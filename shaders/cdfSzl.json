{
    "Shader": {
        "info": {
            "date": "1669365361",
            "description": "Monorail track based on generalized hexagonal Truchet tiles (mouseable, multiple views)",
            "flags": 0,
            "hasliked": 0,
            "id": "cdfSzl",
            "likes": 26,
            "name": "Monorail",
            "published": 3,
            "tags": [
                "truchet",
                "train",
                "track",
                "monorail"
            ],
            "usePreview": 1,
            "username": "dr2",
            "viewed": 369
        },
        "renderpass": [
            {
                "code": "// \"Monorail\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat HexEdgeDist (vec2 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 HsvToRgb (vec3 c);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_CAR 5   // any reasonable value\n#define PLEN 17\n\nvec4 cPath[PLEN], carPos[N_CAR];\nvec3 qHit, sunDir;\nvec2 cId, cMid;\nfloat dstFar, tCur, gSize, tEnd[PLEN + 1], tLen, trVel, cDir, cType, gHt, bHt, trSzFac;\nint idObj;\nconst int idGrnd = 1, idFenc = 2, idRail = 3, idSup = 4, idBld = 5, idMast = 6, \n   idWhl = 7, idCar = 8;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat Ddot (vec2 p)\n{\n  return dot (p, p);\n}\n\nvec3 TruchSDist (vec2 p)\n{ // (from \"Forest Train Ride\")\n  vec2 pc, pc1, pc2, dp;\n  float d, d1, d2, cxy, rc, ac, s, ss;\n  bool ct;\n  ct = (cType == 2. || cType == 4.);\n  if (ct) {\n    pc1 = - vec2 (0., cDir);\n    pc2 = vec2 (sqrt3/2. * sign (p.x), 0.5 * cDir);\n    d1 = Ddot (p - pc1);\n    d2 = Ddot (p - pc2);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = 0.5;\n    d = abs (sqrt (d) - rc);\n  } else {\n    if (cDir != 0.) p = 0.5 * vec2 (p.x - cDir * sqrt3 * p.y, cDir * sqrt3 * p.x + p.y);\n    pc1 = vec2 (sqrt3/2. * sign (p.x), 0.);\n    pc2 = vec2 (sqrt3 * sign (p.x), 0.);\n    d1 = sqrt (Ddot (p - pc1));\n    d2 = abs (sqrt (Ddot (p - pc2)) - 1.5);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = (d == d1) ? 0.: 1.5;\n  }\n  dp = p - pc;\n  cxy = cId.x - cId.y;\n  s = (ct && cxy < 0. || ! ct && abs (cxy - 2.) == 1.) ? -1. : 1.;\n  ac = (0.5 - atan (dp.y, - dp.x) / (2. * pi)) * s;\n  if (! ct && abs (cxy - 2.) <= 1.) ac += 1./6.;\n  ss = sign (length (dp) - rc);\n  return vec3 (d * ss, rc * ss * s, ac);\n}\n\nbool OnTrk (vec2 w)\n{\n  vec2 wp, wm;\n  float cxy;\n  bool cyo, offTrk;\n  cxy = cId.x - cId.y;\n  cyo = (mod (cId.y, 2.) == 1.);\n  wm = Rot2Cs (w, sin (- pi / 3. + vec2 (0.5 * pi, 0.))) - vec2 (0., 0.3);\n  wp = Rot2Cs (w, sin (pi / 3. + vec2 (0.5 * pi, 0.)));\n  offTrk = (cxy == -2. && wm.y > 0. ||\n     ! cyo && (cxy == -3. && w.y > -0.3 || cxy == -2. || cxy == -1. && wm.y > 0. ||\n     cxy == 1. && wm.y < 0. || (cxy == 2. || cxy == 3.) && w.x < 0. || cxy == 4. || cxy == 5.) ||\n     cyo && (cxy == -3. || cxy == 0. && wp.x > 0. || (cxy == 1. || cxy == 2.) && w.x > 0. || \n     cxy == 3. || cxy == 4. && wm.x < 0. || cxy == 5. && wm.y < 0.));\n  return ! offTrk;\n}\n\nvoid SetPath ()\n{\n  float ts, tl;\n  ts = 1.;\n  tl = 1.5;\n  cPath[ 0] = vec4 (0., 0., -1./6., tl);\n  cPath[ 1] = vec4 (1., 0., 1./3., - ts);\n  cPath[ 2] = vec4 (0., 1., 5./6., tl);\n  cPath[ 3] = vec4 (-1., 1., -1./3., ts);\n  cPath[ 4] = vec4 (-1., 2., 1., ts);\n  cPath[ 5] = vec4 (0., 1., - 1./6., tl);\n  cPath[ 6] = vec4 (1., 1., 1./6., tl);\n  cPath[ 7] = vec4 (1., 2., 1., ts);\n  cPath[ 8] = vec4 (2., 1., 1./2., - tl);\n  cPath[ 9] = vec4 (2., 0., -1./2., tl);\n  cPath[10] = vec4 (3., -1., -1./6., tl);\n  cPath[11] = vec4 (4., -1., 1./3., - ts);\n  cPath[12] = vec4 (3., 0., -1./2., - tl);\n  cPath[13] = vec4 (3., 1., 1./2., tl);\n  cPath[14] = vec4 (2., 2., 5./6., tl);\n  cPath[15] = vec4 (1., 2., -1./3., ts);\n  cPath[16] = vec4 (1., 3., 1., ts);\n  tEnd[0] = 0.;\n  for (int k = 0; k < PLEN; k ++) tEnd[k + 1] = tEnd[k] + abs (cPath[k].w);\n  tLen = tEnd[PLEN];\n}\n\nvec2 EvalPPos (float t)\n{\n  vec4 cp;\n  vec2 tp, vd;\n  float tt, r, a, dc;\n  t /= 3.;\n  tp = floor (t / tLen) * vec2 (2.);\n  t = mod (t, tLen);\n  for (int k = 0; k < PLEN; k ++) {\n    if (t >= tEnd[k] && t < tEnd[k + 1]) {\n      cp = cPath[k];\n      tt = 2. * (t - tEnd[k]) / (tEnd[k + 1] - tEnd[k]) - 1.;\n      break;\n    }\n  }\n  tp += cp.xy;\n  if (abs (cp.w) == 1.5) {\n    r = 1.5;\n    dc = sqrt3;\n    a = pi / 6.;\n    tt *= sign (cp.w);\n  } else {\n    r = 0.5;\n    dc = 1.;\n    a = - sign (cp.w) * pi / 3.;\n  }\n  vd = vec2 (-1., 1.) * sin (pi * cp.z + vec2 (0., 0.5 * pi));\n  return (HexToPix (tp) + dc * vd - r * Rot2Cs (vd, sin (tt * a + vec2 (0.5 * pi, 0.)))) * gSize;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar / trSzFac;\n  for (int k = VAR_ZERO; k < N_CAR; k ++) {\n    q = (p - carPos[k].xyz) / trSzFac;\n    q.xz = Rot2D (q.xz, carPos[k].w);\n    d = abs (SmoothMax (PrRoundBox2Df (q.xz, vec2 (0.3, 1.1), 0.4), abs (q.y) - 0.7, 0.1)) - 0.02;\n    d = max (d, - min (PrBox2Df (vec2 (q.x, q.y - 0.25), vec2 (0.4, 0.25)),\n       PrBox2Df (vec2 (abs (q.z) - 0.5, q.y - 0.25), vec2 (0.4, 0.25))));\n    DMINQ (idCar + k);\n    q.z = abs (q.z);\n    q.yz -= vec2 (1.19, 0.6);\n    d = max (max (PrCaps2Df (q.zy, 0.12, 0.9), max (abs (q.x) - 0.13, -0.5 - q.y)),\n       max (min (0.07 - abs (q.x), 0.4 - abs (q.y)), min (0.22 - abs (q.y - 0.7), 0.07 - q.x)));\n    DMINQ (idMast);\n    q.xy -= vec2 (0.02, 0.85);\n    d = PrCylDf (q.yzx, 0.11, 0.12);\n    DMINQ (idWhl);\n  }\n  return dMin * trSzFac;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar / trSzFac;\n  for (int k = VAR_ZERO; k < N_CAR; k ++) {\n    q = (p - carPos[k].xyz) / trSzFac;\n    q.xz = Rot2D (q.xz, carPos[k].w);\n    d = max (PrRoundBox2Df (q.xz, vec2 (0.3, 1.1), 0.4), abs (q.y) - 0.6);\n    DMIN (0);\n  }\n  return dMin * trSzFac;\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvoid SetGConf ()\n{\n  float h, cxy;\n  cMid = HexToPix (cId * gSize);\n  h = Hashfv2 (cId);\n  if (Hashfv2 (17.11 * cId) > 0.4) {\n    cDir = floor (3. * h) - 1.;\n    cType = 3.;\n  } else {\n    cDir = 2. * floor (2. * h) - 1.;\n    cType = 4.;\n  }\n  cxy = cId.x - cId.y;\n  if (cxy == 0.) cType = 1.;\n  else if (abs (cxy) == 1.) cType = mod (cId.x, 2.) + 1.;\n  else if (cxy == -2. || cxy == -3. || cxy == 5.) cType = 2.;\n  else if (cxy == 2. || cxy == 3. || cxy == 4.) cType = 1.;\n  if (cType <= 2.) {\n    if (cType == 1. && (cxy == 1. || cxy == 2. || cxy == 3.)) cDir = 0.;\n    else if (cType == 1. && cxy == 4.) cDir = -1.;\n    else if (cType == 2. && cxy == 5.) cDir = 1.;\n    else cDir = 2. * mod (cId.x, 2.) - 1.;\n  }\n}\n\nfloat GObjDf (vec3 p)\n{\n  vec3 q, cm3;\n  vec2 b;\n  float dMin, d, dt, dWid, eWid, rc, ac, dh, h, a;\n  bool onTrk;\n  dWid = 0.3;\n  eWid = 0.1;\n  dMin = dstFar;\n  if (cType > 0.) {\n    q = p;\n    q.xz = (q.xz - cMid) / gSize;\n    cm3 = TruchSDist (q.xz);\n    dt = gSize * abs (cm3.x);\n    rc = abs (cm3.y);\n    ac = 18. * cm3.z;\n    dh = gSize * HexEdgeDist (q.xz);\n    onTrk = (cType <= 2. && rc != 0. && OnTrk (q.xz));\n    if (onTrk) {\n      a = (fract (3. * rc * ac + 0.5) - 0.5) / 3.;\n      d = PrRoundBox2Df (vec2 (dt, q.y - 0.4), vec2 (0.002, 0.01), 0.001);\n      DMIN (idRail);\n      if (cm3.y < 0.) {\n        b = vec2 (dt - 0.18, q.y - 0.4);\n        d = max (min (min (max (abs (b.x - 0.002) - 0.008, b.y), max (abs (b.y) - 0.006,\n           b.x - 0.01)), max (abs (dot (b, sign (0.25 * pi + vec2 (0.5 * pi, 0.))) + \n           0.05) - 0.005, Maxv2 (b))), abs (a) - 0.0013);\n        d = min (d, max (max (abs (b.x) - 0.02, abs (a) - 0.004), q.y - 0.03));\n        DMIN (idSup);\n      }\n      if (abs (cm3.y) == 1.5 || cm3.x > 0.) {\n        d = max (PrBox2Df (vec2 (dt - dWid - 0.75, fract (rc * ac + 0.5) - 0.5),\n           vec2 (0.2, 0.2)), q.y - ((cm3.y > 0.) ? 4. : 2.) * bHt - gHt);\n        DMIN (idBld);\n      }\n      d = min (length (vec2 (dt - dWid, q.y - 0.1)) - 0.008,\n         max (PrRoundBox2Df (vec2 (dt - dWid, (fract (10. * rc * ac + 0.5) - 0.5) / 10.),\n         vec2 (0.007, 0.002), 0.001), q.y - 0.1));\n      d = max (d, eWid - dh);\n      DMIN (idFenc);\n    }\n    d = q.y - gHt;\n    h = PrBox2Df (vec2 (dh, q.y - gHt), vec2 (eWid, 0.01));\n    if (onTrk) h = min (h, min (PrBox2Df (vec2 (dt, q.y - gHt), vec2 (dWid - 0.1, 0.01)),\n       PrBox2Df (vec2 (abs (abs (dt - 1.05) - 0.3), q.y - gHt), vec2 (0.05, 0.01))));\n    d = SmoothMax (d, - h, 0.01);\n    DMIN (idGrnd);\n  }\n  return dMin;\n}\n\nfloat GObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, cIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = gSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / gSize;\n  pM = HexToPix (PixToHex (ro.xz / gSize));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  cIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 320; j ++) {\n    p = ro + dHit * rd;\n    cId = PixToHex (p.xz / gSize);\n    if (cId != cIdP) {\n      cIdP = cId;\n      SetGConf ();\n    }\n    d = GObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 GObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat GObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  cIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    p = ro + d * rd;\n    cId = PixToHex (p.xz / gSize);\n    if (cId != cIdP) {\n      cIdP = cId;\n      SetGConf ();\n    }\n    h = GObjDf (p);\n    sh = min (sh, smoothstep (0., 0.02 * d, h));\n    d += max (h, 0.01);\n    if (sh < 0.05 || d > gSize) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 GroundCol (vec3 p, inout vec2 vf)\n{\n  vec4 col4, gCol;\n  vec3 cm3;\n  vec2 w;\n  float dt, rc, ac;\n  gCol = vec4 (0.1, 0.5, 0.1, 0.1);\n  if (p.y < 0.024) {\n    col4 = mix (vec4 (0.5, 0.55, 0.5, 0.), gCol, smoothstep (0., 0.2,\n       abs (Rot2D (p.xz, pi / 3.).x) / (5. * gSize) - 1.));\n    vf = vec2 (64., 1.);\n  } else {\n    col4 = gCol * (0.7 + 0.3 * Fbm2 (0.5 * p.xz));\n    vf = vec2 (32., 2.);\n  }\n  w = (p.xz - cMid) / gSize;\n  cm3 = TruchSDist (w);\n  dt = gSize * abs (cm3.x);\n  rc = abs (cm3.y);\n  ac = 18. * cm3.z;\n  if (cType <= 2. && rc != 0. && OnTrk (w)) {\n    if (dt < 0.025 && step (0.3, abs (fract (16. * rc * ac + 0.5) - 0.5)) > 0.)\n       col4 = vec4 (0.5, 0.5, 0.4, 0.);\n  }\n  return col4;\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.3, 0.35, 0.7), vec3 (0.8, 0.8, 0.8),\n     clamp (2. * (Fbm2 (2. * rd.xz / rd.y + 0.1 * tCur) - 0.1) * rd.y, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, rs, cm3, roo;\n  vec2 vf;\n  float dstObj, dstObjB, dstTrObj, sh, dt, rc, ac;\n  int idObjB;\n  bool isLit;\n  vf = vec2 (0.);\n  roo = ro;\n  dstObjB = GObjRay (ro, rd);\n  idObjB = idObj;\n  dstObj = ObjRay (ro, rd);\n  if (dstObjB < dstObj) {\n    dstObj = dstObjB;\n    idObj = idObjB;\n  }\n  isLit = false;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    if (dstObj == dstObjB) {\n      cId = PixToHex (ro.xz / gSize);\n      SetGConf ();\n      vn = GObjNf (ro);\n    } else {\n      vn = ObjNf (ro);\n    }\n    if (idObj == idRail || idObj == idBld || idObj == idSup) {\n      cm3 = TruchSDist ((ro.xz - cMid) / gSize);\n      dt = gSize * abs (cm3.x);\n      rc = abs (cm3.y);\n      ac = 18. * cm3.z;\n    }\n    if (idObj == idFenc) {\n      col4 = vec4 (0.7, 0.7, 0.8, 0.);\n    } else if (idObj == idRail) {\n      col4 = vec4 (0.7, 0.7, 0.75, 0.) * (0.5 + 0.5 * smoothstep (0., 0.001,\n           abs (fract (3. * rc * ac + 0.5) - 0.5) - 0.001));\n    } else if (idObj == idSup) {\n      col4 = vec4 (0.6, 0.6, 0.65, 0.);\n      if (abs (dt - 0.183) < 0.01 && ro.y < 0.395 && ro.y > 0.03)\n         col4 *= 0.8 + 0.2 * step (0.1, abs (fract (128. * ro.y + 0.5) - 0.5));\n    } else if (idObj == idBld) {\n      col4 = vec4 (HsvToRgb (vec3 (Hashfv2 (19.11 * cId), 0.2, 0.9)), 0.) * (0.8 +\n         0.2 * smoothstep (0., 0.002, abs (fract ((ro.y + 0.5 - gHt) / bHt) - 0.5) - 0.02));\n      if (abs (fract ((ro.y - gHt - 0.01) / bHt) - 0.5) < 0.15 &&\n         min (abs (fract (24. * rc * ac + 0.5) - 0.5) - 0.15,\n         abs (abs (dt - 1.05) - 0.07) - 0.02) < 0.) col4 = vec4 (0.3, 0.2, 0., -1.);\n      else vf = vec2 (128., 0.2);\n    } else if (idObj == idGrnd) {\n      col4 = GroundCol (ro, vf);\n    } else if (idObj == idMast) {\n      col4 = vec4 (0.7, 0.8, 0.7, 0.1);\n    } else if (idObj == idWhl) {\n      col4 = vec4 (0.5, 0.5, 0.6, 0.1);\n    } else if (idObj >= idCar) {\n      col4 = vec4 (HsvToRgb (vec3 (float (idObj - idCar) / float (N_CAR), 0.8, 1.)), 0.2);\n      col4 = (qHit.y < 0.65) ? col4 : vec4 (0.7, 0.7, 0.75, 0.2) * (0.95 +\n         0.05 * step (0.1, abs (fract (8. * qHit.x + 0.5) - 0.5)));\n      if (max (PrRoundBox2Df (qHit.xz, vec2 (0.3, 1.1), 0.4), abs (qHit.y) - 0.7) < -0.01)\n         col4 *= 0.5;\n      else if (abs (qHit.y + 0.2) < 0.05) col4 *= 0.8;\n      else if (length (vec2 (qHit.x, qHit.y + 0.4)) < 0.15) {\n        if (ShowInt (vec2 (qHit.x - 0.13 * sign (qHit.z), qHit.y + 0.46),\n           0.25 * vec2 (sign (qHit.z), 0.5), 2.,\n           float (idObj - idCar + 31)) != 0.) col4 = vec4 (vec3 (0.8), -1.);\n        else col4 *= 0.8;\n      }\n      if (abs (qHit.y) < 0.6 && abs (qHit.z) < 1.) col4 *= 0.5 + 0.5 * smoothstep (0., 0.001,\n         min (abs (abs (abs (qHit.z) - 0.5) - 0.5) - 0.03, abs (abs (qHit.y) - 0.6) - 0.015));\n    }\n    if (col4.a >= 0.) {\n      rs = ro + 0.01 * vn;\n      sh = min (ObjSShadow (rs, sunDir), GObjSShadow (rs, sunDir));\n      if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n      isLit = true;\n    } else {\n      col = col4.rgb * (0.2 + 0.8 * max (- dot (rd, vn), 0.));\n    }\n  } else if (rd.y < 0.) {\n    dstObj = - ro.y / rd.y;\n    vn = vec3 (0., 1., 0.);\n    col4 = 0.8 * vec4 (0.1, 0.5, 0.1, 0.);\n    sh = 1.;\n    isLit = true;\n  } else {\n    col = SkyCol (rd);\n  }\n  if (isLit) {\n    col = col4.rgb * (0.3 + 0.2 * max (- dot (sunDir, vn), 0.) +\n       0.7 * sh * max (dot (vn, sunDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n    col = mix (col, SkyCol (rd), 1. - exp (min (0., 1. - 5. * dstObj / dstFar)));\n  }\n  dstTrObj = TrObjRay (roo, rd);\n  if (dstTrObj < min (dstObj, dstFar)) {\n    ro = roo + dstTrObj * rd;\n    vn = TrObjNf (ro);\n    col = mix (0.8 * col, SkyCol (reflect (rd, vn)), 0.3 +\n       0.6 * pow (1. - abs (dot (vn, rd)), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define N_WIN  3\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, vd, pAv;\n  vec2 canvas, uv, uvv, mMid[N_WIN], ut[N_WIN], mSize, msw, pc[3];\n  float el, az, zmFac, asp, sr, t, cGap, nc;\n  int vuId, regId;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./5.) * vec2 (asp, 1.);\n  mMid[0] = (1. - mSize.y) * vec2 (- asp, 1.);\n  mMid[1] = (1. - mSize.y) * vec2 (asp, 1.);\n  mMid[2] = (1. - mSize.y) * vec2 (asp, -1.);\n  for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    for (int k = 0; k < N_WIN; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = k + 1;\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = k + 1;\n      break;\n    }\n  }\n  if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  gSize = 8.;\n  gHt = 0.03;\n  bHt = 0.2;\n  SetPath ();\n  trSzFac = 0.1;\n  trVel = 0.2;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0. && vuId == regId) {\n    az -= 2. * pi * msw.x;\n    el += 0.5 * pi * msw.y;\n  }\n  cGap = 0.3;\n  pAv = vec3 (0.);\n  for (int k = VAR_ZERO; k < N_CAR; k ++) {\n    t = (tCur + 30.) * trVel - float (k) * cGap;\n    for (int j = VAR_ZERO; j < 3; j ++)\n       pc[j] = EvalPPos (t + ((j > 0) ? sign (float (j) - 1.5) * 0.06 : 0.));\n    carPos[k].xz = pc[0];\n    carPos[k].y = 0.22;\n    pAv += carPos[k].xyz;\n    vd.xz = pc[2] - pc[1];\n    carPos[k].w = 0.5 * pi - atan (vd.z, vd.x);\n  }\n  nc = float (N_CAR);\n  pAv /= nc;\n  t = (tCur + 30.) * trVel;\n  if (vuId == 0 || vuId == 3) {\n    if (uv.x / asp > -1.+ 2. * SmoothBump (0.25, 0.75, 0.01, fract (0.025 * tCur)))\n       vuId = 3 - vuId;\n    ro.xz = EvalPPos (t - ((vuId == 0) ? nc + 0.5 : -1.5) * cGap);\n    ro.x += 0.1;\n    ro.y = (vuId == 0) ? 0.2 : 0.5;\n    vd = normalize (((vuId == 0) ? carPos[N_CAR - 1].xyz : carPos[0].xyz) - ro);\n    az += atan (vd.z, - vd.x) - 0.5 * pi;\n    el += asin (vd.y);\n    el = clamp (el, -0.15 * pi, 0.15 * pi);\n    zmFac = 3.5;\n    dstFar = 12. * gSize;\n  } else if (vuId == 1) {\n    ro = vec3 (0., 30., (-3. * sqrt3 + (2. / tLen) * t) * gSize);\n    ro.xz = Rot2D (ro.xz, - pi / 3.);\n    ro.xz += 0.01;\n    ro.x += 1.6 * gSize;\n    az += pi / 3.;\n    el -= 0.2 * pi;\n    el = clamp (el, -0.4 * pi, -0.13 * pi);\n    zmFac = 3.;\n    dstFar = 40. * gSize;\n  } else if (vuId == 2) {\n    ro = vec3 (0., 20., (-1.5 * sqrt3 + (2. / tLen) * t) * gSize);\n    ro.xz = Rot2D (ro.xz, - pi / 3.);\n    ro.xz += 0.01;\n    ro.x -= 1.5 * gSize;\n    vd = normalize (pAv - ro);\n    az = atan (vd.z, - vd.x) - 0.5 * pi;\n    el = asin (vd.y);\n    zmFac = 30.;\n    dstFar = 30. * gSize;\n  }\n  vuMat = StdVuMat (el, az);\n  sunDir = normalize (vec3 (0., 2., -1.));\n  sunDir.xz = Rot2D (sunDir.xz, - pi / 3.);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (-2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 3.) col = vec3 (0.7, 0.3, 0.3);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat DigSeg (vec2 q)\n{\n  q = 1. - smoothstep (vec2 (0.), vec2 (0.04, 0.07), abs (q) - vec2 (0.13, 0.5));\n  return q.x * q.y;\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  vec2 vp, vm, vo;\n  float d;\n  int k, kk;\n  vp = vec2 (0.5, 0.5);\n  vm = vec2 (-0.5, 0.5);\n  vo = vp - vm;\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (Minv2 (q) >= 0. && Maxv2 (q) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log2 (val) / log2 (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}