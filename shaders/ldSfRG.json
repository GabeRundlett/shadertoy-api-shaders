{
    "Shader": {
        "info": {
            "date": "1500856354",
            "description": "Recreation of the best introduction in science fiction. Reference [url]https://www.youtube.com/watch?v=HnDtvZXYHgE[/url]",
            "flags": 96,
            "hasliked": 0,
            "id": "ldSfRG",
            "likes": 63,
            "name": "[SH17B] The Next Generation",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "space",
                "sh17b",
                "startrek"
            ],
            "usePreview": 1,
            "username": "Klems",
            "viewed": 16334
        },
        "renderpass": [
            {
                "code": "\n#define PI 3.14159265359\n#define PHI 1.61803398875\n\n#define SAMPLES 20\n#define BLOOM_RADIUS 20.0\n\nvec3 hash33(vec3 p3){\n    #define HASHSCALE3 vec3(.1031, .1030, .0973)\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tvec2 uv = fragCoord / iResolution.xy;\n    vec4 value = texture(iChannel0, uv);\n\tvec3 rnd = hash33(vec3(fragCoord, iFrame));\n    \n    fragColor.rgb = value.rgb;\n    \n    \n    vec3 bloom = vec3(0);\n    float totfac = 0.0;\n    \n    // bloom\n    for (int i = 0 ; i < SAMPLES ; i++) {\n        \n        float theta = 2.0*PI*PHI*float(i);\n        theta += rnd.x*2.0*PI;\n        float radius = sqrt(float(i)) / sqrt(float(SAMPLES));\n        radius *= BLOOM_RADIUS;\n        \n        vec2 offset = vec2(cos(theta), sin(theta))*radius;\n        vec4 here = texture(iChannel0, (fragCoord+offset)/iResolution.xy);\n        \n        float fact = smoothstep(BLOOM_RADIUS, 0.0, radius);\n        \n        bloom += here.rgb*0.05*fact;\n        totfac += fact;\n    }\n    \n    bloom /= totfac;\n    fragColor.rgb += bloom;\n    \n    // clamp values, then gamma correction\n    fragColor.rgb = clamp(fragColor.rgb, vec3(0), vec3(1));\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n    \n    // vignette\n    vec2 p = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), dot(p, p)*0.1);\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define PI 3.14159265359\n#define SQ 0.70710678118\n#define BACKGROUND_SS 2\n#define rot(a) mat2(cos(a + PI*0.25*vec4(0,6,2,0)))\n\n// scenes parameters\nvec4 sunPosition = vec4(0);\nvec3 sunStrength = vec3(0);\nfloat time = 0.0;\n\n// using during warp scenes\nfloat warp = 0.0;\n\n// camera controls\nvec3 sceneFrom = vec3(0);\nvec3 shipFrom = vec3(0);\nvec3 forward = vec3(0);\nvec3 up = vec3(0);\n\n// used for the travelling stars\nfloat starsX = 0.0;\n\n// current sequence\nint sequence = 0;\n\n\nbool intSphere( in vec4 sp, in vec3 ro, in vec3 rd, out float t, out vec3 n ) {\n    vec3  d = ro - sp.xyz;\n    float b = dot(rd,d);\n    float c = dot(d,d) - sp.w*sp.w;\n    float tt = b*b-c;\n    if ( tt > 0.0 ) {\n        t = -b-sqrt(tt);\n        n = (ro+rd*t-sp.xyz)/sp.w;\n        if (t>0.0) return true;\n    }\n    return false;\n}\n\nbool intPlane( in vec4 pl, in vec3 ro, in vec3 rd, out float t ) {\n    float tt = -(dot(pl.xyz,ro)+pl.w)/dot(pl.xyz,rd);\n    if (tt > 0.0) {\n        t = tt;\n        return true;\n    }\n    return false;\n}\n\n// smooth 3D noise\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = texture( iChannel0, (uv+0.5) / 256.0 ).yx;\n    return mix( rg.x, rg.y, f.z );\n}\n\n// like abs but with a rounded corner instead\nfloat smoothAbs(float x, float radius) {\n    float ab = abs(x);\n    if ( ab > SQ*radius ) return ab;\n    float xCirc = x/radius;\n    return 2.0*SQ*radius - sqrt(1.0 - xCirc*xCirc)*radius;\n}\n\nfloat smin( in float a, in float b, in float r ) {\n    return (a + b - smoothAbs(a - b, r*2.0))*.5;\n}\n\nfloat smax( in float a, in float b, in float r ) {\n    return (a + b + smoothAbs(a - b, r*2.0))*.5;\n}\n\n// approximation of the distance to an ellipsoid\nfloat sdEllipsoid( in vec3 p, in vec3 r ) {\n    return (length(p/r)-1.0) * min(min(r.x,r.y),r.z);\n    //return (length(p/r)-1.0) / length(normalize(p)/r);    \n}\n\n// distance to a box\nfloat sdBox( in vec3 p, in vec3 b ) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat hash11(float p) {\n    #define HASHSCALE1 .1031\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3){\n    #define HASHSCALE3 vec3(.1031, .1030, .0973)\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// NCC-1701-D\nfloat ncc( in vec2 uv ) {\n    const ivec2 ncc1701d[] = ivec2[](ivec2(14,11),ivec2(3,11),ivec2(3,11),ivec2(13,13),ivec2(1,12),\n                                     ivec2(7,12),ivec2(0,12),ivec2(1,12),ivec2(13,13),ivec2(4,11));\n    uv += vec2(5.0, 0.5);\n    float letter = 0.0;\n    ivec2 iuv = ivec2(floor(uv));\n    vec2 fuv = fract(uv);\n    if( iuv.x>=0 && iuv.x<=9 && iuv.y==0 ) {\n        fuv = 0.5 + vec2(0.5,1.0)*(fuv-0.5);\n        float te = texture( iChannel1, ( vec2(ncc1701d[iuv.x]*64) + fuv*64.0 )/1024.0 ).w;\n        letter = smoothstep( 0.02, 0.0, te-0.5 );\n    }\n    return letter;\n}\n\n// USS ENTERPRISE\nfloat enterprise( in vec2 uv ) {\n    const ivec2 ncc1701d[] = ivec2[](ivec2(5,10),ivec2(3,10),ivec2(3,10), ivec2(0,13),\n                                     ivec2(5,11),ivec2(14,11),ivec2(4,10),ivec2(5,11),ivec2(2,10),\n                                     ivec2(0,10),ivec2(2,10),ivec2(9,11),ivec2(3,10),ivec2(5,11));\n    uv += vec2(7.0, 0.5);\n    float letter = 0.0;\n    ivec2 iuv = ivec2(floor(uv));\n    vec2 fuv = fract(uv);\n    if( iuv.x>=0 && iuv.x<=13 && iuv.y==0 ) {\n        fuv = 0.5 + vec2(0.5,1.0)*(fuv-0.5);\n        float te = texture( iChannel1, ( vec2(ncc1701d[iuv.x]*64) + fuv*64.0 )/1024.0 ).w;\n        letter = smoothstep( 0.02, 0.0, te-0.5 );\n    }\n    return letter;\n}\n\n\n// window texture\nvoid windows( in vec2 inWindow, float noWindow, inout vec4 diffuse, inout vec4 emissive) {\n\tvec2 window = floor(inWindow)+0.5;\n    inWindow -= window;\n\n    float border = smoothstep(0.95, 1.0, abs(sin((inWindow.x)*PI)))*noWindow;\n    float win = noWindow*(1.0-border);\n\n    vec4 rnd = texture(iChannel0, window/iChannelResolution[0].xy);\n    float spec = 0.0;\n    if (rnd.x < 0.7) {\n        // add windows\n        float deWin = sdBox( vec3(inWindow, 0), vec3(0.1, 0.1, 1) ) - 0.1;\n        float winScale = smoothstep(0.1, 0.0, deWin)*win;\n        spec = winScale;\n        diffuse.rgb = mix(diffuse.rgb, diffuse.rgb*.2, winScale);\n        // lights on some windows\n        if (rnd.y < 0.4) {\n            emissive.rgb += smoothstep(0.0, -0.1, deWin)*winScale*vec3(1, 1, 0.7);\n        }\n    }\n\n    diffuse = mix(diffuse, diffuse*0.8, border);\n    diffuse.a = mix(diffuse.a, 0.8, spec);\n}\n\n// secondary hull\nfloat hullDE( in vec3 p, in bool doColor, out vec4 diffuse, out vec4 emissive  ) {\n    \n    vec3 inBot = p-vec3(13, 0, -2.5);\n    inBot.z = max(0.0, abs(inBot.z)+1.0)*sign(inBot.z);\n    if (inBot.z > 0.0) inBot.z = max(1.0, inBot.z-0.5);\n    vec3 botDim = vec3(6.0 + smoothstep(0.0, -2.0, inBot.x)*8.0, 6, 3);\n    float bot = sdEllipsoid(inBot, botDim);\n    \n    vec3 inCo = p-vec3(10.5, 0, 1);\n    float co = sdBox(inCo, vec3(10, 5.0, 3));\n    vec3 inHoles = inCo;\n    inHoles.x -= 10.0;\n    inHoles.y = abs(inHoles.y)-5.3;\n    inHoles.z += 3.0;\n    float holes = sdEllipsoid(inHoles, vec3(20, 5, 7));\n    co = max(co, -holes);\n    \n    float coBack = dot(normalize(vec3(-1, 0, 1.2)), inCo)-1.0;\n    float coFront = dot(normalize(vec3(2.1, 0, -1.0)), inCo)-7.0;\n    co = max(co, coBack);\n    \n    float de = bot;\n    de = smin(de, co, 1.0);\n    de = max(de, coFront);\n    \n    // deflector dish\n    const vec3 dishDim = vec3(2, 4, 1.2);\n    vec3 inDish = p-vec3(17, 0, -2.5);\n    float dish = sdEllipsoid(inDish, dishDim);\n    de = max(de, -dish);\n    \n    if (doColor) {\n        \n        diffuse = vec4(0.5, 0.6, 0.7, 0.2);\n        emissive = vec4(0);\n        \n        vec2 inWindow = vec2(0);\n        float noWindow = 1.0;\n        \n        if (co > bot) {\n            vec3 inSecon = inBot/botDim;\n            float theta = atan(inSecon.x, inSecon.y);\n            inWindow = vec2(theta/PI*17.0, inSecon.z*13.0);\n        } else {\n            inWindow = p.xz*1.5;\n            noWindow = smoothstep(0.0, -0.2, coBack);\n        }\n        \n        noWindow *= smoothstep(0.0, -0.2, coFront);\n        noWindow *= smoothstep(0.4, 0.5, abs(inCo.z+3.25));\n        noWindow *= smoothstep(0.1, 0.2, dish);\n        \n        float trans = smoothstep(0.02, 0.09, abs(co-bot));\n        noWindow *= trans;\n        \n        windows( inWindow, noWindow, diffuse, emissive);\n        diffuse.a *= (0.8+trans*0.2);\n        \n        // do the dish\n        float dishFX = inDish.x+3.0;\n        inDish.x = 0.0;\n        dishFX = max(sdEllipsoid(inDish, dishDim), -dishFX);\n        dishFX = smoothstep(0.1, -0.3, dishFX);\n        // remove some diffuse\n        diffuse.rgb = mix(diffuse.rgb, diffuse.rgb*vec3(0.1, 0.2, 0.3), dishFX);\n        \n        // don't light in the center\n        float lenFX = length(inDish.yz/dishDim.yz);\n        dishFX *= smoothstep(0.1, 0.2, abs(lenFX-0.7));\n        dishFX *= smoothstep(0.3, 0.4, lenFX);\n        \n        emissive.rgb += dishFX*vec3(0.01, 0.05, 1.0)*20.0;\n    }\n    \n\treturn de;\n}\n\n// saucer section\nfloat saucerDE( in vec3 p, in bool doColor, out vec4 diffuse, out vec4 emissive  ) {\n    \n    // saucer section\n    const vec3 sauDim = vec3(15, 18, 3);\n    vec3 inSau = p-vec3(26, 0, 3.5);\n    float sauPlane = -inSau.z;\n    \n    vec2 inSau2D = inSau.xy/sauDim.xy;\n    float inSau2DL = length(inSau2D);\n    float rim = smoothstep(0.1, 0.12, abs(inSau2DL-.6)+.1);\n\n    inSau.z = max(0.0, abs(inSau.z)+1.0)*sign(inSau.z);\n    if (inSau.z > 0.0) inSau.z = max(1.0, inSau.z-0.5);\n    float saucer = sdEllipsoid(inSau, vec3(15, 18, 3));\n    float saucer2 = saucer;\n    saucer = max(saucer, sauPlane);\n    saucer = smin(saucer, saucer2+0.7, 0.1);\n    \n    // add the bridge\n    vec3 inBridge = inSau - vec3(0, 0, 3);\n    float bridge = sdEllipsoid(inBridge, vec3(2.5, 3.2, 3));\n    // blend it with the shuttle bay\n    vec3 inShuttle = inSau - vec3(-5.0, 0, 2);\n    inShuttle.y = smoothAbs(inShuttle.y, 1.0);\n    inShuttle.xy *= rot(-0.1);\n    inShuttle.xz *= rot(0.1);\n    float shuttle = sdBox(inShuttle, vec3(4, 2, 1))-0.1;\n    bridge = smin(bridge, shuttle, 0.5);\n    bridge = smax(bridge, inBridge.z-0.3, 0.1);\n    // add the rim on the top\n    if (inSau.z > 0.0) saucer += rim*0.1*smoothstep(0.0, 1.0, bridge) - 0.1;\n    // add the saucer with the bridge\n    saucer = smin(saucer, bridge, 0.3);\n    \n    if (doColor) {\n        \n        diffuse = vec4(0.5, 0.6, 0.7, 0.2);\n        emissive = vec4(0);\n                \n        vec2 inWindow = vec2(atan(inSau2D.y, inSau2D.x)/PI*50.0, inSau2DL*10.0+1.0);\n        float noWindow = rim;\n        noWindow *= smoothstep(0.92, 0.91, inSau2DL);\n        noWindow *= smoothstep(1.9, 2.0, bridge);\n        if (inSau.z < 0.0) noWindow *= smoothstep( 0.09, 0.08, abs(inSau2DL-0.6) );\n        \n        // do some checkered panels\n        vec2 panels = floor(inWindow*vec2(0.2, 0.5));\n        float check = mod(panels.x+panels.y, 2.0);\n        check *= smoothstep(0.9, 1.0, bridge);\n        diffuse *= (check*.1+.9);\n        \n        float letter = 0.0;\n        \n        vec2 inLetter = inWindow;\n        if (inSau.z > 0.0) {\n            inLetter -= vec2(0, 5.5);\n            inLetter *= vec2(0.5, -0.8);\n            noWindow *= smoothstep(0.0, 0.1, sdBox(vec3(inLetter-vec2(0, 1), 0), vec3(5.5, 1.5, 1)));\n            vec2 inEnt = inLetter-vec2(0, 0.7);\n            letter += enterprise(inEnt*vec2(1.7, 2.0));\n        } else {\n            inLetter -= vec2(0, 5.5);\n            inLetter *= vec2(0.5, 0.8);\n            \n        }\n        \n        letter += ncc(inLetter);\n        windows( inWindow, noWindow, diffuse, emissive);\n        diffuse.rgb = mix(diffuse.rgb, vec3(0.15, 0.02, 0.02), letter);\n    }\n\t    \n    return saucer;\n}\n\n// arms connecting the nacelles to the stardrive section\nfloat armsDE( in vec3 p, in bool doColor, out vec4 diffuse, out vec4 emissive ) {\n    \n    // start with the nacelles arms\n    float arms = sdBox(p, vec3(6, 7.5, 0.5))-2.0;\n    arms = max(arms, 2.0-sdBox(p-vec3(0, 0, 1), vec3(99, 7, 1)));\n    \n    vec3 inHoles = p-vec3(6, 0, -4.0);\n    inHoles.y = abs(inHoles.y)-8.0;\n    float holes = sdEllipsoid(inHoles, vec3(4, 5, 5));\n    \n    float by = abs(p.y);\n    float backLen = 1.0 + smoothstep(1.0, 7.0, by)*0.7;\n    float back = dot(normalize(vec3(1, 0, -0.7)), p) + backLen;\n   \tarms = max(arms, -back);\n    arms = max(arms, -holes);\n    arms = max(arms, p.z-0.5);\n    \n    if (doColor) {\n        vec3 inCheck = p;\n        inCheck.x += backLen;\n       \tinCheck = floor(inCheck*0.5);\n        float check = mod(inCheck.x+inCheck.y+inCheck.z, 2.0);\n        \n        diffuse = vec4(0.5, 0.6, 0.7, 0.2);\n        diffuse *= check*.1+.9;\n        emissive = vec4(0);\n    }\n    \n    return arms;\n}\n\n// nacelles\nfloat nacellesDE( in vec3 p, in bool doColor, out vec4 diffuse, out vec4 emissive  ) {\n    \n    p -= vec3(2.5, 0, 1);\n    p.y = abs(p.y)-9.25;\n    \n    float s = smoothstep(0.0, 20.0, abs(p.x+2.0));\n    float de = sdBox(p, vec3(8, 1.0 - s * 1.0, 0.3-s*.5))-1.0;\n    float blues = sdBox(p-vec3(-4, 0, 0), vec3(8, 20, 0.0 + 0.6*smoothstep(0.0, 3.0, p.x)))-0.5;\n    float blueLight = smoothstep(0.0, -0.2, blues);\n    float red = sdBox(p-vec3(+8, 0, 0), vec3(2, 20, 0))-1.1;\n    float redLight = smoothstep(0.0, -0.2, red);\n    \n    de += blueLight*.1;\n    de += redLight*.1;\n    \n    if (doColor) {\n        diffuse = vec4(0.5, 0.6, 0.7, 0.2);\n        emissive = vec4(0);\n        \n        diffuse = mix(diffuse, diffuse*vec4(0.1, 0.2, 0.3, 0.0), blueLight);\n        diffuse = mix(diffuse, diffuse*vec4(0.3, 0.1, 0.1, 0.0), redLight);\n        \n        \n        float more = smoothstep(0.0, 2.0, warp);\n        \n        emissive.rgb += smoothstep(0.1, -1.0, blues)*vec3(0.01, 0.05, 1.0)*(20.0+more*150.0);\n        emissive.rgb += smoothstep(0.05, -1.0, red)*vec3(1.0, 0.02, 0.01)*5.0;\n        \n    }\n    \n    return de;\n    \n}\n\n\n// distance/color function to a galaxy class starship\nfloat de( in vec3 p, in bool doColor, out vec4 diffuse, out vec4 emissive ) {\n    \n    // flip the ship\n    //p.xyz = p.yxz;\n    \n    float multX = 1.0;\n    if (sequence == 1) {\n        // change shape during warp\n        multX = 1.0 + (smoothstep(2.0, 2.3, warp) - smoothstep(2.3, 3.0, warp))*1.5;\n        p.x /= multX;\n    }\n    \n    // don't go through the expensive distance field when far away from the object\n    diffuse = emissive = vec4(-1);\n    float bbBox = sdBox(p, vec3(25.0*multX, 18, 7));\n    if (bbBox > 1.0) return bbBox;\n    \n    // recenter the ship around the box\n    diffuse = emissive = vec4(0);\n    p += vec3(17, 0, 1);\n    \n    // start with the secondary hull\n    float de = hullDE(p, doColor, diffuse, emissive);\n    vec4 newDiff = vec4(0), newEmissive = vec4(0);\n    \n    // then the saucer section\n    float saucer = saucerDE(p, doColor, newDiff, newEmissive);\n    if (saucer < de) {\n        diffuse = newDiff;\n        emissive = newEmissive;\n        de = smin(de, saucer, 0.5);\n    }\n    \n    // the arms connecting the nacelles to the secondary hull\n    float arms = armsDE(p, doColor, newDiff, newEmissive);\n    if (arms < de) {\n        diffuse = newDiff;\n        emissive = newEmissive;\n        de = smin(de, arms, 0.3);\n    }\n    \n    // the nacelles\n    float nacelles = nacellesDE(p, doColor, newDiff, newEmissive);\n    if (nacelles < de) {\n        diffuse = newDiff;\n        emissive = newEmissive;\n        de = nacelles;\n    }\n    \n    // thrusters\n    vec3 inThrust = p - vec3(12.5, 0, 4);\n    inThrust.y = abs(inThrust.y)-6.7;\n    float thrust = sdBox(p - vec3(9, 0, 0.5), vec3(1, 1.5, 0.4))-0.2;\n    vec3 inSecThrust = inThrust - vec3(1.5, -0.7, -0.25);\n    float secThrust = sdBox(inSecThrust, vec3(1.0, 1.5, 0.0))-0.2;\n    float thrustHole = sdBox(inThrust, vec3(1, 1.5, 1));\n    \n    de = max(de, -thrustHole);\n\n    if (doColor) {\n        if ( thrust < de || secThrust < de) {\n        \t\n            diffuse = vec4(0.5, 0.6, 0.7, 0.2)*0.5;\n        \temissive = vec4(0);\n            \n            \n            float red = 0.0;\n            \n            if (thrust < secThrust) {\n                red = inThrust.x+4.5;\n            } else {\n                red = inSecThrust.x+1.0;\n            }\n            \n            diffuse = mix(diffuse, diffuse*vec4(0.3, 0.1, 0.1, 0.0), smoothstep(0.0, -0.1, red));\n            emissive += smoothstep(-0.05, -1.0, red)*vec4(1.0, 0.02, 0.01, 0.0)*120.0;\n\n    \t}\n    }\n\n    de = min(de, thrust);\n    de = min(de, secThrust);\n\n    return de/multX;\n} \n\n// normal function\nvec3 normal(vec3 p) {\n    const vec3 e = vec3(0.0, 0.001, 0.0);\n    vec4 dummy = vec4(0);\n    float d = de(p, false, dummy, dummy);\n\treturn normalize(vec3(\n\t\td-de(p-e.yxx, false, dummy, dummy),\n\t\td-de(p-e.xyx, false, dummy, dummy),\n\t\td-de(p-e.xxy, false, dummy, dummy)));\t\n}\n\n// shadows function\nfloat shadows( vec3 p, vec3 dir, float sinTheta ) {\n    vec4 dummy = vec4(0);\n    float totdist = 0.0;\n    float opa = 1.0;\n    for (int i = 0 ; i < 50 ; i++) {\n        vec3 here = p+dir*totdist;\n        float d = de(here, false, dummy, dummy);\n        float prox = d / (sinTheta*totdist);\n        float alpha = clamp(prox * -0.5 + 0.5, 0.0, 1.0);\n        opa = min(opa, 1.0-alpha);\n        //opa *= 1.0-alpha;\n        if (opa < 0.01) break;\n      \ttotdist += max(0.3, d);\n    }\n    return opa;\n}\n\n// filtered starfield\nvec3 starfield( in vec3 dir, float position, float speed ) {\n    dir.xyz = dir.yxz; // i'm lazy\n    vec3 ret = vec3(0);\n    vec2 dim = vec2(0.15, 0.15+speed)*0.01;\n    for (float radius = 1.0 ; radius < 7.5 ; radius ++) {\n        float x = atan(dir.x, dir.z)/PI;\n        float scale = (radius / length(dir.xz));\n        float y = dir.y * scale + position;\n        vec2 uv = vec2(x, y)*vec2(6.0*radius, 1);\n        vec2 cen = floor(uv)+0.5;\n        vec3 rnd = hash33(vec3(cen, radius));\n        cen += (2.0*rnd.xy-1.0) * (0.5 - dim);\n        vec2 inStar = uv-cen;\n        float dist = sdEllipsoid(vec3(inStar, 0), vec3(dim, 1));\n        // get derivative, correct with the atan\n        float delta = length(fwidth(abs(uv)));\n        ret += smoothstep(delta/scale*2.0, 0.0, dist) / (scale*scale);\n    }\n    return ret;\n}\n\n// raytrace to a sun\nfloat traceSun( in vec3 from, in vec3 dir, in vec4 sun ) {\n    vec3 sunPos = sun.xyz;\n    float sunRadius = sun.w;\n    vec3 inSun = from-sunPos;\n    float distToSun = inversesqrt(dot(inSun, inSun));\n    float theta = acos(dot(-dir, inSun*distToSun));\n    float maxTheta = atan(sunRadius*distToSun);\n    return exp((maxTheta-theta)/sunRadius/distToSun);\n}\n\n// planets palette\nvec3 pal( in float t ) {\n    const vec3 a = vec3(0.3,0.2,0.1);\n    const vec3 b = vec3(0.2,0.1,0.1);\n    const vec3 c = vec3(0.4,2.7,4.2);\n    return a + b*cos( 6.28318*(c*t) );\n}\n\n// raytrace to a planet\nvoid tracePlanet( inout float maxDist, inout vec3 rgb,\n                 in vec3 from, in vec3 dir, in vec4 planet, in float seed ) {\n    float dist = 0.0;\n    vec3 norm = vec3(0);\n    \n    if ( intSphere(planet, from, dir, dist, norm) ) {\n        if (dist < maxDist) {\n            maxDist = dist;\n            \n            // change color\n            vec3 toSun = normalize(sunPosition.xyz-(from+dir*dist));\n            \n            float perl = 0.0;\n            perl += noise(norm*1.0)*2.0;\n            perl += noise(norm*3.0)*1.0;\n            perl += noise(norm*6.0)*1.0;\n            perl += noise(norm*12.0)*0.5;\n            perl /= 4.5;\n            vec3 baseColor = pal(seed+perl*0.4);\n            \n            // add spiral clouds\n            vec3 inClouds = norm;\n            inClouds.xy *= rot(inClouds.z*2.0+time*0.2);\n            float clouds = 1.0;\n            clouds *= sin(atan(inClouds.x, inClouds.y)*5.0)*0.5+0.5;\n            clouds *= smoothstep(1.0, 0.9, abs(inClouds.z));\n            clouds *= noise(inClouds*5.0);\n            \n            baseColor = mix(baseColor, vec3(1), clouds*0.5);\n            \n            // lighting\n            rgb = baseColor * vec3(max(0.0, dot(toSun, norm)))*sunStrength;\n            \n        }\n    }\n}\n\n\n// introduction background\nvec3 background01( in vec3 from, in vec3 dir ) {\n    vec3 base = starfield( dir, 0.0, 0.0 );\n    base += traceSun(from, dir, vec4(0, 0, 0, 1)) * vec3(1.0, 0.8, 0.7) * 3.0;\n    base += traceSun(from, dir, vec4(-5, -80, -10, 0.5)) * vec3(0.35, 0.3, 1.0) * 2.0;\n    \n    // add a nebula\n    dir.yz *= rot(-0.2);\n    dir.xy *= rot(0.7);\n    \n    vec2 inNebula = dir.xz;\n    float radNeb = 1.0 + sin(atan(inNebula.x, inNebula.y)*8.0)*0.05;\n    float nebulaDist = length(inNebula/vec2(0.07, 0.4)) - radNeb;\n    float nebula = exp(-1.0-nebulaDist*3.0);\n    \n    float perl = 0.0;\n    perl += noise(dir*10.0)*3.0;\n    perl += noise(dir*30.0)*1.0;\n    perl += noise(dir*60.0)*0.5;\n    perl /= 4.5;\n    \n    vec3 newDir = dir;\n    newDir.z *= 0.2;\n    newDir.z += time*0.01;\n    \n    float perl2 = 0.0;\n    perl2 += noise(newDir*32.0)*2.0;\n    perl2 += noise(newDir*80.0)*1.0;\n    perl2 /= 3.0;\n    \n    perl *= perl2;\n    \n    vec3 nebColor = mix(vec3(0.2, 0.15, 0.5), vec3(0.15, 0.3, 0.7), noise(dir*20.0));\n    \n    base += nebula*perl*nebColor;\n    base += exp(-4.0-nebulaDist*6.0)*vec3(0.17, 0.15, 0.3);\n    \n    return base;\n}\n\nvec3 glare( in vec3 dir ) {\n    // add a glare during warp\n    vec2 inGlare = dir.yz;\n    float radGl = 0.07 + sin(atan(inGlare.x, inGlare.y)*8.0)*0.01;\n    inGlare.x *= 3.0;\n    inGlare *= 1.3;\n    float glareDist = length(inGlare)-radGl;\n    \n    float glare = exp(-glareDist*20.0);\n    \n    glare *= smoothstep(4.2, 4.6, warp);\n    glare *= smoothstep(7.0, 5.0, warp);\n    \n    return glare*vec3(0.55, 0.5, 1.0);\n}\n\n\n\n// second background, enterprise goes to warp\nvec3 background02( in vec3 from, in vec3 dir ) {\n    \n    float dist = 9e9;\n    vec3 base = starfield( dir, 0.0, 0.0 );\n    \n    base += traceSun(from, dir, sunPosition)*sunStrength*15.0;\n    \n    const vec4 gasGiant = vec4(3, 0, 0, 5);\n    tracePlanet( dist, base, from, dir, gasGiant, -0.1 );\n    tracePlanet( dist, base, from, dir, vec4(12, -44, 0, 2), 1.0 );\n    tracePlanet( dist, base, from, dir, vec4(25, -57, 3, 2.5), 2.0 );\n    \n    // trace rings around the first planet\n    float distRing = 0.0;\n    vec3 dirPlane = normalize(vec3(0.2, -0.3, 1));\n    \n    bool hitRing = intPlane( vec4(dirPlane, -dot(dirPlane, gasGiant.xyz)), from, dir, distRing );\n    if (hitRing && distRing < dist) {\n        \n        vec3 onRing = from+dir*distRing;\n        float len = length(onRing - gasGiant.xyz);\n        \n        float ringAlpha = smoothstep(6.0, 6.5, len) * smoothstep(10.5, 10.0, len);\n        vec3 baseColor = vec3(0.9);\n        baseColor = mix(vec3(0.3, 0.2, 0.1), vec3(0.1, 0.0, 0.0), \n                        (sin(len*5.0)+sin(len*12.13))*0.3+.5 );\n        baseColor *= sunStrength;\n        ringAlpha = ringAlpha*smoothstep(0.0, 0.1, (sin(len*3.124)*0.5+0.5));\n        \n        float dummy1 = 0.0;\n        vec3 dummy2 = vec3(0);\n        if ( intSphere(gasGiant, onRing, normalize(sunPosition.xyz-onRing), dummy1, dummy2) ) {\n            baseColor *= 0.0;\n        }\n        \n        base = mix(base, baseColor, ringAlpha);\n    }\n    \n    // add a glare during warp\n\tbase += glare(dir);\n    \n    return base;\n}\n\n// third background, moving stars\nvec3 background03( in vec3 from, in vec3 dir ) {\n    vec3 base = starfield( dir, starsX, 0.3 + smoothstep(1.0, 3.0, warp) );\n    \n    // add a glare during warp\n\tbase += glare(dir);\n    \n    return base;\n}\n\n\n// handle camera positions, background, lightsources, etc\nint sequencer( in float time ) {\n    \n    int sequence = 0;\n    \n    if (time < 9.0) {\n        sequence = 0;\n    } else if (time < 52.0) {\n        sequence = 1;\n    } else if (time < 58.0) {\n        sequence = 2;\n    } else if (time < 62.0) {\n        sequence = 3;\n    } else if (time < 67.0) {\n        sequence = 4;\n    } else {\n        sequence = 5;\n    }\n    \n    if (sequence == 0) {\n        \n        // introduction with fading into star\n        shipFrom = vec3(0, 1000, 0);\n        sceneFrom = vec3(0, -200, 0);\n        sceneFrom.y += time*22.5;\n        forward = vec3(0, 1, 0);\n        forward.xy*=rot(smoothstep(0.0, 9.0, time)*0.7-0.7);\n        forward.xz*=rot(smoothstep(0.0, 9.0, time)*0.9-0.9);\n        up = vec3(0, 0.5, 1);\n        \n    } else if (sequence == 1) {\n        \n        // planetary system + camera moving toward the ship + warp speed\n        \n        // add the main lightsource\n        sunPosition = vec4(60, -35, 2, 0.5);\n\t\tsunStrength = vec3(1.5, 1.5, 1.9)*2.0;\n    \t\n        shipFrom = vec3(80, -45, -5);\n        sceneFrom = vec3(7, -70, 7);\n        sceneFrom.y += smoothstep(9.0, 35.0, time)*60.0;\n        \n        forward = vec3(0, 1, 0);\n        \n        forward.xy*=rot(0.8 - smoothstep(9.0, 27.0, time)*0.6);\n        forward.xz*=rot(0.3 + smoothstep(9.0, 27.0, time)*1.2);\n        \n        // rotate toward the ship\n        forward.xy *= rot(-smoothstep(28.0, 35.0, time)*1.0);\n        forward.xz *=rot(smoothstep(27.0, 34.0, time)*0.3);\n        // travel alongside it\n        shipFrom.x -= smoothstep(33.0, 48.0, time)*130.0;\n        shipFrom.z += smoothstep(37.0, 47.0, time)*15.0;\n        shipFrom.y += smoothstep(40.0, 47.5, time)*34.0;\n        \n        // turn to match the ship\n        forward.yz *= rot(smoothstep(35.0, 48.0, time)*0.4);\n        forward.xy *= rot(smoothstep(36.0, 48.0, time)*2.4);\n        \n        // set the warp value\n        warp = max(0.0, time - 44.75);\n        float pos = max(0.0, warp-2.0);\n        shipFrom.x -= (pos*pos*500.0);\n        \n        up = vec3(0, 0, 1);\n        \n    } else if (sequence == 2) {\n        \n        // first flyby\n        shipFrom = vec3(230, -15, -5);\n        sceneFrom = vec3(0);\n        shipFrom.x -= (time-52.0)*53.0;\n        starsX += time*2.0;\n        forward = vec3(-1, 0, 0);\n        up = vec3(0, 0, 1);\n        forward.xy *= rot(smoothstep(51.0, 60.0, time)*0.3);\n        forward.yz *= rot(smoothstep(51.0, 59.0, time)*-0.3);\n        \n    } else if (sequence == 3) {\n        \n        // second flyby\n        shipFrom = vec3(150, 10, 20);\n        sceneFrom = vec3(0);\n        shipFrom.x -= (time-58.0)*44.0;\n        starsX += time*2.0;\n        forward = vec3(-1, 0, 0);\n        up = vec3(0, 0, 1);\n        forward.xy *= rot(smoothstep(56.0, 65.0, time)*-0.4);\n        forward.xz *= rot(-0.1+smoothstep(56.0, 65.0, time)*-0.5);\n        \n    } else if (sequence == 4) {\n        \n        // third flyby\n        shipFrom = vec3(150, -5, -20);\n        sceneFrom = vec3(0);\n        shipFrom.x -= (time-62.0)*43.0;\n        starsX += time*2.0;\n        forward = vec3(-1, 0, 0);\n        up = vec3(0, 0, 1);\n        forward.xy *= rot(smoothstep(60.0, 68.0, time)*0.3);\n        forward.xz *= rot(0.1-smoothstep(61.0, 68.0, time)*-1.0);\n        \n        \n    } else if (sequence == 5) {\n        \n        // look at the ship, go behind it then warp\n        shipFrom = vec3(-150, -8, 20);\n        sceneFrom = vec3(0);\n        \n        // go toward the ship, then rotate around it\n        shipFrom.x += smoothstep(65.0, 75.0, time)*100.0;\n        shipFrom.x += smoothstep(75.0, 90.0, time)*30.0;\n        shipFrom.xy *= rot(-smoothstep(68.0, 92.0, time)*2.0*PI);\n        \n        // go behind the ship while preparing for warpspeed\n        shipFrom = mix(shipFrom, vec3(-40, -4, 5), smoothstep(80.0, 95.0, time));\n        \n        // set the warp value\n        warp = max(0.0, time - 93.0);\n        float pos = max(0.0, warp-2.0);\n        shipFrom.x -= (pos*pos*500.0);\n        \n        starsX += time*2.0 + max(0.0, warp-2.0)*8.0;\n        \n        forward = normalize(-shipFrom);\n        up = vec3(0, 0, 1);\n        \n    }\n\n    return sequence;\n    \n}\n\n// direction fonction, from forward/right/up and uv\nvec3 getDir( in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    //get direction\n    vec3 right = normalize(cross(up, forward));\n    up = cross(forward, right);\n    vec3 dir = normalize(forward*3.0 - right*uv.x + up*uv.y);\n    \n    return dir;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // get sequence\n    time = iChannelTime[3];\n    sequence = sequencer(time);\n    \n    // get direction\n    vec3 dir = getDir(fragCoord);\n\n    vec3 rnd = hash33(vec3(fragCoord, iFrame));\n    vec4 dummy = vec4(0);\n\tvec3 p = vec3(0);\n    float totdist = 0.0;\n    vec4 diffuse = vec4(-1);\n    vec4 emissive = vec4(-1);\n\n    // trace to the ship\n    for (int steps = 0 ; steps < 250 ; steps++) {\n        p = shipFrom + totdist * dir;\n        float d = de(p, false, dummy, dummy)*1.0;\n        totdist += d*0.9;\n        if (d < 0.001) {\n            break;\n        }\n    }\n\n    // pick color\n    p = shipFrom + totdist * dir;\n    de(p, true, diffuse, emissive);\n    \n    // supersample the background\n    fragColor.rgb = vec3(0);\n    for (int x = 0 ; x < BACKGROUND_SS ; x++) {\n        for (int y = 0 ; y < BACKGROUND_SS ; y++) {\n            vec2 offset = (vec2(x, y) + 0.5) / float(BACKGROUND_SS) - 0.5;\n            vec3 ssDir = getDir(fragCoord.xy + offset);\n            if (sequence == 0) {\n                fragColor.rgb += background01(sceneFrom, ssDir);\n            } else if (sequence == 1) {\n                fragColor.rgb += background02(sceneFrom, ssDir);\n            } else {\n                fragColor.rgb += background03(sceneFrom, ssDir);\n            }\n        }\n    }\n    \n    fragColor.rgb /= float(BACKGROUND_SS*BACKGROUND_SS);\n\n    \n    // diffuse color is positive, we found the ship\n    if (diffuse.r > 0.0) {\n        \n        fragColor.rgb = vec3(0.0);\n        vec3 n = normal(p);\n    \n        // add 2 lights\n        vec3 dir1 = normalize(vec3(-7, -8, 4));\n        \n        float cos1 = dot(dir1, n);\n        float vis = cos1>0.0?shadows(p+n*.1, dir1, 0.01):0.0;\n        fragColor.rgb += diffuse.rgb*max(0.0, cos1)*vec3(1.5, 1.5, 1.9)*vis*.8;\n\n        float refl = pow(max(0.0, dot(reflect(dir, n), dir1)), 1.0/diffuse.a);\n        fragColor.rgb += diffuse.rgb*vec3(1.5, 1.5, 1.9)*refl*vis;\n\n        vec3 dir2 = normalize(vec3(6, 2, -3));\n        fragColor.rgb += diffuse.rgb*max(0.0, dot(dir2, n))*vec3(0.0, 0.1, 0.3)*.1;\n\n        fragColor.rgb += diffuse.rgb*vec3(0.1, 0.1, 0.15)*0.1;\n\n        // add the emissive\n        fragColor.rgb += emissive.rgb;\n        \n    }\n    \n    // dithering \n    fragColor.rgb += (rnd-0.5)/255.0*0.375;\n    fragColor.rgb = max(vec3(0), fragColor.rgb);\n    \n    // fade the picture\n    fragColor.rgb = mix(fragColor.rgb, vec3(1), smoothstep(1.0, 0.2, abs(time-9.0)));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), smoothstep(1.0, 0.0, time));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), smoothstep(99.0, 100.0, time));\n    \n    fragColor.a = 1.0;\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 11440,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/user655219080/star-trek-the-next-generation"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}