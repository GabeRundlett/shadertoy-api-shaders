{
    "Shader": {
        "info": {
            "date": "1652624558",
            "description": "Improving a 3x3 denoising box filter by weighing the samples proportionally to the sizes of their sorted noise values' voronoi intervals.",
            "flags": 0,
            "hasliked": 0,
            "id": "Nljfzt",
            "likes": 5,
            "name": "Improved 3x3 Denoising",
            "published": 3,
            "tags": [
                "noise"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 473
        },
        "renderpass": [
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    Improving a 3x3 denoising box filter by weighing the samples proportionally to the sizes of their sorted noise values' voronoi intervals.\n    The resulting 9 weights per texel should be pre-computed in practice (done at run-time here for simplicity).\n    Doing this mainly improves white noise dithering. For blue noise it attenuates high frequencies that the box filter doesn't handle.\n    For IGN it usually makes not much of a difference (as expected since IGN is already optimized for 3x3 box filtering).\n    Overall not really worth it, I think.\n    \n    Left to right: white noise | blue noise | IGN.\n    \n    Top to bottom: test gradient | raw noise | 3x3 denoising | improved 3x3 denoising | reference\n*/\n\nint xc = 0;\n\n// Jorge Jimenez http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\nfloat IGN(vec2 uv) { return fract(52.9829189 * fract(dot(uv, vec2(0.06711056, 0.00583715)))); }\n\nfloat ReadNoise(ivec2 uvi)\n{\n    if(xc == 0) return Hash01(vec2(uvi), 0u);\n    if(xc == 2) return IGN(vec2(uvi));\n    return texelFetch(iChannel0, ivec2(uvec2(uvi) % 1024u), 0).r;\n}\n\nvec3 SampleGradient(float x)\n{\n    //return vec3(x);\n    //return x < 0.25 || x > 0.75 ? vec3(1.0) : vec3(0.0);\n    //return x < 0.25 || x > 0.75 ? vec3(0.0) : vec3(1.0);\n    return round(Hue_to_RGB(x)*2.0)/2.0;\n    //return Hue_to_RGB(x);\n    return mix(vec3(0.0), vec3(1.0), greaterThan(vec3(x), vec3(0.25, 0.5, 0.75)));\n    return round(pow(textureLod(iChannel1, vec2(x * 0.02 + 0.4, 0.5), 0.0).rgb, vec3(2.2)) * 4.0)*0.5;\n    return pow(textureLod(iChannel1, vec2(x * 0.02 + 0.4, 0.5), 0.0).rgb, vec3(2.2));\n}\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec2 tc = uv0 / iResolution.xy;\n    \n    if(tc.x > 1.0/3.0) xc = tc.x < 2.0/3.0 ? 1 : 2;\n    \n    vec3 col = vec3(0.0);\n    \n    vec2 uv = uv0 - 0.5;\n    ivec2 uvi = ivec2(uv);\n    \n    \n    if(tc.y > 0.98)// test gradient\n    {\n        col = SampleGradient(tc.x);\n    }\n    else if(tc.y > 0.9)// raw noise\n    {\n        col = SampleGradient(ReadNoise(uvi));\n    }\n    else if(tc.y < 0.1)// reference\n    {\n        float r2 = fract(dot(uv0-0.5, vec2(0.7548776662, 0.56984029)));\n        //r2 = 0.5;\n        col = vec3(0.0);\n        float count = 64.0;\n        for(float i = 0.0; i < count; ++i)\n        col += SampleGradient((i + r2) / count);\n        col /= count;\n    }\n    else if(tc.y > 0.5)// 3x3 denoising\n    {\n        col = vec3(0.0);\n\n        for(int y = -1; y <= 1; ++y)\n        for(int x = -1; x <= 1; ++x)\n        {\n            ivec2 o = ivec2(x, y);\n\n            float n = ReadNoise(uvi + o);\n\n            float w = 1.0;\n\n            col += SampleGradient(n);\n        }\n\n        col /= 9.0;\n    }\n    else// improved 3x3 denoising\n    {\n        float vs[9];\n\n        uint i = 0u;\n        for(int y = -1; y <= 1; ++y)// fill noise values\n        for(int x = -1; x <= 1; ++x)\n        {\n            float n = ReadNoise(uvi + ivec2(x, y));\n\n            vs[i] = n;\n            ++i;\n        }\n\n        for(uint j = 0u; j < 9u; ++j)\n        for(uint i = 0u; i < 8u-j; ++i)// sort noise valus\n        {\n            float a = vs[i     ];\n            float b = vs[i + 1u];\n\n            if(b < a)\n            {\n                vs[i     ] = b;\n                vs[i + 1u] = a;\n            }\n        }\n\n\n        float c[9];// compute voronoi intervals\n\n       #if 1\n        float c08 = vs[0] + (1.0 - vs[8]);\n        \n        c[0] = (c08 + (vs[1] - vs[0])) * 0.5;\n        c[8] = (c08 + (vs[8] - vs[7])) * 0.5;        \n       #else\n        // this version is biased\n        c[0] = (      vs[0]) + (vs[1] - vs[0]) * 0.5;\n        c[8] = (1.0 - vs[8]) + (vs[8] - vs[7]) * 0.5;\n       #endif\n        \n        for(uint i = 1u; i < 8u; ++i)\n        {\n            c[i] = ((vs[i] - vs[i-1u]) + (vs[i+1u] - vs[i])) * 0.5;\n        }\n\n        col = vec3(0.0);\n\n        for(int y = -1; y <= 1; ++y)// denoise\n        for(int x = -1; x <= 1; ++x)\n        {\n            ivec2 o = ivec2(x, y);\n\n            float n = ReadNoise(uvi + o);\n\n            float w = 128.0;\n\n            for(uint i = 0u; i < 9u; ++i)// find noise value in sorted array\n            {\n                if(vs[i] == n)\n                {\n                    w = c[i];// weigh according to voronoi interval\n                    break;\n                }\n            }\n\n            col += SampleGradient(n) * w;\n        }\n        //col = vec3(1.0) * v;\n    }\n    \n    outCol.rgb = pow(col, vec3(1.0/2.2));\n    //outCol.rgb = col;\n    outCol.a = 1.0;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 Resolution;\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n/* http://keycode.info/ */\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_TAB 9\n#define KEY_CTRL 17\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n#define KEY_Q 81\n#define KEY_E 69\n#define KEY_R 82\n#define KEY_T 84\n#define KEY_Z 90\n#define KEY_U 85\n#define KEY_I 73\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_Y 89\n#define KEY_X 88\n#define KEY_C 67\n#define KEY_V 86\n#define KEY_B 66\n#define KEY_N 78\n#define KEY_M 77\n\n#define KEY_N0 48\n#define KEY_N1 49\n#define KEY_N2 50\n#define KEY_N3 51\n#define KEY_N4 52\n#define KEY_N5 53\n#define KEY_N6 54\n#define KEY_N7 55\n#define KEY_N8 56\n#define KEY_N9 57\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\nvec2 CosSin(float x)\n{\t\n\treturn vec2(cos(x), sin(x));\n}\n\nvec2 CmplxMul(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y, \n                a.x*b.y + a.y*b.x); \n}\n\nvec2 Rotate(vec2 v, float ang)\n{\n    return CmplxMul(v, CosSin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat cubic(float x) { return x*x*(3.0-2.0*x); }\n\nvoid NormAndNormalize(vec3 vec, out float len, out vec3 dir)//TODO: fix nans\n{\n\tfloat sqrLen = dot(vec, vec);\n\tfloat rcpLen = rsqrt(sqrLen);\n\t\n\tlen = sqrLen * rcpLen;\n\tdir = vec * rcpLen;\n}\n\nfloat sRGB_Encode(float c)\n{\n    return c > 0.0031308 ? pow(c, 1.0/2.4) * 1.055 - 0.055 : c * 12.92;\n}\n\nfloat sRGB_Decode(float c)\n{\n    return c > 0.04045 ? pow(c / 1.055 + 0.055/1.055, 2.4) : c / 12.92;\n}\n\nvec3 sRGB_Encode(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.0031308)), pow(rgb, vec3(1.0/2.4)) * 1.055 - 0.055, rgb * 12.92);\n}\n\nvec3 sRGB_Decode(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.04045)), pow(rgb / 1.055 + 0.055/1.055, vec3(2.4)), rgb / 12.92);\n}\n\n    \n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//==============================================================================================================================================//\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n// https://probablydance.com/2018/06/16/fibonacci-hashing-the-optimization-that-the-world-forgot-or-a-better-alternative-to-integer-modulo/\nconst float rPhif1 =      0.6180340;\nconst vec2  rPhif2 = vec2(0.7548777, 0.5698403);\nconst vec3  rPhif3 = vec3(0.8191725, 0.6710436, 0.5497005);\nconst vec4  rPhif4 = vec4(0.8566749, 0.7338919, 0.6287067, 0.5385973);\n\nconst uint  rPhi1 =       2654435769u;\nconst uvec2 rPhi2 = uvec2(3242174889u, 2447445413u);\nconst uvec3 rPhi3 = uvec3(3518319153u, 2882110345u, 2360945575u);\nconst uvec4 rPhi4 = uvec4(3679390609u, 3152041523u, 2700274805u, 2313257605u);\n\n// low bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\n// minimal bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c)\n{ \n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u;\n}\n\n// Pierre L'Ecuyer - \"TABLES OF LINEAR CONGRUENTIAL GENERATORS OF DIFFERENT SIZES AND GOOD LATTICE STRUCTURE\"\n// https://www.ams.org/journals/mcom/1999-68-225/S0025-5718-99-00996-5/S0025-5718-99-00996-5.pdf\nconst uint lcgM = 2891336453u;// ideal for 32 bits with odd c\n\nuint lcg(uint h)\n{\n    return h * lcgM + 0x5C995C6Du;\n}\n\n#define SEED uvec4(0x5C995C6Du, 0x6A3C6A57u, 0xC65536CBu, 0x3563995Fu)\n\n// Mark Jarzynski & Marc Olano - \"Hash Functions for GPU Rendering\"\n// http://jcgt.org/published/0009/03/02/ | https://www.shadertoy.com/view/XlGcRh\nuvec3 pcg3Mix(uvec3 h)\n{\n    h.x += h.y * h.z; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    \n    return h;\n}\n\nuvec3 pcg3Permute(uvec3 h)\n{\n    h = pcg3Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg3Mix(h);\n}\n\nuvec3 pcg3(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg3Permute(uvec3(2447445413u, state, 3242174889u));\n}\n\nuvec3 pcg3(uvec3 h, uint seed)\n{\n    uvec3 c = (seed << 1u) ^ SEED.xyz;\n    \n    return pcg3Permute(h * lcgM + c);\n}\n\nuvec4 pcg4Mix(uvec4 h)\n{\n    h.x += h.y * h.w; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    h.w += h.y * h.z;\n    \n    return h;\n}\n\nuvec4 pcg4Permute(uvec4 h)\n{\n    h = pcg4Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg4Mix(h);\n}\n\nuvec4 pcg4(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg4Permute(uvec4(2882110345u, state, 3518319153u, 2360945575u));\n}\n\nuvec4 pcg4(uvec4 h, uint seed)\n{\n    uvec4 c = (seed << 1u) ^ SEED;\n\n    return pcg4Permute(h * lcgM + c);\n}\n\nuint pcg(inout uint state)\n{\n    state = lcg(state);\n    \n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    \n    return (word >> 22u) ^ word;\n}\n\nuint pcg(uint h, uint seed)\n{\n    uint c = (seed << 1u) ^ SEED.x;\n\n    h = h * lcgM + c;\n    \n    h = ((h >> ((h >> 28u) + 4u)) ^ h) * 277803737u;\n    \n    return (h >> 22u) ^ h;\n}\n\n#undef SEED\n\n\nvec4  Hash01x4(inout uint state) { return Float01(pcg4(state)   ); }\nvec3  Hash01x3(inout uint state) { return Float01(pcg3(state)   ); }\nvec2  Hash01x2(inout uint state) { return Float01(pcg3(state).xy); }\nfloat Hash01  (inout uint state) { return Float01(pcg (state)   ); }\n\nvec4  Hash11x4(inout uint state) { return Float11(pcg4(state)   ); }\nvec3  Hash11x3(inout uint state) { return Float11(pcg3(state)   ); }\nvec2  Hash11x2(inout uint state) { return Float11(pcg3(state).xy); }\nfloat Hash11  (inout uint state) { return Float11(pcg (state)   ); }\n\n\nvec4 Hash01x4(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed)); }\nvec4 Hash01x4(vec3  v, uint seed) { return Hash01x4(vec4(v, 0.0          ), seed); }\nvec4 Hash01x4(vec2  v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash01x4(float v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash01x3(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash01x3(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed)); }\nvec3 Hash01x3(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed); }\nvec3 Hash01x3(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash01x2(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash01x2(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash01(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).x); }\nfloat Hash01(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).x); }\nfloat Hash01(vec2  v, uint seed) { return Float01(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash01(float v, uint seed) { return Float01(pcg(asuint2(v), seed)); }\n\n\nvec4 Hash11x4(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed)); }\nvec4 Hash11x4(vec3  v, uint seed) { return Hash11x4(vec4(v, 0.0          ), seed); }\nvec4 Hash11x4(vec2  v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash11x4(float v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash11x3(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash11x3(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed)); }\nvec3 Hash11x3(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed); }\nvec3 Hash11x3(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash11x2(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash11x2(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash11(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).x); }\nfloat Hash11(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).x); }\nfloat Hash11(vec2  v, uint seed) { return Float11(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash11(float v, uint seed) { return Float11(pcg(asuint2(v), seed)); }\n\n//==============================================================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvec3 Hue_to_RGB(float hue)\n{\n    float H6 = hue * 6.0;\n    \n\tfloat R =       abs(H6 - 3.0) - 1.0;\n\tfloat G = 2.0 - abs(H6 - 2.0);\n\tfloat B = 2.0 - abs(H6 - 4.0);\n    \n\treturn clamp(vec3(R, G, B), 0.0, 1.0);\n}\n\nvec3 HSV_to_RGB(vec3 hsv)\n{\n    return (Hue_to_RGB(hsv.x) * hsv.y + vec3(1.0 - hsv.y)) * hsv.z;\n}\n\nfloat RGB_to_Hue(vec3 rgb)\n{\n    float v = (rgb.r - rgb.g - rgb.b) *  (1.0/6.0) + (1.0/3.0);\n    \n    return (rgb.b < rgb.g ? -v : v) + 0.5;     \n}\n\nvec3 RGB_to_HSV(vec3 rgb)\n{\n    float v = max(rgb.r, max(rgb.g, rgb.b));\n    \n    if(v == 0.0) return vec3(0.0);\n    \n    rgb /= v;\n    \n    float ds = min(rgb.r, min(rgb.g, rgb.b));\n    float s = 1.0 - ds;\n    \n    if(ds == 1.0) return vec3(0.0, 0.0, v);\n    \n    rgb = (rgb - ds) / s;\n    \n    float h = RGB_to_Hue(rgb);\n    \n    return vec3(h, s, v);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}