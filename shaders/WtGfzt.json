{
    "Shader": {
        "info": {
            "date": "1614834193",
            "description": "A Domino Clock design I came up with.\n\nFirst domino is the hours, Second one is the upper digits on the minutes and Third is the lower digits of the minutes.\n\nNeeds work on animations and time keeping, if anyone has any suggestions please leave a comment.",
            "flags": 0,
            "hasliked": 0,
            "id": "WtGfzt",
            "likes": 3,
            "name": "Domino Clock (WIP)",
            "published": 3,
            "tags": [
                "time",
                "clock",
                "domino"
            ],
            "usePreview": 0,
            "username": "foxic",
            "viewed": 241
        },
        "renderpass": [
            {
                "code": "#define domino_scale     .3\n#define domino_dot_scale .25\n#define domino_roundness .05\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\nfloat sdCircle( vec2 p, float r ){\n    return length(p) - r;\n}\n\nfloat domino_dot( in vec2 p, in float scale, in float amount ){\n    float d = 1.;\n    d =      sdCircle( p+vec2(0.,0.125*domino_scale), scale*domino_scale );\n    d = max( sdCircle( p,                             scale*domino_scale ), -abs(d) );\n    return mix(1.,d,amount);\n}\nint domino_get_face( in int face ){\n    // let me know if there is a better way to do this in a shader (something like an array would be perfect)\n    if (face == 1){\n        return 16;\n    } else if (face == 2){\n        return 68;\n    } else if (face == 3){\n        return 84;\n    } else if (face == 4){\n        return 341;\n    } else if (face == 5){\n        return 341;\n    } else if (face == 6){\n        return 455;\n    }\n}\nfloat domino_dot_face( in vec2 p, in int face, in int face_next, in float seconds ){\n    float d = 1.;\n    \n    int i = 0;\n    int data      = domino_get_face( face      );\n    int data_next = domino_get_face( face_next );\n    for( int x=-1; x < 2; x++ ){\n        for( int y=-1; y < 2; y++ ){\n            vec2 offset = vec2(x,y)*domino_scale*0.6;\n            float is_on   = float( ((data      >> i)&1) == 1 );\n            float is_next = float( ((data_next >> i)&1) == 1 );\n            \n            is_on = mix( is_next, is_on, seconds ); // need to work out animation probblems (Commented this out if you want to try it.)\n            d = min( domino_dot( p+offset, domino_dot_scale, is_on), d );\n            i++;\n        }\n    }\n    return d;\n}\n\nfloat domino( in vec2 p, in float value, in float value_next, in float seconds ){\n    float d = 1.;\n    float temp = 1.;\n    \n    // base\n    temp = sdRoundedBox(   p+vec2(0.,0.1), vec2(1, 2)*domino_scale, vec4(domino_roundness) );\n    d = min( sdRoundedBox( p,              vec2(1, 2)*domino_scale, vec4(domino_roundness) ), abs(temp) );\n    \n    \n    int upper_face      = int(floor(value/2.));\n    int lower_face      = int(ceil( value/2.));\n    \n    int upper_face_next = int(floor(value_next/2.));\n    int lower_face_next = int(ceil( value_next/2.));\n    \n    d = max( -domino_dot_face( p-vec2(0.,domino_scale), upper_face, upper_face_next, seconds ), d);\n    d = max( -domino_dot_face( p+vec2(0.,domino_scale), lower_face, lower_face_next, seconds ), d);\n    \n    return d;\n}\n\nfloat domino_clock( in vec2 p, in int num, in float time ){\n    \n    float seconds = fract(time);\n    if (num == 0){ // hours\n        float hour      = floor(mod(  time    /3600.0, 24.0 ));\n        float hour_next = floor(mod( (time+1.)/3600.0, 24.0 ));\n        return domino( p, float(mod(hour,     10.)), float(mod(hour_next, 10.)), seconds );\n        \n    } else if (num == 1){ // minnets (higher)\n        float mins      = mod(  time    /60.0, 60.0 );\n        float mins_next = mod( (time+1.)/60.0, 60.0 );\n        return domino( p, float(mod(mins/10., 10.)), float(mod(mins_next/10., 10.)), seconds );\n        \n    } else if (num == 2){ // minnets (lower)\n        float mins      = mod(  time    /60.0, 60.0 );\n        float mins_next = mod( (time+1.)/60.0, 60.0 );\n        return domino( p, float(mod(mins,     10.)), float(mod(mins_next, 10.)), seconds);\n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = ((fragCoord-vec2(0.,iResolution.y*0.5))/iResolution.x);\n    float px = 2.0/iResolution.y;\n    \n    vec2 dp = vec2( mod(p.x*(3.), 1.)-0.5, (p.y*3.));\n    int num = int(p.x*3.);\n    \n    float time  = iDate.w;\n    \n    float d = domino_clock( dp, num, time);\n    d = smoothstep( 0.0, 1.75*px, d-0.001);\n    vec3 col = mix( vec3(0.356,0.533,0.886), vec3(0.96,0.96,0.91), d );\n    \n    float ds = (domino_clock( dp+vec2(0.,0.01), num, time)*0.05);\n    ds = smoothstep( 0.0, 0.012, ds+0.008 );\n    \n    //vec3 col = mix( vec3(0.243,0.243,0.243), vec3(0.9647,0.9058,0.7568), d);// sandy\n    //vec3 col = mix( vec3(0.5,0.,0.), vec3(1.,1.,1.), d); // red\n    col = mix(col,mix( vec3(0.96,0.96,0.91)*0.3, vec3(0.96,0.96,0.91), ds ), d);\n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(vec3(float(num)/3.),1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}