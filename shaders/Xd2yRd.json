{
    "Shader": {
        "info": {
            "date": "1493373670",
            "description": "Hi guys.\nI couldn't find this being used anywhere so decided to share. Cheap invertible interpolation / easing using 1/x. More info in code comments.\nMouse x controls slope, mouse y on top / bottom half switches between functions.\nVirgin Shadertoy entry.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xd2yRd",
            "likes": 47,
            "name": "Interpolating with 1/x",
            "published": 3,
            "tags": [
                "contrast",
                "graph",
                "inverse",
                "step",
                "shape",
                "slope",
                "interpolate",
                "ease"
            ],
            "usePreview": 0,
            "username": "grinist",
            "viewed": 2396
        },
        "renderpass": [
            {
                "code": "// Cheap interpolation / easing using 1/x.\n// Properties:\n// * Discontinuity at x=0 and x=1\n// * Invertible: y=f(x, k) <=> x=f(y, 1/k)\n// * Symmetric relative to the diagonal y=x\n// * Intuitive to control with a slope parameter\n\n// Thank you rs, jistyles and iq for simplifications!\n\n// rx stands for \"reciprocal of x\".\n// rxEase uses a portion of the 1/x curve to make an ease in or out interpolation.\n// rxEase2 does a dual ease using symmetry at the origin.\n// The rxStep and rxStep2 variants perform the same interpolations over a given range.\n\n// Update:\n// * Renamed functions to rxEase and rxEase2 for brevity. (Originally invXEase and invXEaseDual)\n// * Added corresponding step functions\n// * Curve drawing takes advantage of inverse\n\n// ----------\n\n// Interpolates from 0 to 1 with slope of k at x=0 and 1/k at x=1.\n// k must be greater than zero.\n// k<1: ease in, k=1: lerp, k>1: ease out\nfloat rxEase(float x, float k)\n{\n    k = clamp(k, 0.0001, 10000.0) - 1.0; // clamp optional, if you know your k\n    x = clamp(x, 0.0, 1.0);\n    float kx = k * x;\n    return (x + kx) / (kx + 1.0);    \n}\n\n// Interpolates from 0 to 1 with slope of k at x=0 and x=1.\n// k must be greater than zero.\n// k<1: sigmoid, k=1: lerp, k>1: seat\nfloat rxEase2(float x, float k)\n{\n    k = clamp(k, 0.0001, 10000.0); // clamp optional, if you know your k\n    x = 0.5 - x; // re-center at 0\n    float s = sign(x);\n    x = clamp(abs(x) * 2.0, 0.0, 1.0);\n    return 0.5 + 0.5 * s * x / (x * (k - 1.0) - k);\n}\n\n// Interpolates from 0 to 1 between [a, b], with slope of k at x=a and 1/k at x=b.\n// k must be greater than zero.\n// k<1: ease in, k=1: lerp, k>1: ease out\nfloat rxStep(float a, float b, float x, float k)\n{\n    return (a == b) ? step(x, a) : rxEase((x - a) / (b - a), k);\n}\n\n// Interpolates from 0 to 1 between [a, b], with slope of k at x=a and x=b.\n// k must be greater than zero.\n// k<1: sigmoid, k=1: lerp, k>1: seat\nfloat rxStep2(float a, float b, float x, float k)\n{\n    return (a == b) ? step(x, a) : rxEase2((x - a) / (b - a), k);\n}\n\n// ----------\n\nvoid drawGradientRect(vec2 pos, vec2 size, float t, vec4 startCol, vec4 endCol)\n{\n\tvec2 inside = step(pos, xy) * step(xy, pos + size);\n\tmixColor(mix(startCol, endCol, t), inside.x * inside.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    setupGraph(vec2(0.5), vec2(1.4), fragCoord, iResolution);\n\n\t// background\n\tfcol = mix(vec4(0.1, 0.25, 0.35, 1.0), vec4(0.05, 0.125, 0.175, 1.0), sqrlength(xy - graphCenter) / sqrlength(graphSize * 0.5));\n    \n\t// grid\n\tdrawGrid(0.1, px, vec4(1.0, 1.0, 1.0, 0.125));\n\tdrawGrid(0.5, px, vec4(1.0, 1.0, 1.0, 0.25));\n\tdrawGrid(1.0, px, vec4(1.0, 1.0, 1.0, 0.5));\n\n    vec2 auto = vec2(0.5 + 0.5 * sin(iTime), fract(iTime / (6.2832 * 2.0)));\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = iMouse.z <= 0.0 ? auto : mouse;\n    // translate x coordinate to a slope value between 0.01 and 100\n\tfloat k = pow(10.0, (-0.5 + mouse.x) * 4.0);\n    float lerpTime = clamp(fract(iTime * 0.25) * 2.0 - 0.5, 0.0, 1.0);\n\n    float r = 3.0 * px;\n    // mask curve drawing in y, since verticals x = 0 and x = 1 would be drawn with inverse functions\n    float mask = lerpstep(-r - aa, -r + aa, xy.y) - lerpstep(1.0 + r - aa, 1.0 + r + aa, xy.y);\n    \n\tif (mouse.y > 0.5)\n\t{\n\t\t// ease function on top half\n        vec4 col = vec4(0.2, 0.7, 1.0, 1.0);\n        drawFuncWithInverse(rxEase(xy.x, k), rxEase(xy.y, 1.0 / k), r, vec4(col.rgb, mask));\n        if (iMouse.z > 0.0)\n        {\n\t        vec4 dimCol = vec4(col.rgb, 0.5);\n\t        drawFunc(k * xy.x, k, px, dimCol);\n            drawCircle(vec2(lerpTime, rxEase(lerpTime, k)), 8.0 * px, dimCol);\n            drawCircle(vec2(1.1, rxEase(lerpTime, k)), 8.0 * px, col);\n        }\n        drawGradientRect(graphPos, vec2(graphSize.x, 0.1), rxEase(xy.x, k), vec4(0.0, 0.0, 0.0, 1.0), col);\n\t}\n\telse\n\t{\n\t\t// dual ease function on bottom half\n        vec4 col = vec4(1, 0.45, 0.1, 1.0);\n        drawFuncWithInverse(rxEase2(xy.x, k), rxEase2(xy.y, 1.0 / k), r, vec4(col.rgb, mask));\n        if (iMouse.z > 0.0)\n        {\n\t        vec4 dimCol = vec4(col.rgb, 0.5);\n\t        drawFunc(k * xy.x, k, px, dimCol);\n            drawCircle(vec2(lerpTime, rxEase2(lerpTime, k)), 8.0 * px, dimCol);\n            drawCircle(vec2(1.1, rxEase2(lerpTime, k)), 8.0 * px, col);\n        }\n        drawGradientRect(graphPos, vec2(graphSize.x, 0.1), rxEase2(xy.x, k), vec4(0.0, 0.0, 0.0, 1.0), col);\n\t}\n\n\tfragColor = fcol;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 graphSize;\nvec2 graphCenter;\nvec2 graphPos; // bottom left\n\nvec2 xy;\t// current graph coords\nfloat px;\t// pixel size in graph units, assumes uniform graph\nfloat aa;\t// aa falloff radius\nvec4 fcol;\t// current fragment color\n\nfloat lerpstep(float a, float b, float x)\n{\n    return (a == b) ? step(x, a) : clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\nfloat sqrlength(vec2 v)\n{\n    return dot(v, v);\n}\n\nvoid mixColor(vec4 col, float alpha)\n{\n    fcol = vec4(mix(fcol.rgb, col.rgb, alpha * col.a), 1.0);\n}\n\nvoid drawGrid(float stepSize, float r, vec4 col)\n{\n\tvec2 grid = abs(vec2(-0.5) + fract((xy + vec2(stepSize) * 0.5) / stepSize));\n    float d = min(grid.x, grid.y) * stepSize;\n    mixColor(col, lerpstep(r + aa, r - aa, d));\n}\n\nvoid drawCircle(vec2 pos, float r, vec4 col)\n{\n    float d = length(pos - xy);\n    mixColor(col, lerpstep(r + aa, r - aa, d));\n}\n\n// Draws an explicit function of x with a known derivative.\n// Uses y distance to curve, breaks with great derivatives and discontinuities.\nvoid drawFunc(float y, float dy, float r, vec4 col)\n{\n    float d = abs(y - xy.y);\n    float yspan = sqrt(1.0 + dy * dy); // accurate, decent approximate: abs(dy) + 1.0 / (abs(dy) + 1.0)\n\tmixColor(col, lerpstep(yspan * (r + aa), yspan * (r - aa), d));\n}\n\n// Draws an explicit function of x, uses screen space derivative.\nvoid drawFunc(float y, float r, vec4 col)\n{\n    drawFunc(y, dFdx(y) / px, r, col);\n}\n\n// Draws an explicit function of x with a known inverse.\n// Uses distance to curve in both y and x.\nvoid drawFuncWithInverse(float y, float x, float r, vec4 col)\n{\n    vec2 d = abs(vec2(xy.x - x, xy.y - y));\n    mixColor(col, lerpstep(r + aa, r - aa, max(d.x, d.y) / length(d) * min(d.x, d.y)));\n}\n\nvoid setupGraph(vec2 center, vec2 size, vec2 fragcoord, vec3 resolution)\n{\n    graphSize = size * (resolution.xy / resolution.y);\n    graphCenter = center;\n    graphPos = graphCenter - 0.5 * graphSize;\n    xy = graphPos + fragcoord / resolution.xy * graphSize;\n\tpx = graphSize.y / resolution.y;\n    aa = 0.5 * px;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}