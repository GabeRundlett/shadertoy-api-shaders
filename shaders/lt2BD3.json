{
    "Shader": {
        "info": {
            "date": "1543070008",
            "description": "Another nice construction from plane projective geometry: the eleven point conic.",
            "flags": 16,
            "hasliked": 0,
            "id": "lt2BD3",
            "likes": 6,
            "name": "Eleven point conic",
            "published": 3,
            "tags": [
                "conic",
                "projective",
                "elevenpoint"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 618
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Projective geometry: the eleven point conic.\n//\n// Take 4 points (red) and the 6 lines (yellow) through pairs of points,\n// forming a complete quadrangle.\n//\n// There are 3 diagonal points where the line through two points meets\n// the line through the other two points (cyan).\n//\n// Given a line l (red), the 6 quadrangle lines meet l in 6 points and each\n// point has a harmonic conjugate with the two points of the quadrangle\n// on the same line (green).\n//\n// Additionally, the 4 points of the quadrangle and the line l\n// define a pair of conics (blue and grey), passing through the 4 points\n// and tangent to the line (these conics may be imaginary though).\n//\n// The three diagonal points, the six harmonic points and the two points\n// of tangency of the pair of conics all lie on a third conic, the\n// eleven point conic (white).\n//\n// Copyright (c) Matthew Arcus, 2018\n// MIT License: https://opensource.org/licenses/MIT\n//\n// Controls:\n// Drag mouse to change line\n// '1' and '2': change initial configuration\n// 'f': change line & point drawing style\n// 'z': zoom in\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint configuration = 2;\n\nconst float lwidth = 0.01;\nconst float pwidth = 0.04;\nfloat ledge0 = 0.0, ledge1 = lwidth;\nfloat pedge0 = lwidth, pedge1 = pwidth;\nconst float scale = 1.5;\nfloat zoom = 1.0;\n\nconst float PI =  3.141592654;\n\nconst vec3 pcolor0 = vec3(1,0,0);\nconst vec3 pcolor1 = vec3(0,1,0);\nconst vec3 pcolor2 = vec3(1,1,0);\nconst vec3 pcolor3 = vec3(0,1,1);\nconst vec3 pcolor4 = pcolor1;\nconst vec3 lcolor0 = pcolor0;\nconst vec3 lcolor1 = pcolor1;\nconst vec3 lcolor2 = vec3(1,1,0.2);\nconst vec3 ccolor0 = vec3(1,1,1);\nconst vec3 ccolor1 = vec3(0,0,1);\nconst vec3 ccolor2 = vec3(0.5,0.5,1);\n\n// Solve Ax^2 + 2Bx + C = 0\nbool quadratic(float A, float B, float C,\n               out float x1, out float x2) {\n   float D = B*B - A*C;\n   if (D < 0.0) return false;\n   D = sqrt(D);\n   if (B < 0.0) D = -D;\n   x1 = (-B-D)/A;\n   x2 = C/(A*x1);\n   return true;\n}\n\n// Return either intersection of lines p and q\n// or line through points p and q, r = kp + jq\nvec3 join(vec3 p, vec3 q) {\n  return cross(p,q);\n}\n\n// Find a projective mapping taking p0,p1,p2,p4 to\n// triangle of reference and unit point, ie:\n// p0 -> (1,0,0), p1 -> (0,1,0), p2 -> (0,0,1), p3 -> (1,1,1)\n// No three points collinear.\nmat3 rproject(vec3 p0, vec3 p1, vec3 p2, vec3 p3) {\n  // Just an inverse for the first three points\n  // (the triangle of reference). No inverse if collinear.\n  mat3 m = inverse(mat3(p0,p1,p2)); // column major!\n  p3 = m*p3; \n  // Then scale each row so the unit point (1,1,1) is correct\n  m = transpose(m);\n  // zero components here only if not collinear\n  m[0] /= p3[0];\n  m[1] /= p3[1];\n  m[2] /= p3[2];\n  return transpose(m);\n}\n\n// Represent a projective conic as a 3x3 matrix:\n//\n// M = (a,d,e,\n//      d,b,f,\n//      e,f,c)\n//\n// is: axx + byy + czz + 2(dxy + exz + fyz) = 0\n// calculated as pMp for p = (x,y,z).\n//\n// We can treat this as a distance field, scaled by the\n// (x,y) derivative in order to get correct line widths.\n\n// With this representation, the dual conic is just the inverse;\n// if the determinant is zero then there is no dual and the\n// conic is degenerate.\n\n// Conic through 4 points and a line - there are 2 solutions, so\n// need to solve quadratic. I'm sure I didn't invent this but\n// can't remember the source.\n// l.p = l'p == l'(MinvM)p = (Minv'l)'Mp\nbool conic4points(vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 l4, out mat3 M0, out mat3 M1) {\n  // p takes p0,p1,p2,p3 to triangle of reference and unit point\n  mat3 p = rproject(p0,p1,p2,p3);\n  // and then to the square (1,1),(1,-1),(-1,1),(-1,-1)\n  mat3 q = rproject(vec3(1,-1,1), vec3(-1,1,1),vec3(-1,-1,1),vec3(1,1,1));\n  p = inverse(q)*p; // q is constant\n  // Now construct a conic through the images of p0-p3 and l4\n  l4 = transpose(inverse(p))*l4;\n  float i = l4.x, j = l4.y, k = l4.z;\n  float A = -j*j, B = 0.5*(i*i+j*j-k*k), C = -i*i;\n  float t0,t1;\n  if (!quadratic(A,B,C,t0,t1)) return false;\n  M0 = mat3(t0, 0, 0,\n            0, -1, 0,\n            0,  0, 1.0-t0);\n  M0 = transpose(p)*M0*p;\n  if (isnan(determinant(M0))) return false;\n  M1 = mat3(t1, 0, 0,\n            0, -1, 0,\n            0,  0, 1.0-t1);\n  M1 = transpose(p)*M1*p;\n  if (isnan(determinant(M1))) return false;\n  return true;\n}\n\n// Find the two points of intersection of a line through p0 and\n// p1 with the conic defined by M.\nbool lineconic(vec3 p0, vec3 p1, mat3 M, out vec3 q0, out vec3 q1) {\n  // (tp0 + p1)M(tp0 + p1) == 0\n  float A = dot(p0,M*p0);\n  float B = dot(p0,M*p1);\n  float C = dot(p1,M*p1);\n  float t0,t1;\n  if (!quadratic(A,B,C,t0,t1)) return false;\n  q0 = t0*p0+p1;\n  q1 = t1*p0+p1;\n  return true;\n}\n\n// Find the two points of intersection of the line l\n// with the conic defined by c.\nbool lineconic(vec3 l, mat3 M, out vec3 i0, out vec3 i1) {\n  // Intersect l with two of the axes. This might of course\n  // be the same point (1,0,0) here, so should use the third\n  // axis.\n  vec3 p0 = join(l,vec3(0,0,1));\n  vec3 p1 = join(l,vec3(0,1,0));\n  return lineconic(p0,p1,M,i0,i1);\n}\n\n// Construct the conic defined by 5 points.\n// Method taken from \"Geometry\", Brannan, Esplan & Gray, CUP, 2012\nmat3 conic5points(vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n  // p takes p0,p1,p2,p3 to triangle of reference and unit point\n  mat3 p = rproject(p0,p1,p2,p3);\n  // Now construct a conic through the images of p0-p4,\n  p4 = p*p4;\n  float a = p4.x, b = p4.y, c = p4.z;\n  float d = c*(a-b);\n  float e = b*(c-a);\n  float f = a*(b-c);\n  mat3 m = mat3(0,d,e,\n                d,0,f,\n                e,f,0);\n  // And combine the two.\n  return transpose(p)*m*p;\n}\n\n// Harmonic conjugate of p,q and intersection of p,q with l.\nvec3 harmonic(vec3 p, vec3 q, vec3 l) {\n  // kp + jq is conjugate of kp - lq:\n  // l.(kp - jq) = 0\n  // k(l.p) = j(l.q)\n  float k = dot(l,q);\n  float j = dot(l,p);\n  return k*p+j*q;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Drawing functions\n////////////////////////////////////////////////////////////////////////////////\n\nfloat point(vec3 pos, vec3 p) {\n  if (p.z == 0.0) return 0.0;\n  pos /= pos.z; p /= p.z; // Normalize\n  float dist = distance(pos,p);\n  if (isnan(dist)) return 0.0;\n  return 1.0-smoothstep(pedge0,pedge1,dist);\n}\n\nfloat line(vec3 pos, vec3 l) {\n  float dist = dot(pos,l)/(pos.z*length(l.xy));\n  if (isnan(dist)) return 0.0;\n  return 1.0-smoothstep(ledge0,ledge1,abs(dist));\n}\n\nfloat conic(vec3 pos, mat3 m) {\n  float dist = dot(pos,m*pos);   // Distance from the conic\n  vec3 grad = m*pos*2.0;         // The gradient uses the same matrix.\n  dist /= pos.z*length(grad.xy); // Normalize for Euclidean distance\n  if (isnan(dist)) return 0.0;\n  return 1.0-smoothstep(ledge0,ledge1,abs(dist));\n}\n\n// Screen coords to P2 coords\nvec3 map(vec2 p) {\n  return vec3(scale*zoom*(2.0*p - iResolution.xy) / iResolution.y, 1);\n}\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(vec3 p) {\n  float t = 0.5*iTime;\n  p.x *= 1.0+0.5*sin(t);\n  p.y *= 1.0+0.3*sin(0.618*t);\n  p.xy = rotate(p.xy,0.2*t);\n  //p.yz = rotate(p.yz,0.1*t);\n  return p;\n}\n\nvec3 cmix(vec3 color0, vec3 color1, float level) {\n  return mix(color0,color1,level);\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_I = 73;\nconst int CHAR_Z = 90;\nbool keypress(int code) {\n#if defined LOCAL || __VERSION__ < 300\n  return false;\n#else\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  if (keypress(CHAR_Z)) zoom = 0.25;\n  if (!keypress(CHAR_F)) {\n      float pixelwidth = 2.0*scale/iResolution.y;\n      pedge0 = pwidth-pixelwidth;\n      pedge1 = pwidth+pixelwidth;\n      ledge0 = lwidth-pixelwidth;\n      ledge1 = lwidth+pixelwidth;\n  }    \n  configuration = int(keypress(CHAR_0+1)) + 2*int(!keypress(CHAR_0+2));\n  vec3 pos = map(fragCoord.xy);\n  vec3 p0,p1,p2,p3,l4; // p4 is the movable line\n  if (configuration == 0) {\n    p0 = vec3(1,0,0); p1 = vec3(0,1,0);\n    p2 = vec3(0,0,1); p3 = vec3(1,1,1);\n    l4 = vec3(0.5,-1,1);\n  } else if (configuration == 1) {\n    p0 = vec3(0,0,1); p1 = vec3(1,0,1);\n    p2 = vec3(0,1,1); p3 = vec3(1,1,1);\n    l4 = vec3(0.5,-1,1);\n  } else if (configuration == 2) {\n    p0 = vec3(0,0,1); p1 = vec3(0,1,1);\n    p2 = vec3(0.866,-0.5,1); p3 = vec3(-0.866,-0.5,1);\n    l4 = vec3(-1,0.5,1);\n  } else {\n    p0 = vec3(1,0,1);  p1 = vec3(0,1,1);\n    p2 = vec3(-1,0,1); p3 = vec3(0,-1,1);\n    l4 = vec3(0.5,-1,1);\n  }\n  p0 = transform(p0); p1 = transform(p1);\n  p2 = transform(p2); p3 = transform(p3);\n  if (iMouse.x != 0.0) {\n    l4 = map(iMouse.xy);\n  }\n  vec3 l01 = join(p0,p1);\n  vec3 l02 = join(p0,p2);\n  vec3 l03 = join(p0,p3);\n  vec3 l12 = join(p1,p2);\n  vec3 l13 = join(p1,p3);\n  vec3 l23 = join(p2,p3);\n\n  // diagonal points\n  vec3 d0 = join(l01,l23);\n  vec3 d1 = join(l02,l13);\n  vec3 d2 = join(l03,l12);\n\n  // harmonic points\n  vec3 h01 = harmonic(p0,p1,l4);\n  vec3 h02 = harmonic(p0,p2,l4);\n  vec3 h03 = harmonic(p0,p3,l4);\n  vec3 h12 = harmonic(p1,p2,l4);\n  vec3 h13 = harmonic(p1,p3,l4);\n  vec3 h23 = harmonic(p2,p3,l4);\n\n  // conics\n  mat3 elevenpoint = conic5points(d0,d1,d2,h01,h23);\n  mat3 M1,M2;\n  bool doM1M2 = conic4points(p0,p1,p2,p3,l4,M1,M2);\n  vec3 i0,i1;\n  bool doN = lineconic(l4,elevenpoint,i0,i1);\n\n  vec3 color = vec3(0);\n\n  // The diagonal lines of the quadrangle\n  color = cmix(color,lcolor2,line(pos,l01));\n  color = cmix(color,lcolor2,line(pos,l02));\n  color = cmix(color,lcolor2,line(pos,l03));\n  color = cmix(color,lcolor2,line(pos,l12));\n  color = cmix(color,lcolor2,line(pos,l13));\n  color = cmix(color,lcolor2,line(pos,l23));\n\n  // The moving line\n  color = cmix(color,lcolor0,line(pos,l4));\n  \n  // The conics\n  color = cmix(color,ccolor0,conic(pos,elevenpoint));\n  if (doM1M2) {\n    color = cmix(color,ccolor1,conic(pos,M1));\n    color = cmix(color,ccolor2,conic(pos,M2));\n  }\n\n  // The points of the quadrangle\n  color = cmix(color,pcolor0,point(pos,p0));\n  color = cmix(color,pcolor0,point(pos,p1));\n  color = cmix(color,pcolor0,point(pos,p2));\n  color = cmix(color,pcolor0,point(pos,p3));\n\n  // The midpoints of the sides of the quadrangle\n  color = cmix(color,pcolor1,point(pos,h01));\n  color = cmix(color,pcolor1,point(pos,h02));\n  color = cmix(color,pcolor1,point(pos,h03));\n  color = cmix(color,pcolor1,point(pos,h12));\n  color = cmix(color,pcolor1,point(pos,h13));\n  color = cmix(color,pcolor1,point(pos,h23));\n\n  // The magic triangle\n  color = cmix(color,pcolor3,point(pos,d0));\n  color = cmix(color,pcolor3,point(pos,d1));\n  color = cmix(color,pcolor3,point(pos,d2));\n\n  color = cmix(color,pcolor4,point(pos,join(l01,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l02,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l03,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l12,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l13,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l23,l4)));\n  \n  if (doN) {\n    color = cmix(color, pcolor2, point(pos,i0));\n    color = cmix(color, pcolor2, point(pos,i1));\n  }\n  fragColor = vec4(pow(1.0*color,vec3(0.4545)),1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}