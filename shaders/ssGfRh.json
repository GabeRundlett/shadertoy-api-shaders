{
    "Shader": {
        "info": {
            "date": "1657638045",
            "description": "The following references are that I used to make this walking machine animation:\nhttps://en.wikipedia.org/wiki/Chebyshev_lambda_linkage\nhttps://en.wikipedia.org/wiki/Chebyshev_lambda_linkage#/media/File:Tchebyshevs_plantigrade_machine.gif\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ssGfRh",
            "likes": 21,
            "name": "Walking Machine Animation 01",
            "published": 3,
            "tags": [
                "machineanimation"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 384
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 64\n#define MAX_DIST 64.\n#define SURF_DIST .001\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define MATERIAL 0\n#define MATERIAL1 1\n#define PI 3.141592653589793\n#define ZERO (min(iFrame,0))\n\nstruct MachineAnim {\n    float moveX;\n    float moveY;\n    \n    float moveX2;\n    float moveY2;\n    \n    float a1;\n    float a2;\n};\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// Modified as the 3D version of sdOrientedBox\n// thx iq! https://iquilezles.org/articles/distfunctions2d/\nfloat sdOrientedBox( in vec3 p, in vec3 a, in vec3 b, float th )\n{\n    float l = length(b-a);\n    vec3  d = (b-a)/l;\n    vec3  q = (p-(a+b)*0.5);\n          q.xy = mat2(d.x,-d.y,d.y,d.x)*q.xy;\n          q = abs(q)-vec3(l,th,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);   \n}\n\nfloat sdOrientedBox2( in vec3 p, in vec3 a, in vec3 b, float th )\n{\n    float l = length(b-a);\n    vec3  d = (b-a)/l;\n    vec3  q = (p-(a+b)*0.5);\n          q.xz = mat2(d.x,-d.z,d.z,d.x)*q.xz;\n          q = abs(q)-vec3(l,th,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);   \n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat getTime(float t, float duration){\n    return clamp(t,0.0,duration)/duration;\n}\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nvec2 getPointB(vec2 a, float len, float r){\n    return vec2(a.x-cos(r)*len,a.y-sin(r)*len);\n}\n\nvec2 getMidPoint(vec2 a, vec2 b){\n    return vec2((a.x+b.x)*0.5, (a.y+b.y)*0.5);\n}\n\n// main animation logic\nMachineAnim GetAnimationValues(){\n    float totalMoveFrame = 2.0;\n    float halfFrame = totalMoveFrame*0.5;\n    float t = mod(iTime,totalMoveFrame);\n    float moveX = 0.;\n    float moveY = 0.;\n    \n    float moveX2 = 0.;\n    float moveY2 = 0.;\n    \n    float xdist = 0.1;\n    \n    float a1 = 0.0;\n    float a2 = 0.0;\n    if(t<halfFrame){\n        float a = radians(getTime(t,halfFrame)*180.);\n        moveX = cos(a)*xdist;\n        moveY = abs(sin(a)*0.1);\n        \n        moveX2 = -xdist+cubicInOut(t)*(xdist*2.0);\n        \n        a1 = radians(90.)-a;\n        a2 = radians(-90.)-a;\n    } else if(t>=halfFrame && t<totalMoveFrame){\n        t = getTime(t-halfFrame,halfFrame);\n        moveX = -xdist+cubicInOut(t)*(xdist*2.0);\n        \n        float a = radians(t*180.);\n        moveX2 = cos(a)*xdist;\n        moveY2 = abs(sin(a)*0.1);\n        \n        a1 = radians(-90.-getTime(t,halfFrame)*180.);\n        a2 = radians(-270.-getTime(t,halfFrame)*180.);\n    }\n    \n    return MachineAnim(moveX,moveY,moveX2,moveY2,a1,a2);\n}\n\n// 2D version\nfloat chebyshevLambdaLinkageDist(vec2 uv){\n    float lineSize = 0.005;\n    \n    MachineAnim anim = GetAnimationValues();\n    \n    vec2 a1 = vec2(-0.2+anim.moveX,0.2+anim.moveY);\n    vec2 b1 = vec2(-0.2+anim.moveX,-0.2+anim.moveY);\n    \n    vec2 a1_2 = vec2(-0.2+anim.moveX2,0.2+anim.moveY2);\n    vec2 b1_2 = vec2(-0.2+anim.moveX2,-0.2+anim.moveY2);\n    \n    vec2 a2 = vec2(0.2+anim.moveX,0.2+anim.moveY);\n    vec2 b2 = vec2(0.2+anim.moveX,-0.2+anim.moveY);\n    \n    vec2 a2_2 = vec2(0.2+anim.moveX2,0.2+anim.moveY2);\n    vec2 b2_2 = vec2(0.2+anim.moveX2,-0.2+anim.moveY2);\n    \n\n    float segDLen = 0.06;\n    vec2 d1 = getPointB(vec2(-0.075,-0.05),segDLen,anim.a1);\n    vec2 e1 = getPointB(vec2(-0.075,-0.05),segDLen,anim.a2);\n    \n    vec2 d2 = getPointB(vec2(0.075,-0.05),segDLen,anim.a1);\n    vec2 e2 = getPointB(vec2(0.075,-0.05),segDLen,anim.a2);\n    \n    // something complex part\n    float dd = sdSegment(uv,a1,d1)-lineSize;\n    float dd2 = sdSegment(uv,vec2(-0.075,-0.05),d1)-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,a2,d2)-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,vec2(-0.075,-0.05),e1)-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,a1_2,e1)-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,a2_2,e2)-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,vec2(0.075,-0.05),d2)-lineSize;\n    dd = min(dd,dd2);\n    dd2 = sdSegment(uv,vec2(0.075,-0.05),e2)-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,d1,d2)-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,e1,e2)-lineSize;\n    dd = min(dd,dd2);\n    \n    \n    // body\n    vec2 blt = vec2(-0.2,-0.05);\n    vec2 brt = vec2(0.2,-0.05);\n    \n    vec2 mid_a1_d1 = getMidPoint(a1,d1);\n    vec2 mid_a2_d2 = getMidPoint(a2,d2);\n    \n    vec2 mid_a1_2_d1 = getMidPoint(a1_2,e1);\n    vec2 mid_a2_2_d2 = getMidPoint(a2_2,e2);    \n    \n    dd2 = sdSegment(uv,blt,mid_a1_d1)-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,brt,mid_a2_d2)-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,blt,mid_a1_2_d1)-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,brt,mid_a2_2_d2)-lineSize;\n    dd = min(dd,dd2);    \n    \n    dd2 = sdSegment(uv,blt,brt)-lineSize;\n    dd = min(dd,dd2);\n    \n    \n    // legs\n    dd2 = sdSegment(uv,a1,b1)-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,a1_2,b1_2)-lineSize;\n    dd = min(dd,dd2);    \n    \n    dd2 = sdSegment(uv,a2,b2)-lineSize;\n    dd = min(dd,dd2);    \n    \n    dd2 = sdSegment(uv,a2_2,b2_2)-lineSize;\n    dd = min(dd,dd2);\n    \n    // foot\n    dd2 = sdSegment(uv,vec2(b1.x-0.03,b1.y),vec2(b1.x+0.03,b1.y))-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,vec2(b1_2.x-0.03,b1_2.y),vec2(b1_2.x+0.03,b1_2.y))-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,vec2(b2.x-0.03,b2.y),vec2(b2.x+0.03,b2.y))-lineSize;\n    dd = min(dd,dd2);    \n    \n    dd2 = sdSegment(uv,vec2(b2_2.x-0.03,b2_2.y),vec2(b2_2.x+0.03,b2_2.y))-lineSize;\n    dd = min(dd,dd2);        \n    \n    return dd;\n}\n\n// 3D version\nfloat chebyshevLambdaLinkageDist(vec3 p){\n    vec3 prevP = p;\n    float th = 0.01;\n    float z = 0.04;\n    MachineAnim anim = GetAnimationValues();\n    \n    vec3 a1 = vec3(-0.2+anim.moveX,0.2+anim.moveY,-z*2.0);\n    vec3 b1 = vec3(-0.2+anim.moveX,-0.2+anim.moveY,-z*2.0);\n    \n    vec3 a1_2 = vec3(-0.2+anim.moveX2,0.2+anim.moveY2,-z);\n    vec3 b1_2 = vec3(-0.2+anim.moveX2,-0.2+anim.moveY2,-z);\n    \n    vec3 a2 = vec3(0.2+anim.moveX,0.2+anim.moveY,z);\n    vec3 b2 = vec3(0.2+anim.moveX,-0.2+anim.moveY,z);\n    \n    vec3 a2_2 = vec3(0.2+anim.moveX2,0.2+anim.moveY2,0);\n    vec3 b2_2 = vec3(0.2+anim.moveX2,-0.2+anim.moveY2,0);\n    \n\n    float segDLen = 0.06;\n    vec3 d1 = vec3(getPointB(vec2(-0.075,-0.05),segDLen,anim.a1),-z*2.0);\n    vec3 e1 = vec3(getPointB(vec2(-0.075,-0.05),segDLen,anim.a2),-z);\n    \n    vec3 d2 = vec3(getPointB(vec2(0.075,-0.05),segDLen,anim.a1),z);\n    vec3 e2 = vec3(getPointB(vec2(0.075,-0.05),segDLen,anim.a2),0);\n    \n    // something complex part\n    float dd = sdOrientedBox(p,a1,d1,th);\n    float dd2 = sdOrientedBox(p,vec3(-0.075,-0.05,-z*2.0),d1,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,a2,d2,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,vec3(-0.075,-0.05,-z),e1,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,a1_2,e1,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,a2_2,e2,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,vec3(0.075,-0.05,z),d2,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,vec3(0.075,-0.05,0),e2,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,vec3(d1.xy,-0.02),vec3(d2.xy,-0.02),th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,vec3(e1.xy,-0.02),vec3(e2.xy,-0.02),th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdCappedCylinder(p-vec3(d1.xy,-0.05),0.012,0.04);\n    dd = min(dd,dd2);    \n    dd2 = sdCappedCylinder(p-vec3(e1.xy,-0.03),0.012,0.02);\n    dd = min(dd,dd2);   \n    dd2 = sdCappedCylinder(p-vec3(d2.xy,0.01),0.012,0.04);\n    dd = min(dd,dd2);  \n    dd2 = sdCappedCylinder(p-e2,0.012,0.03);\n    dd = min(dd,dd2);       \n    \n    \n    // body\n    vec3 blt = vec3(-0.2,-0.05,0.0);\n    vec3 brt = vec3(0.2,-0.05,0.0);\n    \n    vec3 bltZ = vec3(-0.2,-0.05,-0.15);\n    vec3 brtZ = vec3(0.2,-0.05,-0.15);\n    \n    vec3 mid_a1_d1 = vec3(getMidPoint(a1.xy,d1.xy),-z*2.0);\n    vec3 mid_a2_d2 = vec3(getMidPoint(a2.xy,d2.xy),z);\n    \n    vec3 mid_a1_2_d1 = vec3(getMidPoint(a1_2.xy,e1.xy),-z);\n    vec3 mid_a2_2_d2 = vec3(getMidPoint(a2_2.xy,e2.xy),0.0);    \n    \n    dd2 = sdOrientedBox(p,vec3(blt.xy,-z*2.0),mid_a1_d1,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,vec3(brt.xy,z),mid_a2_d2,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,vec3(blt.xy,-z),mid_a1_2_d1,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,brt,mid_a2_2_d2,th);\n    dd = min(dd,dd2);    \n    \n    dd2 = sdOrientedBox(p,blt,brt,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox2(p,blt,bltZ,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox2(p,brt,brtZ,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox2(p,vec3(-0.075,-0.05,0),vec3(-0.075,-0.05,-0.15),th);\n    dd = min(dd,dd2);\n        \n    dd2 = sdOrientedBox2(p,vec3(0.075,-0.05,0),vec3(0.075,-0.05,-0.15),th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdCappedCylinder(p-vec3(-0.075,-0.05,0.0),0.012,0.01);\n    dd = min(dd,dd2);\n    \n    dd2 = sdCappedCylinder(p-vec3(-0.2,-0.05,0.0),0.012,0.01);\n    dd = min(dd,dd2);\n    \n    dd2 = sdCappedCylinder(p-vec3(0.075,-0.05,0.02),0.012,0.03);\n    dd = min(dd,dd2);\n    \n    dd2 = sdCappedCylinder(p-vec3(0.2,-0.05,0.02),0.012,0.03);\n    dd = min(dd,dd2);\n\n    dd2 = sdCappedCylinder(p-mid_a1_d1,0.012,0.01);\n    dd = min(dd,dd2);    \n    dd2 = sdCappedCylinder(p-mid_a2_d2,0.012,0.01);\n    dd = min(dd,dd2);   \n    dd2 = sdCappedCylinder(p-mid_a1_2_d1,0.012,0.01);\n    dd = min(dd,dd2);  \n    dd2 = sdCappedCylinder(p-mid_a2_2_d2,0.012,0.01);\n    dd = min(dd,dd2);   \n    \n    // legs\n    dd2 = sdOrientedBox(p,a1,b1,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,a1_2,b1_2,th);\n    dd = min(dd,dd2);    \n    \n    dd2 = sdOrientedBox(p,a2,b2,th);\n    dd = min(dd,dd2);    \n    \n    dd2 = sdOrientedBox(p,a2_2,b2_2,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdCappedCylinder(p-a1,0.012,0.01);\n    dd = min(dd,dd2);\n    \n    dd2 = sdCappedCylinder(p-a1_2,0.012,0.01);\n    dd = min(dd,dd2);\n    \n    dd2 = sdCappedCylinder(p-a2,0.012,0.01);\n    dd = min(dd,dd2);\n    \n    dd2 = sdCappedCylinder(p-a2_2,0.012,0.01);\n    dd = min(dd,dd2);\n    \n    // foot\n    dd2 = sdOrientedBox(p,vec3(b1.x-0.03,b1.y,-z*2.0),vec3(b1.x+0.03,b1.y,-z*2.0),th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,vec3(b1_2.x-0.03,b1_2.y,-z),vec3(b1_2.x+0.03,b1_2.y,-z),th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,vec3(b2.x-0.03,b2.y,z),vec3(b2.x+0.03,b2.y,z),th);\n    dd = min(dd,dd2);    \n    \n    dd2 = sdOrientedBox(p,vec3(b2_2.x-0.03,b2_2.y,0.0),vec3(b2_2.x+0.03,b2_2.y,0.0),th);\n    dd = min(dd,dd2);        \n    \n    return dd;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    p.z = abs(p.z)-0.15;\n    float d = chebyshevLambdaLinkageDist(p);\n    p = prevP;\n    float d2 = p.y+0.208;\n    d2 = sdBox(p+vec3(0,0.215,0.0),vec3(0.7,0.005,0.7));\n    vec2 model = vec2(d,MATERIAL);\n    vec2 model2 = vec2(d2,MATERIAL1);\n    \n    return combine(model,model2);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<3; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(10,10,-10));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    //float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(0.1)*diff*occ;\n    diffCol += col*vec3(1.0)*skyDiff*occ;\n    diffCol += col*vec3(1.0)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 reflectMaterial(vec3 p, vec3 rd, vec3 n) {\n    float IOR = 2.42; //IOR:index of reflection\n    vec3 rdIn = refract(rd,n,1.0/IOR); \n    vec3 refTex = texture(iChannel0,rdIn).rgb;\n    return refTex;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL){\n        vec3 c = vec3(1.2);\n        col = reflectMaterial(p,rd,n);\n    } else if(mat == MATERIAL1){\n        vec3 c = vec3(0.9);\n        col = diffuseMaterial(n,rd,p,c);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0.0, -0.9);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.yz *= Rot(radians(20.0));\n        ro.xz *= Rot(radians(iTime*10.0));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    } else {\n        col = vec3(1.0);\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );\n    \n    float dd = B(uv-vec2(-0.65,-0.32),vec2(0.2,0.14));\n    col = mix(col,vec3(0.0),S(dd,0.0));\n    \n    uv-=vec2(-0.65,-0.34);\n    uv*=2.1;\n    dd = chebyshevLambdaLinkageDist(uv);\n    col = mix(col,vec3(1.0),S(dd,0.0));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}