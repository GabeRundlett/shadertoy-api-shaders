{
    "Shader": {
        "info": {
            "date": "1556189163",
            "description": "ray marching with single bounce reflections and very basic materials",
            "flags": 0,
            "hasliked": 0,
            "id": "wlf3W8",
            "likes": 1,
            "name": "blobs in a box",
            "published": 3,
            "tags": [
                "simple",
                "sdf",
                "bouncereflections"
            ],
            "usePreview": 0,
            "username": "madpew",
            "viewed": 438
        },
        "renderpass": [
            {
                "code": "float box(vec3 p, vec3 c)\n{\n  \tvec3 q = abs(p)-c;\n  \treturn min(0., max(q.x, max(q.y, q.z))) + length(max(q,0.));\n}\n\nfloat sphere(vec3 p, float r)\n{\n  \treturn length(p)-r;\n}\n\nfloat sdf_smin(float a, float b)\n{\n\tfloat res = exp(-12.*a) + exp(-12.*b);\n \treturn -log(max(0.001,res)) / 12.;\n}\n\nvec2 add_object(float f, float id, vec2 current)\n{\n    if (f < current.x) return vec2(f,id);\n    return current;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 result = vec2(999.,-1.);\n    \n    float backwall = box(p, vec3(.9, .9, .05));\n    float leftwall = box(p+vec3(.9,0.,0.), vec3(.05,.9,.9));\n    float rightwall = box(p-vec3(.9,0.,0.), vec3(.05,.9,.9));\n    float floorwall = box(p+vec3(0.,.9,0.), vec3(.95,.05,.9));\n    \n    float room = min(floorwall, min(rightwall, min(backwall, leftwall)));\n    result = add_object(room, 0., result);\n    \n    vec3 rotbase = p+vec3(0.,0.,.5);\n    vec3 rotp = rotbase;\n    rotp.x = rotbase.x * cos(iTime*2.2) - rotbase.z * sin(iTime*2.2);\n  \trotp.z = rotbase.z * cos(iTime*2.2) + rotbase.x * sin(iTime*2.2);\n\n    float bar = box(rotp + vec3(0.,.8,0.), vec3(.38,.05,.05));\n    result = add_object(bar, 2., result);\n    \n    float s1 = sphere(p+vec3(.4*sin(iTime*2.3),.4*cos(iTime*1.4), 0.2), .3);\n    float s2 = sphere(p+vec3(.5*sin(iTime*1.7),.5*cos(iTime*1.2), .3+.3*sin(iTime*.7)), .2);\n    float s3 = sphere(p+vec3(.3*cos(iTime*1.3),.3*sin(iTime*1.7), .4+.35*cos(iTime*.6)), .4);\n    \n    float object =sdf_smin(s3, sdf_smin(s1, s2));\n    \n    result = add_object(object, 1., result);\n\n    float light_ball = sphere(p+vec3(.2*cos(iTime*2.1),.3*sin(iTime*2.1), .5+.2*cos(iTime*1.6)), .15);\n    result = add_object(light_ball, 3., result);\n    \n    float overball = sphere(p+vec3(.5*sin(iTime*2.1),.4*sin(iTime*1.5), .6+.4*cos(iTime*2.1)), .1);\n    result = add_object(overball, 4., result);\n    \n    return result;\n}\n\nvec4 getMaterial(int id)\n{\n    switch(id)\n    {\n        //shiny, light, texture, darken (should be reworked to emissive light)\n        // box\n        case 0: return vec4(0.4,1.,.25,0.);\n        \n        // blobs\n    \tcase 1: return vec4(1.,1.,0.,0.);\n        \n        // bar\n    \tcase 2: return vec4(0.,1.,1.,0);\n        \n        // light ball\n        case 3: return vec4(0.,0.,0.,0.);\n        \n        // dark ball\n        case 4: return vec4(0.,0.,0.,1.);\n    }\n}\n\nvec3 n(vec3 p)\n{\n  vec2 eps = vec2(0.00001, 0.); // eps defines hot smooth the normals are\n  return normalize(vec3(map(p+eps.xyy).x - map(p-eps.xyy).x, map(p+eps.yxy).x - map(p-eps.yxy).x, map(p+eps.yyx).x - map(p-eps.yyx).x));\n}\n\nfloat light(vec3 p)\n{\n  \tvec3 l = vec3(7.*cos(iTime*.5),8.*sin(iTime*.4),-4.);\n  \treturn dot(n(p), normalize(l))*.5+.5;\n}\n\nvec3 background(vec2 uv)\n{\n    vec2 bguv = uv+.01*sin(209.*uv);\n    return vec3(.2,.2,.3) * (mod(bguv.y+bguv.x*.3*cos(iTime+bguv.y*6.),(-bguv.x)*.7)*.9+.95);\n}\n\nvec4 march(vec2 uv)\n{\n  vec3 ro = vec3(0,0,-2.9); // ray origin\n  vec3 rd = normalize(vec3(uv, 1.)); // ray direction / cam direction\n  ro.x += .73*sin(iTime*.62); // simple camera movement and alignment\n  ro.y -= .03;\n    \n  vec3 p = ro; // current point\n  \n  \n    \n  bool hit = false;\n  vec3 color = vec3(1.);\n  vec3 bounce_pos = vec3(0);\n  vec4 bounce_material = vec4(0);\n    \n  for(float i=0.;i<100.; i++) // trace steps\n  { \n    // catch wandering rays\n    if ((abs(p.z) > 3.) || (abs(p.y) > 3.) || (abs(p.x) > 3.))\n    {\n    \tbreak;\n    }      \n      \n  \tvec2 tracehit = map(p); // get SDF (x = distance, y = object id)\n    \n    if (abs(tracehit.x)<0.001)\n    {\n        vec4 material = getMaterial(int(tracehit.y));\n        \n        if (hit == false)\n        {\n            hit = true;\n            bounce_pos = p;\n                \n            color = mix(vec3(1.), vec3(light(p)), material.y);\n            color *= mix(vec3(1.), texture(iChannel0, cos(p.xy)+p.yz+sin(p.zx)).xyz, material.z);\n            color *= (1.-material.w);\n            if (material.x > 0.)\n            {\n            \trd = reflect(rd,n(p));\n            \tp += rd * 0.0011;\n                bounce_material = material;\n            \tcontinue;\n            }\n            break;\n        } else {\n            // bounce hit\n            vec3 bounce_color = mix(vec3(1.), vec3(light(p)), material.y);\n            bounce_color *= mix(vec3(1.), texture(iChannel0, cos(p.xy)+p.yz+sin(p.zx)).xyz, material.z);\n            bounce_color *= (1.-material.w);\n            float bounce_distance = 1. - clamp(length(bounce_pos-p),0.,.75);\n            color = mix(color, bounce_color, bounce_material.x * bounce_distance); \n            break;\n        }\n    }\n  \tp += tracehit.x * rd;\n  }\n  \n  if (!hit)\n  {\n      color = background(uv);\n  }\n  \n  return vec4(color,1);\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.98 *iTime,78.233)))*43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    \n    //pixelate\n    //uv -= mod(uv,0.0025);\n    \n\tfragColor = march(uv);\n\t\n  \t// gamma and grading\n  \tfragColor = pow(fragColor, .8*vec4(.9,1.0,.9,1));\n   \n  \t// white vignette\n  \tfragColor = mix(fragColor,vec4(random(uv)),length(uv)*.1);\n    fragColor = clamp(fragColor, 0.,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}