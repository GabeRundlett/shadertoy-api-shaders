{
    "Shader": {
        "info": {
            "date": "1492389928",
            "description": " keys : WASD\n\nfork of https://www.shadertoy.com/view/lstSRM\nminor improvements.\nfocus on quaternion rotation.",
            "flags": 48,
            "hasliked": 0,
            "id": "lsScWm",
            "likes": 7,
            "name": " 012b Ball Forker",
            "published": 3,
            "tags": [
                "3d",
                "terrain",
                "ball",
                "quaternion",
                "buffer"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 715
        },
        "renderpass": [
            {
                "code": "// Memory Props\nvec2 mPos     = vec2(1., 0.);\nvec2 mCamPos  = vec2(2., 0.);\nvec2 mQuat    = vec2(4., 0.);\n\nvec3 gBallPos;\nvec3 gCamPos;\nvec4 gBallQuat;\n\n\nconst float gBallRadius=1.;\n\n\nvec4 Load(in sampler2D s,vec2 r,in vec2 p){\n return texture(s,(p+.5)/r);}\n\n//return v, rotated by quaternion q\nvec3 Rotate(vec4 q, vec3 v){vec3 t=2.*cross(q.xyz,v);\n return v+q.w*t+cross(q.xyz,t);}\n\nvec2 MapBall(in vec3 p, out vec3 c){\n c=Rotate(gBallQuat,p-gBallPos-vec3(0,1,0));\n return vec2(length(c)-gBallRadius,1);}\n\nvec2 MapTerrain(in vec3 p){float h=\n  sin(    p.x*.1)*1.5\n +sin(1.8*p.x*.1)*0.2\n +cos(0.6+p.z*.1)*1.0\n +sin(    p.z*.2)*0.2;return vec2(p.y-h-1.,2.);}\n\nvec2 Map(in vec3 p, out vec3 c){\n    vec2 a=MapTerrain(p),b=MapBall(p,c);\n    if(b.x<a.x)return b;return a;}\n\nvec2 Intersect(vec3 o, vec3 d, float n, float m, out vec3 c){\n float k=n;\n vec2 r=vec2(m);\n for(int i=0;i<160;++i){\n  vec2 t=Map(o+d*k,c);\n   k+=t.x;\n   if(t.x<.01){r=vec2(k,t.y);break;}\n }return r;}\n\n#define mm(a) Map(p+e.a,d).x-c\nvec3 CalcNormal(vec3 p){vec3 d;\n vec2 e=vec2(1e-3,0.);float c=Map(p,d).x;\n return normalize(vec3(mm(xyy),mm(yxy),mm(yyx)));}\n\nvec3 Shade(vec3 c, vec3 n, vec3 v, vec3 l){\n c*=.05+.95*pow(max(dot(n,-v),0.),2.);\n float s=pow(max(dot(reflect(v,n),l), 0.), 25.);\n return c+s*vec3(1);}\n\n\nfloat checkerMod(vec3 p){p=floor(p*.5);return mod(p.x+p.y+p.z,2.);}\n\n\nvec3 GetColor(float id, vec3 p, vec3 c, vec3 d, inout vec3 n){\n if(id < 1.5){\n  return vec3(checkerMod(c*5.))*c;        \n  //return texture(iChannel1, normalize(coord)).xyz+c*0.25; \n }else return vec3(.3,.6,.9);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n vec2 u=(fragCoord.xy-iResolution.xy*0.5) / iResolution.y;\n gBallPos  = Load(iChannel0, iChannelResolution[0].xy, mPos).xyz;\n gBallPos.y = -MapTerrain(vec3(gBallPos.x, 0., gBallPos.z)).x;\n gCamPos  = Load(iChannel0, iChannelResolution[0].xy, mCamPos).xyz;\n gCamPos.y+=2.;\n gBallQuat = Load(iChannel0, iChannelResolution[0].xy, mQuat);\n vec3 target=gBallPos,\n o=gCamPos,\n \n //lazy camera()\n front = normalize(target+vec3(0., 4.0, 0.)-o),\n right = cross(vec3(0., 1, 0.), front),\n up=cross(front, right),\n d=normalize(front + 35.*(3.14159/180.)*(right*u.x + up*u.y)),\n \n coord,color=vec3(.03);\n const vec3 l=normalize(vec3(-.1,.5,-.1));                \n    float w=1.;\n    for(int i=0;i<3;++i){//accumulate reflections\n        vec2 res = Intersect(o, d, 0.1, 100., coord);\n        if(res.x<100.){\n            vec3 p=o + res.x * d;\n            vec3 n = CalcNormal(p);\n            vec3 tmpColor = GetColor(res.y, p, coord, d, n);\n            color += Shade(tmpColor, n, d, l)*w;\n            \n            if(res.y<1.5)break;\n            else{//reflect\n                d=reflect(d, n); d.y *= 0.8;\n                o=p;\n                w*=.25;\n        }}else{\n            vec3 tmpColor = vec3(.5,.3,.2);\n            color += mix(vec3(.8,.8,.6),color,smoothstep(0., 1., pow(abs(d.y+0.02)*4., 0.5)))*0.2*w;\n            vec3 farPos = d * 4./d.z;\n            vec2 uv = farPos.xy*vec2(0.5, 1.)*0.40-vec2(-0.50, -0.40);\n            //vec3 texColor = texture(iChannel3, uv).rgb;\n            break;\n }}fragColor=vec4(pow(color,vec3(1./2.2)),1.);}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//quaternion rotation from keyboard input and sinusoidial terrain\n\n//in its original\n//https://www.shadertoy.com/view/lstSRM\n//you apply impulse in .xy directions, \n//leading to movement and rotation due to angulat momentum\n\n#define gBallRadius 1.\n//relevant for angular momentum\n\nfloat gTime,gDt;//gets set to iTime,iTimeDelata, for clean init.\n\nconst float SP= exp2(-126.);//smallest positive 16bit float //SP<1e-15\n//if(iTime=floor(iTime*1000.)/1000.){SP=1e-3 is small enough here.} == (shadertoy rounds the value iTime)\n//but exp2(-126) is future-proof.\n\n//if(distance field size is not too large (by using mod() tiling or scaling) this is useful for normal()-calculationon \nconst float SPH= exp2(-13.);\n//for more precise normals close to concave areas, fratals, sharp corners.\n//will fail if any(p.xyz) is too far away from vec3(0)\n\n//Address.Memory\nconst float \nmState =0.,\nmPos   =1.,\nmCamPos=2.,\nmVel   =3.,\nmQuat  =4.,\n//Address.KeyboardIO\n#define l(a,b) a=(float(b+64)+.5)/255.\n l(KEY_A,1),l(KEY_B,2),l(KEY_C,3),l(KEY_D,4),l(KEY_E,5),\n l(KEY_F,6),l(KEY_G,7),l(KEY_H,8),l(KEY_I,9),l(KEY_J,10),l(KEY_K,11),\n l(KEY_L,12),l(KEY_M,13),l(KEY_N,14),l(KEY_O,15),l(KEY_P,16),\n l(KEY_Q,17),l(KEY_R,18),l(KEY_S,19),l(KEY_T,20),l(KEY_U,21),\n l(KEY_V,22),l(KEY_W,23),l(KEY_X,24),l(KEY_Y,25),l(KEY_Z,26);\n\nvec3 camDir=vec3(0.,0.,-15.);\n\nfloat IsInside(in vec2 valueCoord, in vec2 p){\n vec2 res=abs(p-.5-valueCoord)-.5;return -max(res.x,res.y);}\n\nvec4 Load(in sampler2D s,in vec2 r,in float p){\n return texture(s,vec2(p+.5,0.)/r);}\nvec3 Load3(in sampler2D s,in vec2 r,in float p){\n return texture(s,vec2(p+.5,0.)/r).xyz;}\n   // return texture(s,vec2((p+.5)/r),0.);}\nvoid Save(in float p,in vec4 v,in vec2 i,inout vec4 o){\n o=IsInside(vec2(p,0.),i)>0.?v:o;}\n#define Save3(a,b,c,d) Save(a,vec4(b,0.),c,d)\n//eg: \n//vec4 state=Load(iChannel0,iChannelResolution[0].xy,mCamPos);//load data from THIS buffer.\n//campos+=CameraMovement;\n//Save(mCamPos,camPos,fragCoord,fragColor);//save data to this buffer, in void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n//above is a bit slower and more flexible and user friendly than putting save() inside branching cases.\n\n//quaternions\n//normalize quaternion: true for quaternions <-> nornamoze(q)=q/length(q)==q/length(q*q)=q/dot(q,q)\nvec4 q(vec4 q){return q/dot(q,q);}\n//return quaternin of [axis]&{angle] rotation\nvec4 q(vec3 axis, float angle){angle*=.5;return q(vec4(axis*sin(angle),cos(angle)));}\n//return [r]rotation, rotated by [b] //use like matrix multiplication\nvec4 r(vec4 b,vec4 r){return q(vec4(b.w*r.xyz+r.w*b.xyz+cross(b.xyz,r.xyz),b.w*r.w-dot(b.xyz,r.xyz)));}\n//return [r]vector, rotated by [b] //use like matrix multiplication\nvec3 r(vec4 b,vec3 r){vec3 t=2.*cross(b.xyz, r);\n return r+b.w*t+cross(b.xyz,t);}\n//from  https://www.shadertoy.com/view/lstSRM\n\n//return distance of [p] to sinusiodual floor.\nfloat df(in vec3 p){\n float h=\n  sin(    p.x*0.1)*1.5\n +sin(1.8*p.x*0.1)*0.2\n +cos(0.6+p.z*0.1)*1.0\n +sin(    p.z*0.2)*0.2;\n return p.y-h-1.;}\n\n//calculate normal\n#define cn(a) df(p+vec2(SPH,0.).a)-df(p)\n#define ld(a,b) vec4 b=lc0(a);vec3 a=b.xyz;\nvec3 CalcNormal(vec3 p){return normalize(vec3(cn(xyy),cn(yxy),cn(yyx)));}\n\n#define lc3(a) Load3(iChannel0,iChannelResolution[0].xy,a);\n#define lc4(a) Load(iChannel0,iChannelResolution[0].xy,a);\n\nvoid mainImage( out vec4 Out, in vec2 In){\n gTime=iTime;\n gDt  =iTimeDelta;\n Out=texture(iChannel0,In/iResolution.xy);\n vec3 vel=lc3(mVel);\n vec3 state=lc3(mState);\n vec3 pos=lc3(mPos);\n vec3 camPos=lc3(mCamPos);\n //loading all the values.\n if(iFrame==0||iTime < 1e-3) \n  Save(mState,vec4(0),In,Out);\n if(state.x<.5){//init matters fopr linux\n  camPos=camDir;\n  pos=vec3(0.);\n  vel=vec3(0.);\n  Save(mQuat ,vec4(0,0,0,1),In,Out);\n  Save(mState,vec4(1),In,Out);\n }else{     \n  vec3 up    =vec3(0,1,0);\n  vec3 front =vec3(0,0,1);\n  vel *=.98;//friction    \n  #define t3(a) texture(iChannel3,vec2(a,.2)).x\n  #define t2(a,b) (t3(a)-t3(b))\n  vel+=t2(KEY_D,KEY_A)*vec3(1,0,0);//left\n  vel+=t2(KEY_W,KEY_S)*vec3(0,0,1);//front\n        \n  vel.xz+=CalcNormal(pos.xyz).xz;// add normal vel\n            \n  vec3 deltaPos=vel.xyz*gDt;\n  pos.xyz+=deltaPos;\n        \n  // cam pos\n  vec3 newCamPos = pos.xyz + camDir + vec3(0., 2.0, 0.);\n  camPos.xyz = mix(camPos.xyz,newCamPos,5.*gDt);//smoother followcam\n        \n  //if(ball moved enough) update ball rotation\n  if(length(vel)>1e-10){\n   vec4 quat=lc4(mQuat);\n   vec3 axis  =cross(normalize(vel.xyz),vec3(0., 1., 0.));\n   float angle=length(deltaPos)/gBallRadius;\n   vec4 currQuat = q(axis, angle);\n   quat=r(quat,currQuat);\n   Save(mQuat  ,quat  ,In,Out);\n  }\n  Save3(mPos   ,pos   ,In,Out);\n  Save3(mCamPos,camPos,In,Out);\n  Save3(mVel   ,vel   ,In,Out);\n}}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}