{
    "Shader": {
        "info": {
            "date": "1457882260",
            "description": "Another flight through Gotham, now with user control and adjustable perspective.",
            "flags": 32,
            "hasliked": 0,
            "id": "4s3XzN",
            "likes": 22,
            "name": "Pannini Flies Gotham",
            "published": 3,
            "tags": [
                "raymarching",
                "interactive",
                "projection",
                "widgets",
                "flythrough",
                "cityscape"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 1739
        },
        "renderpass": [
            {
                "code": "// \"Pannini Flies Gotham\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  See \"Pannini's Rotunda\" for background info.\n  Vertical slider controls flight speed.\n  Horizontal sliders control zoom and Pannini factor.\n  Look around using the mouse.\n  Scenery based on earlier \"Gotham\" (daytime flythrough mode only).\n*/\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat IFbm1 (float p)\n{\n  float s, a;\n  p *= 5.;\n  s = 0.;\n  a = 10.;\n  for (int j = 0; j < 4; j ++) {\n    s += floor (a * Noiseff (p));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return 0.1 * s;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat PrOBoxDf (vec3 p, vec3 b)\n{\n  return length (max (abs (p) - b, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst float txRow = 64.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nmat3 vuMat;\nvec3 vuPos, qHit, sunDir;\nvec2 iqBlk, cTimeV;\nfloat dstFar, tCur, qcCar, cDir, flrHt;\nint idObj;\nconst int idBldgF = 1, idBldgC = 2, idRoad = 3, idSWalk = 4, idCarWhl = 5,\n   idCarBdy = 6, idTrLight = 7, idTwr = 8, idTwrTop = 9;\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  if (rd.y >= 0.) {\n    ro.xz += 2. * tCur;\n    sd = max (dot (rd, sunDir), 0.);\n    col = vec3 (0., 0., 0.6) + 0.3 * pow (1. - rd.y, 8.) +\n       0.35 * pow (sd, 6.) + 0.65 * min (pow (sd, 256.), 0.3);\n    f = Fbm2 (0.05 * (ro.xz + rd.xz * (100. - ro.y) / max (rd.y, 0.001)));\n    col = mix (col, vec3 (1.), clamp (0.1 + 0.8 * f * rd.y, 0., 1.));\n  } else {\n    col = mix (vec3 (0.4, 0.5, 0.2), 0.95 * vec3 (0.4, 0.4, 0.9),\n       pow (1. + rd.y, 8.));\n  }\n  return col;\n}\n\nfloat BldgDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  vec2 ip;\n  float d, bWid, bWidU, bHt, bHtU, bShape, tWid, hiMid, twHt;\n  bool bTall;\n  ip = floor (p.xz);\n  hiMid = dot (ip, ip);\n  bTall = (hiMid == 0.);\n  hiMid = 0.75 * clamp (4. / max (sqrt (hiMid), 1.), 0., 1.);\n  d = p.y;\n  if (d < dMin) { dMin = d;  idObj = idRoad;  qHit = p;  iqBlk = ip; }\n  q = p;\n  q.xz = fract (q.xz) - vec2 (0.5);\n  bWid = floor ((0.2 + Hashfv2 (11. * ip) * 0.1) / flrHt + 0.5) * flrHt;\n  bWidU = floor (bWid * (0.5 + 0.3 * Hashfv2 (12. * ip)) / flrHt + 0.5) * flrHt;\n  bHt = (0.5 * Hashfv2 (13. * ip) + 0.05) * hiMid *\n     (1.5 + (bWid - 0.15) / flrHt) + 0.1;\n  bHtU = 0.25 * bHt + 0.75 * max (0., Hashfv2 (15. * ip) - 0.5) * hiMid + 0.05;\n  bHt = (floor (bHt / flrHt) + 0.2) * flrHt;\n  bHtU = floor (bHtU / flrHt) * flrHt;\n  if (bHtU > 0.) bHtU += 0.2 * flrHt;\n  if (bTall) {\n    bHt = max (bHt, 40.2 * flrHt);\n    bHtU = max (bHtU, 20.2 * flrHt);\n  }\n  tWid = ((bHtU > 0.) ? bWidU : bWid) - 0.0125;\n  bShape = Hashfv2 (17. * ip);\n  q.y -= 0.0015;\n  d = PrOBoxDf (q, vec3 (0.35, 0.0015, 0.35));\n  if (d < dMin) { dMin = d;  idObj = idSWalk;  qHit = p; }\n  q.y -= 0.0015;\n  qq = q;\n  qq.y -= bHt - 0.2 * flrHt - 0.001;\n  if (bShape > 0.25) {\n    d = PrOBoxDf (qq, vec3 (bWid, bHt, bWid));\n    if (d < dMin) { dMin = d;  idObj = idBldgF;  qHit = qq;  iqBlk = ip; }\n  } else {\n    d = PrCylDf (qq.xzy, bWid, bHt);\n    if (d < dMin) { dMin = d;  idObj = idBldgC;  qHit = qq;  iqBlk = ip; }\n  }\n  qq.y -= bHt + bHtU - 0.2 * flrHt - 0.001;\n  if (bHtU > 0.) {\n    if (bShape > 0.5) {\n      d = max (PrOBoxDf (qq, vec3 (bWidU, bHtU, bWidU)),\n         - PrOBoxDf (qq - vec3 (0., bHtU, 0.),\n         vec3 (tWid, 0.1 * flrHt, tWid)));\n      if (d < dMin) { dMin = d;  idObj = idBldgF;  qHit = qq;  iqBlk = ip; }\n    } else {\n      d = max (PrCylDf (qq.xzy, bWidU, bHtU),\n         - PrCylDf ((qq - vec3 (0., bHtU, 0.)).xzy, tWid, 0.1 * flrHt));\n      if (d < dMin) { dMin = d;  idObj = idBldgC;  qHit = qq;  iqBlk = ip; }\n    }\n  }\n  qq.y -= bHtU - 0.2 * flrHt - 0.001;\n  if (bShape < 0.1) {\n    d = PrCapsDf (qq.xzy, 0.4 * bWidU, 1.25 * flrHt);\n    if (d < dMin) { dMin = d;  idObj = idBldgC;  qHit = qq;  iqBlk = ip; }\n  } else if (bShape > 0.7) {\n    d = PrOBoxDf (qq, vec3 (0.25 * bWidU, 1.25 * flrHt, 0.25 * bWidU));\n    if (d < dMin) { dMin = d;  idObj = idBldgF;  qHit = qq;  iqBlk = ip; }\n  }\n  if (bHt + bHtU > 30. * flrHt) {\n    twHt = 0.1 * (bHt + bHtU);\n    qq.y -= twHt;\n    d = PrCapsDf (qq.xzy, 0.3 * flrHt, twHt);\n    if (d < dMin) {\n      dMin = d;  qHit = qq;  iqBlk = ip;\n      idObj = (qq.y > 0.9 * twHt) ? idTwrTop : idTwr;  \n    }\n  }\n  if (bTall) {\n    qq = q;\n    qq.y -= 2. * (bHt + bHtU) + 0.2 * flrHt;\n    d = PrCylDf (qq.xzy, 0.3, 1.2 * flrHt);\n    if (d < dMin) { dMin = d;  idObj = idBldgC;  qHit = qq;  iqBlk = ip; }\n  }\n  return dMin;\n}\n\nfloat TrLightDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.xz = abs (fract (q.xz) - vec2 (0.5)) - vec2 (0.345);\n  q.y -= 0.023;\n  d = PrCylDf (q.xzy, 0.002, 0.02);\n  if (d < dMin) { dMin = d;  idObj = idTrLight;  qHit = q; }\n  return dMin;\n}\n\nvec4 CarPos (vec3 p)\n{\n  vec3 q;\n  float vDir, cCar;\n  if (cDir == 0. && abs (fract (p.z) - 0.5) > 0.35 ||\n     cDir == 1. && abs (fract (p.x) - 0.5) < 0.35) {\n    p.xz = vec2 (- p.z, p.x);\n    vDir = 0.;\n  } else {\n    vDir = 1.;\n  }\n  q = p;\n  q.y -= -0.003;\n  q.z += 3. * floor (q.x);\n  q.x = fract (q.x) - 0.5;\n  q.z *= 2. * step (0., q.x) - 1.;\n  q.z -= cTimeV.x + ((cDir == vDir) ? vDir + cTimeV.y : 1.);\n  cCar = floor (20. * q.z);\n  q.z = fract (q.z) - 0.5;\n  q.x = abs (q.x) - 0.395 - 0.06 * step (0.7, Hashff (11. * cCar)) -\n     0.03 * Hashff (13. * cCar);\n  return vec4 (q, cCar);\n}\n\nfloat CarDf (vec3 p, float dMin)\n{\n  vec4 q4;\n  vec3 q;\n  float d, bf;\n  q4 = CarPos (p);\n  q = q4.xyz;\n  bf = PrOBoxDf (q + vec3 (0., 0., -0.1), vec3 (0.015, 0.05, 0.2));\n  q.z = mod (q.z, 0.05) - 0.025;\n  d = SmoothMin (PrOBoxDf (q + vec3 (0., -0.008, 0.), vec3 (0.007, 0.002, 0.015)),\n     PrOBoxDf (q + vec3 (0., -0.015, 0.003), vec3 (0.0035, 0.0003, 0.005)), 0.02);\n  d = max (d, bf);\n  if (d < dMin) { dMin = d;  idObj = idCarBdy;  qHit = q;  qcCar = q4.w; }\n  q.xz = abs (q.xz) - vec2 (0.0085, 0.01);\n  q.y -= 0.006;\n  d = max (PrCylDf (q.yzx, 0.003, 0.0012), bf);\n  if (d < dMin) { dMin = d;  idObj = idCarWhl;  qHit = q; }\n  return 0.7 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  dMin = BldgDf (p, dMin);\n  dMin = TrLightDf (p, dMin);\n  dMin = CarDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 srd, dda, h;\n  float dHit, d;\n  srd = 1. - 2. * step (0., rd.xz);\n  dda = - srd / (rd.xz + 0.0001);\n  dHit = 0.;\n  for (int j = 0; j < 240; j ++) {\n    p = ro + dHit * rd;\n    h = fract (dda * fract (srd * p.xz));\n    d = ObjDf (p);\n    dHit += min (d, 0.2 + max (0., min (h.x, h.y)));\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.0001, -0.0001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 40; j ++) {\n    h = BldgDf (ro + rd * d, dstFar);\n    sh = min (sh, smoothstep (0., 1., 20. * h / d));\n    d += min (0.05, 3. * h);\n    if (h < 0.001) break;\n  }\n  return max (sh, 0.);\n}\n\nvec4 ObjCol (vec3 ro, vec3 rd, vec3 vn)\n{\n  vec3 col;\n  vec2 g, b;\n  float wFac, f, ff, spec;\n  wFac = 1.;\n  col = vec3 (0.);\n  spec = 0.;\n  if (idObj == idBldgF || idObj == idBldgC) {\n    col = HsvToRgb (vec3 (0.7 * Hashfv2 (19. * iqBlk), 0.2,\n       0.4 + 0.2 * Hashfv2 (21. * iqBlk)));\n    if (abs (vn.y) < 0.05) {\n      f = mod (qHit.y / flrHt - 0.2, 1.) - 0.5;\n      wFac = 1. - (step (0., f) - 0.5) * step (abs (abs (f) - 0.24), 0.02) -\n         0.801 * step (abs (f), 0.22);\n      if (wFac < 0.2) {\n        f = (idObj == idBldgF) ? 1.5 * dot (qHit.xz, normalize (vn.zx)) :\n           length (qHit.xz) * (atan (qHit.z, qHit.x) + 0.5 * pi);\n        wFac = min (0.2 + 0.8 * floor (fract (f / flrHt + 0.25) *\n           (1. + Hashfv2 (51. * iqBlk))), 1.);\n      }\n      col *= wFac;\n      spec = 0.3;\n    } else if (vn.y > 0.95) {\n      g = step (0.05, fract (qHit.xz * 70.));\n      col *= mix (0.8, 1., g.x * g.y);\n    }\n    if (vn.y < 0.95 && wFac > 0.5)\n       col *= (0.8 + 0.2 * Noisefv2 (512. * vec2 (qHit.x + qHit.z, qHit.y)));\n  } else if (idObj == idTwr) {\n    col = vec3 (0.3);\n    spec = 0.3;\n  } else if (idObj == idTwrTop) {\n     col = vec3 (1., 0., 0.);\n     spec = -1.;\n  } else if (idObj == idSWalk) {\n    g = step (0.05, fract (qHit.xz * 35.));\n    col = vec3 (0.2) * mix (0.7, 1., g.x * g.y);\n  } else if (idObj == idTrLight) {\n    f = 2. * (atan (qHit.z, qHit.x) / pi + 1.) + 0.5;\n    ff = floor (f);\n    if (abs (qHit.y - 0.014) < 0.004 && abs (f - ff) > 0.3) {\n      col = mix (vec3 (0., 1., 0.), vec3 (1., 0., 0.),\n         (mod (ff, 2.) == 0.) ? cDir : 1. - cDir);\n      spec = -2.;\n    } else {\n      col = vec3 (0.4, 0.2, 0.1);\n      spec = 0.5;\n    }\n  } else if (idObj == idCarBdy) {\n    col = HsvToRgb (vec3 (Hashff (qcCar * 37.), 0.9,\n       0.4 + 0.6 * vec3 (Hashff (qcCar * 47.))));\n    f = abs (qHit.z + 0.003);\n    wFac = max (max (step (0.001, f - 0.005) * step (0.001, abs (qHit.x) - 0.0055),\n       step (f, 0.001)), step (0.0015, abs (qHit.y - 0.0145)));\n    col *= wFac;\n    spec = 0.5;\n    if (abs (qHit.z) > 0.015) {\n      g = vec2 (qHit.x, 3. * (qHit.y - 0.008));\n      if (qHit.z > 0. && dot (g, g) < 3.6e-5) col *= 0.3;\n      g = vec2 (abs (qHit.x) - 0.005, qHit.y - 0.008);\n      f = dot (g, g);\n      if (qHit.z > 0. && f < 2.2e-6) {\n        col = vec3 (1., 1., 0.3);\n        spec = -2.;\n      } else if (qHit.z < 0. && f < 1.1e-6) {\n        col = vec3 (1., 0., 0.);\n        spec = -2.;\n      }\n    }\n  } else if (idObj == idCarWhl) {\n    if (length (qHit.yz) < 0.0015) {\n      col = vec3 (0.7);\n      spec = 0.8;\n    } else {\n      col = vec3 (0.03);\n    } \n  } else if (idObj == idRoad) {\n    g = abs (fract (qHit.xz) - 0.5);\n    if (g.x < g.y) g = g.yx;\n    col = mix (vec3 (0.05), vec3 (0.08), step (g.x, 0.355));\n    f = ((step (abs (g.x - 0.495), 0.002) + step (abs (g.x - 0.365), 0.002)) +\n       step (abs (g.x - 0.44), 0.0015) * step (fract (g.y * 18. + 0.25), 0.7)) *\n       step (g.y, 0.29);\n    col = mix (col, vec3 (0.5, 0.4, 0.1), f);\n    f = step (0.6, fract (g.x * 30. + 0.25)) * step (0.36, g.x) *\n       step (abs (g.y - 0.32), 0.02);\n    col = mix (col, vec3 (0.6), f);\n    b = CarPos (ro).xz;\n    g = abs (b + vec2 (0., -0.1)) - vec2 (0.015, 0.2);\n    b.y = mod (b.y, 0.05) - 0.025;\n    b = abs (b) * vec2 (1.55, 1.);\n    if (max (g.x, g.y) < 0. && max (b.x, b.y) < 0.016) col *= 0.6;\n  }\n  if (wFac < 0.5) {\n    rd = reflect (rd, vn);\n    g = Rot2D (rd.xz, 5.1 * atan (20. + iqBlk.y, 20. + iqBlk.x));\n    col = 0.8 * (0.2 + 0.8 * (step (1., 0.5 * ro.y + 3. * rd.y -\n       0.2 * floor (5. * IFbm1 (0.3 * atan (g.y, g.x) + pi) + 0.05)))) *\n       BgCol (ro, rd);\n    spec = -1.;\n  }\n  return vec4 (col, spec);\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, float zmVar, float pnVar, float fvVar)\n{\n  vec4 wgBx[3];\n  vec2 ust;\n  float asp;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (0.47 * asp, -0.2, 0.012 * asp, 0.15);\n  wgBx[1] = vec4 (0.13 * asp, -0.46, 0.1 * asp, 0.022);\n  wgBx[2] = vec4 (0.37 * asp, -0.46, 0.1 * asp, 0.022);\n  ust = abs (0.5 * uv - wgBx[0].xy) - wgBx[0].zw;\n  if (abs (max (ust.x, ust.y)) * canvas.y < 1.) col = vec3 (0.8);\n  ust = 0.5 * uv - wgBx[0].xy;\n  ust.y -= (fvVar - 0.5) * 2. * wgBx[0].w;\n  if (abs (length (ust) - 0.8 * wgBx[0].z) * canvas.y < 2.)\n     col = (fvVar * canvas.y > 15.) ? vec3 (0.1, 1., 0.1) : vec3 (1., 0.1, 0.1);\n  ust = abs (0.5 * uv - wgBx[1].xy) - wgBx[1].zw;\n  if (abs (max (ust.x, ust.y)) * canvas.y < 1.) col = vec3 (0.8);\n  ust = 0.5 * uv - wgBx[1].xy;\n  ust.x -= (zmVar - 0.5) * 2. * wgBx[1].z;\n  ust = abs (ust) - 0.6 * wgBx[1].ww;\n  if (abs (max (ust.x, ust.y)) * canvas.y < 2.) col = vec3 (1., 0.3, 1.);\n  ust = abs (0.5 * uv - wgBx[2].xy) - wgBx[2].zw;\n  if (abs (max (ust.x, ust.y)) * canvas.y < 1.) col = vec3 (0.8);\n  ust = 0.5 * uv - wgBx[2].xy;\n  ust.x -= (pnVar - 0.5) * 2. * wgBx[2].z;\n  ust = abs (ust) - 0.6 * wgBx[2].ww;\n  if (abs (max (ust.x, ust.y)) * canvas.y < 2.) col =\n     (pnVar > 0.3) ? vec3 (1., 0., 0.1) : ((pnVar > 0.1) ?\n     vec3 (1., 1., 0.1) : vec3 (0.1, 1., 0.1));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 col, bgCol, vn;\n  float dstHit, sh;\n  int idObjT;\n  bgCol = BgCol (ro, rd);\n  dstHit = ObjRay (ro, rd);\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    objCol = ObjCol (ro, rd, vn);\n    col = objCol.rgb;\n    if (objCol.a >= 0.) {\n      if (idObj == idRoad) vn = VaryNf (500. * qHit, vn, 2.);\n      else if (idObj == idBldgF || idObj == idBldgC)\n         vn = VaryNf (500. * qHit, vn, 0.5);\n      sh = 0.2 + 0.8 * ObjSShadow (ro, sunDir);\n      col = col * (0.2 + 0.1 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n         0.8 * sh * max (dot (vn, sunDir), 0.) +\n         sh * objCol.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 128.));\n    } else if (objCol.a == -1.) {\n      if (idObj == idBldgF || idObj == idBldgC || idObj == idTwrTop) col *= 0.2;\n    }\n    col = mix (col, bgCol, smoothstep (0.4, 1., dstHit / dstFar));\n  } else col = bgCol;\n  return pow (clamp (col, 0., 1.), vec3 (0.6));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, cTime, tRep, sunAz, sunEl, asp, zmVar, pnVar, fvVar, zmFac,\n     pnFac, a, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  stDat = Loadv4 (0);\n  zmVar = stDat.x;\n  pnVar = stDat.y;\n  el = stDat.z;\n  az = stDat.w;\n  stDat = Loadv4 (1);\n  fvVar = stDat.y;\n  tRep = 80.;\n  dstFar = 40.;\n  flrHt = 0.05;\n  sunAz = pi * sin (0.006 * 2. * pi * tCur);\n  sunEl = pi * (0.3 + 0.15 * sin (0.44 * sunAz));\n  sunDir = vec3 (cos (sunAz) * cos (sunEl), sin (sunEl), sin (sunAz) * cos (sunEl));\n  cTime = 0.15 * mod (tCur, tRep);\n  cDir = mod (floor (cTime), 2.);\n  cTimeV = vec2 (floor (0.5 * floor (cTime)), mod (cTime, 1.));\n  stDat = Loadv4 (3);\n  ro = stDat.xyz;\n  ori = vec2 (el, az + stDat.w);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  asp = canvas.x / canvas.y;\n  zmFac = 0.2 + 3.8 * zmVar;\n  pnFac = exp (5. * pnVar) - 1.;  \n  a = atan (uv.x / (asp * zmFac));\n  rd = vuMat * normalize (vec3 (((1. + pnFac) * sin (a) / (pnFac + cos (a))) * asp,\n     uv.y / zmFac, 1.));\n  col = (abs (uv.y) < 0.85) ? ShowScene (ro, rd) : vec3 (0.1, 0.1, 0.2);\n  t = step (50. * abs (mod (tCur / tRep + 0.5, 1.) - 0.5),\n     max (abs (uv.x), abs (uv.y) * asp / 0.85) / max (1., asp));\n  col = mix (col, vec3 (0.1, 0.1, 0.2), t);\n  col = ShowWg (uv, canvas, col, zmVar, pnVar, fvVar);\n  fragColor = vec4 (col, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Pannini Flies Gotham\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float pi = 3.14159;\n\nconst float txRow = 64.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat tCur;\n\nvec3 TrackPath (float s)\n{\n  vec3 p;\n  float pLen, scnCount;\n  scnCount = mod (floor (tCur / 80.), 7.);\n  pLen = 4.;\n  p.y = 0.15 + 0.5 * SmoothBump (0.4, 0.7, 0.1, mod (0.53 * s, 1.)) +\n     1.5 * SmoothBump (0.4, 0.7, 0.07, mod (0.31 * s, 1.));\n  s = mod (s + scnCount, 4.);\n  if (s < 1.) {\n    p.x = 1.;\n    p.z = -1. + 2. * s;\n  } else if (s < 2.) {\n    p.x = 1. - 2. * (s - 1.);\n    p.z = 1.;\n  } else if (s < 3.) {\n    p.x = -1.;\n    p.z = 1. - 2. * (s - 2.);\n  } else if (s < 4.) {\n    p.x = -1. + 2. * (s - 3.);\n    p.z = -1.;\n  }\n  p.xz *= pLen;\n  p.x *= (mod (tCur / 80., 2.) > 1.) ? - 1. : 1.;\n  p.x += (scnCount - 3.) * pLen;\n  return p;\n}\n\nvec4 FlyPR (float s)\n{\n  vec3 fpF, fpB, vd;\n  float ds;\n  ds = 0.02;\n  fpF = TrackPath (s + ds);\n  fpB = TrackPath (s - ds);\n  vd = fpF - fpB;\n  return vec4 (0.5 * (fpF + fpB), - (atan (vd.z, vd.x) - 0.5 * pi));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[3], stDat, mPtr, mPtrP;\n  vec2 iFrag, canvas, ust;\n  float az, el, asp, zmVar, pnVar, fvVar, flSpd, flMov, tCurP;\n  int pxId, wgSel, wgReg;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4) discard;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  zmVar = 0.3;\n  pnVar = 0.25;\n  fvVar = 0.3;\n  flMov = 0.;\n  el = 0.;\n  az = 0.;\n  wgSel = -1;\n  wgReg = -2;\n  if (iFrame <= 5) {\n    mPtrP = mPtr;\n  } else {\n    stDat = Loadv4 (0);\n    zmVar = stDat.x;\n    pnVar = stDat.y;\n    el = stDat.z;\n    az = stDat.w;\n    stDat = Loadv4 (1);\n    wgSel = int (stDat.x);\n    fvVar = stDat.y;\n    flMov = stDat.z;\n    tCurP = stDat.w;\n    mPtrP = Loadv4 (2);\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.47 * asp, -0.2, 0.012 * asp, 0.15);\n    wgBx[1] = vec4 (0.13 * asp, -0.46, 0.1 * asp, 0.022);\n    wgBx[2] = vec4 (0.37 * asp, -0.46, 0.1 * asp, 0.022);\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[0].xy) - wgBx[0].zw;\n    if (max (ust.x, ust.y) < 0.) wgReg = 0;\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[1].xy) - wgBx[1].zw;\n    if (max (ust.x, ust.y) < 0.) wgReg = 1;\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[2].xy) - wgBx[2].zw;\n    if (max (ust.x, ust.y) < 0.) wgReg = 2;\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {\n      el = clamp (pi * mPtr.y, -0.4 * pi, 0.35 * pi);\n      az = clamp (2. * pi * mPtr.x, - pi, pi);\n    }\n  } else {\n    if (wgSel == 0) {\n      fvVar = clamp (0.5 + 0.5 * (mPtr.y - wgBx[0].y) / wgBx[0].w, 0., 1.);\n    } else if (wgSel == 1) {\n      zmVar = clamp (0.5 + 0.5 * (mPtr.x * asp - wgBx[1].x) / wgBx[1].z, 0., 1.);\n    } else if (wgSel == 2) {\n      pnVar = clamp (0.5 + 0.5 * (mPtr.x * asp - wgBx[2].x) / wgBx[2].z, 0., 1.);\n    }\n  }\n  flSpd = 0.1 * fvVar;\n  if (flSpd < 0.003) flSpd = 0.;\n  flMov += flSpd * (tCur - tCurP);\n  tCurP = tCur;\n  if (pxId == 0) stDat = vec4 (zmVar, pnVar, el, az);\n  else if (pxId == 1) stDat = vec4 (float (wgSel), fvVar, flMov, tCurP);\n  else if (pxId == 2) stDat = mPtr;\n  else if (pxId == 3) stDat = FlyPR (flMov);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}