{
    "Shader": {
        "info": {
            "date": "1650302857",
            "description": "CC0: Ship in an Icy vista\nBeen tinkering with this for a few days. Some aliasing still remains on the icy shore line but perhaps someone has some good ideas on how to reduce it. ",
            "flags": 32,
            "hasliked": 0,
            "id": "NtSyDc",
            "likes": 19,
            "name": "Ship in an Icy vista",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 355
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst vec3 sunPos     = 1E7*vec3(1.0,0.25,-1.0);\nconst vec3 skyDir     = normalize(vec3(-1.0,0.25,1.0));\nconst vec4 moonDim    = vec4(1E5*vec3(-0.2175,0.1525,-1.0), 9000.0);\nconst vec3 sunDir     = normalize(sunPos);\nconst vec3 sunCol0    = HSV2RGB(vec3(0.15, 0.66, 1.0));\nconst vec3 sunCol1    = HSV2RGB(vec3(0.5*0.15, 0.95, 1.0));\nconst vec3 skyCol     = HSV2RGB(vec3(0.6, 0.6, 0.6)); \nconst vec3 morningDir = normalize(vec3(0.65,0.4,-1.0));\nconst float speed     = 0.3;\n\nconst float iceHeightFactor = -0.0125;\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat noise_xx(vec2 p) {\n  vec2 n = fract(floor(p)*0.5)*2.0;\n  p = fract(p);\n  p = mix(p, 1.0 - p, n);\n  return texture(iChannel0, p).x;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec2 hash2(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return fract(sin(p)*43758.5453123);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat parabola(vec2 pos, float k) {\n  pos.x = abs(pos.x);\n  float ik = 1.0/k;\n  float p = ik*(pos.y - 0.5*ik)/3.0;\n  float q = 0.25*ik*ik*pos.x;\n  float h = q*q - p*p*p;\n  float r = sqrt(abs(h));\n  float x = (h>0.0) ? \n      pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n      2.0*cos(atan(r,q)/3.0)*sqrt(p);\n  return length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat vesica(vec2 p, vec2 sz) {\n  // Based of vesica by IQ: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n  if (sz.x < sz.y) {\n    sz = sz.yx;\n  } else {\n    p  = p.yx; \n  }\n  vec2 sz2 = sz*sz;\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\n  float r  = sqrt(sz2.x+d*d);\n  float b  = sz.x;\n  p = abs(p);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\n// License: Unknown, author: Shane, found: https://www.shadertoy.com/view/Mld3Rn\nvec3 voronoi(vec2 p) {\n  vec2 op = p;\n  vec2 g = floor(p), o; p -= g;\n  vec3 d = vec3(1); // 1.4, etc. \"d.z\" holds the distance comparison value.\n    \n  vec2 mp;\n\n  for(int y = -1; y <= 1; y++) {\n    for(int x = -1; x <= 1; x++) {\n      o = vec2(x, y);\n      o += hash2(g + o) - p;\n            \n      d.z = dot(o, o); \n            \n      d.y = max(d.x, min(d.y, d.z));\n      if (d.z < d.x) {\n        d.x = d.z;\n        mp = op+o;\n      }\n      d.x = min(d.x, d.z); \n                       \n    }\n  }\n \n  return vec3(max(d.y/1.2 - d.x*1.-0., 0.), mp);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - sph.w*sph.w;\n  float h = b*b - c;\n  if( h<0.0 ) return vec2(-1.0);\n  h = sqrt( h );\n  return vec2(-b - h, -b + h);\n}\n\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 srd = toSpherical(rd.xzy);\n  vec3 col = vec3(0.0);\n\n  float morningd = clamp(dot(morningDir,rd), 0.0, 1.0 );\n  float sund = clamp(dot(sunDir,rd), 0.0, 1.0 );\n\n  vec2 mi = raySphere(ro, rd, moonDim);\n\n  float sy = max(-(srd.y-PI/2.0), 0.0);\n  sy = exp(-5.*sy);\n  col += hsv2rgb(vec3(0.6, mix(0.8, 0.5, sy), sy));\n\n  const float sh = 0.15;\n  col += 8.0*sunCol0*pow(sund, 1000.0);\n  col += 1.0*sunCol1*pow(sund, 100.0);\n  col += 2.0*HSV2RGB(vec3(sh, 0.66, 1.0))*pow(morningd, 2000000.0);\n\n  vec3 mpos = ro + mi.x*rd; \n  vec3 mnor = normalize(mpos-moonDim.xyz);\n  vec3 mref = reflect(rd, mnor);\n  vec3 mld  = normalize(sunPos - mpos);  \n  float mdif= pow(max(dot(mnor,mld), 0.0), 2.0);\n  float mspe= pow(max(dot(mnor,mld), 0.0), 5.0);\n  vec3 mcol = vec3(0.005);\n  mcol += 0.9*mspe;\n  mcol += 0.5*mdif;\n  col += mcol*tanh_approx(0.0005*max((mi.y - mi.x), 0.0));\n\n  return col;\n}\n\nfloat iceHeight(vec2 p, float aa) {\n  vec2 vp = p;\n  float vz = 1.0;\n\n  float gh = 0.0;\n  float hh = 0.0;\n\n  // Recursive voronois\n  {\n    vec3 c = voronoi(vp);\n    gh = (0.125*max(abs(c.y+8.0*sin(0.025*c.z)+2.0*sin(0.1*c.z))-mix(10.0, 30.0, 0.0*smoothstep(-0.5, 0.5, cos(0.01*c.z))), 0.));\n    hh = smoothstep(-aa, aa, c.x-2.0*aa*smoothstep(1.0, 0.75, gh));\n    if (gh > 0.75) {\n      return iceHeightFactor*tanh_approx(hh+0.5*(gh-0.75));\n    }\n\n    vz *= 0.5;\n    vp = vp * 2.0 + c.yz;\n  }\n\n  {\n    vec3 c = voronoi(vp);\n    hh = hh*smoothstep(-aa, aa, vz*c.x-3.0*aa*smoothstep(1.0, 0.5, gh));\n    if (gh > 0.5) {\n      return 0.75*iceHeightFactor*hh;\n    }\n\n    vz *= 0.5;\n    vp = vp * 2.0 + c.yz;\n  }\n\n  {\n    vec3 c = voronoi(vp);\n    hh = hh*smoothstep(-aa, aa, vz*c.x-2.0*aa*smoothstep(0.9, 0.25, gh));\n    if (gh > 0.25) {\n      return 0.5*iceHeightFactor*hh;\n    }\n  }\n  \n  return 0.0;\n}\n\nvec3 iceNormal(vec2 p, float aa, float eps) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(eps, 0);\n  \n  vec3 n;\n  n.x = iceHeight(p + e.xy, aa) - iceHeight(p - e.xy, aa);\n  n.y = 2.0*e.x;\n  n.z = iceHeight(p + e.yx, aa) - iceHeight(p - e.yx, aa);\n  \n  return normalize(n);\n}\n\nvec4 iceColor(vec3 ro, vec3 rd, vec3 pos, float t, float aa) {\n  vec2 pp = pos.xz;\n  float haa = 0.125*t*aa;\n  float height  = iceHeight(pp, haa);\n  vec3 nor      = iceNormal(pp, haa, 1.0*haa);\n  vec3 ref      = reflect(rd, nor);\n  float fre = 1.0+dot(nor, rd);\n  fre *= fre;\n  fre *= fre;\n  fre *= fre;\n\n  float dif0    = max(dot(nor, sunDir), 0.0);\n  float spe0    = pow(max(dot(ref, sunDir), 0.0), 10.0);\n  float dif1    = max(dot(nor, skyDir), 0.0);\n\n//  dif = sqrt(dif);\n  vec3 col = vec3(0.0);\n  col += 3.0*dif0;\n  col += 4.0*fre*spe0;\n  col += 4.0*dif1*skyCol;\n  return vec4(col, smoothstep(0.3*iceHeightFactor, 0.6*iceHeightFactor, height));\n}\n\nfloat seaHeight(vec2 p) {\n  float lo = noise_xx(0.0025*p);\n  lo *= lo;\n  float hi = noise_xx(0.025*p);\n  hi *= hi;\n  return -0.01*hi*mix(0.5, 1.0, lo);\n}\n\n\nvec3 seaNormal(vec2 p, float eps) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(eps, 0);\n  \n  vec3 n;\n  n.x = seaHeight(p + e.xy) - seaHeight(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = seaHeight(p + e.yx) - seaHeight(p - e.yx);\n  \n  return normalize(n);\n}\n\nvec3 shipColor(vec3 ro, vec3 rd, vec3 pos, vec3 nor, float aa) {\n  const float ys = -6.0+0.3;\n  vec2 pp   = pos.xz;\n\n  vec2 sp = pp;\n  vec2 spo = vec2(0.0, -27.0-speed*TIME);\n  sp -= spo;\n\n  vec3 ppp = vec3(spo.x, ys, spo.y);\n  float ss = length(pos - ppp);\n  vec3 pnor= normalize(ro-ppp);\n  vec4 ppl = vec4(pnor, -dot(ppp, pnor));\n  float pd = rayPlane(ro, rd, ppl);\n  vec3 plp = ro + pd*rd-ppp;\n\n  const vec3 pup = normalize(vec3(0.0, 1.0, 0.0));\n  vec3 pxx = normalize(cross(pnor, pup));\n  vec3 pyy = normalize(cross(pnor, pxx));\n  vec2 pp2 = vec2(dot(pxx, plp), dot(pyy, plp));\n  float ld = length(pp2);\n\n  float pm = -dot(ppp, nor);\n\n  vec2 sbp = sp;\n  sbp -= vec2(0.0, -0.4);\n\n  vec2 spp = sp;\n  spp -= vec2(0.0, 0.3);\n\n  float sd = vesica(sp, vec2(0.1, 1.0)*0.5);\n  float gd = length(sp);\n  float sbd = parabola(sbp, 110.0);\n  float spd = parabola(spp, 110.0);\n  sbd = abs(sbd)-0.0071;\n\n  float wrnd = smoothstep(-2.5, 0.5, sin(10.0*sbp.y)*sin(13.0*sbp.y+5.0*sbp.x));\n  float sbfo = smoothstep(13.0, 0.0, sp.y)*wrnd;\n  float spfo = smoothstep(4.0, 0.0, sp.y)*wrnd;\n\n  vec3 col = vec3(0.0);\n  const vec3 seaCol = HSV2RGB(vec3(0.45, 0.5, 0.1)); \n  vec3 shCol = vec3(mix(0.8,0.3, smoothstep(0.0, 1.0, cos(20.0*sqrt(2.0)*sp.y+1.0)*cos(20.0*sp.y))));\n  col  = mix(col, shCol, smoothstep(aa, -aa, sd));\n  col += smoothstep(aa, -aa, sbd*sbfo)*sbfo;\n  col += 0.5*smoothstep(aa, -aa, spd*spfo)*spfo;\n  float ff = smoothstep(0.5, 1.0, sin(TAU*TIME+1.0)*sin(TAU*sqrt(2.0)*TIME+2.0)*sin(TAU*sqrt(3.0)*TIME+3.0));\n  col += 3.0*seaCol*exp(-mix(0.25, 0.275, ff)*gd);\n  col += 1.0*exp(-mix(10.0, 20.0, ff)*ld);\n\n  return col;  \n}\n\nvec3 render(vec3 ro, vec3 rd, vec3 nrd) {\n  vec3 skyCol = skyColor(ro, rd);\n\n  const float ys = -6.0;\n  float tb = (ys-ro.y)/rd.y;\n  \n  if (tb < 0.0) {\n    return skyCol;\n  }\n\n  vec3 pos  = ro +  tb*rd;\n  vec3 npos = ro +  tb*nrd;\n  float baa = length(pos.xz - npos.xz);\n  \n  vec3 nor = seaNormal(pos.xz, baa);\n  vec3 ref = reflect(rd, nor);\n  vec3 rskyCol = skyColor(ro, ref);\n  vec4 iceCol  = iceColor(ro, rd, pos, tb, baa);\n  float fre = 1.0+dot(nor, rd);\n  fre *= fre;\n  fre *= fre;\n\n  vec3 col = HSV2RGB(vec3(0.45, 0.5, 0.1));\n  col += shipColor(ro, rd, pos, nor, baa);\n  col += fre*rskyCol;\n  col = mix(col, iceCol.xyz, iceCol.w);\n  \n  col = mix(skyCol, col, exp(-0.0125*max(tb-60.0, 0.0)));\n\n  return col;\n}\n\nvec3 color(vec2 p, vec2 q) {\n  float z = -speed*TIME;\n  vec3 ro   = vec3(0.0, 0.0, z);\n  vec3 dro  = normalize(vec3(0.0, -0.1, -1.0));\n\n  vec2 np   = vec2(p+2.0/RESOLUTION.y);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = cross(ww, uu);\n  const float rdd = 2.0;\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd= normalize(np.x*uu + np.y*vv + rdd*ww);;\n    \n  vec3 col = render(ro, rd, nrd);\n\n  return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2.*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;  \n  vec3 col = color(p, q);\n  fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define RESOLUTION iResolution\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n\n#define BLUR\n#if defined(BLUR)\n  const int c = 3;\n\n  vec2 pq = q;\n\n  \n  vec2 aa = 4.0/RESOLUTION.xy;\n  vec2 start = pq-float(c)*aa;\n  vec3 bcol = vec3(0.0); \n  for (int y = -c; y <= c; ++y) {\n    vec2 pp = start;\n    for (int x = -c; x <= c; ++x) {\n      vec4 fcol = texture(iChannel1, pp);\n      fcol *= fcol;\n      bcol += fcol.xyz;\n      pp.x += aa.x;\n    }\n    start.y += aa.y;\n  }\n  \n  bcol /= float((2*c+1)*(2*c+1));\n  float l = max(max(bcol.x, bcol.y), bcol.z);\n  bcol *= smoothstep(0.2, 1.0, l);\n  \n  vec4 pcol = texture(iChannel0, q);\n  vec3 col = pcol.xyz;\n  col = aces_approx(col);\n  col += 0.25*bcol;\n  col = sRGB(col);\n#else\n  vec4 bcol = texture(iChannel1, q);\n  bcol *= bcol;\n  float l = max(max(bcol.x, bcol.y), bcol.z);\n  \n  vec4 pcol = texture(iChannel0,q);\n  vec3 col = pcol.xyz;\n  col = aces_approx(col);\n  col += 0.25*bcol.xyz*smoothstep(0.2, 1.0, l);\n  col = sRGB(col);\n#endif\n\n  fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}