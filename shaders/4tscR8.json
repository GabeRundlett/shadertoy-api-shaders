{
    "Shader": {
        "info": {
            "date": "1503414390",
            "description": "the [optical circuit demo] video source code once appeared on glslsandbox.com\nwww.pouet.net/prod.php?which=65125\nhttps://www.youtube.com/watch?v=ISkIB4w6v6I\nit is fractal code golf overkill in [0..6] scenes.\nthis is a deconstruction of scene 5",
            "flags": 0,
            "hasliked": 0,
            "id": "4tscR8",
            "likes": 87,
            "name": "Optical deconstruction 5b",
            "published": 3,
            "tags": [
                "fractal",
                "optical",
                "glow",
                "kifs",
                "laser",
                "battle",
                "circuit",
                "0x4015",
                "spaseship"
            ],
            "usePreview": 1,
            "username": "ollj",
            "viewed": 8160
        },
        "renderpass": [
            {
                "code": "//scene1: https://www.shadertoy.com/view/MlfczH\n//self 5: https://www.shadertoy.com/view/4tscR8\n//Optical-Circuit optical circuit scene 5 deconstruction b\n\n/*\n\nnot my code, just deconstructing it:\n\nwww.pouet.net/prod.php?which=65125\nhttps://www.youtube.com/watch?v=ISkIB4w6v6I\n\nThe [optical circuit demo] video source code once appeared on glslsandbox.com\n... with very nondesctiptic labels, \n... only using single letter names for functions and vars..\n\nIt is fractal code golf overkill in [0..6] scenes.\nThis is a deconstruction of scene 5. , not the whole demo.\nUn-used functions (only used in other scenes) are removed;\nscene-specific branches are set to 1, or removed \n... (multiplying by *0. or adding -0 iterations)\n... all changes are annotated.\n\nThis may run slightly faster due to removing all schene-specific branching\nMost of that modifies iteration count (between scenes, which are static per shader)\nThe [smart re-use of schene specific branches and modifiers] is what makes this a 4k demo.\n... at a cost of running slightly slower, by summing up scene-modifiers.\n*/\n\n\n//#define scene 5\n#define timeOffset 23.984083\n\n//scene5 skips all the black fractal code.\n//and it replaces it with +50% more iterations over the 2 main loops\n\nconst float pi=acos(-1.);//3.14\nconst float t1=sqrt(.5); //0.707\n\nfloat A,D,E;vec3 B,C;\n\nfloat mav(vec2 a){return max(a.y,a.x);}\nfloat mav(vec3 a){return max(a.z,mav(a.xy));}\nfloat mav(vec4 a){return max(mav(a.zw),mav(a.xy));}\n#define miv(a) -mav(-a)\n#define dd(a) dot(a,a)\nfloat vsum(vec3 a){return dot(a,vec3(1));}//dot() is generally faster on a gpu than 2add()\n //return a.x+a.y+a.z;}\n\n//spaceship distance field is the min() of many sub-distance fields\n//sub of H and I\nvec3 F(vec3 a, float b){float c=sin(b),d=cos(b);return mat3(d,-c,0,c,d,0,0,0,1)*a;}\n//sub of T,used once\nvec3 H(vec3 a){a=F(a,(floor(atan(a.y,a.x)*1.5/pi)*2.+1.)*pi/3.);\n return vec3(a.x,abs(a.y),a.z);}\n//sub of T, used once, modifies a internally though\nvec3 I(vec3 a){a.z-=A*1.5;float b=A*.5 + floor(a.z);\n return F(vec3(a.x,a.y+sin(b),fract(a.z)-.5),pi-cos(b));}\n//\n//sub of S and T\nfloat R(vec3 a){vec3 b=abs(a);return max(b.y,dot(vec3(.87,.5, 0), b))- 1.;}\n//sub of T, used twice\nfloat S(vec3 a){return max(max(abs(length(a-vec3(0,0,5.))-5.)-.05,R(a)),a.z-2.);}\n//sub of T, used twice\nfloat Q(vec3 a){return max(abs(length(a*vec3(1,1,.3))-.325)-.025,-a.z);}\n//sub of T,used twice\nfloat P(vec3 a){vec3 b=abs(a);\n return max(mav(b),max(max(length(b.xy),length(b.yz)),length(b.zx))-.2)-1.;}\n//t is most scene specific\n//for scene5 it is the distance field of chasing spaceships\nfloat T(vec3 a){\n vec3 b=I(a)*20.,c=H(b*2.+vec3(0,0,2))-vec3(1.4,0,0),d=b;\n d.y=abs(d.y);\n return min(min(min(\n           min(max(R(d*4.-vec3(2,5,0))*.25,abs(d.z)-1.),S(d.yzx*vec3(1,.5,.5)*1.5 + vec3(.3,0,0))/1.5),\n           max(min(.1-abs(d.x),-d.z),S(vec3(0, 0, 1) - d.xzy * vec3(1, .5, .5)))),\n          min(\n           min(max(P(c),-P(c * 1.2 + vec3(0,0, 1.5)) / 1.2),Q(c + vec3(0, 0, 1.5))),\n           Q(vec3(abs(c.xy), c.z) - vec3(.5,.5,-1.5)))*.5)*.05,\n  .15-abs(a.x));}\n\n//sub of W and Y\nvec3 V(float a,vec3 b,float c){a*=c;return 1./((1.+2.*b/a+b*b/(a*a))*c+.0001);}\n//used twice in Mainimage\nvec3 W(vec3 a,float b,float c,float d){\n vec3 e=(V(.01,abs(a),d)*2.+V(.05, vec3(length(a.yz),length(a.zx),length(a.xy)),d)*5.)\n       *(sin(A * vec3(2.1,1.3,1.7)+b*10.0)+1.);\n return(e*7.+e.yzx*1.5+e.zxy*1.5)*max(1.-c*200./d,0.)/d*12.;}\n\n//glowing planes:\n//sub of X\nvec3 Z(float t){\n return vec3(0,-sin(t*.6),t*1.6+.5)+sin(t*.01*vec3(11,23,19))*vec3(.135,.25,.25);}\n//sub of Y\nfloat X(vec3 a,float t,float b){\n float c=fract(t+b),e=t-c;\n vec3 f=Z(e)* vec3(0, 1, 1) + sin(vec3(0,23,37)*e),\n g=normalize(sin(vec3(0, 17, 23) * e))*8.,\n h=f+g+vec3(sin(e*53.)*.15,0,9),\n j=f-g+vec3(sin(e*73.)*.15,0,9),\n k=mix(h,j,c-.15),\n l=mix(h,j,c+.15);\n t=dot(a-k,l-k)/dot(l-k,l-k);\n return length((t<.0?k:t>1.?l:k+t*(l-k))-a);}\n//used in main\nvec4 Y(vec3 a,float b,float t){\n vec3 c=I(a)*20.,\n d=vec3(length(c + vec3(-.35,.57,2)),length(c + vec3(-.35, -.57, 2)), length(c + vec3(.7, 0, 2))),\n e=V(.2,d,b),\n f=vec3(X(a, t, 0.0), X(a, t, .3), X(a, t, .6)), g = V(.001, f, b);\n return vec4(\n  vsum(e)*vec3(30, 75, 150) * (E + 1.0) + vsum(g) * vec3(1.0, .1, .2) * 5000.0,\n  min(min(min(d.y, d.z), d.x) * .05, min(min(f.y, f.z), f.x)));}\n\n//used once in MainImage\nvec3 G(vec3 a, float b){a=fract(a*.2)*2.-1.;a.z=b;float c=50.;\n for(int i=0;i<6+1;++i){//scene5 adds +1 iteration here\n  float d = clamp(dd(a),.05,.65);c*=d;a=abs(a)/d-1.31;a.xy*=mat2(1,1,-1,1)*t1;\n }return a*c;}\n//U is very scene specific, used 5* in mainImage\nfloat U(vec3 a){return .15-abs(a.x);}\n\n#define resolution iResolution\nvoid mainImage(out vec4 O, in vec2 Uuu){\n {//this looks like it used to be an initiating function\n  A=iTime + timeOffset;\n  vec2 glVertex=Uuu.xy/resolution.xy*2.-1.;\n  vec3 a=Z(A),//a b c d are very scene specific\n  b=normalize((vec3(0,-sin((A+sin(A*.2)*4.)*.5+A*.1),(A+sin(A*.2)*4.)*1.6+.5)-a)),\n  c=normalize(cross(b,sin(A*.001*vec3(31,17,29))));\n  float d=A*5.;\n  for(int i=0;i< 20;++i){\n   float t=A-float(i)*.1;\n   vec4 y=Y(Z(t),25.,t);\n   d+=1.*sin((y.w+t)* 5.)*y.x*.05*exp(float(i)*-.25);//scene specific\n  }/**/\n  vec3 e=normalize(vec3(sin(vec2(.53,.47)*d)*4.+sin(vec2(.91,1.1)* d)*2.+sin(vec2(2.3,1.7)*d),200)),\n  f=normalize(cross(e, vec3(sin(d), 50, 0)));\n  B=a;\n  C=mat3(c,cross(c,b),b)*(f*glVertex.x*1.78+cross(f,e)*glVertex.y+e*1.4);\n  D=fract(sin(vsum(C)*99.317*pi)*85.081*pi);\n  E=fract(sin(A      *99.317*pi)*85.081*pi);\n }\n vec3 a=normalize(C),c=vec3(1),e=B,f=a,g=e,b=vec3(0),s=vec3(1,-1,-1)*.0005;\n vec4 l=vec4(B,1),k=vec4(0),j=k,h=j;\n int m=1;\n float t=.0,o=1.,p=1.,q=D*.01+.99,n;\n for(int i=0;i<64;++i) {//scene5 adds +32 iterations here. \n  //...i removed that. performance loss not wirth that.\n  g=e+f*t;\n  float d=T(g);\n  if(d<(t*5.+1.)*.0001){\n   vec3 u=normalize(T(g+s)*s+T(g+s.yyx)*s.yyx+T(g+s.yxy)*s.yxy+T(g+s.xxx)*s.xxx);//normal\n   float r=pow(abs(1.-abs(dot(u,f))),5.)*.9+.1;\n   o+=t*p;p*=5./r;\n   e=g+u*.0001;f=reflect(f,u);t=.0;\n   float v=dd(u);\n   if(v<.9||1.1<v||v!= v)u=vec3(0);\n   if(m<4){h=j;j=k;k=l;l=vec4(g,max(floor(o),1.)+clamp(r,.001,.999));++m;\n   }\n  }else t=min(t+d*q,100.);\n }\n if(m<4){h=j;j=k;k=l;l=vec4(g,o+t*p);++m;}\n int nn=m;for(int i=0;i<4;++i)if(nn < 4){h=j;j=k;k=l;++nn;}\n f=normalize(j.xyz-h.xyz);n=length(j.xyz-h.xyz);\n t=.0;o=1.;p=.0;e=h.xyz;\n q=D*.1+.8;//scene specific, no mod for scene5\n for(int i=0;i<64+32;++i){//scene5 adds 32 iterations here\n  if(t>n){\n   if(m<3)break;\n   h=j;j=k;k=l;\n   --m;\n   e=h.xyz;\n   f=normalize(j.xyz - h.xyz);\n   n=length(j.xyz - h.xyz);\n   t=.0;\n   if(n<.0001)break;\n   float r=fract(h.w);\n   o = h.w-r;\n   p=(floor(j.w)-o)/n;\n   c*=mix(vec3(.17,.15,.12),vec3(1),r);}\n  g=e+f*t;\n  vec4 y=Y(g,o+p*t,A);//scene specific\n  float u=U(g);\n  u=min(u, y.w);//scene specific\n  g-=normalize(U(g+s)*s+U(g+s.yyx)*s.yyx+U(g+s.yxy)*s.yxy+U(g+s.xxx)*s.xxx)*u;\n  float v=sin(A*.05+g.z)*.5,w=u*q;//scene specific\n  vec3 x=G(g,v);//scene specific\n  b+=(W(x,v,u,o+p*t)+W(x,v,u,o+p*t+50.)+ y.xyz)*c*w;//scene specific\n  c*=pow(.7,w);t+=w;\n }\n //O is scene specific, nno modifier for scene 5.\n O = vec4(pow(b, vec3(.45)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}