{
    "Shader": {
        "info": {
            "date": "1489076833",
            "description": "It's fast because it doesn't use noise but rather sin waves",
            "flags": 0,
            "hasliked": 0,
            "id": "MdXyzX",
            "likes": 690,
            "name": "Very fast procedural ocean",
            "published": 3,
            "tags": [
                "waves",
                "sea",
                "water",
                "ocean",
                "seascape",
                "scape"
            ],
            "usePreview": 1,
            "username": "afl_ext",
            "viewed": 180401
        },
        "renderpass": [
            {
                "code": "// afl_ext 2017-2024\n// MIT License\n\n// Use your mouse to move the camera around! Press the Left Mouse Button on the image to look around!\n\n#define DRAG_MULT 0.38 // changes how much waves pull on the water\n#define WATER_DEPTH 1.0 // how deep is the water\n#define CAMERA_HEIGHT 1.5 // how high the camera should be\n#define ITERATIONS_RAYMARCH 12 // waves iterations of raymarching\n#define ITERATIONS_NORMAL 37 // waves iterations when calculating normals\n\n#define NormalizedMouse (iMouse.xy / iResolution.xy) // normalize mouse coords\n\n// Calculates wave value and its derivative, \n// for the wave direction, position in space, wave frequency and time\nvec2 wavedx(vec2 position, vec2 direction, float frequency, float timeshift) {\n  float x = dot(direction, position) * frequency + timeshift;\n  float wave = exp(sin(x) - 1.0);\n  float dx = wave * cos(x);\n  return vec2(wave, -dx);\n}\n\n// Calculates waves by summing octaves of various waves with various parameters\nfloat getwaves(vec2 position, int iterations) {\n  float wavePhaseShift = length(position) * 0.1; // this is to avoid every octave having exactly the same phase everywhere\n  float iter = 0.0; // this will help generating well distributed wave directions\n  float frequency = 1.0; // frequency of the wave, this will change every iteration\n  float timeMultiplier = 2.0; // time multiplier for the wave, this will change every iteration\n  float weight = 1.0;// weight in final sum for the wave, this will change every iteration\n  float sumOfValues = 0.0; // will store final sum of values\n  float sumOfWeights = 0.0; // will store final sum of weights\n  for(int i=0; i < iterations; i++) {\n    // generate some wave direction that looks kind of random\n    vec2 p = vec2(sin(iter), cos(iter));\n    \n    // calculate wave data\n    vec2 res = wavedx(position, p, frequency, iTime * timeMultiplier + wavePhaseShift);\n\n    // shift position around according to wave drag and derivative of the wave\n    position += p * res.y * weight * DRAG_MULT;\n\n    // add the results to sums\n    sumOfValues += res.x * weight;\n    sumOfWeights += weight;\n\n    // modify next octave ;\n    weight = mix(weight, 0.0, 0.2);\n    frequency *= 1.18;\n    timeMultiplier *= 1.07;\n\n    // add some kind of random value to make next wave look random too\n    iter += 1232.399963;\n  }\n  // calculate and return\n  return sumOfValues / sumOfWeights;\n}\n\n// Raymarches the ray from top water layer boundary to low water layer boundary\nfloat raymarchwater(vec3 camera, vec3 start, vec3 end, float depth) {\n  vec3 pos = start;\n  vec3 dir = normalize(end - start);\n  for(int i=0; i < 64; i++) {\n    // the height is from 0 to -depth\n    float height = getwaves(pos.xz, ITERATIONS_RAYMARCH) * depth - depth;\n    // if the waves height almost nearly matches the ray height, assume its a hit and return the hit distance\n    if(height + 0.01 > pos.y) {\n      return distance(pos, camera);\n    }\n    // iterate forwards according to the height mismatch\n    pos += dir * (pos.y - height);\n  }\n  // if hit was not registered, just assume hit the top layer, \n  // this makes the raymarching faster and looks better at higher distances\n  return distance(start, camera);\n}\n\n// Calculate normal at point by calculating the height at the pos and 2 additional points very close to pos\nvec3 normal(vec2 pos, float e, float depth) {\n  vec2 ex = vec2(e, 0);\n  float H = getwaves(pos.xy, ITERATIONS_NORMAL) * depth;\n  vec3 a = vec3(pos.x, H, pos.y);\n  return normalize(\n    cross(\n      a - vec3(pos.x - e, getwaves(pos.xy - ex.xy, ITERATIONS_NORMAL) * depth, pos.y), \n      a - vec3(pos.x, getwaves(pos.xy + ex.yx, ITERATIONS_NORMAL) * depth, pos.y + e)\n    )\n  );\n}\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n  return mat3(\n    oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, \n    oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, \n    oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n  );\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord) {\n  vec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n  // for fisheye, uncomment following line and comment the next one\n  //vec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);  \n  vec3 proj = normalize(vec3(uv.x, uv.y, 1.5));\n  if(iResolution.x < 600.0) {\n    return proj;\n  }\n  return createRotationMatrixAxisAngle(vec3(0.0, -1.0, 0.0), 3.0 * ((NormalizedMouse.x + 0.5) * 2.0 - 1.0)) \n    * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), 0.5 + 1.5 * (((NormalizedMouse.y == 0.0 ? 0.27 : NormalizedMouse.y) * 1.0) * 2.0 - 1.0))\n    * proj;\n}\n\n// Ray-Plane intersection checker\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal) { \n  return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \n}\n\n// Some very barebones but fast atmosphere approximation\nvec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir) {\n  sundir.y = max(sundir.y, -0.07);\n  float special_trick = 1.0 / (raydir.y * 1.0 + 0.1);\n  float special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);\n  float raysundt = pow(abs(dot(sundir, raydir)), 2.0);\n  float sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);\n  float mymie = sundt * special_trick * 0.2;\n  vec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);\n  vec3 bluesky= vec3(5.5, 13.0, 22.4) / 22.4 * suncolor;\n  vec3 bluesky2 = max(vec3(0.0), bluesky - vec3(5.5, 13.0, 22.4) * 0.002 * (special_trick + -6.0 * sundir.y * sundir.y));\n  bluesky2 *= special_trick * (0.24 + raysundt * 0.24);\n  return bluesky2 * (1.0 + 1.0 * pow(1.0 - raydir.y, 3.0));\n} \n\n// Calculate where the sun should be, it will be moving around the sky\nvec3 getSunDirection() {\n  return normalize(vec3(sin(iTime * 0.1), 1.0, cos(iTime * 0.1)));\n}\n\n// Get atmosphere color for given direction\nvec3 getAtmosphere(vec3 dir) {\n   return extra_cheap_atmosphere(dir, getSunDirection()) * 0.5;\n}\n\n// Get sun color for given direction\nfloat getSun(vec3 dir) { \n  return pow(max(0.0, dot(dir, getSunDirection())), 720.0) * 210.0;\n}\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color) {  \n  mat3 m1 = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n  );\n  mat3 m2 = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602\n  );\n  vec3 v = m1 * color;  \n  vec3 a = v * (v + 0.0245786) - 0.000090537;\n  vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n  return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));  \n}\n\n// Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // get the ray\n  vec3 ray = getRay(fragCoord);\n  if(ray.y >= 0.0) {\n    // if ray.y is positive, render the sky\n    vec3 C = getAtmosphere(ray) + getSun(ray);\n    fragColor = vec4(aces_tonemap(C * 2.0),1.0);   \n    return;\n  }\n\n  // now ray.y must be negative, water must be hit\n  // define water planes\n  vec3 waterPlaneHigh = vec3(0.0, 0.0, 0.0);\n  vec3 waterPlaneLow = vec3(0.0, -WATER_DEPTH, 0.0);\n\n  // define ray origin, moving around\n  vec3 origin = vec3(iTime * 0.2, CAMERA_HEIGHT, 1);\n\n  // calculate intersections and reconstruct positions\n  float highPlaneHit = intersectPlane(origin, ray, waterPlaneHigh, vec3(0.0, 1.0, 0.0));\n  float lowPlaneHit = intersectPlane(origin, ray, waterPlaneLow, vec3(0.0, 1.0, 0.0));\n  vec3 highHitPos = origin + ray * highPlaneHit;\n  vec3 lowHitPos = origin + ray * lowPlaneHit;\n\n  // raymatch water and reconstruct the hit pos\n  float dist = raymarchwater(origin, highHitPos, lowHitPos, WATER_DEPTH);\n  vec3 waterHitPos = origin + ray * dist;\n\n  // calculate normal at the hit position\n  vec3 N = normal(waterHitPos.xz, 0.01, WATER_DEPTH);\n\n  // smooth the normal with distance to avoid disturbing high frequency noise\n  N = mix(N, vec3(0.0, 1.0, 0.0), 0.8 * min(1.0, sqrt(dist*0.01) * 1.1));\n\n  // calculate fresnel coefficient\n  float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\n\n  // reflect the ray and make sure it bounces up\n  vec3 R = normalize(reflect(ray, N));\n  R.y = abs(R.y);\n  \n  // calculate the reflection and approximate subsurface scattering\n  vec3 reflection = getAtmosphere(R) + getSun(R);\n  vec3 scattering = vec3(0.0293, 0.0698, 0.1717) * 0.1 * (0.2 + (waterHitPos.y + WATER_DEPTH) / WATER_DEPTH);\n\n  // return the combined result\n  vec3 C = fresnel * reflection + scattering;\n  fragColor = vec4(aces_tonemap(C * 2.0), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}