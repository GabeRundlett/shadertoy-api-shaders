{
    "Shader": {
        "info": {
            "date": "1551017954",
            "description": "Ray marching improvised geometry with curvy shapes and rock textures.\nExploring level of details, materials and lights.",
            "flags": 0,
            "hasliked": 0,
            "id": "wdXSWn",
            "likes": 122,
            "name": "Crypt Roots",
            "published": 3,
            "tags": [
                "tunnel"
            ],
            "usePreview": 0,
            "username": "leon",
            "viewed": 5515
        },
        "renderpass": [
            {
                "code": "// Crypt Roots\n// Ray marching improvised geometry with curvy shapes and rock textures\n// Exploring level of details, materials and lights\n// Licensed under hippie love conspiracy\n// Leon Denise (ponk) 2019.02.24\n\n// Using code from\n\n// Inigo Quilez\n// https://www.shadertoy.com/view/Xds3zN\n\n// Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\n\n#define repeat(p,r) (mod(p,r)-r/2.)\nconst float PI = 3.14159;\nmat2 rot (float a) { float c=cos(a), s=sin(a); return mat2(c,s,-s,c); }\nfloat smoothmin (float a, float b, float r) { float h = clamp(.5+.5*(b-a)/r, 0., 1.); return mix(b, a, h)-r*h*(1.-h); }\nfloat random (in vec2 st) { return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123); }\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    float n = dot(i, step);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\nfloat fbm (vec3 p) {\n  float amplitude = 0.5;\n  float result = 0.0;\n  for (float index = 0.0; index <= 3.0; ++index) {\n    result += noise(p / amplitude) * amplitude;\n    amplitude /= 2.;\n  }\n  return result;\n}\nvec3 look (vec3 eye, vec3 target, vec2 anchor) {\n    vec3 forward = normalize(target-eye);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = normalize(cross(right, forward));\n    return normalize(forward + right * anchor.x + up * anchor.y);\n}\nvoid moda(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*length(p);\n}\n\nfloat map (vec3 pos) {\n  float chilly = noise(pos * 2.);\n  float salty = fbm(pos*20.);\n  \n  pos.z -= salty*.04;\n  salty = smoothstep(.3, 1., salty);\n  pos.z += salty*.04;\n  pos.xy -= (chilly*2.-1.) * .2;\n    \n  vec3 p = pos;\n  vec2 cell = vec2(1., .5);\n  vec2 id = floor(p.xz/cell);\n  p.xy *= rot(id.y * .5);\n  p.y += sin(p.x + .5);\n  p.xz = repeat(p.xz, cell);\n    \n  vec3 pp = p;\n  moda(p.yz, 5.0);\n  p.y -= .1;\n  float scene = length(p.yz)-.02;\n    \n  vec3 ppp = pos;\n  pp.xz *= rot(pp.y * 5.);\n  ppp = repeat(ppp, .1);\n  moda(pp.xz, 3.0);\n  pp.x -= .04 + .02*sin(pp.y*5.);\n  scene = smoothmin(length(pp.xz)-.01, scene, .2);\n\n  p = pos;\n  p.xy *= rot(-p.z);\n  moda(p.xy, 8.0);\n  p.x -= .7;\n  p.xy *= rot(p.z*8.);\n  p.xy = abs(p.xy)-.02;\n  scene = smoothmin(scene, length(p.xy)-.005, .2);\n\n  return scene;\n}\n\nvec3 getNormal (vec3 pos) {\n  vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n  return normalize( e.xyy*map( pos + e.xyy ) + e.yyx*map( pos + e.yyx ) + e.yxy*map( pos + e.yxy ) + e.xxx*map( pos + e.xxx ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n  vec3 eye = vec3(.1,.1,-iTime*.1-4.);\n  vec3 at = vec3(0,0,eye.z-2.0);\n  vec3 ray = look(eye, at, uv);\n  vec3 pos = eye;\n  float dither = random(uv+fract(iTime));\n  float total = dither * .2;\n  float shade = 0.0;\n  const float count = 60.0;\n  for (float index = count; index > 0.0; --index) {\n    pos = eye + ray * total;\n    float dist = map(pos);\n    if (dist < 0.001 + total * .003) {\n      shade = index / count;\n      break;\n    }\n    dist *= 0.5 + 0.1 * dither;\n    total += dist;\n  }\n  vec3 normal = getNormal(pos);\n  vec3 color = vec3(0);\n  color += smoothstep(.3, .6, fbm(pos*100.)) * .2;\n  color += vec3(0.839, 1, 1) * pow(clamp(dot(normal, normalize(vec3(0,2,1))), 0.0, 1.0), 4.);\n  color += vec3(1, 0.725, 0.580) * pow(clamp(dot(normal, -normalize(pos-at)), 0.0, 1.0), 4.);\n  color += vec3(0.972, 1, 0.839) * pow(clamp(dot(normal, normalize(vec3(4,0,1))), 0.0, 1.0), 4.);\n  color += vec3(0.972, 1, 0.839) * pow(clamp(dot(normal, normalize(vec3(-5,0,1)))*.5+.5, 0.0, 1.0), 4.);\n  color = mix(vec3(0), color, clamp(dot(normal, -ray), 0.0, 1.0));\n  color *= pow(shade, 1.0/1.2);\n  fragColor = vec4(color, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}