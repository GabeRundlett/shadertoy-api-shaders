{
    "Shader": {
        "info": {
            "date": "1594562888",
            "description": "filled version of \"Moebius Lizard\", Escher-like tiling on Moebius spiral, by iapafoto. [url]https://shadertoy.com/view/wtjyz1[/url]\nMouse control.",
            "flags": 0,
            "hasliked": 0,
            "id": "Wt2cWm",
            "likes": 15,
            "name": "Moebius Lizard - filled",
            "published": 3,
            "tags": [
                "2d",
                "mobius",
                "escher",
                "lizard",
                "moebus"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 467
        },
        "renderpass": [
            {
                "code": "// === variant of \"Moebius Lizard\" by iapafoto. https://shadertoy.com/view/wtjyz1\n// see study here :  https://shadertoy.com/view/WtBcRD\n// Here: filled shapes\n\n// --- L() get the distance d of p=U-a to segment(a-a,b-a) \n// AND get whether pixel in/out shape by counting the number of intersection with [U,U+(0,inf)]\n//     for close contours, n is odd inside and even outside.\n// l get the label of the closest line\nvec2 q; float s,c,v,d=1e3; int k,n=0;\n#define L(p,l) v = length( q = p-b*( c = clamp( s = dot(p,b)/dot(b,b),0.,1.))); \\\n               if (v<d) d=v, k=l;                                               \\\n               c = clamp ( s = (p).y/b.y, 0.,1.);                               \\\n               if ( c == s && s * b.x > (p).x ) n++\n            \n// --- T encodes shape, turned 4x by Pi/2, + copied trough tiles.\n// note that a Lizard is contoured by 3 of these.        Vsame Yv                         Vsame xV\nint[] T = int[](6,0,9,2,12,5,6,10,0,20,  6,26,  12,20,11,17,14,17,17,18,15,22,11,26,16,26,22,18,22,27,25,28,28,30,30,26\n          // left hand  - left of head (10)head right of head                   -                right foot\n    ,     // completed contour. Used only with FILL=2\n    26,24,28,21,29,18,38,18,30,12,30,7,34,11,38,13,39,10,39,7,36,8,  30,2,    24,8,14,2,9,-4,6,-1,4,2, 6,0 );\n          //       ^same y^                        ^same x^           <- possible issues\n\nvoid drawTile(vec2 m, int i, int r) {\n    vec2 a = vec2(T[i  ],T[i+1]),\n         b = vec2(T[i+2],T[i+3]) - a;\n    L(m-a, 4*r);\n}\n    \nvoid mainImage(out vec4 O, vec2 u ) {\n    \n    vec2 R = iResolution.xy, D = vec2(6,2),\n         m = 2.*iMouse.xy/R,\n         U = (u - .5*R) / R.y ,z = U + vec2(1,0), \n         g = vec2(30,26), I;   \n    float w = 3.*48./R.y;\n#if 0                                    // tile plane\n    U *= 1.3; I = floor(U+.5); U *= 48.;\n#else \t                                 // tile Moebius spiral\n    U *= mat2(z,-z.y,z) / dot(U,U);\n    U += .5;\n    float a = atan(U.y, U.x)/6.283;\n\tU =  m + log(length(U)) *vec2(.5,-1) + iTime/20.\n           + a*D;\n // w = 48.* determinant(mat2(dFdx(U),dFdy(U)));  // Jacobian to eval distortions, see https://www.shadertoy.com/view/WlByRW\n    vec2 dFx = dFdx(U), dFy = dFdy(U); // eliminate atan discont, see  https://www.shadertoy.com/view/WlScRW\n    float dax = dFdx(a), day = dFdy(a),\n           dx = abs(dax) > .5 ? sign(dax) : 0.,      // detect the jump\n           dy = abs(day) > .5 ? sign(day) : 0.;      // ( jump is +- 1 since atan/2PI, 0.5 threshold is large )\n    dFx -= D*dx, dFy -= D*dy,                        // eliminates in derivatives\n    w = determinant(mat2(dFx,dFy));                  // corrected Jacobian det\n    w = 48.* 2.*sqrt(abs(w));            // pixel width, for antialiasing\n    U = 48.*fract( U ) - g;              // tiles\n#endif\n    \n    int nn=-1; float  e = 1e3;\n    for (int r=0; r < 4; r++)\n    {   \n        m = mod(U+g+8.,48.)-8.;\n        U = vec2(-U.y,U.x); \n        for (int i=0; i <  T.length()-2 ; i+=2) {\n            drawTile(m,i,r);\n        }\n      e = min(e, min(length(m-vec2(7.8,20)),length(m-vec2(4.5,20)))-.8);  // eyes\n\n        if (n%2>0) nn=r, n=0; // for checkered filling color\n    }\n    if(nn>=0) n=nn; \n    // --- returned values: d = distance to contour, n = fill parity, I = tileId\n\n    e = smoothstep(w,0.,abs(e));\n    d = smoothstep(w,0.,abs(d));\n  //O = .5 + vec4( n%2 > 0 ? 1. -d - e : e );   // just surfaces\n    O = .5 + vec4( n%2 > 0 ? 1. - e : e ) - d;  // + border\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}