{
    "Shader": {
        "info": {
            "date": "1685776746",
            "description": "A dual kawase blur implementation using 3 buffer passes.\nInteractable with iMouse.y.\nBufferA comes from gelami's [url=https://www.shadertoy.com/view/cty3R3]2-Pass Buffer Bloom[/url].",
            "flags": 32,
            "hasliked": 0,
            "id": "ct3Szl",
            "likes": 11,
            "name": "[zznewclear13] Dual Kawase Blur",
            "published": 3,
            "tags": [
                "2d",
                "blur",
                "postprocess",
                "kawase",
                "dualkawaseblur"
            ],
            "usePreview": 0,
            "username": "zznewclear13",
            "viewed": 916
        },
        "renderpass": [
            {
                "code": "// [zznewclear13] Dual Kawase Blur\n// A dual kawase blur implementation using 2 buffer passes.\n// Interactable with iMouse.y.\n// BufferA comes from gelami's [url=https://www.shadertoy.com/view/cty3R3]2-Pass Buffer Bloom[/url].\n// \n// Possible References:\n// gelami: [2-Pass Buffer Bloom](https://www.shadertoy.com/view/cty3R3)\n// alex47: [Dual Kawase Blur](https://www.shadertoy.com/view/3td3W8)\n// Marius BjÃ¸rge: [Bandwith-Efficient Rendering](https://community.arm.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-20-66/siggraph2015_2D00_mmg_2D00_marius_2D00_slides.pdf)\n// \n// What's different from gelami's 2-Pass Buffer Bloom?\n// 1. This shader is blur effect, gelami's is bloom effect.\n// 2. This shader uses dual kawase filter, gelami's uses gaussian filter. \n// 3. This shader calculates (dual kawase) mipmaps in BufferB, gelami's uses built-in mipmaps.\n// \n// What's different from alex47's Dual Kawase Blur or Kawase Blur animated (https://www.shadertoy.com/view/Wlc3D4)?\n// 1. This shader downsamples and upsamples based on blur amount, alex47's downsamples and upsamples based on number of buffers.\n// 2. This shader linear interpolates between different blur result to create a smooth transition, alex47's increases sample offset (which may affect blur quality).\n\n// Dual kawase blur final upsample.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 iFragCoord = floor(fragCoord);\n    vec2 pixelSize = 1.0f / iResolution.xy;\n    \n    GET_SCREEN_MAX_LOD\n    GET_MAX_DOWNSAMPLE_COUNT_WITH_MOUSE_Y\n    \n    vec2 samplePos = (iFragCoord + 0.5f) * 0.5f;\n    vec3 color, tl, tr, bl, br, t2, b2, l2, r2; \n    if(maxDownsampleCount == 0.0f)\n    {\n        // Upsample first mip in bufferB, and mix with buffferA.\n        tl = texture(iChannel1, (samplePos + vec2(-1.0f, +1.0f) * 0.5f) * pixelSize).rgb;\n        tr = texture(iChannel1, (samplePos + vec2(+1.0f, +1.0f) * 0.5f) * pixelSize).rgb;\n        bl = texture(iChannel1, (samplePos + vec2(-1.0f, -1.0f) * 0.5f) * pixelSize).rgb;\n        br = texture(iChannel1, (samplePos + vec2(+1.0f, -1.0f) * 0.5f) * pixelSize).rgb;\n        t2 = texture(iChannel1, (samplePos + vec2(+0.0f, +2.0f) * 0.5f) * pixelSize).rgb;\n        b2 = texture(iChannel1, (samplePos + vec2(+0.0f, -2.0f) * 0.5f) * pixelSize).rgb;\n        l2 = texture(iChannel1, (samplePos + vec2(-2.0f, +0.0f) * 0.5f) * pixelSize).rgb;\n        r2 = texture(iChannel1, (samplePos + vec2(+2.0f, +0.0f) * 0.5f) * pixelSize).rgb;\n        \n        color = (t2 + b2 + l2 + r2 + 2.0f * (tl + tr + bl + br)) / 12.0f;\n        vec3 bufferA = texture(iChannel0, (iFragCoord + 0.5f) * pixelSize).rgb;\n        color = mix(bufferA, color, fracVal);\n    }\n    else\n    {\n        // Upsample bufferC.\n        tl = texture(iChannel2, (samplePos + vec2(-1.0f, +1.0f) * 0.5f) * pixelSize).rgb;\n        tr = texture(iChannel2, (samplePos + vec2(+1.0f, +1.0f) * 0.5f) * pixelSize).rgb;\n        bl = texture(iChannel2, (samplePos + vec2(-1.0f, -1.0f) * 0.5f) * pixelSize).rgb;\n        br = texture(iChannel2, (samplePos + vec2(+1.0f, -1.0f) * 0.5f) * pixelSize).rgb;\n        t2 = texture(iChannel2, (samplePos + vec2(+0.0f, +2.0f) * 0.5f) * pixelSize).rgb;\n        b2 = texture(iChannel2, (samplePos + vec2(+0.0f, -2.0f) * 0.5f) * pixelSize).rgb;\n        l2 = texture(iChannel2, (samplePos + vec2(-2.0f, +0.0f) * 0.5f) * pixelSize).rgb;\n        r2 = texture(iChannel2, (samplePos + vec2(+2.0f, +0.0f) * 0.5f) * pixelSize).rgb;\n        \n        color = (t2 + b2 + l2 + r2 + 2.0f * (tl + tr + bl + br)) / 12.0f;\n    }\n    \n    // color = texture(iChannel2, fragCoord / iResolution.xy).rgb;\n\n    color = ACESFilm(color * 0.55);\n    color = linearTosRGB(color);\n    fragColor = vec4(color, 1.0f);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2023-05-17 14:41:51\n\n#define EXPOSURE 5.0\n#define ROTATION\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\n// https://www.shadertoy.com/view/3tSGDy\nfloat sdStar(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\n// https://www.shadertoy.com/view/3tyBzV\nfloat dot2(vec2 p) { return dot(p, p); }\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat smootherstep(float f)\n{\n    return f*f*f*(f*(f*6.0-15.0)+10.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pv = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = vec3(0);\n\n    col = vec3(1, 0.5, 1);\n    \n    float t = iTime * 0.8;\n    \n    #ifdef ROTATION\n    #if 0\n    pv *= rot2D(t * 0.8);\n    #else\n    pv *= rot2D(smootherstep(fract(t * 0.5 / PI)) * TAU);\n    #endif\n    #endif\n    \n    vec2 p1 = pv - vec2(0.8, 0);\n    vec2 p2 = (pv + vec2(0.8, 0.2)) * 2.6;\n    \n    #ifdef ROTATION\n    p1 *= rot2D(t * 1.0);\n    \n    p2.y -= 0.55;\n    p2 *= rot2D(t * 1.0);\n    p2.y += 0.55;\n    #endif\n    \n    float d = length(pv) - 0.2;\n    float r = 0.02;\n    float st = sdStar(p1, 0.25 - r, 5, 3.0) - r;\n    float sh = sdHeart(p2) / 2.6 - 0.02;\n    \n    if (st < d)\n    {\n        d = st;\n        col = vec3(1, 0.5, 0.2);\n    }\n    if (sh < d)\n    {\n        d = sh;\n        col = vec3(0.2, 0.5, 1);\n    }\n    \n    /*\n    float sb = abs(sdBox(pv, vec2(1.6, 0.8))) - 0.01;\n    if (sb < d)\n    {\n        d = sb;\n        col = vec3(1, 0.8, 0.6);\n    }*/\n    \n    col *= smoothstep(2.0 / iResolution.y, 0.0, d);\n    \n    col *= EXPOSURE;\n    col = max(col, vec3(0));\n\n    // col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col, 1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Dual kawase blur downsample and upsample.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 iFragCoord = floor(fragCoord);\n    vec2 pixelSize = 1.0f / iResolution.xy;\n    \n    GET_SCREEN_MAX_LOD\n    GET_MAX_DOWNSAMPLE_COUNT_WITH_MOUSE_Y\n    \n    vec3 color, c, tl, tr, bl, br;\n    if(iFragCoord.y < iResolution.y * 0.5f)\n    {\n        vec2 iStart, iRes;\n        float lod = getLOD(iFragCoord, iResolution.xy, maxLOD, iStart, iRes);\n        if(lod == 1.0f)\n        {\n            // Downsample BufferA\n            vec2 samplePos = (iFragCoord - iStart + 0.5f) * 2.0f;\n            if(!any(greaterThanEqual(samplePos, iResolution.xy)))\n            {\n                c = texture(iChannel0, samplePos * pixelSize).rgb;\n                tl = texture(iChannel0, (samplePos + vec2(-1.0f, +1.0f)) * pixelSize).rgb;\n                tr = texture(iChannel0, (samplePos + vec2(+1.0f, +1.0f)) * pixelSize).rgb;\n                bl = texture(iChannel0, (samplePos + vec2(-1.0f, -1.0f)) * pixelSize).rgb;\n                br = texture(iChannel0, (samplePos + vec2(+1.0f, -1.0f)) * pixelSize).rgb;\n            }   \n        }\n        else\n        {\n            // Downsample BufferB\n            vec2 iLastStart, iLastRes;\n            getLODParam(lod - 1.0f, iResolution.xy, iLastStart, iLastRes);\n\n            vec2 samplePos = (iFragCoord - iStart + 0.5f) * 2.0f;\n            if(!any(greaterThanEqual(samplePos, iLastRes)))\n            {             \n                c = sampleWithClamp(iChannel1, samplePos, iLastStart, iLastRes, pixelSize);\n                tl = sampleWithClamp(iChannel1, (samplePos + vec2(-1.0f, +1.0f)), iLastStart, iLastRes, pixelSize);\n                tr = sampleWithClamp(iChannel1, (samplePos + vec2(+1.0f, +1.0f)), iLastStart, iLastRes, pixelSize);\n                bl = sampleWithClamp(iChannel1, (samplePos + vec2(-1.0f, -1.0f)), iLastStart, iLastRes, pixelSize);\n                br = sampleWithClamp(iChannel1, (samplePos + vec2(+1.0f, -1.0f)), iLastStart, iLastRes, pixelSize);\n            }\n        }\n        color = (tl + tr + bl + br + 4.0f * c) / 8.0f;\n    }\n    else\n    {\n        iFragCoord = iResolution.xy - 1.0f - iFragCoord;\n        \n        vec2 iStart, iRes;\n        float lod = getLOD(iFragCoord, iResolution.xy, maxLOD, iStart, iRes); \n        vec2 iLastStart, iLastRes;\n        getLODParam(lod + 1.0f, iResolution.xy, iLastStart, iLastRes);\n        vec2 samplePos = (iFragCoord - iStart + 0.5f) * 0.5f;\n        \n        vec3 t2, b2, l2, r2;\n        if(!any(greaterThanEqual(samplePos, iLastRes)))\n        {\n            // Upsample downsamples : Upsample upsamples.   \n            bool upsideDown = (lod < (maxDownsampleCount+1.0f));\n\n            tl = sampleWithClamp(iChannel1, (samplePos + vec2(-1.0f, +1.0f) * 0.5f), iLastStart, iLastRes, pixelSize, iResolution.xy, upsideDown);\n            tr = sampleWithClamp(iChannel1, (samplePos + vec2(+1.0f, +1.0f) * 0.5f), iLastStart, iLastRes, pixelSize, iResolution.xy, upsideDown);\n            bl = sampleWithClamp(iChannel1, (samplePos + vec2(-1.0f, -1.0f) * 0.5f), iLastStart, iLastRes, pixelSize, iResolution.xy, upsideDown);\n            br = sampleWithClamp(iChannel1, (samplePos + vec2(+1.0f, -1.0f) * 0.5f), iLastStart, iLastRes, pixelSize, iResolution.xy, upsideDown);\n            t2 = sampleWithClamp(iChannel1, (samplePos + vec2(+0.0f, +2.0f) * 0.5f), iLastStart, iLastRes, pixelSize, iResolution.xy, upsideDown);\n            b2 = sampleWithClamp(iChannel1, (samplePos + vec2(+0.0f, -2.0f) * 0.5f), iLastStart, iLastRes, pixelSize, iResolution.xy, upsideDown);\n            l2 = sampleWithClamp(iChannel1, (samplePos + vec2(-2.0f, +0.0f) * 0.5f), iLastStart, iLastRes, pixelSize, iResolution.xy, upsideDown);\n            r2 = sampleWithClamp(iChannel1, (samplePos + vec2(+2.0f, +0.0f) * 0.5f), iLastStart, iLastRes, pixelSize, iResolution.xy, upsideDown);\n        }   \n        color = (t2 + b2 + l2 + r2 + 2.0f * (tl + tr + bl + br)) / 12.0f;\n        // color = lod >= (maxLOD+1.0f) ? vec3(1.0f) : vec3(0.0f);\n        // vec3 self = texture(iChannel1, (iFragCoord + 0.5f) * pixelSize).rgb;\n        // color = mix(color, self, 0.5f);\n    }\n    \n    fragColor = vec4(color, 1.0f);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define LOG_E_2 0.693147181f\n\n// What a mess here!\n// Idealy I would let maxLOD begin from 1.0f, however...\n\n#define GET_SCREEN_MAX_LOD \\\n        float logVal = floor(log(iResolution.x) / LOG_E_2);\\\n        float maxLOD = 0.0f;\\\n        float xStart = 0.0f;\\\n        float halfX = floor((iResolution.x + 1.0f) / 2.0f);\\\n        for (;maxLOD<=logVal;++maxLOD)\\\n        {\\\n            xStart += halfX;\\\n            if(iResolution.x <= xStart) break;\\\n            halfX = floor((halfX + 1.0f) / 2.0f);\\\n        }\\\n\n#define GET_MAX_DOWNSAMPLE_COUNT_WITH_MOUSE_Y \\\n        float mouseY = sin(iTime) * 0.5f + 0.5f;\\\n        if(iMouse.z > 0.0f) mouseY = iMouse.y / iResolution.y;\\\n        float fracVal;\\\n        float maxDownsampleCount = getMaxDownsampleCount(mouseY, maxLOD, fracVal);\\\n\nfloat getMaxDownsampleCount(float mouseY, float maxLOD, out float fracVal)\n{\n    float logVal = log(mouseY * (pow(2.0f, maxLOD-1.0f) - 1.0f) + 1.0f) / LOG_E_2;\n    float floorVal = floor(logVal);\n    fracVal = (floorVal >= maxLOD) ? 0.99f : fract(logVal);\n    return clamp(floorVal, 0.0f, maxLOD-1.0f);\n}\n\nfloat getLOD(vec2 iFragCoord, vec2 fullRes, float maxLOD, out vec2 iStart, out vec2 iRes)\n{\n    iRes = floor((fullRes+1.0f) / 2.0f);\n    iStart = vec2(0.0f, 0.0f);\n  \n    float i = 0.0f;\n    for (; i<maxLOD; ++i)\n    {\n        float iEnd = iStart.x + iRes.x;\n        if(iFragCoord.x < iEnd) break;\n        iStart.x = iEnd;\n        iRes = floor((iRes+1.0f) / 2.0f);\n    }\n    return i+1.0f;\n}\n\nvoid getLODParam(float lod, vec2 fullRes, out vec2 iStart, out vec2 iRes)\n{\n    iRes = floor((fullRes+1.0f) / 2.0f);\n    iStart = vec2(0.0f, 0.0f);\n    for(float i=1.0f; i<lod; ++i)\n    {\n        iStart.x = iStart.x + iRes.x;\n        iRes = floor((iRes+1.0f) / 2.0f);\n    }\n}\n\nvec3 sampleWithClamp(sampler2D tex, vec2 samplePos, vec2 iStart, vec2 iRes, vec2 pixelSize)\n{\n    samplePos = clamp(samplePos, vec2(0.5f), iRes - 0.5f);\n    return texture(tex, (samplePos + iStart) * pixelSize).rgb;\n}\n\nvec3 sampleWithClamp(sampler2D tex, vec2 samplePos, vec2 iStart, vec2 iRes, vec2 pixelSize, vec2 fullRes, bool upsideDown)\n{\n    samplePos = clamp(samplePos, vec2(0.5f), iRes - 0.5f);\n    samplePos = upsideDown ? fullRes - samplePos : samplePos;\n    return texture(tex, (samplePos + iStart) * pixelSize).rgb;\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Dual kawase blur upsample.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 iFragCoord = floor(fragCoord);\n    vec2 pixelSize = 1.0f / iResolution.xy;\n    \n    GET_SCREEN_MAX_LOD\n    GET_MAX_DOWNSAMPLE_COUNT_WITH_MOUSE_Y\n\n    vec2 iStart, iRes;\n    float lod = getLOD(iFragCoord, iResolution.xy, maxLOD, iStart, iRes); \n    \n    vec3 color;      \n    if(lod >= (maxDownsampleCount+1.0f))\n    {\n        // Mix bufferB.\n        vec2 realSamplePos = iResolution.xy - iFragCoord - 0.5f;\n        if(!any(greaterThanEqual(iFragCoord - iStart, iRes)))\n        {\n            vec3 orig = texture(iChannel0, (iFragCoord + 0.5f) * pixelSize).rgb;\n            vec3 blurred = texture(iChannel0, realSamplePos * pixelSize).rgb;\n            \n            if(lod > (maxDownsampleCount+1.0f)) fracVal = 0.0f;\n            color = mix(orig, blurred, fracVal);\n        }         \n    }\n    else\n    {\n        vec2 iLastStart, iLastRes;\n        getLODParam(lod + 1.0f, iResolution.xy, iLastStart, iLastRes);\n        vec2 samplePos = (iFragCoord - iStart + 0.5f) * 0.5f;\n        vec2 realSamplePos = samplePos + iLastStart;\n        if(!any(greaterThanEqual(samplePos, iLastRes)))\n        {\n            // Upsample BufferC.\n            vec3 tl, tr, bl, br, t2, b2, l2, r2;\n\n            tl = sampleWithClamp(iChannel1, (samplePos + vec2(-1.0f, +1.0f) * 0.5f), iLastStart, iLastRes, pixelSize).rgb;\n            tr = sampleWithClamp(iChannel1, (samplePos + vec2(+1.0f, +1.0f) * 0.5f), iLastStart, iLastRes, pixelSize).rgb;\n            bl = sampleWithClamp(iChannel1, (samplePos + vec2(-1.0f, -1.0f) * 0.5f), iLastStart, iLastRes, pixelSize).rgb;\n            br = sampleWithClamp(iChannel1, (samplePos + vec2(+1.0f, -1.0f) * 0.5f), iLastStart, iLastRes, pixelSize).rgb;\n            t2 = sampleWithClamp(iChannel1, (samplePos + vec2(+0.0f, +2.0f) * 0.5f), iLastStart, iLastRes, pixelSize).rgb;\n            b2 = sampleWithClamp(iChannel1, (samplePos + vec2(+0.0f, -2.0f) * 0.5f), iLastStart, iLastRes, pixelSize).rgb;\n            l2 = sampleWithClamp(iChannel1, (samplePos + vec2(-2.0f, +0.0f) * 0.5f), iLastStart, iLastRes, pixelSize).rgb;\n            r2 = sampleWithClamp(iChannel1, (samplePos + vec2(+2.0f, +0.0f) * 0.5f), iLastStart, iLastRes, pixelSize).rgb;\n\n            color = (t2 + b2 + l2 + r2 + 2.0f * (tl + tr + bl + br)) / 12.0f; \n        }\n    }\n\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}