{
    "Shader": {
        "info": {
            "date": "1713543681",
            "description": "A simple shader for viewing the burning ship fractal with antialiasing and shading. Use WASD to move around and arrow keys to zoom.",
            "flags": 48,
            "hasliked": 0,
            "id": "McKGzG",
            "likes": 5,
            "name": "Burning Ship Fractal Viewer",
            "published": 3,
            "tags": [
                "fractal",
                "interactive"
            ],
            "usePreview": 0,
            "username": "Bingle",
            "viewed": 303
        },
        "renderpass": [
            {
                "code": "//#define GRID\n#define SHADE\n\n// Max fractal iterations\n#define MAXITERS 120\n// Anti-aliasing (will compute (AA*2+1)^2 samples, so 1 for 0, 9 for 1, 25 for 2...)\n#define AA 1\n\n// AA breaks down near precision-limit levels of zoom\n// Also, if the AA looks like barf, you're probably looking at a very noisy boundary.\n\nvec4 f(vec4 p){\n    return vec4(p.x*p.x-p.y*p.y+p.z,abs(2.0*p.x*p.y)+p.w,p.zw);\n    // Remove the \"abs\" (keep the parentheses) for a mandelbrot fractal!\n}\n\nvec2 UV(vec2 px,vec3 iResolution,vec4 cam){\n    return (px-0.5*iResolution.xy)/iResolution.y*cam.z-cam.xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragCoord.y = iResolution.y-fragCoord.y; // Mirror vertically except im lazy (and who's gonna stop me)\n    \n    vec4 cam = texelFetch(iChannel0,TEXEL_CAM,0);\n    \n    float pxSize = 1.0/iResolution.y*cam.z;\n    float gridSize = pow(2.0,round(log2(0.25*cam.z)));\n    \n    vec2 uv = UV(fragCoord,iResolution,cam);\n    \n    float val = 0.0;\n    float iters = 0.0;\n    for (int x=0-AA;x<1+AA;x++){\n        for (int y=0-AA;y<1+AA;y++){\n            vec4 p = (uv+(0.5/float(AA))*pxSize*vec2(x,y)).xyxy; // I chose 0.333 arbitrarily, as I needed a value large enough to produce nice antialiasing but small enough to not just blur everything.\n            for (int i=0;i<MAXITERS;i++){\n                p = f(p);\n                if (isinf(p.x) || isinf(p.y)){\n                    iters+=float(i);\n                    break;\n                }\n            }\n            if (length(p.xy)<4.0){\n                val+=1.0;\n            }\n        }\n    }\n    \n    float pxCount = float((2*AA+1)*(2*AA+1));\n    \n    val /= pxCount; // Because we do 9 antialiasing samples\n    iters /= pxCount;\n    \n    vec3 col = vec3(val);\n    #ifdef SHADE\n    col = mix(2.0*vec3(0,0,iters/float(MAXITERS)),col,val);\n    #endif\n    \n    #ifdef GRID\n    vec2 offset = UV(fragCoord-vec2(1.0),iResolution,cam);\n    if (offset.x!=uv.x && offset.y!=uv.y){ // Check if we're hitting precision limits\n        float halfCell = 0.5*gridSize;\n        if (mod(uv.x-halfCell,gridSize)>=halfCell && mod(offset.x-halfCell,gridSize)<halfCell){\n            col+=vec3(0.0,0.5,0.0);\n        }\n        if (mod(uv.y-halfCell,gridSize)>=halfCell && mod(offset.y-halfCell,gridSize)<halfCell){\n            col+=vec3(0.0,0.5,0.0);\n        }\n    }\n    #endif\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define  KEY_LEFT 37\n#define    KEY_UP 38\n#define KEY_RIGHT 39\n#define  KEY_DOWN 40\n\n#define     KEY_A 65\n#define     KEY_D 68\n#define     KEY_S 83\n#define     KEY_W 87\n\n// Zooming is framerate dependant. I can't figure out how to uncouple zooming from the framerate effectively.\n// One would think simply multiplying ZOOMFAC by the timestep would work, but what if the timestep is greater than 1? I know such a situation is absurd, but it proves that this method is flawed. I'm not sure how to fix this.\n#define ZOOMFAC 0.02\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    ivec2 iCoord = ivec2(fragCoord);\n    vec4 data = texelFetch(iChannel0,iCoord,0);\n    \n    if (iCoord == TEXEL_CAM){\n        \n        // (X position, Y position, Zoom, Unused)\n        \n        float moveScale = iTimeDelta*data.z;\n        if (texelFetch(iChannel1,ivec2(KEY_W,0),0).r>0.5){\n            data.y+=moveScale;\n        }\n        if (texelFetch(iChannel1,ivec2(KEY_S,0),0).r>0.5){\n            data.y-=moveScale;\n        }\n        if (texelFetch(iChannel1,ivec2(KEY_A,0),0).r>0.5){\n            data.x+=moveScale;\n        }\n        if (texelFetch(iChannel1,ivec2(KEY_D,0),0).r>0.5){\n            data.x-=moveScale;\n        }\n        \n        if (texelFetch(iChannel1,ivec2(KEY_UP,0),0).r>0.5){\n            data.z*=(1.0-ZOOMFAC);\n        }\n        if (texelFetch(iChannel1,ivec2(KEY_DOWN,0),0).r>0.5){\n            data.z/=(1.0-ZOOMFAC);\n        }\n        \n        if (texelFetch(iChannel1,ivec2(KEY_LEFT,0),0).r>0.5){\n            data.z*=(1.0-3.0*ZOOMFAC);\n        }\n        if (texelFetch(iChannel1,ivec2(KEY_RIGHT,0),0).r>0.5){\n            data.z/=(1.0-3.0*ZOOMFAC);\n        }\n        \n        if (data.z<=0.0 || iFrame==0){\n            data = vec4(0.5,0.5,2.5,0.0);\n        }\n        \n        data.x = clamp(data.x,-6.0,7.0);\n        data.y = clamp(data.y,-3.0,4.0);\n        \n        data.z = min(data.z,9.0);\n    }\n    \n    fragColor = data;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define TEXEL_CAM ivec2(0,0)",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}