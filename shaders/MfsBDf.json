{
    "Shader": {
        "info": {
            "date": "1724472285",
            "description": "A ray marched cube which is upsampled using a depth-aware algorithm.\n(Left side shows the raw data, right side shows the upsampled result)\n\nanimated upscale transition\n\nOriginal:\nhttps://www.shadertoy.com/view/4cffDX",
            "flags": 32,
            "hasliked": 0,
            "id": "MfsBDf",
            "likes": 0,
            "name": "Fork Depth-aware upsampled cube",
            "published": 3,
            "tags": [
                "raymarching",
                "interpolation",
                "bilinear"
            ],
            "usePreview": 0,
            "username": "Z_Z",
            "viewed": 70
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec2 maxvals = (vec2(iResolution.xy)-.5*iResolution.xy)/iResolution.y;\n    \n    float tanim = sin(iTime*0.5)*maxvals.x;\n    \n    if (abs(uv.x-tanim) < 0.002) { /* Draw center line */\n        vec3 raw = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n        fragColor = vec4(1.0 - raw, 1.0);\n        return;\n    }\n    \n    if (uv.x < (0.0+tanim)) { /* Draw raw data */\n        vec3 raw = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n        fragColor = vec4(raw, 1.0);\n        return;\n    }\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n   \n    /* Get fullress depth value */\n    float depth = RayMarch(ro, rd);\n    vec3 p = ro + rd * depth;\n    vec3 normal = GetNormal(p);\n    \n    if (depth >= MAX_DIST) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    /* Bilinear merge */\n    BilinearSamples bi = GetBilinearSamples(vec2(fragCoord) / float(DOWNSAMPLE) - vec2(0.5));\n    vec4 bilinear = GetBilinearWeights(bi.ratio);\n    \n    /* Fetch the bilinear samples */\n    vec4 samples[4];\n    vec3 normals[4];\n    for (int s = 0; s < 4; s++) {\n        ivec2 bilinear_index = bi.base_index + GetBilinearOffset(s);\n        samples[s] = texture(iChannel0, (vec2(bilinear_index) * float(DOWNSAMPLE) + float(DOWNSAMPLE) * 0.5) / iResolution.xy);\n        normals[s] = texture(iChannel1, (vec2(bilinear_index) * float(DOWNSAMPLE) + float(DOWNSAMPLE) * 0.5) / iResolution.xy).xyz;\n    }\n    \n    /* Create bilateral weights */\n    vec4 depth_samples = vec4(samples[0].w, samples[1].w, samples[2].w, samples[3].w);\n    vec4 normal_samples = vec4(\n        clamp(dot(normal, normals[0]) * 1.5, 0.0, 1.0), \n        clamp(dot(normal, normals[1]) * 1.5, 0.0, 1.0), \n        clamp(dot(normal, normals[2]) * 1.5, 0.0, 1.0), \n        clamp(dot(normal, normals[3]) * 1.5, 0.0, 1.0)\n    );\n    \n    /* Edge detection (from <https://gist.github.com/pixelmager/a4364ea18305ed5ca707d89ddc5f8743>) */\n    float mind = min4(depth_samples);\n    float maxd = max4(depth_samples);\n    float diffd = maxd - mind;\n    float avg = dot(depth_samples, vec4(0.25));\n    bool d_edge = (diffd / avg) > 0.2;\n    \n    vec4 w = bilinear * normal_samples;\n    if (d_edge) { /* Use bilateral depth weights on edges */\n        vec4 dd = abs(depth_samples - depth);\n        w *= vec4(1.0) / (dd + vec4(0.0001));\n    }\n    float wsum = w.x + w.y + w.z + w.w;\n    w /= wsum;\n    \n    /* Sum the bilinear samples with their weights */\n    vec3 r = vec3(0.0);\n    for (int i = 0; i < 4; i++) {\n        r += samples[i].rgb * w[i];\n    }\n    \n    fragColor = vec4(r, 1.0);\n    // fragColor = vec4(normalize(normals[0] + normals[1] + normals[2] + normals[3]), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 coord = ivec2(fragCoord / vec2(float(DOWNSAMPLE))) * int(DOWNSAMPLE) + (int(DOWNSAMPLE) / 2);\n    // vec2 uv = vec2(coord) / iResolution.xy;\n\n    vec2 uv = (vec2(coord)-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        \n        // col = vec3(clamp((p.x + 1.0) * 0.5, 0.0, 1.0), clamp((p.y + 1.0) * 0.5, 0.0, 1.0), 0.0);\n        if (iChannelResolution[0].x != 0.0) {\n            col = texture(iChannel0, vec2(col.x, col.y)).rgb;\n        }\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col, d);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/* Simple ray marcher from BigWIngs <https://www.shadertoy.com/view/WtGXDD> */\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\n#define DOWNSAMPLE 16\n\nfloat min4(vec4 v) { return min(min(v.x, v.y), min(v.z, v.w)); }\nfloat max4(vec4 v) { return max(max(v.x, v.y), max(v.z, v.w)); }\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    float d = sdBox(p, vec3(1));\n    d = min(d, sdBox(p + vec3(4, 0, 0), vec3(1)));\n    d = min(d, sdBox(p + vec3(0, 4, 0), vec3(1)));\n    d = min(d, sdBox(p + vec3(0, 0, 4), vec3(1)));\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(abs(dS)<SURF_DIST) return dO;\n        if (dO>MAX_DIST) break;\n    }\n    \n    return MAX_DIST;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nstruct BilinearSamples {\n    ivec2 base_index;\n    vec2 ratio;\n};\n\nvec4 GetBilinearWeights(vec2 ratio) {\n    return vec4(\n        (1.0 - ratio.x) * (1.0 - ratio.y),\n        ratio.x * (1.0 - ratio.y),\n        (1.0 - ratio.x) * ratio.y,\n        ratio.x * ratio.y);\n}\n\nivec2 GetBilinearOffset(int offset_index) {\n    ivec2 offsets[4] = ivec2[4](ivec2(0, 0), ivec2(1, 0), ivec2(0, 1), ivec2(1, 1));\n    return offsets[offset_index];\n}\n\nBilinearSamples GetBilinearSamples(vec2 pixel_index2f) {\n    BilinearSamples samples;\n    samples.base_index = ivec2(floor(pixel_index2f));\n    samples.ratio = fract(pixel_index2f);\n    return samples;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 coord = ivec2(fragCoord / vec2(float(DOWNSAMPLE))) * int(DOWNSAMPLE) + (int(DOWNSAMPLE) / 2);\n    // vec2 uv = vec2(coord) / iResolution.xy;\n\n    vec2 uv = (vec2(coord)-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = n;\n    }\n\n    fragColor = vec4(col, d);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}