{
    "Shader": {
        "info": {
            "date": "1613569024",
            "description": "Tilings by irregular pentagons. Best viewed full screen.\n\ncf. Craig S. Kaplan: [url]https://twitter.com/cs_kaplan/status/1361089568229974017[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "WtdBWj",
            "likes": 34,
            "name": "A Plethora of Pentagons",
            "published": 3,
            "tags": [
                "deformation",
                "pentagons",
                "parquet"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 526
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Dual snub hexagonal tiling (so the tiles are generally pentagons).\n// Matthew Arcus, mla, 2021\n//\n// Wythoff construction, with the Wythoff point varying across the plane.\n// Inspired by Craig S. Kaplan: https://twitter.com/cs_kaplan/status/1361089568229974017\n// \n// <mouse>: Uniform tiling across plane\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float X = sqrt(3.0);\n\nfloat drawone(vec2 z, vec2 t0, float d) {\n  d = min(d,segment(z,t0,vec2(0)));\n  d = min(d,segment(z,t0,vec2(X,0)));\n  d = min(d,segment(z,t0,vec2(0,1)));\n\n  d = min(d,segment(-z,t0,vec2(0)));\n  d = min(d,segment(-z,t0,vec2(X,0)));\n  d = min(d,segment(-z,t0,vec2(0,1)));\n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  z = rotate(z,0.05*iTime);\n  z *= 16.0;\n  vec2 z0 = z;\n\n  const mat2 M = mat2(X,-3,X,3);\n  z.x += X;\n  z = inverse(M)*z; // Convert to square grid\n  z -= floor(z);\n  z = M*z; // Back to triangles\n  z.x -= X;\n\n  if (z.y < 0.0) z = -z; // Rotate lower triangle to upper.\n\n  // Rotational symmetry about triangle centre, so map centre of triangle to origin...\n  z.y -= 1.0;\n\n  // ...and reflect in planes of symmetry of triangle\n  const vec2 A = normalize(vec2(1,X));\n  const vec2 B = normalize(vec2(-1,X));\n  int parity = 0;\n  float ta = dot(z,A);\n  if (ta < 0.0) z -= 2.0*ta*A;\n  float tb = dot(z,B);\n  if (tb < 0.0) z -= 2.0*tb*B;\n  if (int(ta>0.0) + int(tb>0.0) == 1) z.x = -z.x; // Want even number of reflections\n  z.y += 1.0;        // Shift origin back to region centre,\n\n  float pwidth = fwidth(z0.x);\n  \n  vec3 col0 = vec3(0);\n  vec3 col1 = vec3(0.9);//vec3(1,0,0);\n  vec3 col2 = vec3(0.95);//vec3(1,1,0);\n\n  float d = min(abs(z.x),z.y);\n  d = min(d,line(abs(z),vec2(0,1),vec2(X,0)));\n  float mfact = smoothstep(-pwidth,pwidth,d);\n  vec3 col = mix(col1,col2,(z.x < 0.0 ? mfact : mfact-1.0));\n  \n  vec2 z1 = vec2(-1,1)*reflection(z,vec2(X,0),vec2(0,1));\n  vec2 z2 = reflection(vec2(-1,1)*z,vec2(X,0),vec2(0,1));\n  vec2 t0 = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n  if (iMouse.z > 0.0) t0 = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n  t0 = 1.2*rotate(t0,-0.2*iTime);\n  \n  d = 1e8;\n  d = drawone(z,t0,d);\n  d = drawone(z1,t0,d);\n  d = drawone(z2,t0,d);\n\n  col = mix(col0,col,smoothstep(0.015,0.015+1.25*pwidth,d));\n\n  fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 reflection(vec2 p, vec2 q, vec2 r) {\n  // reflect p in the line through q and r\n  p -= q;\n  vec2 n = (r-q).yx * vec2(1,-1);\n  p -= 2.0*dot(p,n)*n/dot(n,n);\n  p += q;\n  return p;\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  float d = length(pa - ba * h);\n  return d;\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a;\n  vec2 ba = b-a;\n  float h = dot(pa,ba)/dot(ba,ba);\n  return length(pa - ba * h);\n}\n\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}