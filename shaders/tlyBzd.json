{
    "Shader": {
        "info": {
            "date": "1614874786",
            "description": "Click -> Write\nKey X + Click -> Cross\n\nIf you click on an already painted square, it will erased.\nIf the answer is correct, the picture will be colored.\nEnjoy! :)",
            "flags": 48,
            "hasliked": 0,
            "id": "tlyBzd",
            "likes": 10,
            "name": "Picross (Nonogram)",
            "published": 3,
            "tags": [
                "game",
                "bitmap",
                "puzzle",
                "picross",
                "nonogram"
            ],
            "usePreview": 0,
            "username": "IWBTShyGuy",
            "viewed": 508
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright © 2021 IWBTShyGuy\n\nconst float GRID_THICKNESS = 0.1;\n\nconst vec4 BACK = vec4(230, 220, 182, 255) / 255.0;\nconst vec4 GRID = vec4(78, 52, 0, 255) / 255.0;\nconst vec4 INK = vec4(122, 89, 64, 255) / 255.0;\n\nfloat letter(in vec2 uv, in int idx) {\n    uv = clamp(uv, 0.0, 1.0);\n    int i = idx % 16;\n    int j = 15 - idx / 16;\n    vec2 origin = vec2(float(i) / 16.0, float(j) / 16.0);\n    uv = (uv / 16.0 + origin);\n    float r = texture(iChannel1, uv).x;\n    return floor(r + 0.5);\n}\n\nfloat number(in vec2 uv, in int num) {\n    int num_100 = num / 100;\n    int num_10 = (num % 100) / 10;\n    int num_1 = num % 10;\n    float flag_100 = float(sign(num_100));\n    float flag_10 = (1.0 - flag_100) * float(sign(num_10));\n    float flag_1 = (1.0 - flag_100) * (1.0 - flag_10);\n    float r_1 = letter(uv, num_1 + 48);\n    int x_10 = int(uv.x * 2.0);\n    int a_10 = num_10 * clamp(1 - x_10, 0, 1)\n        + num_1 * clamp(1 - abs(x_10 - 1), 0, 1);\n    float r_10 = letter(vec2(fract(uv.x * 2.0), uv.y), a_10 + 48);\n    int x_100 = int(uv * 3.0);\n    int a_100 = num_100 * clamp(1 - x_100, 0, 1)\n        + num_10 * clamp(1 - abs(x_100 - 1), 0, 1)\n        + num_1 * clamp(1 - abs(x_100 - 2), 0, 1);\n    float r_100 = letter(vec2(fract(uv.x * 3.0), uv.y), a_100 + 48);\n    return flag_1 * r_1 + flag_10 * r_10 + flag_100 * r_100;\n}\n\nfloat drawLine(in float x) {\n    float a = x - floor(x);\n    a = clamp(a / GRID_THICKNESS, 0.0, 1.0);\n    float b = floor(x + 1.0) - x;\n    b = clamp(b / GRID_THICKNESS, 0.0, 1.0);\n    return min(a, b);\n}\n\nint countDifference() {\n    int counter = 0;\n    for (int i = 0; i < WIDTH; i++) {\n        for (int j = 0; j < HEIGHT; j++) {\n            int board = int(texelFetch(iChannel0, ivec2(i, j), 0).x * 1.01);\n            board = clamp(1 - abs(board - 1), 0, 1);\n            int bit = BITMAP[(HEIGHT - 1 - j) * WIDTH + i];\n            bit = clamp(1 - abs(bit - 1), 0, 1);\n            counter += abs(bit - board);\n        }\n    }\n    return counter;\n}\n\nconst int PICROSS[7] = int[](80, 105, 99, 114, 111, 115, 115);\n\nvec4 upperLeft(in vec2 uv) {\n    uv = vec2(uv.x / 0.25, (uv.y - 0.75) / 0.25);\n    int idx = int(uv.x * 7.0);\n    uv.x = fract(uv.x * 7.0);\n    uv.y = clamp((uv.y - 0.4) * 7.0, 0.0, 1.0);\n    float r = 1.0 - letter(uv, PICROSS[idx]);\n    return r * BACK + (1.0 - r) * GRID;\n}\n\nint countRow(in int row, in int num) {\n    int prev = 0;\n    int counter = 0;\n    for (int i = 0; i < WIDTH; i++) {\n        int idx = (HEIGHT - 1 - row) * WIDTH + (WIDTH - 1 - i);\n        int current = 1 - clamp(abs(BITMAP[idx] - 1), 0, 1);\n        int pflag = 1 - clamp(abs(num), 0, 1);\n        counter += pflag * current;\n        num -= clamp(prev - current, 0, 1);\n        prev = current;\n    }\n    return counter;\n}\n\nvec4 lowerLeft(in vec2 uv) {\n    float c = drawLine(uv.y / 0.75 * float(HEIGHT));\n    int row = int(uv.y / 0.75 * float(HEIGHT));\n    int num = int((0.25 - uv.x) / 0.25 * 6.0);\n    int count = countRow(row, num);\n    uv = vec2((0.25 - uv.x) / 0.25 * 6.0, uv.y / 0.75 * 16.0);\n    uv = uv - floor(uv);\n    uv.x = 1.0 - uv.x;\n    uv.y = clamp((uv.y - 0.5) * 1.2 + 0.5, 0.0, 1.0);\n    float r = 1.0 - float(sign(count)) * number(uv, count);\n    r = min(r, c);\n    return r * BACK + (1.0 - r) * GRID;\n}\n\nint countCol(in int col, in int num) {\n    int prev = 0;\n    int counter = 0;\n    for (int i = 0; i < HEIGHT; i++) {\n        int idx = (HEIGHT - 1 - i) * WIDTH + col;\n        int current = 1 - clamp(abs(BITMAP[idx] - 1), 0, 1);\n        int pflag = 1 - clamp(abs(num), 0, 1);\n        counter += pflag * current;\n        num -= clamp(prev - current, 0, 1);\n        prev = current;\n    }\n    return counter;\n}\n\nvec4 upperRight(in vec2 uv) {\n    float h = drawLine((uv.x - 0.25) / 0.75 * float(WIDTH));\n    int col = int((uv.x - 0.25) / 0.75 * float(WIDTH));\n    int num = int((uv.y - 0.75) / 0.25 * 6.0);\n    int count = countCol(col, num);\n    uv = vec2((uv.x - 0.25) / 0.75 * 16.0, (uv.y - 0.75) / 0.25 * 6.0);\n    uv = uv - floor(uv);\n    uv.x = clamp((uv.x - 0.5) * 1.1 + 0.5, 0.0, 1.0);\n    float r = 1.0 - float(sign(count)) * number(uv, count);\n    r = min(r, h);\n    return r * BACK + (1.0 - r) * GRID;\n}\n\nfloat middleOfGame(in vec2 uv) {\n    float t = texelFetch(iChannel0, ivec2(uv), 0).x;\n    uv = 2.0 * (uv - floor(uv)) - 1.0;\n    float a = 1.0 * clamp(1.0 - t, 0.0, 1.0);\n    float b = 0.0 * (1.0 - abs(t - 1.0));\n    float c = clamp(abs(abs(uv.x) - abs(uv.y)) / (GRID_THICKNESS * 3.0), 0.0, 1.0);\n    c *= clamp(t - 1.0, 0.0, 1.0);\n    return max(max(a, b), c);\n}\n\nvec4 drawBitmap(in vec2 uv) {\n    ivec2 iuv = ivec2(uv);\n    iuv.y = HEIGHT - 1 - iuv.y;\n    int idx = iuv.y * WIDTH + iuv.x;\n    return PALLET[BITMAP[idx]];\n}\n\nvec4 lowerRight(in vec2 uv) {\n    uv = vec2(uv.x - 0.25, uv.y) / 0.75 * float(WIDTH);\n    float g = drawLine(uv.x);\n    g = min(g, drawLine(uv.y));\n    float r = middleOfGame(uv);\n    vec4 col = min(r * BACK + (1.0 - r) * INK, g * vec4(1) + (1.0 - g) * GRID);\n    float count = clamp(float(countDifference()), 0.0, 1.0);\n    vec4 bitmap = min(drawBitmap(uv), col);\n    bitmap = bitmap * BACK + (1.0 - bitmap) * GRID;\n    return col * count + bitmap * (1.0 - count);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = intoUv(fragCoord, iResolution.xy);\n    if (0.0 <= uv.x && uv.x < 0.25 && 0.75 <= uv.y) {\n        fragColor = upperLeft(uv);\n    } else if (0.0 <= uv.x && uv.x < 0.25 && uv.y < 0.75) {\n        fragColor = lowerLeft(uv);\n    } else if (0.25 <= uv.x && uv.x < 1.0 && 0.75 <= uv.y) {\n        fragColor = upperRight(uv);\n    } else if (0.25 <= uv.x && uv.x < 1.0 && uv.y < 0.75) {\n        fragColor = lowerRight(uv);\n    } else {\n        fragColor = vec4(0, 0, 0, 1);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// The MIT License\n// Copyright © 2021 IWBTShyGuy\n\nbool isKeyDown(int code) {\n    return texelFetch(iChannel1, ivec2(code, 0), 0).x > 0.0;\n}\nconst int Key_Z = 90;\nconst int Key_X = 88;\n\nbool onMousePressed() {\n    float prev = texelFetch(iChannel0, ivec2(0, HEIGHT + 1), 0).z;\n    return prev <= 0.0 && iMouse.z > 0.0;\n}\n\nint countDifference() {\n    int counter = 0;\n    for (int i = 0; i < WIDTH; i++) {\n        for (int j = 0; j < HEIGHT; j++) {\n            int board = int(texelFetch(iChannel0, ivec2(i, j), 0).x * 1.01);\n            board = clamp(1 - abs(board - 1), 0, 1);\n            int bit = BITMAP[(HEIGHT - 1 - j) * WIDTH + i];\n            bit = clamp(1 - abs(bit - 1), 0, 1);\n            counter += abs(bit - board);\n        }\n    }\n    return counter;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame == 0) {\n        fragColor = vec4(0);\n        return;\n    }\n    int count = countDifference();\n    if (count == 0) {\n        fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n        fragColor = 1.0 - abs(1.0 - fragColor);\n        return;\n    }\n    ivec2 ifragCoord = ivec2(fragCoord);\n    if (ifragCoord == ivec2(0, HEIGHT + 1)) {\n        fragColor = iMouse;\n        return;\n    }\n    if (onMousePressed()) {\n        vec2 uv = intoUv(iMouse.xy, iResolution.xy);\n        uv = vec2(uv.x - 0.25, uv.y) / 0.75;\n        uv *= 16.0;\n        if (ifragCoord == ivec2(uv)) {\n            int r = int(texelFetch(iChannel0, ifragCoord, 0).x);\n            if (isKeyDown(Key_X)) {\n                fragColor = vec4(2 * sign(2 - r));\n            } else {\n                fragColor = vec4(abs(1 - r));\n            }\n            return;\n        }\n    }\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// BITMAP reference\n// https://www.spriters-resource.com/nes/supermariobros2supermariousa/\n\nconst int WIDTH = 16;\nconst int HEIGHT = 16;\n\nconst vec4 PALLET[4] = vec4[](\n    vec4(1),\n    vec4(0, 0, 0, 1),\n    vec4(1),\n    vec4(0xf8, 0x38, 0x00, 0xff) / 255.0\n);\n\nconst int BITMAP[WIDTH * HEIGHT] = int[](\n0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,\n1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,\n0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,2,2,1,1,1,1,\n1,1,1,2,2,1,0,0,0,1,2,2,2,1,1,1,1,1,2,2,2,1,0,0,\n0,1,2,2,1,2,1,1,1,2,1,2,2,1,0,0,0,1,1,2,2,2,2,1,\n2,2,2,2,1,1,0,0,0,0,1,1,2,2,2,1,2,2,2,1,1,0,0,0,\n0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,3,3,\n3,1,1,1,1,1,1,1,0,1,1,1,1,1,3,3,3,1,1,1,1,1,1,1,\n0,0,1,1,1,1,1,3,1,1,1,1,1,1,0,0,0,1,3,3,1,1,1,1,\n1,1,1,1,1,0,0,0,1,3,3,3,3,3,1,1,1,1,1,1,1,1,1,0,\n1,3,3,3,3,3,3,1,1,1,1,3,3,3,3,1);\n\nvec2 intoUv(in vec2 fragCoord, in vec2 resolution) {\n    return (fragCoord - resolution / 2.0) / resolution.y + 0.5;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}