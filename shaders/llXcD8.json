{
    "Shader": {
        "info": {
            "date": "1504559895",
            "description": "my testbed",
            "flags": 32,
            "hasliked": 0,
            "id": "llXcD8",
            "likes": 0,
            "name": "test_0001",
            "published": 3,
            "tags": [
                "study"
            ],
            "usePreview": 0,
            "username": "karl_jacksson",
            "viewed": 417
        },
        "renderpass": [
            {
                "code": "\n#define RESOLUTION 600.0\n\n// map\n#define MAP_SIZE_X 10\n#define MAP_SIZE_Y 10\n#define MAP_SIZE_Xf 10.0\n#define MAP_SIZE_Yf 10.0\n\n#define B 1 //brick\n#define _ 0 //empty\n\nint map(in ivec2 qpos)\n{\n    if(qpos.x >= MAP_SIZE_X || qpos.y >= MAP_SIZE_Y)\n    {\n    \treturn _;\n    }\n \n\tint m = _;\n\tint row = qpos.y;\n\n    #define mSHIFT 2\n    #define mMN (1 << mSHIFT) // max pack value\n    #define mPACK(q,w,e,r,t,y,u,i,o,p) (q+mMN*(w+mMN*(e+mMN*(r+mMN*(t+mMN*(y+mMN*(u+mMN*(i+mMN*(o+mMN*(p))))))))))\n    #define mMM(rr,q,w,e,r,t,y,u,i,o,p) if(row == rr)m = mPACK(q,w,e,r,t,y,u,i,o,p)\n\n    mMM(9, _,B,B,B,B,B,B,B,B,_);\n    mMM(8, B,B,B,B,B,B,_,B,B,B);\n    mMM(7, B,B,B,B,B,B,B,B,B,B);\n    mMM(6, B,B,B,B,B,B,B,B,B,B);\n    mMM(5, B,_,_,_,_,_,_,_,_,B);\n\n\treturn (m >> (mSHIFT * qpos.x)) & (mMN - 1);\n}\n\n\n// digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n// converted to LUT and integer logic by iq\nconst int[] font = int[]( \n    7 + 5*16 + 5*256 + 5*4096 + 7*65536,\n    2 + 2*16 + 2*256 + 2*4096 + 2*65536,\n    7 + 1*16 + 7*256 + 4*4096 + 7*65536,\n    7 + 4*16 + 7*256 + 4*4096 + 7*65536,\n    4 + 7*16 + 5*256 + 1*4096 + 1*65536,\n    7 + 4*16 + 7*256 + 1*4096 + 7*65536,\n    7 + 5*16 + 7*256 + 1*4096 + 7*65536,\n    4 + 4*16 + 4*256 + 4*4096 + 7*65536,\n    7 + 5*16 + 7*256 + 5*4096 + 7*65536,\n    7 + 4*16 + 7*256 + 5*4096 + 7*65536 );\n                          \nint _sampleDigit(const in int n, const in vec2 vUV)\n{\n    vec2 q = abs(vUV - 0.5);\n    if(max(q.x, q.y) > 0.5)\n    {\n        return 0;\n    }\n    ivec2 p = ivec2(floor(vUV * vec2(4.0, 5.0)));\n    int i = p.x + p.y * 4;\n    return (font[n] >> i) & 1;\n}\n\nvoid printInt(inout vec3 color, in vec2 fragCoord, in int value)\n{\n    //vec2 uv = (fragCoord / iResolution.y - vec2(0.03, 0.95)) * 30.0;\n    vec2 uv = fragCoord.xy / iResolution.xy * 20.0;\n    uv.x *= 2.0;\n    int maxDigits = (value < 10) ? 1 : (value < 100) ? 2 :\n    \t\t\t\t\t(value < 1000) ? 3 : (value < 10000) ? 4 : 5;\n    int digitID = maxDigits - 1 - int(floor(uv.x));\n    if(digitID >= 0 && digitID < maxDigits)\n    {\n        int div = (digitID == 0) ? 1 : (digitID == 1) ? 10 :\n        \t\t\t(digitID == 2) ? 100 : (digitID == 3) ? 1000 : 10000;\n        color += float(_sampleDigit((value / div) % 10, vec2(fract(uv.x), uv.y)));\n    }\n}\n\nvec2 getScreenSize()\n{\n    return vec2(RESOLUTION * iResolution.x / iResolution.y, RESOLUTION);\n}\n\nvoid mapbrick(inout vec3 color, in vec2 size, in vec2 offset, in vec2 fragCoord)\n{\n    ivec2 mappos;\n    float resolution_x = RESOLUTION * (iResolution.x / iResolution.y);\n\tvec2 frpos = fragCoord.xy / iResolution.xy;    \n    vec2 origin = frpos * vec2(resolution_x, RESOLUTION);\n    vec2 objpos = origin - offset;\n    mappos.x = int(objpos.x / size.x);\n    mappos.y = int(objpos.y / size.y);\n    int m = map(mappos);\n    if(m != _)\n    //if(mappos.x == 5 && mappos.y == 5)\n    {\n\t\tvec2 lpos = frpos - offset / vec2(resolution_x, RESOLUTION);\n        if(lpos.x >= 0.0 && lpos.y >= 0.0)\n        {\n\t\t\tvec2 txsz = vec2(size.x / resolution_x, size.y / RESOLUTION);\n            lpos = mod(lpos, txsz);\n            color = texture(iChannel1, lpos).rgb;\n        }\n    }\n}\n\nvoid racket(inout vec3 color, in vec2 size, in vec2 pos, in vec2 fragCoord)\n{\n    float resolution_x = RESOLUTION * (iResolution.x / iResolution.y);\n\tvec2 frpos = fragCoord.xy / iResolution.xy;    \n    vec2 objpos = frpos * vec2(resolution_x, RESOLUTION) - pos;\n    if(objpos.x < size.x && objpos.y < size.y)\n    {\n\t\tvec2 lpos = frpos - pos / vec2(resolution_x, RESOLUTION);\n        if(lpos.x >= 0.0 && lpos.y >= 0.0)\n        {\n\t\t\tvec2 txsz = vec2(size.x / resolution_x, size.y / RESOLUTION);\n        \tcolor = texture(iChannel2, lpos / txsz).rgb;\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    vec2 screenSize = getScreenSize();\n    vec2 brick_size = vec2(100.0, 64.0);\n    vec2 racket_size = vec2(200.0, 48.0);\n    \n    // bricks\n    vec2 offset = vec2(0.0, RESOLUTION - MAP_SIZE_Yf * brick_size.y);\n    mapbrick(col, brick_size, offset, fragCoord);\n\n    // racket\n    vec2 rpos = vec2((screenSize.x - racket_size.x) / 2.0, 50);\n    rpos.x += sin(iTime) * 100.0;\n    racket(col, racket_size, rpos, fragCoord);\n\n    // score\n    printInt(col, fragCoord, 98765);\n    \n    fragColor = vec4(col, 1.0);\n    \n    fragColor = texture(iChannel1, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//based on https://thebookofshaders.com\n\n#define RESOLUTION 600.0\n\n#define BRICK_SIZE_Xf (100.0 * 5.0)\n#define BRICK_SIZE_Yf (64.0 * 5.0)\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nfloat degToRad(float angleDeg)\n{\n\treturn (angleDeg * PI) / 180.0;\n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid triangle(inout vec3 col, in vec2 uv, in vec2 size, in vec2 pos)\n{\n    float a = atan(uv.x, uv.y) + PI;\n    float r = TWO_PI / 4.0;\n    float d = cos(floor(0.5 + a / r) * r - a) * length(uv / RESOLUTION);\n    col = vec3(1.0 - smoothstep(0.4, 0.41, d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    // brick\n    float resolution_x = RESOLUTION * (iResolution.x / iResolution.y);\n\tvec2 frpos = fragCoord.xy / iResolution.xy;    \n    vec2 origin = frpos * vec2(resolution_x, RESOLUTION);\n    vec3 col = vec3(0.0);\n    \n    //if(origin.x < BRICK_SIZE_Xf && origin.y < BRICK_SIZE_Yf)\n    {        \n        vec2 uv = origin;// / RESOLUTION;\n        uv = rotate2d(degToRad(0.0)) * uv;\n        \n        vec2 size = vec2(BRICK_SIZE_Xf, BRICK_SIZE_Yf);\n\t\tvec2 pos = vec2(0.0, 0.0);\n        triangle(col, uv, size, pos);\n        fragColor = vec4(col, 1.0);\n    }\n    if(!(origin.x < BRICK_SIZE_Xf && origin.y < BRICK_SIZE_Yf))\n    {\n        fragColor += vec4(0.5, 0.5, 0.5, 1.0);\n    }\n    // discard;\n}\n\n// roundbox\n/*\nfloat bw = BRICK_SIZE_Xf / resolution_x;\nfloat bh = BRICK_SIZE_Yf / RESOLUTION;\nvec2 pos = (fragCoord.xy / iResolution.yy) - vec2(bw * 0.9, bh * 0.5);\nvec2 size = vec2(bw * 2.8, bh) / 5.0;\nfloat r = 0.05 / 5.0;\nfloat dist = roundBox(pos, size, r);\nfloat s = 1.0 - smoothstep(size.y * 1.0, size.y * 1.0, dist); \nfragColor = vec4(s,s,s, 1.0);\nreturn;\n*/",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}