{
    "Shader": {
        "info": {
            "date": "1590827507",
            "description": "Licence CC0: Nothing special, just a mandelbrot with orbit traps, experimenting with \"smart\" AA",
            "flags": 0,
            "hasliked": 0,
            "id": "wdBfDK",
            "likes": 16,
            "name": "Mandelbrot with \"smart\" AA",
            "published": 3,
            "tags": [
                "2d",
                "mandelbrot",
                "aa"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 582
        },
        "renderpass": [
            {
                "code": "\n#define MANDELBROT_ZOOM_START 0.0\n#define MANDELBROT_ITER       240\n\nvoid pR(inout vec2 p, in float a) { \n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);    \n}\n\nvec2 pMod2(inout vec2 p, in vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n\nvec3 mandelbrot(float time, vec2 p, out float ii) {\n  vec3 col = vec3(0.0);\n\n  float ztime = (time - MANDELBROT_ZOOM_START)*step(MANDELBROT_ZOOM_START, time);\n\n  float zoo = 0.64 + 0.36*cos(.07*ztime);\n  float coa = cos(0.15*(1.0-zoo)*ztime);\n  float sia = sin(0.15*(1.0-zoo)*ztime);\n  zoo = pow(zoo,8.0);\n  vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\n  vec2 c = vec2(-.745,.186) + xy*zoo;\n\n  const float B = 10.0;\n  float l = 0.0;\n  vec2 z  = vec2(0.0);\n\n  vec2 zc = vec2(1.0);\n  \n  pR(zc, ztime);\n\n  float d = 1e20;\n  \n  int i = 0;\n        \n  for(int j = 0; j < MANDELBROT_ITER; ++j) {\n// \"Furry\" mandelbrot\n//    const float ss = 0.125*1.13125;\n//    const float ss = sqrt(1.99)/10.0;\n//    z = tanh(ss*z)/ss;\n    float re2 = z.x*z.x;\n    float im2 = z.y*z.y;\n    float reim= z.x*z.y;\n        \n    if(re2 + im2 > (B*B)) break;\n\n    z = vec2(re2 - im2, 2.0*reim) + c;\n\n    vec2 zm = z;\n    vec2 n = pMod2(zm, vec2(4));\n    vec2 pp = zm - zc;\n    float dd = dot(pp, pp);\n\n    d = min(d, dd);\n\n    l += 1.0;\n    \n    i = j;\n  }\n\n  ii = float(i)/float(MANDELBROT_ITER);\n  \n  float sl = l - log2(log2(dot(z,z))) + 4.0; \n\n  vec3 dc = vec3(pow(max(1.0 - d, 0.0), 20.0));\n  vec3 gc = 0.5 + 0.5*cos(3.0 + sl*0.15 + vec3(0.1,0.5,0.9));\n  return gc + dc*smoothstep(28.8, 29.0, ztime);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float s = 2.0/iResolution.y;\n\n  vec2 o1 = vec2(1.0/8.0, 3.0/8.0)*s;\n  vec2 o2 = vec2(-3.0/8.0, 1.0/8.0)*s;\n\n  vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n  float ii = 0.0;\n  vec3 col = mandelbrot(iTime, p+o1, ii);\n\n  // \"smart\" AA? Is that a good idea?  \n  vec2 dii2 = vec2(dFdx(ii), dFdy(ii));\n  float dii = length(dii2);\n  \n  if(abs(dii) > 0.01) {\n    col += mandelbrot(iTime, p-o1, ii);\n    col += mandelbrot(iTime, p+o2, ii);\n    col += mandelbrot(iTime, p-o2, ii);\n    col *=0.25;\n//    col = vec3(1.0, 0.0, 0.0);\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}