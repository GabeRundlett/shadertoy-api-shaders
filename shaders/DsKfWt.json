{
    "Shader": {
        "info": {
            "date": "1698768742",
            "description": "Mouse reactive liquid",
            "flags": 0,
            "hasliked": 0,
            "id": "DsKfWt",
            "likes": 4,
            "name": "Reactive liquid",
            "published": 3,
            "tags": [
                "mouse",
                "reactive",
                "liquid"
            ],
            "usePreview": 0,
            "username": "bartus131313",
            "viewed": 174
        },
        "renderpass": [
            {
                "code": "uniform sampler2D u_textures[16];\n\nfloat psrdnoise(vec2 x, vec2 period, float alpha, out vec2 gradient) {\n\n\t// Transform to simplex space (axis-aligned hexagonal grid)\n\tvec2 uv = vec2(x.x + x.y*0.5, x.y);\n\n\t// Determine which simplex we're in, with i0 being the \"base\"\n\tvec2 i0 = floor(uv);\n\tvec2 f0 = fract(uv);\n\t// o1 is the offset in simplex space to the second corner\n\tfloat cmp = step(f0.y, f0.x);\n\tvec2 o1 = vec2(cmp, 1.0-cmp);\n\n\t// Enumerate the remaining simplex corners\n\tvec2 i1 = i0 + o1;\n\tvec2 i2 = i0 + vec2(1.0, 1.0);\n\n\t// Transform corners back to texture space\n\tvec2 v0 = vec2(i0.x - i0.y * 0.5, i0.y);\n\tvec2 v1 = vec2(v0.x + o1.x - o1.y * 0.5, v0.y + o1.y);\n\tvec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\n\n\t// Compute vectors from v to each of the simplex corners\n\tvec2 x0 = x - v0;\n\tvec2 x1 = x - v1;\n\tvec2 x2 = x - v2;\n\n\tvec3 iu, iv;\n\tvec3 xw, yw;\n\n\t// Wrap to periods, if desired\n\tif(any(greaterThan(period, vec2(0.0)))) {\n\t\txw = vec3(v0.x, v1.x, v2.x);\n\t\tyw = vec3(v0.y, v1.y, v2.y);\n\t\tif(period.x > 0.0)\n\t\t\txw = mod(vec3(v0.x, v1.x, v2.x), period.x);\n\t\tif(period.y > 0.0)\n\t\t\tyw = mod(vec3(v0.y, v1.y, v2.y), period.y);\n\t\t// Transform back to simplex space and fix rounding errors\n\t\tiu = floor(xw + 0.5*yw + 0.5);\n\t\tiv = floor(yw + 0.5);\n\t} else { // Shortcut if neither x nor y periods are specified\n\t\tiu = vec3(i0.x, i1.x, i2.x);\n\t\tiv = vec3(i0.y, i1.y, i2.y);\n\t}\n\n\t// Compute one pseudo-random hash value for each corner\n\tvec3 hash = mod(iu, 289.0);\n\thash = mod((hash*51.0 + 2.0)*hash + iv, 289.0);\n\thash = mod((hash*34.0 + 10.0)*hash, 289.0);\n\n\t// Pick a pseudo-random angle and add the desired rotation\n\tvec3 psi = hash * 0.07482 + alpha;\n\tvec3 gx = cos(psi);\n\tvec3 gy = sin(psi);\n\n\t// Reorganize for dot products below\n\tvec2 g0 = vec2(gx.x,gy.x);\n\tvec2 g1 = vec2(gx.y,gy.y);\n\tvec2 g2 = vec2(gx.z,gy.z);\n\n\t// Radial decay with distance from each simplex corner\n\tvec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\n\tw = max(w, 0.0);\n\tvec3 w2 = w * w;\n\tvec3 w4 = w2 * w2;\n\n\t// The value of the linear ramp from each of the corners\n\tvec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\n\n\t// Multiply by the radial decay and sum up the noise value\n\tfloat n = dot(w4, gdotx);\n\n\t// Compute the first order partial derivatives\n\tvec3 w3 = w2 * w;\n\tvec3 dw = -8.0 * w3 * gdotx;\n\tvec2 dn0 = w4.x * g0 + dw.x * x0;\n\tvec2 dn1 = w4.y * g1 + dw.y * x1;\n\tvec2 dn2 = w4.z * g2 + dw.z * x2;\n\tgradient = 10.9 * (dn0 + dn1 + dn2);\n\n\t// Scale the return value to fit nicely into the range [-1,1]\n\treturn 10.9 * n;\n}\n\n\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef INV_PI\n#define INV_PI 0.31830988618379067153776752674503\n#endif\n#ifndef INV_SQRT_TAU\n#define INV_SQRT_TAU 0.39894228040143267793994605993439  // 1.0/SQRT_TAU\n#endif\n#ifndef SQRT_HALF_PI\n#define SQRT_HALF_PI 1.25331413732\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE // (3.-sqrt(5.0))*PI radians\n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n#ifndef FNC_BOUNCEOUT\n#define FNC_BOUNCEOUT\nfloat bounceOut(in float t) {\n    const float a = 4.0 / 11.0;\n    const float b = 8.0 / 11.0;\n    const float c = 9.0 / 10.0;\n\n    const float ca = 4356.0 / 361.0;\n    const float cb = 35442.0 / 1805.0;\n    const float cc = 16061.0 / 1805.0;\n\n    float t2 = t * t;\n\n    return t < a\n        ? 7.5625 * t2\n        : t < b\n            ? 9.075 * t2 - 9.9 * t + 3.4\n            : t < c\n                ? ca * t2 - cb * t + cc\n                : 10.8 * t * t - 20.52 * t + 10.72;\n}\n#endif\n\n#ifndef FNC_BOUNCEOUT\n#define FNC_BOUNCEOUT\nfloat bounceOut(in float t) {\n    const float a = 4.0 / 11.0;\n    const float b = 8.0 / 11.0;\n    const float c = 9.0 / 10.0;\n\n    const float ca = 4356.0 / 361.0;\n    const float cb = 35442.0 / 1805.0;\n    const float cc = 16061.0 / 1805.0;\n\n    float t2 = t * t;\n\n    return t < a\n        ? 7.5625 * t2\n        : t < b\n            ? 9.075 * t2 - 9.9 * t + 3.4\n            : t < c\n                ? ca * t2 - cb * t + cc\n                : 10.8 * t * t - 20.52 * t + 10.72;\n}\n#endif\n\n#ifndef FNC_BOUNCEIN\n#define FNC_BOUNCEIN\nfloat bounceIn(in float t) { return 1.0 - bounceOut(1.0 - t); }\n#endif\n\n#ifndef FNC_BOUNCEOUT\n#define FNC_BOUNCEOUT\nfloat bounceOut(in float t) {\n    const float a = 4.0 / 11.0;\n    const float b = 8.0 / 11.0;\n    const float c = 9.0 / 10.0;\n\n    const float ca = 4356.0 / 361.0;\n    const float cb = 35442.0 / 1805.0;\n    const float cc = 16061.0 / 1805.0;\n\n    float t2 = t * t;\n\n    return t < a\n        ? 7.5625 * t2\n        : t < b\n            ? 9.075 * t2 - 9.9 * t + 3.4\n            : t < c\n                ? ca * t2 - cb * t + cc\n                : 10.8 * t * t - 20.52 * t + 10.72;\n}\n#endif\n#ifndef FNC_BOUNCEINOUT\n#define FNC_BOUNCEINOUT\nfloat bounceInOut(in float t) {\n    return t < 0.5\n        ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\n        : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\n#endif\n\n// type # to get code suggestions for regions\n// the regions are also foldable\n\nvec2 rot(vec2 v, float a){\n    return mat2x2(\n                cos(a), -sin(a), \n                sin(a), cos(a)\n            ) * v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 st = uv * vec2(iResolution.x / iResolution.y, 1.);\n    // @note you can tweak float and vec values\n    // try to right click on 8, choose \"Tweak Value\" (or use a shortcut)\n    st = rot(st, -PI / 8.);\n\n    // normalize mouse coordinates\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec2 gradient;\n    // @note to tweak vectors as a whole, right click on vec2/vec3/vec4, select \"Tweak Value\"\n    // 2D vectors have a convenient point tweaking, while higher order vectors are tweaked by values\n    float n = psrdnoise(vec2(3.) * st, vec2(0.), 1.2 * iTime + mouse.y * PI, gradient);\n\n    float lines = cos((st.x + n * 0.1 + mouse.x + 0.2) * PI);\n\n    fragColor = vec4(\n        mix(\n            // @note vec3 and vec4 with normalized values are recognized as colors, \n            // so you can use a color picker to tweak the values\n            vec3(0.949, 0.561, 0.576), // rgb(242, 143, 147)\n            vec3(0.494, 0.047, 0.839), // rgb(126,  12, 214)\n            // @todo try to experiment with functions. How about bounceInOut?\n            bounceIn(lines * 0.5 + 0.5)\n        ), \n        1.\n    );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}