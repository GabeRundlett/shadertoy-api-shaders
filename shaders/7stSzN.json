{
    "Shader": {
        "info": {
            "date": "1632800610",
            "description": "This changes the \"Northern Elves\" shader drastically by switching from sin and cos to Quilez' Basic Noise. It looks like melting liquid metal, which is fun.",
            "flags": 0,
            "hasliked": 0,
            "id": "7stSzN",
            "likes": 9,
            "name": "Northern Melter",
            "published": 3,
            "tags": [
                "noise",
                "basic",
                "plasma",
                "metal",
                "melter",
                "northern"
            ],
            "usePreview": 0,
            "username": "TEttinger",
            "viewed": 680
        },
        "renderpass": [
            {
                "code": "// CC0 licensed, do what thou wilt.\n\n// change the seed to any not-too-huge float and the colors/shapes will change.\nconst float SEED = 69.42; // starts off with a \"melting face\"\nconst vec3 COEFFS = fract((SEED + 23.4567) * vec3(0.8191725133961645, 0.6710436067037893, 0.5497004779019703)) + 0.5;\nconst vec3 SECTION = fract(COEFFS.zxy - COEFFS.yzx * 1.618);\n\n// Quilez Basic Noise, from https://www.shadertoy.com/view/3sd3Rs (MIT-license)\nvec3 bas( vec3 x )\n{\n    // setup    \n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    vec3 s = sign(fract(x/2.0)-0.5);\n    \n    // use some hash to create a random value k in [0..1] from i\n    vec3 k = fract(SECTION * i + i.yzx);\n\n    // quartic polynomial\n    return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\n\n// this is different from other swayRandomized in Northern demos because it uses Quilez basic noise instead of trigonometry.\nvec3 swayRandomized(vec3 seed, vec3 value)\n{\n    return bas(seed.xyz + value.zxy - bas(seed.zxy + value.yzx) + bas(seed.yzx + value.xyz));\n}\n\n// this function, if given steadily-increasing values in con, may return exponentially-rapidly-changing results.\n// even though it should always return a vec3 with components between -1 and 1, we use it carefully.\nvec3 cosmic(vec3 c, vec3 con)\n{\n    return (con\n    + swayRandomized(c, con)\n    ) * 0.5;\n    //+ swayRandomized(c + 1.1, con.xyz)\n    //+ swayRandomized(c + 2.2, con.xyz)) * 0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//    vec2 uv = (fragCoord + cos(iTime * 0.3) * 64.0) * (2.125 + sin(iTime * 0.25));\n    vec2 uv = (fragCoord * 0.1) + swayRandomized(COEFFS.zxy, (iTime * 0.1875) * COEFFS.yzx - fragCoord.yxy * 0.004).xy * 42.0;\n    // aTime, s, and c could be uniforms in some engines.\n    float aTime = iTime * 0.0625;\n    vec3 adj = vec3(-1.11, 1.41, 1.61);\n    vec3 s = (swayRandomized(vec3(34.0, 76.0, 59.0), aTime + adj)) * 0.25;\n    vec3 c = (swayRandomized(vec3(27.0, 67.0, 45.0), aTime - adj.yzx)) * 0.25;\n    vec3 con = vec3(0.0004375, 0.0005625, 0.0008125) * aTime + c * uv.x + s * uv.y;\n    \n    con = cosmic(COEFFS, con);\n    con = cosmic(COEFFS + 1.618, con);\n    \n    fragColor = vec4(sin(con * 3.1416) * 0.5 + 0.5,1.0);\n//    fragColor = vec4(swayRandomized(COEFFS + 3.0, con) * 0.5 + 0.5,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}