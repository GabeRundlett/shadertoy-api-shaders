{
    "Shader": {
        "info": {
            "date": "1569332983",
            "description": "i love playing with glass i can't stop help",
            "flags": 0,
            "hasliked": 0,
            "id": "wdt3Dj",
            "likes": 5,
            "name": "Glass Grid",
            "published": 3,
            "tags": [
                "light",
                "glass",
                "mirror"
            ],
            "usePreview": 0,
            "username": "JuliaPoo",
            "viewed": 440
        },
        "renderpass": [
            {
                "code": "const float END = 20.;\nconst float ep = 0.01;\nconst float k = 0.03;\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat smin(float a, float b, float k){\n\tfloat f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat cube(vec3 p, float b, float r){\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) - r + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sphere(vec3 p, float r){\n \treturn length(p) - r;  \n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  \treturn dot(p,n.xyz) + n.w;\n}\n\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat light(vec3 p){\n    float ball1 = sphere(p + vec3(sin(iTime*k*3.) * 5., 0,0), 1.);\n    float ball2 = sphere(p +vec3(0, cos(iTime*k*3.) * 5., 0), 1.);\n    float ring = torus(p + vec3(0.,sin(iTime*k*3.)*5.,0.), vec2(6., .5));\n\treturn min(min(ball1, ball2), ring);\n}\n\nfloat obj(vec3 p){\n    vec3 pos = p;\n    vec3 c = vec3(6.);\n    p = mod(pos, c) - .5*c;\n    vec3 id = floor(pos/c);\n    p.xy *= rot(sin(id.x) * id.y + id.z + iTime*.3*k);\n    p.yz *= rot(sin(id.y) * id.z + id.x + iTime*.3*k);\n    p += .8*vec3(sin(id.x + iTime*k), cos(id.y + iTime*1.2*k), sin(id.z + iTime*1.7*k));\n    float cubes = cube(p, 1., 0.);\n    return cubes;\n}\n\nfloat mirror(vec3 p){\n    \n    return light(-p);\n}\n\nfloat SDscene(vec3 p){\n   \n\tfloat obj = obj(p);\n    float mirror = mirror(p);\n    float light = light(p);\n    float d = min(min(obj, mirror), light);\n    \n    return d;\n}\n\nvec3 SDnormal(vec3 p){\n    \n    //Calculates the normal vector of SDscene\n    \n    return normalize(vec3(\n    SDscene(vec3(p.x+ep,p.y,p.z))-SDscene(vec3(p.x-ep,p.y,p.z)),\n    SDscene(vec3(p.x,p.y+ep,p.z))-SDscene(vec3(p.x,p.y-ep,p.z)),\n    SDscene(vec3(p.x,p.y,p.z+ep))-SDscene(vec3(p.x,p.y,p.z-ep))\n    ));\n}\n\nfloat depth(vec3 ro, vec3 rd, float sig, inout float min_l){\n    \n    //Returns depth from ro given raydirection\n    \n    int max=300;\n    vec3 p;\n    \n    float dist=0., d;\n    for (int i=0; i<max; i++){\n        p = ro + dist*rd;\n    \td = SDscene(p)*sig;\n        if (light(p) < min_l){ min_l = light(p);}\n    if (abs(d)<ep){\n        return dist+d;\n    }\n    dist += d;\n    if (dist > END){\n        return END;\n    }\n  }\n}\n\nvoid ray_mirror(inout vec3 ro, inout vec3 rd, inout float d, inout float min_l, inout vec3 col, inout vec3 scale){\n    \n    int Nmax = 20, count = 0;\n    while (count < Nmax){\n        \n        ro += SDnormal(ro)*ep*3.;\n        rd = normalize(reflect(rd, SDnormal(ro)));\n        d = depth(ro, rd, 1., min_l);\n        ro += d*rd;\n       \n        if (abs(mirror(ro)) > ep){break;}\n        \n        count += 1;\n    }\n}\n\nvoid ray_obj(inout vec3 ro, inout vec3 rd, inout float Dglass, inout float d, inout float min_l, inout vec3 col, inout vec3 scale){\n    \n    int Nmax = 10, count = 0, count2 = 0;\n    vec3 p, rd_;\n    while (count < Nmax){\n        \n        //Go into glass\n        rd = normalize(refract(rd, SDnormal(ro), 0.6));\n        ro -= SDnormal(ro) * ep*3.;\n        d = depth(ro, rd, -1., min_l);\n        ro += rd * d;\n    \tDglass += d;\n        \n        //internal refraction\n    \trd_ = refract(rd, -SDnormal(ro), 1.5);\n       \twhile (length(rd_) < ep && count2 < Nmax){\n            \n            rd = normalize(reflect(rd, -SDnormal(ro)));\n            ro -= SDnormal(ro) * ep*3.;\n            d = depth(ro, rd, -1., min_l);\n            ro += d*rd;\n            \n            Dglass += d;\n            rd_ = refract(rd, -SDnormal(ro), 1.5);\n            count2 += 1;\n        }\n  \n        if (length(rd_) > ep){rd = normalize(rd_);}\n        ro += SDnormal(ro) * ep*3.;\n        d = depth(ro, rd, 1., min_l);\n        ro += rd * d;\n        \n        if (abs(obj(ro)) > ep){break;}\n        \n        //if (mirror(ro) > ep){ break;}\n      \t\n\t\tcount += 1;\n    }\n  \t\n    vec3 tint = vec3(exp(Dglass*-0.2),exp(Dglass*-0.05),exp(Dglass*-0.05));\n    scale *= tint;\n    Dglass = 0.;\n}\n\n\nvoid fresnel(vec3 ro, vec3 rd, inout float refl, inout float refr){\n \t   \n   \tfloat b = ((1. - 1.5)/(1. + 1.5));\n    float r0 = b*b;\n    refl = r0 + (1. - r0)*pow((1. - abs(dot(SDnormal(ro), normalize(rd)))), 5.);\n    refr = 1.-refl;\n    //refl = .5; refr = .5;\n}\n\nvec3 render(vec2 uv){\n    vec3 col;\n    \n    //Camera\n    float ScreenSize = 4.;\n    \n    float zoom = 2.5;\n    float k1 = 0.4;\n    float osc = sin(iTime*.3*k); //3.5 + 2.*osc*osc\n  \tvec3 ro = 4.*vec3(sin(k1*iTime*k), .3, cos(k1*iTime*k));\n  \tvec3 lookat = vec3(0,0,0);\n    \n    \n  \tvec3 fw = normalize(lookat - ro);\n  \tvec3 r = normalize(cross(vec3(0,1.,0), fw));\n  \tvec3 up = normalize(cross(fw,r));\n  \tvec3 scrC = ro + (zoom)*fw;\n  \tvec3 scrP = scrC + (uv.x*r + uv.y*up) * ScreenSize;\n  \tvec3 rd = normalize(scrP - ro);\n    \n    \n    vec3 ro_, rd_, scale_;\n    float refl, refr;\n    vec3 scale = vec3(1.);\n    int Nmax = 10, count;\n    float Dglass, min_l = END;\n    float d = depth(ro, rd, 1., min_l);\n    ro += d*rd;\n    while (count < Nmax){\n        //hits background\n        if (d > END - ep){\n            col += texture(iChannel0, ro).xyz * scale;\n            //col += vec3(.3)*scale;\n            col += pow(clamp(abs(1./min_l)*0.05, 0., 1.), 1.5) * scale;\n            break;\n        }\n        \n        //hit light\n        else if (abs(light(ro)) < ep){\n        \tcol += vec3(1.)*scale;\n            break;\n        }\n\n        //hit obj\n        else if (abs(obj(ro)) < ep){\n            fresnel(ro, rd, refl, refr);\n            ro_ = ro; rd_ = rd; scale_ = scale;\n            scale *= refr;\n            scale_ *= refl;\n            ray_obj(ro, rd, Dglass, d, min_l, col, scale);\n            ray_mirror(ro_, rd_, d, min_l, col, scale_);\n        }\n\n        //hit mirror\n        else if (abs(mirror(ro)) < ep){\n            ray_mirror(ro, rd, d, min_l, col, scale);\n        }\n        \n        else{d = END;}\n        \n        col += pow(clamp(abs(1./min_l)*0.05, 0., 1.), 1.5) * scale;\n        count += 1;\n    }\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \t\n    //Shader setup\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord - 0.5*R)/R.x;\n    vec3 col = render(uv);\n   \tfragColor = vec4(col,1.);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}