{
    "Shader": {
        "info": {
            "date": "1492933322",
            "description": "A basic temple model. Terrain is false perspective. No global illumination. Two sun directions. Ambient occlusion is mostly painted by hand. Bounce lighting is also painted by hand. Live coded: [url]https://www.youtube.com/watch?v=-pdSjBPH3zM[/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "ldScDh",
            "likes": 375,
            "name": "Greek Temple",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "distancefield",
                "sdf"
            ],
            "usePreview": 1,
            "username": "iq",
            "viewed": 80015
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2017 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n// You can buy a metal print of this shader here:\n// https://www.redbubble.com/i/metal-print/Greek-Temple-by-InigoQuilez/39845587.0JXQP\n\n// A basic temple model. No global illumination, all cheated and composed to camera:\n//\n// - the terrain is false perspective\n// - there are two different sun directions for foreground and background. \n// - ambient occlusion is mostly painted by hand\n// - bounce lighting is also painted by hand\n//\n// This shader was made as a continuation to a live coding session I did for the students\n// of UPENN. After the initial live coded session I decided to rework it and improve it,\n// and that turned out to be a bit of a pain because when looking for the final look I got\n// trapped in more local minima that I usually do and it took me a while to leave them. \n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tivec2 p = ivec2(fragCoord-0.5);\n    \n    vec3 col = texelFetch( iChannel0, p, 0 ).xyz;\n    \n    vec2 q = fragCoord / iResolution.xy;\n    col *= 0.8 + 0.2*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\n\n    \n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by inigo quilez - iq/2017\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n// If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n\n// A basic temple model\n//\n// - the terrain is false perspective\n// - there are two different sun directions for foreground and background. \n// - ambient occlusion is mostly painted by hand\n// - bounce lighting is also painted by hand\n//\n// This shader was made as a continuation to a live coding session I\n// did for the students of UPENN. Check it here:\n//\n// https://www.youtube.com/watch?v=-pdSjBPH3zM\n\n\n\n//#define STATICCAM\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash( uint n ) \n{\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    // floating point conversion from https://iquilezles.org/articles/sfrand\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor(p));\n    vec2  f = fract(p);\n\tf = f*f*(3.0-2.0*f);\n\tfloat a = texelFetch( iChannel1, (i+ivec2(0,0))&255, 0 ).x;\n    float b = texelFetch( iChannel1, (i+ivec2(1,0))&255, 0 ).x;\n    float c = texelFetch( iChannel1, (i+ivec2(0,1))&255, 0 ).x;\n    float d = texelFetch( iChannel1, (i+ivec2(1,1))&255, 0 ).x;\n    return mix( mix(a,b,f.x), mix(c,d,f.x), f.y );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm4( in vec3 p )\n{\n    float n = 0.0;\n    n += 1.000*noise( p*1.0 );\n    n += 0.500*noise( p*2.0 );\n    n += 0.250*noise( p*4.0 );\n    n += 0.125*noise( p*8.0 );\n    return n;\n}\n\nfloat fbm6( in vec3 p )\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 );\n    n += 0.50000*noise( p*2.0 );\n    n += 0.25000*noise( p*4.0 );\n    n += 0.12500*noise( p*8.0 );\n    n += 0.06250*noise( p*16.0 );\n    n += 0.03125*noise( p*32.0 );\n    return n;\n}\n\nfloat fbm6( in vec2 p )\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 );\n    n += 0.50000*noise( p*2.0 );\n    n += 0.25000*noise( p*4.0 );\n    n += 0.12500*noise( p*8.0 );\n    n += 0.06250*noise( p*16.0 );\n    n += 0.03125*noise( p*32.0 );\n    return n;\n}\n\nfloat fbm4( in vec2 p )\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 );\n    n += 0.50000*noise( p*2.0 );\n    n += 0.25000*noise( p*4.0 );\n    n += 0.12500*noise( p*8.0 );\n    return n;\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRhombus( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p);\n    float h = clamp( (-2.0*ndot(q,b) + ndot(b,b) )/dot(b,b), -1.0, 1.0 );\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    d *= sign( q.x*b.y + q.y*b.x - b.x*b.y );\n\treturn d - r;\n}\n\nfloat usdBox( in vec3 p, in vec3 b )\n{\n    return length( max(abs(p)-b,0.0 ) );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( float p, float b )\n{\n  return abs(p) - b;\n}\n\nfloat opRepLim( in float p, in float s, in float lima, float limb, out float id )\n{\n    id = round(p/s);\n    return p-s*clamp(id,-lima,limb);\n}\n\nvec2 opRepLim( in vec2 p, in float s, in vec2 lim )\n{\n    return p-s*clamp(round(p/s),-lim,lim);\n}\n\nvec2 opRepLim( in vec2 p, in float s, in vec2 limmin, in vec2 limmax )\n{\n    return p-s*clamp(round(p/s),-limmin,limmax);\n}\nvec2 opRepBox( in vec2 p, in float rep, in ivec2 ib )\n{\n    vec2 b = rep*vec2(ib>>1);\n    p = abs(p);\n    vec2  w = p - b;\n    bool  q = w.x > w.y;\n    float u = q ? min(p.y,b.y) : min(p.x,b.x);\n    u = round(u/rep)*rep;\n    return q ? vec2(w.x,p.y-u) : vec2(p.x-u,w.y);\n}\n\nvec4 textureGood( in sampler2D sam, in vec2 uv )\n{\n    ivec2 res = textureSize(sam,0).xy;\n    uv = uv*vec2(res) - 0.5;\n    ivec2 i = ivec2(floor(uv));\n    vec2  f = fract(uv);\n    f = f*f*(3.0-2.0*f);\n    vec4 a = texelFetch( sam, (i+ivec2(0,0))&(res-1), 0 );\n    vec4 b = texelFetch( sam, (i+ivec2(1,0))&(res-1), 0 );\n    vec4 c = texelFetch( sam, (i+ivec2(0,1))&(res-1), 0 );\n    vec4 d = texelFetch( sam, (i+ivec2(1,1))&(res-1), 0 );\n    return mix( mix(a,b,f.x), mix(c,d,f.x), f.y );\n}\n\n#define ZERO (min(iFrame,0))\n\n//------------\n\nfloat terrain( in vec2 p )\n{\n    float h = 90.0*textureGood( iChannel2, p.yx*0.0001 + 0.35 + vec2(0.02,0.05) ).x - 70.0 + 5.0;\n    h = mix( h, -7.2, 1.0-smoothstep(16.0,60.0,length(p)));\n    h -= 7.0*textureGood( iChannel2, p*0.002 ).x;\n    float d = textureLod( iChannel0, p*0.01, 0.0 ).x;\n    h -= 1.0*d*d*d;\n    return h;\n}\n\nconst float ocean = -25.0;\n\nvec3 temple( in vec3 p )\n{\n    vec3 op = p;    \n    vec3 res = vec3(-1.0,-1.0,0.5);\n\n    p.y += 2.0;\n\n    // columns\n//  vec3 q = p; q.xz = opRepLim( q.xz, 4.0, (vec2(9.0,5.0)-1.0)/2.0 );\n    vec3 q = p; q.xz = opRepBox( q.xz, 4.0, ivec2(9,5) );\n    vec2 id = floor((p.xz+2.0)/4.0);\n    float d = length(q.xz) - 0.9 + 0.05*p.y;\n    d = max(d,p.y-6.0);\n    d = max(d,-p.y-5.0);\n    d -= 0.05*pow(0.5+0.5*sin(atan(q.x,q.z)*16.0),2.0);\n    d -= 0.15*pow(0.5+0.5*sin(q.y*3.0+0.6),0.12) - 0.15;\n    res.z = hash1( id + 11.0*floor(0.25 + (q.y*3.0+0.6)/6.2831) );\n    d *= 0.85;\n    vec3 w = vec3(q.x,abs(q.y-0.3)-5.5, q.z );\n    d = min( d,  sdBox(w,vec3(1.4,0.2,1.4)+sign(q.y-0.3)*vec3(0.1,0.05,0.1))-0.1 ); // base\n//  d = max( d, -sdBox(p,vec3(14.0,10.0,6.0)) ); // clip in\n\n    // floor upper bounding plane\n    float bb1 = op.y+7.0;\n    if( bb1<d )\n    {\n    float ra = 0.15 * hash1(id+vec2(1.0,3.0));\n\tq = p; q.xz = opRepLim( q.xz, 4.0, vec2(4.0,3.0) );\n    float b = sdBox( q-vec3(0.0,-6.0+0.1-ra,0.0), vec3(2.0,0.5,2.0)-0.15-ra )-0.15;\n    b *= 0.5;\n    if( b<d ) { d = b; res.z = hash1(id); }\n    \n    p.xz -= 2.0;\n    id = floor((p.xz+2.0)/4.0);\n    ra = 0.15 * hash1(id+vec2(1.0,3.0)+23.1);\n    q = p; q.xz = opRepLim( q.xz, 4.0, vec2(5.0,4.0), vec2(5.0,3.0) );\n\tb = sdBox( q-vec3(0.0,-7.0-ra,0.0), vec3(2.0,0.6,2.0)-0.15-ra )-0.15;\n    b *= 0.8;\n    if( b<d ) { d = b; res.z = hash1( id + 13.5 ); }\n    p.xz += 2.0;\n    \n    id = floor((p.xz+2.0)/4.0);\n    ra = 0.15 * hash1(id+vec2(1.0,3.0)+37.7);\n    q = p; q.xz = opRepLim( q.xz, 4.0, vec2(5.0,4.0) );\n\tb = sdBox( q-vec3(0.0,-8.0-ra-1.0,0.0), vec3(2.0,0.6+1.0,2.0)-0.15-ra )-0.15;\n    b *= 0.5;\n    if( b<d ) { d = b; res.z = hash1( id*7.0 + 31.1 ); }\n    }\n\n\n    // roof lower bounding plane\n    float bb2 = -(op.y-4.0);\n    if( bb2<d )\n    {\n#if 0    \n    q = vec3( mod(p.x+2.0,4.0)-2.0, p.y, mod(p.z+0.0,4.0)-2.0 );\n    float b = sdBox( q-vec3(0.0,7.0,0.0), vec3(1.95,1.0,1.95)-0.15 )-0.15;\n    b = max( b, sdBox(p-vec3(0.0,7.0,0.0),vec3(18.0,1.0,10.0)) );\n    if( b<d ) { d = b; res.z = hash1( floor((p.xz+vec2(2.0,0.0))/4.0) + 31.1 ); }\n#else\n        {\n        float id1;\n        q = vec3(p.x,p.y,abs(p.z))-vec3(0.0,0.0,9.0);\n        q.x = opRepLim( q.x, 4.0, 4.0, 4.0, id1 );\n        float b = sdBox( q-vec3(0.0,7.0,0.0), vec3(1.95,1.0,0.95)-0.05 )-0.05;\n        if( b<d ) { d = b; res.z = hash1(20.0*vec2(id1*1.3,1.0)); }\n        }\n        {\n        float id1;\n        q = vec3(abs(p.x)+1.0,p.y,p.z-2.0)-vec3(17.0,0.0,0.0);\n        q.z = opRepLim( q.z, 4.0, 2.0, 1.0, id1 );\n        float b = sdBox( q-vec3(0.0,7.0,0.0), vec3(1.95,1.0,1.95)-0.05 )-0.05;\n        if( b<d ) { d = b; res.z = hash1(23.0*vec2(id1*1.7,2.1)); }\n        }\n#endif\n    q = p; q.xz = opRepLim( q.xz+0.5, 1.0, vec2(18,10),vec2(19,11) );\n    float b = sdBox( q-vec3(0.0,8.0,0.0), vec3(0.45,0.2,0.45)-0.02 )-0.02;\n    if( b<d ) { d = b; res.z = hash1( floor((p.xz+0.5)/1.0) + 7.8 ); }\n    \n    b = sdRhombus( p.yz-vec2(8.2,0.0), vec2(3.0,11.0), 0.05 ) ;\n    q = vec3( mod(p.x+1.0,2.0)-1.0, p.y, mod(p.z+1.0,2.0)-1.0 );\n    b = max( b, -sdBox( vec3( abs(p.x)-20.0,p.y,q.z)-vec3(0.0,8.0,0.0), vec3(2.0,5.0,0.1) )-0.02 );\n    \n    b = max( b, -p.y+8.2 );\n    b = max( b, usdBox(p-vec3(0.0,8.0,0.0),vec3(19.0,12.0,11.0)) );\n    float c = sdRhombus( p.yz-vec2(8.3,0.0), vec2(2.25,8.5), 0.05 );\n    c = max( c, sdBox(abs(p.x)-19.0,2.0) );\n    b = max( b, -c );    \n\n    d = min( d, b );\n    d = max( d,-sdBox(p-vec3(0.0,9.5,0.0),vec3(15.0,2.0,9.0)) );\n    }\n\n    if( d<0.1 )\n    {\n    d -= 0.02*smoothstep(0.5,1.0,fbm4( p.zxy ));\n    d -= 0.01*smoothstep(0.4,0.8,fbm4( op*3.0 ));\n    d += 0.005;\n    }\n    \n    return vec3( d, 1.0, res.z );\n}\n\nvec3 map( in vec3 p )\n{\n    vec3 res = vec3( p.y+25.0, 3.0, 0.0 );\n\n    float bb = p.y+6.0; // bounding plane for terrain\n    if( bb<res.x )\n    {\n        float h = terrain( p.xz );\n        float m = (p.y-h)*0.35;\n        if( m<res.x ) res=vec3( m, 2.0, 0.0 );\n    }\n\n    bb = usdBox(p-vec3(0.0,-1.0,0.0),vec3(22.0,11.0,20.0) ); // bounding box for temple\n    if( bb<res.x )\n    {\n        vec3 tmp = temple(p);\n        if( tmp.x<res.x ) res=tmp;\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p, in float t )\n{\n#if 0    \n    float e = 0.001*t;\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n#else    \n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.001*t).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    vec2 ma = vec2(0.0);\n\n    vec3 res = vec3(-1.0);\n    \n    float tmax = 1000.0;\n\n    // bottom bounding plane\n    {\n    float tp = (ocean-ro.y)/rd.y;\n    if( tp>0.0 ) { tmax = tp; res = vec3( tp, 3.0, 0.0 ); }\n    }\n    // top bounding plane\n    {\n    float tp = (10.0-ro.y)/rd.y;\n    if( tp>0.0 ) { tmax = tp;  }\n    }\n        \n    float t = 10.0;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 h = map( pos );\n        ma = h.yz;\n        if( h.x<(0.0001*t) || t>tmax ) break;\n        t += h.x;\n    }\n\n    if( t<tmax )\n    {\n    \tres = vec3(t, ma);\n    }\n\n    return res;\n}\n\nvec4 textureBox( in sampler2D tex, in vec3 pos, in vec3 nor )\n{\n    vec4 cx = texture( tex, pos.yz );\n    vec4 cy = texture( tex, pos.xz );\n    vec4 cz = texture( tex, pos.xy );\n    vec3 m = nor*nor;\n    return (cx*m.x + cy*m.y + cz*m.z)/(m.x+m.y+m.z);\n}\n\nfloat calcShadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n\n    float t = 0.01;\n    for( int i=0; i<128; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map( pos ).x;\n        res = min( res, k*max(h,0.0)/t );\n        if( res<0.0001 || pos.y>10.0) break;\n        t += clamp(h,0.01,5.0);\n    }\n\n    return res;\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float ra )\n{\n    float occ = 0.0;\n    for( int i=ZERO; i<32; i++ )\n    {\n        float h = 0.01 + 4.0*pow(float(i)/31.0,2.0);\n        vec2 an = hash2( ra + float(i)*13.1 )*vec2( 3.14159, 6.2831 );\n        vec3 dir = vec3( sin(an.x)*sin(an.y), sin(an.x)*cos(an.y), cos(an.x) );\n        dir *= sign( dot(dir,nor) );\n        occ += clamp( 5.0*map( pos + h*dir ).x/h, -1.0, 1.0);\n    }\n    return clamp( occ/32.0, 0.0, 1.0 );\n}\n\nconst vec3 sunLig = normalize(vec3(0.7,0.1,0.4));\n\nvec3 skyColor( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.3,0.4,0.5)*0.3 - 0.3*rd.y;\n\n    float t = (1000.0-ro.y)/rd.y;\n    if( t>0.0 )\n    {\n        vec2 uv = (ro+t*rd).xz;\n        float cl = texture( iChannel0, .000003*uv.yx ).x;\n        cl = smoothstep(0.3,0.7,cl);\n        col = mix( col, vec3(0.3,0.2,0.1), 0.1*cl );\n    }\n    \n    col = mix( col, vec3(0.2,0.25,0.30)*0.5, exp(-30.0*rd.y) ) ;\n    \n    float sd = pow( clamp( 0.25 + 0.75*dot(sunLig,rd), 0.0, 1.0 ), 4.0 );\n    col = mix( col, vec3(1.2,0.30,0.05)/1.2, sd*exp(-abs((60.0-50.0*sd)*rd.y)) ) ;\n    \n    return col;\n}\n\nvec3 doBumpMap( in vec3 pos, in vec3 nor )\n{\n    float e = 0.002;\n    float b = 0.015;\n    \n\tfloat ref = fbm6( 4.0*pos );\n    vec3 gra = -b*vec3( fbm6(4.0*vec3(pos.x+e, pos.y, pos.z))-ref,\n                        fbm6(4.0*vec3(pos.x, pos.y+e, pos.z))-ref,\n                        fbm6(4.0*vec3(pos.x, pos.y, pos.z+e))-ref )/e;\n\t\n\tvec3 tgrad = gra - nor * dot ( nor , gra );\n    return normalize( nor - tgrad );\n}\n\nvec3 doBumpMapGrass( in vec2 pos, in vec3 nor, out float hei )\n{\n    const float e = 0.002;\n    const float b = 0.03;\n    \n\tfloat ref = fbm6( 4.0*pos );\n    hei = ref;\n    \n    vec3 gra = -b*vec3( fbm6(4.0*vec2(pos.x+e, pos.y))-ref,\n                        e,\n                        fbm6(4.0*vec2(pos.x, pos.y+e))-ref )/e;\n\t\n\tvec3 tgrad = gra - nor*dot( nor, gra );\n    return normalize( nor - tgrad );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float isThumbnail = step(iResolution.x,499.0);\n    \n    vec2 o = (1.0-isThumbnail)*(hash2( float(iFrame) ) - 0.5);\n    \n\tvec2 p = (-iResolution.xy + 2.0*(fragCoord+o)) / iResolution.y;\n    \n    uvec2 px = uvec2(fragCoord);\n    float ran = hash( px.x + 1920U*px.y + (1920U*1080U)*uint(iFrame*0) );    \n    \n    #ifdef STATICCAM\n    float an = -0.96;\n    #else\n    float an = -0.96 + sin(iTime*0.05)*0.1;\n    #endif\n    float ra = 70.0;\n    float fl = 3.0;\n    vec3 ta = vec3(0.0,-3.0,-23.0);\n    vec3 ro = ta + vec3(ra*sin(an),10.0,ra*cos(an));\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,fl));\n    \n    \n    vec3 col = skyColor( ro, rd );\n    \n    float resT = 10000.0;\n    vec3 res = intersect( ro, rd );\n    if( res.y>0.0 )\n    {\n        float t = res.x;\n        resT = t;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n        \n        float fre = pow( clamp( 1.0+dot(nor,rd), 0.0, 1.0), 5.0 );\n\t\tfloat foc = 1.0;\n        \n        vec3 mate = vec3(0.2);\n        vec2 mspe = vec2(0.0);\n        float mbou = 0.0;\n        float mter = 0.0;\n        if( res.y<1.5 )\n        {\n            vec3 te = textureBox( iChannel0, pos*0.05, nor ).xyz;\n            mate = vec3(0.14,0.10,0.07) + 0.1*te;\n            mate *= 0.8 + 0.4*res.z;\n            mate *= 1.15;            \n            mspe = vec2(1.0,8.0);\n            mbou = 1.0;\n\n            nor = doBumpMap( pos, nor );\n            \n            foc = 0.7 + 0.3*smoothstep(0.4,0.7,fbm4( 3.0*pos ));\n\n            float ho = 1.0;\n            if( pos.y>-7.5 ) ho *= smoothstep( 0.0, 5.0, (pos.y+7.5)  );\n            ho = mix( 0.1+ho*0.3, 1.0, clamp( 0.6 + 0.4*dot( normalize(nor.xz*vec2(0.5,1.0)), normalize(pos.xz*vec2(0.5,1.0)) ) + 1.0*nor.y*nor.y, 0.0, 1.0 ) );\n            foc *= ho;\n            foc *= 0.4 + 0.6*smoothstep( 2.0, 15.0, length(pos*vec3(0.5,0.25,1.0)) );\n            float rdis = clamp( -0.15*max(sdRhombus( pos.yz-vec2(8.3,0.0)+vec2(2.0,0.0), vec2(2.25,8.5), 0.05 ),-(pos.y-8.3+2.0)), 0.0, 1.0 );\n            if( rdis>0.0001 ) foc = 0.1 + sqrt(rdis);\n\t\t\tif( pos.y<5.8 ) foc *= 0.6 + 0.4*smoothstep( 0.0, 1.5, -(pos.y-5.8) );\n            if( pos.y<3.4 ) foc *= 0.6 + 0.4*smoothstep( 0.0, 2.5, -(pos.y-3.4)  );\n\n            foc *= 0.8;            \n        }\n        else if( res.y<2.5 )\n        {\n            mate = vec3(0.95,0.9,0.85) * 0.4*texture( iChannel0, pos.xz*0.015 ).xyz;\n            mate *= 0.25 + 0.75*smoothstep( -25.0, -24.0, pos.y );\n            mate *= 0.32;            \n\t\t\tfloat h;\n            vec3 mor = doBumpMapGrass( pos.xz, nor, h );\n            mspe = vec2(2.5,4.0);\n            float is_grass = smoothstep( 0.9,0.95,mor.y);\n            \n            mate = mix( mate, vec3(0.15,0.1,0.0)*0.8*0.7 + h*h*h*vec3(0.12,0.1,0.05)*0.15, is_grass );\n            mspe = mix( mspe, vec2(0.5,4.0), is_grass );\n            nor = mor;\n            mter = 1.0;\n        }\n\t\telse\n        {\n            mate = vec3(0.1,0.21,0.25)*0.45;\n            mate += 2.0*vec3(0.01,0.03,0.03)*(1.0-smoothstep(0.0,10.0,pos.y-terrain(pos.xz)));\n            mate *= 0.4;            \n            float foam = (1.0-smoothstep(0.0,1.0,pos.y-terrain(pos.xz)));\n            foam *= smoothstep( 0.35,0.5,texture(iChannel0,pos.xz*0.07).x );\n            mate += vec3(0.08)*foam;\n            mspe = vec2(0.5,8.0);\n\n            vec2 e = vec2(0.01,0.0);\n            float ho = fbm4( (pos.xz     )*vec2(2.0,0.5) );\n            float hx = fbm4( (pos.xz+e.xy)*vec2(2.0,0.5) );\n            float hy = fbm4( (pos.xz+e.yx)*vec2(2.0,0.5) );\n            float sm = (1.0-smoothstep(0.0,4.0,pos.y-terrain(pos.xz)));\n            sm *= 0.02 + 0.03*foam;\n            ho *= sm;\n            hx *= sm;\n            hy *= sm;\n                \n            nor = normalize( vec3(ho-hx,e.x,ho-hy) );\n        }\n\n        float occ = 0.33 + 0.5*nor.y;\n        occ = calcOcclusion(pos,nor,ran) * foc;\n        \n        float lf = 1.0 - smoothstep( 30.0,80.0,length(pos.z));\n        vec3 lig = normalize( vec3(sunLig.x,sunLig.y+0.245*lf,sunLig.z) );\n        vec3 ligbak = normalize(vec3(-lig.x,0.0,-lig.z));\n        float dif = dot( nor, lig );\n        float sha = 1.0; if( dif>0.0 ) sha=calcShadow( pos+nor*0.001, lig, 32.0 );\n              dif = clamp(dif*sha,0.0,1.0);\n        float amb = (0.8 + 0.2*nor.y);\n              amb = mix( amb, amb*(0.5+0.5*smoothstep( -8.0,-1.0,pos.y)), mbou );\n\n        vec3 qos = pos/1.5 - vec3(0.0,1.0,0.0);\n\n        float bak = clamp( 0.4+0.6*dot( nor, ligbak ), 0.0, 1.0 );\n              bak *= 0.6 + 0.4*smoothstep( -8.0,-1.0,qos.y);\n        \n        float bou = 0.3*clamp( 0.7-0.3*nor.y, 0.0, 1.0 );\n              bou *= smoothstep( 8.0,0.0,qos.y+6.0)*smoothstep(-6.7,-6.4,qos.y);\n              bou *= (0.7*smoothstep( 3.0,1.0,length( (qos.xz-vec2(1.0,6.0))*vec2(0.2,1.0)) )+\n                          smoothstep( 5.0,1.0,length( (qos.xz-vec2(5.0,-3.0))*vec2(0.4,1.0)) ));\n              bou +=  0.1*smoothstep( 5.0,1.0,length( (qos-vec3(-5.0,0.0,-5.0))*vec3(0.7,0.8,1.5)) );\n        \n        vec3 hal = normalize( lig -rd );\n        float spe = pow( clamp( dot(nor,hal), 0.0, 1.0), mspe.y )*(0.1+0.9*fre)*sha*(0.5+0.5*occ);\n\n        col = vec3(0.0);\n        col += amb*1.0*vec3(0.15,0.25,0.35)*occ*(1.0+mter);\n        col += dif*5.0*vec3(0.90,0.55,0.35);\n        col += bak*1.7*vec3(0.10,0.11,0.12)*occ*mbou;\n        col += bou*3.0*vec3(1.00,0.50,0.15)*occ*mbou;\n        col += spe*6.0*mspe.x*occ;\n        \n        col *= mate;\n\n        vec3 fogcol = vec3(0.1,0.125,0.15);\n        float sd = pow( clamp( 0.25 + 0.75*dot(lig,rd), 0.0, 1.0 ), 4.0 );\n\t    fogcol = mix( fogcol, vec3(1.0,0.25,0.042), sd*exp(-abs((60.0-50.0*sd)*abs(rd.y))) ) ;\n\n        float fog = 1.0 - exp(-0.0013*t);\n        col *= 1.0-0.5*fog;\n        col = mix( col, fogcol, fog );\n    }\n\n    col = max( col, 0.0 );\n    \n    col += 0.15*vec3(1.0,0.8,0.7)*pow( clamp( dot(rd,sunLig), 0.0, 1.0 ), 6.0 );\n\n    col = 1.2*col/(1.0+col);\n    \n    col = sqrt( col );\n\n    col = clamp( 1.9*col-0.1, 0.0, 1.0 );\n    col = col*0.1 + 0.9*col*col*(3.0-2.0*col);\n    col = pow( col, vec3(0.76,0.98,1.0) );    \n    \n    //------------------------------------------\n\t// reproject from previous frame and average\n    //------------------------------------------\n\t#ifdef STATICCAM\n        vec3 ocol = texelFetch( iChannel3, ivec2(fragCoord-0.5), 0 ).xyz;\n        if( iFrame==0 ) ocol = col;\n        col = mix( ocol, col, 0.05 );\n        fragColor = vec4( col, 1.0 );\n    #else\n        mat4 oldCam = mat4( texelFetch(iChannel3,ivec2(0,0),0),\n                            texelFetch(iChannel3,ivec2(1,0),0),\n                            texelFetch(iChannel3,ivec2(2,0),0),\n                            0.0, 0.0, 0.0, 1.0 );\n\n        // world space\n        vec4 wpos = vec4(ro + rd*resT,1.0);\n        // camera space\n        vec3 cpos = (wpos*oldCam).xyz; // note inverse multiply\n        // ndc space\n        vec2 npos = fl * cpos.xy / cpos.z;\n        // screen space\n        vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y/iResolution.x,1.0);\n        // undo dither\n        spos -= o/iResolution.xy;\n        // raster space\n        vec2 rpos = spos * iResolution.xy;\n\n        if( (rpos.y<1.0 && rpos.x<3.0) || (isThumbnail>0.5)  )\n        {\n        }\n        else\n        {\n            vec4 data = textureLod( iChannel3, spos, 0.0 );\n            vec3 ocol = data.xyz;\n            float dt = abs(data.w - resT)/resT;\n            if( iFrame==0 ) ocol = col;\n            col = mix( ocol, col, 0.1 + 0.5*smoothstep(0.1,0.2,dt) );\n        }\n\n        if( fragCoord.y<1.0 && fragCoord.x<3.0 )\n        {\n            if( abs(fragCoord.x-2.5)<0.5 ) fragColor = vec4( ca[2], -dot(ca[2],ro) );\n            if( abs(fragCoord.x-1.5)<0.5 ) fragColor = vec4( ca[1], -dot(ca[1],ro) );\n            if( abs(fragCoord.x-0.5)<0.5 ) fragColor = vec4( ca[0], -dot(ca[0],ro) );\n        }\n        else\n        {\n            fragColor = vec4( col, resT );\n        }\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}