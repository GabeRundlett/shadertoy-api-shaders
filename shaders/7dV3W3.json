{
    "Shader": {
        "info": {
            "date": "1632343202",
            "description": "A simple shader with mostly PBR lighting. ",
            "flags": 0,
            "hasliked": 0,
            "id": "7dV3W3",
            "likes": 9,
            "name": "Lava Lamp :)",
            "published": 3,
            "tags": [
                "raymarching",
                "pbr"
            ],
            "usePreview": 0,
            "username": "SpencerKuan",
            "viewed": 277
        },
        "renderpass": [
            {
                "code": "/*\n\n\nI originally created this on Khan Academy :)\n\n\n\n*/\n\n\n\n\nprecision lowp float;\nconst vec2 u_res = vec2(1280, 720);\n\n/* uncomment for anti-aliasing: */\n//#define MULTIPASS; \n\n#define pi 3.1415926\n\n//point-light source structure\nstruct Light {\n    vec3 o;\n    vec3 col;\n};\n\n//light ray structure\nstruct lightR {\n    vec3 col;\n    vec3 dir;\n};\n\n//material structure\nstruct material {\n    vec3 albedo;\n    float rough;\n    float metal;\n};\n\n//lights array\nLight lights[4];\n\n//sdBox, sdCone, and smin by Inigo Quilez\nfloat sdBox( vec3 p, vec3 b ) \n{ \n    vec3 q = abs(p) - b; \n    return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0); \n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat sdCone(vec3 p, vec2 c, float h)\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n\n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat blob(vec3 p, vec4 i, float t)\n{\n    float h = sin(t + i.z) * 30.0;\n    float s = clamp((h + 50.0) / 50.0, 0.5, 1.0);\n    return length(p + vec3(i.x, h, i.y)) - i.w * s;\n}\n\n/*float Bblob(vec3 p, vec4 i, float t)\n{\n    float h = sin(t + i.z) * 150.0;\n    return length(p + vec3(i.x, h - 20.0, i.y)) - i.w;\n}*/\n\n\n//transparent signed dist func\nfloat tsdf(vec3 p)\n{\n    float shape = max(sdCone(p+vec3(0,-180,0),vec2(sin(.09),cos(.09)),188.0), p.y - 70.0);\n\n    float d = max(shape, p.y - 49.3);\n\n    return d;\n}\n\n\n//main signed dist function\nfloat sdf(vec3 p)\n{\n\n    //time\n    float t = iTime * 0.2;\n\n    //floor\n    float d = p.y + 80.0;\n\n    //pedestal\n    d = min(d, sdBox(p+vec3(0,70,0),vec3(40,10,40)));\n\n    //walls\n    d = min(d, -sdBox(p, vec3(200)));\n\n    //translated blob position\n    vec3 mp = p + vec3(0, -20, 0);\n\n    //lamp components\n    float top = max(sdCone(p+vec3(0,-90,0),vec2(sin(.3),cos(.3)),40.), p.y - 70.0);\n    float bottom = max(sdCone(-p+vec3(0,-49,0),vec2(sin(.4),cos(.4)),40.), -p.y - 50.);\n    float base = sdCone(p+vec3(0,20,0),vec2(sin(.4),cos(.4)),40.);\n\n    //adding the lamp pieces\n    d = min(d, top);\n    d = min(d, bottom);\n    d = min(d, base);\n\n    //lava blobs\n    float b = d;\n\n    b = smin(b, blob(mp, vec4(-6,5,1,5), t), 10.);\n    b = smin(b, blob(mp, vec4(-3,0,2.3,5), t), 10.);\n    b = smin(b, blob(mp, vec4(0,8,3,2), t), 10.);\n    b = smin(b, blob(mp, vec4(0,7,4,2), t), 10.);\n    b = smin(b, blob(mp, vec4(-8,-4,5,3), t), 10.);\n    b = smin(b, blob(mp, vec4(7,0,6,3), t), 10.);\n    b = smin(b, blob(mp, vec4(2,2,7,4), t), 10.);\n\n    //constrain blobs to the container\n    float container = tsdf(vec3(p.xz, clamp(p.y, -3.0, 44.0)).xzy);\n    b = max(b, container + 2.0);\n    b = max(b, p.y - 50.0);\n    b = max(b, -p.y - 10.0);\n\n    d = min(d, b);\n\n    return d;\n}\n\nmaterial getMaterial(vec3 p)\n{\n\n    //walls\n    if(max(abs(p.x), abs(p.z)) > 199.0){\n        return material(\n            vec3(1),\n            0.1,\n            0.0\n        );\n    }\n\n    if(max(abs(p.x), abs(p.z)) < 50.0)\n    {\n        //blob stuff\n        if( p.y > -11.0 && p.y < 49.9 && length(p.xz) < 16.0)\n        {\n            return material(\n                vec3(0.4, 0.1, 0.4),\n                0.1,\n                0.0\n            );\n        }\n\n        //shiny lamp metal\n        if( p.y > -59.5 && p.y < 80.0)\n        {\n            return material(\n                vec3(0.2),\n                0.2,\n                1.0\n            );\n        }\n    }\n\n    return material(\n        vec3(0.1, 0.4, 0.5),\n        1.0,\n        0.0\n    );\n\n}\n\n//normal calculation\nvec3 getNormal(vec3 pos)\n{\n\n    //epsilon value\n    float h = 0.1;\n\n    float dist1 = sdf(pos);\n    return normalize(vec3(\n        sdf(pos + vec3(h, 0, 0)) - dist1,\n        sdf(pos + vec3(0, h, 0)) - dist1,\n        sdf(pos + vec3(0, 0, h)) - dist1\n    ));\n}\n\n//glass normal calculation\nvec3 getGlassNormal(vec3 pos)\n{\n\n    //epsilon value\n    float h = 0.1;\n\n    float dist1 = tsdf(pos);\n    return normalize(vec3(\n        tsdf(pos + vec3(h, 0, 0)) - dist1,\n        tsdf(pos + vec3(0, h, 0)) - dist1,\n        tsdf(pos + vec3(0, 0, h)) - dist1\n    ));\n}\n\n//create a ray for a given screen position\nvec3 createRay(vec2 pos)\n{\n    return normalize(vec3(pos, 200.0));\n}\n\n//raymarching loop\nfloat raymarch(vec3 ro, vec3 rd, out bool hit)\n{\n    const int MAX_STEPS = 70;\n    const float epsilon = 0.5;\n\n    hit = false;\n    float totalDist = 0.0;\n    for(int i = 0; i < MAX_STEPS; i ++){\n        float d = sdf(ro + rd * totalDist);\n        if(abs(d) < epsilon){\n            hit = true;\n            break;\n        }\n        totalDist += d;\n    }\n    return totalDist;\n}\n\nfloat glassmarch(vec3 ro, vec3 rd, out bool hit)\n{\n    const int MAX_STEPS = 20;\n    const float epsilon = 0.5;\n\n    hit = false;\n    float totalDist = 0.0;\n    for(int i = 0; i < MAX_STEPS; i ++){\n        float d = tsdf(ro + rd * totalDist);\n        if(abs(d) < epsilon){\n            hit = true;\n            break;\n        }\n        totalDist += d;\n    }\n    return totalDist;\n}\n\nfloat shadowmarch(vec3 rc, vec3 ld, float md)\n{\n    const int MAX_STEPS = 50;\n    const float step = 0.1;\n\n    float t = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++){\n        float s = sdf(rc + ld * t);\n        if(t > md) return 1.0;\n        if(s < 0.0) return 0.0;\n        t += max(step, s);\n    }\n\n    return 1.0;\n}\n\n//normal distribution function\nfloat NDF(vec3 h, vec3 n, float a)\n{\n    float a2 = a * a;\n    float dotHN = dot(h, n);\n    float x = dotHN * dotHN * (a2 - 1.0) + 1.0;\n\n    return a2 / (pi * x * x);\n}\n\n//geometry function\nfloat GF(vec3 v, vec3 n, float a)\n{\n    float dotNV = max(dot(n, -v), 0.0);\n    float a2 = a * a;\n    float k = (a + 1.0) * (a + 1.0) / 8.0;\n\n    return dotNV / (dotNV * (1.0 - k) + k);\n}\n\n//fresnel function\nvec3 FF(vec3 v, vec3 n, vec3 f0)\n{\n    float x = clamp(1.0 - dot(v, n), 0.0, 1.0);\n    return f0 + (1.0 - f0) * pow(x, 5.0);\n}\n\n//calculate contribution of individual light\nvec3 calcLight (material c, vec3 n, vec3 rd, lightR lr)\n{\n\n    vec3 dir = lr.dir;\n    vec3 l = lr.col;\n\n    //material values\n    vec3 a = c.albedo;\n    float rough = c.rough;\n    float metal = c.metal;\n\n    //halfway vector\n    vec3 h = normalize(rd + dir);\n\n    vec3 f0 = mix(vec3(0.01), a, metal);\n\n    //normal distribution\n    float nd = NDF(dir, n, rough);\n\n    //geometry occulsion\n    float g = GF(dir, n, rough)*GF(rd, n, rough);\n\n    //fresnel\n    vec3 f = FF(-rd, n, f0);\n\n    //some dot products\n    float dotDN = max(dot(-dir, n), 0.0);\n    float dotRN = max(dot(-rd, n), 0.0);\n\n    //specular denominator\n    float specDenom = 2.0 * dotDN * dotRN + .0001;\n    vec3 spec = g * nd * f / specDenom;\n\n    //diffuse contribution\n    vec3 kd = (vec3(1) - f) * (1.0 - metal);\n\n    vec3 fin = ((kd * a / pi) + spec) * l * dotDN;\n    return fin;\n}\n\n//calculate contribution of all lights\nvec3 doLighting(material c, vec3 n, vec3 rc, vec3 rd, bool doShadow)\n{\n    vec3 fCol = vec3(0.0);\n\n    const int len = 4;\n    for(int i = 0; i < 4; i++)\n    {\n        //get the light\n        Light light = lights[i];\n\n        //find light ray direction\n        vec3 dir = normalize(rc - light.o);\n\n        //light radius\n        float r = length(rc - light.o);\n\n        //light brightness (attenuation)\n        float b = 1.0 / r;\n\n        //resulting light ray color\n        vec3 l = light.col * b;\n\n        //light ray\n        lightR lr = lightR(l, dir);\n\n        //shadows\n        float s = doShadow ? shadowmarch(rc, -dir, r) : 1.0;\n\n        //final light contribution\n        vec3 fin = calcLight(c, n, rd, lr) * s;\n\n        fCol += fin;\n    }\n\n    //ambient light\n    fCol += c.albedo * (1.0 - c.metal) * 0.1;\n\n\n    //global directional lighting \n    //const vec3 sCol = vec3(0.1);\n    //const vec3 sDir = normalize(vec3(1, -5, 0));\n    //float s = shadowmarch(rc, -sDir);\n    //fCol += calcLight(c, n, rd, lightR(sCol, sDir))*s;\n\n    //fog\n    float fog = exp(-length(rc) * 0.01);\n\n    return fCol * fog;\n}\n\n//create a matrix\nmat3 yMat(float a){\n    return mat3(cos(a), 0, sin(a), 0, 1, 0, -sin(a), 0, cos(a));\n}\n\nmat3 xMat(float a){\n    return mat3(1, 0, 0, 0, cos(a), -sin(a), 0, sin(a), cos(a));\n}\n\nvec4 shadeP (float t, vec3 cam, mat3 rot, vec2 unit)\n{\n    //ray initial values\n    vec3 ro = rot * cam;\n    vec3 rd = rot * createRay(unit);\n\n    //raymarch the ray\n    bool hit;\n    float d = raymarch(ro, rd, hit);\n\n\n    //fragment color\n    vec3 col = vec3(0);\n\n    if(!hit){\n        return vec4(col, 1);\n    }\n\n    //find ray collision\n    vec3 rc = ro + rd * d;\n\n    //find collision normal\n    vec3 normal = getNormal(rc);\n\n    //find material\n    material c = getMaterial(rc);\n\n    //raymarch the glass\n    bool glass;\n\n    const material glassMat = material(vec3(1), 0.4, 1.0);\n    const vec3 glassTint = vec3(2, 1, 2);\n\n    float gd = glassmarch(ro, rd, glass);\n    vec3 gc = gd * rd + ro;\n    bool glassVis = gd < d || !hit;\n\n    //shade material\n    col = doLighting(c, normal, rc, rd, true);\n\n    //glass shading\n    if(glass && glassVis)\n    {\n        col *= glassTint;\n        col += doLighting(glassMat, getGlassNormal(gc), gc, rd, false) * 0.1;\n\n\n    }\n\n    //cheap HDR\n    col = col / (col + 1.0);\n\n    //gamma correction\n    col = pow(col, vec3(1.0 / 2.2));\n\n    return vec4(col, 1);\n}       \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //set the light positions\n    lights[0] = Light(\n        vec3(80, 10, 100), vec3(200, 100, 100)\n    );\n\n    lights[1] = Light(\n        vec3(120, 80, -130), vec3(250, 250, 500)\n    );\n\n    lights[2] = Light(\n        vec3(-50, 120, 120), vec3(300)\n    );\n\n    lights[3] = Light(\n        vec3(-90, 110, -80), vec3(100, 200, 100)\n    );\n\n    //time increment\n    float t = mod(iTime * 0.4, 2.0 * pi);\n\n    //create rotation matrix\n    mat3 rot = yMat(t) * xMat(sin(t)*.1-0.4);\n\n    //find the screen scale\n    float scale = 2.0 / min(iResolution.x, iResolution.y);\n\n    //create clip-space-ish coordinates\n    vec2 clip = (fragCoord.xy - iResolution.xy / 2.0)*scale;\n\n    //translate clip space into unit space\n    vec2 unit = clip * 100.0;\n\n    //camera position\n    const vec3 cam = vec3(10, -10, -199);\n\n\n    # ifdef MULTIPASS\n        fragColor = (\n            shadeP(t, cam, rot, unit) + \n            shadeP(t, cam, rot, unit + vec2(0.25))\n        ) * 0.5;\n\n    # else\n        fragColor = shadeP(t, cam, rot, unit);\n\n    # endif\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}