{
    "Shader": {
        "info": {
            "date": "1479349369",
            "description": "Made the aphex twin logo using distance fields, then trying to come up with a visualizer for it. Use the mouse to look around.",
            "flags": 96,
            "hasliked": 0,
            "id": "ltdSW8",
            "likes": 19,
            "name": "Aphex Twin Logo",
            "published": 3,
            "tags": [
                "2d",
                "3d",
                "sound",
                "reactive",
                "music",
                "mirror",
                "glossy",
                "afx",
                "aphex"
            ],
            "usePreview": 0,
            "username": "Klems",
            "viewed": 1300
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 p = fragCoord / iResolution.xy * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    \n    float scale = dot(p, p)+1.0;\n    \n    float tempo = texture(iChannel0, vec2(0.0)).a;\n    \n    float r = texture(iChannel0, (fragCoord - p*scale*2.0*tempo - 2.0) / iResolution.xy).r;\n    float g = texture(iChannel0, (fragCoord - p*scale*4.0*tempo - 4.0) / iResolution.xy).g;\n    float b = texture(iChannel0, (fragCoord - p*scale*6.0*tempo - 6.0) / iResolution.xy).b;\n    \n    fragColor.rgba = vec4(r, g, b, 1);\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// music url: https://soundcloud.com/warp-records/aphex-twin-minipops-67-1202source-field-mix\n\n#define PI 3.14159265359\n\n// thanks fabrice\nmat2 rot(float a) {\n    vec2 v = sin(vec2(PI*0.5, 0) + a);\n    return mat2( v, -v.y, v.x );\n}\n\n// thanks iq\nfloat smin(float a, float b , float s) { \n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\nfloat smax(float a, float b, float s) {\n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\nfloat caps(vec2 p, vec2 a, vec2 b, float aRadius) {\n    vec2 bma = b-a;\n    vec2 pma = p-a;\n    vec2 pmb = p-b;\n    \n    float len = length(bma);\n    vec2 xDir = bma / len;\n    vec2 yDir = vec2(-xDir.y, xDir.x);\n    \n    vec2 uv = vec2(dot(pmb, xDir), abs(dot(pmb, yDir)));\n    \n    float theta = asin(aRadius/len);\n    uv *= rot(-theta);\n    float dist = sqrt(max(0.0, len*len - aRadius*aRadius));\n    \n    if ( uv.x < -dist) {\n        return length(pma)-aRadius;\n    } else if ( uv.x < 0.0 ) {\n        return uv.y;\n    } else {\n        return length(pmb);\n    }\n}\n\nfloat caps(vec2 p, vec2 a, vec2 b, float aRadius, float bRadius) {\n    return caps(p, a, b, aRadius-bRadius)-bRadius;\n}\n\nfloat afx(vec2 p) {\n    #define SCALE 215.0\n    p *= SCALE;\n    \n    float ring = length(p);\n    ring = abs(ring-202.0)-12.0;\n    \n    p.y *= -1.0;\n    p += vec2(250.0);\n    float top = caps(p, vec2(127, 167), vec2(290, 167), 28.0, 28.0);\n    float recess1 = caps(p, vec2(216, 177), vec2(174, 233), 10.0, 20.0);\n    top = smax(top, -recess1, 10.0);\n    \n    float right = caps(p, vec2(372, 347), vec2(285, 175), 16.0, 36.0);\n    float left = caps(p, vec2(165, 318), vec2(261, 161), 13.0, 22.0);\n    float recess2 = caps(p, vec2(225, 246), vec2(285, 230), 20.0, 40.0);\n    float recess3 = caps(p, vec2(260, 230), vec2(321, 406), 15.0, 60.0);\n    \n    float bott = smin(left, recess2, 10.0);\n    bott = smax(bott, -recess3, 20.0);\n    bott = min(bott, right);\n    \n    float de = min(top, bott);\n    de = min(de, ring);\n    \n    return de / SCALE;\n}\n\n// above is AFX logo distance field, feel free to use it in your own (hopefully musical) shader\n// below is rendering\n\n// most played note, between [0, 1] and in Hz\nfloat bestNoteFrac = 0.0;\n// move the logo\nfloat tempo = 0.0;\n\n// thanks Dave_Hoskins\nvec3 hash33(vec3 p3) {\n    #define HASHSCALE3 vec3(.1031, .1030, .0973)\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n// thanks fabrice\nfloat message(vec2 uv) {\n    uv-=vec2(1.,10.); if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  928473456/bit;\n    if (int(uv.y)==1) i=  626348112/bit;\n    if (int(uv.y)==0) i= 1735745872/bit;\n \treturn float(i-2*(i/2));\n}\n\nfloat tracePlane( in vec4 pl, in vec3 ro, in vec3 rd ) {\n    return -(dot(pl.xyz,ro)+pl.w)/dot(pl.xyz,rd);\n}\n\nbool traceWall( in vec3 from, in vec3 dir, inout float dist, inout vec3 norm ) {\n    vec3 wallNorm = vec3(0, -1, 0);\n    float distWall = tracePlane( vec4(wallNorm, 0), from, dir );\n    if (distWall > 0.0) {\n        dist = distWall;\n        norm = wallNorm;\n        return true;\n    }\n    return false;\n}\n\nbool traceGround( in vec3 from, in vec3 dir, inout float dist, inout vec3 norm ) {\n    vec3 groundNorm = vec3(0, 0, 1);\n    float distGround = tracePlane( vec4(groundNorm, 0), from, dir );\n    if (distGround > 0.0) {\n        dist = distGround;\n        norm = groundNorm;\n        return true;\n    }\n    return false;\n}\n\nvec3 light(vec3 p, vec3 norm, vec3 diffuse) {\n    \n    const vec3 afxPos = vec3(0, 0, 3);\n    \n    // add a spotlight pointing toward the logo\n    vec3 spotPos = vec3( (bestNoteFrac-0.5)*16.0, -1.5, 8);\n    spotPos.z -= spotPos.x*spotPos.x*0.07;\n    \n    vec3 spotDir = normalize(afxPos - spotPos);\n\n    vec3 pms = p - spotPos;\n    float pmsSq = dot(pms, pms);\n    vec3 dirToLight = pms / sqrt(pmsSq);\n    float l = 15000.0 / pmsSq;\n    l *= max(0.0, dot(norm, -dirToLight));\n    float spot = max(0.0, dot(dirToLight, spotDir));\n    spot = pow(spot, 32.0);\n    l *= spot;\n    \n    // add ao\n    float ao = 0.5 + 0.5 * (1.0 - pow(2.0, -length(p.yz)));\n    \n    return diffuse*l + diffuse*ao;\n}\n\nvoid bars(float p, out vec3 diffuse, out vec3 surfaceLight) {\n    #define BPM 120.2\n    p += iTime*0.2;\n    p *= 0.8;\n    float inUV = fract(p)-0.5;\n    float x = floor(p) - floor(iTime * (BPM / 60.0));\n    float d = smoothstep( 0.45, 0.40, abs(inUV) );\n    diffuse = mix(vec3(0.05), vec3(0.07), d);\n    surfaceLight = vec3(50) * d * pow(abs(mod(x, 10.0) / 9.0), 10.0);\n}\n\nfloat embossD(vec2 p) {\n    return smin(smax(afx(p), 0.01, 0.02), 0.03, 0.02);\n}\n\nvec2 emboss(vec2 p) {\n    const vec2 u = vec2(0.001, 0);\n    float e = embossD(p);\n    return vec2(e - embossD(p+u.xy),\n                e - embossD(p+u.yx)) / u.x;\n}\n\nvec3 wallColor(vec3 p, vec3 norm) {\n    vec2 uv = p.xz;\n    uv.y -= 3.0;\n    uv *= 0.5;\n    \n    uv /= 1.0 + tempo*0.4;\n    \n    float afxOuter = smoothstep(0.045, 0.035, afx(uv));\n    float afxInner = smoothstep(0.009, -0.009, afx(uv));\n    \n    vec3 diffuse = vec3(0);\n    vec3 surfaceLight = vec3(0);\n    bars(p.x, diffuse, surfaceLight);\n    \n    const vec3 afxcol = vec3(191, 214, 48)/255.0;\n    \n    diffuse = mix(diffuse, vec3(0.05), afxOuter);\n    diffuse = mix(diffuse, afxcol, afxInner);\n    \n    surfaceLight *= 1.0 - afxOuter;\n    surfaceLight += afxInner * afxcol*40.0;\n    \n    // modify the normal\n    vec2 grad = emboss(uv);\n    norm.xz -= grad*2.0;\n    norm = normalize(norm);\n    \n    diffuse = light(p, norm, diffuse);\n    \n    return diffuse + surfaceLight;\n}\n\n// thanks Gijs, see https://www.shadertoy.com/view/4dc3zH#\nconst float ATone = 0.0370;\nconst float Semitone = 1.05946309436;\nfloat KeyToFrequency(int n){\n    return pow(Semitone,float(n-49))*440.;\n}\nfloat FrequencyToTexture(float Frequency){\n    return Frequency/440.*ATone;\n}\nfloat getAmplitude(float freq) {\n    return texture(iChannel0, vec2(FrequencyToTexture(freq), 0.0)).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // the \"sound in\" message is somewhat fitting to afx visually so double plus\n    vec2 fragSoundIn = fragCoord.xy;\n    fragSoundIn += vec2(-16, 32);\n    float c = message(fragSoundIn/8.0);\n    if ( c>=0.0 ) {\n        fragColor=vec4(c);\n        return;\n    }\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // find most played note to alter the spotlight position\n    float bestValue = 0.0;\n    for (int i = 0 ; i < 10 ; i++) {\n        float hz = KeyToFrequency(30+i*2);\n        float value = getAmplitude(hz);\n        if (value > bestValue) {\n            bestValue = value;\n            bestNoteFrac = float(i) / 9.0;\n        }\n    }\n    \n    // find \"tempo\" to scale the logo\n    tempo = texture(iChannel0, vec2(0.66, 0.0)).r;\n    \n    vec3 from = vec3(0, -6.5, 2);\n\tvec3 dir = normalize(vec3(uv.x, 1.5, uv.y));\n    \n    vec2 mouse = vec2(0);\n    if (iMouse.z > 0.0) mouse = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n    dir.yz *= rot(-mouse.y*0.4);\n    dir.xy *= rot(mouse.x*0.4);\n\n    float distWall = 99999.9;\n    vec3 normWall = vec3(0);\n    bool hitWall = traceWall(from, dir, distWall, normWall);\n    \n    float distGround = 99999.9;\n    vec3 normGround = vec3(0);\n    bool hitGround = traceGround(from, dir, distGround, normGround);\n    \n    vec3 color = vec3(0);\n    \n    if ( hitWall && distWall < distGround ) {\n        vec3 p = from + dir * distWall;\n        color = wallColor(p, normWall);\n        \n    } else if ( hitGround && distGround < distWall ) {\n        vec3 p = from + dir * distGround;\n        \n        vec3 reflDir = reflect(dir, normGround);\n        vec3 dirTan = normalize(cross(reflDir, vec3(0, 0, 1)));\n        vec3 dirCoTan = cross(reflDir, dirTan);\n        float angle = 0.03;\n        \n        // specular reflection, average of n rays traced in a cone\n        vec3 specColor = vec3(0);\n        #define BLUR 20\n        for (int i = 0 ; i < BLUR ; i++) {\n            vec3 rand = hash33(vec3(fragCoord.xy, float(i*BLUR+iFrame)));\n        \tfloat rot = 2.0*PI*rand.x;\n        \tfloat the = acos(1.0 - rand.y*(1.0 - cos(angle)));\n        \tfloat sinThe = sin(the);\n        \tvec3 blurDir = dirTan*sinThe*cos(rot) + dirCoTan*sinThe*sin(rot) + reflDir*cos(the);\n            \n            float distToWall = 0.0;\n            vec3 normToWall = vec3(0);\n            \n            traceWall(p, blurDir, distToWall, normToWall);\n            vec3 onWall = p + blurDir * distToWall;\n            vec3 blurColor = wallColor(onWall, normToWall);\n            \n            specColor += blurColor;\n        }\n        specColor /= float(BLUR);\n        \n        vec3 diffuseColor = vec3(0);\n        vec3 surfaceLight = vec3(0);\n        bars(p.x, diffuseColor, surfaceLight);\n        diffuseColor = light(p, normGround, diffuseColor);\n        diffuseColor = mix(diffuseColor, specColor, 0.6);\n        color = diffuseColor + surfaceLight;\n        \n    }\n    \n    fragColor.rgb = color;\n    \n    // exposition\n    fragColor.rgb *= 0.01;\n    // gamma correction\n    fragColor.rgb = pow( max(vec3(0), fragColor.rgb), vec3(1.0/2.2) );\n    // add noise to fix banding\n    vec3 rand = hash33( vec3(fragCoord.xy, float(iFrame)));\n    fragColor.rgb += (rand-0.5) * 0.01;\n    // clamp and vigneting\n    fragColor.rgb = clamp(fragColor.rgb, vec3(0), vec3(1));\n    vec2 p = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), min(dot(p, p)*0.4, 1.0));\n    // store tempo in alpha channel\n    fragColor.a = tempo;\n    \n    return;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 6632,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/warp-records/aphex-twin-minipops-67-1202source-field-mix"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}