{
    "Shader": {
        "info": {
            "date": "1634655375",
            "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nvariant of https://shadertoy.com/view/sdGXWD\nHard to get nice ribbon borders !  another approach here: https://www.shadertoy.com/view/fdVSDW",
            "flags": 0,
            "hasliked": 0,
            "id": "fsVSWW",
            "likes": 20,
            "name": " Fab19 #inktober2021 \"loop\" 2",
            "published": 3,
            "tags": [
                "2d",
                "short",
                "fourierseries",
                "inktober2021"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 408
        },
        "renderpass": [
            {
                "code": "// variant of https://shadertoy.com/view/sdGXWD\n// another approach here: https://www.shadertoy.com/view/fdVSDW\n\n// --- utils inspired from https://www.shadertoy.com/view/llySRh\n\n#define H(p)     fract( sin( (p) * 78.233 ) * 43758.5453 ) // hash\n#define hue(v) ( .88 + .18 * cos( v  + vec3(0,23,21)  ) )  // desaturated hue\n#define S(v)     smoothstep(  8./R.y, 0.,   v )            // AA draw\n#define s(a,b)   t=a, a=b, b=t                             // swap\n\nfloat line(vec2 p, vec2 a,vec2 b, out float h) { // h = pos on segment ( possibly out )\n    p -= a, b -= a;\n    return length( p - b * clamp( h = dot(p, b) / dot(b, b), 0., 1.) );\n}\n\n// -----------------------------------------------------------\n\nvec2 f(float t) {                               // curve P(t)\n    vec2 P = vec2(0);\n    for (float f, i = 0.; i < 6.; i++ )         // Fourier series \n        f = exp2(i)*t + 6.283*H(i) + i*iTime,\n        P += vec2(cos(f),sin(f)) / pow(1.4, i); // spectrum 1.4^-f, random phase\n    return P;\n}\n#define D(t)  l = dot( P = f(t) - U, P )        // distanceÂ² to curve(t)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, P,\n         U = 2.5*( u+u - R ) / R.y;\n    float l, d0 = 9., d1=d0, T0,T1,t0,t1,e,h0,h1,h_,c0,c1, t=0., dt = .015, dt2 = dt/4.;\n    O-=O;\n    for ( ; t < 6.283; t+=dt )                  // Sample the curve and get the 2 closests\n        D(t),                                   //   that are not on the same segment.\n          l < d0 ?  t<=T0+dt ? d0=l,T0=t        // Prev best was on same segment: don't update 2nd best\n                             : ( d1=d0, T1=T0, d0=l, T0=t ) // independant best: save old as 2nd best\n        : l < d1 && t> T0+dt ? d1=l,T1=t : t;   // update 2nd best only if not on best segment\n        \n    if (iMouse.z > 0.) O += smoothstep(8./R.y, 0., sqrt(min(d0,d1))-.01 ); // test: draw dots\n\n    t0=T0; t1=T1;    \n    for ( t = -dt; t < dt; t += dt2 )           // Look more accurately around 1st and second\n        D(T0+t), l < d0 ? d0=l,  t0=T0+t : t,   //   closest curve segments.\n        D(T1+t), l < d1 ? d1=l,  t1=T1+t : t;\n        \n   // draw upstream and dowstream segment for 1st and 2nd best\n   // the mess with h & c is to draw the borders pushed only at the right extra angle on the round segment junction\n#define  L(t,h,c) ( d0 = line(U, f(t-dt2), f(t), h  ),  h  = (abs(h -.5)-.5)*length(f(t)-f(t-dt2)), \\\n                    d1 = line(U, f(t+dt2), f(t), h_ ),  h_ = (abs(h_-.5)-.5)*length(f(t)-f(t-dt2)), \\\n                  c = dot( normalize( f(t) - f(t-dt2) ), normalize( f(t+dt2) - f(t) ) ),            \\\n                ( d1 < d0 ? h=h_, d1 : d0 ) -.06 ) \n    T0 = L(t0,h0,c0), T1 = L(t1,h1,c1);\n\nif ( cos(t1) < cos(t0) ) s(T0,T1), s(t0,t1), s(h0,h1), s(c0,c1); // z-sort\n                                       // ribbon pattern (up to a bit of the joint)         , ribbon color,  ribbon mask\n#define B(h,t,T,c) O += (1.-O.a)* vec4( ( h > sqrt(1.-c*c)*(.2+6./R.y) ? 1. : S(T + 6./R.y) ) * hue(t), 1 ) * S(T) // blend ribon pattern*mask\n    B(h0,t0,T0,c0);                             // draw top segment\n    B(h1,t1,T1,c1);                             // draw bottom segment\n    O +=  1.-O.a ;                              // background\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}