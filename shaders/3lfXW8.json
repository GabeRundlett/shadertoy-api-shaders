{
    "Shader": {
        "info": {
            "date": "1562652852",
            "description": "Whisp forms",
            "flags": 0,
            "hasliked": 0,
            "id": "3lfXW8",
            "likes": 42,
            "name": "Ghost Chamber #13",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "distancefield",
                "ghost"
            ],
            "usePreview": 0,
            "username": "audiopixel",
            "viewed": 3457
        },
        "renderpass": [
            {
                "code": "// Created by Hepp Maccoy 2019, hepp@audiopixel.com | http://audiopixel.com\n// Distance functions by Inigo Quilez, iquilezles.org\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define PI 3.14159265358979323846\n\nvec3 glow;\nfloat d1;\nfloat t1;\nvec3 b_8(vec3 c1, vec3 c2){\n    return (c1 + c2) - (c1 * c2);\n}\n\nvec3 b_6(vec3 c1, vec3 c2){\n    return (c1 + c2) - 1.0;\n}\n\nfloat soc(vec3 p) {\n    vec3 n = normalize(sign(p+1e6));\n    return min(min(dot(p.xy, n.xy), dot(p.yz, n.yz)), dot(p.xz, n.xz));\n}\n\nfloat sinc(float x, float k) {\n    float a = PI * (float(k)*x-1.0);\n    return sin(a)/a;\n}\n\nmat2 r2d(float a) {\n    float sa=sin(a);\n    float ca=cos(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nvec2 mo(inout vec2 p, vec2 d) {\n    vec2 q = p;\n    q.x = abs(q.x) - d.x;\n    q.y = abs(q.y) - d.y;\n    if (q.y > q.x) q = q.yx;\n    return q;\n}\n\nfloat map(vec3 p) {\n    float d = 0.328;\n    float a = abs(p.y);\n    p.yz *= r2d(sign(a) * 5.6);\n    p.xz *= r2d(sign(a) * d1 * 4.2);\n    p.xz = mo(p.xz, vec2((-d1 * 29.8) - 1., -7.3676));\n    p.zx = mo(p.xz, vec2(8.4443, 4.0344));\n    p.xz = mo(p.xz, vec2(-12.9879, -9.1065));\n    p.zx = mo(p.zx, vec2(5.4177, 2.3984));\n    p.xz = max(abs(p.xz) - -8.7279, 10.023);\n    p.xz = mo(p.xz, vec2((d1 * 2.) - 4., -12.7982));\n    p.zx = mo(p.xz, vec2(-16.7502, -8.5611));\n    p.z = mod(p.z, -16.381445)-(-16.381445 *.5);\n    p.x = mod(p.x, 76.08105)-(76.08105 *.5);\n    p.y = mod(p.y + t1 * 21.2, 28.46435) - 5.;\n    p.zy = mo(p.zy, vec2(0.0, (d1 * 2.8)));\n    p.xz = mo(p.xz, vec2(0.0, 14.1212));\n    p.yx = mo(p.yx, vec2(2.3815, 0.5875));\n    d = min(d, soc(max(abs(p) - 1.3103, -0.9418)));\n    glow += vec3(0.8784314,0.8784314,0.8784314) * 0.0471 / (0.0539 + d*d);\n    return (length(p * -0.6424) - -0.7392) * 0.1944 - (d * -1.939);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    t1 = (iTime * .78) + 166.;\n    d1 = sin(t1 * .2);\n    vec2 st = (fragCoord.xy / iResolution.xy) * 2.1 - 1.;\n    st.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(st, 3.0);\n    vec3 rd = normalize(vec3(st + vec2(0.), -0.35938));\n    vec3 mp;\n    mp = ro;\n    float md;\n    for(int i=0; i<50; i++) {\n        md = map(mp);\n        mp += (rd * 0.5921) * md;\n    }\n    float b = length(ro - mp);\n    float dA = 1.6979 - (b * 0.1462) * -0.6102;\n    float dB = 0.9117 - (b * 0.1348) * -1.998;\n    dA = sinc(dA, 0.3252);\n    dB = sinc(dB, 0.2127);\n    float src1 = dA * -0.3094;\n    float src2 = dB * -1.0;\n    float src3 = dB * -1.0;\n    float src4 = dA * 0.4847;\n    vec3 c;\n    src1 *= 2.0;\n    src2 *= 0.9038;\n    c = b_6((mix(vec3(0.,0.5882353,1.0), vec3(0.0), src1) * 1.0),(mix(vec3(0.0), vec3(1.0,0.0,0.9411765), src2) * 1.211));\n    c = c * vec3(src3);\n    c = b_6(c,vec3(src4));\n    vec3 gt = c + (glow * 0.1);\n    c = b_8(c,gt);\n    fragColor = vec4(c, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}