{
    "Shader": {
        "info": {
            "date": "1548408980",
            "description": "Quick and simple reflections + shadows!",
            "flags": 0,
            "hasliked": 0,
            "id": "wsSGRw",
            "likes": 2,
            "name": "Raytracing Reflections Demo",
            "published": 3,
            "tags": [
                "reflection",
                "raytrace"
            ],
            "usePreview": 0,
            "username": "mrsaturn",
            "viewed": 486
        },
        "renderpass": [
            {
                "code": "// setup\n/////////////////////////////////////////////////////////////////\nconst vec3 CAMERA_POS = vec3(0, 0, 2.0);\nconst vec3 FORWARD = vec3(0.0, 0.0, -1.0);\nconst vec3 RIGHT = normalize(cross(vec3(0.0, 1.0, 0.0), FORWARD));\nconst vec3 UP = normalize(cross(FORWARD, RIGHT));\nconst mat3 CAMERA_MATRIX = mat3(RIGHT, UP, FORWARD);\nconst float FOV = 5.5;\n\nconst float LIGHT_INTENSITY = 1.0;\nconst float SHADOW_FACTOR = 0.3;\nconst float BIAS = 0.05;\nconst float LIGHT_MOVE_FACTOR = 0.2;\n\nstruct Material\n{\n    vec3 color;\n};\n    \nstruct Sphere\n{\n    vec3 position;\n    float radius;\n    Material mat;\n};\n    \nconst Material RED = Material(vec3(1.0, 0.0, 0.0));\nconst Material GREEN = Material(vec3(0.0, 1.0, 0.0));\nconst Material BLUE = Material(vec3(0.0, 0.0, 1.0));\nconst Material PURPLE = Material(vec3(1.0, 0.0, 1.0));\nconst Material WHITE = Material(vec3(1.0, 1.0, 1.0));\n\nSphere SPHERES[] = Sphere[]\n(\n    Sphere(vec3(-1.0, 0.0, -5.0), 0.5, RED),\n    Sphere(vec3(0.2, 0.0, -5.0), 0.4, GREEN),\n    Sphere(vec3(0.8, 0.0, -5.0), 0.3, BLUE),\n    Sphere(vec3(1.5, 0.0, -5.0), 0.2, PURPLE),\n    Sphere(vec3(0.0, 0.0, -7.0), 1.2, WHITE)\n);\n\nstruct IResult\n{\n    bool iIntersected;\n    vec3 iPoint;\n    vec3 iNormal;\n};\n/////////////////////////////////////////////////////////////////\n\n// get a direction ray in world-space\nvec3 rayDir(vec2 coord)\n{\n    return normalize(CAMERA_MATRIX * vec3(coord, FOV));\n}\n\n// test ray-sphere intersection\nIResult sphereIntersect(vec3 start, vec3 dir, Sphere s)\n{\n    vec3 m = start - s.position;\n    float b = dot(m, dir); \n\tfloat c = dot(m, m) - s.radius * s.radius;\n    \n    if (c > 0.0f && b > 0.0f)\n        return IResult(false, vec3(0.0), vec3(0.0));\n    \n\tfloat discr = b * b - c;\n    \n    if (discr < 0.0f)\n\t\treturn IResult(false, vec3(0.0), vec3(0.0));\n    \n    float t = -b - sqrt(discr);\n    if (t < 0.0)\n        t = 0.0;\n    \n    vec3 ipoint = start + t * dir;\n    \n    return IResult(true, ipoint, normalize(ipoint - s.position));\n}\n\n// test for rs-intersection, run reflection test, run shadow test\nvec3 rayTrace(const vec3 dir, vec3 light_pos)\n{\n    for (int i = 0; i < SPHERES.length(); ++i)\n    {\n        IResult result = sphereIntersect(CAMERA_POS, dir, SPHERES[i]);\n        \n        if (result.iIntersected)\n        {\n            vec3 indirect = vec3(0.0);\n            float shadow = 1.0;\n            vec3 ldir = -normalize(light_pos);\n            vec3 from_light = normalize(result.iPoint - light_pos);\n            \n            for (int j = 0; j < SPHERES.length(); ++j)\n            {   \n            \tIResult result2 = sphereIntersect(result.iPoint + result.iNormal * BIAS, result.iNormal, SPHERES[j]);\n                \n                if (result2.iIntersected)\n                    indirect += LIGHT_INTENSITY * max(dot(ldir, result2.iNormal), 0.0) * SPHERES[j].mat.color;\n            }\n            \n            for (int j = 0; j < SPHERES.length(); ++j)\n            {\n            \tIResult result2 = sphereIntersect(result.iPoint + from_light * BIAS, from_light, SPHERES[j]);\n                \n                if (result2.iIntersected)\n                    shadow -= SHADOW_FACTOR;\n            }\n            \n            if (shadow < 0.0)\n                shadow = 0.0;\n            \n            return (indirect + SPHERES[i].mat.color) * shadow * LIGHT_INTENSITY * max(dot(ldir, result.iNormal), 0.0);\n        }\n    }\n    \n    return vec3(0.0);\n}\n\n// move spheres up and down\nvoid animateSpherePositions()\n{\n    for (int i = 0; i < SPHERES.length() - 1; ++i)\n    {\n     \tSPHERES[i].position.y = cos(sin(SPHERES[i].position.x)) + sin(iTime * (float(i) + 0.2)) - 0.8;   \n    }\n}\n\n// move light around the scene\nvec3 animateLight()\n{\n    float factor = iTime * LIGHT_MOVE_FACTOR;\n    float circleX = sin(factor);\n    float circleZ = cos(factor);\n \treturn 50.0 * vec3(circleX, 0.0, circleZ);\n}\n\n// output pixel\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 dir = rayDir(coord);\n    \n    animateSpherePositions();\n    \n    const vec3 gamma = vec3(0.454545);\n    fragColor = vec4(pow(rayTrace(dir, animateLight()), gamma), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}