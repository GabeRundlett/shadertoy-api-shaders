{
    "Shader": {
        "info": {
            "date": "1583166001",
            "description": "Shooting a planet with a gigantic frickin' laser!\nA different scene, but the same scatter engine as my previous shader.",
            "flags": 32,
            "hasliked": 0,
            "id": "wtySWD",
            "likes": 38,
            "name": "Planet Blast",
            "published": 3,
            "tags": [
                "raymarching",
                "montecarlo",
                "laser",
                "scatter",
                "atmospheric"
            ],
            "usePreview": 1,
            "username": "TekF",
            "viewed": 1897
        },
        "renderpass": [
            {
                "code": "// Fork of \"Photoreal Clouds\" by TekF. https://shadertoy.com/view/tlcSzs\n// 2020-02-14 14:25:32\n\n// Tone Mapping by Hazel Quantock\n// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n\nfloat exposureModifier = 1.1;\n\n// Exposure curve parameters\n//#define SHOW_CURVE 1\nconst vec3 gradient = vec3(1.4,1.5,1.6);\nconst vec3 whiteSoftness = vec3(.3);\nconst vec3 blackClip = vec3(.0,.1,.2)*.3+.0;\nconst vec3 blackSoftness = vec3(.65,.5,.35)*2.;\n\nvec3 LinearToSRGB ( vec3 col )\n{\n    return mix( col*12.92, 1.055*pow(col,vec3(1./2.4))-.055, step(.0031308,col) );\n}\n\nvec3 SRGBToLinear ( vec3 col )\n{\n    return mix( col/12.92, pow((col+.055)/1.055,vec3(2.4)), step(.04045,col) );\n}\n\nvec3 HDRtoLDR( vec3 col )\n{\n#if (1)\n    // soft cut off near black to enhance contrast\n   \t// this is good for correcting for atmospheric fog\n\tcol = max(col-blackClip,0.); \n    col = sqrt(col*col+blackSoftness*blackSoftness)-blackSoftness;\n\n    col *= gradient;\n    \n    // soft clamp to white (oh this is so good)\n    vec3 w2 = whiteSoftness*whiteSoftness;\n    col += w2;\n    col = (1.-col)*.5;\n    col = 1. - (sqrt(col*col+w2) + col);\n#else\n    // skip tone mapping\n\tcol*=.4;\n#endif\n    \n\treturn LinearToSRGB(col);\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n#if defined(RESOLUTION_REDUCTION) && RESOLUTION_REDUCTION > 1\n    fragCoord /= vec2(RESOLUTION_REDUCTION);\n    // smooth out the transition between pixels\n//    fragCoord -= 1.*sin(fragCoord*6.283185)/6.283185;\n    fragColour = SampleTextureCatmullRom4Samples(iChannel0,fragCoord/iResolution.xy,iResolution.xy);\n#else    \n    ivec2 ifragCoord = ivec2(fragCoord);\n    fragColour = texelFetch(iChannel0,ifragCoord,0);\n\n#ifdef MOSAIC_PREVIEW\n    const float targetCount = 1024.;\n    if ( fragColour.a < targetCount )\n    {\n        // blend a square big enough to hit targetCount\n        int kernelSize = int(ceil(sqrt(targetCount/fragColour.a)));\n        const int maxKernel = 32;\n        kernelSize = min(kernelSize,maxKernel);\n        ivec2 blockuv = (ifragCoord/kernelSize)*kernelSize;\n        for ( int i=0; i < maxKernel; i++ )\n        {\n            if ( i > kernelSize ) break;\n            for ( int j=0; j < maxKernel; j++ )\n            {\n                if ( j > kernelSize ) break;\n                fragColour += texelFetch(iChannel0,blockuv+ivec2(i,j),0);\n            }\n        }\n    }\n#endif\n#endif\n    \n    fragColour /= fragColour.a;\n\n\tvec4 blurred = texelFetch(iChannel1,ifragCoord,0);\n    blurred /= blurred.a;\n    \n    // adjust saturation\n    blurred = mix( blurred, vec4(dot(blurred,vec4(.2,.7,.1,0))), .5 );\n    \n\tvec4 exposure = blurred;\n    \n    // prevent it adjusting to impossibly dark colours\n\texposure += .02;//.003;//.0007; // arbitrary value chosen to look right for scene (also to limit graininess on really dark areas\n    \n    // how much to compensate? - fully! then modify blur radius in buf B\n    fragColour *= exposureModifier/exposure;\n\n//fragColour = blurred*2.;\n    \n    fragColour.rgb = HDRtoLDR( fragColour.rgb );\n    \n#ifdef SHOW_CURVE\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 f = HDRtoLDR(vec3( uv.x*3. ));\n    f = SRGBToLinear(f); // show curve without gamma correction (comment this out to see actual HDR->colour value mapping)\n    f -= (uv.y*1.04-.02);\n    fragColour.rgb = SRGBToLinear(fragColour.rgb);\n    fragColour.rgb = mix( vec3(1), fragColour.rgb, smoothstep( 0., 1.4, abs(f)/max(dFdx(f),vec3(1)/iResolution.y) ) );\n    fragColour.rgb = LinearToSRGB(fragColour.rgb);\n#endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Planet Blast by Hazel Quantock\n// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n\n// scene parameters\nconst float cloudiness = -.1;\n\nconst vec3 groundColour = vec3(.1,.15,.05); // grassy\n//const vec3 groundColour = vec3(.1); // dark grey (looks a bit brown because of tone mapping)\n//const vec3 groundColour = vec3(1); // snow\n\nconst vec3 lightDirection = normalize(vec3(2,2,5));\nconst vec3 lightColour = vec3(.3);\n\n\n// control the ray marcher\nconst float minStepLength = .05;\nconst int marchCount = 200;\nconst float shadowDrawDistance = 8.;\nconst float shadowStep = .05;\n\nconst float directLightProportion = 1./6.; // proportion of scattered rays used to sample direct light (balance graininess of god rays vs graininess of radiosity)\n//^ this shouldn't be affecting radiosity brightness, but it is! Bah!\n\nstruct ScatterData\n{\n\tfloat scatter; // proportion of rays scattered per metre - must be less than 1.0\n\tvec3 tint; // what proportion of RGB light remains after 1m - must be more than 0.0 - applies independent of scatter, so if this is 1,1,1 we still have reduction in visibility caused by scatter\n    vec3 emission; // amount of light added per 1m - should work for values > 1 but I'm not sure\n\tvec3 scatterTint; // particles can have one colour when light bounces off them and a different colour when light is absorbed by them - this can be [0,1]\n    float eccentricity; // bias the direction of scattering toward/away from (+ve/-ve) incident light direction\n};\n\nScatterData Mix( ScatterData a, ScatterData b, float c )\n{\n\t// this isn't perfect - interpolated media can have values that look different either of the two being blended\n    // e.g. this can cause a halo around very dense objects when they interpolate to the colour of the sky\n    // to reduce this effect, premultiply by scatter, to prioritise the parameters of the denser media\n    \n\t// but tint doesn't need this - since it is effectively the same as scatter (hard to explain but very easy to see this is true with a test)\n    \n    // fudge to prevent vacuum getting it wrong\n    const float vacuum = .001;\n    \n    a.scatter += vacuum;\n    b.scatter += vacuum;\n    \n    ScatterData m = \n        ScatterData(\n            mix( a.scatter, b.scatter, c ),\n            mix( a.tint, b.tint, c ),\n            mix( a.emission*a.scatter, b.emission*b.scatter, c ),\n            mix( a.scatterTint*a.scatter, b.scatterTint*b.scatter, c ),\n            mix( a.eccentricity*a.scatter, b.eccentricity*b.scatter, c )\n        );\n    return\n        ScatterData(\n            m.scatter - vacuum,\n            m.tint,\n            m.emission/m.scatter,\n            m.scatterTint/m.scatter,\n            m.eccentricity/m.scatter\n        );\n}\n\n\n// signed distance field (SDF) for a torus\n// returned value is distance of pos from the surface (negative if inside)\nfloat Torus( vec3 position, vec3 axis, float majorRadius, float minorRadius )\n{\n    axis = normalize(axis);\n    float perp = dot(axis,position);\n    position -= perp*axis;\n    return length( vec2( perp, length(position) - majorRadius ) ) - minorRadius;\n}\n\n\nfloat Billow( vec3 pos )\n{\n    return abs(Noise(pos)-.5)-.25;\n}\n    \nScatterData SampleMedia( vec3 pos )\n{\n    float planetRadius = 20.;\n    vec3 planetCentre = normalize(vec3(3,-3.5,0))*planetRadius + vec3(0,0,-4);\n    float altitude = length(pos-planetCentre) - planetRadius;\n    \n\n    ScatterData air = ScatterData( .7, vec3(1,.6,.3), vec3(0), vec3(.6,.8,1), .3 );\n    ScatterData space = ScatterData( .0, vec3(1), vec3(0), vec3(1), .0 );\n    \n    \n    vec3 groundColour = mix(\n        \t\t\t\t\t// green vs desert\n        \t\t\t\t\tmix(\n                                vec3(.1,.3,.05),\n                                vec3(.6,.5,.1),\n                                smoothstep( .6, .9, mix( Noise(pos), .5-.5*cos(pow(abs(pos.y/planetRadius),.333)*tau), .7 ) ) // 2 bands of desert either side of the equator\n                            ),\n        \t\t\t\t\t// ocean\n        \t\t\t\t\tvec3(.01,.03,.15),\n        \t\t\t\t\tsmoothstep( .45, .55, mix( Noise(pos/3.), Noise(pos/.8), .3 ) ) // smooth so we don't mind the lack of detail!\n        \t\t\t\t);\n    \n    ScatterData ground = ScatterData( 1., vec3(0), vec3(0), groundColour, .3 );\n    \n    \n    ScatterData cloud = ScatterData( .99, vec3(1), vec3(0), vec3(1), .0 );\n\n    // swirled position\n    vec3 swirlPos = pos - planetCentre;\n\t// rotate this so it's somewhere nice wrt camera (or rotate camera & light - but camera code is a bit locked to right-way-uppedness)\n    swirlPos.xy = swirlPos.xy*sqrt(2./4.) + swirlPos.yx*vec2(1,-1)*sqrt(2./4.);\n\n    float distFromSwirlSquared = dot(swirlPos.xz,swirlPos.xz);\n    float distFromSwirl = sqrt(distFromSwirlSquared);\n    float swirl = .7/(distFromSwirlSquared+.7);\n    float swirlAngle = swirl*7.;\n    swirlPos.xz = swirlPos.xz*cos(swirlAngle) + swirlPos.zx*vec2(1,-1)*sin(swirlAngle);\n    swirlPos.xz /= 2.; // scale against the swirl a bit\n\n    // push up the planet under the swirl\n//    altitude -= 2.*sin(distFromSwirl*4.+.25*tau)*swirl;\n    altitude -= 2.*sin(swirl*.75*tau)*swirl;\n    \n    float cloudSDF = pow( abs((altitude-.1)/.1), 2. )*.1;\n    cloudSDF += (Noise(swirlPos/.3)-.5)*.15;\n    cloudSDF *= .7;\n    cloudSDF += (Noise(swirlPos/.15)-.5)*.10;\n\n    vec3 uvw = pos;\n\t// billowy noise looks nice for clouds\n\t// but it makes the grid of the noise very visible (because I'm using a cheap and nasty noise function)\n    // so rotate it with each octave of noise\n    uvw = vec3( uvw.xy*sqrt(3./4.)+uvw.yx*vec2(-1,1)*sqrt(1./4.), uvw.z ).yzx;\n\tcloudSDF -= Billow(uvw/.15)*.05;\n    uvw = vec3( uvw.xy*sqrt(3./4.)+uvw.yx*vec2(-1,1)*sqrt(1./4.), uvw.z ).yzx;\n    cloudSDF -= Billow(uvw/.06)*.06;\n    uvw = vec3( uvw.xy*sqrt(3./4.)+uvw.yx*vec2(-1,1)*sqrt(1./4.), uvw.z ).yzx;\n    cloudSDF -= Billow(uvw/.03)*.03;\n\n    float cloudVariation = (Noise(swirlPos/1.2+2.)-.5)+cloudiness;\n    \n    cloudSDF -= mix( cloudVariation*.1, .05, smoothstep(.0,.2,swirl) );\n    \n    ground.emission = swirl*swirl*vec3(1,.2,.04)*30.*(1.-abs(Noise((pos - planetCentre)*(1.-.3*swirl)/.15)-.5)/.5);\n//^ ok mix for emission is borked, probably because of space\n    \n    ScatterData scatter =\n        Mix(Mix(Mix(\n            space,\n            air,\n            exp2( clamp( -altitude/.12, -15., 15. ) ) ),\n            cloud,\n            smoothstep( 1., -1., cloudSDF/.01 ) ),\n            ground, // ground overrides most things\n            smoothstep( 1., -1., altitude/(.001+swirl*.2) ) // break up the surface near the blast\n        );\n    \n    // laser is too powerful to blend sensibly with space & atmosphere - it should just add to them!\n    float laserMask = exp2( clamp( -distFromSwirlSquared/.05, -15., 15. ) );//.01/(distFromSwirlSquared+.01)//smoothstep( .8, 0., distFromSwirl )\n    scatter.emission +=  vec3(20,7,13)*1.*laserMask;\n    \n    return scatter;\n}\n\n\nvec3 SphereMap( vec2 uv )\n{\n    // uv is in the range [0,1)\n    // map this range onto a unit sphere, with a uniform distribution of points\n    \n    // use the fact that the surface area of a slice of a sphere is the same\n    // as the surface area of a cylinder with the height of the slice and the\n    // radius of the sphere\n    \n    // wrap the 2D space around a cylinder\n    float h = uv.y*2.-1.; // height up cylinder\n    float a = uv.x*tau; // angle around the circle\n    \n    // position on the circular slice of the cylinder at this height\n    vec2 v = vec2(sin(a),cos(a));\n    \n    // project onto the corresponding slice of the sphere\n    // by multiplying by width of sphere at this height\n    v = v * sqrt(1.-h*h);\n    \n    return vec3(v,h);\n}\n\n/* obsfuscated version:\nvec3 SphereMap( vec2 uv )\n{\n    return vec3( sin((uv.xx+vec2(0,.25))*6.283185)*2.*sqrt(uv.y*(1.-uv.y)), uv.y*2.-1. );\n}*/\n\n                 \nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    ivec2 pixelIndex = ivec2(fragCoord);\n#if defined(RESOLUTION_REDUCTION) && RESOLUTION_REDUCTION > 1\n    fragCoord *= vec2(RESOLUTION_REDUCTION);\n    if ( fragCoord.x > iResolution.x || fragCoord.y > iResolution.y )\n    {\n        fragColour = vec4(.5,.5,.5,1);\n        return;\n    }\n#endif\n\n    fragColour = vec4(0);\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    if ( iMouse.x < 1. && iMouse.y < 1. )\n        mouse = vec2(.41,.68);\n    \n    // slightly ugly hack: remap the range of mouse movements to give better camera control without re-adjusting all the magic numbers below.\n    mouse.y = pow(mouse.y,.5)*.7+.1;\n    \n\tvec2 camAngle = ((mouse-.5)*vec2(1.3,-.4999)+vec2(.2*1.3,.1))*6.283185;\n\n#ifdef ANIMATE\n//    camAngle.x+=iTime*.05;\n#endif\n    \n    float mouseH = .608 - mouse.y; // make high camera positions frame the whole torus\n    \n    vec3 camTarget = vec3(1,-1,-1);// + vec3(5.5,.5,-9)*1.6*mouseH;\n    float camDistance = 12.;\n    float camZoom = 1.;\n\n\tcamDistance *= exp2(3.*mouseH); // move camera in/out\n    \n    vec3 camPos = camDistance*vec3(-vec2(sin(camAngle.x),cos(camAngle.x))*cos(camAngle.y),sin(camAngle.y)).xzy+vec3(0,-3.5,0);\n    vec3 camK = normalize( camTarget-camPos );\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\n    vec3 camJ = cross(camK,camI);\n    \n\n    const int maxPasses = 100;\n    \n    int sampleCountMul = sampleCountMultiplier;\n#if defined(RESOLUTION_REDUCTION) && RESOLUTION_REDUCTION > 1\n    sampleCountMul *= (RESOLUTION_REDUCTION*RESOLUTION_REDUCTION);\n    sampleCountMul = (sampleCountMul*7)/8; // not sure why but without this res reduction always slows it down\n#endif        \n\tint numPasses = max(1,sampleCountMul*(320*180)/int(iResolution.x*iResolution.y));\n\n    int bounceCount = 0;\n    for ( int pass=0; pass < maxPasses; pass++ )\n    {\n        if ( pass >= numPasses ) break;\n\n        SeedRand( iFrame*numPasses+pass, fragCoord );\n\n        vec2 jitter = vec2(rand2())-.5;\n        vec3 ray = normalize( vec3( (fragCoord+jitter-iResolution.xy*.5)/iResolution.y, camZoom ) );\n\n        ray = ray.x*camI + ray.y*camJ + ray.z*camK;\n\n\t\tfloat stepLength = minStepLength;\n\n        // First, march through space, allowing the ray to be deflected randomly by scatter\n        vec3 pos = camPos;\n        pos += ray * rand() * stepLength; // randomize initial step to hide aliasing errors (doesn't fix them, but hides them really well)\n        float lastH = stepLength;\n        vec3 lastTint = SampleMedia(pos).tint;\n        vec3 tint = vec3(1);\n        vec3 emission = vec3(0);\n\t\tbool lightRay = false;\n        float t = 0.;\n        for ( int i=0; i < marchCount; i++ )\n        {\n            //if ( max(max(tint.r,tint.g),tint.b) <= .01 ) break; // early out when rays have almost no effect - this doesn't seem to improve performance\n            \n            // step through media [step size modified by probability]\n            ScatterData scatter = SampleMedia(pos);\n\n            float h = stepLength*(1. + .9*(rand()*2.-1.)); // adjust steps randomly to hide aliasing errors\n\n            // experimenting with variable step size\n            // at the moment it just increases with distance, so rays can travel further but become less accurate\n\t\t\t// I could do this adaptively, but that's more complicated\n\t\t\tstepLength *= 1.01;\n\n            // accumulate average tint\n            tint *= pow(max(vec3(.00000001),mix(scatter.tint,lastTint,.5)),vec3(lastH));\n\n            float pointH = mix(lastH,h,.5); // length of step represented by this scatter sample        \n\n            // accumulate emission with current tint applied        \n            emission += tint*(scatter.emission * pointH);  // pretty sure emission should be multiplied not pow'd, so it's additive not exponential\n\n            if ( pow(max(.00000001,1.-scatter.scatter), pointH) < rand() )// [modified by average of last/next step size]\n            {\n                if ( rand() < directLightProportion ) // proportion of rays which become direct light rays\n                {\n                \t// direct light\n                    // apply the scatter tint and point the ray at the light\n\n                    // correct brightness by proportion of rays not scattered this way\n                    tint /= directLightProportion;\n\t                tint *= scatter.scatterTint;\n\n                    // apply a curve for eccentricity\n                    // this uses the derivative of the curve used for the random scatter\n                    // we want to say \"how much light is scattered in this direction\" rather than \"what direction should this light be scattered in\"\n                    float cos0 = dot(ray,lightDirection);\n                    float ae = abs(scatter.eccentricity);\n                    \n                    float se = (scatter.eccentricity<0.)?-1.:1.; // sign(eccentricity) but without 0.0\n\t\t\t\t\t//float cos1 = (pow(cos0*se*.5+.5,1.-ae)*2.-1.)*se;\n\t\t\t\t\t// dcos1/dcos0 (computed by wolframalpha.con)\n                    float dcos1dcos0 = (1. - ae)*pow( max(.00000001,0.5 - se*0.5*cos0), -ae );\n\n                    // hack to reduce speckly artefacts caused by lighting amplified by multiple bounces\n                    // these speckles are technically correct, but they occur as a result of highly unlikely combinations of bounces\n                    // so it will take a very long time for them to average out\n\t\t\t\t\tif ( bounceCount > 0 ) dcos1dcos0 = clamp(dcos1dcos0,0.,10.);\n                    \n                    tint *= dcos1dcos0;\n\n                    // break out of this loop so we can do a separate shadow-tracing loop which doesn't scatter\n\t\t            ray = lightDirection;\n                    lightRay = true;\n                    break;\n                }\n                else\n                {\n                    vec3 newRay = SphereMap( vec2(rand2()) );\n\n                    // eccentricity - push & scale the sphere along the view ray to bias rays in same/opposite direction\n                    // amount of push such that at -1 or 1 the near side of the spheroid hits 0 and the far side hits infinity\n                    float cos0 = dot(newRay,ray);\n\n                    // Apply a curve to the distribution of rays.\n                    // This isn't ideal, it tends to create a sharp bright spot around the light rather than a softer blob\n                    // but it has the advantage that it reduces to 1-dimension which makes it easier to compute the derivative, \n                    // which is needed for direct light.\n                    // We can do this in 1D because a slice through the surface of a sphere has the same area for a given\n                    // thickness of slice, regardless of where the slice is positioned. (napkin ring problem)\n                    float ae = 1.-abs(scatter.eccentricity);\n                    float se = (scatter.eccentricity<0.)?-1.:1.;\n                    float cos1 = (pow(max(.00000001,cos0*se*.5+.5),ae*ae)*2.-1.)*se;\n                    newRay = normalize(newRay - cos0*ray);\n                    newRay = ray*cos1 + newRay*sqrt(max(.00000001,1.-cos1*cos1));\n                    ray = newRay;\n\n                    // correct brightness by proportion of rays not scattered this way\n                    // to conserve energy (this seems to have a bug, as the image changes significantly when I change directLightProportion)\n                    tint /= 1.-directLightProportion;\n\n                    // break energy conservation to prevent speckles caused by rare multiply scattered rays\n                    // technically they are correct, but they're so rare the speckles they cause are unlikely\n                    // to ever be corrected.\n                    // reduce this amount for faster convergence but less radiosity\n\t\t\t\t\ttint = clamp(tint,0.,5.);\n                    \n                    tint *= scatter.scatterTint;\n                }\n                \n                bounceCount++;\n            }\n\n            pos += ray*h;\n            t += h;\n            lastH = h;\n            lastTint = scatter.tint;\n        }\n                \n        \n        if ( directLightProportion > 0. && lightRay )\n        {\n            // haven't balanced this for variable step size, so use a const step\n            vec3 lastAbsorption;\n            float shadowT = 0.;\n            for ( int i=0; i < int(shadowDrawDistance/shadowStep); i++ )\n            {\n                // step through media [step size modified by probability]\n                ScatterData scatter = SampleMedia(pos);\n\n                float h = shadowStep; // todo: port the random stuff here too, and change the loop the same way\n                \n                // accumulate average tint\n               \t// don't scatter, just count the proportion of scattered rays as a darkening tint\n                vec3 absorption = scatter.tint*(1.-scatter.scatter);\n                if ( i > 0 )\n                {\n                \ttint *= pow(max(vec3(.00000001),mix(absorption,lastAbsorption,.5)),vec3(lastH));\n                }\n\n                pos += ray*h;\n                shadowT += h;\n                lastH = h;\n                lastAbsorption = absorption;\n            }\n            \n            emission += lightColour*tint;\n        }\n        fragColour.rgb += emission;\n\n        fragColour.a += 1.;\n    }\n\n\t// this prevents NaNs/INFs - but it's good to turn it off for testing, since I like to know what's causing bad numbers\n\tfragColour.rgb = clamp( fragColour.rgb, 0., 10000.*fragColour.a );\n    \n#if defined(RESOLUTION_REDUCTION) && RESOLUTION_REDUCTION > 1\n    // precompute checkerboard of negative/positive values\n    // required by SampleTextureCatmullRom4Samples\n    fragColour = (pixelIndex.x&1)==(pixelIndex.y&1) ? fragColour : -fragColour;\n#endif\n    \n    if ( iFrame > 0 && iMouse.z <= 0. )\n    {\n        fragColour += texelFetch(iChannel0,pixelIndex,0)\n#ifdef ANIMATE\n            *.93\n#endif\n            ;\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// quality adjustments - to improve fps\n//#define RESOLUTION_REDUCTION 3 this doesn't work with the local exposure code\nconst int sampleCountMultiplier = 7; // increase this until fps drops\n#define MOSAIC_PREVIEW 1\n\n\n// maths constants\nconst float tau = 6.28318530718;\nconst float phi = 1.61803398875; // golden ratio\n\n\n// random hash from here: https://www.shadertoy.com/view/4dVBzz\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 (1.0/float(0xffffffffU))\n\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) (uint(p)*M1)\n#define coord2(p) (uvec2(p).x*M1^uvec2(p).y*M2)\n#define coord3(p) (uvec3(p).x*M1^uvec3(p).y*M2^uvec3(p).z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n\n\n// sequential rand functions - return a different value each time\nuint seed = 1u;\n\nvoid SeedRand( int frame, vec2 fragCoord )\n{\n    seed = coord3(uvec3(frame,fragCoord));\n}\nfloat rand() { return hash1(coord1(seed++)); }\nvec2 rand2() { return hash2(coord1(seed++)); }\nvec3 rand3() { return hash3(coord1(seed++)); }\nvec4 rand4() { return hash4(coord1(seed++)); }\n\n\n// continuous noise\n// cheaper and uglier than perlin\nfloat Noise( vec3 pos )\n{\n    uvec3 p = uvec3(ivec3(floor(pos))+0x8000000);\n    vec3 f = smoothstep(.0,1.,fract(pos));\n    uvec2 d = uvec2(0,1);\n    \n    return\n        mix(\n        \tmix(\n                mix( hash1(coord3(p+d.xxx)), hash1(coord3(p+d.yxx)), f.x ),\n                mix( hash1(coord3(p+d.xyx)), hash1(coord3(p+d.yyx)), f.x ),\n                f.y\n            ),\n        \tmix(\n                mix( hash1(coord3(p+d.xxy)), hash1(coord3(p+d.yxy)), f.x ),\n                mix( hash1(coord3(p+d.xyy)), hash1(coord3(p+d.yyy)), f.x ),\n                f.y\n            ),\n            f.z\n        );\n}\n\n\n// catmull-rom texture sampler, from https://www.shadertoy.com/view/4tyGDD by Giliam de Carpentier\nvec4 SampleTextureBilinearlyAndUnpack(sampler2D tex, vec2 uv)\n{\n    vec4 sample_color = texture(tex, uv, 0.0);\n#ifdef PACK_SIGNED_TO_UNSIGNED\n    sample_color = 2.0 * sample_color - 1.0;\n#endif // PACK_SIGNED_TO_UNSIGNED\n    return sample_color;\n}\n \nvec4 SampleTextureCatmullRom4Samples(sampler2D tex, vec2 uv, vec2 texSize)\n{\n    // Based on the standard Catmull-Rom spline: w1*C1+w2*C2+w3*C3+w4*C4, where\n    // w1 = ((-0.5*f + 1.0)*f - 0.5)*f, w2 = (1.5*f - 2.5)*f*f + 1.0,\n    // w3 = ((-1.5*f + 2.0)*f + 0.5)*f and w4 = (0.5*f - 0.5)*f*f with f as the\n    // normalized interpolation position between C2 (at f=0) and C3 (at f=1).\n \n    // half_f is a sort of sub-pixelquad fraction, -1 <= half_f < 1.\n    vec2 half_f     = 2.0 * fract(0.5 * uv * texSize - 0.25) - 1.0;\n \n    // f is the regular sub-pixel fraction, 0 <= f < 1. This is equivalent to\n    // fract(uv * texSize - 0.5), but based on half_f to prevent rounding issues.\n    vec2 f          = fract(half_f);\n \n    vec2 s1         = ( 0.5 * f - 0.5) * f;            // = w1 / (1 - f)\n    vec2 s12        = (-2.0 * f + 1.5) * f + 1.0;      // = (w2 - w1) / (1 - f)\n    vec2 s34        = ( 2.0 * f - 2.5) * f - 0.5;      // = (w4 - w3) / f\n \n    // positions is equivalent to: (floor(uv * texSize - 0.5).xyxy + 0.5 +\n    // vec4(-1.0 + w2 / (w2 - w1), 1.0 + w4 / (w4 - w3))) / texSize.xyxy.\n    vec4 positions  = vec4((-f * s12 + s1      ) / (texSize * s12) + uv,\n                           (-f * s34 + s1 + s34) / (texSize * s34) + uv);\n \n    // Determine if the output needs to be sign-flipped. Equivalent to .x*.y of\n    // (1.0 - 2.0 * floor(t - 2.0 * floor(0.5 * t))), where t is uv * texSize - 0.5.\n    float sign_flip = half_f.x * half_f.y > 0.0 ? 1.0 : -1.0;\n \n    vec4 w          = vec4(-f * s12 + s12, s34 * f); // = (w2 - w1, w4 - w3)\n    vec4 weights    = vec4(w.xz * (w.y * sign_flip), w.xz * (w.w * sign_flip));\n \n    return SampleTextureBilinearlyAndUnpack(tex, positions.xy) * weights.x +\n           SampleTextureBilinearlyAndUnpack(tex, positions.zy) * weights.y +\n           SampleTextureBilinearlyAndUnpack(tex, positions.xw) * weights.z +\n           SampleTextureBilinearlyAndUnpack(tex, positions.zw) * weights.w;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Adaptive Exposure by Hazel Quantock\n// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n\n// blur the image so I can sample exposure locally\n\nconst vec2 exposureRadius = vec2(.03); // low values mean space and ground and horizon can all be exposed at once!\n// this adds a bit of a comic book feel to it - where details are emphasized more than overall brightness\n\nconst float globalExposure = .4; // 0.0 = use only nearby exposure, 1.0 = sample exposure over entire image, 0.5 = 50/50 blend\n\nvec2 BoxMuller( vec2 rand )\n{\n//    float r = sqrt(-2.*log(rand.x));\n    float a = tau * rand.y;\n\n// alternative curve, to hang onto small details AND do larger ones\nfloat r = -2.*log(max(.0001,rand.x));\n//float r = pow(-2.*log(rand.x),3.); // push it even further - weird\n    \n    return r*vec2(sin(a),cos(a));\n}\n\n\n// blurred image of Buffer A\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    /*would like it to be resolution independent\n\t=> take random samples from buf a spread over a gaussian (normal) distribution\n\tand feedback, so high res just takes longer to converge*/\n    // ooh box muller transform: https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\n\n    vec2 blurRadius = sqrt(iResolution.x*iResolution.y) * exposureRadius;\n    \n    fragColour = vec4(0);\n    const int numPasses = 10;\n    for ( int pass = 0; pass < numPasses; pass++ )\n    {\n        SeedRand( iFrame*numPasses+pass, fragCoord );\n    \n    \tvec2 tappos;\n        if ( rand() > globalExposure )\n        {\n        \ttappos = BoxMuller( rand2() ) * blurRadius;\n            tappos = clamp(fragCoord+tappos,vec2(0),iResolution.xy-1.);\n        }\n        else\n        {\n            tappos = rand2()*(iResolution.xy-1.);\n        }\n\n        fragColour += texelFetch( iChannel0, ivec2(tappos), 0 );\n\t}\n    \n    // this might need *.99 or something\n    if ( iFrame > 0 && iMouse.z <= 0. )\n    {\n        fragColour += texelFetch( iChannel1, ivec2(fragCoord), 0 );\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}