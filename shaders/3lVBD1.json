{
    "Shader": {
        "info": {
            "date": "1614268265",
            "description": "A reproduction of the shape of http://scp-wiki.wdfiles.com/local--files/scp-1968/bronzetorus.gif\nI was originally going to try to do the refractions too, but just getting the shape done was pretty advanced for me, so I won't work on this more yet.",
            "flags": 0,
            "hasliked": 0,
            "id": "3lVBD1",
            "likes": 2,
            "name": "SCP-1968 shape",
            "published": 3,
            "tags": [
                "raymarch",
                "torus",
                "scp",
                "scp1968"
            ],
            "usePreview": 0,
            "username": "DukeOfStraylight",
            "viewed": 90
        },
        "renderpass": [
            {
                "code": "// 0 = loop through all toruses to see which one's closest\n// 1 = use atan() to figure out which toruses might be closest, try two\n#define IMPLEMENTATION 1\n\nmat2 rotate(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nconst float pi = 3.14159;\nconst float tau = 2.*pi;\n\n// Just the tiniest bit of in-out easing\nfloat ssmooth(float z, float x) {\n  return x-sin(x*tau)*z;\n}\n\nconst float toruses = 7.;\nconst float twist = 3.;\n// Weird name, but: how much slower the inside moves than the outside.\n// Starts breaking optimizations at 0.08ish or so.\nconst float sinification = 0.06;\nconst vec2 scale = vec2(1.8, 2.5);\nconst float speed = 0.15;\n\n// czm_ prefixed functions from\n// https://github.com/CesiumGS/cesium/blob/master/Source/Shaders/Builtin/Functions/fastApproximateAtan.glsl\nfloat czm_fastApproximateAtan(float x) {\n    return x * (-0.1784 * x - 0.0663 * x * x + 1.0301);\n}\n\nfloat czm_fastApproximateAtan(float x, float y) {\n    // atan approximations are usually only reliable over [-1, 1], or, in our case, [0, 1] due to modifications.\n    // So range-reduce using abs and by flipping whether x or y is on top.\n    float t = abs(x); // t used as swap and atan result.\n    float opposite = abs(y);\n    float adjacent = max(t, opposite);\n    opposite = min(t, opposite);\n\n    t = czm_fastApproximateAtan(opposite / adjacent);\n\n    // Undo range reduction\n    t = (abs(y) > abs(x)) ? (pi*0.5) - t : t;\n    t = (x < 0.0) ? pi - t : t;\n    t = (y < 0.0) ? -t : t;\n    return t;\n}\n\n\nfloat scene(vec3 p) {\n    p.y = abs(p.y);\n    float a = atan(p.x, p.z)*(twist/tau/toruses);\n    vec2 q = vec2(length(p.xz)-4.,p.y-4.);\n\n#if IMPLEMENTATION == 0\n    float minl = 10000.;\n    for (float n = 0.; n < 1.; n += (1./toruses)) {\n        float t = iTime*speed - a + n;\n        t = ssmooth(sinification, t) * tau + pi;\n        vec2 ep = vec2(cos(t), sin(t))*scale;\n        vec2 l = q-ep;\n        minl = min(minl, dot(l, l));\n    }\n#endif\n\n#if IMPLEMENTATION == 1\n    // Loopless implementation: Make two reasonable guesses\n    // about which torus is actually closest, and only draw those.\n    // This does slightly warp space in the middle, but not so much\n    // as to cause any artifacts that I can see.\n    // No need for high precision in our atan here because we're just\n    // using it to figure out what general neighborhood we're in;\n    // we're also using the somewhat squished q without normalizing it\n    // first, based on the guess that that's less work overall\n    float uta = (czm_fastApproximateAtan(q.x, q.y) + pi)/tau;\n    // Just assume that ssmooth(sinification, x) =~ x (i.e. that the toruses\n    // are uniformly spaced), again because we don't need high precision\n    float nt = (uta - iTime*speed + a)*toruses;\n    vec2 ns = vec2(floor(nt), ceil(nt))/toruses;\n\n    vec2 t = iTime*speed - a + ns;\n    t = vec2(ssmooth(sinification, t.x), ssmooth(sinification, t.y)) * tau + pi;\n    vec2 epx = vec2(cos(t.x), sin(t.x)) * scale;\n    vec2 lx = q-epx;\n    vec2 epy = vec2(cos(t.y), sin(t.y)) * scale;\n    vec2 ly = q-epy;\n    float minl = min(dot(lx, lx), dot(ly, ly));\n#endif\n\n    float od = sqrt(minl) - .5;\n    return od;\n}\n\n// iq's tetrahedral normals from\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.01; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*scene( p + k.xyy*h ) + \n                      k.yyx*scene( p + k.yyx*h ) + \n                      k.yxy*scene( p + k.yxy*h ) + \n                      k.xxx*scene( p + k.xxx*h ) );\n}\n\n// stolen from wherever, http://glslsandbox.com/e#48598.1 I think\nfloat hash21(vec2 p) {\n  p = fract(p * vec2(233.34, 851.74));\n  p += dot(p, p + 23.45);\n  return fract(p.x * p.y);\n}\n\nconst vec3 uglybrown = vec3(.4, .4, .25);\nconst vec3 lovelyblue = 1.-uglybrown;\n\nvec2 castRay(vec3 ro, vec3 rd, float t) {\n    float minD = 20.;\n    for (int n = 0; n < 200; n++) {\n        vec3 p = ro + t * rd;\n        float d = scene(p);\n        t += d;\n        minD = min(minD, d);\n        if (d < 0.001 || d > 20.) {\n            break;\n        }\n    }\n    return vec2(minD, t);\n}\n\nvec3 sceneColor(vec3 ro, vec3 rd, float initT) {\n    vec2 ray = castRay(ro, rd, initT);\n    float minD = ray.x;\n    float t = ray.y;\n\n    vec3 p = ro + t * rd;\n    vec2 floorHit = ro.xz - ro.y/rd.y * rd.xz;\n    float floorBrightness = smoothstep(7., 4., length(floorHit))*0.8;\n    if (minD < 0.001) {\n        vec3 normal = normal(p);\n        if (p.y > 0.) {\n            float d = dot(normal, normalize(vec3(1, 0.2, 0.2)));\n            d = mix(d, 1.0, 0.4);\n            return mix(vec3(.4, .7, 1.), vec3(.1, .3, 1.), 1.-d);\n        } else {\n            float d = -dot(normal, rd);\n            d *= d * d;\n            vec3 c = mix(vec3(d), uglybrown, 0.9);\n            return mix(c, vec3(1), floorBrightness);\n        }\n    } else {\n        return mix(lovelyblue, vec3(1), floorBrightness);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0, 9, 14);\n    vec3 rd = normalize(vec3(uv.x, uv.y-.4, -1));\n    fragColor = vec4(sceneColor(ro, rd, 0.), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}