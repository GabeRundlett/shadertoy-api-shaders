{
    "Shader": {
        "info": {
            "date": "1493856498",
            "description": "This is a modification of reinder's path tracer code, combining with BRDF microfacet importance sampling, as described in the paper in the comments. \n\nMouse.x controls the roughness of the left sphere",
            "flags": 0,
            "hasliked": 0,
            "id": "4s2cWK",
            "likes": 25,
            "name": "BRDF Microfacet Sampling",
            "published": 3,
            "tags": [
                "light",
                "pathtracer",
                "sampling",
                "brdf"
            ],
            "usePreview": 0,
            "username": "culdevu",
            "viewed": 2227
        },
        "renderpass": [
            {
                "code": "// BRDF Microfacet Sampling\n// CulDeVu, 2017\n//\n// This technique is based on the paper \"Microfacet Models for Refraction\n// through Rough Surfaces\", found here: \n// https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n//\n// Or, if that's not your thing, I wrote a concise little blog post explaining\n// the steps: http://djtaylor.me/blog/2016/microfacet-dummies/\n// \n// Based on the original shader by Reinder Nijhoff:\n// https://www.shadertoy.com/view/4tl3z4\n//\n\n#define PI 3.14159\n\n#define eps 0.0001\n#define EYEPATHLENGTH 4\n#define SAMPLES 2\n\n// uncomment this to get the light sampling window from Reinder's shader\n//#define SHOWSPLITLINE\n#define FULLBOX\n\n#define ANIMATENOISE\n\n#define LIGHTCOLOR vec3(16.86, 10.76, 8.2)*1.3\n#define WHITECOLOR vec3(.7295, .7355, .729)*0.7\n#define GREENCOLOR vec3(.117, .4125, .115)*0.7\n#define REDCOLOR vec3(.611, .0555, .062)*0.7\n\n#define alpha max(0.001, iMouse.x / (2.*iResolution.x))\n\nfloat hash1(inout float seed) {\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\nvec2 hash2(inout float seed) {\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3(inout float seed) {\n    return fract(sin(vec3(seed+=0.1,seed+=0.1,seed+=0.1))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n//-----------------------------------------------------\n// Intersection functions (by iq)\n//-----------------------------------------------------\n\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\n    return (pos-sph.xyz)/sph.w;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n\n\tfloat s = sqrt(h);\n\tfloat t1 = -b - s;\n\tfloat t2 = -b + s;\n\t\n\treturn t1 < 0.0 ? t2 : t1;\n}\n\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\n    return obj.xyz;\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\n}\n\n//-----------------------------------------------------\n// scene\n//-----------------------------------------------------\n\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {\n  \tvec2 r = hash2(seed);\n    \n\tvec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tvec3  vv = cross( uu, n );\n\t\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.2831*r.x); \n\tfloat ry = ra*sin(6.2831*r.x);\n\tfloat rz = sqrt( 1.0-r.y );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n    \n    return normalize( rr );\n}\n\nvec3 randomSphereDirection(inout float seed) {\n    vec2 r = hash2(seed)*6.2831;\n\tvec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));\n\treturn dr;\n}\n\nvec3 randomHemisphereDirection( const vec3 n, inout float seed ) {\n\tvec3 dr = randomSphereDirection(seed);\n\treturn dot(dr,n) * dr;\n}\n\n//-----------------------------------------------------\n// light\n//-----------------------------------------------------\n\nvec4 lightSphere;\n\nvoid initLightSphere( float time ) {\n\tlightSphere = vec4( 3.0+2.*sin(time),2.8+2.*sin(time*0.9),3.0+4.*cos(time*0.7), .5 );\n}\n\nvec3 sampleLight( const in vec3 ro, inout float seed ) {\n    vec3 n = randomSphereDirection( seed ) * lightSphere.w;\n    return lightSphere.xyz + n;\n}\n\n//-----------------------------------------------------\n// scene\n//-----------------------------------------------------\n\nvec2 intersect( in vec3 ro, in vec3 rd, inout vec3 normal ) {\n\tvec2 res = vec2( 1e20, -1.0 );\n    float t;\n\t\n\tt = iPlane( ro, rd, vec4( 0.0, 1.0, 0.0,0.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = vec3( 0., 1., 0.); }\n\tt = iPlane( ro, rd, vec4( 0.0, 0.0,-1.0,8.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = vec3( 0., 0.,-1.); }\n    t = iPlane( ro, rd, vec4( 1.0, 0.0, 0.0,0.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 2. ); normal = vec3( 1., 0., 0.); }\n#ifdef FULLBOX\n    t = iPlane( ro, rd, vec4( 0.0,-1.0, 0.0,5.49) ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = vec3( 0., -1., 0.); }\n    t = iPlane( ro, rd, vec4(-1.0, 0.0, 0.0,5.59) ); if( t>eps && t<res.x ) { res = vec2( t, 3. ); normal = vec3(-1., 0., 0.); }\n#endif\n\n\tt = iSphere( ro, rd, vec4( 1.5,1.0, 2.7, 1.0) ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = nSphere( ro+t*rd, vec4( 1.5,1.0, 2.7,1.0) ); }\n    t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0, 1.0) ); if( t>eps && t<res.x ) { res = vec2( t, 6. ); normal = nSphere( ro+t*rd, vec4( 4.0,1.0, 4.0,1.0) ); }\n    t = iSphere( ro, rd, lightSphere ); if( t>eps && t<res.x ) { res = vec2( t, 0.0 );  normal = nSphere( ro+t*rd, lightSphere ); }\n\t\t\t\t\t  \n    return res;\t\t\t\t\t  \n}\n\nbool intersectShadow( in vec3 ro, in vec3 rd, in float dist ) {\n    float t;\n\t\n\tt = iSphere( ro, rd, vec4( 1.5,1.0, 2.7,1.0) );  if( t>eps && t<dist ) { return true; }\n    t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0,1.0) );  if( t>eps && t<dist ) { return true; }\n\n    return false; // optimisation: planes don't cast shadows in this scene\n}\n\n//-----------------------------------------------------\n// materials\n//-----------------------------------------------------\n\nvec3 matColor( const in float mat ) {\n\tvec3 nor = vec3(1.0, 1.0, 1.0);\n\t\n\tif( mat<3.5 ) nor = REDCOLOR;\n    if( mat<2.5 ) nor = GREENCOLOR;\n\tif( mat<1.5 ) nor = WHITECOLOR;\n\tif( mat<0.5 ) nor = LIGHTCOLOR;\n\t\t\t\t\t  \n    return nor;\n}\n\nbool matIsSpecular( const in float mat ) {\n    return mat > 4.5;\n}\n\nbool matIsLight( const in float mat ) {\n    return mat < 0.5;\n}\n\n// -------------------------------------------------------\n// cook torrace microfacet functions\n// -------------------------------------------------------\nfloat BeckmanD(vec3 m, vec3 norm)\n{\n\tfloat NDotM = dot(m, norm);\n\t\n\tfloat positivity = (NDotM > 0.) ? 1.0f : 0.0f;\n\n\tfloat theta_m = clamp(acos(NDotM), -PI / 2. + 0.001f, PI / 2. - 0.001f);\n\tfloat coef = -pow(tan(theta_m), 2.) / (alpha * alpha);\n\tfloat denom = pow(alpha, 2.) * pow(NDotM, 4.);\n\tif (denom < 0.001)\n\t\tdenom = 0.001;\n\tfloat total = positivity * max(0.001, exp(coef)) / (PI * denom);\n\treturn total;\n}\nfloat SmithG1Approx(vec3 v, vec3 m, vec3 norm)\n{\t\n\tfloat VDotM = dot(v, m);\n\tfloat VDotN = dot(v, norm);\n\n\tfloat theta_v = acos(VDotN);\n\tfloat a = 1. / (alpha * tan(theta_v));\n\n\tfloat positivity = (VDotM / VDotN > 0.) ? 1.0 : 0.0;\n\n\tif (a < 1.6)\n\t\treturn (3.535 * a + 2.181 * a * a) / (1. + 2.276 * a + 2.577 * a * a);\n\telse\n\t\treturn 1.;\n}\n\nvec3 BRDFMicro(vec3 norm, vec3 lDir, vec3 vDir)\n{\n    vec3 hDir = normalize(lDir + vDir);\n    \n    float LDotH = max(0.001, dot(lDir, hDir));\n\tfloat NDotH = max(0.001, dot(norm, hDir));\n\n\tfloat LDotN = dot(lDir, norm);\n\tfloat ODotN = dot(vDir, norm);\n\n\tvec3 FresnelTerm = vec3(1.); // not calculating because it doesn't play nice with the light sampling\n    // probably not physically correct though :(\n\n\tfloat DistributionTerm = BeckmanD(hDir, norm);\n\n\tfloat GeometryTerm = SmithG1Approx(lDir, hDir, norm) * SmithG1Approx(vDir, hDir, norm);\n\n\tfloat denom = max(0.001, 4. * LDotN * ODotN);\n\n\tvec3 f_microfacet = FresnelTerm * GeometryTerm * DistributionTerm / denom;\n\n\treturn f_microfacet;\n}\n\n//-----------------------------------------------------\n// brdf\n//-----------------------------------------------------\nvec3 getTangent(vec3 norm)\n{\n\tvec3 tangent;\n\tvec3 c1 = cross(norm, vec3(0.0, 0.0, 1.0));\n\tvec3 c2 = cross(norm, vec3(0.0, 1.0, 0.0));\n\tif (dot(c1, c1) > dot(c2, c2))\n\t\ttangent = c1;\n\telse\n\t\ttangent = c2;\n\treturn tangent;\n}\n\nvec3 importanceBRDFHalf(float mat, vec3 norm, vec3 oDir, inout bool specularBounce, inout float seed)\n{\n    if(!matIsSpecular( mat ))\n    {\n        vec3 iDir = cosWeightedRandomHemisphereDirection(norm, seed);\n        specularBounce = false;\n        return normalize(oDir + iDir);\n    }\n    \n    specularBounce = true;\n        \n    float r1 = hash1(seed);\n    float r2 = hash1(seed);\n    float theta_m = atan(sqrt(-alpha * alpha * log(1.0 - r1)));\n    float phi_m = 2. * PI * r2;\n\n    float mY = cos(theta_m);\n    float mX = cos(phi_m) * sin(theta_m);\n    float mZ = sin(phi_m) * sin(theta_m);\n\n    vec3 tangent = getTangent(norm);\n    vec3 bitangent = cross(norm, tangent);\n    vec3 m = normalize(tangent * mX + norm * mY + bitangent * mZ);\n\n    return m;\n}\n\n\n\n//-----------------------------------------------------\n// eyepath\n//-----------------------------------------------------\n\nvec3 traceEyePath( in vec3 ro, in vec3 rd, const in bool directLightSampling, inout float seed ) {\n    vec3 tcol = vec3(0.);\n    vec3 fcol  = vec3(1.);\n    \n    bool specularBounce = true;\n    \n    for( int j=0; j<EYEPATHLENGTH; ++j ) {\n        vec3 normal;\n        \n        vec2 res = intersect( ro, rd, normal );\n        if( res.y < -0.5 ) {\n            return tcol;\n        }\n        \n        if( matIsLight( res.y ) ) {\n            if( directLightSampling ) {\n            \tif( specularBounce ) tcol += fcol*LIGHTCOLOR;\n            } else {\n                tcol += fcol*LIGHTCOLOR;\n            }\n            return tcol;\n        }\n        \n        vec3 oDir = -rd;\n        vec3 m = importanceBRDFHalf(res.y, normal, -rd, specularBounce, seed);\n        rd = reflect(rd, m);\n        \n        // !!! THESE LINES RIGHT HERE. PLEASE CORRECT IF WRONG !!!\n        // essentially, the half vector sampling that happens above\n        // can produce microfacet normals that don't actually make\n        // sense, making the next ray go below the surface normal when\n        // they're not supposed to. I don't know how to combat this,\n        // so I just do this. I don't know if this biases the render,\n        // please mention in the comments if it does. Thanks!\n        if (dot(rd, normal) < 0.)\n            rd *= -1.;\n        \n        vec3 iDir = rd;\n        \n        if (!specularBounce)\n        {\n        \tfcol *= matColor( res.y );\n        }\n        else\n        {\n            float G = SmithG1Approx(iDir, m, normal) * SmithG1Approx(oDir, m, normal);\n            fcol *= vec3(1.,1.,1.) * G * dot(iDir, m) / (dot(iDir, normal) * dot(m, normal));\n        }\n\n        ro = ro - res.x * oDir;\n        vec3 ld = sampleLight( ro, seed ) - ro;\n        \n        if( directLightSampling ) {\n\t\t\tvec3 nld = normalize(ld);\n            if(j < EYEPATHLENGTH-1 && !intersectShadow( ro, nld, length(ld)) ) {\n\n                float cos_a_max = sqrt(1. - clamp(lightSphere.w * lightSphere.w / dot(lightSphere.xyz-ro, lightSphere.xyz-ro), 0., 1.));\n                float weight = 2. * PI * (1. - cos_a_max);\n                \n                if (!matIsSpecular( res.y ))\n                \ttcol += (fcol / PI * LIGHTCOLOR) * (weight * clamp(dot( nld, normal ), 0., 1.));\n                //else\n                    //tcol += LIGHTCOLOR * BRDFMicro(normal, ld, oDir) * (weight * clamp(dot( nld, normal ), 0., 1.));\n            }\n        }\n    }\n    if (tcol != tcol)\n        return vec3(1.,0., 0.);\n    return tcol;\n}\n\n//-----------------------------------------------------\n// main\n//-----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    \n\tfloat splitCoord = iMouse.y;\n#ifdef SHOWSPLITLINE\n    bool directLightSampling = fragCoord.y < splitCoord;\n#else\n    bool directLightSampling = true;\n#endif\n    \n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n#ifdef ANIMATENOISE\n    float seed = p.x + p.y * 3.43121412313 + fract(1.12345314312*iTime);\n#else\n    float seed = p.x + p.y * 3.43121412313;\n#endif\n    \n    vec3 ro = vec3(2.78, 2.73, -8.00);\n    vec3 ta = vec3(2.78, 2.73,  0.00);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    //-----------------------------------------------------\n    // render\n    //-----------------------------------------------------\n\n    vec3 col = vec3(0.0);\n    vec3 tot = vec3(0.0);\n    vec3 uvw = vec3(0.0);\n    \n    for( int a=0; a<SAMPLES; a++ )\n    {\n        vec2 rpof = 4.*(hash2(seed)-vec2(0.5)) / iResolution.xy;\n\t    vec3 rd = normalize( (p.x+rpof.x)*uu + (p.y+rpof.y)*vv + 3.0*ww );\n        \n        vec3 rof = ro;\n        \n        initLightSphere( iTime );\n        \n        col = traceEyePath( rof, rd, directLightSampling, seed );\n\n        tot += col;\n        \n        seed = mod( seed*1.1234567893490423, 13. );\n    }\n    \n    tot /= float(SAMPLES);\n    \n#ifdef SHOWSPLITLINE\n\tif (abs(fragCoord.y - splitCoord) < 1.0) {\n\t\ttot = vec3(1.0, 0.0, 0.0);\n\t}\n#endif\n    \n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\n\n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}