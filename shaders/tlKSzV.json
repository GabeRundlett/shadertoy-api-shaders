{
    "Shader": {
        "info": {
            "date": "1610101371",
            "description": "Boolean logic circuits without erasure of bits.",
            "flags": 32,
            "hasliked": 0,
            "id": "tlKSzV",
            "likes": 3,
            "name": "Boolean LogicWithoutBitErasure",
            "published": 3,
            "tags": [
                "computation"
            ],
            "usePreview": 0,
            "username": "brianhaak",
            "viewed": 311
        },
        "renderpass": [
            {
                "code": "// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine (vec2 a, vec2 b) {\n    \n     \n\tb = a - b;\n\tfloat h = clamp(dot(a, b)/ dot(b, b), 0.0, 1.0);\n    \n    return length(a - b * h);\n}\n\nvec4 render (in vec2 fragCoord) {\n\n    vec4 fragColor = vec4(0.0);\n    \n    // Use 1-byte color values for compatibility with mobile\n    vec4 gpgpu_data = texture(iChannel0, 0.3333 * fragCoord/iResolution.xy);\n    //vec4 gpgpu_data = texture(iChannel0, 0.5 * fragCoord/iResolution.xy);\n    \n    Element elt = elementFromTexel(gpgpu_data);\n    \n    // iFrame\n    // iChannel0\n    // iMouse zw click\n    \n    \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // fragColor = vec4(fragCoord.x - iMouse.x, fragCoord.y - iMouse.y, gpgpu_data.x, 1.0);\n                     \n\n    // Screen coordinates. I've put a cap on the fullscreen resolution to stop\n    // the pattern looking too blurred out.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/min(650., iResolution.y);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n   \n    // Position with some scrolling, and screen rotation to level the pattern.\n    vec2 p = rot2(3.14159/12.)*uv + vec2(.8660254, .5)*1./16.;\n\n    // Scaling constant.\n    //const float gSc = 64.0;//0.25;//8.0;\n    const float gSc = 8.0;\n    p *= gSc;\n    \n    vec2 s = floor(p + (p.x + p.y) * 0.36602540378); // Skew the current point.\n    \n    p -= s - (s.x + s.y) * .211324865; // Use it to attain the vector to the base vertex (from p).\n    \n    // Determine which triangle we're in. Much easier to visualize than the 3D version.\n    float i = p.x < p.y? 1.0 : 0.0; // Apparently, faster than: i = step(p.y, p.x);\n    vec2 ioffs = vec2(1.0 - i, i);\n    \n    // Vectors to the other two triangle vertices.\n    vec2 ip0 = vec2(0);\n    vec2 ip1 = ioffs - 0.2113248654;\n    vec2 ip2 = vec2(0.577350269);\n\n    // Displaying the 2D simplex grid. Basically, we're rendering lines between\n    // each of the three triangular cell vertices to show the outline of the \n    // cell edges.\n    float tri = min(min(distLine(p - ip0, p - ip1), distLine(p - ip1, p - ip2)), \n                  distLine(p - ip2, p - ip0));\n    // Adding the triangle grid to the d5 distance field value.\n    float d5 = min(1e5, tri);\n                  \n    // Initial color.\n    vec3 col = vec3(0.5, 1.0, 1.0);\n    \n    // Smoothing factor.\n    float sf = .004;\n                  \n    \n    // Triangle grid overlay.\n    d5 /= gSc;\n    //col = mix(vec3(0.33333 * (elt.outA + elt.outB + elt.outC)), vec3(1.0, 1.0, 1.0), (1. - smoothstep(0., sf, d5)) * 0.35);\n    \n    col = vec3(0.33333 * (elt.outA + elt.outB + elt.outC));\n    //col = vec3(0.33333 * (elt.outA + elt.outB + elt.outC), 0.33333 * (elt.outA + elt.outB + elt.outC), elt.switchCtrl / 6.0);\n    \n    //col = vec3(elt.outB, elt.outA, elt.outC);\n    \n    return vec4(col, 1.0);\n    \n    \n    //fragColor = vec4(gpgpu_data.rgba);//, 1.0);\n    \n    //return vec4(mix(col, vec3(0.), (1. - smoothstep(0., sf, fragColor.arg))), 0.95);\n\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n    fragColor = render(fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Random number generator. Borrowed from https://www.shadertoy.com/view/wltcRS\n//\n// Usage:\n    \n//   rng_initialize(fragCoord, iFrame);\n    \n//   fragColor = rand4();\n\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec3 rand3()\n{\n    pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\n//random blue noise sampling pos\nivec2 shift2()\n{\n    pcg4d(s1); \n    return (pixel + ivec2(s1.xy%0x0fffffffu))%1024;\n}\n\n\n\n/*\n\n IO is organized in blocks of 32x32 texels,\n only one block is read at a time,\n and only one block is written at a time.\n\n Memory organization (FIFO depth 3 bits):\n\n\n /^^^^^^^^^^^^^^T^^^^^^^^^^^^^^^^^^^^^^^T^^^^^^^^^^^^^^^^^^^^^^^T^^^^^\\\n | computer's   | input (32x32 texels)  | input (32x32 texels)  | ... |\n |              |-----------------------|-----------------------| ... |\n |   core       | input (32x32 texels)  | output (32x32 texels) | ... |\n |              |-----------------------|-----------------------| ... |\n |--------------| output (32x32 texels) | output (32x32 texels) | ... |\n |              \\-----------------------|-----------------------/ ... |\n |                                                                    |\n \\____________________________________________________________________/\n\nNote that computer's core size is a multiple of 32, due to simultaneous use\nof the entire 32-bits slice within a texel of IO.\nIO happens only on the edges of the core.\n\n*/\n\nfloat ioBlockNumber (\n    in vec2 fragCoord,\n    out float ioBlockX,\n    out float ioBlockY) {\n\n    // exclude the core\n    if (fragCoord.x < COMPUTER_WIDTH && fragCoord.y < COMPUTER_HEIGHT) {\n        return -1.0;\n    }\n    \n    // Are there IO blocks on the right?\n    \n    float blocksOnTheRight = floor((iResolution.x - COMPUTER_WIDTH) / 32.0);\n    float blocksWidth = floor(iResolution.x / 32.0);\n    float totalBlocksOnTheRight = blocksOnTheRight * COMPUTER_HEIGHT / 32.0;\n\n    // Decimal part here is texel coordinate of the IO block\n    float row;\n    float column;\n\n    // IO block number\n    float block;\n\n    if (blocksOnTheRight > 0.0) {\n        if (fragCoord.y < COMPUTER_HEIGHT) {\n        \n            column = (fragCoord.x - COMPUTER_WIDTH) / 32.0;\n            if (column > blocksOnTheRight) {\n                // completely ignore that area\n                discard;\n            }\n            \n            row = fragCoord.y / 32.0;\n            block = floor(row) * blocksOnTheRight + floor(column);\n         } else {\n            column = fragCoord.x / 32.0;\n            if (column > blocksWidth) {\n                discard;\n            }\n            row = (fragCoord.y - COMPUTER_HEIGHT) / 32.0;\n            block = totalBlocksOnTheRight + floor(row) * blocksWidth + floor(column);\n         }\n    } else {\n        // The rest is always attempted to fill by blocks. Otherwise, nothing will work.\n        column = fragCoord.x / 32.0;\n        if (column > blocksWidth) {\n            discard;\n        }\n        row = (fragCoord.y - COMPUTER_HEIGHT) / 32.0;\n        \n        block = floor(row) * blocksWidth + floor(column);\n    }\n    \n    const float totalBlocks = IO_FIFO_DEPTH_BITS * 2.0;\n    if (block > totalBlocks - 1.0) {\n        discard;\n    }\n    \n    ioBlockY = row - floor(row);\n    ioBlockX = column - floor(column);\n   \n    return block;\n}\n\n\nvec4 writeIoBlock(\n    float ioBlock,\n    float ioBlockX,\n    float ioBlockY) {\n    \n    vec4 gpgpu_data = texture(iChannel0, vec2(ioBlockX, ioBlockY));\n    \n    return gpgpu_data;\n}\n\nstruct Direction {\n  lowp float left;\n  lowp float leftTop;\n  lowp float rightTop;\n  lowp float right;\n  lowp float rightBottom;\n  lowp float leftBottom;\n};  \n    \nDirection isDirection (float dir) {\n    \n  Direction rd;\n  rd.left = whenGt(dir, 0.5) * whenGt(1.5, dir);\n  rd.leftTop = whenGt(dir, 1.5) * whenGt(2.5, dir);\n  rd.rightTop = whenGt(dir, 2.5) * whenGt(3.5, dir);\n  rd.right = whenGt(dir, 3.5) * whenGt(4.5, dir);\n  rd.rightBottom = whenGt(dir, 4.5) * whenGt(5.5, dir);\n  rd.leftBottom = whenGt(dir, 5.5) * whenGt(6.5, dir);\n  \n  return rd;\n}\n\nlowp vec2 ctrlOffset (float dir) {\n    \n  return vec2(-2.0,  0.0) * whenGt(dir, 0.5) * whenGt(1.5, dir) +\n         vec2(-1.0, -1.0) * whenGt(dir, 1.5) * whenGt(2.5, dir) +\n         vec2( 1.0, -1.0) * whenGt(dir, 2.5) * whenGt(3.5, dir) +\n         vec2( 2.0,  0.0) * whenGt(dir, 3.5) * whenGt(4.5, dir) +\n         vec2( 1.0,  1.0) * whenGt(dir, 4.5) * whenGt(5.5, dir) +\n         vec2(-1.0,  1.0) * whenGt(dir, 5.5) * whenGt(6.5, dir);\n}\n\nbool triDownSwitchingCauseBit (float dir, in Element switchingElement) {\n\n    return whenGt(switchingElement.outB,  0.5) * whenGt(dir, 0.5) * whenGt(2.5, dir) +\n           whenGt(switchingElement.outC,  0.5) * whenGt(dir, 2.5) * whenGt(4.5, dir) +\n           whenGt(switchingElement.outA,  0.5) * whenGt(dir, 4.5) * whenGt(6.5, dir) > 0.5;\n}\n\nbool triUpSwitchingCauseBit (float dir, in Element switchingElement) {\n\n    return whenGt(switchingElement.outA,  0.5) *  whenGt(dir, 1.5) * whenGt(3.5, dir) +\n           whenGt(switchingElement.outB,  0.5) *  whenGt(dir, 3.5) * whenGt(5.5, dir) +\n           whenGt(switchingElement.outC,  0.5) * (\n               whenGt(dir, 5.5) * whenGt(6.5, dir)\n             + whenGt(dir, 0.5) * whenGt(1.5, dir)\n           ) > 0.5;\n}\n\nlowp vec3 outFromPerm (float perm, float lr, float rl, float middle) {\n    // If triangle is down, then rl is right, otherwise it's left\n    // if triangle is down, then lr is left, otherwise it's right\n    return vec3(\n        middle * whenGt(perm, 0.5) * whenGt(2.5, perm) +\n        rl * whenGt(perm, 2.5) * whenGt(4.5, perm) +\n        lr * whenGt(perm, 4.5) * whenGt(6.5, perm),\n        \n        rl * whenGt(perm, 0.5) * whenGt(1.5, perm) +\n        lr * whenGt(perm, 1.5) * whenGt(2.5, perm) +\n        middle * whenGt(perm, 2.5) * whenGt(3.5, perm) +\n        lr * whenGt(perm, 3.5) * whenGt(4.5, perm) +\n        middle * whenGt(perm, 4.5) * whenGt(5.5, perm) +\n        rl * whenGt(perm, 5.5) * whenGt(6.5, perm),\n        \n        lr * whenGt(perm, 0.5) * whenGt(1.5, perm) +\n        rl * whenGt(perm, 1.5) * whenGt(2.5, perm) +\n        lr * whenGt(perm, 2.5) * whenGt(3.5, perm) +\n        middle * whenGt(perm, 3.5) * whenGt(4.5, perm) +\n        rl * whenGt(perm, 4.5) * whenGt(5.5, perm) +\n        middle * whenGt(perm, 5.5) * whenGt(6.5, perm)\n    );\n}\n\n\nlowp vec3 triUpOutFromPerm (float perm, in Element left, in Element right, in Element middle, in vec2 fragCoord) {\n\n    if (fragCoord.x < 0.5) {\n        // Left edge\n        \n    } else if (fragCoord.x > (COMPUTER_WIDTH - 1.0)) {\n        // Right edge\n        lowp float ioBit = 1.0;\n        return outFromPerm(perm, ioBit, left.outB, middle.outA);\n    }\n        \n    return outFromPerm(perm, right.outC, left.outB, middle.outA);\n/*\n    return vec3(\n        middle.outA * whenGt(perm, 0.5) * whenGt(2.5, perm) +\n        left.outB * whenGt(perm, 2.5) * whenGt(4.5, perm) +\n        right.outC * whenGt(perm, 4.5) * whenGt(6.5, perm),\n        \n        left.outB * whenGt(perm, 0.5) * whenGt(1.5, perm) +\n        right.outC * whenGt(perm, 1.5) * whenGt(2.5, perm) +\n        middle.outA * whenGt(perm, 2.5) * whenGt(3.5, perm) +\n        right.outC * whenGt(perm, 3.5) * whenGt(4.5, perm) +\n        middle.outA * whenGt(perm, 4.5) * whenGt(5.5, perm) +\n        left.outB * whenGt(perm, 5.5) * whenGt(6.5, perm),\n        \n        right.outC * whenGt(perm, 0.5) * whenGt(1.5, perm) +\n        left.outB * whenGt(perm, 1.5) * whenGt(2.5, perm) +\n        right.outC * whenGt(perm, 2.5) * whenGt(3.5, perm) +\n        middle.outA * whenGt(perm, 3.5) * whenGt(4.5, perm) +\n        left.outB * whenGt(perm, 4.5) * whenGt(5.5, perm) +\n        middle.outA * whenGt(perm, 5.5) * whenGt(6.5, perm)\n    );\n    */\n}\n\n\nElement computeElement (in Element old, in vec2 fragCoord, float fifoRwPtr) {\n\n    Element elt = old;\n    \n    // Switching cause bit:\n    Element switchingCause = elementFromTexel(texture(iChannel0, (fragCoord + ctrlOffset(elt.switchCtrl))/iResolution.xy));\n    \n    // Fetch neighbor elements or IO surface bits\n    vec4 gpgpu_data_left = texture(iChannel0, (fragCoord - vec2(1.0, 0.0))/iResolution.xy);\n    vec4 gpgpu_data_right = texture(iChannel0, (fragCoord + vec2(1.0, 0.0))/iResolution.xy);\n    \n    Element left = elementFromTexel(gpgpu_data_left);\n    Element right = elementFromTexel(gpgpu_data_right);\n\n    // Rotate parent pointer\n    elt.parent = old.parent + 1.0 > 3.5 ? 0.0 : old.parent + 1.0;\n    \n    lowp vec2 odd = vec2(int(fragCoord.x) % 2, int(fragCoord.y) % 2);\n\n    \n    \n    // lowp vec2 switchingCauseOffset;\n    \n    if (abs(odd.x - odd.y) < 0.5) {\n    \n        /* Both this triangle and switchingCause point down:\n           ______\n           \\  A /\n           C\\  /B\n             \\/\n        */\n        \n        vec4 gpgpu_data_middle = texture(iChannel0, (fragCoord + vec2(0.0, -1.0))/iResolution.xy);\n        Element middle = elementFromTexel(gpgpu_data_middle);\n        \n        lowp vec3 res;\n        \n        float perm = triDownSwitchingCauseBit(elt.switchCtrl, switchingCause)\n            ? elt.wiring1\n            : elt.wiring0;\n        \n        if (fragCoord.x < 1.0) {\n            // Left edge\n            \n            vec4 gpgpu_data_io = texture(iChannel0,\n                // TODO: read actual IO coordinate!!! (this is a fake rn)\n                vec2(\n                    fifoRwPtr * 32.0 + COMPUTER_WIDTH + (fragCoord.y / 32.0),\n                    0.0\n                    \n                ) / iResolution.xy);\n\n            Array32Bits io_bits = unpack_32_bits(gpgpu_data_io * 255.0);\n            \n            lowp float ioBit = io_bits.bit[int(fragCoord.y) % 32];\n            \n            res = outFromPerm(perm, ioBit, right.outB, middle.outA);\n            \n        } else if (fragCoord.x > (COMPUTER_WIDTH - 1.0)) {\n            // Right edge\n            vec4 gpgpu_data_io = texture(iChannel0,\n                // TODO: read actual IO coordinate!!! (this is a fake rn)\n                vec2(\n                    fifoRwPtr * 32.0 + COMPUTER_WIDTH + (fragCoord.y / 32.0),\n                    1.0\n                    \n                ) / iResolution.xy);\n\n            Array32Bits io_bits = unpack_32_bits(gpgpu_data_io * 255.0);\n            \n            lowp float ioBit = io_bits.bit[int(fragCoord.y) % 32];\n            res = outFromPerm(perm, left.outC, ioBit, middle.outA);\n        } else {\n            res = outFromPerm(perm, left.outC, right.outB, middle.outA);\n        }\n        \n        elt.outA = res.x;\n        elt.outB = res.y;\n        elt.outC = res.z;\n        \n    } else {\n    \n        /* The triangles point up:\n\n             /\\\n           B/  \\C\n           /____\\\n             A        */\n             \n        vec4 gpgpu_data_middle = texture(iChannel0, (fragCoord + vec2(0.0, 1.0))/iResolution.xy);\n        Element middle = elementFromTexel(gpgpu_data_middle);\n\n        lowp vec3 res;\n        \n        float perm = triUpSwitchingCauseBit(elt.switchCtrl, switchingCause)\n            ? elt.wiring1\n            : elt.wiring0;\n        \n        if (fragCoord.x < 1.0) {\n            // Left edge\n            vec4 gpgpu_data_io = texture(iChannel0,\n                // TODO: read actual IO coordinate!!! (this is a fake rn)\n                vec2(\n                    fifoRwPtr * 32.0 + COMPUTER_WIDTH + (fragCoord.y / 32.0),\n                    2.0\n                    \n                ) / iResolution.xy);\n\n            Array32Bits io_bits = unpack_32_bits(gpgpu_data_io * 255.0);\n            \n            lowp float ioBit = io_bits.bit[int(fragCoord.y) % 32];\n            res = outFromPerm(perm, right.outC, ioBit, middle.outA);\n            \n        } else if (fragCoord.x > (COMPUTER_WIDTH - 1.0)) {\n            // Right edge\n            vec4 gpgpu_data_io = texture(iChannel0,\n                // TODO: read actual IO coordinate!!! (this is a fake rn)\n                vec2(\n                    fifoRwPtr * 32.0 + COMPUTER_WIDTH + (fragCoord.y / 32.0),\n                    3.0\n                    \n                ) / iResolution.xy);\n\n            Array32Bits io_bits = unpack_32_bits(gpgpu_data_io * 255.0);\n            \n            lowp float ioBit = io_bits.bit[int(fragCoord.y) % 32];\n            res = outFromPerm(perm, ioBit, left.outB, middle.outA);\n            \n        } else {\n        \n            res = outFromPerm(perm, right.outC, left.outB, middle.outA);\n        }\n        \n        elt.outA = res.x;\n        elt.outB = res.y;\n        elt.outC = res.z;\n    }\n\n    return elt;\n}\n\n\nvec4 update (in vec2 fragCoord) {\n\n    // We use a combined FIFO pointers for both reading and writing\n    // when interfacing with the core. Our computer's core never waits.\n    // If you want to support asynchronous FIFO with blocking IO,\n    // insert special signaling bits.\n    float fifoRwPtr = float((iFrame - 2) % int(IO_FIFO_DEPTH_BITS));\n\n    float ioBlockX;\n    float ioBlockY;\n\n    float ioBlock = ioBlockNumber(fragCoord, ioBlockX, ioBlockY);\n    \n    if (ioBlock > -0.5) {\n    \n        float ioBlockPixel = 32.0 * ioBlockY + ioBlockX;\n        if (ioBlockPixel > (IO_PIXELS - 1.0)) {\n            // IO surface is adjusted to the total computer's core size\n            discard;\n        }\n\n        if (ioBlock < IO_FIFO_DEPTH_BITS) {\n            // Read IO block\n            \n            // Emulate external IO input:\n            // (lags by one, so it's on the opposite side of the FIFO)\n            float fifoExternalWritePtr = float((int(IO_FIFO_DEPTH_BITS) + iFrame - 3 ) % int(IO_FIFO_DEPTH_BITS));\n            \n            \n            if (abs(ioBlock - fifoExternalWritePtr) < 0.5) {\n                rng_initialize(fragCoord, iFrame);\n                return rand4();\n            } else {\n            \n                // do nothing; preserve contents\n                vec4 gpgpu_data = texture(iChannel0, fragCoord/iResolution.xy);\n                return gpgpu_data;\n            }\n\n        } else {\n            // Write IO block\n            if (abs(ioBlock - IO_FIFO_DEPTH_BITS - fifoRwPtr) < 0.5) {\n            \n                // TODO: read Element's D flip-flop state\n                return writeIoBlock(ioBlock - IO_FIFO_DEPTH_BITS, 0.0, 0.0);// ioBlockX, ioBlockY);\n            } else {\n                // do nothing; preserve contents\n                vec4 gpgpu_data = texture(iChannel0, fragCoord/iResolution.xy);\n                return gpgpu_data;\n            }\n        }\n    }\n    \n    \n    // Use 1-byte color values for compatibility with mobile\n    vec4 gpgpu_data = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    if (fragCoord.x > COMPUTER_WIDTH || fragCoord.y > COMPUTER_HEIGHT) {\n        // Skip processing of data not in computer core\n        // or not being in IO\n        // Note that we can write in this buffer realtime external inputs\n        // (mouse, keyboard, etc.)\n        return gpgpu_data;\n    }\n\n    return texelFromElement(computeElement(elementFromTexel(gpgpu_data), fragCoord, fifoRwPtr));\n}\n\n\n\n\n\nvec4 init (in vec2 fragCoord) {\n    \n    if (fragCoord.x > COMPUTER_WIDTH || fragCoord.y > COMPUTER_HEIGHT) {\n        discard;\n        /*\n        lowp float ioBlockX;\n        lowp float ioBlockY;\n\n        float ioBlock = ioBlockNumber(fragCoord, ioBlockX, ioBlockY);\n        if (ioBlock > -0.5) {\n        \n            rng_initialize(fragCoord, iFrame);\n    \n            return rand4();\n        \n            // return vec4(0.7, 0.2, 0.8, 1.0);\n        } else {\n            discard;\n        }\n        */\n    }\n    \n    rng_initialize(fragCoord, 115);\n    vec4 randomValues = rand4();\n\n    Element elt = elementFromTexel(randomValues);\n    \n    lowp vec2 odd = vec2(int(fragCoord.x) % 2, int(fragCoord.y) % 2);\n\n    /*\n    if (abs(odd.x - odd.y) < 0.5) {\n        // Triangle points down\n        elt.wiring0 = 4.0;\n        elt.wiring1 = 5.0;\n        //elt.switchCtrl = 1.0;\n        //elt.outA = 1.0;\n        //elt.outB = 0.0;\n        //elt.outC = 1.0;\n    } else {\n        elt.wiring0 = 5.0;\n        elt.wiring1 = 4.0;\n        //elt.switchCtrl = 1.0;\n        \n        //elt.outA = 0.0;\n        //elt.outB = 1.0;\n        //elt.outC = 0.0;\n    }\n    */\n    \n    elt.wiring0 = elt.wiring0 < 0.5 ? 1.0 : elt.wiring0 > 6.5 ? 6.0 : floor(elt.wiring0);\n    elt.wiring1 = elt.wiring1 < 0.5 ? 1.0 : elt.wiring1 > 6.5 ? 6.0 : floor(elt.wiring1);\n    elt.switchCtrl = elt.switchCtrl < 0.5 ? 1.0 : elt.switchCtrl > 6.5 ? 6.0 : floor(elt.switchCtrl);\n    \n    elt.parent = elt.parent < 0.5 ? 1.0 : elt.parent > 3.5 ? 3.0 : floor(elt.parent);\n    \n    vec4 moreRandomValues = rand4();\n    elt.outA = floor(0.5 + moreRandomValues.r);\n    elt.outB = floor(0.5 + moreRandomValues.g);\n    elt.outC = floor(0.5 + moreRandomValues.b);\n    \n    return texelFromElement(elt);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n  \n    if (iFrame > 1) {\n        fragColor = update(fragCoord);\n    } else {\n        fragColor = init(fragCoord);\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "# ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\n# else\nprecision mediump float;\nprecision lowp int;\nprecision lowp sampler2D;\n# endif\n\n/*\n\n  Maximum _parallel_ IO size is 1024 pixels.\n  Think about these as 32,768 output pins,\n  and another 32K input pins, being a rough\n  equivalent to a 65,536 pins FPGA package.\n\n  A single IO \"tile\" is fixed size 32x32 pixels\n  (on ShaderToy it _should_ be 16x16 pixels,\n  because of the use of float texels instead of RGBA8)\n\n  The 32x32 tile embraces the perimeter of the computer core\n  and provides IO, beginning from the left side to the bottom\n  clockwise.\n\n  Each pixel of the IO tile feeds 32 rows at the left (and at the right),\n  and 64 columns at the top and at the bottom. The discrepancy is due\n  to triangular shape of the computing elements:\n\n 0   1   \n________\n\\  /\\  /\\   0\n \\/__\\/__\\\n /\\  /\\  /  1\n/__\\/__\\/\n\\  /\\  /\\   2\n \\/__\\/__\\\n /\\  /\\  /  3\n/__\\/__\\/\n\n  Each triangular computing element uses a single pixel (32 bits) for its state storage.\n  See \"struct Element\" for specifics.\n\n*/\n\n// The length of data IO buffer until it enters the computer\n// The same size is visible when data outputs the computer\n#define IO_FIFO_DEPTH_BITS 32.\n //470.\n\n// Computer width must be a multiple of 64 to match IO surfaces\n#define MIN_COMPUTER_WIDTH 64.\n\n// Computer height must be a multiple of 32 to match IO surfaces\n#define MIN_COMPUTER_HEIGHT 32.\n\n#define MAX_COMPUTER_WIDTH 8192.\n#define MAX_COMPUTER_HEIGHT 8192.\n\n// Note that IO on the top and the bottom edge\n// is twice less as that of the left and the right\n#define COMPUTER_WIDTH 1920.\n#define COMPUTER_HEIGHT 960.\n\n// IO size, in bits. The number of \"package pins\" is twice of that.\n// The number of IO pixels is 32 times smaller.\n# define IO_SIZE ((COMPUTER_WIDTH) + 2.0 * (COMPUTER_HEIGHT))\n\n# define IO_PIXELS (0.03125 * IO_SIZE)\n\n// 32 bits on bit-by-bit access\nstruct Bitset8Bits {\n\n    vec4 bit0;\n    vec4 bit1;\n    vec4 bit2;\n    vec4 bit3;\n    vec4 bit4;\n    vec4 bit5;\n    vec4 bit6;\n    vec4 bit7;\n};\n\n// 3 * 4 bits\nstruct Bitset3Bits {\n\n    vec4 bit0;\n    vec4 bit1;\n    vec4 bit2;\n};\n\nfloat whenGt (float l, float r) {\n  return max(sign(l - r), 0.0);\n}\n\nvec4 when_gt (vec4 l, vec4 r) {\n  return max(sign(l - r), 0.0);\n}\n\n//------------------------------------\n//\n//      texels -> structured data\n\nBitset3Bits unpack_4_numbers (vec4 numbers) {\n    Bitset3Bits result;\n\n    result.bit2 = when_gt(numbers, vec4(3.5));\n    \n    vec4 bits0to1 = numbers - 4.0 * result.bit2;\n    result.bit1 = when_gt(bits0to1, vec4(1.5));\n    \n    result.bit0 = when_gt(bits0to1 - 2.0 * result.bit1, vec4(0.5));\n\n    return result;\n}\n\n\nBitset8Bits unpack_4_bytes (vec4 byte) {\n    Bitset8Bits result;\n    \n    result.bit7 = when_gt(byte, vec4(127.5));\n    \n    vec4 bits0to6 = byte - 128.0 * result.bit7;\n    result.bit6 = when_gt(bits0to6, vec4(63.5));\n    \n    vec4 bits0to5 = bits0to6 - 64.0 * result.bit6;\n    result.bit5 = when_gt(bits0to5, vec4(31.5));\n    \n    vec4 bits0to4 = bits0to5 - 32.0 * result.bit5;\n    result.bit4 = when_gt(bits0to4, vec4(15.5));\n    \n    vec4 bits0to3 = bits0to4 - 16.0 * result.bit4;\n    result.bit3 = when_gt(bits0to3, vec4(7.5));\n    \n    vec4 bits0to2 = bits0to3 - 8.0 * result.bit3;\n    result.bit2 = when_gt(bits0to2, vec4(3.5));\n    \n    vec4 bits0to1 = bits0to2 - 4.0 * result.bit2;\n    result.bit1 = when_gt(bits0to1, vec4(1.5));\n    \n    result.bit0 = when_gt(bits0to1 - 2.0 * result.bit1, vec4(0.5));\n\n    return result;\n}\n\nstruct Array32Bits {\n    float bit[32];\n};\n\nArray32Bits unpack_32_bits (vec4 byte) {\n    Bitset8Bits bits = unpack_4_bytes(byte);\n    \n    Array32Bits a;\n    a.bit[0] = bits.bit0.r;\n    a.bit[1] = bits.bit1.r;\n    a.bit[2] = bits.bit2.r;\n    a.bit[3] = bits.bit3.r;\n    a.bit[4] = bits.bit4.r;\n    a.bit[5] = bits.bit5.r;\n    a.bit[6] = bits.bit6.r;\n    a.bit[7] = bits.bit7.r;\n    \n    a.bit[8] = bits.bit0.g;\n    a.bit[9] = bits.bit1.g;\n    a.bit[10] = bits.bit2.g;\n    a.bit[11] = bits.bit3.g;\n    a.bit[12] = bits.bit4.g;\n    a.bit[13] = bits.bit5.g;\n    a.bit[14] = bits.bit6.g;\n    a.bit[15] = bits.bit7.g;\n\n    \n    a.bit[16] = bits.bit0.b;\n    a.bit[17] = bits.bit1.b;\n    a.bit[18] = bits.bit2.b;\n    a.bit[19] = bits.bit3.b;\n    a.bit[20] = bits.bit4.b;\n    a.bit[21] = bits.bit5.b;\n    a.bit[22] = bits.bit6.b;\n    a.bit[23] = bits.bit7.b;\n    \n    a.bit[24] = bits.bit0.a;\n    a.bit[25] = bits.bit1.a;\n    a.bit[26] = bits.bit2.a;\n    a.bit[27] = bits.bit3.a;\n    a.bit[28] = bits.bit4.a;\n    a.bit[29] = bits.bit5.a;\n    a.bit[30] = bits.bit6.a;\n    a.bit[31] = bits.bit7.a;\n\n    return a;\n}\n\n/* -----------------------------------------------------------------------\n\n\nFigure 1. Wiring permutations. Signals enter from \"in\" and go to \"out\".\n\n\nEach \"out\" has a D flip-flop in it.\nCircuits, composed of many triangles, are globally clocked.\n\n(In hardware implementation, clock domains can be in each Cartilage subtree).\n\n         /\\\n       in--out\nside A /    \\   side B\n    out      in\n     / \\    / \\\n     ^^^in^^out^\n    \n       side C\n\n\nPermutation | Input | Output\n----------------------------\n            |   A   |   A        /\\\n      1     |   B   |   B       *  *\n            |   C   |   C      /    \\\n----------------------------   ^^**^^\n            |   A   |   A        /\\\n      2     |   B   |   C       * /\\\n            |   C   |   B      / / /\\\n----------------------------   ^^^^^^\n            |   A   |   B        /\\\n      3     |   B   |   A       /^^\\\n            |   C   |   C      /^^^^\\\n----------------------------   ^^**^^\n            |   A   |   B        /\\\n      4     |   B   |   C       /^^\\\n            |   C   |   A      /\\  /\\\n----------------------------   ^^^^^^\n            |   A   |   C        /\\\n      5     |   B   |   A       /\\/\\\n            |   C   |   B      /^/\\^\\\n----------------------------   ^^^^^^\n            |   A   |   C        /\\\n      6     |   B   |   B       /\\ *\n            |   C   |   A      /\\ \\ \\\n----------------------------   ^^^^^^\n\n\n\n\nFigure 2. Switching cause source D flip-flop permutation\n\n      \n     /\\    /\\\n    /  \\  /  \\\n   /__2_\\/__3_\\\n  /\\    /\\    /\\\n / 1\\  /  \\  /4 \\\n/____\\/____\\/____\\\n     /\\    /\\    \n    / 6\\  /5 \\\n   /____\\/____\\\n   \nOnly one D flip-flop can drive element's crossbar switch.\n\nThe crossbar switch switches between two wirings (from fig.1).\n\nAn ordinary crossbar switch switches two channels,\nand it switches just between two wiring schemes:\n\n\n       [A]->----->[C]                     [A]--   -->[C]\n              .                                \\ /\n[CTRL = 0]->...           <=>     [CTRL = 1]->..X\n              .                                / \\\n       [B]->----->[C]                     [B]--   -->[D]\n\n\nOur triangular element switches three channels,\nand it _also_ switches just between two wiring schemes:\n\n   [A in]->  --------  ->[A out]           [A in]->  --------  ->[A out]\n            / wiring \\                              / wiring \\\n   [B in]-> | scheme | ->[B out]    <=>    [B in]-> | scheme | ->[B out]\n            \\ ~ 0 ~  /                              \\ ~ 1 ~  /\n   [C in]->  --------  ->[C out]           [C in]->  --------  ->[C out]\n            \n\nThe difference from ordinary crossbar switch is that\nthere are 6 wiring schemes to choose from to use as \"wiring scheme 0\",\nand the same 6 wiring schemes to use as \"wiring scheme 1\".\n\n\nThe selections are stored in \"wiring0\" and \"wiring1\".\n   \n----------------------------------------------------------------------------*/\n\n\n\nstruct Element {\n\n    // 16 bits of runtime state, fully reconfigurable\n    \n    // --- Three D flip-flops storing the states of the three outputs A, B, and C ---\n    \n    lowp float outA;  // 0..1\n    lowp float outB;  // 0..1\n    lowp float outC;  // 0..1\n\n\n    // --- 9 bits of wiring and control configuration ---\n\n    // Wiring scheme (see fig. 1) when switching cause bit is 0. A number 1..6.\n    float wiring0;\n\n    // Wiring scheme when switching cause bit is 1. A number 1..6.\n    float wiring1;\n    \n    // Switching cause D flip-flop (see fig.2) A number 1..6\n    float switchCtrl;\n\n    \n    // --- 4 bits of Cartilage tree engine ---\n    \n    // Pointer to the owner element - A, B, or C\n    float parent; // 1..3\n    \n    // End-of-subtree markers (relatively to parent)\n    // When neighbor element's parent points to our element,\n    // that neighbor for us becomes a subtree we can reconfigure.\n    lowp float leftIsLeaf;   // 0..1\n    lowp float rightIsLeaf;  // 0..1\n\n    \n    // 16 reconfiguration FIFO bits:\n    \n    // Mode switcher. When reconfiguration starts, the old state is removed\n    // and sent to parent, bit by bit. The new state is pushed in.\n    // When the final configuration bit is captured from the parent's D flip-flop,\n    // It's immediately used to reconfigure the element. This is due to 32 bits total limit.\n    // There possibly can be two modes\n    // lowp float isReconfiguring;\n    \n    // 16 bits deep double buffer / FIFO\n    lowp float fifo0;\n    lowp float fifo1;\n    lowp float fifo2;\n    lowp float fifo3;\n    lowp float fifo4;\n    lowp float fifo5;\n    lowp float fifo6;\n    lowp float fifo7;\n    lowp float fifo8;\n    lowp float fifo9;\n    lowp float fifo10;\n    lowp float fifo11;\n    lowp float fifo12;\n    lowp float fifo13;\n    lowp float fifo14;\n    lowp float fifo15;\n    \n};\n\nElement elementFromTexel (in vec4 texel) {\n\n    Element elt;\n\n    Bitset8Bits bits = unpack_4_bytes(texel * 255.0);\n    \n    elt.outA = bits.bit0.r;\n    elt.outB = bits.bit1.r;\n    elt.outC = bits.bit2.r;\n    \n\n    elt.wiring0 = float(bits.bit3.r + 2.0 * bits.bit4.r + 4.0 * bits.bit5.r);\n    elt.wiring1 = float(bits.bit6.r + 2.0 * bits.bit7.r + 4.0 * bits.bit0.g);\n    elt.switchCtrl = float(bits.bit1.g + 2.0 * bits.bit2.g + 4.0 * bits.bit3.g);\n    elt.parent = float(bits.bit4.g + 2.0 * bits.bit5.g);\n\n    elt.leftIsLeaf = bits.bit6.g;\n    elt.rightIsLeaf = bits.bit7.g;\n\n    \n    elt.fifo0 = bits.bit0.b;\n    elt.fifo1 = bits.bit1.b;\n    elt.fifo2 = bits.bit2.b;\n    elt.fifo3 = bits.bit3.b;\n    elt.fifo4 = bits.bit4.b;\n    elt.fifo5 = bits.bit5.b;\n    elt.fifo6 = bits.bit6.b;\n    elt.fifo7 = bits.bit7.b;\n    \n    elt.fifo8 = bits.bit0.a;\n    elt.fifo9 = bits.bit1.a;\n    elt.fifo10 = bits.bit2.a;\n    elt.fifo11 = bits.bit3.a;\n    elt.fifo12 = bits.bit4.a;\n    elt.fifo13 = bits.bit5.a;\n    elt.fifo14 = bits.bit6.a;\n    elt.fifo15 = bits.bit7.a;\n\n    return elt;\n}\n\n\n//------------------------------------\n//\n//       structured data -> texels\n//\n\nvec4 pack_4_bytes (Bitset8Bits state) {\n\n  vec4 data;\n\n  data = vec4(state.bit0)\n    + 2.0 * vec4(state.bit1)\n    + 4.0 * vec4(state.bit2)\n    + 8.0 * vec4(state.bit3)\n    + 16.0 * vec4(state.bit4)\n    + 32.0 * vec4(state.bit5)\n    + 64.0 * vec4(state.bit6)\n    + 128.0 * vec4(state.bit7);\n\n  return data;\n}\n\nvec4 texelFromElement (in Element elt) {\n\n    Bitset8Bits bits;\n    \n    Bitset3Bits parameters = unpack_4_numbers(vec4(elt.wiring0, elt.wiring1, elt.switchCtrl, elt.parent));\n\n    bits.bit0.r = elt.outA;\n    bits.bit1.r = elt.outB;\n    bits.bit2.r = elt.outC;\n    bits.bit3.r = parameters.bit0.r;\n    bits.bit4.r = parameters.bit1.r;\n    bits.bit5.r = parameters.bit2.r;\n    bits.bit6.r = parameters.bit0.g;\n    bits.bit7.r = parameters.bit1.g;\n    \n\n    bits.bit0.g = parameters.bit2.g;\n    bits.bit1.g = parameters.bit0.b;\n    bits.bit2.g = parameters.bit1.b;\n    bits.bit3.g = parameters.bit2.b;\n    bits.bit4.g = parameters.bit0.a;\n    bits.bit5.g = parameters.bit1.a;\n    bits.bit6.g = elt.leftIsLeaf;\n    bits.bit7.g = elt.rightIsLeaf;\n\n    \n    bits.bit0.b = elt.fifo0;\n    bits.bit1.b = elt.fifo1;\n    bits.bit2.b = elt.fifo2;\n    bits.bit3.b = elt.fifo3;\n    bits.bit4.b = elt.fifo4;\n    bits.bit5.b = elt.fifo5;\n    bits.bit6.b = elt.fifo6;\n    bits.bit7.b = elt.fifo7;\n    \n    bits.bit0.a = elt.fifo8;\n    bits.bit1.a = elt.fifo9;\n    bits.bit2.a = elt.fifo10;\n    bits.bit3.a = elt.fifo11;\n    bits.bit4.a = elt.fifo12;\n    bits.bit5.a = elt.fifo13;\n    bits.bit6.a = elt.fifo14;\n    bits.bit7.a = elt.fifo15;\n\n    return pack_4_bytes(bits) / 255.0;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}