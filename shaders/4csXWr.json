{
    "Shader": {
        "info": {
            "date": "1705157821",
            "description": "CRT effect with noticeable fake pixels.\nLICENS: WTFPL",
            "flags": 32,
            "hasliked": 0,
            "id": "4csXWr",
            "likes": 3,
            "name": "Multipass CRT effect",
            "published": 3,
            "tags": [
                "noise",
                "pixel",
                "crt",
                "multipass",
                "pixilated"
            ],
            "usePreview": 0,
            "username": "t1m",
            "viewed": 174
        },
        "renderpass": [
            {
                "code": "vec2 curve(vec2 uv)\n{\n\tuv = (uv - 0.5) * 2.0;\n\tuv *= 1.0;\t\n\tuv.x *= 1.0 + pow((abs(uv.y) / 5.0), 2.0);\n\tuv.y *= 1.0 + pow((abs(uv.x) / 4.0), 2.0);\n\tuv  = (uv / 2.0) + 0.5;\n\treturn uv;\n}\n\nvec3 chroma(sampler2D source, vec2 uv){\n    vec3 col = vec3(0.0);\n    col.r = texture(source,vec2(uv.x+0.004,uv.y)).x;\n    col.g = texture(source,vec2(uv.x+0.000,uv.y)).y;\n    col.b = texture(source,vec2(uv.x-0.004,uv.y)).z;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = curve( uv );\n    \n    vec3 col;\n    \n    // Chromatic\n    col = chroma(iChannel0, uv);\n    \n    // uncomment to disable chroma\n    //col = texture(iChannel0, uv).rgb;\n    \n    // drop things beyond curved image\n    col *= step(0.0, uv.x) * step(0.0, uv.y);\n    col *= 1.0 - step(1.0, uv.x) * 1.0 - step(1.0, uv.y);\n\n    // vignete\n    float vig = (0.0 + 32.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y));\n\tcol *= vec3(pow(vig,0.3));\n    \n    // more green, less other components\n    col *= vec3(0.975,1.05,0.975);\n    \n    // horizontal scanlines:\n    // gues what is it\n\tfloat scanSpeed = 10.0;\n\t// bigger number - more scanlines\n\tfloat scanlinesNumber = 20.0;\n    // scanline darkness\n\tfloat s_am = 0.0350;\n\tfloat s_b = 1.0 - s_am;\n    col *= s_b + s_am*(sin(scanSpeed * iTime + \n                          (uv.y*scanlinesNumber*3.14)));\n  \n    // screen flickering\n    float freq = 35.0*3.14;\t\t\t// PI is used to make it \"per second\"\n\tfloat f_am = 0.020;\t\t\t\t// amplitude of bright changing\n\tfloat f_b = 1.0 - f_am;         // base level of color\n\tcol *= f_b + f_am*sin(freq*iTime);\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Pixelation - produces noizy \"pixelated\" image.\n// author: https://github.com/T1mL3arn\n// ---------------\n\n// Converts UV pixel coord to \"fake screen\" pixel coord.\nvec2 fakePixel(vec2 uv, vec2 fakeSize)\n{\n    vec2 res = vec2(0.0);\n    res.x = abs(sin(3.14*(uv.x*fakeSize.x)));\n    res.y = abs(sin(3.14*(uv.y*fakeSize.y)));\n    \n    return res;\n}\n\n// good old pseudo-random,\n// returns a value in range [0,1]\nfloat random (vec2 st) {\n    float speed = 0.00175*iTime*3.14;\n    return fract(sin(speed + dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    // Scale defines how many \"fake pixels\"\n    // will be inside \"fake screen\".\n    // Less scale - bigger \"fake pixels\".\n    // Set it to 0.00625 to get 4x3 screen\n    float scale = 0.1875;\n    // Width and height in fake pixels,\n    // set it to whatever you want.\n    vec2 fakeSize = vec2(640.0, 480.0)*scale;\n    // fp - is \"fake pixel\" coord used below\n    // to mix black and real texture color.\n    vec2 fp = fakePixel(uv, fakeSize);\n    \n    // How dark edges of \"fake pixels\" should be,\n\t// the bigger - the darker\n\tconst float dark = 0.35;\n\tvec3 darkColor = col*(1.0-dark);\n\t// how bright the fake pixel should be\n\tfloat luma = 1.25;\n    // fp.x*fp.y means horizontal AND vertical.\n    // Use only one component to get only H or V stripes.\n\tcol = mix(darkColor, col*luma, fp.x*fp.y);\n    \n    // scale coordinate system to match \"fake screen\"\n    uv *= (fakeSize);\n    // integer coord of \"fake pixel\"\n    vec2 ipos = floor(uv);\n\n    // noise over \"fake pixels\",\n    float rnd = 0.0;\n    // comment line below to disable the noise\n    rnd = random( ipos );\n    // 40% of pixels kinda broken\n    if (rnd >= 0.6){\n        // noise factor\n        const float nf = 0.08;\n        // using just 1.0 makes it boring\n        const float base = 1.1 - nf;\n        // convert rnd to be in [-1, 1] range\n        col *= base + nf*(rnd*2.0-1.0);\n    }\n    // to see is UV matches fakeSize\n    //vec2 fpos = fract(uv);\n    // constant grid...\n    //col = vec3(fpos,0.0);\n    // ...or dynamic\n    //col = mix(col, vec3(fract(uv),0.0), abs(sin(iTime*3.14*0.5)));\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Bloom filter\n//\n// ---------------\n\nfloat u_blurSize = 1.0/256.0;\nfloat intensity = 0.01250;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec4 color = vec4(0);\n   vec2 uv = fragCoord.xy/iResolution.xy;\n   \n   float blurSize = u_blurSize;\n   // animate blur size\n   //blurSize = 1.0/(0.01+256.0*abs(sin(iTime*3.14*0.25)));\n   //blurSize *= abs(sin(iTime*3.14*0.25));\n\n   // thank you! http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/ for the \n   // blur tutorial\n \n   // blur in x (horizontal)\n   // take nine samples, with the distance blurSize between them\n   //color += texture(iChannel0, vec2(uv.x - 5.0*blurSize, uv.y)) * 0.0275;\n   color += texture(iChannel0, vec2(uv.x - 4.0*blurSize, uv.y)) * 0.05;\n   color += texture(iChannel0, vec2(uv.x - 3.0*blurSize, uv.y)) * 0.09;\n   color += texture(iChannel0, vec2(uv.x - 2.0*blurSize, uv.y)) * 0.12;\n   color += texture(iChannel0, vec2(uv.x - blurSize, uv.y)) * 0.15;\n   color += texture(iChannel0, vec2(uv.x, uv.y)) * 0.16;\n   color += texture(iChannel0, vec2(uv.x + blurSize, uv.y)) * 0.15;\n   color += texture(iChannel0, vec2(uv.x + 2.0*blurSize, uv.y)) * 0.12;\n   color += texture(iChannel0, vec2(uv.x + 3.0*blurSize, uv.y)) * 0.09;\n   color += texture(iChannel0, vec2(uv.x + 4.0*blurSize, uv.y)) * 0.05;\n   //color += texture(iChannel0, vec2(uv.x + 5.0*blurSize, uv.y)) * 0.0275;\n\t\n   // blur in y (vertical)\n   // take nine samples, with the distance blurSize between them\n   //color += texture(iChannel0, vec2(uv.x, uv.y - 5.0*blurSize)) * 0.0275;\n   color += texture(iChannel0, vec2(uv.x, uv.y - 4.0*blurSize)) * 0.05;\n   color += texture(iChannel0, vec2(uv.x, uv.y - 3.0*blurSize)) * 0.09;\n   color += texture(iChannel0, vec2(uv.x, uv.y - 2.0*blurSize)) * 0.12;\n   color += texture(iChannel0, vec2(uv.x, uv.y - blurSize)) * 0.15;\n   color += texture(iChannel0, vec2(uv.x, uv.y)) * 0.16;\n   color += texture(iChannel0, vec2(uv.x, uv.y + blurSize)) * 0.15;\n   color += texture(iChannel0, vec2(uv.x, uv.y + 2.0*blurSize)) * 0.12;\n   color += texture(iChannel0, vec2(uv.x, uv.y + 3.0*blurSize)) * 0.09;\n   color += texture(iChannel0, vec2(uv.x, uv.y + 4.0*blurSize)) * 0.05;\n   //color += texture(iChannel0, vec2(uv.x, uv.y + 5.0*blurSize)) * 0.0275;\n\n   vec4 origColor = texture(iChannel0, uv);\n   \n   // animate intensity\n   //intensity *= abs(sin(iTime*3.14*0.5));\n\n   // SCREEN blending\n   //fragColor = 1.0-(1.0-origColor)*(1.0-color*intensity);\n\n   fragColor = color*intensity + origColor;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}