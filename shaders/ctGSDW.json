{
    "Shader": {
        "info": {
            "date": "1686087785",
            "description": "I wrote this mostly for myself to better understand gamma corrections.\nYou can tweak the gamma values to see how perceived luminance of a blended value stacks against a weighted mix of black and white pixels (where your brain does the \"blending\")\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ctGSDW",
            "likes": 1,
            "name": "Experiment - Gamma \"Calibrator\"",
            "published": 3,
            "tags": [
                "gamma",
                "greyscale",
                "gradientnoise"
            ],
            "usePreview": 0,
            "username": "Sellis",
            "viewed": 165
        },
        "renderpass": [
            {
                "code": "// Interleaved Gradient Noise, code from\n// https://blog.demofox.org/2022/01/01/interleaved-gradient-noise-a-different-kind-of-low-discrepancy-sequence/\n\nfloat IGN(int pixelX, int pixelY, float frame)\n{\n    frame = mod(frame, 64.f); // need to periodically reset frame to avoid numerical issues\n    float x = float(pixelX) + 5.588238f * float(frame);\n    float y = float(pixelY) + 5.588238f * float(frame);\n    return mod(52.9829189f * mod(0.06711056f*float(x) + 0.00583715f*float(y), 1.0f), 1.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/(iResolution.xy);\n    \n    // Animated gradient noise. Possibly passing frame as float may break the original low discrepancy properties?\n    // You are welcome to substitute your own noise here;\n    float gradNoise = IGN(int(fragCoord.x), int(fragCoord.y), iTime * 0.02f);\n    \n    // Greyscale simulated by stepping. This offloads the \"blending\" part to your brain.\n    // Values of 0.0f and 1.1f stay the same regardless of gamma, so a weighted quantitative\n    // mix of pixels should approximate \"correct\" luminance. \n    float stepped = step(gradNoise, uv.x);\n    \n    // Gamma-corrected blending between 0.0f and 1.1f\n    // You can try different values here    \n    float gamma = 2.2f;\n    float corrected = pow(uv.x, 1.0f/gamma);\n    \n    // Interleave strips of gamma-corrected blend and noise-stepped \"blend\"\n    // you can tweak the number of repetitions so it is easier for you to compare the two scales\n    \n    float selection = step(mod(uv.y * 120.f, 1.0f), 0.5f);\n    \n    float final = mix(corrected, stepped, selection);\n    \n\n    // Output to screen\n    fragColor = vec4(final,final,final,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}