{
    "Shader": {
        "info": {
            "date": "1646290087",
            "description": "This is a part of my piece \"Crazy Climbers\".\n[url]https://iy0yi.me/work/crazy-climbers/[/url]\nOther parts playlist:\n[url]https://www.shadertoy.com/playlist/3X3BRB[/url]\n",
            "flags": 48,
            "hasliked": 0,
            "id": "fdlcRH",
            "likes": 28,
            "name": "[CrzClm] Hand",
            "published": 3,
            "tags": [
                "maptoy",
                "crazyclimbers"
            ],
            "usePreview": 1,
            "username": "iY0Yi",
            "viewed": 427
        },
        "renderpass": [
            {
                "code": "// SDF is in BufB.\n\n#define getBuf(coord)\ttexelFetch(iChannel0, ivec2(coord), 0)\nvec3 getAlbedo(vec2 coord) { return unpackU4(getBuf(coord).x).rgb; }\nfloat getAO(vec2 coord) { return s2u(unpackS3(getBuf(coord).y).b); }\nfloat getDiffuse(vec2 coord) { return s2u(unpackS3(getBuf(coord).y).r); }\nfloat getDepth(vec2 coord) { return getBuf(coord).w; }\nvec3 getNormal(vec2 coord) { return normalize(unpackS3(getBuf(coord).z)); }\nvec2 clampCoord(vec2 coord) { return clamp(coord, vec2(0), iResolution.xy - .5); }\n\nfloat calcEdge(vec3 nlm1, vec3 nlm2) {\n\tvec2 difN = abs(nlm1.xy - nlm2.xy);\n\treturn smoothstep(1.5, 1., difN.x + difN.y);\n}\n\nfloat getOutline(vec2 coord) {\n    if(getDepth(coord)>.9)return .4;\n    \n\tconst vec3 offset = vec3(.5, -.5, 0)*2.;\n    #define NM(x)\tgetNormal(x)\n\tvec2 coords = coord;\n\tfloat edge = 1.;\n\tedge = min(edge, calcEdge(NM(clampCoord(coords + offset.yx)), NM(clampCoord(coords + offset.xy))));\n\tedge = min(edge, calcEdge(NM(clampCoord(coords + offset.xx)), NM(clampCoord(coords + offset.yy))));\n\tedge = min(edge, calcEdge(NM(clampCoord(coords + offset.yz)), NM(clampCoord(coords + offset.xz))));\n\tedge = min(edge, calcEdge(NM(clampCoord(coords + offset.zx)), NM(clampCoord(coords + offset.zy))));\n\treturn edge;\n}\n\n// ref: (in japanese)\n// https://imagingsolution.net/imaging/canny-edge-detector/\n// Detect edge.\nvec4 sobel(vec2 fragCoord, vec2 dir) {\n\tfloat np, zp, pp, nz, pz, nn, zn, pn, gx, gy;\n    np = getDiffuse(clampCoord(fragCoord + (vec2(-1, 1) + dir)));\n    zp = getDiffuse(clampCoord(fragCoord + (vec2(0, 1) + dir)));\n    pp = getDiffuse(clampCoord(fragCoord + (vec2(1) + dir)));\n    nz = getDiffuse(clampCoord(fragCoord + (vec2(-1, 0) + dir)));\n    pz = getDiffuse(clampCoord(fragCoord + (vec2(1, 0) + dir)));\n    nn = getDiffuse(clampCoord(fragCoord + (vec2(-1) + dir)));\n    zn = getDiffuse(clampCoord(fragCoord + (vec2(0, -1) + dir)));\n    pn = getDiffuse(clampCoord(fragCoord + (vec2(1, -1) + dir)));\n\n\t// https://www.shadertoy.com/view/Wds3Rl\n\tgx = np * -3. + nz * -10. + nn * -3. + pp * 3. + pz * 10. + pn * 3.;\n\tgy = np * -3. + zp * -10. + pp * -3. + nn * 3. + zn * 10. + pn * 3.;\n\n\tvec2 G = vec2(gx, gy);\n\treturn vec4(G, length(G), atan(G.y, G.x));\n}\n\nvec2 hysteresisThr(vec2 fragCoord, float mn, float mx) {\n\tvec4 edge = sobel(fragCoord, vec2(0));\n\tvec2 dir = vec2(cos(-edge.w), sin(-edge.w));\n\tvec4 edgep = sobel(fragCoord, dir),\n\t     edgen = sobel(fragCoord, -dir);\n\tif (edge.z < edgep.z || edge.z < edgen.z) edge.z = 0.;\n\treturn vec2((edge.z > mn) ? edge.z : 0., (edge.z > mx) ? edge.z : 0.);\n}\n\nfloat cannyEdge(vec2 fragCoord, float mn, float mx, bool isDiffuse) {\n\tvec2 np = hysteresisThr(fragCoord + vec2(-1, 1), mn, mx),\n\t     zp = hysteresisThr(fragCoord + vec2(0, 1), mn, mx),\n\t     pp = hysteresisThr(fragCoord + vec2(1), mn, mx),\n\t     nz = hysteresisThr(fragCoord + vec2(-1, 0), mn, mx),\n\t     zz = hysteresisThr(fragCoord + vec2(0), mn, mx),\n\t     pz = hysteresisThr(fragCoord + vec2(1, 0), mn, mx),\n\t     nn = hysteresisThr(fragCoord + vec2(-1), mn, mx),\n\t     zn = hysteresisThr(fragCoord + vec2(0, -1), mn, mx),\n\t     pn = hysteresisThr(fragCoord + vec2(1, -1), mn, mx);\n\treturn 1. - min(1., step(1e-3, zz.x * 8.) * smoothstep(0., .5, np.y + zp.y + pp.y + nz.y + pz.y + nn.y + zn.y + pn.y) * 8.);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    switchShowFinal();\n    \n\tvec3 albedo = getAlbedo(fragCoord);\n    vec3 col = vec3(.9608, .9216, .8431);\n\n\tcol *= min(getOutline(fragCoord), cannyEdge(fragCoord, 0., 3.5, true));\n    col *= sms(.25,.24, getAO(fragCoord));\n\tcol *= sms(.4, .401, gnoise(fragCoord * .18+floor(iTime)) + gnoise(fragCoord * .15) + .3);\n\tcol += 1. - sms(.8, .801, (1. - gnoise(fragCoord * .05+floor(iTime)) * gnoise(fragCoord * .1)) + .7);\n\tfragColor = vec4(pow3(col, .45), 1);\n    \n    if(!SHOW_FINAL)fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nbool SHOW_FINAL = true;\n#define switchShowFinal() SHOW_FINAL=(int(floor(iTime*.25))%2==0) \n\n#define PI acos(-1.)\n#define TAU (PI*2.)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n#define sat(x) clamp(x,0.,1.)\n#define sms(min,max,x) smoothstep(min,max,x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n#define sign1f(x) ((x > 0.) ? 1. : -1.)\n#define sign2v(v) vec2(sign1f(v.x),sign1f(v.y))\n#define linearstep(edge0,edge1,x) min(max((x-(edge0))/((edge1)-(edge0)),0.),1.)\n#define ZERO min(0,iFrame)\nvec3 pow3(vec3 v,float power){return pow(v,vec3(power));}\n\n// \"hash11()\"-\"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.xx + p3.yz) * p3.zy);\n}\nvec3 hash33(vec3 p3) {\n  p3 = fract(p3 * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yxz + 33.33);\n  return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\n// FBMs\n// https://postd.cc/understanding-perlin-noise/\nfloat gnoise(in vec2 st) {\n  st *= .75;\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n\n  vec2 u = smoothstep(0., 1., f);\n\n  vec2 rnd_x0y0 = u2s(hash22(i + vec2(0, 0)));\n  vec2 rnd_x1y0 = u2s(hash22(i + vec2(1, 0)));\n  vec2 rnd_x0y1 = u2s(hash22(i + vec2(0, 1)));\n  vec2 rnd_x1y1 = u2s(hash22(i + vec2(1, 1)));\n\n  vec2 dir_x0y0 = st - (i + vec2(0, 0));\n  vec2 dir_x1y0 = st - (i + vec2(1, 0));\n  vec2 dir_x0y1 = st - (i + vec2(0, 1));\n  vec2 dir_x1y1 = st - (i + vec2(1, 1));\n\n  float dot_x0y0 = dot(rnd_x0y0, dir_x0y0);\n  float dot_x1y0 = dot(rnd_x1y0, dir_x1y0);\n  float dot_x0y1 = dot(rnd_x0y1, dir_x0y1);\n  float dot_x1y1 = dot(rnd_x1y1, dir_x1y1);\n\n  float res_x = mix(dot_x0y0, dot_x1y0, u.x);\n  float res_y = mix(dot_x0y1, dot_x1y1, u.x);\n  return s2u(mix(res_x, res_y, u.y) * 2.);\n}\n\n// fbm base for all noise\n#define fbm_base(nname, n, rep, pers){\\\n\tfloat total = 0.;\\\n\tfloat frequency = 1.;\\\n\tfloat amplitude = 1.;\\\n\tfloat maxValue = 0.;\\\n\tfor(int i=0;i<rep;i++) {\\\n\t\ttotal += nname(vec2(n.x * frequency, n.y * frequency)) * amplitude;\\\n\t\tmaxValue += amplitude;\\\n\t\tamplitude *= pers;\\\n\t\tfrequency *= 2.;\\\n\t}\\\n\tres = total/maxValue;\\\n}\nfloat gfbm(vec2 n, int rep, float pers) {\n  float res = 0.;\n  fbm_base(gnoise, n, rep, pers);\n  return res;\n}\n\n\n// Data packer/unpacker\n// albedo,diffuse,specular,shadow,normal,and depth are rendered in raymarching pass,\n// and then,those results packed in one vec4 to use in post processing.\n// here are some experiments:\n// https://www.shadertoy.com/view/Ws3cRS\nuint packSnorm3x10(vec3 x) {\n\tx = round(clamp(x,-1., 1.) *.997 * 511.);\n\tuvec3 sig = uvec3(mix(vec3(0), vec3(1), greaterThanEqual(sign(x),vec3(0))));\n\tuvec3 mag = uvec3(abs(x));\n\tuvec3 r = sig.xyz << 9 | mag.xyz;\n\treturn r.x << 22 | r.y << 12 | r.z << 2;\n}\n#define packS3(x) uintBitsToFloat(packSnorm3x10(x))\nvec3 unpackSnorm3x10(uint x) {\n\tuvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n\tuvec3 sig = r >> 9;\n\tuvec3 mag = r & uvec3(0x1FF);\n\tvec3 fsig = mix(vec3(-1), vec3(1), greaterThanEqual(sig, uvec3(1)));\n\tvec3 fmag = vec3(mag) / 511.;\n\treturn fsig * fmag;\n}\n#define unpackS3(x) unpackSnorm3x10(floatBitsToUint(x))\nuint packUnorm4x8(vec4 x) {\n\tx = round(clamp(x, 0., 1.) * 255.);\n\tuvec4 r = uvec4(x);\n\treturn r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\n#define packU4(x) uintBitsToFloat(packUnorm4x8(x))\nvec4 unpackUnorm4x8(uint x) {\n\tuvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n\tvec4 v = vec4(r) / 255.0;\n\treturn v;\n}\n#define unpackU4(x) unpackUnorm4x8(floatBitsToUint(x))\n\nstruct RenderData {\n  vec3 albedo;\n  vec3 normal;\n  float diffuse;\n  float specular;\n  float shadow;\n  float ao;\n  float depth;\n  vec3 result;\n} renDat;\n\nstruct Ray {\n  vec3 origin;\n  vec3 progress;\n  vec3 direction;\n}ray;\n\nstruct Camera {\n  vec3 position;\n  vec3 direction;\n  vec3 target;\n  vec4 quaternion;\n  float fov;\n  float orthoDist;\n  float orthoScale;\n  vec3 up;\n};\n\nstruct Light {\n  vec3 direction;\n  vec3 color;\n  float intensity;\n  float shadowStart;\n  float shadowEnd;\n  float shadowSoft;\n};\n\n#define MAT_VOID vec3(-1)\nbool isMaterial(vec3 MAT) { return distance(renDat.albedo, MAT) < .005; }\n\n// Raymarching setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define DIST_MIN .001\n#define DIST_MAX 20.\n#define STEP_MAX 100\n\n#define INIT_CAM_POS vec3(2,-.25,2)\n#define CAM_DIST 5.\n#define CAM_INIT_SCALE .6\n#define TURN_TABLE_SPEED .25\n\n/*\n   __  __    __    ____  ____  _____  _  _ \n  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n\n  Version: 1.1.0\n\n  This is a \"Maptoy\" template.\n  I wanted an editor dedicated to distance functions,\n  so I created it in Shadertoy.\n  You can bookmark this page, fork, and edit it.\n  I've tried to keep everything but the map functions\n  in the Common tab.\n\n  Hotkeys:\n  -------------------------------------------------------------\n   1   | Camera: Front\n  -------------------------------------------------------------\n   3   | Camera: Side\n  -------------------------------------------------------------\n   7   | Camera: Top\n  -------------------------------------------------------------\n   0   | Camera: Free (release specific views above.)\n  -------------------------------------------------------------\n   W/S | Camera: Zoom +/-\n  -------------------------------------------------------------\n   Q   | ViewMode: Quad view\n  -------------------------------------------------------------\n   T   | ViewMode: Turntable\n  -------------------------------------------------------------\n   I   | Debug: ISO line\n  -------------------------------------------------------------\n   C   | Debug: Cost\n  -------------------------------------------------------------\n   N   | Debug: Normal\n  -------------------------------------------------------------\n   M   | Debug: Matcap (overwrite the Normal debug drawing.)\n  -------------------------------------------------------------\n*/\n\n/*\n  Update:\n\n  1.1.0 @ 2022/09/14 \n      - Fixed long compilation in Quad view.\n      - Many of the features went to hotkeys from #defines.\n\n  1.0.4 @ 2021/11/03    \n      - Added Isoline draw.\n\n  1.0.3 @ 2021/10/22    \n      - Added Matcap debug mode.\n\n  1.0.2 @ 2021/10/20    \n      - Added Quad view mode.\n\n  1.0.1 @ 2021/10/15    \n      - Added Axis draw.\n      - Added Hotkeys for Camera View angle.\n      ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n\n  1.0.0 @ 2021/10/14   \n      - Released.\n*/\n\n// Theme\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define THM_BACKGROUND (vec3(0.071,0.071,0.071)*.8)\n#define THM_GRID vec3(.13)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(0.820,0.820,0.820)\n#define THM_MATCAP_TYPE 1\n// Matcaps 0:CURVATURE/1:METAL/2:RED_WAX\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\n\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist){\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr ){\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc col+= char(U,64+CAPS+c).rgb;\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\nvec3 mouse=vec3(0);\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(2,0)\n#define C_MOUSE_VEC vec2(4,0)\n#define C_MOUSE_POS vec2(6,0)\n#define C_QUAD_VIEW vec2(8,0)\n#define C_TURN_TABLE vec2(10,0)\n#define C_CAM_SCALE vec2(12,0)\n#define C_TARGET_X vec2(14,0)\n#define C_TARGET_Y vec2(16,0)\n#define C_TARGET_Z vec2(18,0)\n#define C_DEBUG_ISO vec2(20,0)\n#define C_DEBUG_COST vec2(22,0)\n#define C_DEBUG_MATCAP vec2(24,0)\n#define C_DEBUG_NORMAL vec2(26,0)\n\nvec4 packRenderData(){\n  return vec4(packU4(vec4(renDat.albedo, renDat.shadow)), packS3((vec3(u2s(renDat.diffuse), renDat.specular, u2s(renDat.ao)))), packS3((renDat.normal)), renDat.depth);\n}\n\nbool isTurntable = false;\nint char_id = -1; vec2 char_pos, dfdx, dfdy;\nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) /* thighly y-clamped to allow dense text*/\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\n    return vec4(0);\n}\n\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n#define render() \\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1e5) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=ZERO; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=ZERO; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 target = vec3(fetch(C_TARGET_X).x,fetch(C_TARGET_Y).x,fetch(C_TARGET_Z).x);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5) && num==0)\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && isTurntable)\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED), 1, cos(iTime*TURN_TABLE_SPEED))*INIT_CAM_POS) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n        if(length(mou.xyz)<=.0)pos=INIT_CAM_POS;\\\n    }\\\n    vec3 cw = normalize(target-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= (CAM_INIT_SCALE+fetch(C_CAM_SCALE).x)/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = target-pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    renDat.normal=vec3(0);\\\n    renDat.diffuse=1.;\\\n    renDat.albedo=vec3(.9);\\\n    renDat.depth=1.;\\\n    renDat.specular=0.;\\\n    renDat.shadow=1.;\\\n    renDat.ao=1.;\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(0,1,1);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(fetch(C_DEBUG_NORMAL).x>.5)col = (n*.5+.5)*.5;\\\n        if(fetch(C_DEBUG_MATCAP).x>.5 || SHOW_FINAL){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(n,vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(THM_MATCAP_TYPE == 0){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 1){\\\n                float corrosion = clamp(-curvature * 8.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 3.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.047,0.067,0.094);\\\n                vec3 diffuse = mix(mix(vec3(0.259,0.380,0.290), vec3(0.431,0.549,0.549), corrosion),\\\n                vec3(0.761,0.655,0.439), shine) - ambient;\\\n                vec3 specular = mix(vec3(0), vec3(1) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 2){\\\n                float dirt = clamp(0.15 - curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.251,0.082,0.008);\\\n                vec3 diffuse = mix(vec3(0.565,0.224,0.078), vec3(0.996,0.843,0.843), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.3) - ambient, vec3(0.0), dirt);\\\n                float shininess = 16.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n            renDat.normal=n;\\\n            renDat.diffuse=(dot(n, normalize(vec3(1.0, 1.0, 1.0))));\\\n            renDat.albedo = vec3(1);\\\n            renDat.depth = 0.;\\\n            renDat.specular = 0.;\\\n            renDat.shadow = 1.;\\\n            renDat.ao = cost/float(STEP_MAX);\\\n        }\\\n    }\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    float vx = 1., vy = 1., vz = 1.;\\\n    if(num==1) vx=0.,vz=0.;\\\n    if(num==7) vx=0.,vy=0.;\\\n    if(num==3) vy=0.,vz=0.;\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz);\\\n    if((fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx*vx+gy*vy+gz*vz)*.333;\\\n    if(fetch(C_DEBUG_COST).x>.5)\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, THM_GRID, g);\\\n    if(fetch(C_DEBUG_ISO).x>.5) {\\\n        vec4 n;\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(num!=3 && axisX>0. && (fetch(C_DEBUG_ISO).x>.5 || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(num!=7 && axisY>0. && (fetch(C_DEBUG_ISO).x>.5 || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(num!=1 && axisZ>0. && (fetch(C_DEBUG_ISO).x>.5 || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    caps C(_c) low C(_a)C(_m)C(_e)C(_r)C(_a) caps C(-6) spc\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e)}\\\n    col = mix(col, pow(vec3(.8),vec3(.4545)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    isTurntable = fetch(C_TURN_TABLE).x>.5;\\\n    switchShowFinal();\\\n    isTurntable = true;\\\n    float scale = 1.;\\\n    vec2 offset=vec2(0);\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    mouse = (vec3(iMouse.xy/iResolution.xy,.5)*2.)-1.;\\\n    if(num==1)mouse = mouse.xyz;\\\n    if(num==3)mouse = mouse.zyx;\\\n    if(num==7)mouse = mouse.xzy;\\\n    if(num==0)mouse = vec3(.0001);\\\n    vec3 Res = vec3(iResolution.xy, 0);\\\n    if(fetch(C_QUAD_VIEW).x>.5){\\\n        scale = 2.;\\\n        forceView = vec2(1,1);\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {isTurntable=false;forceView = vec2(1,1);offset=Res.zz;}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {isTurntable=false;forceView = vec2(1,7);offset=Res.zy;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {isTurntable=false;forceView = vec2(1,3);offset=Res.xz;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);offset=Res.xy;}\\\n    }\\\n    fragColor = vec4(renderRect(fragCoord*scale-offset),1);\\\n    if(fetch(C_QUAD_VIEW).x>.5 &&\\\n    ((fragCoord.x>Res.x*.5-1. && fragCoord.x<Res.x*.5+1.) ||\\\n    (fragCoord.y>Res.y*.5-1. && fragCoord.y<Res.y*.5+1.)))\\\n    fragColor = vec4(pow(THM_GRID,vec3(.4545)),1);\\\n    if(SHOW_FINAL)fragColor=packRenderData();\\\n}int dummy\\\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*\n  User Inputs\n\n  References:\n  \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n  \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n  \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n  \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n  Shows how to use the mouse input (only left button supported):\n       mouse.xy  = mouse position during last button down\n   abs(mouse.zw) = mouse position during last button click\n  sign(mouze.z)  = button is down\n  sign(mouze.w)  = button is clicked\n*/\n\nconst int K_PAD_0 = 96;\nconst int K_PAD_1 = 97;\nconst int K_PAD_2 = 98;\nconst int K_PAD_3 = 99;\nconst int K_PAD_4 = 100;\nconst int K_PAD_5 = 101;\nconst int K_PAD_6 = 102;\nconst int K_PAD_7 = 103;\nconst int K_PAD_8 = 104;\nconst int K_PAD_9 = 105;\n\nconst int K_NUM_0 = 48;\nconst int K_NUM_1 = 49;\nconst int K_NUM_2 = 50;\nconst int K_NUM_3 = 51;\nconst int K_NUM_4 = 52;\nconst int K_NUM_5 = 53;\nconst int K_NUM_6 = 54;\nconst int K_NUM_7 = 55;\nconst int K_NUM_8 = 56;\nconst int K_NUM_9 = 57;\n\nconst int K_W = 87;\nconst int K_A = 65;\nconst int K_S = 83;\nconst int K_D = 68;\nconst int K_E = 69;\nconst int K_Q = 81;\nconst int K_T = 84;\nconst int K_N = 78;\nconst int K_M = 77;\nconst int K_C = 67;\nconst int K_I = 73;\nconst int K_X = 88;\nconst int K_Y = 89;\nconst int K_Z = 90;\n\nconst int K_SHIFT = 16;\nconst int K_CTRL = 17;\nconst int K_ALT = 18;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 O, in vec2 C ){\n\n    if(iFrame < 2 ){O = vec4(0);return;}\n    \n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){O = (sign(iMouse.z)>.0) ? iMouse : last;return;}\n    \n    if(ID(C_CAMERA)){\n        O = last;\n        bool isFreeCamera = bool(last.y);\n        if((getKeypress(K_NUM_0)||getKeypress(K_PAD_0)) && sign(iMouse.z)<=.0)O = vec4(0, 0, 0, 0);\n        if(getState(K_NUM_1)||getState(K_PAD_1))O = vec4(1, true, 0, 0);\n        if(getState(K_NUM_3)||getState(K_PAD_3))O = vec4(3, true, 0, 0);\n        if(getState(K_NUM_7)||getState(K_PAD_7))O = vec4(7, true, 0, 0);\n        return;}\n    \n    if(ID(C_CAM_SCALE)){\n        if(getState(K_W))last-=.01;\n        if(getState(K_S))last+=.01;\n        O = last;\n        return;}\n    \n    if(ID(C_TARGET_X)){\n        if(getState(K_X) &&  getState(K_ALT))last+=.01;\n        if(getState(K_X) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n        \n    if(ID(C_TARGET_Y)){\n        if(getState(K_Y) &&  getState(K_ALT))last+=.01;\n        if(getState(K_Y) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n            \n    if(ID(C_TARGET_Z)){\n        if(getState(K_Z) &&  getState(K_ALT))last+=.01;\n        if(getState(K_Z) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n    if(ID(C_QUAD_VIEW))   {O = vec4(getToggle(K_Q));return;}\n    if(ID(C_TURN_TABLE))  {O = vec4(getToggle(K_T));return;}\n    if(ID(C_DEBUG_ISO))   {O = vec4(getToggle(K_I));return;}\n    if(ID(C_DEBUG_COST))  {O = vec4(getToggle(K_C));return;}\n    if(ID(C_DEBUG_MATCAP)){O = vec4(getToggle(K_M));return;}\n    if(ID(C_DEBUG_NORMAL)){O = vec4(getToggle(K_N));return;}\n    \n    // blank pixel\n    O = vec4(0,0,1,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float sabs(float x,float k) {\n\tfloat a = (.5/k)*x*x+k*.5;\n\tfloat b = abs(x);\n\treturn b<k ? a : b;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r){\n\tfloat k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tr*=1.35;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return min( a, b ) - h*h*h*r*(1.0/6.0);\n}\n\nfloat fOpSubstractionSmooth( float a,float b,float r){\n    //vec2 u = max(vec2(r + b,r + -a), vec2(0));\n\t//return min(-r, max (b, -a)) + length(u);\n\tr*=1.35;\n    a = -a;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return max( a, b ) + h*h*h*r*(1.0/6.0);\n}\n\nmat2 rot2d(float a) {\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\n#define CYCLE 4.\n\nfloat swTri(float v){\n    return asin(sin(v*TAU/CYCLE))*2./PI;\n}\n\nfloat uwTri(float v){\n    return s2u(swTri(v));\n}\n\nfloat cubicInOut(float t){return t < 0.5 ? 4.0 * t * t * t : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;}\n\nfloat uwCubic(float v){\n    return cubicInOut(uwTri(v));\n}\n\nfloat swCubic(float v){\n    return u2s(uwCubic(v));\n}\n\nfloat sdFinger(vec3 p, vec2 baseSize, vec4 frot) {\n    float min_mix = .001;\n    float base_mix = baseSize.x*2.7;\n    const float MAX_ROT = PI*.25;\n    frot *= MAX_ROT;\n    \n    // anchor points\n    vec3 p0 = p;\n    p0.yx *= rot2d(-frot.w);\n    p0.yz *= rot2d(-frot.x);\n    \n    vec3 p1 = p0-vec3(0,baseSize.y*1.166*2.,0);\n    p1.yz *= rot2d(-frot.y);\n    \n    vec3 p2 = p1-vec3(0,baseSize.y*2.,0);\n    p2.yz *= rot2d(-frot.z);\n    \n    float dRoot = sdEllipsoid(p0-vec3(0,baseSize.y*.6,0), baseSize.xyx*1.1);\n    float dFin0 = sdEllipsoid(p0-vec3(0,baseSize.y*1.166,0), baseSize.xyx*vec2(1., 1.15).xyx);\n    dFin0 = fOpUnionSmooth(dFin0, dRoot, .05); \n    float dFin1 = sdEllipsoid(p1+vec3(0,-baseSize.y*1.15,0), baseSize.xyx*vec2(1., 1.1).xyx);\n    float dFin2 = sdEllipsoid(p2+vec3(0,-baseSize.x*1.5,0), baseSize.xxx*1.15);\n\n    // combine all\n    float d = fOpUnionSmooth(dFin0, dFin1, base_mix*.9+min_mix);\n    d = fOpUnionSmooth(d, dFin2, base_mix*1.1+min_mix);\n    \n    return d;\n}\n\nfloat sdPalm(vec3 p) {\n    float d= sdEllipsoid(p, vec2(0.17, .1).xxy);\n    d = fOpSubstractionSmooth(sdEllipsoid(p+vec3(-.1,0,.17), vec2(0.17, .1).xxy), d, .15);\n    return d;\n}\n\nfloat sdHand(vec3 p, vec4 frot0, vec4 frot1, vec4 frot2, vec4 frot3) {\n    float bd = length(p-vec3(0,.25,0))-.6;\n    if(bd>.1) return bd;\n    \n    p.y-=.27;\n    p.x-=.09;\n    vec2 baseSize = vec2(.175, .25);\n    float winkleStart = 2.;\n    \n    // anchor points\n    vec3 p0 = p;\n    p0 += vec3(-.0,.13,.05);\n    p0 = rot(p0, vec3(-.75,-1.5,.75));\n    \n    vec3 p1 = p;\n    p1 += vec3(0,0,0);\n    p1 = rot(p1, vec3(0,0,.25));\n    \n    vec3 p2 = p;\n    p2 += vec3(.1,-.015,0);\n    p2 = rot(p2, vec3(0,0,0));\n    \n    vec3 p3 = p;\n    p3 += vec3(.19,0,0);\n    p3 = rot(p3, vec3(0,0,-.25));\n    \n    // combine all\n    float d = sdPalm(p+vec3(.09,.1,0));\n    vec2 scale = vec2(.9, 1.);\n    d = fOpUnionSmooth(d, sdFinger(p0, vec2(0.039, .06)*scale, frot0*.9), .001+.25 * smoothstep(.2, .0, length(p0)));\n    d = fOpUnionSmooth(d, sdFinger(p1, vec2(0.036, .07)*scale, frot1*.75), .001+.065 * smoothstep(.2, .1, length(p1)));\n    d = fOpUnionSmooth(d, sdFinger(p2, vec2(0.036, .07)*scale, frot2*.8), .001+.065 * smoothstep(.2, .1, length(p2)));\n    d = fOpUnionSmooth(d, sdFinger(p3, vec2(0.0325, .0625)*scale, frot3*.8), .001+.06 * smoothstep(.2, .1, length(p3)));\n    \n    return d-.01;\n}\n\nfloat map(vec3 p){\n    p.y+=.3;\n    float t = iTime*3.;\n    float rxyz0 = (swCubic(t+.5))*.15-.1;\n    float rxyz1 = (swCubic(t+.5)+1.)*1.3-.2;\n    float rxyz2 = (swCubic(t+.5*2.)+1.)*1.3-.2;\n    float rxyz3 = (swCubic(t+.5*3.)+1.)*1.3-.2;\n    float rw = swCubic(t)*.25;\n    vec4 frot0 = vec4(vec3(rxyz0), rw);\n    vec4 frot1 = vec4(vec3(rxyz1), rw);\n    vec4 frot2 = vec4(vec3(rxyz2), rw);\n    vec4 frot3 = vec4(vec3(rxyz3), rw);\n    return sdHand(p, frot0, frot1, frot2, frot3);\n}\n\nrender();\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}