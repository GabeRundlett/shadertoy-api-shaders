{
    "Shader": {
        "info": {
            "date": "1570796692",
            "description": "My attempt at ray-marching with scene definition, reflection and colors.\nIt's far from optimized and I'm open to any helping tips.",
            "flags": 0,
            "hasliked": 0,
            "id": "wdV3R1",
            "likes": 1,
            "name": "Ray-Marching : Inflating",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "klemek",
            "viewed": 287
        },
        "renderpass": [
            {
                "code": "/* \n\tPARTS :\n\t* CONSTANTS\n\t* UTILS\n\t* OBJECT DEFINITION\n\t* SCENE\n\t* RAY MARCHING\n\t* MAIN\n*/\n\n/*\n\tCONSTANTS\n*/\n\n#define MAX_STEPS 100\n#define SURFACE_DIST 1.5 / iResolution.y\n#define MAX_DIST 100.\n#define PI 3.14159\n\n#define TYPE_LIGHT 0\n#define TYPE_SPHERE 1\n#define TYPE_PLANE 2\n#define TYPE_CAPS 3\n#define TYPE_TORUS 4\n#define TYPE_BOX 5\n#define TYPE_CYL 6\n\n#define MAX_OBJECTS 10\n#define MAX_REFLECT 5\n\n/*\n\tUTILS\n*/\n\nmat3 rotY(float t)\n{\n    return mat3(\n        cos(t), 0, sin(t),\n        0, 1, 0,\n        -sin(t), 0, cos(t));\n}\n\n/*\n\tOBJECT DEFINITION\n*/\n\nstruct obj {\n    int type;\n    vec4 v;\n    vec4 w;\n    vec3 color;\n    float ref;\n};\n\nobj light(vec3 pos, vec3 color)\n{\n    return obj(TYPE_LIGHT, vec4(pos, 0), vec4(0), color, 0.);\n}\n\nobj sphere(vec3 pos, float r, vec3 color, float ref)\n{\n    return obj(TYPE_SPHERE, vec4(pos, r), vec4(0), color, ref);\n}\n\nobj plane(vec3 dir, float offset, vec3 color, float ref)\n{\n    return obj(TYPE_PLANE, vec4(dir, offset), vec4(0), color, ref);\n}\n\nobj capsule(vec3 pos1, vec3 pos2, float r, vec3 color, float ref)\n{\n    return obj(TYPE_CAPS, vec4(pos1, r), vec4(pos2, 0), color, ref);\n}\n\nobj torus(vec3 pos, float r1, float r2, vec3 color, float ref)\n{\n    return obj(TYPE_TORUS, vec4(pos, 0), vec4(r1, r2, 0, 0), color, ref);\n}\n\nobj box(vec3 pos, vec3 size, vec3 color, float ref)\n{\n    return obj(TYPE_BOX, vec4(pos, 0), vec4(size, 0), color, ref);\n}\n\nobj cylinder(vec3 pos1, vec3 pos2, float r, vec3 color, float ref)\n{\n    return obj(TYPE_CYL, vec4(pos1, r), vec4(pos2, 0), color, ref);\n}\n\n//get distance from an object by its type\nfloat getObjDist(vec3 p, obj o)\n{\n    switch (o.type) {\n    case TYPE_SPHERE:\n        return length(p - o.v.xyz) - o.v.w;\n    case TYPE_PLANE:\n        return dot(o.v.xyz, p) + o.v.w;\n    case TYPE_TORUS:\n        p -= o.v.xyz;\n        float x = length(p.xz) - o.w.x;\n        return length(vec2(x, p.y)) - o.w.y;\n    case TYPE_BOX:\n        p -= o.v.xyz;\n        return length(max(abs(p) - o.w.xyz, 0.));\n    case TYPE_CAPS:\n        vec3 ab1 = o.w.xyz - o.v.xyz;\n        vec3 ap1 = p - o.v.xyz;\n        float t1 = dot(ap1, ab1) / dot(ab1, ab1);\n        t1 = clamp(t1, 0., 1.);\n        vec3 c1 = o.v.xyz + t1 * ab1;\n        return length(p - c1) - o.v.w;\n    case TYPE_CYL:\n        vec3 ab2 = o.w.xyz - o.v.xyz;\n        vec3 ap2 = p - o.v.xyz;\n        float t2 = dot(ap2, ab2) / dot(ab2, ab2);\n        vec3 c2 = o.v.xyz + t2 * ab2;\n        float d = length(p - c2) - o.v.w;\n        float y = (abs(t2 - .5) - .5) * length(ab2);\n        float e = length(max(vec2(d, y), 0.));\n        float i = min(max(d, y), 0.);\n        return e + i;\n    }\n    return MAX_DIST;\n}\n\n/*\n\tSCENE\n*/\n\nobj scene[MAX_OBJECTS];\nint obj_count;\n\n/* \n\tRAY MARCHING\n*/\n\n//get distance from closest object in scene\nfloat getDist(vec3 p)\n{\n    float d = MAX_DIST;\n    for (int i = 0; i < obj_count; i++) {\n        d = min(d, getObjDist(p, scene[i]));\n    }\n    return d;\n}\n\n//get the normal vector of a point relative to the scene\nvec3 getNormal(vec3 p)\n{\n    float d = getDist(p);\n    vec2 e = vec2(.01, 0);\n\n    vec3 n = d - vec3(\n                     getDist(p - e.xyy),\n                     getDist(p - e.yxy),\n                     getDist(p - e.yyx));\n\n    return normalize(n);\n}\n\nstruct hit {\n    float dO;\n    float dS;\n    int index;\n};\n\n//return the closest object in scene and its distance\nhit getDist2(vec3 p)\n{\n    float d = MAX_DIST;\n    float t;\n    int hit_index = -1;\n    for (int i = 0; i < obj_count; i++) {\n        t = getObjDist(p, scene[i]);\n        if (t < d) {\n            hit_index = i;\n            d = t;\n        }\n    }\n    return hit(0., d, hit_index);\n}\n\n//ray march in a direction until an object is hit\nhit rayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.;\n    hit last;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + dO * rd;\n        last = getDist2(p);\n        dO += last.dS;\n        if (last.dS < SURFACE_DIST || dO > MAX_DIST)\n            break;\n    }\n    last.dO = dO;\n    return last;\n}\n\n//calculate the light influence on a point\nvec3 getLight(vec3 p, obj light)\n{\n    vec3 l = normalize(light.v.xyz - p);\n    vec3 n = getNormal(p);\n\n    float dif = clamp(dot(n, l), 0., 1.);\n\n    hit h = rayMarch(p + n * SURFACE_DIST * 2., l);\n    float ld = length(light.v.xyz - p);\n\n    if (h.dO < ld) {\n        dif *= .1;\n    }\n    return dif * light.color;\n}\n\n/*\n\tMAIN\n*/\n\n//add light from every sources\nvec3 getPointColor(vec3 p, vec3 hitColor)\n{\n    vec3 col = vec3(0);\n    for (int i = 0; i < obj_count; i++) {\n        if (scene[i].type == TYPE_LIGHT) {\n            col += getLight(p, scene[i]);\n        }\n    }\n    return col * hitColor;\n}\n\n//main calculation : hit and bounce over objects\nvec4 getColor(vec2 uv, vec3 ro, mat3 dir)\n{\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.)) * dir;\n\n    hit h = rayMarch(ro, rd);\n    vec3 p = ro + rd * h.dO;\n    vec3 col = vec3(0);\n    float ref = 1.;\n    int i = 0;\n    vec3 n;\n    while (h.index >= 0 && i++ < MAX_REFLECT) {\n        col += ref * getPointColor(p, scene[h.index].color) * (1. - scene[h.index].ref);\n        ref *= scene[h.index].ref;\n        if (ref > .01) {\n            n = getNormal(p);\n            rd -= 2. * dot(rd, n) * n;\n            h = rayMarch(p + rd * SURFACE_DIST * 2., rd);\n            p += (h.dO + SURFACE_DIST * 2.) * rd;\n        }\n        else {\n            break;\n        }\n    }\n\n    return vec4(col, 1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //normalize uv\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    //build scene\n    int i = 0;\n    scene[i++] = plane(vec3(0, 1, 0), 0., vec3(1.), .2);\n    scene[i++] = sphere(vec3(0, .5 + cos(iTime) * .2, -2), .5 + cos(iTime) * .2, vec3(0., 1., 0.), .5);\n    scene[i++] = box(vec3(0, .3, 0), vec3(.6, .3, .6), vec3(1., 0., 0.), .2);\n    scene[i++] = torus(vec3(0, 1. + sin(iTime) * .2, 0), .5, .1, vec3(1., 0., 0.), .2);\n    scene[i++] = capsule(vec3(0, .3, 0), vec3(0, .5 + cos(iTime) * .2, -2), .08 + cos(iTime) * .03, vec3(1., 1., 1.), 0.);\n    scene[i++] = cylinder(vec3(0, 0, 0), vec3(0, 1. + sin(iTime) * .2, 0), .2, vec3(1., 1., 1.), .2);\n    scene[i++] = light(vec3(2, 4, 0), vec3(.7, .3, .3));\n    scene[i++] = light(vec3(2, 4, .5), vec3(.3, .7, .3));\n\n    obj_count = i;\n\n    //specify camera\n    vec3 pos = vec3(cos(iTime - PI / 2.) * 3., 1. + cos(iTime * .3) * .5, sin(iTime - PI / 2.) * 3.);\n    mat3 dir = rotY(-iTime);\n\n    fragColor = getColor(uv, pos, dir);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}