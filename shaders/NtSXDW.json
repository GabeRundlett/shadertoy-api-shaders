{
    "Shader": {
        "info": {
            "date": "1627642701",
            "description": "This is a tool shader I wrote while writing a more complex shader to do 2d ray marching of 4d objects (this was simpler + let me test 3d shapes before 4d ones).\n2d ray marching produces a projection -- so 2d ray marching a 3d scene gives back a 1d image",
            "flags": 0,
            "hasliked": 0,
            "id": "NtSXDW",
            "likes": 1,
            "name": "2d ray marching - 3d sandbox",
            "published": 3,
            "tags": [
                "raymarching",
                "raymarching",
                "sandbox",
                "learning",
                "experimental",
                "2draymarching",
                "2draymarching"
            ],
            "usePreview": 0,
            "username": "xertrov",
            "viewed": 315
        },
        "renderpass": [
            {
                "code": "precision highp float;\n/*\n\n4D VERSION + EXPLANATION: <https://www.shadertoy.com/view/NtBXDW>\n\nDo 2d raymarching over 1 axis with secondary ray march for projections.\n\nThe result is shown on the LHS -- a 1d image of the ray marched YZ plane\nwith the XY plane projected on it.\n\nNote: some bits of shapes are missed (in this case they should all appear\nsolid), but SURF_DIST is set quite low here.\n\nThe yellow bits mean MAX_STEPS is reached without reaching MAX_DIST or\nSURF_DIST.\n\nset HIGH_RESOURCES to 1 to see more shapes, but FYI it runs hot.\n\n*/\n\n#define MAX_STEPS 70\n#define MAX_DIST 25.\n#define SURF_DIST 0.001\n\n#define HIGH_RESOURCES 0\n\n\n// i used 'sld' for \"signed line-dist\" b/c I was trying to do the projection\n// via the distance between a point an a line (our ray direction is a normal\n// this line), but couldn't get it to work. I don't think it can work, but if\n// it could then it might speed things up a lot.\n\nvec4 sldBox(in vec3 p, in vec3 b) {\n  vec3 d = abs(p) - b;  // point on the line to corner\n  float l = length(max(d, 0.0)) + min(max(d.z, max(d.x, d.y)), 0.0);\n  return vec4(l, d);\n}\n\nvec4 sldBoxEdges(vec3 p, in vec3 s) {\n  vec3 d = abs(p) - s;\n  float l = length(best2(d));\n  return vec4(l, d);\n}\n\nvec4 minWith(vec4 a, vec4 b) {\n  return (min(0., (a.x - b.x)) * a + min(0., (b.x - a.x)) * b) * -1. / abs(b.x - a.x);\n}\n\nfloat mapWDists(vec3 p, out vec3 dists) {\n  mat3 r1 = rot3XY(u_time, 3), r2 = rot3XY(u_time * .48597, 1);\n  // r1 = rot3XY(u_time * .0, 3), r2 = rot3XY(u_time * .763 * .0, 2);\n  vec4 boxEdges = sldBoxEdges((p - vec3(0.4, 1.0 , 0)) * r2 * r2 * r1, vec3(.3)) - .01;\n  vec4 box = sldBox(p * r2 * r1, vec3(.3)) - .01;\n  vec4 tri = sdTriangle2((p - vec3(-.4, -.9, 0)) * r2 * r1, .3) - .01;\n  vec4 tri2 = sdTriangle1((p - vec3(.4, -1.4, 0)) * r2 * r1, .3) - .01;\n  vec4 tet;\n  tet.x = sdTetrahedron((p - vec3(.4, 1.9, 0)) * r2 * r1, .3, tet.yzw) - .01;\n\n  vec4 tri3;\n  tri3.x = sdTriangleGen((p - vec3(.5, 1.9, 0)) * r2 * r1, .3, tri3.yzw) - .01;\n\n  vec4 m = minWith(boxEdges, vec4(999.));\n  m = minWith(m, tri2);\n\n  if (HIGH_RESOURCES == 1) {\n    m = minWith(m, box);\n    m = minWith(m, tri);\n  }\n\n  dists = m.yzw;\n  return m.x;\n}\n\nfloat map(vec3 p) {\n  vec3 temp;\n  return mapWDists(p, temp);\n}\n\nvec4 rayMarch(inout vec3 p, in vec3 rd, out vec3 dists) {\n  float dS = 99., d = 0., minDS = dS, steps = 0.;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    steps += 1.;\n    dS = mapWDists(p, dists);\n    minDS = min(minDS, abs(dS));\n    d += dS;\n    p = p + rd * dS;\n    if ((0. <= dS && dS < SURF_DIST) || d > MAX_DIST) break;\n  }\n  return vec4(d, dS, minDS, steps);\n}\n\nvec2 e = vec2(.0001, 0);\n\nvec4 rayMarch1d(inout vec3 p, in vec3 rd, in vec3 rd2, out vec3 dists) {\n  float dS = 99., dSx = 99., dSy, dSz, d = 0., minDS = dS, steps = 0.;\n  vec3 dists2;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    steps += 1.;\n    dS = 99.;\n    dS = mapWDists(p, dists);\n    minDS = min(minDS, abs(dS));\n    if (dS > SURF_DIST) {\n      vec3 p2 = p - rd2 * 2.;\n      vec4 innerRmd = rayMarch(p2, rd2, dists2);\n      // steps += innerRmd.w;\n      if (innerRmd.x < MAX_DIST && innerRmd.y < SURF_DIST) {\n        p = p2;\n        return vec4(length(vec2(innerRmd.x, d)), innerRmd.yz, steps);\n      } else {\n        dS = min(dS, min(innerRmd.y, 99.));\n        minDS = min(minDS, abs(innerRmd.z));\n      }\n    }\n    // backported chBasis + slow_thru from 4d version\n    mat3 chBasis = mat3(rd.x, rd.y, rd.z, 0, 0, 0, rd2.x, rd2.y, rd2.z);\n    vec3 components = normalize(dists * chBasis);\n    d += dS;\n    float dsFactor = maxOf(vec4(components.xz, -components.xz));\n    dsFactor *= min(1., max(minOf(abs(p)) + .08, .01));\n    p = p + rd * dS * dsFactor;\n    if ((0. <= dS && dS < SURF_DIST) || d > MAX_DIST) break;\n  }\n  return vec4(d, dS, minDS, steps);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // split screen first\n  vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n  float aspect = u_resolution.x / u_resolution.y;\n  float id = sign(uv.x - .5);\n  uv.x = (fract(uv.x * 2.) - .5) * aspect;\n  uv.y -= .5;\n  vec2 mouse = (u_mouse.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n  float t = u_time *3.;\n  vec3 col = BLACK;\n\n  float zoom = 3.0;\n  uv *= zoom * vec2(1.0, 2.0);\n  float maxU = zoom / 2. * aspect;\n  vec2 fw = fwidth(uv);\n\n  // starting with this at -2 (like you might with the z axis) results in issues rendering b/c the ray doesn't pass close enough to the objects to get the sideways projection right.\n  float xStart = hh(id) * uv.x;  // 0 for left, 1 for right\n  float yStart = uv.y + .5;\n  vec3 ro = vec3(xStart, yStart, -2);\n  vec3 rd = vec3(0, 0, 1);\n  vec3 xAxis = vec3(1, 0, 0);\n  mat3 r = rot3XY(t / 3., 1);\n  ro *= r;\n  rd *= r;\n  xAxis *= r;\n\n  vec3 p = ro, dists;\n  vec4 rmd;\n  if (id < 0.) {\n    rmd = rayMarch1d(p, rd, xAxis, dists);\n  } else {\n    rmd = rayMarch(p, rd, dists);\n  }\n\n  float d = rmd.x, dS = rmd.y, minDS = rmd.z, steps = rmd.w;\n\n  if (d > MAX_DIST) {\n    col = vec3(.95, .1, .7);\n  } else if (steps >= float(MAX_STEPS)) {\n    col = vec3(.8, .9, .1);\n  } else {\n    col.r += max(1. / (1. + d), 0.);\n    col.b = clamp(p.x, 0., 1.);\n  }\n\n  //col.g += max(1. / (1. + minDS), 0.);\n  //col.g += minDS / 2.;\n  //col.b += 1. / (1. + minDS);\n  //col += S(SURF_DIST * 2., SURF_DIST, minDS);\n\n  /* lines marking origin */\n  col.b += S(fw.x * 2., .0, abs(uv.x));\n  col.b += S(fw.y * 2., .0, abs(uv.y));\n  float around = .25;\n\n  col *= S((-maxU + fw.x * 3.) * id, (-maxU + fw.x * 5.) * id, uv.x);\n\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/* copy pasted from my libs. lots is written by me. you're welcome to use it, but caveat emptor. */\n\n#define u_resolution iResolution\n#define u_mouse iMouse\n#define u_time iTime\n#define gl_FragColor fragColor\n\n#define PI 3.141592653589\n#define TAU 6.28318530718\n\n#define SQRT_3 1.7320508\n#define SQRT_2 1.41421356\n\n#define S(a, b, t)smoothstep(a, b, t)\n#define hh(x)(x * 0.5 + 0.5)\n#define zoth vec4(0.0, 1.0, 2.0, 0.5)\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n\nvec2 best2(vec3 p) {\n  vec2 r = vec2(max(p.x, p.y), min(p.x, p.y)); // : vec2(p.y, p.x);\n  if (p.z > r.x) { return vec2(p.z, r.x);}\n  if (p.z > r.y) { return vec2(r.x, p.z);}\n  return r;\n}\n\nvec2 best2(vec4 p) {\n  vec2 r = p.x > p.y ? vec2(p.x, p.y) : vec2(p.y, p.x);\n  if (p.z > r.x) { r = vec2(p.z, r.x); }\n  else if (p.z > r.y) { r = vec2(r.x, p.z); }\n  if (p.w > r.x) { return vec2(p.w, r.x); }\n  else if (p.w > r.y) { return vec2(r.x, p.w); }\n  return r;\n}\n\nfloat minOf(vec2 v) {\n  return min(v.x, v.y);\n}\nfloat maxOf(vec2 v) {\n  return max(v.x, v.y);\n}\nfloat sumOf(vec2 v) {\n  return v.x + v.y;\n}\n\nfloat minOf(vec3 v) {\n  return min(minOf(v.xy), v.z);\n}\nfloat maxOf(vec3 v) {\n  return max(maxOf(v.xy), v.z);\n}\nfloat sumOf(vec3 v) {\n  return sumOf(v.xy) + v.z;\n}\n\nfloat minOf(vec4 v) {\n  return min(minOf(v.xyz), v.w);\n}\nfloat maxOf(vec4 v) {\n  return max(maxOf(v.xyz), v.w);\n}\nfloat sumOf(vec4 v) {\n  return sumOf(v.xyz) + v.w;\n}\n\nfloat bestOf(vec2 p) {\n  // return p.x > p.y ? p.x : p.y;\n  return max(p.x, p.y);\n}\nfloat bestOf(vec3 p) {\n  return max(max(p.x, p.y), p.z);\n}\nfloat bestOf(vec4 p) {\n  return max(bestOf(p.xyz), p.w);\n}\n\n\nvec2 sinCos(in vec2 ab) {\n  return vec2(sin(ab.x), cos(ab.y));\n}\nvec2 sinCos(in float a) {\n  return vec2(sin(a), cos(a));\n}\n\n// roll from XY to XZ or YZ (0 no roll, 1=XZ, 2=YZ)\nmat3 rot3XY(float angle, int roll) {\n  float s = sin(angle), c = cos(angle);\n  mat3 r = mat3(c, - s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n  if (roll == 1) {\n    r = mat3(r[0].xzy, r[2].xzy, r[1].xzy);\n  } else if (roll == 2) {\n    r = mat3(r[2].zxy, r[0].zxy, r[1].zxy);\n  }\n  return r;\n}\n\n\n// Some SDFs\n\n\nfloat sdTriangle1(vec2 uv, float b) {\n  float willFold = sign(step(.0, -uv.x) + (step(.0, -uv.y) * step(0., -dot(sinCos(TAU / 12.), uv))));\n  float splitAt = -dot(sinCos(- 7. * TAU / 12.), uv);\n  float top = sign(splitAt);\n  float foldAngle = (step(0., top) * TAU / 4. + step(0., -top) * (TAU / 12.)) * willFold;\n  vec2 n = sinCos(foldAngle);\n  float fold = -dot(n, uv) * willFold;\n  uv += fold * n * 2.;\n  // get distance to line that is our edge\n  return dot(uv, sinCos(TAU / 6.)) - b * .5;\n}\n\nvec4 sdTriangle1(vec3 p, float b) {\n  return vec4(length(vec2(sdTriangle1(p.xy, b), p.z)), abs(p)); // approximate dists for each axis\n}\n\nfloat sdTriangle2(vec2 uv, float b) {\n  float a = atan(uv.x, uv.y) + PI;\n  float id = floor(a * 3. / TAU) - 1.;\n  vec2 n = sinCos(-id * 7. * TAU / 12.);\n  uv += - abs(id) * dot(n, uv) * n * 2.;\n  return  uv.y - b / 2.;  // estimate based only on y; but it works...\n}\n\nvec4 sdTriangle2(vec3 p, float b) {\n  vec3 dd = abs(p) - vec3(0,b,0);\n  return vec4(length(vec2(sdTriangle2(p.xy, b), p.z)), dd);\n}\n\nvec2 foldXyThirds(vec2 uv, out float id) {\n  float a = atan(uv.x, uv.y) + PI;\n  id = floor(a * 3. / TAU) - 1.;\n  vec2 n = sinCos(-id * 7. * TAU / 12.);\n  uv += - abs(id) * dot(n, uv) * n * 2.;\n  return abs(uv);\n}\n\nvec2 foldXyThirds(vec2 uv) {\n  float id;\n  return foldXyThirds(uv, id);\n}\n\nfloat sdTriangleGen(vec3 p, float r, out vec3 dists) {\n  p.xy = foldXyThirds(p.xy);\n\n  vec3 a = vec3(r / 2. * SQRT_3, r / 2., 0.);\n  vec3 b = a * vec3(-1, 1, 1);\n  vec3 ap = p - a;\n  vec3 ab = b - a;\n  //* (step(r / 2., p.y) * 2. - 1.)\n  float dotPaBa = dot(ap, ab);\n  float dotBaBa = dot(ab, ab);\n  float h = clamp(dotPaBa / dotBaBa, -0., 1.);\n  dists = ap - h * ab;\n  float d = length(dists);\n  // for negative:\n  // * (step(r / 2., p.y) * 2. - 1.);\n\n  return d;\n}\n\n/* searching for a similar generalized tetrahedron method didn't work,\nbut i found some fun triangle methods.\n\nThe following isn't exact, but it's p nice:\n*/\n\n\nvec3 sdTetrahedronInner(vec3 p, float r) {\n  float ySign = sign(p.y);\n  p.xz = abs(ySign < 0. ? p.zx : p.xz);\n  p.y = abs(p.y);\n  vec3 box = vec3(mix(r/2., r, p.y / r), r, mix(r/2., r, -p.y / r));\n  return p - box;\n}\n\nfloat sdTetrahedron(vec3 p, float r, out vec3 dists) {\n  dists = sdTetrahedronInner(p, r);\n  return length(bestOf(dists));\n}\n\nfloat sdTetrahedronFrame(vec3 p, float r, out vec3 dists) {\n  dists = sdTetrahedronInner(p, r);\n  return length(best2(dists));\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}