{
    "Shader": {
        "info": {
            "date": "1654154742",
            "description": "Cubeworld ([url]https://www.shadertoy.com/view/tsXBzs[/url]) again, but instead of every face leading back to the same cube, every face leads back to a different cube. Inspired by [url]https://www.shadertoy.com/view/7dlyW7[/url] by SchnitzelKiller.",
            "flags": 0,
            "hasliked": 0,
            "id": "fs3yDf",
            "likes": 9,
            "name": "Lattice of Forking Paths",
            "published": 3,
            "tags": [
                "cube",
                "lattice",
                "noneuclidean",
                "feistel"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 327
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Lattice of Forking Paths\n// Matthew Arcus, mla, 2022\n//\n// Based on https://www.shadertoy.com/view/tsXBzs, but instead of every face\n// leading back to the same cube, every face leads to a completely different\n// cube, with each path leading to a different cube.\n//\n// We need to keep track of the path through the lattice, this is done with\n// an iterated hash (so we're using blockchain technology!). The hash is a\n// simple Feistel network so moving through a face one way undoes the effect\n// of moving through the other way.\n//\n// Navigation is just moving on a line. Mouse changes view direction.\n// Repeats every 60 seconds to avoid excessive time computing the start\n// cube (I should store this in a texture).\n//\n// Inspired by https://www.shadertoy.com/view/7dlyW7 by SchnitzelKiller.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\nfloat maxdist = 50.0;\nint maxiterations = 100;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nfloat stepsize(vec3 p, vec3 r) {\n  // Want least k such that p + kr has coordinate 1 in some dimension\n  // eg. p.x+kr.x = 1 => k = (1-p.x)/r.x\n  // eg. p.x+kr.x = 0 => k = -p.x/r.x\n  // Want k positive, so assuming p.x is 0 < p.x < 1, depends on r.\n  float k = 1e8;\n  if (r.x > 0.0) k = min(k,(1.0-p.x)/r.x);\n  else if (r.x < 0.0) k = min(k,-p.x/r.x);\n  if (r.y > 0.0) k = min(k,(1.0-p.y)/r.y);\n  else if (r.y < 0.0) k = min(k,-p.y/r.y);\n  if (r.z > 0.0) k = min(k,(1.0-p.z)/r.z);\n  else if (r.z < 0.0) k = min(k,-p.z/r.z);\n  return k;\n}\n\n// Having moved to a face & just beyond, work out which face\n// we have hit. What happens if we are close to the edge & in\n// fact have passed through 2 faces?\nint gethitface(vec3 p) {\n  if (p.x > 1.0) return 0;\n  if (p.x < 0.0) return 1;\n  if (p.y > 1.0) return 2;\n  if (p.y < 0.0) return 3;\n  if (p.z > 1.0) return 4;\n  if (p.z < 0.0) return 5;\n  return -1;\n}\n\nvoid nextpos(int hitface, inout vec3 p) {\n  if (hitface == 0) p.x -= 1.0;\n  if (hitface == 1) p.x += 1.0;\n  if (hitface == 2) p.y -= 1.0;\n  if (hitface == 3) p.y += 1.0;\n  if (hitface == 4) p.z -= 1.0;\n  if (hitface == 5) p.z += 1.0;\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nuvec2 update(uvec2 type, int hitface) {\n  uint k = uint((hitface>>1)+1);\n  uint n0 = type[0];\n  uint n1 = type[1];\n  if ((hitface&1) == 0) {\n    n0 ^= ihash(n1^k);\n    n1 ^= ihash(n0^k);\n  } else {\n    n1 ^= ihash(n0^k);\n    n0 ^= ihash(n1^k);\n  }\n  return uvec2(n0,n1);\n}\n\nbool traceray(inout vec3 p, inout vec3 r, out int hitface, inout uvec2 type, out float totaldist) {\n  totaldist = 0.0;\n  vec3 p0 = p;\n  for (int i = 0; i < maxiterations; i++) {\n    assert(i+1 < maxiterations);\n    float eps = 1e-3;\n    float k = stepsize(p,r)+eps;\n    p += k*r;\n    totaldist += k;\n    if (totaldist > maxdist) return false;\n    // determine the hit face\n    hitface = gethitface(p);\n    type = update(type,hitface);\n    vec3 border = min(p,1.0-p);\n    // Have we hit the face frames?\n    float framewidth = 0.05;\n    if (true) {\n      if (hitface/2 == 0 && min(border.y,border.z) < framewidth) return true;\n      if (hitface/2 == 1 && min(border.z,border.x) < framewidth) return true;\n      if (hitface/2 == 2 && min(border.x,border.y) < framewidth) return true;\n    }\n    // Advance p\n    nextpos(hitface,p);\n  }\n  assert(false); // We should have enough iterations to get to maxdist\n  return false;\n}\n\nvoid moveforward(inout vec3 p, vec3 dir, float t, inout uvec2 type) {\n  for (int i = 0; i < 50; i++) {\n    assert(i < 49);\n    float k = stepsize(p,dir) ;\n    float eps = 1e-3;\n    if (t <= k) {\n      p += t*dir;\n      return;\n    }\n    k += eps;\n    p += k*dir;\n    t -= k;\n    int hitface = gethitface(p);\n    type = update(type,hitface);\n    nextpos(hitface,p);\n  }\n  assert(false);\n}\n\nvec3 bgcol = vec3(1,1,0.5);\n\nvec3 colors[] =\n  vec3[](vec3(1,0,0),\n         vec3(0,1,0),\n         vec3(0,0,1),\n         vec3(1,1,0),\n         vec3(1,0,1),\n         vec3(0,1,1));\n         \nvec3 getcolor(uint type) {\n  type = ihash(type);\n  return colors[type%uint(colors.length())];\n}\n\nvec3 normal(int hitface) {\n  vec3 n = vec3(0);\n  n[hitface>>1] = 1.0;\n  return n;\n}\n\nvec3 raycolor(vec3 p, vec3 r, uvec2 type) {\n  float totaldist;\n  int hitface;\n  if (!traceray(p,r,hitface,type,totaldist)) return bgcol;\n  vec3 color = 0.8*getcolor(type[0]^type[1]);\n  vec3 light = normalize(vec3(0,1,-0.5));\n  vec3 n = normal(hitface);\n  if (dot(n,r) > 0.0) n = -n;\n  color *= 0.4+0.4*clamp(dot(light,n),0.0,1.0);\n  color = mix(color,bgcol,totaldist/maxdist);\n  return color;\n}\n\nvec2 rotate(vec2 p, float t) {\n  return mat2(cos(t),sin(t),-sin(t),cos(t))*p;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (false) {\n    p.zx = rotate(p.zx,iTime * 0.2);\n    p.xy = rotate(p.xy,iTime * 0.125);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 col = vec3(0);\n  float AA = 2.0;\n  vec3 p0 = vec3(0.5);\n  uvec2 type0 = uvec2(0x12345678U,0x87654321U);\n  moveforward(p0,vec3(0,0.618,1),mod(0.5*iTime,30.0),type0);\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec3 p = p0;\n      uvec2 type = type0;\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 r = vec3(uv,2);\n      r = transform(r);\n      r = normalize(r); // Normalize after transform\n      vec3 c = raycolor(p,r,type);\n      col += c;\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545));\n  if (alert) col = vec3(1,0,0);\n  fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}