{
    "Shader": {
        "info": {
            "date": "1590893943",
            "description": "21",
            "flags": 0,
            "hasliked": 0,
            "id": "tdSBzc",
            "likes": 2,
            "name": "just21",
            "published": 3,
            "tags": [
                "number",
                "box",
                "gyroid"
            ],
            "usePreview": 0,
            "username": "elle",
            "viewed": 273
        },
        "renderpass": [
            {
                "code": "#define BOX_CNT 7\n#define EPS\t0.0001\n#define MAX_STEPS 100\n#define MAX_DIST 200.0\n#define NUMBER1 0\n#define NUMBER2 1\n#define PLANE\t2\n\nstruct Intersect {\n    int\t\tidx;\n    float\tdist;};\n\nstruct Point\t{\n\tvec3\tpos;\n    vec3\tcol;};\n    \nvec3 diffCol[] = vec3[](vec3(0.0, 1.0, 0.7),\n\t\t\t\t\t\tvec3(1.0, 1.0, 0.0),\n\t\t\t\t\t\tvec3(0.8, 0.0, 0.8));\n\nfloat diff[] =  float[](0.4,  0.4,  0.5);\nfloat spec[] =  float[](0.8,  0.9,  0.2);\nfloat specPow[]=float[](64.0, 32.0, 4.0);\n\nvec3 rotate(vec3 p, float angleX, float angleY, float angleZ)\n{\n    float cosA = cos(angleY);\n\tfloat sinA = sin(angleY);\n\tvec3 r = vec3(p.x, sinA * p.z + cosA * p.y, cosA * p.z - sinA * p.y);\n    cosA = cos(angleX);\n\tsinA = sin(angleX);\n\tr = (-vec3(cosA * r.x - sinA * r.z, r.y, sinA * r.x + cosA * r.z));\n    cosA = cos(angleZ);\n\tsinA = sin(angleZ);\n\treturn (vec3(cosA * r.x - sinA * r.y, sinA * r.x + cosA * r.y, r.z));\n}\n\n//https://iquilezles.org/articles/distfunctions\nvec2 repeat(in vec2 p, in float s, in vec2 lim)\n{\n    return p - s * clamp(round(p / s), -lim, lim);\n}\n\n\nfloat gyroidDist(vec3 p, float scale, float thickness, float bias)\n{\n\tp *= scale;\n    return abs(dot(sin(p), cos(p.zxy)) + bias) / (scale) - thickness;\n}\n\n\nfloat planeDist(in vec3 pos, in vec4 normal)\n{\n    return (dot(pos, normal.xyz) + normal.w);\n}\n\n\nfloat box(vec3 p)\n{\n\tfloat b = 1.0;\n\tfloat rounding = 0.6;\n\treturn length(max(abs(p) - b, 0.0)) - rounding;\n}\n\nfloat blob(float dist[BOX_CNT], int i1, int i2)\n{\n    float k = 2.2;\n    float res = 0.0;\n    for (int i = i1; i <= i2; i++)\n        res += exp(-k * dist[i]);\n\treturn -log(res)/k;\n}\n\n\nIntersect sceneDist(vec3 pos)\n{   \n    Intersect res;\n\tfloat SINt = sin(iTime * 0.5);\n    \n    float dist[BOX_CNT];\n    vec3 p1 = pos + vec3( 6.0, -6.0, 0.0);\n    vec3 p2 = pos + vec3( 3.0,  6.0, 0.0);\n    vec3 p3 = pos + vec3( 0.0, -3.0, 0.0);\n    vec3 p4 = pos + vec3( 9.0,  3.0, 0.0);\n    vec3 p5 = pos + vec3( 4.35, 0.0, 0.0);\n    \n    vec3 p6 = pos + vec3(-7.0,  1.5, 0.0);\n    vec3 p7 = pos + vec3(-4.0, -6.0, 0.0);\n\n    p1.xy = repeat(p1.xy, 2.0, vec2(1.5, 0.0));\n\tp2.xy = repeat(p2.xy, 2.0, vec2(1.5, 0.0));\n    p5.xy = repeat(p5.xy, 2.0, vec2(0.9, 0.0));\n    p6.xy = repeat(p6.xy, 2.0, vec2(0.0, 2.2));\n \n    //2\n    dist[0] = box(rotate(p1, 0.0, 8.0 * clamp(SINt - 0.0, 0.0, 0.2), 0.0));\n    dist[1] = box(rotate(p2, 0.0, 8.0 * clamp(SINt - 0.2, 0.0, 0.2), 0.0));\n    dist[2] = box(rotate(p3, 0.0, 8.0 * clamp(SINt - 0.05, 0.0, 0.2), 0.0));\n    dist[3] = box(rotate(p4, 0.0, 8.0 * clamp(SINt - 0.15, 0.0, 0.2), 0.0));\n    dist[4] = box(rotate(p5, 0.0, 8.0 * clamp(SINt - 0.1, 0.0, 0.2), 0.0));\n    //1\n    dist[5] = box(rotate(p6, 8.0 * clamp(SINt - 0.3, 0.0, 0.2), 0.0, 0.0));\n    dist[6] = box(rotate(p7, 0.0, 0.0, 8.0 * clamp(SINt - 0.25, 0.0, 0.2)));\n    \n    float distPlane = planeDist(pos, vec4(0.0, 1.0, 0.0, 100.0));\n    \n    float distBox = min(blob(dist, 0, 4), blob(dist, 4, 6));\n    \n    res.dist = min(distPlane, distBox);\n    if (res.dist == distPlane)\n        res.idx = PLANE;\n    else if (SINt <= 0.4) \n    \tres.idx = NUMBER1;\n    else\n        res.idx = NUMBER2;\n    return (res);\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n    sceneDist(vec3(p.x + EPS, p.y, p.z)).dist - sceneDist(vec3(p.x - EPS, p.y, p.z)).dist,\n    sceneDist(vec3(p.x, p.y + EPS, p.z)).dist - sceneDist(vec3(p.x, p.y - EPS, p.z)).dist,\n    sceneDist(vec3(p.x, p.y, p.z  + EPS)).dist - sceneDist(vec3(p.x, p.y, p.z - EPS)).dist));\n}\n\n\nIntersect rayMarch(vec3 ro, vec3 rd)\n{\n    Intersect d;\n    Intersect intersect;\n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        d = sceneDist(ro + intersect.dist * rd);\n        intersect.dist += d.dist;\n        if (intersect.dist < EPS || intersect.dist >= MAX_DIST)\n            break;\n    }\n    intersect.idx = d.idx;\n    return (intersect);\n}\n\nfloat getShadow(in vec3 ro, in vec3 rd, in float min_t, in float max_t, in float k)\n{\n    float res = 1.0;\n    for (float t = min_t; t < max_t;)\n    {\n        float dist = sceneDist(ro + rd * t).dist;\n        if (dist < EPS)\n            return 0.0;\n        res = min(res, k * dist / t);\n        t += dist;\n    }\n    return (res);\n}\n\nvec3 getLight(int idx, vec3 pos, vec3 eye, vec3 lightPos)\n{\n    vec3 diffuseCol = diffCol[idx];\n    vec3 specularCol = vec3(1.0);\n    vec3 Norm = getNormal(pos);\n    vec3 Ldir = normalize(lightPos - pos);\n    vec3 View = normalize(eye - pos);\n    vec3 Refl = normalize(reflect(-Ldir, Norm));\n\n    float dotLN = dot(Ldir, Norm);\n    float dotRV = dot(Refl, View);\n\n    // light not visible\n    if (dotLN < 0.0)\n        return vec3(0.0);\n\n    // light reflection in opposite direction, apply only diffuse lighting\n    if (dotRV < 0.0)\n        return 1.7 * (diffuseCol * dotLN) * diff[idx];\n\n    vec3 half_direction = normalize(normalize(Ldir) + View);\n    float specular = pow(max(dot(half_direction, Norm), 0.0), specPow[idx]);\n    return 1.7 * diffuseCol * dotLN * diff[idx] + specularCol * specular * spec[idx];\n}\n\nPoint getColor(vec3 ro, vec3 rd, vec3 eye, vec3 lightPos, vec2 uv)\n{\n    Point point;\n    Intersect intersect = rayMarch(ro, rd);\n    point.pos = ro + intersect.dist * rd;\n    if (intersect.dist > MAX_DIST - EPS)\n    {\n        float bg = gyroidDist(rotate(vec3(uv.x, uv.y, iTime*0.3), 0.0, cos(iTime*0.01), cos(iTime*0.01)), 28.0, 0.001, 3.0);\n        point.col += abs(bg) * 6.0;\n        point.col *= vec3(rd.y + 0.4, 0.05, rd.y + 0.7); //background\n    }\n    else\n    {    \n\t\t//ambient\n        vec3 ambientCol = vec3(0.5, 0.5, 0.5);    \n    \tvec3 ambientLight = 0.3 * vec3(1.0);\n    \tpoint.col = ambientLight * ambientCol;\n\n    \t//shadow\n    \tvec3 shadowDir = normalize(lightPos - point.pos);\n    \tfloat shadow = getShadow(point.pos + shadowDir, shadowDir, 0.0, MAX_DIST, 8.0);\n\n    \t//diffuse + specular\n    \tvec3 blinn_phong = getLight(intersect.idx, point.pos, eye, lightPos) * shadow;\n    \tpoint.col += blinn_phong;\n    }\n    return point;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 aspectRatio = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 uv = aspectRatio * (fragCoord.xy / iResolution.xy - 0.5);\n    vec2 mouse = 6.4 * (iMouse.xy / iResolution.xy);\n\tfloat SINt = 0.5 + 0.5 * sin(iTime * 0.6);\n\tvec3 ro = rotate(vec3(0.0, 0.0, 30.0), SINt - 0.4 , 0.0, 0.0);\n    vec3 rd = -rotate(vec3(uv, 1.0), SINt - 0.4, 0.0, 0.0);  \n\tvec3 lightPos = rotate(vec3(5.0, -10.0, 80.0), 0.0, 0.0, 0.0);\t  \n    \n    Point point = getColor(ro, rd, ro, lightPos, uv);\n\tvec3 color = point.col;   \n    \n    vec3 rd1 = rd - (2.0 * dot(rd, getNormal(point.pos)) * getNormal(point.pos));\n    Point point2 = getColor(point.pos + rd1, rd1, ro, lightPos, uv);\n    color = mix(color, point2.col, 0.2);\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}