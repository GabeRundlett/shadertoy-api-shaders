{
    "Shader": {
        "info": {
            "date": "1468668749",
            "description": "A shader inspried by the train through the Euro Tunnel, made at and for the Sundown 2016 Shadertoy competition.\nBrought to you by TropicalTrevor and Glow / Poobrainque.\n",
            "flags": 96,
            "hasliked": 0,
            "id": "ltc3Wn",
            "likes": 52,
            "name": "Euro Tunnel",
            "published": 3,
            "tags": [
                "raymarching",
                "tunnel",
                "eurotunnel",
                "sundown"
            ],
            "usePreview": 0,
            "username": "Daedelus",
            "viewed": 1728
        },
        "renderpass": [
            {
                "code": "//vblur\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float w = 0.5;\n    float tw = 0.0;\n    vec4 c = vec4(0.0);\n    vec2 stp = vec2(0.0, 2.0 / iResolution.y);\n    for(int i = 0 ; i < 32; ++i)\n    {\n        c += texture(iChannel0, uv + float(i) * stp) * w;\n        c += texture(iChannel0, uv - float(i) * stp) * w;\n        tw += w + w;\n        w *= 0.9;\n    }\n    \n    vec4 res = pow((c / tw), vec4(2.0));\n    \n    vec2 off = normalize(uv - vec2(0.5, 0.5)) * pow(length(uv- vec2(0.5, 0.5))/1.4, 4.0) * 0.2;\n    \n    res.r += texture(iChannel1, uv-off).r;\n    res.g += texture(iChannel1, uv).g;\n    res.b += texture(iChannel1, uv+off).b;\n    \n    fragColor = res;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 4074,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/wurstgetrank/je-moeder"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define FOV_BIAS 0.2\n#define NEAR 0.1\n#define FAR 200.0\n#define STEPS 500\n\nvoid pR(inout vec2 p, float a)\n{\n    float sa = sin(a), ca = cos(a);\n    p *= mat2(ca, sa, -sa, ca);\n}\n\nvec2 matmin(vec2 a, vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) \n{\n\treturn max(v.x, v.y);\n}\nfloat vmax(vec3 v) \n{\n\treturn max(v.x, max(v.y, v.z));\n}\n\nfloat fBox2(vec2 p, vec2 b) \n{\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\nfloat fBox(vec3 p, vec3 b) \n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fOpUnionChamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\n// Hexagonal prism, circumcircle variant\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.y - h.y, max(q.x*sqrt(3.0)*0.5 + q.z*0.5, q.z) - h.x);\n}\n\nvec2 Map2(vec3 inPos, float cz)\n{\n    float material = 3.0;\n    \n    float dist = -inPos.y + 0.75;\n    \n\tfloat wall = -inPos.x + 0.8;\n    dist = min(dist, wall);\n    vec3 pt = inPos;\n    pt.x -= sin(iTime * 4.0 + cz + cos(cz * 0.8)) * 0.5 + 1.5;\n    float gate = fBox(pt, vec3(1.0, 1.0, 0.5));\n    \n    inPos.z = abs(inPos.z) - 1.8;\n    float awning = fBox(inPos - vec3(0.73, 0.5, 0.0), vec3(0.1, 0.05, 0.76));\n    float frame = fBox(inPos - vec3(0.75, -0.15, 0.0), vec3(0.05, 0.6, 0.75));\n    float cutout = fBox2(inPos.yz - vec2(-0.15, 0.0), vec2(0.6, 0.7));\n    float door = fBox(inPos - vec3(0.75, -0.15, 0.0), vec3(0.02, 0.6, 0.7));\n    door = min(door, max(-cutout, min(frame, awning)));\n     \n    dist = min(dist, door);\n    \n    if (gate < dist)\n    {\n        dist = gate;\n        material = 5.0;\n    }\n\n    float flr = inPos.y + 0.775;\n    if(flr < dist)\n    {\n\t\tdist = flr;\n       \tmaterial = 1.0;\n    }\n   \t\n    return vec2(dist, material);\n}\n\nfloat MapL(vec3 inPos)\n{\n    float sz = 5.5;\n    inPos.x = abs(inPos.x);\n    inPos.z = (fract(inPos.z / sz + 0.5) - 0.5) * sz;\n    \n    vec3 pt = inPos;\n    float light = fBox(pt - vec3(0.7, 0.73, 0.0), vec3(0.18, 0.01, 2.4));\n    pR(pt.xy, 0.2);\n    light = min(light, fBox(pt - vec3(0.86, 0.0, 0.0), vec3(0.01, 0.18, 0.35)));\n    return light;\n}\n\nvec2 Map(vec3 inPos)\n{\n\tfloat light = MapL(inPos);\n    inPos.x = abs(inPos.x);\n    \n    float sz = 5.5;\n    float cellz = floor(inPos.z / sz + 0.5);\n    inPos.z = (fract(inPos.z / sz + 0.5) - 0.5) * sz;\n    \n    if(mod(cellz, 3.0) == 0.0)\n    {\n        return Map2(inPos, cellz);\n    }\n    \n    float material = 0.0;\n    float dist = -inPos.y + 0.75;\n    \n    float wall = -inPos.x + 1.0 - inPos.y * 0.2;\n    if(wall < dist)\n    {\n        material = 0.0;\n    \tdist = wall;\n    }\n    dist = fOpUnionChamfer(dist, wall, 0.3);\n    \n    vec3 pt = inPos;\n    pR(pt.xy, 0.2);\n    float frame = fBox(pt - vec3(0.83, 0.0, 0.0), vec3(0.05, 0.215, 0.58));\n    if(-frame > dist)\n    {\n        material = 3.0;\n    \tdist = -frame;\n    }\n    \n    float flr = inPos.y + 0.75;\n    flr = max(flr, -fBox2(inPos.xy + vec2(0.0, 0.75), vec2(0.45, 0.025)));\n    if(flr < dist)\n    {\n        material = 1.0;\n    \tdist = flr;\n    }\n    \n    float coolers = fBox(inPos - vec3(0.9 + inPos.y * 0.05, -0.6, 0.0), vec3(0.1, 0.4, 2.5));\n    if(coolers < dist)\n    {\n        material = 0.0;\n    \tdist = coolers;\n    }\n    \n    float pipe = fBox2(inPos.yz - vec2(-0.55, 0.0), vec2(0.4, 2.4));\n    pipe = fOpPipe(pipe, -inPos.x + 0.82, 0.005);\n    if(pipe < dist)\n    {\n        material = 2.0;\n    \tdist = pipe;\n    }\n    \n    if(light < dist)\n    {\n        material = 4.0;\n    \tdist = light;\n    }\n    \n    /*if(mod(cellz, 6.0) == 5.0)\n    {\n        pR(inPos.xz, 0.7);\n        pR(inPos.yz, -0.5);\n        float triangle = fBox(inPos, vec3(0.2));\n        if(triangle < dist)\n        {\n            material = 4.0;\n    \t\tif(mod(cellz, 12.0) == 5.0)\n                material += 1.0;\n        \tdist = triangle;\n        }\n    }*/\n    \n    return vec2(dist, material);\n}\n\n\nvec3 Normal(vec3 inPos, float inDistAtPos)\n{\n    // vec2 e = vec2(0.07, 0.0);\n    vec2 e = vec2(0.01, 0.0);\n    return normalize(vec3(Map(inPos + e.xyy).x,\n                          Map(inPos + e.yxy).x,\n                          Map(inPos + e.yyx).x) - inDistAtPos);\n}\n\n\nbool Trace(vec3 inOrigin, vec3 inDir, out vec3 outHitPos, out float outHitDist, out float outMatIndex)\n{\n    float totalDist = NEAR;\n\n    for (int i = 0 ; i < STEPS ; ++i)\n    {\n        vec3 samplePos = inOrigin + inDir * totalDist;\n        vec2 hit = Map(samplePos);\n        totalDist += hit.x;\n        \n        outHitPos = samplePos;\n        outHitDist = hit.x;    \n        outMatIndex = hit.y;\n        \n        if (hit.x <= 0.01)\n        \treturn true;\n\n        if (totalDist > FAR)\n            break;\n    }  \n\n    return false;\n}\n\n\nstruct Material\n{\n\tvec3 albedo;\n    float ambient;\n    float diffuse;\n    float specular;\n\tfloat reflectivity;\n};\n    \n\n\nMaterial CalcMaterial(float inMat, vec3 inHitPos, vec3 inNormal)\n{\n    Material result;\n    \n        vec3 fwd = vec3(0.0,0.0,1.0);\n        vec3 tangent = normalize(cross(fwd, inNormal));\n        vec2 uv = vec2( dot(fwd, inHitPos)*0.6, dot(tangent, inHitPos) ) * 0.5;\n    \n    // 0: Stone?\n    if (inMat <= 0.5)\n    {\n        vec3 col = texture(iChannel0, uv).xyz;\n        col = mix(col, vec3(1.0,1.0,1.0), 0.8);\n    \n\n        float yellowness = 1.0 - min(1.0, max(0.0, abs(inHitPos.y - 0.67) - 0.04)*50.0 );\n        col = mix(col, vec3(1.0, 0.7, 0.0), yellowness);\n\n        float line = min(1.0, max(0.01, mod(inHitPos.z, 2.0)-0.02)*50.0);\n        \n        float Vline = clamp(sin(clamp(inHitPos.x, -0.14, 0.14) * 3.14159265359 * (8.0 * 5.0 + 1.0) + 0.5 * 3.14159265359) * 100.0, 0.0, 1.0);\n        line = min(line, Vline);\n        \n        if (inHitPos.y < -0.25 && inHitPos.y >= -0.7)\n        {\n            float rep = 0.3;\n            float directional = clamp( 50.0*((mod(inHitPos.y*3.0+inHitPos.z, 2.0*rep) - rep)/rep), -0.5, 0.5);\n            directional *= 0.6;\n            directional += 0.8;\n            \n            line = min(line, directional);\n        }\n        \n        if (inHitPos.y < -0.19)\n            col *= 0.8;\n        \n        \n        col *= line;\n        \n        result.albedo = col;               \n        \n        result.ambient = 0.2 + yellowness * 0.2;\n        result.diffuse = 0.8;\n        result.specular = 0.9;\n        result.reflectivity = 0.0;\n    }\n\t// 1: Floor\n    else if (inMat <= 1.5)\n    {\n        uv = vec2( dot(fwd, inHitPos)*0.6, dot(tangent, inHitPos) ) * 0.2;\n        \n        uv.y += inHitPos.z*0.02;\n\n        vec3 col = texture(iChannel1, uv * 10.0).xyz;\n        uv += col.xy * 0.1;\n        col = texture(iChannel1, uv).xxx;\n        \n        if (inHitPos.y < -0.75)\n        \tcol.rgb *= 0.8;\n\t\t\n        result.albedo = col;\n        result.ambient = 0.2;\n        result.diffuse = 1.0;\n        result.specular = 0.1;\n        result.reflectivity = clamp( (texture(iChannel1, uv).x - 0.6)*20.0, -0.5, 0.5) + 0.5;\n    }\n\t// 2: Pipes\n    else if (inMat <= 2.5)\n    {\n        float yellowness = 0.5 + clamp(200.0 * sin(inHitPos.z * 5.0), -0.5, 0.5);\n        result.albedo = mix(vec3(1.0, 0.6, 0.0), vec3(1.0,1.0,1.0), yellowness);\n        result.ambient = 0.0;\n        result.diffuse = 0.9;\n        result.specular = 0.1;\n        result.reflectivity = 0.3;\n    }\n\t// 3: Gray\n    else if (inMat <= 3.5)\n    {\n        result.albedo = mix(texture(iChannel1, uv).xyz, vec3(0.8), 0.5);\n        result.ambient = 0.0;\n        result.diffuse = 0.8;\n        result.specular = 0.2;\n        result.reflectivity = 0.15;\n    }\n\t// 4: Lights\n    else if (inMat <= 4.5)\n    {\n        result.albedo = vec3(0.85, 0.95, 1.0);\n        result.ambient = 1.2;\n        result.diffuse = 0.0;\n        result.specular = 0.0;\n        result.reflectivity = 0.0;\n    }\n    // 5: Door\n    else \n    {\n        vec2 uv = vec2(-abs(inHitPos.x),abs(inHitPos.y));\n        \n    \tfloat sz = 5.5;\n    \tfloat cellz = floor(inHitPos.z / sz + 0.5);        \n        uv.x += sin(iTime * 4.0 + cellz + cos(cellz * 0.8)) * 0.5;\n        \n        float rep = 0.2;\n        float yellowness = clamp( 50.0*((mod(uv.x+uv.y, 2.0*rep) - rep)/rep), -0.5, 0.5);\n        yellowness += 0.5;\n        if (inHitPos.y > 0.65 || inHitPos.y < -0.7)\n            yellowness = 1.0;\n        \n        yellowness = 1.0 - yellowness;\n        yellowness *= clamp((texture(iChannel0, uv*4.0).r - 0.3) * 10.0, -0.5, 0.5)+0.5;\n        yellowness = 1.0 - yellowness;\n        \n        \n        result.albedo = mix(vec3(1.0, 0.6, 0.0), vec3(1.0,1.0,1.0), yellowness);\n        result.ambient = 0.2;\n        result.diffuse = 0.8;\n        result.specular = 0.2;\n        result.reflectivity = 0.05*yellowness;        \n    }\n    \n    return result;\n}\n\n\nfloat AO(vec3 inPos, vec3 inNormal)\n{\n    // ambient occlusion\n    float ao;\n    float totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<10; aoi++ )\n    {\n        float hr = 0.1 + 0.02*float(aoi*aoi);\n        vec3 aopos = inNormal * hr + inPos;\n        vec2 dd = Map( aopos );\n        ao = -(dd.x-hr);\n        totao += ao*sca;\n        sca *= 0.55;\n    }\n    ao = 1.0 - clamp( totao, 0.0, 1.0 );\n    return ao;\n}\n\n\nvec3 Shade(vec3 inHitPos, vec3 inEyePos, vec3 inNormal, Material inMat)\n{\n    vec3 eyeDir = normalize(inEyePos - inHitPos);\n    \n    vec2 lightDirR = normalize(vec2( 1.8, 1.5) - inHitPos.xy);\n    vec2 lightDirL = normalize(vec2(-1.8, 1.5) - inHitPos.xy);\n    float specular = pow( max(0.0, dot(reflect(vec3(lightDirL, 0.0), inNormal), eyeDir)), 2.0);\n    specular += pow(max(0.0, dot(reflect(vec3(lightDirR, 0.0), inNormal), eyeDir) ), 2.0);\n    \n    float diffuse = pow(1.0 - abs(inNormal.y), 3.0) * 0.5 + inNormal.y * 0.25 + 0.25;\n    \n    float lightDist = MapL(inHitPos);\n    vec2 e = vec2(0.01, 0.0);\n    vec3 lightNormal = -normalize(vec3(MapL(inHitPos + e.xyy),\n                                 MapL(inHitPos + e.yxy),\n                                 MapL(inHitPos + e.yyx)) - lightDist);\n    diffuse = mix(diffuse, max(0.0, dot(inNormal, lightNormal)) / (1.0 + pow(lightDist, 3.0)), 0.7);\n    \n    vec3 col = inMat.albedo * (inMat.ambient + diffuse * inMat.diffuse) + specular * inMat.specular;\n    \n    col += vec3(0.0, 0.05, 0.1) * (0.5 - inHitPos.y * 0.5);\n    col = pow(max(vec3(0.0), col) * vec3(1.15, 1.1, 1.0), vec3(1.3, 1.2, 1.15));\n    \n    float distance = length(inHitPos - inEyePos);\n    \n    float fog = clamp(distance / 70.0, 0.0, 1.0);\n    \n    return mix(col, vec3(0.9, 1.0, 1.0), fog) + (1.0 - pow(abs(eyeDir.y), 0.05)) * pow(fog, 0.5);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    uv *= 1.0 + pow(length(uv)*0.35, 2.0);\n \n    vec3 origin = vec3(0.25 * sin(iTime), 0.0, iTime * 4.0);\n    vec3 direction = normalize(vec3(0.0, 0.1*sin(iTime*0.2), 1.0));\n    \n    vec3 is, n;\n    pR(direction.xz, uv.x * FOV_BIAS);\n    pR(direction.yz, uv.y * FOV_BIAS);\n\n    vec3 hitPos;\n    float hitDist;\n    float hitMat;\n    if (Trace(origin, direction, hitPos, hitDist, hitMat))\n    {\n        vec3 normal = Normal(hitPos, hitDist);\n\t\n    \tMaterial mat = CalcMaterial(hitMat, hitPos, normal);        \n        vec3 c = Shade(hitPos, origin, normal, mat);\n        \n        if (mat.reflectivity > 0.0)\n        {\n        \tvec3 reflDir = reflect(direction, normal);\n            \n            vec3 reflhitPos;\n            float reflhitDist;\n            float reflhitMat;\n            if (Trace(hitPos + normal*0.001, reflDir, reflhitPos, reflhitDist, reflhitMat))\n            {\n                vec3 reflnormal = Normal(reflhitPos, reflhitDist);\n    \t\t\tMaterial reflMat = CalcMaterial(reflhitMat, reflhitPos, reflnormal);        \n        \t\tvec3 c2 = Shade(reflhitPos, origin, reflnormal, reflMat);\n                \n                c += mat.reflectivity * c2;\n            }\n        }\n\n        c*=AO(hitPos, normal);\n        \n        //c = vec3(1.0, 0.7, 0.4) * normal * 0.5 + 0.5;\n        //c = mix(c, vec3(0.1, 0.2, 0.4), min(1.0, t / FAR));\n    \n        fragColor = vec4(c, 1.0);       \n    }\n    else\n    {\n        fragColor = vec4(1,1,1,1);\n    }   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//hblur\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float w = 0.5;\n    float tw = 0.0;\n    vec4 c = vec4(0.0);\n    vec2 stp = vec2(2.0 / iResolution.x, 0.0);\n    for(int i = 0 ; i < 32; ++i)\n    {\n        c += texture(iChannel0, uv + float(i) * stp) * w;\n        c += texture(iChannel0, uv - float(i) * stp) * w;\n        tw += w + w;\n        w *= 0.95;\n    }\n    \n    fragColor = c / tw;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}