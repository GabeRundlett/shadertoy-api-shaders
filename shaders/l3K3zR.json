{
    "Shader": {
        "info": {
            "date": "1717262003",
            "description": "Making my version of a hash in the PCG family to generate random floats.\n\nThis is optimized to use 24-bit integer multiplies and multiply-adds which are significantly faster in some architectures, then uses those bits to fill the mantissa of a float32.",
            "flags": 0,
            "hasliked": 0,
            "id": "l3K3zR",
            "likes": 0,
            "name": "Pseudorandom Floats & osor_pcg",
            "published": 3,
            "tags": [
                "random",
                "float",
                "pseudorandom",
                "pcg",
                "osor"
            ],
            "usePreview": 0,
            "username": "osor_io",
            "viewed": 37
        },
        "renderpass": [
            {
                "code": "//\n// See the common tab for the implementation of the hash\n// and the (pseudo) random number generation.\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uvec3 seed = uint3(uvec2(fragCoord), 0u); \n    if (uv.x > 0.5)\n    {\n        seed.z = uint(iFrame);\n    }\n    \n    vec3 col = vec3(0.0);\n    //col = vec3(osor_random_float_01(seed));\n    //col.rg = osor_random_float2_01(seed);\n    col.rgb = osor_random_float3_01(seed);\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//\n// This software is available under 2 licenses -- choose whichever you prefer.\n// ------------------------------------------------------------------------------\n// ALTERNATIVE A - MIT License\n// Copyright (c) 2024 Rubén Osorio López\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n// of the Software, and to permit persons to whom the Software is furnished to do\n// so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n// ------------------------------------------------------------------------------\n// ALTERNATIVE B - Public Domain (www.unlicense.org)\n// This is free and unencumbered software released into the public domain.\n// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this\n// software, either in source code form or as a compiled binary, for any purpose,\n// commercial or non-commercial, and by any means.\n// In jurisdictions that recognize copyright laws, the author or authors of this\n// software dedicate any and all copyright interest in the software to the public\n// domain. We make this dedication for the benefit of the public at large and to\n// the detriment of our heirs and successors. We intend this dedication to be an\n// overt act of relinquishment in perpetuity of all present and future rights to\n// this software under copyright law.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\n\n\n//\n// Forgive me GLSL for I have sinned :)\n//\n// Copy-Pasting here from my HLSL shaders, for that\n// and to avoid issues if copying back to HLSL (which I\n// seem to do more often than not) I'm keeping the source\n// with HLSL types. If you want to nuke this a find & replace\n// should sort you out.\n//\n#define uint2 uvec2\n#define uint3 uvec3\n#define uint4 uvec4\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define mad(a,b,c) ((a)*(b)+(c))\n\nuint  mad24(uint  a, uint b, uint c) { return mad(a & 0x00FFFFFFu, b & 0x00FFFFFFu, c); }\nuint2 mad24(uint2 a, uint b, uint c) { return mad(a & 0x00FFFFFFu, b & 0x00FFFFFFu, c); }\nuint3 mad24(uint3 a, uint b, uint c) { return mad(a & 0x00FFFFFFu, b & 0x00FFFFFFu, c); }\nuint4 mad24(uint4 a, uint b, uint c) { return mad(a & 0x00FFFFFFu, b & 0x00FFFFFFu, c); }\n\nfloat  asfloat(uint  x) { return uintBitsToFloat(x); }\nfloat2 asfloat(uint2 x) { return uintBitsToFloat(x); }\nfloat3 asfloat(uint3 x) { return uintBitsToFloat(x); }\nfloat4 asfloat(uint4 x) { return uintBitsToFloat(x); }\nuint  asuint(float  x) { return floatBitsToUint(x); }\nuint2 asuint(float2 x) { return floatBitsToUint(x); }\nuint3 asuint(float3 x) { return floatBitsToUint(x); }\nuint4 asuint(float4 x) { return floatBitsToUint(x); }\n\n\n\n//\n// # Osor PCG Hash (24-bit and 32-bit)\n//\n// Starting with the 24-bit implementation. This is being designed\n// to be a good performance/quality hash to generate floating point\n// numbers in the [0,1) range.\n// \n// For this purpose, we only care about getting 24 good quality bits\n// out of it, since the mantissa of a float is 23 bits (and can use\n// that extra one as the sign bit).\n//\n// Given that we're optimizing for a good set of 24 bits we can\n// take advantage of GPU support for 24-bit integer multiplies and\n// multiply-adds. Most interestingly, in GCN and RDNA this changes\n// the instructions from being quarter-rate to full-rate. So instead\n// of a quarter-rate multiply followed by an add (5-cycles) we can\n// do a single full-rate multiply-add via V_MAD_U32_U24. The reason\n// this is fast is likely due to reusing the floating point ALU for\n// the 24-bit multiply, which is hardware used for float32 multiplies.\n//\n// When finding good numbers for the LCG, the multiplier is the most important\n// factor, also briefly mentioned in the GDC talk below. In the paper\n// \"Computationally easy, spectrally good multipliers for congruential\n// pseudorandom number generators\" they find, well, spectrally good \n// multipliers for LCGs, the ones used here are:\n//\n//  * 0xc083c5   (or 12616645)   : For 24-bit inputs and a 32-bit output\n//  * 0x915f77f5 (or 2438952949) : For 32-bit inputs and a 32-bit output\n//\n//\n// For the increment, we can still use 32-bit numbers, since mad24()\n// still does 32-bit addition after the multiplication. For these\n// I'm using the classic bitwise interesting primes that Knuth\n// mentions in \"Numerical Recipes\":\n//\n//  * 1013904223\n//  * 1289706101\n//  * 1640531513\n//\n// The above describes the LCG part of a PCG-style hash, for the\n// permutations we're doing Feistel ciphers similar to what\n// \"Hash Functions for GPU Rendering\" paper does, which itself links\n// to the idea of the generalized Feistel cyphers from Hoang and \n// Rogaway 2010.\n//\n// It should be noted that even if the multiplies essentially discard\n// the top 8 bits, due to the increment term of mad24(...) being 32-bits\n// there is still data in those top 8 bits as we perform the hash, which\n// gets xor-ed into the 24-bit element.\n//\n// See:\n//\n//  - https://en.wikipedia.org/wiki/Linear_congruential_generator\n//  - https://www.researchgate.net/publication/354960552_Computationally_easy_spectrally_good_multipliers_for_congruential_pseudorandom_number_generators\n//  - https://github.com/vigna/CPRNG\n//  - https://www.youtube.com/watch?v=LWFzPP8ZbdU\n//  - https://jcgt.org/published/0009/03/02/\n//  - https://www.youtube.com/watch?v=FGhj3CGxl8I\n//\n//                            - Ruben Osorio, 30/05/2024\n//\n// Tested the 1D version with PractRand and for the top 16 bits of the \n// resulting 24-bit integer it gets better results than the widely used\n// 1D PCGRand. It performs similarly for the bottom 16 bits.\n//\n// This perfectly fits the use case of generating [0,1) floats, since\n// the top bits of the mantissa is where we want the highest quality\n// bits, as they are the most significant.\n//\n// I make no claims about the quality of this hash for more serious\n// cryptographic use-cases. This was though out for the purposes that this\n// file shows.\n//\n// See:\n// \n//  - https://www.pcg-random.org/posts/how-to-test-with-practrand.html\n//  - https://pracrand.sourceforge.net/\n//\n//                            - Ruben Osorio, 31/05/2024\n//\nuint osor_pcg24(uint v)\n{\n    v = mad24(v, 12616645u, 1013904223u);\n    v = v ^ (v >> 12u);\n    v = mad24(v, 12616645u, 1289706101u);\n    v = v ^ (v >> 12u);\n    v = mad24(v, 12616645u, 1640531513u);\n    v = v ^ (v >> 12u);\n    return v;\n}\nuint2 osor_pcg24(uint2 v)\n{\n    v = mad24(v, 12616645u, 1013904223u);\n    v.x = mad24(v.y, 12616645u, v.x);\n    v.y = mad24(v.x, 12616645u, v.y);\n    v = v ^ (v >> 12u);\n    v.x = mad24(v.y, 12616645u, v.x);\n    v.y = mad24(v.x, 12616645u, v.y);\n    v = v ^ (v >> 12u);\n    return v;\n}\nuint3 osor_pcg24(uint3 v)\n{\n    v = mad24(v, 12616645u, 1013904223u);\n    v.x = mad24(v.y, v.z, v.x);\n    v.y = mad24(v.x, v.z, v.y);\n    v.z = mad24(v.x, v.y, v.z);\n    v = v ^ (v >> 12u);\n    v.x = mad24(v.y, v.z, v.x);\n    v.y = mad24(v.x, v.z, v.y);\n    v.z = mad24(v.x, v.y, v.z);\n    return v;\n}\nuint4 osor_pcg24(uint4 v)\n{\n    v = mad24(v, 12616645u, 1013904223u);\n    v.x = mad24(v.y, v.w, v.x);\n    v.y = mad24(v.x, v.z, v.y);\n    v.z = mad24(v.x, v.y, v.z);\n    v.w = mad24(v.y, v.z, v.w);\n    v = v ^ (v >> 12u);\n    v.x = mad24(v.y, v.w, v.x);\n    v.y = mad24(v.x, v.z, v.y);\n    v.z = mad24(v.x, v.y, v.z);\n    v.w = mad24(v.y, v.z, v.w);\n    return v;\n}\n\n//\n// As for the 32-bit version of the hash, we pick a multiplier\n// for the LCG that suits 32-bit inputs and change the \n// shift-xor rounds to fold the top 16-bits instead. Same idea\n// but optimized to generate 32 quality bits and using full\n// 32-bit multiplies.\n//\nuint osor_pcg32(uint v)\n{\n    v = mad(v, 2438952949u, 1013904223u);\n    v = v ^ (v >> 16u);\n    v = mad(v, 2438952949u, 1289706101u);\n    v = v ^ (v >> 16u);\n    v = mad(v, 2438952949u, 1640531513u);\n    v = v ^ (v >> 16u);\n    return v;\n}\nuint2 osor_pcg32(uint2 v)\n{\n    v = mad(v, 2438952949u, 1013904223u);\n    v.x = mad(v.y, 2438952949u, v.x);\n    v.y = mad(v.x, 2438952949u, v.y);\n    v = v ^ (v >> 16u);\n    v.x = mad(v.y, 2438952949u, v.x);\n    v.y = mad(v.x, 2438952949u, v.y);\n    v = v ^ (v >> 16u);\n    return v;\n}\nuint3 osor_pcg32(uint3 v)\n{\n    v = mad(v, 2438952949u, 1013904223u);\n    v.x = mad(v.y, v.z, v.x);\n    v.y = mad(v.x, v.z, v.y);\n    v.z = mad(v.x, v.y, v.z);\n    v = v ^ (v >> 16u);\n    v.x = mad(v.y, v.z, v.x);\n    v.y = mad(v.x, v.z, v.y);\n    v.z = mad(v.x, v.y, v.z);\n    return v;\n}\nuint4 osor_pcg32(uint4 v)\n{\n    v = mad(v, 2438952949u, 1013904223u);\n    v.x = mad(v.y, v.w, v.x);\n    v.y = mad(v.x, v.z, v.y);\n    v.z = mad(v.x, v.y, v.z);\n    v.w = mad(v.y, v.z, v.w);\n    v = v ^ (v >> 16u);\n    v.x = mad(v.y, v.w, v.x);\n    v.y = mad(v.x, v.z, v.y);\n    v.z = mad(v.x, v.y, v.z);\n    v.w = mad(v.y, v.z, v.w);\n    return v;\n}\n\n//\n// For when you want to call the hashing function with a single\n// input but require to get multiple outputs out of it. So to go\n// from uint -> uint4, you would call hash(expand_seedXX_4(uint))\n//\nuint2 osor_expand_seed24_2(uint seed)\n{\n    uint x = seed;\n    uint y = mad24(x, 12616645u, 1013904223u);\n    return uint2(x,y);\n}\nuint3 osor_expand_seed24_3(uint seed)\n{\n    uint x = seed;\n    uint y = mad24(x, 12616645u, 1013904223u);\n    uint z = mad24(y, 12616645u, 1289706101u);\n    return uint3(x,y,z);\n}\nuint3 osor_expand_seed24_3(uint2 seed)\n{\n    uint x = seed.x;\n    uint y = seed.y;\n    uint z = mad24(x, 12616645u, 1289706101u);\n    return uint3(x,y,z);\n}\nuint4 osor_expand_seed24_4(uint seed)\n{\n    uint x = seed;\n    uint y = mad24(x, 12616645u, 1013904223u);\n    uint z = mad24(y, 12616645u, 1289706101u);\n    uint w = mad24(z, 12616645u, 1640531513u);\n    return uint4(x,y,z,w);\n}\nuint4 osor_expand_seed24_4(uint2 seed)\n{\n    uint x = seed.x;\n    uint y = seed.y;\n    uint z = mad24(x, 12616645u, 1289706101u);\n    uint w = mad24(y, 12616645u, 1640531513u);\n    return uint4(x,y,z,w);\n}\nuint4 osor_expand_seed24_4(uint3 seed)\n{\n    uint x = seed.x;\n    uint y = seed.y;\n    uint z = seed.z;\n    uint w = mad24(x, 12616645u, 1640531513u);\n    return uint4(x,y,z,w);\n}\n\nuint2 osor_expand_seed32_2(uint seed)\n{\n    uint x = seed;\n    uint y = mad(x, 12616645u, 1013904223u);\n    return uint2(x,y);\n}\nuint3 osor_expand_seed32_3(uint seed)\n{\n    uint x = seed;\n    uint y = mad(x, 12616645u, 1013904223u);\n    uint z = mad(y, 12616645u, 1289706101u);\n    return uint3(x,y,z);\n}\nuint3 osor_expand_seed32_3(uint2 seed)\n{\n    uint x = seed.x;\n    uint y = seed.y;\n    uint z = mad(x, 12616645u, 1289706101u);\n    return uint3(x,y,z);\n}\nuint4 osor_expand_seed32_4(uint seed)\n{\n    uint x = seed;\n    uint y = mad(x, 12616645u, 1013904223u);\n    uint z = mad(y, 12616645u, 1289706101u);\n    uint w = mad(z, 12616645u, 1640531513u);\n    return uint4(x,y,z,w);\n}\nuint4 osor_expand_seed32_4(uint2 seed)\n{\n    uint x = seed.x;\n    uint y = seed.y;\n    uint z = mad(x, 12616645u, 1289706101u);\n    uint w = mad(y, 12616645u, 1640531513u);\n    return uint4(x,y,z,w);\n}\nuint4 osor_expand_seed32_4(uint3 seed)\n{\n    uint x = seed.x;\n    uint y = seed.y;\n    uint z = seed.z;\n    uint w = mad(x, 12616645u, 1640531513u);\n    return uint4(x,y,z,w);\n}\n\n\n\n//\n// Conversion from Random u24 to float32\n//\n// Here you can use a path that sets the 23 mantissa bits in a [1,2)\n// float 32, then subtracts 1 to go to [0,1). This does give good results\n// but \"only\" uses 23 bits for randomness.\n//\n// Alternatively, because we're working with 24 bits of good input, we can cast\n// that to a float32, which in IEEE 754 can represent as exact integers exactly up\n// to 2^24, so there's no loss in precission. Then we multiply by 2^(-24) to go\n// to a [0,1) range.\n//\n// The \"set-mantissa\" implementation does a AND,OR,SUB whereas \n// the \"multiply\" implementation does AND,CVT,MUL. Depending on the costs\n// of these on the target platform, or the extra bit of precission, you might\n// prefer one or the other.\n//\n// The CVT instruction is sometimes not cheap, and some targets (e.g AMDGPU) can do\n// a combined AND_OR instruction in a single cycle, which makes the \"set-mantissa\"\n// path potentially faster, albeit at the cost of that one extra bit of precission.\n//\n#if 0 // \"set-mantissa\" implementation\nfloat  osor_float_01_from_uint24(uint  x) { return asfloat((x & 0x007FFFFFu) | 0x3F800000u) - 1.0; }\nfloat2 osor_float_01_from_uint24(uint2 x) { return asfloat((x & 0x007FFFFFu) | 0x3F800000u) - 1.0; }\nfloat3 osor_float_01_from_uint24(uint3 x) { return asfloat((x & 0x007FFFFFu) | 0x3F800000u) - 1.0; }\nfloat4 osor_float_01_from_uint24(uint4 x) { return asfloat((x & 0x007FFFFFu) | 0x3F800000u) - 1.0; }\n#else // \"multiply\" implementation\nfloat  osor_float_01_from_uint24(uint  x) { return float (x & 0x00FFFFFFu) * asfloat(0x33800000u); }\nfloat2 osor_float_01_from_uint24(uint2 x) { return float2(x & 0x00FFFFFFu) * asfloat(0x33800000u); }\nfloat3 osor_float_01_from_uint24(uint3 x) { return float3(x & 0x00FFFFFFu) * asfloat(0x33800000u); }\nfloat4 osor_float_01_from_uint24(uint4 x) { return float4(x & 0x00FFFFFFu) * asfloat(0x33800000u); }\n#endif\n\n\n\n//\n// N -> M Pseudorandom [0,1) float32 Generation\n//\n// Wrappers around the seed expansion, hash and float conversion, call these with\n// the inputs you have and for the desired output to get as many floats as you need.\n//\nfloat  osor_random_float_01  (uint  seed) { return osor_float_01_from_uint24(osor_pcg24(seed));                       }\nfloat  osor_random_float_01  (uint2 seed) { return osor_float_01_from_uint24(osor_pcg24(seed).x);                     }\nfloat  osor_random_float_01  (uint3 seed) { return osor_float_01_from_uint24(osor_pcg24(seed).x);                     }\nfloat  osor_random_float_01  (uint4 seed) { return osor_float_01_from_uint24(osor_pcg24(seed).x);                     }\nfloat2 osor_random_float2_01 (uint  seed) { return osor_float_01_from_uint24(osor_pcg24(osor_expand_seed24_2(seed))); }\nfloat2 osor_random_float2_01 (uint2 seed) { return osor_float_01_from_uint24(osor_pcg24(seed).xy);                    }\nfloat2 osor_random_float2_01 (uint3 seed) { return osor_float_01_from_uint24(osor_pcg24(seed).xy);                    }\nfloat2 osor_random_float2_01 (uint4 seed) { return osor_float_01_from_uint24(osor_pcg24(seed).xy);                    }\nfloat3 osor_random_float3_01 (uint  seed) { return osor_float_01_from_uint24(osor_pcg24(osor_expand_seed24_3(seed))); }\nfloat3 osor_random_float3_01 (uint2 seed) { return osor_float_01_from_uint24(osor_pcg24(osor_expand_seed24_3(seed))); }\nfloat3 osor_random_float3_01 (uint3 seed) { return osor_float_01_from_uint24(osor_pcg24(seed).xyz);                   }\nfloat3 osor_random_float3_01 (uint4 seed) { return osor_float_01_from_uint24(osor_pcg24(seed).xyz);                   }\nfloat4 osor_random_float4_01 (uint  seed) { return osor_float_01_from_uint24(osor_pcg24(osor_expand_seed24_4(seed))); }\nfloat4 osor_random_float4_01 (uint2 seed) { return osor_float_01_from_uint24(osor_pcg24(osor_expand_seed24_4(seed))); }\nfloat4 osor_random_float4_01 (uint3 seed) { return osor_float_01_from_uint24(osor_pcg24(osor_expand_seed24_4(seed))); }\nfloat4 osor_random_float4_01 (uint4 seed) { return osor_float_01_from_uint24(osor_pcg24(seed));                       }\n\nfloat  osor_random_float_01_changing_seed  (inout uint  seed) { uint  newSeed = osor_pcg24(seed);                         seed = newSeed;      return osor_float_01_from_uint24(newSeed);    }\nfloat  osor_random_float_01_changing_seed  (inout uint2 seed) { uint2 newSeed = osor_pcg24(seed);                         seed = newSeed.xy;   return osor_float_01_from_uint24(newSeed.x);    }\nfloat  osor_random_float_01_changing_seed  (inout uint3 seed) { uint3 newSeed = osor_pcg24(seed);                         seed = newSeed.xyz;  return osor_float_01_from_uint24(newSeed.x);    }\nfloat  osor_random_float_01_changing_seed  (inout uint4 seed) { uint4 newSeed = osor_pcg24(seed);                         seed = newSeed.xyzw; return osor_float_01_from_uint24(newSeed.x);    }\nfloat2 osor_random_float2_01_changing_seed (inout uint  seed) { uint2 newSeed = osor_pcg24(osor_expand_seed24_2(seed));   seed = newSeed.x;    return osor_float_01_from_uint24(newSeed.xy);   }\nfloat2 osor_random_float2_01_changing_seed (inout uint2 seed) { uint2 newSeed = osor_pcg24(seed);                         seed = newSeed.xy;   return osor_float_01_from_uint24(newSeed.xy);   }\nfloat2 osor_random_float2_01_changing_seed (inout uint3 seed) { uint3 newSeed = osor_pcg24(seed);                         seed = newSeed.xyz;  return osor_float_01_from_uint24(newSeed.xy);   }\nfloat2 osor_random_float2_01_changing_seed (inout uint4 seed) { uint4 newSeed = osor_pcg24(seed);                         seed = newSeed.xyzw; return osor_float_01_from_uint24(newSeed.xy);   }\nfloat3 osor_random_float3_01_changing_seed (inout uint  seed) { uint3 newSeed = osor_pcg24(osor_expand_seed24_3(seed));   seed = newSeed.x;    return osor_float_01_from_uint24(newSeed.xyz);  }\nfloat3 osor_random_float3_01_changing_seed (inout uint2 seed) { uint3 newSeed = osor_pcg24(osor_expand_seed24_3(seed));   seed = newSeed.xy;   return osor_float_01_from_uint24(newSeed.xyz);  }\nfloat3 osor_random_float3_01_changing_seed (inout uint3 seed) { uint3 newSeed = osor_pcg24(seed);                         seed = newSeed.xyz;  return osor_float_01_from_uint24(newSeed.xyz);  }\nfloat3 osor_random_float3_01_changing_seed (inout uint4 seed) { uint4 newSeed = osor_pcg24(seed);                         seed = newSeed.xyzw; return osor_float_01_from_uint24(newSeed.xyz);  }\nfloat4 osor_random_float4_01_changing_seed (inout uint  seed) { uint4 newSeed = osor_pcg24(osor_expand_seed24_4(seed));   seed = newSeed.x;    return osor_float_01_from_uint24(newSeed.xyzw); }\nfloat4 osor_random_float4_01_changing_seed (inout uint2 seed) { uint4 newSeed = osor_pcg24(osor_expand_seed24_4(seed));   seed = newSeed.xy;   return osor_float_01_from_uint24(newSeed.xyzw); }\nfloat4 osor_random_float4_01_changing_seed (inout uint3 seed) { uint4 newSeed = osor_pcg24(osor_expand_seed24_4(seed));   seed = newSeed.xyz;  return osor_float_01_from_uint24(newSeed.xyzw); }\nfloat4 osor_random_float4_01_changing_seed (inout uint4 seed) { uint4 newSeed = osor_pcg24(seed);                         seed = newSeed.xyzw; return osor_float_01_from_uint24(newSeed.xyzw); }\n\n\n\n//\n// N -> M Pseudorandom [0,2^32) uint32 Generation\n//\n// Wrappers around the seed expansion and hash, similar to above, but\n// using the full 32-bit hash\n//\nuint  osor_random_uint_01  (uint  seed) { return osor_pcg32(seed);                       }\nuint  osor_random_uint_01  (uint2 seed) { return osor_pcg32(seed).x;                     }\nuint  osor_random_uint_01  (uint3 seed) { return osor_pcg32(seed).x;                     }\nuint  osor_random_uint_01  (uint4 seed) { return osor_pcg32(seed).x;                     }\nuint2 osor_random_uint2_01 (uint  seed) { return osor_pcg32(osor_expand_seed32_2(seed)); }\nuint2 osor_random_uint2_01 (uint2 seed) { return osor_pcg32(seed).xy;                    }\nuint2 osor_random_uint2_01 (uint3 seed) { return osor_pcg32(seed).xy;                    }\nuint2 osor_random_uint2_01 (uint4 seed) { return osor_pcg32(seed).xy;                    }\nuint3 osor_random_uint3_01 (uint  seed) { return osor_pcg32(osor_expand_seed32_3(seed)); }\nuint3 osor_random_uint3_01 (uint2 seed) { return osor_pcg32(osor_expand_seed32_3(seed)); }\nuint3 osor_random_uint3_01 (uint3 seed) { return osor_pcg32(seed).xyz;                   }\nuint3 osor_random_uint3_01 (uint4 seed) { return osor_pcg32(seed).xyz;                   }\nuint4 osor_random_uint4_01 (uint  seed) { return osor_pcg32(osor_expand_seed32_4(seed)); }\nuint4 osor_random_uint4_01 (uint2 seed) { return osor_pcg32(osor_expand_seed32_4(seed)); }\nuint4 osor_random_uint4_01 (uint3 seed) { return osor_pcg32(osor_expand_seed32_4(seed)); }\nuint4 osor_random_uint4_01 (uint4 seed) { return osor_pcg32(seed);                       }\n\nuint  osor_random_uint_01_changing_seed  (inout uint  seed) { uint  newSeed = osor_pcg32(seed);                         seed = newSeed;      return newSeed;      }\nuint  osor_random_uint_01_changing_seed  (inout uint2 seed) { uint2 newSeed = osor_pcg32(seed);                         seed = newSeed.xy;   return newSeed.x;    }\nuint  osor_random_uint_01_changing_seed  (inout uint3 seed) { uint3 newSeed = osor_pcg32(seed);                         seed = newSeed.xyz;  return newSeed.x;    }\nuint  osor_random_uint_01_changing_seed  (inout uint4 seed) { uint4 newSeed = osor_pcg32(seed);                         seed = newSeed.xyzw; return newSeed.x;    }\nuint2 osor_random_uint2_01_changing_seed (inout uint  seed) { uint2 newSeed = osor_pcg32(osor_expand_seed32_2(seed));   seed = newSeed.x;    return newSeed.xy;   }\nuint2 osor_random_uint2_01_changing_seed (inout uint2 seed) { uint2 newSeed = osor_pcg32(seed);                         seed = newSeed.xy;   return newSeed.xy;   }\nuint2 osor_random_uint2_01_changing_seed (inout uint3 seed) { uint3 newSeed = osor_pcg32(seed);                         seed = newSeed.xyz;  return newSeed.xy;   }\nuint2 osor_random_uint2_01_changing_seed (inout uint4 seed) { uint4 newSeed = osor_pcg32(seed);                         seed = newSeed.xyzw; return newSeed.xy;   }\nuint3 osor_random_uint3_01_changing_seed (inout uint  seed) { uint3 newSeed = osor_pcg32(osor_expand_seed32_3(seed));   seed = newSeed.x;    return newSeed.xyz;  }\nuint3 osor_random_uint3_01_changing_seed (inout uint2 seed) { uint3 newSeed = osor_pcg32(osor_expand_seed32_3(seed));   seed = newSeed.xy;   return newSeed.xyz;  }\nuint3 osor_random_uint3_01_changing_seed (inout uint3 seed) { uint3 newSeed = osor_pcg32(seed);                         seed = newSeed.xyz;  return newSeed.xyz;  }\nuint3 osor_random_uint3_01_changing_seed (inout uint4 seed) { uint4 newSeed = osor_pcg32(seed);                         seed = newSeed.xyzw; return newSeed.xyz;  }\nuint4 osor_random_uint4_01_changing_seed (inout uint  seed) { uint4 newSeed = osor_pcg32(osor_expand_seed32_4(seed));   seed = newSeed.x;    return newSeed.xyzw; }\nuint4 osor_random_uint4_01_changing_seed (inout uint2 seed) { uint4 newSeed = osor_pcg32(osor_expand_seed32_4(seed));   seed = newSeed.xy;   return newSeed.xyzw; }\nuint4 osor_random_uint4_01_changing_seed (inout uint3 seed) { uint4 newSeed = osor_pcg32(osor_expand_seed32_4(seed));   seed = newSeed.xyz;  return newSeed.xyzw; }\nuint4 osor_random_uint4_01_changing_seed (inout uint4 seed) { uint4 newSeed = osor_pcg32(seed);                         seed = newSeed.xyzw; return newSeed.xyzw; }",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}