{
    "Shader": {
        "info": {
            "date": "1607980426",
            "description": "I was playing with fractal noise but found something more interesting.",
            "flags": 48,
            "hasliked": 0,
            "id": "3dVBWK",
            "likes": 7,
            "name": "Underground Flythrough",
            "published": 3,
            "tags": [
                "flythrough",
                "underground",
                "mesheffect"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 315
        },
        "renderpass": [
            {
                "code": "/*\nUse the mouse to rotate the camera and the arrow keys to move it.\n\nCommon: contains all of the settings and helper functions for texture lookups\nBuffer A: contains the code for updating the camera position and yaw/pitch rotations\nImage: contains the raymarching code\n*/\n\n// Set to true for a slight framerate boost:\nconst bool OPTIMIZE_RAYMARCHING = false;\n\nfloat Shape(in vec3 p) {\n\treturn sin(p.x) - sin(p.y) + sin(p.z);\n}\n\nfloat MeshShape(in vec3 p) {\n    vec3 cell = floor(p);\n    vec3 local = fract(p);\n\n    float ldb = Shape(cell);                       // Left, Down, Back\n    float rdb = Shape(cell + vec3(1.0, 0.0, 0.0)); // Right, Down, Back\n    float ldf = Shape(cell + vec3(0.0, 0.0, 1.0)); // Left, Down, Front\n    float rdf = Shape(cell + vec3(1.0, 0.0, 1.0)); // Right, Down, Front\n    float lub = Shape(cell + vec3(0.0, 1.0, 0.0)); // Left, Up, Back\n    float rub = Shape(cell + vec3(1.0, 1.0, 0.0)); // Right, Up, Back\n    float luf = Shape(cell + vec3(0.0, 1.0, 1.0)); // Left, Up, Front\n    float ruf = Shape(cell + vec3(1.0, 1.0, 1.0)); // Right, Up, Front\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(ldf, rdf, local.x),\n                   local.z),\n\n               mix(mix(lub, rub, local.x),\n                   mix(luf, ruf, local.x),\n                   local.z),\n\n               local.y);\n}\n\nfloat FractalMeshShape(in vec3 p, in float scale, in float octaves) {\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += MeshShape(p * pow(2.0, octave) * scale) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n    }\n\n    return value / tscale;\n}\n\nfloat mapScene(in vec3 p) {\n    return (FractalMeshShape(p, 2.0, 4.0) - 0.3) * 0.3;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + GRADIENT_STEP.xyy) - mapScene(p - GRADIENT_STEP.xyy),\n                          mapScene(p + GRADIENT_STEP.yxy) - mapScene(p - GRADIENT_STEP.yxy),\n                          mapScene(p + GRADIENT_STEP.yyx) - mapScene(p - GRADIENT_STEP.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 rayOrigin = getViewPosition();\n    mat3 camera = getCamera(getViewDirection());\n    vec3 rayDirection = normalize(FOCAL_LENGTH * camera[2] + uv.x * camera[0] + uv.y * camera[1]);\n\n    fragColor = vec4(0.25, 0.25, 1.0, 1.0);\n    float distanceTraveled = 0.0;\n    for (int iteration=0; iteration < MAX_ITERATIONS; iteration++) {\n        vec3 position = rayOrigin + rayDirection * distanceTraveled;\n        float sceneDistance = mapScene(position);\n        float multiplier = OPTIMIZE_RAYMARCHING ? 1.0 + distanceTraveled : 1.0;\n        if (sceneDistance < MIN_HIT_DISTANCE * multiplier) {\n            vec3 normal = getNormal(position);\n            vec3 light = vec3(-0.58, 0.58, 0.58);\n            float h = 0.5 + 0.5 * normal.y;\n            vec3 color = mix(vec3(0.6, 0.3, 0.0), vec3(0.0, 1.0, 0.0), h * h * h);\n            fragColor.rgb = color * max(0.0, dot(normal, light));\n            fragColor.rgb += 0.3 * color;\n            break;\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        distanceTraveled += sceneDistance;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Raymarching constants:\nconst vec3 GRADIENT_STEP = vec3(0.001, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 10.0;\nconst float MIN_HIT_DISTANCE = 0.001;\nconst int MAX_ITERATIONS = 200;\nconst float FOCAL_LENGTH = 1.0;\n\n// Math constants:\nconst float TWO_PI = 6.2832;\n\n// Camera constants:\nconst float STEP_SIZE = 0.1;\nconst float ROTATION_SPEED = 0.5;\n\n// Addresses to viewing data:\nconst ivec2  VIEW_POSITION_ADDR = ivec2(0, 0);\nconst ivec2 VIEW_DIRECTION_ADDR = ivec2(1, 0);\n\n// Key codes from iq's keyboard input demo (https://www.shadertoy.com/view/lsXGzf):\nconst int    KEY_UP = 38;\nconst int  KEY_DOWN = 40;\nconst int KEY_RIGHT = 39;\nconst int  KEY_LEFT = 37;\n\n// A bunch of crazy macros because they are the only way to define texelFetches in Common :(\n#define  getViewPosition() texelFetch(iChannel0, VIEW_POSITION_ADDR, 0).xyz\n#define getViewDirection() texelFetch(iChannel0, VIEW_DIRECTION_ADDR, 0).xy\n\n#define     keyUpPressed() bool(texelFetch(iChannel1, ivec2(38, 0), 0).x)\n#define   keyDownPressed() bool(texelFetch(iChannel1, ivec2(40, 0), 0).x)\n#define  keyRightPressed() bool(texelFetch(iChannel1, ivec2(39, 0), 0).x)\n#define   keyLeftPressed() bool(texelFetch(iChannel1, ivec2(37, 0), 0).x)\n\n// Calculates camera axes:\nmat3 getCamera(in vec2 viewDirection) {\n    vec2 c = cos(viewDirection); vec2 s = sin(viewDirection);\n    return mat3(vec3(       c.x, 0.0,         s.x),  // Camera right axis (x)\n                vec3(s.x * -s.y, c.y, -c.x * -s.y),  // Camera up axis (y)\n                vec3(s.x *  c.y, s.y, -c.x *  c.y)); // Camera forward axis (z)\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*\nThe camera rotation is stored as yaw/pitch rotations. Yaw is spin and pitch is tilt.\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n\n    if (iFrame > 0) {\n        ivec2 address = ivec2(fragCoord);\n        if (address == VIEW_POSITION_ADDR) {\n            fragColor = vec4(getViewPosition(), 1.0);\n            mat3 camera = getCamera(getViewDirection());\n \n            if (keyUpPressed()) {\n                fragColor.xyz += camera[2] * STEP_SIZE;\n            }\n\n            if (keyDownPressed()) {\n                fragColor.xyz -= camera[2] * STEP_SIZE;\n            }\n\n            if (keyRightPressed()) {\n                fragColor.xyz += camera[0] * STEP_SIZE;\n            }\n\n            if (keyLeftPressed()) {\n                fragColor.xyz -= camera[0] * STEP_SIZE;\n            }\n        }\n\n        if (address == VIEW_DIRECTION_ADDR) {\n            vec2 viewDirection = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * TWO_PI * ROTATION_SPEED;\n            fragColor = vec4(viewDirection, 0.0, 1.0);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}