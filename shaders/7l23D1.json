{
    "Shader": {
        "info": {
            "date": "1624003824",
            "description": "Complex natural log fractal found on https://www.youtube.com/watch?v=VqmsaW9SXbA.",
            "flags": 48,
            "hasliked": 0,
            "id": "7l23D1",
            "likes": 21,
            "name": "natural log fractal",
            "published": 3,
            "tags": [
                "fractal",
                "interactive",
                "zoomable"
            ],
            "usePreview": 0,
            "username": "peabrainiac",
            "viewed": 422
        },
        "renderpass": [
            {
                "code": "// Fork of \"fractal interiors\" by peabrainiac. https://shadertoy.com/view/fd23R3\n// 2021-06-16 16:00:38\n// Original video: https://www.youtube.com/watch?v=VqmsaW9SXbA\n\n/*\n * A fractal I found on youtube a while ago and found quite interesting.\n * It is generated by iterating z'=log(-z)/log(z), and coloring each point\n * based on how quickly its derivative grows (since the orbit itself never\n * actually diverges to infinity).\n *\n * The shader displays an animation by default, but you can also explore\n * the fractal on your own by using WASD and the up and down arrow keys.\n * \n * If you want to dig into the code, Buffer A contains the actual fractal-\n * related code, while Buffer B contains all of the controls, together\n * with a bunch of code that is currently unused and has just been copied\n * over from one of my previous shaders.\n * This whole piece of code is licensed under the unlicense (see below),\n * so feel free to fork and edit it as you like.\n * \n *  - - - - -\n * \n * This is free and unencumbered software released into the public domain.\n * \n * Anyone is free to copy, modify, publish, use, compile, sell, or\n * distribute this software, either in source code form or as a compiled\n * binary, for any purpose, commercial or non-commercial, and by any\n * means.\n * \n * In jurisdictions that recognize copyright laws, the author or authors\n * of this software dedicate any and all copyright interest in the\n * software to the public domain. We make this dedication for the benefit\n * of the public at large and to the detriment of our heirs and\n * successors. We intend this dedication to be an overt act of\n * relinquishment in perpetuity of all present and future rights to this\n * software under copyright law.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n * \n * For more information, please refer to <http://unlicense.org/>.\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 color(vec2 c, vec2 dc);\n\nfloat fractal(in vec2 c, in vec2 dc, in int iter, in vec2 param);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    if (texelFetch(iChannel1,ivec2(0),0).x==0.0){\n        // if the update flag in buffer B is not set, simply keep the old value\n        fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    }else{\n        vec3 pos = texelFetch(iChannel1,ivec2(2,0),0).xyz;\n        vec2 dc = vec2(10.0/(length(iResolution)*pos.z),0.0);\n        vec2 c = pos.xy+dc.x*vec2(1.,-1.)*(fragCoord-iResolution.xy*0.5);\n        fragColor = vec4(color(c,dc),1.0);\n    }\n}\n\n// computes the brightness the pixel at a given fractal coordinate should have\nvec3 color(vec2 c, vec2 dc){\n    vec3 config = texelFetch(iChannel1,ivec2(1,0),0).xyz;\n    int formula = int(config.x);\n    float param = config.y;\n    int iter = int(config.z);\n    if (formula!=-1){\n        return vec3(fractal(c,dc,iter,vec2(cos(.7*sin(param)),sin(0.7*sin(param)))));\n    }else{\n        return vec3(0.0);\n    }\n}\n\nfloat fractal(in vec2 c, in vec2 dc, in int iter, in vec2 param){\n    vec2 z = c;\n    vec2 dz = dc;//vec2(1.0,0.0);\n    for (int i=0;i<iter&&dot(dz,dz)<0.5*dot(z,z);i++){\n        //vec2 z2 = clog(z);\n        //vec2 z3 = vec2(z2.x,z2.y-PI*sign(z2.y));\n        //vec2 z4 = z2-z3;\n        //vec2 z5 = cmul(z,cmul(z2,z2));\n        //z4 = cdiv(z4,z5);\n        //z = cdiv(z3,z2);\n        //dz = cmul(dz,z4);\n        vec2 z2 = vec2(0.5*log(dot(z,z)),atan(z.y,z.x));\n        vec2 z3 = vec2(z2.x,z2.y-PI*sign(z2.y));\n        vec2 z4 = z2-z3;\n        vec2 z5 = vec2(z2.x*z2.x-z2.y*z2.y,2.0*z2.x*z2.y);\n        z5 = vec2(z.x*z5.x-z.y*z5.y,dot(z,z5.yx));\n        z4 = vec2(dot(z4,z5),z4.y*z5.x-z4.x*z5.y)/dot(z5,z5);\n        z = vec2(dot(z2,z3),z3.y*z3.x-z3.x*z2.y)/dot(z2,z2);\n        dz = vec2(dz.x*z4.x-dz.y*z4.y,dot(dz,z4.yx));\n    }\n    return 2.0*(0.7-length(z))*(0.7-length(z));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n * stored values, in order:\n *  - refresh flag, animation flag, reset flag\n *  - formula id, formula param, iterations\n *  - X, Y, zoom\n */\nconst vec3[] defaultValues = vec3[](vec3(1.0,1.0,0.0),vec3(0.0,0.0,500.0),vec3(0.0,0.0,1.0));\n\nfloat keysDown();\nint keyState(int key);\nivec4 keyStates(int key1, int key2, int key3, int key4);\nint keyPressed(int key);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    ivec2 p = ivec2(fragCoord);\n    if (p.y>0||p.x>=3){\n        discard;\n    }else if (iFrame==0){\n        fragColor = vec4(defaultValues[p.x],1.0);\n    }else{\n        fragColor = texelFetch(iChannel0,p,0);\n        if (p==ivec2(0)){\n            // flag updates\n            float keys = keysDown();\n            if (fragColor.y==1.0){\n                if (keys/*+iMouse.x+iMouse.y*/>0.0){\n                    // animation end because of user input\n                    fragColor.xyz = vec3(1.0,0.0,1.0);\n                }\n            }else{\n                //refresh flag update\n                fragColor.x = min(1.0,keys+step(mod(float(iFrame),30.0),0.0));\n                fragColor.z = 0.0;\n            }\n        }else if(p==ivec2(1,0)){\n            // formula & iteration changes\n            vec3 flags = texelFetch(iChannel0,ivec2(0),0).xyz;\n            fragColor.x = mod(fragColor.x+float(keyPressed(KEY_E)-keyPressed(KEY_Q)),6.0);\n            if (flags.y==1.0){\n                // animation\n                fragColor.y = 0.15*iTime*iTime/(iTime+2.0);\n            }else{\n                if (flags.z==1.0){\n                    fragColor.y = 0.0;\n                }\n                // normal controls\n                float zoom = texelFetch(iChannel0,ivec2(2,0),0).z;\n                float paramChange = iTimeDelta/zoom*float(keyState(KEY_RIGHT)-keyState(KEY_LEFT));\n                fragColor.y = mod(fragColor.y+paramChange,2.0*PI);\n                fragColor.z += min(100.0,fragColor.z*(pow(2.0,iTimeDelta*float(keyState(KEY_R)-keyState(KEY_F)))-1.0));\n            }\n        }else if(p==ivec2(2,0)){\n            // zoom & position changes\n            vec3 flags = texelFetch(iChannel0,ivec2(0),0).xyz;\n            if (flags.y==1.0){\n                // animation\n                float theta = 0.3*iTime*iTime/(iTime+2.0);\n                float a = 0.5*theta-0.25*PI;\n                a = cos(a-0.5*sin(a));\n                float b = 1.0-abs(a);\n                b = b*b;\n                a = sign(a)*(1.0-b*b*b*b*b);\n                a = 0.5+0.5*a;\n                fragColor.xy = (0.35+a*1.25)*vec2(-sin(theta),-cos(theta));//+vec2((a-1.0)*0.125,0.0);\n                fragColor.z = 0.75*(4.0-3.0*a)*(1.0+3.0*(iTime*iTime)/((iTime*iTime)+5.0));\n                //fragColor.z = exp(3.0*cos(a));\n            }else{\n                if (flags.z==1.0){// reset flag\n                    //fragColor.xyz = vec3(-0.5,-0.5,2.0);\n                }\n                // normal controls\n                fragColor.xy -= 2.0*iTimeDelta*vec2(float(keyState(KEY_A)-keyState(KEY_D)),float(keyState(KEY_W)-keyState(KEY_S)))/fragColor.z;\n                float zoomChange = iTimeDelta*float(keyState(KEY_UP)-keyState(KEY_DOWN));\n                fragColor.z *= pow(2.0,zoomChange);\n            }\n        }\n    }\n}\n\nfloat keysDown(){\n    float temp = dot(vec4(keyStates(KEY_UP,KEY_RIGHT,KEY_DOWN,KEY_LEFT)),vec4(1.0));\n    temp += dot(vec4(keyStates(KEY_W,KEY_A,KEY_S,KEY_D)),vec4(1.0));\n    temp += dot(vec4(keyStates(KEY_Q,KEY_E,KEY_R,KEY_F)),vec4(1.0));\n    return temp;\n}\n\nint keyState(int key){\n    return int(texelFetch(iChannel1,ivec2(key,0),0).x);\n}\n\nivec4 keyStates(int key1, int key2, int key3, int key4){\n    return ivec4(keyState(key1),keyState(key2),keyState(key3),keyState(key4));\n}\n\nint keyPressed(int key){\n    return int(texelFetch(iChannel1,ivec2(key,1),0).x);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\nconst int KEY_E = 69; // nice.\nconst int KEY_Q = 81;\nconst int KEY_R = 82;\nconst int KEY_F = 70;\n\nconst float PI = 3.14159265358979323846264;\n\n// taken from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 complexColor(vec2 z){\n    float t = length(z);\n    t = 2.0*t/(t+1.0);\n    float t2 = 1.0-min(1.0,2.0-t);\n    float t3 = 1.0-min(1.0,t);\n    return hsv2rgb(vec3(0.5+(0.5/PI)*atan(-z.y,-z.x),1.0-t2*t2,1.0-t3*t3));\n}\n\nvec2 cmul(vec2 a, vec2 b){\n    return vec2(dot(a,vec2(1.0,-1.0)*b),dot(a,b.yx));\n}\n\nvec2 cdiv(vec2 a, vec2 b){\n    return vec2(dot(a,b),dot(a.yx,vec2(1.0,-1.0)*b))/dot(b,b);\n}\n\nvec2 clog(vec2 a){\n    return vec2(0.5*log(dot(a,a)),atan(a.y,a.x));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}