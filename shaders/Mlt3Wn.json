{
    "Shader": {
        "info": {
            "date": "1469019958",
            "description": "As much of the old classic as I could reimplement in GLSL in a week. I think I managed to cover most of the essential features. Unsurprisingly, the gameplay logic would prove to be the real challenge.\n\nArrows + Space.",
            "flags": 56,
            "hasliked": 0,
            "id": "Mlt3Wn",
            "likes": 94,
            "name": "[SH16C] Stubble Bobble",
            "published": 3,
            "tags": [
                "sh16c"
            ],
            "usePreview": 1,
            "username": "stubbe",
            "viewed": 11379
        },
        "renderpass": [
            {
                "code": "#define ONLY_INTEGER_SCALING 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 targetSize = vec2(32.,27.)*8.;\n    vec2 tmp = iResolution.xy / targetSize;\n    float scale = min(tmp.x, tmp.y);\n#if ONLY_INTEGER_SCALING\n    scale = floor(scale);\n#endif\n    vec2 windowOffset = floor((iResolution.xy - targetSize*scale)*.5);\n    \n    vec2 coord = (fragCoord- windowOffset) / scale;\n    if(coord.x < 0.0 || coord.y < 0.0 || coord.x >= targetSize.x || coord.y >= targetSize.y)\n    {\n        fragColor.xyz = vec3(0.0);\n        return;\n    }\n    \n    fragColor = texture(iChannel0, coord / iChannelResolution[0].xy) ;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float BPM = 125.0;\nconst float SPEED = 6.0;\nconst float ROWS_PER_SEC = BPM * 24.0 / (60.0 * SPEED);\nconst float SEC_PER_ROW = 1.0 / ROWS_PER_SEC;\n\nconst int\tPATTERN0_LENGTH = 153;\nconst int\tPATTERN_LENGTH = 64;\nconst int \tNUM_PATTERNS = 7;\n\nconst float PI = 3.1415926535;\n\nconst int C  = 0;\nconst int Cs = 1;\nconst int D  = 2;\nconst int Ds = 3;\nconst int E  = 4;\nconst int F  = 5;\nconst int Fs = 6;\nconst int G  = 7;\nconst int Gs = 8;\nconst int A  = 9;\nconst int As = 10;\nconst int B  = 11;\nconst int X  = -1;\n\n#define N(_pos, _note, _octave) if(row >= (_pos)) { note = ((_octave)*12 + (_note)); hitRow = baseRow + (_pos); }\n\nint imod(int x, int m)\n{\n    return x - x / m * m;\n}\n\nint Data(float time, int track, out float envTime)\n{\n    int globalRow = int(time * ROWS_PER_SEC);\n    \n    int baseRow = 0;\n    int pattern = 0;\n    int row = globalRow;\n    \n    if(globalRow >= PATTERN0_LENGTH)\n    {\n        int m = NUM_PATTERNS - 1;\n        \n        int tmp = globalRow - PATTERN0_LENGTH;\n        \n        row = imod(tmp, PATTERN_LENGTH);\n        \n        pattern = tmp / PATTERN_LENGTH;\n        int numRepeats = pattern / m;\n        pattern = imod(pattern, m);\n        \n        baseRow = PATTERN0_LENGTH + (numRepeats*m+pattern) * PATTERN_LENGTH;\n        pattern++;\n    }\n    \n    int hitRow = -10;\n    int note = 0;\n    if(track == 0)\n    {\n        if(pattern == 0)\n        {\n            N( 0,  B, 0) N( 1,  C, 1) N( 2,  D, 1) N( 3,  E, 1) N( 4,  F, 1) N( 5,  G, 1) N( 6,  A, 1) N( 7,  B, 1) N( 8,  C, 2) \n            N( 9,  D, 2) N(10,  E, 2) N(11,  F, 2) N(12,  G, 2) N(13,  A, 2) N(14,  C, 3) N(20,  X, 0)         \n            //break between splash and intro. Currently 60 beats.\n            N(80,  C, 2) N(86,  C, 2) N(90,  B, 1) N(92,  A, 1)\n            N(96,  B, 1) N(98,  C, 2) N(100, D, 2) N(102, G, 1) N(108,  B, 1)\n            N(112, A, 1) N(118, E, 1) N(124, B, 1)\n            N(128, C, 2) N(132, D, 2) N(139, E, 2) N(146, Fs, 2)\n        }\n        else if(pattern == 1)\n        {\n            N( 0,  G, 2) N( 2, Fs, 2) N( 4,  E, 2) N( 7,  D, 2) N( 8, Fs, 2) N(10,  E, 2) N(12,  D, 2) N(15,  C, 2)\n            N(16,  E, 2) N(18,  D, 2) N(20,  C, 2) N(21,  B, 1) N(24,  D, 2) N(30,  B, 1) N(31,  A, 1) \n            N(32,  G, 1) N(34,  A, 1) N(36,  B, 1) N(38,  C, 2) N(40,  A, 1) N(42,  B, 1) N(43,  C, 2) N(46,  D, 2)\n            N(48,  D, 2) N(50,  E, 2) N(52, Fs, 2) N(53,  E, 2) N(56,  D, 2) N(58,  D, 2) N(60,  E, 2) N(62, Fs, 2) \n        }\n        else if(pattern == 2)\n        {\n            N( 0,  G, 2) N( 2, Fs, 2) N( 4,  E, 2) N( 7,  D, 2) N( 8, Fs, 2) N(10,  E, 2) N(12,  D, 2) N(15,  C, 2)\n            N(16,  E, 2) N(18,  D, 2) N(20,  C, 2) N(21,  B, 1) N(24,  D, 2) N(30,  B, 1) N(31,  A, 1) \n            N(32,  G, 1) N(34,  A, 1) N(36,  B, 1) N(38,  C, 2) N(40,  A, 1) N(42,  B, 1) N(43,  C, 2) N(46,  D, 2)\n            N(48,  D, 2) N(50,  E, 2) N(52, Fs, 2) N(53,  D, 2) N(56,  G, 2) N(58,  D, 2) N(60,  E, 2) N(62, Fs, 2) \n        }\n        else if(pattern == 3)\n        {\n            N( 0, Fs, 2) N(10,  D, 2) N(12,  E, 2) N(14, Fs, 2)\n            N(16,  G, 2) N(26,  D, 2) N(28,  E, 2) N(30, Fs, 2)\n            N(32,  A, 2) N(42,  D, 2) N(44,  E, 2) N(46, Fs, 2)\n            N(48,  B, 2) N(58,  G, 2) N(60,  A, 2) N(62,  B, 2)\n        }\n        else if(pattern == 4)\n        {\n            N( 0,  C, 3) N( 2,  C, 3) N( 6,  C, 3) N(10,  B, 2) N(12,  A, 2)\n            N(16,  B, 2) N(28,  B, 2)\n            N(32,  A, 2) N(38,  E, 2) N(44,  B, 2) N(48,  A, 2) \n            N(58,  D, 2) N(60,  E, 2) N(62,  Fs, 2) \n        }\n        else if(pattern == 5)\n        {\n            N( 0, Fs, 2) N(10,  D, 2) N(12,  E, 2) N(14, Fs, 2)\n            N(16,  G, 2) N(26,  D, 2) N(28,  E, 2) N(30, Fs, 2)\n            N(32,  A, 2) N(42,  D, 2) N(44,  E, 2) N(46, Fs, 2)\n            N(48,  B, 2) N(58,  G, 2) N(60,  A, 2) N(62,  B, 2)\n        }\n        else if(pattern == 6)\n        {\n            N( 0,  C, 3) N( 2,  C, 3) N( 6,  C, 3) N(10,  B, 2) N(12,  A, 2)\n            N(16,  B, 2) N(28,  B, 2)\n            N(32,  A, 2) N(38,  D, 2) N(42,  B, 2) N(44,  D, 2) N(46,  B, 2)\n            N(48,  G, 2) N(56,  X, 0) N(58,  D, 2) N(60,  E, 2) N(62, Fs, 2) \n        }\n    }\n    else if(track == 1)\n    {\n        if(pattern == 0)\n            \n        {\n            N(50, C, 1) \n            N(66,  G, 1)\n            N(82,  A, 1)\n            N(98,  D, 1) N(102,  D, 1) N(109,  E, 1) N(116, Fs, 1)\n\n        }\n        else if(pattern == 1)\n        {\n            N( 0,  G, 1) N( 2,  G, 2) N( 4,  G, 1) N( 6,  G, 2) N( 8,  G, 1) N(10,  G, 2) N(12,  G, 1) N(14,  G, 2)\n            N(16,  G, 1) N(18,  G, 2) N(20,  G, 1) N(22,  G, 2) N(24,  G, 1) N(26,  G, 2) N(28,  G, 1) N(30,  G, 2)\n            N(32,  E, 0) N(34,  E, 1) N(36,  E, 0) N(38,  E, 1) N(40,  E, 0) N(42,  E, 1) N(44,  E, 0) N(46,  E, 1)\n            N(48,  E, 0) N(50,  E, 1) N(52,  E, 0) N(54,  E, 1) N(56,  E, 0) N(58,  E, 1) N(60,  E, 0) N(62,  E, 1)\n        }\n        else if(pattern == 2)\n        {\n            N( 0,  G, 1) N( 2,  G, 2) N( 4,  G, 1) N( 6,  G, 2) N( 8,  G, 1) N(10,  G, 2) N(12,  G, 1) N(14,  G, 2)\n            N(16,  G, 1) N(18,  G, 2) N(20,  G, 1) N(22,  G, 2) N(24,  G, 1) N(26,  G, 2) N(28,  G, 1) N(30,  G, 2)\n            N(32,  E, 0) N(34,  E, 1) N(36,  E, 0) N(38,  E, 1) N(40,  E, 0) N(42,  E, 1) N(44,  E, 0) N(46,  E, 1)\n            N(48,  E, 0) N(50,  E, 1) N(52,  E, 0) N(54,  E, 1) N(56,  G, 0) N(58,  D, 0) N(60,  E, 0) N(62,  F, 0)\n        }\n        else if(pattern == 3 || pattern == 5)\n        {\n            N( 0, Fs, 0) N( 2, Fs, 1) N( 4, Fs, 0) N( 6, Fs, 1) N( 8, Fs, 0) N(10,  D, 0) N(12,  E, 0) N(14, Fs, 0)\n            N(16,  G, 0) N(18,  G, 1) N(20,  G, 0) N(22,  G, 1) N(24,  G, 0) N(26,  D, 0) N(28,  E, 0) N(30,  F, 0)\n            N(32, Fs, 0) N(34, Fs, 1) N(36, Fs, 0) N(38, Fs, 1) N(40, Fs, 0) N(42,  D, 0) N(44,  E, 0) N(46, Fs, 0)\n            N(48,  G, 0) N(50,  G, 1) N(52,  G, 0) N(54,  G, 1) N(56,  G, 0) N(58,  G, 0) N(60,  A, 1) N(62,  B, 1)\n        }\n        else if(pattern == 4)\n        {\n            N( 0,  C, 1) N( 2,  C, 2) N( 4,  C, 1) N( 6,  C, 2) N( 8,  C, 1) N(10,  C, 2) N(12,  C, 1) N(14,  C, 2)\n            N(16,  B, 0) N(18,  B, 1) N(20,  B, 0) N(22,  B, 1) N(24,  B, 0) N(26,  B, 1) N(28,  B, 0) N(30,  B, 1)\n            N(32,  A, 0) N(34,  A, 1) N(36,  A, 0) N(38,  A, 1) N(40,  E, 0) N(42,  E, 1) N(44,  E, 0) N(46,  E, 1)\n            N(48,  A, 0) N(50,  A, 1) N(52,  A, 0) N(54,  A, 1) N(56,  A, 0) \n        }\n        else if(pattern == 6)\n        {\n            N( 0,  C, 1) N( 2,  C, 2) N( 4,  C, 1) N( 6,  C, 2) N( 8,  C, 1) N(10,  C, 2) N(12,  C, 1) N(14,  C, 2)\n            N(16,  B, 0) N(18,  B, 1) N(20,  B, 0) N(22,  B, 1) N(24,  B, 0) N(26,  B, 1) N(28,  B, 0) N(30,  B, 1)\n            N(32,  A, 0) N(34,  A, 1) N(36,  A, 0) N(38,  A, 1) N(40,  D, 0) N(42,  A, 0) N(44,  D, 0) N(46,  A, 0)\n            N(48,  G, 0) N(56,  X, 0) N(58,  D, 0) N(60,  E, 1) N(62, Fs, 1) \n        }\n    }\n    else if(track == 2)\n    {\n        if(pattern == 3 || pattern == 5)\n        {\n            N( 2,  D, 3) N( 4,  E, 3) N( 6,  F, 3) N( 8, Fs, 3)\n            N(18,  D, 3) N(20,  E, 3) N(22, Fs, 3) N(24,  G, 3)\n            N(34,  D, 3) N(36,  E, 3) N(38, Fs, 3) N(40,  A, 3)\n            N(50,  D, 3) N(52,  E, 3) N(54, Fs, 3) N(56,  B, 3)\n        }\n    }\n    \n    envTime = time - float(hitRow)*SEC_PER_ROW;\n    \n    return note;\n}\n\nfloat Square(float x, float threshold)\n{\n    return fract(x) > threshold ? 1.0 : -1.0;\n}\n\nfloat Square2(float x, float threshold, float detune)\n{\n    return (Square(x-detune, threshold) + Square(x+detune, threshold))*.5;\n}\n    \nvec2 mainSound( in int samp, float time )\n{\n    float threshold = sin(time*5.)*.1+.5;\n    \n    float envTime0;\n    float envTime1;\n    float envTime2;\n    float envTime3;\n    \n    int note0 = Data(time, 0, envTime0);\n    int note1 = Data(time, 1, envTime1);\n    int note2 = Data(time, 2, envTime2);\n    int note3 = Data(time - SEC_PER_ROW, 0, envTime3);\n    \n    float freq0 = 440.0*pow(2.0, float(note0)/12.0)*.5*.5;\n    float freq1 = 440.0*pow(2.0, float(note1)/12.0)*.5*.5;\n    float freq2 = 440.0*pow(2.0, float(note2)/12.0)*.5*.5;\n    float freq3 = 440.0*pow(2.0, float(note3)/12.0)*.5*.5;\n    \n    float v = 0.0;\n    v += Square(envTime0*freq0, .5) * exp(-envTime0*.1) * float(note0 >= 0);\n    v += Square(envTime3*freq3, .5) * exp(-envTime3*.1) * float(note0 >= 0) * .2;\n    v += Square2(envTime1*freq1*.5*.5, threshold, 0.03) * float(note0 >= 0);\n    v += Square(envTime2*freq2, .5) * exp(-envTime2*2.) * float(note0 >= 0);\n    \n    return vec2(v*.1);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 38
                    }
                ],
                "type": "sound"
            },
            {
                "code": "// shared game state\n\nconst int ENTITIES_START_Y = 1;\nconst int MAX_ENTITIES = 64;\nconst int NUM_DYNAMIC_ROWS = 3;\n\nconst int LEVEL_WIDTH = 28;\nconst int LEVEL_HEIGHT = 25;\nconst int LEVEL_START_Y = 32;\nconst int NUM_LEVELS = 4;\n\nconst int FONT_START_Y = 8;\nconst int FONT_HEIGHT = 8;\nconst int FONT_WIDTH = 8;\n\nconst int SPRITE_WIDTH = 16;\nconst int SPRITE_HEIGHT = 16;\nconst int SPRITE_START_Y = 16;\n\nconst int STRINGS_START_Y = 60;\nconst int STR_GAME_OVER = 0;\nconst int STR_BEGINNING0 = 1;\nconst int STR_BEGINNING1 = 2;\nconst int STR_BEGINNING2 = 3;\nconst int STR_BEGINNING3 = 4;\nconst int STR_BEGINNING4 = 5;\nconst int STR_PUSH_START = 6;\nconst int STR_1UP = 7;\nconst int STR_HIGH_SCORE = 8;\nconst int STR_00 = 9;\nconst int STR_INSERT = 10;\nconst int STR_COIN = 11;\nconst int STR_TO = 12;\nconst int STR_CONTINUE = 13;\nconst int STR_COPYRIGHT = 14;\nconst int STR_ALL_RIGHTS = 15;\nconst int STR_INSERT_COIN = 16;    \nconst int NUM_STRINGS = 17;\n\nconst int LOGO_START_Y = 200;\nconst int LOGO_WIDTH = 300;\nconst int LOGO_HEIGHT = 150;\n\nconst float ENTITY_TYPE_BUBBLE = 1.0;\nconst float ENTITY_TYPE_MONSTER = 2.0;\nconst float ENTITY_TYPE_TUMBLING_MONSTER = 3.0;\nconst float ENTITY_TYPE_ITEM = 4.0;\nconst float ENTITY_TYPE_SCORE = 5.0;\n\nconst int MONSTER_SPRITE_START_IDX = 5;\nconst int ITEM_SPRITE_START_IDX = 9;\n\nconst int NUM_PLACE_PLAYER_FRAMES = 120;\n\nconst float BUBBLE_ATTACK_FRAMES = 20.0;\nconst float BUBBLE_DEATH_FRAMES = 30.0;\nconst float BUBBLE_LIFE_FRAMES = 1200.0;\nconst float BUBBLE_FLOW_POWER = 0.4;\nconst float BUBBLE_ATTACK_EXP_SCALE = .15;\nconst float BUBBLE_POP_THRESHOLD = 4.0;\nconst float BUBBLE_COOLDOWN = 15.0;\nconst float RESPAWN_FRAMES = 120.0;\nconst float MONSTER_FREE_FRAME = 120.0;\nconst float MONSTER_HIT_DIST_SQ = 60.0;\n\nconst float WIN_DELAY_FRAMES = 150.0;\nconst float INVULNERABLE_FRAMES = 90.0;\n\nconst float PI = 3.1415926535;\nconst float GRAVITY = 0.10;\nconst float TERMINAL_VELOCITY = 1.0;\nconst float MOVEMENT_SPEED = 1.5;\nconst float JUMP_VELOCITY = 3.0;\nconst float PUSH_VECTOR_SCALE = .3;\nconst vec2 txGameState =    vec2(0.0,0.0);\nconst vec2 txGameState2 =   vec2(1.0,0.0);\nconst vec2 txGameState3 =   vec2(2.0,0.0);\nconst vec2 txPlayerPos =    vec2(3.0,0.0);  \nconst vec2 txPlayerSprite = vec2(4.0,0.0);  //vec4(sprite_idx, mirrored, 0, 0)\nconst vec2 txPlayerFlags =  vec2(5.0,0.0);\n// private game state\nconst vec2 txPlayerVel =    vec2(6.0,0.0);\nconst vec2 txKeyWasDown =\tvec2(7.0,0.0);\nconst vec2 txCoolDown = \tvec2(8.0,0.0);\nconst vec2 txStaticDataInited = vec2(9.0,0.0);\n\nconst int SKIP_INTRO = 0;\nconst int START_LEVEL = 1;\n\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\n\nconst int _A = 10, _B = 11, _C = 12, _D = 13, _E = 14, _F = 15, _G = 16, _H = 17, _I = 18, _J = 19, _K = 20, _L = 21, _M = 22, _N = 23, _O = 24, _P = 25, _Q = 26, _R = 27, _S = 28, _T = 29, _U = 30, _V = 31, _W = 32, _X = 33, _Y = 34, _Z = 35, _COPYRIGHT = 36, _EXCLAMATION = 37, _SPACE = 38;\n\n#define HASHSCALE1 .1031\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 Logo(int x, int y)\n{\n    y += 50;\n    vec2 coord = vec2(x, y);\n    float radius = 5.0;\n    float radiusSq = radius*radius;\n    vec2 pos = vec2(0);\n    \n    const int NUM_STEPS = 50;\n    const int NUM_OBJECTS = 13;\n    const int NUM_PARTS = 3;\n    const float STEP_SIZE = 1.5;\n    \n\t#define P(_T) enabled = true; if(phase == ph++ && t >= (_T)) phase++, \n    #define E(_T) if(phase == ph++ && t >= (_T)) break;\n    \n    float value = 0.0;\t//0.0: not drawn, 1.0: inner, 2.0: edge, 3.0: shadow\n    \n    vec2 shadowOffset = vec2(-3,-2);\n    for(int object = 0; object < NUM_OBJECTS; object++)\n    {\n        for(int pass = 0; pass < 2; pass++)\n        {\n            for(int part = 0; part < NUM_PARTS; part++)\n            {       \n                int phase = 0;\n                float shortestDistSq = 1e10;\n                float hitT = 0.0;\n\n                float angle = 0.0;\n                float velocity = 0.0;\n                float acceleration = 0.0;\n                bool enabled = false;\n                bool overrideInner = false;\n                for(int i = 0; i < NUM_STEPS; i++)\n                {\n                    float t = float(i) / float(NUM_STEPS - 1);\n                    int ph = 0;\n                    \n                    // E\n                    if(object == 0)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(170,115), angle = -PI*.5;\n                            P(0.4) angle += PI*.5;\n                            E(0.6);\n                        }\n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(170,115), angle = -PI*.5;\n                            P(0.2) angle += PI*.5;\n                            E(0.35);\n                        }\n                        if(part == 2)\n                        {\n                            P(0.0) pos=vec2(170,115), angle = 0.0;\n                            E(0.2);\n                        }\n                    }\n                    \n                    // L\n                    if(object == 1)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(155,115), angle = -PI*.5-.2;\n                            P(0.4) angle += PI*.5;\n                            E(0.6);\n                        }\n                    }\n                    \n                    // B\n                    if(object == 2)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(130,95), angle = PI*.5;\n                            P(0.35) angle -= PI*0.5, acceleration = -0.007;\n                            P(0.70) acceleration = 0.004;\n                            E(0.82);\n                        }\n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(130,95), angle = -.3, acceleration = 0.007;\n                            P(0.2) overrideInner = true;\n                            E(0.35);\n                        }\n                    }\n                    \n                    // B\n                    if(object == 3)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(108,90), angle = PI*.5-.2;\n                            P(0.35) angle -= PI*0.5, acceleration = -0.007;\n                            P(0.70) acceleration = 0.004;\n                            E(0.82);\n                        }\n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(108,90), angle = -.5, acceleration = 0.007;\n                            P(0.2) overrideInner = true;\n                            E(0.37);\n                        }\n                    }\n                    \n                    // O\n                    if(object == 4)\n                    {\n                        if(part == 0)\n                        {\n                    \t\tP(0.0) pos=vec2(95,100), velocity = 0.13;\n                            E(0.7);\n                        }\n                    }\n                    \n                    // B\n                    if(object == 5)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(65,90), angle = PI*.5;\n                            P(0.4) angle -= PI*0.5, acceleration = -0.007;\n                            P(0.8) acceleration = 0.004;\n                            E(0.87);\n                        }\n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(65,90), angle = -0.2, acceleration = 0.0065;\n                            P(0.2) overrideInner = true;\n                            E(0.4);\n                        }   \n                    }\n                    \n                    // E\n                    if(object == 6)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(190,165), angle = -PI*.5-.2;\n                            P(0.4) angle += PI*.5;\n                            E(0.6);\n                        }\n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(190,165), angle = -PI*.5-.2;\n                            P(0.2) angle += PI*.5;\n                            E(0.35);\n                        }\n                        if(part == 2)\n                        {\n                            P(0.0) pos=vec2(190,165), angle = -.2;\n                            E(0.2);\n                        }\n                    }\n                    \n                    // L\n                    if(object == 7)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(173,165), angle = -PI*.5-.25;\n                            P(0.4) angle += PI*.5;\n                            E(0.6);\n                        }\n                    }\n                    \n                    // B\n                    if(object == 8)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(140,135), angle = PI*.5-.1;\n                            P(0.37) angle -= PI*0.5, acceleration = -0.007;\n                            P(0.70) acceleration = 0.004;\n                            E(0.82);\n                        }\n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(140,135), angle = -.4, acceleration = 0.007;\n                            P(0.2) overrideInner = true;\n                            E(0.4);\n                        }\n                    }\n                    \n                    // B\n                    if(object == 9)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(115,135), angle = PI*.5-.1;\n                            P(0.35) angle -= PI*0.5, acceleration = -0.007;\n                            P(0.70) acceleration = 0.004;\n                            E(0.82);\n                        }\n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(115,135), angle = -.4, acceleration = 0.007;\n                            P(0.2) overrideInner = true;\n                            E(0.37);\n                        }\n                    }\n                    \n                    // U\n                    if(object == 10)\n                    {\n                        if(part == 0)\n                        {\n                    \t\tP(0.0) pos=vec2(95,155), angle =-PI*.5-.2;\n                            P(0.2) velocity = 0.15;\n                            P(0.489) velocity = 0.0;\n                            E(0.68);\n                        }\n                    }\n                    \n                    // T\n                    if(object == 11)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(80,160), angle = -PI*.5+.1;\n                            E(0.35);\n                        }\n                        \n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(67,157), angle = .1;\n                            E(0.30);\n                        }\n                    }\n                    \n                    // S\n                    if(object == 12)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(60,167), angle = PI+.3;\n                            P(0.1) velocity = 0.12;\n                            P(0.35) velocity = 0.0;\n                            P(0.6) velocity = -0.15;\n                            P(0.85) velocity = 0.0;\n                            E(0.95);\n                        }\n                        \n                    }\n                    \n                    \n                    if(!enabled) break;\n\n                    velocity += acceleration * STEP_SIZE;\n                    angle += velocity * STEP_SIZE;\n                    pos += STEP_SIZE * vec2(cos(angle), sin(angle));\n\n                    vec2 offset = (pass == 0) ? shadowOffset : vec2(0,0);\n                    vec2 delta = (coord + offset) - pos;\n                    float lenSq = dot(delta, delta);\n                    if(lenSq < radiusSq)\n                    {\n                        if(lenSq < shortestDistSq)\n                        {\n                            shortestDistSq = lenSq;\n                            hitT = t;\n\n                            if(pass == 0)\n                                value = 3.0;\n                            else\n                                if(lenSq < radiusSq * 0.4)\n                                {\n                                    value = 1.0;\n                                }\n                            \telse\n                                {\n                                    if(value != 1.0 || overrideInner)\n                                    \tvalue = 2.0;\n                                }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    vec3 color = vec3(0);\n    float len = 1e10;\n    for(int i = 0; i < 200; i++)\n    {\n        float t = float(i) + 1200.0;\n        vec2 p = vec2((hash11(t)*2.0)*80.0-80.0,(hash11(t+1000.0)*2.0)*40.0-40.0) + vec2(128, 125);\n        len = min(len, length(p - coord) - hash11(t + 2000.0)*25.+8.0);\n    }\n    if(len < 10.0)\n    {\n        color = mix(vec3(250,161,0)/255.0, color, smoothstep(9.5, 10.0, len));\n        color = mix(vec3(0), color, smoothstep(6.5, 7.0, len));\n        color = mix(vec3(255,240,32)/255.0, color, smoothstep(5.0, 5.5, len));\n    }\n    \n    if(value == 1.0)\n        color = vec3(-1);\n    else if(value >= 2.0)\n        color = vec3(0);\n    \n    return color;\n}\n\n\n\n//hack hack: encode bits into floating point mantissa. much faster to compile than any of the alternatives\n#define D24(_y, _d0, _d1, _d2, _d3, _d4, _d5, _d6, _d7, _d8, _d9, _d10, _d11, _d12, _d13, _d14, _d15, _d16, _d17, _d18, _d19, _d20, _d21, _d22, _d23) v = (y == (_y)) ? (float(_d0)*0.5 + float(_d1)*1.0 + float(_d2)*2.0 + float(_d3)*4.0 + float(_d4)*8.0 + float(_d5)*16.0 + float(_d6)*32.0 + float(_d7)*64.0 + float(_d8)*128.0 + float(_d9)*256.0 + float(_d10)*512.0 + float(_d11)*1024.0 + float(_d12)*2048.0 + float(_d13)*4096.0 + float(_d14)*8192.0 + float(_d15)*16384.0 + float(_d16)*32768.0 + float(_d17)*65536.0 + float(_d18)*131072.0 + float(_d19)*262144.0 + float(_d20)*524288.0 + float(_d21)*1048576.0 + float(_d22)*2097152.0 + float(_d23)*4194304.0) : v;\n\nbool Font(int x, int y, int n)\n{\n    if(x < 0 || x >= FONT_WIDTH || y < 0 || y >= FONT_HEIGHT) return false;\n    float v = 0.0;\n    y = (FONT_HEIGHT - 1) - y;\n    \n    int b = n / 3;\n    \n    \n    if(b == 0)\n    {\n        // 0, 1, 2\n        D24(0, 0,0,0,1,1,1,0,0, 0,0,0,0,1,1,0,0, 0,0,1,1,1,1,1,0)\n        D24(1, 0,0,1,0,0,1,1,0, 0,0,0,1,1,1,0,0, 0,1,1,0,0,0,1,1)\n        D24(2, 0,1,1,0,0,0,1,1, 0,0,0,0,1,1,0,0, 0,0,0,0,0,1,1,1)\n        D24(3, 0,1,1,0,0,0,1,1, 0,0,0,0,1,1,0,0, 0,0,0,1,1,1,1,0)\n        D24(4, 0,1,1,0,0,0,1,1, 0,0,0,0,1,1,0,0, 0,0,1,1,1,1,0,0)\n        D24(5, 0,0,1,1,0,0,1,0, 0,0,0,0,1,1,0,0, 0,1,1,1,0,0,0,0)\n        D24(6, 0,0,0,1,1,1,0,0, 0,0,1,1,1,1,1,1, 0,1,1,1,1,1,1,1) \n    }\n    else if(b == 1)\n    {\n        // 3, 4, 5\n        D24(0, 0,0,1,1,1,1,1,1, 0,0,0,0,1,1,1,0, 0,1,1,1,1,1,1,0)\n        D24(1, 0,0,0,0,0,1,1,0, 0,0,0,1,1,1,1,0, 0,1,1,0,0,0,0,0)\n        D24(2, 0,0,0,0,1,1,0,0, 0,0,1,1,0,1,1,0, 0,1,1,1,1,1,1,0)\n        D24(3, 0,0,0,1,1,1,1,0, 0,1,1,0,0,1,1,0, 0,0,0,0,0,0,1,1)\n        D24(4, 0,0,0,0,0,0,1,1, 0,1,1,1,1,1,1,1, 0,0,0,0,0,0,1,1)\n        D24(5, 0,1,1,0,0,0,1,1, 0,0,0,0,0,1,1,0, 0,1,1,0,0,0,1,1)\n        D24(6, 0,0,1,1,1,1,1,0, 0,0,0,0,0,1,1,0, 0,0,1,1,1,1,1,0)        \n    }\n    else if(b == 2)\n    {\n        // 6, 7, 8\n        D24(0, 0,0,0,1,1,1,1,0, 0,1,1,1,1,1,1,1, 0,0,1,1,1,1,0,0)\n        D24(1, 0,0,1,1,0,0,0,0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,0)\n        D24(2, 0,1,1,0,0,0,0,0, 0,0,0,0,0,1,1,0, 0,1,1,1,0,0,1,0)\n        D24(3, 0,1,1,1,1,1,1,0, 0,0,0,0,1,1,0,0, 0,0,1,1,1,1,0,0)\n        D24(4, 0,1,1,0,0,0,1,1, 0,0,0,1,1,0,0,0, 0,1,0,0,1,1,1,1)\n        D24(5, 0,1,1,0,0,0,1,1, 0,0,0,1,1,0,0,0, 0,1,0,0,0,0,1,1)\n        D24(6, 0,0,1,1,1,1,1,0, 0,0,0,1,1,0,0,0, 0,0,1,1,1,1,1,0)\n    }\n    else if(b == 3)\n    {\n        // 9, A, B\n        D24(0, 0,0,1,1,1,1,1,0, 0,0,0,1,1,1,0,0, 0,1,1,1,1,1,1,0)\n        D24(1, 0,1,1,0,0,0,1,1, 0,0,1,1,0,1,1,0, 0,1,1,0,0,0,1,1)\n        D24(2, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(3, 0,0,1,1,1,1,1,1, 0,1,1,0,0,0,1,1, 0,1,1,1,1,1,1,0)\n        D24(4, 0,0,0,0,0,0,1,1, 0,1,1,1,1,1,1,1, 0,1,1,0,0,0,1,1)\n        D24(5, 0,0,0,0,0,1,1,0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(6, 0,0,1,1,1,1,0,0, 0,1,1,0,0,0,1,1, 0,1,1,1,1,1,1,0)\n    }\n    else if(b == 4)\n    {\n        // C, D, E\n        D24(0, 0,0,0,1,1,1,1,0, 0,1,1,1,1,1,0,0, 0,1,1,1,1,1,1,1)\n        D24(1, 0,0,1,1,0,0,1,1, 0,1,1,0,0,1,1,0, 0,1,1,0,0,0,0,0)\n        D24(2, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,0,0)\n        D24(3, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,1,1, 0,1,1,1,1,1,1,0)\n        D24(4, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,0,0)\n        D24(5, 0,0,1,1,0,0,1,1, 0,1,1,0,0,1,1,0, 0,1,1,0,0,0,0,0)\n        D24(6, 0,0,0,1,1,1,1,0, 0,1,1,1,1,1,0,0, 0,1,1,1,1,1,1,1)\n    }\n    else if(b == 5)\n    {\n        // F, G, H\n        D24(0, 0,1,1,1,1,1,1,1, 0,0,0,1,1,1,1,1, 0,1,1,0,0,0,1,1)\n        D24(1, 0,1,1,0,0,0,0,0, 0,0,1,1,0,0,0,0, 0,1,1,0,0,0,1,1)\n        D24(2, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,1,1)\n        D24(3, 0,1,1,1,1,1,1,0, 0,1,1,0,0,1,1,1, 0,1,1,1,1,1,1,1)\n        D24(4, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(5, 0,1,1,0,0,0,0,0, 0,0,1,1,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(6, 0,1,1,0,0,0,0,0, 0,0,0,1,1,1,1,1, 0,1,1,0,0,0,1,1)\n    }\n    else if(b == 6)\n    {\n        // I, J, K\n        D24(0, 0,0,1,1,1,1,1,1, 0,0,0,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(1, 0,0,0,0,1,1,0,0, 0,0,0,0,0,0,1,1, 0,1,1,0,0,1,1,0)\n        D24(2, 0,0,0,0,1,1,0,0, 0,0,0,0,0,0,1,1, 0,1,1,0,1,1,0,0)\n        D24(3, 0,0,0,0,1,1,0,0, 0,0,0,0,0,0,1,1, 0,1,1,1,1,0,0,0)\n        D24(4, 0,0,0,0,1,1,0,0, 0,0,0,0,0,0,1,1, 0,1,1,1,1,1,0,0)\n        D24(5, 0,0,0,0,1,1,0,0, 0,1,1,0,0,0,1,1, 0,1,1,0,1,1,1,0)\n        D24(6, 0,0,1,1,1,1,1,1, 0,0,1,1,1,1,1,0, 0,1,1,0,0,1,1,1)\n    }\n    else if(b == 7)\n    {\n        // L, M, N\n        D24(0, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(1, 0,1,1,0,0,0,0,0, 0,1,1,1,0,1,1,1, 0,1,1,1,0,0,1,1)\n        D24(2, 0,1,1,0,0,0,0,0, 0,1,1,1,1,1,1,1, 0,1,1,1,1,0,1,1)\n        D24(3, 0,1,1,0,0,0,0,0, 0,1,1,1,1,1,1,1, 0,1,1,1,1,1,1,1)\n        D24(4, 0,1,1,0,0,0,0,0, 0,1,1,0,1,0,1,1, 0,1,1,0,1,1,1,1)\n        D24(5, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,1,1,1)\n        D24(6, 0,1,1,1,1,1,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n    }\n    else if(b == 8)\n    {\n        // O, P, Q\n        D24(0, 0,0,1,1,1,1,1,0, 0,1,1,1,1,1,1,0, 0,0,1,1,1,1,1,0)\n        D24(1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(2, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(3, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(4, 0,1,1,0,0,0,1,1, 0,1,1,1,1,1,1,0, 0,1,1,0,1,1,1,1)\n        D24(5, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,0,0, 0,1,1,0,0,1,1,0)\n        D24(6, 0,0,1,1,1,1,1,0, 0,1,1,0,0,0,0,0, 0,0,1,1,1,1,0,1)\n    }\n    else if(b == 9)\n    {\n        // R, S, T\n        D24(0, 0,1,1,1,1,1,1,0, 0,0,1,1,1,1,0,0, 0,0,1,1,1,1,1,1)\n        D24(1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,1,1,0, 0,0,0,0,1,1,0,0)\n        D24(2, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,0,0, 0,0,0,0,1,1,0,0)\n        D24(3, 0,1,1,0,0,1,1,1, 0,0,1,1,1,1,1,0, 0,0,0,0,1,1,0,0)\n        D24(4, 0,1,1,1,1,1,0,0, 0,0,0,0,0,0,1,1, 0,0,0,0,1,1,0,0)\n        D24(5, 0,1,1,0,1,1,1,0, 0,1,1,0,0,0,1,1, 0,0,0,0,1,1,0,0)\n        D24(6, 0,1,1,0,0,1,1,1, 0,0,1,1,1,1,1,0, 0,0,0,0,1,1,0,0)\n    }\n    else if(b == 10)\n    {\n        // U, V, W\n        D24(0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(2, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,1,0,1,1)\n        D24(3, 0,1,1,0,0,0,1,1, 0,1,1,1,0,1,1,1, 0,1,1,1,1,1,1,1)\n        D24(4, 0,1,1,0,0,0,1,1, 0,0,1,1,1,1,1,0, 0,1,1,1,1,1,1,1)\n        D24(5, 0,1,1,0,0,0,1,1, 0,0,0,1,1,1,0,0, 0,1,1,1,0,1,1,1)\n        D24(6, 0,0,1,1,1,1,1,0, 0,0,0,0,1,0,0,0, 0,1,1,0,0,0,1,1)\n    }\n    else if(b == 11)\n    {\n        // X, Y, Z\n        D24(0, 0,1,1,0,0,0,1,1, 0,0,1,1,0,0,1,1, 0,1,1,1,1,1,1,1)\n        D24(1, 0,1,1,1,0,1,1,1, 0,0,1,1,0,0,1,1, 0,0,0,0,0,1,1,1)\n        D24(2, 0,0,1,1,1,1,1,0, 0,0,1,1,0,0,1,1, 0,0,0,0,1,1,1,0)\n        D24(3, 0,0,0,1,1,1,0,0, 0,0,0,1,1,1,1,0, 0,0,0,1,1,1,0,0)\n        D24(4, 0,0,1,1,1,1,1,0, 0,0,0,0,1,1,0,0, 0,0,1,1,1,0,0,0)\n        D24(5, 0,1,1,1,0,1,1,1, 0,0,0,0,1,1,0,0, 0,1,1,1,0,0,0,0)\n        D24(6, 0,1,1,0,0,0,1,1, 0,0,0,0,1,1,0,0, 0,1,1,1,1,1,1,1)\n    }\n    else if(b == 12)\n    {\n        // copyright, exclamation, space\n        D24(0, 0,0,1,1,1,1,0,0, 0,0,0,1,1,1,0,0, 0,0,0,0,0,0,0,0)\n        D24(1, 0,1,0,0,0,0,1,0, 0,0,0,1,1,1,0,0, 0,0,0,0,0,0,0,0)\n        D24(2, 1,0,0,1,1,0,0,1, 0,0,0,1,1,1,0,0, 0,0,0,0,0,0,0,0)\n        D24(3, 1,0,1,0,0,0,0,1, 0,0,0,1,1,0,0,0, 0,0,0,0,0,0,0,0)\n        D24(4, 1,0,1,0,0,0,0,1, 0,0,0,1,1,0,0,0, 0,0,0,0,0,0,0,0)\n        D24(5, 1,0,0,1,1,0,0,1, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0)\n        D24(6, 0,1,0,0,0,0,1,0, 0,0,0,1,1,0,0,0, 0,0,0,0,0,0,0,0)\n        D24(7, 0,0,1,1,1,1,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0)\n    }\n    \n    int bi = n - b*3;\n    return fract(v*exp2(float(-(bi*8 + x)))) >= 0.5;\n}\n\nint ModLevel(int level)\n{\n    if(level == 0) return 0;\n    return level - (level - 1)/NUM_LEVELS*NUM_LEVELS;\n}\n\nbool Level(int x, int y, int level)\n{\n    if(x < 0 || x >= LEVEL_WIDTH) return true;\n    if(y < 0 || y >= LEVEL_HEIGHT) return false;\n    \n    int abs_x = x <= (LEVEL_WIDTH - 1) - x ? x : (LEVEL_WIDTH - 1) - x;\n    \n    level = ModLevel(level);\n    \n    if(level == 1)\n    {\n        if(y == 0 || y == LEVEL_HEIGHT - 1)\n            return true;\n        else if((y == 5 || y == 10 || y == 15) && (abs_x <= 1 || abs_x >= 5))\n            return true;\n    }\n    else if(level == 2)\n    {\n        if(y == 0)\n            return true;\n        else if(y == 5 && ((abs_x >= 2 && abs_x <= 8) || (abs_x >= 11)))\n            return true;\n        else if(y == 10 && abs_x >= 5)\n            return true;\n        else if(y == 15 && abs_x >= 9 && abs_x <= 12)\n            return true;\n        else if(y == 20 && abs_x >= 11)\n            return true;\n    }\n    else if(level == 3)\n    {\n        if((y == 0 || y == 24) && (abs_x <= 6 || abs_x >= 11))\n            return true;\n        else if(y == 5 && (abs_x <= 4 || (abs_x >= 7 && abs_x <= 9)))\n            return true;\n        else if(abs_x == 3 && y >= 10 && y <= 19)\n            return true;\n        else if(y == 10 && abs_x >= 3 && abs_x <= 12)\n            return true;\n        else if(y == 15 && abs_x >= 3 && abs_x <= 11)\n            return true;\n        else if(y == 20 && abs_x >= 3 && abs_x <= 10)\n            return true;\n    }\n    else if(level == 4)\n    {\n        if((y == 0 || y == 24) && (abs_x <= 6 || abs_x >= 11))\n            return true;\n        if(y == 5 && (abs_x >= 3 && abs_x <= 9 || abs_x == 13))\n            return true;\n        if((y == 10 || y == 15) && (abs_x >= 3 && abs_x <= 6))\n            return true;\n        if(y == 19 && (abs_x >= 3 && abs_x <= 11))\n           return true;\n        if(y == 22 && (abs_x >= 6 && abs_x <= 8))\n           return true;\n        if(y == 23 && abs_x == 6)\n           return true;\n        if(abs_x == 3 && (y >= 5 && y <= 10 || y >= 15 && y <= 19))\n            return true;\n        if((abs_x >= 10 && abs_x <= 11) && (y >= 11 && y <= 19))\n            return true;\n    }\n    \n    return false;\n}\n\nbool Collision(int x, int y, int level)\n{\n    if(level == 0) return false;\n    \n    if(y < 0 || y >= LEVEL_HEIGHT-1) return false;\n    if(x < 0 || x >= LEVEL_WIDTH) return true;\n    \n    level = ModLevel(level);\n    \n    return textureLod(iChannel0, (vec2(x + level*LEVEL_WIDTH, y+LEVEL_START_Y) + 0.5) / iChannelResolution[0].xy, 0.0).x > 0.5;\n}\n\n#define D16(_y, _d0, _d1, _d2, _d3, _d4, _d5, _d6, _d7, _d8, _d9, _d10, _d11, _d12, _d13, _d14, _d15) if(y == (_y)) v0 = float(_d0) * 0.125 + float(_d1) * 1.0 + float(_d2) * 8.0 + float(_d3) * 64.0 + float(_d4) * 512.0 + float(_d5) * 4096.0 + float(_d6) * 32768.0 + float(_d7) * 262144.0, v1 = float(_d8) * 0.125 + float(_d9) * 1.0 + float(_d10) * 8.0 + float(_d11) * 64.0 + float(_d12) * 512.0 + float(_d13) * 4096.0 + float(_d14) * 32768.0 + float(_d15) * 262144.0;    \nvec3 Sprite(int x, int y, int n)\n{\n    vec3 color = vec3(-1);\n    if(x < 0 || x >= SPRITE_WIDTH || y < 0 || y >= SPRITE_HEIGHT) return color;\n    y = (SPRITE_HEIGHT - 1) - y;\n \n    int palette = 0;\n    \n    float v0 = 0.0;\n    float v1 = 0.0;\n    if(n == 1)\n    {\n        palette = 0;\n        D16( 0, 0,0,0,0,0,0,0,0, 1,0,0,0,0,0,0,0)\n        D16( 1, 0,0,0,0,0,0,0,1, 1,1,0,0,0,0,0,0)\n        D16( 2, 0,0,0,1,1,1,1,2, 2,2,2,2,0,0,0,0)\n        D16( 3, 0,0,0,0,1,1,2,2, 2,2,2,2,2,0,0,0)\n        D16( 4, 0,0,0,0,0,2,2,2, 2,3,3,2,3,2,0,0)\n        D16( 5, 0,0,1,1,1,2,2,2, 3,3,4,2,4,3,0,0)\n        D16( 6, 0,0,0,1,2,2,2,2, 3,3,4,2,4,3,0,0)\n        D16( 7, 0,0,0,0,2,2,2,2, 3,3,4,2,4,3,2,0)\n        D16( 8, 0,0,1,1,2,2,2,2, 3,3,4,2,4,3,2,0)\n        D16( 9, 0,0,0,1,2,2,2,2, 2,3,3,2,3,3,2,0)\n        D16(10, 0,0,0,0,2,1,2,2, 0,0,0,3,0,0,0,0)\n        D16(11, 0,0,0,2,1,1,1,2, 2,2,2,2,2,2,0,0)\n        D16(12, 0,0,0,2,1,1,1,2, 2,3,3,3,3,0,0,0)\n        D16(13, 0,0,1,2,1,1,2,2, 3,3,3,3,3,3,0,0)\n        D16(14, 0,1,2,2,2,2,2,1, 1,3,3,3,3,3,0,0)\n        D16(15, 2,2,2,2,2,2,1,1, 1,1,3,3,3,1,1,1)\n    }\n    else if(n == 2)\n    {\n        // shoot\n        palette = 0;\n        D16( 0, 0,0,0,0,0,0,0,1, 0,0,0,0,0,0,0,0)\n        D16( 1, 0,0,0,0,0,0,1,1, 1,3,3,0,0,0,0,0)\n        D16( 2, 0,0,0,1,1,1,1,2, 2,4,3,3,2,0,0,0)\n\t\tD16( 3, 0,0,0,0,1,1,2,3, 4,2,4,3,3,2,0,0)\n        D16( 4, 0,0,0,0,0,2,3,3, 4,4,2,3,2,2,0,0)\n        D16( 5, 0,0,1,1,1,2,3,3, 3,4,3,2,2,0,0,0)\n        D16( 6, 0,0,0,1,2,2,2,3, 3,3,3,2,3,0,0,0)\n\t\tD16( 7, 0,0,0,0,2,2,2,2, 3,3,2,0,0,0,0,0)\n        D16( 8, 0,0,1,1,2,2,2,2, 2,2,0,0,0,0,0,0)\n        D16( 9, 0,0,0,0,0,2,2,2, 2,0,0,0,0,0,0,0)\n        D16(10, 0,0,0,1,1,1,2,2, 0,0,0,0,0,0,0,0)\n\t\tD16(11, 0,0,0,1,1,1,1,2, 2,2,2,2,2,2,0,0)\n        D16(12, 2,0,0,0,1,1,2,2, 2,3,3,3,3,0,0,0)\n        D16(13, 2,1,1,2,2,2,2,2, 3,3,3,3,3,3,0,0)\n        D16(14, 0,2,2,2,2,2,2,1, 1,1,3,3,3,3,0,0)\n\t\tD16(15, 0,0,2,2,2,2,1,1, 1,1,1,3,3,1,1,1)\n    }\n    else if(n == 3)\n    {\n        // dead!\n        palette = 0;\n        D16( 0, 0,0,0,3,0,0,0,0, 1,0,0,0,0,0,0,0)\n        D16( 1, 0,3,0,0,0,0,0,1, 1,1,0,0,0,0,0,0)\n        D16( 2, 0,0,0,1,1,1,1,2, 2,2,2,2,0,0,0,0)\n        D16( 3, 0,0,0,0,1,1,2,2 ,2,2,2,2,2,0,0,0)\n        D16( 4, 0,0,0,0,0,2,2,2 ,2,3,3,2,3,2,0,0)\n        D16( 5, 0,0,1,1,1,2,2,2 ,3,3,4,3,4,3,0,0)\n        D16( 6, 0,0,0,1,2,2,2,2 ,3,3,4,3,4,3,0,0)\n        D16( 7, 2,0,0,1,2,2,2,2 ,4,4,4,4,4,4,2,0)\n        D16( 8, 2,1,1,0,2,2,2,2 ,3,3,4,3,4,3,2,0)\n        D16( 9, 2,1,1,1,1,2,2,2 ,2,3,3,2,3,2,2,0)\n        D16(10, 0,1,1,1,1,1,2,0 ,0,0,0,0,0,0,0,0)\n        D16(11, 0,2,1,1,1,2,2,2 ,0,0,0,0,0,0,0,0)\n        D16(12, 0,0,2,2,2,2,2,2 ,0,0,0,0,0,0,0,0)\n        D16(13, 0,0,2,1,1,1,1,3 ,3,0,0,0,0,0,0,0)\n        D16(14, 0,0,2,2,1,1,1,1 ,3,3,3,3,1,1,1,0)\n        D16(15, 0,0,0,2,3,1,1,1 ,3,3,3,1,1,1,0,0)\n    }\n    else if(n == 4)\n    {\n        // in bubble\n        D16( 0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0)\n        D16( 1, 0,0,0,0,0,0,2,2, 2,2,0,0,0,0,0,0)\n        D16( 2, 0,0,0,0,2,2,2,2, 2,2,2,2,0,0,0,0)\n        D16( 3, 0,0,0,0,2,2,3,3, 2,3,3,2,0,0,0,0)\n        D16( 4, 0,0,0,2,2,3,3,4, 2,4,3,3,2,0,0,0)\n        D16( 5, 0,0,0,2,2,3,3,4, 2,4,3,3,2,0,0,0)\n        D16( 6, 0,0,2,2,2,3,3,4, 2,4,3,3,2,0,0,0)\n        D16( 7, 0,0,2,4,2,3,3,3, 2,3,3,3,2,2,0,0)\n        D16( 8, 0,0,2,4,2,2,3,3, 2,3,3,2,2,2,0,0)\n        D16( 9, 0,0,0,2,4,4,4,4, 4,4,4,4,4,0,0,0)\n        D16(10, 0,0,1,1,1,2,2,2, 2,2,2,2,2,0,1,0)\n        D16(11, 0,1,1,1,1,2,3,3, 3,3,3,2,1,1,1,0)\n        D16(12, 0,0,1,1,2,3,3,3, 3,3,3,3,2,1,0,0)\n        D16(13, 0,0,2,2,1,1,1,3, 3,3,1,1,1,0,0,0)\n        D16(14, 0,0,0,1,1,1,1,1, 3,1,1,1,1,0,0,0)\n        D16(15, 0,0,0,0,0,0,0,0, 0,1,1,1,0,0,0,0)\n    }\n    else if(n == 5)\n    {\n        // monster 0\n        palette = 1;\n        D16( 0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0)\n        D16( 1, 0,0,0,1,1,1,1,1, 1,1,1,1,1,0,0,0)\n        D16( 2, 0,0,1,1,3,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 3, 0,0,1,3,1,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 4, 0,0,1,3,1,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 5, 0,0,1,1,1,1,1,1, 1,1,1,1,2,5,5,0)\n        D16( 6, 0,0,1,1,1,1,1,1, 1,1,1,1,5,6,6,5)\n        D16( 7, 0,0,1,4,1,4,1,1, 1,1,1,1,5,6,6,5)\n        D16( 8, 0,0,1,4,1,4,1,1, 1,1,5,5,5,5,5,0)\n        D16( 9, 0,0,1,4,1,4,1,1, 1,2,6,6,5,6,0,0)\n        D16(10, 0,0,1,1,1,1,1,2, 2,2,6,6,5,6,0,0)\n        D16(11, 0,2,2,2,2,2,2,2, 2,6,5,5,6,2,0,0)\n        D16(12, 0,2,2,2,2,2,2,2, 2,2,6,6,2,2,0,0)\n        D16(13, 0,0,2,2,2,2,2,2, 2,2,2,2,2,0,0,0)\n        D16(14, 0,0,0,0,7,7,7,0, 0,7,7,7,7,0,0,0)\n        D16(15, 0,0,7,7,7,7,7,7, 0,0,0,0,0,0,0,0)\n    }\n    else if(n == 6)\n    {\n        // monster 1\n        palette = 1;\n        D16( 0, 0,0,0,0,0,1,1,1, 1,1,1,0,0,0,0,0)\n        D16( 1, 0,0,0,0,1,1,3,1, 1,1,1,1,1,1,0,0)\n        D16( 2, 0,0,0,1,1,3,1,1, 1,1,1,1,1,1,1,0)\n\t\tD16( 3, 0,0,0,1,1,1,1,1, 1,1,1,1,1,1,1,0)\n        D16( 4, 0,0,0,1,4,1,4,1, 1,1,1,1,1,1,1,0)\n        D16( 5, 0,0,0,1,4,1,4,1, 1,1,1,1,6,5,5,0)\n        D16( 6, 0,0,0,1,4,1,4,1, 1,1,1,6,5,6,6,5)\n\t\tD16( 7, 0,0,0,1,1,1,1,1, 1,1,1,6,5,6,6,5)\n        D16( 8, 0,0,0,4,4,4,4,4, 4,1,1,1,6,5,5,0)\n        D16( 9, 0,0,0,0,4,4,4,4, 4,4,4,4,5,5,5,0)\n        D16(10, 0,0,2,2,2,2,2,2, 2,2,2,6,5,6,6,5)\n\t\tD16(11, 0,0,2,2,2,2,2,2, 2,2,2,6,5,6,6,5)\n        D16(12, 0,0,2,2,2,2,2,2, 2,2,2,2,6,5,5,0)\n        D16(13, 0,7,7,2,2,2,2,2, 2,2,2,2,2,6,0,0)\n        D16(14, 0,0,0,7,7,7,7,0, 0,7,7,7,0,0,0,0)\n\t\tD16(15, 0,0,0,0,0,0,0,7, 7,7,7,7,7,0,0,0)\n    }\n    else if(n == 7)\n    {\n        // monster 2\n        palette = 1;\n        D16( 0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0)\n        D16( 1, 0,0,0,1,1,1,1,1, 1,1,1,1,1,0,0,0)\n        D16( 2, 0,0,1,1,3,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 3, 0,0,1,3,1,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 4, 0,0,1,3,1,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 5, 0,0,1,1,1,1,1,1, 1,1,5,5,1,1,0,0)\n        D16( 6, 0,0,1,1,1,1,1,1, 1,5,6,6,5,0,0,0)\n        D16( 7, 0,0,1,4,1,4,1,1, 1,5,6,6,5,0,0,0)\n        D16( 8, 0,0,1,4,1,4,1,1, 1,6,5,5,5,5,5,0)\n        D16( 9, 0,0,1,4,1,4,1,1, 1,1,1,1,5,6,6,5)\n        D16(10, 0,0,1,1,1,1,1,2, 2,2,2,2,5,6,6,5)\n        D16(11, 0,2,2,2,2,2,2,2, 2,2,2,2,6,5,5,6)\n        D16(12, 0,2,2,2,2,2,2,2, 2,2,2,7,7,6,6,0)\n        D16(13, 0,0,2,2,2,2,2,2, 2,7,7,7,7,7,0,0)\n        D16(14, 0,0,0,0,7,7,7,0, 0,7,7,7,0,0,0,0)\n        D16(15, 0,0,7,7,7,7,7,7, 0,0,0,0,0,0,0,0)   \n    }\n    else if(n == 8)\n    {\n        // monster 3\n        palette = 1;\n        D16( 0, 0,0,0,0,1,1,1,1, 1,1,0,0,0,0,0,0)\n        D16( 1, 0,0,0,1,1,3,1,1, 1,1,1,1,1,0,0,0)\n        D16( 2, 0,0,1,1,3,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 3, 0,0,1,1,1,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 4, 0,0,1,4,1,4,1,1, 1,1,1,1,1,1,0,0)\n        D16( 5, 0,0,1,4,1,4,1,1, 1,1,1,1,1,1,0,0)\n        D16( 6, 0,0,1,4,1,4,1,1, 1,1,5,5,1,5,5,0)\n        D16( 7, 0,0,1,1,1,1,1,1, 1,5,6,6,5,6,6,5)\n        D16( 8, 0,0,4,4,4,4,4,4, 1,5,6,6,5,6,6,5)\n        D16( 9, 0,0,0,4,4,4,4,4, 4,4,5,5,6,5,5,0)\n        D16(10, 0,2,2,2,2,2,2,2, 2,2,6,6,2,6,0,0)\n        D16(11, 0,2,2,2,2,2,2,2, 2,2,2,2,2,2,0,0)\n        D16(12, 7,7,7,7,2,2,2,2, 2,2,2,2,2,2,0,0)\n        D16(13, 0,7,7,7,7,2,2,2, 2,2,2,2,2,0,0,0)\n        D16(14, 0,0,7,7,7,7,0,0, 7,7,7,0,0,0,0,0)\n        D16(15, 0,0,0,0,0,0,7,7, 7,7,7,7,0,0,0,0)        \n    }\n    else if(n == 9)\n    {\n        // banana?\n        palette = 2;\n        D16( 0, 0,0,0,0,0,0,0,0, 0,0,0,3,3,0,0,0)\n        D16( 1, 0,0,0,0,0,0,0,0, 0,0,0,1,2,3,0,0)\n        D16( 2, 0,0,0,0,0,0,0,0, 0,0,0,1,1,1,3,0)\n        D16( 3, 0,0,0,0,0,0,0,0, 0,5,3,1,1,1,1,1)\n        D16( 4, 0,0,0,0,0,0,0,5, 5,3,3,3,1,1,0,0)\n        D16( 5, 5,5,5,5,5,5,5,3, 3,2,3,3,1,1,1,0)\n        D16( 6, 5,3,3,3,3,3,2,2, 2,3,3,1,3,1,1,0)\n        D16( 7, 0,2,2,2,2,2,2,3, 3,3,1,3,3,2,1,0)\n        D16( 8, 0,0,0,2,2,3,3,3, 3,1,3,3,3,2,1,0)\n        D16( 9, 5,5,5,5,5,3,3,2, 1,3,3,3,2,2,1,0)\n        D16(10, 1,5,5,3,2,2,1,1, 3,3,3,2,2,1,0,0)\n        D16(11, 0,1,1,1,1,2,3,3, 3,3,2,2,1,1,0,0)\n        D16(12, 0,0,5,5,5,5,3,3, 2,2,2,1,1,0,0,0)\n        D16(13, 0,5,5,5,5,3,2,2, 2,1,1,1,0,0,0,0)\n        D16(14, 0,0,1,1,1,1,1,1, 1,1,1,0,0,0,0,0)\n        D16(15, 0,0,0,0,1,1,1,1, 1,0,0,0,0,0,0,0)\n    }\n    else if(n == 10)\n    {\n        palette = 2;\n        D16( 0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0)\n        D16( 1, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0)\n        D16( 2, 0,0,0,0,0,0,0,0, 0,0,0,3,2,0,0,0)\n        D16( 3, 0,0,0,0,0,0,1,2, 2,2,2,3,4,2,0,0)\n        D16( 4, 0,0,0,0,1,2,2,3, 3,3,3,3,3,2,0,0)\n        D16( 5, 0,0,0,1,2,3,3,6, 6,3,3,2,2,2,0,0)\n        D16( 6, 0,0,0,2,3,3,3,6, 6,3,3,3,2,2,0,0)\n        D16( 7, 0,0,1,3,3,6,3,3, 3,3,3,3,3,2,0,0)\n        D16( 8, 0,0,2,3,3,3,3,3, 3,3,3,3,3,2,0,0)\n        D16( 9, 0,0,2,3,3,3,3,3, 3,3,3,3,3,2,0,0)\n        D16(10, 0,0,2,3,3,3,3,3, 3,3,3,3,2,2,0,0)\n        D16(11, 0,0,3,3,3,3,3,3, 3,3,3,3,2,2,0,0)\n        D16(12, 0,2,3,3,3,3,3,3, 3,3,3,2,2,0,0,0)\n        D16(13, 0,2,3,2,3,3,3,3, 3,3,2,2,2,0,0,0)\n        D16(14, 0,0,2,2,2,2,2,2, 2,2,2,2,0,0,0,0)\n        D16(15, 0,0,0,0,2,2,2,2, 2,2,0,0,0,0,0,0)\n    }\n    else if(n == 11)\n    {\n        palette = 2;\n        D16( 0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,4,4)\n        D16( 1, 0,0,0,0,0,0,0,0, 0,0,5,5,5,0,4,0)\n        D16( 2, 0,0,0,0,0,0,0,0, 0,5,5,5,4,4,0,0)\n        D16( 3, 0,0,0,0,0,0,0,0, 4,5,6,5,5,4,4,0)\n        D16( 4, 0,0,0,0,0,0,4,4, 4,5,5,5,5,4,4,0)\n        D16( 5, 0,0,0,4,4,4,4,4, 5,5,5,5,5,4,4,0)\n        D16( 6, 0,0,4,4,4,5,5,5, 5,5,5,5,5,4,4,0)\n        D16( 7, 0,4,4,4,4,6,6,4, 5,5,5,5,4,4,4,0)\n        D16( 8, 0,4,4,5,5,6,6,5, 5,4,5,5,4,4,0,0)\n        D16( 9, 4,4,4,5,5,4,5,5, 5,5,5,4,4,4,0,0)\n        D16(10, 4,4,5,4,5,5,5,4, 5,5,5,4,4,4,0,0)\n        D16(11, 4,4,5,5,5,5,5,5, 5,5,4,4,4,0,0,0)\n        D16(12, 4,4,4,5,4,5,5,5, 4,5,4,4,4,0,0,0)\n        D16(13, 0,4,4,4,5,5,4,5, 0,4,4,4,4,0,0,0)\n        D16(14, 0,4,4,4,4,4,4,4, 4,4,4,4,0,0,0,0)\n        D16(15, 0,0,4,4,4,4,4,4, 4,4,4,0,0,0,0,0)\n    }\n    \n    int shift = x < 8 ? 3*x : 3*x-24;\n    float v = x < 8 ? v0 : v1;\n    float idx = floor(fract(v*exp2(float(-shift))) * 8.0);\n    if(palette == 0)\n    {\n        color = (idx == 1.0) ? vec3(224,128, 64)/255.0 : color;\n        color = (idx == 2.0) ? vec3( 96,224, 64)/255.0 : color;\n        color = (idx == 3.0) ? vec3(255,255,255)/255.0 : color;\n        color = (idx == 4.0) ? vec3(  0,  0,  0)/255.0 : color;\n    }\n    else if(palette == 1)\n    {\n        color = (idx == 1.0) ? vec3(170,170,221)/255.0 : color;\n        color = (idx == 2.0) ? vec3(136,136,187)/255.0 : color;\n        color = (idx == 3.0) ? vec3(255,255,255)/255.0 : color;\n        color = (idx == 4.0) ? vec3(  0,  0,  0)/255.0 : color;\n        color = (idx == 5.0) ? vec3(  0,153,255)/255.0 : color;\n        color = (idx == 6.0) ? vec3(136,  0,255)/255.0 : color;\n        color = (idx == 7.0) ? vec3(255,  0,119)/255.0 : color;\n    }\n    else if(palette == 2)\n    {\n        color = (idx == 1.0) ? vec3(255,136,  0)/255.0 : color;\n        color = (idx == 2.0) ? vec3(255,187,  0)/255.0 : color;\n        color = (idx == 3.0) ? vec3(204,255,  0)/255.0 : color;\n        color = (idx == 4.0) ? vec3(  0,187,  0)/255.0 : color;\n        color = (idx == 5.0) ? vec3(  0,255,  0)/255.0 : color;\n        color = (idx == 6.0) ? vec3(255,255,255)/255.0 : color;\n\n    }\n    \n    return color;\n}\n\nvec2 Flow(int x, int y, int level)\n{\n    if(x < 0) return vec2(1,0);\n    if(x >= LEVEL_WIDTH) return vec2(-1,0);\n    if(y < 0) return vec2(0,1);\n    if(y >= LEVEL_HEIGHT - 2) return vec2(0,-1);\n    \n    level = ModLevel(level);\n    \n    float xsign = sign(float(14 - x));\n    \n    //if(level == 1 || level == 2)\n    {\n        if(y > 21) return vec2(xsign, 0);\n    }\n    \n    return vec2(0,1);\n}\n\n#define S4(_c0, _c1, _c2, _c3) { v = (current++ == b) ? (float(_c0)*0.015625 + float(_c1)*1.0 + float(_c2)*64.0 + float(_c3)*4096.0) : v; }\nint String(int str, int x)\n{\n    int b = x / 4;\n    int bi = x - b*4;\n    int current = 0;\n    float v = float(_SPACE)*4161.015625;\n    if(str == STR_GAME_OVER)\n    {\n        S4(_G, _A, _M, _E)\n        S4(_SPACE, _O, _V, _E)\n        S4(_R, _SPACE, _SPACE, _SPACE)\n    }\n    else if(str == STR_BEGINNING0)\n    {\n        S4(_N, _O, _W, _SPACE)\n        S4(_I, _T, _SPACE, _I)\n        S4(_S, _SPACE, _T, _H)\n        S4(_E, _SPACE, _B, _E)\n        S4(_G, _I, _N, _N)\n        S4(_I, _N, _G, _SPACE)\n        S4(_O, _F, _SPACE, _SPACE)\n    } else if(str == STR_BEGINNING1)\n    {\n        S4(_A, _SPACE, _F, _A)\n        S4(_N, _T, _A, _S)\n        S4(_T, _I, _C, _SPACE)\n        S4(_S, _T, _O, _R)\n        S4(_Y, _EXCLAMATION, _SPACE, _L)\n        S4(_E, _T, _SPACE, _U)\n        S4(_S, _SPACE, _SPACE, _SPACE)\n    }\n    else if(str == STR_BEGINNING2)\n    {\n        S4(_M, _A, _K, _E)\n        S4(_SPACE, _A, _SPACE, _J)\n        S4(_O, _U, _R, _N)\n        S4(_E, _Y, _SPACE, _T)\n        S4(_O, _SPACE, _SPACE, _SPACE)\n    }\n    else if(str == STR_BEGINNING3)\n    {\n        S4(_T, _H, _E, _SPACE)\n        S4(_C, _A, _V, _E)\n        S4(_SPACE, _O, _F, _SPACE)\n        S4(_M, _O, _N, _S)\n        S4(_T, _E, _R, _S)\n        S4(_EXCLAMATION, _SPACE, _SPACE, _SPACE)\n    }\n    else if(str == STR_BEGINNING4)\n    {\n        S4(_G, _O, _O, _D)\n        S4(_SPACE, _L, _U, _C)\n        S4(_K, _EXCLAMATION, _SPACE, _SPACE)\n    }\n    else if(str == STR_PUSH_START)\n    {\n        S4(_P, _U, _S, _H)\n        S4(_SPACE, _S, _T, _A)\n        S4(_R, _T, _SPACE, _SPACE)\n    }\n    else if(str == STR_1UP)\n    {\n        S4(1, _U, _P, _SPACE)\n    }\n    else if(str == STR_HIGH_SCORE)\n    {\n        S4(_H, _I, _G, _H)\n        S4(_SPACE, _S, _C, _O)\n        S4(_R, _E, _SPACE, _SPACE)\n    }\n    else if(str == STR_00)\n    {\n        S4(0, 0, _SPACE, _SPACE)\n    }\n    else if(str == STR_INSERT)\n    {\n        S4(_I, _N, _S, _E)\n        S4(_R, _T, _SPACE, _SPACE)\n    }\n    else if(str == STR_COIN)\n    {\n        S4(_C, _O, _I, _N)\n    }\n    else if(str == STR_TO)\n    {\n        S4(_T, _O, _SPACE, _SPACE)\n    }\n    else if(str == STR_CONTINUE)\n    {\n        S4(_C, _O, _N, _T)\n        S4(_I, _N, _U, _E)\n    }\n    else if(str == STR_COPYRIGHT)\n    {\n        S4(_COPYRIGHT, _SPACE, _M, _E)\n        S4(_N,_T,_O,_R)\n        S4(_SPACE,_C,_O,_R)\n        S4(_P,_O,_R,_A)\n        S4(_T,_I,_O,_N)\n        S4(_SPACE,1,9,8)\n        S4(6,_SPACE,_SPACE,_SPACE)\n    }\n    else if(str == STR_ALL_RIGHTS)\n    {\n        S4(_A,_L,_L,_SPACE)\n        S4(_R,_I,_G,_H)\n        S4(_T,_S,_SPACE,_R)\n        S4(_E,_S,_E,_R)\n        S4(_V,_E,_D,_SPACE)\n    }\n    else if(str == STR_INSERT_COIN)\n    {\n        S4(_I, _N, _S, _E)\n        S4(_R, _T, _SPACE, _C)\n        S4(_O, _I, _N, _SPACE)\n    }\n       \n    return int(fract(v * exp2(-float(bi*6)))*64.0);\n}\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue(vec2 re)\n{\n    return textureLod( iChannel0, (0.5 + re) / iChannelResolution[0].xy, 0.0 );\n}\n\nvoid storeValue(vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord)\n{\n    fragColor = (isInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int x = int(fragCoord.x);\n    int y = int(fragCoord.y);\n\n    fragColor = textureLod( iChannel0, fragCoord / iChannelResolution[0].xy, 0.0 );\n    vec4 staticDataInited = loadValue(txStaticDataInited);\n    if(staticDataInited.x == 0.0)\n    {\n        fragColor = vec4(0);\n        if(y >= FONT_START_Y && y < FONT_START_Y + FONT_HEIGHT)\n        {\n            fragColor = Font(x - x/FONT_WIDTH*FONT_WIDTH, y - FONT_START_Y, x/FONT_WIDTH) ? vec4(1) : vec4(0);\n        }\n        \n        if(y >= LEVEL_START_Y && y < LEVEL_START_Y + LEVEL_HEIGHT)\n        {\n            fragColor = Level(x - x/LEVEL_WIDTH*LEVEL_WIDTH, y - LEVEL_START_Y, x/LEVEL_WIDTH) ? vec4(1) : vec4(0);\n        }\n        \n        if(y >= SPRITE_START_Y && y < SPRITE_START_Y + SPRITE_HEIGHT)\n        {\n            fragColor = vec4(Sprite(x - x/SPRITE_WIDTH*SPRITE_WIDTH, y - SPRITE_START_Y, x/SPRITE_WIDTH), 1.0);\n        }\n        if(y >= STRINGS_START_Y && y < STRINGS_START_Y + NUM_STRINGS*FONT_HEIGHT)\n        {\n            int str = (y - STRINGS_START_Y) / FONT_HEIGHT;\n            int c = String(str, x / FONT_WIDTH);\n            int lx = x - x/FONT_WIDTH*FONT_WIDTH;\n            int ly = (y - STRINGS_START_Y) - str*FONT_HEIGHT;\n            fragColor = Font(lx, ly, c) ? vec4(1) : vec4(0);\n        }\n        if(y >= LOGO_START_Y && y < LOGO_START_Y + LOGO_HEIGHT)\n        {\n            fragColor.xyz = Logo(x, y - LOGO_START_Y);\n        }\n        \n        staticDataInited.x = 1.0;\n\t}\n    else\n    {\n        if(y >= NUM_DYNAMIC_ROWS)\n        {\n            return;\n        }\n    }\n\n    if(y == 0 && x >= 16) discard;\n    if(((y == ENTITIES_START_Y) || (y == ENTITIES_START_Y + 1)) && x >= MAX_ENTITIES) discard;\n    \n    // load state\n    vec4 gameState = loadValue(txGameState);\n    vec4 gameState2 = loadValue(txGameState2);\n    vec4 gameState3 = loadValue(txGameState3);\n    vec4 playerPos = loadValue(txPlayerPos);\n    vec4 playerSprite = loadValue(txPlayerSprite);\n    \n    vec4 playerVel = loadValue(txPlayerVel);\n    vec4 playerFlags = loadValue(txPlayerFlags);\n    vec4 keyWasDown = loadValue(txKeyWasDown);\n    vec4 cooldown = loadValue(txCoolDown);\n    \n    float moveRight = textureLod( iChannel1, vec2(KEY_RIGHT, 0.25), 0.0 ).x;\n    float moveLeft  = textureLod( iChannel1, vec2(KEY_LEFT,  0.25), 0.0 ).x;\n    float moveUp    = textureLod( iChannel1, vec2(KEY_UP,    0.25), 0.0 ).x;\n    float keySpace\t= textureLod( iChannel1, vec2(KEY_SPACE, 0.0), 0.0 ).x;\n    \n    float time = iTime - gameState2.w;\n    \n    \n    if(gameState.x == 0.0)\n    {\n        // init\n        playerPos = vec4(0,8,0,0);\n        playerSprite = vec4(1,0,0,0);\n        playerVel = vec4(0);\n        playerFlags = vec4(0);\n        gameState = vec4((SKIP_INTRO == 0) ? 1.0 : 5.0, float(0.0), 0.0, 2.0);   //state, level, score, lives\n        //gameState2 = vec4(0,0,0,0);\t\t//old_player_x, old_player_x, frame_counter, globaltime offset\n        gameState2.xyz = vec3(0,0,0);\n        gameState3 = vec4(0);\t//win_counter\n        \n        if(y == ENTITIES_START_Y || y == ENTITIES_START_Y + 1)\n        {\n            fragColor = vec4(-1);\t\t//(x, y, time, type)\n            //monster:\n            //(x, y, time, type), (direction, target_height, y_velocity, had_floor_contact)\n            //bubble:\n            //(x, y, time, type), (direction, monster, pop_from_timeout, ?)\n        }\n        \n    }\n    else if(gameState.x == 1.0)\n    {\n        if(time > 7.0)\n            gameState.x = 2.0;\n    }\n    else if(gameState.x == 2.0)\n    {\n        if(time > 9.6)\n        {\n            gameState.x = 3.0;\n            gameState2.z = 0.0;\n            \n            float angle = time*2.5;\n        \tplayerPos.xy = vec2(40,120) + vec2(cos(angle)*30.0,sin(angle)*20.0);\t//hack: avoid pop\n        }\n    }\n    else if(gameState.x == 3.0)\n    {\n        // now is the beginning...\n        float angle = time*2.5;\n        playerPos.xy = vec2(40,120) + vec2(cos(angle)*30.0,sin(angle)*20.0);\n        \n        if(time > 18.36)\n        {\n            gameState.x = 4.0;\n            \n            gameState.y += 1.0;\t//hack: avoid pop\n            gameState2.xy = playerPos.xy;\n            playerPos = vec4(0,8,0,0);\n            playerSprite = vec4(1,0,0,0);\n            playerVel = vec4(0);\n            playerFlags = vec4(0);\n        }\n    }\n    else if(gameState.x == 4.0)\n    {\n        if(gameState2.z == 0.0)\n        {\n            if(y == ENTITIES_START_Y || y == ENTITIES_START_Y + 1)\n            {\n                fragColor = vec4(-100,-100,-1,-1e5);\n            }\n            \n            // init level\n            /*\n            gameState2.xy = playerPos.xy;\n            playerPos = vec4(0,8,0,0);\n            playerSprite = vec4(1,0,0,0);\n            playerVel = vec4(0);\n            playerFlags = vec4(0);\n            */\n            int modLevel = ModLevel(int(gameState.y));\n         \n            if(modLevel == 1)\n            {\n                if(y == ENTITIES_START_Y)\n                {\n                    if(x == 0) fragColor = vec4(14*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 1) fragColor = vec4(14*8, LEVEL_HEIGHT*8+16, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 2) fragColor = vec4(14*8, LEVEL_HEIGHT*8+32, 0, ENTITY_TYPE_MONSTER);\n                }\n                \n                if(y == ENTITIES_START_Y + 1)\n                {\n                    if(x == 0) fragColor = vec4(-1, 16*8, -1, -1);\n                    if(x == 1) fragColor = vec4(-1, 18*8, -1, -1);\n                    if(x == 2) fragColor = vec4(-1, 20*8, -1, -1);\n                }\n            }\n            else if(modLevel == 2)\n            {\n                if(y == ENTITIES_START_Y)\n                {\n                    if(x == 0) fragColor = vec4(10*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 1) fragColor = vec4(12*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 2) fragColor = vec4(14*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 3) fragColor = vec4(16*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                }\n                \n                if(y == ENTITIES_START_Y + 1)\n                {\n                    if(x == 0) fragColor = vec4(-1, 16*8, -1, -1);\n                    if(x == 1) fragColor = vec4(-1, 21*8, -1, -1);\n                    if(x == 2) fragColor = vec4( 1, 21*8, -1, -1);\n                    if(x == 3) fragColor = vec4( 1, 16*8, -1, -1);\n                }\n            }\n            else if(modLevel == 3)\n            {\n                if(y == ENTITIES_START_Y)\n                {\n                    if(x == 0) fragColor = vec4(4*8, LEVEL_HEIGHT*8,  0, ENTITY_TYPE_MONSTER);\n                    if(x == 1) fragColor = vec4(8*8, LEVEL_HEIGHT*8,  0, ENTITY_TYPE_MONSTER);\n                    if(x == 2) fragColor = vec4(18*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 3) fragColor = vec4(22*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                }\n                \n                if(y == ENTITIES_START_Y + 1)\n                {\n                    if(x == 0) fragColor = vec4( 1, 16*8, -1, -1);\n                    if(x == 1) fragColor = vec4( 1, 21*8, -1, -1);\n                    if(x == 2) fragColor = vec4(-1, 21*8, -1, -1);\n                    if(x == 3) fragColor = vec4(-1, 16*8, -1, -1);\n                }\n            }\n            else if(modLevel == 4)\n            {\n                if(y == ENTITIES_START_Y)\n                {\n                    if(x == 0) fragColor = vec4(4*8, LEVEL_HEIGHT*8,  0, ENTITY_TYPE_MONSTER);\n                    if(x == 1) fragColor = vec4(6*8, LEVEL_HEIGHT*8,  0, ENTITY_TYPE_MONSTER);\n                    if(x == 2) fragColor = vec4(8*8, LEVEL_HEIGHT*8,  0, ENTITY_TYPE_MONSTER);\n                    if(x == 3) fragColor = vec4(18*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 4) fragColor = vec4(20*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 5) fragColor = vec4(22*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                }\n                \n                if(y == ENTITIES_START_Y + 1)\n                {\n                    if(x == 0) fragColor = vec4( 1, 20*8, -1, -1);\n                    if(x == 1) fragColor = vec4( 1, 16*8, -1, -1);\n                    if(x == 2) fragColor = vec4( 1,  8*8, -1, -1);\n                    if(x == 3) fragColor = vec4(-1,  8*8, -1, -1);\n                    if(x == 4) fragColor = vec4(-1, 16*8, -1, -1);\n                    if(x == 5) fragColor = vec4(-1, 20*8, -1, -1);\n                }\n            }\n\n        }\n        \n        gameState2.z++;\n        if(gameState2.z > float(NUM_PLACE_PLAYER_FRAMES))\n        {\n            gameState.x = 5.0;\n            gameState2.z = 0.0;\n        }\n    }\n    else if(gameState.x == 5.0)\n    {\n        gameState2.z++;\n\n        \n        // player\n        playerVel.y = max(playerVel.y - GRAVITY, -TERMINAL_VELOCITY);\n\n        float oldPlayerPosX = playerPos.x;\n        if(playerFlags.y >= 0.0)\n        {\n            // alive\n            \n            if(moveUp > 0.0 && playerFlags.x == 1.0)\t//only allow jump if we had ground collision last frame\n            {\n                //playerFlags.x = 1.0;\n                playerVel.y += JUMP_VELOCITY;\n            }\n\n            playerPos.x += MOVEMENT_SPEED * (moveRight - moveLeft);\n            playerSprite.y = (moveRight > 0.0 ^^ moveLeft > 0.0) ? float(moveLeft) : playerSprite.y;\n            \n            playerFlags.y += 1.0;\n        }\n        else\n        {\n            playerFlags.y -= 1.0;\n        }\n        \n        playerPos.xy += playerVel.xy;\n        \n        {\n            float deltaX = playerPos.x - oldPlayerPosX;\n            if(deltaX > 0.0)\n            {\n                int bx = int(playerPos.x/8.0+2.0);\n            \tbool wallCollision = Collision(bx, int(playerPos.y/8.0+0.5), int(gameState.y)) &&\n                \t\t\t\t\tCollision(bx, int(playerPos.y/8.0+1.5), int(gameState.y));\n            \tif(wallCollision) playerPos.x = float(bx)*8.0-16.0;\n            }\n            else\n            {\n                int bx = int(floor(playerPos.x/8.0));\n                bool wallCollision = Collision(bx, int(playerPos.y/8.0+0.5), int(gameState.y)) &&\n                    \t\t\t\tCollision(bx, int(playerPos.y/8.0+1.5), int(gameState.y));\n                if(wallCollision) playerPos.x = float(bx)*8.0+8.0;\n            }            \n        }\n        \n        \n        if(playerPos.y < -16.0) playerPos.y = float(LEVEL_HEIGHT)*8.0;\t// wrap around y-axis\n        \n        \n        // did I walk into a monster?\n        int firstFreeEntity = 0;\n        for(int i = 0; i < MAX_ENTITIES; i++)\n        {\n            vec4 entity0 = textureLod( iChannel0, (vec2(i, ENTITIES_START_Y) + 0.5) / iChannelResolution[0].xy, 0.0 );\n            \n            if(entity0.w == ENTITY_TYPE_MONSTER && playerFlags.y >= INVULNERABLE_FRAMES && length(entity0.xy - playerPos.xy) < 10.0)\n            {\n                // death\n                playerFlags.y = -1.0;\n                gameState.w -= 1.0;\n            }\n            \n            if(entity0.w < 0.0 && firstFreeEntity == 0)\n            {\n                firstFreeEntity = i;\n            }\n        }\n        \n        // respawn?\n        if(playerFlags.y < -RESPAWN_FRAMES)\n        {\n            if(gameState.w >= 0.0)\n            {\n                playerFlags.y = 0.0;\n                playerPos = vec4(0,8,0,0);\n                playerSprite = vec4(1,0,0,0);\n                playerVel = vec4(0);\n            }\n            else\n            {\n                gameState.x = 6.0;\t//game over!\n            }\n        }\n        \n        \n        bool didFire = (keySpace != 0.0 && keyWasDown.x == 0.0 && cooldown.x <= 0.0 && playerFlags.y >= 0.0);\n        if(didFire)\n        {\n            cooldown.x = BUBBLE_COOLDOWN;\n        }\n        \n        if(playerFlags.y >= 0.0)\n        \tplayerSprite.x = float(cooldown.x > 5.0) + 1.0;\n        else\n            playerSprite.x = 3.0; \n        \n        bool floorCollision = Collision(int(playerPos.x/8.0+.5), int(playerPos.y/8.0), int(gameState.y)) || Collision(int(playerPos.x/8.0+.5)+1, int(playerPos.y/8.0), int(gameState.y));\n        playerFlags.x = 0.0;\n        if(playerVel.y <= 0.0 && floorCollision)\n        {\n            float new_y = (floor(playerPos.y/8.0)+1.0)*8.0;\n            if(new_y <= playerPos.y + 2.0)\t//ignore if it moves us up too much\n            {\n                playerPos.y = new_y;\n                playerVel.y = 0.0;\n                playerFlags.x = 1.0;\n            }\n        }\n\n        \n        // entity update\n        if((y == ENTITIES_START_Y || y == ENTITIES_START_Y + 1) && x < MAX_ENTITIES)\n        {\n            vec4 entity0 = textureLod( iChannel0, (vec2(x, ENTITIES_START_Y + 0) + 0.5) / iChannelResolution[0].xy, 0.0 );\n            vec4 entity1 = textureLod( iChannel0, (vec2(x, ENTITIES_START_Y + 1) + 0.5) / iChannelResolution[0].xy, 0.0 );\n            \n            \n            if(entity0.w == ENTITY_TYPE_BUBBLE)\t// bubble update\n            {\n                entity1.w = 0.0;\t// clear points\n                \n                bool turnToMonster = false;\n                bool turnToTumbling = false;\n                \n                vec2 pushVector = vec2(0);\n            \tfor(int i = 0; i < MAX_ENTITIES; i++)\n            \t{\n                \tvec4 otherEntity0 = textureLod( iChannel0, (vec2(i, ENTITIES_START_Y + 0) + 0.5) / iChannelResolution[0].xy, 0.0 );\n                    vec4 otherEntity1 = textureLod( iChannel0, (vec2(i, ENTITIES_START_Y + 1) + 0.5) / iChannelResolution[0].xy, 0.0 );\n                \n                    if(entity0.z >= 0.0 && otherEntity0.w == ENTITY_TYPE_BUBBLE)\n                    {\n                        vec2 delta = entity0.xy - otherEntity0.xy;\n                        float dist = length(delta);\n                        if(otherEntity0.z >= 0.0)\n                        {\n                            if(length(delta) > 0.01) pushVector += normalize(delta) * max(0., 13.0 - dist);\n                        }\n                        else if(otherEntity0.z >= -2.0 && otherEntity1.z == 0.0 && dist < 15.0)\t//neighbor died very recently\n                        {\n                            entity0.z = -1.0;\n                            entity1.z =  0.0;\t// not timeout\n                            entity1.w = (entity1.y > 0.0) ? 1000.0 : 10.0;\t// points\n                           \tturnToTumbling = (entity1.y > 0.0);\n                        }\n                    }\n            \t}\n                \n                if(entity0.z >= 0.0)\n                {\n                    if(entity0.z < BUBBLE_ATTACK_FRAMES && entity1.y <= 0.0 && gameState2.z >= MONSTER_FREE_FRAME)\n                    {\n                        for(int j = 0; j < MAX_ENTITIES; j++)\n                        {\n                            vec4 otherEntity0 = textureLod( iChannel0, (vec2(j, ENTITIES_START_Y + 0) + 0.5) / iChannelResolution[0].xy, 0.0 );\n                            if(otherEntity0.w == ENTITY_TYPE_MONSTER)\n                            {\n                                vec2 delta = entity0.xy - (otherEntity0.xy + vec2(8,8));\n                                if(dot(delta, delta) < MONSTER_HIT_DIST_SQ)\n                                {\n                                    entity1.y = 1.0;\t// caught a monster!\n                                }\n                            }\n                        }\n                    }\n                    \n                    vec2 delta = entity0.xy - (playerPos.xy + vec2(8,8));\n                    float penetration = max(0.,16. - length(delta));\n                    if(length(delta) > .01) pushVector += normalize(delta) * penetration;\n\n                    if(entity0.z < BUBBLE_ATTACK_FRAMES)\n                        entity0.x += entity1.x * exp2(-BUBBLE_ATTACK_EXP_SCALE * entity0.z) / BUBBLE_ATTACK_EXP_SCALE;\n                    else\n                        entity0.xy += Flow(int(entity0.x/8.0), int(entity0.y/8.0), int(gameState.y)) * BUBBLE_FLOW_POWER;\n                    entity0.xy += pushVector*PUSH_VECTOR_SCALE;\n                    entity0.x = clamp(entity0.x, 8., float(LEVEL_WIDTH)*8.-8.);\n                    entity0.z += 1.0;\n                    if(entity0.z >= BUBBLE_LIFE_FRAMES)\n                    {\n                        entity0.z = -1.0;\n                        entity1.z =  1.0;\t// timeout\n                        entity1.w =  0.0;\t// 0 points\n                        turnToMonster = (entity1.y > 0.0);\n                    }\n                    else if(entity0.z > 10.0 && penetration > BUBBLE_POP_THRESHOLD)\n                    {\n                        entity0.z = -1.0;\t// popped by player\n                        entity1.z =  0.0;\t// not timeout\n                        entity1.w = (entity1.y > 0.0) ? 1000.0 : 10.0;\t// points\n                        turnToTumbling = (entity1.y > 0.0);\n                    }   \n                }\n                else\n                {\n                    entity0.z -= 1.0;\n                }\n              \n                if(entity0.z < -BUBBLE_DEATH_FRAMES)\n                {\n                    entity0.w = -1.0;\n                }\n                \n                if(turnToMonster)\n                {\n                    entity0.z = 0.0;\n                    entity0.w = ENTITY_TYPE_MONSTER;\n                    entity1 = vec4(1, 0, -1, -1);\n                }\n                \n                if(turnToTumbling)\n                {\n                    entity0.z = 0.0;\n                    entity0.w = ENTITY_TYPE_TUMBLING_MONSTER;\n                    entity1 = vec4(-1, -1, -1, 1000.0);\n                    entity1.x = (hash11(iTime + float(x)*100.0)*2.0-1.0)*3.0;\n                    entity1.y = 3.5;\n                }\n                \n            }\n            else if(entity0.w == ENTITY_TYPE_MONSTER)\t// monster update\n            {\n                // alive                \n                if(gameState2.z < MONSTER_FREE_FRAME)\n                {\n                    //move monsters down to starting location\n                    if(entity0.y > entity1.y)\n                    {\n                        entity0.y = max(entity0.y - 1.5, entity1.y);\n                    }\n                }\n                else\n                {\n                    // was monster hit by bubble?\n                    for(int i = 0; i < MAX_ENTITIES; i++)\n                    {\n                        vec4 otherEntity0 = textureLod( iChannel0, (vec2(i, ENTITIES_START_Y + 0) + 0.5) / iChannelResolution[0].xy, 0.0 );\n                        vec4 otherEntity1 = textureLod( iChannel0, (vec2(i, ENTITIES_START_Y + 1) + 0.5) / iChannelResolution[0].xy, 0.0 );\n                        if(otherEntity0.w == ENTITY_TYPE_BUBBLE && otherEntity0.z >= 0.0 && otherEntity0.z < BUBBLE_ATTACK_FRAMES && otherEntity1.y <= 0.0)\n                        {\n                            vec2 delta = otherEntity0.xy - (entity0.xy + vec2(8,8));\n                            if(dot(delta, delta) < MONSTER_HIT_DIST_SQ)\n                            {\n                                entity0.w = -1.0;\n                            }\n                        }\n                    }\n                    \n                    entity1.z = max(entity1.z - GRAVITY, -TERMINAL_VELOCITY);\n                    \n                    \n                    entity0.y += entity1.z;\n                    bool floorCollision = Collision(int(entity0.x/8.0+.5), int(entity0.y/8.0), int(gameState.y)) || Collision(int(entity0.x/8.0+.5)+1, int(entity0.y/8.0), int(gameState.y));\n                    \n                    bool ceilingCollision = false;\n                    for(int i = 2; i <= 5; i++)\n                    {\n                        ceilingCollision = ceilingCollision || Collision(int(entity0.x/8.0+1.0), int(entity0.y/8.0+float(i)), int(gameState.y));\n                    }\n                    \n                    if(entity1.w > 0.0)\n                    {\n                        //we can jump, but should we?\n                        if(playerPos.y > entity0.y + 8.0 && ceilingCollision && hash11(time+float(x)*200.0)>0.98)\n                        {\n                             // yes!\n                            entity1.z += JUMP_VELOCITY;\n                            entity1.w = 0.0;\n                        }\n                    }\n                    \n                    entity1.w = 0.0;\n                    if(entity1.z <= 0.0 && floorCollision)\n                    {\n                        float new_y = (floor(entity0.y/8.0)+1.0)*8.0;\n                        if(new_y <= entity0.y + 2.0)\t//ignore if it moves us up too much\n                        {\n                            entity0.y = new_y;\n                            entity1.z = 0.0;\n                            entity1.w = 1.0;\n                        }\n                        entity0.x += entity1.x;\n                        \n                        float xpos = entity0.x/8.0 + ((entity1.x < 0.0) ? -1.0 : 2.0);\n                        bool wallCollision = Collision(int(xpos), int(entity0.y/8.0+.5), int(gameState.y));\n                        if(wallCollision)\n                        {\n                            entity0.x -= entity1.x;\n                            entity1.x *= -1.0;\n                        }\n                    }\n                    if(entity0.y < -16.0) entity0.y = float(LEVEL_HEIGHT)*8.0;\t// wrap around y-axis\n                    \n                }\n                entity0.z += 1.0;\n            }\n            else if(entity0.w == ENTITY_TYPE_TUMBLING_MONSTER)\n            {\n                entity1.w = 0.0;\t//clear points\n                \n                entity0.z += 1.0;\n                entity0.xy += entity1.xy;\n                if(entity0.y < -16.0) entity0.y = float(LEVEL_HEIGHT)*8.0;\t// wrap around y-axis\n                \n                entity1.y = max(entity1.y - GRAVITY, -TERMINAL_VELOCITY);\n                \n                if(entity0.x < 0.0)\n                {\n                    entity0.x = 0.0;\n                    entity1.x *= -1.0;\n                }\n                else if(entity0.x >= float(LEVEL_WIDTH-4)*8.0)\n                {\n                    entity0.x = float(LEVEL_WIDTH-4)*8.0;\n                    entity1.x *= -1.0;\n                }\n                entity1.x *= 0.98;\n                \n                if(entity0.z > 180.0)\n                {\n                    bool floorCollision = Collision(int(entity0.x/8.0+.5), int(entity0.y/8.0), int(gameState.y)) || Collision(int(entity0.x/8.0+.5)+1, int(entity0.y/8.0), int(gameState.y));\n    \t\t\t\tif(floorCollision)\n                    {\n                        entity0.y = (floor(entity0.y/8.0)+1.0)*8.0;\n                    \tentity0.z = floor(hash11(iTime + float(x)*100.0)*2.99);\t// icon\n                        entity0.w = ENTITY_TYPE_ITEM;\n                        entity1.w = 1000.0;\t// points\n                    }\n                }   \n            }\n            else if(entity0.w == ENTITY_TYPE_ITEM)\n            {\n                if(length(playerPos.xy - entity0.xy) < 10.0)\n                {\n                    entity0.w = ENTITY_TYPE_SCORE;\n                    entity1.w = 1000.0;\n                }\n            }\n            else if(entity0.w == ENTITY_TYPE_SCORE)\n            {\n                entity1.w = 0.0;\n            }\n            \n            // fire new bubble?\n            if(didFire && x == firstFreeEntity)\n            {\n                if(playerSprite.y > 0.0)\n                {\n                    entity0 = vec4(playerPos.x +  6.0, playerPos.y + 8., 0, ENTITY_TYPE_BUBBLE);\n                    entity1 = vec4(-1, -1, -1, 0);\n                }\n                else\n                {\n                    entity0 = vec4(playerPos.x + 10.0, playerPos.y + 8., 0, ENTITY_TYPE_BUBBLE);\n                    entity1 = vec4( 1, -1, -1, 0);\n                }\n            }\n            \n            fragColor = (y == ENTITIES_START_Y) ? entity0 : entity1;\n        }\n        \n        \n        \n        keyWasDown.x = keySpace;\n        cooldown -= 1.0;\n        \n        bool winCondition = true;//gameState.y > 0.0;\n        if(y == 0)\n        {\n            for(int i = 0; i < MAX_ENTITIES; i++)\n            {\n                vec4 entity0 = textureLod( iChannel0, (vec2(i, ENTITIES_START_Y + 0) + 0.5) / iChannelResolution[0].xy, 0.0 );\n                vec4 entity1 = textureLod( iChannel0, (vec2(i, ENTITIES_START_Y + 1) + 0.5) / iChannelResolution[0].xy, 0.0 );\n                if(entity0.w == ENTITY_TYPE_MONSTER || (entity0.w == ENTITY_TYPE_BUBBLE && entity1.y > 0.0))\n                {\n                    winCondition = false;\n                }\n                if(entity0.w == ENTITY_TYPE_BUBBLE || entity0.w == ENTITY_TYPE_SCORE)\n                {\n                    gameState.z += entity1.w;\n                }\n                if(entity0.w == ENTITY_TYPE_TUMBLING_MONSTER)\n                {\n                    gameState.z += entity1.w;\n                    winCondition = false;\n                }\n            }\n        }\n        \n        if(winCondition)\n        {\n            gameState3.x += 1.0;\n            \n            if(gameState3.x >= WIN_DELAY_FRAMES)\n            {\n                gameState.x = 4.0;\t//next level\n                gameState2.z = 0.0;\n                gameState3.x = 0.0;\n                \n                //hack hack to avoid pop when changing level\n                gameState.y++;\n                gameState2.xy = playerPos.xy;\n                playerPos = vec4(0,8,0,0);\n                playerSprite = vec4(1,0,0,0);\n                playerVel = vec4(0);\n                playerFlags = vec4(0);\n            }\n        }\n        \n    } else if(gameState.x == 6.0)\n    {\n        if(keySpace != 0.0)\n        {\n            gameState.x = 0.0;\n            gameState2.w = iTime;\n        }\n    }\n    \n    // store state\n    storeValue(txGameState,     vec4(gameState),    fragColor, fragCoord);\n    storeValue(txGameState2,    vec4(gameState2),   fragColor, fragCoord);\n    storeValue(txGameState3,    vec4(gameState3),   fragColor, fragCoord);\n    storeValue(txPlayerPos,     vec4(playerPos),    fragColor, fragCoord);\n    storeValue(txPlayerSprite,  vec4(playerSprite), fragColor, fragCoord);\n    storeValue(txPlayerVel,     vec4(playerVel),    fragColor, fragCoord);\n    storeValue(txPlayerFlags,   vec4(playerFlags),  fragColor, fragCoord);\n    storeValue(txKeyWasDown,  \tvec4(keyWasDown),\tfragColor, fragCoord);\n    storeValue(txCoolDown,  \tvec4(cooldown),\t\tfragColor, fragCoord);\n    storeValue(txStaticDataInited, vec4(staticDataInited),\tfragColor, fragCoord);\n    \n}\n\n\n//TODO:\n//*d24 font\n//**baseline: ~2s\n//**now: ~1s\n//*move sprites to Buf A\n//**baseline: ~5s\n//**now: ~3s\n//**float hacking for sprites\n//*monster sprite + movement\n//*sprite rotation\n//*life counter\n//*fix pattern 0 length\n//*intro animation: \"now it is the beginning of a fantastic story..\"\n//*hero in bubble\n//*change level animation\n//*game over\n//*game restart\n//-fix state transition glitches!\n//**remove bubbles\n//**clear jump state\n//-monster in bubble: begin: 9:17\n//**monster disappears when hit by attack bubble: 9:26\n//**monster trapped in bubble: 10:55\n//**monsters/items/bubbles are entities! 11:12\n//**release monster\n//**win condition\n//*bug: hit multiple monsters with one bubble!\n//**multipop doesn't work anymore\n//**fall out the bottom...\n//**bug: can walk on top of level\n//**draw monster in bubble\n//*support for multiple tiles\n//*shake bubble when about to pop\n//*bubbles shouldn't pop neighbors when popped by timeout\n//*points for bubbles\n//*monsters use collision\n//**wall collision\n//*collision issues\n//**jump after fall\n//**glide into wall\n//**walk through wall\n//*monster fall\n//*monster jump\n//*better AI\n//*repeat levels!\n//*invulnerable\n//*item pickup\n//**sync music with logo\n//**optimize: performance is crappy now\n//*resolution scaling\n//*more fruit\n//*faster compile\n//*only update 'dynamic' part of texture\n//*level 4\n//*fix transitions\n//*logo\n//*copyright message?\n//-long compile time because of logo\n//-real tiles\n//-bubble effect in intro\n//-dead monster sprite\n//-bug no wall colision on top row\n//-logo AA?\n//-jump animation\n//-fall animation\n//-walk animation\n//-bubbles collide with level?\n//-monster leaping\n//-death animation\n//-player 2\n//-TODO: retrigger notes\n//-note slide\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// shared game state\nconst int LEVEL_WIDTH = 28;\nconst int LEVEL_HEIGHT = 25;\nconst int LEVEL_START_Y = 32;\nconst int NUM_LEVELS = 4;\n\nconst int FONT_START_Y = 8;\nconst int FONT_HEIGHT = 8;\nconst int FONT_WIDTH = 8;\n\nconst int SPRITE_WIDTH = 16;\nconst int SPRITE_HEIGHT = 16;\nconst int SPRITE_START_Y = 16;\n\nconst int ENTITIES_START_Y = 1;\nconst int MAX_ENTITIES = 64;\n\nconst int STRINGS_START_Y = 60;\nconst int STR_GAME_OVER = 0;\nconst int STR_BEGINNING0 = 1;\nconst int STR_BEGINNING1 = 2;\nconst int STR_BEGINNING2 = 3;\nconst int STR_BEGINNING3 = 4;\nconst int STR_BEGINNING4 = 5;\nconst int STR_PUSH_START = 6;\nconst int STR_1UP = 7;\nconst int STR_HIGH_SCORE = 8;\nconst int STR_00 = 9;\nconst int STR_INSERT = 10;\nconst int STR_COIN = 11;\nconst int STR_TO = 12;\nconst int STR_CONTINUE = 13;\nconst int STR_COPYRIGHT = 14;\nconst int STR_ALL_RIGHTS = 15;\nconst int STR_INSERT_COIN = 16;\n\nconst int LOGO_START_Y = 200;\nconst int LOGO_WIDTH = 300;\nconst int LOGO_HEIGHT = 150;\n\n\nconst float ENTITY_TYPE_BUBBLE = 1.0;\nconst float ENTITY_TYPE_MONSTER = 2.0;\nconst float ENTITY_TYPE_TUMBLING_MONSTER = 3.0;\nconst float ENTITY_TYPE_ITEM = 4.0;\n\nconst int MONSTER_SPRITE_START_IDX = 5;\nconst int ITEM_SPRITE_START_IDX = 9;\n\nconst int NUM_PLACE_PLAYER_FRAMES = 120;\nconst float INVULNERABLE_FRAMES = 90.0;\n\nconst float BUBBLE_ATTACK_FRAMES = 20.0;\nconst float BUBBLE_DEATH_FRAMES = 30.0;\nconst float BUBBLE_LIFE_FRAMES = 1200.0;\nconst vec3 BUBBLE_COLOR = vec3(0.25, 1.0, 0.25);\n\nconst float TILE_SIZE = 8.;\nconst float SHADOW_WIDTH = 3.0;\nconst int LEVEL_HEIGHT_MARGIN = 4;\nconst int LEVEL_HEIGHT_IN_PIXELS = int(TILE_SIZE) * (LEVEL_HEIGHT + LEVEL_HEIGHT_MARGIN);\nconst vec2 txGameState = \tvec2(0.0,0.0);\nconst vec2 txGameState2 = \tvec2(1.0,0.0);\nconst vec2 txGameState3 = \tvec2(2.0,0.0);\nconst vec2 txPlayerPos = \tvec2(3.0,0.0);\nconst vec2 txPlayerSprite = vec2(4.0,0.0);\nconst vec2 txPlayerFlags =  vec2(5.0,0.0);\n\nconst float PI = 3.1415926535;\n\n\n\n#define HASHSCALE1 .1031\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nbool Letter(int x, int y, int n)\n{\n    if(x < 0 || x >= FONT_WIDTH || y < 0 || y >= FONT_HEIGHT) return false;\n    return textureLod(iChannel0, (vec2(x + n*FONT_WIDTH, y+FONT_START_Y) + 0.5) / iChannelResolution[0].xy, 0.0).x > 0.5;\n}\n\nint ModLevel(int level)\n{\n    if(level == 0) return 0;\n    return level - (level - 1) / NUM_LEVELS * NUM_LEVELS;\n}\n\n#define D16(_y, _d0, _d1, _d2, _d3, _d4, _d5, _d6, _d7, _d8, _d9, _d10, _d11, _d12, _d13, _d14, _d15) if(y == (_y)) v0 = float(_d0) * 0.125 + float(_d1) * 1.0 + float(_d2) * 8.0 + float(_d3) * 64.0 + float(_d4) * 512.0 + float(_d5) * 4096.0 + float(_d6) * 32768.0 + float(_d7) * 262144.0, v1 = float(_d8) * 0.125 + float(_d9) * 1.0 + float(_d10) * 8.0 + float(_d11) * 64.0 + float(_d12) * 512.0 + float(_d13) * 4096.0 + float(_d14) * 32768.0 + float(_d15) * 262144.0;    \nvec3 Sprite(vec2 coord, int n, vec3 color, bool mirror, int rotate, vec3 colorMultiply)\n{\n    int x = int(coord.x);\n    int y = int(coord.y);\n    if(mirror) x = (SPRITE_WIDTH - 1) - x;\n    int old_x = x;\n    int old_y = y;\n    if(rotate == 1) { x = 15-old_y; y = old_x; }\n    else if(rotate == 2) { x = 15-old_x; y = 15-old_y; }\n    else if(rotate == 3) { x = old_y; y = 15-old_x; }\n\n    if(x < 0 || x >= SPRITE_WIDTH || y < 0 || y >= SPRITE_HEIGHT) return color;\n    \n    vec3 c = textureLod(iChannel0, (vec2(x + n*SPRITE_WIDTH, y + SPRITE_START_Y) + 0.5) / iChannelResolution[0].xy, 0.0).xyz;\n    return c.x >= 0.0 ? (c * colorMultiply) : color;\n}\n\n\nvec3 PrintStr(vec2 fragCoord, int x, int y, int str, vec3 color, vec3 inputColor)\n{\n    int lx = int(fragCoord.x) - x;\t\n    int ly = int(fragCoord.y) - y;\n    if(lx < 0 || ly < 0 || ly >= FONT_HEIGHT) return inputColor;\n    \n    return textureLod(iChannel0, (vec2(lx, STRINGS_START_Y + str * FONT_HEIGHT + ly) + 0.5) / iChannelResolution[0].xy, 0.0).x > 0.5 ? color : inputColor;\n}\n\n\nfloat Number(vec2 coord, int n, int numDigits)\n{\n    int x = int(coord.x);\n    int y = int(coord.y);\n    if(x < 0 || y < 0 || x >= FONT_WIDTH*numDigits || y >= FONT_HEIGHT)\n    {\n        return 0.0;\n    }\n    \n    int d = x / FONT_WIDTH;\n    x = x - d * FONT_WIDTH;\n    int tmp = int((float(n) + 0.5) / pow(10.,float((numDigits - 1) - d)));\n    if(tmp == 0 && d < numDigits - 2)\n        return 0.0;\n\n    tmp = tmp - tmp/10*10;\n    return Letter(x, y, tmp) ? 1.0 : 0.0;\n}\n\nbool Map(vec2 coord, int level)\n{\n    int x = int(coord.x);\n    int y = int(coord.y);\n    \n    if(level == 0) return false;\n    \n    if(y < 0 || y >= LEVEL_HEIGHT) return false;\n    if(x < 0 || x >= LEVEL_WIDTH) return true;\n    \n    level = ModLevel(level);\n    \n    \n    return textureLod(iChannel0, (vec2(x + level*LEVEL_WIDTH, y+LEVEL_START_Y) + 0.5) / iChannelResolution[0].xy, 0.0).x > 0.5;\n}\n\nvec3 Tile(vec2 coord, int tile)\n{\n    //coord = floor(coord);\t//pixelate\n    if(tile == 1)\n    {\n        float s = sin((coord.x + coord.y)/8.0*PI*2.0+1.);\n        return (s >= 0.0 ? vec3(244,106,252) : vec3(252, 194, 252)) / 255.0;\n    }\n    else if(tile == 2)\n    {\n        float s = sin((coord.x + coord.y)/8.0*PI*2.0+1.);\n        return (s >= 0.0 ? vec3(106,244,252) : vec3(194, 252, 252)) / 255.0;\n    }\n    else if(tile == 3)\n    {\n        float s = sin((coord.x + coord.y)/8.0*PI*2.0+1.);\n        return (s >= 0.0 ? vec3(244,252,106) : vec3(252, 252, 194)) / 255.0;\n    }\n    else if(tile == 4)\n    {\n        float s = sin((coord.x + coord.y)/8.0*PI*2.0+1.);\n        return (s >= 0.0 ? vec3(244,252,106) : vec3(252, 252, 194)) / 255.0;\n    }\n    \n    return vec3(0.0);\n}\n\nvoid TileShadowColors(int tile, out vec3 color0, out vec3 color1)\n{\n    color0 = color1 = vec3(0);\n    if(tile == 1)\n    {\n        color0 = vec3(244,106,252)/255.0*.6;\n        color1 = vec3(244,106,252)/255.0*.4;\n    } else if(tile == 2)\n    {\n        color0 = vec3(106,244,252)/255.0*.6;\n        color1 = vec3(106,244,252)/255.0*.4;\n    }\n    else if(tile == 3)\n    {\n        color0 = vec3(244,252,106)/255.0*.6;\n        color1 = vec3(244,252,106)/255.0*.4;\n    }\n    else if(tile == 4)\n    {\n        color0 = vec3(244,252,106)/255.0*.6;\n        color1 = vec3(244,252,106)/255.0*.4;\n    }\n}\n\n\n\nvec3 LargeBubble(vec2 coord, float time, vec3 color)\n{\n    float radius = 12.0 + sin(time*3.0);\n    float aspect = 1.0 + sin(time*7.5)*.1;\n    float len = abs(length(coord*vec2(aspect, 2.0 - aspect)) - radius);\n    float alpha = max(0.0, 1.0 - len);\n    return mix(color, vec3(1), alpha);\n}\n\nvec3 DrawMap(vec2 pixelCoord, float offset, vec3 color)\n{\n    if(offset < float(LEVEL_HEIGHT_IN_PIXELS)*.5)\n    {\n        int ioffset = int(offset);\n        \n        // vec3 PrintStr(vec2 fragCoord, int x, int y, int str, vec3 color, vec3 inputColor)\n        color = PrintStr(pixelCoord, 1*8, 25*8+ioffset, STR_BEGINNING0, vec3(1), color);\n        color = PrintStr(pixelCoord, 2*8, 23*8+ioffset, STR_BEGINNING1, vec3(1), color);\n        color = PrintStr(pixelCoord, 6*8, 21*8+ioffset, STR_BEGINNING2, vec3(1), color);\n        color = PrintStr(pixelCoord, 4*8, 19*8+ioffset, STR_BEGINNING3, vec3(1), color);\n        color = PrintStr(pixelCoord, 9*8, 16*8+ioffset, STR_BEGINNING4, vec3(1), color);\n    }\n    \n    int level = int(offset - pixelCoord.y + float(LEVEL_HEIGHT_IN_PIXELS)) / LEVEL_HEIGHT_IN_PIXELS;\n    level = ModLevel(level);\n    pixelCoord.y = mod(pixelCoord.y - offset, float(LEVEL_HEIGHT_IN_PIXELS));\n                    \n    vec2 tileCoord = floor((pixelCoord + 0.5) / TILE_SIZE);\n    vec2 tileOffset = (pixelCoord - tileCoord*TILE_SIZE);\n    tileOffset.y = (TILE_SIZE - 1.0) - tileOffset.y;\n    \n    \n    \n    \n    int tile = level;\n    if(Map(tileCoord, level))\n    {\n        color = Tile(tileOffset, tile);\n    }\n    else\n    {\n        //TODO: optimize this!\n        vec3 color0, color1;\n        TileShadowColors(tile, color0, color1);\n        bool left = Map(tileCoord+vec2(-1,0), level);\n        bool up = Map(tileCoord+vec2(0,1), level);\n        bool upleft = Map(tileCoord+vec2(-1,1), level);\n        if(upleft && left && up && tileOffset.x < SHADOW_WIDTH && tileOffset.y < SHADOW_WIDTH)\n        \tcolor = (tileOffset.x < tileOffset.y)?color0:color1;\n        else if(upleft && left && tileOffset.x < SHADOW_WIDTH)\n        \tcolor = color0;// now is the beginning...\n        else if(upleft && up && tileOffset.y < SHADOW_WIDTH)\n        \tcolor = color1;\n        else if(upleft && tileOffset.x < SHADOW_WIDTH && tileOffset.y < SHADOW_WIDTH)\n        \tcolor = (tileOffset.x < tileOffset.y)?color1:color0;\n        else if(left && tileOffset.x < SHADOW_WIDTH)\n            color = (tileOffset.x < tileOffset.y)?color0:vec3(0);\n        else if(up && tileOffset.y < SHADOW_WIDTH)\n            color = (tileOffset.x < tileOffset.y)?vec3(0):color1;\n    }\n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 targetSize = vec2(32.,27.)*TILE_SIZE;\n    if(fragCoord.x > targetSize.x || fragCoord.y > targetSize.y) discard;\n    fragColor = vec4(0);\n    \n    // load state\n    vec4 gameState = \ttextureLod(iChannel0, (txGameState + 0.5) / iChannelResolution[0].xy, 0.0);\n    vec4 gameState2= \ttextureLod(iChannel0, (txGameState2+ 0.5) / iChannelResolution[0].xy, 0.0);\n    vec2 playerPos = \ttextureLod(iChannel0, (txPlayerPos + 0.5) / iChannelResolution[0].xy, 0.0).xy;\n    vec4 playerSprite =\ttextureLod(iChannel0, (txPlayerSprite + 0.5) / iChannelResolution[0].xy, 0.0);\n    vec4 playerFlags =\ttextureLod(iChannel0, (txPlayerFlags + 0.5) / iChannelResolution[0].xy, 0.0);\n    \n    vec2 playFieldCoord = fragCoord - vec2(TILE_SIZE*2.0,0);\n    vec2 tileCoord = floor((playFieldCoord + 0.5) / TILE_SIZE);\n    vec2 tileOffset = (playFieldCoord - tileCoord*TILE_SIZE);\n    tileOffset.y = (TILE_SIZE - 1.0) - tileOffset.y;\n    \n    float time = iTime;\n    \n\tint level = int(gameState.y);\n    /*\n    if(gameState.x == 3.0)\n    {\n        // now is the beginning...\n        \n        fragColor.xyz = Sprite(playFieldCoord - playerPos.xy, 4, fragColor.xyz, fract(time*2.0) > 0.5, 0);\n        fragColor.xyz = LargeBubble(playFieldCoord - playerPos.xy - vec2(8.0, 8.0), time, fragColor.xyz);\n        \n        \n        \n        return;\n    }\n    */\n    \n    if(gameState.x == 3.0 || gameState.x == 4.0)\n    {\n        // transition to level\n        float s = min(1.0, gameState2.z * .01);\n        vec2 pos = mix(gameState2.xy, playerPos.xy, s);\n        float offset = (float(level-1)+s) * float(LEVEL_HEIGHT_IN_PIXELS);\n        if(gameState.x == 3.0)\n        {\n            pos = playerPos;\n            offset = 0.0;\n        }\n    \n        fragColor.xyz = DrawMap(playFieldCoord, offset, fragColor.xyz);\n        \n        fragColor.xyz = Sprite(playFieldCoord - pos.xy, 4, fragColor.xyz, fract(time*2.0) > 0.5, 0, vec3(1));\n        fragColor.xyz = LargeBubble(playFieldCoord - pos.xy - vec2(8.0, 8.0), time, fragColor.xyz);\n        \n        return;\n    }\n    \n    // header\n    if(tileCoord.y > 24.0)\n    {\n        int score = int(gameState.z);\n        fragColor.xyz = vec3( Number(fragCoord - vec2(0,25.*8.), score, 8) +\n                              Number(fragCoord - vec2(10*8,25.*8.), 30000, 8));\n    \n        fragColor.xyz = PrintStr(fragCoord, 4*8, 26*8, STR_1UP, vec3(0,210,0)/255., fragColor.xyz);\n        fragColor.xyz = PrintStr(fragCoord, 11*8, 26*8, STR_HIGH_SCORE, vec3(210,0,0)/255., fragColor.xyz);\n        \n        float playTime = iTime;\t//TODO: fix this\n        if(gameState.x < 4.0)\n        {\n            fragColor.xyz = PrintStr(fragCoord, 25*8, 26*8, STR_1UP, vec3(0,190,255)/255., fragColor.xyz);\n            fragColor.xyz = PrintStr(fragCoord, 27*8, 25*8, STR_00, vec3(0,190,255)/255., fragColor.xyz);\n        }\n        else\n        {\n            if(mod(iTime,3.0) < 1.5)\n            {\n                fragColor.xyz = PrintStr(fragCoord, 24*8, 26*8, STR_INSERT, vec3(0,190,255)/255., fragColor.xyz);\n                fragColor.xyz = PrintStr(fragCoord, 25*8, 25*8, STR_COIN, vec3(0,190,255)/255., fragColor.xyz);\n            }\n            else\n            {\n                fragColor.xyz = PrintStr(fragCoord, 26*8, 26*8, STR_TO, vec3(0,190,255)/255., fragColor.xyz);\n                fragColor.xyz = PrintStr(fragCoord, 23*8, 25*8, STR_CONTINUE, vec3(0,190,255)/255., fragColor.xyz);\n            }\n        }\n        \n        return;\n    }\n\n\n    \n    if(gameState.x == 1.0)\n    {\n        // bubble bobble splash\n        \n        fragColor.xyz = PrintStr(fragCoord, 3*8, 5*8, STR_COPYRIGHT, vec3(1), fragColor.xyz);\n        fragColor.xyz = PrintStr(fragCoord, 7*8, 3*8, STR_ALL_RIGHTS, vec3(1), fragColor.xyz);\n        \n        float c = sin(iTime*24.5)*.5+0.5;\n        \n        /*\n        vec2 coord = fragCoord + vec2(0, min(0.0,-160.0+floor(iTime*120.0)));\n        float len = 1e10;\n        for(int i = 0; i < 200; i++)\n        {\n            float t = float(i) + 1200.0;\n            vec2 p = vec2((hash11(t)*2.0)*80.0-80.0,(hash11(t+1000.0)*2.0)*40.0-40.0) + vec2(128, 125);\n            len = min(len, length(p - coord) - hash11(t + 2000.0)*25.+8.0);\n        }\n        if(len < 10.0)\n        {\n            vec3 color = vec3(0);\n            color = mix(vec3(250,161,0)/255.0, color, smoothstep(9.5, 10.0, len));\n            color = mix(vec3(0), color, smoothstep(6.5, 7.0, len));\n            color = mix(vec3(255,240,32)/255.0, color, smoothstep(5.0, 5.5, len));\n        \tfragColor.xyz = color;\n        }\n        \n        fragColor.xyz = Logo(int(coord.x), int(coord.y), vec3(1), fragColor.xyz);\n\t\t*/\n        \n        vec2 coord = fragCoord - vec2(0, 50) + vec2(0, min(0.0,-160.0+floor(iTime*120.0)));\n        int x = int(coord.x);\n        int y = int(coord.y);\n        \n        \n        if(x >= 0 && x < LOGO_WIDTH && y >= 0 && y < LOGO_HEIGHT)\n        {\n            vec3 tmp = textureLod(iChannel0, (vec2(x, y+LOGO_START_Y) + 0.5) / iChannelResolution[0].xy, 0.0).xyz;\n            float s = sin(iTime*50.0)*.5+.5;\n            \n            if(iTime >= 0.12*20.0) s = 0.0;\n    \t\tvec3 drawColor = mix(vec3(255, 88, 152), vec3(255, 255, 100), s)/255.0;\n            \n    \n    \t\tfragColor.xyz = tmp.x < 0.0 ? drawColor : tmp;\n        }\n        \n        return;\n    }\n    \n    if(gameState.x == 2.0)\n    {\n        // insert coin\n        fragColor.xyz = PrintStr(fragCoord, 10*8, 13*8, STR_INSERT_COIN, vec3(1), fragColor.xyz);\n        return;\n    }\n    \n    if(gameState.x == 6.0)\n    {\n        // game over        \n        fragColor.xyz = PrintStr(fragCoord, 12*8, 13*8, STR_GAME_OVER, vec3(1), fragColor.xyz);\n        fragColor.xyz = PrintStr(fragCoord, 11*8, 7*8, STR_PUSH_START, vec3(1), fragColor.xyz);\n        return;\n    }\n    \n    fragColor.xyz = DrawMap(playFieldCoord, float(level * LEVEL_HEIGHT_IN_PIXELS), fragColor.xyz);\n    \n    int lives = int(gameState.w);\n    \n    // bubbles    \n    for(int i = 0; i < MAX_ENTITIES; i++)\n    {\n        vec4 entity0 = textureLod(iChannel0, (vec2(i, ENTITIES_START_Y + 0) + 0.5) / iChannelResolution[0].xy, 0.0);\n        vec4 entity1 = textureLod(iChannel0, (vec2(i, ENTITIES_START_Y + 1) + 0.5) / iChannelResolution[0].xy, 0.0);\n        if(entity0.w == ENTITY_TYPE_BUBBLE && entity0.z >= -BUBBLE_DEATH_FRAMES)\n        {\n            float radius =  min(8.,1.0 + entity0.z*.5);\n            if(entity0.z < 0.0) radius = 8.0;\n            vec2 delta = playFieldCoord - entity0.xy;\n            float aspect = 1.0 + sin(entity0.z*.1 )*.1;\n            float l = length(delta*vec2(aspect,2.0-aspect));\n            if(l < radius + 1.)\n            {\n                float l2 = length(delta + vec2(2,-2));\n                float c = max(0.0, 1.0 - entity0.z / BUBBLE_ATTACK_FRAMES);\n                \n                if(entity0.z >= 0.0)\n                {    \n                    if(entity1.y >= 0.0)\n                    {\n                        // draw monster inside\n                        fragColor.xyz = Sprite(delta*1.25 + vec2(8.,8.), MONSTER_SPRITE_START_IDX, fragColor.xyz, false, 0, vec3(1));\n                    }\n                    \n                    // bubble\n                    float shake = max(0., entity0.z - (BUBBLE_LIFE_FRAMES - 120.0));\n                    shake = sin(shake)*.3 + 1.0;\n                    float alpha = max(0., 1.0 - abs(l - 7.5)*.75);\n                \tfragColor.xyz = ((fragColor.xyz + c) * (mix(vec3(1), BUBBLE_COLOR, c)) + (alpha*.75*BUBBLE_COLOR + exp(-l2)))*shake;\n                }\n                else\n                {\n                    // bursting animation\n                    float angle = fract(atan(delta.y, delta.x)/(2.0*PI));\n                    float band = min(.4 - entity0.z*.05, 1.3);\n                    float q = abs(0.5 - 2.0*fract(angle*16.0))*5.0/l * float(l > radius*(band-.1) && l < radius*band);\n                    q = clamp(q, 0.0, 1.0);\n                    fragColor.xyz = mix(fragColor.xyz, vec3(1), vec3(q));\n                }\n            }\n        }\n    }\n    \n    // draw monsters/tumblers/items\n    for(int i = 0; i < MAX_ENTITIES; i++)\n    {\n        vec4 entity0 = textureLod(iChannel0, (vec2(i, ENTITIES_START_Y + 0) + 0.5) / iChannelResolution[0].xy, 0.0);\n        vec4 entity1 = textureLod(iChannel0, (vec2(i, ENTITIES_START_Y + 1) + 0.5) / iChannelResolution[0].xy, 0.0);\n        if(entity0.w == ENTITY_TYPE_MONSTER)\n        {\n            int frame = int(mod(entity0.z*.1, 4.0));\n            fragColor.xyz = Sprite(playFieldCoord - entity0.xy, MONSTER_SPRITE_START_IDX+frame, fragColor.xyz, entity1.x > 0.0, 0, vec3(1));\n        }\n        else if(entity0.w == ENTITY_TYPE_TUMBLING_MONSTER)\n        {\n            int rot = int(mod(entity0.z*.1, 4.0));\n            int frame = int(mod(entity0.z*.2, 4.0));\n            fragColor.xyz = Sprite(playFieldCoord - entity0.xy, MONSTER_SPRITE_START_IDX+frame, fragColor.xyz, entity1.x > 0.0, rot, vec3(0.5,0.7,1));\n        }\n        else if(entity0.w == ENTITY_TYPE_ITEM)\n        {\n            int frame = int(entity0.z);\n            fragColor.xyz = Sprite(playFieldCoord - entity0.xy, ITEM_SPRITE_START_IDX+frame, fragColor.xyz, false, 0, vec3(1));\n        }\n    }\n\n    if(playerFlags.y >= 0.0)\n    {\n        float intensity = 1.0 + 0.1*sin(playerFlags.y)*float(playerFlags.y < INVULNERABLE_FRAMES);\n        // alive\n        fragColor.xyz = Sprite(playFieldCoord - playerPos, int(playerSprite.x), fragColor.xyz, playerSprite.y != 0.0, 0, vec3(intensity));\n    }\n    else\n    {\n        // dead\n        int rot = int(-playerFlags.y)/16;\n        rot = rot - rot/4*4;\n        fragColor.xyz = Sprite(playFieldCoord - playerPos, int(playerSprite.x), fragColor.xyz, playerSprite.y != 0.0, rot, vec3(1));\n    }\n    \n    \n    \n    if(fragCoord.x < 2.0*8.0)\n    {\n    \t// level\n        if(fragCoord.y > 23.5*8.0)\n        {\n            fragColor.xyz -= Number(fragCoord - vec2(-1,24.*8.-1.) + vec2(-1,1), level, 2);\n            fragColor.xyz = clamp(fragColor.xyz, 0.0, 1.0);\n            fragColor.xyz += Number(fragCoord - vec2(-1,24.*8.-1.), level, 2);\n        }\n        // lives\n        if(fragCoord.y < 8.0)\n        {\n            fragColor.xyz -= Number(fragCoord - vec2(-1,0.*8.-1.) + vec2(-1,1), lives, 2);\n            fragColor.xyz = clamp(fragColor.xyz, 0.0, 1.0);\n            fragColor.xyz += Number(fragCoord - vec2(-1,0.*8.-1.), lives, 2);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}