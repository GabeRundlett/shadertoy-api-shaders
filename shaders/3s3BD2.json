{
    "Shader": {
        "info": {
            "date": "1605976657",
            "description": "A remix of spolsh's \"Sunset Drive Unlimited\" (SDU). Seusenarnarnareu features harder gameplay: invisible reflected cars and hidden coins. Has graphical modifications. [url]https://www.shadertoy.com/view/wtS3W3[/url]\nPlease post your high scores!",
            "flags": 48,
            "hasliked": 0,
            "id": "3s3BD2",
            "likes": 3,
            "name": "Seusenarnarnareu, a fork",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "game",
                "retro",
                "text",
                "remix",
                "glitch",
                "fork",
                "keyboard",
                "weird",
                "ui",
                "hard",
                "rave",
                "90",
                "80",
                "multipass",
                "arcade",
                "synthwave"
            ],
            "usePreview": 0,
            "username": "UrbanClubProfessional",
            "viewed": 630
        },
        "renderpass": [
            {
                "code": "// Hacked and cracked by Urban Club Professional!\n\n\nvec3 fxaa( vec3 color )\n{\n\t// FXAA implementation by mudlord (I think?)\n    vec3 luma = vec3(0.399, 0.687, 0.214);\n\tvec2 pp = 1.0 / R.xy;\n    float lumaNW = dot(texture(iChannel0, (F.xy + vec2(-1.0, -1.0)) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (F.xy + vec2(1.0, -1.0)) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (F.xy + vec2(-1.0, 1.0)) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (F.xy + vec2(1.0, 1.0)) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.35 * (2.0/9.0)), (2.0/228.0));\n\n    float rcpDirMin = 3.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(9.0, 9.0),\n              max(vec2(-9.0, -9.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.6 * (\n        texture(iChannel0, F.xy * pp + dir * (2.0 / 4.0 - 0.6)).xyz +\n        texture(iChannel0, F.xy * pp + dir * (3.0 / 3.0 - 0.6)).xyz);\n    vec3 rgbB = rgbA * 0.6 + 0.35 * (\n        texture(iChannel0, F.xy * pp + dir * -0.6).xyz +\n        texture(iChannel0, F.xy * pp + dir * 0.6).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        return rgbA;\n    } else {\n        return rgbB;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4( 0.0 );\n\t\n\tvec2 uv = F.xy / R.xy;\n    vec2 q = 1.0 - 2.0 * uv;\n    q.x *= R.x / R.y;\n\n#ifdef FORCED_RATIO\n    float bars = step( abs( q.y ) * g_forceRatio, R.x / R.y );\n    if ( bars < 0.5 ) return;\t\n#endif // FORCED_RATIO\n       \n    fragColor = texture( iChannel0, vec2( uv ) );\n\n#ifdef FXAA\t\n\tfragColor.rgb = fxaa( fragColor.rgb );\n#endif\n\n#ifdef NOISE\n    fragColor.rgb *= 0.9 + 0.3 * hash22( 2000.0 * ( F.xy / R.xy + fract( iTime ) ) ).x;\n#endif\n\n#ifdef FPS_COUNTER    \n    vec2 h = F.xy / R.xy;\n    h.x *= R.x / R.y;\n    fragColor.rgb += printInt( ( h -vec2( 0.0, 0.31 ) ) * 40.0, iFrameRate );\n#endif \n\n    // gamma\n\tfragColor.rgb = pow( fragColor.rgb, vec3( 0.5545 ) );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Hacked and cracked by Urban Club Professional!\n\n\n\n// switches, enable/disable effects:\n#define REFLECTIONS // needs good gpu\n#define VOLUMETRICS // needs good gpu\n#define FXAA\n#define GRADE\n#define NOISE\n#define FORCED_RATIO\n// debug:\n#define SHOW_UI\n// #define FPS_COUNTER\n// #define DEBUG_2D\n// #define DEBUG_CAMERA\n// #define CAM_STICKED\n\n\n#define ZERO (min(iFrame,0))\n#define R iResolution\n#define F gl_FragCoord\n// fix by adx\n#define texture(s,u) textureLod(s,u,0.)\n\nconst float g_forceRatio = 2.39;\nconst float PI = float(3.14159);\n\n// control loop\nconst float keysLeft[] = float[] ( \n\t 37.0,  // Arrow left\n\t 65.0,  // A\n\t 197.0  // a \n);\n\nconst float keysRight[] = float[] ( \n\t 39.0, // Arrow right\n\t 68.0, // D\n     100.0 // d\n);\n\nconst int ASCII_U\t\t= 85;\nconst int ASCII_SPACE\t= 32;\n\n// Game State\nconst float GS_SPLASH = 0.0;\nconst float GS_GAME   = 1.0;\n\n// Cell State\nstruct AppState\n{\n\tfloat stateID;\n    float isPressedLeft;\n    float isPressedRight;\n    float timeStarted;\n    \n    vec2 playerPos;\n    float score;\n    float timeFailed;\n    \n    float highscore;\n    float timeCollected;\n    float timeAccumulated;\n    float showUI;\n    \n    float paceScale;\n    float seed;\n    \n    float coin0Pos;\n    float coin0Taken;\n    float coin1Pos;\n    float coin1Taken;\n    float coin2Pos;\n    float coin2Taken;\n    float coin3Pos;\n    float coin3Taken;\n};\n\n   \n// https://www.shadertoy.com/view/4djSRW\nfloat hash11( float p )\n{\n\tvec3 p3  = fract( vec3( p ) * .1031 );\n    p3 += dot( p3, p3.yzx + 19.19 );\n    return fract( ( p3.x + p3.y) * p3.z );\n}\n\nvec2 hash21( float p )\n{\n\tvec3 p3 = fract( vec3( p ) * vec3( .1031, .1030, .0973 ) );\n\tp3 += dot( p3, p3.yzx + 19.19 );\n    return fract( ( p3.xx + p3.yz ) * p3.zy );\n}\n\nvec2 hash22( vec2 p )\n{\n\tvec3 p3 = fract( vec3( p.xyx ) * vec3( .1031, .1030, .0973 ) );\n    p3 += dot( p3, p3.yzx + 19.19 );\n    return fract( ( p3.xx + p3.yz ) * p3.zy );\n}\n\n// from Tiny Planet: Earth by morgan3d https://www.shadertoy.com/view/lt3XDM\nfloat hash( float n ) { return fract( sin( n ) * 1e4 ); }\nfloat noise( vec3 x ) { const vec3 step = vec3( 110, 241, 171 ); vec3 i = floor( x ); vec3 f = fract( x ); float n = dot( i, step ); vec3 u = f * f * ( 3.0 - 2.0 * f ); return mix( mix( mix( hash( n + dot( step, vec3( 0, 0, 0 ) ) ), hash( n + dot( step, vec3( 1, 0, 0 ) ) ), u.x ), mix( hash( n + dot( step, vec3( 0, 1, 0 ) ) ), hash( n + dot( step, vec3( 1, 1, 0 ) ) ), u.x ), u.y ), mix( mix( hash( n + dot( step, vec3( 0, 0, 1 ) ) ), hash( n + dot( step, vec3( 1, 0, 1 ) ) ), u.x ), mix( hash( n + dot( step, vec3( 0, 1, 1) ) ), hash( n + dot( step, vec3( 1, 1, 1 ) ) ), u.x ), u.y ), u.z ); }\n\n#define DEFINE_FBM(name, OCTAVES) float name( vec3 x ) { float v = 0.0; float a = 0.5; vec3 shift = vec3( 100 ); for ( int i = 0; i < OCTAVES; ++i ) { v += a * noise( x ); x = x * 2.0 + shift; a *= 0.5; } return v; }\nDEFINE_FBM(fbm3, 3)\n\n\nvec4 loadValue( sampler2D tex, int x, int y )\n{\n    return texelFetch( tex, ivec2( x, y ), 0 );\n}\n\nvoid loadState( sampler2D tex, out AppState s )\n{\n    vec4 data;\n\n\tdata = loadValue( tex, 0, 0 );\n    s.isPressedLeft\t\t= data.x;\n    s.isPressedRight\t= data.y;\n    s.stateID      \t\t= data.z;\n\ts.timeStarted \t\t= data.w;    \n    \n    data = loadValue( tex, 1, 0 );\n    s.playerPos\t\t\t= data.xy;\n    s.score\t\t\t\t= data.z;\n    s.timeFailed \t\t= data.w;\n    \n    data = loadValue( tex, 2, 0 );\n    s.highscore \t\t= data.x;\n    s.timeCollected\t\t= data.y;\n    s.timeAccumulated\t= data.z;\n    s.showUI\t\t\t= data.w;\n    \n    data = loadValue( tex, 3, 0 );\n    s.paceScale\t\t\t= data.x;\n    s.seed\t\t\t\t= data.y;\n   \n    data = loadValue( tex, 0, 1 );\n    s.coin0Pos = data.x;\n    s.coin0Taken = data.y;\n    s.coin1Pos = data.z;\n    s.coin1Taken = data.w;\n    data = loadValue( tex, 1, 1 );\n    s.coin2Pos = data.x;\n    s.coin2Taken = data.y;\n    s.coin3Pos = data.z;\n    s.coin3Taken = data.w;\n}\n\nvoid storeValue( vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord )\n{\n    fragCoord = floor( fragCoord );\n    fragColor = ( fragCoord.x == re.x && fragCoord.y == re.y ) ? va : fragColor;\n}\n\nAppState setStateStartGame( in AppState s, float iTime )\n{    \n    s.stateID \t\t\t=  GS_SPLASH;\n    s.timeStarted\t\t=  iTime;\n    s.playerPos\t\t\t=  vec2( 0.5, 0.0 );\n    s.score\t\t\t\t=  0.0;\n    s.timeFailed\t\t= -1.0;\n    s.timeCollected\t\t= -1.0;\n    s.timeAccumulated\t=  0.0;\n    s.showUI\t\t\t=  1.0;\n\n    s.coin0Pos\t\t= 0.0;\n    s.coin0Taken\t= 0.0;\n    s.coin1Pos\t\t= 0.0;        \n    s.coin1Taken\t= 0.0;\n    s.coin2Pos\t\t= 0.0;        \n    s.coin2Taken\t= 0.0;\n    s.coin3Pos\t\t= 0.0;        \n    s.coin3Taken\t= 0.0;    \n    \n    return s;\n}\n\nvec4 saveState( in AppState s, in vec2 fragCoord, int iFrame, float iTime )\n{\n    if (iFrame <= 0)\n    {\n        s.seed = fbm3( iDate.yzw );\n \t\ts = setStateStartGame( s, iTime );\n\t}\n    \n    vec4 ret = vec4( 0.);\n\tstoreValue( vec2( 0., 0. ), vec4( s.isPressedLeft,\t\ts.isPressedRight,\ts.stateID,\t\t\ts.timeStarted),\tret, fragCoord );    \n\tstoreValue( vec2( 1., 0. ), vec4( s.playerPos,\t\t\t\t\t\t\t\ts.score,\t\t\ts.timeFailed),\tret, fragCoord );\n\tstoreValue( vec2( 2., 0. ), vec4( s.highscore,\t\t\ts.timeCollected,\ts.timeAccumulated,\ts.showUI),\t\tret, fragCoord );\n    storeValue( vec2( 3., 0. ), vec4( s.paceScale,\t\t\ts.seed,\t\t\t\t0.0,\t\t\t\t0.0),\t\t\tret, fragCoord );\n    \n    storeValue( vec2( 0., 1. ), vec4( s.coin0Pos, s.coin0Taken, s.coin1Pos, s.coin1Taken ), ret, fragCoord );\n    storeValue( vec2( 1., 1. ), vec4( s.coin2Pos, s.coin2Taken, s.coin3Pos, s.coin3Taken ), ret, fragCoord );\n    return ret;\n}\n\n// math\n\nfloat saturate( float x ) { return clamp( x, 0., 1. ); }\n\nvec3 saturate( vec3 x ) { return clamp( x, vec3( 0. ), vec3( 1. ) ); }\n\nmat2 rot( float a ) { float s = sin( a ); float c = cos( a ); return mat2( c, -s, s, c ); }\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize( ta - ro );\n\tvec3 cp = vec3( sin( cr ), cos( cr ), 0.0 );\n\tvec3 cu = normalize( cross( cw, cp ) );\n\tvec3 cv =          ( cross( cu, cw ) );\n    return mat3( cu, cv, cw );\n}\n\nfloat impulse( float k, float x ) {\n    float h = k * x;\n    return h * exp( 1.0 - h );\n}\n\n//-----------------------------------------------------------------\n// Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n\nfloat sampleDigit( const in float n, const in vec2 vUV )\n{\t\t\n\tif ( vUV.x  < 0.0 ) return 0.0;\n\tif ( vUV.y  < 0.0 ) return 0.0;\n\tif ( vUV.x >= 1.0 ) return 0.0;\n\tif ( vUV.y >= 1.0 ) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if( n < 0.5 ) data = 7.0 + 5.0 * 16.0 + 5.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 1.5 ) data = 2.0 + 2.0 * 16.0 + 2.0 * 256.0 + 2.0 * 4096.0 + 2.0 * 65536.0;\n\telse if( n < 2.5 ) data = 7.0 + 1.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 3.5 ) data = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 4.5 ) data = 4.0 + 7.0 * 16.0 + 5.0 * 256.0 + 1.0 * 4096.0 + 1.0 * 65536.0;\n\telse if( n < 5.5 ) data = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 6.5 ) data = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 7.5 ) data = 4.0 + 4.0 * 16.0 + 4.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 8.5 ) data = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 9.5 ) data = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t\n\tvec2 vPixel = floor( vUV * vec2( 4.0, 5.0 ) );\n\tfloat fIndex = vPixel.x + ( vPixel.y * 4.0 );\n\t\n\treturn mod( floor( data / pow( 2.0, fIndex ) ), 2.0 );\n}\n\nfloat printInt( const in vec2 uv, const in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0 + ceil( log2( value ) / log2( 10.0 ) );\n\tfloat digitID = floor( uv.x );\n\tif( digitID > 0.0 && digitID < maxDigits )\n\t{\n        float digitVa = mod( floor( value / pow( 10.0, maxDigits - 1.0 - digitID ) ), 10.0 );\n        res = sampleDigit( digitVa, vec2( fract( uv.x ), uv.y ) );\n\t}\n\n\treturn res;\t\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Hacked and cracked by Urban Club Professional!\n\n\nAppState updateGame( AppState s, float isDemo )\n{\n    if ( isDemo > 0.0 )\n    {\n        s.timeAccumulated += 4.5 * iTimeDelta;\n    \ts.playerPos.y = 22.5 * s.timeAccumulated;\n    }\n    else\n    {\n        float playerCellID = floor( s.playerPos.y );\n        s.paceScale = saturate( ( playerCellID - 50.0) / 500.0);\n        float timeMultiplier = mix( 0.75, 2.0, pow( s.paceScale, 1.0 ) );\n\n        s.timeAccumulated += timeMultiplier * iTimeDelta;\n        s.playerPos.y = 5.0 * s.timeAccumulated;\n    }    \n    \n    float playerCellID = floor( s.playerPos.y );\n\n    if ( isDemo > 0.0 )\n    {           \n        float cellOffset = 1.0;\n        float nextPlayerCellID = playerCellID + cellOffset;\n\n        float nextCellCoinRND = hash11( nextPlayerCellID + s.seed ); // skip rnd obstacle every second cell to make room for driving\n        nextCellCoinRND *= mix( 1.0, -1.0, step( mod( nextPlayerCellID, 4.0 ), 1.5 ) ); // gaps in coin placing: 2 gaps, 2 coins\n        nextCellCoinRND = mix( nextCellCoinRND, -1.0, step( nextPlayerCellID, 5.0 ) ); // head start\n        float nextCellCoinCol = floor( 3.0 * nextCellCoinRND );\n\n        // OBSTACLE\n        float nextCellObsRND = hash11( 100.0 * nextPlayerCellID + s.seed );\n        nextCellObsRND *= mix( 1.0, -1.0, step( mod( nextPlayerCellID, 3.0 ), 1.5 ) );\n        nextCellObsRND = mix( nextCellObsRND, -1.0, step( nextPlayerCellID, 7.0 ) ); // head start\n        float nextCellObsCol = floor( 3.0 * nextCellObsRND );\n        \n        float inputObs = 0.0;                \n        if ( nextCellObsCol > -0.5 )\n        {\n            nextCellCoinCol -= 0.5; // pos fix\n        \tfloat toObs = nextCellObsCol - s.playerPos.x;\n        \n            if ( nextCellObsCol == 1.0 )\n                inputObs = hash11( nextPlayerCellID + s.seed );\n            \n            if ( nextCellObsCol < 1.0 )\n                inputObs = 1.0;\n\n            if ( nextCellObsCol > 1.0 )\n                inputObs = -1.0;\n        }\n        \n        \n        float inputCoin = 0.0;\n        if ( nextCellCoinCol > -0.5 )\n        {               \n            nextCellCoinCol -= 0.5; // pos fix\n            float toCoin = nextCellCoinCol - s.playerPos.x;\n            \n\t\t\tinputCoin = sign(toCoin) * saturate( abs( toCoin ) );\n        }\n\n        float inputDir = inputCoin + 5.0 * inputObs;\n        inputDir = sign( inputDir ) * 4.0 * saturate( abs( inputDir ) );\n        \n        s.isPressedLeft  = step( 0.5, -inputDir );\n        s.isPressedRight = step( 0.5,  inputDir );\n    }\n\n    float speed = mix( 0.1, 0.15, isDemo );\n    s.playerPos.x -= speed * s.isPressedLeft; \n    s.playerPos.x += speed * s.isPressedRight; \n\n    s.playerPos.x = clamp( s.playerPos.x, -0.5, 1.5 );\n\n    if ( playerCellID != s.coin0Pos ) \n    {\n        s.coin3Pos \t = s.coin2Pos;\n        s.coin3Taken = s.coin2Taken;\n\n        s.coin2Pos \t = s.coin1Pos;\n        s.coin2Taken = s.coin1Taken;\n\n        s.coin1Pos \t = s.coin0Pos;\n        s.coin1Taken = s.coin0Taken;\n\n        s.coin0Pos = playerCellID;\n        s.coin0Taken = 0.0;\n    }\n \n    // COIN start\n    float cellCoinRND = hash11( playerCellID + s.seed ); // skip rnd obstacle every second cell to make room for driving\n    cellCoinRND *= mix( 1.0, -1.0, step( mod( playerCellID, 4.0 ), 1.5 ) ); // gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -1.0, step( playerCellID, 5.0 ) ); // head start\n    float cellCoinCol = floor( 3.0 * cellCoinRND );\n\n    vec2 coinPos = -vec2( 0.0, playerCellID )\t// cell pos\n        +vec2( 0.5, -0.5 )\t// move to cell center\n        -vec2( cellCoinCol, 0.0 ); // move to column\n\n    if ( cellCoinRND >= 0.0 )\n    {        \n        float distCoinPlayer = length( coinPos + s.playerPos );\n\n        if ( distCoinPlayer < 0.5 && s.coin0Taken < 0.5 )\n        {\n            if ( isDemo < 1.0 )\n            \ts.score++;\n            \n            s.coin0Taken = 1.0;\n            s.timeCollected = iTime;\n        }\n    }\n    // COIN end\n\n    // OBSTACLE start\n    float cellObsRND = hash11( 100.0 * playerCellID + s.seed );\n    cellObsRND *= mix( 1.0, -1.0, step( mod( playerCellID, 3.0 ), 1.5 ) );\n    cellObsRND = mix( cellObsRND, -1.0, step( playerCellID, 7.0 ) ); // head start\n    float cellObsCol = floor( 3.0 * cellObsRND );\n\n    if ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {   \n        vec2 obstaclePos = -vec2( 0.0, playerCellID )\t// cell pos\n            +vec2( 0.5, -0.25 )\t// move to cell center\n            -vec2(cellObsCol, 0.0 ); // move to column\n\n        float distObstaclePlayer = length( obstaclePos + s.playerPos );\n\n        if ( distObstaclePlayer < 0.5 && isDemo < 1.0 )\n        {\n            s.timeFailed = iTime;\n            s.timeCollected = -1.0;\n            s.highscore = max( s.highscore, s.score );\n        }\n    }\n    // OBSTACLE end        \n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    if ( fragCoord.x >= 8. || fragCoord.y >= 8. ) \n    {        \n        discard;    \n    }\n    \n    AppState s;\n    loadState( iChannel0, s );\n        \n    s.showUI = mod( s.showUI + texelFetch( iChannel1, ivec2( ASCII_U, 1 ), 0 ).x, 2.0 );\n    float isSpacePressed = texelFetch( iChannel1, ivec2( ASCII_SPACE, 1 ), 0 ).x;\n   \n  \t// read keys that people usually press\n    // https://www.shadertoy.com/view/lsXGzf\n    float keyLeft = 0.0;\n    for ( int i = 0; i < keysLeft.length(); ++i )\n        keyLeft = max( keyLeft, texelFetch( iChannel1, ivec2( keysLeft[i], 0 ), 0 ).x );\n    \n\ts.isPressedLeft = keyLeft;    \n            \n    float keyRight = 0.0;\n    for ( int i = 0; i < keysRight.length(); ++i )\n        keyRight = max( keyRight, texelFetch( iChannel1, ivec2( keysRight[i], 0 ), 0 ).x );\n    \n    s.isPressedRight = keyRight;    \n       \n    if ( s.stateID == GS_SPLASH ) // splash\n    {                             \n        if ( isSpacePressed > 0.5 || s.isPressedLeft > 0.5 || s.isPressedRight > 0.5 )\n        {\n            s = setStateStartGame( s, iTime );\n            s.stateID = GS_GAME;            \n            s.timeStarted = iTime;\n            s.timeAccumulated = 0.0;\n            s.seed += iTime;\n        }\n        else\n        {\n            s = updateGame( s, 1.0 );\n        }        \n    }\n    else if ( s.stateID == GS_GAME ) // game\n    {\n        if ( s.timeFailed > s.timeStarted )\n        {   \n            if ( iTime > s.timeFailed + 1.0 \n                && ( s.isPressedLeft > 0.5 || s.isPressedRight > 0.5 ) )\n            {            \n            \ts.timeStarted = iTime;\n                s.timeFailed = -1.0;\n            }\n                        \n            if ( iTime > s.timeFailed + 5.0 )\n            {                \n                s = setStateStartGame( s, iTime );\n                s.stateID = GS_SPLASH;\n            }\n            \n            s.isPressedLeft = 0.0;\n            s.isPressedRight = 0.0;\n        }\n        else\n        {\n            s = updateGame( s, 0.0 );\n        }\n    }\n  \n    fragColor = saveState( s, fragCoord, iFrame, iTime );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Hacked and cracked by Urban Club Professional!\n\n\n\nAppState g_S;\n\nfloat g_glowCoin = 2e10;\nfloat g_glowCoinRefl = 2e10;\nfloat g_glowEnemy = 2e10;\nfloat g_glowEnemyRefl = 2e10;\nfloat g_glowPlayer = 2e10;\nfloat g_glowPlayerRefl = 2e10;\nfloat g_glowPlayerFront = 2e10;\nfloat g_glowPlayerLights = 2e10;\nfloat g_cameraMode = 0.0;\n\nconst float GRID_SIZE = 0.5;\nconst float GRID_LINE_SIZE = 1.25;\n\nconst float GRID_CAR_SIZE = 0.5;\nconst float GRID_CAR_LINE_SIZE = 1.5;\n\nconst vec3 GRID_COLOR_1 = vec3(0.30, 0.03, 0.00);\nconst vec3 GRID_COLOR_2 = vec3(3.600, 22.20, 2.40)/555.;\n\nconst vec3 SUN_DIRECTION = vec3(0.6, 0.035, 0.0);\nconst vec3 SKY_COLOR_1 = vec3(59., 76., 43.)/355.;\nconst vec3 SKY_COLOR_2 = vec3(0.30,0.03,0.00);\n\nconst vec3 SUN_COLOR_1 = vec3(0.4, 0.2, 0.4) * 0.6;\nconst vec3 SUN_COLOR_2 = vec3(0.2, 0.2, 0.2) * 0.6;\n\nconst vec3 CAR_COLOR_1 = vec3(0.6, 0.2, 0.6) * 0.0;\nconst vec3 CAR_COLOR_2 = vec3(0.0, 0.2, 0.2) * 2.5;\n\nconst vec3 CAR_PLAYER_COLOR_1 = vec3(0.6, 0.6, 0.2) * 0.2;\nconst vec3 CAR_PLAYER_COLOR_2 = vec3(0.6, 0.6, 0.2) * 2.5;\n\nconst vec3 FOG_COLOR = vec3(293.0, 223.00, 134.0)/555.;\n\n\nstruct sHit {\n    float t;\n    float m;\n    vec3 lPos;\n};\n    \nsHit createHit( float t, float m, vec3 lPos )\n{\n    sHit h;\n    h.t = t;\n    h.m = m;\n    h.lPos = lPos;\n    return h;\n}\n\nvoid drawCoin( inout vec3 color, vec2 p, vec2 coinPos )\n{  \n    float sCoin = length(\n        p\n        -vec2( 0.0, coinPos.y )\t// cell pos\n        +vec2( 0.5, -0.5 )\t\t// move to cell center\n        -vec2( coinPos.x, 0.0 ) // move to column\n    ) - 0.25; \t\t\t\t\t// radius of coin\n\n    color.rgb = mix( vec3( 1.0, 1.0, 0.0 ), color.rgb, smoothstep( 0.0, 0.1, sCoin ) );\n}\n\nvoid drawGameFlat( inout vec4 color, vec2 p, AppState s )\n{\n    // game\n\tvec2 p0 = p;    \n    // float cameraAnim = smoothstep(-0.5, 0.5, sin(iTime) );\n    float cameraAnim = 0.0;\n\tp0 *= mix( 5.0, 10.0, cameraAnim );\t\t// scale field of view\n    p0.x += 0.25;\t\t\t\t\t\t\t// fix track centering\n    p0.y += mix( 2.0, 8.0, cameraAnim );\t// move camera pos\n    p0.y += s.playerPos.y;\n    \n    float playerCellID = floor( s.playerPos.y );\n    float sPlayer = length( p0 - s.playerPos ) - 0.25;\n           \n    vec2 p1 = p0;\n    p1.y += 2.0 * s.playerPos.y;\n    color.rgb = mix( vec3( 1.0 ), color.rgb, smoothstep( 1.5, 1.75, abs( p1.x - 0.5 ) ) );\n    color.rgb = mix( texture( iChannel2, fract( p1 ) ).rgb, color.rgb, 0.5 );\n       \n\t// COIN start\n    float cellID = floor( p0.y );\n    float cellCoinRND = hash11( cellID + g_S.seed );\t\t\t\t\t// skip rnd obstacle every second cell to make room for driving    \n    cellCoinRND *= mix( 2.0, -2.0, step( mod( cellID, 5.0 ), 2.5 ) );\t// gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -2.0, step (cellID, 6.0 ) );\t\t// head start\n    float cellCoinCol = floor( 4.0 * cellCoinRND );\n       \n    if ( cellCoinRND >= 0.0 )\n    {\n        if ( cellID > playerCellID )\n           \tdrawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n        \n        if ( cellID == playerCellID && s.coin0Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n        \n        if ( cellID == playerCellID - 1.0 && s.coin1Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n        \n        if ( cellID == playerCellID - 2.0 && s.coin2Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n       \n        if ( cellID == playerCellID - 3.0 && s.coin3Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n    }    \n// COIN end\n\n// OBSTACLE start\n    float cellObsRND = hash11( 100.0 * cellID + g_S.seed );\t\t// skip rnd obstacle every second cell to make room for driving\n    cellObsRND *= mix( 2.0, -2.0, step( mod( cellID, 4.0 ), 2.5 ) );\n    cellObsRND = mix( cellObsRND, -2.0, step( cellID, 8.0) );\t// head start\n    float cellObsCol = floor( 4.0 * cellObsRND );\n    \n\tif ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {        \n    \tfloat sObstacle = length(\n            p0\n            -vec2( 0.0, cellID )\t\t// cell pos\n            +vec2( 0.5, -0.5 )\t\t\t// move to cell center\n            -vec2( cellObsCol, 0.0 )\t// move to column\n        ) - 0.25;\t\t\t\t\t\t// radius of coin\n        \n    \tcolor.rgb = mix( vec3( 1.0, 0.0, 0.0 ), color.rgb, smoothstep( 0.0, 0.1, sObstacle ) );\n        \n        vec2 obstaclePos = -vec2( 0.0, cellID )\t\t\t// cell pos\n            \t\t\t\t+vec2( 0.5, -0.5 )\t\t\t// move to cell center\n            \t\t\t\t-vec2( cellObsCol, 0.0 );\t// move to column\n\n        float distObstaclePlayer = length( obstaclePos + s.playerPos );\n        \n        if ( distObstaclePlayer < 0.5 ) \n        {\n            color.rgb += vec3( 0.5 );\n        }\n    }\n    \n    color.rgb = mix( vec3( 0.0, 1.0, 0.0 ), color.rgb, smoothstep( 0.0, 0.1, sPlayer ) );\n\n// OBSTACLE end        \n\n}\n\nfloat circle( vec2 p, float r )\n{\n    return ( length( p / r ) - 1. ) * r;\n}\n\nvoid opRotate( inout vec2 p, float a ) \n{\n    p = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn ( d1.x < d2.x ) ? d1 : d2;\n}\n\nsHit opUS( sHit d1, sHit d2 )\n{\n    if ( d1.t < d2.t )\n        return d1;\n    else \n        return d2;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n   \tp = vec3( p.z, p.x, -p.y ); // Coord fix\n    // n must be normalized\n          \n    vec3 p0 = vec3(p.x, p.y, p.z);\n\n    float fgProf = 0.3 * smoothstep( 2.5, 3.0, abs( p0.y ) );\n    float bgProf = 2.0 * smoothstep( 4.5, 5.5, abs( p0.y ) );\n    float fg = 0.15 * p.y * p.y * fgProf + fgProf * clamp( texture( iChannel2, p0.xy / 10. ).r, 0.0, 1.0 );\n    float bg = 0.2 * fgProf + bgProf * clamp( texture( iChannel2, p0.xy / 50.).r, 0.0, 2.0 );\n    float displace = 1.5 * fg + 3.5 * bg;\n    \n    float sGround = dot(\n        vec3( p.x, p.y, max( p.z + displace, p.z ) ),\n        n.xyz )\n        + n.w;\n    \n    sGround *= 0.5;\n    \n  \treturn sGround;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\treturn length( pa - ba * h ) - r;\n}\n\nfloat opUnion( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat opIntersect( float a, float b )\n{\n    return max( a, b );\n}\n\nfloat opSubstract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat opSubstractChamfer( float a, float b, float r ) \n{\n    return max( max( a, -b ), ( a + r - b ) * 0.70711 );\n}\n\nfloat plane( vec3 p, vec4 plane ) \n{\n    return dot( p, plane.xyz ) + plane.w;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat cylinder( vec3 p, float r, float height ) \n{\n    float d = length( p.xz ) - r;\n    d = max( d, abs( p.y ) - height );\n    return d;\n}\n\nfloat sphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\n\nvec2 sdColumn( vec3 p, float r, float id )\n{\n    return vec2( ( ( abs( p.x ) + abs( p.y ) ) - r ) / sqrt( 2.0 ), id );\n}\n\nfloat sdCoin( vec3 p, float id )\n{       \n    float sCyl = cylinder( p.yzx, 0.1, 0.02 );    \n\n    if ( id == 2.0 )\n        g_glowCoin = min( g_glowCoin, sCyl );\n    \n    if ( id == 12.0 )\n    \tg_glowCoinRefl = min( g_glowCoin, sCyl );\n    \n    return sCyl;\n}\n\n// From \"[SH16B] Speed Drive 80\" by knarkowicz. https://shadertoy.com/view/4ldGz4\nfloat car( vec3 p, float id )\n{        \n    p *= 6.5;\n    \n    p.x = -p.x;     \n    p.y -= 0.4;\n    \n    float a = box( p, vec3( 5.2, 1.0, 2.8 ) );   \n    \n    vec3 t = p + vec3( -7.0, 0.0, 0.0 );\n    opRotate( t.yx, 0.3 );\n    float b = plane( t, vec4( 0.0, -2.0, 0.0, 0.0 ) );\n    \n    t = p + vec3( -6.0, 0.0, 0.0 );\n    opRotate( t.yx, -0.5 );\n    float c = plane( t, vec4( 0.0, 2.0, 0.0, 0.0 ) );    \n    \n    t = p + vec3( 3.0, -0.3, 0.0 );\n    opRotate( t.yx, -0.5 );\n    float d = plane( t, vec4( 0.0, -2.0, 0.0, 0.0 ) );   \n    \n    t = p + vec3( 3.0, -0.4, 0.0 );\n    opRotate( t.yx, -0.06 );\n    float e = plane( t, vec4( 0.0, -2.0, 0.0, 0.0 ) );       \n    \n    t = p + vec3( 3.0, 2.0, 0.0 );\n    opRotate( t.yx, 0.3 );\n    float f = plane( t, vec4( 0.0, 2.0, 0.0, 0.0 ) );     \n        \n    if ( id == 2.0 )\n    {\n        float bloomF = box( t + vec3( -0.5, 0.7, 0.0 ), vec3( 0.1, 0.3, 1.5 ) );\n        t.z = abs( t.z );\n        t.z -= 1.5;       \n        float bloomB = box( t + vec3( -4.4, -0.2, 0.0 ), vec3( 0.2, 0.4, 0.2 ) );\n    \tg_glowPlayer = min( g_glowPlayer, 1.0 / 5.5 * min( bloomF, bloomB ) );\n    }\n    \n    if ( id == 3.0 )\n        g_glowEnemy = min( g_glowEnemy, 1.0 / 5.5 * box( t + vec3( -2.0, 0.7, 0.0 ), vec3( 3.0, 1.0, 1.0 ) ) );\n\n    t = p + vec3( 1.0, -0.6, 0.0 );\n    opRotate( t.yx, -0.4 );\n    float frontWindow = box( t, vec3( 0.6, 0.05, 1.6 ) );\n    \n    t = p + vec3( -2.5, -0.7, 0.0 );\n    opRotate( t.yx, 0.2 );\n    float backWindow = box( t, vec3( 1.0, 0.05, 1.6 ) );\n    \n    float body = opSubstract( a, opUnion( opUnion( opUnion( b, c ), opIntersect( d, e ) ), f ) );\n    \n    t = p;\n    t.z = -abs( t.z );\n    t += vec3( 0.0, -0.8, 1.2 );\n    opRotate( t.yz, -0.9 );\n    float sideCutPlanes = plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );      \n    \n    body = opSubstractChamfer( body, opUnion( backWindow, frontWindow ), 0.1 );\n    body = opSubstractChamfer( body, sideCutPlanes, 0.05 );\n    \n    p.x += 0.1;\n    p.xz = abs( p.xz );\n    t = p.xzy - vec3( 2.4, 1.5, -0.65 );\n    float wheel = cylinder( t, 0.7, 1.0 );\n    body = opSubstract( body, wheel );\n    t.y -= .1;\n    wheel = opSubstract( cylinder( t, 0.6, 0.3 ), sphere( t + vec3( 0.0, -0.45, 0.0 ), 0.45 ) );\n    \n    body = opUnion( body, wheel );\n    \n    body /= 5.5;\n    \n    return body;\n}\n\nfloat carFront( vec3 p, float id )\n{        \n    // front lights\n    p.z = abs( p.z );\n    p.z -= 0.2;\n    float front = cylinder( p.zxy + vec3( -0.06, -0.77, -0.02 ), 0.05, 0.01 );\n    \n    if ( id == 1.5 )\n        g_glowPlayerFront = min( g_glowPlayerFront, front );\n       \n    return front;\n}\n\nfloat carLights( vec3 p, float id )\n{        \n    // back lights\n    p.z = abs( p.z );\n    p.z -= 0.2;\n    float back = box( p + vec3( 0.75, -0.09, 0.0 ), vec3( 0.02, 0.02, 0.075 ) );\n    \n    if ( id == 1.5 )\n    \tg_glowPlayerLights = min( g_glowPlayerLights, back );\n       \n    return back;\n}\n\n\nfloat carRefl( vec3 p, float id )\n{        \n    float body = box( p + vec3( 0.0, -0.07, 0.0 ), vec3( 0.6, 0.02, 0.2) );\n    body = min( body, box( p + vec3( 0.2, -0.1, 0.0 ), vec3( 0.4, 0.02, 0.2 ) ) );\n    \n    // back lights\n    p.z = abs( p.z );\n    p.z -= 0.2;\n    float bloom = box( p + vec3( 0.75, -0.09, 0.0 ), vec3( 0.02, 0.02, 0.075 ) );    \n    \n    bloom = min( bloom, body );\n    \n    if ( id == 1.5 )\n    \tg_glowPlayerRefl = min( g_glowPlayerRefl, bloom );\n    \n    if ( id == 3.5 )\n        g_glowEnemyRefl = min( g_glowEnemyRefl, bloom );\n       \n    return body;\n}\n\nvec2 getBent()\n{\n    float bentSide\t= sin( g_S.timeAccumulated / PI );\n    float bentUp\t= ( ( cos( 0.25 * g_S.timeAccumulated / PI ) * 0.5 ) + 0.5 ) * 1.5;\n    return vec2( bentSide, bentUp );\n}\n\nsHit map( in vec3 pos )\n{\n    sHit sRes = createHit( 1e10, 0.0, pos );\n\n\t// player, in place in fact\n    vec2 bent = getBent();\n    \n    // game\n    vec3 p0 = pos;    \n    // bending    \n    p0.x -= 1.4 * sin( 0.06 * p0.z * PI ) * bent.x;\n    p0.y += 1.4 * sin( 0.06 * p0.z * PI ) * bent.y;\n   \n    vec3 pPlayer = pos -vec3( g_S.playerPos.x, 0.25, 0.0 );\n    \n    pPlayer.xz *= rot(  0.3 * bent.x );\n    pPlayer.yz *= rot( -0.3 * bent.y );\n    // sRes = opUS( sRes, CreateHit( sdBox( pPlayer, vec3(0.5, 0.2, 0.5) ) - 0.01, 1.0, pPlayer) ); // debug collider\n    \n\tfloat rotY = -.3 * g_S.isPressedLeft + .3 * g_S.isPressedRight;\n    float rotX = -.2 * g_S.isPressedLeft + .2 * g_S.isPressedRight;    \n    pPlayer.xz *= rot( -0.02 * PI * bent.y + rotY -0.6 * PI );\n    pPlayer.yz *= rot( -0.02 * PI * bent.x + rotX );\n    // pPlayer.yz *= rot( -10.0*iTime ); // mothman\n    pPlayer.y += 0.05;    \n    sRes = opUS( sRes, createHit( car( pPlayer, 1.0 ), 1.0, pPlayer ) );\n\tsRes = opUS( sRes, createHit( carLights( pPlayer, 1.5 ), 1.5, pPlayer ) );\n    sRes = opUS( sRes, createHit( carFront( pPlayer, 1.6 ), 1.6, pPlayer ) );\n    \n    vec3 pEnv = p0;\n    pEnv.z += 3.0 * g_S.playerPos.y;\n    pEnv.x -= 0.6;\n    sRes = opUS( sRes, createHit( sdPlane( pEnv, vec4( 0, 0, -2, 0 ) ), 0.0, vec3( pEnv.x, 0.0, pEnv.z ) ) );\n    \n    p0.z *= 0.6;\n    p0.z += g_S.playerPos.y;\n    \n    vec3 p0Mod = p0;\n    p0Mod.z = mod( p0.z + 0.6, 2.0 ) - 0.6;\n                \n    float playerCellID = floor( g_S.playerPos.y );\n   \n    // COIN start\n    float cellID = floor( p0.z + 0.5 );\n    \n    float cellCoinRND = hash11( cellID + g_S.seed ); // skip rnd obstacle every second cell to make room for driving    \n    cellCoinRND *= mix( 1.0, -1.0, step( mod( cellID, 4.0 ), 1.5 ) ); // gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -1.0, step( cellID, 5.0 ) ); // head start\n    float cellCoinCol = floor( 3.0 * cellCoinRND );\n    \n    if (cellCoinRND >= 0.0)\n    {\n        vec3 pCoin = p0Mod; \n        float bounce = 0.3 * abs( sin( 5.0 * iTime + cellID ) );\n        vec3 coinOffset = vec3( -0.5  + cellCoinCol, 0.4 + bounce, 0.0 );\n        pCoin -= coinOffset;\n        pCoin.z *= 2.0;\n        pCoin.xz *= rot( 10.0 * iTime );\n                \n        if ( cellID > playerCellID )\n            sRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID && g_S.coin0Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 1.0 && g_S.coin1Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 2.0 && g_S.coin2Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 3.0 && g_S.coin3Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n    }    \n       \n    float cellObsRND = hash11( 100.0 * cellID + g_S.seed ); // skip rnd obstacle every second cell to make room for driving\n    cellObsRND *= mix( 1.0, -1.0, step( mod( cellID, 3.0 ), 1.5 ) );\n    cellObsRND = mix( cellObsRND, -1.0, step( cellID, 7.0 ) ); // head start\n    float cellObsCol = floor( 3.0 * cellObsRND );\n\n    if ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {            \n        vec3 obstacleOffset = vec3(\n            -0.5 + cellObsCol,  \n             0.2,\n             0.0\n        );\n\n        // sRes = opUS( sRes, CreateHit( sdBox( p0Mod -obstacleOffset, vec3(0.5, 0.1, 0.5) ) - 0.01, 3.0, p0Mod ) ); // debug colider\n        p0Mod -= obstacleOffset;\n        p0Mod.z *= 2.0;\n        p0Mod.xz *= rot( -0.5 * PI );\n        sRes = opUS( sRes, createHit( car( p0Mod, 3.0 ), 3.0, p0Mod ) );\n        sRes = opUS( sRes, createHit( carLights( p0Mod, 3.5 ), 3.5, p0Mod ) );\n        sRes = opUS( sRes, createHit( carFront( p0Mod, 3.6 ), 3.6, p0Mod) );\n    }\n\n    return sRes;\n}\n\nsHit mapRefl( in vec3 pos )\n{\n    sHit sRes = createHit( 1e10, -1.0, pos );\n\n    vec2 bent = getBent();\n    vec3 p0 = pos;    \n    p0.x -= 1.5 * sin( 0.05 * p0.z * PI) * bent.x;\n    p0.y += 1.5 * sin( 0.05 * p0.z * PI) * bent.y;\n   \n    float rotY = -.2 * g_S.isPressedLeft + .2 * g_S.isPressedRight;\n    float rotX = -.1 * g_S.isPressedLeft + .1 * g_S.isPressedRight;    \n    vec3 pPlayer = pos - vec3( g_S.playerPos.x, 0.25, 0.0 );\n    pPlayer.xz *= rot(  0.2 * bent.x );\n    pPlayer.yz *= rot( -0.2 * bent.y );\n    pPlayer.xz *= rot( -0.01 * PI * bent.y + rotY -0.5 * PI);\n    pPlayer.yz *= rot( -0.01 * PI * bent.x + rotX);\n    pPlayer.y += 0.05;\n\tsRes = opUS( sRes, createHit( carRefl( pPlayer, 1.5 ), 1.5, pPlayer) );\n\n    p0.z *= 0.5;\n    p0.z += g_S.playerPos.y;      \n    \n    vec3 p0Mod = p0;\n    p0Mod.z = mod( p0.z + 0.5, 1.0 ) -0.5;\n                \n    float playerCellID = floor( g_S.playerPos.y );\n   \n    // COIN start\n    float cellID = floor( p0.z + 0.5 );\n    \n    float cellCoinRND = hash11( cellID + g_S.seed ); // skip rnd obstacle every second cell to make room for driving    \n    cellCoinRND *= mix( 1.0, -1.0, step( mod( cellID, 4.0 ), 1.5 ) ); // gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -1.0, step( cellID, 5.0 ) ); // head start\n    float cellCoinCol = floor( 3.0 * cellCoinRND );\n    \n    if ( cellCoinRND >= 0.0 )\n    {\n        vec3 pCoin = p0Mod; \n        float bounce = 0.3 * abs( sin( 5.0 * iTime + cellID ) );\n        vec3 coinOffset = vec3( -0.5 + cellCoinCol, 0.4 + bounce, 0.0 );\n        pCoin -= coinOffset;\n        pCoin.z *= 2.0;\n        pCoin.xz *= rot( 10.0 * iTime );\n                \n        if ( cellID > playerCellID )\n            sRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID && g_S.coin0Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 1.0 && g_S.coin1Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 2.0 && g_S.coin2Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 3.0 && g_S.coin3Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n    }    \n       \n    float cellObsRND = hash11( 100.0 * cellID + g_S.seed ); // skip rnd obstacle every second cell to make room for driving\n    cellObsRND *= mix( 1.0, -1.0, step( mod( cellID, 3.0 ), 1.5 ) );\n    cellObsRND = mix( cellObsRND, -1.0, step( cellID, 7.0 ) ); // head start\n    float cellObsCol = floor( 3.0 * cellObsRND );\n\n    if ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {            \n        vec3 obstacleOffset = vec3(\n            -0.5 + cellObsCol,  \n             0.2,\n             0.0\n        );\n\n        p0Mod -= obstacleOffset;\n        p0Mod.z *= 2.0;\n        p0Mod.xz *= rot( -0.5 * PI );\n        sRes = opUS( sRes, createHit( carRefl( p0Mod, 3.5), 3.5, p0Mod ) );\n    }\n\n    return sRes;\n}\n\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs( m ) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nsHit castRay( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    sHit sRes = createHit( -1.0, -1.0, rd );\n\n    // raymarch primitives   \n    vec2 tb = iBox( ro - vec3( 0.0, 0.0, 25.0 ), rd, vec3( 8.0, 5.0, 55.0 ) );\n    \n    if( tb.x < tb.y && tb.y > 0.0 && tb.x < tmax )\n    {\n        tmin = max( tb.x, tmin );\n        tmax = min( tb.y, tmax );       \n\n        float t = tmin;\n        for( int i = ZERO; i < 228 && t < tmax; i++ )\n        {\n            sHit h = map( ro + rd * t );\n            if( abs( h.t ) < ( 0.002 * t ) )\n            { \n                // res = vec2(t,h.y); \n                sRes = createHit( t, h.m, h.lPos ); \n                break;\n            }\n            t += h.t;\n        }\n    }\n    \n    return sRes;\n}\n\nsHit castRayRefl( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    sHit sRes = createHit( -1.0, -1.0, rd );\n\n    // raymarch primitives   \n    vec2 tb = iBox( ro - vec3( 0.0, 0.0, 6.0 ), rd, vec3( 5.0, 5.0, 35.0 ) );\n    \n    if( tb.x < tb.y && tb.y > 0.0 && tb.x < tmax )\n    {\n        tmin = max( tb.x, tmin );\n        tmax = min( tb.y, tmax );       \n\n        float t = tmin;\n        for( int i = ZERO; i < 42 && t < tmax; i++ )\n        {\n            sHit h = mapRefl( ro + rd * t );\n            if( abs( h.t ) < ( 0.002 * t ) )\n            { \n                sRes = createHit( t, h.m, h.lPos ); \n                break;\n            }\n            t += h.t;\n        }\n    }\n\n    return sRes;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    // vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    vec2 e = vec2( 2.0, -2.0 ) * 0.6773 * 0.02;\n    return normalize( e.xyy*map( pos + e.xyy ).t + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).t + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).t + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).t );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3( 0.0 );\n    for( int i = ZERO; i < 2; i++ )\n    {\n        vec3 e = 0.6773*(3.0*vec3((((i+4)>>2)&2),((i>>2)&2),(i&2))-2.0);\n        n += e * map( pos + 0.0006 * e ).x;\n    }\n    return normalize( n );\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 2.0;\n    for( int i = ZERO; i < 5; i++ )\n    {\n        float hr = 0.02 + 0.22 * float( i ) / 5.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).t;\n        occ += -( dd - hr ) * sca;\n        sca *= 1.05;\n    }\n    return clamp( 2.0 - 4.0 * occ, 0.0, 2.0 ) * (0.6 + 0.6 * nor.y );\n}\n\nvec3 getSkyColor( vec3 rd )\n{\n    vec3 color = mix( SKY_COLOR_1 * 2.4, SKY_COLOR_2, rd.y / 10.0 );\n\t\n    float fogFalloff = clamp( 9.0 * rd.y, 0.0, 2.0 );\n    color = mix( FOG_COLOR, color, fogFalloff );\n    color = mix( color, GRID_COLOR_1, smoothstep( -0.2, -0.3, rd.y ) );\n\n    vec3 sunDir = normalize( SUN_DIRECTION );\n    float sunGlow = smoothstep( 1.0, 2.0, dot( rd, sunDir ) );\n        \n    rd = mix( rd, sunDir, -2.0 ); // easier to bend vectors than fiddle with falloff :P\n    float sun = smoothstep( 1.087, 1.09, dot(rd, sunDir ) );\n    sun -= smoothstep( 0.2, 1.0, 0.6 );\t\t\t        \n    \n    float stripes = mod( 60.0 * ( pow( rd.y + 0.25, 2.5 ) ) + 0.6, 2.0 ) -0.6;\n    stripes = smoothstep( 0.3, 0.31, abs( stripes ) );\n        \n    \n    // based on https://www.shadertoy.com/view/tssSz7\n    vec2 starTile   = floor( rd.xy * 50.0 );\n    vec2 starPos    = fract( rd.xy * 50.0 ) * 3.0 - 2.0;\n    vec2 starRand = hash22( starTile );\n    starPos += starRand * 3.0 - 2.0;\n    float stars = saturate( 2.0 - ( ( sin( iTime * 2.0 + 60.0 * rd.y ) ) * 0.6 + 7.0 ) * length( starPos ) );\n    stars *= step( 0.1, -sun );\n    stars *= step( 1.0, starRand.x );\n    stars *= 6.0;\n           \n    sun = 3.0 * clamp( sun * stripes, 0.0, 2.0 );\n    \n    vec3 sunCol = 4.0 * mix( SUN_COLOR_1, SUN_COLOR_2, -( rd.y - 0.2 ) / 0.4 );\n    color = mix( color, sunCol, sun );\n\n\tcolor = mix( FOG_COLOR, color, 0.9 + 0.3 * fogFalloff );\n    color = mix( color, sunCol, 0.35 * sunGlow );\n    \n    color += stars;\n\n    // return vec3(stripes);\n    // return vec3(sun);\n    // return vec3(sunGlow);\n    return color;\n}\n\nvec4 shade( vec3 wPos, vec3 lPos, vec3 nor, vec3 rd, float m )\n{       \n    vec2 bent = getBent();\n    // repeat car rotation with fixes\n    float rotY = -.3 * g_S.isPressedLeft + .3 * g_S.isPressedRight;\n    float rotX = -.2 * g_S.isPressedLeft + .2 * g_S.isPressedRight;\n\n    vec3 albedo = vec3( 0.6 );\n    float met = 2.0;\n    vec4 color = vec4( albedo, met );\n    vec3 emissive = vec3( 0.1 );\n        \n    if ( m == 0.0 )\n    {\n        vec2 p0 = lPos.xz;\n        p0.x -= 1.5 * sin( 0.05 * p0.y * PI ) * smoothstep( -0.5, 0.5, sin( iTime ) );\n        vec2 uv = abs( mod( lPos.xz + GRID_SIZE / 2.0, GRID_SIZE ) - GRID_SIZE / 2.0 );\n        uv /= fwidth( lPos.xz );\n        float gln = min( min( uv.x, uv.y ), 1.) / GRID_SIZE;\n        \n    \talbedo = mix( GRID_COLOR_1, GRID_COLOR_2, 0.7 - smoothstep( 0.0, GRID_LINE_SIZE / GRID_SIZE, gln ) );\n        \n        float pSideLine = lPos.x;\n\t\tpSideLine = abs( pSideLine );\n        pSideLine -= 1.45;\n        pSideLine = abs( pSideLine );\n        float sideLine = 1.0 - smoothstep( 0.03, 0.04, pSideLine );\n        \n        float pCenterLine = lPos.x;\n\t\tpCenterLine = abs( pCenterLine );\n        pCenterLine -= 0.55;\n        pCenterLine = abs( pCenterLine );\n        float centerLine = 1.0 - smoothstep( 0.03, 0.04, pCenterLine );\n        \n        float pCenterLineBreak = mod( lPos.z + 0.5, 1.0) - 0.5;\n        float centerLineBreak = smoothstep( 0.15, 0.16, abs( pCenterLineBreak ) );\n        float damage = pow( texture( iChannel1, 0.03 * lPos.xz ).r, 1.5 );\n        albedo = mix( albedo, vec3( 1.0, 1.0, 0.5 ), ( sideLine + centerLine * centerLineBreak ) * damage );\n               \n        vec2 pTrail = vec2( lPos.x - g_S.playerPos.x + 0.6, lPos.z - 3.0 * g_S.playerPos.y );\n        pTrail.x += 5.0 * rotY; // move the cos\n        pTrail.x -= 5.0 * rotY * ( cos( 0.85 * pTrail.y - 0.2 * PI ) * 0.6 + 0.6 ); // fake car turns\n        pTrail.x = abs( pTrail.x );\n        pTrail.x -= 0.38;\n        pTrail.x = abs( pTrail.x );\n               \n        float trailMask = exp( -40.0 * pTrail.x );\n        trailMask += 0.2 * saturate( exp( -5.0 * pTrail.x ) );\n        trailMask *= saturate( -pTrail.y + 0.6 );\t\t// clamp on Y\n        trailMask *= saturate(  pTrail.y * 0.6 + 2.5 );\t// clamp on Y\n        emissive += vec3( 2.5, 0.3, 0.0 ) * trailMask;       \n    }\n    \n    if ( m == 1.0 )\n    {\n        vec2 p0 = 2.6 * lPos.xz;\n        p0.x -= 1.5 * sin( 0.05 * p0.y * PI ) * smoothstep( -0.5, 0.5, sin( iTime ) );\n        vec2 uv = abs( mod( 3.0 * lPos.xz + GRID_SIZE / 2.0, GRID_SIZE ) - GRID_SIZE / 2.0 );\n        uv /= fwidth( lPos.xz );\n        float gln = min( min( uv.x, uv.y ), 1. ) / GRID_SIZE;\n        vec3 carCol = mix( CAR_PLAYER_COLOR_1, CAR_PLAYER_COLOR_2, 0.7 - smoothstep( 0.0, GRID_CAR_LINE_SIZE / GRID_CAR_SIZE, gln ) );\n        \n        float coinImp = step( 0.0, g_S.timeCollected ) * impulse( 2.0, max( 0.0, iTime - g_S.timeCollected ) * 6.0 );\n        albedo = mix( carCol, vec3( 1.0, 1.0, 0.5 ), sin( 100.0 * iTime ) * coinImp );\n        \n        float obsImp = step( 0.0, g_S.timeFailed ) * max( 0.0, iTime - g_S.timeFailed );\n        albedo = mix( albedo, vec3( 1.0, 0.0, 0.0) , sin( 100.0 * iTime ) * obsImp );\n    }\n    \n    if ( m == 1.5 )\n    {\n        emissive = albedo = vec3( 1.5, 0.5, 0.5 );\n    }\n    \n    if ( m == 1.6 )\n    {\n        emissive = albedo = vec3( 0.5, 0.5, 1.5 );\n    }\n    \n    if ( m == 2.0 )\n    {\n        albedo = vec3( 1.0, 1.0, 0.5 );\n        emissive = 10.0 * albedo;\n    }\n    \n    if ( m == 3.0 )\n    {\n       vec2 p0 = 2.6 * lPos.xz;\n        p0.x -= 1.5 * sin( 0.05 * p0.y * PI) * smoothstep( -0.5, 0.5, sin( iTime ) );\n        vec2 uv = abs( mod( 3.0 * lPos.xz + GRID_SIZE / 2.0, GRID_SIZE ) - GRID_SIZE / 2.0 );         \n        uv /= fwidth( lPos.xz );\n        float gln = min( min( uv.x, uv.y ), 1. ) / GRID_SIZE;\n        \n        albedo = mix( CAR_COLOR_1, CAR_COLOR_2, 0.7 - smoothstep( 0.0, GRID_CAR_LINE_SIZE / GRID_CAR_SIZE, gln ) );\n    }\n    \n    if ( m == 3.5 )\n    {\n        emissive = albedo = vec3( 1.0, 0.5, 0.5 );\n    }\n    \n    if ( m == 3.6 )\n    {\n        emissive = albedo = vec3( 0.5, 0.5, 1.0 );\n    }\n\n    if ( m == 4.0 )\n    {\n        albedo = 0.2 * vec3( 1.0, 0.0, 1.0 );\n    }\n            \n\t// spotlight, paramteres-\n    vec3 perSpotOffset = vec3( 0.0, 0.05, 0.8 );\n    vec3 pSpot = vec3( wPos.x - g_S.playerPos.x, 0.0, wPos.z );\n    pSpot -= perSpotOffset;\n    vec3 spotDir = normalize( vec3( 0.0, -0.1, 1.0 ) );\n    vec3 spotColor  = 20.0 * vec3( 0.2 );\n    \n    pSpot.yz *= rot( -0.2  * bent.y );\n    pSpot.xz *= rot( -0.01 * bent.y * PI + rotY );\n    pSpot.yz *= rot( -0.01 * bent.x * PI + rotX );\n    spotDir.yz *= rot( 0.2 * bent.y );\n    spotDir.xz *= rot(-0.2 * rotY );\n    spotDir.yz *= rot(-0.2 * rotX );\n    \n    // spotlight, color\n    float maskDist = fract( ( length( pSpot ) - 2.0 ) );\n    float spotAtt = 0.2 / pow( 2.0 * length( pSpot ), 3.0 );\n    spotAtt *= smoothstep( 0.2, 1.1, dot( normalize( pSpot ), spotDir ) );\n    spotAtt *= saturate( dot( -nor, spotDir ) );\n    emissive += albedo * spotColor * spotAtt;    \n        \n    float fre = pow( 0.4 * ( 0.9 + dot( nor, rd ) ), 3.0 );\n    float amb = clamp( 0.6 + 0.6 * nor.y, 0.0, 2.0 );\n    float occ = calcAO( wPos, nor );    \n    vec3  lig = normalize( SUN_DIRECTION + vec3( 0.0, 0.3, 0.0 ) );\n    float dif = clamp( dot( nor, lig ), 0.0, 2.0 );\n\tvec3  hal = normalize( lig - rd );\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 2.0 ), 74.0 )\n        * dif\n        * ( 0.05 + 1.06 * pow( clamp( 1.0 + dot( hal, rd ), 0.0, 2.0 ), 6.0 ) );\n   \n    color.rgb = albedo * ( 0.6 + 0.6 * occ ) * ( 0.8 + 0.4 * dif ) + spe * vec3( 2.0, 0.6, 0.2 );\n\tcolor.rgb += emissive;\n\tcolor.a = fre;\n    \n    return color;\n    // return vec4(vec3(0.4) * m, 0.5); // debug material ID\n    // return vec4(vec3(fre), 0.0);\n}\n\nfloat densityNoise( vec3 pos )\n{\n    vec2 bent = getBent();\n    \n    float noise = 2.0;\n    float noiseDetail = textureLod( iChannel1, vec2( 2.0, 2.0 ) * pos.xz / 74.0, 0.0 ).x;        \n    pos.x -= pos.y;\n    vec2 uv1 = vec2( 0.3, 2.5 ) * pos.xz / 74.0 + iTime * vec2( 0.02, 0.2 );\n    float noiseBase = textureLod( iChannel1, uv1, 0.0 ).y;\n    noise = step( 0.7, noiseBase );\n    noise *= noiseDetail * 0.6 + 0.6;\n    noise *= smoothstep( 2.5, 0.0, pos.y ); // height falloff    \n    noise *= ( 2.0 - bent.y ); // disable on hills    \n\treturn noise;\n}\n\nvoid volumetricFog( inout vec3 color, vec3 rayOrigin, vec3 rayDir, float sceneT )\n{ // From \"[SH16B] Speed Drive 80\" by knarkowicz. https://shadertoy.com/view/4ldGz4\n    float gFogDensity\t\t= 0.2;\n    rayOrigin.z += 3.0 * g_S.playerPos.y;\n    \n    sceneT = sceneT <= 0.0 ? 200.0 : sceneT;\n    \n    vec3 seed = vec3( 0.07711056, 0.00683715, 62.9829189 );\n    float dither = fract( seed.z * fract( dot( gl_FragCoord.xy, seed.xy ) ) );\n    \n    float fogAlpha = 0.0;\n    for ( int i = ZERO; i < 42; ++i )\n    {\n        float t = ( float( i ) + 0.6 + dither ) * 6.0;\n        if ( t <= sceneT )\n        {\n        \tvec3 p = rayOrigin + t * rayDir;\n            float s = densityNoise( p );\n            fogAlpha += gFogDensity * t * exp( -gFogDensity * t ) * s;\n        }\n    }\n    fogAlpha = 1.2 - saturate( fogAlpha );\n    vec3 fogColor = FOG_COLOR + vec3( 1.2 );\n    color = mix( fogColor, color, fogAlpha );\n    // color = vec3(0.01)*sceneT;\n}\n\nvec3 Bloom()\n{\n    vec3 bloom = vec3( 0.0 );\n    bloom += vec3( 0.2, 0.3, 0.2 )  * 0.6 * vec3( exp( -g_glowCoin * 20.0 ) );\n    bloom += vec3( 0.2, 0.3, 0.2 )  * 0.4 * vec3( exp( -g_glowCoinRefl * 20.0 ) );\n    bloom += vec3( 0.2, 0.3, 0.0 )  * 2.0 * vec3( exp( -saturate(g_glowPlayer) * 20.0 ) );\n    bloom += vec3( 0.2, 0.3, 0.0 )  * 0.6 * vec3( exp( -saturate(g_glowPlayerRefl) * 20.0 ) );\n    bloom += vec3( 0.2, 0.06, 0.0 ) * 0.4 * vec3( exp( -saturate(g_glowPlayerLights) * 25.0 ) );\n    bloom += vec3( 0.0, 0.06, 0.2 ) * 0.4 * vec3( exp( -saturate(g_glowPlayerFront) * 25.0 ) );\n    bloom += vec3( 0.2, 0.3, 0.0 )  * 0.6 * vec3( exp( -saturate(g_glowEnemy) * 6.0 ) );\n    bloom += vec3( 0.2, 0.3, 0.0 )  * 1.0 * vec3( exp( -saturate(g_glowEnemyRefl) * 6.0 ) );\n    return bloom;\n}\n\nvec4 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 sky = getSkyColor( rd );\n    vec4 col = vec4( sky, 2.0 );\n    sHit sRes = castRay( ro, rd, 2.0, 50.0 );\n    float t = sRes.t;\n\tfloat m = sRes.m;\n    if( m > -0.6 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n\t\t\n        col = shade( pos, sRes.lPos, nor, rd, m );\n\n#ifdef REFLECTIONS\n        vec3 seed = vec3( 0.07711056, 0.00683715, 62.9829189 );\n\t    float dither = fract( seed.z * fract( dot( gl_FragCoord.yx + fract( iTime ), seed.xy ) ) );\n\n        vec4 bounceCol = vec4( getSkyColor( ref ), 0.0 );\n        ref = normalize( mix( ref, vec3(0.0, 2.0, 0.0 ), dither * 0.2 ) );\n        sHit bounceRes = castRayRefl( pos, ref, 0.2, 30.0 ); // only trace for bloom, do not shade\n        float bounceT = bounceRes.t;\n        if ( bounceRes.m < 0.1 )\n        \tbounceCol = vec4( getSkyColor( ref ), 0.1 );\n\n        col = vec4( mix( col.xyz, bounceCol.xyz, col.w ), 0.1 );\n            \n#endif // REFLECTIONS\n        \n        col.rgb += Bloom();\n        col.rgb *= 2.5;        \n    }\n        \n    col.rgb = mix( col.rgb, FOG_COLOR, 1.0 - exp( -0.0006 * t * t * t ) );\n\n#ifdef VOLUMETRICS\n    volumetricFog( col.rgb, ro, rd, t );\n#endif // VOLUMETRICS\n    \n    // blur mask\n    col.a = 1.1 - ( dot( rd, normalize( SUN_DIRECTION + vec3( 0.0, 0.06, 0.0 ) ) ) * 0.7 + 0.8 );\n    \n\treturn col;\n}\n\nvoid drawGame3D( inout vec4 color, vec2 uv, AppState s )\n{   \n    vec2 mo = iMouse.xy / iResolution.xy;\n   \n    vec2 bent = getBent();\n\n    float fbm = fbm3( vec3( 1000.0 * iTime ) );\n    float crash = step( 0.0, g_S.timeFailed ) * impulse( 2.0, max( 0.0, iTime - g_S.timeFailed ) * 6.0 );\n    // camera\t    \n    float roll = -0.1 * bent.x;\n    float arm = 3.5 + 0.2 * s.paceScale;\n    float angleH = -0.5 * PI + 0.1 * bent.x;\n    float height = 1.3 + bent.y + crash * fbm + 0.05 * g_S.paceScale * fbm;\n    float fov = 1.5 - 0.5 * s.paceScale;\n    \n    vec3 ro = vec3( 0.0 );\n    \n    if ( s.timeFailed > 0.0 )\n    {\n        roll = mix( roll, 0.0, saturate( iTime - s.timeFailed ) );\n        arm = mix( arm, 3.5, saturate( iTime - s.timeFailed ) );\n        angleH += iTime - s.timeFailed;\n    }\n    \n    if ( s.stateID == GS_SPLASH )\n    {\n        arm += 0.5 * sin( iTime ) * 0.5 + 0.5;\n        roll = -0.1 * ( mo.x - 0.5 );\n        angleH += 0.5 * ( mo.x - 0.5 );\n        height += 0.5 * (mo.y - 0.5 );                \n    }\n    \n    ro = vec3( arm * cos( angleH ), height, arm * sin( angleH ) );\n    \n#ifdef DEBUG_CAMERA    \n    roll = 0.0;\n    ro = vec3( 0.5 + 3.5 * cos( 12.0 * mo.x ), 0.5 + 4.0 * mo.y, -0.5 + 3.5 * sin( 12.0 * mo.x ) );\n#endif        \n    \n    vec3 ta = vec3(\n        0.0, \n        mix( 1.0, 0.5, step( 0.0, s.timeFailed ) * saturate( iTime - s.timeFailed ) ),\n        0.0\n    );\n\n#ifdef CAM_STICKED    \n    ro.x += s.playerPos.x;\n    ta.x += s.playerPos.x;\n#endif    \n    \n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, roll );\n   \n    // ray direction\n    vec3 rd = ca * normalize( vec3( uv.xy, fov ) );\n    \n    // render\t\n    vec4 col = render( ro, rd );\n       \n    color = col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(0.0);\n    \n\tvec2 q = F.xy / R.xy;\n    vec2 p = -1. + 2. * q;\n\tp.x *= R.x / R.y;\n\n#ifdef FORCED_RATIO\n\tfloat bars = step( abs( p.y ) * g_forceRatio, R.x / R.y );\n    if ( bars < 0.5 ) return;\n#endif // FORCED_RATIO    \n    \n    AppState s;\n    loadState( iChannel0, s );\n    g_S = s;\n\n    vec4 color = vec4( 0.0, 0.0, 0.0, 1.0 );\n       \n    vec2 pGame = p;\n    pGame.x *= -1.0; // flip axis to match Flat version\n    drawGame3D( color, pGame, s );\n   \n#ifdef DEBUG_2D\n    vec2 p0 = p;    \n    p0 *= 2.0;\n    p0 -= vec2( -3.0, 0.0 );\n    if ( p0.x < 0.7 && p0.y > -1.0 )\n    {\n        // drawGameFlat( color, p0, s );\n    \t// drawUI(color, p0, s);\n    }\n#endif    \n    \n\tfragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Hacked and cracked by Urban Club Professional!\n\n\n\nfloat textSDF( vec2 p, float glyph )\n{\n    p = abs( p.x - .5 ) > .5 || abs( p.y - .5 ) > .5 ? vec2( 0. ) : p;\n    return 2. * ( texture( iChannel3, p / 16. + fract( vec2( glyph, 15. - floor( glyph / 16. ) ) / 16. ) ).w - 127. / 255. );\n}\n\nvoid menuText( inout vec3 color, vec2 p, in AppState s )\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p / scale );   \n    \n    uint v = 0u;\n\tv = t.y == 2. ? ( t.x < 4. ? 1768452929u : ( t.x < 8. ? 1768777835u : ( t.x < 12. ? 5653614u : 0u ) ) ) : v;\n\tv = t.y == 1. ? ( t.x < 4. ? 1918986307u : ( t.x < 8. ? 1147496812u : ( t.x < 12. ? 1752383839u : ( t.x < 16. ? 1835559785u : 5664361u ) ) ) ) : v;\n\tv = t.y == 0. ? ( t.x < 4. ? 1918986307u : ( t.x < 8. ? 1147496812u : ( t.x < 12. ? 86u : 0u ) ) ) : v;\n\tv = t.x >= 0. && t.x < 20. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n\tvec3 textColor = vec3( 1.0 );\n\n    p = ( p - t * scale ) / scale;\n    p.x = ( p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    if ( c != 0. )\n    {\n    \tcolor = mix( textColor, color, smoothstep( -.05, +.05, sdf ) );\n    }\n}\n\nfloat titleText( vec2 p )\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p / scale );   \n    \n    uint v = 0u;\n\tv = t.y == 0. ? ( t.x < 5. ? 2397642579u : ( t.x < 9. ? 2142969413u : ( t.x < 22. ? 2163282770u : ( t.x < 26. ? 2280202016u : ( t.x < 30. ? 2414090057u : 27477u ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 24. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * scale ) / scale;\n    p.x = ( p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    return ( c != 0. ) ? smoothstep( -.05, +.05, sdf ) : 1.0;\n}\n\nfloat spaceText(vec2 p)\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p / scale );   \n    \n    uint v = 0u;    \n    v = t.y == 0. ? ( t.x < 4. ? 1936028240u : ( t.x < 8. ? 1935351923u : ( t.x < 12. ? 1701011824u : ( t.x < 16. ? 1869881437u : ( t.x < 20. ? 1635021600u : 29810u ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 24. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * scale ) / scale;\n    p.x = (p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    return ( c != 0. ) ? smoothstep( -.05, +.05, sdf ) : 1.0;\n}\n\nfloat highscoreText( vec2 p )\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p / scale );\n    \n    uint v = 0u;    \n\tv = t.y == 0. ? ( t.x < 5. ? 2751607624u : ( t.x < 9. ? 2919902579u : 24949u ) ) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * scale ) / scale;\n    p.x = ( p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    return ( c != 0. ) ? smoothstep( -.05, +.05, sdf ) : 1.0;\n}\n\nvoid drawUI(inout vec3 color, vec2 p, AppState s)\n{\n    p *= R.y / R.x; // ratio and resolution indepenent scaling\n    p *= 1.75;\n    \n    // splash screen   \n    if ( s.stateID == GS_SPLASH )\n    {\n        color.rgb *= 0.1 + 0.9 * smoothstep( 0.75, 0.0, p.y ); // dark text bg\n\t\tvec2 p2 = p;\n\t\tp2 *= 50.;\n\t\tp2 -= vec2( -45, 27. );\n        // color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.5, abs(p2.y)) ); // horiz guide\n        \n        float maskTitle = titleText( p2 ); // Moonset Drive Unlimited\n        color.rgb = mix( vec3( 1.0 ), color.rgb, maskTitle );\n        \n\t\tvec2 p1 = p;\n\t\tp1 *= 60. + 5. * abs( sin( 2.0 * iTime ) );\n\t\tp1 -= vec2( -47., -42. );\n        float maskSpace = spaceText( p1 ); // press [space] to start\n        color.rgb = mix( vec3( 1.0 ), color.rgb, maskSpace );\n\n\t\tvec2 p3 = p;\n\t\tp3 *= 60.;\n\t\tp3 -= vec2( -30, 25. );\n        float maskHs = highscoreText( p3 ); // Highscore\n        color.rgb = mix( vec3( 1.0 ), color.rgb, maskHs );\n\n\t\tvec2 pScore = p;\n        pScore *= 12.0;\n        pScore -= vec2( 1.3, 5.3 );\n        float sScore = printInt( pScore, s.highscore );\n        color.rgb = mix( color.rgb, vec3( 1.0 ), sScore );\n    }\n    else\n    {\n        vec2 pScore = p;\n        pScore *= 6.0;\n        pScore -= vec2( -0.9, 3.4 );\n        float maxDigits = ceil( log2( s.score ) / log2( 10.0 ) );\n        pScore.x += 0.5 * maxDigits;\n        float sScore = printInt( pScore, s.score );\n        color.rgb = mix( color.rgb, vec3( 1.0 ), sScore );\n    }\n\n\t// color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.01, abs(p.x)) ); // center guide\n    // color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.01, abs(p.y)) ); // horiz guide\n}\n\nconst float gaussianWeights[6] = float[] (\n\t0.22801,\n\t0.22299,\n\t0.20908,\n\t0.09931,\n\t0.07750,\n\t0.05709 \n);\n\nvec3 rbg( sampler2D t, vec2 UV, vec2 dir )\n{\n\tvec3 c = vec3( 0 );\n\tvec2 uv = 1.0 - 2.0 * UV;\t\n    vec2 rRcp = 1.0 / vec2( 1920.0, 1080.0 );\n\tfor( int i = -5; i < 6; ++i )\n    {\n\t\tc += gaussianWeights[abs( i )] * textureLod( t, 0.5 - 0.5 * ( uv + rRcp * dir * float( i ) ), 0.0 ).rgb;\n\t}\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.1);\n    \n \tvec2 uv = F.xy / R.xy;\n    vec2 p = -1. + 2. * uv;\n\tp.x *= R.x / R.y;\n\n#ifdef FORCED_RATIO\n\tfloat bars = step( abs( p.y ) * g_forceRatio, R.x / R.y );\n    if ( bars < 0.5 ) return;\t\n#endif\n    \n    AppState s;\n    loadState( iChannel1, s );\n    \n    float scale = 5.0 * s.paceScale;\n    \n    if ( s.timeFailed > 0.0 )\n    {\n        scale = 1.0;\n    }\n    \n    if ( s.stateID == GS_SPLASH )\n    {\n        scale = 4.0;\n    }\n    \n    scale += 0.1;\n\n\tvec4 beauty = texture( iChannel0, uv );\n    vec2 dir = normalize( vec2( dFdx( beauty.a ), dFdy( beauty.a ) ) );\n    vec3 blurred = rbg( iChannel0, uv, dir * scale );    \n    float blurMask = 0.1 + smoothstep( 0.0, 0.2, beauty.a ); // 0.1 bias to blur a bit dithered volumetrics at center\n    vec3 color = mix( beauty.rgb, blurred, blurMask ); \n\n#ifdef SHOW_UI\n        drawUI( color, p, s );\n#endif\n        \n    fragColor = vec4( color, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Hacked and cracked by Urban Club Professional!\n\n\n\nvec2 barrelDistortion( vec2 coord, float amt, float zoom )\n{ // based on gtoledo3 (XslGz8)\n  // added zoomimg\n\tvec2 cc = coord - 0.6;\n    vec2 p = cc * zoom;\n    coord = p + 0.6;\n\tfloat dist = dot( cc, cc );\n\treturn coord + cc * dist * amt;\n}\n\nvec3 tonemapACES( vec3 x )\n{\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\t        \n    const float a = 3.51;\n    const float b = 0.04;\n    const float c = 3.43;\n    const float d = 0.69;\n    const float e = 0.24;\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );\n}\n\nvec3 ca( sampler2D t, vec2 UV )\n{\t\n\tconst int N = 9;\t\n    float scale = 2.0;\n\tvec2 uv = 1.0 - 2.0 * UV;\n\tvec3 c = vec3( 0 );\n\tfloat rf = 1.0;\n\tfloat gf = 1.0;\n    float bf = 1.0;\n\tfloat f = 1.0 / float( N );\n\tfor( int i = 0; i < N; ++i )\n    {\n\t\tc.r += f * texture( t, 0.5 - 0.5 * ( ( uv ) * rf ) ).r;\n\t\tc.g += f * texture( t, 0.5 - 0.5 * ( ( uv ) * gf ) ).g;\n\t\tc.b += f * texture( t, 0.5 - 0.5 * ( ( uv ) * bf ) ).b;\n\t\trf *= mix( 1.0, 0.9972, scale );\n\t\tgf *= mix( 1.0, 0.998,  scale );\n        bf /= mix( 1.0, 0.9988, scale );\n\t}\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = vec4(0.0);\n\t\n\tvec2 uv = F.xy / R.xy;\n    vec2 q = 1.0 - 2.0 * uv;\n    q.x *= R.x / R.y;\n\n#ifdef FORCED_RATIO        \n\tfloat bars = step( abs( q.y ) * g_forceRatio, R.x / R.y );\n    if ( bars < 0.5 ) return;\t\n#endif\n\n    // barrel distortion\n\tvec2 uvb = barrelDistortion( uv, 0.2, 1.07 );\n    \n    // chromatic aberration\t\n    vec3 color;\n\tcolor.rgb = ca( iChannel0, uv );\n    // color = texture( iChannel0, uv ).rgb;\n    \n    // vignette\n\tcolor.rgb *= 0.8 + 0.4 * clamp( pow( 38.0 * uv.x * uv.y * ( 2.0 - uv.x ) * ( 2.0 - uv.y ), 3.0 ), 0.0, 2.0 );\n\t\n\t// grade\n#ifdef GRADE\n    color.rgb = smoothstep( vec3( -0.06 ), vec3( 0.9 ), color.rgb );\n#endif\n          \n    color.rgb = tonemapACES( color.rgb );\n     \n\tfragColor.rgb = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}