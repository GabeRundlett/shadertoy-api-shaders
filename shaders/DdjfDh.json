{
    "Shader": {
        "info": {
            "date": "1689675610",
            "description": "Quick draft of the sets. Trying to get more precision",
            "flags": 0,
            "hasliked": 0,
            "id": "DdjfDh",
            "likes": 1,
            "name": "J/M Set",
            "published": 3,
            "tags": [
                "mandelbrotset"
            ],
            "usePreview": 0,
            "username": "Elyades",
            "viewed": 214
        },
        "renderpass": [
            {
                "code": "float PI = 3.14159265358979323846;\nfloat TWOPI = 6.28318530718;\nfloat PIONTWO = 1.57079632679;\nfloat PIONFOUR = 0.78539816339;\nfloat E = 2.71828182846;\n\nfloat atan2(float y, float x)\n{\n    //this computes arctan(y/x)\n    float angle = atan(y,x);\n    if(angle < 0.0){angle+= TWOPI;}\n    return(angle);\n}\n\nvec2 times(vec2 a , vec2 b)\n{\n    return( vec2(a.x*b.x - a.y*b.y , a.x*b.y + a.y*b.x) );\n}\n\nvec2 itimes(vec2 uv)\n{\n    return( vec2(-uv.y,uv.x) );\n}\n\nfloat norm(vec2 uv)\n{\n    return( uv.x*uv.x + uv.y*uv.y );\n}\n\nvec2 oneover(vec2 uv)\n{\n    return( vec2(uv.x , -uv.y)/norm(uv) );\n}\n\nvec2 square(vec2 uv)\n{\n    return( vec2(uv.x*uv.x - uv.y*uv.y, 2.0*uv.x*uv.y) );\n}\n\nvec2 cube(vec2 uv)\n{\n    float x2 = uv.x*uv.x ; float y2 = uv.y*uv.y;\n    return( vec2(x2*uv.x - 3.0*uv.x*y2 , 3.0*x2*uv.y - y2*uv.y) );\n}\n\nvec2 quad(vec2 uv)\n{\n    float x2 = uv.x*uv.x ; float y2 = uv.y*uv.y; float xy = uv.x*uv.y;\n    return( vec2(x2*x2 - 6.0*x2*y2 + y2*y2 , 4.0*xy*(x2 - y2) ) );\n}\n\nvec2 exp2d(vec2 uv)\n{\n    return( exp(uv.x)*vec2(cos(uv.y),sin(uv.y)));\n}\n\nvec2 log2d(vec2 uv)\n{\n    return(vec2(log(length(uv)),atan(uv.y,uv.x)));\n}\n\nvec2 cos2d(vec2 uv)\n{\n    return ( vec2 (exp2d(itimes(uv)) + exp2d(itimes(-uv)))*0.5);\n}\n\nvec2 sin2d(vec2 uv)\n{\n    return ( vec2 (-itimes((exp2d(itimes(uv)) - exp2d(itimes(-uv)))*0.5)));\n}\n\nvec2 cosh2(vec2 uv)\n{\n    float expo = exp(uv.x); float co = cos(uv.y); float si = sin(uv.y);\n    return ( (expo*vec2(co,si) + exp(-uv.x)*vec2(co,-si))*0.5 );\n}\n\nvec2 sinh2(vec2 uv)\n{\n    float expo = exp(uv.x); float co = cos(uv.y); float si = sin(uv.y);\n    return ( (expo*vec2(co,si) - exp(-uv.x)*vec2(co,-si))*0.5 );\n}\n\nvec2 tanh2(vec2 uv)\n{\n    vec2 expo = exp2d(2.0*uv);\n    return( vec2(expo - 1.0)/(expo + 1.0) );\n}\n\nvec2 rotate(vec2 uv,float angle)\n{\n    float co = cos(angle);float si = sin(angle);\n    uv *= mat2(co,-si,si,co);\n    return(uv);\n}\n\nvec2 power(vec2 uv, float n)\n{\n    float modulus = length(uv);\n    float angle = atan2(uv.y,uv.x);\n    angle *= n;\n    \n    return( exp(n*log(modulus))*vec2(cos(angle),sin(angle)));\n}\n\nvec2 zpowlnz(vec2 uv)\n{\n    float modulus = length(uv);\n    float angle = atan2(uv.y,uv.x);\n    float LOG = log(modulus);\n    float value = 2.0*angle*LOG;\n    vec2 result = vec2(cos(value),sin(value))*exp(-angle*angle + LOG*LOG);\n    return(result);\n}\n\nvec2 conj(vec2 uv)\n{\n    return vec2(uv.x,-uv.y);\n}\n\nvec3 palette1( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(2.0,1.0,1.0);\n    vec3 d = vec3(0.5,0.2,0.25);\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette2( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.0,0.1,0.2);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette3( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.2,0.3,0.3);\n    vec3 b = vec3(0.0,0.3,0.2);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.0,0.25,0.5);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette4(float t) //blue purple :D\n{\n    vec3 a = vec3(0.6,0.4,0.9);\n    vec3 b = vec3(0.4,0.6,0.1);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.45,0.0,0.1);\n\n    vec3 finalColor = vec3( a + b*cos(TWOPI*(c*t + d)) );\n    return finalColor;\n}\n\nvec4 threeLayerColoring( float t ) {\n    float iterationAmount = t;\n\n    float scale = 0.5;\n    float periodFast = 10.0*scale;\n    float residueFast = mod(iterationAmount,periodFast);\n    float indexFast = float(residueFast)/float(periodFast);\n    vec3 colorFast = palette3(indexFast);\n\n    float periodMedium = 20.0*scale;\n    float residueMedium = mod(iterationAmount,periodMedium);\n    float indexMedium = float(residueMedium)/float(periodMedium);\n    vec3 colorMedium = palette3(indexMedium);\n\n    float periodSlow = 100.0*scale;\n    float residueSlow = mod(iterationAmount,periodSlow);\n    float indexSlow = float(residueSlow)/float(periodSlow);\n    vec3 colorSlow = palette3(indexSlow);\n    \n    float finalIndex = (indexFast + indexMedium + indexSlow)/3.;\n    vec3 finalColor = (colorSlow + colorMedium + colorFast)/3.;\n    \n    return(vec4(finalColor, finalIndex));\n}\n\nfloat logplus(float t)\n{\n    if (t < 1.0){return(0.0);}\n    else{return(log(t));}\n}\n\nvec2 iteration(vec2 uv, vec2 c)\n{\n    return (square(uv) +  c );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 m = 3.0*(iMouse.xy - iResolution.xy/2.0)/iResolution.xy;\n    //Scale\n    float scale = 4.0;\n    uv += -0.5;\n    uv *= scale;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\n    \n\n    //Choosing the Zoom\n    float zoomAmount = pow(10.0,-iTime/8.0);\n    //vec2 zoomPoint = vec2(-1.76,0.035);\n    vec2 zoomPoint = vec2(0,0);\n    vec2 mousePoint = (iMouse.xy - iResolution.xy/2.0)*8.0/ iResolution.xy;\n    \n\n    uv = uv*zoomAmount;\n    //uv = rotate(uv,mod(max(iTime-7.0,0.0)/40.0,1.0)*TWOPI); //comment this to stop the rotation\n    uv += zoomPoint;\n    \n    //uv += mousePoint*zoomAmount*max(iTime-4.0,0.0);\n    //uv += vec2(-0.61021,-0.0001);\n    //uv += zoomPoint*zoomAmount;\n    \n    //Change this line to go from Mandelbrot to Julia\n    float angle = TWOPI*iTime/6.0;\n    float r = clamp(0.2,1.0,1.0 + cos(TWOPI*iTime/17.0));\n    //vec2 c = r*exp2d(vec2(cos(angle),sin(angle)));\n    vec2 c = mousePoint;\n    \n    float tol = pow(10.0,-10.0);\n    float DistanceToPrevious = 1.0;\n    float currentModulus = length(uv);\n    vec2 previousIteration;\n    float iterationAmount;\n    int testAmount = 5000;\n    float bailout = pow(10.0,2.0);\n    \n    vec2 dummyuv = uv; vec2 dz = vec2(1.0,0.0);\n    int i;\n    \n    for (i = 0; i < testAmount; i++)\n    {\n        previousIteration = dummyuv;\n        dz = times(dz, 2.0*dummyuv) + vec2(1.0,0.0);\n        dummyuv = iteration(dummyuv,c);\n        \n        currentModulus = norm(dummyuv);\n        DistanceToPrevious = norm(dummyuv - previousIteration);\n        \n        if(DistanceToPrevious < tol){break;}\n        if(currentModulus > bailout)\n        {\n            break;\n        } \n    }\n    iterationAmount = float(i);\n\n    //Coloring the interior of the set\n\n    if (currentModulus < bailout)\n    {\n        \n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n    //Coloring the exterior of the set\n \n    else\n    {\n        int colorType = 3; // 0 = usual , 1 = log-potential, 2 = (log-potential) + normal map;\n        //3 = distance estimation + normal map + log-potential (mu)\n        \n        if (colorType == 0){\n            iterationAmount = 4.0*log(iterationAmount+1.0)+2.0;\n            float i = iterationAmount+1.0;\n            vec3 color1; float finalIndex; vec4 result = threeLayerColoring(iterationAmount);\n            color1 = result.rgb; finalIndex = result.t;\n            vec3 color2 = threeLayerColoring(log(i)).rgb;\n            vec3 finalColor = mix(color1,color2,finalIndex);\n            \n            fragColor = vec4(finalColor,1.0);\n        }\n        \n        if (colorType == 1){\n            float K = log(2.0);\n            float potential = logplus(norm(dummyuv))/2.0;\n            float nu = log(potential/log(bailout))/K;\n            iterationAmount = log(iterationAmount) + nu;\n            vec3 color1 = threeLayerColoring(iterationAmount).rgb;\n            vec3 color2 = threeLayerColoring(iterationAmount+1.0).rgb;\n            vec3 finalColor = mix(color1,color2,0.5+0.5*sin(iterationAmount));\n            if(nu > 1.0){finalColor = vec3(0.0);}\n\n            fragColor = vec4(finalColor,1.0);\n        }\n        \n        if (colorType == 2){\n            float height = 1.5; float lightAngle = PIONFOUR; \n            vec2 lightVector = vec2(cos(lightAngle),sin(lightAngle));\n            vec2 u = times(dummyuv,oneover(dz)); u = u/length(u);\n            float intensity = ( dot(u,lightVector) + height )/(1.0+height);\n            \n            float K = log(2.0);\n            float potential = log(norm(dummyuv))/2.0;\n            float nu = log(potential)/K;\n            iterationAmount += 1.0 - nu;\n            \n            iterationAmount = 7.0*log(iterationAmount + 1.0) + 1.0; \n            \n            vec4 result = threeLayerColoring(iterationAmount);\n            vec3 color1 = result.rgb; float finalIndex = result.t;\n            vec3 color2 = threeLayerColoring(iterationAmount+1.0).rgb;\n            vec3 finalColor = mix(color1,color2,finalIndex)*intensity;\n\n            fragColor = vec4(finalColor,1.0);\n        }\n        \n        if (colorType == 3){\n            float estimation = sqrt(currentModulus/norm(dz))*0.5*log(currentModulus);\n            estimation = pow(estimation,0.1);\n            //vec3 finalColor = vec3(estimation,estimation,estimation);\n            float lg2 = log(2.0);\n            float potential = log(log(currentModulus))/lg2 - 1.0;\n            //estimation += potential;\n            //finalColor = 0.6*finalColor + 0.4*threeLayerColoring(log(estimation)).rgb;\n            \n            \n            \n            float height = 1.3; float lightAngle = PIONFOUR; \n            vec2 lightVector = vec2(cos(lightAngle),sin(lightAngle));\n            vec2 u = times(dummyuv,oneover(dz)); u = u/length(u);\n            float intensity = ( dot(u,lightVector) + height )/(0.8+height);\n            \n            //vec3 finalColor = 0.5*texture(iChannel0, vec2(intensity,estimation)).rgb;\n            //finalColor += 0.5*texture(iChannel0, vec2(iterationAmount,estimation)).rgb;\n            vec3 finalColor = vec3( estimation );\n            \n            fragColor = vec4(finalColor*intensity,1.0);\n        }\n        \n    }\n\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "video",
                        "id": 29,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}