{
    "Shader": {
        "info": {
            "date": "1626753155",
            "description": "I take off my hat to FMS_Cat. There is just something I really dig about the way this all moves. Tweaked to get most of the bits I like. I would love to get it to look like this does at this point:\nhttps://youtu.be/BpP9r84VqOk",
            "flags": 32,
            "hasliked": 0,
            "id": "NlfSDl",
            "likes": 7,
            "name": "Flux Modulation Synapse cat.01",
            "published": 3,
            "tags": [
                "3d",
                "livecoding"
            ],
            "usePreview": 0,
            "username": "xenn",
            "viewed": 339
        },
        "renderpass": [
            {
                "code": "// Given a vec2 in [-1,+1], generate a texture coord in [0,+1]\nvec2 barrelDistortion( vec2 p, vec2 amt )\n{\n    p = 2.0 * p - 1.0;\n\n    /*\n    const float maxBarrelPower = 5.0;\n\t//note: http://glsl.heroku.com/e#3290.7 , copied from Little Grasshopper\n    float theta  = atan(p.y, p.x);\n    vec2 radius = vec2( length(p) );\n    radius = pow(radius, 1.0 + maxBarrelPower * amt);\n    p.x = radius.x * cos(theta);\n    p.y = radius.y * sin(theta);\n\n\t/*/\n    // much faster version\n    //const float maxBarrelPower = 5.0;\n    //float radius = length(p);\n    float maxBarrelPower = sqrt(5.0);\n    float radius = dot(p,p); //faster but doesn't match above accurately\n    p *= pow(vec2(radius), maxBarrelPower * amt);\n\t/* */\n\n    return p * 0.5 + 0.5;\n}\n\n//note: from https://www.shadertoy.com/view/MlSXR3\nvec2 brownConradyDistortion(vec2 uv, float scalar)\n{\n// AH!!!    uv = uv * 2.0 - 1.0;\n    uv = (uv - 0.5 ) * 2.0;\n    \n    if( true )\n    {\n        // positive values of K1 give barrel distortion, negative give pincushion\n        float barrelDistortion1 = -0.02 * scalar; // K1 in text books\n        float barrelDistortion2 = 0.0 * scalar; // K2 in text books\n\n        float r2 = dot(uv,uv);\n        uv *= 1.0 + barrelDistortion1 * r2 + barrelDistortion2 * r2 * r2;\n        //uv *= 1.0 + barrelDistortion1 * r2;\n    }\n    \n    // tangential distortion (due to off center lens elements)\n    // is not modeled in this function, but if it was, the terms would go here\n//    return uv * 0.5 + 0.5;\n   return (uv / 2.0) + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float maxDistort = 4.0 * (1.0-iMouse.x/iResolution.x);\n\n    float scalar = 1.0 * maxDistort;\n//    vec4 colourScalar = vec4(2.0, 1.5, 1.0, 1.0);\n    vec4 colourScalar = vec4(700.0, 560.0, 490.0, 1.0);\t// Based on the true wavelengths of red, green, blue light.\n    colourScalar /= max(max(colourScalar.x, colourScalar.y), colourScalar.z);\n    colourScalar *= 2.0;\n    \n    colourScalar *= scalar;\n    \n    vec4 sourceCol = texture(iChannel2, uv);\n\n    const float numTaps = 16.0;\n    \n    \n    fragColor = vec4( 0.0 );\n    for( float tap = 0.0; tap < numTaps; tap += 1.0 )\n    {\n        fragColor.r += texture(iChannel0, brownConradyDistortion(uv, colourScalar.r)).r;\n        fragColor.g += texture(iChannel0, brownConradyDistortion(uv, colourScalar.g)).g;\n        fragColor.b += texture(iChannel0, brownConradyDistortion(uv, colourScalar.b)).b;\n        \n        colourScalar *= 0.99;\n    }\n    \n    fragColor /= numTaps;\n  \n    fragColor.a = 1.0;\n    \n    vec4 bloom = texture(iChannel0,  uv);\n    vec4 base = texture(iChannel1,  uv); \n    \n    fragColor = sqrt(bloom).a * (bloom - ( base * bloom)); \n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Fork of \"FMS_Cat @ Shader Royale #1\" by FMS_Cat. https://shadertoy.com/view/wsccWj\n// 2021-07-20 03:21:18\n\n// FMS_Cat!!\n// Since it's written in the shader royale compo,\n// the code is a total mess that is not intended to be read.\n// I heard the compo machine is not a beast enough\n// so I made this less intensive a bit.\n// There are several artifacts that is difficult to ignore :(\n\n\n#define BEAT (time*69.0/60.0)\n#define PI 3.14159265\n#define time iTime * 01.0\n#define lofi(x,d) (floor((x)/(d))*(d))\n#define saturate(a) (clamp((a),0.025,1.))\n#define linearstep(a,b,t) (saturate(((t)-(a))/((b)-(a))))\n\nfloat seed;\n\nfloat fractsin(float v)\n{\n  return fract(sin(v*121.445)*34.59);\n}\n\nfloat rand()\n{\n  seed=fractsin(seed);\n  return seed;\n}\n\nvec3 randsphere()\n{\n  float t=PI*2.*rand();\n  float p=acos(rand()*2.-1.);\n  return vec3(sin(p)*sin(t),cos(p),sin(p)*cos(t));\n}\n\nfloat easeceil(float t, float fac)\n{\n  return floor(t)+.5+.5*cos(PI*exp(fac*fract(t)));\n}\n\nmat2 rot2d(float t)\n{\n  return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\n\nvec3 ifs(vec3 p,vec3 rot,vec3 shift)\n{\n  vec3 pt=abs(p);\n  vec3 t=shift;\n  for(int i=0;i<6;i++)\n  {\n    pt=abs(pt)-abs(lofi(t*pow(1.8,-float(i)),1.0/512.0));\n    t.yz=rot2d(rot.x)*t.yz;\n    t.zx=rot2d(rot.y)*t.zx;\n    t.xy=rot2d(rot.z)*t.xy;\n    pt.xy=pt.x<pt.y?pt.yx:pt.xy;\n    pt.yz=pt.y<pt.z?pt.zy:pt.yz;\n  }\n  return pt;\n}\n\nfloat sdbox(vec3 p,vec3 s)\n{\n  vec3 d=abs(p)-s;\n  return length(max(d,0.));\n}\n\n// ======= map!!!!!!!!!! ====================================\nvec4 map(vec3 p)\n{\n  vec3 pt=p;\n  vec3 haha=lofi(pt,5.0);\n  float scrphase=mod(999.9*fractsin(haha.y+haha.z+3.88),PI*2.0);\n  float scr=(mod(haha.y+haha.z,2.0)*2.0-1.0)*20.0*smoothstep(-0.5,0.5,sin(time*0.5+scrphase));\n  pt.x+=scr;\n  haha=lofi(pt,5.0);\n  float phase=BEAT/8.0;\n  phase+=dot(haha,vec3(2.75,3.625,1.0625));\n  phase=easeceil(phase,-10.0);\n  pt=mod(pt,5.0)-2.5;\n  vec3 pm=pt;\n  pt.yz=rot2d(.5*PI*phase+.25*PI)*pt.yz;\n  float clampBox=sdbox(pt,vec3(2.25,1.5,1.8));\n  pt=ifs(pt,vec3(3.6,3.0+0.4*phase,3.1),vec3(3.0,2.3,3.5));\n  pt=mod(pt-.5,1.)-.5;\n  float dist=sdbox(pt,vec3(.17));\n  dist=max(dist,clampBox);\n  return vec4(\n    dist,\n    sin(PI*fract(phase)),\n    step(0.0,0.01-abs(pt.x+pt.y)),\n    abs(pm.x)+abs(pm.y)+abs(pm.z)\n  );\n}\n\nvec3 normalFunc(vec3 p,vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx).x-map(p-d.yxx).x,\n    map(p+d.xyx).x-map(p-d.xyx).x,\n    map(p+d.xxy).x-map(p-d.xxy).x\n  ));\n}\n\nfloat aoFunc(vec3 p,vec3 n)\n{\n  float accum=0.;\n  for(int i=0;i<32;i++){\n    vec3 d=(0.02+0.02*float(i))*randsphere();\n    d=dot(d,n)<.0?-d:d;\n    //accum+=step(map(p+d).x,0.0)/64.0;\n    accum+=linearstep(0.02,0.0,map(p+d).x)/64.0;\n  }\n  return 1.0-sqrt(saturate(6.0*accum));\n}\n\nvec2 glitch(vec2 v)\n{\n  vec2 vt=v;\n  for(int i=0;i<6;i++)\n  {\n    float fac=4.0*pow(2.2,-float(i));\n    float s=fractsin(lofi(vt.x,1.6*fac));\n    s+=fractsin(lofi(vt.y,0.4*fac));\n    s+=fractsin(time);\n    float proc=fractsin(s);\n    vt+=0.2*step(proc,0.4*exp(-30.0*mod(BEAT,8.0))-0.1)*(vec2(\n      fractsin(s+22.56),\n      fractsin(s+17.56)\n    )-0.5);\n  }\n  return vt;\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n  vec2 p=(fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n  o=vec4(0,0,0,1);\n  seed=texture(iChannel0,p).x;\n  seed+=time;\n  \n  vec2 po=p;\n  p=glitch(p);\n  \n  vec3 ro=vec3(4.0*time,0,lofi(BEAT,8.0));\n  vec3 rd=vec3(p,-1);\n  rd.z+=0.6*length(p);\n  float camphase=lofi(BEAT,8.0)+mod(BEAT,8.0)*0.2;\n  rd.yz=rot2d(0.33*camphase+0.03*sin(3.0*time))*rd.yz;\n  rd.zx=rot2d(0.78*camphase+0.03*cos(3.0*time))*rd.zx;\n  rd.xy=rot2d(0.048*camphase)*rd.xy;\n  rd=normalize(rd);\n  vec3 fp=ro+rd*5.0;\n  ro+=0.002*randsphere();\n  rd=normalize(fp-ro);\n  \n  vec4 dist;\n  float rl=0.01;\n  float glow=0.0;\n  vec3 rp=ro+rl*rd;\n  for(int i=0;i<69;i++){ // nice\n    dist=map(rp);\n    glow=dist.y;\n    rl+=dist.x*0.7;\n    rp=ro+rl*rd;\n  }\n  \n  float fog=exp(-0.1*max(0.,rl-5.0));\n  o.xyz+=(1.0-fog)*vec3(1.);\n  \n  vec3 n2=normalFunc(rp,vec2(0.0,1E-2+4E-2*dist.y));\n  vec3 n=normalFunc(rp,vec2(0.0,2E-3));\n  float edge=saturate(length(n-n2));\n  float gorge=dist.z;\n\n  o.xyz+=fog*0.1*vec3(15.0,1.0,1.5)*glow;\n  \n  if(dist.x<1E-3)\n  {\n    float ao=aoFunc(rp,n);\n    o.xyz+=fog*vec3((0.4-0.1*gorge)*ao);\n    o.xyz+=fog*edge*dist.y*vec3(15.0,1.0,1.5);\n    //o.xyz+=fog*gorge*vec3(2.0,15.0,5.0)*exp(-10.0*mod(time+dist.w,1.0));\n  }\n  \n  o.xyz+=length(p-po)*2.0*sin(3.0+4.0*o.x+vec3(0.0,2.0,4.0));\n  o.xyz=pow(o.xyz,vec3(0.4545));\n  o.xyz-=0.2*length(p);\n  o.xyz=vec3(\n    smoothstep(0.1,0.9,o.x),\n    linearstep(0.0,0.8,o.y),\n    smoothstep(-0.2,1.1,o.z)\n  );\n  o.xyz*=1.0+0.1*sin(vec3(0.,1.,2.)+fragCoord.y*2.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Given a vec2 in [-1,+1], generate a texture coord in [0,+1]\nvec2 barrelDistortion( vec2 p, vec2 amt )\n{\n    p = 2.0 * p - 1.0;\n\n    /*\n    const float maxBarrelPower = 5.0;\n\t//note: http://glsl.heroku.com/e#3290.7 , copied from Little Grasshopper\n    float theta  = atan(p.y, p.x);\n    vec2 radius = vec2( length(p) );\n    radius = pow(radius, 1.0 + maxBarrelPower * amt);\n    p.x = radius.x * cos(theta);\n    p.y = radius.y * sin(theta);\n\n\t/*/\n    // much faster version\n    //const float maxBarrelPower = 5.0;\n    //float radius = length(p);\n    float maxBarrelPower = sqrt(5.0);\n    float radius = dot(p,p); //faster but doesn't match above accurately\n    p *= pow(vec2(radius), maxBarrelPower * amt);\n\t/* */\n\n    return p * 0.5 + 0.5;\n}\n\n//note: from https://www.shadertoy.com/view/MlSXR3\nvec2 brownConradyDistortion(vec2 uv, float scalar)\n{\n// AH!!!    uv = uv * 2.0 - 1.0;\n    uv = (uv - 0.5 ) * 2.0;\n    \n    if( true )\n    {\n        // positive values of K1 give barrel distortion, negative give pincushion\n        float barrelDistortion1 = -0.02 * scalar; // K1 in text books\n        float barrelDistortion2 = 0.0 * scalar; // K2 in text books\n\n        float r2 = dot(uv,uv);\n        uv *= 1.0 + barrelDistortion1 * r2 + barrelDistortion2 * r2 * r2;\n        //uv *= 1.0 + barrelDistortion1 * r2;\n    }\n    \n    // tangential distortion (due to off center lens elements)\n    // is not modeled in this function, but if it was, the terms would go here\n//    return uv * 0.5 + 0.5;\n   return (uv / 2.0) + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float maxDistort = 4.0 * (1.0-iMouse.x/iResolution.x);\n\n    float scalar = 1.0 * maxDistort;\n//    vec4 colourScalar = vec4(2.0, 1.5, 1.0, 1.0);\n    vec4 colourScalar = vec4(700.0, 560.0, 490.0, 1.0);\t// Based on the true wavelengths of red, green, blue light.\n    colourScalar /= max(max(colourScalar.x, colourScalar.y), colourScalar.z);\n    colourScalar *= 2.0;\n    \n    colourScalar *= scalar;\n    \n    vec4 sourceCol = texture(iChannel0, uv);\n\n    const float numTaps = 8.0;\n    \n    \n    fragColor = vec4( 0.0 );\n    for( float tap = 0.0; tap < numTaps; tap += 1.0 )\n    {\n        fragColor.r += texture(iChannel0, brownConradyDistortion(uv, colourScalar.r)).r;\n        fragColor.g += texture(iChannel0, brownConradyDistortion(uv, colourScalar.g)).g;\n        fragColor.b += texture(iChannel0, brownConradyDistortion(uv, colourScalar.b)).b;\n        \n        colourScalar *= 0.99;\n    }\n    \n    fragColor /= numTaps;\n  \n    fragColor.a = 1.0;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = fragCoord.xy;\n    \n    vec2 uv = (p.xy) / iResolution.xy;\n    \n    //line thickness\n    float th = 0.002;\n    \n    //gradient detection for r,g and b separatly\n    //not sure why I did this actually\n    \n    float gxr = texture(iChannel0, uv.xy+vec2(th, 0.)).r\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).r ;\n    \n    float gyr = texture(iChannel0, uv.xy+vec2(0., th)).r\n    - texture(iChannel0, uv.xy-vec2(0., th)).r;\n    \n    float gxg = texture(iChannel0, uv.xy+vec2(th, 0.)).g\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).g ;\n    \n    float gyg = texture(iChannel0, uv.xy+vec2(0., th)).g\n    - texture(iChannel0, uv.xy-vec2(0., th)).g;\n    \n    float gxb = texture(iChannel0, uv.xy+vec2(th, 0.)).b\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).b;\n    \n    float gyb = texture(iChannel0, uv.xy+vec2(0., th)).b\n    - texture(iChannel0, uv.xy-vec2(0., th)).b;\n    \n    //hack to concea noise from: https://www.shadertoy.com/view/Mdf3zr\n    float gr = gxr*gxr + gyr*gyr;\n    float gg = gxg*gxg + gyg*gyg;\n    float gb = gxb*gxb + gyb*gyb;\n    \n    //more noise control\n    float g = pow((gr+gg+gb)/1.,1.9);\n    \n    \n    vec3 col = texture(iChannel1, p / iResolution.xy).xyz;\n    col = mix(col,  0.5 + 0.5*cos(iTime*4.+uv.y*6.+vec3(0,2,4)),g*100.);\n    \n    fragColor = vec4(col,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This buffer is the feedback loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915;\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    \n    // sample the last texture with uv's slightly scaled up\n    vec3 overlay = texture(iChannel1,offs).rgb;\n\n        // Additively blend the colors together\n    vec4 col = vec4(base + (base * overlay*(0.8478975*cos(iTime/5.5))), 1.0);\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define Pi  3.14159265359\n\n#define FocalDistance 1.4\n#define LensRatio .5\n#define Margins .01",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}