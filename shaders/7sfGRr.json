{
    "Shader": {
        "info": {
            "date": "1615408914",
            "description": "Based on demofox's [url=http://demofox.org/TextureSamplerVolume.html]texture sampler volume[/url]\nPracticing more integration to do some volumetric shading (not physically based).",
            "flags": 0,
            "hasliked": 0,
            "id": "7sfGRr",
            "likes": 7,
            "name": "Raytraced Volume",
            "published": 3,
            "tags": [
                "raytracing",
                "volume",
                "trilinear",
                "analytic",
                "integration"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 209
        },
        "renderpass": [
            {
                "code": "#define BSPHERE 4.0 // Bounding sphere radius\n#define LIGHT -rd\n\n// Cubic solver\nvec4 solveCubic(in float a, in float b, in float c, in float d) {\n    float h = 18.0 * a * b * c * d - 4.0 * b * b * b * d + b * b * c * c - 4.0 * a * c * c * c - 27.0 * a * a * d * d, minCplx = 1.0;\n\n    float d0 = b * b - 3.0 * a * c;\n    float d1 = (2.0 * b * b - 9.0 * a * c) * b + 27.0 * a * a * d;\n    float q = d1 * d1 - 4.0 * d0 * d0 * d0, j = sqrt(abs(q));\n    a *= 3.0;\n\n    vec2 C = q < 0.0 ? vec2(d1, j) : vec2(d1 + j, 0.0);\n    if (abs(C.x) < 1e-3 && abs(C.y) < 1e-3) C = q < 0.0 ? vec2(d1, -j) : vec2(d1 - j, 0.0); // Switch sign if C=0\n    C = sin(atan(C.y, C.x) / 3.0 + vec2(1.57079632679, 0.0)) * pow(0.25 * dot(C, C), 1.0 / 6.0);\n\n    vec4 roots = vec4(0.0, 0.0, 0.0, h < 0.0 ? 1 : 3);\n    vec2 e = vec2(1.0, 0.0);\n    for (int k=0; k < (h < 0.0 ? 2 : 3); k++) {\n        vec2 m = e * mat2(C.x, -C.y, C.yx); // Complex multiplication\n        e *= mat2(-0.5, -0.86602540378, 0.86602540378, -0.5); // Raise cube root of unity to next power\n        vec2 root = (vec2(-d0, d0) * m / dot(m, m) - vec2(b, 0.0) - m) / a;\n        if (h < 0.0 ? (abs(root.y) < minCplx) : true) roots[h < 0.0 ? 0 : k] = root.x, minCplx = abs(root.y);\n    }\n\n    return roots;\n}\n\n// mla's suggestion to reverse the coefficients and reciprocate the results\nvec4 solveCubic2(in float a, in float b, in float c, in float d) {\n    vec4 roots = solveCubic(d, c, b, a);\n    roots[0] = 1.0 / roots[0];\n    if (roots[3] > 1.0) roots.yz = 1.0 / roots.yz;\n    return roots;\n}\n\nvec3 IntersectSphere(in vec3 ro, in vec3 rd, in float r) {\n    float a = dot(rd, rd);\n    float b = dot(2.0 * ro, rd);\n    float c = dot(ro, ro) - r * r;\n\n    vec3 info = vec3(0.0);\n    float discr = b * b - 4.0 * a * c;\n    if (discr > 0.0) {\n        float root = sqrt(discr);\n        float denom = 2.0 * a;\n        info[0] =  (root - b) / denom;\n        info[1] = -(root + b) / denom;\n        info[2] = 2.0;\n    }\n\n    return info;\n}\n\n// It might be more optimal to merge some of these together\nvec4 IntersectTrilinearSurf(in vec3 ro, in vec3 rd, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = ro.x, y = ro.y, z = ro.z;\n    float u = rd.x, v = rd.y, w = rd.z;\n\n    // Reused values\n    float ba = b - a, ca = c - a, ea = e - a;\n    float q = ba + c - d + e - f - g + h;\n    float dbac = d - ba - c, fbae = f - ba - e, gcae = g - ca - e;\n    float xy = x * y, uv = u * v;\n    float xvuy = x * v + u * y;\n\n    // Coefficients of the cubic intersection function\n    float coeff1 = q * uv * w;\n    float coeff2 = dbac * uv + (fbae * u + gcae * v) * w + (xvuy * w + uv * z) * q;\n    float coeff3 = ba * u + ca * v + ea * w + xvuy * dbac + (x * w + u * z) * fbae + (y * w + v * z) * gcae + (xy * w + xvuy * z) * q;\n    float coeff4 = a + ba * x + ca * y + ea * z + dbac * xy + (fbae * x + gcae * y) * z + q * xy * z;\n\n    return solveCubic2(coeff1, coeff2, coeff3, coeff4);\n}\n\nvec3 getTrilinearSurfNormal(in vec3 p, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = p.x, y = p.y, z = p.z;\n\n    // Reused values (largely the same as in the intersection formula)\n    float ba = b - a, ca = c - a;\n    float q = ba + c - d + e - f - g + h, qx = q * x;\n    float dbac = d - ba - c, fbae = f - ba - e, gcae = g - ca - e;\n\n    // Partial derivatives of the implicit equation wrt x, y, and z\n    float dx = ba + dbac * y + (fbae + q * y) * z;\n    float dy = ca + dbac * x + (gcae + qx) * z;\n    float dz = e - a + fbae * x + (gcae + qx) * y;\n\n    return normalize(vec3(dx, dy, dz));\n}\n\nfloat getTrilinearVolume(in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = ro.x, y = ro.y, z = ro.z;\n    float u = rd.x, v = rd.y, w = rd.z;\n\n    // Reused values\n    float ba = b - a, ca = c - a, ea = e - a;\n    float q = ba + c - d + e - f - g + h;\n    float dbac = d - ba - c, fbae = f - ba - e, gcae = g - ca - e;\n    float xy = x * y, uv = u * v;\n    float xvuy = x * v + u * y;\n\n    // Coefficients of the cubic intersection function\n    float coeff1 = q * uv * w;\n    float coeff2 = dbac * uv + (fbae * u + gcae * v) * w + (xvuy * w + uv * z) * q;\n    float coeff3 = ba * u + ca * v + ea * w + xvuy * dbac + (x * w + u * z) * fbae + (y * w + v * z) * gcae + (xy * w + xvuy * z) * q;\n    float coeff4 = a + ba * x + ca * y + ea * z + dbac * xy + (fbae * x + gcae * y) * z + q * xy * z;\n\n    // Definite integral of the intersection function from tmin to tmax\n    float m = tmin * tmin, n = tmax * tmax;\n    return 0.25 * coeff1 * (n * n - m * m) + coeff2 * (n * tmax - m * tmin) / 3.0 + 0.5 * coeff3 * (n - m) + coeff4 * (tmax - tmin);\n}\n\nbool insideTrilinearVolume(in vec3 p, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    return mix(mix(mix(a, b, p.x), mix(c, d, p.x), p.y),\n               mix(mix(e, f, p.x), mix(g, h, p.x), p.y), p.z) < 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Environment map\n    fragColor = texture(iChannel0, rd);\n\n    // Isovalues\n    float a = sin(time * 0.5) * 2.0;\n    float b = -cos(time);\n    float c = cos(time * 1.25);\n    float d = sin(time * 2.0) * 0.5;\n    float e = cos(time * 0.5) * 1.5;\n    float f = -sin(time * 1.5) * 0.25;\n    float g = sin(time);\n    float h = cos(time) * 0.75;\n\n    vec3 bSphereInfo = IntersectSphere(ro, rd, BSPHERE);\n    if (bSphereInfo[2] > 0.0) {\n        vec4 info = IntersectTrilinearSurf(ro, rd, a, b, c, d, e, f, g, h);\n\n        // Find closest valid intersection\n        vec3 hitPos;\n        float tMin = 1000000.0;\n        bool intersecting = false;\n        for (int i=0; i < int(info[3]); i++) {\n            vec3 posCandid = ro + rd * info[i];\n            float tCandid = info[i];\n            if (tCandid > 0.0 && tCandid < tMin && length(posCandid) < BSPHERE) {\n                hitPos = posCandid;\n                tMin = tCandid;\n                intersecting = true;\n            }\n        }\n\n        float start = min(bSphereInfo[0], bSphereInfo[1]);\n        float end = max(bSphereInfo[0], bSphereInfo[1]);\n\n        if (intersecting) {\n            end = tMin;\n\n            vec3 n = getTrilinearSurfNormal(hitPos, a, b, c, d, e, f, g, h);\n            n *= sign(dot(n, -rd));\n\n            float diff = max(0.0, dot(n, LIGHT));\n            float checkers = mod(floor(hitPos.x) + floor(hitPos.y) + floor(hitPos.z), 2.0);\n            fragColor = mix(vec4(0.5 + 0.5 * checkers, 0.0, 0.0, 1.0), texture(iChannel0, reflect(-rd, n)), 0.25) * diff;\n        }\n\n        // Sphere shell over solid areas of the volume\n        vec3 bSphereHit = ro + rd * start;\n        if (insideTrilinearVolume(bSphereHit, a, b, c, d, e, f, g, h)) {\n            vec3 n = bSphereHit / BSPHERE;\n            float diff = max(0.0, dot(n, LIGHT));\n            float checkers = mod(floor(bSphereHit.x) + floor(bSphereHit.y) + floor(bSphereHit.z), 2.0);\n            fragColor = mix(vec4(0.5 + 0.5 * checkers, 0.0, 0.0, 1.0), texture(iChannel0, reflect(-rd, n)), 0.25) * diff;\n        }\n\n        else {\n            float d = getTrilinearVolume(ro, rd, start, end, a, b, c, d, e, f, g, h);\n            float v = 1.0 - exp(-d * 0.175 / (end - start));\n            fragColor.rgb = mix(fragColor.rgb, mix(vec3(0.0, 0.0, 1.0), fragColor.rgb, v), v);\n        }\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.75));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}