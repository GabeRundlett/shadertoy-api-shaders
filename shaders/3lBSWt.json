{
    "Shader": {
        "info": {
            "date": "1567428876",
            "description": "Music : https://soundcloud.com/mayupuma/skydive-mayu-puma-cover (Original from Astronauts)\n\nDon't forget to restart from zero once the music has loaded!\n\nYoutube render : https://www.youtube.com/watch?v=j6aXIIC3Hm0&list=PLbRiR5PpVynZqRn_ZwiXrB8lbSs8xuZom&",
            "flags": 96,
            "hasliked": 0,
            "id": "3lBSWt",
            "likes": 1,
            "name": "Mayu Puma - Skydive VIZU",
            "published": 3,
            "tags": [
                "music",
                "zoom",
                "infinite",
                "vizu",
                "musicclip"
            ],
            "usePreview": 0,
            "username": "ttoinou",
            "viewed": 520
        },
        "renderpass": [
            {
                "code": "\n\n#define TIME(M,S,DS) (float(M)*60.+float(S)+float(DS)*.1)\nfloat t0 = .0;\nfloat t_sm_intro = 23.;\nfloat t_intro1 = TIME(0,23,9);       //23s\nfloat t_phase1 = TIME(0,48,0);       //48s\nfloat t_phase1b = 60.;               //60s\nfloat t_phase1c = 120.;              //120s\n\nfloat t_break1 = TIME(2,0,0);        //120s\nfloat t_break1b = TIME(2,24,0);      //144s\nfloat t_break1c = TIME(2,48,0);      //168s\n\nfloat t_break2 = TIME(3,12,0);       //192s\nfloat t_break2b = TIME(3,36,0);      //215s\n\nfloat t_phase2 = TIME(4,00,0);       //240s\nfloat t_phase2b = TIME(4,23,5);      //263s\n\nfloat t_outro = TIME(4,48,0);        //288s\nfloat t_end = TIME(5,20,0);          //320s\n\n//#define SHOW_FFT\n#define SHOW_FFT_POINT (.047)\n//#define SHOW_WHEEL\n\n#define dx (iMouse.x/iResolution.x)\n#define dy (iMouse.y/iResolution.y)\n\n#define to01(x)  (clamp(x,0.0,1.0))\n#define to01_(x) (smoothstep(0.0,1.0,x))\n\n#define ABto01(x,a,b)  (to01( (x-a)/(b-a) ))\n#define ABto01_(x,a,b) (to01_( (x-a)/(b-a) ))\n\n#define ABtoCD(x,a,b,c,d)  (ABto01(x,a,b)*(d-c)+c)\n#define ABtoCD_(x,a,b,c,d) (ABto01_(x,a,b)*(d-c)+c)\n\n#define PI (3.14159265359)\n#define TWOPI (3.14159265359*2.0)\n\n//https://www.shadertoy.com/view/XtVGDz\n\n#define sound iChannel0\n\nfloat min2(vec2 v) { return (v.x<v.y) ? v.x : v.y;}\nfloat max2(vec2 v) { return (v.x>v.y) ? v.x : v.y;}\nfloat min3(vec3 v) { float t = (v.x<v.y) ? v.x : v.y; t = (t<v.z) ? t : v.z; return t;}\nfloat max3(vec3 v){float t = (v.x>v.y) ? v.x : v.y;t = (t>v.z) ? t : v.z;return t;}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n#define fftMin 0.1\n#define fftH 2.0\n\nfloat fftmul(float i){\n    return i*fftH*(i*fftH+0.8)*1.5 + 0.1;\n}\n\n\nvec4 spectr(vec4 k){\n    return 2.0*abs(k*k*k);\n    return k;\n    return 1.2*k*k;\n}\n\nvec4 fft(float freq,float time){\n    if( iTime > t_end)\n        return vec4(.0);\n    \n    return texture(sound,vec2(freq,time));\n}\n\nfloat repeat(float x,float y){\n    x = mod(x,2.0*y);\n    if( x > y ){\n        x = 2.0*y - x;\n    }\n    //return x;\n    return mod(x+y,y);\n}\n\nvec3 bar(vec2 uv){\n    float mul = fftmul( uv.y );\n    vec4 fft1 = fft(uv.x,0.0);\n    \n    if( abs(uv.x-SHOW_FFT_POINT) < .002 && uv.y < .2 )\n    {\n        return vec3(.0);\n    }\n    \n\treturn vec3(\n        mul*float(fft1.r - fftMin > fftH*uv.y),\n        mul*float(fft1.g - fftMin > fftH*uv.y) ,\n        mul*float(fft1.b - fftMin > fftH*uv.y)\n    );\n}\n\n\n//https://www.shadertoy.com/view/ldSBRK\nvec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {\n    return (line1y - line2y) / (line2x - line1x);\n}\n\nvec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {\n    return sqrt(pointx*pointx + pointy*pointy);\n}\n\nvec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {\n    vec3 len = y / (sin(theta) - x * cos(theta));\n    if (len.r < 0.0) {len.r=1000.0;}\n    if (len.g < 0.0) {len.g=1000.0;}\n    if (len.b < 0.0) {len.b=1000.0;}\n    return len;\n}\n\nfloat hsluv_maxSafeChromaForL(float L){\n    mat3 m2 = mat3(\n         3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n        -1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n        -0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n    );\n    float sub0 = L + 16.0;\n    float sub1 = sub0 * sub0 * sub0 * .000000641;\n    float sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n    vec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n    vec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n    vec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n    vec3 bounds0x = top1 / bottom;\n    vec3 bounds0y = top2 / bottom;\n\n    vec3 bounds1x =              top1 / (bottom+126452.0);\n    vec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);\n\n    vec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );\n    vec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );\n\n    vec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );\n    vec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );\n\n    return  min(lengths0.r,\n            min(lengths1.r,\n            min(lengths0.g,\n            min(lengths1.g,\n            min(lengths0.b,\n                lengths1.b)))));\n}\n\nfloat hsluv_maxChromaForLH(float L, float H) {\n\n    float hrad = radians(H);\n\n    mat3 m2 = mat3(\n         3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n        -1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n        -0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n    );\n    float sub1 = pow(L + 16.0, 3.0) / 1560896.0;\n    float sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n    vec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n    vec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n    vec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n    vec3 bound0x = top1 / bottom;\n    vec3 bound0y = top2 / bottom;\n\n    vec3 bound1x =              top1 / (bottom+126452.0);\n    vec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);\n\n    vec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );\n    vec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );\n\n    return  min(lengths0.r,\n            min(lengths1.r,\n            min(lengths0.g,\n            min(lengths1.g,\n            min(lengths0.b,\n                lengths1.b)))));\n}\n\nfloat hsluv_fromLinear(float c) {\n    return c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\nvec3 hsluv_fromLinear(vec3 c) {\n    return vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );\n}\n\nfloat hsluv_toLinear(float c) {\n    return c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;\n}\n\nvec3 hsluv_toLinear(vec3 c) {\n    return vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );\n}\n\nfloat hsluv_yToL(float Y){\n    return Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;\n}\n\nfloat hsluv_lToY(float L) {\n    return L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);\n}\n\nvec3 xyzToRgb(vec3 tuple) {\n    const mat3 m = mat3( \n        3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ,\n       -0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613,\n        0.055630079696993609,-0.20397695888897657, 1.0569715142428786  );\n    \n    return hsluv_fromLinear(tuple*m);\n}\n\nvec3 rgbToXyz(vec3 tuple) {\n    const mat3 m = mat3(\n        0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,\n        0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,\n        0.019330818715591851, 0.11919477979462599, 0.95053215224966058 \n    );\n    return hsluv_toLinear(tuple) * m;\n}\n\nvec3 xyzToLuv(vec3 tuple){\n    float X = tuple.x;\n    float Y = tuple.y;\n    float Z = tuple.z;\n\n    float L = hsluv_yToL(Y);\n    \n    float div = 1./dot(tuple,vec3(1,15,3)); \n\n    return vec3(\n        1.,\n        (52. * (X*div) - 2.57179),\n        (117.* (Y*div) - 6.08816)\n    ) * L;\n}\n\n\nvec3 luvToXyz(vec3 tuple) {\n    float L = tuple.x;\n\n    float U = tuple.y / (13.0 * L) + 0.19783000664283681;\n    float V = tuple.z / (13.0 * L) + 0.468319994938791;\n\n    float Y = hsluv_lToY(L);\n    float X = 2.25 * U * Y / V;\n    float Z = (3./V - 5.)*Y - (X/3.);\n\n    return vec3(X, Y, Z);\n}\n\nvec3 luvToLch(vec3 tuple) {\n    float L = tuple.x;\n    float U = tuple.y;\n    float V = tuple.z;\n\n    float C = length(tuple.yz);\n    float H = degrees(atan(V,U));\n    if (H < 0.0) {\n        H = 360.0 + H;\n    }\n    \n    return vec3(L, C, H);\n}\n\nvec3 lchToLuv(vec3 tuple) {\n    float hrad = radians(tuple.b);\n    return vec3(\n        tuple.r,\n        cos(hrad) * tuple.g,\n        sin(hrad) * tuple.g\n    );\n}\n\nvec3 hsluvToLch(vec3 tuple) {\n    tuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * .01;\n    return tuple.bgr;\n}\n\nvec3 lchToHsluv(vec3 tuple) {\n    tuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * .01;\n    return tuple.bgr;\n}\n\nvec3 hpluvToLch(vec3 tuple) {\n    tuple.g *= hsluv_maxSafeChromaForL(tuple.b) * .01;\n    return tuple.bgr;\n}\n\nvec3 lchToHpluv(vec3 tuple) {\n    tuple.g /= hsluv_maxSafeChromaForL(tuple.r) * .01;\n    return tuple.bgr;\n}\n\nvec3 lchToRgb(vec3 tuple) {\n    return xyzToRgb(luvToXyz(lchToLuv(tuple)));\n}\n\nvec3 rgbToLch(vec3 tuple) {\n    return luvToLch(xyzToLuv(rgbToXyz(tuple)));\n}\n\nvec3 hsluvToRgb(vec3 tuple) {\n    return lchToRgb(hsluvToLch(tuple));\n}\n\nvec3 rgbToHsluv(vec3 tuple) {\n    return lchToHsluv(rgbToLch(tuple));\n}\n\nvec3 hpluvToRgb(vec3 tuple) {\n    return lchToRgb(hpluvToLch(tuple));\n}\n\nvec3 rgbToHpluv(vec3 tuple) {\n    return lchToHpluv(rgbToLch(tuple));\n}\n\nvec3 luvToRgb(vec3 tuple){\n    return xyzToRgb(luvToXyz(tuple));\n}\n\n\n\n\n\n// https://www.shadertoy.com/view/lsjfDm\nvec2 polar( float k , float t )\n{\n  return k*vec2(cos(t),sin(t));\n}\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cexp( vec2 z ) { return polar(exp(z.x) , z.y ); }\nvec2 clog( vec2 z ) { return vec2( log(length(z)) , atan(z.y , z.x) ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 cpow( vec2 z , float k ) { return polar(pow(length(z),k) , k*atan(z.y,z.x) ); }\n\n\n\n\nfloat normP = 2.0;\nfloat norm(vec2 uv)\n{\n    return pow( pow(abs(uv.x),normP) + pow(abs(uv.y),normP) , 1./normP );\n}\n\nfloat roseK = 7.;\nfloat roseT;\n// todo: be abnle to choose SL from main code\nvec2 roseHS(float a)\n{\n    float r = cos(roseK*a*TWOPI+roseT);\n    return vec2(\n        mod( a*360. + (r < 0. ? 180. : 0.) , 360.),\n        sqrt(abs(r))*100.\n    );\n}\n\nvec3 roseColor(float a)\n{\n    return hsluvToRgb(vec3(roseHS(a),50.));\n    //return hpluvToRgb(vec3(roseHS(a),50.));\n}\n\n// use need double mod to handle negative values\nfloat mod_(float x,float k) {\n    return mod(mod(x,k)+k,k);\n}\n\nfloat modc(float x,float k) {\n    return mod_(x,k)/(k-1.);\n}\n    \nfloat modi(float x,float k) {\n    return floor(mod_(x,k))/(k-1.);\n}\n\n\nvoid ZoomRotationNorm_ForPhase1(float time){\n}\n\nvoid mainImage( out vec4 col, in vec2 coord ) {\n\tvec2 uv01 = coord.xy / iResolution.xy;\n    vec2 uv = (coord-iResolution.xy*.5)/min2(iResolution.xy)*2.;\n    float n,rotation,ln,angle,zoom,m,m2,a,b,c;\n    vec4 a4;\n    vec3 col3;\n    vec3 white = vec3(1.25);\n    vec3 black = vec3(.0);\n    float t = iTime;\n    \n    t *= pow(ABto01_(t,t0,t_sm_intro),.7);\n    float tForSpiral = t;\n    \n    //rotation = -tForSpiral/sqrt(7.); uv = rotate(uv,rotation);\n    \n    //todo: at the end, do not rotate anymore\n    \n    if(t> t_phase1b)\n    {\n        c = ABto01_(t,t_phase1b,t_phase1c+10.);\n        \n        //uv = cmul( uv + deformation_pole , uv - deformation_pole );\n        \n\t\t/*float dipole = 2./3.;\n\t\tvec2 uv_ =\n            //cdiv(\n            cmul(\n              uv + // vec2(dipole,.0)\n                 vec2(mix(.0,dipole,c),.0)\n            , cpow(\n                uv - // vec2(dipole,.0)\n                 vec2(mix(exp( (1.-c)*2. ),dipole,c),.0)\n              //, ABto01_(t,t_phase1b,t_phase1b+10.)\n              , 1.\n            )\n        );\n        \n        uv_ = cmul(uv,uv_);*/\n       vec2 dipole = vec2(7./8.,.0);\n        \n        float rotationStart = t_break1c;\n       float d = ABto01_(tForSpiral,rotationStart,t_break2b);\n        \n        \n       dipole = mix( vec2(exp( (1.-c)*2. ) , .0 ),dipole,c);\n\n       // left and right well rotating\n       dipole = rotate(dipole,-d*(tForSpiral-rotationStart)/sqrt(57.));\n        \n        // zooming back to main well\n        float e = ABto01(tForSpiral,rotationStart,t_outro-20.);//t_phase2+20.);\n        //uv /= (1. + 7.*e*e*e);\n        uv *= 1. - .58*e;\n        \n        \n        vec2 uv_ = cmul(\n              uv + dipole\n            , uv - dipole\n        );\n        //t_break2 \n        // doesn't look great and buggy (messes up the rest of the video)\n        /*\n\n       float circle = dipole.x;\n       circle = mix( exp( (1.-d)*2. ),circle,d);\n\nfloat angle = TWOPI/6.;\n        vec2 circle1 = cmul(\n              uv + polar(circle,angle*1.)\n            , uv + polar(circle,angle*2.)\n        );\n        \n        vec2 circle2 = cmul(\n              uv + polar(circle,angle*4.)\n            , uv + polar(circle,angle*5.)\n        );\n                \n        vec2 circle3 = cmul(circle1,circle2);\n        uv_ = cmul(uv_,circle3);*/\n        \n        uv_ = cmul(uv,uv_);\n        \n        uv = uv_;\n        /*uv = mix(uv,uv_,\n                 ABto01_(t,t_phase1b,t_phase1b+10.)\n                 //c\n        );*/\n    }\n   \n    \n    col3 = white;\n    roseT = tForSpiral/sqrt(33.); // for colors\n    \n    // Settings rotation,zoom,normP values\n    \n    rotation = tForSpiral/sqrt(19.);\n    \n    zoom = -.7 + tForSpiral*.25;\n    \n    normP = cos(tForSpiral/11.)*2.+3.;\n    \n    if( tForSpiral > t_phase1 )\n    {\n        normP = 10. - (sin(tForSpiral/3.)*.5+.5)*9.;\n    }\n    \n    if(tForSpiral> t_phase1b)\n    {\n    \trotation = tForSpiral/sqrt(7.);\n        normP = mix(1.25,10., sin(tForSpiral/7.)*.5+.5 );\n        zoom -= .8;\n    }\n    \n    if(tForSpiral> t_break1b && ( tForSpiral < t_break2b || tForSpiral > t_outro) )\n    {\n       zoom = -.8 + tForSpiral*.6;\n       zoom += ( -fft(.85,.0).b*.7 + fft(.047,.0).r - .3 )*.6;\n       //zoom += fft(.85,.0).b*.1;\n    }\n    \n    bool isFinale = tForSpiral > t_phase2 && tForSpiral < t_outro;\n    float finaleCoeff = ABto01(tForSpiral,t_phase2,t_outro);\n        \n    if(isFinale)\n    {\n        rotation = -tForSpiral/sqrt(3.);\n        normP = mix(0.4,2., -cos(tForSpiral/4.)*.5+.5 );\n    \tzoom = -pow(finaleCoeff,1.5)*100.;\n    }\n    \n    //normP = 0.0001;\n    \n    // /Settings rotation,zoom,normP values\n    \n    uv = rotate(uv,rotation);\n    \n    n = norm(uv);\n    ln = log(n)+zoom;\n    angle = atan(uv.y,uv.x)/TWOPI;\n    \n    //if( n < 1. ) col = vec4(.5);\n    \n    // intro 1\n    m = mod(ln,4.);\n    if( m < 1. && ln > -2. ) col3 = roseColor(modi(ln,7.)) ;\n    \n    // intro 2\n    if( t > t_intro1 && 2. < m && m < 3. && ln > 3.)\n        col3 = mix( white ,\n        \troseColor(modi(ln,7.))\n        \t* (t > t_intro1 ? fft(.05,.0).r : .0)\n          , ABto01_(t,t_break2,t_intro1+.5) )\n        ;\n    \n    // intro fade in\n    col3 = mix( white ,col3 , sqrt(ABto01(t,t0,t_sm_intro)) );\n    \n    if(t > t_phase1)\n    {\n    \t//m2 = mod(ln,6.);\n        \n        n = modi(ln,7.);\n        \n        float endIncrease = ABto01_(t,t_phase1,t_outro);\n        \n        float freq = mod_(5.*n+t/17.,1.)*.8+0.1;\n        if(isFinale)\n            freq = repeat(   ln*(mix(1./60.,1./6.,pow(finaleCoeff,1.6)))  ,.5);\n        \n        bool enableDoubleSpiral = isFinale;\n        // + float(enableDoubleSpiral)*pow(finaleCoeff,1.2)*1.1\n        //enableDoubleSpiral = false;\n        \n        enableDoubleSpiral = tForSpiral > t_break2b && !isFinale;\n        \n       // freq = .1;\n        a4 = fft(freq,.0);\n        // todo: use second argument of fft to go back in time\n        // and create soft boundaries around each stripe\n        //a4 = fft(.5,.0);\n        \n        //float(endOfVideo)*\n        // - tForSpiral*.2\n        \n        float musicFactor = max(.0,a4.g-.05)*.5 + .2;\n        if(isFinale)\n            musicFactor = a4.r+.1;\n        else if(tForSpiral > t_outro)\n            musicFactor = a4.g-.2;\n        \n        col3 = roseColor(\n                 modi(ln - float(enableDoubleSpiral)*tForSpiral\n                      *( tForSpiral > t_outro ? 10.7 /* doesnt work anymore */ : 1.2 )\n                  ,( tForSpiral > t_outro ? 3. : 4. ))\n               - tForSpiral*.0145\n            )\n            //  ln+tForSpiral = craaazy ! double zoom // +tForSpiral/10.\n            * musicFactor\n            // coeff to increase when music gets intense at the end\n            * mix(.75,2.,endIncrease)\n        ;\n        \n        /*a = mod_(ln,1.);\n        a = min(a,1.-a);\n        col3 = mix(black,col3,\n        \tABto01_( a , .0 , .03 )\n        );*/\n        \n        \n        //if( a < .01 ) col3 = white;\n    }\n    \n    if(t> t_phase1b)\n    {\n        \n    }\n   \n    \n    #ifdef SHOW_WHEEL\n    \tnormP = 2.;\n    \tn = norm(uv);\n    \tvec3 wheelCoord = vec3(\n            atan(uv.y,uv.x)/TWOPI*360. + 180.,\n            n*100.,\n            n < 1. ? 50. : .0\n        );\n    \tvec3 wheel = hpluvToRgb(wheelCoord);\n    \twheel = hsluvToRgb(wheelCoord);\n    \n    \tfloat iMax = 99.;\n    \tfor(float i = 0. ; i < iMax ; i++)\n        {\n            vec2 p = roseHS(i/iMax);\n            float d = length( wheelCoord.xy-p );\n            if(d< 3.)\n            {\n                wheel = vec3(1.,0.,0.);\n            }\n        }\n    \tcol3 = wheel;\n    \t\n    #endif\n    \n    #ifdef SHOW_FFT\n\t\tcol3 += bar(uv01);\n\t\t//fragColor += bar(vec2(1.0) - uv);\n\t#endif\n    \n    float coeffAllVideo = ABto01_(t,t0,t_end);\n    col = tanh(vec4(col3,1.)*mix(1.,2.5,coeffAllVideo));\n    //col = vec4(col3,1.);\n    //fragColor = texture(iChannel0,uv);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define dx iMouse.x/iResolution.x\n#define dy iMouse.y/iResolution.y\n\n#define buffer iChannel0\n#define sound  iChannel1\n#define soundRes iChannelResolution[1]\n#define step 1.0/iResolution.y\n\n//https://www.shadertoy.com/view/XtVGDz\n\n// fft Options\n#define inputSound iChannel0\n#define fftWidth \t\t1.0\t\t\t// width of fft texture (why not 512.0 ?! )\n\n#define fftSmooth \t\t1.3\t\t\t// smoothness coeff\n#define fftPreamp\t\t0.65\t\t// pre amp before dynamic\n#define fftBoost  \t\t0.14\t\t// dynamic amp\n#define fftAmp\t\t\t0.7\t\t\t// pre amp before dynamic\n#define fftMinBass \t\t0.00196 \t// 1.0/512.0\n#define noiseLevel      0.05\n\n#define fftRadiusR\t\t8.0/512.0\n#define fftRadiusG\t\t8.0/512.0*4.0\n#define fftRadiusB\t\t8.0/512.0*4.0*4.0\n#define fftSamplesR \t8 // number of iteration for fft sampling, increases quality !\n#define fftSamplesG \t8*4\n#define fftSamplesB \t8*4*4\n#define fftGBGain       1.1\n\n#define to01(x) clamp(x,0.0,1.0)\n\nfloat remapIntensity(float f, float i){\n  // noise level\n  i = to01( (i - noiseLevel) / (1.0 - noiseLevel) );\n  float k = f-1.0;\n  // preamp, x2 for trebles -> x1 for bass\n  //i *= ( 2.0 - 1.0*k*k ) * fftPreamp;\n  //i *= ( 3.0 - 1.5*k*k ) * fftPreamp;\n  i *= ( 3.0 - 1.6*k*k ) * fftPreamp;\n  // more dynamic\n  i *= (i+fftBoost);\n  // limiter\n  return i*fftAmp;\n  // limiter, kills dynamic when too loud\n  //return 1.0 - 1.0 / ( i*4.0 + 1.0 );\n}\n\nfloat remapFreq(float freq){\n // linear scale\n //return clamp(freq,fftMinBass,1.0);\n // log scale\n return clamp(to01(- log(1.0-freq/2.0 + fftMinBass*8.0)),fftMinBass,1.0);\n}\n\nfloat fftR(float f){\n    float sum = 0.0;\n    float val = 0.0;\n    float coeff = 0.0;\n    float k = 0.0;\n    for( int i = 0; i < fftSamplesR ; i++ ){\n        k = float(i)/float(fftSamplesR-1)-0.5;\n        coeff = exp(-k*k/(fftSmooth*fftSmooth)*2.0);\n\t\tval += texture(sound, vec2( remapFreq(f + k * fftRadiusR)*fftWidth, 0.0) ).r * coeff;\n        sum += coeff;\n    }\n    return remapIntensity(f,val/sum);\n}\n\nfloat fftG(float f){\n    float sum = 0.0;\n    float val = 0.0;\n    float coeff = 0.0;\n    float k = 0.0;\n    for( int i = 0; i < fftSamplesG ; i++ ){\n        k = float(i)/float(fftSamplesG-1)-0.5;\n        coeff = exp(-k*k/(fftSmooth*fftSmooth)*2.0);\n\t\tval += texture(sound, vec2( remapFreq(f + k * fftRadiusG)*fftWidth, 0.0) ).r * coeff;\n        sum += coeff;\n    }\n    return remapIntensity(f,val/sum)*fftGBGain;\n}\n\nfloat fftB(float f){\n    float sum = 0.0;\n    float val = 0.0;\n    float coeff = 0.0;\n    float k = 0.0;\n    for( int i = 0; i < fftSamplesB ; i++ ){\n        k = float(i)/float(fftSamplesB-1)-0.5;\n        coeff = exp(-k*k/(fftSmooth*fftSmooth)*2.0);\n\t\tval += texture(sound, vec2( remapFreq(f + k * fftRadiusB)*fftWidth, 0.0) ).r * coeff;\n        sum += coeff;\n    }\n    return remapIntensity(f,val/sum)*fftGBGain*fftGBGain;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n   \t// black by default\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    \n    float k = texture( iChannel2, vec2(82.5/256.0,0.0) ).x;\n\n     // key R => Reset\n    if( abs(k) < 0.1 ){\n        // store current fft\n        if( fragCoord.y <= 1.0 ){\n            \n            float freq = uv.x;\n            float i1,i2,i3;\n\n            i1 = fftR(freq);\n            i2 = fftG(freq);\n            i3 = fftB(freq);\n\n            fragColor = vec4(i1,i2,i3,1.0);\n            \n        // store previous fft\n        } else if( fragCoord.y < iResolution.y - 1.0 ) {\n            fragColor=texture(buffer,vec2(uv.x,uv.y - step));\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 19421,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/mayupuma/skydive-mayu-puma-cover"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}