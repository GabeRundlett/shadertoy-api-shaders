{
    "Shader": {
        "info": {
            "date": "1666491539",
            "description": "kind of fractal architecture experiment.\nclick and drag the mouse to change the camera position.\n\nsry for compile times and slow speed.\nruns smoothly on a gtx2070 in fullhd.\nDOF or TAA would propably help.",
            "flags": 0,
            "hasliked": 0,
            "id": "cslGDM",
            "likes": 32,
            "name": "Fractal Cabin In The Woods",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "fractal",
                "kifs",
                "forrest",
                "cabin",
                "woods",
                "mk3drmb"
            ],
            "usePreview": 0,
            "username": "derSchamane",
            "viewed": 510
        },
        "renderpass": [
            {
                "code": "//               = Fractal Cabin In The Woods =         \n//               by Maximilian Knape  ·∑>| 2022            \n// -----------------------------------------------------------\n// This work is licensed under a Creative Commons Attribution-\n//        NonCommercial-ShareAlike 3.0 Unported License\n\n#define GAMMA vec3(.4545)\n\n#define MAX_STEPS 180\n#define STEP_FAC 0.8\n#define MAX_DIST 1000.\n#define MIN_DIST 1.\n\n#define SURF_DIST .005\n#define SURF_MUL 2000.\n#define SURF_EXP 1.4\n\n#define PP_GLOW 0.6\n#define PP_ACES 0.5\n#define PP_CONT 0.4\n#define PP_VIGN 2.0\n#define AO_OCC 0.3\n#define AO_SCA 0.4\n\n#define AA_ENAB false //compile time warning\n#define AA_THRE .03   //fps warning\n\n#define CAM_MOVEMENT true //set false to stop animation\n\n#define iTime iTime*1.\n#define PI 3.14159265358979\n#define S(x,y,t) smoothstep(x,y,t)\n#define cAngle vec2(cos(PI/12.), sin(PI/12.))\n\nvec2 Map(in vec3 p) \n{   \n    //puh, that escalated quickly..\n    //wanted a simple small room - steady image\n    //therefore needed a house and a world around\n    //ended up here, a bit messy but I like it. <3\n    \n    float d = 10e10, col;\n    float dis = length(p.xz);\n    \n    //ground\n    float terrain = max(0., p.y + 3.*dot(sin(p/13.-2.3), cos(p/21.-15.5)) + \n                    pow((p.x+100.)/100., 3.) + pow(p.z/50., 2.) - 3.);\n    col = 3.1 + step(100.,dis)*5.1;\n    d = terrain*.8;\n    \n    //grass\n    if (dis < 100.) \n    {   //it works, but nothing more\n        float grass = max(0.,terrain - .1 - .6*noise(p.xz/8.1-14.3) + \n                      .13*noise(p.xz*11.11+32.) * S(100., 0., dis));\n        grass = mix(grass, terrain, pow(S(30.+grass*50.,3., dis), 2.));\n        if (p.x > 0.) grass = mix(grass, terrain - .1*(noise(p.zx * vec2(10.,2.))-.5), \n            S(3., 1.5, abs(p.z -5.*pow(sin((p.x-10.)/30.), 3.)) + .1*cos(p.z*5.)));\n        col = mix(col, 8.05 + grass*.3, step(grass, d));\n        d = min(d, grass * S(-100., 100., dis));\n    }\n    \n    //forest\n    if (dis > 50.) \n    {   //bob style\n        float tree = MAX_DIST; \n        const float gridSize = 30.;\n        vec3 pos = mod(p.xyz, vec3(gridSize)) - vec3(gridSize/2.);\n        pos.xz += (vec2(noise(round(p.xz/gridSize-.5)))*2.-1.) * gridSize/2.4;\n        float wind = S(.5, 1., noise(p.xz/100. + vec2(iTime/12.) + p.y/300.)) * (p.y-terrain)/10. * (1.-dis/MAX_DIST);\n        pos.y = terrain -5.;\n        float needles = fract(-p.y/4. + .5*noise(pos.xz*5.1) + atan(10.*(pos.x/pos.z+p.z))) * 10.;\n        tree = max(dot(cAngle, vec2(length(pos.xz + wind), pos.y - needles - S(30., 300., dis)*60.+10.)), -pos.y-needles+1.);\n        col = mix(col, 7.3, step(tree, d));\n        d = min(d, tree * (S(50., MAX_DIST, dis)+.4));\n    } \n    \n    //house\n    if (dis < 30.) \n    {   //earthship, seams liveable in some kind \n        float house;\n        float frame = sdKMC(p - vec3(0,0,0), 10, vec3(0,4,0), vec3(0.001), vec4(4,3,10.+ step(-p.y, -10.)*(p.x+15.)/15.,10)).x;\n        col = mix(col, 1.7, step(frame, d));\n        house = min(d, frame);\n\n        float screed = length(max(vec3(0.), abs(vec3(0,-4.7,0) + p) - vec3(9.5,.1,9.5))) - .1;\n        col = mix(col, 6.1, step(screed, house));\n        house = min(house, max(screed, -(length(p - vec3(0,5,0)) - 4.4)));\n\n        vec3 rot = p;\n        rot.xy *= Rot(-.07);\n        float roof = length(max(vec3(0.), abs(rot/vec3(1, 1.+ cos(rot.z*20.)*.004,1) - vec3(2,11,0)) - vec3(12,.03,12))) - .03;\n        col = mix(col, 5.9, step(roof, house));\n        house = min(house, max(roof, -(length(p - vec3(0,10,0)) - 3.5)));\n\n        float lSph = length(rot / vec3(1.2,.3,1.2) - vec3(0.6,36,0)) - 3.;\n        col = mix(col, -0.2, step(lSph, house));\n        house = min(house, lSph*.6);\n\n        float concrete = sdKMC(p/1.05 - vec3(0,-5,0), 8, vec3(-5), vec3(0.), vec4(4,3,12,13)).x;\n        col = mix(col, 2.2, step(concrete, house));\n        house = min(house, concrete);\n\n        if (step(-5., -p.y) * step(-1., p.y) * step(-10., -length(p.xz)) > 0.)\n        {\n            rot = p; //messy stairs\n            rot.xz *= Rot(0.65 * floor((p.y)*5.)/5.);\n            rot = max(abs(rot - vec3(0,-3,4)) - vec3(.2+.4*step(4.8,p.y), .2, 2.-1.5*S(3., 5., p.y)), 0.);\n            float stairs = length(mod(rot, vec3(0,.2,0)))-.01;\n            col = mix(col, 9.2, step(stairs, house));\n            house = min(house, stairs*.8); \n            \n            float sphere = length(p - vec3(0,.3,0)) - 1.;\n            col = mix(col, 4.6, step(sphere, house));\n            house = min(house, sphere);\n        }\n        \n        d = mix(smin(terrain, house, 1.3), d, S(20., 30., dis));\n    }\n\n    return vec2(d, col);\n}\n\nvec3 Normal(in vec3 p) \n{\n    const vec2 e = vec2(.005, 0);\n    return normalize(Map(p).x - vec3(Map(p-e.xyy).x, Map(p-e.yxy).x,Map(p-e.yyx).x));\n}\n\nvec3 RayMarch(in vec3 ro, in vec3 rd) \n{\n    float col = 0.;\n\tfloat dO = MIN_DIST;\n    int steps = 0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) \n    {\n        steps = i;\n        \n    \tvec3 p = ro + rd*dO;\n        vec2 dS = Map(p);\n        col = dS.y;\n        dO += dS.x * mix(STEP_FAC, 1., dO/MAX_DIST);\n        \n        if (dO > MAX_DIST || dS.x < (SURF_DIST * (pow(dO/MAX_DIST, SURF_EXP)*SURF_MUL+1.))) break;\n    }\n    \n    return vec3(dO, steps, col);\n}\n\nfloat SoftShadow(in vec3 ro, in vec3 lp, in float k) //Shane\n{\n    if (length(ro) > 200.) return 1.;\n\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro;\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    for (int i = 0; i<maxIterationsShad; i++)\n    {\n\n        float h = Map(ro + rd*dist).x;\n        shade = min(shade, smoothstep(0., 1., k*h/dist));\n        dist += clamp(h, .02, .25);\n        \n        if (h < .0 || dist > end) break;\n    }\n\n    return min(max(shade, 0.) + .1, 1.); \n}\n\n\nfloat CalcAO(in vec3 p, in vec3 n) //iq\n{\n    float occ = AO_OCC;\n    float sca = AO_SCA;\n\n    for( int i = 0; i < 5 ; i++ )\n    {\n        float h = 0.001 + 0.150 * float(i) / 4.0;\n        float d = Map(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= 0.95;\n    }\n    return S(0.0, 1.0 , 1.0 - 1.5 * occ);    \n}\n\n\nconst vec3 ambCol = vec3(.01,.02,.03) * 4.0;\nconst vec3 sunCol = vec3(1., .9, .8) * 1.2;\nconst vec3 skyCol = vec3(.3, .6, 1.) * 1.0;\nconst float specExp = 12.;\n\nvec3 Shade( in vec3 col, \n            in float mat, \n            in vec3 p, \n            in vec3 n, \n            in vec3 rd, \n            in vec3 lP) \n{\n    vec3  lidi = normalize(lP - p);\n    float mafa = max(mat, .0),\n          amoc = CalcAO(p, n),\n          shad = SoftShadow(p + n*.015, lP, 2.),\n          diff = max(dot(n, lidi), 0.) * shad,\n          spec = pow(diff, max(1., specExp * mafa)),\n          refl = pow(max(0., dot(lidi, reflect(rd, n))), max(1., specExp * 3. * mafa)) * shad;\n    vec3  ambc = mix(sunCol/8., ambCol, S(10., 20., length(p.xz))*.2+.6);\n          \n    return mix( ambc * col * amoc +                           //ambient\n                mix(diff * col * sunCol,                      //diffuse\n                (spec * col + refl * mafa), mafa) * sunCol,   //specular\n                \n                col  * S(0., 1., amoc * amoc + .5),           //emission\n                max(-mat, 0.));\n}\n\nvec3 Palette(int index, in vec3 p)\n{\n    switch (index)\n    {\n        case 0: return vec3(1.);                                       //lightsphere\n        case 1: return vec3(.8, .4, .35);                              //frame\n        case 2: return vec3(.6, .6, .6);                               //concrete\n        case 3: return vec3(.4, .3, .2)*(.25 + .25*noise(-p.xz/PI));   //terrain\n        case 4: return hsv2rgb_smooth(vec3(fract(iTime/21.), .8, .8)); //sphere\n        case 5: return vec3(.2, .6, .8);                               //roof\n        case 6: return vec3(.5);\n        case 7: return vec3(.3, .8, .2)*(.1 + .1*noise(p.xz/10.));     //trees\n        case 8: return vec3(.5, .8, .2)*(.13 + .15*noise(p.xz/6.2));   //grass\n        case 9: return vec3(.8, .5, .2)*(.2 + .4*noise(p.xy*vec2(.1,100.))); //messy stairs\n    }\n    return vec3(0.);\n}\n\nvoid Render( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5 * iResolution.xy) / iResolution.y;\n\tvec2 m = S(vec2(0), vec2(1), iMouse.xy / iResolution.xy);\n\n    if (length(m) <= 0.) m = vec2(0.65,.9);\n    if (CAM_MOVEMENT && !AA_ENAB) \n        m = mix(m, pow(vec2(sin(iTime/69.-1.), -cos(iTime/69.)), vec2(3)) *\n            vec2(.6, .3) + vec2(.6, .6), S(10., 100., (iMouse.z > 0.) ? 0. : iTime));\n\n    vec3 ro = vec3(-1., 3., -8.-m.x*60.);\n    ro.yz *= Rot(-m.y * PI/4. + PI/4.);\n    ro.xz *= Rot(-m.x * PI * 2.);\n    vec3 rd = R(uv, ro, vec3(0., 5., 0.), .8);\n    \n    vec3 bg = skyCol * (.2 + S(-.1, 0.3, dot(rd, vec3(0,1,0))));\n    vec3 lPos = vec3(2,2,-2)*100.; \n    vec3 col = bg;\n    vec3 p = vec3(0.);\n    \n    vec3 rmd = RayMarch(ro, rd);\n\n    if(rmd.x < MAX_DIST) \n    {\n        p = ro + rd * rmd.x;\n        vec3 n = Normal(p);\n        \n        float shine = fract(rmd.z)*abs(rmd.z)/rmd.z;\n        int index = int(floor(abs(rmd.z)));\n        col = Palette(index, p);\n        \n        if (index == 3) n *= .8 + .6*noise(p.xz*33.);\n        if (index == 8) n *= mix(.7 + .6*noise(p.xz*7.), 1., S(10., 150., rmd.x));\n        \n        col = Shade(col, shine, p, n, rd, lPos);   \n        //col = vec3(1) * CalcAO(p, n);\n    }\n    \n    float disFac = S(0., 1., pow(rmd.x / MAX_DIST, 1.2));\n    \n    col = mix(col, bg, disFac);\n\n    float sdir = dot(normalize(lPos-ro), rd);\n    float sblend =  pow(S(0.1, 1.2, sdir), 3.)*.6 + \n                    pow(max(sdir,0.01), 2000.);\n    col += sblend * disFac * sunCol;\n    \n    float glow = pow(rmd.y / float(MAX_STEPS), 1.2) + sblend*sblend;\n    col += glow * normalize(mix(sunCol/10., ambCol, S(10., 20., length(p.xz))*.5+.5)) * PP_GLOW;\n    \n    float hfog = S(0.3, .8, noise(p.zx/100.+vec2(iTime/21.))) * S(25., -10., p.y) * S(0., .05, disFac);\n    col += glow * hfog * .8;\n    \n    \n    fragColor = vec4(col,1.0);\n}\n\nvec4 PP(vec3 col, vec2 uv)\n{\n    col = mix(col, (col * (2.51 * col + 0.03)) / (col * (2.43 * col + 0.59) + 0.14), PP_ACES);\n    col = mix(col, S(vec3(0.), vec3(1.), col), PP_CONT);  \n    col *= S(PP_VIGN,-PP_VIGN/5., dot(uv,uv)); \n    col = pow(col, GAMMA);\n    \n    return vec4(col, 1.);\n}\n\n//totally unusable in realtime.\nvoid mainImage(out vec4 O, vec2 U) //Fabrice - easy adaptive super sampling | edited\n{\n    Render(O,U);\n    \n    if (AA_ENAB && fwidth(length(O)) > AA_THRE)\n    {\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { Render(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n        //O.r++; //Show sampled area\n    }\n    \n    O = PP(vec3(O), (U-.5 * iResolution.xy) / iResolution.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float sminCubic( float a, float b, float k ) //iq\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat smin( float a, float b, float k ) //iq\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nvec3 hsv2rgb_smooth( in vec3 c ) //iq\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n    \n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nmat2 Rot(in float a) //2D\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n#define Rot2D(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 Rot(in vec3 p, in vec3 r) //las\n{\n    Rot2D(p.xz, r.y);\n    Rot2D(p.yx, r.z);\n    Rot2D(p.zy, r.x);\n    return p;\n}\n\n//keep air hot, the winter is comming:\nvec2 sdKMC( in vec3 p,\n            in int iters,\n            in vec3 fTra,\n            in vec3 fRot,\n            in vec4 para)\n{//kind of kaleidoscopic menger cube \"structure\"\n    \n    float d =   length(max(vec3(0.), abs(p) - para.z - \n                length(abs(fTra) + abs(sin(fRot)))));\n    if (d > 0.) return vec2(10e3, 0.);\n    \n    int i;\n    float col = 0.;\n    float x1, y1;\n    float r = p.x*p.x + p.y*p.y + p.z*p.z;\n    \n    for(i = 0; i < iters && r < 1e8; i++)\n    {\n        if (i > 0) \n        {\n            p -= fTra;\n            p = Rot(p, fRot);\n        }\n\n        p = abs(p);\n\n        if (p.x-p.y < 0.) { x1=p.y; p.y=p.x; p.x=x1;}\n        if (p.x-p.z < 0.) { x1=p.z; p.z=p.x; p.x=x1;}\n        if (p.y-p.z < 0.) { y1=p.z; p.z=p.y; p.y=y1;}\n\n        p.z -= 0.5 * para.x * (para.y - 1.) / para.y;\n        p.z = -abs(p.z);\n        p.z += 0.5 * para.x * (para.y - 1.) / para.y;\n\n        p.x = para.y * p.x - para.z * (para.y - 1.);\n        p.y = para.y * p.y - para.w * (para.y - 1.);\n        p.z = para.y * p.z;\n\n        r = p.x*p.x + p.y*p.y + p.z*p.z;\n    }\n    \n    d = length(p) * pow(para.y, float(-i));\n\n    return vec2(d, col);\n}\n\nfloat hash(float n) { return fract(sin(n)*43758.5453123); } //iq\n\nfloat noise(in vec2 x) //iq\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n    float res = mix(mix(hash(n+  0.0), hash(n+  1.0), f.x),\n                    mix(hash(n+ 57.0), hash(n+ 58.0), f.x), f.y);\n    return res;\n}\n\nvec3 R(in vec2 uv, in vec3 p, in vec3 l, in float z)\n{\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}