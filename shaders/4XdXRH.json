{
    "Shader": {
        "info": {
            "date": "1718627881",
            "description": "DNA",
            "flags": 0,
            "hasliked": 0,
            "id": "4XdXRH",
            "likes": 4,
            "name": "DNA color",
            "published": 3,
            "tags": [
                "spiral",
                "rotate",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 239
        },
        "renderpass": [
            {
                "code": "uniform vec2 resolution;\nuniform float time;\n#define time iTime\n#define resolution iResolution.xy\nfloat deLine(vec3 p,vec3 a,vec3 b)\n{\n p.zx*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n p.yz*=mat2(cos(iTime*0.1),sin(iTime*0.1),-sin(iTime*0.1),cos(iTime*0.1));\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - 0.02;\n\n}\nvec3 dir=vec3(0.0,0.0,-1.0);\n#define EPS 0.001\nfloat trace(vec3 p,vec3 a,vec3 b,out vec3 target)\n{\n\nfloat td=0.0;\nfor(int i=0;i<30;i++){\nfloat de=deLine(p,a,b);\np+=de*dir;\ntd+=de;\nif(de<EPS){target=p;break;}\n}\nreturn td;\n}\n\nvec3 GetNormal(vec3 p,vec3 a,vec3 b)\n{\n\nfloat d=deLine(p,a,b);\nfloat dx=deLine(vec3(p.x+EPS,p.y,p.z),a,b),dy=deLine(vec3(p.x,p.y+EPS,p.z),a,b);\nreturn normalize(vec3(dx-d,dy-d,EPS));\n}\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\n\n#define H2(a) (cos(radians(vec3(-30, 60, 150))+(a)*6.2832)*.5+.5)  // hue\n#define A(v) mat2(cos((v*3.1416) + vec4(0, -1.5708, 1.5708, 0)))  // rotate\n#define s(a, b) c = max(c, .01/abs(L( u, K(a, v, h), K(b, v, h) )+.02)*k*10.*o); // segment\n//#define s(a, b) c += .02/abs(L( u, K(a, v, h), K(b, v, h) )+.02)*k*o*(1.-i);  // alt segment\n\n// line\nfloat L(vec2 p, vec3 A, vec3 B)\n{\n    vec2 a = A.xy,\n         b = B.xy - a;\n         p -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return length(p - b*h) + .01*mix(A.z, B.z, h);\n}\n\n// cam\nvec3 K(vec3 p, mat2 v, mat2 h)\n{\n    p.zy *= v; // pitch\n    p.zx *= h; // yaw\n    if (texelFetch(iChannel0, ivec2(80, 2), 0).x < 1.) // P key\n        p *= 4. / (p.z+4.); // perspective view\n    return p;\n}\n#define TAU 6.28318530718\n#define gradicalscale 0.3\nmat3 m1 = mat3(0.4122214708, 0.5363325363, +0.0514459929,\n               0.2119034982, 0.6806995451, +0.1073969566,\n               0.0883024619, 0.2817188376, +0.6299787005);\n\nmat3 inverse_m1 = mat3(+4.0767416621, -3.3077115913, +0.2309699292,\n                       -1.2684380046, +2.6097574011, -0.3413193965,\n                       -0.0041960863, -0.7034186147, +1.7076147010);\n\nmat3 m2 = mat3(0.2104542553, +0.7936177850, -0.0040720468,\n               1.9779984951, 2.4285922050, +0.4505937099,\n               0.0259040371, 0.7827717662, -0.8086757660);\n\nmat3 inverse_m2 = mat3(1., +0.3963377774, +0.2158037573,\n                       1., -0.1055613458, -0.0638541728,\n                       1., -0.0894841775, -1.2914855480);\n\nfloat cbrt( float x ) // https://www.shadertoy.com/view/wts3RX (needed for negative cube roots)\n{\nfloat y = sign(x) * uintBitsToFloat( floatBitsToUint( abs(x) ) / 3u + 0x2a514067u );\n\nfor( int i = 0; i < 1; ++i )\n    y = ( 2. * y + x / ( y * y ) ) * .333333333;\n\n    for( int i = 0; i < 1; ++i )\n    {\n    float y3 = y * y * y;\n        y *= ( y3 + 2. * x ) / ( 2. * y3 + x );\n    }\n   \n    return y;\n}\n\nvec3 cbrt( vec3 xyz )\n{\n    return vec3(cbrt(xyz.x), cbrt(xyz.y), cbrt(xyz.z));\n}\n\nvec3 rgb2oklab(vec3 rgb)\n{\n    return cbrt(rgb * m1)*m2;\n}\n\nvec3 oklab2rgb(vec3 oklab)\n{\n    return pow(oklab * inverse_m2, vec3(3.)) * inverse_m1;\n}\n\nvec3 oklab2oklch(vec3 oklab)\n{\n    return vec3(oklab.x,\n    sqrt(oklab.y * oklab.y + oklab.z * oklab.z),\n    atan(oklab.z, oklab.y)/TAU);\n}\n\nvec3 oklch2oklab(vec3 oklch)\n{\n    return vec3(oklch.x,\n    oklch.y * cos(oklch.z*TAU),\n    oklch.y * sin(oklch.z*TAU));\n}\nvec3 colorize(float t)\n{\n    float r = smoothstep(-.2, .55, t);\n    float g = smoothstep(0., 1., t);\n    float b = smoothstep(.45, 1.05, t);\n\n    return vec3(r, g, b);\n}\nvec3 rgb2oklch(vec3 rgb) { return oklab2oklch(rgb2oklab(rgb)); }\nvec3 oklch2rgb(vec3 oklch) { return oklab2rgb(oklch2oklab(oklch)); }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 pos = 1.0*(gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n  vec3 p=vec3(pos,2.0),target,normal;\n vec3 col = oklch2rgb( vec3(.85, 0.1, -pos.x + .167) );\n  float pi2=atan(1.0)*8.0,da=pi2/20.0;\n  float dist=100.0;\n  vec3 va[20],vb[20];\nfor(int i=1;i<20;i++){\nfloat n=float(i);\nva[i]=vec3(-0.2*cos(n*da),-1.0+0.1*n,-0.2*sin(n*da)),vb[i]=vec3(0.2*cos(n*da),-1.0+0.1*n,0.2*sin(n*da));\n}\nfor(int i=1;i<20;i++){\n\nfloat d=trace(p,va[i],vb[i],target);\nif(d<dist){dist=d;normal=GetNormal(target,va[i],vb[i]);}\n}\nfor(int i=1;i<19;i++){\n\nfloat d=trace(p,va[i],va[i+1],target);\nif(d<dist){dist=d;normal=GetNormal(target,va[i],va[i+1]);}\n}\nfor(int i=1;i<19;i++){\n\nfloat d=trace(p,vb[i],vb[i+1],target);\nif(d<dist){dist=d;normal=GetNormal(target,vb[i],vb[i+1]);}\n}\n\n  if(dist<3.0){\nvec3 light=normalize(vec3(-1.0,1.0,4.0));\nfloat color=dot(normal,light);\nfragColor=vec4(vec3(col),1.0);\n}\nelse fragColor*=vec4(vec3(1.,1.2,2.),1.);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}