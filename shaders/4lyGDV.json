{
    "Shader": {
        "info": {
            "date": "1476715228",
            "description": "Full-scene tracing inspired by glk7's [url=https://www.shadertoy.com/view/Ml3GDX]Reactive Voronoi[/url]. My approach is more robust (no need to find closest cell at every step, just continue) plus I've added ambient occlusion.",
            "flags": 0,
            "hasliked": 0,
            "id": "4lyGDV",
            "likes": 99,
            "name": "Voronoi Column Tracing",
            "published": 3,
            "tags": [
                "voronoi",
                "raymarch",
                "shadows",
                "ao",
                "tracing"
            ],
            "usePreview": 0,
            "username": "tomkh",
            "viewed": 4078
        },
        "renderpass": [
            {
                "code": "// Clean Voronoi Column Tracing\n// by Tomasz Dobrowolski'2016 CC BY-SA\n\n// Inspired by:\n//   https://www.shadertoy.com/view/Ml3GDX \"Reactive Voronoi\" (by Genise Sole)\n\n// Other references:\n//   https://www.shadertoy.com/view/llG3zy \"Faster Voronoi Borders\"\n//   https://www.shadertoy.com/view/XtK3RG \"Voronoi Floor Tiling\"\n//   https://www.shadertoy.com/view/4djSRW Dave Hoskins hash functions\n\n// Do you like colors? \n//  Put 0 if not ;)\n//      1 for pastel-rainbow\n//      2 for image-based\n//      3 elevation-based coloring (via Shane's suggestion)\n#define USE_COLORS 3\n\n// Waving or city-like?\n#define WAVING 1\n\n#define ROTATE 1\n\n#define SHADOWS 1\n#define AO 1\n\n#define ANIMATE 1\n#define ANIM_SPEED .25\n\n\nfloat hash12(vec2 p)\n{\n#if WAVING == 1\n   float v = sin(p.x*.3)*sin(p.y*.3+iTime)*.5 + .5;\n   return v*v;\n#else\n   // Dave Hoskins hash\n   vec3 p3  = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract((p3.x + p3.y) * p3.z);\n#endif\n}\n\nvec2 hash22(vec2 p)\n{\n#if ANIMATE == 0\n   //vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n   //p3 += dot(p3, p3.yzx+19.19);\n   //return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y))*.9+.05;\n    // Texture-based\n   return texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n#elif 1\n   // Dave Hoskins hash with animation\n   vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+19.19);\n   vec2 v = fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n   return sin(iTime*ANIM_SPEED + v*6.283185)*.45 + .5;\n#else\n   // Texture-based\n   vec2 v = texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n   return sin(iTime*ANIM_SPEED + 6.283185*v)*.45 + .5;\n#endif\n}\n\n//---------------------------------------------------------------\n// Trace through 2D Voronoi columns\n// by Tomasz Dobrowolski'2016 CC BY-SA\n\n// Requires:\n//   vec2 hash22( in vec2 p ); // to get Voronoi seeds positions\n//   float hash12( in vec2 p ); // to get column heights\n\nconst float eps = .0001;\nconst float max_dist = 9999.;\n\n// Scan through all Voronoi neighbours in direction of ray.\nfloat find_neighbour(vec2 n, vec2 f, vec2 dir, vec4 mc, out vec4 kc, out vec2 kdr)\n{\n   float kd = max_dist;\n   // This is fast. approx of neighbour search,\n   // to make it error free in all possible cases,\n   // we would have to use 7x7 scan.\n   for( int j=-2; j<=2; j++ )\n   for( int i=-2; i<=2; i++ )\n   {\n      vec2 g = mc.zw + vec2(float(i),float(j));\n      vec2 o = hash22( n + g );\n      vec2 r = g + o - f;\n\n      vec2 dr = r - mc.xy;\n      if ( dot(dr,dr) > eps ) { // Check if not equal to cell seed\n         float d = dot(dir,dr);\n         if ( d > eps ) { // Check if in direction of ray\n            d = dot(.5*(mc.xy + r),dr)/d;\n            if (d < kd) {\n               kd = d;\n               kdr = dr;\n               kc = vec4(r, g);\n            }\n         }\n      }\n   }\n   return kd;\n}\n\n// Trace through 2D Voronoi columns\n// Z-axis is height: \n//      0 = ground\n//  max_h = max. column height (positive)\n// Returns:\n//   xy = Voronoi seed at hit pos.\n//   zw = Voronoi grid cell at hit pos.\nvec4 voronoi_column_trace(\n         vec3 ray_pos,\n         vec3 ray_dir,\n         float max_h,\n         out vec4 hit_pos,\n         out vec3 hit_norm,\n         out vec3 hit_dh )\n{\n   const int iter = 32;\n   \n   vec2 p = ray_pos.xy;\n   float s = 1./length(ray_dir.xy);\n   vec2 dir = ray_dir.xy*s;\n   vec2 n = floor(p);\n   vec2 f = fract(p);\n   \n   vec4 mc;\n   float md;\n\n   // Find closest Voronoi cell to ray starting position.\n   md = 8.;\n\n   // This is fast. approx of closest point search,\n   // to make it error free in all possible cases,\n   // we would have to use 4x4 scan.\n   for( int j=-1; j<=1; j++ )\n   for( int i=-1; i<=1; i++ )\n   {\n      vec2 g = vec2(float(i),float(j));\n      vec2 o = hash22( n + g );\n      vec2 r = g + o - f;\n      float d = dot(r,r);\n\n      if( d<md )\n      {\n         md = d;\n         mc = vec4(r, g);\n      }\n   }\n   \n   vec2 mdr = vec2(0,1);\n   float dh = 0.;\n   float prev_h = 0.;\n   float h = 0.;\n   \n   md = eps;\n\n   for( int k=0; k<iter; ++k )\n   {\n      // Get height of the column\n      h = hash12( mc.zw + n )*max_h;\n      if (ray_dir.z >= 0.) {\n         dh = ray_pos.z + ray_dir.z*md;\n         if (dh < h || dh > max_h) break; // ray goes to inifnity or hits\n      }\n      \n      vec4 kc;\n      vec2 kdr;\n      float kd = find_neighbour(n, f, dir, mc, kc, kdr)*s;\n      \n      if (ray_dir.z < 0.) {\n         dh = ray_pos.z + ray_dir.z*kd;\n         if (dh < h) break; // hit!\n      }\n      \n      mc = kc;\n      md = kd;\n      mdr = kdr;\n      prev_h = h;\n   }\n   \n   if (dh >= h) {\n      hit_pos = vec4(ray_pos + ray_dir*max_dist,max_dist);\n      hit_norm = vec3(0,0,1);\n      hit_dh = vec3(1,1,h);\n      return vec4(0);\n   }\n   \n   float d;\n   if (ray_dir.z >= 0.) {\n      d = md;\n      hit_norm = vec3(-normalize(mdr),0);\n      hit_dh = vec3(vec2(ray_pos.z + ray_dir.z*d - prev_h, h-prev_h)/max_h,h);\n   }\n   else {\n      d = (h - ray_pos.z)/ray_dir.z;\n      if (md > d) {\n         d = md;\n         hit_norm = vec3(-normalize(mdr),0);\n         hit_dh = vec3(vec2(ray_pos.z + ray_dir.z*d - prev_h, h-prev_h)/max_h,h);\n      } else {\n         hit_norm = vec3(0,0,1);\n         hit_dh = vec3(1,1,h);\n      }\n   }\n   hit_pos = vec4(ray_pos + ray_dir*d, d);\n   return mc + vec4(p, n);\n} \n\n// Trace through 2D Voronoi columns with some tuning for artifact-free shadows\n// Assumes: ray_dir.z >= 0\nvec4 voronoi_column_trace_shadow(\n         vec4 mc,\n         vec3 ray_pos,\n         vec3 ray_dir,\n         float max_h,\n         out vec4 hit_pos,\n         out vec3 hit_norm )\n{\n   const int iter = 8;\n\n   vec2 p = ray_pos.xy;\n   float s = 1./length(ray_dir.xy);\n   vec2 dir = ray_dir.xy*s;\n   vec2 n = floor(p);\n   vec2 f = fract(p);\n   \n   mc -= vec4(p, n);\n   \n   float md;\n   \n   vec2 mdr = vec2(0,1);\n   float dh = 0.;\n   float h = 0.;\n   \n   md = eps;\n\n   for( int k=0; k<iter; ++k )\n   {\n      // Scan through all Voronoi neighbours in direction of ray.\n      \n      vec4 kc;\n      vec2 kdr;\n      float kd = find_neighbour(n, f, dir, mc, kc, kdr)*s;\n      \n      mc = kc;\n      md = kd;\n      mdr = kdr;\n      \n      // Get height of the column\n      h = hash12( mc.zw + n )*max_h;\n      dh = ray_pos.z + ray_dir.z*md;\n      if (dh > max_h || dh < h) break;\n   }\n   \n   if (dh >= h) {\n      hit_pos = vec4(ray_pos + ray_dir*max_dist,max_dist);\n      hit_norm = vec3(0,0,1);\n      return vec4(0);\n   }\n   \n   float d = md;\n   hit_norm = vec3(-normalize(mdr),0);\n   hit_pos = vec4(ray_pos + ray_dir*d, d);\n   return mc + vec4(p, n);\n}\n\n// Calculate AO on the top face of the column\nfloat voronoi_column_ao( vec2 x, vec4 mc )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    vec2 mr = mc.xy - x;\n    vec2 mg = mc.zw - n;\n    \n    float mh = hash12( n + mg );\n    \n    // Set center of search based on which half of the cell we are in,\n    // since 4x4 is not centered around \"n\".\n    mg = step(.5,f) - 1.;\n\n    float mao = 0.;\n    for( int j=-1; j<=2; j++ )\n    for( int i=-1; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n        vec2 o = hash22( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>eps ) // skip the same cell\n        {\n            float d = dot( 0.5*(mr+r), normalize(r-mr) );\n            // Get height of the column\n            float h = hash12( n + g );\n            float ao = clamp((h - mh)*2.,0.,.5)*max(0., 1. - d*4.);\n            mao = max(mao, ao);\n        }\n    }\n\n    return mao;\n}\n//---------------------------------------------------------------\n\n// Examplary rendering with simple shading\n\nconst float fog_density = .04;\nconst float fog_start = 16.;\nconst float cam_dist = 13.5;\nconst float ground = -.2;\n#if WAVING == 1\nconst float max_h = 3.;\n#else\nconst float max_h = 2.;\n#endif\n\nvec4 trace(in vec3 ray_start, in vec3 ray_dir, in vec3 light_dir,\n   out vec4 norm_h, out vec4 ret_mc, out vec2 shadow_ao )\n{\n   vec3 p = ray_start;\n   p.y += ground;\n   \n   norm_h = vec4(0,1,0,0);\n   ret_mc = vec4(9999.,0,0,0);\n   shadow_ao = vec2(0);\n\n   if (p.y > max_h && ray_dir.y > -.0001)\n      return vec4(0.);\n   \n\n   float dist = p.y - max_h;\n   if (dist > .001) {\n      dist /= -ray_dir.y;\n      p += ray_dir*dist;\n   } else {\n      dist = 0.;\n   }\n\n   vec4 hit;\n   vec3 hit_dh;\n   ret_mc = voronoi_column_trace(p.xzy, ray_dir.xzy, max_h, hit, norm_h.xyz, hit_dh);\n#if AO == 1\n   if (hit_dh.x < 1.) {\n      shadow_ao.y = max(0., 1. - hit_dh.x*8.)*.5*hit_dh.y;\n   } else {\n      shadow_ao.y = voronoi_column_ao(hit.xy, ret_mc);\n   }\n#endif\n\n#if SHADOWS == 1\n   if (hit.w < 48.-dist) {\n      vec3 sh_dir = light_dir.xzy;\n      vec4 sh_hit;\n      vec3 sh_norm;\n      if (dot(sh_dir,norm_h.xyz) < .001) {\n         shadow_ao.x = 1.;\n      } else {\n         vec4 smc = voronoi_column_trace_shadow(ret_mc, hit.xyz, sh_dir, max_h, sh_hit, sh_norm);\n         shadow_ao.x = 1.-step(max_dist-1.,sh_hit.w);\n      }\n   }\n#endif\n\n   hit = hit.xzyw;\n   hit.w += dist;\n   hit.y -= ground + hit_dh.z;\n   norm_h = vec4(norm_h.xzy, hit_dh.z/max_h);\n   return hit;\n}\n\nvec3 shade(in vec3 ray_start, in vec3 ray_dir, vec4 norm_h, vec4 mc,\n   vec2 shadow_ao, in vec3 light_dir, in vec3 fog_color, in vec4 hit)\n{   \n   vec3 norm = norm_h.xyz;\n   float diffuse = pow(max(0.05, dot(norm, light_dir)*(1.-shadow_ao.x*.9)),.3);\n   diffuse *= 1. - shadow_ao.y*.7*(1.-shadow_ao.x*.6);\n   float spec = max(0.0,dot(reflect(light_dir,norm),normalize(ray_dir)));\n   spec = pow(spec, 32.0)*.5*(1.-shadow_ao.x);\n\n#if USE_COLORS == 0\n   vec3 base_color = vec3(.6);\n#else\n  #if USE_COLORS == 3\n   #if WAVING == 1\n     float sh = sqrt(max(0.,norm_h.w))*.8+.2;\n   #else\n     float sh = norm_h.w*.8+.2;\n   #endif\n   vec3 base_color =\n    vec3(exp(pow(sh-.75,2.)*-10.),\n         exp(pow(sh-.50,2.)*-20.),\n         exp(pow(sh-.25,2.)*-10.));\n  #elif USE_COLORS == 1\n   float sh = mc.z; // + mc.w*17.;\n   sh = (abs(mod(sh+6.,12.)-6.)+2.5)*(1./9.);\n   // Ken Silverman's EvalDraw colors ;)\n   vec3 base_color =\n    vec3(exp(pow(sh-.75,2.)*-10.),\n         exp(pow(sh-.50,2.)*-20.),\n         exp(pow(sh-.25,2.)*-10.));\n  #else\n   vec3 base_color = texture(iChannel1, mc.zw*.1, -100.).xyz;\n  #endif\n   vec3 an = abs(norm);\n   base_color = mix(base_color, texture(iChannel1,\n       ((an.y>an.x&&an.y>an.z)?hit.xz:(an.x>an.z)?hit.yz:hit.xy)*.25).xyz, .2);\n#endif\n\n   if (hit.w < max_dist-1.) {\n      base_color *= 1.-dot(mc.xy-hit.xz,mc.xy-hit.xz)*.25;\n   }\n   vec3 color = mix(vec3(0.),vec3(1.),diffuse)*base_color +\n      spec*vec3(1.,1.,.9);\n  \n   \n   float fog_dist = max(0.,hit.w - fog_start);\n   float fog = 1.0 - 1.0/exp(fog_dist*fog_density);\n   color = mix(color, fog_color, fog);\n\n   return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    \n   //vec3 light_dir = normalize(vec3(.5, 1.0, .25));\n   vec3 light_dir = normalize(vec3(.25, .7, .25));\n   \n   // Simple model-view matrix:\n   float ms = 2.5/iResolution.y;\n   float ang, si, co;\n   ang = (iMouse.z > 0.0) ? (iMouse.x - iResolution.x*.5) * -ms :\n#if ROTATE == 1\n      -iTime*.125 + .7;\n#else\n      .7;\n#endif\n   si = sin(ang); co = cos(ang);\n   mat3 cam_mat = mat3(\n      co, 0., si,\n      0., 1., 0.,\n     -si, 0., co);\n   ang = (iMouse.z > 0.0) ? (iMouse.y - iResolution.y) * -ms - .5 :\n#if ROTATE == 1\n      cos(-iTime*.5)*.2 + .8;\n#else\n      .8;\n#endif\n   //ang = .1;\n   ang = max(0.,ang);\n   si = sin(ang); co = cos(ang);\n   cam_mat = cam_mat * mat3(\n      1., 0., 0.,\n      0., co, si,\n      0.,-si, co);\n\n   vec3 pos = cam_mat*vec3(0., 0., -cam_dist);\n   vec3 dir = normalize(cam_mat*vec3(uv, 1.));\n\n   vec3 color;\n   vec3 fog_color = vec3(min(1.,.4+max(-.1,dir.y*.8)));\n   vec4 norm_h;\n   vec4 mc;\n   vec2 shadow_ao;\n   vec4 hit = trace(pos, dir, light_dir, norm_h, mc, shadow_ao);\n   if (hit.w == 0.) {\n      color = fog_color;\n   } else {\n      color = shade(pos, dir, norm_h, mc, shadow_ao, light_dir, fog_color, hit);\n   }\n   \n   // gamma correction:\n   color = pow(color,vec3(.6));\n   \n   fragColor = vec4(color, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}