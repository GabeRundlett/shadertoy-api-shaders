{
    "Shader": {
        "info": {
            "date": "1726146472",
            "description": "some tests of raytracing",
            "flags": 16,
            "hasliked": 0,
            "id": "lXXyWH",
            "likes": 0,
            "name": "myRaytracing",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "boblareleve",
            "viewed": 69
        },
        "renderpass": [
            {
                "code": "//#define LENGHT(a) sqrt((a).x * (a).x + (a).z * (a).z + (a).y * (a).y)\n#define PI 3.14159265358979323846\n#define remap(a, b, f) ( ((f)-(a)) / ((b)-(a)) )\n#define FLT_MAX 3.402823466e+38\n\n\n#define time (iTime/6.)      // speed of the animation\n#define VOID_COLOR vec3(0.1) // color of the backGround\n#define N 7                  // num of sphere\n#define NB_BOUNCE 100         // nomber of bounce max\n#define CRICLE_RADIUS 2.6     // radius of the circle where the sphere are place\n#define BG_COLOR_BIAIS .3\n#define NB_COLOR 5           // numbers of color if modify also mod in makeSphere func\n#define Nf float(N)\n#define SEED 14567242.52256\n#define NOISE_3D rand(uv+SEED)\n#define GLOBAL_LIGHT_DIR normalize(vec3(1.,-1.,0.))\n\n#define KEY_Z 90./256.\n#define KEY_A 65./256.\n#define KEY_D 68./256.\n#define KEY_E 69./256.\n#define KEY_Q 81./256.\n#define KEY_S 83./256.\n\nstruct sphereData \n{\n    vec3 origin;\n    float r;   // radius\n    float mir; // mirorness\n    vec3 color;\n};\nstruct rayres\n{\n    vec3 inter;\n    int index;\n};\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co*SEED, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\nfloat colorS(float a)\n{\n    if (a > 1.)\n        return (1.);\n    if (a < 0.) \n        return (0.);\n    return (a);\n}\n\nsphereData makeSphere(int i)\n{\n    float area = 8.;\n    vec3 colors[NB_COLOR];\n    colors[0] = vec3(.8);\n    colors[1] = vec3(.1);\n    colors[2] = vec3(.8,0.1,0.);\n    colors[3] = vec3(.1,.8,0.1);\n    colors[4] = vec3(0.,.1,.8);\n    \n    /*return (sphereData(\n        vec3(\n            area*rand(vec2(float(i)  +SEED, 1.)) - area/2.,\n            area*rand(vec2(float(i+1)+SEED, 2.)) - area/2.,\n            area*rand(vec2(float(i+2)+SEED, 3.)) - area/2.\n        ),\n        1.5*rand(vec2(float(i+3))),\n        .7,\n        colors[i % NB_COLOR]\n    ));//*/\n    return sphereData(\n        vec3(sin(2.*PI*mod(float(i)+time*1.5,Nf) / Nf)*CRICLE_RADIUS,\n             0.,\n             cos(2.*PI*mod(float(i)+time*1.5,Nf) / Nf)*CRICLE_RADIUS), \n        1., // radus of the sphere\n        iMouse.y/iResolution.y,\n        //.2, // quantity of light reflected\n        //vec3(float(i+6)/Nf, float(i+2)/Nf, float(i+4)/Nf) // pink gradient\n        colors[i % NB_COLOR]\n    );\n}\n\n// give intersection point sphere/ray in globlal coordonate\nvec3 sphere(vec3 rayO, vec3 rayD, sphereData obj) //, vec3 lightSource)\n{\n    float k = dot(obj.origin - rayO, rayD);\n    vec3  p = rayO + k * rayD;\n    float y = distance(obj.origin, p);\n    \n    if (y < obj.r && k > 0.)\n    {\n        float x = sqrt(obj.r*obj.r - y*y);\n        float k1 = k-x;\n        float k2 = k+x;\n\n        // float d = dot(lightSource, k2*rayD+rayO - so) ;//remap(so.z, so.z - r, dot(lightSource, -so+k2*rayD))/4.;\n        vec3 tmp1 = k1*rayD + rayO;\n        vec3 tmp2 = k2*rayD + rayO;\n        vec3 tmp = (distance(rayO, tmp1) > distance(rayO, tmp2) ? tmp2 : tmp1);\n        return vec3(tmp);//, tmp    -obj.origin);\n    }\n    return vec3(.5);\n}\n\nmat3 getRotMatrix(vec3 angles)\n{\n    return\n    \n    mat3(1, 0,             0,\n         0, cos(angles.x), -sin(angles.x),\n         0, sin(angles.x), cos(angles.x))\n         *\n    mat3(cos(angles.y), -sin(angles.y), 0.,\n         sin(angles.y), cos(angles.y),  0.,\n         0,             0,              1.)\n         *\n    mat3(cos(angles.z), 0., sin(angles.z),\n         0.,            1., 0.,\n         -sin(angles.z),0., cos(angles.z));                          \n}\nvec3 rotPiAroundVec(vec3 v, vec3 u)\n{\n    return (\n        mat3(\n            2.*u.x*u.x-1., 2.*u.x*u.y   , 2.*u.x*u.z   ,\n            2.*u.x*u.y   , 2.*u.y*u.y-1., 2.*u.y*u.z   ,\n            2.*u.x*u.z   , 2.*u.y*u.z   , 2.*u.z*u.z-1.\n        ) *  v\n    );\n}\n\n// draw n Spheres from the obj objOrigin (do not draw it)\nrayres drawSpheres(vec3 ro, vec3 rd, int objOrigin)\n{\n    rayres nearest = rayres(vec3(FLT_MAX), -1);\n    float nearestDis = distance(nearest.inter, ro);\n\n    for (int i = 0; i < N; i++)\n    {\n        if (objOrigin != i)\n        {\n            rayres tmp = rayres(sphere(ro, rd, makeSphere(i)), i);\n\n            float tmpDis = distance(tmp.inter, ro);\n            if (tmp.inter != vec3(.5) && tmpDis < nearestDis)\n            {\n                nearestDis = tmpDis;\n                nearest = tmp;\n            }\n        }\n    }\n    return (nearest);\n}\n\n\nfloat fogFunc(float y)\n{\n    return (exp(-(y*y)));\n}\n\n// index ->  sphere\nvec3 getBgColor(vec3 rayO, vec3 rayD)\n{\n    //return (vec3(.9));\n    //return (\n      //  texture(iChannel0, vec3(rayD.x, rayD.y, rayD.z)*5.).x > .1 ?\n        //    VOID_COLOR : texture(iChannel0, rayD.xyz*5.).xxx*\n      //                          (sin(rand(vec2(iTime))) + 15.)\n    //);\n    \n    float y = rayD.y + .01*rayO.y;\n    //if (y < 0.)\n      //  return vec3(0.);\n    return vec3(colorS(y*4.+.1));//vec3(fogFunc(-rayD.y));\n}\nvec3 getBgLight(vec3 rayO, vec3 rayD)\n{\n    float res = colorS(.2+dot(rayD, -GLOBAL_LIGHT_DIR));\n    return vec3(\n        res*1.,\n        res*(215./256.),\n        res*0.\n    );\n    //float y = rayD.y + .01*rayO.y;\n    //if (y < 0.)\n      //  return vec3(0.);\n    //return vec3(colorS(y*4.+.1));//vec3(fogFunc(-rayD.y));\n}\n\nrayres bounceSphere(vec3 rayIn, rayres res)\n{\n    // return (rayres(vec3(FLT_MAX), 1));\n    vec3 n = normalize(res.inter - makeSphere(res.index).origin);\n    //return (rayres(n,-1));// color by the normal\n    \n    \n    //vec3 rayout = 2.*(rayIn + dot(-rayIn, n)*n) + rayIn;\n    vec3 rayout = -rotPiAroundVec(rayIn, n);\n\n    rayres tmp = drawSpheres(res.inter, rayout, res.index);\n    if (tmp.index == -1) // if no hit\n        tmp.inter = rayout; // replace inter with the rayOut\n    return (tmp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5) / iResolution.y;\n\n    vec3 col;\n    \n    \n    \n    float rayonCamPos = 10.;\n    \n    vec3 camPos = vec3(0., -rayonCamPos*sin(time), -rayonCamPos*cos(time));\n    \n    camPos = normalize(vec3(\n        4.*(iMouse.x/iResolution.x - .5), \n        4.*(iMouse.y/iResolution.y - .5),\n        -1.)\n    ) * rayonCamPos;\n    \n    vec3 camDir = vec3(mod(time,  2.*PI), .0, 0.);\n    \n    camDir = vec3(\n        -3.*(iMouse.y/iResolution.y-.5),\n        0.,\n        3.*(iMouse.x/iResolution.x-.5)\n    );\n    \n    mat3 rotMatrix = getRotMatrix(camDir);\n    vec3 rayD = normalize(rotMatrix * vec3(uv, 1.));\n    vec3 rayO = camPos;\n\n    rayres s = drawSpheres(rayO, rayD, -1);\n    \n    if (s.index == -1) //vec3(FLT_MAX))\n        col = getBgColor(rayO, vec3(rayD.x, rayD.y+.2, rayD.z));\n    else\n    {\n        rayres ray1 = s;\n        rayres ray2;\n        int i = 0;\n        col = makeSphere(s.index).color;\n        float colRatio = makeSphere(s.index).mir;\n        do\n        {\n            ray2 = bounceSphere(rayD, ray1);\n            if (ray2.index != -1)//-normalize(ray1.inter - makeSphere(ray1.index).origin)\n            {\n                col = mix(\n                          col, //makeSphere(ray1.index).color,\n                          makeSphere(ray2.index).color,\n                          colRatio);\n            }\n            //else col =mix(\n              //            col, //makeSphere(ray1.index).color,\n                //          getBgColor(ray2.inter, normalize(ray2.inter - makeSphere(ray2.index).origin)),\n                  //        colRatio * BG_COLOR_BIAIS);\n                          // biais to lower the impact of the BG\n            else col = mix(col, getBgLight(\n                            ray2.inter, \n                            normalize(ray1.inter - makeSphere(ray1.index).origin)\n                        ), colRatio * BG_COLOR_BIAIS);\n                          \n            ray1 = ray2;\n            rayD = -normalize(ray1.inter - makeSphere(ray1.index).origin);\n            colRatio *= makeSphere(ray1.index).mir;\n            i++;\n        }\n        while (i < NB_BOUNCE && ray1.index != -1);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col + .01*NOISE_3D,1.);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}