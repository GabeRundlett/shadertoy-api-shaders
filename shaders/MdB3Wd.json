{
    "Shader": {
        "info": {
            "date": "1395093307",
            "description": "A shadertoy adaptation of the PC 4k released at Evoke 2013.\nhttp://www.pouet.net/prod.php?which=61720",
            "flags": 0,
            "hasliked": 0,
            "id": "MdB3Wd",
            "likes": 2,
            "name": "BluFlame - Reflected",
            "published": 3,
            "tags": [
                "raymarching",
                "4k",
                "bluflame",
                "evoke",
                "reflected"
            ],
            "usePreview": 0,
            "username": "xTr1m",
            "viewed": 681
        },
        "renderpass": [
            {
                "code": "const int shader = 0; // Change to 0, 1, 2 or 3\n\n#define time (iTime * 0.125)\n\nfloat Yy() // Base drum sync\n{\n\treturn smoothstep(0.4, 0.6, (1.0 - mod(2.0 * iTime, 1.0)));\n}\nfloat Yz() // Snare sync\n{\n\treturn pow(1.0 - mod(iTime + 0.5, 1.0), 2.0);\n}\n\n// All data of our world\nfloat L, CurScene, CurTime, CurAnim, CurStep, cFac, VolLight, pi2= 6.28319, LightHeight = 50.0;\nint m;\nvec3 cRes, CurColor, RayStep;\n\nvec2 rotate(vec2 v,float y)\n{\n\treturn cos(y)*v+sin(y)*vec2(-v.y,v.x);\n}\n\n//repeat around y axis w times\n//void rp(inout vec3 p, float trans, float w) \nfloat repeatr(inout vec2 v,float x, float y) \n{\n    float a= atan(v.y,v.x);\n\tfloat z=mod(a,y)-y*.5;\n\tv=(length(v))*vec2(cos(z),sin(z));\n\tv.x-=x;\n    return a-z;\n}\n \nvoid repeat( inout float w, float y )\n{\n\tw= mod( w - y*.5, y ) - y*.5;\n}\n\nvoid repeate( inout float w, float y, float z )\n{\n\tw= max( abs(w)-z, mod( w - y*.5, y ) - y*.5);\n}\n\nfloat CBox( in vec3 p, in vec3 box, float rad )\n{\n    return length( max( abs(p) - box + vec3(rad), 0.0 ) ) - rad;\n}\n\n\nfloat plasm(float x, float a, float b,float c)\n{\n\treturn sin(x+a+c*sin(x+b));\n}\n\nvec3 shad2move()\n{\n\treturn vec3( CurTime*19.0, 24.0 - cos(CurAnim*9.0) * 8.0, cos(CurAnim*5.0) * 24.0);\n}\n\nvoid schad3transform( inout vec3 p )\n{\n\tp.xz = rotate(p.xz, 0.2 * cos( pow(abs(p.x),0.4 - CurTime * 0.1)) );\n\tp.yx = rotate(p.yx, 0.2 * cos( pow(abs(p.x),0.3 + CurTime * 0.1)) );\n}\n\nfloat f0(vec3 p)\n{\n\tif( shader == 0 )\n\t{\n\t\tschad3transform(p);\n\t\trepeat(p.x, 0.5);\n\t\treturn max( length(p.x) - 0.1, CBox( p, vec3(1000.,1.4,1.4), .5));\n\t}\n\tif( shader == 1 )\n\t{\n\t\tp -= shad2move();\n\t\t//p.y = rotate(p.yz, 50. *CurAnim );\n\t\tp.x = length (p.xz)+4.0*Yy() - 12.5;\n\t\trepeat (p.x, 24.0);\n\t\treturn length( max( abs(p.xy) - vec2(3., .2), 0.0 ) ) - 0.2;\n\t}\n\tif( shader == 2 )\n\t{\n\t\t p.y += plasm( \n\t\t\t0.1 * p.x,\n\t\t\t0.1 * p.z,\n\t\t\tCurTime* 10.0,\n\t\t\t1.0 );\n\t\tfloat d = p.x;\n\t\trepeat(p.x, pi2);\n\t\tp.y -= 0.3 * cos(  (p.z + d - p.x)*.5);\n\t\tp.z += 128.0 * CurTime * cos(0.7 * (d-p.x) );\n\t\trepeat(p.z, 2.4);\n\t\treturn CBox( p, vec3(1.0, 0.1, 1.0), 0.1); \n\t}\n\tif( shader == 3 )\n\t{\n\t\tp.x -= 128. * CurAnim;\n\t\trepeat(p.x, 64.);\n\t\tp.x = length( p.x ) - 11.;\n\t\treturn (p.x < 0.0 ? length( p.yz ): length( p )) -  5.0 ;\n\t}\n}\n\nfloat f1(vec3 p)\n{\n\tif( shader == 0 || shader == 3)\n\t{\n\t\tfloat d = p.y - 5.;\n        p.x *= 1.0;\n\t\trepeat(p.x, 20.);\n\t\trepeatr(p.yz, 28.0, pi2 / 9.0);\n\t\treturn max( d,  CBox( p, vec3(10.,2.0,10.), 3.));\n\t}\n\tif( shader == 1)\n\t{\n\t\tvec3 o= p;\n\t\trepeat(p.x, 8.0);\n\t\trepeat(p.z, 8.0);\n\t\to -= shad2move();\n\t\tp.xz = rotate(p.xz, atan(o.x, o.z) );\n\t\tp.yz = rotate(p.yz, atan(length(o.xz), 48.0) );\n\t\tfloat d = CBox( p, vec3(2.5 , 2.0, 2.5), 0.8); \n\t\tp.y += 12. + plasm( \n\t\t\t0.1 * o.x,\n\t\t\t0.1 * o.z,\n\t\t\tCurTime* 10.0,\n\t\t\t1.0 );\n\t\treturn max(d,  length(p)- 12.);\n\t}\n\tif( shader == 2 )\n\t{\n\t\tp.y += plasm( \n\t\t\t0.1 * p.x,\n\t\t\t0.1 * p.z,\n\t\t\tCurTime* 10.0,\n\t\t\t1.0 );\n\t\tfloat d = p.z;\n\t\trepeat(p.z, pi2);\n\t\tp.y += 0.3 * cos( (p.x + d - p.z)*.5);\n\t\treturn CBox( p, vec3(1000.0, 0.1, 2.0), 0.1); \n\t}\n}\n\nfloat f2(vec3 p)\n{\n\tif( shader == 0)\n\t{\n\t\tschad3transform(p);\n\t\tp.x += 256.0 * CurAnim;\n\t\trepeat(p.x, 32.0);\n\t\treturn length(vec2(length(p.yz) - 3.0,p.x)) - 1.- Yy();\n\t}\n\tif( shader == 1 )\n\t{\n\t\treturn length(p-shad2move()) - 12.0;\n\t}\n\tif( shader == 2 )\n\t{\n\t\tp.y -= 8.;\n\n\t\tfloat d = p.x;\n\t\trepeat(p.x, 32.0);\n\n\t\tp.yz = rotate(p.yz, plasm(d-p.x, 2., CurAnim, 1.0)- Yz() );\n\t\tp.xz = rotate(p.xz, plasm(d-p.x, 1., CurAnim, 2.0) );\n\n\t\treturn CBox( p, vec3(8.0), 6. - CurAnim);\n\t}\n\tif( shader == 3 )\n\t{\n\t\tp.yz = rotate(p.yz, plasm(round(p.x / 8.0), 1., 4.0*CurTime, 2.0) );\n\t\trepeat(p.x, 8.0);\n\t\trepeatr(p.yz, 0.0, pi2 / 10.0);\n\t\treturn max( abs(length(p.yz) - 6.0)-.2, abs(length(p.xz) - 2.+0.5*Yy())-.3);\n\t}\n}\n\nfloat f3(vec3 p)\n{\n\tif( shader == 0)\n\t{\n\t\tschad3transform(p);\n\t\treturn CBox( p, vec3(1000.,1.,1.), .1);\n\t}\n\tif( shader == 1 )\n\t{\n\t\tp.y += 20.;\n\t\trepeat( p.x, 6.3);\n\t\trepeat( p.z, 1.3);\n\t\t//repeatr(p.xz, .0, pi2 / 4.0);\n\t\treturn CBox( p, vec3(3.0, 15.0, 0.5), 0.4);\n\t}\n\tif( shader == 2 )\n\t{\n\t\tp.y -= 20.;\n\t\trepeat( p.x, 20.0);\n\t\trepeat( p.z, 20.0);\n\t\trepeatr(p.xz, .0, pi2 / 4.0);\n\t\treturn CBox( p, vec3(1000.0, 1.0, 1.0), 0.2);\n\t}\n\tif( shader == 3 )\n\t{\n\t\trepeat(p.z, 6.);\n\t\trepeat(p.x, 5.5);\n\t\trepeatr(p.xz, 2.0, pi2 / 6.0);\n\t\treturn max( abs(1.-length(p.xz))-0.1,abs(length(p.y)-15.0)-0.1);\n\t}\n\n}\n\n\nfloat f(vec3 p)\n{\n\treturn (0.003 - Yy() * 0.007) * plasm(p.x+Yy()*9., p.y, p.z,  1.0-Yy()) + min( min( min( f0(p), f1(p) ), f2(p) ), f3(p) );\n}\n\nfloat l(vec2 p)\n{\n    float d = floor(0.5 - p.y/32.0) + floor(0.5 - p.x/70.0) * 3.;\n    if( shader == 1 || shader == 2 )\n\t{\n\t\td= plasm( 33.0 * floor(0.5 - p.y/20.0), 5.0 * floor(0.5 - p.x/20.0), 17.0 * floor(CurTime * 16.0 + 0.5), 1.0);\n\t\trepeate( p.x, 20.0, 60.0 );\n\t\trepeat( p.y, 20.0);\n\t\tL = length( max( abs(p) - vec2(3.0), 0.0 ) ) + 2.5;// max( length(p.x), length(p.y));\n        if (d > 0.5)\n\t\t\tL +=  2.0*Yy();\n\t}\n\telse if( shader == 0 || shader == 3 )\n\t{\n\t\trepeate( p.y, 32.0, 32.0 );\n\t\trepeat( p.x, 70.0 );\n\t\tp.x = length(p.x) - 25.0;\n\t\tL =  2.0 - Yz() + (p.x < 0. ? length(p.y) : length(p));\n\t}\n    if( CurScene == 0.0 )\n\t    return max(0.0, 4.0 * smoothstep(10.,-pow(sin(d+CurTime*10.0*CurTime*220.0)+sin(d)+CurTime*10.0-4.0,.2),L));\n\n    return 4.0 * smoothstep(10.,0.0,L);\n}\n\n\nvoid mat(vec3 p)\n{\n\tCurColor = vec3(0.,.65,.2 );\n\t//CurColor = vec3(1.0,.3,0.9 );\n\tCurStep= .3;\n\t//CurNormal.y= 1.5;\n\t\n\tfloat z= f0(p);\n\tif( z > f1(p) )\n\t{\n\t\tz= f1(p);\n\t\tCurColor = vec3(0.1);\n\t\tCurStep= 0.85;\n\t\t//CurNormal.y= 0.15;\n\t}\n\t\t\n\tif( z > f2(p) )\n\t{\n\t\tz= f2(p);\n\t\tCurColor = vec3(1.0,.0,0.0 );\n\t\t//CurColor = vec3(0.1,1.0,.0 );\t\n\t\tCurStep= .2;\n\t\t//CurNormal.y= 0.0;\n\t}\n\n\tif( z > f3(p) )\n\t{\n\t\t//Wz= f3(p);\n\n\t\tCurColor = vec3(.25);// + animTex(p.zy / 10.0) * 0.6;\n\t\tCurStep= .1;\n\t\tm=2;\n\t}\n}\n\nvoid ToRes(vec3 Color, float Factor)\n{\n\tcRes+= Color * cFac;\n\tcFac*= Factor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat st = float(shader) * 4.0 + mod(time, 4.0);\n\tCurScene= floor(st);\n\tCurTime= st - CurScene;\n\tCurAnim= CurTime;\n\n\t// Get the look direction for the current pixel (always look forwards)\n\tvec3 rayDir = vec3( 0.6, (vec2(iResolution.x/iResolution.y, 1)*(fragCoord.yx / iResolution.xy) - 0.5));\n\t\n\t//Kamera sitzt an dieser Position\n\tvec3 p;\n\n\tif( CurScene == 0.0 )\n\t{\n\t\tp= vec3(  CurTime * 120. - 120. , -24.0, .0);\n\t\trayDir.xy= rotate( rayDir.xy, CurTime - 0.9  );\n\t\t//rayDir.xz= rotate( rayDir.xz, CurTime );\n\t\t//rayDir.yz= rotate( rayDir.yz, 0.9 - CurTime );\n\t}\n\telse if( CurScene == 1.0 )\n\t{\n\t\tp= vec3( 0., 5.0, -2.0);\n\t\trayDir.xy= rotate( rayDir.xy, -0.4 );\n\t\trayDir.xz= rotate( rayDir.xz, CurTime );\n\t\tCurAnim= CurTime*CurTime;\n\t}\n\telse if( CurScene == 2.0 )\n\t{\n\t\tp= vec3( -CurTime * 200. + 140.0, -2., 5.0);\n\t\trayDir.xy= rotate( rayDir.xy, CurTime-0.8 );\n\t\trayDir.xz= rotate( rayDir.xz, 3.14 );\n\t}\n\telse if( CurScene == 3.0 )\n\t{\n\t\tp= vec3( -25. , 0., CurTime * 20.0 - 19.0);\n\t\trayDir.xy= rotate( rayDir.xy, -0.2 );\n\t}\n\telse if( CurScene == 4.0 )\n\t{\n\t\tp= vec3( 0., 40.0, CurTime *8.);\n\t\trayDir.xy= rotate( rayDir.xy, -CurTime );\n\t\tCurAnim= 0.0;\n\t}\n\telse if( CurScene == 5.0 )\n\t{\n\t\tp= vec3( 0., 40.0, CurTime * -64. + 56.);\n\t\trayDir.xy= rotate( rayDir.xy, -1.0 );\n\t\tCurAnim= 0.4*CurTime*CurTime;\n\t}\n\telse if( CurScene == 6.0 )\n\t{\n\t\tp= vec3( 0., 12.0, CurTime * -12.0);\n\t\trayDir.xy= rotate( rayDir.xy, CurTime - 1.5);\n\t\trayDir.xz= rotate( rayDir.xz, CurTime );\n\t}\n\telse if( CurScene == 7.0 )\n\t{\n\t\tp= vec3( -4., CurTime * 64. + 4.0,  0.);\n\t\trayDir.xy= rotate( rayDir.xy, -1.0 );\n\t\trayDir.xz= rotate( rayDir.xz, -CurTime );\n\t}\n\telse if( CurScene == 8.0 )\n\t{\n\t\tp= vec3( 8.0, 8.0, CurTime * 24. - 32.);\n\t\trayDir.xy= rotate( rayDir.xy, -0.3 );\n\t\trayDir.xz= rotate( rayDir.xz, CurTime );\n\t\tCurAnim= 0.0;\n\t}\n\telse if( CurScene == 9.0 )\n\t{\n\t\tp= vec3( CurTime * 14., 18.0, 0.);\n\t\trayDir.xy= rotate( rayDir.xy, -CurTime-0.5 );\n\t\tCurAnim= CurTime*CurTime;\n\t}\n\telse if( CurScene == 10.0 )\n\t{\n\t\tp= vec3( 2.0, CurTime * 4. + 2.0, CurTime * 12.+ 7.);\n\t\trayDir.xy= rotate( rayDir.xy, -0.2 );\n\t\trayDir.xz= rotate( rayDir.xz, -CurTime );\n\t}\n\telse if( CurScene == 11.0 )\n\t{\n\t\tp= vec3( CurTime * 70. - 80., CurTime * -4. + 6.0, CurTime * 64.- 56.);\n\t\trayDir.xy= rotate( rayDir.xy, -0.2 );\n\t\trayDir.xz= rotate( rayDir.xz, CurTime );\n\t\tCurAnim= 4.*CurTime;\n\t}\n\telse if( CurScene == 12.0 )\n\t{\n\t\tp= vec3( 30.,-8.,-8.);\n\t\trayDir.xy= rotate( rayDir.xy, 0.2 );\n\t\trayDir.xz= rotate( rayDir.xz, -CurTime + 3.0 );\n\t\tCurAnim= 0.4*CurTime*CurTime;\n\t}\n\telse if( CurScene == 13.0 )\n\t{\n\t\tp= vec3( -60.,12.,0.);\n\t\trayDir.xy= rotate( rayDir.xy, CurTime - 1.5 );\n\t}\n\telse if( CurScene == 14.0 )\n\t{\n\t\tp= vec3( -22.,0.,-8.);\n\t\t//rayDir.xy= rotate( rayDir.xy, 0.2 );\n\t\trayDir.xz= rotate( rayDir.xz, -CurTime + 2.0 );\n\t\t//CurAnim= 0.4*Y.y;\n\t}\n\telse if( CurScene == 15.0 )\n\t{\n\t\tp= vec3( 80. * CurTime,  7. ,-0.);\n\t\trayDir.xz= rotate( rayDir.xz, 3.*CurTime );\n\t}\n\telse if( CurScene == 16.0 )\n\t{\n\t\tp.x = 43.0;\n\t\trayDir.xz= rotate( rayDir.xz, pi2/2.);\n\t\tCurAnim= CurTime*CurTime;\n\t}\n\t\n\trayDir = normalize(rayDir);\n\n\tcRes= vec3( .0 );\n\tcFac=1.0;\n\t\n\tfloat t=0.0;\n\tm = 0;\n\tfor (int w=0; w < 2; w++)\n\t{\n\t\tif (m >= 2)\n\t\t\tbreak;\n\t\t\n\t\t//bis zu einer Oberflaeche steppen\n\t\t//for (CurStep=1.0;t<220.0 && CurStep>t*.003;t+=0.01+max(0.0, CurStep),RayStep=rayDir*t )\n\t\tCurStep = 1.0;\n\t\tfor (int i = 0; i < 64; ++i)\n\t\t{\n\t\t\tCurStep = f(p+RayStep);\n\t\t\t\t\n\t\t\tt+=CurStep;RayStep=rayDir*t;\n\t\t\tif (CurStep<=t*.003 || t>220.0)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tvec3 NextPos = p+RayStep;\n\t\tVolLight = 0.0;\n\t\tif( p.y < LightHeight && NextPos.y > LightHeight)\n\t\t{\n\t\t\tfloat f = (p.y - LightHeight) / (p.y - NextPos.y);\n\t\t\tp += RayStep*f;\n\t\t\tVolLight = l(p.xz) * smoothstep( 220.0,0.0, f * t );\n\t\t}\n\t\t\n\t\t//Startpunkt und Richtung fuer reflektierten Strahl;\n\t\tp= NextPos;\n\t\t\n\t\tvec3 n = vec3(0.04, 0.0, 0.0);\n\t\tn= normalize(vec3( f(p + n.xyy) - f(p - n.xyy), f(p + n.yxy) - f(p - n.yxy), f(p + n.yyx) - f(p - n.yyx) ));\n\t\t\n\t\t//n= normalize(n);\n\t\t//CurStep ab hier == Reflektion !!!\n\t\tmat(p);\n\t\t\n\t\tfloat Ambient= 0.45 + 0.4 * dot( n,vec3(0,1.0,0) );\n\n\n\t\tToRes(vec3(0.7,1.0,0.9)*VolLight,1.0-VolLight);\n\t\tL= smoothstep( 0.,128., t );\n\t\tToRes(vec3( 0.0, 0.0, 0.05 )*L,1.0-L); // FogColor\n\t\t\n\t\tif( t > 220.0 )\n\t\t\tbreak;\n\t\t\n\t\trayDir= reflect( rayDir, n );\n\n\t\t//float ao(vec3 p, vec3 n, float d, float i) {\n\t\tfloat z = 1.0;\n\t\tfor (float y=6.0;y>0.;y--)\n\t\t{\n\t\t\tz-=(y*.5-f(p+n*y*.5))/exp2(y);\n\t\t}\n\t\tCurColor*= z*Ambient;\n\t\t\n\t\t//CurColor*= .4 + .3 * ( dot(normalize(LightPos-p),n) );\n    \n\t\tcRes+= cFac*CurColor;//*(1.0-Reflect);\n\t\tcFac*= CurStep;// Reflect * (1.0-t/tmax);\n\t\tt= 0.5;\n\t\tRayStep=rayDir*t;\n\t}\n\t\n\t\n\tfragColor.xyz = cRes;// + Y.w;// + cFac*FogColor;\n\t\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}