{
    "Shader": {
        "info": {
            "date": "1679257279",
            "description": "chromatic abberation and refraction test",
            "flags": 0,
            "hasliked": 0,
            "id": "dsV3Wd",
            "likes": 2,
            "name": "Spherochromatism",
            "published": 3,
            "tags": [
                "refraction",
                "chromaticaberration",
                "abbenumber"
            ],
            "usePreview": 0,
            "username": "domrally",
            "viewed": 179
        },
        "renderpass": [
            {
                "code": "/// by Dom Mandy in 2023\n\n\nfloat sphIntersect( vec3 ro, vec3 rd, vec4 sph) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n\nvec3 normalAtPoint(vec3 point) {\n    vec3 xTangent = dFdx(point);\n    vec3 yTangent = dFdy(point);\n    vec3 normal = normalize(cross(yTangent, xTangent));\n    return normal;\n}\n\n\n/*\nabbe spectral energy stuff\n*/\nvec3 computeSpectralIOR(float eta, float abbeNumber)\n{\n    vec3 etaOut;\n    etaOut.g = eta;\n    etaOut.b = (etaOut.g - 1.) / (2. * abbeNumber) + etaOut.g;\n    etaOut.r = 2. * etaOut.g - etaOut.b;\n    \n    return etaOut;\n}\n\n\nfloat f(float x) {\n    if (x >= 0.0031308)\n        return (1.055) * pow(x, (1.0/2.4) - 0.055);\n    else\n        return 12.92 * x;\n}\n\n\nfloat f_inv(float x)\n{\n    if (x >= 0.04045)\n        return pow(((x + 0.055)/(1. + 0.055)), 2.4);\n    else \n        return x / 12.92;\n}\n\n\n/*\nAssumes all vectors are normalized, and N points on the side of Ng (it has\nnot been flipped towards wo).\nReturns false in case of total internal reflection, and true otherwise.\nIn the latter case, it also returns abs(N.dot(wo)) and abs(N.dot(wi)).\n*/\nvec3 computeRefractionDirection(vec3 N, vec3 wo, float neta)\n{\n    // Compute refraction vector\n    float NdotWo = dot(N, wo);\n    vec3 Nf;\n    if (NdotWo > 0.0f) {\n        Nf = N;\n    } else {\n        Nf = -N;\n    }\n    NdotWo = abs(NdotWo);\n\n    float NdotWi = 1.0f - neta * neta * (1.0f - (NdotWo * NdotWo));\n    if (NdotWi < 0.0f) {\n        // Total internal reflection\n        return vec3(0.);\n    }\n    NdotWi = sqrt(NdotWi);\n\n    float negMu = neta * NdotWo - NdotWi;\n    \n    vec3 wi = negMu * Nf - neta * wo;\n    wi = normalize(wi);\n\n    return wi;\n}\n\n\n/*\nAssumes all vectors are normalized, and N points on the side of Ng, not Ngf\nReturns N.dot(wo) (which is also N.dot(wi))\n*/\nvec3 computeReflectionDirection(vec3 N, vec3 wo)\n{\n    float NDotWo = dot(N, wo);\n\n    vec3 wi = -1.0f * wo + 2.0f * NDotWo * N;\n    wi = normalize(wi);\n\n    return wi;\n}\n\n\n/*\nSampling R, G and B wavelengths with the weights (0.35f, 0.35f, 0.30f)\nthat all sum to 1.0f. Returning the appropritate dispersionColor and pdf.\n*/\nvec4 sampleSpectralIOR(float r, float etaR, float etaG, float etaB)\n{\n    float sampleEta;\n    vec3 dispersionColor;\n    \n    if (r < .35) {\n        r /= .35;\n        // Red\n        dispersionColor = vec3(1., 0., 0.);\n        sampleEta = etaR;\n    } else if (r < .7) {\n        r = (r - .35) / .35;\n        // Green\n        dispersionColor = vec3(0., 1., 0.);\n        sampleEta = etaG;\n    } else {\n        r = (r - .7) / .3;\n        // Blue\n        dispersionColor = vec3(0., 0., 1.);\n        sampleEta = etaB;\n    }\n    \n    return vec4(dispersionColor, sampleEta);\n}\n\n\n/*\nrotates a vector by a given angle (in radians) around a given axis (must be a unit vector)\nsee: https://en.wikipedia.org/wiki/Rodrigues'_rotation_formula\n*/\nvec3 rotationRodrigues(vec3 v, vec3 axis, float angle)\n{\n    float c = cos(angle);\n    return v * c + cross(axis, v) * sin(angle) + axis * dot(axis, v) * (1.0 - c);\n}\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 p = .6 * (2. * fragCoord.xy-iResolution.xy) / iResolution.y;\n    vec3 up = vec3(0., 1., 0.);\n    vec3 wo = vec3(p, -2.);\n    float t = iTime * .1;\n    wo = rotationRodrigues(wo, up, t);\n    vec3 cam = vec3(0., 0., -4.);\n    cam = rotationRodrigues(cam, up, t);\n    vec3 ray = wo - cam;\n    ray = normalize(ray);\n    \n    \n    float d = sphIntersect(wo, ray, vec4(0., 0., 0., 1.));\n    vec3 pt = ray * d + cam;\n\n    // normal\n    vec3 normy = normalAtPoint(pt);\n    vec3 ri = computeSpectralIOR(.5, 10.);\n    vec4 eta = sampleSpectralIOR(1.0, ri.r, ri.g, ri.b);\n    vec3 refracted = computeRefractionDirection(normy, ray, eta.a);\n    vec3 rfrct[3];\n    rfrct[0] = computeRefractionDirection(normy, ray, ri.r);\n    rfrct[1] = computeRefractionDirection(normy, ray, ri.g);\n    rfrct[2] = computeRefractionDirection(normy, ray, ri.b);\n    vec3 reflected = computeReflectionDirection(normy, ray);\n\n    vec3 background = texture(iChannel0, ray).rgb;\n    rfrct[0].xy *= -1.;\n    rfrct[1].xy *= -1.;\n    rfrct[2].xy *= -1.;\n    refracted.xy *= -1.;\n    vec3 refraction = texture(iChannel0, refracted).rgb;\n    vec3 reflection = .2 * pow(normy, vec3(7.)) * float(texture(iChannel0, reflected).r > .5);\n    \n    refraction = vec3(f_inv(refraction.x), f_inv(refraction.y), f_inv(refraction.z));\n    \n    float counter = 0.;\n    \n    for(float r = 255.; r > 0.; r -= 64.) {\n        for(float g = 255.; g > 0.; g -= 64.) {\n            for(float b = 255.; b > 0.; b -= 64.) {\n                vec3 w = vec3(r, g, b) / (r + g + b);\n                vec3 re = rfrct[0] * w.r + rfrct[1] * w.g + rfrct[2] * w.b;\n                vec3 s = texture(iChannel0, re).rgb;\n                s = vec3(f_inv(s.x), f_inv(s.y), f_inv(s.z));\n                                \n                refraction += s * w;\n                counter++;\n            }\n        }\n    }\n    \n    refraction /= counter;\n    refraction *= 3. * vec3(.99, 1., .8);\n    refraction = vec3(f(refraction.x), f(refraction.y), f(refraction.z));\n\n    fragColor.rgb = float(d <= 0.) * background + float(d > 0.) * (refraction + reflection);\n    \n    fragColor.rgb = pow(fragColor.rgb, vec3(2.2));\n    fragColor.a = 1.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}