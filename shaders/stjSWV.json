{
    "Shader": {
        "info": {
            "date": "1628735235",
            "description": "polar coord tutorial",
            "flags": 0,
            "hasliked": 0,
            "id": "stjSWV",
            "likes": 0,
            "name": "polar coord tutorial",
            "published": 3,
            "tags": [
                "tutorial",
                "polar"
            ],
            "usePreview": 0,
            "username": "jcyuan",
            "viewed": 121
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // 坐标转换至屏幕中心变为-1至1\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // 转换uv为极坐标，l为半径，a为角度\n    float l = length(uv);\n    \n    // atan转换角度，除2PI归一化（倍数越多花瓣越多，可试着修改后面的2为N倍）\n    float a = atan(uv.y, uv.x) / 6.28318 * 2.\n              +\n              // 将角度按半径叠加，得到越离外部角度越大的角度(弯曲)\n              l * 2.\n              -\n              // 加或减一个变化的值，让所有角度整体移动（旋转）\n              iTime;\n              \n    a = fract(a);   // 取每个花瓣的区间0到1\n    \n    // 从红色至绿色，在花瓣间插值着色并输出\n    vec3 col = vec3(mix(vec3(1., 0., 0.), vec3(0., 1., 0.), a));\n\n    fragColor = vec4(col, 1.);\n}\n\n// 其实整体的思想非常简单，也就是相当于笛卡尔坐标系\n// 的fract(uv * N或uv / N)来变成格子uv，只不过在极\n// 坐标下会变成平均切分一个圆为N分，然后再配合半径，\n// 就能将角度显示为螺旋。\n// 要查看未扭曲的圆切分，可将13行注释掉并将10行的花\n// 瓣倍数改大。\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}