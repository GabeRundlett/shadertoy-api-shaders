{
    "Shader": {
        "info": {
            "date": "1456867752",
            "description": "A spin off of https://www.shadertoy.com/view/lsKGDV.  This shader uses JFA to get both an inside and outside distance to shapes, so that it can make a true signed distance texture (not unsigned!) and use that for rendering.",
            "flags": 48,
            "hasliked": 0,
            "id": "ldVGWc",
            "likes": 21,
            "name": "JFA SDF Texture",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "distance"
            ],
            "usePreview": 0,
            "username": "demofox",
            "viewed": 4743
        },
        "renderpass": [
            {
                "code": "// Shared constant between Buf C and Image\n// The sdf texture is 1/c_sdfShrinkFactor in size\nconst float c_sdfShrinkFactor = 4.0; \n\nconst float c_gamma = 2.2;\n\nconst float KEY_1 = 49.5/256.0;\nconst float KEY_2 = 50.5/256.0;\nconst float KEY_3 = 51.5/256.0;\nconst float KEY_4 = 52.5/256.0;\n\n//============================================================\nvoid DecodeData (in vec4 data, out vec2 coord, out vec3 color)\n{\n    coord = data.xy;\n    color.x = floor(data.z / 256.0) / 255.0;\n    color.y = mod(data.z, 256.0) / 255.0;\n    color.z = mod(data.w, 256.0) / 255.0;\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // zooming\n    vec2 adjustedFragCoord = fragCoord;\n    float zoom = 1.0;\n    if(iMouse.z>0.0 && length(iMouse.xy - fragCoord) < 100.0) {\n        zoom = 20.0;\n        adjustedFragCoord = (((fragCoord.xy - iMouse.xy) / zoom) + iMouse.xy);\n        if (length(iMouse.xy - fragCoord) > 95.0)\n        {\n            fragColor = vec4(1.0, 1.0, 0.0, 1.0);\n            return;\n        }\n    }\n    vec2 uv = adjustedFragCoord / iResolution.xy;    \n    \n\tvec3 seedColor = vec3(1.0, 0.0, 1.0);\n    \n    // if the 1 key is pressed, show information from Buf A\n    if (texture(iChannel3, vec2(KEY_1,0.25)).x > 0.1)\n    {\n        // Get and decode data for this pixel\n        vec4 data = texture(iChannel0, uv);\n\t\tvec2 seedCoord;\n    \tDecodeData(data, seedCoord, seedColor);  \n        \n        // highlight the seeds a bit\n        if (length(floor(adjustedFragCoord)-floor(seedCoord)) > 1.0)\n            seedColor *= 0.25;            \n    }    \n    // if the 2 key is pressed, show information from Buf B\n    else if (texture(iChannel3, vec2(KEY_2,0.25)).x > 0.1)\n    {\n        // Get and decode data for this pixel\n        vec4 data = texture(iChannel1, uv);\n\t\tvec2 seedCoord;\n    \tDecodeData(data, seedCoord, seedColor); \n        \n        // highlight the seeds a bit\n        if (length(floor(adjustedFragCoord)-floor(seedCoord)) > 1.0)\n            seedColor *= 0.25;    \n    }       \n    // if the 3 key is pressed, show Buf C\n    else if (texture(iChannel3, vec2(KEY_3,0.25)).x > 0.1)\n    {\n        uv -= (1.0 - 1.0 / c_sdfShrinkFactor) * 0.5;\n        if (uv.x >= 0.0 && uv.y >= 0.0 && uv.x <= 1.0 / c_sdfShrinkFactor && uv.y <= 1.0 / c_sdfShrinkFactor)\n        \tseedColor = texture(iChannel2, uv).rgb;\n        else\n            seedColor = vec3(0.0);\n    }\n    // if the 4 key is pressed, show Buf C stretched up to full size\n    else if (texture(iChannel3, vec2(KEY_4,0.25)).x > 0.1)\n    {\n        uv /= c_sdfShrinkFactor;\n        uv *= iChannelResolution[2].xy;\n        uv = floor(uv) + vec2(0.5);\n        uv /= iChannelResolution[2].xy;\n        \n        seedColor = 1.0 - texture(iChannel2, uv).rgb;\n    }    \n    else\n    {\n        float halfAA = 0.0625 / zoom;        \n        uv /= c_sdfShrinkFactor;\n        float dist = texture( iChannel2, uv).r;        \n        float shade = smoothstep(0.5 - halfAA, 0.5 + halfAA, dist);\n\t\tshade = 1.0 - shade;\n        seedColor = vec3(shade);           \n    }\n    \n    // gamma correct\n\tseedColor = pow(seedColor, vec3(1.0/c_gamma));\n    fragColor = vec4(seedColor, 1.0);    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define DIST_OUTSIDE 1\n\n/*============================================================\n\nThis shader is the same in Buf A and Buf B with different\nvalues for DIST_OUTSIDE.  Buf A finds the distance outside\nof the shapes, while Buf B finds the distance inside of\nthe shapes.\n\nBuf C combines the information to make a true SDF texture\nwhich is used to do rendering in the Image tab.\n\n============================================================*/\n\n// how many JFA steps to do.  2^c_maxSteps is max image size on x and y\nconst float c_maxSteps = 10.0;\n\n// circle info\nconst int c_numCircles = 10;\nconst vec2 c_circleRadius = vec2(0.01, 0.05);  // min, max\n\n// line info\nconst int c_numLines = 10;\nconst vec4 c_lineSize = vec4(0.01, 0.01, 0.3, 0.1); // vec2 min, max \n\n// squiggle info\nconst int c_numSquiggles = 10;\nconst vec4 c_squiggleSize = vec4(0.01, 0.01, 0.3, 0.1); // vec2 min, max \n\n//============================================================\nfloat UDFatLineSegment (in vec2 coords, in vec2 A, in vec2 B, in float height)\n{    \n    // calculate x and y axis of box\n    vec2 xAxis = normalize(B-A);\n    vec2 yAxis = vec2(xAxis.y, -xAxis.x);\n    float width = length(B-A);\n    \n\t// make coords relative to A\n    coords -= A;\n    \n    vec2 relCoords;\n    relCoords.x = dot(coords, xAxis);\n    relCoords.y = dot(coords, yAxis);\n    \n    // calculate closest point\n    vec2 closestPoint;\n    closestPoint.x = clamp(relCoords.x, 0.0, width);\n    closestPoint.y = clamp(relCoords.y, -height * 0.5, height * 0.5);\n    \n    return length(relCoords - closestPoint);\n}\n\n//============================================================\n// Hash without sine from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n//============================================================\nvec4 EncodeData (in vec2 coord, in vec3 color)\n{\n    vec4 ret = vec4(0.0);\n    ret.xy = coord;\n    ret.z = floor(color.x * 255.0) * 256.0 + floor(color.y * 255.0);\n    ret.w = floor(color.z * 255.0);\n    return ret;\n}\n\n//============================================================\nvoid DecodeData (in vec4 data, out vec2 coord, out vec3 color)\n{\n    coord = data.xy;\n    color.x = floor(data.z / 256.0) / 255.0;\n    color.y = mod(data.z, 256.0) / 255.0;\n    color.z = mod(data.w, 256.0) / 255.0;\n}\n\n//============================================================\nvec4 StepJFA (in vec2 fragCoord, in float level)\n{\n    level = clamp(level, 0.0, c_maxSteps);\n    float stepwidth = floor(exp2(c_maxSteps - level)+0.5);\n    \n    float bestDistance = 9999.0;\n    vec2 bestCoord = vec2(0.0);\n    vec3 bestColor = vec3(0.0);\n    \n    for (int y = -1; y <= 1; ++y) {\n        for (int x = -1; x <= 1; ++x) {\n            vec2 sampleCoord = fragCoord + vec2(x,y) * stepwidth;\n            \n            vec4 data = texture( iChannel0, sampleCoord / iChannelResolution[0].xy);\n            vec2 seedCoord;\n            vec3 seedColor;\n            DecodeData(data, seedCoord, seedColor);\n            float dist = length(seedCoord - fragCoord);\n            if ((seedCoord.x != 0.0 || seedCoord.y != 0.0) && dist < bestDistance)\n            {\n                bestDistance = dist;\n                bestCoord = seedCoord;\n                bestColor = seedColor;\n            }\n        }\n    }\n    \n    return EncodeData(bestCoord, bestColor);\n}\n\n//============================================================\nvec4 DrawShapes (in vec2 fragCoord)\n{\n    #if DIST_OUTSIDE == 1\n    \tvec4 ret = vec4(0.0);\n    #else\n    \tvec4 ret = EncodeData(fragCoord, vec3(0.0, 1.0, 0.0));\n    #endif\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = (fragCoord / iResolution.xy);\n    uv.x *= aspectRatio;    \n    \n    // draw circles\n    for (int i = 0; i < c_numCircles; ++i)\n    {\n        vec2 posuv = hash22(vec2(i, iDate.w));\n        posuv.x *= aspectRatio;\n        \n        vec3 color = hash32(vec2(i, iDate.w));\n        float radius = mix(c_circleRadius.x, c_circleRadius.y, hash12(vec2(i, iDate.w)));\n\t\tfloat dist = length(uv-posuv);\n       \n        if (dist <= radius) {\n            #if DIST_OUTSIDE == 1\n            \tret = EncodeData(fragCoord, color);      \n            #else\n            \tret = vec4(0.0);\n            #endif\n        }\n    }\n    \n    // draw lines\n    for (int i = 0; i < c_numLines; ++i)\n    {\n        vec2 startuv = hash23(vec3(i, iDate.w, 0.453));\n        startuv.x *= aspectRatio;\n        \n        vec2 lineDir = normalize(hash23(vec3(i, iDate.w, 0.627)));\n        \n        vec3 color = hash33(vec3(i, iDate.w, 2.564));\n        float width = mix(c_lineSize.x, c_lineSize.z, hash13(vec3(i, iDate.w, 1.453)));\n        float height = mix(c_lineSize.y, c_lineSize.w, hash13(vec3(i, iDate.w, 0.894)));\n\t\tvec2 enduv = startuv + lineDir * width;\n        \n        float dist = UDFatLineSegment(uv, startuv, enduv, height);\n        \n        if (dist <= 0.0) {\n            #if DIST_OUTSIDE == 1\n            \tret = EncodeData(fragCoord, color);      \n            #else\n            \tret = vec4(0.0);\n            #endif            \n        }\n    }    \n    \n    // draw squiggle lines\n    for (int i = 0; i < c_numSquiggles; ++i)\n    {\n        vec2 startuv = hash23(vec3(i, iDate.w, 2.635));\n        startuv.x *= aspectRatio;\n        \n        vec2 squiggleDir = normalize(hash23(vec3(i, iDate.w, 0.912)));\n        \n        vec3 color = hash33(vec3(i, iDate.w, 0.123));\n        float width = mix(c_squiggleSize.x, c_squiggleSize.z, hash13(vec3(i, iDate.w, 0.342)));\n        float height = mix(c_squiggleSize.y, c_squiggleSize.w, hash13(vec3(i, iDate.w, 1.847)));\n\t\tvec2 enduv = startuv + squiggleDir * width;\n        \n        vec2 uvOffset = vec2(0.0);\n        float uvdp = dot(uv - startuv, squiggleDir);\n        vec2 normal = vec2(squiggleDir.y, -squiggleDir.x);\n        if (uvdp >= 0.0 && uvdp <= width)\n            uv += normal * sin(uvdp * 100.0) * 0.01;\n        \n        float dist = UDFatLineSegment(uv, startuv, enduv, height);\n        \n        if (dist <= 0.0) {\n            #if DIST_OUTSIDE == 1\n            \tret = EncodeData(fragCoord, color);      \n            #else\n            \tret = vec4(0.0);\n            #endif\n        }\n    }        \n\n    return ret;\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 adjustedFragCoord = fragCoord;\n    \n    // initialize random seed locations and colors\n    if (iFrame == 0) {\n        fragColor = DrawShapes(adjustedFragCoord);\n        return;\n    }\n    \n    // JFA steps\n    fragColor = StepJFA(adjustedFragCoord, floor(float(iFrame-1)));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define DIST_OUTSIDE 0\n\n/*============================================================\n\nThis shader is the same in Buf A and Buf B with different\nvalues for DIST_OUTSIDE.  Buf A finds the distance outside\nof the shapes, while Buf B finds the distance inside of\nthe shapes.\n\nBuf C combines the information to make a true SDF texture\nwhich is used to do rendering in the Image tab.\n\n============================================================*/\n\n// how many JFA steps to do.  2^c_maxSteps is max image size on x and y\nconst float c_maxSteps = 10.0;\n\n// circle info\nconst int c_numCircles = 10;\nconst vec2 c_circleRadius = vec2(0.01, 0.05);  // min, max\n\n// line info\nconst int c_numLines = 10;\nconst vec4 c_lineSize = vec4(0.01, 0.01, 0.3, 0.1); // vec2 min, max \n\n// squiggle info\nconst int c_numSquiggles = 10;\nconst vec4 c_squiggleSize = vec4(0.01, 0.01, 0.3, 0.1); // vec2 min, max \n\n//============================================================\nfloat UDFatLineSegment (in vec2 coords, in vec2 A, in vec2 B, in float height)\n{    \n    // calculate x and y axis of box\n    vec2 xAxis = normalize(B-A);\n    vec2 yAxis = vec2(xAxis.y, -xAxis.x);\n    float width = length(B-A);\n    \n\t// make coords relative to A\n    coords -= A;\n    \n    vec2 relCoords;\n    relCoords.x = dot(coords, xAxis);\n    relCoords.y = dot(coords, yAxis);\n    \n    // calculate closest point\n    vec2 closestPoint;\n    closestPoint.x = clamp(relCoords.x, 0.0, width);\n    closestPoint.y = clamp(relCoords.y, -height * 0.5, height * 0.5);\n    \n    return length(relCoords - closestPoint);\n}\n\n//============================================================\n// Hash without sine from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n//============================================================\nvec4 EncodeData (in vec2 coord, in vec3 color)\n{\n    vec4 ret = vec4(0.0);\n    ret.xy = coord;\n    ret.z = floor(color.x * 255.0) * 256.0 + floor(color.y * 255.0);\n    ret.w = floor(color.z * 255.0);\n    return ret;\n}\n\n//============================================================\nvoid DecodeData (in vec4 data, out vec2 coord, out vec3 color)\n{\n    coord = data.xy;\n    color.x = floor(data.z / 256.0) / 255.0;\n    color.y = mod(data.z, 256.0) / 255.0;\n    color.z = mod(data.w, 256.0) / 255.0;\n}\n\n//============================================================\nvec4 StepJFA (in vec2 fragCoord, in float level)\n{\n    level = clamp(level, 0.0, c_maxSteps);\n    float stepwidth = floor(exp2(c_maxSteps - level)+0.5);\n    \n    float bestDistance = 9999.0;\n    vec2 bestCoord = vec2(0.0);\n    vec3 bestColor = vec3(0.0);\n    \n    for (int y = -1; y <= 1; ++y) {\n        for (int x = -1; x <= 1; ++x) {\n            vec2 sampleCoord = fragCoord + vec2(x,y) * stepwidth;\n            \n            vec4 data = texture( iChannel0, sampleCoord / iChannelResolution[0].xy);\n            vec2 seedCoord;\n            vec3 seedColor;\n            DecodeData(data, seedCoord, seedColor);\n            float dist = length(seedCoord - fragCoord);\n            if ((seedCoord.x != 0.0 || seedCoord.y != 0.0) && dist < bestDistance)\n            {\n                bestDistance = dist;\n                bestCoord = seedCoord;\n                bestColor = seedColor;\n            }\n        }\n    }\n    \n    return EncodeData(bestCoord, bestColor);\n}\n\n//============================================================\nvec4 DrawShapes (in vec2 fragCoord)\n{\n    #if DIST_OUTSIDE == 1\n    \tvec4 ret = vec4(0.0);\n    #else\n    \tvec4 ret = EncodeData(fragCoord, vec3(0.0, 1.0, 0.0));\n    #endif\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = (fragCoord / iResolution.xy);\n    uv.x *= aspectRatio;    \n    \n    // draw circles\n    for (int i = 0; i < c_numCircles; ++i)\n    {\n        vec2 posuv = hash22(vec2(i, iDate.w));\n        posuv.x *= aspectRatio;\n        \n        vec3 color = hash32(vec2(i, iDate.w));\n        float radius = mix(c_circleRadius.x, c_circleRadius.y, hash12(vec2(i, iDate.w)));\n\t\tfloat dist = length(uv-posuv);\n       \n        if (dist <= radius) {\n            #if DIST_OUTSIDE == 1\n            \tret = EncodeData(fragCoord, color);      \n            #else\n            \tret = vec4(0.0);\n            #endif\n        }\n    }\n    \n    // draw lines\n    for (int i = 0; i < c_numLines; ++i)\n    {\n        vec2 startuv = hash23(vec3(i, iDate.w, 0.453));\n        startuv.x *= aspectRatio;\n        \n        vec2 lineDir = normalize(hash23(vec3(i, iDate.w, 0.627)));\n        \n        vec3 color = hash33(vec3(i, iDate.w, 2.564));\n        float width = mix(c_lineSize.x, c_lineSize.z, hash13(vec3(i, iDate.w, 1.453)));\n        float height = mix(c_lineSize.y, c_lineSize.w, hash13(vec3(i, iDate.w, 0.894)));\n\t\tvec2 enduv = startuv + lineDir * width;\n        \n        float dist = UDFatLineSegment(uv, startuv, enduv, height);\n        \n        if (dist <= 0.0) {\n            #if DIST_OUTSIDE == 1\n            \tret = EncodeData(fragCoord, color);      \n            #else\n            \tret = vec4(0.0);\n            #endif            \n        }\n    }    \n    \n    // draw squiggle lines\n    for (int i = 0; i < c_numSquiggles; ++i)\n    {\n        vec2 startuv = hash23(vec3(i, iDate.w, 2.635));\n        startuv.x *= aspectRatio;\n        \n        vec2 squiggleDir = normalize(hash23(vec3(i, iDate.w, 0.912)));\n        \n        vec3 color = hash33(vec3(i, iDate.w, 0.123));\n        float width = mix(c_squiggleSize.x, c_squiggleSize.z, hash13(vec3(i, iDate.w, 0.342)));\n        float height = mix(c_squiggleSize.y, c_squiggleSize.w, hash13(vec3(i, iDate.w, 1.847)));\n\t\tvec2 enduv = startuv + squiggleDir * width;\n        \n        vec2 uvOffset = vec2(0.0);\n        float uvdp = dot(uv - startuv, squiggleDir);\n        vec2 normal = vec2(squiggleDir.y, -squiggleDir.x);\n        if (uvdp >= 0.0 && uvdp <= width)\n            uv += normal * sin(uvdp * 100.0) * 0.01;\n        \n        float dist = UDFatLineSegment(uv, startuv, enduv, height);\n        \n        if (dist <= 0.0) {\n            #if DIST_OUTSIDE == 1\n            \tret = EncodeData(fragCoord, color);      \n            #else\n            \tret = vec4(0.0);\n            #endif\n        }\n    }        \n\n    return ret;\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 adjustedFragCoord = fragCoord;\n    \n    // initialize random seed locations and colors\n    if (iFrame == 0) {\n        fragColor = DrawShapes(adjustedFragCoord);\n        return;\n    }\n    \n    // JFA steps\n    fragColor = StepJFA(adjustedFragCoord, floor(float(iFrame-1)));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*============================================================\n\nThis shader combines the outside distance from buf A with the\ninside distance from buf B to make a true SDF texture.\n\n============================================================*/\n\n// Shared constant between Buf C and Image\n// The sdf texture is 1/c_sdfShrinkFactor in size\nconst float c_sdfShrinkFactor = 4.0; \n\nconst float c_distanceWidth = 8.0; // This is the width in pixels that it transitions from outside to inside\n\n//============================================================\nvoid DecodeData (in vec4 data, out vec2 coord, out vec3 color)\n{\n    coord = data.xy;\n    color.x = floor(data.z / 256.0) / 255.0;\n    color.y = mod(data.z, 256.0) / 255.0;\n    color.z = mod(data.w, 256.0) / 255.0;\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 adjustedFragCoord = floor(fragCoord) * c_sdfShrinkFactor - 0.5;\n    \n    // get our data\n    vec2 uv = adjustedFragCoord / iResolution.xy;    \n    vec4 outsideData = texture(iChannel0, uv);\n    vec4 insideData = texture(iChannel1, uv);\n    \n    // decode outside data\n    vec2 outsideCoord;\n    vec3 outsideColor;\n    DecodeData(outsideData, outsideCoord, outsideColor);\n\n    // decode inside data\n    vec2 insideCoord;\n    vec3 insideColor;\n    DecodeData(insideData, insideCoord, insideColor);   \n    \n    // calculate distances\n    float outsideDist = clamp(length(outsideCoord-adjustedFragCoord) / c_distanceWidth, 0.0, 1.0);\n    float insideDist  = clamp(length(insideCoord-adjustedFragCoord)  / c_distanceWidth, 0.0, 1.0);\n    \n    // calculate output distance\n    float signedDistance = 0.5 + outsideDist * 0.5 - insideDist * 0.5;\n        \n    // set the color based on that distance\n    fragColor = vec4(signedDistance);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}