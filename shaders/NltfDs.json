{
    "Shader": {
        "info": {
            "date": "1663849761",
            "description": "This shader is visualizing the construction used in https://www.shadertoy.com/view/NldBDs\nSee top comment for explanation.\n\nMove control point with mouse.",
            "flags": 0,
            "hasliked": 0,
            "id": "NltfDs",
            "likes": 7,
            "name": "Biarc cubic Bezier approx expl.",
            "published": 3,
            "tags": [
                "2d",
                "bezier",
                "beziercurve",
                "spline",
                "curve",
                "cubic",
                "arc",
                "biarc"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 222
        },
        "renderpass": [
            {
                "code": "/*\nThe idea is the same as in https://www.shadertoy.com/view/sl3BWs\nThe difference is that now the intersection of both\ngreen circles with the cubic bezier curve is computed.\n\nIn the quadratic bezier case, one always has an\nintersection with the green circle where the incenter lies on.\n\nIn the cubic bezier case, one has to check both green circles\nfor intersections.\n\nAlso, the polynomial equation one has to solve is quartic\ninstead of quadratic now, so this is much more involved computationally.\n\nThere should always be exactly one intersection.\n(I've read this somewhere, not sure how to prove this)\n*/\n\n//#define MOVE_NODE /* Move the node with the mouse instead */\n\nconst vec3 dot_col=vec3(0);\nconst vec3 line_col=vec3(0);\nconst vec3 bezier_col=vec3(0,0,1);\nconst vec3 arc_col=vec3(1,0,0);\nconst vec3 bg_col=vec3(1);\n\nconst float dot_size=.004;\nconst float line_width=.001;\n\nconst float zoom=1.;\n\nconst float pi=3.1415925;\n\nconst float eps = .000005;\n\nvec2 parametric_cubic_bezier(float t, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a0 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a1 = (3. * p0  -6. * p1 + 3. * p2);\n\tvec2 a2 = (-3. * p0 + 3. * p1);\n\tvec2 a3 = p0;\n\n\treturn (((a0 * t) + a1) * t + a2) * t + a3;\n}\n\nfloat cubic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){\n\t//horner's method\n\tvec2 a_2=a2+t*a3;\n\tvec2 a_1=a1+t*a_2;\n\tvec2 b_2=a_2+t*a3;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*b_2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat cubic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tvec4 t0=vec4(0.,.25,.75,1.);\n\tfloat t;\n\n\tfor(int i=0;i<3;i++){\n\t\tt=t0[i];\n\t\tfor(int j=0;j<3;j++){\n\t\t\tt=cubic_bezier_normal_iteration(t,a0,a1,a2,a3);\n\t\t}\n\t\tt=clamp(t,0.,1.);\n\t\tvec2 uv_to_p=((a3*t+a2)*t+a1)*t+a0;\n\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t}\n\n\treturn d0;\n}\n\nfloat cubic_bezier_dis_approx(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\treturn sqrt(cubic_bezier_dis_approx_sq(uv,p0,p1,p2,p3));\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n    // normal form: x^2 + px + q = 0\n    float p = coeffs[1] / 2.;\n    float q = coeffs[0];\n\n    float D = p * p - q;\n\n    if (D < 0.){\n\t\treturn 0;\n    }\n    else if (D > 0.){\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n    }\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\n\tfloat f,f1;\n\tr[0] = offset + u * (m + m);\n\n\tf = ((r[0] + a) * r[0] + b) * r[0] + c;\n\tf1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\tr[0] -= f / f1;\n\n\tr[1] = offset - u * (n + m);\n\n\tf = ((r[1] + a) * r[1] + b) * r[1] + c;\n\tf1=(3. * r[1] + 2. * a) * r[1] + b;\n\n\tr[1] -= f / f1;\n\n\tr[2] = offset + u * (n - m);\n\n\tf = ((r[2] + a) * r[2] + b) * r[2] + c;\n\tf1 = (3. * r[2] + 2. * a) * r[2] + b;\n\n\tr[2] -= f / f1;\n\n\treturn 3;\n}\n\nfloat halley_iteration4(vec4 coeffs, float x){\n\n\tfloat f = (((x + coeffs[3]) * x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\tfloat f1 = ((4. * x + 3. * coeffs[3]) * x + 2. * coeffs[2]) * x + coeffs[1];\n\tfloat f2 = (12. * x + 6. * coeffs[3]) * x + 2. * coeffs[2];\n\n\treturn x - (2. * f * f1) / (2. * f1 * f1 - f * f2);\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quartic(vec4 coeffs, inout vec4 s){\n\n\tfloat a = coeffs[3];\n\tfloat b = coeffs[2];\n\tfloat c = coeffs[1];\n\tfloat d = coeffs[0];\n\n    /*  substitute x = y - A/4 to eliminate cubic term:\n\tx^4 + px^2 + qx + r = 0 */\n\n    float sq_a = a * a;\n    float p = - 3./8. * sq_a + b;\n    float q = 1./8. * sq_a * a - 1./2. * a * b + c;\n    float r = - 3./256.*sq_a*sq_a + 1./16.*sq_a*b - 1./4.*a*c + d;\n\n\tint num;\n\n\t/* doesn't seem to happen for me */\n    //if(abs(r)<eps){\n\t//\t/* no absolute term: y(y^3 + py + q) = 0 */\n\n\t//\tvec3 cubic_coeffs;\n\n\t//\tcubic_coeffs[0] = q;\n\t//\tcubic_coeffs[1] = p;\n\t//\tcubic_coeffs[2] = 0.;\n\n\t//\tnum = solve_cubic(cubic_coeffs, s.xyz);\n\n\t//\ts[num] = 0.;\n\t//\tnum++;\n    //}\n    {\n\t\t/* solve the resolvent cubic ... */\n\n\t\tvec3 cubic_coeffs;\n\n\t\tcubic_coeffs[0] = 1.0/2. * r * p - 1.0/8. * q * q;\n\t\tcubic_coeffs[1] = - r;\n\t\tcubic_coeffs[2] = - 1.0/2. * p;\n\n\t\tsolve_cubic(cubic_coeffs, s.xyz);\n\n\t\t/* ... and take the one real solution ... */\n\n\t\tfloat z = s[0];\n\n\t\t/* ... to build two quadric equations */\n\n\t\tfloat u = z * z - r;\n\t\tfloat v = 2. * z - p;\n\n\t\tif(u > -eps){\n\t\t\tu = sqrt(abs(u));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(v > -eps){\n\t\t\tv = sqrt(abs(v));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tvec2 quad_coeffs;\n\n\t\tquad_coeffs[0] = z - u;\n\t\tquad_coeffs[1] = q < 0. ? -v : v;\n\n\t\tnum = solve_quadric(quad_coeffs, s.xy);\n\n\t\tquad_coeffs[0]= z + u;\n\t\tquad_coeffs[1] = q < 0. ? v : -v;\n\n\t\tvec2 tmp=vec2(1e38);\n\t\tint old_num=num;\n\n\t\tnum += solve_quadric(quad_coeffs, tmp);\n\n\t\t//s[old_num] = tmp[0];\n\t\t//s[old_num+1] = tmp[1];\n\n\t\tif(old_num == 0){\n            s[0] = tmp[0];\n            s[1] = tmp[1];\n        }\n        else{//old_num == 2\n            s[2] = tmp[0];\n            s[3] = tmp[1];\n        }\n\n    }\n\n    /* resubstitute */\n\n    float sub = 1./4. * a;\n\n\t/* single halley iteration to fix cancellation */\n\tfor(int i=0;i<4;i+=2){\n\t\tif(i < num){\n\t\t\ts[i] -= sub;\n\t\t\ts[i] = halley_iteration4(coeffs,s[i]);\n\n\t\t\ts[i+1] -= sub;\n\t\t\ts[i+1] = halley_iteration4(coeffs,s[i+1]);\n\t\t}\n\t}\n\n    return num;\n}\n\nfloat segment_dis( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvec2 incenter(vec2 p0, vec2 p1, vec2 p2){\n\tvec2 v1=normalize(p1-p0);\n\tvec2 v2=normalize(p2-p0);\n\n\tvec2 v3=normalize(p2-p1);\n\tvec2 v4=normalize(p0-p1);\n\n\tvec3 line1, line2;\n\tline1.xy=(v1+v2)/2.;\n\tline1.xy=vec2(-line1.y,line1.x);\n\tline1.z=-dot(line1.xy,p0);\n\n\tline2.xy=(v3+v4)/2.;\n\tline2.xy=vec2(-line2.y,line2.x);\n\tline2.z=-dot(line2.xy,p1);\n\n\tvec3 l12=cross(line1,line2);\n\n\treturn l12.xy/l12.z;\n}\n\nvec2 circumcenter(vec2 p0, vec2 p1, vec2 p2){\n\tvec3 line1, line2;\n\tline1.xy=p1-p0;\n\tline1.z=-dot(line1.xy,(p0+p1)/2.);\n\n\tline2.xy=p2-p1;\n\tline2.z=-dot(line2.xy,(p1+p2)/2.);\n\n\tvec3 m1=cross(line1,line2);\n\tm1/=m1.z;\n\n\treturn m1.xy;\n}\n\nvec2 compute_best_node(vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec3 line1, line2, line3, line4;\n\n\tline1.xy=p1-p0;\n\tline1.xy=vec2(line1.y,-line1.x);\n\tline1.z=-dot(line1.xy,p0);\n\n\tline2.xy=p3-p2;\n\tline2.xy=vec2(line2.y,-line2.x);\n\tline2.z=-dot(line2.xy,p2);\n\n\tvec3 l12=cross(line1,line2);\n\n\tvec2 m0=l12.xy/l12.z;\n\tvec2 m1=incenter(p0,m0,p3);\n\tvec2 m2=circumcenter(p0,m1,p3);\n\n\tline3.xy=m2-p0;\n\tline3.z=-dot(line3.xy,p0);\n\n\tline4.xy=p3-p0;\n\tline4.z=-dot(line4.xy,(p0+p3)/2.);\n\n\tvec3 l34=cross(line3,line4);\n\tvec2 m3=l34.xy/l34.z;\n\n\tvec2 a3=(-p0+3.* p1-3.*p2+p3);\n\tvec2 a2=(3.*p0-6.*p1+3.*p2);\n\tvec2 a1=(-3.*p0+3.*p1);\n\n\tvec2 a0_1=p0-m2;\n\tvec2 a0_2=p0-m3;\n\n\tfloat b5=dot(a3,a3);\n\tfloat b4=2.*dot(a3,a2);\n\tfloat b3=dot(a2,a2) + 2.*dot(a1,a3);\n\n\tfloat b2_1=2.*(dot(a1,a2) + dot(a0_1,a3));\n\tfloat b2_2=2.*(dot(a1,a2) + dot(a0_2,a3));\n\n\tfloat b1_1=dot(a1,a1) + 2.*dot(a0_1,a2);\n\tfloat b1_2=dot(a1,a1) + 2.*dot(a0_2,a2);\n\n\tfloat c4=b5;\n\tfloat c3=b4+c4;\n\tfloat c2=b3+c3;\n\n\tfloat c1_1=b2_1+c2;\n\tfloat c1_2=b2_2+c2;\n\n\tfloat c0_1=b1_1+c1_1;\n\tfloat c0_2=b1_2+c1_2;\n\n\tvec4 roots_1 = vec4(1e38);\n\tint num_roots_1 = solve_quartic(vec4(c0_1,c1_1,c2,c3)/c4,roots_1);\n\n\tfor(int i=0;i<num_roots_1;i++){\n\t\tif(roots_1[i] > 0. && roots_1[i] < 1.){\n\t\t\treturn parametric_cubic_bezier(roots_1[i],p0,p1,p2,p3);\n\t\t}\n\t}\n\n\tvec4 roots_2 = vec4(1e38);\n\tint num_roots_2 = solve_quartic(vec4(c0_2,c1_2,c2,c3)/c4,roots_2);\n\n\tfor(int i=0;i<num_roots_2;i++){\n\t\tif(roots_2[i] > 0. && roots_2[i] < 1.){\n\t\t\treturn parametric_cubic_bezier(roots_2[i],p0,p1,p2,p3);\n\t\t}\n\t}\n\n\treturn m1;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border=2./iResolution.x;\n\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n    uv.y*=iResolution.y/iResolution.x;\n\n\tvec2 mouse=iMouse.xy/iResolution.xy;\n\tmouse-=.5;\n    mouse.y*=iResolution.y/iResolution.x;\n\n\tborder*=zoom;\n\tuv*=zoom;\n\tmouse*=zoom;\n\n\tvec2 p0=vec2(-.3,-.1);\n\t#ifdef MOVE_NODE\n\tvec2 p1=vec2(-.4,.2);\n\t#else\n\tvec2 p1=mouse;\n    // Animate if mouse is in left bottom corner\n    if(max(iMouse.x, iMouse.y) < 20.){\n        p1=vec2(-.2,.0)+vec2(.1*sin(iTime),.2*cos(iTime));\n    }\n\t#endif\n\tvec2 p2=vec2(.1,-.2);\n\tvec2 p3=vec2(.2,.15);\n\n\tvec3 line0, line1, line2, line3, line4, line5, line6, line7;\n\n\t// Tangent in p0\n\n\tline0.xy=p0-p1;\n\tline0.xy=normalize(vec2(line0.y,-line0.x));\n\tline0.z=-dot(line0.xy,p0);\n\n\t// Tangent in p3\n\n\tline1.xy=p2-p3;\n\tline1.xy=normalize(vec2(line1.y,-line1.x));\n\tline1.z=-dot(line1.xy,p3);\n\n\t// Tangent intersection point\n\tvec3 l01=cross(line0,line1);\n\tvec2 p4=l01.xy/l01.z;\n\n\t#ifdef MOVE_NODE\n\tvec2 node=mouse;\n\t#else\n\tvec2 node=compute_best_node(p0,p1,p2,p3);\n\t#endif\n\n\tvec3 color=bg_col;\n\n\t// Show segments\n\tfloat dis=segment_dis(uv,p0,p1)-line_width;\n\tdis=min(dis,segment_dis(uv,p1,p2)-line_width);\n\tdis=min(dis,segment_dis(uv,p2,p3)-line_width);\n\tcolor=mix(line_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\t// Show cubic bezier curve\n\tdis=cubic_bezier_dis_approx(uv,p0,p1,p2,p3)-line_width;\n\tcolor=mix(bezier_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\t// Line at p0 perpendicular to the segment between p0 and p1\n\tline2.xy=p4-p0;\n\tline2.z=-dot(line2.xy,p0);\n\n\t// Perpendicular bisector of segment between p0 and node\n\tline3.xy=node-p0;\n\tline3.z=-dot(line3.xy,(p0+node)/2.);\n\n\t// Line at p3 perpendicular to the segment between p2 and p3\n\tline4.xy=p3-p4;\n\tline4.z=-dot(line4.xy,p3);\n\n\t// Perpendicular bisector of segment between p3 and node\n\tline5.xy=node-p3;\n\tline5.z=-dot(line5.xy,(p3+node)/2.);\n\n\t// The midpoint of the first arc\n\tvec3 l23=cross(line2,line3);\n\tvec2 m1=l23.xy/l23.z;\n\tfloat r1=distance(m1,p0);\n\n\t// The midpoint of the second arc\n\tvec3 l45=cross(line4,line5);\n\tvec2 m2=l45.xy/l45.z;\n\tfloat r2=distance(m2,p3);\n\n\tvec2 m3=incenter(p0,p4,p3);\n\n\t// The midpoint of the first green circle\n\tvec2 m4=circumcenter(p0,m3,p3);\n\tfloat r4=distance(p0,m4);\n\n\t// Line at p0 perpendicular to the first green circle\n\tline6.xy=m4-p0;\n\tline6.z=-dot(line6.xy,p0);\n\n\t// Perpendicular bisector of segment between p0 and p3\n\tline7.xy=p3-p0;\n\tline7.z=-dot(line7.xy,(p0+p3)/2.);\n\n\t// The midpoint of the second green circle\n\tvec3 l67=cross(line6,line7);\n\tvec2 m5=l67.xy/l67.z;\n\tfloat r5=distance(p0,m5);\n\n\t// Show red circles (arcs)\n\tdis=abs(distance(m1,uv)-r1)-line_width;\n\tdis=min(dis,abs(distance(m2,uv)-r2)-line_width);\n\tcolor=mix(arc_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\t// Show green circles\n\tdis=abs(distance(m4,uv)-r4)-line_width;\n\tdis=min(dis,abs(distance(m5,uv)-r5)-line_width);\n\tcolor=mix(vec3(0,1,0),color,smoothstep(-border/2.,border/2.,dis));\n\n\t// Show dots\n\tdis=distance(p0,uv)-dot_size;\n\tdis=min(dis,distance(uv,p1)-dot_size);\n\tdis=min(dis,distance(uv,p2)-dot_size);\n\tdis=min(dis,distance(uv,p3)-dot_size);\n\tdis=min(dis,distance(uv,p4)-dot_size);\n\tdis=min(dis,distance(uv,node)-dot_size);\n\tdis=min(dis,distance(m1,uv)-dot_size);\n\tdis=min(dis,distance(m2,uv)-dot_size);\n\tdis=min(dis,distance(m3,uv)-dot_size);\n\tdis=min(dis,distance(m4,uv)-dot_size);\n\tdis=min(dis,distance(m5,uv)-dot_size);\n\tcolor=mix(dot_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\tfragColor=vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}