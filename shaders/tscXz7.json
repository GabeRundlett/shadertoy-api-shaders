{
    "Shader": {
        "info": {
            "date": "1571684782",
            "description": "Ray marched endless zoom on the Menger sponge",
            "flags": 0,
            "hasliked": 0,
            "id": "tscXz7",
            "likes": 8,
            "name": "Shadertober 21 Cheese -jaburns",
            "published": 3,
            "tags": [
                "fractal",
                "raymarch",
                "menger"
            ],
            "usePreview": 0,
            "username": "jaburns",
            "viewed": 535
        },
        "renderpass": [
            {
                "code": "#define ITERATIONS  100\n#define EPSILON      0.0001\n#define MAX_DIST    100.\n#define PI 3.14159265358979\n\nmat2 rot(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat sdBox2d(vec2 p, float r)\n{\n    vec2 q = abs(p) - r;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat sdBox( vec3 p, float b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCross(vec3 p, float r)\n{\n    return min(sdBox2d(p.yz, r), min(sdBox2d(p.xy, r), sdBox2d(p.xz, r)));\n}\n\nfloat opSubtract(float a, float b)\n{\n    return max(a, -b);\n}\n\nfloat map(vec3 p, float scale)\n{\n    p /= scale;\n    \n    p = mod(p + 3., 6.) - 3.;\n    \n    float d = sdBox(p, 3.);        \n    d = opSubtract(d, sdCross(p, 1.));\n\n    float s = 1.;\n    for (int i = 0; i < 6; ++i) {\n        vec3 p1 = mod(s*p + 1., 2.) - 1.;\n        float cutDist = sdCross(p1, 1. / 3.) / s;\n        d = opSubtract(d, cutDist);\n        s *= 3.;\n    }\n\n    return d * scale;\n}\n\nstruct MarchResult\n{\n    vec3 pos;\n    float dist;\n    float ao;\n};\n\nMarchResult march(vec3 ro, vec3 rd, float scale)\n{\n    float dist, totalDist = 0.0;\n    \n    int i;\n    for (i = 0; i < ITERATIONS; ++i) {\n    \tdist = map(ro, scale);\n        if (dist < EPSILON || totalDist > MAX_DIST) break;        \n        totalDist += dist;\n        ro += rd * dist;\n    }\n    \n    return MarchResult(ro, dist < EPSILON ? totalDist : -1., 1. - float(i)/100.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy - vec2(.5*iResolution.x/iResolution.y, .5);\n\n    // ===== Camera =====\n\n    float T = 20.;\n    float t = mod(iTime / T, 1.);\n    float zoom = mix(1., 3., t);\n\tvec3 rd;\n    const float x0 = 2.;\n    const float xx = 6.;\n    const float yy = 8. - (.666);\n  \n    vec3 ro;\n    if (t < .5) {\n        t *= 2.;\n        ro = zoom*vec3(x0,0, -yy * (  2.*t-t*t ));\n        float angle = -PI / 2. * (.5-.5*cos(PI*t));\n        rd = normalize(vec3(uv, -1));\n        rd.xz *= rot(angle);\n        rd.yz *= rot(2.*PI* (.5-.5*cos(PI*t)) );\n    } else {\n        t = 2.*(t - .5);\n        vec3 roA = zoom*vec3(x0,0,-yy);\n        vec3 roB = zoom*vec3(x0+xx*t,0,-yy);\n        ro = mix(roA, roB, smoothstep(0.,1.,clamp(4.*t, 0., 1.)));\n        float look = (1.-(2.*t-1.)*(2.*t-1.)) * sin(2.*PI*t);                \n        rd = normalize(vec3(uv + .5*look, -1));\n        rd.xz *= rot(-PI / 2.);\n        rd.zy *= rot(.25*look);\n    }\n    \n    // ==================\n    \n    MarchResult m = march(ro, rd, zoom);\n    \n    float vis = 0.;\n    if (m.dist >= 0.) {\n    \tvis = exp(-.2 * m.dist) * m.ao;\n    }\n    \n    const vec3 DARK = mix(vec3(97., 8., 52.) / 255., vec3(0), .2);\n    const vec3 LIGHT = vec3(255., 165., 0.) / 255.;\n    \n    fragColor = vec4(mix(DARK, LIGHT, vis), 0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}