{
    "Shader": {
        "info": {
            "date": "1662401301",
            "description": "A small pathtracing + voxel test inspired by MagicaVoxel and the works of MadMaraca (https://twitter.com/MadMaraca)",
            "flags": 32,
            "hasliked": 0,
            "id": "styyDV",
            "likes": 58,
            "name": "Lost temple",
            "published": 3,
            "tags": [
                "voxel",
                "pathtracing"
            ],
            "usePreview": 0,
            "username": "XT95",
            "viewed": 997
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    col /= col.a;\n\n\n    // Vignetting & color grading\n    col *= pow( uv.x * uv.y * (1.-uv.x) * (1.-uv.y)*10., .15 );\n    col = pow(col, vec4(1.1,1.1,1.0, 1.));\n    \n    // Output to screen\n    col = pow(col, vec4(1./2.2));\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define SCANLLINE_RENDER 8\n#define SUNDIR normalize(vec3(2.,.5,1.))\n\nfloat material;\n#define NONE -1.\n#define SAND 1.\n#define WALL 2.\n#define GRASS 3.\n\n\n// -----------------------------------------------------\n// Scene\n// -----------------------------------------------------\nfloat ground(vec3 p) { \n    float d = p.y;\n    float s = cos(p.x*.05+cos(p.z*.05)+cos(p.x*0.01+p.z*0.02));\n    d -= smoothstep(-1.,1.,s)*10.;\n    d += noise(p*.1)*5.;\n    return d;\n}\n\nfloat walls(vec3 p) {\n    float d = -box(p, vec3(100.));\n    d = max(d, -box(p-vec3(-100.,-60.,10.), vec3(100.,40.,30.)));\n    return d;\n}\n\n\nfloat grass(vec3 p, float w) {\n    float d = abs(box(p-vec3(0.,0.,0.), vec3(100., 103., 100.)));\n    d = max(d, p.y+0.);\n    //d = max(d,p.y+10.)*3.;\n    d -= (noise(p*vec3(.1,0.03,.1))*2.-1.)*5.;\n    d -= (noise(p*vec3(.5))*2.-1.)*3.;\n    //d = max(d, -w);\n    return d;\n}\n\n\nfloat column(vec3 p) {\n    float d = length(p.xz-vec2(-30.,50.))-5.;\n    d = max(d, p.y+30.-p.z);\n    d = min(d, box(p-vec3(-30.,-100.,50.), vec3(3.,6.,3.))-6.);\n    \n    p.xz = rotate(.5) * p.xz;\n    float dd = length(p.xy-vec2(-30.,-95))-5.;\n    dd = max(dd, p.z);\n    dd = max(dd, -p.z+p.x);\n    d = min(d, dd);\n    return d;\n\n}\n\nfloat map(vec3 p) {\n    float d = ground(p);\n    material = SAND;\n    float w = walls(p);\n    d = max(d, w);\n    if (w>-3.) {\n        if (w>-5.) \n            material = WALL;\n        d -= cos(noise(p*vec3(.1))*8.)*1.;\n        d = min(d, column(p));\n        d += pow((noise(p*.1)),10.)*5.;\n        float g = grass(p,w);\n        if (g < d) {\n            material = GRASS;\n            d = g;\n        }\n    }\n    return d;\n}\n\n\nfloat mapSimplified(vec3 p) {\n    float d = p.y-10.;\n    \n    float w = -box(p, vec3(100.));\n    w -= 5.;\n    d = max(d, w);\n    d = min(d, column(p)-1.);\n    return d;\n}\n\n\n\n\n// -----------------------------------------------------\n// Trace ray to the scene\n// It's a mix of voxel tracing and SDF tracing \n// -----------------------------------------------------\nvec3 trace(vec3 ro, vec3 rd, out vec3 mask){\n\tvec3 dRd = 1./abs(rd);\n\tvec3 sRd = sign(rd);\n\t\n    \n    // Safe start\n    vec3 p = floor(ro) + .5;\n    vec3 side = dRd*(sRd*(p - ro) + .5);\n\tfor (int i=ZERO; i<16; i++) {\n        if (map(p)<0.) return p;\n        mask = step(side, side.yzx)*(1. - step(side.zxy, side));\n\t\tside += mask*dRd;\n\t\tp += mask*sRd;\n\t}\n    \n    // Turbo\n    float d = mapSimplified(p);\n    if (d>0.) {\n        p += rd * d;\n        for(int i=0; i<32; i++) {\n            d = mapSimplified(p);\n            p += rd * d;\n            if (d < 1.) break;\n        }\n        if (p.y>30.) return p;\n    }\n    \n    // Safe landing\n    ro = p;\n    p = floor(ro) + .5;\n    side = dRd*(sRd*(p - ro) + .5);\n\tfor (int i=0; i<320; i++) {\n        if (map(p)<0.) break;\n        mask = step(side, side.yzx)*(1. - step(side.zxy, side));\n\t\tside += mask*dRd;\n\t\tp += mask*sRd;\n\t}\n    \n    return p;    \n}\n\n// -----------------------------------------------------\n// Shadow stuff\n// -----------------------------------------------------\nfloat shadow(vec3 p, vec3 ld) {\n    vec3 mask;\n    vec3 pp = trace(p,ld,mask);\n    return step(0., map(pp));\n}\nfloat shadowDistance(vec3 p, vec3 ld) {\n    vec3 mask;\n    vec3 pp = trace(p,ld,mask);\n    return length(pp-p);\n}\n\n// -----------------------------------------------------\n// Hardcoded blue area light\n// -----------------------------------------------------\nvec3 sampleAreaLight(vec2 u, vec3 p, vec3 n)\n{\n    u = u * 2.0f - 1.0f;\n    \n    vec3 lightPosition = vec3(-190.,-60.,10.);\n    vec3 lightRight = vec3(0.,0.,20.);\n    vec3 lightUp = vec3(0.,30.,0.);\n    vec3 lightForward = vec3(1.,0.,0.);\n    \n    vec3 samplePosition = lightPosition +\n                          lightRight * u.x +\n                          lightUp * u.y;\n    \n    vec3 lightDirection = samplePosition - p;\n    float lightDistance = length(lightDirection);\n    float inverseLightDistance = 1.0f / max(lightDistance, 1e-3f);\n    lightDirection *= inverseLightDistance;\n    \n    vec3 col = vec3(0.1,0.9,1.)*50.;\n    col *= (inverseLightDistance * inverseLightDistance);\n    col *= saturate(dot(-lightDirection, lightForward));\n    col *= step(lightDistance, shadowDistance(p+n,lightDirection));\n    \n    return col;\n}\n\n\n// -----------------------------------------------------\n// Pathtrace\n// -----------------------------------------------------\nvec3 pathtrace(vec3 ro, vec3 rd, vec3 seed) {\n    \n    vec3 abso = vec3(1.);\n    vec3 acc = vec3(0.);\n    \n    for(int i=0; i<2; i++) {\n        vec3 mask;\n        vec3 p = trace(ro,rd, mask);\n        if (map(p)>0.) {\n            break;\n        }\n        vec3 n = -(mask*sign( rd ));\n        float t = length(ro-p);\n        \n        \n        vec3 albedo = vec3(.1);\n        if (material == SAND)\n            albedo = vec3(0.1+(noise(p*.1)*.5+.5)*.1,0.07,0.025);\n        else if (material == WALL)\n            albedo = vec3(.1,.1,.1);\n        else if (material == GRASS) {\n            albedo = vec3(.025,.1,.0);\n            if (noise(p*.25)>.9 && p.y>-90.) albedo = vec3(.05,.01,.01);\n        }\n        \n        rd = cosineDirection(seed,n);\n        vec3 sd = mix(SUNDIR, seed*2.-1., .05);\n        \n        \n        vec3 dcol = vec3(0.);\n        dcol += vec3(.5,.7,1.)*.125 * shadow(p+n,rd);\n        dcol += vec3(1.,.3,.1)*2. * max(dot(n,sd),0.) * shadow(p+n,sd);\n        dcol += sampleAreaLight(vec2(hash(seed+1.),hash(seed)), p, n)*200.;\n        \n        abso *= albedo*5.;\n        acc += dcol * abso;\n        \n        seed = fract(seed + GOLDEN_RATIO);\n        ro = p+n;\n        \n    }\n    return acc;\n}\n\n// -----------------------------------------------------\n// Entrypoint\n// -----------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    vec2 uv = fragCoord.xy * invRes;\n    int f = iFrame % SCANLLINE_RENDER;\n    if(abs(uv.x-float(f)/float(SCANLLINE_RENDER)-.5f/float(SCANLLINE_RENDER)) > 1.f/(float(SCANLLINE_RENDER)*2.)) {\n        fragColor = texture(iChannel0, uv);\n        return;\n    }\n    \n    \n    material = NONE;\n    \n    vec3 seed = hash3(vec3(fragCoord.xy, float(iFrame)));\n    vec2 q = (fragCoord.xy+(seed.xy-.5)*.5) * invRes;\n    vec2 v = q*2.-1.;\n    v.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(91.7, 130., -91.7)*45.5;\n    vec3 rd = normalize(vec3(v,100.));\n    rd.yz = rotate(PI*.25) * rd.yz;\n    rd.xz = rotate(PI*.25) * rd.xz;\n\n    \n    vec3 col = pathtrace(ro,rd, seed);\n    vec4 lastFrame = texture(iChannel0, uv);\n    fragColor = lastFrame+vec4(col,1.0);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// math\n#define ZERO (min(iFrame,0)) // skip unroll loop\n#define time iTime\n#define PI 3.141592653589\n#define saturate(x) clamp(x,0.,1.)\n#define GOLDEN_RATIO 0.61803398875f\nfloat hash( vec3 x );\nfloat hash( float p );\nfloat noise( vec3 x );\nmat2 rotate( float t );\nfloat box( vec3 p, vec3 b );\n\n// tone mapping\nvec3 acesToneMapping( vec3 col );\nvec3 filmicToneMapping( vec3 col );\n\n\n\n\n\n// ---------------------------------------------\n// Math\n// ---------------------------------------------\nfloat hash( float p ) \n{\n    return fract(sin(p)*43758.5453123);\n}\n\nfloat hash( vec3 p )\n{\n    return fract(sin(dot(p,vec3(127.1,311.7, 74.7)))*43758.5453123);\n}\nvec3 hash3(vec3 p) {\n    uvec3 x = uvec3(p*100000.+1000.);\n    const uint k = 1103515245U; \n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec3 cosineDirection( vec3 seed, in vec3 n)\n{\n    vec2 rnd = seed.xy;\n\n    float a = 6.2831853 * rnd.y;\n    rnd.x = 2.0*rnd.x - 1.0;\n    return normalize( n + vec3(sqrt(1.0-rnd.x*rnd.x) * vec2(cos(a), sin(a)), rnd.x) );\n\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n#if 0\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n#else\nfloat noise(vec3 p)\n{\n    vec3 i = floor(p);\n    vec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n    vec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n    a = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n    a.xy = mix(a.xz, a.yw, f.y);\n    return mix(a.x, a.y, f.z)*.5+.5;\n}\n#endif\n\nmat2 rotate( float t ) {\n    float a = cos(t);\n    float b = sin(t);\n    \n    return mat2( a, b, -b, a );\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}