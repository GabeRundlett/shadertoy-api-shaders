{
    "Shader": {
        "info": {
            "date": "1696802367",
            "description": "rayMarching + spotlight source",
            "flags": 0,
            "hasliked": 0,
            "id": "mdVcWK",
            "likes": 0,
            "name": "RayMarching-PhongLightSimulation",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "mokasiri",
            "viewed": 161
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265358979\n#define MAX_DIST 1000.\n#define MAX_STEPS 100\n#define SURFACE_DIST 0.01\n\nfloat random (vec2 st) \n{\n    return fract(sin(dot(st.xy,\n    vec2(12.9898,78.233)))*\n    43758.5453123);\n}\n\n\nfloat GetDist(vec3 p){\n    vec4 sphere = vec4(0.0,1.,6.0, 1.0);\n    //sphere.xz += vec2(-sin(iTime) * 2., -cos(iTime) * 2.);\n    float sphereDist = length(p - sphere.xyz) - sphere.w; // distance to the sphere\n    \n    float planeDist = p.y; // distance to the plane \n    float dis = min(sphereDist, planeDist); // picking the smallest distance\n    return dis;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float d0 = 0.0;\n    for(int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro + d0 * rd; // blue points on the circles\n        float ds = GetDist(p);\n        d0 += ds;\n        if (ds < SURFACE_DIST || d0 > MAX_DIST) break;\n    }\n    return d0; // Returns the distance of the camera origin (based on the specific pixel) to the sphere of plane\n}\n\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(0.01,0.0);\n    vec3 dists = vec3(GetDist(p- e.xyy), GetDist(p - e.yxy), GetDist(p - e.yyx)); //\n    vec3 n = d - dists;\n    return normalize(n);\n}\n\n\nvec3 GetLight (vec3 p,vec3 ro){\n    vec3 MainlightDirection = vec3(.0, 1.0, .0); // for creating spot light\n    vec3 rgb = vec3(0.925,0.714,0.514); // light color\n    vec4 sphere = vec4(0.0, 1.0, 6.0, 1.0);\n    vec3 lightPos = vec3(0., 4., 5.);\n    lightPos.xz += vec2(sin(iTime), cos(iTime));\n    //lightPos.y += 2. * iMouse.y;\n    //lightPos.x += 2. * iMouse.x;\n    float distance2light = length(lightPos - p);\n    vec3 lightDirection = normalize(lightPos - p);\n    //vec3 viewDirection = normalize(p - \n    ro = vec3(ro.x, ro.y, ro.z);\n    vec3 h = normalize((lightDirection + ro)/length(lightDirection + ro));\n    \n    vec3 n = GetNormal(p);\n    //float dif = dot(n,lightDirection);\n    float dif = clamp(dot(n,lightDirection), 0., 1.0); \n    \n    float d = RayMarch(p + n * SURFACE_DIST * 2.0, lightDirection); // distance from point p to the direction of light\n    // if we do not add any number value to the p, it will be smaller than SURFACE_DIST and the raymarching loop does not work\n    // addition of n (normal) ensures that the point does not go inside of the sphere.\n    //because if it goes inside of the sphere, it reaches the inner surface instantly and will be considered as being in the shadow\n    \n    // Implementing light sternght reduction based on distance\n    float kc = 0.1;\n    float kl = 0.1;\n    float kq = 0.01;\n    \n    \n    float spec = max(pow(dot(h,n),30.), 0.01);\n    dif += spec;\n    \n    /* Directional Light*/\n    float kWide = 1.2;\n    dif = dif * max(dot(MainlightDirection,lightDirection) * kWide, 0.0) /max(kc + kl * distance2light + kq * distance2light * distance2light, 1.0);\n    \n    /* Point Light */\n    //dif = dif/max(kc + kl * distance2light + kq * distance2light * distance2light, 1.0);\n    \n    \n    \n    \n    // shadow\n    if(d <length(lightPos - p)) dif *= 0.05; \n    if(length(p) < MAX_DIST) dif += 0.1; // Ambient Light, except points in far away (sky)\n    \n   // return dif;\n   return dif * rgb;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * gl_FragCoord.xy - iResolution.xy)/ iResolution.y;\n    //vec2 p = vUv;\n\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0.0, 1., 0.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n\n    float d = RayMarch(ro,rd); // The distanse from the origin (based on pixel direction) to the collision point\n\n    vec3 p = ro + rd * d;   // The coordinate of the collision point based on the ray casted from camera origin (based on pixel direction)\n                            // another word: if you cast a ray from each pixel it will collid to a point,\n                            // the coordination of that specific point is 'vec3 p = ro + rd * d' which d was calculated by raymarching\n\n    vec3 dif = GetLight(p,ro);\n    col = dif;\n\n    //vec3 normcol = normalize(vec3(col));\n    //col = GetNormal(p);\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}