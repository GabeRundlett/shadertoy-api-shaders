{
    "Shader": {
        "info": {
            "date": "1563272960",
            "description": "fresnel",
            "flags": 0,
            "hasliked": 0,
            "id": "3llXW7",
            "likes": 3,
            "name": "[Ese] fresnel",
            "published": 3,
            "tags": [
                "raymarching",
                "refraction",
                "fresnel"
            ],
            "usePreview": 0,
            "username": "Eseris",
            "viewed": 503
        },
        "renderpass": [
            {
                "code": "#define pow(a,b) pow(abs(a),(b))\n\nconst int MARCHING_STEPS = 150;\nconst int ALIASING_STEPS = 1;\nconst float MIN_DIST = 0.;\nconst float MAX_DIST = 40.;\nconst float EPSILON = 1e-3;\n\nmat2 rot(float a) {\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat sdSphere(vec3 p, float radius) {\n\treturn length(p) - radius;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdRoundedCylinder(vec3 p, float ra, float rb, float h) {\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nvec2 vUnion(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec2 map(vec3 p) {\n    vec2 d = vec2(sdPlane(p, vec4(0, 1, 0, 1.)), .1);\n    \n    {\n        vec3 p2 = p  - vec3(-5, 1, 0);\n        p2.zx *= rot(iTime);\n    \td = vUnion(d, vec2(sdBox(p2, vec3(1, 2, 1)), 1.68));\n    }\n    \n    d = vUnion(d, vec2(sdSphere(p - vec3(4, 0., 1), 1.3), 1.27));\n    d = vUnion(d, vec2(sdRoundedCylinder(p - vec3(0, 1.1, 0), 1., .3, 1.7), 2.85));\n    \n    //{\n    //    vec3 p2 = p  - vec3(0, 1.3, 0);\n    //    p2.yx *= rot(.6);\n    //\td = vUnion(d, vec2(sdRoundedCylinder(p2, .12, .1, 3.), 2.2));\n    //}   \n    \n\treturn d;\n}\n\nvec3 mapGradient(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy).x - map(p - e.xyy).x,\n\t\tmap(p + e.yxy).x - map(p - e.yxy).x,\n        map(p + e.yyx).x - map(p - e.yyx).x\n\t));\n}\n\nvec2 rayProcess(vec3 camPos, vec3 rayDir, float start, float end) {\n\tfloat depth = start;\n   \tvec2 e = vec2(end, 0.);\n\tfor(int i = 0; i < MARCHING_STEPS; ++i) {\n\t\tvec2 dist = map(camPos + depth * rayDir);\n\t\tif(abs(dist.x) < EPSILON) return vec2(depth, dist.y);\n\t\tdepth += abs(dist.x);\n\t\tif(dist.x >= end) return e;\n\t}\n\treturn e;\n}\n\nvec3 rayDirection(float camAngle, vec2 coord) {\n\tvec2 uv = (coord - .5) * iResolution.xy;\n\tfloat focalDist = iResolution.y / 2. / tan(radians(camAngle) / 2.);\n\treturn normalize(vec3(uv, -focalDist));\n}\n\n\nfloat checkerboard(in vec3 p) {\n    vec3 q = floor(p);\n    return mod(q.x + q.z,2.);              \n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    const float maxHei = 2.;\n    float tp = (maxHei-ro.y)/rd.y; \n    if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=min(0, iFrame); i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 palette(float t) {\n\treturn vec3(.6, .5, .5) \n\t\t+ .5 * cos(6.283185 * (-vec3(1., 1., .5) * t + vec3(.2, .15, -.1) - .2));\n}\n\nvec3 applyLight(vec3 p, vec3 rd, vec3 nor, float id) {\n    vec3 col = vec3(0.);\n\n    // material        \n    vec3 mate = .7 * palette(fract(id));\n    if(id < 1.) {\n        float f = checkerboard(p);\n        mate = 0.2 + f*vec3(0.08);\n    }\n\n    // key light\n    vec3  lig = normalize(vec3(-8., 8., 5.));\n    vec3  hal = normalize( lig-rd );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\n    float spe = pow(dot( nor, hal ), 100.0);//*\n       // dif * (0.04 + 0.99*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 6.0 ));\n    \n    dif *= calcSoftshadow(p, lig, .1, 3.);\n\n    col = mate * 3.*dif*vec3(.80,0.70,0.6);\n    col +=      .6*spe*vec3(1.00,0.70,0.5);\n\n    // ambient light\n    float amb = .6;\n    col += mate*amb;\n    \n\treturn col;\n}\n\nvec3 refract2(vec3 i, vec3 n, float eta) {\n    if(dot(i, n) < 0.) eta = 1. / eta;\n    else n = -n;\n    return refract(i, n, eta);\n}\n\n\nvec3 basicShading(vec3 ro, vec3 rd, int nStep) {\n    vec3 resCol = vec3(0);\n    vec3 p = ro;\n    float alpha = 1.;\n    for(int i = nStep; i > 0; --i) {\n        vec2 d = rayProcess(p, rd, MIN_DIST, MAX_DIST);\n    \tp += d.x * rd;\n    \tvec3 nor = mapGradient(p);\n        \n    \tvec3 col = applyLight(p, rd, nor, d.y);\n        col *= pow(smoothstep(MAX_DIST, 10., d.x), 2.); // fog\n        \n        if(d.y < 2.) {\n        \tresCol += col * alpha;\n       \t\talpha *= .25;\n            rd = reflect(rd, nor);\n        }\n        else {\n            float transparency = .3;\n            resCol += col * alpha * transparency;\n            alpha *= (1. - transparency);\n            rd = refract2(rd, nor, 1.07);\n        }\n        \n        if(d.y < 1.) break; //i = min(i, 1);\n        \n        p += rd * 1e-2; // small incr to avoid null dist\n    }\n    \n\treturn resCol;\n}\n\n\nvec3 shading(vec3 ro, vec3 rd) {\n    vec3 resCol = vec3(0);\n    vec3 p = ro;\n    float alpha = 1.;\n    for(int i = 5; i > 0; --i) {\n        vec2 d = rayProcess(p, rd, MIN_DIST, MAX_DIST);\n    \tp += d.x * rd;\n    \tvec3 nor = mapGradient(p);\n        \n    \tvec3 col = applyLight(p, rd, nor, d.y);\n        col *= pow(smoothstep(MAX_DIST, 10., d.x), 2.); // fog\n        \n        if(d.y < 2.) {\n       \t\tfloat kr = pow(1. - abs(dot(nor,-rd)), 3.) + .03 + .13 * step(d.y, 1.);\n        \tresCol += col * alpha * (1. - kr);\n       \t\talpha *= kr;\n            rd = reflect(rd, nor);\n        }\n        else {\n       \t\tfloat kr = .05 + pow(1. - abs(dot(nor,-rd)), 4.);\n            vec3 rdRefl = reflect(rd, nor);\n            resCol += basicShading(p + rdRefl * 1e-2, rdRefl, i) * alpha * kr;\n            float transparency = .1;\n            resCol += col * alpha * transparency;\n            \n            alpha *= (1. - kr) * (1. - transparency);\n            rd = refract2(rd, nor, 1.1);\n        }\n        \n        if(d.y < 1.) break;//i = min(i, 2);\n        \n        p += rd * 1e-2; // small incr to avoid null dist\n    }\n    \n\treturn resCol;\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 tot = vec3(0.);\n    \n    for(int i = 0; i < ALIASING_STEPS; ++i) {\n        for(int j = 0; j < ALIASING_STEPS; ++j) {\n            vec2 offset = vec2(i, j) / 2. - .5;\n            vec3 camPos = vec3(0., 6., 10.);\n            vec3 rd = rayDirection(50., (fragCoord + offset) / iResolution.xy);\n            \n            float ang = .5 * iTime;\n            camPos.zx *= rot(ang);\n            rd.yz *= rot(.5);\n            rd.zx *= rot(ang);\n\n            vec3 col = vec3(0.);\n            col = shading(camPos, rd);\n            \n            // gamma\n            tot += pow(col, vec3(1. / 1.7));\n        }\n    }\n    \n    \n\tvec2 uv = fragCoord/iResolution.yy;\n    float x = fragCoord.x / iResolution.x;\n\t//tot = mix(tot, palette(x), step(abs(uv.y - .03), .02));\n    \n    tot /= float(ALIASING_STEPS * ALIASING_STEPS);\n\tfragColor = vec4(tot, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}