{
    "Shader": {
        "info": {
            "date": "1599517636",
            "description": "Attempt at recreating a cool gif I saw online.\nSadly, I don't know original author.",
            "flags": 0,
            "hasliked": 0,
            "id": "wlSBWm",
            "likes": 31,
            "name": "Rotating torus",
            "published": 3,
            "tags": [
                "raymarching",
                "torus",
                "animation",
                "loop",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "zduny",
            "viewed": 2400
        },
        "renderpass": [
            {
                "code": "const float pi = 3.1416;\n\nconst int steps = 256;\nconst vec4 background = vec4(vec3(0.0), 1.0);\nconst float ringRadius = 1.5;\nconst float pipeRadius = 0.3;\n\nconst bool showTexture = false;\n\nvec3 toSRGB(in vec3 color) { return pow(color, vec3(1.0 / 2.2)); }\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\nRay createRayPerspective(in vec2 resolution, in vec2 screenPosition,\n                         in float verticalFov) {\n  vec2 topLeft = vec2(-resolution.x, -resolution.y) * .5;\n  float z = (resolution.x * .5) / abs(tan(verticalFov / 2.0));\n\n  return Ray(vec3(0.0),\n             normalize(vec3(topLeft + screenPosition, -z)));\n}\n\nvec3 positionOnRay(in Ray ray, in float t) {\n  return ray.origin + ray.direction * t;\n}\n\nfloat sdTorus(in vec3 position, in float ringRadius, in float pipeRadius) {\n  vec2 q = vec2(length(position.xz) - ringRadius, position.y);\n  return length(q) - pipeRadius;\n}\n\nvec2 textureCoordinates(in vec3 position, in float ringRadius) {\n  vec2 q = vec2(length(position.xz) - ringRadius, position.y);\n  float u = (atan(position.x, position.z) + pi) / (2.0 * pi);\n  float v = (atan(q.x, q.y) + pi) / (2.0 * pi);\n  return vec2(u, v);\n}\n\nfloat map(in vec3 position) {\n  return -sdTorus(position, ringRadius, pipeRadius);\n}\n\nfloat sdSegment(in vec2 point, in vec2 a, in vec2 b) {\n  vec2 pa = point - a;\n  vec2 ba = b - a;\n\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\n  return length(pa - ba * h);\n}\n\nvoid drawSegment(in vec2 fragmentCoordinates, in vec2 p0, in vec2 p1,\n                 in float thickness, in vec4 color, inout vec4 outputColor) {\n  float d = sdSegment(fragmentCoordinates, p0, p1);\n  float a = 1.0 - clamp(d - thickness / 2.0 + 0.5, 0.0, 1.0);\n\n  outputColor = mix(outputColor, color, a * color.a);\n}\n\nvec4 tex(in vec2 uv) {\n  vec2 resolution = vec2(400.0);\n  uv *= resolution;\n  vec4 color = vec4(vec3(0.0), 1.0);\n  \n  float thickness = resolution.x / 100.0;\n    \n  vec2 position = uv;\n  position.x -= position.y - thickness * 3.0 - 2.0;\n  position.x = mod(position.x, resolution.x / 8.0);\n  position.y = mod(position.y, resolution.x / 30.0); \n  drawSegment(position, vec2(2.0, resolution.x / 30.0 * 0.5), \n              vec2(resolution.x / 8.0  * 0.5, resolution.x / 30.0 * 0.5), \n              thickness * 0.01, vec4(1.0), color);\n    \n  vec2 margin = vec2(50.0);\n  vec2 offset = vec2(resolution.x + 0.5, 0.5);\n  thickness *= 3.0;\n  drawSegment(uv, -margin, resolution + margin, thickness * 1.5, vec4(vec3(0.0), 1.0), color);\n  drawSegment(uv, -margin, resolution + margin, thickness, vec4(1.0), color);\n  drawSegment(uv, -margin - offset, resolution + margin - offset, thickness * 1.5, vec4(vec3(0.0), 1.0), color);\n  drawSegment(uv, -margin - offset, resolution + margin - offset, thickness, vec4(1.0), color);\n  drawSegment(uv, -margin + offset, resolution + margin + offset, thickness * 1.5, vec4(vec3(0.0), 1.0), color);\n  drawSegment(uv, -margin + offset, resolution + margin + offset, thickness, vec4(1.0), color);\n    \n  return color;\n}\n\nvec4 trace(in Ray ray) {    \n  ray.origin += vec3(0.0, 1.53, 0.85); \n    \n  float t = 0.0;\n  for (int i = 0; i < steps; i++) {\n    vec3 position = positionOnRay(ray, t).yxz;\n    float distance = map(position);\n    \n    if (distance < 0.002) {\n      vec2 uv = textureCoordinates(position, 1.5);\n      uv.x += iTime * 0.1;\n      uv.x = mod(uv.x * 10.0, 1.0);\n      return tex(uv) * clamp(1.2 - t * 0.25, 0.0, 1.0);\n    }\n      \n    t += distance * 0.999;\n  }\n\n  return background;\n}\n\nvec4 takeSample(in vec2 fragCoord) {\n  const float fov = pi / 2.0;\n    \n  Ray ray = createRayPerspective(iResolution.xy, fragCoord, fov);\n  return trace(ray);\n}\n\n#define SAMPLE(p) takeSample(p)\nvec4 superSample(in vec2 fragCoord, in int samples) {\n  if (samples == 1) {\n    return SAMPLE(fragCoord);\n  }   \n    \n  float divided = 1.0 / float(samples);\n\n  vec4 outColor = vec4(0.0);\n  for (int x = 0; x < samples; x++) {\n    for (int y = 0; y < samples; y++) {\n      vec2 offset = vec2((float(x) + 0.5) * divided - 0.5,\n                         (float(y) + 0.5) * divided - 0.5);\n      vec2 samplePosition = fragCoord + offset;\n      outColor += SAMPLE(samplePosition);\n    }\n  }\n\n  return outColor / float(samples * samples);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  if (showTexture) {\n    fragColor = tex(fragCoord / iResolution.xy);\n    return;\n  }\n    \n  fragColor = superSample(fragCoord, 2);\n  fragColor = vec4(toSRGB(fragColor.rgb), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}