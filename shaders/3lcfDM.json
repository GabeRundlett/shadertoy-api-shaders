{
    "Shader": {
        "info": {
            "date": "1612811270",
            "description": "I spent about 2 day on this shader. it is a montecarlo path tracer.\nif there is any optimisations plz tell me, because i am hoping that this will be real time,\nI used Michele Morrone glslSmartDeNoise (https://www.shadertoy.com/view/3dd3Wr)\nlike shader ( :",
            "flags": 32,
            "hasliked": 0,
            "id": "3lcfDM",
            "likes": 25,
            "name": "Fast path tracer v2.0",
            "published": 3,
            "tags": [
                "pathtracing"
            ],
            "usePreview": 1,
            "username": "me_123",
            "viewed": 1138
        },
        "renderpass": [
            {
                "code": "//I used Michele Morrone glslSmartDeNoise (https://www.shadertoy.com/view/3dd3Wr)\n#define INV_SQRT_OF_2PI 0.39894228040143267793994605993439  // 1.0/SQRT_OF_2PI\n#define INV_PI 0.31830988618379067153776752674503\nvec4 smartDeNoise(sampler2D tex, vec2 uv, float sigma, float kSigma, float threshold)\n{\n    float radius = round(kSigma*sigma);\n    float radQ = radius * radius;\n    \n    float invSigmaQx2 = .5 / (sigma * sigma);      // 1.0 / (sigma^2 * 2.0)\n    float invSigmaQx2PI = INV_PI * invSigmaQx2;    // 1.0 / (sqrt(PI) * sigma)\n    \n    float invThresholdSqx2 = .5 / (threshold * threshold);     // 1.0 / (sigma^2 * 2.0)\n    float invThresholdSqrt2PI = INV_SQRT_OF_2PI / threshold;   // 1.0 / (sqrt(2*PI) * sigma)\n    \n    vec4 centrPx = texture(tex,uv);\n    \n    float zBuff = 0.0;\n    vec4 aBuff = vec4(0.0);\n    vec2 size = vec2(textureSize(tex, 0));\n    \n    for(float x=-radius; x <= radius; x++) {\n        float pt = sqrt(radQ-x*x);  // pt = yRadius: have circular trend\n        for(float y=-pt; y <= pt; y++) {\n            vec2 d = vec2(x,y);\n\n            float blurFactor = exp( -dot(d , d) * invSigmaQx2 ) * invSigmaQx2PI; \n            \n            vec4 walkPx =  texture(tex,uv+d/size);\n\n            vec4 dC = walkPx-centrPx;\n            float deltaFactor = exp( -dot(dC, dC) * invThresholdSqx2) * invThresholdSqrt2PI * blurFactor;\n                                 \n            zBuff += deltaFactor;\n            aBuff += deltaFactor*walkPx;\n        }\n    }\n    return aBuff/zBuff;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = smartDeNoise(iChannel0, fragCoord.xy/iResolution.xy, 5.0, 1.0, .2);//texture(iChannel0, fragCoord.xy/iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float eps = 0.0000001;\nfloat INFINITY = 100000.;\nfloat hash(vec2 p) {\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nfloat hash3(vec3 pp) {\n    vec2 p = pp.xy+(pp.z/100.);\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nstruct ray {\n\tvec3 origin;\n    vec3 dir;\n};\nstruct mater {\n\tvec3 color;\n    int mat;\n    float ev;\n};\nstruct rec {\n    float t;\n    vec3  p;\n    vec3  normal;\n    mater mat;\n};\n\nstruct sphere {\n\tvec3 radius;\n    vec3 center;\n    mater mat;\n    int type;\n};\nvec4 nois(in vec3 x) {\n\tvec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.);\n    vec3 du = 30.*w*w*(w*(w-2.0)+1.0);\n    float a = hash3(p+vec3(0, 0, 0));\n    float b = hash3(p+vec3(1, 0, 0));\n    float c = hash3(p+vec3(0, 1, 0));\n    float d = hash3(p+vec3(1, 1, 0));\n    float e = hash3(p+vec3(0, 0, 1));\n    float f = hash3(p+vec3(1, 0, 1));\n    float g = hash3(p+vec3(0, 1, 1));\n    float h = hash3(p+vec3(1, 1, 1));\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k3 = e - a;\n    float k4 = a - b - c + d;\n    float k5 = a - c - e + g;\n    float k6 = a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n    return vec4(-1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z),\n                2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z, \n                                k2 + k5*u.z + k4*u.x + k7*u.z*u.x, \n                                k3 + k6*u.x + k5*u.y + k7*u.x*u.y));\n}\nvec4 fbm(in vec3 x, int octives) {\n\tfloat f = 1.98;\n    float s = 0.6;\n    float a = 0.0;\n    float b = 0.3;\n    vec3 d = vec3(0);\n    float o = 0.6;\n    mat3 m = mat3(o, 0, 0, 0, o, 0, 0, 0, o);\n    for (int i = 0; i < octives; i ++) {\n        vec4 n = nois(x);\n        a += b*n.x;\n        d += b*m*n.yzw;\n        b *= s;\n        x = f*m*x;\n        m = f*m*m;\n    }\n    return vec4(a, d);\n}\nvec3 rus(vec2 seed) {\n    float u = hash(seed);\n    float v = hash(seed+2.);\n    float theta = u * 2.0 * 3.1415;\n    float phi = acos(2.0 * v - 1.0);\n    float r = pow(hash(seed+10.), 0.33333333);\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    float x = r * sinPhi * cosTheta;\n    float y = r * sinPhi * sinTheta;\n    float z = r * cosPhi;\n    return vec3(x, y, z);//vec3(hash(seed)-0.5, hash(seed+2.0)-0.5, hash(seed+2.0)-0.5);\n}\nint sc = 11;\nsphere scene[11];\nbool hitObject(vec3 center, vec3 radius, ray r, float t_min, float t_max, out rec re, mater mat, int type) {\n    if (type == 0) {\n        vec3 oc = r.origin-center;\n        float a = dot(r.dir, r.dir);\n        float b = dot(oc, r.dir);\n        float c = dot(oc, oc) - radius.x*radius.x;\n        float disc = b*b - a*c;\n        if (disc > 0.) {\n            float temp = (-b - sqrt(b*b-a*c)) / a;\n            if (temp < t_max && temp > t_min) {\n                vec3 p = r.origin+r.dir*temp;\n                re.t = temp;\n                re.p = p;\n                re.normal = (p - center) / radius;\n                re.mat = mat;\n                return true;\n            }\n            temp = (-b + sqrt(b*b-a*c)) / a;\n            if (temp < t_max && temp > t_min) {\n                vec3 p = r.origin+r.dir*temp;\n                re.t = temp;\n                re.p = p;\n                re.normal = (p - center) / radius;\n                re.mat = mat;\n                return true;\n            }\n        }\n        return false;\n    } else {\n    \t    vec3 roo = r.origin;\n        vec3 rdd = r.dir;\n        vec3 rad = radius;//vec3(radius);\n        vec3 ro = r.origin-center;\n        vec3 rd = r.dir;\n        vec3 oN = vec3(0);\n        vec3 m = 1.0/rd;\n        vec3 n = m*ro;\n        vec3 k = abs(m)*rad;\n        vec3 t1 = -n - k;\n        vec3 t2 = -n + k;\n        float tN = max(max(t1.x, t1.y), t1.z);\n        float tF = min(min(t2.x, t2.y), t2.z);\n        if (tN > tF || tN < 0.0) {\n            return false;\n        }\n        if (tF > t_min && tN < t_max) {\n            oN = -sign(rd)*step(t1.yzx, t1.xyz)*step(t1.zxy, t1.xyz);\n            re.t = tN;\n            re.p = r.origin+r.dir*tN;\n            re.normal = oN;\n            re.mat = mat;\n            return true;\n        }\n        return false;\n    }\n}\nbool hitScene(ray r, float tmin, float tmax, out rec hit) {\n\tbool hitIt = false;\n    float closest = tmax;\n    for (int i = 0; i < sc; i += 1) {\n        if (hitObject(scene[i].center, scene[i].radius, r, tmin, closest, hit, scene[i].mat, scene[i].type)) {\n            hitIt = true;\n            closest = hit.t;\n        }\n    }\n    return hitIt;\n}\nvoid diffused(out ray r, vec2 seed, rec hit, inout vec3 c) {\n    vec3 target = hit.p + hit.normal + rus(seed);\n    r.origin = hit.p;\n    r.dir = target - (hit.p+eps);\n    c *= hit.mat.color;\n}\nvoid gloss(inout ray r, vec2 seed, rec hit, inout vec3 c) {\n    r.origin = hit.p;\n    r.dir = (reflect(r.dir, hit.normal)+(rus(seed)*hit.mat.ev));\n    c *= hit.mat.color;\n}\nvoid emit(inout ray r, vec2 seed, rec hit, inout vec3 c) {\n    c *= hit.mat.color*5.;\n}\nvec3 color(vec3 ro, vec3 rd, vec2 seed) {\n    vec3 c = vec3(1.0);\n    vec3 roo = ro;\n    vec3 rdd = rd;\n    int i;\n    for (i = 0; i < 20; i += 1) {\n        rec hit;\n        ray r = ray(roo, rdd);\n        if (hitScene(r, eps, INFINITY, hit)) {\n            ray rrr = r;\n            if (hit.mat.mat == 0) {diffused(rrr, seed, hit, c);}\n            else if (hit.mat.mat == 1) {gloss(rrr, seed, hit, c);}\n            else {emit(rrr, seed, hit, c);break;}\n            roo = rrr.origin;\n            rdd = rrr.dir;\n        } else {\n            vec3 dir = normalize(rdd);\n            float t = 0.5*(dir.y+2.);\n            c *= texture(iChannel1, dir).xyz;\n            break;\n        }\n\t}\n    return c;\n}\nint samples = 3;\nfloat camSize = 15.;\nvec3 drawImage(in vec2 fragCoord )\n{\n\tscene[0] = sphere(vec3(0.4, 2., 0.4), vec3(-4, 1.5, -4), mater(vec3(0.8, 0.3, 0.3), 0, 0.), 1);\n\tscene[1] = sphere(vec3(0.4, 2., 0.4), vec3(4, 1.5, -4), mater(vec3(0.8, 0.3, 0.3), 0, 0.), 1);\n\tscene[2] = sphere(vec3(0.4, 2., 0.4), vec3(4, 1.5, 4), mater(vec3(0.8, 0.3, 0.3), 0, 0.), 1);\n\tscene[3] = sphere(vec3(0.4, 2., 0.4), vec3(-4, 1.5, 4), mater(vec3(0.8, 0.3, 0.3), 0, 0.), 1);\n\tscene[4] = sphere(vec3(5, 0.1, 5), vec3(-0, 3.5, 0), mater(vec3(0.2, 0.6, 0.8), 0, 0.), 1);\n\tscene[5] = sphere(vec3(4, 0.25, 4), vec3(-0, 3.65, 0), mater(vec3(0.8, 0.8, 0.3), 1, 0.1), 1);\n\tscene[6] = sphere(vec3(5), vec3(-10, 10., 0), mater(vec3(1, 0.8, 0.2), 2, 0.), 0);\n\tscene[7] = sphere(vec3(5), vec3(10, 10., 0), mater(vec3(1, 0, 0), 2, 0.), 0);\n\tscene[8] = sphere(vec3(5), vec3(2, 20., 0), mater(vec3(0.5, 0.5, 1.0), 2, 0.), 0);\n\tscene[9] = sphere(vec3(20, 0.1, 20), vec3(0, -.6, -1), mater(vec3(0.8, 0.8, 0.8), 0, 0.5), 1);\n\tscene[10] = sphere(vec3(2), vec3(0, 6., 0), mater(vec3(0.8), 0, 0.), 0);\n    vec2 mouse = (iMouse.xy/iResolution.xy)-0.5;\n    float r = iResolution.x/iResolution.y;\n    mouse *= (r)*2.;\n    mouse.y = max(mouse.y, -0.0);\n    if (int(iMouse.x) == 0) {\n        mouse.x = 0.5;\n        mouse.y = 0.5;\n    }\n    vec3 c = vec3(0);\n    float tSeed = (iTime/10.);\n    for (int i = 0; i < samples; i += 1) {\n        vec2 uv = ((fragCoord.xy/iResolution.xy)-0.5) * vec2(r, 1.);\n        uv += (vec2(hash(uv+float(i)+tSeed), hash(uv+float(i)+float(samples+1)+tSeed))-0.5)/(iResolution.xy/2.);\n        vec3 ro = vec3(sin(mouse.x*5.)*camSize, mouse.y*camSize, cos(mouse.x*5.)*camSize);\n        vec3 at = vec3(0, 4.9, 0);\n        vec3 cam_z = normalize(at-ro);\n        vec3 cam_x = normalize(cross(vec3(0, 1, 0), cam_z));\n        vec3 cam_y = cross(cam_z, cam_x);\n        vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 1. * cam_z);\n        c += color(ro, rd, uv+(float(i)/1000.)+tSeed);\n    }\n   \treturn vec3(c/float(samples));\n}\nvec2 chunkPos = vec2(0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iMouse.z < 10.) {\n        fragColor = (vec4(drawImage(fragCoord), 1.0)+(texture(iChannel0, fragCoord/iResolution.xy))*100.)/101.;\n    } else {\n        fragColor = vec4(clamp(drawImage(fragCoord), 0.0, 1.0), 1.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}