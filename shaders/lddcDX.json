{
    "Shader": {
        "info": {
            "date": "1520451259",
            "description": "Raymarching",
            "flags": 0,
            "hasliked": 0,
            "id": "lddcDX",
            "likes": 2,
            "name": "raymarching___",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "SmartPointer",
            "viewed": 747
        },
        "renderpass": [
            {
                "code": "struct Material {\n    vec3 color;\n    bool reflective;\n};\n    \nMaterial materials[3] = Material[] (\n    Material(vec3(0.3, 0.8, 1.0), true),\n    Material(vec3(1.0, 1.0, 0.0), false),\n    Material(vec3(1.0, 1.0, 1.0), true)\n);\n\nvec2 shapeUnion(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat sphere(vec3 center, float radius, vec3 point) {\n    return length(center - point) - radius;\n}\n\nvec2 scene(vec3 pos) {\n    int shapeIndex = 0;\n    \n    vec2 f = vec2(sphere(vec3(-1, -1, 2), 2.0, pos), shapeIndex++);\n    f = shapeUnion(f, vec2(sphere(vec3(1, -1.0, 0), 1.0, pos), shapeIndex++));\n    f = shapeUnion(f, vec2(sphere(vec3(0, 1, 0), 1.0, pos), shapeIndex++));\n    \n    return f;\n}\n\nvec3 getNormal(vec3 pos) {\n    vec3 normal;\n    normal.x = scene(pos + vec3(0.01, 0, 0)).x - scene(pos - vec3(0.01, 0, 0)).x;\n    normal.y = scene(pos + vec3(0, 0.01, 0)).x - scene(pos - vec3(0, 0.01, 0)).x;\n    normal.z = scene(pos + vec3(0, 0, 0.01)).x - scene(pos - vec3(0, 0, 0.01)).x;\n    \n    return normalize(normal);\n}\n\nfloat shadowMarch(vec3 rayPos, vec3 lightPos) {\n    float shadowFactor = 1.0;\n    vec3 rayDir = normalize(lightPos - rayPos);\n    float totalDist = 0.1;\n    for (int i = 0; i < 100; i++) {\n        float dist = scene(rayPos + rayDir * totalDist).x;\n        if (dist < 0.01) {\n            shadowFactor = 0.0;\n            break;\n        }\n        totalDist += dist;\n    }\n    \n    return shadowFactor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 lightPos = vec3(0.0, 0.0, -2.0);\n    vec3 diffuseLightColor = vec3(1.0, 0.9, 0.8);\n    vec3 ambientLightColor = vec3(0.0);\n    \n    vec3 rayDir = normalize(vec3(\n        (fragCoord - iResolution.xy * 0.5) / iResolution.x,\n        1.0\n    ));\n    vec3 rayPos = vec3(0.0, 0.0, -8.0);\n    \n    vec3 color = vec3(0.0);\n    int reflectionCount = 0;\n    for (int i = 0; i < 100 && reflectionCount < 4; i++) {\n        vec2 result = scene(rayPos);\n        float dist = result.x;\n        int shapeIndex = int(result.y);\n        \n        if (dist < 0.01) {\n            vec3 lightDir = normalize(lightPos - rayPos);\n            vec3 normal = getNormal(rayPos);\n            \n            color += vec3(\n                materials[shapeIndex].color *\n                max(0.0, dot(normal, lightDir)) *\n                diffuseLightColor *\n                shadowMarch(rayPos, lightPos) +\n                ambientLightColor\n            );\n            \n            float ao = 0.0;\n            for(int k = 1; k < 5; k++){\n                vec3 aoRayPos = rayPos + normal * float(k) * 0.3;\n                vec2 r = scene(aoRayPos);\n                ao += (float(k) * 0.3 - r.x) / pow(2.0, float(k));\n            }\n            color *= 1.0 - ao;\n            \n            reflectionCount++;\n            if (materials[shapeIndex].reflective) {\n                i = 0;\n                rayDir = reflect(rayDir, normal);\n    \t\t\trayPos += rayDir * 0.01;\n            } else {\n                break;\n            }\n        }\n        rayPos += rayDir * dist;\n    }\n    \n    color /= float(reflectionCount);\n    fragColor = vec4(pow(color, vec3(1.0 / 2.2)), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}