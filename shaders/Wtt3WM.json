{
    "Shader": {
        "info": {
            "date": "1576531567",
            "description": "Geometric grid",
            "flags": 0,
            "hasliked": 0,
            "id": "Wtt3WM",
            "likes": 12,
            "name": "Reticolo",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "lucasassone",
            "viewed": 534
        },
        "renderpass": [
            {
                "code": "\n// restituisce le coordinate di p modulari tra -interval/2 e +interval/2 \nvec2 onRep(vec2 p, float interval) {\n\treturn mod(p, interval) - interval * 0.5;\n}\n\nfloat barDist(vec2 p, float interval, float width) {\n\treturn length(max(abs(onRep(p, interval)) - width, 0.0));\n}\n\nfloat cubeDist(vec3 p, float interval, float width) {\n\treturn length(max(abs(mod(p, interval) - interval * 0.5) - width, 0.0));\n}\n\nfloat sphereDist(vec3 p, float interval, float width) {\n\treturn length(0.5 * interval - abs(mod(p + vec3(0, 0, 3.0 * iTime), interval) - interval * 0.5)) - width;\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n\tvec3 a = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat r = 1.0 - c;\n\tmat3 m = mat3(\n\t\ta.x * a.x * r + c,\n\t\ta.y * a.x * r + a.z * s,\n\t\ta.z * a.x * r - a.y * s,\n\t\ta.x * a.y * r - a.z * s,\n\t\ta.y * a.y * r + c,\n\t\ta.z * a.y * r + a.x * s,\n\t\ta.x * a.z * r + a.y * s,\n\t\ta.y * a.z * r - a.x * s,\n\t\ta.z * a.z * r + c\n\t);\n\treturn m * p;\n}\n\n// distance estimator\nfloat sceneDist(vec3 p) {\n\tfloat bar_x = barDist(p.yz, 0.5, 0.0125);\n\tfloat bar_y = barDist(p.xz, 0.5, 0.0125);\n\tfloat bar_z = barDist(p.xy, 0.5, 0.0125);\n\treturn min(min(min(bar_x, bar_y), bar_z), min(cubeDist(p, 0.5, 0.0375), sphereDist(p, 1.0, 0.05)));\n}\n\nvec3 lerp(vec3 a, vec3 b, float f) {\n\treturn a + f * (b - a);\n}\n\n// ----------------------------------------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n//    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 p = ( fragCoord.xy * 2. - iResolution.xy ) / min(iResolution.x, iResolution.y);\n\tvec3 cameraPos = vec3(0.25 * iTime + 0.5, 0.125 * iTime, 0.25 * iTime + 0.125);\n\n\tvec2 a = 0.8 * p;\n\tvec3 rayDirection = normalize(vec3(sin(a.x) * cos(a.y), sin(a.y), cos(a.x) * cos(a.y)));\n\n\trayDirection = rotate(rayDirection, 0.5 * iTime, vec3(0., 0., 1.));\n\trayDirection = rotate(rayDirection, 0.5 * iTime, vec3(0., 1., 0.));\n\n\tfloat depth = 0.0;\n   \n\tvec3 col = vec3(0.8, 0.9, 1.0);\n\n\t// ray marching\n\tfor (int i = 0; i < 99; i++) {\n\t\tvec3 rayPos = cameraPos + rayDirection * depth;\n\t\tfloat dist = sceneDist(rayPos);\n\t\tif (dist < 0.0001) {\n\t\t\tcol = vec3(1.0, 0.9, 0.7) * (0.2 + 0.01 * float(i));\n\t\t\tcol = lerp(col, vec3(0.8, 0.9, 1.0), 0.01 * float(i));\n\t\t\tbreak;\n\t\t}\n\t\tdepth += dist;\n\t}\n    \n\t// effetto vignette\n\tvec2 sv = sin(fragCoord.xy / iResolution.xy * 3.141592);\n\tcol = col * (0.5 + 0.5 * sv.x * sv.y);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}