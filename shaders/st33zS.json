{
    "Shader": {
        "info": {
            "date": "1636254018",
            "description": "test",
            "flags": 34,
            "hasliked": 0,
            "id": "st33zS",
            "likes": 6,
            "name": "transx",
            "published": 3,
            "tags": [
                "transitions"
            ],
            "usePreview": 0,
            "username": "Sergeindamix",
            "viewed": 399
        },
        "renderpass": [
            {
                "code": "\n\nint n = 50;            // number of \"frames\" in transition\nfloat sa = .05;        // smooth amount - size of smooth edges\nbool roto = true;      // if true, rotate transitions that can optionally rotate\nfloat rota = 360.0;    // amount of rotation from start to end of transition\nint rn = 1, rd = 0;    // select based on whether to start with full\n//int rn = 0, rd = -1; //   frame of source1 (only for some transitions)\n\n#define SPEEDADJ .75\n//#define NEEDMOD 1\n\n#define imod(a,b) (int((float(a)-(float(b)*floor(float(a)/float(b))))))\n\n#define iGlobalTime (iTime / SPEEDADJ)\n\n#define num_transitions 33\n\n// macros for selecting/mixing the textures\n\n#define MEM2 col = alt ? col1 : col2;\n#define MEM1 col = alt ? col2 : col1;\n#define MEM12 col = alt ? v1 * col2 + v2 * col1 : v1 * col1 + v2 * col2;\n#define MEM1S { col = alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz; }\n\n// Solve some incompatibilities\n\n#define atan2 atan\n#define fmod mod\n#define texture2D texture\n\n// Useful values\n\n#define _TWOPI 6.283185307\n#define M_PI 3.141592654\n\nfloat intersect(vec2, vec2, vec2, vec2);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = fragCoord.xy / iResolution.xy, uv2;\nbool alt = false;\nint type, i, i2, j;\nvec3 col, col3;\nfloat v1, v2;\nfloat ye, yfe, dx, dy, cx, cy, rad, slope, theta, xc1, yc1, b, rad0, rad2;\nfloat xc2, yc2, b2, cx2, cy2, r1, vy1, vy2, dx2, dy2, ro, ri, ang, a, a1;\nfloat r, r2, l, l2, theta2, theta3, tang, ang1, ang2, angt, angs, c1, s1;\nfloat xc0, yc0;\nvec2 p1, p2, po, pd;\n\nfloat aspect = iResolution.y / iResolution.x;\nvec3 col1 = texture2D(iChannel0, uv).xyz;\nvec3 col2 = texture2D(iChannel1, uv).xyz;\nvec3 col4 = texture2D(iChannel2, uv).xyz;\nvec3 col5 = texture2D(iChannel3, uv).xyz;\n\n#ifdef NEEDMOD\ni = imod(int(iGlobalTime * 20.0) , n);\ntype = imod((int(iGlobalTime * 20.0) / n) , num_transitions);\nif (imod(type , 2)== 1) { alt = true; } else { alt = false; }\n#else\ni = int(iGlobalTime * 20.0) % n;\ntype = (int(iGlobalTime * 20.0) / n) % num_transitions;\nif (type % 2 == 1) { alt = true; col1=col4; } else { alt = false; col2=col5; }\n#endif\n\n//type = 32;\n\n// some of these equations are long, so I'll forego extra spaces\n\n// was a switch, but some GPUs won't do switch\n\n\t\tif (type==0) // fade in/out\n\t\t\t{\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\tMEM12\n\t\t\t}\n\t\telse if (type==1) // window down with soft edge\n\t\t\t{\n\t\t\tye=1.0-float(i)/float(n-1);\n\t\t\tyfe=ye+sa;\n\t\t\tif (uv.y<=ye) MEM1\n\t\t\telse if (uv.y>yfe) MEM2\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tv2=float(uv.y-ye)/sa; if (v2>1.0) { v2=1.0; } v1=1.0-v2;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type==2) // increasing box\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tdx=cx*float(i+rn)/float(n+rd);\n\t\t\tdy=cy*float(i+rn)/float(n+rd);\n\t\t\tif ((uv.x>=cx-dx)&&(uv.x<=cx+dx)&&(uv.y>=cy-dy)&&(uv.y<=cy+dy)) MEM2\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==3) // increasing diamond\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx*cx+cy*cy)*(float(i+rn)/float(n+rd));\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tdy=abs(.5-uv.y);\n\t\t\tdx=abs(.5-uv.x);\n\t\t\tif (dx>cx) MEM1\n\t\t\telse if (dy>slope*dx+cy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==4) // increasing circle\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx/aspect*cx/aspect+cy*cy)*(float(i+rn)/float(n+rd));\n\t\t\tif (sqrt((uv.x-cx)/aspect*(uv.x-cx)/aspect+(uv.y-cy)*(uv.y-cy))>rad) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==5) // increasing and decreasing diamonds\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad0=sqrt(cx*cx+cy*cy)/2.0;\n\t\t\trad=sqrt(cx*cx+cy*cy)*(float(n-(i+1))/float(n+rd))/2.0;\n\t\t\trad2=rad0+(rad0-rad);\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\txc2=rad2*cos(theta); yc2=rad2*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tb2=yc2-slope*xc2;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tcy2=b2; cx2=(-b2/slope);\n\t\t\tdy=abs(.5-uv.y);\n\t\t\tdx=abs(.5-uv.x);\n\t\t\tif (dx>cx) MEM2\n\t\t\telse if (dy>slope*dx+cy) MEM2\n\t\t\telse MEM1\n\t\t\tif (dy>slope*dx+cy2) MEM1\n\t\t\t}\n\t\telse if (type==6) // four corner vanish\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tdx=cx*float(i+rn)/float(n+rd);\n\t\t\tdy=cy*float(i+rn)/float(n+rd);\n\t\t\tif ((uv.x>cx-dx)&&(uv.x<cx+dx)&&(uv.y>cy-dy)&&(uv.y<cy+dy)) MEM2\n\t\t\telse if ((uv.y<cy)&&(uv.x>cx-dx)&&(uv.x<cx+dx)) MEM2\n\t\t\telse if ((uv.y>cy)&&(uv.x>cx-dx)&&(uv.x<cx+dx)) MEM2\n\t\t\telse if ((uv.x<cx)&&(uv.y>cy-dy)&&(uv.y<cy+dy)) MEM2\n\t\t\telse if ((uv.x>cx)&&(uv.y>cy-dy)&&(uv.y<cy+dy)) MEM2\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==7) // increasing circle with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx/aspect*cx/aspect+cy*cy)*(float(i+rn)/float(n+rd));\n\t\t\t//rad2=rad+10.0*sa;\n\t\t\trad2=rad+sa;\n\t\t\tr1=sqrt((uv.x-cx)/aspect*(uv.x-cx)/aspect+(uv.y-cy)*(uv.y-cy));\n\t\t\tif (r1>rad2) MEM1\n\t\t\telse if (r1>rad) { v1=(r1-rad)/(rad2-rad); v2=1.0-v1; MEM12 }\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==8) // increasing diamond with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx*cx+cy*cy)*(float(i+rn)/float(n+rd));\n\t\t\t//rad2=rad+7.0*sa;\n\t\t\trad2=rad+.7*sa;\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\txc2=rad2*cos(theta); yc2=rad2*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tb2=yc2-slope*xc2;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tcy2=b2; cx2=(-b2/slope);\n\t\t\tdy=abs(.5-uv.y);\n\t\t\tdx=abs(.5-uv.x);\n\t\t\tif (dx>cx2) MEM1\n\t\t\telse if (dy>slope*dx+cy2) MEM1\n\t\t\telse if (dy>slope*dx+cy)\n\t\t\t\t{\n\t\t\t\tvy1=slope*dx+b;\n\t\t\t\tvy2=slope*dx+b2;\n\t\t\t\tv1=(dy-vy1)/(vy2-vy1); v2=1.0-v1;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==9) // increasing & decreasing diamonds w/ soft edge\n\t\t\t{\n\t\t\tfloat xc1s,yc1s,xc2s,yc2s,rads,rad2s,bs,b2s,cxs,cys,cx2s,cy2s;\n\n\t\t\tcx=.5; cy=.5;\n\t\t\trad0=sqrt(cx*cx+cy*cy)/2.0;\n\t\t\trad=sqrt(cx*cx+cy*cy)*(float(n-(i+1))/float(n+rd))/2.0;\n\t\t\t//rads=rad+7.0*sa;\n\t\t\trads=rad+.7*sa;\n\t\t\trad2=rad0+(rad0-rad);\n\t\t\t//rad2s=rad2-7.0*sa;\n\t\t\trad2s=rad2-.7*sa;\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\txc2=rad2*cos(theta); yc2=rad2*sin(theta);\n\t\t\txc1s=rads*cos(theta); yc1s=rads*sin(theta);\n\t\t\txc2s=rad2s*cos(theta); yc2s=rad2s*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tb2=yc2-slope*xc2;\n\t\t\tbs=yc1s-slope*xc1s;\n\t\t\tb2s=yc2s-slope*xc2s;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tcy2=b2; cx2=(-b2/slope);\n\t\t\tcys=bs; cxs=(-bs/slope);\n\t\t\tcy2s=b2s; cx2s=(-b2s/slope);\n\t\t\tdy=abs(.5-uv.y);\n\t\t\tdx=abs(.5-uv.x);\n\t\t\tif (dx>cxs) MEM2\n\t\t\telse if (dy>slope*dx+cys) MEM2\n\t\t\telse if (dy>slope*dx+cy)\n\t\t\t\t{\n\t\t\t\tvy1=slope*dx+b;\n\t\t\t\tvy2=slope*dx+bs;\n\t\t\t\tv2=(dy-vy1)/(vy2-vy1); v1=1.0-v2;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\telse MEM1\n\t\t\tif (dy>slope*dx+cy2) MEM1\n\t\t\telse if (dy>slope*dx+cy2s)\n\t\t\t\t{\n\t\t\t\tvy1=slope*dx+b2;\n\t\t\t\tvy2=slope*dx+b2s;\n\t\t\t\tv2=(dy-vy1)/(vy2-vy1); v1=1.0-v2;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type==10) // increasing box with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tdx=(cx*float(i+rn)/float(n+rd));\n\t\t\tdy=(cy*float(i+rn)/float(n+rd));\n\t\t\tdx2=(cx*float(i+rn)/float(n+rd)+sa);\n\t\t\tdy2=(cy*float(i+rn)/float(n+rd)+sa);\n\t\t\tif ((uv.x>=cx-dx)&&(uv.x<=cx+dx)&&(uv.y>=cy-dy)&&(uv.y<=cy+dy)) MEM2\n\t\t\telse if ((uv.x>=cx-dx2)&&(uv.x<=cx+dx2)&&(uv.y>=cy-dy2)&&(uv.y<=cy+dy2))\n\t\t\t\t{\n\t\t\t\tif ((abs(uv.x-cx)>dx)&&(abs(uv.y-cy)>dy))\n\t\t\t\t\t{\n\t\t\t\t\tif (abs(uv.y-cy)-dy>abs(uv.x-cx)-dx) v1=float(abs(uv.y-cy)-dy)/(sa);\n\t\t\t\t\telse v1=float(abs(uv.x-cx)-dx)/(sa);\n\t\t\t\t\t}\n\t\t\t\telse if (abs(uv.x-cx)>dx) { v1=float(abs(uv.x-cx)-dx)/(sa); }\n\t\t\t\telse if (abs(uv.y-cy)>dy) { v1=float(abs(uv.y-cy)-dy)/(sa); }\n\t\t\t\tv2=1.0-v1; MEM12\n\t\t\t\t}\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==11) // rotating vanishing (gets smaller) square with fade in new/fade out old\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\ttheta=-_TWOPI*(float(i+rn)/float(n+rd));\n\t\t\tc1=cos(theta); s1=sin(theta);\n\t\t\trad=(float(n-(i+1))/float(n+rd));\n\t\t\tif (rad<=0.0) { rad=0.00001; }\n\t\t\txc0=uv.x; yc0=uv.y;\n\t\t\txc1=xc0-cx; yc1=yc0-cy;\n\t\t\txc2=(xc1*c1-yc1*s1)/rad;\n\t\t\tyc2=(xc1*s1+yc1*c1)/rad;\n\t\t\tuv2.x=xc2*aspect+cx; uv2.y=yc2+cy;\n\t\t\tif ((uv2.x>=0.0)&&(uv2.x<=1.0)&&(uv2.y>=0.0)&&(uv2.y<=1.0)) { col3 = alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz; }\n\t\t\telse { col3 = vec3(0,0,0); }\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\tcol = alt ? v1*col3+v2*col1 : v1*col3+v2*col2;\n\t\t\t}\n\t\telse if (type==12) // rotating vanishing (gets smaller) square with fade out old\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\ttheta=-_TWOPI*(float(i+rn)/float(n+rd));\n\t\t\tc1=cos(theta); s1=sin(theta);\n\t\t\trad=(float(n-(i+1))/float(n+rd));\n\t\t\tif (rad<=0.0) { rad=0.00001; }\n\t\t\txc0=uv.x; yc0=uv.y;\n\t\t\txc1=xc0-cx; yc1=yc0-cy;\n\t\t\txc2=(xc1*c1-yc1*s1)/rad;\n\t\t\tyc2=(xc1*s1+yc1*c1)/rad;\n\t\t\tuv2.x=xc2*aspect+cx; uv2.y=yc2+cy;\n\t\t\tif ((uv2.x>=0.0)&&(uv2.x<=1.0)&&(uv2.y>=0.0)&&(uv2.y<=1.0)) { col3 = alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz; }\n\t\t\telse { col3 = alt ? col1 : col2; }\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\tcol = alt ? v1*col3+v2*col1 : v1*col3+v2*col2;\n\t\t\t}\n\t\telse if (type==13) // increasing flower with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tang=36.0*M_PI/180.0;\n\t\t\tro=(1.0/aspect)/.731*(float(i+rn)/float(n+rd));\n\t\t\ta1=234.0*M_PI/180.0;\n\t\t\tl=(sqrt((ro*cos(a1)*ro*cos(a1))+((ro*sin(a1)-ro)*(ro*sin(a1)-ro))))/2.0;\n\t\t\ta1=162.0*M_PI/180.0;\n\t\t\tl2=((ro*cos(a1)*ro*cos(a1))+((ro*sin(a1)-ro)*(ro*sin(a1)-ro)));\n\t\t\tri=(ro-sqrt(l2-l*l))/cos(36.0*M_PI/180.0);\n\t\t\tif (roto) { vy1=float(i+rn-1)/float(n+rd)*rota*M_PI/180.0; }\n\t\t\telse { vy1=0.0; }\n\t\t\tyc1=1.0-uv.y-cy;\n\t\t\txc1=(uv.x-cx)/aspect;\n\t\t\ttheta=atan2(xc1,yc1)+vy1;\n\t\t\ttheta2=fmod(abs(theta),ang);\n\t\t\ti2=int((180.0*theta/M_PI)/36.0);\n#ifdef NEEDMOD\n\t\t\tif (imod(i2,2)==0) { r=theta2/ang*(ro-ri)+ri; }\n#else\n\t\t\tif (i2%2==0) { r=theta2/ang*(ro-ri)+ri; }\n#endif\n\t\t\telse { r=(1.0-theta2/ang)*(ro-ri)+ri; }\n\t\t\tr2=sqrt(xc1*xc1+yc1*yc1);\n\t\t\tif (r2>r+sa) { MEM1 } else if (r2>r) { v1=(r2-r)/(sa); v2=1.0-v1; MEM12 } else { MEM2 }\n\t\t\t}\n\t\telse if (type==14) // increasing star with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tang=36.0*M_PI/180.0;\n\t\t\tro=(1.0/aspect)/.731*(float(i+rn)/float(n+rd));\n\t\t\ta1=234.0*M_PI/180.0;\n\t\t\tl=(sqrt((ro*cos(a1)*ro*cos(a1))+((ro*sin(a1)-ro)*(ro*sin(a1)-ro))))/2.0;\n\t\t\ta1=162.0*M_PI/180.0;\n\t\t\tl2=((ro*cos(a1)*ro*cos(a1))+((ro*sin(a1)-ro)*(ro*sin(a1)-ro)));\n\t\t\tri=(ro-sqrt(l2-l*l))/cos(36.0*M_PI/180.0);\n\t\t\tif (roto) { vy1=float(i+rn-1)/float(n+rd)*rota*M_PI/180.0; }\n\t\t\telse { vy1=0.0; }\n\t\t\tpo.x=po.y=0.0;\n\t\t\tyc1=1.0-uv.y-cy;\n\t\t\txc1=(uv.x-cx)/aspect;\n\t\t\ttheta=atan2(xc1,yc1)+vy1;\n\t\t\ttheta2=fmod(abs(theta),ang);\n\t\t\ti2=int((180.0*theta/M_PI)/36.0);\n#ifdef NEEDMOD\n\t\t\tif (imod(i2,2)==0) { p1.x=ri; p1.y=0.0; p2.x=ro*cos(ang); p2.y=ro*sin(ang); }\n#else\n\t\t\tif (i2%2==0) { p1.x=ri; p1.y=0.0; p2.x=ro*cos(ang); p2.y=ro*sin(ang); }\n#endif\n\t\t\telse { p1.x=ro; p1.y=0.0; p2.x=ri*cos(ang); p2.y=ri*sin(ang); }\n\t\t\tpd.x=cos(theta2); pd.y=sin(theta2);\n\t\t\tr=intersect(po,pd,p1,p2);\n\t\t\tr2=sqrt(xc1*xc1+yc1*yc1);\n\t\t\tif (r2>r+sa) { MEM1 } else if (r2>r) { v1=(r2-r)/(sa); v2=1.0-v1; MEM12 } else { MEM2 }\n\t\t\t}\n\t\telse if (type==15) // dissolve\n\t\t\t{\n\t\t\t// easier to use this common shadertoy random number gen rather than the one I used in original\n\t\t\tint v=int(fract(sin(dot(uv, vec2(12.9898, 78.233)))* 43758.5453)*float(n-1));\n\t\t\tif (i>v) MEM2 else MEM1\n\t\t\t}\n\t\telse if (type==16) // split horizontal\n\t\t\t{\n\t\t\tcy=.5;\n\t\t\tye=1.0/2.0*float(i+rn)/float(n+rd);\n\t\t\tif (uv.y<cy-ye) MEM1\n\t\t\telse if (uv.y>=cy+ye) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==17) // split vertical\n\t\t\t{\n\t\t\tcx=.5;\n\t\t\tye=1.0/2.0*float(i+rn)/float(n+rd);\n\t\t\tif (uv.x<cx-ye) MEM1\n\t\t\telse if (uv.x>=cx+ye) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==18) // slide\n\t\t\t{\n\t\t\tye=float(i+rn)/float(n+rd);\n\t\t\tuv2.x=uv.x;\n\t\t\tuv2.y=uv.y+ye;\n\t\t\tif (uv.y>=1.0-ye) MEM2\n\t\t\telse MEM1S\n\t\t\t}\n\t\telse if (type==19) // window right with soft edge\n\t\t\t{\n\t\t\tye=float(i)/float(n-1);\n\t\t\tyfe=ye+(10.0*sa);\n\t\t\tif (uv.x<=ye) MEM2\n\t\t\telse if (uv.x>yfe) MEM1\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tv1=(uv.x-ye)/(10.0*sa); if (v1>1.0) { v1=1.0; } v2=1.0-v1;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type==20) // inset down right\n\t\t\t{\n\t\t\tdx=float(i+rn)/float(n+rd);\n\t\t\tdy=float(i+rn)/float(n+rd);\n\t\t\tif (uv.x>=dx) MEM1\n\t\t\telse if (1.0-uv.y>=dy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==21) // inset down left\n\t\t\t{\n\t\t\tdx=float(i+rn)/float(n+rd);\n\t\t\tdy=float(i+rn)/float(n+rd);\n\t\t\tif ((1.0-uv.x)>dx) MEM1\n\t\t\telse if (1.0-uv.y>=dy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==22) // inset up right\n\t\t\t{\n\t\t\tdx=float(i+rn)/float(n+rd);\n\t\t\tdy=float(i+rn)/float(n+rd);\n\t\t\tif (uv.x>=dx) MEM1\n\t\t\telse if (uv.y>dy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==23) // inset up left\n\t\t\t{\n\t\t\tdx=float(i+rn)/float(n+rd);\n\t\t\tdy=float(i+rn)/float(n+rd);\n\t\t\tif ((1.0-uv.x)>dx) MEM1\n\t\t\telse if ((uv.y)>dy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==24) // pixelate\n\t\t\t{\n\t\t\t// this is simpler (not as good) as my original non-glsl code\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\tif (i<n/2) { j=int(float(i)/(float(n)/2.0)*50.0); }\n\t\t\telse { j=int(float(n-i-1)/(float(n)/2.0)*50.0); }\n\t\t\tif (j<1) { j=1; }\n\t\t\tuv2.x=float(int(uv.x*iResolution.x/float(j))*j)/iResolution.x;\n\t\t\tuv2.y=float(int(uv.y*iResolution.y/float(j))*j)/iResolution.y;\n\t\t\tcol = v1 * (alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz) + v2 * (alt ? texture2D(iChannel0, uv2).xyz : texture2D(iChannel1, uv2).xyz);\n\t\t\t}\n\t\telse if (type==25) // fan in\n\t\t\t{\n\t\t\ttheta2=M_PI*float(i+rn)/float(n+rd);\n\t\t\tdy=1.0/4.0; dx=1.0/2.0; dy2=1.0*3.0/4.0;\n\t\t\txc1=M_PI/180.0*sa; cy=.5;\n\t\t\ttheta=atan2(abs(dx-uv.x),dy-uv.y);\n\t\t\ttheta3=atan2(abs(dx-uv.x),uv.y-dy2);\n\t\t\tif ((theta<theta2)||(theta3<theta2)) MEM2\n\t\t\telse if (abs(theta2-M_PI)<=.00001) MEM2\n\t\t\telse if ((theta<theta2+xc1)&&(uv.y<=cy)) { v1=(theta-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\telse if (theta3<theta2+xc1) { v1=(theta3-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==26) // fan out\n\t\t\t{\n\t\t\ttheta2=_TWOPI*float(i+rn)/float(n+rd);\n\t\t\tdx=1.0/4.0; dy=.5; dx2=1.0*3.0/4.0; cx=.5;\n\t\t\txc1=M_PI/180.0*sa;\n\t\t\ttheta=M_PI+atan2(1.0-uv.y-dy,dx-uv.x);\n\t\t\ttheta3=M_PI+atan2(1.0-uv.y-dy,uv.x-dx2);\n\t\t\tif (theta2<=M_PI)\n\t\t\t\t{\n\t\t\t\tif ((theta<theta2)&&(theta3<theta2)) MEM2\n\t\t\t\telse if ((theta<theta2+xc1)&&(uv.x<=cx)) { v1=(theta-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\t\telse if ((theta3<theta2+xc1)&&(uv.x>=cx)) { v1=(theta3-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\t\telse MEM1\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tif ((theta>theta2+xc1)&&(uv.x<=cx)) MEM1\n\t\t\t\telse if ((theta3>theta2+xc1)&&(uv.x>=cx)) MEM1\n\t\t\t\telse if (!((theta>theta2)&&(theta3>theta2))) MEM2\n\t\t\t\telse if (uv.x<=cx) { v1=(theta-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\t\telse { v1=(theta3-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type==27) // fan up\n\t\t\t{\n\t\t\ttheta2=M_PI/2.0*float(i+rn)/float(n+rd);\n\t\t\tdy=0.0; dx=1.0/2.0; xc1=M_PI/180.0*sa;\n\t\t\ttheta=atan2(abs(dx-uv.x),1.0-uv.y);\n\t\t\tif (theta<theta2) MEM2\n\t\t\telse if (theta<theta2+xc1) { v1=(theta-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\telse MEM1\n\t\t\t}\n/*\n\t\t// I'm not even gonna try to convert this one\n\t\tcase 33: // roll\n\t\t\tmem1ts=(short *)calloc(sizeof(short),size);\n\t\t\tcx=w; cy=h;\n\t\t\ttheta=M_PI/2.0*((float)(i+rn)/(float)(n+rd));\n\t\t\tc1=cos(theta); s1=sin(theta);\n\t\t\tfor (y=0;y<h;y++)\n\t\t\t\t{\n\t\t\t\tfor (x=0;x<w;x++)\n\t\t\t\t\t{\n\t\t\t\t\ta=(y*w+x)*3;\n\t\t\t\t\tmem1ts[a]=mem1ts[a+1]=mem1ts[a+2]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfor (yc0=0;yc0<h;yc0+=.5)\n\t\t\t\t{\n\t\t\t\tfor (xc0=0;xc0<w;xc0+=.5)\n\t\t\t\t\t{\n\t\t\t\t\txc1=xc0-(float)(cx); yc1=yc0-(float)(cy);\n\t\t\t\t\txc2=(xc1*c1-yc1*s1);\n\t\t\t\t\tyc2=(xc1*s1+yc1*c1);\n\t\t\t\t\tdx=(int)(xc2)+cx; dy=(int)(yc2)+cy;\n\t\t\t\t\ta2=(dy*w+dx)*3;\n\t\t\t\t\ta=((int)(yc0)*w+(int)(xc0))*3;\n\t\t\t\t\tif ((dx>=0)&&(dx<w)&&(dy>=0)&&(dy<h)) MEM1TS\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfor (y=0;y<h;y++)\n\t\t\t\t{\n\t\t\t\tfor (x=0;x<w;x++)\n\t\t\t\t\t{\n\t\t\t\t\ta=(y*w+x)*3;\n\t\t\t\t\tif (mem1ts[a]>=0) MEM1TS1\n\t\t\t\t\telse MEM2\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfree(mem1ts);\n\t\t\tbreak;\n*/\n\t\telse if (type==28) // bars\n\t\t\t{\n\t\t\tint v=int(fract(sin(dot(vec2(uv.y,0), vec2(12.9898, 78.233)))* 43758.5453)*float(n-1));\n\t\t\tif (i>v) MEM2 else MEM1\n\t\t\t}\n/*\n\t\t// I'm not even gonna try to convert this one\n\t\tcase 34: // slide up center\n\t\t\tmem1ts=(short *)calloc(sizeof(short),size);\n\t\t\tcx=w/2; cy=0;\n\t\t\trad=((float)(n-(i+1))/(float)(n+rd));\n\t\t\tfor (y=0;y<h;y++)\n\t\t\t\t{\n\t\t\t\tfor (x=0;x<w;x++)\n\t\t\t\t\t{\n\t\t\t\t\ta=(y*w+x)*3;\n\t\t\t\t\tmem1ts[a]=mem1ts[a+1]=mem1ts[a+2]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfor (yc0=0;yc0<h;yc0+=1.0)\n\t\t\t\t{\n\t\t\t\tfor (xc0=0;xc0<w;xc0+=1.0)\n\t\t\t\t\t{\n\t\t\t\t\txc1=xc0-(float)(cx); yc1=yc0-(float)(cy);\n\t\t\t\t\txc2=rad*xc1;\n\t\t\t\t\tyc2=rad*yc1;\n\t\t\t\t\tdx=(int)(xc2)+cx; dy=(int)(yc2)+cy;\n\t\t\t\t\ta2=(dy*w+dx)*3;\n\t\t\t\t\ta=((int)(yc0)*w+(int)(xc0))*3;\n\t\t\t\t\tif ((dx>=0)&&(dx<w)&&(dy>=0)&&(dy<h)) MEM1TS\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfor (y=0;y<h;y++)\n\t\t\t\t{\n\t\t\t\tfor (x=0;x<w;x++)\n\t\t\t\t\t{\n\t\t\t\t\ta=(y*w+x)*3;\n\t\t\t\t\tif (mem1ts[a]>=0) MEM1TS1\n\t\t\t\t\telse MEM2\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfree(mem1ts);\n\t\t\tbreak;\n*/\n\t\telse if (type==29) // diagonal down right\n\t\t\t{\n\t\t\trad=sqrt(2.0+2.0)*(1.0-(float(i+rn)/float(n+rd)));\n\t\t\tslope=-1.0/1.0;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\tb=yc1-slope*xc1-sa;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tdy=abs(uv.y);\n\t\t\tdx=abs(1.0-uv.x);\n\t\t\t//if (dx>cx-sa) MEM2\n\t\t\tif (dy>slope*dx+cy+sa) MEM2\n\t\t\telse if (dy>slope*dx+cy) { v2=(dy-(slope*dx+cy))/(sa); v1=1.0-v2; MEM12 }\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==30) // diagonal cross out\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx*cx+cy*cy)/2.0*(float(i+rn)/float(n+rd));\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tcy=b; cx=(-b/slope); vy1=sa;\n\t\t\tdy=(uv.y-.5);\n\t\t\tdx=(uv.x-.5);\n\t\t\tif (!(((dy>slope*dx+cy)||(dy<slope*dx-cy))&&((dy>(-slope)*dx+cy)||(dy<(-slope)*dx-cy)))) MEM2\n\t\t\telse if ((sa!=0.0)&&(!(((dy>slope*dx+cy+vy1)||(dy<slope*dx-cy-vy1))&&\n\t\t\t\t((dy>(-slope)*dx+cy+vy1)||(dy<(-slope)*dx-cy-vy1)))))\n\t\t\t\t{\n\t\t\t\tif ((dx>=0.0)&&(dy>=0.0))\n\t\t\t\t\t{\n\t\t\t\t\tv1=v2=0.0;\n\t\t\t\t\tif (dy>-slope*dx) { v1=(dy-(-slope*dx+cy))/vy1; v2=1.0-v1; }\n\t\t\t\t\telse { v1=((-slope*dx-cy)-dy)/vy1; v2=1.0-v1; }\n\t\t\t\t\tMEM12\n\t\t\t\t\t}\n\t\t\t\telse if ((dx<0.0)&&(dy<0.0))\n\t\t\t\t\t{\n\t\t\t\t\tv1=v2=0.0;\n\t\t\t\t\tif (dy>-slope*dx) { v1=(dy-(-slope*dx+cy))/vy1; v2=1.0-v1; }\n\t\t\t\t\telse { v1=((-slope*dx-cy)-dy)/vy1; v2=1.0-v1; }\n\t\t\t\t\tMEM12\n\t\t\t\t\t}\n\t\t\t\telse if ((dx>=0.0)&&(dy<0.0))\n\t\t\t\t\t{\n\t\t\t\t\tv1=v2=0.0;\n\t\t\t\t\tif (dy>slope*dx) { v1=(dy-(slope*dx+cy))/vy1; v2=1.0-v1; }\n\t\t\t\t\telse { v1=((slope*dx-cy)-dy)/vy1; v2=1.0-v1; }\n\t\t\t\t\tMEM12\n\t\t\t\t\t}\n\t\t\t\telse if ((dx<0.0)&&(dy>=0.0))\n\t\t\t\t\t{\n\t\t\t\t\tv1=v2=0.0;\n\t\t\t\t\tif (dy>slope*dx) { v1=(dy-(slope*dx+cy))/vy1; v2=1.0-v1; }\n\t\t\t\t\telse { v1=((slope*dx-cy)-dy)/vy1; v2=1.0-v1; }\n\t\t\t\t\tMEM12\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==31) // increasing gear with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tro=sqrt(cx*cx+cy*cy)/.9*float(i+rn)/float(n+rd);\n\t\t\tif (roto) { vy1=float(i+rn-1)/float(n+rd)*rota*M_PI/180.0; }\n\t\t\telse { vy1=0.0; }\n\t\t\tri=ro*.9;\n\t\t\tpo.x=po.y=0.0;\n\t\t\tangt=5.0;\n\t\t\tangs=2.5;\n\t\t\ttang=(angt+angs)*2.0;\n\t\t\tang=tang*M_PI/180.0;\n\t\t\tyc1=uv.y-cy;\n\t\t\txc1=(uv.x-cx)/aspect;\n\t\t\ttheta=atan2(xc1,yc1);\n\t\t\ttheta2=fmod(theta+M_PI+vy1,ang);\n\t\t\tif (theta2<=angt*M_PI/180.0) { r1=r2=ri; ang2=angt; ang1=theta2; }\n\t\t\telse if (theta2<=(angt+angs)*M_PI/180.0) { r1=ri; r2=ro; ang2=angs; ang1=theta2-angt*M_PI/180.0; }\n\t\t\telse if (theta2<=(angt+angs+angt)*M_PI/180.0) { r1=r2=ro; ang2=angt; ang1=theta2-(angt+angs)*M_PI/180.0; }\n\t\t\telse { r1=ro; r2=ri; ang2=angs; ang1=theta2-(angt+angs+angt)*M_PI/180.0; }\n\t\t\tang2*=(M_PI/180.0);\n\t\t\tp1.x=r1; p1.y=0.0; p2.x=r2*cos(ang2); p2.y=r2*sin(ang2);\n\t\t\tpd.x=cos(ang1); pd.y=sin(ang1);\n\t\t\tr=intersect(po,pd,p1,p2);\n\t\t\tr2=sqrt(xc1*xc1+yc1*yc1);\n\t\t\tif (r2>r+sa) { MEM1 } else if (r2>r) { v1=(r2-r)/(sa); v2=1.0-v1; MEM12 } else { MEM2 }\n\t\t\t}\n        else if (type==32) // rotating expanding square with fade in new/fade out old\n\t\t\t{\n            float x = mod(iTime,1.); // change this to alter the speed\n   \n            x=smoothstep(.0,1.0,(x*2.0+uv.x-1.0));\n            col= mix(texture(iChannel0,(uv-.5)*(1.-x)+.5).rgb, texture(iChannel1,(uv-.5)*x+.5).rgb, x);  \n            }\n\t\telse if (type==33) // rotating expanding square with fade in new/fade out old\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\ttheta=-_TWOPI*(float(i+rn)/float(n+rd));\n\t\t\tc1=cos(theta); s1=sin(theta);\n\t\t\trad=(float(n-(i+1))/float(n+rd));\n\t\t\txc0=uv.x; yc0=uv.y;\n\t\t\txc1=xc0-cx; yc1=yc0-cy;\n\t\t\txc2=rad*(xc1*c1-yc1*s1);\n\t\t\tyc2=rad*(xc1*s1+yc1*c1);\n\t\t\tuv2.x=xc2*aspect+cx; uv2.y=yc2+cy;\n\t\t\tif ((uv2.x>=0.0)&&(uv2.x<=1.0)&&(uv2.y>=0.0)&&(uv2.y<=1.0)) { col3 = alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz; }\n\t\t\telse { col3 = alt ? col1 : col2; }\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\t//col=col3;\n\t\t\tcol = alt ? v1*col3+v2*col1 : v1*col3+v2*col2;\n\t\t\t}\n\nfragColor = vec4(col, 1.0);\n}\n\nfloat intersect(vec2 origin, vec2 direction, vec2 point1, vec2 point2)\n{\nvec2 v1, v2, v3;\nfloat dot, t1, t2;\n\nv1.x = origin.x - point1.x;\nv1.y = origin.y - point1.y;\nv2.x = point2.x - point1.x;\nv2.y = point2.y - point1.y;\nv3.x = -direction.y;\nv3.y = direction.x;\ndot = v2.x * v3.x + v2.y * v3.y;\nif (abs(dot) < 0.000001) return(-1000.0);\nt1 = (v2.x * v1.y - v2.y * v1.x) / dot;\nt2 = (v1.x * v3.x + v1.y * v3.y) / dot;\nif ((t1 >= 0.0) && (t2 >= 0.0) && (t2 <= 1.0)) return(t1);\nreturn(-1000.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define DO_SHADOW\n#define CAMERA_ZOOM 1.5\n#define ITER 150\n#define NEAR 0.005\n#define CHEAPER_NORMAL\n#define FAKE_AMBIENT // fake ambient occlusion/shadows\n\nconst float PI = 3.141592;\n\nmat2 rot(float a) {\n  float s = sin(a), c = cos(a);\n  return mat2(c, -s, s, c);\n}\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\nfloat noise(vec2 n) {\n  return fract(sin(dot(n, vec2(12.2437, 4.5671))) * 43758.1345);\n}\n\n//Functions from http://mercury.sexy/hg_sdf/ :\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\n\n#define TUBE_LIGHTS_COUNT 4\n\nfloat TubeLightsLuminosity[TUBE_LIGHTS_COUNT] = float[TUBE_LIGHTS_COUNT](1.5,1.5,1.5,1.5);\n\nconst vec3 Colors[3] = vec3[3](vec3(1, 1, .6), vec3(1, 0, 0), vec3(.3, 1, .3));\n\nconst int LightColors[TUBE_LIGHTS_COUNT] = int[4](0, 0, 2, 1);\n\nconst vec3 TubeLightPositions[TUBE_LIGHTS_COUNT] =\n    vec3[TUBE_LIGHTS_COUNT](\n        vec3(3.5, 3, 5), \n        vec3(-3.5, 3, 5), \n        vec3(-3.5, 3, 35),\n        vec3(3.5, 3, 35) // last light is the flickering one\n    );\n\n\n// Instead of returning the distance to the capsule,\n// return the nearest position on the surface of capsule, from p\n// Used for lighting calculations as we can calculate the light\n// assuming it all comes from the nearest position on the light\n\n// Also now returns the signed distance in the w channel of the vec4,\n// because the distance to the position is unsigned which means backtracking breaks\nvec4 capsulePos(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  vec3 np = a + ba * h;\n  return vec4(\n    np + r * normalize(p - np), //the position\n    length( pa - ba*h ) - r     //the signed distance\n  );\n}\n\nvec4 getLightPos(vec3 p, int i) {\n  vec3 lp = TubeLightPositions[i];\n  return capsulePos(p, lp + vec3(0, 0, -5), lp + vec3(0, 0, 5), .2);\n}\n\nfloat corridorPrism(vec3 p, float l) {\n  vec3 pp = p;\n  pp.xy *= rot(PI / 4.);\n  p.y += .375;\n  return min(-box(p, vec3(5, 4.125, l)), -box(pp, vec3(5., 5., l)));\n}\n\nfloat dividers(vec3 p) {\n  p.z -= 5.;\n  p.z = mod(p.z, 30.) - 15.; // repeat them every 30 units\n  return fOpPipe(corridorPrism(p, 0.), corridorPrism(p, 2.), .8);\n}\n\nfloat floorHole(vec3 p) {\n  p.y+=4.;\n  float b = box(p, vec3(1.9, 1, 50));\n  p.xz = mod(p.xz,vec2(.4,2))-vec2(.2,1);\n  p.y+=1.;\n  return min(b, box(p,vec3(.1,.4,.8)));\n}\n\nfloat octoRoom(vec3 p) {\n  const float radius = 5.;\n  const float edgeSize = radius * 2. * sin(PI / 8.);\n  float div = dividers(p);\n  float fh = floorHole(p);\n  // Add the wall bumps:\n  p.x += sign(p.x) * pow(abs(cos((p.y / edgeSize) * PI * 4.6 - 0.1)), .6) * .2;\n  return fOpDifferenceRound(min(div, corridorPrism(p, 50.)), fh,.1);\n}\n\nfloat nearestLight(vec3 p) {\n  float d = 999.;\n  float lum = 0.;\n  for (int i = 0; i < TUBE_LIGHTS_COUNT; i++) {\n    d = min(d, getLightPos(p, i).w);\n  }\n  return d;\n}\n\nfloat glowDist = 999.;\nint glowColor = 0;\nfloat computeLight(vec3 p) {\n  float d = 999.;\n  float lum = 1.;\n  for (int i = 0; i < TUBE_LIGHTS_COUNT; i++) {\n    float diff = getLightPos(p, i).w;\n    if (diff < d) {\n      lum = sqrt(TubeLightsLuminosity[i]);\n      glowColor = LightColors[i];\n    }\n    d = min(d, diff);\n  }\n  glowDist = min(glowDist, d / lum);\n  return d;\n}\n\nfloat sdfForNormals(vec3 p) { return min(octoRoom(p), nearestLight(p)); }\n\nfloat sdfWithLighting(vec3 p) { return min(octoRoom(p), computeLight(p)); }\n\nvec3 norm(vec3 p) {\n  vec2 ss = vec2(0.001, 0.);\n#ifdef CHEAPER_NORMAL\n  return normalize(sdfForNormals(p) - vec3(sdfForNormals(p - ss.xyy),\n                                           sdfForNormals(p - ss.yxy),\n                                           sdfForNormals(p - ss.yyx)));\n#else\n  float gx = sdfForNormals(p + ss.xyy) - sdfForNormals(p - ss.xyy);\n  float gy = sdfForNormals(p + ss.yxy) - sdfForNormals(p - ss.yxy);\n  float gz = sdfForNormals(p + ss.yyx) - sdfForNormals(p - ss.yyx);\n  return normalize(vec3(gx, gy, gz));\n#endif\n}\n\nfloat rm(vec3 ro, vec3 rd) {\n  float td = 0.;\n  for (int i = 0; i < ITER; i++) {\n    float d = sdfWithLighting(ro + rd * td);\n    td += d;\n    if (abs(d) < NEAR || td > 999.)\n      break;\n  }\n  return td;\n}\n\nvec3 singleLight(vec3 p, vec3 n, vec3 rd, int i) {\n  vec3 lp = getLightPos(p, i).xyz;\n  vec3 d = normalize(lp - p);\n  float diffuse = clamp(dot(n, d), 0.1, 1.);\n  float sh = 1.;\n#ifdef DO_SHADOW\n  p += n * .01;\n  if (rm(p, d) < length(lp - p) - .5) {\n    sh = .5;\n  }\n#endif\n  float specular = dot(d, reflect(rd, n));\n  specular = pow(clamp(specular, 0.0, 1.0), 200.);\n  return ((specular + diffuse) * clamp(1. / length(lp - p), 0., 1.) * sh) *\n         TubeLightsLuminosity[i] * Colors[LightColors[i]];\n}\n\nvec3 light(vec3 p, vec3 rd) {\n  vec3 tl = vec3(0.);\n  vec3 n = norm(p);\n  for (int i = 0; i < TUBE_LIGHTS_COUNT; i++) {\n    tl += singleLight(p, n, rd, i);\n  }\n#ifdef FAKE_AMBIENT\n  tl *= clamp(sdfForNormals(p + n * .2) / .2, .5, 1.);\n#endif\n  return tl;\n}\n\nvec3 color(vec3 p) {\n  return vec3(1.); // white\n  // return vec3(\n  //    smoothstep(.2,.3,abs(sin(p.z * 5.)))\n  //);\n}\n\nvec3 lightGlow() {\n  return Colors[glowColor] * (1. - clamp(pow(glowDist, .4), 0., 1.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 fragUV = (fragCoord - iResolution.xy * .5) / iResolution.x;\n  vec3 ro = vec3(0,-1,-30);\n  ro.z += mod((iTime * 3.), 55.); // repeating forwards motion\n  ro.y += sin(iTime * 5.) * 0.1; // head-up-down\n  ro.x += sin(iTime * 2.5) * 0.1; // head left-right each \"step\"\n  \n\n  TubeLightsLuminosity[3] = clamp(\n      (sin(iTime * 2.234) + \n      sin(iTime * 4.324) + \n      sin(iTime * 60.) * 0.5) * 2., 0., 1.); //flicker > 0 ? 1 : 0\n  \n  vec3 rd = normalize(vec3(fragUV, CAMERA_ZOOM));\n  if (iMouse.z > 0.) {\n    rd.yz *= rot(-PI * (iMouse.y - iResolution.y * .5) / iResolution.y);\n    rd.xz *= rot(-2. * PI * (iMouse.x - iResolution.x * .5) / iResolution.x);\n  }\n\n  float dist = rm(ro, rd);\n  vec3 p = ro + rd * dist;\n\n  // Calculate the Lighting+Texture at point p:\n  vec3 c = lightGlow() + light(p, rd) * color(p);\n\n  // Add distance Fog:\n  vec3 fogColor = vec3(.1, 0, 0);\n  float fogDensity = .02;\n  c = mix(c, fogColor, 1. - exp(-dist * fogDensity));\n\n  // Add noise:\n  c += noise(fragCoord * iTime) * .03;\n\n  // Final result:\n  fragColor = vec4(c, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define pmod(p,m) (mod(p,m)-.5*(m))\n#define time (iTime*.6)\n#define NYQ (.5*iSampleRate)\n#define fft(oct) (texture(iChannel0, vec2(0.,1024./NYQ*pow(2., (oct)))).r)/FFTMAX\n#define BPM 120.\n// this was supposed to use texFFTIntegrated but uh idk how to do that\n// also it seems to want a vec2 which is silly... it's a 1d texture...\n#define fftint(oct) texture(iChannel0, vec2(0.,.5*1024./NYQ*pow(2., (oct)))).g/FFTMAX\n\n#define v2Resolution iResolution\n\nfloat FFTMAX = 1.;\n\nfloat ffta(float a, float b) {\n  float iter=10.;\n  float x=0.;\n  for (float i=0.;i<1.;i+=1./iter) x+=fft(mix(a,b,i));\n  return x/iter;\n}\nfloat fftinta(float a, float b) {\n  float iter=10.;\n  float x=0.;\n  for (float i=0.;i<1.;i+=1./iter) x+=fftint(mix(a,b,i));\n  return x/iter;\n}\n\nmat2 hexel = mat2(2., 0., -1., sqrt(3.))/3.;\nmat2 pixel = mat2(3.,0.,sqrt(3.),2.*sqrt(3.))/2.;\n\nvec3 to_cubic(vec2 p) { return vec3(p.x, -p.y-p.x, p.y); }\n\nvec3 round_cubic(vec3 p, float m) {\n  p *= m;\n  vec3 r = round(p);\n  \n  vec3 d = abs(p-r);\n  vec3 alt = -r.yzx-r.zxy;\n  float big = max(d.x,max(d.y,d.z));\n  \n  return mix(r, alt, step(big, d))/m;\n}\n\nfloat box(vec3 p, vec3 a) {\n  vec3 q = abs(p)-a;\n  return length(max(q,0.))+min(0., max(q.x, max(q.y,q.z)));\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nmat2 rot(float a) {float s=sin(a),c=cos(a); return mat2(c,s,-s,c); }\n\nfloat boxle(vec3 p, float r, float m) {\n  r*=.8;\n  float o = .1+.3*ffta(0.,2.);\n  float B = box(p, vec3(r))-1.2*o;\n  \n  float S = sphere(p+vec3(mix(-.8,1.,2.*o)), m*r)-o;\n  return max(B,-S);\n}\nfloat glow=0.;\nfloat MAT=-1.;\nfloat S(vec3 p) {\n  // i don't know how to get the equivalent of bonzo's texFFTIntegrated out of this texture\n  float tt=mix(time, fftinta(7.,9.), 0.);\n  float T=floor(tt);\n  float t=fract(tt);\n  \n\n  //t=mix(t, smoothstep(0.,1.,t),.5);\n  glow+=.01;\n  float O = 1001.;\n  \n  for (float i=0.; i<3.; i+=1.) {\n    float r=t+i;\n    //if (r < -.5) continue;\n    p.xz *= rot(.8*log(1.+r*r));\n    //p.xy *= rot(r*.8);\n    p.yz *= rot(r*.2);\n    float B = boxle(p, r, 1.+log(1.+.3*r));\n    \n    if (B<O) MAT=mod(T-i+9.,3.);\n\n    O = min(O, B);\n\n  }\n  return O;\n}\n\n#define MISS(d) (d > 1000.)\n\nfloat ray(vec3 p, vec3 dir) {\n  float d=0.;\n  for (int i=0;i<500;i++) {\n    float c = S(p+d*dir);\n    d+=c;\n    if (c<.00001) return d;\n    if (MISS(d)) return d;\n  }\n  return 1001.;\n}\n\nvec3 normal(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(1e-4);\n  return normalize(S(p) - vec3(S(k[0]), S(k[1]), S(k[2])));\n}\n#define desat(x, R) mix(x, vec3(x.r+x.g+x.b)/3., R)\n\n#define TAU (2*acos(-1))\n#define nsin(x) (.5+.5*sin(TAU*(x)))\n\n\nvec3 light(vec3 cam, vec3 dir, float dist, vec3 hex, float mat) {\n  vec3 hit = cam + dir*dist;\n  \n  vec3 n = normal(hit);\n  \n  float diff = dot(dir, -n);\n  vec3 rdir = reflect(dir,n);\n  \n  vec3 C = vec3(diff);\n  vec3 T;\n  if (mat<1.) { T= texture(iChannel1, rdir).xyz; }\n  else if (mat<2.) { T= texture(iChannel2, rdir).xyz; }\n  else { T= texture(iChannel3, rdir).xyz; }\n  \n  C = mix(C,T,.5);\n  \n  \n  return C;\n}\n\n\n#define gmix(a, b, q) ((a)*pow((b)/(a), (q))) \n\n#define tri(x) (abs(fract(x)-.5)*2.)\n#define bump(x) (sqrt(abs(sin(x))))\n\nfloat hex_dist = .5*sqrt(3.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = gl_FragCoord.xy / v2Resolution.xy - .5;\n  vec2 uu = gl_FragCoord.xy / v2Resolution.xy;\n  uv.x *= v2Resolution.x/v2Resolution.y;\n  \n  uv *= rot(time*.5);\n  \n  float res = gmix(20., 100., ffta(2., 6.));\n  \n  vec2 axial = uv * hexel;\n  vec3 cubic = to_cubic(axial);\n  \n  \n  \n  vec3 hex = round_cubic(cubic, res);\n  vec2 hex_center = hex.xz*pixel;\n  \n  float center_d = length(hex_center-uv);\n  \n  if (center_d > .9*hex_dist/res) {\n    fragColor = vec4(0.);\n    return;\n  }\n  \n  vec3 cam = vec3(0,0,-2);\n  cam -= vec3(0,0,.5);\n  vec3 dir = normalize(vec3(hex_center, 1));\n  vec3 real_dir = normalize(vec3(uv,1));\n  \n  float dist = ray(cam, dir);\n  \n    vec3 C;\n    \n  \n\n  \n  if (MISS(dist)) {\n    C = hex;\n  }\n  else {\n    C = light(cam,dir,dist,hex,MAT);\n  }\n    glow=0.;\n  float real_dist = ray(cam+vec3(0,0,.5), real_dir);\n  \n  //if (MISS(dist) || real_dist < dist) C-=(1.-desat(hex,.5))*glow;\n  \n  fragColor = vec4(sqrt(C), 0.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define time (iTime*.5)\n#define v2Resolution iResolution\n#define out_color fragColor\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax,p,cos(ro))+cross(ax,p)*sin(ro);\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p)-r;\n}\n\nfloat box(vec3 p, vec3 a) {\n  vec3 q = abs(p)-a;\n  return length(max(q,0.))+min(0., max(q.x,max(q.y,q.z)));\n}\n\nmat2 rot(float x) { float s=sin(x),c=cos(x); return mat2(c,s,-s,c); }\n\nfloat roundunion(float d1, float d2, float amt) {\n  float m = min(d1, d2);\n\n  vec2 d = clamp(vec2(d1, d2),-amt,amt);\n  \n  return min(m, amt-length(d-amt)); //max(m,length(vec2(d1,d2))-.5);\n}\n\nfloat roundint(float d1, float d2, float amt) {\n  float m = max(d1, d2);\n  vec2 d= clamp(vec2(d1,d2),-amt,amt);\n  return max(m, -(amt-length(d+amt)));\n}\n\n\nfloat chamfunion(float d1, float d2, float amt) {\n  float m = min(d1, d2);\n  vec2 d = max(vec2(d1,d2),0.);\n  \n  return min(m, (d.x+d.y-amt)/sqrt(2.)); //max(m,length(vec2(d1,d2))-.5);\n}\n\nfloat chamfint(float d1, float d2, float amt) {\n  float m = max(d1, d2);\n  \n  vec2 d = min(vec2(d1,d2),0.);\n  \n  //return m;\n  return max(m, (d.x+d.y+amt)/sqrt(2.));\n}\n\n\n\nfloat smoothsubtract(float d1, float d2, float k) {\n  float h = clamp(.5-.5*(d2+d1)/k, 0., 1.);\n  return mix(d2, -d1, h) + k*h*(1.-h);\n}\n\n#define gmix(A,B,Q) ((A)*pow((B)/(A), Q))\nfloat COL;\n#define tri(x) (abs(fract(x)-.5)*2.)\nfloat scene(vec3 p) {\n  float perz=3.;\n  p.xz *= rot(sin(time)*.4);\n  //p.z = mod(p.z, perz)-.5*perz;\n  //p.xy *= rot(time);\n  p.x -= .3;\n  p.y -=.2;\n  \n  float perxy = 2.8;\n  vec2 newxy = mod(p.xy, perxy)-.5*perxy;\n  vec2 cell = p.xy-newxy;\n  COL = cos(time)*cell.x+sin(time)*cell.y;\n  p.xy = newxy;\n  \n  //p.xz *= rot(3.14/3.);\n  //p.yz *= rot(1.);\n  p = erot(p, normalize(vec3(-1,.2,.8)), time*.5);\n  float cube = box(erot(p, normalize(vec3(.1,.1,0)), time*8.), vec3(1,1,1))-.2;\n  float amt = 2.*(.5+.5*tri(time));\n  \n  float per = .555;\n  vec3 sphc = mod(erot(p, vec3(0,0,1), time), per)-.5*per;\n  float sph = sphere(sphc, .4);\n  \n  float sph2 = sphere(p, 1.);\n  //return max(-sph,cube);\n  float sparkle = chamfint(-sph,cube, .01);\n  return sparkle;\n  \n  return gmix(sph2, sparkle, sin(time)*.5+.5);\n}\n\n#define MISS(x) ((x)>1000.)\n\nfloat ray(vec3 p, vec3 dir) {\n  float d=0.;\n  for (int i=0;i<300;i++) {\n    float c=scene(p+dir*d);\n    d+=c;\n    if (c < .00001) return d;\n    if (MISS(d)) return 1001.;\n  }\n  \n  return d;\n}\n\nvec3 grad(vec3 p) {\n  mat3 K = mat3(p,p,p)-mat3(.001);\n  return scene(p) - vec3(scene(K[0]), scene(K[1]), scene(K[2]));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / v2Resolution.xy - .5;\n  vec2 uu = fragCoord.xy / v2Resolution.xy;\n  uv.x *= v2Resolution.x/v2Resolution.y;\n  \n  vec3 cam = vec3(0,0,-20);\n  vec3 dir = normalize(vec3(uv, 1));\n  \n  float dist = ray(cam, dir);\n  \n  vec3 C;\n  if (MISS(dist)) {\n    C = vec3(0);\n  }\n  else {\n    vec3 hue = floor(mod(vec3(1,3,5)+COL-.5, 10.))*.1+.05;\n    vec3 normal = normalize(grad(cam+dir*dist));\n    float diff = length(sin(3.*normal+vec3(1,2,2))*.5+.5)/sqrt(3.);\n    C = vec3(diff*diff)*hue;\n\n  }\n  \n\n  out_color = vec4(sqrt(C), 0.);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/******\nThanks the Shader Showdown Scene folks for all the fun ! \n\n\nObrigado Inercia organiser jeenio, ps, alien and also all folks that participated !\n\n\n\n# \n    This is the first scripted shader showdown / royale entry.\n    It was 'coded' live before the event, the bonzomatic network message has been recoreded via a script, \n    and then was replayed step by step thanks to another script and the bonzomatic network\n    during the Intercia 2021 Shader Royale\n#\n\n--- \n/******\nThis work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n\n== Do not buy NFT ==\n== Do not make NFT with Creative-Commons artworks ==\n== If you respect the art and the artists, remember and apply this ==\n\n01000110011101010110001101101011 011011100110011001110100\n\n                                                                               \n _|_|_|_|                      _|            _|      _|  _|_|_|_|  _|_|_|_|_|  \n _|        _|    _|    _|_|_|  _|  _|        _|_|    _|  _|            _|      \n _|_|_|    _|    _|  _|        _|_|          _|  _|  _|  _|_|_|        _|      \n _|        _|    _|  _|        _|  _|        _|    _|_|  _|            _|      \n _|          _|_|_|    _|_|_|  _|    _|      _|      _|  _|            _|      \n                                                                          \n\n01000110011101010110001101101011 011011100110011001110100\n\n******/\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat box2(vec2 p,vec2 b){\n    vec2 q = abs(p)-b;\n     return length(max(vec2(0.),q))+min(0.,max(q.x,q.y));\n  }\n \nvec2 sdf(vec3 p){\n  p.y -=.2;\n    p.xy *=rot(-.785*.5);\n  float bump = fract(iTime);\n  vec2 h;\n  vec3 hp = p;\n  hp.y -=1.;\n  hp.x +=1.;\n  h.x =  max(abs(hp.z)-.1-bump,box2(hp.xy,vec2(.5)));\n  h.y = 1.;\n  \n  vec2 t;\n  vec3 tp = p;\n  tp.x +=1.;\n  tp.y +=1.;\n  t.x =  max(abs(tp.z)-.1-bump,box2(tp.xy,vec2(.5,1.)));\n  t.y = 1.;\n  \n  h = t.x < h.x ? t:h;\n  \n  tp = p;\n  tp.y+=.3;\n  tp.x +=.1;\n  t.x = max(abs(tp.z)-.1-bump,length(tp.xy)-1.75);\n  t.x = max(-tp.x+.1,t.x);\n  \n  float tt  = max(abs(tp.z)-.2-bump,length(tp.xy)-1.);\n  tt = max(-tp.x,tt);\n  t.x= max(-tt,t.x);\n  t.y = 2.;\n  \n    h = t.x < h.x ? t:h;\n  return h;\n  }\n#define q(s) s*sdf(p+s).x\n  vec3 norm(vec3 p,float ee){vec2 e=vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\nfloat diam2(vec2 p,float s){\n    p = abs(p);\n    return (p.x+p.y-s)*inversesqrt(3.);\n}\nvec3 txt(vec2 uv){\n  uv*=4.;\n  uv = vec2(log(length(uv)),atan(uv.y,uv.x))*3.1415;\n  uv.x -=iTime;\n  vec2 id = floor(uv);\n  uv = fract(uv)-.5;\n     vec3 col = vec3(.8,.2,.2);\n  if(mod(id.x,2.)==0.){\n       uv*=4.;\n       uv.y +=iTime;\n       uv = fract(uv)-.5;\n    col = vec3(.2,.8,.2);\n    }\n  float d = diam2(uv,.2);\n  d=  mix(d,abs(d)-.01,asin(sin(uv.x+uv.y))); // NOT SQUIDGAME \n  d=  smoothstep(1.7*fwidth(d),0.,d);\n \n  return .5*col*d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  vec3 col = txt(uv);\n  \n  vec3 ro = vec3(sin(iTime),0.,-5.);\n  vec3 rt = vec3(0.);\n  vec3 rp = ro;\n  vec3 z = normalize(rt-ro);\n  vec3 x = normalize(cross(z,vec3(0.,-1.,0.)));\n  vec3 y = normalize(cross(z,x));\n\n  vec3 rd = mat3(x,y,z)*normalize(vec3(uv,1.));\n  vec3 light = vec3(1.,2.,-3.);\n  vec3 acc = vec3(0.);\n  float time = mod(iTime,10.);\nfor(float i=0.;i<=128.;i++){\n    vec2 d = sdf(rp);\n     \n     \n     if(time < 5. && length(rp-vec3(.25,.1,.0)) >.6 ) acc += (d.y ==1. ? vec3(.2,.9,.2):vec3(.9,.2,.2))*exp(-abs(d.x))/(50.-min(40.,fract(iTime)*50.));\n     if(time < 5. &&  fract(iTime+ length(rp)*.5)<0.5){  d.x = max(.001,abs(d.x));}\n    \n    if(d.x <.0001){\n        vec3 n = norm(rp,.001);\n        vec3 nn = norm(rp,.01);\n        float diff = max(0.,dot(normalize(light-rp),n));\n        float spc = max(0.,dot(normalize(light-ro),reflect(-normalize(light),n)));\n      spc  = pow(spc,32.);\n        if(d.y == 1.){\n             col = vec3(.2,.9,.2)*diff;\n        }  else {\n             col = vec3(.9,.2,.2)*diff;\n          \n          }\n         col = time < 5. ?col : mix(col, col*step(.2,length(nn-n)),floor(asin(sin(rp.y+iTime)*.5)*10.)*.5+.5);\n         col +=spc*vec3(1.);\n      break;\n      }\n      rp +=rd*d.x;\n  \n  }  \n  col +=acc;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}