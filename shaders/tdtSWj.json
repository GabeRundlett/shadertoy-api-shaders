{
    "Shader": {
        "info": {
            "date": "1572920949",
            "description": "codevember '19 #4 \nderivative of https://www.shadertoy.com/view/4t2GDG",
            "flags": 0,
            "hasliked": 0,
            "id": "tdtSWj",
            "likes": 2,
            "name": "Codevember #4 - Ball in høøp",
            "published": 3,
            "tags": [
                "raymarching",
                "beginner",
                "codevember"
            ],
            "usePreview": 0,
            "username": "desertsky",
            "viewed": 335
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DISTANCE 100.\n#define SURF_DIST .01\n\n#define STEPS 5\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n  \n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3D(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*.1*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\nvec3 fogCube( vec3 ro , vec3 rd , vec3 n ){\n \n    float lum = .1;\n    \n    vec3 col = vec3( 0. );\n    for( int i = 0; i < STEPS; i++ ){\n        vec3 p = ro + rd * .3  * float( i );\n\n        lum += pow(triNoise3D( p * .3, float( i ) / float( STEPS )),.4);// + sin( p.y * 3. ) + sin( p.z * 5.);\n    \n       \tcol += hsv( lum * 4. + sin( iTime * .1 ) , 1. , 1. ) / lum;\n    }\n    \n    return col * 2.5/float(STEPS);\n}\n\n\n//----\n// Camera Stuff and much more courtesy of Cabbibo, who really pulled it off much better\n// https://www.shadertoy.com/view/4t2GDG\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// Taken From\n//https://www.shadertoy.com/view/MsX3RH\n\nvec3 nmap(vec2 t, sampler2D tx, float str)\n{\n\tfloat d=1.0/1024.0;\n\n\tfloat xy=texture(tx,t).x;\n\tfloat x2=texture(tx,t+vec2(d,0)).x;\n\tfloat y2=texture(tx,t+vec2(0,d)).x;\n\t\n\tfloat s=(1.0-str)*1.2;\n\ts*=s;\n\ts*=s;\n\t\n\treturn normalize(vec3(x2-xy,y2-xy,s/8.0));\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float ax )\n{\n    float an = 0.3 + 10.0*ax;\n\tcamPos = vec3(2.5*sin(an),1.0,5.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat GetDist(vec3 p) {\n\n\tvec4 sphere = vec4(0,sin(iTime)+1.,0,.5);\n    float distanceToSphere = length(p-sphere.xyz)-sphere.w;\n    \n    vec3 torusLoc = vec3(0,sin(iTime),0);\n    vec2 test = vec2(1.,.1);\n    float distToOcta = sdTorus(p+torusLoc,test);\n    \n\n    float distanceToPlane = p.y;\n    \n    float totalDistance = smin(distanceToSphere, distanceToPlane, 0.4);\n    totalDistance = smin(totalDistance, distToOcta, 0.4);\n    return totalDistance;\n    \n}\n\nvec3 GetNormal (vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.01,0);\n    vec3 pointNormal = d - vec3(\n    \tGetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n    return normalize(pointNormal);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    \n\n    for (int i = 0; i<MAX_STEPS; i++) {\n        vec3 p = ro+dO*rd;\n        float dS = GetDist(p);\n        dO+=dS;\n        if(dS<SURF_DIST || dO>MAX_DISTANCE) break;\n    }\n        return dO;    \n}\n\nvec3 GetLight(vec3 p, vec3 rd) {\n    \n\tvec3 lightPos = vec3(0,0,0);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    vec3 dif = vec3(clamp(dot(n,l),0.,.1));\n    \n    vec3 nor = GetNormal(p);\n    \n    // from\n    // https://www.shadertoy.com/view/MsX3RH\n    //triplanar blend vector\n    vec3 tpn=normalize(max(vec3(0.0),(abs(nor.xyz)-vec3(0.2))*7.0))*0.5;\n    //normal mapping\n    float nms=.59;\n    vec3 tuv=p*vec3(1.0 , 1. , 1.);\t//texture coordinates\n\n    vec3 nmx=nmap(tuv.yz,iChannel0,nms)+nmap(-tuv.yz,iChannel0,nms);\n    vec3 nmy=nmap(tuv.xz,iChannel1,nms)+nmap(-tuv.xz,iChannel1,nms);\n    vec3 nmz=nmap(tuv.xy,iChannel2,nms)+nmap(-tuv.xy,iChannel2,nms);\n\n    vec3 nn=normalize(nmx*tpn.x+nmy*tpn.y+nmz*tpn.z);\n    nor = normalize(nn + nor);\n\n\n    float match = -dot( nor , rd );\n\n    vec3 lightDir = normalize( p - lightPos );\n    vec3 refl = reflect( lightDir , nor );\n\n    float reflMatch = dot( rd , refl );\n\n    vec3 iriCol = fogCube( p , rd , nor );        \n\n    dif = iriCol * .25 + iriCol * pow( max( 0. , -reflMatch ) , 14. ) ;\n\n       // float c = pow(( 1.-AO) , 5.)*  10.;\n        float c = 0.;\n        c += pow((1.- match),4.) * 1.;\n        //c += pow(( 1.-AO) , 5.)*  2.;\n        dif -= vec3( c) ;// * .4 * ( nor * .5 + .5 );\n    \t//dif = clamp(dif, 0.,.3);\n    \treturn dif;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n\n    vec3 ro = vec3(0,1,0); // origin\n\n    \n    // camera movement\n\tvec3 col = vec3(0);\n    float ax = 0.;\n\tvec3 ta;\n    ax+=iTime/10.;\n    doCamera( ro, ta, iTime, ax );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    vec3 rd = normalize(camMat*vec3(uv.x,uv.y,2)); // direction    \n\n    \n\tfloat d = RayMarch(ro, rd);\n\n    if( d > -.5 ){\n        vec3 p = ro + rd * d;\n        vec3 dif = GetLight(p, rd);    \n\t    col = vec3(dif*3.);\n        \n      }\n    \n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}