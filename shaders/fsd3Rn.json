{
    "Shader": {
        "info": {
            "date": "1629016724",
            "description": "Relax and unwind in the distance fields\n    \na 4k executable graphics entry for Névoke 2021",
            "flags": 32,
            "hasliked": 0,
            "id": "fsd3Rn",
            "likes": 74,
            "name": "Fragments [névoke]",
            "published": 3,
            "tags": [
                "dispersion",
                "zen",
                "crystal",
                "nevoke"
            ],
            "usePreview": 1,
            "username": "tdhooper",
            "viewed": 2155
        },
        "renderpass": [
            {
                "code": "/*\n\n    Fragments\n    ---------\n\n    Relax and unwind in the distance fields\n    \n    a 4k executable graphics entry for Névoke 2021\n\n*/\n\n\n// colour grading from tropical trevor's scripts\n// https://github.com/trevorvanhoof/ColorGrading\n\n#define sat(x) clamp(x,0.,1.)\n\n// from http://www.tannerhelland.com/4435/convert-temperature-rgb-algorithm-code/\nvec3 colorFromKelvin(float temperature) // photographic temperature values are between 15 to 150\n{\n    float r, g, b;\n    if(temperature <= 66.0)\n    {\n        r = 1.0;\n        g = sat((99.4708025861 * log(temperature) - 161.1195681661) / 255.0);\n        if(temperature < 19.0)\n            b = 0.0;\n        else\n            b = sat((138.5177312231 * log(temperature - 10.0) - 305.0447927307) / 255.0);\n    }\n    else\n    {\n        r = sat((329.698727446 / 255.0) * pow(temperature - 60.0, -0.1332047592));\n        g = sat((288.1221695283  / 255.0) * pow(temperature - 60.0, -0.0755148492));\n        b = 1.0;\n    }\n    return vec3(r, g, b);\n}\n\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nfloat Luma(vec3 color) { return dot(color, vec3(0.2126, 0.7152, 0.0722)); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec4 tex = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n\tvec3 col = tex.rgb / tex.a;\n\n    //fragColor = vec4(col, 1); return;\n\n    // saturation\n\tfloat luma = Luma(col);\n\tcol = mix(vec3(luma), col, 1.25);\n\n    // temperature\n    col *= 1. / colorFromKelvin(100.);\n\n    vec3 uGain = vec3(1.333);\n    vec3 uLift = vec3(.0015,.00,.005) * 1.25;\n    vec3 uOffset = vec3(.00,.00,.00);\n    vec3 uGamma = vec3(.0666);\n    col = pow(max(vec3(0.0), col * (1.0 + uGain - uLift) + uLift + uOffset), max(vec3(0.0), 1.0 - uGamma));\n    col = aces(col);\n    col = pow( col, vec3(1./2.2) );\n    \n    fragColor = vec4(col, 1);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.1415926\n\n\n// Spectrum palette\n// IQ https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n//========================================================\n// Noise\n//========================================================\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n    p += 1.61803398875; // fix artifacts when reseeding\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nconst uint k = 1103515245U;  // GLIB C\n\n// https://www.shadertoy.com/view/XlXcW4\nvec3 hash33( vec3 xs )\n{\n    uvec3 x = uvec3(xs);\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat hash13(vec3 p3)\n{\n\treturn hash33(p3).x;\n}\n\n\n//========================================================\n// Utils\n//========================================================\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat vmin(vec3 v) {\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat vmax2(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax2(min(d, vec2(0)));\n}\n\nmat3 lookUp(vec3 up, vec3 forward) {\n    vec3 ww = normalize(up);\n    vec3 uu = normalize(cross(ww,forward));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, ww, vv);\n}\n\nvec3 pLookUp(vec3 p, vec3 up, vec3 forward) {\n    return p * lookUp(up, forward);\n}\n\nvec2 rndcircle(vec2 seed) {\n    float a = seed.x * 2. * PI;\n    float r = sqrt(seed.y);\n    return vec2(r * cos(a), r * sin(a));\n}\n\nfloat unlerp(float minv, float maxv, float value) {\n  return (value - minv) / (maxv - minv);\n}\n\n\n//========================================================\n// Modelling\n//========================================================\n\nfloat invert;\n\nstruct Model {\n    float d;\n    int id;\n};\n\nfloat sdCrystalOne(vec3 size, vec3 p) {\n    float d = fBox(p, size);\n    d = max(d, -abs(p.x));\n    d = max(d, -(d + vmin(size) * .333));\n    return d;\n}\n\nfloat sdCrystalLoop(vec3 size, vec3 l, vec3 p, float seed) {\n\n    p.y = max(p.y, .5 * size.y / l.y);\n    \n    p.y -= size.y * .5;\n    size.y *= .5;\n\n    float bs = 1.;\n    float bound = fBox(p, size * vec3(1.5,1.4,1.5));\n    if (bound > bs) {\n        return bound;\n    }\n   \n    vec3 pp = p;\n    float d = 1e12;\n    \n    for (int x = 0; x < int(l.x); x++)\n    for (int y = 0; y < int(l.y); y++)\n    for (int z = 0; z < int(l.z); z++) {\n        p = pp;\n        vec3 c = vec3(x, y, z);\n        p -= ((c + .5) / l - .5) * size * 2.;\n        vec3 sz = size / l;\n        vec3 h3 = hash33(c + 11. + seed);\n        p -= (h3 * 2. - 1.) * sz * .5;\n        float m = hash13(c * 10. + 27. + seed);\n        sz *= mix(.6, 1.5, m);\n        sz.xz *= mix(1.8, .45, pow(float(y) / (l.y - 1.), .5));\n        float d2 = fBox(p, sz);\n        d2 = max(d2, -abs(p.x));\n        if (h3.z > .5 && c.y > 0.) {\n            d2 = max(d2, -abs(p.y - (m * 2. - 1.) * sz.y * .5));\n        }\n        d = min(d, d2);\n    }\n    \n    d = max(d, -(d + vmin(size / l) * .5));\n    \n    d = mix(d, bound, smoothstep(bs * .8, bs, bound));\n\n    return d;\n}\n\n\nfloat sdCrystalLoop2(vec3 size, vec3 l, vec3 p) {\n\n    size *= .9;\n    \n    p.y -= size.y * .5;\n    size.y *= .5;\n    \n    float bs = 1.;\n    float bound = fBox(p, size * vec3(1.2,1.8,1.2));\n    if (bound > bs) {\n        return bound;\n    }\n\n    vec3 pp = p;\n    float d = 1e12;\n    \n    for (int x = 0; x < int(l.x); x++)\n    for (int y = 0; y < int(l.y); y++)\n    for (int z = 0; z < int(l.z); z++) {\n        p = pp;\n        vec3 c = vec3(x, y, z);\n        p -= ((c + .5) / l - .5) * size * 2.;\n        vec3 sz = size / l;\n        float m = hash13(c+15.);\n        sz *= mix(1.1, 1.75, m);\n        float d2 = fBox(p, sz) + .01;\n        if (c == vec3(0)) {\n            d2 = max(d2, -abs(p.x));\n        }\n        d2 = max(d2, -d);\n        d = min(d, d2);\n    }\n    \n    d = max(d, -(d + vmin(size / l) * .5));\n    \n    d = mix(d, bound, smoothstep(bs * .8, bs, bound));\n    \n    return d;\n}\n\nfloat sdCrystalField(vec3 p) {\n    float d = 1e12;\n    float s = .2;\n    d = sdCrystalLoop(vec3(.35, 1.6, .35), vec3(2,3,2), pLookUp(p - vec3(.8,0,-.8), vec3(.2,1,-.5), vec3(1,0,1)), 0.);\n    d = smin(d, sdCrystalOne(vec3(.13), pLookUp(p - vec3(1.8,-.15,-.3), vec3(0,1,0), vec3(1,0,-.25))), s);\n    d = smin(d, sdCrystalLoop2(vec3(.3, .35, .3), vec3(2,1,2), pLookUp(p - vec3(-.3,0,.5), vec3(-.0,1,.2), vec3(.0,0,1)) - vec3(0,-.2,0)), s);\n    d = smin(d, sdCrystalLoop(vec3(.15,1.,.15), vec3(1,3,1), pLookUp(p - vec3(-1.8,-.15,-2.3), vec3(-1,2,-.5), vec3(-1,0,-2)), 11.), s);\n    return d;\n}\n\n\nModel map(vec3 p) {\n    //vec2 im = iMouse.xy / iResolution.xy;     \n    vec2 im = vec2(.43,.43);\n    pR(p.yz, (.5 - im.y) * PI);\n    pR(p.xz, (.5 - im.x) * PI * 2.5);\n    \n    p.y += .6;\n    p.xz -= vec2(-1,1) * .4;\n    \n    float d = p.y + .25;    \n    d = smin(d, length(p - vec3(.6,-2.5,-.7)) - 2.5, .6);\n    d = smin(d, length(p - vec3(-.3,-.5,.5)) - .5, .4);\n\n    float d2 = sdCrystalField(p);\n\n    float df = pow(d2 + .333, .5) * 1.5;\n    float ripple = 7.;    \n    d += cos(max(df, 0.) * ripple * PI * 2.) * .015;\n\n    Model m = Model(d, 2);\n    Model m2 = Model(d2 * invert, 1);\n    \n    if (m2.d < m.d) {\n        m = m2;\n    }\n\n    return m;\n}\n\n\n//========================================================\n// Rendering\n//========================================================\n\nconst float sqrt3 = 1.7320508075688772;\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e).d;\n    }\n    return normalize(n);\n}\n\nstruct Hit {\n    Model model;\n    vec3 pos;\n    float len;\n};\n\nHit march(vec3 origin, vec3 rayDir, float maxDist) {\n    vec3 p;\n    float len = 0.;\n    float dist = 0.;\n    Model model;\n\n    for (float i = 0.; i < 100.; i++) {\n        len += dist;\n        p = origin + len * rayDir;\n        model = map(p);\n        dist = model.d;\n        if (abs(model.d) / len < .0002) {\n            break;\n        }\n        if (len >= maxDist) {\n            len = maxDist;\n            model.id = 0;\n            break;\n        }\n    }   \n\n    return Hit(model, p, len);\n}\n\n// tracing/lighting setup from yx\n// https://www.shadertoy.com/view/ts2cWm\nvec3 ortho(vec3 a){\n    vec3 b=cross(vec3(-1,-1,.5),a);\n    // assume b is nonzero\n    return (b);\n}\n\n// re-borrowed from yx from\n// http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec3 getSampleBiased(vec3  dir, float power, vec2 seed) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = seed;\n\tr.x=r.x*2.*PI;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 getConeSample(vec3 dir, float extent, vec2 seed) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  seed;\n\tr.x=r.x*2.*PI;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nfloat intersectPlane(vec3 rOrigin, vec3 rayDir, vec3 origin, vec3 normal, vec3 up, out vec2 uv) {\n    float d = dot(normal, (origin - rOrigin)) / dot(rayDir, normal);\n  \tvec3 point = rOrigin + d * rayDir;\n\tvec3 tangent = cross(normal, up);\n\tvec3 bitangent = cross(normal, tangent);\n    point -= origin;\n    uv = vec2(dot(tangent, point), dot(bitangent, point));\n    return max(sign(d), 0.);\n}\n\nmat3 sphericalMatrix(vec2 tp) {\n    float theta = tp.x;\n    float phi = tp.y;\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 envOrientation;\n\nvec3 light(vec3 origin, vec3 rayDir) {\n\n    origin = -origin;\n    rayDir = -rayDir;\n\n    origin *= envOrientation;\n    rayDir *= envOrientation;\n\n    vec2 uv;\n    vec3 pos = vec3(-6);\n    float hit = intersectPlane(origin, rayDir, pos, normalize(pos), normalize(vec3(-1,1,0)), uv);\n    float l = smoothstep(.75, .0, fBox2(uv, vec2(.5,2)) - 1.);\n    l *= smoothstep(6., 0., length(uv));\n\treturn vec3(l) * hit * 2.;\n}\n\nvec4 draw(vec2 fragCoord) {\n\n    vec2 seed = hash22(fragCoord + (float(iFrame)) * sqrt3);\n\n    invert = 1.;\n    \n    envOrientation = sphericalMatrix(((vec2(81.5, 119) / vec2(187)) * 2. - 1.) * 2.);\n\n    vec2 p = (-iResolution.xy + 2.* fragCoord) / iResolution.y;\n    \n    // jitter for antialiasing\n    p += 2. * (seed - .5) / iResolution.xy;\n\n    float focalLength = 3.;\n    vec3 camPos = vec3(0, 0, 1.5) * focalLength;\n    vec3 camTar = vec3(0, 0, 0);\n    \n    // DOF\n    camPos.xy += rndcircle(seed) * .05;\n    seed = hash22(seed);\n    \n    vec3 ww = normalize(camTar - camPos);\n    vec3 uu = normalize(cross(vec3(0,1,0),ww));\n    vec3 vv = normalize(cross(ww,uu));\n    mat3 camMat = mat3(-uu, vv, ww);\n\n    vec3 rayDir = normalize(camMat * vec3(p.xy, focalLength));\n    vec3 origin = camPos;\n    \n    Hit hit = march(origin, rayDir, 4. * focalLength);\n\n    float firstHitLen = hit.len;\n    bool isFloor = hit.model.id == 2;\n    \n    vec3 nor, ref, raf; \n    float ior, offset;\n    \n    float wavelength = seed.y;\n    vec3 col = vec3(0);    \n\n    for (int bounce = 0; bounce < 10; bounce++) {\n   \n        if (bounce > 0) {\n           seed = hash22(seed);\n           hit = march(origin, rayDir, 6.);\n        }\n        \n        if (hit.model.id == 0) {\n            break;\n        }\n\n        nor = calcNormal(hit.pos);\n        \n        if (hit.model.id == 1) {\n            \n            // Reflective bounce\n            \n            ref = reflect(rayDir, nor);\n            \n            // shade\n            col += light(hit.pos, ref) * .5;\n            col += pow(max(1. - abs(dot(rayDir, nor)), 0.), 5.) * .1;\n            col *= vec3(.85,.85,.98);\n\n            // refract\n            ior = mix(1.2, 1.8, wavelength);\n            ior = invert < 0. ? ior : 1. / ior;\n            raf = refract(rayDir, nor, ior);\n            bool tif = raf == vec3(0); // total internal reflection\n            rayDir = tif ? ref : raf;\n            invert *= -1.; // not correct but gives more interesting results\n            //invert = tif ? 1. : -1.; // 'correct' refraction\n            \n        } else {\n            \n            // Diffuse bounce\n            \n            seed = hash22(seed);\n            rayDir = getSampleBiased(nor, 1., seed);            \n \n        }\n        \n        offset = .01 / abs(dot(rayDir, nor));\n        origin = hit.pos + offset * rayDir;\n    }    \n    \n    if (isFloor) {\n        col *= 2.;\n    }\n\n    vec3 fogcol = vec3(.0);\n    col = mix(col, fogcol, saturate(1.0 - exp2(-.0006 * pow(firstHitLen - length(camPos*.666), 5.))));\n\n    // Dispersion\n    col *= spectrum(-wavelength+.30);\n\n    return vec4(col, 1);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec4 col = draw(fragCoord);\n    \n    if (iFrame > 0) {\n        vec4 lastCol = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n        col += lastCol;\n    }\n    \n    fragColor = col;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}