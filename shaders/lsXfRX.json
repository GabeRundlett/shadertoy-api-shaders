{
    "Shader": {
        "info": {
            "date": "1497157058",
            "description": "Mouse rotates camera. FBM based nebula and starfield with a trick that looks like gravitational lensing. ",
            "flags": 0,
            "hasliked": 0,
            "id": "lsXfRX",
            "likes": 9,
            "name": "Cosmos",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "fractal",
                "noise",
                "interactive",
                "volumetric"
            ],
            "usePreview": 0,
            "username": "Ebanflo",
            "viewed": 1156
        },
        "renderpass": [
            {
                "code": "// Cosmos by Eben Kadile aka Ebanflo - 2017\n// eben.cowley42@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define pi 3.141592654\n#define urx 1920U\n#define ury 1080U\n#define time iDate.x + iDate.y + iDate.z + iDate.w\n//blackhole\n#define renderBlackhole\n#define blackholeInFront //adds cool halo effect when clouds pass in front of the lensing\n#define blackholeCenter vec3(0.0)\n#define blackholeRadius .12\n#define blackholeIntensity .02\n//nebula\n#define cloudSpeed .05\n#define fractalIterations3d 5\n#define renderIterations 6\n#define stepsize .3\n#define cloudBrightness 1.1\n#define cloudThickness .47\n#define colDisp vec3(2.5, 5.0, 7.5)\n#define colDist 6.0\n//starfield\n#define renderStars\n#define fractalIterations2d 4\n#define starDensity .15\n#define starColor vec3(1.0)\n#define starBrightness 1.0\n#define starTwinkle \n#define twinkleFreq .01\nconst bool coolEffect = false; //try it out\n\nvec4 iPlane(vec3 ro, vec3 rd, vec3 po, vec3 pd){\n    float d = dot(po - ro, pd) / dot(rd, pd);\n    return vec4(d * rd + ro, d);\n}\n\n//modified Lambert-Azimuthal projection\nvec2 proj(vec3 v){return inversesqrt(.5 * (1.0 + abs(v.z)) * abs(v.xy));}\n\nvec3 r(vec3 v, vec2 r){//rodolphito's rotation\n    vec4 t = sin(vec4(r, r + 1.5707963268));\n    float g = dot(v.yz, t.yw);\n    return vec3(v.x * t.z - g * t.x,\n                v.y * t.w - v.z * t.y,\n                v.x * t.x + g * t.z);\n}\n\nfloat hash(uint n){//Hugo Elias's hash\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return 1.0 - float(n & 0x7fffffffU)/float(0x7fffffff);\n}\n\nfloat hashNoise2(vec2 x){\n    x = mod(x, .1);\n    x *= vec2(urx, ury);\n    vec2 fr = fract(x);\n    uvec2 p = uvec2(x);\n\tfloat f1 = hash(p.x + ury * p.y);\n    float f2 = hash(p.x + 1U + ury * p.y);\n    f1 = mix(f1, f2, fr.x);\n    float f3 = hash(p.x + ury * (p.y + 1U));\n    float f4 = hash(p.x + 1U + ury * (p.y + 1U));\n    f3 = mix(f3, f4, fr.x);\n\treturn mix(f1, f3, fr.y);\n}\n\nfloat hashNoise3(vec3 x){\n    vec3 fr = fract(x);\n    fr = smoothstep(0.0, 1.0, fr);\n    uvec3 p = uvec3(x);\n    return mix(mix(mix(hash(p.x + ury * p.y + urx * p.z), \n                        hash(p.x + 1U + ury * p.y + urx * p.z),fr.x),\n                   mix(hash(p.x + ury * (p.y + 1U) + urx * p.z), \n                        hash(p.x + 1U + ury * (p.y + 1U) + urx * p.z),fr.x),fr.y),\n               mix(mix(hash(p.x + ury * p.y + urx * (p.z + 1U)), \n                        hash(p.x + 1U + ury * p.y + urx * (p.z + 1U)),fr.x),\n                   mix(hash(p.x + ury * (p.y + 1U) + urx * (p.z + 1U)), \n                        hash(p.x + 1U + ury * (p.y + 1U) + urx * (p.z + 1U)),fr.x),fr.y),fr.z);\n}\n\nfloat fractalNoise3d(vec3 pos){\n    float acc = 0.0;\n    float scale = 1.0;\n    for(int n = 0; n < fractalIterations3d; n++){\n        acc += hashNoise3(scale * pos) / scale;\n        scale *= 2.0;\n    }\n    return .5 * acc; \n}\n\nfloat fractalNoise2d(vec2 x){\n    float acc = 0.0;\n    float scale = 1.0;\n    for(int n = 0; n < fractalIterations2d; n++){\n        acc += hashNoise2(scale * x) / scale;\n        scale *= 2.0;\n    }\n    return .65 * acc;\n}\n\nvec3 density(vec3 pos, float d){\n    pos += cloudSpeed * (time + 13.0);\n    float fn = fractalNoise3d(pos * 10.0);\n    fn *= cloudBrightness;\n    fn = 3.0 * smoothstep(1.0 - cloudThickness, 1.0, fn);\n    vec3 col = fn * sin(fn + colDisp + colDist * d);\n    return mix(col, vec3(fn), fn);\n}\n\nvec3 starField(vec2 pos){\n    float stars = fractalNoise2d(pos);\n    stars = smoothstep(1.0 - starDensity, 1.0, stars);\n    stars *= starBrightness;\n    #ifdef starTwinkle\n    if(stars > 1.0 - starDensity || coolEffect){\n    \tstars -= hash(uint(5.0 * abs((pos.x + float(urx) * pos.y)) \n                           + float(ury) * iTime * twinkleFreq));\n    }\n\t#endif\n    return starColor * stars;\n}\n\n#ifdef blackholeInFront\nvec3 render(vec3 ro, vec3 rd){\n    #ifdef renderBlackhole\n    \tvec3 nml = normalize(blackholeCenter - ro);\n    \tvec3 pos = iPlane(ro, rd, blackholeCenter, nml).xyz;\n    \tpos = blackholeCenter - pos;\n    \tfloat intensity = dot(pos, pos);\n    \tif(intensity < blackholeRadius * blackholeRadius) return vec3(0.0);\n    \telse {\n            intensity = 1.0 / intensity;\n        \trd = mix(rd, pos * sqrt(intensity), blackholeIntensity * intensity);\n        }\n    #endif\n    vec3 result = vec3(0.0);\n    float d = stepsize;\n\tfor(int n = 0; n < renderIterations; n++){\n        vec3 pos = d * rd + ro;\n        result += density(pos, d) / d;\n        d += stepsize;\n    }\n    #ifdef renderStars\n    \tvec2 dir = proj(rd);\n    \tvec3 stars = starField(dir);\n    \tresult += stars;\n    #endif\n    return result;\n}\n#else\nvec3 render(vec3 ro, vec3 rd){\n    vec3 nml = normalize(blackholeCenter - ro);\n    vec4 pos = iPlane(ro, rd, blackholeCenter, nml);\n    float dist = pos.w;\n    vec3 p = blackholeCenter - pos.xyz;\n    float intensity = dot(p, p);\n    vec3 result = vec3(0.0);\n    float ss = 2.0 * dist / float(renderIterations);\n    float d = ss;\n\tfor(int n = 0; n < renderIterations / 2; n++){\n        vec3 pos = d * rd + ro;\n        result += density(pos, d) / d;\n        d += ss;\n    }\n    bool cont = true;\n    #ifdef renderBlackhole\n    \tif(intensity < blackholeRadius * blackholeRadius){\n        \tresult -= .5;\n            cont = false;\n        }\n    \telse {\n            intensity = 1.0 / intensity;\n        \trd = mix(rd, p * sqrt(intensity), blackholeIntensity * intensity);\n        }\n    #endif\n    if(cont){\n    \tfor(int n = 0; n < renderIterations / 2; n++){\n    \t    vec3 pos = d * rd + ro;\n    \t    result += density(pos, d) / d;\n    \t    d += ss;\n    \t}\n    }\n    #ifdef renderStars\n    if(cont){\n    \tvec2 dir = proj(rd);\n    \tvec3 stars = starField(dir);\n    \tresult += stars;\n    }\n    #endif\n    return result;\n}\n#endif\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n\tfragColor = vec4(1.0);\n    vec2 xy = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -1.0);\n    vec3 rd = normalize(vec3(xy, 3.0));\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    if(iMouse.xy == vec2(0.0)) m = vec2(0.0);\n    rd = r(rd, m);\n    ro = r(ro, m);\n    ro += blackholeCenter;\n    fragColor.xyz = render(ro, rd);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}