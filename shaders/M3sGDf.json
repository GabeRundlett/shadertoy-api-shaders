{
    "Shader": {
        "info": {
            "date": "1708042916",
            "description": "Relatively simple fluid simulation based on cellular automata",
            "flags": 32,
            "hasliked": 0,
            "id": "M3sGDf",
            "likes": 10,
            "name": "Simple Fluid Cellular Automata",
            "published": 3,
            "tags": [
                "fluid",
                "liquid",
                "ca",
                "cellularautomata"
            ],
            "usePreview": 0,
            "username": "Oman395",
            "viewed": 253
        },
        "renderpass": [
            {
                "code": "/*\n* Relatively simple fluid cellular automata\n* Made by Oran RH\n* \n* This, as the name implies, is a very crude fluid simulation making use of cellular automata. I have consulted exactly 0 papers, and used 0 preexisting formulas;\n* I should say that it is somewhat inspired by https://www.shadertoy.com/view/WtfyDj, which I believe is a more advanced version of a similar system to this.\n*\n* The idea behind the algorithm is simple. Each pixel has a \"velocity\" and \"height\", which are updated every frame. During the update, the velocity will be updated\n* based on the relative heights of the pixels around it. As well, the velocity will be updated to account for height coming in from other pixels, as well as height\n* from the current pixel. Unfortunately, the devil's in the details; there are *so many* ways for NaN and Infinity to appear that it gets really annoying.\n*\n* I've also included a gaussian blur with a relatively low sigma, which I find helps to remove some of the strange-looking noise in particularly turbulent areas without\n* removing too much detail.\n*\n* Also does anyone know which algorithm I've definitely accidentally implemented here because I have no clue\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(length(texture(iChannel0, uv).xy) / 2.0) * (texture(iChannel0, uv).b / 2.0) + vec4(0,0,texture(iChannel0, uv).b / 2.0,1);\n    fragColor = vec4(texture(iChannel0, uv).z) / 2.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float DT = 0.2;\n\nconst vec2 BLOCK_POS_1 = vec2(100, 100);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    if(distance(fragCoord, BLOCK_POS_1) < 20.0) {\n        fragColor = vec4(0);\n        return;\n    }\n    if(iFrame == 0) {\n        fragColor = vec4(0, 0, 0.3, 1);\n        return;\n    }\n    vec4 currentData = texture(iChannel0, uv);\n    vec2 currentVel = currentData.xy;\n    vec2 acc = currentVel;\n    float dAcc = currentData.z;\n    float currentDensity = currentData.z;\n    float forceXSign = 0.0;\n    float forceYSign = 0.0;\n    vec2 forceReflectNormal = vec2(-100);\n\n    // 3x3 around current pixel\n    for(int x = -1; x < 2; x++) {\n        for(int y = -1; y < 2; y++) {\n            if(x == 0 && y == 0) continue; // Exclude 0,0\n            // Bounce off walls\n            if(fragCoord.x + float(x) >= iResolution.x) {\n                if(currentVel.x > 0.0) forceXSign = -1.0;\n                continue;\n            }\n            if(fragCoord.x + float(x) < 0.0) {\n                if(currentVel.x > 0.0) forceXSign = -1.0;\n                continue;\n            }\n            if(fragCoord.y + float(y) >= iResolution.y) {\n                if(currentVel.y > 0.0) forceYSign = -1.0;\n                continue;\n            }\n            if(fragCoord.y + float(y) < 0.0) {\n                if(currentVel.y < 0.0) forceYSign = 1.0;\n                continue;\n            }\n            if(distance(fragCoord + vec2(x,y), BLOCK_POS_1) < 20.0) {\n                vec2 np = fragCoord + vec2(x,y);\n                vec2 delta = normalize(np - BLOCK_POS_1);\n                forceReflectNormal = normalize(delta);\n                continue;\n            }\n\n\n            vec2 offDir = vec2(x,y);\n            vec4 offsetData = texture(iChannel0, uv + offDir / iResolution.xy);\n            \n            // Height based velocity change, relatively simple, just adds around enough to equalize the levels if DT=1, which I've found to\n            // give good results\n            float deltaDensity = currentDensity - offsetData.z;\n            acc -= normalize(offDir) * deltaDensity * DT;\n            // This is almost a prediction step, effectively smoothing out a lot of the really high heights before they get too bad\n            dAcc -= deltaDensity * DT / length(offDir) / 2.0;\n            \n            // Adjusting the velocities like this allows us to somewhat loosely \"predict\" what the velocities will be in the future,\n            // accounting for issues related to the non-continuous natre of the simulatiion, as well as helping to reduce the prevalence\n            // of comically high waves\n            vec2 offVel = offsetData.xy + (deltaDensity * DT / length(offDir) / 4.0);\n            vec2 cVelLater = currentVel - (deltaDensity * DT / length(offDir) / 4.0);\n            float offDens = offsetData.z;\n            \n            float offVelDot = dot(normalize(offVel), normalize(offDir));\n            float curVelDot = -dot(normalize(cVelLater), normalize(offDir));\n            // Recieved fluid\n            // We \n            if(length(offVel) != 0.0 && offVelDot >= 0.0) {\n                dAcc += offDens * min(length(offVel), 1.0) * offVelDot * DT / length(offDir);\n                acc += normalize(offVel) * currentDensity * offVelDot * DT * min(length(offVel), 1.0) / length(offDir);\n            }\n            if(length(cVelLater) != 0.0 && curVelDot >= 0.0) {\n                dAcc -= currentDensity * min(length(cVelLater), 1.0) * curVelDot * DT / length(offDir);\n                acc -= normalize(cVelLater) * offDens * curVelDot * DT * min(length(cVelLater) / length(offDir), 1.0);\n            }\n        }\n    }\n    if(dAcc < 0.0) dAcc = 0.0;\n    if(forceYSign != 0.0) acc.y = abs(acc.y) * forceYSign * 0.5;\n    if(forceXSign != 0.0) acc.x = abs(acc.x) * forceXSign * 0.5;\n    if(length(forceReflectNormal) < 10.0) acc = reflect(acc, forceReflectNormal);\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if(distance(uv * vec2(iResolution.x / iResolution.y, 1), mouse * vec2(iResolution.x / iResolution.y, 1)) < 0.05 && iMouse.z >= 0.0) {\n        fragColor = vec4(0, 0, 2, 1);\n        return;\n    }\n    fragColor = vec4(acc * 0.999, dAcc, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}