{
    "Shader": {
        "info": {
            "date": "1492529570",
            "description": "I'm approximating the signed distance to a (rational) cubic bezier curve.\nIt's based on implicitization using moving lines. See https://www.shadertoy.com/view/XdjcDz for a visualization of what's happening.",
            "flags": 0,
            "hasliked": 0,
            "id": "lsByRG",
            "likes": 7,
            "name": "Cubic bezier approx distance",
            "published": 3,
            "tags": [
                "2d",
                "bezier",
                "cubic",
                "rational",
                "cubicbezier"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 1983
        },
        "renderpass": [
            {
                "code": "/*\n\tMy technique is mostly based on chapter 17 of \n\thttps://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=1000&context=facpub\n\n\tBut i've also used stuff from\n\thttp://140.129.20.249/~jmchen/ana/docs/resultant/implicitization-sederbeg.pdf\n\tand http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\n\t(see https://www.shadertoy.com/view/XsX3zf)\n*/\n\n//#define TAYLOR\n//#define RATIONAL\n\nconst float dot_size=.005;\n\nconst vec3 point_col=vec3(1,1,0);\n\nconst float weight_p1=1.;\nconst float weight_p2=1.;\n\nconst float zoom=1.;\n\nconst float pi=3.1415926535;\n\nfloat det(mat2 m){\n\treturn m[0][0] * m[1][1] - m[1][0] * m[0][1];\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec3 coeffs, out vec2 roots){\n    float p, q, D;\n\n    // normal form: x^2 + px + q = 0\n\n    p = coeffs[1] / (2. * coeffs[0]);\n    q = coeffs[2] / coeffs[0];\n\n    D = p * p - q;\n\n    if (D < 0.){\n\t\treturn 0;\n    }\n    else if (D > 0.){\n\t\tfloat sqrt_D = sqrt(D);\n\n\t\troots[0] =   sqrt_D - p;\n\t\troots[1] = - sqrt_D - p;\n\t\treturn 2;\n    }\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(float a, float b, float c, out vec3 r){\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n    r[1] = offset - u * (n + m);\n    r[2] = offset + u * (n - m);\n    \n    vec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n    \n    r -= f / f1;\n\n\treturn 3;\n}\n\n//Sign computation is pretty straightforward:\n//I'm solving a cubic equation to get the intersection count\n//of a ray from the current point to infinity and parallel to the x axis\n//Also i'm computing the intersection count with the tangent in the end points of the curve\nfloat cubic_bezier_sign(vec2 uv, vec3 p0, vec3 p1, vec3 p2, vec3 p3){\n\n\t#ifndef RATIONAL\n\tp0/=p0.z;\n\tp1/=p1.z;\n\tp2/=p2.z;\n\tp3/=p3.z;\n\t#endif\n\n\t#ifdef RATIONAL\n\tfloat cu=(-p0.y+3.*p1.y-3.*p2.y+p3.y)-uv.y*(-p0.z+3.*p1.z-3.*p2.z+p3.z);\n\tfloat qu=(3.*p0.y-6.*p1.y+3.*p2.y)-uv.y*(3.*p0.z-6.*p1.z+3.*p2.z);\n\tfloat li=(-3.*p0.y+3.*p1.y)-uv.y*(-3.*p0.z+3.*p1.z);\n\tfloat co=p0.y-uv.y*p0.z;\n\t#else\n\tfloat cu=(-p0.y+3.*p1.y-3.*p2.y+p3.y);\n\tfloat qu=(3.*p0.y-6.*p1.y+3.*p2.y);\n\tfloat li=(-3.*p0.y+3.*p1.y);\n\tfloat co=p0.y-uv.y;\n\t#endif\n\n\tvec3 roots;\n\tint n_roots=solve_cubic(qu/cu,li/cu,co/cu,roots);\n\n\tint n_ints=0;\n\n\tfor(int i=0;i<3;i++){\n\t\tif(i<n_roots){\n\t\t\tif(roots[i]>=0. && roots[i]<=1.){\n\t\t\t\tfloat x_pos=((((-p0.x+3.*p1.x-3.*p2.x+p3.x)*roots[i]+(3.*p0.x-6.*p1.x+3.*p2.x))*roots[i])+(-3.*p0.x+3.*p1.x))*roots[i]+p0.x;\n\t\t\t\t#ifdef RATIONAL\n\t\t\t\tfloat x_pos_w=((((-p0.z+3.*p1.z-3.*p2.z+p3.z)*roots[i]+(3.*p0.z-6.*p1.z+3.*p2.z))*roots[i])+(-3.*p0.z+3.*p1.z))*roots[i]+p0.z;\n\t\t\t\tx_pos/=x_pos_w;\n\t\t\t\t#endif \n\n\t\t\t\tif(x_pos<uv.x){\n\t\t\t\t\tn_ints++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t#ifdef RATIONAL\n\tp0/=p0.z;\n\tp1/=p1.z;\n\tp2/=p2.z;\n\tp3/=p3.z;\n\t#endif\n\n\tvec2 tang1=p0.xy-p1.xy;\n\tvec2 tang2=p2.xy-p3.xy;\n\n\tvec2 nor1=vec2(tang1.y,-tang1.x);\n\tvec2 nor2=vec2(tang2.y,-tang2.x);\n\n\tif(p0.y<p1.y){\n\t\tif((uv.y<=p0.y) && (dot(uv-p0.xy,nor1)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\telse{\n\t\tif(!(uv.y<=p0.y) && !(dot(uv-p0.xy,nor1)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\n\tif(p2.y<p3.y){\n\t\tif(!(uv.y<=p3.y) && dot(uv-p3.xy,nor2)<0.){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\telse{\n\t\tif((uv.y<=p3.y) && !(dot(uv-p3.xy,nor2)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\n\tif(n_ints==0 || n_ints==2 || n_ints==4){\n\t\treturn 1.;\n\t}\n\telse{\n\t\treturn -1.;\n\t}\n}\n\nfloat cubic_bezier_dis_approx(vec2 uv, vec3 p0, vec3 p1, vec3 p2, vec3 p3){\n\n\t#ifndef RATIONAL\n\tp0/=p0.z;\n\tp1/=p1.z;\n\tp2/=p2.z;\n\tp3/=p3.z;\n\t#endif\n\n\tfloat bezier_dis=1e38;\n\n\t//Control lines of quadratic bezier lines\n\t//The intersection of two of the three moving lines\n\t//at the same parameter value define the cubic bezier curve\n\tvec3 line00=3.*cross(p0,p1);\n\tvec3 line01=3.*cross(p0,p2);\n\tvec3 line02=cross(p0,p3);\n\n\tvec3 line10=line01;\n\tvec3 line11=cross(p0,p3)+9.*cross(p1,p2);\n\tvec3 line12=3.*cross(p1,p3);\n\n\tvec3 line20=line02;\n\tvec3 line21=line12;\n\tvec3 line22=3.*cross(p2,p3);\n\n\t//Compute a linear moving line (line pencil) through elimination\n\t//The intersection of this and one of the quadratic moving lines\n\t//define the cubic bezier curve\n\tfloat pre_factor1=line20.z/line00.z;\n\tfloat pre_factor2=line20.z/line10.z;\n\n\tfloat sub_factor=(line20.x-pre_factor2*line10.x)/(pre_factor1*line00.x-pre_factor2*line10.x);\n\n\tfloat factor1=pre_factor1*sub_factor;\n\tfloat factor2=pre_factor2*(1.-sub_factor);\n\n\tvec3 line31=line21-factor1*line01-factor2*line11;\n\tvec3 line32=line22-factor1*line02-factor2*line12;\n\n\t//Compute signed distance of pixel coordinate to the control lines\n\tfloat l00=dot(vec3(uv,1),line00);\n\tfloat l01=dot(vec3(uv,1),line01);\n\tfloat l02=dot(vec3(uv,1),line02);\n\n\tfloat l11=dot(vec3(uv,1),line31);\n\tfloat l12=dot(vec3(uv,1),line32);\n\n\t//Compute the value of the resultant\n\t//of both line equations at the pixel coordinate\n\t//this is an implicit equation for the cubic bezier curve\n\t//(resultant is zero iff point lies on curve)\n\tvec2 a=vec2(l00,0.);\n\tvec2 b=vec2(l01,l11);\n\tvec2 c=vec2(l02,l12);\n\n\tmat2 bezout=mat2(det(mat2(a,b)),det(mat2(a,c)),det(mat2(a,c)),det(mat2(b,c)));\n\n\t//Also compute the gradient of the resultant\n\tvec2 bezout_grad1=(line00.xy*b.y+a.x*line31.xy);\n\tvec2 bezout_grad2=(line00.xy*c.y+a.x*line32.xy);\n\tvec2 bezout_grad3=bezout_grad2;\n\tvec2 bezout_grad4=(line01.xy*c.y+b.x*line32.xy)-(line02.xy*b.y+c.x*line31.xy);\n\n\tfloat resultant=det(bezout);\n\tvec2 resultant_grad=(bezout_grad1*bezout[1][1]+bezout[0][0]*bezout_grad4)-(bezout_grad2*bezout[0][1]+bezout[1][0]*bezout_grad3);\n\n\t//Interestingly, i'm getting a kind of parasitic line in my resultant\n\t//The resultant is zero also if point lies on line00\n\t//This is not mentioned in Sederberg's script, so i am not entirely sure\n\t//if i'm doing something wrong\n\t//Anyway, i'm just dividing it out ;)\n\tvec2 gradient=(resultant_grad*l00-resultant*line00.xy)/(l00*l00);\n\tresultant/=l00;\n\n\t//Use the gradient to compute a point that's nearer to the curve\n\tvec2 nearest_point_global=uv-(resultant*gradient)/dot(gradient,gradient);\n\n\tfloat npgl31=dot(vec3(nearest_point_global,1),line31);\n\tfloat npgl32=dot(vec3(nearest_point_global,1),line32);\n\n\t//Get parameter value of this point by solving the linear line equation\n\tfloat parameter_global=npgl31/(npgl31-npgl32);\n\tparameter_global=clamp(parameter_global,0.,1.);\n\n\t#ifdef RATIONAL\n\tvec3 clamped_point_global=((((-p0+3.*p1-3.*p2+p3)*parameter_global+(3.*p0-6.*p1+3.*p2))*parameter_global)+(-3.*p0+3.*p1))*parameter_global+p0;\n\tvec2 uv_to_cpg=uv-clamped_point_global.xy/clamped_point_global.z;\n\t#else\n\tvec2 clamped_point_global=((((-p0.xy+3.*p1.xy-3.*p2.xy+p3.xy)*parameter_global+(3.*p0.xy-6.*p1.xy+3.*p2.xy))*parameter_global)+(-3.*p0.xy+3.*p1.xy))*parameter_global+p0.xy;\n\tvec2 uv_to_cpg=uv-clamped_point_global.xy;\n\t#endif\n\n\tbezier_dis=min(bezier_dis,dot(uv_to_cpg,uv_to_cpg));\n\n\t//The above method doesn't work well when we have a double point\n\t//So we are doing a Taylor (or PadÃ©) approximation to both branches\n\n\t//The double point is the intersection of the control lines\n\t//of the linear moving line\n\tvec3 double_point=cross(line31,line32);\n\n\t//Compute the parameter values at the double point\n\t//by solving the quadratic moving line equation\n\tfloat dpl00=dot(double_point,line00);\n\tfloat dpl01=dot(double_point,line01);\n\tfloat dpl02=dot(double_point,line02);\n\n\tvec3 coeffs=vec3(dpl00-dpl01+dpl02,dpl01-2.*dpl00,dpl00);\n\tvec2 roots;\n\n\tint n=solve_quadric(coeffs,roots);\n\n\tif(n!=0){ //Acnode or crunode?\n\t\tfor(int i=0;i<2;i++){\n\t\t\t//First compute the derivatives of the parametric cubic bezier curve at\n\t\t\t//both parameter values of the double point\n\t\t\t#ifndef RATIONAL\n\t\t\tvec2 f=double_point.xy/double_point.z;\n\t\t\t#else\n\t\t\tvec2 f=((((-p0.xy+3.*p1.xy-3.*p2.xy+p3.xy)*roots[i]+(3.*p0.xy-6.*p1.xy+3.*p2.xy))*roots[i])+(-3.*p0.xy+3.*p1.xy))*roots[i]+p0.xy;\n\t\t\t#endif\n\t\t\tvec2 f1=(3.*(-p0.xy+3.*p1.xy-3.*p2.xy+p3.xy)*roots[i]+2.*(3.*p0.xy-6.*p1.xy+3.*p2.xy))*roots[i]+(-3.*p0.xy+3.*p1.xy);\n\t\t\tvec2 f2=2.*(3.*(-p0.xy+3.*p1.xy-3.*p2.xy+p3.xy)*roots[i]+(3.*p0.xy-6.*p1.xy+3.*p2.xy));\n\t\t\t#ifndef TAYLOR\n\t\t\tvec2 f3=6.*(-p0.xy+3.*p1.xy-3.*p2.xy+p3.xy);\n\t\t\t#endif\n\n\t\t\t#ifdef RATIONAL\n\t\t\tfloat q=((((-p0.z+3.*p1.z-3.*p2.z+p3.z)*roots[i]+(3.*p0.z-6.*p1.z+3.*p2.z))*roots[i])+(-3.*p0.z+3.*p1.z))*roots[i]+p0.z;\n\t\t\tfloat q1=(3.*(-p0.z+3.*p1.z-3.*p2.z+p3.z)*roots[i]+2.*(3.*p0.z-6.*p1.z+3.*p2.z))*roots[i]+(-3.*p0.z+3.*p1.z);\n\t\t\tfloat q2=2.*(3.*(-p0.z+3.*p1.z-3.*p2.z+p3.z)*roots[i]+(3.*p0.z-6.*p1.z+3.*p2.z));\n\t\t\t#ifndef TAYLOR\n\t\t\tfloat q3=6.*(-p0.z+3.*p1.z-3.*p2.z+p3.z);\n\t\t\t#endif\n\n\t\t\t//Compute Taylor coefficients (at point 0)\n\t\t\tvec2 a0=f/q;\n\t\t\tvec2 a1=(f1-f*q1/q)/q;\n\t\t\tvec2 a2=(1./2.)*(((2.*f*q1*q1)/q-(2.*f1*q1+f*q2))/q+f2)/q;\n\t\t\t#ifndef TAYLOR\n\t\t\tvec2 a3=(1./6.)*((((-6.*f*q1*q1*q1)/q+(6.*f1*q1*q1+6.*f*q1*q2))/q+(-3.*f2*q1-f*q3-3.*f1*q2))/q+f3)/q;\n\t\t\t#endif\n\n\t\t\t#else //RATIONAL\n\n\t\t\tvec2 a0=f;\n\t\t\tvec2 a1=f1;\n\t\t\tvec2 a2=(1./2.)*f2;\n\t\t\t#ifndef TAYLOR\n\t\t\tvec2 a3=(1./6.)*f3;\n\t\t\t#endif\n\n\t\t\t#endif //RATIONAL\n\n\t\t\t//PadÃ© approximation: Use Taylor coefficients to compute PadÃ© coefficients\n\t\t\t//PadÃ© is better for most curve's, but sometimes, especially for rational cubic curves\n\t\t\t//The PadÃ© approximation itself (which is a conic section)\n\t\t\t//degenerates to two lines, then Taylor approximation is the better variant\n\t\t\t#ifndef TAYLOR\n\t\t\tfloat d0_tmp=1.;\n\t\t\tfloat d1_tmp=-dot(a2,a3)/(dot(a2,a2)-dot(a1,a3));\n\t\t\tfloat d2_tmp=dot(a3,a3)/(dot(a2,a2)-dot(a1,a3));\n\n\t\t\tvec2 c0=a0;\n\t\t\tvec2 c1=a1+a0*d1_tmp;\n\t\t\tvec2 c2=a2+a1*d1_tmp+a0*d2_tmp;\n\n\t\t\t//Resubstitution: The previous calculation assumed the Taylor base point was 0 (which it isn't)\n\t\t\tfloat d2=d2_tmp;\n\t\t\tfloat d1=d1_tmp-2.*roots[i]*d2_tmp;\n\t\t\tfloat d0=d0_tmp+roots[i]*(roots[i]*d2_tmp-d1_tmp);\n\n\t\t\tvec2 qu=c2-d2*uv;\n\t\t\tvec2 li=c1-2.*roots[i]*c2-d1*uv;\n\t\t\tvec2 co=c0+roots[i]*(roots[i]*c2-c1)-d0*uv;\n\t\t\t#else\n\t\t\tvec2 qu=a2;\n\t\t\tvec2 li=a1-2.*roots[i]*a2;\n\t\t\tvec2 co=a0+roots[i]*(roots[i]*a2-a1)-uv;\n\t\t\t#endif\n\n\t\t\t//Implicitize the parametric approximation with the BÃ©zout matrix\n\t\t\t//And compute it's gradient\n\t\t\tmat2 taylor_bezout=mat2(det(mat2(qu,li)),det(mat2(qu,co)),det(mat2(qu,co)),det(mat2(li,co)));\n\t\t\tfloat taylor_resultant=det(taylor_bezout);\n\n\t\t\t#ifndef TAYLOR\n\t\t\tvec2 taylor_grad1=(vec2(-d2,0)*li.y+qu.x*vec2(0,-d1))-(vec2(-d1,0)*qu.y+li.x*vec2(0,-d2));\n\t\t\tvec2 taylor_grad2=(vec2(-d2,0)*co.y+qu.x*vec2(0,-d0))-(vec2(-d0,0)*qu.y+co.x*vec2(0,-d2));\n\t\t\tvec2 taylor_grad3=taylor_grad2;\n\t\t\tvec2 taylor_grad4=(vec2(-d1,0)*co.y+li.x*vec2(0,-d0))-(vec2(-d0,0)*li.y+co.x*vec2(0,-d1));\n\n\t\t\tvec2 taylor_grad=(taylor_grad1*taylor_bezout[1][1]+taylor_bezout[0][0]*taylor_grad4)-(taylor_grad2*taylor_bezout[0][1]+taylor_bezout[1][0]*taylor_grad3);\n\t\t\t#else\n\t\t\tvec2 taylor_grad=taylor_bezout[0][0]*(vec2(li.y,-li.x))-(vec2(qu.y,-qu.x)*taylor_bezout[0][1]+taylor_bezout[1][0]*vec2(qu.y,-qu.x));\n\t\t\t#endif\n\n\t\t\t//Now use this gradient to get a point that's more close to the curve (but on the approximation curve now)\n\t\t\tvec2 nearest_point_taylor=uv-(taylor_resultant*taylor_grad)/dot(taylor_grad,taylor_grad);\n\t\t\t\n\t\t\t#ifndef TAYLOR\n\t\t\tvec2 npt_qu=c2-d2*nearest_point_taylor;\n\t\t\tvec2 npt_li=c1-2.*roots[i]*c2-d1*nearest_point_taylor;\n\t\t\tvec2 npt_co=c0+roots[i]*(roots[i]*c2-c1)-d0*nearest_point_taylor;\n\t\t\t#else\n\t\t\tvec2 npt_qu=a2;\n\t\t\tvec2 npt_li=a1-2.*roots[i]*a2;\n\t\t\tvec2 npt_co=a0+roots[i]*(roots[i]*a2-a1)-nearest_point_taylor;\n\t\t\t#endif\n\n\t\t\t//Get the parameter value of the point computed above\n\t\t\t//I'm using curve inversion of the approximation curve\n\t\t\t//using some coefficients of the bezout matrix\n\t\t\tfloat parameter_taylor=-det(mat2(npt_qu,npt_co))/det(mat2(npt_qu,npt_li));\n\t\t\tparameter_taylor=clamp(parameter_taylor,0.,1.);\n\n\t\t\t//Compute point on original curve using the parameter at the point on the approximation curve\n\t\t\t#ifdef RATIONAL\n\t\t\tvec3 clamped_point_taylor=((((-p0+3.*p1-3.*p2+p3)*parameter_taylor+(3.*p0-6.*p1+3.*p2))*parameter_taylor)+(-3.*p0+3.*p1))*parameter_taylor+p0;\n\t\t\tvec2 uv_to_cpt=uv-clamped_point_taylor.xy/clamped_point_taylor.z;\n\t\t\t#else\n\t\t\tvec2 clamped_point_taylor=((((-p0.xy+3.*p1.xy-3.*p2.xy+p3.xy)*parameter_taylor+(3.*p0.xy-6.*p1.xy+3.*p2.xy))*parameter_taylor)+(-3.*p0.xy+3.*p1.xy))*parameter_taylor+p0.xy;\n\t\t\tvec2 uv_to_cpt=uv-clamped_point_taylor.xy;\n\t\t\t#endif\n\t\t\tbezier_dis=min(bezier_dis,dot(uv_to_cpt,uv_to_cpt));\n\t\t}\n\t}\n\n\treturn sqrt(bezier_dis);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border=2./iResolution.x;\n\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n    uv.y*=iResolution.y/iResolution.x;\n\n\tvec2 mouse=iMouse.xy/iResolution.xy;\n\tmouse-=.5;\n    mouse.y*=iResolution.y/iResolution.x;\n\n\tborder*=zoom;\n\tuv*=zoom;\n    mouse*=zoom;\n\n\tvec3 p0=vec3(-.3,-.1,1);\n\tvec3 p1=weight_p1*vec3(mouse,1);\n\t//vec3 p1=weight_p1*vec3(-.1,.2,1);\n\t//vec3 p2=weight_p2*vec3(mouse,1);\n\tvec3 p2=weight_p2*vec3(.1,-.2,1);\n\tvec3 p3=vec3(.2,.15,1);\n\n\tfloat dis=cubic_bezier_dis_approx(uv,p0,p1,p2,p3);\n\n\tfloat sgn=cubic_bezier_sign(uv,p0,p1,p2,p3);\n\n\t//iq's sd color scheme\n\tvec3 color = vec3(1.0) - sgn*vec3(0.1,0.4,0.7);\n\tcolor *= 1.0 - exp(-8.0*dis);\n\tcolor *= 0.8 + 0.2*cos(480.0*dis*sgn);\n\tcolor = mix( color, vec3(1.0), 1.0-smoothstep(0.0,0.005,dis) );\n\n\tdis=1e38;\n\n\tdis=min(dis,distance(p0.xy/p0.z,uv)-dot_size);\n\tdis=min(dis,distance(p1.xy/p1.z,uv)-dot_size);\n\tdis=min(dis,distance(p2.xy/p2.z,uv)-dot_size);\n\tdis=min(dis,distance(p3.xy/p3.z,uv)-dot_size);\n\n\tcolor=mix(point_col,color,smoothstep(0.,border,dis));\n\n\tfragColor=vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}