{
    "Shader": {
        "info": {
            "date": "1662825205",
            "description": "Another 2D refraction study.\nSURPRISING RESULT: [b]when a ray passes from outside a sphere to inside, once inside there is no total internal reflection.[/b]\nTop: With Fresnel (Schlick's approximation)\nBottom: No Fresnel, Reflectance = 0.5\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "slcfz7",
            "likes": 11,
            "name": "2d analytic refraction",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 346
        },
        "renderpass": [
            {
                "code": "\nconst float iorA = ior_air;\nconst float iorB = ior_water;\n\n#define RES    (iResolution)\n#define MINRES (min(RES.x, RES.y))\n\nconst float gMinContrib = 0.001;\nconst uint  gMaxRays    = 20u;\n\nfloat gT;\n\n\nstruct ray_t {\n    vec3  ro;\n    vec3  rd;\n    float contrib;\n    float side;           // 1 = external -1 = internal\n};\n\nstruct hit_t {\n    bool  hit;\n    vec3  pnt;\n    vec3  nrm;\n    uint  mtl;\n    float t;    // distance along ray\n};\n\nvoid rayVsSphere(in ray_t ray, in vec3 c, float r, uint mtl, inout hit_t hit) {\n    \n    vec3 ro = ray.ro - c;\n    vec3 rd = ray.rd;\n\n    float A = dot(rd, rd);\n    float B = dot(ro, rd) * 2.0;\n    float C = dot(ro, ro) - (r * r);\n    \n    vec2 roots;\n    if (!solveQuadratic(vec3(A, B, C), roots)) {\n        return;\n    }\n    \n    if (roots.y < 0.0) {\n        // both hits are before the start of the ray\n        return;\n    }\n    \n    if (roots.x > 0.0) {\n        if (roots.x > hit.t) {\n            return;\n        }\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.x;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n    \n    if (roots.y < hit.t) {\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.y;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n}\n\n#define Q_TYPE        ray_t\n#define Q_MAX_ENTRIES 10u\nQ_IMPLEMENTATION\n\nconst float gZoom  = 0.8;\n\nvec2 worldFromScreen(in vec2 p) {\n    return (p - RES.xy / 2.0) / MINRES * 2.0 / gZoom - vX.xy * 0.5;\n}\n\n// hit normal is oriented towards \"outside\"\nhit_t rayVsScene(in ray_t ray) {\n    hit_t hit;\n    hit.t   = 1e9;\n    hit.hit = false;\n    \n    rayVsSphere(ray,  v0, 1.0, 1u, hit);\n    \n    return hit;\n}\n\n//-----------------------------------------------------------\n// https://en.wikipedia.org/wiki/Schlick%27s_approximation\nfloat schlickR0(in float n1, in float n2) {\n    // same if n1 and n2 are swapped.\n    float q  = (n1 - n2) / (n1 + n2);\n    float q2 = q * q;\n    return q2;\n}\nfloat schlick(in float R0, in float cosTheta) {\n    float q  = 1.0 - cosTheta;\n    float q5 = q * q * q * q * q;\n    return R0 + ((1.0 - R0) * q5);\n}\n\n//-----------------------------------------------------------\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    vec2 xy = worldFromScreen(XY);\n    vec2 m  = worldFromScreen(iMouse.xy);\n    float ssEps = 3.0 / MINRES;\n    float ssLw  = 2.0 / MINRES;\n    \n    gT = iTime * 0.2 + pi / 2.0;\n    \n    if (length(iMouse.xy) < 40.0) {\n        m = vec2(cos(gT), sin(gT)) * 1.1 - vX.xy * 1.2;\n    }\n    \n    float c = 0.0;\n    float a = 1.0;\n    \n    ray_t r0;\n    r0.ro      = vec3(m.x, m.y, 0.0);\n    r0.rd      = vX;\n    r0.contrib = 1.0;\n    r0.side    = length(r0.ro) > 1.0 ? 1.0 : -1.0;\n    QEnqueue(r0);\n    \n    float R0 = schlickR0(iorA, iorB); \n    \n    uint rayCount = 0u;\n    \n    while(!QIsEmpty()) {\n        ray_t r = QDequeue();\n        hit_t h = rayVsScene(r);\n        rayCount += 1u;\n        \n        if (!h.hit) {\n            h.pnt = r.ro + r.rd * 1e5;\n        }\n        else {\n            bool addMoreRays = true;\n            addMoreRays = addMoreRays && (QSpaceLeft() > 2u);\n            addMoreRays = addMoreRays && (r.contrib > gMinContrib);\n            addMoreRays = addMoreRays && (rayCount < gMaxRays);\n            if (addMoreRays) {\n                vec3 hitFacingNormal = h.nrm * r.side;\n                float eta = pow(iorA / iorB, r.side);\n                ray_t rTrn;\n                rTrn.ro      = h.pnt - hitFacingNormal * 0.0001;\n                rTrn.rd      = refract(r.rd, hitFacingNormal, eta);\n                if (rTrn.rd == v0) {\n                    // total internal\n                    rTrn.contrib = 0.0;\n                }\n                else {\n                    float R = schlick(R0, dot(r.rd, -hitFacingNormal));\n                    if (r0.ro.y < 0.0) {\n                        R = 0.5;\n                    }\n                    rTrn.contrib = r.contrib * (1.0 - R);\n                    rTrn.side    = -r.side;\n                    QEnqueue(rTrn);\n                }\n                \n                ray_t rRfl;\n                rRfl.ro      = h.pnt + hitFacingNormal * 0.0001;\n                rRfl.rd      = reflect(r.rd, hitFacingNormal);\n                rRfl.side    = r.side;\n                rRfl.contrib = r.contrib - rTrn.contrib;\n                QEnqueue(rRfl);\n            }\n        }\n        \n        float d;\n        d = length(xy - h.pnt.xy);\n        c += a * r.contrib * smoothstep(ssEps, 0.0, d - ssLw * 4.0);\n        a *= 0.2 + 0.8 * smoothstep(0.0, ssLw * 7.0, d - ssLw * 7.0);\n        d = sdSegment(xy, r.ro.xy, h.pnt.xy);\n        c += a * r.contrib * smoothstep(ssEps, 0.0, d - ssLw * 4.0);\n        a *= 0.2 + 0.8 * smoothstep(0.0, ssLw * 7.0, d - ssLw * 7.0);\n    }\n    \n    RGBA.rgb = vec3(c);\n    \n    const vec3 sceneColor = vec3(0.1, 0.5, 0.7) * 0.04;\n    \n    RGBA.rgb += sceneColor * smoothstep(ssEps, 0.0, abs(length(xy) - 1.0) - ssLw);\n    RGBA.rgb += sceneColor * smoothstep(ssEps, 0.0, abs(xy.y) - ssLw) * smoothstep(0.0, ssEps, length(xy) - 1.0);\n    \n    // boost darker colors\n    RGBA.rgb = pow(RGBA.rgb, vec3(0.45));\n    RGBA.a = 1.0;\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec3  v0 = vec3(0.0);\nconst vec3  v1 = vec3(1.0);\nconst vec3  vX = vec3(1.0, 0.0, 0.0);\nconst vec3  vY = vec3(0.0, 1.0, 0.0);\nconst vec3  vZ = vec3(0.0, 0.0, 1.0);\nconst float pi = 3.14159265359;\n\n\n//--------------------------------------------------------------------------------\nconst float ior_air     = 1.0003;\nconst float ior_ice     = 1.309;\nconst float ior_water   = 1.333;\nconst float ior_quartz  = 1.46;\nconst float ior_diamond = 2.42;\n\n\n//--------------------------------------------------------------------------------\n// #define Q_TYPE and Q_MAX_ENTRIES,\n// then put Q_IMPLEMENMTATION.\n// this is a basic ringbuffer.\n// NO ERROR CHECKING\n// orion elenzil 2022.\n//\n// Usage:\n// #define Q_TYPE        <your type>\n// #define Q_MAX_ENTRIES <size of rungbuffer you want. unsigned int>\n// Q_IMPLEMENTATION\n#define Q_IMPLEMENTATION                           \\\nconst uint gQCapacity = Q_MAX_ENTRIES;             \\\nconst uint gQNumSlots = gQCapacity + 1u;           \\\nQ_TYPE gQ[gQNumSlots];                             \\\nuint gQHead = 0u;                                  \\\nuint gQTail = 0u;                                  \\\n                                                   \\\nuint QCount() {                                    \\\n\tif (gQHead >= gQTail) {                        \\\n\t\treturn gQHead - gQTail;                    \\\n\t}                                              \\\n\telse {                                         \\\n\t\treturn gQNumSlots - (gQTail - gQHead);     \\\n\t}                                              \\\n}                                                  \\\n                                                   \\\nuint QSpaceLeft() {                                \\\n\treturn gQCapacity - QCount();                  \\\n}                                                  \\\n                                                   \\\nbool QIsFull() {                                   \\\n\treturn QSpaceLeft() == 0u;                     \\\n}                                                  \\\n                                                   \\\nbool QIsEmpty() {                                  \\\n\treturn QCount() == 0u;                         \\\n}                                                  \\\n                                                   \\\nuint QEnqueueIndex() {                             \\\n\tgQHead = (gQHead + 1u) % gQNumSlots;           \\\n    return gQHead;                                 \\\n}                                                  \\\n                                                   \\\nuint QDequeueIndex() {                             \\\n\tgQTail = (gQTail + 1u) % gQNumSlots;           \\\n    return gQTail;                                 \\\n}                                                  \\\n                                                   \\\nvoid QEnqueue(Q_TYPE item) {                       \\\n\tgQ[QEnqueueIndex()] = item;                    \\\n}                                                  \\\n                                                   \\\nQ_TYPE QDequeue() {                                \\\n\treturn gQ[QDequeueIndex()];                    \\\n}\n////////////////////////////////////////////////////\n\n\n//--------------------------------------------------------------------------------\n\n\n// returns false if there are no real roots.\n// returns true if there are one or two real roots.\n// roots.x <= roots.y.\nbool solveQuadratic(in vec3 coeffs, out vec2 roots) {\n    const uint A = 0u;\n    const uint B = 1u;\n    const uint C = 2u;\n    \n    // (-B +- sqrt(BB - 4AC)) / 2A\n    \n    float disc = (coeffs[B] * coeffs[B]) - (4.0 * coeffs[A] * coeffs[C]);\n    \n    if (disc < 0.0) {\n        return false;\n    }\n    \n    float sqrt_disc = sqrt(disc);\n    \n    roots.x = (-coeffs[B] - sqrt_disc) / (2.0 * coeffs[A]);\n    roots.y = (-coeffs[B] + sqrt_disc) / (2.0 * coeffs[A]);\n    \n    if (roots.y < roots.x) {\n        roots.xy = roots.yx;\n    }\n    \n    return true;\n}\n\n\n//--------------------------------------------------------------------------------\n// From IQ - https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}