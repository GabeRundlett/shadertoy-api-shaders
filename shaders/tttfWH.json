{
    "Shader": {
        "info": {
            "date": "1612746003",
            "description": "Somewhat accurate simulation of the light of a star/laser travelling through an atmosphere. Inspired by https://youtu.be/Xm3wOOuMfrw",
            "flags": 32,
            "hasliked": 0,
            "id": "tttfWH",
            "likes": 6,
            "name": "Star/Laser Scintillation Sim",
            "published": 3,
            "tags": [
                "star",
                "laser",
                "atmosphere",
                "scintillation"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 438
        },
        "renderpass": [
            {
                "code": "// ##### Star/Laser Scintillation Sim #####\n// Made by Zi7ar21 on February 7th, 2021\n// Updated February 7th, 2021 18:00 Mountain Time\n\n// If you found this anywhere other than Shadertoy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/tl3BR4\n\n/* This Shader contains a simulation of the light from a star/laser (or any other small point light)\npropagating through a medium of non-homogeneous refraction. It should be somewhat accurate, the only\nthing that could be improved is the simulated medium. Currently, it uses 3D fbm noise and shifts the\nray direction based on the value of the noise at any given point. If you have a better model you can\nreplace the fbm function in Buffer A.*/\n\n// Common contains Settings and Other Functions.\n// Buffer A contains the Ray-Marched Simulation.\n// Buffer B contains Image Export.\n\n// Inspired by \"Scintillation Modelling for Martian Laser Communication\":\n// https://youtu.be/Xm3wOOuMfrw\n\n// Display the Rendered Image on the Screen\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ##### Settings and Other Functions #####\n\n// Tile-Rendering n*n Tiles\n// This prevents WebGL Time-Out.\n#define tiles 2U\n\n// ### Camera Parameters ###\n#define camfov 0.2\n#define campos vec3(0.0, 0.0, -16.0)\n\n// ### Ray-Marching Parameters ###\n#define maxmarches 8192U\n#define stepsize 0.2\n\n// ### Simulation Parameters ###\n// FBM Noise Octaves\n#define octaves 8U\n// Maximum Distance from the Z plane\n#define scenesize campos.z+0.1\n// Maximum Distance from a straight path to the source\n#define transmissionlanesize 2.0\n\n// #### Constants and Other Functions ####\n// Pi (Octuple-Precision Floating-Point Future-Proof)\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n#define twopi pi*2.0\n\n// Hash: https://www.shadertoy.com/view/4djSRW\n/*vec3 hash(vec3 pos){\n\tpos =  fract(pos*vec3(0.1031, 0.1030, 0.0973));\n    pos += dot(pos, pos.yxz+33.33);\n    return fract((pos.xxy+pos.yxx)*pos.zyx);\n}\n\n// Gradient Noise: https://iquilezles.org/articles/gradientnoise\nfloat noise(vec3 x){\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 ga = hash(p+vec3(0.0,0.0,0.0));\n    vec3 gb = hash(p+vec3(1.0,0.0,0.0));\n    vec3 gc = hash(p+vec3(0.0,1.0,0.0));\n    vec3 gd = hash(p+vec3(1.0,1.0,0.0));\n    vec3 ge = hash(p+vec3(0.0,0.0,1.0));\n    vec3 gf = hash(p+vec3(1.0,0.0,1.0));\n    vec3 gg = hash(p+vec3(0.0,1.0,1.0));\n    vec3 gh = hash(p+vec3(1.0,1.0,1.0));\n    float va = dot(ga, w-vec3(0.0,0.0,0.0));\n    float vb = dot(gb, w-vec3(1.0,0.0,0.0));\n    float vc = dot(gc, w-vec3(0.0,1.0,0.0));\n    float vd = dot(gd, w-vec3(1.0,1.0,0.0));\n    float ve = dot(ge, w-vec3(0.0,0.0,1.0));\n    float vf = dot(gf, w-vec3(1.0,0.0,1.0));\n    float vg = dot(gg, w-vec3(0.0,1.0,1.0));\n    float vh = dot(gh, w-vec3(1.0,1.0,1.0));\n    return va+\n    u.x*(vb-va)+\n    u.y*(vc-va)+\n    u.z*(ve-va)+\n    u.x*u.y*(va-vb-vc+vd)+\n    u.y*u.z*(va-vc-ve+vg)+\n    u.z*u.x*(va-vb-ve+vf)+\n    u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}*/\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x+fragCoord.y*iResolution.x);\n\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state >> ((state >> 28u)+4u)) ^ state)*277803737u;\n    ns = (word >> 22u) ^ word;\n}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\n//vec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random, also from Michael0884: https://www.shadertoy.com/view/WttyWX\n/*float ErfInv(float x){\n   float lnx = log((1.0-x)*(1.0+x));\n   float tt1 = 4.3308+0.5*lnx;\n   float tt2 = 6.8027*lnx;\n   return(sign(x)*sqrt(-tt1+sqrt(tt1*tt1-tt2)));\n}*/\n\n//float nrand(){return ErfInv(rand()*2.0-1.0);}\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ##### Ray-Marched Simulation #####\n\n// 3D FBM Noise: https://www.shadertoy.com/view/3dSBRh\nvec3 fbm3(vec3 x){\n\tvec3 v = vec3(0.0);\n\tfloat a = 0.5;\n\tfor(uint i = 0U; i < octaves; i++){\n\t\tv += a*texture(iChannel1, x+0.5).rgb;\n\t\tx *= 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn 2.0*(v-(0.5-1.0/pow(2.0, float(octaves+1U))));\n}\n\n// Star/Laser \"Signal\" Function\nfloat signal(vec2 coord){\n    return max(0.0, 1.0-length(coord));\n}\n\n// Ray-Marching\nvec3 raymarch(vec3 raydir, vec3 rayori){\n    // Start our ray (moved slightly forward for dithering)\n    vec3 raypos = rayori+(raydir*rand()*stepsize);\n\n    for(uint i = 0U; i < maxmarches; i++){\n        // Check if we reached our Source\n        if(raypos.z > 0.0){return vec3(signal(raypos.xy));}\n\n        // Check if the Ray is Outside an Acceptable Position\n        if(abs(raypos.z) < scenesize || length(raypos.xy) > transmissionlanesize){break;}\n\n        // \"Distort\" the Ray\n        raydir = normalize(raydir+(fbm3(raypos*2.0)*0.025));\n\n        // March the Ray\n        raypos += raydir*stepsize;\n    }\n\n    // If the ray reached an unacceptable position or never hit anything, output 0.0\n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Progressive Rendering\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0){oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}\n    fragColor = oldFragColor;\n\n    // Tile-Rendering Function\n    uint index = uint(fragCoord.x/iResolution.x*float(tiles))\n               + uint(fragCoord.y/iResolution.y*float(tiles))*tiles;\n    if(uint(iFrame)-(tiles*tiles*(uint(iFrame)/(tiles*tiles))) != index){return;}\n\n    // Initialize RNG\n    INIT_RNG;\n\n    // Screen UV Coordinates Centered on [0.0, 0.0]\n    vec2 uv = 2.0*((fragCoord+nrand2(0.5, vec2(0.0)))-0.5*iResolution.xy)/max(iResolution.x, iResolution.x);\n\n    // Camera-World Coordinates (+Z Forward)\n    mat3 rotmat = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    vec3 raydir = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Ray-March the Image and Output the Results\n    fragColor += vec4(raymarch(raydir, campos), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ##### Image Export #####\n\n/* Look at the bottom of the editor, there is a little Image icon. If\nyou click it, then Shadertoy will save a 32-Bit-Per-Channel Floating Point\nOpenEXR Image. It is more optimal for Image editing than right-clicking\nthe canvas and pressing copy/save image (as).*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n    // No Gamma-Correction this time... In GIMP, it is automatically done.\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}