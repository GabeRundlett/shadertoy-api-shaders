{
    "Shader": {
        "info": {
            "date": "1498469736",
            "description": "I got this strange sun while messing with this simplex noise and fbm.\nI'm sorry I can't remember who I took it from.\nLights uses the blackbody algorithm with distance as parameter.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdXBDf",
            "likes": 5,
            "name": "Simplex Sun",
            "published": 3,
            "tags": [
                "raymarching",
                "sun",
                "3dnoise",
                "simplex"
            ],
            "usePreview": 0,
            "username": "Palliaci",
            "viewed": 769
        },
        "renderpass": [
            {
                "code": "\n#define I_MAX\t130\n#define E\t\t0.002\nvec2\tuv;\nfloat\tphase;\n\nvec3\tcamera(vec2 uv);\nvec3\tblackbody(float Temp);\nfloat\tsimplex3d(vec3 p);\nfloat\tsimplex3d_fractal(vec3 m);\nvec3\trandom3(vec3 c);\nvec2\thash( vec2 p );\nfloat\tnoise( in vec2 p );\nmat3\tRot3X( float a );\nmat3\tRot3Y( float a );\n\n\nfloat sdTriPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat\tscene( vec3 p ) {\n    float\tmind = 1e5;\n    float plen = length(p);\n    if (plen-.125 < .0)\n        return 1e5;\n    mind = plen - .25 * (phase-.125);\n//\tmind = sdTriPrism( p, vec2(.2, .8) );\n    //mind = min(length(simplex3d_fractal(vec3(mind, .2 * iTime, p.y)) - .1), mind);\n    mind = min(length(simplex3d_fractal(vec3(mind, p.z, p.y)) - .1), mind);\n    /*\n\tmind = min(length(noise(vec2(iTime*.25, 1.*p.y*mind)) -.5), mind);\n    mind = min(length(noise(vec2(iTime*.25, 2.*p.x*mind)) -.5), mind);\n    mind = min(length(noise(vec2(iTime*.25, 2.*p.z*mind)) -.5), mind);\n    */\n/*\n   // mind = min(length(noise(vec2(mind, p.y))) -.1, mind);\n    mind = min(length(noise(vec2(mind, .2 * iTime))) -.1, mind);\n    mind = min(length(noise(vec2(p.y*2., mind))) -.1, mind);\n*/\n //   mind = min(length(texture(iChannel0, uv)) -uv, mind);\n    //mind = length(noise(vec2(iTime*.25, 2.*p.y)) -.5*mind);\n//    mind = mod(mind, 2.);\n    return( max(mind, plen - 1.2) );\n}\n\nvec4\tmarch( vec3 pos, vec3 dir ) {\n    vec2\tdist = vec2( 0.0 );\n    vec3\tp = vec3( 0.0 );\n    vec4\tstep = vec4( 0.0 );\n    for ( int i = -1; i < I_MAX; ++i )\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = scene( p );\n        dist.y += dist.x;\n        if ( dist.x < E || dist.y > 4. )\n           break;\n        step.x++;\n    }\n    step.y = dist.x;\n    step.w = dist.y;\n    return ( step );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    uv  = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    float\tt = iTime*.5;\n    phase = 1. + sin(iTime);\n    float \tst = sin(t);\n    float\tct = cos(t);\n\tvec3\tdir = camera( uv );\n    vec4\tcol;\n    vec3\tpos = vec3( 0., 0., -.5);\n\n    //pos.z += 1.8*(.5*-st);\n    pos.x -= 2.5*st;\n    pos.y -= 2.5*-ct;\n    dir *= Rot3X( ct*1. ) * Rot3Y( st*1. );\n    vec4 inter = ( march( pos, dir ) );\n\n\tcol.xyz = blackbody(inter.x*200./inter.w);\n   \tfragColor = col;\n}\n\n\n\n\n\n\nvec3\tcamera(vec2 uv) {\n    float   fov = \t\t 1.;\n\tvec3    forw  = vec3( 0.0, 0.0, 1.0 );\n\tvec3    right = vec3( 1.0, 0.0, 0.0) ;\n\tvec3    up    = vec3( 0.0, 1.0, 0.0) ;\n\n    return ( normalize( ( uv.x - 1. ) * right\n                        + ( uv.y - 0.5 ) * up\n                        + fov * forw ) );\n}\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\nmat3\tRot3X( float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat3( 1, 0, 0,\n                 0, c,-s,\n                 0, s, c );\n}\nmat3\tRot3Y( float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat3( c, 0, s,\n                 0, 1, 0,\n                 -s, 0, c );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}