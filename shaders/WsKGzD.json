{
    "Shader": {
        "info": {
            "date": "1570044600",
            "description": "Again experiments with particles and neighbors. Made on RTX 2080 Ti at 100 FPS windowed, so might be slow on your computer.",
            "flags": 32,
            "hasliked": 0,
            "id": "WsKGzD",
            "likes": 4,
            "name": "Again With The Particles",
            "published": 3,
            "tags": [
                "particles"
            ],
            "usePreview": 0,
            "username": "emh",
            "viewed": 698
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec4 m = iMouse / iResolution.xxxx;\n    \n    if(m.z > 0.0) {\n        //uv = 0.1 * (fragCoord + iMouse.xy) / iResolution.xy;\n        float magAmt = 4.0;\n        vec2 res = iResolution.xy;\n        uv = uv/magAmt-iMouse.xy/res*(1.-magAmt)/magAmt;\n        //uv *= 0.25;\n    }\n    \n    vec4 ppIn = texture(iChannel2, uv);\n    vec3 col = ppIn.rgb;\n    /*\n    vec2 pp = ppIn.xy;\n    vec4 xyzs = texture(iChannel0, pp);\n    float d = 0.0; //distance(uv, xyzs.xy);\n    \n    const int k = 1;\n    \n    for (int dx = -k; dx <= k; dx += 1) {\n        for (int dy = -k; dy <= k; dy += 1) {\n            // Neighborhood search\n            vec2 ppuv2 = fract(uv + vec2(dx, dy) / iResolution.xy);\n            vec2 pp2 = texture(iChannel1, ppuv2).xy;\n            vec2 xy2 = texture(iChannel0, pp2).xy;\n            float nd2 = distance(xy2, uv);\n            //if (nd2 < 0.1 && pp.x * iResolution.y + pp.y < pp2.x * iResolution.y + pp2.y) {\n            if (pp.x * iResolution.y + pp.y < pp2.x * iResolution.y + pp2.y) {\n            \tpp = pp2;\n                d += nd2;\n            }\n        }\n    }\n    \n    if (d == 0.0) {\n        d = 1.0;\n    }\n    \n    //float d = distance(uv, xyzs.xy);\n    vec3 col = vec3(0.0);\n    if (d > xyzs.z) {\n        d = 0.0;\n        col = vec3(0.0);\n    } else {\n        d *= 100.0;\n        d /= xyzs.z;\n        //d *= rand(pp);\n        //col = vec3(pp, rand(pp)) * 0.25 / d;\n        col = vec3(0.1 / d);\n    }\n\t*/\n    \n    //col = vec3(ppIn.z, ppIn.z * ppIn.w, ppIn.w);\n    //col = vec3(pp, rand(pp)) * ppIn.z * ppIn.w;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Ideas:\n// Nearest neighbour network graph / grid search\n// Sorting (bitonic or merge)\n// Linear tracking\n// Small kXk Buckets: 8x8\n// Particle properties:\n// 1: previous (x y z size)\n// 2: x y z size\n// 3: nearestUpLeft nearestUpRight nearestDownLeft nearestDownRight\n// 4:\n\nconst float E = 1.0e-10;\n\nvec3 getSpring(vec3 particle, vec3 pos) {\n    vec3 dv = particle - pos;\n    float l = length(dv);\n    float k = 0.1;\n    float s = sign(k - l);\n    vec3 dvn = dv / (E + l);\n    l = min(abs(k - l), l);\n    \n    float SPRING_COEFF = 1.0e2;\n    float SPRING_LENGTH = 0.001;\n    float X = abs(SPRING_LENGTH - l);\n    float F_spring = SPRING_COEFF * X;\n    \n    if (l >= SPRING_LENGTH) {\n    \tdv = dvn * SPRING_LENGTH;\n    }\n    \n    \n    vec3 a = vec3(0.0);\n    \n    // Spring force\n    a += -dv * F_spring;\n    \n    return a;\n}\n\nvec3 getGravity(vec3 particle, vec3 pos) {\n    // Anti-gravity\n    float MIN_DIST = 0.01;\n    float G = 5.0e-1;\n    float m = 1.0 / (MIN_DIST * MIN_DIST);\n    vec3 dvg = particle - pos;\n    float l2 = length(dvg);\n    vec3 dvgn = dvg / l2;\n    \n    vec3 a = G * dvg / (MIN_DIST + m * l2 * l2);\n    \n    return a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    if (iFrame < 60) {\n        \n        // Initialize particle positions\n        \n        vec3 xyz = vec3(0.0);\n        if (isParticleP1(fragCoord)) {\n        \txyz = vec3(rand(uv), rand(1.24513 * uv), rand(1.13325 * uv));\n            xyz = vec3(uv, rand(uv));\n            //xyz = vec3(uv, 0.0);\n        } else {\n            xyz = texture(iChannel0, uv - vec2(1.0, 0.0) / iResolution.xy).xyz;\n            xyz += 0.012153 * vec3(randNeg(uv), randNeg(-uv), randNeg(1.13325 * uv));\n        }\n        \n\t\tfragColor = vec4(xyz, 1.0);\n    } else {\n        \n        // Update particle positions\n        \n        vec3 prevXYZ = vec3(0.0);\n        vec3 nextXYZ = vec3(0.0);\n        vec2 nextUV = vec2(0.0);\n        if (isParticleP1(fragCoord)) {\n    \t\tprevXYZ = texture(iChannel0, uv - vec2(0.0, 0.0) / iResolution.xy).xyz;\n            nextXYZ = texture(iChannel0, uv + vec2(1.0, 0.0) / iResolution.xy).xyz;\n            nextUV = uv + vec2(1.0, 0.0) / iResolution.xy;\n        } else {\n            prevXYZ = texture(iChannel0, uv - vec2(1.0, 0.0) / iResolution.xy).xyz;\n            nextXYZ = texture(iChannel0, uv + vec2(0.0, 0.0) / iResolution.xy).xyz;\n            nextUV = uv + vec2(0.0, 0.0) / iResolution.xy;\n            //xyz = texture(iChannel0, uv - vec2(1.0, 0.0) / iResolution.xy).xyz;\n        }\n        \n        vec3 vel = nextXYZ - prevXYZ;\n        \n        // Update velocity\n        vec2 ppuv = nextXYZ.xy;\n        \n        const int k2 = 4;\n        for (int dx = -k2; dx <= 0; dx += 1) {\n        \tfor (int dy = 0; dy <= 0; dy += 1) {\n        //const int k2 = 1;\n        //for (int dx = -k2; dx <= k2; dx += 1) {\n        //\tfor (int dy = -k2; dy <= k2; dy += 1) {\n                {\n                    int s = 1; //int(sign(uv.x - 0.4));\n                    vec2 ppuv2 = nextUV + vec2(2 * dx * s, dy) / iResolution.xy;\n                    //vec2 pp = texture(iChannel1, ppuv2).xy;\n                    vec4 pxyzs = texture(iChannel0, ppuv2);\n                    vec3 diff = nextXYZ - pxyzs.xyz;\n                    float d = length(diff.xyz);\n\n                    const float ff = 1.0;\n                    if (d > 0.0 && d < 2.0) {\n                        //if ((dx <= -1 && dy == 0) || (dx == -1 && dy == -1)) {\n                        if ((dx <= -1 && dy == 0)) {\n                        //if (abs(dx) + abs(dy) == 1) {\n                            //continue;\n                            vel.xyz += getSpring(nextXYZ.xyz, pxyzs.xyz) * ff;\n                        }\n                        //vel.xy += getGravity(nextXYZ.xy, pxyzs.xy) * ff * 0.1;\n                    }\n\n            \t}\n            }\n        }\n        \n        const int k = 2;\n        for (int dx = -k; dx <= k; dx += 1) {\n        \tfor (int dy = -k; dy <= k; dy += 1) {\n                {\n                    vec2 ppuv2 = ppuv + vec2(2 * dx, dy) / iResolution.xy;\n                    vec2 pp = texture(iChannel1, ppuv2).xy;\n                    vec4 pxyzs = texture(iChannel0, pp);\n                    vec3 diff = nextXYZ - pxyzs.xyz;\n                    float d = length(diff.xyz);\n\n                    if (d > 0.0 && d < 2.0) {\n                        d += 2.0;\n                        //d += 0.1;\n                        //vel += 0.1 * diff / (d * d * d);\n                        vel += 3.0 * 0.0025 * diff / (d * d * d);\n                        //d -= 2.0;\n                        //vel += 0.0005 * diff / (d * d * d);\n                    }\n                }\n\t\t\t\t\n            }\n        }\n        \n        vel *= 0.4;\n        //vel *= 0.999;\n        \n        const float limitForVel = 0.001;\n        if (length(vel) >= limitForVel) {\n            //vel = normalize(vel) * limitForVel;\n        }\n        \n        prevXYZ = nextXYZ;\n        nextXYZ += vel;\n        \n        //if (abs(uv.x - 0.5) <= 4.0 * 0.5 / iResolution.x) {\n        if (uv.x <= 4.0 * 0.5 / iResolution.x) {\n            float t = iTime * 1.0;\n            //prevXYZ = vec3(0.5 + 0.5 * vec2(cos(t), sin(t)), 0.0);\n            //vec2 origo = texture(iChannel0, vec2(0.0, 0.5)).xy;\n            //prevXYZ = vec3(origo, 0.0);\n            prevXYZ = vec3(vec2(0.5, 0.5), prevXYZ.z);\n            //prevXYZ = (vec3(0.5 + 0.5 * vec2(cos(t), sin(t)), 0.0));\n            nextXYZ = prevXYZ;\n        }\n        \n        if (nextXYZ.x <= 0.0 || nextXYZ.x >= 1.0) {\n        \tnextXYZ.x -= vel.x * 2.0;\n        }\n        if (nextXYZ.y <= 0.0 || nextXYZ.y >= 1.0) {\n        \tnextXYZ.y -= vel.y * 2.0;\n        }\n        if (nextXYZ.z <= 0.0 || nextXYZ.z >= 1.0) {\n        \tnextXYZ.z -= vel.z * 2.0;\n        }\n        \n        if (isParticleP1(fragCoord)) {\n        \tfragColor = vec4(prevXYZ, 1.0);\n        } else {\n            fragColor = vec4(nextXYZ, 1.0);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat randNeg(vec2 n) {\n    return (rand(n) - 0.5) * 2.0;\n}\n\nbool isParticleP1(vec2 fragCoord) {\n    return int(fragCoord.x - 0.5) % 2 == 0;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 ppuv = uv;\n    if (!isParticleP1(fragCoord)) {\n        ppuv -= vec2(1.0, 0.0) / iResolution.xy;\n    }\n    \n    vec4 ppIn = texture(iChannel1, ppuv);\n    vec2 pp = ppIn.xy;\n    vec4 pxyzs = texture(iChannel0, pp);\n    vec2 pxy = pxyzs.xy;\n    \n    //vec3 uvz = vec3(uv, (pxyz.z + 0.5) / 2.0);\n    \n    float d = distance(uv, pxy);\n    \n    vec2 psum = vec2(0.0);\n    int count = 0;\n    \n    float seed = rand(uv + vec2(iTime, -iTime));\n    const int k = 2;\n    for (int dx = -k; dx <= k; dx += 1) {\n        for (int dy = -k; dy <= k; dy += 1) {\n            // Random search\n            vec2 nuv = fract(ppuv + seed + vec2(2 * dx, dy) / iResolution.xy);\n            vec2 xy = texture(iChannel0, nuv).xy;\n            float nd = distance(xy, uv);\n            if (nd < d) {\n            \tpp = nuv;\n                d = nd;\n            }\n        }\n    }\n    \n    const float ppow = 0.85;\n    const float pmul = 0.000025 * 0.025;\n    const int k2 = 8;\n    for (int dx = -k2; dx <= k2; dx += 1) {\n        for (int dy = -k2; dy <= k2; dy += 1) {\n            if ((dx * dx + dy * dy) > k2 * k2) {\n                continue;\n            }\n            // Neighborhood search\n            vec2 ppuv2 = fract(ppuv + vec2(2 * dx, dy) / iResolution.xy);\n            vec2 pp2 = texture(iChannel1, ppuv2).xy;\n            vec2 xy2 = texture(iChannel0, pp2).xy;\n            float nd2 = distance(xy2, uv);\n            if (nd2 < d) {\n            \tpp = pp2;\n                d = nd2;\n            }\n            //if (nd2 < distance(uv, ppuv2)) {\n            /*\n            float maxnd2 = float(k2) / iResolution.x;\n            if (nd2 > 0.0 && nd2 < 2.0 * maxnd2) {\n            \t//psum += 1.0 / pow((maxnd2 - nd2), ppow);\n                //psum += 1.0 / pow((maxnd2 - nd2), ppow);\n                //psum = max(psum, 1.0 / pow(nd2, ppow) * pp2);\n                psum = max(psum, 50.0 / pow(nd2, ppow) * pp2);\n                //psum += 1.0 / pow(1.0 + (maxnd2 - nd2), 2.0);\n                //psum += (distance(uv, ppuv2) - nd2); // * pp2;\n            \tcount++;\n            }\n\t\t\t*/\n        }\n    }\n    if (count > 0) {\n    \t//psum /= float(count);\n    }\n   \n    //psum = 1.0 - psum;\n    //psum *= 1000.0;\n    //psum *= 0.05;\n    //psum *= pow(pmul, ppow);\n    \n    //fragColor = vec4(pp, 0.6 * ppIn.zw + 1.0 * psum);\n    fragColor = vec4(pp, vec2(0.0)); //0.95 * ppIn.zw + psum);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 ppuv = uv;\n    if (!isParticleP1(fragCoord)) {\n        ppuv -= vec2(1.0, 0.0) / iResolution.xy;\n    }\n    \n    vec4 ppIn = texture(iChannel1, ppuv);\n    vec2 pp = ppIn.xy;\n    vec4 pxyzs = texture(iChannel0, pp);\n    vec2 pxy = pxyzs.xy;\n    \n    //vec3 uvz = vec3(uv, (pxyz.z + 0.5) / 2.0);\n    \n    float d = distance(uv, pxy);\n    \n    vec3 psum = vec3(0.0);\n    int count = 0;\n    \n    float seed = rand(uv + vec2(iTime, -iTime));\n    const int k = 2;\n    for (int dx = -k; dx <= k; dx += 1) {\n        for (int dy = -k; dy <= k; dy += 1) {\n            // Random search\n            vec2 nuv = fract(ppuv + seed + vec2(2 * dx, dy) / iResolution.xy);\n            vec2 xy = texture(iChannel0, nuv).xy;\n            float nd = distance(xy, uv);\n            if (nd < d) {\n            \tpp = nuv;\n                d = nd;\n            }\n        }\n    }\n    \n    const float ppow = 0.85;\n    const float pmul = 0.000025 * 0.025; // * 10000.0;\n    const int k2 = 8;\n    float zmax = 0.0;\n    for (int dx = -k2; dx <= k2; dx += 1) {\n        for (int dy = -k2; dy <= k2; dy += 1) {\n            if ((dx * dx + dy * dy) > k2 * k2) {\n                continue;\n            }\n            // Neighborhood search\n            vec2 ppuv2 = fract(ppuv + vec2(2 * dx, dy) / iResolution.xy);\n            vec2 pp2 = texture(iChannel1, ppuv2).xy;\n            vec3 xyz = texture(iChannel0, pp2).xyz;\n            vec2 xy2 = xyz.xy;\n            //float nd2 = distance(xy2, uv) + 8.0 * pow(xyz.z, 1.0);\n            float nd2 = distance(xy2, uv);\n            //float nd2 = distance(xyz, vec3(uv, 1.0)) * 1.5;\n            if (nd2 < d) {\n            \tpp = pp2;\n                d = nd2;\n            }\n            //if (nd2 < distance(uv, ppuv2)) {\n            float maxnd2 = float(k2) / iResolution.x;\n            if (nd2 > 0.0 && nd2 < 2.0 * maxnd2) {\n            \t//psum += 1.0 / pow((maxnd2 - nd2), ppow);\n                //psum += 1.0 / pow((maxnd2 - nd2), ppow);\n                //psum = max(psum, 1.0 / pow(nd2, ppow) * pp2);\n                psum = max(psum, 100.0 / pow(nd2, ppow) * vec3(pp2.y, rand(pp2), pp2.x));\n                zmax = max(zmax, xyz.z);\n                //psum = max(psum, 100.0 / pow(nd2, ppow) * vec3(pp2.y, xyz.z, pp2.x));\n                //psum += 1.0 / pow(1.0 + (maxnd2 - nd2), 2.0);\n                //psum += (distance(uv, ppuv2) - nd2); // * pp2;\n            \tcount++;\n            }\n        }\n    }\n    if (count > 0) {\n    \t//psum /= float(count);\n    }\n   \n    //psum = 1.0 - psum;\n    //psum *= 1000.0;\n    //psum *= 0.05;\n    psum *= pow(pmul, ppow);\n    float zk = 10.0;\n    //psum *= 2.0 * pow(zmax * zk, 0.75) / zk;\n    \n    //fragColor = vec4(pp, 0.6 * ppIn.zw + 1.0 * psum);\n    vec3 prev = texture(iChannel2, uv).rgb;\n    fragColor = vec4(0.93 * prev + psum, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}