{
    "Shader": {
        "info": {
            "date": "1672173581",
            "description": "My entry for the animation compo of the Zenta 2022 demoparty",
            "flags": 0,
            "hasliked": 0,
            "id": "Dtf3zX",
            "likes": 8,
            "name": "Hammertime [zenta2022]",
            "published": 3,
            "tags": [
                "raymarching",
                "loop",
                "toy"
            ],
            "usePreview": 0,
            "username": "robin_be",
            "viewed": 153
        },
        "renderpass": [
            {
                "code": "/*\nMy entry for the animation compo of the Zenta 2022 demoparty\nContains code sourced from various shaders from various people\nand articles by iq.\n\nhacked and butchered together not last-minute but still pretty\nclose to the deadline (and there's a party to enjoy instead of\nspending that time coding very nervously)\n*/\n\n#define shadertoy 1\n#if shadertoy == 0\n#define debugmov 0\n#define iTime fpar[0].x\nlayout (location=0) uniform vec4 fpar[2];\nlayout (location=2) uniform vec4 debug[2]; //noexport\n#else\n#define debugmov 0\n#endif\n#define PI 3.14159265359\n#define HALFPI 1.5707963268\n#define MAT_GROUND 1\n#define MAT_RED 2\n#define MAT_WOOD 3\n#define MAT_BLUE 4\n#define MAT_YELLOW 5\n#define MAT_GREEN 6\nint i;\nvec3 gHitPosition = vec3(0);\nfloat gTimeMod;\n\nmat2 rot2(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\nfloat iq(float t){return t*t;} // easing_in_quad\nfloat oq(float t){return -1.*t*(t-2.);} // easing_out_quad\nfloat ioq(float t){t=t*2.;if(t<1.){return .5*t*t*t*t;}t-=2.;return -.5*(t*t*t*t-2.);} // easing_in_out_quart\nfloat ioc(float t){t=t*2.;if(t<1.){return .5*t*t*t;}t-=2.;return .5*(t*t*t+2.);} // easing_in_out_cubic\nfloat ob(float t){ // easing_out_bounce\n\tif(t<0.36363636){return 7.5625*t*t;}\n\tif(t<.72727273){t-=.54545454;return 7.5625f*t*t+.75;}\n\tif(t<.90909091){t-=.81818182;return 7.5625*t*t+.9375;}\n\tt-=.9545456;return 7.5625*t*t+.984375;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat ss(float a, float b, float k)\n{\n\tfloat h = clamp(0.5 - 0.5*(b+a)/k, 0., 1.);\n\treturn mix(b, -a, h) + k*h*(1.-h);\n}\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCylinder(vec3 p, float h, float r)\n{\n\tvec2 d = abs(vec2(length(p.xy),p.z)) - vec2(r,h);\n\treturn min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\nfloat peg(vec3 p, float offset, float downfrom)\n{\n\tp.x -= offset;\n\tif (gTimeMod > downfrom) {\n\t\tif (gTimeMod > downfrom + .2) {\n\t\t\tp.z -= 1.;\n\t\t} else {\n\t\t\tfloat t = mod(gTimeMod, .5) / .2;\n\t\t\tt = t < .4 ? 0. : (t - .4) / .6;\n\t\t\tvec3 q = vec3(0., .65, 2.15);\n\t\t\tq.yz *= rot2(HALFPI/2.);\n\t\t\tfloat base = q.z;\n\t\t\tq.yz *= rot2(HALFPI/2.*t);\n\t\t\tfloat now = q.z;\n\t\t\tq.yz *= rot2(HALFPI/2.*(1.-t));\n\t\t\tfloat to = q.z;\n\t\t\tp.z += 1. - 2. * (now - base) / (to - base);\n\t\t}\n\t} else {\n\t\tp.z += 1.;\n\t}\n\treturn sdCappedCylinder(p, 2.3, .8) - .2;\n}\n\nvec2 pegs(vec3 p)\n{\n\tvec2 one = vec2(peg(p, 0., .5), MAT_BLUE),\n\t\ttwo = vec2(peg(p, 3.5, .0), MAT_YELLOW),\n\t\ttri = vec2(peg(p, -3.5, 1.), MAT_GREEN);\n\tif (two.x < one.x) one = two;\n\tif (tri.x < one.x) one = tri;\n\treturn one;\n}\n\nvec2 base(vec3 p)\n{\n\tfloat middle = length(max(abs(p) - vec3(6.5, 1.5, .5), 0.));\n\t//middle = max(middle, -(length(p.xy) - 1.23));\n\tmiddle = ss(length(p.xy) - 1.3, middle, .2);\n\tmiddle = ss(length(vec2(abs(p.x) - 3.5, p.y)) - 1.3, middle, .2);\n\t//middle = max(middle, -(length(vec2(abs(p.x) - 3.5, p.y)) - 1.23));\n\tmiddle -= .2;\n\tvec2 m = vec2(middle, MAT_WOOD);\n\tp.x = abs(p.x) - 7.;\n\tp.z = abs(p.z) - 1.8;\n\tfloat side = length(max(abs(p) - vec3(.5, 3., 2.), 0.)) - .3;\n\tp.z -= 2.;\n\tside = ss(length(p.yz) - 2., side, .3);\n\tvec2 s = vec2(side, MAT_RED);\n\n\tif (m.x < s.x) s = m;\n\treturn s;\n}\n\nvec2 hammer(vec3 p)\n{\n\tp.x-=3.5;p.z += 4.3;p.y += 2.6;\n\tif (gTimeMod < 1.2) {\n\t\tfloat tpt = mod(gTimeMod, .5);\n\t\tp.x += 3.5 * (gTimeMod - tpt) * 2.;\n\t\tif (tpt < .2) {\n\t\t\tfloat t = tpt / .2;\n\t\t\tp.yz *= rot2(HALFPI/2.*t);\n\t\t\tp.z -= 2. * t;\n\t\t} else {\n\t\t\tfloat t = (tpt - .2) / .3;\n\t\t\tp.x += 3.5 * t;\n\t\t\tif (t < .5) {\n\t\t\t\tt /= .5;\n\t\t\t\tp.yz *= rot2(HALFPI/2.*(1.-t));\n\t\t\t\tp.z += -2. + (2. + 2.) * oq(t);\n\t\t\t} else {\n\t\t\t\tt = (t - .5) / .5;\n\t\t\t\tp.z += 2. * (1. - iq(t));\n\t\t\t}\n\t\t}\n\t\tp.yz *= rot2(HALFPI/2.);\n\t} else {\n\t\tfloat t = (gTimeMod-1.2)/1.3;\n\t\tp.x += 7. * (1. - t);\n\t\tif (t < .5) {\n\t\t\tfloat xx = 1.-clamp(t / .2, 0., 1.);\n\t\t\tp.yz *= rot2(HALFPI/2.*xx);\n\t\t\tp.z -= 2. * xx;\n\t\t\tp.z += oq(t/.5) * 8.;\n\t\t} else {\n\t\t\tp.z += oq(1.-(t-.5)/.5) * 8.;\n\t\t}\n\t\tp.yz *= rot2(HALFPI/2.-PI*2.*ioc(t));\n\t}\n\tvec2 r = vec2(sdCappedCylinder(p, 4., .8), MAT_RED);\n\tp.z += 3.5;\n\tp.yz *= rot2(HALFPI);\n\tvec2 head = vec2(sdCappedCylinder(p, 1.3, 1.1) - .1, MAT_WOOD);\n\tif (head.x < r.x) r = head;\n\treturn r;\n}\n\nvec2 map(vec3 p)\n{\n\t// bright the scene a bit more into the light\n\tp.y -= 2.;\n\tp.x -= 1.;\n\tp.xy *= rot2(.1);\n\tvec2 r = vec2(dot(p,normalize(vec3(0.,0.,-1.))), MAT_GROUND);\n\tp.z += 4.;\n\t//p.xz *= rot2(.3);\n\t//p.zy *= rot2(iTime);\n\tvec2 hammer = hammer(p);\n\tif (gTimeMod > 1.2) {\n\t\tif (gTimeMod > 1.6) {\n\t\t\tfloat t = clamp((gTimeMod - 1.6) /.9, 0., 1.);\n\t\t\tp.z += 5. - 5. * ob(t);\n\t\t} else {\n\t\t\tp.z += 5. * oq((gTimeMod - 1.2) / .4);\n\t\t}\n\t\tif (gTimeMod > 1.4) {\n\t\t\tfloat t = clamp((gTimeMod - 1.4) / .4, 0., 1.);\n\t\t\tp.zy *= rot2(PI*ioq(t));\n\t\t}\n\t}\n\tvec2 base = base(p);\n\tvec2 pegs = pegs(p);\n\tif (base.x < r.x) r = base;\n\tif (pegs.x < r.x) r = pegs;\n\tif (hammer.x < r.x) r = hammer;\n\treturn r;\n}\n\n/*vec3 norm(vec3 p, float dist_to_p)\n{\n\tvec2 e=vec2(.00035,-.00035);\n\treturn normalize(e.xyy*map(p+e.xyy).x+e.yyx*map(p+e.yyx).x+e.yxy*map(p+e.yxy).x+e.xxx*map(p+e.xxx).x);\n}*/\n// suggestion by Shane (see comments)\nvec3 norm(vec3 p, float dist_to_p){     \n    vec3 n = vec3(0);\n    for(int i=min(iFrame, 0); i<4; i++){\n        vec3 e = .57735*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.);\n        n += e*map(p + .00035*e).x;\n    }    \n    return normalize(n);\n}\n\n// x=hit y=dist_to_p z=dist_to_ro w=material(if hit)\nvec4 march(vec3 ro, vec3 rd, int maxSteps)\n{\n\tvec4 r = vec4(0);\n\tfor (i = 0; i < maxSteps && r.z < 350.; i++){\n\t\tgHitPosition = ro + rd * r.z;\n\t\tvec2 m = map(gHitPosition);\n\t\tfloat dist = m.x;\n\t\tif (dist < .0001) {\n\t\t\tr.x = float(i)/float(maxSteps);\n\t\t\tr.y = dist;\n\t\t\tr.w = m.y;\n\t\t\tbreak;\n\t\t}\n\t\tr.z += dist;\n\t}\n\treturn r;\n}\n\n// sourced from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO(vec3 pos, vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = map(pos + h*nor).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows/\nfloat softshadow(vec3 ro, vec3 rd)\n{\n\tfloat res = 1.0;\n\tfloat ph = 9e9;\n\tfor(float dist = 0.01; dist < 40.; ) {\n\t\tfloat h = map(ro + rd*dist).x;\n\t\tif (h<0.001) {\n\t\t\treturn 0.0;\n\t\t}\n\t\tfloat y = h*h/(2.0*ph);\n\t\tfloat d = sqrt(h*h-y*y);\n\t\tres = min(res, 5.*d/max(0.0,dist-y));\n\t\tph = h;\n\t\tdist += h;\n\t}\n\treturn res;\n}\n\nvec3 colorHit(vec4 result, vec3 rd)\n{\n\tvec3 shade = vec3(0., 1., 0.);\n\n\tswitch (int(result.w)) {\n\tcase MAT_GROUND: shade = vec3(.93,.83,.74); break;\n\tcase MAT_RED: shade = vec3(1.,0.,0.); break;\n\tcase MAT_WOOD: shade = vec3(.88,.8,.71); break;\n\tcase MAT_BLUE: shade = vec3(0.,.56,.81); break;\n\tcase MAT_YELLOW: shade = vec3(.98,.84,0.); break;\n\tcase MAT_GREEN: shade = vec3(.12,.69,.32); break;\n\t}\n\t//return shade * .3 + .4 * result.x;\n\n\tvec3 normal = norm(gHitPosition, result.y);\n\tvec3 material = shade * .3;\n\n    // https://www.shadertoy.com/view/lsKcDD\n\t// key light\n\tvec3 lig = normalize(vec3(0.1, 0.3, -0.6));\n\tvec3 hal = normalize(lig-rd);\n\tfloat dif = clamp(dot(normal, lig), 0.0, 1.0) * softshadow(gHitPosition, lig);\n\n\tfloat spe = pow(clamp(dot(normal, hal), 0.0, 1.0 ),16.0)* dif *\n\t(0.04 + 0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0), 5.0));\n\n\tvec3 col = material * 4.0*dif*vec3(1.00,0.70,0.5);\n\tcol += 12.0*spe*vec3(1.00,0.70,0.5);\n\n\t// ambient light\n\tfloat occ = calcAO(gHitPosition, normal);\n\tfloat amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n\tcol += material*amb*occ*vec3(0.0,0.08,0.1);\n\n\t// fog\n\tfloat t = result.z;\n\tcol *= exp(-0.000007*t*t*t);\n\t//col *= exp(-0.00007*t);\n    //col *= exp(-0.0005*t*t*t);\n\treturn col;\n}\n\n#if shadertoy == 1\nvoid mainImage(out vec4 c, in vec2 v)\n{\n#else\nout vec4 c;\nin vec2 v;\nvoid main()\n\t{\n#endif\n\tgTimeMod = mod(iTime, 2.5);\n\n\t//vec3 ro = vec3(3, 14, -12) * 1.3;\n\t//vec3 at = vec3(1, 0, -8);\n\tvec3 ro = vec3(10, 14, -10) * 1.3;\n\tvec3 at = vec3(1, 0, -6);\n\n#if debugmov //noexport\n\tro = debug[0].xyz; //noexport\n\tfloat vertAngle = debug[1].y/20.; //noexport\n\tfloat horzAngle = debug[1].x/20.; //noexport\n\tif (abs(vertAngle) < .001) { //noexport\n\t\tvertAngle = .001; //noexport\n\t} //noexport\n\tfloat xylen = sin(vertAngle); //noexport\n\tvertAngle = cos(vertAngle); //noexport\n\tat.x = ro.x + cos(horzAngle) * xylen; //noexport\n\tat.y = ro.y + sin(horzAngle) * xylen; //noexport\n\tat.z = ro.z + vertAngle; //noexport\n#endif //noexport\n\n    vec3  cf = normalize(at-ro),\n\t      cl = normalize(cross(cf,vec3(0,0,-1)));\n\tmat3 rdbase = mat3(cl,normalize(cross(cl,cf)),cf);\n\n\tvec3 resultcol = vec3(0.);\n\tfor (int aaa = 0; aaa < 2; aaa++) {\n\t\tfor (int aab = 0; aab < 2; aab++) {\n#if shadertoy == 1\n\t\t\tvec2 o = v + vec2(float(aaa),float(aab)) / 2. - 0.5;\n\t\t\tvec2 uv = (o-.5*iResolution.xy)/iResolution.y;\n#else\n            vec2 iResolution = fpar[0].yz;\n\t\t\tvec2 uv = v*(iResolution + vec2(float(aaa),float(aab))/4)/iResolution;\n\t\t\tuv.y /= iResolution.x/iResolution.y;\n#endif\n\t\t\tvec3 rd = rdbase*normalize(vec3(uv,1)), col = vec3(0.);\n\n\t\t\tvec4 result = march(ro, rd, 200);\n\n\t\t\tif (result.x > 0.) { // hit\n\t\t\t\tcol = colorHit(result, rd);\n\t\t\t}\n\t\t\tresultcol += col;\n\t\t}\n\t}\n\tresultcol /= 4.;\n\n\n\tc = vec4(pow(resultcol, vec3(.4545)), 1.0); // pow for gamma correction because all the cool kids do it\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}