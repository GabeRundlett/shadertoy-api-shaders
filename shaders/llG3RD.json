{
    "Shader": {
        "info": {
            "date": "1473489972",
            "description": "Ported some of my AS3 raytracer! It's great to actually see it run in real-time.\nIt's my first time creating a true shader, which can explain why my code is CPU-minded. ;) Enjoy!\n(I wish GLSL had a call stack for multiple reflection&refraction bounces)",
            "flags": 0,
            "hasliked": 0,
            "id": "llG3RD",
            "likes": 28,
            "name": "Voxel Towers",
            "published": 3,
            "tags": [
                "3d",
                "raycast",
                "voxel",
                "raytrace"
            ],
            "usePreview": 0,
            "username": "Zanzlanz",
            "viewed": 3987
        },
        "renderpass": [
            {
                "code": "// Shader by Zanzlanz ;)\n// You can freely use and alter this shader (please give credit).\n\nconst float worldSize = 150.0;\nconst float pi = 3.1415926536;\nconst vec3 skyColor = vec3(22.0/255.0, 86.0/255.0, 129.0/255.0);\n\nvec3 cam;\nvec3 camRot;\nfloat tick = 0.0;\n\n// One of my favorite utilities :)\nfloat mod2(float a, float b) {\n\tfloat c = mod(a, b);\n\treturn (c < 0.0) ? c + b : c;\n}\n\n// For coloring blocks, but current not used\nfloat rand2(vec2 co){\n    return fract(sin(dot(co.xy*.01, vec2(25.5254, -15.5254))) * 52352.323);\n}\n\n// For block heights\nfloat rand(vec2 co){\n\treturn min(rand2(co)+sin(co.x*.1-co.y*.5+tick*.2)*.1+cos(co.y*.3+co.x*.5+tick*.4)*.1,\n               .87+length(vec2(mod2(co.x-cam.x+worldSize*.5, worldSize)-worldSize*.5, mod2(co.y-cam.z+worldSize*.5, worldSize)-worldSize*.5))*.1);\n}\n\nvec3 getFG(vec3 co) {\n    if(co.y/worldSize*3.0 < rand(vec2(co.x, co.z))) {\n        //Uncomment below for randomly colored blocks\n        //return vec3(rand(vec2(co.x+co.y+1., co.z+2.)), rand(vec2(co.x+3., co.z+co.y+4.)), rand(vec2(co.x+co.y+5., co.z+co.y+6.)));\n    \n        return vec3(1.0, 1.0, 1.0);\n    }\n    return vec3(-1, 0, 0);\n}\nvec4 raycast(vec3 start, vec3 castSpeedStart) {\n\tvec3 castSpeed = castSpeedStart.xyz;\n    float skyAmount = castSpeed.y*.4;\n    \n\tvec4 returnValue = vec4(skyColor*skyAmount, 0.0);\n\tvec3 ray = vec3(start.xyz);\n\t\n    float shadowing = 1.0;\n    vec3 currentCast = vec3(floor(ray));\n    \n    int collideWith = 0;\n\t\n    bool skipLoop = false;\n    for(int its=0; its<200; its++) {\n        // For some reason having this as if(skipLoop) actually broke the shader when I updated my nvidia driver\n        // It acted as though skipLoop was always true. Was that bad GLSL practice? Any other details you know? Comment please :D\n        if(skipLoop == true) {\n            skipLoop = false;\n            continue;\n        }\n\t\tif(currentCast.y<0.0 || currentCast.y>=worldSize*.4) {\n\t\t\treturnValue = vec4(skyColor*skyAmount, 0);\n\t\t\tbreak;\n\t\t}\n        \n\t\tvec3 inBlock = getFG(vec3(mod(currentCast.x, worldSize), mod(currentCast.y, worldSize), mod(currentCast.z, worldSize)));\n\t\tif(inBlock.x != -1.0) {\n            float finalShadowing = clamp(shadowing-length(ray-start)/60.0, 0.0, 1.0);\n            \n            finalShadowing *= mod(.7*(float(collideWith)+5.0), 1.0)*.8+.2;\n            \n            returnValue = vec4(inBlock*finalShadowing+(1.0-finalShadowing)*skyColor*skyAmount, 0.0 );\n            break;\n\t\t} // Here is also where I used to do reflections and fun stuff... recursively though\n        \n        // These last three IFs are checking if the ray passes the next voxel plane\n\t\tif(castSpeed.x != 0.0) {\n\t\t\tfloat t = ( floor(currentCast.x+clamp(sign(castSpeed.x), 0.0, 1.0)) -ray.x)/castSpeed.x;\n\t\t\tvec3 cast1Tmp = ray+castSpeed*t;\n\t\t\tif(cast1Tmp.y>=currentCast.y && cast1Tmp.y<=currentCast.y+1.0 && cast1Tmp.z>=currentCast.z && cast1Tmp.z<=currentCast.z+1.0) {\n\t\t\t\tray = cast1Tmp;\n\t\t\t\tcurrentCast.x += sign(castSpeed.x);\n\t\t\t\tcollideWith = (castSpeed.x>0.0?0:1);\n                skipLoop = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif(castSpeed.y != 0.0) {\n\t\t\tfloat t = ( floor(currentCast.y+clamp(sign(castSpeed.y), 0.0, 1.0)) -ray.y)/castSpeed.y;\n\t\t\tvec3 cast1Tmp = ray+castSpeed*t;\n\t\t\tif(cast1Tmp.x>=currentCast.x && cast1Tmp.x<=currentCast.x+1.0 && cast1Tmp.z>=currentCast.z && cast1Tmp.z<=currentCast.z+1.0) {\n\t\t\t\tray = cast1Tmp;\n\t\t\t\tcurrentCast.y += sign(castSpeed.y);\n\t\t\t\tcollideWith = (castSpeed.y>0.0?2:3);\n                skipLoop = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif(castSpeed.z != 0.0) {\n\t\t\tfloat t = ( floor(currentCast.z+clamp(sign(castSpeed.z), 0.0, 1.0)) -ray.z)/castSpeed.z;\n\t\t\tvec3 cast1Tmp = ray+castSpeed*t;\n\t\t\tif(cast1Tmp.y>=currentCast.y && cast1Tmp.y<=currentCast.y+1.0 && cast1Tmp.x>=currentCast.x && cast1Tmp.x<=currentCast.x+1.0) {\n\t\t\t\tray = cast1Tmp;\n\t\t\t\tcurrentCast.z += sign(castSpeed.z);\n\t\t\t\tcollideWith = (castSpeed.z>0.0?4:5);\n                skipLoop = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\treturnValue.w = length(ray-start);\n    float val = 1.0-returnValue.w/70.0;\n\treturn vec4(returnValue.xyz*val, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 f) {\n    vec2 f2 = vec2(f.x, iResolution.y-f.y);\n\tvec2 uv = f.xy / iResolution.xy;\n    tick = iTime;\n    \n    cam.x = worldSize/2.0+sin(tick/worldSize*14.0*pi)*10.0;\n    cam.y = worldSize-100.0;\n    cam.z = worldSize/2.0+tick*8.0;\n    \n    camRot = vec3(sin(tick/worldSize*22.0*pi)*.5+.5, 0.0, sin(tick/worldSize*14.0*pi)*.5);\n    \n    vec3 castDir = vec3(0, 0, 0);\n    vec3 cast1 = vec3(cam+.5);\n    vec3 cast2 = vec3(0, 0, 0);\n\n    // Getting raycast speed based on the pixel in the frustrum\n    castDir.x = f2.x/iResolution.y*5.0-(iResolution.x-iResolution.y)/2.0/iResolution.y*5.0-.5*5.0;\n    castDir.y = (.5-f2.y/iResolution.y)*5.0;\n    castDir.z = 3.0;\n\n    // Rotating camera in 3D\n    cast2.x = castDir.x*(cos(camRot.y)*cos(camRot.z))+castDir.y*(cos(camRot.z)*sin(camRot.x)*sin(camRot.y)-cos(camRot.x)*sin(camRot.z))+castDir.z*(cos(camRot.x)*cos(camRot.z)*sin(camRot.y)+sin(camRot.x)*sin(camRot.z));\n    cast2.y = castDir.x*(cos(camRot.y)*sin(camRot.z))+castDir.y*(cos(camRot.x)*cos(camRot.z)+sin(camRot.x)*sin(camRot.y)*sin(camRot.z))-castDir.z*(cos(camRot.z)*sin(camRot.x)-cos(camRot.x)*sin(camRot.y)*sin(camRot.z));\n    cast2.z = -castDir.x*(sin(camRot.y))+castDir.y*(cos(camRot.y)*sin(camRot.x))+castDir.z*(cos(camRot.x)*cos(camRot.y));\n \n    vec3 castResult = raycast(cast1, cast2).xyz;\n    \n    fragColor = vec4(clamp(castResult, 0.0, 1.0), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}