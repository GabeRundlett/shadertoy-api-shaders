{
    "Shader": {
        "info": {
            "date": "1520183121",
            "description": "You are yellow, you start: try to align 4 (horiz, vertic or diag)\nCommon: \n  switch #Human  for computer vs computer game\n  #def tune strategy (pretty simplist, anyway: see 2 places in BufA )",
            "flags": 48,
            "hasliked": 0,
            "id": "XscyDj",
            "likes": 10,
            "name": "4 in a row (against computer)",
            "published": 3,
            "tags": [
                "game",
                "puissance4"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 791
        },
        "renderpass": [
            {
                "code": "// === display board\n\n#define disk(U) smoothstep(24./R.y, 0., length(U)-.85 ) // draw disk\n#define col(c)  vec4( c!=0., c<0., b,1 )                // pawn color\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U = 6.* ( U - .5*vec2(R.x,0) ) / R.y;        // cell coords\n\n    // --- margins & end game\n    O -= O;\n    float c = sign(U.x), b=0.;                   // margin side\n    if ( T(vec2(0)).y == c ) O = hue(4.*iTime ); // if win display\n    O  = mix( O, col(c)*(T(vec2(9,2)).y==c?1.:.5), disk(2.*(abs(U)-vec2(4.5,3))) ); // side pawns\n    if ( abs(U.x) > 3.55 ) return;\n    U.x += 3.5;\n    \n    // --- draw cells\n    vec4 C = T(U+1.);                            // cell state\n    float d = disk(2.*fract(U)-1.);\n    b = T(vec2(9,3)).yz==ceil(U) ? .7 : 0.;      // brighter if last play\n    O = mix( vec4(0,0,1,1), col(C.x) , d );      // draw cell\n    \n    // --- debug: show potential analysis\n    if(keyToggle(32)) {\n        vec2 P = fract(U)*10.;\n        if (floor(P.x)==1. && P.y < C.y/10.) O = vec4(.5,1,.5,1);\n        if (floor(P.x)==8. && P.y < C.z/10.) O = vec4(1,.5,.5,1);\n      //if (floor(P.x)==4. && P.y <  mod( C.w,8.)*2.5) O = vec4(.5,1,.5,1);\n      //if (floor(P.x)==5. && P.y < floor(C.w/8.)*2.5) O = vec4(1,.5,.5,1);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// === game strategy for computer vs computer or human. SPACE to see potentials\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U -= .5;\n    if (   iFrame==0 \n        || T(vec2(0)).y != 0. && iTime > T(vec2(0)).z+6.) // (re)init board\n    {\n        O -= O;                          // state(0,0).yz: win, delay  \n        if (U.x<1. || U.y<1. || U.x>7. || U.y > 6. )\n            O.x = 2.;                                 // 2: outside\n      //else if (U.y<2.) O.x = floor(3.*rnd(U)) - 1.; // 1:red -1:yellow 0: free\n        if (U==vec2(9,2)) O.y = -1.;                  // yellow start\n        return;\n    }\n    \n    O = T(U);                                         // restore state\n    if ( T(vec2(0)).y != 0. ) return;                 // win delay\n    \n    // --- each player on turn\n    if ( iTime > T(vec2(9,2)).z ) {      // state (9,0/1): best pot., its pos\n        float c = T(vec2(9,2)).y;        // state (9,2).yz: who play, delay \n        if (c==-1.)                                   // yellow plays\n#if HUMAN\n          if (iMouse.z>0.) {                          // human yellow\n            vec2 R = iResolution.xy,\n                 M = 6.* ( iMouse.xy - .5*vec2(R.x,0) ) / R.y; // clicked cell\n                 M.x += 3.5; M = ceil(M);\n          if (M.x>0. && M.x<8.) {                     // please play in board\n            for(M.y=1.; M.y<7. && T(M).x!= 0.;) M.y++;// search col top (playable pos)\n            // we should verify that M.y < 7 <><> \n#else\n         {{ vec2 M = T(vec2(9,0)).yz;                 // computer yellow pick best strategy\n#endif\n            if (U==M) O.x = -1.;                      // yellow play its best\n            if (U==vec2(0) && mod(T(M).w,8.)==3.)     // yellow win (added to 3 aligned)\n                { O.y = -1.;  O.z = iTime; return; }\n            if (U==vec2(9,2)) O.y = -c, O.z = iTime+1.; // switch player\n            if (U==vec2(9,3)) O.yz = M;               // save last play for effects\n        }}\n\n        if (c==1.) {                                  // red plays\n            vec2 M = T(vec2(9,1)).yz;                 // computer red pick best strategy\n            if (U==M) O.x =  1.;                      // auto red play its best\n            if (U==vec2(0) && floor(T(M).w/8.)==3.)   // red win (added to 3 aligned)\n               { O.y = 1.;  O.z = iTime; return; }\n            if (U==vec2(9,2)) O.y = -c, O.z = iTime+float(1-HUMAN);  // switch player\n            if (U==vec2(9,3)) O.yz = M;               // save last play for effects\n        }\n    }\n\n    // --- choose best strategy\n    if (U.x==9. && U.y<2.) {                         // state (9,0/1)\n        vec2 P, P0=P-P, P1=P-P, C, M=vec2(-9e9);\n        for(int x=1; x<8; x++) {                     // for each col\n            int y=1;\n            while( y<7 && T(P=vec2(x,y)).x!= 0. ) y++;// search col top (playable pos)\n            vec4 V = T(P);\n            if (V.x==0.) {                           // STRATEGY:\n                C =   V.yz + def*V.zy                // play if best for me or him\n                    + .5*( T(P+vec2(0,1)).yz-T(P+vec2(0,1)).zy); // anticipate next row\n                C += 200.*step(90.,V.yz);            // can win now\n                if (C.x>M.x) M.x=C.x, P0=P;\n                if (C.y>M.y) M.y=C.y, P1=P;\n            }\n        }\n        O = U.y==0. ? vec4(M.x,P0,0)                 // store best play for each\n                    : vec4(M.y,P1,0);\n    }\n    \n    // --- evaluate cell potential for both point of view\n    if ( U.x<1. || U.y<1. || U.x>7. || U.y > 6. ) return; // out of board\n    O.w = 0.;\n    for (float c=-1.; c<2.; c+=2. ) {              // check for each point of view\n        int m = 0, p = 0;                          // potential for col c\n        vec2 V, D = vec2(0,1);                     // axis checked\n        for (int y=-2; y<2; y++, D = vec2(1,y) ) { // check 4 axis\n            int l=1, n=0, a=0;                     // hole length, nb c-pawns, nb aligned\n            for(int d=0; d<2; d++, D = -D) {       // 1 axis = 2 directions\n                V = U;\n                for (int i=1,e=0; i<4; i++) {      // explore band up to 4\n                    float v = T(V+=D).x;\n                    if (v!=0. && v!=c) break;      // stop if !c or out\n                    if (v==c) n++;                 // count c-pawns\n                    if (v==0.) e=1;\n                    if (v==c&&e==0) a++;           // count aligned pawns\n                    l++;                           // count hole size\n                }\n            }                                      // end axis in both dir\n            if (l>3) p += l-n + 10*n*n + 2*a;      // STRATEGY: c-value of the segment\n            m = max(m,a);                          // max aligned\n        }\n        O[c==-1.?1:2] = float(p)                   // cell potential\n              + 3.*rnd(U+vec2(0,iTime));           // some randomness\n        O.w += float( c==-1. ? m : 8*m );          // max aligned (to detect win)\n    }  \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define HUMAN 1  // 1: human against computer 0: computer against computer\n#define def 2.   // >1. : defensive strategy <1: offensive strategy\n\n#define T(U)    texelFetch(iChannel0, ivec2(U), 0)\n#define rnd(U)  fract(1e4*sin(dot(U,vec2(72,17.7))))\n#define hue(v) ( .5 + .5 * cos( v + vec4(0,23,21,0) ) ) // rainbow(hue)\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}