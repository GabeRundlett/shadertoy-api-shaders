{
    "Shader": {
        "info": {
            "date": "1671854330",
            "description": "Discovering graphics by figuring out techniques on my own with minimal research. Features raymarching, diffuse & specular shading, supersampled ray shadows. Does not necessarily represent best practices or make sense.",
            "flags": 0,
            "hasliked": 0,
            "id": "mtfGzM",
            "likes": 1,
            "name": "sponge flight",
            "published": 3,
            "tags": [
                "raymarching",
                "shadows"
            ],
            "usePreview": 0,
            "username": "nickbrick",
            "viewed": 161
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265\n#define SCENE 2\nfloat hills(vec3 p){ // test SCENE = 1\n    vec3 near = vec3(round(p.x), 0.0, round(p.z));\n    return distance(p, near);\n}\nvec3 hillsNormal(vec3 p){\n    vec3 near = vec3(round(p.x), 0.0, round(p.z));\n    return normalize(p - near);\n}\n\nfloat sampleFreqs(int bandFrom, int bandTo){\n    float v = 0.0;\n    for (int b = bandFrom; b <= bandTo; b ++)\n        v += texelFetch(iChannel0, ivec2(b, 0), 0).x; \n    return v / float(bandTo - bandFrom);\n}\n\nfloat sponge(vec3 p){ // actual SCENE = 2\n    vec3 near = round(p);\n    return norm(near, p, 5.0 - sampleFreqs(0, 64) * 4.0);\n}\nvec3 spongeNormal(vec3 p){ // this just returns the norm2 normals (spherical cells). i'd love to somehow calculate arbitrary norm normals\n    vec3 pp = round(p);\n    return normalize(round(p) - p);\n}\n\nbool hit(vec3 p){\n    if (SCENE == 1) return hills(p) < 0.55;\n    if (SCENE == 2) return sponge(p) > 0.55;\n}\nvec3 normal(vec3 p){\n    if (SCENE == 1) return hillsNormal(p);\n    if (SCENE == 2) return spongeNormal(p);\n}\n\nvec3 pixel(vec3 o, float fov, vec2 fc){\n    vec2 uv = (fc - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n    float f = 0.5 / tan(fov/2.0);\n    vec3 n = vec3(0.0, 0.0, f);\n    return o + n + vec3(uv, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #define FROM 0.0\n    #define TO   30.0\n    #define SAT  .9\n    #define STEP 0.07\n    #define DIFF 10.0\n    #define SPEC 80.0\n    #define AMBI 10.\n    #define BULB (sampleFreqs(256, 511) * 0.1 + 0.01)\n    #define SHADOWS true\n    #define SS   16.0\n\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    //camera, light source\n    vec3 o = vec3(0.0 + 1.1 * cos((iTime + 0.5) * PI / 4.0),\n                  2.0 + 1.1 * sin((iTime + 0.5) * PI / 4.0), \n                  0.0 + 1.0 * iTime);\n    vec3 l = vec3(0.0,\n                  2.0 + sin(iTime) * 0.0,\n                  1.0 * iTime + 1.0);\n    \n    // shading components\n    float range = TO;\n    float diffuse = 0.0;\n    float specular = 0.0;\n    \n    vec3 n = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 pl = vec3(TO);\n    for (float a = FROM; a < TO; a += STEP){\n        vec3 pixel = pixel(o, 2.3, fragCoord);\n        pixel = axisAngle(vec3(0.,0.,1.), 0.5 * cos(0.5 * iTime)) * (pixel - o) + o;\n        vec3 p = mix(o, pixel, a);\n        if (hit(p)){ // surface\n            float shadow = 1.0;\n            if (SHADOWS){\n                vec3 dial = orthogonal(l - p) * BULB;\n                float hits = 0.0;\n\n                for (float a2 = 10.0 * STEP; a2 < 1.0; a2 += STEP){ // main shadow ray\n                        vec3 p2 = mix(p, l, a2);\n                        if (hit(p2)){ // shadow\n                            hits += 1.0;\n                            break;\n                        }\n                    }\n                for (float sector = 0.0; sector < 2.0 * PI; sector += 2.0 * PI / SS){ // shadow supersampling disk\n                    vec3 disk = (axisAngle(l - p, sector) * dial) + l;\n                    for (float a2 = 10.0 * STEP; a2 < 1.0; a2 += STEP){\n                        vec3 p2 = mix(p, disk, a2);\n                        if (hit(p2)){ // shadow\n                            hits += 1.0;\n                            break;\n                        }\n                    }\n                }\n                shadow =  (SS + 1.0 - hits) / (SS + 1.0);\n            }\n            range = distance(o, p);\n            pl = l - p;\n            vec3 po = o - p;\n            n = normal(p);\n            diffuse = pow(BULB, 0.5) / 0.1 * shadow / range * max(0.0, DIFF * dot(n, normalize(pl)));\n            specular = shadow * max(0.0001, SPEC * pow(max(0.0, -dot(normalize(po), reflect(normalize(pl), n))), 2.0 / BULB));\n            break;\n        }\n        if (length(l - p) < BULB) {diffuse = 100000000.; break;}\n    }\n    float v = 1.0 - (-1.0 / SAT / (TO - FROM) * ( (diffuse+ specular + AMBI) / pow(length(pl), 2.) ) + TO / (TO - FROM));\n    #define BMINOR vec3(0.82421875,0.41015625,0.03515625)\n    fragColor = vec4(v * BMINOR, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 35,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "mat3 axisAngle(vec3 u, float a){\n    float X = u.x;\n    float Y = u.y;\n    float Z = u.z;\n    float C = cos(a);\n    float S = sin(a);\n    float C_= 1.-cos(a);\n\n    return mat3(\n        C+X*X *C_ ,\n        Y*X*C_+Z*S,\n        Z*X*C_-Y*S,\n        X*Y*C_-Z*S,\n        C+Y*Y *C_  ,\n        Z*Y*C_+X*S,\n        X*Z*C_+Y*S,\n        Y*Z*C_-X*S,\n        C+Z*Z*C_\n     );\n}\n// returns a vector (0, y, z) where y, z >= 0 and magnitude = 1\nvec3 orthogonal(vec3 u){\n    if (abs(u.x) > 0.999) return vec3(0.0, 1.0, 0.0);\n    float y = abs(u.z) / sqrt(u.y * u.y + u.z * u.z);\n    float z = sqrt(1.0 - pow(y, 2.0));\n    return vec3(0.0, y, z);\n}\n\nfloat norm(vec3 p0, vec3 p1, float N){\n    vec3 d = abs(p0 - p1);\n    return pow(pow(d.x, N) + pow(d.y, N) + pow(d.z, N), 1.0 / N);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}