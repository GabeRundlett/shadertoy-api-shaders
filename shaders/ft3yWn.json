{
    "Shader": {
        "info": {
            "date": "1659883462",
            "description": "potato  t",
            "flags": 32,
            "hasliked": 0,
            "id": "ft3yWn",
            "likes": 14,
            "name": "Day 958",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 314
        },
        "renderpass": [
            {
                "code": "// Fork of \"Day 957\" by jeyko. https://shadertoy.com/view/Nl3czM\n// 2022-08-03 08:27:34\n\n// Fork of \"Day 956\" by jeyko. https://shadertoy.com/view/7l3yz4\n// 2022-08-02 07:37:58\n\n// Fork of \"Day 955\" by jeyko. https://shadertoy.com/view/fttyR8\n// 2022-08-01 07:12:45\n\n// Fork of \"Day 802\" by jeyko. https://shadertoy.com/view/ssBBDW\n// 2022-07-31 07:41:23\n\n\nfloat T;\n\nvec3[4*4] palAppleII = vec3[](\n    vec3(217, 60, 240)/255.,\n    vec3(64, 53, 120)/255.,\n    vec3(108, 41, 64)/255.,\n    vec3(0, 0, 0)/255.,\n\n    vec3(236, 168, 191)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(217, 104, 15)/255.,\n    vec3(64, 75, 7)/255.,\n\n    vec3(191, 180, 248)/255.,\n    vec3(38, 151, 240)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(19, 87, 64)/255.,\n\n    vec3(255, 255, 255)/255.,\n    vec3(147, 214, 191)/255.,\n    vec3(191, 202, 135)/255.,\n    vec3(38, 195, 15)/255.\n);\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n\n    T = initTime(iTime, U, R);\n    vec2 oU = U;\n    C *= 0.;\n    \n    \n    // pixelzie\n    float sc = 1./(1.+ 0.*max(5.*float(lightMode == 1.)*max(sin(T*2.),0.)*sin(T*0.5),0.));\n    \n    \n    // offset uv\n    float md = 1.;\n    U = floor(U*sc)/sc + pow(mix(hash11(floor(T*md)),hash11(ceil(T*md)),fract(T*md)),0.1);\n    \n    \n    vec2 uv = U/R.xy;\n    vec2 nuv = (U - 0.5*R.xy)/max(R.x,R.y);\n    \n    vec2 id;\n    quantid(nuv,vec2(0.0+ 0.04*hash11(floor(T*5. + 2000.)),0.001 + 0.04*hash11(floor(T*10.))),id);\n    \n    float db = sdBox(nuv,vec2(0.1,0.1)*-0.2 + 0.6*hash11(floor(T*10. + 2000.)) -  float(lightMode));\n    //float db = length(nuv) - 0. ;\n    float dbb;\n    \n    if(lightMode == 1.)\n        dbb= sdBox(nuv,vec2(0.25,0.25) + 0.5*hash11(floor(T*1.))*float(lightMode) );\n    else\n        dbb= -10e5;\n    \n    \n    vec4 a = Tb(uv);\n    vec4 b = Tc(uv);\n    vec4 d = Td(uv);\n    \n    \n    /*\n    if(db > 0.){\n        d.xyz *= 0.;\n    }*/\n    //vec2 st = 0.4/R.xy + 0.1*sin(T)*float(hash11(floor(T)) < 1. && lightMode == 0.);\n    vec2 st = (140.4 + 0.*float(hash11(floor(T*2.)) < 0.5 && lightMode == 0.))/R.xy;\n    \n    int cmp = 0;\n    float l = \n        Tb(uv + vec2(st.x,0))[cmp]-(Tb(uv - vec2(st.x,0)))[cmp] +\n        Tb(uv + vec2(0,st.y))[cmp]-(Tb(uv - vec2(0,st.y)))[cmp] +\n        Tb(uv + vec2(st.xy))[cmp]-(Tb(uv - vec2(st.xy)))[cmp] +\n        Tb(uv + vec2(st.x,-st.y))[cmp]-(Tb(uv - vec2(st.x,-st.y)))[cmp]\n    ;\n    \n    l = clamp(abs(l),0.,1.);\n    //a.xz = vec4(l);\n    \n    \n    \n\n\n    C += b;\n    \n    \n    // C = mix(C,1.-C,abs(l));\n    \n    // britney\n    \n    C += d;\n    C = clamp(C,0.,1.);\n    \n    C = mix(C,d,d.z);\n    \n    //C *= Td(uv);\n        \n        \n    uv = (U - 0.5*R.xy)/max(R.x,R.y);\n    if(lightMode == 0.){\n        // ui;\n        vec2 p = uv;\n        \n        float md = 0.0156;\n        \n        p.y *= 0.01;\n        vec2 id = floor(p/md);\n        p = pmod(p,md); \n        \n        float d = length(p.xy) - 0.003;\n        \n        float ra = hash12(id + 10.);\n        vec2 r = hash22(id + 200. + floor(T*1.5 + ra*1.));\n        \n        if(mod(id.y+T,2.) == 0.){\n            if(r.y < 0.){\n                if(r.x < 0.9)\n                    d = abs(d) - 0.0004;\n                \n                C = mix(C,vec4(1),smoothstep(0.001,0.,d));\n                \n            } else if(r.x < 0.1){\n                C = mix(C,vec4(1),1.);\n                \n            }\n               \n        }\n         \n    }\n\n    if(dbb > 0.)\n        C = vec4(1);\n    {\n        // ui crosses\n        vec2 p = uv;\n        \n        vec2 sid = vec2(float(p.x > 0.),float(p.y > 0.))*2. - 1.;\n        p = abs(p) - vec2(0.45,0.2);\n        float md = 0.0156;\n        \n        float trig = fcondmore(T, 0.1,0.3);\n        vec2 id = floor(p/md);\n        p = pmod(p,md); \n        \n        vec2 sz = vec2(0.001,0.004 + trig);\n        float d = sdBox(p.xy,sz);\n        if(lightMode == 1.)\n            d = min(d,sdBox(p.xy,sz.yx)) ;\n        if(trig == 1.)\n            d = max(d,-sdBox(p.xy,vec2(0.003))) ;\n        \n        float ra = hash12(id + 10.);\n        vec2 r = hash22(id + 200. + floor(T*1.5 + ra*1.));\n        \n        if(abs(id.x) < 1. + trig*0. && abs(id.y) < 1. + hash12(sid + floor(T*4.))*6.*(lightMode*2.-1.)*(1. + trig*1. )){\n        \n            if(d < 0.){\n                C = vec4(1);\n                if(r.y < 0.4){\n                    int cidx = int(r.x*4.*4.);\n                    vec3 c = palAppleII[cidx];\n\n                    c = rgb2hsv(c);\n                    c = hsv2rgbSmooth( c *vec3(1,0.1 + lightMode,1));\n\n                    C.xyz = c;\n\n                }    \n            }\n            \n               \n        } else if(abs(id.x) < 4. && abs(id.y) < 1. + hash12(sid + floor(T*4.) + 20.)*3.){\n            C = vec4(1);\n        } else{\n        \n            if(lightMode == 0.){\n                // ui coloured --blocks-- lines\n                vec2 p = uv;\n\n                vec2 md = vec2(0.01 + 0.0*hash11(floor(T)),0.07);\n\n                vec2 id = floor(p/md);\n                p = pmod(p,md); \n\n                float d = length(p.xy) - 0.004;\n\n                float ra = hash12(id + 10.);\n                vec2 r = hash22(id + 200. + floor(T*1.5 + ra*1.));\n\n\n                if(abs(uv.y) > 0.24 && abs(id.x) < 13. && sin(T + sin(r.y*3.)*4.)> 0.){\n                    C = vec4(1);\n                    if(r.y < 0.4){\n                        int cidx = int(r.x*4.*4.);\n                        vec3 c = palAppleII[cidx];\n\n                        c = rgb2hsv(c);\n                        c = hsv2rgbSmooth( c *vec3(1,0.1 + lightMode,1));\n\n                        C.xyz = c;\n\n                    }\n\n                }\n\n\n            }  \n        \n        }\n        \n        \n    }    \n    \n  \n    \n    vec3 n = hash33(vec3(U,mod(T,200.)));\n    vec3 nb = hash33(vec3(U,mod(T,5200.)));\n    \n    \n    C.xyz += smoothstep(1.,0.,length(C.xyz))*n*0.2;\n    \n    C.xyz -= smoothstep(0.,1.,length(C.xyz))*nb*0.1;\n    \n    float e = float(enva(T)>0.5);\n    e = float(fract(T*0.18) < 0.5);\n\n    uv = (oU - 0.5*R.xy)/max(R.x,R.y);\n    if(\n        e == 0.\n    ){\n        //if(uv.x < 0.)\n            //C = mix(C,1.-C,1.);\n    \n    }else {\n        if( fract(T*0.3) > 0.9)\n            C = 1.-C;\n    \n    }\n    //C = mod(Tb(U/R).x,1.)*vec4(1);\n    C = max(C,vec4(0.01));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nfloat hash11(float p);\n\n\nfloat eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\n//float eeeeeeeeeeee;\n\n//#define iTime (iTime + floor(gl_FragCoord.y/200.)*0.4*)\n#define NO_INTERSECTION -1456.123456\n#define iTime (iTime + 100. + 60. + 20.)\n\nvec4 intersectPlane(vec3 ro, vec3 rd, vec3 n){\n    //ro = -ro;\n    n = normalize(n);\n    //dot(n, ro + rd*t) = 0;\n    //(ro.x + rd.x*t)*n.x + (ro.y + rd.y*t)*n.y + (ro.z + rd.z*t)*n.z = 0\n    //ro.x*n.x + rd.x*t*n.x + ro.y*n.y + rd.y*t*n.y + ro.z*n.z + rd.z*t*n.z = 0\n    // t  = - (ro.x*n.x +  ro.y*n.y  + ro.z*n.z)/( rd.x*n.x + rd.y*n.y + rd.z*n.z ) \n    //return vec4(-(dot(ro,n))/dot(rd,n), n);\n    \n    float dron = dot(ro, n); \n    if(dron > 0.){\n    \tro -= n * dron*2.;\n    \trd = -rd;\n    }\n    \n    float nominator = dot(ro,n); \n        \n    float denominator = dot(rd,n);\n        \n    if (denominator > 1e-9) { \n        return vec4( -nominator / denominator, n); \n    \n    } else {\n    \treturn vec4(NO_INTERSECTION);\n    }\n}\n\n#define fcondless(t,c,l) float(fract(t*c) < l)\n#define fcondmore(t,c,l) float(fract(t*c) > l)\n#define pi acos(-1.)\n\n#define R iResolution.xy\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n#define quant(v,a) floor(v/a)*a\n#define quantid(v,a,id)  id = floor(v/a);v = floor(v/a)*a; \n\n#define Ta(u) texture(iChannel0,u)\n#define Tb(u) texture(iChannel1,u)\n#define Tc(u) texture(iChannel2,u)\n#define Td(u) texture(iChannel3,u)\n\n\n\n#define lightMode float(fract(iTime*0.1) <0.5 )\n#define hardMode(T) float(fract(T*0.15) >0.7 ) \n\n\nvec3 getRo(float t, vec2 m, vec2 r){\n    vec3 ro = vec3(0,-2,2);\n    //ro.xy *= rot((t*0.8 + sin(t*1.7)*0.6)*0.1);\n    ro.yz *= rot(sin(t)*0.4);\n    \n    //ro.xy *= rot((t*0.8 + sin(t*1.7)*0.6)*0.1);\n    \n    ro.xz *= rot((t + sin(t*1.4))*0.6);\n    \n    ro.xz *= rot(m.x/r.x);\n    ro.yz *= rot(m.y/r.x);\n    \n    ro *= 0.5;\n    \n    if(fract(t*0.167) < 0.33)\n        ro = vec3(0,4,0);\n    //if(fract(t*0.15)< 0.25)\n    ro.y *= 0.5;\n    return ro;\n}\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv ){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = normalize(cross(dir,right));\n    return normalize(dir + right*uv.x + up * uv.y);\n}\nmat3 getLookAtMatrix(vec3 ro, vec3 lookAt,float t){\n\n    //ro = vec3(,4,0) + 0.004;\n    float lm = float(fract(t*0.1) <0.5 );\n    lookAt =  vec3(0,0. + lm*0.1 - 2.4*0.,0) + 0.2*sin(t*vec3(1,0.8,0.9));\n    lookAt *= 0.8;\n    \n    \n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = normalize(cross(dir,right));\n    return mat3(right,up,dir);\n}\n\n\n// iq\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n// from iq\nvec3 hsv2rgbSmooth( in vec3 hsv )\n{\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\n\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\n}\n\n\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat luma(vec3 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat sdBox(vec2 c, vec2 s){\n    c = abs(c) - s; return max(c.x,c.y);\n}\n\n\nfloat initTime(float T, vec2 fc, vec2 res){\n    \n    float per = 0.05;\n    \n    float subdivs = (8. + 16.*hash11(floor(T/per)));\n    \n    \n    float subdivIdx = floor(fc.y/res.y*subdivs);\n    \n    float probEnv = fract((T - subdivIdx/subdivs*0.4)*per);\n    \n    \n    probEnv = clamp(probEnv*10.,0.,1.);\n    probEnv *= smoothstep(0.,0.1,probEnv);\n    probEnv *= 1. - smoothstep(0.9,1.,probEnv);\n    \n    \n    \n    if(hardMode(T) == 1.)\n        T -= subdivs*0.6*probEnv;\n    else\n        T += (subdivIdx)/subdivs*0.4*probEnv;\n    \n    \n    return T;\n}\n// cyclic noise by nimitz. i have a tutorial on it on shadertoy\n\nfloat noise(vec3 p_){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,11.);\n    p.xy *= rot(1.4);\n    p.x *= 3.;\n    for(float i = 0.; i < 8.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(1.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 0.7;\n        p *= 1.5*vec4(1,1.5,1,1);\n    }\n    \n    //n = n * 0.9;\n    //n = sin(n*2.);\n    return n;\n}\n\nfloat enva(float t){\n    return (fract(t*0.25*0.25) );\n}\nfloat envb(float t){\n    return (fract(t*0.25 + 0.5) );\n}\n\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "float T;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    T = initTime(iTime, fragCoord, R);\n    \n    fragColor = vec4(0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// raymarch\n\nfloat T;\n\n\nvec4 n14(float f){ return texture(iChannel2,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\nfloat map(vec3 p){\n    vec3 op = p;\n    p.y += (T + sin(T))*0.4;\n    \n    if(lightMode == 0.)\n        p.xz *= rot(p.z + sin(T + p.z)*4.);\n    else\n        p.xz *= rot(p.y + sin(T + p.y)*3.);\n    \n    \n    float d = 10e5;\n    \n    float its = 2.;\n    for(float i = 0.; i < its; i++){\n        vec3 lp = p - vec3(cos(i/its*pi*2.),0,sin(i/its*pi*2.))*sin(T+i + sin(T + i))*1.;\n        \n        \n        if(lightMode == 1.)\n            d = min(d,dot(lp.xz,lp.xz));\n        else\n            d = min(d,length(lp.xz));\n    }\n    \n    return d + sin(p.y + T)*0.3*noise(p*2.*vec3(1.,0.1,4) + vec3(T + sin(T),0,0))*0.4 + smoothstep(2.,3.,abs(op.y));\n}\n\nvoid mainImage( out vec4 C, in vec2 U ){\n\n    T = initTime(iTime, U, R);\n    \n    float sc = 1.;\n    U = floor(U/sc)*sc;\n    \n    vec2 uv = (U-0.5*R.xy)/max(R.x,R.y)*(1. ) ;\n\n    vec3 ro = getRo(T, iMouse.xy, R.xy);\n    \n    //ro.xz *= rot(T);\n    //ro.xy *= rot(sin(T));\n   \n    \n    vec3 lookAt = vec3(0);\n    mat3 lookAtMat = getLookAtMatrix(ro,lookAt,T);\n    vec3 rd = lookAtMat * normalize(vec3(uv,0.5));\n    \n    \n    float t = 0.;\n    vec3 p = ro;\n    bool hit = false;\n    \n    float c = 0.;\n    float planeCnt = 1. + 4.*float(fract(iTime*0.12) > 0.2 || fract(iTime*0.2) < 0.2 );\n    \n    //\n    for(float i = 0.; i < planeCnt; i++){\n        vec3 pp = vec3(0,-i/planeCnt*0.5 - 0.,0);\n        \n        vec4 plane = intersectPlane(ro + pp, rd, vec3(0,1,0));\n        \n        vec3 hitP = ro + rd * plane.x;\n        \n        vec2 pUv = hitP.xz;\n        \n        #define xor(a,b) (int(a) ^ int(b))\n        #define fxor(a,b) float(xor(a,b))\n        \n        float epicSwirly = enva(T);\n        //epicSwirly = 0.;\n        if(hardMode(T) == 1.){\n        \n        } else {\n            //epicSwirly = enva(iTime);\n        }\n        \n        //epicSwirly = 0.;\n        if(epicSwirly < 0.6){\n            //pUv *= 10. + 40.*float(1.-lightMode)*hash11(floor(T*1.) + 20.);\n            pUv *= 20. + 140.*float(1.-lightMode);\n            \n            pUv.x = abs(pUv.x) -120.*(lightMode) ;\n            \n            pUv.y = -abs(pUv.y)- 1.;\n\n            float x = fxor(pUv.x,pUv.y);\n            //x = clamp(x,-100.,11114.);\n            \n            if(lightMode == 0. && fract(T*0.18) < 0.5){\n                pUv *= .15*8.;\n                pUv.xy += T;\n                x -= fxor(pUv.x,pUv.y);\n                c = x*0.8;\n                //c = mix(c,1.-c,x*(1.-0.*pow(hash11(floor(T)),0.06)));\n            }else{\n            \n                if(hash11(floor(T*0.25)) < 0.5)\n                    c = mod(x*0.04 + iTime,4.);\n                if(mod(c,1.) < 0.5)\n                    c = mix(c,1.-c,1. + x*(1. - 1.*pow(hash11(floor(T)),0.06)));            \n                    \n            }\n            //c = x*0.01;\n            \n            //x = mod(x,120.);\n            //c += mod(x*0.05 + iTime*5.,40.);\n            \n\n        } else{\n            vec2 qid = vec2(1);\n            \n            \n            pUv = quantid(pUv,(0.001 + 0.2*hash11(floor(T/0.5))*fcondless(T, 0.34,0.5)*0.06),qid);\n            \n            vec2 ppUv = vec2(0,length(pUv));\n            \n            ppUv.y = log(ppUv.y);\n            \n            float ll = ppUv.y;\n            \n            \n            float h = floor(hash11(floor(iTime))*5.);\n            float hb = pow(hash11(floor(iTime/2. + 200.)),0.4)*5.;\n            \n            \n            vec2 lpp = pUv*rot(sin(ppUv.y*(1. + hb) + T) + ppUv.y*5. + T+ i*4.);\n            \n            ppUv.x = atan(lpp.x,lpp.y);\n            \n            \n            \n            //vec2 md = vec2(1./(5. - 4.*floor(hash11(floor(iTime*12. + 1200.)))));\n            \n            //float hashp = floor(iTime);\n            //hashp = fract(hashp * .1031);\n            //hashp *= hashp + 33.33;\n            //hashp *= hashp + hashp;\n            //float h = fract(hashp);\n            \n            vec2 md = vec2(1./(1. + h));\n            vec2 id = floor(ppUv/md);\n            ppUv = pmod(ppUv,md);\n            \n            \n            \n            float d = length(ppUv.x);\n            \n            if(d < 0.04){\n                c += sin(i +1. + ppUv.y*200.*float(fract(T*0.5)>0.75) + (T*20. + ll*10. + id.x)*float(fract(T*0.25)<0.25));\n            } else {\n                c -= 1.*lightMode;\n            \n            }\n            break;\n            \n        }\n    }\n        \n    \n    \n    uv = U/R.xy*(1. );\n    \n    \n    vec2 st = 1.4/R.xy;\n   \n    float tPrev = Tb(uv).x;\n    float l = \n        Tb(uv + vec2(st.x,0)).x-(Tb(uv - vec2(st.x,0))).x +\n        Tb(uv + vec2(0,st.y)).x-(Tb(uv - vec2(0,st.y))).x\n    ;\n    \n    \n    C.x = c;\n    C.y = l;\n    C.z = t;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// dither\n\n\nfloat T;\nvec3[4*4] palAppleII = vec3[](\n    vec3(217, 60, 240)/255.,\n    vec3(64, 53, 120)/255.,\n    vec3(108, 41, 64)/255.,\n    vec3(0, 0, 0)/255.,\n\n    vec3(236, 168, 191)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(217, 104, 15)/255.,\n    vec3(64, 75, 7)/255.,\n\n    vec3(191, 180, 248)/255.,\n    vec3(38, 151, 240)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(19, 87, 64)/255.,\n\n    vec3(255, 255, 255)/255.,\n    vec3(147, 214, 191)/255.,\n    vec3(191, 202, 135)/255.,\n    vec3(38, 195, 15)/255.\n);\n\n\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n\n\n    //T = initTime(iTime, U, R);\n    T = iTime;\n    vec2 uv = U/R.xy;\n    vec2 t = 1./R.xy;\n    \n    C = Ta(uv);\n    \n    float dith = texture(iChannel1,U.xy/vec2(textureSize(iChannel1,0).xy*(1 + int(fract(T*0.1) < 0.5)))).x;\n    \n    \n    float quant = 1.;\n    float recipQuant = 1./quant;\n    \n    vec4 s = Ta(uv);\n    s = vec4(s.x);\n    \n    \n    \n    vec4 currC = floor(s*quant)/quant;\n    vec4 nextC = clamp(currC + recipQuant,0.,1.);\n    float perc = fract(luma(s)*quant);\n    \n    \n    \n    \n    if(perc>dith){\n        C = nextC;\n    } else{\n        C = currC;\n    }\n   \n    vec3 Chsv = rgb2hsv(C.xyz);\n\n    vec3 hit = vec3(0);\n    float similarity = -0.;\n    for(int i = 0; i < 4*4; i++){\n        vec3 palC = palAppleII[i];\n        \n        vec3 palCHsv = rgb2hsv(palC);\n        \n        float palMod = sin(T*(1. + float(fract(T*0.2)>0.8)*1. ) + C.x*(0.01 + lightMode)+ float(i))*3.;\n        palCHsv.b += palMod;\n        float localSimilarity = dot(palCHsv.b, Chsv.b);\n        \n        if(localSimilarity > similarity){\n            similarity = localSimilarity;\n            hit = palC;\n        }\n    }\n    \n    C = vec4(hit.xyzx);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ui\n\nfloat T;\n \nvec4 n14(float f){ return hash41(f); }\n\n\n\nfloat textb(vec2 p, float[16] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    if(scrobble)\n        char += floor(\n            15. * n14(id.x + idx + (T * 0.05 *sin(idx)+ sin(id.x))*24.).y * \n            pow(abs(sin(T + id.x*0.2 + idx)),1.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (T + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((T - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    \n    float lim = n14(idx + 200.).x*15.;\n   \n   if(id.x > lim && id.x < 18.)\n       return -0.1;\n   if(abs(id.y) < 1. && id.x >= 0. && id.x < 16.   && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\nfloat text(vec2 p, float[4] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    char += floor(hash11(idx)*200.);\n    if(scrobble)\n        char += floor(15. * n14(id.x + idx + (T + sin(id.x))*24.).y*pow(abs(sin(T + id.x*0.2 + idx)),5.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (T + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((T - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 3. - hash11(idx + 20.)*2.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n\n    T = initTime(iTime, U, R);\n    \n    vec2 oU = U;\n    float sc = 1. + 4.*float(fract(T)<0.3)*float(fract(T*0.25)<0.25);\n    U = floor(U/sc)*sc;\n    vec2 uv = (U - 0.5*R.xy)/max(R.x,R.y);\n    \n    \n    float z = Ta(U/R.xy).z;\n    z = 1000000.;\n    //z = z;\n    \n    uv = (U - 0.5*R.xy)/min(R.y,R.x);\n    \n    vec3 ro = getRo(T, iMouse.xy, R.xy);\n    \n    //ro.xz *= rot(T);\n    //ro.xy *= rot(sin(T));\n    float rep = fract(T*0.15) < 0.25 ? 0.04 : 1./min(R.y,R.x);\n    \n    float idd = floor(uv.y/rep);\n    uv.y = floor(uv.y / rep)*rep; \n    \n    vec3 lookAt = vec3(0);\n    mat3 lookAtMat = getLookAtMatrix(ro,lookAt,T);\n    vec3 rd = lookAtMat * normalize(vec3(uv,1.));\n    C -= C;\n      \n   U = oU;\n   uv = (U - 0.5*R.xy)/max(R.y,R.x);\n    \n   // epic text\n   \n           for(float i = 0.; i < 1. - lightMode*10.; i++){\n            vec2 projPos = hash21(floor(i + iTime))*2. - 1.;\n            \n            projPos *= 0.5;\n            \n            vec2 lp = uv - projPos.xy;\n            \n            lp *= 79.4;\n\n            float md = 0.3;\n            float id = floor(lp.y/md);\n            if(id < 1. || id > 5. + sin(i)*1.)\n                continue;\n                \n                \n            lp.y = mod(lp.y,md);\n            float td = textb(lp, float[4*4](\n                103.,103.,103.,103.,\n                103.,103.,103.,103.,\n                103.,103.,103.,103.,\n                103.,96.,96.,96.\n                ), -0.5 , 0.2 , false, 0., 0.4 , true, id + i*40. + floor(iTime*10.));\n            C = mix(C,vec4(1),smoothstep(0.04,0.,td - 0.0));\n        }\n            \n   U = oU;\n    sc = 1. + 15.*float(fract(T)<0.3)*float(fract(T*0.25)<0.25);\n    U = floor(oU/sc)*sc;\n    \n   vec2 u = (U-R.xy*0.5)/R.y;\n   \n   u += 1. - hash11(floor(T) + 200.)*1.8;\n   u *= 0.9 - hash11(floor(T))*0.1;\n   u*=0.51 + floor((hash11(floor(T/3.))*4.));\n   u.x /= 7.;\n   \n\n   \n   \n   \n    \n    //u += 1./3.;\n   if(u.x < 1. && u.y < 0.3 && u.x > 0. && u.y > 0. && fract(T) < 0.2 && sin(T) < 0.){\n       vec4 britney =  texture(iChannel1,u);\n       float dith = texture(iChannel2,oU.xy/vec2(textureSize(iChannel1,0).xy*(4 + 0*int(fract(T*0.1) < 0.2)))).x;\n    \n    \n        float quant = 2.;\n        float recipQuant = 1./quant;\n\n        vec4 s = Tb(uv);\n        vec4 currC = floor(s*quant)/quant;\n        vec4 nextC = clamp(currC + recipQuant,0.,1.);\n        float perc = fract(luma(s)*quant);\n\n\n\n\n        if(perc>dith){\n            britney = nextC;\n        } else{\n            britney = currC;\n        }\n        \n        britney.xyz = rgb2hsv(britney.xyz);\n        britney.xyz = hsv2rgbSmooth(britney.xyz*vec3(110.9,0.5,0.5) + vec3(1. + T,0.2,0.)).xyz;\n        C = britney;\n       C -= 1.- britney;\n       C.w = 1.;\n   } else {\n       C.w = 0.;\n   }\n   \n   \n    \n\n/*\n    vec3 hit = vec3(0);\n    float similarity = -1.;\n    for(int i = 0; i < 4*3; i++){\n        vec3 palC = palAppleII[i];\n        \n        //vec3 palCHsv = hsv2rgbSmooth( in vec3 hsv )\n        vec3 palCHsv = rgb2hsv(palC);\n        \n        float localSimilarity = dot(luma(palC), luma(C));\n        \n        if(localSimilarity > similarity){\n            similarity = localSimilarity;\n            hit = palC;\n        }\n    }\n    C.xyz = hit;\n*/\n    //C = currC;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}