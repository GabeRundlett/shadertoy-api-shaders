{
    "Shader": {
        "info": {
            "date": "1620417165",
            "description": "This method can be applied in many cases. If the curve is too complicated, it may fail.\nIt may not be applied to SDFs of 3D surfaces; the computational cost is too high to be applied to raymarching.",
            "flags": 0,
            "hasliked": 0,
            "id": "fsBXRG",
            "likes": 2,
            "name": "General SDF for C1 Curve",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "IWBTShyGuy",
            "viewed": 444
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2021 IWBTShyGuy\n\nconst int DIV = 100;\nconst int BISECTIONMAX = 10;\n\nconst float PARAM_MIN = -3.0;\nconst float PARAM_MAX = 3.0;\n\nvec2 curve(in float t) {\n    float a[4] = float[](0.0, 2.0 * sin(iTime), 0.0, 0.0);\n    float b[4] = float[](0.0, 2.0 * sin(iTime), 0.0, 1.0);\n    return vec2(\n        a[0] + a[1] * t + a[2] * t * t + a[3] * t * t * t,\n        b[0] + b[1] * t + b[2] * t * t + b[3] * t * t * t\n    );\n}\n\nvec2 derive(in float t) {\n    float a[4] = float[](0.0, 2.0 * sin(iTime), 0.0, 0.0);\n    float b[4] = float[](0.0, 2.0 * sin(iTime), 0.0, 1.0);\n    return vec2(\n        a[1] + 2.0 * a[2] * t  + 3.0 * a[3] * t * t,\n        b[1] + 2.0 * b[2] * t  + 3.0 * b[3] * t * t\n    );\n}\n\n// Roughly find the parameter hint that minimizes the distance between p and curve(hint).\nfloat rough(in vec2 p) {\n    float hint = 0.0, mdist = 10.0;\n    for (int i = 0; i <= DIV; i++) {\n        float t = (PARAM_MAX - PARAM_MIN) * float(i) / float(DIV) + PARAM_MIN;\n        float dist = distance(curve(t), p);\n        mdist = min(dist, mdist);\n        hint = t + sign(dist - mdist) * (hint - t);\n    }\n    return hint;\n}\n\n// Find the critical parameter t of the signed distance between p and curve(t).\nfloat precise(in vec2 p) {\n    float hint = rough(p);\n    float t0 = hint - (PARAM_MAX - PARAM_MIN) / float(DIV);\n    float t1 = hint + (PARAM_MAX - PARAM_MIN) / float(DIV);\n    for (int _i = 0; _i < BISECTIONMAX; _i++) {\n        float f0 = dot(derive(t0), curve(t0) - p);\n        float t = (t0 + t1) / 2.0;\n        float f = dot(derive(t), curve(t) - p);\n        t0 = t0 + max(sign(f * f0), 0.0) * (t - t0);\n        t1 = t1 - min(sign(f * f0), 0.0) * (t - t1);\n    }\n    return (t0 + t1) / 2.0;\n}\n\nfloat sdf(in vec2 p) {\n    float t = precise(p);\n    vec2 c = curve(t);\n    vec2 d = derive(t);\n    float s = sign((p.x - c.x) * d.y - (p.y - c.y) * d.x);\n    return s * distance(p, c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (4.0 * fragCoord - 2.0 * iResolution.xy) / iResolution.y;\n    float d = sdf(uv) / 2.0;\n\n    // iq's SDF coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    fragColor = vec4(col, 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}