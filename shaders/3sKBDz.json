{
    "Shader": {
        "info": {
            "date": "1606930764",
            "description": "This path tracer can only have spheres, and no refractions.  its based of the paper Ray Tracing In One Weekend.",
            "flags": 0,
            "hasliked": 0,
            "id": "3sKBDz",
            "likes": 10,
            "name": "simple path tracer",
            "published": 3,
            "tags": [
                "pathtracing"
            ],
            "usePreview": 0,
            "username": "me_123",
            "viewed": 601
        },
        "renderpass": [
            {
                "code": "float hash(vec2 p) {\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nfloat hash3(vec3 pp) {\n    vec2 p = pp.xy+(pp.z/100.);\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nstruct ray {\n\tvec3 origin;\n    vec3 dir;\n};\nstruct mater {\n\tvec3 color;\n    int mat;\n    float ev;\n};\nstruct rec {\n    float t;\n    vec3  p;\n    vec3  normal;\n    mater mat;\n};\n\nstruct sphere {\n\tfloat radius;\n    vec3 center;\n    mater mat;\n};\nvec4 nois(in vec3 x) {\n\tvec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.);\n    vec3 du = 30.*w*w*(w*(w-2.0)+1.0);\n    float a = hash3(p+vec3(0, 0, 0));\n    float b = hash3(p+vec3(1, 0, 0));\n    float c = hash3(p+vec3(0, 1, 0));\n    float d = hash3(p+vec3(1, 1, 0));\n    float e = hash3(p+vec3(0, 0, 1));\n    float f = hash3(p+vec3(1, 0, 1));\n    float g = hash3(p+vec3(0, 1, 1));\n    float h = hash3(p+vec3(1, 1, 1));\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k3 = e - a;\n    float k4 = a - b - c + d;\n    float k5 = a - c - e + g;\n    float k6 = a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n    return vec4(-1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z),\n                2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z, \n                                k2 + k5*u.z + k4*u.x + k7*u.z*u.x, \n                                k3 + k6*u.x + k5*u.y + k7*u.x*u.y));\n}\nvec4 fbm(in vec3 x, int octives) {\n\tfloat f = 1.98;\n    float s = 0.6;\n    float a = 0.0;\n    float b = 0.3;\n    vec3 d = vec3(0);\n    float o = 0.6;\n    mat3 m = mat3(o, 0, 0, 0, o, 0, 0, 0, o);\n    for (int i = 0; i < octives; i ++) {\n        vec4 n = nois(x);\n        a += b*n.x;\n        d += b*m*n.yzw;\n        b *= s;\n        x = f*m*x;\n        m = f*m*m;\n    }\n    return vec4(a, d);\n}\nvec3 rus(vec2 seed) {\n    float u = hash(seed);\n    float v = hash(seed+2.);\n    float theta = u * 2.0 * 3.1415;\n    float phi = acos(2.0 * v - 1.0);\n    float r = pow(hash(seed+10.), 0.33333333);\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    float x = r * sinPhi * cosTheta;\n    float y = r * sinPhi * sinTheta;\n    float z = r * cosPhi;\n    return vec3(x, y, z);\n}\nint sc = 7;\nsphere scene[7];\nbool hitSphere(vec3 center, float radius, ray r, float t_min, float t_max, out rec re, mater mat) {\n    vec3 oc = r.origin-center;\n    float a = dot(r.dir, r.dir);\n    float b = dot(oc, r.dir);\n    float c = dot(oc, oc) - radius*radius;\n    float disc = b*b - a*c;\n    if (disc > 0.) {\n        float temp = (-b - sqrt(b*b-a*c)) / a;\n        if (temp < t_max && temp > t_min) {\n            vec3 p = r.origin+r.dir*temp;\n            re.t = temp;\n            re.p = p;\n            re.normal = (p - center) / radius;\n            re.mat = mat;\n        \treturn true;\n        }\n        temp = (-b + sqrt(b*b-a*c)) / a;\n        if (temp < t_max && temp > t_min) {\n            vec3 p = r.origin+r.dir*temp;\n            re.t = temp;\n            re.p = p;\n            re.normal = (p - center) / radius;\n            re.mat = mat;\n        \treturn true;\n        }\n    }\n    return false;\n}\nbool hitScene(ray r, float tmin, float tmax, out rec hit) {\n\tbool hitIt = false;\n    float closest = tmax;\n    for (int i = 0; i < sc; i += 1) {\n        if (hitSphere(scene[i].center, scene[i].radius, r, tmin, closest, hit, scene[i].mat)) {\n        \thitIt = true;\n            closest = hit.t;\n        };\n    }\n    return hitIt;\n}\nvoid diffused(out ray r, vec2 seed, rec hit, inout vec3 c) {\n    vec3 target = hit.p + hit.normal + rus(seed);\n    r.origin = hit.p;\n    r.dir = target - hit.p;\n    c *= hit.mat.color;\n}\nvoid gloss(inout ray r, vec2 seed, rec hit, inout vec3 c) {\n    r.origin = hit.p;\n    r.dir = (reflect(r.dir, hit.normal)+(rus(seed)*hit.mat.ev))/hit.mat.ev;\n    c *= hit.mat.color;\n}\nvoid emit(inout ray r, vec2 seed, rec hit, inout vec3 c) {\n    c = hit.mat.color*10.;\n}\nvec3 color(vec3 ro, vec3 rd, vec2 seed) {\n    vec3 c = vec3(1.0);\n    vec3 roo = ro;\n    vec3 rdd = rd;\n    for (int i = 0; i < 100; i += 1) {\n        rec hit;\n        ray r = ray(roo, rdd);\n        if (hitScene(r, 0.001, 10000.0, hit)) {\n            ray rrr = r;\n            if (hit.mat.mat == 0) {diffused(rrr, seed, hit, c);}\n            if (hit.mat.mat == 1) {gloss(rrr, seed, hit, c);}\n            if (hit.mat.mat == 2) {emit(rrr, seed, hit, c);}\n            roo = rrr.origin;\n            rdd = rrr.dir;\n        } else {\n            vec3 dir = normalize(rdd);\n            float t = 0.5*(dir.y+1.);\n            c *= ((1.-t)*vec3(1)+t*vec3(0.5, 0.7, 1.0))/1.;\n            break;\n        }\n\t}\n    return c;\n}\nint samples = 10;\nfloat camSize = 5.;\nvec3 drawImage(in vec2 fragCoord )\n{\n\tscene[0] = sphere(0.5, vec3(0, 0., 0), mater(vec3(0.8, 0.3, 0.3), 0, 0.));\n\tscene[1] = sphere(0.5, vec3(1, 0., 0), mater(vec3(0.8, 0.8, 0), 0, 0.));\n\tscene[2] = sphere(0.5, vec3(-1., 0., 0), mater(vec3(0.8, 0.6, 0.2), 0, 0.));\n\tscene[3] = sphere(0.5, vec3(-1., 1., 0), mater(vec3(0.4), 0, 0.));\n\tscene[4] = sphere(0.5, vec3(1., 1., 0), mater(vec3(0.9), 0, 0.));\n\tscene[5] = sphere(0.5, vec3(0., 1., 0), mater(vec3(0.7), 0, 0.));\n\tscene[6] = sphere(1000.0, vec3(0, -1000.5, -1), mater(vec3(0.8, 0.8, 0.8), 1, 0.1));\n    vec2 mouse = (iMouse.xy/iResolution.xy)-0.5;\n    float r = iResolution.x/iResolution.y;\n    mouse *= (r)*2.;\n    mouse.y = max(mouse.y, -0.1);\n    vec3 c = vec3(0);\n    for (int i = 0; i < samples; i += 1) {\n        vec2 uv = ((fragCoord.xy/iResolution.xy)-0.5) * vec2(r, 1.);\n        uv += (vec2(hash(uv+float(i)), hash(uv+float(i)+float(samples+1)))-0.5)/(iResolution.xy/2.);\n        vec3 ro = vec3(sin(mouse.x*5.)*camSize, mouse.y*camSize, cos(mouse.x*5.)*camSize);\n        vec3 at = vec3(0);\n        vec3 cam_z = normalize(at-ro);\n        vec3 cam_x = normalize(cross(vec3(0, 1, 0), cam_z));\n        vec3 cam_y = cross(cam_z, cam_x);\n        vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 1.5 * cam_z);\n        c += color(ro, rd, uv+(float(i)/1000.));\n    }\n   \treturn vec3(c/float(samples));\n}\nvec2 chunkPos = vec2(0);\nfloat chunkSize = 200.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Render in Tiles So webgl dose not crash (:\n    chunkPos.x = ceil(mod(float(iFrame)*chunkSize, ceil(iResolution.x/chunkSize)*chunkSize)/chunkSize)*chunkSize;\n    chunkPos.y = mod(floor(mod(float(iFrame/int(ceil(iResolution.x/chunkSize)))*chunkSize, iResolution.x)/chunkSize)*chunkSize, iResolution.y);\n\n    float time = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec4 texture = texture(iChannel0,uv);\n    \n    if (fragCoord.x < chunkPos.x+chunkSize && fragCoord.y < chunkPos.y+chunkSize && fragCoord.x > chunkPos.x && fragCoord.y > chunkPos.y) {\n        fragColor = vec4(drawImage(fragCoord), 1);//vec4(texture.rgb,1.); \n    } else {   \n        fragColor = vec4(fragColor.rgb,1.); discard;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}