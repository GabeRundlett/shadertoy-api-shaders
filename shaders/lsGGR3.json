{
    "Shader": {
        "info": {
            "date": "1455559234",
            "description": "Quite simple one, just for practicing\n3 without a revision has been retracted.\n\nReplace Oren-Nayar BRDF with Disney's BRDF (diffuse only)\n\n2: [url]https://www.shadertoy.com/view/4sy3zG[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "lsGGR3",
            "likes": 0,
            "name": "Ray Marching Practice 3b",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "Takoa",
            "viewed": 508
        },
        "renderpass": [
            {
                "code": "// Sphere with Disney's BRDF (diffuse only)\n// \n// Course notes: http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n//------------------------------------------------------------------\n//\n// ALL parts surrounded by \"/* Begin Disney's */\" and /* End Disney's */ are from Disney's codes\n// (https://github.com/wdas/brdf) which are licensed under the license below.\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n// Copyright Disney Enterprises, Inc.  All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License\n// and the following modification to it: Section 6 Trademarks.\n// deleted and replaced with:\n//\n// 6. Trademarks. This License does not grant permission to use the\n// trade names, trademarks, service marks, or product names of the\n// Licensor and its affiliates, except as required for reproducing\n// the content of the NOTICE file.\n//\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n// The codes are slightly modified for compilability, readability\n// and performance.\n\n#define PI 3.141592653\n#define INV_PI 0.3183098861\n#define INV_GAMMA 0.4545454545\n\n#define EPSILON 0.0001\n\nvec3 sphereColor = vec3(0.3, 0.9, 0.6);\n\nvec3 cameraPosition = vec3(0.0, 0.0, 2.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraLookingAt = vec3(0.0, 0.0, -100.0);\n\nfloat roughness = 0.3; // Surface roughness, controls both diffuse and specular response.\nfloat subsurface = 0.0; // Controls diffuse shape using a subsurface approximation.\nfloat sheen = 0.0; // An additional grazing component, primarily intended for cloth.\nfloat sheenTint = 0.0; // Amount to tint sheen towards base color.\n\nfloat getDistanceToSphere(vec3 rayPosition, vec3 spherePosition, float radius)\n{\n    return length(spherePosition - rayPosition) - radius;\n}\n\nfloat getDistance(vec3 position)\n{\n    return min(\n        getDistanceToSphere(position, vec3(-0.5, 0.0, 0.0), 1.0),\n        getDistanceToSphere(position, vec3(0.5, 0.0, 0.0), 1.0));\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n          getDistance(p + vec3(EPSILON, 0.0, 0.0)) - getDistance(p - vec3(EPSILON, 0.0, 0.0)),\n          getDistance(p + vec3(0.0, EPSILON, 0.0)) - getDistance(p - vec3(0.0, EPSILON, 0.0)),\n          getDistance(p + vec3(0.0, 0.0, EPSILON)) - getDistance(p - vec3(0.0, 0.0, EPSILON))\n        ));\n}\n\nvec3 getRayDirection(vec2 screenPosition, vec3 origin, vec3 lookingAt, vec3 up, float fov)\n{\n    vec3 d = normalize(lookingAt - origin);\n    vec3 rayRight = normalize(cross(d, up));\n    \n    return normalize(screenPosition.x * rayRight + screenPosition.y * up + 1.0 / tan(radians(fov / 2.0)) * d);\n}\n\nfloat rayMarch(inout vec3 p, vec3 rayDirection)\n{\n    float d;\n    \n    for (int i = 0; i < 128; i++)\n    {\n        d = getDistance(p);\n        p += d * rayDirection;\n    }\n    \n    return d;\n}\n\nvec3 pow3(vec3 color, float g)\n{\n    return vec3(pow(color.x, g), pow(color.y, g), pow(color.z, g));\n}\n\nfloat getSchlicksApproximation(float f)\n{\n    float g = clamp(1.0 - f, 0.0, 1.0);\n    float g2 = g * g;\n    \n    return g2 * g2 * g;\n}\n\nvec3 getDisneysReflectance(\n    vec3 normal,\n    vec3 lightDirection,\n    vec3 viewDirection,\n    vec3 baseColor,\n    float roughness,\n    float subsurface,\n    float sheen,\n    float sheenTint)\n{\n    float cosL = dot(normal, lightDirection);\n    \n    if (cosL < 0.0)\n        return vec3(0.0);\n    \n    float cosV = dot(normal, viewDirection);\n    float cosD = dot(lightDirection, normalize(lightDirection + viewDirection));\n    float fl = getSchlicksApproximation(cosL);\n    float fv = getSchlicksApproximation(cosV);\n    float fD90M1 = -0.5 + 2.0 * cosD * cosD * roughness;\n    float fD = (1.0 + fD90M1 * fl) * (1.0 + fD90M1 * fv);\n    \n    /* Begin Disney's */\n    float fSS90 = cosD * cosD * roughness;\n\tfloat fSS = mix(1.0, fSS90, fl) * mix(1.0, fSS90, fv);\n\tfloat ss = 1.25 * (fSS * (1.0 / (cosL + cosV) - 0.5) + 0.5);\n    \n    float luminance = 0.298912 * baseColor.x + 0.586611 * baseColor.y + 0.114478 * baseColor.z;\n    vec3 cTint = baseColor / luminance;\n    vec3 cSheen = mix(vec3(1.0), cTint, sheenTint);\n    /* End Disney's */\n    float fh = getSchlicksApproximation(cosD);\n    vec3 fSheen = fh * sheen * cSheen;\n    \n    return (baseColor * INV_PI * mix(fD, ss, subsurface) + fSheen) * cosL;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 lightPosition = vec3(10.0 * cos(iTime), 10.0, 10.0 * sin(iTime));\n    vec3 rayDirection = getRayDirection(position, cameraPosition, cameraLookingAt, cameraUp, 90.0);\n    vec3 p = cameraPosition;\n    float d = rayMarch(p, rayDirection);\n    \n    if (d < EPSILON)\n    {\n        vec3 normal = getNormal(p);\n        vec3 lightDirection = normalize(lightPosition - p);\n        vec3 diffuse = getDisneysReflectance(\n            normal,\n            lightDirection,\n            -rayDirection,\n            sphereColor,\n            roughness,\n            subsurface,\n            sheen,\n            sheenTint);\n        \n        fragColor = vec4(pow3(diffuse, INV_GAMMA), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}