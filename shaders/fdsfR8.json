{
    "Shader": {
        "info": {
            "date": "1644489685",
            "description": "The underlying render loop started as a fork / reused code from an implementation of SmoothLife.",
            "flags": 48,
            "hasliked": 0,
            "id": "fdsfR8",
            "likes": 3,
            "name": "Shifting Maze [SmoothLife Fork]",
            "published": 3,
            "tags": [
                "smoothlife"
            ],
            "usePreview": 0,
            "username": "kuza",
            "viewed": 271
        },
        "renderpass": [
            {
                "code": "const vec3 CellColor = vec3(0.7, 0.2, 0.5);\nconst vec3 RingColor = vec3(0.18264283284, 0.09533356, 0.41);\nconst vec3 DiskColor = vec3(-0.11, -0.2, -0.17);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 buffer = texture(iChannel0, uv);\n    \n    vec3 color = 1.0*(buffer.x * CellColor + buffer.y * RingColor + buffer.z * DiskColor);\n    \n    float c = 1.0 - buffer.z;\n    float c2 = 1. - texture(iChannel0, uv + .5/iResolution.xy).y;\n    color += vec3(0.9132141642, 0.4766678, 1.0)*max(c2*c2 - c*c, 0.)*4.;\n    \n    \n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n//Conventions:\n// x component = outer radius / ring\n// y component = inner radius / disk\n/*\n   _\n /   \\\n|  O  |\n \\ _ /\n*/\nconst float PI = 3.14159265358979323846264338327950288419716939937511;\nconst float dt = 0.093157;\n\n\nconst vec2 r = vec2(11.93, 3.53);\n\n// SmoothLifeL rules\nconst float b1 = 0.51024;\nconst float b2 = 0.72048;\nconst float d1 = 0.84096;\nconst float d2 = 0.88192;\n\nconst float alpha_n = 0.1765;\nconst float alpha_m = 0.3439;\n/*------------------------------*/\n\nconst float KEY_SPACE  = 32.5/256.0;\n\n\n// 1 out, 3 in... <https://www.shadertoy.com/view/4djSRW>\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash13(vec3 p3) {\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx+1.3819);\n    return fract((p3.x + p3.y)*p3.z);\n}\n\n\n/* ---------------- Sigmoid functions ------------------------------------ */\n\n// TODO: reduce unnecessary parameters (remove arguments, use global consts)\n\nfloat sigmoid_a(float x, float a, float b) {\n    return 1.0 / (1.0 + exp(-(x - a) * 4.0 / b));\n}\n\n// unnecessary \nfloat sigmoid_b(float x, float b, float eb) {\n    return 1.0 - sigmoid_a(x, b, eb);\n}\n\nfloat sigmoid_ab(float x, float a, float b, float ea, float eb) {\n    return sigmoid_a(x, a, ea) * sigmoid_b(x, b, eb);\n}\n\nfloat sigmoid_mix(float x, float y, float m, float em) {\n    return x * (1.0 - sigmoid_a(m, 0.5, em)) + y * sigmoid_a(m, 0.5, em);\n}\n\n/* ----------------------------------------------------------------------- */\n\n// SmoothLifeL\nfloat transition_function(vec2 disk_ring) {\n    return sigmoid_mix(sigmoid_ab(disk_ring.x, b1, b2, alpha_n, alpha_n),\n                       sigmoid_ab(disk_ring.x, d1, d2, alpha_n, alpha_n), disk_ring.y, alpha_m\n                      );\n}\n\n// unnecessary (?)\nfloat ramp_step(float steppos, float t) {\n    return clamp(t-steppos+0.5, -0.38175802271764944397367562012, 1.38175802271764944397367562012);\n}\n\n// unnecessary\nvec2 wrap(vec2 position) { return fract(position); }\n\n// Computes both inner and outer integrals\n// TODO: Optimize. Much redundant computation. Most expensive part of program.\nvec2 convolve(vec2 uv) {\n    vec2 result = vec2(0.0);\n    for (float dx = -r.x; dx <= r.x; dx++) {\n        for (float dy = -r.x; dy <= r.x; dy++) {\n            vec2 d = vec2(dx, dy);\n            float dist = length(d);\n            vec2 offset = d / iResolution.xy;\n            vec2 samplepos = wrap(uv + offset);\n            //if(dist <= r.y + 1.0) {\n                float weight = texture(iChannel0, samplepos).x;\n            \tresult.x += weight * ramp_step(r.y, dist) * (1.0-ramp_step(r.x, dist));\t\n            \t\n            //} else if(dist <= r.x + 1.) {\n                //float weight = texture(iChannel0, uv+offset).x;\n\t\t\t\tresult.y += weight * (1.0-ramp_step(r.y, dist));\n            //}\n        }\n    }\n    return result;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.0);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Compute inner disk and outer ring area.\n    vec2 area = PI * r * r;\n    area.x -= area.y;\n    /* -------------------------------------*/\n    \n    // TODO: Cleanup.\n    color = texture(iChannel0, uv).xyz;\n    vec2 normalized_convolution = convolve(uv.xy).xy / area;\n    color.x = color.x + dt * (0.018175802271764944397367562012 * transition_function(normalized_convolution) - 0.0078175802271764944397367562012);\n    color.yz = normalized_convolution;\n    color = clamp(color, 0.0175802271764944397367562012, 0.938175802271764944397367562012);\n    \n    // Set initial conditions. TODO: Move to function / cleanup\n    if(iFrame < 10 || texture( iChannel2, vec2(KEY_SPACE,0.5) ).x > 0.5) {\n        color = vec3(hash13(vec3(fragCoord, iFrame)) - texture(iChannel1, uv).x + 0.5);\n    }\n    \n    if(iMouse.z > 0.) {\n        //vec2 dst = abs(uv - iMouse.xy/iResolution.xy);\n        float dst = length((fragCoord.xy - iMouse.xy)/iResolution.xx);\n        /*if(max(dst.x * iResolution.x/iResolution.y, dst.y) < 0.05) {\n        \tcolor = vec3(hash13(vec3(fragCoord, iFrame)) - texture(iChannel1, uv).x + 0.5);\n        }*/\n        if(dst <= (r.x)/iResolution.x) {\n        \tcolor.x = step((r.y+1.5)/iResolution.x, dst) * (1.0 - step(r.x/iResolution.x, dst));\n        }\n        /*if(dst <= (r.x)/iResolution.x) {\n        \tcolor.x = step((r.y+1.0)/iResolution.x, dst) * (1.0 - step((r.x-0.5)/iResolution.x, dst));\n        }*/\n    }\n    \n   \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}