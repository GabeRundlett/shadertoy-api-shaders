{
    "Shader": {
        "info": {
            "date": "1654406918",
            "description": "Trying to port Felix Westin's minimalAtmosphere to shader toy but I have no idea what I'm doing :)\n\nhttps://github.com/Fewes/MinimalAtmosphere\nhttps://github.com/Fewes/MinimalAtmosphere/blob/master/Assets/Atmosphere/Shaders/Atmosphere.cginc\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ssGcz1",
            "likes": 0,
            "name": "Felix Westin minimalAtmosphere",
            "published": 3,
            "tags": [
                "atmosphere"
            ],
            "usePreview": 0,
            "username": "blahblah",
            "viewed": 265
        },
        "renderpass": [
            {
                "code": "// Copyright (c) 2021 Felix Westin\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// -------------------------------------\n// Defines\n#define EPS 1e-6\n#define PI 3.14159265359\n#define INFINITY 1000000.0 // Had to change this otherwise I got a division by zero 1.0 / 0.0\n#define PLANET_RADIUS 6371000.0\n#define PLANET_CENTER vec3(0, -PLANET_RADIUS, 0)\n#define ATMOSPHERE_HEIGHT 100000.0\n#define RAYLEIGH_HEIGHT (ATMOSPHERE_HEIGHT * 0.08)\n#define MIE_HEIGHT (ATMOSPHERE_HEIGHT * 0.012)\n\n// -------------------------------------\n// Coefficients\n#define C_RAYLEIGH (vec3(5.802, 13.558, 33.100) * 1e-6)\n#define C_MIE (vec3(3.996, 3.996, 3.996) * 1e-6)\n#define C_OZONE (vec3(0.650, 1.881, 0.085) * 1e-6)\n\n#define ATMOSPHERE_DENSITY 1.0\n#define EXPOSURE 20.0\n\n// -------------------------------------\n// Math\nvec2 SphereIntersection(vec3 rayStart, vec3 rayDir, vec3 sphereCenter, float sphereRadius)\n{\n    rayStart -= sphereCenter;\n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(rayStart, rayDir);\n    float c = dot(rayStart, rayStart) - (sphereRadius * sphereRadius);\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.0)\n    {\n        return vec2(-1, -1);\n    }\n    else\n    {\n        d = sqrt(d);\n        return vec2(-b - d, -b + d) / (2.0 * a);\n    }\n}\n\nvec2 PlanetIntersection(vec3 rayStart, vec3 rayDir)\n{\n    return SphereIntersection(rayStart, rayDir, PLANET_CENTER, PLANET_RADIUS);\n}\n\nvec2 AtmosphereIntersection(vec3 rayStart, vec3 rayDir)\n{\n    return SphereIntersection(rayStart, rayDir, PLANET_CENTER, PLANET_RADIUS + ATMOSPHERE_HEIGHT);\n}\n\n// -------------------------------------\n// Phase functions\nfloat PhaseRayleigh(float costh)\n{\n    return 3.0 * (1.0 + costh * costh) / (16.0 * PI);\n}\n// g = 0.85\nfloat PhaseMie(float costh)\n{\n    float g = 0.85;\n    g = min(g, 0.9381);\n    float k = 1.55 * g - 0.55 * g * g * g;\n    float kcosth = k * costh;\n    return (1.0 - k * k) / ((4.0 * PI) * (1.0 - kcosth) * (1.0 - kcosth));\n}\n\n// -------------------------------------\n// Atmosphere\nfloat AtmosphereHeight(vec3 positionWS)\n{\n    return distance(positionWS, PLANET_CENTER) - PLANET_RADIUS;\n}\nfloat DensityRayleigh(float h)\n{\n    return exp(-max(0.0, h / RAYLEIGH_HEIGHT));\n}\nfloat DensityMie(float h)\n{\n    return exp(-max(0.0, h / MIE_HEIGHT));\n}\nfloat DensityOzone(float h)\n{\n    // The ozone layer is represented as a tent function with a width of 30km, centered around an altitude of 25km.\n    return max(0.0, 1.0 - abs(h - 25000.0) / 15000.0);\n}\nvec3 AtmosphereDensity(float h)\n{\n    return vec3(DensityRayleigh(h), DensityMie(h), DensityOzone(h));\n}\n\n// Optical depth is a unitless measurement of the amount of absorption of a participating medium (such as the atmosphere).\n// This function calculates just that for our three atmospheric elements:\n// R: Rayleigh\n// G: Mie\n// B: Ozone\n// If you find the term \"optical depth\" confusing, you can think of it as \"how much density was found along the ray in total\".\nvec3 IntegrateOpticalDepth(vec3 rayStart, vec3 rayDir)\n{\n    vec2 intersection = AtmosphereIntersection(rayStart, rayDir);\n    float rayLength = intersection.y;\n\n    int sampleCount = 8;\n    float stepSize = rayLength / float(sampleCount);\n\n    vec3 opticalDepth = vec3(0.0, 0.0, 0.0);\n\n    for (int i = 0; i < sampleCount; i++)\n    {\n        vec3 localPosition = rayStart + rayDir * (float(i) + 0.5) * stepSize;\n        float localHeight = AtmosphereHeight(localPosition);\n        vec3 localDensity = AtmosphereDensity(localHeight);\n\n        opticalDepth += localDensity * stepSize;\n    }\n\n    return opticalDepth;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth)\n{\n    // Note that Mie results in slightly more light absorption than scattering, about 10%\n    return exp(-(opticalDepth.x * C_RAYLEIGH + opticalDepth.y * C_MIE * 1.1 + opticalDepth.z * C_OZONE) * ATMOSPHERE_DENSITY);\n}\n\n// Integrate scattering over a ray for a single directional light source.\n// Also return the transmittance for the same ray as we are already calculating the optical depth anyway.\nvec3 IntegrateScattering(vec3 rayStart, vec3 rayDir, float rayLength, vec3 lightDir, vec3 lightColor, out vec3 transmittance)\n{\n    // We can reduce the number of atmospheric samples required to converge by spacing them exponentially closer to the camera.\n    // This breaks space view however, so let's compensate for that with an exponent that \"fades\" to 1 as we leave the atmosphere.\n    float rayHeight = AtmosphereHeight(rayStart);\n    float sampleDistributionExponent = 1.0 + clamp(1.0 - rayHeight / ATMOSPHERE_HEIGHT, 0.0, 1.0) * 8.0; // Slightly arbitrary max exponent of 9\n\n    vec2 intersection = AtmosphereIntersection(rayStart, rayDir);\n    rayLength = min(rayLength, intersection.y);\n    if (intersection.x > 0.0)\n    {\n        // Advance ray to the atmosphere entry point\n        rayStart += rayDir * intersection.x;\n        rayLength -= intersection.x;\n    }\n\n    float costh = dot(rayDir, lightDir);\n    float phaseR = PhaseRayleigh(costh);\n    float phaseM = PhaseMie(costh);\n\n    int sampleCount = 64;\n\n    vec3 opticalDepth = vec3(0.0, 0.0, 0.0);\n    vec3 rayleigh = vec3(0.0, 0.0, 0.0);\n    vec3 mie = vec3(0.0, 0.0, 0.0);\n\n    float prevRayTime = 0.0;\n\n    for (int i = 0; i < sampleCount; i++)\n    {\n        float rayTime = pow(float(i) / float(sampleCount), sampleDistributionExponent) * rayLength;\n        // Because we are distributing the samples exponentially, we have to calculate the step size per sample.\n        float stepSize = (rayTime - prevRayTime);\n\n        vec3 localPosition = rayStart + rayDir * rayTime;\n        float localHeight = AtmosphereHeight(localPosition);\n        vec3 localDensity = AtmosphereDensity(localHeight);\n\n        opticalDepth += localDensity * stepSize;\n\n        // The atmospheric transmittance from rayStart to localPosition\n        vec3 viewTransmittance = Absorb(opticalDepth);\n\n        vec3 opticalDepthlight = IntegrateOpticalDepth(localPosition, lightDir);\n        // The atmospheric transmittance of light reaching localPosition\n        vec3 lightTransmittance = Absorb(opticalDepthlight);\n\n        rayleigh += viewTransmittance * lightTransmittance * phaseR * localDensity.x * stepSize;\n        mie += viewTransmittance * lightTransmittance * phaseM * localDensity.y * stepSize;\n\n        prevRayTime = rayTime;\n    }\n\n    transmittance = Absorb(opticalDepth);\n\n    return (rayleigh * C_RAYLEIGH + mie * C_MIE) * lightColor * EXPOSURE;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    // Hack this for now because I don't know how to get world position in shaderToy...\n    vec3 instanceWorldPos = vec3(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y  * 5.0, 0.0);\n    \n    vec3 _WorldSpaceCameraPos = vec3(0.0, 0.0, -10.0);\n    vec3 _WorldSpaceLightPos0 = vec3(0.0, 10.0, 0.0);\n    vec3 _LightColor0 = vec3(0.5, 0.5, 0.5);\n\n    vec3 rayStart = _WorldSpaceCameraPos;\n    vec3 rayDir = normalize(instanceWorldPos - _WorldSpaceCameraPos);\n    float rayLength = INFINITY;\n    \n    float _DrawPlanet = 0.0;\n\n    if (_DrawPlanet == 1.0)\n    {\n        vec2 planetIntersection = PlanetIntersection(rayStart, rayDir);\n        if (planetIntersection.x > 0.0)\n            rayLength = min(rayLength, planetIntersection.x);\n    }\n\n    vec3 lightDir = _WorldSpaceLightPos0.xyz;\n    vec3 lightColor = _LightColor0.xyz;\n\n    vec3 transmittance;\n    vec3 color = IntegrateScattering(rayStart, rayDir, rayLength, lightDir, lightColor, transmittance);\n\n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}