{
    "Shader": {
        "info": {
            "date": "1674270335",
            "description": "My first shader with raymarching",
            "flags": 0,
            "hasliked": 0,
            "id": "mtfSzH",
            "likes": 3,
            "name": "Star Field (raymarching)",
            "published": 3,
            "tags": [
                "raymarching",
                "stars"
            ],
            "usePreview": 0,
            "username": "null_ptr",
            "viewed": 252
        },
        "renderpass": [
            {
                "code": "#define MAX_STEP 32\n#define STAR_RANGE 0.03\n#define PI 3.1415926536\n#define ANGLE PI/6.\n\nfloat hash1( in vec3 p )\n{\n    p  = 50.0*fract( p*2.3183099 );\n    return fract( p.x*p.y*(p.x+p.y + 0.6543) + p.z*22.632334);\n}\n\nvec3 relative_star_pos( in vec3 ind)\n{\n\treturn 0.9 * vec3(hash1(ind * 2.65 + vec3(1.11, 3.67, 4.6)), hash1(ind * 34. + vec3(123.21,657.15, 12.347)), hash1(ind + vec3(0.1,0.2,.04)))*STAR_RANGE;\n}\n\nvec3 absolute_star_pos( in vec3 ind)\n{\n\treturn relative_star_pos(ind) + ind*vec3(STAR_RANGE);\n}\n\nfloat dist_to_nearest_star( out vec3 star_ind, in vec3 p)\n{\n\tvec3 ind0 = floor(p / vec3(STAR_RANGE));\n\tfloat l = 1e10;\n\tfor (int x = -1; x <= 1; x++)\n\t\tfor (int y = -1; y <= 1; y++)\n\t\t\tfor (int z = -1; z <= 1; z++)\n\t\t\t{\n\t\t\t\tfloat new_l = distance(absolute_star_pos(ind0 + vec3(x,y,z)), p);\n\t\t\t\tif (new_l < l)\n                    star_ind = ind0 + vec3(x,y,z), l = new_l;\n\t\t\t}\n\t\n\treturn l;\n}\n\nvec3 star_color (in vec3 ind)\n{\n    return vec3(hash1(ind), hash1(ind + 1.2), hash1(ind*2.46 + 3.567));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0,0,0);\n\t\n\tvec2 mousePos = iMouse.yx/iResolution.yx - vec2(0.25, 0.75);\n\tfloat cos_x = cos(mousePos.x), sin_x = sin(mousePos.x);\n\tfloat cos_y = cos(mousePos.y), sin_y = sin(mousePos.y);\n\tmat3 rot = mat3(cos_y, 0,  sin_y,\n\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t-sin_y, 0, cos_y);\n\trot *= mat3(1, 0, 0,\n\t\t\t\t0, cos_x, -sin_x,\n\t\t\t\t0, sin_x, cos_x);\n\n\tvec3 ro = vec3(0.,0.,-iTime/10.), rd = normalize(rot*vec3(sin(uv * ANGLE), -1.));\n\t\n    //Some noise\n\t//rd += 1e-3 * vec3(hash1(vec3(uv, iTime)) * 2. - 1., hash1(vec3(uv+1.34, iTime*2.378)) * 2. - 1., hash1(vec3(uv*5.6 + 1.4, iTime*12.32)) * 2. - 1.);\n\t\n\tfloat t = 0.;\n\tint i;\n\t\n\tfor (i = 0; i < MAX_STEP; i++)\n\t{\n\t\tvec3 ind0;\n\t\tfloat d = dist_to_nearest_star(ind0, ro + t*rd);\n\t\tt+=d;\n\n\t\tif (t >= 0.5)\n\t\t\tbreak;\n\t\t\n\t\tfloat l = d;\n\t\tl = 1./(1e4*l);\n\t\tl *= pow(1.1, -l*1.);\n\t\tcol += clamp(vec3(l), 0., 1.) * star_color(ind0) * pow(1.1, -t*40.);\n\t}\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}