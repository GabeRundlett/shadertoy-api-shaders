{
    "Shader": {
        "info": {
            "date": "1617744865",
            "description": "I like this shape. Set the ray with the mouse.",
            "flags": 0,
            "hasliked": 0,
            "id": "fs2GRc",
            "likes": 5,
            "name": "Lemniscate Intersect 2D",
            "published": 3,
            "tags": [
                "ray",
                "raycasting",
                "intersect",
                "bernoulli",
                "lemniscate"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 158
        },
        "renderpass": [
            {
                "code": "// Convenience struct\nstruct Hit4 {\n    int numHits;\n    vec4 hits;\n};\n\n// Drawing utilities\n#define drawSDF(dist, transp, col) color = mix(color, col, smoothstep(unit, 0.0, dist) * transp)\n#define drawImplicit(func, ss, transp, col)                                                     \\\n    float total = 0.0;                                                                          \\\n    for (float i=0.0; i < 1.0; i += 1.0 / ss) {                                                 \\\n        for (float j=0.0; j < 1.0; j += 1.0 / ss) {                                             \\\n            vec2 offs = vec2(i, j) / iResolution.xy * 4.0;                                      \\\n            total += step(0.0, -func(uv + offs));                                               \\\n        }                                                                                       \\\n    }                                                                                           \\\n                                                                                                \\\n    color = mix(color, col, total / (ss * ss) * transp);                                        \\\n\n// SDFs\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\n\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdInfLine(in vec2 p, in vec2 a, in vec2 b) {\n    return abs(dot(p - a, normalize(b - a).yx * vec2(-1.0, 1.0)));\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v) {\n    float m = length(v); vec2 n = v / m;\n    p = vec2(dot(p, n.yx * vec2(1.0, -1.0)), dot(p, n));\n    return min(sdVerticalLine(p, m) - 0.025, sdIsosceles(p - vec2(0.0, m), 0.1, 0.15));\n}\n\n// @mla's quartic solver (https://www.shadertoy.com/view/ltVfDK)\nfloat evalcubic(float x, float a, float b, float c, float d) {\n  return ((x * a + b) * x + c) * x + d;\n}\n\nfloat evalquad(float x, float a, float b, float c) {\n  return (x * a + b) * x + c;\n}\n\n// Solve a*x**2 + b*x + c == 0\nbool quadratic(float a, float b, float c, out vec2 t) {\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.0) return false;\n    d = sqrt(d);\n    if (b < 0.0) d = -d;\n    t.x = 0.5 * (-b - d) / a;\n    t.y = c / (a * t.x);\n    if (t.x > t.y) t.xy = t.yx; // Sort results\n    return true;\n}\n\n// Find real root of x**3 + a*x**2 + b*x + c\n// Assume c < 0\nfloat cubic(float a, float b, float c) {\n    // c is always negative, but may be very\n    // small, in which case we return an\n    // approximation. Never return < 0.\n    if (c > -1e-6) {\n        if (b > 1e-10) return -c / b;\n        if (b > -1e-4) return 0.0;\n    }\n\n    // Now substitute to make c = -1\n    float k = 1.0;\n    k = pow(-c, 1.0 / 3.0);\n    a /= k; b /= k * k; c = -1.0;\n    // Now bracket a root between 0 and 1\n    // We may need to solve for 1/x\n    bool reciprocate = evalcubic(1.0, 1.0, a, b, c) < 0.0;\n    if (reciprocate) {\n        float a1 = -b;\n        float b1 = -a;\n        a = a1; b = b1;\n    }\n\n    vec2 res;\n    float x = 0.0;\n    // Chebyshev polynomial: |32x**3 - 48x**2 + 18x - 1| < 1\n    if (quadratic(a + 1.5, b - 0.5625, c + 0.03125, res)) {\n        // Find root closest to unit interval,\n        x = (abs(res[0] - 0.5) < abs(res[1] - 0.5)) ? res[0]: res[1];\n    }\n\n    // 3 rounds of Newton-Raphson\n    x -= evalcubic(x, 1.0, a, b, c) / evalquad(x, 3.0, 2.0 * a, b);\n    x -= evalcubic(x, 1.0, a, b, c) / evalquad(x, 3.0, 2.0 * a, b);\n    x -= evalcubic(x, 1.0, a, b, c) / evalquad(x, 3.0, 2.0 * a, b);\n\n    if (reciprocate) return k / x;\n    return k * x;\n}\n\nint quartic(float c1, float c2, float c3, float c4, out vec4 res) {\n    float alpha = 0.5 * c1;\n    float A = c2 - alpha * alpha;\n    float B = c3 - alpha * A;\n    float a, b, beta, psi;\n    if (B == 0.0) psi = 0.0;\n    else psi = cubic(2.0 * A - alpha * alpha, A * A + 2.0 * B * alpha - 4.0 * c4, -B * B);\n    a = sqrt(psi);\n    beta = 0.5 * (A + psi);\n    if (psi == 0.0) b = sqrt(max(beta * beta - c4, 0.0));\n    else b = 0.5 * a * (alpha - B / psi);\n\n    vec2 tmp;\n    int resn = 0;\n    if (quadratic(1.0, alpha + a, beta + b, tmp)) {\n        res.xy = tmp.xy;\n        resn += 2;\n    }\n\n    if (quadratic(1.0, alpha - a, beta - b, tmp)) {\n        res.zw = res.xy;\n        res.xy = tmp.xy;\n        resn += 2;\n    }\n\n    return resn;\n}\n\n// Intersection\nHit4 iBernoulliLemniscate(in vec2 ro, in vec2 rd) {\n    vec2 oo = ro * ro;\n    vec2 dd = rd * rd;\n    vec2 od = ro * rd;\n\n    float a = dot(dd, dd) + 2.0 * dd.y * dd.x;\n    float b = 4.0 * (od.x + od.y) * (dd.x + dd.y);\n\n    float c1 = 2.0 * ((oo.y - 1.0) * dd.x + (oo.x + 1.0) * dd.y);\n    float c2 = 6.0 * dot(oo, dd) + 8.0 * od.y * od.x;\n    float c = c1 + c2;\n\n    float sq = oo.x + oo.y;\n    float d = 4.0 * ((sq - 1.0) * od.x + (sq + 1.0) * od.y);\n    float e = dot(oo, oo) + 2.0 * ((oo.y - 1.0) * oo.x + oo.y);\n\n    vec4 roots;\n    int numRoots = quartic(b / a, c / a, d / a, e / a, roots);\n\n    return  Hit4(numRoots, roots);\n}\n\n// Implicit\nfloat deBernoulli(in vec2 p) {\n    vec2 p1 = vec2(p.x - 1.0, p.y);\n    vec2 p2 = vec2(p.x + 1.0, p.y);\n    return dot(p1, p1) * dot(p2, p2) - 1.0;\n}\n\n// Normal\nvec2 nBernoulliLemniscate(in vec2 p) {\n    return normalize(p * p * p + vec2(-p.x, p.y) + p.xx * p.yx * p.yy);\n}\n\n// Animation\nvec2 Velocity(in float t) {\n    vec2 p = vec2(0.0);\n    for (float n=0.0; n < 10.0; n++) {\n        float s = pow(2.0, n), ts = t * s;\n        p += vec2(cos(ts), sin(ts)) / s;\n    }\n\n    return p;\n}\n\n// Analytic integral\nvec2 Position(in float t) {\n    vec2 p = vec2(0.0);\n    for (float n=0.0; n < 10.0; n++) {\n        float ts = t * pow(2.0, n);\n        p += vec2(sin(ts), -cos(ts)) / pow(2.0, 2.0 * n);\n    }\n\n    return p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec3 color = vec3(0.5 + 0.5 * nBernoulliLemniscate(uv), 0.0);\n    float unit = 8.0 / iResolution.y;\n\n    vec2 ro = Position(iTime);\n    vec2 rd = Velocity(iTime);\n    if (iMouse.z > 0.0) {\n        ro = mouse.zw;\n        rd = mouse.xy - mouse.zw;\n    }\n\n    drawImplicit(deBernoulli, 8.0, 0.5, vec3(0.0, 0.0, 1.0));\n\n    drawSDF(sdInfLine(uv, ro, ro + rd) - 0.001, 1.0, vec3(0.0));\n    drawSDF(sdVectorArrow(uv - ro, rd), 1.0, vec3(1.0));\n\n    // Find the closest hit in front of the camera\n    Hit4 hit = iBernoulliLemniscate(ro, rd);\n    for (int n=0; n < int(hit.numHits); n++) {\n        vec2 pos = ro + rd * hit.hits[n];\n        drawSDF(length(uv - pos) - 0.05, 1.0, vec3(1.0, 0.0, 0.0));\n    }\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}