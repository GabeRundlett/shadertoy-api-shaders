{
    "Shader": {
        "info": {
            "date": "1716623172",
            "description": "tutorial",
            "flags": 0,
            "hasliked": 0,
            "id": "43c3zS",
            "likes": 4,
            "name": "LearnGL YoungFanYi03",
            "published": 3,
            "tags": [
                "tutorial"
            ],
            "usePreview": 0,
            "username": "YoungFanYi",
            "viewed": 115
        },
        "renderpass": [
            {
                "code": "// 定义S宏 smoothstep函数进行平滑插值\n#define S(a,b,t) smoothstep(a,b,t)\n#define sat(x) clamp(x,0.,1.)\n\nfloat remap01(float a,float b,float t){\n    return sat((t-a)/(b-a));\n}\nfloat remap(float a,float b,float c,float d,float t){\n    return sat(((t - a)/(b - a)) * (d - c) + c);\n}\n\nvec2 within(vec2 uv,vec4 rect){\n    return (uv - rect.xy)/(rect.zw - rect.xy);\n} \n\nvec4 Brow(vec2 uv,float smile) {\n    float offs = mix(.2,0.,smile);\n    uv.y += offs; \n    float y = uv.y; // 保存初始y值\n    uv.y += uv.x * .8 - .3; // 根据x值调整y值，形成眉毛的弯曲\n    uv -= .5; // 将uv坐标中心化\n\n    vec4 col = vec4(0.0); // 初始化颜色为全透明\n    float blur = .1; // 初始模糊值\n\n    // 计算距离和平滑步进\n    float d1 = length(uv);\n    float s1 = S(.45, .45 - blur, d1);\n    float d2 = length(uv - vec2(.1, -.2) * .7);\n    float s2 = S(.5, .5 - blur, d2);\n    float browMask = sat(s1 - s2); // 计算眉毛遮罩\n\n    // 计算颜色遮罩\n    float colMask = remap01(.7, .8, y) * .75;\n    colMask *= S(.6, .9, browMask);\n    vec4 browCol = vec4(.4, .2, .2, 1.);\n\n    uv.y += .15 - offs; // 调整y值形成阴影\n    blur += .1; // 增加模糊值\n    d1 = length(uv);\n    s1 = S(.45, .45 - blur, d1);\n    d2 = length(uv - vec2(.1, -.2) * .7);\n    s2 = S(.5, .5 - blur, d2);\n    float shadowMask = sat(s1 - s2); // 计算阴影遮罩\n\n    // 混合阴影和眉毛颜色\n    col = mix(col, vec4(0., 0., 0., 1.), S(.0, 1., shadowMask) * .5);\n    col = mix(col, browCol, S(.2, .4, browMask));\n\n    return col; // 返回眉毛颜色\n}\n\n// 创建眼睛的视觉效果\nvec4 Eye(vec2 uv,float side,vec2 m ,float smile) {\n    uv -= .5; // 将uv坐标中心化\n    uv.x *= side;\n    float d = length(uv); // 计算从中心到当前点的距离\n    \n    vec4 irisCol = vec4(.0, .5, 1., 1.); // 虹膜颜色\n    \n    vec4 col = mix(vec4(1.), irisCol, S(.1, .7, d) * .5); // 创建渐变颜色\n    \n    col.a = S(.5, .48, d); // 使用smoothstep调整透明度\n    \n    col.rgb *= 1. - S(.45, .5 ,d) * .5 * sat(-uv.y - uv.x* side ) ; \n    \n    \n    \n    float d1 = length(uv - .2 *m); // 计算受限后的偏移量 \n    col.rgb = mix(col.rgb, vec3(0.),S(.3,.28,d1));//iris outline\n    irisCol.rgb *= 1. + S(.3,.05,d1);\n    float irisMask = S(.28,.25,d1);\n    col.rgb = mix(col.rgb, irisCol.rgb,irisMask);\n    \n    \n    float d2 = length(uv - .3 * m);\n    float pupilSize = mix(.4,.16,smile);\n    float pupilMask = S(pupilSize,pupilSize* .85,d2);\n    pupilMask *= irisMask;\n    col.rgb = mix(col.rgb,vec3(0.),pupilMask);\n    \n    /*float pupilMask = S(.2,.14,d2);\n    pupilMask *= irisMask;//to limit the size of the pupil <= iris\n    col.rgb = mix(col.rgb, vec3(0.),pupilMask);*/\n      \n    float t = iTime * 3.;\n    vec2 offs = vec2(sin(t + uv.y*25.),sin(t + uv.x*25.)) ;\n    offs *= .01*(1.-smile);\n    uv += offs;\n    float highlight = S(.1,.09,length(uv-vec2(-.15,.15)));\n    highlight += S(.07,.05,length(uv-vec2(.08,-.08)));\n    \n    col.rgb = mix(col.rgb,vec3(1.),highlight);\n       \n    return col;\n}\n\nvec4 Mouth(vec2 uv,float smile) {\n    uv -= .5; // 中心化uv坐标，使原点位于纹理中心\n    vec4 col = vec4(.5, .18, .05, 1.); // 初始化嘴巴颜色为棕色，完全不透明\n\n    uv.y *= 1.5; // 纵向拉伸uv坐标，调整嘴巴形状\n    uv.y -= uv.x * uv.x * 2.*smile; // 应用二次方曲线，使y坐标随x的平方变化，创建弧形\n    \n    uv.x *= mix(2.,1.,smile);\n    float d = length(uv); // 计算调整后的uv坐标到原点的距离\n    col.a = S(.5, .48, d); // 使用smoothstep平滑边缘，调整透明度，形成边缘模糊效果\n\n    \n    float td1 = length(uv - vec2(0.,-0.5));\n    col.rgb = mix(col.rgb,vec3(1.,.5,.5),S(.5,.2,td1));\n    col.rgb *= 1. - S(.4,.5 ,td1) * .5;\n    \n    float td2 = length(uv - vec2(0., .6)); // 计算uv到(0, 0.6)点的距离，用于添加牙齿\n    \n    vec3 toothCol = vec3(1.) * S(.55,.35,d);\n    \n    col.rgb = mix(col.rgb, toothCol, S(.4, .37, td2)); // 混合原始颜色与白色，根据td的smoothstep结果调整颜色\n    return col; // 返回带有颜色和透明度调整的嘴巴图像\n}\n\n// Head函数：创建头部图形\nvec4 Head(vec2 uv) {\n    // 初始化颜色为橙色，完全不透明\n    vec4 col = vec4(0.9, 0.65, 0.1, 1.);\n\n    // 计算当前像素点到中心点的欧氏距离\n    float d = length(uv);\n\n    // 使用smoothstep函数调整alpha值以创建平滑的边缘过渡\n    // 这样的边缘效果可以使图形在视觉上更柔和，没有硬边\n    col.a = S(0.5, 0.49, d);\n\n    // 创建边缘阴影，使图形边缘更为显著，增加深度感\n    float edgeShade = remap01(.35, .5, d); // 将距离映射到[0,1]，用于阴影计算\n    edgeShade *= edgeShade; // 使阴影更加集中于边缘\n    col.rgb *= 1. - edgeShade * .5; // 根据计算的阴影调整颜色亮度\n\n    // 添加颜色过渡，使头部颜色在特定区域内过渡到不同的颜色\n    col.rgb = mix(col.rgb, vec3(.6, .3, .1), S(.47, .48, d));\n\n    // 添加高光效果，使图形顶部有高光，增加立体感\n    float highlight = S(.41, .405, d); // 根据距离计算高光的基础值\n    highlight *= remap(.41, -.1, .75, 0., uv.y); // 根据垂直位置调整高光的强度\n    highlight *= S(.18,.19,length(uv - vec2(0.21,0.08)));\n    col.rgb = mix(col.rgb, vec3(1.), highlight); // 将高光颜色混合到当前颜色\n    \n    //reuse d val\n    d = length(uv - vec2(.25,-.2));\n    float cheek = S(.2,.01,d) * .4;\n    //col.rgb = mix(col.rgb,vec3(1.,.1,.1),cheek);\n    cheek *= S(.17,.16,d);\n    col.rgb = mix(col.rgb,vec3(1.,.1,.1),cheek);\n    return col; // 返回头部的颜色向量\n}\n\nvec4 Smiley(vec2 uv,vec2 m,float smile) {\n\n    vec4 col = vec4(0.); // 初始化颜色为全透明黑\n    \n    float side = sign(uv.x);\n    uv.x = abs(uv.x);\n    \n    \n    vec4 head = Head(uv); // 获取头部的颜色向量\n    \n    vec4 eye = Eye(within(uv,vec4(.03,-.1,.37,.25)),side,m,smile);\n    \n    vec4 mouth = Mouth(within(uv,vec4(-.3,-.4,.3,-.1)),smile);\n    \n    vec4 brow = Brow(within(uv, vec4(.03, .2, .4, .45)),smile);\n    \n    col = mix(col, head, head.a); // 根据头部的透明度将头部颜色混合到初始颜色中\n    \n    col = mix(col, eye, eye.a);\n    \n    col = mix(col, mouth, mouth.a);\n    \n    col = mix(col, brow, brow.a);\n    \n    return col; // 返回最终的微笑表情的颜色向量\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // 将像素坐标归一化到0到1的范围\n    vec2 uv = fragCoord / iResolution.xy;\n\n    uv -= 0.5; // 将坐标中心移至图像中心\n    uv.x *= iResolution.x / iResolution.y; // 纠正宽高比\n    \n    vec2 m = iMouse.xy / iResolution.xy; // 获取鼠标位置并归一化\n    m -= 0.5; // 将鼠标位置中心化\n    \n    uv -= m * (0.25 - dot(uv, uv)); // 根据鼠标位置和uv的点积调整uv坐标\n    \n    float smile = cos(iTime) * 0.5 + 0.5; // 计算微笑的动态值（0到1之间变化）\n    \n    fragColor = Smiley(uv, m, smile); // 使用Smiley函数生成最终的片元颜色\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}