{
    "Shader": {
        "info": {
            "date": "1611281143",
            "description": "A small thing I made for simulating water use a noise texture\nFor any questions or concerns regarding this shader please contact me on discord: fuzdex#1998",
            "flags": 0,
            "hasliked": 0,
            "id": "wtycDD",
            "likes": 2,
            "name": "Water waves height function",
            "published": 3,
            "tags": [
                "water"
            ],
            "usePreview": 0,
            "username": "fuzdex",
            "viewed": 1171
        },
        "renderpass": [
            {
                "code": "/* \nA little bit of context on this:\nThis is the shadertoy I'm using to test a water wave height function, which will be used in a minecraft shader I'm writing to simulate water\nThe shaders are availbe here: https://github.com/saada2006/MinecraftShaders\n*/\n// Shadertoy to optifine\n#define noisetex iChannel0 // Sample noise from the first channel\n#define frameTimeCounter iTime // frameTimeCounter is iTime\n#define texture2D texture // Since GLSL version 120 only has texture2D, and minecraft shaders for the most part are written in 120\n\nvec4 Cubic(float x)\n{\n    float x2 = x * x;\n    float x3 = x2 * x;\n    vec4 w;\n    w.x =   -x3 + 3.0f*x2 - 3.0f*x + 1.0f;\n    w.y =  3.0f*x3 - 6.0f*x2       + 4.0f;\n    w.z = -3.0f*x3 + 3.0f*x2 + 3.0f*x + 1.0f;\n    w.w =  x3;\n    return w / 6.f;\n}\n\nvec4 BicubicTexture(in sampler2D tex, in vec2 coord, float resolution) {\n\n\tcoord *= resolution;\n\n\tfloat fx = fract(coord.x);\n    float fy = fract(coord.y);\n    coord.x -= fx;\n    coord.y -= fy;\n\n    vec4 xcubic = Cubic(fx);\n    vec4 ycubic = Cubic(fy);\n\n    vec4 c = vec4(coord.x - 0.5, coord.x + 1.5, coord.y - 0.5, coord.y + 1.5);\n    vec4 s = vec4(xcubic.x + xcubic.y, xcubic.z + xcubic.w, ycubic.x + ycubic.y, ycubic.z + ycubic.w);\n    vec4 offset = c + vec4(xcubic.y, xcubic.w, ycubic.y, ycubic.w) / s;\n\n    vec4 sample0 = texture2D(tex, vec2(offset.x, offset.z) / resolution);\n    vec4 sample1 = texture2D(tex, vec2(offset.y, offset.z) / resolution);\n    vec4 sample2 = texture2D(tex, vec2(offset.x, offset.w) / resolution);\n    vec4 sample3 = texture2D(tex, vec2(offset.y, offset.w) / resolution);\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix( mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n}\n\nvec4 BicubicTexture(in sampler2D tex, in vec2 coord) {\n    return BicubicTexture(tex, coord, iChannelResolution[0].x);\n}\n\nconst float freq = 0.5f;\n\n// This is heavily based on SEUS V10.1\nfloat CalculateWaves2D(in vec2 coords) {\n    float AnimationTime = frameTimeCounter * 0.9f;\n    \n    coords *= freq;\n    coords += 10.0f;\n    float waves = 0.0f;\n    coords += AnimationTime / 40.0f;\n    \n    float weight;\n    float weights;\n    \n    weight = 1.0f;\n    waves += BicubicTexture(noisetex, coords * vec2(1.9f, 1.2f) + vec2(0.0f, coords.x * 1.856f)).r * weight;\n    weights += weight;\n    coords /= 1.8f;\n    coords.x -= AnimationTime / 55.0f;\n    coords.y -= AnimationTime / 45.0f;\n    weight = 2.24f;\n    waves += BicubicTexture(noisetex, coords * vec2(1.5f, 1.3f) + vec2(0.0f,coords.x * -1.96f)).r * weight;\n    weights += weight;\n    coords.x += AnimationTime / 20.0f;     \n    coords.y += AnimationTime / 25.0f;\n    coords /= 1.3f;\n    weight = 6.2f;\n    waves += BicubicTexture(noisetex, coords * vec2(1.1f, 0.7f) + vec2(0.0f, coords.x * 1.265f)).r * weight;\n    weights += weight;\n    coords /= 2.2f;\n    coords -= AnimationTime / 22.50f;\n    weight = 8.34f;\n    waves += BicubicTexture(noisetex, coords * vec2(1.1f, 0.7f) + vec2(0.0f, coords.x * -1.8454f)).r * weight;\n    weights += weight;\n    \n    return waves / weights;\n}\n\nfloat CalculateOverlayedWaves2D(in vec2 coords){\n    float waves0 = CalculateWaves2D(coords);\n    float waves1 = CalculateWaves2D(-coords);\n    return sqrt(waves0 * waves1); // take geometric mean of both values\n    \n} \n\nfloat CaclulateWaves3D(in vec3 coords){\n    return CalculateWaves2D(coords.xy + coords.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 texcoord = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(CalculateOverlayedWaves2D(texcoord));\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}