{
    "Shader": {
        "info": {
            "date": "1555692173",
            "description": "Fork of https://www.shadertoy.com/view/ldfGWn\n\nAllows the path animation to still apply in VR mode. Slowed down some to reduce the pukeness, and depending on the headset and configuration, vr_height may need to be adjusted.",
            "flags": 1,
            "hasliked": 0,
            "id": "3lXGR4",
            "likes": 3,
            "name": "Puke in a Can",
            "published": 3,
            "tags": [
                "vr"
            ],
            "usePreview": 0,
            "username": "Mithaldu",
            "viewed": 639
        },
        "renderpass": [
            {
                "code": "float rand(vec3 r) { return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453); }\n\n#define Iterations 64\n#define Thickness 0.1\n#define SuperQuadPower 8.0\n#define Fisheye 0.5\n\nconst float pi=3.141592;\n\nfloat time_divisor = 9.0;\nfloat vr_height = 1.8; // non-vr mode modifies this to speed things up\n\nfloat truchetarc(vec3 pos)\n{\n\tfloat r=length(pos.xy);\n//\treturn max(abs(r-0.5),abs(pos.z-0.5))-Thickness;\n//\treturn length(vec2(r-0.5,pos.z-0.5))-Thickness;\n\treturn pow(pow(abs(r-0.5),SuperQuadPower)+pow(abs(pos.z-0.5),SuperQuadPower),1.0/SuperQuadPower)-Thickness;\n}\n\nfloat truchetcell(vec3 pos)\n{\n\treturn min(min(\n\ttruchetarc(pos),\n\ttruchetarc(vec3(pos.z,1.0-pos.x,pos.y))),\n\ttruchetarc(vec3(1.0-pos.y,1.0-pos.z,pos.x)));\n}\n\nfloat distfunc(vec3 pos)\n{\n\tvec3 cellpos=fract(pos);\n\tvec3 gridpos=floor(pos);\n\n\tfloat rnd=rand(gridpos);\n\n\tif(rnd<1.0/8.0) return truchetcell(vec3(cellpos.x,cellpos.y,cellpos.z));\n\telse if(rnd<2.0/8.0) return truchetcell(vec3(cellpos.x,1.0-cellpos.y,cellpos.z));\n\telse if(rnd<3.0/8.0) return truchetcell(vec3(1.0-cellpos.x,cellpos.y,cellpos.z));\n\telse if(rnd<4.0/8.0) return truchetcell(vec3(1.0-cellpos.x,1.0-cellpos.y,cellpos.z));\n\telse if(rnd<5.0/8.0) return truchetcell(vec3(cellpos.y,cellpos.x,1.0-cellpos.z));\n\telse if(rnd<6.0/8.0) return truchetcell(vec3(cellpos.y,1.0-cellpos.x,1.0-cellpos.z));\n\telse if(rnd<7.0/8.0) return truchetcell(vec3(1.0-cellpos.y,cellpos.x,1.0-cellpos.z));\n\telse  return truchetcell(vec3(1.0-cellpos.y,1.0-cellpos.x,1.0-cellpos.z));\n}\n\nvec3 gradient(vec3 pos)\n{\n\tconst float eps=0.0001;\n\tfloat mid=distfunc(pos);\n\treturn vec3(\n\tdistfunc(pos+vec3(eps,0.0,0.0))-mid,\n\tdistfunc(pos+vec3(0.0,eps,0.0))-mid,\n\tdistfunc(pos+vec3(0.0,0.0,eps))-mid);\n}\n\n// these two just generate a path offset and rotation matrix based on time\n\nvec3 make_location() {\n\tfloat t=iTime/time_divisor;\n\tvec3 ray_pos=vec3(\n\t2.0*(sin(t+sin(2.0*t)/2.0)/2.0+0.5),\n\t2.0*(sin(t-sin(2.0*t)/2.0-pi/2.0)/2.0+0.5),\n\t2.0*((-2.0*(t-sin(4.0*t)/4.0)/pi)+0.5+0.5));\n\treturn ray_pos;\n}\n\nmat3 make_rotation() {\n\tfloat a=iTime/time_divisor;\n\tmat3 m=mat3(\n\t0.0,1.0,0.0,\n\t-sin(a),0.0,cos(a),\n\tcos(a),0.0,sin(a));\n\tm*=m;\n\tm*=m;\n\treturn m;\n}\n\n// due to the VR data lacking details about the orientation of the vr goggles,\n// the rotation component of the path must be applied as a rotation of both\n// the ray position and ray direction around the zero point, after which the\n// translation component of the path can be added\n\nvoid apply_path_to_camera(vec3 path_pos, mat3 path_rotation, inout vec3 ray_pos, inout vec3 ray_dir ) {\n\tvec3 ray_look_at = ray_pos + ray_dir; // store this before modifying the ray position\n\tvec3 rotated_pos = path_rotation * ray_pos; // rotate the ray position around zero point\n\tray_dir = ( path_rotation * ray_look_at ) - rotated_pos;\n\n\tray_pos = path_pos + rotated_pos;           // and store it with the path translation added\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ray_pos, in vec3 ray_dir )\n{\n    ray_pos.y -= vr_height;\n\tapply_path_to_camera(make_location(), make_rotation(), ray_pos, ray_dir);\n\n\tfloat i=float(Iterations);\n\tfor(int j=0;j<Iterations;j++)\n\t{\n\t\tfloat dist=distfunc(ray_pos);\n\t\tray_pos+=dist*ray_dir;\n\n\t\tif(abs(dist)<0.001) { i=float(j); break; }\n\t}\n\n\tvec3 normal=normalize(gradient(ray_pos));\n\n\tfloat ao=1.0-i/float(Iterations);\n\tfloat what=pow(max(0.0,dot(normal,-ray_dir)),2.0);\n\tfloat light=ao*what*1.4;\n\n\tfloat z=ray_pos.z/2.0;\n//\tvec3 col=(sin(vec3(z,z+pi/3.0,z+pi*2.0/3.0))+2.0)/3.0;\n\tvec3 col=(cos(ray_pos/2.0)+2.0)/3.0;\n\n\tvec3 reflected=reflect(ray_dir,normal);\n\tvec3 env=texture(iChannel0,reflected*reflected*reflected).xyz;\n\n\tfragColor=vec4(col*light+0.1*env,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time_divisor /= 3.0; // non-vr mode animates faster\n    \n\tvec2 coords=(2.0*fragCoord.xy-iResolution.xy)/length(iResolution.xy);\n\n\tvec3 ray_dir=normalize(vec3(1.4*coords,-1.0+Fisheye*(coords.x*coords.x+coords.y*coords.y)));\n\n\tmainVR(fragColor,fragCoord,vec3(0.0, vr_height, 0.0),ray_dir);\n\n   \tfloat vignette=pow(1.0-length(coords),0.3);\n\tfragColor.xyz*=vec3(vignette);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}