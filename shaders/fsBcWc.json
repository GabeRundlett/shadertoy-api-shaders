{
    "Shader": {
        "info": {
            "date": "1644181394",
            "description": "move = ESDF             +TG (=up down)   \nrotate = arrows/mouse +WR(roll)\nray2TriangleBezierQuadratic is analytic (4 roots or less) fast and precise\n\nwith quaternion-camera of\nhttps://www.shadertoy.com/view/wtdyRs",
            "flags": 49,
            "hasliked": 0,
            "id": "fsBcWc",
            "likes": 2,
            "name": "quadBezierTriangle QuaternionCam",
            "published": 3,
            "tags": [
                "bspline",
                "bezierpatch",
                "fly",
                "aabv",
                "pqfm",
                "bpatch",
                "quaternioncamera",
                "tracequadratic"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 145
        },
        "renderpass": [
            {
                "code": "//remove the line below to only show the background\n#define showbezier\n\n\n//drag mouse for quaternion rotation\n//arrow keys to accellerate and roll\n\n//grandparent bezierPatch  : https://www.shadertoy.com/view/XsjSDt\n//grandparent flyQuaternion: https://www.shadertoy.com/view/MldczM\n//parent                   : https://www.shadertoy.com/view/ttjSzw\n//self                     : https://www.shadertoy.com/view/wlSyzd\n\n//A triangular cubic bezier patch, bound by 6 CV-heights, \n//is tranceable analytically with good performance and precision\n//for no good reason i never bothered to fix the camera of /XsjSDt, till now\n//and i notice that this shader sucks if the camera is inside the bezier-triangle-prism.\n\n//it works fine, as long as the patch is not too planar\n//any near-planar bezierPatch has a too small determinant which diminishes precision too much.\n//the first few milliseconds of this demo are near-planar\n\n//it works fine as long as the camera is not inside the bounding-prism (incl min&&max height) \n//of the bezier patch\n\n//But if the camera is inside the bezierPrism, the roots are in the wrong order. \n//and it seems to treat roots behind the camera as if they are infront of the camera??\n\n//BUT it always renders 2 patches, and their distance to each other is the distance of the camera to vec3(0)\n//, as if they are mirror images.\n//and they intersect when the camera is close to it.\n//, and they appear to swap places when you move over one of them.\n//and then you may confuse it for its mirror image.\n//unless you have the original inside its AABV\n\n//the open question here is, how to remove the mirror image solution?\n\n//to better approach this, lets add ANY background, with the same camera\n\n\n\n//using\n//https://www.shadertoy.com/view/llj3Rz\n//but with a buffered quaternion camera\n//only to have any backdrop other than a grey void\n\n\n// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n/*\nvoid mainImage(out vec4 o, in vec2 u){\n o=texture(iChannel2,u/iResolution.xy, -100.0 );\n //o=mainImageD(o,u);\n  //o+=mainImage2(o,u);\n}\n*/\n\n\n//using\n//https://www.shadertoy.com/view/llj3Rz\n//but with a buffered quaternion camera\n//only to have any backdrop other than a grey void\n\n// Copyright Inigo Quilez, 2015 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\n\n// https://iquilezles.org/articles/spherefunctions/\nfloat shpIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( rd, oc );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h>0.0 ) h = -b - sqrt( h );\n    return h;\n}\n\n// https://iquilezles.org/articles/spherefunctions/\nfloat sphDistance( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float h = dot( oc, oc ) - b*b;\n    return sqrt( max(0.0,h)) - sph.w;\n}\n\n// https://iquilezles.org/articles/spherefunctions/\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph, in float k )\n{\n    vec3 oc = sph.xyz - ro;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    return (b<0.0) ? 1.0 : 1.0 - smoothstep( 0.0, 1.0, k*h/b );\n}    \n\n// https://iquilezles.org/articles/spherefunctions/\nvec3 sphNormal( in vec3 pos, in vec4 sph )\n{\n    return (pos - sph.xyz)/sph.w;    \n}\n\nvec3 fancyCube( sampler2D sam, in vec3 d, in float s, in float b )\n{\n    vec3 colx = texture( sam, 0.5 + s*d.yz/d.x, b ).xyz;\n    vec3 coly = texture( sam, 0.5 + s*d.zx/d.y, b ).xyz;\n    vec3 colz = texture( sam, 0.5 + s*d.xy/d.z, b ).xyz;\n    vec3 n = d*d;\n    return (colx*n.x + coly*n.y + colz*n.z)/(n.x+n.y+n.z);\n}\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*43758.5453); }\n\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n        vec2  r = g - f + o;\n\t\tfloat d = dot( r, r );\n        if( d<m.x ) m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\n//=======================================================\n\nvec3 background( in vec3 d, in vec3 l )\n{\n    vec3 col = vec3(0.0);\n         col += 0.5*pow( fancyCube( iChannel1, d, 0.05, 5.0 ).zyx, vec3(2.0) );\n         col += 0.2*pow( fancyCube( iChannel1, d, 0.10, 3.0 ).zyx, vec3(1.5) );\n         col += 0.8*vec3(0.80,0.5,0.6)*pow( fancyCube( iChannel1, d, 0.1, 0.0 ).xxx, vec3(6.0) );\n    float stars = smoothstep( 0.3, 0.7, fancyCube( iChannel1, d, 0.91, 0.0 ).x );\n\n    vec3 n = abs(d);\n    n = n*n*n;\n    \n    vec2 vxy = voronoi( 50.0*d.xy );\n    vec2 vyz = voronoi( 50.0*d.yz );\n    vec2 vzx = voronoi( 50.0*d.zx );\n    vec2 r = (vyz*n.x + vzx*n.y + vxy*n.z) / (n.x+n.y+n.z);\n    col += 0.5 * stars * clamp(1.0-(3.0+r.y*5.0)*r.x,0.0,1.0);\n\n    col = 1.5*col - 0.2;\n    col += vec3(-0.05,0.1,0.0);\n\n    float s = clamp( dot(d,l), 0.0, 1.0 );\n    col += 0.4*pow(s,5.0)*vec3(1.0,0.7,0.6)*2.0;\n    col += 0.4*pow(s,64.0)*vec3(1.0,0.9,0.8)*2.0;\n    \n    return col;\n}\n\n//--------------------------------------------------------------------\n\nconst vec4 sph1 = vec4( 0.0, 0.0, 0.0, 1.0 );\n\nfloat rayTrace( in vec3 ro, in vec3 rd )\n{\n    return shpIntersect( ro, rd, sph1 );\n}\n\nfloat map( in vec3 pos )\n{\n    vec2 r = pos.xz - sph1.xz;\n    float h = 1.0-2.0/(1.0+0.3*dot(r,r));\n    return pos.y - h;\n}\n\nfloat rayMarch( in vec3 ro, in vec3 rd, float tmax )\n{\n    float t = 0.0;\n    \n    // bounding plane\n    float h = (1.0-ro.y)/rd.y;\n    if( h>0.0 ) t=h;\n\n    // raymarch\n    for( int i=0; i<20; i++ )    \n    {        \n        vec3 pos = ro + t*rd;\n        float h = map( pos );\n        if( h<0.001 || t>tmax ) break;\n        t += h;\n    }\n    return t;    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 lig = normalize( vec3(1.0,0.2,1.0) );\n    vec3 col = background( rd, lig );\n    \n    // raytrace stuff    \n    float t = rayTrace( ro, rd );\n\n    if( t>0.0 )\n    {\n        vec3 mat = vec3( 0.18 );\n        vec3 pos = ro + t*rd;\n        vec3 nor = sphNormal( pos, sph1 );\n            \n        float am = 0.1*iTime;\n        vec2 pr = vec2( cos(am), sin(am) );\n        vec3 tnor = nor;\n        tnor.xz = mat2( pr.x, -pr.y, pr.y, pr.x ) * tnor.xz;\n\n        float am2 = 0.08*iTime - 1.0*(1.0-nor.y*nor.y);\n        pr = vec2( cos(am2), sin(am2) );\n        vec3 tnor2 = nor;\n        tnor2.xz = mat2( pr.x, -pr.y, pr.y, pr.x ) * tnor2.xz;\n\n        vec3 ref = reflect( rd, nor );\n        float fre = clamp( 1.0+dot( nor, rd ), 0.0 ,1.0 );\n\n        float l = fancyCube( iChannel0, tnor, 0.03, 0.0 ).x;\n        l += -0.1 + 0.3*fancyCube( iChannel0, tnor, 8.0, 0.0 ).x;\n\n        vec3 sea  = mix( vec3(0.0,0.07,0.2), vec3(0.0,0.01,0.3), fre );\n        sea *= 0.15;\n\n        vec3 land = vec3(0.02,0.04,0.0);\n        land = mix( land, vec3(0.05,0.1,0.0), smoothstep(0.4,1.0,fancyCube( iChannel0, tnor, 0.1, 0.0 ).x ));\n        land *= fancyCube( iChannel0, tnor, 0.3, 0.0 ).xyz;\n        land *= 0.5;\n\n        float los = smoothstep(0.45,0.46, l);\n        mat = mix( sea, land, los );\n\n        vec3 wrap = -1.0 + 2.0*fancyCube( iChannel1, tnor2.xzy, 0.025, 0.0 ).xyz;\n        float cc1 = fancyCube( iChannel1, tnor2 + 0.2*wrap, 0.05, 0.0 ).y;\n        float clouds = smoothstep( 0.3, 0.6, cc1 );\n\n        mat = mix( mat, vec3(0.93*0.15), clouds );\n\n        float dif = clamp( dot(nor, lig), 0.0, 1.0 );\n        mat *= 0.8;\n        vec3 lin  = vec3(3.0,2.5,2.0)*dif;\n        lin += 0.01;\n        col = mat * lin;\n        col = pow( col, vec3(0.4545) );\n        col += 0.6*fre*fre*vec3(0.9,0.9,1.0)*(0.3+0.7*dif);\n\n        float spe = clamp( dot(ref,lig), 0.0, 1.0 );\n        float tspe = pow( spe, 3.0 ) + 0.5*pow( spe, 16.0 );\n        col += (1.0-0.5*los)*clamp(1.0-2.0*clouds,0.0,1.0)*0.3*vec3(0.5,0.4,0.3)*tspe*dif;;\n    }\n    \n    // raymarch stuff    \n    float tmax = 20.0;\n    if( t>0.0 ) tmax = t; \n    t = rayMarch( ro, rd, tmax );    \n    if( t<tmax )\n    {\n        vec3 pos = ro + t*rd;\n\n        vec2 scp = sin(2.0*6.2831*pos.xz);\n\n        vec3 wir = vec3( 0.0 );\n        wir += 1.0*exp(-12.0*abs(scp.x));\n        wir += 1.0*exp(-12.0*abs(scp.y));\n        wir += 0.5*exp( -4.0*abs(scp.x));\n        wir += 0.5*exp( -4.0*abs(scp.y));\n        wir *= 0.2 + 1.0*sphSoftShadow( pos, lig, sph1, 4.0 );\n\n        col += wir*0.5*exp( -0.05*t*t );\n    }        \n\n    // outter glow\n    if( dot(rd,sph1.xyz-ro)>0.0 )\n    {\n        float d = sphDistance( ro, rd, sph1 );\n        vec3 glo = vec3(0.0);\n        glo += vec3(0.6,0.7,1.0)*0.3*exp(-2.0*abs(d))*step(0.0,d);\n        glo += 0.6*vec3(0.6,0.7,1.0)*0.3*exp(-8.0*abs(d));\n        glo += 0.6*vec3(0.8,0.9,1.0)*0.4*exp(-100.0*abs(d));\n        col += glo*1.5;\n    }        \n    \n    //col *= smoothstep( 0.0, 6.0, iTime ); //fade in from black\n\n    return col;\n}\n\n/*\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}*/\n\nvec4 mainImage2(in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n#if AA>1\n\t#define ZERO min(iFrame,0)\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif \n\n        float zo = 1.0 + smoothstep( 5.0, 15.0, abs(iTime-48.0) );\n        float an = 3.0 + 0.05*iTime + 6.0*iMouse.x/iResolution.x;\n        \n        //vec3 ro = zo*vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\n        //vec3 rt = vec3( 1.0, 0.0, 0.0 );\n\n       // mat3 cam = setCamera( ro, rt, 0.35 );\n        \n        vec3 ro=get(camP0).xyz;\n        vec4 q=get(camA0); //get() always gets from ichannel2\n        mat3 cam=q2m(q);\n        \n        const float FOV=1.;\n        vec2 uv=(fragCoord-0.5*iResolution.xy)/iResolution.y;\n         vec3 rd=normalize(cam*vec3(1.,FOV*uv));\n        //vec3 rd = normalize( cam * vec3( p, -2.0) );\n\n        col += render( ro, rd );\n\n#if AA>1\n    }\n    col /= float(AA*AA);\n#endif\n\n    vec2 q = fragCoord / iResolution.xy;\n    col *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    vec4 o=texture(iChannel3,fragCoord/iResolution.xy, -100.0 );\n    o=clamp(o,0.,1.);\n   // return mix(fragColor,o,.7);\n    \n    col=clamp(col,0.,1.);\n\treturn vec4( col, 1.0 ) ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 o=vec4(0.);\n    #ifdef showbezier\n    o=texture(iChannel3,fragCoord/iResolution.xy, -100.0 );//the bezier, buffC\n    //o=clamp(o,0.,1.);//safeguard unecessary\n    fragColor =o;\n    #endif\n    if(o.a==0.)   //if(transparent)\n    fragColor=mainImage2(fragCoord);  //backbround == https://www.shadertoy.com/view/llj3Rz\n    //both use quzaternion-camera of buffB\n}\n\n/*\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    float zo = 1.0 + smoothstep( 5.0, 15.0, abs(iTime-48.0) );\n    float an = 3.0 + 0.05*iTime;\n    vec3 ro = zo*vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\n\n    vec3 rt = vec3( 1.0, 0.0, 0.0 );\n    mat3 cam = setCamera( ro, rt, 0.35 );\n    \n    \n    fragColor = vec4( render( ro + cam*fragRayOri,\n                                   cam*fragRayDir ), 1.0 );\n                                   \n  // fragColor=texture(iChannel3,fragCoord/iResolution.xy, -100.0 );\n\n}*/\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Camera Controller (quaternion 2022-02)\n//also contains the non-quaternion camera controller (toggle is [camType] in commontab):\n// // simpler camera, can not roll of https://www.shadertoy.com/view/wttyDX\n// // #define noRollCam     0\n// // quaternion cam,              of https://www.shadertoy.com/view/wtdyRs\n// // #define quaternionCam 1\n// // \n// // #define camType quaternionCam\n\n//note. for cvollision to work, this function needs df() and normal() functions\n//added to collide with a distanceField bacl along a surface normal\n//they are commented out in THIS shader\n\n//full alphabet + arrows\nconst int keyLe=37,keyUp=38,keyRi=39,keyDn=40\n,keyA=65,keyB=66,keyC=67,keyD=68,keyE=69,keyF=70,keyG=71,keyH=72,keyI=73,keyJ=74,keyK=75,keyL=76,keyM=77,keyN=78,keyO=79,keyP=80,keyQ=81,keyR=82,keyS=83,keyT=84,keyU=85,keyV=86,keyW=87,keyX=88,keyY=89,keyZ=90;\n\n//Keyboard constants (ESDF/arrows+TG+MouseDrag)\n//esdf is mor comparible than wasd (especially with french layout)\n//modify inputs by changing the ivec3() below (keys are defined in CommonTab)\nconst ivec3 klp=ivec3(keyF ,keyT ,keyE).zxy//right ,up  ,front      ==+linear strave\n           ,kln=ivec3(keyS ,keyG ,keyD).zxy//left  ,down,back       ==-linear strave\n           //... above .zxy swivel is a porting artefact\n           ,kap=ivec3(keyLe,keyUp,keyR) //kPitchLeft ,kJawUp  ,kRollRight ==+angular rotate\n           ,kan=ivec3(keyRi,keyDn,keyW);//kPitchRight,kJawDown,kRollLeft  ==-angular rotate\n\n//constant code:\nbool key(int k){return texelFetch(iChannel3,ivec2(k,0),0).x>0.5;}\nfloat kg(int k){return texelFetch(iChannel3,ivec2(k,0),0).x;}\nvec3 ks(ivec3 a){return vec3(kg(a.x),kg(a.y),kg(a.z));}//key input subroutine\nvec3 drag(vec3 r,vec3 a,float d){return (r+a*iTimeDelta)*(1.-d*iTimeDelta);}\n\n#if (camType==0) \nvec4 cp0( //non quaternion camera\n){if(iFrame<1)return posStart;\n ;vec4 v=get(camP1)\n ;if(length(v.xyz)>0.1)return vec4(0);\n ;//if(w>0.)c.xyz+=0.1*vec3(sin(iTime),cos(iTime),0.)*speed\n ;return vec4(get(camP0).xyz+v.xyz*abs(v.w),0);}\n#else\nvec4 cp0( //quaternion camers\n//return camera linear Position.xyz (.w is unused)\n){if (iFrame<1)return posStart;\n ;vec3 r=get(camP0).xyz\n ;if(PHYSICS_RADIUS>-99.){\n  ;float d=PHYSICS_RADIUS//-df(r.xyz) //include df() as distance field function here to collide the dcamera\n  ;if (d>0.)r.xyz+=0. //+normal(r)*d //optional collision \n  //include the function that estimates the surface normal of the df() function here \n  //to push the camera away, alogn the surfaceNormal to avoid collisions\n ;}\n ;return vec4(r+(q2m(get(camA0),vec3(0))\n               *vec4(get(camP1).xyz,0)).xyz*iTimeDelta,0);}\n#endif\n\n#if (camType==0) \nvec4 cp1(  //non quaternion camera\n//return camera linear velocity.xyz a vec3 with speed.w as scalart, unaffected by change-of-direction\n){vec4 c=get(camP1)\n ;if(iFrame<1)c.w=CAMERA_SPEED\n ;if(key(keyQ))c.w*=1.01\n ;if(key(keyE))c.w*=0.99\n ;mat3 camera=getCam(get(camA0).xy)\n ;c.w=-sign(c.w)\n ;float s=abs(c.w)*iTimeDelta*.1\n ;if(key(keyUp)||key(keyE))c+=vec4( camera[0]*s,0)\n ;if(key(keyDn)||key(keyD))c+=vec4(-camera[0]*s,0)\n ;if(key(keyRi)||key(keyF))c+=vec4( camera[1]*s,0)\n ;if(key(keyLe)||key(keyS))c+=vec4(-camera[1]*s,0)\n ;c.xyz*=.8 \n ;return c;}\n#else   \n  //quaternion camera\nvec4 cp1(//return camera linear velocity.xyz (.w is unused)\n){return vec4(drag(get(camP1).xyz,LIN_ACCE*(ks(klp)-ks(kln)),LIN_DRAG),0);}\n#endif\n \nconst vec4 rotStart= vec4(.5,0,.27,0)*pi; //vec4(-.27,.5,0,0)*pi;\n#if (camType==0) \nvec4 ca0( //non quaternion camera\n){if(iFrame<1)return rotStart\n ;vec4 c=get(camA0)\n ;c.xy=c.xy+c.zw*MOUSE_SENSITIVITY\n ;c.y=clamp(c.y,pi*.01,pi*.99)\n ;c.zw+=vec2(-1,1)*get(camA1).xy\n ;c.zw*=.6\n ;return c;} \n#else \n//quaternion camera\nvec4 ca0(//return camera angular Position.xyz (quaternion)\n){if (iTime < 0.1)return aa2q(vec3(0,0,1),-2.75)\n ;return normalize(qq2q(eYPR2q(iTimeDelta*get(camA1).zxy),get(camA0)));}\n#endif\n\n#if (camType==0) \n //non quaternion camera\nvec4 ca1(//mouse angularVelocity (just a mouse.xyxy doubleBuffer)\n){if(iFrame<1)return vec4(0,0,iM.xy)\n ;vec4 c=get(camA1)\n ;return vec4((length(iM.zw-iM.xy)>10.)?iM.xy-c.zw:vec2(0),iM.xy);}\n#else\n  //quaternion camera\nvec4 ca1(//return camera angular velocity.xyzw (quaternion)\n){vec3 a=ks(kap)-ks(kan)\n ;if(sign(iMouse.z)==1.)a.xy+=MOUSE_SENSITIVITY*(iM.xy-abs(iM.zw))/iR.xy;\n ;a=clamp(a,-1.,1.)\n ;a=a.yzx\n ;return vec4(drag(get(camA1).xyz,a*ANG_ACCE,ANG_DRAG)\n ,0.);}\n#endif\n\n//keyL and keyP may be used to position 2 seperate light sources \n//at the current camera position, when the key L/P is pressed\nvec4 lightPos(float q,int k,vec4 d\n){if(iFrame<1)return d\n ;vec4 c=get(q)\n ;if(key(k))c.xyz=get(camP0).xyz+vec3(LIGHT_RADIUS*1.3);\n ;return c;}\n \nvec4 cam4(float u//4 buffers for CameraControl\n){if(u<2.){if(u==camP0)return cp0();return ca0();}\n ;         if(u==camP1)return cp1();return ca1();}\n\n//2 buffers for 2 movable light sources\nvec4 switchcase(float u\n){u=floor(u)//essential\n ;if(u<4.)return cam4(u);\n ;if(u==camP0p)return get(camP0)//memorize previous pos\n ;if(u==camA0p)return get(camA0)//memorize previous angle\n ;if(u==li0P0)return lightPos(u,keyL,vec4(.2,.9,0,0))\n ;if(u==li1P0)return lightPos(u,keyP,vec4(-.9,0,0,0))\n ;return vec4(0);}\n\nvoid mainImage(out vec4 c,vec2 u\n){if(!(u.y<0.||u.x<NBuffB))discard\n ;c=switchcase(u.x);}\n \n ",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//2022-02 union of \n//https://www.shadertoy.com/view/wlSyzd (quadratic bezier triangle   2022-01)\n//https://www.shadertoy.com/view/wl3yDs (reproject volume quaternion 2022-02)\n//mostly to improve camera controls\n\n//tags:\n//traceQuadratic,bezierPatch,Quaternioncamera,fly,aabv,bspline,bpatch,pqfm\n\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define vec1 float\nstruct v22{vec3 a,b;};//for 2 domains(density/distance field)\n\n//way too common subroutine shorthands:\n#define pi acos(-1.)\n#define dd(a) dot(a,a)\n#define sat(a) clamp(a,0.,1.)\n#define u2(u) ((u)*2.-1.)\n#define iR iResolution\n#define iM iMouse\nvec3 ma0(vec3 a){return max(a,0.);}\nfloat mu(vec2 a){return a.x*a.y;}float mu(vec3 a){return a.x*a.y*a.z;}\nfloat su(vec2 a){return a.x-a.y;}float su(vec3 a){return a.x+a.y-a.z;}\nfloat ad(vec2 a){return a.x+a.y;}float ad(vec3 a){return a.x+a.y+a.z;}\n//2d rotation matrix from angle(deg)\nmat2 rot(float ang){return mat2(cos(ang),sin(ang),-sin(ang),cos(ang));}\n//return smallest angle between 2 vectors\nfloat AngleBetween(vec3 a,vec3 b){;return acos(dot(a,b)/(length(a)*length(b)));}\n\n\n\n\n\n\n//----- START  of parameters and common functions for camera controls\n//\n//simpler camera, can not roll of https://www.shadertoy.com/view/wttyDX\n#define noRollCam     0\n//\n//quaternion cam,              of https://www.shadertoy.com/view/wtdyRs\n#define quaternionCam 1\n//\n//\n//temporal-Reprojection appears initialize wrongly with quaternionCam (must reset time)\n//\n#define camType quaternionCam\n//[noRoll] camera is worse than [quaternionCam]\n//- does not allow for roll (and thus it never gridlocks)\n//- camAng1 is just a doubleBuffered iMouse.xy (is not true angularVelocity, but has similar effect)\n//- camPos1 (posaition derivative) has a confused .w factor (maxVelocity, but it changes)\n//\n//global buffereB Addresses for camera controls/properties\n//eg: use get(camP1).xyz to get camera position\n//all positions are vec3.xyz\n//all rotations are vec4.xyzw quaternions (stored (very close to) normalized) (for the quaternion camera)\n//all rotations are vec2.xy   jaw+roll    for the non-quaternion camera\nconst float //values must count up from 9, and NBuffB muzst be the last+largest.\n camP0=0.//camera position (0th derivative/time)\n,camA0=1.//camera rotation (0th derivative/time)\n,camP1=2.//camera position (1th derivative/time) == camera velocity\n,camA1=3.//camera rotation (1th derivative/time) == camera momentum\n,li0P0=4.//light0 position\n,li1P0=5.//light1 position\n,camP0p=6.//camera position of previous frame\n,camA0p=7.//camera rotation of previous frame\n,NBuffB=8.//max address count (for Bounding Volume)\n;//\n//camera starting position\nconst vec4 posStart=vec4(-3,3,1,1);\n//\n#if (camType==0) \n #define CAMERA_SPEED .05\n const float MOUSE_SENSITIVITY=.2/60.;\n#else\n const vec2 MOUSE_SENSITIVITY = vec2(-1.,1.)*9.;\n const float\n  //set to -100. to skip collisions\n  //=.01 is reasonable for the mandelbulb distanceField\n  PHYSICS_RADIUS=-100.\n ,LIN_ACCE=7.//linear accelleration\n ,ANG_ACCE=2.//angular accelleration\n ,LIN_DRAG=7.//linear drag\n ,ANG_DRAG=2.//angular drag\n;\n#endif\n//#endif\n//\n//radius of lightSource sphere\n#define LIGHT_RADIUS .01\n//\n#define get(i)texelFetch(iChannel2,ivec2(i,0),0)\nvec4 get2(ivec2 a,sampler2D b){return texelFetch(b,a,0);}\nvec4 get2(float a,sampler2D b){return texelFetch(b,ivec2(a,0),0);}\nvec4 get2(int   a,sampler2D b){return texelFetch(b,ivec2(a,0),0);}\n//----- end of parameters and common functions for camera controls\n\n\n//--- quaternionRotation math (updated 2021-Jan-7) //https://www.shadertoy.com/view/4tSyRz\n//\n//essential for the quaternion-camera.\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\nvec4 qid(){return vec4(0,0,0,1);}//quaternion Identity\n//\n//---quaternion & AxisAngle (==quaternion multiplication)\n//\n//return quaternion from Axis[a] and Angle[r]\nvec4 aa2q(vec3 a,float r){vec2 g=vec2(sin(r),cos(r))*.5;return normalize(vec4(a*g.x,g.y));}\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.);}//assumed q is normalized coverts to axis&angle\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz),(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f//jonathanBlow wrote many documents about better alternatives.\n){float d=dot(a,b),t=acos(abs(d)),o=(1./sin(t));return normalize(a*sin(t*(1.0-f))*o*sign(d)+b*sin(t*f)*o);}\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q//){return q/dd(q) //not as wortksafe, division is slow.\n){float w=dot(q,q);return w==1.?q:.5*(3.-w)*q;}//worksafe and faster: https://www.shadertoy.com/view/llySRh\n//return normalize(q) //unnecessary, as long as lenght(q) is close to 1.\n\n//qexp() qlog() qpow() seem useful for fractals.\nvec4 qexp(vec4 v\n){float a=dot(v.xyz,v.xyz)\n ;if (a<1e-7) return vec4(0,0,0,1)\n ;a=.5*sqrt(a)\n ;return vec4(cos(a),v.xyz*(sin(a)*.5/a));}\nvec4 qlog(vec4 q\n){float l=length(q.xyz),s=2.*atan(l/q.w)/l\n ;return vec4(q.xyz*2.*atan(l/q.w)/l,l);}//bug in qexp, final quat constructor args reversed.\nvec4 wpow(vec4 a,vec4 b){return qexp(qlog(a)*b);}//or something like that\nvec4 qrev(vec4 q){q.w=-q.w;return q;}// conjugate quaternion\n// untested, just tossed together to demo qlog,qexp instead of porting original lol - probably backward\n/*vec4 qq2qLerpBAD(vec4 a, vec4 b, float i){\n    //ERROR; will go around the wrong long-angle hyper-geodesic half-the-time, needs bit of work\n   ;if (dot(a, b) < 0.) b.w = -b.w; // should help\n    return qq2q(a,qexp(qlog(qq2q(qrev(a),b))*i));}//from https://www.shadertoy.com/view/ssGSDm\n*/\n//\n//not sure about more use-cases pf qexp() qlog() qpow()\n//\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\nvec4 qBetween(vec3 a,vec3 b//http://wiki.secondlife.com/wiki/LlRotBetween\n){float v=sqrt(dd(a)*dd(b));if(v==0.)return qid();v=dot(a,b)/v\n ;vec3 c=a.yzx*b.zxy-a.zxy*b.yzx/v;float d=dd(c)\n ;if(d!=0.){float s=(v>-0.707107) ? 1.+v : d/(1.+sqrt(1.-d));return vec4(c,s)/sqrt(d+s*s);}\n ;if(v>0.)return qid()\n ;float m=length(a.xy);return (m!=0.) ? vec4(a.y,-a.x,0,0)/m : vec4(1,0,0,0);\n ;}//Written by Moon Metty, optimized by Strife Onizuka (faster version, without trigonometry)\nvec4 qBetween2(vec3 a,vec3 b){if(a==b)return qid();return aa2q(cross(a,b),AngleBetween(a,b));}//qBetween() with less code, but has some slower or less precise cases.\n//return inverse of quaternion\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dd(q);}\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q,vec3 p){return qq2q(q,qq2q(vec4(p,.0),qinv(q))).xyz;}\n//return [v]vector, rotated by [b] around v2(0)\nv2 r(v3 b,v2 v){\n//return qv2v(b*vec4(1,1,1,-1),v);//somehow this is not identical, fuck it all!\nv2 t=2.*cross(b.xyz, v);return v+b.w*t+cross(b.xyz,t);}//return r(q,r(v3(v,.0),qinv(q))).xyz\n//\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it i rotated by VECTOR p (asif it is a quaternion)\nvec3 vq2v(vec3 p,vec4 q){return qq2q(qinv(q),qq2q(vec4(p,0.0),q)).xyz;}\nvec3 vq2v(vec4 a,vec3 b){return qv2v(a,b);}//in case of namespace confuction\nvec3 qv2v(vec3 a,vec4 b){return vq2v(a,b);}//in case of namespace confuction\n//\n//---quaternion & matrix (second to last in list, because they are bulky)\n//\n//return mat3 of (normalized) [q]uaternion (rotation matrix without translation)\n//uncomment notWorkSafeForNoGoodReason, to break the matrix on some opengl implementations.\n//#define notWorkSafeForNoGoodReason\n//or use mat4 quat_to_transform() (without the translation part) of /WsGfWm\nmat3 q2m(vec4 q //https://www.shadertoy.com/view/WsGfWm\n){vec3 a=vec3(-1,1,0)\n ;mat3 m=mat3(.5)+mat3(q.xzy*a.zxy,q.zyx*a.yzx,q.yxz*a)*q.w\n //above is necessary for compatibility, see /wtdyRs\n +matrixCompMult(outerProduct(q.xyz,q.xyz),1.-mat3(1))//3 unnecessary multy by 0.\n ;q*=q//<-everythig except the main diagonal\n ;m-=mat3(q.y+q.z,0,0,0,q.x+q.z,0,0,0,q.x+q.y)//<- only the main diagonal\n ;return m*2.;}//this *2 scalar may not need to be internal\n//\n//return q2m() as mat4, with [t]ranslation\nmat4 q2m(vec4 q,vec3 t //studying https://www.shadertoy.com/view/WsGfWm\n){mat3 m=q2m(q);return mat4(m[0],0,m[1],0,m[2],0,t,0);}//*=2,and add tranlation\n//return rotation matrix sub of mat4\nmat3 m42Rot(mat4 a){return mat3(a[0].xyz,a[1].xyz,a[2].xyz);}\n#define m2f(a,b) m[a][b]-m[b][a]\nvec4 m2q(mat3 m//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\n){float q=2.*sqrt(abs(1.+m[0][0]+m[1][1]+m[2][2]))//http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n ;return vec4(vec3(m2f(2,1),m2f(0,1),m2f(1,0))/q/4.,q);}\n//\n//---quaternion+ EulerRot (last in list, because they are the worst)\n//\n//eulerRot2Quaternion and back \n//- not elegant, not fast\n//- and theres 6 arbitiary, incompatible and non commutative permutatuions of [yaw opitch roll] order\n//BUT, your keyboard inputs are most likely Euler-rotations, so we have to chose one:\n//wikipedia does (jaw pitch roll) order: of a plane taking of;\n//; (jaw)   first    steers like a car\n//, (pitch) secondly the nose pulls up\n//, (roll)  lastly   and in the air to roll\n//\n//above function is used here, but it lacks an inverse, unlike below other order:\n//\nfloat at2e(vec2 a){a*=2.;return atan(a.x,1.-a.y);}\n//return quaternion of Euler[yaw,pitch,roll]     //this one needs to be phased out\n//float mu(vec3 a){return a.x*a.y*a.z;}\nvec4 eYPR2q(vec3 o){o*=.5;vec3 s=sin(o);o=cos(o)\n//https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n ;vec4 a=vec4(s.xz,o.xz);return  a.yyww*a.zxxz*o.y+a.wwyy*a.xzzx*s.y*vec4(-1,1,-1,1);}\nvec4 eYPR2q(vec2 o){o*=.5;vec2 s=sin(o);o=cos(o)\n ;vec4 a=vec4(s.x,0.,o.x,0.);return  a.yyww*a.zxxz*o.y+a.wwyy*a.xzzx*s.y*vec4(-1,1,-1,1);}\n//return Euler[yaw,pitch,roll]  of quaternion \nvec3 q2eYPR(vec4 q){vec3 r=vec3(0,2.*(q.w*q.y-q.z*q.x),0)\n ;return vec3(at2e(vec2(dot(q.wx,q.zy),dd(q.yz)))          //yaw   (z-axis rotation)\n             //at2e(vec2(q.w*q.z+q.x*q.y,q.y*q.y+q.z*q.z)) //yaw   (z-axis rotation)\n              ,(abs(r.y)>=1.)?r.y=sign(r.y)*pi*.5:asin(r.y)//pitch (y-axis rotation) (worksaved asin())\n              ,at2e(vec2(dot(q.wy,q.xz),dd(q.xy))))        //roll  (x-axis rotation)\n            //,at2e(vec2(q.w*q.x+q.y*q.z,q.x*q.x+q.y*q.y)))//roll  (x-axis rotation)\n ;}//<-untested function\n/*\n//these EulerOrders are being phased out:\n//return quaternion of Euler [pitch, yaw, roll]  //this one needs to be phased out\nvec4 ePYR2q(vec3 o){//return eYPR2q(o.zyx)\n;o*=.5;vec3 s=sin(o);o=cos(o);vec4 a=vec4(s.xy,o.xy)//https://www.shadertoy.com/view/4tSyRz\n ;return a.xyxz*a.wzyw*o.z+a.yxzx*a.zwwy*s.z*vec4(1,-1,1,-1);}\n//return quaternion of EulerRotation [around axes in (Z,Y,X)==(roll,pitch,yaw) order]\nvec4 eRPY2q(vec3 c){c*=.5;vec3 s=sin(c);c=cos(c)//http://wiki.secondlife.com/wiki/LlEuler2Rot\n ;return qq2q(qq2q(vec4(0,0,s.z,c.z),vec4(0,s.y,0,c.y)),vec4(s.x,0,0,c.x));}\n/**/\n\n//from https://www.shadertoy.com/view/wlSyzd\nv3 qlookat(v2 v){return aa2q(v2(-v.y,v.x,0.0),acos(v.z/length(v)));}//point in direction v\nv2 vmulq(v2 p, v3 q){return qq2q(qinv(q),qq2q(v3(p,0.0),q)).xyz;}//inverse rotation\n//---end__ quaternion\n\n\n\n\n\n\n//load and save, originally from iq, modified\nv0 isInside(v1 p,v1 c){v1 d=abs(p-.5-c)-.5;return -max(d.x,d.y);}\n/*v3 load(int re){return texture(iChannel0,(.5+v1(re,.0))/iChannelResolution[0].xy,-100.);}\nvoid store(in int re, in v3 va, inout v3 o, in v1 u\n){if(isInside(u,v1(re,0))>.0)o=va;}//o=(isInside(u,v1(re,0))>.0)?va:o;}\n*/\n\n//#define u2(a)(a*2.-1.)\n#define u5(a)(a*.5+.5)\n//perpendicular dot()used for line intersections.\n#define dotp(a,b)dot(v1(-a.y,a.x),b)\nv0 suv(v1 a){return a.x+a.y;}\nv0 miv(v1 a){return min(a.y,a.x);}\nv0 miv(v2 a){return min(a.z,miv(a.xy));}\nv0 miv(v3 a){return min(miv(a.zw),miv(a.xy));}//return min domain of vector.\n#define mav(a)-miv(-a)\n#define sat(a)clamp(a,0.,1.)\nv3 minx(v3 a,v3 b){return mix(b,a,step(a.x,b.x));}//return the v3 with the smaller .x\n\nv0 suv(v2 a){return a.x+a.y+a.z;}\n//v0 ad(v1 a){return a.x+a.y;}\n//v0 mu(v1 a){return a.x*a.y;} \n\n#define rs3 sqrt(3.)\n#define rs5 sqrt(5.)\n#define phi u4(rs5)\n#define Phi u5(rs5)\n//(reciprocal) [skewConstant] arithmetic:   [rs*]==[reciprocal square of *]\n// ske==.36602540378;//==sqrt(3.)*.5-.5\n//#define   ske u4(rs3)\n//reSke=.21132486540;//==(sqrt(3.)*.5-.5)/sqrt(3.)==.5-.5/sqrt(3.)\n//#define reSke u4(rs3)/rs3\n//enter [0.366025] or [.2113248654] in search engines and be amazed by peoplewho use values without knowing them\n//v1   skew(v1 u){return u+ad(u)*ske;}\n//v1 unskew(v1 u){return u-ad(u)*reSke;}\nv0 det2d(v1 a,v1 b){return a.x*b.y-a.y*b.x;}//2d determinant(mat2(a,b))-=perpendicular dotproduct\n\n//instead of doing imouse.zw=abs(imouse.zw) iMouseZwFix only changes sign when needed.\nvec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n  \n//checkerboard of https://www.shadertoy.com/view/4lySzc\nv0 board(v2 p){p=floor(p*2.);return mod(p.x+p.y+p.z,2.);}\nv0 board(v1 p){p=floor(p*2.);return mod(p.x+p.y,2.);}\n\n//a matrix of quadraticFields, that share no prime factors, is a fast and simple hash.\nmat3 opop(v2 a,v2 b){return outerProduct(a,v2(1))\n                           +outerProduct(  v2(1),b);}\nmat3 pqfmA(){return opop((v2(2,7,5)),sqrt(v2(13,21,17)));}\n//matrix of quadratic fields with unique prime factors to maximize period length\n//also has the neat effect of all starting at null, which tends to be (near) a special (coplanar) case\n// that we can then skip over and safely assert to not reorrur anytime soon.\n//maybe see https://www.shadertoy.com/results?query=pqfm\n\n//random number (permuted congruential generator)\nuvec4 s0,s1;//internal RNG state \nivec2 pixel;//internal RNG state \nvoid rng_initialize(vec2 p,int frame\n){pixel=ivec2(p)\n ;s0=uvec4(p,uint(frame),uint(p.x)+uint(p.y))//white noise seed\n ;s1=uvec4(frame,frame*15843,frame*31+4566,frame*2345+58585)//blue noise seed\n ;}\nuvec4 pcg4d(uvec4 v//https://www.pcg-random.org/\n){v=v*1664525u+1013904223u\n ;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z\n ;v=v ^ (v>>16u)\n ;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z\n ;return v;}\n//float rand(){return float(pcg4d(s0).x)/float(0xffffffffu);}\nvec2 rand2(){return  vec2(pcg4d(s0).xy)/float(0xffffffffu);}\n//vec3 rand3(){return  vec3(pcg4d(s0).xyz)/float(0xffffffffu);}\nvec4 rand4(){return  vec4(pcg4d(s0))/float(0xffffffffu);}\nivec2 shift2(//random blue noise sampling pos\n){return (pixel+ivec2(pcg4d(s1).xy%0x0fffffffu))%1024;}\nvec3 udir(//uniformly spherically distributed\n){vec2 rng=rand2()\n ;vec2 r=vec2(2.*pi*rng.x,acos(2.*rng.y-1.))\n ;vec4 c=vec4(cos(r),sin(r))\n ;return vec3(c.xz*c.ww,c.y);}\nfloat HenyeyGreenstein(float g,float costh\n){return (1.-g*g)/(4.*pi*pow(1.0+g*g-2.0*g*costh,3./2.));}\n \nfloat sdBox(vec3 p,vec3 b\n){vec3 q=abs(p)-b\n ;return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.);}\n\n//subroutines of   https://www.shadertoy.com/view/XlVyDK\n#define le(a) sqrt(dd(a))\n#define co(a) cos(a)\n#define si(a) sin(a)\n//real and imaginary parts for polar z\nfloat arg(vec2 a){return atan(a.y,a.x);}\nvec2 c2p(vec2 a){return vec2(arg(a),le(a));}\nvec2 p2c(vec2 a){return vec2(co(a.x),si(a.x))*a.y;}\nfloat real(vec2 z){return p2c(z).x;return z.s*co(z.t);}\nfloat imag(vec2 z){return p2c(z).y;return z.s*si(z.t);}\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)//repetitive only for less repetitive legacy namespace support.\nvec1 pModMirror1(inout vec1 p,vec1 s){float c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pmod(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);p=mix(p,(fract((p/s)+.5)-.5)*s,step(p,0.));return c;}\nfloat pModPolar(inout vec2 p,float t\n){vec2 q=c2p(p)\n ;float v=pi/t\n ;q.x+=v//offset by half-axis\n ;float c=floor(q.x*.5*v)\n ;q.x=mod(q.x,2.*v)-v\n ;p=p2c(q)\n ;if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size\n){vec2 c=floor((p+size*.5)/size)\n ;p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5\n ;if(p.x>p.y)p.xy=p.yx;return floor(c*.5)\n ;}\n\n\nvec3 repeat(vec3 u){//return u;\n ;vec3 v=pmod(u,vec3(2.8));return u\n ;}\n\n//- distance Field\n\n/*\n//mandelbulb fractal\nvec3 pq(vec2 a){return vec3(a.x*a.x,a.x*a.y,a.y*a.y);}\nfloat pow7(float a){float b=a*a;float c=b*b;return a*b*c;}\n//mandelbulb.core \n//o.x=distance, o.yzw are for orbittrap memory\n//w.xyz=uv    ,w.w=dd(uv)\nvoid mandelCore(inout vec4 o,inout vec4 w,vec3 u\n){o.x=8.*sqrt(pow7(w.w))*o.x+1.\n ;vec3 w2=w.xyz*w.xyz,w4=w2*w2\n ,e=vec3(ad(w2.xz)\n        ,ad(w4)-6.*dot(w2.zx,w2.yy)+2.*mu(w2.xy)\n        ,su(w2.zxy))\n ;w.xyz=u+vec3( 64.*mu(w.xyz)*su(w2.xz)*ad(pq(w2.xz)*vec3(1,-6,1))\n              ,-16.*w2.y*mu(e.xzz)+e.y*e.y\n              ,-8.*w.y*(dd(w4.xz)+mu(w2.xz)*(-28.*w4.x+70.*mu(w2.xz)-28.*w4.z)))\n              *(vec3(0,1,0)+vec3(1,0,1)*e.z*e.y*inversesqrt(pow7(e.x)))\n ;w.w=dd(w.xyz);}\nvec4 mandelBulbO(vec3 u//return distance.x,orbittrap.yzw\n){vec4 w=vec4(u,dd(u)),o=vec4(1)\n ;for(int i=0;i<5;i++\n ){if(w.w>1.2)break\n  ;mandelCore(o,w,u)\n  ;o.yzw=min(abs(w.xyz)*1.2,o.yzw);}\n ;o.x=0.25*log(w.w)*sqrt(w.w)/o.x;return o;}\nfloat mandelBulb(vec3 u//return distance.x,orbittrap.yzw\n){vec4 w=vec4(u,dd(u)),o=vec4(1)\n ;for(int i=0;i<5;i++\n ){if(w.w>1.2)break\n  ;mandelCore(o,w,u)\n  ;o.yzw=min(abs(w.xyz)*1.2,o.yzw);}\n ;return 0.25*log(w.w)*sqrt(w.w)/o.x;}\n\n//float df (vec3 u){u=repeat(u);return mandelBulb (u);}\n//vec4  dfo(vec3 u){u=repeat(u);return mandelBulbO(u);}\n\n\nvec3 normal(in vec3 p\n){vec2 e=vec2(-1,1)*.001\n ;return normalize(e.yxx*df(p+e.yxx)+e.xxy*df(p+e.xxy)\n                  +e.xyx*df(p+e.xyx)+e.yyy*df(p+e.yyy));}\n*/\n\n\n//damn, this is a fisheye cam that is just as complex.\n//in short i fail\n\n//getRayDir() lookAtCamera is 3* normalize(cross()), it seems to be a lazy and slow camera.\n//quatrernion alternatives exist:\n//https://www.shadertoy.com/view/wl3yDs\n//commontab has quaternion functions:\nvec3 getCam(vec3 ro, vec3 lookAt, vec2 uv\n){/*\n ;vec3 f = normalize(lookAt - ro)\n ,r = normalize(cross(vec3(0, 1, 0), f))\n ;return normalize(f + r * uv.x + cross(f, r) * uv.y);/**/\n ;\n ;vec4 quatUv=eYPR2q(vec3(uv,0.).zxy)//fragCoord.xy/iResolution*2.-1.) //uv.y not scaled by AspectRatio?\n ;lookAt=normalize(lookAt-ro)\n ;vec3 rayDirection=qv2v(quatUv,lookAt)*vec3(1,-1,1)\n ;return rayDirection;}\n /**/\n\nmat3 getCam(vec2 a// phi.x,theta.y\n){vec3 x_dir=vec3(cos(a.x)*sin(a.y),sin(a.x)*sin(a.y),cos(a.y))\n ;vec3 y_dir=normalize(cross(x_dir,vec3(0,0,1)))\n ;vec3 z_dir=normalize(cross(x_dir,y_dir))\n ;return mat3(x_dir,y_dir,z_dir);}\n\nmat3 getCam(sampler2D s//buffer is a quaternion\n){return q2m(get2(camA0,s));}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//buffC.start\n//ichannel0=self\n//ichannel1=keyIn\n\n//scaling to merger this with others as enironment-set\nconst float scale=.2;\n\n//this buffer has its own shitty cameraControls\n//, to be replaced by the camera control of BuffB\n\n/*\nbezier patch analytic: https://www.shadertoy.com/view/4tSyRz\n- single page, less duped code. trutural sorting \n- less globals, more object oriented.\n- more defines\n- larger render distance.\n- establishing [tiny namespace convention]\n- - mostly in scene()\n- - distance field is called gd() and gd1()for colors (resolves fractal G-buffer stuff?)\nparent: https://www.shadertoy.com/view/lsd3Dl\n  Rocket City by eiffie (although there are no rockets \n   and there is little if any esemblance to a city this is what eiffie called it)\n  eiffie just wanted to make a reusable flight control \n   but then messed that up with collision detection.\n*/\n\n//Cartesian to barycentric(relative to spline verts)\nv2 CartToBary(v1 c,v1 p1,v1 p2,v1 p3\n){c-=p1;v1 a=p2-p1,b=p3-p1,d=v1(dot(c,b),dot(c,a))\n ;v2 r=v2(dd(a),dd(b),dot(a,b))\n ;r=v2(0.,det2d(r.yz,d),det2d(r.xz,d.yx))/det2d(r.yz,r.zx)\n ;return v2(1.-r.y-r.z,r.yz);}\n\n//quaternions q()<->creation r()<->rotaition\n//use like matrix multiplication, see https://www.shadertoy.com/view/lstSRM\n//normalize quaternion: true for quaternions <-> nornamoze(q)=q/length(q)==q/length(q*q)=q/dot(q,q)\n//v3 qid(){return v3(0,0,0,1);}//NULL_ROTATION\n//v3 qinv(v3 q){return v3(-q.xyz,q.w)/dd(q);}//inverse quaternion\nv3 q(v2 o){o*=0.5;v2 s=sin(o),c=cos(o) //quaternion from pitch,yaw,roll (in that order):\n          ;return v3(s.x*c.y*c.z+s.y*c.x*s.z,s.y*c.x*c.z-s.x*c.y*s.z\n,s.x*s.y*c.z+s.z*c.x*c.y, c.x*c.y*c.z-s.x*s.y*s.z);}\nv3 q(v3 q){return q/dd(q);} //normalize quaternion (may be needed after every 5th rotation)\n//return quaternin of [axis]&{angle] rotation\n//v3 q(v2 axis, v0 angle){angle*=.5;return v3(axis*sin(angle),cos(angle));}\n//return [r]rotation, rotated by [b]\n//v3 r(v3 b,v3 r){return v3(b.w*r.xyz+r.w*b.xyz+cross(b.xyz,r.xyz),b.w*r.w-dot(b.xyz,r.xyz));}\n//return p, rotated by b, AROUND c (center) instead of around v2(0) (offset rotation)\n//v2 r(v3 b,v2 p,v2 c){return r(b,p+c)-c;}\n//return shortest rotation fro+\n//get rotation from a to b (around v2(0), has higher precision for small angles: Written by Moon Metty, optimized by Strife Onizuka\n\n\n//trace AABV-box 3d,2d,1d, all worksave, reciprocal direction replaces a lot of branching and epsilon nonsense\n//is more precise the closer length(direction) is to 1\n//returns: .x if box is hit, .y=far root, .y=near root.\n//rayorigin,raydirection,lowcorner,highcorner\n//worksaving, if(one domain of raiDir ==0) this is a simpler special case with one less domain.\n#define TABV(a,b) if(d.a==0.)return abv(d.b,l.b,h.b)\nv2 abv(v0 d,v0 l,v0 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){if(d==0.)return v2(0)//directionless ray is not a ray\n ;d=1./d;l=l*d;h=h*d\n ;d=min(h,l);h=max(h,l);return v2(v0(h>max(d,0.)),h,d);}\nv2 abv(v1 d,v1 l,v1 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,y);TABV(y,x);d=1./d;l=l*d;h=h*d\n ;v0 o=mav(min(h,l))\n ;h.x=miv(max(h,l))\n ;return v2(v0(h.x>max(o,0.)),h.x,o);}\nv2 abv(v2 d,v2 l,v2 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,yz);TABV(y,xz);TABV(z,xy);d=1./d;l=l*d;h=h*d\n ;v2 o=min(h,l)\n ;h=max(h,l)\n ;o.xy=max(o.xx,o.yz);o.z=mav(o.xy)\n ;o.xy=min(h.xx,h.yz);o.x=miv(o.xy)\n ;return v2(v0(o.x>max(o.z,0.)),o.x,o.z);}\n#define aabv(o,d,l,h) abv(d,l-o,h-o)\n\nv2 triangleNornal(v2 a,v2 b,v2 c){return cross(a-b,a-c);}//normal of triangle of 3 pointsi is cross() of any 2 sides.\n\n//LineSegmentAB+RayUD intersection\nv1 LineISect(v1 a,v1 b,v1 u,v1 d\n){vec4 c=vec4(b.y-a.y,a.x-b.x,d.y-u.y,u.x-d.x)\n ;u=v1(dot(c.zw,u),det2d(c.xy,c.zw))\n ;if(u.y==0.)return v1(0)//parralel lines do not intersect.\n ;c*=v3(u.xx,vec2(dot(c.xy,a)))\n ;return (c.wx-c.yz)/u.y;}\n\n/* //explicit version for compatibility where bvec4 is not a defined type.\nbool altm(v1 a,v3 b){\n ;v3 c=v3(a,b.zw)\n ;b=v3(b.xy,a)\n ;if(c.x<b.x)return true;\n ;if(c.y<b.y)return true;\n ;if(c.z<b.z)return true;\n ;if(c.w<b.w)return true;\n ;return false\n ;//return any(lessThan(v3(a,b.zw),v3(b.xy,a)))\n ;}*/\n\n\n/*\n//grandparent backup version to check errors\nv1 v2VertA = v1( 0.0, 4.0 ); \nv1 v2VertB = v1(-4.0,-4.0 );\nv1 v2VertC = v1( 4.0,-4.0 );\n#define D_BIAS 0.0001\nv2 CartToBary( v1 v2Cart ){\n    v1 w0 = v2VertB - v2VertA;\n    v1 w1 = v2VertC - v2VertA;\n    v1 w2 = v2Cart - v2VertA;\n    v0 d00 = dot(w0, w0);\n    v0 d01 = dot(w0, w1);\n    v0 d11 = dot(w1, w1);\n    v0 d20 = dot(w2, w0);\n    v0 d21 = dot(w2, w1);\n    v0 denom = d00 * d11 - d01 * d01;\n    v2 v3Bary;\n    v3Bary.y = (d11 * d20 - d01 * d21) / denom;\n    v3Bary.z = (d00 * d21 - d01 * d20) / denom;\n    v3Bary.x = 1.0 - v3Bary.y - v3Bary.z;\n    return v3Bary;}\nv3 BezierTriISect( const v2 v3CameraPos, const v2 v3LookDir, v2 CP_2, v2 CP_0 ){\n    v1 v2LookPt = v3CameraPos.xy + v3LookDir.xy;\n    //This is a hacky brute-force way of finding limits of triangle bounding retion.  \n    // I will probably re-write this with a better approach.\n    v1 v2PosA = LineISect( v2VertA, v2VertB, v3CameraPos.xy, v2LookPt );\n    v1 v2PosB = LineISect( v2VertB, v2VertC, v3CameraPos.xy, v2LookPt );\n    v1 v2PosC = LineISect( v2VertC, v2VertA, v3CameraPos.xy, v2LookPt );\n    v1 v2MinA = v1( min( v2VertA.x, v2VertB.x ), min( v2VertA.y, v2VertB.y ) ) - D_BIAS;\n    v1 v2MinB = v1( min( v2VertB.x, v2VertC.x ), min( v2VertB.y, v2VertC.y ) ) - D_BIAS;\n    v1 v2MinC = v1( min( v2VertC.x, v2VertA.x ), min( v2VertC.y, v2VertA.y ) ) - D_BIAS;\n    v1 v2MaxA = v1( max( v2VertA.x, v2VertB.x ), max( v2VertA.y, v2VertB.y ) ) + D_BIAS;\n    v1 v2MaxB = v1( max( v2VertB.x, v2VertC.x ), max( v2VertB.y, v2VertC.y ) ) + D_BIAS;\n    v1 v2MaxC = v1( max( v2VertC.x, v2VertA.x ), max( v2VertC.y, v2VertA.y ) ) + D_BIAS;\n    bool bAValid = \n        v2PosA.x >= v2MinA.x && v2PosA.x <= v2MaxA.x && \n        v2PosA.y >= v2MinA.y && v2PosA.y <= v2MaxA.y;\n    bool bBValid =\n        v2PosB.x >= v2MinB.x && v2PosB.x <= v2MaxB.x &&\n        v2PosB.y >= v2MinB.y && v2PosB.y <= v2MaxB.y;    \n    bool bCValid =\n        v2PosC.x >= v2MinC.x && v2PosC.x <= v2MaxC.x && \n        v2PosC.y >= v2MinC.y && v2PosC.y <= v2MaxC.y;\n    v0 fCamDistA = (v2PosA.x - v3CameraPos.x) / v3LookDir.x;\n    v0 fCamDistB = (v2PosB.x - v3CameraPos.x) / v3LookDir.x;\n    v0 fCamDistC = (v2PosC.x - v3CameraPos.x) / v3LookDir.x;\n    \n    v2 v3Start, v3End;\n    if( bAValid && bBValid )    {\n        v3Start = v3CameraPos + v3LookDir * min( fCamDistA, fCamDistB );\n        v3End = v3CameraPos + v3LookDir * max( fCamDistA, fCamDistB );\n    }else if( bBValid && bCValid )    {\n        v3Start = v3CameraPos + v3LookDir * min( fCamDistB, fCamDistC );\n        v3End = v3CameraPos + v3LookDir * max( fCamDistB, fCamDistC );\n    }else if( bCValid && bAValid )    {\n        v3Start = v3CameraPos + v3LookDir * min( fCamDistC, fCamDistA );\n        v3End = v3CameraPos + v3LookDir * max( fCamDistC, fCamDistA );\n    }else{       return v3( 0.0, 0.0, 0.0, 2.0 );    }       //no intersection!\n    v2 S = CartToBary( v3Start.xy );\n    v2 E = CartToBary( v3End.xy );\n    //Plug in eye ray and solve variables for root finding.\n    v2 ES = E - S;\n    v0 fA = dot( ES * ES, CP_2 ) + 2.0*dot( v2(ES.y*ES.z, ES.x*ES.z, ES.x*ES.y), CP_0 );\n    v0 fB = - (v3End.z - v3Start.z) + 2.0*( \n        dot( ES*S, CP_2 ) + \n        dot( v2((ES.y*S.z + ES.z*S.y), (ES.x*S.z + ES.z*S.x), (ES.x*S.y + ES.y*S.x)), CP_0 ) );\n    v0 fC = - v3Start.z + dot( S*S, CP_2 ) +\n    \t2.0*dot( v2(S.y*S.z,S.x*S.z,S.x*S.y), CP_0 );    \n    //Actual root finding\n    v0 fRoot = fB*fB - 4.0*fA*fC;\n    if( fRoot >= 0.0 )    {\n        v0 fRootA = (-fB + sqrt( fRoot ) ) /( 2.0 * fA );\n        v0 fRootB = (-fB - sqrt( fRoot ) ) /( 2.0 * fA );        \n        if( fRootA >= 0.0 && fRootA <= 1.0 )        {\n            if( fRootB >= 0.0 )                fRootA = min( fRootB, fRootA );\n            return v3( S + fRootA*ES, fRootA );        }\n        if( fRootB >= 0.0 && fRootB <= 1.0 )            return v3( S + fRootB*ES, fRootB );    }    \n    return v3(0.0, 0.0, 0.0, 2.0);}/**/\n\n//by @JJcoolkl,crunched by ollj\n//analytical intersection of RAY [u,d]=[origin,direction] \n//and quadratic-bezier triangular-patch(6 CV-heights)\n//in:\n//p1,p2,p3 corners of base triangle\n//c1,c0 6 CW heights (a vec3 for corners and a vec3 for midpoints)\n//... (orthogonal to triangle plane)\n//res=resolution.x (screen width in pixel)\n//out:\n//.xyz returns intersection\n//.w   returns if it hits (.w<=1 means it hit a surface)\n//inout:\n//cd is a debug color, used to show the bounding volume, and 3 cases within that volume.\nv3 BezierTriISect(const v2 u,const v2 d,v2 c1,v2 c0,v1 p1,v1 p2,v1 p3,v0 res,inout v2 cd\n){\n ;//return BezierTriISect(u,d,c1,c0) //reference to grandparent version, to compare if i introduced an error, or found a grandpparent error\n ;v1 L=u.xy-d.xy\n ,a=LineISect(p1,p2,u.xy,L)//project ray onto the triangle, within its ray+triangle intersections\n ,b=LineISect(p2,p3,u.xy,L)\n ,c=LineISect(p3,p1,u.xy,L)//three 2d intersections\n //\n //sicne eror hairlines are always lines, the error seems to be in the projected triangle 2d intersection.\n //\n //g+bA, h+bB, o+bC distinguish 3 ways to slice a triangle in two, in respect to its corners \n #define Mm(a,b,c)min(a.c,b.c)\n #define MM(a,b,c)max(a.c,b.c)\n #define mmm(a,b)v3(Mm(a,b,x),Mm(a,b,y),MM(a,b,x),MM(a,b,y))+q\n ;v3 q=v3(-1,-1,1,1)*.001/res//tiny epsilon accounts for precision loss. this seals the seam between 2 planes in screenspace\n //;v3 q=v3(-1,-1,1,1)*4./res//just to visualize the screenspace seam\n ,g=mmm(p1,p2),h=mmm(p2,p3),o=mmm(p3,p1)\n #define altm(a,b)any(lessThan(v3(a,b.zw),v3(b.xy,a)))\n ;bool bA=altm(a.xy,g),bB=altm(b.xy,h)\n ;v2 f,e=(v2(a.x,b.x,c.x)-u.x)/d.x//e stores 3 lengths.x of raystart.x to intersections.x, we care more for the shorter ones here.\n ;cd=v2(.7,0,0);//initially assume intersection with 1/3 sides of a \"triangle prism\"\n ;       if(  bA||bB ){bool bC=altm(c.xy,o)//restructured,1/3 of all cases skips the calculation of cB (remains default assumed case above)\n  ;      if(!(bB||bC)){e=e.yzx;cd=cd.yzx//intersection with 1/3 sides of a \"triangle prism\"\n  ;}else if(!(bA||bC)){e=e.zxy;cd=cd.zxy//intersection with 1/3 sides of a \"triangle prism\"\n ;}else{cd=cd.yyy;return v3(0,0,0,2);}}//no intersection with prism\n ;f=u+d*miv(e.xy);v2 S=CartToBary(f.xy,p1,p2,p3)//barycentric projection root solving black magic\n ;e=u+d*mav(e.xy);v2 E=CartToBary(e.xy,p1,p2,p3)-S//Plug in eye ray and solve variables for root finding.\n ;o=v3(0,f.z-e.z,dot(S*S,c1)-f.z,0)\n   +v3(dot(E*E,c1)+dot(E.yxx*E.zzy,c0)*2.\n      ,dot(E*S,c1)+dot(v2(dot(E.yz,S.zy),dot(E.xz,S.zx),(E.x*S.y+E.y*S.x)),c0)//i smell a cross()\n      ,dot(v2(S.y*S.z,S.x*S.z,S.x*S.y),c0),0)*2.//3 root solving factors; .x is the scalar to baricentric range[0..1]\n ;o.z=o.y*o.y-2.*o.x*o.z\n ;if(o.z>=0.&&o.x!=0.//worksafing\n ){a=(v1(1.,-1.)*sqrt(o.z)-o.y)/o.x;//[a] stores 2 distances to two roots, scaled to a [0..1] barycentric range., a.x may not be within that range, meaning theres less than 2 roots.\n  ;if(abs(a.x-.5)<.5\n  ){if(a.y>0.) a.x=miv(a); //a.xy may not be within that [0..1]range, meaning theres less than 2 roots, we hope theres one root.\n   ;return v3(S+a.x*E,a.x);}\n  ;if(abs(a.y-.5)<=.5\n  ){cd+=v2(0,.3,.3)\n   ;v2 ci=S+a.y*E;//closest interection(hopefully)\n   //;if (dot(ci,-d)<0.)return vec4(0.); //check if intersection is behind camera\n   ;return v3(S+a.y*E,a.y)//;if(a.y>=0.&&a.y<=1.)\n   ;}}\n  ;return v3(0,0,0,2);}//no intersection\n//\n//above function has triangle normal fixed to v2(0,0,+11), all corners have .z==0.\n//below version rotates the whole set around p1 to set the triangle normal to v2(0,0,1)\n//\n/*\nv3 BezierTriISect(v2 u,v2 d,v2 c1,v2 c0,v2 p1,v2 p2,v2 p3,v0 res,inout v2 cd\n){v2 n=normalize(triangleNornal(p1,p2,p3))\n ;v3 b=qBetween(n,v2(0,0,1))\n ;//we rotate everything around p1, and then move it by -p1.z, to make all p*.z values ==0.\n ;v2 s=v2(0,0,p1.z);\n// ;u =r(b,u ,p1)-s\n// ;d =r(b,d ,p1)-s\n// ;p2=r(b,p2,p1)-s\n// ;p3=r(b,p3,p1)-s\n ;return BezierTriISect(u,d,c1,c0,p1.xy,p2.xy,p3.xy,res,cd);}\n//this transform seems to be false.\n*/\n\n//--- all above code used to be in a commontab\n\n\nv2 BezierTriangle_Quadratic_Normal(const v2 u,const v2 a,const v2 b,v2 p1,v2 p2,v2 p3//get normal(2nd derivative)of quadradicBezier triangularPatch\n){v2 n=triangleNornal(p1,p2,p3)\n ;v3 c=qBetween(n,v2(0,0,1))\n ;//we rotate everything around p1, and then move it by -p1.z, to make all p*.z values ==0.\n ;//v2 s=v2(0,0,p1.z);\n ;//p2=r(c,p2,p1)-s\n ;//p3=r(c,p3,p1)-s\n ;return normalize(cross(v2(p1.xy-p2.xy,suv(u*v2(a.x-b.z,b.z-a.y,b.y-b.x)))\n                        ,v2(p1.xy-p3.xy,suv(u*v2(a.x-b.y,b.z-b.x,b.y-a.z)))));}\n\nv3 ComputeBezierColor(v2 u,v2 d,v2 a,v2 b,v2 p1,v2 p2,v2 p3,v0 res,inout v2 cd//get color based on bezier tri intersection+lighting\n){v3 v4ISect=BezierTriISect(u,d,a,b,p1.xy,p2.xy,p3.xy,res,cd)//analytical intersection of ray [u,d] and triangular quadratic-bezier patch(6 CV-heights [a,b])\n ;v2 c=v2(0)\n ;//v4iSect form may be return v3(S+a.y*E,a.y)\n //where S and E are baricentric.xyz and a.x (or a.y) are the closest root.\n ;//we basically only care for the .w parameter\n ;if(v4ISect.w<2.\n ){v2 n=BezierTriangle_Quadratic_Normal(v4ISect.xyz,a,b,p1,p2,p3)//analytical first derivative\n  ;c=n*.5+.5\n  ;if(board(v4ISect.xyz*9.)>0.)c.z=1.-c.z//barycentric checkerboard\n  ;return v3(c,1);}return v3(0);}\n\n//controls (i may have swapped left and right here, do not overthing this one)\n#define LEFT_ARROW 39\n#define RIGHT_ARROW 37  \n#define UP_ARROW 38\n#define DOWN_ARROW 40\n\n#define THRUST 0.1*iTimeDelta\n#define ROLL 1.0*iTimeDelta\n#define ROTATE 4.0*iTimeDelta\n//collision epsilon\n#define TOO_CLOSE 0.01\n//should scale with movement speed\n//return signed distane of[p] to a surface. (relict for collision detection of flyCamera.\nv0 gd(v2 u){return 999.;}//never collide\n\n//bool KeyDown(in int key){return (texture(iChannel1,v1((v0(key)+0.5)/256.0, 0.25)).x>0.0);}\nv0 key(in int key){return texture(iChannel1,v1((v0(key)+0.5)/256.0, 0.25)).x;}\n\n/*\n//namespace convention\n[o]RayOrigin\n[d]RayDirection\n[c]color, to be returned\n[f]FragmentSpaceScaling, to blur rasterization, against moire;a=smoothstep(s,-s,a);\n[t]TimeTraveled (implies division by speed of light) == distance to camera \n[g]gradient, signed distance to surface.\n*/\n\nv0 sp(v2 u,v2 d,vec4 s//draw CV as spheres,with simple projection;radius scaled by distance to camera.//cameraPos,Sphere\n){u-=s.xyz;u/=scale\n;v0 a=dot(d,u);u.x=length(u);s.w+=.0001;u.y=s.w*s.w\n;return sat(mix(0.,1.,(a*a-(u.x*u.x)+u.y)/(u.y-s.w*s.w)));}\n\nv0 ComputeOverlay(v2 u,v2 d,v2 a,v2 b,v2 p1,v2 p2,v2 p3\n ){v2 n=normalize(triangleNornal(p1,p2,p3))\n  ;return sp(u,d,v3(p1+n*a.x,.2))\n         +sp(u,d,v3(p2+n*a.y,.2))      \n         +sp(u,d,v3(p3+n*a.z,.2))      \n         +sp(u,d,v3((p1+p2)*.5+n*b.z,.2))\n         +sp(u,d,v3((p3+p1)*.5+n*b.y,.2))\n         +sp(u,d,v3((p2+p3)*.5+n*b.x,.2))\n         ;}//paint 6 CVs as spheres\n\n//lots of min max for an aabv\nv0 doAABV(v2 v,v2 d,v2 p1,v2 p2,v2 p3,v2 a,v2 b){\n     ;v2 n=normalize(triangleNornal(p1,p2,p3))\n// ;v3 q=RotBetween(n,v2(0,0,1))\n/*\n ;v2 s=v2(0,0,p1.z);\n ;p2=r(q,p2,p1)-s\n ;p3=r(q,p3,p1)-s\n/**/ \n ;v2 cv1=p1+n*a.x,cv12=(p1+p2)*.5+n*b.x\n ;v2 cv2=p2+n*a.y,cv23=(p3+p3)*.5+n*b.y\n ;v2 cv3=p3+n*a.z,cv31=(p3+p1)*.5+n*b.z\n #define muchm(a,b,c) v0 b=a(a(a(cv1.c,cv2.c),a(cv3.c,cv12.c)),a(cv23.c,cv31.c))\n ;muchm(min,x,x);muchm(max,X,x)\n ;muchm(min,y,y);muchm(max,Y,y)\n ;muchm(min,z,z);muchm(max,Z,z)     \n ;v2 aa=aabv(v,d,v2(x,y,z),v2(X,Y,Z))\n ;if(aa.x<1.)return 0.//outside of AABV\n ;return 1.;}\n\n//a faster and insignificantly less precise 3d line segment distance.\n//https://www.shadertoy.com/view/ssyXzy\nfloat angularSeg16(vec3 d, vec3 a, vec3 b)\n{\n    b -= a;\n    float e = dot(d, a),\n      f = dot(d, b),\n\t  w = dot(b, b) - f * f;\n    vec3 x = a + b * (abs(w) < 1e-7 ? .5 : clamp((e * f - dot(b, a)) / w, 0., 1.)); // closest point on segment\n    float s = dot(d, x);\n    return s < 0. ? 3e38 // behind camera -> infinity\n        : dot(x, x) - s * s; // AngularDistanceSquaredDotted\n}\nbool segmentMask(vec3 d,vec3 a,vec3 b //viewRayDir, segmentStart,segmenrEnd\n){float tiny=.001 ;\n    float g =angularSeg16(d, a, b)+tiny;\n    g = sqrt(g); // un-square squared signed distance\n    g -= .022+tiny; // thickness\n    return (g <= .01)\n    ;}\n\nfloat drawTri(v2 v,v2 d,v2 p1,v2 p2,v2 p3,float o\n){float t0=0.\n ;p1.z+=o\n ;p2.z+=o\n ;p3.z+=o \n ;v-=o\n ;t0=+v0(segmentMask(d,p1,p2))\n ;t0+=v0(segmentMask(d,p1,p3))\n ;t0+=v0(segmentMask(d,p2,p3));//base triangle done\n ;return t0;\n}\n\nv3 drawPrism(v2 v,v2 d,v2 p1,v2 p2,v2 p3,v2 a,v2 b\n){//position,direction, 3*trianglecorners , 3*CV ,3*CV\n float t0=0.;\n p1-=v;\n p2-=v;\n p3-=v;\n v3 c=v3(0);\n      t0+=drawTri(v,d,p1,p2,p3,0.);//triangle at z=0\n      t0+=v0(segmentMask(d,p1,p1+vec3(0,0,a.x)));\n      t0+=v0(segmentMask(d,p2,p2+vec3(0,0,a.y)));\n      t0+=v0(segmentMask(d,p3,p3+vec3(0,0,a.z)));//3 corner CV done\n      vec3 m1=mix(p1,p2,.5);\n      vec3 m2=mix(p1,p3,.5);\n      vec3 m3=mix(p2,p3,.5);//3 triangle midpoints\n      t0+=v0(segmentMask(d,m1,m1+vec3(0,0,b.z)));\n      t0+=v0(segmentMask(d,m2,m2+vec3(0,0,b.y)));\n      t0+=v0(segmentMask(d,m3,m3+vec3(0,0,b.x)));//3 midpoint CVs done\n      if (t0>1.)t0=1.;//capping brightness of all the above\n      \n      float mi=min(min(min(a.x,a.y),min(a.z,b.z)),min(b.x,b.y));//min of 6\n      float ma=max(max(max(a.x,a.y),max(a.z,b.z)),max(b.x,b.y));//max of 6\n      t0+=drawTri(v,d,p1,p2,p3,mi)*.3;//triangle at z=mi (dimmed, uncapped)\n      t0+=drawTri(v,d,p1,p2,p3,ma)*.3;//triangle at z=ma\n return v3(t0)*.4;//thin dark grey dithered lines\n}\n\nv3 bezierPatch(v2 v,v2 d,v2 p1,v2 p2,v2 p3,vec2 uv\n){//position,direction, trianglecorners , ScreenSpaceUv(for dither only)\n ;p1*=scale\n ;p2*=scale\n ;p3*=scale\n ;v3 o=v3(0);\n ;mat3 pq=pqfmA()//matrix of different quadratic fields, to be most aperiodic\n ;pq=pq*(iTime*.2+.001)//.001 to skip the coplanar case at iTime==0 (with tiny determinant). dare to get closer to it, its quite the precision-mess where it gets too planar (but not quite planar)\n ;v2 a=cos(pq[0])*scale, b=cos(pq[2])*scale //a and b are 9 cv heights\n ;//a=v2(0,1,2)\n ;//b=v2(0,1,2)\n ;a*=9.\n ;b*=9.\n ;v2 cd=v2(0)\n //the line below is completely optional, and may not even be worth computing\n //as it is only an AxisAlignedBoundingVolume for culling.\n ;if(doAABV(v,d,p1,p2,p3,a,b)==0.\n ){\n  ;return v3(.5,.5,.5,0)//if(ray misses AABV)return grey transparent\n ;}\n ;//a*=0.0;b*=0.0 //known bug debug enforcing case: planar case has determinant of 0 special case!\n ;v3 c=ComputeBezierColor(v,d,a,b,p1,p2,p3,iResolution.x,cd)\n ;c=mix(v3(.5,.5,.5,1.),c,c.a)//lazy alpha compositioning\n ;if(c.xyz==v2(.5)){ //if(color is still backgound color == no compositing effect \n //if condition is lazy condition, lazy coding, but weorks)\n c.xyz=mix(c.xyz,cd,.5);//debug color output, 2 cases are colored differently\n  //last color is like saturation here.\n  //if(mod(iTime*.4,1.)<.5)\n  if(board(uv/2.)==0.)  return vec4(0.);}//pixel-perfect a1pha dithering of the debug output\n  //thich mostly just shows the AABV-box\n ;o=mix(c,v3(.7,.7,.7,1),ComputeOverlay(v,d,a,b,p1,p2,p3))\n ;o+=drawPrism(v,d,p1,p2,p3,a,b);\n ;return vec4(o.xyz,1.);\n;}\n\nv3 scene(v2 o,v2 d,v1 uv\n){v2 //3 corners.xyx of a triangle\n//, that the bezier patch is pklaced above and below of\n//all ControllVectors only move in the .z direction.\n p1=v2(-4,0,0)\n,p2=v2(4,0,0)\n,p3=v2(0,sqrt(3.)/3.*4.*4.,0);//.z==0. for simplicity/debugging\n ;return bezierPatch(o.zxy,d.zxy,p1,p2,p3,uv)\n ;}//origin,direction\n\nconst float FOV=1.;\nvoid mainImage(out v3 O,v1 U\n){vec4 q=get(camA0) //get() always gets from ichannel2\n ;mat3 cam=q2m(q)\n ;vec2 uv=(U-0.5*iResolution.xy)/iResolution.y\n ;vec3 rd=normalize(cam*vec3(1.,FOV*uv))\n ;O=v3(scene(get(camP0).xyz,rd,U));}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}