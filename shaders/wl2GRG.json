{
    "Shader": {
        "info": {
            "date": "1560347608",
            "description": "Recreating BigWIngs's double arc quad Truchet weave pattern, with some minor changes thrown in.",
            "flags": 0,
            "hasliked": 0,
            "id": "wl2GRG",
            "likes": 28,
            "name": " Double Sided Quad Truchet",
            "published": 3,
            "tags": [
                "bezier",
                "square",
                "truchet",
                "pattern",
                "double",
                "quad",
                "weave"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1320
        },
        "renderpass": [
            {
                "code": "/*\n\n\t Double Sided Quad Truchet\n\t--------------------------\n\n\tBigWIngs posted a really interesting weave pattern the other day that I wanted to\n    recreate for my own amusement. I like it because the premise is incredibly simple, \n\tbut\tit leads to visually entertaining results -- In fact, I'm amazed at just how\n    much variation it provides. The link to his orginal example is below.\n\n\tThe idea is very simple: Instead of rendering two sets of arcs connecting the\n    midpoints of the grid cell boundaries (like with a standard Truchet arc pattern), \n\tdouble the connecting points on each edge, then connect four arc-like segments\n    between them -- Bezier curves are a good option, but not mandatory. The four \n\tcurve segments each connect random pairs of entry and exit points, which result \n\tin the crazy spaghetti pattern you see. :)\n\n\tBigWIngs rendered some presets and left the overall random pattern rendering as \n\tan exercise to the reader, so I gave it a go. I had to think about it for a while, \n\tbut then realized all that was required was to shuffle an array of 8 points, \n\tthen render the shuffled pairs. It seems to work, but I'm open to suggestion, if \n\tthere's a better way.\n\n    I also went out of my way to append smooth Bezier curves, which look fine, but my \n\tmethodology was a bit hacky, so I'm hoping BigWIngs, or someone else, will come up \n\twith something more robust.\n\n\tI didn't spend a great deal of time prettying this up, so I'm not sure what style\n\tthis is rendered in. Art deco grunge? :) I might bump map it later to make it pop\n\tout a bit more, or make a 3D version. By the way, if you wanted to produce a 3D \n\textruded version, you'd probably have to replace the Bezier curves with a mixture \n\tof arcs and lines, which would be much faster.\n\n\n\tBased On:\n\n\tCube-mapped Double Quad Truchet - BigWIngs\n\thttps://www.shadertoy.com/view/wlSGDD\n\n\n*/\n\n// The textured version. Without it, the look is cleaner, which makes the pattern\n// a little easier to discern. Sometimes, I prefer it.\n#define USE_TEXTURE\n\n// This will change the spacing of the boundary connecting points to loosen the weave \n// a little. I like it more, but I left the standard look as the default.\n//#define LOOSE_WEAVE\n\n// Grid outlines, which allows the viewer to see the individual tiles... and spoils\n// the illusion. :)\n//#define SHOW_GRID\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Standard vec2 to float hash.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(27.917, 57.543)))*43758.5453); }\n\n// vec4 swap.\nvoid swap(inout vec4 a, inout vec4 b){ vec4 tmp = a; a = b; b = tmp; }\n\n// A swap without the extra declaration -- It works fine on my machine, but I'm\n// not game  enough to use it, yet. :)\n//void swap(inout vec4 a, inout vec4 b){ a = a + b; b = a - b; a = a - b; }\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n\n// Smooth fract function.\nfloat sFract(float x, float sf){\n    \n    x = fract(x);\n    return min(x, (1. - x)*x*sf);\n    \n}\n\n// The grungey texture -- Kind of modelled off of the metallic Shadertoy texture,\n// but not really. Most of it was made up on the spot, so probably isn't worth \n// commenting. However, for the most part, is just a mixture of colors using \n// noise variables.\nvec3 GrungeTex(vec2 p){\n    \n \t// Some fBm noise.\n    //float c = n2D(p*4.)*.66 + n2D(p*8.)*.34;\n    float c = n2D(p*3.)*.57 + n2D(p*7.)*.28 + n2D(p*15.)*.15;\n    \n    \n    // Noisey bluish red color mix.\n    vec3 col = mix(vec3(.35, .5, .65), vec3(.25, .1, .02), c);\n    // Running slightly stretched fine noise over the top.\n    col *= n2D(p*vec2(150., 350.))*.5 + .5; \n    \n    \n    // Using a smooth fract formula to provide some splotchiness... Is that a word? :)\n    col = mix(col, col*vec3(.75, .95, 1.2), sFract(c*4., 12.));\n    col = mix(col, col*vec3(1.2, 1, .8)*.8, sFract(c*5. + .35, 12.)*.5);\n    \n    // More noise and fract tweaking.\n    c = n2D(p*8. + .5)*.7 + n2D(p*18. + .5)*.3;\n    c = c*.7 + sFract(c*5., 16.)*.3;\n    col = mix(col*.6, col*1.4, c);\n    \n    // Clamping to a zero to one range.\n    return clamp(col, 0., 1.);\n    \n}\n\n\n// IQ's signed distance to a quadratic Bezier. Like all of IQ's code, it's\n// quick and reliable. :)\n//\n// Quadratic Bezier - 2D Distance - IQ\n// https://www.shadertoy.com/view/MlKcDD\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){\n  \n    // p(t)    = (1 - t)^2*p0 + 2(1 - t)t*p1 + t^2*p2\n    // p'(t)   = 2*t*(p0 - 2*p1 + p2) + 2*(p1 - p0)\n    // p'(0)   = 2*(p1 - p0)\n    // p'(1)   = 2*(p2 - p1)\n    // p'(1/2) = 2*(p2 - p0)\n    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n     // If I were to make one change to IQ's function, it'd be to cap off the value \n    // below, since I've noticed that the function will fail with straight lines.\n    float kk = 1./max(dot(b,b), 1e-6); // 1./dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\n// Rendering the smooth Bezier segment. The idea is to calculate the midpoint\n// between \"a.xy\" and \"b.xy,\" then offset it by the average of the combined normals\n// at \"a\" and \"b\" multiplied by a factor based on the length between \"a\" and \"b.\"\n// At that stage, render a Bezier from \"a\" to the midpoint, then from the midpoint\n// to \"b.\" I hacked away to come up with this, which means there'd have to be a more\n// robust method out there, so if anyone is familiar with one, I'd love to know.\nfloat doSeg(vec2 p, vec4 a, vec4 b, float r){\n    \n    // Mid way point.\n    vec2 mid = (a.xy + b.xy)/2.; // mix(a.xy, b.xy, .5);\n    \n    // The length between \"a.xy\" and \"b.xy,\" multiplied by... a number that seemed\n    // to work... Worst coding ever. :D\n    float l = length(b.xy - a.xy)*(1.4142 - 1.)/1.4142;\n    // Segments between edge points need to be refactored. Comment this out to\n    // see why it's necessary.\n    if(abs(length(b.xy - a.xy) - r*2.)<.01) l = r; \n  \n    // Offsetting the midpoint between the exit points \"a\" and \"b\"\n    // by the average of their normals and the line length factor.\n    mid += (a.zw + b.zw)/2.*l;\n\n    // Piece together two quadratic Beziers to form the smooth Bezier arc from the\n    // entry and exit points. The only reliable part of this method is the quadratic\n    // Bezier function, since IQ wrote it. :D\n    float b1 = sdBezier(p, a.xy, a.xy + a.zw*l, mid);\n    float b2 = sdBezier(p, mid, b.xy + b.zw*l, b.xy);\n    \n    // Return the minimum distance to the smooth Bezier arc.\n    return min(b1, b2);\n}\n\nvec4 DoubleQuadTruchet(vec2 p){\n    \n    vec2 ip = floor(p); // Cell ID.\n    p -= ip + .5; // Cell's local position. Range [vec2(-.5), vec2(.5)].\n    \n    \n    \n    // Positioning the connecting points around the square grid cell. \"r\" is an offset\n    // from the mid point, which controls the tightness of the pattern. The value\n    // \".25\" gives the most even spread, whereas something like \".175\" will give\n    // a tighter looking loop pattern.\n    //\n    // The first two entries of the vec4 represent the positions, and the remaining\n    // two are their edge normals, which, by the way, would be easy enough to \n    // calculate, but I thought hardcoding them in would be easier.\n    //\n    // Only range values between .18 and .32 will work with this configuration. Larger ranges\n    // would work, but you'd have to render surrounding cells also to account for neighboring\n    // cell infringement.\n    float r = .25; \n    #ifdef LOOSE_WEAVE\n    r = .2;\n    #endif\n    vec4[8] pnt = vec4[8](vec4(-r, .5, 0, -1), vec4(r, .5, 0, -1), vec4(.5, r, -1, 0), vec4(.5, -r, -1, 0),\n                         vec4(r, -.5, 0, 1), vec4(-r, -.5, 0, 1), vec4(-.5, -r, 1, 0), vec4(-.5, r, 1, 0));\n    \n     \n    // Shuffling the 8 array points and normals. Afterward, the four array pairs should\n    // be rendered randomly. This also means the rendering order should be randomized,\n    // which is an added bonus. I think this is the Fisher–Yates method, but it's been \n    // a while since I've used a shuffling algorithm, so if there are inconsistancies, \n    // etc, feel free to let me know.\n    //\n    // There'd be some combinations, like four corner arcs, etc, that would be rendered \n    // more often, since lack of overlap would mean that different rendering orders would\n    // result in the same tile combination. However, as a general rule, this method works\n    // well enough. I mean, you could start including weighted distribution for certain \n    // arrangements... but who wants the extra headache? :)\n    //\n    for(int i = 7; i>0; i--){\n        // Using the cell ID and shuffle number to generate a unique random number.\n        float fi = float(i);\n        float rs = hash21(ip + fi/8.); // Random number.\n        //int j = int(floor(mod(rs*8e5, fi + 1.)));\n        // I think this does something similar to the line above, but if not, let us know.\n        int j = int(floor(rs*(fi + .9999)));\n        swap(pnt[i], pnt[j]);\n         \n    }\n    \n    // Render all four connecting arc segments.\n    vec4 d;\n    \n    d.x = doSeg(p, pnt[0], pnt[1], r);\n    d.y = doSeg(p, pnt[2], pnt[3], r);\n    d.z = doSeg(p, pnt[4], pnt[5], r);\n    d.w = doSeg(p, pnt[6], pnt[7], r);\n    \n    return d; // The Truchet tile distance field value.\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/min(iResolution.y, 800.);\n    \n    // Scaling and translation.\n    const float gSc = 8.;\n    \n    // Smoothing factor.\n    float sf = 2./iResolution.y*gSc;\n    \n    // Scaling and translation.\n    vec2 p = uv*gSc + vec2(1, 0)*iTime;\n \n    // Grid fields: Square and diamond.\n    vec2 grid;\n    vec2 p2 = abs(fract(p) - .5);\n    grid.x = abs(max(abs(p2.x), abs(p2.y)) - .5); // Square grid.\n    grid.y = abs((abs(p2.x) +  abs(p2.y)) - .5*.7071); // Diamond background.\n    \n    \n    // The pattern itself.\n    vec4 d = DoubleQuadTruchet(p);\n    d -= .155; // Give the pattern some width.\n \n    // Background, line and edge colors. \n    vec3 col = vec3(1, .8, .6);\n    vec3 lCol = vec3(1, .95, .9);\n    vec3 eCol = vec3(1, .8, .6);\n    \n    // Subtle coloring, based on pixel height. I was going for an oxidized copper\n    // tone, so that kind of does it. :)\n    lCol = mix(lCol, lCol.yxz, -uv.y*.35 + .35);\n    eCol = mix(eCol, eCol.yxz, -uv.y*.2 + .2); \n    col = mix(col, col.yxz, -uv.y*.35 + .35);    \n    \n\t// Concentric diamond background pattern.\n    float pat = clamp(cos(grid.y*6.2831*8.), 0., 1.);\n    col *= 1. -  pat*.9;\n    \n    #ifdef USE_TEXTURE\n        \n        // Applying the pattern to the line element. Comment it out to give a\n        // a cleaner pattern look.\n        lCol *= vec3(.3, .45, .55) +  pat;\n        \n        // Home made texture algorithm... Sufficient for this example,\n        // but not my best work. :)\n        vec3 tx = GrungeTex(p/gSc);\n        vec3 tx2 = GrungeTex(p/gSc + 6.5);\n\n        // Apply the texture.\n        col *= min(tx2*4., 1.);\n        lCol *= min(tx*1.5, 1.);\n        eCol *= min(tx2*6., 1.);\n\n        float sAlpha = .75; // Darker texture shadowing.\n    #else\n \n        float sAlpha = .5; // Lighter shadowing when not using a texture.\n    #endif\n    \n\n    // Render the four arcs. Layers include shadowing, strokes, inner strokes,\n    // coloring, etc.\n    for(int i = 0; i<4; i++){\n       \n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., d[i] - .01))*sAlpha);\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, d[i]))*.9);\n        col = mix(col, eCol, 1. - smoothstep(0., sf, d[i] + .03));\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, d[i] + .09))*.9);\n        col = mix(col, lCol, 1. - smoothstep(0., sf, d[i] + .12));\n    }\n    \n    \n    // Displaying the grid.\n    #ifdef SHOW_GRID\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., grid.x - .025))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, grid.x - .025))*.9);\n    col = mix(col, vec3(1, .9, .8)*1.2, (1. - smoothstep(0., sf, grid.x - .005))*.9);\n    #endif\n    \n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625);\n    // Colored variation.\n    //col = mix(col.xzy, col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625));\n  \n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}