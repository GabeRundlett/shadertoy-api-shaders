{
    "Shader": {
        "info": {
            "date": "1613123041",
            "description": "Drag control points with the mouse (press SHIFT to change their weights).\nUse keys (A, B, C, D) to toggle various rendering styles.",
            "flags": 48,
            "hasliked": 0,
            "id": "WlcBRn",
            "likes": 7,
            "name": "AA Rational Cubic Bezier Fill",
            "published": 3,
            "tags": [
                "2d",
                "bezier"
            ],
            "usePreview": 1,
            "username": "Lichtso",
            "viewed": 781
        },
        "renderpass": [
            {
                "code": "vec4 lookup_variable(int index) {\n    return texture(iChannel0, vec2(float(index)+0.5, 0.5)/iChannelResolution[0].xy);\n}\n\nbool lookup_keyboard(int index) {\n    return texture(iChannel1, vec2(float(index)+0.5, 2.5)/iChannelResolution[1].xy).x > 0.0;\n}\n\nconst vec3 colors[] = vec3[](\n    vec3(1.0, 0.25, 0.25),\n    vec3(0.62, 1.0, 0.25),\n    vec3(0.25, 1.0, 1.0),\n    vec3(0.62, 0.25, 1.0),\n    vec3(1.0, 0.8, 0.5),\n    vec3(0.9, 0.0, 0.0)\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Load Control Points\n    mat4 control_points;\n    for(int i = 0; i < 4; ++i) {\n        control_points[i] = lookup_variable(1+i);\n        control_points[i].xy *= control_points[i].z;\n    }\n    mat4 c = control_points * cubic_power_basis;\n    \n    // Load Weight Planes\n    vec3 planes[4];\n    for(int i = 0; i < 4; ++i)\n        planes[i] = lookup_variable(8+i).xyz;\n    \n    // Draw Implicit Curve\n    vec4 weights = sample_planes(planes, fragCoord);\n    fragColor = vec4(\n        vec3(clamp(\n            lookup_keyboard(65)\n                ? 0.5+(weights.x*weights.x*weights.x-weights.y*weights.z*weights.w)*planes[0].z\n                : rational_cubic_bezier(weights),\n            0.0, 1.0\n        )), 1.0\n    );\n    \n    // Draw Dashed Curve\n    if(lookup_keyboard(66))\n        for(float t = -1.0; t <= 2.0; t += 0.05)\n            fragColor.rgb = mix(fragColor.rgb, colors[4],\n                smoothstep(5.0, 3.0, distance(fragCoord, point_at(c, t)))\n            );\n    \n    // Draw Inflection Points with Tangents\n    if(lookup_keyboard(67))\n        for(int i = 0; i < 3; ++i) {\n            vec2 root = lookup_variable(5+i).xy;\n            if(abs(root.y) < ERROR_MARGIN)\n                continue;\n            float param = root.x/root.y;\n            vec2 point = point_at(c, param);\n            vec2 tangent = normalize(tangent_at(c, param));\n            fragColor.rgb = mix(fragColor.rgb, colors[5],\n                clamp(\n                    smoothstep(7.0, 5.0, distance(fragCoord, point))+\n                    smoothstep(2.0, 0.0, abs(dot(point-fragCoord, vec2(-tangent.y, tangent.x))))*\n                    step(abs(dot(point-fragCoord, tangent)), 100.0),\n                0.0, 1.0)\n            );\n        }\n    \n    /* Gradient and tangent at first control point\n    vec2 point = point_at(c, 0.0);\n    vec2 gradient = normalize(implicit_curve_gradient(planes, sample_planes(planes, point)));\n    fragColor.rgb = mix(fragColor.rgb, colors[5],\n        clamp(\n            smoothstep(7.0, 5.0, distance(fragCoord, point))+\n            smoothstep(2.0, 0.0, abs(dot(point-fragCoord, vec2(-gradient.y, gradient.x))))*\n            step(abs(dot(point-fragCoord, gradient)), 100.0),\n        0.0, 1.0)\n    );\n    vec2 tangent = normalize(tangent_at(c, 0.0));\n    fragColor.rgb = mix(fragColor.rgb, colors[5],\n        clamp(\n            smoothstep(7.0, 5.0, distance(fragCoord, point))+\n            smoothstep(2.0, 0.0, abs(dot(point-fragCoord, vec2(-tangent.y, tangent.x))))*\n            step(abs(dot(point-fragCoord, tangent)), 100.0),\n        0.0, 1.0)\n    );*/\n    \n    // Draw Control Points\n    if(!lookup_keyboard(68))\n        for(int i = 0; i < 4; ++i)\n            fragColor.rgb = mix(fragColor.rgb, colors[i],\n                0.8*smoothstep(control_point_radius, control_point_radius-2.0,\n                    distance(fragCoord, control_points[i].xy/control_points[i].z)));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 lookup_variable(int index) {\n    return texture(iChannel0, vec2(float(index)+0.5, 0.5)/iChannelResolution[0].xy);\n}\n\nbool lookup_keyboard(int index) {\n    return texture(iChannel1, vec2(float(index)+0.5, 0.5)/iChannelResolution[1].xy).x > 0.0;\n}\n\nconst vec3 control_point_defaults[] = vec3[](\n    vec3(300.0, 300.0, 1.0),\n    vec3(500.0, 500.0, 1.0),\n    vec3(700.0, 300.0, 5.0),\n    vec3(500.0, 100.0, 1.0)\n);\n\n/*const vec3 control_point_defaults[] = vec3[](\n    vec3(100.0, 400.0, 1.0),\n    vec3(300.0, 400.0, 1.0),\n    vec3(400.0, 300.0, 1.0),\n    vec3(400.0, 100.0, 1.0)\n);*/\n\n/*const vec3 control_point_defaults[] = vec3[](\n    vec3(100.0, 400.0, 1.0),\n    vec3(250.0, 400.0, 1.0),\n    vec3(250.0, 100.0, 1.0),\n    vec3(400.0, 100.0, 1.0)\n);*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int index = int(fragCoord);\n    fragColor = vec4(0.0);\n    if(index >= 8) { // Weight Planes\n        mat4 control_points;\n        for(int i = 0; i < 4; ++i) {\n            control_points[i] = lookup_variable(1+i);\n            control_points[i].xy *= control_points[i].z;\n        }\n        mat4 c = control_points * cubic_power_basis;\n        vec4 ippc;\n        rational_inflection_point_polynomial_coefficients(ippc, c);\n        float discr;\n        vec2 roots[3];\n        rational_inflection_points(discr, roots, ippc);\n        mat4 w;\n        weights(w, control_points, discr, roots, ippc);\n        vec3 planes[4];\n        weight_planes(planes, w, control_points);\n        normalize_implicit_curve_side(planes, c, w);\n        fragColor.xyz = planes[index-8];\n    } else if(index >= 5) { // Inflection Point Polynomial Roots\n        mat4 control_points;\n        for(int i = 0; i < 4; ++i) {\n            control_points[i] = lookup_variable(1+i);\n            control_points[i].xy *= control_points[i].z;\n        }\n        mat4 c = control_points * cubic_power_basis;\n        vec4 ippc;\n        rational_inflection_point_polynomial_coefficients(ippc, c);\n        float discr;\n        vec2 roots[3];\n        rational_inflection_points(discr, roots, ippc);\n        fragColor.xy = roots[index-5];\n    } else if(index >= 1) { // Control Points\n        fragColor = lookup_variable(index);\n        if(fragColor == vec4(0.0))\n            fragColor.xyz = control_point_defaults[index-1];\n        int selected = int(lookup_variable(0).x);\n        if(selected == index) // Position\n            fragColor.xyz = vec3(iMouse.xy, 1.0);\n        else if(selected == index+4) { // Weight\n            vec2 mouse = (iMouse.xy-lookup_variable(index).xy)/iResolution.xy;\n            fragColor.z = mouse.x/mouse.y;\n        }\n    } else if(index == 0) { // Mouse Selection\n        if(iMouse.z > 0.0) {\n            fragColor = lookup_variable(0);\n            if(iMouse.w > 0.0) {\n                int closest_i = 0;\n                float min_dist = control_point_radius;\n                for(int i = 1; i <= 4; ++i) {\n                    float dist = distance(iMouse.xy, lookup_variable(i).xy);\n                    if(min_dist > dist) {\n                        min_dist = dist;\n                        closest_i = i;\n                    }\n                }\n                if(lookup_keyboard(16))\n                    closest_i += 4;\n                if(min_dist < control_point_radius)\n                    fragColor.x = float(closest_i);\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float ERROR_MARGIN = 0.0001;\nconst float control_point_radius = 10.0;\n\n// Rendering: Anti-Aliased Fill\n\nfloat quadratic_bezier(in vec2 weights) {\n    float value = weights.x*weights.x - weights.y;\n    vec2 weights_dx = dFdx(weights);\n    vec2 weights_dy = dFdy(weights);\n    vec2 derivative = mat2(\n        weights_dx.x, weights_dy.x,\n        weights_dx.y, weights_dy.y\n    ) * vec2(\n        2.0*weights.x,\n        -1.0\n    );\n    return 0.5+value/length(derivative);\n}\n\nfloat rational_quadratic_bezier(in vec3 weights) {\n    float value = weights.x*weights.x - weights.y*weights.z;\n    vec3 weights_dx = dFdx(weights);\n    vec3 weights_dy = dFdy(weights);\n    vec3 derivative = mat3(\n        weights_dx.x, weights_dy.x, 0.0,\n        weights_dx.y, weights_dy.y, 0.0,\n        weights_dx.z, weights_dy.z, 0.0\n    ) * vec3(\n        2.0*weights.x,\n        -weights.z,\n        -weights.y\n    );\n    return 0.5+value/length(derivative);\n}\n\nfloat cubic_bezier(in vec3 weights) {\n    float value = weights.x*weights.x*weights.x - weights.y*weights.z;\n    vec3 weights_dx = dFdx(weights);\n    vec3 weights_dy = dFdy(weights);\n    vec3 derivative = mat3(\n        weights_dx.x, weights_dy.x, 0.0,\n        weights_dx.y, weights_dy.y, 0.0,\n        weights_dx.z, weights_dy.z, 0.0\n    ) * vec3(\n        3.0*weights.x*weights.x,\n        -weights.z,\n        -weights.y\n    );\n    return 0.5+value/length(derivative);\n}\n\nfloat rational_cubic_bezier(in vec4 weights) {\n    float value = weights.x*weights.x*weights.x - weights.y*weights.z*weights.w;\n    vec4 weights_dx = dFdx(weights);\n    vec4 weights_dy = dFdy(weights);\n    vec4 derivative = mat4(\n        weights_dx.x, weights_dy.x, 0.0, 0.0,\n        weights_dx.y, weights_dy.y, 0.0, 0.0,\n        weights_dx.z, weights_dy.z, 0.0, 0.0,\n        weights_dx.w, weights_dy.w, 0.0, 0.0\n    ) * vec4(\n        3.0*weights.x*weights.x,\n        -(weights.z*weights.w),\n        -(weights.y*weights.w),\n        -(weights.y*weights.z)\n    );\n    return 0.5+value/length(derivative);\n}\n\n// Complex Arithmetic\n\nvec2 complex_conjugate(vec2 a) {\n    return vec2(a.x, -a.y);\n}\n\nvec2 complex_multiplication(vec2 a, vec2 b) {\n    return mat2(a.x, a.y, -a.y, a.x) * b;\n    // return vec2(a.x*b.x-a.y*b.y, a.y*b.x+a.x*b.y);\n}\n\nvec2 complex_division(vec2 a, vec2 b) {\n    return complex_multiplication(a, complex_conjugate(b))/dot(b, b);\n    // return vec2(a.x*b.x+a.y*b.y, a.y*b.x-a.x*b.y)/dot(b, b);\n}\n\nvec2 polar_complex(float radius, float angle) {\n    return radius*vec2(cos(angle), sin(angle));\n}\n\nvec2 complex_exponentiation(vec2 b, vec2 e) {\n    float radius = length(b);\n    float angle = atan(b.y, b.x);\n    return polar_complex(\n        pow(radius, e.x)*exp(-angle*e.y),\n        angle*e.x+log(radius)*e.y\n    );\n}\n\nvec2 complex_exponentiation(vec2 b, float e) {\n    return polar_complex(\n        pow(length(b), e),\n        atan(b.y, b.x)*e\n    );\n}\n\nvec2 complex_square_root(float a) {\n    return (a < 0.0) ? vec2(0.0, sqrt(-a)) : vec2(sqrt(a), 0.0);\n}\n\nvec2 complex_cubic_root(vec2 a) {\n    return complex_exponentiation(a, 1.0/3.0);\n}\n\nvec2 roots_of_unity_3[] = vec2[](\n    vec2(-0.5, -0.5*sqrt(3.0)), // polar_complex(1.0, radians(120.0))\n    vec2(-0.5, 0.5*sqrt(3.0)), // polar_complex(1.0, radians(-120.0))\n    vec2(1.0, 0.0) // polar_complex(1.0, radians(0.0))\n);\n\n// Bezier Curve Evaluation\n\nvec2 point_at(mat4 c, float t) {\n    vec4 p = c * vec4(1.0, t, t*t, t*t*t);\n    return p.xy/p.z;\n}\n\nvec2 tangent_at(mat4 c, float t) {\n    vec4 p = c * vec4(1.0, t, t*t, t*t*t);\n    vec4 d1 = c * vec4(0.0, 1.0, 2.0*t, 3.0*t*t);\n    return (d1.xy*p.z-p.xy*d1.z)/(p.z*p.z);\n}\n\nvec2 second_order_derivative_at(mat4 c, float t) {\n    vec4 p = c * vec4(1.0, t, t*t, t*t*t);\n    vec4 d2 = c * vec4(0.0, 0.0, 2.0, 6.0*t);\n    return (d2.xy*p.z-p.xy*d2.z)/(p.z*p.z);\n}\n\nvec2 third_order_derivative_at(mat4 c, float t) {\n    vec4 p = c * vec4(1.0, t, t*t, t*t*t);\n    vec4 d2 = c * vec4(0.0, 0.0, 2.0, 6.0*t);\n    vec4 d3 = c * vec4(0.0, 0.0, 0.0, 6.0);\n    return (d3.xy*p.z-p.xy*d3.z)/(p.z*p.z*p.z)+(d2.xy*p.z-p.xy*d2.z)/(p.z*p.z);\n}\n\nvec2 implicit_curve_gradient(in vec3 planes[4], in vec4 w) {\n    return planes[0].xy*(3.0*w[0]*w[0])\n          -planes[1].xy*(w[2]*w[3])\n          -planes[2].xy*(w[1]*w[3])\n          -planes[3].xy*(w[1]*w[2]);\n}\n\n// Finding Inflection Points\n\nvoid integral_inflection_point_polynomial_coefficients(out vec4 ippc, in mat4 c) {\n    ippc = normalize(vec4(\n        0.0,\n        -determinant(mat3(c[3].xyz, c[2].xyz, c[0].xyz)),\n        determinant(mat3(c[3].xyz, c[1].xyz, c[0].xyz)),\n        -determinant(mat3(c[2].xyz, c[1].xyz, c[0].xyz))\n    ));\n}\n\nvoid rational_inflection_point_polynomial_coefficients(out vec4 ippc, in mat4 c) {\n    ippc = normalize(vec4(\n        determinant(mat3(c[3].xyz, c[2].xyz, c[1].xyz)),\n        -determinant(mat3(c[3].xyz, c[2].xyz, c[0].xyz)),\n        determinant(mat3(c[3].xyz, c[1].xyz, c[0].xyz)),\n        -determinant(mat3(c[2].xyz, c[1].xyz, c[0].xyz))\n    ));\n}\n\nvoid integral_inflection_points(out float discr, out vec2 roots[3], in vec4 ippc) {\n    discr = 3.0*ippc[2]*ippc[2]-4.0*ippc[1]*ippc[3];\n    if(abs(ippc[1]) < ERROR_MARGIN) {\n        if(abs(ippc[2]) < ERROR_MARGIN) {\n            discr = -1.0;\n            roots = vec2[](\n                vec2(-1.0, 1.0),\n                vec2(1.0, 0.0),\n                vec2(1.0, 0.0)\n            );\n        } else {\n            discr = 1.0;\n            roots = vec2[](\n                vec2(ippc[3], 3.0*ippc[2]),\n                vec2(1.0, 0.0),\n                vec2(1.0, 0.0)\n            );\n        }\n    } else {\n        float d = sqrt(discr * (discr < 0.0 ? -1.0 : 1.0/3.0));\n        roots = vec2[](\n            vec2(ippc[2]+d, 2.0*ippc[1]),\n            vec2(ippc[2]-d, 2.0*ippc[1]),\n            vec2(1.0, 0.0)\n        );\n    }\n}\n\nconst mat4 cubic_power_basis = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    -3.0, 3.0, 0.0, 0.0,\n    3.0, -6.0, 3.0, 0.0,\n    -1.0, 3.0, -3.0, 1.0\n);\n\nconst mat4 inverse_cubic_power_basis = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    1.0, 1.0/3.0, 0.0, 0.0,\n    1.0, 2.0/3.0, 1.0/3.0, 0.0,\n    1.0, 1.0, 1.0, 1.0\n);\n\nvoid rational_inflection_points(out float discr, out vec2 roots[3], in vec4 ippc) {\n    if(abs(ippc[0]) < ERROR_MARGIN) {\n        integral_inflection_points(discr, roots, ippc);\n        return;\n    }\n    vec3 hc = vec3(\n        ippc[0]*ippc[2]-ippc[1]*ippc[1],\n        ippc[1]*ippc[2]-ippc[0]*ippc[3],\n        ippc[1]*ippc[3]-ippc[2]*ippc[2]\n    );\n    discr = 4.0*hc[0]*hc[2]-hc[1]*hc[1];\n    vec2 d = vec2(\n        9.0*(\n            ippc[1]*ippc[1]\n            -ippc[0]*ippc[2]\n        ),\n        27.0*(\n            -2.0*ippc[1]*ippc[1]*ippc[1]\n            +3.0*ippc[0]*ippc[1]*ippc[2]\n            -ippc[0]*ippc[0]*ippc[3]\n        )\n    );\n    vec2 c = complex_square_root(d[1]*d[1]-4.0*d[0]*d[0]*d[0]);\n    c.x += (c.x+d[1] == 0.0) ? -d[1] : d[1];\n    c = complex_cubic_root(0.5*c);\n    float p = (3.0*ippc[0]*ippc[2]-ippc[1]*ippc[1])/(3.0*ippc[0]*ippc[0]);\n    for(int i = 0; i < 3; ++i) {\n        vec2 ci = complex_multiplication(c, roots_of_unity_3[i]);\n        vec2 numerator = 3.0*ippc[1]*ci\n            -complex_multiplication(ci, ci)\n            -vec2(d[0], 0.0);\n        vec2 denominator = 3.0*ippc[0]*ci;\n        roots[i] = vec2(\n            complex_multiplication(numerator, complex_conjugate(denominator)).x,\n            dot(denominator, denominator)\n        );\n    }\n    if(discr < 0.0) {\n        int real_root = int((radians(180.0)-atan(c.y, c.x))/radians(120.0));\n        roots[2] = roots[(real_root+1)%3];\n        float d = sqrt(-discr);\n        roots[0] = vec2(-hc[1]+d, 2.0*hc[0]);\n        roots[1] = vec2(-hc[1]-d, 2.0*hc[0]);\n    }\n}\n\n// Compute Implicit Curve Weights\n\nvec4 weight_derivatives(vec2 roots[3]) {\n    return vec4(\n        roots[0].x*roots[1].x*roots[2].x,\n        -roots[0].y*roots[1].x*roots[2].x-roots[0].x*roots[1].y*roots[2].x-roots[0].x*roots[1].x*roots[2].y,\n        roots[0].x*roots[1].y*roots[2].y+roots[0].y*roots[1].x*roots[2].y+roots[0].y*roots[1].y*roots[2].x,\n        -roots[0].y*roots[1].y*roots[2].y\n    );\n}\n\nvoid weights(out mat4 w, in mat4 control_points, in float discr, in vec2 roots[3], in vec4 ippc) {\n    mat4 F;\n    if(discr == 0.0) {\n        F = mat4(\n            weight_derivatives(vec2[](roots[0], roots[0], roots[2])),\n            weight_derivatives(vec2[](roots[0], roots[0], roots[0])),\n            weight_derivatives(vec2[](roots[0], roots[0], roots[0])),\n            weight_derivatives(vec2[](roots[2], roots[2], roots[2]))\n        );\n    } else if(discr < 0.0) {\n        F = mat4(\n            weight_derivatives(vec2[](roots[0], roots[1], roots[2])),\n            weight_derivatives(vec2[](roots[0], roots[0], roots[1])),\n            weight_derivatives(vec2[](roots[1], roots[1], roots[0])),\n            weight_derivatives(vec2[](roots[2], roots[2], roots[2]))\n        );\n    } else {\n        F = mat4(\n            weight_derivatives(vec2[](roots[0], roots[1], roots[2])),\n            weight_derivatives(vec2[](roots[0], roots[0], roots[0])),\n            weight_derivatives(vec2[](roots[1], roots[1], roots[1])),\n            weight_derivatives(vec2[](roots[2], roots[2], roots[2]))\n        );\n    }\n    w = transpose(F) * inverse_cubic_power_basis;\n}\n\nvoid weight_planes(out vec3 planes[4], in mat4 w, in mat4 control_points) {\n    for(int i = 0; i < 4; ++i) {\n        vec3 a = vec3(control_points[0].xy, w[0][i])/control_points[0].z;\n        vec3 b = vec3(control_points[1].xy, w[1][i])/control_points[1].z;\n        vec3 c = vec3(control_points[2].xy, w[2][i])/control_points[2].z;\n        vec3 n = cross(b-a, c-a);\n        if(dot(n, n) < ERROR_MARGIN) {\n            vec3 d = vec3(control_points[3].xy, w[3][i])/control_points[3].z;\n            n = cross(b-a, d-a);\n        }\n        n /= n.z;\n        planes[i] = vec3(n.xy, -dot(n, a));\n    }\n    // mat4 phi = F * transpose(c) * inverse(c * transpose(c));\n}\n\nvoid normalize_implicit_curve_side(inout vec3 planes[4], in mat4 c, in mat4 w) {\n    vec2 tangent = tangent_at(c, 0.0);\n    vec2 gradient = implicit_curve_gradient(planes, w[0]);\n    float flip_side = step(0.0, dot(vec2(tangent.y, -tangent.x), gradient.xy))*2.0-1.0;\n    for(int i = 0; i < 4; ++i)\n        planes[i] *= flip_side;\n}\n\nvec4 sample_planes(in vec3 planes[4], in vec2 position) {\n    vec4 result;\n    for(int i = 0; i < 4; ++i)\n        result[i] = dot(planes[i], vec3(position, 1.0));\n    return result;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}