{
    "Shader": {
        "info": {
            "date": "1711876950",
            "description": "this is just an experiment using raymarching step count as an indicator for doing ambient occlusion",
            "flags": 0,
            "hasliked": 0,
            "id": "4c33zj",
            "likes": 2,
            "name": "just a piece of square broccoli ",
            "published": 3,
            "tags": [
                "fractal",
                "occlusion"
            ],
            "usePreview": 0,
            "username": "benhardy",
            "viewed": 99
        },
        "renderpass": [
            {
                "code": "\n#define MAX_DIST 10.0\n#define STEP_RATIO 0.5\n#define MAX_STEPS 1000\n#define EPSILON 0.0001\n#define NORMAL_DELTA 0.001\n\n#define ID_TOO_FAR -2.0\n#define ID_TOO_MANY_STEPS -1.0\n#define ID_NONE 0.0\n#define ID_SPHERE 1.0\n#define ID_PLANE 2.0\n\n#define GREEN vec3(0,1,0)\n#define RED vec3(1,0,0)\n#define BLUE vec3(0,0,1)\n#define BLACK vec3(0,0,0)\n#define WHITE vec3(1,1,1)\n#define CYAN vec3(0,1,1)\n#define YELLOW vec3(1,1,0)\n\nconst vec3 LIGHT_1_DIRECTION = normalize(vec3(1,4,-1));\n\nconst vec3 SPHERE_1_LOCATION = vec3(-1,0.25,-4);\nconst float SPHERE_1_RADIUS = 0.5;\n\nvec3 sphere_1_local(vec3 where){\n    return mod(where + 20.0,40.0 ) - 20.0;\n}\n\nmat4 makeTwist() {\n    mat4 twist1 = mat4(\n        cos(iTime*0.17),sin(iTime*0.17),0,0.2, \n        -sin(iTime*0.17),cos(iTime*0.17),0,0,\n        0,0,1,0,\n        0,0,0,1\n    );\n    float wibble = sin(iTime*0.175)*0.493485;\n    mat4 twist2 = mat4(\n        1,0,0,0,\n        0, cos(wibble),sin(wibble),0, \n        0, -sin(wibble),cos(wibble),0.02,\n        0,0,0,1\n    );\n    float wibble2 = sin(iTime * 0.34875)*0.48327564826;\n    mat4 twist3 = mat4(\n        cos(wibble2),0, sin(wibble2),0, \n        0, 1,0, 0.03,\n        -sin(wibble2),0, cos(wibble2),0,\n        0,0,0,1\n    );\n    return twist1 * twist2 *twist3;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nvec3 measure(vec3 where, mat4 twist3) {\n    \n    //plane\n    float d = where.y + 3.0;\n    float best = d;\n    float which = ID_PLANE;\n    if (d < EPSILON) {\n        return vec3(best, which,0);\n    }\n\n    //float best = MAX_DIST;\n    //float which = ID_NONE;\n\n    // do fractal first\n    float fscale = 1.0;\n    float scalestep = 2.0;\n    vec3 localised = sphere_1_local(where);\n    d = (length(localised)-SPHERE_1_RADIUS);\n    float d2;\n\n    float closestDepth = 0.0;\n    float fBest = MAX_DIST;\n    for (int depth = 0; depth < 7; depth++) {\n        localised = (abs(localised)-0.35)*scalestep;\n        localised = (vec4(localised,1)*twist3).xyz;\n        fscale *= scalestep;\n        d2 = (length(localised)-SPHERE_1_RADIUS)/fscale; // again\n        float newD = opSmoothUnion(d, d2, 0.5/fscale);\n        \n        if (newD < fBest) {\n            fBest = newD;\n            closestDepth = float(depth) + (newD-d)/(d2-d);\n        }\n        d = newD;\n    }\n    if (d < best) {\n        best = d;\n        which = ID_SPHERE;\n    }\n    \n    return vec3(best, which, closestDepth);\n}\n\nvec3 calc_surface_normal(vec3 hit, mat4 twist) {\n\treturn normalize(vec3(\n            measure(hit+vec3(NORMAL_DELTA, 0.0, 0.0),twist).x - measure(hit-vec3(NORMAL_DELTA, 0.0, 0.0),twist).x,\n            measure(hit+vec3(0.0, NORMAL_DELTA, 0.0),twist).x - measure(hit-vec3(0.0, NORMAL_DELTA, 0.0),twist).x,\n            measure(hit+vec3(0.0, 0.0, NORMAL_DELTA),twist).x - measure(hit-vec3(0.0, 0.0, NORMAL_DELTA),twist).x\n    ));\n}\n\nvec4 march(vec3 start, vec3 dir, inout vec3 where) {\n    float progress = 0.0;\n    float which = ID_NONE;\n    int step = 0;\n    mat4 twist = makeTwist();\n    for (step = 0; step < MAX_STEPS && progress < MAX_DIST; step++) {\n        float best = MAX_DIST;\n        where = start + progress * dir;\n        vec3 measured = measure(where, twist);\n        best = measured.x;\n        which = measured.y;\n        if (best <= EPSILON) {\n            break;\n        } else {\n            progress += best * STEP_RATIO;\n        }\n    }\n    if (step >= MAX_STEPS) {\n        return vec4(0,0,progress, ID_TOO_MANY_STEPS);\n    }\n    if (progress >= MAX_DIST) {\n        return vec4(0,0,progress, ID_TOO_FAR);\n    }\n    if (which > 0.0) {\n        return vec4(0,float(step),progress, which);\n    }\n    return vec4(0,0,progress,ID_NONE);\n}\n\nvec3 trace(vec2 pos) {\n    vec3 eye = vec3(sin(iTime*0.01) * 2.0, sin(iTime*0.03)*1.0+2.5, cos(iTime* 0.01) * 3.0);\n    vec3 look_at = vec3(0,0,0);\n    vec3 look = normalize(\n        look_at - eye\n    );\n    vec3 proto_up = vec3(0,1,0);\n    vec3 right = normalize(cross(proto_up, look));\n    vec3 up = normalize(cross(look, right));\n    vec3 ray = normalize(look*2.0 + pos.x * right +pos.y*up);\n    vec3 landing = eye;\n    vec4 marched = march(eye, ray, landing);\n    float which = marched.q;\n    float dist = marched.z;\n    float steps = marched.y;\n    float glow = 0.1;\n    vec3 glowColor = vec3(1,0,0);\n    vec3 color = BLACK;\n    if (which == ID_TOO_FAR) {\n        color = WHITE;\n    }\n    else if (which == ID_TOO_MANY_STEPS) {\n        color = YELLOW;\n    }\n    else if (which == ID_NONE) {\n        color = CYAN;\n    }\n    else if (which == ID_SPHERE) {\n        mat4 twist = makeTwist();\n\n        vec3 local = sphere_1_local(landing);\n        vec3 s_norm = calc_surface_normal(local, twist);\n        float colscale = measure(local, twist).y;\n        vec3 paint = vec3(clamp(1.0-colscale*2.2,0.0,1.0), 3.0, 0.1);\n        float illum = max(0.0, dot(LIGHT_1_DIRECTION, s_norm));\n        color = paint * (illum * 0.5 + 0.5);\n        float occlusion = clamp(1.0 - 0.23 * log(steps), 0.0, 1.0);\n        color *= occlusion;\n        float dotty = dot(LIGHT_1_DIRECTION, s_norm);\n        vec3 reflected = s_norm * 2.1 * dotty - LIGHT_1_DIRECTION;\n        vec3 toEye = normalize(-ray);\n        float specular = 0.2 *pow(max(0.0, dot(toEye, reflected)), 12.0);\n        color = color * 1.0;\n        color += vec3(specular, specular, specular);    \n    }\n    else if (which == ID_PLANE) {\n        color = max(fract(landing), 0.1)+0.9;\n    }\n    float fading = 1.0 - tanh(dist*0.05);\n    return fading * color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y / iResolution.x;\n    vec2 shift = 0.5* vec2(1.0, aspect);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * (fragCoord/iResolution.x - shift);\n    //uv.y *= iResolution.y /iResolution.x;\n\n    // Time varying pixel color\n    vec3 col = trace(uv);\n            \n    // gamma\n    col = pow( col, vec3(0.4545) );\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}