{
    "Shader": {
        "info": {
            "date": "1713620736",
            "description": "Dieser shader dient als beispiel zur erklaerung der einfachen interpolation von zwei formen. \neinfache interpolation ",
            "flags": 0,
            "hasliked": 0,
            "id": "Xf3Xz4",
            "likes": 1,
            "name": "simple interpolation von formen",
            "published": 3,
            "tags": [
                "simple"
            ],
            "usePreview": 0,
            "username": "jonasfrey",
            "viewed": 109
        },
        "renderpass": [
            {
                "code": "float dot2( in vec2 v ) { return dot(v,v); }\nfloat f_n_sd_heart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat f_n_sd_star(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // symmetry (optional)\n    p.x = abs(p.x);\n    \n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5)/iResolution.yy;\n    vec2 uv2 = fract(uv*vec2(2.,1.))-vec2(.5, 1.);\n    //uv = uv2;\n    uv*=1.5; // herauszoomen\n\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float n_sd_circ = dot(uv,uv);\n    float n_sd_star = f_n_sd_star(uv, .5, 5, 3.);\n    float n_sd_heart = f_n_sd_heart(uv+vec2(0., 0.5));\n    float n_t = sin(iTime)*.5+.5;//1.0 max, 0.0 min, 1.0 ->nur kreis, 0.0 ->nur stern\n    float n_interpoliert = n_t*n_sd_circ + (1.-n_t)*n_sd_star;\n    fragColor = vec4(smoothstep(0.05, 0.04, n_interpoliert));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}