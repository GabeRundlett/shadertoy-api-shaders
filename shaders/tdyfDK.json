{
    "Shader": {
        "info": {
            "date": "1607966608",
            "description": "dancing polca-dotted spheres\n\nInspired by Yayoi Kusama",
            "flags": 0,
            "hasliked": 0,
            "id": "tdyfDK",
            "likes": 5,
            "name": "Polka de Sphère",
            "published": 3,
            "tags": [
                "pattern"
            ],
            "usePreview": 0,
            "username": "IWBTShyGuy",
            "viewed": 364
        },
        "renderpass": [
            {
                "code": "// Copyright © 2020 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n// ------ Configures ------ //\nconst vec3 RED = vec3(230.0, 0.0, 18.0) / 255.0;\nconst vec3 GREEN = vec3(0.0, 167.0, 60.0) / 255.0;\nconst vec3 BLUE = vec3(0.0, 100.0, 180.0) / 255.0;\n\nconst uint N_SPHERE = 8u;\nconst float SPHERE_RADIUS = 0.5;\nconst float ORBIT_RADIUS = 2.0;\nconst float ORBIT_VELO = 1.0;\nconst float ROTATION_VELO = 1.5;\nconst vec3 ROTATION_AXIS = normalize(vec3(1.0, 2.0, 0.0));\n\nconst float SPHERE_DOT_RADIUS = 0.07;\nconst float BACK_DOT_RADIUS = 0.21;\nconst float BACK_DOT_INTERVAL = 0.12;\nconst float BACK_DOT_VELO = 1.5;\n\n// ------ 3D utilities ------ //\nconst float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction;\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nCamera newCamera(vec3 position, vec3 direction, vec3 up_direction, float fov, float aspect) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\n// perspective camera ray\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float radian = camera.fov;\n    float h = tan(radian * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\n// Rodrigues' rotation formula\nmat3 rot(vec3 axis, float angle) {\n    return mat3(\n        axis[0] * axis[0] * (1.0 - cos(angle)) + cos(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) + axis[2] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) - axis[1] * sin(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) - axis[2] * sin(angle),\n        axis[1] * axis[1] * (1.0 - cos(angle)) + cos(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) + axis[0] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) + axis[1] * sin(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) - axis[0] * sin(angle),\n        axis[2] * axis[2] * (1.0 - cos(angle)) + cos(angle)\n    );\n}\n\nbool depthTest(in Ray ray, in vec3 current_position, in vec3 new_position) {\n    float dist0 = distance(ray.origin, current_position);\n    float dist1 = distance(ray.origin, new_position);\n    return dist0 > dist1;\n}\n\n// ------ sphere ------ //\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\nSphere newSphere(in vec3 center, in float radius) {\n    Sphere sphere;\n    sphere.center = center;\n    sphere.radius = radius;\n    return sphere;\n}\n\nconst float A = (sqrt(5.0) + 1.0) / 2.0;\nconst float B = (sqrt(5.0) - 1.0) / 2.0;\n\nconst uint N = 32u; // the number of vertices.\nconst vec3 VERTICES[N] = vec3[](\n    normalize(vec3(1.0, 1.0, 1.0)),\n    normalize(vec3(1.0, 1.0, -1.0)),\n    normalize(vec3(1.0, -1.0, 1.0)),\n    normalize(vec3(1.0, -1.0, -1.0)),\n    normalize(vec3(-1.0, 1.0, 1.0)),\n    normalize(vec3(-1.0, 1.0, -1.0)),\n    normalize(vec3(-1.0, -1.0, 1.0)),\n    normalize(vec3(-1.0, -1.0, -1.0)),\n    normalize(vec3(0.0, A, B)),\n    normalize(vec3(0.0, A, -B)),\n    normalize(vec3(0.0, -A, B)),\n    normalize(vec3(0.0, -A, -B)),\n    normalize(vec3(A, B, 0.0)),\n    normalize(vec3(A, -B, 0.0)),\n    normalize(vec3(-A, B, 0.0)),\n    normalize(vec3(-A, -B, 0.0)),\n    normalize(vec3(B, 0.0, A)),\n    normalize(vec3(B, 0.0, -A)),\n    normalize(vec3(-B, 0.0, A)),\n    normalize(vec3(-B, 0.0, -A)),\n    normalize(vec3(0.0, 1.0, A)),\n    normalize(vec3(0.0, 1.0, -A)),\n    normalize(vec3(0.0, -1.0, A)),\n    normalize(vec3(0.0, -1.0, -A)),\n    normalize(vec3(1.0, A, 0.0)),\n    normalize(vec3(1.0, -A, 0.0)),\n    normalize(vec3(-1.0, A, 0.0)),\n    normalize(vec3(-1.0, -A, 0.0)),\n    normalize(vec3(A, 0.0, 1.0)),\n    normalize(vec3(A, 0.0, -1.0)),\n    normalize(vec3(-A, 0.0, 1.0)),\n    normalize(vec3(-A, 0.0, -1.0))\n);\n\nbool onSphere(in Ray ray, in Sphere sphere, out vec3 intersection) {\n    vec3 to_center = sphere.center - ray.origin;\n    vec3 h = to_center - dot(to_center, ray.direction) * ray.direction;\n    float d2 = sphere.radius * sphere.radius - dot(h, h);\n    if (d2 < 0.0) return false;\n    intersection = ray.origin + (dot(to_center, ray.direction) - sqrt(d2)) * ray.direction;\n    return true;\n}\n\n// ------ basis function for gradation ------ //\nfloat parab(float t) { return 2.0 * t * t; }\n\nvec3 nowColor(float t) {\n    t = fract(t / 3.0) * 3.0;\n    float r0 = t < 1.0 ? (t < 0.5 ? 1.0 - parab(t) : parab(1.0 - t)) : 0.0;\n    float g = t < 2.0 ? (t < 1.0 ? 1.0 - r0 : (t < 1.5 ? 1.0 - parab(t - 1.0) : parab(2.0 - t))) : 0.0;\n    float r1 = 2.0 < t ? (t < 2.5 ? parab(t - 2.0) : 1.0 - parab(3.0 - t)) : 0.0;\n    float b = 1.0 < t ? 1.0 - g - r1 : 0.0;\n    return (r0 + r1) * RED + g * GREEN + b * BLUE;\n}\n\nSphere[N_SPHERE] createSpheres(float t) {\n    Sphere sphere[N_SPHERE];\n    for (uint i = 0u; i < N_SPHERE; i++) {\n        float theta = t + 2.0 * PI * float(i) / float(N_SPHERE);\n        sphere[i] = newSphere(vec3(sin(theta), 0.0, cos(theta)) * ORBIT_RADIUS, SPHERE_RADIUS);\n    }\n    return sphere;\n}\n\nvec4 backGroundPolka(in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y / BACK_DOT_INTERVAL + BACK_DOT_VELO * iTime;\n    vec2 lattice = uv + 0.5;\n    lattice = vec2(floor(lattice.x), floor(lattice.y));\n    if (distance(uv, lattice) < BACK_DOT_RADIUS) return vec4(nowColor(iTime), 1.0);\n    else return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvec3 rotOnSphere(in Sphere sphere, in vec3 position, mat3 rotation) {\n    return rotation * (position - sphere.center) + sphere.center;\n}\n\nvec4 spherePolka(in Sphere sphere, in vec3 position) {\n    for (uint i = 0u; i < N; i++) {\n        vec3 dot_center = sphere.radius * VERTICES[i] + sphere.center;\n        if (distance(position, dot_center) < SPHERE_DOT_RADIUS) {\n            return vec4(nowColor(-iTime), 1.0);\n        }\n    }\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 unit = normalize(vec3(0.0, -0.5, 1.0));\n    Camera camera = newCamera(\n        -5.0 * unit - vec3(0.0, 0.5, 0.0),\n        unit,\n        vec3(0.0, 1.0, 0.0),\n        PI / 4.0,\n        iResolution.x / iResolution.y\n    );\n    Ray ray = cameraRay(camera, uv);\n\n    Sphere sphere[N_SPHERE] = createSpheres(ORBIT_VELO * iTime);\n    bool onOneSphere = false;\n    vec3 position = vec3(100.0);\n    uint idx;\n    for (uint i = 0u; i < N_SPHERE; i++) {\n        vec3 tmp_position;\n        if (onSphere(ray, sphere[i], tmp_position)) {\n            if (depthTest(ray, position, tmp_position)) {\n                position = tmp_position;\n                idx = i;\n            }\n            onOneSphere = true;\n        }\n    }\n    if (onOneSphere) {\n        mat3 rotation = rot(ROTATION_AXIS, ROTATION_VELO * iTime);\n        position = rotOnSphere(sphere[idx], position, rotation);\n        fragColor = spherePolka(sphere[idx], position);\n    } else {\n        fragColor = backGroundPolka(fragCoord);\n    }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}