{
    "Shader": {
        "info": {
            "date": "1556848516",
            "description": "Cube Too Maze",
            "flags": 96,
            "hasliked": 0,
            "id": "WlfGzj",
            "likes": 16,
            "name": "Cube Too Maze",
            "published": 3,
            "tags": [
                "cube",
                "too",
                "maze"
            ],
            "usePreview": 0,
            "username": "aiekick",
            "viewed": 662
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by Stephane Cuillerdier - @Aiekick/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/WlfGzj\n// Tuned with NoodlesPlate\n\nconst vec3 neonColor = vec3(1.0,0.5,0.0);\nconst float blackbodyFactor = 200.0;\nconst mat4 light0 = mat4(0.819152,0.573576,0,0,-0.40558,0.579228,0.707107,0,0.40558,-0.579228,0.707107,0,-2.5037,2.39084,-3.22105,1);\nconst float normalPrec = 0.01;\nconst int countSteps = 200;\nconst float maxDistance = 100.0;\nconst float stepScale = 0.3;\nconst float accCoef = 0.05;\nconst vec4 coefs = vec4(9.59854,0.28102,1,0.98905);\nconst int countStepsY = 10;\nconst float cubeCorners = 0.2;\nconst float cubeSize = 2.3;\nconst float fillet = 0.0;\n\nmat3 rx(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 ry(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 rz(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nfloat cube(vec3 p, float s)\n{\n\treturn length(max(abs(p)-s,0.0));\n}\n\n// from Shane Shader but original from Fizzer\nfloat mazeSDF(vec3 p)\n{\n   vec3 ip = floor(p) + .5;\n   vec3 q = p - ip;\n   p = abs(q); \n   q = step(p.yzx, p.xyz)*step(p.zxy, p.xyz)*sign(q);\n   q.x = fract(sin(dot(ip + q*.5, vec3(111.67, 147.31, 27.53)))*43758.5453);\n   p.xy = abs(q.x>.333 ? q.x>.666 ? p.xz : p.yz : p.xy);\n   return max(p.x, p.y);  \n}\n\nvec2 maxo(vec2 a,vec2 b)\n{\n\tif (a.x > b.x)\n\t\treturn a;\n\treturn b;\n}\n\nvec2 mino(vec2 a,vec2 b)\n{\n\tif (a.x < b.x)\n\t\treturn a;\n\treturn b;\n}\n\nvec3 _TransRot(vec3 p)\n{\n\tp.y -= 2.0;\n\tp *= ry(iTime * 0.5);\n\tp *= rz(radians(35.));\n\tp *= rx(radians(45.));\n\treturn p;\n}\n\n#define MAZE_MAT 0.\n#define DOMAIN_MAT 1.\n#define CUBE_MAT 2.\n#define GROUND_MAT 3.\n\nfloat acc;\n\nvec2 monolith(vec3 p)\n{\n\tp = _TransRot(p);\n\t\n\t// maze\n\tvec3 k = p * coefs.x;\n\tvec2 kf = vec2(mazeSDF(k) - coefs.y,MAZE_MAT);\n\t\n\t// monolith limit\n\tvec2 cmax = vec2(cube(p, coefs.z),DOMAIN_MAT);\n\tvec2 c = vec2(cube(p, coefs.w),CUBE_MAT);\n\t\n\tvec2 res = maxo(cmax,mino(c,-kf))-fillet;\n\t\n\tif (abs(CUBE_MAT-res.y)<0.5)\n\t{\n\t\tacc += accCoef;\n\t}\n\t\n\treturn res;\n}\n\nvec2 ground(vec3 p)\n{\n\treturn vec2(p.y - sin(dot(p.xz,p.xz)*0.5 - iTime) * 0.125, GROUND_MAT);\n}\n\t\nvec2 getSDF(vec3 p)\n{\n\tvec2 mo = monolith(p);\n\tvec2 gr = ground(p);\n\treturn mino(gr,mo);\n}\n\nfloat march( in vec3 ro, in vec3 rd )\n{\n\tfloat s = 1.;\n    float d = 0.;\n\tfor( int i=0; i<countSteps; i++ )\n    {\n        if( \n\t\t\td*d/s>1e6||\n\t\t\t//abs(s)<0.0025*(d*.125 + 1.)||\n\t\t\td>maxDistance ) break;\n\t    s = getSDF( ro+rd*d ).x;\n        d += s * stepScale;\n    }\n    return d;\n}\n\nvec3 getNor( vec3 p, float k )\n{\n\tvec3 eps = vec3( k, 0., 0. );\n\tvec3 nor = vec3(\n\t    getSDF(p+eps.xyy).x - getSDF(p-eps.xyy).x,\n\t    getSDF(p+eps.yxy).x - getSDF(p-eps.yxy).x,\n\t    getSDF(p+eps.yyx).x - getSDF(p-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat getSha( in vec3 ro, in vec3 rd, in float hn)\n{\n    float res = 1.0;\n    float t = 0.0005;\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )\n    {\n        h = getSDF(ro + rd*t).x;\n        res = min( res, hn*h/t );\n\t\tt += clamp( h, 0.02, 2.0 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat getAO( in vec3 p, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12 * float(i)/4.0;\n        vec3 aopos =  nor * hr + p;\n        float dd = getSDF( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// from Shane\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    \n    //return cellTileColor(p);\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z ); \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// from Shane\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.002, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\nvec3 light( in vec3 lightdir, in vec3 lightcol, in vec3 tex, in vec3 norm, in vec3 camdir )\n{    \n    float cosa = pow(0.5 + 0.5*dot(norm, -lightdir),2.0);\n    float cosr = max(dot(-camdir, reflect(lightdir, norm)), -0.0);\n    \n    float diffuse = cosa;\n    float phong = pow(cosr, 32.0);\n    \n    return lightcol * 1.5 * (tex * diffuse + phong);\n}\n\nvec3 GetRainBow(float r)\n{\n\tint i = int(3.*fract(r)); \n\tvec4 c = vec4(.25);   \n\tc[(i+1)%3] += r = fract(3.*r);\n\tc[i] += 1.-r;\n\treturn c.rgb;\n}\n\nvec3 material( in vec3 ro , in vec3 rd, in float d )\n{    \n\tvec3 pos = ro + rd * d;\n\t\n\tvec3 n = getNor(pos, normalPrec);\n    \n    vec3 d1 = -normalize(light0[3].xyz);\n    \n\tvec3 tex = vec3(1.0);\n    float sha = 1.0;\n    float ao = 1.0;\n    \t\n\tfloat mat = getSDF(pos).y;\n\t\n    if (mat < GROUND_MAT + 0.5)\n\t{\n\t\tconst float tSize0 = 0.2;\n\t\tn = texBump(iChannel0, pos * tSize0, n, 0.005);\n\t\ttex = tex3D(iChannel0, pos * tSize0, n);\n\t}\n\t\n    sha = 0.5 + 0.5 * getSha(pos, n, 2.0);\n    ao = getAO(pos, n);\n    \n    vec3 l1 = light(d1, vec3(1), tex, n, rd);\n    \n\tvec3 amb = tex * 0.2;\n\tvec3 col = amb * ao + l1 *  sha;\n    \n\tvec4 sound = texture(iChannel1, vec2(0.01,0.01));\n    float dd = mazeSDF(sin(_TransRot(pos))*pos) - 2.;\n    col += acc * GetRainBow(sound.x*dd*0.8);\n\t\n\tcol = mix(col, vec3(0), 1.0-exp(-0.005*d*d));\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tacc = 0.0;\n\t\n    float ca = 2.;\n    float ce = 6.;\n    float cd = 7.;\n    \n    if (iMouse.z > 0.)\n    {\n    \tcd = 10. * iMouse.y/iResolution.y;\n        ce = 10. * iMouse.x/iResolution.x;\n    }\n    \n   \tvec2 uv = (fragCoord*2. - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec3 ro = vec3(cos(ca), ce, sin(ca)); ro.xz *= cd;\n    vec3 rov = normalize(-ro);\n    vec3 u = normalize(cross(vec3(0,1,0),rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + 0.5*uv.x*u + 0.5*uv.y*v);\n\n    vec3 col = vec3(0.0);\n    \n\tfloat d = march(ro, rd);\n    \n\tif (d < maxDistance)\n    {\n    \tcol = material(ro, rd, d);\n    }\n \n\tfragColor = vec4(sqrt(col*col*1.2),1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 18560,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/deejaybol/jason-derulo-swalla-bol-moombahton-remix"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}