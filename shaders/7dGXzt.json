{
    "Shader": {
        "info": {
            "date": "1635104741",
            "description": "a u r123\n\nany tips on how to reduce artifacts without ruining performance ?",
            "flags": 32,
            "hasliked": 0,
            "id": "7dGXzt",
            "likes": 1,
            "name": "auroracorev222222",
            "published": 3,
            "tags": [
                "222"
            ],
            "usePreview": 0,
            "username": "WaifuFarmer",
            "viewed": 335
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - mod(fragCoord, SCALE)) / iResolution.xy;\n    //vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(pow(texture(iChannel0, uv).rgb / 10., vec3(0.454545)), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_STEPS 1280\n#define MAX_DIST 1280.\n#define MAX_DIST_CHECK MAX_DIST - 10.\n#define E 0.001\n#define PI 3.141592\n#define MODE 1\n\n#define PI 3.141592\n\n//#define PRECISION (sin(iDate.w)*.1+.11)\n//#define INV_PRECISION (1. / PRECISION)\n#define PRECISION 0.1\n#define INV_PRECISION 10.\n\n#define MIND_RATIO 0.6\n#define COL_LOL_RATIO (sin(iDate.w*0.73)*.5+.5)\n\nvec3 rotX(vec3 v, float a)\n{\n    return vec3(v.x, v.y * cos(a) - v.z * sin(a), v.y * sin(a) + v.z * cos(a));\n}\n\nvec3 rotY(vec3 v, float a)\n{\n    return vec3(v.x * cos(a) + v.z * sin(a), v.y, v.z * cos(a) - v.x * sin(a));\n}\n\nvec3 rotZ(vec3 v, float a)\n{\n    return vec3(v.x * cos(a) - v.y * sin(a), v.x * sin(a) + v.y * cos(a), v.z);\n}\n\nvec3 modSDF(vec3 p, vec3 c)\n{\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\nvec3 modSDFlim( in vec3 p, in float c, in vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nvec3 elongateSDF(in vec3 p, in vec3 h )\n{\n    vec3 q = abs(p)-h;\n    return max(q,0.0) + min(max(q.x,max(q.y,q.z)), 0.0);\n}\n\nvec3 twistSDF(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\nfloat sdfBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdfTorus(vec3 p, vec2 r)\n{\n    float x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\n\nfloat sdfSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat scene(vec3 p)\n{\n    //p = modSDF(p, vec3(30., 30., 30.))+ sin(iTime + p.x) * 10.;\n    //p.x /= iResolution.x / iResolution.y - 0.3;\n    float stx = sin(iDate.w);\n    float sty = sin(iDate.w * 1.228);\n    float stz = sin(iDate.w * 0.856);\n    float displacement_mapping = sin(p.y) + 0.3 * sin(p.x * (1.23 + 2. * stx)) * sin(p.y * (1.37 + 2.2 * sty)) * sin(p.z * (1.56 + 2.12 * stz));\n    float dm = 0.2 * sin(p.x * sin(iDate.w / 5.) * 3.) * sin(p.y * sin(iDate.w / 4.) * 3.) * sin(p.z * sin(iDate.w / 6.) * 3.);\n    //float size = abs(mod(p.x * 0.3 + p.y * 0.5+ p.z * 0.4 + iDate.w, delay) - delay * 0.5);\n    //displacement_mapping *= size;\n    vec2 torus_0 = vec2(4.8, 0.6);\n    vec3 p_mod = rotZ(rotY(rotX(p, iDate.w * 1.2), sin(iDate.w) * 1. * displacement_mapping), iDate.w * .9);\n        return PRECISION * sdfTorus(twistSDF(p_mod, (sin(iDate.w * 0.8)-0.7) + 0.3 +  displacement_mapping * 0.1 + sin(iTime)*.5+.9) + displacement_mapping * 0.1, torus_0) + dm * 0.2 * smoothstep(-1., 1., stx) + 0.033 * (sin(iTime));\n}\n\n\nvec2 march(vec3 ro, vec3 rd, float side)\n{\n    float ray_dist = 0.;\n    float mind = 10000.;\n    for (int steps = 0; steps < MAX_STEPS; steps++)\n    {\n        vec3 p = ro + rd * ray_dist;\n        float step_dist = scene(p) * side;\n        if (step_dist * INV_PRECISION < mind)\n            mind = step_dist * INV_PRECISION;\n        ray_dist += step_dist;\n        if (step_dist < E || ray_dist > MAX_DIST)\n            break;\n    }\n    return vec2(ray_dist, mind);\n}\n\nvec3 normal(vec3 p)\n{\n    float d = scene(p);\n    vec2 e = vec2(E, 0.);\n    \n    vec3 n = d - vec3(\n        \t\tscene(p - e.xyy),\n                scene(p - e.yxy),\n                scene(p - e.yyx));\n    return normalize(n);\n}\n\nfloat light(vec3 p, vec3 n, float side)\n{\n    vec3 lightPos = vec3(-30. * sin(iTime), 30., -30. * cos(iTime));\n    vec3 l = normalize(lightPos - p);\n    float dif = clamp(dot(l, side * n), 0.1, .7);\n    vec2 d = march(p + n, l, -side);\n    if (d.x < length(lightPos - p))\n       return dif * 0.;\n    return dif;\n\n}\n\nvec3 get_ray_dir(vec2 uv, vec3 p, vec3 l, float z)\n{\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (ivec2(mod(fragCoord, SCALE)) != ivec2(0))\n        return;\n\tvec3 col = vec3(0);\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / iResolution.y);\n    //vec3 ro = vec3(20. * sin(iTime), 0., -20. * cos(iTime));\n    //vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    //rd = rotY(rd, -iTime);\n\n\tvec2 m = iMouse.xy/iResolution.xy;\n    vec3 ro = vec3(10, 0, -10);\n    ro.yz *= rot(-m.y * PI + 1.);\n    ro.xz *= rot(-m.x * TAU);\n    \n    vec3 rd = get_ray_dir(uv, ro, vec3(0,0.,0), 0.9);\n\n    \n    vec2 d = march(ro, rd, 1.);\n    float mind = 1. - pow(1. - min(1., max(d.y, 0.)), 2.2);\n    mind = d.y;\n    vec3 p = ro + rd * d.x;\n    vec3 n = normal(p);\n    vec3 pp = p + n * E * 10.;\n    vec3 refr = rd;\n    int i = 1;\n    vec3 lol = vec3(0);\n    //if (d.x < MAX_DIST_CHECK)\n    //    col += light(pp, n, 1.) * vec3(pp.x - 3., pp.y - 3., pp.z - 3.) / 8.;\n    float st = sin(iTime * 0.93)*.5+.5;\n    //st = 0.;\n    while (1 - MODE == 0 && d.x < MAX_DIST_CHECK && i < 4)\n    {\n        //col += light(pp, n, mod(float(i + 1), 2.)*2.-1.)\n        //    *(vec3(pp.x - 3., pp.y + 100., pp.z - 13.) * st\n        //    + vec3(d.x * 20., d.y * 7., length(p) / 3.) * (1. - st))\n        //    / exp(float(i) + 1.5);\n        col += light(pp, n, mod(float(i + 1), 2.)*2.-1.) * (modSDF(abs(pp), vec3(10.)) + n) * 0.7 * (sin(iTime*0.24562152534)*0.25+0.75);\n        /*refr = refract(refr, n, 1./1.3);\n        d = march(p - n * E * 3., refr, 1.);\n        p = ro + rd * d.x;\n        n = normal(p);\n        pp = p + n * E * 10.;*/\n        i++;\n        mind += abs(d.y);\n    }\n    mind /= float(i);\n    mind = MIND_RATIO / mind;\n    //vec3 mind = vec3(1.) - pow(vec3(1.) - vec3(min(1., max(d.y, 0.))), vec3(2.2));\n    //col += (1. - log(mind + 1.)) * max(0., (0.4 - min(1.4, max(d.y, 0.))));\n    //col = vec3(mind);\n    //col += smoothstep(0.8, 1.1, 3.333 * max(0., (0.3 - min(1., max(mind, 0.)))));\n    //col = col * COL_LOL_RATIO + lol * (1. - COL_LOL_RATIO);\n    //col += 0.00 * vec3(sin(iDate.w / 2.), cos(iDate.w / 3.), sin(iDate.w / 4.)) * 0.3 * (1. - pow(1. - vec3(min(1., max(d.y, 0.))), vec3(2.2)));\n    //col *= smoothstep(0., 0.4, max(0., 0.45 - length(uv)));\n    //col = ((1. - (sin(iDate.w * 0.6)*.5+.5)) + 0.4) * pow(col, vec3(0.454545));\n    col = pow(col, vec3(0.454545));\n    //ADD THIS//col += 0.2*vec3(0.1, 0.4, 0.9) * smoothstep((cos(iDate.w)*.5+.7) * 1., (sin(iDate.w)*.5+.7) * 10., mind);\n    fragColor = vec4(1.*col, 1.);\n    //fragColor = vec4(col /*+ (sin(iTime * 2.8)*.5+.5) * 0.99 * texture(iChannel0, fragCoord / iResolution.xy).brg * vec3(0.8, .5, 1.2)*/, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define TAU 6.283185\n#define STK(x) (sin(iTime * x * TAU)*.5+.5)\n#define FUN (1. + floor(STK(STK(.1) * .11)*8.))\n#define SCALE 1.\n/*\n** Trigonometry functions\n*/\n\nmat2 rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n/*\n** Bitwise Operators\n*/\n\nint xor(float a, float b)\n{\n    a = float(int(a));\n    b = float(int(b));\n    int c = 0;\n    for (float i = 1.; i < 65536.; i *= 2.)\n    {\n        float m = i * 2.;\n        int d = 0;\n        if (mod(a, m) > i-0.5)\n            d++;\n        if (mod(b, m) > i-0.5)\n            d++;\n        if (d == 1)\n            c += int(i);\n    }\n    return c;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}