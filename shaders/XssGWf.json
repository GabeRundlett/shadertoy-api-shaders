{
    "Shader": {
        "info": {
            "date": "1380823867",
            "description": "trying to simulate a Gertner-trochoid like gravity wave:\nx = x + Acos(phase), dens = dens0 + Asin(phase)",
            "flags": 0,
            "hasliked": 0,
            "id": "XssGWf",
            "likes": 13,
            "name": "galactic arm",
            "published": 3,
            "tags": [
                "noise",
                "warp"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1044
        },
        "renderpass": [
            {
                "code": "//---  Galaxy --- Fabrice NEYRET  august 2013\n\nconst float RETICULATION = 3.;  // strenght of dust texture\nconst float NB_ARMS = 2.;       // number of arms\n//const float ARM = 3.;         // contrast in/out arms\nconst float COMPR = .9;         // compression in arms\nconst float SPEED = .1;\nconst float GALAXY_R = 1./2.;\nconst float BULB_R = 1./4.;\nconst vec3 GALAXY_COL = vec3(.9,.9,1.); //(1.,.8,.5);\nconst vec3 BULB_COL   = vec3(1.,.8,.8);\nconst vec3 SKY_COL    = .5*vec3(.1,.3,.5);\n\t\t\n#define Pi 3.1415927\n\tfloat t;\nvec2 FragCoord;\nvec4 FragColor;\n\n\n#define ANIM true\n\nfloat scale = 1.;\n\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//mat3 m = mat3( 0.00,  0.80,  0.60,\n//              -0.80,  0.36, -0.48,\n//              -0.60, -0.48,  0.64 );\nmat3 m = mat3(-0.60, -0.48,  0.64,\n              -0.80,  0.36, -0.48,\n               0.00,  0.80,  0.60);\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n// --- End of Created by inigo quilez\n\n\nfloat fbmm( vec3 p )\n{\n    float f;\n    f  =    noise( p ); p = m*p*2.02;\n    f *= 2.*noise( p ); p = m*p*2.03;\n    f *= 2.*noise( p ); p = m*p*2.01;\n    f *= 2.*noise( p ); p = m*p*2.03;\n    f *= 2.*noise( p ); p = m*p*2.01;\n    f *= 2.*noise( p );\n    return f;\n}\n\n#define noises(p) (2.*noise(p)-1.)\nfloat fbms( vec3 p )\n{\n    float f;\n    f  = 0.5000*noises( p ); p = m*p*2.02;\n    f += 0.2500*noises( p ); p = m*p*2.03;\n    f += 0.1250*noises( p ); p = m*p*2.01;\n    f += 0.0625*noises( p );\n    return f;\n}\nfloat scaleW = 0.;\n#define warp1(p) p\n#define warp2(p) p\nfloat fbmms( vec3 p )\n{\n    float f;\n\tp = warp2(p);\n    f  = 1.+scale*noises( warp1(p) ); p = warp2(m*p*2.02);\n    f *= 1.+scale*noises( warp1(p) ); p = warp2(m*p*2.03);\n    f *= 1.+scale*noises( warp1(p) ); p = warp2(m*p*2.01);\n    f *= 1.+scale*noises( warp1(p) ); p = warp2(m*p*2.03);\n    f *= 1.+scale*noises( warp1(p) ); p = warp2(m*p*2.01);\n    f *= 1.+scale*noises( warp1(p) );\n#if 0\n\t p = warp2(m*p*2.03);\n    f *= 1.+scale*noises( warp1(p) ); p = warp2(m*p*2.01);\n    f *= 1.+scale*noises( warp1(p) );\n#endif\n    return .5*f;\n}\nfloat fbma( vec3 p )\n{\n    float f;\n    f  = 0.5000*abs(noise( p )); p = m*p*2.02;\n    f += 0.2500*abs(noise( p )); p = m*p*2.03;\n    f += 0.1250*abs(noise( p )); p = m*p*2.01;\n    f += 0.0625*abs(noise( p ));\n    return f;\n}\nfloat fbmsa( vec3 p )\n{\n    float f;\n    f  = 0.5000*abs(noises( p )); p = m*p*2.02;\n    f += 0.2500*abs(noises( p )); p = m*p*2.03;\n    f += 0.1250*abs(noises( p )); p = m*p*2.01;\n    f += 0.0625*abs(noises( p ));\n    return f;\n}\nfloat fbmsma( vec3 p )\n{\n    float f;\n    f  = 0.5000*(1.-abs(noises( p ))); p = m*p*2.02;\n    f += 0.2500*(1.-abs(noises( p ))); p = m*p*2.03;\n    f += 0.1250*(1.-abs(noises( p ))); p = m*p*2.01;\n    f += 0.0625*(1.-abs(noises( p )));\n    return f;\n}\n\n// gives a random 1..N integer for index i\n#define rnd(i,N) int(1.+float(N)*hash(float(i)))\n\n// gives a random 1..N integer every T seconds, starting at i.\n#define rndT(i,N,T) int(1.+float(N)*hash(float(i)+floor(t/(T))))\n\nvec2 noise2_2( vec2 p )     // 2 noise channels from 2D position\n{\n\tvec3 pos = vec3(p,.5);\n\tif (ANIM) pos.z += t;\n\tpos *= m;\n    float fx = noise(pos);\n    float fy = noise(pos+vec3(1345.67,0,45.67));\n    return vec2(fx,fy);\n}\n\nbool affSlider(vec2 p0, vec2 dp, float v,int ticks)\n{\n\tfloat R=5.;\n\tvec2 pix = FragCoord.xy/iResolution.y;\n\tfloat pt = max(1e-2,1./iResolution.y); R*=pt;\n\tpix -= p0;\n\n\tfloat dp2 = dot(dp,dp);\n\tfloat x = dot(pix,dp)/dp2; if ((x<0.)||(x>1.)) return false;\n\tfloat x2=x*x;\n\tfloat y = dot(pix,pix)/dp2-x2; if (y>R*R) return false;\n\n\tFragColor = vec4(1.,.2,0.,1.); \n\ty = sqrt(y);\n\tif (y<pt) return true;       // rule\n\tvec2 p = vec2(x-v,y);\n\tif (dot(p,p)<R*R) return true; // button\n\tif ((ticks>0)&&\n\t (int(mod(FragCoord.x-p0.x,iResolution.y*dp.x/float(ticks)))==0)) return true;\n\n\treturn false;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime;\n    FragCoord=fragCoord;\n\tFragColor = vec4(0.);\t\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\tuv = 2.*(uv - vec2(.8,.5));\n\n#if 0\n\tvec2 val = iMouse.xy/iResolution.y;\n\t\n\tif (affSlider(vec2(.05,.02),vec2(.45,.0),val.x,0)) { fragColor=FragColor; return;}\n\tif (affSlider(vec2(.02,.05),vec2(0.,.45),val.y,0)) { fragColor=FragColor; return;}\n\tscale  = val.y;\n\tscaleW = val.x;\n#else\n\tscale  = 1.;\n#endif\n\t\n\tvec3 pos = vec3(5.*uv,0.5);\n\tvec3 col;\n\tfloat shape, noiz;\n\n\t// spiral stretching with distance\n\tfloat rho = length(uv); // polar coords\n\tfloat ang = atan(uv.y,uv.x);\n\tfloat shear = 2.*log(rho); // logarythmic spiral\n\tfloat c = cos(shear), s=sin(shear);\n\tmat2 R = mat2(c,-s,s,c);\n\n\t// galaxy profile\n\tfloat r; // disk\n\tr = rho/GALAXY_R; float dens = exp(-r*r);\n\tr = rho/BULB_R;\t  float bulb = exp(-r*r);\n\tfloat phase = NB_ARMS*(ang-shear);\n\t// arms = spirals compression\n\t//ang = ang-.5*COMPR*cos(phase)+SPEED*t; // .1/rho\n    ang = ang-COMPR/NB_ARMS*cos(phase)+SPEED*t;\n\tuv = rho*vec2(cos(ang),sin(ang));\n\t// stretched texture must be darken by d(new_ang)/d(ang)\n\tfloat spires = 1.+NB_ARMS*COMPR*sin(phase);\n\t// pires = mix(1.,sin(phase),ARM);\n\n\tdens = 1.+COMPR*sin(phase);\n\t//dens *= .7*spires;\t\n\t\n\t// gaz texture\n\tfloat gaz = fbmms(vec3(100.*.09*1.2*R*uv,0.5));\n\tfloat gaz_trsp = pow(clamp(1.-gaz*dens,0.,1.),2.);\n\tvec3 stars = vec3(0.);\n\t\n\n\t// mix all\t\n#if 0\n\tcol = mix(SKY_COL,\n\t\t\t  gaz_trsp*(1.7*GALAXY_COL) + 1.2*stars, \n\t\t\t  dens);\n\tcol = mix(col, 1.2*BULB_COL, bulb);\n#else\n\tcol = vec3(1.-dens*gaz);\n#endif\n\t\t\n\t\n\t\n\t\n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}