{
    "Shader": {
        "info": {
            "date": "1595634046",
            "description": "#makeYourShadersPublic, This one is 3.5 year old. \nNo code cleanup",
            "flags": 96,
            "hasliked": 0,
            "id": "3tByWd",
            "likes": 55,
            "name": "â™« 82 attoseconds",
            "published": 3,
            "tags": [
                "raymarching",
                "drumbass",
                "makeyourshaderspublic"
            ],
            "usePreview": 1,
            "username": "patu",
            "viewed": 4961
        },
        "renderpass": [
            {
                "code": "#define T texture(iChannel0, uv\n#define W vec2\n\n#define BLOOM\n\n#define time iTime\n    float alpha;\n#define res iResolution\nvec4\n     bloom = vec4(0),\n     blur = vec4(0);\n\n#define GA 2.399\nmat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\nvec3 pixel=vec3(.001*8./6.,.001, 0) * .05;\n\n\nfloat intensity(vec4 col) {\n\treturn dot(col.rgb, vec3(0.2126, 0.7152, 0.0722));\n}\n\n// \tsimplyfied version of Dave Hoskins blur\nvoid dof(sampler2D tex, vec2 uv, float rad, vec4 org)\n{\n\tvec2 angle=vec2(0,rad);\n    rad=1.;\n    float bc = 1.;\n\tfor (int j=0;j<60;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        \n        vec4 col=texture(tex,uv+pixel.xy*(rad-1.)*angle);\n        if (intensity(col) > .8) {            \n\t\t\tbloom += col; \n            //bc++;\n        }\n        blur += col;\n\t}\n\tblur /= 96.;\n    //bloom /= bc;\n}\n\n//-------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / res.xy;\n    \n    vec4 orgColor = (\n        texture(iChannel0,uv) \n    \t+ (texture(iChannel0,uv + pixel.xz)\n        \t+ texture(iChannel0,uv + pixel.zx)\n        \t+ texture(iChannel0,uv - pixel.xz)\n        \t+ texture(iChannel0,uv - pixel.zx)\n         ) * .25\n    ) / 2.,\n        \n    oo = orgColor;\n    \n    alpha = texture(iChannel0,uv).a;\n    \n    dof(iChannel0,uv, 40., orgColor);\n    \n    #ifdef BLOOM\n    \n    orgColor += bloom * 0.03;\n    #endif\n    \n    \n    orgColor = mix(\n        orgColor, \n        blur, \n        clamp(\n        \tmin(1., 1. - pow(abs(alpha - .6) * 2., 2.)),\n            0.,\n            1.\n        )\n    );\n    \n    \n    orgColor = mix(\n        orgColor, \n        blur.bgra, \n        clamp(\n        \tmin(1., pow(length(uv -.5) * 1.4, 2.)),\n            0.,\n            1.\n        )\n    );\n    \n\n    \n    \n    \n    \n \t//fragColor = oo;\n    fragColor = orgColor;    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define V vec3\n#define W vec2\n#define F float\n\nconst float BMP = 124.;\nfloat BEAT_COUNT ;\nfloat BEATN ;\n\nfloat hash12(vec2 p) {\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123);\n}\n\nfloat scene;\n\n#define FAR 570.\n#define INFINITY 1e32\n#define t iTime\n#define mt iChannelTime[1]\n#define FOV 100.0\n#define FOG .06\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat vol = 0.;\nF \n    Z = 0., \n    J = 1.;\n\nfloat B(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nvec3 fromRGB(int r, int g, int b) {\n \treturn vec3(float(r), float(g), float(b)) / 255.;   \n}\n    \nvec3 \n    light = vec3(0.0),\n    p = vec3(0.),\n    p2 = vec3(0.),\n\tlightDir = vec3(0.);\n\n\nvec3 lightColour = normalize(vec3(1.8, 1.0, 0.3)); \n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\nvec4 fold1(vec4 z) {\n    vec3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return vec4(p, z.w);\n}\n\nvec4 fold2(vec4 z) {\n    vec3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return vec4(p * 2.0, 2.0 * z.w);\n}\n\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nstruct geometry {\n    float dist;\n    vec3 space;\n    vec3 hit;\n    vec3 sn;\n    int material;\n    int iterations;\n    float glow;\n};\n\ngeometry geoU(geometry g1, geometry g2) {\n    if (g1.dist < g2.dist) return g1;\n    return g2;\n}\n\ngeometry geoI(geometry g1, geometry g2) {\n    if (g1.dist > g2.dist) return g1;\n    return g2;\n}\n\nfloat opS2( float d1, float d2 )\n{\t\n    if (-d2 > d1) return -d2;\n    return d1;\n}\n\nvec3 opI2( vec3 d1, vec3 d2 ) {\n \tif (d1.x > d2.x) return d1;\n    return d2;\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fBox2Cheap(vec2 p, vec2 b) { return vmax(abs(p)-b); }\n\nfloat fCross(vec3 p, vec3 size) {\n    float obj = fBox(p, size);\n    obj = opU2(obj, fBox(p, size.zxy));\n    obj = opU2(obj, fBox(p, size.yzx));\n    return obj;\n}\n\n\nfloat fSphere(vec3 p, float r) { return length(p) - r; }\n\ngeometry DE(vec3 p)\n{\n \tfloat scale = 4.5;\n\tconst float offset = 14.;\n    const int FRACTALITERATIONS = 5;\n    vec3 modifier = vec3(4., 1.5, .4 );\n\n    for(int n=0; n< FRACTALITERATIONS; n++)\n\t{\n        \n\tp = abs(p);        \n        \n\t\tp.xy = (p.x - p.y < 0.0) ? p.yx : p.xy;\n\t\t//p.xz = (p.x - p.z < 0.0) ? p.zx : p.xz;\n\t\tp.zy = (p.y - p.z < 0.0) ? p.yz : p.zy;\n\n\n\t\tp.y -= 9.9;\n\n        p.y += 2.;\n        p.x -= 14.;\n        p.xy = scale* p.xy - offset*(scale-1.4) * modifier.xy;\n        \n\t}\n \tgeometry obj;\n    obj.dist = length(p.xz) * (pow(scale, -float(FRACTALITERATIONS))) - .5; \n\tobj.space = p;\n    return obj;\n}\nfloat smin( float a, float b, float k ){\n    \n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n    \n}\nfloat ring(vec3 p, float w, float h) {\n    return opS2(\n        fCylinder(p, w, h),\n        fCylinder(p, w - 2., h + 1.)\n        );\n}\ngeometry map(vec3 p) {\n    float t = pow(iTime * 0.1, 2.);\n    vec3 bbp = p;\n    p.xz /= 1. + vol * 0.4;\n    p += sin(vol * 4.+ t);\n    pR(p.zy, t * .4 + vol * .1);\n    \n    vec3 bp = p;\n    \n    vec3 h = vec2(0., pow(B(vec2(0, -iTime * 5.).xxy + p * .5) * 3., 4.)).yyy * 0.007;\n    \n    \n    \n    geometry obj, obj2;\n\n    //pR(p.xy, t * 2.);\n    obj.dist = ring(p, 20., 1.);\n\n    pModPolar(p.yx, 1. + ceil(t * .1 + vol));\n    //obj.dist = opU2(obj.dist, fBox(p, vec3(20., 1.0, 1.) ));\n    //obj.dist = opU2(obj.dist, fBox(p, vec3(1., 10., 20.)));\n    pR(p.xy, .3 + t);\n    obj.dist = opU2(obj.dist, ring(p, 22., 3.));\n    pR(p.zy, .4 + 3. * t);\n    obj.dist = opU2(obj.dist, ring(p, 24., 4.));\n    p = bp;\n    pR(p.zy, .5 + t * 2.4);\n    obj.dist = opU2(obj.dist, ring(p, 26., 5.));\n    \n    pR(p.zy, .5 + t * 2.4);\n    obj.dist = opU2(obj.dist, ring(p, 46., 10.));\n    \n\n    obj.material = 1;\n    obj.space = p;\n    \n    pR(bp.zx,  + B(vec3(t)) * 13.);\n    pModPolar(bp.zx, 3.);\n\n    pR(bp.zx, 2. * PI / 3. / 2.);\n    pModPolar(bp.xy, 5.);    \n    \n    \n    obj2.dist = fBox(bp, vec3(20., .1, .1) + h * 9.);\n    obj2.material = 2;\n    obj2.space = bp;\n    \n    obj.dist = opU2(obj.dist, fSphere(bp, 5.));\n\n    obj = geoU(obj, obj2);\n    \n    return obj;\n}\n\n\nfloat t_min = 0.1;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 80;\n\ngeometry trace(vec3 o, vec3 d) {\n    float omega = 1.3;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 0.003;\n    \n    geometry mp = map(o);\n    mp.glow = 0.;\n    \n    float functionSign = mp.dist < 0. ? -1. : +1.;\n    float minDist = 1e32;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n\n        mp = map(d * t + o);\n\t\t//mp.iterations = i;\n        //if (mp.material == 2) {\n\t\t\t//minDist = min(minDist, mp.dist * 3.); \n\t\t//\tmp.glow = pow( 1. / minDist, .5);\n        //}\n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength;\n   \t}\n    \n    mp.dist = candidate_t;\n    //if (mp.material != 2) mp.glow = 0.;\n    \n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INFINITY;\n    \n    \n    return mp;\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 8;\n    vec3 rd = (lp - ro);\n    float shade = .3;\n    float dist = 4.5;\n    float end = max(length(rd), 0.01);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).dist;\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.15), 1.0);\n}\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayOri,   // camera position\n               in vec3  rayDir, vec3 fc )  // camera to point vector\n{\n    float c = .5;\n    float b = .06;\n    \n    float fogAmount = c * exp(-rayOri.y*b) * (1.0-exp( -distance*rayDir.y*b ))/rayDir.y;\n    //vec3  fogColor  = vec3(1.,0.5, 0.);\n    return mix( rgb, fc, saturate(fogAmount) );\n}\n\nvec3 normal(vec3 pos) {\n    F eps=0.0001, d=map(pos).dist;\n\treturn normalize(vec3(map(pos+vec3(eps,0,0)).dist-d,map(pos+vec3(0,eps,0)).dist-d,map(pos+vec3(0,0,eps)).dist-d));\n}\n\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos).dist;\n    return clamp(sdist / dist, 0.0, 1.0);\n}\n\n\n\n\nvec3 getObjectColor(vec3 p, vec3 n, geometry obj) {\n    vec3 col = vec3(.0);\n\n    if (obj.material == 1) { \n        col = fromRGB(128,128,128) * 3. + pow(vol, 4.) * .2;\n            //boxmap(iChannel1, obj.space / 10., 1.).rgb;\n    }\n    \n    if (obj.material == 2) { \n        col = vec3(1.) * 3. - length(obj.space) * .2;// - B(obj.space* .1 - vec3(0., 0., t * 10.));\n        \n    };\n    \n    return col ;\n\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec3 sceneCol = vec3(0.0);\n    lp = sp + lp;\n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld / 4.), 0.1); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n\n    // Attenuating the light, based on distance.\n    float atten = 1. / (1.0 + lDist * 0.025 + lDist * lDist * 0.2);\n\n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 2.);\n    // Standard specualr term.\n    float spec = pow(max(dot(reflect(-ld, sn), rd), .7), 3.);\n\n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = getObjectColor(sp, sn, obj);\n\n    // Combining the above terms to produce the final scene color.\n    sceneCol += (objCol * (diff + .15) * spec * .2);// * atten;\n\n    // Return the color. Done once every pass... of which there are\n    // only two, in this particular instance.\n    \n    return sceneCol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    BEAT_COUNT = iTime /  60. * BMP / 8.;\n    BEATN = fract(BEAT_COUNT);\n    scene = mod(floor(BEAT_COUNT / 2.), 4.);\n    vec2 ouv = fragCoord.xy / iResolution.xy;\n        \n    vec2 uv = ouv - .5;\n\tfloat n = hash12(ceil(uv.yy * 8.));\n    vol = pow((texture(iChannel0, vec2(.42, .25)).r) * 2., 2.);\n    \n//uv.x += n * .02;\n    //uv *= tan(radians (FOV) / 2.0) * 1.1;\n    \n  //uv += hash12(uv / 20.) * 0.01;\n    float t2 = 140. - 35.;\n\tfloat t = iTime;   \n    float \n        sk = sin(-t * 3.2) * 24.0, \n        ck = cos(-t * 1.2) * 24.0,\n        \n        mat = 0.;\n     \n    light = vec3(0., 170., 150.);        \n    lightDir = light;\n    \n\n    \n    vec3 \n        vuv = vec3(0., 1., 0.), // up\n    \tro = vec3(10, 50, 0);// + vec3(iMouse.x / 20.,iMouse.y / 10. - 1., 10.); // pos\n\n    //scene = floor(scene + fract(ouv.y - BEATN) * 2.);\n    \n    /*if (scene == 0.) ro.y = 55.;\n    if (scene == 1.) ro.z = 528.;\n    if (scene == 2.) ro.z = 228.;\n    if (scene == 3.) {\n        ro.x = 34.; ro.z = 490.;\n    }\n    */\n   \n         \n    \n    vec3\n        vrp =  vec3(0., 0., 0.) , // lookat    */\n\t\t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro);        \n\t\n    vec3 sceneColor = vec3(0.), \n         fogCol = vec3(1., .3, 0.);\n    \n    vec3 oro = ro, ord = rd;\n    \n    geometry tr = trace(ro, rd);    \n    \n    tr.hit = ro + rd * tr.dist;\n\n    tr.sn = normal(tr.hit);\t\n    \n    float \n        sh = softShadow(tr.hit, tr.hit + light, 10.),\n    \tao = getAO(tr.hit, tr.sn, 1.),\n        a = 0.;\n    \n    vec3 sky = (\n        vec3(\n            pow(B(rd * 5. + t * .2) * 1., 3.) * 2. + .5 \n        //    + ceil(fract(-rd.x * 3. + rd.z * 4. - t * 2.1 ) - .5) * .04\n        ) * vec3(1., .5, .0)) * .5;\n    \n    if (tr.dist < FAR) { \n        \n        sceneColor = doColor(tr.hit, rd, tr.sn, light, tr);\n        sceneColor *= 1. + vec3(length(\n            max(\n                vec2(0.),\n                1. * max(\n                    0.,\n                    length(normalize(light.z) * max(0., tr.sn.z))\n                )\n            )\n        ));\n        if (tr.material == 1) sceneColor *= ao; \n        sceneColor *= sh;\n       \n        sceneColor = applyFog(sceneColor, tr.dist, oro, ord, fogCol);\n        a = tr.dist / FAR;\n    } else {\n\n    \tsceneColor = sky;\n    }\n\t//sceneColor += tr.glow;// * B(tr.space);\n    //a += (sceneColor.r + sceneColor.g + sceneColor.b) / 190.;\n    fragColor = vec4(clamp(sceneColor * (1.4 - length(uv) / 1.), 0.0, 1.0), a);\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.4));\n\n   // fragColor += scene;\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 30633,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/neurofunksocietyofpoland/effect-xara-clip?in=neurofunksocietyofpoland/sets/effect-existentialism-lp"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}