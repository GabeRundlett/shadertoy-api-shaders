{
    "Shader": {
        "info": {
            "date": "1471978511",
            "description": "remove line 13 of [Buff A] has #defines to switch layouts.\n(line 29 uses Key_F to fly) flying fails me. needs more spaceships and animals.\n\niq environment mergedwith paniq -movement.\nit is not a good merger according to camera controls and interface.",
            "flags": 49,
            "hasliked": 0,
            "id": "Mtc3WX",
            "likes": 60,
            "name": "WASD & ZQSD+F  Mountain movement",
            "published": 3,
            "tags": [
                "fbm",
                "camera",
                "snow",
                "mountain",
                "wasdmovement",
                "friction"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 4459
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//modified by ollj to merge it with was movement by benq\n\n#define SC (250.0)\n\nfloat chan0n(in vec2 i){return texture(iChannel0,i/256.0,-100.).x;}\nvec4 chan3(float x){return texture(iChannel3,vec2(x,.5)/iResolution.xy,-100.);}\n\n// value noise, and its analytical derivatives\nvec3 noised(in vec2 x){vec2 p=floor(x);vec2 f=fract(x);vec2 u=f*f*(3.-2.*f);\n float a=chan0n(p+vec2(.5));\n float b=chan0n(p+vec2(1.5,.5));\n float c=chan0n(p+vec2(.5,1.5));\n float d=chan0n(p+vec2(1.5,1.5));\n return vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n 6.0*f*(1.-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));}\nconst mat2 m2=mat2(.8,-.6,.6,.8);\n\nfloat detailH(in vec2 x){//return 0.;}\n return 50.0*texture(iChannel2, x*.03/SC,0.).x;}\n\nfloat detailM( in vec2 x ){//return 0.;}\n return 50.0*texture(iChannel2, x*.03/SC,0.).x;}\n\n#define pab {vec2 p=x*.003/SC;float a=0.;float b =1.;vec2 d = vec2(0.0);for(int i=0;i\n#define pal i++){vec3 n=noised(p);d+=n.yz;a+=b*n.x/(1.+dot(d,d));b*=.5;p=m2*p*2.;}return SC*100.*a\n#define pam pal-detailH(x);}\nfloat terrainH(in vec2 x)pab<15;pam \nfloat terrainM(in vec2 x)pab<9;pam\nfloat terrainL(in vec2 x)pab<7;pal;}\n\nfloat interesct(in vec3 o,in vec3 d,in float m,in float n){float t=m;\n for(int i=0;i<256;i++){\n  vec3 pos=o+t*d;\n  float h=pos.y-terrainM(pos.xz);\n  if(h<(.002*t)||t>n)break;\n  t+=.5*h;}return t;}\n\nfloat softShadow(in vec3 o, in vec3 d){float t=.001;\n float res=1.;\n for(int i=0;i<80;i++){\n  vec3 p=o+t*d;\n  float h=p.y-terrainM(p.xz);\n  res=min(res,16.*h/t);t+=h;\n  if(res<.001||p.y>(SC*200.))break;}\n return clamp(res,0.,1.);}\n\nvec3 calcNormal(in vec3 pos,float t){vec2 e=vec2(.002*t,0.);\n return normalize(vec3(terrainH(pos.xz-e.xy)-terrainH(pos.xz+e.xy),2.*e.x,\n                       terrainH(pos.xz-e.yx)-terrainH(pos.xz+e.yx)));}\n\nvec3 camPath(float time){return SC*1100.*vec3(cos(0.+0.23*time),0.,cos(1.5+.21*time));}\n\nfloat tc(vec2 p){return texture(iChannel0,p/256.).x;}\n#define tcp f+=tc(p);p=m2*p\nfloat fbm(vec2 p){\n float f=0.;\n tcp*2.02/2.;\n tcp*2.03/4.;\n tcp*2.01/8.;\n f+=tc(p)/16.;\n return f/0.9375;}\n\nmat3 setCamera(in vec3 t,in float r){vec3 c=normalize( cross(t,vec3(sin(r),cos(r),0.)));\n return mat3(c,normalize(cross(c,t)),t);}\n\nvec3 render(in vec3 ro, in vec3 rd){vec3 light1=normalize(vec3(-.8,.4,-.3));\n float tmin=1.;\n float tmax=1000.*SC;\n#if 1\n float maxh=300.*SC;\n float tp=(maxh-ro.y)/rd.y;\n if(tp>0.){\n  if(ro.y>maxh)tmin=max(tmin, tp);\n  else tmax=min(tmax,tp);}\n#endif\n float sundot=clamp(dot(rd,light1),0.,1.);\n vec3 col;\n float t=interesct(ro,rd,tmin,tmax);\n if(t>tmax){\t\n  col=vec3(0.3,.55,0.8)*(1.0-0.8*rd.y)*0.9;//sky\t\n  col +=.25*vec3(1.,.7,.4)*pow(sundot,5.);\n  col +=.25*vec3(1.,.8,.6)*pow(sundot,64.);\n  col +=.2 *vec3(1.,.8,.6)*pow(sundot,512.);//sun\n  vec2 sc=ro.xz+rd.xz*(SC*1000.-ro.y)/rd.y;\n  col=mix(col,vec3(1.,.95,1.),.5*smoothstep(.5,.8,fbm(.0005*sc/SC)) );//cloud\n  col=mix(col,vec3(.7,.75,.8),pow(1.-max(rd.y,0.),8.));// horizon\n  }else{\n   vec3 pos=ro+t*rd;\n   vec3 nor=calcNormal(pos,t);//mountain\n   //nor=normalize(nor+.5*(vec3(-1.,0.,-1.)+vec3(2.,1.,2.)*texture(iChannel1,.01*pos.xz).xyz));\n   vec3 ref=reflect(rd,nor);\n   float fre=clamp(1.+dot(rd,nor),0.,1.);   \n   float r=texture(iChannel0,(7./SC)*pos.xz/256.).x;\n   col=(r*.25+.75)*.9*mix(vec3(.08,.05,.03),vec3(.10,.09,.08),texture(iChannel0,.00007*vec2(pos.x,pos.y*48.0)/SC).x );\n   col=mix(col,.20*vec3(.45,.30,.15)*(.50+.50*r),smoothstep(.70,.9,nor.y));\n   col=mix(col,.15*vec3(.30,.30,.10)*(.25+.75*r),smoothstep(.95,1.,nor.y));//rock\n\n   float h=smoothstep(55.,80.,pos.y/SC+25.*fbm(.01*pos.xz/SC));\n   float e=smoothstep(1.-.5*h,1.-.1*h,nor.y);\n   float s=h*e*(.3+.7*smoothstep(.0,.1,nor.x+h*h));\n   col=mix(col,.29*vec3(.62,.65,.7),smoothstep(.1,.9,s));//snow\n\t\t\n   float amb=clamp(.5+.5*nor.y,0.,1.);\n   float dif=clamp(dot(light1,nor),0.,1.);\n   float bac=clamp(.2+.8*dot(normalize(vec3(-light1.x,0.,light1.z)),nor),0.,1.);\n   float sh=1.;\n   if(dif>=.0001 )sh=softShadow(pos+light1*20.,light1);//lighting\n\t\t\n   vec3 lin=vec3(0);float si=sh*sh;\n   lin+=dif*vec3(7.,5.,3.)*vec3(sh,si*.5+.5*sh,si*.8+.2*sh);\n   lin+=amb*vec3(.4,.6,.8)*1.2;\n   col*=lin+bac*vec3(.4,.5,.6);\n   col+=s*.1*pow(fre,4.)*vec3(7.,5.,3.)*sh*pow(clamp(dot(light1,ref),.0,1.),16.);\n   col+=s*.1*pow(fre,4.)*vec3(.4,.5,.6)*smoothstep(.0,.6,ref.y);\n   //float fo=1.-exp(-.000004*t*t/(SC*SC));// fog\n   float fo=1.-exp(-.001*t/SC);\n   vec3 fco=.7*vec3(.5,.7,.9)+.1*vec3(1.,.8,.5)*pow(sundot,4.);\n   col=mix(col,fco,fo);\n   col += 0.3*vec3(1.0,0.8,0.4)*pow( sundot, 8.0 )*(1.0-exp(-0.002*t/SC));//sun scatter\n  }col = pow(col,vec3(0.4545));// gamma\n return col;}\n\nmat2 rot2(float r){float c=cos(r),s=sin(r);return mat2(c,s,-s,c);}\n\nvoid mainVR(out vec4 r,in vec2 i,in vec3 o,in vec3 d){vec3 p=o;\n p=chan3(.5).xyz;;//camPath(20.);\n //problem here is that your looking direction has no effect on your movement direction.\n //as yor movement direction is set by looking directionvia mouse AND movement via key.\n //the [buffA ] is unaffected by [mainVR()] but it should be affected.\n p.y+=terrainM(p.xz)+2.;\n r=vec4(render(p,d),1.);} \n\nvoid mainImage(out vec4 r,in vec2 i){\n vec2 xy=-1.+2.*i.xy/iResolution.xy;\n vec2 s=xy*vec2(iResolution.x/iResolution.y,1.0);\n float time=iTime*.15+iMouse.x/iResolution.x;\n //vec3 ro=camPath(time);\n vec4 ro=chan3(.5);\n ro.xz*=10000.;\n //if(ro.w<0.)\n ro.y+=max(ro.y,terrainL(ro.xz)+1.5*SC);\n vec3 ta=chan3(1.5).xyz*6.28318530718;//camPath(time+3.);ta.y=ro.y-20.*SC;\n //problem is that [ta] stores an euler rotation in radians\n //and setCamera() function takes an axisangle.\n //mat3 cam=setCamera(normalize(ro-ray),0.);//this camera matrix function is pretty dub and too inefficient for this!\n //vec3 rd=cam*normalize(vec3(s.xy,2.));//ray direction\n    \n //while this one takes an euler rot:\n vec3 ray=normalize(vec3((i.xy-iResolution.xy*.5)/iResolution.x,1.));\n ray.zy=ray.zy*cos(ta.x)+sin(ta.x)*vec2(1,-1)*ray.yz;\n ray.xz=ray.xz*cos(ta.y)+sin(ta.y)*vec2(1,-1)*ray.zx;\n\n vec3 col=render(ro.xyz,ray);\n //col*=.5+.5*pow((xy.x+1.)*(xy.y+1.)*(xy.x-1.0)*(xy.y-1.0),.1);//vignette\t\n r.xyz=col;}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//WASD-Movement\n//Ben Quantock 2016\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//shortened&modified by ollj \n#define fl float\n#define ff const fl\nff minY=0.;//minimum height.\nff yMul=-1.;//negate to invert y-axis in controls\nff acc =.001;//acceleration \nff fri =.95;//friction\n\n//if both are disabled, it uses both (zq=wa)+sd+f+space\n//#define wasd\n//#define zqsd\n\n#define cf 256.;\n#define cfc cf ff\nff Key_left=37.5/cfc Key_up=38.5/cfc Key_right=39.5/cfc Key_down=40.5/cfc Key_Space=32.5/cfc \nKey_0=48.5/cfc Key_1=49.5/cfc Key_2=50.5/cfc Key_3=51.5/cfc Key_4=52.5/cfc Key_5=53.5/cfc Key_6=54.5/cfc Key_7=55.5/cfc Key_8=56.5/cfc Key_9=57.5/cfc \nKey_A=65.5/cfc Key_B=66.5/cfc Key_C=67.5/cfc Key_D=68.5/cfc Key_E=69.5/cfc Key_F=70.5/cfc Key_G=71.5/cfc Key_H=72.5/cfc Key_I=73.5/cfc Key_J=74.5/cfc Key_K=75.5/cfc Key_L=76.5/cfc Key_M=77.5/cfc Key_N=78.5/cfc Key_O=79.5/cfc Key_P=80.5/cfc Key_Q=81.5/cfc Key_R=82.5/cfc Key_S=83.5/cfc Key_T=84.5/cfc Key_U=85.5/cfc Key_V=86.5/cfc Key_W=87.5/cfc Key_X=88.5/cfc Key_Y=89.5/cfc Key_Z=90.5/cf\nfl rkInternal(fl k,fl t){return texture(iChannel3,vec2(k,t)).x;}\nfl rk      (fl k){return rkInternal(k,.25);}\nfl rkToggle(fl k){return rkInternal(k,.75);}\nvec4 chan0(fl x){return texture(iChannel0,vec2(x,.5)/iResolution.xy,-100.);}\n\nvoid mainImage(out vec4 r, in vec2 i){r=vec4(0.,0.,0.,1.);if(int(i.y)==0){\n if(int(i.x)==0){//x=0 stores CameraPosition.xyz; .w stores if the camera is flying: if(camPos.w>.0) is flying, no gravity|jumping\n  vec4 camPos=chan0(.5);\n  vec4 camVel=chan0(3.5);\n  r=camPos+camVel;\n  //if(camPos.y<.0)r.y=minY;//no flying below .y<minY\n  r.w=rkToggle(Key_F);\n }else if(int(i.x)<2){//x=1. stores [cameraRot=0] in radians; .w stores iMouse.z, if mouse was held down at the last frame.\n  vec4 b=chan0(2.5);vec4 o=chan0(1.5);\n  vec2 m=(iMouse.yx/iResolution.yx-.5)*vec2(.5*yMul,1.);\n  o.w=iMouse.z;bool p=o.w>.0;\n  if(p&&!(b.w >.0))b.xy-=m;if(p)o.xy=b.xy+m;else b=o;b.w=o.w;\n  r=(int(i.x)==1)?o:b;\n  //x=2. stores [BASE-cameraRot=b] in radians; the last [camRot=o] were the mouse was being held down.\n }else if(int(i.x)==3){//x=3. stores [cameraVel=v] for acceleration and friction.\n  vec4 p=chan0(.5);vec4 v=chan0(3.5);vec4 o=chan0(1.5)*6.28318530718;\n  bool fly=p.w>.0;\n  vec3 f=acc*vec3(0,0,1);vec3 l=f.zxx;\n  if(!fly){fl s=sin(o.x);fl c=cos(o.x);\n   f.zy=f.zy*c+s*vec2(1,-1)*f.yz;\n   l.zy=l.zy*c+s*vec2(1,-1)*l.yz;}\n  fl s=sin(o.y);fl c=cos(o.y);\n  f.xz=f.xz*c+s*vec2(1,-1)*f.zx;\n  l.xz=l.xz*c+s*vec2(1,-1)*l.zx;\n#ifdef wasd\n v.xyz+=(rk(Key_W)-rk(Key_S))*f;\n v.xyz+=(rk(Key_D)-rk(Key_A))*l;\n#elseif zqsd\n v.xyz+=(rk(Key_Z)-rk(Key_S))*f;\n v.xyz+=(rk(Key_D)-rk(Key_Q))*l;  \n#else \n v.xyz+=(max(rk(Key_W),rk(Key_Z))-rk(Key_S))*f;\n v.xyz+=(rk(Key_D)-max(rk(Key_A),rk(Key_Q)))*l; \n#endif\n v.xyz+=(rk(Key_up)-rk(Key_down))*f;\n v.xyz+=(rk(Key_right)-rk(Key_left))*l;\n v*=fri;\n  if(fly){v.y-=.01;\n   if(p.y<=.0)v.y=(rk(Key_Space)!=.0)?.3:minY;\n  }r=v;}}}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}