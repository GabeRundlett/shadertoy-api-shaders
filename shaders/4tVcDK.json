{
    "Shader": {
        "info": {
            "date": "1537807168",
            "description": "4, 9, 16, 25, 36 etc. separate code-blocks can run in separate panes.   Here I just vary the parameters, based on which tile we're in.   The basis is a great tutorial by Inigo Quilez (@iquilezles) at https://www.youtube.com/watch?v=0ifChJ0nJfM.",
            "flags": 0,
            "hasliked": 0,
            "id": "4tVcDK",
            "likes": 3,
            "name": "polypane",
            "published": 3,
            "tags": [
                "2d",
                "digitalart"
            ],
            "usePreview": 0,
            "username": "teraspora",
            "viewed": 1368
        },
        "renderpass": [
            {
                "code": "// Polypane a multi-pane shader - a fragment shader in OpenGL, built on shadertoy.com;\n// Author: John Lynch (teraspora);\n// Date: 24 SEP 2018.\n\nconst float HALF = 0.5;\nconst float PI = 3.141592654;\nconst float TWO_PI = 6.283185307;\n\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 cyan =       vec3(0.0,  1.,   0.84);\nconst vec3 magenta =    vec3(1.0,  0.,   1.0 );\nconst vec3 blue =       vec3(0.0,  0.6,  0.84);\nconst vec3 gold =       vec3(1.0,  0.84, 0.66);\nconst vec3 orange =     vec3(1.0,  0.2,  0.0 );\nconst vec3 yellow =     vec3(1.0,  0.8,  0.0 );\nconst vec3 dark_blue =  vec3(0.0,  0.05, 0.15);\nconst vec3 crimson =    vec3(0.76, 0.0,  0.42);\n    \nvec3[] cols = vec3[](magenta, cyan, crimson, blue, orange, yellow);\nint cl = cols.length();\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\n// MAIN METHOD:\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    \n    // Set this var to the number of tiles acroos and down:\n    float tileDim = 7.;\n    float numTiles = tileDim * tileDim;\n    \n    // some shorter names:\n    float fx = fragCoord.x;\n    float fy = fragCoord.y;\n    float resx = iResolution.x;\n    float resy = iResolution.y;\n    vec2 f = fragCoord.xy;\n    vec2 hr = iResolution.xy / tileDim;\n    \n    // MUTABLE VARIABLES\n    float scaleFactor = 1.0;\n    \n    // ===============================================================\n    // the output vector giving the position the program needs to know!-\n    vec2 pp = f;\n    // Make numTiles sub-frames:\n    vec2 n = vec2(float(int(f.x / resx * tileDim)), float(int(f.y / resy * tileDim)));\n    \n    float tile = numTiles -(n.y * tileDim + n.x) - 1.;\t// start at 1 so we don't lose stuff when multiplying\n    float toe = fract(tile / 2.) * 4. - 1.; // returns 1. if tile index odd, -1. if even;\n    float tile2 = tile * tile;\n    \n    // shift back to the first tile if in any other tile:\n    pp.x -= hr.x * n.x;\n    pp.y -= hr.y * n.y;\n    // normalise to [0, 1[, shift to make unit quad with origin in centre\n    vec2 q = pp / hr - 0.5;     // normalise\n    // then scale:\n    q /= scaleFactor;\n    \n    // some rotation and translation for a bit of variation!\n    if (fract((numTiles + 37.) / tile) == 0.0) q = rotate(q, 0.5 * PI);\n\tq *= 1.0 + sin(iTime / 20.) * tile / numTiles * toe;    \n    q = rotate(q, iTime / 10. * sin(tile) * toe);\n    \n    // control factors for changing colours\n    float cmi = float((int(iTime / 16.)));\n    int cm = int(mod(cmi + tile2 - 1., float(cl)));;\n    int cn = int(mod(float(cm) + 1., float(cl)));\n    \n    // Initial colour set:\n    vec3 col = mix(cols[cm], cols[cn], q.y);\n    \n    col.b = sin(iTime  / 6.);\n    \n    float freq = 10. + float(int(sqrt(tile))) + 10. * sin(iTime / 100.);\n    float rmin = 0.15;\n    float rinc = 0.06;\n    float k = 0.25 + 0.1 * sin(iTime) * sin(tile);\n    \n    // shift the tree:\n    q.x += 0.2 * sin(iTime / 2.) * toe;\n    q.x -= 0.2 * sin(iTime / 10.) * toe;\n    \n    float phi = sin(iTime / 2. + tile) * 0.2;\n    q = rotate(q, phi);    \n    // r has all the info to make fronds and splay them:\n    float r = rmin + k * cos(atan(q.y, q.x) * freq + 40. * q.x  + 1.4 * toe);\n    q = rotate(q, -phi);    \n    q = rotate(q, phi * toe * 2.);    \n      \n    // make trunk wavy:\n    float trunkAngle = 0.2 * toe * cos(iTime / 10.);\n    float trunkWaviness = tile;\n    float barkRoughness = 0.002;\n    float barkIndentation = 60.;\n    float baseSize = -.19;    \n       \n    // make arms:\n    col *= smoothstep(r, r + rinc, length(q));\n    // and a trunk:\n    r = 0.04 * tile / numTiles;\n    r += barkRoughness * cos(barkIndentation * q.y);\n    r += exp(baseSize * pp.y);\n    \n    col *= 1. - (1. - smoothstep(r, r+ 0.001, abs(q.x - trunkAngle * sin(trunkWaviness * q.y)))) \n              * (1. - smoothstep(0.0, 0.01, q.y));    \n    \n    // ===============================================================================\n\n    // Make a border: 8px solid black; with line inset:\n    float b = 6.;   // border width    \n    vec3 borderInsetLineColour = white;\n    \n    // Make a line inset:\n    if ((pp.x > b - 1. && pp.x <= b + 1.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = borderInsetLineColour;\n    if ((pp.y > b - 1. && pp.y <= b + 1.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = borderInsetLineColour;\n    \n    // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));\n    \n    // Black out a 'random' tile...\n    // if (int(mod(tile * 79., numTiles)) == int(mod(iTime * 2., numTiles))) col = black;\n    \n    \n    // and finally return the colour:\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}