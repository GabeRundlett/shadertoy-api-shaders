{
    "Shader": {
        "info": {
            "date": "1634315785",
            "description": "An implementation of the 3blue1brown video",
            "flags": 0,
            "hasliked": 0,
            "id": "NdtSDf",
            "likes": 1,
            "name": "newton raphson",
            "published": 3,
            "tags": [
                "3blue1brown"
            ],
            "usePreview": 0,
            "username": "kp1197",
            "viewed": 79
        },
        "renderpass": [
            {
                "code": "\n#define AA 1\n\n#define LOOP_TIME 10.\n\n// set programmatically at generaiton time\n#define JITTER_SALT 0.\n\nconst float EPS = 1e-12;\nconst float PI = 3.1415962;\nconst float e = 2.7182818284;\n\n\nconst float RATE_1 = 2. * PI / LOOP_TIME;\nconst float PHASE_1 = PI / 2.;\nconst float NUM_CELLS = 10.;\n\n\nmat2 noise2d_rotator = mat2(-0.8, 0.6, 0.6, 0.8);\n\n\n// { \"loop\": (\"-1.\", 0.10), \"blue\": (\"0.\", 0.23), \"red\": (\"1.\", 0.23), \"green\":(\"2.\", 0.22), \"teal\": (\"3.\", 0.22) }\n#define COLOR_MODE 3.\n\n// undocumented value: 0: none\n// { \"twist\": (\"1\", 0.33), \"fritz\": (\"2\", 0.33), \"pulsar\": (\"3\", 0.33) }\n#define ANIMATION_STYLE 2\n\n// { \"kalm\": (\"0.\", 0.80), \"jittery\": (\"1.\", 0.20) }\n#define JITTERY 0.\n\n\n\n// { \"clearview\": (\"-1\", 0.70), \"tiles\": (\"0\", 0.10), \"gems\": (\"1\", 0.10), \"cubist\": (\"3\", 0.10)}\n#define FRACTURE_STYLE 1\n\n#define SCANLINE 0.\n\n// { \"ghost\": (\"3\", 0.20), \"sharp\": (\"0\", 0.80) }\n#define TRAILS 0\n\n\n// { \"dragon\": (\"2.\", 0.25), \"tri\": (\"3.\", 0.25), \"quad\": (\"4.\", 0.25),  \"sept\": (\"6.\", 0.25) }\n#define LEADING_EXPONENT 2.\n\n// { \"stripeworld\": (\"-1.\", 0.50), \"spiralworld\": (\"1.\", 0.50) }\n#define LEADING_EXPONENT_SIGN 1.\n\n// { \"zoomout\": (\"-0.1\", 0.25), \"nakedeye\": (\"-1.\",0.75)}\n#define CONSTANT_REAL_TERM -1.0\n\n// { \"polar\": (\"1\",0.25), \"cartesian\": (\"0\",0.75) }\n#define POLAR 1\n\n// {  \"regularness\": (\"0\", 0.625), \"velvet\": (\"1\", 0.125), \"neons\": (\"2\", 0.125), \"fantasy\": (\"3\", 0.125) } \n#define SHADE_STYLE 3\n\n// { \"no\": (\"0\", 0.50), \"yes\": (\"1\", 0.50) }\n#define INVERT_COLORS 0\n\n// { \"yes\": (\"1\", 0.30), \"no\": (\"0\", 0.70) }\n#define FBM 1\n\n#define VIGNETTE 1.\n\n#define LEADING_TERM_COEF 5.\n\n#define CONSTANT_IMAG_TERM 0.\n\n#define LINEAR_TERM 0.0\n\n#define QUADRATIC_TERM 0.0\n\n#define SHAPES 10\n\n#define Gx 0\n\nconst int MAX_ITER = SHAPES;\n\nstruct Poly3 {\n\n    float A;\n    float expA;\n\n    float B;\n    float expB;\n\n    float C;\n    float expC;\n\n    float D;\n\n    float E;\n};\n\nstruct Z {\n    float real;\n    float imag;\n};\n\n\n\n\nPoly3 getPoly(float time) {\n\n    float bounce =  (ANIMATION_STYLE == 1) ? sin(RATE_1 * time) : 0.0;\n\n    //float constant_radius = CONSTANT_REAL_TERM + bounce;\n    //float constant_real = constant_radius*cos(time);\n    //float constant_imag = constant_radius*sin(time);\n\n    return Poly3(LEADING_TERM_COEF, LEADING_EXPONENT_SIGN * LEADING_EXPONENT, QUADRATIC_TERM, LEADING_EXPONENT_SIGN * 2., LINEAR_TERM, LEADING_EXPONENT_SIGN, CONSTANT_REAL_TERM + bounce, CONSTANT_IMAG_TERM);\n}\n\n\n\nfloat _exp(float x) {\n    return pow(e, x);\n}\n\n\nZ add(Z a, Z b, Z c, Z d, Z e, Z f) {\n    return Z(a.real + b.real + c.real + d.real + e.real + f.real, a.imag + b.imag + c.imag + d.imag + e.imag + f.imag);\n}\n\nZ add(Z a, Z b, Z c, Z d, Z e) {\n    return Z(a.real + b.real + c.real + d.real + e.real, a.imag + b.imag + c.imag + d.imag + e.imag);\n}\n\nZ add(Z a, Z b, Z c, Z d) {\n    return Z(a.real + b.real + c.real + d.real, a.imag + b.imag + c.imag + d.imag);\n}\n\nZ add(Z a, Z b, Z c) {\n    return Z(a.real + b.real + c.real, a.imag + b.imag + c.imag);\n}\n\nZ add(Z a, Z b) {\n    return Z(a.real + b.real, a.imag + b.imag);\n}\n\nZ power(Z a, float exponent) {\n    float r = pow(length(vec2(a.real, a.imag)), float(exponent));\n    float cis = float(exponent) * atan(a.imag, a.real);\n    return Z(r * cos(cis), r * sin(cis));  \n}\n\nZ conj(Z a) {\n    return Z(a.real, -a.imag);\n}\n\nZ mult(float x, Z z) {\n    return Z(x * z.real, x * z.imag);\n}\n\nZ mult(Z a, Z b) {\n    return Z(a.real * b.real - a.imag * b.imag, a.real * b.imag + a.imag * b.real);\n}\n\nZ div(Z a, Z b) {\n    \n    Z numerator = mult(a, conj(b));\n    float denom = mult(b,conj(b)).real;\n    denom = denom == 0. ? 1. : denom;\n    return mult(1./denom, numerator);\n}\n\nZ _ln(Z a) {\n    return Z(length(vec2(a.real, a.imag)),  atan(a.imag, a.real));\n}\n\nZ _exp(Z a) {\n    return mult(_exp(a.real), Z(cos(a.imag), sin(a.imag)) );\n}\n\nZ _cos(Z x) {\n    float a = x.real;\n    float b = x.imag;\n    return Z(cos(a) * cosh(b), -1. * sin(a) * sinh(b));\n}\n\nZ _sin(Z x) {\n    float a = x.real;\n    float b = x.imag;\n    return Z(sin(a) * cosh(b), -1. * cos(a)* sinh(b));\n}\n\nfloat _length(Z x) {\n    return length(vec2(x.real, x.imag));\n}\n\nfloat _length_squared(Z x) {\n    return x.real*x.real + x.imag*x.imag;\n}\n\n// Inner implementation - not to be called directly\nZ _fz(Z z, Poly3 poly) {\n    return add(mult(poly.A, power(z, poly.expA)), mult(poly.B, power(z, poly.expB)), mult(poly.C, power(z, poly.expC)), Z(poly.D,poly.E)); \n}\n\n// Inner implementation - not to be called directly\nZ _dfdx(Z z, Poly3 poly) {\n    Z t1 = mult(poly.expA*poly.A, power(z, poly.expA-1.));\n    Z t2 = mult(poly.expB*poly.B, power(z, poly.expB-1.));\n    Z t3 = mult(poly.expC*poly.C, power(z, poly.expC-1.));\n    return add(t1, t2, t3);\n}\n\n// F(z) = f(p(z)) = f(az^m-b)\nZ fz(Z z, Poly3 poly) {\n    Z a = _fz(z, poly);\n    #if Gx == 0\n        // identity\n        return a;\n    #elif Gx == 1\n        // sin\n        return _sin(a);\n    #elif Gx == 2\n        // exp\n        return _exp(a);\n    #elif Gx == 3\n        // (1+f(x))/f(x)\n        return div(add(Z(1.,0.), a), a);\n    #else\n        return 0.; // deliberate compiler error\n    #endif\n}\n\n// F'(z) = F'(p(z))*p'(z)\nZ dfdx(Z z, Poly3 poly) {\n    Z a = _dfdx(z, poly);\n    #if Gx == 0\n        // chain rule applied to identity function\n        return a;\n    #elif Gx == 1\n        // chain rule applied to sin\n        return mult(_cos(_fz(z, poly)), a);\n    #elif Gx == 2\n        // chain rule applied to exp\n        return mult(_exp(_fz(z, poly)), a);\n    #elif Gx == 3\n        // chain rule applied to (1+f(x))/f(x)\n        Z numerator = a;\n        Z denominator = power(_fz(z, poly), 2.); \n        return div(numerator,denominator);\n    #else\n        return 0.; // deliberate compiler error\n    #endif \n}\n\n// TODO: handle divide by zero without branches or additive smoothing\nZ next(Z z, Poly3 poly, Z multiplier) {\n    return add(z, mult(multiplier,div(fz(z, poly), dfdx(z, poly))));\n}\n\n\nZ _multiplier(float time) {\n\n    Z multiplier = Z(1.,1.);\n\n    if (ANIMATION_STYLE == 1) {\n        multiplier = Z(-1.+0.9*sin(RATE_1*time),-0.1+0.9*cos(RATE_1*time));\n    }\n    else if (ANIMATION_STYLE == 2) {\n        multiplier = div( Z(-1. + cos(RATE_1*time), 1. + sin(RATE_1*time) ), Z( 1. + sin(RATE_1*time) , -1. + cos(RATE_1*time) ) );\n        //return Z(2., -3. + cos(RATE_1*time));\n    }\n    else if (ANIMATION_STYLE == 3 && LEADING_EXPONENT_SIGN == 1.) {\n        multiplier = mult(Z(-0.1,-0.1), Z(sin(RATE_1*time), cos(RATE_1*time)));   \n    }   \n    else if (ANIMATION_STYLE == 3 && LEADING_EXPONENT_SIGN == -1.) {\n        multiplier = mult(Z(-0.1,-0.1), Z(sin(RATE_1*time), cos(RATE_1*time))); \n        multiplier = add(multiplier, Z(-2.,0.));\n    }\n    \n    return multiplier;\n}\n\nfloat HUE_SHIFT_FRAC(float time) {\n    if (COLOR_MODE == -1.) {\n        return floor(5.*(time / LOOP_TIME))/5.;\n    }\n    else if (COLOR_MODE == 0.) {\n        return 0.0;\n    }\n    else if (COLOR_MODE == 1.) {\n        return 0.24;\n    }\n    else if (COLOR_MODE == 2.) {\n        return 0.6;\n    }\n    else if (COLOR_MODE == 3.) {\n        return 0.85;\n    }\n    else {\n        return 0.0;\n    }\n}\n\n\n\n// from https://www.shadertoy.com/view/MsjXRt\n// todo: my own implementation\nvec3 HueShift (in vec3 Color, in float Shift)\n{\n    vec3 P = vec3(0.55735)*dot(vec3(0.55735),Color);\n    \n    vec3 U = Color-P;\n    \n    vec3 V = cross(vec3(0.55735),U);    \n\n    Color = U*cos(Shift*6.2832) + V*sin(Shift*6.2832) + P;\n    \n    return Color;\n}\n\n\nstruct Result {\n    int iterations;\n    Z zero;\n    float success;\n    float d;\n};\n\n\n\nResult newtown_raphson(Z z, Poly3 poly, Z multiplier) {\n    \n    if (POLAR == 1) {\n        z = div(Z(0.05,0.0),z);\n    }\n    \n    #if SHADE_STYLE == 3\n    float tot_d = 1.;\n    #else\n    float tot_d = 0.;\n    #endif\n\n    for (int i = 0; i < MAX_ITER; i++) {\n        float d = z.real*z.real + z.imag*z.imag;\n        \n        #if SHADE_STYLE == 1\n            tot_d = min(abs(atan(z.real,z.imag)), abs(atan(z.imag, z.real)));\n        #elif SHADE_STYLE ==2\n            //tot_d = max(tot_d, d);\n            tot_d = (z.real + z.imag) / 2.;\n        #elif SHADE_STYLE == 3\n            tot_d *= (((z.real / z.imag)));\n        #endif\n        \n        if (d < EPS) {\n            return Result(i, z, 1., tot_d);\n        }\n        z = next(z, poly, multiplier);           \n        \n    }\n    float d =  z.real*z.real + z.imag*z.imag;\n    \n    \n    return Result(MAX_ITER, z, 0., tot_d);\n}\n\n\nvec3 render(in vec2 fragCoord, float time ) {\n    // Normalized pixel coordinates (from 0 to 1)\n\n    // AA accumulation\n    vec3 tot = vec3(0.);\n\n    vec2 uv = fragCoord.xy/iResolution.xx;\n    \n    uv -= 0.5 * (iResolution.xy/iResolution.xx);\n\n    Z z = Z(uv.x, uv.y);\n    \n    Z a = _multiplier(time);\n    Result result = newtown_raphson(z, getPoly(time), a);\n    \n    vec3 root_color = 0.5*(1.+clamp(vec3(result.zero.real, result.zero.imag, 1.), -1., 1.));\n\n    #if SHADE_STYLE == 0\n        float shade = clamp(float(result.iterations) / float(SHAPES), 0., 1.);                \n    #elif SHADE_STYLE > 0\n        float shade = clamp(result.d, 0., 1.);\n    #else\n        float shade = vec2(0.); // DELIBERATE COMPILER ERROR\n    #endif\n\n    // Time varying pixel color\n    vec3 color = shade * shade * shade * root_color;\n\n    tot += (0.15*9.)*(HueShift(color, HUE_SHIFT_FRAC(time)));\n    \n    #if INVERT_COLORS == 1\n    tot = (1. - tot);\n    #endif\n\n    // Output to screen\n    return tot;\n}\n\n// from IQ @ https://www.shadertoy.com/view/XdXGW8\nvec2 grad2( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;                             \n}\n\nfloat noise2_octave(in vec2 p, float intensity) \n{\n     ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( intensity*grad2( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( intensity*grad2( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( intensity*grad2( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( intensity*grad2( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n// from IQ @ https://www.shadertoy.com/view/XdXGW8\nfloat noise2( in vec2 p, int octaves, float intensity )\n{\n    float f = 0.;\n    for (int i = 0; i < octaves; i++) {\n        float coef = pow(2., -float(i + 1));\n        f += coef*noise2_octave(p,intensity); \n        p = p*noise2d_rotator*2.01;\n    }\n    //f = 0.5 + 0.5*f;\n    return f;\n}\n\nfloat fbm2( in vec2 x, int octaves, in float H )\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<octaves; i++ )\n    {\n        t += a*noise2(f*x, 1, 1.);\n        f *= 2.01;\n        a *= G;\n    }\n    return t;\n}\n\n// https://iquilezles.org/articles/warp\nvec2 distort2(in vec2 u, int iters, float scale, float intensity, float time) {\n    vec2 p = vec2(u);\n    p = vec2(\n            fbm2(u+vec2(0.0,0.0),1,1.),\n            fbm2(u+vec2(5.2,1.3),1,1.));\n    for (int i = 0; i < iters-1; i++) \n    {\n        p = vec2(\n            fbm2(u + scale*p+vec2(1.7,9.2),1,1.),\n            fbm2(u + scale*p+vec2(8.3,2.8),1,1.));\n            \n        p += vec2(time);\n    }\n    return u+intensity*p;\n}\n\nvec2 getFBM(in vec2 uv, float time) {\n    float UV_SCALE = 4./iResolution.x;\n    float STRENGTH = (1./8.)*iResolution.x;\n    return STRENGTH*(distort2(vec2(UV_SCALE*uv + JITTER_SALT + time), 2, 1., 1., 0.) - vec2(UV_SCALE*uv + JITTER_SALT + time));\n}\n\nvec2 fbm(in vec2 fragCoord, float time) {\n    vec2 _fbm1 = getFBM(fragCoord, mod(time,LOOP_TIME));\n    vec2 _fbm2 = getFBM(fragCoord, mod(time,LOOP_TIME) - LOOP_TIME);\n    vec2 _fbm = mix(_fbm1, _fbm2, mod(time/LOOP_TIME,1.));\n    return _fbm + fragCoord;\n}\n\nvec2 getJitter(float time)\n{\n    return 0.3*(distort2(vec2(JITTER_SALT + time), 5, 1., 1., 0.) - vec2(JITTER_SALT + time)); \n}\n\n// this jitter implementatoin blends two jitters with 100% of A at t=0.0 and 100% of B at t=LOOP_TIME\n// The blends are offset by t = -LOOP_TIME, that way, you have seemless looping of length LOOP_TIME\nvec2 jitter(in vec2 fragCoord, float time) {\n    vec2 jitter1 = getJitter(mod(time,LOOP_TIME));\n    vec2 jitter2 =  getJitter(mod(time,LOOP_TIME) - LOOP_TIME);  \n    vec2 jitter = mix(jitter1, jitter2, mod(time/LOOP_TIME,1.));\n    return jitter;\n}\n\nvec2 random2f( vec2 p ) {\n    return fract(\n        sin(\n            vec2(\n                dot(p,vec2(127.1,311.7)),\n                dot(p,vec2(269.5,183.3)))\n        )*(43758.5453)\n    );\n}\n\n\nfloat veronoi_metric( in vec2 r, float exponent, float angle ) {\n    // manhattan\n    //return dot(abs(r), vec2(1.));\n    // euclidean\n    //return dot(r,r);\n    return dot(pow(abs(r),vec2(exponent)), 0.01+abs(vec2(cos(angle), sin(angle))));\n}\n\nstruct Voronoi {\n    vec3 col;\n    float res;\n    vec2 ij;\n};\n\nVoronoi voronoi_f1_colors( in vec2 x, float randomness, float power, float angle )\n{\n    vec2 p = floor( x );\n    vec2  f = fract( x );\n\n    float res = 8.0;\n    vec3 res_col = vec3(0.);\n    ivec2 ij = ivec2(0);\n    \n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 b = vec2( i, j );\n        vec2 point = random2f( vec2(p + b) );\n        vec2  r = vec2( b ) - f + randomness*point;\n        float d = veronoi_metric( r, power, angle);\n        vec3 col = vec3(point,1.);\n\n        ij = (d < res) ? ivec2(i,j) : ij;\n        res_col = (d < res) ? col : res_col;\n        res = min( res, d );\n        \n    }\n    \n    return Voronoi(res_col, res, vec2(ij));\n    //return vec4(res_col, sqrt( res ));\n}\n\n\n\nvec3 renderMainImage(in vec2 fragCoord, float time )\n{\n    vec2 oFragCoord = fragCoord;\n    \n    vec2 jitter_amt = 500.*jitter(fragCoord, time);\n    fragCoord += JITTERY * jitter_amt;  \n    \n    vec2 uv = fragCoord.xy / iResolution.xx;    \n    \n    Voronoi voronoi = Voronoi(vec3(0.),0.,vec2(0));\n    float voronoi_amt = 0.;\n    vec2 renderFragCoord = fragCoord;\n    if (FRACTURE_STYLE >= 0) {\n        voronoi = voronoi_f1_colors( NUM_CELLS*uv, float(FRACTURE_STYLE), 2. + 0.2*sin(RATE_1*time), PI/4. );\n        voronoi_amt =  sin(5. * RATE_1 * time / LOOP_TIME);\n        float a = mod(1.*(RATE_1 * time),2.*PI);\n        vec2 center = (floor(NUM_CELLS*uv) + voronoi.ij + vec2(0.5)) / NUM_CELLS;\n        mat2 spin = mat2(cos(a), -sin(a), sin(a), cos(a));\n        renderFragCoord = iResolution.xx*((spin * (uv - center)) + center);// + voronoi_amt * 50. * voronoi.xy;\n    }\n\n    #if FBM > 0\n    renderFragCoord = fbm(renderFragCoord, time);\n    #endif\n\n    vec3 color = render(renderFragCoord, time);\n    \n    if (FRACTURE_STYLE >= 0) {\n        color = mix(voronoi.col.xyz, color, 1.-voronoi_amt/4.);\n        color = color + voronoi_amt * 0.25 * dot(vec2(cos(RATE_1*time), sin(RATE_1*time)), (voronoi.col.xy));\n        color = mix(color, vec3(1.), voronoi.res);\n    }\n\n\n    if (VIGNETTE == 1.) {\n        float d= length(oFragCoord.xy / iResolution.xy - vec2(0.5));\n        float vignette = abs(1. - pow(d,1.));\n        color = vignette * color;\n    }\n    \n    //color = scanline_mask * mix(vec3(0.6,1.,0.6),color,0.1) + (1.-scanline_mask) * color;\n    \n    return color;\n}\n\nvec3 _mainImage(in vec2 fragCoord) {\n    vec3 color = renderMainImage(fragCoord, iTime);\n    \n    \n\n    \n    \n    if (TRAILS > 0) {\n        color = (1./float(1+TRAILS)) * color;\n    }\n    \n    for (int i = 1; i <= TRAILS; i++) {\n        vec3 trail = renderMainImage(fragCoord, iTime-0.35*(1./float(TRAILS))*float(i));\n        float coef = (1./float(1+TRAILS));//pow(2.,float(i));\n        color += coef * vec3(length(trail)/pow(3.,0.5));\n    }\n    \n    return color;\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA > 0\n    \n    float AA_scale = 0.5;\n    float coef = 0.;\n    float denom = 0.0;\n    float max_coef = float(1+2*AA);\n    \n    for (int i = -1*AA; i <= 1*AA; i++) {\n        for (int j = -1*AA; j <= 1*AA; j++) {\n            fragCoord += AA_scale * vec2(i,j);\n            coef = max_coef - float(i+j);\n            tot += coef * _mainImage(fragCoord);\n            denom += coef;\n        }\n    }\n    \n    tot /= denom;\n    \n    #else\n    \n    tot = _mainImage(fragCoord);\n    \n    #endif\n    \n\n    \n    fragColor = vec4(tot, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}