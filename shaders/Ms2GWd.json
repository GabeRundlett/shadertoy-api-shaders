{
    "Shader": {
        "info": {
            "date": "1395399997",
            "description": "Just wanted to play with deformation of the primitives (here: the tentacles).",
            "flags": 0,
            "hasliked": 0,
            "id": "Ms2GWd",
            "likes": 14,
            "name": "Mysterious Octopus",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "Nrx",
            "viewed": 1725
        },
        "renderpass": [
            {
                "code": "#define DELTA\t\t\t\t0.02\n#define RAY_LENGTH_MAX\t\t150.0\n#define RAY_STEP_MAX\t\t200\n#define AMBIENT\t\t\t\t0.3\n#define SPECULAR_POWER\t\t5.0\n#define SPECULAR_INTENSITY\t0.3\n#define FADE_POWER\t\t\t3.0\n#define GAMMA\t\t\t\t0.8\n#define M_PI\t\t\t\t3.1415926535897932384626433832795\n\n//#define ATAN2 // Comment this to use the original atan function\n#define SHADOW\n\nvec3 vRotateX (in vec3 p, in float angle) {\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn vec3 (p.x, c * p.y + s * p.z, c * p.z - s * p.y);\n}\n\nvec3 vRotateY (in vec3 p, in float angle) {\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn vec3 (c * p.x - s * p.z, p.y, c * p.z + s * p.x);\n}\n\nfloat fixDistance (in float d, in float correction, in float k) {\n\tcorrection = max (correction, 0.0);\n\tk = clamp (k, 0.0, 1.0);\n\treturn min (d, max ((d - DELTA) * k + DELTA, d - correction));\n}\n\nfloat smin (float a, float b, float k) {\n\n\t// From https://iquilezles.org/articles/smin\n\tfloat h = clamp (0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n\treturn mix (b, a, h) - k * h * (1.0 - h);\n}\n\n#ifndef ATAN2\n#define atan2 atan\n#else\nfloat atan2 (float y, float x) {\n\n\t// From http://www.deepdyve.com/lp/institute-of-electrical-and-electronics-engineers/full-quadrant-approximations-for-the-arctangent-function-tips-and-V6yJDoI0iF\n\tfloat t1 = abs (y);\n\tfloat t2 = abs (x);\n\tfloat t3 = min (t1, t2) / max (t1, t2);\n\tt3 = t3 / (1.0 + 0.28086 * t3 * t3);\n\tt3 = t1 > t2 ? M_PI / 2.0 - t3 : t3;\n\tt3 = x < 0.0 ? M_PI - t3 : t3;\n\tt3 = y < 0.0 ? -t3 : t3;\n\treturn t3;\n}\n\nfloat atan2_bis (float y, float x) {\n\n\t// From http://http.developer.nvidia.com/Cg/atan2.html\n\tfloat t1 = abs (y);\n\tfloat t2 = abs (x);\n\tfloat t3 = min (t1, t2) / max (t1, t2);\n\tfloat t4 = t3 * t3;\n\tfloat t5 = -0.013480470;\n\tt5 = t5 * t4 + 0.057477314;\n\tt5 = t5 * t4 - 0.121239071;\n\tt5 = t5 * t4 + 0.195635925;\n\tt5 = t5 * t4 - 0.332994597;\n\tt5 = t5 * t4 + 0.999995630;\n\tt3 = t5 * t3;\n\tt3 = t1 > t2 ? M_PI / 2.0 - t3 : t3;\n\tt3 = x < 0.0 ? M_PI - t3 : t3;\n\tt3 = y < 0.0 ? -t3 : t3;\n\treturn t3;\n}\n\nfloat atan2_ter (float y, float x) {\n\n\t// From http://rc0rc0.wordpress.com/2013/06/05/minimax-approximation-to-arctan-atan-atan2/\n\tfloat t1 = abs (y);\n\tfloat t2 = abs (x);\n\tfloat t3 = min (t1, t2) / max (t1, t2);\n\tt3 = 0.97239 * t3 - 0.19195 * t3 * t3 * t3;\n\tt3 = t1 > t2 ? M_PI / 2.0 - t3 : t3;\n\tt3 = x < 0.0 ? M_PI - t3 : t3;\n\tt3 = y < 0.0 ? -t3 : t3;\n\treturn t3;\n}\n#endif\n\nfloat getDistance (in vec3 p) {\n\tfloat k = 0.2 + 0.2 * sin (p.y * 2.0 + iTime * 3.0);\n\tvec3 pp = p;\n\tpp.z *= 1.2;\n\tfloat body = length (pp) + k - 4.5;\n\tbody = fixDistance (body, 2.0, 0.8);\n\n\tp.y += 1.0;\n\tfloat angle = 2.0 * M_PI / 8.0;\n\tpp = vRotateY (p, -angle * 0.5);\n\tangle *= floor (atan2 (pp.x, pp.z) / angle);\n\tp = vRotateY (p, angle);\n\tp.xy /= min (1.1, 40.0 / p.z);\n\tk = clamp (p.z - 5.0, 0.0, 0.5);\n\tp = vRotateX (p, p.z * (0.01 + 0.01 * sin (iTime * 0.5 + angle * 5.0)) + 0.1 * sin (p.z * 0.3 + iTime + angle * 3.0));\n\tp = vRotateY (p, 0.1 * sin (p.z * 0.2 + iTime * 2.0 + angle * 7.0));\n\tp.z = sin (p.z * 2.0) / 2.0;\n\tfloat tentacle = length (p) - 1.0 - k * sin (abs (p.x * p.y * p.y* p.y + p.z));\n\ttentacle = fixDistance (tentacle, 60.0, 0.15);\n\n\treturn smin (body, tentacle, 0.2);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Old monitor effect\n\tvec2 frag = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n\tfloat round = pow (length (frag * frag), 6.0);\n\tfrag.y *= 1.0 + round * 0.2;\n\tvec3 colorMonitor = vec3 (1.0 - round);\n\tcolorMonitor *= vec3 (0.8, 1.0 + abs (mod (frag.y, 0.04) / 0.04 - 0.5), 0.8);\n\n\t// Define the ray corresponding to this fragment\n\tfrag.x *= iResolution.x / iResolution.y;\n\tfrag.x += 0.01 * sin (frag.y * 40.0 + iTime);\n\tvec3 direction = normalize (vec3 (frag, 2.0));\n\n\t// Set the camera\n\tvec3 origin = vec3 ((50.0 * cos (iTime * 0.1)), -3.0 + 10.0 * sin (iTime * 0.2), -35.0 + 20.0 * sin (iTime * 0.3));\n\tvec3 forward = -origin;\n\tvec3 up = vec3 (0.0, 1.0, 0.0);\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tdirection = rotation * direction;\n\n\t// Ray marching\n\tvec3 p = origin;\n\tfloat dist = RAY_LENGTH_MAX;\n\tfloat rayLength = 0.0;\n\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\tdist = getDistance (p);\n\t\trayLength += dist;\n\t\tif (dist < DELTA || rayLength > RAY_LENGTH_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\tp = origin + direction * rayLength;\n\t}\n\n\t// Compute the background color\n\tvec3 lightDirection = normalize (vec3 (2.0, sin (iTime), -2.0));\n\tvec3 finalColor = vec3 (0.1, 0.2, 0.2 + 0.3 * max (0.0, dot (-direction, lightDirection)));\n\tif (dist < DELTA) {\n\n\t\t// Define the color of the octopus\n\t\tvec3 color = vec3 (0.3, 0.1, 0.2);\n\n\t\t// Initialize the lighting\n\t\tfloat fade = pow (1.0 - rayLength / RAY_LENGTH_MAX, FADE_POWER);\n\t\tfloat diffuse = 0.0;\n\t\tfloat specular = 0.0;\n\n\t\t#ifdef SHADOW\n\t\t// Ray march again to check whether the light is visible\n\t\tdist = RAY_LENGTH_MAX;\n\t\trayLength = DELTA * 10.0;;\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tvec3 pp = p + lightDirection * rayLength;\n\t\t\tdist = getDistance (pp);\n\t\t\trayLength += dist;\n\t\t\tif (dist < DELTA || rayLength > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (dist >= DELTA)\n\t\t#endif\n\t\t{\n\t\t\t// Get the normal\n\t\t\tvec2 h = vec2 (DELTA, 0.0);\n\t\t\tvec3 normal = normalize (vec3 (\n\t\t\t\tgetDistance (p + h.xyy) - getDistance (p - h.xyy),\n\t\t\t\tgetDistance (p + h.yxy) - getDistance (p - h.yxy),\n\t\t\t\tgetDistance (p + h.yyx) - getDistance (p - h.yyx)));\n\n\t\t\t// Lighting\n\t\t\tdiffuse = max (0.0, dot (normal, lightDirection));\n\t\t\tspecular = pow (max (0.0, dot (reflect (direction, normal), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t}\n\n\t\t// Compute the final color\n\t\tfinalColor = mix (finalColor, (AMBIENT + diffuse) * color + specular, fade);\n\t}\n\n\t// Set the fragment color\n\tfinalColor = pow (finalColor, vec3 (GAMMA));\n\tfragColor = vec4 (finalColor * colorMonitor, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}