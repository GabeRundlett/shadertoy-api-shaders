{
    "Shader": {
        "info": {
            "date": "1660609166",
            "description": "Temple Gateway - experiment with using 3 2D sdf's to make one 3D sdf",
            "flags": 0,
            "hasliked": 0,
            "id": "sttcWB",
            "likes": 28,
            "name": "Temple Gateway",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "temple"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 363
        },
        "renderpass": [
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n   \n    Temple Gateway\n    08/15/22 | byt3_m3chanic\n\n    @IY0YI posted a cool thing on the tweets\n    https://twitter.com/IY0YI/status/1558851205920858113\n\n    with a link to a shader from @fizzer\n    shadertoy.com/view/MsdBDj\n    \n    in which he used 3 2D SDF shapes to composite a 3D \n    SDF, so this is a version/inspired by that.\n    \n*/\n\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    .0001\n#define MAX_DIST    55.\n\nfloat hash21(vec2 a){ return fract(sin(dot(a, vec2(27.609, 57.583)))*43758.5453); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n//@iq https://iquilezles.org/articles/palettes\nvec3 hue(float t){ \n    vec3 d = vec3(0.110,0.584,0.949);\n    return .45+.4*cos( PI2*t*vec3(.95,.97,.88)*d ); \n}\n//@iq \nfloat box( vec3 p, vec3 b ) {\n    vec3 q = abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\nfloat box( vec2 p, vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.)) + min(max(d.x,d.y),0.);\n}\nfloat uncap( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\n// sides\nfloat sideX(vec3 p) {\n    p.x=abs(p.x);\n    float d = length(p.xy-vec2(0,.35))-.095;\n    d = min(d,length(p.xy-vec2(0,.17))-.045);\n    vec2 tp=p.xy-vec2(.7,-.3);\n    tp*=rot(.83);\n    float t = uncap(tp,.05,.05-.025,.85);\n    d=min(d,t);\n    \n    float c = box(p.xy+vec2(0,.0),vec2(.2,.05))-.04;\n    c=abs(c)-.02;\n    c = min(c,box(vec2(p.x,abs(p.y+.225)-.05),vec2(.15,.025)));\n    c = min(c,box(p.xy+vec2(0,.41 ),vec2(.3,.055)));\n    c = min(c,box(p.xy+vec2(0,.575),vec2(.3,.06)));\n    c = min(c,box(p.xy+vec2(0,1.2 ),vec2(.3,.52)));\n    c = min(c,box(p.xy+vec2(0,2.1 ),vec2(.3,.34)));\n    d=min(d,c);\n    \n    return d;\n}\n\nfloat sideZ(vec3 p) {\n    vec2 sc = vec2(1.5,1.5);\n    float d = box(p.xz,sc);\n    float ff = (p.y<-1.75 || p.y>-.66)?.2:.1;\n    if(p.y<-.5) d=length(vec2(abs(p.x)-(1.25-.4*cos(p.y*.5)),p.z))-ff;\n    return d;\n}\n\nfloat sideY(vec3 p) {\n    return box(p.xy,vec2(2.));\n}\n\n//global\nvec3 hp,hitPoint;\n\nvec2 map(vec3 p) {\n    p.y-=1.25;\n    vec2 r = vec2(1e5,0.);\n    p.z-=T*.65;\n    p.y-=.5*sin(p.z*.4);\n    \n    vec3 q = p;\n    p.z=mod(p.z+2.,4.)-2.;\n    vec3 w = p;\n    p.y-=-.1*cos(p.x*.5*PI);\n\n    float x = \n        max(sideZ(p.xyz),\n            max(sideY(p.xzy),sideX(p.zyx))\n        );\n\n    if(x<r.x) {\n        r = vec2(x,1.);\n        hitPoint=p;\n    }\n\n    float f = q.y+2.25;\n    if(f<r.x) {\n        r = vec2(f,2.);\n        hitPoint=q;\n    }\n    \n    w.x=abs(w.x)-2.25;\n    float v = box(w+vec3(0,2.3,0),vec3(.5,.1,2.));\n    if(v<r.x) {\n        r = vec2(v,3.);\n        hitPoint=w;\n    }\n    \n    return r;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, inout bool hit, int steps) {\n    hit = false; float d=0., m = 0.;\n    for(int i=0;i<steps;i++) {\n        p = ro + rd * d;\n        vec2 t = map(p);\n        if(abs(t.x)<d*MIN_DIST) hit = true;\n        d += i<32? t.x*.3:t.x*.7;\n        m  = t.y;\n        if(d>MAX_DIST) break;\n    } \n    return vec2(d,m);\n}\n\nvec3 FC = vec3(0);\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, int bnc, inout float d) {\n        \n    vec3 RC=vec3(0);\n    vec3 p = ro;\n    vec3 sp= p;\n    float m = 0., fA = 0., f = 0.;\n    bool hit = false;\n    \n    vec2 ray = marcher(ro,rd,p, hit, 200);\n    d = ray.x;\n    m = ray.y;\n    \n    hp = hitPoint;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(8.5,8,5.5);\n        vec3 l = normalize(lpos);\n\n        float diff = clamp(dot(n,l),0.,1.);\n\n        float shdw = marcher(p + n * .01 * 2., l, sp, hit, 128).x;\n        if(shdw < length(p -  lpos)) diff *= .65;\n\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 12.);\n        fresnel = mix(.0, .9, fresnel);\n\n        vec3 h = vec3(.5);\n           \n        if(m==1.) {\n            h=mix(vec3(1.,0,0),vec3(1,.4,.0),clamp(hp.y+1.*.5,0.,1.));\n            if(hp.y>-.65&&hp.y<-.5)h=vec3(.9);\n            h=mix(h,h*.1,clamp(n.x,0.,1.));\n            ref=vec3(h);\n        }\n        \n        if(m==2.) {\n            h=vec3(0.18);\n            ref=h*.15;hp.xz+=sin(hp.xz*4.);\n            vec2 ff = fract(hp.xz)-.5;\n            if(ff.x*ff.y>0.) {\n                h=vec3(0.1);\n            }\n            \n            ref=h;\n        }\n        \n        if(m==3.) {\n            h=vec3(.8);\n            ref=vec3(.4);\n        }\n        \n        RC = h*diff;\n        if(bnc<2) RC = mix(RC,FC, 1.-exp(-.001*d*d*d));\n        \n        ro = p+n*.0001;\n        vec3 rf = reflect(rd,n);\n        rd = mix(rd,rf,1.-fresnel);\n\n    } else {\n        RC = FC;\n    } \n\n    return RC;\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    // uv ro + rd\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    \n    vec3 C=vec3(0);\n    vec3 ro = vec3(0, 0, 10);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float ux = clamp((uv.y+.25)*1.5,0.,1.);\n    FC = mix(vec3(0.396,0.671,0.945),vec3(0.443,0.016,0.016),ux);\n    \n    if(uv.x>-.5&&uv.x<.5&&uv.y>-.5&&uv.y<.5){\n    // mouse //\n    float x = M.xy==vec2(0)? 0.: -(M.y/R.y*.125-.0625)*PI;\n    float y = M.xy==vec2(0)? 0.: -(M.x/R.x*.5-.25)*PI;\n\n    mat2 rx = rot(.18+x), ry = rot(.78+y);\n\n    ro.yz*=rx; ro.xz*=ry; \n    rd.yz*=rx; rd.xz*=ry;\n\n    vec3 RC=vec3(0), ref=vec3(0), fill=vec3(1);\n    vec3 p = ro;\n    float m = 0., d = 0., fA = 0., f = 0.;\n    bool hit = false;\n \n    int bnc = 2;\n    for(int i = 0; i < bnc + min(iFrame, 0); i++){\n        RC = render(ro,rd,ref,bnc-i,d);\n        C += RC*fill;\n        fill *= ref; \n        if(i==0)fA=d;\n    }\n    \n    C = mix(C,FC, 1.-exp(-.00035*fA*fA*fA));\n    C = mix(C,FC,smoothstep(0.,1.,f*0.015));\n \n    }\n    \n    // top decorations\n    float scl = R.x/15.;\n    float bg = (clamp(sin((uv.x - uv.y)*PI2*scl) + .8, 0., 1.)*.5 + .5);\n    float px = 2./R.x;\n    float f = length(uv)-.45;\n    float sd = length(uv+vec2(-.005,.01))-.45;\n    sd=smoothstep(.04+px,-px,sd);\n    float df=smoothstep(px,-px,abs(f)-.005);\n    f=smoothstep(-px,px,f);\n    C = mix(C,vec3(.50,0.,0.)*bg,f);\n    \n    // dots and lines setup\n    vec2 p = uv;\n    p *= rot(-T*.1);\n    vec2 q = p;\n    \n    float a = atan(p.y, p.x);\n    float dots = 100.;\n    float tabs = 12.;\n\n    float ia = floor(a/PI2*dots);\n    ia = (ia + .5)/dots*PI2;\n\n    float ix = floor(a/PI2*tabs);\n    ix = (ix + .5)/tabs*PI2;\n    \n    p *= rot(ia);\n    q *= rot(ix);\n\n    // lines\n    float ln = (q.y)-.001;\n    ln=smoothstep(px,-px,ln);\n    C=mix(C,vec3(.161,0.,0.),min(ln,f));\n    \n    C = mix(C,C*.1,min(sd,f));\n    C = mix(C,vec3(.890,.361,.008),df);\n    \n    // dots\n    p.x -= .45 + .05*sin(ia*6.);\n    float b = length(p)-(.0075+.005*sin(ia*3.-T*3.));\n    b=smoothstep(px,-px,b);\n    C=mix(C,vec3(.984,.596,.055),b);\n\n    \n    \n    \n    C = clamp(C,vec3(.01),vec3(1));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}