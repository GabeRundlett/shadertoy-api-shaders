{
    "Shader": {
        "info": {
            "date": "1697722490",
            "description": "Shader gallery to keep my favorites",
            "flags": 0,
            "hasliked": 0,
            "id": "ddtfWX",
            "likes": 6,
            "name": "Shader Gallery",
            "published": 3,
            "tags": [
                "shader",
                "gallery"
            ],
            "usePreview": 0,
            "username": "Peace",
            "viewed": 375
        },
        "renderpass": [
            {
                "code": "const float SMOOTHNESS = 0.5;\nconst vec3 BLOB_COL_BASE = vec3(1.0, 0.11, 0.8);\nconst vec3 BLOB_COL_GLOW = vec3(1.0, 0.9, 0.0);\nconst float ROWS = 6.0;\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k-abs(a-b), 0.0)/k;\n    return min(a, b) - h*h*k*(1.0/4.0);\n}\n\nfloat rand(int i, float lo, float hi) {\n    return (hi - lo) * 0.5 * (sin(float(997*i)) + 1.) + lo;\n}\n\nvec4 perm(vec4 x) { x = ((x * 34.0) + 1.0) * x; return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat noise(vec3 p)\n{\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * 0.02439024);\n    vec4 o2 = fract(k4 * 0.02439024);\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat rand1d(float n) { return fract(sin(n) * 43758.5453123); }\n\nfloat noise1d(float p) \n{\n\tfloat fl = floor(p);\n\tfloat fc = fract(p);\n\treturn mix(rand1d(fl), rand1d(fl + 1.0), fc);\n}\n\nfloat blob(vec2 uv, vec2 pos, float n, float radius, float period, int index) \n{ \n    float time = iTime * 0.3 + float(index) * 684.7291;\n    int i = int(time / period);\n    float t = mod(time, period) / period;\n    \n    pos.y = smoothstep(0., .4, t)*2.-1.;\n    pos.y = mix(pos.y, -1., smoothstep(.5, .8, t)) * (ROWS - 1.0);\n    \n    vec2 p = uv - pos + n;\n    return length(p) - radius;\n}\n\nfloat sdf(vec2 uv) \n{\n    float d = 9999999.;\n    float n = noise(vec3(uv, iTime * .2) * 0.7) * 0.7;\n    for (float i = -ROWS; i <= ROWS; i += 1.0) \n    {\n        float r = noise1d(i+iTime*0.2);\n        d = smin(d, blob(uv, vec2(i * iResolution.x / iResolution.y * 0.8, 0.0), n, (0.7 + r*2.) * 0.8, 8.0 + abs(rand1d(i)) * 8.0, int(i)), SMOOTHNESS);\n    }\n    return d;\n}\n\nfloat specular(vec3 light_dir, vec3 normal) {\n    light_dir = normalize(light_dir);\n    vec3 view_dir = vec3(0,0,-1);\n    vec3 halfway = normalize(light_dir + view_dir);\n    float s = max(0.0, dot(normal, halfway));\n    return s * s * s * s * s * s;\n}\n\nconst uint MAX_RAY_MARCH_STEPS = 32u;\nconst float MAX_DISTANCE = 1.0;\nconst float SURFACE_DISTANCE = 0.01;\nconst float HALF_PI = 1.57079632679;\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Camera\n{\n    Ray ray;\n    float fov;\n};\nCamera camera;\n\nstruct Hit\n{\n    float dist;\n    float min_dist;\n    vec3 point;\n    vec3 normal;\n};\n    \nfloat specularBlinnPhong(vec3 light_dir, vec3 ray_dir, vec3 normal)\n{\n    return max(0.0, dot(normal, normalize(light_dir + ray_dir)));\n}\n\nfloat fbm(vec3 p)\n{\n    return (noise(p * 1.4) + noise(p * 2.25 + 16.791) * 0.6 + noise(p * 3.375 - 31.613) * .35) * 0.6;\n}\n\nfloat SDF(vec3 point, float seed)\n{\n    return (dot(point, point) - 0.16 - fbm(vec3(point.xy, iTime * 0.25 + point.z) + seed) * 0.25) * 0.7;\n}\n\nHit raymarch(Ray ray, float seed)\n{\n    Hit hit;\n    hit.dist = 0.0;\n    hit.min_dist = MAX_DISTANCE;\n    hit.normal = vec3(0);\n    for (uint i = 0u; i < MAX_RAY_MARCH_STEPS; ++i)\n    {\n        hit.point = ray.pos + ray.dir * hit.dist; \n        float sdf = SDF(hit.point, seed);\n        hit.min_dist = min(hit.min_dist, sdf);\n        hit.dist += sdf;\n        if (hit.dist >= MAX_DISTANCE)\n            return hit;\n        if (abs(sdf) <= SURFACE_DISTANCE)\n        {\n            vec2 e = vec2(0.002, 0.0);\n            hit.normal = normalize(sdf - vec3(SDF(hit.point - e.xyy, seed), SDF(hit.point - e.yxy, seed), SDF(hit.point - e.yyx, seed)));\n            return hit;\n        }\n    }\n    \n    return hit;\n}\n\nvec4 getColor(Ray ray, vec3 color, float seed)\n{\n    vec3 col = vec3(0);\n    Hit hit = raymarch(ray, seed);\n    if (hit.normal != vec3(0))\n    {\n        vec3 n = abs(hit.normal + vec3(0, 0, 0.5));\n        col = normalize(color + n * n);\n        col += pow(specularBlinnPhong(normalize(vec3(100, 100, -100) - hit.point), normalize(camera.ray.pos - hit.point), hit.normal), 32.0) * 0.5;\n    }\n    else\n    {\n        col = vec3(pow(max(0.0, 1.0 - hit.min_dist), 16.0)) * color;\n        hit.dist = MAX_DISTANCE + 1.0 - max(0.0, 1.0 - hit.min_dist);\n    }\n    return vec4(col, hit.dist);\n}\n\nvec3 first(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;    \n    camera.fov = 90.0;\n    camera.ray.pos = vec3(0, 0, -1);\n    camera.ray.dir = vec3(0, 0, 1);\n    float fov = tan(HALF_PI - radians(camera.fov) * 0.5);\n    camera.ray.dir = normalize(vec3(uv, fov));\n    \n    vec4 c1 = getColor(camera.ray, vec3(1, 0.35, 1), 0.0);\n    vec4 c2 = getColor(camera.ray, vec3(0.1, 0.5, 1.0), 1000.612);\n    \n    if (c1.w > c2.w) { vec4 temp = c1; c1 = c2; c2 = temp; }\n    \n    if (c1.w >= MAX_DISTANCE)\n    {\n        fragColor = vec4(mix(c1.rgb, c2.rgb, 0.5), 1);\n        return fragColor.rgb;\n    }\n    \n    fragColor.rgb = c1.rgb;\n    if (c2.w < MAX_DISTANCE) fragColor.rgb = mix(fragColor.rgb, c2.rgb, 0.5);\n    fragColor.rgb = sqrt(fragColor.rgb * 1.1 - .1);\n    return fragColor.rgb;\n}\n\nvec3 second(out vec4 fragColor, in vec2 fragCoord)\n{\n    float min_res = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min_res * ROWS;\n    vec3 uvn = normalize(vec3(uv, 1.0));\n    \n    float d = sdf(uv); \n    vec2 e = vec2(8.0, 0);\n    float nx = (sdf(uv - e.xy) - sdf(uv + e.xy)) / (2.0 * e.x);\n    float ny = (sdf(uv - e.yx) - sdf(uv + e.yx)) / (2.0 * e.x);\n    vec3 n = normalize(vec3(nx, ny, -1.));\n    float m = smoothstep(0.0, 0.0 - fwidth(uv).y * 2., d);\n    float s = noise(vec3(uv, iTime * .5 + 630.737551) * 1.0) * 0.5;\n    float spec = max(0.0, uvn.y) * specular(vec3(uvn.x,-3.,0.0), n);\n    spec += min(1.0, 1.-uvn.y) * specular(vec3(uvn.x,3.,0.0), n);\n    spec = spec / (spec + 1.0) * 1.5;\n    vec3 col = spec * spec * (BLOB_COL_GLOW * 0.3 + 0.7) + mix(BLOB_COL_BASE, BLOB_COL_GLOW, spec);\n    col -= max(0.0, 1.- pow(abs(-d), 0.25)) * 0.7;\n    fragColor = vec4(col * m + BLOB_COL_BASE * (1.0 - m) / (6.0 + d), 1.0);\n    return fragColor.rgb;\n}\n\nconst float OPACITY = 0.2;\nconst vec3 HALO_COL = vec3(0.2, 0.6, 1.0);\nconst vec3 EDGE1_COL = vec3(1.0, 0.68, 0.66);\nconst vec3 EDGE2_COL = vec3(1.0, 0.3, 0.2);\nconst vec3 BACKGROUND_COL = vec3(0, 0, 0.11);\n\nvec2 rot(vec2 v, float a) \n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\nvec3 circle(vec2 uv, float off) \n{\n    vec3 col = HALO_COL;\n    float t = iTime * 0.5 + off;\n    float rt = t * 0.4;\n    float f = fwidth(uv).y * 4.0;\n    uv = rot(uv, 6.2831853 * (noise1d(rt - 6816.6) * 0.5 + noise1d(rt * 1.25 - 3743.16) * 0.4 + noise1d(rt * 1.5 + 1741.516) * 0.3));\n    float n = noise(vec3(uv * 1.2, t)) * 0.2 + noise(vec3(-uv * 1.7, t)) * 0.15 + noise(vec3(uv * 2.2, t)) * 0.1;\n    float d = dot(uv, uv);\n    float hd = d + n;\n    col = pow(vec3(hd), vec3(3.5, 3.5, 2.0)) * HALO_COL * smoothstep(1.0, 1.0 - f, hd);\n    float cd = d * hd * hd * smoothstep(1.0, 1.0 - f, hd) * 1.25;\n    col += cd * cd * mix(EDGE1_COL, EDGE2_COL, pow(hd, 8.0)) - (cd * cd * cd) * col;\n    col = mix(BACKGROUND_COL, col, smoothstep(1.0, 1.0 - f, hd));\n    return col;\n}\n\nvec3 third( out vec4 fragColor, in vec2 fragCoord )\n{\n    float min_res = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min_res * 1.1;\n    \n    vec3 col = mix(mix(mix(mix(\n    circle(uv, 0.0), \n    circle(uv, 1000.0), OPACITY), \n    circle(uv, 2000.0), OPACITY), \n    circle(uv, 3000.0), OPACITY), \n    circle(uv, 4000.0), OPACITY);\n    return col;\n}\n\n#define MAX_RAY_MARCH_STEPS 32\n#define MAX_DISTANCE 4.0\n#define SURFACE_DISTANCE 0.002\n\nstruct Hit2\n{\n    float dist;\n    float closest_dist;\n    vec3 p;\n};\n    \nfloat specularBlinnPhong2(vec3 light_dir, vec3 ray_dir, vec3 normal)\n{\n    vec3 halfway = normalize(light_dir + ray_dir);\n    return max(0.0, dot(normal, halfway));\n}\n\nfloat SDF(vec3 point)\n{\n    vec3 p = vec3(point.xy, iTime * 0.3 + point.z);\n    float n = (noise(p) + noise(p * 2.0) * 0.5 + noise(p * 4.0) * 0.25) * 0.57;\n    return length(point) - 0.35 - n * 0.3;\n}\n\nvec3 getNormal(vec3 point)\n{\n    vec2 e = vec2(0.002, 0.0);\n    return normalize(SDF(point) - vec3(SDF(point - e.xyy), SDF(point - e.yxy), SDF(point - e.yyx)));\n}\n\nHit2 raymarch(vec3 p, vec3 d)\n{\n    Hit2 hit;\n    hit.closest_dist = MAX_DISTANCE;\n    for (int i = 0; i < MAX_RAY_MARCH_STEPS; ++i)\n    {\n        float sdf = SDF(p);\n        p += d * sdf; \n        hit.closest_dist = min(hit.closest_dist, sdf);\n        hit.dist += sdf;\n        if (hit.dist >= MAX_DISTANCE || abs(sdf) <= SURFACE_DISTANCE)\n            break; \n    }\n    \n    hit.p = p;\n    return hit;\n}\n\nvec3 fourth(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    fragColor = vec4(0, 0, 0, 1);\n    if (dot(uv, uv) > 1.0) return fragColor.rgb;\n    vec3 pos = vec3(0, 0, -1);\n    vec3 dir = normalize(vec3(uv, 1));\n    \n    Hit2 hit = raymarch(pos, dir);\n    fragColor = vec4(pow(max(0.0, 1.0 - hit.closest_dist), 32.0) * (max(0.0, dot(uv, vec2(0.707))) * vec3(0.3, 0.65, 1.0) + max(0.0, dot(uv, vec2(-0.707))) * vec3(0.6, 0.35, 1.0) + vec3(0.4, 0.5, 1.0)), max(0.0, hit.closest_dist));\n    if (hit.closest_dist >= SURFACE_DISTANCE)\n        return fragColor.rgb;\n    vec3 normal = getNormal(hit.p);\n\n    vec3 ray_dir = normalize(pos - hit.p);\n    float facing = max(0.0, sqrt(dot(normal, vec3(0.707, 0.707, 0))) * 1.5 - dot(normal, -dir));\n    fragColor = mix(vec4(0), vec4(0.3, 0.65, 1.0, 1.0), 0.75 * facing * facing * facing);\n    \n    facing = max(0.0, sqrt(dot(normal, vec3(-0.707, -0.707, 0))) * 1.5 - dot(normal, -dir));\n    fragColor = vec4(fragColor.rgb, 0) + mix(vec4(0), vec4(0.6, 0.35, 1.0, 1.0), 0.75 * facing * facing * facing);\n    \n    facing = max(0.0, sqrt(dot(normal, vec3(0.0, 0.0, -1.0))) * 1.5 - dot(normal, -dir));\n    fragColor = vec4(fragColor.rgb, 0) + mix(vec4(0), vec4(0.4, 0.5, 1.0, 1.0), 0.5 * facing * facing * facing);\n    \n    fragColor = vec4(fragColor.rgb, 0) + mix(vec4(0), vec4(0.4, 0.625, 1.0, 1.0), pow(specularBlinnPhong(normalize(vec3(600, 800, -500) - hit.p), ray_dir, normal), 12.0) * 1.0);\n    fragColor = vec4(fragColor.rgb, 0) + mix(vec4(0), vec4(0.6, 0.5625, 1.0, 1.0), pow(specularBlinnPhong(normalize(vec3(-600, -800, -00) - hit.p), ray_dir, normal), 16.0) * 0.75);\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.25));\n    return fragColor.rgb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const float SMOOTH = 0.15;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 a = first(fragColor, fragCoord * 2.0 - vec2(iResolution.x, 0));\n    vec3 b = second(fragColor, fragCoord * 2.0);\n    vec3 m1 = mix(a, b, smoothstep(0.5 + SMOOTH, 0.5 - SMOOTH, uv.x));\n     \n    vec3 c = third(fragColor, fragCoord * 2.0 - vec2(0, iResolution.y));\n    vec3 d = fourth(fragColor, fragCoord * 2.0 - vec2(iResolution.x, iResolution.y));\n    vec3 m2 = mix(d, c, smoothstep(0.5 + SMOOTH, 0.5 - SMOOTH, uv.x));\n    \n    fragColor.rgb = mix(m2, m1, smoothstep(0.5 + SMOOTH, 0.5 - SMOOTH, uv.y));\n    fragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}