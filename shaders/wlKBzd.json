{
    "Shader": {
        "info": {
            "date": "1615200463",
            "description": "Experimenting with ray-tracing for a triangularized mesh. Improved accuracy of the results.",
            "flags": 0,
            "hasliked": 0,
            "id": "wlKBzd",
            "likes": 3,
            "name": "Triangularized Mesh Raytracer 2",
            "published": 3,
            "tags": [
                "test"
            ],
            "usePreview": 0,
            "username": "jstrom2002",
            "viewed": 287
        },
        "renderpass": [
            {
                "code": "mat4 RotateScaleTranslate( vec3 r, vec3 s, vec3 t )\n{\n    float a = sin(r.x); float b = cos(r.x); \n    float c = sin(r.y); float d = cos(r.y); \n    float e = sin(r.z); float f = cos(r.z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f*s.x,  d*e,          -c,      0.0,\n                 ac*f-b*e, ac*e+b*f*s.y, a*d,     0.0,\n                 bc*f+a*e, bc*e-a*f,     b*d*s.z, 0.0,\n                 t.x,      t.y,          t.z,     1.0 );\n}\nvec3 applyTransform(mat4 M, in vec3 v)\n{\n    vec4 v_ = vec4(v, 1.0);\n    v_ = M * v_;\n    return v_.xyz / v_.w;\n}\nvoid applyTransform(mat4 M, inout Triangle tri)\n{\n    tri.v0 = applyTransform(M,tri.v0);\n    tri.v1 = applyTransform(M,tri.v1);\n    tri.v2 = applyTransform(M,tri.v2);\n}\n\n// From iq's intersectors: https://iquilezles.org/articles/intersectors\nRayHit IntersectTriangle(in Ray ray, in Triangle tri) \n{\n    vec3 v1v0 = tri.v1 - tri.v0;\n    vec3 v2v0 = tri.v2 - tri.v0;\n    vec3 rov0 = ray.o - tri.v0;\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, ray.d );\n    float d = 1.0/dot( ray.d, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 ) \n        t = -1.0;//null return value    \n    return RayHit(t >= 0.0, ray.o + ray.d * t, t, vec3(u, v, 1.0-u-v), n);\n}\n\n// Specular GGX code from: https://www.shadertoy.com/view/4tXXzM\nfloat G1V(float NdotV, float k)\n{\n\treturn 1.0/(NdotV*(1.0-k)+k);\n}\nfloat SpecGGX(vec3 N, vec3 V, vec3 L, float roughness, float F0 )\n{\n\tfloat SqrRoughness = roughness*roughness;\n\n\tvec3 H = normalize(V+L);\n\n\tfloat NdotL = clamp(dot(N,L),0.0,1.0);\n\tfloat NdotV = clamp(dot(N,V),0.0,1.0);\n\tfloat NdotH = clamp(dot(N,H),0.0,1.0);\n\tfloat LdotH = clamp(dot(L,H),0.0,1.0);\n\n\t// Geom term\n\tfloat RoughnessPow4 = SqrRoughness*SqrRoughness;\n\tfloat denom = NdotH * NdotH *(RoughnessPow4-1.0) + 1.0;\n\tfloat D = RoughnessPow4/(PI * denom * denom);\n\n\t// Fresnel term \n\tfloat LdotH5 = 1.0-LdotH;\n    LdotH5 = LdotH5*LdotH5*LdotH5*LdotH5*LdotH5;\n\tfloat F = F0 + (1.0-F0)*(LdotH5);\n\n\t// Vis term \n\tfloat k = SqrRoughness/2.0;\n\tfloat Vis = G1V(NdotL,k)*G1V(NdotV,k);\n\n\tfloat specular = NdotL * D * F * Vis;\n    \n\treturn specular;\n}\n\nvec3 hitLighting(in vec3 N, in vec2 uv, in vec3 X)\n{\n        vec3 col = vec3(0.0);\n\n        if(DEBUG_NORMALS != 0)\n        {\n            return N;            \n        }\n\n        // Material properties.\n        vec3 ambient = vec3(0.2);\n        vec3 albedo = texture(iChannel1, uv).rgb;\n        vec3 specular = vec3(1.0);\n        float roughness = 0.9;\n        float metalness = 0.04;\n\n        // Calc values for lighting.\n        vec3 L = lightPosition - X;\n        vec3 V = cameraPosition - X;\n        float NdotL = max(dot(N,L), 0.0);\n        float NdotV = max(dot(N,V), 0.0);\n\n        // Lambertian diffuse model.\n        vec3 diffuse_val = lightIntensity[1] * albedo;\n        \n        // Cook-Torrance specular model.\n        float spec = SpecGGX(N,V,L,roughness,metalness);\n        vec3 specular_val = lightIntensity[2] * specular * spec;\n        \n        // Calculate light falloff.\n        float d = length(L);\n        float constant_falloff = lightFalloff[0];\n        float linear_falloff = lightFalloff[1] * d;\n        float quad_falloff = lightFalloff[2] * d * d;\n        float attenuation = 1.0 / (1.0 + constant_falloff + linear_falloff + quad_falloff);\n\n        col = ambient + \n            NdotL * lightColor * attenuation * (diffuse_val + specular_val);\n        \n        return col;\n}\n\nvec3 RaySceneIntersection(inout Ray ray, out bool anyHit)\n{\n    anyHit = false;\n    vec3 col = vec3(0.0);//output color.\n    float tMin = MAX_DISTANCE;\n    vec3 pos, N;\n    vec2 uv;\n    mat4 M = RotateScaleTranslate(modelRot, modelScale, modelPos);\n    for (int i=0; i < indices.length(); i += 3) \n    {\n        Triangle tri;\n        tri.v0 = vertices[indices[i + 0]];\n        tri.v1 = vertices[indices[i + 1]];\n        tri.v2 = vertices[indices[i + 2]];\n\n        applyTransform(M, tri);\n\n        RayHit info = IntersectTriangle(ray,tri);\n        if (info.hit && info.dist > 0.0 && info.dist < tMin) {\n            tMin = info.dist;\n            pos = info.pos;\n            anyHit = true;\n\n            vec3 na = normals[indices[i + 0]];\n            vec3 nb = normals[indices[i + 1]];\n            vec3 nc = normals[indices[i + 2]];\n\n            vec2 uva = uvs[indices[i + 0]];\n            vec2 uvb = uvs[indices[i + 1]];\n            vec2 uvc = uvs[indices[i + 2]];\n\n            //N = info.norm;// Use face normal from intersection calc.\n            N = (na * info.bary.x) + (nb * info.bary.y) + (nc * info.bary.z);// Use normal from mesh data.\n            uv = (uva * info.bary.x) + (uvb * info.bary.y) + (uvc * info.bary.z);                       \n        }\n    }\n\n    if (anyHit) {\n        N *= sign(dot(N, -ray.d));// Make normal is oriented torwards the camera\n        N = normalize(N);\n\n        col = hitLighting(N, uv, pos);\n    }\n    else\n    {//Shade skybox.\n        col = texture(iChannel0, ray.d).rgb;\n    }\n    \n    return col;\n}\n\nRay initRay(vec2 fragCoord)\n{\n    Ray ray;\n    \n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * PI;\n    vec2 st = (fragCoord - center) / iResolution.y;\n\n    ray.o = cameraPosition;\n    ray.d = normalize(st.x * cameraRight + st.y * cameraUp + cameraFront);\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ray.o.yz *= mat2(cp, -sp, sp, cp);\n    ray.o.xz *= mat2(cy, -sy, sy, cy);\n    ray.d.yz *= mat2(cp, -sp, sp, cp);\n    ray.d.xz *= mat2(cy, -sy, sy, cy);\n\n    return ray;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    // Rotate light.\n    float tha = 2.0*iTime / PI;\n    lightPosition += 5.0 * vec3(\n        cos(tha) * sin(tha),\n        sin(tha) * sin(tha),\n        sin(tha)\n    );\n    \n    // Rotate model.\n    if(ROTATE_MODEL != 0)\n    {\n        modelRot += 1.0 * vec3(\n            cos(tha) * sin(tha),\n            sin(tha) * sin(tha),\n            sin(tha)\n        );\n    }\n    \n    // Setup ray.\n    Ray ray = initRay(fragCoord);\n\n    // Trace ray against scene objects.\n    vec3 out_col = vec3(0.0);    \n    for(int bounce_number = 1; bounce_number < MAX_BOUNCES+1; ++bounce_number)\n    {\n        bool anyHit = false;\n        vec3 pass_color = RaySceneIntersection(ray,anyHit);\n        pass_color /= float(bounce_number);//taper off strength of light bounces.\n        out_col += pass_color;\n        if(!anyHit)\n            break;\n    }\n\n    fragColor = vec4(out_col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Global definitions\n#define DEBUG_NORMALS 0\n#define INTERSECT_EPSILON 0.00001\n#define MAX_BOUNCES 1\n#define MAX_DISTANCE 9999.9\n#define PI 3.1415926\n#define ROTATE_MODEL 0\n\n// Scene objects (models, cameras, lights, etc).\nvec3 cameraPosition = vec3(0.0, 0.0, 32.0);\nvec3 cameraFront = vec3(0,0,-1);\nvec3 cameraRight = vec3(1,0,0);\nvec3 cameraUp = vec3(0,1,0);\n\nvec3 lightPosition  = vec3(0.0, 0.0, 0.0);\nvec3 lightIntensity = vec3(5.0);\nvec3 lightFalloff = vec3(0.0, 0.0, 1.0);\nvec3 lightColor = vec3(1,1,0.92);\n\nvec3 modelPos   = vec3(0,0,0);\nvec3 modelScale = vec3(1.0);\nvec3 modelRot   = vec3(0,0,0);\n\n// Structs.\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\nstruct Triangle\n{\n    vec3 v0,  v1, v2;\n    vec3 n0,  n1, n2;\n    vec2 uv0,uv1,uv2;\n};\nstruct RayHit {\n    bool hit;\n    vec3 pos;\n    float dist;\n    vec3 bary;\n    vec3 norm;//triangle face normal just in case mesh data doesn't provide it.\n};\n\n// Triangularized Cornell box mesh data:\nconst int maxIndexValue = 20;\nvec3 vertices[maxIndexValue] = vec3[maxIndexValue](\nvec3(-10.0,10.0,10.0),//Top\nvec3(-10.0,10.0,-10.0),\nvec3(10.0,10.0,-10.0),\nvec3(10.0,10.0,10.0),\n\nvec3(-10.0,-10.0,-10.0),//Back\nvec3(10.0,-10.0,-10.0),\nvec3(10.0,10.0,-10.0),\nvec3(-10.0,10.0,-10.0),\n\nvec3(-10.0,-10.0,10.0),//Bottom\nvec3(10.0,-10.0,10.0),\nvec3(10.0,-10.0,-10.0),\nvec3(-10.0,-10.0,-10.0),\n\nvec3(-10.0,-10.0,10.0),//Left\nvec3(-10.0,-10.0,-10.0),\nvec3(-10.0,10.0,-10.0),\nvec3(-10.0,10.0,10.0),\n\nvec3(10.0,-10.0,-10.0),//Right\nvec3(10.0,-10.0,10.0),\nvec3(10.0,10.0,10.0),\nvec3(10.0,10.0,-10.0)\n);\n\nvec2 uvs[maxIndexValue] = vec2[maxIndexValue]\n(\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000)\n);\n\nvec3 normals[maxIndexValue] = vec3[maxIndexValue]\n(\nvec3( 0.0000,-1.0000, 0.0000),\nvec3( 0.0000,-1.0000, 0.0000),\nvec3( 0.0000,-1.0000, 0.0000),\nvec3( 0.0000,-1.0000, 0.0000),\n\nvec3( 0.0000, 0.0000, 1.0000),\nvec3( 0.0000, 0.0000, 1.0000),\nvec3( 0.0000, 0.0000, 1.0000),\nvec3( 0.0000, 0.0000, 1.0000),\n\nvec3( 0.0000, 1.0000, 0.0000),\nvec3( 0.0000, 1.0000, 0.0000),\nvec3( 0.0000, 1.0000, 0.0000),\nvec3( 0.0000, 1.0000, 0.0000),\n\nvec3( 1.0000, 0.0000, 0.0000),\nvec3( 1.0000, 0.0000, 0.0000),\nvec3( 1.0000, 0.0000, 0.0000),\nvec3( 1.0000, 0.0000, 0.0000),\n\nvec3(-1.0000, 0.0000, 0.0000),\nvec3(-1.0000, 0.0000, 0.0000),\nvec3(-1.0000, 0.0000, 0.0000),\nvec3(-1.0000, 0.0000, 0.0000)\n);\n\n// Mesh vertex data is aligned to use a single index for position/normal/uv vertex values.\nconst int numIndices = 30;\nint indices[numIndices] = int[numIndices]\n(\n0,1,2,//Ceiling\n0,2,3,\n\n4,5,6,//Back wall\n4,6,7,\n\n8,9,10,//Floor\n8,10,11,\n\n12,13,14,//Left wall\n12,14,15,\n\n16,17,18,//Right wall\n16,18,19\n);",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}