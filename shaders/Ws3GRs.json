{
    "Shader": {
        "info": {
            "date": "1569077427",
            "description": "Here's a cheap trick that I came up with to give the impression of random asymmetric rectangular tiling.",
            "flags": 0,
            "hasliked": 0,
            "id": "Ws3GRs",
            "likes": 67,
            "name": "Asymmetric Blocks",
            "published": 3,
            "tags": [
                "grid",
                "wall",
                "rectangle",
                "tiling",
                "block",
                "pack",
                "tessellation",
                "paving",
                "stochastic",
                "asymmetric"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 2607
        },
        "renderpass": [
            {
                "code": "/*\n\n\tAsymmetric Blocks\n\t-----------------\n\n    Here's a cheap trick that I came up with to give the impression of random\n    asymmetric rectangular tiling. The final implementation was a bit fiddly to \n    code, but I thought it fell into place nicely. However, it took me ages to \n\tdream up something that'd work. Producing random packed rectangles in realtime, \n\teven in pseudo form, isn't something you see much of, or at all, which surprises \n\tme, since it's a common thing to see in the world of architecture, and so forth.\n\n\tThere's a really cool way to use five edge Wang tiles, but it requires various \n\ttileset restrictions, which I don't think would be easy to replicate in one pass\n    on Shadertoy... or so I'd imagine. There are some pretty smart people on here,\n    so you never know. :) Either way, in the meantime, here's a less sophisticated \n    method that seems to work well enough. Well, it fools my eyes anyway. :)\n\n\tAs usual, I've dressed the pattern up a little, but the method itself is quite\n\tsmall and simple, so for anyone interested, the workings can be found in the\n    \"pattern\" function.\n\n\tBy the way, I wrote the algorithm in such a way that each brick returns a local\n\tposition and position-based ID which means it can be used to render picture\n\tmosaics, and more importantly, can be adapted for raymarching purposes. In fact, \n\tI have an example ready to go, which I'll put up when I've tidied it up a little.\n    \n\n    Similar Examples:\n\n    To my knowledge, there aren't any, but here's an unlisted box divide version. \n    Unlike all other versions, it maintains aspect correctness and returns tile IDs \n    based on position.\n\t\n    Box Divide ID - Shane.\n\thttps://www.shadertoy.com/view/WlsSRs\n\n*/\n\n// Simple overlays.\n//#define NAIVE_HATCH // I made this up a while back, and find it useful.\n//#define PAPER_GRAIN\n\n// Uncomment this to give it a cleaner look.\n//#define UNTEXTURED\n\n// Shadows almost always look better, but there are times when they might\n// overcook things a little. I think they enhance this example, but it's\n// all a matter of personal requirements. Turning them off gives it a \n// fresher, more naive, rendering style, which can sometimes be preferable.\n#define SHADOWS\n\n// Highlights -- Usually performed by taking a nearby sample, then adding a\n// variation on the difference.\n#define HIGHLIGHTS\n\n// Palettes: Not many, but I might add more.\n//#define GRAYSCALE\n\n// Wobbling the coordinates, just a touch, in order to give the blocks a subtle \n// hand cut appearance. Turning this off will result in cleaner straight lines.\n#define PERTURB_COORDINATES\n    \n// Display the square cell grid boundaries. It's there for debug purposes,\n// but has a certain aesthetic appeal.\n//#define SHOW_GRID\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n\n// Hacked together from IQ, Nimitz and Fabrice's hash functions.\nvec2 hash22(in vec2 f){\n     \n    uvec2 p = floatBitsToUint(f);\n    uint  n = 1103515245U*((p.x)^(p.y>>3U));\n    // Converting a uint to a uvec3:\n    // These numbers came from here:\n    // Quality hashes collection WebGL2 - Nimitz.\n    // https://www.shadertoy.com/view/Xt3cDn\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2((rz.xy >> 1) & uvec2(0x7fffffffU))/float(0x7fffffff)*2. - 1.;\n    \n    // Animated.\n    //f = vec2((rz.xy >> 1) & uvec2(0x7fffffffU))/float(0x7fffffff);\n    //return sin(p*6.2831853 + iTime); \n     \n}\n\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22(i), p);\n    v.y = dot(hash22(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22(i + 1.), p - 1.);\n\n#if 1\n    // Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    //return v.x + p.x*(v.y - v.x) + p.y*(v.z - v.x) + p.x*p.y*(v.x - v.y - v.z + v.w);\n}\n\n// A hatch-like algorithm, or a stipple... or some kind of textured pattern.\nfloat doHatch(vec2 p, float res){\n    \n    \n    // The pattern is physically based, so needs to factor in screen resolution.\n    p *= res/16.;\n\n    // Random looking diagonal hatch lines.\n    float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.); // Diagonal lines.\n\n    // Slight randomization of the diagonal lines, but the trick is to do it with\n    // tiny squares instead of pixels.\n    float hRnd = hash21(floor(p*6.) + .73);\n    if(hRnd>.66) hatch = hRnd;  \n\n\n    return hatch;\n\n    \n}\n\n// IQ's box function with a smoothing factor added.\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n    vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n}\n\n/*\n// IQ's standard box function.\nfloat sBox(in vec2 p, in vec2 b){\n   \n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n*/\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21B(vec2 f){\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return (float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU) - .5)*.75;\n}\n\n// The asymmetric block pattern.\n//\n// By the way, you could take a simple line-drawing and partitioning approach to greatly\n// minimize the instruction count, and if 2D bump mapping effects, etc, are all you're\n// after, it might be worth doing. However, if you wish to raymarch this, or do other\n// interesting things, the four rectangles, and corresponding IDs, are a necessary evil.\nvec3 pattern(vec2 p, float sc){\n\n    vec2 ip = floor(p*sc) + .5; // Grid ID.\n    p -= ip/sc; // Local coordinates.\n    \n    vec3 e = vec3(-1, 0, 1); // Helper vector.\n    \n    float h11 = hash21B(ip); // Original cell.\n    \n    float h10 = hash21B(ip + e.xy); // Left.\n    float h01 = hash21B(ip + e.yz); // Top.\n    float h12 = hash21B(ip + e.zy); // Right.\n    float h21 = hash21B(ip + e.yx); // Bottom.\n    \n    float h00 = hash21B(ip + e.xz); // Top left.\n    float h02 = hash21B(ip + e.zz); // Top right.\n    float h22 = hash21B(ip + e.zx); // Bottom right.\n    float h20 = hash21B(ip + e.xx); // Bottom left.\n      \n     \n    vec2[4] ctr;\n    vec2[4] l;\n    \n    \n    // The code looks fiddly, but it's based on a simple idea.\n    // A while ago, I noticed that if you ran vertical and \n    // horizontal lines on alternate checkered tiles, you could\n    // render perpendicular lines on either side at random\n    // positions and everything would line up to form rectangles.\n    // The following is just an implementation of that.\n    \n    // If you uncomment the SHOW_GRID define you'll see that \n    // each cell consists of either a vertical line flanked on\n    // either side by horizontal lines at random Y-positions, or \n    // a horizontal line flanked on either side by vertical\n    // lines at random X-positions.\n    \n    // Implementing the aforementioned is simple enough. However, \n    // lines are great, but cell boundaries -- in order to\n    // render things like blocks would be the thing we'd be more \n    // interested in rendering, so that requires a little more\n    // work.   \t\n    \n    \n    \n    if(mod((ip.x + ip.y), 2.)<.5){ // Horizontal cell.\n\n        // Partition the cell with a randomly positioned horizontal \n        // line and two joining randomly positioned vertical lines\n        // then determine the cell dimensions and cell center of\n        // all four resultant rectangular blocks.\n        \n        // Four block dimensions (X: Width, Y: Height).\n        l[0] = vec2(h01 - h10, h00 - h11) + 1.;\n        l[1] = vec2(-h01 + h12, h02 - h11) + 1.;\n        l[2] = vec2(-h21 + h12, -h22 + h11) + 1.;\n        l[3] = vec2(h21 - h10, -h20 + h11) + 1.;\n        \n        // Four block centers.\n        ctr[0] = vec2(h01, h11) + l[0]*vec2(-.5, .5);\n        ctr[1] = vec2(h01, h11) + l[1]*vec2(.5, .5);\n        ctr[2] = vec2(h21, h11) + l[2]*vec2(.5, -.5);\n        ctr[3] = vec2(h21, h11) + l[3]*vec2(-.5, -.5); \n\n    }\n    else { // Vertical cell.\n\n        // Partition the cell with a randomly positioned vertical \n        // line and two joining randomly positioned horizontal lines\n        // then determine the cell dimensions and cell center.\n        \n        // Four block dimensions (X: Width, Y: Height).\n        l[0] = vec2(-h00 + h11, h01 - h10) + 1.;\n        l[1] = vec2(h02 - h11, h01 - h12) + 1.;\n        l[2] = vec2(h22 - h11, -h21 + h12) + 1.;\n        l[3] = vec2(-h20 + h11, -h21 + h10) + 1.;\n        \n        // Four block centers.\n        ctr[0] = vec2(h11, h10) + l[0]*vec2(-.5, .5);\n        ctr[1] = vec2(h11, h12) + l[1]*vec2(.5, .5);\n        ctr[2] = vec2(h11, h12) + l[2]*vec2(.5, -.5);\n        ctr[3] = vec2(h11, h10) + l[3]*vec2(-.5, -.5); \n        \n\n    }\n                                                                             \n\n    // Debugging: Show the squares with a set single dimension.\n    //l[0] = l[1] = l[2] = l[3] = vec2(.7); // Overlapping: vec2(1.5); \n    \n    // Scaling down the block dimensions.\n    l[0] /= sc; l[1] /= sc; l[2] /= sc; l[3] /= sc;\n    \n    \n    \n    // Determine the minimum block using the standard method.\n    float d = 1e5;\n    vec2 tileID = vec2(0);\n    //vec2 ctri = vec2(0);\n    //vec2 li = vec2(0);\n     \n    for(int i = 0; i<4; i++){\n    \t \n    \tfloat bx = sBoxS(p - ctr[i]/sc, l[i]/2. - .05/sc, .1/sc);\n        \n        if(bx<d) {\n            d = bx;\n            tileID = ip + ctr[i];\n            //ctri = ctr[i];\n            //li = l[i];\n        }\n        \n    }\n    \n    \n    // Return the distance value of the closed rectangular block\n    // and it's cell center, which doubles as a unique ID. By the\n    // way, you could also return the the tile center and dimensions,\n    // if you wished to render other things.\n    return vec3(d, tileID);\n\n}\n\n\n\n// The square grid.\nfloat gridField(vec2 p){\n    \n    p = abs(fract(p) - .5);\n    float grid = abs(max(p.x, p.y) - .5) - .008;\n    \n    return grid;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n\n    // Aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 750.);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iRes;\n    \n    // Scaling and translation.\n    \n    // You could rotate also, if you felt like it: rot2(a)*uv...\n    // Depending on perspective; Moving the oject toward the bottom left, \n    // or the camera to the north east (top right) direction. \n    vec2 p = uv - vec2(-1, -.25)*iTime/12.;\n    \n    // Keeping a copy of the background vector.\n    vec2 oP = p;\n\n    // The smoothing factor -- based on scale.\n    float sf = 1.5/iResolution.y;\n  \n    #ifdef PERTURB_COORDINATES\n    // Wobbling the coordinates, just a touch, in order to give a subtle hand drawn appearance.\n    p += vec2(n2D3G(p*8.5), n2D3G(p*8.5 + 7.3))*.008;\n    #endif\n    \n    // The grid block scaling -- as opposed to the global scaling, which is set to \n    // one for this example.\n    const float sc = 12.;\n    \n    \n    \n    // Take two pattern samples.\n    vec3 d = pattern(p, sc);\n    vec2 e = vec2(.005*8./sc, -.007*8./sc);\n    vec3 d2 = pattern(p - e, sc);\n    \n \n    // Highlighting the objects.\n    float ba = mix(min(-d.x*4., .1), smoothstep(0., sf*2., -d.x), .1);\n    float bb = mix(min(-d2.x*4., .1), smoothstep(0., sf*2., -d2.x), .1);\n    float b = max(-bb - -ba, 0.)/length(e);\n\n\n    // Coloring each individual tile using the ID. It's scaled down by the scaling\n    // factor to bring the texture into view.\n    vec3 tx = texture(iChannel0, d.yz/sc).xyz; tx *= tx;\n    tx = smoothstep(-.1, .7, tx);\n    \n    // Mixing in a regular non-mosaic texture in with it.\n    vec3 tx2 = texture(iChannel1, oP).xyz; tx2 *= tx2;\n    tx2 = smoothstep(-.1, .6, tx2);\n    tx2 = mix(tx2, vec3(1)*dot(tx2, vec3(.299, .587, .114)), .25);\n    \n    \n    // Just a dark background. You only see this between the tiles. If I were \n    // putting in effort, I'd probably have to arrange for some mortar to put \n    // between the blocks.\n    vec3 col = vec3(.725, .7, .675)*tx2*tx2/3.;\n    \n    #ifdef UNTEXTURED\n    col = vec3(.1);\n    #endif\n\n    \n    // Apply the line shadows and the fist layer object shadows.\n    #ifdef SHADOWS\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d2.x - .003))*.9);\n    #endif\n    \n    \n    \n    #ifdef UNTEXTURED\n    // Using the ID for a shade.\n    vec2 rnd = hash22(d.yz);\n    vec3 lCol = vec3(1, .5 + rnd.y*.5, rnd.x*.4 + .4)*.75 + .15;\n    // Fabrice's candy colored palette.\n    //vec3 lCol = .6 + .3*cos(6.3*rnd.x + vec3(0, 23, 21));\n    #else\n    // Setting the block color to the texture at the specific ID position.\n    vec3 lCol = (tx2*2.)*tx*1.; \n    #endif\n    \n    \n    \n    \n    #ifdef HIGHLIGHTS\n    lCol *= (1. + b*.125);\n    #endif\n\n\n    // The Pattern.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*3., d.x - .002))*.9);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d.x - .002)));\n    col = mix(col, lCol, (1. - smoothstep(0., sf, d.x + .002)));  \n\n    \n    #ifdef SHOW_GRID\n    // The grid.\n    float grid = gridField(p*sc);\n  \n    vec3 svC = col;\n    // Display the grid boundaries. Usually used for debug purposes.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*1.5*sc, grid - .05))*.9);\n    col = mix(col, mix(svC.zyx*1.5, vec3(1, 1, 4), .5), (1. - smoothstep(0., sf*sc, grid)));\n    #endif\n    \n    \n    // POST PROCESSING\n    #ifdef GRAYSCALE\n    col = vec3(1)*dot(col, vec3(.289, .597, .114));\n    #endif\n\n    \n    #ifdef NAIVE_HATCH\n    float hatch = doHatch(oP, iRes);\n    col *= hatch*.5 + .7;\n    #endif\n    \n    #ifdef PAPER_GRAIN\n    // Cheap paper grain.\n    oP = floor(oP*1024.);\n    vec3 rn3 = vec3(hash21(oP), hash21(oP + 2.37), hash21(oP + 4.83));\n    col *= .9 + .1*rn3.xyz  + .1*rn3.xxx;\n    #endif\n\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= min(pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./8.)*1.1, 1.);\n    \n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}