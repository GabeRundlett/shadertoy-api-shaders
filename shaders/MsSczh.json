{
    "Shader": {
        "info": {
            "date": "1490815335",
            "description": "Two simple procedural shapes implementing Phisically Based Rendering",
            "flags": 0,
            "hasliked": 0,
            "id": "MsSczh",
            "likes": 6,
            "name": "Cook-Torrance + Oren-Nayar - PBR",
            "published": 3,
            "tags": [
                "procedural",
                "raymarching",
                "pbr",
                "cook",
                "torrance",
                "oren",
                "nayar"
            ],
            "usePreview": 0,
            "username": "Karambit",
            "viewed": 2000
        },
        "renderpass": [
            {
                "code": "\n\nfloat metallic = 1.0;\nfloat roughness = 0.1;\n\nconst float PI = 3.14159265359;\n\nfloat degToRad(float d) \n{\n    return d * PI / 180.0;\n}\n\nmat4 makeYRotation(in float angleInRadians) \n{\n  float c = cos(degToRad(angleInRadians));\n  float s = sin(degToRad(angleInRadians));\n  mat4 r;\n  r[0].xyzw = vec4(c, 0, -s, 0);\n  r[1].xyzw = vec4(0, 1, 0, 0);\n  r[2].xyzw = vec4(s, 0, c, 0);\n  r[3].xyzw = vec4(0, 0, 0, 1);\n\n  return r;\n}\n\nvec3 opTx( vec3 p, mat4 m )\n{\n    vec3 q = mat3(inverse(m))*p;\n    return q;\n}\n\nfloat sdSphere( vec3 p, float s)\n{\n\treturn length(p + vec3(0.0, 0.5, 0.0))-s;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p + vec3(0.0, 0.5, 0.0))-b,0.0))-r;\n}\n\nfloat smin( float a, float b )\n{\n\tfloat k = 0.1;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat map( in vec3 p)\n{\n\tfloat res = 0.0;\n\tfloat resSph = sdSphere(p, 3.0);\n\n\tvec3 q = opTx(p, makeYRotation(5.0 * iTime));\n\tfloat resCube = udRoundBox(q, vec3(2.0), 0.3);\n\n\tres = smin(resCube, resSph);\n    \n    vec2 M = ((iMouse.xy / iResolution.xy)*2.0-1.0)*6.0;\n    vec3 lp = vec3(M.x, M.y, 0.) - vec3(0., 0., -1.5);\n    \n    \n\tfloat sph = sdSphere(p-lp, 1.0);\n\n\treturn min(res, sph);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.002,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 10.0;\n\tfloat h          = 1.0;\n    float t          = 0.0;\n    for( int i=0; i<50; i++ )\n    {\n        if( h<0.001 || t>maxd ) break;\n\t    h = map( ro+rd*t);\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\t\n    return t;\n}\n\nfloat orenNayarDiffuse(\n  vec3 ld,\n  vec3 vd,\n  vec3 sn,\n  float r,\n  float a) {\n  \n  float LdotV = dot(ld, vd);\n  float NdotL = dot(ld, sn);\n  float NdotV = dot(sn, vd);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1., max(NdotL, NdotV), step(.0, s));\n\n  float sigma2 = r * r;\n  float A = 1. - .5 * (sigma2/((sigma2 + .33) + .000001));\n  float B = .45 * sigma2 / (sigma2 + .09) + .00001;\n    \n  float ga = dot(vd-sn*NdotV,sn-sn*NdotL);\n\n  return max(0., NdotL) * (A + B * max(0., ga) * sqrt((1.0-NdotV*NdotV)*(1.0-NdotL*NdotL)) / max(NdotL, NdotV));\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n  \n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n  \n    return nom / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n  \n    return nom / denom;\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n  \n    return ggx1 * ggx2;\n}\nvec3 F;\nvec3 kS;\nvec3 kD;\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}  \n\nvec3 lighting(in vec3 n, in vec3 lp, in vec3 p)\n{\n\n\n    vec3 ld = normalize(lp - p);\n    vec3 vd = normalize(vec3(0., 0., 5.) - p);\n\tfloat diff = orenNayarDiffuse(ld, vd, n, roughness, 1.0);\n\n\n\tvec3 F0 = vec3(0.04);\n    F0      = mix(F0, vec3(1.0), metallic);\n\n    F = fresnelSchlickRoughness(max(dot(n, vd), 0.0), F0, roughness);\n    kS = F;\n    kD = vec3(1.0) - kS;\n    kD *= 1.0 - metallic;\n\n\tvec3 H = normalize(vd + ld);\n        float distance = length(lp - p);\n        float attenuation = 1.0/pow(distance, 2.0);\n        vec3 radiance     = vec3(1.0) * attenuation;        \n        \n        /* Cook-Torrance BRDF*/\n        float NDF = DistributionGGX(n, H, clamp(roughness, 0.03, 1.0));        \n        float G   = GeometrySmith(n, vd, ld, roughness);      \n        \n        vec3 nominator    = NDF * G * F;\n        float denominator = (4.0 * max(dot(vd, n), 0.0) * max(dot(ld, n), 0.0)) + 0.001; \n        vec3 brdf = nominator / denominator;\n                       \n        vec3 Lo = (kD * vec3(1.0) / PI + brdf) * radiance * diff; \n   \n        \n\treturn vec3(diff) + Lo;\n}\n\nfloat saturate(in float n) {\n\treturn clamp(n, 0., 1.);\n}\n\nfloat sss(in vec3 L, in vec3 N, in vec3 V, in vec3 P){\n    \n\tint iLPower = 2;\n    float fLTScale = 5.;\n    float fLTThickness = 0.5;\n    float fLTAmbient = 0.0;\n    float fLightAttenuation = 2.0 * 1.0/pow(length(P - L), 2.0);\n\n    vec3 vLTLight = normalize(L + N * 0.3);\n    float fLTDot = pow(saturate(dot(V, -vLTLight)), float(iLPower)) * fLTScale; \n    float fLT = fLightAttenuation * (fLTDot + fLTAmbient) * fLTThickness;\n    \n    return fLT;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 q = uv * 2.0 - 1.0;\n\tq.x *= 16.0/9.0;\n\n\tvec3 ro = vec3(0.0, 0.0, 5.0 );\n    vec3 rd = normalize( vec3(q,-1.0) );\n\tvec3 col = vec3(0.0);\n    float t = intersect(ro,rd);\n    if( t>0.0 )\n    {\n    \tvec3 pos = ro+rd*t;\n        float d =  max(0.0, 5.0 - t)/2.0;\n        vec3 normal = calcNormal(pos);\n        vec2 M = ((iMouse.xy / iResolution.xy)*2.0-1.0)*6.0;\n        vec3 lp = vec3(M.x, M.y, 0.) - vec3(0., 0., -1);\n        vec3 L = pos - lp;\n        \n        vec3 light = vec3(lighting(normal, lp, pos));\n        \n        light += sss(L, normal, rd, pos) * vec3(0.7, 0.2, 0.1);\n        \n        col = light * vec3(0.2, 0.4, 0.9) + vec3(0.04);\n    }\n    \n    fragColor = vec4(col, 1.0 );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}