{
    "Shader": {
        "info": {
            "date": "1714781089",
            "description": "Wanted to try and ray-march both above and under the water.\nI'm not sure how to get rid of the black spot that appears when looking straight down at the water surface.\n\nUse the mouse to look around :)",
            "flags": 0,
            "hasliked": 0,
            "id": "lcGSz1",
            "likes": 3,
            "name": "Under water marcher",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "water"
            ],
            "usePreview": 0,
            "username": "ianertson",
            "viewed": 176
        },
        "renderpass": [
            {
                "code": "#define R iResolution\n#define T ((iTime-10.0)+39.37)\n\nmat2 rot(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nvec3 aces(vec3 x) { return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14),0.0,1.0); }\n\nvec3 hash3(vec3 ip) {\n    uvec3 p = floatBitsToUint(ip);\n    uvec3 k = ~p;\n    p ^= p >> 13U;\n    p ^= p << 5U;   \n    p ^= (p.xzy) << 15U;\n    p ^= (p.yxz) >> 12U;\n    p ^= (p.zyx) << 4U;\n    p ^= (k.yzx % 9U) << 3U;\n    uint n = 514295U *\n             ((p.x * p.y * p.z) +\n             ( p.z ^ p.x ^ p.y) +\n             ( p.x + p.y + p.z));\n    uint a = n & 0xFFU;\n    uint b = (n >> 8U) & 0xFFU;\n    uint c = (n >> 16U) & 0xFFU;\n    return vec3(a, b, c) / float(0xFFU);\n}\n\n\nvec3 noise3(vec3 p) {\n    vec3 id = floor(p);\n    vec3 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    \n    vec3 a = mix(\n        mix(hash3(id + vec3(0, 0, 0)), hash3(id + vec3(1, 0, 0)), lv.x),\n        mix(hash3(id + vec3(0, 1, 0)), hash3(id + vec3(1, 1, 0)), lv.x),\n        lv.y\n    );\n    \n    vec3 b = mix(\n        mix(hash3(id + vec3(0, 0, 1)), hash3(id + vec3(1, 0, 1)), lv.x),\n        mix(hash3(id + vec3(0, 1, 1)), hash3(id + vec3(1, 1, 1)), lv.x),\n        lv.y\n    );\n    \n    return mix(a, b, lv.z);\n}\n\nvec3 noise3(vec3 p, float freq, int oct, float tt) {\n    float amp = 1.0;\n    float div = 0.0;\n    vec3 n = vec3(0.0);\n    \n    vec3 t = vec3(sin(tt), cos(tt), cos(tt+0.3125));\n    p += t;\n    for (int i = min(iFrame, 0); i < oct; i++) {\n        n += amp*noise3(p*freq);\n        div += amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    \n    return exp((n/div)-1.0);\n}\n\nfloat getDist(vec3 p) {\n    float tt =  T*0.5;\n    vec3 h1 = noise3(p, 0.25, 1, tt);\n    vec3 h2 = noise3(p+30.39123123, 0.15, 6, tt+0.025);\n    vec3 h3 = abs(cross(h1*2.0-1.0, h2*2.0-1.0));\n    vec3 h4 = noise3((0.01*(p+31.4901823))+(h1+h2+h3), 0.75, 1, tt+1.23);\n    vec3 h = (h1+h2+h3)*0.33333333;\n    float d = max(p.y-1.6*(h1.y+h3.y+h2.y+h4.y), abs((h.x+h.y+h.z)*0.33333))-2.0*h4.z;\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc - 0.5 * R.xy) / R.y;\n    vec4 m = vec4((iMouse.xy - 0.5 * R.xy) / R.y, iMouse.zw);\n    vec3 rd = normalize(vec3(uv, 0.5));\n    vec3 ro = vec3(0, 1.0, -10.0);\n    \n    if (m.z > 0.001) {\n        ro.yz *= rot(m.y*6.28);\n        ro.xz *= rot(m.x*6.28);\n        rd.yz *= rot(m.y*6.28);\n        rd.xz *= rot(m.x*6.28);\n    } else {\n        float t = T*0.5;  \n        ro.y += (0.5+0.5*sin(T))*4.;\n        rd.yz *= rot(mix(-0.6, 0.1, 0.5+0.5*sin(T)));\n    }\n    \n    ro.y += 0.;\n    ro.z += T;\n    float d = 0.0;\n    \n    int st = 40;\n    float neg = 0.0;\n    for (int i = 0; i < st; i++) {\n        float r = float(i) / float(st);\n        float nn = neg * r * 0.5;\n        float k = (0.05*(r * (0.5 + nn)));\n        vec3 p = ro+rd*d*(1.0 + k);\n        float next = (getDist(p));\n        if (abs(next) >= float(st)) break;\n        d += abs(next);\n        neg += max(0.0, -next);\n    }\n    \n    neg = neg / float(st);\n    vec3 p = ro+rd*d;\n    \n    vec2 e = vec2(0.025, 0.0);\n    vec3 n = normalize(getDist(p) - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx)\n    ));\n\n    vec3 L = normalize(vec3(1, 2, -3));\n    float NdotL = max(0.05, dot(n, L));\n\n    \n    col += max(0.0, 1.0-(d / float(st)));\n    col *= vec3(0.25, 0.51, 0.75);\n  \n    col = mix(col, col*NdotL, (1.0-neg)*0.33333);\n    col = mix(col, col*col, 0.25*max(0.0, 1.0-2.0*neg));\n    col /= (1.0 + (neg*neg*3.));\n    col = max(vec3(0.0), col);\n    col = mix(col, vec3(0.1, 0.46, 0.69), max(0.0, dot(rd, vec3(0, 1, 0))));\n    float lum = luma(col);\n    col += (lum*lum);\n    col += (col*col);\n    col += vec3(0.2, 0.3, 0.5)*(col*col*luma(col*col));\n    \n    col = aces(col);\n    col = pow(col, vec3(1.0 / 2.2));\n    \n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}