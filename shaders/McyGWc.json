{
    "Shader": {
        "info": {
            "date": "1713373168",
            "description": "mouse xy for roughness / tile size\n\nNot really written for performance... (offline/precalc texture generation)\nBased on a 3D integer hash (hash3), and then just using integer modulo for tiling.\nCubic filtered. (can be turned off in common tab)",
            "flags": 0,
            "hasliked": 0,
            "id": "McyGWc",
            "likes": 1,
            "name": "Tiled FBM/NoiseClouds",
            "published": 3,
            "tags": [
                "noise",
                "tiled",
                "fbm"
            ],
            "usePreview": 0,
            "username": "teadrinker",
            "viewed": 199
        },
        "renderpass": [
            {
                "code": "float minv(vec2 x) { return min(x.x,x.y); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int startI = 8;\n    float roughness = 0.5;\n\n    // mouse control\n    if(iMouse.y > iResolution.y / 16.) {\n        roughness = iMouse.x/iResolution.x;\n        startI = 3 + int(7. * pow(iMouse.y/iResolution.y, 0.8));\n    }\n    \n    // fbm / noise clouds\n    uint startSize = 2u << uint(startI);\n    float gray = 0.0;\n    float blend = 1.0;\n    for(int i = startI; i > 0; i--)\n    {\n       uvec3 tile = uvec3(startSize>>i, startSize>>i, 1<<30);\n       vec2 scale = vec2(tile.xy) / float(startSize);\n       vec3 samplePos = vec3(fragCoord.x * scale.x, fragCoord.y * scale.y, float(i)*15.27 +  iTime);\n       float noise = TiledNoise3D(samplePos, tile);\n       gray = mix(gray, noise, blend);\n       blend *= roughness;\n    }\n    \n    // grid\n    gray *= min(1.0, 0.5*float(startSize)*minv(mod(fragCoord.xy - iMouse.xy,vec2(startSize))/float(startSize)));\n\n    fragColor = vec4(gray, gray, gray ,1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// https://nullprogram.com/blog/2018/07/31/\n// https://github.com/skeeto/hash-prospector/issues/19\nuint hash(uint x)\n{  \n#if 0\n    x ^= x >> 16;\n    x *= 0x21f0aaadU;\n    x ^= x >> 15;\n    x *= 0xd35a2d97U;\n    x ^= x >> 15;\n#elif 0\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n#else\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n#endif    \n    return x;\n}\n\n\n\n// by teadrinker, MIT / CC BY-NC-SA\n\n#define USE_CUBIC_FILTER true\n\nuint hash3(uvec3 p) { return hash(hash(hash(p.x)^p.y)^p.z); }\nfloat cubicint(float t, float m1, float p0, float p1, float p2) { return (p0+0.5*t*(p1-m1+t*(2.0*m1-5.0*p0+4.0*p1-p2+t*(p2-3.0*p1+3.0*p0-m1)))); }\nfloat smoothstepc(float x) { return x*x*(3.0-2.0*x); }\n\nfloat randTile(uvec3 p, uvec3 tileN) {\n   return float(hash3(p % tileN)) / 4294967295.0;\n}\n\nfloat noise1D(float x, uvec2 yz, uvec3 tileN) { \n   uint ix = uint(floor(x));\n   float fx = fract(x);\n   return USE_CUBIC_FILTER ?\n      cubicint(fx, randTile(uvec3(ix-1U, yz), tileN), \n                   randTile(uvec3(ix   , yz), tileN), \n                   randTile(uvec3(ix+1U, yz), tileN), \n                   randTile(uvec3(ix+2U, yz), tileN)) :\n      mix(randTile(uvec3(ix, yz), tileN), randTile(uvec3(ix+1U, yz), tileN), smoothstepc(fx));\n}\n\nfloat noise2D(vec2 p, uint z, uvec3 tileN) { \n   uint ix = uint(floor(p.y));\n   float fx = fract(p.y);   \n   return USE_CUBIC_FILTER ?\n      cubicint(fx, noise1D(p.x, uvec2(ix-1U, z), tileN), \n                   noise1D(p.x, uvec2(ix   , z), tileN), \n                   noise1D(p.x, uvec2(ix+1U, z), tileN), \n                   noise1D(p.x, uvec2(ix+2U, z), tileN)) :\n      mix(noise1D(p.x, uvec2(ix, z), tileN), noise1D(p.x, uvec2(ix+1U, z), tileN), smoothstepc(fx));\n}\n\nfloat TiledNoise3D(vec3 p, uvec3 tileN) { \n   uint ix = uint(floor(p.z));\n   float fx = fract(p.z);   \n   return USE_CUBIC_FILTER ?\n      cubicint(fx, noise2D(p.xy, ix-1U, tileN), \n                   noise2D(p.xy, ix   , tileN), \n                   noise2D(p.xy, ix+1U, tileN), \n                   noise2D(p.xy, ix+2U, tileN)) :\n      mix(noise2D(p.xy, ix, tileN), noise2D(p.xy, ix+1U, tileN), smoothstepc(fx));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}