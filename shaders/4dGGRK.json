{
    "Shader": {
        "info": {
            "date": "1455243572",
            "description": "Just some funny swirling voxel tori",
            "flags": 0,
            "hasliked": 0,
            "id": "4dGGRK",
            "likes": 10,
            "name": "drl0010 (Generator)",
            "published": 3,
            "tags": [
                "voxel",
                "dithering"
            ],
            "usePreview": 0,
            "username": "DrLuke",
            "viewed": 1291
        },
        "renderpass": [
            {
                "code": "/*\n\tThanks to fb39ca4 for this shader: https://www.shadertoy.com/view/4dX3zl\n\n\tI've copied it and then plugged in my own distance functions in getVoxel.\n\n\tAdditionally I've added a basic lighting system. I've commented my changes.\n*/\n\n/*\t------------------------- SETTINGS ------------------------- */\n// Dither the entire screen for a fun effect\n//#define DITHERING\n// Whether you want \n//#define CAMERAROTATING\n\n\n\n/*\t------------------------ /SETTINGS/ ------------------------ */\n\n\n\n\n// function to generate a rotation matrix. Very handy!\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n//The raycasting code is somewhat based around a 2D raycasting toutorial found here: \n//http://lodev.org/cgtutor/raycasting.html\n\nconst int MAX_RAY_STEPS = 170;\n\n\n// For different distance functions, look here: https://www.shadertoy.com/view/Xds3zN\nfloat sdSphere(vec3 p, float d) { return length(p) - d; } \n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// this function returns true if there's a bool in the provided grid position.\nbool getVoxel(ivec3 c, mat3 rotMat1, mat3 rotMat2) \n{\n\tvec3 p = vec3(c) + vec3(0.5);\n    // Generate 2 rotation matrices for the \n\tfloat d = min(min(sdTorus(rotMat1*vec3(c), vec2(10,3)),sdTorus(rotMat2*vec3(c), vec2(25,4))), -sdSphere(p, 50.0));\n    \n    #define CAPSULEDIST (0.0 + abs(sin(iTime))*13.0)\n    d = min(d, sdCapsule(rotMat1*vec3(c), vec3(0,CAPSULEDIST,0), vec3(0,-CAPSULEDIST,0), 4.0));\n\treturn d < 0.0;\n}\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\n#ifdef DITHERING\nfloat dither(vec2 position, float brightness) {\n\tfloat bayer = texture(iChannel0, position).r;\n    return step(bayer, brightness-0.1);\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((fragCoord.xy * 2.0) / iResolution.xy) - vec2(1);\t// Make UV go from -1 to 1 instead of 0 to 1\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 s = vec3(sin(iTime*0.1)*45.0,sin(iTime*0.4)*15.0,cos(iTime*0.1)*45.0);\n    #define FOCALLEN 0.6\n    vec3 d = vec3(uv*FOCALLEN, 1.0);\n    mat3 rotMat = rotationMatrix(vec3(0,1,sin(iTime*3.14159*0.1)*-0.3), -iTime*0.1 + 3.14159) * rotationMatrix(vec3(1,0,0), -0.4*sin(iTime*0.4) - 0.0);\n    d = rotMat * d;\n    \n\tvec3 rayDir = d;\n\tvec3 rayPos = s;\n\t\n\t\n\tivec3 mapPos = ivec3(floor(rayPos + 0.));\n\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n\t\n\tivec3 rayStep = ivec3(sign(rayDir));\n\n\tvec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\t\n\tbvec3 mask;\n    mat3 rotMat1 = rotationMatrix(vec3(1,1,0), iTime*0.3);\n    mat3 rotMat2 = rotationMatrix(vec3(1,1,0), iTime*0.2);\n\t\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) \n    {\n\t\t//if (getVoxel(mapPos)) continue;\n\t\tbvec3 b1 = lessThan(sideDist.xyz, sideDist.yzx);\n\t\tbvec3 b2 = lessThanEqual(sideDist.xyz, sideDist.zxy);\n\t\tmask.x = b1.x && b2.x;\n\t\tmask.y = b1.y && b2.y;\n\t\tmask.z = b1.z && b2.z;\n\t\t//Would've done mask = b1 && b2 but the compiler is making me do it component wise.\n\t\t\n\t\t//All components of mask are false except for the corresponding largest component\n\t\t//of sideDist, which is the axis along which the ray should be incremented.\t\t\t\n\t\t\n        if(getVoxel(mapPos, rotMat1, rotMat2)) break;\n\t\tsideDist += vec3(mask) * deltaDist;\n\t\tmapPos += ivec3(mask) * rayStep;\n\t}\n\n    /*\n\t\tBasic lighting\n\t\tI calculate the distance from the current voxel center (mapPos) to a given light.\n\t*/\n    \n    fragColor = vec4(0,0,0,1);\t// Thanks otaviogood\n    \n    #define POW2(a) (a*a)\n    \n    #define CENTERCOLOR (vec3(0,0.4,0.8) * clamp(cos(-iTime*2.0)*1.4-0.4, -0.1, 1.) )\n    fragColor.rgb += ( 1.0/POW2(distance(vec3(0,0,0), rotMat*vec3(mapPos))) ) * 100.0 * CENTERCOLOR;\n    \n    #define MEDROTCOLOR vec3(0.1,0.5,0)\n    rotMat = rotationMatrix(vec3(1,1,0), iTime*0.2);\n    fragColor.rgb += ( 1.0/POW2(distance(vec3(sin(iTime)*25.0,0,cos(iTime)*25.0), rotMat*vec3(mapPos))) ) * 20.0 * MEDROTCOLOR;\n    fragColor.rgb += ( 1.0/POW2(distance(vec3(sin(-iTime)*25.0,0,cos(iTime)*25.0), rotMat*vec3(mapPos))) ) * 20.0 * MEDROTCOLOR;\n    \n    #define CAPSULECOLOR (vec3(1,0,1)*(-cos(iTime*2.0)*0.5+0.5))\n    //#define CAPSULEDIST (10.0 + sin(iTime)*5.0) Actually defined further up\n    rotMat = rotationMatrix(vec3(1,1,0), iTime*0.3);\n    fragColor.rgb += ( 1.0/POW2(distance(vec3(0, CAPSULEDIST+1.0,0), rotMat*vec3(mapPos))) ) * 10.0 * CAPSULECOLOR;\n    fragColor.rgb += ( 1.0/POW2(distance(vec3(0,-CAPSULEDIST+1.0,0), rotMat*vec3(mapPos))) ) * 10.0 * CAPSULECOLOR;\n    \n    #define RIMCOLOR vec3(0,0.1,0.3) * max(0.0, sin(atan(float(mapPos.z), float(mapPos.x))*5.0+iTime*5.0)) * step(30.0, length(vec3(mapPos))) * (1.0-smoothstep(20., 50., abs(float(mapPos.y))))\n    fragColor.rgb += clamp(( 1.0/abs(sdTorus(vec3(mapPos - ivec3(0,0,0)), vec2(50.0,20)) )), 0., 1.0) * 5.0 * RIMCOLOR;\n    \n    #define OUTROTSPEED 0.2\n    #define OUTROTRADIUS 45.0\n    #define OUTROTBRIGHTNESS 100.0\n    #define OUTROTCOLOR vec3(1,0.4,0)\n    fragColor.rgb += ( 1.0/POW2(distance(vec3( sin(iTime*OUTROTSPEED)*OUTROTRADIUS,0, cos(iTime*OUTROTSPEED)*OUTROTRADIUS), vec3(mapPos))) ) * OUTROTBRIGHTNESS * OUTROTCOLOR;\n    fragColor.rgb += ( 1.0/POW2(distance(vec3( cos(iTime*OUTROTSPEED)*OUTROTRADIUS,0,-sin(iTime*OUTROTSPEED)*OUTROTRADIUS), vec3(mapPos))) ) * OUTROTBRIGHTNESS * OUTROTCOLOR;\n    fragColor.rgb += ( 1.0/POW2(distance(vec3(-sin(iTime*OUTROTSPEED)*OUTROTRADIUS,0,-cos(iTime*OUTROTSPEED)*OUTROTRADIUS), vec3(mapPos))) ) * OUTROTBRIGHTNESS * OUTROTCOLOR;\n    fragColor.rgb += ( 1.0/POW2(distance(vec3(-cos(iTime*OUTROTSPEED)*OUTROTRADIUS,0, sin(iTime*OUTROTSPEED)*OUTROTRADIUS), vec3(mapPos))) ) * OUTROTBRIGHTNESS * OUTROTCOLOR;\n    \n    #ifdef DITHERING\n    fragColor.r = dither(fragCoord.xy / vec2(8), fragColor.r);\n    fragColor.g = dither(fragCoord.xy / vec2(8), fragColor.g);\n    fragColor.b = dither(fragCoord.xy / vec2(8), fragColor.b);\n    #endif\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}