{
    "Shader": {
        "info": {
            "date": "1584660423",
            "description": "infinity mirror",
            "flags": 1,
            "hasliked": 0,
            "id": "WdlyWn",
            "likes": 15,
            "name": "infinity mirror",
            "published": 3,
            "tags": [
                "reflection",
                "cube",
                "sphere",
                "ball",
                "mirror",
                "infinity",
                "elevator"
            ],
            "usePreview": 0,
            "username": "xjorma",
            "viewed": 683
        },
        "renderpass": [
            {
                "code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#if HW_PERFORMANCE==0\n#else\n#define AA\n#endif\n\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y,q.z)), 0.);\n}\n\nmat3 mo;\n\nfloat mapCube(vec3 p)\n{\n    p = mo * p * 2.;\n    float\tradius = 0.45;\n    vec3\tv = vec3(1,1,1);\n    vec3\tq = mod(p + v / 2., v) - v / 2.0;\n\tfloat\tds = sdSphere(q, radius);\n    float\tdb = sdBox(p, vec3(1. + radius));\n    return max(ds, db) / 2.;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat map(vec3 p)\n{\t\n    return min(mapCube(p), -sdRoundBox( p, vec3(1.6), 0.3 ));    \n}\n\n#define EPS  0.0001\n\nvec3 calcNormal(vec3 pos)\n{\n\n    vec3\tcol;\n    vec2\teps = vec2(EPS, 0);\n\tfloat d = map(pos);\n\treturn normalize(vec3(map(pos + eps.xyy) - d, map(pos + eps.yxy) - d, map(pos + eps.yyx) - d));\n}\n\nvoid rayMarch(vec3 ro, vec3 rd, out float t, out float d, in float maxd)\n{\n    t = 0.;\n    d = 0.;\n    vec3 cp = ro;\n    for(int i=0;i<90;++i)\n    {\n        d = map(cp);\n        t += d;\n        cp = ro+rd*t;\n        if (d < .001 || d > maxd)\n            break;\n    }\n}\n\nvec3 applyFog(vec3 rgb,float distance, vec3 fogColor)\n{\n    float fogAmount = 1.0 - exp( -distance*0.3 );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nvec3 getSkyColor(vec3 rd)\n{\n    return texture(iChannel0,rd).rgb;\n}\n\nvec3 lastRecur(vec3 ro,vec3 rd)\n{\n    return getSkyColor(rd);\n}\n\n#define GEN_RENDER(NAME,DIST,RECUR) \t\t\t\t\t\t\t\t\t\t\\\nvec3 NAME(vec3 ro,vec3 rd)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    float\tt,d;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    rayMarch(ro, rd, t, d, DIST);\t\t\t\t\t\t\t\t\t\t\t\\\n    vec3 p = ro + rd * t;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    vec3 n = calcNormal(p);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    vec3 color;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    if (d < .001)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        float fresnel = pow(1.0 - abs(dot(n, rd)), 2.0);\t\t\t\t\t\\\n        vec3 d = mix(vec3(1), vec3(0.82, 0.45, 0.20), fresnel);\t\t\t\t\\\n        vec3 ref = reflect(rd, n);\t\t\t\t\t\t\t\t\t\t\t\\\n        color = d * RECUR(p + ref * 0.2 , ref);\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    else\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        color = getSkyColor(rd);\t\t\t\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    return color;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n}\n\n\nGEN_RENDER(render4,  4., lastRecur)\nGEN_RENDER(render3,  4., render4)\nGEN_RENDER(render2,  4., render3)\nGEN_RENDER(render1,  4., render2)\nGEN_RENDER(render ,  4., render1)\n\n    \nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 desaturate(in vec3 c, in float a)\n{\n    float l = dot(c, vec3(1. / 3.));\n    return mix(c, vec3(l), a);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    mat3 ma = setCamera(vec3(0), vec3(0,1,-1));\n    \n\tro.y+=iTime;\n\t\n    fragColor = vec4(render(ma*ro/3.,ma*rd) ,1);\n}\n\n\n\nmat3 fromEuler(vec3 ang)\n{\n    mat3 mx = mat3(\n\t\t\t1.0,\t\t0.0,\t\t0.0,\n\t\t\t0.0,\t\tcos(ang.x),\t-sin(ang.x),\n\t\t\t0.0,\t\tsin(ang.x),\tcos(ang.x));\n    mat3 my = mat3(\n\t\t\tcos(ang.y), 0.0,\t\tsin(ang.y),\n\t\t\t0.0,\t\t1.0,\t\t0.0,\n\t\t\t-sin(ang.y),0.0,\t\tcos(ang.y));\n    mat3 mz = mat3(\n\t\t\tcos(ang.z), -sin(ang.z),0.0,\n\t\t\tsin(ang.z),\tcos(ang.z),\t0.0,\n\t\t\t0.0,\t\t0.0,\t\t1.0);\n        \n    return mx*my*mz;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\n    float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + iTime*.1;\n    float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5)-1.;\n    vec3 ro = 1.8 * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n    vec3 ta = vec3(0);\n    mat3 ca = setCamera( ro, ta );\n    \n    // Objet\n    mo = fromEuler(vec3(0.25, 0.2, 0.27) * iTime);\n\n    \n\tvec3 tot = vec3(0.0);\n        \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = render(ro, rd);\n\n\t    tot += col;\n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n    \n    tot = desaturate(tot, -0.4);\n    tot = vignette(tot, fragCoord / iResolution.xy, 0.8);\n\n\tfragColor = vec4(tot, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}