{
    "Shader": {
        "info": {
            "date": "1707621778",
            "description": "The world needs more CRT shaders.\nNo really I just needed to get some ideas out of my head, maybe they'll prove useful to someone.",
            "flags": 0,
            "hasliked": 0,
            "id": "43l3zB",
            "likes": 1,
            "name": "Variation on FixingPixelArt",
            "published": 3,
            "tags": [
                "scanlines",
                "crt",
                "shadowmask"
            ],
            "usePreview": 1,
            "username": "Yarr_RCD",
            "viewed": 301
        },
        "renderpass": [
            {
                "code": "/*\nVariation on:\nFixingPixelArt - Timothy Lottes\nhttps://www.shadertoy.com/view/XsjSzR\n\nLike the original, this shader is released to the public domain.\n\n-Uses only 4 corner texels\n-Explicit brightness boost (original sets maskLight above 1.0 instead)\n-Light up two shadow mask components per display pixel. Feels the\n same to me, but less brightness is lost to the shadow mask.\n-Pretend the beam abrubtly changes level at the brightest of two\n neighboring texels, then use the same kernel as the scanlines to\n smooth the transition.\n*/\n\n//Options\n//#define res vec2(320,200)\n#define res (iResolution.xy/6.0)\nfloat hardBeam = -6.0;\nfloat maskDark=0.5;\nfloat maskLight=1.0;\nfloat boost = (1.0/0.866) /*scanlines*/ * (1.0/0.8333) /*mask*/;\n//scanline boost from the integral from -1 to 1 of the beam kernel\n//mask boost from (2*maskLight+1*maskDark)/3\n\nfloat ToLinear1(float c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nvec3 ToLinear(vec3 c){return vec3(ToLinear1(c.r),ToLinear1(c.g),ToLinear1(c.b));}\nfloat ToSrgb1(float c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nvec3 ToSrgb(vec3 c){return vec3(ToSrgb1(c.r),ToSrgb1(c.g),ToSrgb1(c.b));}\n\nvec3 FetchNearest(vec2 pos)\n{    \n    pos = floor(pos*res)/res;\n    return ToLinear(texture(iChannel0, pos, -16.0).rgb);\n}\n\nmat4x3 FetchCorners(vec2 pos)\n{\n    pos = floor(pos*res);\n    mat4x3 o;\n    o[0] = ToLinear(texture(iChannel0, (pos+vec2(0.0,0.0))/res, -16.0).rgb);\n    o[1] = ToLinear(texture(iChannel0, (pos+vec2(1.0,0.0))/res, -16.0).rgb);\n    o[2] = ToLinear(texture(iChannel0, (pos+vec2(0.0,1.0))/res, -16.0).rgb);\n    o[3] = ToLinear(texture(iChannel0, (pos+vec2(1.0,1.0))/res, -16.0).rgb);\n    return o;\n}\n\nfloat BeamKernel(float f)\n{\n    return exp2(hardBeam*f*f);\n}\n\nvec3 Mask(vec2 pos)\n{\n    vec3 mask = vec3(maskLight, maskLight, maskLight);\n \n    pos.x += pos.y*3.0;\n    pos.x = fract(pos.x/6.0);\n         if(pos.x < 0.333) mask.r = maskDark;\n    else if(pos.x < 0.666) mask.g = maskDark;\n    else                   mask.b = maskDark;\n    return mask;\n}\n\nfloat MixHorizontal1(float left, float right, float f)\n{\n    if(left > right) return mix(right, left,  BeamKernel(f));\n    else             return mix(left,  right, BeamKernel(1.0-f));\n}\nvec3 MixHorizontal(vec3 left, vec3 right, float f)\n{\n    return vec3(\n        MixHorizontal1(left.r, right.r, f),\n        MixHorizontal1(left.g, right.g, f),\n        MixHorizontal1(left.b, right.b, f));\n}\n\nvec3 CRT(vec2 pos)\n{\n    mat4x3 c = FetchCorners(pos);\n    vec2 f = fract(pos*res);\n    vec3 bot = BeamKernel(    f.y)*MixHorizontal(c[0], c[1], f.x);\n    vec3 top = BeamKernel(1.0-f.y)*MixHorizontal(c[2], c[3], f.x);\n    vec3 col = bot+top;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 o;\n    if(uv.x < 0.5) o = FetchNearest(uv + vec2(0.25,0.0));\n    else           o = boost*CRT(uv + vec2(-0.25,0.0))*Mask(fragCoord.xy);\n    fragColor = vec4(ToSrgb(o),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}