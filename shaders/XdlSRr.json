{
    "Shader": {
        "info": {
            "date": "1395909642",
            "description": "Not much to say: it's a basic Voronoi diagram...",
            "flags": 0,
            "hasliked": 0,
            "id": "XdlSRr",
            "likes": 21,
            "name": "Simple Voronoi",
            "published": 3,
            "tags": [
                "voronoi"
            ],
            "usePreview": 0,
            "username": "Nrx",
            "viewed": 1027
        },
        "renderpass": [
            {
                "code": "// Concept from: https://iquilezles.org/articles/voronoilines\n\n// Relation between the \"HASH_MAGNITUDE\" (M) and \"KERNEL\" (K):\n// - In a given cell C1, the greatest distance from a point P1 of this cell to the cell's reference point R1 is D:\n//   D = SQRT2 * (M / 2 + 1 / 2)\n//   D = (M + 1) * SQRT2 / 2\n//   (This happens when P1 is in a corner of C1, and R1 is as far as possible in the opposite direction.)\n// - So, the farther other reference point R2 that can be closer to P1 is somewhere on the circle of center P1 and radius D.\n// - The center of the cell C2 which the reference point is R2 is maximum at a distance M / 2 from R2.\n// - The relative position of the center of C2 compare to C1 is K:\n//   K = floor (1 / 2 + sqrt ((D + M / 2) ^ 2 - (1 / 2) ^ 2))\n//   K = floor ((1 + sqrt (((M + 1) * SQRT2 + M) ^ 2 - 1)) / 2)\n// - If we neglect \"- 1\" in the square root, we can approximate K:\n//   K = floor ((1 + (M + 1) * SQRT2 + M) / 2)\n//   K = floor ((M + 1) * (SQRT2 + 1) / 2)\n// - Reciprocally, if we set K, we can compute the maximum value of M:\n//   M < 2 * (K + 1) / (SQRT2 + 1) - 1\n// Having said that, you can actually use greater values for M without too much risk, as the relations given here above are just for the worst case (i.e. theoretical).\n\n#define SQRT2\t1.41421356237\n#define SQRT3\t1.73205080757\n\n#define SIZE \t\t\t15\n#define HASH_MAGNITUDE\t(6.0 / (SQRT2 + 1.0) - 1.0) // Perfect if: HASH_MAGNITUDE < 2 * (KERNEL + 1) / (SQRT2 + 1) - 1\n#define KERNEL\t\t\t2 // Perfect if: KERNEL >= floor ((HASH_MAGNITUDE + 1) * (SQRT2 + 1) / 2)\n\n#define BORDER\n//#define CENTER\n#define DISTANCE\n#define STRIPS\n#define HEXAGONAL\n\nfloat hash (in int index) {\n\tfloat x = float (index);\n\treturn HASH_MAGNITUDE * 0.5 * sin (sin (x) * x + sin (x * x) * iTime);\n}\n\nvec2 pointInCell (in ivec2 cell) {\n\tint index = cell.x + cell.y * SIZE;\n\tvec2 point = vec2 (cell);\n\t#ifdef HEXAGONAL\n\tpoint.x += fract (point.y * 0.5) - 0.25;\n\t#endif\n\treturn point + vec2 (hash (index), hash (index + 1)) * (0.5 + 0.5 * sin (iTime * 0.5));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 p = float (SIZE) * (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\t#ifdef HEXAGONAL\n\tp.y /= SQRT3 * 0.5;\n\t#endif\n\tivec2 pCell = ivec2 (floor (p + 0.5));\n\n\tfloat dMin = HASH_MAGNITUDE + 1.0;\n\tvec2 pqMin;\n\tivec2 minCell;\n\tfor (int y = -KERNEL; y <= KERNEL; ++y) {\n\t\tfor (int x = -KERNEL; x <= KERNEL; ++x) {\n\t\t\tivec2 qCell = pCell + ivec2 (x, y);\n\t\t\tvec2 pq = pointInCell (qCell) - p;\n\t\t\t#ifdef HEXAGONAL\n\t\t\tpq.y *= SQRT3 * 0.5;\n\t\t\t#endif\n\t\t\tfloat d = dot (pq, pq);\n\t\t\tif (d < dMin) {\n\t\t\t\tdMin = d;\n\t\t\t\tpqMin = pq;\n\t\t\t\tminCell = qCell;\n\t\t\t}\n\t\t}\n\t}\n\tint col = minCell.x + minCell.y * SIZE;\n\tvec4 color = 0.6 + vec4 (hash (col), hash (col + 1), hash (col + 2), 0.0) * 0.8 / HASH_MAGNITUDE;\n\n\t#ifdef CENTER\n\tdMin = sqrt (dMin);\n\t#else\n\tdMin = HASH_MAGNITUDE + 1.0;\n\t#endif\n\n\t#ifdef BORDER\n\tfor (int y = -KERNEL; y <= KERNEL; ++y) {\n\t\tfor (int x = -KERNEL; x <= KERNEL; ++x) {\n\t\t\tivec2 qCell = pCell + ivec2 (x, y);\n\t\t\tif (qCell != minCell) {\n\t\t\t\tvec2 pq = pointInCell (qCell) - p;\n\t\t\t\t#ifdef HEXAGONAL\n\t\t\t\tpq.y *= SQRT3 * 0.5;\n\t\t\t\t#endif\n\t\t\t\tdMin = min (dMin, dot (0.5 * (pqMin + pq), normalize (pq - pqMin)));\n\t\t\t}\n\t\t}\n\t}\n\t#endif\n\n\tcolor *= smoothstep (0.02, 0.1, dMin);\n\n\t#ifdef DISTANCE\n\tcolor *= 0.9 + 0.1 * sin (dMin * 40.0);\n\t#endif\n\n\t#ifdef STRIPS\n\tfloat strip = float (col);\n\tfloat stripCos = cos (strip);\n\tfloat stripSin = sin (strip);\n\tstrip = mix (1.0, sin (40.0 * (pqMin.x * stripCos - pqMin.y * stripSin)), mod (strip * 0.5, 2.0));\n\tstrip *= sin (40.0 * (pqMin.x * stripSin + pqMin.y * stripCos));\n\tcolor *= 0.8 + 0.2 * strip;\n\t#endif\n\n\tfragColor = color;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}