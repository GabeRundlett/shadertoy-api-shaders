{
    "Shader": {
        "info": {
            "date": "1571599357",
            "description": "Volumetric raymarching for Cookie fanzine #003 with theme \"anaglyph\".\nUse your red/blue glass to see this in 3D!",
            "flags": 0,
            "hasliked": 0,
            "id": "tddXR4",
            "likes": 22,
            "name": "Voodoo",
            "published": 3,
            "tags": [
                "raymarching",
                "volumetric",
                "stereoscopic"
            ],
            "usePreview": 1,
            "username": "lsdlive",
            "viewed": 1090
        },
        "renderpass": [
            {
                "code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nVoodoo.\n\nVolumetric raymarching for Cookie fanzine #003 with theme \"anaglyph\".\nUse your red/blue glass to see this in 3D!\n\nMore about volumetric raymarching: https://www.shadertoy.com/view/wd3GWM\n\nSome notation:\np: position (usually in world space)\nrd: ray direction (eye or view vector)\n*/\n\n// Enable/disable animation & anaglyph (3D effect)\n#define ANIMATE\n#define ANAGLYPH\n\n#define PI 3.14159\n#define TAU 6.28318\n\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n// iq's noise\nfloat noise(in vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3. - 2. * f);\n\tvec2 uv = (p.xy + vec2(37., 17.) * p.z) + f.xy;\n\tvec2 rg = textureLod(iChannel0, (uv + .5) / 256., 0.).yx;\n\treturn -1. + 2.4 * mix(rg.x, rg.y, f.z);\n}\n\n// Fbm\nfloat fbm(vec3 p) {\n\treturn noise(p * .06125) * .5 + noise(p * .125) * .25 + noise(p * .25) * .125;\n}\n\n// Dodecahedron folding\n// checkout: https://www.shadertoy.com/view/wtsGzl\nvec3 fold(vec3 p) {\n\tvec3 nc = vec3(-.5, -.809017, .309017);\n\tfor (int i = 0; i < 5; i++) {\n\t\tp.xy = abs(p.xy);\n\t\tp -= 2. * min(0., dot(p, nc))*nc;\n\t}\n\treturn p - vec3(0, 0, 1.275);\n}\n\nfloat sdf_crystal(vec3 p, float scale) {\n\tvec3 fp = fold(p * scale);\n\tfloat cryst = dot(fp, normalize(sign(fp))) - .1 - sin(fp.y*.2)*2. - sin(fp.y*.7)*1.;\n\tcryst += min(fp.x*1., sin(fp.y*.3));\n\n\tfp = fold(fp) - vec3(.2, .57, -.2);\n\tfp = fold(fp) - vec3(-.14, .99, -2.4);\n\tfp = fold(fp) - vec3(-.03, 1., -.3);\n\tfp = fold(fp) - vec3(0, .26, 0);\n\tcryst += sin(fp.y*.18)*5.;\n\tcryst *= .6;\n\n\treturn cryst / scale;\n}\n\nfloat sdf_mask(vec3 p) {\n\tp.x = abs(p.x) - .28;\n\n\tp.xz *= r2d(.56);\n\tp.xy *= r2d(-.01);\n\n\treturn sdf_crystal(p, 3.);\n}\n\nfloat de(vec3 p) {\n\n#ifdef ANIMATE\n\tp.xy *= r2d(sin(iTime)*.3);\n\tp.xz *= r2d(sin(iTime*2.)*.12);\n\tp.xy *= r2d(sin(sin(iTime * 2.) * 2.) * .2);\n\tp.x += sin(iTime*2.)*.9;\n#endif\n\n\treturn sdf_mask(p * .1) / .1 + fbm(p * 35.) * .1;\n}\n\nvec3 camera(vec3 ro, vec3 ta, vec2 uv) {\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = normalize(cross(vec3(0, 1, 0), fwd));\n\tvec3 up = normalize(cross(fwd, left));\n\treturn normalize(fwd + uv.x * left + up * uv.y);\n}\n\nfloat raymarch(vec3 ray_ori, vec2 uv) {\n\tvec3 target = vec3(0);\n\tvec3 ray_dir = camera(ray_ori, target, uv);\n\tvec3 pos = ray_ori;\n\n\t// local density/distance\n\tfloat ldensity = 0.;\n\n\t// accumulation color & density\n\tvec4 sum = vec4(0.);\n\n\tfloat tmax = 25.;\n\tfloat tdist = 0., dist = 0.;\n\n\tfor (float i = 0.; (i < 1.); i += 1. / 64.) {\n\n\t\tif (dist < tdist * .001 || tdist > tmax || sum.a > .95)\n\t\t\tbreak;\n\n\t\t// evaluate distance function\n\t\tdist = de(pos) * .59;\n\n\t\t// check whether we are close enough (step)\n\t\t// compute local density and weighting factor \n\t\tconst float h = .05;\n\t\tldensity = (h - dist) * step(dist, h);\n\n\t\tvec4 col = vec4(1);\n\t\tcol.a = ldensity;\n\n\t\t// pre-multiply alpha\n\t\t// checkout: https://www.shadertoy.com/view/XdfGz8\n\t\t// http://developer.download.nvidia.com/assets/gamedev/files/gdc12/GDC2012_Mastering_DirectX11_with_Unity.pdf\n\t\tcol.rgb *= col.a;\n\t\tsum += (1. - sum.a) * col;\n\n\t\t// from duke/las\n\t\tsum.a += .004;\n\n\t\t// enforce minimum stepsize\n\t\tdist = max(dist, .03);\n\n\t\t// step forward\n\t\tpos += dist * ray_dir; // sphere-tracing\n\t\ttdist += dist;\n\t}\n\n\t// from duke/las\n\t// simple scattering approximation\n\tsum *= 1. / exp(ldensity * 3.) * 1.25;\n\n\tsum.r = pow(sum.r, 2.15);\n\tsum.r -= texture(iChannel0, uv * 6.).r * .18;\n\n\treturn sum.r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tfloat rotation_delta = 1.57;\n\tfloat z_dst = -19.5;\n\n#ifdef ANAGLYPH\n\trotation_delta -= .02;\n#endif\n\n\tvec3 ro1 = vec3(z_dst * cos(rotation_delta), 0, z_dst * sin(rotation_delta));\n\n#ifdef ANAGLYPH\n\trotation_delta += .04;\n#endif\n\n\tvec3 ro2 = vec3(z_dst * cos(rotation_delta), 0, z_dst * sin(rotation_delta));\n\n\tfloat red = raymarch(ro1, uv);\n\tfloat cyan = raymarch(ro2, uv);\n\n\tfragColor = vec4(vec3(red, vec2(cyan)), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}