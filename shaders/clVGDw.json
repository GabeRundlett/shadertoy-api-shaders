{
    "Shader": {
        "info": {
            "date": "1684407856",
            "description": "All year long I'm going to just focus on truchet tiles and the likes!\nAA off by default - GPU killer but pretty!\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "clVGDw",
            "likes": 36,
            "name": "Year of Truchets #020",
            "published": 3,
            "tags": [
                "raymarching",
                "torus",
                "refraction",
                "glass",
                "truchet"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 375
        },
        "renderpass": [
            {
                "code": "/**\n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #020\n    05/17/2023  @byt3_m3chanic\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n*/\n\n// AA = 1 = OFF else 2 > depending on GPU\n#define ZERO (min(iFrame,0))\n#define AA 1\n\n// AA\n\n#define R    \t\tiResolution\n#define T \t    \tiTime\n#define M \t    \tiMouse\n\n#define PI          3.141592653\n#define PI2         6.283185307\n\n#define MAX_DIST    50.\n\n// globals & const\nvec3 hit,hp;\nfloat mid,sid;\nmat2 flip,turn,r90;\n\nconst vec2 sz = vec2(1.25,1.5);\n\nconst vec3 size = sz.xyx;\nconst vec3 hlf = size/2.;\nconst vec3 bs = vec3(hlf*.9);\n// change depth / width / height of truchet grid\nconst vec3 grid = vec3(1,1,1);\n\nconst float thick = .175;\nconst float tc = thick*.55;\nconst float tf = thick*1.8;\nconst float td = thick;\nconst float tg = thick*1.2;\n    \nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.53,84.21+iDate.z)))*4832.3234); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\n\n//@iq sdf's\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat cap(vec3 p,float r,float h){\n    vec2 d = abs(vec2(length(p.xy),p.z))-vec2(h,r);\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n \nfloat trs( vec3 p,vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nvec2 map(vec3 p){\n    vec2 res = vec2(1e5,0.);\n    p.yz*=flip; p.xz*=turn;\n    vec3 q = p;\n    \n    vec3 id = floor((q + hlf)/size);\n    q = q-size*clamp(round(q/size),-grid,grid);\n   \n    float hs = hash21(id.xz+id.y);\n    if(hs>.5) q.xz*=r90;\n\n    vec2 p2 = vec2(length(q.xz-hlf.xz), length(q.xz+hlf.xz));\n    vec2 gx = p2.x<p2.y ? vec2(q.xz-hlf.xz) : vec2(q.xz+hlf.xz);\n    vec3 uv = vec3(gx.x,q.y,gx.y);\n\n    \n    float xhs = fract(2.*hs+id.y);\n    float rhs = fract(hs+id.x);\n    float trh = trs(uv,vec2(hlf.x,thick));\n\n    if(rhs>.9){\n        trh = length(vec3(abs(q.x),q.yz)-vec3(hlf.x,0,0))-thick;\n        trh = min(length(vec3(q.xy,abs(q.z))-vec3(0,0,hlf.z))-thick,trh);\n    } else if(rhs>.6){\n        trh = cap(q,hlf.x,thick);\n        trh = min(length(vec3(abs(q.x),q.yz)-vec3(hlf.x,0,0))-thick,trh);\n    } \n \n    trh=max(abs(trh)-.075,-trh);\n    trh=max(trh,box(q,bs));\n\n    if(trh<res.x ) {\n        float mt = floor(mod(xhs*7.32,4.))+1.;\n        res = vec2(trh,mt);\n        hit = uv;\n    } \n\n    \n    float bls = cap(vec3(q.xy,abs(q.z))-vec3(0,0,hlf),tc,tf);\n      bls = min(cap(vec3(q.zy,abs(q.x))-vec3(0,0,hlf),tc,tf),bls);\n    \n    float crt = cap(vec3(q.xy,abs(q.z))-vec3(0,0,hlf),td,tg);  \n      crt = min(cap(vec3(q.zy,abs(q.x))-vec3(0,0,hlf),td,tg),crt);\n   \n    bls=max(bls,-crt)-.01;\n\n    if(bls<res.x) {\n       res = vec2(bls,8.);\n       hit = q;\n    } \n\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist) {\n    float e = mindist*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n//@iq hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0,4,2),6.)-3.)-1., 0., 1. );\n\treturn c.z * mix( vec3(1), rgb, c.y);\n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n) {\n    n = normal(p,d,1.);\n    vec3 lpos = vec3(2,12,7);\n    vec3 l = normalize(lpos);\n    float diff = clamp(dot(n,l),.01,1.);\n    vec3 h = m==8.? vec3(.12) : hsv2rgb(vec3(T*.075+m*.08,.7,.3))*.4;\n\n    return h*diff;\n}\n\nvec3 render(in vec2 uv, in vec2 F )\n{    \n    vec3 C = vec3(0);\n    vec3 ro = vec3(0,0,3.25),\n         rd = normalize(vec3(uv,-1));\n\n    // mouse //\n    float mvt = 1.5707*sin(T*.08);\n    float x = M.xy==vec2(0) ? .68 : (M.y/R.y * 2.-1.)*PI;\n    float y = M.xy==vec2(0) ? .00 : (M.x/R.x * 2.-1.)*PI;\n\n    flip=rot(x+T*.07);\n    turn=rot(y+mvt);\n    r90=rot(1.5707);\n    \n    // bounces - set lower if slow\n    float b = 10.;\n\n    vec3  p = ro + rd * .1;\n    float atten = 1., k = 1., iv = 1., alpha = 1.;\n    \n    // loop inspired/adapted from @blackle's \n    // marcher https://www.shadertoy.com/view/flsGDH\n    for(int i=0;i<100;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n = vec3(0);\n\n        float d = i<32? ray.x*.3: ray.x*.9;\n        float m = ray.y;\n\n        p += rd * d * k;\n        \n        if (d*d < 1e-6) {\n            C+=shade(p,rd,d,ray.y,n)*atten;\n            \n            alpha *= 1e-1;\n            b -= 1.;\n            if(m==12.||b<1.)break;\n            \n            atten *= .98;\n            p += rd* .025;\n            k = sign(map(p).x);\n        \n            vec3 rf=refract(rd,n,iv>0.?.875:1.1);\n            iv *= -1.;\n            \n            if(length(rf) == 0.) rf = reflect(rd,n);\n            \n            rd=rf;\n            p+=-n*.0025;\n        } \n        if(distance(p,rd)>45.) { break; }\n    }\n    \n    return C;\n}\n\nfloat fltm(float t, float d) { return hash21(vec2(t,d));}\n\n// AA from @iq https://www.shadertoy.com/view/3lsSzf\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    vec3 C = vec3(0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - .5;\n        vec2 uv = (-R.xy + 2.*(F+o))/max(R.x,R.y);\n#else    \n        vec2 uv = (-R.xy + 2.*F)/max(R.x,R.y);\n#endif\n        vec3 color = render(uv,F);       \n        color = 1.35*color/(1.+color);\n        C += color;\n#if AA>1\n    }\n    C /= float(AA*AA);\n#endif\n    C = pow(C, vec3(.4545) );\n    // Output to screen\n    O = vec4(C,1.);\n}\n//end",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}