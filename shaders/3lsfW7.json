{
    "Shader": {
        "info": {
            "date": "1597487906",
            "description": "Plywood terrain",
            "flags": 0,
            "hasliked": 0,
            "id": "3lsfW7",
            "likes": 14,
            "name": "Plyworld",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "terrain"
            ],
            "usePreview": 0,
            "username": "ruojake",
            "viewed": 514
        },
        "renderpass": [
            {
                "code": "// Plyworld by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\nvec2 hash21(float v)\n{\n    vec2 p = vec2(v * 12.3 + 2., v + 11.31);\n\treturn fract(sin(p + dot(p, vec2(2.5341, 1.9413))) * 41321.123);\n}\n\nfloat hash12(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(3.5341, 2.9413))) * 4321.123);\n}\n\nfloat hash13(vec3 p)\n{\n\treturn fract(sin(dot(p, vec3(3.5341, 2.9413, 3.1533))) * 4321.123);\n}\n\nvec2 hash22(vec2 p)\n{\n\treturn fract(sin(p + dot(p, vec2(2.5341, 1.9413))) * 41321.123);\n}\n\n#define sat(x) clamp((x), 0., 1.)\n#define LAYERS 60.\n\nfloat noise(vec2 p)\n{\n\tvec2 i = floor(p);\n    vec2 f = smoothstep(0., 1., p - i);\n    const vec2 o = vec2(1, 0);\n    \n    return mix(mix(hash12(i), hash12(i + o), f.x),\n               mix(hash12(i + o.yx), hash12(i + 1.), f.x),\n               f.y);\n}\n\nfloat noise(vec3 p)\n{\n\tvec3 i = floor(p);\n    vec3 f = smoothstep(0., 1., p - i);\n    const vec2 o = vec2(1, 0);\n    \n    return mix(\n        mix(\n            mix(hash13(i), hash13(i + o.xyy), f.x),\n            mix(hash13(i + o.yxy), hash13(i + o.xxy), f.x),\n            f.y),\n        mix(\n            mix(hash13(i + o.yyx), hash13(i + o.xyx), f.x),\n            mix(hash13(i + o.yxx), hash13(i + 1.), f.x),\n            f.y),\n        f.z);\n}\n\nfloat fbm(vec2 p)\n{\n    const float per = .45;\n    const float oct = 5.;\n    \n    float res = 0.;\n    float amp = .4;\n    \n\tfor(float i = 1.; i <= oct; i += 1.)\n    {\n    \tres += amp * noise(p);\n        p += p;\n        amp *= per;\n    }\n    return smoothstep(1., 0., res);\n}\n\nvec2 noise21(float v)\n{\n\tfloat i = floor(v);\n    float f = smoothstep(0., 1., v - i);\n    return mix(hash21(i), hash21(i + 1.), f);\n}\n\nfloat stairstep(float v, float s, float b)\n{\n\tfloat i = floor(v * s);\n    float f = v * s - i;\n    f = smoothstep(b - 1., b, f * b);\n    return mix(i, i + 1., f) / s;\n}\n\nfloat pattern(vec3 p)\n{\n    float i = floor(p.y * LAYERS + .5);\n    float f = fract(p.y * LAYERS);\n\tvec2 o = hash21(i * 31. + .4) * 2. - 1.;\n    vec2 xz = p.xz;\n    p.xz += noise(p.xz * 5. + i * 3.) * .125 - .0625;\n    p.xz += mix(sin(dot(xz * 1000., o)), sin(dot(xz * 1301., o)), hash12(xz * 900.)) * .002;\n    \n    return mix( \n        fract(sin(dot(p.xz * 20. * (1. + sin(i * 1312.41) * .2), o))),\n        (cos(f * 25.1327) * 2. + 1.) * sat(1. - 100. * fwidth(p.x)),\n        smoothstep(.24, .25, min(f, 1. - f)));\n}\n\nfloat scene(vec3 p)\n{\n\tfloat res = fbm(p.xz);\n    res *= 2.5 - res * res;\n    res = mix(stairstep(res, LAYERS, 30.), res, sat(length(fwidth(p)) * 75.));\n    return .45 * (p.y + res - 2.);\n}\n\nfloat shadow(vec3 ro, vec3 rd, float maxDist, float k)\n{\n    float res = 1.;\n    float d = 0.;\n    float t = .01;\n    for(int i = 0; i < 30; ++i)\n    {\n        d = scene(ro + rd * t) * 2.;\n        res = min(res, k * d / t);\n        t += d;\n    \tif(abs(d) < .0001 || t >= maxDist)\n            break;\n        if (res < .001)\n        {\n        \tres = 0.;\n            break;\n        }\n    }\n    return res;\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat d = scene(p);\n    vec2 e = vec2(.00001, .0);\n    return normalize(d - vec3(\n        scene(p - e.xyy),\n        scene(p - e.yxy),\n        scene(p - e.yyx)));\n}\n\nvec3 ray(vec3 ro, vec3 lookAt, vec2 uv, float zoom)\n{\n\tvec3 f = normalize(lookAt - ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n\n    return normalize(uv.x * r + uv.y * u + f * zoom);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    vec2 m = clamp((iMouse.xy / iResolution.xy) * 2. - 1., vec2(-1.), vec2(1.));\n    if (m == vec2(-1.,-1.)) m = vec2(0.);\n    \n    vec3 v = vec3(0, 0, iTime * .1);\n    vec3 md = vec3(m.x * 2., m.y, -max(abs(m.x), abs(m.y) * .5));\n    \n    vec3 tgt = vec3(10., 1., 2.) + v + md;\n    vec3 ro = vec3(10.,1.5, 0.) + v;\n    \n    vec3 rd = ray(ro, tgt, uv, .8);\n    float t = 0.;\n    vec3 p;\n\n    for(float i = 0.; i < 60.; i++)\n    {\n    \tp = ro + rd * t;\n        float d = scene(p);\n        if (d < 0.) d /= (i * .75 + 1.);\n        \n        if (abs(d) < .00005) break;\n        t += d;\n    }\n\n    vec3 lDir = normalize(vec3(4,4,3));\n    vec3 n = normal(p);\n    float l = sat(dot(n,lDir));\n    l *= shadow(p + n * .01, lDir, 5., 1.5);\n    \n    vec3 col = mix(vec3(.95,.92,.76), vec3(.81,.72,.45), pattern(p));\n\t\n    col *= 1. + sin(floor(p.y * LAYERS) * 5123.23) * vec3(-.06,0.,.06);\n    col *= n.y * .6 + .4;\n    \n    col *= mix(vec3(.2,.25, .35), vec3(1.2,1.17,1.), l);\n    col = mix(mix(vec3(.96,.97,1.) * sat(1.3 - rd.y), vec3(.4,.4,.42), rd.y), col, sat(1.2 - t * .1));\n    \n    col *= 1. - smoothstep(.45, .7, length((uv * iResolution.y / iResolution.xy))) * .5;\n    \n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}