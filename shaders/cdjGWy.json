{
    "Shader": {
        "info": {
            "date": "1668517432",
            "description": "An extruded non-intersecting hexagon fractal curve.",
            "flags": 32,
            "hasliked": 0,
            "id": "cdjGWy",
            "likes": 72,
            "name": "Extruded Hexagon Fractal Curve",
            "published": 3,
            "tags": [
                "fractal",
                "hexagon",
                "truchet",
                "curve",
                "polar",
                "extrude",
                "gosper"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 681
        },
        "renderpass": [
            {
                "code": "/*\n\n    Extruded Hexagon Fractal Curve\n    ------------------------------\n    \n    This is an extruded hexagon fractal curve -- to match the 2D version that \n    I posted earlier. The original was constructed in a tri-level blob form, \n    but I've rendered this in a curved configuration to better display the \n    non-intersecting space-filling curve properties. As you can see, it has \n    a hexagon Truchet look about it.\n    \n    Although not the same, it has a similar feel to Fabrice Neyret and MLA's \n    Gosper curve examples, which are well worth the look if you haven't seen \n    them. Gosper curves are one those interesting and important topics that \n    very little code exists for.\n    \n    Technically, there's not much to this. I've rendered the curve in 2D to a\n    backbuffer, then extruded the 2D field inside the raymarching distance \n    function, which is a lot faster than constructing things on the fly. As a \n    small aside, it would be much more practical to render from a fixed size \n    buffer for many reasons. Even though cube map faces have fixed sizes, \n    they are not fun to work with in that capacity.\n    \n    I kept the lighting and coloring very basic, which is just another way to \n    say, I was feeling lazy. :D There are a few defines at the top of the \n    \"Common\" tab for anyone interested in changing the color, curve shape, etc.\n \n\n\n    \n    Related examples:\n    \n    // The Gosper curves are different, but have a very similar feel.\n    Gosper Closed Curves - mla\n    https://www.shadertoy.com/view/mdXGWl\n    \n    // The original Gosper curve example on here.\n    Gosper curve - FabriceNeyret2\n    https://www.shadertoy.com/view/cdsGRj\n    \n    // A 2D hexagon fractal version.\n    Hexagon Fractal Object - Shane\n    https://www.shadertoy.com/view/cdfGzs\n    \n*/\n\n\n// Global tile scale.\nvec2 scale = vec2(1./8.);\n\n// Max ray distance.\n#define FAR 20.\n\n\n// Scene object ID.\nfloat objID;\n\n\n\n// Height map value.\nfloat hm(in vec2 p){ \n\n    // Reading into \"Buffer A\".\n    // Stretching to account for the varying buffer size.\n    p *= vec2(iResolution.y/iResolution.x, 1);\n    return texture(iChannel0, p + .5).x;\n    \n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .015;\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n    */\n}\n\n \n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = p.y;\n\n    // The 2D hexagon fractal object.\n    float d2 = hm(p.xz);\n    \n    // Extruding the 2D field.\n    float d = opExtrusion(d2, p.y, .05);\n    \n    //d += d2*.25; // Raised tops.\n  \n    // Overall object ID.\n    objID = fl<d? 1. : 0.;\n    \n    // Combining the floor with the extruded object.\n    return  min(fl, d);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(0, iFrame); i<96; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    //const vec2 e = vec2(.001, 0);\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable. :)\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.  \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, \n    // the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*d/t)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += clamp(d, .01, stepDist), etc.\n        t += clamp(d, .005, .15); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    \n\t// Camera Setup.\n    vec3 ro = vec3(cos(iTime/8.)*1.1, 1.25, sin(iTime/8.)*1.1); // Camera position, doubling as the ray origin.\n\tvec3 lk = vec3(0, -.06, 0);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = lk + vec3(-.25, .5, .4);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .5; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro); // Forward.\n    //if(dot(fwd, vec3(fwd.z, 0, -fwd.x))==0.) fwd = normalize(fwd - vec3(0, 0, .00001));\n    vec3 rgt = normalize(cross(vec3(0, 1, 0), fwd));// Right. \n    // \"right\" and \"forward\" are perpendicular normals, so the result is normalized.\n    vec3 up = cross(fwd, rgt); // Up.\n    \n    // Camera.\n    //mat3 mCam = mat3(rgt, up, fwd);\n    // rd - Ray direction.\n    //vec3 rd = mCam*normalize(vec3(uv, 1./FOV));//\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the object ID.\n    float svObjID = objID;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n        vec3 sn = getNormal(sp, t);\n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        //sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        //float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough. \n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol = vec3(.6); \n        \n        vec2 txP = sp.xz;        \n        txP *= vec2(iResolution.y/iResolution.x, 1);\n        vec4 tx = texture(iChannel0, txP + .5);\n        float dst = tx.w;\n        float sf = 1./iResolution.y;\n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n            //float h = hm(sp.xz);\n            \n\n            \n            dst = max(dst, sp.y - .05 - .02);\n\n            \n            // The fractal curve object color.\n            #if COLOR == 0\n            vec3 fg = vec3(1, .2, .4);\n            fg = mix(fg, vec3(1, .4, .2), uv.y*.5 + .25);\n            #elif COLOR == 1\n            vec3 fg = vec3(.8, 1, .15);\n            fg = mix(fg, vec3(1, .8, .2), uv.y*.5 + .25);\n            #elif COLOR == 2\n            vec3 fg = vec3(.2, .5, 1);\n            fg = mix(fg, vec3(.1, .9, 1), uv.y*.5 + .25);\n            #else\n            vec3 fg = vec3(.85);\n            fg = mix(fg, vec3(.88, .9, .95), uv.y*.5 + .25);\n            #endif\n\n            // Object color.\n            \n            float th = .005*float(2 - cInd);\n            vec3 oCol = vec3(0);\n            oCol = mix(oCol, pow(fg, vec3(1)), 1. - smoothstep(0., sf,  dst + .005));\n            // Surface detail.\n            //oCol = mix(oCol, oCol*.5, 1. - smoothstep(0., sf,  abs(dst + .013) - .001));\n\n            texCol = mix(oCol, pow(fg, vec3(1.4)), 1. - smoothstep(0., sf, sp.y - .05 + .002));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, sp.y - .005));\n \n        }\n        else {\n            \n            // The floor pattern.\n            \n            \n            // Background.\n            texCol = vec3(.1); //vec3(.4, .35, .3); //vec3(.9, .95, 1)\n      \n            // The hexagon Truchet background.\n            float hSc = .2/.8660254*sqrt(7.)/scale.x*2.; // Scale based on the main pattern level.\n            vec2 hUV = rot2(-atan(sqrt(3.)/9.))*sp.xz; // Rotating the coordinates.\n            float bgP = bgPat(hUV*hSc)/hSc;\n            vec3 svBg = texCol;\n\n            // Rendering the hexagon background pattern.\n            texCol = mix(texCol, svBg*.8, (1. - smoothstep(0., sf*8., bgP)));  \n            texCol = mix(texCol, svBg*.5, 1. - smoothstep(0., sf, bgP));   \n            texCol = mix(texCol, svBg*1.1, 1. - smoothstep(0., sf, bgP + .0035));  \n            // Surface detail.\n            //texCol = mix(texCol, svBg*.6, 1. - smoothstep(0., sf,  abs(bgP + .011) - .001));\n \n            // Rendering some dark edges to match the extruded pattern.\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf,  dst - .0005));\n        \n        }\n       \n\n        \n        // Combining the above terms to produce the final color.\n        col = texCol*(diff*sh + .3 + vec3(1, .97, .92)*spec*freS*2.*sh);\n      \n        // Shading.\n        col *= ao*atten;\n        \n        // It's sometimes helpful to check things like shadows and AO by themselves.\n        //col = vec3(ao);\n          \n\t\n\t}\n    \n    // Horizon fog. Not visible here, but provided for completeness.\n    col = mix(col, vec3(0), smoothstep(0., .99, t/FAR));\n          \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// The 2D hexagon fractal object.\n\n\n// Dividing line passing through \"a\" and \"b\".\nfloat divLine(vec2 p, vec2 a, vec2 b){\n\n   // I've had to put a hack on the end to get rid of fine lines\n   // at the zero point. That, of course, invalidates the distance portion.\n   // However, in this case, I only need it for a border check, not distances.\n   // I'm not sure why the hack is needed... Some kind of float inaccuracy... \n   // I'll look into it later. :)\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b))*1e8;\n}\n\n// Standard polar partitioning.\nvec2 polRot(vec2 p, inout float na, int m){\n\n    const float aN = 6.;\n    float a = atan(p.y, p.x);\n    na = mod(floor(a/6.2831*aN) + float(m - 1), aN);\n    float ia = (na + .5)/aN;\n    p *= rot2(-ia*6.2831);\n    // Flip alternate cells about the center.\n    if(mod(na, 2.)<.001) p.y = -p.y;\n\n    return p;\n}\n\n// Partition lines.\nvec3 prtnLines(vec2 p, mat3x2 ctr){\n\n                \n    // Cell partition lines.\n    float div1 = divLine(p, ctr[1], ctr[0]);\n    float div2 = divLine(p, ctr[2], ctr[1]);  \n     // Cell border.\n    float bR = divLine(p, vec2(0), ctr[2]);\n    //bL = divLine(p, vec2(0), ctr[0]);\n\n    return vec3(div1, -max(div1, div2), max(div2, bR));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Aspect corret coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scale and smoothing factor.\n    const float sc = 1.;\n    float sf = sc*1.5/iResolution.y;\n    \n    // Automatically rotate through all levels.\n    //cInd = int(mod(floor(iTime/4.), 2.));\n    \n    \n    // Scaling and translation.\n    vec2 p = sc*uv;//rot2(3.14159/6. - iTime/24.)*sc*uv;\n    \n    // Scene field calculations.\n\n    vec2 op = p;\n    \n    // The distance field for each level.\n    vec3 gDst = vec3(1e5);\n \n    // Polar cell numbers.\n    vec3 na;    \n  \n    \n    // Bounds for each level.\n    float gBound = 1e5;\n\n    \n    // I poached this from one of my hexagonal six petal geometry examples. I remember\n    // working it out on paper and liking the fact that it was so weird but concise. \n    // Unfortunately, I didn't mention how I got there. :)\n    const float shF = sqrt(1./7.);\n    // The original radius of the circle that the curve is constucted around.\n    const float r0 = .2;\n    const float hr0 = r0/.8660254; // Hexagon radius.\n    float r20 = hr0/3.; // Small circle radius.\n    #if SHAPE != 0\n    r20 *= .8660254; // Readjusting the radius for hexagonal shapes.\n    #endif\n    // Each polar cell has an S-shaped curve running through it, which is\n    // constructed with three vertex points. There are two on the cell boundaries, \n    // and one in the center -- Check the figure with one iteration for a visual. \n    // The vertex scale changes for greater iteration depth, but not the direction, \n    // so we're going to precalculate the original scale and direction here.\n    mat3x2 ctr0 = mat3x2(rot2(3.14159/6.)*vec2(hr0*2./3., 0), vec2(r0*4./3., 0), \n                         rot2(-3.14159/6.)*vec2(hr0*4./3., 0));\n    \n    // Precalculating the rotation matrices, which get used a few times.\n    // The angle is a hexagonal rotation related number involving ratios...\n    // The tangential angle between thrice the apothem and half the side\n    // length... I worked it out long ago, and no longer care why it works. :D\n    //\n    // Angle between the vertical line and the line running through the \n    // left hexagon vertex to the right vertex on the hexagon above.\n    float rotAng = atan(sqrt(3.)/9.); // Approx: 0.19012.\n    mat2 mRot = rot2(rotAng);\n    mat2 mRotP3 = rot2(rotAng + 3.14159/3.); // Inner curve needs extra rotation.\n\n    for(int aI = 0; aI<3; aI++){\n\n        // The radius of the circle that the curve is constucted around.\n        float r2 = r20; // Small circle radius.\n        p = op; // Original global coordinates.\n       \n        // Split this space into polar cells, and return the local coordinates\n        // and the cell number, which is used later.\n        p = polRot(p, na.x, aI);\n\n\n        mat3x2 ctr = ctr0; // Curve center -- There are three in each segment.\n\n\n        // Partition lines for each of the three vertices in the cell.\n        vec3 oDiv = prtnLines(p, ctr);\n        // Hexagon bounds for this scale. It's used to reverse coloring at the end.\n        gBound = min(gBound, max(-oDiv.y, oDiv.z)); // Previous hexagonal boundary lines.\n\n    \n        // Left, middle, right central point distances.\n        vec3 c = vec3(dist(p - ctr[0]), dist(p - ctr[1]), dist(p - ctr[2])) - r2;\n        \n        \n        c = max(c*vec3(-1, 1, -1), oDiv);\n\n        float crv = min(max(c.x, c.z), c.y);\n        \n        if(crv<gDst.x){ gDst.x = crv; }\n        \n        \n\n        ////////////////////////  \n\n        // Move to the new frame of reference, readjust r to the new scale\n        // (the smaller circle, r2), then recalculate the curve.\n        \n        // Move to the new points.\n        mat3x2 p3 = mat3x2(p, p, p) - ctr;\n        //\n        if(mod(na.x, 2.)<.001){\n            // Flip the X-value in every second polar cell.\n            p3[0].x = -p3[0].x; p3[1].x = -p3[1].x; p3[2].x = -p3[2].x;\n        }\n        // Rotate each point to the new orientation. The second point\n        // needs to be rotated an extra 60 degrees.\n        p3[0] *= mRot; p3[1] *= mRotP3; p3[2] *= mRot;\n \n\n        for(int i = 0; i<3; i++){\n\n            ctr = ctr0*shF; \n            r2 = r20*shF;\n            \n            p = p3[i];\n            \n            // Split this space into polar cells, and return the local coordinates\n            // and the cell number, which is used later.\n            p = polRot(p, na.y, 1); // bI - 1\n\n\n            // Partition lines for each of the three vertices in the cell.\n            vec3 oDiv2 = prtnLines(p, ctr);\n            \n       \n            // Applying the previous clipping region to this one.\n            oDiv2 = max(oDiv2, oDiv[i]);\n     \n            // Left, middle, right central point distances.\n            c = vec3(dist(p - ctr[0]), dist(p - ctr[1]), dist(p - ctr[2])) - r2;\n            ////\n            \n            c = max(c*vec3(-1, 1, -1), oDiv2);\n           \n            crv = min(max(c.x, c.z), c.y);\n        \n            if(crv<gDst.y){ gDst.y = crv; }\n\n           \n       \n\n        } // End \"i\".\n        \n\n    } // End \"aI\".   \n\n\n    \n    // Clamp the level index between zero and one, since they're the only\n    // one's that work.\n    cInd = cInd<0? 0 : cInd>1? 1 : cInd;\n    \n    // Flipping patterns outside the bounds of previous levels... Yeah, it's confusing. :)\n    // With Truchet patterns, there's usually some cell pattern flipping involved, but with \n    // this example, there's level flipping also. \n    if(gBound<0.){ gDst.y = -gDst.y; gDst.z = -gDst.z; }\n     \n    // Giving the pattern some extra thickness.\n    gDst -= .004*float(3 - cInd);\n    \n    #ifdef CURVE\n    gDst = abs(gDst + .004*float(3 - cInd)) - .009*float(3 - cInd);\n    #endif\n \n    \n\n    // Edge, or stroke.\n    float dst = gDst[cInd];\n\n\n    // Output to screen\n    fragColor = vec4(dst);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// Fractal iteration depth. I'm only prividing 2 here, so the\n// numbers are 0 for the base object or 1.\nint cInd = 1;\n\n// Display the closed curve... Technically, the dark edges are the closed\n// curve, but this presents it more fully.\n#define CURVE\n\n// Arc shape. Circular: 0, Hexagon: 1.\n#define SHAPE 0\n\n// Color: Terracotta: 0, Lime: 1, Blue: 2, White: 3.\n#define COLOR 0\n\n\n//////////////\n// Background pattern code.\n// vec2 to float hash.\nfloat hash21( vec2 p ){ \n\n    return fract(sin(dot(p, vec2(1, 113)))*45758.5453); \n    // Animation, if preferred.\n    //p.x = fract(sin(dot(p, vec2(1, 113)))*45758.5453);\n    //return sin(p.x*6.2831853 + iTime)*.5 + .5; \n}\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Arc or blob shape.\nfloat dist(vec2 p){\n  \n    #if SHAPE == 0\n    return length(p); // Circle.\n    #else\n    p = abs(p);\n    return max(p.y*.8660254 + p.x*.5, p.x); // Hexagon.\n    #endif\n\n}\n\n\n// Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n// 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\nconst vec2 s = vec2(1, 1.7320508);\n\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID -- in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\nvec4 getHex(vec2 p){\n    \n    // The hexagon centers.\n\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    \n    // Nearest hexagon center (with respect to p) to the current point. \n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + .5);\n\n}\n\n// A pretty simple hexagon Truchet pattern.\n//\n// I'm using the standard arc pattern for the fractal hexagon curve option, \n// and the blob equivalent for the non-curve (or blob) option.\nfloat bgPat(vec2 p){\n\n    // The hexagon grid.\n    vec4 h = getHex(p + vec2(0, s.y/3.));\n    \n     // Unique random number.\n    float rnd = hash21(h.zw + .11);\n    #ifdef CURVE\n    h.xy *= rot2(3.14159/3.*floor(rnd*72.));\n    #else\n    if(rnd<.5) h.y = -h.y;\n    #endif\n    \n    // Distances from three equispapced hexagon vertices.\n    vec2 v = vec2(0, s.y/3.);\n    \n    // Three circles at the vertices.\n    vec3 cDist = vec3(dist(h.xy - v), \n                      dist(h.xy - rot2(6.2831/3.)*v), \n                      dist(h.xy - rot2(2.*6.2831/3.)*v)); \n    \n    \n    // Random circle size.\n    vec3 r = vec3(s.y/6.);\n    #if SHAPE != 0\n    r *= .8660254; // Readjusting the radius for hexagonal shapes.\n    #endif\n    \n    #ifdef CURVE\n    // Randomly replace some of the arcs with end point dots.\n    for(int i = 0; i<3; i++){\n       \n        if(hash21(h.zw + float(i + 1)/6.)<.2){\n\n            r.x = 0., \n            cDist.x = dist(h.xy - rot2(-6.2831/12. + float(i)*6.2831/3.)*v*.8660254);\n            cDist.x = min(cDist.x, dist(h.xy - rot2(6.2831/12. + float(i)*6.2831/3.)*v*.8660254));\n        }\n        \n        r = r.yzx;\n        cDist = cDist.yzx;\n    }\n    #endif\n   \n    cDist -= r;\n    \n    float d = min(min(cDist.x, cDist.y), cDist.z);\n    #ifdef CURVE\n    d = abs(d) - .15; // Circles to arcs.\n    #else\n    if(rnd<.5) d = -d; // Flip the pattern for the blob version.\n    #endif\n    \n    \n    return d;\n\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}