{
    "Shader": {
        "info": {
            "date": "1635634032",
            "description": "A shader I made during practice for inercia shader royale. ",
            "flags": 0,
            "hasliked": 0,
            "id": "7dVXDt",
            "likes": 37,
            "name": "Twisted^4 Tunnel",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "twisty",
                "rope"
            ],
            "usePreview": 0,
            "username": "Tater",
            "viewed": 698
        },
        "renderpass": [
            {
                "code": "#define MDIST 60.0\n#define STEPS 178.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n\n\nvec3 hsv(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n//My poor mans version of Javad Taba's helix function\nvec3 spiral(vec3 p, float R){\n   \n    p.xz*=rot(p.y/R);\n    vec2 s = sign(p.xz);\n    p.xz=abs(p.xz)-R*0.5;\n    \n    p.xz*=rot(iTime*pi/3.);\n    \n    float poy = p.y;\n    p.y=0.;\n    //This is supposed to correct for the distortion that happens\n    //when you twist a shape by rotating it over an axis.\n    //In my head it should work a lot better than it does, but\n    //it definitely helps a little bit so I guess it's better than nothing\n    p.yz*=rot(mix(0.,pi/4.,1./(R*0.5+1.5)))*-sign(s.x*s.y);\n    p.y=poy;\n    return p;\n}\n\n\nvec2 map(vec3 p){\n    float t = iTime*0.5;\n    //p.y+=sin(-p.z*0.1)*2.;\n    p.y-=p.z*p.z*0.008;\n    \n    p.zy*=rot(pi/2.);\n    vec3 po = p;\n\n    p.y-=t*pi*4.339;\n    \n    vec2 a = vec2(1);\n    vec2 b = vec2(2);\n    p.xz*=rot(-0.05*(iTime/3.));\n    p = spiral(p,6.6);\n    p = spiral(p,2.);\n    p = spiral(p,1.);\n    p = spiral(p,0.4);\n    //there are some small artifacts but you dont notice them ;) \n    \n    \n    //p = spiral(p,0.1);\n    //vec2 d = abs(p.xz);\n    //a.x = max(d.x,d.y)-1.0;\n    a.x = length(p.xz)-0.1;\n    //a.x = max((abs(po.y)-7.),a.x);\n    a.x*=0.6;\n    return vec2(a);\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.005,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,0.,-1.)*1.5;\n    if(iMouse.z>0.){\n    ro.yz*=rot(3.0*(iMouse.y/iResolution.y-0.5));\n    ro.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));\n    }\n    vec3 lk = vec3(0,0,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(0.9)+uv.x*r+uv.y*cross(f,r));  \n    vec3 p = ro;\n    float dO = 0.;\n    bool hit = false;\n    vec2 d= vec2(0);\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n\n        if(abs(d.x)<0.005||i>STEPS-1.5){\n            hit = true;\n            break;\n        }\n        if(dO>MDIST){\n            dO = MDIST;\n            break;\n        }\n    }\n    if(hit)\n    {\n        vec3 ld = normalize(-vec3(p.x,p.y,p.z-5.));\n      \n        //sss from nusan\n        float sss=0.01;\n        for(float i=1.; i<20.; ++i){\n            float dist = i*0.35;\n            sss += smoothstep(0.,1.,map(p+ld*dist).x/dist)*0.18*1.25;\n        }\n        for(float i=1.; i<5.; ++i){\n            float dist = i*0.7;\n            sss += smoothstep(0.,1.,map(p-ld*dist).x/dist)*0.25;\n        }\n        vec3 al = vec3(0.204,0.267,0.373);\n        vec3 n = norm(p);\n        vec3 r = reflect(rd,n);\n        float diff = max(0.,dot(n,ld));\n        float amb = dot(n,ld)*0.45+0.55;\n        float spec = pow(max(0.,dot(r,ld)),40.0);\n        #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).x)\n        float ao = AO(.3,n,p)*AO(.5,n,p)*AO(.9,n,p);\n\n        col = al*\n        mix(vec3(0.169,0.000,0.169),vec3(0.984,0.996,0.804),mix(amb,diff,0.75))\n        +spec*0.3;\n        col+=sss*hsv(vec3(0.76,0.9,1.35));\n        col*=mix(ao,1.,0.5);\n        col = pow(col,vec3(0.7));\n    }\n    vec3 bg = mix(vec3(0.094,0.000,0.200),vec3(0.600,0.000,0.600),length(rd.xy)-0.65);\n    \n    col = mix(col,bg,pow(dO/MDIST,2.5));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}