{
    "Shader": {
        "info": {
            "date": "1454751609",
            "description": "SAT building & minification. Left: SAT, right: mipmap. The SAT minification uses 9 tex samples. SAT can be built on CPU in 1 pass, O(N) but here it's built in 4 passes. For shadertoy preview to work, this SAT is dynamically rescaled to fit iResolution.y.",
            "flags": 32,
            "hasliked": 0,
            "id": "ldGGWm",
            "likes": 11,
            "name": "Summed Area Table (SAT) Sampling",
            "published": 3,
            "tags": [
                "texture",
                "sampling",
                "area",
                "table",
                "sat",
                "summed",
                "minification"
            ],
            "usePreview": 0,
            "username": "tsone",
            "viewed": 987
        },
        "renderpass": [
            {
                "code": "/*\n\nCopyright 2016 Valtteri \"tsone\" Heikkilä\n\nThis work is licensed under the Creative Commons Attribution 4.0 International License.\nTo view a copy of this license, visit http://creativecommons.org/licenses/by/4.0/\n\n*/\n\n\n// NOTE: The shader is not optimized.\n\n\n// Texture size multiplier. See main(). (Also see 'Buf A' pass.)\nfloat M;\n// SAT size in texels (as stored in FB in iChannel0). See main().\nvec2 TS;\nvec2 INVTS;\n\nfloat length2(in vec2 v) { return dot(v, v); }\n\n\nvec3 SATSample(in vec2 p, in vec2 s, in vec2 fbres)\n{\n    vec2 sc = TS / fbres;\n    vec2 mx = (TS - .5) / TS;    \n    \n    float area = (4. * TS.x*TS.y) * s.x*s.y;\n    \n    p -= INVTS;\n    p -= floor(p - s);\n\n    vec2 it = floor(p + s);\n    \n    vec2 at = INVTS + p - s;\n    vec2 bt = INVTS + fract(p + vec2(s.x, -s.y));\n    vec2 ct = INVTS + fract(p + vec2(-s.x, s.y));\n    vec2 dt = INVTS + fract(p + s);\n    vec2 b2t = vec2(mx.x, bt.y);\n    vec2 c2t = vec2(ct.x, mx.y);\n    vec2 d2t = vec2(mx);\n    vec2 d3t = vec2(mx.x, dt.y);\n    vec2 d4t = vec2(dt.x, mx.y);\n\n\tvec3 a  = texture(iChannel0, sc*at ).rgb;\n\tvec3 b  = texture(iChannel0, sc*bt ).rgb;\n\tvec3 c  = texture(iChannel0, sc*ct ).rgb;\n\tvec3 d  = texture(iChannel0, sc*dt ).rgb;\n    vec3 b2 = texture(iChannel0, sc*b2t).rgb;\n    vec3 c2 = texture(iChannel0, sc*c2t).rgb;\n    vec3 d2 = texture(iChannel0, sc*d2t).rgb;\n    vec3 d3 = texture(iChannel0, sc*d3t).rgb;\n    vec3 d4 = texture(iChannel0, sc*d4t).rgb;\n    \n    return (a - (it.x*b2 + b) - (it.y*c2 + c)\n            + (it.x*it.y*d2 + it.x*d3 + it.y*d4 + d)) / area;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    M = max(ceil(iChannelResolution[1].y / iResolution.y), 1.);\n    TS = iChannelResolution[1].xy / M;\n    INVTS = 1. / TS;\n    \n    float ti = .2 * cos(.92*iTime);\n\n    // Intersect plane and rotate texture coordinates.\n    vec3 c = fragCoord.xyy - vec3(.5*iResolution.x, iResolution.yy);\n    c.y += 1. * iResolution.y;\n    c.xy /= .02*c.z * iResolution.xy;\n    float sc = 6. - 2.*sin(iTime);\n    mat2 mat = sc * mat2(cos(ti), -sin(ti), sin(ti), cos(ti));\n    vec2 tc = mat * c.xy;\n    \n    // SAT sample using derivates.\n    vec2 dtc = fwidth(tc);\n    vec3 s = SATSample(tc, dtc, iChannelResolution[0].xy);\n    \n    // Mipmap sampling.\n    // TODO: Make sure mipmap uses anisotropic sampling.\n    float borderx = (iMouse.z > 0.) ? iMouse.x : .5*iResolution.x;\n    if (length2(dtc) < .25/length(TS) || fragCoord.x > borderx) {\n        s = texture(iChannel1, tc).rgb;\n        s = pow(s, vec3(2.2)); // Gamma decode.\n    }\n    \n    // Border.\n    s.gb *= clamp(abs(fragCoord.x - borderx) / 2.5, .375, 1.);\n\n    // Gamma encode.\n    s = pow(s, vec3(1./2.2));\n    fragColor = vec4(s, 1.);    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\nCopyright 2016 Valtteri \"tsone\" HeikkilÃ¤\n\nThis work is licensed under the Creative Commons Attribution 4.0 International License.\nTo view a copy of this license, visit http://creativecommons.org/licenses/by/4.0/\n\n*/\n\n/*\n\nSAT generation is based on this article: \nhttp://developer.amd.com/wordpress/media/2012/10/GDC2005_SATEnvironmentReflections.pdf\n\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Resizing SAT to fit iResolution.y This is for shadertoy preview to work...\n    float M = max(ceil(iChannelResolution[0].y / iResolution.y), 1.);\n    \n    // Because bilinear interpolation is used to sample the SAT (in the 'Image' shader)\n    // we must extend the SAT texture size by 1 texel. This is done by offseting with -1.\n    vec2 uv = M * (fragCoord-1.) / iChannelResolution[0].xy;\n    float istep = M / iChannelResolution[0].x;\n    \n    vec3 sum = vec3(0.);\n    for (int i = 0; i < 32; ++i) {\n        // Allow sampling below u=0 (as SAT is bilinearly sampled).\n        if (uv.x >= -M / iChannelResolution[0].x) {\n            vec3 s = texture(iChannel0, uv).rgb;\n            s = pow(s, vec3(2.2)); // Gamma decode.\n            sum += s;\n        }\n        uv.x -= istep;\n    }\n    fragColor = vec4(sum, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n\nCopyright 2016 Valtteri \"tsone\" HeikkilÃ¤\n\nThis work is licensed under the Creative Commons Attribution 4.0 International License.\nTo view a copy of this license, visit http://creativecommons.org/licenses/by/4.0/\n\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iChannelResolution[0].xy;\n    float istep = 32. / iChannelResolution[0].x;\n    vec3 sum = vec3(0.);\n    for (int i = 0; i < 32; ++i) {\n        if (uv.x >= 0.) {\n            sum += texture(iChannel0, uv).rgb;\n        }\n        uv.x -= istep;\n    }\n    fragColor = vec4(sum, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n\nCopyright 2016 Valtteri \"tsone\" HeikkilÃ¤\n\nThis work is licensed under the Creative Commons Attribution 4.0 International License.\nTo view a copy of this license, visit http://creativecommons.org/licenses/by/4.0/\n\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iChannelResolution[0].xy;\n    float istep = 1. / iChannelResolution[0].y;\n    vec3 sum = vec3(0.);\n    for (int i = 0; i < 32; ++i) {\n        if (uv.y >= .0) {\n            sum += texture(iChannel0, uv).rgb;\n        }\n        uv.y -= istep;\n    }\n    fragColor = vec4(sum, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n\nCopyright 2016 Valtteri \"tsone\" HeikkilÃ¤\n\nThis work is licensed under the Creative Commons Attribution 4.0 International License.\nTo view a copy of this license, visit http://creativecommons.org/licenses/by/4.0/\n\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iChannelResolution[0].xy;\n    float istep = 32. / iChannelResolution[0].y;\n    vec3 sum = vec3(0.);\n    for (int i = 0; i < 32; ++i) {\n        if (uv.y >= 0.) {\n            sum += texture(iChannel0, uv).rgb;\n        }\n        uv.y -= istep;\n    }\n    fragColor = vec4(sum, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}