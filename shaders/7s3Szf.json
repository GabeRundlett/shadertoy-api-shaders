{
    "Shader": {
        "info": {
            "date": "1633617669",
            "description": "Original version was made for https://t.me/webgl_ru community competition\n\nInspired by:\nhttps://www.shadertoy.com/view/MtXSRj\n\nDOF Based on http://tuxedolabs.blogspot.fr/2018/05/bokeh-depth-of-field-in-single-pass.html",
            "flags": 32,
            "hasliked": 0,
            "id": "7s3Szf",
            "likes": 8,
            "name": "Night city road",
            "published": 3,
            "tags": [
                "dof",
                "road",
                "city"
            ],
            "usePreview": 0,
            "username": "avin",
            "viewed": 449
        },
        "renderpass": [
            {
                "code": "// DOF Based on http://tuxedolabs.blogspot.fr/2018/05/bokeh-depth-of-field-in-single-pass.html\n#define DISPLAY_GAMMA 1.5\n\n#define GOLDEN_ANGLE 2.39996323\n#define MAX_BLUR_SIZE 20.0\n#define RAD_SCALE 0.5\n\n#define uFar 10.0\n\nfloat getBlurSize(float depth, float focusPoint, float focusScale)\n{\n\tfloat coc = clamp((1.0 / focusPoint - 1.0 / depth)*focusScale, -1.0, 1.0);\n    return abs(coc) * MAX_BLUR_SIZE;\n}\n\nvec3 depthOfField(vec2 texCoord, float focusPoint, float focusScale)\n{\n    vec4 Input = texture(iChannel0, texCoord).rgba;\n    float centerDepth = Input.a * uFar;\n    float centerSize = getBlurSize(centerDepth, focusPoint, focusScale);\n    vec3 color = Input.rgb;\n    float tot = 1.0;\n    \n    vec2 texelSize = 1.0 / iResolution.xy;\n\n    float radius = RAD_SCALE;\n    for (float ang = 0.0; radius < MAX_BLUR_SIZE; ang += GOLDEN_ANGLE)\n    {\n        vec2 tc = texCoord + vec2(cos(ang), sin(ang)) * texelSize * radius;\n        \n        vec4 sampleInput = texture(iChannel0, tc).rgba;\n\n        vec3 sampleColor = sampleInput.rgb;\n        float sampleDepth = sampleInput.a * uFar;\n        float sampleSize = getBlurSize(sampleDepth, focusPoint, focusScale);\n        \n        if (sampleDepth > centerDepth)\n        {\n        \tsampleSize = clamp(sampleSize, 0.0, centerSize*2.0);\n        }\n\n        float m = smoothstep(radius-0.5, radius+0.5, sampleSize);\n        color += mix(color/tot, sampleColor, m);\n        tot += 1.0;\n        radius += RAD_SCALE/radius;\n    }\n    \n    return color /= tot;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;   \n    \n    vec4 color = texture(iChannel0, uv).rgba;\n    \n    float focusPoint = 88.0;\n    float focusScale = iResolution.y/15.;\n    \n    color.rgb = depthOfField(uv, focusPoint, focusScale);\n\n    //tone mapping\n    color.rgb = vec3(1.7, 1.8, 1.9) * color.rgb / (1.0 + color.rgb);\n    \n    \n    vec3 col = color.rgb;\n    \n    //-----------------------------------------------------\n    // postprocessing\n    //-----------------------------------------------------    \n\n    // Color control\n    col = 0.5 * col + 0.5 * col * col * (3.0 - 2.0 * col);\n\n    // Border dark\n    col *= 0.2 + 0.8 * pow(32.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.3);\n\n    // Fade in\n    col *= smoothstep(0.0, 1.0, iTime);    \n    \n    color.rgb = col;\n    \n    // -----------------------------------------------------\n    \n    //inverse gamma correction\n\tfragColor = vec4(pow(color.rgb, vec3(1.0 / DISPLAY_GAMMA)), 1.0);\n    \n    // Debug depth\n    //fragColor.rgb = vec3(color.a)*0.015;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define ROAD_COL vec3(.1, .1, .1)\n#define ROAD_SEP_COL vec3(1., 1., 1.)\n#define BUILDING_COL vec3(1., 0., 0.)\n#define GROUND_COL vec3(0.250, .250, 0.250)\n\nconst float tau = 6.283185;\n\n//------------------------------\n\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 33758.5453)-.5;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;    \n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nconst float PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n\n//------------------------------\n\n// vec3 opRep(vec3 p, vec3 c) {\n//    return mod(p,c)-0.5*c;\n// }\n\nvec3 opRep(vec3 p, vec3 c) {\n    vec3 res = p;\n\n    if(c.x != 0.) res.x = mod(p.x,c.x)-0.5*c.x;    \n    if(c.y != 0.) res.y = mod(p.y,c.y)-0.5*c.y;   \n    if(c.z != 0.) res.z = mod(p.z,c.z)-0.5*c.z;\n        \n    return res;    \n}\n\nvec4 opU( vec4 d1, vec4 d2 ) {    \n    return d1.a<d2.a ? d1 : d2;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nmat2 rotation(float theta) {\n    return mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\n\nvec3 getBuildingColor(vec3 p){\n    vec3 block = floor(p.xyz + vec3(.25, 0., 0.));   \n    float fill = smoothstep(.1, .9, fract(p.y*1.)) * step(.1, fract(p.z*1.)) * step(.1, fract(p.x*2. + 0.5));\n    \n    float lightForce = Hash3d(block);\n    float isLightning = step(.5, Hash3d(block + vec3(52.12, 17.3, 7.5)));\n    \n    return vec3(fill)*(Hash3d(block) * isLightning + .01);        \n}\n\nvec3 getRoadColor(vec3 p){\n    float lineFill = step(fract(p.x*.25) + .05, .1) * step(.5, fract(p.z*.2));\n    float texture = step(fract(p.x*.25) + .05, .1) * step(.5, fract(p.z*.2));\n    \n    vec3 roadColor = vec3(noise2d(p.xz*4.));\n           \n    return mix(vec3(0.1, 0.1, 0.11) + roadColor*.05, vec3(1.), lineFill);\n}\n\nvec4 map(vec3 p) {   \n    \n    \n    vec4 res = vec4(getBuildingColor(p), sdBox(opRep(p, vec3(15.0, 0.0, 15.0)), vec3(3.0, 15., 3.0)));\n    res = opU(res, vec4(getRoadColor(p),sdBox(opRep(p, vec3(0.0, 0.0, 1.0)), vec3(3.0, .25, 5.0))));    \n    \n    // vec3 lp = p + (p.x > 0. ? vec3(0., 0., 2.5) : vec3(0.));\n    vec3 lp = p;\n    lp = lp + (abs(lp.x) > 10. ? vec3(0., -100., 0.): vec3(0.));\n    float lh = 0.5;\n    res = opU(res, vec4(vec3(1., 0., 0.),sdBox(opRep(lp + vec3(0., -lh, 0.), vec3(7.5, 0.0, 5.0)), vec3(.05, .20, .05))));    \n    res = opU(res, vec4(vec3(0.5, .5, .5),sdBox(opRep(lp, vec3(7.5, 0.0, 5.0)), vec3(.05, lh, .05))));           \n    \n    res = opU(res, vec4(GROUND_COL,p.y));\n    \n\treturn res;\n}\n\n\nvec4 trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    vec3 col = vec3(0.);\n    for (int i = 0; i < 100; i++) {\n    \tvec3 p = o + r * t;\n        vec4 result = map(p);\n        float d = result.a;\n        \n        if (d < 0.001) break;\n         \n        col = result.rgb;\n        t += d;\n    }\n    return vec4(col,t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;  \n    \n    vec2 m = vec2(0.00, 0.);\n    if (iMouse.z > 0.0) {\n        m = iMouse.xy / iResolution.xy - vec2(.5, 0.);\n    }\n        \n    m *= tau * vec2(1.0, 0.25);\n   \n   \n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float time = iTime*.525 * 1.1;\n    \n    time = mod(time, 100.);\n    \n    vec3 r = normalize(vec3(uv, 0.75 ));\n    \n    r.yz *= rotation(0.15 - m.y);\n    r.xy *= rotation(sin(time + 10.0) * 0.5);\n    \n    r.xz *= rotation(-m.x);\n    \n    float altitude = sin(time * 0.5) * 0.5 + 2.5;\n    vec3 o = vec3(sin(time * 0.5) * 1.17, altitude*.5 + 1., time * 32.0);        \n    \n    vec4 t = trace(o, r);\n    float tDepth = t.a;\n    vec3 tCol = t.xyz;\n    float fog = 1.0 / (1.0 + tDepth * tDepth * 0.01);  \n    vec3 col = mix(vec3(0.0), tCol, fog);\n    // vec3 fc = vec3(fog);\n\n       \n    \n\t// gamma\t\n\tcol = pow( clamp(col,.0,1.0), vec3(0.95) );\n\n\t// vignetting\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.21 );\n    \n\tfragColor = vec4(col ,tDepth);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}