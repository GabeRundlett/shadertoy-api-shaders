{
    "Shader": {
        "info": {
            "date": "1618319146",
            "description": "its private for my client, so a repost",
            "flags": 0,
            "hasliked": 0,
            "id": "7dfXR4",
            "likes": 3,
            "name": "blue fog",
            "published": 3,
            "tags": [
                "repost",
                "forapi"
            ],
            "usePreview": 0,
            "username": "JulianCode1337",
            "viewed": 294
        },
        "renderpass": [
            {
                "code": "#define PI 3.141592654\n\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3D(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n\n#define LOOP 4\nfloat fbm(vec3 p)\n{\n    float res=0.0;\n    float fre=1.0;\n    float ap=0.5+0.5/(1e-5+float(LOOP));\n    for(int i=0;i<LOOP;i++)\n    {\n        res+=ap*(0.5+0.5*simplex3D(p*fre));\n        fre*=3.0;\n        ap*=0.5;\n    }\n    res=pow(res,5.0);\n    return max(res,0.0);\n}\nfloat fbm_mask(vec3 p)\n{\n    float res=1.0;\n    float fre=1.0;\n    float ap=0.5+0.5/(1e-5+float(LOOP));\n    for(int i=0;i<LOOP;i++)\n    {\n\t\tfloat temp=0.5+0.5*simplex3D(p*fre);\n        res*=1.0-0.9*ap+ap*temp;\n        fre*=3.0;\n\t\tap*=0.5;\n    }\n    res=pow(res,5.0);\n    return max(res,0.0);\n}\n\nfloat CloudDensity(vec3 p)\n{\n\treturn fbm_mask(p);\n\t// return fbm(p);\n}\nconst vec3 SkyColor=vec3(0.68,0.63,0.58);\n#define IStepCount 60\n#define SamplerScale 0.01\n\n\nbool TraceClouds(vec3 RayOrigin,vec3 RayDir,float TMin,float TMax,out vec4 Luminance)\n{\n\n    Luminance=vec4(0.0);\n\t\n    // float alpha=0.0;\n    float StepT=(TMax-TMin)/float(IStepCount);\n\tfloat fogT = 0.;\n\tfloat PreStepT=StepT;\n    for(float t=TMin;t<TMax;)\n    {\n        vec3 CurrentPos=RayOrigin+t*RayDir;\n        float density=CloudDensity(SamplerScale*CurrentPos);\n\n\t\tfloat Bottom=RayOrigin.y-400.0;\n\t\tfloat Top=RayOrigin.y+70.0;\n\t\tfloat HeightFactor=clamp((CurrentPos.y-Bottom)/(Top-Bottom),0.0,1.0);\n\t\tfloat k=100.0*pow(1.0-HeightFactor,3.0);\n\n\t\tdensity=clamp(density*k,0.0,1.0);\n        float density2=density*density;\n\t\tfloat density05=sqrt(density);\n\t\tvec3 CloudColor=2.0-vec3(0.85,0.85,0.99);\n        vec3 color=2.2*pow(vec3(density2),CloudColor);\n        Luminance.xyz+=color*(1.0-Luminance.w);\n        Luminance.w+=density*(1.0-Luminance.w);\n\n\t\t\n\t\tif(Luminance.w>0.99)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tPreStepT=1.0*StepT*(1.0-0.99*density05);\n\t\tt+=PreStepT;\n\t\t// t+=1.0*StepT*(1.0-0.9*Luminance.w);\n    }\n    \n\n    return true;\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv=fragCoord/iResolution.xy;\n\n    vec2 coord=uv*2.0-1.0;\n    coord.x*=iResolution.x/iResolution.y;\n    // vec4 res=vec4(fbm(vec3(coord*2.0,iMouse.x+100.0+iTime*0.1)));\n    // vec3 RayOrigin=vec3(0.0,0.0,0.0);\n    vec3 RayOrigin=vec3(0.0,0.0,iTime*0.3/SamplerScale);\n    // vec3 RayOrigin=vec3(0.0,iTime*0.5/SamplerScale,0.0);\n    // vec3 RayOrigin=vec3(iTime*0.5/SamplerScale,0.0,iTime*0.5/SamplerScale);\n    vec3 RayDir=normalize(vec3(coord,1.0));\n\n    float TMin=20.0;\n    float TMax=200.0;\n    vec4 Luminance=vec4(0.0);\n    TraceClouds(RayOrigin,RayDir,TMin,TMax,Luminance);\n    fragColor=vec4(smoothstep(0.0,0.7,sqrt(Luminance.xyz))+SkyColor*(1.0-Luminance.w),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}