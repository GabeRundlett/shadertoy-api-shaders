{
    "Shader": {
        "info": {
            "date": "1638755845",
            "description": "Some base code for future projects. Includes a flycam that can be controlled with WASD, Shift to go faster, drag to rotate. Also basic raytracing code to get started. ",
            "flags": 48,
            "hasliked": 0,
            "id": "Nt3SRr",
            "likes": 4,
            "name": "Camera Model, Flycam, Raytracing",
            "published": 3,
            "tags": [
                "mouse",
                "rays",
                "camera",
                "keyboard",
                "flycam"
            ],
            "usePreview": 0,
            "username": "ASchneidman",
            "viewed": 247
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screen_coord = fragCoord / iResolution.xy;\n\n    fragColor = vec4(texture(iChannel0, screen_coord));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nfloat traceSphere(Ray ray, Sphere sphere) {\n    vec3 L = sphere.center - ray.origin;\n\n    float tca = dot(L, ray.direction);\n    if (tca < 0.0) {\n        return -1.0;\n    } \n\n    float d = dot(L, L) - tca * tca;\n    float r2 = sphere.radius * sphere.radius;\n    if (d > r2) {\n        return -1.0;\n    }\n\n    float thc = sqrt(r2 - d);\n\n    float t0 = tca - thc;\n    float t1 = tca + thc;\n\n    if (t0 < 0.0) {\n        if (t1 < 0.0) {\n            return -1.0;\n        }\n        return t1;\n    } else {\n        if (t1 < 0.0) {\n            return t0;\n        }\n        return min(t0, t1);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // TODO: THIS NEEDS TO GET THE CURRENT STATE STORED IN SOME BUFFER\n    // INSTEAD OF RESETTING EVERY FRAME\n    Camera camera = Camera_Get_Cached(iChannel1, iResolution);\n\n    mat4 model, view, rotation;\n    Camera_Model_View(camera, model, view, rotation);\n\n\n    // Generate ray and transform to world space\n    vec2 screen_coord = fragCoord / iResolution.xy;\n    vec2 centered = vec2(screen_coord.x - 0.5, screen_coord.y - 0.5);\n\n    float sensor_v = 2.0 * tan(Radians(camera.fov / 2.0));\n    float sensor_h = camera.aspect_ratio * sensor_v;\n\n    // In camera space, lies on plane at z = -1\n    vec3 scaled = vec3(centered.x * sensor_h, centered.y * sensor_v, -1.0);\n    Ray ray = Ray(vec3(0.0), normalize(scaled));\n    Ray_Transform(ray, model);\n\n\n    \n    Sphere sphere = Sphere(vec3(0.0, 0.0, -3.), 2.0);\n    float t = traceSphere(ray, sphere);\n    if (t >= 0.0) {\n        vec3 intersection_point = ray.origin + ray.direction * t;\n        vec3 color_norm = normalize(intersection_point - sphere.center);\n\n        color_norm = (color_norm + 1.) / 2.;\n        fragColor = vec4(color_norm, 1.0);\n        return;\n    }\n\n    \n    fragColor = vec4(0.0,0.0,0.0,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define VSCODE 0\n\n#define PI 3.14159\n#define UP vec3(0.0, 1.0, 0.0)\n#define Radians(x) ((x) * PI / 180.0)\n#define Degrees(x) ((x) * 180.0 / PI)\n\n\n// Utility Functions\n\nvec3 hsv2rgb(vec3 c)\n{\n    // from https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nmat4 euler_angles_to_rotation(vec3 ea) {\n    mat4 X = mat4(\n        vec4(1.0, 0.0, 0.0, 0.0),\n        vec4(0.0, cos(ea.x), -sin(ea.x), 0.0),\n        vec4(0.0, sin(ea.x), cos(ea.x), 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    mat4 Y = mat4(\n        vec4(cos(ea.y), 0.0, sin(ea.y), 0.0),\n        vec4(0.0, 1.0, 0.0, 0.0),\n        vec4(-sin(ea.y), 0.0, cos(ea.y), 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    mat4 Z = mat4(\n        vec4(cos(ea.z), -sin(ea.z), 0.0, 0.0),\n        vec4(sin(ea.z), cos(ea.z), 0.0, 0.0),\n        vec4(0.0, 0.0, 1.0, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n\n\n    return Z * Y * X;\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nvec3 Vector_Transform(vec3 v, mat4 m) {\n    return (m * vec4(v, 0.0)).xyz;\n}\n\nvoid Ray_Transform(inout Ray ray, mat4 m) {\n    vec4 homogeneous = m * vec4(ray.origin, 1.0);\n    ray.origin = homogeneous.xyz / homogeneous.w;\n\n    ray.direction = Vector_Transform(ray.direction, m);\n}\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\nstruct Camera {\n    vec3 position;\n    vec3 euler_angles;\n    //mat4 rotation;\n\n    float fov;\n    float aspect_ratio;\n\n    float move_sens;\n};\n\nCamera Camera_Reset(vec3 iResolution) {\n    // Matrices are in column major order\n    vec3 euler_angles = vec3(0.0, 0.0, 0.0);\n\n    return Camera(\n        vec3(0.0),\n        euler_angles,\n        90.0,\n        iResolution.x / iResolution.y,\n        0.015\n    );\n}\n\nvoid Camera_Model_View(Camera camera, out mat4 model, out mat4 view, out mat4 rotation) {\n    rotation = euler_angles_to_rotation(camera.euler_angles);\n    // Precomputes view\n    model = mat4(\n            vec4(1.0, 0.0, 0.0, 0.0),\n            vec4(0.0, 1.0, 0.0, 0.0),\n            vec4(0.0, 0.0, 1.0, 0.0),\n            vec4(camera.position.xyz, 1.0)\n        ) * rotation;\n\n    view = inverse(model);\n}\n\nCamera Camera_Get_Cached(sampler2D camera_channel, vec3 iResolution) {\n    vec3 position = texelFetch(camera_channel, ivec2(4, 0), 0).xyz;\n    vec3 euler_angles = texelFetch(camera_channel, ivec2(0, 0), 0).xyz;\n\n    return Camera(\n        position,\n        euler_angles,\n        90.0,\n        iResolution.x / iResolution.y,\n        0.015\n    );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n#if VSCODE\n#else\n#define KEYBOARD iChannel2\n\nconst int Key_W = 87;\nconst int Key_A = 65;\nconst int Key_S = 83;\nconst int Key_D = 68;\nconst int Key_Shift = 16;\nconst int Key_R = 82;\n\n\nbool isKeyDown(int key) {\n    return texelFetch(KEYBOARD, ivec2(key, 0), 0).x > 0.0;\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    int id = int(floor(fragCoord.x));\n    if (id >= 6 || fragCoord.y > 0.5) {\n        discard;\n    }\n\n    // id 0 computes position\n    // id 1 + i computes ith column of rotation\n    Camera camera = Camera_Reset(iResolution);\n    if (iFrame > 0) {\n        vec4 prev_iMouse = texelFetch(iChannel1, ivec2(5, 0), 0);\n        camera = Camera_Get_Cached(iChannel1, iResolution);\n\n        mat4 model, view, rotation;\n        Camera_Model_View(camera, model, view, rotation);\n\n        vec3 total_move = vec3(0.0);\n\n        if (isKeyDown(Key_Shift)) {\n            camera.move_sens *= 2.0;\n        }\n        if (isKeyDown(Key_W)) {\n            // Camera looks along -z axis, so \n            // take vector going along -z axis and transform\n            total_move += Vector_Transform(vec3(0.0, 0.0, -1.0), model);\n        }\n        if (isKeyDown(Key_S)) {\n            total_move += Vector_Transform(vec3(0.0, 0.0, 1.0), model);\n        }\n        if (isKeyDown(Key_D)) {\n            total_move += Vector_Transform(vec3(1.0, 0.0, 0.0), model);\n        }\n        if (isKeyDown(Key_A)) {\n            total_move += Vector_Transform(vec3(-1.0, 0.0, 0.0), model);\n        }\n\n        // Do translation\n        if (iMouse.z > 0.0) {\n            // Mouse is pressed, check if it was pressed last frame\n            if (prev_iMouse.z > 0.0) {\n                vec2 offset = (iMouse.xy - prev_iMouse.xy) * vec2(1.0, -1.0) * camera.move_sens;\n                //vec3 euler_change = vec3(0.0, offset.yx);\n                vec3 euler_change = vec3(offset.yx, 0.0);\n                \n                camera.euler_angles += euler_change;\n            }\n        }\n\n        if (length(total_move) > 0.0) {\n            camera.position += normalize(total_move) * camera.move_sens;\n        }\n\n        if (isKeyDown(Key_R)) {\n            camera = Camera_Reset(iResolution);\n        }\n    }\n\n    if (id == 0) {\n        fragColor = vec4(camera.euler_angles, 0.0);\n        return;\n    }\n    if (id == 4) {\n        fragColor = vec4(camera.position, 0.0);\n        return;\n    }\n    if (id == 5) {\n        fragColor = iMouse;\n        return;\n    }\n    //fragColor = camera.rotation[id];\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}