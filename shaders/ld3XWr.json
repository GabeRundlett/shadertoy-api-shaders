{
    "Shader": {
        "info": {
            "date": "1549132285",
            "description": "Playing with domain repetition with offsets and deformations and fighting artifacts. ",
            "flags": 1,
            "hasliked": 0,
            "id": "ld3XWr",
            "likes": 35,
            "name": "Ghost Silent Disco",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "seb0fh",
            "viewed": 1676
        },
        "renderpass": [
            {
                "code": "/*\n\tGhost Silent Disco\n\t02/2019\n\tseb chevrel\n*/\n\nconst float PI= 3.1415926535897;\nconst float H_PI = PI * 0.5;\nconst float Q_PI = PI * 0.25;\nconst float E_PI = PI * 0.125;\nconst float TWO_PI= PI*2.0;\n\n// rotations\nmat3 rotate(vec3 axis, float angle)\n{\n    axis = normalize(axis); float s = sin(angle), c = cos(angle), oc = 1.0 - c;\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c          \n               );\n}\nvec3 rotateX(vec3 p, float a) { float c = cos(a), s = sin(a); return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z); }\nvec3 rotateY(vec3 p, float a) { float c = cos(a), s = sin(a); return vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x); }\nvec3 rotateZ(vec3 p, float a) { float c = cos(a), s = sin(a); return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z); }\n\n// signed distance primitives (from IQ)\nfloat sdPlane( vec3 p, vec4 n ) { return dot(p,n.xyz) + n.w; }\nfloat sdSphere(vec3 p,float r) { return (length(p) - r); }\nfloat sdTorus(vec3 p,float r,float r2) { return(length( vec2(length(p.xz)-r,p.y) )-r2); }\nfloat sdBox( vec3 p, vec3 b ) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\nfloat sdHexPrism( vec3 p, vec2 h ) { vec3 q = abs(p); return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x); }\nfloat sdCylinder( vec3 p, vec3 c ) { return length(p.xz-c.xy)-c.z; }\nfloat sdCappedCylinder( vec3 p, vec2 h ) { vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdVerticalCapsule( vec3 p, float h, float r ) { p.y -= clamp( p.y, 0.0, h ); return length( p ) - r; }\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) { vec3 pa = p - a, ba = b - a; float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 ); return length( pa - ba*h ) - r; }\nfloat sdTriPrism( vec3 p, vec2 h ) { vec3 q = abs(p); return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5); }\nfloat sdEllipsoid( in vec3 p, in vec3 r ) { float k0 = length(p/r); float k1 = length(p/(r*r)); return k0*(k0-1.0)/k1;}\n\nfloat opSmoothUnion( float d1, float d2, float k ) { float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 ); return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat opSmoothSubtraction( float d1, float d2, float k ) { float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );    return mix( d2, -d1, h ) + k*h*(1.0-h); }\nfloat opSmoothIntersection( float d1, float d2, float k ) { float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat hash3(vec3 p) { return fract(dot(p,vec3(102.04978598, 51.98729547, 33.09874))*4.13439); }\nfloat hash2(vec2 p) { return fract(sin(1.0+dot(p,vec2(127.1,311.7)))*43758.545); }\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n#ifndef HIGH_QUALITY_NOISE\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;\n#else\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = textureLod( iChannel0, (uv+ vec2(0.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg2 = textureLod( iChannel0, (uv+ vec2(1.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg3 = textureLod( iChannel0, (uv+ vec2(0.5,1.5))/256.0, 0. ).yx;\n\tvec2 rg4 = textureLod( iChannel0, (uv+ vec2(1.5,1.5))/256.0, 0. ).yx;\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n#endif\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvec2 cossin(float a) { return vec2(cos(a),sin(a)); }\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) { return a + b*cos( 6.28318*(c*t+d) ); }\nfloat checkers( in vec3 p ) { vec2 s = sign(fract(p.xz*.5)-.5); return .5 - .5*s.x*s.y; }\n\n//----------------------------------------------------------------------------------------------\n\n\n\nvec2 map(in vec3 p) \n{    \n    float d2Plane=sdPlane(p,vec4(0.0,1.0,0.0,0.0));\n\n    vec2  grid_id = floor((p.xz+1.0)/2.0);    \n    float fSeed = hash2(grid_id);\n    float fSeed2 = hash2(grid_id+248.0);\n    \n    p.xz = mod( p.xz+1.0, 2.0 ) - 1.0;        \n    \n    float a =fSeed*TWO_PI+iTime*(1.0+fSeed2*3.0)*sign(fSeed-0.5);\n    vec2 sc = cossin(a);\n   \t\n    // deformation \n    p.xz +=cossin(p.y*sign(fSeed)+iTime*(5.0+fSeed2)+fSeed*TWO_PI).yx*0.2;\n    \n    // jump anim\n    p.y-=0.7+sin(iTime*(1.0+fSeed2*5.0)+fSeed)*0.5;\n    \n    // Body\n    float h = 1.0+fSeed2;\n    float r = sin(p.y*PI+fSeed*TWO_PI+iTime*10.0)*(0.05+fSeed2*0.05-0.025)+0.25;    \n    float d2Body =  sdVerticalCapsule(p, h, r);\n    \n    // Arms\n    float r2 = r*2.5;\n    float armH = h*0.6+fSeed2*0.3;\n    float armL = h*0.4+fSeed*0.2 + abs(sin(iTime*(1.0+fSeed*1.0)+fSeed2));\n    d2Body=opSmoothUnion(d2Body, sdCapsule(p, vec3(sc.x*r,armH,sc.y*r), vec3(sc.x*r2,armL,sc.y*r2) ,0.1), 0.2);\n    d2Body=opSmoothUnion(d2Body, sdCapsule(p, vec3(-sc.x*r,armH,-sc.y*r), vec3(-sc.x*r2,armL,-sc.y*r2) ,0.1), 0.2);\n    \n    // Mouth\n    float mouthR = max(0.0,sin(iTime*(0.7+fSeed2)+fSeed)*sin(iTime*(2.0+fSeed)+fSeed2)*0.15+0.1);\n    float d2Mouth = sdSphere(p+vec3(-sc.y*r,-h*(0.7+fSeed2*0.2),sc.x*r),mouthR);\n    \n    // Eyes\n    vec2 eye1 = cossin(a+Q_PI);\n    vec2 eye2 = cossin(a+Q_PI+H_PI);\n    float eyeS = 0.12;     \n    float d2Eyeball = min(sdSphere(p+vec3(eye1.x*r,-h,eye1.y*r),eyeS),sdSphere(p+vec3(eye2.x*r,-h,eye2.y*r),eyeS) );\n    float pupilS = 0.07;\n    float r3=r+eyeS;\n    float d2Pupil = min(sdSphere(p+vec3(eye1.x*r3,-h,eye1.y*r3),pupilS),sdSphere(p+vec3(eye2.x*r3,-h,eye2.y*r3),pupilS) );\n    float d2Eye = max(d2Eyeball, -d2Pupil);\n    \n    if (d2Plane<d2Body)\n   \t\treturn vec2(-1.0, d2Plane);\n    else if (d2Eye<d2Body)       \n        if (d2Pupil  < d2Eyeball )\n            return vec2(-4.0, d2Pupil);\n\t\telse            \n        \treturn vec2(-3.0, d2Eyeball);\n    else\n    {\n     \tif(d2Body > -d2Mouth)   \n        \treturn vec2(fSeed,d2Body);\n        else\n            return vec2(-2.0,-d2Mouth);\n    }\n}\n\nvec3 normal( in vec3 pos,in float epsilon )\n{\n\tvec3 eps = vec3( 0.003, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).y - map(pos-eps.xyy).y,\n\t    map(pos+eps.yxy).y - map(pos-eps.yxy).y,\n\t    map(pos+eps.yyx).y - map(pos-eps.yyx).y );\n\treturn normalize(nor);\n}\n\nfloat AO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.10*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).y;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat softShadows( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).y;\n        res = min( res, 7.0*h/t );\n        t += clamp( h, 0.01, 0.15 );\n        if( res<0.01 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd, in float px, const float maxdist )\n{\n    vec3 res = vec3(-1.0);\n    float t = 0.0;\n    for( int i=0; i<256; i++ )\n    {\n\t    vec2 IDdist = map(ro + t*rd);\n        res = vec3( t, IDdist.x, float(i)/256.0 );\n        if( IDdist.y<(px*t) || t>maxdist ) break;\n        t += min( IDdist.y, 0.4 )*0.4;\n    }\n\treturn res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 r = intersect(ro, rd, 0.3/iResolution.y, 100.0);                \t\n    \n    // light\n    vec3 p = ro+(rd*r.x);\n    vec3 nor = normal(p,0.0001);\n    vec3 light = normalize(vec3(-0.5,2.0,-1.0));\n    float diffuse = dot(nor,light);\n    float occlusion = AO(p,nor);\n    vec3 ref = reflect( rd, nor );\n    float specular = (r.y >=0.0 || r.y==-4.0) ? pow(clamp( dot( ref, light ), 0.0, 1.0 ),20.0) : 0.0;\n    float shadow = softShadows(p,light,0.01,10.0);   \n    \n    vec3 color = r.y<0.0 ? \n        (r.y<-3.0 ? vec3(0.1) :\n        (r.y<-2.0 ? vec3(1.0) :\n        (r.y<-1.0 ? vec3(0.1) :\n        checkers(p)*vec3(0.2)+0.2 ))) : \n        palette(r.y*100.,vec3(0.5),vec3(0.5),vec3(0.5),vec3(0.0,0.33,0.67));\n    \n    return vec3(1.0)*diffuse*specular + vec3(diffuse*0.5*shadow+0.5)*color;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xx) -vec2( 0.5,0.5*iResolution.y/iResolution.x);\n    \n    float time = iTime*0.3;\n  \n    float cam_h = sin(time*0.5+1.0)*5.0+10.0;\n    float cam_r = sin(time*1.7+2.0)*sin(time)*5.0+cam_h;    \n    vec3 ro = vec3(sin(time)*cam_r,cam_h,-cos(time)*cam_r);      \n    vec3 rd = normalize(vec3(uv, 1.0)); // fov\n    rd=rotateX(rd,PI/5.0);\n    \n    \n    fragColor=vec4(render(ro,rd) ,1.0);\n}\n\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    fragColor = vec4(render( fragRayOri, fragRayDir),1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}