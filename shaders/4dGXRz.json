{
    "Shader": {
        "info": {
            "date": "1462369650",
            "description": "The simplest mechanical system that exhibits deterministic chaos; see the source for details.",
            "flags": 32,
            "hasliked": 0,
            "id": "4dGXRz",
            "likes": 87,
            "name": "Double Pendulum",
            "published": 3,
            "tags": [
                "mechanics",
                "chaos",
                "pendulum"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 4535
        },
        "renderpass": [
            {
                "code": "// \"Double Pendulum\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  The simplest mechanical system that exhibits deterministic chaos.\n\n  The two sliders on the left control the relative masses of the two bobs\n  and the arm lengths. The right sliders control the initial angular\n  velocities of the two arms. Each change restarts the simulation.\n\n  The total energy is shown; if the numerical integration is sufficiently\n  accurate this should remain unchanged.\n\n  The dots show the most recent segment of the trajectory of the end bob.\n\n  Examine different parameter combinations to see the kinds of behavior that\n  can occur.\n*/\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nfloat Fbm2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, vec4 slVal);\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvec3 vnBall, ltDir;\nfloat rLen[2], bRad[2], pAng[2], dstBall, dstFar;\nint idObj;\nconst int ntPoint = 120;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  q.xy = Rot2D (q.xy, pAng[0]);\n  q.y -= - rLen[0];\n  d = PrCylDf (q.xzy, 0.03, rLen[0]);\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  q.yz -= vec2 (- rLen[0], -0.03);\n  d = PrSphDf (q, bRad[0]);\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  q.xy = Rot2D (q.xy, pAng[1] - pAng[0]);\n  q.yz -= vec2 (- rLen[1], -0.03);\n  d = PrCylDf (q.xzy, 0.03, rLen[1]);\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  q.yz -= vec2 (- rLen[1], -0.03);\n  d = PrSphDf (q, bRad[1]);\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  q = p;  q.yz -= vec2 (-1.1 * (rLen[0] + rLen[1]), 0.5);\n  d = PrBoxDf (q, vec3 (0.2, 1.15 * (rLen[0] + rLen[1]), 0.1));\n  if (d < dMin) { dMin = d;  idObj = 3; }\n  q = p;  q.y -= - 2.15 * (rLen[0] + rLen[1]) - 0.1;\n  d = PrBoxDf (q, vec3 (1., 0.1, 1.));\n  if (d < dMin) { dMin = d;  idObj = 3; }\n  q = p;  q.z -= 0.25;\n  d = PrCylDf (q, 0.1, 0.25);\n  if (d < dMin) { dMin = d;  idObj = 4; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat TBallHit (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec3 v;\n  float b, d, w, dMin, sz;\n  dMin = dstFar;\n  sz = 0.05;\n  p.z = 0.;\n  for (int n = 0; n < ntPoint; n ++) {\n    p.xy = Loadv4 (4 + n).xy;\n    p.xy *= -4.;\n    v = ro - p.xyz;\n    b = dot (rd, v);\n    w = b * b + sz * sz - dot (v, v);\n    if (w >= 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vnBall = (v + d * rd) / sz;\n      }\n    }\n  }\n  return dMin;\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  p *= 4.;\n  float f = dot (vec3 (Fbm2 (p.zy * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.xy * vec2 (1., 0.1))), abs (n));\n  return mix (vec3 (0.8, 0.4, 0.2), vec3 (0.45, 0.25, 0.1), f);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  float dstObj;\n  int idObjT;\n  dstBall = TBallHit (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (dstBall < min (dstObj, dstFar)) {\n    col = vec3 (0.7, 0.5, 0.3) * (0.4 + 0.6 * max (dot (vnBall, ltDir), 0.));\n  } else if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    col = vec3 (0.8, 0.8, 0.1);\n    if (idObj == 1) col = vec3 (0.9, 0.9, 1.);\n    else if (idObj == 2) col = vec3 (1., 1., 0.);\n    else if (idObj == 3) col = WoodCol (ro, vn);\n    else if (idObj == 4) col = vec3 (0.6, 0.6, 0.7);\n    col = col * (0.2 + 0.8 * max (dot (vn, ltDir), 0.) +\n       0.5 * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.));\n  } else col = (1. - 2. * dot (rd.xy, rd.xy)) * vec3 (0.2, 0.2, 0.4);\n  col = clamp (col, 0., 1.);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, slVal;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;;\n  float az, el, asp, parmL, parmM, mFrac, eTot;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  dstFar = 30.;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (0);\n  eTot = stDat.y;\n  el = stDat.z;\n  az = stDat.w;\n  stDat = Loadv4 (1);\n  pAng[0] = stDat.x;\n  pAng[1] = stDat.y;\n  slVal = Loadv4 (2);\n  parmL = (slVal.x - 0.5) * ((slVal.x >= 0.5) ? 1. : 1. / 5.) * 8. + 1.;\n  parmM = (slVal.y - 0.5) * ((slVal.y >= 0.5) ? 1. : 1. / 5.) * 8. + 1.;\n  rLen[0] = 2. / (1. + parmL);\n  rLen[1] = 2. * parmL / (1. + parmL);\n  mFrac = parmM / (1. + parmM);\n  bRad[0] = 0.05 * (1. + 3. * sqrt (1. - mFrac));\n  bRad[1] = 0.05 * (1. + 3. * sqrt (mFrac));\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 3.));\n  ro = vuMat * vec3 (0., 0., -15.);\n  ltDir = vuMat * normalize (vec3 (1., 2., -1.));\n  col = ShowScene (ro, rd);\n  col = ShowWg (uv, canvas, col, slVal);\n  col = mix (col, vec3 (1., 1., 0.), ShowInt (0.5 * uv - vec2 (0.47 * asp, - 0.45),\n     vec2 (0.06 * asp, 0.03), 4., floor (100. * eTot)));\n  fragColor = vec4 (col, 1.);\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, vec4 slVal)\n{\n  vec4 wgBx[4];\n  vec3 cc;\n  vec2 ut, ust;\n  float vW[4], asp;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (-0.45 * asp, 0., 0.012 * asp, 0.18);\n  wgBx[1] = vec4 (-0.35 * asp, 0., 0.012 * asp, 0.18);\n  wgBx[2] = vec4 ( 0.35 * asp, 0., 0.012 * asp, 0.18);\n  wgBx[3] = vec4 ( 0.45 * asp, 0., 0.012 * asp, 0.18);\n  vW[0] = slVal.x;\n  vW[1] = slVal.y;\n  vW[2] = slVal.z;\n  vW[3] = slVal.w;\n  for (int k = 0; k < 4; k ++) {\n    cc = (k < 2) ? vec3 (0.2, 1., 0.2) : vec3 (1., 0.2, 0.2);\n    ut = 0.5 * uv - wgBx[k].xy;\n    ust = abs (ut) - wgBx[k].zw * vec2 (0.7, 1.);\n    if (max (ust.x, ust.y) < 0.) {\n      if  (min (abs (ust.x), abs (ust.y)) * canvas.y < 2.) col = vec3 (1., 1., 0.);\n      else col = (mod (0.5 * ((0.5 * uv.y - wgBx[k].y) / wgBx[k].w - 0.99), 0.1) *\n         canvas.y < 6.) ? vec3 (1., 1., 0.) : vec3 (0.6);\n    }\n    ut.y -= (vW[k] - 0.5) * 2. * wgBx[k].w;\n    ut = abs (ut) * vec2 (1., 2.);\n    if (length (ut) < 0.03 && max (ut.x, ut.y) > 0.01) col = cc;\n  }\n  return col;\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv < 5) {\n    if (iv == -1) k = 8;\n    else if (iv == 0) k = 119;\n    else if (iv == 1) k = 36;\n    else if (iv == 2) k = 93;\n    else if (iv == 3) k = 109;\n    else k = 46;\n  } else {\n    if (iv == 5) k = 107;\n    else if (iv == 6) k = 122;\n    else if (iv == 7) k = 37;\n    else if (iv == 8) k = 127;\n    else k = 47;\n  }\n  q = (q - 0.5) * vec2 (1.7, 2.3);\n  d = 0.;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx - vo);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy - vp);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy - vm);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy + vm);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy + vp);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (sgn < 0.) {\n      if (idChar == mxChar - nDig - 1.) s = ShowDig (q, -1);\n      else ++ v;\n    }\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Double Pendulum\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float pi = 3.14159;\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nfloat nStep, gVal, mFrac, rLen1, rLen2, delT;\nconst int ntPoint = 120;\n\nvec4 EvalRhs (vec4 s)\n{\n  vec4 f;\n  float sd, cd, s1, s2, t;\n  sd = sin (s.x - s.y);\n  cd = cos (s.x - s.y);\n  s1 = sin (s.x);\n  s2 = sin (s.y);\n  t = delT / (1. - mFrac * cd * cd);\n  f.x = s.z * delT;\n  f.y = s.w * delT;\n  f.z = t * ((mFrac * cd * s2 - s1) * gVal / rLen1 -\n     mFrac * sd * (cd * s.z * s.z + (rLen2 / rLen1) * s.w * s.w));\n  f.w = t * ((cd * s1 - s2) * gVal / rLen2 +\n     mFrac * cd * sd * s.w * s.w + (rLen1 / rLen2) * sd * s.z * s.z);\n  return f;\n}\n\nvoid Step (inout vec4 s)\n{\n  vec4 k1, k2, k3, k4;\n  k1 = EvalRhs (s);\n  k2 = EvalRhs (s + k1 / 2.);\n  k3 = EvalRhs (s + k2 / 2.);\n  k4 = EvalRhs (s + k3);\n  s += (k1 + k4) / 6. + (k2 + k3) / 3.;\n  s.xy = mod (s.xy + pi, 2. * pi) - pi;\n}\n\nfloat Eng (vec4 s)\n{\n  float c1, c2;\n  c1 = cos (s.x);\n  c2 = cos (s.y);\n  return 0.5 * ((1. - mFrac) * rLen1 * rLen1 * s.z * s.z + \n     mFrac * (rLen1 * rLen1 * s.z * s.z + rLen2 * rLen2 * s.w * s.w +\n     2. * rLen1 * rLen2 * cos (s.x - s.y) * s.z * s.w)) +\n     gVal * ((1. - mFrac) * rLen1 * (1. - c1) +\n     mFrac * (rLen1 * (1. - c1) + rLen2 * (1. - c2)));\n}\n\nvec2 TPoint (vec4 s)\n{\n  return rLen1 * vec2 (sin (s.x), cos (s.x)) +\n         rLen2 * vec2 (sin (s.y), cos (s.y));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[4], mPtr, mPtrP, stDat, slVal, r;\n  vec2 iFrag, canvas, ust, tPoint;\n  float asp, vW, parmL, parmM, parmV1, parmV2, eTot, el, az;\n  int pxId, wgSel, wgReg, kSel;\n  bool doInit;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 + ntPoint) discard;\n  delT = 0.005;\n  gVal = 10.;\n  doInit = false;\n  wgReg = -2;\n  if (iFrame <= 5) {\n    parmL = 0.6;\n    parmM = 0.5;\n    parmV1 = -6.;\n    parmV2 = 6.;\n    slVal.x = 0.5 + (parmL - 1.) * ((parmL >= 1.) ? 1. : 5.) / 8.;\n    slVal.y = 0.5 + (parmM - 1.) * ((parmM >= 1.) ? 1. : 5.) / 8.;\n    slVal.z = 0.5 - parmV1 / 20.;\n    slVal.w = 0.5 - parmV2 / 20.;\n    mPtrP = mPtr;\n    wgSel = -1;\n    doInit = true;\n  } else {\n    nStep = Loadv4 (0).x;\n    r = Loadv4 (1);\n    slVal = Loadv4 (2);\n    stDat = Loadv4 (3);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (-0.45 * asp, 0., 0.012 * asp, 0.18);\n    wgBx[1] = vec4 (-0.35 * asp, 0., 0.012 * asp, 0.18);\n    wgBx[2] = vec4 ( 0.35 * asp, 0., 0.012 * asp, 0.18);\n    wgBx[3] = vec4 ( 0.45 * asp, 0., 0.012 * asp, 0.18);\n    for (int k = 0; k < 4; k ++) {\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  el = 0.;\n  az = 0.;\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {\n      el +=  pi * mPtr.y;\n      az += 2. * pi * mPtr.x;\n    }\n  } else {\n    for (int k = 0; k < 4; k ++) {\n      if (wgSel == k) {\n        kSel = k;\n        vW = clamp (0.5 + 0.5 * (mPtr.y - wgBx[k].y) / wgBx[k].w, 0.01, 0.99);\n        break;\n      }\n    }\n    if      (kSel == 0) slVal.x = vW;\n    else if (kSel == 1) slVal.y = vW;\n    else if (kSel == 2) slVal.z = vW;\n    else if (kSel == 3) slVal.w = vW;\n    doInit = true;\n  }\n  parmL = (slVal.x - 0.5) * ((slVal.x >= 0.5) ? 1. : 1. / 5.) * 8. + 1.;\n  parmM = (slVal.y - 0.5) * ((slVal.y >= 0.5) ? 1. : 1. / 5.) * 8. + 1.;\n  parmV1 = - (slVal.z - 0.5) * 20.;\n  parmV2 = - (slVal.w - 0.5) * 20.;\n  if (doInit) {\n    r = vec4 (0., 0., parmV1, parmV2);\n    nStep = 0.;\n  }\n  rLen1 = 1. / (1. + parmL);\n  rLen2 = 1. - rLen1;\n  mFrac = parmM / (1. + parmM);\n  if (! doInit) {\n    Step (r);\n    ++ nStep;\n  }\n  eTot = Eng (r);\n  if (pxId == 4) tPoint = TPoint (r);\n  else if (pxId > 4) {\n    if (doInit) tPoint = vec2 (0.);\n    else {\n      if (mod (nStep, 5.) == 0.) tPoint = Loadv4 (pxId - 1).xy;\n      else tPoint = Loadv4 (pxId).xy;\n    }\n  }\n  if (pxId == 0) stDat = vec4 (nStep, eTot, el, az);\n  else if (pxId == 1) stDat = r;\n  else if (pxId == 2) stDat = slVal;\n  else if (pxId == 3) stDat = vec4 (mPtr.xyz, float (wgSel));\n  else stDat = vec4 (tPoint, 0., 0.);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Double Pendulum\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float pi = 3.14159;\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nfloat nStep, gVal, mFrac, rLen1, rLen2, delT;\nconst int ntPoint = 120;\n\nvec4 EvalRhs (vec4 s)\n{\n  vec4 f;\n  float sd, cd, s1, s2, t;\n  sd = sin (s.x - s.y);\n  cd = cos (s.x - s.y);\n  s1 = sin (s.x);\n  s2 = sin (s.y);\n  t = delT / (1. - mFrac * cd * cd);\n  f.x = s.z * delT;\n  f.y = s.w * delT;\n  f.z = t * ((mFrac * cd * s2 - s1) * gVal / rLen1 -\n     mFrac * sd * (cd * s.z * s.z + (rLen2 / rLen1) * s.w * s.w));\n  f.w = t * ((cd * s1 - s2) * gVal / rLen2 +\n     mFrac * cd * sd * s.w * s.w + (rLen1 / rLen2) * sd * s.z * s.z);\n  return f;\n}\n\nvoid Step (inout vec4 s)\n{\n  vec4 k1, k2, k3, k4;\n  k1 = EvalRhs (s);\n  k2 = EvalRhs (s + k1 / 2.);\n  k3 = EvalRhs (s + k2 / 2.);\n  k4 = EvalRhs (s + k3);\n  s += (k1 + k4) / 6. + (k2 + k3) / 3.;\n  s.xy = mod (s.xy + pi, 2. * pi) - pi;\n}\n\nfloat Eng (vec4 s)\n{\n  float c1, c2;\n  c1 = cos (s.x);\n  c2 = cos (s.y);\n  return 0.5 * ((1. - mFrac) * rLen1 * rLen1 * s.z * s.z + \n     mFrac * (rLen1 * rLen1 * s.z * s.z + rLen2 * rLen2 * s.w * s.w +\n     2. * rLen1 * rLen2 * cos (s.x - s.y) * s.z * s.w)) +\n     gVal * ((1. - mFrac) * rLen1 * (1. - c1) +\n     mFrac * (rLen1 * (1. - c1) + rLen2 * (1. - c2)));\n}\n\nvec2 TPoint (vec4 s)\n{\n  return rLen1 * vec2 (sin (s.x), cos (s.x)) +\n         rLen2 * vec2 (sin (s.y), cos (s.y));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[4], mPtr, mPtrP, stDat, slVal, r;\n  vec2 iFrag, canvas, ust, tPoint;\n  float asp, vW, parmL, parmM, parmV1, parmV2, eTot, el, az;\n  int pxId, wgSel, wgReg, kSel;\n  bool doInit;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 + ntPoint) discard;\n  delT = 0.005;\n  gVal = 10.;\n  doInit = false;\n  wgReg = -2;\n  if (iFrame <= 5) {\n    parmL = 0.6;\n    parmM = 0.5;\n    parmV1 = -6.;\n    parmV2 = 6.;\n    slVal.x = 0.5 + (parmL - 1.) * ((parmL >= 1.) ? 1. : 5.) / 8.;\n    slVal.y = 0.5 + (parmM - 1.) * ((parmM >= 1.) ? 1. : 5.) / 8.;\n    slVal.z = 0.5 - parmV1 / 20.;\n    slVal.w = 0.5 - parmV2 / 20.;\n    mPtrP = mPtr;\n    wgSel = -1;\n    doInit = true;\n  } else {\n    nStep = Loadv4 (0).x;\n    r = Loadv4 (1);\n    slVal = Loadv4 (2);\n    stDat = Loadv4 (3);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (-0.45 * asp, 0., 0.012 * asp, 0.18);\n    wgBx[1] = vec4 (-0.35 * asp, 0., 0.012 * asp, 0.18);\n    wgBx[2] = vec4 ( 0.35 * asp, 0., 0.012 * asp, 0.18);\n    wgBx[3] = vec4 ( 0.45 * asp, 0., 0.012 * asp, 0.18);\n    for (int k = 0; k < 4; k ++) {\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  el = 0.;\n  az = 0.;\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {\n      el +=  pi * mPtr.y;\n      az += 2. * pi * mPtr.x;\n    }\n  } else {\n    for (int k = 0; k < 4; k ++) {\n      if (wgSel == k) {\n        kSel = k;\n        vW = clamp (0.5 + 0.5 * (mPtr.y - wgBx[k].y) / wgBx[k].w, 0.01, 0.99);\n        break;\n      }\n    }\n    if      (kSel == 0) slVal.x = vW;\n    else if (kSel == 1) slVal.y = vW;\n    else if (kSel == 2) slVal.z = vW;\n    else if (kSel == 3) slVal.w = vW;\n    doInit = true;\n  }\n  parmL = (slVal.x - 0.5) * ((slVal.x >= 0.5) ? 1. : 1. / 5.) * 8. + 1.;\n  parmM = (slVal.y - 0.5) * ((slVal.y >= 0.5) ? 1. : 1. / 5.) * 8. + 1.;\n  parmV1 = - (slVal.z - 0.5) * 20.;\n  parmV2 = - (slVal.w - 0.5) * 20.;\n  if (doInit) {\n    r = vec4 (0., 0., parmV1, parmV2);\n    nStep = 0.;\n  }\n  rLen1 = 1. / (1. + parmL);\n  rLen2 = 1. - rLen1;\n  mFrac = parmM / (1. + parmM);\n  if (! doInit) {\n    Step (r);\n    ++ nStep;\n  }\n  eTot = Eng (r);\n  if (pxId == 4) tPoint = TPoint (r);\n  else if (pxId > 4) {\n    if (doInit) tPoint = vec2 (0.);\n    else {\n      if (mod (nStep, 5.) == 0.) tPoint = Loadv4 (pxId - 1).xy;\n      else tPoint = Loadv4 (pxId).xy;\n    }\n  }\n  if (pxId == 0) stDat = vec4 (nStep, eTot, el, az);\n  else if (pxId == 1) stDat = r;\n  else if (pxId == 2) stDat = slVal;\n  else if (pxId == 3) stDat = vec4 (mPtr.xyz, float (wgSel));\n  else stDat = vec4 (tPoint, 0., 0.);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}