{
    "Shader": {
        "info": {
            "date": "1657347327",
            "description": "\"one cube challenge\": the idea is to draw a spinning cube with very little code [url]https://www.shadertoy.com/view/4d33R8[/url]\n\nI thought using ray marching with voxels might give a good result. My code isn't really golfed, but it should be a good start",
            "flags": 0,
            "hasliked": 0,
            "id": "fdtfWf",
            "likes": 5,
            "name": "one cube challenge - voxels",
            "published": 3,
            "tags": [
                "cube"
            ],
            "usePreview": 0,
            "username": "DjinnKahn",
            "viewed": 268
        },
        "renderpass": [
            {
                "code": "// public domain\n\n////212 chars from FabriceNeyret2:\n//void mainImage( out vec4 f, vec2 u )\n//{\n//    vec3 R = iResolution, p, P = R-R; P.z-= 6.;\n//    for ( f += 1.-f;  P.z < 7.;  \n//          dot(p=sign( 2. - abs(round(p))),p) < 2. && p == p*p ? f *= .99 : f\n//        )\n//        p = P += .01*vec3( (u+u-R.xy)/R.y, 1 ), \n//        p.xz *= mat2(cos(iTime+vec4(0,33,11,0)));\n//}\n\n\nvoid mainImage( out vec4 f, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y; // normalize input coord\n    \n    mat3 m = mat3( cos(iTime), 0., sin(iTime), 0., 1., 0., -sin(iTime), 0., cos(iTime) ); // rotation matrix\n        \n    float CAMERA_DIST = 6.;\n    \n    vec3 pos = m * vec3( 0., 0., -CAMERA_DIST );\n    vec3 v = m * vec3( uv, 1. );\n    \n    f = vec4(1.);    \n    for ( ; length(pos) < 7.; pos += v*.01 ) // ray-march until ray is far away\n    {\n        float CUBE_SIZE = 2.;        \n        vec3 voxelPos = round(pos); // voxel (5,5,a) or (5,a,-5) or (-5,-5,a) is ON for abs(a) <= 5\n        vec3 p = sign( CUBE_SIZE - abs(voxelPos));  // p value of (0,0,1) or (0,1,0) or (0,0,1) is ON\n        if ( length(p) <= 1. && p == abs(p) )\n        //if ( p*p-p*p.yzx == p )\n            f *= vec4(.99);\n    }\n}\n\n////213 chars from FabriceNeyret2: (old style rendering)\n//void mainImage( out vec4 f, vec2 u )\n//{\n//    vec3 R = iResolution,p;\n//  \n//    f-=f;\n//    for ( float t = 0.; t < 99.; t += .1 ) \n//        p = vec3( ( u+u - R.xy ) / R.y *t , t - 15. ), \n//        p.xz *= mat2(cos(iTime+vec4(0,33,11,0))) ,\n//        p = sign( 5. - abs(floor(p))),\n//        dot(p,p) <= 1. && p == p*p ? f += .06 : f;\n//}\n\n\n\n\n// ray-marching + voxels\n//\n//void mainImage( out vec4 f, in vec2 fragCoord )\n//{\n//    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y; // normalize input coord\n//    \n//    mat3 m = mat3( cos(iTime), 0., sin(iTime), 0., 1., 0., -sin(iTime), 0., cos(iTime) ); // rotation matrix\n//        \n//    float CAMERA_DIST = 15.;\n//    \n//    vec3 pos = m * vec3( 0., 0., -CAMERA_DIST );\n//    vec3 v = m * vec3( uv, 1. );\n//    \n//    f = vec4(0.);\n//    \n//    for ( float t = 0.; t < 25.; t += .01 ) // sample 99 positions\n//    {\n//        float CUBE_SIZE = 5.;\n//        vec3 voxelPos = floor(pos + v*t); // voxel (5,5,a) or (5,a,-5) or (-5,-5,a) is ON for abs(a) <= 5\n//        vec3 p = sign( CUBE_SIZE - abs(voxelPos));  // p value of (0,0,1) or (0,1,0) or (0,0,1) is ON\n//        if ( length(p) <= 1. && p == abs(p) )\n//        //if ( p*p-p*p.yzx == p )\n//            f += vec4(.006);\n//    }\n//}\n\n//void mainImage( out vec4 f, in vec2 fragCoord )\n//{\n//    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n//    \n//    mat3 m = mat3( cos(iTime), 0., sin(iTime), 0., 1., 0., -sin(iTime), 0., cos(iTime) );\n//        \n//    vec3 pos = vec3( -sin(iTime), 0., cos(iTime) ) * -15.;\n//    vec3 v = m * vec3( uv, 1. );\n//    \n//    f = vec4(0.);\n//    \n//    for ( float t = 0.; t < 99.; t += .1 )\n//    {\n//        vec3 p = 5. - floor(abs(pos + v*t));  \n//        //if ( p*p.yzx+p == abs(p) )\n//        if ( p*p*p*p.yzx + p == abs(p) )\n//            f += vec4(.06);\n//    }\n//}\n\n\n//void mainImage( out vec4 f, in vec2 fragCoord )\n//{\n//    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n//    \n//    mat3 m = mat3( cos(iTime), 0., sin(iTime), 0., 1., 0., -sin(iTime), 0., cos(iTime) );\n//        \n//    vec3 pos = m * vec3( 0., 0., -15. );\n//    vec3 v = m * vec3( uv, 1. );\n//    \n//    f = vec4(0.);\n//    \n//    for ( float t = 0.; t < 99.; t += .1 )\n//    {\n//        vec3 p = sign( 5. - floor(abs(pos + v*t)));  \n//        if ( p*p.yzx+p == abs(p) )\n//        //if ( p*p*p*p.yzx + p == abs(p) )\n//            f = vec4(1.);\n//    }\n//    \n//    // Output to screen\n//    //f = vec4(col);\n//}\n\n\n//void mainImage( out vec4 fragColor, in vec2 fragCoord )\n//{\n//    // Normalized pixel coordinates (from 0 to 1)\n//    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n//    \n//    mat3 m = mat3( cos(iTime), 0., sin(iTime), 0., 1., 0., -sin(iTime), 0., cos(iTime) );\n//        \n//    vec3 pos = m * vec3( 0., 0., -15. );\n//    vec3 v = m * vec3( uv, 1. );\n//    \n//    float col = 0.;\n//    \n//    for ( float t = 0.; t < 99.; t += .1 )\n//    {\n//        vec3 p = 5. - floor(abs(pos + v*t));  \n//        //if ( length(p) == p.x+p.y+p.z && p.x*p.y*p.z == 0. )\n//        if ( p*p.yzx == vec3(0.) && p == abs(p) )\n//        //if ( p*p*p*p.yzx + p == abs(p) )\n//            col = 1.;\n//    }\n//    \n//    // Output to screen\n//    fragColor = vec4(col);\n//}\n//\n\n\n//float sphereCol( vec3 a, vec3 v, float r )\n//{    \n//    return 1. - ( dot(a,a) - dot(a,v)*dot(a,v)/dot(v,v) ) / (r*r);\n//}\n//\n//void mainImage( out vec4 fragColor, in vec2 fragCoord )\n//{\n//    // Normalized pixel coordinates (from 0 to 1)\n//    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n//    \n//    mat3 m = mat3( cos(iTime), 0., sin(iTime), 0., 1., 0., -sin(iTime), 0., cos(iTime) );\n//        \n//    vec3 pos = m * vec3( 0., 0., -8. );\n//    vec3 v = m * vec3( uv, 1. );\n//    \n//    vec3 spherePos = vec3( -1., 0., 0. );\n//    \n//    vec3 a = spherePos - pos;\n//    float distToSphere = dot(a,a) - dot(a,v)*dot(a,v)/dot(v,v);\n//    \n//    float col = 0.;\n//\n//    col += max( 0., sphereCol( vec3( -2., 0., 0. ) - pos, v, 1. ) );\n//    col += max( 0., sphereCol( vec3( -1., 0., 0. ) - pos, v, 1. ) );\n//    col += max( 0., sphereCol( vec3( 0., 0., 0. ) - pos, v, 1. ) );\n//    col += max( 0., sphereCol( vec3( 1., 0., 0. ) - pos, v, 1. ) );\n//    col += max( 0., sphereCol( vec3( 2., 0., 0. ) - pos, v, 1. ) );\n//    \n//    // Output to screen\n//    fragColor = vec4(col);\n//}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}