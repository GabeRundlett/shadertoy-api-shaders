{
    "Shader": {
        "info": {
            "date": "1725888234",
            "description": "originals https://glslsandbox.com/e#67378.0",
            "flags": 0,
            "hasliked": 0,
            "id": "X3fyz4",
            "likes": 1,
            "name": "bloom menger",
            "published": 3,
            "tags": [
                "menger",
                "bloom"
            ],
            "usePreview": 1,
            "username": "nayk",
            "viewed": 101
        },
        "renderpass": [
            {
                "code": "#define  time iTime\n#define  resolution iResolution.xy\n\n\n\n// Emulate a black texture\n#define texture(s, uv) vec4(0.0)\n\n\n#define R           iResolution\n#define M           iMouse\n#define T           iTime\n#define S           smoothstep\n#define PI          3.1415926\n#define PI2         6.2831853\n#define d5          .5773\n#define MINDIST     .0001\n#define MAXDIST     100.\n\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n//thebookofshaders timing functions\nfloat easeInOutExpo(float t) {\n    if (t == 0.0 || t == 1.0) return t;\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * pow(2.0, 10.0 * (t - 1.0));\n    } else {\n        return 0.5 * (-pow(2.0, -10.0 * (t - 1.0)) + 2.0);\n    }\n}\n\nfloat linearstep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0.0, 1.0);\n}\n\nfloat circle(vec2 pt, vec2 center, float r, float lw) {\n  float len = length(pt - center),\n        hlw = lw / 5.,\n        edge = .21;\n  return smoothstep(r-hlw-edge,r-hlw, len)-smoothstep(r+hlw,r+hlw+edge, len);\n}\n\nvec3 getMouse(vec3 p) {\n    float x = M.xy == vec2(0) ? -.6 : -(M.y/R.y * 1. - .5) * PI;\n    float y = M.xy == vec2(0) ? -1. :  (M.x/R.x * 1. - .5) * PI;\n    \n    p.zy *=r2(x);\n    p.xz *=r2(y);\n    return p;\n}\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.)-.05;\n}\n\nfloat getCircle(vec2 p, vec2 rp){\n\tp *= vec2(iResolution.x, iResolution.y);\n    p /= max(iResolution.x, iResolution.y);\n    \n    return step(distance(p, rp), 0.1);\n}\n\nfloat orbit = .0,\n      txx   = .0025,\n      txa   = .0025,\n      glw   = .0;\nfloat zoom = 17.5; \nmat2 rotA = mat2(0.), rotB = mat2(1.), spin = mat2(0.);\n\n//@gaz Original Fractal Formula - Thank you!\n//translated comments\n//https://twigl.app/?ch=-MFu0X8wYxqxuhK4Cgd9&dm=graphics\nfloat Scale;\nvec3 map(vec3 p,float mgl){\n \n  \tp.zy-=-1.3;\n     \n    p.yx *= rotA;\n    p.xz *= rotB;\n    vec3 res = vec3(100.,-1.,0.);\n\n    float b = sdBox(p,vec3(2.5));\n\n    if(b<res.x) res=vec3(b,2.,orbit);\n    \n    // It will be the size of the box, but it is interesting to play with the numbers.\n    // Just because the size changes, so does the camera position.\n    p=abs(p)-3.5;\n\n    // Don't tamper with the three lines here. \n    // @pjkarlik - when I read this - I quickly staretd to touch it! haha but dont!\n    if(p.x<p.z)p.xz=p.zx;\n    if(p.y<p.z)p.yz=p.zy;\n    if(p.x<p.y)p.xy=p.yx;\n\n    // Negative value is recommended for this number.\n    // If this is set to a negative value, the amount of movement will fold each time\n    // I think that reversing will give a good pattern.\n\tfloat rate=-16.5;\n\t\n\t// This number has good sensitivity, so I think it is fine.\n\tfloat mr2=.25;\n\t// I think the standard here is about 0.3 to 1.8.\n\tfloat off=1.37;\t// This number is the initial magnification. \n    // In the case of fractal, it is 1.0, but since it has artifacts,\n    // Set to 3.0 to slow down ray progress. You almost never have to finger.\n    // If you want to reduce the number of iterations of the Martin group and make it lighter\n    // Adjust while making it close to 1.0 while observing artifacts.\n\tfloat s=.95;\n    // Fractal folding is IFS of magnification. After changing the scale, move to make changes.\n    // The initial coordinates are used for the movement amount. By the way, \n    //the variable of off is used to adjust the degree of this movement amount.\n    vec3  p0 = p;\n    p.xz *= rotB;\n    // You can play around with the number of iterations.\n    for (float i=0.; i<5.55; i++){\np.xy*=r2(iTime*1.1);\n\n    // Please do not tamper with this function.\n    p=3.5-abs(p-1.);\n\n    // You can play around with all the constants here.\n    float g=clamp(mr2*max(1.25/dot(p,p),.8),0.,1.);\n\n    // Please do not tamper with these two lines.\n    p=p*rate*g+p0*off;\n    s=s*abs(rate)*g+off;\n        \n    // Rotate the coordinates a little. It's a bit peaky, so try it little by little.\n    // You can do various things without rotating it forcibly. I think it's better to use it with an accentã€‚\n  \n    }\n\n    // This number is log2() the final scale factor. It is a parameter for coloring.\n    // There is no problem with log() separately. I'm using it with a glue like log2() because it will be multiplied like twice.\n    Scale = log2(s);\n\torbit=log2(s*.0091553);\n  \n    //return length(p.xy)/s-.003;\n    \n    float d= length(p.xz)/s-.025;\n    d= max(sdBox(p,vec3(5.))/s-.01,-d);\n    if(d<res.x) res=vec3(d,1.,orbit);\n    //glw += .00025/(.025+d*d);//@evvvil \n    glw += .15/(.3+b*b);//@evvvil\n    return res;\n    //return length(cross(p,normalize(vec3(1))))/s-.003;\n}\n\n// distance estimator\nvec3 marcher(vec3 ro, vec3 rd, int maxsteps) {\n    float d = 0.,\n          m = -1.,\n          o = 0.;\n    int i = 0;\n    for(int ii = 0; ii<256; ii++) {\n        vec3 p = ro + rd * d;\n        vec3 t = map(p,1.);\n        if(t.x<MINDIST||d>MAXDIST) break;\n        d += t.x*.5;\n        m  = t.y;\n        o  = t.z;\n        ++i;\n    }\n    float de = float(i)/float(maxsteps);\n    return vec3(d,m,o);\n}\n\n// Tetrahedron technique @iq\n// https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 getNormal(vec3 p, float t){\n    float e = (MINDIST + .0001) *t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ,0.).x + \n                      h.yyx*map( p + h.yyx*e ,0.).x + \n                      h.yxy*map( p + h.yxy*e ,0.).x + \n                      h.xxx*map( p + h.xxx*e ,0.).x );\n}\n\n//camera setup\nvec3 camera(vec3 lp, vec3 ro, vec2 uv) {\n    vec3 f=normalize(lp-ro),//camera forward\n         r=normalize(cross(vec3(0,1,0),f)),//camera right\n         u=normalize(cross(f,r)),//camera up\n         c=ro+f*.595,//zoom\n         i=c+uv.x*r+uv.y*u,//screen coords\n        rd=i-ro;//ray direction\n    return rd;\n}\n//vec3(.45,1.5,1.25)?\nvec3 gethue(float a){return  1.15 + .45*cos((4.5*a) - vec3(.25,1.5,2.15));}\n\nvec3 getColor(float m, float o){\n    vec3 h = gethue(o*.25);\n    // use orbit number to band coloring\n    if(o>4.     && o<5.1)   h=vec3(1.);\n    if(o>6.     && o<6.1)   h=vec3(1.);\n    if(o>7.15   && o<7.65)  h=vec3(1.);\n    if(o>8.     && o<8.6)   h=vec3(1.);\n    if(o>.0     && o<.5)    h=vec3(1.);\n    if(o>-.1    && o<-.05)  h=vec3(1.);\n    if(o>-2.2   && o<-1.75) h=vec3(1.);\n    if(o>-3.8   && o<-2.75) h=vec3(1.);\n    if(o>-6.    && o<-5.75) h=vec3(1.);\n    if(o>-9.    && o<-8.75) h=vec3(1.);\n    if(o>-8.5   && o<-7.75) h=vec3(1.);\n    return h;\n}\n\nfloat ao(float j, vec3 p, vec3 n) {\n    return clamp(map(p + n*j,0.).x/j, 0.,1.);   \n}\n#define colorRange 24.0\nvoid mainImage( out vec4 O, in vec2 F ){\n  \n    float tm = mod(T*2.5, 32.);\n   \n   vec2 uv2 =  F/vec2(iResolution.x, iResolution.y);\n\n    vec2 uv3 = F/iResolution.xy;\n\n    vec2 pos = 0.5 - uv3;\n\n \n   pos*=0.25;\n    float dist = 10.2/length(pos);\n  \n\n   \n    dist = pow(dist, 100.08);\n   \n    vec3 col = dist * vec3(1.0, 0.5, 0.25);\n\t\n   \n    col = 1.3 - exp( -col );\n     vec3 circle2 = getCircle(pos, vec2(0.,0.0)) * vec3(00.72, 0.3, 0.0)+col * 3.1;\n    float v1 = linearstep(0.0, 1.0, tm);\n    float a1 = linearstep(2.0, 3.0, tm);\n    \n\tfloat v2 = linearstep(4.0, 5.0, tm);\n    float a2 = linearstep(6.0, 7.0, tm);\n    \n    float v3 = linearstep(8.0, 9.0, tm);\n    float a3 = linearstep(10.0, 11.0, tm);\n    \n    float v4 = linearstep(12.0, 13.0, tm);\n    float a4 = linearstep(14.0, 15.0, tm);\n    \n    float v5 = linearstep(16.0, 17.0, tm);\n    float a5 = linearstep(18.0, 19.0, tm);\n    \n\tfloat v6 = linearstep(20.0, 21.0, tm);\n    float a6 = linearstep(22.0, 23.0, tm);\n    \n    float v7 = linearstep(24.0, 25.0, tm);\n    float a7 = linearstep(26.0, 27.0, tm);\n    \n    float v8 = linearstep(28.0, 29.0, tm);\n    float a8 = linearstep(30.0, 31.0, tm);\n    \n    float degs = mix(0., 360./8.,v1+v2+v3+v4+v5+v6+v7+v8);\n    float degx = mix(0., 360./8.,a1+a2+a3+a4+a5+a6+a7+a8);\n    \n    // mix downs\n    txa = degs;\n    txx = degx;\n    \n    rotB = r2(degs*PI/180.);\n    rotA = r2(degx*PI/180.);\n    \n    spin = r2(-T*.06);\n\n    // Normalized pixel coordinates -1 to 1\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 C = vec3(0.);\n\tvec3 FC = gethue(10.3);\n    vec3 lp = vec3(0.,0.,0.),\n         ro = vec3(0.,0.,zoom);\n         ro = getMouse(ro);\n\n    vec3 rd = camera(lp, ro, uv);\n    vec3 t = marcher(ro,rd, 256);\n    \n    float m = t.y;\n    float o = t.z;\n    // Standard shading procedures\n    // yah dif - p and n - dif yah\n    if(t.x<MAXDIST) {\n        vec3 p = ro + rd * t.x,\n             n = getNormal(p, t.x);\n        vec3 light1 = vec3(0,25.,-15.0),\n             light2 = vec3(0,25.,15.0);\n        float dif  = clamp(dot(n,normalize(light1-p)),0. , 1.);\n              dif += clamp(dot(n,normalize(light2-p)),0. , 1.);\n        vec3 h = (m==1.) ? getColor(m,o) : FC;      \n        C += dif* (ao (0.5,p,n) + ao(.05,p,n))*h*vec3(2.);\n    } else {\n        C += FC;\n    }\n    // Background - I enjoy the slight motion stuff\n    vec2 dv = uv+vec2(T*.041,-T*.023);\n    float cir = circle(fract(dv*12.),vec2(0.5),.34,.03);\n    cir += circle(fract(dv*12.),vec2(0.5),.45,.06);\n    vec3 cirx = mix(FC,gethue(14.3),cir);\n    float dt = smoothstep(.2,.65,distance(uv,vec2(0.))*.75);\n    cirx = mix(FC,cirx,dt*.25);\n    // Fog / Blending\n    C = mix( C, cirx, 2.-exp(-.000125*t.x*t.x*t.x));\n    // add back glow\n    // Output to screen\n    C *=vec3(texture(iChannel0,uv/.23).x);\n    C += vec3(glw*.25)*FC;\n   \n    O = vec4(pow(C, vec3(0.4545)),1.0);\n  O.xyz*=pow(circle2*col*10., vec3(1.0 / 1.2)) / colorRange;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}