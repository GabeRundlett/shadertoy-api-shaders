{
    "Shader": {
        "info": {
            "date": "1543604466",
            "description": "this is very slow, but it works mostly.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltyfRW",
            "likes": 5,
            "name": "many circles accurate distance",
            "published": 3,
            "tags": [
                "distance"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 541
        },
        "renderpass": [
            {
                "code": "//#define showchanges\n\nvec4 findcircle( ivec2 p )\n{\n\tvec4 s = texelFetch( iChannel0, ivec2(mod(vec2(p),256.0)), 0);\n    //radius\n    s.z = s.z*0.3+0.4;\n    //position\n    s.xy = 0.5 + 0.5*sin( iTime*s.xy + 6.2831*s.xy );\n    //s.w doesn't do anything yet\n    s.w = sign(s.w-0.5);\n    return s;\n}\n\nfloat de(vec2 p) {\n    float len = 999.9;\n    ivec2 fp = ivec2(floor(p));\n\n    for (int i = -2; i < 2; i++) {\n        for (int j = -2; j < 2; j++) {\n            vec4 s = findcircle(fp+ivec2(i,j));\n            s.xy += vec2(fp+ivec2(i,j));\n\n            len = min(len, length(p-s.xy)-s.z);\n        }\n    }\n\n    return len;\n}\n\nfloat de2(vec2 p) {\n    float len = 999.9;\n    ivec2 fp = ivec2(floor(p));\n\n    for (int i = -2; i < 2; i++) {\n        for (int j = -2; j < 2; j++) {\n            vec4 s = findcircle(fp+ivec2(i,j));\n            s.xy += vec2(fp+ivec2(i,j));\n\n            len = min(len, dot(p-s.xy,p-s.xy)-s.z*s.z);\n        }\n    }\n\n    return len;\n}\n\nfloat crescent(vec2 p) {\n    \n    float len = de(p);\n\n    if (len < 0.0) {\n        float len2 = 999.0;\n        float overwrite = 0.0;\n        ivec2 fp = ivec2(floor(p));\n        for (int i0 = -2; i0 < 2; i0++) {\n            for (int j0 = -2; j0 < 2; j0++) {\n                ivec2 fp0 = fp+ivec2(i0,j0);\n                vec4 s0 = findcircle(fp0);\n                s0.xy += vec2(fp0);\n\n                vec2 p2 = p-s0.xy;\n\n                for (int i1 = -2; i1 < 2; i1++) {\n                    for (int j1 = -2; j1 < 2; j1++) {\n                        if (i0!=i1||j0!=j1) {\n                            ivec2 fp1 = fp+ivec2(i1,j1);\n\n                            vec4 s1 = findcircle(fp1);\n\n                            s1.xy += vec2(fp1);\n\n                            s1.xy -= s0.xy;\n\n                            float d = length(s1.xy);\n\n                            if (d > 0.0) {\n                                float a = (s0.z*s0.z - s1.z*s1.z + d*d) / (2.0 * d);\n\n                                if (a < s0.z) {\n                                    float b = sqrt(s0.z*s0.z-a*a);\n\n                                    vec2 n = normalize(s1.xy);\n                                    vec2 nt = vec2(n.y,-n.x);\n\n                                    vec2 corner = a*n-b*nt;\n                                    vec2 q = p2-corner;\n\n                                    vec2 n0 = d*(corner-s1.xy);\n                                    n0 = vec2(n0.y,-n0.x);\n\n                                    vec2 n1 = d*corner;\n                                    n1 = vec2(-n1.y,n1.x);\n\n                                    if (abs(de2(corner+s0.xy))<0.001) {\n                                        if (dot(q,q) < len2) {\n                                            overwrite = max(dot(q,n0),dot(q,n1));\n                                            len2 = dot(q,q);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (overwrite < 0.0) {\n            len = -sqrt(len2);\n            #ifdef showchanges\n            len = -len;\n            #endif\n        }\n    }\n    return len;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = 2.0;\n    vec2 uv = scale*(fragCoord*2.0-iResolution.xy)/iResolution.y-2.0;\n    \n    float len = crescent(uv)/scale;\n\n    //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n    //this is a bit different, i wanted the border to be resolution independent\n    vec3 col = pow(vec3(1.0) - sign(len)*vec3(0.1,0.4,0.7),vec3(2.0));\n    col *= 1.0 - exp(-iResolution.y*0.01*abs(len));\n    col *= pow(0.8 + 0.2*cos(iResolution.y*0.6*abs(len)),2.0);\n    col = mix( col, vec3(1.0), max(1.0-abs(len)*iResolution.y*0.4,0.0));\n\n    fragColor = vec4(col, 1.0);\n\n    // squareroot for 2.0 gamma\n    fragColor = sqrt(fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}