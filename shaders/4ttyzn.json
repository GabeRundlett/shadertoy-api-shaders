{
    "Shader": {
        "info": {
            "date": "1533109230",
            "description": "This shader shows how to use the Cubemap pass to generate a cubemap texture. Caching is totally optional, you can regenerate the cubemap every frame if you want so. And you can also apply mipmpping to them :)\n",
            "flags": 0,
            "hasliked": 0,
            "id": "4ttyzn",
            "likes": 37,
            "name": "Example - mainCubemap",
            "published": 3,
            "tags": [
                "3d",
                "cubemap",
                "dynamic",
                "maincubemap"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 2106
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// This shader shows how to use the Cubemap pass to generate, and cacache, a cubemap\n// texture. Caching is totally optional, you can regenerate the cubemap every frame\n// if you want so.\n//\n// The cubemap is computed in the previous pass.\n\n\nfloat map( vec3 p )\n{\n\tvec3 q = vec3( length(p.xz)-2.0, p.y, mod(0.1*iTime + 6.0*atan(p.z,p.x)/3.14,1.0)-0.5 );\n\n    float d1 = length(p) - 1.0;\n    float d2 = length(q) - 0.2;\n\t\n\treturn min(d1,d2);\n}\n\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float precis = 0.001;\n\tconst float maxt = 9.0;\n\n    float t = 0.0;\n    for( int i=0; i<200; i++ )\n    {\n\t    float h = map( ro+rd*t );\n        if( h<precis || t>maxt ) break;\n        t += h;\n    }\n\n    if( t>maxt ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2  eps = vec2(0.001,0.0);\n    return normalize( vec3( map(pos+eps.xyy) - map(pos-eps.xyy),\n                            map(pos+eps.yxy) - map(pos-eps.yxy),\n                            map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\t\n    // camera\n\tfloat an1 = 0.2*iTime;\n\tfloat an2 = 1.45 + 0.1*sin(2.2+iTime*0.11);\n    vec3 ro = 3.5*normalize(vec3(sin(an2)*cos(an1), cos(an2)-0.2, sin(an2)*sin(an1)));\n\n    vec3 ww = normalize(vec3(0.2,0.0,0.0) - ro);\n    vec3 uu = normalize(cross( ww, vec3(0.0,1.0,0.0) ));\n    vec3 vv = normalize(cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n    // background\n    vec3 col = texture( iChannel0, rd ).xyz;\n\t\n    \n    float lod = 9.0*(0.5+0.5*sin(iTime*2.0));\n    \n    // raymarch\n    float t = intersect(ro,rd);\n    if( t>0.0 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd,nor);\n\n        float occ = 0.5+0.5*nor.y;\n\n\t\t// reflection occlusion\t\t\n\t\tt = intersect(pos+nor*0.001,ref);\n\t\tif( t<0.0 )\n\t\t{\n\t\t    col = occ*textureLod( iChannel0, ref, lod ).xyz;\n\t\t}\n        else\n        {\n        \tpos = pos + t*ref;\n            nor = calcNormal(pos);\n\t\t    col = occ*texture( iChannel0, nor, lod ).xyz*(0.5+0.5*nor.y);\n        }\n    }\n    \n    col = sqrt(col);\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// This shader shows how to use the Cubemap pass to generate and cacache,\n// a cubemap texture. Caching is totally optional, you can regenerate the \n// cubemap every frame if you want so.\n//\n// The signature of the cubemap renderer is:\n//\n// void mainCubemap( out vec4 fragColor,  in vec2 fragCoord, \n//                    in vec3 fragRayOri, in vec3 fragRayDir )\n//\n// where fragRayOri is the center of the cubemap - (0,0,0) by default,\n// and fragRayDir is the ray direction for a given pixel\n\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return -1.0+2.0*mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat map( in vec3 q )\n{\n    float h = q.y;\n\n    q *= 0.01*vec3(0.5,1.0,0.5);\n    \n\tfloat f;\n    f  = 0.500000*abs(noise( q )); q = q*2.02;\n    f += 0.250000*abs(noise( q )); q = q*2.03;\n    f += 0.125000*abs(noise( q )); q = q*2.01;\n    f += 0.062500*abs(noise( q )); q = q*2.02;\n    f += 0.031250*abs(noise( q )); q = q*2.03;\n  //f += 0.015625*abs(noise( q ));\n    f = -1.0 + 2.0*f;\n    \n    f = mix( f, -0.1, 1.0-smoothstep( h, 50.0, 60.0 ));\n    f = mix( f, -0.1, 1.0-smoothstep( h, 250.0, 300.0 ));\n    f += 0.17;\n\n    return f;\n}\n\n\nvec3 sundir = normalize( vec3(-1.0,0.5,1.0) );\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol )\n{\n\tvec4 sum = vec4(0.0);\n\n\tfloat t = (50.0-ro.y)/rd.y;\n    \n\tif( t>0.0 )\n    {\n        for(int i=0; i<512; i++ )\n        { \n            vec3  pos = ro + t*rd;\n            float den = map( pos );\n            if( den>0.001 )\n            { \n                // lighting\n                float dif = clamp( (den - map(pos+50.0*sundir))*1.0, 0.0, 1.0 ); \n                vec3 lin = vec3(0.5,0.7,0.9)*0.5 + vec3(1.0, 0.7, 0.5)*dif*5.0;\n                vec4 col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.1,0.2,0.3), sqrt(clamp(den,0.0,1.0) )), den );\n                col.xyz *= lin;\n                col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.0005*t) );\n                col.a *= 0.1;\n                // front to back blending    \n                col.rgb *= col.a;\n                sum = sum + col*(1.0-sum.a);\n                // early skip\n                if( sum.a > 0.99 || pos.y>300.0) break;\n            }\n            t += 2.0;\n        }\n    }\n    \n    return clamp( sum, 0.0, 1.0 );\n}\n\n\nvoid mainCubemap( out vec4 fragColor,  in vec2 fragCoord, \n                  in vec3  fragRayOri, in vec3 fragRayDir )\n{\n    // cache\n    if( iFrame>1 )\n    {\n        discard;\n    }\n    \n    //---------------------------------\n    \n    // dome    \n    vec3 col = vec3(0.5,0.7,0.8) - max(0.0,fragRayDir.y)*0.4;\n    \n    // sun\n    float s = pow( clamp( dot(fragRayDir,sundir),0.0,1.0),32.0 );\n    col += s*vec3(1.0,0.7,0.4)*3.0;\n\n    // ground\n    float t = (-5.0-fragRayOri.y)/fragRayDir.y;\n    if( t>0.0 )\n    {\n        vec3 pos = fragRayOri + t*fragRayDir;\n        \n        vec3 gcol = vec3(0.2,0.1,0.08)*0.9;\n        \n        float f = 0.50*noise( pos );\n              f+= 0.25*noise( pos*1.9 );\n        gcol *= 0.5 + 0.5*f;\n\n        col = mix( gcol, col, 1.0-exp(-0.0005*t) );\n    }\n\n\n    // clouds\n    vec4 res = raymarch( fragRayOri, fragRayDir, col );\n    col = col*(1.0-res.w) + res.xyz;\n\n    \n    fragColor = vec4( col, 1.0 );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}