{
    "Shader": {
        "info": {
            "date": "1511061765",
            "description": "A lakeside fireworks display. Now with music!. Best viewed in full-screen.",
            "flags": 32,
            "hasliked": 0,
            "id": "MtsBRH",
            "likes": 51,
            "name": "Lakeside",
            "published": 3,
            "tags": [
                "explosion",
                "fluid",
                "fireworks"
            ],
            "usePreview": 0,
            "username": "TimoKinnunen",
            "viewed": 1992
        },
        "renderpass": [
            {
                "code": "// Lakeside by Timo Kinnunen 2017\n//\n// Based on https://www.shadertoy.com/view/llXfRn\n\n// Created by Robert Schuetze - trirop/2017\n// Modified by Ulysse Vimont - Ultraviolet/2017\n// Modified by Action/2017\n// Modified by Timo Kinnunen 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define colorBot vec3(0.16, 0.54, 0.71)\n#define colorMid vec3(0.34, 0.12, 0.04)\n#define colorTop vec3(0.02, 0.16, 0.39)\n#define exGain 5\n#define exOffset 20\n#define wpGain 10\n#define wpOffset 15\n\n//#define SHOW_FREQUENCY\n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p,n)+ distanceFromOrigin;\n}\nuint hash12_xor_int(uint x, uint y) {\n\n\tuint W0 = 0x3504f333u;   // 3*2309*128413\n\tuint W1 = 0xf1bbcdcbu;   // 7*349*1660097\n\tuint M = 741103597u;    // 13*83*686843\n\n\tx *= W0;   // x' = Fx(x)\n\ty *= W1;   // y' = Fy(y)\n\n\t//note: hash2-improvement from MBR\n\t//x += W1;   // some odd constant\n\t//y += W0;   // some odd constant\n\n\tx ^= y;    // combine\n\tx *= M;    // MLCG constant\n\n\t//note: murmur-like finalizer, suggestion: https://twitter.com/funny_falcon/status/923270464394481664\n\tx ^= x>> 16;\n\tx *= M;\n\tx ^= x>> 16;\n\n\treturn x;\n}\nfloat hash12_xor_float(vec2 seed) {\n\tuint hi = hash12_xor_int(uint(int(seed.x)),uint(int(seed.y)));\n\treturn (float(hi)* (1.0/ 4294967296.0));\n}\nvec3 cubic(vec3 x) {\n\treturn x* x* (3.0- 2.0* x);\n}\nfloat cubic(float x) {\n\treturn x* x* (3.0- 2.0* x);\n}\nfloat cubicpulse(float c, float w, float x) {\n    x = abs(x - c);\n    return (x >= w) ? 0.0 : 1.0 - cubic(x/w);\n}\nfloat csstep(float c, float w1, float w2, float x) {\n    x = abs(x - c) - w1;\n    return (x >= w2) ? 0.0 : (x <= 0.0) ? 1.0 : 1.0 - cubic(x/w2);\n}\nvec3 csstep(vec3 c, vec3 w1, vec3 w2, vec3 x) {\n    return vec3(csstep(c.x,w1.x,w2.x,x.x),csstep(c.y,w1.y,w2.y,x.y),csstep(c.z,w1.z,w2.z,x.z));\n}\nvec3 hsv2rgb_smooth(vec3 c) {\n\treturn c.z* mix(vec3(1),cubic(clamp(abs(mod(c.x* 6.+ vec3(0,4,2),6.)- 3.)- 1.,0.,1.)),c.y);\n}\nvec3 ApplyTonemap(vec3 vLinear, float kExposure, float kWhitePoint) {\n\treturn log2(1.0+ vLinear* kExposure* 0.75)/ log2(1.0+ kWhitePoint);\n}\nfloat bluenoise12(vec2 frag) {\n\tivec4 magic = ivec4(3* 2309* 128413,7* 349* 1660097,0,13* 83* 686843);\n\tivec2 xy = ivec2(frag)* magic.xy;\n\tivec4 xy1 = xy.xyxy- magic.xyzz+ magic.zzxy;\n\n\tivec4 tl = magic.w* ((xy1.xxxz- magic.xxzx)^ (xy1.ywww+ magic.zzyy));\n\tivec4 br = magic.w* ((xy1.zzzx+ magic.xxzz)^ (xy1.wyyy- magic.zzyy));\n\tivec4 cr = magic.w* ((xy1.xzxz- magic.xxzz+ magic.zzxx)^ (xy1.ywwy- magic.zzyy+ magic.yyzz));\n\tivec4 bo = magic.w* (xy1^ xy.yxyx);\n\tivec4 co = magic.w* (xy1.xzzx^ xy1.wwyy);\n\tint self = magic.w* (xy.x^ xy.y);\n\tfloat total =\n\t\t((3.0/64.0)/ 4294967296.0)*dot(vec4(tl)+vec4(br),vec4(1))+\n\t\t((4.0/64.0)/ 4294967296.0)*dot(vec4(cr),vec4(1))-\n\t\t((4.0/64.0)/ 4294967296.0)*dot(vec4(co),vec4(1))-\n\t\t((12.0/64.0)/ 4294967296.0)*dot(vec4(bo),vec4(1))+\n\t\t((24.0/64.0)/ 4294967296.0)*float(self);\n\ttotal *= 1.7578125;\n\ttotal += 0.5;\n\treturn total;\n}\nfloat or3(vec3 v) {\n    return v.x * v.y * v.z - v.y * v.z - v.z * v.x - v.x * v.y + v.x + v.y + v.z;\n}\nvoid mainImage( out vec4 fragColor, in vec2 frag) {\n\tfloat cutoff = 0.3;\n\tvec3 plane1N = vec3(0,1,0);\n\tvec3 plane2N = vec3(0,0,-1);\n\tvec2 r = iResolution.xy;\n\tvec3 ro = vec3(0);\n\tvec3 rd = normalize(vec3((frag- r* 0.5)/ r.y,1));\n\tbool below = frag.y< r.y* cutoff;\n\tfloat belowAmount = max(0.0,cutoff- frag.y/ r.y)/ cutoff;\n\tfloat aboveAmount = max(0.0,frag.y/ r.y- cutoff)/ (1.- cutoff);\n\tfloat horizonAmount1 = (1.0- aboveAmount)* (1.0- belowAmount);\n\tfloat horizonAmount2 = pow(horizonAmount1,4.0);\n\tfloat horizonAmount3 = pow(horizonAmount2,4.0);\n\tfloat horizonAmount4 = pow(horizonAmount3,2.0);\n\n\tfloat wave = 0.0;\n\tfor(int i = 0; i< 15; i++) {\n\t\tvec3 p = ro+ rd* wave;\n\t\tfloat dist = min(fPlane(p,plane1N,cutoff),fPlane(p,plane2N,cutoff/ (.5- cutoff)));\n\t\tif(abs(dist)< 0.0001) {\n\t\t\tbreak;\n\t\t}\n\t\twave += dist;\n\t}\n\tvec2 seed = ro.xz+ wave* rd.xz;\n\tseed.y += float(iFrame>> 9);\n\tseed.y += float(iFrame& 0x1FF)/ 512.0;\n\tseed *= 128.0;\n\tfloat rnd = mix(\n\tmix(hash12_xor_float(seed+ vec2(0,0)),hash12_xor_float(seed+ vec2(0,1)),fract(seed.y)),\n\tmix(hash12_xor_float(seed+ vec2(1,0)),hash12_xor_float(seed+ vec2(1,1)),fract(seed.y)),fract(seed.x));\n\trnd += sin(-iTime* 0.0625+ wave);\n\tvec2 C = vec2(frag.x* (1.- 10./ r.x)+ 5.,abs(frag.y- cutoff* r.y));\n\tC.y *= mix(1.,0.9/ (1.- cutoff),aboveAmount);\n\tC.x += sin(radians(360.0)* rnd)* 4.0* belowAmount;\n\n\tvec2 uv = (C- r* 0.5)/ r.y;\n\n\tfloat concentration = texture(iChannel0,C/ r).z;\n\tfloat temperature = texture(iChannel1,C/ r).w;\n    float pressure = texture(iChannel0,C/ r).w;\n\ttemperature = abs(temperature);\n\n\tfloat boom1 = smoothstep(-60.0,-15.0,-abs(45.- float(iFrame% 200)));\n\tfloat boom2 = smoothstep(-120.0,-30.0,-abs(100.- float(iFrame- (iFrame& 0xFFFFFE00))));\n\n\tfloat bass = bassImpact(iChannel2);\n    float treble = trebleImpact(iChannel2);\n    boom1 = clamp(.8*boom1+.25*treble,0.,1.);\n    boom2 = clamp(.8*boom2+.5*bass,0.,1.);\n    \n    \n\tvec3 bkg = colorMid;\n\tbkg = mix(bkg,colorTop,aboveAmount);\n\tbkg = mix(bkg,colorBot,belowAmount);\n\n\tbkg =\n\tcolorTop*aboveAmount+\n\tcolorBot*belowAmount+\n\tcolorMid*(horizonAmount2+horizonAmount3+horizonAmount4);\n\tvec3 boom1Col = vec3(.9,.7,.3);\n\tvec3 boom2Col = vec3(.9,.7,.3);\n\tboom1Col = hsv2rgb_smooth(vec3(float(iFrame/ 200)* .3,1,1));\n\tboom2Col = hsv2rgb_smooth(vec3(float(iFrame>> 9)* .7,1,1));\n\tbkg += boom1Col* 0.75* (horizonAmount2+horizonAmount3+horizonAmount4)* boom1;\n\tbkg += boom2Col* 1.25* (horizonAmount1+horizonAmount2+horizonAmount3)* boom2;\n\tbkg *= .75+ .25* (belowAmount* belowAmount+ aboveAmount* aboveAmount);\n\tbkg *= 1.0- 0.5* horizonAmount1* horizonAmount2;\n\tbkg *= 1.0-ceil(belowAmount)* 0.0625;\n\n\tvec3 con = bkg- vec3(concentration* 0.5);\n\tvec3 col = con+ (.95*temperature*vec3(.99,.498,.197)+pressure*(pressure*vec3(1.5,1.4,1.3)+vec3(.4,.15,-.75)));\n    //col = 1.0-col;\n\n\tfloat exposure = 0.1*(float(exOffset)+float(exGain)*(boom1+ boom2));\n\tfloat whitepoint = 0.1*(float(wpOffset)+float(wpGain)*(boom1+ boom2));\n\tcol = ApplyTonemap(col,exposure,whitepoint);\n\tcol += bluenoise12(frag*iTime)/64.0;\n\n\t/*\n\t //----------------------------\n\t // visualize pressure\n\t //col = 0.1*vec3(pressure,-pressure, 0.0);\n\n\t float pl = texture(iChannel3,(C-vec2(-1, 0))/r).x;\n\t float pr = texture(iChannel3,(C-vec2( 1, 0))/r).x;\n\t float pt = texture(iChannel3,(C-vec2( 0,-1))/r).x;\n\t float pb = texture(iChannel3,(C-vec2( 0, 1))/r).x;\n\t vec2 grad = vec2(pr-pl,pb-pt);\n\t //grad = vec2(dFdx(pressure), dFdy(pressure));\n\t col = vec3(0.2+0.8*max(dot(normalize(vec3(0.0, 1.0, 1.0)), normalize(vec3(grad.x, .4, grad.y))), 0.0));\n\t */\n\n    \n#ifdef SHOW_FREQUENCY\n    vec3 sound0 = texelFetch(iChannel2, ivec2(frag), 0).zyw;\n    vec3 sound2 = texelFetch(iChannel2, ivec2(frag.x,frag.y+1.0), 0).zyw;\n    vec3 sound4 = texelFetch(iChannel2, ivec2(frag.x,frag.y+2.0), 0).zyw;\n    float cut = 0.03125+0.015625*0.015625*1.;\n    vec3 ds0 = smoothstep(0.0, cut, (sound0.yxx-sound0.zzy)*sound0.x);\n    vec3 ds2 = smoothstep(0.0, cut, (sound2.yxx-sound2.zzy)*sound2.x);\n    vec3 ds4 = smoothstep(0.0, cut, (sound4.yxx-sound4.zzy)*sound4.x);\n    col = mix(col, sound0, smoothstep(0.0009375,0.005,dot(sound0,vec3(1))));\n    ds0 *= clamp(3.0-4.0*dot(normalize(ds0),normalize(vec3(0,.5,1))),0.,1.);\n    ds0 = vec3(dot(ds0,vec3(.25,.65725,.09375)));\n    ds2 *= clamp(3.0-4.0*dot(normalize(ds2),normalize(vec3(0,.5,1))),0.,1.);\n    ds2 = vec3(dot(ds2,vec3(.25,.65725,.09375)));\n    ds4 *= clamp(3.0-4.0*dot(normalize(ds4),normalize(vec3(0,.5,1))),0.,1.);\n    ds4 = vec3(dot(ds4,vec3(.25,.65725,.09375)));\n    vec3 ds = vec3(ds0.x*step(0.999,ds0.x+ds0.y+ds0.z),\n                   ds2.x*step(0.999,ds2.x+ds2.y+ds2.z),\n                   ds4.x*step(0.999,ds4.x+ds4.y+ds4.z));\n\n    \n    col = clamp(col,0.,1.);\n\n\n    ivec2 bassUV = ivec2(10,7.*32.+31.);\n    float bass0 = .000085, bass1 = .5000095;\n\n    ivec2 trebleUV1 = ivec2(.94*512., 0.*32.+0.);\n    ivec2 trebleUV2 = ivec2(.94*512., 1.*32.+15.);\n    float treble1 = .25, treble0 = treble1*.0625;\n    \n    vec3 sound10 = texelFetch(iChannel2, ivec2(frag.x*.25,0.*32.+mod(iTime,31.)), 0).yzw;\n    vec3 sound20 = texelFetch(iChannel2, ivec2(frag.x*.25,bassUV.y), 0).yzw;\n    vec3 sound21 = texelFetch(iChannel2, ivec2(frag.x,trebleUV1.y), 0).yzw;\n    vec3 sound22 = texelFetch(iChannel2, ivec2(frag.x,trebleUV2.y), 0).yzw;\n    vec3 m0 = step(256.,frag.y)*smoothstep(0./256.,4.0/256.,sound10-(frag.y-256.)/128.);\n    m0 = csstep(sound10,vec3(2./256.),vec3(4.0/256.),vec3(frag.y-0.)/64.);\n    col = mix(col,vec3(0,1,0)*m0.z+vec3(1,0,0)*m0.y+vec3(0,0,1)*m0.x,or3(m0));\n    m0 = csstep(sound20,vec3(2./256.),vec3(4.0/256.),vec3(frag.y-256.)/64.);\n    col = mix(col,m0,or3(m0));\n    vec3 m3 = csstep(clamp(vec3(sound22.z-sound21.z-treble0,sound22.z-treble0,sound21.z-treble0),0.,1.),vec3(2./256.),vec3(4.0/256.),vec3(frag.y-128.)/128.);\n    col = mix(col,vec3(0,0,1)*m3.z+vec3(1,0,0)*m3.y+vec3(0,1,0)*m3.x,or3(m3));\n#endif\n\tfragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Runge-Kutta 4 backward advection\n\n// Note: Components are attributed as follow:\n//   - x : velocity field (X)\n//   - y : velocity field (Y)\n//   - z : concentration field\n//   - w : temp\n// The advection of the velocity field makes it non divergent-free, hence the next steps.\n\n#define h 2.\n\nvec2 RK4(vec2 p) {\n\tvec2 r = iResolution.xy;\n\tvec2 k1 = texture(iChannel0,p/ r).xy;\n\tvec2 k2 = texture(iChannel0,(p- 0.5* h* k1)/ r).xy;\n\tvec2 k3 = texture(iChannel0,(p- 0.5* h* k2)/ r).xy;\n\tvec2 k4 = texture(iChannel0,(p- h* k3)/ r).xy;\n\treturn h/ 3.* (0.5* k1+ k2+ k3+ 0.5* k4);\n}\nfloat trajectory(float x, float x_0, float y_0) {\n\treturn (2.- (x/ x_0))* (x/ x_0)* y_0;\n}\nfloat sanity(float x) {\n\treturn x== x&& x< 2000.0&& x> -2000.0? x: 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 C) {\n\tvec2 r = iResolution.xy;\n\tvec2 uv = ((C- r* 0.5)/ r.y);\n\n\t// advection\n\tvec4 buf = texture(iChannel0,(C- RK4(C))/ r);\n\tvec2 v = buf.xy;\n\tfloat d = buf.z;\n\tfloat t = buf.w;\n\tbool solid = t< 0.? true: false;\n\n\t// set boundary velocity\n\tif(C.x< 2.|| C.x> r.x- 2.) {\n\t\tv.x = .0;\n\t\tv.y *= .5;\n\t}\n\tif(r.y- 2.< C.y|| C.y< 2.) {\n\t\tv.y = .0;\n\t\tv.x *= .5;\n\t}\n\n\t// The smoke cools over time and starts to fall\n\tt *= 1.0- 0.002;\n\tt = max(0.,t);\n\n\tif((iFrame/ 100)% 2!= 1) {\n\t\tint pos = ((iFrame/ 100)+ 1)% int(r.x/ 50.0);\n\t\tvec2 mm = (vec2(float(pos)* 50.0,9.5)- r* 0.5)/ r.y;\n\t\tif(length(uv- mm)* r.y< 9.0) {\n\t\t\tfloat q = length(uv- mm)* 50.0/ 450.0* min(r.y,450.0);\n\t\t\tq = sqrt(1.0- q* q);\n\t\t\td += q;\n\t\t\tt += q;\n\t\t}\n\t}\n\n\tfloat tn = float((iFrame>> 9)+ 28);\n\tfloat tf = float(iFrame- (iFrame& 0xFFFFFE00));\n\tvec2 eo1 = vec2(mod(tn* 150.0,r.x),5.0);\n\tvec2 eo2 = vec2(mod(tn* 150.0+ .75* r.x,r.x),5.0);\n\tfloat boomDir1 = 45.0+ fract(tn* 123.456789)* 135.0;\n\tfloat boomDir2 = 45.0+ fract(tn* 1234.56789)* 135.0;\n\tboomDir2 = min(176.0,boomDir2+ 0.5* boomDir1);\n\tboomDir1 = max(4.0,boomDir2- boomDir1);\n\tfor(float ang = 4.0; ang<= 176.0; ang += 6.0) {\n\t\tfloat a = mix(boomDir1,boomDir2,ang/ 180.0);\n\t\tvec2 hp = vec2(cos(radians(a)),sin(radians(a)));\n\t\tfloat x = hp.x* tf* (2.0+ 0.0625* sin(ang* 10.));\n\t\tfloat y = trajectory(x,hp.x* 300.0,hp.y* 300.0);\n\t\tvec2 mm1 = (vec2(-x*mix(1.0,0.5,tf/512.0),y*0.97)+ eo1- r* 0.5)/ r.y;\n\t\tvec2 mm2 = (vec2(+x*mix(1.0,0.5,tf/512.0),y*0.99)+ eo2- r* 0.5)/ r.y;\n\t\tfloat fade = smoothstep(512.0,200.0,tf* 0.5* (3.0+ sin(tn* 39.61+ a* 51.3)));\n\t\tfloat block1 = float(length(uv- mm1)* r.y< 2.0* fade);\n\t\tfloat block2 = float(length(uv- mm2)* r.y< 2.0* fade);\n\t\tfloat q1 = length(uv- mm1)* 1.0;\n\t\tfloat q2 = length(uv- mm2)* 1.0;\n\t\tq1 = sqrt(1.0- q1* q1* block1);\n\t\tq2 = sqrt(1.0- q2* q2* block2);\n\t\tq1 *= 0.75+ 0.25* sin(tf* .125+ ang* .0625)+ 0.25* sin(ang* 53.9);\n\t\tq2 *= 0.75+ 0.25* sin(tf* .125+ ang* .0625)+ 0.25* sin(ang* 53.9);\n\t\tq1 *= fade* (0.5+ 0.75* sin(eo1.x))* block1;\n\t\tq2 *= fade* (0.5+ 0.75* sin(eo2.x))* block2;\n\t\td += q1+ q2;\n\t\tt += q1+ q2;\n\t}\n    if(abs(10.5-C.y)<10.0) {\n        float num = floor(r.x/10.0);\n        float offset = mod(r.x,10.0)*0.;\n        float freq = floor((C.x-offset)/10.0);\n        vec2 closest = vec2(freq*10.0+5.0+offset, 10.5);\n        freq = mod(freq,512.);\n        //if(distance(C, closest*vec2(1,.5))-3.0 < 0.0) \n        {\n            float boom1 = smoothstep(-60.0,-15.0,-abs(45.- float(iFrame% 200)));\n            float boom2 = smoothstep(-120.0,-30.0,-abs(100.- float(iFrame- (iFrame& 0xFFFFFE00))));\n            \n            float q = mod(freq + iTime*8.,256.);\n\n            float bass = bassImpact(iChannel2);\n            float treble = trebleImpact(iChannel2);\n            boom1 = clamp(.19*boom1+.95*treble,0.,1.);\n            boom2 = clamp(.18*boom2+.95*bass,0.,1.);\n\n            vec3 sound10 = texelFetch(iChannel2, ivec2(freq,2.*32.+6.), 0).yzw;\n            float source = smoothstep(0.25,-0.25,distance(C, closest)-3.0);\n            source *= smoothstep(.0625,.125,sound10.y-sound10.x);// *(1.-(1.-boom1)*(1.-.0*boom2));\n            //source *= min(1.0,boom1*.0 + boom2);\n            \n            boom1 *= float(freq-mod(0.0+1.0*floor(iTime* 10.25),num)==0.);\n            boom2 *= float(freq-mod(0.0+1.0*floor(iTime*-14.25),num)==0.);\n\n\n            float extra1 = boom1*step(0.3,boom1*boom1)*.25;\n            float extra2 = boom2*step(0.5,boom2*boom2);\n\n            extra1 *= step(3.,C.y)*smoothstep(0.25,-0.25,distance(C*vec2(1,.5)+closest*vec2(0,.5), closest)-8.0);\n\t\t\td += 80.*extra1;\n\t\t\tt += 120.*extra1;\n            v.y += 55.0*extra1;\n            v.x += (C.x-closest.x)*0.5*extra1;\n            extra2 *= step(3.,C.y)*smoothstep(0.25,-0.25,distance(C*vec2(1,.5)+closest*vec2(0,.5), closest)-8.0);\n\t\t\td += 75.*extra2;\n\t\t\tt += 125.*extra2;\n            v.y += 50.0*extra2;\n            v.x += (C.x-closest.x)*0.5*extra2;\n            source *= .5*smoothstep(0.25,-0.25,distance(C, closest)-3.0);\n            d += 1.24*source;\n\t\t\tt += 1.25*source;\n            v.y += -.125*source;\n            v.x += -(C.x-closest.x)*0.125*source;\n        }\n\t}\n\t// Open sides\n\tif(C.x< 2.|| C.x> r.x- 2.) {\n\t\td = 0.;\n\t\tt = 0.;\n\t}\n\t// Open top\n\tif(r.y- 20.< C.y) {\n\t\td = 0.;\n\t\tt = 0.;\n\t}\n\tt = solid? -abs(t): abs(t);\n\tv.x = sanity(v.x);\n\tv.y = sanity(v.y);\n\td = sanity(d);\n\tt = sanity(t);\n\n\tfragColor = vec4(v,d,t);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by Robert Schuetze - trirop/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Compute divergence\n\n// Note : Divergence is the right hand side of the Poisson equation:\n//   ∇²P = ∇.U*\n\nfloat sanity(float x) {\n\treturn x== x&& x< iResolution.x&& x> -iResolution.x? x: 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 C) {\n\tvec2 r = iResolution.xy;\n\tfloat vxl = texture(iChannel0,(C- vec2(-1,0))/ r).x;\n\tfloat vxr = texture(iChannel0,(C- vec2(1,0))/ r).x;\n\tfloat vyt = texture(iChannel0,(C- vec2(0,-1))/ r).y;\n\tfloat vyb = texture(iChannel0,(C- vec2(0,1))/ r).y;\n\tfloat div = (vxl- vxr+ vyt- vyb)/ 2.;\n\tdiv = sanity(div);\n\tfragColor = vec4(div,0,0,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by Robert Schuetze - trirop/2017\n// Modified a lot by Action/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Pressure solver\n\n// Note: Pressure is the left hand side of the Poisson equation:\n//   ∇²P = ∇.U*\n// The initial guess for P is the result of the previous pass.\n//\n// Note: Not divergence free.\n\nfloat sanity(float x) {\n\treturn x== x&& x< iResolution.x&& x> -iResolution.x? x: 0.0;\n}\n\nfloat texelFetchiChannel3(float x) {\n    vec2 c = vec2(0);\n    if(x-3.>=0.) c += .010805*vec2(texelFetch(iChannel3,ivec2(x-3.,0),0).x,1);\n    if(x-2.>=0.) c += .074929*vec2(texelFetch(iChannel3,ivec2(x-2.,0),0).x,1);\n    if(x-1.>=0.) c += .238727*vec2(texelFetch(iChannel3,ivec2(x-1.,0),0).x,1);\n    if(x+1.<=512.) c += .238727*vec2(texelFetch(iChannel3,ivec2(x+1.,0),0).x,1);\n    if(x+2.<=512.) c += .074929*vec2(texelFetch(iChannel3,ivec2(x+2.,0),0).x,1);\n    if(x+3.<=512.) c += .010805*vec2(texelFetch(iChannel3,ivec2(x+3.,0),0).x,1);\n    c += (1.-c.y)*vec2(texelFetch(iChannel3,ivec2(x,0),0).x,1);\n    return c.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 C) {\n\tvec2 r = iResolution.xy;\n\n\tfloat RHS_ = 0.446031937273809* texture(iChannel0,gl_FragCoord.xy/ iResolution.xy).x;\n\tfloat Pressure_ = 0.776135028354475* texture(iChannel1,gl_FragCoord.xy/ iResolution.xy).x;\n\tfloat p = RHS_+ Pressure_;\n\n\t// Open sides\n\tif(C.x< 2.|| C.x> r.x- 2.) {\n\t\tp = .0;\n\t}\n\t// Open top\n\tif(r.y- 20.< C.y) {\n\t\tp = 0.;\n\t}\n\tp = sanity(p);\n\tfragColor = vec4(p,0,0,0);\n    float row = floor(mod(C.y,32.));\n    vec4 which = vec4(floor(C.y/32.0));\n    which.yzw = mod(which.xxx,vec3(8,4,2))*vec3(.25,.5,1);\n    if(which.x < 8.0) {\n        float idx = floor(abs(mod(C.x-512.,1024.)-512.));\n        if(iFrame == 0) {\n            fragColor.yzw = texelFetch(iChannel3,ivec2(idx,0),0).xxx;\n            if(which.y<1.0) {\n            } else {\n                fragColor.yzw *= fragColor.yzw;\n            }\n            return;\n        }\n        float s0;\n\t    if(which.w < 1.0) {\n            s0 = texelFetch(iChannel3,ivec2(idx,0),0).x;\n        } else {\n\t        s0 = texelFetchiChannel3(idx);\n        }\n        vec3 s1;\n        if(row==0.0) {\n            s1 = vec3(1,0,0);\n        } else {\n            s1 = texelFetch(iChannel1, ivec2(C.x,C.y-1.0),0).yzw;\n        }\n        if(which.y<1.0) {\n            //s0*=s0;\n        } else {\n            s0*=s0;\n            s0*=s0;\n        }\n        float de = 1./(1.+row);\n        if(which.z<1.0) {\n            fragColor.yzw = vec3(min(s0,         s1.x     ),max(s0,s1.y    ),mix(s1.z,s0,de));\n        } else {\n            fragColor.yzw = vec3(min(s0,1.0-(1.0-s1.x)*.98),max(s0,s1.y*.98),mix(s1.z,s0,de));\n        }\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "music",
                        "id": 19,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by Robert Schuetze - trirop/2017\n// Modified by Action/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Gradient subtraction\n\n// Note: This allows the velocity field to be divergence-free\n\n#define tamb 0.\n#define a 0.3\n#define b 0.5\n#define gravity 1.\n\nfloat sanity(float x) {\n\treturn x== x&& x< iResolution.x&& x> -iResolution.x? x: 0.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 C) {\n\tvec2 r = iResolution.xy;\n\tfloat pl = texture(iChannel0,(C- vec2(-1,0))/ r).x;\n\tfloat pr = texture(iChannel0,(C- vec2(1,0))/ r).x;\n\tfloat pt = texture(iChannel0,(C- vec2(0,-1))/ r).x;\n\tfloat pb = texture(iChannel0,(C- vec2(0,1))/ r).x;\n\tvec2 grad = vec2(pr- pl,pb- pt)/ 2.;\n\tvec4 bufOld = texture(iChannel1,C/ r);\n\n\t// Temperature causes buoyancy against gravity. Ambient temperature is tamp.\n\t// Try to find good settings.\n\tfloat s = bufOld.z;\n\tfloat t = bufOld.w;\n\tif(t< 0.) {\n\t\tfragColor = vec4(0,0,0,t);\n\t\t;\n\t\treturn;\n\t}\n\tfloat buoyancy = (a* s- b* (abs(t)- tamb))* gravity;\n\tvec2 g = vec2(0.0,buoyancy)* 0.1;\n\n\tvec2 f = bufOld.xy- grad- g;\n\t// Open sides\n\tif(C.x< 2.|| C.x> r.x- 2.) {\n\t\ts = 0.;\n\t\tt = 0.;\n\t}\n\t// Open top\n\tif(r.y- 20.< C.y) {\n\t\ts = 0.;\n\t\tt = 0.;\n\t}\n\n\tf.x = sanity(f.x);\n\tf.y = sanity(f.y);\n\ts = sanity(s);\n\tt = sanity(t);\n\tfragColor = vec4(f,s,t);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float bassImpact(sampler2D bufferC) {\n    ivec2 bassUV = ivec2(10,7.*32.+31.);\n    float bass0 = .000085, bass1 = .5000095;\n    vec3 bassData = texelFetch(bufferC, bassUV,0).yzw;\n    float bass   = smoothstep(bass0*(1.-bassData.z),bass1*(1.-bassData.z), bassData.y-bassData.z);\n\treturn bass;\n}\n\nfloat trebleImpact(sampler2D bufferC) {\n    ivec2 trebleUV1 = ivec2(.94*512., 0.*32.+0.);\n    ivec2 trebleUV2 = ivec2(.94*512., 1.*32.+15.);\n    float treble0 = .35-.99*.2, treble1 = .4-.99*.2;\n    vec2 i2Mouse = vec2(.25,.0625);\n    treble1 = i2Mouse.x;\n    treble0 = treble1*i2Mouse.y;\n    vec3 trebleData1 = texelFetch(bufferC, trebleUV1,0).yzw;\n    vec3 trebleData2 = texelFetch(bufferC, trebleUV2,0).yzw;\n    float treble = smoothstep(treble0,treble1, trebleData1.z-trebleData2.x);\n    return treble;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}