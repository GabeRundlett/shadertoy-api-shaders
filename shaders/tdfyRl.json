{
    "Shader": {
        "info": {
            "date": "1585332389",
            "description": "potato!!!!!!",
            "flags": 40,
            "hasliked": 0,
            "id": "tdfyRl",
            "likes": 59,
            "name": "Day 99",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 1296
        },
        "renderpass": [
            {
                "code": "// All geodesic reflection functions and are from tdhooper! shadertoy.com/view/4tG3zW\n// They are in common tab! \n\n// radiual blur in this buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\tfragColor = vec4(0);\n    // Radial blur\n    float steps = 16.;\n    float scale = 0.00 + pow(dot(uvn,uvn),1.1)*0.04;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.)*2.2;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1.4/iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    \n    fragColor.b *= 0.97 + dot(uvn,uvn)*0.1;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.);\n    \n    fragColor.t *= 1.  - smoothstep(0.,1.,dot(uvn,uvn))*0.;\n    \n    \n    fragColor = pow(fragColor, vec4(0.4545));\n    \n    fragColor.b *= 1. + uv.x*0.2;\n    fragColor.g *= 1. + uv.t*0.05;\n    \n    fragColor = max(fragColor, 0.);\n    fragColor *= 1. - dot(uvn,uvn)*1.   ;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI acos(-1.)\n\n#define T true\n#define F false\n\n#define init vec2 s = vec2(0)\n#define ret return s\n#define bpm 140.\n\n#define tick (60./bpm)\n\n#define beat tick\n#define bar  beat*4.\n#define hbar  bar/2.\n#define msr  bar*4.\n#define hbeat tick/2.\n#define qbeat tick/4.\n\n\n\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\nint Type=5;\nvec3 nc,pab,pbc,pca;\nvoid initIcosahedron() {\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n\tnc=vec3(-0.5,-cospin,scospin);\n\tpab=vec3(0.,0.,1.);\n\tpbc=vec3(scospin,0.,0.5);\n\tpca=vec3(0.,scospin,cospin);\n\tpbc=normalize(pbc);\tpca=normalize(pca);\n}\n\nvec3 bToC(vec3 A, vec3 B, vec3 C, vec3 barycentric) {\n\treturn barycentric.x * A + barycentric.y * B + barycentric.z * C;\n}\n\n\n\n\nvec3 pIcosahedron(inout vec3 p, int subdivisions) {\n    p = abs(p);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    \n    if (subdivisions > 0) {\n\n        vec3 A = pbc;\n       \tvec3 C = reflect(A, normalize(cross(pab, pca)));\n        vec3 B = reflect(C, normalize(cross(pbc, pca)));\n       \n        vec3 n;\n\n\n        float d = .5;\n        \n        vec3 p1 = bToC(A, B, C, vec3(1.-d, .0, d));\n        vec3 p2 = bToC(A, B, C, vec3(1.-d, d, .0));\n        n = normalize(cross(p1, p2));\n        pReflect(p, n, 0.);\n        \n        if (subdivisions > 1) {\n\n            A = reflect(A, n);\n            B = p1;\n            C = p2;\n\n            p1 = bToC(A, B, C, vec3(.5, .0, .5));\n            p2 = bToC(A, B, C, vec3(.5, .5, .0));\n            n = normalize(cross(p1, p2));\n            pReflect(p, n, 0.);\n            \n\n\t\t\tp2 = bToC(A, B, C, vec3(.0, .5, .5));\n            p1 = bToC(A, B, C, vec3(.5, .5, .0));\n            n = normalize(cross(p1, p2));\n            pReflect(p, n, 0.);\n        }\n    }\n    \n    return pca;\n}\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\nfloat kick;\nvec4 r11(float x){return texture(iChannel0,vec2(x)/256.);}\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy) + f.xy;\n\treturn textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).x;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, pow(f.z, 0.05) );\n}\nvec3 glow = vec3(0);\n\nvec3 ro;\n#define pmod(p,x) mod(p,x) - 0.5*x\nvec2 map(vec3 p, float t){\n\tvec2 d = vec2(10e6);\n\n    \n    vec3 q = p;\n    \n    \n   \tvec3 n = pIcosahedron(p, int(1.));\n    n = pIcosahedron(p, int(1.));\n    \n    float dP = length(p.yx) - 0.01;\n    \n    p.x -= 0.12;\n    \n    n = pIcosahedron(p, int(2.));\n    \n\t\n    \n    p.z = log(p.z + 0.) - iTime*0.44;\n    \n    p.z = sin(0.5*p.z*6.28) - 0.5;\n    \n    float modD = 1.;\n    \n    float id = floor(p.z/modD);\n    \n    //p.z = pmod(p.z, modD);\n    \n    //p.z -= 0.1;\n    \n    p.x *= log(p.y)*1.;\n    //p.xz *= rot(-1.4);\n    p.x -= 0.1;\n    p.xz *= rot(-1.4);\n    \n    //p.x -= 0.4;\n    //p.y -= 0.4;\n    \n    //d.x =  length(p) - 0.44;\n    \n    \n    \n    float dc = length(p.z) - 0.06;\n    \n    \n    \n    //dc = max(dc, -abs(p.x) + 0.09);\n    dc = max(dc, -abs(p.x) + 0.7);\n    //dc = max(dc, -abs(p.y) + 0.14);\n    //dc = max(dc, -abs(p.y) + 0.44);\n    d.x =  min(d.x, dc);\n    \n    \n    d.x = abs(d.x) + 0.001;\n    \n    //vec3 c = pal(0.1, 0.5, vec3(0.9,0.2,0.1), 0.6,4.7 + t*6. + iTime + p.z*0.2);\n    //vec3 c = pal(0.4, 0.5, vec3(0.9,0.2,0.05), 1.4, t*2. + iTime + p.z*0.2);\n    vec3 c = pal(0.4, 0.5, vec3(1.4,0.9,0.3), 1.4, t*2. + iTime + p.z*0.2);\n    c = max(c, 0.);\n    vec3 ga = 0.0007/(0.1 + d.x*d.x*d.x*d.x*d.x*20000000000.) * c;\n    \n    vec3 gb = 0.0004/(0.1 + d.x*d.x*d.x*d.x*d.x*2000.) * pal(0.6,0.1, vec3(0.7,0.2,0.5),0.67,0.2);\n    \n    //glow += mix(ga,gb, smoothstep(0.,1.,length(ga)*400.));\n    glow += ga;\n    \n    d.x =  min(d.x, abs(dP) + 0.01);\n    float at = pow(abs(sin(q.z - iTime + n.y)), 200.)*smoothstep(0.,1.,length(q.z)*0.4);\n    //glow  += 0.001/(0.006 + dP*dP*dP*100.) * pal(0.5,0.5, vec3(0.7,0.2,0.5),0.67,0.2)*at;\n    \n    d.x *= 0.6;\n    \n    return d;\n}\nfloat it = 0.;\nfloat dith = 0.;\nvec2 march(vec3 ro, vec3 rd,inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e6);\n    \n    t = 0.; hit = false; p = ro;\n    \n    for(it = 0.; it < 110. + min(float(iFrame), 0.) ; it++){\n    \td = map(p,t);\n     \td.x += 0.01*pow(smoothstep(1.,0.,t*0.2), 2.5);\n        d.x *= dith;\n        t += d.x;\n    \tp = ro + rd*t;\n    }\n    \n    \n\treturn d;\n}  \n\nvec3 getRd(vec3 ro,vec3 lookAt,vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n\treturn normalize(dir + (right*uv.x + up *uv.y)*0.8);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    initIcosahedron();\n    \n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    dith = mix(0.9,1.,texture(iChannel0, 4000.*(uv + 0.5 + iTime*0.05)/256.).x);\n    uv *= 1. + dot(uv,uv)*0.2;\n    vec3 col = vec3(0);\n\n    \n    vec3 ro = vec3(0);\n    \n    \n    float sp = 0.3;\n    \n    float tt = iTime*sp ;\n    ro = vec3(cos(tt+ iMouse.x/iResolution.x*2.),sin(tt+ iMouse.y/iResolution.x*2.)*1.6,sin(tt+ iMouse.x/iResolution.x*2.))*(4.1);\n    \n    vec3 lookAt = vec3(0);\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    bool hit; float t; vec3 p;\n    vec2 d = march(ro, rd, p, t, hit);\n    \n    \n    \n    \n    \n    glow = smoothstep(0.,1.,glow*1.);\n    //glow = smoothstep(0.,1.,glow*1.);\n    col += glow;\n    \n    \n    //col -= smoothstep(0.,1.,it*0.0009)*0.8;\n    //col -= pow(smoothstep(0.,1.,it*0.0045), 10.)*2.4;\n    \n    \n    //col = mix(col, vec3(0.,0.1,0.2)*0.2,pow(smoothstep(0.,1.,t*0.2), 2.));\n    //col = mix(col, vec3(0.1,0.,0.1)*0.002,pow(smoothstep(0.,1.,t*0.1), 1.));\n    \n    \n    col = max(col, 0.);\n    col *= 9.;\n    \n    fragColor = vec4(col,1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define TT (tau*t)\n#define tt (tau*t)\n\n\n\n#define S vec2 s = vec2(0);\n#define E return s;\n\n\nfloat[] probK = float[16](0.9,0.1,0.9,0.2,0.4,0.9,0.1,0.9,0.2,0.4,0.9,0.,0.9,0.1,0.4,0.5);\nbool[] pattK = bool[16](F,F,F,T,F,T,T,F,T,F,F,T,F,T,T,F);\nbool[] pattL = bool[16](T,T,F,T,T,T,T,F,T,F,F,T,F,T,T,F);\nbool[] pattS = bool[8](F,T,F,T,F,T,F,T);\n\n\nbool[] pattBa = bool[8](T,T,F,T,F,T,F,T);\nbool[] pattB = bool[8](T,T,T,T,T,T,T,T);\nint[] notesB = int[8](0,1,2,3,0,1,2,3);\n\nconst vec4 cmin9 = vec4(0.,3.,7.,14.);\nconst vec4 cmin7 = vec4(0.,3.,7.,10.);\nconst vec4 cmaj9 = vec4(0.,4.,7.,14.);\nconst vec4 cmaj7 = vec4(0.,4.,7.,11.);\nconst vec4 cmaj7f15 = vec4(0.,4.,6.,11.);\nconst vec4 cmin7maj = vec4(0.,3.,7.,11.);\n\nvec4[] chords = vec4[4](\n    cmaj7f15,\n    cmaj7 - 4.,\n    cmin9 - 7.,\n    cmaj9 - 4.\n);\nfloat note(float note, float octave){ \n\treturn 27.5*exp2(((octave*12. ) + note )/12.);//pow(2., );\n}\n\nvec4 r11(float x){return texture(iChannel0,vec2(x)/256.);}\nvec2 hash22(vec2 p)\n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float ft = fract(t);\n    float tn = t - ft;\n    ft = smoothstep(0.0, 1.0, ft);\n\n    vec2 n0 = noise(floor(tn + 0.0) / fq);\n    vec2 n1 = noise(floor(tn + 1.0) / fq);\n\n    return mix(n0, n1, ft);\n}\n\n#define bitreduction(s,amt) s = sign(s) * floor(abs(s)/amt)*amt\n#define sampleratereduction(t, amt) t = floor(t/amt)*amt\n\n\nvec2 kick(float t, inout float sc){\n\tinit;\n\t\n    sampleratereduction(t, 0.00002);\n    \n    float md = beat/4.;\n    float pl = 16.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    float env = exp(-t*40.7);\n    s += sin((exp(-t*20.1)*240. + 30.)*tt )*env;\n    \n    s = mix(s,sin(s*3.)*1., 0.3);\n    \n    \n    bitreduction(s, 0.001);\n    \n    //s = sign(s)*smoothstep(0.,1.,abs(s));\n    \n    \n    s = clamp(s,-1., 1.);\n    \n    \n    float att = float(pattK[int(idx)]);\n    s *= att;\n    sc = 1. - pow(env, 0.15)*att;\n    sc = smoothstep(0.,1.,sc);\n    ret;\n}\n\nvec2 snare(float t){\n\n    init;\n    \n    \n    //sampleratereduction(t, 0.00001);\n    float md = beat;\n    float pl = 8.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 5000.)*0.9;\n    nn += lpnoise(t, 16500.)*0.45;\n    \n    float amt = 1.;\n    float env = exp(-t*30.);\n    //float f = (400. + exp(-t*50.)*600.)*tt;\n    float f = (300./1. + exp(-t*14.)*1100.  )*tt;\n    s += sin( f + nn.x*0.2)*env;\n    s += sin( f*2.5 + nn.y*4.6)*pow(env, 0.8)*0.7;\n    s += sin( pow(f, 1.01)*4. )*env*0.3;\n    \n    \n    \n    s += sin( f*1.5 )*env*0.1;\n    s *= 0.2;\n    //bitreduction(s, 0.001);\n    //s += sin( f*2. )*env*0.1;\n    \n    s *= float(pattS[int(idx)]);\n    ret;\n}\n\nvec2 lead(float t){\n\tinit;\n\t\n    sampleratereduction(t, 0.00002);\n    float to;\n    vec2 nn = lpnoise(t, 600.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 5500.)*0.1;\n    \n    \n    vec2 id;\n    float r = bar;\n    t = mod(t, r*4.);\n    \n    id.x = floor(t/r);\n    \n    t = mod(t,bar);\n    float reps = 16.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \n    \n    float amt = 1.;\n    float env = exp(-t*10.4);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    //n += floor(id.y/4.)*12.;\n    \n    s += sin( note(n, 4.) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    s += sin( note(n, 4.) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 + nn*0.4)*env;\n    s -= sin( note(n, 4.) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    \n    \n    //s += sin(f + sin(2000.*tt)*exp(-t*20.))*env;\n    \n    \n    \n    \n    //bitreduction(s, 0.0);\n    s *= float(pattL[int(id.y)]);\n    \n    //s += sin( f )*env;\n    //s += amt*sin( f + nn*0.5 )*env;\n    //s -= amt*sin( f )*env;\n    \n    s *= 0.7;\n    ret;\n}\n\nvec2 bass(float t){\n\tinit;\n\t\n    float to;\n    \n    \t\n    //sampleratereduction(t, 0.001);\n    vec2 id;\n    float r = bar;\n    t = mod(t, r*4.);\n    \n    id.x = floor(t/r);\n    \n    t = mod(t,r);\n    float reps = 32. / 2.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \n    \n    float env = exp(-t*9.4);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    //n += floor(id.y/4.)*12.;\n    \n    s += sin( note(n, 1.) *tt \n             +sin(note(n, 2.) *tt + \n             \t+sin(note(n, 4.) *tt)*exp(-t*1.)*0.4\n                 \n                 )*exp(-t*9.)*1. \n             +sin(note(n, 1.) *tt + \n             \t+sin(note(n, 2.) *tt)*exp(-t*1.)*0.1 \n                 \n                 )*exp(-t*9.)*1.5\n            )*env;\n    \n    \n    s *= 1.;\n    \n    \n    //bitreduction(s, 0.3);\n    //s *= float(pattL[int(id.y)]);\n    \n    //s += sin( f )*env;\n    //s += amt*sin( f + nn*0.5 )*env;\n    //s -= amt*sin( f )*env;\n    \n    s *= 0.7;\n    ret;\n}\n\n\n\nvec2 chord(float t){\n\tinit;\n    \n    \n    sampleratereduction(t, 0.00001);\n    float r = bar;\n    t = mod(t,r*4.);\n    int id = int(floor(t/r));\n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 4500.)*0.45;\n    \n    nn *= 0.1*sin(t);\n    float m = 1.;\n    float width = 10.;\n    s += sin( note(chords[id].x, 3.) *tt + nn.x);\n    s += sin( note(chords[id].y, 3.) *tt + nn.x);\n    for(float i = 0.; i < 4.; i++){\n        float a = (1. + i/4.);\n    \t//s += sin( note(chords[id].x, 3.) *tt + nn.x)*m;\n    \ts.x += sin( note(chords[id].x, 4.) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].y, 4.) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].z, 4.) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].w, 4.) *tt*a + nn.x)*m;\n    \ts.y += sin( note(chords[id].x, 4.) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].y, 4.) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].z, 4.) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].w, 4.) *tt*a + nn.y + width)*m;\n    \tm *= 0.5;\n    }\n    \n    //bitreduction(s, 0.04);\n    \n    s *= 0.03;\n    s = sin(s*2.);\n    //s /= 2.;\n    //s = sin(s);\n\tret;\n}\n\n\nvec2 hats (float t){\n\tinit;\n\t\n    t = mod(t + 0., hbeat*0.5);\n    \n    sampleratereduction(t, 0.00005);\n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 1500.)*0.4;\n    \n    float amt = 0.2;\n    float env = exp(-t*15.4);\n    float f =  sin((12000. )*tt)*exp(-t*0.4)*0.215 +sin((9000. )*tt)*exp(-t*2.)*0.5 + ( 2000. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    bitreduction(s, 0.8);\n    s *= 0.5;\n    ret;\n}\nvec2 hatsb (float t){\n\tinit;\n\t\n    t = mod(t + 0., hbeat/0.5);\n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 5500.)*0.4;\n    \n    float amt = 1.;\n    float env = exp(-t*10.4);\n    float f =  sin((12000. )*tt)*exp(-t*0.4)*0.215 +sin((9000. )*tt)*exp(-t*2.)*0.5 + ( 2000. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    float bitreduction = 0.35;\n    s = sign(s) * floor(abs(s)/bitreduction)*bitreduction;\n    \n    s *= 0.7;\n    ret;\n}\nvoid initKickPatt(float t){\n\t\n    float r = beat/4.;\n    \n    float id = floor(t/r);\n    \n    \n    for(int i = 0; i < 16; i++){\n        \n        vec4 r = r11(id + float(i));\n        \n    \tpattK[i] = r.x < probK[i];\n        \n    }\n}\n\nvec2 mainSound( in int samp, float t )\n{\n    //t += msr*4.;\n    vec2 s= vec2(0);\n    \n    initKickPatt(t);\n    \n    float sc;\n    \n    vec2 k = kick(t,sc)*1.;\n    vec2 sn = snare(t);\n    \n    vec2 ha = hats(t)*(pow(sc,4.4))*0.2;\n    vec2 hb= hatsb(t)*(pow(sc,4.4))*0.1;\n    vec2 bass = bass(t)*(pow(sc,1.4))*0.4;\n    vec2 c = chord(t)*(pow(sc,2.8))*0.7;\n    vec2 l = lead(t)*(pow(sc,1.))*0.25;\n    \n    \n    if(t < msr){\n        t = mod(t,msr);\n    \ts += c;\n        \n        if(t > bar){\n    \t\ts += bass;\t\n        }\n        if(t > bar + beat){\n        \ts += l;\n        }\n        if(t > beat*14.){\n    \t\ts += k;\n        }\n    } else if (t < msr*2.){\n    \ts += k;\n    \ts += sn;\n        s += ha;\n        s += c;\n        s += bass;\t\n        //s += l;\n    } else if (t < msr*4.){\n        t = mod(t,msr);\n    \ts += k;\n    \ts += sn;\n        s += ha;\n        s += hb;\n        s += c;\n        s += bass;\t\n        if(t > msr*3.5){\n        \ts -= c;\n        \ts += l;\n        }\n    } else {\n        t -= msr*4.;\n    \ts += k;\n    \ts += sn;\n        s += ha;\n        s += hb;\n        s += c;\n        s += bass;\t\n        //s -= c;\n        s += l;\n    \tbitreduction(s, (0.01 + smoothstep(0.,1.,t*0.01)));\n    }\n    \n    s *= 0.1;\n    \n    s = mix(s,sign(s)*smoothstep(0.1,1.,abs(s)), (0.3 + sin(t)*0.2)*0.);\n    s = clamp(s,-1.,1.);\n    \n    //s *= smoothstep(0.,1.,t*0.5);\n    return s;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}