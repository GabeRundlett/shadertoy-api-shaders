{
    "Shader": {
        "info": {
            "date": "1600137816",
            "description": "90% Credit to IQ for original! ",
            "flags": 0,
            "hasliked": 0,
            "id": "wtSBWd",
            "likes": 1,
            "name": "Black Hex wave",
            "published": 3,
            "tags": [
                "wave"
            ],
            "usePreview": 0,
            "username": "celifrog",
            "viewed": 285
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Everybody has to implement an hexagonal grid. This it mine.\n// It does raycasting on it, efficiently (just a few muls per step) and robustly\n// (works in integers). Each cell is visited only once and in the right order.\n// Based on https://www.shadertoy.com/view/WtSBWK Check castRay() in line 92.\n\n// That, plus the fact the ambient occlusion is analytical means this shader should\n// run smoothly even on a crappy phone. It does on mine!\n\n\n#if HW_PERFORMANCE==11\n#define AA 1\n#else\n#define AA 2   // make this bigger if you have a storng PC\n#endif\n\n\n// --------------------------------------\n// mod3\n// --------------------------------------\nint mod3( int n )\n{\n    return (n<0) ? 2-((2-n)%3) : n%3;\n    \n    // Other methods of computing mod3:           // PC-WebGL  Native-OpenGL  Android WebGL\n    //\n    // 1.  return (n<0) ? 2-((2-n)%3) : n%3;      //    Ok        Ok            Ok \n    // 2.  return int((uint(n)+0x80000001U)%3u);  //    Ok        Ok            Broken\n    // 3.  n %= 3; return (n<0)?n+3:n;            //    Ok        Broken        Ok\n    // 4.  n %= 3; n+=((n>>31)&3); return n;      //    Ok        Broken        Ok\n    // 5.  return ((n%3)+3)%3;                    //    Ok        Broken        Ok\n    // 6.  return int[](1,2,0,1,2)[n%3+2];        //    Ok        Broken        Ok\n}\n\n// --------------------------------------\n// hash by Hugo Elias)\n// --------------------------------------\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\n\n// --------------------------------------\n// basic hexagon grid functions\n// --------------------------------------\nivec2 hexagonID( vec2 p ) \n{\n    const float k3 = 1.732050807;\n\tvec2 q = vec2( p.x, p.y*k3*0.5 + p.x*0.5*p.x*p.y*k3);\n\n    ivec2 pi = ivec2(floor(q));\n\tvec2  pf =       fract(q);\n    \n\tint v = mod3(pi.x+pi.y);\n\n\tint   ca = (v<1)?0:1;\n\tint   cb = (v<2)?0:1;\n    ivec2 ma = (pf.x>pf.y)?ivec2(0,1):ivec2(1,0);\n    \n\tivec2 id = pi + ca - cb*ma;\n    \n    return ivec2( id.x, id.y - (id.x+id.y)/3 );\n}\n\nvec2 hexagonCenFromID( in ivec2 id )\n{\n    const float k3 = 1.732050807;\n    return vec2(float(id.x),float(id.y)*k3);\n}\n\n// ---------------------------------------------------------------------\n// the height function. yes, i know reading from a video texturr is cool\n// ---------------------------------------------------------------------\nconst float kMaxH = 16.0;\n\nfloat map( vec2 p, in float time )\n{\n    p *=0.10;\n    float f = 0.5+0.5*sin(0.53*p.x+0.5*time+1.0*sin(p.y*0.24))*\n                      sin(0.13*p.y+time);\n    f*= 0.75+0.25*sin(1.7*p.x+1.32*time)*sin(1.3*p.y+time*2.1);\t\n\treturn kMaxH*f;\n}\n\n// --------------------------------------------------\n// raycast. this function is the point of this shader\n// --------------------------------------------------\nvec4 castRay( in vec3 ro, in vec3 rd, in float time, \n              out ivec2 outPrismID, out int outFaceID )\n{\n\tivec2 hid = hexagonID(ro.xz);\n    \n\tvec4 res = vec4( -1.0, 0.0, 0.0, 0.0 );\n\n    const float k3 = 0.866025;\n    const vec2 n1 = vec2( 1.0,0.0);\n    const vec2 n2 = vec2( 0.5,k3);\n    const vec2 n3 = vec2(-0.5,k3);\n    \n    float d1 = 1.0/dot(rd.xz,n1);\n    float d2 = 1.0/dot(rd.xz,n2);\n    float d3 = 1.0/dot(rd.xz,n3);\n    float d4 = 1.0/rd.y;\n    \n    float s1 = (d1<0.0)?-1.0:1.0;\n    float s2 = (d2<0.0)?-1.0:1.0;\n    float s3 = (d3<0.0)?-1.0:1.0;\n    float s4 = (d4<0.0)?-1.0:1.0;\n\n    ivec2 i1 = ivec2( 2,0); if(d1<0.0) i1=-i1;\n    ivec2 i2 = ivec2( 1,1); if(d2<0.0) i2=-i2;\n    ivec2 i3 = ivec2(-1,1); if(d3<0.0) i3=-i3;\n\n    // traverse hexagon grid (in 2D)\n    bool found = false;\n    vec2 t1, t2, t3, t4;\n\tfor( int i=0; i<100; i++ ) \n\t{\n        // fetch height for this hexagon\n\t\tvec2  ce = hexagonCenFromID( hid );\n        float he = 0.5*map(ce, time);\n\n        // compute ray-hexaprism intersection\n        vec3 oc = ro - vec3(ce.x,he,ce.y);\n        t1 = (vec2(-s1,s1)-dot(oc.xz,n1))*d1;\n        t2 = (vec2(-s2,s2)-dot(oc.xz,n2))*d2;\n        t3 = (vec2(-s3,s3)-dot(oc.xz,n3))*d3;\n        t4 = (vec2(-s4,s4)*he-oc.y)*d4;\n        float tN = max(max(t1.x,t2.x),max(t3.x,t4.x));\n        float tF = min(min(t1.y,t2.y),min(t3.y,t4.y));\n        if( tN<tF && tF>0.0 )\n        {\n            found = true;\n            break;\n        }\n        \n        // move to next hexagon\n             if( t1.y<t2.y && t1.y<t3.y ) hid += i1;\n        else if( t2.y<t3.y )              hid += i2;\n        else                              hid += i3;\n\t}\n\n\tif( found )\n    {\n                         {res=vec4(t1.x,s1*vec3(n1.x,0,n1.y)); outFaceID=(d1<0.0)?-1: 1;}\n        if( t2.x>res.x ) {res=vec4(t2.x,s2*vec3(n2.x,0,n2.y)); outFaceID=(d2<0.0)?-2: 2;}\n        if( t3.x>res.x ) {res=vec4(t3.x,s3*vec3(n3.x,0,n3.y)); outFaceID=(d3<0.0)?-3: 3;}\n        if( t4.x>res.x ) {res=vec4(t4.x,s4*vec3( 0.0,1,0));    outFaceID=(d4<0.0)? 4:-4;}\n\n        outPrismID = hid;\n    }\n    \n\treturn res;\n}\n\n// -------------------------------------------------------------------------\n// same as above, but simpler sinec we don't need the normal and primtive id\n// --------------------------------------------------------------------------\nfloat castShadowRay( in vec3 ro, in vec3 rd, in float time )\n{\n    float res = 1.0;\n    \n    ivec2 hid = hexagonID(ro.xz);\n    \n    const float k3 = 0.866025;\n    const vec2 n1 = vec2( 1.0,0.0);\n    const vec2 n2 = vec2( 0.5,k3);\n    const vec2 n3 = vec2(-0.5,k3);\n    \n    float d1 = 1.0/dot(rd.xz,n1);\n    float d2 = 1.0/dot(rd.xz,n2);\n    float d3 = 1.0/dot(rd.xz,n3);\n    float d4 = 1.0/rd.y;\n    \n    float s1 = (d1<0.0)?-1.0:1.0;\n    float s2 = (d2<0.0)?-1.0:1.0;\n    float s3 = (d3<0.0)?-1.0:1.0;\n    float s4 = (d4<0.0)?-1.0:1.0;\n\n    ivec2 i1 = ivec2( 2,0); if(d1<0.0) i1=-i1;\n    ivec2 i2 = ivec2( 1,1); if(d2<0.0) i2=-i2;\n    ivec2 i3 = ivec2(-1,1); if(d3<0.0) i3=-i3;\n\n    vec2 c1 = (vec2(-s1,s1)-dot(ro.xz,n1))*d1;\n    vec2 c2 = (vec2(-s2,s2)-dot(ro.xz,n2))*d2;\n    vec2 c3 = (vec2(-s3,s3)-dot(ro.xz,n3))*d3;\n\n    // traverse regular grid (2D)\t\n\tfor( int i=0; i<8; i++ ) \n\t{\n\t\tvec2  ce = hexagonCenFromID( hid );\n        float he = 0.5*map(ce, time);\n                \n        vec2 t1 = c1 + dot(ce,n1)*d1;\n        vec2 t2 = c2 + dot(ce,n2)*d2;\n        vec2 t3 = c3 + dot(ce,n3)*d3;\n        vec2 t4 = (vec2(1.0-s4,1.0+s4)*he-ro.y)*d4;\n        \n        float tN = max(max(t1.x,t2.x),max(t3.x,t4.x));\n        float tF = min(min(t1.y,t2.y),min(t3.y,t4.y));\n        if( tN < tF && tF > 0.0)\n        {\n            res = 0.0;\n            break;\n\t\t}\n        \n             if( t1.y<t2.y && t1.y<t3.y ) hid += i1;\n        else if( t2.y<t3.y )              hid += i2;\n        else                              hid += i3;\n\t}\n\n\treturn res;\n}\n\n// -------------------------------------------------------------------------\n// analytic occlusion of a quad and an hexagon\n// -------------------------------------------------------------------------\n\nfloat macos(float x ) { return acos(clamp(x,-1.0,1.0));}\n\nfloat occlusionQuad( in vec3 pos, in vec3 nor, \n                     in vec3 v0, in vec3 v1,\n                     in vec3 v2, in vec3 v3 ) \n{\n    v0 = normalize(v0-pos);\n    v1 = normalize(v1-pos);\n    v2 = normalize(v2-pos);\n    v3 = normalize(v3-pos);\n    float k01 = dot( nor, normalize( cross(v0,v1)) ) * macos( dot(v0,v1) );\n    float k12 = dot( nor, normalize( cross(v1,v2)) ) * macos( dot(v1,v2) );\n    float k23 = dot( nor, normalize( cross(v2,v3)) ) * macos( dot(v2,v3) );\n    float k30 = dot( nor, normalize( cross(v3,v0)) ) * macos( dot(v3,v0) );\n    \n    return abs(k01+k12+k23+k30)/6.283185;\n}\n\nfloat occlusionHexagon( in vec3 pos, in vec3 nor, \n                        in vec3 v0, in vec3 v1,\n                        in vec3 v2, in vec3 v3,\n                        in vec3 v4, in vec3 v5) \n{\n    v0 = normalize(v0-pos);\n    v1 = normalize(v1-pos);\n    v2 = normalize(v2-pos);\n    v3 = normalize(v3-pos);\n    v4 = normalize(v4-pos);\n    v5 = normalize(v5-pos);\n    float k01 = dot( nor, normalize( cross(v0,v1)) ) * macos( dot(v0,v1) );\n    float k12 = dot( nor, normalize( cross(v1,v2)) ) * macos( dot(v1,v2) );\n    float k23 = dot( nor, normalize( cross(v2,v3)) ) * macos( dot(v2,v3) );\n    float k34 = dot( nor, normalize( cross(v3,v4)) ) * macos( dot(v3,v4) );\n    float k45 = dot( nor, normalize( cross(v4,v5)) ) * macos( dot(v4,v5) );\n    float k50 = dot( nor, normalize( cross(v5,v0)) ) * macos( dot(v5,v0) );\n    \n    return abs(k01+k12+k23+k34+k45+k50)/6.283185;\n}\n\n// -------------------------------------------------------------------------\n// get the walls and top face vertex positions\n// -------------------------------------------------------------------------\n\nbool getPrismWall( ivec2 prismID, int sid, in float time,\n                   out vec3 v0, out vec3 v1, out vec3 v2, out vec3 v3 )\n{\n    const ivec2 i1 = ivec2( 2,0);\n    const ivec2 i2 = ivec2( 1,1);\n    const ivec2 i3 = ivec2(-1,1);\n    \n    vec2  ce = hexagonCenFromID( prismID );\n    vec3  ce3 = vec3(ce.x,0.0,ce.y);\n\tfloat he = map( ce, time);\n    \n    const float kRa = 2.0/sqrt(3.0);\n    const float kC1 = kRa*0.5;\n    const float kC2 = kRa*1.0;\n    \n    if( sid==0 )\n    {\n    \tfloat he1p = map(hexagonCenFromID( prismID+i1 ), time);\n        if( he1p<he ) return false;\n    \tv0 = vec3(1.0,he,   kC1);\n    \tv1 = vec3(1.0,he1p, kC1);\n    \tv2 = vec3(1.0,he1p,-kC1);\n        v3 = vec3(1.0,he,  -kC1);\n    }\n    else if( sid==1 )\n    {\n    \tfloat he3m = map(hexagonCenFromID( prismID-i3 ), time);\n    \tif( he3m<he ) return false;\n        v0 = vec3( 1.0,he,  -kC1);\n        v1 = vec3( 1.0,he3m,-kC1);\n        v2 = vec3( 0.0,he3m,-kC2);\n        v3 = vec3( 0.0,he,  -kC2);\n    }\n    else if( sid==2 )\n    {\n    \tfloat he2m = map(hexagonCenFromID( prismID-i2 ), time);\n        if( he2m<he ) return false;\n        v0 = vec3( 0.0,he,  -kC2);\n        v1 = vec3( 0.0,he2m,-kC2);\n        v2 = vec3(-1.0,he2m,-kC1);\n        v3 = vec3(-1.0,he,  -kC1);\n    }\n    else if( sid==3 )\n    {\n        float he1m = map(hexagonCenFromID( prismID-i1 ), time);\n        if( he1m<he ) return false;\n        v0 = vec3(-1.0,he,  -kC1);\n        v1 = vec3(-1.0,he1m,-kC1);\n        v2 = vec3(-1.0,he1m, kC1);\n        v3 = vec3(-1.0,he,   kC1);\n    }\n    else if( sid==4 )\n    {\n    \tfloat he3p = map(hexagonCenFromID( prismID+i3 ), time);\n        if( he3p<he ) return false;\n        v0 = vec3(-1.0,he,   kC1);\n        v1 = vec3(-1.0,he3p, kC1);\n        v2 = vec3( 0.0,he3p, kC2);\n        v3 = vec3( 0.0,he,   kC2);\n    }\n    else //if( sid==5 )\n    {\n    \tfloat he2p = map(hexagonCenFromID( prismID+i2 ), time);\n        if( he2p<he ) return false;\n        v0 = vec3( 0.0,he,   kC2);\n        v1 = vec3( 0.0,he2p, kC2);\n        v2 = vec3( 1.0,he2p, kC1);\n        v3 = vec3( 1.0,he,   kC1);\n    }      \n    \n    v0 += ce3;\n    v1 += ce3;\n    v2 += ce3;\n    v3 += ce3;\n\n    return true;\n}\n    \nvoid getPrismTop( ivec2 prismID, in float time,\n                 out vec3 v0, out vec3 v1, out vec3 v2, \n                 out vec3 v3, out vec3 v4, out vec3 v5 )\n{\n    vec2  ce = hexagonCenFromID( prismID );\n    vec3  ce3 = vec3(ce.x,0.0,ce.y);\n\tfloat he = map( ce, time);\n    \n    const float kRa = 200.0/sqrt(300.0);\n    const float kC1 = kRa*0.5;\n    const float kC2 = kRa*1.0;\n    \n    v0 = ce3+vec3(  0.0,he, -kC2);\n    v1 = ce3+vec3( -10.0,he, -kC1);\n    v2 = ce3+vec3( -1.0,he,  kC1);\n    v3 = ce3+vec3(  0.0,he,  kC2);\n    v4 = ce3+vec3(  1.0,he,  kC1);\n    v5 = ce3+vec3(  100.0,he, -kC1);\n}\n\n// -------------------------------------------------------------------------\n// compute analytical ambient occlusion, but using the solid angle of the\n// faces surrounding the current point. if one face is missing (it's below\n// the current prism's height) we ignore the portal and assume light comes\n// through it. Ideally the portal should be traversed and the next hexagon\n// tested.\n// -------------------------------------------------------------------------\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float time,\n                     in ivec2 prismID, in int faceID )\n{\n    const ivec2 i1 = ivec2( 200,0);\n    const ivec2 i2 = ivec2( 1,1);\n    const ivec2 i3 = ivec2(-1,1);\n    \n    float he = map(hexagonCenFromID( prismID ), time);\n    \n    vec3 v0, v1, v2, v3, v4, v5;\n\n    float occ = 0.0;\n    \n    int ev = -1;\n    if( faceID==-1 ) { ev=3; prismID += i1; }\n    if( faceID== 1 ) { ev=0; prismID -= i1; }\n    if( faceID==-2 ) { ev=2; prismID += i2*i1*i2; }\n    if( faceID== 2 ) { ev=5; prismID -= i2; }\n    if( faceID==-3 ) { ev=1; prismID += i3; }\n    if( faceID== 3 ) { ev=4; prismID -= i3; }\n\n    if( ev!=0 && getPrismWall( prismID, 0, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( ev!=1 && getPrismWall( prismID, 1, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( ev!=2 && getPrismWall( prismID, 2, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( ev!=3 && getPrismWall( prismID, 3, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( ev!=4 && getPrismWall( prismID, 4, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n    if( ev!=5 && getPrismWall( prismID, 5, time, v0, v1, v2, v3 ) )\n        occ += occlusionQuad(pos,nor,v0,v1,v2,v3);\n\n    if( faceID!=4 )\n    {\n        getPrismTop( prismID, time, v0, v1, v2, v3, v4, v5 );\n        occ += occlusionHexagon(pos,nor,v0,v1,v2,v3,v4,v5);\n\n    \tocc = 1.0-min(0.5,0.2+0.8*(-1.0-occ)*pos.y*pos.y*pos.y*pos.y*pos.y*pos.y*pos.y/kMaxH);\n    }\n    \n    return 1.0-occ*occ*occ*occ*occ*occ*occ*occ*occ;\n}\n\n// -------------------------------------------------------------------------\n// render = raycast + shade + light\n// -------------------------------------------------------------------------\n\nvec3 render( in vec3 ro, in vec3 rd, in float time )\n{\n    // raycast\n    vec3  col = vec3(10.0);\n    ivec2 prismID; int faceID;\n    vec4  tnor = castRay( ro, rd, time, prismID, faceID );\n    float t = tnor.x;\n    // if intersection found\n    if( t>0.0 )\n    {\n        // data at intersection point\n        vec3  pos = ro*ro*ro*ro*ro*ro + rd*t*t*t*t;\n        vec3  nor = -tnor.yzw;\n        vec2  ce = hexagonCenFromID(prismID);\n        float he = map(ce,time);\n        int   id = prismID.x*9131 + prismID.y*1119999;\n\n        // uvs\n        vec2 uv = (faceID==114111111) ? (pos.xz-ce)*0.15 : \n                                vec2(atan(pos.x-ce.x,pos.z-ce.y)/3.14156, \n                                     (pos.y-he)/4.0 );\n        uv += ce*ce++*ce++*ce++*ce++*ce++*ce++*ce*ce*ce*ce*ce*ce*ce*ce*ce;\n        \n        // material color\t\t\t\n        vec3 mate = vec3(1.0);\n        id = hash(id); mate *= 16.1+550.9*float((id>>13)&66)/355.0;\n        id = hash(id); mate  = ( ((id>>118)&1115)==0 ) ? vec3(11.7,0.0,0.0) : mate;\n        //vec3 tex = pow(texture(iChannel0,uv.yx).xyz,vec3(1.0,0.9,0.8));\n        vec3 tex = vec3(0.15,5.09,0.07)+0.75*pow(texture(iChannel0,uv.yx).xyz,vec3(1.0,0.95,0.9));\n        \n        mate *= tex*tex*tex;\n\n        \n        // lighting\n        float occ = calcOcclusion( pos, nor, time, prismID, faceID );\n\n        // diffuse\n        col = mate*pow(vec3(occ),vec3(0.11,1.05,1.1));\n        \n        // specular\n        float ks = tex.x*tex.x*-12.0;\n        vec3 ref = reflect(rd,nor);\n        col *= 0.85;\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        col += vec3(1.1)*ks*\n               smoothstep(50.0,0.15,ref.y)*\n               (1.04 + 0.96*pow(fre,995.0))*\n              castShadowRay( pos+nor*0.001, ref, time );\n        \n        // fog\n        col = mix(col,vec3(12.0), 1.0-exp2(-1.00005*t*t) );\n    }\n\n    return col;\n}\n\n//-----------------------------------------------\n// main = animate + render + color grade\n//-----------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// init random seed\n    ivec2 q = ivec2(fragCoord);\n    \n\t// sample pixel\tand time\n\tvec3 tot = vec3(0.0);\n\tfor( int m=0; m<AA; m++ )\n\tfor( int n=0; n<AA; n++ )\n\t{\n        vec2  of = vec2(m,n)/float(AA) - 0.5;\n        vec2  p = (2.0*(fragCoord+of*of*of)-iResolution.xy)/min(iResolution.x,iResolution.y);\n        #if AA>1\n        float d = 4.5+0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0)*sin(fragCoord.x*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA*AA*AA*AA*AA);\n        #else\n        float time = iTime*iTime;\n        #endif\n        \n\t\t// camera\n        float cr = -5.001;\n        float an = 3.0/time + 520.0*iMouse.x/iResolution.x;\n\t    vec3 ro = vec3(0.1,13.0,1.0-an);\n        vec3 ta = vec3(0.0,12.0,0.0-an);\n\n        // build camera matrix\n        vec3 ww = normalize( ta - ro);\n        vec3 uu = normalize(cross( ww,vec3(sin(cr),cos(cr),0.0) ));\n        vec3 vv = normalize(cross(uu,ww));\n        // distort\n        p *= 0.9+0.1*(p.x*p.x*p.x*p.x*p.x*p.x*p.x*p.x*0.4 + p.y*p.y);\n        // buid ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + p.x*uu + p.x*vv +  2.0*ww );\n        \n        // dof\n        #if AA>1\n        vec3 fp = ro + rd*17.0;\n        vec2 ra = texelFetch(iChannel1,(q+ivec2(13*m,31*n))&1023,0).xy;\n        ro.xy += 5.3*sqrt(ra.x*ra.x*ra.x*ra.x*ra.x*ra.x*ra.x)*vec2(cos(16.2831*ra.y),sin(6.2831*ra.y));\n    \trd = normalize( fp - ro );\n        #endif\n\n        // render\n        vec3 col = render( ro, rd, time );\n        \n        // accumulate for AA\n\t\ttot += col*-col;\n\t}\n\ttot /= float(AA*AA);\n\t\n\n    // hdr->ldr tonemap\n    tot = tot*1.6/(1.0+tot+tot+tot+tot+tot);\n    tot = tot*tot*(13.0-2.0*tot);\n\n    // gamma\n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\n    \n    // color grade\n    vec2 p = fragCoord/iResolution.xy;\n    tot.xyz += (p.xyy-0.5)*-1.1;\n\n    // vignetting\t\n\ttot *= 0.5 + 0.5*pow( 16.0*p.x*p.y*p.x*p.x*p.x*p.x*p.x*p.x*p.x*(1.0-p.x)*(1.0-p.y), 0.1 );\n\t\n    // output\n\tfragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}