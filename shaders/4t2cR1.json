{
    "Shader": {
        "info": {
            "date": "1554750790",
            "description": "This is the aggressive version of tunnel from my PC intro \"Sailing Beyond\".\nMusic used here is \"Xara\" by Effect (https://soundcloud.com/neurofunksocietyofpoland/effect-xara-clip)\n",
            "flags": 64,
            "hasliked": 0,
            "id": "4t2cR1",
            "likes": 208,
            "name": "â™« Sailing Beyond - Hyper Tunnel",
            "published": 3,
            "tags": [
                "tunnel",
                "demoscene"
            ],
            "usePreview": 1,
            "username": "patu",
            "viewed": 14309
        },
        "renderpass": [
            {
                "code": "/* \n\n    Hyper Tunnel from \"Sailing Beyond\" (demoscene producion)\n\t\n    https://www.youtube.com/watch?v=oITx9xMrAcM&\n\thttps://www.pouet.net/prod.php?which=77899\n\n\n*/\n\n\n/*\n\thttp://bit.ly/shadertoy-plugin\n*/\n\n\n\n\n\n#pragma optimize(off)\n\n\n\n\n\n#define getNormal getNormalHex\n\n#define FAR 1e3\n#define INFINITY 1e32\n\n#define T iTime\n#define mt (iChannelTime[0] > 0. ? iChannelTime[0] : iTime)\n#define FOV 70.0\n#define FOG .06\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat vol = 0.;\n\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = 1.-(--f)*f*f*f*-f;\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.);\n}\n\nfloat fbm(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<4; i++)\n    {\n        w *= 0.25;\n        s *= 3.;\n        r += w * noise_3(s * x);\n    }\n    return r;\n}\n \nfloat yC(float x) {\n \treturn cos(x * -.134) * 1. * sin(x * .13) * 15.+ fbm(vec3(x * .1, 0., 0.) * 55.4);\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nstruct geometry {\n    float dist;\n    vec3 hit;\n    int iterations;\n};\n\n\n// Cylinder with infinite height\nfloat fCylinderInf(vec3 p, float r) {\n\treturn length(p.xz) - r;\n}\n\ngeometry map(vec3 p) {\n    p.x -= yC(p.y * .1) * 3.;\n    p.z += yC(p.y * .01) * 4.;\n    \n    float n = pow(abs(fbm(p * .06 )) * 12., 1.3);\n    float s = fbm(p * 0.01 + vec3(0., T * 0.14, 0.)) * 128.;\n    \n    geometry obj;\n\n    obj.dist = max(0., -fCylinderInf(p, s + 18. -n));\n    \n    p.x -= sin(p.y * .02) * 34. + cos(p.z * 0.01) * 62.;\n    \n    obj.dist = max(obj.dist, -fCylinderInf(p, s + 28. + n * 2.));\n    \n    return obj;\n}\n\n\nfloat t_min = 10.0;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 100;\n\ngeometry trace(vec3 o, vec3 d) {\n    float omega = 1.3;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 1./ 1000.;\n    \n    geometry mp = map(o);\n\n    float functionSign = mp.dist < 0. ? -1. : +1.;\n    float minDist = FAR;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n\n        mp = map(d * t + o);\n\t\tmp.iterations = i;\n    \n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        \t(radius + previousRadius) < stepLength;\n        \n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        \tstepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        \n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        \n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        \n        t += stepLength * .5; // ;(\n   \t}\n    \n    mp.dist = candidate_t;\n    \n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INFINITY;\n    \n    \n    return mp;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 ouv = fragCoord.xy / iResolution.xy;\n    vec2 uv = ouv - .5;\n\n    uv *= tan(radians (FOV) / 2.0) * 4.;\n    \n    vec3 \n        vuv = normalize(vec3(cos(T), sin(T * .11), sin(T * .41))), // up\n    \tro = vec3(0., 30. + iTime * 100., -.1);\n\n    ro.x += yC(ro.y * .1) * 3.;\n    ro.z -= yC(ro.y * .01) * 4.;\n    \n    vec3 vrp =  vec3(0., 50. + iTime * 100., 2.);\n    \n    vrp.x += yC(vrp.y * .1) * 3.;\n    vrp.z -= yC(vrp.y * .01) * 4.;\n    \n    vec3\n\t\tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro),\n        oro = ro;\n\t\n    vec3 sceneColor = vec3(0.);\n\n    geometry tr = trace(ro, rd);\n    \n    tr.hit = ro + rd * tr.dist;\n    \n    vec3 col = vec3(1., 0.5, .4) * fbm(tr.hit.xzy * .01) * 20.;\n    col.b *= fbm(tr.hit * .01) * 10.;  \n    \n    sceneColor += min(.8, float(tr.iterations) / 90.) * col + col * .03;\n    sceneColor *= 1. + .9 * (abs(fbm(tr.hit * .002 + 3.) * 10.) * (fbm(vec3(0.,0.,iTime * .05) * 2.)) * 1.);\n    sceneColor = pow(sceneColor, vec3(1.)) * (iChannelTime[0] > 0. ? texelFetch(iChannel0, ivec2(128, 0), 0).r * min(1., mt * .1) : 0.6);\n    \n    vec3 steamColor1 = vec3(.0, .4, .5);\n\tvec3 rro = oro;\n    \n    ro = tr.hit;\n\n    float distC = tr.dist, f = 0., st = .9;\n    \n    for (float i = 0.; i < 24.; i++) {       \n        rro = ro - rd * distC;\n        f += fbm(rro * vec3(.1, .1, .1) * .3) * .1;\n        distC -= 3.;\n        if (distC < 3.) break;\n    }\n \n    steamColor1 *= iChannelTime[0] > 0. ? texelFetch(iChannel0, ivec2(32, 0), 0).r : 1.;\n    sceneColor += steamColor1 * pow(abs(f * 1.5), 3.) * 4.;\n    \n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 2.), 0.0, 1.0), 1.0);\n    fragColor = pow(abs(fragColor / tr.dist * 130.), vec4(.8));\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 18302,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/neurofunksocietyofpoland/effect-xara-clip"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}