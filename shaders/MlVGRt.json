{
    "Shader": {
        "info": {
            "date": "1476250994",
            "description": "A test of raymarching morphing geometry with an environment map for reflections and phong shading for the sun. Raymarching and phong shading code based off of https://www.shadertoy.com/view/XsB3Rm",
            "flags": 0,
            "hasliked": 0,
            "id": "MlVGRt",
            "likes": 26,
            "name": "Morphing Mirror",
            "published": 3,
            "tags": [
                "raymarching",
                "mirror",
                "environmentmap"
            ],
            "usePreview": 0,
            "username": "ehj1",
            "viewed": 1468
        },
        "renderpass": [
            {
                "code": "// ray marching\nconst int max_iterations = 64;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.02;\nconst float clip_far = 250.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n// morphing parameters (change over time in mainImage)\nfloat a;\nfloat b;\nfloat c;\nfloat twist;\nfloat r;\nfloat cube_disappear;\n\n\n// iq's distance function for sphere\nfloat sdSphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\n// iq's distance function for box\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// wobbly displacement for box\nfloat displacement(vec3 p) {\n\treturn a*sin(p.x*8.0+iTime*4.0)+\n           b*cos(p.z*8.0+iTime*4.0) + \n           c*cos(p.y*8.0+iTime*4.0);\n}\n\n\n// get distance in the world\nfloat dist_field( vec3 p ) {\n            \n    float c = cos(twist*sin(iTime*2.0)*p.y);\n    float s = sin(twist*sin(iTime*2.0)*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n\n    float v = 1000.0;\n    if (iTime < cube_disappear) {\n        v = sdBox( q, vec3(0.5) );\n        v += displacement(q);\n\n        if (iTime > 40.0) {\n            float sphereDist = -sdSphere(p+vec3(0.3*sin(2.0*iTime+2.0), 0.3*cos(iTime), 0.1*sin(2.1*iTime)), 0.3*r );\n            sphereDist = max(sphereDist, -sdSphere(p+vec3(0.5*sin(iTime), 0.5*cos(iTime), sin(2.1*iTime)), 0.6*r ));\n            sphereDist = max(sphereDist, -sdSphere(p+vec3(0.2*sin(2.*iTime), 0.3*cos(4.*iTime), 0.5*sin(1.*iTime)), 0.4*r ));\n            sphereDist = max(sphereDist, -sdSphere(p+vec3(0.1*sin(4.*iTime), 0.1*cos(3.*iTime), 0.2*sin(0.5*iTime)), 0.5*r ));\n        \tv = max( v, sphereDist);\n        }\n\t}\n    v = min(v, sdSphere(p, 0.3*r) + 0.005*sin(p.y*32.0 + iTime*2.0));\n\n    return v;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) - dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\tfloat shininess = 16.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( 0.0, 20.0, 0.0 );\n\t\tvec3 light_color = vec3( 0.9, 0.9, 1.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n    \n    // Add in environment reflection\n    final += 0.7*texture(iChannel0, vec3(ref_ev.x,-ref_ev.y,ref_ev.z)).xyz;\n\n\treturn final;\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n        vec3 p = origin + dir * depth;\n\t\tfloat dist = dist_field( p ) / length( gradient( p ) );\n\t\tif ( abs( dist ) < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist * 0.9;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n// linear fade in and out from 0.0 to 1.0 and back\nfloat linear_fadeinout(float x, float start_x, float end_x) {\n    return clamp(1.0 - abs(x - 0.5*start_x - 0.5*end_x)/(0.5*(end_x-start_x)), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // update morphing parameters\n    twist = linear_fadeinout(iTime, 4.0, 16.0)*3.5;\n    a = linear_fadeinout(iTime, 16.0,40.0)*0.1;\n    b = linear_fadeinout(iTime, 24.0,40.0)*0.1;\n    c = linear_fadeinout(iTime, 24.0,40.0)*0.1;\n    r = clamp((iTime-40.0)*0.1, 0.0, 2.0);\n    cube_disappear = 60.0;\n    \n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 2.5 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY( vec2(0.0,iTime*0.1) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n\tfloat depth = ray_marching( eye, dir, 0.0, clip_far );\n\tif ( depth >= clip_far ) {\n\t\tfragColor = texture(iChannel0, vec3(dir.x,-dir.y,dir.z));\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = gradient( pos );\n\tfragColor = vec4( shading( pos, n, eye ), 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}