{
    "Shader": {
        "info": {
            "date": "1673985996",
            "description": "rockin' and waterin'",
            "flags": 0,
            "hasliked": 0,
            "id": "DlB3WV",
            "likes": 86,
            "name": "Cavernic",
            "published": 3,
            "tags": [
                "tunnel",
                "water",
                "gyroid",
                "rock"
            ],
            "usePreview": 1,
            "username": "leon",
            "viewed": 1884
        },
        "renderpass": [
            {
                "code": "\n// Cavernic by Leon Denise 2023-01-17\n\n// a noise designed cavern with rock and water\n// (you can move camera with mouse)\n\n// globals\nfloat material, total;\n\n// snippets\n#define R iResolution\n#define N(x,y,z) normalize(vec3(x,y,z))\n#define ss(a,b,t) smoothstep(a,b,t)\n#define repeat(p,r) (mod(p,r)-r/2.)\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\nfloat gyroid(vec3 p) { return dot(sin(p), cos(p.yzx)); }\n\n// Victor Shepardson + Inigo Quilez \n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// the noises\nfloat noise(inout vec3 p)\n{\n    float result = 0., a = .5;\n    for (float i = 0.; i < 3.; ++i, a/=2.)\n    {\n        result += (gyroid(p/a)*a);\n    }\n    return result;\n}\n\nfloat noise2(vec3 p)\n{\n    float result = 0., a = .5;\n    for (float i = 0.; i < 6.; ++i, a/=2.)\n    {\n        p.z += result * .5;\n        result += abs(gyroid(p/a)*a);\n    }\n    return result;\n}\n\nfloat noise3(vec3 p)\n{\n    float result = 0., a = .5;\n    for (float i = 0.; i < 5.; ++i, a/=2.)\n    {\n        p.y += result * .5 + iTime * .05;\n        result += abs(gyroid(p/a)*a);\n    }\n    return result;\n}\n\nfloat noise4(vec3 p)\n{\n    float result = 0., a = .5;\n    for (float i = 0.; i < 3.; ++i, a/=2.)\n    {\n        p.y += result * .5;\n        result += abs(gyroid(p/a)*a);\n    }\n    return result;\n}\n\nfloat map(vec3 p)\n{\n    float dist = 100.;\n    \n    // recenter\n    p.x += .7;\n    \n    // travel\n    p.z -= iTime * .1;\n    \n    // save position for later\n    vec3 q = p;\n    \n    // global structure\n    p.z *= .5;\n    dist = noise(p);\n    \n    // subtract medium holes\n    float grid = .5;\n    float shape = length(repeat(p,grid))-grid/1.5;\n    shape = max(dist, abs(shape)-.1);\n    dist = max(dist, -abs(shape)*.5);\n    \n    // add intermediate structure\n    p = q*5.;\n    p.y *= .3;\n    dist += abs(noise(p))*.2;\n    \n    // add medium vertical details\n    p = q*10.;\n    p.y *= .2;\n    dist += pow(abs(noise(p)), 4.)*.1;\n    \n    // extra medium horizontal details\n    p = q;\n    p.y += cos(p.z*2.)*.05;\n    p.zx *= .3;\n    dist -= pow(abs(noise4(p*10.)), 4.)*.03;\n    \n    // add surface details\n    p = q*10.;\n    p.z *= 2.;\n    dist -= noise2(p) * .05;\n    \n    // inflate/deflate volume along z\n    dist -= .1;\n    dist -= .1 * sin(q.z);\n    \n    // inflate volume for the ceiling\n    dist -= max(0., p.y) * .02;\n    \n    // water\n    float water = q.y + 1. + noise3(q*2.) * .01;\n    \n    material = water < dist ? 1. : 0.;\n    dist = min(water, dist);\n    \n    return dist;\n}\n\n// NuSan\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal(vec3 pos, float e)\n{\n    vec2 noff = vec2(e,0);\n    return normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n}\n\nvec3 getColor(vec3 pos, vec3 normal, vec3 ray, float shade)\n{\n    // Inigo Quilez palette\n    // https://iquilezles.org/articles/palettes\n    vec3 color = .5+.5*cos(vec3(1,2,3)*5.9+normal.y-normal.z*.5-.5);\n    \n    // light\n    color *= dot(normal, -normalize(pos))*.5+.5;\n    \n    // shadow\n    color *= shade*shade;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 color = vec3(0);\n    \n    // coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord-R.xy)/R.y;\n    vec3 pos = vec3(0,0,0);\n    vec3 ray = normalize(vec3(p,-1.));\n    vec3 rng = hash(uvec3(fragCoord, 0.));\n    \n    // mouse camera\n    bool clicked = iMouse.x > 0.;\n    bool clicking = iMouse.z > 0.;\n    if (clicked)\n    {\n        vec2 mouse = iMouse.xy-abs(iMouse.zw)+R.xy/2.;\n        vec2 angle = vec2((2.*mouse-R.xy)/R.y);\n        ray.yz *= rot(angle.y);\n        ray.xz *= rot(angle.x);\n    }\n\n    // raymarch\n    total = 0.;\n    float shade = 0.;\n    for (shade = 1.; shade > 0.; shade -= 1./200.)\n    {\n        float dist = map(pos);\n        if (dist < .001*total || total > 20.) break;\n        dist *= 0.12 + 0.05*rng.z;\n        pos += ray * dist;\n        total += dist;\n    }\n\n    // coloring\n    if (shade > .01)\n    {\n        float mat = material;\n        vec3 normal = getNormal(pos, .003*total);\n        \n        // cavern\n        if (mat == 0.)\n        {\n            color = getColor(pos, normal, ray, shade);\n            \n            // water wet\n            float spec = pow(dot(-ray, normal)*.5+.5, 100.);\n            color += .2*spec*ss(.5,.0,pos.y+1.);\n        }\n        // water\n        else\n        {\n            // raymarch reflection\n            ray = reflect(ray, normal);\n            pos += ray *.05;\n            total = 0.;\n            for (shade = 1.; shade > 0.; shade -= 1./80.)\n            {\n                float dist = map(pos);\n                if (dist < .05*total || total > 20.) break;\n                dist *= 0.2;\n                pos += ray * dist;\n                total += dist;\n            }\n            \n            // color reflection\n            color = getColor(pos, getNormal(pos, .001), ray, shade);\n            color *= ss(1.,0.,pos.y+1.);\n            color *= ss(0.,0.6,(pos.y+1.2));\n        }\n    }\n    \n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}