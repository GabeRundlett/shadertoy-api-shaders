{
    "Shader": {
        "info": {
            "date": "1632560764",
            "description": "Not so crappy, got some perf drop when close to wireframe but it's fine.",
            "flags": 0,
            "hasliked": 0,
            "id": "fs3SRH",
            "likes": 8,
            "name": "大龙猫 - WiReZ",
            "published": 3,
            "tags": [
                "tunnel",
                "wireframe"
            ],
            "usePreview": 0,
            "username": "totetmatt",
            "viewed": 291
        },
        "renderpass": [
            {
                "code": "\n/**\n\n== Do not buy NFT made with my art. ==\n\n== Do not make NFT with my Creative-Commons artworks. ==\n\n== If you respect my art, remember and apply this. ==\n\n*/\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat elev(vec3 p){\n  float s = 0.;\n  vec4 pp= vec4(p*.5,1.1);\n  const float lim = 8.;\n  for(float i=0.;i<lim;i++){\n     pp.xzy = abs(pp.xzy)-vec3(1.125,1.5,1.2);\n        pp.xz*=rot(-.785+i);\n      pp *=1.3;\n  float m = min(pp.x,pp.z);\n      s += sqrt(clamp( \n       ( \n         tan(sin(m-pp.x*3.))\n         +tan(cos(m+pp.z*7.))\n    )/(pow(3.,i+1.))\n   \n    \n    ,-0.0,1.3))*.5;\n  }\n  return s/lim;\n}\nfloat diam2(vec2 p,float s){\n   p = abs(p);\n   return (p.x+p.y-s)*inversesqrt(3.);\n  }\nvec2 sdf(vec3 p){\n  p.xy *=rot(p.z*.3);\n  p.y = -(abs(p.y)-1.);\n  \n  vec2 h;\n  \n  vec3 hp= p;\n  h.x = dot(p,vec3(0.,1.,0.))+elev(hp)*2.0;;\n  //h.x = mix(h.x,+elev(hp+vec3(551.51,55.2,55.))*2.0,.5);\n  h.y= 1.;\n  \n  vec2 t ;\n  vec3 tp = p;\n  vec2 ltp = vec2(log(length(p.xy)),atan(p.y,p.x))*3.;\n  ltp.x +=iTime;\n\n  ltp = fract(ltp);\n  \n  \n  tp.y +=asin(sin(p.z));\n  tp.xy *= rot(tp.z*.1)*.7;\n  tp.xz /=2.;\n  tp.xz = fract(tp.xz)-.5;\n  \n  t.y =2.;\n  t.x = min(diam2(tp.zy,.05),diam2(tp.xy,.05));\n  \n  h = t.x < h.x ? t:h;\n \n  return h;\n  \n}\n\n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p,float ee){vec2 e= vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\n  vec3 pal(float t){return vec3(0.,.5,.0)+vec3(.0,.5,.1)*cos(6.28*(vec3(1.,1.0,10.)*t+vec3(.0,.3,.7)));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n\n\tvec3 col = vec3(.01);\n  vec3 ro = vec3(0.,0.2,-7.+iTime);\n\n  vec3 rt = vec3(0.+sin(iTime*.2)*3.,-1.0,ro.z+cos(iTime*.2)*10.);\n  vec3 z = normalize(rt-ro);\n  vec3 x = normalize(cross(z,vec3(0.,-1.,0.)));\n  vec3 y = normalize(cross(z,x));\n  \n  vec3 rd = mat3(x,y,z)*normalize(vec3(uv,1.));\n  rd.xy*=rot(iTime*.1);\n  vec3 rp =ro;\n  \n  vec3 light = ro+vec3(1.,2.,-1.);\n  float dd = 0.;\n  float side = 1.;\n  vec3 acc = vec3(0.);\n  float sat = 0.;\n  for(float i=0.;i<=128.;i++){\n    vec2 d = sdf(rp);\n    dd +=d.x;\n    d.x *=side;\n    if(dd>50.) break;\n    if(d.x < .001){\n      vec3 n = norm(rp,.005);\n      float diff = max(0.,dot(normalize(light-rp),n));\n        if(d.y == 1.){\n        \n          col = vec3(.02)*diff;\n          break;\n        } \n        if(d.y == 2.){\n            vec3 n2 = norm(rp,.001);\n          float l = length(n-n2);\n            float di = step(.1,l);\n            acc += vec3(di)*pal(+fract(rp.z*.1));\n            sat = min(1.,sat+sqrt(di));\n        \n          side *=-1.;\n              \n          rp +=rd*.05;\n         \n        \n          }\n      }\n    rp +=rd*d.x;\n    }\n col +=acc;\n\n    fragColor = vec4(sqrt(col),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}