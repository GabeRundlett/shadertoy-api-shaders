{
    "Shader": {
        "info": {
            "date": "1635654545",
            "description": "Coded live at Inercia 2021 shader royale compo. Continued coding after being wiped out 2nd, and this is what I ended up with.\nPoV VoD: https://www.youtube.com/watch?v=EZNpgjQnXVg",
            "flags": 0,
            "hasliked": 0,
            "id": "ftcGz8",
            "likes": 16,
            "name": "[live] Inercia 2021 royale",
            "published": 3,
            "tags": [
                "dof",
                "livecoding"
            ],
            "usePreview": 0,
            "username": "w23",
            "viewed": 448
        },
        "renderpass": [
            {
                "code": "float t;\n#define pi 3.1415927\n#define TT(t,v) texture(t, ((v)+.5)/vec2(textureSize(t,0)))\n//float fft(float f){return TT(texFFT,f).r;}\n//float ffts(float f){return TT(texFFTSmoothed,f).r;}\n//float ffti(float f){return TT(texFFTIntegrated,f).r;}\n\n//float fft(float f){return TT(iChannel0, vec2(f, t*32.)).r;}//TT(texFFT,f).r;}\nfloat ffts(float f){return .02 * pow(TT(iChannel0, vec2(f/1., t*10.)).r, 2.5);}//TT(texFFTSmoothed,f).r;}\n//float ffti(float f){return 0.;}//TT(texFFTIntegrated,f).r;}\n\n\n#define rep(v,s) (mod(v,s)-(s)*.5)\nfloat hash(float f){return fract(sin(f)*54353.42347);}\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvec3 circ(vec2 uv, float h) {\n  float r=length(uv);\n  float a=atan(uv.x,uv.y);\n  a/=pi;a+=1.;\n  a+=2.;\n  float f = 4. * ffts(floor(a*(5. + 50. * hash(h))));\n  r -= f;\n  \n  float mask = step(abs(r-.3), .1);\n  float masz = .2 * hash(h+.1);\n  mask *= step(mod(a + sin(t+h*4.),.1+masz),.04+.1*masz);\n  \n  return mix(vec3(.1,.2,.3),vec3(.5,.2,.3),min(f*40., 3.)) * mask;\n}\n\nvec3 dots(vec2 p) {\n  //p = fract(p) - .5;\n  p = rep(p,vec2(.2));\n  return vec3(.1,.4,.6) * step(length(p), .01);\n}\n\nvec3 plane(float O, float D, float S, vec2 ouv, vec2 duv, float n) {\n  float l = (S - O) / D; if (l < 0.) return vec3(0.);\n  vec2 uv = ouv + duv * l;\n  \n  if (n == 1.)\n     uv.y += floor(t) + pow(fract(t), 2.);\n  \n  float xoffc = floor(uv.y);\n  float xoffp = t * (.2 - 1. * sin(2. * pi * hash(xoffc+.3))) + hash(xoffc);\n  //xoffp = \n  float xoff = floor(xoffp/2.)*2. + 2. * pow(fract(xoffp), 3.);\n  uv.x += xoff;\n  \n  vec2 pc = floor(uv);\n  vec2 p = fract(uv) - .5;\n  \n  vec3 c = vec3(0.);\n  \n  c += circ(p*1.5, hash(pc.x*.18+pc.y*34.)) * 4.;\n  \n  //c += vec3(.1, .2, .3) * step(length(p), .1);\n  c += dots(uv) * 4.;\n  \n  //c +\n  \n  return c / l;\n}\n\n\n/*void main(void) {\n\tvec2 uv = vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord/iResolution.xy - .5; uv.x *= iResolution.x/iResolution.y;\n  \n  vec3 C=vec3(0.);\n  \n  //t = iTime; fragColor.rgb = circ(uv, 1.); return;\n  \n  float seed = uv.x*45.43278 + uv.y*17.643 + iTime*3.4;\n\n  const float foc = 6.;\n  const float fov = 1./2.;\n  const float ls = .05;\n\n  const int NS = 16;\n  ///float tt = iTime;// * 130./120.;\n  for(int si = 0; si < NS; ++si) {\n    seed = fract(seed);\n    vec3 O,D;\n\n    t = iTime - hash(seed+=.01) * iTimeDelta;\n    vec2 dp = vec2(hash(seed+=.1), hash(seed+=.2));\n    \n    vec3 at = vec3(uv, fov) * foc;\n    O = vec3(dp * ls, 0.);\n    D = normalize(at - O);\n    \n    vec3 S=vec3(1., 1.1, 10.), DS=vec3(2.);\n    //O += vec3(.1 + .4*sin(t*.17 + ffti(.3)*.1), .4, 5.);\n    \n    float tp = t / 2.;\n    float tc = floor(tp);\n    float tct = /*1. -*/ pow(fract(tp), 1.);\n    \n    vec3 o0 = S * .9 * (1. - 2. * vec3(hash(tc   ),hash(tc+ .1),hash(tc+ .2)));\n    vec3 o1 = S * .9 * (1. - 2. * vec3(hash(tc+1.),hash(tc+1.1),hash(tc+1.2)));\n\n    O += mix(o0, o1, tct);\n    \n    D.xz *= rot(-.3 + .2 * (1. - 2. * mix(hash(tc+.3), hash(tc+1.3), tp)));\n    D.yz *= rot(-.2 + .3 * (1. - 2. * mix(hash(tc+.5), hash(tc+1.5), tp)));\n    D.xy *= rot(-.1 + .4 * (1. - 2. * mix(hash(tc+.6), hash(tc+1.6), tp)));\n    D = normalize(D);\n    //D.yz *= rot(-.2);\n\n\n    S *= sign(D);\n    DS *= sign(D);\n    \n    //C += circ(uv);\n    for (float ip = 0.; ip < 2.; ++ip, S+=DS) {\n      C += plane(O.y, D.y, S.y, O.xz, D.xz, 0.);\n      C += plane(O.x, D.x, S.x, O.yz, D.yz, 1.);\n      C += plane(O.z, D.z, S.z, O.xy, D.xy, 2.);\n    }\n  }\n  \n  C /= float(NS);\n  \n\t//out_color = vec4(sqrt(C), 0.);\n    fragColor = vec4(sqrt(C), 0.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}