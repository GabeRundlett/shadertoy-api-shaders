{
    "Shader": {
        "info": {
            "date": "1719246340",
            "description": "Quaternion Julia set rendered using ray-marching",
            "flags": 0,
            "hasliked": 0,
            "id": "X3cSzj",
            "likes": 2,
            "name": "Raymarcher Julia",
            "published": 3,
            "tags": [
                "raymarchingjuliaset"
            ],
            "usePreview": 0,
            "username": "bandrieu",
            "viewed": 124
        },
        "renderpass": [
            {
                "code": "//vec3 light = vec3(-1,0,.5);//-0.7, 0.5, 1);\n//vec3 light = vec3(-1,-0.1,0.2);//-0.7, 0.5, 1);\n\n//vec3 light = vec3(-1,1,1);\nvec3 light = vec3(-1,-1,1);\n\nfloat PI = 4.*atan(1.);\n\nvec4 cfunc()\n{\n    vec4 c;\n    \n    \n    float fx = 4.34558732;\n    float fy = 6.23489327;\n    float fz = 2.95732852;\n    float fw = 7.49395834;\n    vec4 f = vec4(fx, fy, fz, fw);\n    \n    f *= 0.2;\n    \n    \n    c.x = cos(f.x*iTime);\n    c.y = cos(f.y*iTime);\n    c.z = cos(f.z*iTime);\n    c.w = cos(f.w*iTime);\n    \n    c /= length(c);\n    \n    vec4 s = vec4(0.5);\n    \n    s.x *= cos(iTime);\n    s.z *= sin(iTime);\n    \n    c *= s;\n    \n    \n    c = vec4(-0.125,-0.256,0.847,0.0895);\n    \n    return c;\n}\n\nvec4 quat_mult(in vec4 a, in vec4 b)\n{\n    vec4 ab;\n    \n    ab.x = a.x*b.x - dot(a.yzw, b.yzw);\n    ab.yzw = a.x*b.yzw + b.x*a.yzw + cross(a.yzw, b.yzw);\n    \n    return ab;\n}\n\nint julia_iterations(inout vec4 q, inout vec4 dq, in vec4 c, in int max_iter, inout vec4 t)\n{\n    float x0 = 0.;\n    float y0 = 0.;\n    float z0 = 1.;\n    \n    for (int iter = 0; iter < max_iter; iter++) {\n        dq = 2.*quat_mult(q, dq);\n        q = c + quat_mult(q, q);\n        \n        t.x = min(t.x, abs(q.x - x0));\n        t.y = min(t.y, abs(q.y - y0));\n        t.z = min(t.z, abs(q.z - z0));\n        t.w = min(t.w, length(q));\n\n        if (length(q) > 4.) {\n            return iter + 1;\n        }\n        \n    }\n    return 0;\n}\n\nfloat eval_julia4d(in vec3 p, out vec4 trap)\n{\n    const int max_iter = 20;//40;//60;\n    //vec4 c = vec4(-0.08, 0.0, -0.8, -0.03) + 0.05*iTime;\n    //vec4 c = vec4(-0.8, 0, -0.08, 0) - 0.11 + 0.05*iTime;\n    //vec4 c = vec4(-0.8, 0, -0.8, 0);\n    //c.xz += 0.01*3.58 + 0.05*14.48 + 0.05*iTime;\n    vec4  q = vec4(p.x, p.y, p.z, 0);\n    vec4 dq = vec4(1, 0, 0, 0);\n    \n    vec4 c = cfunc();\n    \n    trap = vec4(1, 1, 1, 1) * 1e6;\n    int stat = julia_iterations(q, dq, c, max_iter, trap);\n    \n    float mag_q  = length(q);\n    float mag_dq = length(dq);\n    float dist = 0.5 * mag_q * log(mag_q) / mag_dq;\n    \n    return dist;\n}\n\n/*\n( (x2+y2−0.852)2 + (z2−1)2 ) ∗\n((y2+z2−0.852)2+(x2−1)2) ∗ ((z2+x2−0.852)2+(y2−1)2)−0.001=0}\n*/\n\nfloat len2(in vec2 a)\n{\n    return a.x*a.x + a.y*a.y;\n}\n\nfloat sdf1(in vec3 p)\n{\n    //return length(p) - 0.2;\n    return \n    ( pow(len2(p.xy) - 0.852, 2.) * pow(p.z*p.z - 1., 2.) ) * \n    ( pow(len2(p.yz) - 0.852, 2.) * pow(p.x*p.x - 1., 2.) ) * \n    ( pow(len2(p.zx) - 0.852, 2.) * pow(p.y*p.y - 1., 2.) ) - 0.1;\n}\n\n//x4 + 2x2y2 + 2x2z2 + y4 + 2y2z2 + z4 + 8xyz − 10x2 − 10y2 − 10z2 + 20 = 0\nfloat sdf2(in vec3 p)\n{\n    return\n    pow(p.x, 4.) + pow(p.y, 4.) + pow(p.z, 4.) + \n    2.*(pow(p.x*p.y, 2.) + pow(p.y*p.z, 2.) + pow(p.z*p.x, 2.)) + \n    8.*p.x*p.y*p.z - 10.*dot(p, p) + 20.;\n}\n\nvec3 rotate(in vec3 v, in vec3 axis, in float angle)\n{\n    return v*cos(angle) + cross(axis, v)*sin(angle) + axis*dot(axis, v)*(1. - cos(angle));\n}\n\nfloat sdf(in vec3 p, out vec4 t)\n{\n    vec3 pr = rotate(p, vec3(0,0,1), iTime*0.2);\n    return eval_julia4d(pr, t);\n    return max(eval_julia4d(pr, t), -pr.y);\n    \n    //return length(p) - 1.;\n    float r2 = length(p);\n    float e = 4.;\n    float r4 = pow(pow(p.x, e) + pow(p.y, e) + pow(p.z, e), 1./e);\n    float ri = max(abs(p.x), max(abs(p.y), abs(p.z)));\n    vec3 q = p*r4/r2;\n    \n    float a = r2 * (1. + 0.1*iTime);\n    vec3 axis = p;\n    axis *= axis + p;\n    axis /= length(axis);\n    \n    q = rotate(q, axis, a);\n    \n    return eval_julia4d(q, t);\n    \n    \n    return max(cos(PI*length(q)), -p.y);\n\n    return length(q) - 1.;\n    return sdf2(p);\n    \n    float d1 = eval_julia4d(p, t);\n    //return d1;\n    float d2 = p.y;\n    \n    \n    float d3 = max(d1, -d2);\n    return d3;\n    /*float d1 = length(p) - 0.25;\n    float d2 = length(p - vec3(-0.1,-0.1,0.1)) - 0.125;\n    return max(d1, -d2);*/\n}\n\nvec3 normal(in vec3 p, in float z)\n{\n    float h = 1e-4 * z;\n    \n    vec4 t;\n    \n    float d1 = sdf(vec3(p.x + h, p.y - h, p.z - h), t);\n    float d2 = sdf(vec3(p.x - h, p.y - h, p.z + h), t);\n    float d3 = sdf(vec3(p.x - h, p.y + h, p.z - h), t);\n    float d4 = sdf(vec3(p.x + h, p.y + h, p.z + h), t);\n    \n    vec3 n = vec3(d1 - d2 - d3 + d4, -d1 - d2 + d3 + d4, -d1 + d2 - d3 + d4);\n    n /= length(n);\n    \n    return n;\n}\n\nfloat soft_shadow(in vec3 ray_origin, in vec3 ray_direction, in float k)\n{\n    float res = 1.;\n    float t   = 0.;\n    vec4 trap;\n    \n    for (int i = 0; i < 64; i++) {\n        float h = sdf(ray_origin + t*ray_direction, trap);\n        res = min(res, k*h/max(t, 1e-30));\n        if (res < 1e-3) break;\n        t += clamp(h, 1e-2, 0.2);\n        \n    }\n    return clamp(res, 0., 1.);\n}\n\n\nint ray_march(in vec3 ray_origin, in vec3 ray_direction, out float z, out vec3 n, out float s, out vec3 p, out vec4 t)\n{\n    const int max_iter = 200;\n    const float step_factor = 0.8;\n    const float eps_step = 1e-6;\n    const float far = 100.;\n    \n    vec3 rd = ray_direction/length(ray_direction);\n    \n    p = ray_origin;\n    \n    int stat = 0;\n    \n    z = 0.;\n    \n    for (int iter = 0; iter < max_iter; iter++) {\n        float dist = sdf(p, t);\n        \n        float step_size = dist * step_factor;\n        \n        if (step_size < eps_step) {\n            stat = iter+1;\n            break;\n        }\n        \n        p += step_size*rd;\n        \n        z += step_size;\n        \n        if (z > far) {\n            stat = -(iter+1);\n            break;\n        }\n    }\n    \n    n = normal(p, z);\n    \n   \n    light /= length(light);\n    \n    s = soft_shadow(p + 1e-3*z*n, light, 32.);\n    \n    return stat;\n}\n\nvec3 phong(in vec3 light, in vec3 eye, in vec3 pos, in vec3 normal, in vec3 diffuse, in float specularity)\n{\n    float specularExponent = 8.;\n    \n    vec3 l = light;// - pos;\n    l /= length(l);\n    \n    vec3 e = eye - pos;\n    e /= length(e);\n    \n    float ndotl = dot(normal, l);\n    vec3  r     = 2.*ndotl*normal - l;\n    \n    return diffuse * max(ndotl, 0.) + specularity*pow(max(dot(e, r),0.), specularExponent);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*vec3 CameraPosition   = vec3(-4.834987445122383, -2.537701093986909, 0.8728160380768178);\n    vec3 CameraFocalPoint = vec3(1.915184597066479, 1.1531878958487949, -0.10643989352606119 + 0.7);\n    vec3 CameraViewUp     = vec3(0.006393707051345064, 0.24549869101349586, 0.9693758369284855);\n    float CameraViewAngle = 26.0;*/\n    \n    /*vec3 CameraPosition   = vec3(-0.9179494327213386, -0.4525010104906535, 0.43285558421922027);\n    vec3 CameraFocalPoint = vec3(0.11445259035616803, 0.05656067379659292, 0.21978019538544788);\n    vec3 CameraViewUp     = vec3(0.07710313000707185, 0.2478498975889743, 0.965725393478005);\n    float CameraViewAngle = 120.0;*/\n    \n    /*vec3 CameraPosition   = vec3(-0.7922684278814051, -0.6396971518530031, 0.4447577521167551 + 0.4);\n    vec3 CameraFocalPoint = vec3(0.1084300758510455, 0.07286043047203916, 0.21803599701640816 + 0.4);\n    vec3 CameraViewUp     = vec3(0.05965772088460955, 0.23340002231857188, 0.970549012631791);\n    float CameraViewAngle = 30.0;*/\n    \n    /*CameraPosition += 0.5*(CameraPosition - CameraFocalPoint);\n    CameraPosition.x -= 1.;*/\n    \n    /*vec3  CameraPosition   = vec3(-20,0,0);\n    vec3  CameraFocalPoint = vec3(0);\n    vec3  CameraViewUp     = vec3(0,0,1);\n    float CameraViewAngle  = 36.0;*/\n    \n    vec3 CameraPosition   = vec3(-4.834987445122383, -2.537701093986909, 0.8728160380768178);\n    vec3 CameraFocalPoint = vec3(1.915184597066479, 1.1531878958487949, -0.10643989352606119);\n    vec3 CameraViewUp     = vec3(0.006393707051345064, 0.24549869101349586, 0.9693758369284855);\n    float CameraViewAngle = 50.0;\n\n    \n    vec3 camera_x;\n    vec3 camera_y = CameraViewUp;\n    vec3 camera_z = CameraPosition - CameraFocalPoint;\n\n    camera_y /= length(camera_y);\n    camera_z /= length(camera_z);\n    camera_x = cross(camera_y, camera_z);\n    camera_x /= length(camera_x);\n    \n    int AA_factor = 2;\n    \n    \n    float screen_distance = 0.5/tan(0.5*CameraViewAngle * 3.1415926535897931/180.);\n    vec3 screen_origin = CameraPosition - screen_distance*camera_z;\n    \n    float inv = 1./max(iResolution.x, iResolution.y);\n    float invAA = 1./float(AA_factor);\n    \n    float weight = invAA*invAA;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy - 0.5;\n    vec2 uv0 = fragCoord*inv;// - 0.5;\n    uv0.x -= 0.5;\n    uv0.y -= 0.5*iResolution.y/iResolution.x;\n    \n    float z = 0.;\n    vec3  n = vec3(0, 0, 0);\n    float s = 0.;\n    vec3  p = vec3(0, 0, 0);\n    vec4  t = vec4(0, 0, 0, 0);\n    float c = 0.;\n    \n    vec2 uv;\n    for (int ii = 0; ii < AA_factor; ii++) {\n    \n        uv.y = uv0.y + ((float(ii)+0.5)*invAA - 0.5)*inv;\n        \n        for (int jj = 0; jj < AA_factor; jj++) {\n        \n            uv.x = uv0.x + ((float(jj)+0.5)*invAA - 0.5)*inv;\n\n            vec3 ray_direction = screen_origin + uv.x*camera_x + uv.y*camera_y - CameraPosition;\n\n\n            float _z;\n            vec3  _n;\n            float _s;\n            vec3  _p;\n            vec4  _t;\n            \n            int stat = ray_march(CameraPosition, ray_direction, _z, _n, _s, _p, _t);\n            \n            z += weight*_z;\n            n += weight*_n;\n            s += weight*_s;\n            p += weight*_p;\n            t += weight*_t;\n            c += weight*float(stat);\n        }\n    }\n    \n    n /= length(n);\n    \n    //z = sdf(vec3(uv.x, 0, uv.y));\n    \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float dot_light = clamp(dot(n, light), 0., 1.);\n    float ambient = 0.3;\n    //vec3 col = (2.*vec3(p.x,p.y,p.z) + 1.) * 0.7;\n    //vec3 col = smoothstep(1., 0., clamp(t.zxy, 0., 1.));//0.5*(n + 1.);\n    \n    vec3 col = vec3(1,.2,.2) * 0.95;\n    //col *= dot_light * (ambient + (1.-ambient)*s);// * clamp(n.z, 0., 1.) + 0.5/z;//(1. - z/100.);\n    float specularity = 0.2;\n    col = phong(light, CameraPosition, p, n, col, specularity);\n    col *= ambient + (1.-ambient)*s;\n\n\n    vec3 col_top    = vec3(0.2,0.3,0.4);\n    vec3 col_bottom = vec3(0.4,0.45,0.6);\n    \n    float v = fragCoord.y/iResolution.y;\n    vec3 bg = (1.-v)*col_bottom + v*col_top;\n    \n    float mask = smoothstep(1., 0., z/100.);\n    \n    //col = 0.5*(cos(5.*t.wxy) + 1.);\n    \n    col = (1. - mask)*bg + mask*col;\n    \n    //col = 0.5*(p + 1.);\n    \n    //col = vec3(clamp(abs(c)/300.,0.,1.));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}