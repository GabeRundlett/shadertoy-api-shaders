{
    "Shader": {
        "info": {
            "date": "1491743134",
            "description": "improving precision and performance of https://www.shadertoy.com/view/lsjyzR#\n\nhigh precision in a front end display is rather silly.\nin general you are better off with this most recent notable link collection:\nhttps://www.shadertoy.com/view/MtyXDV",
            "flags": 0,
            "hasliked": 0,
            "id": "Ms2cWz",
            "likes": 5,
            "name": "010 text AVERAGE fps2",
            "published": 3,
            "tags": [
                "text",
                "debug",
                "fps",
                "float",
                "glyph",
                "debugging",
                "decimal",
                "base10"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 732
        },
        "renderpass": [
            {
                "code": "//this is improving\n//https://www.shadertoy.com/view/lsjyzR#\n//in precision and performance\n//it dares to such the boundaries of floating point percission.\n//way past 5 decimals, \n//which is were reasonable people would stop using only 16 bit float.\n\n//got a performance boost with code from https://www.shadertoy.com/view/MtyXDV\n\n//this code is bad at displaying large values in the 2billions.\n//because it insists on tpe float for large values, \n//resulting in rounding such large integers down.\n//\n//this is becase i assume most fragment shader impllementations \n//will do type float FASTER than integer divisions of integers >1million.\n//and i just do not use type int anywhere in here.\n\n//this funcion is important to avoid SOME rounding errors \n//that can result in \"out of bound\" glyphs that will be caught by clamp(digit,0,9))\n//but then still display the wrong glyph due to \"cascading rounding up\".\n//at roughly the 5th decmal place of values like -78987.8889999999;\nfloat powf(float i){\n //if (i<-8.)return pow(10.,floor(i));\n //line makes makes no difference because for that range you have MUCH different issues first.\n if (i>-1.){\n  if(i>3.){\n   if(i>5.){\n    if(i>6.)return 1e7;return 1e6;}else{\n    if(i>4.)return 1e5;return 1e4;}}else{\n   if(i>1.){\n    if(i>2.)return 1e3;return 1e2;}else{\n    if(i>0.)return 1e1;return 1e0;}}}else{\n  if(i>-5.){\n   if(i>-3.){\n    if (i>-2.)return 1e-1;return 1e-2;}else{\n    if (i>-4.)return 1e-3;return 1e-4;}}else{\n   if(i>-6.){\n    if (i>-6.)return 1e-5;return 1e-6;}else{\n    if (i>-8.)return 1e-7;return 1e-8;}}}}\n\n//based on \n//https://www.shadertoy.com/view/XsfyDl          =leading zeroes, other precision boons\n//https://www.shadertoy.com/view/lsfcRX          =bufferless bitmap-font version\n//https://www.shadertoy.com/view/4ltXDf          =font texture\n//https://www.shadertoy.com/view/MsXyzX          =less branching for above\n//based on https://www.shadertoy.com/view/Mt2GWD =log10 stuff for decimal spacing\n\n//core function is floatShow()\n//should be easy to modify to show cursor.xy or values of matrices.\n\n//change for a quick test, changes the GREEN text:\nconst float demo=-78987.8889999999;//-3.14159265358979;//-7.12345;\n//rounding errors are still pretty bad, and gets worse for larger abs(value)s\n//such is the bane of 16 bit floating points.\n//this is nt so much an error of this code.\n//but due to low precision of float.\n//does not do a cascading rounding-up of values like 9.9999 when only displaying 3 decmals of that.\n\n//only shows [glyphs] decimals left of the decimal point.\n//only shows min(4,[glyphs]) decimals right of the decimal point. (5th rounds poorly)\nconst float glyphs =11.;//max glyphs\n//Sets loop iterations.\n//is used in 2 loops, cycling that often,\n//..once for whats left of the decimal point, once for whats right of the decimal point\n\n//transparent border around glyphs that\n//replaces thin border of glyph with transparency, does not add whitespace.\nconst float marginT=1.;//if (marginG==1. && small text scale) neigbors can bleed trough.\n//marginT gets obsoleted by [p<-clamp(p,0.,1.)] within char()\n\n//#define div0\n//some compilers may just cry and may refuse to compile shit or just return a black screen.\n#ifdef div0\n//for openGl division by 0 case handling of type float.\nconst float NaN= 0./0.;\nconst float Inf= 1./0.;\nconst float NIn=-1./0.;\nconst float Po0= pow(0.,0.);\n//pow(0.,0.) should be \"ndef\" or \"NaN\", but is \"0.\" (or \"1.\") depending on hardware.\n#endif\n\n//bounding-box-calculation.Start:\n//return if a vec2() is within a bounding box==within a characters space.\n#define lt(a) lessThan(vec2(-1.),a)\nbool whiteRectangle(vec2 u){\n bvec2 a=lessThan(vec2(-1.),-abs(u));//bvec2 a=greaterThan(vec2(.1), uv); \n return (a.x&&a.y);}//inspired by https://www.shadertoy.com/view/ldScRm\n//bool whiteRectangle2(vec2 i){bvec2 a=lt(-i),b=lt(i);//symmetry--:\n// return (a.x&&a.y)&&(b.x&&b.y);}//inspired by https://www.shadertoy.com/view/ldScRm\nbool isInside3(vec2 p){return !whiteRectangle(p*2.-1.);}\n/*\n//below is same, using type float, for no good reasoon other than being worse alternatives.\n//return distance to square, center at [0:0], corners are at [+-.5:+-.5]\nfloat isOutside(vec2 p){float o=.5;//diagonally offset the squares center away from [0:0].\n vec2 d=abs(p-o)-.5;return max(d.x,d.y);}\n//making \"out of bounds\" check branchless:\nfloat isInside2(vec2 p){\n return step(isOutside(p),0.);//fastest, less sub()s than ifb(isInside(p),1.,0.)\n //return ifb(isOutside(p),0.,1.);//faster\n //if (isOutside(p)>0.)return 0.;return 1.;//fast\n //if (p.x<0.||p.x>1.||p.y<0.||p.y>1.)return 0.;return 1.;//slower\n}\n*/\n//bounding-box-calculation.End:\n\n// --- access to the image of ascii code c\nvec4 char(vec2 p,float c){\n  if(isInside3(p*marginT))return vec4(0,0,0,1e5); //optional shortcut...\n    //+3fps max, boost declines over time down to +1 fps (base fps is 50 fps)\n  return texture(iChannel0,clamp(p,0.,1.)/16.+fract(floor(vec2(c,16.-(1e-6)-floor(c)/16.))/16.));\n}//via https://www.shadertoy.com/view/MtyXDV\n//above seems to be much better than below: above even makes \"isinside\" optional.\n/*\nvec4 charO(vec2 p, int C) {\n  //by using [clamp(p,0.,1.)] instead of [p]...\n  //...all \"isinside\" becomes an OPTIONAL shortcut branch \n    \n  //if(isInside3(p*marginT))return vec4(0,0,0,1e5);       //type bool  -> 50.5 fps\n  //if(isInside2(p*marginT)==0.)return vec4(0,0,0,1e5); //type float -> 50.0 fps\n  //strangely, for both above, totalAverageFps lowers over time, approaching their limits.\n  //strangely, the limits heavily depend on what moment you start on,\n  //... if you scale textsinusoidial over time, without approaching the same limits over time.\n    \n  return texture(iChannel0,clamp(p,0.,1.)/16.+fract(vec2(C,15-C/16)/16.));\n  //return textureLod( iChannel0, p/16. + fract( vec2(C, 15-C/16) / 16. ) , \n  //                   log2(length(fwidth(p/16.*iResolution.xy))) );\n    //return textureGrad( iChannel0, p/16. + fract( vec2(C, 15-C/16) / 16. ) , \n    //                   dFdx(p/16.),dFdy(p/16.) );\n    //textureGrad() results in the decimal, and everything after the decimal, being blurrier than the rest.\n    //more apparent with post processing \n}\n// possible variants: (but better separated in an upper function) \n//     - inout pos and include pos.x -= .5 + linefeed mechanism\n//     - flag for bold and italic \n*/\n#define ch(n) char(p,n).x;p.x-=.5;\n\n\n//p=fragment, n=float value\nvec4 print_number(vec2 p,float n){\n   return char(p,clamp(mod(n,10.),0.,9.)+48.);}\n   //return char(p,int(floor(mod(n*10.,10.)))+48);}\n   //return char(p,int(fract(n)*10.)+48);}//actually rounds differently\n//vec4 print_number(vec2 p,float n){return char(p,int(mod(n*10.,10.))+48);}\n//alternatively use mod():  int(floor(mod(n,10.)));\n\n//#define logb(b,x) log(x)/log(b)\nconst float l10=(1./log(10.));//precalc for speed\n#define log10(x) log(x)*l10\n//#define log10(x) logb(10.,x)//would be slower, log() is slow.\n//http://stackoverflow.com/questions/14081024/opengl-using-a-logarithmic-coordinates-axis\n\n//return number of digits left of decimal point\nfloat getWholeDigits(float f){if(abs(f)==0.)return 0.;return floor(log10(max(abs(f),0.0000001)))+1.;}\n//see http://stackoverflow.com/questions/1068849/how-do-i-determine-the-number-of-digits-of-an-integer-in-c\n//to remember that dumb|raw solutions can often outperform smart solutions.\n\n\n\n//left==digits left to the decimal point, relevant for other text being left-endian.\n//commonly left=getWholeDigits(abs(number));\n//and you can add one leading zero by \n// left=getWholeDigits(abs(number))+1.;\n//right==digits right of the decimal point (todo, fix pathethic rounding errors)\n//w returns the total width of the float in glyphs.\nvec4 floatShow(vec2 p,float f,float left,float right,out float w){vec4 o=vec4(0); \n w=p.x;\n#ifdef div0\n #define ro w-=p.x;return o;}\n if(f==NaN){     o+=ch( 78)o+=ch( 97)o+=ch( 78)ro//Nan //  0./0.\n else if(f==Inf){o+=ch( 73)o+=ch(110)o+=ch(102)ro//Inf // +1./0.;\n else if(f==NIn){o+=ch(126)o+=ch( 73)o+=ch(110)ro//~In // -1./0.\n#endif\n if(f<.0){f=abs(f);o+=ch(45.)}//negative number handling:\n //f=abs(f);//double safe, because x>0 for log(x);\n //must also catch all cases of log(0) !!!\n float n=left;\n //loop displays \"left\" digits left to the decimal point:\n                \n for(float i=glyphs;i>-1.;i--){ \n  if(left<1.){o+=print_number(p,0.).x;p.x-=.5;break;}\n  float ex=-i-n+glyphs+1.;\n  //ex=max(0.,ex);\n  float n=pow(10.,ex);if(abs(n)>0.){\n   o+=print_number(p,f*n).x;p.x-=.5;}\n  left--;if(left<=0.)break;}\n //decimal point shifting,making \".\" non-fixedwidth:\n f=fract(f);//=mod(f,1.);//=1.-floor(f);//adds rounding errors.\n p.x+=.1;\n o+=char(p,46.).x;p.x-=2.5-.1; //44->\",\" :: 46->\".\"\n p.x+=2.;\n //digits right of the decimal point:\n float decimals=right;\n //f=mod(f,1.);//=1.-floor(f);//adds rounding errors.\n //less errors in onstants?\n for(float i=decimals;i>0.;i--){\n  float n=\n  //pow(10.,decimals-i+1.);\n    powf(   decimals-i+1.);\n    //n=1e9;//this overwrite shows that above function is not the culpit.\n  o+=print_number(p,f*n).x;p.x-=.5;\n }w-=p.x;return o;}\n\n         \n\n\n//mainImage2() to have this as completely optional numeric display layer.\nvoid mainImage2(out vec4 o,vec2 p){\n p/=iResolution.y;\n p *= 16.2+sin(iTime);//scale text smaller\n //disregarding above scaling:\n //p.x-=.5 moves the \"cursor\" 1 glyph to the right\n //p.x+=.5 moves the \"cursor\" 1 glyph to the left\n //p.y-=1. moves the \"cursor\" 1 glyph to the bottom \n //p.y+=1. moves the \"cursor\" 1 glyph to the top \n //as we \"move the paper\", and we do not not move the typewriter.\n \n //iTime, time in white\n p.x -=4.;//p.x-= shifts cursor sideways.\n float left = getWholeDigits(abs(iTime));\n //left+=2.;    //adding 2 leadig zeroes\n //left=8.-left;//fixedwidth (character count), replacing spacing with leadig zeroes\n float w=0.;//will get width (as glyphs) of a float stored in it.\n o+=floatShow(p,iTime,left,10.,w).x;\n p.x-=w;\n o+=ch(115.)//s\n     \n //average total fps in red:\n p.x-=.5;\n float fpsTotal=float(iFrame);//totalAverage fps=totalFrames/totalSeconds\n if(iTime>0.)fpsTotal/=iTime;\n //if(pause time and rewind)\n //...shadertoy has an issue with the values for the very first frame?\n //...cant even tll if i is ==0./0. or ==1./0.;\n //if (iTime<.1)fpsTotal==1.;//overwriting doesnt even fix that\n left = getWholeDigits(abs(fpsTotal));\n o.xw+=floatShow(p,fpsTotal,left,2.,w).x; \n p.x -=w;\n o.xw+=ch(102.)o.xw+=ch(112.)o.xw+=ch(115.)//fps\n \n //single frame fps in blue\n p.x -=.5;\n \n float fpsFrame=iTimeDelta;//single frame fps, highly varies over time\n if(abs(fpsFrame)>0.){\n  fpsFrame=1./fpsFrame;\n  left=getWholeDigits(abs(fpsFrame));\n  o.yzw+=floatShow(p,fpsFrame,left,2.,w).x; \n }else {fpsFrame=0.000001;left=2.;}\n  //above error case is for when a frame claim that \n  //iTimeDelta is not set, as if a frame was calculated instantly or tripple buffered or queued?\n p.x -=w;   \n o.yzw+=ch(102.)o.yzw+=ch(112.)o.yzw+=ch(115.)//fps\n \n p+=vec2(10.4,-6.);\n float dem=demo-iTime;\n p.y+=1.;left=getWholeDigits(abs(dem));o.yw+=floatShow(p,dem,left,8.,w).x; \n //all rounding errors should almost only be floating point percision errors.\n //as it only does minimal mod(a*1eX*10,10) to address a glyph.\n     \n #ifdef div0\n //testing bounds of floats for divisions by 0, will appear dark blue\n //usurprisingly divisions by 0 result in some shit.\n //especially with my cheap hanling for these cases.\n //\"NaN\",\"infinity\" and \"negInfinity\" are not caught b my ==0. filter before applying log()\n //and log() does strange shit with these values:\n  #define divn(a) p.y+=1.;left=getWholeDigits(abs(a));o.zw+=floatShow(p,a,left,2.,w).x; \n  divn(NaN) divn(Inf) divn(NIn) divn(Po0)\n  p.x-=w+.2;\n  o.zw+=ch(112)o.zw+=ch(111)o.zw+=ch(119)//pow\n  o.zw+=ch(40)//(\n  o.zw+=ch(48)o.zw+=ch(44)o.zw+=ch(48)//0,0\n  o.zw+=ch(41)//)\n #endif  \n  \n  p.y*=2.5;p.x=length(p);if(p.x<.3)o+=.5;//add circle that shoes \"cursor\" position.\n  \n  //post processing \n  //to test gradients and borders. not to look pretty\n  o*=.5*(smoothstep(0.,1.,o.w));\n  vec4 v=vec4(sin(iTime*acos(-1.)*2.-asin(1.))*.5+.6);\n  v=max(v,vec4(0));\n  o=pow(o,v);\n  o=max(o,vec4(0));\n  //above sin(t) makes bloom most intense while remainer of iTime is close to 0.\n  //... ==1 hz sinusoid, wavelength = 1 second.\n  o=sqrt(o);//cheapest cubic bloom    \n}\n\n\n///--end of mainimage2 content, start of its mainimage() container:\nvoid mainImage(out vec4 c,vec2 i){\n mainImage2(c,i);//number overlay\n c.z+=sin(199.*length(i/iResolution.xy))*.2;   //ring waves.\n c+=.2*texture(iChannel0,i/iResolution.xy).x;//display glyph distance field\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}