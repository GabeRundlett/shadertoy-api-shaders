{
    "Shader": {
        "info": {
            "date": "1452074148",
            "description": "Use a chroma key to create an alpha mask, and then uses that alpha mask to texture a 3D object and create shadows. There's some oddities sometimes, but I'm pretty happy with the results.",
            "flags": 32,
            "hasliked": 0,
            "id": "lsd3DB",
            "likes": 10,
            "name": "JCVD 3D",
            "published": 3,
            "tags": [
                "3d",
                "shadow",
                "lighting",
                "raymarcher",
                "mask",
                "alpha",
                "composite",
                "jcvd"
            ],
            "usePreview": 0,
            "username": "jackdavenport",
            "viewed": 1961
        },
        "renderpass": [
            {
                "code": "#define MAX_ITERATIONS 256\n#define MIN_DISTANCE  .001\n#define LIGHT_DIR normalize(vec3(45.,60.,-45.))\n\nstruct Ray { vec3 ori; vec3 dir; };\nstruct Dist { float dst; int id; };\nstruct Hit { vec3 p; int id; };\n  \n// Source: http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand(vec2 co) {\n    \n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\n}\n\nvec2 rot2D(vec2 p, float angle) {\n\n\tfloat s = sin(radians(angle));\n\tfloat c = cos(radians(angle));\n\treturn p * mat2(c,-s,s,c);\n\n}\n\nDist distBox(vec3 p, vec3 pos, vec3 box) {\n\n\treturn Dist(length(max(abs(pos - p) - box,0.)), 0);\n\n}\n\nDist distFloor(vec3 p, float y) {\n\n\treturn Dist(p.y - y, 1);\n\n}\n\nDist minDist(Dist a, Dist b) {\n\n\tif(a.dst < b.dst) {\n\t\n\t\treturn a;\n\t\n\t}\n\t\n\treturn b;\n\n}\n\nDist distScene(vec3 p) {\n\n\tDist d = distFloor(p, -0.1);\n\td = minDist(d, distBox(p, vec3(1.,1.,3.), vec3(1.,1.,0.05)));\n\n\treturn d;\n\n}\n\nHit raymarch(Ray ray) {\n\n\tvec3 p = ray.ori;\n\tint id = -1;\n\t\n\tfor(int i = 0; i < MAX_ITERATIONS; i++) {\n\t\n\t\tDist dst = distScene(p);\n\t\tp += ray.dir * dst.dst;\n\t\t\n\t\tif(dst.dst < MIN_DISTANCE) {\n\t\t\n\t\t\tid = dst.id;\n\t\t\tbreak;\n\t\t\n\t\t}\n\t\n\t}\n\t\n\treturn Hit(p,id);\n\n}\n\nvec3 calcNormal(vec3 p) {\n\n\tvec2 eps = vec2(.001,0.);\n\tvec3 n = vec3(distScene(p + eps.xyy).dst - distScene(p - eps.xyy).dst,\n\t\t\t\t  distScene(p + eps.yxy).dst - distScene(p - eps.yxy).dst,\n\t\t\t\t  distScene(p + eps.yyx).dst - distScene(p - eps.yyx).dst);\n\treturn normalize(n);\n\t\n}\n\nvec4 shadeJCVD(Hit scn, Ray ray, vec3 n) {\n \n    vec2 uv = mod(scn.p.xy / 2., 1.) - vec2(.0,.0);\n    vec4 c  = texture(iChannel0, uv);\n    \n    if(dot(n,ray.dir) == 0.) {\n     \n        c.a = 0.;\n        \n    }\n    \n    return c;\n    \n}\n\nvec3 calcLighting(Hit scn, Ray ray, vec3 n, bool shadowOnly) {\n\n\tfloat diff = max(dot(LIGHT_DIR,n), 0.);\n\tif(shadowOnly) diff = 1.;\n    \n\tif(scn.id == 1) {\n\t\n\t\tRay sr = Ray(scn.p + LIGHT_DIR * .003, LIGHT_DIR);\n\t\tHit sh = raymarch(sr);\n\t\n\t\tif(sh.id == 0) {\n\t\t\n            vec4 t = shadeJCVD(sh,sr,calcNormal(scn.p));    \n\t\t\tdiff = mix(diff,0.,t.a);\n\t\t\n\t\t}\n\t\n\t}\n\n    return vec3(diff);\n\treturn (shadowOnly ? vec3(1.) : vec3(1.,.98,.9)) * diff;\n\n}\n\nvec3 shadeFloor(Hit scn, Ray ray) {\n \n    vec3 n = calcNormal(scn.p);\n    vec2 uv = mod(scn.p.xz / 2., 1.);\n    \n\treturn texture(iChannel1, ray.dir).xyz * calcLighting(scn,ray,n,true);\n    \n}\n\nvec3 shade(Ray ray) {\n\n\tHit scn = raymarch(ray);\n\tvec3 col = texture(iChannel1,ray.dir).xyz;\n\n\tif(scn.id == 0) {\n\t\n        vec3 n   = calcNormal(scn.p);\n        vec4 tex = shadeJCVD(scn,ray,n);\n\t\n        tex.xyz *= calcLighting(scn,ray,n,false);\n        \n        if(tex.a < 1.) {\n         \n            Ray ar = Ray(scn.p + ray.dir * .11, ray.dir);\n            Hit ah = raymarch(ar);\n            vec3 bg = ah.id == 1 ? shadeFloor(ah,ar) : col;\n            \n            tex.xyz = mix(bg,tex.xyz,tex.a);\n            \n        }\n        \n        col = tex.xyz;\n        \n\t} else if(scn.id == 1) {\n\t\n\t\tcol = shadeFloor(scn,ray);\n\t\n\t}\n    \n\treturn col;\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec2 uv = (fragCoord.xy - iResolution.xy / 2.) / iResolution.y;\n\tvec3 dir = vec3(uv, 1.);\n\t\n    //vec2 m = iMouse.xy / iResolution.xy;\n\t//dir.yz = rot2D(dir.yz, 15. * m.y);\n\t//dir.xz = rot2D(dir.xz, m.x * 15.);\n\t\n\tvec3 scn = shade(Ray(vec3(1.,1.,1.),dir));\n\tfragColor = vec4(scn, 1.);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            },
            {
                "code": "#define THRESHOLD .6\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    \n    vec3 diff = col.xyz - vec3(0.,1.,0.);\n    if(dot(diff,diff) < THRESHOLD) {\n     \n        col.a = 0.;\n        \n    }\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define BLUR_SIZE .01\n#define BLUR_SAMPLES 3\n\nfloat getBlurredAlpha(vec2 uv) {\n \n    float sum = 0.;\n    int iter = 0;\n    \n    for(int i = 0; i < BLUR_SAMPLES; i++) {\n    \n        //float div = float(i) + 1.;\n        float div = 1.;\n        sum += texture(iChannel0, uv).a;\n        sum += texture(iChannel0, uv + vec2(BLUR_SIZE,0.) / div).a;\n        sum += texture(iChannel0, uv + vec2(BLUR_SIZE,0.) / 2. / div).a;\n        sum += texture(iChannel0, uv + vec2(BLUR_SIZE,0.) / 4. / div).a;\n        sum += texture(iChannel0, uv + vec2(BLUR_SIZE,0.) / 6. / div).a;\n        sum += texture(iChannel0, uv + vec2(0.,BLUR_SIZE) / div).a;\n        sum += texture(iChannel0, uv + vec2(0.,BLUR_SIZE) / 2. / div).a;\n        sum += texture(iChannel0, uv + vec2(0.,BLUR_SIZE) / 4. / div).a;\n        sum += texture(iChannel0, uv + vec2(0.,BLUR_SIZE) / 6. / div).a;\n        \n        iter += 9;\n        \n    }\n    \n    return sum / float(iter);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    fragColor = texture(iChannel0, uv);\n    fragColor.a = getBlurredAlpha(uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}