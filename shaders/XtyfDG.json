{
    "Shader": {
        "info": {
            "date": "1543753848",
            "description": "TokyoDemoFest 2018 GLSL Graphics Compo 2nd place.",
            "flags": 0,
            "hasliked": 0,
            "id": "XtyfDG",
            "likes": 62,
            "name": "[TDF2018] Life",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "tdf"
            ],
            "usePreview": 0,
            "username": "setchi",
            "viewed": 2664
        },
        "renderpass": [
            {
                "code": "// Title: Life (TokyoDemoFest 2018 GLSL Graphics Compo 2nd place)\n// Copyright (c) 2018 setchi\n// License: Attribution-NonCommercial-ShareAlike (http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US)\n\nprecision highp float;\n\n#define SHADERTOY 1\n#define PI 3.141592654\n#define saturate(a) clamp(a, 0., 1.)\n#define range(a, b) (step(a, floor(time2)) * step(floor(time2), b))\n\nconst int maxIteration = 128;\nconst float fmaxIteration = float(maxIteration);\n\nuniform float time;\nuniform vec2 resolution;\n\nfloat time0, time1, time2, zoom, a;\nint iter;\n\nfloat box(vec3 p, float b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 hue(float hue) {\n    vec3 rgb = fract(hue + vec3(0., 2. / 3., 1. / 3.));\n    rgb = abs(rgb * 2. - 1.);\n    return clamp(rgb * 3. - 1., 0., 1.);\n}\n\nfloat hash11(float p) {\n    vec3 p3 = fract(vec3(p) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat2 rot1, rot2, rot3, rot4;\n\nvec2 ifs(vec3 p) {\n    float d1 = 999., d2 = 999.;\n    float range = .8, radius = .5 * (1. + zoom);\n\n    const float maxIter = 8.;\n    for (int i = int(maxIter); i > 0; i--) {\n        if (i <= iter) {\n            break;\n        }\n\n        float ratio = float(i) / maxIter;\n        float bx = box(p, radius * ratio);\n        d1 = mix(d1, min(d1, bx), float(i > iter + 1));\n        d2 = min(d2, bx);\n\n        ratio *= ratio;\n\n        p.xz = abs(p.xz) - range * ratio * .7;\n        p.xz *= rot1;\n        p.yz *= rot3;\n        p.yx *= rot2;\n\n        p.yz = abs(p.yz) - range * ratio * .7;\n        p.xz *= rot1;\n        p.yz *= rot4;\n        p.yx *= rot2;\n    }\n\n    return vec2(d1, d2);\n}\n\nfloat map(vec3 p) {\n    vec2 d = ifs(p);\n    return mix(d.y, d.x, mix(a, 1. - a, step(time0, 5.5)));\n}\n\nfloat calcAo(vec3 p, vec3 n) {\n    float sca = 1.0, occ = 0.0;\n\n    for (float i = 0.; i < 5.; i++) {\n        float hr = 0.05 + i * 0.08;\n        float dd = map(n * hr + p);\n        occ += (hr - dd) * sca;\n        sca *= 0.5;\n    }\n\n    return saturate(1.0 - occ);\n}\n\nvec3 intersect(vec3 ro, vec3 ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i < maxIteration; i++) {\n        float res = abs(map(ro + ray * t));\n        if (res < 0.005) return vec3(t, res, i);\n        t += res;\n    }\n\n    return vec3(-1.0);\n}\n\nvec3 normal(vec3 pos, float e) {\n    vec2 eps = vec2(1.0, -1.0) * 0.5773 * e;\n\n    return normalize(eps.xyy * map(pos + eps.xyy) +\n                     eps.yyx * map(pos + eps.yyx) +\n                     eps.yxy * map(pos + eps.yxy) +\n                     eps.xxx * map(pos + eps.xxx));\n}\n\nmat3 createCamera(vec3 ro, vec3 ta, float cr) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    \n    return mat3(cu, cv, cw);\n}\n\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(vec2 x) {\n\tvec2 i = floor(x), f = fract(x);\n\n\tfloat a = hash(i);\n\tfloat b = hash(i + vec2(1.0, 0.0));\n\tfloat c = hash(i + vec2(0.0, 1.0));\n\tfloat d = hash(i + vec2(1.0, 1.0));\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 p) {\n\tconst mat2 m2 = mat2(0.8, -0.6, 0.6, 0.8);\n\n\tp.xy += 0.1 * time1;\n\n\tfloat f = 0.5000 * noise(p); p = m2 * p * 2.02;\n\tf += 0.2500 * noise(p); p = m2 * p * 2.03;\n\tf += 0.1250 * noise(p); p = m2 * p * 2.01;\n\tf += 0.0625 * noise(p);\n\treturn f / 0.9375;\n}\n\nvec3 sky(vec3 ro, vec3 ray) {\n    vec3 col = vec3(0.);\n\n    float rd = ray.y + 0.3;\n    col = mix(col, vec3(2.0, 0.25, 2.0), 0.5 * smoothstep(0.5, 0.8, fbm((ro.xz + ray.xz * (250000.0 - ro.y) / rd) * 0.000008)));\n    col = mix(col, vec3(0.), pow(1.0 - max(rd, 0.0), 4.0));\n    \n    col = mix(vec3(0.), col, saturate(time1 * 3. - 4.));\n    col = mix(col, vec3(0.), saturate(time1 - 5.25));\n    return col * 1.3;\n}\n\n#define edge(start, end, sStart, sEnd, ecol) if (range(start, end) > 0.) { showEdge = 1.; float offs = pos.y - mix(sStart, sEnd, 0.025 + saturate(time2 - start)); edgeColor = ecol; edgeIntensity = mix(0., edgeIntensity, saturate(1. - abs(offs))); col = mix(col, objectColor, saturate(1. - (offs + 1.5))); }\n\nvec3 render(vec2 p) {\n    float t = time0 * 0.7 - 1.;\n    float offs = mix(1., hash11(max(1., floor(t * 4.))), smoothstep(0., .5, time0));\n    vec3 ro = vec3(cos(t * 3.5) * 11., sin(t * 3.9) * 4.5, sin(t * 1.5) * 10.) * 0.7;\n\n    t = time1 * 0.7;\n    offs = mix(mix(1., hash11(max(1., floor(t * 4.))), step(0., time1)), 1., step(4.6, time1));\n    ro = mix(ro, vec3(cos(t * 1.5) * 11. * offs, sin(t * 2.) * 4. * offs * 2., sin(t * 1.5) * 20. * offs) * 0.9, smoothstep(0.7, 1., time1));\n    ro = mix(ro, vec3(cos(t * 1.5) * 11., sin(t * 3.9) * 4., sin(t * 1.5) * 10.), smoothstep(4.6, 5.5, time1));\n    ro = mix(ro, vec3(5., 3., 5.), saturate(time1 - 6.7));\n\n    vec3 ta = vec3(0.0, 0.0, (sin(t * 0.55) * 0.5 + 0.5) * 2.0);\n    ta = mix(ta, vec3(0.), saturate(time1 - 6.7));\n\n    mat3 cm = createCamera(ro, ta, 0.);\n    vec3 ray = cm * normalize(vec3(p, 4.0));\n\n    vec3 res = intersect(ro, ray);\n    if (res.y < -0.5) {\n        return sky(ro, ray);\n    }\n\n    vec3 pos = ro + ray * res.x;\n    vec3 nor = normal(pos, 0.008);\n\n    float glowIntensity = saturate(pow(abs(1. - abs(dot(nor, ray))), 1.));\n    vec3 objectColor = (vec3(.003, .001, .0095)\n            * pow(1. / res.z * 1.5, -1.8) + glowIntensity * vec3(.1, .25, .3)) * res.x * 0.3\n            * calcAo(pos, nor)\n            + sky(ro, normalize(reflect(ray, nor))) * .4 * (1. - zoom);\n\n    float a = smoothstep(0.3, 0.7, pow(fract(time0 * 3.), 0.4));\n    float edgeThreshold = mix(0.02, 0.03, (1. - a) * (1. - zoom));\n    float edgeIntensity = smoothstep(edgeThreshold - 0.01, edgeThreshold, length(nor - normal(pos, .015)));\n\n    float noShade = range(-10., 3.);\n    vec3 col = mix(objectColor, vec3(0.), noShade);\n\n    float showEdge = 0.;\n    vec3 edgeColor = vec3(1.);\n    vec3 rainbow = hue(pos.z / 2.);\n    edge(3., 3.5, -2., 2.2, hue(abs(offs) / 5. + .5) * 2.)\n    edge(6., 6.5, -3.5, 2., rainbow)\n    edge(5., 5.5, -3.5, 2., rainbow)\n    edge(10., 10.5, -3.5, 2., rainbow)\n    edge(11.5, 12., -3.5, 2.4, rainbow)\n\n    if (time2 > 16.5) {\n        showEdge = 1.;\n        offs = pos.y - mix(-3.5, 4., saturate(time2 - 16.5));\n        col = mix(objectColor, vec3(0.), saturate(1. - offs));\n        edgeIntensity = mix(0., edgeIntensity, saturate(1. - (offs + .6)));\n    }\n\n    col += edgeColor * edgeIntensity * step(1., zoom + noShade + showEdge);\n    col = mix(col, 1. - col, zoom);\n    return col;\n}\n\nvec2 shake(float t) {\n    float s = t * 50.0;\n    return (vec2(hash11(s), hash11(s + 11.0)) * 2.0 - 1.0) * exp(-5.0 * t) * 0.2;\n}\n\nvec3 vignette(vec2 p) {\n    p *= 1.0 - p.yx;\n    return vec3(1.2, 1.1, .85) * pow(16. * p.x * p.y * (1. - p.x) * (1. - p.y), 0.125);\n}\n\nvoid entryPoint(in vec2 coord, in vec2 resolution, in float time, out vec4 color) {\n    vec2 p = (coord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n\n    time0 = mod(time * 0.4, 11.);\n    time1 = time0 - 11. / 4.;\n    time2 = time1 * 0.7 * 4.;\n\n    float t = time0 * 3.;\n    iter = int(mix(clamp(14. - floor(t), 0., 7.), min(8., floor(t) - 24.), step(24., floor(t))));\n    a = mix(1., smoothstep(0.3, 0.7, pow(fract(t), 0.4)), step(7.5, t));\n\n    t = time1 * 3.;\n    float angle = step(1.2, time1) * (floor(t + 0.5) + smoothstep(0.3, 0.7, pow(fract(t + 0.5), 0.4)));\n\n    rot1 = rot(0.785397);\n    rot2 = rot(1.7079);\n    rot3 = rot(angle * 1.2 + 424. + step(7.035716, time0) * 3.);\n    rot4 = rot(angle * 1.2 + 226.);\n\n    zoom = range(8., 9.) + range(11., 11.5);\n\n    p = mix(p, vec2(1. + hash11(p.y) * 10., p.y), saturate(time0 - 10.33) * 5.);\n    p += shake(fract(time1 * 2.)) * 0.10;\n    p *= 1.0 + 5. * pow(length(p), 1.5) * zoom;\n\n    vec3 col = render(p);\n    col *= vignette(coord.xy / resolution.xy);\n    col = mix(col, vec3(0.), saturate(time0 - 10.33) * 10. + step(time, 0.));\n\n    color = vec4(col, 0.);\n}\n\nvoid\n#if SHADERTOY == 1\nmainImage(out vec4 fragColor, in vec2 fragCoord) { entryPoint(fragCoord.xy, iResolution.xy, iTime, fragColor); }\n#else\nmain(void) { entryPoint(gl_FragCoord.xy, resolution.xy, time, gl_FragColor); }\n#endif\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}