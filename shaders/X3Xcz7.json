{
    "Shader": {
        "info": {
            "date": "1726520315",
            "description": "Textured, improved lighting, reflections, better shape than original (shadow bigger because of light position)",
            "flags": 32,
            "hasliked": 0,
            "id": "X3Xcz7",
            "likes": 3,
            "name": "Katana 2.0",
            "published": 3,
            "tags": [
                "sdf",
                "texture",
                "shadow",
                "lighting"
            ],
            "usePreview": 0,
            "username": "helloy90",
            "viewed": 64
        },
        "renderpass": [
            {
                "code": "// --------- Constants ---------\n\nconst float kPi = 3.14159265359;\n\nconst int kMaxSteps = 256;\nconst int kMaxShadowSteps = 32;\nconst float kPresicion = 0.001;\nconst float kMinDist = 0.0;\nconst float kMaxDist = 100.0;\n\nconst mat3 kIdentityMat = mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n);\n\n// --------- Structs ---------\n\nstruct Material {\n    vec3 ambient_color; // ambient reflection * ambient lighting\n    vec3 diffuse_color; // diffuse reflection * light intensity\n    vec3 specular_color; // specular reflection * specular light\n    float reflection;\n    float shininess;\n    int texture_id; // if -1 then no texture\n};\n\nstruct Surface {\n    int id;\n    float sd;\n    Material material;\n};\n\nstruct Light {\n    vec3 pos;\n    float intensity;\n};\n\n// --------- Materials ---------\n\nMaterial mGuard() {\n  vec3 aCol = 0.4 * vec3(0.8);\n  vec3 dCol = 0.3 * vec3(0.7);\n  vec3 sCol = 0.2 * vec3(1, 1, 1);\n  float ref = 0.01;\n  float a = 1.;\n  int tex_id = 1;\n\n  return Material(aCol, dCol, sCol, ref, a, tex_id);\n}\n\nMaterial mHandle() {\n  vec3 aCol = 0.5 * vec3(0.1);\n  vec3 dCol = 0.5 * vec3(0.4);\n  vec3 sCol = 0.6 * vec3(0);\n  float ref = 0.0;\n  float a = 1.;\n  int tex_id = 1;\n\n  return Material(aCol, dCol, sCol, ref, a, tex_id);\n}\n\nMaterial mBlade() {\n  vec3 aCol = 1.5 * vec3(0.7, 0, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0, 0);\n  vec3 sCol = 1.0 * vec3(1, 1, 1);\n  float ref = 1.5;\n  float a = 50.;\n  int tex_id = 0;\n\n  return Material(aCol, dCol, sCol, ref, a, tex_id);\n}\n\nMaterial mPlane(vec3 p) {\n  vec3 aCol = 0.4 * vec3(0.835, 1, 1);\n  vec3 dCol = 0.3 * vec3(1.0);\n  vec3 sCol = 0.0 * vec3(1.0);\n  float ref = 0.1;\n  float a = 1.0;\n  int tex_id = -1;\n\n  return Material(aCol, dCol, sCol, ref, a, tex_id);\n}\n\n// --------- Utils ---------\n\n// --- Rotations ---\n\nmat3 rotateX(in float angle) {\n    float angle_cos = cos(angle);\n    float angle_sin = sin(angle);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, angle_cos, -angle_sin),\n        vec3(0, angle_sin, angle_cos)\n    );\n}\n\nmat3 rotateY(in float angle) {\n    float angle_cos = cos(angle);\n    float angle_sin = sin(angle);\n    return mat3(\n        vec3(angle_cos, 0, angle_sin),\n        vec3(0, 1, 0),\n        vec3(-angle_sin, 0, angle_cos)\n    );\n}\n\nmat3 rotateZ(in float angle) {\n    float angle_cos = cos(angle);\n    float angle_sin = sin(angle);\n    return mat3(\n        vec3(angle_cos, -angle_sin, 0),\n        vec3(angle_sin, angle_cos, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nmat2 rotate2d(in float angle) {\n    float angle_cos = cos(angle);\n    float angle_sin = sin(angle);\n    return mat2(\n        vec2(angle_cos, angle_sin),\n        vec2(-angle_sin, angle_cos)\n    );\n}\n\n// --- SDF operations ---\n\nSurface opUnion(Surface first_sur, Surface second_sur) {\n    if (second_sur.sd < first_sur.sd) {\n        return second_sur;\n    }\n    return first_sur;\n}\n\nSurface opSmoothUnion(Surface first_sur, Surface second_sur, in float coeff) {\n    float h = clamp( 0.5 + 0.5 * (second_sur.sd - first_sur.sd) / coeff, 0.0, 1.0 );\n    return Surface(second_sur.id, mix(second_sur.sd, first_sur.sd, h) - coeff * h * (1.0 - h), second_sur.material);\n}\n\nSurface opIntersection(Surface first_sur, Surface second_sur) {\n    if (second_sur.sd < first_sur.sd) {\n        return first_sur;\n    }\n    return second_sur;\n}\n\nSurface opSmoothIntersection(Surface first_sur, Surface second_sur, in float coeff) {\n    float h = clamp( 0.5 - 0.5 * (second_sur.sd - first_sur.sd) / coeff, 0.0, 1.0 );\n    return Surface(second_sur.id, mix(second_sur.sd, first_sur.sd, h) + coeff * h * (1.0 - h), second_sur.material);\n}\n\nSurface opSubtraction(Surface first_sur, Surface second_sur) {\n    if (second_sur.sd > -first_sur.sd) {\n        return second_sur;\n    }\n    return first_sur;\n}\n\n\nfloat opRound(in float sdf, in float rad) {\n    return sdf - rad;\n}\n\n// --------- Metrics ---------\n\nfloat lengthInf(in vec2 vector) {\n    return max(abs(vector.x), abs(vector.y));\n}\n\nfloat lengthInf(in vec3 vector) {\n    return max(abs(vector.x), max(abs(vector.y), abs(vector.z)));\n}\n\n// --------- Primitives ---------\n\nfloat sdTriPrism(in vec3 pos, in vec2 h, in vec3 offset, in vec3 params, mat3 rotation, mat3 rotation_offset) {\n    pos = pos * rotation;\n    pos = (pos - offset) * rotation_offset;\n    vec3 q = abs(pos);\n    return max(q.z - h.y, max(q.x * params.x + pos.y * params.y, -pos.y) - h.x * params.z);\n}\n\nfloat sdPlane(in vec3 pos, in vec3 normal, in float offset) {\n    return dot(pos, normal) + offset;\n}\n\nfloat sdSphere(in vec3 pos, in vec3 center, in float radius) {\n    return length(pos - center) - radius;\n}\n\nfloat sdTor(in vec3 p, in vec2 t, in vec3 offset, mat3 rotation, mat3 scale) {\n    p = (p - offset) * scale * rotation;\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return lengthInf(q) - t.y;\n}\n\nfloat sdBox(in vec3 pos, in vec3 size, in vec3 offset, mat3 rotation) {\n    vec3 adj_pos = abs((pos - offset) * rotation) - size;\n    return length(max(adj_pos, 0.0)) + min(max(adj_pos.x, max(adj_pos.y, adj_pos.z)), 0.0);\n}\n\n// --------- Camera ---------\n\nmat3 camera(in vec3 camera_pos, in vec3 look_at_point) {\n    vec3 camera_dir = normalize(look_at_point - camera_pos);\n    vec3 camera_right = normalize(cross(vec3(0, 1, 0), camera_dir));\n    vec3 camera_up = normalize(cross(camera_dir, camera_right));\n    \n    return mat3(-camera_right, camera_up, -camera_dir);\n}\n\n// --------- Render ---------\n\n// --- Separate Objects ---\n\nSurface sdOuterShell(in vec3 pos) { // unused\n    Surface outer_shell = Surface(1, sdPlane(pos, vec3(0.0, 0.0, 1.0), 20.0), mPlane(pos));\n    outer_shell = opSmoothUnion(Surface(1, sdPlane(pos, vec3(0.0, 1.0, 0.0), 1.0), mPlane(pos)), outer_shell, 0.9); // floor plane\n    outer_shell = opSmoothUnion(Surface(1, sdPlane(pos, vec3(1.0, 0.0, 0.0), 20.0), mPlane(pos)), outer_shell, 0.9);\n    outer_shell = opSmoothUnion(Surface(1, sdPlane(pos, vec3(0.0, 0.0, -1.0), 20.0), mPlane(pos)), outer_shell, 0.9);\n    outer_shell = opSmoothUnion(Surface(1, sdPlane(pos, vec3(0.0, -1.0, 0.0), 20.0), mPlane(pos)), outer_shell, 0.9);\n    outer_shell = opSmoothUnion(Surface(1, sdPlane(pos, vec3(-1.0, 0.0, 0.0), 20.0), mPlane(pos)), outer_shell, 0.9);\n    return outer_shell;\n}\n\nSurface sdBlade(in vec3 pos) { \n    Surface upper_blade = Surface(2, sdBox(pos, vec3(0.03, 3, 0.05), vec3(0, 0.07, 3), rotateX(kPi/2.0)), mBlade());\n    Surface lower_blade = Surface(2, sdTriPrism(pos, vec2(0.5, 3), vec3(0, 0.005, 3), vec3(1.1, 0.4, 0.05), rotateZ(kPi), kIdentityMat), mBlade());\n    Surface tip = Surface(2, sdTriPrism(pos, vec2(0.5, 0.1), vec3(0, -0.023, 6.0), vec3(1, 0.4, 0.05), rotateZ(kPi), rotateX(-kPi/ 2.0)), mBlade());\n    Surface intersector = Surface(2, sdSphere(pos, vec3(0, 4, 0), 7.15), mBlade());\n    Surface blade_full = opSmoothUnion(upper_blade, lower_blade, 0.003);\n    blade_full = opSmoothUnion(blade_full, tip, 0.005);\n    blade_full = opIntersection(intersector, blade_full);\n    return blade_full;\n}\n\nSurface sdGuardHandle(in vec3 pos) {\n    mat3 guard_scale = mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1.5)\n    );\n    Surface guard = Surface(2, sdTor(pos, vec2(0.3, 0.1), vec3(0), rotateX(kPi / 2.0), guard_scale), mGuard());\n\n    Surface handle = Surface(2, opRound(sdBox(pos, vec3(0.07, 0.8, 0.07), vec3(0, 0, -0.8), rotateX(kPi / 2.0)), 0.05), mHandle());\n\n    return opSmoothUnion(guard, handle, 0.2);\n}\n\n// --- Full Scene ---\n\nSurface sdScene(in vec3 pos) {\n    Surface outer_shell = Surface(1, sdPlane(pos, vec3(0.0, 1.0, 0.0), 3.0), mPlane(pos));\n    \n    Surface blade = sdBlade(pos);\n    Surface guard_handle = sdGuardHandle(pos);\n    Surface res = opUnion(guard_handle, blade);\n    res = opUnion(res, outer_shell);\n\n    return res;\n}\n\n// --- Tracing ---\n\nSurface trace(in vec3 ray_origin, in vec3 ray_dir) {\n    vec3 pos = ray_origin;\n    float total_depth = kMinDist;\n    Surface closest_object;\n\n    for (int steps = 0; steps < kMaxSteps; steps++) {\n        closest_object = sdScene(pos);\n        if (closest_object.sd < kPresicion) {\n            break;\n        }\n\n        total_depth += closest_object.sd;\n\n        if (total_depth > kMaxDist) {\n            break;\n        }\n\n        pos += closest_object.sd * ray_dir;\n    }\n    \n    closest_object.sd = total_depth;\n\n    return closest_object;\n}\n\nvec3 generateNormal(in vec3 pos, in float offset) {\n    float dx1 = sdScene(pos + vec3(offset, 0, 0)).sd;\n    float dx2 = sdScene(pos - vec3(offset, 0, 0)).sd;\n    float dy1 = sdScene(pos + vec3(0, offset, 0)).sd;\n    float dy2 = sdScene(pos - vec3(0, offset, 0)).sd;\n    float dz1 = sdScene(pos + vec3(0, 0, offset)).sd;\n    float dz2 = sdScene(pos - vec3(0, 0, offset)).sd;\n\n    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));\n}\n\n// --- Texturing ---\n\nvec3 transformTexture(in vec3 pos, in sampler2D channel, in vec3 normal, float coeff, vec3 mult) {\n    vec3 weight = abs(normal);\n    vec3 color = \n        pow(weight.x, coeff) * texture(channel, pos.yz * mult.x).rgb + \n        pow(weight.y, coeff) * texture(channel, pos.xz * mult.y).rgb +\n        pow(weight.z, coeff) * texture(channel, pos.xy * mult.z).rgb;\n    return color;\n}\n\nvec3 applyTextures(in vec3 pos, in vec3 normal, in Material material) {\n    if (material.texture_id == 0) { // blade\n        return transformTexture(pos, iChannel2, normal, 5.0, vec3(1)) * transformTexture(pos, iChannel1, normal, 10.0, vec3(0.01));\n    }\n    if (material.texture_id == 1) { // handle \n        return 2.0 * transformTexture(pos, iChannel3, normal, 1.0, vec3(1));\n    }\n    return vec3(1);\n}\n\n// --- Lighting ---\n\nfloat softShadow(in vec3 ray_origin, in vec3 ray_direction, in float mint, in float weight) { //unused rn\n    float result = 1.0;\n    float t = mint;\n\n    for(int i = 0; i < kMaxShadowSteps; i++) {\n        float h = sdScene(ray_origin + ray_direction * t).sd;\n        if(h < kPresicion) {\n            break;\n        }\n        \n        result = min(result, h / (t * weight));\n        t += clamp(h, 0.01, 0.5);\n        if(t > kMaxDist) {\n            break;\n        }\n  }\n  return clamp(result, 0.0, 1.0);\n}\n\nvec3 lightCalc(vec3 pos, vec3 normal, vec3 ray_dir, vec3 ray_origin, Light light, Material material) {\n    vec3 cubemap_reflection = texture(iChannel0, reflect(ray_dir, normal)).rgb;\n\n    vec3 light_dir = normalize(light.pos - pos);\n    vec3 ambient = material.ambient_color * applyTextures(pos, normal, material);\n    if (material.reflection > 0.001) {\n        ambient *= material.reflection * cubemap_reflection;\n    }\n    vec3 new_ray_origin = pos + normal * kPresicion * 2.0;\n    float shadow_ray_length = trace(new_ray_origin, light_dir).sd; // hard shadows\n\n    float normal_lighting = clamp(dot(light_dir, normal), 0., 1.);\n  \n    vec3 diffuse = material.diffuse_color * normal_lighting;\n    if (shadow_ray_length < length(light.pos - new_ray_origin)) {\n        diffuse *= 0.2;\n    }\n\n    float specular_lighting = clamp(dot(-reflect(light_dir, normal), -ray_dir), 0.0, 1.0);\n    vec3 specular = material.specular_color * pow(specular_lighting, material.shininess);\n    if (shadow_ray_length < length(light.pos - new_ray_origin)) {\n        specular *= 0.5;\n    }\n\n    return (ambient + diffuse + specular) * light.intensity;\n}\n\n// --- Render call ---\n\nvec3 render(in vec3 ray_origin, in vec3 ray_dir) {\n    vec3 color = texture(iChannel0, ray_dir).rgb; // default color - cubemap\n    \n    // Set up lights\n    Light light = Light(vec3(2, 0.1, 0), 0.9);\n    \n    Surface closest_object = trace(ray_origin, ray_dir);\n\n    if(closest_object.sd < kMaxDist) {\n        vec3 pos = ray_origin + ray_dir * closest_object.sd;\n        vec3 normal = generateNormal(pos, kPresicion);\n        \n        color = lightCalc(pos, normal, ray_dir, ray_origin, light, closest_object.material);\n        \n    }\n    return color;\n}\n\nvec3 postfx(vec3 color) {\n    //color = pow(color, vec3(1.0/2.2)); //gamma correction\n    return color;\n}\n\n// --------- Main ---------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //camera setup\n    vec3 camera_origin = vec3(0.0, 4.0, 0.0);\n    float camera_radius = 2.0;\n    vec3 look_at_point = vec3(0.0, 0.0, 3.0);\n\n    vec2 uv_coord = (fragCoord - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    camera_origin.yz = camera_origin.yz * camera_radius * rotate2d(mix(kPi / 2.0, 0.0, mouse.y));\n    camera_origin.xz = camera_origin.xz * rotate2d(mix(-kPi, kPi, mouse.x)) + vec2(look_at_point.x, look_at_point.z);\n    \n    vec3 ray_dir = camera(camera_origin, look_at_point) *  normalize(vec3(uv_coord, -1));\n\n    vec3 color = render(camera_origin, ray_dir);\n    color = postfx(color);\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir ) {\n    vec3 color = texture(iChannel0, rayDir).rgb * texture(iChannel1, rayDir).rgb * 2.0;\n    color.r *= 1.2;\n    color.g *= 0.7;\n    color.b *= 0.7;\n    // Output to cubemap\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "float rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv_coord = fragCoord/iResolution.xy;\n    vec3 color = vec3(0.9, 0.1, 0.1);\n    \n    float x = uv_coord.x;\n    float y = uv_coord.y;\n    float ref = abs(y - sin(cos(rand(uv_coord) * 40.0) * 20.0) + 0.0);\n    \n    color = vec3(0.1) + ref * color;\n    fragColor = vec4(color, 1.0); // Output to screen\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}