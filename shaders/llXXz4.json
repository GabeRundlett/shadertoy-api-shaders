{
    "Shader": {
        "info": {
            "date": "1434845526",
            "description": "Fun with fake physics!",
            "flags": 0,
            "hasliked": 0,
            "id": "llXXz4",
            "likes": 71,
            "name": "voronoi fracture",
            "published": 3,
            "tags": [
                "voronoi",
                "collision",
                "spherical",
                "explode",
                "fracture",
                "fakephysics"
            ],
            "usePreview": 1,
            "username": "mattz",
            "viewed": 3753
        },
        "renderpass": [
            {
                "code": "/* voronoi fracture, by mattz - Voronoi brittle fracture simulation. \n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   Yet another use of fast spherical Voronoi computations. \n   See https://www.shadertoy.com/view/MtBGRD for technical details.\n\n   Note the code below is not as nice or pretty as the linked shader MtBGRD.\n   Please consider that one the \"reference implementation\".\n\n\n*/\n\n\n/* Magic angle that equalizes projected area of squares on sphere. */\n#define MAGIC_ANGLE 0.868734829276 // radians\n\nconst float warp_theta = MAGIC_ANGLE;\nfloat tan_warp_theta = tan(warp_theta);\n\nconst float farval = 1e5;\nconst vec3 tgt = vec3(0);\nconst vec3 cpos = vec3(0,0,8.0);\nconst float fovy = 0.6; \nvec3 L = normalize(vec3(-0.4, 0.4, 1.0));\n\nconst float plane_dist = 3.0;\nvec3 plane_n = normalize(vec3(0, .2, .5));\n\nconst float eps = 0.05;\n\nconst float thickness = 0.015;\n\nconst float N = 3.0;\nconst float fragment_radius = 0.5;\n\nconst float period = 10.0;\nconst float appear_time = 0.8;\n\nconst float coll_time = 3.6;\nconst vec3 coll_normal = vec3(1.0, 0.0, 0.0);\nconst float r2 = 1.0;\nconst float r1 = 0.25;\nconst float m1 = 4.0;\nconst float m2 = 1.0;\nconst float u1 = 2.0;\nconst float v1 = u1*(m1-m2)/(m1+m2);\nconst float cr = 0.7;\nconst float v2 = cr*2.0*m1*u1 /(m1 + m2);\n\nfloat abs_time, rel_time, seed;\n\nmat3 Rview;\n\nstruct rayhit {\n    vec4 ntmin;\n    vec4 ntmax;\n};\n\nconst rayhit miss = rayhit(vec4(farval), vec4(-farval));\n\n/* Choose vector with smaller w. */\nvec4 v4min(vec4 a, vec4 b) {\n\treturn a.w < b.w ? a : b;\n}\n\n/* Choose vector with larger w. */\nvec4 v4max(vec4 a, vec4 b) {\n\treturn a.w > b.w ? a : b;\n}\n\n/* Intersection of two ray intervals. */\nrayhit rayinter(rayhit a, rayhit b) {\n\treturn rayhit(v4max(a.ntmin, b.ntmin),\n                  v4min(a.ntmax, b.ntmax));\n}\n\n/* Union of two ray intervals. */\nrayhit rayunion(rayhit a, rayhit b) {\n\treturn rayhit(v4min(a.ntmin, b.ntmin),\n                  v4max(a.ntmax, b.ntmax));\n}\n\n/* Difference of two ray intervals. */\nrayhit raydiff(rayhit a, rayhit b) {\n\n    if (b.ntmin.w <= a.ntmin.w) {\n        return rayhit(v4max(a.ntmin, vec4(-b.ntmax.xyz, b.ntmax.w)), a.ntmax);\n    } else {\n        return rayhit(a.ntmin, v4min(a.ntmax, vec4(-b.ntmin.xyz, b.ntmin.w)));\n    }\n    \n\t\t    \n}\n\n/* Ray-sphere intersection. */\nrayhit sphere(in vec3 o, in vec3 d, in float r) {\n\t\n\t\n\tfloat p = -dot(o, d);\n\tfloat q = dot(o, o) - r*r;\n\t\t\n\tfloat D = p*p - q;\n\n\tif (D > 0.0) {\n\t\tfloat sqrtD = sqrt(D);\n        float t0 = p-sqrtD;\n        float t1 = p+sqrtD;\n        if (t1 < 0.0) { return miss; }\n        return rayhit(vec4(normalize(o+t0*d), t0),\n                      vec4(normalize(o+t1*d), t1));\n\t}\n\t\n\treturn miss;\n\t\t\n}\n\n/* Ray-plane intersection. */\nrayhit plane(vec3 o, vec3 d, vec3 n) {\n\n\tfloat t = -dot(n,o)/dot(n,d);    \n    \n    if (dot(d, n) > 0.0) {\n        return rayhit(vec4(n, eps), vec4(n, t));\n    } else {\n        return rayhit(vec4(n, t), vec4(n, farval));\n    }\n        \n    \n}\n\n/* Ray-box intersection. */\nrayhit box(vec3 ro, vec3 rd, vec3 b) {\n\t\n\tvec3 rdi = 1.0/rd;\t\n\t\t\n\tvec3 t1 = (-b - ro)*rdi;\n\tvec3 t2 = ( b - ro)*rdi;\n\t\n\tvec3 tmin = min(t1, t2);\n\tvec3 tmax = max(t1, t2);\n\t\n\tconst vec3 x = vec3(1.0, 0.0, 0.0);\n\tconst vec3 y = vec3(0.0, 1.0, 0.0);\n\tconst vec3 z = vec3(0.0, 0.0, 1.0);\n\t\n\tvec4 vmin = v4max(v4max(vec4(x,tmin.x), vec4(y,tmin.y)), vec4(z,tmin.z));\n\tvec4 vmax = v4min(v4min(vec4(x,tmax.x), vec4(y,tmax.y)), vec4(z,tmax.z));\n    \n    if (vmin.w > 0.0 && vmin.w <= vmax.w) {\n        vmin.xyz *= -sign(dot(rd, vmin.xyz));\n        vmax.xyz *= sign(dot(rd, vmax.xyz));        \n        return rayhit(vmin, vmax);                \n\t} else {\n\t\treturn miss;\n\t}\t\t\n\t\n}\n\n/* Return a permutation matrix whose first two columns are u and v basis \n   vectors for a cube face, and whose third column indicates which axis \n   (x,y,z) is maximal. */\nmat3 getPT(in vec3 p) {\n\n    vec3 a = abs(p);\n    float c = max(max(a.x, a.y), a.z);    \n    vec3 s = c == a.x ? vec3(1.,0,0) : c == a.y ? vec3(0,1.,0) : vec3(0,0,1.);\n    s *= sign(dot(p, s));\n    vec3 q = s.yzx;\n    return mat3(cross(q,s), q, s);\n\n}\n\n/* For any point in 3D, obtain the permutation matrix, as well as grid coordinates\n   on a cube face. */\nvoid posToGrid(in float N, in vec3 pos, out mat3 PT, out vec2 g) {\n    \n    // Get permutation matrix and cube face id\n    PT = getPT(pos);\n    \n    // Project to cube face\n    vec3 c = pos * PT;     \n    vec2 p = c.xy / c.z;      \n    \n    // Unwarp through arctan function\n    vec2 q = atan(p*tan_warp_theta)/warp_theta; \n    \n    // Map [-1,1] interval to [0,N] interval\n    g = (q*0.5 + 0.5)*N;\n    \n}\n\n/* For any grid point on a cube face, along with projection matrix, \n   obtain the 3D point it represents. */\nvec3 gridToPos(in float N, in mat3 PT, in vec2 g) {\n    \n    // Map [0,N] to [-1,1]\n    vec2 q = g/N * 2.0 - 1.0;\n    \n    // Warp through tangent function\n    vec2 p = tan(warp_theta*q)/tan_warp_theta;\n\n    // Map back through permutation matrix to place in 3D.\n    return PT * vec3(p, 1.0);\n    \n}\n\n/* Return whether a neighbor can be identified for a particular grid cell.\n   We do not allow moves that wrap more than one face. For example, the \n   bottom-left corner (0,0) on the +X face may get stepped by (-1,0) to \n   end up on the -Y face, or, stepped by (0,-1) to end up on the -Z face, \n   but we do not allow the motion (-1,-1) from that spot. If a neighbor is \n   found, the permutation/projection matrix and grid coordinates of the \n   neighbor are computed.\n*/\nbool gridNeighbor(in float N, in mat3 PT, in vec2 g, in vec2 delta, out mat3 PTn, out vec2 gn) {\n\n    vec2 g_dst = g.xy + delta;\n    vec2 g_dst_clamp = clamp(g_dst, 0.0, N);\n\n    vec2 extra = abs(g_dst_clamp - g_dst);\n    float esum = extra.x + extra.y;\n \n    if (max(extra.x, extra.y) == 0.0) {\n        PTn = PT;\n        gn = g_dst;\n        return true;\n    } else if (min(extra.x, extra.y) == 0.0 && esum < N) {\n        vec3 pos = PT * vec3(g_dst_clamp/N*2.0-1.0, 1.0 - 2.0*esum/N);\n        PTn = getPT(pos);\n        gn = ((pos * PTn).xy*0.5 + 0.5) * N;\n        return true;\t        \n    } else {\n        return false;\n    }\n    \n\n}\n\n/* From https://www.shadertoy.com/view/Xd23Dh */\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n                  dot(p,vec2(269.5,183.3)), \n                  dot(p,vec2(419.2,371.9)) );\n    return fract(sin(q)*43758.5453);\n}\n\n/* Perturb a cube sample based upon location. */\nvec3 getRandomPos(in float N, in mat3 PTn, in vec2 gn) {\n    \n    float face = dot(PTn[2], vec3(1.,2.,3.));   \n                \n    // Perturb based on grid cell ID\n    gn = floor(gn);\n    vec3 rn = hash3(gn*seed + face);\n    gn += 0.5 + (rn.xy * 2.0 - 1.0)*0.45;\n\n    // Get the 3D position\n    return normalize(gridToPos(N, PTn, gn));  \n    \n}\n\n/* Check one edge of voronoi diagram. */\nvoid checkNeighbor(in vec3 ro, in vec3 rd,\n                   in float N, in mat3 PT, in vec2 g, \n                   in vec3 p1, in vec2 uv, \n                   inout rayhit r) {\n    \n    if (r.ntmin.w < r.ntmax.w) {\n\n        vec2 gn;\n        mat3 PTn;\n\n        if (gridNeighbor(N, PT, g, uv, PTn, gn)) {                \n            vec3 p2 = getRandomPos(N, PTn, gn);                              \n            vec3 n1 = cross(p1.xyz,p2.xyz);\n            vec3 n2 = normalize(cross(n1, 0.5*(p1.xyz+p2.xyz)));\n            r = rayinter(r, plane(ro, rd, n2));\n        }\n        \n    }\n    \n}\n\n/* Given hit on sphere, intersect with voronoi */ \nvoid fragment(in vec3 ro, in vec3 rd, \n              in float N, in mat3 PT, in vec2 g, in vec3 p1,\n              inout rayhit r) {\n    \n    checkNeighbor(ro, rd, N, PT, g, p1, vec2(-1.0, -1.0), r);\n    checkNeighbor(ro, rd, N, PT, g, p1, vec2( 0.0, -1.0), r);\n    checkNeighbor(ro, rd, N, PT, g, p1, vec2( 1.0, -1.0), r);\n    checkNeighbor(ro, rd, N, PT, g, p1, vec2(-1.0,  0.0), r);\n    checkNeighbor(ro, rd, N, PT, g, p1, vec2( 1.0,  0.0), r);\n    checkNeighbor(ro, rd, N, PT, g, p1, vec2(-1.0,  1.0), r);\n    checkNeighbor(ro, rd, N, PT, g, p1, vec2( 0.0,  1.0), r);\n    checkNeighbor(ro, rd, N, PT, g, p1, vec2( 1.0,  1.0), r);\n\n}\n\n\n/* Rotate about x-axis */\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\n\n/* Rotate about y-axis */\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\n/* Rotation matrix from angle-axis */\nmat3 rotaxisangle(in vec3 a, float t) {\n    mat3 K = mat3(0, a.z, -a.y,\n                  -a.z, 0, a.x,\n                  a.y, -a.x, 0);\n    return mat3(1.0) + K*(mat3(sin(t)) + (1.0-cos(t))*K);\n}\n\n/* Cast a ray into the scene and get result. */\nvoid castRay( in vec3 ro, in vec3 rd, out vec4 result, out vec3 mat){\n\n    result = vec4(farval);\n\n    const vec3 x = vec3(1.0, 0.0, 0.0);\n    const vec3 y = vec3(0.0, 1.0, 0.0);\n    const vec3 z = vec3(0.0, 0.0, 1.0); \n\n    rayhit p = plane(ro+plane_dist*plane_n, rd, plane_n);\n    if (p.ntmin.w > eps) {\n        result = p.ntmin;\n        mat = vec3(1.95, 0.2, 8.0);\n    }       \n    \n    vec2 rando = fract(seed*vec2(139398.4339482,9304.371));    \n    vec3 v1_perp = vec3(0.0, rando*vec2(6.0, 1.0)-vec2(3.0, 0)); \n  \n    vec3 p1 = -coll_normal*(r1+r2);\n    if (rel_time < coll_time) {\n        p1 -= (u1*coll_normal + v1_perp)*(coll_time-rel_time);\n    } else {\n        p1 -= (v1*coll_normal + v1_perp)*(coll_time-rel_time);\n    }    \n    \n    rayhit s = sphere(ro-p1, rd, r1);\n    if (s.ntmin.w < s.ntmax.w && s.ntmin.w < result.w) {\n        result = s.ntmin;\n        mat = vec3(1.1, 0.5, 24.0);\n    }\n        \n    for (int k=0; k<6; ++k) {\n        \n        mat3 PT;\n        \n        if (k < 3) {\n            if (k == 0) {\n                PT = mat3(x, y, z);\n            } else if (k == 1) {\n                PT = mat3(y, z, x);\n            } else {\n                PT = mat3(z, x, y);\n            }\n        } else {\n            if (k == 3) {\n                PT = mat3(x, -y, -z);\n            } else if (k == 4) {\n                PT = mat3(y, -z, -x);\n            } else {\n                PT = mat3(z, -x, -y);\n            }\n        }        \n        \n        for (float u=0.0; u<N; ++u) {\n            for (float v=0.0; v<N; ++v) {\n\n                vec2 g = vec2(u,v) + 0.5;\n                \n                vec3 p1 = r2*getRandomPos(N, PT, g);\n                \n                \n                vec3 pos = p1;\n                float a = max(appear_time-rel_time, 0.0)/appear_time;\n                a = 3.0*a*a - 2.0*a*a*a;\n                float da = 2.0*r2+plane_dist+eps;\n                pos -= da*plane_n*a;\n                \n                float time_after_coll = max(rel_time-coll_time, 0.0);\n                \n                if (time_after_coll > 0.0) {                    \n                    vec3 fragment_delta = (p1+coll_normal*v2)*(rel_time-coll_time);\n                    pos += fragment_delta;\n                    float dp = dot(pos, plane_n) + plane_dist - fragment_radius;                \n                    pos -= plane_n * min(0.0, dp);\n                }\n                \n                rayhit f = sphere(ro-pos, rd, fragment_radius);\n\n                if (f.ntmin.w < f.ntmax.w && f.ntmin.w < result.w) {\n\n                    vec3 h1 = hash3(p1.xy);\n                    vec3 h2 = hash3(p1.yz);\n                    \n                    vec3 omega = normalize(2.*h1 - 1.);\n\n                    mat3 R = rotaxisangle(omega, 4.*time_after_coll*h2.x);\n\n                    vec3 fro = R*(ro-pos) + p1;\n                    vec3 frd = R*rd;\n\n                    f = sphere(fro, frd, r2);\n\n                    fragment(fro, frd, N, PT, g, p1, f);\n                    rayhit s2 = sphere(fro, frd, r2-thickness);\n                    f = raydiff(f, s2);\n                    \n                    if (f.ntmax.w >= f.ntmin.w && f.ntmin.w < result.w) {\n                        \n                        result = vec4(f.ntmin.xyz*R, f.ntmin.w);\n                                                \n                        float hue_mod = floor(abs_time/period)*0.6532;\n                        float sphere_h = fract(0.03 + hue_mod);\n                        \n                        mat = vec3(sphere_h, 0.4, 15.0);\n                        \n                    }\n                    \n                }\n                \n            }\n        }\n    }\n    \n    \n}\n\nvec3 hue(float h) {\n\tvec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n\treturn h >= 1.0 ? vec3(h-1.0) : (clamp(min(c, -c+4.0), 0.0, 1.0)*0.75 + 0.2);\n}\n\nvec3 shade(in vec3 ro, in vec3 rd) {\n    \n    vec3 c = vec3(1.0);\n    \n    vec4 r;\n    vec3 m;\n    \n    castRay(ro, rd, r, m);\n\n    if (r.w < farval) {\n        \n        vec3 n = r.xyz;\n        vec3 color = hue(m.x);\n        \n        ro = ro + r.w*rd + 2.0*eps * r.xyz;\n\n        vec3 amb = 0.2 * color;\n        vec3 diff = 0.8*clamp(dot(n,L), 0.0, 1.0) * color;\n                \n        vec3 R = 2.0*n*dot(n,L)-L;\n                \n        float spec = pow(clamp(-dot(R, rd), 0.0, 1.0), m.z)*m.y;\n        \n\t\tcastRay(ro, L, r, m);\n\n        if (r.w < farval) {\n\t\t\tdiff = vec3(0);\n            spec = 0.0;\n        }\n                  \n        c = diff + amb + spec;\n\n    }\n    \n    return c;   \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    abs_time = iTime + appear_time;\n    rel_time = mod(abs_time, period);\n    seed = 0.2134 + floor(abs_time/period)*0.05395029;        \n        \n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) * fovy / (iResolution.y);\n\n    vec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,vec3(0,1.,0))),\n        ry = cross(rx,rz);\n\n    float t = iTime;\n         \n    float thetay = 0.0;\n    float thetax = 0.0;\n\n    if (max(iMouse.x, iMouse.y) > 20.0) { \n        thetax = (iMouse.y - .5*iResolution.y) * 0.5/iResolution.y; \n        thetay = (iMouse.x - .5*iResolution.x) * -1.0/iResolution.x; \n    }\n\n    Rview = mat3(rx,ry,rz)*rotX(thetax)*rotY(thetay);        \n  \n    vec3 rd = Rview*normalize(vec3(uv, 1.)),\n        ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n    \n    vec2 q = fragCoord.xy / iResolution.xy;\n        \n    vec3 color = shade(ro, rd);\n    \n    color = pow(color, vec3(0.7));\n    \n    // stole iq's vingette code\n    color *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );       \n\n    fragColor = vec4(color, 1.0);\n\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}