{
    "Shader": {
        "info": {
            "date": "1635740946",
            "description": "Took a shot at recreating a HUD in the style of The Next Generation's distinctive Okudagrams",
            "flags": 0,
            "hasliked": 0,
            "id": "std3RH",
            "likes": 15,
            "name": "LCARS Display",
            "published": 3,
            "tags": [
                "startrek",
                "lcars",
                "tng",
                "thenextgeneration",
                "okudagram"
            ],
            "usePreview": 0,
            "username": "Xibanya",
            "viewed": 589
        },
        "renderpass": [
            {
                "code": "#define ORANGE vec4(1.0, 0.6, 0.0, 0.0)\n#define LILAC vec4(0.6, 0.6, 1.0, 0.0)\n#define CORAL vec4(0.8, 0.4, 0.4, 0.0)\n#define PEACH vec4(1.0, 0.6, 0.4, 0.0)\n#define CREAM vec4(1.0, 0.8, 0.6, 0.0)\n#define PINK vec4(0.8, 0.6, 0.8, 0.0)\n#define BLACK vec4(0.0)\n\n//https://www.shadertoy.com/view/XtfyRS\nfloat GlyphSDF(vec2 p, float char)\n{\n    // Convert glyph to appropriate char index in the char texture and compute distance to it\n\tp = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\n\treturn 2. * (texture(iChannel0, p / 16. + fract(vec2(char, 15. - floor(char / 16.)) / 16.)).w - 127. / 255.);\n}\n#define INIT_TEXT float glyphRatio = 2.0; \\\n    vec2 glyphScale = 6. * vec2(1., glyphRatio); \\\n    vec2 t = floor(p / glyphScale + 1e-6); \\\n    uint v = 0u\n#define WRITE_TEXT float char = float((v >> uint(8. * t.x)) & 255u); \\\n    vec2 posInCell = (p - t * glyphScale) / glyphScale; \\\n    posInCell.x = (posInCell.x - .5) / glyphRatio + .5; \\\n    float sdf = GlyphSDF(posInCell, char) - 0.03; \\\n    if (char != 0.) color = mix(textColor, color, smoothstep(-.02, +.03, sdf))\n\nvoid TextLCARSACCESS(inout vec3 color, vec3 textColor, vec2 p)\n{\n\tINIT_TEXT;\n    v = t.y == 0. ? ( t.x < 4. ? 1380008780u : ( t.x < 8. ? 1128341587u : ( t.x < 12. ? 1397966147u : 825504800u ) ) ) : v;\n\tv = t.x >= 0. && t.x < 16. ? v : 0u;\n    WRITE_TEXT;\n}\nvoid TextLCARS4(inout vec3 color, vec3 textColor, vec2 p)\n{\n\tINIT_TEXT;\n\tv = t.y == 0. ? ( t.x < 4. ? 1380008780u : ( t.x < 8. ? 808722515u : 3422002u ) ) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    WRITE_TEXT;\n}\nvoid Text3(inout vec3 color, vec3 textColor, vec2 p)\n{\n\tINIT_TEXT;\n\tv = t.y == 0. ? ( t.x < 4. ? 959263536u : ( t.x < 8. ? 943076663u : 51u ) ) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    WRITE_TEXT;\n}\nvoid Text4(inout vec3 color, vec3 textColor, vec2 p)\n{\n\tINIT_TEXT;\n\tv = t.y == 0. ? ( t.x < 4. ? 925709360u : ( t.x < 8. ? 909391158u : 54u ) ) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    WRITE_TEXT;\n}\nvoid Text5(inout vec3 color, vec3 textColor, vec2 p)\n{\n\tINIT_TEXT;\n    v = t.y == 0. ? ( t.x < 4. ? 841823536u : ( t.x < 8. ? 892548146u : 51u ) ) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    WRITE_TEXT;\n}\nvoid Text6(inout vec3 color, vec3 textColor, vec2 p)\n{\n\tINIT_TEXT;\n    v = t.y == 0. ? ( t.x < 4. ? 892155440u : ( t.x < 8. ? 909456951u : 53u ) ) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    WRITE_TEXT;\n}\nvoid TextB(inout vec3 color, vec3 textColor, vec2 p)\n{\n\tINIT_TEXT;\n\tv = t.y == 2. ? ( t.x < 4. ? 909654073u : ( t.x < 8. ? 875770413u : ( t.x < 12. ? 538976288u : ( t.x < 16. ? 538976288u : ( t.x < 20. ? 538976288u : ( t.x < 24. ? 538976288u : ( t.x < 28. ? 942813488u : 959852589u ) ) ) ) ) ) ) : v;\n\tv = t.y == 1. ? 0u : v;\n\tv = t.y == 0. ? ( t.x < 4. ? 875638833u : ( t.x < 8. ? 959526957u : ( t.x < 12. ? 538976288u : ( t.x < 16. ? 538976288u : ( t.x < 20. ? 538976288u : ( t.x < 24. ? 538976288u : ( t.x < 28. ? 842215991u : 942880813u ) ) ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 32. ? v : 0u;\n    WRITE_TEXT;\n}\nvoid TextNumbers(inout vec3 color, vec3 textColor, vec2 p)\n{\n\tINIT_TEXT;\n    v = t.y == 4. ? ( t.x < 4. ? 892875570u : ( t.x < 8. ? 941629472u : ( t.x < 12. ? 842544949u : ( t.x < 16. ? 958411315u : ( t.x < 20. ? 943207200u : ( t.x < 24. ? 943005746u : ( t.x < 28. ? 958411577u : 3487800u ) ) ) ) ) ) ) : v;\n\tv = t.y == 3. ? ( t.x < 4. ? 875966514u : ( t.x < 8. ? 840966176u : ( t.x < 12. ? 959723056u : ( t.x < 16. ? 924856886u : ( t.x < 20. ? 926365984u : ( t.x < 24. ? 908075062u : ( t.x < 28. ? 824194610u : 3290679u ) ) ) ) ) ) ) : v;\n\tv = t.y == 2. ? ( t.x < 4. ? 875765792u : ( t.x < 8. ? 538976288u : ( t.x < 12. ? 840966176u : ( t.x < 16. ? 538982711u : ( t.x < 20. ? 941629472u : ( t.x < 24. ? 892739641u : ( t.x < 28. ? 908081464u : 3617845u ) ) ) ) ) ) ) : v;\n\tv = t.y == 1. ? ( t.x < 4. ? 943077172u : ( t.x < 8. ? 941629472u : ( t.x < 12. ? 842479161u : ( t.x < 16. ? 924858420u : ( t.x < 20. ? 959920416u : ( t.x < 24. ? 959979576u : ( t.x < 28. ? 538982710u : 3553076u ) ) ) ) ) ) ) : v;\n\tv = t.y == 0. ? ( t.x < 4. ? 892876320u : ( t.x < 8. ? 538976288u : ( t.x < 12. ? 875765792u : ( t.x < 16. ? 941635639u : ( t.x < 20. ? 909647904u : ( t.x < 24. ? 857743415u : ( t.x < 28. ? 538981940u : 3420960u ) ) ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 32. ? v : 0u;\n    WRITE_TEXT;\n}\n\n// all sdf functions from iq\n// https://iquilezles.org/articles/distfunctions\nvec2 opRepLim( in vec2 p, in vec2 s, in vec2 lima, in vec2 limb )\n{\n    return p-s*clamp(round(p/s),lima,limb);\n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r ) \n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\nfloat sinc( float x, float k )\n{\n    float a = 3.14 * (k * x - 1.0);\n    return sin(a)/a;\n}\n\n//// LCARS Functions\nfloat MStep(float d)\n{\n    return 1. - smoothstep(-0.005, 0.0, d);\n}\nfloat Margin(float sdf)\n{\n    return clamp(1. - smoothstep(0.01, 0.015, abs(sdf)), 0.0, 1.0);\n}\nfloat MarginSm(float sdf)\n{\n    return clamp(1. - smoothstep(0.005, 0.01, abs(sdf)), 0.0, 1.0);\n}\nvoid Outline(float d, inout vec4 col, vec4 mixCol)\n{\n    vec4 c = mix(mixCol, BLACK, Margin(d));\n    col = mix(col, c, MStep(d));\n}\nfloat Panel(vec2 uv, vec2 f, out vec4 boxCol)\n{\n    const vec4 RED = vec4(1., 0., 0., 0.);\n    const vec4 GREEN = vec4(0.0, 1.0, 0.0, 0.0);\n    const vec4 BLUE = vec4(0.0, 0.0, 1.0, 0.0);\n    const vec4 ALPHA = vec4(0.0, 0.0, 0.0, 1.0);\n    vec2 boxSize = vec2(1.5, 1.);\n    float box = sdRoundBox(uv, boxSize, vec4(0.35));\n    boxCol = RED;\n    float seg = sdBox(uv + vec2(.1, -0.35) * f, vec2(1.7, 0.3));\n    Outline(seg, boxCol, RED);\n\n    boxCol = mix(boxCol, GREEN, step(uv.y, 0.15 * f.y));\n    seg = sdBox(uv + vec2(0., -.15) * f, vec2(1.5, 0.1));\n    Outline(seg, boxCol, BLUE);\n\n    seg = sdBox(uv + vec2(-0.1, 0.) * sign(f), vec2(0.075, 2.));\n    Outline(seg, boxCol, ALPHA);\n\n    uv += vec2(-0.4, 0.075) * sign(f);\n    float innerBox = sdRoundBox(uv, boxSize, vec4(0.1));\n    box = max(box, -innerBox);\n    boxCol = mix(boxCol, BLACK, Margin(box));\n    return box;\n}\nvoid DoText(vec2 p, inout vec4 col)\n{\n    vec2 tUV = p * vec2(100., 50.) - vec2(0., 32.);\n    TextLCARSACCESS(col.rgb, ORANGE.rgb, tUV);\n    tUV = p * vec2(275., 150.) - vec2(-245., 110.);\n    TextLCARS4(col.rgb, BLACK.rgb, tUV);\n    tUV.y += 125.;\n    Text3(col.rgb, BLACK.rgb, tUV);\n    tUV.y += 59.;\n    Text4(col.rgb, BLACK.rgb, tUV);\n    tUV.y += 29.;\n    Text5(col.rgb, BLACK.rgb, tUV);\n    tUV.y += 15.;\n    Text6(col.rgb, BLACK.rgb, tUV);\n    tUV = p * vec2(270., 140.) - vec2(90., 50.);\n    TextB(col.rgb, BLACK.rgb, tUV);\n    tUV *= 1.3;\n    tUV += vec2(290., 5.);\n    TextNumbers(col.rgb, ORANGE.rgb, tUV);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (1.3 * fragCoord-iResolution.xy)/iResolution.y;\n    // this looked different when I was previewing it in my IDE\n    // adjusting aspect here to look good on shadertoy\n    p += vec2(0.7, 0.4);\n    p.y *= 1.3;\n    vec2 boxPos = p + vec2(-0.5, .75);\n    vec4 boxCol = CORAL;\n    vec2 f = vec2(1.);\n    // main panel\n    float box = Panel(boxPos, f, boxCol);\n    vec4 col1 = boxCol.r * CORAL + boxCol.g * PEACH + \n        boxCol.b * ORANGE + boxCol.a * CREAM;\n    vec4 col = mix(BLACK, col1, MStep(box));\n    // mirror flipped panel\n    boxPos = p - vec2(0.5, 1.25);\n    f = vec2(1., -2.);\n    box = Panel(boxPos, f, boxCol);\n    vec4 col2 = boxCol.r * ORANGE + boxCol.g * LILAC + \n        boxCol.b * PINK + boxCol.a * ORANGE;\n    col = mix(col, col2, MStep(box));\n\n    // pills\n    vec2 q = p * 9.0 - vec2(8.0, 2.2);\n    vec2 r = opRepLim(q, vec2(4.75, 1.6), vec2(-1, 1.), vec2(1,2));\n    float d = sdBox( r, vec2(1.5, 0.0001) ) -  0.65;\n    vec4 pillCol = LILAC;\n    float peach = min(step(0.625, p.x), step(0.51, p.y));\n    pillCol = mix(pillCol, PEACH, peach);\n    float orange = min(step(p.x, 0.625), step(p.y, 0.51));\n    pillCol = mix(pillCol, ORANGE, orange);\n    col = mix(col, pillCol, 1. - smoothstep(-0.05, .0, d));\n\n    // center diagram\n    vec4 mCol = PEACH;\n    vec2 mPos = p + vec2(-0.25, 0.3);\n    vec2 mSize = vec2(0.6, 0.4); \n    float midBox = sdRoundBox(mPos, mSize, vec4(0.1));\n    float subMid = sdRoundBox(mPos, mSize * vec2(0.9, 0.925), vec4(0.05));\n    subMid = min(subMid, \n        sdBox(mPos, mSize * vec2(0.8, 1.5)));\n    midBox = max(midBox, -subMid);\n    float cB1 = sdBox(mPos + vec2(0., 0.), vec2(1.5, 0.2));\n    vec4 cB1Col = mix(CORAL, BLACK, MarginSm(cB1));\n    mCol = mix(mCol, cB1Col, MStep(cB1));\n    float mAccent = sdBox(mPos + vec2(-0.4, 0.05), vec2(0.25, .1));\n    vec4 aCol = mix(CREAM, BLACK, MarginSm(mAccent));\n    mCol = mix(mCol, aCol, MStep(mAccent));\n    col = mix(col, mCol, MStep(midBox));\n    \n    // y axis ruler things\n    vec2 rulerOffset = vec2(0.6, 0.0);\n    float ruler = sdBox(mPos + rulerOffset, vec2(0.03, 0.3));\n    rulerOffset.x = abs(rulerOffset.x);\n    rulerOffset.x -= 1.2;\n    ruler = min(ruler, sdBox(mPos + rulerOffset, vec2(0.03, 0.3)));\n    vec2 rUV = p * 9.0 - vec2(6.8, -5.1);\n    rUV = opRepLim(rUV, vec2(1., .4), vec2(1., .0), vec2(1., 12.));\n    float lines = sdBox(rUV, vec2(.2, .15));\n    rUV = p * 9.0 - vec2(-4.3, -5.1);\n    rUV = opRepLim(rUV, vec2(1., .4), vec2(1., .0), vec2(1., 12.));\n    lines = min(lines, sdBox(rUV, vec2(.2, .15)));\n    lines = max(lines, -midBox);\n    vec4 rulerCol = mix(ORANGE, BLACK, MarginSm(ruler));\n    // subtract the ruler lines after doing the outline so that they don't\n    // get included in the outline and mess up the edge being flush\n    // with the larger box\n    ruler = max(ruler, -lines);\n    col = mix(col, rulerCol, MStep(ruler));\n\n    // the bobbing marker things\n    float minY = 7.;\n    float maxY = -7.;\n    float mY = mix(minY, maxY, \n        sinc(sin(iTime + 0.001 + iMouse.y * 0.01), 1.) * 0.5 + 0.25);\n    vec2 offset = vec2(14., mY);\n    float marker = sdRoundBox(mPos * 30. + offset, \n        vec2(2., 0.75), vec4(2.));\n    mY = mix(minY, maxY, \n        sinc(sin(iTime * 1.2 + 0.5 + iMouse.x * 0.01), 1.1) * 0.5 + 0.25);\n    offset = vec2(-14., mY);\n    marker = min(marker, sdRoundBox(mPos * 30. + offset, \n        vec2(2., 0.75), vec4(2.)));\n    col = mix(col, CREAM * 1.25, 1. - smoothstep(-0.005, 0., marker));\n\n    DoText(p, col);\n\tfragColor = vec4(col.rgb, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}