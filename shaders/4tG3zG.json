{
    "Shader": {
        "info": {
            "date": "1475074395",
            "description": "Forked and mixed from 104's Brush Experiments: https://www.shadertoy.com/view/ltj3Wc",
            "flags": 0,
            "hasliked": 0,
            "id": "4tG3zG",
            "likes": 17,
            "name": "Artistic 404 Not Found",
            "published": 3,
            "tags": [
                "2d",
                "brush",
                "calligraphy",
                "404"
            ],
            "usePreview": 0,
            "username": "starea",
            "viewed": 1359
        },
        "renderpass": [
            {
                "code": "// Ruofei Du \n// 404 Not Found Page\n// Forked and mixed from 104's Brush Experiments: https://www.shadertoy.com/view/ltj3Wc\n// Free to use and share\n\nvec2 mouse;\n\n////////////////////////////////////////////////////////////////\n// BOILERPLATE UTILITIES...................\nconst float pi = 3.14159265359;\nconst float pi2 = pi * 2.;\n\nfloat opU( float d1, float d2 ){ return min(d1,d2); }\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\nfloat opI( float d1, float d2) { return max(d1,d2); }\n\n\n// from \"Magic Fractal\" by dgreensp\n// https://www.shadertoy.com/view/4ljGDd\nfloat magicBox(vec3 p) {\n    const int MAGIC_BOX_ITERS = 13;\n    const float MAGIC_BOX_MAGIC = 0.55;\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n\nfloat magicBox(vec2 uv){\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n    // volume along the same axes as the fractal's bounding box.\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n    vec3 p = 0.5*M*vec3(uv, 0.0);\n    return magicBox(p);\n}\n\n\n\n\nmat2 rot2D(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\nfloat nsin(float a){return .5+.5*sin(a);}\nfloat ncos(float a){return .5+.5*cos(a);}\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\nfloat dtoa(float d, float amount)\n{\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\n}\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\n{\n    vec2 d = max(tl-uv, uv-br);\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n}\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\n{\n    return length(uv - origin) - radius;\n}\n// 0-1 1-0\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\n{\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\n}\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n// returns -.5 to 1.5. i think.\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\t\n}\nfloat noise01(vec2 p)\n{\n    return clamp((noise(p)+.5)*.5, 0.,1.);\n}\n// debug function to convert distance to color, revealing sign.\nvec3 dtocolor(vec3 inpColor, float dist)\n{\n    vec3 ret;\n    if(dist > 0.)\n        ret = mix(vec3(0,0,.5), vec3(.5,.5,1), sin(dist * pi2 * 50.));// red = negative / inside geometry.\n    else\n\t    ret = mix(vec3(1.,.5,.5), vec3(.5,0,0), sin(dist * pi2 * 50.));// blue = positive, of of geometry.\n    ret = mix(ret, vec3(0), clamp(abs(dist),0.,1.));// falloff\n    return ret;\n}\n\nfloat smoothing(float x)\n{\n    return x*x*x*(x*(x*6. - 15.) + 10.);\n}\n\n////////////////////////////////////////////////////////////////\n// APP CODE ...................\n\n// this function will produce a line with brush strokes. the inputs are such\n// that you can apply it to pretty much any line; the geometry is separated from this function.\nvec3 colorBrushStroke(vec2 uvLine, vec2 uvPaper, vec2 lineSize, float sdGeometry, vec3 inpColor, vec4 brushColor)\n{\n    float posInLineY = (uvLine.y / lineSize.y);// position along the line. in the line is 0-1.\n\n    if(iMouse.z > 0.)\n    {\n//    return mix(inpColor, vec3(0), dtoa(sdGeometry, 1000.));// reveal geometry.\n//    return mix(inpColor, dtocolor(inpColor, uvLine.y), dtoa(sdGeometry, 1000.));// reveal Y\n//    return mix(inpColor, dtocolor(inpColor, posInLineY), dtoa(sdGeometry, 1000.));// reveal pos in line.\n//    return mix(inpColor, dtocolor(inpColor, uvLine.x), dtoa(sdGeometry, 1000.));// reveal X\n    \tfloat okthen = 42.;// NOP\n    }\n    \n    // warp the position-in-line, to control the curve of the brush falloff.\n    if(posInLineY > 0.)\n    {\n        float mouseX = iMouse.x == 0. ? 1.0 : (iMouse.x / iResolution.x);\n        //float mouseX = 1.0;   \n\t    posInLineY = pow(posInLineY, (pow(mouseX,2.) * 15.) + 1.5);\n    }\n\n    // brush stroke fibers effect.\n    float strokeBoundary = dtoa(sdGeometry, 300.);// keeps stroke texture inside the geometry.\n    float strokeTexture = 0.\n        + noise01(uvLine * vec2(min(iResolution.y,iResolution.x)*0.2, 1.))// high freq fibers\n        + noise01(uvLine * vec2(79., 1.))// smooth brush texture. lots of room for variation here, also layering.\n        + noise01(uvLine * vec2(14., 1.))// low freq noise, gives more variation\n        ;\n    strokeTexture *= 0.333 * strokeBoundary;// 0 to 1 (take average of above)\n    strokeTexture = max(0.008, strokeTexture);// avoid 0; it will be ugly to modulate\n  \t// fade it from very dark to almost nonexistent by manipulating the curve along Y\n\tfloat strokeAlpha = pow(strokeTexture, max(0.,posInLineY)+0.09);// add allows bleeding\n    // fade out the end of the stroke by shifting the noise curve below 0\n    const float strokeAlphaBoost = 1.09;\n    if(posInLineY > 0.)\n        strokeAlpha = strokeAlphaBoost * max(0., strokeAlpha - pow(posInLineY,0.5));// fade out\n    else\n        strokeAlpha *= strokeAlphaBoost;\n\n    strokeAlpha = smoothing(strokeAlpha);\n    \n    // paper bleed effect.\n    float paperBleedAmt = 60. + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\n//    amt = 500.;// disable paper bleed    \n    \n    // blotches (per stroke)\n    //float blotchAmt = smoothstep(17.,18.5,magicBox(vec3(uvPaper, uvLine.x)));\n    //blotchAmt *= 0.4;\n    //strokeAlpha += blotchAmt;\n\n    float alpha = strokeAlpha * brushColor.a * dtoa(sdGeometry, paperBleedAmt);\n    alpha = clamp(alpha, 0.,1.);\n    return mix(inpColor, brushColor.rgb, alpha);\n}\n\nvec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth)\n{\n    // flatten the line to be axis-aligned.\n    float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y);\n    mat2 rotMat = rot2D(lineAngle);\n\n    float lineLength = distance(p2_, p1_);\n    // make an axis-aligned line from this line.\n    vec2 tl = (p1_ * rotMat);// top left\n    vec2 br = tl + vec2(0,lineLength);// bottom right\n    vec2 uvLine = uv * rotMat;\n\n    // make line slightly narrower at end.\n    lineWidth *= mix(1., .9, smoothstep(tl.y,br.y,uvLine.y));\n    \n    // wobble it around, humanize\n    float res = min(iResolution.y,iResolution.x);\n    uvLine.x += (noise01(uvLine * 1.)-0.5) * 0.02;\n    uvLine.x += cos(uvLine.y * 3.) * 0.009;// smooth lp wave\n    uvLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\n//    uvLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\n\n    // calc distance to geometry. actually just do a straight line, then we will round it out to create the line width.\n    float d = sdAxisAlignedRect(uvLine, tl, br) - lineWidth / 2.;\n    uvLine = tl - uvLine;\n    \n    vec2 lineSize = vec2(lineWidth, lineLength);\n    \n    vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,\n                                d, inpColor, brushColor);\n    return ret;\n}\n\n// returns:\n// xy = uvLine\n// z = radius\nvec3 humanizeBrushStrokeDonut(vec2 uvLine, float radius_, bool clockwise, float lineLength)\n{\n    vec2 humanizedUVLine = uvLine;\n    \n\t// offsetting the circle along its path creates a twisting effect.\n    float twistAmt = .24;\n    float linePosY = humanizedUVLine.y / lineLength;// 0 to 1 scale\n    humanizedUVLine.x += linePosY * twistAmt;\n    \n    // perturb radius / x\n    float humanizedRadius = radius_;\n    float res = min(iResolution.y,iResolution.x);\n    humanizedRadius += (noise01(uvLine * 1.)-0.5) * 0.04;\n    humanizedRadius += sin(uvLine.y * 3.) * 0.019;// smooth lp wave\n    humanizedUVLine.x += sin(uvLine.x * 30.) * 0.02;// more messin\n    humanizedUVLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\n//    humanizedUVLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\n    \n    return vec3(humanizedUVLine, humanizedRadius);\n}\n\n// there's something about calling an Enso a \"donut\" that makes me giggle.\n// TODO: sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. 1=whole circle. 0=just a point.\nvec3 colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\n{\n\tvec2 uvLine = uv - o;\n    float angle = atan(uvLine.x, uvLine.y) + pi;// 0-2pi\n    angle = mod(angle-angleStart+pi, pi2);\n    if(!clockwise)\n        angle = pi2 - angle;\n    float lineLength = radius_ * pi2;// this is calculated before any humanizing/perturbance. so it's possible that it's slightly inaccurate, but in ways that will never matter\n    uvLine = vec2(\n        radius_ - length(uvLine),\n        angle / pi2 * lineLength\n    );\n    \n    // make line slightly narrower at end.\n    float lineWidth1 = lineWidth * mix(1., .9, smoothstep(0.,lineLength,uvLine.y));\n    \n    vec3 hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\n    vec2 humanizedUVLine = hu.xy;\n    float humanizedRadius = hu.z;\n\n    float d = opS(sdCircle(uv, o, humanizedRadius),\n                  sdCircle(uv, o, humanizedRadius));\n    d -= lineWidth1 * 0.5;// round off things just like in the line routine.\n\n    vec3 ret = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth1, lineLength), d, inpColor, brushColor);\n    \n    // do the same but for before the beginning of the line. distance field is just a single point\n    vec3 ret2 = vec3(1);\n    if(angle > pi)\n    {\n        uvLine.y -= lineLength;\n        hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\n        humanizedUVLine = hu.xy;\n        humanizedRadius = hu.z;\n        vec2 strokeStartPos = o + vec2(sin(angleStart), cos(angleStart)) * humanizedRadius;\n        d = distance(uv, strokeStartPos);\n        d -= lineWidth * 0.5 * 1.;// round off things just like in the line routine.\n        ret2 = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth, lineLength), d, inpColor, brushColor);\n\t}\n    return min(ret, ret2);\n}\n\n\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize)\n{\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\n    ret *= newSize;// scale up to new dimensions\n    float aspect = iResolution.x / iResolution.y;\n    ret.x *= aspect;// orig aspect ratio\n    float newWidth = newSize.x * aspect;\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/iResolution.xy;\n\tvec2 uvSignature = (fragCoord / iResolution.y * 2.0) - 1.;\n    mouse = getuv_centerX(iMouse.xy, vec2(-1,-1), vec2(2,2));// (iMouse.xy / iResolution.y * 2.0) - 1.;\n\tvec2 uv = getuv_centerX(fragCoord, vec2(-1,-1), vec2(2,2));// 0-1 centered\n    \n    vec3 col = vec3(1.,1.,0.875);// bg\n    float dist;\n    \n\t// geometry on display...\n\tfloat yo = sin(-uv.x*pi*0.5)*0.2;\n    vec4 colFour = vec4(vec3(.8,.1,0),.9);\n    float widFour = 0.15; \n    // 4\n    col = colorBrushStrokeLine(uv, col, colFour, vec2(-1.0, -0.6+yo), vec2(-1.6, 0.2+yo), widFour);\n    col = colorBrushStrokeLine(uv, col, colFour, vec2(-1.45, 0.05+yo), vec2(-0.5, 0.35-yo), widFour);\n    col = colorBrushStrokeLine(uv, col, colFour, vec2(-1.0, -0.6+yo), vec2(-1.0, 0.6+yo), widFour);\n    \n    // 0\n    col = colorBrushStrokeDonut(uv, col, vec4(0,0,0,.9),\n                                vec2(0,0),// origin\n                                0.4,// radius\n                                3.4,// angle of brush start\n                                0.5,// sweep amt 0-1\n                                0.2,// width\n                                true);// clockwise\n    \n    // 4\n    colFour = vec4(vec3(.8,.1,0),.8);\n    float dt = 2.3; \n    widFour = 0.15; \n    col = colorBrushStrokeLine(uv, col, colFour, vec2(-1.0+dt+yo, -0.4), vec2(-1.6+dt+yo, 0.2), widFour);\n    col = colorBrushStrokeLine(uv, col, colFour, vec2(-1.6+dt, -0.0-yo), vec2(-0.5+dt+yo, 0.25+yo), widFour);\n    col = colorBrushStrokeLine(uv, col, colFour, vec2(-1.0+dt+yo, -0.4), vec2(-1.0+dt+yo, 0.8), widFour);\n    \n    // paint blotches\n    float blotchAmt = smoothstep(20.,50.,magicBox((uv+12.)*2.));// smoothstep(40.,40.5, magicBox((uv+9.4)*2.));\n    blotchAmt = pow(blotchAmt, 3.);// attenuate\n    blotchAmt = .7*smoothstep(.2,.4,blotchAmt);// sharpen\n    col *= 1.-blotchAmt;\n\n    // grain\n    col.rgb += (rand(uv)-.5)*.08;\n    col.rgb = saturate(col.rgb);\n\t\n    // vignette\n    vec2 uvScreen = (fragCoord / iResolution.xy * 2.)-1.;\n\tfloat vignetteAmt = 1.-dot(uvScreen*0.5,uvScreen* 0.62);\n    col *= vignetteAmt;\n    \n    // col = pow( col, vec3(1.0,2.0,3.0) ) * pow( 4.0*p.y*(1.0-p.y), 0.25 );\n    fragColor = vec4(col, 1.) * pow( 4.0 * p.y * (1.0 - p.y), 0.25 );\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}