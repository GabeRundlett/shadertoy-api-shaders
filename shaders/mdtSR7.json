{
    "Shader": {
        "info": {
            "date": "1679588208",
            "description": "Click the music thingy in buffer A!\n\nFlicker is a little issue but pretty happy with this one :) \n\nThe tunnel idea was influenced by this shader: https://www.shadertoy.com/view/styBW1\n\n",
            "flags": 96,
            "hasliked": 0,
            "id": "mdtSR7",
            "likes": 62,
            "name": "Orb Tunneler",
            "published": 3,
            "tags": [
                "music",
                "blur",
                "orb",
                "depthoffield",
                "ponder"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 954
        },
        "renderpass": [
            {
                "code": "float box( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 px )\n{\n    vec2 uv = (px - 0.5 * res) / res.y;\n    uv = abs(uv);\n\n    // Chromatic aberration\n    vec4 l = cell(ch0, ivec2(px - vec2(2,0)));\n    vec4 r = cell(ch0, ivec2(px + vec2(2,0)));\n    vec4 c = cell(ch0, ivec2(px));\n    vec4 col = max(vec4(1,0,0,1)*l, vec4(0,0,1,1)*r);\n    col = max(vec4(0,1,0,1)*c, col);\n    \n    // Resolution ratio and top-right corner position\n    float rat = res.x / res.y;\n    vec2 tr = 0.5 * vec2(rat, 1);\n    \n    // Distances for decoration\n    float dMain = abs( box(uv, tr - 0.01 * rat) );\n    float dBox  = abs( mlength(uv - tr + 0.025 * rat) - 0.01 );\n    float dCir1 = length(uv - tr + vec2(.025,.042) * rat);\n    float dCir2 = length(uv - tr + vec2(.042,.025) * rat);\n    float dCir  = abs( min(dCir1, dCir2) - 0.008 );    \n    float d = min(dMain, min(dBox, dCir));\n    \n    // Smoothstep and mix\n    float s = 0.9 * smoothstep(-k, k, k - d);   \n    col.rgb = mix(col.rgb, vec3(0.95), s);\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Thanks to (everyone I've copied code + ideas from):\n// TheArtOfCode - raymarching\n//  BlackleMori - hash, erot\n//      Sizertz - AO, shadow\n//        NuSan - materials\n//        Tater - raymarching\n//         Leon - raymarching hash trick\n//           iq - pal, smin, most things!\n\n#define tau 6.2831853071\n#define pi 3.1415926535\n#define t iTime\n#define res iResolution.xy\n#define k 1./iResolution.y\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define pal(a,b) .5+.5*cos(2.*pi*(a+b))\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n#define Dir(a) vec2(cos(a),sin(a))\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n\nvec4 cell(in sampler2D ch, in ivec2 p) {\n    ivec2 r = ivec2(textureSize(ch, 0));\n    p = (p+r) % r;\n    return texelFetch(ch, p, 0);\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat h21(vec2 a) { return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123); }\nfloat mlength(vec2 uv) { return max(abs(uv.x), abs(uv.y)); }\nfloat mlength(vec3 uv) { return max(max(abs(uv.x), abs(uv.y)), abs(uv.z)); }\n\nfloat smin(float a, float b, float str) {\n    float h = clamp(0.5 + 0.5 * (b - a) / str, 0., 1.);\n    return mix(b, a, h) - str * h * (1. - h);\n}\n\nfloat seg(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define MAX_STEPS 400\n#define MAX_DIST 50.\n#define SURF_DIST .001\n\n#define rn 64.0\nfloat getFreq(float x) {\n\treturn texture(ch2, vec2(floor(x * rn + 1.) / rn, 0)).x;\n}\n\nvec3 ori() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 ro = vec3(1, 1.8, -3);\n    ro.xz *= rot(-0.2 * t);\n    // ro.yz *= rot(-m.y*3.14+1.);\n    // ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nvec2 map(vec3 p) {   \n    // Increase y with distance from origin\n    p.y += 0.4 - 0.01 * dot(p.xz, p.xz);\n\n    // Elevate texture from plane\n    float tx = texture(ch1, 0.015*(p.xz + 0.5 * t)).r;\n    tx += 0.4 * texture(ch1, 0.1 * (p.xz + 0.5 * t)).r;\n    \n    // Plane distance\n    float d = p.y - tx;\n    \n    // Sphere radius\n    float r = 0.55;\n    \n    // Cutout line from plane\n    float dSeg = seg(p, vec3(0,0.5*r,0), vec3(-100, 0.5*r, -100), r);\n    d = -smin(-d, dSeg, r);\n    \n    // Sphere at origin\n    vec3 q = vec3(0, 0.5 * r, 0);   \n    float dSphere = length(p - q) - r;\n    \n    // Audio\n    float f = getFreq(0.25);\n    float f0 = getFreq(0.);\n    \n    // Orbiting sphere, mix between 2 positions with audio\n    float mx = .5+.5*cos(8.*pi*f0);\n    //p.xz = mix(p.xz * rot(-t), p.xz * rot(t), mx);\n    vec3 q2 = vec3(1.5 * f, 2.5 * r - f * r, 1.5 * f);\n    float r2 = 1.4*r*f*f0*f0;\n    q2.xz *= rot(t);\n    float dSphere2 = length(p - q2) - tanh(0.1 * t) * r2;\n    \n    // Maybe sloppy way of return mat etc\n    //dSphere2 = smin(dSphere, dSphere2, length(q-q2));\n    if (dSphere2 < min(dSphere, d))\n        return vec2(dSphere2, 0.5);\n    \n    // dSphere = min(dSphere, dSphere2);\n    if (dSphere < d)\n        return vec2(dSphere, 1.);\n\n    return vec2(d, 0.);\n}\n\nvec3 march(vec3 ro, vec3 rd, float z) {\t\n    float d = 0.;\n    float s = sign(z);\n    int steps = 0;\n    float mat = 0.;\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = ro + rd * d;\n        vec2 m = map(p);\n        //m.x *= 0.8 + 0.2 * hash(hash(p.x,p.z), p.y); // for glow\n        if (s != sign(m.x)) { z *= 0.5; s = sign(m.x); }\n        if (abs(m.x) < SURF_DIST || d > MAX_DIST) {\n            steps = i + 1;\n            mat = m.y;\n            break;\n        }\n        d += m.x * z; \n    }   \n    return vec3(min(d, MAX_DIST), steps, mat);\n}\n\nvec3 norm(vec3 p) {\n\tfloat d = map(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 dir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = ori();\n    \n    vec3 rd = dir(uv, ro, vec3(0), 1.);\n    vec3 col = vec3(0);\n   \n    // March 1\n    vec3 m = march(ro, rd, 1.);  \n    float d = m.x;    \n    vec3 p = ro + rd * d;\n    vec3 n = norm(p);\n    vec3 r = reflect(rd, n); \n    \n    // March 2 (reflect)\n    vec3 p2 = p + 200. * SURF_DIST * n;\n    vec3 m2 = march(p2, r, 1.);\n    vec3 n2 = norm(p2);\n    vec3 r2 = reflect(r, n2);\n    \n    // March 3 (reflect)\n    vec3 p3 = p2 + 200. * SURF_DIST * n2;\n    vec3 m3 = march(p3, r2, 1.);\n    vec3 n3 = norm(p3);\n    vec3 r3 = reflect(r2, n3);\n\n    float f0 = getFreq(0.);\n\n    col = vec3((m2.y + m3.y)/(2.*MAX_DIST));\n\n    // Lighten origin sphere\n    if (m.z == 1. && m2.z == 0.)\n        col *= 1.8;\n        \n    // Lighten orbit sphere with audio\n    else if (m.z == 0.5)\n        col *= 3. * f0;\n\n    // Draw nyan cat on plane :)\n    else if (m.z == 0.) {\n        vec2 tuv = 0.1 * (1.5 * (p.xz + 0.5*t));\n        tuv *= rot(-pi/2.+pi/4.);\n        tuv *= 0.2 * vec2(1,8);         \n        vec3 tx = texture(ch0, tuv).rgb;\n        col =  mix(col, tx, 0.4);\n    }\n\n    // Lighten with distance from origin\n    col = mix(col, vec3(1.3), 1.-1./cosh(0.15*length(p.xz)));\n    \n    // Darken with distance travelled in march 3\n    vec3 gl = vec3(1. - 1./cosh(-0.045 * m3.y));\n    col *= gl;\n    \n    // Change color with audio (with distance from origin)\n    vec3 cl = .5 + .5 * cos(2.*pi*(3.*f0 + vec3(0,1,2)/3.));\n    cl *= tanh(0.05 * t);\n    vec3 cl2 = f0 * f0 * cl * (exp(-2.*length(p2)) + exp(-2.*length(p)));\n    //col = mix(col*20.*cl2, col+cl2, .6+.4*ths(4., 4.*(p.y)-0.5*t));\n    \n    // Gamma correction\n    col = pow(col, vec3(1./2.6)); \n    \n    col += cl2;\n      \n    fragColor = vec4(col, d);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 32849,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/polyphiaofficial/playing-god?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 px )\n{\n    vec2 uv = (px - res) / res.y;\n    //vec2 ms = (iMouse.xy - res) / res.y;\n    vec4 col = cell(ch0, ivec2(px));\n    vec3 av = vec3(0);\n\n    vec2 hres = 0.5 * res;\n    float a = hash(px.x, px.y) * 2. * pi; \n    float r = 0.;\n    float count = 0.;\n    \n    // Hardcoded distance from origin to camera position\n    // (sphere is at origin)\n    float td = length(vec3(1, 1.8, -3)); \n    \n    for (float i = 0.; i < 24.; i++) {\n        // Blur with distance from mouse y position\n        // (unused because it has artifacts at certain resolutions)\n        // float sc = 10. * (1.-1./cosh(0.8*abs(uv.y-ms.y)));\n\n        // Blur with abs(scene distance - target distance)\n        float sc = 2. * (1.-1./cosh(0.1+0.2*abs(col.a-td)));\n        \n        // Increase angle and radius from px for noisy blur\n        a += 1.;     \n        r += sc;\n        \n        // New pixel and cell value\n        vec2 cpx = px + r * Dir(a);\n        vec3 c = cell(ch0, ivec2(cpx)).rgb;\n        \n        // Only sample on-screen cells\n        float s = step(abs(cpx.y - hres.y), hres.y) *\n                  step(abs(cpx.x - hres.x), hres.x);\n        \n        // idk\n        s *= log(1.+r);\n        \n        count += s;\n        av += s * c;\n    }\n    \n    av /= count;\n\n    fragColor = vec4(av, col.a);\n  \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}