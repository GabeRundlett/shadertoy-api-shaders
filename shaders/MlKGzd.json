{
    "Shader": {
        "info": {
            "date": "1476325746",
            "description": "I disabled the whole renderer because it broken beyond repair due to lack of compatibility.\na useful segment starts at line 170 of BufA; spiral staircase distance function...\n\ndefunct keys: r esdf n  ...",
            "flags": 48,
            "hasliked": 0,
            "id": "MlKGzd",
            "likes": 1,
            "name": "003 spiral staircase distance",
            "published": 3,
            "tags": [
                "spiral",
                "hgsdf",
                "babel"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 503
        },
        "renderpass": [
            {
                "code": "/*\nR: fly mode\nesdf: fly mode movement\nN: normal coloring\nT: translucency\nA: ambient occlusion\nG: grid\nH: distance visualization\nJ: step visualization\nC: cast normal/view coordinates\nX: axes\nQ: flip windows (top/front/left -> bottom/back/right)\n\nbackup of \"SDF Inspector\" by \"lara\":\nhttps://www.shadertoy.com/view/MlVGRh\n\nfont by Flyguy (Bit Packed Sprites 2 (5x7)):\nhttps://www.shadertoy.com/view/llSGRm\n*/\n\nvoid mainImage(out vec4 r,in vec2 f){\n float e=texture(iChannel0,(vec2(0)+0.5)/iResolution.xy).x;\n f.xy *=e;//if(f.y<1.5)f.y+=1./e; //Hide data pixels\n vec4 t=texture(iChannel1,f.xy/iResolution.xy/e);\n r=vec4(mix(texture(iChannel0,f.xy/iResolution.xy).rgb,\n  t.rgb,t.a),1);}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//this shader got ruined by an update of how shadertoy now supports more shader models.\n//as in, too many errors to bother.\n//its most valuable part is the distance function to a spiral staircase\n//that i failed to make seamless due to lak of finding the right scaling fator\n//and due to lack of making\n//the right camera controls to test how well the seam location looks.\n\n\n\n\n/*\nmemo.\nalongsinde textureID also return normScale\n, where normalscale scales the normal calculation\nto ake it fuzzier on demand.\n\nthis method has a ballancing act priorizing between\n- good looking nearby normals with good gradients\n- less artefacts for more distant objects.\n- - generally good loking nearby normals win this one.\n*/\n\n/*\nbackup of \"SDF Inspector\" by \"lara\":\nhttps://www.shadertoy.com/view/MlVGRh\nmerged with code from\nhttps://www.shadertoy.com/view/4td3Dj\nfor far render distance\n\nR: fly mode\nesdf: fly mode movement\nN: normal coloring\nT: Transparency\nA: ambient occlusion\nG: grid\nH: distance visualization\nJ: step visualization\nC: cast normal/view coordinates\nX: axes\nQ: flip windows (top/front/left -> bottom/back/right)\n\n(x)Cyan   |blue\n(y)Magenta|pink\n(z)Yellow\n\nFor performance, Lower steps (S) and/or substeps (R).\nThe grid also seems to have a great impact on the fps.\n\nshortened from 8733 to 7777 chars.\n*/\n\n//3 orthogonal side windows, not too pretty.\n//#define Show3Axis\n\n//temporarily defunct, not really worth it.\n//#define noTransparency\n\n#define MarchSimple\n//MarchSiple has a much shorter view distance!\n//without MarchSimple epsilon increases each step,\n//allowing for a much higher render diastance.\n//parameters for non-MarchSimple:\n#define EPS_INIT .0\n//EPS_INIT can be much smaller, only makes sense for fractals close up.\n//#define MAX_DIST          30000000.\n//MAX_STEPS can easily be 1000000. but may crash in higher resolutions\n//#define MAX_STEPS         100000000.\n//MAX_HARD can be 200 to 2000, depending on hardware, but may crash in higher resolutions\n//#define MAX_HARD  512\n#define epsmod1 eps=mad(d,.0000000000001,eps*1.0000000000001);\n//#define epsmod1 eps=nextDistance*.0001+eps*1.005;\n//epsilon increases exponentially, set by step distances.\n//above functions ballances performance/quality the most\n//as it sets a converging cubic-function for many different cases.\n//It makes raymarching more convergent by increasing epsilon and\n//different scenes have different ideal settings for it.\n//like the differences of indoor to outdoor scenes.\n//in general smaller constants cause beter quality and lower fps.\n//\n#define epsmod2 maxSteps -=eps*d;\n//maxSteps dains slower on short step distances.\n//this makes maxDist the limit for many short steps.\n#define epsmod3 maxDist  -=eps/d;\n//maxdist drains slower on long step distances.\n//this makes maxSteps the limit for many large steps.\n\n/*\nconst float  \n RES       =1./1.// 1./1.61//smaller RES == faster rendering\n,GRID_SIZE =1./4.\n,GRID_WIDTH=1./2.\n,P=0.1     // Precision\n,D=5.     // Max distance\n,A=4.     // AO steps\n,R=1.     // March substeps, the lazy factor for too large lipschitz constnts.\n;const int _num_objects=4\n#ifdef MarchSimple\n,S=512    // March steps\n#else\n,S=256\n#endif\n;const vec2 \n _bufA_res       =vec2(0)\n,_bufA_mouse     =vec2(1,0)\n,_bufA_mouse_drag=vec2(2,0)\n,_bufA_cam_pos   =vec2(3,0)\n,_bufA_cam_dir   =vec2(4,0)\n,_bufA_cast      =vec2(5,0)\n;const vec3 \n// COL_FOG    =vec3(.3,.4,.6)\n COL_GRID   =vec3(.5)\n,COL_PLANE_A=vec3(.25)\n,COL_PLANE_B=vec3(0,1,2)\n;bvec3 \n_plane=bvec3(false,false,false),//looks like i brke this one\n_grid =bvec3(false,false,false);\n//bvec3(_grid_yz,_grid_xz,_grid_xy)\n*/\n\n/*\n#define skyColor       vec3(.1,.5,1.)\n#define shadowColor    vec3(.1,.1,.5)\n#define groundColor    vec3(.6,1.,.7)\n#define buildingsColor vec3(.8,.7,.2)\n#define redColor       vec3(1.,.1,.8)\n*/\n//these colors visually make sense for contrast, even for red-green blindness.:\n//shadows are blue\n//ground is greener\n//floating objects are red\n//near ground objects are yellow\n/*\n#define SKY_MTL 0\n#define GROUND_MTL 1\n#define BUILDINGS_MTL 2\n#define RED_MTL 3\n\n//these defines are not too practiical:\n#define fovyCoefficient 1.\n#define shadowHardness 3.\n#define time iTime\n*/\n\n//i lost my latest cleaned up iprved version of this, \n//leaving us with this older messier version.\n\n//the ugliest thing here is that,\n//if a reflected ray runs out of steps/distance, it aborts\n//meaning it is the last reflection\n//but without dithering this looks a bit ugly\n//\n//in other versions i added fake dithering by modifying RayDirection by +=0.001\n//for each step.\n//this warps space a bit (speudo randomly), which is still fine, we call this \"gravity\" , ya know?\n\n//the main trick here is that some cases are better for (nearby) reflections \n//while others are better for ling distance surfaces.\n//and all combinations can be made almost linearily convergent.\n//the problem here is that it only starts to look good \n//with at least 500 itterations of raymarching\n//too much for the average 2014 hardware in useful resolutions/framerates\n\n\n\n\n\n\n\n\n//distance function to spiral staircase:\n//idea is to make a mod() linear endless array of boxes,\n//that are rotated so that 2 of their corners touch.\n//As lazy equalent to a distance function to \n//2 rotated seesaw functions, extruded, but that reuses the distance field of a box.\n//and also simplifies the option to make the boxes non-cubic, \n//allowing steps to be longer than high.\n//\n//The overlapped min() of 2 such offset box-arrays creates a rotated staircase that does not ascend in height.\n//just like a skewed seesaw function, but it is using boxes to make sure all angles are 90°\n//\n//then we rotate the point before gettign the distance to that distance function...\n//to make one face of the box array parallel to whatever plane is defined as the ground.\n//and the result should be an endlessly ascending staircase.\n//which is a simple sin() trigonometry.\n//then you change one dimension to make a strasight line to a spiral.\n//\n//i failed to scale that staircase correctly along whatever dimension equals height .z,\n//to have the exits on a knowable height (of levels to enter and exit) exactly above each other.\n//so i cut into pieces with mod(), trying to scale a piece to fit to an exit-plane.\n//and that also failed.\n\n//PIB = PI/2, PI=3.14 //Tau=pi*2\n//== quater, half and, full rotation in complex number multiplication.\n#define PIB asin(1.)\n#define PI  acos(-1.)\n#define TAU (PI*2.)\nmat2 rot(float a){float c=cos(a),s= sin(a);return mat2(c,s,-s,c);}\n#define pMod(x,d) (mod(x+d*.5,d)-d*.5)\n//hg_sdf by mercury:\nfloat fBoxCheap(vec3 p,vec3 b){vec3 q=(abs(p)-b);return max(max(q.x,q.y),q.z);}\nfloat fOpUnionStairs(float a,float b,float r,float n){float s=r/n;float u=b-r;return min(min(a,b),.5*(u+a+abs(mod(u-a+s,2.*s)-s)));}\n#define fOpIntersectionStairs(a,b,r,n) -fOpUnionStairs(-a,-b,r,n)\n#define fOpDifferenceStairs(a,b,r,n) -fOpUnionStairs(-a,b,r,n)\n//float fOpUnionChamfer(float a,float b,float r){return min(min(a,b),(a-r+b)*sqrt(.5));}\nfloat fOpIntersectionChamfer(float a,float b,float r){return max(max(a,b),(a+r+b)*sqrt(.5));}\n#define fOpDifferenceChamfer(a,b,r) fOpIntersectionChamfer(a,-b,r)\nfloat stairs(vec3 p){vec3 dim=vec3(.2,.1,.5);\n float r=atan(dim.y,dim.x);p.y-=2.;//rotated array of boxes whos borders touch\n p.x=pMod(p.x,length(dim.xy)*2.);\n p.xy*=rot(r);float c=fBoxCheap(p,dim);return c;}\n\n//2 overlapping arrays of tilted boxes => staircase\nfloat stairTwi2(vec2 p){vec2 pr=p;pr.xy*=rot(-atan(1.,2.));\n return min(stairs(vec3(pr,0.)+vec3(.2236067977499,.0,.0)),stairs(vec3(pr,0.)));}\n//the vec2 offset was twiddled in attepts to make it seamless.\n\nfloat FukingSiralStaircase(vec3 p){p.y+=1.8;p.y*=.6;\n float cyl=length(p.xz)-4.;vec3 pt=p.zxy;\n float a=atan(pt.y,pt.x);//you can multiply a by a scaling factor here for wider steps.\n //but what bothers me for aseamless staircase is the height of a step.\n //float c=stairTwi2(vec2(cos(a*2.)*2.,pt.z));\n float c=stairTwi2(vec2(a*2.,pt.z));\n c=fOpIntersectionChamfer(c,cyl,.05);\n cyl=length(p.xz)-2.;\n c=fOpDifferenceChamfer(c,cyl,.05);\n return c;}\n\n//the staircases have to exist as infinite ones, without modulo.\n//return intance of p.xy to an endless spiral staircase.\n//so far i failed to get the edges in the right distances for it to be seamless.\n//the correct scaling factor definitely contains Pi.\nfloat endlessStairCase(vec3 p){\n    p.y-=2.;\n p.y=pMod(p.y,8.);\n vec3 s=vec3(1.,2.5,1.);\n float c=FukingSiralStaircase(p);\n p.y-=10.5;\n return min(c,FukingSiralStaircase(p));\n    //this has bad artefacts. need other case handler?\n}//2 repeats. mod()\n\n//distance field...\nfloat room(vec3 p){\n float sc=endlessStairCase(p);//sc == closest signed distance to spical staircase.\n    //...\n p.y=pMod(p.y,4.);//level height\n p.y-=2.;\n float cei=fBoxCheap(p,vec3(10.,.1,10.));//ceiling\n p.y+=4.;\n float flo=fBoxCheap(p,vec3(10.,.1,10.));//floor\n float cyl=length(p.xz)-4.;//a cylinder\n flo=min(cei,flo);\n flo=fOpDifferenceChamfer(flo,cyl,.05);//substractign a cylindrical hole\n    \n //above is where i failed to make it seamless and scaled to a set level height.\n \n flo=min(flo,sc);\n vec3 p2=p;p2.y-=1.8;//center of head is 1.8 m high.\n float head=length(p2)-.25;//humanoid.head\n vec3 p3=p2;p3.y+=.9;p3.xz*=1.2;p3.y*=.25;\n float body=length(p3)-.2;//humanoid.body\n float hum=min(head,body);\n return min(flo,hum);//body distance field forscale:\n}\n//todo, add hexagonal walls to this room and make it endlessly mod()-repeat in a hex pattenr.\n//alon the xy.plane\n//it should already mod() repeat endlessly along the .z height dimension.\n\n\n//i forgot what this distance field is shaped like, but its not like the room() above.\nfloat engine(vec3 p){p.y-=3.;p*=.3;p.z-=1.;\n vec3 m=pMod(p,4.);vec3 r=p-m;\n m.xy*=rot(r.z);m.zx*=rot(r.y);m.yz*=rot(r.x);\n float c=cos(length(m.xy)*5.),s=sin(length(m.xy)*5.);\n m.yz*=mat2(c,s,-s,c);\n float engine=length(vec2(length(m.xy)-.5,m.z))-.2;\n return engine;}\n\n// Your SDF here\nfloat myObject(vec3 p){\n  return room(p);\n  return min(engine(p),room(p));\n}\n\n\n//end of distance field functions\n//completely broken renderer starts here:\n\nstruct Hit{vec3 p;float t,d,s;};\nstruct Ray{vec3 o,d;},_ray;\nstruct Cam{vec3 p,d,u;float f;},_cam;\n\nint _ignore = -1;\nfloat _d, _dplanes,_dgrid,_darrow,_dobject;\n#define ratio (iResolution.y/iResolution.x)\n\nbool\n_ortho=false,\n_ambOccMarch=false;\n\nvec3 _cast,_cpos;\n\nvec3 safeNormalize(vec3 p){float l=length(p);//if(l==0.)return vec3(0);\n return sign(l)*p/max(abs(l),.000001);}\n\n// ( pos., normal, dist. to obj., dist. travelled, steps taken, cam pos. )\nvec3 myColor(vec3 p,vec3 n,float d,float t,float s,vec3 c){\n vec3 m=safeNormalize(c-p);return vec3(max(dot(n,m),.0)//diffuse\n +pow(max(dot(reflect(safeNormalize(p-c),n),m),.001),100.));}//specular\n\n/*\n//Scene\nfloat sdCone_(vec3 p,vec3 a,vec3 b,float r1,float r2){\n vec3 c=b-a,e=p-a;\n float t=clamp(dot(e,c)/max(dot(c,c),P),0.,1.);\n return length(e-c*t)-mix(r1,r2,t);}\n\n#define set(a,b) if(gl_FragCoord.x==a.x+0.5&&gl_FragCoord.y==a.y+0.5){b;return true;}\n#define get(a,b) texture(b,(a+0.5)/iResolution.xy)\n#define init(a) if(iFrame<2){a;return true;}\n#define keyInfo(a,b) texture(iChannel3,(vec2(a,b)+.5)/vec2(256.,3.)).x \n#define griddy(a,b) d=min(d,length(vec2(mod(p.a+s/2.,s)-s/2.,p.b))-GRID_WIDTH);\n#define griddi(A,B,C) if(_grid.A){griddy(B,A)griddy(C,A)}\nfloat sdGrid(vec3 p){\n if(_ambOccMarch||keyInfo(74.,2.)> 0.||keyInfo(71.,2.) > 0.)return 1e10;\n float d=1e10,s=GRID_SIZE*(float(_ortho)*3.+1.);\n griddi(y,x,z)griddi(z,x,y)griddi(x,y,z)\n return d;}\n\n#define griddo(A,B) if (_ortho||!_grid.A)d=min(d,length(p.B)-r);\nfloat sdAxes(vec3 p){\n if(_ambOccMarch||keyInfo(74.,2.)> 0.||keyInfo(88.,2.)> 0.)return 1e10;\n float d=1e10;\n float r=GRID_WIDTH*(float(_ortho)*3.+1.);\n griddo(y,xz)griddo(z,xy)griddo(x,yz)\n return d;}\n\nfloat sdDistancePlanes(vec3 p){\n if(_ambOccMarch||keyInfo(74.,2.)> 0.||keyInfo(72.,2.)>0.)return 1e10;\n float d=1e10;\n if((_plane.y&&!_ortho)||(_ortho&&!_plane.z&&!_plane.x))\n  d=min(d,abs(p.y));\n if(_plane.z)d=min(d,abs(p.z));\n if(_plane.x)d=min(d,abs(p.x));\n return d;}\n\n#define moo(a,b) b(p+e.a)-b(p-e.a)\n#define mooe(a) moo(a,myObject)\nvec3 getNormalExclusive(vec3 p){vec2 e=vec2(P,0.);\n return safeNormalize(vec3(mooe(xyy),mooe(yxy),mooe(yyx)));}\n\nfloat sdNormalArrow(vec3 p){\n if(_ambOccMarch||keyInfo(67.,2.)< 1.)return 1e10;\n vec3 n=getNormalExclusive(_cast);\n return min(sdCone_(p,_cast     ,_cast+n*.1,0.005,0.005),\n            sdCone_(p,_cast+n*.1,_cast+n*.13,0.015,0.0));}\n\n//for mad()-awareness.\nfloat mad (float b,float c,float d){return b*c+d;}\n\nfloat scene(vec3 p){\n _d=1e10;\n _dplanes=sdDistancePlanes(p);\n _dgrid  =min(sdAxes(p),sdGrid(p));\n _darrow =sdNormalArrow(p);\n _dobject=_ignore==3?1e10:myObject(p);//these global are read elsewhere still.\n _d=min(_d,_dplanes);\n _d=min(_d,_dgrid);\n _d=min(_d,_darrow);\n _d=min(_d,_dobject);//_ is read later and gloal, so why even return it here!\n return _d;}//5 is 1 branch too much for a tree.\n\n#define moos(a) moo(a,scene)\nvec3 getNormal(vec3 p){vec2 e = vec2(0.001,0.);\n return safeNormalize(vec3(moos(xyy),moos(yxy),moos(yyx)));}\n\nRay lookAt(Cam c, vec2 v){\n vec3 r=safeNormalize(cross(c.d,c.u)),u=cross(r,c.d);\n if(_ortho)return Ray(c.p*c.f+v.x*r+v.y*u,c.d*c.f);\n           return Ray(c.p*c.f,safeNormalize(v.x*r+v.y*u+c.d*c.f));}\n\n#ifdef MarchSimple\nHit march(Ray r){float t=0.,d,s;vec3 p;    \n for(int i=0;i<S;i++){\n  d=scene(p=r.o+r.d*t);\n  if(d<P||t>D){s=float(i);break;}//surface.hit ; p is epsilon precision\n  t+=d/max(R+1.,1.);\n  d*=(20000.);\n#else\nHit march(Ray r){float t=0.,d,s;vec3 p;  \n //float maxDist =MAX_DIST;\n //float maxSteps=MAX_STEPS;\n float eps     =EPS_INIT;\n for(int i=0;i<S;i++){\n  d=scene(p=r.o+r.d*t);\n  //if(d<eps||t>D){\n  if(d<eps){s=float(i);break;}//surface.hit\n  t+=d/max(R+1.,1.);//max(R+1.,1.);//R=march Substeps\n  epsmod1 //epsmod2//epsmod3 \n#endif\n s=float(i);}\n float ooo=cos(iTime*.5-3.)*.5+.5-.01;       \n return Hit(p,t,d*(200.*ooo),s);}\n\n//Shade\nfloat getAmbientOcclusion(Hit h){_ambOccMarch=true;float t=0.;\n for(float i=0.;i< A;i++)t+=scene(h.p-_ray.d*i/A*.2);\n return clamp(t/A*20.,0.,1.);}\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c){const vec4 K=vec4(3.,2.,1.,9.)/3.;\n return c.z* mix(K.xxx,clamp(abs(fract(c.xxx+K.xyz)*6.-K.www)-K.xxx,0.,1.), c.y);}\n*/\n\n/*\n#define shh float h=h.s/float(S)\n#define hhh hsv2rgb(vec3(h,1.,1.));}\nvec3 getColor(Hit h){\n float key_j=keyInfo(74.,2.);\n if(h.d>P){\n  if(key_j>0.){shh;return hhh\n  return vec3(.1);}//return COL_FOG;}\n vec3 col=vec3(0),c,n=getNormal(h.p);\n float opacity=0.,lastOpacity=0.,dist=pow(max(h.t/D,P),2.);\n bool firstPass=true;\n for(int i=0;i<2;i++){\n  if(_d==_dplanes){\n   if (key_j<1.){\n    float d=myObject(h.p);\n    c=(d>=0.?COL_PLANE_A:COL_PLANE_B)*smoothstep(0.,1.,(sin(d/P*.2)+1.)*.5);\n   }else{shh;c=hhh\n  }else if(_d==_dgrid){\n   c=COL_GRID;\n   if(keyInfo(88.,2.)<1.){\n    float r=GRID_WIDTH*2.*(float(_ortho)*3.+1.);\n         if(length(h.p.xy)-r<0.)c=vec3(1,1,0);\n    else if(length(h.p.xz)-r<0.)c=vec3(1,0,1);\n    else if(length(h.p.yz)-r<0.)c=vec3(0,1,1);}}\n  else if(_d == _darrow)\n   c=vec3(1.5)*max(dot(n, safeNormalize(_cam.p-h.p)),.0);\n  else if(_d==_dobject){\n   c = myColor(h.p,n,h.d,h.t,h.s,_cam.p);\n   // key N is on: display normals\n   if(keyInfo(78.,2.) > 0.)c = (n+1.)/2.;\n   // key T is off: make object translucent\n   else if(keyInfo(84.,2.) < 1.){opacity=.5;_ignore = 3;}}\n  //#ifdef noTransparency\n   col=c;\n   break;\n /*\n  #else\n   if(firstPass){// not pretty i know\n    col=c;\n    firstPass=false;\n   }else{\n    #ifdef MarchSimple\n     float f=_ortho||key_j>0.?0.:pow(max(h.t/D,P),2.);\n     //c=mix(c, COL_FOG,f);\n    col=mix(col,c,lastOpacity);}\n    #else\n    col=c;}\n    #endif\n  #endif\n  */\n/*\n  if(opacity>0.){\n   _ray.o=h.p;h=march(_ray);\n   //if(h.d>P){\n       col=c;break;\n   //}//col=mix(c,COL_FOG,opacity);break;}\n   lastOpacity=opacity;continue;}\n  break;}\n if(keyInfo(65.,2.)<1.)col*=getAmbientOcclusion(h);// key A is off\n return col;}//return mix(col,COL_FOG,_ortho||key_j>0.?0.:dist );}\n*/\n\n#define F gl_FragColor\n#define Fxyz(a) F.xyz=a;\n\n#define nyzx(n) n.yz*=rot(d.x);n.xz*=rot(d.y);\nbool logic(){\n    /*\n//this used to compile just fine, but shadertoy changed its rules to nonsense\n\n F=texture(iChannel0, gl_fragColor.xy/iResolution.xy);\n set(_bufA_res,   F.x=RES);\n set(_bufA_mouse,{F=iMouse;\n });set(_bufA_mouse_drag,{\n  init(F=vec4(0));\n  if(keyInfo(67.,2.) > 0.)return true;//No drag in cast mode\n  vec4 iMouseLast=get(_bufA_mouse,iChannel0);\n  if(iMouseLast.w<1.)iMouseLast.xy=iMouse.xy;\n  float key_r=keyInfo(82.,2.);\n  float t=get(_bufA_cam_pos,iChannel0).w;\n  if(key_r!=t){F.xy=vec2(0);return true;}//on(view toggle)Reset values \n  vec2 uv=iMouse.xy/iResolution.xy;\n  vec2 a=vec2(1.-1./3.*ratio,1.);\n  if(uv.x<a.x)        \n   F.yx+=(iMouseLast.xy-iMouse.xy)/(iResolution.xy*a)*vec2(1,-1)*2.;\n });set(_bufA_cam_dir,{\n  vec3 n=safeNormalize(-_cpos);\n  init(Fxyz(n));\n  vec4 d=get(_bufA_mouse_drag,iChannel0);     \n  if (keyInfo(82.,2.) < 1.){n=_cpos;nyzx(n)//if(!flyMode)look at vec3(0)\n   Fxyz(safeNormalize(-n));return true;}nyzx(n)Fxyz(n)\n });set(_bufA_cam_pos,{\n  init(Fxyz(_cpos));\n  float key_r=keyInfo(82.,2.);\n  //on(view toggle)Reset position \n  if(key_r!= F.w){Fxyz(_cpos)F.w=key_r;return true;}\n  if(key_r<1.){//if(!FlyMode)Rotate around vec3(0)\n   vec2 d=get(_bufA_mouse_drag,iChannel0).xy;\n   Fxyz(_cpos)nyzx(F)return true;}\n  vec3 dir  =get(_bufA_cam_dir,iChannel0).xyz;\n  vec3 right=safeNormalize(cross(dir,vec3(0,1,0)));\n  float key_left =keyInfo(83.,0.);//keyInfo(37.,0.)\n  float key_up   =keyInfo(69.,0.);//keyInfo(38.,0.)\n  float key_right=keyInfo(70.,0.);//keyInfo(39.,0.)\n  float key_down =keyInfo(68.,0.);//keyInfo(40.,0.)\n  float x=key_left>0.?-1.:key_right>0.?1.:0.;\n  float z=key_down>0.?-1.:key_up   >0.?1.:0.;\n  F.xyz += (right*x + dir*z)*.1;\n  F.w = key_r;\n });set(_bufA_cast,Fxyz(_cast));return false;\n*/\n    return false;\n    //this function got fucked  over completely by a shadertoy parser changing upate.\n}\n\n//Main\nvoid mainImage(out vec4 r,in vec2 o){\n    /*\n //_cpos=safeNormalize(vec3(1,1,-1.2))*2.;\n //vec2 uv=o.xy/iResolution.xy/RES;\n //Discard pixels that are outside the defined resolution:\n //if(uv.x>1.||uv.y>1.)discard;\n _//cam=Cam(\n // iFrame<2? _cpos   :get(_bufA_cam_pos,iChannel0).xyz,\n // iFrame<2?-_cpos/2.:get(_bufA_cam_dir,iChannel0).xyz,\n // vec3(0,1,0),1.);\n //float f=1.;\n //vec2 s=vec2(1./6.)*vec2(ratio,1);\n// vec2 a=vec2(1.-s.x*2.,1.);\n //if(keyInfo(67.,2.) > 0.)//if(Key C)cast a ray to the mouse position\n // _cast=march(lookAt(_cam,(2.*iMouse.xy/RES-iResolution.xy*a)/(iResolution.xx*a.xx))).p;\n// \n    //if(logic()){r=gl_FragColor;return;\n  //          }\n */\n #ifdef Show3Axis\n  /*\n if(uv.x>1.-s.x*2.-.0025){_ortho=true;// axis-view windows\n  if(length(max(abs((1.-uv)-s)-s,0.))==0.){\n  _plane.y=true;_grid=bvec3(false,true,false);//top\n  _cam.p=vec3(0,D,0);_cam.u=vec3(0,0,-1);_cam.d=vec3(0,-1,0);\n  }else if(length(max(abs((1.-uv-vec2(0,s.y*2.))-s)-s,0.))==0.){\n   _plane.z=true;_grid=bvec3(true,false,false);//front\n   _cam.p = vec3(0,0,D);_cam.u = vec3(0,-1,0);_cam.d = vec3(0,0,-1);\n  }else if(length(max(abs((1.-uv-vec2(0,s.y*4.))-s)-s,0.))==0.){\n   _plane.x=true;_grid=bvec3(false,false,true);//left\n   _cam.p = vec3(-D,0,0);_cam.u = vec3(0,-1,0);_cam.d = vec3(1,0,0);\n  }if(keyInfo(81.,2.) > 0.){_cam.p *= -1.;_cam.d *= -1.;\n  }if(step(uv.x-(1.-s.x*2.)+.0025,0.)<1.){\n   f*=1.-step(abs(uv.x-(1.-s.x*2.))-.0025,0.);\n   f*=1.-step(abs(uv.y-1./3.)-.0025/s.x/6.,0.);\n   f*=1.-step(abs(uv.y-2./3.)-.0025/s.x/6.,0.);// window borders\n  }uv = (mod((1.-uv),s*2.)/(s*2.)-.5)*2.;\n }else uv=(2.*o.xy/RES-iResolution.xy*a)/(iResolution.xx*a.xx);\n */\n #else\n //uv=(2.*o.xy/RES-iResolution.xy)/(iResolution.xx);\n #endif\n //_ray = lookAt(_cam,uv);\n //r=vec4(getColor(march(_ray))*f,1);\n\n     \n     \n     //decap distance function code thats not neded\n/*\nvec3 opTwist( vec3 p, float t, float yaw){\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}*/\n\n//what hex is it in, what 6th is it in.\n//room is projected down to one identical room.\n//but the locatives vary for texture.\n\n//lets make a floor with a thickness to stand on\n\n/*\n//cheese wedge shape as base for spral staircase.\nfloat wedge(vec3 p){\n    //p.y+=.1;\n    p.x=abs(p.x);\n float a=atan(p.z,p.x);\n    //if(a>0.)a-=3.14;\n a=abs(a)-.8;\n float cyl=length(p.xz)-2.;\n a=fOpDifferenceChamfer(a,cyl,.1);\n a=max(a,fBoxCheap(p,vec3(10.,.1,10.)));\n    return a;\n}*/\n\n/*\nfloat stairs2(vec3 p){\n //p.xy*=rot(PIB*.75);\n float w=wedge(p);\n p.y-=2.;\n    //p.z-=3.;\n//p.x=sin(p.y);\n //p.z=cos(p.y);\n     float cyl=length(p.xz)-2.;\n     p=opTwist(p-vec3(0,1,0),.5,.5);\n\n float c=fBoxCheap(p,vec3(.5,4.,2.));\n c=fOpDifferenceChamfer(c,cyl,.1);\n    c=min(c,w);\n    return c;\n}*/\n\n/*\nfloat stairTwi(vec3 p){\n vec3 pr=p;\n pr.xy*=rot(-atan(1.,2.));\n float stai=min(stairs(pr+vec3(.2236067977499,.0,.0)),stairs(pr));\n return stai;\n*/\n}\n    ",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//backup of \"SDF Inspector\" by \"lara\":\n//  https://www.shadertoy.com/view/MlVGRh\n\n// Bit Packed Sprites 2 (5x7) by Flyguy\n// https://www.shadertoy.com/view/llSGRm\n\n#define CHAR_SIZE vec2(6, 7)\n#define CHAR_SPACING vec2(6, 9)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define DOWN_SCALE 2.0\n\n/*\nTop left pixel is the most significant bit.\nBottom right pixel is the least significant bit.\n\n â–ˆâ–ˆâ–ˆ  |\nâ–ˆ   â–ˆ |\nâ–ˆ   â–ˆ |  \nâ–ˆ   â–ˆ |\nâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ |\nâ–ˆ   â–ˆ |\nâ–ˆ   â–ˆ |\n\n011100 \n100010\n100010  \n100010\n111110\n100010\n100010\n\n011100 (upper 21 bits)\n100010 -> 011100 100010 100010 100 -> 935188\n100010  \n100\n   010 (lower 21 bits)\n111110 -> 010 111110 100010 100010 -> 780450\n100010\n100010\n\nvec2(935188.0,780450.0)\n*/\n\n//Automatically generated from the sprite sheet here: http://uzebox.org/wiki/index.php?title=File:Font6x8.png\nvec2 ch_spc = vec2(0.0,0.0);\nvec2 ch_exc = vec2(276705.0,32776.0);\nvec2 ch_quo = vec2(1797408.0,0.0);\nvec2 ch_hsh = vec2(10738.0,1134484.0);\nvec2 ch_dol = vec2(538883.0,19976.0);\nvec2 ch_pct = vec2(1664033.0,68006.0);\nvec2 ch_amp = vec2(545090.0,174362.0);\nvec2 ch_apo = vec2(798848.0,0.0);\nvec2 ch_lbr = vec2(270466.0,66568.0);\nvec2 ch_rbr = vec2(528449.0,33296.0);\nvec2 ch_ast = vec2(10471.0,1688832.0);\nvec2 ch_crs = vec2(4167.0,1606144.0);\nvec2 ch_per = vec2(0.0,1560.0);\nvec2 ch_dsh = vec2(7.0,1572864.0);\nvec2 ch_com = vec2(0.0,1544.0);\nvec2 ch_lsl = vec2(1057.0,67584.0);\nvec2 ch_0 = vec2(935221.0,731292.0);\nvec2 ch_1 = vec2(274497.0,33308.0);\nvec2 ch_2 = vec2(934929.0,1116222.0);\nvec2 ch_3 = vec2(934931.0,1058972.0);\nvec2 ch_4 = vec2(137380.0,1302788.0);\nvec2 ch_5 = vec2(2048263.0,1058972.0);\nvec2 ch_6 = vec2(401671.0,1190044.0);\nvec2 ch_7 = vec2(2032673.0,66576.0);\nvec2 ch_8 = vec2(935187.0,1190044.0);\nvec2 ch_9 = vec2(935187.0,1581336.0);\nvec2 ch_col = vec2(195.0,1560.0);\nvec2 ch_scl = vec2(195.0,1544.0);\nvec2 ch_les = vec2(135300.0,66052.0);\nvec2 ch_equ = vec2(496.0,3968.0);\nvec2 ch_grt = vec2(528416.0,541200.0);\nvec2 ch_que = vec2(934929.0,1081352.0);\nvec2 ch_ats = vec2(935285.0,714780.0);\nvec2 ch_A = vec2(935188.0,780450.0);\nvec2 ch_B = vec2(1983767.0,1190076.0);\nvec2 ch_C = vec2(935172.0,133276.0);\nvec2 ch_D = vec2(1983764.0,665788.0);\nvec2 ch_E = vec2(2048263.0,1181758.0);\nvec2 ch_F = vec2(2048263.0,1181728.0);\nvec2 ch_G = vec2(935173.0,1714334.0);\nvec2 ch_H = vec2(1131799.0,1714338.0);\nvec2 ch_I = vec2(921665.0,33308.0);\nvec2 ch_J = vec2(66576.0,665756.0);\nvec2 ch_K = vec2(1132870.0,166178.0);\nvec2 ch_L = vec2(1065220.0,133182.0);\nvec2 ch_M = vec2(1142100.0,665762.0);\nvec2 ch_N = vec2(1140052.0,1714338.0);\nvec2 ch_O = vec2(935188.0,665756.0);\nvec2 ch_P = vec2(1983767.0,1181728.0);\nvec2 ch_Q = vec2(935188.0,698650.0);\nvec2 ch_R = vec2(1983767.0,1198242.0);\nvec2 ch_S = vec2(935171.0,1058972.0);\nvec2 ch_T = vec2(2035777.0,33288.0);\nvec2 ch_U = vec2(1131796.0,665756.0);\nvec2 ch_V = vec2(1131796.0,664840.0);\nvec2 ch_W = vec2(1131861.0,699028.0);\nvec2 ch_X = vec2(1131681.0,84130.0);\nvec2 ch_Y = vec2(1131794.0,1081864.0);\nvec2 ch_Z = vec2(1968194.0,133180.0);\nvec2 ch_lsb = vec2(925826.0,66588.0);\nvec2 ch_rsl = vec2(16513.0,16512.0);\nvec2 ch_rsb = vec2(919584.0,1065244.0);\nvec2 ch_pow = vec2(272656.0,0.0);\nvec2 ch_usc = vec2(0.0,62.0);\nvec2 ch_a = vec2(224.0,649374.0);\nvec2 ch_b = vec2(1065444.0,665788.0);\nvec2 ch_c = vec2(228.0,657564.0);\nvec2 ch_d = vec2(66804.0,665758.0);\nvec2 ch_e = vec2(228.0,772124.0);\nvec2 ch_f = vec2(401543.0,1115152.0);\nvec2 ch_g = vec2(244.0,665474.0);\nvec2 ch_h = vec2(1065444.0,665762.0);\nvec2 ch_i = vec2(262209.0,33292.0);\nvec2 ch_j = vec2(131168.0,1066252.0);\nvec2 ch_k = vec2(1065253.0,199204.0);\nvec2 ch_l = vec2(266305.0,33292.0);\nvec2 ch_m = vec2(421.0,698530.0);\nvec2 ch_n = vec2(452.0,1198372.0);\nvec2 ch_o = vec2(228.0,665756.0);\nvec2 ch_p = vec2(484.0,667424.0);\nvec2 ch_q = vec2(244.0,665474.0);\nvec2 ch_r = vec2(354.0,590904.0);\nvec2 ch_s = vec2(228.0,114844.0);\nvec2 ch_t = vec2(8674.0,66824.0);\nvec2 ch_u = vec2(292.0,1198868.0);\nvec2 ch_v = vec2(276.0,664840.0);\nvec2 ch_w = vec2(276.0,700308.0);\nvec2 ch_x = vec2(292.0,1149220.0);\nvec2 ch_y = vec2(292.0,1163824.0);\nvec2 ch_z = vec2(480.0,1148988.0);\nvec2 ch_lpa = vec2(401542.0,66572.0);\nvec2 ch_bar = vec2(266304.0,33288.0);\nvec2 ch_rpa = vec2(788512.0,1589528.0);\nvec2 ch_tid = vec2(675840.0,0.0);\nvec2 ch_lar = vec2(8387.0,1147904.0);\n\n\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,22.0); //Fixes small artefacts on my nexus 7\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec2 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    \n    return bounds ? extract_bit(spr.x, bit - 21.0)+extract_bit(spr.y, bit) : 0.0;\n\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec2 ch, vec2 uv)\n{\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    //print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n//Returns the digit sprite for the given number.\nvec2 get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return vec2(0.0);\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= -3;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n        \n        if(i == -1) //Add a decimal point.\n        {\n            result += char(ch_per,uv);\n        }\n        \n        if(i < 1) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\n#define get(a,b) texture(b,(a+0.5)/iResolution.xy)\n#define keyInfo(a,b) texture(iChannel3, vec2(a+.5,b+.5)/vec2(256.,3.)).x \n\nconst vec2 _bufA_cast = vec2(5,0);\n\n//vec2 res = iResolution.xy / DOWN_SCALE;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    if(keyInfo(67.,2.) < 1.)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec2 uv = fragCoord.xy;\n    vec3 pos = get(_bufA_cast,iChannel0).xyz;\n\n    float d = 0.0;\n    \n    print_pos = iMouse.xy + vec2(STRWIDTH(1.),0);\n    \n    \n    d += char(ch_x,uv);\n    d += char(ch_col,uv);\n    d += pos.x < 0. ? char(ch_dsh,uv) : char(ch_spc,uv);\n    d += print_number(abs(pos.x),uv);\n    if (d > 0.) { fragColor = vec4(0,1,1,1); return; }\n    \n    print_pos = iMouse.xy + vec2(STRWIDTH(1.),-STRHEIGHT(1.));\n    d += char(ch_y,uv);\n    d += char(ch_col,uv);\n    d += pos.y < 0. ? char(ch_dsh,uv) : char(ch_spc,uv);\n    d += print_number(abs(pos.y),uv);\n    if (d > 0.) { fragColor = vec4(1,0,1,1); return; }\n    \n    print_pos = iMouse.xy + vec2(STRWIDTH(1.),-STRHEIGHT(1.)*2.);\n    d += char(ch_z,uv);\n    d += char(ch_col,uv);\n    d += pos.z < 0. ? char(ch_dsh,uv) : char(ch_spc,uv);\n    d += print_number(abs(pos.z),uv); \n    if (d > 0.) { fragColor = vec4(1,1,0,1); return; }\n    \n\tfragColor = vec4(vec3(d),d);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}