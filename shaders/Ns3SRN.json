{
    "Shader": {
        "info": {
            "date": "1632720167",
            "description": "the self-advection is done purely rotational, therefore no need for divergence-free-step.\ntry changing RotNum.\npress i-key to init image (e.g. in fullscreen)",
            "flags": 32,
            "hasliked": 0,
            "id": "Ns3SRN",
            "likes": 2,
            "name": "2D_FLUID_single pass CFD Audio 2",
            "published": 3,
            "tags": [
                "simulation",
                "fluid",
                "cfd",
                "fluiddynamics"
            ],
            "usePreview": 0,
            "username": "MacroMachines",
            "viewed": 301
        },
        "renderpass": [
            {
                "code": "// Fork of \"single pass CFD\" by flockaroo. https://shadertoy.com/view/MdKXRy\n// 2018-04-18 11:55:03\n\n// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n//\n// \"angRnd\" is the rotational randomness of the rotation-samples\n// \"posRnd\" is an additional error to the position of the samples (not really needed)\n// for higher numbers of \"RotNum\" \"angRnd\" can also be set to 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0,uv);\n    //fragColor += texture(iChannel1, fragColor.rg).rrrr;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2016\n// Modified with audio reactivity by www.axiom-crux.net\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n//\n// \"angRnd\" is the rotational randomness of the rotation-samples\n// \"posRnd\" is an additional error to the position of the samples (not really needed)\n// for higher numbers of \"RotNum\" \"angRnd\" can also be set to 0\n\n#define RotNum 8 //cos(iTime*4.0)\n#define angRnd -8.0 //*cos(iTime*8.0) //*pow(fract(iTime*2.0)*2.0,4.50)\n#define posRnd -0.0\n#define intensity 1.0 //sin(iTime*0.5)+0.50)*2.50\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\n\nfloat hash(float seed) { return fract(sin(seed)*158.5453 ); }\nvec4 getRand4(float seed) { return vec4(hash(seed),hash(seed+123.21),hash(seed+234.32),hash(seed+453.54)); }\nvec4 randS(vec2 uv)\n{\n    //return getRand4(uv.y+uv.x*1234.567)-vec4(0.5);\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 uv, float sc)\n{\n    float fft = texture(iChannel2,fract(uv)).x-0.5*5.;\n    float ang2 = angRnd*randS(uv).x*ang ;//  * fft;\n    vec2 p = vec2(cos(ang2),sin(ang2));\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        vec2 p2 = (p+posRnd*randS(uv+p*sc).xy)*sc;\n        vec2 v = texture(iChannel0,fract(uv+p2)).xy-vec2(0.5);\n        //v+= fft;\n        rot+=cross(vec3(v,0.0),vec3(p2,0.0)).z/dot(p2,p2);\n        p = m*p;\n    } //while(RotNum > 0.0);\n    rot/=float(RotNum);\n    return rot*fft;\n}\n\nvoid init( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / Res.xy;\n    fragColor = texture(iChannel2,uv);\n}\n\n\n#define INIT iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv  = fragCoord.xy / Res.xy;\n    vec2 scr = uv*2.0-vec2(1.0);\n    \n    float sc = 1.0/max(Res.x,Res.y);\n    \n    vec2 v   = vec2(0);\n    \n    vec2 uuvv = vec2(length(uv-0.5),length(uv-0.50));\n    vec2 puv = atan(uv-0.5,uuvv);//uuvv);//,uv+0.5);\n  \n    vec4 fft = texture(iChannel2,(puv))*0.53;\n    vec4 fft2= texture(iChannel2,uuvv*0.1)*0.51;\n    vec4 fft4= fft2+fft*2.0;\n    vec4 fft3= texture(iChannel2,uv*vec2(0.25,0.0))*4.-1.5;\n    float fft33 = step(fft3.r,0.5);\n    \n    for(int level=0;level<20;level++)\n    {\n        if ( sc > 0.7 ) break;\n       // if ( fft4.r > 0.21) break;\n        \n        float ang2 = angRnd * ang * randS(uv).y * fft3.r;\n        \n        vec2 p = vec2(cos(ang2),sin(ang2));\n        \n        for(int i=0;i<RotNum;i++)\n        {\n            vec2 p2 = p*sc;\n            float rot = getRot(uv+p2, sc-0.01);\n            //v+=cross(vec3(0,0,rot),vec3(p2,0.0)).xy;\n            v += p2.yx * rot * vec2(-1,1.1); //maybe faster than above\n            p = m*p;\n        }\n        \n      \tsc *= 2.0 ;\n        sc /= fft4.r*1.0925051;\n        sc *= 2.01;\n    }\n    \n    //v.y+=scr.y*0.1;\n    \n    //v.x+=(1.0-scr.y*scr.y)*0.8;\n    \n    //v/=float(RotNum)/3.0;\n    \n    fragColor = texture(iChannel0,fract(uv+v*3.0/Res.x));\n    \n    fragColor = mix(fragColor,texture(iChannel2, fragColor.xy).rrrr*2.0-0.5009,0.02);\n    \n    \n    if(uv.y < 0.03 || uv.y > 0.99){ fragColor.rgb += fft33*0.975; fragColor.gb *= fft33*0.75;\n    }\n    //if(uv.y > 0.29 && uv.y < 0.71){ \n    //fragColor.gb += fft33*0.15; fragColor.gb *= fft33*0.15;\n   // }\n   fragColor += fft2.rrrr*0.01;\n    \n    \n   // scr += fft.rr;\n   \n     // add a little \"motor\" in the center\n    fragColor.xy += (0.02*intensity*scr.xy / (dot(scr,scr)/0.15+0.3));\n\n   // fragColor.xy += 0.01*fft.rg-0.00015;\n    \n    if(iFrame<=4 || INIT<0.5) fragColor = uv.rgrg;//init(fragColor,fragCoord);\n    \n    //fragColor /= fft.rrrr*1.1;//uuvv.rgr;\n    //fragColor\n    //fragColor += 1.0-texture(iChannel2,uv/2.);//-uv.rgrg*-0.01;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "music",
                        "id": 35,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}