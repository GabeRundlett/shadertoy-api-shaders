{
    "Shader": {
        "info": {
            "date": "1727200193",
            "description": "originals from glslsandbox",
            "flags": 0,
            "hasliked": 0,
            "id": "MXScD1",
            "likes": 3,
            "name": "cosmic cube 2",
            "published": 3,
            "tags": [
                "fractal",
                "cube",
                "cosmic"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 88
        },
        "renderpass": [
            {
                "code": "\nfloat hash(vec2 uv) {\n\treturn fract(74455.45 * sin(dot(vec2(78.54, 14.45), uv)));\n}\n\nvec2 hash2(vec2 uv) {\n\tfloat  k = hash(uv);\n\treturn vec2(k, hash(uv + k));\n}\n\n// IQ\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n//\n\nfloat Hash( vec2 p)\n{\n     vec3 p2 = vec3(p.xy,1.0);\n    return fract(sin(dot(p2,vec3(37.1,61.7, 12.4)))*3758.5453123);\n}\n\nfloat noise(in vec2 p)\n{\n    vec2 i = floor(p);\n     vec2 f = fract(p);\n     f *= f*(3.0-2.0*f);\n    return mix(mix(Hash(i + vec2(0.,0.)), Hash(i + vec2(1.,0.)),f.x),\n               mix(Hash(i + vec2(0.,1.)), Hash(i + vec2(1.,1.)),f.x),\n               f.y);\n}\n\nfloat fbm(vec2 p)\n{\n     float v = 0.0;\n     v += noise(p*1.0) * .75+cos(iTime);\n     v += noise(p*3.)  * .50;\n     v += noise(p*9.)  * .250;\n     v += noise(p*27.)  * .125;\n     return v;\n}\n\n#define time iTime\n#define resolution iResolution.xy\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * gl_FragCoord.xy - resolution) / resolution.y;\n\tvec3 col = vec3(0.);\n    \n    uv.x *= resolution.x/resolution.y; uv.y -= 0.25;\n\n\tfloat timeVal = time * 0.1;\nfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .27)) * 2.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n    uv*=ma;\n\tvec3 finalColor = vec3( 0.0 );\n\tfor( int i=0; i < 20; ++i )\n\t{\n    uv*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n\t\tfloat indexAsFloat = float(i);\n\t\tfloat amp = 10.0 + (indexAsFloat*500.0);\n\t\tfloat period = 2.0 + (indexAsFloat+2.0);\n\t\tfloat thickness = mix( 0.9, 1.0, noise(uv*indexAsFloat)+cos(iTime) );\n\t\tfloat t = abs( 1.0 / (sin(uv.y + fbm( uv + timeVal * period )) * amp) * thickness );\n\t\t\n\t\t\n\t\tfinalColor +=  t * vec3( .3, 0.95, 2.5 );\n\t}\n\t\n\tfor (int i = 0; i < 100; i++) {\n\t\tvec2 p = 2. * hash2(float(i) + vec2(2.)) - 1.;\n\t\tp -= vec2(sin(.1 * hash(float(i) + vec2(10., 50.)) * (time * 50.0) + hash(float(i) + vec2(10.))), \n\t\t\t  cos(.1 * hash(float(i) + vec2(20., 40.)) * (time * 50.0)+ hash(float(i) + vec2(10.))));\n\t\tfloat k = (.5 * hash(float(i) + vec2(25., 75.)) + .01);\n\t\tcol += palette(k * 3., vec3(.5), vec3(.5), vec3(1.), vec3(.0, .33, .67)) / length(uv - p);\n\t}\n\tcol /= 85.;\n    vec3 dir = normalize(vec3((cos(iTime*1.01)-.5)*-4.,(sin(iTime*1.01)-.5)*4.,1.0));\n       dir.xy*=ma;\n\tvec3 left = normalize(cross(dir,vec3(0,1,0)));\n\tvec3 up = cross(dir,left);\n\t\n\tvec3 pos = -dir*10.;\n\t\n\tvec2 screen = (gl_FragCoord.xy-resolution*.5)/resolution.x;\n\t\n\tvec3 ray = normalize(dir+left*screen.x-up*screen.y);\n\t\n\tfloat dsum = 0.;\n\tfloat d;\n\t\n\tfor (int i = 0; i < 55; i++) {\n  \n\t\td = length(max(max(abs(fract(pos)-.5)-.3,0.), abs(pos)-2.0));\n\t\tdsum += d;\n\t\tpos  += d*ray;\n\t}\n\tfragColor = vec4(col*finalColor*10., 1.);\n\t\n\tfragColor*= vec4(1.0-vec3(dsum)*0.08,1.);\n\t\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}