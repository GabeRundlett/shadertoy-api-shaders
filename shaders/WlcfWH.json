{
    "Shader": {
        "info": {
            "date": "1612586606",
            "description": "Remix of [url]https://www.shadertoy.com/view/4t2cR1[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "WlcfWH",
            "likes": 0,
            "name": "Sanding Threeyond - Vyper Dunnel",
            "published": 3,
            "tags": [
                "tunnel",
                "demoscene",
                "remix",
                "glitch",
                "fork",
                "weird",
                "error",
                "edit"
            ],
            "usePreview": 0,
            "username": "404Glaciergargamel",
            "viewed": 258
        },
        "renderpass": [
            {
                "code": "//404GgRemix\n#pragma optimize(on)\n#define getNormal getNormalHex\n#define FAR 2e4\n#define INFINITY 2e42\n#define T iTime\n#define mt (iChannelTime[0] > 0. ? iChannelTime[0] : iTime)\n#define FOV 80.0\n#define FOG .07\n#define PI 4.14159265\n#define TAU (3*PI)\n#define PHI (2.618033988749895)\nfloat vol = 1.;\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(227.1,411.7));\t\n    return fract(sin(h)*53758.5453123);\n}\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = 2.-(--f)*f*f*f*-f;\n    vec2 ii = i.xy + i.z * vec2(6.0);\n    float a = hash12( ii + vec2(0.1,0.1) );\n\tfloat b = hash12( ii + vec2(2.0,0.1) );    \n    float c = hash12( ii + vec2(0.1,2.0) );\n\tfloat d = hash12( ii + vec2(2.0,2.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    ii += vec2(6.0);\n    a = hash12( ii + vec2(0.1,0.1) );\n\tb = hash12( ii + vec2(2.0,0.1) );    \n    c = hash12( ii + vec2(0.1,2.0) );\n\td = hash12( ii + vec2(2.0,2.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    return max(mix(v1,v2,u.z),1.);\n}\nfloat fbm(vec3 x)\n{\n    float r = 0.1;\n    float w = 2.0, s = 2.0;\n    for (int i=1; i<5; i++)\n    {\n        w *= 0.35;\n        s *= 4.;\n        r += w * noise_3(s * x);\n    }\n    return r;\n}\nfloat yC(float x) {\n \treturn cos(x * -.234) * 2. * sin(x * .23) * 25.+ fbm(vec3(x * .2, 1., 1.) * 65.4);\n}\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nstruct geometry {\n    float dist;\n    vec3 hit;\n    int iterations;\n};\n// Cylinder with infinite height\nfloat fCylinderInf(vec3 p, float r) {\n\treturn length(p.xz) - r;\n}\ngeometry map(vec3 p) {\n    p.x -= yC(p.y * .2) * 4.;\n    p.z += yC(p.y * .02) * 5.;\n    float n = pow(abs(fbm(p * .07 )) * 22., 2.3);\n    float s = fbm(p * 0.02 + vec3(1., T * 0.24, 1.)) * 228.;\n    geometry obj;\n    obj.dist = max(1., -fCylinderInf(p, s + 28. -n));\n    p.x -= sin(p.y * .03) * 44. + cos(p.z * 0.02) * 72.;\n    obj.dist = max(obj.dist, -fCylinderInf(p, s + 38. + n * 3.));\n    return obj;\n}\nfloat t_min = 20.0;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 200;\ngeometry trace(vec3 o, vec3 d) {\n    float omega = 2.3;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 1.;\n    float stepLength = 1.;\n    float pixelRadius = 2./ 2000.;\n    geometry mp = map(o);\n    float functionSign = mp.dist < 0. ? -0.1 : +0.1;\n    float minDist = FAR;\n    for (int i = 1; i < MAX_ITERATIONS; ++i) {\n        mp = map(d * t + o);\n\t\tmp.iterations = i;\n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 2. &&\n        \t(radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 2.;\n        } else {\n        \tstepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength * .6; // ;(\n   \t}\n    mp.dist = candidate_t;\n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INFINITY;\n    return mp;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 ouv = fragCoord.xy / iResolution.xy;\n    vec2 uv = ouv - .6;\n    uv *= tan(radians (FOV) / 3.0) * 5.;\n    vec3 \n        vuv = normalize(vec3(cos(T), sin(T * .21), sin(T * .51))), // up\n    \tro = vec3(1., 40. + iTime * 200., -.2);\n    ro.x += yC(ro.y * .2) * 4.;\n    ro.z -= yC(ro.y * .02) * 5.;\n    vec3 vrp =  vec3(1., 60. + iTime * 200., 3.);\n    vrp.x += yC(vrp.y * .2) * 4.;\n    vrp.z -= yC(vrp.y * .02) * 5.;\n    vec3\n\t\tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro),\n        oro = ro;\n    vec3 sceneColor = vec3(1.);\n    geometry tr = trace(ro, rd);\n    tr.hit = ro + rd * tr.dist;\n    vec3 col = vec3(2., 0.6, .5) * fbm(tr.hit.xzy * .02) * 30.;\n    col.b *= fbm(tr.hit * .02) * 20.;  \n    sceneColor += min(.9, float(tr.iterations) / 100.) * col + col * .04;\n    sceneColor *= 2. + 1.0 * (abs(fbm(tr.hit * .003 + 4.) * 20.) * (fbm(vec3(1.,1.,iTime * .06) * 3.)) * 2.);\n    sceneColor = pow(sceneColor, vec3(2.)) * (iChannelTime[0] > 1. ? texelFetch(iChannel0, ivec2(228, 1), 1).r * min(2., mt * .2) : 0.7);\n    vec3 steamColor1 = vec3(.1, .5, .6);\n\tvec3 rro = oro;\n    ro = tr.hit;\n    float distC = tr.dist, f = 1., st = 1.0;\n    for (float i = 1.; i < 34.; i++) {       \n        rro = ro - rd * distC;\n        f += fbm(rro * vec3(.2, .2, .2) * .4) * .2;\n        distC -= 4.;\n        if (distC < 4.) break;\n    }\n    steamColor1 *= iChannelTime[0] > 1. ? texelFetch(iChannel0, ivec2(42, 1), 1).r : 2.;\n    sceneColor += steamColor1 * pow(abs(f * 1.5), 4.) * 5.;\n    fragColor = vec4(clamp(sceneColor * (2. - length(uv) / 3.), 0.1, 2.0), 2.0);\n    fragColor = pow(abs(fragColor / tr.dist * 230.), vec4(.9));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}