{
    "Shader": {
        "info": {
            "date": "1560867159",
            "description": "Constructing some concise contoured layers, then applying various edge and shading effects to produce some faux depth.",
            "flags": 0,
            "hasliked": 0,
            "id": "3lj3zt",
            "likes": 76,
            "name": "Contoured Layers",
            "published": 3,
            "tags": [
                "noise",
                "shadow",
                "gradient",
                "edge",
                "derivative",
                "contour",
                "art",
                "layer"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 3175
        },
        "renderpass": [
            {
                "code": "/*\n\n\tContoured Layers\n\t----------------\n\n\tConstructing some concise contoured layers, then applying various edge and shading \n\teffects to produce some faux depth. Technically, that's what is happening here, but\n\tthis example was mainly put together as a means to demonstrate various layering\n    effects, like strokes, highlights, shadows, etc. No 3D was harmed during the making\n\tof this example. :)\n\n\tI love those contoured noise-based paper layer images that various graphic artists\n\tfrom places like Adobe distribute with their applications. Most consist of some\n\tantialiased noise layers rendered in a flat tone with drop shadows for each. The \n\tfancier ones sometimes include highlighted edges, etc, which is what I've put \n\ttogether here. None of it is difficult to produce, provided you're happy with\n\tconcept of smoothing layers at a particular threshold with respect to the field\n\tderivative.\n\n\tI put in a few diferent aesthetic options to try, just to show how much something\n\tlike a simple palette change, drop shadow, etc, can effect the overall feel. I've\n    tuned most settings on by default, but turning them off can give a cleaner look. \n\tTurning everything off, except the shadows will give the minimal contoured images\n\tyou see around, which I happen to like also.\n\n\tAnyway, feel free to play around with the defines below. At some stage, I might\n    render some icons and allow the various options to be manipulated via the mouse,\n\tbut for now, this will suffice.\n\n\tI also have a few raymarched 3D versions that I'll put up at a later date.\t\n\n\n*/\n\n// Dropping down a blurry dark layer to give a fake ambient occlusion effect.\n// It's subtle, but gives things a bit more depth. However, turning it off gives\n// a crisper look. I guess it depends what you're after.\n#define FAKE_AO\n\n// Contour strokes are great for that hand drawn look, or just to give some definition\n// to geometry. This one is dark, but it can be any color.\n#define STROKE\n\n// Highlights, to give the impression that light is hitting the surface.\n#define HILIGHT\n\n// Shadows: There aren't too many times when I wouldn't want shadows, but I can think\n// of a few. If expense if a problem, you can fake it with a thicker AO layer, but it's\n// not quite the same.\n#define SHADOW\n\n// Including the metallic texture: I overuse this particular texture, but it's the only\n// one on Shadertoy with a fine enough grade on it. I'm hoping more subtle textures\n// will get added at some stage. :)\n#define TEXTURED\n\n// Running a cheap hatch-like algorithm over the layers for a bit of extra texture.\n// Come to think of it, it's probably more of a stipple pattern... Either way, it's\n// just a little extra texture.\n#define HATCH\n\n// Very subtle paper grain. It's pretty simple... and I think it's based on one of\n// Flockaroo's snippets. If you're interested in post processing effects, his examples\n// are definitely worth looking at.\n//#define PAPER_GRAIN\n\n// Palette: It's amazing how something as simple as color choice can effect the feel\n// of an image.\n// Settings: Greyscale: 0, Red: 1, Blue: 2, Earth: 3, Pink and grey: 4, \n// Grey and pink: 5, Green and white: 6.\n#define PALETTE 0\n\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// vec3 to float hash.\nfloat hash21( vec2 p ){ \n     \n    return fract(sin(dot(p, vec2(41, 289)))*45758.5453); \n   \n    //p.x = fract(sin(dot(p, vec2(1, 113)))*45758.5453);\n    //return sin(p.x*6.2831853 + iTime); \n}\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(1, 113)));\n    //return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    // Note the \".45,\" insted of \".5\" that you'd expect to see. When edging, it can open \n    // up the cells ever so slightly for a more even spread. In fact, lower numbers work \n    // even better, but then the random movement would become too restricted. Zero would \n    // give you square cells.\n    return sin(p*6.2831853 + iTime); \n    \n}\n\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values, but that's not an issue here.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22(i), p);\n    v.y = dot(hash22(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22(i + 1.), p - 1.);\n\n#if 1\n    // Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    //return v.x + p.x*(v.y - v.x) + p.y*(v.z - v.x) + p.x*p.y*(v.x - v.y - v.z + v.w);\n}\n\n\n\n// The map function. Just two layers of gradient noise. Way more interesting\n// functions are possible, but we're keeping things simple.\nfloat map(vec3 p, float i){\n    \n    /* \n    // Video version: Load one of the videos into iChannel1, preferably\n    // with the filter setting to mipmap.\n    p.xy *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iChannel1, p.xy + .5, 1.).xyz; tx *= tx;\n    return .15 - dot(tx, vec3(.299, .587, .114)) + i/10.*1. - .15;\n    */\n    return n2D3G(p.xy*3.)*.66 + n2D3G(p.xy*6.)*.34 + i/10.*1. - .15;\n  \n}\n\n\n// 2D derivative function.\nvec3 getNormal(in vec3 p, float m, float i) {\n\t\n    vec2 e = vec2(.001, 0);\n    \n    // Four extra samples. Slightly better, but not really needed here.\n\t//return (vec3(map(p + e.xyy, i) - map(p - e.xyy, i), map(p + e.yxy, i) - map(p - e.yxy, i),\t0.))/e.x*.7071;\n\n    // Three samples, but only two extra sample calculations. \n    return (vec3(m - map(p - e.xyy, i), m - map(p - e.yxy, i),\t0.))/e.x*1.4142;\n}\n\n// The map layer and its derivative. To produce constant width layer edges, the derivative\n// is necessary, so the distance field value and the derivative at the point is returned.\nvec4 mapLayer(in vec3 p, float i){\n    \n    vec4 d;\n    \n    d.x = map(p, i); // Distance field value.\n    \n    d.yzw = getNormal(p, d.x, i); // Derivative.\n    \n    return d;\n    \n}\n\n\n\n// Layer color. Based on the shade, layer number and smoothing factor.\nvec3 getCol(vec2 p, float sh, float fi, float sf){\n     \n    // Color.\n    vec3 col;\n\n    \n    #if PALETTE == 0\n        // Light attenuation palette.\n    \tcol = vec3(1)*(1. - .75/(1. + sh*sh*2.));\n    \t//col = vec3(sh*sh*.65 + .22);\n        //col = vec3(sh*.5 + .2); \n        // Etc.\n    #elif PALETTE == 1\n        col = pow(min(vec3(1.5, 1, 1)*(sh*.35 + .6), 1.), vec3(1, 3, 16));\n        if(fi==0.) col = vec3(.35, .05, .3);\n        col = mix(col.xzy, col, sh*.5 + .5);\n    #elif PALETTE == 2\n        col = pow(min(vec3(1.5, 1, 1)*(sh*.35 + .6), 1.), vec3(1, 3, 16));\n        if(fi==0.) col = vec3(.6, .2, .07);\n        col = mix(col.xzy, col, sh*.5 + .5).zyx;\n    #elif PALETTE == 3\n        if(fi==0.) col = vec3(.25, .52, .75);\n        if(fi==1.) col = vec3(.8, .8, .6);\n        if(fi==2.) col = vec3(.75, .6, .5);\n        if(fi==3.) col = vec3(.6, .58, .5);\n        if(fi==4.) col = vec3(.5, .72, .4);\n        if(fi==5.) col = vec3(.65, .85, .5);\n        else col = min(vec3(.65, .85, .5)*1.25, 1.);\n    #elif PALETTE == 4\n    \tif(mod(fi, 2.)<.5) col = vec3(.25, .15, .2);\n    \telse col = vec3(1, .15, .4)*.8;\n    #elif PALETTE == 5\n    \tif(mod(fi, 2.)<.5) col = vec3(1, .15, .4)*.8;\n    \telse col = vec3(.25, .15, .2);\n    #else\n    \tif(mod(fi, 2.)>.5) col = vec3(.6);\n    \telse col = vec3(.6, 1, .15)*.6;\n    #endif\n    \n      \n    #ifdef TEXTURED\n    vec3 tx = texture(iChannel0, p + hash21(vec2(sh, fi))).xyz; tx *= tx;\n    col = min(col*tx*3., 1.);\n    #endif\n\n    \n    return col;\n    \n}\n\n\n// A hatch-like algorithm, or a stipple... or some kind of textured pattern.\nfloat doHatch(vec2 p, float res){\n    \n    // If the \"HATCH\" define is on, produce the pattern.\n    #ifdef HATCH\n    \n        // The pattern is physically based, so needs to factor in screen resolution.\n        p *= res/16.;\n\n        // Random looking diagonal hatch lines.\n        float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.); // Diagonal lines.\n\n        // Slight randomization of the diagonal lines, but the trick is to do it with\n        // tiny squares instead of pixels.\n        float hRnd = hash21(floor(p*6.) + .73);\n        if(hRnd>.66) hatch = hRnd;  \n\n        #ifdef TEXTURED\n        hatch = hatch*.75 + .5; // Stronger hatching for the textured version.\n        #else\n        hatch = hatch*.5 + .75;\n        #endif\n\n        return hatch;\n    \n    // If the hatch define is off, cancel it out.\n    #else\n    \n    \treturn 1.;\n    \n    #endif \n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n\n    // Aspect correct screen coordinates. Setting a minumum resolution on the\n    // fullscreen setting in an attempt to keep things relatively crisp.\n    float res = min(iResolution.y, 700.);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/res;\n    \n    // Scaling and translation.\n    vec2 p = uv;// + vec2(1, 0)*iTime;\n\n    // Resolution based smoothing factor. Later, the contour derivative will\n    // be factored in.\n    float sf = 1./iResolution.y;\n \n    // Initialize to the first layer color.\n    vec3 col = getCol(p, 0., 0., sf);\n    \n    // Previous layer variable.\n    float pL = 0.;\n    \n    \n    // Random looking diagonal hatch lines.\n    float hatch = doHatch(p, res);\n    \n\t\n    \n    // Applying the cross hatch.\n    col *= hatch;\n    \n    // Number of layers.\n    int lNum = 5;\n    float flNum = float(lNum);\n    \n    \n    for(int i = 0; i<lNum; i++){\n        \n        \n        float fi = float(i);\n        \n        // Repositioning the hatch lines on each layer to reduce the \"shower screen effect,\" \n        // as per Fabrice Neyret's suggestion. :)\n        hatch = doHatch(p + sin(vec2(41, 289)*(fi + 1.)), res);\n       \n        // The map layer value (just some gradient noise), and its derivative.\n        vec4 c = mapLayer(vec3(p, 1.), fi);\n        // Offset noise layer value with derivative. It's offset so as to coincide with\n        // the directional lighting.\n        vec4 cSh = mapLayer(vec3(p - vec2(.03, -.03)*((flNum - fi)/flNum*.5 + .5), 1.), fi);\n         \n        // Shade.\n        float sh = (fi + 1.)/(flNum);\n         \n        // Layer color.\n        vec3 lCol = getCol(p, sh, fi + 1., sf);\n\n        // Some standard direct lighting to apply to the edge layer. It's set in a\n        // direction to compliment the shadow layer.\n        vec3 ld = normalize(vec3(-1, 1, -.25));\n        vec3 n = normalize(vec3(0, 0, -1) + c.yzw);\n        float diff = max(dot(ld, n), 0.);\n        #ifdef TEXTURED\n        diff *= 2.5; // Add a bit more light to the edges for the textured version.\n        #else\n        diff *= 2.;\n        #endif\n        \n        \n        // Applying the diffuse lighting to the edge layer.\n        vec3 eCol = lCol*(diff + 1.);\n        \n        // Apply the layers.\n    \n        // Smoothing factor, based on the distance field derivative.\n    \tfloat sfL = sf*length(c.yzx)*2.;\n    \tfloat sfLSh = sf*length(cSh.yzx)*6.;\n        \n        // Drop shadow.\n        #ifdef SHADOW\n        #ifdef TEXTURED\n        const float shF = .5;\n        #else\n        const float shF = .35;\n        #endif\n        col = mix(col, vec3(0), (1. - smoothstep(0., sfLSh, max(cSh.x, pL)))*shF);\n        #endif\n        \n        // Dark blurred layer.\n        #ifdef FAKE_AO\n\t\tcol = mix(col, vec3(0), (1. - smoothstep(0., sfL*3., c.x))*.25);\n        #endif\n        \n        // Dark edge stroke.\n        #ifdef STROKE\n        col = mix(col, vec3(0), (1. - smoothstep(0., sfL, c.x))*.85);\n        #endif\n        \n        // Hilight and color layer.\n        #ifdef HILIGHT\n        col = mix(col, eCol*hatch, (1. - smoothstep(0., sfL, c.x + length(c.yzx)*.003)));\n        col = mix(col, lCol*hatch, (1. - smoothstep(0., sfL, c.x + length(c.yzx)*.006)));\n        #else\n        col = mix(col, lCol*hatch, (1. - smoothstep(0., sfL, c.x + length(c.yzx)*.0025)));\n        #endif\n        \n        // Previous layer, to take away from the shadow.\n        pL = c.x;\n        \n    }\n    \n    \n    \n    // Mixing in a little extra noisy color for the default greyscale textured setting.\n    #ifdef TEXTURED\n    #if PALETTE == 0\n\tcol *= mix(vec3(1.8, 1, .7).zyx, vec3(1.8, 1, .7).xzy, n2D(p*2.));\n    #endif\n    #endif\n\n\n    \n    // Paper.\n    #ifdef PAPER_GRAIN\n    vec3 rn3 = vec3(n2D((uv*iResolution.y/1. + 1.7)) - n2D(vec2(uv*iResolution.y/1. + 3.4)));\n    col *= .93 + .07*rn3.xyz  + .07*dot(rn3, vec3(.299, .587, .114));\n    #endif\n    \n            \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625);\n    // Colored variation.\n    //col = mix(col*vec3(.3, 0, 1), col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));\n\n    \n    // Rough gamma correction, then output to the screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}