{
    "Shader": {
        "info": {
            "date": "1635904055",
            "description": "Based on the mechanism shown in this video:\nhttps://www.youtube.com/watch?v=hhDdfiRCQS4\nRoughly simulates the hobbing process for the monopole gear, but the geometry isn't quite perfect.",
            "flags": 32,
            "hasliked": 0,
            "id": "7ltGR8",
            "likes": 45,
            "name": "ABENICS Active Ball Joint",
            "published": 3,
            "tags": [
                "sphere",
                "ball",
                "gear",
                "mechanical",
                "monopole"
            ],
            "usePreview": 0,
            "username": "Flyguy",
            "viewed": 585
        },
        "renderpass": [
            {
                "code": "\n//Outline effect based on https://www.shadertoy.com/view/4dVGRW#\nfloat outline(sampler2D buffer, ivec2 uv) {\n  float dpos = 0.0;\n  \n  const ivec2[] v = ivec2[](\n      ivec2(0, 1),\n      ivec2(1, 1),\n      ivec2(1, 0),\n      ivec2(1,-1)\n  );\n  \n  for(int i = 0;i<4;i++)\n  {\n      vec4 s0 = texelFetch(buffer, uv + v[i],0);\n      vec4 s1 = texelFetch(buffer, uv - v[i],0);\n      dpos += 0.15*abs(s0.a - s1.a);\n      dpos += 4.*max(0.0, 1.0 - dot(s0.rgb, s1.rgb));\n  }\n  \n  dpos = pow(max(dpos - 0.5, 0.0), 6.0);\n    \n  return abs(dpos);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 uv = ivec2(fragCoord);\n    \n    vec4 s = texelFetch(iChannel0, uv, 0);\n    \n    vec3 col = vec3(0);\n    \n    if(length(s.a) > 190.)\n    {\n          col = mix(vec3(1), vec3(0.6), fragCoord.y/iResolution.y); //Background\n    }\n    else\n    {\n          col = dot(vec3(0,1,0),-s.xyz) * vec3(1.0,1.0,1.4); //Gears\n    }\n    \n    col -= outline(iChannel0, uv);\n        \n    fragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Constants\nconst float inf = 1e3;\nconst float eps = 0.04;\nconst float pi = 3.14159265;\nconst float tau = 6.28318531;\n\n\n//Transformation / Domain Modification Functions\nmat3 rotate(vec3 angles)\n{\n    angles = radians(angles);\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}\n\nvec3 revolve(vec3 p)\n{\n    return vec3(length(p.xy), 0.0, p.z);\n}\n\n//SDF Combination Operators\n//Union\nfloat opU(float d1, float d2) \n{ \n    return min(d1,d2);\n}\n\n//Subtract\nfloat opS(float d1, float d2)\n{\n    return max(-d1,d2);\n}\n\n//Intersection\nfloat opI(float d1, float d2)\n{\n    return max(d1,d2);\n}\n\n//Subtract with 's' x 45deg chamfer at boundary. \nfloat opSChamfer(float s, float d1, float d2)\n{\n    return max(max(d1, -d2), -((-d1+d2)-s)/sqrt(2.0));\n}\n\n\n//SDF Functions\nfloat sdCylinder(vec3 p, float r)\n{\n  return length(p.xy)-r;\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h)\n{\n  return dot(p,normalize(n)) + h;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n  return length(p)-r;;\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const float Zsp = 32.0, //Number of teeth per-axis on the CS gear\n            Zmp = Zsp/2.0, //Number of teeth on the monopole gear\n            module = 2.0; //Gear module\n      \nfloat mPA, mRA, mPB, mRB;\nvec3 csAng;\n\n//Distance to an involute curve at radius 'r'.\nfloat sdInvolute(vec2 p, float r)\n{ \n    p.x = max(0.0,p.x-r)+r;\n    float a = atan(p.y,p.x) + acos(r/length(p));\n    float d = distance(p, r*vec2(cos(a),sin(a))) - a*r;\n    \n    return d;\n}\n\n//Distance to a spur gear with a given # of teeth and module.\nfloat sdSpurGear(vec3 p, float n, float module, float rs, float amod, float pang)\n{  \n    //Parameters\n    float teeth = floor(n);\n    float rackShift = rs;\n    float addendumMod = amod;\n    float pressureAng = radians(pang);\n    \n    //Geometry variables\n    float pitchDia = module * teeth;\n    float baseDia = pitchDia * cos(pressureAng);\n    float outerDia = pitchDia + 2.0*module * (1.0 + rackShift - addendumMod);\n    float rootDia = pitchDia + 2.0*module * (-1.25 + rackShift);\n    float halfToothThk = 0.5*pi/teeth + sqrt(pitchDia*pitchDia - baseDia*baseDia)/baseDia - pressureAng;\n    float toothAng = tau/teeth;\n    \n    //Angular repeated UVs\n    vec2 ar = vec2(atan(p.y, p.x), length(p.xy));\n    ar.x = mod(ar.x + toothAng / 2.0, toothAng) - toothAng / 2.0;\n    vec2 uvr = vec2(ar.y * vec2(cos(ar.x),sin(ar.x)));\n    \n    //Mirror UVs about Y axis\n    uvr.y = -abs(uvr.y);\n    \n    //Rotate UVs by half tooth thickness\n    uvr *= mat2( cos(-halfToothThk), sin(-halfToothThk),\n                -sin(-halfToothThk), cos(-halfToothThk));\n    \n    float d = sdInvolute(uvr, baseDia/2.0); //Involute tooth profile\n    d = opI(d, sdCylinder(vec3(uvr,0), outerDia/2.0)); //Clip profile at outer diameter\n    d = opU(d, sdCylinder(vec3(uvr,0), rootDia/2.0)); //Gear body\n    \n    return d;\n}\n\n//Distance to cross-spherical (CS) gear\nfloat sdCSGear(vec3 p, float n, float module)\n{\n    if(length(p) < module*n*1.1) //Only calculate gear SDF when close\n    {\n        mat3 rotMat = rotate(vec3(90,0,180.0/n)); //Rotate half tooth & 90deg to align for revolve\n        vec3 pa0 = revolve(p.xyz) * rotMat; //Z-aligned spherical gear\n        vec3 pa1 = revolve(p.zyx) * rotMat; //X-aligned spherical gear\n        \n        //Intersect both spherical gears to create the CS gear.\n        return opI(sdSpurGear(pa0, n, module,0.,0.,20.), sdSpurGear(pa1, n, module,0.,0.,20.));\n    }\n\n    return length(p) - module*n;\n}\n\n//Based on the monopole gear hobbing process shown in fig 5 here:\n//https://ieeexplore.ieee.org/document/9415699\nfloat sdMonopoleGear(vec3 p, float n1, float n2, float module, float thickness)\n{ \n    if(length(p) < module*n2*1.1) //Only calculate gear SDF when close\n    {      \n        float Rcr = module * (n1+n2)/2.0; //Gear to hob center distance\n        float hobAngle = degrees(atan(p.y, p.x)) * (n2/n1); //Angle of the spherical gear hob\n        float toothChamfer = (Rcr-module*n2)/2.0; //Chamfer size on top/bottom edge\n\n        vec3 pHob = p - vec3(normalize(p.xy)*Rcr, 0); //Move hob around gear\n        pHob *= rotate(vec3(90, hobAngle, 0));  //Rotate hob in relation to postion & gear ratio\n        pHob = revolve(pHob).xzy; //Revolve hob into a spherical gear profile\n        pHob.xy -= normalize(pHob.xy) * module*n1; //Invert tooth profile\n\n        float d = sdCylinder(p, Rcr/2.0); //Gear body\n        d = opSChamfer(toothChamfer, d, sdPlane(p, vec3(0,0, 1), thickness/2.0)); //Top & chamfer\n        d = opSChamfer(toothChamfer, d, sdPlane(p, vec3(0,0,-1), thickness/2.0)); //Bottom & chamfer\n        d = opI(d, sdSpurGear(pHob, n1, module, 0.1,0.,20.)); //Intersect hob with gear body\n        d = opSChamfer(2.0, d, sdCylinder(p,0.2 * module*n2)); //Center hole\n\n        return d;\n    }\n    \n    return length(p)-module*n2; \n}\n\nfloat Map(vec3 p)\n{\n    float d = -sdSphere(p,200.0);\n    \n    float Rcr = module*(Zsp+Zmp)/2.0; //Center distance\n    \n    vec3 pSph = p * rotate(csAng);\n    vec3 pMPA = (p - vec3(Rcr,0,0)) * rotate(vec3(-mPA+90.,0,2.0*mRA));\n    vec3 pMPB = (p - vec3(0,Rcr,0)) * rotate(vec3(0,mPB+90.,2.0*mRB+90.));\n    \n    d = opU(d, sdCSGear(pSph, Zsp, module));   \n    d = opU(d, sdMonopoleGear(pMPA, Zsp, Zmp, module, module*12.0));\n    d = opU(d, sdMonopoleGear(pMPB, Zsp, Zmp, module, module*12.0));\n    \n    return d;\n}\n\nvec3 MarchRay(vec3 orig, vec3 dir)\n{\n    vec3 mPos = orig;\n    vec3 lPos = orig;\n    for(int i = 0;i < 96;i++)\n    {\n        float dMap = Map(mPos);\n        if(dMap < eps)\n        {\n            if(dMap < 0.0)\n            {\n                mPos = (lPos + mPos)*0.5;\n            }\n            else\n            {\n                break;\n            }\n        }\n        else\n        {\n            lPos = mPos;\n            mPos += dir*dMap;\n        }\n        \n    }\n    \n    return mPos;\n}\n\nvec3 Normal(vec3 p)\n{\n    vec2 offs = vec2(eps,0);\n    float c = Map(p);\n    return normalize(vec3(\n        Map(p+offs.xyy) - c,\n        Map(p+offs.yxy) - c,\n        Map(p+offs.yyx) - c\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy/iResolution.y;\n    vec2 uv = fragCoord/iResolution.y - res/2.0;\n    vec2 m = iMouse.xy/iResolution.y - res/2.0;\n    \n    //Thumbnail camera angle\n    m = (iMouse.xy == vec2(0)) ? vec2(-135, 45) : m*300.0;\n    \n    //Camera\n    mat3 camMat = rotate(vec3(m.y, 0.0, m.x));\n    vec3 orig = vec3(0,-130,0) * camMat;\n    vec3 dir = normalize(vec3(uv.x,0.9,uv.y)) * camMat;\n    \n    //Cross-spherical gear rotation\n    csAng = iTime*vec3(25,31,37.);\n    mat3 csGearMat = inverse(rotate(csAng));\n    vec3 jA = vec3(0,0,1) * csGearMat; //Angle vector for monopole gear A\n    vec3 jB = vec3(1,0,0) * csGearMat; //Angle vector for monopole gear B\n\n    mPA = degrees(atan(jA.y,jA.z)); //Monopole gear A pitch\n    mRA = degrees(acos(-jA.x)); //Monopole gear A roll\n\n    mPB = degrees(atan(jB.x,jB.z)); //Monopole gear B pitch\n    mRB = degrees(acos(-jB.y)); //Monopole gear B roll\n    \n    vec3 hit = MarchRay(orig, dir);\n    vec3 nrm = Normal(hit);\n\n    // Output to screen\n    fragColor = vec4(nrm*inverse(camMat), length(hit-orig));\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}