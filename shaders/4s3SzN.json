{
    "Shader": {
        "info": {
            "date": "1458145370",
            "description": "A very ad-hoc gravitational raytracer made as part of my final project for UCLA's Math 32BH!\nThis Shadertoy prototype was developed as part of an article explaining gravitational raytracing, which you can find at http://bit.ly/254or0K .",
            "flags": 32,
            "hasliked": 0,
            "id": "4s3SzN",
            "likes": 12,
            "name": "Earth Not Above",
            "published": 3,
            "tags": [
                "raytracing",
                "gravitational"
            ],
            "usePreview": 0,
            "username": "NBickford",
            "viewed": 1605
        },
        "renderpass": [
            {
                "code": "// This is a somewhat ad-hoc gravitational raytracer made as part of my final project\n// for UCLA's Math 32BH.\n// This slightly newer version now has some rough Gaussian lens flare added to work\n// with some of the newer features in Shadertoy.\n// You'll find the mathematical code to render the black hole in Buffer A;\n// Buffer B and this buffer mostly just apply lens flare and do some matting.\n\nvec3 GaussianBlur32(vec2 uv, vec2 dx){\n    float[] weights = float[](0.0563924, 0.0551113, 0.0530082, 0.0501333, 0.0465612,\n0.042392, 0.0377516, 0.032788, 0.0276659, 0.0225568, 0.0176285,\n0.0130338, 0.00889953, 0.00531897, 0.00234712);\n       \n    vec3 col = texture(iChannel0, uv).rgb*0.0568225;\n    \n    for(int i=1; i<=15; i++){\n        col += texture(iChannel0, uv-float(i)*dx).rgb*weights[i-1];\n        col += texture(iChannel0, uv+float(i)*dx).rgb*weights[i-1];\n    }\n\n\treturn col;\n}\n\nvec3 GaussianBlur16(vec2 uv, vec2 dx){\n    float[] weights = float[](0.110335, 0.100369, 0.0848705, 0.0656429, 0.0451595, 0.0260942,\n0.0106488);\n       \n    vec3 col = texture(iChannel0, uv).rgb*0.0568225;\n    \n    for(int i=1; i<=7; i++){\n        col += texture(iChannel0, uv-float(i)*dx).rgb*weights[i-1];\n        col += texture(iChannel0, uv+float(i)*dx).rgb*weights[i-1];\n    }\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // A quick lens flare shader\n    vec2 iir = 1.0/iResolution.xy;\n    vec2 uv = fragCoord*iir;\n    \n    // Matte to widescreen\n    vec2 uv2 = 2.0*(fragCoord-0.5*iResolution.xy)/iResolution.x;\n    if(abs(uv2.y)>0.4){\n        fragColor=vec4(0.,0.,0.,1.);\n        return;\n    }\n    \n    //vec3 source = texture(iChannel0, uv).rgb;\n    vec3 source = texture(iChannel1, uv, 4.0).rgb;\n    // Here's a small hack: If we sample in between pixels,\n    // we get a small amount of blur for free!\n    vec3 gb = GaussianBlur16(uv+vec2(0.5*iir),vec2(4.0*iir.x,0.0));\n    gb+=0.5*GaussianBlur16(uv+vec2(0.5)*iir,vec2(16.0*iir.x,0.0));\n    \n    //Add in a reverse image!\n    gb+=0.15*GaussianBlur16(vec2(0.5)-0.55*(uv-vec2(0.5))+vec2(0.5)*iir,vec2(2.0*iir.x,0.0));\n    \n    fragColor = vec4(source+0.5*gb,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.1415926535\n\nvec3 gamma(vec3 v){\n    return pow(v,vec3(2.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0*(fragCoord.xy-0.5*iResolution.xy) / iResolution.x;\n    \n    // Matte to widescreen\n    vec2 uv2 = 2.0*(fragCoord-0.5*iResolution.xy)/iResolution.x;\n    \n    uv*=6.0; // Ad-hoc view factor\n    \n    // Camera controls\n    // Get spherical coordinates from the camera ray (uv.x,1,uv.y)\n    float cd=4.0+6.0*(1.0-pow(1.1,-(2.0*iTime+25.0) ));\n    vec3 nF=vec3(0.4,uv.x,uv.y);\n    \n    // Astronomical aberration\n    float beta=0.0;\n    float betap=sqrt(1.-beta*beta);\n    nF=vec3(-nF.x*betap,-nF.y+beta,-nF.z*betap)/(1.-beta*nF.y);\n    nF*=3.0;\n    nF.y/=1.01; // Ad-hoc: Make black hole more circular\n    \n    // Initialize the state!\n    float a = 0.9;\n    \n    // For the moment, the camera's coordinates will be (cd,pi/2,0), it'll be at\n    // rest with respect to the FIDO (i.e. we're not accounting for special-relativistic\n    // phenomena), and the ray's canonical momenta will be some multiple of nF.\n    float lr=cd;\n    float lo=PI*(0.49-0.001*pow(1.1,-iTime));\n    float lp=0.0+0.04*iTime;\n    float pr=nF.x;\n    float po=nF.z; //we use 'o' because it looks like theta.\n    float b =(nF.y+3.);\n    \n    // Set timestep and local variables to default values\n    float dt=0.1;\n    \n    float drdz=0.0;\n    float dodz=0.0;\n    float dpdz=0.0;\n    float dprdz=0.0;\n    float dpodz=0.0;\n    \n    float q=po*po+cos(lo)*cos(lo)*(b*b/(sin(lo)*sin(lo))-a*a); \n    \n    // Object we hit and the accumulated color\n    int exitCode=0;\n    vec4 accCol=vec4(0.0,0.0,0.0,0.0);\n    \n    // Main rendering loop\n    for(int i=0;i<300;i++){\n\n        // Compute Kerr black hole parameters\n        // (se the paper for more details as to where this came from)\n        float co=cos(lo);\n        float so=sin(lo);\n        \n        float p2=lr*lr+a*a*co*co;\n        float D=lr*lr-2.0*lr+a*a;\n        \n        // Early exit: are we in the black hole?\n        if(D*p2<0.0){\n            exitCode=1;\n            break;\n        }\n        \n        drdz=pr*D/p2;\n        dodz=po/p2;\n        \n        float P=lr*lr+a*a-a*b;\n        float R=P*P-D*((b-a)*(b-a)+q);\n        \n        dpdz=(a*(P-D)+b*D/(so*so))/(D*p2);\n        dprdz=(lr*D*(-R+pr*pr*D*D)+p2*((1.0-lr)*R+D*(2.0*lr*P+(1.0-lr)*((b-a)*(b-a)+q+pr*pr*D))))/(D*D*p2*p2);\n        dpodz=(b*b*D*p2*co/(so*so*so)+a*a*so*co*(R-D*(pr*pr*D+p2)))/(D*p2*p2);\n        \n        \n        // Change our timestep depending on our curvature and position\n        dt=min(min(0.5/abs(dprdz),0.1/abs(dpodz)),0.01+4.0*abs(mod(lo,PI)-0.5*PI) );\n        \n        // Also exit early if our curvature's too high (this just hides some artifacts)\n        if(min(0.5/abs(dprdz),0.5*.5/abs(dpodz))<0.001){\n            exitCode=1;\n            break;\n        }\n        \n        dt=clamp(dt,0.005,0.5);\n        \n        // Have we escaped the region of influence of the black hole?\n        if(lr+dt*drdz>16.0){\n            //call it\n            dt=(16.0-lr)/drdz;\n            lr+=dt*drdz;\n        \tlo+=dt*dodz;\n        \tlp+=dt*dpdz;\n            break;\n        }\n        \n        \n        //if we might have just passed through the ring\n        lo=mod(lo,PI);\n        //lo+dt*dodz=Pi/2\n        float tdt=(PI*0.5-lo)/dodz;\n        if((-1.*dt<=tdt && tdt<=1.*dt) || (0.<=(PI*0.51-lo)/dodz && (PI*0.49-lo)/dodz<=dt)){\n            float tr=lr+tdt*drdz; // Ring radius\n            if(tr>3. && tr<8.){\n               \n                // Ring brightness - This is largely ad-hoc:\n\t\t\t\tfloat lines=(smoothstep(3.,3.5,tr)*(1.-smoothstep(7.4,8.4,tr)));\n                lines*=texture(iChannel1,vec2(mod(tr+0.00*drdz,2.0)/2.0,mod(lp,PI)/PI ),20.0*abs(dodz)).r;\n                \n                float tp=lp+tdt*dpdz;\n                \n                lines*=(1.-smoothstep(0.0,0.001,mod(tp,0.2))*(1.-smoothstep(0.009,0.01,mod(lp,0.2))));\n                lines*=16.0*pow(abs(dodz),1.0)*exp(abs(dodz))*exp(abs(dpdz))*exp(dt); // ad-hoc attenuation factor\n                lines*=0.68;\n                lines=pow(lines,0.45);\n                \n\t\t\t\tvec4 tex=vec4(lines*0.2+0.1*dpdz,lines*0.08,lines*0.04-0.1*dpdz,3.0*lines*exp(dt));\n                accCol.rgb=(accCol.rgb+tex.rgb*tex.a*(1.-accCol.a));\n                accCol.a=accCol.a*(1.-tex.a);\n                \n            }\n        }\n        \n        // Update position\n        lr+=dt*drdz;\n        lo+=dt*dodz;\n        lp+=dt*dpdz;\n        \n        pr+=dt*dprdz;\n        po+=dt*dpodz;\n    }\n    \n    vec3 col;\n    if(exitCode==1){\n        col=vec3(0.,0.,0.);\n    }else{\n        // turn phi and theta into equiangular lookups\n        float eqPhi=mod(lp,2.*PI);\n        eqPhi=(eqPhi/(2.*PI));\n        float eqTheta=1.-mod(lo,PI);\n        eqTheta/=PI;\n        \n        // Technically, we treat iChannel0 as if it's repeated twice over,\n        // to fake a higher-frequency texture.\n        col = texture(iChannel0,vec2(2.*eqPhi,4.*eqTheta)).rgb;\n        \n        //hey, color grading!\n        col.r*=0.8;\n        col.g*=0.8;\n        col*=(0.25*col.r+0.5*col.g+0.25*col.b);\n        col+=1.0*gamma(texture(iChannel0,vec2(8.*eqPhi,16.*eqTheta)).rgb); \n    }\n   \n    //blend in accCol\n    col=accCol.rgb+col*(1.-accCol.a);\n        \n    // More color grading\n    col.r=0.5*col.r+0.5*smoothstep(0.,1.,col.r);\n    col.b=0.7*col.b+0.3*(col.b-smoothstep(0.,1.,col.b));\n    col.b+=0.1*col.r;\n    col.g*=0.8;\n    \n    col.b*=1.2;\n    col.g*=1.3;\n    \n    col = clamp(col,0.0,10.0);\n    fragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec3 GaussianBlur32(vec2 uv, vec2 dx){\n    float[] weights = float[](0.0563924, 0.0551113, 0.0530082, 0.0501333, 0.0465612,\n0.042392, 0.0377516, 0.032788, 0.0276659, 0.0225568, 0.0176285,\n0.0130338, 0.00889953, 0.00531897, 0.00234712);\n       \n    vec3 col = texture(iChannel0, uv).rgb*0.0568225;\n    \n    for(int i=1; i<=15; i++){\n        col += texture(iChannel0, uv-float(i)*dx).rgb*weights[i-1];\n        col += texture(iChannel0, uv+float(i)*dx).rgb*weights[i-1];\n    }\n\n\treturn col;\n}\n\nvec3 GaussianBlur16(vec2 uv, vec2 dx){\n    float[] weights = float[](0.110335, 0.100369, 0.0848705, 0.0656429, 0.0451595, 0.0260942,\n0.0106488);\n       \n    vec3 col = texture(iChannel0, uv).rgb*0.0568225;\n    \n    for(int i=1; i<=7; i++){\n        col += texture(iChannel0, uv-float(i)*dx).rgb*weights[i-1];\n        col += texture(iChannel0, uv+float(i)*dx).rgb*weights[i-1];\n    }\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Same lens flare shader as in the main image\n    vec2 iir = 1.0/iResolution.xy;\n    vec2 uv = fragCoord*iir;\n\n    vec3 gb = GaussianBlur32(uv+vec2(0.5*iir.x,0.5*iir.y),vec2(0.0,4.0*iir.y));\n    //gb+=0.2*GaussianBlur16(uv+vec2(0.5*iir.x,0.5*iir.y),vec2(0.0,16.0*iir.y));\n\n    \n    fragColor = vec4(gb,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}