{
    "Shader": {
        "info": {
            "date": "1552060135",
            "description": "3 simple sphere",
            "flags": 0,
            "hasliked": 0,
            "id": "WdXXz2",
            "likes": 2,
            "name": "ShaderShader",
            "published": 3,
            "tags": [
                "lighttrace"
            ],
            "usePreview": 0,
            "username": "overlord",
            "viewed": 346
        },
        "renderpass": [
            {
                "code": "const vec3 background_color = vec3(0.5, 0.5, 0.5);\nconst float eps = 1e-3;\n\n//Light type\n//1 - ambient\n//2 - point\n//3 - directional\nstruct Light {\n    vec3 position;\n    vec3 direction;\n    float intensity;\n    vec3 color;\n\tint type;\n};\n\nstruct Ray {\n\tvec3 position;\n    vec3 direction;\n};\n\nstruct Material {\n\tvec3 color;\n    float reflective;\n    float specular;\n};\n\nstruct Sphere {\n\tfloat radius;\n\tvec3 position;\n\tMaterial material;\n};\n\nstruct ClosestIntersection {\n\tSphere sphere;\n    float t;\n};\n\nvec3 CanvasToViewport(vec2 uv) {\n    uv /= iResolution.xy;\n    uv -= vec2(0.5);\n\tuv.x *= iResolution.x / iResolution.y;\n    return vec3(uv.x, uv.y, 1.0);\n}\n\nvec3 ReflectRay(vec3 R, vec3 N) {\n    return 2.0 * N * dot(N, R) - R;\n}\n\nfloat IntersectRaySphere(Ray ray, Sphere sphere, float t_min, float t_max) {\n\tvec3 O = ray.position;\n    vec3 D = ray.direction;\n    vec3 C = sphere.position;\n    float r = sphere.radius;\n    vec3 OC = O - C;\n\n    float k1 = dot(D, D);\n    float k2 = 2.0*dot(OC, D);\n    float k3 = dot(OC, OC) - r*r;\n\n    float discriminant = k2*k2 - 4.0*k1*k3;\n    if (discriminant < 0.0)\n        return 1000000.0;\n\n    float t1 = (-k2 + sqrt(discriminant)) / (2.0*k1);\n    float t2 = (-k2 - sqrt(discriminant)) / (2.0*k1);\n\n    if ((t1 <= t2) && (t1 >= t_min) && (t1 <= t_max))\n        return t1;\n    if ((t2 < t1) && (t2 >= t_min) && (t2 <= t_max))\n        return t2;\n\treturn 1000000.0;\n}\n\nClosestIntersection closestIntersection(Ray ray, float t_min, float t_max) {\n\n    const int spheres_num = 4;\n    Sphere spheres[spheres_num];\n    spheres[0] = Sphere(1.0\t  , vec3(0.0, \t  -1.0, 3.0), Material(vec3(1.0, 0.0, 0.0), 0.2, 500.0));\n    spheres[1] = Sphere(1.0\t  , vec3(2.0 , \t   0.0, 4.0), Material(vec3(0.0, 0.0, 1.0), 0.3, 500.0));\n    spheres[2] = Sphere(1.0\t  , vec3(-2.0, \t   0.0, 4.0), Material(vec3(0.0, 1.0, 0.0), 0.4, 10.0));\n\tspheres[3] = Sphere(5000.0, vec3(0.0 , -5001.0, 0.0), Material(vec3(1.0, 1.0, 0.0), 0.0, 1000.0));\n\n    float closest_t = 1000000.0;\n    Sphere closest_sphere = Sphere(0.0, vec3(0.0), Material(vec3(0.0), 0.0, 0.0));\n\n    for (int i = 0; i < spheres_num; i++) {\n        float t = IntersectRaySphere(ray, spheres[i], t_min, t_max);\n            if (t < closest_t) {\n            closest_t = t;\n            closest_sphere = spheres[i];\n        }\n    }\n    return ClosestIntersection(closest_sphere, closest_t);\n}\n\nfloat ComputeLighting(vec3 P, vec3 N, vec3 V, float s) {\n    const int light_num = 3;\n    Light light[light_num];\n    light[0] = Light(vec3(0.0, 0.0, 0.0), vec3( 0.0,  0.0,  0.0), 0.2, vec3(1.0, 1.0, 1.0), 1);\n    light[1] = Light(vec3(2.0, 1.0, 0.0), vec3( 0.0,  0.0,  0.0), 0.6, vec3(1.0, 1.0, 1.0), 2);\n    light[2] = Light(vec3(0.0, 0.0, 0.0), vec3( 1.0,  4.0,  4.0), 0.2, vec3(1.0, 1.0, 1.0), 3);\n\n    float i = 0.0;\n    for (int j = 0; j < light_num; j++) {\n        if (light[j].type == 1) {\n            i += light[j].intensity;\n        } else {\n            vec3 L;\n            if (light[j].type == 2)\n                L = light[j].position - P;\n            else\n                L = light[j].direction;\n\n            float n_dot_l = dot(N, L);\n\n            ClosestIntersection temp = closestIntersection(Ray(P, L), eps, 100.0);\n            if (temp.sphere.radius != 0.0)\n                continue;\n\n            if (n_dot_l > 0.0)\n                i += light[j].intensity* n_dot_l/(length(N)*length(L));\n\n            if (s != -1.0) {\n                vec3 R = 2.0*N*dot(N, L) - L;\n                float r_dot_v = dot(R, V);\n                if (r_dot_v > 0.0)\n                    i += light[j].intensity*pow(r_dot_v/(length(R)*length(V)), s);\n            }\n        }\n    }\n    return i;\n}\n\nvec3 TraceRay(Ray ray, float t_min, float t_max, int depth) {\n\n    ClosestIntersection clos_inter = closestIntersection(ray, t_min, t_max);\n\n    if (clos_inter.sphere.radius == 0.0)\n        return background_color;\n\n    vec3 P = ray.position + clos_inter.t*ray.direction;\n    vec3 N = P - clos_inter.sphere.position;\n    N = N / length(N);\n    vec3 oppositeD = -ray.direction;\n    vec3 local_color = clos_inter.sphere.material.color*ComputeLighting(P, N, oppositeD, clos_inter.sphere.material.specular);\n\n    //return local_color;\n\n    float r = clos_inter.sphere.material.reflective;\n    if (r <= 0.0)\n        return local_color;\n\n    vec3 R = ReflectRay(oppositeD, N);\n    ClosestIntersection refl = closestIntersection(Ray(P, R), eps, 1000000.0);\n\n    return local_color*(1.0 - r) + refl.sphere.material.color*r;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n\n    vec3 xyz = CanvasToViewport(uv);\n\n    Ray ray = Ray(vec3(0.0, 0.0, 0.0-cos(iTime)), xyz);\n    vec3 color = TraceRay(ray, 1.0, 100.0, 5);\n\n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}