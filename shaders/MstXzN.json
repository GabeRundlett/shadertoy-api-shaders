{
    "Shader": {
        "info": {
            "date": "1458221642",
            "description": "Move around, collect gems, don't get hurt or trapped. R to restart.",
            "flags": 56,
            "hasliked": 0,
            "id": "MstXzN",
            "likes": 39,
            "name": "Boulder Dash",
            "published": 3,
            "tags": [
                "game",
                "music",
                "cellular",
                "ca",
                "adventure",
                "ladybug",
                "tilebased",
                "ruleset"
            ],
            "usePreview": 0,
            "username": "bergi",
            "viewed": 1987
        },
        "renderpass": [
            {
                "code": "/** Boulder Dash - https://www.shadertoy.com/view/MstXzN\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\t(cc) 2016, Stefan Berke\n\n\tMove around, collect gems, don't get hurt or trapped. R to restart\n\tMap get's huge in fullscreen after restart :)\n\n\tv0.1 \n\t\tAn excersise in recreating the boulder rules as cellular automata. \n\t\tGives me quite an headache... Does not function 100% in all cases\n\n\t\tYou can run away from physics in this version. Falling things are\n\t\tonly updated every xth frame.\n\n\t\tNo concrete level design, you do not have to collect ALL gems to win. \n\t\tWhich means, the only goal is to overflow the counter display.\n\t\t\n*/\n\n// -------- RENDER CONFIG ----------\n\n#define AA 1\t\t\t// anti-aliasing > 1\n#define DETAIL 1\t\t// none, some, all\n#define LIGHTING 2\t\t// none, player, diamonds\n#define LADYBUG 1\t\t// agyptian, restoftheworld\n\n\n\n// -------- GAME STATE -------------\n\n// tiles\n#define EMPTY 0\n#define SAND 1\n#define WALL 2\n#define STONE 3\n#define DIAMOND 4\n#define PLAYER 5\n\n// tile states\n#define S_REST 0\n#define S_FALL 1\n#define S_ROLL_LEFT 2\n#define S_ROLL_RIGHT 3\n#define S_LANDED 4\n#define S_UP 5\n#define S_DOWN 6\n#define S_LEFT 7\n#define S_RIGHT 8\n#define S_PUSH_LEFT 9\n#define S_PUSH_RIGHT 10\n#define S_SMASHED 11\n#define S_COLLECTED 12\n\n#define TILE(pix) int(pix.x+.5)\n#define STATE(pix) int(pix.y+.5)\n#define TEXMOD(pix) pix.z\n\n// game state\nvec4 value(in int idx) { return texture(iChannel0, vec2(float(idx)+.5,.5)/iChannelResolution[0].xy); }\n#define V_PLAYER_POS 0\n#define V_CAMERA_CENTER 1\n#define V_CAMERA_MOD 2\n#define V_SMASHED 3\n#define V_GEMS 10\n\n\n\n\n// currently rendered map position\nvec2 curTilePos;\nfloat tileSize; // size of map tile in pixels\n\n\n// rather creates patterns than strict randomness \n// change input texture for other patterns\nfloat hash1(in vec2 p)\n{\n    p = fract(p * vec2(6.171, 5.1213));\n    vec4 t = texture(iChannel3, p / iChannelResolution[3].xy);\n    p.xy += t.xy;\n    return fract(p.x * p.y * 35.937 * (1.+t.z));\n}\n\nfloat noise1(in vec2 p)\n{\n    vec2 f0 = floor(p), f1 = fract(p);\n    f1 = (3.-2.*f1)*f1*f1;\n    return mix( mix(hash1(f0), hash1(f0+vec2(1,0)), f1.x),\n                mix(hash1(f0+vec2(0,1)), hash1(f0+vec2(1,1)), f1.x), f1.y);\n}\n\n\n// -------------- LIGHTING ----------------\n\n// diamond color from texmod\nvec3 diaCol(in float t)\n{\n    return .6+.4*vec3(sin(t),sin(t*1.1+.5),sin(t*1.3+1.5))\n        \t*(.7+.3*sin(iTime*(1.+.3*t)+t))\n#if LIGHTING < 2\n        * 2.\n#endif\n        ;\n}\n\n#if LIGHTING > 1\n// preinitialized with diamonds in +/-2 neighbourhood\nvec4 diaLights[25]; // x,y, on/off\nvec3 lightingDia(in vec3 norm)\n{\n    vec3 col = vec3(0.);\n    for (int i=0; i<25; ++i)\n    {\n        vec3 dt = vec3(diaLights[i].xy, .8) - vec3(curTilePos, 0.);\n        vec3 lnorm = normalize(dt);\n        col += diaLights[i].z * diaCol(diaLights[i].w) * max(0., dot(norm, lnorm))\n            / (1. + .5*dot(dt,dt));\n    }\n    return col;\n}\n#else\nvec3 lightingDia(in vec3 norm) { return vec3(0.); }\n#endif\n\n#if LIGHTING > 0\n    // lighting from player + lightingDia\n    vec3 lightPos;\n    vec3 lighting(in vec3 norm)\n    {\n        vec3 dt = lightPos - vec3(curTilePos, 0.);\n        vec3 lnorm = normalize(dt);\n        return vec3(1.,.8,.4) * max(0., dot(norm, lnorm)) / (1. + .1*dot(dt, dt))\n                + lightingDia(norm);\n    }\n#else\n\tvec3 lighting(in vec3 norm) { return vec3(0.); }\n#endif\n\n// ---- texture helpers ----\n\nfloat squareHeight(in vec2 uv)\n{\n#if DETAIL > 0\n    float h = noise1(uv + curTilePos);\n#if DETAIL > 1\n    h -= 0.3*noise1(uv*3. + curTilePos);\n    h += 0.2*noise1(uv*4.5 + curTilePos);\n    h += 0.15*noise1(uv*13. + curTilePos);\n    h += 0.06*noise1(uv*23. + curTilePos);\n#endif\n    \n    h = .5+.5*h;\n#else\n    float h = 1.;\n#endif\n\n    h *= pow(min(1., 3.*min(abs(abs(uv.x)-1.), abs(abs(uv.y)-1.))), .4);\n    return h;\n}\n// (guess i'm too lazy to do the normal analytically)\nvec3 squareNorm(in vec2 uv)\n{\n    vec2 e = vec2(1./tileSize,.0);\n    return normalize(vec3(squareHeight(uv-e.xy) - squareHeight(uv+e.xy),\n                          squareHeight(uv-e.yx) - squareHeight(uv+e.yx),\n\t\t\t\t\t\t  2.*e.x));\n}\n\nfloat sphereHeight(in vec2 uv)\n{\n#if DETAIL > 0\n    float h = .9+.1*noise1(uv*11.11 + curTilePos);\n#if DETAIL > 1\n    h -= 0.5*noise1(uv*2. + curTilePos);\n    h += 0.3*noise1(uv*3.5 + curTilePos);\n    //h += 0.15*noise1(uv*13. + curTilePos);\n    h += 0.07*noise1(uv*23. + curTilePos);\n#endif\n#else\n    float h = 1.;\n#endif\n    \n    float l = length(uv);\n  \th *= l >= 1. ? 0. : sqrt(1. - l);\n    return h;\n}\nvec3 sphereNorm(in vec2 uv)\n{\n    vec2 e = vec2(1./tileSize,.0);\n    return normalize(vec3(sphereHeight(uv-e.xy) - sphereHeight(uv+e.xy),\n                          sphereHeight(uv-e.yx) - sphereHeight(uv+e.yx),\n\t\t\t\t\t\t  2.*e.x));\n}\n\nfloat diaHeight(in vec2 uv)\n{\n    float h = 1.-abs(uv.x-uv.y);\n    h = min(h, 1.-abs(uv.x+uv.y));\n    \n    return h;\n}\nvec3 diaNorm(in vec2 uv)\n{\n    vec2 e = vec2(1./tileSize,.0);\n    return normalize(vec3(diaHeight(uv-e.xy) - diaHeight(uv+e.xy),\n                          diaHeight(uv-e.yx) - diaHeight(uv+e.yx),\n\t\t\t\t\t\t  2.*e.x));\n}\n\n/** Distance to a cylinder with round caps, end-points in @p a and @p b, radius in @p r \n\tfrom iq */\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// distance, material\nvec2 playerDist(in vec2 uv)\n{\n    float m = 0.;\n\tfloat d = length(uv*vec2(1.2,1.)) - .7;\n    float d1 = length(uv-vec2(0.,.6)) - .3;\n    if (d1 < d) { d = d1; m = 2.; }\n    \n    uv.x = abs(uv.x);  \n    d1 = min(d, sdCapsule(uv, vec2(0.3,0.3), vec2(.8,.8), .08));\n    if (d1 < d) { d = d1; m = 1.; }\n\td1 = min(d, sdCapsule(uv, vec2(0.2,-0.3), vec2(.8,-.8), .08));\n    if (d1 < d) { d = d1; m = 1.; }\n    d1 = min(d, sdCapsule(uv, vec2(0.1,0.), vec2(.9,.0), .08));\n    if (d1 < d) { d = d1; m = 1.; }\n\n    return vec2(d, m);\n}\n\nvec3 playerNorm(in vec2 uv)\n{\n\tvec2 e = vec2(1./tileSize,.0);\n    return normalize(vec3(playerDist(uv+e.xy).x - playerDist(uv-e.xy).x,\n                          playerDist(uv+e.yx).x - playerDist(uv-e.yx).x,\n\t\t\t\t\t\t  2.*e.x));\n}\n\nvec3 playerColor(in vec2 uv, float m)\n{\n#if LADYBUG > 0\n    if (m > .5)\n        return vec3(.2);\n    vec3 col = vec3(1,0,0);\n    float d = length(fract(uv*2.)-vec2(.5,.4))*3.;\n    col *= smoothstep(.9,1.,d);\n    return col;\n#else\n    return vec3(1.,.6,.3);\n#endif\n}\n\n// render TILE tileNr with TEXMOD tmod\n// uv is [-1,1]\nvec3 tileTexture(in vec2 uv, in int tileNr, in float tmod)\n{\n    vec3 col = vec3(0.);\n    vec3 light = vec3(0.);\n    if (tileNr == SAND)\n    {\n        float h = noise1(uv*10. + 10.*curTilePos);\n        h -= .7 * noise1(uv*22. + 10.*curTilePos);\n        h += .3 * noise1(uv*43. + 10.*curTilePos);\n        col = 1.6*vec3(.6,.2+.1*h,0.24*h) * (.3+.7*h);\n\t\tcol *= min(1., 7.*min(abs(abs(uv.x)-1.), abs(abs(uv.y)-1.)));\n    }\n    else if (tileNr == WALL)\n    {\n        col = vec3(squareHeight(uv));\n        light = lighting(squareNorm(uv));\n    }\n    else if (tileNr == DIAMOND)\n    {\n        float dia = diaHeight(uv);\n        if (dia > 0.)\n        {\n        \tcol = diaCol(tmod);\n        \tcol *= pow(dia, .4);\n            light = lighting(diaNorm(uv));\n        }\n    }\n    else if (tileNr == PLAYER)\n    {\n        int tm = int(tmod+.5);\n        mat2 rm = mat2(1,0, 0,1);\n        if (tm == S_DOWN) rm = mat2(-1,0, 0,-1);\n        if (tm == S_LEFT) rm = mat2(0,-1, -1,0);\n        if (tm == S_RIGHT) rm = mat2(0,1, 1,0);\n        vec2 dm = playerDist(rm*uv);\n        float v = smoothstep(0.1,0.,dm.x);\t\n\t\tcol = v * max(0., 1.-2.*dm.x) * .9 \n            \t* ( tm == S_SMASHED ? vec3(1,0,0) : playerColor(rm*uv, dm.y) );\n        vec3 n = playerNorm(rm*uv);\n        n.xy = rm*n.xy;        \n        light = v*lightingDia(n);\n    }\n    else if (tileNr == STONE && length(uv) < 1.)\n    {\n        col = vec3(sphereHeight(uv));\n        light = lighting(sphereNorm(uv));\n    }\n\n#if LIGHTING > 0    \n    col = .6 * col + .7 * light;\n#else\n    \n#endif\n    return clamp(col, 0., 1.);\n}\n\n\n// return map data, wraps around, 'invents' wall at x|y==0 \nvec4 levelData(in ivec2 pos)\n{\n    vec2 fpos = mod(vec2(pos), iChannelResolution[0].xy);\n    vec4 t = texture(iChannel0, ((fpos + .5) / iChannelResolution[0].xy));\n    return fpos.x < 1. || fpos.y < 1. \n        ? vec4(WALL, S_REST, 0, 0)//vec4(floor(hash1(vec2(pos))*1.+.5)*2., 0., 0., 0.)\n        : t;\n}\n\n\n// --- number printing --- \n// from FabriceNeyret2\n// https://www.shadertoy.com/view/ltfXz7\nint printDigit(vec2 p, float n) { // display digit  see https://www.shadertoy.com/view/MlXXzH\n    int i=int(p.y), b=int(pow(2.,floor(30.-p.x-n*3.)));\n    i = p.x<0.||p.x>3.? -1:\n    i==5? 972980223: i==4? 690407533: i==3? 704642687: i==2? 696556137:i==1? 972881535: -1;\n \treturn i<0 ? -1 : i/b-2*(i/b/2);\n}\nint printNum(vec2 p, float n) { // display number \n    float c=1e3;\n    for (int i=0; i<4; i++) { \n        if ((p.x-=4.)<3.) return printDigit(p,mod(floor(n/c),10.));  \n        c*=.1;\n    }\n    return -1;\n}\n// --- end number printing\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 ouv = fragCoord.xy / iResolution.xy, \n         uv = ouv;\n\n    //fragColor = vec4(noise1(uv*10.), 0., 0., 1.);\n    //return;\n    \n    vec2 camCenter = value(V_CAMERA_CENTER).xy;\n    vec4 camMod = value(V_CAMERA_MOD);\n    float distrt = value(V_SMASHED).x * 4.;\n\ttileSize = iResolution.y / 10. * camMod.x;\n\t\n    // init lights\n#if LIGHTING > 0\n    lightPos = vec3(value(V_PLAYER_POS).xy, 1. - distrt);\n    vec2 lpos = (fragCoord - iResolution.xy*.5) / tileSize + camCenter;\n\tlpos.y -= distrt * noise1(uv.xx*3.);\n#if LIGHTING > 1\n    for (int y=0; y<5; ++y)\n    for (int x=0; x<5; ++x)\n    {\n        vec4 l = levelData(ivec2(lpos) + ivec2(x-2,y-2));\n        diaLights[y*5+x] = vec4(\n            lpos.x + float(x-2), lpos.y + float(y-2),\n            TILE(l) == DIAMOND ? 1. : 0.,\n            TEXMOD(l));        \n    }\n#endif\n#endif\n    \n    vec3 acol = vec3(0.);\n    vec2 offs = vec2(0.);\n    \n#if AA > 1\n    for (int aay=0; aay<AA; ++aay)\n\tfor (int aax=0; aax<AA; ++aax)\n    {\n        offs = vec2(float(aax), float(aay)) / float(AA);\n#endif\n        vec2 luv = (fragCoord+offs - iResolution.xy*.5) / tileSize + camCenter;\n\t    luv.y -= distrt * noise1(uv.xx*3.);\n\n        vec4 l = levelData(ivec2(luv));\n        curTilePos = floor(luv);\n        vec2 tileuv = fract(luv)*2.-1.;\n        vec3 col = tileTexture(tileuv, int(l.x+.5), l.z);\n\n        // debug state\n        //if (tileuv.x > .5 && tileuv.y+1. <= l.y/4.)\n        //    col.y = 1.;\n       \t//if (STATE(l) == S_COLLECTED) col.z = 1.;\n        \n        acol += col;\n        \n#if AA > 1\n    }\n    acol /= float(AA*AA);\n#endif\n    \n    int num = printNum(90.*uv*vec2(iResolution.x/iResolution.y,1.), value(V_GEMS).x);\n\tif (num>0)\n        acol += 1.;\n    \n    acol *= pow( 16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), .1);\n    \n\tfragColor = vec4(acol,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/** Boulder Dash - https://www.shadertoy.com/view/MstXzN\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\t(cc) 2016, Stefan Berke\n\n\tMove around, collect gems, don't get hurt or trapped.\n*/\n\n// tiles\n#define EMPTY 0\n#define SAND 1\n#define WALL 2\n#define STONE 3\n#define DIAMOND 4\n#define PLAYER 5\n\n// tile states\n#define S_REST 0\n#define S_FALL 1\n#define S_ROLL_LEFT 2\n#define S_ROLL_RIGHT 3\n#define S_LANDED 4\n#define S_UP 5\n#define S_DOWN 6\n#define S_LEFT 7\n#define S_RIGHT 8\n#define S_PUSH_LEFT 9\n#define S_PUSH_RIGHT 10\n#define S_SMASHED 11\n#define S_COLLECTED 12\n\n#define TILE(pix) int(pix.x+.5)\n#define STATE(pix) int(pix.y+.5)\n#define TEXMOD(pix) pix.z\n\n#define SET_TILE(pix, tile) pix.x = float(tile)\n#define SET_STATE(pix, tile) pix.y = float(tile)\n#define SET_TEXMOD(pix, tile) pix.z = float(tile)\n\n// game state\n#define storeVal(idx_, vec4_) if (int(fragCoord.x) == int(idx_)) fragColor = vec4_;\nvec4 value(in int idx) { return texture(iChannel0, vec2(float(idx)+.5,.5)/iChannelResolution[0].xy); }\n#define V_PLAYER_POS 0\n#define V_CAMERA_CENTER 1\n#define V_CAMERA_MOD 2\n#define V_SMASHED 3\n#define V_GEMS 10\n\nbool key(in int k) { return texture(iChannel1, vec2(float(k)+.5,1.5)/vec2(256.,3.)).x > .5; }\n#define K_LEFT 37\n#define K_UP 38\n#define K_RIGHT 39\n#define K_DOWN 40\n#define K_R 82\n\n// return map data, wraps around, 'invents' wall at x|y==0 \nvec4 levelData(in ivec2 pos)\n{\n    vec2 fpos = mod(vec2(pos), iChannelResolution[0].xy);\n    vec4 t = texture(iChannel0, ((fpos + .5) / iChannelResolution[0].xy));\n    return fpos.x < 1. || fpos.y < 1. \n        ? vec4(WALL, S_REST, 0, 0)//vec4(floor(hash1(vec2(pos))*1.+.5)*2., 0., 0., 0.)\n        : t;\n}\n\n\n// rather creates patterns than strict randomness \n// change input texture for other patterns\nfloat hash1(in vec2 p)\n{\n    p = fract(p * vec2(6.171, 5.1213));\n    vec4 t = texture(iChannel3, p / iChannelResolution[3].xy);\n    p.xy += t.xy;\n    return fract(p.x * p.y * 35.937 * (1.+t.z));\n}\n\n\n// creates a new map\nvoid createMap(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 self = vec4(0.);//levelData(ivec2(fragCoord));\n    \n    vec2 seed = fragCoord + sin(iDate.zw);\n    \n    // sand and walls\n    SET_TILE(self, floor(hash1(seed) * 2. + .4));\n    \n    // stones and diamonds\n    if (TILE(self) != WALL && hash1(seed*1.13) < .3)\n        SET_TILE(self, 2.+floor(hash1(seed*1.31) * 2. + .7) );\n        \n    if (ivec2(fragCoord) == ivec2(30,20))\n    {\n        SET_TILE(self, PLAYER);\n    }\n    \n\tSET_TEXMOD(self, hash1(seed*3.11+.1)*10.);\n        \n    fragColor = self;\n}\n\nbool canPlayerEnter(in int tile) { return tile == EMPTY || tile == SAND || tile == DIAMOND; }\n\n// --- process all map physics ---\n/* It's a bit tricky, \n   basically a move action is split into three parts:\n\t1) set request via SET_STATE\n\t2) fullfill request of neighbour cells\n    3) clear self when fullfilled\n   This takes 2 frames and the order of things is important and there \n   are still a few ladybugs in this code. \n   Especially: player and non-player objects are updated at different intervals which\n   seems problematic, for example, missed player SMASH or missing clears leading to \n   creation of new objects out of nothing.\n   Btw. The player is part of the map and is also tracked by V_PLAYER_POS. \n   The map would process multiple players, but the S_SMASHED and S_COLLECTED states are\n   only tracked for the one player in V_PLAYER_POS\n*/\nvoid processMap(inout vec4 fragColor, in vec2 fragCoord, \n                bool procPlayer, bool procFall)\n{    \n    ivec2 levelPos = ivec2(fragCoord);\n    if (levelPos.x < 1 || levelPos.y < 1)\n    \treturn;\n   \n    vec4 self =  levelData(levelPos);\n\tvec4 topl =  levelData(levelPos+ivec2(-1, 1));\n\tvec4 top =   levelData(levelPos+ivec2( 0, 1));\n\tvec4 topr =  levelData(levelPos+ivec2( 1, 1));\n\tvec4 botl =  levelData(levelPos+ivec2(-1,-1));\n\tvec4 bot =   levelData(levelPos+ivec2( 0,-1));\n\tvec4 botr =  levelData(levelPos+ivec2( 1,-1));\n\tvec4 left =  levelData(levelPos+ivec2(-1, 0));\n\tvec4 right = levelData(levelPos+ivec2( 1, 0));\n\n    // clear previous gem-collection flag\n    if (STATE(self) == S_COLLECTED)\n        SET_STATE(self, S_REST);\n    \n    // process player move requests\n    bool isDia = TILE(self) == DIAMOND;\n    if (canPlayerEnter(TILE(self)) || isDia)\n    {\n        int newState = isDia ? S_COLLECTED : S_REST;\n\t    \t if (TILE(bot) == PLAYER && STATE(bot) == S_UP) { self = bot; SET_STATE(self, newState); }\n\t    else if (TILE(top) == PLAYER && STATE(top) == S_DOWN) { self = top; SET_STATE(self, newState); }\n\t    else if (TILE(left) == PLAYER && STATE(left) == S_RIGHT) { self = left; SET_STATE(self, newState); }\n\t    else if (TILE(right) == PLAYER && STATE(right) == S_LEFT) { self = right; SET_STATE(self, newState); }\n    }\n\telse \n    // clear self when player move requests succeed\n    if (   (STATE(self) == S_UP && canPlayerEnter(TILE(top)))\n        || (STATE(self) == S_DOWN && canPlayerEnter(TILE(bot)))\n        || (STATE(self) == S_LEFT && canPlayerEnter(TILE(left)))\n        || (STATE(self) == S_RIGHT && canPlayerEnter(TILE(right))))\n    {\n        self = vec4(0.);\n    }\n\n    if (TILE(self) == PLAYER && procPlayer)\n    {\n        // fall on head\n\t\tif (STATE(top) == S_LANDED)\n        { \n            SET_STATE(self, S_SMASHED); \n            SET_TEXMOD(self, S_SMASHED);// helper for anim\n        }\n\n\t\t// store player move request\n        if (key(K_UP)) { SET_TEXMOD(self, S_UP); if (canPlayerEnter(TILE(top))) { SET_STATE(self, S_UP); } }\n        if (key(K_DOWN)) { SET_TEXMOD(self, S_DOWN); if (canPlayerEnter(TILE(bot))) { SET_STATE(self, S_DOWN); } }\n        if (key(K_LEFT)) { SET_TEXMOD(self, S_LEFT); if (canPlayerEnter(TILE(left))) { SET_STATE(self, S_LEFT); } }\n        if (key(K_RIGHT)) { SET_TEXMOD(self, S_RIGHT); if (canPlayerEnter(TILE(right))) { SET_STATE(self, S_RIGHT); } }\n    }\n    \n    \n    // process stone push\n    if (TILE(self) == EMPTY)\n    {\n        if (TILE(right) == STONE && STATE(right) == S_PUSH_LEFT) { self = right; SET_STATE(self, S_REST); }\n        else \n        if (TILE(left) == STONE && STATE(left) == S_PUSH_RIGHT) { self = left; SET_STATE(self, S_REST); }\n    }\n    \n    // clear stone after push request succeeded\n    if (TILE(self) == STONE)\n    {\n        if (   (STATE(self) == S_PUSH_LEFT && TILE(left) == EMPTY)\n            || (STATE(self) == S_PUSH_RIGHT && TILE(right) == EMPTY) )\n            self = vec4(0.);\n    }\n    \n    // store stone push requests\n    if (TILE(self) == STONE)\n    {\n\t\tif (TILE(right) == PLAYER && key(K_LEFT)) { SET_STATE(self, S_PUSH_LEFT); }\n\t\tif (TILE(left) == PLAYER && key(K_RIGHT)) { SET_STATE(self, S_PUSH_RIGHT); }\n    }\n    \n    if (procFall)\n    {\n        if (STATE(self) == S_LANDED)\n            SET_STATE(self, S_REST);\n        \n        // clear self when fall requests succeed\n        if (   (STATE(self) == S_FALL && TILE(bot) == EMPTY)\n            || (STATE(self) == S_ROLL_LEFT && TILE(botl) == EMPTY)\n            || (STATE(self) == S_ROLL_RIGHT && TILE(botr) == EMPTY))\n        {\n            self = vec4(0.);\n        }\n\n        // process stuff that wants to enter this tile\n        if (TILE(self) == EMPTY)\n        {\n            // falling states of maptiles above\n            // (remember if it has fallen)\n                 if (STATE(top) == S_FALL) { self = top; SET_STATE(self, S_LANDED); }\n            else if (STATE(topl) == S_ROLL_RIGHT) { self = topl; SET_STATE(self, S_LANDED); }\n            else if (STATE(topr) == S_ROLL_LEFT) { self = topr; SET_STATE(self, S_LANDED); }\n        }\n        \n\n        // create fall requests for stones and diamonds\n        if (TILE(self) == STONE || TILE(self) == DIAMOND)\n        {\n            // fall down\n            if (TILE(bot) == EMPTY)\n            {\n                SET_STATE(self, S_FALL);\n            } \n            // roll to side\n            else if (TILE(botl) == EMPTY && TILE(left) == EMPTY)\n            {\n                SET_STATE(self, S_ROLL_LEFT);\n            }\n            else if (TILE(botr) == EMPTY && TILE(right) == EMPTY)\n            {\n                SET_STATE(self, S_ROLL_RIGHT);\n            }\n            else\n            // clear fall/roll flag\n            // (but keep for one frame, to hit player)\n                if (STATE(self) != S_LANDED)\n                \tSET_STATE(self, S_REST);\n        }\n    }\n    \n    \n    fragColor = self;\n}\n\n\nvoid initStates(inout vec4 fragColor, in vec2 fragCoord)\n{\n    if (int(fragCoord.y) != 0)\n        return;\n    fragColor = vec4(0.);\n    \n    storeVal(V_PLAYER_POS, vec4(30,20,0,0));\n    storeVal(V_CAMERA_CENTER, vec4(30,20,0,0));\n    storeVal(V_CAMERA_MOD, vec4(1,0,0,0));\n}\n\n// step the game states\nvoid processStates(inout vec4 fragColor, in vec2 fragCoord)\n{\n    if (fragCoord.y >= 1.)\n        return;\n    \n    float tdelta = 1./60.;\n    \n    // track player movement\n    ivec2 ppos = ivec2(value(V_PLAYER_POS).xy);\n    vec4 player = levelData(ppos);\n    if (TILE(player) != PLAYER)\n    {\n        ivec2 ppos2,\n        ppos1 = ppos+ivec2(1,0); if (TILE(levelData(ppos1)) == PLAYER)\n        \t{ storeVal(V_PLAYER_POS, vec4(ppos1,0,0)); ppos2 = ppos1; }\n        ppos1 = ppos+ivec2(-1,0); if (TILE(levelData(ppos1)) == PLAYER)\n        \t{ storeVal(V_PLAYER_POS, vec4(ppos1,0,0)); ppos2 = ppos1; }\n        ppos1 = ppos+ivec2(0,1); if (TILE(levelData(ppos1)) == PLAYER)\n        \t{ storeVal(V_PLAYER_POS, vec4(ppos1,0,0)); ppos2 = ppos1; }\n        ppos1 = ppos+ivec2(0,-1); if (TILE(levelData(ppos1)) == PLAYER)\n        \t{ storeVal(V_PLAYER_POS, vec4(ppos1,0,0)); ppos2 = ppos1; }\n    \n\t\tplayer = levelData(ppos2);    \n        \n    } \n    // track actions to player\n    {\n        if (STATE(player) == S_COLLECTED)\n\t        { storeVal(V_GEMS, value(V_GEMS) + vec4(1)); }\n\n        if (STATE(player) == S_SMASHED)\n       \t{ \n            float v = value(V_SMASHED).x;\n            storeVal(V_SMASHED, vec4(v + tdelta*(1.-v))); \n        }\n    }\n    \n    // camera follows player position\n    vec2 campos = value(V_CAMERA_CENTER).xy;\n    vec2 cdelta = value(V_PLAYER_POS).xy - campos;\n    storeVal(V_CAMERA_CENTER, vec4(campos + tdelta * cdelta, 0., 0.));\n    \n    // camera gimmicks\n    vec4 camMod = value(V_CAMERA_MOD);\n    camMod += vec4(.01*sin(iTime*0.2), .03*sin(iTime/7.7), 0,0);\n    camMod.x += 0.02 * dot(cdelta, cdelta) * (.3 - camMod.x);\n    camMod.x += 0.1 * (1. - camMod.x);\n    storeVal(V_CAMERA_MOD, mix(value(V_CAMERA_MOD), camMod, tdelta));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 1 || key(K_R))\n    {\n    \tcreateMap(fragColor, fragCoord);\n        initStates(fragColor, fragCoord);\n    }\n    else\n    {\n        fragColor = texture(iChannel0, (fragCoord)/iChannelResolution[0].xy);\n\n        processStates(fragColor, fragCoord);\n        processMap(fragColor, fragCoord, \n                   value(V_SMASHED).x < .5,\n                   int(mod(float(iFrame), 10.)) == 0);\n    }           \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/** Boulder Dash - https://www.shadertoy.com/view/MstXzN\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\t(cc) 2016, Stefan Berke\n\t\n\t\"THE MUSIC\"\n*/\n\n\n// 0 1  2 3  4 5 6  7 8  9 10 11\n// c c# d d# e f f# g g# a a# b\n\n    \nfloat note2freq(in float note)\n{\n    return pow(pow(2., 1./12.), note) * 16.35155;\n}\n\n#define P(no_, ti_) if (ti > t) { n = float(no_); e = (ti - t) / (ti_); } t += (ti_);\n\nvec2 baseChords(in float time, in float baseNote)\n{\n    float ti = mod(time, 2.);\n    float n = 0., e = 0., t = 0.;\n    \n    P( 0, 0.25);\n    P( 5, 0.5);\n    P( 0, 0.25);\n    P(-7, 0.75);\n    P(-5, 0.25);\n    \n    float f = time*note2freq(baseNote + n);\n    float s = smoothstep(0.,0.004,e) * max(0., 1.-e) \n        \t* sin(f + 0.4*sin(f/4.));\n    \n    return vec2(s);\n}\n\n#undef P\n#define P(no_, ti_) if (ti > t) { n = float(no_); e = (ti - t) / (ti_); e2 = (ti - t) / 2.; } t += (ti_);\n\nvec2 leadVoice(in float time, in float baseNote)\n{\n    // 2x 0-16   32\n    // 2x 16-24  16\n    // 2x 24-32  16\n    float ti = mod(time, 64.);\n    float n = 0., e = 0., e2 = 0., t = 0., rep = 0.;\n    \n    if (ti < 32.)\n    {\n        if (ti > 16.)\n            ti -= 16., rep = 1.;\n        // 0\n        P( 0, 1./8.);\n        P( 3, 1./8.);\n        P( 5, 1./8.);\n        P( 7, 1./8.);\n        P( 5, 3.5);\n\n        P( 0, 1./8.);\n        P( 3, 1./8.);\n        P( 5, 1./8.);\n        P( 7, 1./8.);\n        P( 9, 3.5);\n        // 8\n        P( 0, 1./8.);\n        P( 3, 1./8.);\n        P( 7, 1./8.);\n        P(10, 1./8.);\n        P( 7, 3.5);\n\n        P( 9, 1./8.);\n        P( 7, 1./8.);\n        P( 5, 1./8.);\n        P( 7, 1./8.);\n        P( 5, 3.5);\n    }\n    else if (ti < 48.)\n    {\n        ti -= 32.;\n        if (ti > 8.)\n            ti -= 8., rep = 1.;\n        // 16\n        P( 9, 1.);\n        P( 7, .75);\n        P( 9, .125);\n        P(10, .125);\n        P( 9, .125);\n        P( 7, .125);\n        P( 9, 1.75);\n\n        P(12, 1.);\n        P(10, .75);\n        P(12, .125);\n        P(15, .125);\n        P(12, .125);\n        P(10, .125);\n        P( 9, 1.75);\n    }\n    else //if (ti < 64.)\n    {\n        ti -= 48.;\n        if (ti > 8.)\n            ti -= 8., rep = 1.;\n        // 0\n        P(12, .125);\n        P(12, .125);\n        P(12, .125);\n        P(12, .25);\n        P(10, .25);\n        P(9, .75);\n\n        P(9, .125);\n        P(10, .125);\n        P(12, .125);\n        P(10, .125);\n        P(12, .125);\n        P(15, .125);\n        P(12, .125);\n        P(15, .125);\n        P(17, .125);\n        P(15, .5);\n        \n        P(12, .25);\n        P(10, .125);\n        P( 9, .125);\n        P(10, .25);\n        P( 9, .125);\n        P( 7, .125);\n        P( 9, .25);\n        P( 7, .125);\n        P( 5, .125);\n        P( 7, .25);\n        P( 5, .125/2.);\n        P( 5, .125/2.);\n        P( 5, .125);\n        P( 3, .25);\n    }\n    \n    e = max(0., 1.-e);\n    e2 = pow(max(0., 1.-e2), .5);\n\tfloat mo = 1.-e2;\n    \n    float f = note2freq(baseNote + n);\n    mo = min(.5,mo) * 0.001 * f * sin(time*(25.-5.*mo));\n    f *= time;\n    \n    float env = smoothstep(0.,0.004,1.-e) * e;\n    vec2 s = env * vec2( sin(f+mo + .7*e2*sin(f*2.)),\n                        -sin(f-mo + .3*e2*cos(f*3.)));\n    \n    s += rep * env * vec2(cos(f/2.-mo + .3*s.x),\n                          sin(f/2.+mo + .3*s.x));\n    \n    return s;\n}\n\n\nfloat baseNote(float time)\n{\n    float ti = floor(time/16.);\n    \n    float n = mod(ti, 3.) + mod(ti, 4.) + mod(ti, 5.);\n    \n    \n    return n + 72.;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    vec2 s = baseChords(time, baseNote(time));\n    \n    s += leadVoice(time, baseNote(time));\n    time -= .5;\n    s += 0.3 * leadVoice(time, baseNote(time)).yx;\n    time -= .5;\n    s -= 0.22 * leadVoice(time, baseNote(time));\n    time -= .5;\n    s -= 0.1 * leadVoice(time, baseNote(time)).yx;\n    \n    return s * .3;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 38
                    }
                ],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}