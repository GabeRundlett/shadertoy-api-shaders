{
    "Shader": {
        "info": {
            "date": "1534142612",
            "description": "generates a new blue noise texture every 10 * 60 frames and then continues to optimize out low frequency noise. Still needs some work, but it's a good start. ",
            "flags": 32,
            "hasliked": 0,
            "id": "XtdyW2",
            "likes": 95,
            "name": "Blue Noise Generator",
            "published": 3,
            "tags": [
                "bluenoise"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 44490
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    ivec2 sz = ivec2(iResolution.xy);\n    ivec2 px = ivec2(fragCoord);\n   \tfloat v_ref = texelFetch(iChannel1, ivec2(fragCoord)/1 % ivec2(iChannelResolution[1].xy), 0).r;\n#if 0\n    float v = texelFetch(iChannel0, px, 0).r;    \n    float v_old = texelFetch(iChannel2, px, 0).r;\n    if (uv.x > 0.5) {\n        fragColor = vec4(v_ref,v_ref,v_ref,1.0);\n    } else if (v != v_old) {\n        fragColor = vec4(1.0,0.0,0.0,1.0);\n    } else {\n\t\tfragColor = vec4(v,v,v,1.0);\n    }\n#else\n    float v = texelFetch(iChannel0, px, 0).r;    \n#if 0\n    vec2 s0_x0 = quantify_error(iChannel0, px, sz, v, v);\n    if (uv.x > 0.5) {\n    v = s0_x0.x * 1.0;\n    }\n#endif\n\n#if 0\n    if (uv.x > 0.5) {\n        v = v_ref; \n    }\n    v = step(v, uv.y);\n#endif\n    //v = step(0.999/255.0, v);\n    //v = step(v, 0.0);\n    fragColor = vec4(v, v, v, 1.0);\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// https://nullprogram.com/blog/2018/07/31/\nuint lowbias32 (uint x) {\n    x = x ^ (x >> 16u);\n    x = x * 0x7feb352du;\n    x = x ^ (x >> 15u);\n    x = x * 0x846ca68bu;\n    x = x ^ (x >> 16u);\n    return x;\n}\n\nuvec2 lowbias32(uvec2 v) {\n    return uvec2(lowbias32(v.x), lowbias32(v.y));\n}\n\n// inverse\nuint lowbias32_r (uint x) {\n    x = x ^ (x >> 16u);\n    x = x * 0x43021123u;\n    x = x ^ (x >> 15u ^ x >> 30u);\n    x = x * 0x1d69e2a5u;\n    x = x ^ (x >> 16u);\n    return x;\n}\n\nuvec2 lowbias32_r(uvec2 v) {\n    return uvec2(lowbias32_r(v.x), lowbias32_r(v.y));\n}\n\n#define R2 19\n\n#define SIGMA 1.414\n#define M_PI 3.14159265359\n\nfloat gaussian (float x, float sigma) {\n    float h0 = x / sigma;\n    float h = h0 * h0 * -0.5;\n    float a = 1.0 / (sigma * sqrt(2.0 * M_PI));\n    return a * exp(h);\n}\n\nfloat pow2(float x) {\n    return x * x;\n}\n\nfloat distf(float v, float x) {\n#if 0\n    return 1.0 - abs(x);\n#else\n    return 1.0 / (1.0 + pow2(x));\n#endif\n}\n\nstruct line {\n    float v[5];\n};\n\nvec2 quantify_error (sampler2D channel, ivec2 p, ivec2 sz, float val0, float val1) {\n#if 1\n    float Rf = float(R2) / 2.0;\n    int R = int(Rf);\n    float has0 = 0.0;\n    float has1 = 0.0;\n    float w = 0.0;\n\n    //vec2 g = vec2(0.0, 1.0);\n    for (int sy = -R; sy <= R; ++sy) {\n        for (int sx = -R; sx <= R; ++sx) {\n            float d = length(vec2(sx,sy));\n            if ((d > Rf) || ((sx == 0) && (sy == 0)))\n                continue;\n            ivec2 t = (p + ivec2(sx,sy) + sz) % sz;            \n\t\t\tfloat v = texelFetch(channel, t, 0).r;\n            //g += vec2(v, 1.0);\n\n            float dist0 = (v - val0);\n            float dist1 = (v - val1);\n\n            float q = gaussian(d, SIGMA);\n\n            w += q;            \n            has0 += distf(val0, dist0) * q;\n            has1 += distf(val1, dist1) * q;\n            \n        }\n    }\n    //vec2 avg = vec2(g.x + val0, g.x + val1) / g.y - 0.5;\n\n    vec2 result = vec2(has0, has1) / w;\n    //result = result * result;\n    return result;\n#else\n    // FastNoise-inspired filter variance check\n#define FETCH(OX, OY) texelFetch(channel, (p + ivec2((OX),(OY))) % sz, 0).r\n    line lines[5];\n    // cache\n    for (int sy = -2; sy <= 2; ++sy) {\n        for (int sx = -2; sx <= 2; ++sx) {\n            lines[sy + 2].v[sx + 2] = FETCH(sx, sy);\n        }\n    }\n\n    mat3 coeffs = mat3(\n        1.0, 2.0, 1.0,\n        2.0, 4.0, 2.0,\n        1.0, 2.0, 1.0\n    ) / 16.0;\n\n    lines[2].v[2] = val0;\n    float err[2] = float[](0.0, 0.0);\n    for (int i = 0; i < 2; ++i) {\n        // collect error of all neighboring filter kernels\n        for (int sy = 0; sy < 3; ++sy) {\n            for (int sx = 0; sx < 3; ++sx) {\n\n                float acc = 0.0;\n                // average\n                for (int my = 0; my < 3; ++my) {\n                    for (int mx = 0; mx < 3; ++mx) {\n                        acc += lines[sy + my].v[sx + mx] * coeffs[my][mx];\n                    }\n                }           \n                // variance\n                float vr = 0.0;\n                for (int my = 0; my < 3; ++my) {\n                    for (int mx = 0; mx < 3; ++mx) {\n                        float x = (lines[sy + my].v[sx + mx] - acc);\n                        vr += x * x;\n                    }\n                }\n                acc = (acc - 0.5) * (acc - 0.5);\n                err[i] += acc + 1.0 / (1.0 + vr);\n            }\n        }\n        lines[2].v[2] = val1;\n    }\n    return vec2(err[0], err[1]);\n#endif\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nivec2 flip(ivec2 p, uvec2 mask) {\n    return ivec2(lowbias32_r(lowbias32(uvec2(p)) ^ mask));\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 sz = ivec2(iChannelResolution[0].xy);\n    ivec2 p0 = ivec2(fragCoord);\n    uvec2 mask = uvec2(lowbias32(uint(iFrame)));\n    int M = 10 * 60;\n    int F = (iFrame % M);\n    float framef = float(F) / float(M);\n    const float CHANCE_LIMIT = 0.618; // try to swap 62% of pixels\n    if (F == 0) {\n        int c = (p0.x * 61 + p0.y) % 256;\n        fragColor = vec4(float(c) / 255.0, 0.0, 0.0, 1.0);\n    } else {\n        ivec2 p1 = flip(p0, mask);\n        ivec2 pp0 = flip(p1, mask) % sz;\n        p1 = p1 % sz;\n\n        float chance0 = hash13(vec3(p0, float(iFrame)));\n        float chance1 = hash13(vec3(p1, float(iFrame)));\n        float chance = max(chance0, chance1);\n        \n        float v0 = texelFetch(iChannel0, p0, 0).r;\n        float v1 = texelFetch(iChannel0, p1, 0).r;\n        \n        vec2 s0_x0 = quantify_error(iChannel0, p0, sz, v0, v1);\n        vec2 s1_x1 = quantify_error(iChannel0, p1, sz, v1, v0);\n        \n        float err_s = s0_x0.x + s1_x1.x;\n        float err_x = s0_x0.y + s1_x1.y;\n        \n        float p = v0;\n        if ((chance < CHANCE_LIMIT) && (err_x < err_s)) {\n            p = v1;\n        }\n        fragColor = vec4(p, 0.0, 0.0, 1.0);\n    }\n}                        \n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}