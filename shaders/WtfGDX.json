{
    "Shader": {
        "info": {
            "date": "1559137994",
            "description": "Utilizing a 2D simplex grid to construct the isolines of a noise function.",
            "flags": 0,
            "hasliked": 0,
            "id": "WtfGDX",
            "likes": 348,
            "name": "Triangle Grid Contouring",
            "published": 3,
            "tags": [
                "grid",
                "triangle",
                "marching",
                "contour"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 15766
        },
        "renderpass": [
            {
                "code": "/*\n\n\n\tTriangle Grid Contouring\n\t------------------------\n\n\tUsing a 2D simplex grid to construct the isolines of a 2D field function, namely\n    gradient noise. I'm not entirely sure what to call the process. Since it's the \n\ttriangular version of the marching squares algorithm, you'd think it'd be called \n\t\"marching triangles,\" but that term is used to describe grid point cloud related \n    triangulation. Therefore, \"triangle grid contouring\" will do. :)\n\n\tI've been coding up some Wang tile related patterns on square grids lately, which got \n\tme thinking about attempting the same on a triangle grid. Whilst doing that, I got \n\tsidetracked and wondered what contour lines created with the triangular equivalent of \n\ta marching squares algorithm would look like, and here we are. :)\n\n    I put this together for novelty purposes, but I'd imagine there'd be some practical \n\taspects associated with it; Vector contour point lists would be an obvious one, and\n\tto a lesser extent, triangulated height maps. However, rendering smooth curves would\n\tbe one of the main benefits. Only one unique linear interpolant is rendered through \n\teach triangle, which means that Bezier point information via neighboring triangles \n\twith shared edges would be easy to obtain.... I might demonstrate that at a later \n\tdate, but for now, a novel proof of concept will do.\n\t \n \n*/\n\n// If you were rendering from a vertex shader, or just pushing out a triangle list \n// in general, then you'd need to triangulate the triangles that have been split into \n// quads. The process is almost trivial with just one contour, and slightly more \n// involved with two, but not too difficult. Anyway, here's a visual representation.\n// Aesthetically, I kind of like it, but it's a little busy, so is off by default.\n//#define TRIANGULATE_CONTOURS\n\n// Filling the cells with a concentric triangle pattern. I couldn't decide whether\n// to include it, or not, so it's here as an option.\n#define TRIANGLE_PATTERN\n\n// Render green grass on the terrain. Uncommented leaves dry terrain.\n#define GRASS\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Standard vec2 to float hash - Based on IQ's original.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.13, 289.97)))*43758.5453); }\n\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    //return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n);\n    return sin(p*6.2831853 + iTime); \n    \n}\n\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22(i), p);\n    v.y = dot(hash22(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22(i + 1.), p - 1.);\n\n#if 1\n    // Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    //return v.x + p.x*(v.y - v.x) + p.y*(v.z - v.x) + p.x*p.y*(v.x - v.y - v.z + v.w);\n}\n\n\n// The isofunction. Just a single noise function, but it can be more elaborate.\nfloat isoFunction(in vec2 p){ return n2D3G(p/4. + .07); }\n\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 a, vec2 b){\n    \n     \n\tb = a - b;\n\tfloat h = clamp(dot(a, b)/dot(b, b), 0., 1.);\n    return length(a - b*h);\n}\n\n\n// Based on IQ's signed distance to the segment joining \"a\" and \"b\".\nfloat distEdge(vec2 a, vec2 b){\n    \n    //if(abs(dot(a, a) - dot(b, b))>1e-5) \n    \n\n    \n    return dot((a + b)*.5, normalize((b - a).yx*vec2(-1, 1)) );\n    //else return 1e5;\n \n}\n\n \n\n// Interpolating along the edge connecting vertices v1 and v2 with respect to the isovalue.\nvec2 inter(in vec2 p1, in vec2 p2, float v1, float v2, float isovalue){\n     \n    // The interpolated point will fall somewhere between the vertex points p1 and p2.\n    // Obviously if the isovalue is closer to p1, then the interpolated point will be\n    // closer to p1, and vice versa.\n    //\n    // If you're wondering about the weird numerical hacks on the end, it's a fudge keep the \n    // lines away from the triangle edges. Because this is a per grid cell implementation,\n    // there's neighboring cell overlap to deal with, which basically means rendering more\n    // cells. Typically, that's not particularly difficult to deal with, but can be slower.\n    // Either way, I wanted to keep things simple... and I'm lazy. Hence, the fugde. :)\n    return mix(p1, p2, (isovalue - v1)/(v2 - v1)*.75 + .25/2.); \n    \n    // The mix bit -- without the numberical hacks -- is equivalent to:\n    //return p1 + (isovalue - v1)/(v2 - v1)*(p2 - p1);\n    \n    // This is probably more correct, but we seem to be getting away with the line above.\n    //float inter = v1 == v2 ? .5 : (isovalue - v1) /(v2 - v1); \n    //return mix(p1, p2, inter);\n}\n\n// Isoline function.\nint isoLine(vec3 n3, vec2 ip0, vec2 ip1, vec2 ip2, float isovalue, float i, \n          inout vec2 p0, inout vec2 p1){\n    \n    \n    // Points where the lines cut the edges.\n    p0 = vec2(1e5), p1 = vec2(1e5);\n    \n    // Marching triangles.. Is that a thing? Either way, it's similar to marching\n    // squares, but with triangles. In other words, obtain the underlying function\n    // value at all three vertices of the triangle cell, compare them to the \n    // isovalue (over or under), then render a line between the corresponding edges.\n    //\n    // The line cuts each edge in accordance with the isovalues at each edge, which\n    // means interpolating between the two.\n    \n    // Bitwise accumulation to produce a unique index number upon which to make \n    // decisions. It's a pretty standard technique.\n    //\n    // Minumum threshold value... It's an ID, of sorts.\n    int iTh = 0;\n    //\n    // If the first vertex is over the isovalue threshold, add four, etc.\n    if(n3.x>isovalue) iTh += 4;\n    if(n3.y>isovalue) iTh += 2;\n    if(n3.z>isovalue) iTh += 1;\n    \n    \n    // A value of 1 or 6 means constructing a line between the\n    // second and third edges, and so forth.\n    if(iTh == 1 || iTh == 6){ // 12-20         \n        \n        p0 = inter(ip1, ip2, n3.y, n3.z, isovalue); // Edge two.\n        p1 = inter(ip2, ip0, n3.z, n3.x, isovalue); // Edge three.\n     \n    }\n    else if(iTh == 2 || iTh == 5){ // 01-12 \n        \n        p0 = inter(ip0, ip1, n3.x, n3.y, isovalue); // Edge one.\n        p1 = inter(ip1, ip2, n3.y, n3.z, isovalue); // Edge two.\n        \n    }\n    else if(iTh == 3 || iTh == 4){ // 01-20 \n        \n        p0 = inter(ip0, ip1, n3.x, n3.y, isovalue); // Edge one.\n        p1 = inter(ip2, ip0, n3.z, n3.x, isovalue); // Edge three.       \n        \n    }\n     \n    \n    // For the last three cases, we're after the other side of\n    // the line, and this is a quick way to do that. Uncomment\n    // to see why it's necessary.\n    if(iTh>=4 && iTh<=6){ vec2 tmp = p0; p0 = p1; p1 = tmp; }\n    \n    // Just to make things more confusing, it's necessary to flip coordinates on \n    // alternate triangles, due to the simplex grid triangle configuration. This \n    // line basically represents an hour of my life that I won't get back. :D\n    if(i == 0.){ vec2 tmp = p0; p0 = p1; p1 = tmp; }\n    \n    \n    // Return the ID, which will be used for rendering purposes.\n    return iTh;\n \n    \n}\n\n/*\nvec3 softLight(vec3 s, vec3 d){\n\n    vec3 a = d - (1. - 2.*s)*d*(1. - d), b = d + (2.*s - 1.)*d*((16.*d - 12.)*d + 3.), \n         c = d + (2.*s - 1.)*(sqrt(d) - d);\n    \n    return vec3(s.x<.5? a.x : d.x<.25? b.x : c.x, s.y<.5? a.y : d.y<.25? b.y : c.y,\n    \t\t\ts.z<.5? a.z : d.z<.25? b.z : c.z);\n\t\n}\n*/\n\nvec3 simplexContour(vec2 p){\n    \n    \n    \n    // Scaling constant.\n    const float gSc = 8.;\n    p *= gSc;\n    \n    \n    // Keeping a copy of the orginal position.\n    vec2 oP = p;\n    \n    // Wobbling the coordinates, just a touch, in order to give a subtle hand drawn appearance.\n    p += vec2(n2D3G(p*3.5), n2D3G(p*3.5 + 7.3))*.015;\n\n    \n    \n    // SIMPLEX GRID SETUP\n    \n    vec2 s = floor(p + (p.x + p.y)*.36602540378); // Skew the current point.\n    \n    p -= s - (s.x + s.y)*.211324865; // Use it to attain the vector to the base vertex (from p).\n    \n    // Determine which triangle we're in. Much easier to visualize than the 3D version.\n    float i = p.x < p.y? 1. : 0.; // Apparently, faster than: i = step(p.y, p.x);\n    vec2 ioffs = vec2(1. - i, i);\n    \n    // Vectors to the other two triangle vertices.\n    vec2 ip0 = vec2(0), ip1 = ioffs - .2113248654, ip2 = vec2(.577350269); \n    \n    \n    // Centralize everything, so that vec2(0) is in the center of the triangle.\n    vec2 ctr = (ip0 + ip1 + ip2)/3.; // Centroid.\n    //\n    ip0 -= ctr; ip1 -= ctr; ip2 -= ctr; p -= ctr;\n     \n     \n     \n    // Take a function value (noise, in this case) at each of the vertices of the\n    // individual triangle cell. Each will be compared the isovalue. \n    vec3 n3;\n    n3.x = isoFunction(s);\n    n3.y = isoFunction(s + ioffs);\n    n3.z = isoFunction(s + 1.);\n    \n    \n    // Various distance field values.\n    float d = 1e5, d2 = 1e5, d3 = 1e5, d4 = 1e5, d5 = 1e5; \n  \n    \n    // The first contour, which separates the terrain (grass or barren) from the beach.\n    float isovalue = 0.;\n    \n    // The contour edge points that the line will run between. Each are passed into the\n    // function below and calculated.\n    vec2 p0, p1; \n    \n    // The isoline. The edge values (p0 and p1) are calculated, and the ID is returned.\n    int iTh = isoLine(n3, ip0, ip1, ip2, isovalue, i, p0, p1);\n      \n    // The minimum distance from the pixel to the line running through the triangle edge \n    // points.\n    d = min(d, distEdge(p - p0, p - p1)); \n    \n    \n    \n    //if(iTh == 0) d = 1e5;\n    \n    // Totally internal, which means a terrain (grass) hit.\n    if(iTh == 7){ // 12-20  \n \t\t\n        // Triangle.\n        //d = min(min(distEdge(p - ip0, p - ip1), distEdge(p - ip1, p - ip2)), \n                  //distEdge(p - ip0, p - ip2));\n        \n        // Easier just to set the distance to a hit.\n        d = 0.;\n    } \n    \n \n    \n    // Contour lines.\n    d3 = min(d3, distLine((p - p0), (p - p1))); \n    // Contour points.\n    d4 = min(d4, min(length(p - p0), length(p - p1))); \n    \n    \n    \n    \n    \n    // Displaying the 2D simplex grid. Basically, we're rendering lines between\n    // each of the three triangular cell vertices to show the outline of the \n    // cell edges.\n    float tri = min(min(distLine(p - ip0, p - ip1), distLine(p - ip1, p - ip2)), \n                  distLine(p - ip2, p - ip0));\n    \n    // Adding the triangle grid to the d5 distance field value.\n    d5 = min(d5, tri);\n     \n    \n    // Dots in the centers of the triangles, for whatever reason. :) Take them out, if\n    // you prefer a cleaner look.\n    d5 = min(d5, length(p) - .02);   \n    \n    ////////\n    #ifdef TRIANGULATE_CONTOURS\n    vec2 oldP0 = p0;\n    vec2 oldP1 = p1;\n\n    // Contour triangles: Flagging when the triangle cell contains a contour line, or not.\n    float td = (iTh>0 && iTh<7)? 1. : 0.;\n    \n    // Subdivide quads on the first contour.\n    if(iTh==3 || iTh==5 || iTh==6){\n\n        // Grass (non-beach land) only quads.\n        vec2 pt = p0;\n        if(i==1.) pt = p1;\n        d5 = min(d5, distLine((p - pt), (p - ip0))); \n        d5 = min(d5, distLine((p - pt), (p - ip1)));  \n        d5 = min(d5, distLine((p - pt), (p - ip2))); \n    }\n    #endif\n    ////////\n    \n \n    // The second contour: This one demarcates the beach from the sea.\n    isovalue = -.15;\n   \n    // The isoline. The edge values (p0 and p1) are calculated, and the ID is returned.\n    int iTh2 = isoLine(n3, ip0, ip1, ip2, isovalue, i, p0, p1);\n   \n    // The minimum distance from the pixel to the line running through the triangle edge \n    // points.   \n    d2 = min(d2, distEdge(p - p0, p - p1)); \n    \n    // Make a copy.\n    float oldD2 = d2;\n    \n    if(iTh2 == 7) d2 = 0.; \n    if(iTh == 7) d2 = 1e5;\n    d2 = max(d2, -d);\n\n     \n    // Contour lines - 2nd (beach) contour.\n    d3 = min(d3, distLine((p - p0), (p - p1)));\n    // Contour points - 2nd (beach) contour.\n    d4 = min(d4, min(length(p - p0), length(p - p1))); \n                \n    d4 -= .075;\n    d3 -= .0125;\n     \n    ////////\n    #ifdef TRIANGULATE_CONTOURS\n    // Triangulating the contours.\n    \n    // This logic was put in at the last minute, and isn't my finest work. :)\n    // It seems to work, but I'd like to tidy it up later. \n\n    // Flagging when the triangle contains a second contour line, or not.\n    float td2 = (iTh2>0 && iTh2<7)? 1. : 0.;\n     \n    \n    if(td==1. && td2==1.){\n        // Both contour lines run through a triangle, so you need to do a little more\n        // subdividing. \n        \n        // The beach colored quad between the first contour and second contour.\n        d5 = min(d5, distLine(p - p0, p - oldP0)); \n        d5 = min(d5, distLine(p - p0, p - oldP1));  \n        d5 = min(d5, distLine(p - p1, p - oldP1));\n         \n        // The quad between the water and the beach.\n        if(oldD2>0.){\n            vec2 pt = p0;\n            if(i==1.) pt = p1;\n            d5 = min(d5, distLine(p - pt, p - ip0)); \n            d5 = min(d5, distLine(p - pt, p - ip1));  \n            d5 = min(d5, distLine(p - pt, p - ip2)); \n        }\n    }   \n    else if(td==1. && td2==0.){\n        \n        // One contour line through the triangle.\n        \n        // Beach and grass quads.\n        vec2 pt = oldP0;\n        if(i==1.) pt = oldP1;\n        d5 = min(d5, distLine(p - pt, p - ip0)); \n        d5 = min(d5, distLine(p - pt, p - ip1));  \n        d5 = min(d5, distLine(p - pt, p - ip2)); \n    }\n    else if(td==0. && td2==1.){ \n        \n        // One contour line through the triangle.\n        \n        // Beach and water quads.\n        vec2 pt = p0;\n        if(i==1.) pt = p1;\n        d5 = min(d5, distLine(p - pt, p - ip0)); \n        d5 = min(d5, distLine(p - pt, p - ip1));  \n        d5 = min(d5, distLine(p - pt, p - ip2));  \n    }\n    \n    #endif\n    ////////\n    \n    \n    // The screen coordinates have been scaled up, so the distance values need to be\n    // scaled down.\n    d /= gSc;\n    d2 /= gSc;\n    d3 /= gSc;\n    d4 /= gSc;    \n    d5 /= gSc; \n    \n    \n    \n    // Rendering - Coloring.\n        \n    // Initial color.\n    vec3 col = vec3(1, .85, .6);\n    \n    // Smoothing factor.\n    float sf = .004; \n   \n    // Water.\n    if(d>0. && d2>0.) col = vec3(1, 1.8, 3)*.45;\n     // Water edging.\n    if(d>0.) col = mix(col, vec3(1, 1.85, 3)*.3, (1. - smoothstep(0., sf, d2 - .012)));\n    \n    // Beach.\n    col = mix(col, vec3(1.1, .85, .6),  (1. - smoothstep(0., sf, d2)));\n    // Beach edging.\n    col = mix(col, vec3(1.5, .9, .6)*.6, (1. - smoothstep(0., sf, d - .012)));\n    \n    #ifdef GRASS\n    // Grassy terrain.\n    col = mix(col, vec3(1, .8, .6)*vec3(.7, 1., .75)*.95, (1. - smoothstep(0., sf, d))); \n    #else\n    // Alternate barren terrain.\n    col = mix(col, vec3(1, .82, .6)*.95, (1. - smoothstep(0., sf, d))); \n    #endif \n    \n   \n     \n \n    // Abstract shading, based on the individual noise height values for each triangle.\n    if(d2>0.) col *= (abs(dot(n3, vec3(1)))*1.25 + 1.25)/2.;\n    else col *= max(2. - (dot(n3, vec3(1)) + 1.45)/1.25, 0.);\n    \n    // More abstract shading.\n    //if(iTh!=0) col *= float(iTh)/7.*.5 + .6;\n    //else col *= float(3.)/7.*.5 + .75;\n\n    \n    ////////\n    #ifdef TRIANGULATE_CONTOURS\n    //if(td==1. || td2==1.) col *= vec3(1, .4, .8); \n    #endif\n    ////////\n    \n    ////////\n    #ifdef TRIANGLE_PATTERN\n    // A concentric triangular pattern.\n    float pat = abs(fract(tri*12.5 + .4) - .5)*2.;\n    col *= pat*.425 + .75; \n    #endif\n    ////////\n    \n \n    \n    \n    // Triangle grid overlay.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d5))*.95);\n    \n     \n    \n    // Lines.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d3)));\n    \n    \n    // Dots.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d4)));\n    col = mix(col, vec3(1), (1. - smoothstep(0., sf, d4 + .005)));\n  \n  \n    \n    // Rough pencil color overlay... The calculations are rough... Very rough, in fact, \n    // since I'm only using a small overlayed portion of it. Flockaroo does a much, much \n    // better pencil sketch algorithm here:\n    //\n    // When Voxels Wed Pixels - Flockaroo \n    // https://www.shadertoy.com/view/MsKfRw\n    //\n    // Anyway, the idea is very simple: Render a layer of noise, stretched out along one \n    // of the directions, then mix a similar, but rotated, layer on top. Whilst doing this,\n    // compare each layer to it's underlying grey scale value, and take the difference...\n    // I probably could have described it better, but hopefully, the code will make it \n    // more clear. :)\n    // \n    // Tweaked to suit the brush stroke size.\n    vec2 q = oP*1.5;\n    // I always forget this bit. Without it, the grey scale value will be above one, \n    // resulting in the extra bright spots not having any hatching over the top.\n    col = min(col, 1.);\n    // Underlying grey scale pixel value -- Tweaked for contrast and brightness.\n    float gr = sqrt(dot(col, vec3(.299, .587, .114)))*1.25;\n    // Stretched fBm noise layer.\n    float ns = (n2D3G(q*4.*vec2(1./3., 3))*.64 + n2D3G(q*8.*vec2(1./3., 3))*.34)*.5 + .5;\n    // Compare it to the underlying grey scale value.\n    ns = gr - ns;\n    //\n    // Repeat the process with a rotated layer.\n    q *= rot2(3.14159/3.);\n    float ns2 = (n2D3G(q*4.*vec2(1./3., 3))*.64 + n2D3G(q*8.*vec2(1./3., 3))*.34)*.5 + .5;\n    ns2 = gr - ns2;\n    //\n    // Mix the two layers in some way to suit your needs. Flockaroo applied common sense, \n    // and used a smooth threshold, which works better than the dumb things I was trying. :)\n    ns = smoothstep(0., 1., min(ns, ns2)); // Rough pencil sketch layer.\n    //\n    // Mix in a small portion of the pencil sketch layer with the clean colored one.\n    col = mix(col, col*(ns + .35), .4);\n    // Has more of a colored pencil feel. \n    //col *= vec3(.8)*ns + .5;    \n    // Using Photoshop mixes, like screen, overlay, etc, gives more visual options. Here's \n    // an example, but there's plenty more. Be sure to uncomment the \"softLight\" function.\n    //col = softLight(col, vec3(ns)*.75);\n    // Uncomment this to see the pencil sketch layer only.\n    //col = vec3(ns);\n    \n    \n    /*\n    // Just some line overlays.\n    vec2 pt = p;\n    float offs = -.5;\n    if(i<.5) offs += 2.;//pt.xy = -pt.xy;\n    pt = rot2(6.2831/3.)*pt;\n    float pat2 = clamp(cos(pt.x*6.2831*14. - offs)*2. + 1.5, 0., 1.);\n    col *= pat2*.4 + .8;\n    */\n    \n    \n    // Cheap paper grain.\n    //oP = floor(oP/gSc*1024.);\n    //vec3 rn3 = vec3(hash21(oP), hash21(oP + 2.37), hash21(oP + 4.83));\n    //col *= .9 + .1*rn3.xyz  + .1*rn3.xxx;\n\n    \n    // Return the simplex weave value.\n    return col;\n \n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates. I've put a cap on the fullscreen resolution to stop\n    // the pattern looking too blurred out.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/min(650., iResolution.y);\n   \n    // Position with some scrolling, and screen rotation to level the pattern.\n    vec2 p = rot2(3.14159/12.)*uv + vec2(.8660254, .5)*iTime/16.; \n    \n    // The simplex grid contour map... or whatever you wish to call it. :)\n    vec3 col = simplexContour(p);\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625) + .1;\n    // Colored variation.\n    //col = mix(col.zyx/2., col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));\n\n  \t\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}