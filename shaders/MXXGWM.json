{
    "Shader": {
        "info": {
            "date": "1707512069",
            "description": "The sum of distances (put through a distribution function) of randomly placed circles approaches coherent noise.\nSort of based on CMBR stuff I was watching.\nLet me know what you think :-]",
            "flags": 0,
            "hasliked": 0,
            "id": "MXXGWM",
            "likes": 8,
            "name": "Sum of distances of circles",
            "published": 3,
            "tags": [
                "noise"
            ],
            "usePreview": 0,
            "username": "Rugg0064",
            "viewed": 163
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;\n// Adapted for 2D\nvec2 hash2( uvec2 x )\n{\n    x = ((x>>8U)^x.yx)*k;\n    x = ((x>>8U)^x.yx)*k;\n    return vec2(x)*(1.0/float(0xffffffffU));\n}\n// Straight copy\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n// Grid boxing optimization stuff\nivec2 positions2[3*3];\nvoid initializePositions2() {\n    int i = 0;\n    for(int x = -1; x <= 1; x++ ){\n        for(int y = -1; y <= 1; y++ ){\n            positions2[i] = ivec2(x, y);\n            i++;\n        }   \n    }\n}\nivec2 getGridCoordinate2(vec2 position, float gridSize) {\n    return ivec2(floor(position/gridSize));\n}\nvec2 gridToRealPoint2(ivec2 gridCoordinate, float gridSize) {\n    return vec2(gridCoordinate) * gridSize;\n}\n\n// Kinda sorta match the drawings here\n// https://adh-sj.info/bao_cmb.php\nfloat redDist(float x) {\n    if(x < 0.0 || x > 1.0) {\n        return 0.0;\n    }\n    // Just looks about right\n    return min((sin(pow(x, 4.0) * 5.0) + 1.0) / 2.0, 1.4*x);\n}\nfloat greenDist(float x) {\n    if(x < 0.0 || x > 1.0) {\n        return 0.0;\n    }\n    return redDist(x) * 1.5;\n}\nfloat blueDist(float x) {\n    if(x < 0.0 || x > 1.0) {\n        return 0.0;\n    }\n    return (sin(x*1.5*PI)+1.0)/2.0;\n}\nvec3 vec3Dist(float x) {\n    return vec3(redDist(x), greenDist(x), blueDist(x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 position = vec2(fragCoord) + vec2(iTime*150.0, 0);\n\n    float shellRadius = 60.0;\n    float gridSize = 100.0;\n\n    int pointMultiplier = 100;\n    int pointCount = 1 + int((cos(iTime+2.7)+1.0) * 40.0);\n\n    initializePositions2();\n    ivec2 gridCoordinate = getGridCoordinate2(position, gridSize);\n    vec3 sum = vec3(0, 0, 0);\n    for(int gridIndex = 0; gridIndex < 9; gridIndex++) {\n        for(int i = 0; i < pointCount; i++) {\n            ivec2 currentGridCoordinate = gridCoordinate + positions2[gridIndex];\n            uvec2 currentGridCoordinateScaled = uvec2(currentGridCoordinate * pointMultiplier);\n            uvec2 newGridCoord = uvec2(currentGridCoordinateScaled) + uvec2(i, 0);\n            vec2 hash = hash2(newGridCoord) * gridSize;\n            vec2 circlePosition = gridToRealPoint2(currentGridCoordinate, gridSize) + hash;\n            float circleDistance = distance(position, circlePosition);\n            sum += vec3Dist(circleDistance / shellRadius);\n        }\n    }\n    sum /= float(pointCount)*1.5;\n    fragColor = vec4(sum, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}