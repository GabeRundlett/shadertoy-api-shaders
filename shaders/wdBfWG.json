{
    "Shader": {
        "info": {
            "date": "1590694726",
            "description": "It's a music visualizer that's made of meat!\n\nStarted as a modification of https://www.shadertoy.com/view/3sBGzm\n\nResponds to mouse interaction",
            "flags": 0,
            "hasliked": 0,
            "id": "wdBfWG",
            "likes": 2,
            "name": "more time in meat-space",
            "published": 3,
            "tags": [
                "raycast",
                "music",
                "subsurface",
                "flesh"
            ],
            "usePreview": 0,
            "username": "mds2",
            "viewed": 447
        },
        "renderpass": [
            {
                "code": "#define MAX_DIST 4.0\n\n#define LINEAR_STRIATIONS 0 // looks better with 0, faster with 1\n\n#define SUBSAMPLE 0 // set to 1 for subsampling\n\nconst float inv_subsurface_thick = 75.0; // make it bigger to make a smaller subsurface\n\nconst float tor_rad = 0.5;\nvec2 box_size = vec2(0.075, 0.065);\n\n\nconst float round_size = 0.1;\n\nconst vec3 refl_color = vec3(1.0); // vec3(1.0, 0.6, 0.3); // \nconst vec3 diff_color = vec3(0.8, 0.7, 0.6); // vec3(0.2, 1.0, 0.8); // vec3(0.8, 0.2, 0.2); // \nconst vec3 subsurf_color = vec3(1.0, 0.5, 0.4); // vec3(0.8, 0.6, 0.4);\nconst float specular_intense = 0.5;\n\nvec3 light_dir = vec3(0.8, 0.6, 0.0);\nvec3 cut_dir_1 = vec3(0.0, 0.0, 1.0);\nvec3 cut_dir_2 = vec3(0.0, 0.0, 1.0);\n\nmat3 twist;\n\nfloat dist_to_mouse = 0.0;\n\nfloat s_min(in float x, in float y, in float s) {\n\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return min(x,y) - 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\nfloat s_max(in float x, in float y, in float s) {\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return max(x,y) + 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\n\nvec2 sdf_ring(in vec3 pt) {\n    vec2 tor_coord = abs(vec2(length(pt.xz) - tor_rad, pt.y));\n    tor_coord = max(vec2(0.0), tor_coord - box_size);\n#if !LINEAR_STRIATIONS\n    float theta = mod(abs(0.125 * atan(pt.x, pt.z) / 3.141592654), 1.0);\n#else    \n    float theta = 0.5 + 0.125 * pt.x / tor_rad;\n#endif\n    \n    const float music_texture_y = 0.0;\n#if 1\n    const float blur_step = 0.25 / 1024.0;\n    float blur_sound = 0.25 * (texture(iChannel0, vec2(theta - 2.0 * blur_step, music_texture_y)).r +\n                               texture(iChannel0, vec2(theta - blur_step, music_texture_y)).r +\n                               texture(iChannel0, vec2(theta + blur_step, music_texture_y)).r +\n                               texture(iChannel0, vec2(theta + 2.0 * blur_step, music_texture_y)).r);\n    float sound = blur_sound - 0.5;\n#else \n    float sound = texture(iChannel0, vec2(theta, music_texture_y)).r - 0.5;\n#endif\n    return vec2(length(tor_coord) - round_size - 1.25 * round_size * sound, 1.0 + 2.0 * sound);\n}\n\nfloat sdf(in vec3 pt) {\n    float bumps = 0.0;\n    float bump_size = 0.001;\n    vec2 sdf_and_bumpscale = sdf_ring(pt);\n    float s = sdf_and_bumpscale.x;\n    bump_size *= sdf_and_bumpscale.y;\n    s += 75.0 * bump_size * smoothstep(0.25 * iResolution.y, 0.05 * iResolution.y, dist_to_mouse);\n    if (s < 5.0 * bump_size) {\n        bumps = bump_size * dot(sin(80.0 * pt), vec3(1.0));\n    }\n    return s + bumps;\n}\n\nvec3 sdf_grad(in vec3 pt) {\n    const float h = 0.001;\n    const float h_inv = 1000.0;\n    float f = sdf(pt);\n    return h_inv * vec3(sdf(pt + vec3(h, 0.0, 0.0)) - f,\n                        sdf(pt + vec3(0.0, h, 0.0)) - f,\n                        sdf(pt + vec3(0.0, 0.0, h)) - f);\n}\n\nvec3 norm_perturb(in vec3 pt) {\n    const float rad_2_unit = 1.0 / (2.0 * 3.141592654);\n    float ang1 = atan(pt.x, pt.z) * rad_2_unit;\n    vec2 about = vec2(length(pt.xz) - tor_rad, pt.y);\n    float ang2 = atan(about.y, about.x) * rad_2_unit;\n    const float scale = 3.0;\n    vec3 bmp = normalize(noise3(55.0 * pt, 12.7));\n    return 0.2 * bmp;\n}\n\nvec3 zero_norm_perturb(in vec3 pt) {\n    return vec3(0.0);\n}\n\nvec3 grid_norm_perturb(in vec3 pt) {\n    vec2 uv1 = mod(3.0 * pt.xy, vec2(1.0));\n    vec2 uv2 = mod(3.0 * pt.yz, vec2(1.0));\n    vec2 uv3 = mod(3.0 * pt.zx, vec2(1.0));\n    return texture(iChannel2, uv1).rgb - vec3(0.5) +\n        texture(iChannel2, uv2).rgb - vec3(0.5) +\n        texture(iChannel2, uv3).rgb - vec3(0.5);\n}\n\nfloat ray_cast(in vec3 o, in vec3 dir) {\n    float accum = 0.0;\n    float val = sdf(o);\n    vec3 pt = o;\n    for (int i = 0; i < 512; ++i) {\n        accum += 0.5 * val;\n        pt = o + accum * dir;\n        val = sdf(pt);\n        if (accum > MAX_DIST || val < 1.0e-3) {\n            return accum;\n        }\n    }\n    return MAX_DIST + 1.0;\n}\n\nfloat cast_out(in vec3 o, in vec3 dir) {\n    float accum = 0.0;\n    float val = sdf(o);\n    vec3 pt = o;\n    for (int i = 0; i < 128; ++i) {\n        accum += max(0.95 * abs(val), 5.0e-4);\n        pt = o + accum * dir;\n        val = sdf(pt);\n        if (accum > 1.0e-3 && val > -1.0e-3) {\n            return accum;\n        }\n    }\n    return MAX_DIST + 1.0;\n}\n\nvec4 color_at(in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    \n    dist_to_mouse = length(fragCoord.xy - iMouse.xy);\n    \n    vec3 dir = normalize(vec3(uv, -2.0));\n    vec3 orig = vec3(0.0, 0.0, 1.0);\n    \n    float theta = 0.3;\n    vec2 angles = cos(theta + vec2(0.0, 0.5 * 3.141592654));\n    mat3 tilt = mat3(1.0, 0.0, 0.0,\n                     0.0, angles.x, angles.y,\n                     0.0, -angles.y, angles.x);\n    orig = twist * tilt * orig;\n    dir = twist * tilt * dir;\n\n    float dist = ray_cast(orig, dir);\n    \n    vec3 col = vec3(1.0 / dist);\n\n    if (dist < MAX_DIST) {\n        vec3 pt = orig + dir * dist;\n\t\tvec3 n = normalize(sdf_grad(pt));\n        n = normalize(n + norm_perturb(pt));\n        vec3 bounce = normalize(reflect(dir, n));\n        vec2 weights = smoothstep(0.4, 1.9, noise2(12.0 * pt, 0.0));\n        float refl_bright = 0.2 * smoothstep(0.0, 1.0, dot(bounce, light_dir));\n        float diff_bright = 0.05 +\n            0.75 * smoothstep(0.1, 1.0, dot(n, light_dir)) + 0.25;\n        float dist_out = cast_out(pt + 1.0e-2 * dir, light_dir) +\n            0.1 * dot(light_dir, norm_perturb(pt));\n        col = (weights.x + specular_intense) * refl_bright * refl_color + diff_bright * 0.6 * diff_color;\n        col += 0.5 * weights.y * (1.0 / max(1.0, 1.0 + inv_subsurface_thick * dist_out)) * subsurf_color;\n        \n    } else {\n        col = vec3(0.0);\n    }\n    \n    // Output to screen\n\treturn vec4(col, 1.0);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float theta = 0.5 + 0.01 * mod(iTime, 200.0 * 3.14159265);\n    theta *= 2.0 * 3.141592654;\n    float ct = cos(theta);\n    float st = sin(theta);\n    \n    twist = mat3(ct, 0.0, st,\n                 0.0, 1.0, 0.0,\n                 -st, 0.0, ct);\n    \n\n    float push_pull = 3.141592654 * 0.75;\n    cut_dir_1.xz = sin(push_pull + vec2(0.5 * 3.141592654, 0.0));\n    push_pull = -push_pull;\n    cut_dir_2.xz = -sin(push_pull + vec2(0.5 * 3.141592654, 0.0));\n#if SUBSAMPLE\n    vec4 col_out = 0.25 * color_at(fragCoord);\n    const float scatter_scale = 0.8;\n    col_out += 0.25 * color_at(fragCoord + scatter_scale * vec2(0.6, 0.8));\n    col_out += 0.25 * color_at(fragCoord + scatter_scale * vec2(-1.0, 0.0));\n    col_out += 0.25 * color_at(fragCoord + scatter_scale * vec2(0.0, -1.0));\n#else\n    vec4 col_out = color_at(fragCoord);\n#endif\n    fragColor = col_out;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 19,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//The MIT License\n//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// All hash functions copied from https://www.shadertoy.com/view/Xt3cDn\n// Thanks, nimitz!\n\n//Modified from: iq's \"Integer Hash - III\" (https://www.shadertoy.com/view/4tXyWN)\n//Faster than \"full\" xxHash and good quality\nuint baseHash(uvec2 p)\n{\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\n//--------------------------------------------------\n\nfloat hash13(vec3 x)\n{\n    uint n = baseHash(floatBitsToUint(x.xy)) ^\n        baseHash(floatBitsToUint(x.yz)) ^\n        baseHash(floatBitsToUint(x.zx));\n    \n    return float(n & 0x7fffffffU)/float(0x7fffffff);\n}\n\n\nfloat noise_term(in vec3 x, in float scale_val) {\n    vec3 s = vec3(scale_val);\n    vec3 x000 = x - mod(x, s);\n    vec3 x001 = x + vec3(0.0, 0.0, scale_val);\n    x001 = x001 - mod(x001, s);\n    vec3 x010 = x + vec3(0.0, scale_val, 0.0);\n    x010 = x010 - mod(x010, s);\n    vec3 x011 = x + vec3(0.0, s.xy);\n    x011 = x011 - mod(x011, s);\n    vec3 x100 = x + vec3(scale_val, 0.0, 0.0);\n    x100 = x100 - mod(x100, s);\n    vec3 x101 = x + vec3(scale_val, 0.0, scale_val);\n    x101 = x101 - mod(x101, s);\n    vec3 x110 = x + vec3(s.xy, 0.0);\n    x110 = x110 - mod(x110, s);\n    vec3 x111 = x + s;\n    x111 = x111 - mod(x111, s);\n    \n    float v000 = hash13(x000);\n    float v001 = hash13(x001);\n    float v010 = hash13(x010);\n    float v011 = hash13(x011);\n    float v100 = hash13(x100);\n    float v101 = hash13(x101);\n    float v110 = hash13(x110);\n    float v111 = hash13(x111);\n    \n    vec3 uvw = mod(x, s) / s;\n    \n    float zweight = smoothstep(0.0, 1.0, uvw.z);\n    float v00 = mix(v000, v001, zweight);\n    float v01 = mix(v010, v011, zweight);\n    float v10 = mix(v100, v101, zweight);\n    float v11 = mix(v110, v111, zweight);\n    \n    float yweight = smoothstep(0.0, 1.0, uvw.y);\n    float v1 = mix(v10, v11, yweight);\n    float v0 = mix(v00, v01, yweight);\n    \n    float xweight = smoothstep(0.0, 1.0, uvw.x);\n    \n    return mix(v0, v1, xweight);\n}\n\nfloat noise(in vec3 x, in float base_scale, in float space_decay, in float height_decay,\n           in float shift_by) {\n\tfloat h = 1.0;\n    float s = base_scale;\n\n    float summation = 0.0;\n    \n    for (int i = 0; i < 5; ++i) {\n    \tsummation = summation + h * noise_term(x + vec3(0.0, 0.0, s * shift_by), s);\n        s *= space_decay;\n        h *= height_decay;\n    }\n    return summation;\n}\n\nfloat simple_noise(in vec3 uv, in float shift_by) {\n  return noise(uv * 10.0, 5.0, 0.75, 0.75, shift_by);\n}\n\nvec2 noise2(in vec3 uv, in float shift_by) {\n    return vec2(simple_noise(uv, shift_by),\n                simple_noise(uv + vec3(0.0, 0.0, 101.0), shift_by));\n}\n\nvec3 noise3(in vec3 uv, in float shift_by) {\n    return vec3(simple_noise(uv, shift_by),\n                simple_noise(uv + vec3(0.0, 0.0, 101.0), shift_by),\n               simple_noise(uv + vec3(0.0, 101.0, 0.0), shift_by));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}