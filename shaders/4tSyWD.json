{
    "Shader": {
        "info": {
            "date": "1510419493",
            "description": "Using the game of life to create an interesting ice field!",
            "flags": 32,
            "hasliked": 0,
            "id": "4tSyWD",
            "likes": 11,
            "name": "Iced Game Of Life",
            "published": 3,
            "tags": [
                "2d",
                "experimentation",
                "ice",
                "gameoflife",
                "stateful"
            ],
            "usePreview": 0,
            "username": "BeardThings",
            "viewed": 872
        },
        "renderpass": [
            {
                "code": "// #define OVERLAY\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat SDF(in vec3 p)\n{\n    return p.y - textureLod(iChannel0, (p.xz + 50.0) / 150.0, 0.5).r * 0.7;\n}\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float d, // camera to point distance\n               in vec3  rayDir )   // camera to point vector\n{\n    float fogAmount = 1.0 - exp( -d*0.05 );\n    vec3  fogColor  = vec3(0.5,0.8,0.9) + abs(rayDir)*0.1;\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvec3 Norm(in vec3 p, in float src)\n{\n    // Calculate the normal by calculating the gradient of the SDF\n    const float E = 0.01;\n    return normalize(vec3(\n        SDF(p + vec3(E, 0, 0)) - src,\n        SDF(p + vec3(0, E, 0)) - src,\n        SDF(p + vec3(0, 0, E)) - src));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 screenSpace = uv * 2.0 - 1.0;\n    \n    // Origin, move this around for fun ^.^\n    vec3 o = vec3(cos(iTime * 0.3) * 0.5, 2.0 + sin(iTime * 0.3) * 0.3, -3.0 + iTime);\n    \n    // Create your view basis vectors however you'd like\n    vec3 f = vec3(0.0, 0.0, 1.0);\n    vec3 u = vec3(0, 1.0, 0);\n    vec3 r = normalize(cross(u, f));\n    \n    float aspect = iResolution.y / iResolution.x;\n    float aperture = 1.0;\n    \n    // Have our forward with an aperture at 1.0 \n    // and transform our vector by it's space on the screen\n    vec3 dir = f * aperture + r * screenSpace.x + u * screenSpace.y * aspect;\n    \n    // Max step of 16 is fine for a sphere, can be higher for complex scenes\n    const int MaxSteps = 64;\n    \n    // Our final color\n    vec4 fc = vec4(0.5,0.6,0.7, 1.0);\n    \n    float dist = 0.0;\n    for(int i = 0; i < MaxSteps; ++i)\n    {\n        if(dist > 75.0)\n        {\n            break;\n        }\n        \n        vec3 p = o + dir * dist;\n        float sdf = SDF(p);\n        \n        // If we're close enough to the surface, then count it as \"reached\"\n        const float E = 0.01;\n        if(sdf < E)\n        {\n            const vec3 waterColor = vec3(0.1, 0.3, 0.6);\n            float rim = pow(max(1.0 - dot(-dir, Norm(p, sdf)), 0.0), 20.0) * 10.0;\n            float depth = max(20.0 - dist, 0.0)/20.0;\n            fc = vec4(waterColor * (max(p.y * 10.0, 0.1) + rim + depth), 1.0);\n            fc = fc + pow(rand(floor(p.xz * 50.0)), 1000.0) * 1.0;\n            \n            break;\n        }\n        dist += sdf + dist * 0.01;\n    }\n    \n    float fogAmount = 1.0 - exp( -dist*0.05 );\n    vec3  fogColor  = vec3(0.5,0.7,0.9)+sin(uv.x*4.0+iTime*0.01)*0.175+0.175+length(uv)*0.1;\n    \n    fc.rgb = mix( fc.rgb, fogColor*0.9, fogAmount);\n    fragColor = pow(fc,vec4(2.2));\n    \n#ifdef OVERLAY\n    fragColor += texture(iChannel0, uv)*0.1;\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat loadSate(vec2 uv)\n{\n\treturn 0.0;\n}\n\nint readCellState(vec2 id)\n{\n\treturn int(1.0 - step(texture(iChannel0, id / iChannelResolution[0].xy).x, 0.99));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tint cellState = 0;\n\n\t// Set initial state\n\tif(iFrame == 0)\n    {\n        int on = int(step(rand(fragCoord.xy), 0.3));\n    \tcellState = on;\n        fragColor = vec4(cellState);\n        return;\n    }\n\n\tcellState = readCellState(fragCoord.xy);\n\n\t// Modify State\n    int liveNeighbours = 0;\n    liveNeighbours += readCellState(fragCoord.xy + vec2(1.0, 0.0));\n    liveNeighbours += readCellState(fragCoord.xy + vec2(-1.0, 0.0));\n    liveNeighbours += readCellState(fragCoord.xy + vec2(0.0, 1.0));\n    liveNeighbours += readCellState(fragCoord.xy + vec2(0.0, -1.0));\n    liveNeighbours += readCellState(fragCoord.xy + vec2(-1.0, 1.0));\n    liveNeighbours += readCellState(fragCoord.xy + vec2(1.0, 1.0));\n    liveNeighbours += readCellState(fragCoord.xy + vec2(-1.0, -1.0));\n    liveNeighbours += readCellState(fragCoord.xy + vec2(1.0, -1.0));\n\n    if(cellState == 1)\n    {\n        if(liveNeighbours < 2) cellState = 0;\n        else if(liveNeighbours == 2 || liveNeighbours == 3) cellState = 1;\n            else if(liveNeighbours > 3) cellState = 0;\n    }\n    else if(liveNeighbours == 3) cellState = 1;\n    \n\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    float distancceToUV = distance(fragCoord.xy / iResolution.xy, mouseUV);\n    \n    int on = int(step(rand(fragCoord.xy), 0.3));\n    cellState += on * int(step(distancceToUV, 0.01));\n    \n    float previousFloatState = texture(iChannel0, fragCoord.xy / iResolution.xy).x * 0.98;\n    \n\tfragColor = vec4(min(float(cellState) + previousFloatState, 1.0));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}