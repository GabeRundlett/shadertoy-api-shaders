{
    "Shader": {
        "info": {
            "date": "1506528679",
            "description": "Glowing triangulated mesh displaced by an fbm weighted and translated by some of the frequencies playing on iChannel1. It can be rotated with the mouse.",
            "flags": 64,
            "hasliked": 0,
            "id": "4lXyzj",
            "likes": 21,
            "name": "Reactive Mesh",
            "published": 3,
            "tags": [
                "triangle",
                "reactive",
                "mesh",
                "traversal"
            ],
            "usePreview": 0,
            "username": "glk7",
            "viewed": 1511
        },
        "renderpass": [
            {
                "code": "// Created by genis sole - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\nconst float PI = 3.1415926;\n\n//David Hoskins' hash from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) *  443.8975);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat vnoise(vec2 p) \n{\n    vec2 i = floor(p);\n\tvec2 f = fract(p);\n    \n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0));\n    \n    float c1 = b - a;\n    float c2 = c - a;\n    float c3 = d - c - b + a;\n\t\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n   \treturn a + u.x*c1 + u.y*c2 + u.x*u.y*c3;\n}\n\n\nfloat fbm(vec2 p) \n{\n    vec4 s = vec4(texture(iChannel1, vec2(0.0, 0.0)).r,\n    \t\t\t  texture(iChannel1, vec2(0.25, 0.0)).r,\n    \t\t\t  texture(iChannel1, vec2(0.50, 0.0)).r,\n    \t\t\t  texture(iChannel1, vec2(0.75, 0.0)).r);\n    p += vec2(s.x - s.w, s.z - s.y);\n    \n\tfloat h = vnoise(p) * s.x;\n    h += vnoise(p * 2.0) * s.y * 0.5;\n    h += vnoise(p * 4.0) * s.z * 0.3;\n    h += vnoise(p * 8.0) * s.w * 0.2 ;\n    \n    return h;\n}\n\n//From https://iquilezles.org/articles/palettes\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 color(vec2 p) \n{\n    return pal(hash(p), vec3(1.0), vec3(0.6), vec3(1.0), vec3(0.0, 0.333, 0.666));\n}\n\nfloat map( vec2 p ) \n{\n\treturn clamp(fbm((p+100.+iTime)*0.2)*8.0 - 4.0 + hash(p + 10.0)*1.0, -5.0, 5.0);  \n}\n\nfloat segment(vec2 uv, vec2 a, vec2 b)\n{         \n    b -= a;\n    uv -= a;\n    float d = length( uv - b * clamp(dot(b, uv) / dot(b, b), 0.0, 1.0));\n    \n    return 1.0/(d*d*1000000.);\n}\n\n\nfloat iRayAABox(in vec3 ro, in vec3 invrd, in float b) \n{\n    vec3 t0 = (-vec3(b) - ro) * invrd;\n    vec3 t1 = (vec3(b) - ro) * invrd;\n\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float fmin = max(max(tmin.x, tmin.y), tmin.z);\n    float fmax = min(min(tmax.x, tmax.y), tmax.z);\n    \n    return fmin * sign(fmax - fmin);\n}\n\nvec3 draw_edge(vec2 uv, vec2 a, vec2 b, mat4 iT)\n{\n    \n  \tvec4 t1 = iT * vec4(vec3(a, map(a)).xzy, 1.0);\n  \tvec4 t2 = iT * vec4(vec3(b, map(b)).xzy, 1.0);\n    \n  \tt1.xy /= t1.z;\n  \tt2.xy /= t2.z;\n    \n    vec3 col = color(vec2(0.4, map(a) * 0.0000002) );\n    \n    vec3 r = vec3(0.0);\n    \n   \tr += segment(uv, t1.xy, t2.xy) * col;\n    r += segment(uv, t2.xy, t1.xy) * col;\n    \n    return r;\n}\n    \nvec3 draw_quad(vec2 uv, vec2 c, mat4 iT)\n{\n    vec2 v1 = c + vec2(-0.5, -0.5);\n    vec2 v2 = c + vec2(0.5, -0.5);\n    vec2 v3 = c + vec2(-0.5, 0.5);\n    vec2 v4 = c + vec2(0.5, 0.5);\n    \n    vec4 t1 = iT * vec4(vec3(v1, map(v1)).xzy, 1.0);\n    vec4 t2 = iT * vec4(vec3(v2, map(v2)).xzy, 1.0);\n    vec4 t3 = iT * vec4(vec3(v3, map(v3)).xzy, 1.0);\n    vec4 t4 = iT * vec4(vec3(v4, map(v4)).xzy, 1.0);\n    \n    t1.xy /= t1.z;\n    t2.xy /= t2.z;\n    t3.xy /= t3.z;\n    t4.xy /= t4.z;\n\n    vec3 col = color(vec2(0.4, map(v1) * 0.0000002));\n\n    vec3 r = vec3(0.0);\n\n    r += segment(uv, t1.xy, t2.xy) * col;\n    r += segment(uv, t1.xy, t3.xy) * col;\n    r += segment(uv, t1.xy, t4.xy) * col;\n    r += segment(uv, t3.xy, t4.xy) * col;\n    r += segment(uv, t2.xy, t4.xy) * col;\n    \n\treturn r;\n}\n\nvec3 traverse_mesh( vec3 ro, vec3 rd, vec2 uv, float e, mat4 iT)\n{\n    const float size = 5.0;\n    vec3 v = vec3(0.1); \n\n#if 0\n    for (float c = -size; c < size; ++c) {\n    \tv += draw_edge(uv, vec2(c, -size), vec2(c+1.0, -size), iT);\n        v += draw_edge(uv, vec2(c, size), vec2(c+1.0, size), iT);\n        v += draw_edge(uv, vec2(-size, c), vec2(-size, c+1.0), iT);\n        v += draw_edge(uv, vec2(size, c), vec2(size, c+1.0), iT);\n    }\n#endif\n    \n    vec3 ird = 1.0/rd;\n    vec3 srd = sign(rd);\n\n    \n    float b = iRayAABox(ro, ird, size);\n    \n    if (b < 0.0) return v;\n    \n    ro += b*rd; \n    vec2 c = floor((ro + rd*0.0001).xz) + 0.5;\n        \n    ro.xz -= c;\n    \n    \n    \n    for( int i = 0; i < 20; ++i ){\n        v += draw_quad(uv, c, iT);\n        \n    \tvec3 d = (sign(rd)*0.5 - ro) * ird;\n        ro += min(d.x, d.z) * rd;\n        \n        vec2 n = -sign(rd.xz) * step(d.xz, d.zx);\n        \n        c -= n;\n        ro.xz += n;\n        \n        if (any(greaterThan(abs(c), vec2(5.0)))) break;\n        if (abs(ro.y) > 5.0) break;\n    }\n    \n    return v;\n}\n\nconst float cam_dist = 25.0;\nmat4 camera() \n{\n\tvec2 m = -vec2(((iMouse.xy + 0.01) / iResolution.xy) * 2.0*PI) - vec2(PI, 0.0);\n    \n    if (all(lessThan(iMouse.xy, vec2(10.0)))) {\n        m = vec2(sin(iTime*0.1), cos(iTime*0.1));\n    }\n    \n    vec2 c = cos(m);\n    vec2 s = sin(m);\n    \n   \tmat4 t = mat4(c.x, 0.0, -s.x, 0.0, \n                  s.x*s.y, c.y, c.x*s.y, 0.0, \n                  s.x*c.y, -s.y, c.x*c.y, 0.0,\n                  0.0, 0.0, 0.0, 1.0);\n    \n    t[3] = vec4(t[2].xyz * -cam_dist, 1.0); \n    \n    return t;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    float e = 1.0 / iResolution.x;\n    vec2 uv = (fragCoord - iResolution.xy*0.5) * e;\n    \n    vec3 ro = vec3(0.0);\n\tvec3 rd = normalize(vec3(uv, 1.0));\n    \n    mat4 T = camera();\n    \n    ro = (T * vec4(ro, 1.0)).xyz;\n    rd = mat3(T) * rd;\n    \n    //mat4 iT = inverse(T);\n    mat4 iT = mat4(transpose(mat3(T)));\n    iT[3] = vec4(0.0, 0.0, cam_dist, 1.0);\n    \n    vec3 c = traverse_mesh(ro, rd, uv, e, iT);\n    \n    fragColor = vec4(pow(c, vec3(0.4545)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 18286,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/hammockofficial/when-the-sky-pours-down-like-a?in=hammockofficial/sets/raising-your-voice-trying-to-2"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}