{
    "Shader": {
        "info": {
            "date": "1721495971",
            "description": "I was going to add some background stuff but I've given up :)\nIt's also slower than I'd like since I've used the \"egg\" sdf like 30 times (bad idea)\n\n--> Click the screen to change leg motion <---",
            "flags": 0,
            "hasliked": 0,
            "id": "MfXyDS",
            "likes": 25,
            "name": "Plain Walker",
            "published": 3,
            "tags": [
                "cycle",
                "cool",
                "man",
                "walk",
                "walker",
                "body",
                "dude",
                "arms",
                "legs"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 227
        },
        "renderpass": [
            {
                "code": "#define pi 3.14159\n#define dir(a) vec2(cos(a),sin(a))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define ss(x) smoothstep(1.2/R.y, -1.2/R.y, x)\n#define arc(x) (x)*(1.-(x))\n#define normal(v) vec2(-(v).y, (v).x)\n\n// Conventions:\n// name  = position\n// dName = distance \n// aName = angle\n// nName = normal\n// colName = color\n\n// ( I SHOULD HAVE USED GLOBALS AHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH )\n\n// Height of wave player walks on\nfloat waveH(float x, float t) {\n    return .08 + .025 * cos(4. * x + t);\n}\n\nvoid calcPos(vec2 hip, vec2 neck, vec2 stride, float t, float tS,\n             inout vec2 foot,\n             inout vec2 toe,\n             inout vec2 hipS,\n             inout vec2 butt,\n             inout vec2 knee,\n             inout vec2 calfTop,\n             inout vec2 calfBot,\n             inout vec2 sho,\n             inout vec2 elb,\n             inout vec2 hand,\n             inout vec2 fing) \n{             \n    // Time stuff\n    float to = -.07; // Toe time offset \n    float f   = min(1., mod(tS,    2.)); // Foot \n    float fT  = min(1., mod(tS+to, 2.)); // Toe\n    float fr  = fract(tS/2.);\n    float frT = fract((tS+to)/2.);\n    \n    // Feet move: horizontally in a triangle wave\n    //              vertically in an arc->flat periodic function\n    // https://www.desmos.com/calculator/tm32l9cgdq\n    foot = stride * vec2(f - fr - .25, arc(f));\n    foot.y += waveH(foot.x, t);   \n    \n    // Toe follows same trajectory as foot but time delayed.\n    // Toe position becomes foot moved a fixed distance towards toe\n    // https://www.desmos.com/calculator/ax76ddid9v\n    toe  = stride * vec2(fT - frT - .25, arc(fT));    \n    toe.y += waveH(toe.x, t);\n    toe.x += .04;     \n    toe = foot + .04 * normalize(toe - foot);\n    \n    // hipL and hipR are rotated around hip\n    hipS = hip + .013 * dir(pi*tS);    \n    butt = hipS - vec2(.007, .008);\n    \n    // Use inverse kinematics to find knees\n    knee = hipS + solve(foot - hipS, .19, .2); \n    \n    // Calves \n    vec2 nKneeFoot = normal(knee - foot);\n    float calfMix = .45 + .4*arc(fr); \n    calfTop = mix(knee, foot, calfMix+.1) + .007 * nKneeFoot;  \n    calfBot = mix(knee, foot, calfMix-.1) - .01  * nKneeFoot;      \n                  \n    // Shoulders are above hips, with some rotation\n    float shoulderSway = .4*stride.x;\n    sho = hipS + .25 * dir(pi/2. + shoulderSway*sin(pi*tS));\n    sho = mix(neck, sho, .7);\n    \n    // Elbows are rotated around shoulders\n    float aElb  = pi/2. - .75*abs(stride.x)*sin(pi*tS-pi/3.);\n    elb  = sho  - .148 * dir(aElb);\n    \n    // Hands are rotated around elbows\n    float aHand = aElb + .9*abs(stride.x)*(.6+cos(pi*tS));\n    hand = elb  - .162 * dir(aHand);\n    \n    // Fingers are rotated around hands\n    float aFing = aHand + .6*abs(stride.x)*(.5+cos(pi*tS));\n    fing = hand - .025 * dir(aFing);\n}\n\nfloat dArm(vec2 u, vec2 neck, \n           vec2 sho, vec2 elb, vec2 hand, vec2 fing) \n{\n    float d = seg(u, mix(neck, sho, .6), sho) - .02; \n    d =  min(d, egg(u, sho,  elb,   .02, .013, .05)); \n    d = smin(d, egg(u, elb,  hand, .013, .008, .05), .0005);\n    d =  min(d, egg(u, hand, fing, .008, .006, .05)); \n    return d;   \n}\n\nfloat dSide(vec2 u, vec2 nBodyHip, vec2 hip,  vec2 body, vec2 neck,\n            vec2 foot, vec2 toe, vec2 hipS, vec2 butt, vec2 knee, vec2 calfTop, vec2 calfBot, vec2 sho) \n{  \n    float dButt = length(u - butt) - .0363;\n    float dHipKnee  = egg(u, hipS,  knee, .024, .015, .14);\n    float dKnee = length(u - knee) - .015;\n    float dKneeCalf = egg(u, knee, calfTop, .014, .007, .22);    \n    float dCalfFoot = egg(u, calfBot, foot, .014, .007, .05);\n    float dFootToe = cap(u, foot+vec2(.002,0), toe-vec2(0,.003), .01, .0065);\n    float dTop = egg(u, butt, mix(neck,sho,.5), .03, .03, .05);    \n    vec2 revTop = butt + nBodyHip * 2.8 + (body-hip);\n    dTop = -smin(-dTop, length(u - revTop) - .32, .01);\n    \n    float d = dButt;\n    d = smin(d, dHipKnee, .0015);\n    d = smin(d, dKnee, .001);\n    d = smin(d, smin(dKneeCalf, dCalfFoot, .0007), .001);\n    d = smin(d, dFootToe, .0007);\n    d = smin(d, dTop, .0007);\n    return d;\n}\n\nfloat dMid(vec2 u, vec2 nBodyHip, vec2 hip, vec2 body, vec2 neck, vec2 head, vec2 belly, vec2 breast, vec2 backBot, vec2 backTop) \n{\n    float dBelly  = length(u - belly)- .13;\n    float dBreast = length(u - breast) - .08;\n    \n    if (dot(u - hip, nBodyHip) > 0.) \n        dBelly = dBreast = 1e5;\n    \n    float dBack = seg(u, backBot, backTop) - .031;\n    float dNeck = seg(u, neck, head) - .016;\n    float dHead = length(u - head) - .05;    \n    \n    float d = dBelly;\n    d = min(d, dBreast);\n    d = min(d, dBack);\n    d = min(d, dNeck);\n    d = min(d, dHead);\n    return d;\n}\n\nvoid mainImage( out vec4 o, vec2 u )\n{\n    // Coords\n    vec2 R = iResolution.xy;\n    vec2 v = u / R;\n    vec2 w = u = (u-.5*R)/R.y;  \n    u *= 1.04;\n    u.y += .477;\n    \n    // Distort u slightly\n    u += .004 * (texture(iChannel1, .02*v).xy - .5);\n    \n    float t = iTime;\n    \n    \n    // Middle parts (also used for left/right parts)\n    vec2 hip = vec2(0, .323 + .3*arc(fract(t)) + waveH(0., t));\n    vec2 body = hip + vec2(0, .25)/2.;\n    vec2 neck = hip + vec2(0, .25);\n    vec2 head = neck + .1*dir(pi/2. - .1*sin(2.*pi*t-pi/8.)); \n    \n    // Middle parts (not used for left/right parts)\n    vec2 nBodyHip = normal(body - hip);\n    vec2 belly   = mix(hip, body,  .77) +  .6 * nBodyHip;\n    vec2 breast  = mix(hip, body, 1.73) +  .3 * nBodyHip;\n    vec2 backBot = mix(hip, body, .32)  - .02 * nBodyHip;\n    vec2 backTop = mix(hip, body, 1.98) + .02 * nBodyHip;\n    \n    // Stride width and height\n    vec2 stride = vec2(.45, .26);\n    if (iMouse.w != 0.)\n        stride = vec2(0, .15) + vec2(.65, .5) * iMouse.xy / R;\n         \n    // Calculate left/right positions (ðŸ˜£)\n    vec2 footL,    footR,\n         toeL,     toeR,\n         hipL,     hipR, \n         buttL,    buttR,\n         kneeL,    kneeR,\n         calfTopL, calfTopR,\n         calfBotL, calfBotR,\n         shoL,     shoR,\n         elbL,     elbR,\n         handL,    handR,\n         fingL,    fingR;\n    calcPos(hip, neck, stride, t, t,    footL, toeL, hipL, buttL, kneeL, calfTopL, calfBotL, shoL, elbL, handL, fingL);\n    calcPos(hip, neck, stride, t, t+1., footR, toeR, hipR, buttR, kneeR, calfTopR, calfBotR, shoR, elbR, handR, fingR);\n  \n    // --- Distances ---\n        \n    // (To preserve my sanity)   \n    #define DL(X)    dSide(X, nBodyHip, hip, body, neck, footL, toeL, hipL, buttL, kneeL, calfTopL, calfBotL, shoL)\n    #define DR(X)    dSide(X, nBodyHip, hip, body, neck, footR, toeR, hipR, buttR, kneeR, calfTopR, calfBotR, shoR)\n    #define DM(X)    dMid( X, nBodyHip, hip, body, neck, head, belly, breast, backBot, backTop)\n    #define DARML(X) dArm( X, neck, shoL, elbL, handL, fingL)\n    #define DARMR(X) dArm( X, neck, shoR, elbR, handR, fingR)\n       \n    float dL    = DL(u);\n    float dR    = DR(u);\n    float dM    = DM(u);\n    float dArmL = DARML(u);\n    float dArmR = DARMR(u);\n    \n    float dAll = dM;\n    dAll = min(dAll, min(dL,    dR   ));\n    dAll = min(dAll, min(dArmL, dArmR));\n\n\n    // --- Person Colors --- \n    \n    vec4 col1, col2;\n    float hue = .5 + .5 * cos(ceil(t/2.));\n    col1.rgb = hsv2rgb(vec3(hue,.7,.8));\n    col2.rgb = hsv2rgb(vec3(hue + .06, .75, 1.));\n    col1 = mix(col1, vec4(1), .1);\n    col2 = mix(col2, vec4(1), .45);\n    \n    float mxCol = .5;\n    float mxSpread = .45; // .25 + .25 * cos(.6*t);\n    vec4 colArmL  = mix(col1, col2, mxCol - mxSpread);\n    vec4 colL     = mix(col1, col2, mxCol - mxSpread/2.);\n    vec4 colM     = mix(col1, col2, mxCol);\n    vec4 colR     = mix(col1, col2, mxCol + mxSpread/2.);\n    vec4 colArmR  = mix(col1, col2, mxCol + mxSpread);\n     \n\n    // --- Background ---\n    \n    vec4 bg = mix(colM, vec4(.4,.7,1,0), .9);\n    \n    float whiteRadius = .32 - .11*ths(6.,pi*t/2.-.3);\n    bg = mix(bg, vec4(1), .7*ss(length(w-vec2(0,.02))-whiteRadius));\n      \n    // Wave person walks on (+outline)\n    float dWave = u.y + .032 - waveH(u.x, t);\n    bg = mix(bg, colM, ss(dWave));  \n    bg = mix(bg, .2*colM, ss(abs(dWave-.004) - .004));\n    bg = mix(bg, vec4(1),  ss(abs(dWave-.01)  - .004));\n    \n    // Vignette\n    bg *= pow(16.*v.x*v.y*(1.-v.x)*(1.-v.y), .06);\n    \n    // Multiply by texture (for papery feel)\n    bg *= .994 + .015 * smoothstep(.48, .52, fract(50.*(v.x+v.y)-t));   \n     \n    o = bg;\n              \n   \n    // --- Crude lighting ---\n        \n    vec2 e = vec2(.01, 0);  \n    \n    // Normals obtained by finite differences\n    vec3 nL    = vec3(dL-DL(u-e),       dL-DL(u-e.yx),       .1);\n    vec3 nR    = vec3(dR-DR(u-e),       dR-DR(u-e.yx),       .1);\n    vec3 nM    = vec3(dM-DM(u-e),       dM-DM(u-e.yx),       .1);\n    vec3 nArmL = vec3(dArmL-DARML(u-e), dArmL-DARML(u-e.yx), .1);\n    vec3 nArmR = vec3(dArmR-DARMR(u-e), dArmR-DARMR(u-e.yx), .1);    \n    nL    = normalize(nL);\n    nR    = normalize(nR);\n    nM    = normalize(nM);\n    nArmL = normalize(nArmL);\n    nArmR = normalize(nArmR);\n    \n    // Light direction    \n    vec3 ld = normalize(vec3(1, .4, 1)); \n    \n    // Diffuse lighting\n    float difL    = .5 + .5 * dot(nL,    ld);\n    float difR    = .5 + .5 * dot(nR,    ld);\n    float difM    = .5 + .5 * dot(nM,    ld);\n    float difArmL = .5 + .5 * dot(nArmL, ld);\n    float difArmR = .5 + .5 * dot(nArmR, ld);   \n    colL    *= clamp(1.17 * difL,    0., 1.);\n    colR    *= clamp(1.17 * difR,    0., 1.);\n    colM    *= clamp(1.17 * difM,    0., 1.);\n    colArmL *= clamp(1.17 * difArmL, 0., 1.);\n    colArmR *= clamp(1.17 * difArmR, 0., 1.);\n\n\n    // --- Draw Person --- \n    \n    // Fake shadows\n    float shadowR    = ss(   DR(u+.008) - .016);\n    float shadowArmR = ss(DARMR(u+.008) - .016);\n    float shadowM    = ss(   DM(u+.008) - .016);\n    \n    vec4 colLShadow    = colL    * mix(1., .9, shadowR);\n    vec4 colRShadow    = colR    * mix(1., .9, shadowArmR);\n    vec4 colMShadow    = colM    * mix(1., .94, max(shadowR,shadowArmR));\n    vec4 colArmLShadow = colArmL * mix(1., .95, shadowM);\n    \n    // Subtle outline shadow\n    o = mix(o, .93 * o, smoothstep(.028, .008, dAll));\n    \n    // Body parts\n    o = mix(o, colArmLShadow, ss(dArmL));    \n    o = mix(o, colLShadow,    ss(dL));    \n    o = mix(o, colMShadow,    ss(dM));\n    o = mix(o, colRShadow,    ss(dR));\n    o = mix(o, colArmR,       ss(dArmR));\n    \n    // Outline thickness\n    float outTh = .004;\n    \n    // Outline color\n    vec4 colOutl;\n    colOutl = mix(colOutl, .4*colArmL, ss(abs(dArmL-outTh)-outTh));\n    colOutl = mix(colOutl, .4*colL,    ss(abs(dL   -outTh)-outTh));\n    colOutl = mix(colOutl, .4*colM,    ss(abs(dM   -outTh)-outTh));\n    colOutl = mix(colOutl, .4*colR,    ss(abs(dR   -outTh)-outTh));\n    colOutl = mix(colOutl, .4*colArmR, ss(abs(dArmR-outTh)-outTh));\n    \n    // Draw outline\n    o = mix(o, colOutl, ss(abs(dAll - outTh) - outTh)); \n    o = mix(o, vec4(1), ss(abs(dAll - .01)   - outTh));\n    \n    // Lighten/darken in light direction/opposite\n    o *= .97+.2*dot(u, ld.xy);\n    \n    // Multiply for papery texture\n    o *= .97 + .08 * texture(iChannel0, v).r; \n    \n    // Tonemapping\n    o = pow(o, vec4(.95));\n    //o = sqrt(1.08-exp(-2.*o*o*o));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Quadratic smooth min, from iq\n// https://iquilezles.org/articles/smin/\nfloat smin( float a, float b, float k )\n{\n    k *= 4.0;\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min(a,b) - h*h*k*(1.0/4.0);\n}\n\n// Inverse kinematic solve, from iq\n// https://iquilezles.org/articles/simpleik/\nvec2 solve( vec2 p, float r1, float r2 )\n{\n    float h = dot(p,p);\n    float w = h + r1*r1 - r2*r2;\n    float s = max(4.0*r1*r1*h - w*w,0.0);\n    return (w*p + vec2(-p.y,p.x)*sqrt(s)) * 0.5/h;\n}\n\n// Segment sdf, from iq\n// https://iquilezles.org/articles/distfunctions2d/\nfloat seg( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// Uneven egg segment sdf\n// https://www.shadertoy.com/view/X3KSWG\nfloat egg(vec2 u, vec2 p, vec2 q, float rp, float rq, float tc) \n{    \n    u -= p; q -= p;\n    float h = length(q);\n    u *= mat2(q.y, -q.x, q.x, q.y) / h;\n    q = vec2(0, h);    \n    u.x = abs(u.x); \n    float rprq = rp - rq;\n    if (h <= abs(rprq)) return min(length(u)-rp, length(u-q)-rq);     \n    float a = mix(asin(rprq / h) + .001, 1.570796, tc);\n    vec2 dira = vec2(cos(a), sin(a));\n    vec2 e = q + rq * dira;   \n    vec2 f = e - rp * dira;  \n    vec2 eq = e - q;\n    float t = dot(e-f/2., f) / dot(eq, f);\n    vec2 w = e - eq * t;\n    float k = dot(u, vec2(w.y, -w.x));\n    if (k < 0.)          return length(u)   - rp;  \n    if (k > h*(u.x-w.x)) return length(u-q) - rq;  \n                         return length(u-w) - rq * abs(t);\n}\n\n// Uneven capsule sdf, from iq\nfloat cro(in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nfloat cap( in vec2 p, in vec2 pa, in vec2 pb, in float ra, in float rb )\n{\n    p  -= pa;\n    pb -= pa;\n    float h = dot(pb,pb);\n    vec2  q = vec2( dot(p,vec2(pb.y,-pb.x)), dot(p,pb) )/h;\n    \n    //-----------\n    \n    q.x = abs(q.x);\n    \n    float b = ra-rb;\n    vec2  c = vec2(sqrt(h-b*b),b);\n    \n    float k = cro(c,q);\n    float m = dot(c,q);\n    float n = dot(q,q);\n    \n         if( k < 0.0 ) return sqrt(h*(n            )) - ra;\n    else if( k > c.x ) return sqrt(h*(n+1.0-2.0*q.y)) - rb;\n                       return m                       - ra;\n}\n\n// Box sdf, from iq \nfloat box( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// Smooth HSV to RGB conversion, from iq\n// https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}