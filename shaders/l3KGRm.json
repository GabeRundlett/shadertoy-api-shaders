{
    "Shader": {
        "info": {
            "date": "1717459888",
            "description": "code is messy and the way I encoded ray distance from centre sucks in so many ways because I was too lazy to do it right... but it works. And it's nearly free.",
            "flags": 0,
            "hasliked": 0,
            "id": "l3KGRm",
            "likes": 2,
            "name": "sphere intersection antialiasing",
            "published": 3,
            "tags": [
                "thingy"
            ],
            "usePreview": 0,
            "username": "01000001",
            "viewed": 127
        },
        "renderpass": [
            {
                "code": "//#define zoom (sin(iTime)*2. + 4.)\n\nvec4 sphere(vec3 o, vec3 dirV){    \n    \n    /*\n    float a = dot(dirV, dirV);\n    float b = 2.*(dot(o, dirV));\n    float c = dot(o, o)-1.;\n    float det = b*b - 4.*a*c;\n    if (det < 0.) return vec4(-1);\n    return vec4((-b-sqrt(det))/(2.*a));\n    */\n    \n    /*\n    //value of a is always 1 if dirV is normalized so we can ignore it\n    float b = 2.*(dot(o, dirV));\n    float c = dot(o, o)-1.;\n    float det = b*b - 4.*c;\n    if (det < 0.) return vec4(-1);\n    return vec4((-b-sqrt(det))/2.);\n    */\n    \n    /*\n    //Adding t and normal calculation\n    float b = 2.*(dot(o, dirV));\n    float c = dot(o, o)-1.;\n    float det = b*b - 4.*c;\n    if (det < 0.) return vec4(-1);\n    float t = (-b-sqrt(det))/2.;\n    return vec4(t, o+dirV*t);\n    */\n    \n    // now here we find a clever optimization.\n    // the coeff. 2 in b is squared in det to give 4, and\n    // the det also has a -4 coeff. being subtracted. So we can \n    // bring the 4 outside the det\n    // the det is then square rooted, so we can bring the coeff. of 4\n    // outside as a 2.\n    // Now b was also multiplied by 2, so we can remove the 2 from both terms\n    // and bring it outside, where it is divided by 2, leaving 1, aka nothing\n    // Crazy stuff!\n    /*\n    float b = 2.*(dot(o, dirV));\n    float c = dot(o, o)-1.;\n    float det = b*b - 4.*c;\n    if (det < 0.) return vec4(-1);\n    float t = (-b-sqrt(det))/2.;\n    return vec4(t, o+dirV*t);\n    */\n    \n    float b = (dot(o, dirV));\n    float c = dot(o, o)-1.;\n    float det = b*b - c;\n    if (det < 0.) return vec4(-1);\n    float t = (-b-sqrt(det));\n    return vec4(t, (o+dirV*t)*(1.+det));\n\n\n}\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    vec2 muv = (2.*iMouse.xy-r)/r.y * 3.;\n    \n    if (abs(uv.x - .5) < 2./r.x){\n        O = vec4(1);\n        return;\n    }\n    \n    vec3 o = vec3(0);\n    vec3 dir = vec3(sin(muv.x)*cos(muv.y), cos(muv.x)*cos(muv.y), sin(muv.y));\n    o -= dir*\n    #ifdef zoom\n    zoom*zoom*.6\n    #else\n    5.\n    #endif\n    ;\n    vec3 right = normalize(cross(dir, vec3(0, 0, 1)));\n    vec3 up = cross(right, dir);\n    \n    vec2 camUV = cuv \n    #ifdef zoom\n    / zoom\n    #else\n    * .3\n    #endif\n    ;\n    vec3 dirV = vec3(sin(camUV.x)*cos(camUV.y), cos(camUV.x)*cos(camUV.y), sin(camUV.y));\n    dirV = normalize(dir * dirV.y + right * dirV.x + up * dirV.z);\n\n\n    \n    vec4 s = sphere(o, dirV);\n    if (s.x < 0.){\n        O = texture(iChannel0, dirV);\n        return;\n    }\n    vec3 norm = normalize(s.yzw);\n    O = mix(\n        vec4(pow(max(0., dot(norm, vec3(0,0,1))*.4+.6), 1./2.2)), \n        texture(iChannel0, reflect(dirV, norm)), \n        vec4(pow(1.+dot(norm, dirV), 5.))\n    );\n    \n    if (uv.x > .5) \n        O = mix(O, texture(iChannel0, dirV), smoothstep(1. - s.x/r.x*10.\n        #ifdef zoom\n        /zoom\n        #else\n        *.3\n        #endif\n        , 1., 2.-length(s.yzw)));\n        \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = texture(iChannel0, rayDir.xzy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}