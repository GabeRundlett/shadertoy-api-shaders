{
    "Shader": {
        "info": {
            "date": "1657419885",
            "description": "Today I tried to draw a shape over another. The square inside the bouncing ball should be green, but I don't know how to replace the color in a straight forward way without a step or if.\n\nOh, I discovered the mod function too, making repeating cycles.",
            "flags": 0,
            "hasliked": 0,
            "id": "fscBDs",
            "likes": 0,
            "name": "006 - Varying bouncing ball",
            "published": 3,
            "tags": [
                "beginner",
                "circle",
                "square",
                "learning"
            ],
            "usePreview": 0,
            "username": "PiGIon",
            "viewed": 182
        },
        "renderpass": [
            {
                "code": "// 2022.07.09 rev 1\n// 2022.07.12 rev 2 - implement a rot2d function to rotate the ball\n\n#define PI 3.14159265\n\n// https://www.wolframalpha.com/input?i=f%28x%29%3D0.5%2B%28cos%28%28%28x%2B0.5%2F1%29*20*1%29%2F%28PI%29%29%2F2.%29\nfloat cycle(float perSecond) {\n    // doing this multiplication, we make the animation % grow by perSecond factor\n    // iTime is the current time + timeDelta for precision\n    // _____________________________\n    // | iTime | perSecond |   d   |\n    // |_______|___________|_______|\n    // |0.1    |1          |0.1    |\n    // |0.2    |1          |0.2    |\n    // |0.45   |1          |0.45   |\n    // |0.5    |1          |0.5    |\n    // |_______|___________|_______|\n    // _____________________________\n    // | iTime | perSecond |   d   |\n    // |_______|___________|_______|\n    // |0.1    |2          |0.2    |\n    // |0.2    |2          |0.4    |\n    // |0.45   |2          |0.9    |\n    // |0.5    |2          |0      |\n    // |_______|___________|_______|\n    // _____________________________\n    // | iTime | perSecond |   d   |\n    // |_______|___________|_______|\n    // |0.1    |0.5        |0.05   |\n    // |0.2    |0.5        |0.1    |\n    // |0.45   |0.5        |0.225  |\n    // |0.5    |0.5        |0.25   |\n    // |_______|___________|_______|\n\n    float d = fract((iTime + iTimeDelta) * perSecond);\n    \n    // step 0.5 is used to reverse the keyframe, to get a coming and going effect\n    \n    // since the cut point is 0.5, we need to get original place (e.g. 1 again) if d is exactly to 0.5\n    // this means that it cycles from 0...1...0 every second\n    return 2. * ( d>.5 ? 1.-d : d );\n}\n\nfloat circle(vec2 uv, vec2 origin, float size) {\n    float antiAlias = 1.5/iResolution.y; // TODO: don't recalculate this every time\n\n    return smoothstep(size + antiAlias, size - antiAlias, length(uv - origin));\n}\n\n\nmat2 rot2D(float ang) {\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n}\n\nfloat square(vec2 uv, vec2 origin, float size, float ang) {\n    vec2 o = (uv - origin) * rot2D(ang);\n    float s;\n\n    float antiAlias = 1.5/iResolution.y; // TODO: don't recalculate this every time\n    \n    vec2 x = vec2(size-antiAlias);\n    vec2 y = vec2(size+antiAlias);\n    s = 1.-length(smoothstep(x, y, abs(o))); // TODO: maybe unnecessary 1 - inverse?\n\n    return s;\n}\n\n// returns -size to size cycle\nfloat rangeCycle(float size, float perSec) {\n    return mod(iTime*perSec - size, size) - .5*size;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    \n    vec3 O = fragColor.xyz;\n    \n    float shapeSize = 0.1;\n    shapeSize += cycle(0.3999) * 0.4;\n    vec2 shapeOrigin = vec2(0.);\n    \n    shapeOrigin.x += rangeCycle(5., 1.88);\n    float c = cycle(1.);\n    // range from bottom of screen to top of screen, determined by the shape size\n    shapeOrigin.y = shapeSize - 1. + (1. - shapeSize)*(2. * c);\n    \n    O += vec3(circle(uv, shapeOrigin, shapeSize)*0.89, 0., 0.1);\n    \n    // I need to discover the size of the section of the circle, here, I use pythagorean theorem to do it\n    O = vec3(O.x,\n            0.78 * square(uv, shapeOrigin, sqrt((pow(shapeSize/2., 2.) + pow(shapeSize/2., 2.))),\n            rangeCycle(PI, 1.33)), O.z);\n    \n    fragColor.xyz = O;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}