{
    "Shader": {
        "info": {
            "date": "1663690118",
            "description": "basically a plane with a fractal removed from inside of it, im not sure how long it can zoom for before breaking completely\n\nalso might look less centred the more it zooms (had to offset the point it looks at because of refraction)",
            "flags": 0,
            "hasliked": 0,
            "id": "7ltBD2",
            "likes": 10,
            "name": "Zoomed Refracted Apollonion ",
            "published": 3,
            "tags": [
                "fractal",
                "weird",
                "refract",
                "appollonion"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 274
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 400\n#define MAX_DIST 10.\n#define SURF_DIST .1\n\n// RayMarching from TheArtOfCode\n\n// From BlackleMori\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdBox(in vec2 p, in vec2 b){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\nvec3 GetRayOrigin() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    float r = 5.;\n    float a = 0.25 * iTime;\n    vec3 ro = vec3(r * cos(a), 7, r * sin(a));\n    //ro.yz *= rot(-m.y*3.14+1.);\n    //ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat test(vec3 p0) {\n   // p0.y += 4.;\n    float sd = length(p0.xz) - 3.;\n    //p0 *= 0.5;\n    //sd = p0.y - 0.5;\n    vec4 p = vec4(p0, 1.);\n    p.y += 0.05 * iTime;\n    for(int i = 0; i < 6; i++){\n      p.xyz = mod(p.xyz-1., 2.)-1.;\n      p*=(1./dot(p.xyz, p.xyz));\n    }\n    p/=p.w;\n    return max(sd, abs(p.y));\n}\n\nfloat GetDist(vec3 p) {\n    float d2 = p.y + 0.02 *  dot(p.xz,p.xz);//0.005 * length(p.xz);//length(p) - 0.5;\n    \n    vec3 dim = vec3(0.5,100.,0.5);\n    float d = length(p + vec3(0,2,0)) - 1.;\n    //d = sdBox(p + vec3(0,2. + dim.y,0), dim) - 0.25;\n    d = test(p + vec3(0,2,0));\n    d2 = -smin(-d2, d, 0.1);\n    return d2;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = GetRayOrigin();\n    \n    // starts becoming unenjoyable before ~1000 seconds\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.025,0), 1. + iTime * tanh(0.1 * iTime));\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n    \n    vec3 p = ro + rd * d;\n    float IOR = 2.;\n    if(d<MAX_DIST) {        \n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(nExit, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n           \n        float spec = pow(dif, 15.);\n        \n        if (dIn < MAX_DIST) {\n            float fres = pow(1. + dot(rd, n), 5.);\n            float fres2 = pow(1. + dot(rd, nExit), 4.);\n\n            vec3 c1 = texture(iChannel0, iTime * 0.01 + 0.5 * pExit.xy).rgb;\n            vec3 c2 = texture(iChannel0, iTime * 0.01 + 0.5 * pExit.yz).rgb;\n            vec3 c3 = texture(iChannel0, iTime * 0.01 + 0.5 * pExit.zx).rgb;\n            vec3 c = nExit.z * c1 + nExit.x * c2 + nExit.y * c3;\n            col = clamp(col + spec, 0., 1.); //???\n            col = mix(col, vec3(0), 1. - fres2);\n            \n            float k = 0.25;\n            col += smoothstep(-k,k, c.r-0.5);\n        }\n        float fog = 1.-exp(-0.5 * length(p));\n        col = mix(col, vec3(0.5 * col), fog);\n        col *= pal(fog + 1.75, 0.5 * vec3(0,1,1)/3.);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * pi * (c * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sfloor(float a, float b) {\n    return floor(b) + 0.5 + 0.5 * tanh(a * (fract(b) - 0.5)) / tanh(0.5 * a);\n}\n\n// From iq, k = 0.12 is good\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}