{
    "Shader": {
        "info": {
            "date": "1597614356",
            "description": "A raymarched version of https://www.shadertoy.com/view/ttXfDM\n\nInspired by this tweet: https://twitter.com/PelletierAuger/status/1291072500521148419",
            "flags": 0,
            "hasliked": 0,
            "id": "3tfBzs",
            "likes": 4,
            "name": "The Hole v2",
            "published": 3,
            "tags": [
                "raymarching",
                "hole"
            ],
            "usePreview": 0,
            "username": "BackwardsCap",
            "viewed": 306
        },
        "renderpass": [
            {
                "code": "float edgesize = .02;\n\nfloat map(vec3 p)\n{\n    float a = (1.0+sin(iTime))/2.0;\n    float r = box(p-vec3(0,0,60),vec3(30,20,50));\n\tfloat offset=10.*min(0.,(((10.0+edgesize)-p.z)/20.));\n    float t = iTime/2.;\n    p.x+=cos(t)*offset;\n    p.y+=sin(t)*offset;\n    \n    vec3 hp = p;\n    hp.xy*=rot(iTime);\n    float h = hex(hp-vec3(0,0,60),vec2(.5,50));\n\n    float r2 = hex(p-vec3(0,0,50),vec2(1.,50));\n    p.xy=abs(p.xy);\n    r2 = min(r2, hex(p-vec3(2.,0,0),vec2(1.,50)));\n    r2 = min(r2, hex(p-vec3(1.5,1.7,0),vec2(1,50)));\n    r2 = min(r2, hex(p-vec3(-.8,1,0),vec2(1.,50)));\n    \n    r=max(r,-r2);\n    return min(r,h);\n}\n\n//ao and edge technique thanks to nusan\n//https://www.shadertoy.com/view/WtyXDt\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nfloat ray(vec3 ro, vec3 rd, vec2 uv)\n{\n    float t = 0.;\n    \n    for(int i=0;i<200;i++)\n    {\n        vec3 p = ro+rd*t;\n        float s = map(p);\n        \n        if(s<1e-5)break;\n        t+=s;\n        if(t>MAX_DIST){t=-1.;break;}\n    }\n    return t;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.0001,0);\n    return normalize(vec3(\n        map(p+e.xyy)-map(p-e.xyy),\n        map(p+e.yxy)-map(p-e.yxy),\n        map(p+e.yyx)-map(p-e.yyx)));\n}\n\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    \n    vec2 uv = (2.*f-R)/R.y;\n    uv *= rot(mod((-iTime*.1), 3.1415927 * 2.0));\n    vec3 ro = vec3(0,0,0);\n    vec3 ta = vec3(0,0,10);\n    vec3 cf = normalize(ta-ro);\n    vec3 cu = normalize(cross(cf,vec3(0,1,0)));\n    vec3 cr = normalize(cross(cu,cf));\n    vec3 rd = normalize(uv.x*cu+uv.y*cr+2.*cf);\n    \n    float r = ray(ro,rd, f);\n    \n    vec3 col = vec3(1);\n    \n    float fog = 1.;\n    \n    if(r>0.)\n    {\n        vec3 p = ro+rd*r;\n        vec3 n = normal(p);    \n\t\t\n        float ao = getao(p,n,edgesize);\n        float ao2 = getao(p,n,-edgesize);\n        col-=(r-10.)/35.+smoothstep(1.,.9,ao*ao2)*10.;\n    }\n    \n    c.rgb=col;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_DIST 100.0\n#define R iResolution.xy\n\nmat2 rot(float x)\n{\n    float s = sin(x);\n    float c = cos(x);\n    return mat2(c,-s,s,c);\n}\n\nfloat box(vec3 p, vec3 d)\n{\n  vec3 q = abs(p) - d;\n  return min(max(q.x,max(q.y,q.z)),0.0)+length(max(q,0.0));\n}\n\nfloat hex( vec3 p, vec2 h )\n{\n  vec3 k = vec3(-0.866, 0.5, 0.577);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  float x = length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x);\n  vec2 d = vec2(x, p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}