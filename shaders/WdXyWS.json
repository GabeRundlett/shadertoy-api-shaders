{
    "Shader": {
        "info": {
            "date": "1585418682",
            "description": "My first ray-marching shader! Sorry for my bad coding.\nRays that go near the black hole exhibit a force proportional to the inverse square of their distance from it.\nRays can get stuck inside of the black hole and expire, making the event horizon visible.",
            "flags": 0,
            "hasliked": 0,
            "id": "WdXyWS",
            "likes": 2,
            "name": "Blue's Gravitational Lensing",
            "published": 3,
            "tags": [
                "pbr"
            ],
            "usePreview": 0,
            "username": "BlueVelvetCake",
            "viewed": 436
        },
        "renderpass": [
            {
                "code": "vec3 cameraPos = vec3(0, 0, 0);\nfloat dist = 45.;\nfloat ang = 0.;\nfloat fov = 1.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 halfCoords = fragCoord - (iResolution.xy / 2.); // UV Coordinates centered on zero\n    vec2 normalUv = halfCoords / iResolution.yy; \n    \n    ang = iMouse.x / 100.;\n    dist = iMouse.y / 5.;\n    \n    if (iMouse.xy == vec2(0)) { dist = 30.; }\n    \n    vec3 orbitPos = vec3(-cos(ang) * dist, dist / 3., -sin(ang) * dist);\n    \n    vec3 startPos = cameraPos + orbitPos; // Starting position and starting velocity\n    vec3 startVel = toSphere(normalUv.x * fov + ang, normalUv.y * fov - 0.3);\n    \n    traceResult mainResult = trace(startPos, startVel); // Pass to trace function\n\n    fragColor = mainResult.hitColor; // Output to screen\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "struct traceResult { vec3 hitPos; vec4 hitColor; };\n\nvec3 spherePos = vec3(0, 0, 0);\n    \ntraceResult trace( vec3 startPos, vec3 startVel )\n{\n    \n \tvec3 pos = startPos;\n    vec3 vel = startVel;\n    vec4 color = vec4(vec3(0), 1);\n    float life = 0.;\n    \n    while( life < 500. )\n    {\n        \n        float sphereDist = max(distance(pos, spherePos) - 1., 0.1);\n        float planeDist = pos.y + 10.;\n        \n        float minDist = min(sphereDist, planeDist);\n        \n        pos += vel * (minDist);\n        life += 1.;\n        \n        vec3 force = normalize( spherePos - pos ) * 0.5 / pow( length(spherePos - pos), 2. );\n        vel = normalize(vel + force * minDist);\n\n        if( planeDist < 0.01 )\n        {    \n            \n            color = vec4(1);\n            \n        \tif( mod(pos.x, 8.) > 4. && mod(pos.z, 8.) > 4. )\n            {\n                color = vec4(vec3(0), 1);\n            }\n        }  \n        else if ( length(pos) > 300. ) {\n            \n            color = vec4(vec3(0.5, 0.4, 1), 1); \n            break;\n        \n        }\n    }\n    \n    return traceResult( pos, color );\n    \n}\n\nvec3 toSphere( float azimuth, float inclination )\n{\n    return vec3(\n        cos(inclination) * cos(azimuth),\n        sin(inclination),\n        cos(inclination) * sin(azimuth)\n  );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}