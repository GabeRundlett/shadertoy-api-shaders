{
    "Shader": {
        "info": {
            "date": "1712869172",
            "description": "artist recreation of a strange object seen near the L4 lagrange point",
            "flags": 0,
            "hasliked": 0,
            "id": "lcV3WR",
            "likes": 7,
            "name": "alien artifex A0",
            "published": 3,
            "tags": [
                "alienartifex"
            ],
            "usePreview": 0,
            "username": "ufffd",
            "viewed": 149
        },
        "renderpass": [
            {
                "code": "#define STEP_MAX 180.\n#define RAY_MAX 2.\n#define SPECULAR_POWER 100.\n#define SPECULAR_INTENSITY .5\n\n#define FOV 1.5\n\n#define R (iResolution.xy)\n#define Rmin min(R.x,R.y)\n\n#define tt iTime\n\n// define textures\nstruct Tex {\n    vec3  c; // color\n    float m; // mirror\n    // add more material data:\n    float r; // rough\n    // metal - maybe replace mirror\n    // specular\n    // anisotropic - does this one really matter\n    // opacity - complicated\n    // emission/glow - maybe less complicated\n    // ior\n};\n// tex setup. takes object and global position as inputs\nTex T1(in vec3 p, in vec3 gp) {\n    // green, nonreflective\n    Tex T;\n    T.c = vec3(SS(0.99,0.01,nsin(p.y*100. + iTime)*vec3(1.,0.,0.)));\n    T.c += vec3(SS(0.98,0.01,nsin(p.y*90. + iTime + 1.)*vec3(.7,.6,.0))); // bug: not displaying\n    T.c += vec3(SS(0.97,0.01,nsin(p.y*80. + iTime - 2.)*vec3(0.2,.8,.0))); // bug: not displaying\n    T.m = 0.;\n    return T;\n}\nTex T2(in vec3 p, in vec3 gp) {\n    // black and white stripes\n    // the black part is reflective\n    Tex T;\n    float tt = iTime * 0.1;\n    float stripes = sin(40.*(p.x+p.y+p.z+tt));\n    stripes = SS(0.,0.01,stripes);\n    T.c = vec3(stripes);\n    T.m = 1.-stripes;\n    return T;\n}\nTex T3(in vec3 p, in vec3 gp) {\n    // show norms\n    Tex T;\n    T.c = normalize(p);\n    T.m = 0.;\n    return T;\n}\nTex T4(in vec3 p, in vec3 gp) {\n    // black mirror\n    Tex T;\n    T.c = vec3(.001);\n    T.m = .8;\n    return T;\n}\nTex T5(in vec3 p, in vec3 gp) {\n    // white mattte\n    Tex T;\n    T.c = vec3(1.);\n    T.m = .0;\n    return T;\n}\n// structs for abstracting march process\nstruct MapData {\n    vec4  c; // color\n    float d; // distance\n    float m; // mirror\n    bool  h; // hit\n};\nstruct MarchData {\n    vec4  c; // color\n    vec3  p; // intersection point\n    float d; // distance\n    float s; // steps\n    bool  h; // hit\n    // bounces\n    // attenuation\n    // steps in this bounce\n};\nvoid drawTex(in vec3 p, in vec3 gp, inout MapData m, int tx) {\n    Tex T;\n    if (tx==1) T = T1(p,gp);\n    if (tx==2) T = T2(p,gp);\n    if (tx==3) T = T3(p,gp);\n    if (tx==4) T = T4(p,gp);\n    if (tx==5) T = T5(p,gp);\n    float color_mix = 1.; // this should be set based on material & incidence angle\n    m.c = vec4(T.c,color_mix);\n    m.m = T.m;\n}\n// 3d scene\nvoid addObject(in float sdf, in int tx, in vec3 p, in vec3 gp, inout MapData m) {\n    m.h = m.h || sdf < 0.001; // register hit\n    if (sdf < m.d) { // this is the closest object so far\n        m.d == sdf;\n        drawTex(p,gp,m,tx);\n    }\n    m.d = min(m.d,sdf);\n}\nMapData map(in vec3 p) {\n    // returns distance to nearest surface from a given point in 3d space\n    MapData m;\n    m.d = 9999.; // start high, use min(d,x) to add geometry to scene\n    m.m = 0.; // no reflective surfaces yet\n    m.h = false; // no surfaces at all yet really\n    m.c = vec4(0.); // sure is dark in here...\n    \n    // add sphere\n    // float sph1 = sdOrb(p+vec3(sin(iTime),sin(iTime/4.),cos(iTime))*0.1, 0.2);\n    // addObject(sph1, 2, p, p, m);\n    \n    vec3 hytoP = p;\n    p.xy = rotate(p.xy,1.);\n    float hyto = sdHyperTorus(p, vec3(0.1, 0.05,0.2), iTime, 3);\n    addObject(hyto, 4, p, p, m);\n    \n    float toto = sdTororus(p, vec3(0.3, 0.05, 0.19), iTime, 30);\n    addObject(toto, 1, p, p, m);\n    \n    float to = sdTorus(p, vec2(0.2, 0.05));\n    addObject(to, 2, p, p, m);\n    \n    return m;\n}\nvec3 getNorm(vec3 p, float spread) { \n    float d = map(p).d; // Distance\n    vec2 e = vec2(.02*spread,0); // Epsilon\n    vec3 n = d - vec3(\n        map(p-e.xyy).d,  \n        map(p-e.yxy).d,\n        map(p-e.yyx).d);   \n    return normalize(n);\n}\nvec3 getNorm(vec3 p) {\n    return getNorm(p, 0.01); // default spread\n}\n// raymarch\nMarchData raymarch(in vec3 ro, in vec3 rd) {\n    MarchData d;\n    d.h = false;\n    d.d = 0.;\n    d.c = vec4(0.);\n    float atten = 1.;\n    for (d.s=0.;d.s<STEP_MAX;d.s++) {\n        vec3 p = ro + rd*d.d;\n        MapData m = map(p);\n        if (m.h) { // hit\n            d.h = true; // record hit\n            d.p = p; // hit location\n            d.c.rgb += m.c.rgb*m.c.a*atten; // lol. adds hit color to return color\n            if (m.m<0.01) break; // if not a mirror, we're done\n            // else, we hit a mirror. reflect and keep steppin\n            atten *= m.m;\n            vec3 n = getNorm(p);\n            rd = reflect(rd, n);\n            d.d = 0.;\n            // d.c = vec4(n,1.); break; // debug\n            ro = p + rd*.001; // step away from surface\n        } else\n            d.d += m.d;\n    }\n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // setup\n    vec2 uvc = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(sin(tt*.2),0.,cos(tt*.2));\n    vec3 rd = normalize(vec3(uvc,FOV));\n    rd.xz = rotate(rd.xz,tt*.2+PI);\n    // raymarch\n    for (float M=0.;M<RAY_MAX;M++) { // multiple rays per pixel\n        MarchData d = raymarch(ro+hash31(M)/Rmin,rd);\n        vec3 raycol = d.c.rgb;\n        // col = vec3(1./d.d, d.s/STEP_MAX, float(d.h)); // debug march data\n        // col = vec3(d.d);\n        // lighting - should all of this happen within raymarch for each intersection? probably\n        vec3 n = d.h?getNorm(d.p):vec3(0,0,1);\n        // n += hash33(d.p*1000.); // scatter - ought to be based on material roughness\n        vec3 bounceAngle = reflect(rd,n); \n\n        float amb = d.h?0.001:0.; // add ambient light for all hit pixels\n\n        vec3 light1pos = vec3(sin(tt*0.2),cos(tt*0.2), sin(tt));\n        vec3 light1dir = normalize(light1pos-d.p);\n        vec3 light2pos = vec3(sin(tt*0.3),cos(tt), cos(tt*0.3));\n        vec3 light2dir = normalize(light2pos-d.p);\n        \n        float diff1 = max(0.0, dot(n, light1dir)) * 1.;\n        float spec1 = pow(max(0.0, dot(bounceAngle, light1dir)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n        // float fade = pow (1.0 - d / RAY_LENGTH_MAX, FADE_POWER);\n        float light1result = diff1 + spec1;\n        \n        float diff2 = max(0.0, dot(n, light2dir)) * 1.;\n        float spec2 = pow(max(0.0, dot(bounceAngle, light1dir)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n        // float fade = pow (1.0 - d / RAY_LENGTH_MAX, FADE_POWER);\n        float light2result = diff2 + spec2;\n\n        raycol *= vec3(amb + light1result + light2result); // apply lighting\n        col += raycol;\n    }\n    col /= RAY_MAX;\n    // post fx\n    float gamma = 2.2;\n    col = pow(col, vec3(1.0/gamma));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define SS(a,b,c) smoothstep(a-b,a+b,c)\n#define PI 3.141529\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\nfloat nsin(float a) {return sin(a)*0.5+0.5;}\n\n//hgsdf\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// sdfs\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdOrb(vec3 p, float b) {\n  return length(p) - b;\n}\nfloat sdGyroid(vec3 p, float b) {\n    float g = dot(sin(p),cos(p.yzx));\n    return g - b;\n}\nfloat sdCappedTorus( vec3 p, vec2 sc, float ra, float rb){\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdHyperTorus( vec3 p, vec3 t, float spin, int count) {\n    float d = 9999.;\n    for (int i=0; i<count; i++) {\n        float tpct = (PI*2.)/float(count);\n        float offset = spin + tpct*float(i);\n        float torus = sdTorus(p + vec3(0.,cos(offset)*t.z,0.), vec2(t.x + t.z*nsin(offset), t.y));\n        d = min(d,torus);\n    }\n    return d;\n}\nfloat sdTororus( vec3 p, vec3 t, float spin, int count) {\n    float d = 9999.;\n    pModPolar(p.zx, float(count));\n    p.z -= t.z;\n    p.xy = rotate(p.xy, PI/2.);\n    d = sdTorus(p, t.xy*t.z);\n    return d;\n}\n\n\n// hash - rand - noise\n//--------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n///  3 out, 3 in...\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n\n\n// iq box intersect\nfloat boxIntersect( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return tF;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}