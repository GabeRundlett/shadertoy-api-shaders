{
    "Shader": {
        "info": {
            "date": "1720817050",
            "description": "This is a premade basic ray-marching algorithm. I made this as an easy way to start ray-marching renders, without coding every aspect from the ground up. It includes helpful comments throughout explaining what each step does (too the best of my knowledge)",
            "flags": 0,
            "hasliked": 0,
            "id": "4fXczN",
            "likes": 1,
            "name": "Pre-built Raymarcher",
            "published": 3,
            "tags": [
                "raymarching",
                "utility",
                "premade"
            ],
            "usePreview": 0,
            "username": "JOEMANFLAME",
            "viewed": 81
        },
        "renderpass": [
            {
                "code": "// Pre-setup ray-marcher, mostly for my own use but includes helpful\n// comments explaining each step in the process\n//--------------------------------------------------------------------------------------------------------------------\n\n// Global Variables\n\nfloat fov = 1.0;                                     // FOV adjuster (located in ray-direction intialization)\nint iter = 64;                                       // Iterations for ray-marcher to take\nvec3 rayOrig = vec3(0.0, 0.0, -3.0);                 // xyz-coordinates for ray-marcher to begin at\n\n//--------------------------------------------------------------------------------------------------------------------\n\n// Palette\n// Code originally from: https://iquilezles.org/articles/palettes\n\nvec3 palette( in float t ) \n{                      \n    vec3 a = vec3(0.5, 0.5, 0.5); \n    vec3 b = vec3(0.500, 0.500, 0.500);\n    vec3 c = vec3(1.000, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.577);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// Functions\n\nmat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n// Primitive SDFs (Geometry)\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n//--------------------------------------------------------------------------------------------------------------------\n\n// Map\n\n// 'Draw objects' using signed distance functions, SDFs will\n// return negative values when inside geometry and positive\n// when outside, decreasing in value as it approaches geometry\n// Useful SDF functions at https://iquilezles.org/articles/distfunctions/\n\nfloat map(vec3 p)\n{\n    float sphere = sdSphere(p, 1.0);                    // Sets position values based on sphere SDF (defined above)\n    \n    return sphere;\n}\n\n//--------------------------------------------------------------------------------------------------------------------\n\n// Ray-Marcher\n\nvec4 rayMarch(vec3 rayOrigin, vec3 rayDirection) \n{\n    \n    float t = 0.0;                                      // Distance ray has travelled\n    vec3 col = vec3(0.0);                               // Background (final) pixel color\n    float d;                                            // Distance to scene (will use map)\n    int i;\n    for (i = 0; i < iter; i++) {\n        \n        vec3 p = rayOrigin + rayDirection*t;            // Position along the ray w.r.t. the rays origin\n        d = map(p);                                     // Set d = distance to scene as given by p\n        \n        if (d < 0.001 || d > 100.0) {                   // If d is less than 0.01 (eg. close to geometry) or if d is\n            break;                                      // greater than 100 (eg. ray is going off to infinity then\n        }                                               // move to next ray cast\n        \n        // col += palette(t);                           // To color matrix add the output of the palette function\n        \n        t +=d;                                          // Move the ray forward in the scene by amount d\n    }\n    col = vec3(t * 0.2);                                // Returns color based on distance ray has travelled\n    \n    return vec4(col, 1.0);                              // return a vec4 containing our colored geometry positions\n}                    \n\n//--------------------------------------------------------------------------------------------------------------------\n// Output\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert pixel coordinates into uv coordinates, centered in the middle of the screen\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) /iResolution.y;\n    vec2 mouseInput = (iMouse.xy * 2.0 - iResolution.xy) /iResolution.y;\n    \n    // Initialization\n    vec3 r0 = vec3(rayOrig);                            // Ray-origin\n    vec3 rd = normalize(vec3(uv * fov, 1.0));           // Ray-direction (normalize to 1 so just get dir)\n    \n    // Mouse-click camera rotation (comment out if you don't want it)\n    // Vertical camera rotation (Goes first)\n    r0.yz *= rot2D(-mouseInput.y);                               // Y-component change for ray-origin\n    rd.yz *= rot2D(-mouseInput.y);                               // Y-component change for ray-direction\n    \n    // Horizontal camera rotation\n    r0.xz *= rot2D(-mouseInput.x);                               // Y-component change for ray-origin\n    rd.xz *= rot2D(-mouseInput.x);                               // Y-component change for ray-direction\n    \n    \n    //---------------------------------------------------\n    \n    // Perform any transformations you want before ray-march call\n    \n    //---------------------------------------------------\n    \n    \n    vec4 col = rayMarch(r0, rd);                        // Ray-marcher call\n    \n    \n    // Output to screen\n    fragColor = vec4(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}