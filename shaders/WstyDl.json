{
    "Shader": {
        "info": {
            "date": "1602588047",
            "description": "Insertion of transparent & refractive objects to the regular grid. Boxes are raytraced, crystals are raymarched.",
            "flags": 0,
            "hasliked": 0,
            "id": "WstyDl",
            "likes": 36,
            "name": "Crystal Field",
            "published": 3,
            "tags": [
                "reflection",
                "grid",
                "refraction",
                "diamond",
                "occlusion",
                "ambient",
                "dispersion",
                "gem",
                "crystal"
            ],
            "usePreview": 1,
            "username": "TDM",
            "viewed": 1070
        },
        "renderpass": [
            {
                "code": "/*\n * \"Crystal Field\" by Alexander Alekseev aka TDM - 2020\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\n// comment some of these to get better performance\n#define AA\n#define DISPERSION\n\nconst int NUM_STEPS = 24;\nconst int NUM_REFR_ITER = 30;\nconst float TRESHOLD \t= 1e-4;\nconst float EPSILON \t= 1e-4;\nconst float PI \t\t\t= 3.141592;\nconst float IOR = 0.7;\n\nfloat isCrystalf(vec2 c) {\n    return step(0.8,hash12(c));\n}\nbool isCrystal(vec2 c) {\n    return hash12(c) > 0.8;\n}\nfloat cellHeight(vec2 c) {\n    vec3 rnd = hash32(-c*16.7);\n    float h = rnd.x * 1.8;\n    h += sin((c.x+c.y)*0.2+iTime*1. + rnd.y) * 0.5;\n    h += sin((c.x-c.y)*0.4+iTime*.5 + rnd.z) * 0.5;\n    h += isCrystalf(c);\n    h += pow(dot(c,c) * 0.003,3.0);\n    return h;\n}\n\nfloat crystalSDF(vec3 p, in vec2 cell) {\n    float h = cellHeight(cell);\n    p.y -= h - 100.0;\n    \n    //return rbox(-p,vec2(0.4,100.0).xyx);\n    \n    p.xz = rotateZ(p.xz,sin(iTime)+(h-2.0));\n    vec3 rp = vec3(rotateZ(p.xz,PI*0.25),p.y).xzy;\n    float d = rbox(-rp,vec2(0.45,100.0).xyx);\n\td = max(d, rbox(-p,vec2(0.45,100.0).xyx));\n    d = max(d, octahedron(p,100.0));\n    return d;\n}\n\nvec3 getCrystalNormal(vec3 p, in vec2 cell, float dens) {\n    vec3 n;\n    n.x = crystalSDF(vec3(p.x+EPSILON,p.y,p.z), cell);\n    n.y = crystalSDF(vec3(p.x,p.y+EPSILON,p.z), cell);\n    n.z = crystalSDF(vec3(p.x,p.y,p.z+EPSILON), cell);\n    n = n - crystalSDF(p, cell);   \n    float cr = (tri(p.y*1.4) + tri(p.y*2.7)) * 0.4;\n    n.y += cr * 1e-4;\n    return normalize(n);\n}\n\nfloat getAO(vec3 p, vec3 n, in vec2 c) { \n    vec2 cell_coord = fract(p.xz);\n    \n    float dhc = cellHeight(c);\n    vec4 dh = vec4(cellHeight(c-vec2(1.0,0.0)),\n                   cellHeight(c+vec2(1.0,0.0)),\n                   cellHeight(c-vec2(0.0,1.0)),\n                   cellHeight(c+vec2(0.0,1.0))) - p.y;\n    vec4 side = max(-dh,0.0) / (dhc - min(dh,0.0) - p.y) * 0.75;\n    dh = max(dh, 1e-5);    \n    \n    vec4 aot = min(smix(0.5,1.0,vec4(cell_coord,1.0-cell_coord).xzyw/dh), vec4(1.0));\n    vec4 aos = min(mix(vec4(0.5),vec4(1.0), 1.0-(1.0-side)*max(n.xxzz*vec4(-1.,1.,-1.,1.),0.0)), 1.0);\n    float hao = 1.0 - (dhc - p.y) * 0.4;\n    //aot = 1.0 - (1.0 - aot) * n.y;        \n    \n    float ao = aot.x * aot.y * aot.z * aot.w * \n        \t   aos.x * aos.y * aos.z * aos.w * hao;\n    return ao;//clamp(ao,0.0,1.0);\n}\n\n\n/*\n * grid tracing\n */\n\nvec3 marchCrystal(vec3 ori, vec3 dir, vec2 t_range, vec3 cell_origin, vec2 cell, out vec3 p) {\n    float t = t_range.x;\n    float d = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        p = ori + dir * t;\n        d = crystalSDF(p - cell_origin, cell);\n        if(abs(d) <= TRESHOLD || t >= t_range.y) break;\n        t += d - TRESHOLD;\n    } \n    return vec3(d, t, step(t,t_range.y-EPSILON));\n}\n\nfloat advance(in vec3 ori, in vec3 dir, float t) {\n    vec2 dir2 = normalize(dir.xz);\n    float cosa = dot(dir.xz,dir2);\n    \n    // cell id & internal offset\n    vec3 p = ori + dir * t;\n    vec2 offset = fract(p.xz);\n\n    // next t \n    vec2 t0 = offset / -dir2;\n    vec2 t1 = (1.0-offset) / dir2;\n    t0 = max(t0,t1);\n    float nt = min(t0.x,t0.y);\n    return t + nt / cosa;\n}\n\nvec3 trace(vec3 ori, vec3 dir, vec2 uv, int max_iter,  out vec3 p, out vec3 n, out vec2 c) {\n    vec2 dir2 = normalize(dir.xz);\n    float cosa = dot(dir.xz,dir2);\n    \n    float t = 0.0;\n    for(int i = 0; i < 60 && i < max_iter; i++) {\n        \n        // cell id & internal offset\n        p = ori + dir * t;\n    \tc = p.xz;\n        vec2 offset = fract(c);\n        c = floor(c);\n        \n        // next t \n        vec2 t0 = offset / -dir2;\n        vec2 t1 = (1.0-offset) / dir2;\n        t0 = max(t0,t1);\n        float nt = min(t0.x,t0.y);\n        nt = t + nt / cosa;\n        \n        // march the cell\n        vec3 cell_origin = vec3((c+0.5),0.0).xzy;\n        if(isCrystal(c)) {            \n            vec3 st_res = marchCrystal(ori,dir,vec2(t,nt),cell_origin,c,p);\n            if(st_res.z > 0.5) {\n                n = getCrystalNormal(p - cell_origin, c, st_res.x); \n                return st_res;\n            }\n        } else {\n            vec2 nf;\n    \t\tfloat h = cellHeight(c);\n            vec3 ori2 = ori - cell_origin;\n    \t\tori2.y -= h - 100.0;\n            if(intersectionRayBox(ori2,dir,vec2(0.45,100.0).xyx,p,n,nf) > 0.5) {\n        \t\tp = ori + dir * nf.x;\n                return vec3(0.0,nf.x,1.0);\n            }\n        }\n        \n        t = nt + EPSILON;\n    }\n    return vec3(0.0);\n}\n\n/*\n * color\n */\n\nvec3 getCellColor(vec2 cell) {\n    vec3 rnd = hash32(cell);   \n    rnd = vec3(step(0.9,rnd.x), step(0.7,rnd.x), step(0.8,rnd.x));\n    return rnd * 0.5 + 0.5;\n}\n\nvec3 getBlockColor(vec3 p, vec3 n, vec2 cell) {\n\tvec3 localy_p = p - vec3(0.0,cellHeight(cell),0.0);\n    vec2 tuv = mix(mix(localy_p.xz * 1.2,\n                       localy_p.yz * 1.13,\n                       abs(n.x)),\n                   localy_p.yx * 0.92,\n                   abs(n.z));\n\n    vec3 color = texture(iChannel0,tuv).xyy * vec3(1.0,1.3,1.3);\n    color = pow(color,vec3(2.2));// * getCellColor(cell);\n\n    vec3 l0 = normalize(vec3(1.0,0.5,0.4));\n    color += color * max(dot(n,l0),0.0);\n    \n    color *= getAO(p,n,cell);\n    \n    return color;\n}\n\nvec3 addFog(vec3 color, vec3 dir, vec3 traceinfo) {\n    vec3 bg = vec3(1.5) * (dir.y * 0.25 + 0.75) * smoothstep(-1.0,0.0,dir.y);\n    float fog = clamp(log(traceinfo.y*0.08)/log(10.0), 0.0,1.0);\n    fog = 1.0 - (1.0-fog) * traceinfo.z;\n    return mix(color,bg, fog);\n}\n\nvec3 getRefractedColor(vec3 ori, vec3 dir, vec3 n, vec3 p, vec2 c, float eta) {\n    vec3 rdir = refract(dir,n,eta);\n    ori = p + rdir * advance(p,rdir,0.0);   \n\n    vec3 cr_p, cr_n;\n    vec2 cr_cell;\n    vec3 cell_origin = vec3((c+0.5),0.0).xzy;           \n    vec3 st_res = marchCrystal(ori,-rdir,vec2(0.0,1.5),cell_origin,c,cr_p);\n    cr_n = getCrystalNormal(cr_p - cell_origin, c, st_res.x);                               \n    \n    //vec3 refl_dir = reflect(rdir,-cr_n);    \n    rdir = refract(rdir,-cr_n,eta);\n    //float fresnel = pow(1.0 - max(dot(cr_n,rdir),0.0), 5.0);\n    ori = cr_p + rdir * advance(cr_p,rdir,0.0);\n\n    vec3 cr_ti = trace(ori,rdir,vec2(0.0),NUM_REFR_ITER, cr_p,cr_n,cr_cell);\n    vec3 color = getBlockColor(cr_p, cr_n, cr_cell);\n    \n    // internal reflection    \n    /*ori = cr_p + rdir * advance(cr_p,rdir,0.0);\n    cr_ti = trace(ori,refl_dir,vec2(0.0),NUM_REFR_ITER, cr_p,cr_n,cr_cell);\n    vec3 refl_color = getBlockColor(cr_p, cr_n, cr_cell);        \n    color = mix(color,refl_color,fresnel);*/\n    \n    color = addFog(color,rdir,cr_ti);\n\n    return color;\n}\n\nvec3 getPixel(vec2 uv) {\n    // ray\n    vec3 ang = vec3(0.0,0.56 - sin(iTime*0.2)*0.05,iTime * 0.1);\n    mat4 rot = fromEuler(ang);\n    \n    vec3 ori = vec3(0.0,-4.0,15.0);\n    vec3 dir = normalize(vec3(uv.xy,-1.7)); dir.z += length(uv) * 0.08;    \n    \n    // DOF\n#ifdef AA    \n    vec2 offset = (hash32(uv*825.7).xy * 2.0 - 1.0) * 0.01;\n    dir.xy += offset;\n    ori.xy -= offset * 5.;    \n#endif\n    \n    dir = normalize(dir);\n    ori = rotate(ori,rot);\n    dir = rotate(dir,rot);\n    dir.xz = rotateZ(dir.xz,sin(iTime*0.17)*0.5);\n    \n    // tracing\n    vec3 p,n;    \n    vec2 cell;\n    vec3 traceinfo = trace(ori,dir,uv,100, p,n,cell);        \n    vec3 color;\n    \n    // crystal\n    if(isCrystal(cell)) {     \n    \t#ifdef DISPERSION\n            color.z = getRefractedColor(ori,dir,n,p,cell,mix(IOR,1.0,0.75)).z;\n            color.yz += getRefractedColor(ori,dir,n,p,cell,mix(IOR,1.0,0.5)).yz;\n            color.xy += getRefractedColor(ori,dir,n,p,cell,mix(IOR,1.0,0.25)).xy;\n            color.x += getRefractedColor(ori,dir,n,p,cell,IOR).x;\n        #else\n        \tcolor = getRefractedColor(ori,dir,n,p,cell,IOR);\n        #endif\n        color *= getCellColor(cell);\n        \n        \n    // regular block\n    } else {\n        color = getBlockColor(p, n, cell);        \n    }    \n    \n    // reflection \n    float fresnel = pow(1.0 - max(dot(n,-dir),0.0), 4.0);\n    vec3 rdir = reflect(dir,n);\n    ori = p + rdir * advance(p,rdir*0.990,0.0); \n    vec3 r_traceinfo = trace(ori,rdir,vec2(0.0),NUM_REFR_ITER, p,n,cell);\n    vec3 refl = getBlockColor(p, n, cell); \n    refl = addFog(refl,rdir,r_traceinfo); \n    color = mix(color,refl, fresnel);        \n        \n    color = addFog(color,dir,traceinfo);\n    return color;\n}\n\n/*\n * main\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n#ifdef AA\n    vec3 color = vec3(0.0);\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 uv = (fragCoord+vec2(i,j)/3.0) / iResolution.xy;\n            uv = uv * 2.0 - 1.0;\n            uv.x *= iResolution.x / iResolution.y; \n    \t\tcolor += getPixel(uv);\n        }\n    }\n    color /= 9.0;\n#else    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y; \n    vec3 color = getPixel(uv);\n#endif\n    \n    color *= vec3(1.4,1.7,1.7);\n    color = pow(color,vec3(1.0/2.2));\n    \n\tfragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n * \"Crystal Field\" by Alexander Alekseev aka TDM - 2020\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\n\nmat4 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat4 m;\n    m[0] = vec4(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x,0.0);\n\tm[1] = vec4(-a2.y*a1.x,a1.y*a2.y,a2.x,0.0);\n\tm[2] = vec4(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y,0.0);\n\tm[3] = vec4(0.0,0.0,0.0,1.0);\n\treturn m;\n}\nvec2 rotateZ(vec2 v, float a) {\n    vec2 sc = vec2(sin(a),cos(a));\n    vec2 ret = v;\n    ret.x = v.x * sc.y - v.y * sc.x;\n    ret.y = v.x * sc.x + v.y * sc.y;\n    return ret;\n}\nvec3 rotate(vec3 v, mat4 m) {\n    return vec3(dot(v,m[0].xyz),dot(v,m[1].xyz),dot(v,m[2].xyz));\n}\nfloat smix(float a, float b, float t) {\n    t = clamp(t,0.0,1.0);\n    return mix(a,b, t*t*(3.0-2.0*t));\n}\nvec4 smix(float a, float b, vec4 t) {\n    t = clamp(t,0.0,1.0);\n    return mix(vec4(a),vec4(b), t*t*(3.0-2.0*t));\n}\nfloat tri(float x) {\n    return 1.0 - abs(fract(x) - 0.5) * 4.0;\n}\n\nfloat intersectionRayBox(vec3 o, vec3 d, vec3 ext, out vec3 r0, out vec3 nrm, out vec2 t) {\n    vec3 t0 = (-o - ext) / d;\n    vec3 t1 = (-o + ext) / d;\n    vec3 n = min(t0,t1); t.x = max(max(n.x,n.y),n.z);\n    vec3 f = max(t0,t1); t.y = min(min(f.x,f.y),f.z);\n    r0 = o + d * t.x;\n    nrm = abs(r0/ext);\n    nrm = step(vec3(max(max(nrm.x,nrm.y),nrm.z)),nrm) * sign(r0);\n    return step(t.x,t.y);\n}\n\n// SDF\nfloat rbox(vec3 p,vec3 s) {\n\tp = abs(p)-s;\n    return length(p-min(p,0.0));\n}\nfloat octahedron(vec3 p, float s) {\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\treturn m*0.57735027;\n}\n\n// hash\nfloat hash12(in vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nvec3 hash32(in vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}