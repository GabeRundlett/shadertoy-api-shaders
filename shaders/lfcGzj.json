{
    "Shader": {
        "info": {
            "date": "1711888557",
            "description": "Done while being at the Revision demoscene-party 2024 in Saarbr端cken, Germany. With lots of debugging done elsewhere, there was not much room for real creative inspiration, but I had to do at least a tiny bit. This is the result.",
            "flags": 64,
            "hasliked": 0,
            "id": "lfcGzj",
            "likes": 5,
            "name": "Torus-cavity wax-like thing",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "sdf",
                "revision",
                "2024"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 241
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Torus-cavity wax-like thing - done while being at the Revision demoscene-party\n// 2024 in Saarbr端cken, Germany... with lots of debugging done elsewhere, there\n// was not much room for real creative inspiration, but I had to do at least a\n// tiny bit... this is the result... a variation of www.shadertoy.com/view/lsVfW1\n//\n// Copyright 2024 Mirco M端ller\n//\n// Author(s):\n//   Mirco \"MacSlow\" M端ller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n#define MAX_STEPS 80\n#define STEP_BIAS .5\n#define EPSILON .0002\n#define PI 3.14159265359\n\nstruct Result {\n\tfloat d;\n\tint id;\n};\n\nfloat hashn (vec3 p, float t)\n{\n    p = fract (p*.3183099 + .1);\n    p *= 17.;\n    return max (fract (p.x*p.y*p.z*(p.x + p.y + p.z)), 1. - t);\n}\n\nfloat noise (in vec3 x, in float t)\n{\n    vec3 p = floor (x);\n    vec3 f = fract (x);\n    f = f*f*(3. - 2.*f);\n\t\n    return mix(mix(mix( hashn(p+vec3(0,0,0), t), \n                        hashn(p+vec3(1,0,0), t),f.x),\n                   mix( hashn(p+vec3(0,1,0), t), \n                        hashn(p+vec3(1,1,0), t),f.x),f.y),\n               mix(mix( hashn(p+vec3(0,0,1), t), \n                        hashn(p+vec3(1,0,1), t),f.x),\n                   mix( hashn(p+vec3(0,1,1), t), \n                        hashn(p+vec3(1,1,1), t),f.x),f.y),f.z);\n}\n\nfloat smax (in float a, in float b, in float k)\n{    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\nfloat sdSphere (in vec3 p, in float radius)\n{\n    return length (p) - radius;\n}\n\nfloat sdTorus (in vec3 p, in vec2 t)\n{\n\tvec2 q = vec2 (length (p.xz) - t.x, p.y);\n\treturn length (q) - t.y;\n}\n\nfloat sdBox (in vec3 p, in vec3 b)\n{\n\tvec3 d = abs (p) - b;\n\treturn min (max (d.x, max (d.y, d.z)), .0) + length (max (d, .0));\n}\n\nmat2 r2d (in float degree)\n{\n    float rad = radians (degree);\n    float c = cos (rad);\n    float s = sin (rad);\n\treturn mat2 (c, s, -s, c);\n}\n\nvec3 opTwist (in vec3 p)\n{\n    mat2  m = r2d (p.y*p.x*p.z);\n    vec3  q = vec3 (m*p.xz, p.y);\n    return q;\n}\n\nvec3 sunCenter = vec3 (.0f);\n\nfloat displace (vec3 p)\n{\n\tfloat result = 1.f;\n\tfloat factor = 6.f + 4.f*cos (2.f*iTime);\n\tresult = .375f*sin (factor * p.x)*cos (factor*p.y)*sin (factor*p.z);\n\treturn result;\n}\n\nResult scene (in vec3 p, in float t)\n{\n\tp.xy *= r2d (25.f*iTime);\n\tp.y += 1.25f*cos (iTime);\n\n    vec3 noiseCenter = p;\n    noiseCenter.z -= 2.f; \n    vec3 boxCenter = noiseCenter;\n    vec3 ballCenter = noiseCenter; \n    noiseCenter += .05f*opTwist (.5f*p);\n    noiseCenter.xy *= r2d (2.f*t);\n    noiseCenter.yz *= r2d (-5.f*t);\n    noiseCenter.zx *= r2d (10.f*t);\n\n    float variation = 6.f + 3.f*(.5f + .5f*cos (14.f*t));\n    vec3 offset = vec3 (-5.f, -1.f, 1.f)*t*.5f;\n\tfloat f = 3.f + 2.5f*(.5f + .5f*cos (2.5f*t));\n    float structure = noise (f*noiseCenter + offset, variation) -\n\t\t\t\t\t\t\t .65f + (sin (t) + 1.f)*.05f;\n\n\tvec2 torusSizes = vec2 (2.25f, 1.5f);\n\tfloat torus = sdTorus (ballCenter - vec3 (1.f*sin(iTime), .0f, .0f),\n\t\t\t\t\t\t   torusSizes);\n    float box = sdBox (boxCenter, vec3 (8.f));\n\n\tfloat r1 = 1.5f;\n\tfloat x = 1.f*sin(iTime) + r1*cos (iTime);\n\tfloat y = .7f*cos (3.f*iTime);\n\tfloat z = .0f + r1*sin (iTime);\n\tsunCenter = ballCenter - vec3 (x, y, z);\n\n\tsunCenter.xz *= r2d (74.f*iTime);\n\tsunCenter.yx *= r2d (95.f*iTime);\n\tsunCenter.zy *= r2d (-85.f*iTime);\n\tfloat r2 = .35f;\n\tfloat a = sdSphere (sunCenter, r2);\n\tfloat b = displace (sunCenter);\n\tfloat sun = a + b;\n\n    float ball = sdSphere (ballCenter, 1.5f + .5f*(.5f + .5f*cos (t)));\n    ball = min (ball, torus);\n    structure = smax (-torus, structure*.25f, .25f);\n\tfloat bone = smax (box, structure, .2f);\n\n\tfloat d = min (sun, bone);\n\tint id = (d >= sun) ? 0 : 1;\n\tResult res = Result (d, id);\n\n    return res;\n}\n\nfloat distriGGX (in vec3 N, in vec3 H, in float roughness)\n{\n    float a2     = roughness * roughness;\n    float NdotH  = max (dot (N, H), .0);\n    float NdotH2 = NdotH * NdotH;\n\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.) + 1.);\n    denom        = PI * denom * denom;\n\n    return nom / denom;\n}\n\nfloat geomSchlickGGX (in float NdotV, in float roughness)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1. - roughness) + roughness;\n\n    return nom / denom;\n}\n\nfloat geomSmith (in vec3 N, in vec3 V, in vec3 L, in float roughness)\n{\n    float NdotV = max (dot (N, V), .0);\n    float NdotL = max (dot (N, L), .0);\n    float ggx1 = geomSchlickGGX (NdotV, roughness);\n    float ggx2 = geomSchlickGGX (NdotL, roughness);\n\n    return ggx1*ggx2;\n}\n\nvec3 fresnelSchlick (in float cosTheta, in vec3 F0, float roughness)\n{\n\treturn F0 + (max (F0, vec3 (1.f - roughness)) - F0)*\n\t\t   pow (1.f - cosTheta, 5.f);\n}\n\nvec3 normal (vec3 p, float epsilon, in float t)\n{\n    float d = scene (p, t).d;\n    vec2 e = vec2 (epsilon, .0f);\n    return normalize (vec3 (scene(p + e.xyy, t).d,\n                            scene(p + e.yxy, t).d,\n                            scene(p + e.yyx, t).d) - d); \n}\n\nResult trace (in vec3 o, in vec3 r)\n{\n\tResult res = Result (.0f, 0);\n    float t = .0f;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n\t\tvec3 p = o + r*t;\n\t\tres = scene (p, iTime);\n\t\tif (abs (res.d) < EPSILON*(1.f + .125*res.d)) break;\n\t\tt += res.d*STEP_BIAS;\n    }\n\tres.d = t;\n\n    return res;\n}\n\nfloat shadow (in vec3 p, in vec3 n, in vec3 lPos)\n{\n\tfloat distanceToLight = distance (lPos, p);\n\tfloat distanceToObject = trace (p + .01f*n,\n\t\t\t\t\t\t\t\t\tnormalize (lPos - p)).d;\n\tbool isShadowed = distanceToObject < distanceToLight;\n\treturn isShadowed ? .1 : 1.;\n}\n\nvec3 shade (in vec3 ro, in vec3 rd, in float d, in float t, in int id)\n{\n    vec3 p = ro + d * rd;\n    vec3 nor = normal (p, d*EPSILON, t);\n\n    // \"material\" hard-coded for the moment\n    vec3 albedo = vec3 (.275f);\n    float metallic = .15f;\n    float roughness = .125f;\n\n\tif (id == 0) {\n    \talbedo = vec3 (.1f, .2f, .4f);\n    \tmetallic = .02f;\n    \troughness = .1f;\n\t}\n\n    // lights hard-coded as well atm\n    vec3 lightColors[2];\n    lightColors[0] = .5f*vec3 (.5f, .2f, .1f);\n    lightColors[1] = .5f*vec3 (.1f, .3f, .5f);\n\n    vec3 lightPositions[2];\n    float c = cos (t);\n    float s = sin (t);\n    lightPositions[0] = vec3 (-.5*c, -.5*s, -.1);\n    lightPositions[1] = vec3 (.5*c, .5*s, 1.);\n\n\tvec3 N = normalize (nor);\n    vec3 V = normalize (ro - p);\n\n    vec3 F0 = vec3 (.04);\n    F0 = mix (F0, albedo, metallic);\n    vec3 kD = vec3 (.0);\n\t           \n    // reflectance equation\n    vec3 Lo = vec3 (.0f);\n    for (int i = 0; i < 2; ++i) \n    {\n        // calculate per-light radiance\n        vec3 L = normalize (lightPositions[i] - p);\n        vec3 H = normalize (V + L);\n        float dist = distance (p, lightPositions[i]);\n        float attenuation = 2.f/(dist*dist);\n        vec3 radiance = lightColors[i]*attenuation;\n        \n        // cook-torrance brdf\n        float aDirect = pow (roughness + 1.f, 2.f);\n        float aIBL =  roughness * roughness;\n        float NDF = distriGGX (N, H, roughness);\n        float G = geomSmith (N, V, L, roughness);\n        vec3 F = fresnelSchlick (max (dot (H, V), .0f), F0, roughness);\n\n        vec3 kS = F;\n        kD = vec3 (1.f) - kS;\n        kD *= 1.f - metallic;\n        \n        vec3 nominator = NDF * G * F;\n        float denominator = 4.f*max (dot (N, V), .0f)*max (dot (N, L), .0f);\n        vec3 specular = nominator / max (denominator, .001f);\n\n        // add to outgoing radiance Lo\n        float NdotL = max (dot (N, L), .0f);\n        Lo += (kD*albedo/PI + specular)*radiance*NdotL;\n    }\n\n    vec3 ambient = kD * albedo;\n\n    return ambient + Lo;\n}\n\n\nvec3 camera (in vec3 ro, in vec3 aim, in float zoom, in vec2 uv)\n{\n\tvec3 forward = normalize (aim - ro);\n\tvec3 worldUp = vec3 (.0, 1., .0);\n\tvec3 right = normalize (cross (forward, worldUp));\n\tvec3 up = normalize (cross (right, forward));\n\tvec3 center = ro + forward*zoom;\n\n\treturn normalize (center + uv.x*right + uv.y*up - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize and aspect-correct\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // set up view-ray/\"camera\"\n    vec3 ro = vec3 (.0f, .0f, -.95f);\n\tvec3 rd = camera (ro, vec3 (.0f), 1.05f, uv);\n\n    // determine pixel-color\n    Result res = trace (ro, rd);\n    vec3 color = shade (ro, rd, res.d, iTime, res.id);\n\n    // tone-map, gamma-correct, \"fog\"\n    color = color / (1.f + color);\n    color = pow (color, vec3 (1.f/2.2f));\n    color *= 2.15f - res.d*.3125f;\n\n    fragColor = vec4 (color, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 37037,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/lukhash/demoscene"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}