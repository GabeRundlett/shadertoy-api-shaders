{
    "Shader": {
        "info": {
            "date": "1574256142",
            "description": "Using one cubemap face to store a few 3D distance fields, then using them to create and raymarch an asteroid field in realtime.",
            "flags": 0,
            "hasliked": 0,
            "id": "tsGXWm",
            "likes": 112,
            "name": "Asteroid Debris",
            "published": 3,
            "tags": [
                "3d",
                "volume",
                "raymarch",
                "cube",
                "space",
                "map",
                "field",
                "rock",
                "asteroid"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 2666
        },
        "renderpass": [
            {
                "code": "/*\n\n\tAsteroid Debris\n    ---------------\n\n    Packing a few 3D distance fields into one face of the cubemap to raymarch\n\tan asteroid field in realtime.\n\t\n\tIn regard to the scene itself, I'm basically paying hommage to IQ's Leizex \n\tdemonstration, which has always been a favorite of mine -- The link is below,\n\tfor anyone who hasn't seen it. The main difference between this example and\n\tIQ's is that I have the benefit of coding on a system from over a decade \n\tafter he made it. The inspiration to do this in the first place came from\n\tTDHooper's awesome \"Copper \\ Flesh\" example -- The link to that is below also.\n\n    As far as the physics engine and lighting goes... Well, it doesn't. It's all \n\tmade up, so I'd pretty much ignore that part of it. :D The main focus of this\n\tdemonstration was to fill up a 100 sided voxel cube with distance equations, \n\tpack them into one of the cubemap faces, them read them back and render them.\n\n\tIt's almost 2020, and computers have crazy power compared to those 20 years\n\tago. However, raymarching surfaces like this at reasonable frame rates would \n\tstill be impossible without precalculation. Curiosity got the better of me,\n\tso I dropped a less expensive version of this particular surface that was \n\tcalculated on the fly into the raymarching loop and even that virtually \n\tbrought my Alienware machine to a grinding halt. In fact, I have a feeling \n\tthat trying to calculate these fields on the fly as part of a static image \n    inside a pathtracing demonstration would bring about compiler issues.\n\n    There are 3 surfaces here: The first is a couple of layers of 3D gradient \n    noise -- A few years ago, that surface alone would have been a bit much.\n\tThe second and third layers consist of insanely expensive 3D plane-based \n    rounded Voronoi implementations, which involved exponentials and well over \n    a hundred passes each. \n\n\tThere are still a few technicalities you have to overcome. The storage size\n\ton the cube map is fantastic - There are six 1024 by 1024 RGBA face textures.\n\tHowever, you still need to make a choice between resolution and speed. Within\n\treason, you can take as long as you want to construct your surfaces and pack\n\tthem into the cube map. However, reading them out in realtime needs to be \n\tefficient. For now, I've taken the easy route and packed in a cube with 100\n\tpixels for each of the XYZ positions -- It's an obvious choice, since 100\n\tcubed is a million pixels which is just shy of 1024 x 1024. This means one\n\tsurface per channel, or three surfaces per texel read -- The last channel is \n\tused to store resolution for screen size changes, etc, since the \"iFrame\"\n\tvariable is not reliable -- Well, not for me anyway.\n\n    Looking up a single voxel value when reconstructing the surface won't cut it,\n\tso an interpolation of 8 neighboring voxels is necessary, which means 8 texel\n\treads inside the distance function. My machine can do that with ease, but in\n\tthe future, I'll have to cut it down, and I know of of a few ways to do that.\n\n\tAnyway, this was just a simple demonstration to get something on the board,\n\tas they say. I have more interesting examples coming. As for improvements to\n\tbe made, there are too many to name. One obvious one, is making better use\n\tof the cubemap, since I'm using just a small portion of it. You could use all \n\tfour channels in one 1024 by 1024 face texture, and have enough room for a \n\tcube with side dimensions of 160 pixels. Using all four channels would add to \n    the technicality, but I think I know of a way to bring the rendering side \n    down from 8 interpolated texture reads to just 3, or even two, but don't \n\tquote me on that. :)\n\n\n   \n    Inspired by:\n\n\t// Really nice example, and the thing that motivated me to get in amongst it\n\t// and finally learn to read and write from the cube map. I have a few 3D \n    // examples coming up, which use more simplistic formulae, but I couldn't tell \n    // you whether that translates to extra speed or not. Knowing how I code, \n    // probably not. :D\n    Copper / Flesh - tdhooper\n    https://www.shadertoy.com/view/WljSWz\n\n\n\tLoosely based on:\n    \n    // I used to marvel at this a few years ago. Even today, it's a\n    // nice looking piece of imagery.\n    Leizex (made in 2008) - iq\n    https://www.shadertoy.com/view/XtycD1\n\n\n    2D usage of a cubemap:\n\n    // Using a 3D feature to do something in 2D seems counter intuitive. However,\n\t// I find that one cubemap face is more useful for 2D storage than the in-house\n\t// buffers. By the way, Fabrice was already using it for this purpose before\n\t// it was cool. :D\n\tTuring Texture - Shane\n    https://www.shadertoy.com/view/WsGSDR\n\n\n*/\n\n\n// Far distance, or not very far, in this case. :)\n#define FAR 6.\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){\n    \n    // We only want positive normal weightings. The normal is manipulated to suit\n    // your needs.\n    n = max(n*n - .2, .001); // n = max(abs(n) - .1, .001), etc.\n    //n /= dot(n, vec3(1)); // Rough renormalization approximation.\n    n /= length(n); // Renormalizing.\n    \n\tvec3 tx = texture(t, p.yz).xyz; // Left and right sides.\n    vec3 ty = texture(t, p.zx).xyz; // Top and bottom.\n    vec3 tz = texture(t, p.xy).xyz; // Front and back.\n    \n    // Blending the surrounding textures with the normal weightings. If the surface is facing\n    // more up or down, then a larger \"n.y\" weighting would make sense, etc.\n    //\n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n// Camera path.\nvec2 path(float t) { return sin(t*vec2(1, .8)) + sin(t*vec2(.3, .2)); }\n\n\n// Basically the same as what I normally do, but I got this snippet from \n// unnick's \"light at the end of the tunnel\" example, here:\n// https://www.shadertoy.com/view/WsySR1\n//\n// Camera view matrix.\nmat3 getView(float t){\n    \n    const float FOV = 2.;\n    vec3 fwd = normalize(vec3((path(t + .1) - path(t))/.1, FOV));\n    vec3 up = vec3(0., 1, 0) - fwd*fwd.y;\n    vec3 rgt = cross(fwd, up);\n    return transpose(mat3(rgt, -up, fwd));\n}\n\n// Hacky global to record the glow variable to be using in the \"trace\" function.\nvec3 glow3;\n\n\n// The scene function.\nfloat map(vec3 p) {\n    \n    \n    // Gaz's path correction. Very handy.\n    vec2 pth = path(p.z);\n    vec2 dp = (path(p.z + .1) - pth)/.1; // Incremental path diffence.\n    vec2 a = cos(atan(dp)); \n    // Wrapping a tunnel around the path.\n    float tun = length((p.xy - pth)*a);\n    \n    \n    \n    // Obtaining the distanc field values from the 3D data packed into\n    // the cube map face. These have been smoothly interpolated.\n    vec3 tx3D = texMapSmooth(iChannel0, p/3.).xyz;\n    // Using this will show you why interpolation is necessary.\n    //vec3 tx3D = tMap(iChannel0, p/3.).xyz;\n    \n    // The main surface. Just a couple of gradient noise layers. This is used\n    // as a magnetic base to wrap the asteroids around.\n    float main = (tx3D.x - .55)/2.;\n    \n    // Calling the function again, but at a higher resolution, for the other\n    // surfaces, which consist of very expensive rounded Voronoi.\n    tx3D = texMapSmooth(iChannel0, p*2.).xyz;\n    \n    // Saving the higher resolution gradient noise to add some glow. I patched\n    // this in at the last minute.\n    glow3 = tx3D;\n\n    \n    // Attaching the asteroid field to the gradient surface. Basically, the \n    // rocks group together in the denser regions. With doing this, you'd \n    // end up with a constant density mass of rocks.\n    main = smax(main, -(tx3D.z + .05)/6., .17);\n    \n    // Adding a heavy layer of gradient noise bumps to each rock.\n    main += (abs(tx3D.x - .5)*2. - .15)*.04;\n   \n    // Smoothly running the tunnel through the center, to give the camera\n    // something to move through -- Otherwise, it'd bump into rocks. Getting \n    // a tunnel to run through a group of rocks without warping them was \n    // only possilbe because of the way the rocks have been constructed.\n    return smax(main, -tun, .25);\n    \n}\n\n\n// Surface bump function.\nfloat bumpSurf3D( in vec3 p){\n    \n    \n    // Obtaining the distanc field values from the 3D data packed into\n    // the cube map face. These have been smoothly interpolated.\n    vec3 tx3D = texMapSmooth(iChannel0, p*6.).xyz;\n    \n    // This is a mixed rounded Voronoi surface, moulded to look a bit lit\n    // holes or craters for that pitted look.\n    return tx3D.y;\n}\n\n// Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n// a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(.001, 0); \n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    float ref = bumpSurf3D(p);\n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx)) - ref)/e.x; \n    \n    /*\n    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n                     bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n                     bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    */\n       \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= nor*dot(nor, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(nor + grad*bumpfactor);\n\t\n}\n\n/*\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    ro += n*.002;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .025, .35); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n*/\n        \n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 4., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n\n \n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 normal(in vec3 p, float ef) {\n\tvec2 e = vec2(.001*ef, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n// Hacky global for the glow.\nfloat glow;\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd, in vec3 lp){\n\n    float t = 0., d;\n    \n    float l = length(lp - ro);\n    \n    glow = 0.;\n    \n    for(int i = min(iFrame, 0); i<128; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001*(t*.1 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        \n        //float l2D = l;//length(l2 - pp);\n        // Distance based falloff.\n        //float aD = abs(d);\n        //if(aD<.15) glow += 1.*(.15 - aD)/(.0001 + l2D*l2D);\n        // Accumulating the attenuation, whilst applying a little noise.\n        //\n        glow += .04/(.0001 + l)*glow3.x;//\n        \n        // In an ideal world, we'd only render functions with Lipschitz contants within\n        // acceptable ranges (less than one, I think), but with anything interesting,\n        // it rarely happens. Therefore, hacks like ray shortening are necessary.\n        t += d*.7;\n    }\n    \n\n    // Clip the distance to the maximum to avoid artifacts. \n    return min(t, FAR);\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    \n    // Aspect correct screen coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    // Slight barrel distortion.\n    float r = dot(uv, uv);\n    uv *= 1. + .15*(r*r + r);\n    \n    // Time for the camera and light, viewing matrix and\n    // the unit direction ray.\n    vec2 tm = vec2(iTime/2.) + vec2(0, 1.25);\n    mat3 vMat = getView(tm.x);\n    vec3 rd = normalize(vec3(-uv, 1.))*vMat;\n    \n    // Moving the camera and the light along the path.\n    vec3 ro = vec3(path(tm.x), tm.x);\n    vec3 lp = vec3(path(tm.y), tm.y);\n    \n    \n    // Raymarch the scene.\n    float t = trace(ro, rd, lp);\n    \n    // Initiate the scene color to zero.\n    vec3 col = vec3(0);\n    \n    // If we've hit something, light it up.\n    if (t<FAR){\n        \n        \n        // Surface postion and the normal at that position.\n        vec3 sp = ro + rd*t;\n        vec3 sn = normal(sp, 1.);\n        \n        \n         \n        // Function based bump mapping.\n        sn = doBumpMap(sp, sn, .01);///(1. + t*t/FAR/FAR*.25)\n      \n        \n       \n        // Trusty \"Rusty Metal\" texture -- I'm trying to set a Shadertoy\n        // record for its overusage. :D\n        vec3 tx = tex3D(iChannel1, sp*2., sn);\n        tx = smoothstep(-.1, .5, tx);\n        \n        // Set the asteroid color to the texture color.\n        vec3 oCol = tx*2.;\n        \n        \n        // Applying some extra shading to the bumped craters.\n        float ns = bumpSurf3D(sp);\n        oCol *= ns*1.5;\n       \n       \n    \n        // I noticed that the soft shadows weren't contributing enough to the scene, so \n        // figured, I may as well go with something cheaper. Just for the record, this\n        // example still runs pretty quickly with them as well.\n        \n        // Needs to match the frequency of that in the distance function.\n        vec3 tx3D = texMapSmooth(iChannel0, (sp/3.)).xyz;\n        //\n        //float sh = softShadow(sp, lp, sn, 8.);\n        float sh = tx3D.x;\n        float ao = calcAO(sp, sn); // Ambient occlusion.\n        // Ramping up the ambient occlusion, since they're now faking the job of the light\n        // shadows as well.\n        ao *= ao; \n        sh = min(sh + ao*.3, 1.);\n\n\n        // Surface to light vector, corresponding distance, then normalizing \"ld.\"\n        vec3 ld = lp - sp;\n        float lDist = max(length(ld), .001);\n        ld /= lDist;\n\n        // Light and distance attenuation: The scene can get a little speckly in the distance, \n        // so I've attenuated the light that reaches the viewer with respect to distance also.\n        // I don't often do it, but it seemed necessary here.\n        float atten = 1./(1. + lDist*lDist*.25)/(1. + t);\n       \n\n        // Diffuse, specular and Fresnel calculations.\n        float dif = max(dot(ld, sn), 0.); // Diffuse term.\n        float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 32.); // Specular term.\n        float fre = clamp(1.0 + dot(rd, sn), 0., 1.); // Fresnel reflection term.\n        \n        \n        /*\n        // Electric charge: I could not make this work, but at least I tried, so I get\n        // participation award, right? :D I'll tweak it later, and see whether I can make \n        // it work. :)\n        float hi = smoothstep(.0, .1, abs(n3D(sp + vec3(0, 0, iTime)) - .5)*2.);\n        oCol += fre*glow*vec3(.1, 1, .7)*.25/(.01 + hi*hi)/(1. + t*.25);\n        */\n \n        // Applying the above to produce a color.\n        col = oCol*(dif*vec3(4, .8, .5) + vec3(2, .7, .4)*spe + vec3(.1, .3, 1)*fre + ao*.2);\n        \n        \n        // A bit of reflection. I put this in as an afterthought.\n        col += col*vec3(1, .7, .3)*fBm2(32.*reflect(rd, sn));\n \n       \n        // Applying the ambient occlusion, very fake shadow term and light attenuation.\n        col *= ao*sh*atten;\n   \n    }\n    \n    // Combine the scene with a gradient fog color.\n    vec3 sky = mix(vec3(1), vec3(.6, .8, 1), -rd.y*.5 + .5);\n     \n    \n   \n    \n    // Mix the gradients using the Y value of the unit direction ray. \n    vec3 fog = mix(vec3(.5, .7, 1), vec3(.7, .6, .5), pow(max(rd.y*.7, 0.), 1.));\n    col = mix(col, fog, smoothstep(0., .95, t/FAR)); // Linear fade. Much dustier. I kind of like it.\n    //col = mix(col, fog, min(t*t*2./FAR/FAR, 1.)); // Quadratic fade off. More subtle.\n\n    // Simulating mild sun scatter over scene: IQ uses it in his Elevated example.\n    // The context in which I'm using it is not really physically correct, but it's only\n    // mild, and I like the scattering effect.\n    vec3 gLD = normalize(lp - ro);\n    col += (dot(col, vec3(.299, .587, .114)) + .5)*sky.zyx*pow( max(dot(rd, gLD), 0.), 4.)*.2;\n    \n    \n    // Adding in the glow.\n    col += (col*.5 + .5)*vec3(.05, .2, 1)*min(glow, 1.);\n   \n\n    // Mild gamma correction before presenting to the screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// The cubemap routine. \n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n \n    // UV coordinates.\n    // \n    // I'm guessing here, but in this particular tab, \"iResolution.xy\" is\n    // simply the dimension of the cubemap faces, or 1024 by 1024. This \n    // caused me a lot of confusion for a while. :)   \n    //\n    // For whatever reason (which I'd love expained), the Y coordinates flip each\n    // frame, if I don't negate the coordinates here -- I'm assuming this is internal, \n    // a VFlip thing, or there's something I'm missing. If there are experts out \n    // there, any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1));\n    \n   \n    // Color variable: Technically, it's not holding colors, but rather isovalues.\n    vec3 col = vec3(0); \n    \n    \n    // Flag the initialization frame. The calculations below are only performed \n    // once, which is just as well, because they're prohibitively expensive to put\n    // in a raymarching loop. Trust me, I tried, and my computer's still not talking\n    // to me. :D\n    //\n    // To my knowledge, this is the only way to guarantee that the program\n    // doesn't continue on without loading everything in -- Surely, there's\n    // a better way, so if anyone knows of one, feel free to let me know.\n    //\n    if(abs(tx(iChannel0, uv).w - iResolution.y)>.001){\n    // I wish it were a guarantee, because it's heaps easier, but it's not.\n    //if(iFrame==0){ \n         \n        // Convert the standard UV coordinates to to a voxel in a 100 sided\n        // cube. I've seen a few 3D packing examples that convert the \"rayDir\"\n        // vector to cube faces, etc, but it's not necessary here.\n        vec3 p = convertCoord(uv);\n        \n        \n        // It took me a while to convince myself that the wrapping scales only\n        // need to be whole numbers to wrap on a 100 sided cube. They don't need \n        // to be factors of 100... I'm kind of mostly cautiously sure of that. :D\n        //\n        // This particular example needs to wrap. Hence the wrapping variables (gSc).\n        // \n        \n        // Isovalue one. Just a couple of layers of gradient noise. It's used as a\n        // base structure to mold the rocks to.\n        gSc = 12.;\n        float c = gradN3D(p*gSc);\n        gSc = 24.;\n        c = c*.66 + gradN3D(p*gSc)*.34;\n \n\n        // The Voronoi and gradient noise middle-range layers. Used in the distance\n        // function, then reused to bump map a bit of detail onto the asteroid field\n        // rocks -- or whatever you want to call them.\n        gSc = 10.;\n        vec3 v2 = Voronoi(p*gSc, vec3(0));\n        gSc = 40.;\n        float c2 = gradN3D(p*gSc);\n        gSc = 80.;\n        c2 = c2*.66 + gradN3D(p*gSc*2.)*.34;\n        c2 = mix(1. - smoothstep(0., .35, v2.x - .01), c2, .5);\n\n       \n        \n        gSc = 6.;\n        vec3 v3 = Voronoi(p*gSc, vec3(0));\n        // X and Y prefer different smoothstep values.\n        float c3 = smoothstep(0., .525, v3.x);\n        //float c3 = smoothstep(0., .7, v3.y);\n  \n        \n        // Load in the isovalues.\n        col = vec3(c, c2, c3);\n        \n       \n    }    \n    else {\n        \n        // The cubemap isovalues were all calculated in the previous frame, so\n        // all that's needed from this point is a single texel retrieval. I think\n        // there's a way to do it with discard as well, but I'm not positive.\n        col = tx(iChannel0, uv).xyz;\n  \n    }\n     \n   \n    // Storing the three isovalues in the first three channels, and the resolution\n    // in the forth for initialization. It would be nice if Shadertoy had a guaranteed\n    // varibale to flag the first frame after all textures have loaded. I remember\n    // doing this with my own backend code, so I know it's easier said than done, but\n    // it's worth it.\n    fragColor = vec4(clamp(col, -1., 1.), iResolution.y);\n    \n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "/*\n\n    For people who need a quick 3D coordinate packing explanation, or refresher --\n    I always forget, so need to refresh my memory every. single. damn. time. :D\n\n\tAnyway, a 1024 by 1024 texture will have just over a million pixels. What you \n    need to do is choose three dimensions (one for X, Y and Z) that will multiply\n\ttogether to fit into those million pixels -- We'll ignore the four individual\n\tpixel channels, for now. X, Y and Z don't need to be equal, or even, but it's \n\tprobably helpful to choose something simple that will fit into the geometry of \n\tthe situation -- For instance, if you were surfacing a long box, you'd probably\n\twant more X pixels, and fewer Y and Z. \n\n\tTo make things easy, I chose 100 pixels for all three dimensions, since \n\t100x100x100 equals 1 million precisely. This works out nicely. On the texture, \n\tyou render 100 boxes (10 rows of 10) that each have X and Y dimensions of 100. \n\tThe X and Y values are represented by the XY coordinate of each box, and the Z \n\tvalue is represented by the box itself. For instance, the surface value for the\n\tcoordinate \"vec3(20, 40, 45)\" will be found in the 45th box (row 5, column 6) \n    at XY coordinates \"vec2(20, 40).\" Simple.\n\n\tThere is the matter of converting the uv (fragment) coordinates to the 3D \n\tposition, and also converting the 3D position in your scene to the texture \n\tcoordinates in the cube map face, but that's just a bit of math involving \n\tmodulos and so forth, which you can find below.\n\n*/\n\n// Cube size.\nconst vec3 size = vec3(100);\n\n// Cubic texture dimensions. They're large and they're constant, which makes life\n// so much easier.\nvec2 cubeMapRes = vec2(1024);\n\n// Global texture scaling variable. I probably should have built it into various\n// functions\nfloat gSc;\n\n\nvec3 convertCoord(vec2 p){\n   \n    p *= cubeMapRes;\n    \n    //p = mod(p, vec2(1000, 1000));\n    float z = floor(p.x/100.) + floor(p.y/100.)*10.;\n    return vec3(mod(floor(p.xy), 100.), z)/100.;\n\n}\n\n// Straight UV coordinate to cubemap face read.\nvec4 tx(samplerCube iCh, vec2 uv){\n    \n    // Back Z face -- Depending on perspective. Either way, so long as\n    // you're consistant.\n    return texture(iCh, vec3(fract(uv) - .5, .5));\n}\n\n\n// Straight 3D coordinate to cubemap face read.\nvec4 tMap(samplerCube iCh, vec3 p){\n\n    // Multiplying \"p\" by 100 was style choice.\n    p *= 100.;\n    \n    // Using the 3D coordinate to index into the cubemap and read\n    // the isovalue. Basically, we need to convert Z to the particular\n    // square slice on the 2D map, the read the X and Y values. \n    //\n    // mod(p.xy, 100), will read the X and Y values in a square, and \n    // the offset value will tell you how far down (or is it up) that\n    // the square will be.\n    \n    vec2 offset = mod(floor(vec2(p.z, p.z/10.)), vec2(10, 10));\n    vec2 uv = (mod(floor(p.xy), 100.) + offset*100. + .5)/cubeMapRes;\n    \n    // Back Z face -- Depending on perspective. Either way, so long as\n    // you're consistant.\n    return texture(iCh, vec3(fract(uv) - .5, .5));\n}\n\n\n\n// Smooth interpolated 3D coordinate to cubemap face. The \"p\" value has \n// already been multiplied by 100 in the \"texMapSmooth\" function (See below).\nvec4 tMapSm(samplerCube iCh, vec3 p){\n \n    // Using the 3D coordinate to index into the cubemap and read\n    // the isovalue. Basically, we need to convert Z to the particular\n    // square slice on the 2D map, the read the X and Y values. \n    //\n    // mod(p.xy, 100), will read the X and Y values in a square, and \n    // the offset value will tell you how far down (or is it up) that\n    // the square will be.\n    vec2 offset = mod(floor(vec2(p.z, p.z/10.)), vec2(10, 10));\n    vec2 uv = (mod(p.xy, 100.) + offset*100. + .5)/cubeMapRes;\n    \n    // Back Z face -- Depending on perspective. Either way, so long as\n    // you're consistant. I noticed the Y values need to be flipped...\n    // I'd like to arrange so that it's not necessary, but it might be\n    // and internal thing, so I'm not sure how, yet.\n    //\n    // You could also use one of the newer texture functions that \n    // doesn't require the \".5\" and \"iChannelRes0\" division, but I'm\n    // keeping it oldschool. :) Actually, if the newer ones are\n    // superior, let us know.\n    return texture(iCh, vec3(fract(uv) - .5, .5));\n}\n\n\n// Smooth texture interpolation. You really need this -- I wish you didn't, but you do.\n// I wrote it a while ago, and I'm pretty confident that it works. The smoothing factor\n// isn't helpful at all, which surprises me. It's written in the same way that you'd \n// write any cubic interpolation: 8 corners, then a linear interpolation using the corners\n// as boundaries.\nvec4 texMapSmooth(samplerCube tx, vec3 p){\n\n    // Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy. \n\tvec2 e = vec2(0, 1);\n  \n    // Multiplying the coordinate value by 100 to put them in the zero to 100 pixel range.\n    // It was a style choice... which I'm standing by, for now. :)\n    p *= 100.;\n    \n    \n    vec3 ip = floor(p);\n    // Set up the cubic grid.\n    p -= ip; // Fractional position within the cube.\n    \n    // Smoothing - for smooth interpolation. Comment it out to see the\n    //p = p*p*p*(p*(p*6. - 15.) + 10.); // Quintic smoothing. Slower, but derivaties are smooth too.\n    //p = p*p*(3. - 2.*p); // Cubic smoothing. \n    //p = mix(p, smoothstep(0., 1., p), .5);\n    //vec3 w = p*p*p; p = ( 7. + (p - 7.)*w)*p;\t// Super smooth, but less practical.\n    //p = .5 - .5*cos(p*3.14159); // Cosinusoidal smoothing.\n    // No smoothing. Gives a blocky appearance.\n    \n     // Smoothly interpolating between the eight verticies of the cube. Due to the shared verticies between\n    // cubes, the result is blending of random values throughout the 3D space.\n    vec4 c = mix(mix(mix(tMapSm(tx, ip + e.xxx), tMapSm(tx, ip + e.yxx), p.x),\n                     mix(tMapSm(tx, ip + e.xyx), tMapSm(tx, ip + e.yyx), p.x), p.y),\n                 mix(mix(tMapSm(tx, ip + e.xxy), tMapSm(tx, ip + e.yxy), p.x),\n                     mix(tMapSm(tx, ip + e.xyy), tMapSm(tx, ip + e.yyy), p.x), p.y), p.z);\n/*   \n    // For fun, I tried a straight up average. It didn't work. :)\n    vec4 c = (tMapSm(tx, ip + e.xxx) + tMapSm(tx, ip + e.yxx) +\n              tMapSm(tx, ip + e.xyx) + tMapSm(tx, ip + e.yyx) +\n              tMapSm(tx, ip + e.xxy) + tMapSm(tx, ip + e.yxy) +\n              tMapSm(tx, ip + e.xyy) + tMapSm(tx, ip + e.yyy))/8.;\n*/ \n    \n    return c;\n\n}\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n/*\n// IQ's exponential-based smooth maximum function. Unlike the polynomial-based\n// smooth maximum, this one is associative and commutative.\nfloat smaxExp(float a, float b, float k){\n\n    float res = exp(k*a) + exp(k*b);\n    return log(res)/k;\n}\n*/\n\n// IQ's exponential-based smooth minimum function. Unlike the polynomial-based\n// smooth minimum, this one is associative and commutative.\nfloat sminExp(float a, float b, float k){\n\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\n\n// With the spare cycles, I thought I'd splash out and use Dave's more reliable hash function. :)\n//\n// Dave's hash function. More reliable with large values, but will still eventually break down.\n//\n// Hash without Sine.\n// Creative Commons Attribution-ShareAlike 4.0 International Public License.\n// Created by David Hoskins.\n// vec3 to vec3.\nvec3 hash33G(vec3 p){\n\n    \n    p = mod(p, gSc);\n\tp = fract(p * vec3(.10313, .10307, .09731));\n    p += dot(p, p.yxz + 19.1937);\n    p = fract((p.xxy + p.yxx)*p.zyx)*2. - 1.;\n    return p;\n   \n    /*\n    // Note the \"mod\" call. Slower, but ensures accuracy with large time values.\n    mat2  m = rot2(mod(iTime, 6.2831853));\t\n\tp.xy = m * p.xy;//rotate gradient vector\n    p.yz = m * p.yz;//rotate gradient vector\n    //p.zx = m * p.zx;//rotate gradient vector\n\treturn p;\n    */\n\n}\n\n// Cheap vec3 to vec3 hash. I wrote this one. It's much faster than others, but I don't trust\n// it over large values.\nvec3 hash33(vec3 p){ \n   \n    \n    p = mod(p, gSc);\n    //float n = sin(dot(p, vec3(7, 157, 113)));    \n    //p = fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; \n    \n    //mat2  m = rot2(iTime);//in general use 3d rotation\n\t//p.xy = m * p.xy;//rotate gradient vector\n    ////p.yz = m * p.yz;//rotate gradient vector\n    ////p.zx = m * p.zx;//rotate gradient vector\n\t//return p;\n    \n    float n = sin(dot(p, vec3(113, 57, 27)));    \n    return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.;  \n\n    \n    //float n = sin(dot(p, vec3(7, 157, 113)));    \n    //p = fract(vec3(2097152, 262144, 32768)*n); \n    //return sin(p*6.2831853 + iTime)*.5; \n}\n\n\n// hash based 3d value noise\nvec4 hash41(vec4 p){\n    return fract(sin(p)*43758.5453);\n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(hash41(h), hash41(h + s.x), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Gradient noise fBm.\nfloat fBm2(in vec3 p){\n    \n    return n3D(p)*.57 + n3D(p*2.)*.28 + n3D(p*4.)*.15;\n}\n\n\n// Gradient noise, or Perlin noise. Break space into cubes, attach random 3D vectors to each of the eight \n// verticies, then smoothly interpolate between them. It's that simple. With the exception of some simple\n// changes and some commentary addition, this is basically IQ's implementation.\n// \nfloat gradN3D(in vec3 p){\n   \n    // Utilility bector.\n    const vec2 e = vec2(0, 1);\n    \n    // Set up the cubic grid.\n    // Integer value - unique to each cube, and used as an ID to generate random vectors for the\n    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed\n    // to them.\n    vec3 ip = floor(p); \n    \n    p -= ip; // Fractional position within the cube.\n\n    // Smoothing - for smooth interpolation. Comment it out to see the\n    //vec3 w = p*p*p*(p*(p*6. - 15.) + 10.); // Quintic smoothing. Slower, but derivaties are smooth too.\n    vec3 w = p*p*(3. - 2.*p); // Cubic smoothing. \n    //vec3 w = p*p*p; w = (7. + (w - 7.) * p) * w;\t// Super smooth, but less practical.\n    //vec3 w = .5 - .5*cos(p*3.14159); // Cosinusoidal smoothing.\n    //vec3 w = p; // No smoothing. Gives a blocky appearance. Can look cool under the right conditions.\n    \n    // Smoothly interpolating between the eight verticies of the cube. Due to the shared verticies between\n    // cubes, the result is blending of random values throughout the 3D space.\n    float c = mix(mix(mix(dot(hash33G(ip + e.xxx), p - e.xxx), dot(hash33G(ip + e.yxx), p - e.yxx), w.x),\n                      mix(dot(hash33G(ip + e.xyx), p - e.xyx), dot(hash33G(ip + e.yyx), p - e.yyx), w.x), w.y),\n                  mix(mix(dot(hash33G(ip + e.xxy), p - e.xxy), dot(hash33G(ip + e.yxy), p - e.yxy), w.x),\n                      mix(dot(hash33G(ip + e.xyy), p - e.xyy), dot(hash33G(ip + e.yyy), p - e.yyy), w.x), w.y), w.z);\n    \n    // Taking the final result, and putting it into the zero to one range.\n    return c*.5 + .5; // Range: [0, 1].\n\n}\n\n// Gradient noise fBm.\nfloat fBm(in vec3 p){\n    \n    return gradN3D(p)*.57 + gradN3D(p*2.)*.28 + gradN3D(p*4.)*.15;\n}\n\n\n\n\n// This is a variation on a regular 2-pass Voronoi traversal that produces a Voronoi\n// pattern based on the interior cell point to the nearest cell edge (as opposed\n// to the nearest offset point). It's a slight reworking of Tomkh's example, which\n// in turn, is based on IQ's original example. The links are below:\n//\n// On a side note, I have no idea whether a faster solution is possible, but when I\n// have time, I'm going to try to find one anyway.\n//\n// Voronoi distances - iq\n// https://www.shadertoy.com/view/ldl3W8\n//\n// Here's IQ's well written article that describes the process in more detail.\n// https://iquilezles.org/articles/voronoilines\n//\n// Faster Voronoi Edge Distance - tomkh\n// https://www.shadertoy.com/view/llG3zy\n//\n//\nvec3 cellID;\n//\nvec3 Voronoi(in vec3 p, in vec3 rd){\n    \n    // One of Tomkh's snippets that includes a wrap to deal with\n    // larger numbers, which is pretty cool.\n\n \n    vec3 n = floor(p);\n    p -= n + .5;\n \n    \n    // Storage for all sixteen hash values. The same set of hash values are\n    // reused in the second pass, and since they're reasonably expensive to\n    // calculate, I figured I'd save them from resuse. However, I could be\n    // violating some kind of GPU architecture rule, so I might be making \n    // things worse... If anyone knows for sure, feel free to let me know.\n    //\n    // I've been informed that saving to an array of vectors is worse.\n    //vec2 svO[3];\n    \n    // Individual Voronoi cell ID. Used for coloring, materials, etc.\n    cellID = vec3(0); // Redundant initialization, but I've done it anyway.\n\n    // As IQ has commented, this is a regular Voronoi pass, so it should be\n    // pretty self explanatory.\n    //\n    // First pass: Regular Voronoi.\n\tvec3 mo, o;\n    \n    // Minimum distance, \"smooth\" distance to the nearest cell edge, regular\n    // distance to the nearest cell edge, and a line distance place holder.\n    float md = 8., lMd = 8., lMd2 = 8., lnDist, d;\n    \n    for( int k=-2; k<=2; k++ ){\n    for( int j=-2; j<=2; j++ ){\n    for( int i=-2; i<=2; i++ ){\n    \n        o = vec3(i, j, k);\n        o += hash33(n + o) - p;\n        // Saving the hash values for reuse in the next pass. I don't know for sure,\n        // but I've been informed that it's faster to recalculate the had values in\n        // the following pass.\n        //svO[j*3 + i] = o; \n  \n        // Regular squared cell point to nearest node point.\n        d = dot(o, o); \n\n        if( d<md ){\n            \n            md = d;  // Update the minimum distance.\n            // Keep note of the position of the nearest cell point - with respect\n            // to \"p,\" of course. It will be used in the second pass.\n            mo = o; \n            cellID = vec3(i, j, k) + n; // Record the cell ID also.\n        }\n       \n    }\n    }\n    }\n\n    // Second pass: Distance to closest border edge. The closest edge will be one of the edges of\n    // the cell containing the closest cell point, so you need to check all surrounding edges of \n    // that cell, hence the second pass... It'd be nice if there were a faster way.\n    for( int k=-3; k<=3; k++ ){\n    for( int j=-3; j<=3; j++ ){\n    for( int i=-3; i<=3; i++ ){\n        \n        // I've been informed that it's faster to recalculate the hash values, rather than \n        // access an array of saved values.\n        o = vec3(i, j, k);\n        o += hash33(n + o) - p;\n        // I went through the trouble to save all sixteen expensive hash values in the first \n        // pass in the hope that it'd speed thing up, but due to the evolving nature of \n        // modern architecture that likes everything to be declared locally, I might be making \n        // things worse. Who knows? I miss the times when lookup tables were a good thing. :)\n        // \n        //o = svO[j*3 + i];\n        \n        // Skip the same cell... I found that out the hard way. :D\n        if( dot(o - mo, o - mo)>.00001 ){ \n            \n            // This tiny line is the crux of the whole example, believe it or not. Basically, it's\n            // a bit of simple trigonometry to determine the distance from the cell point to the\n            // cell border line. See IQ's article for a visual representation.\n            lnDist = dot(0.5*(o + mo), normalize(o - mo));\n            \n            // Abje's addition. Border distance using a smooth minimum. Insightful, and simple.\n            //\n            // On a side note, IQ reminded me that the order in which the polynomial-based smooth\n            // minimum is applied effects the result. However, the exponentional-based smooth\n            // minimum is associative and commutative, so is more correct. In this particular case, \n            // the effects appear to be negligible, so I'm sticking with the cheaper polynomial-based \n            // smooth minimum, but it's something you should keep in mind. By the way, feel free to \n            // uncomment the exponential one and try it out to see if you notice a difference.\n            //\n            // // Polynomial-based smooth minimum.\n            //lMd = smin2(lMd, lnDist, lnDist*.75); //lnDist*.75\n            //\n            // Exponential-based smooth minimum. By the way, this is here to provide a visual reference \n            // only, and is definitely not the most efficient way to apply it. To see the minor\n            // adjustments necessary, refer to Tomkh's example here: Rounded Voronoi Edges Analysis - \n            // https://www.shadertoy.com/view/MdSfzD\n            lMd = sminExp(lMd, lnDist, 10.); \n            \n            // Minimum regular straight-edged border distance. If you only used this distance,\n            // the web lattice would have sharp edges.\n            lMd2 = min(lMd2, lnDist);\n        }\n\n    }\n    }\n    }\n\n    // Return the smoothed and unsmoothed distance. I think they need capping at zero... but \n    // I'm not positive.\n    return max(vec3(lMd, lMd2, md), 0.);\n}\n\n\n\n\n\n/*\n// 3D blurring function. Not used here, but it will be in later examples.\nvec4 BlurTri(samplerCube iCh, vec3 p, int dim){\n    \n    // Initiate the color.\n    vec4 col = vec4(0);\n    \n    p *= 100.;\n    //p = floor(p);\n    \n    \n    int hDim = dim/2;\n    \n    float tot = 0.;\n    // There's a million boring ways to apply a kernal matrix to a pixel, and this \n    // is one of them. :)\n    for (int k=0; k<dim; k++){\n        for (int j=0; j<dim; j++){\n            for (int i=0; i<dim; i++){ \n\n               // Triangle blur, of sorts.\n               float ijk = float(hDim - abs(hDim - i) + 1)*float(hDim - abs(hDim - j) + 1)*\n                   \t\t  float(hDim - abs(hDim - k) + 1);\n               float d = length(vec3(hDim - i, hDim - j, hDim - k));\n               //if(d>float(hDim)*1.2) continue;\n                 \n               //ijk = length(vec3(hDim)) - d;\n               float mDim = pow(float(hDim + 1), 3.);\n               //ijk = smoothstep(0., 1., ijk/mDim)*mDim;//sqrt(ij);\n               col += ijk*tMapSm(iCh, p + vec3(i - hDim, j - hDim, k - hDim));\n               tot += ijk;\n            }\n        }\n    }\n    \n    return col/tot; // /81.\n    \n}\n*/\n\n \n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}