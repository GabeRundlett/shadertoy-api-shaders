{
    "Shader": {
        "info": {
            "date": "1507864088",
            "description": "based on Projection Matrix Tricks by Eric Lengyel (http://www.terathon.com/gdc07_lengyel.pdf), adjusted for supporting perspective as well as orthographic projections with one setup.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltByzw",
            "likes": 6,
            "name": "Infinite Far Plane Projection",
            "published": 3,
            "tags": [
                "projection",
                "plane",
                "perspective",
                "infinite",
                "transform",
                "orthogonal",
                "far"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 1336
        },
        "renderpass": [
            {
                "code": "struct Projection {\n    vec2 aspect;\n    vec2 z_coeffs;\n    vec2 w_coeffs;\n};\n\n/* infinite far plane perspective transform\nfor this to work, the depth buffer must be reversed;\nglDepthFunc must be set to GL_GREATER, glClearDepth set to 0,\nand glDepthRangedNV set to -1, 1; */\nProjection perspective (vec2 aspect, float near) {\n    return Projection(aspect, vec2(0.0, near), vec2(1.0, 0.0));\n}\n\n/* linear orthographic with near = 1 far = 0\nfor this to work, the depth buffer must be reversed;\nglDepthFunc must be set to GL_GREATER, glClearDepth set to 0,\nand glDepthRangedNV set to -1, 1; */\nProjection orthographic (vec2 aspect, float near, float far) {\n    return Projection(aspect, \n\t\tvec2(1.0, -far) / (near - far),\n\t\tvec2(0.0, 1.0));\n}\n\n/* generic projection transform; allows for orthographic\nand perspective coeffs; must be divided by w afterwards */\nvec4 project (Projection proj, vec4 v) {\n\treturn vec4(\n            v.xy * proj.aspect,\n            dot(v.zw, proj.z_coeffs),\n            dot(v.zw, proj.w_coeffs));\n}\n\n/* inverse projection transform */\nvec4 project_inverse (Projection proj, vec4 v) {\n    float z = (v.z * proj.w_coeffs.y - proj.z_coeffs.y) \n        / (proj.z_coeffs.x - v.z * proj.w_coeffs.x);\n    float w = z * proj.w_coeffs.x + proj.w_coeffs.y;\n    return vec4(v.xy * w / proj.aspect, z, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n    vec3 ndc = vec3(uv, mix(0.0, 1.0, 1.0-max(abs(uv.x),abs(uv.y))));\n    vec2 aspect = vec2(iResolution.y / iResolution.x, 1.0);\n    Projection proj = perspective(aspect, 0.1);\n    \n\tvec4 p = project_inverse(proj, vec4(ndc, 1.0));\n    if (uv.x > uv.y) {\n    \tp = project(proj, p);\n    \tp /= p.w;\n    }\n    \n    fragColor = vec4(p.xy*0.5+0.5, p.z, 1.0);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}