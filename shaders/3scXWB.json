{
    "Shader": {
        "info": {
            "date": "1579096860",
            "description": "t",
            "flags": 0,
            "hasliked": 0,
            "id": "3scXWB",
            "likes": 3,
            "name": "weird terrain;k",
            "published": 3,
            "tags": [
                "planet"
            ],
            "usePreview": 0,
            "username": "vjblind",
            "viewed": 510
        },
        "renderpass": [
            {
                "code": "#define ANTIALIAS 2\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  240.0\n#define MAX_RAY_MARCHES 550\n\n// Hi    just to say A big thank for iq for the help !!\n\n\n\n\n\n#define speed iTime*0.\n#define time iTime*.50\n#define timeline iTime\n\n#define LIGHT_COLOR\t\t\tvec3(.0, 0.9, 2.6)*1.6\n\n//wip//SCENESsystem/////////////////////////////////////////////////////////////////////\n//const ivec3 SCENES[] = ivec3[](}\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat stepUp(float t, float len, float smo)\n{\n  float tt = mod(t += smo, len);\n  float stp = floor(t / len) - 1.0;\n  return smoothstep(0.0, smo, tt) + stp;\n}\n\n\n/////transform/////////////////////////////////////////////////////////////////////\nfloat smin(in float a ,float b, float k){\nfloat h= max(k-abs(a-b),0.0);\nreturn min(a,b)-h*h/(k*4.);\n}\nfloat smin1(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k * (1.0-k ) * h;\n}\n\n\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opInt( float d1, float d2 ) { return max(d1,d2); }\n\n\nfloat opdistsub( float d1, float d2 ) { return max(-d1,d2); }\n\n\n\nmat2 rot(float a)\n{\n float cs = cos(a);\n    float si = sin(a);\n    \n    return mat2(cs, si, -si, cs);\n}\n///////////////////////////////////////////////////////////////////////////////////\n\n\n//////tool/////////////////////////////////////////////////////////////////////////\nvec3 fracta(vec3 p,float t){\n float s=3.;\n    for(float i=0.0;i<4.;i++){\n    float t2=t*i;\n    p.xy*=rot(t2);\n    p.yz*=rot(t2*1.2);\n        p=abs(p);\n     p-=s;\n   p*=.870;\n    }\n\n\nreturn p;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\n//////noise/////////////////////////////////////////////////////////////////////////\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n\n\n\n//---------------------------------------------------------------\n// value noise, and its analytical derivatives\n//---------------------------------------------------------------\n\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\tvec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    \n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+157.0);\n    float d = hash(n+158.0);\n    float e = hash(n+113.0);\n\tfloat f = hash(n+114.0);\n    float g = hash(n+270.0);\n    float h = hash(n+271.0);\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));\n}\n\n\n\n/////fbm///////////////////////////////////////////////////////////////////////////\n\n\nvec4 fbmd( in vec3 x )\n{\n      float scale  = 1.5+3.*sin(iTime/100.);\n\n    float a = 0.0;\n    float b = 0.5;\n\tfloat f = 1.0;\n    vec3  d = vec3(0.0);\n    for( int i=0; i<3; i++ )\n    {\n        vec4 n = noised(f*x*scale)*noised(f*x*scale).x;\n        a += b*n.x;           // accumulate values\t\t\n        d += b*n.yzw*f*scale; // accumulate derivatives\n        b *= 0.5;             // amplitude decrease\n        f *= 2.8;             // frequency increase\n    }\n\n\treturn vec4( a, d );\n}\n\n\n\n///////////////////////////////////////////////////////////////////////////////////\n\n\n\n//////Primitive/////////////////////////////////////////////////////////////////\n//////Primitive/////////////////////////////////////////////////////////////////\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n///////////////////////////////////////////////////////////////////////////////////\n//////Primitive normal/////////////////////////////////////////////////////////////////\n\n\nvec4 sdsphere1( vec3 p, vec3 b ) // distance and normal\n{\n    return vec4( (length(p)-b),1.);\n}\n\n\nvec4 sdBox2( vec3 p, vec3 b ) // distance and normal\n{\n    vec3 d = abs(p) - b;\n    float x = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    vec3  n = step(d.yzx,d.xyz)*step(d.zxy,d.xyz)*sign(p);\n    return vec4( x, vec3(1.) );\n}\n/////light/////////////////////////////////////////////////////////////////   \n\nconst vec3 lightPos1 = 20.0*vec3(-0.3,-1.15, 1.0);\nconst vec3 lightPos2 = 20.0*vec3(-0.33,  -0.2, -1.0);\nconst vec3 lightCol1 = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\nconst vec3 lightCol2 = vec3(8.0/8.0,6.0/8.0,7.0/8.0);\n/////Sceneglow///////////////////////////////////////////////////////////\n \nfloat  GScene( vec3 p){      return sdSphere( p, 3. );}\n\n \n//////////////////////////////////////////////////////////////////\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\treturn vec2( tN, tF );\n}\n\n///Scene//////////////////////////////////////////////////////////////////////////\n\nvec2 Scene( vec3 p){\n  \nfloat d =sdBox(p+vec3(0.0,0.0,-speed+25.) ,vec3(1.,1.0,1.0)*10.);;\n  vec3 p1= fracta(p+vec3(0.0,0.0,-speed+25.),time*0.3);  \n  vec3 p2= fracta(p+vec3(0.0,0.0,-speed+25.),time*0.4);  \n \nfloat d1=sdBox(p1 ,vec3(1.,1.0,1.0)*2.);\nfloat d2=sdBox(p2+vec3(1.,1.0,1.0) ,vec3(1.,1.0,1.0)*2.);      \n    \n//vec3 mirror= vec3(abs(q.x),q.yz);\n   \nfloat res=10.0;\n\nres=smin(res,d1,2. );\nres=smin(res,d2 ,9.);\n    \nfloat m1=d1;\n// res=min(res,d);     \n     float mat = 0.0 ;\n     if(res==m1)mat=1.0;\n   return vec2(res,mat);\n}\nvec2 Scene1( vec3 p){\n  \nfloat d =sdBox(p+vec3(0.0,0.0,-speed+25.) ,vec3(1.,1.0,1.0)*10.);;\n  vec3 p1= fracta(p+vec3(0.0,0.0,-speed+25.),time*0.3);  \n  vec3 p2= fracta(p+vec3(0.0,0.0,-speed+25.),time*0.4);  \n \nfloat d1=sdSphere(p1 ,3.);\nfloat d2=sdSphere(p2+vec3(1.,1.0,1.0) ,2.);      \n    \n//vec3 mirror= vec3(abs(q.x),q.yz);\n   \nfloat res=10.0;\n\nres=smin(res,d1,2. );\nres=smin(res,d2 ,9.);\n    \nfloat m1=res=opSub(d1,d2 );\n  \nfloat m2=GScene( p);\n   \nres= min(res, GScene(  p)); \n    \n    \n    \n// res=min(res,d);     \n   float mat = 0.0 ;\n   if(res==m1)mat=1.0;\n   if(res==m2)mat=2.7;\n   return vec2(res,mat);\n}\n\n\n\nvec2 Scenex( vec3 p){\n   // vec3 p2= fracta(p+vec3(0.0,0.0,-speed*0.0+25.),time*0.00004);\n   // p.xy*=rot(time);\nfloat d =sdSphere(p +vec3(0.0,0.0,-50.),10.);\n     \n    // clip to box\n    vec4 d2 = sdsphere1( p , vec3(5.5) ); \n    \n vec4 d1 = fbmd(p );\n    d1.x -= 0.4213571542;\n\t d1.x *= .47;\n    \n    vec4 d3 = fbmd(p )*d1.x;\n    d3.x -= 0.5213571542;\n\t d3.x *= .47;\n //   d1.yzw = normalize(d1.yzw);\n\n    // clip to box\n //   vec4 d2 = sdBox( p, vec3(1.5) );\n   \n   // ugly hacky slow distance field with bad gradients\n   // d = p.y;\n    float c = max(10.0, pow(distance(p.xz, vec2(0,16)), 1.0));\n    float cc = pow(smoothstep(20.0, 105.0, c), 1.0);\n    p.xz *= cc;\n    vec4 n = noised(vec3(p.xz*10.7, 50.5));\n    float nn = n.x * (length((n.yzw)));\n   // n = noised(vec3(p.xz*0.173, 10.*1.639));\n  // nn += 0.25*n.x * (length((n.yzw)));\n    nn = smoothstep(-0.5, .015, nn);\n    d3.x = d3.x*123.0*nn*(cc);\n    \n    \nfloat res = opdistsub(-d,   mix(d3.x, 0.15,  0.9915));\n   res+=d1.x  ;\n   // if(d1.x<0.5)res=d1.x;\n    \n    \n   // ugly hacky slow distance field with bad gradients\n  \n    \n    \n    \n    \n    // res=min(res,d);     \n     float mat =2.7 ;\n\n   return vec2(res,mat);\n}\n \nvec2 path(in float z){ float s = sin(z/36.)*cos(z/18.); return vec2(s*16., 0.); }\n\n\n//////////////////////////////////////////////////////////////////\n////map/////////////////////////////////////////////////////////////////////\n\nvec2 map1(in vec3 p)\n{\n    \n  float t = mod(stepUp(timeline, 15.0, 1.0),15.0);\n    \n\t vec2 d = mix(Scene(p), Scene1(p), clamp(t, 0.0, 1.0));\n          d = mix(d, Scene(p), clamp(t - 3.0, 0.0, 1.0));\n              d = Scenex(p);\n //vec2    d =  Scene2(p);\n\n  //  d = mix(d, s1, clamp(t - 3.0, 0.0, 1.0));\n    \n// min(max(0.0, d), 1.0);   \n    \n\nreturn d;\n\n\n}\n\n\n\n\n\n\n//mat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n float mag2(vec2 p){return dot(p,p);}\n float prm1 = 0.1;\nvec2 bsMo = vec2(00.6);\n\nvec2 disp(float t){ return vec2(sin(t*0.22)*1., cos(t*0.175)*1.)*2.; }\n\nvec2 map(in vec3 p)\n{\n    vec3 p2 = p;\n     p2.xy -= disp(p.z).xy;\n     p.xy *= rot(sin(p.z+iTime)*(0.1 + prm1*0.05) + iTime*0.09);\n   float cl =mag2(p2.xy);\n    float d =  .1;\n   p *= .61;\n    float z = 1.;\n    float trk = 10.;\n    float dspAmp = 0.1 + prm1*0.2;\n    for(int i = 0; i < 1\n        ; i++)\n    {\n\t p += sin(p.zxy*0.75*trk + iTime*trk*.8)*dspAmp;\n        d -= abs(dot(cos(p), sin(p.yzx))*z);\n        z *= 9.57;\n        trk *= 1.4;\n         //p = p*m3;\n    }\n   // d  =  abs( d + prm1*3.)+ prm1*.3 - 20.5 + bsMo.y;//carve the tunel\n  \n      d = abs(d + prm1*3.)+ prm1*.3 - 2.5 + bsMo.y;\n  // return  3.-vec2(length((d*1.3)+p2)-65. , cl);\n    \n    \n   // return  3.-vec2(length(p2)-65. , cl);\n\n    return 1.-vec2(d + cl*.2 + 0.25, cl);\n     \n  // return vec2(   d + cl*.0 + 0.25, 10.1);\n}\n\n\nvec4 Shade( vec3 pos, vec3 ray, vec3 n,float m )\n{\n    vec4 col = vec4(1,0,0,0);\nif (m==1.)col = vec4(1,0,0,0);\nif (m==2.) col = vec4(0,1,0,0);   \n    // col.rgb = fract(pos);\n\n    vec3 diffuse = vec3(.1)*(n.y*.5+.5);\n\tvec2 uv = vec2( atan( n.x, n.z ), acos(n.y) );\n    \t  uv =  (pos.xz + pos.xy*30.)/11.0;\n  \n    vec3 col1 = (texture( iChannel0, uv*0.0915 ).xyz);\n    vec3 l = normalize( vec3( 2,3,4 ) );\n   diffuse = col1*col1* max(dot(n,l),0.);\n\n     col.rgb = diffuse*vec3(.0, 0.9, 2.6)* .6;\n    \n    // reflectivity\n    col.a =  clamp(  pow( 1.+dot(ray,n), 5. ),0.01,1.0);\n    col.a = mix( .01, 1., col.a );\n    \n    return col;\n}\n\nvec3 GetNormal( vec3 pos, float sampleSpacing )\n{\n    vec2 d = vec2(-1,1)*sampleSpacing;\n    \n    return normalize(\n        map( pos + d.xxx ).x*d.xxx +\n        map( pos + d.yyx ).x*d.yyx +\n        map( pos + d.yxy ).x*d.yxy +\n        map( pos + d.xyy ).x*d.xyy\n        );\n}\n\n\nvec2 GlowMarch(vec3 p, vec3 o)\n{\n\tfloat d\t\t= 1000.0;\n\tfloat z\t\t= 0.0;\n\tfloat acc\t= 0.0;\n\t\n\tfor(int i=0; i<100; i++)\n\t{\n\t     \td= map(p + o*z).x;\n  \n\t\tacc\t+= max(3. - d,- 0.);\n            z\t+= max(0.1, d)*d/100.;\n\t}\n\t\n\treturn vec2(acc/1560., z);\n}\n\nvec2 Trace( vec3 start, vec3 dir, float minT, float maxT, float pixelScale )\n{\n    float epsilon = pixelScale*1.;\n    \n    float t = minT;\n    float m ;\n    float dist;\n    for ( int i=0; i < 500; i++ ) // this can be really big as long as epsilon is high enough\n    {\n        dist = map( start + t*dir ).x;\n         m =map( start + t*dir ).y;;\n        if ( abs(dist) < epsilon*t || t > maxT ) return vec2(t,m);\n        t += dist;\n    }\n    \n    if ( dist >0.1 && t < maxT )\n    {\n        t += dist;\n        float dist2 = map( start + t*dir ).x;\n        \n        // try to guess where the surface might be, by extrapolating as if SDF is planar here\n        t += max(0.,dist2*dist/(dist-dist2)); //(dist-dist2)/dist = change in df / distance stepped, so divide DF by this to find distance we should step\n        \n        return vec2 (t,m);\n    }\n    \n    return vec2(maxT,m); // todo: maybe return best-guess t when we run out of iterations?\n}\n\n\nvec2  camera( float p, int x )\n{\n    if( x== 1){return path(p);}\n    if( x== 2){return path(p);}\n}\n\n \n\nvec3 cameraani(int s){\n    float an2= 10.*iMouse.y/iResolution.y ;//iTime;\n    float an= 10.*iMouse.x/iResolution.x ;//iTime;\n    \n    \n  \nswitch (s)\n{\n    case 1:\n     return vec3(sin(an )*10.0 ,-sin(an2 )*10.0, 50.+5.*sin(time/10.) +cos(an )*10.0); \n  \n    \n    break;\n\n    case 2:\n       return vec3(0.0,0.0,50.0); \n    break;\n        \n    default:  return vec3(0.0,0.0,0.0); \n        // code to be executed if n doesn't match any constant\n}\n\n\n\n}\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    const float targetT = 1.;\n     \n    vec3 camPos = vec3(0.0);\n    vec2 uv =(2.0* fragCoord-iResolution.xy )/iResolution.y;\n\n \tfloat fft  = texture( iChannel0, vec2(uv.x,0.25) ).x; \n    \n    // second texture row is the sound wave\n\tfloat wave = texture( iChannel0, vec2(uv.x,0.75) ).x;\n\t\n    //  time = mod(time * 0.6, 500.0) + 16.4;\n    \n   float an2= 10.*iMouse.y/iResolution.y ;//iTime;\n    float an= 10.*iMouse.x/iResolution.x ;//iTime;\n    \n    \n vec3 ro  =cameraani(1);//=vec3(sin(an )*10.0+ speed+-10. ,-sin(an2 )*10.0, speed+50.*sin(time/1.) +cos(an )*10.0); \n  vec3 ta =vec3(00.0,0.0,0.);\n     \n    //ta.xy +=camera( ta.z , 1 );\n\t//ro.xy += camera( ro.z , 2 );\n    vec3 ww=normalize(ta-ro);\n    vec3 uu=normalize(cross(ww,vec3(0.0,1.0,0.0)));\n    vec3 vv=normalize(cross(uu,ww));\n     \n   \n  vec3 rd =normalize(uv.x*uu+uv.y*vv+.5*ww);                  \n rd = normalize(vec3(uv,-2.));\n       \n      \n      \n     vec3 ray = vec3((fragCoord.xy-.5*iResolution.xy)/iResolution.y,1.);\n    float pixelScale = (1.1 )/ray.z / iResolution.y;\n    pixelScale = ( .1*pixelScale);\n    \n       ray =rd;\n\n       camPos=ro ;\n    \n    float far = 1e10;\n    float t = Trace( camPos, ray, 0., far, pixelScale ).x;\nfloat tr;\n    fragColour.rgb = vec3(.0);\n    if ( t < far )\n    {\n        vec3 pos = camPos + ray*t;\n        \n\t    vec3 n = GetNormal( pos,   pixelScale*t  );\n\n        fragColour.rgba = Shade( pos, ray, n ,2.);\n        \n        // reflection\n        vec3 rayr = reflect(ray,n);\n         tr = Trace( pos+n*0.01, rayr, .01, 128., pixelScale ).x;\n\t\tfloat tr2 = Trace( pos, rayr, .01, 128., pixelScale ).y;\nfragColour.rgba *=vec4(.0, 0.9, 2.6,0.0)* .6+ 1.5*exp(-max(t-1.0,0.0)*0.03)*clamp(length(pos-vec3(0.0,0.0,50.))/10.0,0.0,1.0);\n        vec3 ref = vec3(.90, 0.9, 1.6);\n        if ( tr < 128. )\n        {\n            vec3 posr = pos + rayr*t;\n       ref = Shade( posr, rayr, GetNormal( posr, .001 ),2. ).rgb+vec3(.0, 0.9, 1.6)* .46;\n        }\n        \n   fragColour.rgb += mix( fragColour.rgb, ref, fragColour.a );\n    }\n\n    \n\n     \n    \tvec2 gres\t= GlowMarch(ro, rd);\n\tfloat glowi\t= 1.0;\n\tif(tr < .001)\n\t{\n\t \n\t\tglowi = smoothstep(-10.0, 10.5, max(tr, 5.0));\n        //\tfragColour.rgb\t+=(fbmd(   vec3 (tr)).x/100.)-0.293*gres.x *0.50 * LIGHT_COLOR;\n\t}\n\t\t\t\n //fragColour.rgb\t+=(fbmd(   vec3 (tr)).x/400.)-0.2481*gres.x* LIGHT_COLOR;\n\n    \n // fragColour.rgb = mix( fragColour.rgb, ref, fragColour.a );\n\n    \n    fragColour.xyz = acesFilm(fragColour.xyz * 1.85);\n     fragColour.xyz = pow(fragColour.xyz, vec3(1.850/2.2));\n\n    fragColour.a = 1.;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}