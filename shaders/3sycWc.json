{
    "Shader": {
        "info": {
            "date": "1603865603",
            "description": "A simple technique for fuzzed reflections by adding a small sphere to the reflected ray.\nOne improvement would be to use a 16 bit texture, but for only one sample 8 bits is fine.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "3sycWc",
            "likes": 4,
            "name": "1 sample fuzzed reflections",
            "published": 3,
            "tags": [
                "raytracing",
                "reflections",
                "bluenoise",
                "rng"
            ],
            "usePreview": 0,
            "username": "NLIBS",
            "viewed": 468
        },
        "renderpass": [
            {
                "code": "vec3 viewPos = vec3(0,0,-1.8);\n\n#define DISPLAY_GAMMA 2.2\n#define GOLDEN_RATIO 1.6180339887\n#define EXPOSURE 1.\n\n#define BLUE_NOISE\n#define SAMPLES 1\n#define FUZZ .1\n\n\nfloat trace(vec3 rd, vec3 ro) {\n    float r = 1.;\n\tfloat c = dot(ro, ro) - r*r;\n\tfloat b = dot(rd, ro);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n    float t2 = -b + sqrt(abs(d));\n    t = (t<=0.) ? t2 : t;\n\treturn mix(0.0, t, step(0.,min(t,d)));\n}\n\nvec3 _sample(vec3 rd) {\n\tvec3 col = texture(iChannel0,rd).rgb;\n    col = pow(col*1.6,vec3(DISPLAY_GAMMA+2.));\n    \n    return col;\n}\n\n//------------------------ \"High-quality hash function\" by nojima\nuvec4 murmurHash44(uvec4 src) {\n    const uint M = 0x5bd1e995u;\n    uvec4 h = uvec4(1190494759u, 2147483647u, 3559788179u, 179424673u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z; h *= M; h ^= src.w;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 4 outputs, 4 inputs\nvec4 hash44(vec4 src) {\n    uvec4 h = murmurHash44(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n//-------------------------\n\nvec4 bluehash (ivec3 v) {\n    vec4 n = texelFetch(iChannel1, v.xy%1024, 0);\n    //Gamma correction here if needed\n    n = fract(n+GOLDEN_RATIO*float(v.z));\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.xx;\n    \n    float a = (iMouse.z>0.) ? iMouse.x/iResolution.x*3.141593 : iTime;    \n    \n    mat2 mat = mat2(cos(a),-sin(a),sin(a),cos(a));\n    vec3 ro = viewPos;\n    ro.xz = mat * ro.xz;\n    \n    vec3 rd = normalize(vec3(uv,.8));\n    rd.xz = mat * rd.xz;\n    \n    float t = trace(rd,ro);\n    \n    vec3 col;\n    \n    if (t>0.) {\n        //Hit pos and normal\n        vec3 p = ro + rd*t;\n        vec3 n = normalize(p);\n\n        //Summing up a couple reflection rays\n        vec3 acc = vec3(0);\n        vec3 reflect_rd = reflect(rd,n);\n        int frameInt = (iFrame%4)*SAMPLES; //720 works for both 60 and 144fps\n        \n        for (int i = 0; i<SAMPLES; i++) {\n            #ifdef BLUE_NOISE\n            \tvec4 hash = bluehash(ivec3(fragCoord,i+frameInt)); \n            \t//hash += hash44(vec4(uv,float(i)/float(SAMPLES),iTime))/256. - 1./512.;\n            #else\n            \tvec4 hash = hash44(vec4(uv,float(i)/float(SAMPLES),iTime));\n            #endif\n            \n            \n            \n            vec3 sph = normalize(hash.xyz*2.-1.)*pow(hash.w,0.3333);\n            vec3 fuzz_rd = normalize(reflect_rd+sph*FUZZ);\n        \tacc += _sample(fuzz_rd);    \n        }\n        acc/=float(SAMPLES);\n\n        //Colours calc\n        col = acc * vec3(0.7);\n    } else {\n        //Background\n        col = _sample(rd);\n    }\n    \n    \n    //Tone mapping\n    col = vec3(1.0) - exp(-col * EXPOSURE);\n    //Gamma correction\n\tcol = pow(col, vec3(1./DISPLAY_GAMMA));\n    \n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}