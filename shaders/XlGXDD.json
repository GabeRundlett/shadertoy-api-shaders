{
    "Shader": {
        "info": {
            "date": "1484306984",
            "description": "Solving the 2D Schroedinger equation",
            "flags": 32,
            "hasliked": 0,
            "id": "XlGXDD",
            "likes": 18,
            "name": "Quantum Scattering",
            "published": 3,
            "tags": [
                "scattering",
                "quantum",
                "schroedinger"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 774
        },
        "renderpass": [
            {
                "code": "// \"Quantum Scattering\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/* Numerical solution of the time-dependent 2D Schroedinger equation using the\n   (explicit, stable) symmetric product formula method; see DeRaedt (1987), and\n   Richardson (1991) for the CM2 parallel version.\n\n   Cycles through different scenarios: two narrow slits, circular potential barrier\n   (colored red), and potential well (blue); mouse enabled.\n*/\n\nfloat PrOBoxDf (vec3 p, vec3 b);\nfloat PrCylDf (vec3 p, float r, float h);\nvec4 Loadv4 (vec2 vId);\n\nvec3 ltDir;\nvec2 qcHit, qgHit;\nfloat tCur, dstFar, gSize, nCyc, pHeight, pRad, sWid, sGap;\nbool dbSlit;\nconst float pi = 3.14159;\n\nfloat SurfDst (vec3 p)\n{\n  vec2 cg;\n  float h;\n  qgHit = (p.xz + 0.5) * (gSize - 1.);\n  cg = floor (qgHit);\n  if (min (cg.x, cg.y) >= 0. && max (cg.x, cg.y) < gSize - 1.) {\n    qcHit = cg;\n    qgHit -= cg;\n    h = 0.5 * mix (mix (Loadv4 (cg).z, Loadv4 (cg + vec2 (0., 1.)).z, qgHit.y),\n       mix (Loadv4 (cg + vec2 (1., 0.)).z,\n       Loadv4 (cg + vec2 (1.)).z, qgHit.y), qgHit.x);\n    h = min (h, 0.8);\n  } else h = 0.;\n  return p.y - h;\n}\n\nfloat SurfRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  dHit = dstFar;\n  s = PrOBoxDf (ro, vec3 (0.5));\n  sLo = 0.;\n  for (int j = 0; j < 300; j ++) {\n    p = ro + s * rd;\n    h = SurfDst (p);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.004, 0.03 * h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (SurfDst (p) > 0.) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  p.xz = abs (p.xz);\n  return (max (p.x, p.z) > 0.5) ? dstFar : dHit;\n}\n\nvec3 SurfNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (SurfDst (p + e.xxx), SurfDst (p + e.xyy),\n     SurfDst (p + e.yxy), SurfDst (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat TransObjDf (vec3 p)\n{\n  float dMin, d, h;\n  dMin = dstFar;\n  if (dbSlit) {\n    p.y -= 0.08;\n    d = max (PrOBoxDf (p, vec3 (0.001, 0.08, 0.5)),\n       - (abs (abs (p.z) - 0.5 * (sGap + sWid)) - 0.5 * sWid));\n  } else {\n    h = (pHeight > 0.) ? 0.05 * pHeight : 0.01;\n    p.y -= h;\n    d = PrCylDf (p.xzy, pRad, h);\n  }\n  dMin = min (dMin, d);\n  return dMin;\n}\n\nfloat TransObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 50; j ++) {\n    d = TransObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 TransObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (TransObjDf (p + e.xxx), TransObjDf (p + e.xyy),\n     TransObjDf (p + e.yxy), TransObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstSurf, dstObs;\n  dstSurf = SurfRay (ro, rd);\n  dstObs = TransObjRay (ro, rd);\n  if (dstObs > dstSurf) dstObs = dstFar;\n  if (dstSurf < dstFar) {\n    vn = SurfNf (ro + rd * dstSurf);\n    col = vec3 (0.7, 1., 0.2) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +       \n       pow (max (0., dot (ltDir, rd)), 64.);\n  } else col = vec3 (0.05, 0.05, 0.2);\n  if (dstObs < dstFar) {\n    vn = TransObjNf (ro + rd * dstObs);\n    col = 0.8 * col + 0.2 * ((dbSlit || pHeight > 0.) ?\n       vec3 (1., 0.5, 0.5) : vec3 (0.5, 0.5, 1.)) * abs (dot (vn, ltDir));\n  }\n  col = clamp (col, 0., 1.);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  gSize = (canvas.y > 160.) ? 256. : 128.;\n  stDat = Loadv4 (vec2 (0., gSize));\n  nCyc = stDat.y;\n  dbSlit = (nCyc < 2.);\n  if (dbSlit) {\n    sWid = stDat.z;\n    sGap = stDat.w;\n  } else {\n    pRad = stDat.z;\n    pHeight = stDat.w;\n  }\n  dstFar = 6.;\n  el = 0.15 * pi;\n  az = 0.5 * pi + 0.3 * pi * sin (0.1 * tCur);\n  if (mPtr.z > 0.) {\n    el = clamp (el - 1.5 * mPtr.y, 0.1 * pi, 0.35 * pi);\n    az -= 7. * mPtr.x;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  ro = vec3 (0., 0.15, -2.8) * vuMat;\n  rd = normalize (vec3 (uv, 6.)) * vuMat;\n  ltDir = normalize (vec3 (1., 1., 0.5));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrOBoxDf (vec3 p, vec3 b)\n{\n  return length (max (abs (p) - b, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Quantum Scattering\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec2 cs1, cs2;\nfloat tCur, nStep, gSize, deltaT, kappa, lambda, pHeight, pRad, sWid, sGap, enVal;\nbool dbSlit;\nconst float pi = 3.14159;\n\nvec2 PsiV (vec2 vId)\n{\n  return Loadv4 (mod (vId, gSize)).xy;\n}\n\nvec2 SProd (vec2 cs, vec2 ta, vec2 tb)\n{\n  vec4 t;\n  t = vec4 (ta, - tb.x, tb.y);\n  return vec2 (dot (cs, t.xw), dot (cs, t.yz));\n}\n\nvec2 PsiX (vec2 iv)\n{\n  vec2 ive, psi, psiP, psiN, e;\n  e = vec2 (1., 0.);\n  ive = iv;\n  ive.x -= mod (ive.x, 2.);\n  psi = PsiV (ive);\n  psiP = PsiV (ive + e);\n  psiN = SProd (cs2, SProd (cs1, psi, psiP),\n     SProd (cs1, PsiV (ive - e), PsiV (ive - 2. * e)));\n  psiP = SProd (cs2, SProd (cs1, psiP, psi),\n       SProd (cs1, PsiV (ive + 2. * e), PsiV (ive + 3. * e)));\n  return (ive.x == iv.x) ? SProd (cs1, psiN, psiP) : SProd (cs1, psiP, psiN);\n}\n\nvec2 PsiY (vec2 iv)\n{\n  vec2 ive, psi, psiP, psiN, e;\n  e = vec2 (0., 1.);\n  ive = iv;\n  ive.y -= mod (ive.y, 2.);\n  psi = PsiX (ive);\n  psiP = PsiX (ive + e);\n  psiN = SProd (cs2, SProd (cs1, psi, psiP),\n     SProd (cs1, PsiX (ive - e), PsiX (ive - 2. * e)));\n  psiP = SProd (cs2, SProd (cs1, psiP, psi),\n       SProd (cs1, PsiX (ive + 2. * e), PsiX (ive + 3. * e)));\n  return (ive.y == iv.y) ? SProd (cs1, psiN, psiP) : SProd (cs1, psiP, psiN);\n}\n\nvec3 Step (vec2 iv)\n{\n  vec2 psi, dv, eVal, pt;\n  float pVal;\n  pVal = 0.;\n  dv = abs (iv / gSize - 0.5);\n  if (dbSlit) {\n    if (dv.x <= 1. / gSize && abs (dv.y - 0.5 * (sGap + sWid)) > 0.5 * sWid)\n       pVal = 3.;\n  } else {\n    if (length (dv) < pRad) pVal = pHeight;\n  }\n  pVal *= deltaT * kappa * kappa;\n  eVal = vec2 (cos (pVal), sin (pVal));\n  cs1 = vec2 (cos (1. / lambda), - sin (1. / lambda));\n  cs2 = vec2 (cos (2. / lambda), - sin (2. / lambda));\n  pt = PsiY (iv);\n  psi = vec2 (eVal.x * pt.x + eVal.y * pt.y, eVal.x * pt.y - eVal.y * pt.x);\n  return vec3 (psi, dot (psi, psi));\n}\n\nvec3 Init (vec2 iv)\n{\n  vec2 psi, org, vKap, u;\n  float pakWid, f, a;\n  org = dbSlit ? vec2 (0.2, 0.5) : vec2 (0.2, 0.2);\n  vKap = normalize (dbSlit ? vec2 (1., 0.) : vec2 (1.));\n  pakWid = 0.05;\n  psi = vec2 (0.);\n  if (min (iv.x, iv.y) > 0. && max (iv.x, iv.y) <  gSize - 1.) {\n    u = iv / (gSize - 1.) - org;\n    f = 0.5 * dot (u, u) / (pakWid * pakWid);\n    if (f < 10.) {\n      a = dot (kappa * sqrt (enVal) * vKap, u + org);\n      psi = exp (- f) * vec2 (cos (a), sin (a));\n    }\n  }\n  return vec3 (psi, dot (psi, psi));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 p;\n  vec2 canvas, pxIv;\n  float mxStep, pxId, nCyc;\n  bool doInit;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  gSize = (canvas.y > 160.) ? 256. : 128.;\n  pxIv = floor (fragCoord);\n  pxId = pxIv.x + gSize * pxIv.y;\n  if (pxIv.x >= gSize || pxId > gSize * gSize) discard;\n  enVal = 1.;\n  lambda = 40.;\n  kappa = 100.;\n  deltaT = 2. / (lambda * (gSize - 1.) * (gSize - 1.));\n  doInit = false;\n  if (iFrame <= 5) {\n    nCyc = 5.;\n    doInit = true;\n  } else {\n    stDat = Loadv4 (vec2 (0., gSize));\n    nStep = stDat.x;\n    nCyc = stDat.y;\n    ++ nStep;\n    dbSlit = (nCyc < 2.);\n    mxStep = dbSlit ? ((canvas.y > 160.) ? 4000. : 1300.) :\n       ((canvas.y > 160.) ? 5000. : 1600.);\n    if (nStep < mxStep) {\n      if (dbSlit) {\n        sWid = stDat.z;\n        sGap = stDat.w;\n      } else {\n        pRad = stDat.z;\n        pHeight = stDat.w;\n      }\n      p = Step (pxIv);\n    } else doInit = true;\n  }\n  if (doInit) {\n    nCyc = mod (++ nCyc, 6.);\n    nStep = 0.;\n    dbSlit = (nCyc < 2.);\n    if (dbSlit) {\n      sWid = 0.05;\n      sGap = 0.08;\n    } else {\n      pRad = 0.05;\n      pHeight = (nCyc == 2. || nCyc == 3.) ? 0.8 : -0.8;\n    }\n    p = Init (pxIv);\n  }\n  if (pxId == gSize * gSize) stDat = dbSlit ?\n     vec4 (nStep, nCyc, sWid, sGap) : vec4 (nStep, nCyc, pRad, pHeight);\n  else stDat = vec4 (p, 0.);\n  Savev4 (pxIv, stDat, fragColor, fragCoord);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Quantum Scattering\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec2 cs1, cs2;\nfloat tCur, nStep, gSize, deltaT, kappa, lambda, pHeight, pRad, sWid, sGap, enVal;\nbool dbSlit;\nconst float pi = 3.14159;\n\nvec2 PsiV (vec2 vId)\n{\n  return Loadv4 (mod (vId, gSize)).xy;\n}\n\nvec2 SProd (vec2 cs, vec2 ta, vec2 tb)\n{\n  vec4 t;\n  t = vec4 (ta, - tb.x, tb.y);\n  return vec2 (dot (cs, t.xw), dot (cs, t.yz));\n}\n\nvec2 PsiX (vec2 iv)\n{\n  vec2 ive, psi, psiP, psiN, e;\n  e = vec2 (1., 0.);\n  ive = iv;\n  ive.x -= mod (ive.x, 2.);\n  psi = PsiV (ive);\n  psiP = PsiV (ive + e);\n  psiN = SProd (cs2, SProd (cs1, psi, psiP),\n     SProd (cs1, PsiV (ive - e), PsiV (ive - 2. * e)));\n  psiP = SProd (cs2, SProd (cs1, psiP, psi),\n       SProd (cs1, PsiV (ive + 2. * e), PsiV (ive + 3. * e)));\n  return (ive.x == iv.x) ? SProd (cs1, psiN, psiP) : SProd (cs1, psiP, psiN);\n}\n\nvec2 PsiY (vec2 iv)\n{\n  vec2 ive, psi, psiP, psiN, e;\n  e = vec2 (0., 1.);\n  ive = iv;\n  ive.y -= mod (ive.y, 2.);\n  psi = PsiX (ive);\n  psiP = PsiX (ive + e);\n  psiN = SProd (cs2, SProd (cs1, psi, psiP),\n     SProd (cs1, PsiX (ive - e), PsiX (ive - 2. * e)));\n  psiP = SProd (cs2, SProd (cs1, psiP, psi),\n       SProd (cs1, PsiX (ive + 2. * e), PsiX (ive + 3. * e)));\n  return (ive.y == iv.y) ? SProd (cs1, psiN, psiP) : SProd (cs1, psiP, psiN);\n}\n\nvec3 Step (vec2 iv)\n{\n  vec2 psi, dv, eVal, pt;\n  float pVal;\n  pVal = 0.;\n  dv = abs (iv / gSize - 0.5);\n  if (dbSlit) {\n    if (dv.x <= 1. / gSize && abs (dv.y - 0.5 * (sGap + sWid)) > 0.5 * sWid)\n       pVal = 3.;\n  } else {\n    if (length (dv) < pRad) pVal = pHeight;\n  }\n  pVal *= deltaT * kappa * kappa;\n  eVal = vec2 (cos (pVal), sin (pVal));\n  cs1 = vec2 (cos (1. / lambda), - sin (1. / lambda));\n  cs2 = vec2 (cos (2. / lambda), - sin (2. / lambda));\n  pt = PsiY (iv);\n  psi = vec2 (eVal.x * pt.x + eVal.y * pt.y, eVal.x * pt.y - eVal.y * pt.x);\n  return vec3 (psi, dot (psi, psi));\n}\n\nvec3 Init (vec2 iv)\n{\n  vec2 psi, org, vKap, u;\n  float pakWid, f, a;\n  org = dbSlit ? vec2 (0.2, 0.5) : vec2 (0.2, 0.2);\n  vKap = normalize (dbSlit ? vec2 (1., 0.) : vec2 (1.));\n  pakWid = 0.05;\n  psi = vec2 (0.);\n  if (min (iv.x, iv.y) > 0. && max (iv.x, iv.y) <  gSize - 1.) {\n    u = iv / (gSize - 1.) - org;\n    f = 0.5 * dot (u, u) / (pakWid * pakWid);\n    if (f < 10.) {\n      a = dot (kappa * sqrt (enVal) * vKap, u + org);\n      psi = exp (- f) * vec2 (cos (a), sin (a));\n    }\n  }\n  return vec3 (psi, dot (psi, psi));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 p;\n  vec2 canvas, pxIv;\n  float mxStep, pxId, nCyc;\n  bool doInit;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  gSize = (canvas.y > 160.) ? 256. : 128.;\n  pxIv = floor (fragCoord);\n  pxId = pxIv.x + gSize * pxIv.y;\n  if (pxIv.x >= gSize || pxId > gSize * gSize) discard;\n  enVal = 1.;\n  lambda = 40.;\n  kappa = 100.;\n  deltaT = 2. / (lambda * (gSize - 1.) * (gSize - 1.));\n  doInit = false;\n  if (iFrame <= 5) {\n    nCyc = 5.;\n    doInit = true;\n  } else {\n    stDat = Loadv4 (vec2 (0., gSize));\n    nStep = stDat.x;\n    nCyc = stDat.y;\n    ++ nStep;\n    dbSlit = (nCyc < 2.);\n    mxStep = dbSlit ? ((canvas.y > 160.) ? 4000. : 1300.) :\n       ((canvas.y > 160.) ? 5000. : 1600.);\n    if (nStep < mxStep) {\n      if (dbSlit) {\n        sWid = stDat.z;\n        sGap = stDat.w;\n      } else {\n        pRad = stDat.z;\n        pHeight = stDat.w;\n      }\n      p = Step (pxIv);\n    } else doInit = true;\n  }\n  if (doInit) {\n    nCyc = mod (++ nCyc, 6.);\n    nStep = 0.;\n    dbSlit = (nCyc < 2.);\n    if (dbSlit) {\n      sWid = 0.05;\n      sGap = 0.08;\n    } else {\n      pRad = 0.05;\n      pHeight = (nCyc == 2. || nCyc == 3.) ? 0.8 : -0.8;\n    }\n    p = Init (pxIv);\n  }\n  if (pxId == gSize * gSize) stDat = dbSlit ?\n     vec4 (nStep, nCyc, sWid, sGap) : vec4 (nStep, nCyc, pRad, pHeight);\n  else stDat = vec4 (p, 0.);\n  Savev4 (pxIv, stDat, fragColor, fragCoord);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Quantum Scattering\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec2 cs1, cs2;\nfloat tCur, nStep, gSize, deltaT, kappa, lambda, pHeight, pRad, sWid, sGap, enVal;\nbool dbSlit;\nconst float pi = 3.14159;\n\nvec2 PsiV (vec2 vId)\n{\n  return Loadv4 (mod (vId, gSize)).xy;\n}\n\nvec2 SProd (vec2 cs, vec2 ta, vec2 tb)\n{\n  vec4 t;\n  t = vec4 (ta, - tb.x, tb.y);\n  return vec2 (dot (cs, t.xw), dot (cs, t.yz));\n}\n\nvec2 PsiX (vec2 iv)\n{\n  vec2 ive, psi, psiP, psiN, e;\n  e = vec2 (1., 0.);\n  ive = iv;\n  ive.x -= mod (ive.x, 2.);\n  psi = PsiV (ive);\n  psiP = PsiV (ive + e);\n  psiN = SProd (cs2, SProd (cs1, psi, psiP),\n     SProd (cs1, PsiV (ive - e), PsiV (ive - 2. * e)));\n  psiP = SProd (cs2, SProd (cs1, psiP, psi),\n       SProd (cs1, PsiV (ive + 2. * e), PsiV (ive + 3. * e)));\n  return (ive.x == iv.x) ? SProd (cs1, psiN, psiP) : SProd (cs1, psiP, psiN);\n}\n\nvec2 PsiY (vec2 iv)\n{\n  vec2 ive, psi, psiP, psiN, e;\n  e = vec2 (0., 1.);\n  ive = iv;\n  ive.y -= mod (ive.y, 2.);\n  psi = PsiX (ive);\n  psiP = PsiX (ive + e);\n  psiN = SProd (cs2, SProd (cs1, psi, psiP),\n     SProd (cs1, PsiX (ive - e), PsiX (ive - 2. * e)));\n  psiP = SProd (cs2, SProd (cs1, psiP, psi),\n       SProd (cs1, PsiX (ive + 2. * e), PsiX (ive + 3. * e)));\n  return (ive.y == iv.y) ? SProd (cs1, psiN, psiP) : SProd (cs1, psiP, psiN);\n}\n\nvec3 Step (vec2 iv)\n{\n  vec2 psi, dv, eVal, pt;\n  float pVal;\n  pVal = 0.;\n  dv = abs (iv / gSize - 0.5);\n  if (dbSlit) {\n    if (dv.x <= 1. / gSize && abs (dv.y - 0.5 * (sGap + sWid)) > 0.5 * sWid)\n       pVal = 3.;\n  } else {\n    if (length (dv) < pRad) pVal = pHeight;\n  }\n  pVal *= deltaT * kappa * kappa;\n  eVal = vec2 (cos (pVal), sin (pVal));\n  cs1 = vec2 (cos (1. / lambda), - sin (1. / lambda));\n  cs2 = vec2 (cos (2. / lambda), - sin (2. / lambda));\n  pt = PsiY (iv);\n  psi = vec2 (eVal.x * pt.x + eVal.y * pt.y, eVal.x * pt.y - eVal.y * pt.x);\n  return vec3 (psi, dot (psi, psi));\n}\n\nvec3 Init (vec2 iv)\n{\n  vec2 psi, org, vKap, u;\n  float pakWid, f, a;\n  org = dbSlit ? vec2 (0.2, 0.5) : vec2 (0.2, 0.2);\n  vKap = normalize (dbSlit ? vec2 (1., 0.) : vec2 (1.));\n  pakWid = 0.05;\n  psi = vec2 (0.);\n  if (min (iv.x, iv.y) > 0. && max (iv.x, iv.y) <  gSize - 1.) {\n    u = iv / (gSize - 1.) - org;\n    f = 0.5 * dot (u, u) / (pakWid * pakWid);\n    if (f < 10.) {\n      a = dot (kappa * sqrt (enVal) * vKap, u + org);\n      psi = exp (- f) * vec2 (cos (a), sin (a));\n    }\n  }\n  return vec3 (psi, dot (psi, psi));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 p;\n  vec2 canvas, pxIv;\n  float mxStep, pxId, nCyc;\n  bool doInit;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  gSize = (canvas.y > 160.) ? 256. : 128.;\n  pxIv = floor (fragCoord);\n  pxId = pxIv.x + gSize * pxIv.y;\n  if (pxIv.x >= gSize || pxId > gSize * gSize) discard;\n  enVal = 1.;\n  lambda = 40.;\n  kappa = 100.;\n  deltaT = 2. / (lambda * (gSize - 1.) * (gSize - 1.));\n  doInit = false;\n  if (iFrame <= 5) {\n    nCyc = 5.;\n    doInit = true;\n  } else {\n    stDat = Loadv4 (vec2 (0., gSize));\n    nStep = stDat.x;\n    nCyc = stDat.y;\n    ++ nStep;\n    dbSlit = (nCyc < 2.);\n    mxStep = dbSlit ? ((canvas.y > 160.) ? 4000. : 1300.) :\n       ((canvas.y > 160.) ? 5000. : 1600.);\n    if (nStep < mxStep) {\n      if (dbSlit) {\n        sWid = stDat.z;\n        sGap = stDat.w;\n      } else {\n        pRad = stDat.z;\n        pHeight = stDat.w;\n      }\n      p = Step (pxIv);\n    } else doInit = true;\n  }\n  if (doInit) {\n    nCyc = mod (++ nCyc, 6.);\n    nStep = 0.;\n    dbSlit = (nCyc < 2.);\n    if (dbSlit) {\n      sWid = 0.05;\n      sGap = 0.08;\n    } else {\n      pRad = 0.05;\n      pHeight = (nCyc == 2. || nCyc == 3.) ? 0.8 : -0.8;\n    }\n    p = Init (pxIv);\n  }\n  if (pxId == gSize * gSize) stDat = dbSlit ?\n     vec4 (nStep, nCyc, sWid, sGap) : vec4 (nStep, nCyc, pRad, pHeight);\n  else stDat = vec4 (p, 0.);\n  Savev4 (pxIv, stDat, fragColor, fragCoord);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Quantum Scattering\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec2 cs1, cs2;\nfloat tCur, nStep, gSize, deltaT, kappa, lambda, pHeight, pRad, sWid, sGap, enVal;\nbool dbSlit;\nconst float pi = 3.14159;\n\nvec2 PsiV (vec2 vId)\n{\n  return Loadv4 (mod (vId, gSize)).xy;\n}\n\nvec2 SProd (vec2 cs, vec2 ta, vec2 tb)\n{\n  vec4 t;\n  t = vec4 (ta, - tb.x, tb.y);\n  return vec2 (dot (cs, t.xw), dot (cs, t.yz));\n}\n\nvec2 PsiX (vec2 iv)\n{\n  vec2 ive, psi, psiP, psiN, e;\n  e = vec2 (1., 0.);\n  ive = iv;\n  ive.x -= mod (ive.x, 2.);\n  psi = PsiV (ive);\n  psiP = PsiV (ive + e);\n  psiN = SProd (cs2, SProd (cs1, psi, psiP),\n     SProd (cs1, PsiV (ive - e), PsiV (ive - 2. * e)));\n  psiP = SProd (cs2, SProd (cs1, psiP, psi),\n       SProd (cs1, PsiV (ive + 2. * e), PsiV (ive + 3. * e)));\n  return (ive.x == iv.x) ? SProd (cs1, psiN, psiP) : SProd (cs1, psiP, psiN);\n}\n\nvec2 PsiY (vec2 iv)\n{\n  vec2 ive, psi, psiP, psiN, e;\n  e = vec2 (0., 1.);\n  ive = iv;\n  ive.y -= mod (ive.y, 2.);\n  psi = PsiX (ive);\n  psiP = PsiX (ive + e);\n  psiN = SProd (cs2, SProd (cs1, psi, psiP),\n     SProd (cs1, PsiX (ive - e), PsiX (ive - 2. * e)));\n  psiP = SProd (cs2, SProd (cs1, psiP, psi),\n       SProd (cs1, PsiX (ive + 2. * e), PsiX (ive + 3. * e)));\n  return (ive.y == iv.y) ? SProd (cs1, psiN, psiP) : SProd (cs1, psiP, psiN);\n}\n\nvec3 Step (vec2 iv)\n{\n  vec2 psi, dv, eVal, pt;\n  float pVal;\n  pVal = 0.;\n  dv = abs (iv / gSize - 0.5);\n  if (dbSlit) {\n    if (dv.x <= 1. / gSize && abs (dv.y - 0.5 * (sGap + sWid)) > 0.5 * sWid)\n       pVal = 3.;\n  } else {\n    if (length (dv) < pRad) pVal = pHeight;\n  }\n  pVal *= deltaT * kappa * kappa;\n  eVal = vec2 (cos (pVal), sin (pVal));\n  cs1 = vec2 (cos (1. / lambda), - sin (1. / lambda));\n  cs2 = vec2 (cos (2. / lambda), - sin (2. / lambda));\n  pt = PsiY (iv);\n  psi = vec2 (eVal.x * pt.x + eVal.y * pt.y, eVal.x * pt.y - eVal.y * pt.x);\n  return vec3 (psi, dot (psi, psi));\n}\n\nvec3 Init (vec2 iv)\n{\n  vec2 psi, org, vKap, u;\n  float pakWid, f, a;\n  org = dbSlit ? vec2 (0.2, 0.5) : vec2 (0.2, 0.2);\n  vKap = normalize (dbSlit ? vec2 (1., 0.) : vec2 (1.));\n  pakWid = 0.05;\n  psi = vec2 (0.);\n  if (min (iv.x, iv.y) > 0. && max (iv.x, iv.y) <  gSize - 1.) {\n    u = iv / (gSize - 1.) - org;\n    f = 0.5 * dot (u, u) / (pakWid * pakWid);\n    if (f < 10.) {\n      a = dot (kappa * sqrt (enVal) * vKap, u + org);\n      psi = exp (- f) * vec2 (cos (a), sin (a));\n    }\n  }\n  return vec3 (psi, dot (psi, psi));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 p;\n  vec2 canvas, pxIv;\n  float mxStep, pxId, nCyc;\n  bool doInit;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  gSize = (canvas.y > 160.) ? 256. : 128.;\n  pxIv = floor (fragCoord);\n  pxId = pxIv.x + gSize * pxIv.y;\n  if (pxIv.x >= gSize || pxId > gSize * gSize) discard;\n  enVal = 1.;\n  lambda = 40.;\n  kappa = 100.;\n  deltaT = 2. / (lambda * (gSize - 1.) * (gSize - 1.));\n  doInit = false;\n  if (iFrame <= 5) {\n    nCyc = 5.;\n    doInit = true;\n  } else {\n    stDat = Loadv4 (vec2 (0., gSize));\n    nStep = stDat.x;\n    nCyc = stDat.y;\n    ++ nStep;\n    dbSlit = (nCyc < 2.);\n    mxStep = dbSlit ? ((canvas.y > 160.) ? 4000. : 1300.) :\n       ((canvas.y > 160.) ? 5000. : 1600.);\n    if (nStep < mxStep) {\n      if (dbSlit) {\n        sWid = stDat.z;\n        sGap = stDat.w;\n      } else {\n        pRad = stDat.z;\n        pHeight = stDat.w;\n      }\n      p = Step (pxIv);\n    } else doInit = true;\n  }\n  if (doInit) {\n    nCyc = mod (++ nCyc, 6.);\n    nStep = 0.;\n    dbSlit = (nCyc < 2.);\n    if (dbSlit) {\n      sWid = 0.05;\n      sGap = 0.08;\n    } else {\n      pRad = 0.05;\n      pHeight = (nCyc == 2. || nCyc == 3.) ? 0.8 : -0.8;\n    }\n    p = Init (pxIv);\n  }\n  if (pxId == gSize * gSize) stDat = dbSlit ?\n     vec4 (nStep, nCyc, sWid, sGap) : vec4 (nStep, nCyc, pRad, pHeight);\n  else stDat = vec4 (p, 0.);\n  Savev4 (pxIv, stDat, fragColor, fragCoord);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}