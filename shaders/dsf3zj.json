{
    "Shader": {
        "info": {
            "date": "1666424571",
            "description": "light",
            "flags": 32,
            "hasliked": 0,
            "id": "dsf3zj",
            "likes": 26,
            "name": "Light Room",
            "published": 3,
            "tags": [
                "light"
            ],
            "usePreview": 0,
            "username": "wyatt",
            "viewed": 337
        },
        "renderpass": [
            {
                "code": "Main {\n    Q = A(U)/A(U).w;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U/R))\n#define Main void mainImage (out vec4 Q, in vec2 U)\n\nvec2 quadratic (float a, float b, float c) {\n    float det = b*b-4.*a*c;\n    if (det<0.) return vec2(1e9);\n    return (-b+vec2(-1,1)*sqrt(det))/(2.*a);\n}\nvec4 color (float w) {\n    return cos(1.8+5.*w+vec4(1,2,3,4));;\n}\nvec2 sphere (vec3 p, vec3 d, float r) {\n    // (p + dx).(p + dx) = r*r\n    // p.p + 2p.dx + x.x = r*r\n    return quadratic(1.,2.*dot(p,d),dot(p,p)-r*r);\n}\n\nfloat plane (vec3 p, vec3 d, vec3 n) {\n    return -dot(p,n)/dot(d,n);\n}\nfloat mn (float a, float b) {\n    if (a < 0.&&b>0.) return b;\n    if (b < 0.&&a>0.) return a;\n    if (a < b &&a>0.) return a;\n    if (b < a &&b>0.) return b;\n    return 1e9;\n}\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define LIGHT vec3(.1,0.25,0.2)\n#define LIGHT_R .2\n#define SPHERE_1 vec3(0.3,0,.0)\n#define SPHERE_R .3\n#define SPHERE_2 vec3(-0.4,-.3,-.1)\n#define SPHERE_2R .4\n#define SPHERE_3 vec3(0.6,-.2,-.3)\n#define SPHERE_3R .1\n#define FLOOR .3\n#define WALL 1.\n#define PLANE_1 vec3(0,1,0)\n#define PLANE_2 vec3(0,0,1)\n#define PLANE_3 vec3(0,0,-1)\n#define PLANE_4 vec3(1,0,0)\n#define PLANE_5 vec3(-1,0,0)\n#define PLANE_6 vec3(0,-1,0)\nvoid scene (inout vec3 p, inout vec3 d, inout vec4 light, float i, float w) {\n    vec4 Q = vec4(0);\n    float x = 1e9;\n    vec2 sp1 = sphere(p-SPHERE_1,d,SPHERE_R);\n    vec2 sp3 = sphere(p-SPHERE_2,d,SPHERE_2R);\n    vec2 sp4 = sphere(p-SPHERE_3,d,SPHERE_3R);\n    vec2 sp2 = sphere(p-LIGHT,d,LIGHT_R);\n    float p1 = plane(p-vec3(0,-FLOOR,0),d,PLANE_1);\n    float p2 = plane(p-vec3(0,0,-WALL),d,PLANE_2);\n    float p3 = plane(p-vec3(0,0,WALL),d,PLANE_3);\n    float p4 = plane(p-vec3(-WALL,0,0),d,PLANE_4);\n    float p5 = plane(p-vec3(WALL,0,0),d,PLANE_5);\n    float p6 = plane(p-vec3(0,WALL,0),d,PLANE_6);\n    x = mn(x,mn(sp1.x,sp1.y));\n    x = mn(x,mn(sp2.x,sp2.y));\n    x = mn(x,mn(sp3.x,sp3.y));\n    x = mn(x,mn(sp4.x,sp4.y));\n    x = mn (x,p1);\n    x = mn (x,p2);\n    x = mn (x,p3);\n    x = mn (x,p4);\n    x = mn (x,p5);\n    x = mn (x,p6);\n    p += d*x;\n    vec3 h = hash32(vec2(iFrame,i));\n    if (x == sp1.x) {\n        Q = vec4(1,1,1,0);\n        vec3 n = normalize(p-SPHERE_1);\n        if (h.z>0.4)\n            d = refract(d,n,1./(1.5+.0*w));\n        else \n            d = reflect(d,n);\n    }\n    if (x == sp1.y) {\n        Q = vec4(1,1,1,0);\n        vec3 n = -normalize(p-SPHERE_1);\n        if (h.z>0.4)\n            d = refract(d,n,1.5+.0*w);\n        else \n            d = reflect(d,n);\n    }\n    if (x == sp3.x) {\n        Q = vec4(1,1,1,.2);\n        vec3 n = normalize(p-SPHERE_2);\n        if (h.z>0.2)\n            d = refract(d,n,1./(1.5+.0*w));\n        else \n            d = reflect(d,n);\n    }\n    if (x == sp3.y) {\n        Q = vec4(1,1,1,.2);\n        vec3 n = -normalize(p-SPHERE_2);\n        if (h.z>0.2)\n            d = refract(d,n,1.5+.0*w);\n        else \n            d = reflect(d,n);\n    }\n    if (x == sp4.y) {\n        Q = vec4(1,1,1,0);\n        vec3 n = -normalize(p-SPHERE_3);\n        d = reflect(d,n);\n    }\n    if (x == sp4.x) {\n        Q = vec4(1,1,1,0);\n        vec3 n = normalize(p-SPHERE_3);\n        d = reflect(d,n);\n    }\n    if (x == sp2.x) {\n        Q = vec4(1,1,1,6);\n        vec3 n = normalize(p-LIGHT);\n        d = normalize(h*2.-1.);\n        //d = reflect(n,d);\n    }\n    if (x == sp2.y) {\n        Q = vec4(1,1,1,6);\n        vec3 n = -normalize(p-LIGHT);\n        d = normalize(h*2.-1.);\n        //d = reflect(n,d);\n    }\n    if (x == p1) {\n        Q = vec4(1,1,1,0.);\n        vec3 n = PLANE_1;\n        d = normalize(h*2.-1.);\n        d.y = abs(d.y);\n    }\n    if (x == p2) {\n        Q = vec4(.9,.9,.9,0);\n        vec3 n = PLANE_2;\n        d = reflect(d,n);\n    }\n    \n    if (x == p3) {\n        Q = vec4(1,1,1,0);\n        vec3 n = PLANE_3;\n        d = reflect(d,n);\n    }\n    if (x == p4) {\n        Q = vec4(.9,1,.9,0);\n        vec3 n = PLANE_4;\n        d = reflect(d,n);\n    }\n    if (x == p5) {\n        Q = vec4(1,.9,.8,0);\n        vec3 n = PLANE_5;\n        d = reflect(d,n);\n    }\n    if (x == p6) {\n        Q = .3*vec4(.9,.9,1,0);\n        vec3 n = PLANE_6;\n        d = reflect(d,n);\n    }\n    if (x > 1000.) {\n        Q = vec4(0);\n    }\n    light.xyz *= Q.xyz;\n    light.w += Q.w;\n    p += 1e-5*d;\n}\nMain {\n    vec2 u = 2.*(U-.5*R)/R.y;\n    vec3 h = hash32(U);\n    vec2 dr = .0*h.x*vec2(cos(6.2*h.y),sin(6.2*h.y));\n    vec3 p = vec3(.3*u-dr,-.6*WALL);\n    vec3 d = normalize(vec3(u+dr,1));\n    \n    float w = .1+.8*h.z;\n    Q = 1.+.0*color(w);\n    Q.w = 0.;\n    for (float i = 0.; i < 25.; i++) {\n        scene(p,d,Q,i,w);\n    }\n    Q = Q*Q.w;\n    Q.w = 1.;\n    Q += A(U);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}