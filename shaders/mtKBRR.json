{
    "Shader": {
        "info": {
            "date": "1705569341",
            "description": "Animated reproduction of this image: https://www.pinterest.es/pin/163114817725152361/\nIt was made by Christopher David Ryan: https://christopherdavidryan.com/.",
            "flags": 0,
            "hasliked": 0,
            "id": "mtKBRR",
            "likes": 12,
            "name": "Animated swept spheres",
            "published": 3,
            "tags": [
                "color",
                "animated",
                "reproduction",
                "swepsphere"
            ],
            "usePreview": 0,
            "username": "Saimon",
            "viewed": 179
        },
        "renderpass": [
            {
                "code": "/* \"Animated swept spheres\"\n * I wanted to practice GLSL and the primitives describe in https://thebookofshaders.com/07/\n * so I started looking for art images to try to reproduce.\n * This one is part of my practice serie, it is based on this image: \n * https://www.pinterest.es/pin/163114817725152361/\n * It was made by [Christopher David Ryan](https://christopherdavidryan.com/)\n * (November 2023)(started with 2166 char - Updated 17/01/24)\n */\n\n#define R       iResolution.xy\n// Clamp the color to make sure it's between [0;1]\n#define cc(C) clamp(C,0.,1.)\n#define RADIUS 0.35\n#define SIZE RADIUS*7.6\n\nfloat sdCircle(vec2 p, float r){\n  float w = .8/R.y;\n  return smoothstep(-w,w, length(p) - r);\n}\n\nfloat sweptSphere(vec2 st, vec2 dir, float radius){\n    float accumulatedSd = 1.;\n    for (float i = 0.; i < 2.272*10.; i++){\n        accumulatedSd *= sdCircle(st + i*0.012*dir, radius);\n    }\n    return accumulatedSd;\n}\n\n#define swS(st, dir) sweptSphere(st, dir, RADIUS)\n\n// Source of code: https://thebookofshaders.com/edit.php?log=160909065147\n// and http://www.kynd.info\nfloat linearstep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0.0, 1.0);\n}\n\n// Simplify version of code: https://thebookofshaders.com/edit.php?log=160909065147\n// and http://www.kynd.info\nfloat easeInOutExpo(float t) {\n  t = exp2(40.*t-10.);\n  return t < 1.\n      ?      .5 * t\n      : 1. - .5 / t;\n}\n\n#define tweenEIOE(t) easeInOutExpo(min(t, 1. -t))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 st = ( fragCoord.xy*2. -R.xy ) /R.y;\n\n  vec3 BLUE = vec3(0.,0.647,0.859),\n       MAGENTA = vec3(0.863,0.024,0.502),\n       YELLOW = vec3(0.933,0.89,0.043),\n       ORANGE = vec3(0.894,0.549,0.125),\n       VIOLET = vec3(0.529,0.153,0.545);\n\n  float t = mod(iTime, 2.);\n  float size1 = tweenEIOE(linearstep(0.,1.,t))*SIZE, // Magenta swept sphere\n        size2 = tweenEIOE(linearstep(0.5,1.5,t))*SIZE, // Yellow swept sphere\n        size3 = tweenEIOE(linearstep(1.,2.,t))*SIZE; // Blue swept sphere\n\n  // Make the animation loop perfectly\n  if (t < 0.5)\n      t += 2.;\n  float size4 = tweenEIOE(linearstep(1.5,2.5,t))*SIZE; // Orange swept sphere\n\n  fragColor.rgb = cc(swS(st + vec2(RADIUS,-RADIUS), vec2(0.,size1)) + MAGENTA)\n                * cc(swS(st + vec2(RADIUS,RADIUS), vec2(-size2,0.)) + YELLOW)\n                * cc(swS(st + vec2(-RADIUS,RADIUS), vec2(0.,-size3)) + BLUE)\n                * cc(swS(st + vec2(-RADIUS,-RADIUS), vec2(size4,0.)) + ORANGE)\n                * cc(sdCircle(st, RADIUS) + VIOLET);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}