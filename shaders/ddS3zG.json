{
    "Shader": {
        "info": {
            "date": "1667848237",
            "description": "Move the camera with the mouse",
            "flags": 32,
            "hasliked": 0,
            "id": "ddS3zG",
            "likes": 18,
            "name": "My first pathtracing scene",
            "published": 3,
            "tags": [
                "lighting",
                "bounce",
                "occlusion",
                "indirect",
                "sample",
                "ambient",
                "tracer",
                "path",
                "monte",
                "carlo"
            ],
            "usePreview": 0,
            "username": "kishimisu",
            "viewed": 513
        },
        "renderpass": [
            {
                "code": "/* I'm currently learning to implement path-tracing by following this article:\n   https://iquilezles.org/articles/simplepathtracing/\n   \n   * Left image has nice anti-aliasing and indirect lighting \n     thanks to path-tracing with 4 bounces.\n   \n   * Right image is regular raymarching with direct lighting only.\n   \n   * Move the camera to reset the accumulated samples.\n   \n   There is only one point light source, no sky or sun light.\n   I'm not sure if the randomness of ray directions is working correctly\n   as we can see patterns in the noise when moving the camera.\n   \n   I might need to work a bit more on this before learning about\n   importance sampling!\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    float t = texelFetch(iChannel0, ivec2(0.5, 0.5), 0).r;\n    \n    col /= 1. + float(iFrame) - t;\n    col = pow(col, vec3(0.45));\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define BOUNCES 4\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define hash(p) fract(sin(p)*43758.5453)\n#define hash33(p) fract(sin((p) * mat3(127.1,311.7,74.7, 269.5,183.3,246.1, 113.5,271.9,124.6))*43758.5453123)\n\nvec3 lightPos = vec3(0., 1.4, 0.);\nvec3 groundColor = vec3(.9, .8, .7);\n\nfloat sdBox(vec3 p, vec3 s) {\n  vec3 q = abs(p) - s;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-.0;\n}\n\nvec2 scene(vec3 p) {\n    float ground = p.y + .2;\n    \n    vec3 p0 = p;\n    p.xz = fract(p.xz+.5)-.5;\n    float boxes = sdBox(p, vec3(.2, .2 + length(sin(floor(p0+.5)*8.))*.1, .35))/2.;\n  \n    if (boxes < ground) return vec2(boxes, 1.);\n    return vec2(ground, 0.);\n}\n\nvec3 cosineDirection(float seed, vec3 nor) {\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    \n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n    float a = 6.283185 * v;\n\n    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\nvec2 worldIntersect(vec3 ro, vec3 rd, float maxt) {\n    float t = 0.;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + t*rd;\n        vec2 d = scene(p);\n        t += d.x;\n        \n        if (d.x < 0.01) return vec2(t, d.y);\n        if (t > maxt) break;\n    }\n    return vec2(-1.);\n}\n\nfloat worldShadow(vec3 ro, vec3 rd, float maxt) {\n    float t = 0.;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + t*rd;\n        \n        float d = scene(p).x;\n        t += d;\n        \n        if (d < 0.01) return 0.;\n        if (t > maxt) break;\n    }\n    return 1.;\n}\n\nvec3 worldGetNormal(vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*scene( p + k.xyy*h ).x + k.yyx*scene( p + k.yyx*h ).x + \n                      k.yxy*scene( p + k.yxy*h ).x + k.xxx*scene( p + k.xxx*h ).x );\n}\n\nvec3 worldApplyLighting(vec3 p, vec3 nor) {\n    vec3 lightDir = normalize(lightPos - p);\n    float lightDist = length(lightPos - p);\n    float diffuse = clamp(dot(nor, lightDir), 0., 1.);\n    float shadow = worldShadow(p, lightDir, lightDist);\n    float att = clamp(1./pow(lightDist*.4, 2.), 0., 1.);\n    \n    return vec3(diffuse * shadow * att);\n}\n\nvec3 worldGetColor(vec3 p, float objectID) {\n    if (objectID == 0.) return groundColor;\n    else {\n        vec3 fp = floor(p-vec3(.5,0.,.5));\n        if (fp.xz == vec2(-1.)) return vec3(1.);\n        return sin(vec3(.02,.04,.06)*fp*1000.)*.5+.5;\n    }\n}\n\nvec3 worldGetBackground(vec3 rd) {\n    return rd.y * vec3(.4, .4, .5);\n}\n\n#define isLightCube(p) floor(p-.5).xz == vec2(-1.)\nvec3 renderPixel(vec3 ro, vec3 rd, float sa, bool renderRaymarching) {\n    vec3 tcol = vec3(0.0);\n    vec3 fcol = vec3(1.0);\n  \n    for (int i = 0; i < BOUNCES; i++) {\n        vec2 res = worldIntersect(ro, rd, 30.);\n    \n        if (res.y < 0.) {\n            if (i == 0) return worldGetBackground(rd);\n            break;\n        }\n        \n        vec3 p = ro + (res.x-.02)*rd;\n        vec3 n = worldGetNormal(p);\n\n        vec3 scol = worldGetColor(p, res.y);\n        vec3 dcol = (res.y == 1. && isLightCube(p)) ? vec3(1.) : worldApplyLighting(p, n);\n\n        ro = p;\n        rd = cosineDirection(76.2 + 73.1*float(i) + sa + 17.7*float(iFrame), n);\n\n        fcol *= scol;\n        tcol += fcol * dcol; \n\n        if (renderRaymarching) break;\n    }\n    \n    return tcol;\n}\n\nvoid initRayOriginAndDirection(vec2 uv, inout vec3 ro, inout vec3 rd) {\n    vec2 m = iMouse.xy/iResolution.xy*2.-1.;\n    \n    float z = iMouse.z > 0. ? 1. : smoothstep(0., 6., iTime);\n    ro = vec3(0., 0., iMouse.z == 0. ? 4. : 4. - 1.+(m.y*.5+.5)); \n    ro.yz *= rot(iMouse.z == 0. ? -0.3 : (m.y-.9)*.5);\n    ro.zx *= rot(iMouse.z == 0. ? -5.6 : m.x*2.);\n        \n    vec3 f = normalize(-ro), r = normalize(cross(vec3(0,1,0), f));\n    rd = normalize(f + uv.x*r + uv.y*cross(f, r));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 color = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n    if (iMouse.z > 0. || iFrame == 0) color *= 0.;\n    \n    bool renderRaymarching = fragCoord.x/iResolution.x > .5;\n    float sa = renderRaymarching ? 0. : hash(dot(fragCoord, vec2(12.9898, 78.233)) + 1113.1*iTime);\n    \n    vec2 of = (vec2( hash(sa+13.271), hash(sa+63.216) )-0.5);\n    vec2 uv = (fragCoord+of - .5*iResolution.xy)/iResolution.y;\n\n    vec3 ro, rd;\n    initRayOriginAndDirection(uv, ro, rd);\n    \n    color += renderPixel(ro, rd, sa, renderRaymarching);\n    color *= smoothstep(0.003, .004, abs(fragCoord.x/iResolution.x - .5));\n\n    if (fragCoord == vec2(0.5, 0.5) && iMouse.z > 0.) color.r = float(iFrame);\n    \n    fragColor.rgb = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}