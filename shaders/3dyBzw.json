{
    "Shader": {
        "info": {
            "date": "1606756334",
            "description": "The shader uses ray marching. the reflections are just like ray tracing, and the transparency is a different layer. the glow effect is the amount of steps to the object if the ray hit nothing.",
            "flags": 0,
            "hasliked": 0,
            "id": "3dyBzw",
            "likes": 3,
            "name": "Midnight mountain ",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "me_123",
            "viewed": 376
        },
        "renderpass": [
            {
                "code": "float min_dist = 0.001;\nfloat max_dist = 10.;\nint max_steps =200;\nvec3 lightPos = vec3(0, 1, 1);\nfloat hash(vec3 pp) {\n    vec2 p = pp.xy+(pp.z/100.);\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nvec4 un(vec4 a, vec4 b) {\n\treturn a.w < b.w? a : b;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nvec4 nois(in vec3 x) {\n\tvec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.);\n    vec3 du = 30.*w*w*(w*(w-2.0)+1.0);\n    float a = hash(p+vec3(0, 0, 0));\n    float b = hash(p+vec3(1, 0, 0));\n    float c = hash(p+vec3(0, 1, 0));\n    float d = hash(p+vec3(1, 1, 0));\n    float e = hash(p+vec3(0, 0, 1));\n    float f = hash(p+vec3(1, 0, 1));\n    float g = hash(p+vec3(0, 1, 1));\n    float h = hash(p+vec3(1, 1, 1));\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k3 = e - a;\n    float k4 = a - b - c + d;\n    float k5 = a - c - e + g;\n    float k6 = a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n    return vec4(-1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z),\n                2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z, \n                                k2 + k5*u.z + k4*u.x + k7*u.z*u.x, \n                                k3 + k6*u.x + k5*u.y + k7*u.x*u.y));\n}\nvec4 fbm(in vec3 x, int octives) {\n\tfloat f = 1.98;\n    float s = 0.6;\n    float a = 0.0;\n    float b = 0.3;\n    vec3 d = vec3(0);\n    float o = 0.6;\n    mat3 m = mat3(o, 0, 0, 0, o, 0, 0, 0, o);\n    for (int i = 0; i < octives; i ++) {\n        vec4 n = nois(x);\n        a += b*n.x;\n        d += b*m*n.yzw;\n        b *= s;\n        x = f*m*x;\n        m = f*m*m;\n    }\n    return vec4(a, d);\n}\nfloat terrain(vec3 p) {\n\tfloat a = 0.0;\n    float b = 1.0;\n    vec2 d = vec2(0);\n    for (int i = 0; i < 9; i += 1) {\n    \tvec3 n = nois(p).xyz;\n        d += n.yz;\n        a += b*n.x/(1.+dot(d,d));\n        b *= 0.5;\n        p = p*2.1;\n    }\n    return a;\n}\nstruct ray {\n\tfloat dist;\n    float ao;\n    vec3 pos;\n    vec3 normal;\n    vec3 color;\n    vec3 cc;\n};\nvec4 SDF(in vec3 p, in bool tt, bool ttt) {\n    if (!ttt) {\n        float t = (abs(nois(p*(nois(p*20.).xyz*20.)).xyz).x+1.0)/2.;//mix(vec3(0.5, 0.5, 1.0),vec3(1), vec3(p.y+0.2));\n        vec3 color = mix(vec3(t/1.5, t/3., 0.0), vec3(1), clamp(clamp(p.y+0.1, 0.0, 1.0)*20., 0.0, 1.5));\n        if (tt) {\n          return un(un(vec4(color, ((p.y+terrain(p*0.5)*((nois(p/11.).x)/2.)))/3.), vec4(vec3(0.111), (p.y+0.1)+(fbm(p*20., 4).x/2000.))), vec4(vec3(0.222, 0, 0), length(p-vec3(0.7, 0.5, 1.))-0.1));\n        } else {\n          return un(vec4(color, ((p.y+terrain(p*0.5)*((nois(p/10.).x)/2.)))/3.), vec4(vec3(0.222, 0, 0), length(p-vec3(0.7, 0.5, 1.))-0.1));\n        }\n    } else {\n        return vec4(vec3(0.222, 0, 0), (length(p-vec3(0.7, 0.5, 1.))-0.1)/10.);\n    }\n}\nvec3 getNormal(vec3 p, bool tt, bool ttt) {\n\tvec2 e = vec2(0.00001, 0);\n    float d = SDF(p, tt, ttt).w;\n    vec3 n = d -vec3(\n    \tSDF(p-e.xyy, tt, ttt).w,\n    \tSDF(p-e.yxy, tt, ttt).w,\n    \tSDF(p-e.yyx, tt, ttt).w\n    );\n\treturn (normalize(n));\n}\nray get_ray(vec3 ro, vec3 rd, bool tt, bool ttt) {\n\tfloat d0 = 0.0;\n    vec3 p = vec3(0);\n    float steps = 0.0;\n    vec3 color = vec3(0);\n    vec3 cc = vec3(0);\n    for (int i = 0; i < max_steps; i += 1) {\n        steps += 1.;\n        p = ro+rd*d0;\n        vec4 rr = SDF(p, tt, ttt);\n        float d = rr.w;\n        d0 += d;\n        cc += 1.;\n        color = rr.xyz;\n        if (d0 > max_dist || d < min_dist) {\n            break;\n        }\n    }\n    return ray(d0, steps, p, getNormal(p, tt, ttt), color, cc/200.);\n}\nvec3 getColor(vec3 roo, vec3 rdd, bool tt, bool ttt) {\n    vec3 color = vec3(1);\n    ray rr;\n    vec3 ro = roo;\n    vec3 rd = rdd;\n    vec3 sky;\n    float dist = 0.0;\n    for (int i = 0; i < 2; i += 1) {\n    \tfloat t = clamp(rd.y+0.5, 0.0, 0.5);\n   \t\tsky = vec3(t*1., t*1., t*1.4)*1.5;\n    \tray rr = get_ray(ro, rd, tt, ttt);\n        if (rr.dist < max_dist) {\n            dist = rr.dist;\n            if (rr.color.x != 0.111) {\n                if (rr.color.x != 0.222) {\n               \t\tcolor *= rr.color * vec3((clamp((dot(rr.normal, normalize(lightPos))+0.2)-(0.5/rr.ao), 0.0, 1.0)+0.2)/1.9)*vec3(1.2, 1.2, 1.1);\n                \tbreak;\n                } else {\n                    color = vec3(1.5, 1.5, 0.8);\n                }\n            } else {\n                ro = rr.pos*0.99;\n            \trd = reflect(rdd, rr.normal);\n                color = vec3(0.7, 0.7, 0.8);\n            }\n        } else {\n            color = vec3(rr.cc*1.5)*sky*color;\n            break;\n        }\n    }\n    color = mix(color*1.0, clamp(sky, 0.0, 1.0), (dist/10.));\n    return color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = iResolution.x/iResolution.y;\n    vec2 uv = ((fragCoord.xy/iResolution.xy)-0.5) * vec2(r, 1.);\n    vec3 ro = vec3(sin(10.)*2., 0.1, cos(10.)*2.);\n    vec3 at = vec3(0);\n    vec3 cam_z = normalize(at-ro);\n    vec3 cam_x = normalize(cross(vec3(0, 1, 0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 1.5 * cam_z);\n\tvec3 color = mix(mix(getColor(ro, rd, false, false), getColor(ro, rd, true, false), 0.6), getColor(ro, rd, true, true), 0.6);\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}