{
    "Shader": {
        "info": {
            "date": "1530220047",
            "description": "fbm protuded plain",
            "flags": 96,
            "hasliked": 0,
            "id": "lsVfzt",
            "likes": 6,
            "name": "Colour/LavaShader",
            "published": 3,
            "tags": [
                "sdf",
                "fbm"
            ],
            "usePreview": 0,
            "username": "felipunkerito",
            "viewed": 629
        },
        "renderpass": [
            {
                "code": "// EPS defines the epsilon that we use as a minimum for going out of our trace\n// function ray or for defining our shading's function sha 3D treshold\n#define EPS       0.001\n\n// The STEPS integer stores the number of rays that we shoot at our scene, \n// more means a better resolution(specially at the edges) but it also\n// messes up our frame rate as it means many more calculations\n#define STEPS        64\n\n// The FAR float macro defines where should we stop tracing according to the\n// distance from our camera to the 3D scene\n#define FAR        70.0\n\n// Simple trigonometric trick to get pi\n#define PI acos( -1.0 )\n\n// Double the pi's value to get a full rotation in our camera matrix\n#define TPI     PI * 2.\n\n// The COLOUR macro defines how should we colour our scene, if it is defined \n// the function will return a different value than if its not. Simply comment\n// or uncomment the next line to see what I mean\n#define COLOUR\n\n// Samples our microphone's or music's frequency, it is stored in a texture\n// as all of the inputs here in shadertoy so we must call the texture() \n// function with input 1 our Channel, input 2 we define the frequency that we\n// want to sample in two dimensions after we ask only for the x part of the \n// texture as it is a texture it contains 3 values and we only want one float\n// after we multiply by 0.1 to obtain a less strong value for our purposes\n#define WAV texture( iChannel0, vec2( 0.0, 0.25 ) ).x * 0.05\n#define FRE texture( iChannel0, vec2( 0.0, 0.75 ) ).x * 0.05\n\n// Creates a random number from 0 to 1 ( sine's fractional part so for\n// example if we input sin( 3 ) we obtain 0.29552020666, its fract is only \n// 29552020666 ) it is not really a random value but more of a \n// pseudo-stochastic one, as if we will get the same value for the same seed\n// note that this is not entirely true as in different machines we have \n// different floating point precision in the GPU so the number will differ \n// from one computer to another.\nfloat hash( vec2 a )\n{\n\n    return fract( sin( a.x * 3433.8 + a.y * 3843.98 ) * 45933.8 );\n\n}\n\n// Here we store the Buffer A in which we have our wave simulation\nfloat h( vec3 p ) \n{ \n\n    return -0.05*textureLod(iChannel1, p.xy/10.0 + 0.5, 0. ).x; \n\n}\n\n// Divides the 2D space in tiles than those tiles are asigned a random colour\n// than we interpolate using GLSL's mix() function to interpolate to combine\n// the different random values of each tile into a 2D texture.\n\nfloat noise( vec2 uv )\n{\n    \n    vec2 lv = fract( uv );\n    lv = lv * lv * ( 3.0 - 2.0 * lv );\n    vec2 id = floor( uv );\n    \n    float bl = hash( id );\n    float br = hash( id + vec2( 1, 0 ) );\n    float b = mix( bl, br, lv.x );\n    \n    float tl = hash( id + vec2( 0, 1 ) );\n    float tr = hash( id + vec2( 1 ) );\n    float t = mix( tl, tr, lv.x );\n    \n    float c = mix( b, t, lv.y );\n    \n    return c;\n\n}\n\n// Adds the noise's function input ( uv ) by different octaves than divides the\n// whole function by it's negative octave to create a pattern that defines a \n// Fractional Brownian Motion see\n// https://en.wikipedia.org/wiki/Fractional_Brownian_motion and \n// https://thebookofshaders.com/13/\n// uncomment the next line to see what I mean\n//#define FBM\n\nfloat fbm( vec2 uv )\n{\n    \n\tfloat f = 0.0;\n    \n    #ifdef FBM\n    \n    f = noise( uv * 4.0 );\n    f += noise( uv * 8. ) * 0.5; \n    f += noise( uv * 16. ) * 0.25; \n    f += noise( uv * 32. ) * 0.125; \n    f += noise( uv * 64. ) * 0.0625; \n    //f += noise( uv * 126. ) * 0.03125;\n    f /= 2.0;\n    \n    #else\n \n\tf = noise( uv * 4.0 );\n    f += noise( uv * 8. ) * 0.5; uv += WAV * 1.1; \n    f += noise( uv * 16. ) * 0.25; uv -= WAV * 1.2;\n    f += noise( uv * 32. ) * 0.125; uv += WAV * -1.1;\n    f += noise( uv * 64. ) * 0.0625; uv -= WAV * 1.4;\n    //f += noise( uv * 126. ) * 0.03125;\n    f /= 2.0;\n    \n    #endif\n    \n    return f;\n\n}\n\n// Samples the fbm to the y direction of the plane \n// We add domain distortion to get the curly looking fluid \n// https://iquilezles.org/articles/warp\nfloat hei( vec2 uv )\n{\n\n    // We use the mod function to repeat the iTime as we get artifacts\n    // when we have a very high float number from iTime\n    return fbm( uv * 0.1 + fbm( uv * 0.1 + mod( iTime * 0.01, 100.0 ) ) );\n\n}\n\n// Samples the fbm at different inputs to get a different colour\nfloat pat( vec2 uv, out vec3 pa )\n{\n\n    uv += iTime * 0.05 + WAV;\n    \n    pa = vec3( hei( uv * 4.0 + FRE ) * 2.0, hei( uv * 2.0 + WAV ),\n               hei( uv - 3.0 + ( WAV * 1.5 ) )\n             );\n    \n    return 1.0;\n\n}\n\n// Defines a Signed Distance Function if its inside the surface it returs 0\n// else it returns a positive number, although this is a float that we need \n// to output it is important for our shading to return a 2nd value therefore\n// it is a vec2, this way we can change our shading according to the index \n// that we assing to the SDF\n// https://en.wikipedia.org/wiki/Signed_distance_function\nvec2 map(vec3 p)\n{\n    \n    // Here we input the xz of our position, that means our y direction\n    float a = hei( p.xz );\n    \n    // Here we create the plane function p.y + 1.0 or in this case p.y + a \n    // as we want to create a heightmap from our Fractional Brownian Motion \n\tvec2 rip = vec2( p.y + a, 0.0 );\n\n    return rip;\n}\n\n// We define the perpendiculars according to sampling the Signed Distance \n// Function and doing Numerical Differentiation aka we find the derivatives\n// https://en.wikipedia.org/wiki/Numerical_differentiation\nvec3 nor( vec3 p )\n{\n\n    vec2 e = vec2( EPS, 0.0 );\n    return normalize( vec3( map( p + e.xyy ).x - map( p - e.xyy ).x,\n                            map( p + e.yxy ).x - map( p - e.yxy ).x,\n                            map( p + e.yyx ).x - map( p - e.yyx ).x\n                           )\n                    );\n\n}\n\n// We trace a ray from its Ray Origin(ro) and to its Ray Direction(rd) if we\n// get close enough to our Signed Distance Function we stop, this distance is\n// defined by EPS aka epsilon. We also stop if the distance of the ray is more\n// than the defined maximum length aka FAR\nfloat ray( vec3 ro, vec3 rd, out float d )\n{\n\n    float t = 0.0;\n    for( int i = 0; i < STEPS; ++i )\n    {\n    \n        d = map( ro + rd * t ).x;\n        if( d < EPS || t > FAR ) break;\n        t += d;\n        \n    }\n    \n    return t;\n\n}\n\n// We trace a ray from our Ray Origin(ro) to our Ray Direction(rd) in a way \n// similar to our ray function but we increment according to the intersections\n// of our ray \n// https://iquilezles.org/articles/rmshadows\nfloat softShadows( in vec3 ro, in vec3 rd )\n{\n\n    float res = 1.0;\n    for( float t = 0.1; t < 8.0; ++t )\n    {\n    \n        float h = map( ro + rd * t ).x;\n        res = min( res, 4.0 * h / t );\n        t += h;\n    \n    }\n    \n    return res;\n\n}\n\n// We compute the colours according to different simulated phenomena such as\n// diffuse, ambient, specularity\n// Variable definitions:\n// col = to the output RGB channels we are calculating\n// d = our Signed Distance Function\n// t = our ray's distance\n// p = our point in space\n// n = our numerical gradient aka derivatives aka perpendicular of our surface\n// a = we sample our height function in y to get a value to interpolate for\n// our colour in line 255, 256\n// lig = our lights position, note that we must normalize as we dont want a \n// direction but only a point in space \n// blig = another light that we define by negating our original light\n// pa = the initialization of our 3D vector that we input in our pat for\n// pattern function to get different colours for our different RGB channels\n// co = this is a way to get a different output from a function than the \n// return way, see line 103 to see how to define it in the inputs of our \n// function\n// amb = our ambient light, we use our y direction in the normals to fake a \n// sun's parallel rays\n// dif = we use the dot product from our normals and our light to get the \n// diffuse component we must use the max function to not get a value less \n// than 0 as this is incorrect\n// spe = our specular component we use the same process of our diffuse \n// component but instead we over load it by the clamp and power functions to \n// get a much brighter result that simulates the bright reflection of a light\n// into a surface\n// speO = specular component two, we use here instead of the dot product from\n// the light and the normals, the back light and the normals\n// col *= sqrt( col ) a cheap gamma correction\nvec3 sha( vec3 ro, vec3 rd )\n{\n    \n    vec3 col = vec3( 0.0 );\n    float d = 0.0;\n    float t = ray( ro, rd, d );\n    vec3 p = ro + rd * t;\n    vec3 n = nor( p );\n    float a = hei( p.xz );\n    vec3 lig = normalize( vec3( 1.0, 0.8, 0.6 ) );\n    vec3 blig = vec3( -lig.x, -lig.y, -lig.z );\n    vec3 pa = vec3( 0 );\n    float co = pat( p.xz, pa );\n    float sha = softShadows( p, lig );\n    \n    float amb = 0.5 + 0.5 * n.y;\n    float dif = max( 0.0, dot( n, lig ) );\n    float bac = max( 0.0, 0.5 + 0.2 * dot( n, blig ) );\n    float spe = pow( clamp( dot( n, lig ), 0.0, 1.0 ), 16.0 );\n    float speO = pow( clamp( dot( n, blig ), 0.0, 1.0 ), 16.0 );\n    \n    col += amb;\n    col += 1.0 * blig;\n    col += vec3( 0.4 ) * dif * sha;\n    col *= 0.5 + vec3( 0.0, 0.5, 0.4 );\n    col += 1.0 * spe * speO;\n    \n    // We have different colour values if the macro COLOUR is defined we compute\n    // the fbm function with slightly different inputs to get a different R,G and\n    // B colour\n    #ifdef COLOUR\n    \n    col *= pa * 2.0;\n    \n    // If we have the macro COLOUR not defined we compute the colours according to\n    // the height's function hei so that in the valleys we have one colour and in \n    // our mountains we have another\n    #else \n    \n    col += vec3( 0.0, 0.1, 0.3 );\n    col *= mix( vec3( 1.0, 0.0, 0.0 ), vec3( 2.0, 1.0, 0.1 ), a );\n    col *= mix( vec3( 0 ), vec3( 0.7, 0.2, 0.1 ), a );\n    col *= 5.0;\n    \n    #endif\n    \n    col *= sqrt( col );\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n\n    // We create a camera matrix and we create the mou variable that lets us\n    // get input from our mouse\n    vec2 mou = iMouse.xy / iResolution.xy;\n    vec3 ro = 3.0 * vec3( sin( mou.x * TPI ), 1.0, cos( -mou.x * TPI ) );\n    vec3 ww = normalize( vec3( 0.0 ) - ro );\n    vec3 uu = normalize( cross( vec3( 0.0, 1.0, 0.0 ), ww ) );\n    vec3 vv = normalize( cross( ww, uu ) );\n    vec3 rd = normalize( uv.x * uu + uv.y * vv + 1.5 * ww );\n    \n    // We intialize the values for our tracing function ray and our p for \n    // position and our n for normals or gradient\n    float d = 0.0;\n    float t = ray( ro, rd, d );\n    vec3 p = ro + rd * t;\n    vec3 n = nor( p );\n    vec3 col = vec3( 0 );\n    \n    // If the value of d for Distance Function is smaller than our minimum\n    // value aka EPS or epsilon we call our shade function sha else we colour\n    // the pixels to 0 or black\n    \n    #ifdef FBM\n    \n    col = vec3( fbm( uv ) );\n    \n    #else\n    \n    col = d < EPS ? sha( ro, rd ) : vec3( 0 );\n    \n    #endif\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 15842,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/liar_avicenna/jefferson-airplane-white"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This is taken from my own shader https://www.shadertoy.com/view/llfBzl\nfloat tri( float dis, float dec, float fre, float amp, float spe )\n{\n\n\treturn exp( -dec * dis ) * sin( dis * fre + ( -iTime * spe ) ) * amp;\n    \n}\n\n// This function returns the center of the uv coordinates and relates it to the mouse position \nfloat dis( vec2 uv, vec2 mou )\n{\n\n\treturn length( uv - mou );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = fragCoord / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 mou = iMouse.xy / iResolution.y;\n    \n    float dist = dis( p, mou );\n    float amp = 1.4;\n    float dec = 45.0;\n    float fre = 400.0;\n    float spe = 5.0;\n    \n    if( iMouse.z < 0.1 ) \n    {\n    \t\n        dist = dis( p, vec2( 0.9 + sin( iTime * 5.0 ) * 0.5, 0.5 - cos( iTime * 5.0 ) * 0.5 ) );\n        \n    }\n    \n    float col = tri( dist, dec, fre, amp, spe );\n    \n    float xpi = 1.0 / iResolution.x;\n    float ypi = 1.0 / iResolution.y;\n    \n    vec4 center = texture( iChannel0, uv );\n    float top = texture( iChannel0, vec2( uv.x, uv.y + ypi ) ).r;\n\tfloat rig = texture( iChannel0, vec2( uv.x + xpi, uv.y ) ).r;\n    float lef = texture( iChannel0, vec2( uv.x - xpi, uv.y ) ).r;\n    float dow = texture( iChannel0, vec2( uv.x, uv.y - ypi ) ).r;\n    \n    float red = -(center.a - 0.5) * 2.0 + (top + lef + rig + dow - 2.0);\n    red += col; // mouse\n    red *= 0.98; // damping\n    red *= step(0.1, iTime); // hacky way of clearing the buffer\n    red = 0.5 + red * 0.5;\n    red = clamp(red, 0., 1.);\n    \n    //fragColor = vec4( vec3( mix( vec4( 0, 0, 0, center.r ), vec4( red, 0.1, 0.0, center.r ), col ) ), 1 );\n    \n    fragColor = vec4( mix( vec3( red, 0.1, 0.4 ), vec3( 0.2, col, red ), col ), center.r );\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}