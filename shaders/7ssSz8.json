{
    "Shader": {
        "info": {
            "date": "1618282269",
            "description": "visita Ufo tierra",
            "flags": 8,
            "hasliked": 0,
            "id": "7ssSz8",
            "likes": 4,
            "name": "visita Ufo tierra",
            "published": 3,
            "tags": [
                "visitaufotierra"
            ],
            "usePreview": 0,
            "username": "jorge2017a1",
            "viewed": 258
        },
        "renderpass": [
            {
                "code": "//por jorge2017a1- 12/abril/2021\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\n\n///referencia  https://www.shadertoy.com/view/tdVfWd   \n///Created by jllusty in 2020-12-18\n\n/// dr2  Cloud =)Nubes\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 pp=p;\n    \n    float sc1= sdCylinderXZ( p-vec3(0.0,10.0,0.0), vec2(20.0,0.25) );\n    float se1=sdEllipsoid(  p-vec3(0.0,10.0,0.0), vec3(5.0,6.0,5.0) );\n    float se2=sdEllipsoid(  p-vec3(0.0,15.0,0.0), vec3(3.0,2.0,3.0) );\n    float sb1= sdBox(  p-vec3(0.0,6.0,0.0), vec3(6.0,4.0,6.0) );\n    \n    float dif= differenceSDF( se1, sb1);\n    res =opU3(res, vec3(sc1,-1.0,6.0)); \n    res =opU3(res, vec3(se2,-1.0,6.0)); \n    res =opU3(res, vec3(dif,-1.0,6.0)); \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    float strength = 2.; // lower number makes lighting do deeper into sphere\n    float  fresnel = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), strength);\n    lin+=vec3(1.0)*fresnel;\n     \n    return lin*atten;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    \n    float marchCount = 0.0;\n    vec3 p;\n    \n    float minDist = 999.0; \n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n         if ( abs(dS.x)<MIN_DIST)\n        { mObj.hitbln = true; minDist = abs(dO);break; }\n        \n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false; minDist = min(minDist, dO); break; }\n        \n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return dO;\n}\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\nfloat pi = 4.*atan(1.);\n\nmat2 rotate(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nvec2 rand(vec2 n) { \n\tfloat a = fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    float b = fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    return vec2(a,b);\n}\n\nvec3 RadialandAngular( vec2 puv )\n{\n    vec2 uv=puv;\n\n    float r = length(uv);\n    \n    if (int(floor(r)) % 2 == 0) {\n        float freq = rand(vec2(floor(r),1)).y;\n        uv *= rotate(freq*iTime);\n    }\n    float theta = atan(uv.y,uv.x)+pi;\n\n    float n = 7.;    \n    float eps = 30./iResolution.y;\n    float dt = abs(mod(theta+pi/n,2.*pi/n)-pi/n);\n    float ct = smoothstep(2.*eps,eps,dt*r);\n    \n    float dr = abs(fract(r+0.5)-0.5);\n    float cr = smoothstep(2.*eps,eps,dr);\n    \n    float cc = max(ct,cr);\n    \n    vec2 dc = rand(vec2(floor(n*theta/(2.0*pi)),floor(r)));\n    vec3 col = mix(vec3(dc.x),vec3(0.),cc);\n\n    // Output to screen\n    return col;\n}\n\n////----------------------------------------------\n\n\n\n//const float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  vec2 ff = f * f;\n  vec2 u = ff * (3. - 2. * f);\n  vec2 uu = 30. * ff * (ff - 2. * f + 1.);\n  vec4 h = Hashv4f (dot (i, cHashA3.xy));\n  return vec3 (h.x + (h.y - h.x) * u.x + (h.z - h.x) * u.y +\n     (h.x - h.y - h.z + h.w) * u.x * u.y, uu * (vec2 (h.y - h.x, h.z - h.x) +\n     (h.x - h.y - h.z + h.w) * u.yx));\n}\n\n\nvec3 sunDir;\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  vec2 p;\n  float cloudFac, w, f, s;\n    float tCur;\n   //float  a = pi * (0.5 + 0.3 * sin (0.1 * tCur));\n   float  a = pi * (0.5 + 0.3 * sin (0.1 * iTime*5.0));\n    sunDir = normalize (vec3 (cos (a), 0.5, sin (a)));\n    \n    \n     tCur = iTime*10.0;\n    if (rd.y > 0.) {\n  \t  ro.x += 2. * tCur;\n    \tp = 0.02 * (rd.xz * (100. - ro.y) / rd.y + ro.xz);\n    \tw = 0.8;\n    \tf = 0.;\n    for (int j = 0; j < 4; j ++) \n    {\n    \tf += w * Noisefv2 (p);\n      \tw *= 0.5;\n      \tp *= 2.;\n    }\n        \n    cloudFac = clamp (3. * f * rd.y - 0.1, 0., 1.);\n        \n  }\n    else cloudFac = 0.;\n    \n  s = max (dot (rd, sunDir), 0.);\n    \n  col = vec3 (0.1, 0.2, 0.5) + 0.25 * pow (1. - max (rd.y, 0.), 8.) +\n     (0.35 * pow (s, 6.) + 0.65 * min (pow (s, 256.), 0.3));\n  return mix (col, vec3 (1.), cloudFac);\n}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    if (id_material==6.0)\n    {\n        float escala=0.25;\n        vec3 col= RadialandAngular( p.xz );\n        return col;\n   }\n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n   \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n////----------------------------------\nvec3 getSkyColA(vec3 rd) \n{\n    float t = (rd.x + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(0.0, 20.0, -10.0 );  light_color1 =1.25*vec3( 1.0);\n \tlight_pos2= vec3( -5.0, -5.0, -5.0 ); light_color2 =1.25* vec3(1.0); //light_color1; //vec3( 1.0, 1.0, 1.0 );\n    \n\n    vec3 ro=vec3(0.0,7.0,-25.0);\n    ro.y+=10.0*sin(iTime);\n    //ro= getMouse(ro);       \n    vec3 rd=normalize(vec3(uv,1.0));\n    //rd=rotate_x(rd, float phi)\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        vec3 p = (ro + rd * d ); \n        mObj.p=p;\n        mObj.dist =d;\n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result/=1.25;\n        col= result*dif1;\n\n        col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n        col = pow(col, vec3(1.0/2.2));\n    \n    }\n    else if(d>MAX_DIST)\n      col= SkyCol (ro,  rd);\n    \n    \n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "///modificado por jorgefloresP\n//https://www.shadertoy.com/view/ssBGzD\n//Created by nabr in 2021-04-08\n\n#define Fs iSampleRate\n#define _f(x) fract(x)\n\n\nfloat square(float f)\n{\n\treturn sign(fract(f)-0.5);\n}\n\n\n// whoob\nfloat whoob(float t)\n{\n    int it = int(t) & 3;\n    //original\n    float f0 = 47.123*float(int[](44,52,50,42)[it]);\n    float f1 = 47.123*float(int[](74,68,65,48)[it]);\n   \n    \n    float sf0=sin(f0 * t);\n    float sf1=sin(f1 * t);\n\n    float sf3=sin(f1 * t+20.*sin(f1*t));\n    float sc1=square(sf0+sf1);\n    \n    float smul=(sf0+sf1+sf3)*sc1;\n    \n    return.25*clamp(smul,-1.0, 1.0);\n}\n\n\n// drums\nvec2 drums(float t)\n{\n    float bd = 0., sn = 0., hh = 0.;\n    t = mod(t, 8.);\n    \n    float m = float[](.5, 2., 1.,.5, 1., 1., 1., 4.)[int(4.*t)%8];\n    \n    float snf0 = _f(2.*t), snf1 = _f(t),snf2 = _f(3.*t),bdf0 = _f(m *t) ,bdf1 =_f(8.*t)\n    ,pf= pow(bdf1, 3.);\n    // snare\n    sn = sin(1508. * t) * cos(1508. * exp(-.06 * snf2 ) + cos(snf1 * 1500.));\n    sn *= min(1.,floor(.5+snf1)) * exp(-14. * snf0);\n    sn += .2*clamp(sn*abs(1.-cos(sn/4./snf0)),-0.1, 0.2);\n    // base drums\n    bd = sin(628.31 *  t) * cos(376.98 * exp(-0.0432 * pow(1.-bdf1, 10. )) );\n    bd *= min(1., 20. * bdf1) * max(0.,1.-bdf1) * exp(-12. * bdf0);\n    // shakers, autopan\n    hh = cos( exp(-10. * (pf-2.*floor(pf)-1.) )  * 6.2831 * 260.) \n          * exp(-45. * bdf1) * min(1., .002 + bdf1);\n    return vec2(.8 * sn, sn)  + 1. * bd + \n           vec2(hh*(cos(t)+sin(t)),hh*(-sin(t)+cos(t)));\n}\n\n//Fsynth\nvec2 Fsynth(int s)\n{\n    vec2 y = vec2(1e-6);\n    const float w[19]=float[19](210.,411.,178.,258.,610.,0.,340.,120.,0.,510.,344.,388.,0.,606.,605.,405.,0.,10.,610.);\n    \n    float rt = float(s) / Fs * .5;\n    float frt = _f(rt);\n    float pfrt = pow(min(sqrt(sqrt(1.-frt)), 100. * frt), 4.);\n    float sf = 6.283185 * float(s)/Fs;\n    \n    y.y =  sin(sf * w[int(rt) % 10]);\n    y.y += clamp(y.y+(1.-cos(9.*y.y)),-3.,.3) * pfrt;\n    y.x =  sin(sf * w[int(rt) % 9 + 10]);\n    y.x += clamp(y.x+(1.+sin(6.*y.x)),-.2,.9) * pfrt;\n    y.x += ((y.x-floor(.5*y.x)) * atan(1.-frt,25.*frt));\n    return vec2(y.x,y.y);\n}\n\n\nvec2 mainSound(int s, float t)\n{\n    // observation: \n    // the echoes, the synth itself, also introduce phase rotation \n    // with bitreduction -noise, copying, inverse multiplying, finaly adding the original sound\n    // i can control the stereowidth of the output \n    \n    vec4 y = vec4(1e-6);\n    vec4 b =y;\n    vec2 d=(s>44100*4)?drums(t):vec2(1e-6);\n    \n    const int k[8] = int[8](83341,68581,78517,102859,87421,95279,86813,73907);\n   \n    int nt0 = 953, nt1 = 1571, nt11 = 1031;\n    \n    float v1, v2;\n    \n    for(int ii=0;ii<8;++ii)\n    {\n        if(ii<5)\n        {\n         v1=Fsynth((s-(nt0+=k[ii]))).x;   \n         v2=Fsynth((s-(nt1+=k[ii]))).x;\n         y.xw+=vec2(v1, v2);\n        } \n         \n        if(ii>1) \n        {\n            v1=Fsynth((-s+(nt1+=k[ii]))).y;\n            v2=Fsynth((-s+(nt11+=k[ii]))).y;\n            y.yz+=vec2(v1,v2);\n        }\n    }\n    b = y;\n    float bt = pow(.8, 8.);\n    b.x = (bt * floor(y.y/ bt + .5));\n    b.y = (bt * floor(y.x/ bt + .5));\n    \n    \n    vec2 s1=((.03*((b.xy*1.-b.wz) + y.xy) )+d);\n    vec2 s2=d+whoob(t);\n   \n    return mod(t,10.)<5.?s1:s2;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}