{
    "Shader": {
        "info": {
            "date": "1598563347",
            "description": "Uses many cosine waves to generate a pseudo-random noise pattern. Inspired by the idea of a reverse Fourier series: if any image can be represented as cosine waves, then a random amount of random cosine waves will give you a random image.",
            "flags": 0,
            "hasliked": 0,
            "id": "Wt2fzm",
            "likes": 3,
            "name": "Cosine Noise",
            "published": 3,
            "tags": [
                "procedural",
                "noise",
                "random"
            ],
            "usePreview": 0,
            "username": "xacer",
            "viewed": 367
        },
        "renderpass": [
            {
                "code": "\n\n// Random numbers generated with external script\nvec2[10] cosFreqs = vec2[](\n    2.0 * vec2(0.552703259466216, 2.398672067606822), \n    2.0 * vec2(2.596438592672348, 1.7326873556477949),\n    2.0 * vec2(2.0663735123816878, 3.4705755615606906), \n    2.0 * vec2(1.9228225132683292, 3.7546182974940168), \n    2.0 * vec2(3.634548377431929, 3.2709100770764055), \n    2.0 * vec2(0.6124981915112584, 2.0756017953390256),\n    2.0 * vec2(0.6384711516322568, 1.2006440913071856),\n    2.0 * vec2(0.6755551774054765, 2.406119935703464), \n    2.0 * vec2(0.76554183838889, 2.783851124579087), \n    2.0 * vec2(2.206591797643341, 0.25993143348023295));\nvec2[10] cosOffsets = vec2[](\n    5.0 * vec2(1.6963525514584035, 0.4812831515911966), \n    5.0 * vec2(1.7907424867153168, 3.0717651144368574), \n    5.0 * vec2(3.2775063248816876, 2.6948721313849093), \n    5.0 * vec2(2.325938357994892, 0.3067102774744853), \n    5.0 * vec2(1.8504007333889605, 3.8717157411389054),\n    5.0 * vec2(0.2906125103589147, 1.522760608815588), \n    5.0 * vec2(2.3710837614955382, 0.24433000439312308), \n    5.0 * vec2(1.177456422522664, 0.45379907388705765),\n    5.0 * vec2(2.998746489267796, 1.925251271063462),\n    5.0 * vec2(3.98835907059256, 2.8298990848474204));\n\n\n// Square a number\nfloat sq (float v) {\n\treturn v * v;\n}\n\n// Generate the noise value of a single pixel\nfloat cosNoise (vec2 p) {\n    float val = 0.0;\n    float x = p.x;\n    float y = p.y;\n    for (int i = 0; i < 10; i ++) {\n    \tval += 0.8 * 0.1 * 0.5 * \n            (cos(x * cosFreqs[i].x * 20.0 + y * cosFreqs[i].y * 20.0 + cosOffsets[i].y) + \n             cos(y * cosFreqs[i].x * 20.0 - x * cosFreqs[i].y * 20.0 + cosOffsets[i].x) + 1.0);\n    }\n    return (sq(val + 0.5)) - 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n       \n    vec2 uv = 1.0 * fragCoord/iResolution.xy;\n    vec3 col = vec3(cosNoise(uv * 3.1415));\n    fragColor = vec4(col,1.0);\n}\n\n/*\nconst int MAXSTEPS = 100;\nconst float EPSILON = 0.00001;\n\nvec3 cam = vec3(0.0, -1.0, -3.0);\n\nvoid kib (inout float a, in float b) {\n\ta = min(a, b);\n}\n\nfloat sdBox (in vec3 p, in vec3 c1, in vec3 c2, in float r) {\n\treturn length(p - clamp(p, c1, c2)) - r;\n} \n\nfloat sdFloor (in vec3 p, in float h) {\n\treturn h - p.y;\n}\n\nfloat sdSphere (in vec3 p, in vec3 c, in float r) {\n\treturn length(p - c) - r;\n}\n\nfloat map (in vec3 p) {   \n    float dist = 100.0;\n    \n    kib(dist, sdFloor(p, 0.1));\n    kib(dist, sdSphere(p, vec3(0.0), 0.5));\n    kib(dist, sdBox(p, vec3(-2.0, -0.4, -0.2),vec3(-1.5,-0.2, 0),0.02));\n    \n    return dist;\n}\n\nvec3 xDir = vec3(0.000001, 0, 0);\nvec3 yDir = vec3(0, 0.000001, 0);\nvec3 zDir = vec3(0, 0, 0.000001);\n\nvec3 surfaceNormal (vec3 pos) {\n    vec3 normal = vec3(\n        map(pos + xDir) - map(pos - xDir),\n        map(pos + yDir) - map(pos - yDir),\n        map(pos + zDir) - map(pos - zDir)\n    );\n    return normalize(normal);\n}\n\nvec3 lightPos = vec3(0.0, -1.0, -1.5);\n\nvec3 trace (in vec3 ro, in vec3 rd) {\n\tfloat t = 0.0;\n    for (int i = 0; i < MAXSTEPS; i ++) {\n    \tvec3 pos = ro + rd * t;\n        float dist = map(pos);\n        if (dist < EPSILON) {\n            vec3 lightDir = normalize(pos - lightPos);\n            \n        \tvec3 normal = surfaceNormal(pos);\n            \n            float diffuse = max(-dot(normal, lightDir), 0.0);\n            float specular = dot(reflect(rd, normal), lightDir);\n            specular = pow(max(specular, 0.0), 100.0);\n            \n            vec3 tint = texture(iChannel1, pos.xy).rgb;              \n            return tint * (diffuse * 0.7 + specular * 0.3);\n        }\n        t += dist;\n    }\n\treturn vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 1.0 * fragCoord/iResolution.xy;\n    \n    /*\n    vec3 ray = normalize(vec3(uv.xy, 1.0));\n\n    // Time varying pixel color\n    vec3 col = trace(cam, ray);\n\t\n    // Output to screen\n    fragColor = vec4(col.rgb, 1.0);\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}