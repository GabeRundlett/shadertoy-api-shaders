{
    "Shader": {
        "info": {
            "date": "1654619336",
            "description": "(Click and Drag)\nI wanted to render caustics, so I used buffers to apply forward rendered refracted light paths to a texture which is mapped to the plane. It's a rather strange method, and it's pretty biased, but it creates really good-looking caustics.",
            "flags": 32,
            "hasliked": 0,
            "id": "slBSzc",
            "likes": 21,
            "name": "Photon Mapped Caustics",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "glass"
            ],
            "usePreview": 0,
            "username": "SpinningCube",
            "viewed": 874
        },
        "renderpass": [
            {
                "code": "// Hash by Dave_Hoskins\n// Filmic tonemapping curve by milesWaugh\n\nvec3 Texture0(vec2 uv) {\n    // Multiplying the texture by various values to maintain consistency. Also there's a hand-picked constant.\n    return (lightIntensity * 100. * texture(iChannel0, ((uv/scale)/2. + 0.5)).rgb)/float(attempts);\n}\n\nvec3 lighting(vec3 ray, vec3 rayDir, vec3 rayOrigin, vec3 surfNormal, float f) {\n    diffuse = 0.;\n    specular = 0.;\n    \n    sceneLights(ray, rayDir, surfNormal);\n    \n    vec3 finalCol = vec3(0.);\n    \n    if (abs(ray.y - (-1. - epsilon)) < 0.05) {\n        diffuse += float(Texture0(ray.xz));\n    }\n    \n    if (surfType == 0) {\n        finalCol = mix(surfCol * (diffuse + ambient), vec3(specular), f);\n    }\n    else if (surfType == 1) {\n        finalCol = mix(surfCol * specular, vec3(specular), f);\n    }\n    else if (surfType == 2) {\n        finalCol = vec3(specular) * f;\n    }\n    \n    return finalCol;\n}\n\nvec3 renderFromBackwardRay(vec3 rayDir, vec3 rayOrigin) {\n    vec3 contribution = vec3(1.0);\n    vec3 combinedCol;\n    float totalDepth = 0.;\n    float foga;\n    bool newMedium = false;\n    for (int i = 0; i < bounces; i++) {\n        vec4 rayData = shootRay( rayDir, rayOrigin, renderDist, true );\n\n        if (rayData.x == 1.) {\n            totalDepth += distance(rayData.yzw, rayOrigin);\n            float f = fresnel(1.5, surfRoughness, surfNormal, -rayDir);\n            combinedCol += contribution * lighting(rayData.yzw, rayDir, rayOrigin, surfNormal, f);\n            if (surfType == 0) {\n                break;\n                //contribution *= f;\n            }\n            else if (surfType == 1) {\n                vec4 rayData1 = shootRay( reflect(rayDir, surfNormal), rayData.yzw + epsilon * surfNormal, renderDist, true );\n                combinedCol += f * lighting(rayData1.yzw, rayDir, rayData.yzw + epsilon * surfNormal, surfNormal, f);\n                break;\n                //contribution *= mix(surfCol, vec3(1.), vec3(f));\n            }\n            if (surfType == 2) {\n                vec3 rayDir0 = rayDir;\n                vec3 surfNormal0 = surfNormal;\n                contribution *= surfCol * (1. - f);\n                // One bounce of glossy reflections\n                vec4 rayData1 = shootRay( reflect(rayDir, surfNormal), rayData.yzw + epsilon * surfNormal, renderDist, true );\n                combinedCol += f * lighting(rayData1.yzw, rayDir, rayData.yzw + epsilon * surfNormal, surfNormal, f);\n                rayDir = rayDir0;\n                surfNormal = surfNormal0;\n                \n                rayDir = refract(rayDir, surfNormal, mix(1./1.5, 1.5, newMedium));\n                newMedium = !newMedium;\n                \n                rayOrigin = rayData.yzw - epsilon * surfNormal;\n            }\n            else {\n                break;\n            }\n        }\n        else {\n            combinedCol += contribution * ambient;\n            break;\n        }\n    }\n    return combinedCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cosTime = cos(iTime/2.);\n    cosTime = 6.*-cosTime+6.;\n    camera = vec3(0, 0, -7);\n    \n    vec2 mouse = iMouse.xy/iResolution.xy - vec2(0.5);\n    \n    if (mouse == vec2(-0.5)) {\n        mouse = vec2(-0.15, -0.12);\n    }\n    \n    mouse.y = min(0.03, mouse.y); // Constrain camera rotation\n    \n    camera.yz *= rotate(pi * -mouse.y);\n    camera.xz *= rotate(2. * pi * -mouse.x);\n    \n    camera.y = max(-1., camera.y);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.x;\n    vec2 UV = fragCoord/iResolution.xy;\n    vec3 rayDir = rayDirection( focalLength, uv );\n    \n    rayDir.yz *= rotate(pi * -mouse.y);\n    rayDir.xz *= rotate(2. * pi * -mouse.x);\n    \n    vec3 col = renderFromBackwardRay(rayDir, camera);\n    \n    //col = Texture0(10. * (UV - 0.5)); // The caustics texture\n    \n    // Output to screen, filmic tonemapping, and gamma correction.\n    col = filmic(col);\n    fragColor = vec4(pow(col,vec3(1./2.2)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Casting forward rays from the light source\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int id = int(fragCoord.x) + int(iResolution.x) * int(fragCoord.y) + 50;\n    if (id > samples && id > 0) {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n    else {\n        vec2 uv = fragCoord/iResolution.xy;\n        mat3 render;\n        for (int i = 0; i < attempts; i++) { // Rejection sampling, converges much faster but even more bias\n            float seed = 10.23 * (float(iFrame) + 10.4341 * float(i));\n            vec3 rayDir = randInSphere(vec3(uv * 10. * seed, seed/1.));\n            render = renderFromForwardRay(rayDir, lightPos);\n            if (render[1].x > 0.) {\n                break;\n            }\n        }\n        vec3 hit = vec3(render[1].x, render[2].xz); // vec3(brightness, hit position x, hit position z)\n        fragColor = vec4(hit,render[0].x); // vec4(brightness, hit position x, hit position z, hit glass?)\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Hash by Dave_Hoskins\n// Filmic tonemapping curve by milesWaugh\n\nconst float epsilon = 0.001;\nconst float focalLength = 0.8;\nconst float renderDist = 850.;\nconst float pi = 3.141592653589793;\nconst int bounces = 5;\n\nconst int samples = 1000; // Number of fragments used to sample paths per frame\nconst int attempts = 200; // Number of attempts per fragment\nconst float sampleRadius = 0.002;\nconst vec3 lightPos = vec3(-2, 3.5, -3);\nconst float lightIntensity = 2.;\nconst float scale = 6.;\nconst float bumpStrength = 0.2;\n\nvec3 camera;\nfloat nearestDist;\nvec3 ray;\n\nvec3 surfCol;\nvec3 surfNormal;\nfloat surfRoughness;\nint surfType; // 0=dielectric, 1=metallic, 2=glass\nbool updateMat;\n\nfloat diffuse = 0.;\nfloat specular;\nvec3 ambient = vec3(0.1);\n\nmat2 rotate(float a) {\n    float sinA = sin(a);\n    float cosA = cos(a);\n    return mat2(cosA, -sinA, sinA, cosA);\n}\n\nvec3 rand(vec3 p3) // Hash by Dave_Hoskins\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// Smooth tricubic interpolated 3D noise\nvec3 noise(vec3 p3) {\n\n    vec3 p31 = floor(p3);\n    p3 = smoothstep(0., 1., fract(p3));\n    \n    // Corner points\n    vec3 p000 = p31 + vec3(0);\n    vec3 p001 = p31 + vec3(0, 0, 1);\n    vec3 p010 = p31 + vec3(0, 1, 0);\n    vec3 p011 = p31 + vec3(0, 1, 1);\n    vec3 p100 = p31 + vec3(1, 0, 0);\n    vec3 p101 = p31 + vec3(1, 0, 1);\n    vec3 p110 = p31 + vec3(1, 1, 0);\n    vec3 p111 = p31 + vec3(1);\n    \n    \n    // Tricubic interpolation\n    vec3 v000 = rand(p000);\n    vec3 v001 = rand(p001);\n    vec3 v010 = rand(p010);\n    vec3 v011 = rand(p011);\n    vec3 v100 = rand(p100);\n    vec3 v101 = rand(p101);\n    vec3 v110 = rand(p110);\n    vec3 v111 = rand(p111);\n    \n    vec3 vX00 = mix(v000, v100, p3.x);\n    vec3 vX01 = mix(v001, v101, p3.x);\n    vec3 vX10 = mix(v010, v110, p3.x);\n    vec3 vX11 = mix(v011, v111, p3.x);\n    \n    vec3 vXY0 = mix(vX00, vX10, p3.y);\n    vec3 vXY1 = mix(vX01, vX11, p3.y);\n\n    return mix(vXY0, vXY1, p3.z);\n}\n\nvec3 randInSphere(vec3 p3) {\n    for (int i = 0; i < 50; i++) {\n        vec3 rand1 = 2. * (rand(p3) - 0.5);\n        if (length(rand1) <= 1.) {\n            return normalize(rand1);\n        }\n    }\n    return vec3(0, -1, 0);\n}\n\nvec3 rayDirection( float focal, vec2 xy ) {\n    return (normalize(vec3(xy, focal)));\n}\n\n\n// Intersectors\n\nvec4 Sphere( vec3 rayOrigin, vec3 rayDir, vec3 pos, float radius, bool negative) {\n    vec3 offset = pos - rayOrigin;\n    float dot1 = dot(offset, rayDir);\n    float dot2 = dot(offset, offset);\n\n    if (dot2 - dot1 * dot1 < radius * radius) {\n        float near = sqrt(radius * radius - (dot2 - (dot1 * dot1)));\n        float intersectSign = mix(-1., 1., float(negative));\n        return vec4(dot1 + intersectSign * near, intersectSign * (pos - (rayOrigin + (rayDir * (dot1 + intersectSign * near)))));\n    }\n    return vec4(-1., 0, 0, 0);\n}\n\nvec4 Plane( vec3 rayOrigin, vec3 rayDir, vec3 normal, float dist ) {\n    float dot1 = dot(normal, rayDir);\n    float near = (dot(normal, rayOrigin) + dist)/dot1;\n    if (!(dot1 == 0.) && near < 0.)\n    {\n        return vec4(-near, normal);\n    }\n    return vec4(-1., 0, 0, 0);\n}\n\nvec4 Plane2( vec3 rayOrigin, vec3 rayDir, vec3 normal, float dist ) {\n    float dot1 = dot(normal, rayDir);\n    float near = (dot(normal, rayOrigin) + dist)/dot1;\n    if (!(dot1 == 0.) && near < 0. && length((rayOrigin + rayDir * -near).xz + vec2(2., 0.)) < 1.5)\n    {\n        return vec4(-near, normal);\n    }\n    return vec4(-1., 0, 0, 0);\n}\n\nvoid addIntersector( vec4 surface, vec3 col, float roughness, int type /* 0=dielectric, 1=metallic, 2=glass */, int textureType, vec3 textureScale, vec3 rayDir, vec3 start) {\n    float dist = surface.x;\n    if ( dist < nearestDist && dist > 0. ) {\n        nearestDist = dist;\n        if (updateMat) {\n            surfCol = col;\n            if (textureType == 0) {\n            \n            }\n            else if (textureType == 1) {\n                vec3 uvw = rayDir * dist + start;\n                vec3 rUVW = round(textureScale * uvw);\n                float checker = mod(rUVW.x + rUVW.y + rUVW.z, 2.);\n                surfCol = col * mix(0.4, 1., checker);\n            }\n            surfRoughness = roughness*roughness;\n            surfNormal = normalize(surface.yzw);\n            surfType = type;\n        }\n    }\n}\n\nfloat scene( vec3 rayOrigin, vec3 rayDir, vec3 start)\n{\n    \n    addIntersector( Sphere( rayOrigin, rayDir, vec3(1, 0, 0), 1., false), vec3(1.,1., 1.), .05, 2, 0, vec3(1.), rayDir, start);\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(1, 0, 0), 1., true), vec3(1.,1., 1.), .05, 2, 0, vec3(1.), rayDir, start);\n    \n    //addIntersector( Sphere( rayOrigin, rayDir, vec3(-3, 0.2, 0), 1., false), vec3(1.,1., 1.), .05, 2, 0, vec3(1.), rayDir, start);\n    //addIntersector( Sphere( rayOrigin, rayDir, vec3(-3, 0.2, 0), 1., true), vec3(1.,1., 1.), .05, 2, 0, vec3(1.), rayDir, start);\n    \n    addIntersector( Plane( rayOrigin, rayDir, vec3(0, 1, 0), 1. + epsilon), vec3(0.3, 1., 0.3), 1., 0, 1, vec3(0.55), rayDir, start);\n    //addIntersector( Plane( rayOrigin, rayDir, vec3(0, 1, 0), 1. + epsilon), vec3(1., 0.6, 0.2), 1., 0, 1, vec3(0.55), rayDir, start);\n    \n    addIntersector( Plane2( rayOrigin, rayDir, vec3(0, 1, 0), -.5), vec3(1.,1., 1.), .05, 2, 0, vec3(1.), rayDir, start);\n    \n    return nearestDist;\n}\n\nvec4 shootRay( vec3 rayDir, vec3 start, float renderDist, bool updateMaterial ) {\n    updateMat = updateMaterial;\n    \n    nearestDist = renderDist;\n        \n    scene(start, rayDir, start);\n    \n    vec3 hitPos = rayDir * nearestDist + start;\n    \n    if (updateMaterial) {\n        if (surfType == 2) {\n            surfNormal += bumpStrength * noise(7. * hitPos);\n            surfNormal = normalize(surfNormal);\n        }\n        //surfCol = 1. * fract(noise(1. * hitPos));\n    }\n    \n    \n    return vec4(nearestDist < renderDist, hitPos);\n}\n\nfloat GGX (float halfDot, float roughness) {\n    float r2 = roughness*roughness;\n    float a = halfDot * halfDot * (r2 - 1.) + 1.;\n    return r2 / (a * a);\n}\n\nvoid directionalLight(vec3 ray, vec3 rayDir, vec3 lightDir, vec3 surfNormal, float intensity, float lightDist) {\n    if ( shootRay(lightDir, ray + (surfNormal * epsilon), lightDist, false).x == 0. ) {\n        float lambertian = dot(surfNormal, lightDir);\n        diffuse += max(intensity * lambertian, 0.);\n\t\t\n        vec3 halfway = normalize(lightDir - rayDir);\n        float halfDot = dot(surfNormal, halfway);\n    \tspecular += max(lambertian * intensity * GGX(halfDot, surfRoughness), 0.);\n\n    }\n}\n\nvoid pointLight( vec3 ray, vec3 rayDir, vec3 position, float intensity, vec3 surfNormal ) {\n    vec3 lightDir = normalize(position - ray);\n    directionalLight( ray, rayDir, lightDir, surfNormal, intensity, distance(position, ray) );\n}\n\nvoid sceneLights(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    pointLight( ray, rayDir, lightPos, lightIntensity, surfNormal);\n}\n\n// My implementation of the tonemapping curve by milesWaugh\nvec3 filmic(vec3 color) {\n    return 1. - (1./(5. * pow(color, vec3(2.)) + 1.));\n}\n\nfloat fresnel(float IOR, float roughness, vec3 surfNormal, vec3 incoming) {\n    float F0 = (1. - IOR)/(1. + IOR);\n    F0 *= F0;\n    return F0 + (1. - roughness)*((1. - F0) * pow(1. - dot(surfNormal, incoming),5.));\n}\n\nmat3 renderFromForwardRay(vec3 rayDir, vec3 rayOrigin) {\n    vec3 remainingCol = vec3(1.);\n    float totalDepth = 0.;\n    float foga;\n    bool newMedium = false;\n    bool hitGlass = false;\n    for (int i = 0; i < bounces; i++) {\n        vec4 rayData = shootRay( rayDir, rayOrigin, renderDist, true );\n\n        if (rayData.x == 1.) {\n            totalDepth += distance(rayData.yzw, rayOrigin);\n            float f = fresnel(1.5, surfRoughness, surfNormal, -rayDir);\n            if (surfType == 2) {\n                hitGlass = true;\n                remainingCol *= surfCol * (1. - f);\n\n                rayDir = refract(rayDir, surfNormal, mix(1./1.5, 1.5, newMedium));\n                newMedium = !newMedium;\n\n                rayOrigin = rayData.yzw - epsilon * surfNormal;\n            }\n            else {\n                return mat3(vec3(rayData.x), remainingCol * dot(-rayDir, surfNormal) * float(hitGlass), rayData.yzw);\n            }\n        }\n        else {\n            return mat3(0);\n        }\n    }\n    return mat3(0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Uses the crude approach of looping through Buffer A to find the correct path, I couldn't figure out a better way to do this.\n// Fragment shaders are clearly not built for this\n\nvec3 sampleSamples(vec2 uv, float radius) {\n    vec3 total = vec3(0);\n    int num = 0;\n    for (int i = 0; i < samples; i++) {\n        vec4 c = texelFetch(iChannel0, ivec2(mod(float(i), iResolution.x), float(i) / iResolution.x), 0);\n        if (c.w == 1.) {\n            float light = c.x;\n            vec2 pos = c.yz;\n            vec2 diff = (pos / scale) - uv;\n            if (length(diff) < radius) {\n                total += c.xxx;\n                num++;\n            }\n        }\n    }\n    // A hand-picked constant\n    return 0.0006 * total/(pi * radius * radius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 prevCol = texture(iChannel1, uv).rgb;\n    vec3 col = (prevCol * float(iFrame) + sampleSamples(uv * 2. - 1., sampleRadius))/float(iFrame + 1);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}