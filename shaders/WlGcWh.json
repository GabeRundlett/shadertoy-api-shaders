{
    "Shader": {
        "info": {
            "date": "1610873909",
            "description": "[ why crossings ? ]\nvariant of field art [url]https://shadertoy.com/view/wtVyRW[/url] \nusing flownoise [url]https://www.shadertoy.com/view/wdKXzd[/url] \nwith incompressible noise [url]https://www.shadertoy.com/view/Xl3Gzj[/url]\nTry variants for f(U).",
            "flags": 0,
            "hasliked": 0,
            "id": "WlGcWh",
            "likes": 7,
            "name": "flow field art 2",
            "published": 3,
            "tags": [
                "perlin",
                "flow",
                "field",
                "flownoise",
                "lic",
                "incompressible"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 517
        },
        "renderpass": [
            {
                "code": "// variant of \"field art\" by FabriceNeyret2. https://shadertoy.com/view/wtVyRW\n\n#define hash2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\n// --- flownoise from https://www.shadertoy.com/view/wdKXzd\n// gradient noise derived from https://www.shadertoy.com/view/XdXGW8\n\nfloat _z = 1.;\nvec2 hash( vec2 p ) \n{\n // float s = 0.;                      // standard Perlin noise\n    float s = mod(p.x+p.y,2.)*2.-1.;   // flow noise checkered rotation direction\n // float s = mod(floor(p.x)+floor(p.y),2.)*2.-1.;   // should be this but x is integer\n // float s = 1.;                      // flow noise universal rotation direction\n // s *= iTime;                        // same rotation speed at all scales\n    s *= iTime/ _z;                    // rotation speed increase with small scale    \n\n    return ( -1. + 2.*hash2(p) ) \n        *  mat2(cos( s + vec4(0,33,11,0))); // rotating gradients. rot: https://www.shadertoy.com/view/XlsyWX\n}\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor( p ),\n         f = fract( p ),\n\t  // u = f*f*(3.-2.*f);\n         u = f*f*f* ( 10. + f * ( -15. + 6.* f ) ); // better for derivative. from http://staffwww.itn.liu.se/~stegu/TNM022-2005/perlinnoiselinks/paper445.pdf\n\n#define P(x,y) dot( hash( i + vec2(x,y) ), f - vec2(x,y) )\n    return mix( mix( P(0,0), P(1,0), u.x),\n                mix( P(0,1), P(1,1), u.x), u.y);\n}\n\n#define noise01(p) 1.5 * ( .5+.5* noise(p)-.18 )    // well fitted to [0,1] without saturation\n\nfloat perlin( vec2 p )                              // fractal noise\n{\t\n    mat2 m = mat2(2.); // mat2( 1.6,  1.2, -1.2,  1.6 );\n    float v  = 0.,s = 1.;\n    for( int i=0; i < 5; i++, s /= 2. ) { _z = s;   // for flownoise\n        v += s*noise01( p ); p *= m;                // variant using positive noise\n    }\n    return v;\n}\n\n// --- sampling inspired from https://www.shadertoy.com/view/lljczz\n\n#define srnd(p,s) ( 2.* fract( 4e4* sin( 1e3* mat2(1,7.1,-5.1,2.3) * (p) + 1e3*s )) -1. )\n\n// #define f(U)   noise01(U)\n   #define f(U)   noise01(ofs(U))\n// #define f(U) ( noise01(ofs(U)) + .5*noise01(2.*ofs(U)) ) / 1.2\n// #define f(U)   perlin(U) / 1.5     \n// #define f(U)   perlin(ofs(U)) / 1.5\n#define ofs(U) ( (U) *vec2(1,2) + vec2(.3*iTime,0) )\n\nvoid mainImage( out vec4 O,  vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1./R.y,0),\n         U = (2.*u-R)/R.y, p, P, X,V, x;\n    O-=O;       \n         \n    float v, n =   11., // R.y/32., // 11.                // number of cells (optim)\n          l = .08,                                        // stokes length\n       // d = 90.*pow((1.-U.y)/2.,1.7)*R.y/360.;          // strokes density\n          d = 90.*pow(max(f(U)-.25 -.0*U.y,0.),1.7)*R.y/360.;// strokes density\n    int N = 3; // int(3.*R.y/360.);                       // Neighborhood size = NxN . goes with l\n\n    p = floor(U*n+.5) / n;                                // cell center (NB: we should deffered /n )\n\n    for( int i=0; i<N*N; i++)                             // Worley optim. allows overflow to neighbor cell\n      for( float j=0.; j<d; j++) {                        // density loop\n        P = p + vec2( i%N -N/2, i/N -N/2 ) / n;           // cell coordinate in neighborhood\n        P +=     .5* srnd( round(P*n) , j) / n;           // jittering (round: for precision issues)\n        X = U-P,                                          // local coordinate\n        V; // =  f(.5*U);    // f(.5*P)                   // local field.\n        v = f(U); // v = V.x;\n        V = vec2(  dFdx(v), dFdy(v) ) * R.y;              // divergence-free  ( since we trace ortho(V) )  \n     // V = vec2( -dFdy(v), dFdx(v) ) * R.y;              // divergence-free  ( if we were tracing V )  \n     // V = vec2( f(P)-f(P-eps), f(P)-f(P-eps.yx) );      // tangents rather than curves\n\n        v = dot ( X , V );                                // distance to segment\n     // v /= fwidth(v);\n        v /= length(V) * 2.5/R.y;\n        O += (1.-O)*                                      // blend ( comment out for add )\n             .5* max( 0., 1. - 1.3*abs(v) )               // draw segment of dir V and length .04\n               * clamp( ( l - length(X) ) *R.y ,0.,1.);\n}\n    \n // O -=  max(0., length(U)-.8 ) *R.y;                    // white out of circle\n    O = sqrt(1.-O);                                       // reverse + to sRGB\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}