{
    "Shader": {
        "info": {
            "date": "1723728790",
            "description": "Shader visualising Cayley transform between upper half plane and unit disk, showing how translation of H corresponds to inversion of D",
            "flags": 0,
            "hasliked": 0,
            "id": "XfffW4",
            "likes": 0,
            "name": "Cayley transform",
            "published": 3,
            "tags": [
                "complex",
                "hyperbolic"
            ],
            "usePreview": 0,
            "username": "holonomy",
            "viewed": 87
        },
        "renderpass": [
            {
                "code": "\nprecision mediump float;\n\n\n\n\nfloat PI = 3.14159265359;\n\nvec2 multC( vec2 z, vec2 w ) {\n    \n    return vec2(z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n}\n\nvec2 mC( vec2 z, vec2 w ) {\n    \n    return vec2(z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n}\n\n\nvec2 conj( vec2 z) {\n    \n    return vec2(z.x, -z.y);\n}\n\nfloat norm( vec2 z) {\n    \n    return sqrt(z.x*z.x + z.y*z.y);\n}\n\nfloat norm2( vec2 z) {\n    \n    return z.x*z.x + z.y*z.y;\n}\n\nvec2 inv( vec2 z) {\n    \n    return conj(z)/norm2(z);\n}\n\nvec2 divC( vec2 z, vec2 w ) {\n    \n    return multC(z, inv(w));\n}\n\nvec2 I() {\n  return vec2(0., 1.);\n}\n\nfloat Re(vec2 z) {\n  return z.x;\n}\n\nfloat Im(vec2 z) {\n  return z.y;\n}\n\nfloat atan2(in float y, in float x)\n{\n    return x == 0.0 ? sign(y)*PI/2. : atan(y, x);\n}\n\nvec2 polar(vec2 z) {\n  float a = Re(z);\n  float b = Im(z);\n  float r = norm(z);\n  float phi = atan2(b, a);\n  return vec2(r, phi);\n}\n\nvec2 oneC(){\n  return vec2(1., 0.);\n}\n\nvec2 expC(vec2 z) {\n  return vec2(cos(z.y), sin(z.y))*(sinh(z.x) + cosh(z.x));\n}\n\nvec2 polarToNormal(vec2 z) {\n  return expC(I()*z.y)*z.x;\n}\n\n\nvec2 sqrtC(vec2 z) {\n  float r = norm(z);\n  float phi = polar(z).y;\n  return polarToNormal(vec2(sqrt(r), phi/2.));\n}\n\nvec2 powC(vec2 z, float p){\n  float eps = 1e-8;\n  if (norm(z)<eps)\n    return vec2(0., 0.);\n  if (p < 0.)\n    {\n    p = -p;\n    z = inv(z);\n  }\n\n  if (abs(p-1.) < eps)\n    return z;\n  if (abs(p) < eps)\n    return oneC();\n  if (abs(p-2.) < eps)\n    return multC(z, z);\n  float r = norm(z);\n  float phi = polar(z).y;\n  return polarToNormal(vec2(pow(r, p), phi*p));\n}\n\nvec2 logC(vec2 z) {\n  vec2 pol = polar(z);\n  return vec2(log(pol.x), pol.y);\n}\n\nvec2 atanhC(vec2 z) {\n  return (logC(z+oneC()) - logC(z-oneC()))*.5;\n}\n\nvec2 tanhC(vec2 z) {\n  return divC(expC(z) - expC(-z), expC(z) + expC(-z));\n}\n\nvec2 sinhC(vec2 z) {\n  return (expC(z) - expC(-z))/2.;\n}\n\nvec2 coshC(vec2 z) {\n  return (expC(z) + expC(-z))/2.;\n}\n\nvec2 sinC(vec2 z) {\n  return vec2(sin(z.x)*cosh(z.y), cos(z.x)*sinh(z.y));\n}\n\nvec2 cosC(vec2 z) {\n  return vec2(cos(z.x)*cosh(z.y), -sin(z.x)*sinh(z.y));\n}\n\nvec2 asinC(vec2 z) {\n  return multC(I(), logC(sqrtC(oneC() - multC(z, z)) - multC(z, I())));\n}\n\nvec2 acosC(vec2 z) {\n  return oneC()*PI/2. - asinC(z);\n}\n\nvec2 asinhC(vec2 z) {\n  return logC(z + sqrtC(mC(z, z) + oneC()));\n}\n\nvec2 acoshC(vec2 z) {\n  return logC(z + mC(sqrtC(z-oneC()), sqrtC(z+oneC())));\n}\n\nvec2 reflectionAgainstCircle(vec2 z, vec2 center, float radius) {\n  return center + divC(oneC()*radius*radius, conj(z) - conj(center));\n}\n\nvec2 HtoDisk(vec2 z){\n  return divC(-mC(z, I()) - oneC(), z + I());\n}\n\nvec2 diskToH(vec2 z){\n  return divC(mC(z, I()) + oneC(), - I() - z);\n}\n\nvec2 shiftDisk(vec2 z){\n  return (z + vec2(1., 1.))/2.;\n}\n\nvec2 unshiftDisk(vec2 z){\n  return z*2.-vec2(1., 1.);\n}\n\nvec4 rbgToCol(float r, float g, float b){\n  return vec4(r/256., g/256., b/256., 1.);\n}\n\nfloat mushroom(float t, float center, float r)\n  {\n  return abs(t - center) < r ? pow(cos((t - center)/r*PI/2.), 2.5) : 0.;\n}\n\nfloat indicateLine(vec2 uv, float a, float b, float c)\n  {\n  return smoothstep(0.02, 0.0, abs(a*uv.x + uv.y*b + c));\n}\n\nfloat indicateLineBetweenPoints(vec2 uv, vec2 p0, vec2 p1)\n  {\n  float a = 0.;\n  float b = 0.;\n  if (abs(p0.x - p1.x) > abs(p0.y - p1.y))\n    {\n    b=1.;\n    a = (p0.y-p1.y)/(p1.x-p0.x);\n  }\n  else\n    {\n    a=1.;\n    b = (p1.x-p0.x)/ (p0.y-p1.y);\n  }\n  float c = -a*p0.x - b*p0.y;\n  return indicateLine(uv, a, b, c);\n}\n\n\nfloat grid(vec2 uv, float n, float m)\n  {\n  return abs(sin(uv.x*n*PI))*abs(sin(uv.y*m*PI));\n}\n\n\nfloat isWithinDisk(vec2 uv, vec2 center, float r)\n  {\n  return smoothstep(1.02*r, .98*r, norm(uv-center));\n}\n\nfloat isUpperHalf(vec2 uv){\n  return smoothstep(-0.04, 0.04, uv.y);\n}\n\nvec4 drawCurve(float curveImplicit, vec4 bg, vec4 cur, float pen0, float pen1){\n  return mix(bg, cur, smoothstep(pen1, pen0, curveImplicit));\n}\n\nfloat circle(vec2 uv, vec2 center, float r){\n  return pow(uv.x - center.x, 2.)+pow(uv.y - center.y, 2.)-pow(r, 2.);\n}\n\nfloat line(vec2 uv, float a, float b, float c){\n  return abs(uv.x*a + uv.y*b + c);\n}\n\n\n\nvec2 projectVectorOnVector(vec2 v, vec2 w){\n  return w*(dot(v, w)/dot(w, w));\n}\n\nfloat nearestPointOnIntervalParam(vec2 x, vec2 x0, vec2 x1)\n{\n  if (dot(x0-x1, x0-x)<=0.){\n    return 0.;\n  }\n  if (dot(x1-x0, x1-x)<=0.){\n    return 1.;\n  }\n  return norm(projectVectorOnVector(x-x0, x1-x0))/norm(x1-x0);\n}\n\nvec2 nearestPointOnInterval(vec2 x, vec2 x0, vec2 x1){\n  float t = nearestPointOnIntervalParam(x, x0, x1);\n  return mix(x0, x1, t);\n}\n\nfloat intervalWidth(float t, float time_){\n  return (0.003 + t*(1.-t)*0.025+pow(sin(60.*(t + time_/5.)), 2.)*0.0125)/3. + mushroom(t, 0., .03)/150. + mushroom(t, 1., .03)/100.;\n}\n\nfloat intervalWithWidthImplicit(vec2 uv, vec2 x0, vec2 x1, float time_){\n  return norm(uv - nearestPointOnInterval(uv, x0, x1)) - intervalWidth(nearestPointOnIntervalParam(uv, x0, x1), time_);\n}\n\nvec2 parametricCircle(float t, vec2 center, float r){\n  return center + vec2(r*cos(2.*PI*t), r*sin(2.*PI*t));\n}\n\nvec2 orthoComplement(vec2 v){\n  return vec2(-v.y, v.x);\n}\n\nvec2 parametricEllipse(float t, vec2 center, float a, float b, vec2 dir){\n  vec2 v1 = dir;\n  vec2 v2 = orthoComplement(dir);\n  return  center + a*cos(2.*PI*t)*v1 + b*sin(2.*PI*t)*v2;\n}\n\n\n\n\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 u_resolution = iResolution.xy;\n  float border = u_resolution.x/15.;\n  vec4 col0 = rbgToCol(100., 55., 77.);\n  vec4 col1 = rbgToCol(146., 55., 77.);\n  vec4 col2 = rbgToCol(198., 210., 237.);\n  vec4 col3 = rbgToCol(255., 200., 87.);\n  float n = 8.;\n  float m = 10.;\n  float time = iTime/3.;\n\n  \n  float sector = 1.;\n  \n  if(gl_FragCoord.x*2. < u_resolution.x)\n    {\n    sector = -1.;\n  }\n  if(gl_FragCoord.x < border || \n    gl_FragCoord.x > u_resolution.x - border ||\n    gl_FragCoord.y < border || \n    gl_FragCoord.y > u_resolution.y - border||\n    abs(gl_FragCoord.x - u_resolution.x/2.) < border/2.)\n    {\n    sector = 0.;\n  }\n  \n  vec2 corner1 = u_resolution - vec2(border, border);\n  if (sector == -1.)\n    {\n    corner1 = vec2(u_resolution.x/2. - border/2., u_resolution.y - border);\n  }\n  \n  vec2 corner2 = vec2(border, border);\n  if (sector == 1.)\n    {\n    corner2 = vec2(u_resolution.x/2. - border/2., border);\n  }\n  \n  \n  \n  \n  \n  vec2 uv = (gl_FragCoord.xy-corner2)/(corner1 - corner2);\n  uv = (uv + vec2(-.6, -.6))*5.;\n  if (sector == 1.)\n    {\n    uv = HtoDisk(uv)+vec2(0., .3);\n  }\n\n\n    float borderSize0 = .0049;\n    float borderSize1 = .005;\n    float principalCurveSize0 = -0.001;\n    float principalCurveSize1 = 0.002;\n    float minorCurveSize0 = 0.0024;\n    float minorCurveSize1 = 0.003;\n    float N_fl = 80.;\n    const int N = 80;\n  \n    vec4 borderInside = drawCurve(-uv.y, col0, col1, -borderSize0, 0.0);\n    vec4 borderCurve = drawCurve(abs(uv.y), borderInside, col2, borderSize0, borderSize1);\n\n    vec2 beginPoints[N];\n    vec2 endPoints[N];\n    for (int i = 0; i < N; i++)\n    {\n      float t = float(i)/N_fl;\n      beginPoints[i] = parametricEllipse(t + sin(1.5*time)/5., vec2(.0, .25), 1.7, 1.7, vec2(0., 1.));\n      endPoints[i] = parametricEllipse(t, vec2(0, .2), 0.3+ sin(3.5*time)/5., 0.3+ sin(3.5*time)/5., vec2(0., 1.));\n    }\n\n    vec4 princCurve1 = drawCurve(intervalWithWidthImplicit(uv*sin(time), beginPoints[0], endPoints[0], time), borderCurve, col3, principalCurveSize0, principalCurveSize1);\n    for (int i = 1; i < N; i++)\n    {\n      float t = float(i)/N_fl;\n      princCurve1 = drawCurve(intervalWithWidthImplicit(uv*sin(time), beginPoints[i], endPoints[i] , time), princCurve1, col3, principalCurveSize0, principalCurveSize1);\n    }\n    \n    \n    \n    \n\n  // some for loop for this foliation\n\n\n  \n  \n  \n  fragColor = princCurve1*abs(sector);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}