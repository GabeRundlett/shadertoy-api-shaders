{
    "Shader": {
        "info": {
            "date": "1550865690",
            "description": "An experimental volumetric voxel for rendering signed distance functions.\n[url=https://www.shadertoy.com/playlist/fXjyRd]GEOMETRY PLAYLIST[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "3dSGDz",
            "likes": 24,
            "name": "Voxumetric",
            "published": 3,
            "tags": [
                "sdf",
                "cube",
                "voxel",
                "volumetric",
                "isometric",
                "octahedron",
                "pbr",
                "gooch",
                "cividis"
            ],
            "usePreview": 0,
            "username": "domrally",
            "viewed": 625
        },
        "renderpass": [
            {
                "code": "/// by Dom Mandy in 2019\n\n\n/*\nlower default precision for performance\n*/\nprecision mediump float;\nprecision mediump int;\nprecision mediump sampler2D;\n\nconst float pi = 3.1415926535897932384626433832795;\nconst float sqrt2 = sqrt(2.0);\nconst float sqrt3 = sqrt(3.0);\n// default height of the voxel grid\nconst uint gridHeight = 12u;\n// number of lights\nconst int lightCount = 4;\n\nstruct Light\n{\n    float intensity;\n    vec3 position;\n    vec3 color;\n};\n// vector form of a line\nstruct Line\n{\n    // unit vector in the direction of the line\n    vec3 direction;\n    // position of a point on the line\n    vec3 point;\n};\n// geometry of a shape used for rendering\nstruct Shape\n{\n    // direction the surface is facing\n    vec3 normal;\n    // proportional to the number of voxels that the ray has passed through\n    float depth;\n};\n// positioning of scene elements\nstruct Studio\n{\n    Light[lightCount] lights;\n    Line camera;\n};\n// maximum element of absolute value of vector\n// see: https://en.wikipedia.org/wiki/Uniform_norm\nfloat supremumNorm(vec3 v)\n{\n    vec3 u = abs(v);\n    float norm = max(max(u.x, u.y), u.z);\n    return norm;\n}\n// distance a taxi has to drive to in Manhattan to travel the length of the vector\n// see: https://en.wikipedia.org/wiki/Norm_(mathematics)#Taxicab_norm_or_Manhattan_norm\nfloat taxicabNorm(vec3 v)\n{\n    vec3 u = abs(v);\n    float norm = u.x + u.y + u.z;\n    return norm;\n}\n// inverse linear interpolation, an un-smoothed form of smoothstep\nfloat linearStep(float a, float b, float x)\n{\n    float t = clamp((x - a) / (b - a), 0.0, 1.0);\n    return t;\n}\n// rotates a vector by a given angle (in radians) around a given axis (must be a unit vector)\n// see: https://en.wikipedia.org/wiki/Rodrigues'_rotation_formula\nvec3 rotationRodrigues(vec3 v, vec3 axis, float angle)\n{\n    float c = cos(angle);\n    return v * c + cross(axis, v) * sin(angle) + axis * dot(axis, v) * (1.0 - c);\n}\n// distribution of reflective microfacets on a surface\n// see: https://en.wikipedia.org/wiki/Specular_highlight#Beckmann_distribution\nfloat beckmannDistribution(float HN)\n{\n    // roughness\n    const float m = 2.0;\n    const float m2 = m * m;\n    \n    float cos2 = HN * HN;\n    float cos4 = cos2 * cos2;\n    \n    float num = exp((cos2 - 1.0) / (cos2 * m2));\n    float den = pi * m2 * cos4;\n    \n    float k = num / den;\n    \n    return k;\n}\n// amount of light reflected at boundary of air and object \n// see: https://en.wikipedia.org/wiki/Schlick%27s_approximation\nfloat schlickApproximation(float VN)\n{\n    /// refractive indices\n    // air\n    const float n_1 = 1.000293;\n    // diamond\n    const float n_2 = 2.47;\n    \n    float R_0 = (n_1 - n_2) / (n_1 + n_2);\n    R_0 *= R_0;\n    \n    float incidence = 1.0 - VN;\n    incidence *= incidence * incidence * incidence * incidence;\n    float R = R_0 + (1.0 - R_0) * incidence;\n    \n    return R;\n}\n// specular reflections off a rough surface\n// see: https://en.wikipedia.org/wiki/Specular_highlight#Cook%E2%80%93Torrance_model\nvec3 cookTorrance(vec3 V, vec3 N, Light L)\n{\n    vec3 H = normalize(V + L.position);\n    float VN = dot(V, N);\n    float NL = dot(N, L.position);\n    float HN = dot(H, N);\n    float VH = dot(V, H);\n    \n    float g = 2.0 * HN / VH;\n    float G = 1.0;\n    G = min(G, g * VN);\n    G = min(G, g * NL);\n    \n    float D = beckmannDistribution(HN);\n    float F = schlickApproximation(VN);\n    \n    float k = 0.25 * D * F * G / (VN * NL);\n    \n    vec3 color = k * L.intensity * L.color;\n        \n    return color;\n}\n// diffuse reflections on a rough surface\n// see: https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model\nfloat orenNayar(vec3 normal, Light light, vec3 eye)\n{\n    // roughness\n    const float sigma = 0.3;\n    const float sigma2 = sigma * sigma;\n    const float A = 1.0 - 0.5 * sigma2 / (sigma2 + 0.33);\n    const float B = 0.45 * sigma2 / (sigma2 + 0.09);\n    \n    float eyeNormalProjection = dot(eye, normal);\n    float lightNormalProjection = dot(light.position, normal);\n    float thetaEye = acos(eyeNormalProjection);\n    float thetaLight = acos(lightNormalProjection);\n    float alpha = max(thetaEye, thetaLight);\n    float beta = min(thetaEye, thetaLight);\n    vec3 eyeNormalRejection = eye - eyeNormalProjection * normal;\n    vec3 lightNormalRejection = eye - lightNormalProjection * normal;\n    vec3 axis = cross(vec3(0.0, 1.0, 0.0), normal);\n    float phiEye = acos(dot(eyeNormalRejection, axis));\n    float phiLight = acos(dot(lightNormalRejection, axis));\n    \n    float L = A + B * max(cos(phiEye - phiLight), 0.0) * sin(alpha) * tan(beta);\n    L *= max(lightNormalProjection, 0.0);\n    L *= light.intensity;\n    \n    return L;\n}\n// scattering of light below the surface of the object\nfloat sss(Light light, float orenNayar)\n{\n    const float scatterWidth = 0.3;\n    const float scatterWidth2 = 2.0 * scatterWidth;\n    float s = light.intensity * smoothstep(0.0, scatterWidth, orenNayar) * smoothstep(scatterWidth2, scatterWidth, orenNayar);\n        \n    return s;\n}\n/// Gooch:\n// \"cool to warm\" shading so diffuse colors are all midtones\n// see: https://en.wikipedia.org/wiki/Gooch_shading\n/// Cividis: \n// enables nearly identical visual data interpretation to individuals with and without color vision deficiency  \n// perceptually uniform in hue and brightness\n// see: https://arxiv.org/ftp/arxiv/papers/1712/1712.01662.pdf\nvec3 cividisGooch(float intensity)\n{\n    // cache useful cividis values for performance\n\tconst int cividisCount = cividis.length() - 1;\n\tconst float cividisScale = float(cividisCount);\n    // approximately cividis scale sampling\n    intensity *= cividisScale;\n    float a = floor(intensity);\n    float b = ceil(intensity);\n    vec3 color = mix(cividis[int(a)], cividis[int(b)], linearStep(a, b, intensity));\n    \n    return color;\n}\n// light combining physically based equations with stylized elements\nvec3 addLighting(vec3 view, vec3 normal, Light[lightCount] lights, float depth)\n{\n    vec3 color;\n    float diffuse;\n    float subSurface;\n    // for each light\n    for(int n = 0; n < lightCount; n++)\n    {\n        Light light = lights[n];\n        // diffuse\n        float on = 1.0 * orenNayar(normal, light, view);\n        diffuse += on;\n        // specular\n        color += 10.5 * cookTorrance(view, normal, light);\n        // subsurface scattering\n        subSurface += sss(light, on);\n    }\n    // stylized diffuse shading\n    color = mix(cividisGooch(diffuse), color, 0.25);\n    // ochre is one of the oldest used pigments in art\n    // see: https://en.wikipedia.org/wiki/Ochre#Historical_use_in_art_and_culture\n    const vec3 ochre = vec3(204.0 / 255.0, 119.0 / 255.0, 34.0 / 255.0);\n    color = mix(5.5 * subSurface * ochre, color, depth);\n        \n    return color;\n}\n// manage the light and camera for the scene\nStudio staging(vec2 point)\n{\n    // view\n    vec3 viewPoint, viewDirection;\n    viewPoint = vec3(point, -100.0);\n    viewDirection.z = -1.0;\n    // lights\n    Light keyLight;\n    keyLight.position = normalize(vec3(-1.0, 1.0, -1.0));\n    keyLight.intensity = 1.0;\n    // no-see-um green\n\t// see: http://disneylandguru.tumblr.com/post/24656470253\n\tconst vec3 green = vec3(139.0 / 255.0, 153.0 / 255.0, 153.0 / 255.0);\n    keyLight.color = green;\n    Light fillLight = keyLight;\n    fillLight.position.x *= -1.0;\n    fillLight.position.y = 0.0;\n    fillLight.intensity *= 0.25;\n    const float bounceFactor = 0.5 / sqrt(2.0);\n    Light bouncedKeyLight = keyLight;\n    bouncedKeyLight.position = reflect(keyLight.position, viewDirection);\n    bouncedKeyLight.intensity *= bounceFactor;\n    Light bouncedFillLight = fillLight;\n    bouncedFillLight.position = reflect(fillLight.position, viewDirection);\n    bouncedFillLight.intensity *= bounceFactor;\n    \n    Light[lightCount] lights = Light[]\n    (\n        keyLight,\n        fillLight,\n        bouncedKeyLight,\n        bouncedFillLight\n    );\n    // isometric\n    vec3 axis;\n    float angle;\n    axis = vec3(0.0, 1.0, 0.0);\n    angle = -0.75 * pi;\n    viewPoint = rotationRodrigues(viewPoint, axis, angle);\n    viewDirection = rotationRodrigues(viewDirection, axis, angle);\n    for(int n = 0; n < lightCount; n++)\n    {\n        lights[n].position = rotationRodrigues(lights[n].position, axis, angle);\n    }\n    const float inverseSqrt2 = 1.0 / sqrt2;\n    axis = normalize(vec3(1.0, 0.0, -1.0));\n    angle = -atan(inverseSqrt2);\n    viewPoint = rotationRodrigues(viewPoint, axis, angle);\n    viewDirection = rotationRodrigues(viewDirection, axis, angle);\n    for(int n = 0; n < lightCount; n++)\n    {\n        lights[n].position = rotationRodrigues(lights[n].position, axis, angle);\n    }\n    // construct view line\n    Line camera;\n    camera.point = viewPoint;\n    camera.direction = viewDirection;\n    \n    Studio studio;\n    studio.lights = lights;\n    studio.camera = camera;\n    \n    return studio;\n}\n// distance along the ray needed to intersect with a ground plane\nfloat lineGroundIntersection(Line line)\n{\n    float t = -line.point.y / line.direction.y;\n    return t;\n}\n// create \nShape geometry(Line ray, float scale)\n{\n    ray.point *= scale;\n        \n    float t = lineGroundIntersection(ray);\n    \n    ray.direction *= -1.0;\n    \n    vec3 normal;\n    float depth;\n    \n    float time = 0.5 + cos(iTime) * 0.5;\n    \n    float radius = float(gridHeight);\n    radius = mix(0.5 * radius, radius, time);\n    float gh = 2.0 * radius; \n    vec3 center = vec3(radius);\n    // march along voxel grid\n    for(uint n = 0u; float(n) < gh; n++)\n    {\n        // search three voxels in front of the current voxel.\n        vec3 point = ray.point - t * ray.direction;\n        vec3 cubePosition;\n        cubePosition.xz = floor(point.xz);\n        cubePosition.y = point.y;\n        cubePosition += 0.5;\n        for(float i = 0.0; i <= 1.0; i++)\n        {\n            for(float j = 0.0; j <= 1.0; j++)\n            {\n                vec3 voxelPosition = cubePosition;\n                voxelPosition.xz += vec2(i, j);\n                Line voxelRay = ray;\n                voxelRay.point -= voxelPosition;\n                Voxel voxel = boxNormal(voxelRay.direction, voxelRay.point, 0.5);\n                vec3 diff = center - voxelPosition;\n                bool isActive = mix(supremumNorm(diff), taxicabNorm(diff), time) < radius;\n                bool isValid = voxel.isHit && isActive;\n                normal = voxel.normal * float(isValid) + normal * float(!isValid);\n                depth += float(isValid);\n            }\n        }\n        t += sqrt3;\n    }\n    Shape shape;\n    shape.normal = normal;\n    const float dCube = 3.0 * sqrt3;\n    const float dOct = 3.0 * 1.25 / sqrt3;\n    shape.depth = depth / (mix(dCube, dOct, time) * radius);\n    \n    return shape;\n}\n// combine geometry with lighting\nvec3 render(Studio studio, Shape geometry)\n{\n    vec3 color = addLighting(studio.camera.direction, geometry.normal, studio.lights, geometry.depth);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize pixel coordinates and center on origin\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    // golden ratio\n    const float scale = float(gridHeight) * 1.618 * sqrt(2.0);\n    // position the lights and camera\n    Studio studio = staging(uv);\n    // plot objects relative to the camera\n    Shape geometry = geometry(studio.camera, scale);\n    // determine pixel colors\n    vec3 color = render(studio, geometry);\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/// color-blind safe and perceptually uniform color scale\n/// adapted from:\n/// https://github.com/marcosci/cividis\nconst vec3[] cividis = vec3[]\n(\n    vec3(0.0000, 0.1262, 0.3015),\n\tvec3(0.0000, 0.1408, 0.3334),\n\tvec3(0.0000, 0.1546, 0.3676),\n\tvec3(0.0000, 0.1685, 0.4031),\n\tvec3(0.0000, 0.1817, 0.4347),\n\tvec3(0.0000, 0.1930, 0.4361),\n\tvec3(0.0000, 0.2073, 0.4329),\n\tvec3(0.0710, 0.2215, 0.4293),\n\tvec3(0.1204, 0.2357, 0.4262),\n\tvec3(0.1566, 0.2498, 0.4236),\n\tvec3(0.1868, 0.2639, 0.4217),\n\tvec3(0.2133, 0.2780, 0.4205),\n\tvec3(0.2375, 0.2920, 0.4200),\n\tvec3(0.2599, 0.3060, 0.4202),\n\tvec3(0.2811, 0.3200, 0.4210),\n\tvec3(0.3014, 0.3340, 0.4224),\n\tvec3(0.3209, 0.3481, 0.4244),\n\tvec3(0.3398, 0.3622, 0.4270),\n\tvec3(0.3582, 0.3763, 0.4302),\n\tvec3(0.3763, 0.3904, 0.4338),\n\tvec3(0.3940, 0.4047, 0.4381),\n\tvec3(0.4114, 0.4189, 0.4430),\n\tvec3(0.4286, 0.4333, 0.4485),\n\tvec3(0.4456, 0.4477, 0.4547),\n\tvec3(0.4622, 0.4622, 0.4620),\n\tvec3(0.4790, 0.4767, 0.4691),\n\tvec3(0.4971, 0.4915, 0.4723),\n\tvec3(0.5158, 0.5065, 0.4736),\n\tvec3(0.5349, 0.5216, 0.4738),\n\tvec3(0.5541, 0.5368, 0.4733),\n\tvec3(0.5735, 0.5522, 0.4720),\n\tvec3(0.5931, 0.5678, 0.4701),\n\tvec3(0.6129, 0.5835, 0.4673),\n\tvec3(0.6328, 0.5993, 0.4641),\n\tvec3(0.6529, 0.6153, 0.4600),\n\tvec3(0.6732, 0.6315, 0.4553),\n\tvec3(0.6936, 0.6478, 0.4499),\n\tvec3(0.7142, 0.6643, 0.4437),\n\tvec3(0.7350, 0.6810, 0.4368),\n\tvec3(0.7560, 0.6979, 0.4290),\n\tvec3(0.7771, 0.7150, 0.4205),\n\tvec3(0.7985, 0.7322, 0.4111),\n\tvec3(0.8200, 0.7497, 0.4007),\n\tvec3(0.8417, 0.7674, 0.3892),\n\tvec3(0.8636, 0.7853, 0.3766),\n\tvec3(0.8858, 0.8035, 0.3627),\n\tvec3(0.9082, 0.8219, 0.3474),\n\tvec3(0.9308, 0.8405, 0.3306),\n\tvec3(0.9536, 0.8593, 0.3116),\n\tvec3(0.9767, 0.8785, 0.2901),\n\tvec3(1.0000, 0.8979, 0.2655),\n\tvec3(1.0000, 0.9169, 0.2731)\n);\nstruct Voxel\n{\n    vec3 normal;\n    bool isHit;\n};\n/// Inigo Quilez's analytic box normal  \n/// adapted from:\n/// https://iquilezles.org/articles/boxfunctions\nVoxel boxNormal( vec3 direction, vec3 point, float radius )\n{\n    vec3 directionInverse = 1.0 / direction;\n    vec3 n = point * directionInverse;\n    vec3 s = sign(direction);\n    vec3 k = s * radius * directionInverse;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    vec3 normal = -s * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    \n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    bool isHit = tN <= tF && tF >= 0.0;\n        \n    Voxel voxel;\n    voxel.normal = normal;\n    voxel.isHit = isHit;\n    \n    return voxel;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}