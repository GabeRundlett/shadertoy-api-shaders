{
    "Shader": {
        "info": {
            "date": "1523488332",
            "description": "Exercise",
            "flags": 0,
            "hasliked": 0,
            "id": "ldycW3",
            "likes": 4,
            "name": "Blue box",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "mlkn",
            "viewed": 5210
        },
        "renderpass": [
            {
                "code": "float glow = 0.0;\nfloat t;\nconst float EPSILON = 0.0001;\n\nmat3 makeRotationMatrix(vec3 a)\n{\n    return mat3(\n    \tcos(a.x) * cos(a.z) - sin(a.x) * cos(a.y) * sin(a.z),\n        -cos(a.x) * sin(a.z) - sin(a.x) * cos(a.y) * cos(a.z),\n        sin(a.x) * sin(a.y),\n        sin(a.x) * cos(a.z) + cos(a.x) * cos(a.y) * sin(a.z),\n        -sin(a.x) * sin(a.z) + cos(a.x) * cos(a.y) * cos(a.z),\n        -cos(a.x) * sin(a.y),\n        sin(a.y) * sin(a.z),\n        sin(a.y) * cos(a.z),\n        cos(a.y)\n    );\n}\n\n#define sph(p, r) (length(p) - r)\n#define cube(p, b) length(max(abs(p) - vec3(b), 0.))\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat capsules(vec3 q) {\n    vec3 a = vec3(0.05);\n    vec3 b = vec3(0.2);\n    float r = 0.05 * abs(t);\n    \n    float c1 = sdCapsule(q, a, b, r);\n    float c2 = sdCapsule(q, -a, -b, r);\n    float c3 = sdCapsule(vec3(-q.x, -q.y, q.z), a, b, r);\n    float c4 = sdCapsule(vec3(-q.x, -q.y, q.z), -a, -b, r);\n    \n    float c5 = sdCapsule(vec3(-q.x, q.y, q.z), a, b, r);\n    float c6 = sdCapsule(vec3(-q.x, q.y, q.z), -a, -b, r);\n    float c7 = sdCapsule(vec3(q.x, -q.y, q.z), a, b, r);\n    float c8 = sdCapsule(vec3(q.x, -q.y, q.z), -a, -b, r);\n    \n    return min(min(min(min(min(min(min(c1, c2), c3), c4), c5), c6), c7), c8);\n}\n\nfloat sceneSDF(vec3 p) {\n    mat3 rot = makeRotationMatrix(vec3(iTime, iTime * 0.3, iTime * 0.6));\n    vec3 q = rot * p.xyz;\n    t = sin(iTime * 4.);\n\tfloat d = max(sph(p, mix(.125, .15, t)), cube(q, .1)); \n    \n    d = max(-capsules(q), d);\n    \n    d = max(-sph(p.xyz, mix(.1, .125, t)), d);\n    \n\n\t// https://www.shadertoy.com/view/4t2yW1\n\tglow += 0.0001 / (.01 + d * d);\n\treturn d;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n\tvec3 ro = vec3(0., 0., 0.5), p;\n\tvec3 rd = normalize(vec3(uv, -1));\n\tp = ro;\n\n\tfloat t = 0.;\n    float hit = 0.;\n   //  vec3 normal = vec3(0.0);\n\tfor (float i = 0.; i < 2.0; i += .01) {\n\t\tp = ro + rd * t;\n\t\tfloat d = sceneSDF(p);\n        if (d < .001) {\n            hit = 1.0;\n            // normal = estimateNormal(p);\n            break;\n        }\n        \n\t\tt += d * 0.2; // avoid clipping, enhance the glow\n        if (t > 10.) {\n            hit = 0.0;\n            break;\n        }\n\t}\n    \n\tvec3 c = vec3(glow, glow, sqrt(glow)); // normal;\n\tfragColor = vec4(c, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}