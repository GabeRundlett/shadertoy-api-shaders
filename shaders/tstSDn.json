{
    "Shader": {
        "info": {
            "date": "1573112470",
            "description": "Inktober, but with shaders",
            "flags": 0,
            "hasliked": 0,
            "id": "tstSDn",
            "likes": 16,
            "name": "shadetober #22 (ghost)",
            "published": 3,
            "tags": [
                "inktober",
                "shadertober",
                "shadetober",
                "inktober2019"
            ],
            "usePreview": 0,
            "username": "percentcer",
            "viewed": 524
        },
        "renderpass": [
            {
                "code": "#define TAU 6.283\n// https://iquilezles.org/articles/distfunctions2d\n\nfloat sdUnevenCapsule(vec2 p, float r1, float r2, float h) {\n  p.x = abs(p.x);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(p, vec2(-b, a));\n  if (k < 0.0)\n    return length(p) - r1;\n  if (k > a * h)\n    return length(p - vec2(0.0, h)) - r2;\n  return dot(p, vec2(a, b)) - r1;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h);\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat wiggles(vec2 p, float h, float freq, float amp, float speed) {\n  return p.y - (h + sin((iTime * speed + p.x) * freq) * amp);\n}\n\nfloat arms(vec2 p, float h, float l, float freq, float amp) {  \n  return sdLine(p + vec2(0., h) + vec2(0., sin(p.x * freq) * amp), vec2(-l, 0.), vec2(l, 0.)) - .1;\n}\n\nfloat map(vec2 uv) {\n  uv.x += sin((uv.y + iTime) * 4.) * .05;\n  uv.y += sin(iTime) * .2+.15;\n    \n  float dist = 100.;\n\n  float body = sdUnevenCapsule(uv + vec2(0., .2), .5, .4, .5);\n  dist = max(-dist, body);\n\n  float wigg = wiggles(uv, -.3, 8., .1, .5);\n  dist = max(-wigg, dist);\n\n  float arms = arms(uv, -.1, .7, 8., .1 * sin(iTime));\n  dist = min(arms, dist);\n    \n  float eyel = length(uv - vec2(-.18,.4 + sin(iTime) * .02)) - .1;\n  dist = max(-eyel, dist);\n    \n  float eyer = length(uv - vec2(.2,.3 + sin(iTime * 1.2) * .03)) - .1;\n  dist = max(-eyer, dist);\n    \n  float mouthwiggle = .76 + sin(iTime*3.) * .01;\n    float mouthwid = .1 + sin(iTime*2.) * .01;\n  float mouth = sdArc(uv + vec2(.04,-0.35), vec2(sin(TAU*mouthwiggle), cos(TAU*mouthwiggle)), vec2(sin(TAU* mouthwid), cos(TAU* mouthwid)), .15, .02);\n    dist = max(-mouth, dist);\n\n  return dist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n  float ghost = map(uv);\n\n  //vec3 col = vec3(step(0.,ghost));\n  vec3 col = pow(abs(vec3(ghost)), vec3(.2));\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}