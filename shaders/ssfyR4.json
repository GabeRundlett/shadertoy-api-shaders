{
    "Shader": {
        "info": {
            "date": "1642060566",
            "description": "Mandelbrot set colored with a combination of smooth iteration count and orbit trapping. Each orbit is trapped to two different shapes, one used for points in the set and the other for points not in the set. Mouse to change color and outer orbit shape.",
            "flags": 0,
            "hasliked": 0,
            "id": "ssfyR4",
            "likes": 14,
            "name": "Double Orbit Trapping",
            "published": 3,
            "tags": [
                "2d",
                "fractal",
                "mouse",
                "mandelbrot",
                "orbit",
                "trap"
            ],
            "usePreview": 0,
            "username": "amhall",
            "viewed": 575
        },
        "renderpass": [
            {
                "code": "// Mandelbrot set in which orbits are simultaneously trapped to two different shapes.\n// Whether the point is inside or outside the set determines which shape is used for\n// coloring. Mouse x changes the the shape, mouse y offsets the color.\n\n// The goal of this was for regions in the set to be a little more spicy than the\n// classic pitch black look. I couldn't figure out a good way to color the inside but\n// I think if it were done well, it would make for some beautiful renders.\n\n// This doesn't work as well away from the x axis unfortunately. Since those mini-\n// Mandelbrots aren't quite bilaterally symmetrical, there can be a lot of asymmetry\n// in the final orbit trap distances.\n\n// Created by Anthony Hall\n\n\n// Lower these to speed up\nconst int SS = 2;\nconst float maxIters = 600.0;\n\n// The amount of time spent on each shape variation\nconst float shapeDuration = 8.0;\n\nconst float scale = 0.25*0.00131604;\nconst vec2 center = vec2(-1.575705, 0.0);\n\nconst float pi  = radians(180.0);\nconst float twoPi = radians(360.0);\n\n// Globals set in mainImage\nfloat leafOrbitOffset; \nfloat orbitTrapInfluence;\nfloat colorOffset;\n\nvec2 complexMultiply(vec2 c1, vec2 c2) {\n    return vec2(\n    \tc1.x*c2.x - c1.y*c2.y,\n    \tc1.x*c2.y + c1.y*c2.x);\n}\n\n// \"Triangular\" distance from origin\nfloat triangleOrbit(vec2 point)\n{\n    point.y = abs(point.y);\n    return max(-point.x, dot(point, vec2(0.5, 0.5 * sqrt(3.0))));\n}\n\n// \"Leafular\" (??) distance from orgin for positive offset values only - still produces\n// interesting results with negative offset values\n// Increasing offset makes it less circular and more leaf-like\nfloat leafOrbit(vec2 point)\n{\n    point.y = abs(point.y);\n    point.y += leafOrbitOffset;\n    float leafDist = length(point) - leafOrbitOffset;\n    return leafDist;\n}\n\n// Oscillating \"glowing\" color band\nvec3 colorBand(float t, vec3 exponents)\n{\n    float phase = t * twoPi;\n    return pow(vec3(0.5 - 0.5 * cos(phase)), exponents);\n}\n\nvec3 mandelbrot(vec2 C)\n{\n    vec2 z = C; // Implicit first iteration\n    float zz; // z . z\n    float outerDist = 1e5; // Orbit trap outside the set\n    float innerDist = 1e5; // Orbit trap inside the set\n    float iters;\n    \n    // The magnitude at which we consider a point divergent. Higher values are better\n    // for the smooth iteration count method (so Z^2 becomes much more significant than C)\n    // at the cost of a few more iterations.\n    const float bound = 32.0;\n    \n    // This offset corrects the optimized version of the smooth iteration formula\n    // so it is equivalent to the non-optimized version\n    const float smoothOffset = -log2(log2(bound)) - 1.0;\n    \n    for (iters = 1.0; iters < maxIters; iters ++)\n    {\n        z = complexMultiply(z, z) + C;\n        zz = dot(z, z);\n        if (zz > bound * bound)\n            break;\n        \n        // This is a really weird function but it produces a good result\n        outerDist = min(outerDist, \n            log( 0.4 * abs( log( abs( log( leafOrbit(5.0 * z) ) ) ) ) + 0.04) );\n        innerDist = min(innerDist, triangleOrbit(z));\n    }\n    if (iters == maxIters) // In set\n    {  \n        //float t = log(innerDist + 0.00002) - 0.12 * iTime + 0.6; // old\n        float t = 300.0 * innerDist - 0.075 * iTime + 0.45;\n        return colorBand(t, vec3(6.0, 20.0, 1.5));\n    }\n    else // Not in set\n    {\n        // See Inigo Quilez's article on smooth iteration count\n        // https://iquilezles.org/articles/msetsmooth\n        // Orbit distance gets added slightly to the smooth iteration count\n        float smoothIters = iters - (log2(log2(zz)) + smoothOffset);\n        float t = -0.25 * orbitTrapInfluence * outerDist\n            + 0.9 * log2(smoothIters) + 0.5 * (1.0 - orbitTrapInfluence) + colorOffset;\n        return colorBand(t, vec3(10.0, 2.5, 0.75));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Oscillate between different orbit trap shapes based on time/mouse\n    const float[3] offsets = float[3](-2.1, 1.6, -1.0);\n    float shape;\n    if (iMouse.z > 0.0)\n    {\n        shape = 3.0 * iMouse.x / iResolution.x;\n        colorOffset = iMouse.y / iResolution.y - 0.5;\n    }\n    else\n    {\n        shape = mod(iTime / shapeDuration + 0.2, 3.0);\n        colorOffset = 0.0;\n    }   \n    leafOrbitOffset = offsets[int(shape)] + 0.4 * fract(shape);\n    orbitTrapInfluence = smoothstep(0.0, 0.2, 0.5 - abs(fract(shape) - 0.5));     \n\n    const float theta = -0.3;\n    const mat2 transform = scale * mat2(\n        cos(theta), sin(theta),\n        -sin(theta), cos(theta));\n\n    vec3 color = vec3(0.0);\n    for (int y = 0; y < SS; y++)\n    {\n        for (int x = 0; x < SS; x++)\n        {\n            const float increment = 1.0 / float(SS);\n            const float offset = 0.5 * increment - 0.5;\n            vec2 newFragCoord = fragCoord + offset + increment * vec2(x, y);\n            vec2 uv = (2.0 * newFragCoord - iResolution.xy) / iResolution.y;\n            \n            vec2 C = center + transform * uv;\n            color += mandelbrot(C);\n        }\n    }\n    color /= float(SS * SS);\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}