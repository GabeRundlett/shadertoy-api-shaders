{
    "Shader": {
        "info": {
            "date": "1714347918",
            "description": "3D geometry kata. Public domain.\n\nTake a polyhedron and enlarge its faces until they meet again.\nWhat you get is a stellation: another \"layer\" made with the same planes.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "4fcSRS",
            "likes": 23,
            "name": "Stellations",
            "published": 3,
            "tags": [
                "geometry",
                "sorting",
                "polyhedra",
                "platonic",
                "rhombic"
            ],
            "usePreview": 0,
            "username": "rrrola",
            "viewed": 196
        },
        "renderpass": [
            {
                "code": "// 3D geometry kata. Public domain.\n\n// Take a polyhedron and enlarge its faces until they meet again.\n// What you get is a stellation: another \"layer\" made with the same planes.\n\n// I represent a polyhedron using half-spaces or two-sided half-spaces (abs).\n// Normally you would intersect all the half-spaces using \"max\" of their signed distances\n// and get the original polyhedron,\n// but we can take the N-th largest value to get the N-th stellation layer.\n\n// You could also raytrace them and take the N-th intersection. Is it faster than raycasting?\n\n// Sorting is done with sorting networks: https://bertdobbelaere.github.io/sorting_networks.html\n\n// v2 (2024-04-29): update d8 and rhombic d12, use sphere impostors when far away: speedup ×3\n// v3 (2024-04-29): raytrace to a bounding sphere before raycasting: speedup ×1.4\n\nconst float _2PI = 6.2831853, phi = 0.618034, PHI = 1.+phi, EPS = 1e-4;\nconst vec2 J = vec2(1,-1) / sqrt(3.);  // for 4- and 8hedral faces\nconst float LOD_TEST = 5., LOD_RAD = 2.;  // impostor sphere: squared test and reported radius\n\n// Min/max of multiple arguments.\nfloat Min(float a, float b, float c) { return min(min(a,b),c); }\nfloat Max(float a, float b, float c) { return max(max(a,b),c); }\nfloat Min(float a, float b, float c, float d) { return min(min(a,b),min(c,d)); }\nfloat Max(float a, float b, float c, float d) { return max(max(a,b),max(c,d)); }\n\n// Sort two values in place. Building block for sorting networks.\nvoid sort(inout float a, inout float b) {\n  float m = min(a,b);\n  a = max(a,b); b = m;\n}\n\n\n// The scene features the five Platonic solids and the rhombic d12 and d30.\n// The cube and the tetrahedron share a slot because they have only a few stellations.\n\n// 4hedron + cube\nfloat d4d6(vec3 q, vec4 r) {\n  // cube\n  float A=abs(q.x), B=abs(q.y), C=abs(q.z);\n  sort(A,C); sort(A,B); sort(B,C);  // sorting network for 3 inputs: a=max, b=median, c=min\n\n  // 4hedron\n  float a = dot(q,J.xxx), b = dot(q,J.xyy), c = dot(q,J.yxy), d = dot(q,J.yyx);\n  sort(a,c); sort(b,d); sort(a,b); sort(c,d); sort(b,c);  // sorting network for 4 inputs\n\n  // 3D plus: subtract from a cube\n  // 3D screwdriver head: clip with a cube\n  // do something similar with the 4hedron\n  return Min(max(A-r.x, -(B-.7*r.x)), max(A-r.w, C-.2*r.w), max(a-.7*r.y, -c), max(a-r.z, b-.1*r.z));\n}\n\n// rhombic 12hedron\nfloat d12r(vec3 q, vec4 r) {\n  float cube = Max(abs(q.x), abs(q.y), abs(q.z));\n  float a = abs(q.x-q.y) / sqrt(2.),\n        b = abs(q.z-q.x) / sqrt(2.),\n        c = abs(q.y-q.z) / sqrt(2.),\n        d = abs(q.x+q.y) / sqrt(2.),\n        e = abs(q.z+q.x) / sqrt(2.),\n        f = abs(q.y+q.z) / sqrt(2.);\n  // sorting network for 6 inputs: a=max, b=second, ..., f=min\n  sort(a,f); sort(b,d); sort(c,e);\n  sort(b,c); sort(d,e);\n  sort(a,d); sort(c,f);\n  sort(a,b); sort(c,d); sort(e,f);\n  sort(b,c); sort(d,e);\n  return Min(b-.8*r.w, max(a-1.1*r.z,d-.25*r.z), max(a-r.x,-(e-.2*r.x)), c-.55*r.y);\n}\n\n// 8hedron\nfloat d8(vec3 q, vec4 r) {\n  float a = abs(dot(q,J.xxx)),\n        b = abs(dot(q,J.xyy)),\n        c = abs(dot(q,J.yxy)),\n        d = abs(dot(q,J.yyx));\n  sort(a,c); sort(b,d); sort(a,b); sort(c,d); sort(b,c);  // sorting network for 4 inputs\n  return Min(max(length(q)-1.2*r.w, d-r.w/6.), max(a-.8*r.z, -(d-.1*r.z)), b-.6*r.x, max(a-r.y, c-r.y/3.));\n}\n\n// platonic 12hedron\nfloat d12(vec3 q, vec4 r) {\n  vec3 I = vec3(1,phi,-phi); I /= length(I.xy);\n  float a = abs(dot(q.xy,I.xy)),\n        b = abs(dot(q.xy,I.xz)),\n        c = abs(dot(q.yz,I.xy)),\n        d = abs(dot(q.yz,I.xz)),\n        e = abs(dot(q.zx,I.xy)),\n        f = abs(dot(q.zx,I.xz));\n  // sorting network for 6 inputs: a=max, b=second, ..., f=min\n  sort(a,f); sort(b,d); sort(c,e);\n  sort(b,c); sort(d,e);\n  sort(a,d); sort(c,f);\n  sort(a,b); sort(c,d); sort(e,f);\n  sort(b,c); sort(d,e);\n  // e (pentagram holes): clip with a 12hedron\n  return Min(max(e-.23*r.x, a-r.x), b-.7*r.z, c-.7*r.y, d-.3*r.w);\n}\n\n// 20hedron\nfloat d20(vec3 q, vec4 r) {\n  vec3 I = vec3(phi,-phi,PHI); I /= length(I.xz);\n  float a=abs(dot(q,J.xxx)), b=abs(dot(q,J.xyy)), c=abs(dot(q,J.yxy)), d=abs(dot(q,J.yyx)),\n        e=abs(dot(q.xy,I.xz)), f=abs(dot(q.xy,I.yz)),\n        g=abs(dot(q.yz,I.xz)), h=abs(dot(q.yz,I.yz)),\n        i=abs(dot(q.zx,I.xz)), j=abs(dot(q.zx,I.yz));\n  // sorting network for 10 inputs: a=max, b=second, ..., j=min\n  sort(a,i); sort(b,j); sort(c,h); sort(d,f); sort(e,g);\n  sort(a,c); sort(b,e); sort(f,i); sort(h,j);\n  sort(a,d); sort(c,e); sort(f,h); sort(g,j);\n  sort(a,b); sort(d,g); sort(i,j);\n  sort(b,f); sort(c,d); sort(e,i); sort(g,h);\n  sort(b,c); sort(d,f); sort(e,g); sort(h,i);\n  sort(c,d); sort(e,f); sort(g,h);\n  sort(d,e); sort(f,g);\n  // j (pentagram circles): clip with a ball because it looks cool\n  return Min(b-r.x, g-.3*r.z, f-.4*r.w, max(length(q)-1.2*r.y, j-.04*r.y));\n}\n\n// rhombic 30hedron\nfloat d30r(vec3 q, vec4 r) {\n  vec3 W = normalize(vec3(phi,1,PHI));\n  vec3 X = normalize(vec3(phi,-1,-PHI));\n  vec3 Y = normalize(vec3(-phi,1,-PHI));\n  vec3 Z = normalize(vec3(-phi,-1,PHI));\n  // there are 15 plane directions: group them into five cubes\n  float a = Max(abs(q.x), abs(q.y), abs(q.z)),\n        b = Max(abs(dot(q,X)), abs(dot(q,X.yzx)), abs(dot(q,X.zxy))),\n        c = Max(abs(dot(q,W)), abs(dot(q,Z.yzx)), abs(dot(q,Y.zxy))),\n        d = Max(abs(dot(q,Y)), abs(dot(q,W.yzx)), abs(dot(q,Z.zxy))),\n        e = Max(abs(dot(q,Z)), abs(dot(q,Y.yzx)), abs(dot(q,W.zxy)));\n  // sorting network for 5 inputs: a=max, b=second, ..., e=min\n  sort(a,d); sort(b,e);\n  sort(a,c); sort(b,d);\n  sort(a,b); sort(c,e);\n  sort(b,c); sort(d,e);\n  sort(c,d);\n  // a is with holes\n  // c is the 5-cube compound\n  return Min(max(a-r.x, -(b-.9*r.x)), b-r.w, c-r.y, e-.8*r.z);\n}\n\n// Signed distance of the scene.\nfloat f(vec3 p) {\n  vec4 r = sqrt(max(vec4(0), sin(.8*iTime + _2PI/4.*vec4(0,1,2,3))));  // radius: 4 phases\n\n  float k = _2PI/6.;  // one step around the loop\n\n  vec3 q;   // coordinates centered on the current shape\n  float Q;  // impostor sphere\n  float l;  // accumulated minimum distance\n  q = p - 4.*vec3(cos(1.*k),0,sin(1.*k)); Q = dot(q,q); l =        Q>LOD_TEST ? sqrt(Q)-LOD_RAD : d4d6(q, r);\n  q = p - 4.*vec3(cos(3.*k),0,sin(3.*k)); Q = dot(q,q); l = min(l, Q>LOD_TEST ? sqrt(Q)-LOD_RAD : d12r(q, r));\n  q = p - 4.*vec3(cos(5.*k),0,sin(5.*k)); Q = dot(q,q); l = min(l, Q>LOD_TEST ? sqrt(Q)-LOD_RAD : d8(q, r));\n  q = p - 4.*vec3(cos(2.*k),0,sin(2.*k)); Q = dot(q,q); l = min(l, Q>LOD_TEST ? sqrt(Q)-LOD_RAD : d12(q, r));\n  q = p - 4.*vec3(cos(4.*k),0,sin(4.*k)); Q = dot(q,q); l = min(l, Q>LOD_TEST ? sqrt(Q)-LOD_RAD : d20(q, r));\n  q = p - 4.*vec3(cos(0.*k),0,sin(0.*k)); Q = dot(q,q); l = min(l, Q>LOD_TEST ? sqrt(Q)-LOD_RAD : d30r(q, r));\n  return l;\n}\n\n// Intersect a ray (p = o + d*t) with a sphere (dot(p-c,p-c) - r2 = 0).\n// Assume the ray starts outside the sphere and points towards it.\nfloat ray_sphere(vec3 o,vec3 d, vec3 c,float r2) {\n  vec3 q = o-c;\n  float B = dot(q,d);\n  float D = B*B - dot(q,q) + r2;\n  return D>0. ? -B-sqrt(D) : 1000.;\n}\n\nvoid mainImage(out vec4 o, vec2 x) {\n  vec2 r = iResolution.xy, uv = (x+x-r)/r.y;  // y:-1..1\n\n  float t = phi*iTime;\n  vec3 T = vec3(cos(t),sin(t),-sin(t));\n  mat2 R = mat2(T.xzyx), RT = mat2(T.xyzx);  // rotation, inverse rotation\n\n  vec3 p = vec3(0,3,-9);            // camera position\n  vec3 d = normalize(vec3(uv, 2));  // ray direction\n  vec3 n = d;         // normal: default = unrotated direction for background gradient\n  float ao = .5*d.z;  // darkening factor: default = darken the background with a vignette\n\n  // rotate the camera around the origin and angle it a little downwards\n  p.xz = R * p.xz;\n  float up = .4;\n  d.yz = mat2(cos(up),sin(up), -sin(up),cos(up)) * d.yz;\n  d.xz = R * d.xz;\n\n  // move the ray origin to the nearest bounding sphere\n  float L = 100.;\n  {\n    vec3 c;   // coordinates centered on the current shape\n    float k = _2PI/6.;  // one step around the loop\n    c = 4.*vec3(cos(1.*k),0,sin(1.*k)); L = min(L, ray_sphere(p,d,c,LOD_RAD*LOD_RAD));\n    c = 4.*vec3(cos(3.*k),0,sin(3.*k)); L = min(L, ray_sphere(p,d,c,LOD_RAD*LOD_RAD));\n    c = 4.*vec3(cos(5.*k),0,sin(5.*k)); L = min(L, ray_sphere(p,d,c,LOD_RAD*LOD_RAD));\n    c = 4.*vec3(cos(2.*k),0,sin(2.*k)); L = min(L, ray_sphere(p,d,c,LOD_RAD*LOD_RAD));\n    c = 4.*vec3(cos(4.*k),0,sin(4.*k)); L = min(L, ray_sphere(p,d,c,LOD_RAD*LOD_RAD));\n    c = 4.*vec3(cos(0.*k),0,sin(0.*k)); L = min(L, ray_sphere(p,d,c,LOD_RAD*LOD_RAD));\n  }\n  p += L*d;\n\n  // raycast through the scene\n  float l;\n  for (int i=0; i<80; i++) {\n    l = f(p);\n    p += l*d;\n    if (l<EPS || l>6.) break;  // bailout on hit or if too far\n  }\n\n  float fresnel = 0.;\n  if (l < 1.) {  // hit\n    // compute the normal: tetrahedron technique from https://iquilezles.org/articles/normalsSDF/\n    vec2 J = vec2(1,-1), e = EPS*J;\n    n = normalize(J.xxx*f(p+e.xxx) + J.xyy*f(p+e.xyy) + J.yxy*f(p+e.yxy) + J.yyx*f(p+e.yyx));\n\n    // darken the creases a little: take 3 ambient occlusion samples along the normal\n    ao = (max(.5,f(p+.2*n)/.2)\n        + max(.5,f(p+.1*n)/.1)\n        + max(.5,f(p+.05*n)/.05)) / 3.;\n\n    fresnel = pow(1.+dot(n,d), 5.);  // rim lighting\n    n.xz = RT * n.xz;  // lighting is view-dependent: unrotate normal to view space\n  }\n  else { n += n; n.z = 1.-n.z; }  // no hit: background gradient\n\n  // lighting inspired by Mathematica\n  vec3 c = fresnel + vec3(.1,0,.1)\n    + vec3( 0, 0,.2) * max(0., dot(n, vec3( 0, 0,-1)))\n    + vec3( 0,.1,.5) * max(0., dot(n, vec3(.7, 0,-.7)))\n    + vec3(.2,.7,.2) * max(0., dot(n, vec3(.5,.5,-.7)))\n    + vec3(.7,.2, 0) * max(0., dot(n, vec3( 0,.7,-.7)));\n\n  o = vec4(sqrt(c * ao * (n.y*.5 + .7)), 1);  // darken downward directions\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}