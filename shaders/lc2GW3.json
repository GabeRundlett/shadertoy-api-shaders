{
    "Shader": {
        "info": {
            "date": "1704741648",
            "description": "This shader tests safe vector normalization methods, which scale vectors to length 1 while handling zero-length exceptions.",
            "flags": 0,
            "hasliked": 0,
            "id": "lc2GW3",
            "likes": 1,
            "name": "PerfTest Safe Normalization",
            "published": 3,
            "tags": [
                "test",
                "fast",
                "performance",
                "vector",
                "speed",
                "normalize",
                "safe",
                "safenormalize",
                "fastinveresqrt",
                "fastinversesquareroot"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 266
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2024 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis performance test aims to compare methods for safe vector normalization. \nThis means functions that scale a vector to a length of 1, while handling \nthe exception where the length is 0. \n\nThe test works by measuring frames per second (FPS) on Shadertoy. To \nensure valid results, we repeat the test function with varying values, \naccumulating their results into a final image.\n\nSteps:\n- Increase REPEAT until the FPS falls below your monitor's refresh rate \n    (probably somewhere around 60-144 fps)\n- Modify the TEST value to switch between test cases\n- The highest FPS indicates the fastest implementation\n- Congratulate yourself for doing SCIENCE\n*/\n\n// Number of repeats of the test, 10000 should be enough for an RTX3080\n#define REPEAT 1\n\n// Switch between the test cases\n// 0 = Safe Normalization using Length and Normalize \t\t\t~ 61 fps\n// 1 = Safe Normalization using dot product as a partial result ~ 71 fps\n// 2 = 1, but using the Fast Inverse Square Root \t\t\t\t~ 57 fps\n// 3 = Safe Normalization checking if the result is NaN|Inf\t\t~ 32 fps\n// 4 = Safe Normalization checking if the result is NaN\t\t\t~ 56 fps\n#define TEST 0\n\n// Enable a pixelized view to see what happens at (0,0), disable for testing!\n//#define DEBUG\n\n// Extremly tiny positive non-zero float\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\n\n// Safe Normalization using length and normalize functions\nvec2 normalizeLength(vec2 vector) {\n\n    // Check if the length of the vector is greater than a tiny threshold\n    if (length(vector) > SMALLESTFLOAT) {    \n        // If so, normalize the vector\n        return normalize(vector);\n        \n    } else {\n        // Otherwise, return a default vector\n        return vec2(1.0, 0.0);\n    }\n}\n\n// Safe Normalization using dot product and square root\nvec2 normalizeDot(vec2 vector) {\n\n    // Calculate the square of the length of the vector\n    float lenSq = dot(vector, vector);\n    \n    // Check if the squared length is greater than a tiny threshold\n    if (lenSq > SMALLESTFLOAT) {\n        // If so, normalize the vector resuing the squared length\n        return vector / sqrt(lenSq);\n        \n    } else {\n        // Otherwise, return a default vector\n        return vec2(1.0, 0.0);\n    }\n}\n\n// The infamous Fast inverse square root from Quake III Arena\n// Explanation of how this works: https://www.youtube.com/watch?v=p8u_k2LIZyo\n// Glsl Version from 01000001: https://www.shadertoy.com/view/DlSyRD\nfloat FastInverseSqrt(float x) {\n    uint i;\n    float x2, y;\n    \n    x2 = x * 0.5;\n    y = x;\n    i = floatBitsToUint(x);       // Evil floating point bit hack\n    i = 0x5f3759dfu - ( i >> 1);  // What?\n    y = uintBitsToFloat(i);\n    y = y * (1.5 - (x2 * y * y));   // 1st iteration\n//  y = y * (1.5 - (x2 * y * y));   // 2nd iteration, can be removed\n    \n    return y;\n}\n\n// Safe Normalization using Fast Inverse Square Root\nvec2 fastNormalize(vec2 vector) {\n\n    // Calculate the square of the length of the vector\n    float lenSq = dot(vector, vector);\n    \n    // Check if the squared length is greater than an even smaller threshold\n    if (lenSq > 0.000001) {\n        // If so, calculate the inverse square root using the FastInverseSqrt function\n        float invSqrt = FastInverseSqrt(lenSq);\n        \n        // Normalize the vector using the inverse square root\n        return vector * invSqrt;\n        \n    } else {\n        // Otherwise, return a default vector\n        return vec2(1.0, 0.0);\n    }\n}\n\n// Safe Normalization checking for NaN and Inf\n// Originally from iY0Yi: https://www.shadertoy.com/view/cdGfzz\nvec2 normalizeNanInf(vec2 vector) {\n\n    // Normalize the vector\n    vector = normalize(vector); \n    \n    // Check if the vector contains any infinite or NaN values\n    return any(isinf(vector))||any(isnan(vector)) ? vec2(1.0, 0.0) : vector;\n}\n\n// Safe Normalization checking for NaN\nvec2 normalizeNan(vec2 vector) {\n\n    // Normalize the vector\n    vector = normalize(vector); \n    \n    // Check if the vector contains any NaN values\n    return isnan(vector.x) ? vec2(1.0, 0.0) : vector;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // Normalized pixel coordinates (from 0 to 1), centered around 0.5\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n\n    #ifdef DEBUG\n        // Quantize the result to see distinct steps\n        float steps = 16.;\n        uv = floor(uv * steps)/steps;\n    #endif\n    \n    // Initialize test vector\n    vec2 test;\n    for(int i=0; i<REPEAT; i++) {\n    \n        // Unique permutation each iteration\n        float mut = (float(i)/float(REPEAT)); \n          \n        // Use whichever normalization function you wish to test\n        #if TEST == 0\n            test += normalizeLength(uv + mut);\n        #elif TEST == 1\n            test += normalizeDot(uv + mut);\n        #elif TEST == 2\n            test += fastNormalize(uv + mut);\n        #elif TEST == 3\n            test += normalizeNanInf(uv + mut);\n        #else\n            test += normalizeNan(uv + mut);\n        #endif   \n    } \n\n    #if REPEAT > 1\n        // Ensure test vector stays in visible range\n        test = fract(test);\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(test, 0.,1.); \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}