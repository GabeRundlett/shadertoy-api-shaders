{
    "Shader": {
        "info": {
            "date": "1477058116",
            "description": "A simple, oldschool, cylindrically-mapped, tunnel flythrough with some bump mapping, and bump-based edging.",
            "flags": 0,
            "hasliked": 0,
            "id": "Mly3WV",
            "likes": 20,
            "name": "Oldschool Tube",
            "published": 3,
            "tags": [
                "voronoi",
                "tunnel",
                "oldschool",
                "bump",
                "cylinder"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1929
        },
        "renderpass": [
            {
                "code": "/*\n\n\tOldschool Tube\n\t--------------\n\n\tAn oldschool tube effect, with a few extra lines to bump it and light it up. Virtually no \n\tdifferent in concept to the more compact, minimal character versions.\n\n\tAiekick asked about cylindrically wrapping a pattern - like Voronoi - onto a cyclinder, so \n\tI thought I'd put a simple example together and post it privately... However, I got a little \n\tcarried away adding window dressing. It's still not particularly interesting, but I liked\n\tthe simple rendering style, so thought I'd release it publicly.\n\n\tHaving said that, one minor point of interest is that the edging is done in the bump routine.\n\tMost edging examples are raymarched and involved normal-based edge calculations, but this\n\tshows that you can have edging on the bump mapped part of the scene too. There are much more\n\tinteresting applications, and I'll give an example at a later date.\n\n\n\tCreated in repsonse to the following:\n\n    Voro Tri Tunnel - aiekick\n    https://www.shadertoy.com/view/XtGGWy\n\n\tA rough explanation of the oldschool tunnel effect:\n\n\tTraced Minkowski Tube - Shane\n    https://www.shadertoy.com/view/4lSXzh\n\n    // Another example.\n\tLuminescent Tiles - Shane\n\thttps://www.shadertoy.com/view/MtSXRm\n\n*/\n\n// 2D rotation. Always handy. Angle vector, courtesy of Fabrice.\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p, float w) { \n\n    // The Voronoi pattern needs to be repeatable. Hence the \"mod\" line below.\n    p = mod(p, w);\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    return fract(vec2(262144, 32768)*n)*.9 + .1; \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n); \n    // Note the \".45,\" insted of \".5\" that you'd expect to see. When edging, it can open \n    // up the cells ever so slightly for a more even spread. In fact, lower numbers work \n    // even better, but then the random movement would become too restricted. Zero would \n    // give you square cells.\n    //return sin( p*6.2831853 + iTime )*.45 + .5; \n    \n}\n\n\nfloat vx;\n// 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n// up those if-statements. Since there's less writing, it should go faster. That's how \n// it works, right? :)\n//\nfloat Voronoi(in vec2 p, float w){\n    \n    \n\tvec2 g = floor(p), o; p -= g;\n\t\n\tvec3 d = vec3(1.4142); // 1.4, etc. \"d.z\" holds the distance comparison value.\n    \n\tfor(int y=-1; y<=1; y++){\n\t\tfor(int x=-1; x<=1; x++){\n            \n\t\t\to = vec2(x, y);\n            o += hash22(g + o, w) - p;\n            \n\t\t\td.z = length(o);//(dot(o, o)); \n            \n            // More distance metrics.\n            //o = abs(o);\n            //d.z = mix(max(abs(o.x)*.866025 + o.y*.5, -o.y), dot(o, o), .2);//\n            //d.z = max(abs(o.x)*.866025 - o.y*.5, o.y);\n            //d.z = max(abs(o.x) + o.y*.5, -(o.y)*.8660254);\n            //d.z = max(o.x, o.y);\n            //d.z = (o.x*.7 + o.y*.7);\n            \n            d.y = max(d.x, min(d.y, d.z));\n            d.x = min(d.x, d.z); \n                       \n\t\t}\n\t}\n \t\t\t\t\t \n\td/=1.4142;\n    \n    vx = d.x;\n    \n    d = smoothstep(0., 1., d);\n\n    \n    return max(d.y/1.333 - d.x, 0.)*1.333;\n    \n   \n    //return d.y - d.x;\n    \n}\n\nfloat objID;\n\n// The bump mapping function.\nfloat bumpFunction(in vec3 p){\n    \n    // Stock standard cylindrical mapping. This line here is pretty much\n    // where all the oldschool tunnel examples stem from.\n    vec2 uv = vec2(atan(p.y, p.x)/6.2832, p.z/8.);\n    \n    float c = Voronoi(uv*16., 16.);\n\n    objID = 0.;\n\n    // The web section. Comment it out, if you're not sure what it does.\n    if(c<.15) { c = abs(max(c, 0.01) - .3), objID = 1.; }\n    \n    return c;\n   \n}\n\n\n// Standard function-based bump mapping function, with some edging added to the mix.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge){\n    \n    vec2 e = vec2(2.5/iResolution.y, 0);\n    \n    float f = bumpFunction(p); \n    \n    // Samples about the hit point in each of the axial directions.\n    float fx = bumpFunction(p - e.xyy); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunction(p - e.yxy); // Same for the nearby sample in the Y-direction.\n    float fz = bumpFunction(p - e.yyx); // Same for the nearby sample in the Y-direction.\n\n    // Samples from the other side.\n    float fx2 = bumpFunction(p + e.xyy); // Same for the nearby sample in the X-direction.\n    float fy2 = bumpFunction(p + e.yxy); // Same for the nearby sample in the Y-direction.\n    float fz2 = bumpFunction(p + e.yyx); // Same for the nearby sample in the Y-direction.\n    \n    // We made three extra function calls, so we may as well use them. Taking measurements\n    // from either side of the hit point has a slight antialiasing effect.\n    vec3 grad = (vec3(fx - fx2, fy - fy2, fz - fz2))/e.x/2.;   \n\n    // Using the samples to provide an edge measurement.\n    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 6.*f);\n    //edge = abs(fx + fx2 - f*2.) + abs(fy + fy2 - f*2.)+ abs(fz + fz2 - f*2.);\n    edge = smoothstep(0., 1., edge/e.x);\n          \n    grad -= n*dot(n, grad);          \n                      \n    return normalize( n + grad*bumpfactor );\n\t\n}\n\n\n// The second function. This adds the swirly noise patterns to the webbing.\nfloat bumpFunction2(in vec3 p){\n    \n    float c = n3D(p*16.); // Noise value.\n    \n    c = fract(c*4.); // Producing some repeat noise contour rings... Bad description. :)\n    \n    return min(c, c*(1. - c)*4.); // Smooth \"fract.\" It's an old trick.\n   \n}\n\n// A second function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor){\n    \n    vec2 e = vec2(2.5/iResolution.y, 0);\n    float f = bumpFunction2(p); \n    \n    float fx = bumpFunction2(p - e.xyy); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunction2(p - e.yxy); // Same for the nearby sample in the Y-direction.\n    float fz = bumpFunction2(p - e.yyx); // Same for the nearby sample in the Y-direction.\n    \n    vec3 grad = (vec3(fx, fy, fz )-f)/e.x; \n          \n    grad -= n*dot(n, grad);          \n                      \n    return normalize( n + grad*bumpfactor );\n}\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\n    \n    // Unit direction ray. Coyote's elegant version. So obvious, yet it never occurred\n    // to me... or most others, it seems. :)\n    vec3 rd = normalize(vec3(fragCoord - iResolution.xy*0.5, iResolution.y));\n    \n    rd.xy = rot(iTime*0.25)*rd.xy; // Look around, just to show it's a 3D effect.\n    rd.xz = rot(iTime*0.125)*rd.xz;\n    \n    // Ray origin.\n    vec3 ro = vec3(0.0, 0.0, iTime);\n    \n    // Screen color. Initialized to black.\n    vec3 col = vec3(0);\n\n\tconst float rad = 1.; // Initial cylinder radius.\n\n    // Distance fromt the ray origin to the cylinder layer surface point. It's a cut down\n    // version of a traced cylinder with its center fixed to the Z axis.\n    float sDist = rad/max( length(rd.xy), 0.001 );\n\n    // Surface position.\n    vec3 sp = ro + rd*sDist;\n\n    // Surface normal.\n    vec3 sn = normalize(vec3(-sp.xy, 0.)); // Cylinder normal.\n\n    // Bumpmapping (the Voronoi part) with some edge calculations included.\n    float edge;\n    sn = doBumpMap( sp, sn, .75, edge);\n    \n    // The object ID is calculated in the bump function. We save it here. Zero is the bulbous\n    // portion that gets lit up and one is the webbing.\n    float svObjID = objID;\n    \n    // Secondary bump pattern on the webbing. Done separately, so as not to interfere\n    // with the edge calculations.\n    if(svObjID>.5) sn = doBumpMap( sp, sn, .003);\n    \n    // Some rough noise sprinkles. Note that a 3D noise function is being used. You could also\n    // cylindrically map a 2D noise function, but I thought this was less hassle.\n    vec3 tex = vec3(1)*n3D(fract(sp)*192.);\n    vec3 objCol = smoothstep(.1, .9, tex)*.8 + 1.;\n    \n    \n    if(svObjID<.5) objCol *= vec3(.45, .425, .5); // The bulbs. Using a slightly darker tone.\n    else objCol *= vec3(.68, .64, .75); // The Voroni web portion.\n    \n    // Alternative: Egyptian look - gold and turquoise... or lapis lazuli, for the purists. :)\n    //if(svObjID>.5) objCol *= vec3(1, .75, .4)*.75;\n    //else objCol *= vec3(.5, .7, 1);\n\n    // Lighting.\n    //\n    // The light. Placed near the ray origin, camera, etc. We're looking down both ends of the\n    // tunnel, so it helps to keep the light near the camera. A better alternative is to have \n    // two lights on either side, but I'm trying to keep it simple.\n    vec3 lp = ro + vec3(0, .5, 0);\n    vec3 ld = lp - sp; // Light direction.\n    float dist = max(length(ld), 0.001); // Distance from light to the surface.\n    ld /= dist; // Use the distance to normalize \"ld.\"\n\n    // Light attenuation, based on the distance above.\n    float atten = 1.5/(1. + dist*.05 + dist*dist*0.075);\n    \n    // Use the bump texture to darken the crevices. Comment it out to see its effect.\n    atten *= bumpFunction(sp)*.9 + .1;//getGrey(texCol(iChannel0, sp))*.5 + .5;\n\n\n    float diff = max(dot(ld, sn), 0.); // Diffuse light value.\n    diff = pow(diff, 8.)*0.66 + pow(diff, 16.)*0.34;  // Ramping it up.\n    \n    float spec = pow(max(dot(reflect(ld, sn), rd), 0.), 8.); // Specular light value.\n    \n    /////\n    // The blinking light section. All of it is made up.\n    // Basically, we're adding a unit refracted vector to the hit position, then passing it into a\n    // cylindrically mapped Voronoi function, smoothing, then colorizing.\n    vec3 ref = sp + refract(rd, sn, 1./1.6);\n    vec2 tuv = vec2(atan(ref.y, ref.x)/6.2832, ref.z/8.);\n    float c2 = Voronoi(tuv*4. - vec2(1, .5)*iTime, 4.);\n    c2 = smoothstep(0.8, 1., 1.-vx);\n        \n    vec3 elec = (objCol*.7 + .3)*pow(min(vec3(1.5, 1, 1)*c2, 1.), vec3(1,  3, 8)); // Fiery coloring.\n        \n    if (svObjID<.5) objCol += elec*8.; // Add a lot of the color to the bulbs.\n    else objCol += elec*2.; // Add a little to the webbing.\n    //////////\n    \n\n    // Using the values above to produce the layer color.\n    col += (objCol*(diff*vec3(1, .97, .92)*2. + 0.25) + vec3(1, .6, .2)*spec*2.)*atten;// + env*atten;\n\n    // Adding some fake reflection to the walls.\n    ref = reflect(rd, sn);\n    float rc = n3D(ref*2.);\n    col += col*smoothstep(.3, 1., rc)*4.*atten;\n    \n    // Darkening the edges. Without it, the scene would lose its mild cartoony look.\n    col *= 1. - edge*.7;\n    \n    \n    //col = mix(col, vec3(2, 1.5, 1).zyx, 1. - exp(-.002*sDist*sDist)); // Blue fog, if you prefer.\n    col = mix(col, vec3(0), 1. - exp(-.002*sDist*sDist)); // Extra fog at the end of the tunnel.\n    \n    // Gamma correction.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}