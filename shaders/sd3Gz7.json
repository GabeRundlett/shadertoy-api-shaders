{
    "Shader": {
        "info": {
            "date": "1629515412",
            "description": "A collection of simple blur passes.",
            "flags": 32,
            "hasliked": 0,
            "id": "sd3Gz7",
            "likes": 9,
            "name": "Blur primitives",
            "published": 3,
            "tags": [
                "blur",
                "boxblur",
                "gaussianblur",
                "kawase"
            ],
            "usePreview": 0,
            "username": "miyaokamarina",
            "viewed": 472
        },
        "renderpass": [
            {
                "code": "// Blur strength.\n// Actual blur radius may vary depending on blur type.\n#define r 20.0\n\nvoid mainImage(out vec4 col, in vec2 pos) {\n    vec2 uv = pos / res;\n\n    col = texture(tex, pos);\n\n    col =    ubox09(tex, uv, res, r);    // classical box            :: flat 3Ã—3 kernel\n    col =  kawase04(tex, uv, res, r);    // kawase kernel            :: corners only\n    col =  kawase05(tex, uv, res, r);    // dual kawase downsampling :: corners + center\n    col =  kawase08(tex, uv, res, r);    // dual kawase upsampling   :: diamond-like\n    col =    uhex07(tex, uv, res, r);    // uniform hexagon          :: like box, but a hexagon\n    col =    ghex07(tex, uv, res, r);    // gaussian hexagon         :: like hex, but with non-linear coefficients\n    col =    uhex13(tex, uv, res, r);    // uniform double hexagon   :: like hex, but applied twice at different scales\n    col =    ghex13(tex, uv, res, r);    // gaussian double hexagon  :: like hex-13, but with non-linear coefficients\n    col = urandomxx(tex, uv, res, r, 4); // random blur\n    col = grandomxx(tex, uv, res, r, 4); // gaussian random\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI      3.141592653589793\n#define PI2     6.283185307179586\n#define SQRT2   1.414213562373095\n#define SQRT22  0.707106781186548\n#define SQRT3   1.732050807568877\n#define SQRT32  0.866025403784439\n#define FLT_MAX 3.40282346600e+38\n\n#define rand  random(state)                        // uniform random float [0, 1]\n#define urand (vec2(rand - 0.5, rand - 0.5) * 2.0) // uniform random vec2 [-1, +1]\n#define grand bmt(vec2(rand, rand))                // gaussian random vec2 [-1, +1]\n#define crand crandom(state)                       // random within a unit circle\n\nvec4 upick(sampler2D tex, vec2 pos, vec2 res, vec2 o, float r);\nvec4 gpick(sampler2D tex, vec2 pos, vec2 res, vec2 o, float r, inout float s);\n\nvec2 bmt(vec2 u);\n\nfloat next(float state);\nfloat seed(vec2 pos);\nfloat random(inout float state);\nvec2  crandom(inout float state);\n\nvec4 ubox09(sampler2D tex, vec2 uv, vec2 res, float r) {\n    vec4 col;\n\n    col += upick(tex, uv, res, vec2(-1, -1), r);\n    col += upick(tex, uv, res, vec2(-1, 0.), r);\n    col += upick(tex, uv, res, vec2(-1, +1), r);\n    col += upick(tex, uv, res, vec2(0., -1), r);\n    col += upick(tex, uv, res, vec2(0., 0.), r);\n    col += upick(tex, uv, res, vec2(0., +1), r);\n    col += upick(tex, uv, res, vec2(+1, -1), r);\n    col += upick(tex, uv, res, vec2(+1, 0.), r);\n    col += upick(tex, uv, res, vec2(+1, +1), r);\n\n    return col / 9.0;\n}\n\nvec4 kawase04(sampler2D tex, vec2 uv, vec2 res, float r) {\n    vec4 col;\n\n    col += upick(tex, uv, res, vec2(-1, -1), r);\n    col += upick(tex, uv, res, vec2(-1, +1), r);\n    col += upick(tex, uv, res, vec2(+1, -1), r);\n    col += upick(tex, uv, res, vec2(+1, +1), r);\n\n    return col / 4.0;\n}\n\nvec4 kawase05(sampler2D tex, vec2 uv, vec2 res, float r) {\n    vec4 col;\n\n    col += upick(tex, uv, res, vec2(0., 0.), r) * 4.0;\n    col += upick(tex, uv, res, vec2(-1, -1), r);\n    col += upick(tex, uv, res, vec2(-1, +1), r);\n    col += upick(tex, uv, res, vec2(+1, -1), r);\n    col += upick(tex, uv, res, vec2(+1, +1), r);\n\n    return col / 8.0;\n}\n\nvec4 kawase08(sampler2D tex, vec2 uv, vec2 res, float r) {\n    float u = 0.5;\n\n    vec4 col;\n\n    col += upick(tex, uv, res, vec2(0., +1), r);\n    col += upick(tex, uv, res, vec2(-1, 0.), r);\n    col += upick(tex, uv, res, vec2(+1, 0.), r);\n    col += upick(tex, uv, res, vec2(0., -1), r);\n\n    col += upick(tex, uv, res, vec2(-u, -u), r) * 2.0;\n    col += upick(tex, uv, res, vec2(-u, +u), r) * 2.0;\n    col += upick(tex, uv, res, vec2(+u, -u), r) * 2.0;\n    col += upick(tex, uv, res, vec2(+u, +u), r) * 2.0;\n\n    return col / 12.0;\n}\n\nvec4 uhex07(sampler2D tex, vec2 uv, vec2 res, float r) {\n    float u = 0.5;\n    float v = SQRT32;\n\n    vec4 col;\n\n    col += upick(tex, uv, res, vec2(+u, +v), r);\n    col += upick(tex, uv, res, vec2(+1, 0.), r);\n    col += upick(tex, uv, res, vec2(+u, -v), r);\n    col += upick(tex, uv, res, vec2(0., 0.), r);\n    col += upick(tex, uv, res, vec2(-u, -v), r);\n    col += upick(tex, uv, res, vec2(-1, 0.), r);\n    col += upick(tex, uv, res, vec2(-u, +v), r);\n\n    return col / 7.0;\n}\n\nvec4 ghex07(sampler2D tex, vec2 uv, vec2 res, float r) {\n    float s;\n\n    float u = 0.5;\n    float v = SQRT32;\n\n    vec4 col;\n\n    col += gpick(tex, uv, res, vec2(+u, +v), r, s);\n    col += gpick(tex, uv, res, vec2(+1, 0.), r, s);\n    col += gpick(tex, uv, res, vec2(+u, -v), r, s);\n    col += gpick(tex, uv, res, vec2(0., 0.), r, s);\n    col += gpick(tex, uv, res, vec2(-u, -v), r, s);\n    col += gpick(tex, uv, res, vec2(-1, 0.), r, s);\n    col += gpick(tex, uv, res, vec2(-u, +v), r, s);\n\n    return col / s;\n}\n\nvec4 uhex13(sampler2D tex, vec2 uv, vec2 res, float r) {\n    float u = 0.5;\n    float v = SQRT32;\n\n    float w = SQRT2 / (1.0 + SQRT3);\n    float x = w * 0.5;\n    float y = w * SQRT32;\n\n    vec4 col;\n\n    col += upick(tex, uv, res, vec2(+u, +v), r);\n    col += upick(tex, uv, res, vec2(+1, 0.), r);\n    col += upick(tex, uv, res, vec2(+u, -v), r);\n    col += upick(tex, uv, res, vec2(0., 0.), r);\n    col += upick(tex, uv, res, vec2(-u, -v), r);\n    col += upick(tex, uv, res, vec2(-1, 0.), r);\n    col += upick(tex, uv, res, vec2(-u, +v), r);\n\n    col += upick(tex, uv, res, vec2(+y, +x), r);\n    col += upick(tex, uv, res, vec2(0., +u), r);\n    col += upick(tex, uv, res, vec2(+y, -x), r);\n    col += upick(tex, uv, res, vec2(0., 0.), r);\n    col += upick(tex, uv, res, vec2(-y, -x), r);\n    col += upick(tex, uv, res, vec2(0., -u), r);\n    col += upick(tex, uv, res, vec2(-y, +x), r);\n\n    return col / 14.0;\n}\n\nvec4 ghex13(sampler2D tex, vec2 uv, vec2 res, float r) {\n    float s;\n\n    float u = 0.5;\n    float v = SQRT32;\n\n    float w = SQRT2 / (1.0 + SQRT3);\n    float x = w * 0.5;\n    float y = w * SQRT32;\n\n    vec4 col;\n\n    col += gpick(tex, uv, res, vec2(+u, +v), r, s);\n    col += gpick(tex, uv, res, vec2(+1, 0.), r, s);\n    col += gpick(tex, uv, res, vec2(+u, -v), r, s);\n    col += gpick(tex, uv, res, vec2(0., 0.), r, s);\n    col += gpick(tex, uv, res, vec2(-u, -v), r, s);\n    col += gpick(tex, uv, res, vec2(-1, 0.), r, s);\n    col += gpick(tex, uv, res, vec2(-u, +v), r, s);\n\n    col += gpick(tex, uv, res, vec2(+y, +x), r, s);\n    col += gpick(tex, uv, res, vec2(0., +u), r, s);\n    col += gpick(tex, uv, res, vec2(+y, -x), r, s);\n    col += gpick(tex, uv, res, vec2(0., 0.), r, s);\n    col += gpick(tex, uv, res, vec2(-y, -x), r, s);\n    col += gpick(tex, uv, res, vec2(0., -u), r, s);\n    col += gpick(tex, uv, res, vec2(-y, +x), r, s);\n\n    return col / s;\n}\n\nvec4 urandomxx(sampler2D tex, vec2 uv, vec2 res, float r, int i) {\n    float s = float(i);\n    float state = seed(uv);\n\n    vec4 col;\n\n    for (; i > 0; i--) {\n        col += upick(tex, uv, res, crand, r);\n    }\n\n    return col / s;\n}\n\nvec4 grandomxx(sampler2D tex, vec2 uv, vec2 res, float r, int i) {\n    float s;\n    float state = seed(uv);\n\n    vec4 col;\n\n    for (; i > 0; i--) {\n        col += gpick(tex, uv, res, grand, r, s);\n    }\n\n    return col / s;\n}\n\nvec4 upick(sampler2D tex, vec2 uv, vec2 res, vec2 o, float r) {\n    return texture(tex, uv + o * r / res);\n}\n\nvec4 gpick(sampler2D tex, vec2 uv, vec2 res, vec2 o, float r, inout float v) {\n    o *= r;\n\n    // https://dsp.stackexchange.com/a/74157\n    float n = r + r;\n    float s = n / 2.0;\n    float t = 2.0 * s * s;\n    float w = exp(-(o.x * o.x + o.y * o.y) / t);\n\n    v += w;\n\n    return texture(tex, uv + o / res) * w;\n}\n\nvec2 bmt(vec2 u) {\n    float r = sqrt(-2.0 * log(u.x));\n    float t = PI2 * u.y;\n\n    return clamp(vec2(r * cos(t), r * sin(t)), -1.0, +1.0);\n}\n\n#define SEED 0.2434\n\nfloat next(float state) {\n    state = (34.0 * state + 1.0) * state;\n    state = state - floor(state * 0.0034602) * 289.0;\n\n    return state;\n}\n\nfloat seed(vec2 pos) {\n    vec3  m = vec3(pos, SEED) + vec3(1.0);\n    float state;\n\n    state = next(m.x) + m.y;\n    state = next(state) + m.z;\n    state = next(state);\n\n    return state;\n}\n\nfloat random(inout float state) {\n    float r = fract(state * 0.02439);\n\n    state = next(state);\n\n    return r;\n}\n\nvec2 crandom(inout float state) {\n    float a = rand * PI2;\n    float r = sqrt(rand);\n\n    return vec2(r * cos(a), r * sin(a));\n}\n\n#define tex iChannel0\n#define res iResolution.xy\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define u     20.0 // Grid unit\n#define ul    (u * 2.0)\n#define uxl   (u * 3.0)\n#define uxxl  (u * 4.0)\n#define uxxxl (u * 5.0)\n#define us    (u / 2.0)\n\n#define crop(x1, y1, x2, y2) float(p.x > x1 && p.x < x2 && p.y > y1 && p.y < y2)\n#define rad(d) (d * 0.0174533)\n\nvec4 mix(vec4 a, vec4 b, bool c) {\n    return mix(a, b, float(c));\n}\n\nfloat mix(float a, float b, bool c) {\n    return mix(a, b, float(c));\n}\n\nvec4 alpha(vec4 b, vec4 s) {\n    float t = b.a * (1.0 - s.a);\n    float a = s.a + t;\n\n    vec3 rgb = s.rgb * s.a + b.rgb * t;\n\n    return vec4(rgb, a);\n}\n\nfloat hsluv_from_linear(float x) {\n    return x <= 0.003 ? 13.0 * x : 1.055 * pow(x, 0.416) - 0.055;\n}\n\nvec3 hsluv(float h, float s, float l) {\n    const float[6] N = float[6](\n        /* [1, 1] :: 632260 * M[2] - 126452 * M[1] */ -120846.0,\n        /* [1, 2] :: 284517 * M[0] -  94839 * M[2] */ 969398.0,\n        /* [2, 1] :: 632260 * M[5] - 126452 * M[4] */ -210946.0,\n        /* [2, 2] :: 284517 * M[3] -  94839 * M[5] */ -279707.0,\n        /* [3, 1] :: 632260 * M[8] - 126452 * M[7] */ 694074.0,\n        /* [3, 2] :: 284517 * M[6] -  94839 * M[8] */ -84414.0\n    );\n\n    float hsin = sin(h);\n    float hcos = cos(h);\n\n    float a = l + 16.0;\n    float r;\n    float g;\n    float b = a / 116.0;\n\n    float c;\n    float d;\n    float e = 769860.0 * l;\n\n    int i;\n\n    a = a * a * a / 1560896.0;  //   a is sub1\n    a = a > 0.01 ? a : l / 903.0; // a is sub2\n\n    h = 3.402823466e+38;          // h is cmax\n\n    for (; i < 6; ) {\n        r = N[i++] * a;\n        g = N[i++] * a * hcos;\n\n        c = e * a / (r * hsin - g); //                      c is length\n        h = c >= 0.0 ? min(h, c) : h; //                    h is cmax\n\n        c = e * (a - 1.0) / ((r + 126452.0) * hsin - g); // c is length\n        h = c >= 0.0 ? min(h, c) : h; //                    h is cmax\n    }\n\n    h = h / 100.0 * s / (13.0 * l); //       h is c / (13 * l)\n\n    s = hcos * h + 0.19783; //               s is varU\n    h = 1.0 / (hsin * h + 0.4683); //        h is 1 / varV\n\n    l = l <= 8.0 ? l / 903.0 : b * b * b; // l is y\n    s = 9.0 * l * h * s / 4.0; //            s is x\n    h = 3.0 * l * h - s / 3.0 - 5.0 * l; //  h is z\n\n    r = hsluv_from_linear(+3.2410 * s + -1.5373 * l + -0.4986 * h);\n    g = hsluv_from_linear(-0.9692 * s + +1.8760 * l + +0.0416 * h);\n    b = hsluv_from_linear(+0.0556 * s + -0.2040 * l + +1.0570 * h);\n\n    return vec3(r, g, b);\n}\n\nvec3 hsl(int h, float s, float l) {\n    return hsluv(rad(float(h)), s * 100.0, l * 100.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    return hsluv(rad(h * 360.0), s * 100.0, l * 100.0);\n}\n\nvec4 draw_circle(vec3 c, vec2 p, float radius) {\n    return vec4(c, 1.0) * step(length(p), radius);\n}\n\nvec4 draw_stripes(vec3 c, float o, float size, float m) {\n    return vec4(c, 1.0) * mod(floor(o / size), m);\n}\n\nvec4 draw_checkerboard(vec3 c, float o, float p, float size) {\n    return vec4(c, 1.0) * float(mod(floor(o / size), 2.0) != mod(floor(p / size), 2.0));\n}\n\nvec4 testpattern(vec2 pos) {\n    vec2 uv = pos / res;\n    vec2 c  = res / 2.0; // center coordinates\n    vec2 p  = pos - c;   // point coordinates relative to center\n\n    vec4 ne_st = draw_stripes(hsl(uv.x, uv.y, 0.5), p.x + ul, uxxl, 2.0);\n    vec4 se_st = draw_stripes(hsl(150, 1.0, 0.3),   p.y + ul, uxxl, 2.0);\n    vec4 sw_st = draw_stripes(hsl(260, 1.0, 0.4),   p.y - ul, uxxl, 2.0);\n    vec4 nw_st = draw_stripes(hsl(180, 1.0, 0.6),   p.x,      us,   2.0);\n\n    vec4 nw_d0 = draw_circle(hsl(-10, 1.0, 0.5), p - vec2(-u * 7.7, u), us * 0.9);\n    vec4 nw_d1 = draw_circle(hsl( 30, 1.0, 0.5), p - vec2(-u * 5.7, u), us * 0.9);\n    vec4 nw_d2 = draw_circle(hsl( 60, 1.0, 0.5), p - vec2(-u * 3.7, u), us * 0.9);\n    vec4 nw_d3 = draw_circle(hsl(120, 1.0, 0.5), p - vec2(-u * 1.7, u), us * 0.9);\n    vec4 nw_d4 = draw_circle(hsl(270, 1.0, 0.5), p - vec2(-u * 0.0, 0), us * 1.0);\n\n    vec4 sw_cb = draw_checkerboard(hsl(uv.x * 2.0, 1.0 - uv.y, 0.5), p.x, p.y, ul);\n\n    vec4 col;\n\n    col = vec4(0, 0, 0, 1);\n\n    col = alpha(col, nw_st * crop(   -uxxxl,     -ul,       ul,     c.y));\n    col = alpha(col, nw_st * crop(-u * 15.0, u * 6.0, -u * 6.0, u * 8.5));\n    col = alpha(col, ne_st * crop(      0.0,     0.0,      c.x,     c.y));\n    col = alpha(col, se_st * crop(       ul,    -c.y,      c.x,     0.0));\n    col = alpha(col, sw_st * crop(-u * 10.0,    -c.y,      0.0,     -ul));\n    col = alpha(col, sw_cb * crop(-c.x,         -c.y, -u * 4.0,   -uxxl));\n\n    col = alpha(col, nw_d0);\n    col = alpha(col, nw_d1);\n    col = alpha(col, nw_d2);\n    col = alpha(col, nw_d3);\n    col = alpha(col, nw_d4);\n\n    col = clamp(col, 0.0, 1.0);\n\n    return col;\n}\n\nvoid mainImage(out vec4 col, in vec2 pos) {\n    col = testpattern(pos);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}