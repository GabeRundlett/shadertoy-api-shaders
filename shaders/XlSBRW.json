{
    "Shader": {
        "info": {
            "date": "1514685239",
            "description": "Inspired by UE4 Protostar demo and Liquid Carbon by Virgill.\nMouse enabled.\nTested on GTX970 at 1920x1200 on Chrome, Firefox and Opera.\n\nFeel free to feedback how to improve performance and code :)",
            "flags": 96,
            "hasliked": 0,
            "id": "XlSBRW",
            "likes": 147,
            "name": "Crystal Drops",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "metaballs",
                "dof",
                "bokeh",
                "chromatic",
                "aberration",
                "pulfrich",
                "sharpen",
                "multipass",
                "tonemaper",
                "klos"
            ],
            "usePreview": 0,
            "username": "spolsh",
            "viewed": 7764
        },
        "renderpass": [
            {
                "code": "// Crystal Drops\n// by Michal 'spolsh' Klos 2017\n\n// Works well with Pulfrich Effect:\n// https://en.wikipedia.org/wiki/Pulfrich_effect\n// https://www.youtube.com/watch?v=Q-v4LsbFc5c\n\n// comment line 5 in Buf A to animate camera endlessly\n\n#define R iResolution\n#define T iTime\n#define F gl_FragCoord\n#define M iMouse\n\n// uncomment to enable FPS counter \n// #define FPS_COUNTER\n\n//-----------------------------------------------------------------\n// Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\t\t\n\tif(vUV.x  < 0.0) return 0.0;\n\tif(vUV.y  < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n\telse if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n\telse if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt(const in vec2 uv, const in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0+ceil(log2(value)/log2(10.0));\n\tfloat digitID = floor(uv.x);\n\tif( digitID>0.0 && digitID<maxDigits )\n\t{\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n\t}\n\n\treturn res;\t\n}\n\nfloat nrand(vec2 n)\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvec3 filmGrainColor(vec2 uv, float offset)\n{ // by ma (lstGWn)\n    vec4 uvs;\n    uvs.xy = uv + vec2(offset, offset);\n    uvs.zw = uvs.xy + 0.5*vec2(1.0 / iResolution.x, 1.0 / iResolution.y);\n\n    uvs = fract(uvs * vec2(21.5932, 21.77156).xyxy);\n\n    vec2 shift = vec2(21.5351, 14.3137);\n    vec2 temp0 = uvs.xy + dot(uvs.yx, uvs.xy + shift);\n    vec2 temp1 = uvs.xw + dot(uvs.wx, uvs.xw + shift);\n    vec2 temp2 = uvs.zy + dot(uvs.yz, uvs.zy + shift);\n    vec2 temp3 = uvs.zw + dot(uvs.wz, uvs.zw + shift);\n\n    vec3 r = vec3(0.0, 0.0, 0.0);\n    r += fract(temp0.x * temp0.y * vec3(95.4337, 96.4337, 97.4337));\n    r += fract(temp1.x * temp1.y * vec3(95.4337, 96.4337, 97.4337));\n    r += fract(temp2.x * temp2.y * vec3(95.4337, 96.4337, 97.4337));\n    r += fract(temp3.x * temp3.y * vec3(95.4337, 96.4337, 97.4337));\n\n    return r * 0.25;\n}\n\nvec2 barrelDistortion(vec2 coord, float amt, float zoom)\n{ // based on gtoledo3 (XslGz8)\n  // added zoomimg\n\tvec2 cc = coord-0.5;\n    vec2 p = cc*zoom;\n    coord = p+0.5;\n\tfloat dist = dot(cc, cc);\n\treturn coord +cc*dist*amt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragColor = vec4(0.0);\n    vec2 uv = F.xy/R.xy;\n    vec2 vv = 2.0*(uv-0.5);\n    vv.x *= R.x/R.y;\n \n    float cas = step(abs(vv.y)*2.39,R.x/R.y);\n    if (cas<0.1) return;\n \n    vec3 c = texture(iChannel0, uv).rgb;   \n        \n    uv = barrelDistortion(uv, 0.1, 0.96);\n           \n    // chromatic abberation inspired by knifa (lsKSDz)\n    vec2 d = abs((uv-0.5)*2.0);    \n    d = pow(d, vec2(1.5, 1.0));\n    d.y *= 0.1;\n    \n    float dScale = 0.01;\n    const int maxSamples = 4;\n    vec4 r, g, b;\n    r = g = b = vec4(0.0);\n    for (int i=0; i<maxSamples; ++i)\n    {\n        float rnd = nrand(uv+vec2(i)+0.001*T);\n    \tr += texture(iChannel0, uv +d*rnd*dScale);\n    \tg += texture(iChannel0, uv);\n    \tb += texture(iChannel0, uv -d*rnd*dScale);\n\t}\n    \n    c = vec3(r.r, g.g, b.b)/vec3(maxSamples);\n    \n    c *= 1.0 -0.25*filmGrainColor(0.5*uv, T).rgb;\n    \n    c = pow(c, vec3(0.4545));\n    \n    vec2 v = 2.*(uv-.5);\n    v.y *= 2.39 * R.y/R.x;\n    v = clamp((v*.5)+.5, 0., 1.);\n    // c.rgb = vec3(1.0); // uncomment to see only vignette\n    c *= 0.25 + 0.75*pow( 16.0*v.x*v.y*(1.0-v.x)*(1.0-v.y), 0.25);\n    \n#ifdef FPS_COUNTER    \n    vec2 h = F.xy/R.xy; \n    h.x *= R.x / R.y;\n    c += PrintInt( (h -vec2(0.0,0.21))*30.0, iFrameRate );\n#endif \n    \n    fragColor = vec4(c, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 12964,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/hybridminds/hybrid-minds-meant-to-be?in=shaniithebunny/sets/liqud"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Crystal Drops\n// by Michal 'spolsh' Klos 2017\n\n// comment to animate camera endlessly\n// #define SLOMO_LOOP\n\n#define R iResolution\n#define F gl_FragCoord\n#define M iMouse\n\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\nfloat T = 0.0;\n\nvec4 hash41(float p)\n{ // by Dave_Hoskins\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);    \n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{ // by iq\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat map(vec3 p)\n{\n    float s = length(p -vec3(0.0, .01*sin(8.0*T), 0.0)) - 0.5;\n\ts += 0.005*sin(45.0*p.x+10.0*T);\n    \n    for (int i=0; i<12; ++i) {\n        vec4 rnd = hash41(100.0+float(i));        \n        vec3 rndPos = 2.0*(normalize(rnd.xyz) -vec3(0.5));\n        rndPos.y *= 0.2;\n        float timeOffset = rnd.w;\n        float phase = fract(timeOffset -0.25*T);\n\t\tvec3 offset = mix( 0.1*rndPos, 15.0*rndPos, phase);\n        float rnd2 = fract(rnd.x +rnd.y);\n        float s0 = length(p +offset) -0.25*mix(0.8 +0.2*rnd2, 0.2 +0.8*rnd2, phase);\n        s = smin(s, s0, 0.4);\n    }\n\n    s += 0.002*sin(20.0*p.x +10.0*T);\n        \n    return s;    \n}\n\nvec3 env(vec3 dir) \n{\n    vec3 cubemap = texture(iChannel0, dir).rgb;\n    float ex = mix(6.0, 12.0, 0.5*(sin(0.5*T) +1.0));\n    float t0 = 0.05*pow(1.0 -dot(vec3(0.0, -1.0, 0.0), dir), ex);\n    float t1 = mix(0.2, 2.5, 1.0 -abs(sin(2.0*3.14*dir.y)));    \n    vec3 c = cubemap *t0 *t1;\n    return c * vec3(0.35, 1.2, 2.5);\n}\n\nvec3 calcNormal(vec3 p)\n{ // by iq\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n\treturn normalize(\te.xyy *map(p + e.xyy) + \n\t\t\t\t\t\te.yxy *map(p + e.yxy) + \t\t\t\t\t  \n\t\t\t\t\t\te.yyx *map(p + e.yyx) + \t\t\t\t\t  \n\t\t\t\t  \t  \te.xxx *map(p + e.xxx) );\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{ // by iq\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n    return mat3(cu, cv, cw);\n}\n\nvec3 tonemapping(vec3 color)\n{ // by Zavie (lslGzl)\n\tcolor = max(vec3(0.), color-vec3(0.004));\n\tcolor = (color * (6.2*color+.5))/(color*(6.2*color+1.7)+0.06);\n\treturn color;\n}\n\nfloat spline(float x, float x1, float x2, float y1, float dy1, float y2, float dy2)\n{\n\tfloat t = (x -x1) / (x2 -x1);\t\n    float a = 2.0*y1 -2.0*y2 +dy1 +dy2;\n\tfloat b = -3.0*y1 +3.0*y2 -2.0*dy1 -dy2;\n\tfloat c = dy1;\n\tfloat d = y1;\n\tfloat t2 = t*t;\n\tfloat t3 = t2*t;\n\treturn a * t3 +b*t2 +c*t +d;\n}\n\nvoid calcTime()\n{\n    T = iTime;\n#ifdef SLOMO_LOOP\n    // slomo by Dave (4s23RW)\n    T = mod(iTime, 20.0);\n\tconst float slomoMin = 2.3;\n\tconst float slomoMax = 2.6;\n\tconst float slomoK = 0.2;\n\tconst float slomoDuration = (slomoMax-slomoMin)/slomoK;\n\tif (T >= slomoMin && T<slomoMin+slomoDuration)\n\t\tT = spline(T, slomoMin, slomoMin+slomoDuration, slomoMin, slomoDuration*0.3, slomoMax, slomoDuration*0.15);\n\telse if ( T >= slomoMin+slomoDuration)\n\t\tT = T -slomoDuration +(slomoMax-slomoMin);\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragColor = vec4(0,0,0,1);\n    \n    calcTime();\n        \n    vec2 u = F.xy/R.xy;\n    vec2 v = 2.0*(u -0.5);\n    v.x *= R.x/R.y;\n    vec2 m = M.xy/R.xy;\n    float cas = step(abs(v.y)*2.39,R.x/R.y);\n    if (cas<0.1) return;\n        \n\tvec3 ro = vec3(\n        8.0*cos(0.2*T +6.0*m.x),\n        2.0*mix(-1.0,1.0, m.y),\n        8.0*sin(0.2*T +6.0*m.x)\n    );\n    float taAnim = 2.0*(smoothstep(-0.1, 0.1, sin(0.1*T)) -0.5);\n\tvec3 ta = vec3(taAnim, -0.05, 0.0);\n\t\t\n    mat3 ca = setCamera(ro, ta, 0.0);\n    vec3 rd = ca * normalize(vec3(v, mix(4.5, 5.0, taAnim)));    \n    vec3 p, c;\n    vec3 n, rl, rr;\n    p = vec3(0.0);\n    c = env(rd);\n    \n    float t, d, a;\n    t = d = a = 0.0;\n    for(int i=0; i<50; ++i) {\n        t+=(d=map(p=ro+rd*t));\n        if (d<0.01) {\n            break;\n        }                \n    }\n    \n    float depth = length(p-ro);\n    \n    if (t<25.0) { // if hit scene\n        \n    \tn = calcNormal(p);\n\t    rl = reflect(rd, n);\n\t    rr = refract(rd, n, .19);\n    \n        for(int i=0; i<25; ++i) {\n            d = map(p=ro+rd*t);\n            a += step(d, 0.008) *0.005;\n            t += 0.02;\n    \t}\n        \n        a = exp(-a*25.0);\n        c = env(mix(rr, rl, a));\n\t\t// c = vec3(a); // uncomment to see absorbtion mask\n        c *= mix(vec3(1.4, 1.0, 0.9), vec3(1.0), clamp(0.2*length(p), 0.0, 1.0)); // value        \n        c *= mix(vec3(1.5), vec3(.3), clamp(pow(0.1*depth, 2.0), 0.0, 1.0)); // fogging\n    }\n              \n    c = tonemapping(c);\n    \n    depth = 0.01*dot(rd, p-ro); // depth paraller to camera\n\tfragColor = vec4(c, depth);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Crystal Drops\n// by Michal 'spolsh' Klos 2017\n\n#define R iResolution\n#define T iTime\n#define F gl_FragCoord\n\nvec3 sharpen()\n{ // by NickWest (lslGRr)\n    vec2 uv = F.xy/R.xy;\n  \tvec2 step = 1.0/iResolution.xy;\n    float scale = 1.5;\n\tvec3 texA = texture(iChannel0, uv + vec2(-step.x, -step.y) * scale).rgb;\n\tvec3 texB = texture(iChannel0, uv + vec2( step.x, -step.y) * scale).rgb;\n\tvec3 texC = texture(iChannel0, uv + vec2(-step.x,  step.y) * scale).rgb;\n\tvec3 texD = texture(iChannel0, uv + vec2( step.x,  step.y) * scale).rgb;   \n    vec3 around = 0.25 *(texA+texB+texC+texD);\n\tvec3 center = texture(iChannel0, uv).rgb;\n\tvec3 col = center +(center-around)*1.0;\n    return col;\n}\n\nfloat depthToMask(float d)\n{\n\td *= 100.0;\n    d = abs(d -8.5);\n    d = pow(d, 6.0);\n    d = clamp(d, 0.0, 1.0);    \n    return d;\n}\n\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\n\nvec4 bokeh(vec2 uv, float rad)\n{ // based on dof by Jochen \"Virgill\" Feldkötter, Alcatraz / Rhodium 4k Intro liquid carbon\n  // simplyfied version of Dave Hoskins blur\n  // now bokeh is not cut within dof mask, added alpha blending based on difference of dof mask samples\n    const float GA =2.399; \n\tconst mat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n\tvec4 acc = vec4(texture(iChannel0,uv).rgb, rad);\n    float d = rad;\n    vec2 pixel=0.0002*vec2(5.*R.y/R.x,7.);\n\tvec2 angle=vec2(0,rad);\n\tfor (int j=0;j<80;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        vec2 tap_uv = uv+pixel*(rad-1.)*angle;\n        if (abs(tap_uv.y*2.-1.) > 0.743) continue; // fix letterbox artifacts\n        vec4 col=texture(iChannel0, tap_uv);\n      \tacc.rgb = max(acc.rgb,col.rgb);\n        acc.a = max(acc.a, abs(d-depthToMask(col.w)));\n\t}\n\treturn acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{      \n    vec2 uv = F.xy/R.xy;    \n    vec2 v = 2.0*(uv-0.5);\n    v.x *= R.x/R.y;\n        \n    float cas = step(abs(v.y)*2.39,R.x/R.y);\n    if (cas<0.1) return;\n         \n    float d = depthToMask(texture(iChannel0, uv).w);\n    // fragColor = vec4(d); return; // uncomment to see dof mask\n    \n    vec3 sharp = sharpen();   \n\tvec4 dof = bokeh(uv, d);\n    fragColor = vec4(mix(sharp, dof.rgb, dof.a), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}