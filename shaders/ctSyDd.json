{
    "Shader": {
        "info": {
            "date": "1692405217",
            "description": "A tool to help compare the performance of various functions! See common tab for instructions on how to use this shader. \n\nScore means the number of function calls possible per pixel, maintaining 50 fps. Bonus: Fully functional in thumbnail!",
            "flags": 32,
            "hasliked": 0,
            "id": "ctSyDd",
            "likes": 6,
            "name": "GLSL Function Profiler",
            "published": 3,
            "tags": [
                "utility",
                "debug",
                "tool"
            ],
            "usePreview": 0,
            "username": "01000001",
            "viewed": 149
        },
        "renderpass": [
            {
                "code": "\n\n\n\n\n        // See Common for instructions on how to use.\n\n\n\n\n// Thanks to https://www.shadertoy.com/view/4sBfRd\n#define C(c) O+= char(U,c).x; U.x-=.45;\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nvoid mainImage( out vec4 O, in vec2 U ){\n    O = texture(iChannel0, U/iResolution.xy);\n    \n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    float x;\n    \n    \n    \n    \n    //// OVERLAYS ////\n    \n    // You can change these values as you please to move \n    // the white markers. They are useful to compare results\n    // The higher the blue bar, the better the performance\n    // of the function you're testing.\n    \n    x = .42;    \n\n    O += smoothstep(8./r.y, 0., abs(x-uv.y)) * (uv.x > .8?1.:0.);\n\n    x = .32;    \n\n    O += smoothstep(8./r.y, 0., abs(x-uv.y)) * (uv.x > .8?1.:0.);\n\n    x = .8;    \n\n    O += smoothstep(8./r.y, 0., abs(x-uv.y)) * (uv.x > .8?1.:0.);\n    \n    \n    \n    // This displays the number of function calls\n    \n    U = U/iResolution.y * 8.;\n    float s = texture(iChannel0, r-r).x;\n    for (float i = 7.; i >= 0.; i--){\n        C(48 + int(s / pow(10., i))%10);\n    }\n    \n    U.x += 3.4;\n    U.y -= .8;\n    U *= 2.;\n    C(64+19);C(96+3);C(96+15);C(96+18);C(96+5);C(58);\n    \n    if (texture(iChannel0, r-r).z > averagingTime) O = O.xzyw;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = (2.*U-r)/r.y;\n    int samples = 1;\n    \n    vec4 data = texture(iChannel0, r-r);\n        \n    O = vec4(0); // Initialize stuff for safety\n    if (iFrame < 20){\n        return;\n    } else { \n        samples = int(data.x); // Only read if we're fairly sure it's initialized\n    }\n    \n    if (U == vec2(.5)){\n    \n        O.x = max(100., data.x) * (iFrameRate > 50.?1.01:0.99);\n        O.z = max(1., data.z);\n        \n        if (iFrameRate < 50. || O.z > 50.){ // Start tracking average samples once you hit the limit\n\n            if (O.z > averagingTime){\n                O.xy = data.yy;\n                // Once we've been past the limit for a while, stop adjustments.\n            } else {\n                O.y = mix(data.y, O.x, 1e-3 + 1./O.z);\n                O.z ++;\n            }\n            \n        }\n\n        return;\n    }\n    \n    if (data.z > averagingTime){\n        // And decrease this shader's contribution to the heat death of the universe\n        O = texture(iChannel0, U/r);\n        return;\n    }\n        \n    for (int i = 0; i < samples; i++){\n        uvec3 h = uvec3(iFrame + i, int(U.x) - i, int(U.y) + i);\n        // Required for hash input\n        \n        \n        ////// Here you may do whatever visualization you wish. \n        // It is not necessary, but it can be nice to see that\n        // it's actually working! If you rewrite this make sure\n        // that you call a() and that a() is not empty otherwise\n        // chaos ~~may~~ will ensue.\n        \n        vec2 b = vec2(.5);\n        vec2 result = a(h, b);\n        \n        \n\n        O.x += smoothstep(4./r.y, 0., length(result-uv));\n        \n        \n        \n    }\n    \n    \n\n    O.z = smoothstep(0., 1./r.y, data.y*c-U.y/r.y);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This shader allows you to compare the performance of functions\n// easily, I hope :D.  The shader will automatically adjust the\n// number of function calls per pixel, attempting to stabilize the\n// framerate around 50 fps. Once it is relatively stable, it will\n// stop tweaking the performance, and you can log the result. \n\n// The number of calls per pixel is displayed in the corner.\n// The blue line is purely visual, and can be removed if you want.\n// The blue line will turn green once the shader has reached its decision.\n// The time taken to find the equilibrium can be adjusted below, in\n// float averagingTime. Larger is more accurate, but takes longer.\n\n// Please note, the purpose of this shader is only to compare the \n// performance of functions. There is no absolute measurement, \n// only relative.\n\n\n\n\n\n/////////////////////////////////////////\n///////////// CONTROL PANEL /////////////\n/////////////////////////////////////////\n\n\n// the function a() at the bottom is where you place your functions to test.\n// Any visualizations may be placed inside the block at line 60 in Buffer A.\n\n// A hash function is provided to make it easy to test with random values\n// A circle sample function is also provided. Samples a circle of radius 1\n// A square sample function is also provided. Samples a square of width  1\n\n\n// You may need to adjust the coefficient below to suit the performance\n// of your function. If the entire screen goes blue, decrease. If the line\n// is very close to the bottom of the screen, adjust as needed.\nfloat c = 2e-3;\n\n\n// The amount of time the shader spends trying to find the perfect value\n// after it begins oscillating around the eqilibrium.\nfloat averagingTime = 500.;\n\n\n\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\nvec2 circleSample(uvec3 x){\n    vec2 v;\n    for(v=hash(x+uint(v*1e9)).xy*2.-1.;\n        dot(v,v)<1.;)\n    return v;\n}\nvec2 squareSample(uvec3 x){\n    return hash(x).xy*2.-1.;\n}\n\n\n\n\n\n\n\n\nvec2 cloBox( in vec2 p, in vec2 b )\n{\n    vec2   s = sign(p);\n    vec2   w = abs(p) - b;\n    float  g = max(w.x,w.y);\n    float  m = min(0.0,g);\n    return p - vec2(w.x>=m?w.x:0.0,w.y>=m?w.y:0.0)*s;\n}\n\n\n// distance to box\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    float g = max(w.x,w.y);\n    return (g>0.0)?length(max(w,0.0)):g;\n}\n\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .yz = ∇f(p) with ‖∇f(p)‖ = 1\nvec3 sdgBox( in vec2 p, in vec2 b, float ra )\n{\n    vec2 w = abs(p)-(b-ra);\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    \n    float g = max(w.x,w.y);\n\tvec2  q = max(w,0.0);\n    float l = length(q);\n    \n    return vec3(   (g>0.0)?l-ra: g-ra,\n                s*((g>0.0)?q/l : ((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\n\n\n\n\n\nvec2 a(uvec3 x, vec2 b){\n    vec2 p = circleSample(x).xy * 5.;\n    \n    // Below is a comment trick I often use. \n    // Remove one slash from the line below to toggle between the blocks\n    //*\n    return cloBox(p, b);\n    /*/\n    return p - sdgBox(p, b, 0.).yz * sdBox(p, b);\n    //*/\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}