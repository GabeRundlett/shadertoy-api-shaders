{
    "Shader": {
        "info": {
            "date": "1695419620",
            "description": "Wrapping an explicit Bezier Rectangle around a sphere in polar coordinates.  Raytracing the bounding sphere, raymarching the intererior.",
            "flags": 0,
            "hasliked": 0,
            "id": "MtfXRj",
            "likes": 10,
            "name": "Quadratic Bezier Sphere",
            "published": 3,
            "tags": [
                "3d",
                "bezier",
                "polar"
            ],
            "usePreview": 0,
            "username": "demofox",
            "viewed": 227
        },
        "renderpass": [
            {
                "code": "/*\n\nTODO:\n\n* fix NormalAtPos\n* make it work\n\n* make control points have good animation\n* make camera have good animation\n\n* can we make the grid more uniform by using this? https://www.shadertoy.com/view/ltl3D8\n\n* why calculate pos once outside the loop then again immediately inside the loop?\n\n* figure out a way to get a better time value when intersection found.\n\n* try to understand meaning of theta and phi and get intuition for why this works how it does\n\n* blog post\n\n*/\n\nconst float c_pi = 3.14159265359;\nconst float c_twoPi = c_pi * 2.0;\n\n#if 0\n\nfloat anim = sin(iTime) * 0.5 + 0.5;\n\nfloat CP00 = 1.0;\nfloat CP01 = 1.0;\nfloat CP02 = 1.0;\n\nfloat CP10 = 1.0;\nfloat CP11 = anim;\nfloat CP12 = 1.0;\n\nfloat CP20 = 1.0;\nfloat CP21 = 1.0;\nfloat CP22 = 1.0;\n\n#else\n\n#define CP00 (sin(iTime*0.3) * 0.5 + 0.5)\n#define CP01 (sin(iTime*0.1) * 0.5 + 0.5)\n#define CP02 (sin(iTime*0.7) * 0.5 + 0.5)\n\n#define CP10 (sin(iTime*0.2) * 0.5 + 0.5)\n#define CP11 (sin(iTime*0.4) * 0.5 + 0.5)\n#define CP12 (sin(iTime*0.8) * 0.5 + 0.5)\n\n#define CP20 (sin(iTime*0.5) * 0.5 + 0.5)\n#define CP21 (sin(iTime*0.9) * 0.5 + 0.5)\n#define CP22 (sin(iTime*0.6) * 0.5 + 0.5)\n\n#endif\n\n#define FLT_MAX 3.402823466e+38\n\n//=======================================================================================\nvec3 SphericalToCartesian (float theta, float phi, float radius)\n{    \n    return vec3(\n        sin(phi) * cos(theta) * radius,\n        sin(phi) * sin(theta) * radius,\n        cos(phi) * radius\n    );\n}\n\n//=======================================================================================\nvec3 CartesianToSpherical (vec3 p)\n{   \n    float radius = length(p);\n    float theta = atan(p.y, p.x);\n    float phi = atan(length(p.xy), p.z);\n    return vec3(theta, phi, radius);\n}\n\n\n//=======================================================================================\nfloat QuadraticBezier (float A, float B, float C, float t)\n{\n    float s = 1.0 - t;\n    float s2 = s * s;\n    float t2 = t * t;\n    \n    return A*s2 + B*2.0*s*t + C*t2;\n}\n\n\n//=======================================================================================\nfloat DistanceAtPos(vec3 P)\n{\n    vec3 spherical = CartesianToSpherical(P);\n        \n\tfloat theta = spherical.x;  //-pi, +pi\n    float phi = spherical.y;    //-pi, +pi\n    float radius = spherical.z;\n    \n    // normalize each angle to a [0,1] value\n    theta = theta / (c_twoPi);\n    if (theta < 0.0)\n        theta += 1.0;  \n    \n    phi = phi / (c_twoPi);\n    if (phi < 0.0)\n        phi += 1.0;\n    \n    /*\n    if (theta > 0.45)\n        return 0.8;\n    else\n        return 0.5;\n    */\n    \n    // make the bezier surface\n    float CP0X = QuadraticBezier(CP00, CP01, CP02, theta);\n    float CP1X = QuadraticBezier(CP10, CP11, CP12, theta);\n    float CP2X = QuadraticBezier(CP20, CP21, CP22, theta);\n    \n    return QuadraticBezier(CP0X, CP1X,CP2X, phi);\n}\n\n//=======================================================================================\nvec3 NormalAtPos( vec3 p )\n{\n    /*\n\tfloat eps = 0.01;\n    vec3 n = vec3( HeightAtPos(vec2(p.x-eps,p.y)) - HeightAtPos(vec2(p.x+eps,p.y)),\n                         2.0*eps,\n                         HeightAtPos(vec2(p.x,p.y-eps)) - HeightAtPos(vec2(p.x,p.y+eps)));\n    return normalize( n );\n*/\n    \n    return normalize(p);\n}\n\n//=======================================================================================\nbool RayIntersectAABox (vec3 boxMin, vec3 boxMax, in vec3 rayPos, in vec3 rayDir, out vec2 time)\n{\n\tvec3 roo = rayPos - (boxMin+boxMax)*0.5;\n    vec3 rad = (boxMax - boxMin)*0.5;\n\n    vec3 m = 1.0/rayDir;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    time = vec2( max( max( t1.x, t1.y ), t1.z ),\n                 min( min( t2.x, t2.y ), t2.z ) );\n\t\n    return time.y>time.x && time.y>0.0;\n}\n\n//=======================================================================================\nbool RayIntersectSphere (vec4 sphere, in vec3 rayPos, in vec3 rayDir, out vec2 time)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n\n\t//ray now found to intersect sphere, find and set the two collision times\n\tfloat collisionTime1 = -b - sqrt(discr);\n\tfloat collisionTime2 = -b + sqrt(discr);\n    \n    time = vec2( min(collisionTime1, collisionTime2),\n                 max(collisionTime1, collisionTime2));\n    \n    return time.y>time.x && time.y>0.0;\n}\n\n//=======================================================================================\nvec3 DiffuseColor (in vec3 pos)\n{\n    float radius = length(pos);\n\tfloat theta = atan(pos.y, pos.x);\n    float phi = acos(pos.z / radius);   \n    \n    // normalize each angle to a [0,1] value\n    theta = theta / (c_twoPi) + 0.5;\n    phi = phi / c_pi;    \n    \n\tbool whiteSquare = true;\n\n    if (mod(theta*26.0, 2.0) < 1.0)\n\t\twhiteSquare = !whiteSquare;\n\n\tif (mod(phi*26.0, 2.0) < 1.0)\n\t\twhiteSquare = !whiteSquare;\t\n    \n    return vec3(whiteSquare ? 1.0 : 0.4);\n}\n\n//=======================================================================================\nvec3 ShadePoint (in vec3 pos, in vec3 rayDir, float time)\n{\n\tvec3 diffuseColor = DiffuseColor(pos);\n\tvec3 reverseLightDir = normalize(vec3(1.0,1.0,-1.0));\n\tvec3 lightColor = vec3(0.95,0.95,0.95);\t\n\tvec3 ambientColor = vec3(0.05,0.05,0.05);\n\n\tvec3 normal = NormalAtPos(pos);\n\n    // diffuse\n\tvec3 color = diffuseColor * ambientColor;\n\tfloat dp = dot(normal, reverseLightDir);\n\tif(dp > 0.0)\n\t\tcolor += (diffuseColor * dp * lightColor);\n\n    // specular\n    vec3 reflection = reflect(reverseLightDir, normal);\n    dp = dot(rayDir, reflection);\n    if (dp > 0.0)\n        color += pow(dp, 15.0) * vec3(0.5);\t\n    \n    // reflection (environment mappping)\n    reflection = reflect(rayDir, normal);\n    color += texture(iChannel0, reflection).rgb * 0.25;\n    \n    return color;\n}\n\n//=======================================================================================\nvec3 HandleRay (in vec3 rayPos, in vec3 rayDir, in vec3 pixelColor, out float hitTime)\n{\n\tfloat time = 0.0;\n\tfloat lastHeight = 0.0;\n\tfloat lastY = 0.0;\n\tfloat height;\n\tbool hitFound = false;\n    hitTime = FLT_MAX;\n    \n    vec2 timeMinMax = vec2(0.0);\n    if (!RayIntersectSphere(vec4(0.0,0.0,0.0,1.0), rayPos, rayDir, timeMinMax))\n        return pixelColor;\n    \n    time = timeMinMax.x;\n    \n    const int c_numIters = 100;\n    float deltaT = (timeMinMax.y - timeMinMax.x) / float(c_numIters);\n    \n    vec3 pos = rayPos + rayDir * time;\n\tfor (int index = 0; index < c_numIters; ++index)\n\t{\t\t\n\t\tpos = rayPos + rayDir * time;\n        \n        height = DistanceAtPos(pos);\n        \n        float actualDist = length(pos);\n        \n        if (actualDist < height)\n        {\n        \thitFound = true;\n\t\t\tbreak;\n        }\n\t\t\n\t\ttime += deltaT;\t\t\n\t\tlastHeight = height;\n\t\tlastY = pos.y;\n\t}\n\t\n\tif (hitFound) {\n\t\t//time = time - deltaT + deltaT*(lastHeight-lastY)/(pos.y-lastY-height+lastHeight);\n\t\t//pos = rayPos + rayDir * time;\n\t\tpixelColor = ShadePoint(pos, rayDir, time);\n        hitTime = time;\n\t}\n    else {\n        pixelColor += vec3(0.2);\n    }\n    \n\treturn pixelColor;\n}\n\n//=======================================================================================\nvec3 HandleControlPoints (in vec3 rayPos, in vec3 rayDir, in vec3 pixelColor, inout float hitTime)\n{\n    float c_fullAngle = c_twoPi;\n    \n    vec2 cpHitTime;\n    if (RayIntersectSphere(vec4(SphericalToCartesian(0.0, 0.0, CP00), 0.01), rayPos, rayDir, cpHitTime) && cpHitTime.x < hitTime)\n    {\n        hitTime = cpHitTime.x;\n        pixelColor = vec3(1.0,0.0,0.0);\n    }\n    if (RayIntersectSphere(vec4(SphericalToCartesian(c_fullAngle / 2.0, 0.0, CP01), 0.01), rayPos, rayDir, cpHitTime) && cpHitTime.x < hitTime)\n    {\n        hitTime = cpHitTime.x;\n        pixelColor = vec3(1.0,0.0,0.0);\n    }    \n    if (RayIntersectSphere(vec4(SphericalToCartesian(c_fullAngle, 0.0, CP02), 0.01), rayPos, rayDir, cpHitTime) && cpHitTime.x < hitTime)\n    {\n        hitTime = cpHitTime.x;\n        pixelColor = vec3(1.0,0.0,0.0);\n    } \n    \n    \n    if (RayIntersectSphere(vec4(SphericalToCartesian(0.0, c_fullAngle / 4.0, CP10), 0.01), rayPos, rayDir, cpHitTime) && cpHitTime.x < hitTime)\n    {\n        hitTime = cpHitTime.x;\n        pixelColor = vec3(0.0,1.0,0.0);\n    }\n    if (RayIntersectSphere(vec4(SphericalToCartesian(c_fullAngle / 2.0, c_fullAngle / 4.0, CP11), 0.01), rayPos, rayDir, cpHitTime) && cpHitTime.x < hitTime)\n    {\n        hitTime = cpHitTime.x;\n        pixelColor = vec3(0.0,1.0,0.0);\n    }    \n    if (RayIntersectSphere(vec4(SphericalToCartesian(c_fullAngle, c_fullAngle / 4.0, CP12), 0.01), rayPos, rayDir, cpHitTime) && cpHitTime.x < hitTime)\n    {\n        hitTime = cpHitTime.x;\n        pixelColor = vec3(0.0,1.0,0.0);\n    }     \n    \n    \n    if (RayIntersectSphere(vec4(SphericalToCartesian(0.0, c_fullAngle / 2.0, CP20), 0.01), rayPos, rayDir, cpHitTime) && cpHitTime.x < hitTime)\n    {\n        hitTime = cpHitTime.x;\n        pixelColor = vec3(0.0,0.0,1.0);\n    }\n    if (RayIntersectSphere(vec4(SphericalToCartesian(c_fullAngle / 2.0, c_fullAngle / 2.0, CP21), 0.01), rayPos, rayDir, cpHitTime) && cpHitTime.x < hitTime)\n    {\n        hitTime = cpHitTime.x;\n        pixelColor = vec3(0.0,0.0,1.0);\n    }    \n    if (RayIntersectSphere(vec4(SphericalToCartesian(c_fullAngle, c_fullAngle / 2.0, CP22), 0.01), rayPos, rayDir, cpHitTime) && cpHitTime.x < hitTime)\n    {\n        hitTime = cpHitTime.x;\n        pixelColor = vec3(0.0,0.0,1.0);\n    }     \n    \n    return pixelColor;\n}\n\n//=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\t\n    //----- camera\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.0;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 4.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\t\n\t\t\n\t// Objects\n\tvec2 rawPercent = (fragCoord.xy / iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\t\n\tvec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n\t\t\t\t   - (cameraLeft * percent.x * cameraViewWidth)\n\t\t           + (cameraUp * percent.y * cameraViewHeight);\n\tvec3 rayDir = normalize(rayTarget);\n\t\n\t\n    float hitTime = FLT_MAX;\n\tvec3 pixelColor = texture(iChannel0, rayDir).rgb;\n    pixelColor = HandleRay(cameraPos, rayDir, pixelColor, hitTime);\n    pixelColor = HandleControlPoints(cameraPos, rayDir, pixelColor, hitTime);\n    \n    fragColor = vec4(clamp(pixelColor,0.0,1.0), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}