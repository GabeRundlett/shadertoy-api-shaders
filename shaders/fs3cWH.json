{
    "Shader": {
        "info": {
            "date": "1654052631",
            "description": "title",
            "flags": 0,
            "hasliked": 0,
            "id": "fs3cWH",
            "likes": 1,
            "name": "Mickey Mouse Man",
            "published": 3,
            "tags": [
                "implicitsurfaceart"
            ],
            "usePreview": 0,
            "username": "avidixit27",
            "viewed": 171
        },
        "renderpass": [
            {
                "code": "float map(vec3 p, settings setts)\n{\n    return world_sdf(p, iTime, setts);\n}\n\n\nvec3 computeNormal(vec3 p, settings setts)\n{\n    float h = 1e-4;\n    float sdp = world_sdf(p, iTime, setts);\n    return normalize(vec3(world_sdf(p + vec3(h, 0, 0), iTime, setts) - sdp,\n                          world_sdf(p + vec3(0, h, 0), iTime, setts) - sdp,\n                          world_sdf(p + vec3(0, 0, h), iTime, setts) - sdp));\n\n    \n}\n\n\n///////////////////////////////////////////\n/////// SPHERE TRACING CODE HERE:\n///////////////////////////////////////////\n\nbool sphere_tracing(ray r,\n               \t\tint max_iter,\n               \t\tsettings setts,\n               \t\tout vec3 hit_loc,\n               \t\tout int iters)\n{\n    hit_loc = r.origin + r.direction * (-r.origin.y / r.direction.y);\n    iters = 1;\n    float t = 0.;\n    for (int i = 0; i < max_iter; i++) {\n        vec3 p = r.origin + t * r.direction;\n        float dist = world_sdf(p, iTime, setts);\n        if (dist < EPSILON) {\n            hit_loc = p;\n            iters = i;\n            return true;\n        }\n        \n        t += dist;\n        \n    }\n    \n    iters = max_iter;\n    return false;\n    \n}\n\n///////////////////////////////////////////\n\nvec3 shade(ray r, int iters, settings setts)\n{\n    vec3 p = r.origin;\n    vec3 d = r.direction;\n    \n    if (setts.shade_mode == GRID)\n    {\n    \tfloat res = 0.2;\n    \tfloat one = abs(mod(p.x, res) - res / 2.0);\n    \tfloat two = abs(mod(p.y, res) - res / 2.0);\n    \tfloat three = abs(mod(p.z, res) - res / 2.0);\n    \tfloat interp = min(one, min(two, three)) / res;\n        \n        return mix( vec3(0.2, 0.5, 1.0), vec3(0.1, 0.1, 0.1), smoothstep(0.0,0.05,abs(interp)) );\n    }\n    else if (setts.shade_mode == COST)\n    {\n        return vec3(float(iters) / float(cost_norm));\n    }\n    else if (setts.shade_mode == NORMAL)\n    {\n        vec3 normal = computeNormal(p, setts);\n        vec3 white = vec3(1., 1., 1.);\n        return (normal + white) / 2.;\n\n    }\n    else if (setts.shade_mode == DIFFUSE_POINT)\n    {\n        vec3 light_pos = vec3(0.0, 5.0, 0.0);\n        vec3 light_intensity = vec3(5.0);\n        vec3 surface_color = vec3(0.5);\n        \n        vec3 lightDirection = normalize(light_pos - p);\n        vec3 normal = computeNormal(p, setts);\n        vec3 Li = light_intensity / pow(distance(light_pos, p), 2.0);\n        return surface_color * max(0.0, dot(normal, lightDirection)) * Li;\n    }\n    else if (setts.shade_mode == ENVIRONMENT_MAP)\n    {\n        vec3 normal = computeNormal(p, setts);\n        vec3 reflection = reflect(d, normal);\n        //return vec3(texture(iChannel0, reflection));\n    }\n    else\n    {\n        return vec3(0.0);\n    }\n    \n    return vec3(0.0);\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// we will be replacing all of the code below with our own method(s). All of    //\n// the changes you make will be disgarded. But feel free to change the main     //\n// method to help debug your code.                                              //\n//////////////////////////////////////////////////////////////////////////////////\n\nvec3 render(settings setts, vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    //if (p.y < -0.95)\n    //{\n    //    float val = cos(iTime * anim_speed);\n     //   return shade_progress_bar(p, iResolution.xy, val);\n    //}\n    \n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= aspect;\n   \n    \n    // Rotate the camera\n    vec3 eye = vec3(-3, 0.5, 1.);\n    // vec3(-3.0*cos(iTime*0.2), 2.0 + 0.5*sin(iTime*0.1), -3.0*sin(iTime*0.2));\n    vec3 dir = vec3(0.0, 0.0, 0.0) - eye;\n    vec3 up = vec3(0, 1, 0);\n    \n    \n    float focal_length = 2.;\n    \n    vec3 u,v,w;\n    compute_camera_frame(dir, up, u, v, w);\n    \n    ray r;\n    switch(projection_func) {\n        case PROJECTION_ORTHOGRAPHIC:\n            r = generate_ray_orthographic(uv, eye, u, v, w);\n            break;\n     \n        case PROJECTION_PERSPECTIVE:\n            r = generate_ray_perspective(uv, eye, u, v, w, focal_length);\n            break;\n    }\n    \n    \n    int max_iter = 1000;\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 hit_loc;\n    int iters;\n    bool hit;\n    \n    if (sphere_tracing(r, max_iter, setts, hit_loc, iters))\n    {\n        r.origin = hit_loc;\n        col = shade(r, iters, setts);\n    }\n    \n\n    \n    return pow(col, vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(render(render_settings, fragCoord), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// pre-defined constants\n#define EPSILON 1e-4\n#define PI 3.1415926535897932384626433832795\n\n\n// shade mode\n#define GRID 0\n#define COST 1\n#define NORMAL 2\n#define AMBIENT 3\n#define DIFFUSE_POINT 4\n#define ENVIRONMENT_MAP 5\n\n\n//\n// Render Settings\n//\nstruct settings\n{\n    int shade_mode;\n};\n\nsettings render_settings = settings(DIFFUSE_POINT);\n\n\n\n//float anim_speed = 0.35;\nfloat anim_speed = 0.35;\nint cost_norm = 200;\n\nvec3 two_tone_color_a = vec3(0.6 * 1.0, 0.6 * 1.0, 0.0 * 1.0);\nvec3 two_tone_color_b = vec3(0.2 * 1.0, 0.1 * 1.0, 0.9 * 1.0);\n//vec3 two_tone_color_a = vec3(0.9,0.7,0.6);\n//vec3 two_tone_color_b = vec3(0.0);\nvec3 two_tone_dir = vec3(1.0, 1.0, 0.0);\n\n////////////////////////////////////////////////////\n// SDF evaluation code here:\n////////////////////////////////////////////////////\n\n// returns the signed distance to a sphere from position p\nfloat sdSphere(vec3 p, float r)\n{\n \treturn length(p) - r;\n}\n\n// returns the signed distance to a box from position p\nfloat sdBox( vec3 p, vec3 half_bounds )\n{\n    vec3 q = abs(p) - half_bounds;\n    float maxComponent = max(q.x, max(q.y, q.z));\n    return length(max(q, 0.)) + min(maxComponent, 0.);\n}\n\n// returns the signed distance to a cylinder from position p\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    float baMagnitudeSquared = dot(b-a,b-a);\n    float x = length((p - a) * baMagnitudeSquared - (b - a) * dot(p - a, b - a)) - r * baMagnitudeSquared;\n    float y = abs(dot(p - a, b - a) - baMagnitudeSquared * 0.5) - baMagnitudeSquared * 0.5;\n    float dist = 0.0;\n    \n    \n    if (max(x, y) < 0.0) {\n        dist = -min(x * x, y * y * baMagnitudeSquared);\n    } else {\n        \n        if (x > 0.0) {\n            x = x * x;\n        } else {\n            x = 0.0;\n        }\n    \n        if (y > 0.0) {\n            y = y * y * baMagnitudeSquared;\n        } else {\n            y = 0.0;\n        }\n        dist = x + y;\n    }\n    \n    \n    return sign(dist) * sqrt(abs(dist)) / baMagnitudeSquared;\n}\n\n// returns the signed distance to a cone from position p\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float tPrime = dot(p-a, b-a) / dot(b-a, b-a);\n    float x = sqrt(dot(p-a, p-a) - tPrime * tPrime * dot(b-a, b-a));\n    float ax = 0.0; \n    \n    if (tPrime < 0.5) {\n        ax = max(0.0, x-ra);\n    } else {\n        ax = max(0.0, x-rb);\n    }\n    \n    float ay = abs(tPrime - 0.5) - 0.5;\n    float k = (rb-ra) * (rb-ra) + dot(b-a,b-a);\n    float d = min(max(((rb-ra) * (x-ra) + tPrime * dot(b-a,b-a)) / k, 0.0), 1.0);\n    float bx = x-ra - d * (rb-ra);\n    float by = tPrime - d;\n    float y = 0.0; \n    \n    if (bx < 0.0 && ay < 0.0) {\n        y = -1.0;\n    } else {\n        y = 1.0;\n    }\n    \n    return y * sqrt(min(ax*ax + ay*ay*dot(b-a,b-a), bx*bx + by*by*dot(b-a,b-a)));\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b)\n{\n    float tPrime = min(1., max( 0., dot(p-a, b-a) / dot(b-a, b-a)));\n    return length(p-a-(b-a)*tPrime);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k)\n{\n    float h = max(k - abs(d1 - d2), 0.0);\n    return min(d1, d2) - h * h / (4.0 * k);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = max(k - abs(d1 - d2), 0.0);\n    return max(d1, d2) + (h * h / (4.0 * k));\n}\n\nfloat opRound(float d, float iso)\n{\n    return d - iso;\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\n\n#define PROJECTION_ORTHOGRAPHIC 0\n#define PROJECTION_PERSPECTIVE  1\n\nint projection_func = PROJECTION_ORTHOGRAPHIC;\n\n////////////////////////////////////////////////////\n// Write up your ray generation code here:\n////////////////////////////////////////////////////\nstruct ray { \n    vec3 origin;\n    vec3 direction;\n};\n\n\n// TASK 2.1\nvoid compute_camera_frame(\n    vec3 dir, vec3 up,\n    out vec3 u, out vec3 v, out vec3 w ) {\n    \n    w = -dir / length(dir);\n    u = cross(up, w) / length(cross(up, w));\n    v = cross(w, u);\n\n}\n\n\n// TASK 2.2\nray generate_ray_orthographic(vec2 uv, vec3 e, vec3 u, vec3 v, vec3 w) {\n    return ray(vec3(e + uv.x * u + uv.y * v), vec3(-w));\n\n}\n\n// TASK 2.3\nray generate_ray_perspective(vec2 uv, vec3 eye, vec3 u, vec3 v, vec3 w, float focal_length) {\n    return ray(eye, normalize(vec3(-focal_length * w + uv.x * u + uv.y * v)));\n}\n////////////////////////////////////////////////////\n\n// returns the signed distance to an infinate plane with a specific y value\nfloat sdPlane(vec3 p, float z)\n{\n    return p.z - z;\n}\n\nfloat world_sdf(vec3 p, float time, settings setts)\n{\n    float dist = 100000.0;\n    \n    dist = sdPlane(p.xzy, -0.15);\n    \n       \n    dist = opSmoothUnion(dist, sdSphere(vec3(p.x+0.20, p.y, p.z), 0.20), 0.01);\n    \n    dist = opSmoothUnion(dist, sdSphere(vec3(p.x+0.20, p.y-0.2, p.z-0.1), 0.1), 0.01);\n    \n    dist = opSmoothUnion(dist, sdSphere(vec3(p.x+0.20, p.y-0.2, p.z+0.1), 0.1), 0.01);\n    \n    dist = opSmoothUnion(dist, sdSphere(vec3(p.x+0.20, p.y-0.2, p.z+0.1), 0.1), 0.01);\n    \n    dist = opSmoothUnion(dist, sdSphere(vec3(p.x+0.28, p.y-0.25, p.z+0.09), 0.02), 0.01);\n    \n    dist = opSmoothUnion(dist, sdSphere(vec3(p.x+0.28, p.y-0.25, p.z-0.08), 0.02), 0.01);\n    \n    dist = opSmoothUnion(dist, sdSphere(vec3(p.x+0.28, p.y-0.15, p.z), 0.05), 0.01);\n    \n    dist = opSmoothSubtraction(sdSphere(vec3(p.x+0.31, p.y-0.05, p.z-0.15), 0.02), dist , 0.01);\n    \n    dist = opSmoothSubtraction(sdSphere(vec3(p.x+0.33, p.y-0.03, p.z-0.13), 0.02), dist, 0.01);\n    \n    dist = opSmoothSubtraction(sdSphere(vec3(p.x+0.35, p.y-0.01, p.z-0.11), 0.02), dist, 0.01);\n    \n    dist = opSmoothSubtraction(sdSphere(vec3(p.x+0.37, p.y, p.z-0.08), 0.02), dist, 0.01);\n    \n    dist = opSmoothSubtraction(sdSphere(vec3(p.x+0.38, p.y+0.01, p.z-0.05), 0.02), dist, 0.01);\n    \n    \n\n    return dist;\n}\n\n\n// The animation which you see is of a 2D slice of a 3D object. The objects exist in [-1, 1] space\n// and the slice is continuously moved along z=[-1,1] using a cosine. This method renders what the\n// current z value is as a progress bar at the bottom of the animation for reference.\n//vec3 shade_progress_bar(vec2 p, vec2 res, float z)\n//{\n    // have to take account of the aspect ratio\n //   float xpos = p.x * res.y / res.x;\n    \n //   if (xpos > z - 0.01 && xpos < z + 0.01) return vec3(1.0);\n //   else return vec3(0.0);\n//}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}