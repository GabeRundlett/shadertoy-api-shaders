{
    "Shader": {
        "info": {
            "date": "1579297718",
            "description": "Another techy scene ",
            "flags": 0,
            "hasliked": 0,
            "id": "WtKGDw",
            "likes": 12,
            "name": "DataSphere",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "shau",
            "viewed": 385
        },
        "renderpass": [
            {
                "code": "// Created by SHAU - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define R iResolution.xy\n#define EPS 0.005\n#define FAR 50.0\n#define ZERO (min(iFrame,0))\n#define T iTime\n#define PI 3.141592\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n#define S(a, b, v) smoothstep(a, b, v)\n\n//Dave Hoskins - improved hash without sin\n//https://www.shadertoy.com/view/XdGfRR\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\nfloat hash12(vec2 p) \n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash11(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tuint q = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\n//noise IQ - Shane\nfloat n3D(vec3 p) \n{    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n//Nimitz\nfloat tri(float x) {return abs(x - floor(x) - 0.5);}\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//Shane - Perspex Web Lattice - one of my favourite shaders\n//https://www.shadertoy.com/view/Mld3Rn\n//Standard hue rotation formula... compacted down a bit.\nvec3 rotHue(vec3 p, float a)\n{\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr, 0., 1.);\n}\n\n//SDF functions - IQ\n//https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec3 p, vec3 b) \n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) \n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h) - r;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n/*\nvec3 opRepLim(vec3 p, float c, vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n*/\n\n//IQ - Intesectors, sphere and box functions\n//https://iquilezles.org/www/index.htm\nvec2 sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0); //missed\n    h = sqrt(h);\n    float tN = -b - h;\n    float tF = -b + h;\n    return vec2(tN, tF);\n}\n\nfloat sphDensity(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n\n    float ndbuffer = dbuffer / sph.w;\n    vec3  rc = (ro - sph.xyz) / sph.w;\n\n    float b = dot(rd, rc);\n    float c = dot(rc, rc) - 1.0;\n    float h = b * b - c;\n    if (h < 0.0) return 0.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if (t2 < 0.0 || t1 > ndbuffer) return 0.0;\n    t1 = max(t1, 0.0);\n    t2 = min(t2, ndbuffer);\n\n    float i1 = -(c * t1 + b * t1 * t1 + t1 * t1 * t1 / 3.0);\n    float i2 = -(c * t2 + b * t2 * t2 + t2 * t2 * t2 / 3.0);\n    return (i2 - i1) * (3.0 / 4.0);\n}\n\nvec3 sphNormal(vec3 pos, vec4 sph) \n{\n    return normalize(pos - sph.xyz);\n}\n\nvec2 boxes(vec3 p)\n{\n    p.z += T;\n    vec3 q = p;    \n    q.y = abs(q.y);\n    q.xz = fract(p.xz*0.125)*8.0 - 4.0;\n    return vec2(sdBox(q - vec3(0.0, 8.0, 0.0), vec3(3., 0.3, 3.0)), \n                hash12(floor(p.xz*0.125)));\n}\n\nvec4 map(vec3 p)\n{\n    vec2 b = boxes(p);\n    \n    /*\n    vec3 q = p;\n    q += vec3(-8.0, -0.0, 3.0);\n    float l = sin(p.x*3.0)*3.0 * min(1.0, p.x*0.08) * max(0.0, (1.0 - p.x*0.08));\n    q.xy *= rot(sin(p.x*2.0+T*1.2)*0.16);\n    q.xz *= rot(sin(p.x*2.0+T*2.8)*0.2);\n    q = opRepLim(q, 0.25, vec3(30.0, 0.0, 0.0));\n    q.yz *= rot(floor(p.x*4.0)*0.1+T*0.9);\n    float cs = sdCapsule(q, vec3(0.0, -1.0*l, 0.0), vec3(0.0, 1.0*l, 0.0), 0.02);\n    cs = max(cs, -sdSphere(p, 3.0));\n    //*/\n    \n    //capsule stream\n    //right\n    vec3 q = p;\n    q += vec3(0.0, -2.0, 2.0);\n    float l = sin(p.x*2.0)*3.0 * min(1.0, p.x*0.08) * max(0.0, (1.0 - p.x*0.08));  \n    q.xy *= rot(sin(p.x+T*1.2)*0.1);\n    q.xz *= rot(sin(p.x+T*0.8)*0.1);\n    q.x = fract(p.x*4.0)*0.25 - 0.125;\n    q.yz *= rot(floor(p.x*4.0)*0.1+T*0.9);\n    float cs = sdCapsule(q, vec3(0.0, -1.0*l, 0.0), vec3(0.0, 1.0*l, 0.0), 0.01);\n    cs = p.x>0.0 && p.x<20.6 ? cs : FAR;\n    //noise line\n    //left\n    q = p;\n    q.y += sin(q.x*2.0+T*6.)*0.2 + sin((q.x - 4.2)*3.2+T*13.3)*0.1;\n    q.z += sin((q.x - 1.3)*1.7+T*5.)*0.2 + sin((q.x - 5.9)*3.2+T*7.1)*0.14;\n\tq.yz += tri(q.x*0.31 + T*3.6)*0.2;\n\tq.xz += tri(q.x*0.7 + T*1.6)*0.8;\n    cs = min(cs, sdCapsule(q, vec3(-20.0, -7.0 + sin(T*0.4)*2.0, -4.0 + sin((T-3.1)*0.14)), vec3(0.0, -2.0, 0.0), 0.01));\n    //cutout\n    cs = max(cs, -sdSphere(p, 3.0));\n\n    return vec4(min(cs, b.x), cs, b.x, b.y);\n}\n\n// particles (Andrew Baldwin)\n// stolen from Galvanize by Virgill \nfloat snow(vec3 direction) {\n\tfloat help = 0.0;\n\tconst mat3 p = mat3(13.323122,23.5112,21.71123,21.1212,28.7312,11.9312,21.8112,14.7212,61.3934);\n\tvec2 uvx = vec2(direction.x,direction.z)+vec2(1.,iResolution.y/iResolution.x)*gl_FragCoord.xy / iResolution.xy;\n\tfloat acc = 0.0;\n\tfloat DEPTH = direction.y*direction.y-0.3;\n\tfloat WIDTH =0.1;\n\tfloat SPEED = 0.1;\n\tfor (int i=0;i<10;i++) {\n\t\tfloat fi = float(i);\n\t\tvec2 q = uvx*(1.+fi*DEPTH);\n\t\tq += vec2(q.y*(WIDTH*mod(fi*7.238917,1.)-WIDTH*.5),SPEED*iTime/(1.+fi*DEPTH*.03));\n\t\tvec3 n = vec3(floor(q),31.189+fi);\n\t\tvec3 m = floor(n)*.00001 + fract(n);\n\t\tvec3 mp = (31415.9+m)/fract(p*m);\n\t\tvec3 r = fract(mp);\n\t\tvec2 s = abs(mod(q,1.)-.5+.9*r.xy-.45);\n\t\tfloat d = .7*max(s.x-s.y,s.x+s.y)+max(s.x,s.y)-.01;\n\t\tfloat edge = .04;\n\t\tacc += smoothstep(edge,-edge,d)*(r.x/1.0);\n\t\thelp = acc;\n\t}\n\treturn help;\n}\n\n/*\nvec3 overlay(vec2 uv)\n{\n    vec2 ruv = uv*rot(sin(T*0.03));\n    ruv.x += (sin(ruv.y*4.0 + T*0.3) * 0.08);\n    vec2 c = fract(ruv*vec2(20.0, 12.0)) - 0.5;\n    float cH = hash12(floor(ruv*vec2(20.0, 12.0)));\n    \n    vec3 col = palette(cH*10000.) * S(0.16+cH*0.1, 0.1+cH*0.1, length(c)); //dots\n    //vignette\n    col *= S(0.0, 0.1, uv.x) * S(1.0, 0.9, uv.x) * \n           S(0.0, 0.1, uv.y) * S(1.0, 0.9, uv.y);\n    return col;\n}\n*/\n\n//background\nvec3 background(vec3 rd, vec3 colA, vec3 colB)\n{\n    //radial lines\n    float a = (atan(rd.x, rd.y)/6.2831853) + 0.5, //0->1\n          l = floor(a * 24.0) / 24.0; //partition cells    \n    vec3 pc = colB * 2.0 *\n              S(0.46, 0.5, fract(a*24.0)) * S(0.54, 0.5, fract(a*24.0));\n    //horizontal lines\n    float dY = pow(abs(rd.y), 0.8), //problem with power - thanks iapafotoo\n          cY = fract(dY*6.0-T*0.4),\n          cYID = floor(dY*6.0-T*0.4),\n          cYH = hash11(cYID) - 0.6,    \n          tt = mod(T*cYH*4.0*sign(rd.y), 3.0) - 1.5,\n          dX = length(tt - rd.x);\n    pc += colB * 1.6 * S(0.02, 0.0, length(cY - 0.5)); //lines\n    //noise\n    pc *= (2.0 +n3D(rd*3.6+T)) * n3D(rd*5.0+T*0.3);\n    //sparks\n    pc += (cYH*sign(-rd.y)>0.0 ? step(tt, rd.x) : step(rd.x, tt)) * //clip\n          colA * 6.0 * S(0.05, 0.0, length(cY - 0.5)) / //line \n          (1.0 + dX*dX*60.); //attenuation \n    //fade\n    pc *= max(abs(rd.y*0.4), 0.);\n    //center glow\n    pc += colB / ((1.0 + abs(rd.x)*abs(rd.x)*8.0) * (1.0 + dY*dY*100.0));\n\n    return pc;\n}\n\nvec4 renderScene(vec3 ro, vec3 rd, vec3 lp, vec3 colA, vec3 colB)\n{\n    float t = 0.0;\n    vec3 pc = background(rd, colA, colB); \n    \n    for (int i=ZERO; i<80; i++)\n    {\n        vec3 p = ro + rd*t;\n        vec4 ns = map(p);\n        //if (abs(ns.x)<EPS && ns.x==ns.y) break;\n        pc += 0.3 * colA / (1.0 + ns.y*ns.y*200.0);\n        float atn = 1.0 / (1.0 + length(p-ro)*length(p*ro)*0.0001);\n        pc += step(ns.z, EPS) * step(ns.w, 0.4) * //clip \n              0.008 * colB / (1.0 + ns.z*ns.z*30.0) * atn;\n        t += max(EPS*2.0, ns.x * 0.6);\n        if (t>FAR) break;\n    }    \n        \n    return vec4(pc, t);\n}\n\nvec3 camera(vec2 U, vec3 ro, vec3 la, float fl) \n{\n    vec2 uv = (U - R*.5) / R.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z, 0., -fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}\n\nvoid mainImage(out vec4 C, in vec2 U)\n{\n    vec3 col = vec3(0),\n         la = vec3(0),\n         colA = rotHue(vec3(1,0,0), T*0.1),\n         colB = rotHue(vec3(1,0,0), (T-3.0)*0.1),\n         ro = vec3(0.0, sin(T*0.1)*2.0, -11.0 - sin(T*0.2)*2.0);\n    \n    ro.xz *= rot(sin((T+5.0)*0.3)*0.3);\n    vec3 rd = camera(U, ro, la, 1.4);\n    vec3 lp = vec3(3.0, 4.0, -2.0);\n    \n\tvec4 scene = renderScene(ro, rd, lp, colA, colB);\n    col = scene.xyz;\n    \n    vec4 sph = vec4(0.0, 0.0, 0.0, 3.0);\n    vec2 si = sphIntersect(ro, rd, sph);\n    float sd = sphDensity(ro,rd, sph, FAR);\n    if (si.x>0.0)\n    {\n        \n        col *= scene.y==2.0 ? 0.0 : 0.4;\n        vec3 pN = ro + rd*si.x;\n        vec3 pF = ro + rd*si.y;\n        \n        vec3 nN = sphNormal(pN, sph);\n        vec3 nF = sphNormal(pF, sph) * -1.0;\n        \n        vec3 ldN = normalize(lp - pN);\n        vec3 ldF = normalize(lp - pF);\n        \n        float specN = pow(max(dot(reflect(-ldN, nN), -rd), 0.0), 16.0);\n        float specF = pow(max(dot(reflect(-ldF, nF), -rd), 0.0), 16.0);\n        float fres = pow(clamp(dot(nN, rd) + 1.0, 0.0, 1.0), 2.0);\n\n        col += colA * pow(sd, 4.0) * max(0.0, (sin(T*4.0)+0.5) * 0.6);\n        \n        col += vec3(1) * specN;  \n        col += vec3(1) * specF*0.2;  \n        \n        //reflection\n        vec3 rro = pN;\n        vec3 rrd = reflect(rd, nN);\n        vec4 rScene = renderScene(rro, rrd, lp, colA, colB);\n        col += rScene.xyz * fres;\n    }\n    \n    col += colA*2.0*snow(normalize(vec3(0.0, 0.0, -1.0)));\n    \n    C = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}