{
    "Shader": {
        "info": {
            "date": "1495050876",
            "description": "Work in progress - simple test scene/materials, no lighting.\nRenders a static arbitrarily complex SDF scene over multiple frames. No limit to steps.\nKeys: Cursors move fwd/back, sideways. W/S are up/down, Mouse/A/D pan left/right. Q/E view pitch up/down.\n",
            "flags": 48,
            "hasliked": 0,
            "id": "MssfRr",
            "likes": 6,
            "name": "Incremental ray marching",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "baldand",
            "viewed": 826
        },
        "renderpass": [
            {
                "code": "// Incremental ray marcher\n// Copyright (c) 2017 Andrew Baldwin (baldand)\n// License = Attribution-ShareAlike 4.0 International (CC BY-SA 4.0) (http://creativecommons.org/licenses/by-sa/4.0/)\n\n// Renders a scene defined with a signed distance field\n// incrementally over multiple frames\n// Buf A does keyboard handling & camera state\n// Buf B dispatches rays\n// Buf C does ray marching\n// Buf D accumulates results\n// Image displays\n\n// History\n// 17/5/17 - first work-in-progress version\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = fragCoord.xy / iResolution.xy;\n   vec4 final = texture(iChannel0, uv);    \n   fragColor = final;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//  Navigation & global state buffer\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_W = 87;\nconst int KEY_S  = 83;\nconst int KEY_A = 65;\nconst int KEY_D  = 68;\nconst int KEY_Q = 81;\nconst int KEY_E  = 69;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec4 state_pos = texelFetch( iChannel0, ivec2(0,0), 0);\n    vec4 state_dir = texelFetch( iChannel0, ivec2(1,0), 0);\n    float camyaw = state_dir.x;\n    vec3 campos = state_pos.xyz;//\n    vec3 camtrg = vec3(sin(camyaw),0.,cos(camyaw))+campos;\n    vec3 camup = vec3(0.,1.,0.); \n    vec3 forward = normalize(camtrg - campos);\n    vec3 side = cross(forward,camup);\n    vec3 up = cross(forward,side);\n        \n    float resprod = iResolution.x*iResolution.y;\n    vec4 res = vec4(0.);\n    if (fragCoord==vec2(0.5,0.5)) {\n        // Cam pos\n        if (iFrame==0) {\n            // Initialise\n            res = vec4(0.,1.,0.,resprod);\n        } else {\n            vec4 oldpos = texelFetch( iChannel0, ivec2(0,0), 0);\n            res = oldpos;\n            if (oldpos.w == 0.0) res.w = resprod;\n            else if (oldpos.w != resprod) res.w = 0.0;\n            // Check keys\n            if (texelFetch( iChannel1, ivec2(KEY_LEFT,1), 0 ).x>0.) { campos -= 0.1*side; res.w = 0.; }\n            if (texelFetch( iChannel1, ivec2(KEY_RIGHT,1), 0 ).x>0.) { campos += 0.1*side; res.w = 0.; }\n            if (texelFetch( iChannel1, ivec2(KEY_UP,1), 0 ).x>0.) { campos += 10.*forward; res.w = 0.; }\n            if (texelFetch( iChannel1, ivec2(KEY_DOWN,1), 0 ).x>0.) { campos -= 10.*forward; res.w = 0.; }\n            if (texelFetch( iChannel1, ivec2(KEY_W,1), 0 ).x>0.) { campos -= 10.*up; res.w = 0.; }\n            if (texelFetch( iChannel1, ivec2(KEY_S,1), 0 ).x>0.) { campos += 10.*up; res.w = 0.; }\n            res.xyz = campos;\n        }\n    }\n    if (fragCoord==vec2(1.5,0.5)) {\n        // Cam dir\n        if (iFrame==0) {\n            // Initialise\n            res = vec4(0.,0.,0.,0.);\n        } else {\n            vec4 olddir = texelFetch( iChannel0, ivec2(1,0), 0);\n            res = olddir;\n            if (olddir.w == 0.0) res.w = resprod;\n            else if (olddir.w != resprod) res.w = 0.0;\n            // Check keys\n            if (res.z != 6.282*iMouse.x/iResolution.x) {\n\t            res.z = 6.282*iMouse.x/iResolution.x;\n\t            res.w = 0.0;\n            }\n            if (texelFetch( iChannel1, ivec2(KEY_A,1), 0 ).x>0.) { res.x += 0.1; res.w = 0.; }\n            if (texelFetch( iChannel1, ivec2(KEY_D,1), 0 ).x>0.) { res.x -= 0.1; res.w = 0.; }\n            if (texelFetch( iChannel1, ivec2(KEY_Q,1), 0 ).x>0.) { res.y += 0.1; res.w = 0.; }\n            if (texelFetch( iChannel1, ivec2(KEY_E,1), 0 ).x>0.) { res.y -= 0.1; res.w = 0.; }\n        }\n    }\n    fragColor = res;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Ray dispatcher\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec4 state_pos = texelFetch( iChannel0, ivec2(0,0), 0);\n   vec4 state_dir = texelFetch( iChannel0, ivec2(1,0), 0);\n   float reschange = step(state_pos.w,0.5)+step(state_dir.w,0.5);\n    \n   vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.x; \n   float camyaw = state_dir.x+state_dir.z;\n   float campitch = state_dir.y;\n   vec3 campos = state_pos.xyz;\n   vec3 camtrg = vec3(sin(camyaw),campitch,cos(camyaw))+campos;\n   vec3 camup = vec3(0.,1.,0.); \n   vec3 forward = normalize(camtrg - campos);\n   vec3 side = cross(forward,camup);\n   vec3 up = cross(forward,side);\n   vec3 imgpos = campos + uv.x*side - uv.y*up;\n   float focal = 1.;\n   vec3 rayori = campos - (focal*forward);\n   vec3 ray = (imgpos - rayori);\n   vec3 rayn = normalize(ray);\n \n   vec4 command = vec4(rayori,0.0);   \n   vec2 tuv = fragCoord.xy / iResolution.xy;\n   if (iFrame==0 || reschange>0.) {\n   } else {\n       // Read old command\n       vec4 oldcmd = texture(iChannel1, tuv);\n       // Read old comand state\n       vec4 oldcmdstate = texture(iChannel2, tuv);\n   }\n   fragColor = command;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Ray marcher\n\nvec3 rnd3(vec3 n)\n{\n\tvec3 m = floor(n)*.00001 + fract(n);\n\tconst mat3 p = mat3(13.323122,23.5112,21.71123,21.1212,28.7312,11.9312,21.8112,14.7212,61.3934);\n\tvec3 mp = (31415.9+m)/fract(p*m);\n\treturn fract(mp);\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sp(vec3 pos,float r) {\n    return length(pos)-r;\n}\n\n\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat rs(vec3 pos) {\n    float d = sp(pos,2.); // \n    vec3 i = step(abs(pos*.5),vec3(1.));\n    float ii = i.x*i.y*i.z;\n    vec3 p2 = (mod(pos,2.)-1.)*.5;\n    float d2 = sp(p2,ii*.5)*2.;\n    //d = min(d,d2);\n    return d2;\n}\n\nfloat groundh( vec2 co ) {\n    vec2 co_big = co*0.001;\n    float h = 200.*sin(co_big.x+100.0*sin(co_big.x*.02123))*\n        sin(co_big.y+sin(co_big.y*.01293));\n    vec2 co_med = co*0.01;\n    h -= 20.*sin(co_med.x+2.0*sin(co_med.x*.02123))*\n        sin(co_med.y+3.0*sin(co_med.y*.01293));\n    vec2 co_min = co*0.0764;\n    h += 5.*sin(co_min.x+7.0*sin(co_min.x*.02123))*\n        sin(co_min.y+3.0*sin(co_min.y*.01293));\n    vec2 co_mic = co*0.312-.1292;\n    h += 1.*sin(co_mic.x+8.0*sin(co_mic.x*.02123))*\n        sin(co_mic.y+6.0*sin(co_mic.y*.01293));\n    vec2 co_fin = co*1.23+.948;\n    h += .2*sin(co_fin.x+8.0*sin(co_fin.x*.02123))*\n        sin(co_fin.y+6.0*sin(co_fin.y*.01293));\n    vec2 co_stn = co*3.123+.1948;\n    h += .05*sin(co_stn.x+8.0*sin(co_stn.x*.02123))*\n        sin(co_stn.y+6.0*sin(co_stn.y*.01293));\n    vec2 co_snd = co*13.123+.1948;\n    h += .03*sin(co_snd.x+8.0*sin(co_snd.x*.02123))*\n        sin(co_snd.y+6.0*sin(co_snd.y*.01293));\n    return h;\n}\n\nvec2 world( vec3 pos ) {\n   vec2 res;\n   float b = sdBox( pos-vec3(0.,1.5,5.), vec3(1.));\n   float t = sdTorus( pos-vec3(2.,1.,4.), vec2(2.,.5)) + .01*sin(20.*pos.x);\n   float house = smin(t,b,0.99);\n    \n   float ground = pos.y - groundh(pos.xz);\n\n   float choose = step(0.0,ground-house);\n   res = mix(vec2(ground,1.),vec2(house,2.),choose);\n   return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec4 state_pos = texelFetch( iChannel0, ivec2(0,0), 0);\n   vec4 state_dir = texelFetch( iChannel0, ivec2(1,0), 0);\n   float reschange = step(state_pos.w,0.5)+step(state_dir.w,0.5);\n    \n   vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.x; \n   float camyaw = state_dir.x+state_dir.z;\n   float campitch = state_dir.y;\n   vec3 campos = state_pos.xyz;//\n   //campos = vec3(0.,1.,0.);\n   vec3 camtrg = vec3(sin(camyaw),campitch,cos(camyaw))+campos;\n   vec3 camup = vec3(0.,1.,0.); \n   vec3 forward = normalize(camtrg - campos);\n   vec3 side = cross(forward,camup);\n   vec3 up = cross(forward,side);\n   vec3 imgpos = campos + uv.x*side - uv.y*up;\n   float focal = 1.;\n   vec3 rayori = campos - (focal*forward);\n \n   vec2 tuv = fragCoord.xy / iResolution.xy;\n   vec3 p;\n   vec2 d;\n   float t;\n\n   vec4 rayd = texture(iChannel1, tuv); // From ray dispatcher\n   rayori = rayd.xyz;\n   float raytype = rayd.w; // 0 means primary ray from cam\n   vec3 ray = (imgpos - rayori);\n   vec3 rayn = normalize(ray);\n\n   if (iFrame==0 || reschange>0.) {\n       t = length(rayn); // Start at image plane\n   } else {\n       // Read old t\n       vec4 o = texture(iChannel2, tuv);\n       t = o.w;\n   }\n   if (t < 0.) t = abs(t);\n   // Trace forward one step\n   float eps = 1e-2;\n   if (t<1e6) {\n       for (int i=0;i<10;i++) {\n           p = rayori + t*rayn;\n           d = world(p);\n           if (d.x<0.) t*=0.5;\n           if (p.y>300.) { t = -t; break; }\n           if (abs(d.x)<eps) { t = -t; break; }\n           t += .5*d.x;\n       }\n   }\n   if (t<0.) {\n       rayn = p;\n       t = -d.y;\n   }\n   fragColor = vec4(rayn,t);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Lighting, materials, etc\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec4 state_pos = texelFetch( iChannel0, ivec2(0,0), 0);\n   vec4 state_dir = texelFetch( iChannel0, ivec2(1,0), 0);\n   float reschange = step(state_pos.w,0.5)+step(state_dir.w,0.5);\n   vec2 uv = fragCoord.xy / iResolution.xy;\n   vec4 raynt = texture(iChannel2, uv);    \n   vec4 rayd = texture(iChannel1, uv); // From ray dispatcher\n   vec3 rayori = rayd.xyz;\n\n   vec4 c;\n   if (iFrame==0 || reschange>0.) {\n       c = vec4(0.);\n   \t   //c = texture(iChannel3, uv);    \n   } else {\n   \t   c = texture(iChannel3, uv);    \n   }\n    \n   vec3 sun = normalize(vec3(1.,1.,1.));\n    \n   // Accumulate if ray done\n   if (raynt.w < 0.) {\n        vec3 add;\n        float t = -raynt.w;\n   \t\tvec3 p = raynt.xyz; \n        float d = t*.1;\n        d = d/(1.0+d);\n        if (p.y>250.) add = vec3(0.2,0.6,1.0);\n       \telse if (t==1.) {\n            add = vec3(d)*step(vec3(0.1),mod(p,.5))+1.*vec3(0.,1.,0.)*sin(p.y*.1);\n            add = mix(add,vec3(1.),d);\n        } else if (t==2.) {\n            add = vec3(1.0-d,0.0,0.0);\n        }\n        c.xyz = add;\n   }\n   fragColor = c;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}