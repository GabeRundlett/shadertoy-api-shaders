{
    "Shader": {
        "info": {
            "date": "1587570881",
            "description": "Explorer for the Julia set with keyboard and mouse support.\n\nColoring algorithm uses angle average (similar to an algorithm I found on Kerry Mitchell's website) and palettes from Inigo Quilez.",
            "flags": 48,
            "hasliked": 0,
            "id": "wsBcDt",
            "likes": 8,
            "name": "Julia Set Explorer Angle Avg",
            "published": 3,
            "tags": [
                "2d",
                "fractal",
                "julia",
                "interactive"
            ],
            "usePreview": 0,
            "username": "andretugan",
            "viewed": 356
        },
        "renderpass": [
            {
                "code": "//\tAuthor: https://www.shadertoy.com/user/andretugan\n//\tCreative Commons Attribution-NonCommercial 3.0 Unported License\n//\thttps://creativecommons.org/licenses/by-nc/3.0\n//\t\n//  Main image can be dragged with a mouse, the minimap can be clicked\n//\tM - toggle minimap\n// \tA, W, S, D or cursor keys - move\n// \tZ, X, PAGE_UP, PAGE_DOWN - zoom \n// \tQ, E - rotate\n//  SHIFT - hold with move, zoom and rotate for finer movement\n//  SPACE - reset camera\n//\n//\tRequires WebGL 2.0 support. If you are using Safari, it might be disabled by default.  \n//\n//\tThe coloring method is computing atan(y, x) during the iterations and\n//\tuses their average to seed the color palette.\n//\tIt is similar to the weighted average algorithm described here:\n//\thttp://www.kerrymitchellart.com/tutorials/formulas2/uf2-2.htm\n//\tI'm not using weighted average to improve FPS, and it also looks nice.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    // See Buffer A for the actual code\n    vec3 col = texelFetch(iChannel1, ivec2(fragCoord - 0.5), 0).rgb;\n    \n    // Darken the edges of the image\n    vec2 uv01 = fragCoord / iResolution.xy;\n    float vignette = .5 + .5 * pow(16.0 * uv01.x * uv01.y * (1. - uv01.x) * (1. - uv01.y), .2);\n    col = mix(vec3(0.), col, vignette);\n    \n    // Gamma correction\n    col = pow(col, vec3(0.45));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//\tAuthor: https://www.shadertoy.com/user/andretugan\n//\tCreative Commons Attribution-NonCommercial 3.0 Unported License\n//\thttps://creativecommons.org/licenses/by-nc/3.0\n//\t\n//  Main image can be dragged with a mouse, the minimap can be clicked\n//\tM - toggle Mandelbrot minimap\n//\tJ - toggle Julia minimap\n// \tA, W, S, D or cursor keys - move\n// \tZ, X, PAGE_UP, PAGE_DOWN - zoom \n// \tQ, E - rotate\n//  SHIFT - hold with move, zoom and rotate for finer movement\n//  SPACE - reset camera\n//\n//\tRequires WebGL 2.0 support. If you are using Safari, it might be disabled by default.  \n//\n//\tThe coloring method is computing atan(y, x) during the iterations and\n//\tuses their average to seed the color palette.\n//\tIt is similar to the weighted average algorithm described here:\n//\thttp://www.kerrymitchellart.com/tutorials/formulas2/uf2-2.htm\n//\tI'm not using weighted average to improve FPS, and it also looks nice.\n\n#define ANTI_ALIASING 2\n\n#define M_MINIMAP_SCALE 0.25\n#define M_MINIMAP_OFFSET_X 0.9\n#define M_MINIMAP_OFFSET_Y 0.7\n\n#define M_MINIMAP_LEFT_BOUND -2.2\n#define M_MINIMAP_RIGHT_BOUND 1.\n#define M_MINIMAP_TOP_BOUND 1.3\n#define M_MINIMAP_BOTTOM_BOUND -1.3\n\n#define J_MINIMAP_SCALE 0.25\n#define J_MINIMAP_OFFSET_X 0.75\n#define J_MINIMAP_OFFSET_Y -0.7\n\n#define J_MINIMAP_LEFT_BOUND -2.2\n#define J_MINIMAP_RIGHT_BOUND 2.2\n#define J_MINIMAP_TOP_BOUND 1.3\n#define J_MINIMAP_BOTTOM_BOUND -1.3\n\n#define MINIMAP_FADE 0.5\n\n#define M_PI 3.14159265358\n#define M_2_PI (2. * M_PI)\n#define M_PI_2 (0.5 * M_PI)\n\n#define ESCAPE_RADIUS 500.\n\n//\tFor a more detailed deep zoom increase this\n#define MAX_STEPS 200\n\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_SPACE 32\n#define KEY_PAGE_UP 33\n#define KEY_PAGE_DOWN 34\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_A 65\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_J 74\n#define KEY_M 77\n#define KEY_Q 81\n#define KEY_S 83\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n\n//  Color palettes based on article by Inigo Quilez\n// \thttps://iquilezles.org/articles/palettes\nvec3 GetColor1(float t)\n{\n    return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) *\n        cos(M_2_PI * (t * vec3(1., 1., 1.) + vec3(0.00, 0.33, 0.67)));\n}\n\nvec3 GetColor2(float t)\n{\n    return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) *\n        cos(M_2_PI * (t * vec3(1., 1., 1.) + vec3(0.0, 0.1, 0.2)));\n}\n\nvec3 GetColor3(float t)\n{\n    return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) *\n        cos(M_2_PI * (t * vec3(1., 1., 1.) + vec3(0.3, 0.2, 0.2)));\n}\n\nvec3 GetColor4(float t)\n{\n    return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) *\n        cos(M_2_PI * (t * vec3(1.0, 1.0, 0.5) + vec3(0.8, 0.9, 0.3)));\n}\n\nvec3 GetColor5(float t)\n{\n    return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) *\n        cos(M_2_PI * (t * vec3(1.0, 0.7, 0.4) + vec3(0.0, 0.15, 0.2)));\n}\n\nvec3 GetColor6(float t)\n{\n    return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) *\n        cos(M_2_PI * (t * vec3(2.0, 1.0, 0.0) + vec3(0.5, 0.2, 0.25)));\n}\n\nvec3 GetColor7(float t)\n{\n    return vec3(0.8, 0.5, 0.4) + vec3(0.2, 0.4, 0.2) *\n        cos(M_2_PI * (t * vec3(2.0, 1.0, 1.0) + vec3(0.0, 0.25, 0.25)));\n}\n\nbool NoComputationNeeded(vec2 c) {\t\n    // Do not compute inside the large bulbs\n    // Based on https://www.shadertoy.com/view/4sdXWX\n    float c2 = dot(c, c);\n    if ((256.0 * c2 - 96.0) * c2 + 32.0 * c.x < 3.0) return true;    \n    if (16.0 * (c2 + 2. * c.x + 1.) < 1.0) return true;        \n    return false;\n}\n\nvec2 FromGlobalToMMinimap(vec2 global) {\n    vec2 offset = vec2(M_MINIMAP_OFFSET_X * iResolution.x / iResolution.y, M_MINIMAP_OFFSET_Y);\n\treturn (global - offset) / M_MINIMAP_SCALE;\n}\n\nvec2 FromMMinimapToGlobal(vec2 minimap) {\n    vec2 offset = vec2(M_MINIMAP_OFFSET_X * iResolution.x / iResolution.y, M_MINIMAP_OFFSET_Y);\n\treturn M_MINIMAP_SCALE * minimap + offset;\n}\n\nvec2 FromGlobalToJMinimap(vec2 global) {\n    vec2 offset = vec2(J_MINIMAP_OFFSET_X * iResolution.x / iResolution.y, J_MINIMAP_OFFSET_Y);\n\treturn (global - offset) / J_MINIMAP_SCALE;\n}\n\nvec2 FromJMinimapToGlobal(vec2 minimap) {\n    vec2 offset = vec2(J_MINIMAP_OFFSET_X * iResolution.x / iResolution.y, J_MINIMAP_OFFSET_Y);\n\treturn J_MINIMAP_SCALE * minimap + offset;\n}\n\nvec3 Draw(vec2 z, vec2 c) {    \n    if (NoComputationNeeded(c)) return vec3(0.);\n         \n    float z2 = 0.;       \n    float sum = 0.0;\n    float prev_sum = 0.0;    \n    int iter = 0;\n    while (z2 / ESCAPE_RADIUS < ESCAPE_RADIUS) {\n        if (iter == MAX_STEPS) return vec3(0.);    \t\n        ++iter;\n   \n        // z = z^2 + c\n\t\tz = vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y) + c;\n        z2 = dot(z, z);\n        \n        // For coloring\n        prev_sum = sum;\n        sum += atan(z.y, z.x);\n    } \n        \n    // The fractional iteration by which we overshot the escape radius    \n    float overshot = log2(0.5*log2(z2)/log2(ESCAPE_RADIUS));\n    \n    // Compute real values for sum and iter at the point of crossing\n    // the escape radius through linear interpolation\n\tfloat real_sum = mix(sum, prev_sum, overshot);\n    float real_iter = float(iter) - overshot;      \n    float avg = real_sum / real_iter;     \n        \n    //float val = 2. / (1. + exp(-real_iter * 0.07)) - 1.;\n\treturn GetColor2(avg);\n    //return GetColor5(avg * 0.45);// * val;\t\t\t\t\t\n}\n\nbool InMMinimap(vec2 uv_m) {\n    return uv_m.x > M_MINIMAP_LEFT_BOUND && uv_m.x < M_MINIMAP_RIGHT_BOUND &&\n        uv_m.y > M_MINIMAP_BOTTOM_BOUND && uv_m.y < M_MINIMAP_TOP_BOUND;\n}\n\nbool InJMinimap(vec2 uv_m) {\n    return uv_m.x > J_MINIMAP_LEFT_BOUND && uv_m.x < J_MINIMAP_RIGHT_BOUND &&\n        uv_m.y > J_MINIMAP_BOTTOM_BOUND && uv_m.y < J_MINIMAP_TOP_BOUND;\n}\n\nvec3 DrawMainImage(vec2 fragCoord, vec2 center, float zoom, mat2 rotation_matrix, vec2 c) {\n    // Split each pixel into an ANTI_ALIASING x ANTI_ALIASING grid\n    vec3 col = vec3(0.);\n    int num_samples = 0;\n    for (int i = 0; i < ANTI_ALIASING; ++i) {\n    \tfor (int j = 0; j <= ANTI_ALIASING; ++j) {\n    \t\t++num_samples;\n\n            // Apply camera transforms\n            vec2 coord = fragCoord + vec2(float(i)/float(ANTI_ALIASING), float(j)/float(ANTI_ALIASING)); \n            vec2 uv = (2.*coord - iResolution.xy)/iResolution.y;            \n            uv *= rotation_matrix;\n            uv /= zoom;\n            uv += center;\n            \n            col += Draw(uv, c);\n        }\n    }\n\n\tcol /= float(num_samples); \n\n \treturn col;   \n}\n\nvec3 DrawMMinimap(vec2 fragCoord, vec2 center, float zoom,\n                  mat2 rotation_matrix, vec2 c, out float minimap_opacity) {\n\tvec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;    \n    vec2 uv_m = FromGlobalToMMinimap(uv);                    \n     \n    \n    vec3 col = vec3(0.);\n    minimap_opacity = 0.;\n    \n    if (InMMinimap(uv_m)) {\n        // Draw the Mandelbrot set for the minimap\n    \tcol = Draw(vec2(0.), uv_m);\n                                                       \n        vec2 offset = uv_m - c;        \n        float marker_opacity = smoothstep(0.005, 0.0, dot(offset, offset));\n        col = mix(col, vec3(1., .1, .1), marker_opacity);        \n        \n        // Minimap border fade out\n        minimap_opacity = 1.;\n        minimap_opacity *= smoothstep(0., MINIMAP_FADE, uv_m.x - M_MINIMAP_LEFT_BOUND);\n        minimap_opacity *= smoothstep(0., MINIMAP_FADE, M_MINIMAP_RIGHT_BOUND - uv_m.x);\n        minimap_opacity *= smoothstep(0., MINIMAP_FADE, M_MINIMAP_TOP_BOUND - uv_m.y);\n        minimap_opacity *= smoothstep(0., MINIMAP_FADE, uv_m.y - M_MINIMAP_BOTTOM_BOUND);        \n    } \n\treturn col;\n}\n\nvec3 DrawJMinimap(vec2 fragCoord, vec2 center, float zoom,\n                  mat2 rotation_matrix, vec2 c, out float minimap_opacity) {\n\tvec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;    \n    vec2 uv_j = FromGlobalToJMinimap(uv);                    \n     \n    \n    vec3 col = vec3(0.);\n    minimap_opacity = 0.;\n    \n    if (InJMinimap(uv_j)) {\n        // Draw the Julia set for the minimap\n    \tcol = Draw(uv_j, c);\n                                               \n        // Draw the rectangular framing on the minimap        \n        vec2 offset = uv_j - center;\n        vec2 framing_uv_j = rotation_matrix * offset * zoom; \n        float aspect = iResolution.x / iResolution.y;\n        float dx = aspect - abs(framing_uv_j.x);\n        float dy = 1. - abs(framing_uv_j.y);\n        float thickness = zoom * 0.03;       \n        float outside_rectangle = max(smoothstep(thickness, 0., dx), smoothstep(thickness, 0., dy));        \n        float inside_rectangle = min(smoothstep(-thickness, 0., dx), smoothstep(-thickness, 0., dy));\n        float framing_opacity = inside_rectangle * outside_rectangle;\n        // When the zoom is high, draw a point, so that the framing does not degenerate into nothing.\n        framing_opacity += smoothstep(40., 70., zoom) * smoothstep(0.005, 0.0, dot(offset, offset));\n        col = mix(col, vec3(1., .1, .1), framing_opacity);        \n        \n        // Minimap border fade out\n        minimap_opacity = 1.;\n        minimap_opacity *= smoothstep(0., MINIMAP_FADE, uv_j.x - J_MINIMAP_LEFT_BOUND);\n        minimap_opacity *= smoothstep(0., MINIMAP_FADE, J_MINIMAP_RIGHT_BOUND - uv_j.x);\n        minimap_opacity *= smoothstep(0., MINIMAP_FADE, J_MINIMAP_TOP_BOUND - uv_j.y);\n        minimap_opacity *= smoothstep(0., MINIMAP_FADE, uv_j.y - J_MINIMAP_BOTTOM_BOUND);        \n    } \n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {        \n    // Read information pixels in the left top corner\n    ivec2 camera_pixel = ivec2(0, iResolution.y - 0.5);\n    ivec2 state_pixel = ivec2(1, iResolution.y - 0.5);\n    ivec2 julia_pixel = ivec2(0, iResolution.y - 1.5);\n    \n    // camera.xy - camera position\n    // camera.z - zoom exponent = log(zoom) + a\n    // camera.w - camera rotation in radians\n    vec4 camera = texelFetch(iChannel1, camera_pixel, 0);\n    \n    // state.xy - position from where mouse dragging started\n    // state.z - currently dragging if 1., not dragging if 0.\n    // state.w - camera controlled manually if 1., automated if 0.\n    vec4 state = texelFetch(iChannel1, state_pixel, 0);\n    \n    // julia.xy - Julia set seed\n    // julia.z - using default Julia seed if 0., user selected if 1.\n    vec4 julia = texelFetch(iChannel1, julia_pixel, 0);\n            \n    if (state.w <= 0.) {\n        // Automated camera movement\n        camera.xy = vec2(-0.457, 0.26);\n    \tcamera.z = 4. + 2. * sin(iTime * 0.1);\n       \tcamera.w = M_2_PI * sin(iTime * 0.01);\n    }       \n    \n    if (julia.z <= 0.) {\n        // Default Julia set seed\n    \tjulia.z = 1.0;\n        julia.x = -0.6;\n        julia.y = 0.5;\n    }\n    \n    // Camera zoom and rotation\n    float zoom = exp(camera.z - 1.);    \n    float sin_rotation = sin(camera.w);\n    float cos_rotation = cos(camera.w);\n    mat2 rotation_matrix = mat2(cos_rotation, sin_rotation, -sin_rotation, cos_rotation);\n    \n    // Mandelbrot and Julia minimaps toggle flags\n    bool m_minimap_enabled = texelFetch(iChannel0, ivec2(KEY_M, 2), 0).x > 0.;    \n    bool j_minimap_enabled = texelFetch(iChannel0, ivec2(KEY_J, 2), 0).x > 0.;    \n     \n    // Update information pixels\n    if (ivec2(fragCoord - 0.5) == camera_pixel || ivec2(fragCoord - 0.5) == state_pixel) {\n        vec4 old_camera = camera;\n        \n        // Update camera position\n        float factor = 1.0 - 0.9 * texelFetch(iChannel0, ivec2(KEY_SHIFT, 0), 0).x;\n        \n        vec2 xy_change = vec2(0.);\n       \txy_change.x -= 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_LEFT, 0), 0).x;\n        xy_change.x -= 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_A, 0), 0).x;\n        xy_change.x += 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_RIGHT, 0), 0).x;\n        xy_change.x += 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_D, 0), 0).x;\n        xy_change.y -= 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_DOWN, 0), 0).x;        \n        xy_change.y -= 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_S, 0), 0).x;        \n        xy_change.y += 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_UP, 0), 0).x;\n        xy_change.y += 0.1 / zoom * factor * texelFetch(iChannel0, ivec2(KEY_W, 0), 0).x;\n        \n        camera.xy += transpose(rotation_matrix) * xy_change;\n        \n        camera.z -= 0.1 * factor * texelFetch(iChannel0, ivec2(KEY_PAGE_UP, 0), 0).x;        \n        camera.z -= 0.1 * factor * texelFetch(iChannel0, ivec2(KEY_X, 0), 0).x;        \n        camera.z += 0.1 * factor * texelFetch(iChannel0, ivec2(KEY_PAGE_DOWN, 0), 0).x;\n        camera.z += 0.1 * factor * texelFetch(iChannel0, ivec2(KEY_Z, 0), 0).x;        \n        camera.w -= M_PI * 0.01 * factor * texelFetch(iChannel0, ivec2(KEY_E, 0), 0).x;\n        camera.w += M_PI * 0.01 * factor * texelFetch(iChannel0, ivec2(KEY_Q, 0), 0).x;\n                \n        if (iMouse.z > 0.) {\n            vec2 mouse_uv = (2.*iMouse.xy - iResolution.xy)/iResolution.y;    \n            vec2 mouse_uv_j = FromGlobalToJMinimap(mouse_uv);            \n\n            if (state.z > 0.) {\n                // The image is being dragged with a mouse\n            \tcamera.xy = state.xy - transpose(rotation_matrix) * mouse_uv / zoom;                \t\n            } else if (j_minimap_enabled && InJMinimap(mouse_uv_j)) {\n                // Julia minimap was clicked\n            \tcamera.xy = mouse_uv_j;\n            }                    \n        }                \n\t\n        if (camera != old_camera) {\n        \tstate.w = 1.0;\n        } else if (texelFetch(iChannel0, ivec2(KEY_SPACE, 0), 0).x > 0.0) {\n        \tstate.w = 0.0;\n        }\n        \n        // Update dragging state\n        if (ivec2(fragCoord - 0.5) == state_pixel) {                                \n            if (iMouse.z > 0.) {\n                vec2 mouse_uv = (2.*iMouse.xy - iResolution.xy)/iResolution.y;\n                if ((!m_minimap_enabled || !InMMinimap(FromGlobalToMMinimap(mouse_uv))) &&\n                    (!j_minimap_enabled || !InJMinimap(FromGlobalToJMinimap(mouse_uv)))) {\n                    if (state.z <= 0.) { // Not dragging\n                        // Set flag that we are now dragging\n                        state.z = 1.0;\n                        // Set coordinates where we started dragging\n                        state.xy = camera.xy + transpose(rotation_matrix) * mouse_uv / zoom;\n                    }\n                }            \n            } else {\n                // Set flag that we are not dragging\n                state.z = 0.0;        \n            }\n\n            fragColor = state;            \n        } else {        \n        \tfragColor = camera;\n        }\n        \n        return;\n    }\n    \n    // Update Julia set seed\n    if (ivec2(fragCoord - 0.5) == julia_pixel) {\n        if (m_minimap_enabled && iMouse.z > 0.) {\n            vec2 mouse_uv = (2.*iMouse.xy - iResolution.xy)/iResolution.y;                \n            vec2 mouse_uv_m = FromGlobalToMMinimap(mouse_uv);\n            if (InMMinimap(mouse_uv_m)) {\n\t\t\t\tjulia.z = 1.0;\n            \tjulia.xy = mouse_uv_m;\n            }\n        }                \n    \tfragColor = julia;\n        return;\n    }\n         \n    vec3 col = DrawMainImage(fragCoord, camera.xy, zoom, rotation_matrix, julia.xy);\n        \n    if (m_minimap_enabled) {\n    \tfloat minimap_opacity = 0.;\n    \tvec3 minimap_col = DrawMMinimap(fragCoord, camera.xy, zoom,\n                                       rotation_matrix, julia.xy, minimap_opacity);             \t    \n  \t\tcol = mix(col, minimap_col, minimap_opacity);           \n    }\n    \n    if (j_minimap_enabled) {\n    \tfloat minimap_opacity = 0.;\n    \tvec3 minimap_col = DrawJMinimap(fragCoord, camera.xy, zoom,\n                                       rotation_matrix, julia.xy, minimap_opacity);             \t    \n  \t\tcol = mix(col, minimap_col, minimap_opacity);           \n    }\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}