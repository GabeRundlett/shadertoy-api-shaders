{
    "Shader": {
        "info": {
            "date": "1529110876",
            "description": "as god intended\n\nlower LEVELS, OVERSAMPLE_PIX and OVERSAMPLE_TEX to make rendering quicker. make them larger to make it prettier.",
            "flags": 1,
            "hasliked": 0,
            "id": "4sVfDw",
            "likes": 9,
            "name": "chrome spheres over checkerboard",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "halcy",
            "viewed": 935
        },
        "renderpass": [
            {
                "code": "// Various knobs to twiddle\n#define LEVELS 8\n#define OVERSAMPLE_PIX 4\n#define OVERSAMPLE_PIX_WIDTH 0.001\n#define OVERSAMPLE_TEX 16\n#define LARGE_NUMBER 900000.0\n\nbool is_vr = false;\nvec3 vr_ori = vec3(0.0);\nvec3 vr_ray = vec3(0.0);\n\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nvec3 hash33(vec3 p){ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768) * n); \n}\n\n// Trefoil knot positions\nvec3 trefoil(float t) {\n\treturn vec3(\n        sin(t) + 2.0 * sin(2.0 * t),\n        cos(t) - 2.0 * cos(2.0 * t),\n        -sin(3.0 * t)\n    );\n}\n\n// Ray-sphere and ray-plane intersections \nfloat sphere_intersect(vec3 pos, float radius, vec3 eye, vec3 ray) {\n    vec3 pos_to_eye = eye - pos;\n    float ray_dot_dir = dot(ray, pos_to_eye);\n    float determ = ray_dot_dir * ray_dot_dir - dot(pos_to_eye, pos_to_eye) + radius * radius;\n    if(determ < 0.0 || -ray_dot_dir - sqrt(determ) < 0.0) {\n    \treturn LARGE_NUMBER;   \n    }\n    return -ray_dot_dir - sqrt(determ);\n}\n\nfloat xzplane_intersect(float height, vec3 eye, vec3 ray) {\n    float determ = (height - eye.y) / ray.y;\n    if(determ <= 0.0) {\n    \treturn LARGE_NUMBER;   \n    }\n    return determ;\n}\n\n\n\n// View setup\nvoid camera(vec2 coords, out vec3 eye, out vec3 ray) {\n    // Calculate an eye position\n    eye = vec3(sin(iTime) * 0.5, sin(iTime * 0.3) * 0.5 + 0.5, iTime * 16.0);\n    \n    // Camera as eye + imaginary screen at a distance\n    vec3 lookat = vec3(0.0, 0.0, iTime * 16.0 + 2.0);\n    vec3 lookdir = normalize(lookat - eye);\n    vec3 left = normalize(cross(lookdir, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(left, lookdir));\n    vec3 lookcenter = eye + lookdir;\n\tvec3 pixelpos = lookcenter + coords.x * left + coords.y * up;\n    ray = normalize(pixelpos - eye);\n}\n\n// Raytrace the scene\nvec3 sphere_pos(vec3 eye, float spherenum) {\n\tvec3 trefoil_offset = trefoil(3.14 * 2.0 * spherenum / 7.0 + iTime).xzy * 0.7;\n\treturn eye + trefoil_offset + vec3(0.0, -1.0, 4.0);\n}\n\nvec4 trace(vec3 eye, vec3 ray) {\n    float plane_hit = xzplane_intersect(-2.0, eye, ray);\n    float hit_dist = plane_hit;\n    \n    vec3 sphere_c_a = sphere_pos(eye, 1.0);\n\tfloat sphere_hit_a = sphere_intersect(sphere_c_a, 0.5, eye, ray);\n    hit_dist = min(hit_dist, sphere_hit_a);\n    \n    vec3 sphere_c_b = sphere_pos(eye, 2.0);\n\tfloat sphere_hit_b = sphere_intersect(sphere_c_b, 0.5, eye, ray);\n    hit_dist = min(hit_dist, sphere_hit_b);\n    \n    vec3 sphere_c_c = sphere_pos(eye, 3.0);\n\tfloat sphere_hit_c = sphere_intersect(sphere_c_c, 0.5, eye, ray);\n    hit_dist = min(hit_dist, sphere_hit_c);\n    \n    float hit_obj = -1.0;\n    hit_obj = hit_dist == plane_hit ? 1.0 : hit_obj;\n    hit_obj = hit_dist == sphere_hit_a ? 2.0 : hit_obj;\n    hit_obj = hit_dist == sphere_hit_b ? 3.0 : hit_obj;\n    hit_obj = hit_dist == sphere_hit_c ? 4.0 : hit_obj;\n    hit_obj = hit_dist == LARGE_NUMBER ? -1.0 : hit_obj;\n    \n    return(vec4(eye + ray * hit_dist, hit_obj));\n}\n\n// Colour a non-hit\nvec3 background(vec3 dir) {\n    float rotval = atan(dir.x + 0.5, dir.y) + iTime * 0.1;\n    float noiseval = mod(atan(dir.y, dir.z), 0.1);\n    noiseval = rand(vec2(rotval, noiseval)) > 0.5 ? 1.0 : 0.8;\n    float dirs = mod(rotval + 0.08, 0.4);\n    float diry = mod(rotval, 0.2) < 0.04 ? 1.0 : abs(mod(rotval, 0.2) - 0.12) * 5.0;\n    //return texture(iChannel0, 2.0 * vec2((dir.x + 0.5) / 2.0, dir.y)).rgb;\n    if(dirs > 0.2) {\n    \treturn vec3(diry, 0.0, diry) * noiseval;\n    }\n    else {\n        return vec3(0.0, diry, diry) * noiseval;\n    }\n}\n\n// Colour anything whatsoever\nvec3 shade(vec3 pos, vec3 dir, float hit_obj, vec3 stack_color) {\n    if(hit_obj == 1.0) {\n        return vec3(mod(floor(pos.x) + floor(pos.z), 2.0));\n    }\n    if(hit_obj == LARGE_NUMBER) {\n    \treturn background(dir);\n    }\n   \treturn stack_color;\n}\n\n// Oversample textures\nvec3 shade_supersample(vec3 pos, vec3 dir, float hit_obj, vec3 stack_color) {\n    vec3 ddx_a = pos - dFdx(pos);\n    vec3 ddy_a = pos - dFdy(pos);\n\tvec3 ddx_b = pos + dFdx(pos);\n    vec3 ddy_b = pos + dFdy(pos);\n    \n    vec3 shade_sum = vec3(0.0);\n    for(int i = 0; i < OVERSAMPLE_TEX; i++) {\n    \tvec2 samp_off = vec2(\n            rand(vec2(length(pos * 1000.0), 2000.0 * float(i))),\n\t\t\trand(vec2(length(pos * 7000.0), 3700.0 * float(i)))\n        );\n        vec3 samp_pos_x = mix(ddx_a, ddx_b, abs(samp_off.x)) * 0.5;\n        vec3 samp_pos_y = mix(ddy_a, ddy_b, abs(samp_off.y)) * 0.5;\n        shade_sum += shade(samp_pos_x + samp_pos_y, dir, hit_obj, stack_color);\n    }\n    return(shade_sum / float(OVERSAMPLE_TEX));\n}\n\n// One pixel\nvec3 pixel(vec2 coords) {\n\tvec4 hit[LEVELS];\n    vec3 ray[LEVELS];\n    vec3 eye;\n    \n   \tcamera(coords, eye, ray[0]);\n    if(is_vr) {\n    \teye = vr_ori;\n        ray[0] = vr_ori;\n    }\n    hit[0] = trace(eye, ray[0]);\n    \n    // Trace all hits\n    for(int i = 1; i < LEVELS; i++) {\n        // Hit sphere?\n        if(hit[i - 1].w >= 2.0 && hit[i - 1].w < LARGE_NUMBER) {\n\t\t\tvec3 sphere_c = sphere_pos(eye, hit[i - 1].w  - 1.0);            \n            vec3 sphere_n = normalize(hit[i - 1].xyz - sphere_c);\n           \tray[i] = reflect(ray[i - 1], sphere_n);\n            hit[i] = trace(hit[i - 1].xyz + sphere_n * 0.1, ray[i]);\n        }\n        else {\n         \thit[i].w = LARGE_NUMBER;\n        }\n    }\n    \n    // Shade\n    vec3 stackColor = vec3(0.1);\n    for(int i = LEVELS - 1; i >= 0; i--) {\n        vec3 dir = ray[0];\n        if(i != 0) {\n            dir = ray[i - 1];   \n        }\n        stackColor = shade_supersample(hit[i].xyz, dir, hit[i].w, stackColor);\n    }\n    return stackColor;\n}\n\n// Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 coords = (2.0 * fragCoord.xy  - iResolution.xy) / max(iResolution.x, iResolution.y);\n    fragColor.rgb = vec3(0.0);\n    for(int i = 0; i < OVERSAMPLE_PIX; i++) {\n        vec2 offset =  hash33(vec3(coords.x, coords.y, float(i))).xy;\n    \tfragColor.rgb += pixel(coords + offset * OVERSAMPLE_PIX_WIDTH);\n    }\n    fragColor.rgb /= float(OVERSAMPLE_PIX);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n    is_vr = true;\n    vec2 coords = (2.0 * fragCoord.xy  - iResolution.xy) / max(iResolution.x, iResolution.y);\n    fragColor.rgb = vec3(0.0);\n    for(int i = 0; i < OVERSAMPLE_PIX; i++) {\n        vec2 offset =  hash33(vec3(coords.x, coords.y, float(i))).xy;\n    \tfragColor.rgb += pixel(coords + offset * OVERSAMPLE_PIX_WIDTH);\n    }\n    fragColor.rgb /= float(OVERSAMPLE_PIX);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}