{
    "Shader": {
        "info": {
            "date": "1492727786",
            "description": "iMouse.x overrides the otherwise fluctuating glowiness-parameter.\n\na 3d playground with bias for simplicity and gradient/differential visualization.\nal the stuff is in buffA, as it was experimenting with multisampling over time.",
            "flags": 48,
            "hasliked": 0,
            "id": "XsBczV",
            "likes": 14,
            "name": "19 transparent celshade outlines",
            "published": 3,
            "tags": [
                "sdf",
                "cellshading",
                "edge",
                "occlusion",
                "lipschitz",
                "outline",
                "hgsdf",
                "toonshade",
                "dynamiceps",
                "sell",
                "logeps",
                "cellshade"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1681
        },
        "renderpass": [
            {
                "code": "// A simple port of Zavie's GLSL smallpt that uses multipass.\n// Original source: https://www.shadertoy.com/view/4sfGDB#\n\nvoid mainImage( out vec4 o, in vec2 u ) {\n u=u.xy / iResolution.xy;\n vec3 c=texture(iChannel0,u).rgb;\n c=clamp(c,0.,1.);\n o=vec4(c,1.);\n}\n\n//this has a child at\n//  https://www.shadertoy.com/view/lsSyRd",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nhttps://www.shadertoy.com/view/XsBczV   =self\n\ntutorializing webgl fragment shader collection for shadertoy\nthis dives DEEP into irrational complex rotation matrix math.\n\nend__.header\nstart.const   ----do not change this section---\n\nWorld famous irrational numbers, sorted by NATURAL fame:\nDifferent definitions can change performance and precision.\nAll irrationals are infinite recursive fractions like a=1/n+(a), \n... with a sequence for every n being set by a defined series.\nThey can be approximated by iterating trough the infinite series.\nThose with larger divisors are approximated faster->\"less irrational\"\nphi=1/(1+(phi)) has the smallest divisor [1], approximates slowest->\"most irrational\"\n\nhttps://www.youtube.com/watch?v=CaasbfdJdJg\n//iou, function that gives dividend and divisor of irrationals after n-ierations\n\neul=limes of f(x)=pow(1+1/x,x)\npow(e,n)=firstDerivativeOf(pow(e,n));\neul=base for [log()] as the inverse of [pow(e,x)] so that\n... log(pow(eul,x))==x==pow(eul,log(x)); for [x>0]\n*/\n#define eul 2.61803398875\n//eul is not as awesome here, wait till I include advanced \"derivative arithmetic\"\n//\n//integerSquareroot/integer -> RootUnity:  https://en.wikipedia.org/wiki/Root_of_unity\n//With more n-gons this section boils down to more constants of \n//  https://en.wikipedia.org/wiki/Exact_trigonometric_constants\n//\n//generally: most simple fractions are not good enough approximations:\n//eg: 22/7 is not a precise enough approximation for a rotation by pi\n//... when you use polar coordinates.\n//\n//sqrt(2.)=1.4142135623730950488016887242097=\n//...pow(2.,1./2.)= ; https://en.wikipedia.org/wiki/Square_root_of_2#Properties_of_the_square_root_of_two\n//#define p22 sqrt(2.)\n//eightRotation.y=eightRotation.x=cos(pi4)=sin(pi4)=\n//...pow(2.,1./2.)/2=sqrt(2.)/2.=p22/2.=1./p22 =sqrt(0.5)==0.70710678118654752440084436210485\n#define p222 sqrt(0.5) \n//(pow(2.,1./2.)*.5*.5)).5/p22\n#define p224 (p222*.5)\n//incircleHexagonTotalHeight=\n//pow(3.,1./2.)= 97./56. =1.73205080756887729352744634150587236694280525381038062805580=\n#define p32 sqrt(3.)\n//\"inCircleHexagonTotalHeight\"=\"equilateralTriangle.y\"=\"hexagon.y\"=sixth.y\"=.5=\"trivial\" || \"hexagon.x\"=\"sixth.x\"=\"tricky\"=\n//pow(3.,1./2.)/2.= 97./112. =\"sixth.x\"=\"hexagon.x\"=sin(asin(1.)*2./3.)=sin(acos(-1.)/3.)=.866=\n#define p322 (p32/2.)\n//pow(3.,1./2.)/3.= 97./168. =.57735026919=\"useful for hexagonal scaling?\"\n#define p323 (p32/3.)\n//\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1 && 1/Phi=Phi-1\n//https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(), good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n//\"silverRatio\"=  https://en.wikipedia.org/wiki/Silver_ratio\n#define Phis (sqrt(2.)+1)\n//\n//pi8=pi/4  pi2=pi/2 : pi=3.14 _: tau=pi*2 \n#define pi4 acos( 0.)*.5/*eight  rotation in radians : cos(pi4)==sin(pi)*/\n#define pi2 acos( 0.)   /*quater rotation in radians =asin(1.) */\n#define pi  acos(-1.)   /*half   rotation in radians*/\n//#define tau pi*2.    /*full   rotation in radians =6.28*/\n#define tau 6.283185307179586476925286766559\n//substituring [pi] by [tau/2] can make things simpler (and more precise with floats)\n/*\nend__.const\nstart.const.struct\n*/\n//structs are more a namespace issue and less of a mathematic fundament as the above\n//enforcing sctructs makes it harder to confuse things for other things.\nstruct plane  {vec3 n;float d;}Mplane;//plane normal && DISTANCE <- NormalForm (is not the HNF !)\nstruct quat   {vec3 i;float r;}Mquat;//quaternion; axis.ijk && Angle\nstruct rotaAA {vec3 a;float r;}MrotaAA;//AxisAngleRotation; axis.xyz && Angle.w\nstruct sphere {vec3 c;float r;}Msphere;//sphere; center.xyz && radius.w\nstruct ray    {vec3 o;vec3  d;}Mray;//ray; origin && direction\n//todo, rotate plane and points by things.\n/*\nend__.const.struct\nstart.const.comm\n*/\n#define chank iChannel2\n#define tex(a,b) texture(a,b))\n#define pushing .2\n#define once .5\n#define toggle .7\n#define key(a,b) (tex(chank,vec2((.5+a)/256.),b).x >0.)\n//bool keyAtoggle=key(128,toggle);\n/*\n//IOU communication protocols to load data from other shaders:\n//Note that you NEVER need to write in other shaders\n//and you ONLY need good use of memory and timeouts to simulate \"patience\".\n/*\nend__.const.comm\n//\n//ALL parts of the above text (that are used by the functions below)\n//...should be equal for all shaders (that load data from each other)\n//...to avoid namespace cconflicts and unneccessary name changes.\n//To avoid version conflicts, the above gets a ConstantVersionID of:\n//cvid 15\n//                        and the below gets a MutableVersionID of\n//svid 20\n//\nstart.mutable\n*/\n#define Demo1d 0\n#define Demo2d 1\n#define DemoTiny 2\n#define DemoHgSdf 3\n#define DemoRaymarch 4\n#define DemoRaymarchUber 5\n//#define DemoAll 7 //i can dream of a mode that unifies all modes\n//todo IOU: the feature of switching modes by changing DemoNum is VERY incomplete.\n#define DemoNum 6\n//#define DemoNum Demo1d           -> show linear graph y=f(a)=f(a.x)=[*] || eg y=x*x;\n//#define DemoNum Demo2d           -> show 2d distance gradients.\n//all larger DemoNum are 3d        || commonly d=f(a.xy)=fract(length(a.xy)) ||=fract(min(a.x,a.y))\n//#define DemoNum DemoTiny         -> shows a tiny distance field with nice outlining\n//#define DemoNum DemoHgSdf        -> show ARRAY of a [*] DistanceField\n//                                    ...to test distance field collections\n//#define DemoNum DemoRaymarch     -> show a SINGLE [*] distance field that does not fur in the array\n//#define DemoNum DemoRaymarchUber -> show a SINGLE [fUberprim(*)] parametric distance field\n//#define DemoNum DemoRaymarchUber -> demonstrate rayTracing DFunctions\n\n//define what time is, how (fast) it changes or it if is paused at any value.\n#define time iTime\n//#define time .5\n//the specialty of time dimensions is that they hav a constant sign.\n//[time not having a constant sign] -> [no meaningful derivatives over time]\n//                                  -> [time dimension becomes spatial]\n#if DemoNum > Demo2d      /*at least 3d space*/\n //maximum raymarching iterations\n #define rmIterations 256\n //the lame solution for overstepping: scale steps by *lipschitsScale\n #define lipschitsScale .5\n //because scaling a first derivative is fun and totally awesome, not!\n //return s3d sinusoidial \"blob_displacement\" of [p].\n #define blob(p) (sin(p.x)*sin(p.y)*sin(p.z))\n#endif /*DemoNum > Demo2d, is at least 3d */\n//\n#define eps 2e-2\n//.02*(sin(tt)*.5+.6)\n//1e-2\n//#if DemoNum > 0  /*at least 2d space*/\n vec2 _A=normalize(vec2(eul, 1.));\n vec2 _B=normalize(vec2(1.,Phi));\n//#endif /*DemoNum > Demo1d, is at least 2d */\n/*\nend__.mutable\nstart.solver\n*/\n//return ifb(a,b,c); is identical to if(a<0.){return b;}else{return c;} but branchless:\n#define ifb(a,b,c) (b+(c-b)*step(a,0.))\n//branchless code -> longer pipelines on newer hardware -> likely better performance.\n//branchless code -> +1add +1mult, even slower on older hardware.\n//branchless code -> b & c are both calculated and substracted.\n//... this can cause extra calculations and more rounding errors. as only one difference of b and c matters.\n\n//a lot of things solve efficiently with inverse(m) of matrix [m].\n//m*inverse(m)=mat3(1)=mat2(1,0,0,0,1,0,0,0,1);\n//if(determinant(m)==0)matrix is its own inverse (matrix changes nothing);\n//calculaitng an inverse is tricky in higher dimensions.\n//due to division of: inverse(m)==adjugate(m)/determinant(m)\n//... we seperate adjugate(m) and determinant(m) for higher precision.\n\n//in 2d this is simple:\n//[2d determinant() in 2 other types]=det()=determinant()\nfloat det(mat2 a){return determinant(a);}//shorthand avoids reserved namespace\nfloat det(vec2 a,vec2 b){return det(mat2(a,b));}//return a.x*b.y-b.x*a.y;)\nfloat det(float a[2],float b[2]){return det(mat2(a[0],a[1],b[0],b[1]));}//return a[0]*b[1]-b[0]*a[1];)\n\n//return inverse of m, multiplied by its determinant(m)\nmat2 adjugate(mat2 m){vec4 n=vec4(m);return mat2(n.w,-n.yz,n.a);}\n //return mat2(m[1][1],-m[1][0],-m[0][1],m[0][0]);\n//https://www.mathsisfun.com/algebra/matrix-inverse.html\n\n#define skipli for(int i=0;i<e;i++){r[i+int(step(skip-float(i),0.))]=a[i];}return r;}\n#define skipl a[3],float skip){int e=a.length()-1\n//return sublist of a, without entry number#[skip]\n//int[2]   listSkipI(int  skipl,      r[2];skipli\n//float[2] listSkip(float skipl;float r[2];skipli\n\n/*\n//adjugates in 3d it get trickier:\nmat3 adjugate(mat3 m){\n mat3 r=mat3(0);\n for (int i=0;i<4;i++){\n  for (int j=0;j<4;i++){\n   float s=-2.*(float(i+j)*.5);//s=sign of checperboardMatrix at m[i][j]\n// https://www.mathsisfun.com/algebra/matrix-inverse-minors-cofactors-adjugate.html\n   int count[3]=int[3](0,1,2);\n   int c2[2]=listSkipI(count,float(j));\n   int nullth=c2[0];\n   int first =c2[1];\n   //above calculates that .y parameter are NOT skipped.\n   //a is the LEFTMOST sub-column\n   float a[2]=listSkip(float[3](m[0][nullth],m[1][nullth],m[2][nullth]),float(j));\n   //b is the RIGHTMOST sub-column\n   float b[2]=listSkip(float[3](m[0][first],m[1][first],m[2][first]),float(j));\n   r[i][j]=s*det(a,b);//det(aa,bb)==entry[i][j] of \"matrix of minors\"\n }}return transpose(r);}\n*/\n\n/*\n//return vec3(a,b,c) that makes all input equations true.\n//p contains \"solutions\", one side of the equation\n//x,y,z store factors on the other side of the equations:\n//1=2*a+3*b+4*c -> p.x=1; a=vec3(2,3,4)\n//5=6*a+7*b+8*c -> p.y=5; b=vec3(6,7,8)\n#define sr if(determinant(m)==0.)return p;return inverse(m)*p;}\nvec2 solve(vec2 p,vec2 x,vec2 y){mat2 m=transpose(mat2(x,y));sr\nvec3 solve(vec3 p,vec3 x,vec3 y,vec3 z){mat3 m=transpose(mat3(x,y,z));sr\nvec4 solve(vec4 p,vec4 x,vec4 y,vec4 z,vec4 w){mat4 m=transpose(mat4(x,y,z,w));sr\n//opengl goes ColumnsBeforeLines: check (determinant(m)!=0) before solvem() \n#define solvem(p,m) (inverse(m)*p)\n//https://www.mathsisfun.com/algebra/systems-linear-equations-matrices.html\n*/\n    \n//IOU gaussian Elimination\nmat2 GaussianElimination(mat2 m){return mat2(0);}\nmat3 GaussianElimination(mat3 m){return mat3(0);}\nmat4 GaussianElimination(mat4 m){return mat4(0);}\n\n//////solver.end\n//\n//////hash.start ---------------- \"h[*]\"\n\n//IOU - pseudoRandom stuffs.\n//hashes are better when they are pseudoRandom, with an unpredictable seed-stream.\n\n//hashes take the namespace \"h[*]\"\n//hashes project one set (of numbers) to another (smaller) set (of numbers).\n//a more constant input part of a hash is called \"seed\". \n//seeds can be constant or streamed video or audio, to include change over time.\n//\n//hashes include sin() or fract() as final operation and approximate irrational \n//...numbers within that to more evenly distribute the result of any non-seed-input.\n//Simplest most evenly distributing most predictable hash, plants love it:\n#define hPhi(seed,a) (a*fract(seed*Phi))\n//above is used by plants, below is better for type int due to smaller intDivisions\n#define hphi(seed,a) (a*fract(seed*phi))\n//But you want the results of consecutive hashes to be good pseudo-randoms-values.\n//\n//A hash reduces information, if only by rounding.\n//A hashes result can be spread over more output dimensions than its input dimensions.\n//this does not create information out of thin air, but can give the illusion of that.\n\n/*\n//return float range [0..1] from uint[n] : by Hugo Elias:\nfloat hash(uint n){n=(n<<13U)^n;n=n*(n*n*15731U+789221U)+1376312589U;\n //return 1.-float(n&0x7fffffffU)/float(0x7fffffff);}//older approach from https://iquilezles.org/articles/sfrand\n return uintBitsToFloat((n>>9U)|0x3f800000U)-1.0;}\n*/\n\n//////hash.end\n//\n//////noise.start\n\n//\"noise\" comes down to being a smoothenedHash==HashesNthDerivative\n\n//simple fast smooth noise, uses texture2D() as seed.\n/*float nC(in vec3 x){vec3 p=floor(x),f=fract(x);f=f*f*(3.-2.*f);\t\n vec2 rg=texture2D(iChannel0,((p.xy+vec2(37.,17.)*p.z)+f.xy+.5)/256.,-100.).yx;\n return mix(rg.x,rg.y,f.z);}/**/\n\nvec2 M;\n/*\nvec4 noise(vec2 u){u=mod(u,M.x)+M.y; // mod() avoids grid glitch\n u-=.5;return vec4(hash(uint(u.x+iResolution.x*u.y)));}\n*/\n#define V(i,j)  noise(u+vec2(i,j))\n/*\nvec4 bluenoise(vec2 u){//U=floor(U/8.); \n vec4 n=8./9.*noise(u)-1./9.*(V(-1,-1)+V(0,-1)+V(1,-1)+V(-1,0)+V(1,0)+V(-1,1)+V(0,1)+V(1,1));  \n return n*2.+.5;}   // or *1 to avoid saturation at the price of low contrast\n//https://www.shadertoy.com/view/XdScRt\n*/\n\n//////noise.end\n//\n//////color.start\n\n//IOU hsl2rgb\n//IUO all the nice 3d gradients.\n\n// return color from temperature in kelvin\n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp){\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) return col*Temp/1000.;\n   \treturn col;}\n//to be replaced by\nvec3 blackbody2(float k){float p=pow(k,-3./2.),\n g=0.;//green is approximated in 2 ways, depending on k.\n if(k>6500.)g=138e3*p+.721;else g=.39*log(k)-2.45;\n vec3 c=clamp(vec3(22e4*p+.58,g,.76*log(k)-5.68),0.,1.);\n //if(k<1e3)return c*k*.001;//extra black.\n return c;}\n\n//////color.end\n//\n//////transform.start\n\n//this one focuses on 2d transforms:\n\n//2d rotation r=3.14 -> half rotation roundrclockwise\n#define r2d(r) mat2(cos(r),-sin(r),sin(r),cos(r))\n\n//return matrix of complex multiplication of [a] by [b]\n#define cmul(a,b) mat2(a,-a.y,a.x)*b\n//return matrix of complex division       of [a] by [b]\n#define cdiv(a,b) a*mat2(b,-b.y,b.x)/dot(b,b)\n\n//3d transforms\n//return vector [p] rotated by angle [r] around axis [a]\n#define raa(p,a,r) (cos(r)*v+sin(r)*cross(a,v)+(1.-cos(r))*dot(a*p)*a)\n\n//////transform.end\n//\n//////tracing.start\n\n//raytracing returns intersection points||distances\n//which comes down to solving a 2nd to 6th degree spline\n//for all the points where f(x)=0, with 0 to 6 solutions for 6th gegree splines.\n//Raytacing is useful to calculate bounding shapes for raymarching\n\n//raytracing an elypsoid\n\n//[h.xyz],[h.w]=paneNormal,paneDistanceToVec3(0)\n//[o],[d]=TayOrigin,RayDirection\n//return distance along ray to intersection of plane along ray \nfloat gPRxZ(plane p,ray r){return -((dot(p.n,r.o)+p.d)/(dot(p.n,r.d)));}\n#define PlaneRayDistance(p,r) gPRxZ(p,r)\n//return intersection of ray[r] anf plane[p]\nvec3 gPRdV(plane p,ray r){return r.d*gPRxZ(p,r);}\n#define PlaneRayIntersection(p,r) gPRdV(p,r)\n\nvec3 RayTraceDemo(plane p,ray r){\n float d=PlaneRayDistance(p,r);//ditance=distanceOnRayToPlane\n vec3 c=r.d*fract(d)*pow(d,-.3);//color=fades to black with distance\n vec3 Out=c;\n return Out;\n}\n\n//#if DemoNum == DemoRaymarch\n//[o]=rayOrgin [d]RayDirection, sets up a planeto collide ray with.\nvec3 RayTraceDemoScene(vec3 o,vec3 d){\n plane p=plane(vec3(0,1,0),1.);\n ray r=ray(o,d);\n vec3 Out=RayTraceDemo(p,r);\n return Out;\n}\n//#endif\n\n//return vector that points from point[p] to nearest place on plane[h]\nvec3 gPXdV(plane h,vec3 p){\n return -(dot(h.n,p)+h.d)*h.n;}\n\n//////tracing.end\n//\n//////marching.hg_sdf.start\n\n//primarily sorted by dimensions\n//secondarily sirted by types; [field],[transform],[merger]\n//\n//All p* functions return a transformed [p], like a [p=matrix*p;] transformation.\n//All pM* functions return #'s of the modulo tile, while inout transforming p\n\n#define saturate(x) clamp(x,0,1)\n#define dd(p) dot(p,p)\n#define am(a,b) (abs(a)-b)\n//1to4d\nfloat vmax(vec2 p){return max(p.x,p.y);}\nfloat vmax(vec3 p){return max(vmax(p.xy),p.z);}\nfloat vmax(vec4 p){return max(vmax(p.xy),vmax(p.zw));}\nfloat vmin(vec2 p){return min(p.x,p.y);}\nfloat vmin(vec3 p){return min(vmin(p.xy),p.z);}\nfloat vmin(vec4 p){return min(vmin(p.xy),vmin(p.zw));}\nfloat vsum(vec2 p){return p.x+p.y;}\nfloat vsum(vec3 p){return vsum(p.xy)+p.z;}\nfloat vsum(vec4 p){return vsum(p.xy)+vsum(p.zw);}\nvec2  vpow(vec2 a,float n){return pow(a,vec2(n));}\nvec3  vpow(vec3 a,float n){return pow(a,vec3(n));}\nvec4  vpow(vec4 a,float n){return pow(a,vec4(n));}\n#define vmm(a) vmax(am(a,0.));\n//distance to sphere with radius (is subroutine)\n#define fSphere(p,r) (length(p)-r)\n#define ml(a,l) max(a,length(l))\n#define fBoxCheap(p,b) return vmax(am(p,b);\n//fBoxCheap() extrudes to box : fBox() extrudes to ROUNDED box\n\n//https://iquilezles.org/articles/distfunctions\n#define lengthN(a,e) pow(vsum(vpow(a,e)),1./e)\n//#define length8(a) pow((pow(a,vec2(8.)),vec2(1./8.)))\n\n#define pmm p*=mod(c,2.)*2.-1.;return c;}\n#define pm c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\n//1d not0 //linear f(x)functions were f(0)=f(planck) ->discontinuity\n//therefore f(0)==f(pow2(-126)) != 0. ;\nfloat sgn(float x){return step(x,0.)*2.-1.;}//return (x<0)?-1:1;\n//hull-curves with descriptive names: p[-1..1] r[0..1] -> .y[0..1]\n//https://www.shadertoy.com/view/lsscR2\n#define powm(a) (1.-pow(a))\n#define fpr float p,float r){return\nfloat fhTongueButt(     fpr 1.-pow(abs(p),r);}\nfloat fhTongueIncube(   fpr 1.-pow(max(0.,abs(p)*2.-1.),r);}\nfloat fhTongueSinButt(  fpr 1.-pow(abs(sin(pi2*p)),r);}\nfloat fhSinSphereOncube(fpr pow(    cos(pi2*p),r);}\nfloat fhTentDomeOncube( fpr pow(min(cos(pi2*p),1.-abs(p)),r);}\n/*\n//tent-shaped hull curves\n    vec2 u = fragCoord.xy / iResolution.xy;\n\t//u.x = (u.x - 0.5) * 2.0;\n    u.x*=iResolution.x/ iResolution.y;\n    u.x-=1.;\n    float a = (0.5 + 0.5 * sin(iTime)) * 5.5;\n    //a=.5;\n    float r=fhTongueButt(u,a);\n    float g=fhTongueIncube(u,a);\n    float b=fhTongueSinButt(u,a);\n    float y=fhSinSphereOncube(u,a);\n    float p=fhTentDomeOncube(u,a);\n    //col.r +=fract(r -uv.y);\n    //col.g +=fract(g -uv.y);\n    //col.b +=fract(b -uv.y);\n    //col.rg+=fract(y-uv.y);\n    //col.rb+=fract(p-uv.y);\n    col+=vec3(fract(mix(p,g,.5)-uv.y));\n*/\n// convert distance to alpha for nice \"logarytmhic glow\"\nfloat dtoa(float d,float a){a=1./a;\n return clamp(a/(clamp(d,a,1.)),0.,1.);}\n//usage as in https://www.shadertoy.com/view/XtjGzt\n//c=mix(c,vec4(1,.5,0),.7 *dtoa(distance,60.));\n\n\n//1d pM*\nfloat pMod1(inout float p,float s){\n float c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModMirror1(inout float p,float s){float c=pMod1(p,s);pmm\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);if(p>=0.)p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pMod1(p,s);\n if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModPolar(inout vec2 p,float t){float g=tau/t,a=atan(p.y,p.x)+g*.5,r=length(p),c=floor(a/g);a=mod(a,g)-g*.5;p=vec2(cos(a),sin(a))*r;if(abs(c)>=t*.5)c=abs(c);return c;}\nfloat pMirror(inout float p,float d){float s=(p<0.)?-1.:1.;//s=step(p,0.)*2.-1.;\n p=am(p,d);return s;}\nfloat pReflect(inout vec3 p,vec3 n,float o){float t=dot(p,n)+o;if(t<0.){p=p-(t+t)*n;}return (t<0.)?-1.:1.;}\n//bend around point that is offset -20. on the p.y axis.\nvec3 pCheapBend(vec3 p){return vec3(r2d(20.*p.y)*p.xy,p.z);}\n//ztwist p around p,y axis.\nvec3 pTwist( vec3 p ){return vec3(r2d(20.*p.y)*p.xz,p.y);}\nvoid pR(inout vec2 p,float r){p=cos(r)*p+sin(r)*vec2(p.y,-p.x);} \n//eight-rotation (45°/360°)\nvoid pR45(inout vec2 p){p=(p+vec2(p.y,-p.x))*p222;}\n//2d.f\nfloat fBox2(vec2 p,vec2 b){vec2 q,d=am(p,b);//fBox2()=ROUNDED box,different in 3d and 2d.\n return length(max(d,0.))+vmm(p)} \n//egg= weighted ellipse -> \"Cartesian Oval\" //.z=weightFactor\nfloat fEllipseW(vec2 p,vec3 a,vec3 b,float r){\n return length(p-a.xy)*a.z+length(p-b.xy)*b.z-r;}\n//https://www.shadertoy.com/view/lld3DS\nfloat fNgon(in vec2 p,float N){p=p*2.-1.;//centring\n float a=atan(p.x,p.y);//a=atan(p.x/p.y);//fast mirrored\n return cos(floor(.5+a*N/tau)*tau/N-a)*length(p);  \n return cos(floor(.5+a*N/tau)*tau/N-a)*dot(p,p); \n return cos(floor(.5+a*N/tau)*tau/N-a)*dot(p,p)*length(p);\n}//https://www.shadertoy.com/view/4ldXDn\n//squircle  http://en.wikipedia.org/wiki/Squircle\nfloat sdSquircle(vec2 p, float r, float w){p=abs(p);\n return vsum(pow(p,vec2(w)))-pow(r,w);}         \n#define lvmm(a,b) return length(max(a,0.))+vmm(b)}\nfloat fCorner(vec2 p){lvmm(p,p)\nfloat fDisc(vec3 p,float r){\n float l=length(p.xz)-r;return l<0.?abs(p.y):length(vec2(p.y,l));}\n//2d.pM*\nvec2 pMod2(inout vec2 p,vec2 s){vec2 pm\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pMod2(p,s);pmm\nvec2 pModGrid2(inout vec2 p,vec2 size){\n vec2 c=floor((p+size*.5)/size);\n p=mod(p+size*.5,size)-size*.5;\n p*=mod(c,2.)*2.-vec2(1);p-=size*.5;\n if(p.x>p.y)p.xy=p.yx;return floor(c*.5);}\nvec2 pMirrorOctant (inout vec2 p,vec2 dist){\n vec2 s=vec2((p.x<0.)?-1.:1.,(p.y<0.)?-1.:1.);\n pMirror(p.x,dist.x);pMirror(p.y,dist.y);if(p.y>p.x)p.xy=p.yx;return s;}                    \n//3d.f\n\n//[n]planeNormal [d]=planeDistanceToVecN(0) (aka. hessian normal form)\n#define fPlane(p,n,d) (dot(p,n)+d)\n#define pa in vec3 p,in vec3 a\n#define pab pa,in vec3 b                                     \n#define pr in vec3 p,in float r\nfloat fBox(pa){vec3 q,d=am(p,a);//fBox()=ROUNDED box,different in 3d and 2d.\n return length(max(d,0.))+vmax(min(d,0.));}\nfloat fBlob(vec3 p){p=abs(p);//no clue\n if(p.x<max(p.y,p.z))p=p.yzx;if(p.x<max(p.y,p.z))p=p.yzx;\n float l=length(p),b=max(max(max(dot(p,vec3(p323)),dot(p.xz,_A)),dot(p.yx,_B)),dot(p.xz,_B));\n return l-1.5-.15*cos(min(sqrt(1.01-b/l)*4.*pi,pi));}\nfloat fCylinder(pr,float h){//extrudes to cylinder\n return max(fSphere(p.xz,-r),am(p.y,h));}\nfloat fLineSegment(pab){vec3 c=b-a;float t=clamp(dot(p-a,c)/dot(c,c),0.,1.);return length(c*t+a-p);}\n//lineSegment() has other input values than fCapsule()\nfloat fCapsule(pab,float r){return fLineSegment(p,a,b)-r;}\n//above is smarter reuse of code\nfloat fCapsule(pr,float c){\n return mix(length(p.xz)-r,fSphere(vec3(p.x,am(p.y,c),p.z),r),step(c,abs(p.y)));}\nfloat fTorus(pr,float c){//r and i input positions swapped!\n return fSphere(vec2(fSphere(p.xz,r),p.y),c);}\n//fCircle() is a torus were r sets both radii.1sub less\n#define fCircle(p,r) length(vec2(p.y,fSphere(p.xz,r)))\n//https://iquilezles.org/articles/distfunctions\n#define hm1 vec3 p,vec2 h){vec3 q=abs(p);return max(q.y-h.y,max(q.x*p322\nfloat fTriPrism           (hm1+p.z*.5,-p.z)-h.x*.5);}\nfloat fHexagonCircumcircle(hm1+q.z*.5, q.z)-h.x);}\nfloat fHexagonIncircle(vec3 p,vec2 h){return fHexagonCircumcircle(p,vec2(h.x*p322,h.y));}\nfloat fCone(pr,float h){\n vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=normalize(vec2(h,r));\n float j=dot(t,vec2(m.y,-m.x)),d=max(dot(t,m),-q.y);\n if(q.y>h&&j<0.)d=ml(d,t);\n if(q.x>r&&j>length(vec2(h,r)))d=ml(d,q-vec2(r,0.));return d;}\nfloat fEllipsoid(in vec3 p,in vec3 r){\n return fSphere(p/r,1.)*vmin(r);}\n//euclidean distance(a,b)=length(a-b) has exponent[n]=[2]; here [n] can be other EVEN number exponents.\nfloat fTorusN2( vec3 p,vec2 t,float n){\n return lengthN(vec2(length(p.xz)-t.x,p.y),n)-t.y;}\nfloat fTorus82(vec3 p,vec2 t){return fTorusN2(p,t,8.);}\nfloat fTorusNN(vec3 p,vec2 t,float n1,float n2){\n vec2 q=vec2(lengthN(p.xz,n1)-t.x,p.y);return lengthN(q,n2)-t.y;}\n                      \nfloat fUnterprim(vec3 p,vec4 s,vec3 r,vec2 ba,float sz2){\n vec3 d=abs(p)-s.xyz;float q=length(max(d.xy,0.))+min(0.,max(d.x,d.y))-r.x;\n #ifndef CONVEX    \n q=abs(q)-s.w;\n #endif    \n vec2 px=vec2(q,p.z-s.z),\n diag=px-vec2(r.z,sz2)*clamp(dot(px,ba),0.,1.),\n h0=vec2(max(q - r.z,0.0),p.z + s.z),\n h1=vec2(max(q,0.0),p.z-s.z);\n return sqrt(min(dot(diag,diag),min(dot(h0,h0),dot(h1,h1))))\n  *sign(max(dot(px,vec2(-ba.y,ba.x)),d.z))-r.y;}\n//https://www.shadertoy.com/view/MsVGWG\n//[s]=width,height,depth,thickness\n//[r]=xy corner radius,zCornerRadius,bottomRadiusOffset\nfloat fUberprim(vec3 p, vec4 s, vec3 r){//these operations can be precomputed\n s.xy-=r.x;\n #ifdef CONVEX  \n r.x-=r.y;\n #else\n r.x-=s.w;s.w-=r.y;\n #endif\n s.z-=r.y;vec2 ba=vec2(r.z,-2.*s.z);return fUnterprim(p,s,r,ba/dd(ba),ba.y);}\nfloat fUcube    (vec3 p){return fUberprim(p,vec4(1),vec3(0));}\nfloat fUcylinder(vec3 p){return fUberprim(p,vec4(1)          ,vec3(1,0,0));}\nfloat fUcone    (vec3 p){return fUberprim(p,vec4(0,0,1  ,1  ),vec3(0,0  ,1));}\nfloat fUpill    (vec3 p){return fUberprim(p,vec4(1,1,2  ,1  ),vec3(1,1  ,0));}\nfloat fUsphere  (vec3 p){return fUberprim(p,vec4(1          ),vec3(1,1  ,0));}\nfloat fUpellet  (vec3 p){return fUberprim(p,vec4(1,1,.25,1  ),vec3(1,.25,0));}\nfloat fUtorus   (vec3 p){return fUberprim(p,vec4(1,1,.25,.25),vec3(1,.25,0));}\nfloat fUpipe    (vec3 p){return fUberprim(p,vec4(1          ),vec3(1,.1 ,0));}\nfloat fUcorridor(vec3 p){return fUberprim(p,vec4(1,1,1  ,.25),vec3(1,.1 ,0));}\n//3d.pM*\nvec3 pMod3(inout vec3 p,vec3 s){vec3 pm\n//1d.fOp* take 2 distances (a,b) + parameters ([r][ra][rb]=radii,[n]=NumberOfThings)\n//*union*     ==a || b, volumetric union        == both volumes together\n//*intersect* ==a && b, volumetric intersection == only the shared volume\n//*difference*==a &&!b, volumetric difference   == volumeA-VolumeB\n//\n//*Chamfer ==diagonal cut\n//*Round   ==negative cylinder cut          \n//*Columns ==positive cylinder cut\n//*Stairs  ==stair cut\n//*Soft    ==cubic \"melt\"\n\n//a lot of hg_sdf library as one liners:\n#define ac4(b) (a-b)*p222)\n#define mac4(a,b) max(a,ac4(b)\nfloat fOpUnionChamfer       (float a,float b,float r){\n return min(min(a,b),ac4(r+b);}\nfloat fOpIntersectionChamfer(float a,float b,float r){\n return mac4(max(a,b),-b);}\n#define fOpDifferenceChamfer(a,b,r) fOpIntersectionChamfer(a,-b,r)\nfloat fOpUnionRound(float a,float b,float r){\n vec2 u=max(vec2(r-a,r-b),0.);return max(r,min(a,b))-length(u);}\nfloat fOpIntersectionRound(float a,float b,float r){\n vec2 u=max(vec2(r+a,r+b),0.);return min(-r,max(a,b))+length(u);}\nfloat fOpDifferenceRound(float a,float b,float r){return fOpIntersectionRound(a,-b,r);}\n#define _M(S) (float a,float b,float r,float n){float c,m=min(a,b);if(a>r||b>r)return S*m;vec2 p=vec2(a,b);c=r*1.41421356237/(n*2.-0.58578643762);pR45(p);\nfloat fOpUnionColumns _M(1.)p.x+=p222*(-r)+p222*(c*2.);\n if(mod(n,2.)==1.)p.y+=c;pMod1(p.y,c*2.);\n return min(min(min(length(p)-c,p.x),a),b);}\nfloat fOpDifferenceColumns _M(-1.)p.y+=c;p.x-=p222*(r+c);\n if(mod(n,2.)==1.)p.y+=c;pMod1(p.y,c*2.);\n return-min(min(max(-length(p)+c,p.x),a),b);}\n#define fOpIntersectionColumns(a,b,r,n) fOpDifferenceColumns(a-b,r,n)\nfloat fOpUnionStairs(float a,float b,float r,float n){\n float s=r/n;float u=b-r;\n return min(min(a,b),.5*(u+a+abs(mod(u-a+s,2.*s)-s)));}\n#define fOpIntersectionStairs(a,b,r,n) -fOpUnionStairs(-a,-b,r,n)\n#define fOpDifferenceStairs(a,b,r,n) -fOpUnionStairs(-a,b,r,n)\n//a smoother fOpUnionRound(), by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a,float b,float r){float e=max(r-abs(a-b),0.);return min(a,b)-e*e*.25/r;}\n//cylindical pipe that runs along the intersection.\nfloat fOpPipe(float a,float b,float r){return length(vec2(a,b))-r;}\n//// first object gets a v-shaped engraving where it intersect the second\nfloat fOpEngrave(float a,float b,float r){return max(a,(a+r-abs(b))*sqrt(.5));}\n// first object gets a U-shaped capenter-style groove cut out\nfloat fOpGroove(float a,float b,float ra,float rb){return max(a,min(a+ra,rb-abs(b)));}\n// first object gets a capenter-style tongue attached (negative groove)\nfloat fOpTongue(float a,float b,float ra,float rb){return min(a,max(a-ra,abs(b)-rb));}\n//metabally union of 7: //https://www.shadertoy.com/view/Xls3R7\nfloat fOpBlob7(float d1,float d2,float d3,float d4,float d5,float d6,float d7){float k=-2.;\n return -log(exp(k*d1)+exp(k*d2)+exp(k*d3)+exp(k*d4)+exp(k*d5)+exp(k*d6)+exp(k*d7))/-k;}\n//////marching.hg_sdf.end\n            \n\n\n//use cases for hg_sdf functions\nfloat hg_sdf_demo(vec3 p){\n float t=sin(time)*.01+.02;\n mat2 m=r2d(time*.1);//rotation.2d\n //rotate world==rotate camera\n //p.yz*=m;p.xy*=m;//uses same 2d rotation 2x on different axes\n \n #ifndef hgSdfShowUber\n  //pMirrorOctant(p.xy,vec2(1.,1.));\n  pModMirror1(p.x,.5);  \n  pModMirror1(p.y,.5);\n  pModMirror1(p.z,.5);\n  m=r2d(time*.5);//rotation.2d\n  //rotate within tile-grid\n  //p.yz*=m;p.xy*=m;//uses same 2d rotation 2x on different axes\n #else\n  p-=vec3(0,0,4);\n  p*=2.;\n  p=p.zxy; \n  m=r2d(time*.2);\n  p.yz*=m;p.xz*=m;//uses same 2d rotation 2x on different axes\n  return fUberprim(p,vec4(0,4,2,0)*.2,vec3(-2,1.5,1.5));\n  return fUcorridor(p)-t*20.;\n  return fUcylinder(p)-t*20.;\n  return fUpipe(p)-t*20.;//rounded cylinder\n  return fUtorus(p)-t*20.;\n  return fUpellet(p)-t*20.;\n  return fUsphere(p)-t*20.;\n  return fUpill(p)-t*20.;\n  return fUcone(p)-t*20.;\n  return fUcylinder(p)-t*20.;\n  return fUcube(p)-t*20.;\n  #endif\n  \n  //return fdEllipsoid(p,vec3(1,2,3)*.05);\n  //return fPlane(p,vec3(2,2,0),1.);\n  float roundedSquareFrame=fTorusNN(p,vec2(.1,.0),4.,2.)-t;\n  float wheel             =fTorusN2(p,vec2(.1,.01),4.)-t;\n  //return wheel;\n  //return roundedSquareFrame;\n  float sphere  =fSphere(p,.08);\n  float cone    =fCone  (p,.02,.06)-t;\n//float circle  =fCircle(p,.05    )-t;//torus with less params\n  float torus   =fTorus (p.yxz,.03,.08)-t;\n//float disc    =fDisc  (p,.01    )-t;\n  float hex     =fHexagonCircumcircle(p,vec2(0.06,0.05))-t;\n  float triprism=fTriPrism(p,vec2(.1,.02))-t;\n  //  return triprism;\n  //return fHexagonIncircle(p,vec2(0.05,0.01))-t;\n//float capsule =fCapsule(p,.02,.04)-t;\n//float cylinder=fCylinder(p,.05,.02)-t;\n//float blob    =fBlob(p*.1); //???\n\n  //return sphere;\n  \n  float box     =fBox(p,vec3(.05))-t;\n//float bxcheap =fBoxCheap(p,vec3(.05))-.01;\n//float sphere  =fSphere(p,.1);\n  //return fOpIntersectionChamfer(box-.02,torus-.02,1.07);\n  //return fOpUnionSoft(torus,hex,.02);\n  //return fOpUnionColumns(torus,hex,.03,6.);\n  //return fOpUnionStairs(torus,hex,.03,6.);\n  //return fOpEngrave(hex,torus,.03);\n  //return fOpGroove(hex,torus,.03,0.04)-.01;\n  return fOpPipe(hex,torus,.03)+.01;\n  return hex;\n}\n\n//return distance of [p] to closest surface, defined by function.\n//.xyz can be additional texture values.\nvec4 df(vec3 p){\n  #ifdef hgSdf\n  vec3 h=p; h.z-=.1;h.x-=.1;return hg_sdf_demo(h);\n  #endif\n  p=fract(p);\n  float t=time*.1;\n  float k=20.*(sin(t*5.)*.5+.9);//blobbyness\n  return vec4(0,0,0,length(p*1.-0.5)-.2+.1*blob(k*p));}\n            \n            \n\nvec3 Gradient(vec3 p,float d){vec2 e=vec2(.001,0);p*=99.;\n return (vec3(df(p+e.xyy).w,df(p+e.yxy).w,df(p+e.yyx).w)*99.-d)/e.x;}\n            \nvec3 Normal(vec3 p){vec2 e=vec2(.01,0)\n    ;return normalize(vec3(\n df(p+e.xyy).w-df(p-e.xyy).w\n,df(p+e.yxy).w-df(p-e.yxy).w\n,df(p+e.yyx).w-df(p-e.yyx).w));}\nvec3 Normal2(vec3 p){if(df(p).w<.03)return Normal(p);return vec3(0);}\n\n#define dynamicEps\n\n//these branchless comparators compare [c] with [0.0] to return [a]==true or [b]==false;\n//based on \n//  https://www.reddit.com/r/askmath/comments/6aag2g/simplifying_stepa00step00a/\n//(c> 0)?a:b\n#define greater(a,b,c)   mix(a,b,step(c,0.))\n//(c< 0)?a:b\n#define less(a,b,c)      mix(a,b,step(0.,c))\n//(c==0)?a:b\n#define equals(a,b,c)    mix(b,a,step(c,0.)+step(0.,c)-1.)\n////#define equalsA(a,b,c) mix(b,a,(sign(c)+sign(-c))*.5)//here you can NOT substitute sign(-c) for=sign(c),because that implies a [signed null]!\n//----------- mirror symmetry mirror==swap outputs--------------------\n//(c!=0)?a:b\n#define unequal(a,b,c)   mix(a,b,step(c,0.)+step(0.,c)-1.)\n//(a>=0)?a:b   \"unless   \"=not less  ==greater OR equal\n#define unless(a,b,c)    mix(b,a,step(0.,c))\n//(c<=0)?a:b   \"ungreater\"=not greater==less    OR equal\n#define ungreater(a,b,c) mix(b,a,step(c,0.))\n            \n//\n//////raymarch.start\n\n//rm3 does 2*df() per rmIterations, but the loop unrolls to less code.\n            \n//d0.w== distanceTo                   surface           d0.xyz = texture\n//t0.w== distanceToCamera approaching surface           t0.xyz = texture\n//d1  == distanceTo                   Celshading Border\n//t1  == distanceToCamera approaching Celshading Border\n\n#define ReciprocalLipschitz .5\n//toon-shading may multiply 2 distances by:               0.<[ghostgloom].xy<=1.\n//one of the values should be ==1., the other should be;  0<n               <=1.\n//setting only .y lower makes it gloomy, celshading dominateswhat is below it\n//setting only .x lower makes it ghosty, testure below celshading bleeds into its cel.\n#define ghostgloom slideGhostGloom()            //vec2(1.,1.)\nvec2 slideGhostGloom(){float m=iMouse.x/iResolution.x-.5\n ;if(iMouse.z<=0.)m=cos(iTime)*.5\n ;if(m<0.)return vec2(1,1.+m*2.);return vec2(1.-m*2.,1)\n\n    ;}\nvoid rm3(vec3 o,vec3 r,inout vec4 t0,inout vec4 t1){for(int i=0;i<rmIterations;++i\n){float d0=df(o+r*t0.w).w\n ;float d1=df(o+r*t1.w).w//df() pointsDistances to 2 points along the ray.\n ;             t0.w+=d0*ReciprocalLipschitz*ghostgloom.x\n ;if(eps-d1<0.)t1.w+=d1*ReciprocalLipschitz*ghostgloom.y //step forward\n #ifdef dynamicEps\n ;d0=pow(abs(d0),pow(abs(t0.w),.5)); //oh boy, this was before logeps()\n   //d=exp(log(t)*.5)) //the transition into logeps()\n   //and tome calculus-fidldign later, we shift above into the logeps() below:\n   //DistanceIntegralEstimation is a poorly estimated/accumulated integral of previously measured distances, scaled by an arbitiary lipschitzFiddle\n   //DistanceIntegralEstimation would be better if it would include some bayesian-theorem code.\n   //this weights 2 factors against each other:\n     //over t*t disatance epsilon increases, ALL space shrinks to a singularity with increasing distanceToCamera as epsilon approaches infinity.\n     //over !/(DistanceIntegralEstimation*epsilon), epsilon decreases\n       //and we march further trough large voids AND less far in near surface-parallel/tangential rays.\n     //these 2 factors can be ballanced durprisingly easily, because its just 3 divisions of 3 factors.\n   //if (log(t*t/DistanceIntegralEstimation/epsilon)<0.)break; //logeps pseudocode\n   //which is rough, but VERY fast, for being logarythmic and 2 multiplications (one of them is a dot(a,a) and 1 division.\n  #endif\n ;if(d0<eps*.05)break;}}//calculate 2 distances at once is useful to:\n//- better visualize a distance field. -> analyze errors in the df easier.\n//- - it basically visualizes ONE first derivative!!!\n//- - as a transparent cartoon outline (half assed cellshading)\n            \n//////raymarch.end\n//\n//////main.start\n            \nvoid mainImage(out vec4 Out,in vec2 In){\n vec2 u=In.xy/iResolution.xy-.5;\n u.x*=iResolution.x/iResolution.y;\n vec3 o=vec3(0,0,-.2);//ray.Origin\n vec3 r=normalize(vec3(u,1));//ray.Direction\n mat2 m=r2d(time*.2);//rotation.2d\n r.yz*=m;r.xy*=m;//uses same 2d rotation 2x on different axes\n \n // Out=vec4( RayTraceDemoScene(o,r),1);return;\n  vec3 p;//point were a surface was hit\n  vec4 t=vec4(0),t2=vec4(0);\n  rm3(o,r,t,t2);\n  #if DemoNum == DemoHgSdf\n   //p=mix((o+r*t2),Normal2(o+r*t)*.5+.5,1.0);\n   //p=Gradient((o+r*t2),.01)*.5+.5;\n    p=Normal2(o+r*t)*.5+.5;\n  #else\n   p=o+r*t.w;\n   p=fract(p)*mod(p,3.)*t2.w*t2.w/(t.w*t.w*t.w);\n  #endif\n  //p=vec3(fract(t),fract(t2),0.);\n \n /*for STATIC image multipass:\n vec3 pp=texture(iChannel0,In/iResolution.xy).rgb*float(iFrame);\n pp+=p*.5;\n Out=vec4(pp/float(iFrame+1),1);\n*/\n Out=vec4(p,1);\n //#endif\n}\n\n//the i am tired dump:\n            \n//todo, i actually need a linear equation solver up to 6th gedree curves?\n//for many things, but mostly just to raytrace.\n//for that i need my decent 2d canvvas\n\n//pow(x,y) is internally doing exp(log(x)*y)\n//pow(2,y) is faster as pow2(y);\n\n// continuous angle from atan\nfloat cAtan(vec2 p){\n if (p.x< 0.) return acos(-1.)-atan(p.x,-p.y);\n return atan(p.x,p.y);}\n\n/*memos\n\n\n\nhttps://en.wikipedia.org/wiki/Volume_ray_casting\n\nhttps://en.wikipedia.org/wiki/Contour_line\nhttps://en.wikipedia.org/wiki/Isosurface\nlink surface nets to distance fields.\n\n//what i still have never done:\nhttps://en.wikipedia.org/wiki/Volume_ray_casting\n\n//optimizing\nhttps://en.wikipedia.org/wiki/Volume_rendering#Optimization_techniques\n\n\nsyntax:\nhttps://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Arrays\nconst float array[3] = float[3](2.5, 7.0, 1.5);\n\n*/\n            \n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}