{
    "Shader": {
        "info": {
            "date": "1494469239",
            "description": "klick mouse.\ni want to podMirror something\nand i also want to mirror it only once.\nso i merged it with pModInterval\nbut near the mirror shit gets strange.\nand i do not want it to be thi way",
            "flags": 0,
            "hasliked": 0,
            "id": "4dfBRn",
            "likes": 0,
            "name": "through the loking glass",
            "published": 3,
            "tags": [
                "mod",
                "modulo",
                "hgsdf",
                "pmod",
                "pmodmirror"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 610
        },
        "renderpass": [
            {
                "code": "#define diagonalRotation\n\n\n#define r2(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n\n\n//rotate p by angle r: p=r(p,r);\n#define r(p,r) (cos(r)*p+sin(r)*vec2(-p.y,p.x))\n//vec2 r(vec2 p,float t){return cos(r)*p+sin(r)*vec2(-p.y,p.x);\n//}//from https://www.shadertoy.com/view/XlfGzH\n\n\n\n\nvec2 frame(vec2 u){\n return u/iResolution.xy;\n u.x*=iResolution.x/iResolution.y;\n u*=.5;\n #ifndef diagonalRotation\n u*=r2(acos(-1.)/4.);\n #endif\n return u;\n}\n\n//see https://www.shadertoy.com/view/MdjcDd\n//from hg_sdf lib\nfloat pModMirror1interval(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0)*2. - 1.;\n    float start =-1.;\n    //above is pModMirror\n    //fused with\n    //below is pModInterval\n    float stop=0.;\n    if (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c );\n\t\tc = stop;\n\t}if (c <start) {\n\t\tp += size*(c);\n\t\tc = start;\n\t}return c;}\nvec2 mirr(vec2 u,float d){\n //float d=abs(u.x+1.);\n //d=.1;\n #ifdef diagonalRotation\n mat2 m=r2(acos(-1.)/4.);//matrix for 1(7 of full rotation\n #else\n mat2 m=mat2(1,0,0,1);//matrix of \"nothing changes\"\n #endif\n    //d=abs(u.x-u.y);\n u*=m;\n pModMirror1interval(u.x,sqrt(2.)*d);\n u*=inverse(m);\n return u;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 In ){\n vec2 d=iMouse.xy/iResolution.xy;   \n d-=.5;\n    \n //d*=sqrt(2.);\n vec2 u=frame(In);\n vec2 m=frame(iMouse.xy);\n float e=length(mirr(u-m,d.x+d.y));\n //e=smoothstep(.1,.0,e);\n e=fract(e*3.);\n fragColor = vec4(0.,0.,e,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}