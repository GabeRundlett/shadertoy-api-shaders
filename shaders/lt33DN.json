{
    "Shader": {
        "info": {
            "date": "1469374521",
            "description": "'W','S','A','D' or arrows for directions.\n'J' fire.\n\nScore reset on hit.:)  Sadly no explosion.",
            "flags": 48,
            "hasliked": 0,
            "id": "lt33DN",
            "likes": 10,
            "name": "[SH16C]StickRaid",
            "published": 3,
            "tags": [
                "game",
                "plane",
                "stg"
            ],
            "usePreview": 0,
            "username": "EvilRyu",
            "viewed": 1342
        },
        "renderpass": [
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n    \nconst vec2 plane_pos_uv=vec2(.5,.5);\nconst vec2 last_time_uv=vec2(1.5,.5);\nconst vec2 state_uv=vec2(2.5,.5);\nconst vec2 missle_uv=vec2(3.5,0.5);\nconst vec2 enemy_uv=vec2(0.5,1.5);\nconst vec2 bullet_dir_uv=vec2(0.5,16.5);\nconst vec2 bullet_uv=vec2(0.5,2.5);\n\nfloat segment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa=p-a, ba=b-a;\n    float h=clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-ba*h );\n}\n\nfloat plane(vec2 p,vec2 pos)\n{\n    p-=pos;\n    float d0=segment(p,vec2(0.0,0.15),vec2(0.0,0.0));\n    d0=smoothstep(0.01,0.015,d0);\n    float d1=segment(p,vec2(-0.1,0.115),vec2(0.1,0.115));\n    d1=smoothstep(0.01,0.015,d1);\n    float d2=segment(p,vec2(-0.035,0.0),vec2(0.035,0.0));\n    d2=smoothstep(0.01,0.015,d2);\n    float d=min(d0,d1);\n    d=min(d,d2);\n    return d;\n}\n\nfloat enemy0(vec2 p, vec2 pos)\n{   \n    p.y=-p.y;\n    float d0=plane(p,pos);\n    p-=pos;\n    p.x=abs(p.x)-0.1;\n    float d1=segment(p,vec2(-0.03,0.12),vec2(-0.03,0.15));\n    //float d1=segment(p,vec2(-0.1,0.07),vec2(0.0,0.11));\n    d1=smoothstep(0.01,0.015,d1);\n    float d=min(d0,d1);\n    return d;\n}\n\nfloat missle(vec2 p, vec2 pos)\n{\n    p-=pos;\n    float d0=segment(p,vec2(-.02,.0),vec2(-.02,.1));\n    d0=smoothstep(0.01,0.03,d0);\n    float d1=segment(p,vec2(.02,.0),vec2(.02,.1));\n    d1=smoothstep(0.01,0.03,d1);\n    return min(d0,d1);\n}\n\nfloat bullet(vec2 p,vec2 pos)\n{\n    float d=length(p-pos)-0.02;\n    d=smoothstep(0.01,0.02,d);\n    return d;\n}\n\nfloat border(vec2 p)\n{\n    p.x=abs(p.x)-2.;\n    float d0=segment(p,vec2(-1.,-1.),vec2(-1.,1.));\n    d0=smoothstep(0.01,0.03,d0);\n    float d=d0;\n    return d;\n}\n\n// print digits from iq's https://www.shadertoy.com/view/MddGzf\nfloat sampledigit(const in float n, const in vec2 vUV)\n{\n    if( abs(vUV.x-0.5)>0.5 || abs(vUV.y-0.5)>0.5 ) return 0.0;\n\n    // digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n    float data = 0.0;\n         if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n    else if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n    else if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    \n    vec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n    float fIndex = vPixel.x + (vPixel.y * 4.0);\n    \n    return mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat print_int(in vec2 uv, in float value)\n{\n    float res = 0.0;\n    float maxDigits = 1.0+ceil(.01+log2(value)/log2(10.0));\n    float digitID = floor(uv.x);\n    if( digitID>0.0 && digitID<maxDigits )\n    {\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = sampledigit( digitVa, vec2(fract(uv.x), uv.y) );\n    }\n\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    vec2 plane_pos=texture(iChannel0,plane_pos_uv/iChannelResolution[0].xy).xy;\n    vec2 state=texture(iChannel0,state_uv/iChannelResolution[0].xy).xy;\n    vec3 col=vec3(1.0);\n    if(abs(uv.x)<1.0&&abs(uv.y)<1.0)\n    {\n        col=10.0*texture(iChannel3,vec2(0.3*(uv.y+iTime*2.), 0.1*(uv.x-0.3))).xxx;\n    }\n    vec2 bullet_pos=vec2(0.,0.5);\n    float d=plane(uv,plane_pos);\n    \n    col=mix(col,vec3(.0),1.-d);\n    d=border(uv);\n    col=mix(col,vec3(.0),1.-d);\n    \n    for(int i=0;i<9;++i)\n    {\n        vec4 missle_info=texture(iChannel0,(missle_uv+vec2(i,0.0))/iChannelResolution[0].xy);\n        if(missle_info.z>0.0)\n        {\n            d=missle(uv,missle_info.xy);\n            col=mix(col,vec3(0.0,0.5,1.0),1.0-d);\n        }  \n    }\n    \n    for(int i=0;i<7;++i)\n    {\n        vec4 enemy_info=texture(iChannel0,(enemy_uv+vec2(i,0.0))/iChannelResolution[0].xy);\n        \n        if(enemy_info.z>0.0)\n        {\n            d=enemy0(uv,vec2(enemy_info.x,-enemy_info.y));\n            col=mix(col,vec3(0.),1.0-d);\n        }\n                    \n        for(int j=0;j<5;++j)\n        {\n            vec4 bullet_info=texture(iChannel0,(bullet_uv+vec2(j,i))/iChannelResolution[0].xy);\n            if(bullet_info.z>0.0)\n            {\n                d=bullet(uv,vec2(bullet_info.x, bullet_info.y));\n                col=mix(col,(1.0-d*7.2)*1.1*vec3(1.0,0.7,0.2),1.0-d);\n            }\n        }\n    }\n    \n    d=print_int( (uv-vec2(-1.8,0.8))*10.0, state.y+100. );\n\n    col = mix( col, vec3(0.0,0.0,0.0),d);\n    float t=length(uv-plane_pos-vec2(0.0,0.11))-0.02*(0.5+0.5*sin(iTime*7.));\n    t=smoothstep(0.01,0.02,t);\n    col=mix(col,vec3(1.2,0.0,0.0)*(0.5+0.5*sin(iTime*7.)),1.0-t);\n    if(state.x>0.0)col=mix(col,vec3(1.0,0.0,0.0),0.5);\n    fragColor=vec4(col,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "music",
                        "id": 19,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define ARROW 0\nconst vec2 plane_pos_uv=vec2(.5,.5);\nconst vec2 last_time_uv=vec2(1.5,.5);\nconst vec2 state_uv=vec2(2.5,.5);\nconst vec2 missle_uv=vec2(3.5,0.5);\nconst vec2 enemy_uv=vec2(0.5,1.5);\nconst vec2 bullet_dir_uv=vec2(0.5,16.5);\nconst vec2 bullet_uv=vec2(0.5,2.5);\n\nconst float ENEMY_LIFE=10.0;\n    \n#if ARROW\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n#else\nconst float KEY_UP = 87.5/256.0;\nconst float KEY_DOWN = 83.5/256.0;\nconst float KEY_LEFT = 65.5/256.0;\nconst float KEY_RIGHT = 68.5/256.0;\n#endif\nconst float KEY_J = 74.5/256.0;\n\nmat2 rot(float t)\n{\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\nvec2 hash(vec2 p)\n{\n    p=fract(p*vec2(5.3983, 5.4427));\n    p+= dot(p.yx, p.xy+vec2(21.5351, 14.3137));\n    return fract(vec2(p.x*p.y*95.4337, p.x*p.y*97.597));\n}\nfloat hash(float p)\n{\n    vec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n    return fract(p2.x * p2.y * 95.4337);\n}\n\nvec4 loadbuf(vec2 pos)\n{\n    return texture(iChannel0,pos/iChannelResolution[0].xy);\n}\n\nvoid storebuf(vec2 pos,vec4 val,vec2 fragCoord,inout vec4 fragColor)\n{\n    if(abs(fragCoord.x-pos.x)<0.01&&abs(fragCoord.y-pos.y)<0.01)\n        fragColor=val;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if( fragCoord.x > 32. || fragCoord.y>32. ) discard;\n    vec2 state=loadbuf(state_uv).xy;\n    vec2 plane_pos=loadbuf(plane_pos_uv).xy;\n    float last_time=loadbuf(last_time_uv).x;\n        \n    float right=texture(iChannel1, vec2(KEY_RIGHT,0.25)).x;\n    float left=texture(iChannel1, vec2(KEY_LEFT,0.25)).x;\n    float up=texture(iChannel1,vec2(KEY_UP,0.25)).x;\n    float down=texture(iChannel1,vec2(KEY_DOWN,0.25)).x;\n    float fire=texture(iChannel1,vec2(KEY_J,0.25)).x;\n\n    plane_pos.x+=0.02*(right-left);\n    plane_pos.y+=0.02*(up-down);\n    plane_pos.x=clamp(plane_pos.x, -0.9,0.9);    \n    plane_pos.y=clamp(plane_pos.y, -1.0,0.9);\n\n    fragColor=vec4(.0);\n    \n    vec4 enemy_info[8];\n    enemy_info[0]=loadbuf(enemy_uv+vec2(0.,.0));\n    enemy_info[1]=loadbuf(enemy_uv+vec2(1.,.0));\n    enemy_info[2]=loadbuf(enemy_uv+vec2(2.,.0));\n    enemy_info[3]=loadbuf(enemy_uv+vec2(3.,.0));\n    enemy_info[4]=loadbuf(enemy_uv+vec2(4.,.0));\n    enemy_info[5]=loadbuf(enemy_uv+vec2(5.,.0));\n    enemy_info[6]=loadbuf(enemy_uv+vec2(6.,.0));\n    enemy_info[7]=loadbuf(enemy_uv+vec2(7.,.0));\n    //enemy_info[8]=loadbuf(enemy_uv+vec2(8.,.0));\n\n    // at most 9 missles at the same time.\n    for(int i=0;i<9;++i)\n    {\n        vec4 missle_info=loadbuf(missle_uv+vec2(i,.0));\n        // empty slot for a new missle\n        if(missle_info.z<1.0)\n        {\n            missle_info.xy=plane_pos+vec2(.0,0.1);\n            if(fire>0.0)\n                missle_info.z=1.0,fire=0.0;\n        }\n        \n        missle_info.y+=0.08*missle_info.z;\n        \n        // out of screen, clear the slot\n        if(missle_info.y>1.2)\n        {\n            missle_info.z=missle_info.y=0.0;\n        }\n        // check collision with missle\n        for(int j=0;j<8;++j)\n        {\n            if(enemy_info[j].z * missle_info.z>0.0 &&\n               length(missle_info.xy-enemy_info[j].xy+vec2(.0,0.1))<0.13)\n            {\n                missle_info.z=missle_info.y=0.0;\n                enemy_info[j].w+=1.0;\n            }\n        }\n        \n        storebuf(missle_uv+vec2(i,.0),missle_info,fragCoord,fragColor);\n    }\n    state.x=0.0;\n    // at most 8 enemies on the screenn\n    for(int i=0;i<8;++i)\n    {\n        vec4 ei=enemy_info[i];\n        \n        // empty slot for creating a new enemy\n        if(ei.z<1.0)\n        {\n            ei.xy=vec2(1.2*(hash(float(i)+iTime)-0.5),1.0);\n            if(iTime-last_time>1.)\n            {\n                last_time=iTime;\n                ei.z=1.0;\n            }\n        }\n              \n        ei.y-=0.006*ei.z;\n        // out of screen or get killed\n        if(ei.y<-1.0||ei.w>ENEMY_LIFE)\n        {\n            state.y+=ei.w>ENEMY_LIFE?100.:0.0;\n            ei=vec4(0.0);\n        }\n        \n        // Create bullets for an enemy plane\n        for(int j=0;j<5;++j)\n        {\n            vec4 bullet_info=loadbuf(bullet_uv+vec2(j,i));\n            vec2 bullet_dir=loadbuf(bullet_dir_uv+vec2(j,i)).xy;\n\n            if(bullet_info.z<1.0&&ei.z>0.0)\n            {\n                bullet_info.xy=ei.xy+vec2(0.0,-0.15);\n                bullet_info.z=1.0;\n\n                vec2 v=plane_pos-ei.xy;\n                float t=acos(dot(normalize(vec2(0.,-1.)),normalize(v)));\n                bullet_dir=rot(-sign(plane_pos.x)*t)*vec2(j-2,4.0);\n            }\n\n            bullet_info.xy-=0.003*bullet_dir*bullet_info.z;\n            if(abs(bullet_info.x)>1.0||abs(bullet_info.y)>1.0)\n            {\n                bullet_info.z=bullet_info.y=0.0;\n            }\n\n            // get hit by enemy, die, well just reset the score.\n            if(bullet_info.z>0.0 && length(plane_pos.xy+vec2(.0,0.11)-bullet_info.xy)<0.04)\n            {\n                bullet_info.z=bullet_info.y=0.0;\n                state.x=1.0;\n                state.y=0.0;\n            }\n            storebuf(bullet_dir_uv+vec2(j,i),vec4(bullet_dir,.0,.0),fragCoord,fragColor);\n\n            storebuf(bullet_uv+vec2(j,i),bullet_info,fragCoord,fragColor);\n        }\n       \n        storebuf(enemy_uv+vec2(i,.0),ei,fragCoord,fragColor);\n        storebuf(last_time_uv,vec4(last_time,.0,.0,.0),fragCoord,fragColor);\n    }\n\n    storebuf(plane_pos_uv,vec4(plane_pos,.0,.0),fragCoord,fragColor);\n    storebuf(state_uv,vec4(state,.0,.0),fragCoord,fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}