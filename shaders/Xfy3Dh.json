{
    "Shader": {
        "info": {
            "date": "1712675865",
            "description": "i planned to add an ocean but couldn't make it look right",
            "flags": 0,
            "hasliked": 0,
            "id": "Xfy3Dh",
            "likes": 5,
            "name": "oceanless ocean",
            "published": 3,
            "tags": [
                "terrain",
                "sun",
                "clouds"
            ],
            "usePreview": 0,
            "username": "starielsl",
            "viewed": 160
        },
        "renderpass": [
            {
                "code": "#define FAR 100.\n#define STEPS 64\nfloat NEAR = .01;\n\nstruct DirectionalLight\n{\n    vec3 position;\n    float intensity;\n    vec3 color;\n};\n\nDirectionalLight light = DirectionalLight(\n    vec3(0, 0, -15),\n    1.,\n    vec3(1)\n);\n\nvec3 ro = vec3(0, 0, 0);\nvec2 uv = vec2(0);\nvec2 fragCoords = vec2(0);\n\nfloat Sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat WaterPlane(vec3 p, float h)\n{\n    float t = rnoise(p.xz + iTime, 4);\n    return p.y - t / 2. - h;\n}\n\nbool isWater = false;\n\nfloat Scene(vec3 p, bool isLight, bool isVolumetric, bool useBoth)\n{\n     isWater = false;\n     float s = Sphere(p - vec3(0, 0, -10), 1.);\n     p.y += 4.;\n     float t = FAR;\n     if (length(p - ro) < 15.)\n     {\n         t = rnoise(p.xz / 4., 8) * 4.;\n         t = t * sin(length(p.xz - ro.xz) / 15.); // round terrain\n         t = p.y - t;\n     }\n     //float water = FAR;\n     \n     //water = WaterPlane(p, 0.6);\n     //t = min(t, water);\n     //isWater = t == water;\n\n     vec3 q = p - vec3(iTime / 10.,0.1,1.0) * 10.;\n     q.x /= 1.;\n     q.y *= 2.;\n     float g = 0.5+0.5*noise3( q*0.3 );\n\n\tfloat f;\n    f  = 0.50000*noise3( q ); q = q*2.02;\n    f += 0.25000*noise3( q ); q = q*2.23;\n    f += 0.12500*noise3( q ); q = q*2.41;\n    f += 0.06250*noise3( q ); q = q*2.62;\n    f += 0.03125*noise3( q ); \n    \n    f = mix( f*0.1-0.5, f, g*g );\n    f /= (uv.y);\n    f *= 2.;\n    if (uv.y < 0. || f < -5.) f = FAR;\n \n    if (useBoth) return min(f, t);\n    return isVolumetric ? f : t;\n}\n\nbool hit = false;\nbool lightHit = false;\nfloat hitDistance = FAR;\n\nfloat RayMarch(vec3 ro, vec3 rd, bool isLight)\n{\n    if (!isLight) hit = false;\n    else lightHit = false;\n    float ad = 0.;\n    for (int i = 0; i < STEPS; i++)\n    {\n        vec3 p = ro + rd * ad;\n        float d = Scene(p, isLight, false, false);\n        ad += d;\n        if (d < NEAR && !isLight) hit = true;\n        if (d < NEAR && isLight) lightHit = true;\n        if (ad > FAR || d < NEAR) break;\n    }\n    if (hit) hitDistance = ad;\n    return ad;\n}\n\nvec3 GetNormal(vec3 p)\n{ \n    float d = Scene(p, true, false, false);\n    vec2 e = vec2(NEAR / 2., 0);\n    vec3 n = d - vec3(\n        Scene(p - e.xyy, true, false, false),\n        Scene(p - e.yxy, true, false, false),\n        Scene(p - e.yyx, true, false, false)\n    );\n    return normalize(n);\n}\n\nvec3 GetSkyColor(DirectionalLight l, vec3 rd)\n{\n    vec3 color = (l.position.y / length(l.position.xz) + .5) * (rd.y * 2. + .3) * vec3(0.37, 0.55, 1.0); // sky\n    if (l.position.y / length(l.position.xz) > -.1 && l.position.y / length(l.position.xz) < 1.)\n        color.x += (-uv.y - l.position.y / length(l.position.xz));\n    return color;\n}\n\nvec3 GetLight(vec3 p, vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(.05);\n    DirectionalLight l = light;\n    vec3 ld = normalize(l.position - p); \n    vec3 n = GetNormal(p);\n    float dif = dot(n, ld);\n    dif = clamp(dif, 0., 1.) * l.intensity;\n        \n    float d = RayMarch(p + n * NEAR * 2., ld, true); // shadow\n    if (d < length(l.position - p)) dif *= .1;\n        \n    vec3 np = normalize(p);\n    vec3 nl = normalize(l.position);\n    float dpl = .01 / length(nl - np);\n    if (!hit || length(l.position - ro) < length(p - ro)) color += dpl * l.color;\n    else color += .04;\n    \n    vec3 waterCol = (vec3(22.,79.,86.)/255.) + dif * (vec3(0.,214.,10.)/255.) * 0.12; \n\n    if (hit)\n    {\n        float distanceFromCamera = length(ro - p);\n        color -= distanceFromCamera / FAR;\n        color.z += (distanceFromCamera / 8.) / FAR;\n        color.x += .5*((distanceFromCamera / 8.) / FAR);\n        \n        float le = length(p.xz);\n        float sur = -1.;\n        vec2 tuv = vec2(atan(p.z,p.x), ((sur<0.0)?(le+p.y)*0.4:atan(p.y,le)));\n        \n        color = mix(color, texture(iChannel0, tuv * 1.).xyz, n.y + (p.y / 8.));\n            color += clamp(l.position.y / length(l.position.xz), -1., 0.);\n        \n        color = mix(color, l.color, dif);\n    }\n\n    vec3 nld = normalize(l.position - normalize(p));\n    if (!hit)\n    {\n        // color += (l.position.y / length(l.position.xz) + .5) * (rd.y + .5) * vec3(0.37, 0.55, 1.0); // sky\n        color += (l.position.y / length(l.position.xz) + .5) * (rd.y * 2. + .3) * vec3(0.37, 0.55, 1.0); // sky\n        if (l.position.y / length(l.position.xz) > -.1 && l.position.y / length(l.position.xz) < 1.)\n            color.x += (-uv.y - l.position.y / length(l.position.xz));\n    }\n    if (!hit)\n    {\n        float total_density = 0.;\n        float maxDistance = 15.;\n        int steps = 64;\n        float density_step_val = .05;\n        float step_size_f = maxDistance / float(steps);\n        vec3 step_size = rd * step_size_f;\n        vec3 dp = ro;\n        if (uv.y > 0.)\n        {\n            for (int s = 0; s < steps; s++)\n            {\n                vec3 srp = dp;\n                float slrd = 0.;\n                for (int sr = 0; sr < 10; sr++)\n                {\n                    float dst = Scene(srp, true, true, false);\n                    srp += rd * dst;\n                    slrd += dst;\n\n                    if (dst < NEAR)\n                    {\n                        total_density += density_step_val * step_size_f;\n                        break;\n                    }\n                    else if (slrd > maxDistance) break;\n                }\n                dp += step_size;\n                if (total_density > .99) break;\n            }\n\n            if (total_density > .6)\n                color += (l.position.y / length(l.position.xz) + 1.) - clamp(total_density, 0., 1.);\n        }\n            \n        total_density = 0.;\n        dp = ro;\n        for (int s = 0; s < steps; s++)\n        {\n            vec3 srp = dp;\n            float slrd = 0.;\n            for (int sr = 0; sr < 10; sr++)\n            {\n                float dst = Scene(srp, true, true, true);\n                srp += nld * dst;\n                // srp += rd * dst;\n                slrd += dst;\n                \n                if (dst < NEAR)\n                {\n                    total_density += density_step_val * step_size_f;\n                    break;\n                }\n                else if (slrd > maxDistance) break;\n            }\n            dp += step_size;\n        }\n        color *= exp(-total_density);\n    }\n    \n    return color + (l.position.y / length(l.position)) / 3.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragCoords = fragCoord;\n    vec3 color = vec3(0);\n    uv = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    vec2 mo = vec2(iMouse.xy / iResolution.xy - .5);\n    if (iMouse.z < 1.) mo = vec2(.25, 0);\n    mo.x *= (iResolution.x / iResolution.y);\n    light.position += vec3(mo * abs(light.position.z), 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, -1));\n    \n    float d = RayMarch(ro, rd, false);\n    vec3 p = ro + rd * d;\n    color = GetLight(p, ro, rd);\n    \n    float starsCol = -clamp(stars(uv), 0., 1.);\n    if (!hit)\n    {\n        float w = light.position.y / length(light.position.xz);\n        if (w < 0.) color = mix(color, vec3(starsCol), w);\n    }\n    fragColor = vec4(color + .25*camera_noise(uv * 50. + 100.*iTime), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\n//noise by iq\n\nvec2 grad( ivec2 z )\n{\n    int n = z.x+z.y*11111;\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n#if 0\n    return vec2(cos(float(n)),sin(float(n))); \n#else\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;\n#endif                              \n}\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat rnoise( in vec2 uv, int iter )\n{\n    float f = 0., div = 1.;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for (int i = 0; i < iter; i++)\n    {\n        div /= 2.;\n        f  += div*noise( uv ); uv = m*uv;\n    }\n    f = 0.5 + 0.5*f;\n\n    return f;\n}\n\nfloat camera_noise( in vec2 uv )\n{\n    float f = 0., div = 1. / 8.;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    uv *= 32.;\n    f = div*noise( uv ); uv = m*uv;\n    f = 0.5 + 0.5*f;\n\t\n    f *= smoothstep( 0.0, 0.005, abs(uv.x-0.6) );\n    return f;\n}\n\nfloat stars( in vec2 uv )\n{\n    float f = noise(uv * 100.);\n    return f*f*f*f*f;\n}\n\nfloat noise3(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nfloat fbm(vec3 p) {\n\tfloat f = 0.0;\n\tf = 0.5000 * noise3(p);\n\tp *= 2.01;\n\tf += 0.2500 * noise3(p);\n\tp *= 2.02;\n\tf += 0.1250 * noise3(p);\n\n\treturn f;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}