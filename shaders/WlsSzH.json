{
    "Shader": {
        "info": {
            "date": "1562097581",
            "description": "A super hexagon inspired shader I wrangled up today..\nIt's *HIGHLY* unoptimized, So expect some heavy load on your CPU :/\n",
            "flags": 0,
            "hasliked": 0,
            "id": "WlsSzH",
            "likes": 2,
            "name": "N-gon prism distance field",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "zikbakguru",
            "viewed": 502
        },
        "renderpass": [
            {
                "code": "/*\n\tZik's horryfiying SDF lab\n\tWarning : contains spaghetti code\n\n\tMaterial system heavily inspired from\n\thttps://www.shadertoy.com/view/ld3Gz2\n\n\t=======================================\n\tMMXIX ZIK\n*/\n#define DIST_MAX 999999999.9\n#define MAX_STEPS 128\n#define MIN_MARCH_DIST 0.001\n\n#define RGB(r,g,b) vec3(float(r)/255.0, float(g)/255.0, float(b)/255.0)\n\nconst vec3[] hexagon = vec3[](\n    \t\t\t\tRGB(176, 21, 34),\n                    RGB(163, 97, 26),\n                    RGB(163, 97, 26),\n    \t\t\t\tRGB(176, 21, 34)\n                   );\n\n/*\n\tHelper\n\thttp://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n*/\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n/*\n\tN-GON PRISM SDF FUNCTION\n\t========================================\n    Original SDF function for reference\n\n    float getPoly (vec2 uv, float gonSide, float gonAngle, float thickness, float percent)\n    {\n        // N-Gon from : https://thndl.com/square-shaped-shaders.html\n        float gonSlice = 6.28319 / gonSide;\n        float gonSize = percent;\n        float gonWidth = thickness;\n\n        vec2 deltaUV = vec2(0.5) - uv;\n        float deltaAngle = atan(deltaUV.x,deltaUV.y) + (gonAngle / PI);\n        float dist = cos(floor(.5 + deltaAngle / gonSlice) * gonSlice - deltaAngle) * length(deltaUV.xy) * 2.0;\n        return min(smoothstep(gonSize - gonWidth - 0.001, gonSize - gonWidth, dist), smoothstep(gonSize + gonWidth, gonSize + gonWidth - 0.001, dist));\n    }\n*/\n\n// Returns signed distance from n-gon prism\n// sdfPolyPrism (vec3 point, float sides, vec2(radius, thickness))\n// Based on iq's sdf functions : https://iquilezles.org/articles/distfunctions\n#define PI 3.14\nfloat sdfPolyPrism (vec3 p, float sides, vec2 size)\n{\n    // N-Gon from : https://thndl.com/square-shaped-shaders.html\n    float gonSlice = 6.28319 / sides;\n    float deltaAngle = atan(p.x,p.y);\n    float dist = cos(floor(0.5 + deltaAngle / gonSlice) * gonSlice - deltaAngle) * length(p.xy) - size.x;\n    \n    vec2 d = vec2(dist, abs(p.z) - size.y);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// and for fun's sake and some wacky strip effect I've decided to make sdf for \"donut\" of n-gons\nfloat sdfPolyDonut (vec3 p, float sides, vec3 size)\n{\n    return max(-sdfPolyPrism(p, sides, vec2(size.x - size.z, size.y * 2.0)), sdfPolyPrism(p, sides, vec2(size.x + size.z, size.y)));\n}\n\n/*===================================================*/\n\n/*\n\tScene functions\n*/\n// returns distance, [out] vec4 mat\nfloat getSceneInfo (vec3 p, out vec3 mat, float time, float BPS)\n{\n    vec3 tmpMat;\n    float dist = DIST_MAX;\n    float tmpDist;\n    \n    float beatTime = mod(iTime, BPS);\n    float HalfbeatTime = mod(iTime, BPS * 0.5);\n    float FullbeatTime = 1.0 - pow(1.0 - (mod(iTime, BPS * 2.0) / (BPS * 2.0)), 2.0);\n    float beatIncr = floor(iTime / BPS);\n    \n    int colourIdx = int(mod(beatIncr, 2.0)) * 2;\n    vec3 hexColour = clamp(mix(hexagon[colourIdx], hexagon[colourIdx + 1], beatTime / BPS) + 0.6, 0.0, 1.0);\n    mat = vec3(hexColour);\n    \n    // Hexagon\n    float powerBeat = 1.0 - pow(1.0 - beatTime / BPS, 4.0);\n    float deltaHalfBeatTime = HalfbeatTime / (BPS * 0.5);\n    \n    float ang = iTime;\n   \tvec3 dp = (rotationMatrix(vec3(0.0, 0.0, 1.0), ang) * rotationMatrix(vec3(0.5, 0.5, 0.0), PI * 0.1 + sin(iTime * 0.5) * 0.25) * vec4(p.xyz, 0.0)).xyz;\n    \n    float hexSides = 4.0 + mod(floor((iTime * 0.2) / BPS), 3.0);\n    float hexSz = 64.0 + 12.0 * powerBeat;\n    float hexThick = 18.0 + sin(powerBeat * PI) * 16.0;\n    dist = min(dist, sdfPolyDonut(dp, hexSides, vec3(hexSz, hexThick, 2.5)));\n    dist = min(dist, sdfPolyDonut(dp, hexSides, vec3(mix(max(iResolution.x, iResolution.y) * 1.2, hexSz + 10.0, FullbeatTime), hexThick, 10.0)));\n    \n    float tmpdist = sdfPolyPrism(dp, hexSides, vec2(hexSz, 5.0));\n    if (tmpdist < dist)\n    {\n        dist = tmpdist;\n        mat = vec3(hexColour) * 0.2;\n    }\n    \n    return dist;\n}\n\nfloat getSceneDist (vec3 p, float time, float BPS)\n{\n    vec3 trash;\n    return getSceneInfo(p, trash, iTime, BPS);\n}\n\nvec3 getSceneNormal (vec3 p, vec3 lightPos, float time, float BPS)\n{\n    vec3 md = vec3(MIN_MARCH_DIST * 10.0, 0.0, 0.0);\n    vec3 delta = vec3(\n        getSceneDist(p + md.xyy, iTime, BPS) - getSceneDist(p - md.xyy, iTime, BPS), // = getScene(p + vec3(MIN_MARCH_DIST, 0, 0)) - getScene(p - vec3(MIN_MARCH_DIST, 0, 0)\n        getSceneDist(p + md.yxy, iTime, BPS) - getSceneDist(p - md.yxy, iTime, BPS),\n        getSceneDist(p + md.yyx, iTime, BPS) - getSceneDist(p - md.yyx, iTime, BPS)\n    );\n    \n    vec3 normal = normalize(delta);\n    return normal;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    // hexagon style bg flash\n    const float BPM = 130.0;\n    const float BPS = 60.0 / BPM;\n    const float BPS2 = 60.0 / (BPM * 0.5);\n    \n    float beatTime = mod(iTime, BPS);\n    float HalfbeatTime = mod(iTime, BPS * 0.5);\n    float beatIncr = floor(iTime / BPS2);\n    int colourIdx = int(mod(beatIncr, 2.0)) * 2;\n    \n    vec3 final = mix(hexagon[colourIdx], hexagon[colourIdx + 1], mod(iTime, BPS2) / BPS2);\n\t\n    // World info / camera settings\n    float time = iTime;\n    ivec2 intRes = ivec2(iResolution.xy);\n    vec3 camPos = vec3(0.0, 0.0, -256.0);\n    vec3 lightPos = vec3(0.0, 0.0, DIST_MAX);\n    \n    // We're doing some ortho camera in this shader so\n    // We don't have to worry about spooky projection math\n    vec2 screenPos = uv * iResolution.xy;\n    vec3 rayOrigin = camPos + vec3(screenPos.x - (iResolution.x * 0.5), screenPos.y - (iResolution.y * 0.5), 0.0);\n    vec3 rayPos = rayOrigin;\n    vec3 rayDir = vec3(0.0, 0.0, 1.0);\n\tvec3 mat;\n    \n    for (int rs=0; rs<=MAX_STEPS; rs++)\n    {\n        float dist = getSceneInfo(rayPos, mat, iTime, BPS);\n\n        if (dist < MIN_MARCH_DIST) // We hit something\n        {\n            vec3 normal = getSceneNormal(rayPos, lightPos, iTime, BPS);\n            \n            // Diffuse lighting\n            vec3 lightDelta = normalize(rayPos - lightPos);\n            float lightDot = dot(normal, lightDelta);\n            float diffLt = max(lightDot, 0.0) * 0.6 + 0.4;\n            \n            final.xyz = mat.xyz * diffLt;\n        }\n        else // Nope. Keep moving\n        {\n            rayPos += rayDir * dist;\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(final,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}