{
    "Shader": {
        "info": {
            "date": "1718652428",
            "description": "Colorized Julia",
            "flags": 48,
            "hasliked": 0,
            "id": "l33Xz8",
            "likes": 4,
            "name": "Mango",
            "published": 3,
            "tags": [
                "juliaset"
            ],
            "usePreview": 0,
            "username": "kosalos",
            "viewed": 122
        },
        "renderpass": [
            {
                "code": "/*\nKey Commands:\n<Up,Dn Arrows> : select widget focus. PgUp,PgDn hop by 5 entries.\n<Lt,Rt Arrows> : alter value of focused widget\n<0>   : focused value -> 0.0\n<E>   : animate just focused value (A,Z affect amount)\n<X>   : toggle animation\n<Spc> : reset\n<1>...<6> to load preset images\n\nDrag mouse on X axis to alter focused widget value.\nNote: mouse X affects focused value, mouse Y affects next entry\n\nAccelerated changes while holding down arrow keys or moving the mouse:\nHold down <A> for change Amount * 0.1\nHold down <Z> for change Amount * 10.\nHold down both <A><Z> for change Amount * 50.\n \nShape design:           https://fractalforums.org/programming/11/mango/5159/msg37976#new\nColoring:               https://www.shadertoy.com/view/NdXBzr\nDistance functions:     https://iquilezles.org/articles/distfunctions2d/\nText display:           https://www.shadertoy.com/view/mdsSD7\nKeyboard:               https://www.shadertoy.com/view/lsXGzf\nJavascript rendition:   https://openprocessing.org/sketch/1987170\n\n*/\n\nvec3 data[PDATA_ADDR_COUNT]; // copy of storage data for animation and drawing\n\n#define qequation       data[0].x\n#define qiterations     data[0].y\n#define qzoom           data[0].z\n#define qpanx           data[1].x\n#define qpany           data[1].y\n#define qsdStyle        data[1].z\n#define qsdType         data[2].x\n#define qsdf1           data[2].y\n#define qsdf2           data[2].z\n#define qcenterx        data[3].x\n#define qcentery        data[3].y\n#define qcMult          data[3].z\n#define qzMult          data[4].x\n#define qoffsetP        data[4].y\n#define qoffsetM        data[4].z\n#define qoffsetMultP    data[5].x\n#define qoffsetMultM    data[5].y\n#define qc1             data[5].z\n#define qcontrast       data[6].x\n#define qc2             data[6].y\n#define qshadowPower    data[6].z\n#define qflipShadow     data[7].x\n#define qcolor          data[7].y\n#define qtint           data[7].z\n#define qc3             data[8].x\n#define qc4             data[8].y\n#define qrr             data[8].z\n#define qgg             data[9].x\n#define qbb             data[9].y\n#define qss             data[9].z\n#define qalpha          data[10].x\n#define qkappa          data[10].y\n#define focus           data[11].x\n#define displayCount    data[11].y\n#define animationEnable data[11].z\n\n// --------------------------------------------------------\n\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb ) {\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : abs(length(p)-ra)) - rb;\n}\n\nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w ) {\n //   p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, c.y, c.x)*p;\n    p = vec2((p.y>0.0 || p.x>0.0)?p.x:l*sign(-c.x), (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ) { \n\tif(qsdType == 0.) {\n\t\tvec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n\t}\n\t\n\tvec2 m = (a+b)/2.0;\n\tvec2 l = abs(b-a)/2.0;\n\tp = abs(p-m)-l;\n\treturn length(p) * 0.2; \n}\n\nfloat sdCircle( vec2 p, float r ) {\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n//    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n    return length(max(d,qsdf1)) + min(max(d.x,d.y),qsdf2); // 0.0);\n}\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th ) {\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n\t\tq = mat2(d.x,-d.y,d.y,d.x)*q;\n\t\tq = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sdHexagram( in vec2 p, in float r ) {\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nfloat distanceFunction( in vec2 p, in vec2 a, in vec2 b ) { \n    int style = int(qsdStyle);\n\tif(style == 0) return sdSegment(p,a,b);\n\tif(style == 1) return sdCircle(p,qsdf1);\n\tif(style == 2) return sdOrientedBox(p,a,b,qsdf1);\n\tif(style == 3) return sdHexagram(p,qsdf1);\n\tif(style == 4) return sdHorseshoe(p,a,qsdf1,b);\n\tif(style == 5) return sdArc(p,a,qsdf1,qsdf2);\n\tif(style == 6) return sdBox(p,a);\n \treturn 0.;\n}\n\n// --------------------------------------------------------\n\nconst ivec2[] legends = ivec2[](\n    cE,cq,cu,ca,ct,ci,co,cn,\n    cI,ct,ce,cr,ca,ct,ce,c0,\n    cZ,co,co,cm,c0,c0,c0,c0,\n    cP,ca,cn,cX,c0,c0,c0,c0,\n    cP,ca,cn,cY,c0,c0,c0,c0,\n    cS,cD,cs,ct,cy,cl,ce,c0,\n    cS,cD,ct,cy,cp,ce,c0,c0,\n    cS,cD,cf,c1,c0,c0,c0,c0,\n    cS,cD,cf,c2,c0,c0,c0,c0,\n    cJ,cu,cl,ci,ca,cX,c0,c0,\n    cJ,cu,cl,ci,ca,cY,c0,c0,\n    cC,cm,cu,cl,ct,c0,c0,c0,\n    cZ,cm,cu,cl,ct,c0,c0,c0,\n    cO,cf,cf,cs,ce,ct,cP,c0,\n    cO,cf,cf,cs,ce,ct,cM,c0,\n    cM,cu,cl,ct,cP,c0,c0,c0,\n    cM,cu,cl,ct,cM,c0,c0,c0,\n    cB,cr,ci,cg,ch,ct,c0,c0,\n    cC,co,cn,ct,cr,ca,cs,ct,\n    cS,ca,ct,cu,cr,ca,ct,ce,\n    cS,ch,ca,cd,co,cw,c0,c0,\n    cS,ch,cF,cl,ci,cp,c0,c0,\n    cC,co,cl,co,cr,c1,c0,c0,\n    cC,co,cl,co,cr,c2,c0,c0,\n    cC,co,cl,co,cr,c3,c0,c0,\n    cC,co,cl,co,cr,c4,c0,c0,\n    cC,co,cl,co,cr,cR,c0,c0,\n    cC,co,cl,co,cr,cG,c0,c0,\n    cC,co,cl,co,cr,cB,c0,c0,\n    cC,co,cl,co,cr,cS,c0,c0,\n    cA,cl,cp,ch,ca,c0,c0,c0,\n    cK,ca,cp,cp,ca,c0,c0,c0);\n\nvoid displayData(inout vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.x > iResolution.x * 0.35) return; // no printing in that region\n    if(fragCoord.y < iResolution.y * 0.95) return;\n\n    Font f;\n    setFont(f,iChannelResolution[3].xy / vec2(16, 16),iChannelResolution[3].xy);\n\n    TextCursor t;\n    const vec2 charScale = vec2(30,30);\n    t.startPos = vec2(0, iResolution.y);\n    t.coord = ivec2(0.);\n    t.font = f;\n    t.color = vec4(1.);\n    t.charSize = charScale;\n    t.charSpace = vec2(0.7, 1) * charScale;\n    t.pageWidth = int(iResolution.x / t.charSize.x);\n    t.fragCoord = fragCoord;\n    \n    int ifocus = int(focus); \n    int index = ifocus / 3;\n    int field = ifocus % 3;\n\n    printInt(ifocus+1,t);\n    printChar(cSp,t);\n    \n    int legendIndex = ifocus * 8;\n    for(int i=0;i<8;++i) {\n        ivec2 chr = legends[legendIndex+i];\n        if(chr == c0) break;\n        printChar(chr,t);\n    }\n    \n    bool isInteger = pData[ifocus].delta == INTEGER || pData[ifocus].delta == SLOWINTEGER;\n    \n    printChar(cSp,t);\n    printFloat(data[index][field], t,isInteger ? 0 : 4);\n    drawText(t, iChannel3, fragColor);\n}\n\n// animation routines ----------------------------------------\n\nvoid cycleValue(int pDataIndex,inout float value, float deviation, float speed) {\n    float ratio = 1.0 + cos(iTime * speed);  // 0 ... 2\n    value = clamp(value-deviation + deviation * ratio, pData[pDataIndex].vmin, pData[pDataIndex].vmax);\n}\n\nvoid alterparams() {\n    float amt = 0.1;\n    \n    if(abs(qpanx) > 2.) amt = 0.002; // special handling for preset #5, who has large pan settings \n    \n    for(int i=11;i<17;++i) {  // julia, mult\n        int index = i/3;\n        int field = i%3;\n        cycleValue(i,data[index][field],amt,0.1 + float(i) * 0.05);\n    }\n    \n    for(int i=22;i<30;++i) {  // colors\n        int index = i/3;\n        int field = i%3;\n        cycleValue(i,data[index][field],amt,0.1 + float(i) * 0.03);\n    }\n}\n\nvoid animate() {\n    if(animationEnable == 0.) return;\n    alterparams();\n}\n\n// --------------------------------------------------------\n#define PI 3.141592654\n\nvec3 palette(float loc, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b*cos( qcolor * (c*loc+d) );\n}\n\n#define rot(x, y, theta, temp) \\\n\ttemp =  cos(theta) * x + sin(theta) * y; \\\n\ty    = -sin(theta) * x + cos(theta) * y; \\\n\tx    =  temp;\n\nvec3 calc(vec2 center,vec2 uv,inout float op, inout float om) {\n\tvec3 color4 = vec3(qc4+qrr,qc4+qgg,qc4+qbb);\n\tint equation = int(qequation);\t\n    int iterations = int(qiterations);    \n\tfloat dist;\n    float closest = 2.;\n    float closest2 = 4.;\n    int smallestI = -1;\n    vec2 z = uv;   \n    vec2 c = center;  \n\n    for (int i = 0; i < 1000; ++i) {\n        if (i >= iterations) break;\n\n        if(equation == 2)  // PSHIP\n            z.y = abs(z.y);\n            \n        if(equation == 3)  // BSHIP\n            z.xy = abs(z.xy);\n            \n        if(equation == 4) // MBAR\n            z.y = -z.y;\n            \n        if(equation == 5) // MANGO\n            z.y = abs(z.y + qalpha) - qalpha;\n            \n        if(equation == 6) { // NSHIP\n            float t6,t7 = -PI / qkappa;\n            float t8 = PI + t7;\n            rot(z.x, z.y, qalpha, t6);\n\n            float o = 0.0;\n            for (int j = 0; j < 100; ++j) {\n                if(o >= qkappa) break;\n                o += 1.0;\n                rot(z.x, z.y, t7, t6);\n                z.y = abs(z.y);\n            }\n\n            rot(z.x, z.y, t8, t6);\n        }\n\n        z = mat2(z, -z.y, z.x) * z + c;\n\n        dist = distanceFunction(z,center+op,center-om);  \n\n        if (dist < closest) {\n            closest2 = closest;\n            closest = dist;\n            smallestI = i;\n        } else if (dist < closest2) \n            closest2 = dist;\n\n        c *= qcMult;\n        z *= qzMult;\n        op *= qoffsetMultP;\n        om *= qoffsetMultM;\n    }\n\n    vec3 col = palette(float(smallestI) / qtint, vec3(qc1),vec3(qc2),vec3(qc3),color4);\n\n    float shadow = sqrt(qshadowPower - closest / closest2);\n    if(qflipShadow > 0.) shadow = 1.0 - shadow;\n    \n    float highlight = clamp(4. * (0.2 - (closest / closest2)), 0., 21.);\n\n    col = col * shadow * qss + highlight;\n    return col * (-1. / qiterations * float(smallestI) + 1.);\n}\n\n// --------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    for(int i=0;i<PDATA_ADDR_COUNT;++i)  // get copy of storage data\n        data[i] = fetchData(iChannel0, storeAddr[i]).xyz;\n    animate();                           // optionally alter some of the values\n    \n    float zoomY = qzoom * iResolution.y / iResolution.x; // square aspect ratio\n    vec2 vTexCoord = fragCoord / iResolution.xy;  // pixel coord mapped 0...1\n    \n    // pixel value panned and zoomed\n\tvec2 uv = vec2( (vTexCoord.x - qpanx - 0.5) * qzoom,  (vTexCoord.y - qpany - 0.5) * zoomY) * 0.5;    \n    vec2 center = vec2(qcenterx,qcentery);\n\tfloat op = qoffsetP;\n\tfloat om = qoffsetM;\n\n\tvec3 color = vec3(0.);\n    for(int i=0;i<4;++i)\n        color += calc(center,uv,op,om);\n\tcolor *= 0.3;\n\n    fragColor = vec4(vec3(0.5) + (color - vec3(0.5)) * qcontrast, 1.); // apply contrast\n\n    if(displayCount > 0.) \n        displayData(fragColor,fragCoord);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int maxStringLength = 8;\nconst ivec2 cNl    = ivec2(-1, -1);\nconst ivec2 cSp    = ivec2( 0, 13);\nconst ivec2 cPlus  = ivec2(11, 13);\nconst ivec2 cMinus = ivec2(13, 13);\nconst ivec2 cDot   = ivec2(14, 13);\n\nconst ivec2[10] Digits = ivec2[10]\n(\n    ivec2(0, 12), ivec2(1, 12), ivec2(2, 12), ivec2(3, 12), ivec2(4, 12),\n    ivec2(5, 12), ivec2(6, 12), ivec2(7, 12), ivec2(8, 12), ivec2(9, 12)\n);\n#define chd(name, index) const ivec2 name = Digits[index];\nchd(c0,  0) chd(c1,  1) chd(c2,  2) chd(c3,  3) chd(c4,  4)\nchd(c5,  5) chd(c6,  6) chd(c7,  7) chd(c8,  8) chd(c9,  9)\n\nconst ivec2[26] Uppercase = ivec2[26]\n(\n    ivec2( 1, 11), ivec2( 2, 11), ivec2( 3, 11), ivec2( 4, 11), ivec2( 5, 11),\n    ivec2( 6, 11), ivec2( 7, 11), ivec2( 8, 11), ivec2( 9, 11), ivec2(10, 11),\n    ivec2(11, 11), ivec2(12, 11), ivec2(13, 11), ivec2(14, 11), ivec2(15, 11),\n    ivec2( 0, 10), ivec2( 1, 10), ivec2( 2, 10), ivec2( 3, 10), ivec2( 4, 10),\n    ivec2( 5, 10), ivec2( 6, 10), ivec2( 7, 10), ivec2( 8, 10), ivec2( 9, 10),\n    ivec2(10, 10)\n);\n#define chu(name, index) const ivec2 name = Uppercase[index];\nchu(cA,  0) chu(cB,  1) chu(cC,  2) chu(cD,  3) chu(cE,  4)\nchu(cF,  5) chu(cG,  6) chu(cH,  7) chu(cI,  8) chu(cJ,  9)\nchu(cK, 10) chu(cL, 11) chu(cM, 12) chu(cN, 13) chu(cO, 14)\nchu(cP, 15) chu(cQ, 16) chu(cR, 17) chu(cS, 18) chu(cT, 19)\nchu(cU, 20) chu(cV, 21) chu(cW, 22) chu(cX, 23) chu(cY, 24)\nchu(cZ, 25)\n\nconst ivec2[26] Lowercase = ivec2[26]\n(\n    ivec2( 1,  9), ivec2( 2,  9), ivec2( 3,  9), ivec2( 4,  9), ivec2( 5,  9),\n    ivec2( 6,  9), ivec2( 7,  9), ivec2( 8,  9), ivec2( 9,  9), ivec2(10,  9),\n    ivec2(11,  9), ivec2(12,  9), ivec2(13,  9), ivec2(14,  9), ivec2(15,  9),\n    ivec2( 0,  8), ivec2( 1,  8), ivec2( 2,  8), ivec2( 3,  8), ivec2( 4,  8),\n    ivec2( 5,  8), ivec2( 6,  8), ivec2( 7,  8), ivec2( 8,  8), ivec2( 9,  8),\n    ivec2(10,  8)\n);\n#define chl(name, index) const ivec2 name = Lowercase[index];\nchl(ca,  0) chl(cb,  1) chl(cc,  2) chl(cd,  3) chl(ce,  4)\nchl(cf,  5) chl(cg,  6) chl(ch,  7) chl(ci,  8) chl(cj,  9)\nchl(ck, 10) chl(cl, 11) chl(cm, 12) chl(cn, 13) chl(co, 14)\nchl(cp, 15) chl(cq, 16) chl(cr, 17) chl(cs, 18) chl(ct, 19)\nchl(cu, 20) chl(cv, 21) chl(cw, 22) chl(cx, 23) chl(cy, 24)\nchl(cz, 25)\n\nstruct String {\n    int count;\n    ivec2[maxStringLength] chars;\n};\n\n\n// ========================================================================\n// visit: https://www.shadertoy.com/view/mdsSD7\n// This code is released into the public domain.\n// If you need a license instead, consider this CC0, MIT or BSD licensed, take your pick.\n\n// If you want to print numbers larger than 32 digits, increase maxStringLength\n\n#define setString(string, n, contents)\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n#define declString(string, n, contents)\\\nString string;\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n\nstruct Font {\n    vec2 texSize;\n    vec2 charSize;\n    vec2 ct;\n};\n\n#define setFont(ff,c,t) ff.charSize = c; ff.texSize = t; ff.ct = c/t;\n\nstruct TextCursor {\n    vec2 startPos;\n    ivec2 coord;\n    Font font;\n    vec4 color;\n    vec2 charSize;\n    vec2 charSpace;\n    int pageWidth;\n    vec2 fragCoord;\n    vec2 outUV;\n    vec4 outColor;\n};\n\nvec4 getFontCharRect(in Font f, ivec2 char) {\n    return vec4(char, char+ivec2(1)) * f.ct.xyxy;\n}\n\nvec4 getCharScreenRect(in TextCursor t)\n{\n    vec2 leftTop = t.startPos + t.charSpace * vec2(t.coord.x, -t.coord.y);\n    vec2 rightBottom = leftTop + t.charSize * vec2(1, -1);\n    \n    return vec4(leftTop.x, rightBottom.y, rightBottom.x, leftTop.y);\n}\n\nvoid updateOutUV(ivec2 char, inout TextCursor t) {\n    vec4 fontRect = getFontCharRect(t.font, char);\n    vec4 screenRect = getCharScreenRect(t);\n    vec2 screenRectUV = (t.fragCoord - screenRect.xy) / (screenRect.zw - screenRect.xy);\n    \n    if(clamp(screenRectUV, vec2(0), vec2(1)) != screenRectUV) return;\n    \n    t.outUV = screenRectUV * (fontRect.zw - fontRect.xy) + fontRect.xy;\n    t.outColor = t.color;\n}\n\nvoid incrementCursor(inout TextCursor t)\n{\n    t.coord.x += 1;\n    if(t.coord.x >= t.pageWidth)\n    {\n        t.coord.x = 0;\n        t.coord.y += 1;\n    }\n}\n\nvoid newlineCursor(inout TextCursor t)\n{\n    t.coord.x = 0;\n    t.coord.y += 1;\n}\n\nvoid printChar(ivec2 char, inout TextCursor t)\n{\n    if(char == cNl)\n    {\n        newlineCursor(t);\n        return;\n    }\n    \n    updateOutUV(char, t);\n    incrementCursor(t);\n}\n\nvoid printString(String s, inout TextCursor t)\n{\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n    {\n        printChar(s.chars[i], t);\n    }\n}\n\n/*\nvoid blend(vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);\n}\n\nvoid printLine(String s, inout TextCursor t)\n{\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n    {\n        printChar(s.chars[i], t);\n    }\n    printChar(cNl, t);\n}\n*/\nvoid printInt(int val, inout TextCursor t) {\n    if(val < 0)\n    {\n        printChar(cMinus, t);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    for(;;)  {\n        digits[count++] = val % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        val /= 10;\n        \n        if(val == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n        printChar(Digits[digits[i]], t);\n}\n\n\nvoid printFloat(float val, inout TextCursor t,int fractCount) {\n    if(val < 0.0) {\n        printChar(cMinus, t);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    int iVal = int(val);\n    val -= float(iVal);\n    \n    for(;;) {\n        digits[count++] = iVal % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        iVal /= 10;\n        \n        if(iVal == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n        printChar(Digits[digits[i]], t);\n    \n    if(fractCount == 0)  return;\n    printChar(cDot, t);\n        \n    for(int i = 0; i < fractCount; i++) {\n        val *= 10.0;\n        \n        int digit = int(val);\n        val -= float(digit);\n        \n        printChar(Digits[digit], t);\n        \n        if(val <= 0.0)\n            break;\n    }\n}\n\nvoid drawText(TextCursor t, sampler2D fontTexture, inout vec4 fragColor) {\n    fragColor = t.outColor;\n    if(texture(fontTexture, t.outUV).r < 0.2)\n        fragColor = vec4(0.4,0.4,0.4,10.);\n/*\n    fragColor = vec4(0.);\n    if(texture(fontTexture, t.outUV).r < 0.2)\n        fragColor = t.outColor;\n*/\n}\n\n// =====================================================================================\n// =====================================================================================\n\nstruct ParamData {\n    float start,vmin,vmax,delta;\n};\n\n#define INTEGER 1.\n#define SLOWINTEGER 1.001\n#define UNUSED  999.\n#define UNUSEDP ParamData(0.,0.,0.,0.)\n\nconst ParamData[] pData = ParamData[](\n    //  0 p0 ---------------\n    ParamData(6., 1.,6.,SLOWINTEGER ),     // equation\n    ParamData(70.,5.,200.,INTEGER ),       // iterations\n    ParamData(16.14, 0.0001, 200.0, 0.01), // zoom\n    //  3 p1 ---------------\n    ParamData(0., -20000., 20000., 0.01 ), // pan x\n    ParamData(0., -20000., 20000., 0.01 ), // pan y\n    ParamData(0., 0., 6., SLOWINTEGER ),   // signed distance style code\n    //  6 p2 ---------------\n    ParamData(0., 0., 1., SLOWINTEGER ),   // sd type code\n    ParamData(2., -5., 5., 0.01 ),         // sd param 1\n    ParamData(2., -5., 5., 0.01 ),         // sd param 2\n    //  9 p3 ---------------\n    ParamData(3.2486, -9., 9., 0.02 ),     // Julia x\n    ParamData(-2.6028, -9., 9., 0.02 ),    // Julia y\n    ParamData(1.0099, -9., 9., 0.02 ),     // C mult\n    // 12 p4 ---------------\n    ParamData(-0.3045, -9., 9., 0.002 ),   // Z mult\n    ParamData(7.225, -9., 9., 0.002 ),     // offset P\n    ParamData(-5.7122, -9., 9., 0.002 ),   // offset M\n    // 15 p5 ---------------\n    ParamData(-0.9117, -9., 9., 0.002 ),   // Mult P\n    ParamData(-1.6025, -9., 9., 0.002 ),   // Mult M\n    ParamData(1.0599, 0., 1.5, 0.01 ),     // Brightness\n    // 18 p6 ---------------\n    ParamData(1.1698, 0.1, 2., 0.01 ),     // Contrast\n    ParamData(0.87, 0., 1., 0.01 ),        // Saturation\n    ParamData(0.9799, 0.1, 2., 0.01 ),     // Shadow Power\n    // 21 p7 ---------------\n    ParamData(0., 0., 1., SLOWINTEGER ),   // Flip Shadow?\n    ParamData(2., 1., 9., 0.1 ),           // color factor 1\n    ParamData(1.3, 1., 100., 0.1 ),        // color 2\n    // 24 p8 ---------------\n    ParamData(0.33, 0., 5., 0.01 ),        // color 3\n    ParamData(-1., -1., 1., 0.01 ),        // color 4\n    ParamData(0.79, -3., 3., 0.01 ),       // color R\n    // 27 p9 ---------------\n    ParamData(0.3399, -3., 3., 0.01 ),     // color G\n    ParamData(3., -3., 3., 0.01 ),         // color B\n    ParamData(0.3999, 0.1, 5., 0.01 ),     // color Strength\n    // 30 p10 ---------------\n    ParamData(1.891, -3., 3., 0.01 ),      // alpha (sd styles 5,6)\n    ParamData(0.5329, -3., 3., 0.001 ),    // kappa\n    UNUSEDP,  // unused\n    // 33 p11 ---------------\n    UNUSEDP,  // focus\n    UNUSEDP,  // displayCount\n    UNUSEDP   // animationFlag\n);\n\nconst int UI_SIZE = 32;  // #fields user interface\n\nconst ivec2 P0_ADDR =  ivec2( 0, 0);\nconst ivec2 P1_ADDR =  ivec2( 1, 0);\nconst ivec2 P2_ADDR =  ivec2( 2, 0);\nconst ivec2 P3_ADDR =  ivec2( 3, 0);\nconst ivec2 P4_ADDR =  ivec2( 4, 0);\nconst ivec2 P5_ADDR =  ivec2( 5, 0);\nconst ivec2 P6_ADDR =  ivec2( 6, 0);\nconst ivec2 P7_ADDR =  ivec2( 7, 0);\nconst ivec2 P8_ADDR =  ivec2( 8, 0);\nconst ivec2 P9_ADDR =  ivec2( 9, 0);\nconst ivec2 P10_ADDR = ivec2(10, 0);\nconst ivec2 P11_ADDR = ivec2(11, 0);\nconst int PDATA_ADDR_COUNT = 12;\n\n#define FOCUS_ADDR P11_ADDR\n\nconst ivec2[] storeAddr = ivec2[](P0_ADDR,P1_ADDR,P2_ADDR,P3_ADDR,P4_ADDR,P5_ADDR,P6_ADDR,P7_ADDR,P8_ADDR,P9_ADDR,\n    P10_ADDR,P11_ADDR);\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeDataAddr(buf_pos, addr) ivec2(buf_pos) == addr\n#define storeData(buf_pos, addr,data) if(ivec2(buf_pos) == addr) fragColor = data\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nconst float sd1[] = float[](\n\t6.0,29.40000, 20.14591, -0.00059, -0.00444, 0.00000, 0.00000, 0.60999, -5.00000, 4.4139, \n    -7.3199, 1.0098,  -0.2573, 7.2079, -9., 0.2042, 2.1654,   0.18, 0.71,0.7199,\n    0.92,0.,  4.299,2.9999, 3.4799,-0.3,-1.7699,1.8,-3.,1.84,\n 3.00000, 0.62999,0.,0.,0.,0.);\n\nconst float sd2[] = float[](\n\t6.,70., 12.04675, 0.0877, -0.6523, 0.00000, 0.00000, 0.60999, -5.00000, -6.25139, -4.06684, 1.00994, -0.30459,\n    3.19503, -7.06222, 0.95424, 1.15149, 1.05999, 1.16980, 0.87000, 0.99, 0.00000, 2.00000, 1.30000, 0.33000,\n    -1.00000, 0.79000, 0.33999, 3.00000, 0.65997, -1.08400, 0.42598,0.,0.,0.,0.);\n    \nconst float sd3[] = float[]( \n\t6.0,29.40000, 20.14591, -0.00059, -0.00444, 0.00000, 0.00000, 0.60999, -5.00000, -4.58604, -3.20844, 0.99789, \n    -0.27334, 4.29799, -5.59893, 0.95424, 1.15149, 1.05999, 1.16980, 0.87000, 0.85, 0.00000, 2.00000, 1.30000, \n    0.33000, -1.00000, 0.79000, 0.33999, 3.00000, 0.76998, -0.87000, 0.62999,0.,0.,0.,0.);\n   \nconst float sd4[] = float[]( \n   6.,29.40000, 7.2659, -0.4105, -0.5040, 0.00000, 0.00000, 0.60999, -5.00000, -4.92275, -2.92654, 0.95450,\n   -0.31560, 4.29799, -5.59893, 0.95424, 1.15149, 1.05999, 1.16980, 0.87000, 0.98000, 0.00000, 2.00000, 1.30000, \n   0.33000, -1.00000, 0.79000, 0.33999, 3.00000, 0.76998, -1.96000, 0.41399,0.,0.,0.,0.);\n   \nconst float sd5[] = float[]( \n   6.,70.00000, 0.07893, 41.2837, 21.5684, 0.00000, 0.00000, 0.60999, -5.00000, -6.02329, -3.95859, 1.00234,\n   -0.29755, 4.29799, -5.59893, 0.95424, 1.15149, 1.05999, 1.16980, 0.87000, 0.98000, 0.00000, 2.00000, 1.30000, \n   0.33000, -1.00000, 0.79000, 0.33999, 3.00000, 0.76998, -1.01400, 0.41398,0.,0.,0.,0.);\n\nconst float sd6[] = float[]( \n   5.,29.40000, 2.1693, 0.8594, -0.1699, 0.00000, 1.00000, 0.60999, -5.00000, -0.67800, 0.62200, -0.10775, \n   1.52685, 4.29799, -5.59893, 0.95424, 1.15149, 1.05999, 1.16980, 0.87000, 0.999, 0.00000, 2.00000, 1.30000,\n   0.33000, -1.00000, 0.79000, 0.33999, 3.00000, 0.95998, -0.12200, 0.07699,0.,0.,0.,0.);\n\n   \nvoid retrieveDataset(inout vec4 fragColor,vec2 fragCoord, const float storage[36]) {\n    for(int i=0;i<12;++i) {\n        if (storeDataAddr(fragCoord, storeAddr[i])) {\n            int arrayIndex = i * 3;\n            fragColor.x = storage[arrayIndex++];\n            fragColor.y = storage[arrayIndex++];\n            fragColor.z = storage[arrayIndex];\n            return;\n        }\n    }\n}\n\n// ---------------------------------------------------------\n\nvoid initializeStorage(inout vec4 fragColor,vec2 fragCoord) {\n    if (storeDataAddr(fragCoord, FOCUS_ADDR)) fragColor.xyz = vec3(0.);\n    \n    int pIndex = 0;\n    for(int i=0;i<PDATA_ADDR_COUNT;++i) {\n        if(storeDataAddr(fragCoord, storeAddr[i])) {\n            fragColor.xyz = vec3(0.);\n            if(pIndex+0 < UI_SIZE) fragColor.x = pData[pIndex+0].start;\n            if(pIndex+1 < UI_SIZE) fragColor.y = pData[pIndex+1].start;\n            if(pIndex+2 < UI_SIZE) fragColor.z = pData[pIndex+2].start;\n        }\n        \n        pIndex += 3;\n    }\n}\n\n// --------------------------------------------------------\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_ALT   = 18;\nconst int KEY_PGUP  = 33;\nconst int KEY_PGDN  = 34;\n\nbool keyClick(int ascii) {\n\treturn (texture(iChannel1,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,0), 0).x != 0.);\n}\n\nbool getKeyClick(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,1), 0).x != 0.);\n}\n\nvoid acceleratedValue(inout float value) {\n    bool aKey = getKeyState(65);\n    bool zKey = getKeyState(90);\n    \n    if(aKey && zKey) value *= 50.; else\n    if(aKey) value *= 0.1; else\n    if(zKey) value *= 10.0;    \n}\n\n// --------------------------------------------------------\n\nbool alterFocusedVariable(int focus,int axis,inout vec3[PDATA_ADDR_COUNT] memory) {\n    if(focus > UI_SIZE-1) return false;\n    float changeAmount = 0.;\n    int focusIndex = focus / 3;  // memory index\n    int focusField = focus % 3;  // x,y,z field within\n\n    if(getKeyClick(48)) {  // '0' sets value to 0.\n        memory[focusIndex][focusField] = 0.;\n        changeAmount = 1.;   // so function returns true\n    }\n    else {\n        if(getKeyState(69)) { // 'E'\n            changeAmount = sin(iTime) * 0.25;\n        }\n        else {\n            if(axis == 0) { // arrow keys affect only focused variable \n            \n                if(pData[focus].delta == SLOWINTEGER) { \n                    if(getKeyClick(KEY_LEFT))  changeAmount = -pData[focus].delta; else\n                    if(getKeyClick(KEY_RIGHT)) changeAmount = +pData[focus].delta;\n                } else {\n                    if(getKeyState(KEY_LEFT))  changeAmount = -pData[focus].delta; else\n                    if(getKeyState(KEY_RIGHT)) changeAmount = +pData[focus].delta;\n                }\n            }\n\n            // mouse affects focused variable and also next one --------------\n            if(iMouse.z > 0.0) { // left mouse button down\n                vec2 delta = (iMouse.xy - abs(iMouse.zw)) * 0.01 * pData[focus].delta;\n                if(axis == 0) changeAmount = delta.x;\n                if(axis == 1) changeAmount = -delta.y; // flip Y axis\n             }\n        }\n\n        if(changeAmount != 0.) {\n            acceleratedValue(changeAmount);\n            memory[focusIndex][focusField] += changeAmount;\n        }\n    }\n       \n    memory[focusIndex][focusField] = clamp(memory[focusIndex][focusField],pData[focus].vmin,pData[focus].vmax);\n    \n    return changeAmount != 0.;\n}\n\n// --------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.x > 20.0 || fragCoord.y > 1.0) return; // skip unused storage locations\n    \n    if(iFrame < 10 || keyClick(32)) {  // reset settings on coldstart or <Spc> keypress\n        initializeStorage(fragColor, fragCoord);\n        return; \n    }\n    \n    // $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n    if(keyClick(49)) {  // retrive storage dataset #1 via '1' key\n        retrieveDataset(fragColor, fragCoord,sd1);\n        return; \n    }\n    if(keyClick(50)) {  // retrive storage dataset #2 via '2' key\n        retrieveDataset(fragColor, fragCoord,sd2);\n        return; \n    }\n    if(keyClick(51)) {  // 3\n        retrieveDataset(fragColor, fragCoord,sd3);\n        return; \n    }\n    if(keyClick(52)) {  // 4\n        retrieveDataset(fragColor, fragCoord,sd4);\n        return; \n    }\n    if(keyClick(53)) {  // 5\n        retrieveDataset(fragColor, fragCoord,sd5);\n        return; \n    }\n    if(keyClick(54)) {  // 6\n        retrieveDataset(fragColor, fragCoord,sd6);\n        return; \n    }\n    // $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n    \n    // ==========================================================       \n    // keyboard & mouse alter focused data (mouse also affects next entry) ---------\n    vec3[PDATA_ADDR_COUNT] memory; \n           \n    // fetch current values\n    for(int i=0;i<PDATA_ADDR_COUNT;++i)\n        if (storeDataAddr(fragCoord, storeAddr[i])) \n            memory[i] = fetchData(iChannel0, storeAddr[i]).xyz;\n\n    bool resetDisplayCount = false; \n    int focus = int(fetchData(iChannel0, FOCUS_ADDR).x);\n\n    if(alterFocusedVariable(focus,  0,memory)) resetDisplayCount = true;\n    if(alterFocusedVariable(focus+1,1,memory)) resetDisplayCount = true;\n    \n    // output possibly altered values\n    for(int i=0;i<PDATA_ADDR_COUNT;++i)\n        if (storeDataAddr(fragCoord, storeAddr[i])) \n            fragColor.xyz = memory[i];\n    // ==========================================================       \n\n    // alter focus.  update displayCount. toggle animationEnable --------\n    if (storeDataAddr(fragCoord, FOCUS_ADDR)) {\n        fragColor = fetchData(iChannel0, FOCUS_ADDR);\n        float focusChange = 0.;\n        if(getKeyClick(KEY_UP))   focusChange = -1.;\n        if(getKeyClick(KEY_DOWN)) focusChange = +1.;\n        if(getKeyClick(KEY_PGUP)) focusChange = -5.;\n        if(getKeyClick(KEY_PGDN)) focusChange = +5.;\n\n        if(focusChange != 0.) {\n        \n            //skip past UNUSED rows\n            while(true) {\n                fragColor.x += focusChange;\n                if(fragColor.x < 0.0) fragColor.x = float(UI_SIZE-1);\n                if(fragColor.x >= float(UI_SIZE)) fragColor.x = 0.0;\n                \n                if(pData[int(fragColor.x)].start != UNUSED) break;\n            }\n            \n            resetDisplayCount = true; \n        }\n        \n        if(resetDisplayCount) fragColor.y = iFrameRate; else\n        if(--fragColor.y < 0.0) fragColor.y = 0.0;  // so widget display times out \n        \n        bool kx = getKeyClick(88); // 'X'  animationEnable\n        if(kx) fragColor.z = (fragColor.z == 0.) ? 1. : 0.;\n    }   \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}