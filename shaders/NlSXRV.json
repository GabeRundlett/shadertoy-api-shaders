{
    "Shader": {
        "info": {
            "date": "1628022227",
            "description": "Deep Space Kraken as found on Bop in Kerbal Space Program [url]https://aliens.fandom.com/wiki/Deep_Space_Kraken[/url]\n\nOut of its element!",
            "flags": 0,
            "hasliked": 0,
            "id": "NlSXRV",
            "likes": 7,
            "name": "Kerbal Kraken",
            "published": 3,
            "tags": [
                "sea",
                "kraken",
                "kerbalspaceprogram"
            ],
            "usePreview": 0,
            "username": "Roninkoi",
            "viewed": 354
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265\n#define MAXIT 150\n#define EPSILON 0.05\n#define STEP 0.5\n\n#define minx4(a, b) ((a.x) < (b.x) ? (a) : (b))\n#define minx2(a, b) ((a.x) < (b.x) ? (a) : (b))\n\n#define GROUNDCOL 1.\n#define KRAKENCOL 2.\n#define TENTACLECOL 3.\n#define BEAKCOL 4.\n#define EYECOL 5.\n\nmat3 rotX(float a)\n{\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\n\nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, -sin(a),\n        0., 1., 0.,\n        sin(a), 0.0, cos(a)\n    );\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n\nfloat hash(vec2 r) {\n    return fract(sin(dot(r, vec2(15.5921, 96.654654))) * 23626.3663);\n}\n\nfloat t;\n\nfloat sphere(vec3 r, float a)\n{\n    return length(r) - a;\n}\n\nfloat beak(vec3 r, float a)\n{\n\tvec3 p = r;\n\tp.x *= 0.8;\n\tp.y *= 0.6;\n\t\n\tvec3 b1 = rotZ(PI/4. - 0.4 - abs(sin(t*3.)) * 0.9)*vec3(p.x - p.y * p.y * p.y, p.y, 0.);\n\tvec3 b2 = rotZ(PI/4. + 0.4 + abs(sin(t*3.)) * 0.9)*vec3(p.x + p.y * p.y * p.y, p.y, 0.);\n\t\n    return length(p) - a + max(-b1.x-b1.y + 0.12, 0.)*max(-b2.x-b2.y + 0.12, 0.)*10.;\n}\n\nfloat body(vec3 r, float a)\n{\n\tr.y -= abs(r.y)*0.33;\n    return length(r) - a;\n}\n\nfloat torus(vec3 r, vec3 a)\n{\n    vec2 p = vec2(length(r.xz) - a.x, r.y);\n    return length(p) - a.y;\n}\n\nfloat plane(vec3 r, vec3 o, vec3 n) {\n\tr.y += sin(r.x * 0.1) * 2.;\n\tr.y += cos(r.z * 0.1) * 2.;\n\tr.y += (sin(r.x)) * 0.2;\n\tr.y += (sin(r.x) + cos(r.z * 0.5)) * 0.2;\n\t\n    return dot(r - o, n);\n}\n\nfloat tentacle(vec3 r, vec3 a, float tt)\n{\n\tfloat d = a.y - r.y;\n\tr.x += sin(r.x * 0.2 + r.y * 0.5 + tt) * d * 0.3;\n\tr.z += cos(r.z * 0.1 + r.y * 0.8 + tt) * d * 0.3;\n\ta.z = clamp(a.z - d * a.z / a.y / 2., 0., a.z);\n    \n\tvec2 p = abs(vec2(length(r.xz), r.y)) - a.xy;\n\tp.x = abs(p.x) - a.z;\n\n\treturn min(max(p.x, p.y), 0.0) + length(max(p, 0.));\n}\n\nfloat box(vec3 r, vec3 a)\n{\n    vec3 p = (abs(r) - a);\n\n    return length(max(p + 0.1, 0.));\n}\n\nfloat shade(vec3 n, vec3 rd)\n{\n    return clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n\nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n    return mix(fogCol, col, exp(-z));\n}\n\nvec3 matCol(vec4 o)\n{\n\tvec2 cc = o.zw;\n\t\n    if (o.y == GROUNDCOL) {\n\t    cc.x += cos(.3*t) * 2.;\n\t    cc.y += sin(.3*t) * 2.;\n        return normalize(vec3(0.8 + sin(cc.x + cc.y) * 0.05, 0.5 + sin(cc.x) * 0.1, 0.0));\n    }\n    \n    if (o.y == KRAKENCOL) {\n\t    float fade = cos(clamp(cc.y*1.2, 0., PI/2.));\n\t    vec3 top = normalize(vec3(0., 0.9, 0.)) * (sin(cc.x * 6.) * fade * 0.6 + 0.4);\n\t    float bfade = clamp(-cc.y+.3, 0., 1.);\n\t    vec3 bot = vec3(0.7, 0.3, 0.);\n\t    return top * (1.-bfade) + bot * bfade;\n    }\n    \n    if (o.y == TENTACLECOL) {\n\t    float fade = clamp(abs(cc.y), 0., PI/2.);\n\t    vec3 top = normalize(vec3(0., 0.9, 0.)) * ((fade) * 0.8) * 0.5;\n\t    return top;\n    }\n    \n    if (o.y == EYECOL) {\n\t    float fade = cos(clamp(cc.y*10., 0., PI/2.));\n\t    \n\t    float pupil = smoothstep(-0.6,-0.5, cc.y);\n\t    float lid = smoothstep(0.0,-0.2, cc.y);\n\t    vec3 top = vec3(1.2, 1.2, 0.) * (cos(cc.x * 6.) * fade * 0.6 + 0.4) + vec3(0.9, 1., 0.);\n\t    \n\t    return top * pupil * lid + vec3(0.2, 0.0, 0.2) * (1. - pupil) + vec3(0.5, 0.8, 0.) * (1.-lid);\n    }\n    \n    if (o.y == BEAKCOL) {\n\t    float fade = clamp(abs(sin(cc.y * cc.y)), 0., PI/2.);\n\t    vec3 top = normalize(vec3(1.7, 1., 0.8)) * (fade * 0.6 + 0.4);\n\t    return top * fade;\n    }\n    \n    return normalize(vec3(0.8, 0.2, 0.));\n}\n\nmat3 obj;\n\nvec4 kraken(vec3 r, float tt)\n{\n\tvec3 br = r * rotY(0.7) * rotX(-PI / 2.);\n\tbr *= rotY((sin(t) + t * 1.5) * 0.5);\n\tvec2 bc = vec2(atan(br.x, br.z), br.y / 3.);\n\t\n\tvec4 bd = vec4(\n\t\tbody(br, 3.), matCol(vec4(0., KRAKENCOL, bc))\n\t);\n\t\n\tvec4 td = vec4(1000., 0., 0., 0.);\n\tfor (int a = 0; a < 6; ++a) {\n\t\tfloat aa = float(a) - PI / 4.;\n\t\tfloat split = (floor(float(a) / 3.) * 2. - 1.) * 0.3;\n\t\ttd = minx4(td, \n            vec4(tentacle(br + 1.7 * vec3(cos(float(aa)) - split, 1.8, sin(float(aa))),\n                vec3(.01, 2., .6), tt * 0.5), \n            matCol(vec4(0., TENTACLECOL, bc))\n\t\t));\n\t}\n\t\n\tvec3 er = br + vec3(0., 2., -1.5);\n\tfloat eax = sin(t * 2.) * 0.4;\n\tfloat eaz = cos(t * 2.) * 0.4;\n\ter *= rotX(eax * sin(t * 0.71)) * rotZ(eaz * sin(t * 0.54));\n\tvec2 ec = vec2(atan(er.x, er.z), er.y);\n\tvec4 ed1 = vec4(\n\t\tsphere(er, 0.6), matCol(vec4(0., EYECOL, ec))\n\t);\n\ter = br + vec3(0., 2., 1.5);\n\ter *= rotX(-eax * cos(t * 0.32)) * rotZ(-eaz * sin(t * 0.76));\n\tec = vec2(atan(er.x, er.z), er.y);\n\tvec4 ed2 = vec4(\n\t\tsphere(er, 0.6), matCol(vec4(0., EYECOL, ec))\n\t);\n\tvec4 ed = minx4(ed1, ed2);\n\t\n\tvec3 kr = br + vec3(0., 2.3, 0.);\n\tvec4 kd = vec4(\n\t\tbeak(kr, 0.6), matCol(vec4(0., BEAKCOL, bc))\n\t);\n\t\n\treturn minx4(minx4(minx4(bd, td), ed), kd);\n}\n\nvec4 map(vec3 r)\n{\n\tfloat tt = t * 10. - sin(t) * 5.;\n\t\n\tr *= rotY(sin(t * 0.5));\n\t\n\tvec4 kd = kraken(r, tt);\n\t\n\tvec3 gr = r;\n\tgr.x += tt * 0.4;\n\tgr.z += tt;\n\tgr.y += 7.;\n\t\n\tvec4 gd = vec4(\n\t\tplane(gr, vec3(0., 0., 0.), vec3(0., 1., 0.)), matCol(vec4(0., GROUNDCOL, gr.xz))\n\t);\n\t\n\treturn minx4(gd, kd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    t = iTime;\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    mat3 cam = rotY(-PI) * rotX(0.3);\n\n    vec3 ro = vec3(0., 2.0, -10.0);\n    vec3 rd = cam * normalize(vec3(uv * 2., -1.));\n    vec3 r = ro;\n\n    vec3 bcol = vec3(0.2, 0.7, 0.8) * 1.1;\n    vec4 col = vec4(0.);\n    col.rgb = bcol;\n\n    float sh = 1.;\n\n    float glow = 0.;\n\n    int ch = 1;\n\n    for (int i = 0; i < MAXIT; ++i) {\n        vec4 d = map(r);\n        float z = length(r - ro);\n\n        glow += exp(-d.x);\n\n        if (d.x < EPSILON) {\n            col.rgb = mix(col.rgb, d.yzw,\n                shade(normalize(r), rd));\n\t\t\n            col.rgb = fog(z * 0.1, col.rgb, bcol);\n            break;\n        }\n\n        d.x *= 0.8 - 0.2 * hash(uv);\n        r += rd * d.x * STEP;\n\n        sh = (float(i) / float(MAXIT));\n    }\n\n    if (sh < 0.5)\n        col.rgb *= clamp(exp(-sh * 2.0 + 1.0), 0., 1.);\n\n    fragColor = vec4(col.rgb, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}