{
    "Shader": {
        "info": {
            "date": "1426178179",
            "description": "A tribute to the wonderful www.vectorpark.com (now with 3D effect!)\n\nGo play Windosill and Metamorphabet!\n",
            "flags": 0,
            "hasliked": 0,
            "id": "MlsGDf",
            "likes": 9,
            "name": "Vectorpark Egg 3D",
            "published": 3,
            "tags": [
                "raymarching",
                "distancefield",
                "modeling",
                "animation",
                "ik",
                "toy"
            ],
            "usePreview": 0,
            "username": "valentingalea",
            "viewed": 1283
        },
        "renderpass": [
            {
                "code": "#define SHADERTOY\n\n#ifdef __cplusplus\n#define _in(T) const T &\n#define _inout(T) T &\n#define _out(T) T &\n#define _begin(type) type {\n#define _end }\n#define _mutable(T) T\n#define _constant(T) const T\n#define mul(a, b) (a) * (b)\n#endif\n\n#if defined(GL_ES) || defined(GL_SHADING_LANGUAGE_VERSION)\n#define _in(T) const in T\n#define _inout(T) inout T\n#define _out(T) out T\n#define _begin(type) type (\n#define _end )\n#define _mutable(T) T\n#define _constant(T) const T\n#define mul(a, b) (a) * (b)\n#endif\n\n#ifdef HLSL\n#define _in(T) const in T\n#define _inout(T) inout T\n#define _out(T) out T\n#define _begin(type) {\n#define _end }\n#define _mutable(T) static T\n#define _constant(T) static const T\n#define vec2 float2\n#define vec3 float3\n#define vec4 float4\n#define mat2 float2x2\n#define mat3 float3x3\n#define mat4 float4x4\n#define mix lerp\n#define fract frac\n#define mod fmod\n#pragma pack_matrix(row_major)\n#endif\n\n#ifdef HLSLTOY\ncbuffer uniforms : register(b0) {\n\tfloat2 u_res;\n\tfloat u_time;\n\tfloat2 u_mouse;\n};\nvoid mainImage(_out(float4) fragColor, _in(float2) fragCoord);\nfloat4 main(float4 uv : SV_Position) : SV_Target{ float4 col; mainImage(col, uv.xy); return col; }\n#endif\n\n#if defined(__cplusplus) || defined(SHADERTOY)\n#define u_res iResolution\n#define u_time iTime\n#define u_mouse iMouse\n#endif\n\n#ifdef GLSLSANDBOX\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define u_res resolution\n#define u_time time\n#define u_mouse mouse\nvoid mainImage(_out(vec4) fragColor, _in(vec2) fragCoord);\nvoid main() { mainImage(gl_FragColor, gl_FragCoord.xy); }\n#endif\n\n#ifdef UE4\n_constant(vec2) u_res = vec2(0, 0);\n_constant(vec2) u_mouse = vec2(0, 0);\n_mutable(float) u_time = 0;\n#endif\n\n#define PI 3.14159265359\n\nstruct ray_t {\n\tvec3 origin;\n\tvec3 direction;\n};\n#define BIAS 1e-4 // small offset to avoid self-intersections\n\nstruct sphere_t {\n\tvec3 origin;\n\tfloat radius;\n\tint material;\n};\n\nstruct plane_t {\n\tvec3 direction;\n\tfloat distance;\n\tint material;\n};\n\nstruct hit_t {\n\tfloat t;\n\tint material_id;\n\tvec3 normal;\n\tvec3 origin;\n};\n#define max_dist 1e8\n_constant(hit_t) no_hit = _begin(hit_t)\n\tfloat(max_dist + 1e1), // 'infinite' distance\n\t-1, // material id\n\tvec3(0., 0., 0.), // normal\n\tvec3(0., 0., 0.) // origin\n_end;\n\n// ----------------------------------------------------------------------------\n// Various 3D utilities functions\n// ----------------------------------------------------------------------------\n\nray_t get_primary_ray(\n\t_in(vec3) cam_local_point,\n\t_inout(vec3) cam_origin,\n\t_inout(vec3) cam_look_at\n){\n\tvec3 fwd = normalize(cam_look_at - cam_origin);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 right = cross(up, fwd);\n\tup = cross(fwd, right);\n\n\tray_t r = _begin(ray_t)\n\t\tcam_origin,\n\t\tnormalize(fwd + up * cam_local_point.y + right * cam_local_point.x)\n\t\t_end;\n\treturn r;\n}\n\nmat2 rotate_2d(\n\t_in(float) angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat2(_cos, -_sin, _sin, _cos);\n}\n\nmat3 rotate_around_z(\n\t_in(float) angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, -_sin, 0, _sin, _cos, 0, 0, 0, 1);\n}\n\nmat3 rotate_around_y(\n\t_in(float) angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, 0, _sin, 0, 1, 0, -_sin, 0, _cos);\n}\n\nmat3 rotate_around_x(\n\t_in(float) angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(1, 0, 0, 0, _cos, -_sin, 0, _sin, _cos);\n}\n\nvec3 corect_gamma(\n\t_in(vec3) color,\n\t_in(float) gamma\n){\n\tfloat p = 1.0 / gamma;\n\treturn vec3(pow(color.r, p), pow(color.g, p), pow(color.b, p));\n}\n\n#ifdef __cplusplus\nvec3 faceforward(\n\t_in(vec3) N,\n\t_in(vec3) I,\n\t_in(vec3) Nref\n){\n\treturn dot(Nref, I) < 0 ? N : -N;\n}\n#endif\n\nfloat checkboard_pattern(\n\t_in(vec2) pos,\n\t_in(float) scale\n){\n\tvec2 pattern = floor(pos * scale);\n\treturn mod(pattern.x + pattern.y, 2.0);\n}\n\nfloat band (\n\t_in(float) start,\n\t_in(float) peak,\n\t_in(float) end,\n\t_in(float) t\n){\n\treturn\n\tsmoothstep (start, peak, t) *\n\t(1. - smoothstep (peak, end, t));\n}\n// ----------------------------------------------------------------------------\n// Inverse Kinematics solvers\n// ----------------------------------------------------------------------------\n\nvec3 ik_2_bone_centered_solver(\n\t_in(vec3) goal,\n\t_in(float) L1,\n\t_in(float) L2\n){\n#if 0 // from https://www.shadertoy.com/view/ldlGR7\n\tvec3 q = goal*(0.5 + 0.5*(L1*L1 - L2*L2) / dot(goal, goal));\n\n\tfloat s = L1*L1 - dot(q, q);\n\ts = max(s, 0.0);\n\tq += sqrt(s)*normalize(cross(goal, vec3(0, 0, 1)));\n\n\treturn q;\n#else // naive version with law of cosines\n\tfloat G = length(goal);\n\n\t// tetha is the angle between bone1 and goal direction\n\t// get it from law of cosines applied to the\n\t// triangle with sides: bone1, bone2, pivot_of_bone1<->goal\n\tfloat cos_theta = (L1*L1 + G*G - L2*L2) / (2.*L1*G);\n\n\t// sin^2 + cos^2 = 1 (Pythagoras in unit circle)\n\tfloat sin_theta = sqrt(1. - cos_theta * cos_theta);\n\n\t// rotation matrix by theta amount around the axis\n\t// perpendicular to the plane created by bone1 and bone2\n\tmat3 rot = mat3(\n\t\tcos_theta, -sin_theta, 0,\n\t\tsin_theta, cos_theta, 0,\n\t\t0, 0, 1.\n\t\t);\n\n\t// get the end of bone1 aka the pivot of bone2\n\t// by getting a vector from the goal direction\n\t// and rotating along with the newly found theta angle\n\treturn mul(rot, (normalize(goal) * L1));\n#endif\n}\n\nvec3 ik_solver(\n\t_in(vec3) start,\n\t_in(vec3) goal,\n\t_in(float) bone_length_1,\n\t_in(float) bone_length_2\n){\n\treturn start + ik_2_bone_centered_solver(\n\t\tgoal - start, bone_length_1, bone_length_2);\n}\n// ----------------------------------------------------------------------------\n// Signed Distance Fields functions\n// ----------------------------------------------------------------------------\n\nvec2 op_add( // union\n\t_in(vec2) d1,\n\t_in(vec2) d2\n){\n\t// minimum distance (preserving material info)\n\treturn d1.x < d2.x ? d1 : d2;\n}\n\nfloat op_sub( // difference\n\t_in(float) d1,\n\t_in(float) d2\n){\n\t// intersection between first and\n\t// complement of the second field\n\t// aka the second 'carved out' from the first\n\treturn max(d1, -d2);\n}\n\nfloat op_intersect( // intersection\n\t_in(float) d1,\n\t_in(float) d2\n){\n\t// what's common for both fields\n\treturn max(d1, d2);\n}\n\nfloat op_blend(\n\t_in(float) a,\n\t_in(float) b,\n\t_in(float) k // factor of smoothing\n){\n\t// from https://iquilezles.org/articles/smin\n\t// NOTE: not true distance but estimate\n\tfloat h = clamp(0.5 + 0.5*(b - a) / k, 0.0, 1.0);\n\treturn mix(b, a, h) - k*h*(1.0 - h);\n}\n\nfloat sd_plane(\n\t_in(vec3) p,\n\t_in(vec3) n, // normal\n\t_in(float) d // distance\n){\n\t// distance from point to plane\n\t// http://mathworld.wolfram.com/Point-PlaneDistance.html\n\treturn dot(n, p) + d;\n}\n\nfloat sd_sphere(\n\t_in(vec3) p,\n\t_in(float) r\n){\n\t// distance to center of sphere offset by the radius\n\treturn length(p) - r;\n}\n\nfloat sd_box(\n\t_in(vec3) p,\n\t_in(vec3) b // dimensions of box\n){\n\t// intersection of 3 axis aligned 'slabs'\n\treturn max(abs(p.x) - b.x, max(abs(p.y) - b.y, abs(p.z) - b.z));\n}\n\nfloat sd_torus( // around Z axis\n\t_in(vec3) p,\n\t_in(float) R, // 'donut' radius\n\t_in(float) r  // thickness\n){\n\t// projected circle of radius R on xy plane\n\t// combined with circle of radius r around z axis\n\treturn length(vec2(length(p.xy) - R, p.z)) - r;\n}\n\nfloat sd_y_cylinder(\n\t_in(vec3) p,\n\t_in(float) r, // radius\n\t_in(float) h  // height\n){\n\t// distance to the Y axis, offset (aka inflated) by the cylinder radius\n\t// then intersected with 2 cutting planes\n\treturn max(length(p.xz) - r, abs(p.y) - h / 2.);\n}\n\nfloat sd_cylinder(\n\t_in(vec3) P,\n\t_in(vec3) P0, // start point\n\t_in(vec3) P1, // end point\n\t_in(float) R  // thickness\n){\n\t// distance to segment -- http://geomalgorithms.com/a02-_lines.html\n\t// then cut it with 2 planes at the ends\n\t// then offset it with radius    \n\tvec3 dir = normalize(P1 - P0);\n\tfloat dist = length(cross(dir, P - P0));\n\tfloat plane_1 = sd_plane(P, dir, length(P1));\n\tfloat plane_2 = sd_plane(P, -dir, -length(P0));\n\treturn op_sub(op_sub(dist, plane_1), plane_2) - R;\n}\n\n// 3D Bezier curved cylinder\n// original by http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\n// adapted by iq https://www.shadertoy.com/view/ldj3Wh\nfloat det(\n\t_in(vec2) a,\n\t_in(vec2) b\n){\n\treturn a.x*b.y - b.x*a.y;\n}\nvec3 sd_bezier_get_closest(\n\t_in(vec2) b0,\n\t_in(vec2) b1,\n\t_in(vec2) b2\n){\n\tfloat a = det(b0, b2);\n\tfloat b = 2.0*det(b1, b0);\n\tfloat d = 2.0*det(b2, b1);\n\tfloat f = b*d - a*a;\n\tvec2  d21 = b2 - b1;\n\tvec2  d10 = b1 - b0;\n\tvec2  d20 = b2 - b0;\n\tvec2  gf = 2.0*(b*d21 + d*d10 + a*d20); gf = vec2(gf.y, -gf.x);\n\tvec2  pp = -f*gf / dot(gf, gf);\n\tvec2  d0p = b0 - pp;\n\tfloat ap = det(d0p, d20);\n\tfloat bp = 2.0*det(d10, d0p);\n\tfloat t = clamp((ap + bp) / (2.0*a + b + d), 0.0, 1.0);\n\treturn vec3(mix(mix(b0, b1, t), mix(b1, b2, t), t), t);\n}\nvec2 sd_bezier(\n\t_in(vec3) a, // start\n\t_in(vec3) b, // knot (control point)\n\t_in(vec3) c, // end\n\t_in(vec3) p, \n\t_in(float) thickness\n){\n\tvec3 w = normalize(cross(c - b, a - b));\n\tvec3 u = normalize(c - b);\n\tvec3 v = normalize(cross(w, u));\n\n\tvec2 a2 = vec2(dot(a - b, u), dot(a - b, v));\n\tvec2 b2 = vec2(0., 0.);\n\tvec2 c2 = vec2(dot(c - b, u), dot(c - b, v));\n\tvec3 p3 = vec3(dot(p - b, u), dot(p - b, v), dot(p - b, w));\n\n\tvec3 cp = sd_bezier_get_closest(a2 - p3.xy, b2 - p3.xy, c2 - p3.xy);\n\n\treturn vec2(0.85*(sqrt(dot(cp.xy, cp.xy) + p3.z*p3.z) - thickness), cp.z);\n}\n\n// ----------------------------------------------------------------------------\n// Vectorpark Egg\n// ----------------------------------------------------------------------------\n\nvec3 background(_in(ray_t) ray)\n{\n\treturn vec3(.1, .1, .7);\n}\n\nvoid setup_scene()\n{\n#define mat_debug 0\n#define mat_egg 1\n#define mat_bike 2\n#define mat_ground 3\n}\n\nvoid setup_camera(_inout(vec3) eye, _inout(vec3) look_at)\n{\n\teye = vec3(0, 0.25, 5.25);\n\tlook_at = vec3(0, 0.25, 0);\n}\n\nvec3 illuminate(_in(hit_t) hit)\n{\n\tif (hit.material_id == mat_ground) return vec3(13. / 255., 104. / 255., 0. / 255.);\n\tif (hit.material_id == mat_egg) return vec3(0.9, 0.95, 0.95);\n\tif (hit.material_id == mat_bike) return vec3(.2, .2, .2);\n\treturn vec3(1, 1, 1);\n}\n\n#define BEZIER\nvec2 sdf(_in(vec3) P)\n{\n\tvec3 p = mul(rotate_around_y(u_time * -80.0), P)\n\t\t- vec3(0, 0.5, 3.5);\n\n\tint material = mat_egg;\n\n\tfloat egg_y = 0.65;\n#if 1\n\tfloat egg_m = sd_sphere(p - vec3(0, egg_y, 0), 0.475);\n\tfloat egg_b = sd_sphere(p - vec3(0, egg_y - 0.45, 0), 0.25);\n\tfloat egg_t = sd_sphere(p - vec3(0, egg_y + 0.45, 0), 0.25);\n\tfloat egg_1 = op_blend(egg_m, egg_b, .5);\n\tfloat egg_2 = op_blend(egg_1, egg_t, .5);\n\tvec2 egg = vec2(egg_2, material);\n#else\n\tfloat s = 1.55;\n\tmat3 scale = mat3(\n\t\ts, 0, 0,\n\t\t0, 1, 0,\n\t\t0, 0, 1);\n\tmat3 iscale = mat3(\n\t\t1./s, 0, 0,\n\t\t0, 1./s, 0,\n\t\t0, 0, 1.);\n\tvec2 egg = vec2(\n\t\tsd_sphere(iscale * (scale * (p - vec3(0, egg_y, 0))), 0.475),\n\t\tmaterial);\n#endif\n\n\tvec3 wheel_pos = vec3(0, 1.2, 0);\n\tfloat pedal_radius = 0.3;\n\tfloat pedal_speed = 500.;\n\tfloat pedal_off = 0.2;\n\n\tmat3 rot_z = rotate_around_z(-u_time * pedal_speed);\n\tvec3 left_foot_pos = wheel_pos + mul(rot_z, vec3(0., pedal_radius, pedal_off));\n\n\trot_z = rotate_around_z(-u_time * pedal_speed);\n\tvec3 right_foot_pos = wheel_pos + mul(rot_z, vec3(0., -pedal_radius, -pedal_off));\n\n\tvec3 side = vec3(0, 0, pedal_off);\n\tfloat femur = 0.8;\n\tfloat tibia = 0.75;\n\tfloat thick = .05;\n\n\tvec3 pelvis = vec3(0, 0., 0) + side;\n\tvec3 knee_l = ik_solver(pelvis, left_foot_pos, femur, tibia);\n#ifndef BEZIER\n\tvec2 left_leg_a = vec2(\n\t\tsd_cylinder(p + pelvis, vec3(0., 0., 0.), knee_l - side, thick),\n\t\tmaterial);\n\tvec2 left_leg_b = vec2(\n\t\tsd_cylinder(p + knee_l, vec3(0., 0., 0.), left_foot_pos - knee_l, thick),\n\t\tmaterial);\n#endif\n\n\tpelvis = vec3(0, 0., 0) - side;\n\tvec3 knee_r = ik_solver(pelvis, right_foot_pos, femur, tibia);\n#ifndef BEZIER\n\tvec2 right_leg_a = vec2(\n\t\tsd_cylinder(p + pelvis, vec3(0., 0., 0.), knee_r + side, thick),\n\t\tmaterial);\n\tvec2 right_leg_b = vec2(\n\t\tsd_cylinder(p + knee_r, vec3(0., 0., 0.), right_foot_pos - knee_r, thick),\n\t\tmaterial);\n#endif\n\n\tvec2 legs = op_add(\n#ifndef BEZIER\n\t\tvec2(op_blend(left_leg_a.x, left_leg_b.x, .01), material),\n\t\top_add(right_leg_a, right_leg_b)\n#else\n\t\tvec2(\n\t\tsd_bezier(-(vec3(0., 0., 0.) + side), -knee_l, -left_foot_pos, p, thick).x,\n\t\tmaterial),\n\t\tvec2(\n\t\tsd_bezier(-(vec3(0., 0., 0.) - side), -knee_r, -right_foot_pos, p, thick).x,\n\t\tmaterial)\n#endif\n\t);\n\n\tvec3 left_toe = normalize(vec3(left_foot_pos.y - knee_l.y, knee_l.x - left_foot_pos.x, 0));\n\tvec2 left_foot = vec2(\n\t\tsd_cylinder(p + left_foot_pos, vec3(0., 0., 0.), left_toe / 8., thick),\n\t\tmaterial);\n\n\tvec3 right_toe = normalize(vec3(right_foot_pos.y - knee_r.y, knee_r.x - right_foot_pos.x, 0));\n\tvec2 right_foot = vec2(\n\t\tsd_cylinder(p + right_foot_pos, vec3(0., 0., 0.), right_toe / 8., thick),\n\t\tmaterial);\n\n\tvec2 feet = op_add(left_foot, right_foot);\n\n\tvec2 bike = vec2(\n\t\tsd_torus(p + wheel_pos, 1., .03),\n\t\tmat_bike);\n\n\tvec2 ground = vec2(\n\t\tsd_plane(P, vec3(0., 1., 0.), wheel_pos.y + 0.5),\n\t\tmat_ground);\n\n\tvec2 _1 = op_add(feet, bike);\n\tvec2 _2 = op_add(egg, _1);\n\tvec2 _3 = op_add(legs, _2);\n\treturn op_add(ground, _3);\n}\n\nvec3 sdf_normal(_in(vec3) p)\n{\n\tfloat dt = 0.05;\n\tvec3 x = vec3(dt, 0, 0);\n\tvec3 y = vec3(0, dt, 0);\n\tvec3 z = vec3(0, 0, dt);\n\treturn normalize(vec3(\n\t\tsdf(p + x).r - sdf(p - x).r,\n\t\tsdf(p + y).r - sdf(p - y).r,\n\t\tsdf(p + z).r - sdf(p - z).r\n\t));\n}\n\n#define EPSILON 0.001\n\nfloat shadowmarch(_in(ray_t) ray)\n{\n\tconst int steps = 20;\n\tconst float end = 10.;\n\tconst float penumbra_factor = 15.;\n\tconst float darkest = 0.1;\n\n\tfloat t = 0.;\n\tfloat umbra = 1.;\n\tfor (int i = 0; i < steps; i++) {\n\t\tvec3 p = ray.origin + ray.direction * t;\n\t\tvec2 d = sdf(p);\n\n\t\tif (t > end) break;\n\t\tif (d.x < EPSILON) {\n\t\t\treturn darkest;\n\t\t}\n\n\t\tt += d.x;\n\t\t\n\t\t// from https://iquilezles.org/articles/rmshadows\n\t\tumbra = min(umbra, penumbra_factor * d.x / t);\n\t}\n\n\treturn umbra;\n}\n\n_mutable(float) depth = -max_dist;\n\nvec3 render(_in(ray_t) ray)\n{\n\tconst int steps = 80;\n\tconst float end = 15.;\n\n\tfloat t = 0.;\n\tfor (int i = 0; i < steps; i++) {\n\t\tvec3 p = ray.origin + ray.direction * t;\n\t\tvec2 d = sdf(p);\n\n\t\tif (t > end) break;\n\t\tif (d.x < EPSILON) {\n\t\t\thit_t h = _begin(hit_t)\n\t\t\t\tt, // ray length at impact\n\t\t\t\tint(d.y), // material id\n\t\t\t\tvec3(0, 0, 0), // sdf_normal(p),\n\t\t\t\tp // point of impact\t\t\t\t\n\t\t\t_end;\n\n\t\t\tif (h.material_id == mat_egg || h.material_id == mat_bike) {\n\t\t\t\tdepth = max(depth, p.z);\n\t\t\t}\n\n\t\t\tfloat s = 1.;\n#if 1 // soft shadows\n\t\t\tif (int(d.y) == mat_ground) {\n\t\t\t\tvec3 sh_dir = vec3(0, 1, 1);\n\t\t\t\tray_t sh_ray = _begin(ray_t)\n\t\t\t\t\tp + sh_dir * 0.05, sh_dir\n\t\t\t\t_end;\n\t\t\t\ts = shadowmarch(sh_ray);\n\t\t\t}\n#endif\n\n\t\t\treturn illuminate(h) * s;\n\t\t}\n\n\t\tt += d.x;\n\t}\n\n\treturn background(ray);\n}\n\nvoid mainImage(\n\t_out(vec4) fragColor,\n#ifdef SHADERTOY\n\tvec2 fragCoord\n#else\n\t_in(vec2) fragCoord\n#endif\n){\n\tvec2 aspect_ratio = vec2(u_res.x / u_res.y, 1);\n\tfloat fov = tan(radians(30.0));\n\n\tvec3 final_color = vec3(0, 0, 0);\n\n\tvec3 eye, look_at;\n\tsetup_camera(eye, look_at);\n\n\tsetup_scene();\n\n\tvec2 point_ndc = fragCoord.xy / u_res.xy;\n#ifdef HLSL\n\t\tpoint_ndc.y = 1. - point_ndc.y;\n#endif\n\tvec3 point_cam = vec3(\n\t\t(2.0 * point_ndc - 1.0) * aspect_ratio,// * fov,\n\t\t-1.0);\n\tray_t ray = get_primary_ray(point_cam, eye, look_at);\n\n\tfinal_color += render(ray);\n\n#if 1\n\t// from https://www.shadertoy.com/view/4sjGzc\n#define BAR_SEPARATION 0.6\n#define BAR_WIDTH 0.05\n#define BAR_DEPTH 1.\n#define BAR_COLOR vec3(.6, .6, .6)\n\tfloat bar_factor = 1.0 - smoothstep(0.0, 0.01, abs((abs(point_cam.x) - BAR_SEPARATION)) - BAR_WIDTH);\n\tfloat depth_factor = 1. - step(BAR_DEPTH, depth);\n\tfinal_color = mix(final_color, BAR_COLOR, bar_factor * depth_factor);\n#endif\n\n\tfragColor = vec4(corect_gamma(final_color, 2.25), 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}