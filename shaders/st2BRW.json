{
    "Shader": {
        "info": {
            "date": "1652121987",
            "description": "Space to Reset terrain, One(1) to view terrain and particles, Two(2) to toggle erosion on and off.\nBased on a previous shader of mine, reworked to use reintegration tracking(https://michaelmoroz.github.io/Reintegration-Tracking/) for erosion.",
            "flags": 48,
            "hasliked": 0,
            "id": "st2BRW",
            "likes": 9,
            "name": "Erosion Landscape V2",
            "published": 3,
            "tags": [
                "procedural",
                "raymarching",
                "simulation",
                "clouds",
                "landscape",
                "volumetrics",
                "erosion"
            ],
            "usePreview": 0,
            "username": "Dragonpeak",
            "viewed": 426
        },
        "renderpass": [
            {
                "code": "// When focused on the shader window, space to reset terrain, One(1) to view terrain and particles, Two(2) to toggle erosion on and off.\n//Based on a previous shader of mine, reworked to use reintegration tracking(https://michaelmoroz.github.io/Reintegration-Tracking/) for erosion.\n\n// a quick dof, doesn't quite work on the clouds but it is good enough\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\n    if(data.w >=FAR)\n    {\n        col = data.xyz;\n    }\n    else\n    {\n        //col = data.xyz;\n        float focus = abs(data.w-FOCUS_DIST)/FAR*BLUR_MUL;\n        float tot = 0.;\n        int blur_size = int(focus+1.)*2;\n        for(int x = -blur_size; x < blur_size; x++)\n        {\n\n            float w = Gaussian(float(x), 1., 0., focus);\n            tot+=w;\n            col += texelFetch(iChannel0, ivec2(fragCoord)+ivec2(0,x),0).xyz*w;\n        }\n        col/=tot;\n    }\n    \n    col*=vec3(0.690,0.765,0.812)*.8;\n    //col = vec3(focus); \n    if(texelFetch(iChannel3, ivec2(49,2),0).x>0.)col = texture(iChannel1, fragCoord/iResolution.xy).www*.5 +  texture(iChannel2, fragCoord/iResolution.xy).zzz*vec3(100,0,0);\n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//terrain\nconst vec2 OFF = vec2(.1, 0.3);\nconst float BLUR_AMT = .1;\n\nconst vec2 NRM_EPS = vec2(.1,0.);\nconst float NRM_SOFT = .002;\nconst int OCT = 16;\n\n\n\n\nfloat GetTerrain(vec2 p)\n{\n    float data = 0.;\n    if(iFrame < 5 || IsSpaceDown(iChannel3))\n    {\n        p/=iResolution.xy;\n        p += OFF;\n        float s = 2.5;\n        float a = .5;\n        \n        for(int i = 0; i < OCT; i++)\n        {\n            data += abs(Noise2D((p+vec2(float(i)*7.8936345, float(i)*-13.73467))*s)*a-a/2.)/2.*.7+\n            Noise2D((p-17.+vec2(float(i)*7.8936345, float(i)*-13.73467))*s)*a*.3;\n            s*= 1.7;\n            a*= .5;\n        }\n       \n        data = pow(1.-data, 7.8)*1.8* mix(1., .4, pow(length((p-OFF-.5)*.8), .7))-.08;\n    }\n    else\n    {\n        data = texture(iChannel1, p/iResolution.xy).w;\n    }\n    \n    return data;\n}\n\nvec3 GetTerrainNrm(vec2 uv)\n{ \n    vec3 nrm = vec3(0.);\n    nrm.x = -(GetTerrain(uv+NRM_EPS) - GetTerrain(uv-NRM_EPS));\n    nrm.y = -(GetTerrain(uv+NRM_EPS.yx) - GetTerrain(uv-NRM_EPS.yx));\n    nrm.z = NRM_EPS.x*NRM_SOFT;\n    nrm = normalize(nrm);\n    \n    return nrm;\n}\n\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float f = GetTerrain(fragCoord);\n    vec4 data = texture(iChannel2, fragCoord/iResolution.xy);\n    f-= mix(.6, 1., Noise2D(fragCoord/iResolution.xy*80.))*iResolution.x*.0000000005*(length(data.xy)-90.)*float(texelFetch(iChannel3, ivec2(50, 2),0).x<=0.);\n    \n\n    f = clamp(f,0.,1.);\n    fragColor = vec4(GetTerrainNrm(fragCoord),f);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nconst float WATER_HEIGHT = .02;\nconst float FOCUS_DIST = 2.3;\nconst float BLUR_MUL = 6.;\n\n\nconst vec2 WIND = vec2(.06, .1);\nconst float FAR = 5.;\nuvec2 pcg2d(uvec2 v)\n{\n    //from https://www.shadertoy.com/view/XlGcRh\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\nuvec3 pcg3d(uvec3 v) \n{\n    //from https://www.shadertoy.com/view/XlGcRh\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\nvec2 Rand2D(vec2 v)\n{\n    return vec2(pcg2d(uvec2(v)))/float(0xffffffffu);\n}\nvec3 Rand3D(vec3 v)\n{\n    return vec3(pcg3d(uvec3(v)))/float(0xffffffffu);\n}\n\nfloat Noise2D(vec2 p)\n{\n    vec2 ap = abs(p);\n    vec2 fr = fract(ap);\n    fr = fr * fr * (3. - 2. * fr);\n    \n    float a = Rand2D(ap).x;\n    float b = Rand2D(ap+vec2(1,0)).x;\n    float c = Rand2D(ap+vec2(0,1)).x;\n    float d = Rand2D(ap+vec2(1)).x;\n\n    float v = mix(mix(a,b, fr.x),mix(c,d,fr.x), fr.y);\n    \n\n    \n\n    return v;\n}\nfloat Noise3D(vec3 p)\n{\n    vec3 ap = abs(p);\n    vec3 fr = fract(ap);\n    fr = fr * fr * (3. - 2. * fr);\n    \n    float a = Rand3D(ap).x;\n    float b = Rand3D(ap+vec3(1,0,0)).x;\n    float c = Rand3D(ap+vec3(0,1,0)).x;\n    float d = Rand3D(ap+vec3(1,1,0)).x;\n    \n    float e = Rand3D(ap+vec3(0,0,1)).x;\n    float f = Rand3D(ap+vec3(1,0,1)).x;\n    float g = Rand3D(ap+vec3(0,1,1)).x;\n    float h = Rand3D(ap+vec3(1,1,1)).x;\n\n    float v = mix(mix(mix(a,b, fr.x),mix(c,d,fr.x), fr.y), mix(mix(e,f, fr.x),mix(g,h,fr.x), fr.y), fr.z);\n    \n\n    \n\n    return v;\n}\n\n\n\nbool IsSpaceDown(sampler2D key)\n{\n    return texelFetch(key, ivec2(32,0),0).x>0.;\n}\n\nfloat Gaussian(float x, float a, float b, float c)\n{\n    return a*exp(-(pow(x-b,2.)/pow(2.*c,2.)));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//particles https://michaelmoroz.github.io/Reintegration-Tracking/\nconst int AREA = 5;\nfloat SIZE = .0005;\nconst float FRICTION = .98;\nconst float SPEED = .3;\nconst float ERR_STR =.000007;\nbool BBOX_intersect(vec4 a, vec4 b)\n{\n     return !(b.x > a.z\n        || b.z < a.x\n        || b.y > a.w\n        || b.w < a.y);\n}\nvec4 BBOX_overlap(vec4 a, vec4 b)\n{\n    vec4 r = vec4(0);\n    r.xy = max(a.xy,b.xy);\n    r.zw = min(a.zw,b.zw);\n    if(r.x > r.z || r.y > r.w)return vec4(-1);\n    return r;\n}\n\nfloat BBOX_size(vec4 bbox)\n{\n    return max((bbox.x-bbox.z)*(bbox.y-bbox.w),0.);\n}\nfloat BBOX_percent(vec4 a, vec4 b)\n{\n    return BBOX_size(a)/BBOX_size(b);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    SIZE*=iResolution.x;\n    fragColor = vec4(0);\n    \n    if(!(iFrame < 5 || IsSpaceDown(iChannel2)))\n    {\n        vec4 bbox = vec4(fragCoord-.5, fragCoord+.5);\n        for(int x = -AREA; x < AREA; x++)\n        {\n            for(int y = -AREA; y < AREA; y++)\n            {\n                vec2 pos = fragCoord+vec2(x,y);\n\n                vec4 data = texture(iChannel0, pos/iResolution.xy);\n                pos += data.xy*0.01;\n           \n                \n              \n                \n                vec4 prbox = vec4(pos-SIZE,pos+SIZE);\n                if(BBOX_intersect(bbox,prbox))\n                {\n                    vec4 overlap = BBOX_overlap(prbox, bbox);\n                    float amt = BBOX_percent(overlap, prbox);\n\n                    \n                    fragColor += data*amt;\n                }\n           \n                \n            }\n        }\n    \n       \n    }\n    vec4 data = texelFetch(iChannel1, ivec2(fragCoord), 0); \n    if(Rand2D((fragCoord*iTime*100000.3261*iTimeDelta)).x>.9 && data.w > WATER_HEIGHT)\n    {\n        fragColor.xy += normalize(Rand2D((fragCoord+iTime*12.3261*iTimeDelta))*2.-1.)*50.;\n        fragColor.z += Rand2D((fragCoord*iTime*300000.3261*iTimeDelta)).x*.005;\n \n    }\n    if(fragColor.z != 0.)\n    {\n        \n        vec2 vel = vec2(0);\n        vel += normalize(Rand2D((fragCoord*14124.*iTime*12.3261*iTimeDelta))*2.-1.)*50.;\n        \n        vel += data.xy*10.;\n        //vel += vec2(0,-5.);\n        vel *=SPEED;\n        fragColor.xy += vel;\n        fragColor.z+=ERR_STR*length(fragColor.xy)-.0005;\n        \n        //fragColor.xy/=fragColor.z;\n        fragColor.xy*=FRICTION;\n        fragColor.z*=.99;\n        //fragColor.xy = normalize(fragColor.xy);\n        //fragColor *= (data.w < WATER_HEIGHT) ? vec4(vec2(0.95), .99, 1.) : vec4(1.);\n        \n        \n        \n       \n        \n    }\n   \n\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//rendering\nvec3 CAMERA_POS = vec3(-1.5, -1.5, 1.);\nconst vec3 CAMERA_LOOK = vec3(0.,0.,0.);\n\n\nconst float EPS = .01;\nconst float SHADOW_EPS = .03;\nconst float STEP_SIZE = .002;\nconst float SHADOW_STEP = .05;\nvec3 SUN_DIR = normalize(vec3(.3, .5, .2));\nconst vec3 SUN_COL = vec3(1,.7,.4)*2.5;\nconst vec3 AMBIENT = vec3(.3,.35,.53)*.3;\n\nconst vec2 W_NRM_EPS = vec2(.001,0.);\n\nconst float CLOUDS_STEP = .01;\nconst int CLOUD_OCT = 6;\nconst float CLOUD_SCALE = .0016;\nconst float CLOUD_LIGHT_STEP = .04;\nconst float CLOUD_LIGHT_FAR = .1;\n\nconst int TERRAIN_BUMP_OCT = 4;\n\nconst vec2 T_NRM_EPS = vec2(.0017,0.);\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\nRay ConstructViewRay(vec2 screen_pos, vec3 pos, vec3 look_dir, vec3 up, float len)\n{\n    Ray r = Ray(pos, vec3(0));\n    \n    vec3 side = cross(up, look_dir);\n    vec3 cam_up = cross(look_dir,side);\n    \n    r.dir = normalize(side*screen_pos.x+cam_up*screen_pos.y+look_dir*len);\n    \n    return r;\n}\n\nvec2 RayBoxIntersect( Ray r, vec3 boxSize, out vec3 outNormal ) \n{\n    //from https://iquilezles.org/articles/intersectors\n    vec3 m = 1.0/r.dir; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*r.origin;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(FAR); // no intersection\n    outNormal = -sign(r.dir)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\nvec4 GetTerrain(vec2 p)\n{\n    if(p.x > 1. || p.y > 1.|| p.x < -1.|| p.y < -1.) return vec4(0,0,1,0);\n    vec4 data = texture(iChannel0, (p+vec2(1.01))*.47);\n    return data;\n}\n\nvec4 MarchTerrain(Ray r, float dist, float far)\n{\n    vec4 data = vec4(0);\n    while(dist < far)\n    {\n        vec3 p = r.origin+r.dir*dist;\n        data = GetTerrain(p.xy);\n        if(p.z < data.w+EPS)return vec4(data.xyz, dist-STEP_SIZE/2.);\n        dist += STEP_SIZE*(Rand3D(p+iTime).x+.5);\n    }\n    return vec4(data.xyz, FAR);\n}\nfloat MarchShadows(Ray ray, float k)\n{\n    float r = 1.;\n    float dep = 0.001+SHADOW_EPS;\n    while(dep < FAR)\n    {\n        vec3 p = ray.origin+ray.dir*dep;\n        vec4 data = GetTerrain(p.xy);\n        //if(p.z < dist+SHADOW_EPS) 0.;\n        \n        r = min(r, k*(p.z-data.w)/dep);\n        dep += SHADOW_STEP;\n    }\n    return r;\n}\n\n\nfloat CloudDens(vec3 p)\n{\n   float s = 2.;\n   float a = .5;\n   float data = 0.;\n   for(int i = 0; i < CLOUD_OCT; i++)\n   {\n       data += Noise3D(((p+vec3(float(i)*7.8936345, float(i)*-13.73467, float(i)*-36.71261))*s)+vec3(WIND,0.)*iTime)*a;\n       s*= 1.8;\n       a*= .6;\n   }\n   data = min(max(data-.7, 0.)*4., 1.);\n   \n   float h = max(1.-max(abs(p.z-.4)+4.93, 0.)*.2, 0.);\n   \n   return max(data*h*50.,0.);\n       \n}\n\nvec3 MarchCloudLight(Ray r)\n{\n    float dep = 0.;\n    float dens = 0.;\n    while(dep < CLOUD_LIGHT_FAR)\n    {\n        vec3 pos = r.origin+r.dir*dep;\n        dens += CloudDens(pos)*8.;\n        dep += CLOUD_LIGHT_STEP;\n    }\n    return (vec3(exp(-(dens)))*SUN_COL*1.2+AMBIENT*.1)*vec3(.85,.87,1.3)*1.6;\n}\n\nvec4 MarchClouds(Ray r, float mi, float ma)\n{\n    float dep = mi;\n    float trans = 1.;\n    vec3 light = vec3(0.);\n    while(dep < ma)\n    {\n        vec3 pos = r.origin+r.dir*dep;\n        float cd = CloudDens(pos);\n        dep += CLOUDS_STEP;\n        if(cd>.01)\n        {\n            light += MarchCloudLight(Ray(pos, SUN_DIR))*cd*trans;\n            trans *= exp(-cd);\n        }\n    }\n    return vec4(light, trans);\n}\n\n\n\nfloat TerrainBump(vec2 p)\n{\n   float s = 60.;\n   float a = .5;\n   float data = 0.;\n   for(int i = 0; i < TERRAIN_BUMP_OCT; i++)\n   {\n       data += Noise2D(((p.xy+vec2(float(i)*7.8936345, float(i)*-13.73467))*s))*a;\n       s*= 1.8;\n       a*= .6;\n   }\n   return data;\n}\n\nvec3 TerrainBumpNrm(vec2 p)\n{\n    vec3 nrm = vec3(0.);\n    nrm.x = -(TerrainBump(p+T_NRM_EPS) - TerrainBump(p-T_NRM_EPS));\n    nrm.y = -(TerrainBump(p+T_NRM_EPS.yx) - TerrainBump(p-T_NRM_EPS.yx));\n    nrm.z = .8;\n    nrm = normalize(nrm);\n    \n    return nrm;\n}\n\n\nfloat GetAO(vec2 p)\n{\n    vec2 t = vec2(EPS*3., 0);\n    float ao = 0.;\n    \n    float b = GetTerrain(p).w;\n    \n    float x = (GetTerrain(p+t).w+GetTerrain(p-t).w+GetTerrain(p+t.yx).w+GetTerrain(p-t.yx).w)/4.;\n    \n    ao += b-x;\n    \n    return ao*16.+.4;\n}\n\nvec3 TextureTerrain(vec3 p, vec3 nrm, bool is_edge)\n{\n    vec3 col = vec3(0.);\n    vec3 stone = vec3(.6);\n    vec3 grass = vec3(.4, .6, .4);\n    vec3 snow = vec3(1.1, 1.1, 1.2)*4.;\n\n    float stone_mask = min(max((nrm.z-.75), 0.)*8.*smoothstep(0.12, .8, Noise3D(p*40.)), 1.);\n    float snow_mask = min(max((p.z-.2)*Noise3D(p*30.), 0.)*64., 1.);\n    \n    vec3 ground = mix(grass, snow, snow_mask);\n    \n    col = mix(stone, ground, stone_mask)*mix(.6, 1., Noise3D(p*20.+41.));\n\n    \n    return col;\n}\n\nfloat CloudShadow(vec3 p)\n{\n    return 1.-CloudDens(p+SUN_DIR*max(dot(vec3(0,0,.4)-p, vec3(0,0,-1))/dot(SUN_DIR, vec3(0,0,-1)), 0.));\n}\n\nvec3 ShadeTerrain(vec3 p, vec3 nrm, vec3 dir, float dist, bool is_edge)\n{\n\n    vec3 col = TextureTerrain(p,nrm,is_edge);\n    float sun = clamp(dot(SUN_DIR, nrm), 0.,1.);\n    vec3 r = reflect(dir, nrm);\n    vec3 ref = vec3(min(max((dot(r, SUN_DIR)-.85), 0.)*4., 1.));\n    if(!is_edge)\n    {\n        float shadow = clamp(MarchShadows(Ray(p, SUN_DIR), 10.),0.,1.);\n        shadow *= clamp(CloudShadow(p)*2.3-1.3,0.,1.);\n\n        sun *= shadow;\n        ref *= shadow;\n        //return vec3(shadow);\n\n    }\n    vec3 light = SUN_COL*sun;\n    light += AMBIENT;\n    light += ref;\n    light += vec3(.2, .2, .1)*max(dot(-SUN_DIR, nrm),0.);\n    \n    if(!is_edge)\n    {\n        float ao = GetAO(p.xy);\n\n        light *= ao;\n    }\n    \n  \n    col *= light;\n    //col = nrm;\n    //col = vec3(shadow);\n   \n    return col;\n}\n\nvec3 DrawFog(vec3 p, float d, bool is_edge)\n{\n    if(is_edge)return vec3(0);\n    d /= FAR;\n    d = exp(d);\n    float z = 1.-min(max(p.z-.03, 0.)*5., 1.);\n    z *= d;\n    return vec3(.7, .7, .9)*z*.2;\n}\n\nvec3 ShadeSky(vec3 d)\n{\n    vec3 col = mix(vec3(.8,.8, 1.), vec3(.025, .05, .7)*.8, clamp(d.z+.4, 0., 1.));\n    \n    \n    col += SUN_COL*max(1.-max(distance(SUN_DIR, d)+.9, 0.), 0.)*10.;\n    \n    return col;\n}\n\nfloat WaterHeight(vec2 p)\n{\n    return Noise2D((p*100.2+144.)+WIND*iTime);\n}\n\nvec3 WaterNrm(vec2 p)\n{\n    vec3 nrm = vec3(0.);\n    nrm.x = -(WaterHeight(p+W_NRM_EPS) - WaterHeight(p-W_NRM_EPS));\n    nrm.y = -(WaterHeight(p+W_NRM_EPS.yx) - WaterHeight(p-W_NRM_EPS.yx));\n    nrm.z = .5;\n    nrm = normalize(nrm);\n    \n    return nrm;\n}\n\nvec3 Fresnel(float cosTheta, vec3 F0)\n{\n    //from https://learnopengl.com/PBR/Theory\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 ShadeWater(vec3 dir, float d, float wd, vec3 nrm)\n{\n    nrm = normalize(nrm+WaterNrm((CAMERA_POS+dir*wd).xy));\n    float h = GetTerrain((CAMERA_POS+dir*wd).xy).w/WATER_HEIGHT*2.;\n    float fr = Fresnel(dot(dir, nrm), vec3(1.055)).x;//Fresnel\n    vec3 sky = ShadeSky(reflect(dir, nrm));\n\n    return vec3(sky*fr*.5+h*.4);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n\n    SUN_DIR.x = sin(iTime*.1-.8);\n    SUN_DIR.y = cos(iTime*.1-.8);\n    SUN_DIR = normalize(SUN_DIR);\n    CAMERA_POS.y = sin(iTime*0.2)*2.5;\n    CAMERA_POS.x = cos(iTime*0.2)*2.5;\n\n    vec2 screen_pos = fragCoord.xy/iResolution.y*2.-1.-vec2(iResolution.x/iResolution.y/2.,0);\n\n    \n    Ray view_ray = ConstructViewRay(screen_pos, CAMERA_POS, normalize(-CAMERA_POS), vec3(0,0,1), 2.);\n\n    vec3 b_nrm;\n    vec3 box_s = vec3(1,1,FAR);\n    vec2 b_dist = RayBoxIntersect(view_ray, box_s, b_nrm);\n    col = ShadeSky(view_ray.dir);\n    vec4 data = vec4(0,0,0,FAR);\n    if(b_dist.x<FAR)\n    {\n\n        data = MarchTerrain(view_ray, b_dist.x, b_dist.y);\n        if(data.w <= b_dist.x+EPS) data = vec4(b_nrm, b_dist.x);\n        data.w = min(data.w, b_dist.y);\n        vec3 pos = CAMERA_POS+view_ray.dir*data.w;\n\n        bool is_edge = data.w <= b_dist.x;\n        vec3 WaterNrm;\n        vec2 water_d = RayBoxIntersect(view_ray, vec3(box_s.xy, WATER_HEIGHT), WaterNrm);\n        //if(is_edge) data.xyz = b_nrm;\n        if(data.w < b_dist.y)\n        {\n             if(!is_edge)data.xyz = normalize(data.xyz+TerrainBumpNrm(pos.xy));\n             col = ShadeTerrain(pos, data.xyz, view_ray.dir, data.w,is_edge);\n             col *= (is_edge) ? max(min(pos.z*.3+.1, 1.), 0.)+.01 : 1.;\n\n             //col = data.xyz;\n        }\n        if(water_d.x < data.w)\n        {\n\n            col += ShadeWater(view_ray.dir, data.w, water_d.x, WaterNrm);\n            data.w = water_d.x;\n        }\n        vec3 ndump;\n        col += DrawFog(pos, data.w,is_edge);\n        vec2 cbox = RayBoxIntersect(Ray(CAMERA_POS-vec3(0.,0.,.4), view_ray.dir), vec3(box_s.xy, .1),ndump);\n        if(cbox.x < FAR)\n        {\n            vec4 cld = MarchClouds(Ray(CAMERA_POS, view_ray.dir+vec3(vec2(pcg2d(uvec2(fragCoord)+uint(iFrame)))/float(0xffffffffu)*.002, 0.)), cbox.x+.01, min(data.w, cbox.y));\n            data.w = mix(data.w, cbox.x, 1.-cld.w);\n            col = mix(cld.rgb, col, cld.w);\n            //col = vec3(1.);\n        }\n\n        //col = vec3(cld.rgb);\n\n    }\n    \n    //col = vec3(CloudDens(vec3(fragCoord/iResolution.xy*3., 1.)));\n    \n    //col = vec3(Noise2D(fragCoord/iResolution.xy*80.));\n    // Output to screen\n    fragColor = vec4(col, data.w);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 col = vec3(0.);\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\n    if(data.w >=FAR)\n    {\n        col = data.xyz;\n    }\n    else\n    {\n        //col = data.xyz;\n        float focus = abs(data.w-FOCUS_DIST)/FAR*BLUR_MUL;\n        float tot = 0.;\n        int blur_size = int(focus+1.)*2;\n        for(int x = -blur_size; x < blur_size; x++)\n        {\n\n            float w = Gaussian(float(x), 1., 0., focus);\n            tot+=w;\n            col += texelFetch(iChannel0, ivec2(fragCoord)+ivec2(x,0),0).xyz*w;\n        }\n        col/=tot;\n    }\n\n    fragColor = vec4(col,data.w);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}