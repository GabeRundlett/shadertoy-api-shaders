{
    "Shader": {
        "info": {
            "date": "1612670689",
            "description": "Path-Tracing 2 Spheres but with Ray-Tracing. I don't know much about making intersection functions, but combining them was kind of intuitive. Normals are heck though and I have no clue how they work, Normals in Ray-Marching are much easier to find.",
            "flags": 32,
            "hasliked": 0,
            "id": "3ttBWH",
            "likes": 7,
            "name": "Path-Tracing: Ray-Tracing",
            "published": 3,
            "tags": [
                "raytracing",
                "raytracer",
                "raytrace",
                "pathtrace",
                "pathtracing",
                "pathtracer"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 394
        },
        "renderpass": [
            {
                "code": "// ##### Path-Tracing: Ray-Tracing #####\n// Made by Zi7ar21 on February 6th, 2020\n// Last updated: February 6th, 2020 20:50 Mountain Time\n\n// If you found this anywhere other than Shadertoy, a possibly updated version can be found at:\n// https://www.shadertoy.com/view/3ttBWH\n\n// Common is for Parameters, Constants, and Other Functions.\n// Buffer A is for Path-Tracing the scene.\n// Buffer B is for Exporting a 32-BPC Floating Point OpenEXR Image.\n// This is for Drawing the main image.\n\n// ##### Contributors #####\n// LoicVDB and Michael0884 helped me a ton with my shaders, check them out:\n// https://www.shadertoy.com/user/loicvdb\n// https://www.shadertoy.com/user/michael0884\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This contains Parameters, Constants, and Other Functions.\n\n// ##### Common Parameters #####\n// Mouse Control Sensitivity\n#define mousesensitivity 4.0\n\n// Camera Field of View\n#define camfov 1.0\n\n// Roughness Texture Octaves\n#define octaves 4\n\n// ##### Constants and Functions #####\n// Pi (Quadruple Precision Float Future-Proof)\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n#define quarterpi pi*0.25\n#define twopi pi*2.0\n\n// ##### LoicVDB's Sky Parameters #####\n// Controls Sky Quality\n#define SkySamples 8\n\n// Controls Sky Color\n#define SkyColor vec3(0.25, 0.5, 1.0)\n\n// Controls Light Color\n#define LightColor vec3(1.0, 1.0, 1.0)\n\n// Controls Sky Direction\n#define SkyUp vec3(0.0, 1.0, 0.0)\n\n// Controls Light Direction\n#define LightDirection normalize(vec3(1.0, 1.0, -1.0))\n\n// Controls Sky Intensity\n#define SkyIntensity 0.25\n\n// Controls Light Intensity\n#define LightIntensity 1.0\n\n// Controls the Radius of the Light\n#define LightRadius 0.125\n\n// Controls Mie Scattering Intensity\n#define MieIntensity 0.05\n\n// Controls Mie Scattering Anisotropy\n#define MieAnisotropy 0.6\n\n// LoicVDB's (Slightly Modified) Sky Functions (Loic's Profile: https://www.shadertoy.com/user/loicvdb)\n// (I don't know where to link to other than his profile page, since this\n// is from a Fragmentarium shader he shared on the Marble Marcher Discord)\nfloat anisotropicWeight(vec3 dirI, vec3 dirO, float a){\n \treturn quarterpi*(1.0-a*a)/pow(1.0+a*(a-2.0*dot(dirI, dirO)), 1.5);\n}\n\nvec3 skyDirectLight(vec3 pos, int i) {\n    if(dot(LightDirection, SkyUp) < 0.0){return vec3(0.0);}\n    vec3 volAbs = vec3(1.0), stepAbsRay, stepAbsMie;\n    float alt, dist, ds;\n    for(; i < SkySamples; i++){\n        alt = -log(1.0-sign(dot(LightDirection, SkyUp))*float(i)/float(SkySamples));\n    \tdist = alt/dot(LightDirection, SkyUp);\n        ds = exp(-dot(pos, SkyUp));\n        stepAbsRay = exp(-ds*dist*SkyColor*SkyIntensity);\n        stepAbsMie = exp(-ds*dist*MieIntensity*vec3(1.0));\n        volAbs *= stepAbsMie*stepAbsRay;\n        pos += LightDirection*dist;\n    }\n    return LightColor.rgb*LightColor*volAbs;\n}\nvec3 backgroundDirectLight(vec3 dir) {\n\tif(dot(dir, LightDirection) < cos(LightRadius)){return vec3(0.0);}\n\tfloat sphericalCapArea = sin(LightRadius)*sin(LightRadius);\n\tfloat lightStrength = LightIntensity/(sphericalCapArea);\n\treturn lightStrength*LightColor.rgb;\n}\n\nvec3 skyScatter(vec3 dir, bool hasSun){\n    vec3 pos = vec3(0.0), volCol = vec3(0.0), volAbs = vec3(1.0);\n    vec3 stepAbsRay, stepAbsMie, stepColRay, stepColMie;\n    float alt, dist, ds;\n    float aw = anisotropicWeight(dir, LightDirection, MieAnisotropy);\n    for(int i = 0; i < SkySamples; i++) {\n        alt = -log(1.0-sign(dot(dir, SkyUp))*float(i)/float(SkySamples));\n    \tdist = min(alt/dot(dir, SkyUp), 5.0);\n        ds = exp(-dot(pos, SkyUp));\n        stepAbsRay = exp(-ds*dist*SkyColor.rgb*SkyIntensity);\n        stepAbsMie = exp(-ds*dist*MieIntensity*vec3(1.0));\n        stepColRay = (1.0-stepAbsRay);\n        stepColMie = (1.0-stepAbsMie)*aw;\n        volCol += (stepColMie+stepColRay)*volAbs*skyDirectLight(pos, i);\n        volAbs *= stepAbsRay*stepAbsMie;\n        pos += dir*dist;\n    }\n    return volCol+(hasSun ? backgroundDirectLight(dir)*volAbs:vec3(0.0));\n}\n\n// Hash: https://www.shadertoy.com/view/4djSRW\nvec3 hash(vec3 pos){\n\tpos =  fract(pos*vec3(0.1031, 0.1030, 0.0973));\n    pos += dot(pos, pos.yxz+33.33);\n    return fract((pos.xxy+pos.yxx)*pos.zyx);\n}\n\n// Gradient Noise: https://iquilezles.org/articles/gradientnoise\nfloat noise(vec3 x){\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 ga = hash(p+vec3(0.0,0.0,0.0));\n    vec3 gb = hash(p+vec3(1.0,0.0,0.0));\n    vec3 gc = hash(p+vec3(0.0,1.0,0.0));\n    vec3 gd = hash(p+vec3(1.0,1.0,0.0));\n    vec3 ge = hash(p+vec3(0.0,0.0,1.0));\n    vec3 gf = hash(p+vec3(1.0,0.0,1.0));\n    vec3 gg = hash(p+vec3(0.0,1.0,1.0));\n    vec3 gh = hash(p+vec3(1.0,1.0,1.0));\n    float va = dot(ga, w-vec3(0.0,0.0,0.0));\n    float vb = dot(gb, w-vec3(1.0,0.0,0.0));\n    float vc = dot(gc, w-vec3(0.0,1.0,0.0));\n    float vd = dot(gd, w-vec3(1.0,1.0,0.0));\n    float ve = dot(ge, w-vec3(0.0,0.0,1.0));\n    float vf = dot(gf, w-vec3(1.0,0.0,1.0));\n    float vg = dot(gg, w-vec3(0.0,1.0,1.0));\n    float vh = dot(gh, w-vec3(1.0,1.0,1.0));\n    return va+\n    u.x*(vb-va)+\n    u.y*(vc-va)+\n    u.z*(ve-va)+\n    u.x*u.y*(va-vb-vc+vd)+\n    u.y*u.z*(va-vc-ve+vg)+\n    u.z*u.x*(va-vb-ve+vf)+\n    u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}\n\n// 3D FBM: https://www.shadertoy.com/view/3dSBRh\nfloat fbm(vec3 x){\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfor (int i = 0; i < octaves; i++){\n\t\tv += a*noise(x);\n\t\tx = x.zyx*2.0;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x+fragCoord.y*iResolution.x);\n\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state >> ((state >> 28u)+4u)) ^ state)*277803737u;\n    ns = (word >> 22u) ^ word;\n}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\n//vec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random, also from Michael0884: https://www.shadertoy.com/view/WttyWX\n/*float ErfInv(float x){\n   float lnx = log((1.0-x)*(1.0+x));\n   float tt1 = 4.3308+0.5*lnx;\n   float tt2 = 6.8027*lnx;\n   return(sign(x)*sqrt(-tt1+sqrt(tt1*tt1-tt2)));\n}*/\n\n//float nrand(){return ErfInv(rand()*2.0-1.0);}\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// This is for Path-Tracing the scene.\n\n// https://iquilezles.org/articles/intersectors\n// Sphere Intersection Function\nvec2 sphere(vec3 raydir, vec3 rayori, vec3 center, float radius){\n    vec3 oc = rayori-center;\n    float b = dot(oc, raydir);\n    float c = dot(oc, oc)-radius*radius;\n    float h = b*b-c;\n    if(h < 0.0){return vec2(-1.0);}\n    h = sqrt(h);\n    return vec2(-b-h, -b+h);\n}\n\n// Sphere Normal Function\nvec3 sphereNormal(float hit, vec3 raydir, vec3 rayori, vec3 spherepos, float sphererad){\n    return normalize((rayori+(raydir*hit))-spherepos);\n}\n\n// Scene Intersection and Normals\nvec2 scene(vec3 raydir, vec3 rayori, out vec3 normal){\n    vec2 hit;\n    vec3  s0pos = vec3(-0.125, 0.0, 0.0);\n    float s0rad = 0.25;\n    vec3  s1pos = vec3( 0.125, 0.0, 0.0);\n    float s1rad = 0.25;\n    vec2 s0 = sphere(raydir, rayori, s0pos, s0rad);\n    vec2 s1 = sphere(raydir, rayori, s1pos, s1rad);\n    if(s0.x <= 0.0){\n        normal = sphereNormal(s1.x, raydir, rayori, s1pos, s1rad);\n        return s1;\n    }\n    if(s1.x <= 0.0){\n        normal = sphereNormal(s0.x, raydir, rayori, s0pos, s0rad);\n        return s0;\n    }\n    if(s0.x <= 0.0 && s1.x <= 0.0){\n        return vec2(-1.0);\n    }\n    hit = vec2(min(s0.x, s1.x), max(s0.y, s1.y));\n    if(hit.x == s0.x){\n        normal = sphereNormal(s0.x, raydir, rayori, s0pos, s0rad);\n    }\n    if(hit.x == s1.x){\n        normal = sphereNormal(s1.x, raydir, rayori, s1pos, s1rad);\n    }\n    return hit;\n}\n\n// Fresnel Reflectance\nvec3 fresnel(vec3 raydir, vec3 normal){\n    // Gold\n    vec3 F0 = vec3(1.0, 0.71, 0.29);\n    // Pure-Reflection\n    //vec3 F0 = vec3(1.0);\n    return F0+(1.0-F0)*pow(1.0-dot(-raydir, normal), 5.0);\n}\n\n// Ray-Tracing\nvec3 raytrace(vec3 raydir, vec3 raypos){\n    vec3 outCol = vec3(1.0), norm, randnorm;\n    vec2 intersection;\n    for(uint i = 0U; i < 8U; i++){\n        intersection = scene(raydir, raypos, norm);\n        if(intersection.x < 0.0){break;}\n        raypos += raydir*intersection.x;\n        outCol *= fresnel(raydir, norm);\n        randnorm = normalize(nrand3(fbm(raypos*4.0)*0.5+0.125, norm));\n        raydir = reflect(raydir, randnorm);\n    }\n    //return outCol*texture(iChannel1, raydir).rgb;\n    return outCol*skyScatter(raydir, true);\n}\n\n// LoicVDB's Rotation Matrix: https://www.shadertoy.com/view/3ldBDH\nmat3 rotMat(vec3 rotation){\n    vec3 c = cos(rotation), s = sin(rotation);\n    mat3 rx = mat3(\n    1.0, 0.0, 0.0,\n    0.0, c.x,-s.x,\n    0.0, s.x, c.x);\n    mat3 ry = mat3(\n    c.y, 0.0,-s.y,\n    0.0, 1.0, 0.0,\n    s.y, 0.0, c.y);\n    mat3 rz = mat3(\n    c.z,-s.z, 0.0,\n    s.z, c.z, 0.0,\n    0.0, 0.0, 1.0);\n    return rz*rx*ry;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Progressive Rendering\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0){oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}\n    fragColor = oldFragColor;\n    if(iMouse.z > 0.0){fragColor = vec4(0.0);}\n\n    // Initialize RNG\n    INIT_RNG;\n\n    // Screen UV Coordinates Centered on [0.0, 0.0]\n    vec2 uv = 2.0*((fragCoord+nrand2(0.5, vec2(0.0)))-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n    // Mouse Controls\n    //vec2 mouse = vec2(iTime*pi*0.125, 0.0);\n    vec2 mouse = ((iMouse.xy/iResolution.xy)-0.5)*pi*mousesensitivity;\n\n    // World Coordinates\n    mat3 rotmat = rotMat(vec3(0.0, mouse.x, 0.0));\n    vec3 raydir = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Ray-Trace the Scene\n    vec3 raytraced = raytrace(raydir, vec3(-sin(mouse.x), 0.0, -cos(mouse.x)));\n\n    // Output the Rendered Frame\n    fragColor += vec4(clamp(raytraced, 0.0, 32.0), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This is for Exporting a 32-BPC Floating Point OpenEXR Image.\n\n/* Look at the bottom of the editor, there is a little Image icon. If\nyou click it, then Shadertoy will save a 32-Bit-Per-Channel Floating Point\nOpenEXR Image. It is more optimal for Image editing than right-clicking\nthe canvas and pressing copy/save image (as).*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}