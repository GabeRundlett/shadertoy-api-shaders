{
    "Shader": {
        "info": {
            "date": "1546617862",
            "description": "saw it on youtube\nthree Buffers (B C D) to make it compile fast on Angle :)\n\nall layers in single shader 2d [url]https://www.shadertoy.com/view/3dl3Dn[/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "tsfGW4",
            "likes": 106,
            "name": "Paper-cut Light Box",
            "published": 3,
            "tags": [
                "intersection"
            ],
            "usePreview": 1,
            "username": "morimea",
            "viewed": 2648
        },
        "renderpass": [
            {
                "code": "// Created by Danil (2018)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// using https://www.shadertoy.com/view/4tlBDs\n// using https://www.shadertoy.com/view/XdcSzH\n\n#define AA 0\n\n// anime time 8*PI\n//#define iTime (8.*3.1415926)\n\nuvec3 decodeval16(uint varz) {\n    int colz=int(varz);\n    ivec3 retc = ivec3(0);\n    retc.x = ((colz) / (0x10000)) - (0x1);\n    retc.y = ((-(retc.x + 0x1)*0x10000 + (colz)) / (0x100)) - (0x1);\n    retc.z = (-(retc.y + 0x1)*(0x100) - (retc.x + 0x1)*(0x10000) + (colz)) - (0x1);\n    return uvec3(retc);\n}\n\nuvec3 decodeval(uint varz) {\n    int colz=int(varz);\n    ivec3 retc = ivec3(0);\n    retc.x = ((colz) / 10000) - 1;\n    retc.y = ((-(retc.x + 1)*10000 + (colz)) / 100) - 1;\n    retc.z = (-(retc.y + 1)*100 - (retc.x + 1)*10000 + (colz)) - 1;\n    return uvec3(retc);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\n#define MAX_DIST 1000.\n#define MIN_DIST 1.\n\nfloat M_PI = 3.1415972;\nfloat nb_layers = 12.0;\nfloat border_step = 0.15;\n\nconst vec3 mainc1= vec3(0xfa, 0xf9, 0xf8) / float(0xff);\nconst vec3 mainc2= vec3(0xae, 0x96, 0x3a) / float(0xff);\nconst vec3 mainc3= vec3(0xf6, 0xea, 0x89) / float(0xff);\n\nvec2 res;\n\nvec2 getUV(float i)\n{\n    return vec2((i)/iResolution.x, 0);\n}\n\nvec3 l1Pos = vec3(2,1,0);\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Camera\n{\n    vec3 pos;\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    float fovScalar;\n};\n\nvoid setCamera(vec3 pos, vec3 forward, vec3 upGuide, float fov, out Camera cam)\n{\n    cam.pos = pos;\n    cam.forward = normalize(forward);\n    cam.right = cross(-cam.forward, normalize(upGuide));\n    cam.up = cross(cam.right, -cam.forward);\n    cam.fovScalar = tan(radians(fov/2.0));\n}\n\nRay castRay(vec2 uv, in Camera cam)\n{\n    uv *= cam.fovScalar;\n    return Ray(\n        cam.pos,\n        normalize(cam.forward + uv.x * cam.right + uv.y * cam.up)\n    );\n}\n\nbool PlaneIntersect(vec4 Plane, vec3 ro, vec3 rd, out float t, out vec3 norm) {\n    float dd = dot(rd, Plane.xyz);\n    if (dd == 0.0) return false;\n    float t1 = -(dot(ro, Plane.xyz) + Plane.w) / dd;\n    if (t1 < 0.0) return false;\n    norm = normalize(Plane.xyz);\n    t = t1;\n    return true;\n}\n\nbool ParallelogramIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2, in vec3 v3, out float tx, out vec3 norm)\n{\n    vec3 a = v0 - v1;\n    vec3 b = v2 - v0;\n    vec3 p = v0 - ro;\n    vec3 n = cross( a, b );\n    vec3 q = cross( rd, p );\n    float i = 1.0/dot( rd, n );\n    float u = dot( q, a )*i;\n    float v = dot( q, b )*i;\n    float t = dot( n, p )*i;\n    if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return false;\n    vec3 normx = vec3( t, u, v );\n    if( normx.x>MIN_DIST && normx.x<MAX_DIST )\n    {\n    tx = normx.x;\n    vec3 nor = normalize( cross(v2-v1,v1-v3) );\n    norm = faceforward( nor, rd, nor );\n    return true;\n    }\n    return false;\n}\n\nfloat anim_col(vec3 p){\n    return sin(1.-cos(p.x+iTime/1.));\n}\n\nfloat anim_col2(vec3 p){\n    return sin(1.-cos(p.x+iTime/2.));\n}\n\nfloat anim_col3(vec3 p){\n    return sin(1.-cos(p.x+iTime/4.));\n}\n\nvec4 calcColorg(vec3 p)\n{\n    vec3 tc=texture(iChannel3,(p.xz*vec2(iResolution.y/iResolution.x,1.))*.5+0.5).rrr;\n    vec3 m3=mix(mainc3,mainc3.rbg,anim_col2(p));\n    vec3 m2=mix(mainc2,mix(mainc2.bgr,mainc2,anim_col3(p)),anim_col2(p));\n    vec3 tcx=(tc*tc*((m3*m2)/(1.*clamp(sdCircle((p.xz+vec2(0.5*border_step*nb_layers,0.0))*vec2(1.,.35),0.35),0.2,1.)))*1.);\n    tcx*=max(0.15,anim_col(p));\n    return vec4(tcx*0.5,1.);\n}\n\nvec4 calcColorg1(vec3 p)\n{\n    vec3 tc=texture(iChannel3,(p.xy*vec2(iResolution.y/iResolution.x,1.))*.5+0.5).rrr;\n    vec3 m3=mix(mainc3,mainc3.rbg,anim_col2(p));\n    vec3 m2=mix(mainc2,mix(mainc2.bgr,mainc2,anim_col3(p)),anim_col2(p));\n    vec3 tcx=(tc*tc*((m3*m2)/(1.*clamp(sdCircle((p.xy+vec2(border_step*nb_layers,1.0))*vec2(1.,1.),0.3),0.2,1.)))*1.);\n    tcx*=max(0.15,anim_col(p));\n    return vec4(tcx*0.5,1.);\n}\n\nvec4 calcColortx(vec3 p,float i, float j)\n{\n    uvec4 tc=uvec4(0);\n    \n    //if all layers in single buffer\n    //tc=uvec4(abs(texelFetch(iChannel0,ivec2(((p.zy*vec2(iResolution.y/iResolution.x,1.))*.5+0.5)*iResolution.xy-0.5),0)));\n    \n    //three buffers\n    if(i*3.+j<4.)\n    tc=uvec4(abs(texelFetch(iChannel0,ivec2(((p.zy*vec2(iResolution.y/iResolution.x,1.))*.5+0.5)*iResolution.xy-0.5),0)));\n\telse if(i*3.+j<8.)\n    tc=uvec4(abs(texelFetch(iChannel1,ivec2(((p.zy*vec2(iResolution.y/iResolution.x,1.))*.5+0.5)*iResolution.xy-0.5),0)));\n\telse\n    tc=uvec4(abs(texelFetch(iChannel2,ivec2(((p.zy*vec2(iResolution.y/iResolution.x,1.))*.5+0.5)*iResolution.xy-0.5),0)));\n\n    float d =float(decodeval( tc[int(i)])[int(j)])/float(98);\n    vec3 tcx=vec3(0.);\n    vec3 m3=mix(mainc3,mainc3.rbg,anim_col2(p));\n    vec3 m2=mix(mainc2,mix(mainc2.bgr,mainc2,anim_col3(p)),anim_col2(p));\n    if(i*3.+j==nb_layers-1.)\n    tcx=mix(vec3(0.),((m3*m2)/(1.*clamp(sdCircle((p.zy+vec2(0.,.5))*vec2(.65,1.),0.3),0.2,1.)))*1.,d);\n    else\n    tcx=((i*3.+j)/(nb_layers-1.))*mix(vec3(0.),((m3*m2)/(1.*clamp(sdCircle((p.zy+vec2(0.,1.25))*vec2(.25,1.),0.1),0.2,1.)))*1.,d);\n    \n    tcx=clamp(tcx,vec3(0.),vec3(10.));\n    tcx*=max(0.25*((i*3.+j)/(nb_layers-1.)),anim_col(p));\n    return vec4(tcx,d);\n}\n\nvec4 calcColortb(vec3 p)\n{\n    vec3 tc=texture(iChannel3,(p.xz*vec2(iResolution.y/iResolution.x,1.))*.5+0.5).rgb;\n    return vec4(0.15+tc*tc,1.);\n}\n\nvec4 calcColorg2(vec3 p)\n{\n    vec3 tc=vec3(0.); //p.zy\n    vec3 m3=mix(mainc3,mainc3.rbg,anim_col2(p));\n    vec3 m2=mix(mainc2,mix(mainc2.bgr,mainc2,anim_col3(p)),anim_col2(p));\n    tc=0.45*(m3*m2)/(p.y+res.y);\n    tc*=max(0.5,anim_col(p));\n    return vec4(tc,1.);\n}\n\n#define OBJ_BALL 1\n#define OBJ_FLOOR 2\n#define OBJ_WALL 3\n#define OBJ_SUN 4\n#define OBJ_WALL_N 5\n#define OBJ_WALL_V 6\n#define OBJ_WALL_H 7\n#define OBJ_WALL_B 8\n#define OBJ_WALL_V2 9\n\nstruct HitInfo {\n    float t;\n    vec3 norm;\n    vec4 color;\n    int obj_type;\n};\n\nvoid ParallelogramIntersectMin(vec3 ro, vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2, inout bool result, \n                               inout HitInfo hit, int OBJ, float i,float j) {\n    float tnew;\n    vec3 normnew;\n    vec3 v3 = v1 + v2 - v0;\n    if (ParallelogramIntersect(ro, rd, v0, v1, v2, v3, tnew, normnew)) {\n        if (tnew < hit.t) {\n            hit.t = tnew;\n            hit.norm = normnew;\n            vec4 tlc=vec4(0.);\n            if(OBJ==OBJ_WALL_N)\n            tlc=calcColortx(ro+rd*hit.t,i,j);\n            else\n                if(OBJ==OBJ_WALL_V)\n                    tlc= calcColorg(ro+rd*hit.t);\n                else \n                    if(OBJ==OBJ_WALL_V2){\n                        tlc= calcColorg(ro+rd*hit.t);\n                        tlc.rgb*=0.5;\n                    }\n                else \n                    if(OBJ==OBJ_WALL_H)\n                    tlc= calcColorg1(ro+rd*hit.t);\n                    else \n                        tlc= calcColorg2(ro+rd*hit.t);\n                //if(i*3.+j==nb_layers-1.)tlc.a=1.; //last layer is not transparent, remove if need\n                hit.color.rgb = tlc.rgb*tlc.a+hit.color.rgb*(1.-tlc.a);\n                hit.color.a+=tlc.a;\n            \n            \n            hit.obj_type = OBJ;\n            result = true;\n        }\n    }\n}\n\nvoid GroundIntersectMin(vec3 ro, vec3 rd, inout bool result, inout HitInfo hit) {\n    float tnew;\n    vec3 normnew;\n    vec4 pp=vec4(0.0,01.,0.0,01.01);\n    if (PlaneIntersect(pp, ro, rd, tnew, normnew)) {\n        if (tnew < hit.t) {\n            hit.t = tnew;\n            hit.norm = normnew;\n            hit.color = calcColortb(ro+rd*hit.t);\n            hit.obj_type = OBJ_FLOOR;\n            result = true;\n        }\n    }\n}\n\nbool minDist(vec3 ro, vec3 rd, out HitInfo hit)\n{\n    hit.t = MAX_DIST;\n    bool result = false;\n    \n    vec3 v0 = vec3(-border_step*nb_layers,-res.x,-1.) ; \n\tvec3 v1 =  vec3(0.,-res.x,-1.) ; \n\tvec3 v2 =  vec3(-border_step*nb_layers,res.x,-1.); \n    \n    vec3 v01 = vec3(-border_step*nb_layers,-01.,res.x) ; \n\tvec3 v11 =  vec3(-border_step*nb_layers,-01.,-res.x) ; \n\tvec3 v21 =  vec3(-border_step*nb_layers,01.,res.x); \n    \n    v0=v0.xzy;v1=v1.xzy;v2=v2.xzy;\n\n    GroundIntersectMin(ro, rd, result, hit);\n    \n    ParallelogramIntersectMin(ro, rd, v0, v1, v2, result, hit,OBJ_WALL_V,0.,0.);\n    ParallelogramIntersectMin(ro, rd, v0*vec3(1,-1,1), v1*vec3(1,-1,1), v2*vec3(1,-1,1), result, hit,OBJ_WALL_V2,0.,0.);\n    ParallelogramIntersectMin(ro, rd, v0*vec3(0,1,1), v1*vec3(1,-1,1), v2*vec3(1,1,-1), result, hit,OBJ_WALL_H,0.,0.);\n    ParallelogramIntersectMin(ro, rd, v0*vec3(0,1,-1), v1*vec3(1,-1,-1), v2*vec3(1,1,1), result, hit,OBJ_WALL_H,0.,0.);\n    \n    ParallelogramIntersectMin(ro, rd, v01+vec3(border_step*(0.),0.,0.), \n                                 v11+vec3(border_step*(0.),0.,0.), v21+vec3(border_step*(0.),0.,0.), result, hit,OBJ_WALL_B,0.,0.);\n    for(float i=floor((nb_layers-0.)/3.)-1.+float(min(0,iFrame));i>=0.;i--){\n        for(float j=2.+float(min(0,iFrame));j>=0.;j--){\n        ParallelogramIntersectMin(ro, rd, v01+vec3(border_step*(nb_layers-(i*3.+j)),0.,0.), \n                                  v11+vec3(border_step*(nb_layers-(i*3.+j)),0.,0.), v21+vec3(border_step*(nb_layers-(i*3.+j)),0.,0.), result, hit,OBJ_WALL_N,i,j);\n        }}\n    return result;\n}\n\nconst float eps = 1e-3;\n\nvec3 calcFinalColor(Ray r)\n{\n    vec3 col = vec3(0.0);\n    vec3 objectcolor = vec3(1.0);\n    vec3 mask = vec3(1.0);\n    HitInfo hit;\n    hit.color=vec4(0.);\n\n    {\n        if(minDist(r.pos, r.dir, hit)){\n            objectcolor = hit.color.rgb;\n            vec3 p = r.pos + r.dir * hit.t + hit.norm*eps;\n            vec3 sunDir = normalize(l1Pos-p);\n            col = objectcolor;\n            col = objectcolor * (vec3(max(dot(hit.norm,sunDir),0.0)) + 0.05);\n        }\n    }\n    return col;\n }\n\nvec3 render(Ray r)\n{\n    return calcFinalColor(r);\n}\n\n#define PI (4.0 * atan(1.0))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    Camera cam;\n    res = (iResolution.xy / iResolution.y);\n    vec2 iM=vec2(0.);\n    iM=iMouse.xy;\n    if(iMouse.x>0.)iM=iMouse.xy;\n    else iM=vec2(iResolution.x/9.+0.5*iResolution.x*cos(cos(iTime/8.)),iResolution.y/2.5);\n    //else iM=vec2(-iResolution.x/4.+iResolution.x*cos(cos(iTime/15.)),iResolution.y/2.5);\n    vec3 tot = vec3(0.0);\n    vec3 pos = vec3(0.,0.,0.)+vec3((-2.85*((.5+iM.y/iResolution.y)*1.18))*cos((iM.x/iResolution.x+-01.55)\n                                                                                                         *3.0),\n                    4.-4.,\n                    (2.85*((.5+iM.y/iResolution.y)*1.18))*sin((iM.x/iResolution.x+-01.55)*3.0));\n    setCamera(vec3(0.,0.,-res.x*2.*(iM.x/iResolution.x-0.5))+pos, -pos, vec3(0,1,0), 60.0, cam);\n\n    #if AA>1\n    for( int mx=0; mx<AA; mx++ )\n    for( int nx=0; nx<AA; nx++ )\n    {\n    vec2 o = vec2(float(mx),float(nx)) / float(AA) - 0.5;\n    vec2 uv = (fragCoord+o)/iResolution.xy * 2.0 - 1.0;\n    #else\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    #endif\n    uv.y *= iResolution.y/iResolution.x;\n\n    vec3 col = render(castRay(uv, cam));\n    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n    fragColor = vec4( clamp(tot,vec3(0.),vec3(1.)), 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//using https://www.shadertoy.com/view/ldlBWf\n\n//tree buffer, because they realy slow\n//draw five trees\n\n/**\n * Created by Steven Sell (ssell) / 2017\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * Basic algorithm outline:\n *\n *     * Tree consists of branches, with the root branch being the trunk.\n *     * Each branch has one less segment than it's parent branch.\n *     * Each segment has a new branch.\n *     * Each branch has half the total thickness and length of it's parent branch.\n *     * Each branch has an adjusted angle of +/- MajorBranchAngle\n *     * Each segment has an adjusted angle of +/- MinorBranchAngle\n *\n * Not sure if this is the best way to generate a tree, but it's what popped into my head.\n * Implemented using a stack since recursive functions are not allowed.\n */\n\n//------------------------------------------------------------------------------------------\n// Global Properties\n//------------------------------------------------------------------------------------------\n\n// Tree Properties\n\n      float Seed              = 337.0;     // Seed used for PRNG hash\nconst int   TrunkSegments     = 5;         // Number of segments in the trunk branch\nconst float TrunkLength       = 0.7;       // Length of the trunk branch\nconst float TrunkThickness    = 0.025;     // Thickness of the trunk branch\nconst float MajorBranchAngle  = 0.125;     // +/- angle deviation of branches\nconst float MinorBranchAngle  = 0.0625;    // +/- angle deviation of segments\nconst int   StackDepth        = 16;        // Maximum stack depth\n\n// Math Constants\n\nconst float PI                = 3.14156;\nconst float E                 = 2.71828;\n\n//------------------------------------------------------------------------------------------\n// Math Functions\n//------------------------------------------------------------------------------------------\n\nfloat StepValue(float a, float b, float ra, float rb)\n{\n    float s = step(a, b);\n    return (ra * abs(s - 1.0)) + (rb * s);\n}\n\nfloat hash11(float p)\n{\n    // Credit Dave_Haskins\n\tvec3 p3  = fract(vec3(p) * 443.8975);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Noise(float s, float m)\n{\n    float r = (hash11((s + Seed)) * 2.0) - 1.0;\n\treturn (r * m);   \n}\n\nvec2 Rotate(vec2 v, float a)\n{\n    float cosa = cos(a);\n    float sina = sin(a);\n    \n    return vec2((v.x * cosa) - (v.y * sina), (v.x * sina) + (v.y * cosa));\n}\n\nfloat Factorial(float n)\n{\n\tfloat v = 1.0;\n    for(; n > 1.0+float(min(0,iFrame)); --n) { v *= n; }\n    return v;\n}\n\nfloat CalcNumSegments(int trunkSegments)\n{\n    // http://oeis.org/A007526\n    // Example: Trunk has 3 segments, each Branch0 has 2 segments, each Branch1 has 1 segment for 15 total.\n\n\treturn floor(E * Factorial(float(trunkSegments)) - 1.0);\n}\n\n//------------------------------------------------------------------------------------------\n// Line Drawing\n//------------------------------------------------------------------------------------------\n\nvec2 DistToLine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    float frac = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    \n    return vec2(length(pa - (ba * frac)), frac);\n}\n\nfloat Sharpen(in float dist, in float thickness, float blur)\n{\n    float r = (1.0 / min(iResolution.y, iResolution.x)) * blur;\n    return smoothstep(r, -r, dist - thickness);\n}\n\nfloat LineTaper(vec2 uv, vec2 a, vec2 b, float thickness0, float thickness1, float blur)\n{\n    vec2 d = DistToLine(uv, a, b);\n    return Sharpen(d.x, mix(thickness0, thickness1, d.y), blur);\n}\n\n//------------------------------------------------------------------------------------------\n// Tree Structure\n//------------------------------------------------------------------------------------------\n\nstruct Segment\n{\n    vec2 o;      // Origin\n    vec2 d;      // Normal / Direction\n    \n    float bl;    // Total length of the Branch the segment is part of\n    float sl;    // Length of the individual segment\n    float t0;    // Starting thickness of the segment\n    float t1;    // Ending thickness of the segment\n    \n    int s;       // # of Segments a child branch of the segment would have\n    int si;      // Index  of the segment along it's branch\n};\n\nSegment Segments[StackDepth];\n\nvoid Push(inout int i, Segment s)\n{\n    i = min(i + 1, StackDepth);\n    Segments[i] = s;\n}\n\nSegment Pop(inout int i)\n{\n    Segment s = Segments[i];\n    i = max(i - 1, 0);\n    \n    return s;\n}\n    \n//------------------------------------------------------------------------------------------\n// Tree Drawing\n//------------------------------------------------------------------------------------------\n\nfloat DrawSegment(vec2 uv, Segment s)\n{\n    return LineTaper(uv, s.o, (s.o + (s.d * s.sl)), s.t0, s.t1, 1.0);\n}\n\nvoid AddBranch(inout int si, vec2 origin, vec2 dir, float lngth, float thickness, int segments)\n{\n    float tstep = thickness / float(segments);\n    float lstep = lngth / float(segments);\n\n    vec2 sorigin    = origin;\n    vec2 sdirection = dir;\n\n    float t0   = thickness;\n    float t1   = t0 - tstep;\n    float rand = 0.0;\n    \n    for(int j = 0+(min(0,iFrame)); j < segments; ++j)\n    {\n        Push(si, Segment(sorigin, sdirection, lngth, lstep, t0, t1, (segments - 1), j));\n\n       \trand       = float(si + j + 1);\n        sorigin    = sorigin + (sdirection * lstep);\n        sdirection = Rotate(sdirection, Noise(rand, PI * MinorBranchAngle * StepValue(rand, 0.0, 1.0, -1.0)));\n        \n        t0 = t1;\n        t1 = t0 - tstep;\n    }\n}\n\nfloat Tree(vec2 uv, vec2 origin, vec2 direction, float lngth, int segments, float thickness)\n{\n    float f = 0.0;\n    \n    int totalSegments = int(CalcNumSegments(segments));\n    int si = -1;\n    \n    AddBranch(si, origin, direction, lngth, thickness, segments);\n    \n    for(int i = 0+(min(0,iFrame)); i < totalSegments; ++i)\n    {\n        Segment root = Pop(si);                // Root segment of this branch\n        f = max(f, DrawSegment(uv, root));     // Draw the root segment\n        \n  \t\tif(root.s > 0 && root.si > 0)          // Add a branch to this segment if valid\n        {\n            AddBranch(si, root.o,  Rotate(root.d, Noise(float(i + root.s), PI * MajorBranchAngle)), root.bl * 0.5, root.t0, root.s);\n        }\n    }\n    \n    return f;\n}\n\nvec4 mi(in vec2 fragCoord, float vz)\n{\n    Seed = 337.0 + floor(vz * 1.5); //val\n    \n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float f = Tree(uv, vec2(0.5, -0.03), vec2(0.0, 1.0), TrunkLength, TrunkSegments, TrunkThickness);\n    \n    return  vec4(vec3(f),1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 ret_col=vec4(0.);\n    if(ivec2(fragCoord.xy)==ivec2(iResolution.xy-1.)){\n        ret_col=vec4(-1.);//-1.\n        fragColor = ret_col;\n        return;\n    }\n    //repaint on resolution change\n    if(texelFetch(iChannel0,ivec2(iResolution.xy-1.),0).x>=0.){\n        if(fragCoord.x<iResolution.x/3.7)\n        ret_col=mi(fragCoord+vec2(iResolution.x/9.,0.),1.);\n        else if(fragCoord.x<iResolution.x/2.1)ret_col=mi(fragCoord-vec2(iResolution.x/11.5,0.),2.);\n            else if(fragCoord.x<iResolution.x/1.5)ret_col=mi(fragCoord-vec2(iResolution.x/3.85,0.),11.);\n                else if(fragCoord.x<iResolution.x/1.18)ret_col=mi(fragCoord-vec2(iResolution.x/1.98,0.),7.);\n                else ret_col=mi(fragCoord-vec2(iResolution.x/1.47,0.),37.);\n    }\n    else\n        ret_col=texture(iChannel0,fragCoord.xy / iResolution.xy);\n    \n    fragColor = ret_col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define SS(x, y, z) smoothstep(x, y, z)\n#define MD(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define PI (4.0 * atan(1.0))\n#define TAU (2.*PI)\n#define E exp(1.)\n#define res (iResolution.xy / iResolution.y)\n\n// Created by Danil (2018)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//\n//Buf B-D generate only single frame, dont use it in real time\n\n//using https://iquilezles.org/articles/distfunctions2d\n//using https://www.shadertoy.com/view/lslGR8\n//using https://www.shadertoy.com/view/ldGXWh\n//using https://www.shadertoy.com/view/Xl3czS\n\nfloat zv;\nvec2 res_g;\n\n// 0xfe max\n// *float(0xfe)\nuvec3 decodeval16(uint varz) {\n    int colz=int(varz);\n    ivec3 retc = ivec3(0);\n    retc.x = ((colz) / (0x10000)) - (0x1);\n    retc.y = ((-(retc.x + 0x1)*0x10000 + (colz)) / (0x100)) - (0x1);\n    retc.z = (-(retc.y + 0x1)*(0x100) - (retc.x + 0x1)*(0x10000) + (colz)) - (0x1);\n    return uvec3(retc);\n}\n\nuint encodeval16(uvec3 colz) {\n    return uint(int(colz.r)*0x10000 + 0x10000 + int(colz.g)*0x100 + 0x100 + int(colz.b) + 0x1);\n}\n\n// 98 max\n// *float(98)\nuvec3 decodeval(uint varz) {\n    int colz=int(varz);\n    ivec3 retc = ivec3(0);\n    retc.x = ((colz) / 10000) - 1;\n    retc.y = ((-(retc.x + 1)*10000 + (colz)) / 100) - 1;\n    retc.z = (-(retc.y + 1)*100 - (retc.x + 1)*10000 + (colz)) - 1;\n    return uvec3(retc);\n}\n\nuint encodeval(uvec3 colz) {\n    return uint(int(colz.r)*10000 + 10000 + int(colz.g)*100 + 100 + int(colz.b) + 1);\n}\n\nconst float WSCALE = 0.8;\nconst float LEAF = 1.0;\nconst float TRUNK = 2.0;\nvec2 seed;\nvec2 im;\n\n//https://iquilezles.org/articles/smin\nfloat smin( float a, float b )\n{\n    float k = 0.003;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nconst float pi =acos(-1.);\nconst float phi=sqrt(5.)*.5-.5;\nconst float Phi=sqrt(5.)*.5+.5;\nconst float fha=14142.1356237;\n\nfloat rand(vec2 coordinate){\n return fract(sin(dot(coordinate*seed,vec2(Phi,pi)))*fha);}\n\n\nvec2 rotate(vec2 point, float a)\n{\n    return point*MD(a);\n}\n\nfloat sdTreePart(vec2 pos, vec2 uv, vec2 pivot, float angle, float w, float h)\n{\n    uv -= pos;\n    uv = rotate(uv, angle) + pivot;\n    float b = WSCALE + smoothstep(0.0, -h * 2., uv.y - h) * (1.0 - WSCALE);\n    w *= b;\n    float y = max(uv.y - h, -h - uv.y);\n    float x = max(uv.x - w, -w - uv.x);\n    return max(x, y);\n}\n\nfloat sdLeaf(vec2 pos, vec2 uv, vec2 pivot, float angle, float w, float h)\n{\n    uv -= pos;\n    uv = rotate(uv, angle) + pivot;\n    w -= cos(uv.y * 500.) * 0.001;\n    h -= sin(uv.x * 500.) * 0.002;\n    float y = max(uv.y - h, -h - uv.y);\n    float x = max(uv.x - w, -w - uv.x);\n    return max(x, y);\n}\n\nfloat Cursor(in vec2 uv, inout vec2 pos, float H, inout float angle, inout float W)\n{\n    seed += vec2(0.01, 0.04);\n    W *= WSCALE;\n    vec2 pivot = vec2(0.0, -H);\n    float b = sdTreePart(pos, uv, pivot, angle, W, H);\n    pos += vec2(sin(angle), cos(angle)) * H * 2.;\n    float r = rand(seed);\n    angle += (r - 0.5) * 0.9;\n    return b;\n}\n\nint leafIndex = 0;\n\nvec2 Tree (vec2 pos, vec2 uv, int LEAFS, int BRANCHES, int TRUNKS)\n{\n    float H = 0.03;\n    vec2 pivot = vec2(0.0, -H);\n    float b = 999.0;\n    float angle = 0.0;\n    float W = 0.01;\n    float randH = 0.5 * (rand(im.xy) - 0.5);\n    float randA = rand(im.yx) - 0.5;\n    float lf = 999.0;\n    float LEAFANGLE = PI * 0.2;\n    vec2 leafSize = vec2(0.005, 0.01);\n    for (int i = 0+(min(0,iFrame)); i < TRUNKS; ++i)\n    {\n        b = smin(b, Cursor(uv, pos, H, angle, W));\n        vec2 p = pos;\n        float h = H; \n        float a = randA + angle + sin(0. + float(i)) * 0.1;\n        float w = W;\n        for (int j = 0+(min(0,iFrame)); j < BRANCHES; ++j)\n        {\n            b = smin(b, Cursor(uv, p, h, a, w));    \n            vec2 p1 = p;\n            float h1 = max(randH * 0.06, 0.006); \n            float a1 = randA + a + sin(0.+ float(j) * 0.4) * 0.1;\n            float w1 = w;\n            for (int k = 0+(min(0,iFrame)); k < LEAFS; ++k)\n            {\n               b = smin(b, Cursor(uv, p1, h1, a1, w1));    \n               float angl = mod(float(k), 2.0)  == 0.0 ? 1.0 : -1.0;\n               float newLeaf = sdLeaf(p1, uv, vec2(0.0, -leafSize.y),  (a1 + angl * LEAFANGLE), leafSize.x, leafSize.y);\n               if(newLeaf < lf) leafIndex = i * 100 + j * 10 + k;\n               lf = min(lf, newLeaf);\n               if(lf < 0.0 || b < 0.0) break; \n            }\n            if(lf < 0.0 || b < 0.0) break; \n        }\n        if(lf < 0.0 || b < 0.0) break; \n    }\n    if(b < lf)\n    {\n        return vec2(TRUNK, b);\n    }\n    return vec2(LEAF, lf);\n}\n\nfloat grass(vec2 p, float x, float tv, float s)\n{\n\tp.x += pow(1.0 + p.y, 2.0) * 0.1 * abs(cos(x + tv));\n\tp.x *= s;\n\tp.y = (1.0 + p.y) * s - 1.0;\n\tfloat m = 1.0 - smoothstep(-zv*100., clamp(1.0 - p.y * 1.5, 0.01, 0.6) * 0.2 * s, pow(abs(p.x) * 19.0, 1.5) + p.y - 0.6);\n\treturn  m* smoothstep(-1.0, -0.9, p.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat bborders(vec2 p){\n    return SS(-zv,zv,sdBox(p,(res_g/2.)-(res_g/2.)*0.015));\n}\n\nfloat bborders2(vec2 p){\n    return SS(zv,-zv,sdBox(p,(res_g/2.)-(res_g/2.)*0.0025));\n}\n\nfloat gen_grass(vec2 p,float tva){\n    float d=0.;\n    vec2 tp=p;\n    int BLADES=6;\n    float BLADE_SEED=1.0;\n    for(float ii=0.+float(min(0,iFrame));ii<3.;ii++)\n    {\n        tp=p;\n        tp.y+=0.08-ii*0.005;\n        tp.x+=0.25*ii;\n        tp*=10.;\n        tp.y*=1.5+1.25*ii;\n\tfor(int i = 0+(min(0,iFrame)); i < BLADES; i++)\n\t{\n\t\tfloat z = -(float(BLADES - i) * 0.1 + 1.0);\n\t\tvec4 pln = vec4(0.0, 0.0, -1.3, z);\n\t    vec2 tc = tp+(vec2(0.,03.51+tva+0.3*ii))*(1.5+ii);\n\t\ttc.x += cos(float(i) + BLADE_SEED);\n\t\tfloat cell = floor(tc.x);\n\t\ttc.x = (tc.x - cell) - 0.9;\n\t\tfloat c = grass(tc, float(i) + cell * 11.0,ii,0.8-0.1*ii);\n\t\td = max(d,c);\n    }}\n    return d;\n}\n\nfloat layer1(vec2 p){\n    float d=0.;\n    d=max(d,bborders(p));\n    float tdx=bborders2(p);\n    p.y+=0.045;\n    float td=0.;\n    if(p.x<0.3){\n    im=vec2(4.,2.); \n    seed=vec2(10.);\n    td=SS(zv*.75,0.,Tree(vec2(0.65, -0.33),vec2(-p.x,p.y)*.75,6,8,8).y);\n        d=max(d,td);\n    }\n    else{\n    im=vec2(11.,2.);\n    seed=vec2(1.);\n    td=SS(zv*.75,0.,Tree(vec2(0.75, -0.33),p*.75,8,4,8).y);\n        d=max(d,td);\n    }\n    vec2 tp=p;\n    tp.x+=0.;\n    tp*=10.;\n    float tva=0.1*(sin(tp.x+.5)-2.*cos(tp.x/2.-1.5));\n    d=max(d,SS(-04.051-tva,-zv*10.-04.051-tva,tp.y));\n    d=max(d,gen_grass(p,tva));\n    d=min(d,tdx);\n    return d;\n}\n\nfloat layer2(vec2 p){\n    float d=0.;\n    d=max(d,bborders(p));\n    float tdx=bborders2(p);\n    p.y+=0.045;\n    vec2 tp=p;\n    tp.x+=1.5;\n    tp*=10.;\n    float tva=0.1*(sin(tp.x+.5)-2.*cos(tp.x/2.-1.5));\n    d=max(d,SS(-04.051-tva,-zv*10.-04.051-tva,tp.y));\n    if(p.x<-0.3){\n        d=max(d,clamp(2.*texture(iChannel0,p*vec2(iResolution.y/iResolution.x-0.35,.55)+vec2(0.42,-0.35)+0.5).r,0.,1.));}\n    else\n        if(p.x>0.3)\n        d=max(d,clamp(2.*texture(iChannel0,p*vec2(iResolution.y/iResolution.x-0.35,.55)+vec2(-0.1,-0.35)+0.5).r,0.,1.));\n    d=max(d,gen_grass(p+vec2(0.5,0.),tva));\n    d=min(d,tdx);\n    return d;\n}\n\nfloat layer3(vec2 p){\n    float d=0.;\n    d=max(d,bborders(p));\n    float tdx=bborders2(p);\n    p.y+=0.04;\n    vec2 tp=p;\n    tp.x+=1.85;\n    tp*=10.;\n    float tva=0.1*(sin(tp.x+.5)-2.*cos(tp.x/2.-1.5));\n    d=max(d,SS(-04.051-tva,-zv*10.-04.051-tva,tp.y));\n        if(p.x<-0.3){\n        d=max(d,clamp(2.*texture(iChannel0,p*vec2(iResolution.y/iResolution.x-0.3,.6)+vec2(-0.18,-0.35)+0.5).r,0.,1.));}\n    else\n        if(p.x>0.3)\n        d=max(d,clamp(2.*texture(iChannel0,p*vec2(iResolution.y/iResolution.x-0.3,.6)+vec2(-0.3,-0.35)+0.5).r,0.,1.));\n    d=max(d,gen_grass(p+vec2(01.5,0.),tva));\n    d=min(d,tdx);\n    return d;\n}\n\nfloat layer4(vec2 p){\n    float d=0.;\n    d=max(d,bborders(p));\n    float tdx=bborders2(p);\n    p.y+=0.035;\n    vec2 tp=p;\n    tp.x+=2.05;\n    tp*=10.;\n    float tva=0.1*(sin(tp.x+.5)-2.*cos(tp.x/2.-1.5));\n    d=max(d,SS(-04.051-tva,-zv*10.-04.051-tva,tp.y));\n            if(p.x<-0.1){\n        d=max(d,clamp(2.*texture(iChannel0,vec2(-p.x,p.y)*vec2(iResolution.y/iResolution.x-0.25,.6)\n                                 +vec2(0.125,-0.35)+0.5).r,0.,1.));}\n    else\n        if(p.x>0.3)\n        d=max(d,clamp(2.*texture(iChannel0,vec2(-p.x,p.y)*vec2(iResolution.y/iResolution.x-0.25,.6)\n                                 +vec2(0.23,-0.35)+0.5).r,0.,1.));\n    d=max(d,gen_grass(p+vec2(02.,0.),tva));\n    d=min(d,tdx);\n    return d;\n}\n\n\nvec4 main_c(vec2 p){\n    vec4 col=vec4(0.);\n    float d1=layer1(p);\n    float d2=layer2(p);\n    float d3=layer3(p);\n    uvec3 val1=uvec3(vec3(d1,d2,d3)*float(98));\n    \n    d1=layer4(p);\n    d2=0.;\n    d3=0.;\n    uvec3 val2=uvec3(vec3(d1,d2,d3)*float(98));\n    \n    d1=0.;\n    d2=0.;\n    d3=0.;\n    uvec3 val3=uvec3(vec3(d1,d2,d3)*float(98));\n    \n    d1=0.;\n    d2=0.;\n    d3=0.;\n    uvec3 val4=uvec3(vec3(d1,d2,d3)*float(98));\n    \n    col=vec4(encodeval(val1),encodeval(val2),encodeval(val3),encodeval(val4));\n    return vec4(col);\n}\n\nfloat zoom_calc(float zv) {\n    float ex = 0.0025 * ((1080. * zv) / (iResolution.y));\n    return ex;\n}\n\nvoid init_globals() {\n    seed=vec2(0.);\n    im=vec2(0.);\n    zv = zoom_calc(1.);\n    res_g = res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord.xy) / iResolution.y - res/2.0;\n    init_globals();\n    vec4 ret_col=vec4(0.);\n    \n    //resolution control\n    if(ivec2(fragCoord.xy)==ivec2(iResolution.xy-1.)){\n        ret_col=vec4(-10101.);//=-0.\n        fragColor = ret_col;\n        return;\n    }\n    //repaint on resolution change\n    if(texelFetch(iChannel1,ivec2(iResolution.xy-1.),0).x>=0.)\n        ret_col=main_c(uv);\n    else\n        ret_col=texelFetch(iChannel1,ivec2(fragCoord.xy) ,0);\n    \n    fragColor = ret_col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define SS(x, y, z) smoothstep(x, y, z)\n#define MD(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define PI (4.0 * atan(1.0))\n#define TAU (2.*PI)\n#define E exp(1.)\n#define res (iResolution.xy / iResolution.y)\n\n// Created by Danil (2018)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//\n//Buf B-D generate only single frame, dont use it in real time\n\n//using https://iquilezles.org/articles/distfunctions2d\n//using https://www.shadertoy.com/view/lslGR8\n//using https://www.shadertoy.com/view/ldGXWh\n//using https://www.shadertoy.com/view/Xl3czS\n\nfloat zv;\nvec2 res_g;\n\n// 0xfe max\n// *float(0xfe)\nuvec3 decodeval16(uint varz) {\n    int colz=int(varz);\n    ivec3 retc = ivec3(0);\n    retc.x = ((colz) / (0x10000)) - (0x1);\n    retc.y = ((-(retc.x + 0x1)*0x10000 + (colz)) / (0x100)) - (0x1);\n    retc.z = (-(retc.y + 0x1)*(0x100) - (retc.x + 0x1)*(0x10000) + (colz)) - (0x1);\n    return uvec3(retc);\n}\n\nuint encodeval16(uvec3 colz) {\n    return uint(int(colz.r)*0x10000 + 0x10000 + int(colz.g)*0x100 + 0x100 + int(colz.b) + 0x1);\n}\n\n// 98 max\n// *float(98)\nuvec3 decodeval(uint varz) {\n    int colz=int(varz);\n    ivec3 retc = ivec3(0);\n    retc.x = ((colz) / 10000) - 1;\n    retc.y = ((-(retc.x + 1)*10000 + (colz)) / 100) - 1;\n    retc.z = (-(retc.y + 1)*100 - (retc.x + 1)*10000 + (colz)) - 1;\n    return uvec3(retc);\n}\n\nuint encodeval(uvec3 colz) {\n    return uint(int(colz.r)*10000 + 10000 + int(colz.g)*100 + 100 + int(colz.b) + 1);\n}\n\nfloat grass(vec2 p, float x, float tv, float s)\n{\n\tp.x += pow(1.0 + p.y, 2.0) * 0.1 * abs(cos(x + tv));\n\tp.x *= s;\n\tp.y = (1.0 + p.y) * s - 1.0;\n\tfloat m = 1.0 - smoothstep(-zv*100., clamp(1.0 - p.y * 1.5, 0.01, 0.6) * 0.2 * s, pow(abs(p.x) * 19.0, 1.5) + p.y - 0.6);\n\treturn  m* smoothstep(-1.0, -0.9, p.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat bborders(vec2 p){\n    return SS(-zv,zv,sdBox(p,(res_g/2.)-(res_g/2.)*0.015));\n}\n\nfloat bborders2(vec2 p){\n    return SS(zv,-zv,sdBox(p,(res_g/2.)-(res_g/2.)*0.0025));\n}\n\nfloat gen_grass(vec2 p,float tva){\n    float d=0.;\n    vec2 tp=p;\n    int BLADES=6;\n    float BLADE_SEED=1.0;\n    for(float ii=0.+float(min(0,iFrame));ii<3.;ii++)\n    {\n        tp=p;\n        tp.y+=0.08-ii*0.005;\n        tp.x+=0.25*ii;\n        tp*=10.;\n        tp.y*=1.5+1.25*ii;\n\tfor(int i = 0+(min(0,iFrame)); i < BLADES; i++)\n\t{\n\t\tfloat z = -(float(BLADES - i) * 0.1 + 1.0);\n\t\tvec4 pln = vec4(0.0, 0.0, -1.3, z);\n\t    vec2 tc = tp+(vec2(0.,03.51+tva+0.3*ii))*(1.5+ii);\n\t\ttc.x += cos(float(i) + BLADE_SEED);\n\t\tfloat cell = floor(tc.x);\n\t\ttc.x = (tc.x - cell) - 0.9;\n\t\tfloat c = grass(tc, float(i) + cell * 11.0,ii,0.8-0.1*ii);\n\t\td = max(d,c);\n    }}\n    return d;\n}\n\nfloat layer5(vec2 p){\n    float d=0.;\n    d=max(d,bborders(p));\n    float tdx=bborders2(p);\n    p.y+=0.03;\n    vec2 tp=p;\n    tp.x+=2.25;\n    tp*=10.;\n    float tva=0.1*(sin(tp.x+.5)-2.*cos(tp.x/2.-1.5));\n    d=max(d,SS(-04.051-tva,-zv*10.-04.051-tva,tp.y));\n            if((p.x>-0.73)&&(p.x<-0.1)){\n        d=max(d,clamp(2.*texture(iChannel0,vec2(-p.x,p.y)*vec2(iResolution.y/iResolution.x-0.15,.7)+\n                                 vec2(-0.53,-0.35)+0.5).r,0.,1.));}\n    else\n        if(p.x>0.3)\n        d=max(d,clamp(2.*texture(iChannel0,p*vec2(iResolution.y/iResolution.x-0.15,.7)+\n                                 vec2(0.02,-0.35)+0.5).r,0.,1.));\n    d=max(d,gen_grass(p+vec2(02.5,0.),tva));\n    d=min(d,tdx);\n    return d;\n}\n\nfloat layer6(vec2 p){\n    float d=0.;\n    d=max(d,bborders(p));\n    float tdx=bborders2(p);\n    p.y+=0.025;\n    vec2 tp=p;\n    tp.x+=2.5;\n    tp*=10.;\n    float tva=0.1*(sin(tp.x+.5)-2.*cos(tp.x/2.-1.5));\n    d=max(d,SS(-04.051-tva,-zv*10.-04.051-tva,tp.y));\n            if(p.x<-0.24){\n        d=max(d,clamp(2.*texture(iChannel0,p*vec2(iResolution.y/iResolution.x-0.1,.8)+\n                                 vec2(-0.11,-0.35)+0.5).r,0.,1.));}\n    else\n        if(p.x>0.5)\n        d=max(d,clamp(2.*texture(iChannel0,vec2(-p.x,p.y)*vec2(iResolution.y/iResolution.x-0.1,.8)+\n                                 vec2(0.8,-0.35)+0.5).r,0.,1.));\n    d=max(d,gen_grass(p+vec2(03.,0.),tva));\n    d=min(d,tdx);\n    return d;\n}\n\nfloat layer7(vec2 p){\n    float d=0.;\n    d=max(d,bborders(p));\n    float tdx=bborders2(p);\n    p.y+=0.02;\n    vec2 tp=p;\n    tp.x+=2.85;\n    tp*=10.;\n    float tva=0.1*(sin(tp.x+.5)-2.*cos(tp.x/2.-1.5));\n    d=max(d,SS(-04.051-tva,-zv*10.-04.051-tva,tp.y));\n            if((p.x>-0.7)&&(p.x<-0.33)){\n        d=max(d,clamp(1.35*texture(iChannel0,p*vec2(iResolution.y/iResolution.x-0.05,.85)+\n                                 vec2(0.525,-0.15)+0.5).r,0.,1.));}\n    else\n        if((p.x<0.73)&&(p.x>0.37))\n        d=max(d,clamp(1.35*texture(iChannel0,vec2(-p.x,p.y)*vec2(iResolution.y/iResolution.x-0.05,.85)+\n                                  vec2(0.35,-0.15)+0.5).r,0.,1.));\n    d=max(d,gen_grass(p+vec2(03.5,0.),tva));\n    d=min(d,tdx);\n    return d;\n}\n\nfloat layer8(vec2 p){\n    float d=0.;\n    d=max(d,bborders(p));\n    float tdx=bborders2(p);\n    p.y+=0.015;\n    vec2 tp=p;\n    tp.x+=3.05;\n    tp*=10.;\n    float tva=0.1*(sin(tp.x+.5)-2.*cos(tp.x/2.-1.5));\n    d=max(d,SS(-04.051-tva,-zv*10.-04.051-tva,tp.y));\n            if((p.x>-0.67)&&(p.x<-0.27)){\n        d=max(d,clamp(1.1*texture(iChannel0,vec2(-p.x,p.y)*vec2(iResolution.y/iResolution.x-0.05,.9)+\n                                 vec2(-0.725+0.36,-0.15)+0.5).r,0.,1.));}\n    else\n        if((p.x<0.73)&&(p.x>0.17))\n        d=max(d,clamp(1.1*texture(iChannel0,p*vec2(iResolution.y/iResolution.x-0.05,.9)+\n                                  vec2(-0.725+0.12,-0.15)+0.5).r,0.,1.));\n    d=max(d,gen_grass(p+vec2(04.,0.),tva));\n    d=min(d,tdx);\n    return d;\n}\n\nvec4 main_c(vec2 p){\n    vec4 col=vec4(0.);\n    float d1=0.;\n    float d2=0.;\n    float d3=0.;\n    uvec3 val1=uvec3(vec3(d1,d2,d3)*float(98));\n    \n    d1=0.;\n    d2=layer5(p);\n    d3=layer6(p);\n    uvec3 val2=uvec3(vec3(d1,d2,d3)*float(98));\n    \n    d1=layer7(p);\n    d2=layer8(p);\n    d3=0.;\n    uvec3 val3=uvec3(vec3(d1,d2,d3)*float(98));\n    \n    d1=0.;\n    d2=0.;\n    d3=0.;\n    uvec3 val4=uvec3(vec3(d1,d2,d3)*float(98));\n    \n    col=vec4(encodeval(val1),encodeval(val2),encodeval(val3),encodeval(val4));\n    return vec4(col);\n}\n\nfloat zoom_calc(float zv) {\n    float ex = 0.0025 * ((1080. * zv) / (iResolution.y));\n    return ex;\n}\n\nvoid init_globals() {\n    zv = zoom_calc(1.);\n    res_g = res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord.xy) / iResolution.y - res/2.0;\n    init_globals();\n    vec4 ret_col=vec4(0.);\n    \n    //resolution control\n    if(ivec2(fragCoord.xy)==ivec2(iResolution.xy-1.)){\n        ret_col=vec4(-10101.);//=-0.\n        fragColor = ret_col;\n        return;\n    }\n    //repaint on resolution change\n    if(texelFetch(iChannel1,ivec2(iResolution.xy-1.),0).x>=0.)\n        ret_col=main_c(uv);\n    else\n        ret_col=texelFetch(iChannel1,ivec2(fragCoord.xy) ,0);\n    \n    fragColor = ret_col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define SS(x, y, z) smoothstep(x, y, z)\n#define MD(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define PI (4.0 * atan(1.0))\n#define TAU (2.*PI)\n#define E exp(1.)\n#define res (iResolution.xy / iResolution.y)\n\n// Created by Danil (2018)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//\n//Buf B-D generate only single frame, dont use it in real time\n\n//using https://iquilezles.org/articles/distfunctions2d\n//using https://www.shadertoy.com/view/lslGR8\n//using https://www.shadertoy.com/view/ldGXWh\n//using https://www.shadertoy.com/view/Xl3czS\n\nfloat zv;\nvec2 res_g;\n\n// 0xfe max\n// *float(0xfe)\nuvec3 decodeval16(uint varz) {\n    int colz=int(varz);\n    ivec3 retc = ivec3(0);\n    retc.x = ((colz) / (0x10000)) - (0x1);\n    retc.y = ((-(retc.x + 0x1)*0x10000 + (colz)) / (0x100)) - (0x1);\n    retc.z = (-(retc.y + 0x1)*(0x100) - (retc.x + 0x1)*(0x10000) + (colz)) - (0x1);\n    return uvec3(retc);\n}\n\nuint encodeval16(uvec3 colz) {\n    return uint(int(colz.r)*0x10000 + 0x10000 + int(colz.g)*0x100 + 0x100 + int(colz.b) + 0x1);\n}\n\n// 98 max\n// *float(98)\nuvec3 decodeval(uint varz) {\n    int colz=int(varz);\n    ivec3 retc = ivec3(0);\n    retc.x = ((colz) / 10000) - 1;\n    retc.y = ((-(retc.x + 1)*10000 + (colz)) / 100) - 1;\n    retc.z = (-(retc.y + 1)*100 - (retc.x + 1)*10000 + (colz)) - 1;\n    return uvec3(retc);\n}\n\nuint encodeval(uvec3 colz) {\n    return uint(int(colz.r)*10000 + 10000 + int(colz.g)*100 + 100 + int(colz.b) + 1);\n}\n\nfloat grass(vec2 p, float x, float tv, float s)\n{\n\tp.x += pow(1.0 + p.y, 2.0) * 0.1 * abs(cos(x + tv));\n\tp.x *= s;\n\tp.y = (1.0 + p.y) * s - 1.0;\n\tfloat m = 1.0 - smoothstep(-zv*100., clamp(1.0 - p.y * 1.5, 0.01, 0.6) * 0.2 * s, pow(abs(p.x) * 19.0, 1.5) + p.y - 0.6);\n\treturn  m* smoothstep(-1.0, -0.9, p.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat bluenoise(vec2 p){\n    if(texelFetch(iChannel3,ivec2(0),0).x==0.)return 0.;\n    float r = 8.*(iResolution.y/450.), d = 1./455.; \n    float t = texelFetch(iChannel3,ivec2(((p*vec2(iResolution.y/iResolution.x,1.)+0.5)*iResolution.xy)/r),0).x;\n    if ( t< d ) return smoothstep(1.,1.-4./r,length(2.*fract(((p*vec2(iResolution.y/iResolution.x,1.)+0.5)*iResolution.xy)/r)-1.)); \n    return 0.;\n}\n\nfloat bborders(vec2 p){\n    return SS(-zv,zv,sdBox(p,(res_g/2.)-(res_g/2.)*0.015));\n}\n\nfloat bborders2(vec2 p){\n    return SS(zv,-zv,sdBox(p,(res_g/2.)-(res_g/2.)*0.0025));\n}\n\nfloat gen_grass(vec2 p,float tva){\n    float d=0.;\n    vec2 tp=p;\n    int BLADES=6;\n    float BLADE_SEED=1.0;\n    for(float ii=0.+float(min(0,iFrame));ii<3.;ii++)\n    {\n        tp=p;\n        tp.y+=0.08-ii*0.005;\n        tp.x+=0.25*ii;\n        tp*=10.;\n        tp.y*=1.5+1.25*ii;\n\tfor(int i = 0+(min(0,iFrame)); i < BLADES; i++)\n\t{\n\t\tfloat z = -(float(BLADES - i) * 0.1 + 1.0);\n\t\tvec4 pln = vec4(0.0, 0.0, -1.3, z);\n\t    vec2 tc = tp+(vec2(0.,03.51+tva+0.3*ii))*(1.5+ii);\n\t\ttc.x += cos(float(i) + BLADE_SEED);\n\t\tfloat cell = floor(tc.x);\n\t\ttc.x = (tc.x - cell) - 0.9;\n\t\tfloat c = grass(tc, float(i) + cell * 11.0,ii,0.8-0.1*ii);\n\t\td = max(d,c);\n    }}\n    return d;\n}\n\nfloat layer9(vec2 p){\n    float d=0.;\n    d=max(d,bborders(p));\n    float tdx=bborders2(p);\n    p.y+=0.01;\n    vec2 tp=p;\n    tp.x+=3.25;\n    tp*=10.;\n    float tva=0.1*(sin(tp.x+.5)-2.*cos(tp.x/2.-1.5));\n    d=max(d,SS(-04.051-tva,-zv*10.-04.051-tva,tp.y));\n            if((p.x>-0.54)&&(p.x<-0.18)){\n        d=max(d,clamp(1.5*texture(iChannel0,p*vec2(iResolution.y/iResolution.x-0.05,.9)+\n                                 vec2(-0.25+0.5,-0.05)+0.5).r,0.,1.));}\n    else\n        if((p.x<0.73)&&(p.x>0.34))\n        d=max(d,clamp(1.5*texture(iChannel0,vec2(-p.x,p.y)*vec2(iResolution.y/iResolution.x-0.05,.9)+\n                                  vec2(-0.25+0.4,-0.05)+0.5).r,0.,1.));\n    d=max(d,gen_grass(p+vec2(04.5,0.),tva));\n    d=min(d,tdx);\n    return d;\n}\n\nfloat layer10(vec2 p){\n    float d=0.;\n    d=max(d,bborders(p));\n    float tdx=bborders2(p);\n    p.y+=0.005;\n    vec2 tp=p;\n    tp.x+=3.5;\n    tp*=10.;\n    float tva=0.1*(sin(tp.x+.5)-2.*cos(tp.x/2.-1.5));\n    d=max(d,SS(-04.051-tva,-zv*10.-04.051-tva,tp.y));\n            if((p.x>-0.49)&&(p.x<-0.17)){\n        d=max(d,clamp(1.*texture(iChannel0,vec2(-p.x,p.y)*vec2(iResolution.y/iResolution.x,.95)+\n                                 vec2(-0.75+0.83,-0.0)+0.5).r,0.,1.));}\n    else\n        if((p.x<0.73)&&(p.x>0.26))\n        d=max(d,clamp(1.*texture(iChannel0,vec2(-p.x,p.y)*vec2(iResolution.y/iResolution.x,.95)+\n                                  vec2(-0.75+0.67,-0.0)+0.5).r,0.,1.));\n    d=max(d,gen_grass(p+vec2(05.,0.),tva));\n    d=min(d,tdx);\n    return d;\n}\n\nfloat layer11(vec2 p){\n    float d=0.;\n    d=max(d,bborders(p));\n    float tdx=bborders2(p);\n    p.y+=0.005;\n    vec2 tp=p;\n    tp.x+=3.85;\n    tp*=10.;\n    float tva=0.1*(sin(tp.x+.5)-2.*cos(tp.x/2.-1.5));\n    d=max(d,SS(-04.051-tva,-zv*10.-04.051-tva,tp.y));\n    d=max(d,gen_grass(p+vec2(05.5,0.),tva));\n        if((p.x>-0.54)&&(p.x<0.1))\n    d=max(d,texture(iChannel0,vec2(-p.x,p.y)*vec2(iResolution.y/iResolution.x,1.)+vec2(-0.75+0.22,0.)+0.5).r);\n    else\n        if((p.x>0.2)&&(p.x<0.54))\n        d=max(d,texture(iChannel0,(p*vec2(iResolution.y/iResolution.x,1.)+0.5)+vec2(0.05,0.)).r);\n        d=min(d,tdx);\n    return d;\n}\n\nfloat layer12(vec2 p){\n    float d=0.;\n    d=max(d,bborders(p));\n    float tdx=bborders2(p);\n    p.y+=-0.005;\n    vec2 tp=p;\n    tp.x+=4.5;\n    tp*=10.;\n    float tva=-0.015*(sin(tp.x+.5)-2.*cos(tp.x/2.-1.5));\n    d=max(d,SS(-04.051-tva,-zv*10.-04.051-tva,tp.y));\n    d=max(d,gen_grass(p+vec2(06.,0.),tva));\n    d=max(d,min(1.-SS(zv,0.,sdCircle(p+vec2(-0.17,-0.165),0.1)),SS(zv,0.,sdCircle(p+vec2(-0.2,-0.15),0.1))));\n    d=max(d,bluenoise(p));\n    d=min(d,tdx);\n    return d;\n}\n\nvec4 main_c(vec2 p){\n    vec4 col=vec4(0.);\n    float d1=0.;\n    float d2=0.;\n    float d3=0.;\n    uvec3 val1=uvec3(vec3(d1,d2,d3)*float(98));\n    \n    d1=0.;\n    d2=0.;\n    d3=0.;\n    uvec3 val2=uvec3(vec3(d1,d2,d3)*float(98));\n    \n    d1=0.;\n    d2=0.;\n    d3=layer9(p);\n    uvec3 val3=uvec3(vec3(d1,d2,d3)*float(98));\n    \n    d1=layer10(p);\n    d2=layer11(p);\n    d3=layer12(p);\n    uvec3 val4=uvec3(vec3(d1,d2,d3)*float(98));\n    \n    col=vec4(encodeval(val1),encodeval(val2),encodeval(val3),encodeval(val4));\n    return vec4(col);\n}\n\nfloat zoom_calc(float zv) {\n    float ex = 0.0025 * ((1080. * zv) / (iResolution.y));\n    return ex;\n}\n\nvoid init_globals() {\n    zv = zoom_calc(1.);\n    res_g = res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord.xy) / iResolution.y - res/2.0;\n    init_globals();\n    vec4 ret_col=vec4(0.);\n    \n    //resolution control\n    if(ivec2(fragCoord.xy)==ivec2(iResolution.xy-1.)){\n        ret_col=vec4(-10101.);//=-0.\n        if(texelFetch(iChannel3,ivec2(0),0).x==0.)ret_col=vec4(10101.);\n        fragColor = ret_col;\n        return;\n    }\n    //repaint on resolution change\n    if(texelFetch(iChannel1,ivec2(iResolution.xy-1.),0).x>=0.)\n        ret_col=main_c(uv);\n    else\n        ret_col=texelFetch(iChannel1,ivec2(fragCoord.xy) ,0);\n    \n    fragColor = ret_col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}