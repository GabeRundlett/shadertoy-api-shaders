{
    "Shader": {
        "info": {
            "date": "1612539964",
            "description": "Its a world made of sine waves.",
            "flags": 8,
            "hasliked": 0,
            "id": "3tdBDr",
            "likes": 5,
            "name": "Sine Islands",
            "published": 3,
            "tags": [
                "sine"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 364
        },
        "renderpass": [
            {
                "code": "//Sine Islands by eiffie (everything is sine waves)\n#define PI 3.14159265 \n#define size iResolution \n#define time iTime\n#define maxDepth 200.\nconst int iters=11,steps=256,shadowsteps=32; \nfloat eps,spec=0.5; \nconst float aocc=0.0,aoe=0.75,specExp=32.0,contrast=0.45;//light params \nconst vec3 cDiffuse=vec3(0.75,0.54,0.33),cLight=vec3(1.0,1.0,1.0); \nconst vec3 cBGround=vec3(0.5,0.6,1.0),light=vec3(0.0,1.0,0.0); \nvec3 diffuse=vec3(0.3,0.4,0.5),normal,cGlow=vec3(0.0,0.05,0.1); \nbool bColoring=false; \nvec3 eye;\nmat2 RMat2(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));} \nmat2 rmx; \nfloat wvTrn(vec2 z, float amp, float freq, float wave){ \n float h=0.0; \n vec2 offset=vec2(2.5+wave*0.1,1.0+wave*0.07); \n for(int i=0;i<8;i++){ \n  z=z*rmx*freq+offset; \n  h+=sin(z.x+wave)*sin(z.y+wave*1.33)*sin(length(z)*2.33+wave)*amp; \n  amp=pow(amp,1.25); \n } \n return h; \n}\nfloat Mnt(vec2 z){return wvTrn(z*0.01,0.25,2.0,0.0)*25.+1.;}\nfloat DE(vec3 z) { \n float r=length(z.xz-eye.xz);\n float dMnt=Mnt(z.xz)+z.y+r*0.02; \n float dWtr=wvTrn(z.xz*1.0,0.2,1.75,time)*0.25+z.y+1.0; \n float d=min(dMnt,dWtr); \n if(bColoring){ \n  cGlow=vec3(0.1+r*0.002); \n  if(d==dMnt){diffuse=vec3(0.5+wvTrn(z.xz,0.25,2.0,0.0),0.7,0.4)*(0.2+dMnt*4.0);} \n  else if(d==dWtr){diffuse=vec3(0.0,0.1,0.55);cGlow=vec3(0.8);} \n } \n return d; \n} \n \nfloat fakeAO(vec3 ray, vec3 norm, float ao_eps) {//from rrrola \n float ao=1.0,w=0.1/ao_eps,dist=2.0*ao_eps; \n for (int i=0; i<5; i++) { \n  float D = DE(ray + norm*dist); \n  ao -= (dist-D) * w; w *= 0.5; dist = dist*2.0 - ao_eps; \n } \n return clamp(ao, aocc, 1.0); \n} \n \nfloat rand(vec2 co){ \n // implementation found at: lumina.sourceforge.net/Tutorials/Noise.html \n return fract(sin(dot(co.xy*0.123,vec2(12.9898,78.233))) * 43758.5453); \n} \n \nvoid mainImage(out vec4 O, in vec2 U) {\n rmx=RMat2(0.6); \n vec2 uv=(2.*U-size.xy)/size.xy;\n vec3 ray = vec3(time,1.,time*1.5), rayDir = normalize(vec3(uv,3.));\n rayDir.xz=rayDir.xz*RMat2(-.5);\n ray.y=max(-.8,1.5-0.5*(Mnt(ray.xz)+Mnt(ray.xz+rayDir.xz)));eye=ray;\n vec3 color=cBGround+vec3(max(wvTrn(rayDir.xy*5.0,0.25,2.0,-time*0.25)*0.5,0.0)); \n cGlow=vec3(0.2,0.3,0.4);\n eps=1.25/max(size.x,size.y); \n int iSteps=0;\n float rayLen,dist,smoothSteps; \n rayLen=dist=max(DE(ray)*rand(gl_FragCoord.xy),eps); \n for(iSteps=0;iSteps<steps && dist>=eps*rayLen && rayLen<=maxDepth;iSteps++){ \n  rayLen+=dist=DE(ray+rayLen*rayDir)*0.9; \n } \n eps*=rayLen; \n if(dist<eps){//we hit the fractal \n  smoothSteps=(float(iSteps)+dist/eps)/float(steps); \n  ray+=rayLen*rayDir; \n  bColoring=true;DE(ray);bColoring=false;\n  vec2 ve=vec2(eps,0.0); \n  normal=normalize(vec3(-DE(ray-ve.xyy)+DE(ray+ve.xyy),-DE(ray-ve.yxy)+DE(ray+ve.yxy),-DE(ray-ve.yyx)+DE(ray+ve.yyx))); \n  float cheapAO=1.0-smoothSteps*aoe; \n  if(diffuse.x==0.){//hit water\n    float d=Mnt(ray.xz)+ray.y+length(ray.xz-eye.xz)*0.02;\n    if(d<0.5){\n      vec3 c=vec3(0.5+wvTrn(ray.xz,0.25,2.0,0.0),0.7,0.4)*.4;\n      diffuse=mix(c,diffuse,clamp(d*2.,0.,1.));\n    }\n  }else{//ground\n    diffuse+=rand(ray.xz)*0.1;\n    if(aocc>0.0)cheapAO*=fakeAO(ray,normal,eps*4.0);\n  }\n  diffuse=(dot(normal,light)*contrast+0.75)*diffuse;\n  diffuse+=spec*pow(max(dot(normal,normalize(light-rayDir)),0.0),specExp)*cLight;  \n  color=diffuse*cheapAO; \n  color=mix(color,cBGround,clamp(log(rayLen/maxDepth),0.0,1.0));//FOG \n }else {//missed\n  cGlow=vec3(0);\n  rayLen=maxDepth-0.2;//keep rayLen in bounds for models \n  smoothSteps=(float(iSteps)-2.0*dist/rayLen+rand(gl_FragCoord.xy))/float(steps);\n  cGlow=vec3(min(-(rayDir.y-1.)*10.,.8)); \n } \n color=mix(color,cGlow,smoothSteps);//GLOW \n O = vec4(clamp(color,0.0,1.0),1.0);\n} \n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//beats per sec\n#define bps 4.\n//how many beats notes are held\n#define holds 4.\nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);}\nvec2 nofs(float n){//the song's \"random\" ring\n  float r=0.5+0.5*rnd(floor(n));//random volume\n  n=mod(n,8.0);//random ring for brownian motion\n  if(n<1.)n=3.;\n  else if(n<2.)n=1.;\n  else if(n<3.)n=-2.;\n  else if(n<4.)n=-1.;\n  else if(n<5.)n=0.;\n  else if(n<6.)n=-1.;\n  else if(n<7.)n=-3.;\n  else n=3.;\n  //n=(n<1.?3.:n<2.?1.:n<3.?-2.:n<4.?-1.:n<5.?0.:n<6.?-1.:n<7.?-3:3.);\n  return vec2(n,r);\n}\nfloat scale(float note){//throws out dissonant tones\n float n2=mod(note,12.); \n return ((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==10.))?-100.:note;\n}\n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2\nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;}\nfloat env(float att, float bt){return (1.0-exp(-bt*att))*max(1.0-pow(bt,.1),0.);}\n\nvec2 inst(float n,float t,float bt){//note, time and beat within note\n float sn=scale(floor(n));if(sn<0.0)return vec2(0.0);\n float f=ntof(sn);\n float a=sin(f*t*6.283+bt*3.14159*sin(f*t*1.57));\n return vec2(1.5-n/90.0+sin(bt),n/90.0-sin(bt))*a*env(2000.0,bt/holds)*60.0/n;\n}\nvec2 mainSound(int samp, float time){\n float tim=time*bps;\n vec2 a=vec2(0);//accumulator\n for(float i=0.;i<holds;i+=1.){//creating held notes by backing up and playing the\n   float b0=floor(tim),t0=fract(tim);//..tails of old notes\n   vec2 n0=nofs(b0*0.125)+nofs(b0*0.25)+nofs(b0*0.5)+nofs(b0);//sloth canon (fbm for music)\n   a+=inst(n0.x+60.0,time,t0+i)*n0.y;\n   a+=inst(n0.x+67.0,time,t0+i)*n0.y;//a harmonic 7th\n   //if(mod(i,2.0)<1. && n0.x>0. && scale(floor(n0.x+1.))>0.)a+=0.5*(rnd(time)-.5)*n0.y*env(100.,t0*5.);\n   tim-=1.;//go back in time\n }\n return clamp(a/(8.*float(holds)),-1.,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}