{
    "Shader": {
        "info": {
            "date": "1574949678",
            "description": "Using ideas set out in MathMasterZach's \"Self-Avoiding Random Road\" example to create a Wang tile border animation.",
            "flags": 0,
            "hasliked": 0,
            "id": "wdySWG",
            "likes": 28,
            "name": "Wang Tile Border Animation",
            "published": 3,
            "tags": [
                "tile",
                "wang",
                "tracks"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1103
        },
        "renderpass": [
            {
                "code": "/*\n\n\n\tWang Tile Border Animation\n\t--------------------------\n\n\tShadertoy user MathMasterZach put together a very nice, cleverly made maze\n    recently, complete with a surrounding conveyor belt system, then Fabrice put\n\tin some really clever suggestions. I effectively brought nothing to the table,\n\tbut I was part of the cheer squad, so I felt like I was contributing. :D \n\n\tAnyway, I'm aware of the concept of an animated border -- I applied it in my\n    \"Hexagonal Maze Flow\" example. I've also been vaguely aware that an animated \n    border can be applied to all kinds of patterns, but figured it would be too \n    much of a book-keeping mission to produce one around anything but the simplest\n\tof grid arrangements.\n\t\n    However, after perusing the code for a while, I realized that either Zach or \n    Fabrice had employed a neat trick that involved producing a pattern on a\n    standard grid, then subdividing each grid cell into four squares, which in turn\n\twould provide the scaffolding upon which to mold a path around the original \n\tstructure in a simplistic and manageable fashion. It's quite clever, and the \n    kind of thing that would have taken me forever to realize.\n\n\tIn this particular example, I'm applying a very similar principle to a Wang \n    tile pattern. As usual, I got a bit excited with the prettying up portion,\n    which has a tendency to drown out the relevant logic. However, the imagery \n    itself is kind of self explanatory and should give people enough to go on.\n\tHere's a brief summary:\n\n    Straight horizontal segments on the bottom of each cell travel west, and the \n    top ones travel east. Straight vertical segments on the left side of the cell\n    move north, and those on the right travel south. Arcs with their centers at \n    the physical cell center turn clockwise, whereas those with their centers \n    fixed on the cell edges move in the counter-clockwise direction.\n\n    I've also provided some options below and explained the notable segments.\n    Plus, you can always refer the original, which contains much more elegant and \n    succinct code. The link is below.\n\n\n\n\tBased on:\n\n\t// A really nice example on so many different levels. The maze code itself is\n\t// also pretty interesting and clever. The path itself visits every node exactly\n\t// once without crossing its own path, and is useful for all kinds of \n\t// things -- See the link below this one. I'm going to produce a couple of \n    // examples along these lines too.\n\tSelf-Avoiding Random Road - mathmasterzach\n\thttps://www.shadertoy.com/view/wdySWm\n\n\n\tOther examples:\n\n    // This example is really pleasing to watch.\n    Indexed Space Fill Random Path - mathmasterzach\n\thttps://www.shadertoy.com/view/wdySRy\n\n    // A similar animated flow line example, but this was easier to construct.    \n    Hexagonal Maze Flow - Shane\n    https://www.shadertoy.com/view/llSyDh\n\n\t// Dr2 has already put together an extruded 3D example.\n\tLong Loop - Dr2\n\thttps://www.shadertoy.com/view/wdKSDy\n\n\n*/\n\n// Display the inner Wang tile structure that the border flows around. Essentially, \n// you could apply the same concept to heaps of things. Aesthetically, I prefer \n// turning this option off, but it helps visualize the concept more.\n#define SHOW_INNER_STRUCTURE\n\n// Show the straight rails, instead of the beaded structure.\n//#define SHOW_RAILS\n\n// A visual aid to display the original grid boundaries. Although, things get\n// a bit cluttered at this point, so it's probably better with the SHOW_RAILS\n// option turned on.\n//#define SHOW_ORIGINAL_GRID\n\n// A plainer palette to declutter things a bit. The colors vary ever so slightly,\n// so technically, it's not monochrome, but that doesn't write well as a define. :)\n//#define MONOCHROME\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Dave Hoskins's vec2 to float hash.\n// You can find the details here:\n//\n// Hash without Sine - Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash21(vec2 p){ \n    \n    //  2 in, 1 out. \n\tvec3 p3  = fract(vec3(p.xyx)*.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y)*p3.z);\n    \n    // IQ's version. It's my preferred version, but unfortunately,\n    // not always accurate enough for some systems.\n    //return fract(sin(dot(p, vec2(137.609, 157.583)))*43758.5453);\n}\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\n\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n\n// This renders a horizontal or vertical box-line from point \"a\" to point \"b,\" with a line \n// width of \"w.\" It's different to the the usual line formula because it doesn't render the \n// rounded caps on the end -- Sometimes, you don't want those. It utilizes IQ's box formula \n// and was put together in a hurry, so I'd imagine there are more efficient ways to do the \n// same, but it gets the job done. I put together a more generalized angular line formula as \n// well.\nfloat lBoxHV(vec2 p, vec2 a, vec2 b, float w){\n    \n   vec2 l = abs(b - a); // Box-line length.\n   p -= vec2(mix(a.x, b.x, .5), mix(a.y, b.y, .5)); // Positioning the box center.\n   \n   // Applying the above to IQ's box distance formula.\n   vec2 d = abs(p) - (l + w)/2.; \n   return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n\n\n// Distance formula.\nfloat dist(vec2 p, vec2 b){\n    \n    //return length(p) - b.x;\n    return sBoxS(p, b, .2);\n    \n}\n\n// Use the unique edge point IDs to produce a Wang tile ID for the tile.\nfloat edges(vec2 ip, vec2[4] ep, float rnd){\n    \n    // Initial ID: Trivial, and converts to a binary string of \"0000,\" which indicates\n    // the cell has no edge points, or an empty tile.\n    float id = 0.;\n    \n    // Note: exp2(i) = pow(2., i).\n    for(int i = 0; i<4; i++) id += hash21(ip + ep[i])>rnd? exp2(float(i)) : 0.;\n    \n    return id; // Range [0-15] inclusive.\n    \n}\n\n// Hacky global. Just a regional ID for coloring purposes.\nvec2 regID;\n\nvec4 distField(vec2 p){\n    \n    // Tile ID and local coordinate.\n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    \n    // Set the region ID to the main tile ID.\n    regID = ip;\n    \n    // Distance field holders.\n    float d = 1e5, d2 = d, d3 = d;\n    \n    // Wang tile constrction. Pretty standard, and I've explained it in other\n    // examples, if you feel like looking them up.\n    //\n    const float thresh = .5; // Threshold.\n    vec2[4] eps = vec2[4](vec2(-.5, 0), vec2(0, .5), vec2(.5, 0), vec2(0, -.5));\n    vec2[4] cp = eps; \n    \n    // Edge ID for the \n    float id = edges(ip, eps, thresh);\n    // Decode each binary digit.\n    vec4 bit = mod(floor(id/vec4(1, 2, 4, 8)), 2.);\n\n    \n    int iNum = 0; // Edge point index.\n    \n    for(int i = 0; i<4; i++){\n        // Edge numbers.\n        if(bit[i]>.5) {\n            \n            d2 = min(d2, lBoxHV(p, vec2(0), eps[i], 0.));\n            cp[iNum++] = eps[i];\n        }\n        \n    } \n    \n    \n    \n    // Subdividing each cell into four squares, then using the existing\n    // structure to perform  bit checks.\n    \n    // Subdividing further into four squares.\n    vec2 q = mod(p, .5) - .25;\n    \n    \n    // Quadrant identification.\n    int quadID;\n    \n    if(p.x<0.){\n        if(p.y<0.) quadID = 0;\n        else quadID = 1;\n    }\n    else {\n        if(p.y<0.) quadID = 3;\n        else quadID = 2;\n    }\n    \n    \n     \n    // Object angle variable. Moving clockwise.\n    float ang = -iTime/2.;\n    // Quadrant sign variable. It was used to great effect in Zach's example.\n    vec2 s = sign(p);\n    \n    \n    \n    // This mess was written quickly off the top of my head. In concept, it's\n    // simple though. For each quadrant, construct an edge list by referencing\n    // the main Wang structure, then render the Wang structure for it using\n    // standard Wang tile methods.\n    \n    for(int j = 0; j<4; j++){\n        \n        // If the line from the main cell is blocking the \n        // direction, head in that direction also, since you want to\n        // avoid the line and not run into it. Otherwise, head\n        // toward the open space.\n        \n        // Border count.\n        int borders = 0;\n        \n        // Quad ID.\n        float qID = 0.;\n        \n        // Contrucing the edge IDs for this particular quadrant. \n        if(bit[j]>.5) { \n            qID += float(1<<(j)); // 1, 2, 4, 8.\n            borders++;\n        }\n        else qID += float(1<<((j + 1)&3)); // 2, 4, 8, 1.\n        \n        if(bit[(j + 3)&3]>.5) {\n            qID += float(1<<((j + 3)&3)); // 8, 1, 2, 4. \n            borders++;\n        }\n        else qID += float(1<<((j + 2)&3)); // 4, 8, 1, 2.\n        \n        \n        // Edge bit extraction.\n        vec4 qBit = mod(floor(qID/vec4(1, 2, 4, 8)), 2.);\n\n        // Fill in the point structure. Actually, this isn't\n        // technically needed, as you can constuct things with\n        // the quadrant sign variable \"s,\" but I'll need it later.\n        int cnt = 0;\n        vec2[4] qCp = eps; \n        for(int i = 0; i<4; i++){\n            if(qBit[i]>.5){\n                qCp[cnt++] = eps[i]/2.;\n            }\n        }\n        \n        \n        // Contruct the distance fields for this quadrant in any empty\n        // cells. By the way, you don't need to leave empty cells empty,\n        // but I prefer it that way.\n        if(quadID == j && iNum>0){\n            \n            // Refering to the imagery. If there's one border, render\n            // a straight line.\n            if(borders == 1){\n                \n                // Straight line.\n                d = min(d, lBoxHV(q,  qCp[0], qCp[1], 0.)); \n                //d = min(d, lBoxHV(q, vec2(0), qCp[0], 0.)); \n                //d = min(d, lBoxHV(q, vec2(0), qCp[1], 0.)); \n              \n                \n                // Vertical.\n                if(abs(qCp[0].x - qCp[1].x)<.001) {\n                    \n            \n                    // If you take a look at the imagery, you'll see that vertical\n                    // lines on the left need to travel in opposite directions, \n                    // depending which side of the \"p.x = 0\" line they're on. Hence\n                    // the \"s.x\" term. The same applies for the horizontal term\n                    // below.\n                    // \n                    // On a side note. If you choose the right number of repeat \n                    // segments, you can manipulate the angle (or spacing, in this\n                    // case) to make things look more consistant -- since the perimeter\n                    // of a square is larger than that of its circumscribed circle.\n                    //\n                    // For instance, with three segments in each quarter circle, you \n                    // could increase the three here to four by multiplying s.x by 4/3. \n                    // You'd want to do it for the horizontal case below as well.\n                    ang += -(q.y + .25)*s.x;\n                    \n                    // Region ID.\n                    regID = ip + .3;\n                    \n                }\n                else {\n                    \n                    // See the comments above.\n                    ang += (q.x + .25)*s.y;\n                    \n                    // Region ID.\n                    regID = ip + .1;\n                    \n                }\n               \n\n            }\n            else if(borders == 2){\n                \n                // Two borders mean a curved inner bend rendering.\n                \n                vec2 offs = qCp[0] +  qCp[1];\n                d = min(d, dist(q - offs, vec2(.25)));\n                \n                // Quarter circles, so four segments per complete\n                // revolution, which means... Carry the one... The\n                // figure Zach chose works perfectly, so that's good\n                // enough for me. :D\n                //\n                // Current angle. You could use the \"s\" variable too.\n                //ang += atan(q.y - s.y/4., q.x - s.x/4.)/6.283*4.;\n                ang += -atan(q.x - offs.x, q.y - offs.y)/3.14159;\n                \n               \n   \t\t\t\t// Region ID.\n                regID = ip + .2;\n                \n            }\n            else {\n                \n                 // No borders in a non-empty quadrand requre a curved \n                // outer bend rendering.\n                \n                 vec2 offs = qCp[0] +  qCp[1];\n                 d = min(d, dist(q - offs, vec2(.25)));\n                 \n                 // Current angle. You could use the \"s\" variable too.\n                 //ang += atan(q.y - s.y/4., q.x - s.x/4.)/6.283*4.;\n                 ang += atan(q.x - offs.x, q.y - offs.y)/3.14159;\n                \n\n                 // Region ID.\n                 regID = ip + .4;\n                 \n            }\n            \n        }\n            \n        \n    }\n    \n    \n    // Rendering lines around the original Wang tile borders, which is a\n    // bit wasteful, but this is a cheap 2D example.\n    d3 = min(d3, lBoxHV(p, vec2(-.5, -.5), vec2(-.5, .5), 0.));\n    d3 = min(d3, lBoxHV(p, vec2(.5, -.5), vec2(.5, .5), 0.));\n    d3 = min(d3, lBoxHV(p, vec2(-.5, .5), vec2(.5, .5), 0.));\n    d3 = min(d3, lBoxHV(p, vec2(-.5, -.5), vec2(.5, -.5), 0.));\n    \n    #ifdef SHOW_ORIGINAL_GRID\n    d3 -= .045;\n    #endif\n\n    //#ifndef SHOW_ORIGINAL_GRID\n    // Region border construction: Ugly coding at its finest. :)\n    //\n    // I wanted to render region borders, and needed a quick working\n    // method. It works, but I'm pretty sure there are way more \n    // streamlined ways to get the job done.\n    if(id==1. || id==4.){\n        d3 = min(d3, lBoxHV(p, eps[1], eps[3], 0.));\n    }\n    \n    if(id==2. || id==8.){\n        d3 = min(d3, lBoxHV(p, eps[0], eps[2], 0.));\n    }\n    \n    if(id==3. || id==6. ||id==9. ||id==12.){\n        d3 = min(d3, lBoxHV(p, eps[0], eps[2], 0.));\n        d3 = min(d3, lBoxHV(p, eps[1], eps[3], 0.));\n       \n    }\n    \n    if(id==7. || id==13.) d3 = min(d3, lBoxHV(p, eps[0], eps[2], 0.));\n    if(id==11. || id==14.) d3 = min(d3, lBoxHV(p, eps[1], eps[3], 0.));\n    //#endif\n\n    \n\n    \n    // Returning the border, main structure and current angle.\n    return vec4(d, d2, d3, ang);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 800.);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iRes;\n    \n    // Subtle barrel distortion.\n    float r = dot(uv, uv);\n    uv *= 1. + .025*(r*r*.5 + r);\n    \n    // Scaling and translation.\n    float gSc = 6.;\n    //rot2(3.14159/4.)*\n    // Depending on perspective; Moving the oject toward the bottom left, \n    // or the camera in the north east (top right) direction. \n    vec2 p = uv*gSc - vec2(-.5, 0)*iTime;\n    \n   \n    \n    // Keeping a copy.\n    vec2 oP = p;\n    \n    // Smoothing factor, based on scale and resolution.\n    float sf = gSc/iResolution.y;\n  \n    // The animated border distance field and the field for the shadow, \n    // which we're calling first, so as not to disturb some globals.\n    vec4 dSh = distField(p - vec2(-.08, -.12));\n    vec4 d = distField(p);\n    \n    // The straight rail, which we're not using at present.\n    float oD = d.x;\n    float oDSh = dSh.x;\n    \n    // Current angle. Used for animated object construction. \n    float ang = d.w;\n    float angSh = dSh.w;\n    \n    // // The straight rail, which we're not using at present.\n    d.x = abs(d.x) - .15;\n    // The inner Wang tile structure.\n    d.y -= .055;\n    \n    // The corresponding shadows.\n    dSh.x = abs(dSh.x) - .15;\n    dSh.y -= .055;\n       \n    \n    \n    // Use the region ID to generated a random palette color.\n    // Four color palette.\n    vec3[4] pal = vec3[4](vec3(1, .8, .2), vec3(1, .4, .2), vec3(.2, .8, 1), vec3(.2, .4, 1));\n    vec3 col = pal[int(floor(hash21(regID)*3.999))];\n    col = mix(col, col.yzx, uv.y*.75 + .5);\n    \n    #ifdef MONOCHROME\n    float cRnd = hash21(regID); // Random cell color.\n    col = vec3(1, .75 + cRnd*.1, .45 + cRnd*.2);\n    #endif\n    \n\n    // Rendering the region borders.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d.z - .01)));\n\n    \n     \n    // If you increase the number of segments, you'll often have to\n    // change the repeat shape width. Otherwise, you'll end up with\n    // a continuous blob.\n    const float aNum = 2.;\n    // This is something I occasionally need to remind myself of: There are two\n    // ways to render repeat objects around a curved surface. One is to obtain the\n    // the angular position to the object's center on a curve, then render with \n    // aspect correct local coordinates -- That way, if you draw a square, it won't \n    // be mutated.\n    //\n    // However, there are times, like this, when you want the object to mold to the\n    // underlying distance field's shape. The difference, in this case, is that I'm \n    // allowing the angle to vary from one side of the shape to the other, instead \n    // of snapping it to a central position. Obviously, for repeat objects, you \n    // still need to do the repetition thing, which is the case below.\n    float a = (mod(ang*2., 1./aNum) - .5/aNum);\n    \n     // Distance field coordinates -- For a circle, you'd use something like \n    // vec2(angle, radiusDistance), but that's just a special case. In a more general\n    // sense, it's vec2(angleOnSurface, surfaceDistance).\n    vec2 distP = abs(vec2(a/2., oD));\n    float rObj = sBoxS(distP, vec2(.05, .05), .025);\n    rObj = rObj - .12;\n    \n    // The corresponding shadows.\n    float aSh = (mod(angSh*2., 1./aNum) - .5/aNum);\n    vec2 distPSh = abs(vec2(aSh/2., oDSh));\n    float rObjSh = sBoxS(distPSh, vec2(.05, .05), .025);\n    // Cutting a whole out of the shadow to give it a caustic effect.\n    // Completely fake, of course. The correct line is below it. \n    rObjSh = max(rObjSh - .12, -(rObjSh - .04));\n    //rObjSh = rObjSh - .12;\n    \n    \n    // It's possible to rotate object colors, but not many.\n    //float objID = mod(floor(ang*aNum*2.), aNum);\n    \n    // Object color.\n    vec3 oCol = vec3(1);\n    \n    \n    #ifdef SHOW_RAILS\n    // With the translucent rails option, decrease the size of the\n    // rounded square objects slightly.\n    rObj += .01;\n    rObjSh += .01;\n    #endif\n    \n\n    \n    #ifdef SHOW_INNER_STRUCTURE\n    // When dispaying the inner structure, merge its shadow with the \n    // outer framework.\n    #ifdef SHOW_RAILS\n    dSh.x = min(max(dSh.x, -rObjSh), dSh.y);\n    #else\n    rObjSh = min(rObjSh, dSh.y);\n    #endif    \n    #endif\n    \n    #ifdef SHOW_ORIGINAL_GRID\n    #ifdef SHOW_RAILS\n    dSh.x = min(dSh.x, dSh.z);\n    #else\n    rObjSh = min(rObjSh, dSh.z);\n    #endif\n    #endif\n    \n    // Lay down the shadows.\n    #ifdef SHOW_RAILS\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., dSh.x))*.7);\n    #else\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., rObjSh))*.7); \n    #endif\n    \n    #ifdef SHOW_ORIGINAL_GRID\n    col = mix(col, vec3(1), (1. - smoothstep(0., sf, d.z + .02)));\n    #endif\n    \n    // Render the objects themselves, in a fake translucent manner.\n    vec3 svCol = col;\n    #ifdef SHOW_RAILS\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d.x)));\n    col = mix(col, min(svCol*2., 1.), (1. - smoothstep(0., sf, d.x + .03)));\n    #else\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, rObj)));\n    col = mix(col, min(svCol*2., 1.), (1. - smoothstep(0., sf, rObj + .03)));\n    #endif\n    \n   \n    // Applying the middle section of the repeat animated pattern.\n    svCol = col;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, rObj + .06)));\n    col = mix(col, mix(svCol*2., oCol, .75), (1. - smoothstep(0., sf, rObj + .09)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., max(rObj + .09, rObjSh + .02)))*.15);\n     \n    \n    #ifdef SHOW_INNER_STRUCTURE\n    // Render the inner Wang tile structure.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d.y)));\n    col = mix(col, mix(svCol*2., vec3(1, .85, .35), .75), (1. - smoothstep(0., sf, d.y + .03)));\n    #endif\n    \n    // Apply some subtle noise.\n    float ns = fbm(oP/gSc*96.*max(iRes/450., 1.));\n    vec3 tx = mix(vec3(1, .8, .7), vec3(.05, .1, .15), ns);\n    col *= tx*.5 + .7;\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    float vig = pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./6.);\n    col *= min(vig*1.25, 1.);\n    \n    \n    // Rough gamma correction, then output to the screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}