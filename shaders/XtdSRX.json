{
    "Shader": {
        "info": {
            "date": "1480879451",
            "description": "Second attempt to draw Mandale following previous shader: https://www.shadertoy.com/view/MtcSz4",
            "flags": 0,
            "hasliked": 0,
            "id": "XtdSRX",
            "likes": 45,
            "name": "Mandala II",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "mandala"
            ],
            "usePreview": 1,
            "username": "xbe",
            "viewed": 1279
        },
        "renderpass": [
            {
                "code": "// Xavier Benech\n// Mandala 2D (2nd version)\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.14159265\n\n#define CART2POLAR(x,y) vec2( sqrt(x*x + y*y), atan(y, x) )\n\n//////////////////////////////////////////////////////////////////////////////\n// Primitives\n\nfloat circle(vec2 p, float r, float width)\n{\n    float d = 0.;\n    d += smoothstep(1., 0., width*abs(p.x - r));\n    return d;\n}\n\nfloat stripes(vec2 p, float a, float width)\n{\n    float d = 0.;\n    d += smoothstep(1., 0., width*abs(abs(p.y) - a));\n    return d;\n}\n\nfloat zebra(vec2 p, float width)\n{\n    float d = 0.;\n    d += smoothstep(1., 0., width*abs(p.x - p.y));\n    d += smoothstep(1., 0., width*abs(p.x + p.y));\n    return d;\n}\n\nfloat mirror(float x, float v, float width)\n{\n    float d = 0.;\n    d += smoothstep(1., 0., width*abs(x - v));\n    d += smoothstep(1., 0., width*abs(x - abs(v)));\n    d += smoothstep(1., 0., width*abs(abs(x) - v));\n    d += smoothstep(1., 0., width*abs(abs(x) - abs(v)));\n    return d;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Shapes\n\nfloat leaf(vec2 p, float width) {\n    float d = 0.;\n    d += smoothstep(1., 0., width*abs(p.x - abs(sin(-p.y)* exp(-p.y))));\n    d += smoothstep(1., 0., width*abs(abs(p.x) - abs(sin(p.y)* exp(p.y))));\n    return d;\n}\n\nfloat spiral(vec2 p, float width) {\n    return mirror(p.x, 0.5 * p.y / PI, width);\n}\n\nfloat rose(vec2 p, float t, float width) {\n    const float a = 6.;\n    p.x *= 7. + 8. * t;\n    return mirror(p.x, sin(a * p.y), width);\n}\n\nfloat rose2(vec2 p, float t, float width) {\n    const float a = 6.;\n    p.x *= 7. + 8. * t;\n    return mirror(p.x, cos(a * p.y), width);\n}\n\nfloat fun(vec2 p, float t, float width) {\n    const float a = 6.;\n    p.x *= 7. + 8. * t;\n    return mirror(sin(a * p.x / PI), cos(a * p.y / PI), width);\n}\n\nfloat fun2(vec2 p, float t, float width) {\n    const float a = 6.;\n    p.x *= 7. + 8. * t;\n    return mirror(p.x, sin(a * p.y)+cos(a * p.y), width);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Mandala\n\nfloat Shape1(vec2 p, vec2 m, float a, float d) {\n    const float w = 8.;\n    vec2 f = mod(p, m) - 0.5 * m;\n    f.x *= a;\n    float res = 0.;\n    res += fun2(vec2(f.x, f.y*f.y), d, w);\n    res += fun2(vec2(f.x + 0.01, f.y*f.y + 0.05), d, w);\n    res += fun2(vec2(f.x - 0.01, f.y*f.y + 0.05), d, w);\n    res += fun2(vec2(f.x + 0.02, f.y*f.y + 0.075), d, w);\n    res += fun2(vec2(f.x - 0.02, f.y*f.y + 0.075), d, w);\n    return res;\n}\n\nfloat Shape2(vec2 p, vec2 m, float a, float d) {\n    const float w = 8.;\n    vec2 f = mod(p, m) - 0.5 * m;\n    f.x *= a;\n    float res = 0.;\n    res += rose(vec2(f.x, f.y*f.y), d, w);\n    res += rose(vec2(f.x + 0.01, f.y*f.y + 0.05), d, w);\n    res += rose(vec2(f.x - 0.01, f.y*f.y + 0.05), d, w);\n    res += rose(vec2(f.x + 0.02, f.y*f.y + 0.075), d, w);\n    res += rose(vec2(f.x - 0.02, f.y*f.y + 0.075), d, w);\n    return res;\n}\n\nfloat Shape3(vec2 p, vec2 m, float a, float d) {\n    const float w = 8.;\n    vec2 f = mod(p, m) - 0.5 * m;\n    f.x *= a;\n    float res = 0.;\n    res += rose(vec2(f.x, f.y*f.y), d, w);\n    res += rose(vec2(f.x + 0.01, f.y*f.y + 0.05), d, w);\n    res += rose(vec2(f.x - 0.01, f.y*f.y + 0.05), d, w);\n    res += rose(vec2(f.x + 0.02, f.y*f.y + 0.075), d, w);\n    res += rose(vec2(f.x - 0.02, f.y*f.y + 0.075), d, w);\n    return res;\n}\n\nfloat Mandala1(vec2 p) {\n    float res = 0.;\n    vec2 m;\n    vec2 f;\n    if (p.x > 0.6)\n        return 0.;\n    if (p.x < 0.25) {\n        m = vec2(0.25, PI / 6.);\n        f = mod(p, m) - 0.5 * m;\n        f.x *= 1.5;\n        f.y /= 2.;\n        res += zebra(vec2(f.x, f.y), 32.);\n    } \n    if (p.x > 0.32 && p.x < 0.5) {\n        m = vec2(0.25, PI / 12.);\n        f = mod(p, m) - 0.5 * m;\n        f.x *= 2.;\n        res += zebra(vec2(f.x, f.y), 32.);\n        res += zebra(vec2(f.x, f.y - 0.05), 32.);\n        res += zebra(vec2(f.x, f.y + 0.05), 32.);\n        res += zebra(vec2(f.x, f.y - 0.1), 32.);\n        res += zebra(vec2(f.x, f.y + 0.1), 32.);\n    }\n    if (p.x < 0.15) {\n\t    res += 0.25 * Shape1(p, vec2(0.3, PI/6.), 1.5, 0.65);\n    }\n    if (p.x > 0.12 && p.x < 0.34) {\n\t    res += 0.5 * Shape1(p, vec2(0.34, PI/4.), 1.5, 0.65);\n\t    res += 0.25 * Shape1(p, vec2(0.42, PI/6.), 1.5, 0.65);\n    }\n    if (p.x > 0.32 && p.x < 0.5) {\n        m = vec2(0.5, PI / 6.);\n        f = mod(p, m) - 0.5 * m;\n        res += stripes(vec2(f.x, f.y), 0.125, 48.);\n    }\n\tres += 2.*circle(p, 0.015, 72.);\n\tres += 2.*circle(p, 0.105, 72.);\n\tres += circle(p, 0.27, 64.);\n\tres += 2.*circle(p, 0.32, 64.);\n\tres += 2.*circle(p, 0.5, 72.);\n\tres += 2.*circle(p, 0.525, 72.);\n    return 0.5 * res;\n}\n\nfloat Mandala2(vec2 p) {\n    float res = 0.;\n    vec2 m;\n    vec2 f;\n    if (p.x > 0.6)\n        return 0.;\n    if (p.x < 0.4) {\n        m = vec2(0.25, PI / 6.);\n        f = mod(p, m) - 0.5 * m;\n        f.y *= 0.5;\n        res += 0.5 * rose2(vec2(f.x, f.y), 1., 3.);\n    }\n    if (p.x > 0.0125 && p.x < 0.5) {\n        m = vec2(0.25, PI / 6.);\n        f = mod(p, m) - 0.5 * m;\n        f.y *= 0.5;\n        res += zebra(vec2(f.x, f.y), 28.);\n    }\n    if (p.x < 0.5) {\n        m = vec2(0.25, PI / 6.);\n        f = mod(p, m) - 0.5 * m;\n        res += 0.5 * fun(vec2(f.x, f.y), 0.125, 28.);\n    }\n\tres += 2.*circle(p, 0.015, 72.);\n\tres += 2.*circle(p, 0.105, 72.);\n\tres += circle(p, 0.38, 64.);\n\tres += 2.*circle(p, 0.5, 72.);\n\tres += 2.*circle(p, 0.525, 72.);\n    return 0.5 * res;\n}\n\nfloat Mandala3(vec2 p) {\n    float res = 0.;\n    vec2 m;\n    vec2 f;\n    if (p.x > 0.6)\n        return 0.;\n    if (p.x < 0.25) {\n        m = vec2(0.25, PI / 6.);\n        f = mod(p, m) - 0.5 * m;\n        f.y *= 0.5;\n        res += 0.25 * rose2(vec2(f.x, f.y), 1., 4.);\n    }\n    if (p.x > 0.0125 && p.x < 0.5) {\n        m = vec2(0.25, PI / 6.);\n        f = mod(p, m) - 0.5 * m;\n        f.y *= 0.5;\n        res += zebra(vec2(f.x, f.y), 28.);\n    }\n    if (p.x < 0.5) {\n        m = vec2(0.3, PI / 6.);\n        f = mod(p, m) - 0.5 * m;\n        res += 0.5 * fun(vec2(f.x, f.y), 0.125, 28.);\n    }\n    if (p.x < 0.5) {\n        m = vec2(0.25, PI / 6.);\n        f = mod(p, m) - 0.5 * m;\n        f.x *= 2.5;\n        f.y += 0.135;\n        res += 0.5 * fun2(vec2(f.x, f.y), 0.25, 3.);\n    }\n\tres += 2.*circle(p, 0.015, 72.);\n\tres += 2.*circle(p, 0.125, 96.);\n\tres += 2.*circle(p, 0.5, 72.);\n\tres += 2.*circle(p, 0.525, 72.);\n    return 0.5 * res;\n}\n\nfloat Mandala4(vec2 p) {\n    float res = 0.;\n    vec2 m;\n    vec2 f;\n    if (p.x > 0.6)\n        return 0.;\n    if (p.x < 0.125) {\n\t    res += 0.25 * Shape1(p, vec2(0.25, PI/6.), 2.5, 0.25);\n\t   \tres += 0.25 * Shape1(p, vec2(0.5, PI/6.), 0.7, .125);\n    }\n    if (p.x > 0.195 && p.x < 0.32) {\n        m = vec2(0.5, PI / 4.);\n        f = mod(p, m) - 0.5 * m;\n        f.x *= 3.;\n        res += leaf(vec2(f.x, f.y), 28.);\n    }\n    if (p.x > 0.16 && p.x < 0.19) {\n        m = vec2(0.5, PI / 12.);\n        f = mod(p, m) - 0.5 * m;\n        res += stripes(vec2(f.x, f.y), 0.125, 32.);\n    }\n    if (p.x < 0.175) {\n        m = vec2(0.5, PI / 4.);\n        f = mod(p, m) - 0.5 * m;\n        float d = 0.375;\n        res += 0.5 * fun2(vec2(f.x, f.y*f.y), d, 16.);\n        res += 0.5 * fun2(vec2(f.x + 0.01, f.y*f.y + 0.05), d, 16.);\n        res += 0.5 * fun2(vec2(f.x - 0.01, f.y*f.y + 0.05), d, 16.);\n        res += 0.5 * fun2(vec2(f.x + 0.02, f.y*f.y + 0.075), d, 16.);\n        res += 0.5 * fun2(vec2(f.x - 0.02, f.y*f.y + 0.075), d, 16.);\n    }\n    if (p.x > 0.2 && p.x < 0.32) {\n        float w = 20.;\n        m = vec2(0.4, PI / 4.);\n        f = mod(p, m) - 0.5 * m;\n        f.x *= 1.5;\n        f.y *= 2.;\n        res += 0.25*fun(vec2(f.x, f.y*f.y), -0.4, w);\n        res += 0.25*fun(vec2(f.x + 0.01, f.y*f.y + 0.05), -0.4, w);\n        res += 0.125*fun(vec2(f.x + 0.01, f.y*f.y - 0.05), -0.4, w);\n        res += 0.25*fun(vec2(f.x + 0.02, f.y*f.y + 0.075), -0.4, w);\n        res += 0.125*fun(vec2(f.x + 0.02, f.y*f.y - 0.075), -0.4, w);\n    }\n    if (p.x > 0.2 && p.x < 0.6) {\n        vec2 pp = p;\n        pp.x *= 0.685;\n        m = vec2(0.25, PI / 4.);\n        f = mod(pp, m) - 0.5 * m;\n        float d = 0.375;\n        res += 0.5 * fun2(vec2(f.x, f.y*f.y), d, 16.);\n        res += 0.25 * fun2(vec2(f.x + 0.01, f.y*f.y + 0.05), d, 16.);\n        res += 0.5 * fun2(vec2(f.x - 0.01, f.y*f.y + 0.05), d, 16.);\n        res += 0.25 * fun2(vec2(f.x + 0.02, f.y*f.y + 0.075), d, 16.);\n        res += 0.5 * fun2(vec2(f.x - 0.02, f.y*f.y + 0.075), d, 16.);\n    }\n    if (p.x > 0.32 && p.x < 0.5) {\n        vec2 pp = p;\n        pp.x *= 0.825;\n        m = vec2(0.25, PI / 12.);\n        f = mod(pp, m) - 0.5 * m;\n        f.x *= 5.;\n        res += zebra(vec2(f.x, f.y), 32.);\n        res += zebra(vec2(f.x, f.y - 0.05), 32.);\n        res += zebra(vec2(f.x, f.y + 0.05), 32.);\n    }\n\tres += 2.*circle(p, 0.015, 72.);\n\tres += circle(p, 0.16, 128.);\n\tres += circle(p, 0.19, 96.);\n\tres += 2.*circle(p, 0.32, 96.);\n\tres += circle(p, 0.41, 128.);\n\tres += 2.*circle(p, 0.5, 72.);\n\tres += 2.*circle(p, 0.525, 72.);\n    return 0.5 * res;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q - 0.5;\n\tp.x *= iResolution.x/iResolution.y;\n    \n    vec2 f = CART2POLAR(p.x, p.y);\n    \n    float z = 0.;\n    float t = mod(0.3*iTime, 4.);\n    float pcf = floor(t);\n    float m = fract(t) - 0.5;\n    m = smoothstep(0.0, 0.5, (m > 0. ? m : 0.));\n    if (pcf < 1.) {\n       z = mix(Mandala1(f), Mandala2(f), m);\n    } else if (pcf < 2.) {\n       z = mix(Mandala2(f), Mandala3(f), m);\n    } else if (pcf < 3.) {\n       z = mix(Mandala3(f), Mandala4(f), m);\n    } else {\n       z = mix(Mandala4(f), Mandala1(f), m);\n    }\n    \n    z *= z;\n\n    vec3 s = vec3(0.);\n    s.x = 1.33/(0.15+z);\n    s.y = cos(f.y) + 0.25*cos(4.*PI*f.x);\n    s.z = exp(-2.*z);\n\n\tvec3 bkg = vec3(0.72,0.72,0.48);\n    vec3 col = 0.6 + 0.4*cos( bkg + 2.5 + s.z*6.2831 );\n\t\n\tcol += 0.2 * vec3(0.56,0.56,0.56) * s.y;\n    col *= 0.2 * s.x;\n   \tcol *= 0.5 - 0.45*cos(16.0*s.z);\n   \tcol += 0.25 - 0.25*cos(16.0*s.z) * vec3(0.48, 0.64, 0.92);\n    \n\tvec3 nor = normalize( vec3( dFdx(s.z), 0.02, dFdy(s.z) ) );\n\tfloat dif = dot( nor, vec3(0.8,0.8,0.2) );\n\tcol += 0.125*vec3(dif);\n\n    // Vigneting + gamma\n\tcol *= 0.3 + 0.7*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\n    col = pow(col, vec3(0.735));\n    fragColor = vec4( clamp(col, 0., 1.), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}