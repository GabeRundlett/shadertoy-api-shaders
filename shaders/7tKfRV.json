{
    "Shader": {
        "info": {
            "date": "1664877205",
            "description": "Minimalist assembly instructions for \"Rector's Palace\"",
            "flags": 0,
            "hasliked": 0,
            "id": "7tKfRV",
            "likes": 31,
            "name": "Build the Palace",
            "published": 3,
            "tags": [
                "architecture",
                "book",
                "structure"
            ],
            "usePreview": 1,
            "username": "dr2",
            "viewed": 376
        },
        "renderpass": [
            {
                "code": "// \"Build the Palace\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n Minimalist assembly instructions for \"Rector's Palace\" (Xl2yzK).\n Cycle through all pages twice to see everything.\n Mouse overrides paging, view type (inside or outside), orientation (scene or book).\n For monochrome images latest additions are shown in green.\n*/\n\n#define AA  1  // (= 0/1) optional antialiasing (recommended)\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrBoxAn2Df (vec2 p, vec2 b, float w);\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nvec3 HexGrid (vec2 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 StdVuMat (float el, float az);\nfloat Hashfv2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat IFbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDirEx, sunDir, pgSize, qHit;\nvec2 stCent;\nfloat dstFar, tCur, msAz, msEl, dstFarEx, tRead, tpCyc, tpWait, tpBook, phsTurn, idPage,\n   outWd, corWd, flrHt, refSpRad;\nint idObj, bState;\nconst int nPage = 13;\nbool isBw, incBg, isWide;\nconst int idDnFlr = 1, idUpFlr = 2, idRf = 3, idStr = 4, idStWall = 5, idWall = 6, idPil = 7,\n   idBallSt = 8, idBallRf = 9, idCen = 10, idRefSph = 11;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid SetBldParms ()\n{\n  outWd = 20.;\n  corWd = 2.;\n  flrHt = 3.;\n  stCent = vec2 (-16., 2.);\n  refSpRad = 2.1;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq, qqq;\n  vec2 wSz;\n  float dMin, d, a, r, s;\n  dMin = dstFar;\n  qq = p;\n  a = (length (qq.xz) > 0.) ? atan (qq.z, - qq.x) : 0.;\n  qq.xz = Rot2D (qq.xz, 2. * pi * (floor (4. * a / (2. * pi) + 0.5) / 4.));\n  if (bState >= 1) {\n    q = p;\n    d = PrBoxDf (q, vec3 (outWd + 1., 0.2, outWd + 1.));\n    DMINQ (idDnFlr);\n    q = p;\n    q.y -= 0.8;\n    d = PrCylAnDf (q.xzy, 2.4, 0.15, 0.7);\n    DMINQ (idCen);\n  }\n  if (bState >= 2) {\n    q = qq;\n    q.x = abs (abs (q.x) - outWd + corWd) - corWd;\n    q.y -= 2. * flrHt + 0.1;\n    d = PrBox2Df (q.xy, vec2 (0.1, 2. * flrHt));\n    q.yz = mod (q.yz, vec2 (2. * flrHt + 0.2, 2. * corWd)) - vec2 (flrHt + 0.5, corWd);\n    wSz = vec2 (1.7, 1.3);\n    d = SmoothMax (d, - min (min (length (q.yz) - wSz.x, PrBox2Df (vec2 (q.z, q.y + wSz.y), wSz)),\n       PrBoxDf (((qq.x < corWd - outWd) ? vec3 (qq.x + outWd, qq.y - 0.5, abs (qq.z) - 2.) :\n       vec3 (qq.x + outWd - 2. * corWd, q.y + flrHt - 0.1, qq.z + 6.)), vec3 (0.25, 0.5, wSz.x))), 0.01);\n    if (bState == 2) d = max (d, qq.y - 0.25 * flrHt);\n    else if (bState == 3 || bState == 4) d = max (d, qq.y - 2.25 * flrHt);\n    DMINQ (idWall);\n  }\n  if (bState >= 4) {\n    q = qq;\n    q.x = abs (q.x) - outWd + corWd;\n    q.y -= 2. * flrHt + 0.15;\n    d = PrBox2Df (q.xy, vec2 (corWd + 0.2, 0.2));\n    DMINQ (idUpFlr);\n  }\n  if (bState >= 6) {\n    q = p;\n    q.xz = abs (mod (q.xz + corWd, 2. * corWd) - corWd) - 0.1;\n    q.y -= 2. * flrHt + 0.1;\n    d = max (PrCylDf (q.xzy, 0.07, 2. * flrHt), PrBoxAn2Df (p.xz, vec2 (outWd - 2.), 3.));\n    DMINQ (idPil);\n  }\n  if (bState >= 7) {\n    qqq = qq - vec3 (stCent, flrHt + 0.3).xzy;\n    q = qqq;\n    q.xz = Rot2D (q.xz, -0.73 * pi);\n    r = length (q.xz);\n    a = (r > 0.) ? atan (q.z, - q.x) : 0.;\n    q.xz = vec2 (26. * a / (2. * pi), r - 8.);\n    q.xy = Rot2D (q.xy, -0.25 * pi);\n    s = mod (q.x, 0.5 * sqrt (2.));\n    d = max (0.5 * max (q.y + abs (s - 0.25 * sqrt (2.)) - 0.25 * sqrt (2.),\n       max (- q.y - 0.1, abs (q.z) - 1.5)), abs (qqq.y + 0.2) - (flrHt + 0.2));\n    DMINQ (idStr);\n  }\n  if (bState >= 8) {\n    d = max (0.5 * max (abs (q.y - 0.3) - 0.4, abs (abs (q.z) - 1.6) - 0.1),\n       max (max (- qqq.x, qqq.z), - qqq.y - (flrHt + 0.2)));\n    q.x = a;\n    DMINQ (idStWall);\n    q = qq;\n    q.x = abs (q.x + 8.);\n    q -= vec3 (1.6, 0.9, 1.95);\n    d = PrSphDf (q, 0.15);\n    q = qq;\n    q.z = abs (q.z + 6.);\n    q -= vec3 (-15.95, 7.3, 1.6);\n    d = min (d, PrSphDf (q, 0.15));\n    DMINQ (idBallSt);\n  }\n  if (isBw && bState >= 9) {\n    q = p;\n    q.y -= refSpRad;\n    d = PrSphDf (q, refSpRad);\n    DMINQ (idRefSph);\n  }\n  if (bState >= 10) {\n    q = qq;\n    d = dot (vec2 (qq.y, abs (abs (qq.x) - outWd + corWd)), sin (0.15 * pi + vec2 (0.5 * pi, 0.))) -\n       4. * flrHt + (isBw ? 0.01 : 0.02) * sin (4. * pi * qq.z) - 0.2;\n    d = max (max (d, abs (qq.x + outWd - 2.) - 3.), 4. * flrHt + 0.1 - qq.y);\n    DMINQ (idRf);\n    q = p;\n    q.xz = abs (q.xz) - (outWd - corWd);\n    q.y -= 4. * flrHt + 1.8;\n    d = PrSphDf (q, 0.2);\n    DMINQ (idBallRf);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 ObjNfL (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  float s;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  s = dot (v, vec4 (1.));\n  return vec4 (normalize (2. * v.yzw - s), (s - 2. * v.x - 4. * ObjDf (p)) / (e.x * e.x));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 qHitT;\n  float sh, d, h;\n  int idObjT;\n  idObjT = idObj;\n  qHitT = qHit;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  idObj = idObjT;\n  qHit = qHitT;\n  return 0.5 + 0.5 * sh;\n}\n\nfloat Truch (vec2 p)\n{\n  vec2 ip;\n  ip = floor (p);\n  p -= ip + 0.5;\n  if (Hashfv2 (ip) < 0.5) p = vec2 (- p.y, p.x);\n  return min (length (0.5 + p), length (0.5 - p));\n}\n\nvec3 ShGrid (vec2 p, vec2 g, int stag)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (stag > 0 && 2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.02, 0.03, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.07 * pi * smoothstep (0.4, 0.47, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec4 ObjCol (vec3 ro, vec3 rd, inout vec3 vn)\n{\n  vec4 col4;\n  vec3 rg;\n  vec2 vf;\n  float s, w;\n  bool fxz;\n  vf = vec2 (0.);\n  if (idObj == idWall) {\n    col4 = vec4 (0.9, 0.8, 0.7, 0.1);\n    if (abs (qHit.x) < 0.095) {\n      if (! isBw) {\n        col4 *= 0.9;\n        vf = vec2 (64., 1.);\n      }\n    } else if (abs (vn.y) < 0.01) {\n      rg = ro;\n      rg.y = mod (rg.y, 2. * flrHt + 0.2);\n      fxz = (abs (vn.x) > 0.99);\n      rg = ShGrid ((fxz ? rg.zy : rg.xy), vec2 (2., 4.), 1);\n      col4 *= rg.y;\n      if (! isBw) {\n        rg.xz *= sign (fxz ? vn.x : vn.z);\n        if (fxz) {\n          if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n          else vn.xz = Rot2D (vn.xz, rg.x);\n        } else {\n          if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n          else vn.zx = Rot2D (vn.zx, rg.x);\n        }\n        vf = vec2 (32., 1.);\n      }\n    }\n  } else if (idObj == idDnFlr) {\n    col4 = vec4 (0.8, 0.75, 0.7, 0.1);\n    rg = ShGrid (ro.xz, vec2 (1.), 0);\n    s = Maxv2 (abs (ro.xz));\n    w = length (ro.xz) - 2.5;\n    if (w < 0.) col4.rgb *= vec3 (0., 0.4, 0.6);\n    else col4.rgb *= rg.y;\n    if (s > outWd) col4.rg *= 0.95;\n    if (! isBw) {\n      if (vn.y > 0.99) {\n        if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z);\n        else vn.yx = Rot2D (vn.yx, rg.x);\n      }\n      if (w > 0. && s < outWd - 2. * corWd) col4.rg *= 0.8 + 0.1 *\n         smoothstep (0.3, 0.4, length (fract (ro.xz) - 0.5));\n      else if (s < outWd) col4.rgb = mix (col4.rgb, vec3 (0.5, 0.5, 0.8),\n         SmoothBump (0.45, 0.55, 0.02, Truch (ro.xz)));\n      vf = vec2 (64., 0.5);\n    }\n } else if (idObj == idUpFlr) {\n    col4 = vec4 (0.75, 0.65, 0.7, 0.1);\n    rg = ShGrid (ro.xz, vec2 (1.), 0);\n    col4.rgb *= rg.y;\n    if (! isBw) {\n      if (vn.y > 0.99) {\n        if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z);\n        else vn.yx = Rot2D (vn.yx, rg.x);\n        if (abs (Maxv2 (abs (ro.xz)) - outWd + corWd) < corWd) col4.rgb = mix (col4.rgb,\n           vec3 (0.3, 0.7, 0.3), SmoothBump (0.45, 0.55, 0.02, Truch (2. * ro.xz)));\n      }\n      vf = vec2 (64., 0.5);\n    } else {\n      col4.rgb *= 1.1;\n    }\n  } else if (idObj == idRf) {\n    col4 = (vn.y > 0.) ? vec4 (0.8, 0.3, 0., 0.1) : vec4 (0.8, 0.5, 0.4, 0.1);\n    if (! isBw) col4 *= 0.6 + 0.4 * smoothstep (0.03, 0.05, abs (fract (2. * qHit.x + 0.5) - 0.5));\n  } else if (idObj == idStr) {\n    col4 = vec4 (0.8, 0.8, 0.9, 0.1);\n    col4 *= 0.6 + 0.4 * smoothstep (0.03, 0.05, abs (fract (2. * qHit.z + 0.5) - 0.5));\n    if (! isBw) {\n      vf = vec2 (64., 0.5);\n    }\n  } else if (idObj == idStWall) {\n    col4 = vec4 (0.8, 0.8, 0.9, 0.1);\n    rg = ShGrid (qHit.xy - vec2 (0., 0.1), vec2 (20., 5.), 1);\n    col4 *= rg.y;\n    if (! isBw) {\n      if (abs (vn.y) < 0.01) {\n        if (rg.x == 0.) vn = normalize (vec3 (vn.xz, rg.z)).xzy;\n        else vn.xz = Rot2D (vn.xz, - rg.x);\n      }\n      vf = vec2 (32., 1.);\n    }\n  } else if (idObj == idPil) {\n    col4 = vec4 (0.7, 0.7, 0.8, 0.1);\n    if (! isBw) {\n      s = fract (4. * mod (ro.y, 2. * flrHt + 0.2));\n      col4 *= 0.8 + 0.2 * smoothstep (0.03, 0.05, abs (s));\n      vn = normalize (vec3 (vn.xz, -0.3 * (1. - smoothstep (0.05, 0.1, abs (s))) * sign (s))).xzy;\n      vf = vec2 (32., 1.);\n    }\n  } else if (idObj == idBallSt || idObj == idBallRf) {\n    col4 = vec4 (1., 1., 0.1, 0.3);\n  } else if (idObj == idCen) {\n    col4 = vec4 (0.8, 0.9, 0.7, 0.1);\n    rg = ShGrid (vec2 (atan (ro.z, - ro.x) / pi, ro.y + 0.05), vec2 (16., 4.), 1);\n    col4 *= rg.y;\n    if (! isBw) {\n      if (vn.y < 0.01) {\n        if (rg.x == 0.) vn = normalize (vec3 (vn.xz, rg.z)).xzy;\n        else vn.xz = Rot2D (vn.xz, - rg.x);\n      }\n      vf = vec2 (32., 1.);\n    }\n  } else if (idObj == idRefSph) {\n    col4 = vec4 (1., 1., 0.1, 0.3);\n  }\n  if (! isBw && vf.y > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n  return col4;\n}\n\nvec3 GrndCol (vec3 ro, vec3 rd, float dstGrnd, inout vec3 vn)\n{\n  vec3 col, qh;\n  vec2 vf;\n  vn = vec3 (0., 1., 0.);\n  vf = vec2 (0.);\n  if (length (ro.xz) < 50.) {\n    col = vec3 (0.5, 0.5, 0.55);\n    qh = HexGrid (1.5 * ro.xz);\n    vn.yz = Rot2D (vn.yz, 0.5 * max (length (qh.xy) - 0.3, 0.) *\n       (1. - smoothstep (-0.1, -0.05, rd.y)));\n    vn.zx = vn.z * vec2 (qh.x, - qh.y) / length (qh.xy);\n    vf = vec2 (16., 0.5);\n  } else {\n    col = vec3 (0.4, 0.4, 0.3) * (0.85 + 0.15 * smoothstep (0.3, 0.7, Fbm2 (8. * ro.xz)));\n    vf = vec2 (4., 1.);\n  }\n  vf.y *= 1. - smoothstep (0.3, 0.6, dstGrnd / dstFar);\n  if (vf.y > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n  return col;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd, a;\n  a = atan (rd.z, - rd.x) / (2. * pi) + 0.5;\n  if (rd.y > -0.02 && rd.y < 0.02 * mix (IFbm1 (16. * (a + 1.)), IFbm1 (16. * a), a)) {\n    col = vec3 (0.3, 0.35, 0.45);\n  } else {\n    q = 0.02 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec4 SphHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 vn;\n  float b, d, w, dMin;\n  dMin = dstFar;\n  b = dot (rd, ro);\n  w = b * b - dot (ro, ro) + rad * rad;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    if (d > 0.) {\n      dMin = d;\n      vn = (ro + d * rd) / rad;\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, vn4, ds4;\n  vec3 col, vn;\n  float dstObj, dstSph, dstGrnd, sh;\n  bool isNu;\n  dstObj = ObjRay (ro, rd);\n  dstGrnd = dstFar;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    dstObj = ObjRay (ro, rd);\n    if (! isBw) {\n      if (k == 0) {\n        ds4 = SphHit (ro - vec3 (0., refSpRad, 0.), rd, refSpRad);\n        dstSph = ds4.x;\n        if (dstSph < min (dstObj, dstFar)) {\n          ro += dstSph * rd;\n          rd = reflect (rd, ds4.yzw);\n          ro += 0.01 * rd;\n        } else break;\n      }\n    } else break;\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    if (isBw) {\n      vn4 = ObjNfL (ro);\n      vn = vn4.xyz;\n    } else {\n      vn = ObjNf (ro);\n    }\n  } else if (incBg && rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    vn = vec3 (0., 1., 0.);\n  }\n  sh = (incBg && (min (dstObj, dstGrnd) < dstFar || rd.y < 0.)) ?\n     ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n  isNu = false;\n  if (dstObj < dstFar) {\n    col4 = ObjCol (ro, rd, vn);\n    if (isBw) {\n      col = vec3 (1.) * pow (Maxv3 (col4.rgb), 0.7);\n      if (bState == 1) isNu = (idObj == idCen);\n      if (bState == 2 || bState == 3 && ro.y > 0.85 ||\n         bState == 5 && ro.y > 1.05 + 2. * flrHt) isNu = (idObj == idWall);\n      if (bState == 4) isNu = (idObj == idUpFlr);\n      if (bState == 6) isNu = (idObj == idPil);\n      if (bState == 7) isNu = (idObj == idStr);\n      if (bState == 8) isNu = (idObj == idStWall || idObj == idBallSt);\n      if (bState == 9) isNu = (idObj == idRefSph);\n      if (bState == 10) isNu = (idObj == idRf || idObj == idBallRf);\n      if (isNu) col.rb *= 0.2;\n      col *= (1. - 0.5 * smoothstep (0.5, 1., abs (vn4.w) / 64.)) *\n         (0.5 + 0.5 * max (dot (vn, sunDir), 0.));\n    } else {\n      col = col4.rgb * (0.2 + 0.1 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n         0.1 * step (sh, 0.95) * abs (dot (vn, sunDir * normalize (vec3 (-1., 0., -1.)))) +\n         0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n    }\n  } else if (incBg && rd.y < 0.) {\n    col4.rgb = GrndCol (ro, rd, dstGrnd, vn);\n    col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.));\n    col = mix (col, vec3 (0.3, 0.35, 0.45), pow (1. + rd.y, 16.));\n  } else {\n    col = (incBg) ? SkyBgCol (ro, rd) : vec3 (0.7, 0.7, 0.75);\n  }\n  col = clamp (col, 0., 1.);\n  if (! isBw) col = pow (col, vec3 (0.8));\n  return col;\n}\n\nvoid ExMain  (out vec3 fCol, in vec2 fCoord, float asp)\n{\n  mat3 vuMat;\n  vec3 ro, rd;\n  float el, az, zmFac;\n  isBw = (bState < 11);\n  incBg = (bState >= 12);\n  if (! isWide) {\n    el = -0.15 * pi;\n    az = 0.2 * pi;\n    ro = vec3 (0., 1.9, -100.);\n    zmFac = 3.9;\n    fCoord /= zmFac;\n  } else {\n    el = -0.02 * pi;\n    az = 0.;\n    ro = vec3 (0., 3., -16.);\n    zmFac = 1.5;\n    fCoord /= zmFac;\n    fCoord.x = 2. * tan (0.5 * atan (fCoord.x / asp)) * asp;\n  }\n  if (idPage > 0.) {\n    az += (msAz > -999.) ? msAz : 0.;\n    el += (msEl > -999.) ? msEl : 0.;\n    el = clamp (el, -0.4 * pi, -0.02 * pi);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * ro;\n  dstFar = 200.;\n  rd = vuMat * normalize (vec3 (fCoord, 1.));\n  sunDir = normalize (vec3 (1., 3., -1.));\n  SetBldParms ();\n  fCol = ShowScene (ro, rd);\n}\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, rRad, hRad, hOff, np, bc, thFac, nRing, y, s, w;\n  dMin = dstFarEx;\n  rRad = 0.3;\n  hRad = 0.06;\n  nRing = 4.;\n  hOff = 0.15;\n  thFac = 2.2;\n  np = float (nPage - 1);\n  q = p;\n  s = mod (nRing, 2.);\n  w = pgSize.x / nRing;\n  bc = q.x;\n  bc = mod (bc + s * w, 2. * w) - w;\n  for (int k = VAR_ZERO; k < nPage; k ++) {\n    q = p;\n    q.y -= 0.5 * np * thFac * pgSize.y;\n    y = q.y + np * thFac * pgSize.y * phsTurn;\n    if (k == 0) q.zy = Rot2D (vec2 (q.z, y), 2. * pi * phsTurn);\n    else q.y -= thFac * pgSize.y * (phsTurn - float (k));\n    d = hRad - length (vec2 (q.z + rRad, bc));\n    q.z -= - (pgSize.z - hOff + rRad);\n    d = max (PrRoundBoxDf (q, pgSize - pgSize.y, pgSize.y), d);\n    DMINQ (k + 1);\n  }\n  q = p;\n  d = abs (q.x) - pgSize.x;\n  q.x = bc;\n  q = q.zyx;\n  d = max (PrTorusDf (q, 0.8 * hRad, rRad + 0.3 * hRad), d);\n  DMINQ (nPage + 1);\n  return dMin;\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFarEx) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ExObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ExObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ExObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, c, vn;\n  vec2 s, w;\n  float dstObj, sh, npCyc, nDotL, t, asp, d;\n  bool isImg;\n  pgSize = vec3 (3.4, 0.011, 1.7);\n  t = (tpBook < 0.) ? (- tpBook * float (nPage - 1) * (tpCyc + tpWait)) :\n     mod (tpBook - tpWait, tRead);\n  npCyc = mod (floor (t / (tpCyc + tpWait)), float (nPage));\n  phsTurn = min (fract (t / (tpCyc + tpWait)) * (tpCyc + tpWait) / tpCyc, 1.);\n  isImg = false;\n  dstObj = ExObjRay (ro, rd);\n  if (dstObj < dstFarEx) {\n    ro += dstObj * rd;\n    vn = ExObjNf (ro);\n    nDotL = max (dot (vn, ltDirEx), 0.);\n    if (idObj <= nPage) {\n      idPage = mod ((float (idObj - 1) + npCyc), float (nPage));\n      c = vec3 (0.85, 0.85, 0.9) * (0.85 + 0.15 * Fbm2 (8. * qHit.xz));\n      col4 = vec4 (c, 0.2);\n      s = pgSize.xz - abs (qHit.xz);\n      if (qHit.y > 0.) {\n        w = qHit.xz / pgSize.z;\n        if (min (s.x, s.y) > 0.3) {\n          isImg = true;\n          asp = pgSize.x / pgSize.z;\n          if (idPage > 0.) {\n            bState = int (idPage);\n          } else {\n            bState = 12;\n            isWide = (qHit.x < 0.);\n            w -= sign (qHit.x) * vec2 (0.45 * asp, -0.2);\n            if (abs (w.x) > 0.84 || abs (w.y) > 0.37) isImg = false;\n            w *= 2.2;\n          }\n          if (isImg) ExMain (col, w, asp);\n          if (idPage == 0.) {\n            if (fract (tCur) < 0.8) {\n              w -= vec2 (1.7, -0.7);\n              d = min (length (max (abs (w) - vec2 (0.1, 0.002), 0.)),\n                 length (max (abs (Rot2D (vec2 (w.x - 0.1, abs (w.y)), 0.2 * pi)) -\n                 vec2 (0.1, 0.002), 0.)));\n              col = mix (vec3 (0., 1., 0.), col, smoothstep (0., 0.01, length (d)));\n            }\n          }\n        } else if (min (s.x, s.y) > 0.27) {\n          col4 = vec4 (0.6 * c, 0.2);\n        }\n      }\n    } else if (idObj == nPage + 1) {\n      col4 = vec4 (0.95, 0.95, 0.8, 0.2);\n      nDotL *= nDotL;\n    }\n    sh = ExObjSShadow (ro + 0.001 * vn, ltDirEx);\n    if (isImg) col *= 0.2 + 0.8 * sh;\n    else col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDirEx - rd), vn), 0.), 32.);\n  } else {\n    col = vec3 (0.8);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tpBook = max (1.3 * tCur - 0.3, 0.);\n  az = 0.;\n  el = -0.5 * pi;\n  msAz = -999.;\n  msEl = -999.;\n  tpCyc = 3.;\n  tpWait = 4.;\n  tRead = float (nPage) * (tpCyc + tpWait);\n  isWide = (mod (tpBook - tpWait, 2. * tRead) > tRead);\n  if (mPtr.z > 0.) {\n    if (abs (mPtr.y) > 0.4) {\n      tpBook = - clamp (1.05 * mPtr.x + 0.45, 0., 1.);\n      isWide = (mPtr.y > 0.);\n    } else if (abs (mPtr.x) > 0.45) {\n      el += pi * mPtr.y * smoothstep (0.1, 0.15, abs (mPtr.y));\n    } else if (abs (mPtr.x) < 0.42 && abs (mPtr.y + 0.05) < 0.35) {\n      msAz = pi * clamp (mPtr.x / 0.4, -1., 1.);\n      msEl = pi * mPtr.y;\n    }\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0., -1.65, -19.);\n  zmFac = 9.;\n  dstFarEx = 40.;\n  ltDirEx = normalize (vec3 (1., 1., -0.3));\n  ro = vuMat * ro;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ExShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBoxAn2Df (vec2 p, vec2 b, float w)\n{\n  return max (PrBox2Df (p, vec2 (b + w)), - PrBox2Df (p, vec2 (b - w)));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HexGrid (vec2 p)\n{\n  vec2 q;\n  p -= HexToPix (PixToHex (p));\n  q = abs (p);\n  return vec3 (p, (sqrt3/2.) - q.x + 0.5 * min (q.x - sqrt3 * q.y, 0.));\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat IFbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 10.;\n  for (int j = 0; j < 3; j ++) {\n    f += floor (a * Noiseff (p));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / (1.75 * a));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}