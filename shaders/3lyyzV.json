{
    "Shader": {
        "info": {
            "date": "1611319261",
            "description": " Alternative space filling curve to morton and hilbert that apparently falls between them for both computational cost and clustering \n\n https://www2.cs.arizona.edu/~bkmoon/papers/tkde-hilbert.pdf\n",
            "flags": 0,
            "hasliked": 0,
            "id": "3lyyzV",
            "likes": 2,
            "name": "Inverse Gray Coded Curve",
            "published": 3,
            "tags": [
                "2d",
                "inverse",
                "graycode",
                "morton"
            ],
            "usePreview": 0,
            "username": "Dain",
            "viewed": 303
        },
        "renderpass": [
            {
                "code": "//Started from iq \" Inverse Morton and Hilbert\": https://www.shadertoy.com/view/XdlcWr\n\n\n//https://www2.cs.arizona.edu/~bkmoon/papers/tkde-hilbert.pdf\n//This paper compares morton , hilbert and something called gray coded curve: \n//It claims the gray coded curve is better at clustering than morton  order for 3D, but worse than hilbert\n//It didn't really clarify what the gray coded curve was exactly but after fiddling with gray coding this appears to be the same as the curve in the paper\n\n//There is an ugly worm that traces it see the steps\n\n// 0 = Hilbert\n// 1 = Morton\n#define CURVE 1\n\nconst int level = 4;  // Number of points is 2^level in each dimension\n\nint GrayToBinary32(int num){\n\t\tnum ^= num >> 16;\n\t\tnum ^= num >> 8;\n\t\tnum ^= num >> 4;\n\t\tnum ^= num >> 2;\n\t\tnum ^= num >> 1;\n\t\treturn num;\n}\n\nivec2 curve( int i )\n{\n    ivec2 res = ivec2(0,0);\n    \n    i = GrayToBinary32(i);\n    for( int k=0; k<level; k++ )\n    {\n        #if CURVE==0\n        // inverse Hilbert, https://en.wikipedia.org/wiki/Hilbert_curve\n        ivec2 r = ivec2( i>>1, i^(i>>1) ) & 1;\n        if (r.y==0) { if(r.x==1) { res = (1<<k)-1-res; } res = res.yx; }\n        #else\n\t\t// inverse Morton, https://iquilezles.org/articles/wavelet\n        ivec2 r = ivec2( i, i>>1 ) & 1;\n        #endif\n        \n        res += r<<k;\n        i >>= 2;\n    }\n   // res.x = GrayToBinary32(res.x);\n   // res.y = GrayToBinary32(res.y);\n    return res;\n}\n\n\nfloat sdSqLine( in vec2 p, in vec2 a, in vec2 b, out float outH )\n{\n\tvec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    outH = h;\n    vec2 d = pa - ba*h;\n    return dot(d,d);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = 1.0/iResolution.y; // size of a pixel\n    vec2 p = (fragCoord - vec2(0.25*iResolution.x,0.0))*e;\n    \n    p = -0.05 + (1.0+2.0*0.05)*p; // add margin of 0.05\n    \n    const int numPoints = 1<<(level<<1);\n    const float w = float((1<<level)-1); // distance between grid points\n\n    // compute distance field\n    float d = 2.0;\n    ivec2 o = ivec2(0,0);\n    float nearI = -1.0;\n    for( int i=1; i<numPoints; i++ )\n    {\n        ivec2 m = curve(i);\n        \n        float oldD = d;\n        float oH;\n        d = min( d, sdSqLine( p, vec2(m)/w, vec2(o)/w, oH));\n        if(d != oldD){\n          nearI = float(i)+(1.0-oH);\n        }\n        o = m;\n    }\n    d = sqrt(d);\n    \n    // colors\n    float f  = smoothstep(0.0,2.0*e,d); \n          f *= 0.8 + 0.2*sqrt(clamp(d/(8.0*e),0.0,1.0));\n     \n    // float k = sin(float(nearI)+iTime);\n   //  if(d >0.01){\n   //  k = 0.0;\n    // }\n    //make ugly worm follow it\n     float k2 = 0.0;\n    if((abs(nearI-iTime)) < .25 && d<0.015){\n      k2 = .5;\n    }\n    fragColor = vec4( f , max(f- k2,0.0), f, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}