{
    "Shader": {
        "info": {
            "date": "1647630322",
            "description": "sound rudo hex",
            "flags": 8,
            "hasliked": 0,
            "id": "flXcz7",
            "likes": 3,
            "name": "sound rudo hex",
            "published": 3,
            "tags": [
                "soundrudohex"
            ],
            "usePreview": 0,
            "username": "jorge2017a2",
            "viewed": 253
        },
        "renderpass": [
            {
                "code": "//por jorge2017a2\n\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(8.0*antialiasing(2.0),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0)); return colOut;}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\n\nconst vec2 s = vec2(1, 1.7320508);\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n\nvec3 RepetirHex(vec2 p,vec3 col)\n{\n  p=p.yx;\n  vec2 p1=p;\n  vec2 p2=p-vec2(0.0,2.0); //doble posicion\n  p1.y= opRep1D(p1.y, 4.0 );  ///posx\n  p2.y= opRep1D(p2.y, 4.0 ); ///en pos x\n  \n  float d1= sdHexagon(p1,1.0 );\n  \n  float d2=sdHexagon(p2,1.0 );\n  col= DrawFigBorde(vec3(0.3), col, d1 );\n  col= DrawFigBorde(vec3(0.5), col, d2 );\n  \nreturn col;\n}\n\nvec3 hacerHex(vec2 uv, vec3 col)\n{\n    vec2 uv1=uv;\n    vec2 uv2=uv-vec2(1.0,1.75);\n    vec2 uv3=uv-vec2(2.0,3.5);\n    float t=3.25;\n    uv1.y= opRep1D(uv1.y,t);\n    uv2.y= opRep1D(uv2.y,t);\n    uv3.y= opRep1D(uv3.y,t);\n    \n    col= RepetirHex(uv1,col);\n    col= RepetirHex(uv2,col);\n    return col;    \n}    \n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=8.0;\n    uv*=esc;\n    vec2 uv0=uv;\n    vec3 col=vec3(1.0);\n    \n    \n     //picture and picture\n    if (uv.x>0.0 && uv.x < 8.0 &&  uv.y>0.0 && uv.y < 8.0 )\n    {\n        float t=iTime*5.0;\n        uv+=iTime*2.0;\n        uv-=vec2(-0.5+2.5*sin(t),-0.25);\n        uv*= 0.5+sin(t*0.25);\n        col= hacerHex(uv, col);\n        col*=vec3(1.0,0.1,0.2);\n    }\n    else\n    {  uv= rotatev2(uv, radians( iTime)*20.0);\n       col= hacerHex(uv, col);\n    }\n    \n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//modificado por jorge2017a2\n//18-mar-2022\n//referencia\n//Created by mememaestro in 2015-10-15\n//https://www.shadertoy.com/view/llBSzK\n\nconst float trt = 1.0594630943592952645;\nconst float bpm = 140.0;\n\nfloat note2freq(float note) \n{ return 440.0 * pow(trt,note); }\n\nfloat sawWave(float time, float freq, float amp) {\n \t   return mod(time,1.0/freq)*freq*amp;\n}\n\nvec2 bassSynth(float time, float tempo,float note) \n{ return vec2(sawWave(time, note2freq(note), exp(-0.0*mod(tempo, 0.5)))); }\n\nvec2 leadSynth(float time, float tempo,float note, float ampMask)\n{  return vec2(sawWave(time, note2freq(note+0.01), ampMask * exp(-1.0*mod(tempo, 0.5))),\n                sawWave(time, note2freq(note-0.01), ampMask * exp(-1.0*mod(tempo, 0.5))));\n}\n\nvec2 kickSynth(float time, float tempo) {\n    const float dist = 3.0;\n    tempo = mod(tempo,1.0); \n    return vec2(clamp(sin(pow((tempo+0.2)*0.0001,-0.5))*exp(-3.0*tempo),-(1.0/dist),(1.0/dist)) * dist);\n}\n\nfloat rand(vec2 co){return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 clapSynth(float time, float tempo,float ampMask) {\n    return vec2(rand(vec2(time+1.2,tempo+6.1)) * ampMask * exp(-1.5*tempo),\n                rand(vec2(time+2.1,tempo+1.6)) * ampMask * exp(-1.5*tempo));\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    float t = time;\n    float tempo = t * (bpm/60.0);\n    \n    float m = floor(mod(tempo/2.0,10.0)); //minim number\n    float note = floor(mod(tempo*2.0,2.0)) * 12.0 - 35.0 +\n        float(m >= 4.0  && m < 6.5) * (5.0 +2.0*(m-5.0)+ (m-4.0) * 2.0) ;\n        \n    float note2 = floor(mod(tempo*2.0,2.0)) * 6.0 - 30.0 +\n        float(m >= 4.0  && m < 6.5) * (5.0 + (m-3.0) * 2.0) ;\n    \n    vec2 bass, lead;\n    float m1= floor(mod(tempo/2.0,12.0)); \n    \n    if (m1<m)\n    {\n    \n     bass=bassSynth(t, tempo,note2)*0.30;\n     lead = leadSynth(t*1.005,tempo,note2,1.0) * 0.333;\n    }\n    \n    else\n    \n    {\n     bass=bassSynth(t, tempo,note)*0.30;\n     lead = leadSynth(t*1.005,tempo,note,1.0) * 0.333;\n    }\n    \n    vec2 kick = kickSynth(t,tempo) * 0.233;\n    \n    float q = floor(mod(tempo*2.0,32.0)); //quaver number;\n    float b = floor(q/8.0);//bar number\n    float qb = mod(q,8.0); //quaver in bar;\n    float ampMask = float((qb >= 2.0 && qb < 4.0) || (qb >= 6.0 && qb < 7.0)\n                         || (b == 3.0 && (qb == 1.0 || qb >= 5.0))); \n    if (t>10.0 && t<30.0 )\n    tempo = mod(tempo*4.0 ,2.0);\n    else\n    tempo = mod(tempo*0.5 ,4.0);\n    vec2 clap = clapSynth(t,tempo,ampMask) * 0.333;\n    \n   \n    \n    vec2 synths = bass + lead; //sidechain\n    synths *= min(mod(tempo,1.0)+0.4,1.0);\n    return synths + kick+clap*2.0;\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}