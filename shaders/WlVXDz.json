{
    "Shader": {
        "info": {
            "date": "1582554073",
            "description": "2d",
            "flags": 0,
            "hasliked": 0,
            "id": "WlVXDz",
            "likes": 3,
            "name": "GridCircs",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "Arseny",
            "viewed": 428
        },
        "renderpass": [
            {
                "code": "#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pi acos(-1.)\n\nfloat circDist(vec2 cent, float r, vec2 pxpos){\n    return length(cent - pxpos) - r;\n}\n\nvec3 makeLine(vec2 A, vec2 B){\n    vec3 ans;\n    ans.x = A.y - B.y;\n    ans.y = B.x - A.x;\n    ans.z = -(ans.x * A.x + ans.y * A.y);\n    return ans;\n}\n\nvec2 lineIntersection(vec3 A, vec3 B){\n    return \n        vec2(\n            (B.z * A.y - A.z * B.y) / (A.x * B.y - B.x * A.y), \n            (B.z * A.x - A.z * B.x) / -(A.x * B.y - B.x * A.y) \n        );\n}\n\nfloat lineDist(vec3 L, vec2 A){\n    return (L.x * A.x + L.y * A.y + L.z) / sqrt(L.x * L.x + L.y * L.y);\n}\n\nvec2 circCent(vec2 A, vec2 B, vec2 C){\n    float dst = lineDist(makeLine(A, B), C);\n    dst = floor(dst / 0.0001) * 0.0001;\n    if (abs(dst + 0.0001) < 0.001){\n        dst += 0.0001;\n        return (A + B) / 2. + normalize((B - A)) * rot(pi / 2.) * sign(dst) * 100.;\n    }\n    return lineIntersection(\n        makeLine((A + B) / 2., (A + B) / 2. + (B - A) * rot(pi / 2.)), \n        makeLine((C + B) / 2., (C + B) / 2. + (B - C) * rot(pi / 2.))\n    );\n}\n\nfloat circDist(vec2 A, vec2 B, vec2 C, vec2 pxpos){\n   \tvec2 cen = circCent(A, B, C);\n    return circDist(cen, length(A - cen), pxpos) * sign(lineDist(makeLine(A, B), C));\n}\n\nfloat rand(float x){\n    x += 0.0007;\n    x = floor(x / 0.001) * 0.001;\n    return fract(sin(x) * 43758.553);\n}\n\nfloat rand_func(float x, float seed){ // from 0 to 1\n    const float freq = 20.;\n    float block = floor(x * freq);\n    float A = rand(block + seed);\n    float B = rand(block + 1. + seed);\n    return mix(A, B, x * freq - block);\n}\n\nfloat thisrand(vec2 v, float seed){\n    return rand_func(rand_func(v.x, v.y), seed);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n\n    // Time varying pixel color\n    col.xy = uv.xy;\n    float cellsz = 0.1;\n    vec2 gv = (fract(uv / cellsz) - 0.5) * 2.;\n    vec2 fv = floor(uv / cellsz);\n    col.xy = gv;\n    col.xy = vec2(0.);\n    if ((fv.x + fv.y) / 2. - floor((fv.x + fv.y) / 2.) < 0.01){\n        float sgn = 1.;\n        float lastsgn = 1.;\n        vec2 lastcent = vec2(1., -1.);\n        //if (rand(fv.x) + rand(fv.y) + 2. * rand(floor(iTime)) < 2.){\n        if (thisrand(fv, floor(iTime)) < 0.5){\n            //cent = vec2(-1., 1.);\n            sgn = -1.;\n        }\n        //if (rand(fv.x) + rand(fv.y) + 2. * rand(floor(iTime - 1.)) < 2.){\n        if (thisrand(fv, floor(iTime - 1.)) < 0.5){\n            //cent = vec2(-1., 1.);\n            lastsgn = -1.;\n        }\n        float num = 2. * inversesqrt(2.) - 1.;\n        float nowsgn = mix(lastsgn, sgn, fract(iTime));\n        col.r = 1. - smoothstep(\n            -0.1,\n            0.1,\n           \t\t\n                circDist(\n                    vec2(1., 1.), \n                    vec2(-num * nowsgn, num * nowsgn), \n                    vec2(-1., -1.),\n                    //vec2(1., -1.),\n                    //cent,\n                    //2.,\n                    gv\n                )\n            \n        );\n        float anothermul = (mod(fv.x, 2.) - 0.5) * 2.;\n        if (anothermul > 0.){\n            col.r = 1. - col.r;\n        }\n        //col.b = 1.;\n        //col.rg = gv+1.;\n    } else {\n        float sgn = 1.;\n        float lastsgn = 1.;\n        vec2 lastcent = vec2(1., -1.);\n        //if (rand(fv.x) + rand(fv.y) + 2. * rand(floor(iTime)) < 2.){\n        if (thisrand(fv, floor(iTime)) < 0.5){\n            //cent = vec2(-1., 1.);\n            sgn = -1.;\n        }\n        //if (rand(fv.x) + rand(fv.y) + 2. * rand(floor(iTime - 1.)) < 2.){\n        if (thisrand(fv, floor(iTime - 1.)) < 0.5){\n            //cent = vec2(-1., 1.);\n            lastsgn = -1.;\n        }\n        float num = 2. * inversesqrt(2.) - 1.;\n        float nowsgn = mix(lastsgn, sgn, fract(iTime));\n        col.r = 1. - smoothstep(\n            -0.1,\n            0.1,\n           \t\n                circDist(\n                    vec2(-1., 1.), \n                    vec2(num * nowsgn, num * nowsgn), \n                    vec2(1., -1.),\n                    //vec2(1., -1.),\n                    //cent,\n                    //2.,\n                    gv\n                )\n            \n        );\n        float anothermul = (mod(fv.x, 2.) - 0.5) * 2.;\n        if (anothermul > 0.){\n            col.r = 1. - col.r;\n        }\n        //col.g = 1.;\n    }\n    /*if (length(uv) < 0.01){\n        col = vec3(1.);\n    }*/\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}