{
    "Shader": {
        "info": {
            "date": "1713229175",
            "description": "Testing out VR stuff again / totally chokes the Quest 3 stand-alone.. Anyone know of a good VR browser for Steam? There used to be Supermedium but I don't see that anymore?",
            "flags": 1,
            "hasliked": 0,
            "id": "MfKGDG",
            "likes": 17,
            "name": "Gyroid VR",
            "published": 3,
            "tags": [
                "vr"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 233
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Gyroid VR test\n    04/16/2024  @byt3_m3chanic\n    \n    Playing with the VR mode in shadertoy.\n    Best using Rift or other PC based system.\n    totally chokes the Quest 3 stand-alone.\n    \n    Anyone know of a good VR browser for Steam? \n    There used to be Supermedium but I don't \n    see that anymore?\n*/\n\n#define R        iResolution\n#define M        iMouse\n#define T        iTime\n\n#define PI  \t 3.1415926\n#define PI2 \t 6.2831853\n\n#define MAX_DIST 40.\n#define MIN_DIST 1e-3\n\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n//iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mouse(inout vec3 ro) {\n    float x = M.xy == vec2(0) || M.z < 0. ? -.7  : (M.y/R.y * .5 - .25) * PI2;\n    float y = M.xy == vec2(0) || M.z < 0. ? -.25 : (M.x/R.x *.5 - .25) * PI2;\n    ro.zy *= rot(x), ro.zx *= rot(y);\n}\n\nfloat sdGry(vec3 p, float s, float t, float b) {\n    p *= s;\n    float g = abs(dot(sin(p*1.15), cos(p.zxy))-b)/(s*1.15)-t;\n    return g*.9;\n}\n\nfloat g1,g2,g4,speed;\nvec3 hitPoint;\n\nvec2 map(vec3 p) {    \n    vec2 res=vec2(1e5,0.);\n\n    p.z += speed;\n    p.y -= .3;\n\n\tg1 = sdGry(p, 3.5, .025, .85);\n    g2 = sdGry(p, 16.5, .01, .2);\n    g4 = sdGry(p, 12.3, .03, .2);\n\n    g1 += (g2 *.75);\n    g1 = max(g1,g2);\n    g1 -= (g4 *.1);\n\n\n    if(g1<res.x) res=vec2(g1*.5,1.);\n\n    hitPoint = p;\n    return res;\n}\n\n\nvec2 marcher(vec3 ro, vec3 rd) {\n    float mat = 0.;\n    float depth = 0.;\n    for (int i = 0; i<192;i++)\n    {\n     \tvec3 pos = ro + depth * rd;\n        vec2 dist = map(pos);\n        mat = dist.y;\n        if(dist.x<MIN_DIST*depth) break;\n        depth += i<42? dist.x*.25 : dist.x*.8; \n        if(depth>MAX_DIST) break;\n    }\n    return vec2(depth,mat);\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\n// @Shane @iq Compact self-contained \n// version of IQ's 3D value noise function. \nfloat n3D(in vec3 p){\n\tconst vec3 s = vec3(113, 157, 1);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.543), fract(sin(h + s.x)*43758.543), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nvec3 material(vec3 p, vec3 n, float m) {\n    vec3 col = vec3(0);\n\n    float clr = min(n3D(hitPoint*247.)*.5,n3D(hitPoint*135.))*n3D(hitPoint*15.);\n    \n    vec3 lpos = vec3(1.,8,-8.5);\n    vec3 l = normalize(lpos-p);\n\n    float diff = clamp(dot(n,l),0.,1.);\n\n    col = vec3(diff*clr)*.1;\n    float px = 4./R.x;\n    \n    float cks = smoothstep(px,-px,g2+.009);\n    vec3 h = hsv2rgb(vec3(T*.1+p.z*.125,1.,.5))*1.25;\n    if (m==1.) col = mix(col,h,cks);\n    return col;\n}\n\nvec3 camera(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n \nvoid mainImage( out vec4 O, in vec2 F ) {\n    speed = T*.1;\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 col = vec3(0);\n    \n    vec3 lp = vec3(0);\n    vec3 ro = vec3(0,0, -.1);\n    mouse(ro);\n    \n    vec3 rd = camera(uv, ro, lp, 1.);\n    vec2 ray = marcher(ro, rd);\n\n    if(ray.x<MAX_DIST) {\n    \tvec3 p = ro + rd * ray.x;\n   \t\tvec3 n = normal(p, ray.x);\n        float diff = n.y*.5+.5; \n        col = diff * material(p, n, ray.y);\n\n    }\n\n\tcol = mix(col, vec3(0.106,0.106,0.153), 1.-exp(-0.005*ray.x*ray.x*ray.x));\n \n    col = pow(col, vec3(.4545));\n    O = vec4(col,1);\n}\n\n// VR output\nvoid mainVR( out vec4 O, in vec2 F, in vec3 fragRayOri, in vec3 fragRayDir ) {\n    speed = T*.1;\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 col = vec3(0);\n    vec3 ro = fragRayOri;\n    vec3 rd = fragRayDir;\n    \n    vec2 ray = marcher(ro, rd);\n\n    if(ray.x<MAX_DIST) {\n    \tvec3 p = ro + rd * ray.x;\n   \t\tvec3 n = normal(p, ray.x);\n        float diff = n.y*.5+.5; \n        if(ray.y==1.){\n    \t \tcol += diff * material(p, n, ray.y);\n        } \n    }\n\n\tcol = mix( col, vec3(.25,.25,.3), 1.-exp(-0.005*ray.x*ray.x*ray.x));\n\n    col = pow(col, vec3(.4545));\n    O = vec4(col,1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}