{
    "Shader": {
        "info": {
            "date": "1557204496",
            "description": "A simulation of the Ising Model, a simple statistical model which is capable of undergoing phase transitions.\n\nWikipedia: https://en.wikipedia.org/wiki/Ising_model\nBetter source with more theory: https://www.math.arizona.edu/~tgk/541/chap1.pdf",
            "flags": 48,
            "hasliked": 0,
            "id": "tll3zf",
            "likes": 13,
            "name": "The Ising Model",
            "published": 3,
            "tags": [
                "physics",
                "thermodynamics"
            ],
            "usePreview": 0,
            "username": "jumpy89",
            "viewed": 736
        },
        "renderpass": [
            {
                "code": "#define DEBUG_SHOW_GLOBALS 0\n\n// Buffers\n#define SPINBUF iChannel0\n#define STATEBUF iChannel1\n#define CHARBUF iChannel2\n\n\n// Get global state from state buffer\nvec4 getGlobalState(int i)\n{\n    return texelFetch(STATEBUF, ivec2(i, 0), 0);\n}\n\n\nbool inRect(vec2 p, vec2 size)\n{\n    return p.x >= 0. && p.x < size.x && p.y >= 0. && p.y < size.y;\n}\n\n\nvoid drawBar(inout vec3 pixelColor, vec2 xy, vec2 bottomLeft, vec2 size, vec3 color, float value, bool center)\n{\n    vec2 p = xy - bottomLeft;\n    if (!inRect(p, size))\n        return;\n    \n    vec3 color2 = mix(color, vec3(1., 1., 1.), 0.75);\n    \n    if (center)\n    {\n        float y = p.y / size.y * 2. - 1.;\n        if (value >= 0. && y >= 0. && y < value)\n            pixelColor = color;\n        else if(value < 0. && y <= 0. && y > value)\n            pixelColor = color;\n\t\telse\n            pixelColor = color2;\n    } else {\n        if (p.y <= value * size.y)\n            pixelColor = color;\n        else\n            pixelColor = color2;\n    }\n}\n\n// Draw a character\nvoid drawChar(inout vec3 pixelColor, vec2 xy, vec2 bottomLeft, float size, int char, vec3 color)\n{\n    vec2 p = (xy - bottomLeft) / size;\n    if (!inRect(p, vec2(1., 1.)))\n        return;\n    \n    // Row/column in texture\n    ivec2 ij = ivec2(char % 16, 15 - char / 16);\n    \n    // Fetch texture\n    vec2 uv = (p + vec2(ij)) / 16.;\n    vec4 t = texture(CHARBUF, uv);\n    \n    pixelColor = mix(pixelColor, color, t.x);\n}\n\n\n// Draw bar with single character label at bottom\nvoid drawLabeledBar(inout vec3 pixelColor, vec2 xy, vec2 bottomCenter, float barWidth, float totalHeight,\n                    vec3 color, float value, bool center, int label, float labelSize)\n{\n    float barBottom = labelSize * 1.1;\n    vec2 barPos = vec2(bottomCenter.x - barWidth * .5, bottomCenter.y + barBottom);\n    vec2 barSize = vec2(barWidth, totalHeight - barBottom);\n    drawBar(pixelColor, xy, barPos, barSize, color, value, center);\n    \n    vec2 labelPos = vec2(bottomCenter.x - labelSize * 0.5, bottomCenter.y);\n    drawChar(pixelColor, xy, labelPos, labelSize, label, color);\n}\n\nvoid drawBars(inout vec3 pixelColor, vec2 xy)\n{\n    vec4 params = getGlobalState(STATE_PARAMS);\n    \n    float margin = 5.;\n    float barWidth = 10.;\n    float barSpace = 8.;\n    float boxWidth = barWidth * 3. + barSpace * 2. + margin * 2.;\n    float boxHeight = 100.;\n    float labelSize = barWidth * 1.5;\n    float bottom = margin - 0.25 * labelSize;\n    float innerHeight = boxHeight - margin - bottom;\n\n    vec2 boxSize = vec2(boxWidth, boxHeight);\n    //vec2 barSize = vec2(barWidth, 50.);\n    \n    vec2 p = xy - vec2(iResolution.x - boxSize.x - 5., 5.);\n    \n    // background\n    if (inRect(p, boxSize))\n        pixelColor = mix(pixelColor, vec3(.25, .25, .25), .75);\n    \n    float barX = margin + barWidth * 0.5;\n    drawLabeledBar(pixelColor, p, vec2(barX, bottom), barWidth, innerHeight, \n                   vec3(1., 0.5, 0.0), ParamBeta(params) / BETA_RANGE, false, 223, labelSize);\n    \n    barX += barWidth + barSpace;\n    drawLabeledBar(pixelColor, p, vec2(barX, bottom), barWidth, innerHeight,\n                   vec3(0.5, 1., 0.), ParamH(params) / H_RANGE, true, 104, labelSize);\n    \n    barX += barWidth + barSpace;\n    drawLabeledBar(pixelColor, p, vec2(barX, bottom), barWidth, innerHeight,\n                   vec3(0.25, 0.75, 1.), ParamTs(params) / TS_RANGE, false, 116, labelSize);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get state for corresponding site\n    ivec2 site = ivec2(fragCoord) / (SCALE);\n    ivec2 size = ivec2(iResolution.xy) / SCALE;\n    \n    vec4 siteState = texelFetch(SPINBUF, site, 0);\n    float spin = siteState.x;\n    \n    vec3 color = vec3(spin * 0.5 + 0.5);\n    \n    // Invalid spin - happens if resolution not a multiple of scale\n    if (abs(spin) != 1.0)\n        color = vec3(0.);\n    \n    // Show global state buffer values for debugging\n    #if DEBUG_SHOW_GLOBALS\n    ivec2 pixel = ivec2(fragCoord);\n    ivec2 p = pixel / 15;\n    if(p.y < 4)\n    {\n        vec4 state = texelFetch(STATEBUF, ivec2(p.x, 0), 0);\n        if(p.y == 0)\n            color = vec3(state.x);\n        if(p.y == 1)\n            color = vec3(state.y);\n        if(p.y == 2)\n            color = vec3(state.z);\n        if(p.y == 3)\n            color = vec3(state.w);\n    }\n    #endif\n\n    // Parameter meters\n    drawBars(color, fragCoord);\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This many pixels per site\n#define SCALE 1\n\n// Boundary conditions\n#define PERIODIC 1\n#define BOUNDARY_SPIN 0.0\n\n// Pixel positions for various other global state variables in state buffer\n#define STATE_PARAMS 0\n\n// Beta at critical temp\n// = ln(1 + sqrt(2)) / 2\n#define CRITICAL_TEMP 0.44068679351\n\n// Parameter ranges and defaults\n#define BETA_RANGE 1.5\n#define BETA_DEFAULT CRITICAL_TEMP\n#define H_RANGE 1.\n#define H_DEFAULT 0.\n#define TS_RANGE 1.\n#define TS_DEFAULT 1.\n\n// Keys\n#define KEY_RESET_RAND 82\n#define KEY_RESET_UP 85\n#define KEY_RESET_DOWN 68\n#define KEY_RESET_CHECKERBOARD 67\n#define KEY_BETA_INC 221\n#define KEY_BETA_DEC 219\n#define KEY_BETA_RESET 80\n#define KEY_H_INC 222\n#define KEY_H_DEC 186\n#define KEY_H_RESET 76\n#define KEY_TS_INC 191\n#define KEY_TS_DEC 190\n#define KEY_TS_RESET 188\n#define KEY_SET_CRITICAL 84\n\n#define DRAW_RADIUS 10.\n#define DRAW_SPIN 1.0;\n\n\n// Access elements of parameter vector\n// beta, inverse temperature\n#define ParamBeta(params) params.x\n// h, external magnetic field\n#define ParamH(params) params.y\n// e, energy scale\n#define ParamTs(params) params.z\n\n\n\n// https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE .1031\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// Modified from above, random from vec2 and time\n# define HASHITERS 4\nfloat rand(vec2 p, float t)\n{\n    float r = 0.0;\n    for (int i = 0; i < HASHITERS; i++)\n    {\n        float v = float(i+1)*.152;\n        vec2 pos = (p * v + t * 1500. + 50.0);\n        r += hash12(pos);\n    }\n    return fract(r);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// This buffer holds the spin for each site\n// Currently, only the x channel is used to store +/-1 values.\n\n// Buffers\n#define SPINBUF iChannel0\n#define SPINBUFNUM 0\n#define STATEBUF iChannel1\n#define KEYBUF iChannel2\n\n\nbool keyDown(int k)\n{\n    return texelFetch(KEYBUF, ivec2(k, 0), 0).x > 0.0;\n}\n\n// Get site's state vector from site buffer\nvec4 getSiteState(ivec2 site, ivec2 size)\n{\n    #if PERIODIC\n    site.x = site.x % size.x;\n    site.y = site.y % size.y;\n    #else\n    if (site.x < 0 || site.x >= size.x || site.y < 0 || site.y >= size.y)\n        return vec4(BOUNDARY_SPIN, BOUNDARY_SPIN, 0., 0.);\n    #endif\n    return texelFetch(SPINBUF, site, 0);\n}\n\n// Get site's spin in last frame from site buffer\nfloat getSpin(ivec2 site, ivec2 size)\n{\n    vec4 state = getSiteState(site, size);\n    return state.x;\n}\n\n\n// Get global state from state buffer\nvec4 getGlobalState(int i)\n{\n    return texelFetch(STATEBUF, ivec2(i, 0), 0);\n}\n\n\n// Get energy/Hamiltonian contribution of site with up spin\n// Down spin is just the negative of this\nfloat getEnergy(ivec2 site, vec4 params, ivec2 size)\n{\n    // Sum of neighbor spins\n    float neighborSum = getSpin(site + ivec2(-1,  0), size)\n                      + getSpin(site + ivec2( 1,  0), size)\n                      + getSpin(site + ivec2( 0, -1), size)\n                      + getSpin(site + ivec2( 0,  1), size);\n    \n    return -neighborSum - ParamH(params);\n}\n\n\n// Sample from Bernoulli distribution of {-1, 1} with P(1) = p\nfloat sampleSpinBernoulli(float p, float noise)\n{\n    return p > noise ? 1.0 : -1.0;\n}\n\n\nfloat sampleSpinMetropolis(ivec2 site, float noise1, vec4 params, ivec2 size)\n{\n    float currentSpin = getSpin(site, size);\n    \n    \n    // Difference in energy between flipped spin and current\n    float eDiff = 2.0 * getEnergy(site, params, size) * -currentSpin;\n    \n    // Ratio between probability of flipped spin and current\n    float r = exp(-ParamBeta(params) * eDiff);\n    \n    return sampleSpinBernoulli(r, noise1) * -currentSpin;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 site = ivec2(fragCoord);\n    ivec2 size = ivec2(iResolution.xy) / SCALE;\n    \n    if (site.x >= size.x || site.y >= size.y)\n        discard;\n    \n   \t// Fetch parameter values\n    vec4 params = getGlobalState(STATE_PARAMS);\n    \n    // Pseudo-random noise per pixel and frame\n    float noise1 = rand(fragCoord, iTime);\n    float noise2 = rand(fragCoord, iTime + 10.0);\n\n    // Current state of site\n    float currentSpin = getSiteState(site, size).x;\n    bool currentSpinValid = abs(currentSpin) == 1.0;\n    float newSpin;\n    \n    // Random on current state invalid (also on init) or reset random key pressed\n    if (!currentSpinValid || keyDown(KEY_RESET_RAND))\n    {\n    \tnewSpin = sampleSpinBernoulli(.5, noise1);\n\t}\n    // Reset spin up\n    else if(keyDown(KEY_RESET_UP))\n    {\n        newSpin = 1.0;\n    }\n    // Reset spin down\n    else if(keyDown(KEY_RESET_DOWN))\n    {\n        newSpin = -1.0;\n    }\n    // Reset with checkerboard pattern\n    else if(keyDown(KEY_RESET_CHECKERBOARD))\n    {\n        vec2 p = fract(vec2(site.xy) / 100.0);\n        newSpin = (p.x > .5 == p.y > .5) ? 1.0 : -1.0;\n    }\n    // Draw with mouse\n    else if(iMouse.z > 0. && distance(iMouse.xy / float(SCALE), vec2(site)) < DRAW_RADIUS)\n    {\n        newSpin = DRAW_SPIN;\n    }\n    // Metropolis update in checkerboard pattern to avoid updating neighbors simultaneously\n    // Also, stochastically skip updates if time scale is less than 100%\n    else if ((site.x + site.y + iFrame) % 2 == 0 && noise2 < ParamTs(params))\n    {\n    \tnewSpin = sampleSpinMetropolis(site, noise1, params, size);\n    }\n    else\n    {\n        newSpin = currentSpin;\n    }\n    \n    fragColor = vec4(newSpin, 0.0, 0.0, 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This buffer stores global state and handles the logic\n\n// Buffers\n#define STATEBUF iChannel0\n#define KEYBUF iChannel1\n\n\n// Get global state from state buffer\nvec4 getGlobalState(int i)\n{\n    return texelFetch(STATEBUF, ivec2(i, 0), 0);\n}\n\n\nbool keyDown(int k)\n{\n    return texelFetch(KEYBUF, ivec2(k, 0), 0).x > 0.0;\n}\n\nfloat changeParam(float value, float minVal, float maxVal, float defaultVal, int incKey, int decKey, int resetKey)\n{\n    float delta = (maxVal - minVal) * iTimeDelta * .5;\n    if (keyDown(incKey))\n        value += delta;\n    if (keyDown(decKey))\n        value -= delta;\n    if (keyDown(resetKey))\n        value = defaultVal;\n    return clamp(value, minVal, maxVal);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Storage on first row only\n    if(fragCoord.y >= 1.0)\n        discard;\n\n    int i = int(fragCoord.x);\n\n    // Get current value\n    vec4 state = getGlobalState(i);\n    \n    // Check initialized state\n    bool initialized = iFrame > 1;\n\n    // Parameter values\n    if (i == STATE_PARAMS)\n    {\n        // Initial values\n        if(!initialized)\n        {\n            ParamBeta(state) = BETA_DEFAULT; // beta, inverse temperature\n            ParamH(state) = H_DEFAULT; // h, external magnetic field\n            ParamTs(state) = TS_DEFAULT;\n        }\n        \n        float beta = ParamBeta(state), h = ParamH(state), ts = ParamTs(state);\n        \n        // Modify parameters\n        ParamBeta(state) = changeParam(beta, 0., BETA_RANGE, BETA_DEFAULT,\n                                           KEY_BETA_INC, KEY_BETA_DEC, KEY_BETA_RESET);\n        ParamH(state) = changeParam(h, -H_RANGE, H_RANGE, H_DEFAULT,\n                                        KEY_H_INC, KEY_H_DEC, KEY_H_RESET);\n        ParamTs(state) = changeParam(ts, 0., TS_RANGE, TS_DEFAULT,\n                                        KEY_TS_INC, KEY_TS_DEC, KEY_TS_RESET);\n        \n        // Set critical temperature\n        if (keyDown(KEY_SET_CRITICAL))\n        {\n            ParamH(state) = 0.;\n            ParamBeta(state) = CRITICAL_TEMP;\n        }\n        \n        fragColor = state;\n    }\n    \n    else\n        discard;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}