{
    "Shader": {
        "info": {
            "date": "1593290927",
            "description": "potato",
            "flags": 0,
            "hasliked": 0,
            "id": "3tsyWf",
            "likes": 19,
            "name": "Day 190",
            "published": 3,
            "tags": [
                "mograph",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 564
        },
        "renderpass": [
            {
                "code": "\n// Super awesome bayered motion blur from yx https://www.shadertoy.com/view/wsfcWX\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\n#define motionBlurSteps 10 + min(0,iFrame)\n\n#define moblur\n\n#define tri(j) asin(sin(j))\n\n#define timeStep (1./50.)\n\nfloat bayer8(ivec2 uv)\n{   \n    uv %= 8;\n\treturn texelFetch(iChannel1,uv,0).r;\n}\n\n\n// from iq\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\nfloat sdBox( in vec4 p, in vec4 q )\n{\n    p = abs(p) - q;\n    return max(p.y,max(p.x,max(p.z,p.w)));\n}\n\n#define pmod(p,j) mod(p - 0.5*(j),(j)) - 0.5*(j)\n\n\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n\nconst float speed = 0.28;\nfloat[] scenes = float[11](4.2*speed,4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 1.2*speed, 1.2*speed); \n\nfloat sumScenes (float cnt){\n\tfloat sum = 0.;\n    for(float i = 0.; i <= cnt; i++){\n    \tsum += scenes[int(i)];\n    }\n    return sum;\n}\n\nfloat ease(float p, float power, float jump, float offs, float end) {\n    float j = p;\n    p *= offs;\n    float r = (1.-cos(pi*p))/2.*jump;\n    r = pow(r, power);\n    r = mix(r, 1., pow(smoothstep(0.,1.,j),end));\n\treturn r;\n}\nfloat eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n// oh no\n#define smease(p,g) ease(p, 1.5, 1.24, 0.76, 1.)\n \n\nvec3 get(vec2 uv, float t){\n\n    vec3 col = vec3(0);\n       \n    float d = 10e6;\n    \n    uv *= 0.85;\n    \n    \n    t += sumScenes(7.)- 0.;\n    \n    t = mod(t, sumScenes(9.)  );\n    \n    vec2 triW = vec2(0.2,0.2)*0.25;\n    \n    float its = 15.;\n    float scene = 0.;\n    \n    vec2 p = uv;\n\n    vec4 q = vec4(p,1,1);\n\n    float dt = 10e5;\n    float dFirst = 10e5;\n\n    for(float i = 0.; i < its; i++){\n        float tsc = i/its*1.5;\n        float enva = eass((t - tsc)/scenes[0]*1.,3.);\n\n        float envb = eass((t - tsc - scenes[0])/scenes[0]*1.,3.);\n\n        float envc = eass((t - tsc - sumScenes(1.))/scenes[0]*1.,3.);\n        float envd = eass((t - tsc - sumScenes(2.))/scenes[0]*1.,3.);\n\n        float enve = eass((t - tsc - sumScenes(3.))/scenes[0]*1.,3.);\n\n        float envf = eass((t - tsc - sumScenes(4.))/scenes[0]*1.,3.);\n\n        float envg = eass((t - tsc - sumScenes(5.))/scenes[0]*1.,3.);\n\n        float envh = eass((t - tsc - sumScenes(6.))/scenes[0]*1.,3.);\n\n        vec2 b = p;\n\n\n        b *= rot(enve*pi*1. );\n        //b = mix(b,abs(b),1.);\n\n        b -= 0.25 - 0.25*enve - 0.25*envh;\n        b.x += 0.5*enva;\n        b.y += 0.5*envb;\n        b.x -= 0.5*envc;\n        b.y -= 0.5*envd;\n        b *= rot(enva*pi/2. + envb*pi/2. + envc*pi/2.   - envh*pi*0. );\n\n        b *= rot(envf*pi/1. - .5*envh*pi );\n\n\n        float itsifs = 1. + envg*1.  - envh*1.;\n        for(float i = 0.; i < itsifs + 1.; i++){\n            vec2 f = abs(b);\n            //b -= 0.01;\n\n            f *= rot(0.25*pi*envd - 0.25*pi*envg);\n            //f *= rot(0.25*pi*envf);\n            \n            b = mix(b,f,smoothstep(0.,1.,itsifs - i));\n\n        }\n\n        b.xy *= rot(tau*i/its/1.*(envg - envh) );\n\n        //b.y -= 0.3;\n        //b.y += 0.2*enva;\n\n        //b.y += sin((i)/1. - t*pi)*0.1;\n        //b.xy *= rot(i*0.4 + iTime/3.);\n\n        float ld = sdBox(b,triW);\n\n        vec2 g = b;\n        ld = min(ld,sdBox(b,vec2(0.0,0.4)));\n        b = abs(b) - vec2(0,0.2);\n        ld = min(ld,sdBox(b,vec2(0.01,0.01)));\n        b = b - vec2(0,0.2);\n        ld = min(ld,sdBox(b,vec2(0.01,0.01)));\n\n        ld = max(ld,-sdBox(g,vec2(0.005,0.05)));\n\n\n        vec4 q = vec4(b,1,1);\n\n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi);\n        q.xy *= rot(0.25*pi);\n\n\n        q = pmod(abs(q),0.04);\n\n        float dbq = sdBox(q,vec4(0.004 + 0.006*envd - envh*0.006));\n\n        float slider = smoothstep(0.,1.,i/its + envd*0.4 - envh*0.4 )*1.;\n\n        if(i == 0.){\n            dFirst = ld;\n\n            dFirst = mix(dFirst,max(ld,dbq),slider);\n\n        } else {\n            //ld = \n            //slider = 0.1;\n\n        }   \n        float ldb = ld;\n        ld = mix(ld,abs(dbq),slider);\n\n        ld = mix(ld,max(ld,ldb),slider);\n\n        dt = min(dt,abs(ld));\n\n        dt = mix(dt, abs(pmod(dt ,0.04 )) ,slider);\n\n\n    }\n    d = min(d,dt); \n    d = min(d,dFirst);\n\n    d = abs(d);\n\n\n    \n    \n    d = abs(d) - 0.001;\n    \n    col = mix(col,vec3(1.),smoothstep(dFdx(uv.x),0.,d));\n    //col = 1. - col;\n    \n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0);\n    \n    float edge = dFdx(uv.x)*1.;\n    \n    \n    #ifdef moblur\n    for (int i = 0; i < motionBlurSteps  ; ++i) {\n        float subsample = bayer8(ivec2(fragCoord));\n        float time = iTime + ((float(i)+subsample)/float(motionBlurSteps)-.5) * timeStep;\n        col += get(uv,time);\n    }\n    col/=float(motionBlurSteps);\n    #else\n    col += get(uv,iTime);\n    #endif\n    //col = clamp(col, 0., 1.);\n    col *= 0.999;\n    \n    //col *= max((1. + 1.*cos(sin(0.25*tau*iTime/(scenes[0] + scenes[1] ))*tau+length(uv)*2.+vec3(4,2.5,1.5)))*1., 0.);\n    //col *= max((1.5 + 1.4*cos(iTime+length(uv)*2.+vec3(1,1.5,1.5)))*1., 0.);\n    \n    //col *= 1. - pow(smoothstep(0.,1.,dot(uv,uv)*0.9),0.9)*1.;\n    \n    //col = 1. - col;\n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}