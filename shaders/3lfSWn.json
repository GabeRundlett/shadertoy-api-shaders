{
    "Shader": {
        "info": {
            "date": "1565558239",
            "description": "bandelbulb test",
            "flags": 16,
            "hasliked": 0,
            "id": "3lfSWn",
            "likes": 1,
            "name": "raymarched mandelbulb test",
            "published": 3,
            "tags": [
                "mandelbulb"
            ],
            "usePreview": 0,
            "username": "dagbrynildsentholander",
            "viewed": 374
        },
        "renderpass": [
            {
                "code": "vec3 lightDir = vec3(1,.5,.2);\nvec3 lightColor = vec3(1., .9, .9)*1.5;\nvec3 ambientLight = vec3(0.1);\n\nfloat mandelbulb(vec3 pos) \n{\n    int Iterations = 16;\n    float Bailout = 20.;\n    float Power = 4.;\n\tvec3 z = pos;\n\tfloat dr = 2.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n        \n\t\tif (r>Bailout) \n            break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos*2.+(sin(iTime/10.)/10.+0.04);\n\t\t\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\nfloat map(vec3 p)\n{\n    return mandelbulb(p);\n\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat delta = 0.001;\n    vec3 x = vec3 (delta, 0.00, 0.00);\n\tvec3 y = vec3 (0.00, delta, 0.00);\n\tvec3 z = vec3 (0.00, 0.00, delta);\n    \n    float val = map(p);\n    vec3 grad = vec3(val - map(p - x), val - map(p - y), val - map(p - z));\n    return normalize(grad);\n}\n\nvec3 fog(vec3 rgb, vec3 cp, vec3 p, vec3 rd)\n{\n    vec3 fogCol = vec3(1.-lightColor)*.2;\n    fogCol += lightColor*clamp(rd.y, -.1, .1)/5.;\n    fogCol += lightColor*clamp(dot(normalize(rd), normalize(lightDir)), -1.0, 1.0)/10.;\n    return mix(rgb, fogCol, clamp(distance(cp, p)/10., 0., 1.));\n}\n\nvec4 march(vec3 p, vec3 rd, float stepcount)\n{\n    float t = 0.;\n    \n    for(float i = 0.; i < stepcount; i++)\n    {\n        float dist = map(p+rd*t);\n        if(dist < .003)\n            return vec4((p+rd*t).xyz, i);\n        else\n            t+=dist;\n    }\n    \n     return vec4((p+rd*t).xyz, stepcount);\n}\n\nvec3 lighting(vec3 p, vec3 n)\n{\n    float shadow = clamp(distance(march(p+n*.01, lightDir, 128.).xyz, p)/5., 0., 1.);\n    return  max(dot(normalize(lightDir), n), 0.0) * lightColor * (shadow) +ambientLight;\n}\n\nvec3 shade(vec4 p)\n{\n    vec3 n = normal(p.xyz);\n    vec3 baseCol = abs(p.xyz)*n;\n    vec3 color=baseCol*lighting(p.xyz,n);\n    color = mix(color, ambientLight*.5, clamp(p.w/128., 0.0, 1.0));\n\n    return color;\n}\n\nconst int KEY_UP = 38;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.x;\n    \n\tvec3 rrot = vec3(iMouse.y/iResolution.y*360.+180., -iMouse.x/iResolution.x*360.+180., 0);\n    vec3 rp = vec3(sin(radians(rrot.y)), sin(radians(rrot.x)), cos(radians(rrot.y)))*4.0;\n    \t\n    vec3 lookdir = normalize(-rp);\n    vec3 lookDirLeft = cross(lookdir, vec3(0, 1., 0));\n    vec3 lookDirUp = cross(lookDirLeft, lookdir);\n    vec3 rd = normalize(lookdir+lookDirLeft*uv.x+lookDirUp*uv.y);\n\n    vec4 marchResult = march(rp, rd, 256.);\n    vec3 col = fog(vec3(1.), rp, rp+rd*100., rd);\n    \n    if(marchResult.w<256.)\n    {    \n        col = shade(marchResult.xyzw); \n    }\n    else\n        col = fog(col, rp, marchResult.xyz, rd);\t\t\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}