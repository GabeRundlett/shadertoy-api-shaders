{
    "Shader": {
        "info": {
            "date": "1570719957",
            "description": "Character Resource:https://www.youtube.com/watch?v=U-BW5CGgLrY\nThe details are quite different. It's gonna take a while to make it looks as same as youtube one.\n\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "WsGGzd",
            "likes": 7,
            "name": "Experiment - Gaze",
            "published": 3,
            "tags": [
                "raymerching"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 404
        },
        "renderpass": [
            {
                "code": "vec4 map(vec3 p){\n    vec3 pref = p;\n    vec2 uv = p.xy;\n    vec2 uvRef = uv;\n    \n    // body\n    vec3 bodyPos = vec3(0.0,-0.2,0.0);\n    float body1 = length(p+bodyPos+vec3(0.0,-0.2,0.0))-0.99;\n    float body1_2 = sdEllipsoid(p+bodyPos+vec3(0.0,0.0,-0.7), vec3(0.55,0.3+sin(iTime)*0.15,0.5));\n    body1 = opSmoothSubtraction(body1_2,body1,0.3);\n    float body2 = sdBox(p+bodyPos+vec3(0.0,0.9,0.0), vec3(0.45,0.1,0.3),0.7);\n    float bdres = opSmoothUnion(body1,body2,0.5);\n    \n    // eye ball\n    float heyeball = length(p+bodyPos+vec3(0.0,-0.2,0.05))-0.92;\n    float eyemoveX = sin(iTime)*0.1;\n    float heyecold = length(uvRef+vec2(eyemoveX,-0.35))-0.35;\n    vec3 heyecol = mix( vec3(1.0), vec3(0.0), 1.0-smoothstep(0.01,0.015,heyecold) );\n    heyecold = length(uvRef+vec2(eyemoveX,-0.35))-0.27;\n    heyecol = mix( heyecol, vec3(0.5,0.3,0.1), 1.0-smoothstep(0.01,0.015,heyecold) );\n    heyecold = length(uvRef+vec2(eyemoveX,-0.35))-0.2;\n    heyecol = mix( heyecol, vec3(0.7,0.5,0.1), 1.0-smoothstep(0.01,0.015,heyecold) );\n    heyecold = length(uvRef+vec2(eyemoveX,-0.35))-0.12;\n    heyecol = mix( heyecol, vec3(0.0), 1.0-smoothstep(0.01,0.015,heyecold) );\n    \n    // body eyeball\n    p.x = abs(p.x);\n    p.x -= 0.65;\n    uvRef.x = abs(uvRef.x);\n    uvRef.x -= 0.1;\n    vec3 beyep = p+bodyPos+vec3(0.0,0.6,-0.85);\n    float beyeball = length(beyep)-0.17;\n    p = pref;\n    \n    eyemoveX = sin(iTime*2.0)*-0.05;\n    float beyecold = length(uvRef+vec2(-0.56+eyemoveX,0.33))-0.06;\n    vec3 beyecol = mix( vec3(1.0), vec3(0.0), 1.0-smoothstep(0.01,0.015,beyecold) );\n    uvRef = uv;\n    \n    // eyelid\n    p.x = abs(p.x);\n    p.x -= 0.65;\n    vec3 eyelidp = p+bodyPos+vec3(0.0,0.6,-0.85);\n    float eyelid = length(eyelidp)-0.18;\n    float eyelidMask = sdBox((eyelidp+vec3(0.0,0.37,0.0))*matRotateX(radians(25.0)), vec3(0.35),0.001);\n    float eyelidres = max(-eyelidMask,eyelid);\n    p = pref;\n    \n    // mouth and teeth\n    vec3 mouthp = p+bodyPos+vec3(0.0,0.8,-0.95);\n    float mouth = sqrt(mouthp.x*mouthp.x+(mouthp.y*mouthp.y*8.5)+(mouthp.z*mouthp.z*0.1))-0.15;\n    \n    vec3 teethp = p+bodyPos+vec3(0.0,0.76,-0.95);\n    float teeth = sdBox(teethp, vec3(0.05,0.025,0.05),0.001);\n    \n    // legs and arms\n    p.x = abs(p.x);\n    p.x -= 0.5;\n    vec3 legp = p+bodyPos+vec3(0.0,2.7,0.1);\n    float leg = sdCapsule(legp,vec3(0.0,0.0,0.0),vec3(0.0,1.0,0.0),0.15);\n    bdres = opSmoothUnion(bdres,leg,0.5);\n    p = pref;\n    \n    p.x = abs(p.x);\n    p.x -= 0.7;\n    vec3 armp = p+bodyPos+vec3(0.0,2.2,-0.5);\n    float arm = sdCapsule(armp,vec3(sin(iTime*6.0)*0.2,0.0,0.0),vec3(0.1,0.8,0.0),0.1);\n    bdres = opSmoothUnion(bdres,arm,0.3);\n    p = pref;\n    \n    // tail\n    vec3 tailp = p+bodyPos+vec3(0.0,2.0,1.1);\n    vec3 tailp2 = p+bodyPos+vec3(0.0,2.3,2.3);\n    float tail = sdCapsule(tailp,vec3(0.0,-0.3,-0.2),vec3(0.0,0.9,0.0),0.3);\n    float tail2 = sqrt(tailp2.x*tailp2.x+(tailp2.y*tailp2.y*1.5)+(tailp2.z*tailp2.z*0.5))-0.65;\n    tail = opSmoothUnion(tail,tail2,0.6);\n    \n    \n    \n    vec4 _body = vec4(vec3(0.9,0.62,0.65),max(bdres,-mouth));\n    vec4 _heyeball = vec4(heyecol,heyeball);\n    vec4 _beyeball = vec4(beyecol,beyeball);\n    vec4 _eyelid = vec4(vec3(0.9,0.62,0.65),eyelidres);\n    vec4 _teeth = vec4(vec3(1.0),teeth);\n    vec4 _tail = vec4(mix(vec3(0.9,0.62,0.65),vec3(-2.99,-2.92,-2.55),(tailp.z*0.1)),tail);\n    vec4 _floor = vec4(vec3(1.0),p.y+2.6);\n    \n    return combine(combine(combine(combine(combine(combine(_body,_heyeball),_beyeball),_eyelid),_teeth),_tail),_floor);\n}\n\nvec3 normalMap(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        map(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n        map(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n        map(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n    ));\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = map(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\n// from simon green and others\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.15;\n\n    float a = 0.0;\n    float weight = 4.;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - map(p + n*d).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 uv = p;\n    \n    float time = iTime*2.0;\n    \n    vec3 ro = vec3( 3.5*cos(0.1*time + 6.0), 0.0, -0.5+5.5*sin(0.1*time + 6.0) );\n    vec3 ta = vec3( 0.0, -0.4, -0.7 );\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    float zoom = 1.5;\n    vec3 rd = ca * normalize( vec3(p.xy,zoom) );\n    \n    float t, dist;\n    float lastDistEval = 1e10;\n    float edge = 0.0;\n    t = 0.0;\n    vec3 distPos = ro+rd;\n    vec4 distCl = vec4(0.0);\n    for(int i = 0; i < 64; i++){\n        distCl = map(distPos);\n        dist = distCl.w;\n        t += dist;\n        distPos = ro+rd*t;\n        \n        if (dist < lastDistEval) lastDistEval = dist;\n        if(dist < 0.01 || dist > 60.0) break;\n    }\n\n    vec3 color;\n    float shadow = 1.0;\n    if(dist < 1.0){\n        // lighting\n        vec3 lightDir = vec3(0.0, 1.0, 0.0);\n        vec3 light = normalize(lightDir + vec3(0.5, 0.0, 0.9));\n        vec3 normal = normalMap(distPos);\n\n        // difuse color\n        float diffuse = clamp(dot(light, normal), 0.6, 1.0);\n        float lambert = max(.0, dot( normal, light));\n        \n        // ambient occlusion\n        float ao = ambientOcclusion(distPos,normal);\n        \n        // shadow\n        shadow = shadowMap(distPos + normal * 0.001, light);\n\n        // result\n        color += vec3(lambert);\n        color = ao*diffuse*(distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n        \n    }else{\n        color =.84*max(mix(vec3(0.9,0.9,0.9)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n    }\n\n    // rendering result\n    float brightness = 1.5;\n    vec3 dst = (color * max(0.8, shadow))*brightness;\n    \n    fragColor = vec4(dst, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define hash(h) fract(sin(h) * 43758.5453123)\n#define PI 3.141592653589793\n\nfloat sdBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))-r\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) {\n        return val1;\n    }\n    return val2;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}