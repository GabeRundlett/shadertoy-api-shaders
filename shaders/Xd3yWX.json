{
    "Shader": {
        "info": {
            "date": "1520364424",
            "description": "Mouse rotates camera, wait about 1000 frames for all the background galaxies. Inspired by [url=https://www.shadertoy.com/view/4llGWl]andregc's shader.[/url] Uses semi-realistic gravitational lensing.",
            "flags": 32,
            "hasliked": 0,
            "id": "Xd3yWX",
            "likes": 14,
            "name": "Cosmic Storm",
            "published": 3,
            "tags": [
                "fluid",
                "volumetric",
                "blackhole",
                "starfield"
            ],
            "usePreview": 0,
            "username": "Ebanflo",
            "viewed": 1359
        },
        "renderpass": [
            {
                "code": "// Cosmic Storm by Eben Kadile aka Ebanflo - 2018\n// eben.cowley42@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//nebula params\n\n#define nebula\n\n#define fbmIters 5\n#define marchingIters 20\n#define cloudBrightness 15.0\n#define rungeKuttaIters 5\n//vector field from https://en.wikipedia.org/wiki/Hopf_fibration#Fluid_mechanics\n#define A 0.75\n#define B 0.45\n\n//blackhole params\n\n#define blackhole\n#define lensing\n\n//4G/c^2 where G is the gravitational constant and c is the speed of light\n#define forGc2 2.970357293242085e-27\n#define blackholeMass 1e26\n#define blackholeRadius 0.5*forGc2*blackholeMass //Schwarschild radius\n\n#define farOffGalaxies\n\nconst float pi = 4.0*atan(1.0);\nconst float isqrt2 = inversesqrt(2.0);\n\nvec4 makeQuat(vec3 axis, float t){\n    t *= 0.5;\n    vec2 tr = sin(vec2(t, t + 0.5*pi));\n    return vec4(tr.x*normalize(axis), tr.y);\n}\n\nvec3 Rotate(vec4 q, vec3 v){\n    vec3 t = 2.*cross(q.xyz, v);\n    return v + q.w*t + cross(q.xyz, t);\n}\n\nvec3 r(vec3 v, vec2 r){\n    vec4 t = sin(vec4(r, r + 1.5707963268));\n    float g = dot(v.yz, t.yw);\n    return vec3(v.x * t.z - g * t.x,\n                v.y * t.w - v.z * t.y,\n                v.x * t.x + g * t.z);\n}\n\n//Thanks knarkowicz\n//https://knarkowicz.wordpress.com/2014/04/16/octahedron-normal-vector-encoding/\nvec2 OctWrap(vec2 v){\n    return vec2((1.0 - abs(v.y))*(v.x >= 0.0 ? 1.0 : -1.0),\n                (1.0 - abs(v.x))*(v.y >= 0.0 ? 1.0 : -1.0));\n}\n \nvec2 encode(vec3 n){\n    n /= ( abs( n.x ) + abs( n.y ) + abs( n.z ) );\n    n.xy = n.z >= 0.0 ? n.xy : OctWrap( n.xy );\n    n.xy = n.xy * 0.5 + 0.5;\n    return n.xy;\n}\n\n//modified Lambert-Azimuthal projection\nvec2 proj(vec3 v){return inversesqrt(.5 * (1.0 + abs(v.z)) * abs(v.xy));}\n\nfloat hash13(vec3 p){\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise3(vec3 x){\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix(hash13(p+vec3(0,0,0)), \n                       hash13(p+vec3(1,0,0)),f.x),\n                   mix(hash13(p+vec3(0,1,0)), \n                       hash13(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix(hash13(p+vec3(0,0,1)), \n                       hash13(p+vec3(1,0,1)),f.x),\n                   mix(hash13(p+vec3(0,1,1)), \n                       hash13(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbm(vec3 pos){\n    float acc = 0.0;\n    float scale = 1.0;\n    for(int n = 0; n < fbmIters; n++){\n        acc += noise3(scale*pos)/scale;\n        scale *= 2.15926535;\n    }\n    return acc;\n}\n\n//distance to inner ring of Hopf fibration (unit circle in xy pllane centered at origin)\nfloat dRing(vec3 p){return length(vec2(length(p.xy) - 1.0, p.y));}\n\nvec3 velocity(vec3 p){\n    float a = dRing(p);\n    float a2 = a*a;\n    float r = dot(p, p);\n    float ar = a2 + r;\n    return A*vec3(2.0*(-a*p.y + p.x*p.z), 2.0*(a*p.x - p.y*p.z), a - r)/(ar*ar);\n}\n\nfloat density(vec3 p){\n    float a = dRing(p);\n    return 3.0*B/(a*a + dot(p, p));\n}\n\nvec2 pressureAndDensity(vec3 p){\n    float d = density(p);\n    return vec2(-A*A*0.333333*d*d*d/(B*B), d);\n}\n\nvec2 logistic(vec2 v){\n    return vec2(16.0/(1.0 + 10.0*exp(-0.75*v.x)),\n                1.0/(1.0 + 10.0*exp(-1.95*v.y)));\n}\n\nvec3 gaussian(float x){\n    vec3 disp = x - vec3(0.3, 0.6, 0.9);\n    return exp(-16.0*disp*disp - 4.0);\n}\n\nvec3 makeColor(vec3 p){\n    vec2 pd = pressureAndDensity(p);\n    pd = logistic(pd);\n    float fn = cloudBrightness*pd.y*fbm(10.0*p);\n    return fn*vec3(1.0, 0.75, 1.0)*gaussian(pd.x);\n}\n\nvec3 approxFlow(vec3 p, float t){\n    t /= float(rungeKuttaIters);\n    for(int i = 0; i < rungeKuttaIters; ++i) {\n        \tvec3 k1 = -velocity(p);\n        \tvec3 k2 = -velocity(p + 0.5*k1*t);\n        \tvec3 k3 = -velocity(p + 0.5*k2*t);\n\t        vec3 k4 = -velocity(p + k3*t);\n    \t    p += 0.161616*t*(k1 + 2.0*k2 + 2.0*k2 + k3);\n    }\n    return p;\n}\n\nvec3 interpolateColor(vec3 p){\n    float t1 = fract(0.5*iTime);\n    float t2 = fract(t1 + 0.5);\n    vec3 c1 = makeColor(approxFlow(p, t1 + 0.3));\n    vec3 c2 = makeColor(approxFlow(p, t2 + 0.3));\n    t1 = 2.0*abs(t1 - 0.5);\n    return mix(c1, c2, t1);\n}\n\nvec3 galaxies(vec3 rd){return texture(iChannel0, encode(rd)).rgb;}\n\nbool iBlackhole(vec3 ro, vec3 rd){\n    float loc = dot(rd, ro);\n    return loc*loc + 2.25*blackholeRadius*blackholeRadius > dot(ro, ro);\n}\n\nfloat dBlackholePlane(vec3 ro, vec3 rd, vec3 n){return -dot(ro, n)/dot(rd, n);}\n\nvec3 render(vec3 ro, vec3 rd){\n\n    vec3 nml = normalize(ro);\n\n    vec3 col = vec3(0);\n    bool hit = iBlackhole(ro, rd);\n    float plane = dBlackholePlane(ro, rd, nml);\n\n    float stepsize = 2.0*plane/float(marchingIters);\n\n    int fstIters = marchingIters/2;\n    #ifdef blackhole\n    if(hit) fstIters = marchingIters/2 - 1; //avoid rendering inside the blackhole\n    #endif\n\n    vec3 pos = ro + stepsize*rd;\n\n    #ifdef nebula\n    //march until the plane containing the blackhole center is reached\n\tfor(int n = 0; n < fstIters; n++){\n        col += interpolateColor(pos);\n        pos += stepsize*rd;\n    }\n    #endif\n    \n    #ifdef lensing\n    //then change direction\n    float r = length(pos);\n    vec3 axis = cross(pos, nml);\n    //angle of deflection is 4MG/(rc^2)\n    float angle = -forGc2*blackholeMass/r;\n    vec4 quaternion = makeQuat(axis, angle);\n    rd = Rotate(quaternion, rd);\n    #endif\n    \n    #ifdef blackhole\n    if(hit) return col;\n    #ifdef nebula\n    else {\n        for(int n = 0; n < marchingIters/2; n++){\n            col += interpolateColor(pos);\n\n            pos += stepsize*rd;\n        }\n    #endif\n        #ifdef farOffGalaxies\n        col += galaxies(rd);\n        #endif\n    }\n    #else\n    for(int n = 0; n < marchingIters/2; n++){\n        col += interpolateColor(pos);\n        pos += stepsize*rd;\n    }\n    #endif\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n\tfragColor = vec4(0.0);\n    vec2 xy = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -0.5*float(marchingIters)*blackholeRadius);\n    vec3 rd = normalize(vec3(xy, 2.5));\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    m *= 2.0;\n    \n    rd = r(rd, m + 0.1*iTime);\n    ro = r(ro, m + 0.1*iTime);\n    fragColor.rgb = render(ro, rd);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Buffer for storing galaxy position and color\n//Thanks knarkowicz for your blogpost octahedral encoding of unit vec3s\n//https://knarkowicz.wordpress.com/2014/04/16/octahedron-normal-vector-encoding/\n\nvec3 decode(vec2 f){\n    f = f * 2.0 - 1.0;\n    vec3 n = vec3(f.x, f.y, 1.0 - abs(f.x) - abs(f.y));\n    float t = clamp(-n.z, 0.0, 1.0);\n    n.x += n.x >= 0.0 ? -t : t;\n    n.y += n.y >= 0.0 ? -t : t;\n    return normalize( n );\n}\n\nvec2 hash21(float p){\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 rand3dunit(float p){//rodolphito's random unit vector fcn\n  vec3 r = hash21(p).xxy * 2.0 + vec3(0.5, 0.0, -1.0);\n  r.xy = sin(r.xy * 3.141592654) * sqrt(1.0 - r.z * r.z);\n  return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    if(iFrame > 30 && iFrame < 1054){\n        vec3 dir = decode(uv);\n        vec3 pos = rand3dunit(float(iFrame));\n\t\tfloat f = dot(dir, pos);\n        vec2 h = hash21(iTime);\n\t\tfragColor.rgb += 0.75*pow(vec3(h.x, h.y, 0.5*(h.x + h.y)),\n                              50000.0 * vec3(.5 + .5 * f));\n    }\n        \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}