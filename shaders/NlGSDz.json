{
    "Shader": {
        "info": {
            "date": "1640455291",
            "description": "In General we write a Geometric Sequence like this:\n\n{ar^0, ar^1, ar^2, ar^3, ... }\n\nSince any number raised to the power of 0 is 1,\nshouldn't geometric sequences of powers\nconverge on 0 be exact numbers?\n\nThis shader is a test of that theory.",
            "flags": 0,
            "hasliked": 0,
            "id": "NlGSDz",
            "likes": 2,
            "name": "Infinite Sequences of Powers",
            "published": 3,
            "tags": [
                "infinite",
                "geometric",
                "of",
                "powers",
                "sequences"
            ],
            "usePreview": 0,
            "username": "zovox",
            "viewed": 255
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n/*\n    Infinite Powers of Geometric Sequences:\n\n    In General we write a Geometric Sequence like this:\n\n    {a, ar, ar2, ar3, ... }\n\n    Since any number raised to the power of 0 is 1,\n    shouldn't geometric sequences of powers\n    converge on exact numbers?\n\n                   0\n               ...^\n           ar2^      = ?\n        ar^\n      a^\n\n    The purpose of this shader is to attempt a\n    brute-force algorithm for visualizing the\n    output of this algorithm. The x-domain\n    is a, r the y, and the output\n    colors on the plane up to n powers that\n    should also approach 0.\n\n    Enjoy!\n*/\n\nfloat geometric_sequence(float a, float r, float n) {\n    return a*pow(r, n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy*3.);\n    const float max_n = 1024.;\n    float delta_n = max_n;//sin(iTime)*.5+.5);\n    \n    float r = uv.y;\n    \n    float last_power = 1.;\n    \n    for(float n = 0.; n < max_n; n += 1.) {\n        if(n > delta_n) break; \n        float power = max_n-n;\n        last_power = pow(geometric_sequence(uv.x, uv.y, power), last_power);\n    }\n    fragColor = vec4(sin(PI*last_power+vec3(0.,PI/3.,4.*PI/3.))*.5+.5, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}