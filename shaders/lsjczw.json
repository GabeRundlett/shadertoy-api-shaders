{
    "Shader": {
        "info": {
            "date": "1491429690",
            "description": "Quadratic bezier tangents. It's meant as a visualization of De Casteljau's Algorithm.\nUses code and ideas from https://www.shadertoy.com/view/XdB3Ww, https://www.shadertoy.com/view/MslXWr and https://www.shadertoy.com/view/XdjXD1\nBest seen in fullscreen",
            "flags": 0,
            "hasliked": 0,
            "id": "lsjczw",
            "likes": 4,
            "name": "Quadratic Bezier tangents",
            "published": 3,
            "tags": [
                "2d",
                "bezier",
                "tangent",
                "casteljau"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 581
        },
        "renderpass": [
            {
                "code": "#define MOVE_CONTROL_POINT\n#define DRAW_LINES\n//#define MOVE_LINE\n//#define NORMALS\n\nconst float pi=3.1415926535;\n\nconst float dot_size=.003;\nconst float num_lines=20.;\n\nconst vec3 bg_col = vec3(1,1,1);\nconst vec3 bezier_col = vec3(0,0,1);\nconst vec3 point_col = vec3(0);\nconst vec3 line_col0 = vec3(1,0,0);\nconst vec3 line_col1 = vec3(0,1,0);\n\nvec2 quad_bezier(float t, vec2 p0, vec2 p1, vec2 p2){\n\treturn mix((mix(p0, p1, t)),(mix(p1, p2, t)), t);\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec3 coeffs, out vec2 roots){\n    float p, q, D;\n\n    // normal form: x^2 + px + q = 0\n\n    p = coeffs[1] / (2. * coeffs[0]);\n    q = coeffs[2] / coeffs[0];\n\n    D = p * p - q;\n\n    if(D < 0.){\n\t\treturn 0;\n    }\n    else if(D > 0.){\n\t\tfloat sqrt_D = sqrt(D);\n\n\t\troots[0] =   sqrt_D - p;\n\t\troots[1] = - sqrt_D - p;\n\t\treturn 2;\n    }\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(float a, float b, float c, out vec3 r){\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0){ // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\n\tr[0] = offset + u * (m + m);\n    r[1] = offset - u * (n + m);\n\tr[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\n\treturn 3;\n}\n\nvec3 quad_bezier_nor_roots(vec2 x, vec2 a, vec2 b, vec2 c, out int n){\n\tvec2 A=b-a;\n\tvec2 B=c-b-A;\n\tvec2 Cx=x-a;\n\n    // Cubic coefficients\n    float cu = -dot(B,B);\n    // Quadratic coefficients\n    float qu = -3.*dot(A,B);\n    // Linear coefficients\n    float li = dot(Cx,B)-2.*dot(A,A);\n    // Constant terms\n    float C = dot(Cx,A);\n\n    vec3 roots;\n    vec4 coeffs = vec4(cu, qu, li, C);\n    \n    //n = solve_cubic(coeffs, roots);  \n    n = solve_cubic(qu/cu,li/cu,C/cu, roots);  \n\n    return roots;\n}\n\nvec2 quad_bezier_tang_roots(vec2 x, vec2 a, vec2 b, vec2 c, out int n){\n\n\tvec2 A=b-a;\n\tvec2 B=c-b-A;\n\n\tvec2 D=vec2(A.y,-A.x);\n\tvec2 E=vec2(B.y,-B.x);\n\n\tvec2 Cx=x-a;\n\n    // Quadratic coefficients\n    float qu = -dot(B,D)-2.*dot(A,E);\n    // Linear coefficients\n    float li = dot(Cx,E);\n    // Constant terms\n    float C = dot(Cx,D);\n\n    vec2 roots=vec2(0);\n    vec3 coeffs = vec3(qu, li, C);\n    \n    n=solve_quadric(coeffs, roots);  \n\n    return vec2(roots);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border = 2./iResolution.x;\n\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\tuv -= .5;\n    uv.y *= iResolution.y/iResolution.x;\n\n\tvec2 mouse = iMouse.xy/iResolution.xy;\n\n\t#ifdef MOVE_CONTROL_POINT\n\tvec2 mouseuv = mouse-.5;\n    mouseuv.y *= iResolution.y/iResolution.x;\n\t#endif\n\n\tvec2 p0 = vec2(-.4,.2);\n\t#ifdef MOVE_CONTROL_POINT\n\tvec2 p1 = mouseuv;\n\t#else\n\tvec2 p1 = vec2(-.3,-.1);\n\t#endif\n\tvec2 p2 = vec2(.2,.15);\n\n\tvec3 color = bg_col;\n\n\tint n_tang_roots = 0;\n\tvec2 tang_roots = quad_bezier_tang_roots(uv,p0,p1,p2,n_tang_roots);\n\n\tint n_nor_roots = 0;\n\tvec3 nor_roots = quad_bezier_nor_roots(uv,p0,p1,p2,n_nor_roots);\n\n\tfloat line_dis = 1e38;\n\tfloat bezier_dis = 1e38;\n\tfloat dot_dis = 1e38;\n\n\t//Draw tangents (or normals) to the curve through current point on screen\n\t#ifdef DRAW_LINES\n\t#ifdef NORMALS\n\tfor(int i=0;i<3;i++){\n\t\tif(i < n_nor_roots){\n\t\t\tfloat t1 = nor_roots[i];\n\t#else\n\tfor(int i=0;i<2;i++){\n\t\tif(i < n_tang_roots){\n\t\t\tfloat t1 = tang_roots[i];\n\t#endif\n\n\t\t\tt1 = clamp(t1,0.,1.);\n\t\t\tt1 = floor(t1*(num_lines-1.)+.5)/(num_lines-1.);\n\n\t\t\tvec2 lp0 = mix(p0,p1,t1);\n\t\t\tvec2 lp1 = mix(p1,p2,t1);\n\n\t\t\tvec2 llp0 = mix(lp0,lp1,t1);\n\n\t\t\tvec2 nor = normalize(lp0-lp1);\n\t\t\tvec3 tang = vec3(nor.y,-nor.x,0);\n\t\t\ttang.z = -dot(llp0,tang.xy);\n\n\t\t\t#ifdef NORMALS\n\t\t\tline_dis = abs(dot(vec3(nor,-dot(llp0,nor)),vec3(uv,1)));\n\t\t\t#else\n\t\t\tline_dis = abs(dot(tang,vec3(uv,1)));\n\t\t\t#endif\n\n\t\t\tvec3 line_col = mix(line_col0,line_col1,t1);\n\t\t\tcolor = mix(line_col,color,smoothstep(0.,border,line_dis));\n\t\t}\n\t}\n\t#endif //DRAW_LINES\n\n\t#ifdef MOVE_LINE\n\tfloat t1 = mouse.x;\n\n\tvec2 lp0 = mix(p0,p1,t1);\n\tvec2 lp1 = mix(p1,p2,t1);\n\n\tvec2 llp0 = mix(lp0,lp1,t1);\n\n\tvec2 nor = normalize(lp0-lp1);\n\tvec3 tang = vec3(nor.y,-nor.x,0);\n\ttang.z = -dot(llp0,tang.xy);\n\n\tline_dis = abs(dot(tang,vec3(uv,1)));\n\n\tvec3 line_col = mix(line_col0,line_col1,t1);\n\tcolor = mix(line_col,color,smoothstep(0.,border,line_dis));\n\n\tnor = normalize(p0-p1);\n\ttang = vec3(nor.y,-nor.x,0);\n\ttang.z = -dot(p0,tang.xy);\n\tline_dis = abs(dot(tang,vec3(uv,1)));\n\tcolor = mix(line_col0,color,smoothstep(0.,border,line_dis));\n\n\tnor = normalize(p2-p1);\n\ttang = vec3(nor.y,-nor.x,0);\n\ttang.z = -dot(p2,tang.xy);\n\tline_dis = abs(dot(tang,vec3(uv,1)));\n\tcolor = mix(line_col1,color,smoothstep(0.,border,line_dis));\n\n\tdot_dis = min(dot_dis,distance(lp0,uv)-dot_size);\n\tdot_dis = min(dot_dis,distance(lp1,uv)-dot_size);\n\tdot_dis = min(dot_dis,distance(llp0,uv)-dot_size);\n\t#endif\n\n\t//Draw bezier curve and the dots on it using the curve's normals through the current point\n\tfor(int i=0;i<3;i++){\n\t\tif(i < n_nor_roots){\n\t\t\tfloat t1 = nor_roots[i];\n\n\t\t\tvec2 rbp = quad_bezier(t1,p0,p1,p2);\n\n\t\t\tbezier_dis = min(bezier_dis,distance(rbp,uv));\n\n\t\t\t#ifdef DRAW_LINES\n\t\t\tt1 = clamp(t1,0.,1.);\n\t\t\tt1 = floor(t1*(num_lines-1.)+.5)/(num_lines-1.);\n\n\t\t\tvec2 cbp = quad_bezier(t1,p0,p1,p2);\n\n\t\t\tdot_dis = min(dot_dis,distance(cbp,uv)-dot_size);\n\t\t\t#endif\n\t\t}\n\t}\n\n\tcolor = mix(bezier_col,color,smoothstep(0.,border,bezier_dis));\n\n\tdot_dis = min(dot_dis,distance(p0,uv)-dot_size);\n\tdot_dis = min(dot_dis,distance(p1,uv)-dot_size);\n\tdot_dis = min(dot_dis,distance(p2,uv)-dot_size);\n\n\tcolor = mix(point_col,color,smoothstep(0.,border,dot_dis));\n\n\tfragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}