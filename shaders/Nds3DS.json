{
    "Shader": {
        "info": {
            "date": "1616472358",
            "description": "made in 1 day for weekly #willstallchallenge",
            "flags": 32,
            "hasliked": 0,
            "id": "Nds3DS",
            "likes": 31,
            "name": "Lofi gif background loop",
            "published": 3,
            "tags": [
                "reflection",
                "clouds",
                "sky",
                "city",
                "gif",
                "lofi",
                "street",
                "nft",
                "willstall"
            ],
            "usePreview": 1,
            "username": "TheNosiriN",
            "viewed": 758
        },
        "renderpass": [
            {
                "code": "//made by TheNosiriN\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/R;\n    #ifdef MARGIN\n    if(uv.x < marginSize || uv.x > 1.0-marginSize){ fragColor = vec4(0.0); return; }\n    #endif\n    \n    float size = 3.0;\n    vec3 color;\n    vec4 tex = texture(iChannel0, uv);\n    \n    float smp = 0.;\n    for (float i=-size; i<=size; i++){\n        for (float j=-size; j<=size; j++)\n        {\n            //(fragCoord+vec2(i,j)/size)/iResolution.xy //hmm...\n            //some chroma\n            color.r += texture(iChannel0, uv+(vec2(i,j))/720./size).r;\n            color.g += texture(iChannel0, uv+(vec2(i,j)*4.0)/720./size).g;\n            color.b += texture(iChannel0, uv+(vec2(i,j)*8.0)/720./size).b;\n            smp++;\n        }\n    }\n    color /= smp;\n    //color = tex.rgb; //remove blur stuffs\n    \n    color = smoothstep(0.,1.,color);\n    //color = sqrt(color);\n    \n    fragColor = vec4(color, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n// pow for vibrance\nconst vec3 purple = vec3(1.000,0.455,0.745);\nconst vec3 purple2 = pow(vec3(0.353,0.255,0.576), vec3(1.5))*2.;\nconst vec3 suncol = vec3(1.000,0.522,0.008);\nconst vec3 yellow = pow(vec3(1.000,0.741,0.333), vec3(3))*3.;\n//\n\n\n\n\n\nvec2 street(vec3 p)\n{\n    p.x += TIME*8.0;\n    \n    //fence\n    vec3 p1 = p;\n    p1.y += 20.9;\n    p1.z -= 30.;\n    \n    vec2 qf = abs(p1.yz+vec2(0.1,0))-vec2(0.05, 0.01);\n    vec2 d2 = vec2(M(qf), 1);\n    qf = abs(p1.yz-vec2(0.1,0))-vec2(0.05, 0.01);\n    d2.x = min(d2.x, M(qf));\n    \n    p1.x = mod(p1.x+5.0,10.0)-5.0;\n    qf = abs(p1.xz)-0.1;\n    d2.x = min(d2.x, max(M(qf), p1.y-0.15));\n    //\n    \n    //street lamps... I guess? :p\n    p1.z += 10.0;\n    p1.x = mod(p.x+30.,60.)-30.;\n    p1.y -= 7.0;\n    vec2 d3 = vec2(max(length(p1.xz)-0.1, p1.y), 0);\n    p1.z = abs(p1.z);\n    float dt = (sin(p1.z*0.5))*0.9;\n    d3.x = min(d3.x, max(length(p1.xy-vec2(0,dt))-0.1, p1.z-2.0) );\n    p1.z -= 2.2;\n    p1.y -= 0.7;\n    vec2 lmp = vec2(length(p1*vec3(1,1.25,0.6))-0.2, 2);\n    if (p1.y > 0.){ lmp.y = 1.0; }\n    d3 = mind(d3, lmp);\n    //\n    \n    //buildings\n    p.x = mod(p.x+9.0,18.0)-9.0;\n    if (p.z < 0.){ p.z = mod(p.z+6.0,12.0)-6.0; }\n    \n    vec2 q = abs(abs(abs(p.xz)-1.2)-1.12)-1.0;\n    vec2 d = vec2(M(q), 1);\n    \n    float wp = mod(p.y+0.3,0.4)-0.2;\n    vec2 q1 = abs(vec2(q.x+0.65,wp))-vec2(0.2,0.1);\n    d = maxd(d, vec2(-M(q1), 3));\n    vec2 q2 = abs(vec2(q.y+0.65,wp))-vec2(0.2,0.1);\n    d = maxd(d, vec2(-M(q2), 3));\n    \n    q = abs(q+0.1)-0.2;\n    d = mind(d, vec2(M(q), 0));\n    \n    d.x = max(d.x, p.y-1.);\n    q = abs(p.xz-vec2(0,2.5))-0.7;\n    d = mind(d, vec2(max(M(q), p.y-2.7), 1) );\n    //\n    \n    d = mind(d, mind(d2, d3));\n    return d;\n}\n\n\nvec3 march(vec3 eye, vec3 dir, float maxd){\n    \n    float d, i; vec2 ind;\n    for (; i<100. && d < maxd; i++){\n        vec3 p = eye + dir * d;\n        ind = street(p);\n        if (abs(ind.x) < 0.001 * d)break;\n        d += ind.x;\n    }\n    return vec3(d, ind.y, pow(i/60., 2.5));\n}\n\n\n\n\nmat2 rotate(float angle){\n\tangle *= 3.142 / 180.0;\n    float s = sin(angle), c = cos(angle);\n    return mat2( c, -s, s, c );\n}\n\nfloat fbm(vec2 p){\n    float f;\n    f  = 0.5000*noise(p); p = M2*p*2.02 + TIME*0.1;\n    f += 0.2500*noise(p); p = M2*p*2.03 + TIME*0.1;\n    f += 0.1250*noise(p);\n    return f;\n}\n\nvec3 getSky(vec3 dir){\n    dir += Noise(dir.xy+TIME)*0.01;\n    vec3 sky = mix(yellow, purple2, saturate( pow(dir.y, 0.8)*2.0 ));\n    dir.xz *= rotate(20.);\n    dir.xy *= rotate(-22.);\n    float sun = smoothstep(-0.005,0.005,length(dir.yz)-0.04);\n    \n    vec3 col = mix(suncol, sky, sun);\n    \n    float shape = 0.;\n    vec2 mp = dir.yz;\n    for (float i=0.1; i<=1.0; i+=0.2){\n        shape = mix(shape, max(0.3,1.0-i), \n            smoothstep(0.01,-0.01, mp.x-mp.y+0.075 + sin(mp.y*100.+TIME)*0.01 )\n        );\n        mp.y = -mp.y*0.7;\n    }\n    \n    shape = shape*fbm(dir.zy/(mp.x-mp.y+0.15)*2.5 + vec2(0,TIME)*0.2) + shape;\n    shape = saturate(shape);\n    \n    col = mix(col, purple2*pow(yellow,vec3(0.5)), shape);\n    \n    \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/R;\n    vec3 rand = Noise(uv);\n    #ifdef MARGIN\n    if(uv.x < marginSize || uv.x > 1.0-marginSize){ fragColor = vec4(0.0); return; }\n    #endif\n    uv = (fragCoord.xy-R*0.5)/R.y;\n    \n    vec3 eye = vec3(-25,-23,35),\n    f = normalize(vec3(30, 0, 8) - eye),\n    s = normalize(cross(f, vec3(0,1,0))),\n    dir = (\n        mat4(vec4(s,0), vec4(cross(s, f),0), vec4(-f,0), vec4(1)) * \n        vec4(normalize(vec3(uv, -3.0)), 0)\n    ).xyz;\n    \n    dir.yz *= rotate(sin(TIME));\n    \n    vec3 col;\n    \n    vec3 dist = march(eye, dir, 200.);\n    if (dist.x < 200.){\n        eye += dir * dist.x;\n        vec3 P = vec3(-4, 4, 0) * 0.001;\n        vec3 N = normalize(\n            street(eye+P.xyy).x * \n            P.xyy + street(eye+P.yxy).x * \n            P.yxy + street(eye+P.yyx).x * \n            P.yyx + street(eye+P.xxx).x * \n            P.xxx\n        );\n        N = normalize(N + rand*0.05);\n        \n        col += dot(N, vec3(0,0,1)) *0.5+0.25;\n        dir = reflect(dir, N);\n        col *= getSky(dir);\n        \n        if (dist.y == 0.){ col *= 0.5; }\n        if (dist.y == 2.){ col = suncol; }\n        if (dist.y == 3.){ col = purple2; }\n    }else{\n        col = getSky(dir);\n    }\n    col = mix(col, purple*pow(yellow,vec3(0.2)), saturate(dist.z+rand*0.2));\n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define MARGIN //comment this for fullscreen\n\n#define TIME (iTime)\n#define M(p) max((p).x,(p).y)\n#define R (iResolution.xy)\n#define mind(a, b) (a.x < b.x ? a:b)\n#define maxd(a, b) (a.x > b.x ? a:b)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define Noise(uv) textureLod(iChannel0,uv,1.).rgb\n\n\n\nconst float marginSize = 0.15;\n\n\nconst mat2 M2 = mat2(0.8,-0.6,0.6,0.8);\n\n\nfloat hash21(vec2 p){\n    return (fract(sin(dot(p, p+5373.836))*9272.8363) *2.0-1.0);\n}\n\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    return mix(\n        mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n        mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n    u.y);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}