{
    "Shader": {
        "info": {
            "date": "1471828279",
            "description": "Waves propagating through a 2D grid\nTrying to make the edges act as if they continued infinitely, so waves do not reflect off, but simply are dissipated and disappear.\nAnyone have an idea how to do this?",
            "flags": 48,
            "hasliked": 0,
            "id": "llt3W2",
            "likes": 40,
            "name": "Sonic Boom Simulation",
            "published": 3,
            "tags": [
                "waves",
                "sound",
                "simulation",
                "gradient",
                "sonic",
                "physics"
            ],
            "usePreview": 1,
            "username": "tehsauce",
            "viewed": 2131
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = vec4( texture( iChannel0, fragCoord / iResolution.xy ) );\n\tfragColor = vec4( color.x, color.b, -color.x, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Get normalized pixel coordinates\n    vec2 uv = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy; \n\tuv.x *= iResolution.x / iResolution.y; \n    \n    // Store time with shorter name\n    float t = iTime;\n    float t2 = iTime * iTime;\n      \n    // Pixel color\n    vec4 col = vec4(0.0);\n    \n    // First 5 frames or when \"space\" is pressed buffer set to initial conditions\n\tif ( iFrame < 5 || texture(iChannel2, vec2(32.5/256.0, 0.5) ).x > 0.5 ) {\n     // Load texture as initial state\n     //\tcol = vec4( 2.0*texture( iChannel1,  fragCoord / iResolution.xy ).r - 1.0, 0.0, 0.0, 1.0);\n     \n     // Blank initial state \n        col = vec4( 0.0, 0.0, 0.0, 1.0 );\n    } else {\n        \n        // Get current tile value\n    \tcol = texture( iChannel0, fragCoord / iResolution.xy );\n        \n        // Get adjacent tile values\n        vec4 l = vec4( texture( iChannel0, ( fragCoord + vec2( -1.0,  0.0 ) ) / iResolution.xy ) );\n        vec4 r = vec4( texture( iChannel0, ( fragCoord + vec2(  1.0,  0.0 ) ) / iResolution.xy ) );\n        vec4 u = vec4( texture( iChannel0, ( fragCoord + vec2(  0.0,  1.0 ) ) / iResolution.xy ) );\n        vec4 d = vec4( texture( iChannel0, ( fragCoord + vec2(  0.0, -1.0 ) ) / iResolution.xy ) );\n        \n        // Get diagonal tile values\n        vec4 ul = vec4( texture( iChannel0, ( fragCoord + vec2( -1.0,  1.0 ) ) / iResolution.xy ) );\n        vec4 ur = vec4( texture( iChannel0, ( fragCoord + vec2(  1.0,  1.0 ) ) / iResolution.xy ) );\n        vec4 ll = vec4( texture( iChannel0, ( fragCoord + vec2( -1.0, -1.0 ) ) / iResolution.xy ) );\n        vec4 lr = vec4( texture( iChannel0, ( fragCoord + vec2(  1.0, -1.0 ) ) / iResolution.xy ) );\n        \n        // Tile data stored in pixel with following components:\n        //\n        // x - stores tile displacement\n        // y - stores tiles velocity\n        // z - absolute value of displacement ( for visualization )\n        \n        \n        // Calculate weighted average displacement of neighbors using the kernel \n        //\t\t| 1/12 | 1/6 | 1/12 |\n\t\t//\t\t| 1/6  |  0  | 1/6  |\n\t\t//\t\t| 1/12 | 1/6 | 1/12 |\n        \n        float avg = ( l.x + r.x + u.x + d.x + 0.5 * ( ul.x + ur.x + ll.x + lr.x ) ) / 6.0;\n        \n        // Calculate tiles difference from neighbors\n        float force = avg - col.x;\n        \n        // Determine if tile is near edge\n        float off = max(fragCoord.x + 50.0 - iResolution.x, 0.0) + max(fragCoord.y + 50.0 - iResolution.y, 0.0) + max( 50.0 - fragCoord.x, 0.0) + max( 50.0 - fragCoord.y, 0.0);\n        if ( off > 0.0 ) {\n            // Tiles near edge react less\n        \tforce *= 1.0 / off;   \n        }\n        \n        // Create periodic displacement at mouse clicks\n        if ( iMouse.w > 0.0  ) {       \n        \tcol.x += 0.4*sin(t * 4.0) / ( 1.0 + pow( distance( fragCoord, iMouse.xy ), 1.0 ) ); \n        }\n        \n        // Update velocity\n        col.y += force * 0.12;\n        // Update position\n        col.x += col.y;\n        // Sort of measuring acceleration * amplitude\n        col.z = 3.0 * abs( col.x * force );\n        \n        // Sonic Boom\n        col.x += 2.2*sin(t * 3.0) / ( 1.0 + pow( distance( fragCoord, vec2( 0.4*t*t +100.0, iResolution.y*0.5) ), 2.0 ) ); \n      \n        \n        // Circle\n        // col += vec4( sin(t * 16.0), 0.0, 0.0, 0.0 ) / ( 1.0 + 500.0 * distance( uv, 0.8 * vec2( cos( t ), sin( t ) ) )  );  \n        \n      \t// Some strange amplitude limiting attempts   \n        \n        // col = clamp( col, 0.0, 10.5 );\n        // if ( any( greaterThan( col, vec4( 1.0 ) ) ) ) {\n        \t// col /= 2.0;   \n       \t// }\n    }\n    \n    fragColor = col;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}