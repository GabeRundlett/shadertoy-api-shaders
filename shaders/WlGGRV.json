{
    "Shader": {
        "info": {
            "date": "1579304570",
            "description": "Black and white stuff.",
            "flags": 0,
            "hasliked": 0,
            "id": "WlGGRV",
            "likes": 41,
            "name": "Starry Landscape",
            "published": 3,
            "tags": [
                "3d",
                "noise",
                "raymarch"
            ],
            "usePreview": 0,
            "username": "Klems",
            "viewed": 988
        },
        "renderpass": [
            {
                "code": "\n#define PI 3.14159265359\n#define rot(a) mat2(cos(a + PI*0.5*vec4(0,1,3,0)))\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat hash12(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// https://research.nvidia.com/sites/default/files/pubs/2017-02_Hashed-Alpha-Testing/Wyman2017Hashed.pdf\nconst float hashScale = 1.0;\nfloat hashedNoise(vec3 p, vec3 dpdx, vec3 dpdy) {\n    float maxDeriv = max(length(dpdx), length(dpdy));\n    float pixScale = 1.0 / (hashScale*maxDeriv);\n    vec2 pixScales = vec2(exp2(floor(log2(pixScale))), exp2(ceil(log2(pixScale))));\n    float aa = textureGrad(iChannel0, pixScales.x*p.xyz/32.0, pixScales.x*dpdx/32.0, pixScales.x*dpdy/32.0).r;\n    float bb = textureGrad(iChannel0, pixScales.y*p.xyz/32.0, pixScales.y*dpdx/32.0, pixScales.y*dpdy/32.0).r;\n   \tvec2 alpha = vec2(aa, bb);\n    //alpha = vec2(hash33(floor(pixScales.x*p.xyz)).r, hash33(floor(pixScales.y*p.xyz)).r);\n    float lerpFactor = fract( log2(pixScale) );\n    float x = (1.0-lerpFactor)*alpha.x + lerpFactor*alpha.y;\n    float a = min( lerpFactor, 1.0-lerpFactor );\n    vec3 cases = vec3( x*x/(2.0*a*(1.0-a)),(x-0.5*a)/(1.0-a),1.0-((1.0-x)*(1.0-x)/(2.0*a*(1.0-a))) );\n    float alphaRes = (x < (1.0-a)) ? ((x < a) ? cases.x : cases.y) :cases.z;\n    alphaRes = clamp(alphaRes, 1.0e-6, 1.0);\n    return alphaRes;\n}\n\n// https://iquilezles.org/articles/filteringrm\nvoid calcDpDxy( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy, in float t, in vec3 nor, \n                out vec3 dpdx, out vec3 dpdy ) {\n    dpdx = t*(rdx*dot(rd,nor)/dot(rdx,nor) - rd);\n    dpdy = t*(rdy*dot(rd,nor)/dot(rdy,nor) - rd);\n}\n\n// noise with smooth derivative\nfloat snoise( in vec3 x, const in float lod ) {\n    float dim = 32.0 / exp2(lod);\n    x = x * dim;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    x = (p+f+0.5) / dim;\n    return textureLod(iChannel0, x, lod).r;\n}\n\n// smoother noise\nfloat noise( in vec2 x ) {\n    x *= 32.0;\n    const vec2 e = vec2(1, 0);\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix( hash12(i+e.yy), hash12(i+e.xy),f.x),\n               mix( hash12(i+e.yx), hash12(i+e.xx),f.x),f.y);\n}\n\n// cascading return to optimize distance function\nfloat height(vec2 p, float y) {\n    p /= 32.0;\n    float hei = noise(p*0.04);\n    hei *= hei*30.0;\n    if (y > hei+3.0) return hei;\n    hei += snoise(vec3(p*0.5, 0), 0.0)*1.0;\n    if (y > hei+2.0) return hei;\n    hei += snoise(vec3(p*1.0, 10), 10.0)*0.2;\n    if (y > hei+1.0) return hei;\n    hei += snoise(vec3(p*2.0, 100), 20.0)*0.1;\n    return hei;\n}\n\nfloat de(vec3 p) {\n    return p.y - height(p.xz, p.y);\n}\n\nvec3 getNormal(vec3 p) {\n\tvec3 e = vec3(0.0, 0.3, 0.0);\n\treturn normalize(vec3(\n\t\tde(p+e.yxx)-de(p-e.yxx),\n\t\tde(p+e.xyx)-de(p-e.xyx),\n\t\tde(p+e.xxy)-de(p-e.xxy)));\t\n}\n\nbool intSphere( in vec4 sp, in vec3 ro, in vec3 rd, out float t ) {\n    vec3  d = ro - sp.xyz;\n    float b = dot(rd,d);\n    float c = dot(d,d) - sp.w*sp.w;\n    float tt = b*b-c;\n    if ( tt > 0.0 ) {\n        t = -b-sqrt(tt);\n        return true;\n    }\n    return false;\n}\n\nfloat star( in vec3 dir ) {\n    dir.yz *= rot(-0.7);\n    float base = step(abs(dir.z), 0.007);\n    dir.xy *= rot(iTime*0.5);\n    float trail = (atan(dir.x, dir.y)+PI)/(2.0*PI);\n    trail = pow(trail+0.05, 20.0);\n    return base*trail;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    uv += uv*dot(uv,uv)*0.5;\n    \n\tvec3 from = vec3(0, 2, -5);\n\tvec3 dir = normalize(vec3(uv, 0.4));\n    \n\tvec2 mouse=(iMouse.xy - iResolution.xy*0.5) / iResolution.y * 2.5;\n    if (iMouse.z < 0.5) mouse = vec2(0);\n\tmat2 rotxz = rot(-mouse.x+sin(iTime*0.1512)*0.75-PI*0.5);\n\tmat2 rotxy = rot(mouse.y+sin(iTime*0.12412)*0.25);\n\tdir.zy *= rotxy;\n\tdir.xz *= rotxz;\n\n    from.x += iTime*10.0;\n    from.y += height(from.xz, 9e9);\n    \n\tfloat totdist = 0.0;\n    for (int steps = min(iFrame, 0) ; steps < 150 ; steps++) {\n\t\tvec3 p = from + totdist * dir;\n        float dist = de(p);\n\t\ttotdist += dist*0.5;\n        if (dist < 0.001 || totdist > 400.0) {\n        \tbreak;   \n        }\n\t}\n    \n    const vec3 light = normalize(vec3(3, 1, 2));\n    float noi = hashedNoise(dir, dFdx(dir), dFdy(dir));\n    float lig = 0.0;\n    vec3 test = vec3(0);\n    if (totdist > 400.0) {\n        \n        // add stars\n        lig = pow(texture(iChannel0, dir*0.7).r, 40.0)*10.0;\n        \n        // add a shooting star\n        lig += star(dir);\n        \n        // add a planet\n        vec3 fromPl = vec3(8, 5, -1);\n        float toSphere = 0.0;\n        bool sphere = intSphere( vec4(0, 0, 0, 1), fromPl, dir, toSphere);\n        if (sphere) {\n            vec3 normal = fromPl + dir*toSphere;\n            lig = max(0.0, dot(normal, light))*30.0;\n        }\n        \n    } else {\n    \n        vec3 p = from + totdist * dir;\n        vec3 n = getNormal(p);\n        vec3 dpdx = vec3(0);\n        vec3 dpdy = vec3(0);\n        calcDpDxy(from, dir, dir+dFdx(dir), dir+dFdy(dir), totdist, n, dpdx, dpdy);\n\n        noi = hashedNoise(p, dpdx, dpdy);\n\t\t\n        // diffuse\n        lig = max(0.0, dot(n, light));\n        lig *= lig*2.0;\n        \n        // some fresnel\n        float fres = pow(max(0.0, 1.0-dot(n, -dir)), 10.0);\n        lig += fres*2.0;\n    }\n    \n    // vignette, gamma correction\n    lig = pow(lig*0.5, 1.0/2.2);\n    vec2 uu = (fragCoord.xy-iResolution.xy*0.5)/iResolution.xy;\n    lig = mix(lig, 0.0, dot(uu,uu)*1.3);\n    \n    fragColor = vec4(step(noi, lig));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}