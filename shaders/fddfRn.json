{
    "Shader": {
        "info": {
            "date": "1655976654",
            "description": "I created Quadruple Rhombic Dodecahedron Tiling used for Directional Flow in 3D. ",
            "flags": 0,
            "hasliked": 0,
            "id": "fddfRn",
            "likes": 5,
            "name": "Rhombic Dodecahedron Grid Tiling",
            "published": 3,
            "tags": [
                "3d",
                "grid",
                "tetrahedron",
                "distance",
                "barycentric",
                "flow",
                "honeycomb",
                "tiling",
                "trilinear",
                "directional",
                "dodecahedron",
                "rhombic"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 283
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/* \nRhombic Dodecahedron Tiling perfectly in 3D space.\nI made four perfectly overlaying Rhombic Dodecahedron Grid Tiles. In the pattern I\naranged them they have a very useful property. If you add up the edge distance of \nall 4 grids they add up to 1 in all points. This allows us to do bilinear \ninterpolation between 4 samples in 3D space. \n\nThis project contains: \n- Rhombic Dodecahedron Distance function. \n- An infinite Rhombic Dodecahedron Gird Tiling with Center Distance, Edge Distance, \n    centered UVW Coordinates, and Cell ID. \n- Four Rhombic Dodecahedron Girds with the grids being offset so that their\n    edges get perfectly hidden by each other\n\nI created this for a 3D version of the Hex Directional Flow with only 4 flowmaps \n+ 4 textures samples. In contrast the original directional flow has 8 flowmaps + \n8 textures when used in 3D. But to showcase it here, I need a nice 3D Flow \nand Texture. Maybe I will make it in future.\n*/\n\n//#define ZEROTOONE\n\n// show the alpha instead of UVWs\n#define ALPHA\n\n#define sqrt2 \t\t\t1.4142135624 //sqrt(2.)\n#define half_sqrt2\t\t0.7071067812 //sqrt(2.)/2.\n#define qurt_sqrt2\t\t0.3535533906 //sqrt(2.)/4.\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast) {\n    // increase steepness using power\n    vec4 powAlpha = pow(alpha, vec4(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z + powAlpha.w);\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p) {\n    vec3 hra = vec3(0.5, 0.5, half_sqrt2); //vector to Diagonal Edge\n    p = abs(p);\n    float pBC = max(p.x,p.y); //rigt and top edge\n    float pABC = max(dot(p, hra),pBC); //diagonal edge\n    \n    //optional 0-1 range\n    return (.5-pABC)*2.;\n}\n\n// struct to hold 5 floats at a time of my tiling functions\nstruct tilingVal3D \n{\n    vec3 grid;       // Coordinates of the cell in the grid (UV centered on cell)\n    vec3 id;         // ID values\n    float alpha;  // Edge distance from the cell's center to its boundaries\n};\n\n//Rhombic Dodecahedron Tiling\ntilingVal3D rohmTile(vec3 uvw) {\n    vec3 r = vec3(1.0,1.0,sqrt2);\n    vec3 h = r*.5;\n\n    vec3 a = mod(uvw, r)-h;\n    vec3 b = mod(uvw-h,r)-h;\n    \n    vec3 gvw = dot(a, a) < dot(b,b) ? a : b; //center rhom uvw\n    float edist = rhomDist(gvw); //Edge distance with range 0-1\n    //float cdist = dot(gvw, gvw); // squared distance with range 0-1\n    vec3 id = uvw-gvw; // simple ID calculation\n    \n    return tilingVal3D(gvw, id, edist);\n}\n\n// scaled with offset Rhombic Dodecahedron tiling\ntilingVal3D rohmCell(vec3 uvw, vec3 offset, float gridRes) {\n    tilingVal3D rohmTiling = rohmTile(uvw*gridRes + offset);\n    vec3 tiledUV = (rohmTiling.id - offset)/gridRes; //rohm pixaltion    \n    return tilingVal3D(rohmTiling.grid, tiledUV,rohmTiling.alpha);\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec3 uvw, float gridRes, float contrast) {\n    tilingVal3D a = rohmCell(uvw, vec3( .0, .0, .0), gridRes);\n    tilingVal3D b = rohmCell(uvw, vec3( .5, .0, qurt_sqrt2), gridRes);\n    tilingVal3D c = rohmCell(uvw, vec3( .0, .5, qurt_sqrt2), gridRes);\n    tilingVal3D d = rohmCell(uvw, vec3( .0, .0, half_sqrt2), gridRes);\n   \n    // increase contrast\n    vec4 alpha = smoothContrast(vec4(a.alpha, b.alpha, \n                                c.alpha, d.alpha), contrast);\n                                \n#ifdef ZEROTOONE\n    // rescale UVWs to 0-1\n    a.grid = a.grid *0.5+0.5;\n    b.grid = b.grid *0.5+0.5;\n    c.grid = c.grid *0.5+0.5;\n    d.grid = d.grid *0.5+0.5;   \n#endif\n    \n    // interpolate UVWs cause shadertoy doesn't have nice 3d Textures\n    vec3 col = a.grid * alpha.x +\n               b.grid * alpha.y +\n               c.grid * alpha.z +\n               d.grid * alpha.w;\n#ifndef ZEROTOONE\n    col *= 2.0;\n#endif\n\n#ifdef ALPHA\n    col = alpha.xyz;\n#endif\n    \n    return col;\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\n    // https://math.stackexchange.com/questions/2975109/how-to-convert-euler-angles-to-quaternions-and-get-the-same-euler-angles-back-fr\n    vec4 q;\n    vec3 c = cos(a * 0.5), s = sin(a * 0.5);\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n    \n    // https://blog.molecular-matters.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n    vec3 qt = 2.0 * cross(q.xyz, v);\n    return v + q.w * qt + cross(q.xyz, qt);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    float gridRes = 1.5; //size of Ico\n    float contrast = 1.; //1 no contrast, higher values increase contrast\n    \n    vec2 uv = fragCoord/iResolution.y; //square UV pattern\n    float time = (0.1*iTime); // used as z dimension      \n    vec3 point = vec3(uv, time); //animated uv cords\n    \n    //cosmetic rotate for fun hexagons otherwise it looks so square\n    point = rotate(point, normalize(vec3(1.,0.,0.))); \n    \n    vec3 col = quadGrid(point,gridRes, contrast);\n        \n    fragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}