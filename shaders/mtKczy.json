{
    "Shader": {
        "info": {
            "date": "1700382799",
            "description": "truchet3D  toroidal spherical  hexahedron",
            "flags": 0,
            "hasliked": 0,
            "id": "mtKczy",
            "likes": 6,
            "name": "truchet3D toroidal hexahedron",
            "published": 3,
            "tags": [
                "3d",
                "sdf",
                "truchet",
                "sphericalprojection",
                "hexahedron"
            ],
            "usePreview": 0,
            "username": "cyperus",
            "viewed": 178
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"truchet3D toroidal hexahedron\"\n//\n// created by Colling Patrik (cyperus) in 2023\n//\n// References & Inspiration:\n// - \"Year of Truchets\" #058 by byt3_m3chanic\n//   https://www.shadertoy.com/view/msVfzR\n//\n// - conformal mapping with confmap.m by Trefethen\n//   https://people.maths.ox.ac.uk/trefethen/lightning.html\n//\n// - signed distance functions & operations by iq\n//   https://iquilezles.org/articles/distfunctions/\n//\n// - quick guide for shadertoy by FabriceNeyret2\n//   https://shadertoyunofficial.wordpress.com/\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// ray casting bounding shape\nconst float CAM_DIST = 6.;\nconst float CAM_FLE = 1.3;\nconst float BB_DIST = 4.;\nconst float RAY_MIN_DIST = 0.5;\nconst float RAY_MAX_DIST = CAM_DIST+1.1*BB_DIST;\n\nint   MAX_MARCHING_STEPS = 300;\nconst float RAY_STEP_FACTOR3 = 230./450.;\nfloat RAY_STEP_FACTOR = (0.5-0.0001)* pow(RAY_STEP_FACTOR3, 3.) + 0.0001;\nfloat RAY_PRECISION = 1.; \n\n// platonic sphere\nconst float PS_e_f = 4.;\n\n// torus-sphere-spheres\nfloat PS_a0 = 8.;\n\n// data from sdf\nvec4 mat = vec4(0);\n\nfloat map(in vec3 p) {\n    float rxy = 0., au = 0.0;\n    float cell_id = 0., sr = 0.;\n    vec2 z = vec2(0.);\n           \n    /// platonic sphere\n    vec3 pn = normalize(p); \n  \n    // projection from n cells to 1 cell.\n    pn = hexa_cells(pn, cell_id, sr);\n    \n    // invers stereographic projection\n    z = pn.xy/(1.-pn.z);\n    z = cHexaPolyArc2disk(z);\n    \n    // r-polygon-distribution\n    vec2 e = vec2(3., 0.5);\n    e.y += - 0.05 *cos(PS_e_f*atan(z.y, z.x));\n    float en = 1.+( (PS_a0<0.?e.x:e.y)-1. )*smoothstep(1.,5., abs(PS_a0));        \n    float r = length(z); vec2 zn = z/r;\n    z = dist(r, en) * zn;\n\n    //stereograpic projection    \n    pn = sp(vec3(z,sr));\n\n    //unnormalize\n    p = length(p) * pn;    \n\n    /// torus-sphere-spheres\n    rxy = length(p.xy); au = atan(p.y, p.x);   \n    z = vec2(rxy, p.z);\n    z = cmul(z,z); z.x -= PS_a0;\n    \n    p = vec3(log(length(z)), 0.5*au/PI, 0.5*atan(z.y,z.x)/PI); // r,u,v\n    z = p.yz;\n    \n    /// truchet 3d\n    const float TC3D_nu = PS_e_f*2.*2.;\n    const float TC3D_nv = 2.*2.;\n    const float TC3D_nr = 1.;\n    p *= vec3(TC3D_nr,TC3D_nu,TC3D_nv); // r,u,v\n    p.yzx = p.xyz; \n\n    ivec3 l0 = -ivec3(TC3D_nv/2.,0,TC3D_nu/2.); ivec3 l1 = ivec3(TC3D_nv/2.,TC3D_nr,TC3D_nu/2.)-ivec3(1.);\n    vec3 tc_id = floor(p);\n    tc_id = clamp(tc_id, vec3(l0), vec3(l1));\n    vec3 q = p - tc_id -0.5;\n    \n    // random\n    float rnd = hash21(tc_id.xz);  \n    \n    // flip cell direction randomly\n    if(rnd<.5) q.x = -q.x;\n    \n    // sdf\n    float r0 = 0.5; float r1 = 0.125;\n    float d;\n    if(fract(rnd*77.57+iTime/6.)>.75) {\n       // offset-xz circle, id diagonal sub domain\n       vec3 q2 =  length(q.xz-.5)<length(q.xz+.5)\n                ? vec3(q.xz-.5,0.)  \n                : vec3(q.xz+.5,1.);\n       d = sdTorus( vec3(q2.x, q.y, q2.y) , vec2(0.5,r1) );\n    }\n    else {\n       d = opSmoothUnion( sdCylinder( q.zxy, r1 ), sdCylinder( q.xzy, r1 ), 0.05 );\n    }\n    \n    // cell alpha    \n    float tc_a = sdBox( q, vec3(r0*0.9)); float px = fwidth(tc_a);\n    tc_a = smoothstep(px,-px,tc_a);\n    \n    /// return\n    // torus uv, truchet cell alpha, random cell id\n    mat.xy = z; mat.z = tc_a, mat.w = rnd;    \n    return d;\n}\n\n// intersect\nfloat intersect(in vec3 ro, in vec3 rd, in float px) {\n    float res = -1.0;\n    \n    // bb\n    vec2 dis = isphere( ro, rd , abs(BB_DIST));\n    \n    if( dis.y<0.0 ) return -1.0;\n\n    dis.x = max( dis.x, RAY_MIN_DIST );\n    dis.y = min( dis.y, RAY_MAX_DIST );\n\n    // raymarch   \n\tfloat fh = RAY_STEP_FACTOR;\n    float t = dis.x;\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) {\n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t;\n        float h = map( pos);\n        if( t>dis.y || h<th ) break;\n        t += h*fh;\n    }\n    if( t<dis.y ) {\n        res = t;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\tmap(p+e.yyx) - map(p-e.yyx) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) { \n\tif (iMouse.x > 0.0) {\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n    p.yz = crot(p.yz,-2.*PI*1.*time/360.);\n    p.zx = crot(p.zx,-2.*PI*3.*time/360.);\n\treturn p.xyz;\n}\n\n// textures\nvec4 ribbon(in float uv_x, in float time) {\n    float sdf = -(2.*pulsecollision(1.,1./3. * uv_x, time, 2./6.)-1.);\n    float px = fwidth(sdf);\n    return vec4( h2rgb(sdf -2./6.)\n               , smoothstep(px+0.1,-px-0.1,sdf+0.2) );\n}\n\nvec4 truchet3D(in float rnd, in float a ,in float time) {\n    return mix(vec4(1.), vec4(h2rgb( fract(abs(rnd)*22.93 + time)),1.), a);\n}\n\n// main\nvoid mainImage(out vec4 O, in vec2 fragCoord) {  \n    // anti-aliasing to take a picture\n    vec3 tot = vec3(0.0);\n    #define AA 1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {       \n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0*(fragCoord+o) - iResolution.xy)/iResolution.y;\n        \n        // camera viewport --> worldspace\n        vec3 ro = vec3(0,0,-CAM_DIST);\n        vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n             ro = transform(ro,iTime);\n             rd = normalize(transform(rd,iTime));\n        \n        // distance hit ray surface\n        float px = 2.0/( iResolution.y*CAM_FLE );\n        float t = intersect( ro, rd, px );\n\n        vec3 sky_col = 0.7*(0.6+0.4*rd);\n\n        // background\n        vec4 C = vec4(sky_col,1.);\n        O = C;\n        \n        // object surface\n        if (t >= 0.) {\n            // surface properties\n            vec3 p = ro + rd * t;\n            vec3 norm = calcNormal( p, 0.001);\n            \n            // uv-coords\n            vec2 mat_uv = mat.xy;\n                \n            // draw texture layers from back to front\n            O = vec4(0);\n            #if 1\n            if(O.a<1.) {             \n                C = ribbon( float(PS_e_f)*3.* mat_uv.x, 0.0125*iTime); C.rgb *= 0.7;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            #endif\n            #if 1\n            if(O.a<1.) {\n                C = vec4(vec3(n)*0.5,0.2); // normal\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            #endif            \n            #if 1\n            if(O.a<1.) {            \n                C = truchet3D(mat.w, mat.z, iTime/60.); C.rgb *= 0.5;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            #endif\n            C = O;\n                       \n            // lighting\n            vec3  came_li_o   = transform(vec3(-10.,10.,-10.),iTime); // origine\n            vec3  came_li_dir = normalize(p - came_li_o);             // direction\n            vec3  came_li_col = vec3(1.,1.,.5);                       // color\n            float came_li_shi = 10.;                                  // shininess            \n\n            float cosa = 1.;\n            O.rgb += 0.1 * cosa * C.rgb * sky_col;           // amb\n            cosa = clamp(dot(-came_li_dir, norm), 0., 1.);\n            O.rgb += 0.5 * cosa * C.rgb * came_li_col;       // dif       \n            cosa = pow(clamp(dot(reflect(came_li_dir, norm), -rd), 0., 1.), came_li_shi);           \n            O.rgb += 0.4 *(cosa>0.? cosa:0.) * came_li_col ; // spec\n            \n            // fresnel\n            O.rgb += pow(clamp(1. - dot(norm, -rd), 0., 1.), 5.) * 0.6 * sky_col;\n            \n            // fog\n            O.rgb = mix(O.rgb, sky_col, 1.0 - exp(-0.003 * pow(t,3.)));    \n        }\n        tot += O.rgb;\n    }\n    tot /= float(AA*AA);\n    \n    // gamma correction\n    O = vec4(rgb2srgb(tot),1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// consts\nconst float PI = abs(atan(0.,-1.));\nconst float PI_2 = PI/2.;\n\n/// 1D transformations\nfloat pow2( in float x){ return x*x;}\n\nfloat pulsecollision(in float pf, in float x, in float x0, in float pw) {\n    /*\n    x  : periodic in [0,1]\n    x0 : offset\n    pw : pulse width in [0,1]\n    pf : pulse frequency \n    */\n    float ntriw_p = abs( fract( pf*(x - x0) )-0.5); // x_normalized triangle wave function moving in +x_direction\n    float ntriw_n = abs( fract( pf*(x + x0) )-0.5); // x_normalized triangle wave function moving in -x_direction\n    float pp = smoothstep( 0.5*pw, 0., ntriw_p );   // pulse moves in +x_direction\n    float pn = smoothstep( 0.5*pw, 0., ntriw_n );   // pulse moves in -x_direction\n    return (pp+pn);                                 // smooth superposition\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);\n}\n\n/// 2D transformations\n/// complex\nvec2 cmul(vec2 za,vec2 zb){\n    return za*mat2(zb.x,-zb.y,zb.yx);}\n\nvec2 crot(vec2 z,float a){\n    return cmul(vec2(cos(a),sin(a)),z);}\n\nvec2 cinv(vec2 z){\n    return z*vec2(1,-1)/dot(z,z);}\n    \nvec2 cdiv(vec2 z, vec2 w){\n    return cmul(z,cinv(w));}\n\nvec2 cpow(vec2 z, float q){\n    float r=pow(length(z), q);\n\tfloat a=q*atan(z.y,z.x);\n    return vec2(r*cos(a),r*sin(a));}\n\nvec2 cpow(vec2 z, int n){\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));}\n\nvec2 crpt(vec2 z, float a, float p, float x0){\n  // (z*e^ia)^p-x0\n  return cpow( cmul(z, vec2(cos(-a),sin(-a))),p) - vec2(x0, 0.);}\n\nvec2 cHexaPolyArc2disk(vec2 z) {\n    // https://people.maths.ox.ac.uk/trefethen/lightning.html\n    const int NUM_j = 18; // poles\n    const vec2[] rf = vec2[NUM_j]\n    (vec2( 0.7072, -0.7070)\n    ,vec2(-0.7070,  0.7072)\n    ,vec2(-0.0377, -0.9993)\n    ,vec2( 0.7072,  0.7070)\n    ,vec2(-0.7072, -0.7070)\n    ,vec2(-0.0377,  0.9993)\n    ,vec2( 0.5452, -0.8383)\n    ,vec2( 0.9936,  0.1126)\n    ,vec2(-0.9936,  0.1126)\n    ,vec2(-0.7983, -0.6022)\n    ,vec2(-0.7563,  0.6542)\n    ,vec2( 0.6542,  0.7563)\n    ,vec2( 0.7563, -0.6542)\n    ,vec2(-0.6235,  0.7818)\n    ,vec2(-0.7167, -0.6974)\n    ,vec2(-0.6542, -0.7563)\n    ,vec2( 0.7342,  0.6790)\n    ,vec2( 0.7025, -0.7117));\n\n    const vec2[] rw = vec2[NUM_j]\n    (vec2( 0.0135,  0.0   )\n    ,vec2( 0.0008,  0.0001)\n    ,vec2(-0.5762,  0.1282)\n    ,vec2( 0.0013,  0.0002)\n    ,vec2(-0.0135, -0.0085)\n    ,vec2( 0.1239, -0.0601)\n    ,vec2(-0.2162, -0.3769)\n    ,vec2( 0.1197, -0.1327)\n    ,vec2( 0.2544,  0.0708)\n    ,vec2( 0.3228,  0.3050)\n    ,vec2( 0.0377, -0.0056)\n    ,vec2( 0.0362, -0.0135)\n    ,vec2( 0.1439, -0.0871)\n    ,vec2( 0.0551,  0.0066)\n    ,vec2(-0.0935,  0.1492)\n    ,vec2(-0.2397,  0.1216)\n    ,vec2( 0.0218, -0.0211)\n    ,vec2( 0.0077, -0.0763));\n\n    const vec2[] rz = vec2[NUM_j]\n    (vec2( 0.366242, -0.365216)\n    ,vec2(-0.365216,  0.366242)\n    ,vec2(-0.012767, -0.414156)\n    ,vec2( 0.366242,  0.365216)\n    ,vec2(-0.366242, -0.365216)\n    ,vec2(-0.012767,  0.414156)\n    ,vec2( 0.216186, -0.397592)\n    ,vec2( 0.413695,  0.038296)\n    ,vec2(-0.413695,  0.038296)\n    ,vec2(-0.391705, -0.251311)\n    ,vec2(-0.383838,  0.291533)\n    ,vec2( 0.291533,  0.383838)\n    ,vec2( 0.383838, -0.291533)\n    ,vec2(-0.266502,  0.388876)\n    ,vec2(-0.372411, -0.341303)\n    ,vec2(-0.291533, -0.383838)\n    ,vec2( 0.378349,  0.316470)\n    ,vec2( 0.350877, -0.369995));\n\n    // polynomial barycentric representation\n    vec2 zn = vec2(0.); vec2 zd = vec2(0.);       \n    for(int j = 0; j<NUM_j; j++) {\n        vec2 zj = cdiv( rw[j], (z-rz[j]));\n        zn += cmul(rf[j], zj); // sum nominator\n        zd += zj;              // sum denominator\n    }\n    return cdiv(zn, zd);\n}\n\n// map spherical platonic solid pyramidal-face-cells to one cell located at -z-axis.\nvec3 hexa_cells(in vec3 p, out float cell_id, out float sr){\n\t//// hexagon\n    // cells +X, -X, +Y, -Y,+Z, -Z\n    // cell walls defined by the face_normals\n    bool nBA = dot(vec3( 1., 0.,-1.),p)>=0.;\n\tbool nCA = dot(vec3( 0., 1.,-1.),p)>=0.;\n\tbool nDA = dot(vec3( 1., 1., 0.),p)>=0.;\n\tbool nCB = dot(vec3(-1., 1., 0.),p)>=0.;\n\tbool nDB = dot(vec3( 0., 1., 1.),p)>=0.;\n\tbool nDC = dot(vec3( 1., 0., 1.),p)>=0.;\n    // map (+X, -X, +Y, -Y,+Z, -Z)-cells to (-Z)-cell by rotation\n    // rotation angles\n    const float a90 = PI/2.; // a = 90째       \n    const vec2 ei_a0   = vec2(1., 0.);             // a = 0째 \n    const vec2 ei_a90  = vec2(cos(a90), sin(a90)); // a = 90째\n    \n    vec2 ei_y; vec2 ei_x;\n\t//inside cell +X: +X --> -Z\n\tif(nBA && nDA && !nCB && nDC) {\n\t\tcell_id = 0.;\n\t\tei_y = ei_a90;\n\t\tei_x = ei_a0;\n\t}\n\t//inside cell -X: -X --> -Z\n\telse if(!nBA && !nDA && nCB && !nDC) {\n\t\tcell_id = 1.;\n\t\tei_y = -ei_a90;\n\t\tei_x = ei_a0;\n\t}\n    //inside cell +Y: +Y --> -Z\n\telse if(nCA && nDA && nCB && nDB) {\n\t\tcell_id = 2.;\n\t\tei_y = -ei_a90;\n\t\tei_x = -ei_a90;\n\t}\n\t//inside cell -Y: -Y --> -Z\n\telse if(!nCA && !nDA && !nCB && !nDB ) {\n\t\tcell_id = 3.;\n\t\tei_y = ei_a90;\n\t\tei_x = ei_a90;\n\t}\n\t//inside cell +Z: +Z --> -Z\n\telse if(!nBA && !nCA && nDB && nDC) {\n\t\tcell_id = 4.;\n\t\tei_y = -ei_a0; // 180째\n\t\tei_x = ei_a0;\n\t}\n\t//inside cell -Z: -Z --> -Z\n\telse if(nBA && nCA && !nDB && !nDC) {\n\t\tcell_id = 5.;\n\t\tei_y = ei_a0;\n\t\tei_x = ei_a0;\n\t}        \n\t// cell orientation\n\tp.zx = cmul(p.zx,ei_y); // rotate around y-axis\n\tp.yz = cmul(p.yz,ei_x); // rotate around x-axis\n\t// non cyclic\n\tsr = 4.;\n    return p;\n}\n\n// distribution\nfloat sig(float x) {\n    return x < 0. ? -1. : +1.;\n}\n\nfloat dist(float x, float e) {\n    // e in [0., +inf]\n    return sign(x)*abs( pow(sign(x)*x, abs(e)) );\n    //return sign(x)*abs( pow(abs(x), abs(e)) );\n}\n   \nvec2 r_poly_dist(vec2 z, vec2 e, float sh_a) {   \n    /// r-polygon-distribution\n    float r = length(z); z = (r<0.)? vec2(0) : z/r; \n    float d0 = 0.5 *abs(e.y-e.x);\n    float e2 = e.x + d0 + d0 * (2.*smoothstep(-1., 1., -sh_a) - 1.);\n    return dist(r, e2) * z;\n}   \n\n// stereographic projection\nvec3 sp(vec3 zsr){\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // stereopraphic projection (complex plane to unit sphere)\n    float zz = dot(z,z); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(2. * z.x,  2. * z.y, -1. + zz);\n        }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(2. * z.x, -2. * z.y,  1. - zz);\n        }\n    pn /= 1.+zz;\n    return pn;\n}\n\nvec3 spb(vec3 zsr) {\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // inverse stereograpic projection\n    float k = 2./(1.+dot(z,z)); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(k*z, k-1.); }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(k*z, -(k-1.)); }\n    return pn;\n}\n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// sdf\nfloat opIntersection( float d1, float d2 ) {\n    return max(d1,d2); }\n\nfloat opSmoothUnion( in float d1, in float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, float r ) {\n  return length(p.xz)-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// color\nvec3 h2rgb(float h){\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); /* cubic smoothing */\n}\n\nvec3 hsv2rgb(float h, float s, float v){     \n    return v * mix( vec3(1.0), h2rgb(h), s); /* hue, saturation, value */\n}\n\n// srgb <--> rgb (linear)\nvec3 srgb2rgb(vec3 col) {\n    return pow(col, vec3(2.2));\n}\n\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}