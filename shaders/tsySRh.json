{
    "Shader": {
        "info": {
            "date": "1573422731",
            "description": "Hell behind frosted glass. Inspired by Silent Hill 3.",
            "flags": 0,
            "hasliked": 0,
            "id": "tsySRh",
            "likes": 8,
            "name": "Glass Refuge",
            "published": 3,
            "tags": [
                "raytracing",
                "raymarching",
                "reflection",
                "refraction",
                "hell",
                "glossy"
            ],
            "usePreview": 0,
            "username": "ShnitzelKiller",
            "viewed": 564
        },
        "renderpass": [
            {
                "code": "#define MAX_STEP 25\n#define TOL 0.01\n#define FDIST 0.5\n#define MAXDIST 50.\n#define PI 3.1415927\n\n#define PLANE_HEIGHT -0.5\n\n#define SAMPLES 10\n#define GRID_SCALE 40.\n#define GRID_MAGNITUDE 0.04\n#define RADIUS 0.5\n#define SPACING 0.8\n#define OSC_MAGNITUDE 0.25\n#define OSC_SPEED 2.\n#define ROT_SPEED 20.\n\nvec2 rand2d(in vec2 uv) {\n    return fract(mat2(-199.258, 457.1819, -1111.1895, 2244.185)*sin(mat2(111.415, -184, -2051, 505)*uv));\n}\n\nfloat rand(in vec2 uv) {\n    return fract(865.1445*sin(dot(vec2(-1995.11, 144.969), uv)));\n}\n\nfloat map(in vec3 ro, out vec2 uv) {\n    vec2 id = floor(ro.xy/SPACING + 0.5);\n\tfloat offset = rand(id) * 2.*PI;\n    float mag = 9.7;\n\tfloat innerang = ROT_SPEED*iTime/mag + offset;\n    float modulation = cos(innerang);\n    float arg = sin(innerang);\n    float angle = sin(mag/(arg+1.1))*modulation*modulation*3.;\n    //float angle = iTime*(ROT_SPEED*(offset-0.5));\n    float c = cos(angle);\n    float s = sin(angle);\n    mat2 rot = mat2(c, -s, s, c);\n    ro.xy = mod(ro.xy + SPACING*0.5, vec2(SPACING))-SPACING*0.5;\n\tuv = rot * ro.xy + offset * vec2(17.189185, 37.17859812);\n    return length(ro - vec3(0., 0., OSC_MAGNITUDE) * (1. - sin(iTime * OSC_SPEED*offset*0.75 + offset)))-RADIUS;\n}\n\nvec3 getnormal(vec3 ro) {\n    vec2 uv;\n    vec2 d = vec2(TOL, 0.0);\n    float x1 = map(ro+d.xyy, uv);\n    float x2 = map(ro-d.xyy, uv);\n    float y1 = map(ro+d.yxy, uv);\n    float y2 = map(ro-d.yxy, uv);\n    float z1 = map(ro+d.yyx, uv);\n    float z2 = map(ro-d.yyx, uv);\n    return normalize(vec3(\n        x1-x2,\n        y1-y2,\n        z1-z2));\n}\n\nvec2 raymarch(in vec3 ro, in vec3 rd, out vec2 uv) {\n    float t = 0.;\n    for (int i=0; i<MAX_STEP; i++) {\n        float dist = map(ro+t*rd, uv);\n        t += dist;\n        if (dist < TOL) {\n            return vec2(t, 1.);\n        } else if (dist > MAXDIST) break;\n    }\n    return vec2(t, 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n    vec3 eye = vec3(iTime, 10.*sin(iTime*0.2), 0.5);\n    float mouseX = iMouse.z > 1. ? 2.*iMouse.x/iResolution.x-0.5 : 0.;\n    float mouseY = iMouse.w > 1. ? 2.*iMouse.y/iResolution.y-0.5 : 0.;\n    vec3 w = normalize(vec3(1., cos(iTime*0.2) - mouseX, mouseY + 0.5*sin(iTime*0.1367)));\n    vec3 up = vec3(0., 0., 1.);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    \n    vec3 rd = normalize(w * FDIST + uv.x * u + uv.y * v);\n    rd.z = -abs(rd.z);\n    \n    //project onto plane\n    vec3 ro = eye + ((PLANE_HEIGHT-eye.z)/rd.z) * rd;\n    \n    vec3 col = vec3(0.);\n    \n    float horiz = length(ro.xy - eye.xy);\n    if (rd.z > 0. || horiz > MAXDIST) {\n        fragColor = vec4(0.);\n        return;\n    }\n\n    for (int i=0; i<SAMPLES; i++) {\n        vec2 theta = rand2d(ro.xy + float(i) * vec2(104., -30.6));\n        theta *= vec2(2.*PI, 0.02*PI);\n        vec3 n = vec3(cos(theta.x)*sin(theta.y), sin(theta.x)*sin(theta.y), cos(theta.y));\n        n = normalize(n + vec3(vec2(GRID_MAGNITUDE, GRID_MAGNITUDE)*cos(ro.xy*GRID_SCALE), 0.));\n        vec3 newrd = reflect(rd, n);\n        vec2 uv2;\n        vec2 t = raymarch(ro, newrd, uv2);\n\t\tvec3 newro = ro + newrd*t.x;\n        //lighting\n        if (t.y > 0.5) {\n            //shapes\n            vec3 normal = getnormal(newro);\n            vec3 tex = texture(iChannel0, uv2).xyz * vec3(1., 0.7, 0.7);\n            float fac = max(dot(normal, vec3(0., 0., -1.)), 0.) * max(0., 1.-pow(newro.z-PLANE_HEIGHT, 2.));\n            col += fac * tex;\n        } else {\n            //background color\n            col += vec3(0.);\n        }\n    }\n    col /= float(SAMPLES);\n    col *= smoothstep(MAXDIST, MAXDIST-50., horiz);\n    \n    fragColor = vec4(pow(col, vec3(1.3)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}