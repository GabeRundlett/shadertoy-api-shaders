{
    "Shader": {
        "info": {
            "date": "1625966934",
            "description": "I tried making something visually similar to a Scanning Electron Microscope. I won't pretend like it's physically based or anything, but it looks pretty good!",
            "flags": 32,
            "hasliked": 0,
            "id": "7lXXzB",
            "likes": 21,
            "name": "Scanning Electron Microscope",
            "published": 3,
            "tags": [
                "fractal",
                "ray",
                "mandelbulb",
                "tracing",
                "traced",
                "tracer",
                "rt",
                "mandel",
                "trace",
                "path",
                "microscope",
                "pt",
                "electron",
                "bulb",
                "sem",
                "em",
                "microscopy"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 681
        },
        "renderpass": [
            {
                "code": "// ####### Scanning Electron Microscope #######\n// Made by Jacob Bingham (Zi7ar21) on July 10th, 2021\n\n// Last Updated on July 10th, 2021 at 15:00 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, you can find the original and possibly updated version at:\n// https://www.shadertoy.com/view/7lXXzB\n\n// \"License\":\n// You can use this code in any way you want, as long as you keep credits to things that aren't mine\n// e.g. Triple32: https://nullprogram.com/blog/2018/07/31/\n// We are programmers, not lawyers! :)\n\n/*\nI'm not sure how Scanning Electron Microscopes really produce images, but here is my best attempt\nat visually approximating an image from one.\n*/\n\n// Check out my friends!\n// michael0884\n// https://www.shadertoy.com/user/michael0884\n// loicvdb\n// https://www.shadertoy.com/user/loicvdb\n// Dumb_Psycho\n// https://www.shadertoy.com/user/Dumb_Psycho\n// peabrainiac\n// https://www.shadertoy.com/user/peabrainiac\n\n// Image Preview\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the Final Image\n    vec3 color = texel0.rgb;\n\n    // HDR Tonemapping\n    color = tonemap(color);\n\n    // Output the Image Preview\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ##### Parameters #####\n\n// Tonemap Exposure (Image Preview Only!)\n#define exposure 1.0\n\n// Camera Field of View\n#define camfov 1.0\n\n// Ray-Marching Hit Distance\n#define hitDist 1E-4\n\n// Maximum Distance\n#define maxDist 0.6\n\n// Maximum Shadow Ray Distance\n#define shadowDist 0.2\n\n// Maximum Ray-Marching Steps\n#define maxSteps 1024U\n\n// ##### Preprocessor #####\n\n// Compiler Optimization (I think I am using these properly? I will comment them by default just in case...)\n//#pragma optimize(on)\n//#pragma debug(off)\n\n// ##### Constants, Macros, and Maths #####\n\n// Minimum Digits Double Pi\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\n#define pi 3.141592653589793\n\n// Trig Function for Pi\n// (crappy compilers might make the GPU solve this every time, not ideal)\n//#define pi acos(-1.0)\n\n// Ideal 32-Bit Floating-Point Pi\n// (idk how compatible uintBitsToFloat() is, Unsigned Integers alone break on some systems I've tried)\n//#define pi uintBitsToFloat(0x40490FDBU)\n\n// Traditional Uniform Identifiers\n#define resolution iResolution\n#define frame iFrame\n\n// Sample Buffer Texel\n#define texel0 texelFetch(iChannel0, ivec2(gl_FragCoord.xy), 0)\n#define texel1 texelFetch(iChannel1, ivec2(gl_FragCoord.xy), 0)\n#define texel2 texelFetch(iChannel2, ivec2(gl_FragCoord.xy), 0)\n#define texel3 texelFetch(iChannel3, ivec2(gl_FragCoord.xy), 0)\n\n// Dot Product\nfloat dotp(vec2 vector){return dot(vector, vector);}\nfloat dotp(vec3 vector){return dot(vector, vector);}\nfloat dotp(vec4 vector){return dot(vector, vector);}\n\n// ##### Color Management #####\n\n// HDR Tonemapping Function\nvec3 tonemap(vec3 color)\n{\n    // Clamp Negatives\n    color = max(color, 0.0);\n\n    // Exposure Tonemap\n    color = 1.0-exp(-color*exposure);\n\n    // Return the Tonemapped Color\n    return clamp(color, 0.0, 1.0);\n}\n\n// ##### Random Number Generator #####\n\n// Random Number Generator Seed\nuint ns;\n#define INIT_RNG ns = uint(frame)*uint(resolution.x*resolution.y)+uint(gl_FragCoord.x+gl_FragCoord.y*resolution.x)\n\n/*\n// PCG Random: https://www.pcg-random.org/\nuvec4 pcg4(uvec4 x)\n{\n    x *= 0x0019660DU+0x3C6EF35FU;\n    x += uvec4(x.y*x.w, x.z*x.x, x.x*x.y, x.y*x.z);\n    x ^= x >> 16U;\n    x += uvec4(x.y*x.w, x.z*x.x, x.x*x.y, x.y*x.z);\n    return x;\n}\n*/\n\n/*\n// PCG Random: https://www.pcg-random.org/\nuint pcgRandom(uint x)\n{\n    uint state = x*0x2C9277B5U+0xAC564B05U;\n    uint word = ((state >> ((state >> 28U) + 4U)) ^ state) * 0x108EF2D9U;\n    return (word >> 22U) ^ word;\n}\n*/\n\n// Triple32: https://nullprogram.com/blog/2018/07/31/\nuint triple32(uint x)\n{\n    x ^= x >> 17U;\n    x *= 0xED5AD4BBU;\n    x ^= x >> 11U;\n    x *= 0xAC4C1B51U;\n    x ^= x >> 15U;\n    x *= 0x31848BABU;\n    x ^= x >> 14U;\n    return x;\n}\n\n//\nfloat rand()\n{\n    //ns = pcgRandom(ns);\n    ns = triple32(ns);\n    return float(ns)/float(0xFFFFFFFFU);\n}\n\n// Random Vectors\nvec2 rand2(){return vec2(rand (), rand());}\nvec3 rand3(){return vec3(rand2(), rand());}\nvec4 rand4(){return vec4(rand3(), rand());}\n//vec5 rand5(){return vec5(rand4(), rand());} // GLSL Sus Imposter Confirmed!? The truth is out there...\n\n// See michael0884's usage of PCG Random\n// https://www.shadertoy.com/view/wltcRS\n// https://www.shadertoy.com/view/WttyWX\n\n// Normalized Random Vectors\n// A point is equally probable to land at every point inside the volume of a sphere at the mean with a radius of sigma\nvec2 nrand2(float sigma, vec2 mean)\n{\n    vec2 z = rand2();\n    return mean+sigma*sqrt(-2.0*log(z.x   ))*vec2(cos(2.0*pi*z.y), sin(2.0*pi*z.y));\n}\n\nvec3 nrand3(float sigma, vec3 mean)\n{\n    vec4 z = rand4();\n    return mean+sigma*sqrt(-2.0*log(z.xxy ))*vec3(cos(2.0*pi*z.z), sin(2.0*pi*z.z), cos(2.0*pi*z.w));\n}\n\nvec4 nrand4(float sigma, vec4 mean)\n{\n    vec4 z = rand4();\n    return mean+sigma*sqrt(-2.0*log(z.xxyy))*vec4(cos(2.0*pi*z.z), sin(2.0*pi*z.z), cos(2.0*pi*z.w), sin(2.0*pi*z.w));\n}\n\n// Uniform Random Vectors\n// A point is equally probable to land at every point on the surface of a sphere with a radius of 1.0\nvec3 urand3()\n{\n    vec2 z = rand2();\n    vec2 r = vec2(2.0*pi*z.x, acos(2.0*z.y-1.0));\n    vec2 s = sin(r), c = cos(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ##### Rendering #####\n\n// Distance Estimator\nfloat DE(vec3 pos)\n{\n    // Transform the SDF (and dither the position to remove weird artifacts)\n    pos = (vec3(-0.2, 0.2, 1.2)+nrand3(hitDist, pos)).xzy;\n\n    // Soft Edges\n    pos = nrand3(0.0003, pos);\n\n    // Set-Up Variables\n    vec3 z = pos;\n    float dr = 1.0;\n    float r = 0.0;\n\n    // Iterate Mandelbulb\n    for(uint i = 0U; i < 32U; i++)\n    {\n        r = length(z);\n\n        // Bailout\n        if(r > 4.0)\n        {\n            break;\n        }\n\n        // Iterate the Mandelbulb\n        float theta = acos(z.z/r)*8.0;\n        float phi = atan(z.y, z.x)*8.0;\n        dr = r*r*r*r*r*r*r*8.0*dr+1.0;\n        z = r*r*r*r*r*r*r*r*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        z += pos;\n    }\n\n    // Return the Distance Estimate\n    return 0.5*log(r)*r/dr;\n}\n\n// Tetrahedron Numerical SDF Normals\nvec3 sampleNormal(vec3 pos)\n{\n    const vec2 k = vec2(-1.0, 1.0);\n    return normalize(\n    k.xxx*DE(pos+k.xxx*hitDist)+\n    k.xyy*DE(pos+k.xyy*hitDist)+\n    k.yxy*DE(pos+k.yxy*hitDist)+\n    k.yyx*DE(pos+k.yyx*hitDist));\n}\n\n// \"Light\" Transport (or would it be Electron Transport?)\nvec3 radiance(vec3 ro, vec3 rd)\n{\n    // Set-Up Variables\n    float t = 0.0;\n\n    // Ray-Marching\n    for(uint i = 0U; i < maxSteps; i++)\n    {\n        // Check if the Ray reached the background\n        if(t > maxDist)\n        {\n            return vec3(0.0);\n        }\n\n        // Compute the Distance Estimate\n        float td = DE(ro+rd*t);\n\n        // Check if the Ray hit the scene\n        if(td < hitDist)\n        {\n            // Set-Up Variables\n            //vec3 normal = sampleNormal(ro+rd*t);\n            ro = ro+rd*t;\n            //rd = urand3();\n            //rd = reflect(rd, normalize(nrand3(0.2, normal)));\n            // normalize(vec3(1.0)) == vec3(1.0/sqrt(3.0)) == vec3(0.57735026919)\n            const vec3 lightDirection = vec3(0.57735026919, 0.57735026919, 0.57735026919);\n            rd = normalize(nrand3(0.2, lightDirection)+urand3());\n            float t0 = t;\n            t = 0.0;\n\n            // Shadow Ray\n            for(uint i = 0U; i < maxSteps; i++)\n            {\n                // Check if the Shadow Ray reached the background\n                if(t > shadowDist)\n                {\n                    return vec3(4.0)*max(1.0-(t0/maxDist), 0.0);\n                }\n\n                // Compute the Distance Estimate\n                float td = DE(ro+rd*t);\n\n                // Check if the Shadow Ray hit the scene\n                if(td < hitDist)\n                {\n                    //return vec3(0.5)*max(1.0-(t/maxDist), 0.0);\n                    return vec3(0.0);\n                }\n\n                // March the Ray\n                t += td;\n            }\n\n            // Sample Expired\n            return vec3(-1.0);\n        }\n\n        // March the Ray\n        t += td;\n    }\n\n    // Sample Expired\n    return vec3(-1.0);\n}\n\n// Render and Output the Sample\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Progressive Rendering\n    fragColor = frame != 0 ? texel0 : vec4(0.0);\n\n    // Initialize Random Number Generator\n    INIT_RNG;\n\n    // Pixel Filtering\n    //fragCoord.xy += rand2();\n    fragCoord.xy = nrand2(0.5, fragCoord.xy);\n\n    // Screen UV Coordinates\n    vec2 uv = 2.0*(fragCoord.xy-0.5*resolution.xy)/max(resolution.x, resolution.y);\n\n    // Path-Tracing Bloom\n    float t = rand();\n    if(t < 0.25)\n    {\n        // Large Bloom\n        float r2 = rand();\n        uv += nrand2(0.1*r2*r2*r2, vec2(0.0));\n    }\n    else if(t < 0.5)\n    {\n        // Microbloom\n        uv += nrand2(0.005, vec2(0.0));\n    }\n\n    // Set-Up Camera Variables\n    const vec3 ro = vec3(0.0, 0.0, 0.0);\n    const mat3 rotmat = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    vec3 rd = normalize(vec3(camfov*uv, -1.0)*rotmat);\n\n    // Render the Sample\n    vec3 color = radiance(ro, rd);\n\n    // Output the Rendered Sample\n    fragColor += any(lessThan(color, vec3(0.0))) || any(isinf(color)) || any(isnan(color)) ? vec4(0.0) : vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ##### Image Export #####\n// On Shadertoy, click the image icon in the bottom right of the editor to save a Floating-Point OpenEXR Image\n// Be aware it won't be tonemapped, because good image editors such as GIMP apply gamma correction during editing\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the Progressive Rendering Buffer\n    vec4 texel = texel0;\n\n    // Output the Final Image\n    fragColor = vec4(texel.a != 0.0 ? texel.rgb/texel.a : texel.rgb, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}