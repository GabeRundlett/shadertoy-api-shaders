{
    "Shader": {
        "info": {
            "date": "1488286653",
            "description": "Using a cheap - but effective - hack to produce antialiased-looking contour lines without the need for supersampling.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldscWH",
            "likes": 172,
            "name": "Smooth Noise Contours",
            "published": 3,
            "tags": [
                "noise",
                "simplex",
                "antialias",
                "contour"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 9767
        },
        "renderpass": [
            {
                "code": "/*\n\n\tSmooth Noise Contours\n\t---------------------\n\n    Using a cheap - but effective - hack to produce antialiased-looking contour lines without the \n\tneed for supersampling. I had Airtight's elegant \"Cartoon Fire\" shader in mind when making this, \n\tand have provided a link to it below. \n\n\tI've always liked the abstract look of functional contour segments, lines, etc. There's a couple \n\tof ways to produce them, depending on the look you're going for. One method involves combining\n\tyour function value (noise, Voronoi, etc) with the \"fract\" function and the other involves \n\tstepping the function values with the \"floor\" function.\n\n    Each looks all right, except for the aliasing. You could take care of that with supersampling,\n\tbut it's a lot of work for the GPU, so I figured there might be a way to combine the \"smoothstep\" \n\tand \"fwidth\" functions to produce a smooth \"fract\" function. Since \"x - fract(x)\" is \"floor(x),\" \n\tyou'd get the \"floor\" function too.\n\n\tAfter playing around for a while, I came up with something that seems to work. As you can see,\n\tthe partitioned contours look relatively jaggy free, even after the application of border lines \n\tand highlighting.\n\n\tAnyway, the smooth fract \"sFract\" and complimentary smooth floor \"sFloor\" functions are below.\n\tThey haven't undergone extensive testing, so I'd use them cautiously. :)\n\n\tThe rest is just coloring and highlighting. I went for a simplistic cardboard cutout, vector-graphic\n\tstyle.\n\n\tSimilar examples:\n\n    Cartoon Fire - airtight\n\thttps://www.shadertoy.com/view/lsscWr\n\n    // More sophisticated smoothing method, but I might switch to this one in future.\n\tSmooth Voronoi Contours - Shane\n    https://www.shadertoy.com/view/4sdXDX\n\n\n*/\n\n\n// Variable to a keep a copy of the noise value prior to palettization. Used to run a soft gradient \n// over the surface, just to break things up a little.\nfloat ns;\n\n\n//float sFract(float x, float sm){ float fx = fract(x); return fx - smoothstep(fwidth(x)*sm, 0., 1. - fx); }\n//float sFract(float x, float sm){ float fx = fract(x); return min(fx, fx*(1. - fx)/fwidth(x)/sm); }\n\n// Based on Ollj's smooth \"fract\" formula.\nfloat sFract(float x, float sm){\n    \n    // Extra smoothing factor. \"1\" is the norm.\n    const float sf = 1.; \n    \n    // The hardware \"fwidth\" is cheap, but you could take the expensive route and\n    // calculate it by hand if more quality was required.\n    vec2 u = vec2(x, fwidth(x)*sf*sm);\n    \n    // Ollj's original formula with a transcendental term omitted.\n    u.x = fract(u.x);\n    u += (1. - 2.*u)*step(u.y, u.x);\n    return clamp(1. - u.x/u.y, 0., 1.); // Cos term ommitted.\n}\n\n\n\n// Only correct for nonnegative values, but in this example, numbers aren't negative.\nfloat sFloor(float x){ return x - sFract(x, 1.); } \n\n// Standard hue rotation formula with a bit of streamlining. \nvec3 rotHue(vec3 p, float a){\n\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr, 0., 1.);\n}\n\n\n/*\n// Fabrices concise, 2D rotation formula.\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// Dave's hash function. More reliable with large values, but will still eventually break down.\n//\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// vec3 to vec3.\nvec3 hash33(vec3 p){\n\n\tp = fract(p * vec3(.1031, .1030, .0973));\n    p += dot(p, p.yxz + 19.19);\n    p = fract((p.xxy + p.yxx)*p.zyx)*2. - 1.;\n    return p;\n    \n    // Note the \"mod\" call. Slower, but ensures accuracy with large time values.\n    //mat2  m = r2(mod(iTime*2., 6.2831853));\t\n\t//p.xy = m * p.xy;//rotate gradient vector\n    //p.yz = m * p.yz;//rotate gradient vector\n    //p.xz = m * p.xz;//rotate gradient vector\n    \n    //mat3 m = r3(mod(iTime*2., 6.2831853));\t\n    //vec3 th = mod(vec3(.31, .53, .97) + iTime*2., 6.2831853);\n    //mat3 m = r3(th.x, th.y, th.z);\n    //p *= m;\n\treturn p;\n\n}\n*/\n\n// vec3 to vec3 hash algorithm.\nvec3 hash33(vec3 p){ \n\n    // Faster, but doesn't disperse things quite as nicely as the block below it. However, when framerate\n    // is an issue, and it often is, this is the one to use. Basically, it's a tweaked amalgamation I put\n    // together, based on a couple of other random algorithms I've seen around... so use it with caution,\n    // because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; // return fract(vec3(64, 8, 1)*32768.0*n)*2.-1.; \n\n    // I'll assume the following came from IQ.\n    //p = vec3( dot(p, vec3(127.1, 311.7, 74.7)), dot(p, vec3(269.5, 183.3, 246.1)), \n    //          dot(p, vec3(113.5, 271.9, 124.6)));\n    //return (fract(sin(p)*43758.5453)*2. - 1.);\n\n}\n\n\n\n// Cheap, streamlined 3D Simplex noise... of sorts. I cut a few corners, so it's not perfect, but it's\n// artifact free and does the job. I gave it a different name, so that it wouldn't be mistaken for\n// the real thing.\n// \n// Credits: Ken Perlin, the inventor of Simplex noise, of course. Stefan Gustavson's paper - \n// \"Simplex Noise Demystified,\" IQ, other \"ShaderToy.com\" people, etc.\nfloat tetraNoise(in vec3 p){\n\n    // Skewing the cubic grid, then determining the first vertice and fractional position.\n    vec3 i = floor(p + dot(p, vec3(1./3.)) );  p -= i - dot(i, vec3(1./6.));\n    \n    // Breaking the skewed cube into tetrahedra with partitioning planes, then determining which side of the \n    // intersecting planes the skewed point is on. Ie: Determining which tetrahedron the point is in.\n    vec3 i1 = step(p.yzx, p), i2 = max(i1, 1. - i1.zxy); i1 = min(i1, 1. - i1.zxy);    \n    \n    // Using the above to calculate the other three vertices -- Now we have all four tetrahedral vertices.\n    // Technically, these are the vectors from \"p\" to the vertices, but you know what I mean. :)\n    vec3 p1 = p - i1 + 1./6., p2 = p - i2 + 1./3., p3 = p - .5;\n  \n\n    // 3D simplex falloff - based on the squared distance from the fractional position \"p\" within the \n    // tetrahedron to the four vertice points of the tetrahedron. \n    vec4 v = max(.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    \n    // Dotting the fractional position with a random vector, generated for each corner, in order to determine \n    // the weighted contribution distribution... Kind of. Just for the record, you can do a non-gradient, value \n    // version that works almost as well.\n    vec4 d = vec4(dot(p, hash33(i)), dot(p1, hash33(i + i1)), dot(p2, hash33(i + i2)), dot(p3, hash33(i + 1.)));\n     \n     \n    // Simplex noise... Not really, but close enough. :)\n    return clamp(dot(d, v*v*v*8.)*1.732 + .5, 0., 1.); // Not sure if clamping is necessary. Might be overkill.\n\n}\n\n\n// The function value. In this case, slightly-tapered, quantized Simplex noise.\nfloat func(vec2 p){\n    \n    // The noise value.\n    float n = tetraNoise(vec3(p.x*4., p.y*4., 0) - vec3(0, .25, .5)*iTime);\n    \n    // A tapering function, similar in principle to a smooth combine. Used to mutate or shape \n    // the value above. This one tapers it off into an oval shape and punches in a few extra holes.\n    // Airtight uses a more interesting triangular version in his \"Cartoon Fire\" shader.\n    float taper = .1 + dot(p, p*vec2(.35, 1));\n\tn = max(n - taper, 0.)/max(1. - taper, .0001);\n    \n    // Saving the noise value prior to palettization. Used for a bit of gradient highlighting.\n    ns = n; \n    \n    // I remember reasoning to myself that the following would take a continuous function ranging\n    // from zero to one, then palettize it over \"palNum\" discreet values between zero and one\n    // inclusive. It seems to work, but if my logic is lacking (and it often is), feel free to \n    // let me know. :)\n    const float palNum = 9.; \n    // The range should strictly fall between zero and one, but for some crazy reason, numbers fall\n    // outside the range, so I've had to clamp it. I know the computer is never wrong, so I'm \n    // probably overlooking something. Having said that, I don't trust the GPU \"fract\" function much.\n    //return clamp(sFloor(n*(palNum - .001))/(palNum - 1.), 0., 1.);\n    return n*.25 + clamp(sFloor(n*(palNum - .001))/(palNum - 1.), 0., 1.)*.75;\n    \n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Screen coordinates.\n\tvec2 u = (fragCoord.xy - iResolution.xy*.5)/iResolution.y;\n    \n    // Function value.\n    float f = func(u);\n    float ssd = ns; // Saving the unpalettized noise value to add a little gradient to the color, etc.\n    \n    // Four sample values around the original. Used for edging and highlighting.\n    vec2 e = vec2(1.5/iResolution.y, 0);\n    float fxl = func(u + e.xy);\n    float fxr = func(u - e.xy);\n    float fyt = func(u + e.yx);\n    float fyb = func(u - e.yx);\n    \n    // Colorizing the function value, and applying some hue rotation based on position.\n    // Most of it was made up.\n    vec3 col = pow(min(vec3(1.5, 1, 1)*(f*.7 + ssd*.35), 1.), vec3(1, 2., 10)*2.) + .01;\n    col = rotHue(col, -.25+.4*length(u));\n\n    // Applying the dark edges.\n    col *= max(1. - (abs(fxl - fxr) + abs(fyt - fyb))*5., 0.);\n    //col *= max(1. - length(vec2(fxl, fyt) - vec2(fxr, fyb))*7., 0.);\n    // Resampling with a slightly larger spread to provide some highlighting.\n    fxl = func(u + e.xy*1.5);\n    fyt = func(u + e.yx*1.5);\n    col += vec3(.5, .7, 1)*(max(f - fyt, 0.) + max(f - fxl, 0.))*ssd*10.;\n    \n    // Subtle, bluish vignette.\n    //u = fragCoord/iResolution.xy;\n    //col = mix(vec3(0, .1, 1), col, pow( 16.0*u.x*u.y*(1.0-u.x)*(1.0-u.y) , .125)*.15 + .85);\n\n \t\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}