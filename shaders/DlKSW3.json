{
    "Shader": {
        "info": {
            "date": "1686450488",
            "description": "All year long I'm going to just focus on truchet tiles and the likes! (mouseable)\nIf slow turn AA off (AA 1)\nSquare truchet with offset to match corner roundness ",
            "flags": 0,
            "hasliked": 0,
            "id": "DlKSW3",
            "likes": 13,
            "name": "Year of Truchets #034",
            "published": 3,
            "tags": [
                "raymarching",
                "square",
                "truchet"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 194
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #034\n    06/11/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    Square truchet with offset to match corner roundness \n    \n*/\n\n// If slow turn AA off (AA 1)\n#define ZERO (min(iFrame,0))\n#define AA 2\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    1e-4\n#define MAX_DIST    20.\n\nvec3 hp,hitpoint;\nfloat flow,time,tmod,ga1,ga2,ga3,ga4;\nmat2 r90;\n\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 a) { return fract(sin(dot(a,vec2(21.23,41.232)))*4123.2323); }\nfloat lsp(float b, float e, float t) { return clamp((t-b)/(e-b),0.,1.); }\n//@iq\nfloat box(vec2 p, vec2 b) { vec2 d = abs(p)-b; return length(max(d,0.)) + min(max(d.x,d.y),0.);}\nfloat opx(in float d, in float z, in float h){\n    vec2 w = vec2(d,abs(z)-h);return min(max(w.x, w.y),0.)+length(max(w,0.));\n}\n\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0);\n    p.x += flow;\n    \n    vec2 uv = p.xz*.45;\n    float pv= p.y*.45;\n    \n    vec2 id = floor(uv), q = fract(uv)-.5;\n    vec2 ik = floor(uv-.5), k = fract(uv-.5)-.5;\n    \n    float hs = hash21(id*32.123);\n    if(fract(hs*67.913)>.5) q.xy *= r90;\n\n    const float fs = .15, pf = .45, wd = .0751;\n    \n    vec2 p2 = vec2(length(q.xy-pf),length(q.xy+pf));\n    vec2 r = p2.x<p2.y? q.xy-pf : q.yx+pf;\n\n    // main pattern\n    float d = abs(box(r,vec2(.15))-.3)-wd;\n    \n    // alt pattern\n    float tk=1e5, d3=1e5;\n    if(hs>.7) {\n        tk = length(q.x)-wd;\n        d = length(q.y)-wd;\n    }\n    d=abs(d)-.03;\n    float d1 = opx(d,p.y,.085);\n    if(d1<res.x) {\n        res=vec2(d1,2.);\n        hp=p;\n    }\n\n    float ff = fs*cos(q.y*PI2)+fs;\n    float py = fract(hs*47.93)>.45? p.y-ff : p.y+ff;\n    tk=abs(tk)-.03;\n    if(hs>.7) { d3 = opx(tk,py,.085); }\n    if(d3<res.x) {\n        res=vec2(d3,2.);\n        hp=p;\n    }\n    \n    float fa = ik.x+ik.y*.5+T*.5;\n    float ss = .25*sin(fa), st = .25*cos(fa);\n    float b1 = length(vec3(k.x+st,pv+.175,k.y+ss))-.125;\n    if(b1<res.x) {\n        res=vec2(b1,4.);\n        hp=p;\n    }\n\n    float d2 = p.y+.75;\n    if(d2<res.x) {\n        res=vec2(d2,1.);\n        hp=p;\n    }\n\n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, inout bool hit) {\n    float d=0., m = 0.;\n    for(int i=0;i<80;i++) {\n        vec2 t = map(p);\n        if(t.x<MIN_DIST) hit = true;\n        d+= i<15? t.x*.5 : t.x;\n        m = t.y;\n        p = ro + rd * d;\n        if(d>MAX_DIST) break;\n    } \n    return vec2(d,m);\n}\n\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    n = max(abs(n), MIN_DIST);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\n//@iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1., 0., 1.0 );\n    return c.z * mix( vec3(1), rgb, c.y);\n}\n\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, int bnc, inout float d) {\n        \n    vec3 RC = vec3(0),p = ro;\n    float m = 0., fA = 0., f = 0.;\n    \n    bool hit = false;\n    vec2 ray = marcher(ro,rd,p,hit);\n    \n    d = ray.x, m = ray.y;\n    hitpoint = hp;\n    \n    if(hit)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(-2,12,1);\n        vec3 l = normalize(lpos-p);\n\n        float diff = clamp(dot(n,l),0.,1.);\n\n        float shdw = 1., t = .1;\n        for( int i =0; i<14; i++ ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 12.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>8. ) break;\n        }\n        diff = mix(diff,diff*shdw,.75);\n\n        //vec3 view = normalize(p-ro);\n        vec3 ret = reflect(normalize(lpos),n);\n        float spec =  0.45 * pow(max(dot(l, ret), 0.), 24.);\n\n        vec3 h = vec3(.5);\n        \n        vec3 SPC = hsv2rgb(vec3((p.x+p.z)*.025,1.,.5));\n        \n        if(m==4.) {\n            h = mix(SPC,vec3(.75),.175);\n            ref = SPC;\n        }\n        if(m==2.) {\n            vec3 BC = tex3D(iChannel0,hitpoint*.5,n).rgb;\n            h = mix(vec3(.5),BC,.75);\n            ref = vec3(1);\n        }\n        if(m==1.) {\n            h = tex3D(iChannel1,hitpoint*.25,n).rgb*vec3(0.518,0.596,0.624);\n            ref = vec3(.98);\n        }\n\n        \n        RC = h * diff + (spec*SPC);\n        ro = p+n*.01;\n        rd = reflect(rd,n);\n        \n    } else {\n        RC = vec3(.05);\n    } \n\n    return clamp(RC,vec3(0),vec3(1));\n}\n\nvec3 renderALL( in vec2 uv, in vec2 F )\n{   \n\n    //wipe\n    float xln = ga1-(.025*sin(uv.y*25.+T*5.));\n    float zoom = 5.5,tilt = .7;\n    if(uv.x>xln) {zoom = 7.75;tilt = 1.5707;}\n    \n    vec3 ro = vec3(0,-1,zoom);\n    vec3 rd = normalize(vec3(uv,-1));\n    \n    // mouse //\n    float x = M.xy==vec2(0) || M.z<0. ? 0. : -(M.y/R.y*.2-.1)*PI;\n    float y = M.xy==vec2(0) || M.z<0. ? 0. : -(M.x/R.x*1.-.5)*PI;\n\n    mat2 rx = rot(-tilt-x),ry = rot(-.78+.5*sin(T*.075)-y);\n    \n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C=vec3(0), RC=vec3(0), ref=vec3(0), fill=vec3(.95);\n    vec3 p = ro;\n    \n    float m = 0., d = 0., f = 0.;\n\n    int bnc = 2;\n    for(int i = 0; i < bnc; i++){\n        RC = render(ro,rd,ref,bnc-i,d);\n        C += RC*fill;\n        fill = ref; \n        if(i==0)f=d;\n    }\n    \n    C = mix(vec3(.1),C,exp(-.0005*f*f*f));\n    if(uv.x>xln && uv.x-.01<xln)C=vec3(1);\n    return C;\n}\n\n// AA from @iq https://www.shadertoy.com/view/3lsSzf\nvoid mainImage( out vec4 O, in vec2 F )\n{\n\n    r90=rot(1.5707);\n    flow = T*.5;\n    \n    tmod = mod(flow, 10.);\n    float t1 = lsp(3.,  5., tmod);\n    float t2 = lsp(8., 10., tmod);\n    ga1 = ((t1-t2)*2.2)-1.1;\n    \n    vec3 C = vec3(0.);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (-R.xy + 2.*(F+o))/max(R.x,R.y);\n#else    \n        vec2 uv = (-R.xy + 2.*F)/max(R.x,R.y);\n#endif\n\n        vec3 color = renderALL(uv,F);\n        // compress        \n        color = 1.35*color/(1.+color);\n        // gamma\n        color = pow( color, vec3(.4545) );\n\n        C += color;\n#if AA>1\n    }\n    C /= float(AA*AA);\n#endif\n    // Output to screen\n    O = vec4(C,1.);\n}\n//end",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}