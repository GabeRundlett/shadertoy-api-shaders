{
    "Shader": {
        "info": {
            "date": "1497364136",
            "description": "another non periodic tiling experiment",
            "flags": 0,
            "hasliked": 0,
            "id": "lssfzX",
            "likes": 49,
            "name": "silver maze",
            "published": 3,
            "tags": [
                "truchet",
                "maze",
                "tiles"
            ],
            "usePreview": 0,
            "username": "flockaroo",
            "viewed": 1459
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// silver maze\n\n// some more non periodic tilings experiments\n\nvec2 tr_i(vec2 p)\n{\n    return (p*vec2(1,.5*sqrt(3.))+vec2(.5*p.y,0));\n}\n\nvec2 tr(vec2 p)\n{\n    return (p-vec2(p.y/sqrt(3.),0))/vec2(1,.5*sqrt(3.));\n}\n\nvoid getTri(vec2 p, inout vec2 p1, inout vec2 p2, inout vec2 p3, float size)\n{\n    vec2 pt=tr(p)/size;\n    vec2 pf=floor(pt);\n    vec2 pc=ceil(pt);\n    p1=vec2(pf.x,pc.y);\n    p2=vec2(pc.x,pf.y);\n    p3=pc;\n    if(dot(pt-pf,vec2(1))<1.) p3=pf;\n    p1=tr_i(p1)*size;\n    p2=tr_i(p2)*size;\n    p3=tr_i(p3)*size;\n}\n\nfloat tri01(float x)\n{\n    return abs(fract(x)-.5)*2.;\n}\n\nvec4 getRand(vec2 p)\n{\n    vec2 texc=(floor(p)+.5)/iChannelResolution[0].xy;\n    return texture(iChannel0,texc);\n}\n\n// get some 3d rand values by multiplying 2d rand in xy, yz, zx plane\nvec4 getRand(vec3 pos)\n{\n    vec4 r = vec4(1.0);\n    r*=texture(iChannel0,pos.xy)*2.-1.;\n    r*=texture(iChannel0,pos.xz)*2.-1.;\n    r*=texture(iChannel0,pos.zy)*2.-1.;\n    return r;\n}\n\n#define PI 3.14159265\n\n// 2d distance field of pattern\nfloat dist(vec2 p, float period, float size)\n{\n    vec2 p1,p2,p3;\n    getTri(p,p1,p2,p3,size);\n    vec4 rnd=getRand((p1+p2+p3)/3./size*2.);\n\tfloat r=rnd.x;\n\tfloat r2=rnd.y;\n\tfloat r3=rnd.z;\n    if(fract(r*2.)>.3333) { vec2 d=p3; p3=p2; p2=p1; p1=d; }\n    if(fract(r*2.)>.6666) { vec2 d=p3; p3=p2; p2=p1; p1=d; }\n    float d = 10000.;\n    float ang;\n    ang = acos(dot(normalize(p-p1),normalize(p3-p1)));\n    d = min(d,length(p-p1)+1.0*(floor(r2*2.)*2.-1.)*period*ang/PI*3.);\n    ang = acos(dot(normalize(p-p2),normalize(p3-p2)));\n    d = min(d,length(p-p2)+1.0*(floor(r3*2.)*2.-1.)*period*ang/PI*3.);\n    float arg=(d-.5*size)/period;\n    return tri01(arg)*.5*period;\n}\n\n// final distance funtion\nfloat dist(vec3 pos)\n{\n    pos-=.00012*getRand(pos*3.0*.7).xyz;\n    pos-=.00030*getRand(pos*1.3*.7).xyz;\n    pos-=.00080*getRand(pos*0.5*.7).xyz;\n    vec3 p1,p2,p3;\n    float d = 10000.;\n    \n    // plane\n\td=min(d,pos.z+.1);\n    \n    float d2d=dist(pos.xy,.16,.8);\n    d=min(d,sqrt(d2d*d2d+pos.z*pos.z)-.025);\n    \n    return d;\n}\n\nvec3 getGrad(vec3 pos, float eps)\n{\n    vec2 d=vec2(eps,0);\n    float d0=dist(pos);\n    return vec3(dist(pos+d.xyy)-d0,\n                dist(pos+d.yxy)-d0,\n                dist(pos+d.yyx)-d0)/eps;\n                \n}\n\n// march it...\nvec4 march(inout vec3 pos, vec3 dir)\n{\n    // cull the sphere\n    //if(length(pos-dir*dot(dir,pos))>1.05) \n    //\treturn vec4(0,0,0,1);\n    \n    float eps=0.001;\n    float bg=1.0;\n    for(int cnt=0;cnt<132;cnt++)\n    {\n        float d = dist(pos);\n        pos+=d*dir;\n        if(d<eps) { bg=0.0; break; }\n    }\n    vec3 n = getGrad(pos,.001);\n    return vec4(n,bg); // .w=1 => background\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // screen coord -1..1\n    float aspect=iResolution.y/iResolution.x;\n    vec2 sc = (fragCoord.xy/iResolution.xy)*2.-1.;\n    // viewer position\n    float phi = iTime*.08;\n    vec3 pos = 17.*vec3(cos(phi),sin(phi),.3);\n    // pixel view direction--\n    vec3 fwd   = normalize(-pos.xyz*vec3(1,1,0)+pos.yxz*vec3(-1,1,0)*.15*sin(iTime*.3)+vec3(1,1,-17));\n    vec3 right = normalize(fwd.yxz*vec3(1,-1,0));\n    vec3 up    = normalize(cross(right,fwd));\n    vec3 dir = normalize(fwd*2.6+sc.x*right+sc.y*up*aspect);\n    // rotate view around x,z\n    \n    // march it...\n   \tvec4 n=march(pos,dir);\n    float bg=n.w;\n        \n    // calc some ambient occlusion\n    float ao=1.;\n    #if 0\n    // calc simple ao by stepping along radius\n    ao*=dist(pos*1.02)/.02;\n    ao*=dist(pos*1.05)/.05;\n    ao*=dist(pos*1.1)/.1;\n    #else\n    // calc ao by stepping along normal\n    ao*=dist(pos+n.xyz*.02)/.02;\n    ao*=dist(pos+n.xyz*.05)/.05;\n    ao*=dist(pos+n.xyz*.10)/.10;\n    #endif\n    // adjust contrast of ao\n    ao=pow(ao,.4);\n    \n    // reflection dir\n    vec3 R = dir-2.0*dot(dir,n.xyz)*n.xyz;\n    R = R.yzx;\n    \n    vec3 c = vec3(1);\n    // simply add some parts of the normal to the color\n    // gives impression of 3 lights from different dir with different color temperature\n    c += n.xyz*.1+.1;\n\n    //  reflection of cubemap\n    c *= texture(iChannel1,R).xyz*.7+.4;\n    \n    // add some depth darkening\n\t//c*=clamp(-dot(dir,pos)*.7+.7, .2, 1.);\n    \n    // apply ambient occlusion\n    c*=ao;\n    \n    // apply background\n    if(bg>=.5) c=vec3(.5,.6,.75)-.17;\n    \n    // vignetting\n    float vign = (1.1-.35*dot(sc.xy,sc.xy));\n    \n\tfragColor = vec4(c*vign,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}