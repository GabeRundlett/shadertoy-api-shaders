{
    "Shader": {
        "info": {
            "date": "1559039892",
            "description": "crunching \nhttps://www.shadertoy.com/view/4ljGDd\nwithin\nhttps://www.shadertoy.com/view/ltj3Wc\nfor\nhttps://www.shadertoy.com/view/WtfGRS\n",
            "flags": 32,
            "hasliked": 0,
            "id": "3tSGDz",
            "likes": 16,
            "name": "UI2AD37 amalgate",
            "published": 3,
            "tags": [
                "filter",
                "gradient",
                "ik",
                "derivative",
                "ui",
                "ad",
                "automaticdifferentiation",
                "superprim",
                "calculus",
                "csgsuperprim"
            ],
            "usePreview": 1,
            "username": "ollj",
            "viewed": 1192
        },
        "renderpass": [
            {
                "code": "//MainImage(),iChannel0=BuffA,iChannel1=BuffB,iChannel2=BuffC,iChannel3=BuffD\n\n//this amalgation is a bit messy\n//the CommonTab has toggles between 3 scenes\n//below test is mostly about the [automatic differentiation] scene\n\n/* \ndrag dots to see effect of dotPosition.xy\nclick screenspace-void to add a dot (dot params overwrite (animated) default parames)\nerase dots by moving them into the red square\n- Erasing a dot that is not the last dot may cause confusion (no LinkedList structure)\n-, because dots will stay in place, but their indexes may decrease by -1\n- , and the effect of a dot is set by its index, with parameters from its position. \n\ntodo: if(dot gets ersed) properrly rearrange dot indizies)\n\ndot[0] is left dot, sets camera position|angle marameters (naive dumb camera matrix)\ndot[1] is top Left, sets object0 scale.xy\ndot[2] is bottom  , sets object0 scale.z and hole-parameter.y  (klick to add dot)\ndot[3] sets object0 2 roundness parameters (torus/lathe like)\ndot[4] sets object1 scale.xy\ndot[5] sets object1 scale.z and hole-parameter.y  (klick to add dot)\ndot[6] sets object1 2 roundness parameters (torus/lathe like)\ndot[6] sets object1 offset.xy\ndot[7] sets object1 offset.z and a UnionRoundness\n\nSurface normals are analytic [automatic differentiation] \nfirst derivatives over 3 domains, faster and more precise (near sharp corners)\nDebugging of [AD] just needs a merger with [UI], so here it is:\nan easly release of an incomplete merger of [AD26] with [AD33]\n\n- - tags:\n- 4 tabs are 4 plugins, with a shared commonTab library.\n\nAD,UI,IK,superprim,CSGsuperprim,calculus,filter,gradient,derivative,automaticdifferentiation\nsuperprim,uberprim\nUI,diegetic,mouse,parametric,ui,widget,draganddrop,spartial,canvas\nAD,calculus,filter,partialDerivative,TotalDerivative,normal,curvature,laplache\nIK,parabola,bezier,root,projection,\nCA,arclength,calligraphy,sweepAmt,EliteBeatAgents,OsuTatakaeOuendan\n\n/WtfGDM screenshots:\nhttps://twitter.com/ollj/status/1123090411814379520\n\nchild       38: https://www.shadertoy.com/view/3l2GDR\nself   UI2AD37: https://www.shadertoy.com/view/3tSGDz (minor edit)\nparent UI2AD36: https://www.shadertoy.com/view/ttfGRB (skippable)\nparent UI2AD35: https://www.shadertoy.com/view/WtfGRS (milestone)\nparent UI2AD26: https://www.shadertoy.com/view/WtfGDM (4d 3rd derivatives & dragAndDropUi)\nparent    AD33: https://www.shadertoy.com/view/ttX3D8 (1d 3rd derivatives)\nparent    AD26: https://www.shadertoy.com/view/WtXGW4 (3d 1st derivatives)\nparent UI1    : https://www.shadertoy.com/view/Xt3BzX (dragAndDropUi)\nparent UI0    : https://www.shadertoy.com/view/4dtSRn (dragAndDropUi origin)\n\nThe image tab only cares to explain the final composition\nand on very abstract descriptions of the amalgation:\n\nThis is an amalgation of multiple plugins.\nWhos (shared) components mix mostly into the CommonTab\nand into some (remote) compositing/debugging calls from the imageTab.\nJust like a [frankensteins monster] has only one brain and one heart.\n\nEach plugin has its own family tree history and context/tags\nBut these often overlap a lot.\ntherefore all of that is moved to the CommonTab, over time.\n*/\n\nvoid drawDragDots(inout vec4 s,vec2 u,inout vec2 e//loop trough all dots and accumulate colors.\n){v0 f=0.\n ;for(v0 i=0.;i<maxCount;++i\n ){if(i>=s.y)break//bound by number of instantiated UIDots\n  ;f=dd(u-bufDrag(i).xy)\n  ;e=vec2(mix(e.x,i,step(abs(f),(e.y*e.y))),mi(e.y,sqrt(f)));}\n ;}\n\n//ESSENTIAL instant feedback: highlight what is dragged\nvec4 dotColor(vec4 s,v0 r\n){if (r==s.x)return mix(vec4(.5,1,1,1),vec4(0,1,0,1),step(0.,s.z))//highlight last klicked/dragged\n ;return vec4(.5,.5,1,1);}//all other dots\n\nvec4 iDiegeticUIshow(vec2 u){\n ;vec4 c=vec4(0),s=bufDrag(statePos)\n ;vec2 e=vec2(0.,UiDotRadius+UiDotBorder)\n //e.x is the inner bound of a dot's black border\n //e.y is the outer bound of a dot's black border \n ;drawDragDots(s,u,e)\n ;if(e.y<UiDotRadius+UiDotBorder\n ){e.y-=UiDotRadius\n  ;     c=vec4(0,0,0,1)  *smoothstep( UiDotBorder,0.         ,(abs(-e.y)))\n  ;vec4 d=dotColor(s,e.x)*smoothstep(-UiDotBorder,UiDotBorder,     -e.y)\n  ;c=pdOver(c,d)*.4\n ;}//else return vec4(1,0,0,1)//to debug above boundary\n ;if(inRect(u,deleteRect))c.xyz=mix(c.xyz,vec3(1,0,0),.3)\n ;return c;}\n\n\n//iCanBez (iCanvas iBezieer merged in UI2AD37)\n/*\niChannel0=BuffA\niChannel1=BuffB\niChannel2=BuffC\niChannel3=BuffD\n*/\n\n/*\ntags:\nbezier,quadratic,parabola,\n\nnote:\nhttps://math.stackexchange.com/questions/12186/arc-length-of-bÃ©zier-curves\nis tricky but usseful\n*/\n\n//set a viewFrame zoom/FoV-factor, has all turm() parameters, but is often a constant\n//convention insists on parameters, yo that you can set zoom by other data\n\nv0 viewZoom(v0 t,v1 u,v2 r,v3 m){return 1.;}\n#define viewzoom (1./(cos(iTime)*.5+.75))\n\n//restructure of https://www.shadertoy.com/view/XtdyDn\n//this reuses inout values, instead of declating new variables, where posisble\n//this splits BezierQuadParabola() off of BezierQuad()\n\n\n//#define sat(a) clamp(a,0.,1.)\n\n\n//bool rea(v0 s,v0 b,v0 e){b-=s;return(abs(s-.5*b)*e<abs(b));}\n\n\n\n//#define Aa min(iResolution.x,iResolution.y)\n\nv1 sort(v1 a){return v1(min(a.x,a.y),max(a.x,a.y));}\n\n\n\nv3 demoBezierQuad(v0 t,v1 u,v2 r,v3 m//iCanBez (iCanvas iBezieer merged in UI2AD37)\n){\n ;v3 c=v3(0,0,0,1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y      \n ;if(m.z<=0.)m.xy=v1(cos(t),sin(t*1.61))\n ;v3 o=v3(0,0,0,1)\n ;v1 p0=v1(-cos(t*.5),sin(t*0.9))*.4\n ,p1=v1(-cos(t*2.3),sin(t*1.1))\n ,p2=v1(cos(t*1.3)*.4,-sin(t*.3)*.3)*.5\n ;p0*=rot(sin(t)-t)\n ;p1*=rot(sin(t*.7))\n ;p2*=rot(cos(t*1.8)+t)\n ;//lines above are a lot like parent: https://www.shadertoy.com/view/XtdyDn \n ;//liney below may overwrite values from above.\n ;//lines below set 3 CVs by bufDrag , pointCount is number ot points that are set by bufDrag\n ;//and 2 more parameters that define an closed interval along the defined bezier/parabola\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;//if (one point exist) it overwrites p0\n ;if(pointCount >0.)p0=fra(t,bufDrag(0.).xy,r,m)*viewzoom//this bijection is painful\n ;//if(2 points exist) 2nd point overwrites p1\n ;if(pointCount >1.\n ){p1=fra(t,bufDrag(1.).xy,r,m)*viewzoom//... Buffa should just store local coordinates!\n ;} \n //if(3 points exist) 3rd point overwrites p2\n ;if(pointCount >2.\n ){p2=fra(t,bufDrag(2.).xy,r,m)*viewzoom\n ;}  \n //if (4 points exist) 4th points .y overwrites m.y\n ;if(pointCount >3.//point4 sets one point of the red/yellow arc\n ){\n  ;v1 p3=fra(t,bufDrag(3.).xy,r,m)*viewzoom\n  ;m.x=mix(.5,1.,p3.y/viewzoom+.5)\n  ;//m.x=(m.x*2.)\n  ;c.w=segment(u,p3,mix(p0,p2,p3.y/viewzoom+.5))//c.w for a yellow line for an  associative connection\n  ;//c.w=segment(u,p3,v1(0))//c.w for a yellow line for an  associative connection\n  ;} \n //if (5 points exist) 5th point overwrites m.z\n ;if(pointCount>4.\n ){v1 p4=fra(t,bufDrag(4.).xy,r,m)*viewzoom\n  ;m.y=mix(.5,1.,p4.y/viewzoom+.5)\n  ;c.w=min(c.w,segment(u,p4,mix(p0,p2,p4.y/viewzoom+.5)))//c.w for a yellow line for an  associative connection\n ;}\n ;c.x=segment(u,p0,p1)\n ;c.x=min(c.x,segment(u,p1,p2))\n ;c.x=min(c.x,segment(u,p0,p2))                //red triangle shows 3 CVs \n ;c.y=BezierQuadParabola(u,p0,p1,p2)           //green shows parabola\n ;m.xy=sort(m.xy)                               //m.x<m.y for BezierQuadGeneral()\n ;c.z=BezierQuadGeneral (u,p0,p1,p2,2.*m.xy-1.)//blue shows bezier segment of parabola\n ;//c.z=BezierQuad        (u,p0,p1,p2)         //blue shows bezier segment of parabola\n ;//o.z+=.2*smoothstep(1.5,0.,(c.x-10./r.y)/fwidth(c.x))//this is just worse; https://www.shadertoy.com/view/XtdyDn\n ;c.z -=9./Aa(t,u,r,m) //line thickness\n ;c.xw-=2./Aa(t,u,r,m) \n ;c.y -=4./Aa(t,u,r,m)\n ;c=smoothstep(2./Aa(t,u,r,m),-2./Aa(t,u,r,m),c) //checking if gradient is fine (and not a squared distance or something distorted/taxicap)\n ;c*=.3\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;return c;}\n\n/**/\n\nv3 demoProject(v0 t,v1 u,v2 r,v3 m\n){u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v3 c=v3(1)\n ;v1 l0=v1(-.4)\n ;v1 l1=v1( .7)\n ;v1 p0=v1(.5,-.5)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){p0=fra(t,bufDrag(+0.).xy,r,m)*viewzoom\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+1.).xy,r,m)*viewzoom\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+2.).xy,r,m)*viewzoom\n ;}\n ;//l0=v1(0)\n ;v0 d=segment(p0,l0,l1)     //distance of p3 to line segment\n ;c.z=segment(u,l0,l1)//vis blue line segment\n ;c.y=length(u-p0)//green dots\n ;v1 p10=projectS(p0-l0,l1-l0)+l0//projected point on line\n ;c.x=length(u-p10)//red projected point\n ;v1 p11=project(p0-l0,l1-l0)+l0//projected point on line (not clamped)\n ;c.x=min(c.x,length(u-p11))//red projected point\n ;c.y-=d\n ;//c.z-=.01  \n ;c.x-=.05\n ;c.x=min(c.x,segment(u,p0,p10))-.01\n ;c=abs(c-.02)\n ;c=smoothstep(4./Aa(t,u,r,m),-4./Aa(t,u,r,m),c)\n ;c*=.4\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;return c;}\n/**/\n\n\n//catch fails to care for sign== sides of the linesegment!\n  //my usecase likely never cares for that. its cute to shine trough a wall?\nbool catch(v1 rs,v1 r2,v1 ls,v1 le//return if ray r* moves closer to line l; or not\n){//return (segments(rs,ls,le)>segments(r2,ls,le))//there should be a way way with less segments()!\n ;//above does NOT cach adiv0 case for ls==le\n ;v1 ll=le-ls\n ;v0 c= dd(ll);if (c==0.)return false ;//if(zero-length line segment) //means its unhittable, which is odd!\n ;return (dd((rs-ls-(ll*sat((dot(rs-ls,ll)/c)))))\n         >dd((r2-ls-(ll*sat((dot(r2-ls,ll)/c))))))//segment2(r22,ll)\n  //there possibly is no more precise way here.\n ;}\n\n//this is NOT correct iff Rayorigin is closer to linesegment than RayTarget\n//it needs to  ckech for signs, needs sign-biased distance to line (segment())\nv1 InterWall(v1 rs,v1 r2,v1 ls,v1 le//rayStart, RayPoint2, segmentStart,SegmenrEnd\n){if(catch(rs,r2,ls,le))return r2\n ;v1 j=(ls+le)*.5//midpoint\n ;v1 i=gLLxX0(rs,r2,ls,le)//interssecion of LINES\n ;if(length(i-j)>length(ls-le)*.5)i=rs  //there should be a way way with les sqrt()!\n ;//and i dont think that a coordinate-rotation is good here (low precision from trig/dot() )\n ;return i;}\n\nv3 demoLineIntersection(v0 t,v1 u,v2 r,v3 m\n){v3 c=v3(1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v1 l0=v1(-.4)\n ;v1 l1=v1( .7)\n ;v1 r0=v1(.5,-.5)\n ;v1 r1=v1(.5,-.1)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){r0=fra(t,bufDrag(+0.).xy,r,m)*2.\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){r1=fra(t,bufDrag(+1.).xy,r,m)*2.\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+2.).xy,r,m)*2.\n ;} \n ;if(pointCount >3.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+3.).xy,r,m)*2.\n ;}\n ;c.x=segment(u,l0,l1)\n ;c.y=segment(u,r0,r1)\n ;c.z=length(u-mix(l0,l1,.5))\n ;c.w=length(InterWall(r0,r1,l0,l1)-u)\n ;c.xy-=.02\n ;//c.z=abs(c.z-.05)-.02\n ;//c.w=abs(c.w-.1)-.03\n ;c=smoothstep(4./Aa(t,u,r,m),-4./Aa(t,u,r,m),c)\n ;c*=1.\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;return c;}\n\nv3 demoIkBezier(v0 t,v1 u,v2 r,v3 m//define bezier by start,eng,Arclength\n){v3 c=v3(1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v1 p0=v1(-.4)\n ;v1 l0=v1( .7)\n ;v1 l1=v1(.5,-.5)\n ;//v1 r1=v1(.5,-.1)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){p0=fra(t,bufDrag(+0.).xy,r,m)*viewzoom\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+1.).xy,r,m)*viewzoom\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+2.).xy,r,m)*viewzoom\n ;} \n ;v0 d=segment(p0,l0,l1)*2.     //distance of p3 to line segment\n ;if(length(l0-l1)>d)l1=l0+d*normalize(l1-l0)\n ;c.z=segment(u,l0,l1)//vis blue line segment\n ;v1 p11=knee(l0,l1,d)//red dot is knee \n ;v1 p10=project(p0-l0,l1-l0)+l0\n ;c.x=length(u-p11)-.04\n ;c.x=min(c.x,segment(u,p10,p0))\n ;c.y=BezierQuad(u,l0,p11,l1)\n ;c.x=abs(c.x)-.01 \n ;c.y-=.02\n ;c.z=abs(c.z-.05)-.02\n ;//c=mix(ss(c.xyzw,viewzoom/Aa(t,u,r,m)),fract(c.xyzw*9.),.2)\n ;c=smoothstep(4./Aa(t,u,r,m),-4./Aa(t,u,r,m),c)\n ;c*=.3\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;return c;}\n/**/\n\n\nvec4 iCB(out v3 o,v1 u //wrapper for bezier +appolonean demo\n){//o+=demoBezierQuad(iTime,u,iResolution,iMouse)\n ;//o=ltj3Wc(o,u,iResolution,iMouse)//previously called iCanvas\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;     if(pointCount< 7.)o=(demoBezierQuad   (iTime,u,iResolution,iMouse))//,o)\n ;else if(pointCount< 9.)o=(demoProject      (iTime,u,iResolution,iMouse))//,o)                  \n ;else                   o=(demoIkBezier     (iTime,u,iResolution,iMouse))//,o)\n ;//o=demoLineIntersection(iTime,u,iResolution,iMouse)\n ;//o=demoProject(iTime,u,iResolution,iMouse)//not correct for many cases, sign-ignorant\n ;//o=sat(o)\n ;return o\n ;}\n\n//temporal reprojection  MainImage\n//self  : https://www.shadertoy.com/view/wlf3RB\n//parent: https://www.shadertoy.com/view/Xd2fzR\n// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n//vec4 tf0(vec2 b,vec3 r){return tf(iChannel0,b,r);}\n//vec4 tf1(vec2 b,vec3 r){return tf(iChannel1,b,r);}\n//vec4 tf2(vec2 b,vec3 r){return tf(iChannel2,b,r);}\nvec4 tf3(vec2 b,vec3 r){return tf(iChannel3,b,r);}\nvec4 mTR(vec4 o,vec2 u\n){vec3 c=tf3(u,iResolution.xyz).xyz\n ;float g=dot(c,vec3(.3333))// burn highlights\n ;c=mix(c,vec3(g),min(g*.15,1.))\n ;c=pow(c,vec3(.4545))// gamma\n ;c=1.15*pow(c,vec3(.9,.95,1.))+vec3(1,1,0)*-.04 // instafilter\n ;//vignete    \n ;//vec2 q=u/iResolution.xy\n ;//c*= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n ;return vec4(c,1);}\n\n#define pDoOver(a) pdOver(o,texture(a,u/iResolution.xy, -100.0 ))\n\n//#if 1\nvoid mainImage(out vec4 o, in vec2 u\n){o=vec4(0)\n #ifdef Scene2D\n  ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n  ;o=pdOver(o,iCB(o,u))//iCB(o,u)\n  ;o=pdOver(o,ltj3Wc(o,u,iResolution,iMouse))//backsrop is a 2d srawing\n #else\n  #ifdef SceneTR\n   ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n   ;o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n   ;o=pdOver(o,mTR(o,u)) //backfrop is traced 3d scene (TemporalReprojection+brdf)\n  #else\n   ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n   ;o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n   ;o=pDoOver(iAD)  //backfrop is marched 3d scene (automatic Differentiation)\n  #endif\n #endif\n       /**/\n ;}\n/*\n//#else\nvoid mainImage(out vec4 o,vec2 u\n){o=mTR(o,u)//temporal reprojection\n;}\n//#endif\n/**/\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Scene2D just shows a 3d scene of brush strokes: https://www.shadertoy.com/view/ltj3Wc\n#define Scene2D\n\n//else, there are 2 3d scenes:\n#ifndef Scene2D\n //[temporal reprojection] makes (even moving) images better over time, but it is a slow process.\n #define SceneTR\n //[automatic differentiation] calculates derivatives (surfaceNormal,curvatures) as byproduct.\n#endif\n\n\n\n//memo, make SceneTR faster, by diminishing brdf complexits, reflectionCount or whatever.\n\n#define kifsFungusIter 13\n#define kifsFungusSeed .55\n\n/**/ // start: compatibilityCore \n//self  : https://www.shadertoy.com/view/wlf3RB   (compatible v4)\n//parent: https://www.shadertoy.com/view/Xd2fzR   (less compatible)\n#define pi acos(-1.)\n//for a global manual override\n//cannot define any namespace with dual undersore, -> fatal error\n#define VER __VERSION__\n//#define VER 100  //webGl1==openGlEs100\n//#define VER 300  //webGl2==openGlES300\n//there may be some smaller values, labeled \"experimental*\"\n//therefore we only care if (VER <300)\n#if VER <300\n//outerproduct is glES300 exclusive\nmat3 outerProduct(vec3 a,vec3 b){return mat3(a*b.x\n                                            ,a*b.y\n                                            ,a*b.z);}//i may have swapped a and b wrongly here.\n//sign(int) is gles300 exclusive\nint sign(int a){return int(sign(float(a)));}\n//abs(int) is gles300 exclusive\nint abs(int a){return (a)*sign(a);}\n//texelFetch() uses gles300 exclusive ivec2, substituting with texture(,(vec2()*.5)/iResolution.xy)\nvec4 tf(sampler2D a,vec2 b,vec3 r){return texture(a,(b+.5)/r.xy) ;}\n#else\nvec4 tf(sampler2D a,vec2 b,vec3 r){return texelFetch(a,ivec2(b),0) ;}\n#endif\nmat4 rotationAxisAngle(vec3 v,float r//axis,angle\n){float s=sin(r),c=cos(r);return \n  mat4(mat3(c)\n      +outerProduct(v,v)*(1.-c)\n      +mat3(0,-v.z,v.yz,0,-v.xy,v.x,0)*s)\n +mat4(1)-mat4(mat3(1));}\nmat4 translate(vec3 t){mat4 m=mat4(1);m[3]=vec4(t.xyz,1);return m;}\n\n/**/ // end__: compatibilityCore\n/**/ // start: shadertoy-iChannel-pattern\n/* \n\n\nThis amalgation uses the shadertoy-iChannel-pattern:\na-abcd,b-abcd,c-abcd,d-abcd,i-abcd\nUnless a an unnecessary pointer is changed to something more important\n- like KeyboarIn, CubeMapA, a staric distanceField to Glyphs, or a blueNoise Texture.\nthe ichannels of all frasmeBuffers are identical:\niChannel0<-BuffA\niChannel1<-BuffB\niChannel2<-BuffC\niChannel3<-BuffD\nTo have [plugin]s that are rarely more than 1 iChannel FrameBuffer\n[plugin] names are like iChannels, because thats what they point to.\nThis stucture lets me define global modifiable buffer pointers \nfor a plugin-HotSwap option\nwith #ifdef iDiegeticUI contexts for missing-plugin cases:\nEach [plugin] is one seperate FrameBufferObject, summarizing what they buffer:\niDiegeticUI, a lot of object parameters, to be drag and droppable, currently just 2d points.\niAD        , no DoubleBuffer, functions cannot read buffers from commonTab (shadertoy is a bit suilly here)\niCanBez    , no DoubleBuffer, this is the final composite out.\n*/\n#define iDiegeticUI iChannel0\n#define iAD         iChannel1\n#define iVoid0      iChannel2\n#define iVoid1      iChannel3\n#define iCanBez     ImageMain\n\n#define bufDrag(x) texture(iDiegeticUI,(vec2(x,0.)+.5)/iResolution.xy)\n\n/**/ // end__: shadertoy-iChannel-pattern\n/**/ // start: shadertoy-(turm)-pattern\n\n/*\n\n//very common subroutines|aliases\n\n/*\nThis amalgation asserts\n- structure aliases listed below, where:\n- - Array index starts with 0:\n- - - f(x,y)=x*y  ;has [x} as its [0th parameter] and [y] as its [1th parameter]\n- - - A formulaOne race car has 0 drivers and 3 tires\n- - - The fastest racer of a race always achieves 0th place of a race\n- - - 2-dimensional spacetime (minkovski diagram) has 0 time domains and 2 space domains\n- - - the length of an array is equal to the position of its last entry\n\nv*   = linear matrix = vector  with [*]         fields\nm*   = square matrix           with [*]-squared fields\nd*** = single variate calculus over [*] domains down to [tally of *] derivatives\nC*** = multivatiate   calculus over [*] domains down to [tally of *] derivatives\n[tally of *] == [stick counting], in a base1System\n- https://en.wikipedia.org/wiki/Unary_numeral_system\n- https://en.wikipedia.org/wiki/Repdigit\n\n*/\n#define ST struct\n#define norma normalize\n\n#define m1 mat2\n#define m2 mat3\n#define m3 mat4\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define i0 int\n//#define i1 ivec2\n\n\n\n/**/ //start AD structure\n/*\n\na [derivative of f(t)] == [instantaneous rate of change over of f(t) t]\n[derivative of [absememt(t)]] == [[distance(t)]]\n[derivative of [distance(t)]] == [[speed(t)]]\n[derivative of [speed(t)]]    == [[acceleration]]\n\nThis CommonTab valculatesthe 3rd derivative of a vec4 trough many functions:\n\n\ndata types that start with [d*] imply Automatic Differentiation\nfunctions  that start with [D*] imply explicit typecasting to type [d*]\n\na. == first parameter, , ends up being OuterFunction,dividend\nb. == second parameter , ends up being innerFunction,divisor\nc. == third parameter  , ends up being interpolant\n...\n.a==0th derivative\n.b==1th derivative\n.c==2th derivative\n.d==3th derivative\n...\nforeach derivative we use either type; v0, or v1 ,or v2 ,or v3\ndepending on how many dimensions the function/isoline/isosurface/isovolume has:\n[d*  ]dt =+1th derivative\n[d** ]dtÂ²=+2th derivative (and dt)\n[d***]dtÂ³=+3th derivative (and dt adnd dtÂ²)\n[*N*] sets number of domains|dimensions to differentiate over (in parallel)\n      these are commonly orthogonal domains of space.xyzw\n(number of N) in [dN**] sets how many differentials we want to calculate\n     a 1st derivative is rather simple to get\n,but a 2nd derivative usually implies ProductRule or QuotientRule\n,and a 3rd derivative has diminished utility with recursive complexity (productRules of productRules)\n,and a 4th derivative is not even attempted (except for simple identities?)\n/**/\n\n\n//struct d(v0 a;);//just use v0 instead of a [d]  struct\nST   d0  {v0   a;v0   b              ;};//1 domains t,dt\nST   d00 {v0   a;v0   b;v0   c       ;};//1 domains t,dt,dtÂ²\nST   d000{v0   a;v0   b;v0   c;v0   d;};//1 domains t,dt,dtÂ²,dtÂ³ \nST   d1  {v0   a;v1   b              ;};//2 domains t,dt\nST   d11 {v0   a;v1   b;v1   c       ;};//2 domains t,dt,dtÂ²\nST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dtÂ²,dtÂ³ \nST   d2  {v0   a;v2   b              ;};//3 domains t,dt\nST   d22 {v0   a;v2   b;v2   c       ;};//3 domains t,dt,dtÂ²   \nST   d222{v0   a;v2   b;v2   c;v2   d;};//3 domains t,dt,dtÂ²,dtÂ³ \nST   d3  {v0   a;v3   b              ;};//4 domains t,dt\nST   d33 {v0   a;v3   b;v3   c       ;};//4 domains t,dt,dtÂ²\nST   d333{v0   a;v3   b;v3   c;v3   d;};//4 domains t,dt,dtÂ²,dtÂ³\n//the dNULLss can be cast invo v-s and back\nd000 D000(v3   a){return d000(a.x,a.y,a.z,a.w);}\nv3     V3(d000 a){return   v3(a.a,a.b,a.c,a.d);}\nd00 D00(v2   a){return d00(a.x,a.y,a.z);}\nv2   V2(d000 a){return  v2(a.a,a.b,a.c);}\nd0 D0(v1  a){return d0(a.x,a.y);}\nv1 V1(d00 a){return v1(a.a,a.b);}\n//above is sub-struct of below\n//, you may want to read the below before the above!\nST c0  {d0   x                     ;};//1 domains t,dt\nST c00 {d00  x                     ;};//1 domains t,dt,dtÂ²\nST c000{d000 x                     ;};//1 domains t,dtÂ²dtÂ³ \nST c1  {d1   x;d1   y              ;};//2 domains t,dt    \nST c11 {d11  x;d11  y              ;};//2 domains t,dt,dtÂ² \nST c111{d111 x;d111 y              ;};//2 domains t,dt,dtÂ²dtÂ³ \nST c2  {d2   x;d2   y;d2   z       ;};//3 domains t,dt\nST c22 {d22  x;d22  y;d22  z       ;};//3 domains t,dt,dtÂ² \nST c222{d222 x;d222 y;d222 z       ;};//3 domains t,dt,dtÂ²dtÂ³  \nST c3  {d3   x;d3   y;d3   z;d3   w;};//4 domains t,dt\nST c33 {d33  x;d33  y;d33  z;d33  w;};//4 domains t,dt,dtÂ²   \nST c333{d333 x;d333 y;d333 z;d333 w;};//4 domains t,dt,dtÂ²,dtÂ³  \n//above structure may be inefficient, but its user friendlyness first\n//I tried many other structures for AD, this one still wins\n//I am still not perfectly sure about above srtucture\n//i think it enables you to define:\n//-  https://en.wikipedia.org/wiki/Multivariable_calculus#Applications_and_uses\n//-  https://en.wikipedia.org/wiki/Differential_dynamic_programming\n\n//data types that start with [d*] imply [automatic differentiation]\n//functions  that start with [D*] imply explicit typecasting to type [d*]\n//- ALL typecasting just fills voids with zeroes\n//- this may often not do what you want it to do\nv1 V1(v0 a){return v1(a,0);}\nv2 V2(v0 a){return v2(a,0,0);}\nv3 V3(v0 a){return v3(a,0,0,0);}\nv2 V2(v1 a){return v2(a,0);}//what to put in .z here? .x or .y or.0?\nv2 V3(v1 a){return v2(a,0);}\nd0 D0(v0 a){return d0(a,0.);}\nd1 D1(v0 a){return d1(a,v1(0));}\nd2 D2(v0 a){return d2(a,v2(0));}\nd1 D1(d0 a){return d1(a.a,V1(a.b));}\nd2 D2(d0 a){return d2(a.a,v2(a.b,0,0));}\nd2 D2(d1 a){return d2(a.a,v2(a.b,0));}\nd3 D3(d0 a){return d3(a.a,v3(a.b,0,0,0));}\nd00 D00(v0 a){return d00(a,0.,0.);}\nd11 D11(v0 a){return d11(a,v1(0),v1(0));}\nd22 D22(v0 a){return d22(a,v2(0),v2(0));}\nd33 D33(v0 a){return d33(a,v3(0),v3(0));}\nd000 D000(v0 a){return d000(a,0.,0.,0.);}\nd111 D111(v0 a){return d111(a,v1(0),v1(0),v1(0));}\nd222 D222(v0 a){return d222(a,v2(0),v2(0),v2(0));}\nd333 D333(v0 a){return d333(a,v3(0),v3(0),v3(0));}\n\n\n/*\nThis amalgation reserves/asserts the (t,u,r,m)-namespace:\nWithin most function-parameter contexts you can assert that:\n- t=iTime\n- u=uv.xy           //likely uv-transformed)\n- r=iResolution.xyz //.z was intended for projectionMapping, but degraded to a wildcard.\n- m=iMouse.xyzw     //while (left mouse button is up  ) (m.xy=MousePos.xy;m.zw<0.) //m.zw<0. before any uv-transformation\n                    //while (left mouse button is down) (m.xy=MousePos.xy;m.zw=position where mouse was pressed)\nThis allows more code to be moved from and to the commonTab \nfor a subroutine-HotSwap option\n*/\n\n//viewZoom(t,u,r,m){clamp(m.x/r.x,,1.);} is defined seperrately foreach plugin buffer\n//so that every plugin|buffer can have a different FoV|Lens|Zoom function\n//while bokeh among all shaders can still be somewhat uniform.\n\n//divide 1./Aa == hairlineDrawing or sharpBokeh: b=smoothstep(1./Aa,-1./Aa,b)\n#define Aa(t,u,r,m) (min(r.x,r.y)/viewZoom(t,u,r,m))\n//fta insists on TURM-parameters because it contains Viewzoom(), that (locally) insists on TURM\n#define fra(t,u,r,m) (u-.5*r.xy)*viewZoom(t,u,r,m)/(r.y)\n\n/**/ // end__: shadertoy-(turm)-pattern\n/**/ // start: openGl NaN-precision\n\n/*\nexponent == 255 is reserved for Inf and NaN\nmantissa == 0   is   is Inf*(signBit*2-1)\nmantissa != 0        is NaN //(sign is irrelevant in opengl)\nNaN implies that you got too close to an asymptote\nsome languages use different NaN mantissas to differentiate between types/signs of asymptotes\nopengl is not such a language. All opengl NaN are created equal.\n\n32bit signed float bounds: //calculated with win7 64bit calculator:\nLargest  positive  2.-pow(2.,-23.)*pow(2., 127.)==3.4028234663852885981170418348451e38\nSmallest positive    normal        pow(2.,-126.)==1.1754943508222875079687365372222e-38\nSmallest positive subnormal        pow(2.,-150.)==7.0000000000000000000000000000000e-46 \nSmallest negative           = -1*(1+.5+.25+.125+...+ pow(2,-23)*pow(2.^127.)\n                           ~=-pow(2,128) //sum rounds up to 2. in the given precision?\n                            =-3.403e38\nlargest negative normal     =-pow(2.,-127.) //safe assertion???\n//useless for calculations with any predictive property.\n\n#define exp2(a) pow(2.,a) [2<<a]\nhttps://en.wikipedia.org/wiki/Machine_epsilon\ngives an upper bound on the relative rounding error in floating point arithmetic\nmake [exponent] SMALLER, to make [epsilon] larger\n*/\n#define Exponent floor(8. )             //comment values are for exponent=8.\n#define Mantissa floor(23.)             //comment values are for mantissa=23.\nconst v0 mEpsilon   =exp2(-Mantissa);//=1.1920928955078125000000000000000e-7\nconst v0 mEpsilonRec=exp2(+Mantissa);//=8388608.;  \nconst v0  epsilon   =exp2(-Mantissa+    Exponent    );//=0.000030517578125 ==pow(2.,-23.+8.)\nconst v0  epsilonRec=exp2(+Mantissa-    Exponent    );//=32768.=mEpsilonRec/pow(2.,8.)=pow(2.,23.-8.)\n#define zFar epsilonRec\n//abs(safeInt)==v0(i0(abs(safeInt)))\nconst v0  safeInt   =exp2(+Mantissa+max(Exponent,8.));//=2147483648.=8388608.*pow(2.,8.)\nconst v0  safeIntRec=exp2(-Mantissa-max(Exponent,8.));//=4.656612873077392578125e-10 ;\n#undef Exponent\n#undef Mantissa\n\n/**/ // end__: openGl NaN-precision\n/**/ // start: common aliases\n\n\n#define pib acos(0.)\n#define pi acos(-1.)\n#define tau (pi*2.)\n//v0 tau=6.2831853071795864769252867665590057683943387987502116419;//trig definition can be better for smarter compilers.\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n#define u2(a) ((a)*2.-1.)\n#define u5(a) ((a)*.5+.5)\n\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1&&1/Phi=Phi-1\n//https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(),good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n#define sat(x)clamp(x,0.,1.)\n\n\n/*todo\nthis commontab does not have a c2p() p2c() carthesianToPolar bijection-function-set\nadd that!\n*/\n\n//struct ADm2{vec3 a;v2 b;v2 c;v2 d;};//for 3 domains (density/distance field)\n\n//a=0th derivative (point in 3d space)\n//b=1st derivative over 3 domains\n//c=2md derivative over 3 domains\n//d=3rd derivative over 3 domains\n\n//The 3 (or 2) dimensions|domains \n//...are resolved with [struct cN{}] and [da_domain(vN  p)]:\n//where N=number of domains, range [0..3]\n\nc000 da_domain3(v0 p){return c000\n(d000(p,1.,1.,1.));}//3 derivatives over 1d\nc111 da_domain3(v1 p){return c111\n(d111(p.x,v1(1,0),v1(1,0),v1(1,0))//3 derivatives over 2d\n,d111(p.y,v1(0,1),v1(0,1),v1(0,1)));}\nc222 da_domain3(v2 p){return c222\n(d222(p.x,v2(1,0,0),v2(1,0,0),v2(1,0,0))\n,d222(p.y,v2(0,1,0),v2(0,1,0),v2(0,1,0))//3 derivatives over 3d\n,d222(p.y,v2(0,0,1),v2(0,0,1),v2(0,0,1)));}\nc333 da_domain3(v3 p){return c333\n(d333(p.x,v3(1,0,0,0),v3(1,0,0,0),v3(1,0,0,0))\n,d333(p.y,v3(0,1,0,0),v3(0,1,0,0),v3(0,1,0,0))\n,d333(p.z,v3(0,0,1,0),v3(0,0,1,0),v3(0,0,1,0))//3 derivatives over 4d\n,d333(p.w,v3(0,0,0,1),v3(0,0,0,1),v3(0,0,0,1)));}\n\nc00  da_domain2(v0 p){return c00\n(d00 (p,1.,1.));}//2 derivatives over 1d\nc11 da_domain2(v1 p){return c11\n(d11(p.x,v1(1,0),v1(1,0))//2 derivatives over 2d\n,d11(p.y,v1(0,1),v1(0,1)));}\nc22 da_domain2(v2 p){return c22\n(d22(p.x,v2(1,0,0),v2(1,0,0))\n,d22(p.y,v2(0,1,0),v2(0,1,0))//2 derivatives over 3d\n,d22(p.y,v2(0,0,1),v2(0,0,1)));}\nc33 da_domain2(v3 p){return c33\n(d33(p.x,v3(1,0,0,0),v3(1,0,0,0))\n,d33(p.y,v3(0,1,0,0),v3(0,1,0,0))\n,d33(p.z,v3(0,0,1,0),v3(0,0,1,0))//2 derivatives over 4d\n,d33(p.w,v3(0,0,0,1),v3(0,0,0,1)));}\n\nc0   da_domain1(v0 p\n){return c0(d0  (p,1.));}//1 derivatives over 1d\nc1 da_domain1(v1 p){return c1\n(d1(p.x,v1(1,0))//2 derivatives over 2d\n ,d1(p.y,v1(0,1)));}\nc2 da_domain1(v2 p){return c2\n(d2(p.x,v2(1,0,0))\n,d2(p.y,v2(0,1,0))//1 derivatives over 3d\n,d2(p.z,v2(0,0,1)));}\nc3 da_domain1(v3 p){return c3\n(d3(p.x,v3(1,0,0,0))\n,d3(p.y,v3(0,1,0,0))\n,d3(p.z,v3(0,0,1,0))//1 derivatives over 4d\n,d3(p.w,v3(0,0,0,1)));}\n\n//2d one is \n// [wikipedia contour_Line] //for 2 domains (heightmap, isoline, contour)\n//1d one is linear equations.\n\n/*\nimplementation example:\n/*the [c*] struct folds domains to simplify AD-utility:\nthe BoxFunction (with sharp corners) becomes:\nd2 fBoxCheap(c2 p,v2 s){//p=point; s=boxSize\n ;c2 u=subdabsd(p,s)//u=abs(p)-s \n ;return maxdm(u)     //return max(u.x,u.y)\n ;} //for 1 derivatives over 3d space\nd222 fBoxCheap(c2 p,v2 s){\n ;return maxdm(subdabsd(p,s));}//for 3 derivatives over 3d space\n*/\n\n/*\nimplementation example:\n;d333 a=D333(0.)\n;a=ADfunctionMagic(a) //any of the functions below:\n//a.a.xyzw==0th derivative  over 4 domains\n//a.b.xyzw==1th derivatives over 4 domains\n//a.c.xyzw==2th derivatives over 4 domains\n//a.d.xyzw==3th derivatives over 4 domains\n/**/\n/*\nnote: beware  intuitive problems of the above atructure\nIt has 2 different (easily-mistaken-identity) cases:\n- A 2d gradient has NULL differential along +1 additional domain.\n- A vector gets all components scaled \n ,when multiplying a vector by a float.\n*/\n/**/ //--- __end AD-structure\n     //\n/**/ //--- start AD-functions \n/*\naka: [derivative arithmetic] set for [automatic differentiation]\n\nFor a monadic structure, we imply prefix notation for everything:\nInfix notation is a 2000 year old dumd idea;\nGood enough for abacuss multiplication, bad for log((a+b)/(c-d))\n\ninitially i liked to sort by number of input params, but this fails\n- atan() takes 1 input, but its subroutines ad()po()di() take more than 1 input.\n\n/**/\n//negation identity: max(a,b)=-min(-a,-b), requires struct negation\nv0   ne(v0   a){return -a;}\nd0   ne(d0   a){return d0  (-a.a,-a.b);}\nd1   ne(d1   a){return d1  (-a.a,-a.b);}\nd2   ne(d2   a){return d2  (-a.a,-a.b);}\nd3   ne(d3   a){return d3  (-a.a,-a.b);}\nd00  ne(d00  a){return d00 (-a.a,-a.b,-a.c);}\nd11  ne(d11  a){return d11 (-a.a,-a.b,-a.c);}\nd22  ne(d22  a){return d22 (-a.a,-a.b,-a.c);}\nd33  ne(d33  a){return d33 (-a.a,-a.b,-a.c);}\nd000 ne(d000 a){return d000(-a.a,-a.b,-a.c,-a.d);}\nd111 ne(d111 a){return d111(-a.a,-a.b,-a.c,-a.d);}\nd222 ne(d222 a){return d222(-a.a,-a.b,-a.c,-a.d);}\nd333 ne(d333 a){return d333(-a.a,-a.b,-a.c,-a.d);}\n\nc0   ne(c0   a){return c0  (ne(a.x));}\nc00  ne(c00  a){return c00 (ne(a.x));}\nc000 ne(c000 a){return c000(ne(a.x));}\nc1   ne(c1   a){return c1  (ne(a.x),ne(a.y));}\nc11  ne(c11  a){return c11 (ne(a.x),ne(a.y));}\nc111 ne(c111 a){return c111(ne(a.x),ne(a.y));}\nc2   ne(c2   a){return c2  (ne(a.x),ne(a.y),ne(a.z));}\nc22  ne(c22  a){return c22 (ne(a.x),ne(a.y),ne(a.z));}\nc222 ne(c222 a){return c222(ne(a.x),ne(a.y),ne(a.z));}\nc3   ne(c3   a){return c3  (ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\nc33  ne(c33  a){return c33 (ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\nc333 ne(c333 a){return c333(ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\n\n//floor(a) is a basis-function for mod() and fract()\n//because mod() is a mess, so i needed a trueMod(fract())\n//and becase floor(a)=a-fract(a) is needed for differentials!\n//using floor(a) as basis,simplifies above 2 lines to 2 defines\nv0 fl(v0 a){return floor(a);}\ni0 fl(i0 a){return a;} //tautological definition of floor(int(a)) simplifies things\n//multiplying by 0 seems silly, but:\n//it maintains structure to lultiply by *a.b *a.c *a.d\n//it eases into the logic of Automatic Differentiation\nd0   fl(d0   a){return d0(floor(a.a),0.*a.b);}\nd00  fl(d00  a){return d00 (floor(a.a),0.*a.b,0.*a.c);}\nd000 fl(d000 a){return d000(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd1   fl(d1   a){return d1(floor(a.a),0.*a.b);}\nd11  fl(d11  a){return d11 (floor(a.a),0.*a.b,0.*a.c);}\nd111 fl(d111 a){return d111(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd2   fl(d2   a){return d2(floor(a.a),0.*a.b);}\nd22  fl(d22  a){return d22 (floor(a.a),0.*a.b,0.*a.c);}\nd222 fl(d222 a){return d222(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd3   fl(d3   a){return d3(floor(a.a),0.*a.b);}\nd33  fl(d33  a){return d33 (floor(a.a),0.*a.b,0.*a.c);}\nd333 fl(d333 a){return d333(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\n\n//fract(a)=a-floor(a)\n#define fr(a) su(1.,fl(a))\n\n//true-basis-modulo:\n//in comparison, [mod(a,b)] [a%b] are BOTH just an inconsistent MESS\n//just try a<=0 or b<=0 or b==63.\n#define mo(a,b) su(a,mu(b,fl(di(a,b))))\n//v0 mo(v0 a,v0 b){return a-(b*fl(a/b));}//==mod(a,b)\n//i0 mo(i0 a,i0 b){return a-(b*  (a/b));}//==   (a%b)\n\n//also, since mod(a,1.) NEVER returns 1 (its a halfoven interval [0..1[ )\n//we KNOW that 1./0.   = 0. !!!\n//from that, we know that the antiderivative of (1./0.)==log(0.) == 0.+C\n//we KNOW that log(0.) = 0. !!!\n//we KNOW that pow(0.,0.) ==== exp(log(0.)*0.) ==  exp(0*0) = 0. !!!\n//any any argument for pow(0.,0.) approaching 1. but never reaching 1 \n// , is blown out of the water, shown to be wrong\n// , by solving for BASIC modulo arithmetic, where pow(0.,0.) ALWAYS approaches 0.\n\n/*    //residue from AD16 on mod() derivatives                   \n//mo() ideally should be replaced by fractd(), but that adds 1dvd() and 1muld()\n//... but chain rule division (reciprocal product rule) on a custom type is so bad.\n//... that for derivative arithmetic, mod(a,b) outperforms mu(fractd(divd(a,b)),b)\n//v4 mod(v4 a,v4 b){return v4(mod(a.x,b.x),mod(a.yzw,1.));}\n//v4 mod(v4 a,v1 b){return v4(mod(a.x,b  ),mod(a.yzw,1.));}\n//v4 mod(v1 a,v4 b){return v4(mod(a  ,b.x),0,0,0        );}\n//#define modo(a,b) fract(a/b)*b /*what mod(a,b) actually does\n#define may fract(a.b));}\n#define maz mod(a.a,b),may\n#define mab mod(a.a,b.a)\n//v0 mo(v0 a,v0 b){return mod(a,b);}                        \nd2 mo(d2 a,v0 b){return d2(maz\nd1 mo(d1 a,v0 b){return d1(maz\nd0 mo(d0 a,v0 b){return d0(maz\nd0 mo(d0 a,d0 b){return d0(mab,may\nd2 mo(d2 a,d0 b){return d2(mab,may\nd2 mo(d2 a,d2 b){return d2(mab,may\nd2 mo(d2 a,d1 b){return d2(mab,may\nd2 mo(d0 a,d2 b){return d2(mab,v2(0));}\nd2 mo(d1 a,d2 b){return d2(mab,v2(0));}\nd2 mo(v0 a,d2 b){return d2(mo(a,b.a),v2(0));}\nd1 mo(v0 a,d1 b){return d1(mo(a,b.a),v1(0));}\nd0 mo(v0 a,d0 b){return d0(mo(a,b.a),   0.);}\n*/\n                         \n\nv0 si(v0 a){return sin(a);}\nv0 co(v0 a){return cos(a);}\nd0 si(d0 a){return d0(si(a.a),co(a.a)*a.b);}\nd1 si(d1 a){return d1(si(a.a),co(a.a)*a.b);}\nd2 si(d2 a){return d2(si(a.a),co(a.a)*a.b);}\nd0 co(d0 a){return d0(co(a.a),-si(a.a)*a.b);}\nd1 co(d1 a){return d1(co(a.a),-si(a.a)*a.b);}\nd2 co(d2 a){return d2(co(a.a),-si(a.a)*a.b);}\n\n//[automatic differentiation] uo to 3rd derivative of o(a())\n//see siD() for the o()-values of trigonometry derivatives of sin() cos()\nd000 AD(d000 a,vec4 o){v0 O=a.c*o.x\n ;return D000(o.xyyy*vec4(1.,a.b,a.c,a.d)\n +vec4(0,0,a.b*vec2(o.z*a.b,-(2.*O+(a.b*a.b*o.y+O)))));}\n\n//above so far is only useful for sin() or cos()\nvec4 siD(v0 a){return vec4(+si(a),+co(a),-si(a),-co(a));}\nd000 si(d000 a){return AD(a,siD(a.a)     );}//sin()dxdxdx\nd000 co(d000 a){return AD(a,siD(a.a).yzwx);}//cos()dxdxdx\n\n//ST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dtÂ²,dtÂ³ \nd111 si(d111 a){\n ;d000 x=si(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=si(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd111 co(d111 a){\n ;d000 x=co(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=co(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 si(d222 a){\n ;d000 x=si(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=si(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;d000 z=si(d000(a.a,a.b.z,a.c.z,a.d.z))\n ;return d222(x.a,v2(x.b,y.b,z.b)\n                 ,v2(x.c,y.c,z.c)\n                 ,v2(x.d,y.d,z.d));}\nd222 co(d222 a){\n ;d000 x=co(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=co(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;d000 z=co(d000(a.a,a.b.z,a.c.z,a.d.z))\n ;return d222(x.a,v2(x.b,y.b,z.b)\n                 ,v2(x.c,y.c,z.c)\n                 ,v2(x.d,y.d,z.d));}\nd333 si(d333 a){\n ;d000 x=si(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=si(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;d000 z=si(d000(a.a,a.b.z,a.c.z,a.d.z))\n ;d000 w=si(d000(a.a,a.b.w,a.c.w,a.d.w))\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b)\n                 ,v3(x.c,y.c,z.c,w.c)\n                 ,v3(x.d,y.d,z.d,w.d));}\nd333 co(d333 a){\n ;d000 x=co(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=co(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;d000 z=co(d000(a.a,a.b.z,a.c.z,a.d.z))\n ;d000 w=co(d000(a.a,a.b.w,a.c.w,a.d.w))\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b)\n                 ,v3(x.c,y.c,z.c,w.c)\n                 ,v3(x.d,y.d,z.d,w.d));}\n//once more a clear sign of my structure extending poorly.\n\n//patching humber of domains as sub of numberofDerivatives is silly\n//numberOfDerivatives must be sub of DumberOdFomains\n//you would  prilarily chose how many domains your scene has\n//you woul secondarily chose how many differentials you need\n//above structure is ignorant of above 2 lines\n//so the d111 struct is already silly!\n\n//c111 si(c111 a){return c111(si(a.x),(si(a.y));}//sin()dxdxdx\n\n/*\n//atan is implemented, but further below, it needs more subroutines:\ntodo, all the trigonometry functions with glES100 to gles300 porting\n*/\nv0 rec(v0 a){return (a==0.)?a:1./a;}//return [1/a] , work safe\n\n\n//single parameter operations are MUCH simpler here:\nv0 sr(v0 a){return sqrt(a);}\nd0 sr(d0 a){v0 q=sqrt(a.a);return d0(q,.5*rec(q)*a.b);}\nd1 sr(d1 a){v0 q=sqrt(a.a);return d1(q,.5*rec(q)*a.b);}\nd2 sr(d2 a){v0 q=sqrt(a.a);return d2(q,.5*rec(q)*a.b);}\n\nv0 ex(v0 a){return exp(a);}\nd0 ex(d0 a){v0 x=ex(a.a);return d0(x,x*a.b);}\nd1 ex(d1 a){v0 x=ex(a.a);return d1(x,x*a.b);}\nd2 ex(d2 a){v0 x=ex(a.a);return d2(x,x*a.b);}\n//sqrt() and divisions require a worksave reciprocal operator:\n\n//ex(d00) seems to be fine\nd00 ex(d00 a){return d00(ex(a.a)\n,ex(a.a)*a.b\n,ex(a.a)*a.b*a.b+ex(a.a)*a.c//productRule\n//above implies  https://en.wikipedia.org/wiki/Triple_product_rule\n);}\n//exp2() is not THAT simple here???\n\n//ex(d000) seems to be fine\nd000 ex(d000 a){return d000(ex(a.a)\n,ex(a.a)*a.b\n,ex(a.a)*a.b*a.b+ex(a.a)*a.c//productRule\n//above implies  https://en.wikipedia.org/wiki/Triple_product_rule\n,ex(a.a)*a.b*a.b*a.b+  ex(a.a)*a.c*a.b +  ex(a.a)*a.c*a.b\n+ex(a.a)*a.b*a.c+ex(a.a)*a.d);}\n//exp2() is not THAT simple here.\n\nd11 ex(d11 a){\n ;d00 x=ex(d00(a.a,a.b.x,a.c.x))\n ;d00 y=ex(d00(a.a,a.b.y,a.c.y))\n ;return d11(x.a,v1(x.b,y.b)\n                ,v1(x.c,y.c));}\nd22 ex(d22 a){\n ;d00 x=ex(d00(a.a,a.b.x,a.c.x))\n ;d00 y=ex(d00(a.a,a.b.y,a.c.y))\n ;d00 z=ex(d00(a.a,a.b.z,a.c.z))\n ;return d22(x.a,v2(x.b,y.b,z.b)\n                ,v2(x.c,y.c,z.c));}\nd33 ex(d33 a){\n ;d00 x=ex(d00(a.a,a.b.x,a.c.x))\n ;d00 y=ex(d00(a.a,a.b.y,a.c.y))\n ;d00 z=ex(d00(a.a,a.b.z,a.c.z))\n ;d00 w=ex(d00(a.a,a.b.w,a.c.w))\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b)\n                ,v3(x.c,y.c,z.c,w.c));}\nd111 ex(d111 a){\n ;d000 x=ex(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=ex(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;return d111(x.a,v1(x.b,y.b)\n                 ,v1(x.c,y.c)\n                 ,v1(x.d,y.d));}\nd222 ex(d222 a){\n ;d000 x=ex(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=ex(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;d000 z=ex(d000(a.a,a.b.z,a.c.z,a.d.z))\n ;return d222(x.a,v2(x.b,y.b,z.b)\n                 ,v2(x.c,y.c,z.c)\n                 ,v2(x.d,y.d,z.d));}\nd333 ex(d333 a){\n ;d000 x=ex(d000(a.a,a.b.x,a.c.x,a.d.x))\n ;d000 y=ex(d000(a.a,a.b.y,a.c.y,a.d.y))\n ;d000 z=ex(d000(a.a,a.b.z,a.c.z,a.d.z))\n ;d000 w=ex(d000(a.a,a.b.w,a.c.w,a.d.w))\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b)\n                 ,v3(x.c,y.c,z.c,w.c)\n                 ,v3(x.d,y.d,z.d,w.d));}\n\nv0 ln(v0 a){return log(a);}\nd0 ln(d0 a){return d0(log(a.a),a.b/a.a);}\nd1 ln(d1 a){return d1(log(a.a),a.b/a.a);}\nd2 ln(d2 a){return d2(log(a.a),a.b/a.a);}\n//        pow (x,y) ex(   ln(x)*y )//wait till we define mu()\n//#define powd(x,y) ex(mu(ln(x),x))//wait till we define mu()\n\n//ln() 2nd and 3rd derivative imply quotientRule\n//i hope i did this corretcly. last time i did this 15 years ago.\n\n\nd00 ln(d00 a){return d00(\n ln(a.a) //t\n,a.b/a.a //dt\n,(a.c*a.a-a.b*a.b)/(a.a*a.a));}//dtÂ²\n\nd000 ln(d000 a){return d000(\n ln(a.a)//t\n,a.b/a.a//dt\n,(a.c*a.a-a.b*a.b)/(a.a*a.a)//dtÂ²\n,((a.a*a.d-a.b*a.c)*(a.a*a.a)-2.*(a.c*a.a-a.b*a.b)*(a.b*a.a))\n /(a.a*a.a*a.a*a.a)//dtÂ³\n    //the dividend may still contain a faster growing a.b or a.c or a.d ?\n);}//ln() overlaps a lot with di() the a are only off by 1.\n //ln() is a special case of di()\n\n\nv0 sg(v0 a){return sign(a);}\nv1 sg(v1 a){return sign(a);}\nv2 sg(v2 a){return sign(a);}\nv3 sg(v3 a){return sign(a);}\nd0 sg(d0 a){return d0(sign(a.a),0.);}\n\nd2 sg(d2 a){\n   ;d0 x=sg(d0(a.a,a.b.x))\n   ;d0 y=sg(d0(a.a,a.b.y))\n   ;d0 z=sg(d0(a.a,a.b.z))      \n   ;return d2(x.a,v2(x.b,y.b,z.b));}\n\nv0 ab(v0 a){return abs(a);}\nd0 abss(v0 a){return d0(abs(a),sign(a));}//subroutine\n//cmd() is special case of component wise multiplication for abs() with a.a=1.\nd0 cmd(d0 a,v0 b){return d0(a.a,a.b*b);}\nd1 cmd(d0 a,v1 b){return d1(a.a,a.b*b);}\nd2 cmd(d0 a,v2 b){return d2(a.a,a.b*b);}\nd3 cmd(d0 a,v3 b){return d3(a.a,a.b*b);}\nd0 ab(d0 a){return cmd(abss(a.a),a.b);}//d (abs(a.a),sign(a.a)*a.b);}\nd1 ab(d1 a){return cmd(abss(a.a),a.b);}//d1(abs(a.a),sign(a.a)*a.b);}\nd2 ab(d2 a){return cmd(abss(a.a),a.b);}//d2(abs(a.a),sign(a.a)*a.b);}\nd3 ab(d3 a){return cmd(abss(a.a),a.b);}//d2(abs(a.a),sign(a.a)*a.b);}\n\nd00 ab(d00 a){return d00(  \n abs(a.a)\n,sign(a.a)*a.b\n,sign(a.a)*a.c+a.b);}\n\nd000 ab(d000 a){return d000(  \n abs(a.a)\n,sign(a.a)*a.b\n,sign(a.a)*a.c+a.b\n,sign(a.a)*a.d+a.c);}\n\n//ST c2  {d2   x;d2   y;d2   z       ;};//3 domains t,dt\nc2 ab(c2 a){\n ;d2 x=ab(a.x)\n ;d2 y=ab(a.y)\n ;d2 z=ab(a.z)\n ;return c2(x,y,z);}\n\n//i am not too sure about my implementation on fractd();\n//the hell, just use mod() instead, mod() has VERY nice first derivatives!\n//reminder that the fract function's first derivative has a \"kick\" on (mod(a,1)==0.0)\nv0 djum(v0 a){return mix(a,-1.,step(fract(a),0.)*step(0.,fract(a)));}\nv1 djum(v1 a){return v1(djum(a.x),djum(a.y));}\nv2 djum(v2 a){return v2(djum(a.x),djum(a.y),djum(a.z));}\n//i should definitely define this by fract, and not by floor.\n//because fm-modulation taught me that i need fract() a lot more than floor()\nd2 fractd(d2 a){return d2(floor(a.a),djum(a.b));}\nd1 fractd(d1 a){return d1(floor(a.a),djum(a.b));}\nd0 fractd(d0 a){return d0(floor(a.a),djum(a.b));}\n//very slightly lower precision? rarely relevant. fract() has great precision on float!\n#define floord(a) subd(a,fractd(a))\n\n/*\nmathematical ifentity\nof fract(x) \nis mod(x,1.)\nis mod(x,1.)\n*/\n\n//derivatives of functions with 2 input parameters are trickier:\n//  https://en.wikipedia.org/wiki/Multivariable_calculus\n//There are exponential many permutations of mod() mixd() mind() input types\n\n//substraction is simple, because \"differentiation equals integration\"\n//  https://en.wikipedia.org/wiki/Cauchy_integral_formula\n//...making the implementation of the chain rule much simpler for:\n//  https://en.wikipedia.org/wiki/Translation_(geometry)\nv0 su(v0 a,v0 b){return a-b;} \nd2 su(d2 a,d2 b){return d2(a.a-b.a,a.b-b.b);}//3d translation\nd1 su(d1 a,d1 b){return d1(a.a-b.a,a.b-b.b);}//2d translation\nd0 su(d0 a,d0 b){return d0(a.a-b.a,a.b-b.b);}//1d translation\nd2 su(d2 a,v0 b){return d2(a.a-b  ,a.b);}\nd2 su(d2 a,d0 b){return d2(a.a-b.a,a.b);}\nd2 su(d2 a,d1 b){return d2(a.a-b.a,a.b);}      \nd3 su(d3 a,v0 b){return d3(a.a-b  ,a.b);}\nd1 su(d1 a,v0 b){return d1(a.a-b  ,a.b);}                             \nd1 su(d1 a,d0 b){return d1(a.a-b.a,a.b);}\nd0 su(d0 a,v0 b){return d0(a.a-b  ,a.b);}                           \nd2 su(v0 a,d2 b){return d2(a  -b.a,-b.b);}\nd2 su(d0 a,d2 b){return d2(a.a-b.a,-b.b);}\nd2 su(v3 a,d2 b){return d2(a.a-b.a,-b.b);}\nd1 su(v0 a,d1 b){return d1(a  -b.a,-b.b);}\nd1 su(d0 a,d1 b){return d1(a.a-b.a,-b.b);}\nd0 su(v0 a,d0 b){return d0(a  -b.a,-b.b);}\n\n\nd3 su(v0 a,d3 b){return d3(a  -b.a,-b.b);}\nd3 su(d3 a,d3 b){return d3(a.a-b.a,-b.b);}\n\n\nd000 su(d000 a,d000 b){return d000(a.a-b.a\n                                  ,a.b-b.b\n                                  ,a.c-b.c\n                                  ,a.d-b.d\n                                );}\n\n//ST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dtÂ²,dtÂ³\nd111 su(d111 a,d111 b){\n ;d000 xa=d000(a.a,a.b.x,a.c.x,a.d.x)\n ;d000 ya=d000(a.a,a.b.y,a.c.y,a.d.y)\n ;d000 xb=d000(b.a,b.b.x,b.c.x,b.d.x)\n ;d000 yb=d000(b.a,b.b.y,b.c.y,b.d.y)\n  ;xa=su(xa,xb)\n  ;ya=su(ya,yb)\n  ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d))\n ;}\nd222 su(d222 a,d222 b){\n ;d000 xa=d000(a.a,a.b.x,a.c.x,a.d.x)\n ;d000 ya=d000(a.a,a.b.y,a.c.y,a.d.y)\n ;d000 za=d000(a.a,a.b.z,a.c.z,a.d.z)\n ;d000 xb=d000(b.a,b.b.x,b.c.x,b.d.x)\n ;d000 yb=d000(b.a,b.b.y,b.c.y,b.d.y)\n ;d000 zb=d000(b.a,b.b.z,b.c.z,b.d.z)\n  ;xa=su(xa,xb)\n  ;ya=su(ya,yb)\n  ;za=su(za,zb)\n  ;return d222(xa.a,v2(xa.b,ya.b,za.b)\n                   ,v2(xa.c,ya.c,ya.c)\n                   ,v2(xa.d,ya.d,za.d))\n ;}\n//this one hints at inefficient structure\n//glide-translations along multiple domains:\n //p.x.a=point.x\n //p.y.a=point.y\n //p.z.a=point.z\n //p.w.a=point.w\n //p.x.a=1\n //p.y.b=1\n //p.z.c=1\n //p.w.d=1\n/*\nc3333 su(c3 p,v3 s){return c333\n(su(p.x,s.x)//su(d3,v0)\n.su(p.y,s.y)//su(d3,v0)\n,su(p.z,s.z)//su(d3,v0)\n,su(p.w,s.w));}//su(d3,v0)*/\n\n\nc3 su(c3 p,v3 s){return c3(su(p.x,s.x),//su(d3,v0)\n                                 su(p.y,s.y),//su(d3,v0)\n                                 su(p.z,s.z),//su(d3,v0)\n                                 su(p.w,s.w));}//su(d3,v0)\nc2 su(c2 p,v2 s){return c2(su(p.x,s.x),\n                                 su(p.y,s.y),\n                                 su(p.z,s.z));}\nc1 su(c1 p,v1 s){return c1(su(p.x,s.x),\n                                 su(p.y,s.y));}\nc0 su(c0 p,v0 s){return c0(su(p.x,s));}\n//subd(absd(p),s) equals a translation away from the origin by [s]\n//... AND mirroring at origin, via abs() \n//... so it it clamps a an implicit surface to a limited \"thickness\"\n//(in 3 domains),also translating its first de)rivatives.\nd3 suab(d3 p,v0 s){return su(ab((p)),s);}                     \nd2 suab(d2 p,v0 s){return su(ab((p)),s);}\nd1 suab(d1 p,v0 s){return su(ab((p)),s);}\nd0 suab(d0 p,v0 s){return su(ab((p)),s);}\n //p.x.a=point.x\n //p.y.a=point.y\n //p.z.a=point.z\n //p.w.a=point.w\n //p.x.a=1\n //p.y.b=1\n //p.z.c=1\n //p.w.d=1\n\nc3 suab(c3 p,v3 s){return c3(suab(p.x,s.x),\n                                   suab(p.y,s.y),\n                                   suab(p.z,s.z),\n                                   suab(p.w,s.w));}\nc2 suab(c2 p,v2 s){return c2(suab(p.x,s.x),\n                                   suab(p.y,s.y),\n                                   suab(p.z,s.z));}\nc1 suab(c1 p,v1 s){return c1(suab(p.x,s.x),\n                                   suab(p.y,s.y));}\nc0 suab(c0 p,v0 s){return c0(suab(p.x,s));}\n//addition is negated substraction.\n#define ad(a,b) su(a,ne(b))\n#define adddabsd(a,b) suab(a,negd(b))\n\n//automatic_differentiation_multiplication \n// productRule within the chainRule\n//  https://en.wikipedia.org/wiki/Product_rule\n#define atb a.a*b,a.b*b);}\n#define mdb b){return mu(b,a);}\nv0 mu(v0 a,v0 b){return a*b;}\nd2 mu(d2 a,v0 b){return d2(atb\nd1 mu(d1 a,v0 b){return d1(atb\nd0 mu(d0 a,v0 b){return d0(atb\nd2 mu(v0 a,d2 mdb //mdb is the commutative inverse of the 3 above ones\nd1 mu(v0 a,d1 mdb\nd0 mu(v0 a,d0 mdb//scalar multiplication is tautological product_rule.\nd2 mu(d2 a,d2 b){return d2(a.a*b.a,a.b*b.a+a.a*b.b);}\nd1 mu(d1 a,d1 b){return d1(a.a*b.a,a.b*b.a+a.a*b.b);}\nd0 mu(d0 a,d0 b){return d0(a.a*b.a,a.b*b.a+a.a*b.b);}\nd1 mu(d0 a,d1 b){return d1(a.a*b.a,a.b*b.a+a.a*b.b);}\nd1 mu(d1 a,d0 b){return d1(a.a*b.a,a.b*b.a+a.a*b.b);}\n//d2 mu(d2 a,d1 b){return d2(a.x*b.x,a.d*b.x+a.x*b.d);}//nonsense?\nd2 mu(d2 a,d0 b){return d2(a.a*b.a,a.b*b.a+a.a*b.b);}\n//d2 mu(d1 a,d2 b){return d2(a.x*b.x,a.d*b.x+a.x*b.d);}//nonsense?\nd2 mu(d0 a,d2 b){return d2(a.a*b.a,a.b*b.a+a.a*b.b);}\n\n\nd3 mu(v0 a,d3 b){return d3(a  *b.a,a  *b.a+a  *b.b);}\nd3 mu(d3 a,d3 b){return d3(a.a*b.a,a.b*b.a+a.a*b.b);}\n\nc2 mu(c2 p,v2 s){return c2(mu(p.x,s.x),\n                                 mu(p.y,s.y),\n                                 mu(p.z,s.z));}\nc2 mu(c2 p,v0 s){return mu(p,v2(s));}\nc1 mu(c1 p,v1 s){return c1(mu(p.x,s.x),\n                                 mu(p.y,s.y));}\nc0 mu(c0 p,v0 s){return c0(mu(p.x,s));}\n//reciprocal derivatives are most confusing.\n#define atc a.a/b,a.b/b);}\nv0 di(v0 a,v0 b){return a/b;}\nd3 di(d3 a,v0 b){return d3(atc\nd2 di(d2 a,v0 b){return d2(atc\nd1 di(d1 a,v0 b){return d1(atc\nd0 di(d0 a,v0 b){return d0(atc//inverse scalar multiplication is a tautolotgy.\n#define bxx /(b.a*b.a));}\nd2 di(v0 a,d2 b){return d2(a  /b.a,(-a  *b.b)bxx\nd3 di(v0 a,d3 b){return d3(a  /b.a,(-a  *b.b)bxx\nd2 di(d0 a,d2 b){return d2(a.a/b.a,(-a.a*b.b)bxx\nd2 di(d1 a,d2 b){return d2(a.a/b.a,(-a.a*b.b)bxx\nd2 di(d2 a,d2 b){return d2(a.a/b.a,(a.b*b.a-a.a*b.b)bxx\nd3 di(d3 a,d3 b){return d3(a.a/b.a,(a.b*b.a-a.a*b.b)bxx\n//d2 divd(d2 a,d1 b){return d2(a.x/b.x,(a.d*b.x-a.x*b.d)bxx//nonsense?\n//d2 divd(d2 a,d  b){return d2(a.x/b.x,(a.d*b.x-a.x*b.d)bxx//nonsense?\n//All exponential functions utilize their Base_E_identity:\n//...which is still not efficient, but comes doen to O(exp(n*log(n)))\n//      pow (x,y)==exp(     log (x)*y )//baseE exponential and logarythmic functions.\n#define po(x,y) ex(mu(ln(x),x))\n\n//this isNOT mx() with differentials, this is just mi() with differentials and subroutines!\n\n#define ma(a,b) ne(mi(ne(a),ne(b)))\nv0 mi(v0 a,v0 b){return min(a,b);}\nv1 mi(v1 a,v1 b){return min(a,b);}\nv2 mi(v2 a,v2 b){return min(a,b);}\nv3 mi(v3 a,v3 b){return min(a,b);}\n//component-wise min() aliases: \nv0 mi(vec2 a){return mi(a.x,a.y);}\nv0 mi(vec4 a){return mi(mi(a.xy),mi(a.zw));}\n//3-domain matrix tripples:\n//todo, renew structure of this old mess\n\n\n//mixd is subroutine for mind(), which is used as branch. mix(n1,n2,step(m,0.))\nv0 mixd(v0 a,v0 b,v0 c){return mix(a,b,c);}\nv1 mixd(v1 a,v1 b,v0 c){return mix(a,b,c);}\nv2 mixd(v2 a,v2 b,v0 c){return mix(a,b,c);}\nv3 mixd(v3 a,v3 b,v0 c){return mix(a,b,c);}\n//v1 mixd(v0 a,v1 b,v0 c){return mix(v0tv1(a),b,c);} oh my permutations...\nd0 mixd(d0 a,d0 b,v0 c){return d0(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd1 mixd(d1 a,d1 b,v0 c){return d1(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd2 mixd(d2 a,d2 b,v0 c){return d2(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd1 mixd(d0 a,d1 b,v0 c){return mixd(D1(a),b,c);}\nd2 mixd(d0 a,d2 b,v0 c){return mixd(D2(a),b,c);}\nd2 mixd(d1 a,d2 b,v0 c){return mixd(D2(a),b,c);}\nd1 mixd(d1 a,d0 b,v0 c){return mixd(a,D1(b),c);}\nd2 mixd(d2 a,d1 b,v0 c){return mixd(a,D2(b),c);}\nd2 mixd(d2 a,d0 b,v0 c){return mixd(a,D2(b),c);}\n//the return of Fortran's \"XIF(m,n1,n2)===(m==0)?n1:n2===mix(n1,n2,step(m,0.)*step(0.,m))\n//ecept it compares if (a.x>b.x)\n#define min1 {return mixd(b,a,step(a.a,b.a));}\n#define min3 {return mi(b,a);}\n//I define mind() and -maxd(-,-) instead of maxd() and -mind(-,-)\n//because min() is far more common than max(), for z-buffering.\nd2 mi(d2 a,d2 b)min1\nd2 mi(d1 a,d2 b)min1\nd2 mi(d0 a,d2 b)min1\nd2 mi(d2 a,d1 b)min1\nd2 mi(d2 a,d0 b)min1\nd1 mi(d1 a,d1 b)min1\nd1 mi(d0 a,d1 b)min1\nd0 mi(d0 a,d0 b)min1\nd2 mi(v0 a,d2 b){return mixd(D2(a),b,step(b.a,a));}\nd2 mi(d2 a,v0 b){return mixd(D2(b),a,step(a.a,b));}\nd1 mi(v0 a,d1 b){return mi(D1(a),b);}\nd0 mi(v0 a,d0 b){return mi(D0(a),b);}\n//d0 mi(v0 a,v0 b){return D0(min(a,b));}\nd1 mi(d1 a,d0 b)min3\nd1 mi(d1 a,v0 b)min3\nd0 mi(d0 a,v0 b)min3\n\nc2 mi(c2 a,v2 p){return c2(mi(a.x,p.x),mi(a.y,p.y),mi(a.z,p.z));}\nc2 madm(c2 a,v2 p){return c2(ma(a.x,p.x),ma(a.y,p.y),ma(a.z,p.z));}\nc2 madm(c2 a,v0 p){return madm(a,v2(p));}\nc2 mi(c2 a,v0 p){return mi(a,v2(p));}//needed for fast clamping\nd2 mi(d2 a,d2 b,d2 c){return mi(mi(a,b),c);}\nd2 mi(c2 a){return mi(a.x,a.y,a.z);}\nd2 madm(d2 a,d2 b,d2 c){return ma(ma(a,b),c);}\nd2 madm(c2 a){return madm(a.x,a.y,a.z);}\n\n//This lets you derive over up to 3 dimensions at once OR seperately, \n//...using very self-similar dual-function variants:\n//#define pow2d(a) d2(mu(a.x,a.x),mu(a,2.))\n\n//no NOT confuse exp2(a)=pow(2.,a )=ex(2.,a )=e2(a)\n//with             (a*a)=pow(a ,2.)=ex(a ,2.)=p2(a)=mu(a,a)\n#define p2(a) mu(a,a)\n//#define p2(a) ex(a,2.)\n//#define p3(a) ex(a,3.)\n#define p3(a) mu(a,mu(a,a))\n#define p4(a) ex(a,4.)\n//In terms of 3rd derivatives, it is deinitely slower    to do ex(a,2.), than mu(a,a)\n//In terms of 3rd derivatives, it is likely    slower    to do ex(a,3.), than mu(a,mu(a,a))\n//In terms of 3rd derivatives, it is possibly  faster(!) to do ex(a,4.), than mu(mu(a,a),mu(a,a))\n//- the exponentRule is less complex than the productRule, even with only one derivative\n//- PowerRule   3rd derivative   is 13add+12mult+7pow() //(pow of simple exponents)\n//- ProductRule 3rd derivative   is  7add+15mult+0pow()  \n//- ProductRule 3rd derivative*2 is 14add+30mult+0pow()  \n//- ProductRule 3rd derivative*3 is 21add+45mult+0pow()\n//- PowerRule   3rd derivative   is 13add+12mult+7pow() //(pow of simple exponents)                 \n\n                           \n//above pow2() is very special and simple derivative arithmetic \n//... that should tell you what is going on with all the other \n//... dual number arithmetic functions below.\n//operations with only 1 input parameter are the simplest.\n\n//It gets trickier with functions that take up to 3 parameters:, applying the\n//  https://en.wikipedia.org/wiki/Triple_product_rule\n//Euclidean distance (pythagorean theorem) with first derivatives:\n\n//length() is a wrapped dd(a)==dot(a,a)\n//it uses the same root-wrapper as   sr(),cr(),qr(),ur()\n//so we replace [length()] with sd() == squareDotSelf\n\n/**/\nv0 dt(v0 a,v0 b){return dot(a,b);}\nv0 dt(v1 a,v1 b){return dot(a,b);}\nv0 dt(v2 a,v2 b){return dot(a,b);}\nv0 dt(v3 a,v3 b){return dot(a,b);}\n                           \n/*\nST   d0  {v0   a;v0   b              ;};//1 domains t,dt\nST   d00 {v0   a;v0   b;v0   c       ;};//1 domains t,dt,dtÂ²\nST   d000{v0   a;v0   b;v0   c;v0   d;};//1 domains t,dt,dtÂ²,dtÂ³ \nST   d1  {v0   a;v1   b              ;};//2 domains t,dt\nST   d11 {v0   a;v1   b;v1   c       ;};//2 domains t,dt,dtÂ²\nST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dtÂ²,dtÂ³ \nST   d2  {v0   a;v2   b              ;};//3 domains t,dt\nST   d22 {v0   a;v2   b;v2   c       ;};//3 domains t,dt,dtÂ²   \nST   d222{v0   a;v2   b;v2   c;v2   d;};//3 domains t,dt,dtÂ²,dtÂ³ \nST   d3  {v0   a;v3   b              ;};//4 domains t,dt\nST   d33 {v0   a;v3   b;v3   c       ;};//4 domains t,dt,dtÂ²\nST   d333{v0   a;v3   b;v3   c;v3   d;};//4 domains t,dt,dtÂ²,dtÂ³\n\n\nST c2  {d2   x;d2   y;d2   z       ;};//3 domains t,dt\n/**/\n                           \n //;d2 c=p2(p.z) //1 derivative over 3 domains\n //;3 domain-1stDerivatives are stored in .b\n //.a is a 1d point? how does that make sense?                       \n                           \n/*\n//dotProduct of a and b, 1 derivative over 1 domain\n//the mindMelter here is that a dorProduct folds to 1 domain\n//but the inputs likely have more domains than that\nd0 dt(c0 a,c0 b){\n   ;d0 r=\n    return a; //totally false function\n;}//dotProduct of a and b, 1 derivative over 1 domain\n\n                           /*\n//outputs d0, .a is 0th derivative .b is 1st derivative\nd0 dt(c1 a,c1 b\n){d0 r=D0(v1(\n    \n    dot(a.a,b.a)\n    \n             \n             ,0.))\n ;return r;//totally false function\n ;}//dotProduct of a and b, 1 derivative over 2 domains\n                           \n//outputs d0, .a is 0th derivative .b is 1st derivative\nd0 dt(c2 a,c2 b\n){d0 r=D0(v1(\n    \n    dot(a.a,b.a)\n             \n             ,0.))\n ;return r;//totally false function\n ;}//dotProduct of a and b, 1 derivative over 3 domains\n                           \n                           \n//outputs d0, .a is 0th derivative .b is 1st derivative\nd0 dt(d3 a,d3 b\n){d0 r=D0(v1(\n    \n    dot(a.a,b.a)\n    \n    \n    ,0.))\n ;return r;//totally false function\n ;}//dotProduct of a and b, 1 derivative over 4 domains\n                        \n/**/\n                           \n#define dd(a) dt(a,a)\n                           \n#define v0q v0 q=sd(v1(x.a,y.a))\n#define ll2 q,(x.b*x.a+y.b*y.a)*rec(q));}\nv0 sd(v0 a){return abs(a);}\nv0 sd(v1 a){return length(a);}//squareDotSelf==length()\nv0 sd(v2 a){return length(a);}//==sqrt(dt(a))\nv0 sd(v3 a){return length(a);}//==po(dd(a),1./2.)\nv0 cd(v0 a){return po(dd(a),1./3.);}\nv0 cd(v1 a){return po(dd(a),1./3.);}\nv0 cd(v2 a){return po(dd(a),1./3.);}\nv0 cd(v3 a){return po(dd(a),1./3.);}//cubicDotSelf\nv0 qd(v0 a){return po(dd(a),1./4.);}\nv0 qd(v1 a){return po(dd(a),1./4.);}\nv0 qd(v2 a){return po(dd(a),1./4.);}\nv0 qd(v3 a){return po(dd(a),1./4.);}//quarticDotSelf\nv0 ud(v0 a){return po(dd(a),1./5.);}\nv0 ud(v1 a){return po(dd(a),1./5.);}\nv0 ud(v2 a){return po(dd(a),1./5.);}\nv0 ud(v3 a){return po(dd(a),1./5.);}//quinticDotSelf\nd0 sd(d0 x,d0 y){v0q;return d0(ll2\nd1 sd(d1 x,d1 y){v0q;return d1(ll2\nd2 sd(d2 x,d2 y){v0q;return d2(ll2\nd1 sd(c1 u){return sd(u.x,u.y);}//2*2domains (distance on a plane in 2d)\n//d2 sd(c2 u){return sd(u.x,u.y);}//2*3domains (distance on a plane in 3d)\n//above are planar length, below are 3d lengths\nd2 sd(d2 x,d2 y,d2 z){v0 q=length(v2(x.a,y.a,z.a));\n return d2(q,(x.b*x.a+y.b*y.a+z.b*z.a)*rec(q));}\nd2 sd(c2 u){return sd(u.x,u.y,u.z);}//3*3domains (3d euclidean distance)\n\n\n//atan2() is a bit tricky, thankfully commonly only defined for vec2.\nv0 ata(v0 a){return atan(a);}//atan(x/y) has limited range and is non branching.\n//wrapping for namespace sake, for automatic differentiation:\n//first defivative of f(x)=atan(x) is fÂ´(x)=1/x*x+1\nd2 ata(d2 a\n){v0 b=atan(a.a)\n ;d2 e=mu(a,a)\n ;e=ad(e,1.)\n ;e=di(1.,e)//e=divd(1.,addd(mu(a,a),1.));\n ;return d2(b,e.b);}\n\n//expliicit atan2() //https://en.wikipedia.org/wiki/Atan2\nv0 atand(v0 x,v0 y){//return atan(y,x);//2 branches, goes full circle.\n if(x >0.)return atan(y/x);\n if(y >0.)return  pi*.5-atan(x/y);\n if(0.>y )return -pi*.5-atan(x/y);\n if(0.>x )return  pi   +atan(y/x);\n return 0.;\n}\nv0 atand(v1 a){return atand(a.y,a.x);}\n//but that means it only cares for 2 domains?\n//d1 atand(d1 a,d1 b){return a;\n\n\n\n#define u2(a)((a)*2.-1.)\n#define u5(a)((a)*.5+.5)\n#define cosu5(a) u5(cos(a))\n\n#define pi acos(-1.)\n#define ssb2(a,b) smoothstep(a,-a,b)\n#define ssb(b) smoothstep(blur,-blur,b)\n\n//these branchless comparators compare [c] with [0.0] to return [a]==true or [b]==false;\n#define step2 step(c,0.)+step(0.,c)-1.)\n//above is based on   https://www.reddit.com/r/askmath/comments/6aag2g/simplifying_stepa00step00a/\n//(a> 0)?b:c\n#define greater(a,b,c)   mix(a,b,step(c,0.))\n//(a< 0)?b:c\n#define less(a,b,c)      mix(a,b,step(0.,c))\n//(a==0)?b:c\n#define equals(a,b,c)    mix(b,a,step2\n//(a!=0)?b:c\n#define unequal(a,b,c)   mix(a,b,step2\n//(a>=0)?b:c  \"unless   \"=not less   ==greater OR equal\n#define unless(a,b,c)    mix(b,a,step(0.,c))\n//(a<=0)?b:c  \"ungreater\"=not greater==less    OR equal\n#define ungreater(a,b,c) mix(b,a,step(c,0.))\n// https://www.shadertoy.com/view/XssfRf\n\n\n                    \nv0 ss(v0 a,v0 b){return smoothstep(b,-b,a);}\n                    \nvec2 ss(vec2 a,v0 b){return smoothstep(b,-b,a);}\nvec3 ss(vec3 a,v0 b){return smoothstep(b,-b,a);}\nvec4 ss(vec4 a,v0 b){return smoothstep(b,-b,a);}\nvec4 ss(vec4 a,vec4  b){return smoothstep(b,-b,a);}\nvec4 ss(v0 a,vec4  b){return smoothstep(b,-b,vec4(a));}\n\n\nv0 add(vec2 a){return a.x+a.y;}\nv0 suv(vec4 a){return dot(vec4(1),a);}v0 suv(vec3 a){return dot(vec3(1),a);}v0 suv(vec2 a){return a.x+a.y;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\n\n#define segment2(a,c) dd((a-(c*sat((dot(a,c)/dd(c))))))\n//sqared orthogonal projection ,segment()subroutine ,is squared distance\n#define segments(a,b,c) (segment2((a-b),(c-b)))\n//offset segment2(a,c) by -b\n#define segment(a,b,c) sqrt(segments(a,b,c))\n//pointAdistance to (diagonal) lineSegment from B to C\n\nv0 sh4(v0 x){return x*x*x*(x*(x*6.-15.)+10.);}\n\nmat2 rot2D(v0 r){v0 c = cos(r), s = sin(r);return mat2(c, s, -s, c);}\n\n//hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\nvec2 hash(vec2 p \n){p=vec2(dot(p,vec2(127.1,311.7))\n        ,dot(p,vec2(269.5,183.3)))\n ;return fract(sin(p)*43758.5453123)*2.-1.;}\n// returns -.5 to 1.5. i think.\nv0 noise(in vec2 p\n){const v0 K1 = 0.366025404 // (sqrt(3)-1)/2;\n ;const v0 K2 = 0.211324865 // (3-sqrt(3))/6;\n ;vec2 i = floor( p + (p.x+p.y)*K1)\n ;vec2 a = p - i + (i.x+i.y)*K2\n ;vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0) //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n ;vec2 b = a - o + K2\n ;vec2 c = a - 1.0 + 2.0*K2\n ;vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 )\n ;vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)))\n ;return dot( n, vec3(70.0));}\nv0 noise01(vec2 p){return clamp((noise(p)+.5)*.5, 0.,1.);}\n\nv0 dtoa(v0 d,v0 a){return sat(1./(clamp(d,1./a,1.)*a));}\n\nv0 sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br//rounded rectangle\n){vec2 d = max(tl-uv, uv-br)\n ;return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));}\n\n\n\n\n// 0-1 1-0\nv0 smoothstep4(v0 e1, v0 e2, v0 e3, v0 e4, v0 val\n){return min(smoothstep(e1,e2,val),1.-smoothstep(e3,e4,val));}\n\nv0 rand(vec2 co){return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);}\nv0 rand(v0 n){return fract(cos(n*89.42)*343.42);}\nfloat paperbleed(vec2 u){return (2.+rand(u.y)+rand(u.x))*30.;}//ink bleeds on papyrus.\n\n/**/ // end__: common aliases\n/**/ // start: iDiegeticUI v2 header:\n/*\n\nself  : https://www.shadertoy.com/view/WtfGDM\nparent: https://www.shadertoy.com/view/Xt3BzX (multiple dots smoothened compositing)\nparent: https://www.shadertoy.com/view/XttBRB (multiple dots smoothened)\nparent: https://www.shadertoy.com/view/4dtSRn (multiple dots)\nparent: https://www.shadertoy.com/view/MdKGRw (ui widgeds)\nreusable drag and drop framework. \n- Drag objects around by clicking on them.\n- Add new objects by clicking in space.\n- Delete objects by dragging them to the red square.\n\n\n/**/ //end__ diecetic_UI_2 header\n/**/ //start diecetic_UI_2 \n/*\n\n/*\nmodifiables for diecetic_UI_2\nare used by the buffer [iDiegeticUI]\n*/\nconst v0 maxCount = 128.;//large numbers are fine.\n#define  UiDotBorder 1. //dot outline thickness\nconst v0 UiDotRadius = 10.;\n#define clickPointRadius UiDotRadius\nconst v0 statePos = maxCount;\nconst v0 offsetPos = maxCount + 1.;\nconst vec4 deleteRect=vec4(0.,0.,40.,40.);\n\n\nbool inRect(vec2 u, vec4 b\n){b.xyzw-=u.xyxy\n ;return mi(b.zy-b.xw)<mi(b)\n ;return min(b.z-b.x,b.y-b.w)<mi(b) ;}\n\nvoid rToD(v0 d,inout v0 r,inout vec4 state,inout v0 f,inout vec4 o,vec4 center,vec4 m\n){if(d<r\n ){r=d\n  ;state.x=f\n  ;o=center-m;}}\n\n\n//rgba colorspace matrices\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nvec3 rainbow(v0 a,v0 b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbowt(v0 a,v0 b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbow(v0 a){return rainbow(a,1./3.);}\nvec3 rainbowt(v0 a){return rainbowt(a,1./3.);}\n#define ToRgb(a) return c.z*mix(vec3(1.),sat(a(-c.x)),c.y);}\nvec3 angleToColor(vec3 c){ToRgb(rainbow)//cos-mix\n//vec3 hsv2rgb(vec3 c){ToRgb(rainbow2)//linear-mix not identical to the below, but close\nvec3 hsv2rgb(const vec3 c){return c.z*mix(vec3(1),sat(abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),c.y);}\nvec3 rgb2hsv(vec3 a){vec4 K=vec4(0,-1,2,-3)/3.//https://www.shadertoy.com/view/MdGfWm\n ;vec4 P=mix(vec4(a.bg,K.wz),vec4(a.gb,K.xy),step(a.b,a.g));vec4 Q=mix(vec4(P.xyw,a.r),vec4(a.r,P.yzx),step(P.x,a.r))\n ;v0 D=Q.x-min(Q.w,Q.y),E=1e-10;return vec3(abs(Q.z+(Q.w-Q.y)/(6.*D+E)),D/(Q.x+E),Q.x);}\n\n#define tiny .00001\n\nvec2 gLLxX(vec2 A,vec2 B,vec2 C,vec2 D//line line intersection  http://wiki.secondlife.com/wiki/Geometric\n){vec2 b=B-A,d=D-C,c=C-A\n ;v0 dotperp=b.x*d.y-b.y*d.x\n ;if (dotperp==0.)return A\n ;dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;v0 t=(c.x*d.y-c.y*d.x)/dotperp\n ;return vec2(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n//below doesnt catch parallel div0 cases.\nvec2 gLLxX0(vec2 A,vec2 B,vec2 C,vec2 D//line line intersection  http://wiki.secondlife.com/wiki/Geometric\n){vec2 b=B-A,d=D-C,c=C-A\n ;v0 dotperp=b.x*d.y-b.y*d.x\n ;//if (dotperp==0.)return A\n ;//dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;v0 t=(c.x*d.y-c.y*d.x)/dotperp\n ;return vec2(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n#define Over 0.\n#define Atop 1.\n//#define ut(a,b) (a*(1.-b))\nv3 ut(v3 a,v0 b){return a*(1.-b);}\nv2 ut(v2 a,v0 b){return a*(1.-b);}\nv1 ut(v1 a,v0 b){return a*(1.-b);}\nv0 ut(v0 a,v0 b){return a*(1.-b);}\n#define Out 2.\n#define Xor 3.\n#define In 4.\n//vec4 pdOut(v31 a,v31 b){return ut(b,a.b);}\n\nvec4 pdOut(vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+a*b.w;}\nvec4 pdXor(vec4 a,vec4 b){return ut(b,a.w)+vec4(ut(a,b.w));}\nvec4 pdIn(vec4 a,vec4 b){return vec4(a.xyz*b.w,1);}//pdIn() is just multiplication, note swapped AB case here\n//https://en.wikipedia.org/wiki/Alpha_compositing\nvec4 aOverB(vec4 a,vec4 b){a.xyz*=a.w;b.xyz*=b.w;return vec4(a+b*(1.-a));}\n//vec2 aOverB(vec2 a,vec2 b){a.x*=a.y;b.x  *=b.y;return vec2(a+b*(1.-a));}\n//not sure if correct, but looks useful.\nvec4 aXorB(vec4 a,vec4 b){a.xyz*=a.w;b.xyz*=b.w;return vec4(a*(1.-b)+b*(1.-a));}\n//vec2 aXorB(vec2 a,vec2 b){a.x*=a.y;b.x  *=b.y;return vec2(a*(1.-b)+b*(1.-a));}\n//return color corrected r\nvec3 ff_filmic_gamma3(vec3 r){vec3 x=max(vec3(0),r-.004)\n;return (x*(x*6.2+.5))/(x*(x*6.2+1.7)+.06);}     \n\n                          \n//project point [a] onto line trough vecN(0) and vecN([b])\nvec2 project(vec2 a,vec2 b){return b*dot(a,b)/dd(b);}\nvec2 projectS(vec2 a,vec2 b){return b*sat(dot(a,b)/dd(b));}\n//vec3 project(vec3 a,vec3 b){return a*dot(a,b)/dd(b);}\n//vec4 project(vec4 a,vec4 b){return a*dot(a,b)/dd(b);}\n//shortest distance between point [a] and line trough vecN(0) and vecN([b])\n//vec2 dLine(vec2 a,vec2 b){return a*dot(a,b)/dd(b);}\n\n//get 2/3 roots by http://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\n#define root232(a,b)  add(sign(b)*pow(abs(b),vec2(1./3.)))-a/3.\n#define root23(a,b,d) root232(a, ((vec2(1,-1)*sqrt(d)-q)*.5) )\nvec2 solveCubic2b(v0 a,v0 b,v0 c//https://www.shadertoy.com/view/XtdyDn\n){vec2 p=vec2(b-a*a/3.,a)\n ;v0 q=a*(2.*a*a-9.*b)/27.+c\n ,s=p.x*p.x*p.x\n ;c=q*q+4.*s/27.//determinant seperates cases where a root repeats\n ;if(q*q+4.*s/27.>0.)return root23(vec2(a),b,c)//both return values are identical\n ;v0 v=acos(-sqrt(-27./s)*q*.5)/3.,m=cos(v),n=sin(v)*sqrt(3.);p/=3.//...does not care for 3rd (middle) root, intended as subroutine for bezier/parabola\n ;return vec2(m+m,-n-m)*sqrt(-p.x)-p.y;}//middle root is something line m-n or n-m, salbe scaling\nvec2 solveCubic2b(vec3 a){return solveCubic2b(a.x,a.y,a.z);}//https://www.shadertoy.com/view/XtdyDn\n//...does not care for 3rd (middle); middle root is something line m-n or n-m, salbe scaling\n\n//http://www.perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\n//BezierQuad is ALWAYS coplanar (3 CVs define a plane)\n//dot()projection to 2d, and a fold to 1d, simplify  lot\n\n//return distance of u to bezierQuad with CVs(a,b,c); is (always) coplanar 2d.\nvec2 dQBezierSub(inout vec2 u,inout vec2 a,inout vec2 b,vec2 c//..input[b] is not on the liine,but defines a triangle bound.\n){b=mix(b+vec2(1e-4),b,abs(sign(b*2.-a-c)))//catch colinear case\n ;u-=a;a=b-a;b=c-b-a\n ;return solveCubic2b(vec3(-3.*dot(a,b),dot(u,b)-2.*dd(a),dot(u,a))/-dd(b))\n ;}\n\n#define BezierQuadTail(u,a,b,c) min(dd((a*2.+b*c.x)*c.x-u),dd((a*2.+b*c.y)*c.y-u))\n\n//there is likely a better check for colinearity\n//this one may even fail iff any 2 of 3 points are identical.\nbool isColinear(vec2 a,vec2 b,vec2 c){return length(normalize(a-b)-normalize(a-c))<.001;}\n\n//return distance of u to Parabola over bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuadParabola(vec2 u,vec2 a,vec2 b,vec2 c//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n\n//return distance of u to bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuad(vec2 u, vec2 a, vec2 b, vec2 c//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;c=sat(c);//a bezier is a clamped 2dParabola\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n\n\n//return distance of u to bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuadGeneral(vec2 u, vec2 a, vec2 b, vec2 c,vec2 m//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;c=clamp(c,m.x,m.y)//https://www.shadertoy.com/view/Xl3BRX\n                  //bezier is just a clamped parabola\n                   //from [[0].. [.5]..[1]] , which bijectively maps to [a..b..c]\n                   //a better range would be [-1..1], to map better onto this function?\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a) )\n\n//return p1 of quadratic bezier, when given start, end and arclength\nvec2 knee(vec2 p0,vec2 p2,v0 L//https://www.shadertoy.com/view/4ltyWr\n){vec2 l = p2-p0\n ;v0 h = sqrt(max(0.,L*L-dot(l,l)))/2. *sign(L)\n ;return (p0+p2)/2.+sqrt(max(0.,L*L-dot(l,l)))/2. *sign(L)*normalize( vec2(-l.y,l.x) )     \n ;}\n                          \n/**/ //--- start AD-/mercury.sexy/hd_sdf\n\n//Below are translations of the hg_sdf library\n//to use the above [Derivative Arithmetic]\n//mostly just in prefix-notation\n//but also with quite the tricky structure\n//as examples. on how to translate between 2 arithmetics.\n\n//return distance to unit sphere\nd2 fSphere(c2 p){d2 q=sd(p.x,p.y,p.z);return su(q,1.);;}\n//return distance to infinite line segment\nd2 fRay(c2 p){p.x.a=mix(0.,p.x.a,step(p.x.a,0.));\n d2 q=sd(p.x,p.y,p.z);return su(q,1.);}//this might be \"broken\" now.\n//fRay() was an error that I chose to keep.\n\n//return distance to box size (s),\n//... corners extrude, keeping all agngles, underestimating distances.\nv0 fBoxCheap(v2 p,v2 b\n){v2 q=abs(p);q=q-p//mirror clamp\n ;return max(max(q.x,q.y),q.z);}\nd2 fBoxCheap(c2 p,v2 s\n){c2 u=suab(p,s)//mirror clamp\n ;return madm(u);}  \n//return distance to box size (s), corners extrude to rounded spheres.\nv0 fBox(vec3 p,vec3 s\n){v2 d=abs(p)-s//mirror clamp\n ;v0 a=length(max(d,0.))//rounded corners\n ;v2 q=min(d,0.)//clamp\n ;v0 b=max(max(q.x,q.y),q.z)//keep largest of 3\n ;return a+b;}//add //hg_sdf\nd2 fBox(c2 p,v2 s){//v3 s=v3(1.5,.5,1.5);\n c2 d=suab(p,s);//mirror clamp\n d2 a=sd(ma(d,0.));//rounded corners\n c2 q=mi(d,0.);//clamp\n d2 b=madm(q);//keep largest of 3\n return ad(a,b);}//add\n\nv0 fOpUnionRound(v0 a,v0 b,v0 r\n){vec2 u=max(vec2(r-a,r-b),0.);return max(r,min(a,b))-length(u);}     \nd2 fOpUnionRound(d2 a,d2 b,v0 r\n){d2 x=su(r,a);x=ma(x,0.)\n ;d2 y=su(r,b);y=ma(y,0.);x=sd(x,y)\n ;d2 m=mi(a,b);m=ma(r,m);return su(m,x);}\n//does not seem to have good lipschitz.\nv0 fOpIntersectionRound(v0 a,v0 b,v0 r\n){vec2 u=max(vec2(r+a,r+b),0.);return min(-r,max(a,b))+length(u);}\nd2 fOpIntersectionRound(d2 a, d2 b,v0 r\n){d2 x=ad(r,a);x=ma(x,0.)\n ;d2 y=ad(r,b);y=ma(y,0.);x=sd(x,y)\n ;d2 m=ma(a,b);m=mi(-r,m);return ad(m,x);}\n#define fOpDifferenceRound(a,b,r) fOpIntersectionRound(a,negd(b),r)\n\nv0 pMod1(inout v0 p,v0 s){p/=s\n;v0 c=floor((p)+.5);p=(fract(p+.5)-.5)*s;return c;}\nd2 pMod1(d2 p,v0 s){p=di(p,s)\n;//vec4 c=floord4(p);//c=subd(c,.5);//v0 c=floor((p)+.5);\n;p=ad(p,.5);p=fractd(p);p=su(p,.5);p=mu(p,s)//p=(fract(p+.5)-.5)*s;\n;return p;}\n                          \n/*\nhttps://en.wikipedia.org/wiki/Holonomic_function\nhave closed forms in derivatives and antiderivatives.\n*/\n\n//Goursat Surface is an implicit surface with VERY high [rootMultiplicity\n//it is THE goto if you want high exponents, high precision and high performance\n//because it excessively pow(a,2.) and pow(a,4.) over 3 domains\n//no NOT confuse exp2(a)=pow(2.,a )=ex(2.,a )=e2(a)\n//with             (a*a)=pow(a ,2.)=ex(a ,2.)=p2(a)=mu(a,a)\n//goursat has not good LipschitzContinuity, scales with distance to singularities!\nd2 sdGoursat(c2 p,vec4 m//https://www.shadertoy.com/view/XlV3Dy\n){d2 a=p2(p.x),b=p2(a);a=mu(5.,a)\n ;d2 c=p2(p.y),d=p2(c);c=mu(5.,c)\n ;d2 e=p2(p.z),f=p2(e);e=mu(5.,e)\n ;d=ad(d,f);c=ad(c,e)\n ;b=ad(b,d);a=ad(a,c)\n ;b=su(b,a)\n ;b=ad(20.*m.x,b)\n ;v0 q=length(b.b.xyz)\n ;q=max(11.8,q)\n ;return di(b,q);}\n                    \nd3 sdGoursat(c3 p,vec4 m//4d goursat surface or some sort of shadow?\n){d3 a=p2(p.x),b=p2(a);a=mu(5.,a)\n ;d3 c=p2(p.y),d=p2(c);c=mu(5.,c)\n ;d3 e=p2(p.z),f=p2(e);e=mu(5.,e)\n ;d=ad(d,f);c=ad(c,e)\n ;b=ad(b,d);a=ad(a,c)\n ;b=su(b,a)\n ;b=ad(20.*m.x,b)\n ;v0 q=length(b.b.xyz)\n ;q=max(11.8,q)\n ;return di(b,q);}\n\n//explicit type dual_v0 dd()\n#define dd2(a,b) ad(p2(a),p2(b))\n\n//known bug:                          \n//r.y==0. results in nan-noise on many cases.//sdUnterprim() has the preprocessor sdUberprim()             \n//yeah, because r.y then sets the thickness of a wall\n\n                          \nd2 sdUnterprim(c2 u,v2 r,v3 m//m is [s]Uberprim\n){c2 d=su(ab(u),m.xyz)\n  //sadly this lower bound for thickness must be this high (for many shape-cases)\n ;if(abs(r.y)<.0004)r.y=.0004//worksafe: abs(wall thickness)>=mEpsilon\n ;v0 t=mu(-2.,m.z)\n ;v0 s=t\n ,w=dd2(r.z,t)\n ;//w=ma(w,.1)\n ;t=di(t,w)\n ;w=di(r.z,w)\n ;d2 q=dd2(ma(d.x,0.),ma(d.y,0.))\n ;q=sr(ab(q))\n ;q=su(q,r.x)\n ;q=ad(q,mi(0.,ma(d.x,d.y))) \n ;//hole support: without this line, all results are convexHulls/holeLess\n #ifndef CONVEX    \n ;q=ab(q)\n ;q=su(q,m.w)\n #endif \n ;d2 f=su(u.z,m.z)\n ;d2 i=mu(q,w)\n ;i=ad(i,mu(f,t))  \n ;i=mi(i,1.)\n ;i=ma(i,0.)\n ;d2 x=su(q,mu(r.z,i))\n ;d2 y=su(f,mu(s,i))\n ;d2 h=ad(u.z,m.z)\n ;d2 g=ma(su(q,r.z),0.)\n ;d2 e=ma(q,0.)\n ;d2 c=dd2(x,y)//dot(diag,diag)\n ;d2 a=dd2(g,h)//dot(h0,h0)\n ;d2 b=dd2(f,e)//dot(h1,h1) //f is read alone later on\n ;a=mi(a,b)\n ;a=mi(a,c)\n ;a=sr(ab(a))\n ;b=su(mu(f,w),mu(q,t))//is a dot()\n ;b=ma(b,d.z)\n ;b=sg(b)\n ;a=mu(a,b)\n ;return su(a,r.y);}\n// m: width, height, depth, thickness\n// r: xy corner radius, z corner radius, bottom radius offset\nd2 sdUberprim(c2 p,v3 m,v2 r\n){m.xy=m.xy-r.x\n #ifdef CONVEX  \n ;r.x=su(r.x,r.y)\n #else\n ;r.x=su(r.x,m.w);m.w=su(m.w,r.y)\n #endif\n ;m.z=su(m.z,r.y)\n ;return sdUnterprim(p,r,m);}//https://www.shadertoy.com/view/MsVGWG\n                          \nfloat brushNoise(vec2 v,vec3 r//https://www.shadertoy.com/view/ltj3Wc\n){v+=(noise01(v)-.5)*.02\n ;v+=cos(v.y*3.)*.009\n ;v+=(noise01(v*5.)-.5)*.005\n ;v+=(noise01(v*min(r.y,r.x)*.18)-.5)*.0035\n ;return v.x;}\n\n//\"Magic Fractal\" for fungus/splatters (on metaball), by dgreensp\n//aka MAGIC_BOX-fractal: https://www.shadertoy.com/view/4ljGDd\nfloat fractalFungus(vec3 p){p=1.-abs(1.-mod(p,2.));vec3 f=vec3(0,length(p),0)\n ;for(int i=kifsFungusIter;i>0;i--      \n ){p=abs(p)/(f.y*f.y)-kifsFungusSeed;f.z=length(p);f=vec3(f.x+abs(f.z-f.y),f.zz);}return f.x;}\nfloat fractalFungus(vec2 u\n){return fractalFungus(mat3(.28862355854826727,.6997227302779844 , .6535170557707412\n                          , .06997493955670424,.6653237235314099 ,-.7432683571499161\n                          ,-.9548821651308448 ,.26025457467376617, .14306504491456504)*vec3(u,0));}         \n\n                          \n                          \n//lazy gradient debugger for sweep brush strokes  https://www.shadertoy.com/view/ltj3Wc\n//to be replaced with some smarter stuff\nvec3 debugDist(float u){vec3 r\n //;u*=pi *100.\n ;if(u>0.)r=mix(vec3(0, 0,.5),vec3(.5,.5,1),sin(u*pi *100.))// red = negative / inside geometry.\n ;else    r=mix(vec3(1,.5,.5),vec3(.5, 0,0),sin(u*pi *100.))// blue = positive, of of geometry.\n ;r = mix(r,vec3(0),sat(abs(u)))// falloff\n ;return r;}\n                          \n/*\nlazy animated checkerboard\n//inspired by https://www.shadertoy.com/view/4tG3Wh\n//i failed to extend this one to 3d.  \n#define hfrac vec2 h){h=fract(h)\n#define gthv greaterThan(h,vec2\n#define floatbool2);return float(b.x==b.y);}\nfloat checkerBool(hfrac;return float(h.x>.5==h.y>.5);}\n//checkerBool2()might be faster than checkerBool()//xy are independent\nfloat checkerBool2(hfrac;bvec2 b=gthv(.5   )floatbool2\n//checkerBoolT oscillates xy comparators over time.\nfloat checkerBoolT(hfrac;bvec2 b=gthv(cos(iTime)*.45+.5)floatbool2\n/**/\n\n                          \n                          \n//pluginName= iCanvas\n//self: https://www.shadertoy.com/view/ltj3Wc   (brush stroke experiments)\n//crunched by ollj, minor featuures removed.\n//slowly assimilation, to be merged with BuffD\n//duroing that it lives in the sump of the commontap\n//produce a line with brush strokes. the inputs are such\n//that you can apply it to pretty much any line; the geometry is separated from this function.\nvec3 colorBrushStroke(vec2 u,vec3 r,vec4 m,vec2 p,float w, float sdGeometry, vec3 inpColor, vec4 bc//brushColor\n){w=(u.y/w)// position along the line. in the line is 0-1.\n ;if(false ){ //important for uv debugging\n  ;//return mix(inpColor, vec3(0), dtoa(sdGeometry, 1000.));// reveal geometry.\n  ;//return mix(inpColor, debugDist(u.y), dtoa(sdGeometry, 1000.));// reveal Y\n  ;//return mix(inpColor, debugDist(w), dtoa(sdGeometry, 1000.));// reveal pos in line.\n  ;return mix(inpColor, debugDist(u.x), dtoa(sdGeometry, 1000.));// reveal X\n  ;}\n ;if(w>0.   // warp position-in-line, to control the curve of the brush falloff.\n ){float mouseX=m.x==0.?.2:(m.x/r.x)\n  ;w = pow(w, (pow(mouseX,2.)*15.)+1.5);}\n ;float n=0.//bleed noise\n +noise01(u*vec2(min(r.y,r.x)*.2, 1.))//tiny\n +noise01(u*vec2(79,1))//fine\n +noise01(u*vec2(14,1))//coarse\n ;n*=dtoa(sdGeometry, 300.)/3.// keep stroke texture inside geometry.\n ;n=max(.08,n)//null-evasion\n ;float a=pow(n,max(0.,w)+.09)//add allows bleeding\n ;if(w>0.)a=max(0.,a-pow(w,0.5))//optioonal more fading\n ;a=sh4(a)+.4*smoothstep(17.,18.5,fractalFungus(vec3(p,u.x)))//hermite+fungalFreckles\n ;bc.a=sat(a*bc.a*dtoa(sdGeometry,paperbleed(p)))\n ;return mix(inpColor,bc.xyz,bc.a);}\nv2 strokeLine(v1 u,v2 r,v3 M,v2 c, v3 b, v3 m, v0 w\n){v0 lineAngle=atan(m.x-m.z,m.y-m.w)//axis-align\n ;mat2 rotMat =rot2D(lineAngle)\n ;v0 W=length(m.xy-m.zw)    // make an axis-aligned line from this line.\n ;v1 T=m.xy*rotMat// top left\n ;v1 B=T+v1(0,W)// bottom right\n ;v1 l=u*rotMat\n ;l.x+=(noise01(l*1.)-.5)*.02\n ;l.x+=cos(l.y*3.)*.009//lp wave\n ;l.x+=(noise01(l*5.)-.5)*.005;//random waviness like individual strands are moving around\n ;l.x+=(noise01(l*min(r.y,r.x)*.18)-.5)*.0035;// HP random noise makes it look less scientific\n ;v0 d=sdAxisAlignedRect(l,T,B)-w/2.\n ;return colorBrushStroke((T-l)*vec2(1,-1),r,M,u,W,d,c,b);}\n//https://en.wikipedia.org/wiki/EnsÅ\n//japanese zen glyph, dualism-enlightenment circle, a signature that captures a moment in time.\nvec3 humanizeEnso(vec2 u,vec3 R,float r,float lineLength//return: xy=u, z = radius\n){vec2 v=u\n ;v.x+=v.y*.24/lineLength//offset circle along its path for a twisting effect.\n ;r+=(noise01(u*1.)-.5)*.04\n ;r+=sin(u.y*3.)*.019//lp wave\n ;v.x+=sin(u.x*30.)*.02\n ;float b=min(R.y,R.x)*.18\n ;v.x+=(noise01(u*b )-.5)*.0035//HP random noise makes it look less scientific\n ;v.x+=(noise01(u*5.)-.5)*.005 //random waviness like individual strands are moving around\n ;return vec3(v,r);}\n//sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. \n//1=whole circle. 0=just a point.\n//u,canvasColor,brushColor,n,angle,sweepAmt,lineWidth\nvec3 enso(vec2 u,vec3 R,vec4 M,vec3 c, vec4 b,vec2 o,float n, float a, float sweepAmt, float w\n){vec2 v=u-o\n ;//vec3 R=iResolution\n ;//vec4 M=iMouse\n ;float angle = mod(atan(v.x, v.y)-a,tau)\n ;float d=n*tau//is far from euclidean due to all noise below. \n ;v=vec2(n-length(v),angle* d/tau)\n ;float lineWidth1=w*mix(1.,.9,smoothstep(0.,d,v.y))//narrow end\n ;vec3 h=humanizeEnso(v,R,n,d)\n ;float e=max(-length(u-o)+h.z,length(u-o)-h.z)\n ;e-=lineWidth1*.5// round off\n ;vec3 r=vec3(1),r2=colorBrushStroke(h.xy,R,M,u,d,e,c,b)\n ;if(angle>pi //modifies h, so above line cant go below\n ){v.y-=d\n  ;h=humanizeEnso(v,R,n,d)\n  ;vec2 strokeStartPos=o+vec2(sin(a),cos(a))*h.z      \n  ;e=length(u-strokeStartPos)-w*.5*1.// round off things just like in the line routine.\n  ;r=colorBrushStroke(h.xy,R,M,u,d,e,c,b)\n  ;}\n ;return min(r,r2);}\nvec3 brushCircle(vec2 u,vec3 r,vec4 m,vec3 c\n){return enso(u*vec2(1),r,m,c, vec4(0,0,0,.9)\n                            ,vec2(0,0),// origin\n                                .6,// radius\n                                .2,// angle of brush start\n                                .5,// sweep amt 0-1\n                                .3)// width\n;}    \nvec3 redline0(vec2 u,vec3 r,vec4 m,vec3 c,float yo\n){return strokeLine(u,r,m,c,vec4(vec3(.8,.1,0),.9),vec4(-1.4,yo-.4,2.6,yo-.4),.3);}\nvec3 redline1(vec2 u,vec3 r,vec4 m,vec3 c,float yo\n){return c=strokeLine(u,r,m,c,vec4(vec3(.8,.1,0),.4),vec4(1.3,yo,-2.9,yo),.03);}\nvec3 redline2(vec2 u,vec3 r,vec4 m,vec3 c,float yo\n){return c=strokeLine(u,r,m,c,vec4(vec3(.8,.1,0),0.52),\n                           vec4(1.3,.3+yo+(cos(u.x*12.)*.025),-2.9,.3+yo),.1);}\n//shitty subroutine is shitty\nvec2 getuv_centerX(vec2 fragCoord,vec3 r, vec2 newTL, vec2 newSize\n){vec2 ret = vec2(fragCoord.x / r.x, (r.y - fragCoord.y)/r.y)\n ;// ret is now 0-1 in both dimensions\n ;ret*=newSize// scale up to new dimensions\n ;v0 aspect = r.x / r.y\n ;ret.x *= aspect// orig aspect ratio\n ;v0 newWidth = newSize.x * aspect\n ;return ret + vec2(newTL.x - (newWidth-newSize.x) / 2.0, newTL.y);}\nvec4 ltj3Wc(vec4 o, in vec2 u,vec3 r,vec4 m\n){//vec3 r=iResolution\n ;//vec4 m=iMouse\n ;//o=vec4(.01*magicBox(vec3(u/iResolution.xy,iMouse.x)));return;//debug hash\n ;vec2 uv=(u/ r.y * 2.0) - 1.\n ;u = getuv_centerX(u,r, vec2(-1,-1), vec2(2,2))// 0-1 centered\n ;vec3 c=vec3(1.,1.,0.875)// bg\n ;v0 dist\n ;// geometry on display...\n ;v0 yo = sin(-u.x*pi*0.5)*0.2\n ;c=redline0(u,r,m,c,yo)\n ;c=redline1(u,r,m,c,yo)\n ;c=redline2(u,r,m,c,yo)\n ;c=brushCircle(u,r,m,c)\n ;// paint blotches\n ;v0 blotchAmt = smoothstep(20.,50.,fractalFungus((u+12.)*2.))// smoothstep(40.,40.5, fractalFungus((uv+9.4)*2.));\n ;blotchAmt = pow(blotchAmt, 3.)// attenuate\n ;blotchAmt = .7*smoothstep(.2,.4,blotchAmt)// sharpen\n ;c*=1.-blotchAmt\n ;// signature/stamp code removed\n ;c.rgb+=(rand(u)-.5)*.08// grain\n ;c.rgb=sat(c.rgb)//clamp\n ;vec2 uvScreen=(u /r.xy * 2.)-1.\n ;//c*=1.-dot(uvScreen*.5,uvScreen*.62)// vignette\n ;return vec4(c,1);}\n//note to self, this shader uses amt in leu of amount\n//, so the term \"sweep amt\" is somewhat coined in a new context\n                          \n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/**/ //start plugin notes:\n/*\n\npluginName= iDiegeticUI v2\n\niChannel0=BuffA,iChannel1=BuffB,iChannel2=BuffC,iChannel3=BuffD\n- scale inout to storage data by iResolution.xy (or your scaling will just be off)\n\n\nThese plugin specific subroutines of this shader are only used in this shader:\n-   addInit() //initial state == onInit() dot[x] positions\n- clickLoop()\n-   branchi()\nShared Common Subroutines\n- see CommonTab: modifiables for diecetic_UI_2\n- const v3 deleteRect  AxisAlignedBound (red deletion rectangle)\n- inRect(uv,deleteRect) //contextBoundFilter\niDiegeticUI has lots of visualization code, likely only needed in ImageTab\n- drawDragDots()\n\n--- pseudocode structure:\nmainImage(){\n ;//...\n ;if (iFrame==0\n ){v0 count=0.//init\n  ;addInit()\n  ;}\n ;//...\n ;     if(max(state.z,-iMouse.z)<0.)clickLoop(...)\n ;else if(min(state.z,-iMouse.z)>0.&&inRect(iMouse.xy,deleteRect\n ){branchi(...)\n  ;//...\n  ;}\n ;}\n\niDiegeticUI buffers a list of dot[x]\n, for a dragAndDrop UI (in screenspace)\n, and one fragment buffers [number of dots]\n\nAny other shader can read these dot-coordinates\n, commonly used to modify parameters of parametricFunctions:\n- parametric CSG (debug/demo frustrumCulling or AutomaticDifferentiation)\n- - [megaprm]\n- - \"implicit\" splines/isosurfaces\n\nthis buffer stors states that set:\n- number of stored states\n-.xy coordinate of points for [diecetic UI]\n\n/**/ //end__ plugin notes:\n\n\n/*\ndiecetic /screenspace UI = reusable drag&drop\n, as basis for some non-screenspace diegetic-UI\n, like in a FlightSim, [BattleTech], [DeathSpace] or [Astroneer]\n\nparent     : https://www.shadertoy.com/view/Xt3BzX\nparent     : https://www.shadertoy.com/view/4dtSRn\nInspired by: https://www.shadertoy.com/view/MdKGRw\nreusable drag and drop framework; by mhnewman\n- Drag objects around by clicking on them.\n- Add new objects by clicking in space.\n- Delete objects by dragging them to the red square.\n\nbuffOfDot(v0(floor(x))) function returns parameters of dot[x]\n- THIS shader should not contain buffOfDot()\n- , but instead most likely just the [ImageTab] for a screenspace UI\n\nmaxCount := the maximum number of objects that can be represented.\nBuffer pixels (0, 0) to (maxCount - 1, 0) := the coordinates of each object.\n  * .x := the object's x coordinate.\n  * .y := the object's y coordinate.\n\n Buffer pixel (maxCount, 0) := the current state.\n  * .x := the index of the currently selected object.\n  * .y := the number of active objects.\n  * .z := the mouse state.\n\n Buffer pixel (maxCount + 1, 0) := the mouse offset from the center of the current object.\n\n/**/\n\n//alias for an initial state:\n#define addInit(xPos, yPos) {if(u.x==count)o=v3((xPos),(yPos),0.,0.);count+=1.;}\n\nvoid  clickLoop(inout v3 state,v3 o,v3 m\n){v0 r=clickPointRadius+1.\n ;for(v0 i=0.;i<maxCount;++i\n ){v0 f=i\n  ;if(f>=state.y)break\n  ;v3 center=texture(iDiegeticUI ,v1(.5+f,.5)/iResolution.xy)\n  ;rToD(length(m.xy-center.xy),r,state,f,o,center,m);\n ;}if(r>clickPointRadius)state.xy=mix(v1(2.*statePos,state.y),state.yy+v1(0,1),step(state.y,statePos));}\n\nvoid branchi(inout v3 o, v1 u,v0 S,v3 s,v1 U//out,uv,statepos,state,U\n){     if(u.x==S )o=v3(2.*S,s.y-1.,iMouse.z,1)\n ;else if(u.x<s.x)o=texture(iDiegeticUI, U/iResolution.xy)\n ;else            o=texture(iDiegeticUI,(U+v1(1,0))/iResolution.xy);}\n\nvoid mainImage(out v3 o,in v1 U\n){v1 u=U-.5\n ;v2 r=iResolution.xyz\n ;v3 m=iMouse.xyzw\n ;if(u.y>0.||u.x>offsetPos){o=v3(0);return;}\n ;if(iFrame==0\n ){v0 count=0.//init\n  ;addInit(.35*iResolution.x,.4 *iResolution.y)//initial iFrame==0 dot placement\n  ;addInit(.75*iResolution.x,.9 *iResolution.y)\n  ;addInit(.5 *iResolution.x,.1 *iResolution.y)\n  ;//addInit(.4 *iResolution.x,.9 *iResolution.y)\n  ;//addInit(.5*iResolution.x,.3*iResolution.y)\n  ;if(u.x==statePos)o=v3(2.*statePos,count,0.,0.);return;}\n ;v3 s=texture(iDiegeticUI,v1(.5+ statePos,.5)/r.xy)\n ;     o=texture(iDiegeticUI,v1(.5+offsetPos,.5)/r.xy)\n ;     if(max(s.z,-m.z)<0.)clickLoop(s,o,m)\n ;else if(min(s.z,-m.z)>0.&&inRect(m.xy,deleteRect)\n ){branchi(o,u,statePos,s,U);return\n ;}if(u.x==statePos)o=v3(s.xy,m.z,s.w)\n ;else if(u.x==offsetPos)o=o\n ;else if(u.x==s.x&&m.z>0.)o=m+o\n ;else o=texture(iDiegeticUI,U/iResolution.xy)\n ;}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//pluginName= iAD\n/*\niChannel0=BuffA,iChannel1=BuffB,iChannel2=BuffC,iChannel3=BuffD\n*/\n\n/**/ //--- srart AD-Modifiers \n//these can be twiddled with, without breaking much\n\n#define SuperPrim\n\n#define thick .1\n//line thickness\n\n#define scene 2\n//scene: theres 2 scene-layers, a 2d scene and a 3d scene:\n//domains 1 <-> 2d\n//domains 2 <-> 3d\n//domains 3 <-> mix(3d,2d)\n\n#define IterRm 64.\n//max raymarch iterations|steps\n\n#define IterSh 16.\n//softshadow iterations\n \n#define ReciprocalAbsLipschitz 1.\n//if(lipschitzConstant>1., distance is overestimated.\n//multiplying by ReciprocalAbsLipschitz is a \n//... lazy fix for that is scaling stepDistance*=ReciprocalAbsLipschitz\n//higher precision with a smaller ReciprocalAbsLipschitz AND epsilon=0.\n//meaning, a surface will NEVER really be reached.\n//maybe todo: eps=log(eps*b)*a\n\n#define camLens 2.\n//fieldOfView\n\n#define camRoll 0.\n//camera lens and roll for camera projection matrix (is not a quaternion camera)\n\n\n//below code can be twiddled, easily breaking more things\n\nv0 viewZoom(v0 t,v1 u,v2 r,v3 m){return 1.;}\n#define viewzoom 1.\n\n/**/ //--- end__ AD-Modifiers\n     //\n/**/ //--- start AD-calculus-Intro\n/*\n\nThis demoes [AutomaticDifferentiation]==[AD]\n-,that automatically calculates the NthDerivative of (m)any function(s)\n- , by implementing:\n- -    chainRule (top level function)\n- -  productRule (arises out of chainRule 2nd derivative)\n- - quotientRule (reciprocal productRule)\n- -    powerRule:\n\nself   AD35 : https://www.shadertoy.com/view/WtfGRS\nparent AD26c: https://www.shadertoy.com/view/WtXGW4\nparent AD34 : https://www.shadertoy.com/view/Wlf3WN\nparent AD26 : https://www.shadertoy.com/view/MsffRs\ngranny AD24 : https://www.shadertoy.com/view/XdXfRl\nuncle       : https://www.shadertoy.com/view/XlV3Dy (goursat)\naunt        : https://www.shadertoy.com/view/MsXBRB (simpler shapes)\ngranddad    : https://www.shadertoy.com/view/4dVGzw (swiveled)\n\ngeneral automatic differentiation is:\n- based on    : https://www.shadertoy.com/view/4dVGzw\n- inspired by : https://www.shadertoy.com/view/Mdl3Ws \n- explained at: http://blog.demofox.org/2014/12/30/dual-numbers-automatic-differentiation/\n- wiki        : https://en.m.wikipedia.org/wiki/Automatic_differentiation\n- summary:    : https://www.reddit.com/r/math/comments/68st6p/the_wikipedia_article_on_automatic/\n\nThe details/axiomes/rules of this are explained in the CommonTab implementation\nYou do not need to know ALL its rules to know how to use it\nBut it helps oif you are good in physics, and know what [Inertia] means/models.\n\nThis likely makes much more sense\n, if you first calculate the (double) integral of your function\n, with something like:    https://www.integral-calculator.com/\n, And then use AD to derive that precalculated integral back to its original, for:\n- precise/analytic [filter] [anti-alasing] (by starting from a DoubleIntegral)\n- https://en.wikipedia.org/wiki/Contour_integration\n-Fluid dynamics, pressure waves (With a buffer over time)\n-EM-fields: https://en.wikipedia.org/wiki/Surface_integral\nSpecific analytic filters are done regularily by InigoQuilez\n, mostly noise with analytic first derivatives:\n-  iquilezles.org/articles/morecheckerfiltering\n-  https://iquilezles.org/articles/filtering\n-  https://iquilezles.org/articles/filterableprocedurals\n-  https://iquilezles.org/articles/gradientnoise\n-  https://iquilezles.org/articles/morenoise\n- - IQ stateless (no LookUpTable/texture/VBO) 2d and 3d noise (with analytic derivatives) \n  - - Value    Noise 2d 1st Derivative:  https://www.shadertoy.com/view/4dXBRH\n  - - Gradient Noise 2d 1st Derivative:  https://www.shadertoy.com/view/XdXBRH\n  - - Value    Noise 3d 1st Derivative:  https://www.shadertoy.com/view/XsXfRH\n  - - Gradient Noise 3d 1st Derivative:  https://www.shadertoy.com/view/4dffRH\n  - - Value    Noise 2d 0th Derivative:  https://www.shadertoy.com/view/lsf3WH\n  - - Value    Noise 3d 0th Derivative:  https://www.shadertoy.com/view/4sfGzS\n  - - Gradient Noise 2d 0th Derivative:  https://www.shadertoy.com/view/XdXGW8\n  - - Gradient Noise 3d 0th Derivative:  https://www.shadertoy.com/view/Xsl3Dl\n  - - Simplex  Noise 2d 0th Derivative:  https://www.shadertoy.com/view/Msf3WH\n- - \nAD allows you to automate this, with up to a 3th derivative, over up to 4 domains.\nYou calculate thedouble Integral of any function, and AD calculates you 3 derivatves for a [filter]\nThis works over up to 4 domains, this is multivariate-calculis, right?\n\nI mean, tthis can solve for optimization problems of a\n  https://en.wikipedia.org/wiki/Partial_derivative\n, right?\n\n[AD]==[Automatic Differentiation] implies the\nhttps://en.wikipedia.org/wiki/Chain_rule\nto cheaply calculate derivatives as byproduct of a set of operands\nwith specific data types\n\n- - All derivatives let you smoothen line-thickness without multi-tapping.\n- - All derivatives let you better esttimate AO or shadows\n\n1st derivative is useful for\n- precise surface normals\n- more precise surface normals. (better normals on corners)\n- some adcanced-spheretracking optimizazions\n2nd derivative is useful for \n- precise surface curvature (better scatter/subsurface\n- some adcanced-spheretracking optimizazions\n2nd derivative is useful for \n- well its 3d equivalent [instant changeRate of curvature] lacks a name...\n- and some adcanced-spheretracking optimizazions\n\nprecision or performance increases more\n- near sharp corners\n- with shapes|functions, that lack C0|C1-continuity but have C1|C2-continuity.\n- - https://en.wikipedia.org/wiki/Smoothness\n\nThe \"art\" here is to define an implicit isosurface\n https://en.wikipedia.org/wiki/Implicit_surface\n https://en.wikipedia.org/wiki/Isosurface\n https://www.youtube.com/watch?v=qb40J4N1fa4\nThat way you get all the Contour lines, gradients, normals...\n https://en.wikipedia.org/wiki/Contour_line\n https://en.wikipedia.org/wiki/Gradient\n https://en.wikipedia.org/wiki/Surface_normal\n...along all the domains (dimensions) of a surface\n https://en.wikipedia.org/wiki/Surface_%28topology%29\n...very cheaply, because the contour is orthogonal to the gradient.\n\nhow about some fast lacplachians:\nhttps://en.wikipedia.org/wiki/Laplace_operator\n\n2nd derivatives (of the ChainRule) have tricky property\nthat it likely adds a product or fraction, which implies a\nhttps://en.wikipedia.org/wiki/Product_rule\nor\nhttps://en.wikipedia.org/wiki/Quotient_rule\nas subroutine\n\nWe commonly differentiate over [t] so any \"dx\" is replaced by \"dt\"\nthis evades confusion beween [t]th derivatives and [.x] as domain space\nwhere displacement over time is most common:\n\ntodo. list [differentials of displacement over time]\n\neg: absement=antiderivative of position over time == distance*time == homesickness\neg: a [long shortDistance relationship] \n   == [short longDistance relationship] in terms of [abserment]\nBUT t may also be a spartial domain\neg: the [antiderivative of position over space] actually makes sense\n\n\n/**/ //--- end__ AD-calculus-Intro\n     //\n/**/ //--- start AD-calculus-Overview\n/*\n\nr=f(a); is the general form of a function f(a), something like:\nv0 f(v0 a){return 3.*a*a*a+2.*a*a-a+7.;}\n;\nAutomaticDifferentiation calculates the derivatives of f(a):\n;\nA [deritative of [f(a)] over [a]]\nis the INSTANTANEOUS [rate of change] of [f(a)] over [a]\nThe lazy approach is to measure different 2 points of f(a)\nand calculate the slope between these points\n- This is how most shaders on shadertoy calculate a surfaceNormal\n- - They commonly measure 2x3 points, 2 points along each of the 3 orrthogonal axes in 3d\n- - - That is not the INSTANTANEOUS [rate of change], but more like a lowPrecisionAverage [rate of change]\nA [deritative of [f(a)] is the limit of this slope-angle when length(slope) approaches 0.\n;\nA [derivative of a [    derivative]] is a [2nd derivative], aka [gradient]\nA [derivative of a [2nd derivative]] is a [3nd derivative]\n;\nexmaple speed_velocity:\nA function, that returns the position of something for any time-input\n, returns a [pos=position(time) over [time]]:\nv0 position(v0 t){return 3.*a*a*a+2.*a*a-a+7.;}//input time returns position\n;\nThe derivative of the position() function returns the speed(time) (or velocity in more than 1d)\nv0 speed(v0 t){return  9.*a*a+4.*a-1.;}//input time returns speed\n;\nThe derivative of the speed() function returns the Accelleration(time)\nv0 speed(v0 t){return 18.*a+4;}//input time returns Accelleration\n;\nThe derivative of the Accelleration() function returns the Jounce(time) (the rate of change of accelleration)\nv0 speed(v0 t){return 18.;}//input time returns Jounce\n\n\"Jounce\" is by far not the strangest derived-SI-unit's properNoun here:\n\n/**/ //--- end__ AD-calculus-Overview\n     //\n/**/ //--- start AD-common-derived-[SIunit]s, sorted by derivatives.\n/*\n\nWhen we derive over something, we derive over (compositions of)\nhttps://en.wikipedia.org/wiki/International_System_of_Units\nhttps://en.wikipedia.org/wiki/SI_derived_unit\n\nIt helps to define common properNouns\n, to talk about concepts/predictions and correlations\nI shortened some terms (to single-glyph-length), for better monospaced-text\nUppercase labels [T,L,M,I,K,N,J] are nameOfDomain\nLowercase labels [s,m,g,a,e,o,c] are nameOfInitial\nSorted, by how commonly we derive ofer these units:\n-       time()SIunit==[T]==[s]Second\n-     length()SIunit==[L]==[m]Meter\n-       mass()SIunit==[M]==[g](kilo)Gramm  //aka [linear inertia]\n-    current()SIunit==[I]==[a]Ampere\n-temperature()SIunit==[K]==[e]kElvin       //[K] may also be [capitalized \"omega\"]\n-     amount()SIunit==[N]==[o]mOle\n-luminousity()SIunit==[J]==[c]Candela\n\nhttps://en.wikipedia.org/wiki/Metrology#Legal_metrology\n\n/**/ //--- start AD-common-derived-[SIunit]s, sorted by derivatives\n     //\n/**/ //--- start AD-common-derivatives over time,dT,T^(n-1)\n/*\nSome labels are only scalar, or only linear, or only angular\nThe lists below do not care much about that, for now it is a hot mess\n, and it is up to you to properly calculate in carthesian or polar space.\n\nSometimes some notations/labels are more intuitive than others\nFor a simple start, we assert that \n- Time is scalar and measured in seconds=[s]\n- Time has only one dimension (at least true for past experiences)\n- - Otherwise causality is an [arbitiary field] and math of that gets a bit too [statistic]al\n;\nfor simpler syntax, we first to derive over [s] and label [Nth derivatives over s] as:\n[0th derivative of f(s)]= s =f(s)         =f   (s)=f0(s)=a.a=b.a=c.a\n[1th derivative of f(s)]=ds =f(s)*ds      =f'  (s)=f1(s)=a.b=b.b=c.b\n[2th derivative of f(s)]=dsÂ²=f(s)*ds*ds   =f'' (s)=f2(s)=a.c=b.c=c.c\n[3th derivative of f(s)]=dsÂ³=f(s)*ds*ds*ds=f'''(s)=f3(s)=a.d=b.d=c.d\nThe above may seem trivial, but this gets messy VERY fast\nto a point where you MUST know \n- how many derivatives a struct/function calculates\n- what derivative of what else you are currently looking at\n- what that value means in context to a unit of measure\n- what domain you derive over\n\nutility:\nwhile(we only derive over time|s (or over ONE space-domain) (up to 3 times)\n){//we can differentiate any TERM below (into an up to 3lines-Lower-TERM)\n ;//and then a higher-TERM can be used to [filter] a lower-TERM\n ;//  https://www.shadertoy.com/results?query=filter\n ;//this is done (without AD or calculus) in many shaders about motionBlur\n ;//  https://www.shadertoy.com/results?query=blur\n;}\n;\nITIT*==[double integral   over time   of[*]]\n  IT*==       [integral   over time   of[*]]\n  DT*==       [derivative over time   of[*]]\n  DL*==       [derivative over length of[*]]\n  RE*==                   [reciprocal of[*]]\n\n--- position|displacement-integrals (over time|s) are:  \n\nITITtime =1.*s*s*s //[double integral over time of [time]]\n  ITtime =1.*s*s   //       [integral over time of [time]]\n    time =1.*s     //                              [time]\n     unit=1.       //     [derivative over time of [time]]\nfrequency=1./s     //     [derivative over time of [unit]]            aka[becquerel] aka [[fluxion]==initially proposed term for [dt]]\n    phase=1./s/s   //     [derivative over time of [frequency]] ==IADMtesla aka[frequencyDrift] https://en.wikipedia.org/wiki/Instantaneous_phase\n  DTphase=1./s/s/s //     [derivative over time of [phase]]\n;\nsee: (Janzen et al. 2014) and:\nhttp://www.thespectrumofriemannium.com/2012/11/10/log053-derivatives-of-position/\n;\n(wave)length ==1.*m      //beware: [relativistic length-contraction]\n      Speed  ==1.*m/s    //beware: the [speed of information]==[speed of light]==min(AnySpeed,[speed of light]) \n;\nhttps://en.wikipedia.org/wiki/Velocity#Distinction_between_speed_and_velocity\n;\nlength|speed are implicitly scalar,single-dimensional; length(a)=sqrt(dot(a,a)) projections onto a single domain.\nbelow are implicitly defined as VECTORS, with more than 1domain (of space)\nlength-vector == Displacement|position\n speed-vector == Velocity\n- They include a relative direction; length()*(angles|UnitQuaternion)\n- They include all angular reference points\n- ,as a polar transformation implies 2 dimensions.\n- - linear/carthesian vectors are identified by starting with [ 1.*] or [ 1./]\n- - polar /complex    vectors are identified by starting with [rad*] or [rad/]\n- - - This often does NOT care wether you are in carthesian or polar coordinates (sometimes the labels are just mixed up)\n- - - sorry, this first version of the list likely mixes terms that are not to be mixed into the same context/bucket.\n- This is quite a messy collection of many nouns, some contexts are lost, some identities are typos.\n- They include all issues of periodic/circular displacement\n- ,where you can do a lot of work, and can end up exactly where you started, plus some entropy\n- - https://en.wikipedia.org/wiki/Directional_derivative#Normal_derivative\n;\n      âfarnessâ=1.*m*s*s*s*s*s*s*s*s*s*s*s*s\n         absput=1.*m*s*s*s*s*s*s*s*s*s*s*s\n         abshot=1.*m*s*s*s*s*s*s*s*s*s*s\n         absrop=1.*m*s*s*s*s*s*s*s*s*s\n         absock=1.*m*s*s*s*s*s*s*s*s\n          absop=1.*m*s*s*s*s*s*s*s\n      absrackle=1.*m*s*s*s*s*s*s\n       absounce=1.*m*s*s*s*s*s\n         abserk=1.*m*s*s*s*s\n   abseleration=1.*m*s*s*s\n         absity=1.*m*s*s \n       absement=1.*m*s        = [maintenance cost] of [long distance communication]\n   displacement=1.*m           //beware: [relativistic length-contraction]\n       velocity=1.*m/s\n  accelleration=1.*m/s/s\n           snap=1.*m/s/s/s        aka[jounce]\n        crackle=1.*m/s/s/s/s\n            pop=1.*m/s/s/s/s/s \n           lock=1.*m/s/s/s/s/s/s\n           drop=1.*m/s/s/s/s/s/s/s \n           shot=1.*m/s/s/s/s/s/s/s/s\n            put=1.*m/s/s/s/s/s/s/s/s/s\n    âswiftnessâ=1.*m/s/s/s/s/s/s/s/s/s/s\n;\n[Reciprocals of position/displacement] and their time integrals.\n- Integrals of reciprocal displacement over time measure ânearnessâ.\n;\n     ânearnessâ=1./m*s*s*s*s*s*s*s*s*s*s*s*s\n        presput=1./m*s*s*s*s*s*s*s*s*s*s*s\n        preshot=1./m*s*s*s*s*s*s*s*s*s*s\n        presrop=1./m*s*s*s*s*s*s*s*s*s\n        presock=1./m*s*s*s*s*s*s*s*s\n         presop=1./m*s*s*s*s*s*s*s\n      presackle=1./m*s*s*s*s*s*s\n      presounce=1./m*s*s*s*s*s\n        preserk=1./m*s*s*s*s\n  preseleration=1./m*s*s*s\n        presity=1./m*s*s\n      presement=1./m*s\n      placement=1./m             ==REdisplacement\n     REvelocity=1./m/s         [velocity reciprocal]\nREaccelleration=1./m/s/s\n         REsnap=1./m/s/s/s \n;\n              ?=1.*g*m*s*s*s*s\n  spectralPower=1.*g*m*s*s*s\n              ?=1.*g*m*s*s \n              ?=1.*g*m*s\n              ?=1.*g*m\n        impulse=1.*g*m/s          aka[momentum]\n          force=1.*g*m/s/s        aka [weight,Newton,torque,action|actergy]\n           yank=1.*g*m/s/s/s      aka [Joule,NewtonMetre,linear work]\n            tug=1.*g*m/s/s/s/s    aka [linear power]\n         snatch=1.*g*m/s/s/s/s/s\n          shake=1.*g*m/s/s/s/s/s/s\n    âforcenessâ=1.*g*m/s/s/s/s/s/s/s\n;\nabove are \"real vectors\" of below \"pseudo vectors\"\nThe difference between [linear] and [angular] vector(derivative)s is a [coreolis effect]\n- commonly experienced as wind/twister/hurricanes/tensor\nrad=radians, where acos(-1.)*2.==1 full rotation indicate PolarCoordinates via c2p() transformation\nbeware, a [spinor] has a period of 2 full rotations\nbeware, below lists mix lot of things together, disregards coordinateSystem, as long as they have the same SI-derivative\n, which quite often may have some typos or OutOfContext errors.\n, you can just pretend that a straight vector is just a VERY large radius with a tiny angle.\nbeware, I confuse [nouns] for [nouns of quanitities], because i really do not care for now\n;\n    angularDisplacement=rad\n        angularVelocity=rad/s     [radial velocity],  [angular speed] is WRONG, because speed is only 1d!\n    angularAcceleration=rad/s/s\n            angularJerk=rad/s/s/s\n;\n                   area= 1.*m*m\nspecificAngularMomentum= 1.*m*m/s     [diffusionCoefficient, specific energy,KinematicViscosity,Diffusivity]\n                   gray= 1.*m*m/s/s   aka [sievert]\n       absorbedDoseRate= 1.*m*m/s/s/s  \n;\n                   mass= 1.*g\n           massFlowRate= 1.*g/s\n         surfaceTension= 1.*g/s/s    aka [stiffness ,radiantExposure]\n               radiance= 1.*g/s/s/s  aka [irradiance, energyflux density,heat flux density]\n;\n         angularRotatum=rad*g*m*s*s*s    aka [spectralPower, spectral intensity]\n                Inertia=rad*g*m*m*s      \n        MomentOfInertia=rad*g*m*m        [action] https://en.wikipedia.org/wiki/Moment_of_inertia\n                   spin=rad*g*m*m/s      [diffusionCoefficient, specific energy,KinematicViscosity,Diffusivity]\n          angularEnergy=rad*g*m*m/s/s    [joule, work, heat, specific energy, spinConnection]  https://en.wikipedia.org/wiki/Spin_connection\n           angularPower=rad*g*m*m/s/s/s  [watt] [radiant  intensity]\n;\nangularMomentum|Impulse=rad*g*m/s \n      linearMassDensity=rad*g/m \n       dynamicViscosity=rad*g/m/s\n          energyDensity=rad*g/m/s/s     [pascal] ???\n           powerDensity=rad*g/m/s/s/s    aka: [spectral irradiance]\n;\n                coulomb= 1.*a*s\n                 charge= 1.*a\n                current= 1.*a/s\n;\n                  weber= 1./a*g*m*m/s/s\n                   volt= 1./a*g*m*m/s/s/s\n;\n                  henry= 1./a/a*g*m*m/s/s\n                    ohm= 1./a/a*g*m*m/s/s/s\n;\n                  farad= 1./g*a*a/m/m*s*s*s*s\n                siemens= 1./g*a*a/m/m*s*s*s\n;\n        compressibility= 1./g*m*s*s\n      DTcompressibility= 1./g*m*s\n;\n     ITspectralRadiance= 1.*g/m/s/s\n       spectralRadiance= 1.*g/m/s/s/s\n;\n                    mol= 1.*o\n                  katal= 1.*o/s\n;\n            molarVolume= 1./o*m*m*m\n    catalyticEfficiency= 1./o*m*m*m/s\n;\n                 volume= 1.*m*m*m\n     VolumetricFlowRate= 1.*m*m*m/s     //Rate of change of volume with respect to time \t\n\n\n/**/ //--- end__ AD-common-derivatives over time,dT,T^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over space|length,dL,L^(n-1)\n/*\n            ITArea= 1.*s*m*m\n          absement= 1.*s*m\n              time= 1.*s\n            DLtime= 1.*s/m  [reciprocal of velocity]\n;\nvolumetricFlowRate= 1./s*m*m*m\n         viscosity= 1./s*m*m   [diffusionCoefficient,specific energy,KinematicViscosity,Diffusivity,specific angular momentum]\n;\n  absorbedRoseRate= 1./s/s/s*m*m\nDLabsorbedRoseRate= 1./s/s/s*m\n;\n              gray= 1./s/s*m*m  =ILILphase  aka[sievert] \n            DLgray= 1./s/s*m    =  ILphase\n             phase= 1./s/s      =DLDLgray\n;\n                 ?= 1.*m*m*m*m*m\n       hyperVolume= 1.*m*m*m*m\n            volume= 1.*m*m*m\n              area= 1.*m*m\n      displacement= 1.*m    (displacement or SCALAR length)\n              unit= 1.\n         placement= 1./m    aka [curvature,wavenumber,opticalPower,spatialFrequency]\n            REarea= 1./m/m      //copied from stranger online places\n          REvolume= 1./m/m/m\n;\n   momentOfInertia= 1.*g*m*m \n                 ?= 1.*g*m\n              mass= 1.*g\n linearMassDensity= 1.*g/m\n;\n            ITArea= 1.*s*m*m\n          absement= 1.*s*m\n              time= 1.*s\n            DLtime= 1.*s/m  [reciprocal of velocity]\n;\n    angularRotatum= 1.*g/s/s/s*m\n   weber, radiance= 1.*g/s/s/s      aka[energy|heat flux density, irradiance,]\n  spectralRadiance= 1.*g/s/s/s/m    aka[spectral power]\n   radiantUntertua= 1.*g/s/s/s/m/m\n;\n              spin=rad*g/s*m*m [angular torque  |moment] [energy density] [action]\n   angularMomentum=rad*g/s*m   [angular Impulse]\n      massFlowRate=rad*g/s\n  dynamicViscosity=rad*g/s/m\n;\n     angularEnergy=rad*g/s/s*m*m   aka [specific energy] [spinConnection]  https://en.wikipedia.org/wiki/Spin_connection\n                 ?=rad*g/s/s*m\n    SurfaceTension=rad*g/s/s       aka [spring constant, stiffness]\n;\n             joule= 1.*g/s/s*m*m\n           DLjoule= 1.*g/s/s*m\n   radiantExposure= 1.*g/s/s\n;\n       AreaDensity= 1.*g/m/m\n       Massdensity= 1.*g/m/m/m \n\n   MomentOfInertia= 1.*g*s*m*m\n DLMomentOfInertia= 1.*g*s*m\n\n    specificVolume= 1./g*m*m*m\n      specificArea= 1./g*m*m\n    DLspecificArea= 1./g*m\n\n   compressibility= 1./g*s*s*m\n DLcompressibility= 1./g*s*s\n\n    ILpowerDensity= 1.*g/s/s/s\n      powerDensity= 1.*g/s/s/s/m   aka: [spectral irradiance]\n;\n           ILILlux= steradian*cd\n             ILlux= steradian*cd/m\n               lux= steradian*cd/m/m\n\n\nfor relativistic stuff, use:\nhttps://en.wikipedia.org/wiki/Four-velocity\n\n\n\n/**/ //--- end__ AD-common-derivatives over space|length,dL,L^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over mass,dM,M^(n-1)\n/*\n                 IMmass= 1.*g*g\n                   mass= 1.*g\n                   unit= 1.\n                 REmass= 1./g\n;\n               radiance= 1./s/s/s*g  aka[irradiance,weber,energy|heat flux density]\n                DTphase= 1./s/s/s    [derivative over time of [phase]]\n;\n         SurfaceTension= 1./s/s*g     aka [stiffness ,radiant exposure]==[integral of [tesla] over Ampere]\n                  Phase= 1./s/s       ==IADMtesla\n;\n           massFlowRate= 1./s*g\n              frequency= 1./s\n;\n                      ?= 1.*m*g\n           displacement= 1.*m\n;\n        momentOfInertia= 1.*m*m*g\n                   area= 1.*m*m\n;\n                 volume= 1.*m*m*m\n         specificvolume= 1.*m*m*m/g\n;\n                impulse= 1.*m/s*g       aka[momentum,dynamicViscosity]\n               velocity= 1.*m/s\n;\n                  force= 1.*m/s/s*g        aka [Newton,weight,action,actergy,torque]\n          accelleration= 1.*m/s/s\n;\n                   yank= 1.*m/s/s/s*g\n                   snap= 1.*m/s/s/s       aka[Jounce]\n;\n                    tug= 1.*m/s/s/s/s*g    aka [linear power]\n                crackle= 1.*m/s/s/s/s\n;\n                   spin= 1.*m*m/s*g      [diffusionCoefficient, specific energy,KinematicViscosity,Diffusivity]\nspecificAngularMomentum= 1.*m*m/s\n;\n          angularEnergy= 1.*m*m/s/s*g    [joule, work, heat, specific energy, spinConnection]  https://en.wikipedia.org/wiki/Spin_connection\n                   gray= 1.*m*m/s/s      [sievert]\n;\n                   watt= 1.*m*m/s/s/s*g   [angular power] [radiant  intensity]\n       absorbedDoseRate= 1.*m*m/s/s/s\n;\n                 absity= 1.*m*s*s \n        compressibility= 1.*m*s*s/g\n;\n           spectralPower=1.*m*s*s*s*g\n            abseleration=1.*m*s*s*s\n;\n                Inertia= 1.*m*m*s*g      https://en.wikipedia.org/wiki/Moment_of_inertia\n                 ITarea= 1.*m*m*s\n;\n      linearMassDensity= 1./m*g\n              placement= 1./m\n;\n       dynamicViscosity= 1./m/s*g\n             REvelocity= 1./m/s         [reciprocal of velocity]\n;\n          energyDensity= 1./m/s/s*g     [pascal] ???\n        REaccelleration= 1./m/s/s\n;\n           powerDensity= 1./m/s/s/s*g   aka: [spectral(Ir)Radiance|power|intensity,angularRotatum]\n                 REsnap= 1./m/s/s/s\n;\n        radiantUntertua= 1./m/m/s/s/s*g\n      DMradiantUntertua= 1./m/m/s/s/s*\n;\n            areaDensity= 1./m/m*g\n          REarea       = 1./m/m\n;\n            massDensity= 1./m/m/m*g\n               REvolume= 1./m/m/m\n;\n                   mole= 1.*o\n               molality= 1.*o/g  [==molarMassRec]\n;\n                 REmole= 1./o\n              molarMass= 1./o*g  [==molalityRec] \n;\n    molarHeatCapacityIN= 1./e*m*m/s/s*g   aka[molar entropy]\n  DMmolarHeatCapacityIN= 1./e*m*m/s/s\n\n\n\n\n/**/ //--- end__ AD-common-derivatives over mass,dM,M^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over ampere,dA,A^(n-1)\n/*\n\n          watt= 1.*g*m*m/s/s/s\n          volt= 1.*g*m*m/s/s/s/a\n           ohm= 1.*g*m*m/s/s/s/a/a\n;\n angularEnergy= 1.*g/s/s*m*m\n         weber= 1.*g/s/s*m*m/a\n         henry= 1.*g/s/s*m*m/a/a\n;\n     coulombIA= 1.*s*a*a\n       coulomb= 1.*s*a\n          Time= 1.*s\n;\n         farad= 1./g/m/m*s*s*s*s*a*a\n       DAfarad= 1./g/m/m*s*s*s*s*a\n     DADAfarad= 1./g/m/m*s*s*s*s\n;\n       siemens= 1./g/m/m*s*s*s*a*a\n     DAsiemens= 1./g/m/m*s*s*s*a\n;\n      TeslaRec= 1./g*s*s*a   //                [reciprocal of [tesla]]\n       PhaseDM= 1./g*s*s     // [derivative of [reciprocal of [tesla]] over mass] == PhaseDM == [derivative of [Phase] over mass]\n;\nSurfaceTension= 1.*g/s/s       aka [stiffness ,radiantExposure]==[integral of [tesla] over Ampere]\n         tesla= 1.*g/s/s/a\n       DAtesla= 1.*g/s/s/a/a\n\n\n/**/ //--- end__ AD-common-derivatives over space|length,dA,A^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over mole,dN,N^(n-1)\n/*\n\nall terms that I find with an [o] for mOle in it, are in this section\neven if the derivative chains of it are short\nIn that case i derive my orn term with *D* or *I*\n\nmole              =1.*o\n;\n     Mass         =1.*g\nmolarMass         =1.*g/o  [molalityRec]\n;\nmolality          =1.*o/g  [molarMassRec]\n;\nmolarity          =1./m/m/m*o\nmolarityDN        =1./m/m/m      //its odd that we have no proper noun for this\n;\nangularEnergyIN    =1.*g*m*m/s/s*o\nangularEnergy      =1.*g*m*m/s/s\n  molarEnergy      =1.*g*m*m/s/s/o\n;\nmolarHeatCapacityIN=g/e*m*m/s/s\nmolarHeatCapacity  =g/e*m*m/s/s/o   aka[molar entropy]\n;\nINmolarConductivity=a*a/g*s*s*s\n  molarConductivity=a*a/g*s*s*s/o\n\n\n/**/ //--- end__ AD-common-derivatives over space|length,dN,N^(n-1)\n     //\n/**/ //--- start AD-demo\n/*\n\nAD converts ALL operands into their prefix-notation\nto be more monadic (output type of same functionName depends on input type)\nand most common functions are crunched into 2-glyph-initials:\nc=   a+   b*pow(c,d) \n      ==\nc=ad(a,mu(b,po(c,d)))\n      ==\nc=po(c,d);c=mu(c,b);c=ad(c,a)\n\ngoodbye to the infix_notation with [+*-/%^] operands\nand replace it with a proper prefix_notation, like writing in Lisp.:\nhttps://en.wikipedia.org/wiki/Polish_notation\n\n//and then it gets more and more tricky: \n// Chain rule Derivative of dot() appears tricky: this should work, untested:\nd2 dotd(c2 a, c2 b){d2 t0=mu(a.x,b.x),t1=mu(a.y,b.y),t2=mu(a.z,b.z); \n return ad(ad(t0,t1),t2);}\n\n/**/\n\n//using the above, we define distance functions \n//...that automatically also return the gradient at [p].\n//the gradient is multiple first derivatives along multiple domains\n//... like Dfdx() and Dfdy(), and we also have Dfdz()...\n//... except much cheaper, due to many things canceling out each other.\n//This makes surfaces that are C0-discontinuous, like y=fract(x), \n//...at least have their first derivate calculated continuously,\n//... as long as they are C1-continuous,\n//which can be useful for raymarching:\n             \n//A more readable version of a very parametric implicit surface.\n//...that does not look as much like LISP code, but at its core is just like that.\n//One operation per line keeps it BASIC and modifiable.\nd2 sdSuperPrim(c2 p, v3 s,v1 r\n){//v1 r=v1(.2,.5);\n  //v3 s=v3(1.5,.5,1.5,.5);\n  //v3 dx,dy,dz,d,e,f,q,a,b,c;\n  //dy=v3(0);dz=v3(0);d=v3(0);\n  //e=v3(0);f=v3(0);q=v3(0);\n  //a=v3(0);b=v3(0);c=v3(0);\n ;d2 dx=suab(p.x,s.x)\n ;d2 dy=suab(p.y,s.y)\n ;d2 dz=suab(p.z,s.z)\n ;d2 d=ad(dx,r.x);d=ma(d,0.)\n ;d2 e=ad(dy,r.x);e=ma(e,0.)\n ;d2 q=sd(d,e)\n ;d2 f=ma(dx,dy);f=mi(-r.x,f)\n ;q=ad(q,f)\n ;q=ad(q,s.w)\n ;q=ab(q)\n ;q=su(q,s.w)\n ;///return...\n ;d2 a=ad(q ,r.y);a=ma(a,0.)\n ;d2 b=ad(dz,r.y);b=ma(b,0.);a=sd(a,b)\n ;d2 c=mi(-r.y,ma(q,dz));c=ad(a,c)\n ;return c;}\n\n//getfactor() cycles trough example input parameters for sdSuperprim() \n#define SHAPE_COUNT 10.0\nvoid getfactor (int i,out v3 s,out v1 r\n){     if(i==0){s=v3(1)           ;r=v1(0)     ;//cube\n }else if(i==1){s=v3(v2(1),.25) ;r=v1(0)     ;//corridor\n }else if(i==2){s=v3(v2(1),.25) ;r=v1(1)     ;//pipe\n }else if(i==3){s=v3(1)           ;r=v1(1,0)   ;//cylinder\n }else if(i==4){s=v3(1,1,2,1)     ;r=v1(1)     ;//pill\n }else if(i==5){s=v3(1)           ;r=v1(1)     ;//sphere\n }else if(i==6){s=v3(1,1,.25,1)   ;r=v1(1,.25) ;//pellet\n }else if(i==7){s=v3(1,1,.25,.25) ;r=v1(1,.25) ;//torus\n }else if(i==8){s=v3(2,.5,.25,.25);r=v1(.5,.25);//sausage mouth\n }else if(i==9){s=v3(.7,1,1,.25)  ;r=v1(.125)  ;//beveled O\n}}//  https://www.shadertoy.com/results?query=superprim\n                                            \n //demo playground for boolean unions of implicit surfaces.\nd2 aBool(c2 p\n){\n //p.x.a=point.x\n //p.y.a=point.y\n //p.z.a=point.z\n //p.w.a=point.w\n //p.x.a=1\n //p.y.b=1\n //p.z.c=1\n //p.w.d=1\n //all other.b are ==0\n ;d2 box=fBoxCheap(p,v2(1))\n ;//p=su(p,v2(-1,1,1))//p.x=addd(p.x,1.);p.y=subd(p.y,1.);p.z=subd(p.z,1.);\n ;d2 box2=fBox(p,v2(1))\n ;//return mind(box,box2);//(box or     box2)\n ;//return maxd(box,box2);//(box and     box2)\n ;//return maxd(box,-box2);//(box and not box2)\n ;//return fOpUnionRound(box,box2,1.)\n ;//return fOpIntersectionRound(box,box2,.3)\n ;//return fOpDifferenceRound(box,box2,.5)\n ;return box\n ;}\n \n\n\n#define ss01(a) smoothstep(0.,1.,a) \n#define imsc(a) int(mo(a,SHAPE_COUNT))\n\nstruct DAMValue{d2 d;v0 m;};//to paint the gradient on a plane.\nDAMValue min2(DAMValue a, DAMValue b){if(a.d.a>b.d.a)return b;return a;}\nDAMValue plane(c2 p){return DAMValue(ad(p.y,1.),1.);}\n//DAMValue add_plane(DAv2 p,DAMValue m){return min2(plane(p),m);}\n//return distance to surface of DistanceField\n\n\n\nDAMValue df(c2 p\n){d2 D\n ;v0 t=iTime//u=ss01(ss01(fract(t)))\n ;v2 r=iResolution.xyz\n ;v3 m=iMouse.xyzw\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount,0.)+.5)/iResolution.xy).y  \n //p.x.a=point.x\n //p.y.a=point.y\n //p.z.a=point.z\n //p.w.a=point.w\n //p.x.a=1\n //p.y.b=1\n //p.z.c=1\n //p.w.d=1\n //all other.b are ==0\n #ifndef SuperPrim\n //simpler more static parametric surfaces\n ;//m.x=cos(iTime)*r.x\n     \n ;//if(pointCount>9.){m.xy=(fra(t,bufDrag(+9.).xy,r,m)*viewzoom*2.+1.)*r.xy;} \n ;D=sdGoursat(p,r,m)\n     //aBool(p)\n ;//r=fSphere(p)\n ;//r=fBox(p,v2(1))\n ;//r=fBoxCheap(p,v2(1))\n ;//v0 holesize=mix(.6,5.,sin(iTime*3.)*.5+.5)\n ;//d2 s=fSphere(mu(p,v2(holesize)))\n ;//r=ma(r,ne(s))//nope way too bad lipschitz, got to fix this shit!\n //scaling by holesize is bad for lipschitz constant.\n #else\n //superprim() is a very parametric implicit surface.\n ;v3 a,b,c,d;v1 e,f,g,h\n ;getfactor(imsc(t   ),a,e);getfactor(imsc(t+1.),b,f)//params for superprim0\n ;getfactor(imsc(t+2.),c,g);getfactor(imsc(t+3.),d,h)//params for superprim1\n ;v0 v=ss01(fract(t))\n ;a=mix(a,b,v);e=mix(e,f,v)//params for superprim0\n ;c=mix(c,d,v);g=mix(g,h,v)//params for superprim1\n //above getfacvtor sets v3 a,b and v1 c,d into a cyclic mix\n //below overwrites these parameters with iUI data  \n//#define bufDrag(x) texture(iDiegeticUI,(v1(x,0.)+.5)/iResolution.xy)\n  \n ;v1 sdUberprimZ=v1(cos(iTime)*.5)\n //UIdots overwrite superprim params             \n ;if(pointCount>1.){a.xy=(fra(t,bufDrag(+1.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>2.){a.zw=(fra(t,bufDrag(+2.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>3.){e.xy=(fra(t,bufDrag(+3.).xy,r,m)*viewzoom*2.+1.);} \n  //above is 6 params for superprim0, below is 6 params for superprim1\n ;if(pointCount>4.){c.xy=(fra(t,bufDrag(+4.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>5.){c.zw=(fra(t,bufDrag(+5.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>6.){g.xy=(fra(t,bufDrag(+6.).xy,r,m)*viewzoom*2.+1.);}\n                    //below are 2 more params for offset and CSGunion\n ;v3 o=v3(1,2,1,.3)//offset of one of the shapes  and .z uis Union-parameter\n ;if(pointCount>7.){o.xy=(fra(t,bufDrag(+7.).xy,r,m)*viewzoom*2.+1.);}\n ;if(pointCount>8.){v1 O=(fra(t,bufDrag(+8.).xy,r,m)*viewzoom*2.+1.)\n     ;o.zw=O.xy;}\n ;if(pointCount>10.){sdUberprimZ=(fra(t,bufDrag(+10.).xy,r,m)*viewzoom*2.+1.);}\n\n ;//debug corner cases\n  /* ;a.x=1. ;a.y=1. ;a.z=1.*/\n    \n ;//struct for AD, 2 points to 2 shapes.\n ;c2 q=c2(   su(p.y,0.)     ,   p.z     ,   p.x     )\n ;c2 Q=c2(su(p.x,o.y),su(p.y,o.z),su(p.z,o.x))//offset and swivel\n  \n     \n  \n  // a,c: (width, height, depth, thickness)\n  // e,g: (xy corner radius, z corner radius, bottom radius offset (sdUberprim Only))\n ;D     =sdSuperPrim(q,a,e)//superprim0 \n\n ;\n ;d2 box=sdUberprim(Q,c,v2(g,sdUberprimZ.x))\n ;//d2 box=sdSuperPrim(Q,c,g)//superprim1\n ;//box=su(box,o.w)//use o.w to offset shape thickness.\n     \n     //fBoxCheap(su(p,v2(-1.,1,-.5)),v2(.61))\n ;//p=su(p,v2(-1,1,1))//p.x=addd(p.x,1.);p.y=subd(p.y,1.);p.z=subd(p.z,1.);\n ;//D=box2=fBox(p,v2(1))\n ;//D=mind(box,box2);//(box or     box2)\n ;//D=maxd(box,box2);//(box and     box2)\n ;//D=maxd(box,-box2);//(box and not box2)\n ;D=fOpUnionRound(D,box,o.w*3.)\n ;//D=fOpIntersectionRound(box,box2,o.w)\n ;//D=fOpDifferenceRound(box,box2,o.w)\n ;//D=box   \n ;//v0 holesize=mix(2.5,.97,sin(iTime*3.)*.5+.5)//damn i made reciprocal hole size\n ;//d2 s=di(((fSphere(mu(mi(p,v2(.5,.61,-.4)),v2(holesize))))),holesize)\n ;//D=ma(D,ne(s))  //hole(unionround())==bad lipschitz!\n \n     \n  ;if(pointCount>9.){m.xy=(fra(t,bufDrag(+9.).xy,r,m)*viewzoom*2.+1.)\n                    ;m.x=1.-m.x\n                    ;v0 scaleT=1./.5\n                    ;v2 o=v2(sdUberprimZ.y+1.,0,-3)/scaleT\n                    ;p=su(p,o) //yep. the offset must be scaled,too\n                    ;c2 q=c2(   p.y ,   p.z  ,  p.x  )\n                        \n                    ;//q=ad(q,v2(sdUberprimZ.y))\n                  \n                    ;q=mu(p,scaleT)\n  \n                    ;d2 G=sdGoursat(q,m)\n                    ;G.a*=scaleT\n                    ;D=fOpUnionRound(D,G,m.y)\n                     ;}\n /**/     \n #endif\n ;//return DAMValue(r,0.);\n ;return min2(plane(p),DAMValue(D,0.));}\n\n\n\n\n\n\n//return distance & materialID\nv1 dm(v2 p){DAMValue d=df(da_domain1(p));return v1(d.d.a,d.m);}\n//return material at p with normal n\nv3 material(v2 p,v2 n ){d2 d=df(da_domain1(v2(p.x,0.,p.z))).d\n ;return mix(v3(n*.5+.5,.1)\n            ,v3(d.b*.5 +.5,.0)*abs(mod(d.a,.1)/.1-.5)\n            ,sat(dm(p).y));} \n\n//return soft shadow of light source at [o], \n//... with light direction [i] pointing from [o] to surface point [p]\nv0 shadow(v2 o,v2 i\n){const v0 a=32.//shadow hardnes\n ;v0 r=1.,h =1.,t=.0005//t=(self)intersection avoidance distance\n ;const v0 it=clamp(IterSh,0.,64.)\n ;for(v0 j=0.;j<it;j++\n ){h=dm(o+i*t).x\n  ;r=min(r,h*a/t)\n  ;t+=clamp(h,.02,2.);}//limit max and min stepping distances\n ;return clamp(r,0.,1.);}\n//iquilezles.org/articles/rmshadows\n\n//return p, modified by light , shadow, envMap...\nv2 light(v2 p,v2 n,v2 i,v0 d,v3 m\n){v2 l=normalize(v2(1.,.7,.9))//light direction\n ;v0 o=max(0.,dot(n,l))\n ,c=max(0.,dot(n,normalize(l-i)))\n ,s;if(c>.01)s=shadow(p+.01*n,l)\n ;const v2 LigCol=v2(1.)//light color\n ;v2 r=m.rgb*(LigCol+o*v2(.8,.7,.6)*s*3.+v2(.2,.3,.3))\n ;r+=s*c*pow(o,40.)//specular\n ;//r+=m.x*texture(iChannel0, reflect(i,n)).rgb;//environment map\n ;r*=exp(-.01*d*d)//fog  \n ;return r;}\n\n//return distance along ray (raymarch till surface)\nv0 rm(v2 o,v2 i\n){const v0 m=20.//distance.Max\n ;v0 e=.0,h=e,t=0.//intersection.precission\n ;const v0 irm=clamp(IterRm,1.,256.)\n ;for(v0 j=0.;j<irm;j++\n ){if(h<e)break;if(t>m)return -1.\n  ;//wait a moment, do i not have the lipschitz for the point\n  ;//or at least 3 for 3 domains of the point, by using [AD]?\n  ;//i mean, i could really insert this here, right?\n  ;//and substitute ReciprocalAbsLipschitz with \"1/da_length(dm(o+i*t).yzw)\"\n  ;//i am pretty sure that i am missing a dotproduct here\n  ;//the gradient must be dorproducted onto the ray direction?\n  ;//above is as old as AD26, late 2017 stuff\n  ;//2019 comment: oh hey, abvoe line almost described [drungFluttershy] marching.\n  ;DAMValue s=df(da_domain1(o+i*t))\n  ;v0 r=ReciprocalAbsLipschitz\n  ;//r=1./length(dot(s.d.yzw,i));//overwriting with a VERY LOCAL lipschitz constant\n  ;//its not a good estimate, but it is a LOT better?\n  ;//nah it totally fails for concave isosurfaces.\n  ;h=s.d.a*r;t+=h;}return t;}\n \n  //return camera matrix\n  mat3 calcLookAtMatrix(in v2 o,in v2 i,in v0 r ){\n   v2 w=normalize(i-o);v2 u=normalize(cross(w,v2(sin(r),cos(r),0.)) );\n   return mat3(u,normalize(cross(u,w)),w);} \n\n//return surface normal\nv2 getDt1(in v2 p){DAMValue d=df(da_domain1(p));return d.d.b;}\n //d.d.d stores the first derivatives on the 3 domains, (is also an awesopme pointer label)\n //this is equivalent to the gradient at p.\n //If (p is near a surface) the gradient is a surface normal\n //d.d.* addresses a v3. where *.yzw==gradient\n //d.m.* addresses a material\n//#elif (domains==1||domains==3)\n //is a lot like \n //  https://www.shadertoy.com/view/XdffzB\n\n//draw ripples on a plane:\nd0 getd(v0 u){return ad(ab(D0(u)),si(D0(u)));}\n//f(x) = abs(x)+sin(x) = add(abs(x),sin(x))\n\n//set camera position & target\n//first rotate around vertical axis bny t\n//then loop up/down by m\nvoid setCam(out v2 o,out v2 i,v0 t,v0 m\n){\n o=v2(4.*sin(t),m*9.-2.,4.*cos(t));i=v2(0);}\n                               \nv3 in3d(v0 t,v1 u,v2 r,v3 m\n){\n ;v1 v=(u   -r.xy*.5)/r.y\n ;v3 n=v3((m.xy-r.xy*.5)/r.y,(m.zw-r.xy*.5)/r.y)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;v1 zo=v1(t,cos(t)*.5+.5)\n ;if(pointCount >0.//this point sets camera parameters (2 angles)\n ){zo=v1(fra(t,bufDrag(0.).xy,r,n))\n  ;zo=v1(-zo.x*acos(-1.)*2.,cos(clamp(zo.y*2.-1.,-1.65,1.)))//bufDrag(+0.).xy\n ;}\n ;u=(-iResolution.xy+2.*u.xy)/iResolution.y\n ;//v1 zo=v1(iMouse.xy/iResolution.xy)  //mouse\n ;v2 o,i,c=v2(0)\n ;setCam(o,i,zo.x,zo.y+.2)//camMovement\n ;v2 d=normalize(calcLookAtMatrix(o,i,camRoll)*v2(u.xy,camLens))//ray.direction\n ;v0 T=rm(o,d)//Distance.raymarched\n ;if(T>-.5\n ){v2 p=o+T*d,n=getDt1(p)//position & normal\n  ;v3 ma=material(p,n)  //material\n  ;c=light(p,n,d,T,ma);}  //light\n ;c=ff_filmic_gamma3(c*.6)//gamma\n ;//c=pow( clamp(col,0.0,1.0), v2(0.4545) )\n ;return v3(c,1.);}                          \n                                    \n//v3 in2d(v1 u){}   got a bit meessy and its 2 \"scenes\"                        \n//seperated into \n// v3 ovalEyes(v1 u,v0 h,v0 g){     //version 026    \n//and\n//linearGraph(v1 u,v0 h,v0 g){      //version 025\n                                    \n                                    \n \n//2d domain space parent: https://www.shadertoy.com/view/XdffzB        \nv3 ovalEyes(v1 u,v0 h,v0 g\n){v1 m=fra(iTime,iMouse.xy,iResolution.xyz,iMouse)\n ;m*=9.\n ;m=abs(m)\n ;m=1./m\n ;//https://www.shadertoy.com/view/MdfGWn    (derivative ellipse approximation)\n ;//... coverted to derivative arithmetic. \n ;//it think it can be more than a approximation, by using more than 1 domain.\n ;//but how?\n ;c1 f=da_domain1(u)\n ;f=mu(f,m)\n ;f.x=sd(f)//so, we completely distegard one of 2 domains here?\n ;//like we project doen to -1 dimension within a torus, 2 times?\n ;//above (and below) line is like u.x=length(u)-1;\n ;//i am pretty sure, utilizing the other domain will fix a lot of stuff!\n ;f.x=su(f.x,1.)   \n //#define FilledEllipse\n #ifndef FilledEllipse\n  ;f.x=ab(f.x)//makes ellipse ring instead of filled ellipse\n #endif\n ;v0 outlineThickness=iResolution.y*.5\n ;v0 i=length(v1(f.x.b.x,f.x.b.y)*outlineThickness)\n ;//this looks kina nead like \"Fxdx()\", but it is more misleading than anything?\n ;v0 ellipseBorderThickness=(sin(iTime)*.5+.5)*9.;//=0.01\n ;v0 blur=20./max(iResolution.y,1.)\n ;//v0 r=1.-f.x.x\n ;v0 r=ssb2(ellipseBorderThickness,f.x.a*iResolution.y/i)\n ;//v3 yellow =v3(v2(1,1,0),r)\n ;//v3 yellow =v3(v2(1,1,0),ssb(1.-r*iResolution.y/i))\n ;v3 yellow =v3(v2(1,1,0),1.-ssb(r))\n ;v3 cyan   =v3(v2(0,1,1),ssb(g))\n ;//v0 b=0.;//no magenta here//v3 magenta=v3(v2(1,0,1),ssb(b))\n ;return aOverB(yellow,cyan);}\n\n\nv3 linearGraph(v1 u,v0 h,v0 g\n){d0 d=getd(u.x)\n ;//v0 div=sqrt(1.+p.y*p.y)\n ;v0 r=abs(d.a-u.y)/(sqrt(1.+d.b*d.b))-thick\n ;d=getd(u.x)\n ;//no analytical 2nd derivative, so this one sucks a bit\n ;v0 b=abs(d.b-u.y)/(sqrt(1.+d.b*d.b))-thick\n ;//this does not work for scaled p, is far from being user friendly\n ;v0 blur=20./max(iResolution.y,1.)\n ;v3 yellow =v3(v2(1,1,0),ssb(r))\n ;v3 cyan   =v3(v2(0,1,1),ssb(g))\n ;v3 magenta=v3(v2(1,0,1),ssb(b))\n ;return aOverB(aOverB(yellow,magenta),cyan);}\n \n v3 in2d(v0 t,v1 u,v2 r,v3 m\n ){u=fra(t,u,r,m)\n  ;u*=9.\n  ;v1 f=abs(fract(u));//green carthesian grid   \n  v0 h=abs(fract(length(u)+thick)-thick);//green polar circles\n  v0 g=min(min(f.x,f.y),h);\n  return ovalEyes(u,h,g);\n  return linearGraph(u,h,g);\n }\n\n v3 in1d(v1 u){return v3(0);}\n\n                               \n//demoIKBezier is now a dreidelDebugger for iDiegeticUI                        \nv3 demoIkBezier(v0 t,v1 u,v2 r,v3 m//define bezier by start,eng,Arclength\n){v3 c=v3(1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v1 p0=v1(-.4)\n ;v1 l0=v1( .7)\n ;v1 l1=v1(.5,-.5)\n ;//v1 r1=v1(.5,-.1)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){p0=fra(t,bufDrag(+0.).xy,r,m)*viewzoom\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+1.).xy,r,m)*viewzoom\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+2.).xy,r,m)*viewzoom\n ;} \n ;v0 d=segment(p0,l0,l1)*2.     //distance of p3 to line segment\n ;if(length(l0-l1)>d)l1=l0+d*normalize(l1-l0)\n ;c.z=segment(u,l0,l1)//vis blue line segment\n ;v1 p11=knee(l0,l1,d)//red dot is knee \n ;v1 p10=project(p0-l0,l1-l0)+l0\n ;c.x=length(u-p11)-.04\n ;c.x=min(c.x,segment(u,p10,p0))\n ;c.y=BezierQuad(u,l0,p11,l1)\n ;c.x=abs(c.x)-.01 \n ;c.y-=.02\n ;c.z=abs(c.z-.05)-.02\n ;c=mix(ss(c.xyzw,viewzoom/Aa(t,u,r,m)),fract(c.xyzw*9.),.2)\n ;//c.xy+=c.w*.2//fold w as yellow\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,0)*c.w))\n ;return c\n ;}\n                               \nvoid mainImage( out v3 O,in v1 u\n){v0 t=iTime\n ;v2 r=iResolution.xyz\n ;v3 m=iMouse.xyzw\n    \n #if (scene==3)\n ;O=mix(in3d(t,u,r,m),in2d(t,u,r,m),.1)\n #elif (scene==2)\n ;O=in3d(t,u,r,m)\n #elif (scene==1)\n ;O=in2d(t,u,r,m)\n #elif (scene==0)\n ;O=in1d(t,u,r,m)\n #endif \n    \n ;//O=demoIkBezier     (iTime,u,iResolution,iMouse)\n ;}\n\n//my todo_list;\n//todo, find aliases for common operations, and debug them.\n//I suspect that modulo and 2d rotation seem buggy.\n//\n//todo, merge with hg_sdf, full set\n//to have hg_sdf with first derivatives, in 2 or 3 domains.\n//it already poited at my lack of competence to substitute correctly\n//-> lots of small errors.\n//\n//done, looking good enough:\n//\n//fSphere()\n//fRay() (infinite line segment with radius 1)\n//fBox()\n//fBoxCheap()\n//\n//mind() maxd() unions of 2 distance fields (Boolean AND, boolean OR)\n//fOpUnionRound()\n//fOpIntersectionRound()\n//fOpDifferenceRound()\n//\n//I failed at:\n//fOp*Columns\n//fOP*Staircase\n//\n//memo:  https://en.wikipedia.org/wiki/PID_controller\n//- is [[weighted sum of [2 (or more) derivatives]] in a feedback loop]\n//- application is [cruise control] and [music instruments]\n//\n//todo pModd() , will likely hint me at how to fix stuff.\n//\n//todo: include complex plane transformation math of\n//  https://www.shadertoy.com/view/ls2cDt\n//for anything \"Cauchy\"\n//  https://en.wikipedia.org/wiki/Complex_analysis\n//  https://en.wikipedia.org/wiki/Augustin-Louis_Cauchy\n//\n//todo, antialiasing, merger with: https://www.shadertoy.com/view/MdXczr\n//todo: https://en.wikipedia.org/wiki/Quaternionic_analysis\n//todo, curvature stuff, because I want a minimal surface !\n\n\n/**/ //--- start AD-memo todo rant\n/*\n\ntodo, copy   https://www.shadertoy.com/view/MdsBRX\n\nAD26 cleanup 2019-04 is the version where i renamed [length] to [sd]\n\nmemo of a timeless issue:\nfunctions are never (to be) named by the input types (a lesson to learn from noise libraries)\nfunctions are named by output types                  (a lesson to learn from noise libraries)\nproblem of AD is that it is monadic, input types define poutput types:\nv0 si(v0 a)  //must be a thing\nvi si(v0 a)  //must be a thing\nvi si(d0 a)  //must be a thing\n->\nv0 si(d0 a)  //must NEVER be a thing, instead call;  si(D0(a))\n//lets just not do the above\n//and instead imply\nv0 si(D0(a)) \n\nrants:\nExplicit structure \n- adds simplifying symmetry\n- confuses, mostly due to its atomic defines, and counting from 0.\n- creates \"permutation hell\", as usual.\n- does not slow down performance\n\nThis defines implicit 3d Surfaces, or 2d curves, \n... with ChainRule automatic differentiation Arithmetic, \nThis inevitably makes you write in prefixNotation, like Lisp source code.\nsurely this would look much better in Lisp than in Webgl\nStill waiting for the Lisp gpu API, and openCL or CUDA are not my thing!\n... there is \"harlan\" for inspiration, but it is a 2007 non-api thing...\n\n\n/**/ //--- end__ AD-memo todo rant\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nvoid mainImage(out vec4 o, in vec2 u\n){\n ;return;\n ;}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//iTR  TemporalReprohjection\n\n// almost entirely:\n// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// made more compativle by ollj\n// [compatible v4]\n\n//ichan0=wood\n//ichan1=self C (optional for blur instead of celshaded black outlines)\n//ichan3=void\n//ichan3=self C\n//other ichannels may cause silly artefacts (ppixels with 0-vallues seem to create nans, that then make white dots in dark areas)\n\n/*\nmade (more) gles100 compatible\n(i hope i did not forget anything important)\n\n- all lops are complete forLoops\n- all loops have constant max iteration count\n- no ivec*\n- no bitwise operands\n- dualFunctionEd\n- - no texelFetch() \n- - no silly Array stuff \n- - int sign(int a)\n- - int abs(int a)\n- did not add tons of global runtime variables ;)\n- did not add [/*\"] after [#]\n- A lot of code looks 15 years dumber now.\n\n*/\n\n\n#define NUMBOXES 22\n\n//vec4 tf0(vec2 b,vec3 r){return tf(iChannel0,b,r);}\n//vec4 tf1(vec2 b,vec3 r){return tf(iChannel1,b,r);}\n//vec4 tf2(vec2 b,vec3 r){return tf(iChannel2,b,r);}\nvec4 tf3(vec2 b,vec3 r){return tf(iChannel3,b,r);}\n\n//#if 1\n#if VER <300\n//7 are manually placed\nvec3 size7(int i\n){if(i==1)return vec3(10.5,0.1,10.5)\n ;if(i==3)return vec3(10.5,7.5, 0.1)\n ;if(i==5)return vec3(10.5,7.5, 0.1)\n ;if(i==7)return vec3( 0.1,7.5,10.5)\n ;if(i==9)return vec3( 0.1,7.5,10.5)\n ;if(i==11)return vec3( 4.0,0.1,10.5)\n ;return         vec3( 4.0,0.1,10.5);}\nvec3 pos7(int i){\n ;if(i==0)return vec3( 0)\n ;if(i==2)return vec3(  0, 0,-10)\n ;if(i==4)return vec3(  0, 0, 10)\n ;if(i==6)return vec3( 10, 0,  0)\n ;if(i==8)return vec3(-10, 0,  0)\n ;if(i==10)return vec3( -7,-7,  0)\n ;return  vec3(  7,-7,  0);}\nvoid getLocation(int i, out mat4 resMat, out vec3 resSiz\n){if(i<7\n ){resMat = translate( pos7(i*2))\n  ;resSiz = size7(i*2+1)\n ;}else{\n  ;resMat = rotationAxisAngle(vec3(0.3,0.4,0.5)*1.41421, -float(i*13))* translate(vec3(0.0,-2.5,0.0)-vec3(5.0,2.0,5.0)*sin(vec3(i*43,i*23,i*137)));\n  ;resSiz = vec3(1.1,1.6,0.08);}}\n\n#else\n//7 are manually placed\nconst vec3 possiz[14] = vec3[14](\n    vec3(  0, 0,  0), vec3(10.5,0.1,10.5),\n    vec3(  0, 0,-10), vec3(10.5,7.5, 0.1),\n    vec3(  0, 0, 10), vec3(10.5,7.5, 0.1),\n    vec3( 10, 0,  0), vec3( 0.1,7.5,10.5),\n    vec3(-10, 0,  0), vec3( 0.1,7.5,10.5),\n    vec3( -7,-7,  0), vec3( 4.0,0.1,10.5),\n    vec3(  7,-7,  0), vec3( 4.0,0.1,10.5));\nvoid getLocation(int id, out mat4 resMat, out vec3 resSiz\n){if(id<7\n ){resMat = translate( possiz[2*id+0] )\n  ;resSiz = possiz[2*id+1]\n ;}else{\n  ;resMat = rotationAxisAngle(vec3(0.3,0.4,0.5)*1.41421, -float(id*13))* translate(vec3(0.0,-2.5,0.0)-vec3(5.0,2.0,5.0)*sin(vec3(id*43,id*23,id*137)));\n  ;resSiz = vec3(1.1,1.6,0.08);}}\n#endif\n\nfloat fhash1(float n \n){float a=(sqrt(5.)*.5+.5) //golden ratio is sufficient here.\n ;a=n*a\n ;a=abs(a)\n ;return fract(a);}\n\n    \nint ihash1(int n \n){//return 0\n /*\n ;float a=(sqrt(5.)*.5+.5)//golden ratio is NOT good here\n ;a*float(n)*a\n ;return int(fract(a)*pow(2.,22.))\n /**/\n ;float f=float(n)\n ;f =f*pow(2.,13.)// (n << 13) \n //f=f^ n  //not good/compatible/fast, but also really not essential.\n ;n=int(f)\n ;n=n*(n*n* 15731+789221)+1376312589 \n ;n=abs(n)\n ;return n//its a hack, but its close enough to the original.\n /**/\n ;}\n\n//hash2() is completely taken apart, or replaced by a fibonaciSphere\n\n#define cs(a) vec2(cos(a),sin(a))\n#define sr1m(a) sqrt(1.-(a)*(a))\n//return point[k] of a fibonacciSphere with [n] equidistributed points\n//divides by [n] and squares the result, [n] should not be too large, or we lose too much precision\nvec3 fibSphereKthOfNpoints(float k,float n  //0<=k<=n!=0 ;k-bounds are implied geometrically.\n){if(n==0.)n=1.//worksafe\n ;float x=((k*2.+1.)/n)-1.\n ;return vec3(cs(k*pi*(3.-sqrt(5.)))*sr1m(x),x);//poles of HairyBallProblem are along x-axis!\n ;}//https://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere/44164075#44164075\nvec3 uniformVector(int seed\n){const float points=pow(2.,22.)  //[machineEpsilon]=pow(2.,-23)\n ;float f=fhash1(float(seed))\n ;return fibSphereKthOfNpoints(mod(f,points),points);}\n\n//the last remaining hash2() subroutine call is deconstructzed in here:\nvec3 cosineDirection(int seed, in vec3 nor\n){seed=seed*7+11\n ;int n=int(seed)    \n ;float f=float(n)*pow(2.,13.)\n ;//n = int(f)^n //original integer hash used a mask, but thats slow in glES100, and its fine without mask.\n ;n=n*(n*n*15731+789221)+1376312589\n ;int nx=n*n\n ;int ny=n*n*16807\n ;nx=abs(nx)\n ;ny=abs(nx)\n ;vec2 r=vec2(nx,ny)\n  ;r=r/float(0x7fffffff)\n    //;vec2 r = hash2( seed);\n    // by fizzer: http://www.amietia.com/lambertnotangent.html\n    ;float a = 6.2831853 * r.y;\n    float u = 2.0*r.x - 1.0;\n    return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\nfloat iBox(vec3 ro,vec3 rd,mat4 txx,vec3 rad\n){// convert from ray to box space\n ;vec3 rdd = (txx*vec4(rd,0.0)).xyz\n ;vec3 roo = (txx*vec4(ro,1.0)).xyz\n ;// ray-box intersection in box space\n ;vec3 m = 1.0/rdd\n ;vec3 n = m*roo\n ;vec3 k = abs(m)*rad\n ;vec3 t1 = -n - k\n ;vec3 t2 = -n + k\n ;float tN = max( max( t1.x, t1.y ), t1.z )\n ;float tF = min( min( t2.x, t2.y ), t2.z )\n ;if( tN > tF || tF < 0.0) tN = -1.0\n ;return tN;}\n\n// returns normal, st and face\nvoid nBox(vec3 o,vec3 d,mat4 txx,mat4 txi,vec3 rad//rayorigin,raydirection\n         ,out vec3 outNor,out vec2 outST,out int outFaceID\n){// convert from ray to box space\n ;vec3 rdd=(txx*vec4(d,0.0)).xyz\n ;vec3 roo=(txx*vec4(o,1.0)).xyz\n ;// intersect and select\n ;vec3 s=-sign(rdd)\n ;vec3 t=(-roo+s*rad)/rdd\n ;// compute normal in world space\n ;      if(t.x>t.y&&t.x>t.z){outNor=txi[0].xyz*s.x;outST=roo.yz+rdd.yz*t.x;outFaceID=int(1+int(s.x))/2 // 0, 1\n ;}else if(t.y>t.z)         {outNor=txi[1].xyz*s.y;outST=roo.zx+rdd.zx*t.y;outFaceID=int(5+int(s.y))/2 // 2, 3 \n ;}else                     {outNor=txi[2].xyz*s.z;outST=roo.xy+rdd.xy*t.z;outFaceID=int(9+int(s.z))/2 // 4, 5 \n ;}}\n\n\n\n\n\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oNor, out vec2 oUV, out int oID\n){float tmi = 1e20\n ;mat4  cma\n ;vec3  csi\n ;int  cin = 0xffffffff\n ;for( int i=0; i<NUMBOXES; i++   //es100 safe\n ){mat4 ma; vec3 si; getLocation(i, ma, si)\n  ;float res = iBox( ro, rd, ma, si )\n  ;if( res>0.0 && res<tmi\n  ){cma = ma\n   ;csi = si\n   ;cin = i\n   ;tmi = res\n ;}}\n ;int resID\n ;nBox( ro, rd, cma, inverse(cma), csi, oNor, oUV, resID )\n ;oID = cin*6 + resID\n ;return (cin==0xffffffff) ? -1.0 : tmi;}\n\nfloat castShadowRay(vec3 ro,vec3 rd\n){for( int i=0; i<NUMBOXES; i++ //es100 safe\n ){mat4 ma; vec3 si; getLocation(i, ma, si)\n  ;if(iBox(ro,rd,ma,si)>0.)return 0.;}\n ;return 1.;}\n\nmat3 setCamera(vec3 o,vec3 d, float t//origin,target,time\n){d=normalize(d-o)\n ;o=normalize(cross(d,vec3(sin(t),cos(t),0.)))\n ;return mat3(o,cross(o,d),-d);}\n\nvec3 sphereMap(vec3 d){return vec3(.3,.4,1.2);}    \n\nvoid light1(inout vec3 iColor,vec3 pos,vec3 nor,vec3 rd,vec3 tex,int k,int bounce, int sa,float epsilon){\n   ;vec3 sunCol =  vec3(1.7,0.8,0.6)*10.0; \n   ;vec3 sunDir = normalize(vec3(0.5,0.9,-0.2));\n   ;vec3 ssundir = normalize(sunDir+.01*uniformVector(sa + 11 + 45*(bounce+11*k)))\n   ;float sunDif =  max(0.0, dot(ssundir, nor))\n   ;float sunSha = 1.0; if( sunDif > 0.00001 ) sunSha = castShadowRay( pos + nor*epsilon, ssundir)\n   ;iColor += sunCol * sunDif * sunSha\n   ;vec3 h = normalize( sunDir - rd )\n   ;float shl = 0.04 + 0.96*pow( 1.0-clamp(dot(h,-rd),0.0,1.0), 5.0 )\n   ;float spe = tex.x*30.0*pow( clamp( dot( nor, h ), 0.0, 1.0 ), 24.0*tex.x )\n   ;iColor += spe * shl * sunCol * sunSha * sunDif\n   ;}\nvoid light2(inout vec3 iColor,vec3 pos,vec3 nor,vec3 rd,vec3 tex,int sa,int k,int bounce,float epsilon){\n//;for( int i=min(0,iFrame); i<2; i++ //not es100 safe\n ;for( int i=0;i<2;i++// es100 safe\n ){//if(iFrame>1)break//i see no difference in this es100 save line\n  ;vec3 skyPoint=cosineDirection((sa+7*int(iFrame)+47*(k)+13*int(i)+bounce*92),nor)\n  ;float skySha = castShadowRay( pos + nor*epsilon, skyPoint)\n  ;vec3  skyCol = sphereMap(skyPoint)\n  ;iColor += skyCol * skySha / 2.0\n  ;vec3 h = normalize( skyPoint - rd )\n  ;float shl=.04+.96*pow( 1.0-clamp(dot(h,-rd),0.0,1.0), 5.0 )\n  ;float spe=tex.x*250.*pow( clamp( dot( nor, h ), 0.0, 1.0 ), 24.0*tex.x )\n  ;iColor+=spe*shl*skyCol*skySha/2.;};}\n\nvec4 render( in vec3 ro, in vec3 rd, int sa, out int oID\n){const float epsilon = 0.001\n ;vec3 colorMask = vec3(1.0)\n ;vec3 accumulatedColor = vec3(0.0)\n ;vec3 oro = ro\n ;vec3 ord = rd\n ;oID = NUMBOXES+10\n ;float fdis = 0.\n ;const int numRays = 4\n ;for( int k=0; k<numRays; k++ //es100 safe\n ){ro=oro\n  ;rd=ord\n  ;colorMask = vec3(1.0)\n  ;for(int bounce=0;bounce<3;bounce++ //es100 safe // bounces of GI\n  ){vec3 nor\n   ;vec2 st\n   ;int id\n   ;float t=castRay( ro, rd, nor, st, id )\n   ;if( t < 0.\n   ){if( k==0 && bounce==0\n    ){accumulatedColor=sphereMap(rd)*float(numRays)*pi\n     ;oID=NUMBOXES+10\n     ;fdis = 1000.\n    ;}break;}\n   ;int obj = id/6\n   ;vec3 pos = ro + rd*t\n   ;if(k==0&&bounce==0){fdis=t;oID =id;}\n   ;int kid=id/6\n   ;vec3 surfaceColor=vec3(.4)\n   ;vec3 tex = texture(iChannel0, st.yx*0.3 ).xyz\n   ;if( kid>=1 && kid<=4) tex = texture( iChannel0, st*0.2 ).xyz*vec3(0.7,0.8,0.8)\n   ;surfaceColor *= tex\n   ;//direct lighitng\n   ;colorMask *= surfaceColor\n   ;vec3 iColor=vec3(0)\n   #if 1\n   ;light1(iColor,pos,nor,rd,tex,sa,k,bounce,epsilon)\n   #endif\n   #if 1\n   ;light2(iColor,pos,nor,rd,tex,sa,k,bounce,epsilon)\n   #endif\n   ;accumulatedColor += colorMask * iColor\n   ;// calculate new ray\n   ;float isDif = 0.8\n   ;if(fhash1(float(sa + 1 + 7*bounce + 91*k + 31*int(iFrame))) < isDif\n   ){rd = cosineDirection((76 + 73*(bounce+5*k) + sa + 17*int(iFrame)), nor)\n   ;}else{\n    ;float glossiness = 0.4\n    ;rd = normalize(reflect(rd, nor)) + uniformVector(sa + 111 + 65*(bounce+7*k)+87*int(iFrame)) * glossiness\n    ;}\n   ;ro = pos + epsilon*nor;}}\n ;accumulatedColor /= float(numRays)\n ;return vec4( clamp(accumulatedColor,0.,10.),fdis );}\n\nvec3 getVofM(mat3 a,int b){//return a[b]\n ;if(b==2)return a[2]\n ;if(b==1)return a[1]\n ;return a[0];}\n\n     \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){\n #ifndef SceneTR\n ;fragColor=vec4(1);return\n #endif\n ;vec3 r=iResolution.xyz\n ;vec2 off=vec2(0)\n ;//off=(hash2(int(iFrame))-.5)*5.\n ;vec2 p = (2.*(fragCoord+off)-r.xy)/r.y\n ;int sa = ihash1( int(iFrame)*11 + int(fragCoord.x) + int(fragCoord.y)*113 )\n ;float time = -2.0 + (iTime-10.0)*0.03    // camera movement\n ;float cr = 0.1*cos(0.1)\n ;vec3 ro = vec3(8.0*cos(time), 1.0, 8.0*sin(time) )\n ;vec3 ta = vec3(0.0,3.0,0.0)\n ;float fl = 1.8\n ;mat3 cam = setCamera( ro, ta, cr )\n ;vec3 rd = normalize( cam * vec3(p,-fl) )\n ;int id\n ;vec4 ren=render(ro,rd,sa,id)\n ;vec3 c=ren.xyz\n ;float t=ren.w\n ;// reproject from previous frame and average\n ;mat4 oldCam=mat4(tf3(vec2(0,0),r)\n                  ,tf3(vec2(1,0),r)\n                  ,tf3(vec2(2,0),r),0,0,0,1)\n ;vec4 wpos=vec4(ro + rd*t,1.0)    // world space\n ;vec3 cpos=(wpos*oldCam).xyz;  // camera space note inverse multiply\n ;vec2 npos=-fl * cpos.xy / cpos.z  // ndc space\n ;vec2 spos=.5+.5*npos*vec2(r.y/r.x,1.)   // screen space\n ;spos-=off/r.xy //undo dither\n ;vec2 rpos = spos * r.xy - .5// raster space\n ;vec2 ipos=vec2(floor(rpos))\n ;if( (ipos.y>0. || ipos.x>2.) && iFrame>0\n ){// blend pixel color history\n  #if 1\n  ;vec2 fuv=rpos-vec2(ipos)\n  ;vec4 odata1=tf3(ipos,r)\n  ;vec4 odata2=tf3(ipos+vec2(1,0),r)\n  ;vec4 odata3=tf3(ipos+vec2(0,1),r)\n  ;vec4 odata4=tf3(ipos+vec2(1.),r)\n  ;vec4 ocol=vec4(0)\n  ;int n=0\n  ;if(id==int(odata1.w)){ocol+=vec4(odata1.xyz,1.)*(1.-fuv.x)*(1.-fuv.y);n++;}\n  ;if(id==int(odata2.w)){ocol+=vec4(odata2.xyz,1.)*(   fuv.x)*(1.-fuv.y);n++;}\n  ;if(id==int(odata3.w)){ocol+=vec4(odata3.xyz,1.)*(1.-fuv.x)*(   fuv.y);n++;}\n  ;if(id==int(odata4.w)){ocol+=vec4(odata4.xyz,1.)*(   fuv.x)*(   fuv.y);n++;}\n  ;if(n>2)c=mix(max(ocol.xyz/ocol.w,0.),c,.1\n );else   c=mix(textureLod(iChannel1, spos,0.).xyz,c,.3)\n  #else\n  ;col=mix(textureLod(iChannel1,spos,0.).xyz,col,.1)\n  #endif\n  ;}\n ;vec2 ifc = vec2(floor(fragCoord))\n ;vec3 s=getVofM(cam,int(vec2(floor(fragCoord)).x))\n ;if( ifc.y==0. && ifc.x<=2.)fragColor=vec4(s,-dot(s,ro))\n ;else                       fragColor=vec4(c,id);}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}