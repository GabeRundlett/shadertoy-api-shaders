{
    "Shader": {
        "info": {
            "date": "1607110086",
            "description": "The texture mapping is better now. Use the mouse to rotate.",
            "flags": 32,
            "hasliked": 0,
            "id": "tdyfWW",
            "likes": 6,
            "name": "Physics Testing Compound #1",
            "published": 3,
            "tags": [
                "3d",
                "terrain",
                "physics"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 244
        },
        "renderpass": [
            {
                "code": "/*\nA combination of my \"3D Collisions\" and \"3D Terrain Experiment\" shaders.\n*/\n\n// Screen variables:\nvec3 backgroundColor = vec3(0.0, 0.0, 0.0);\nvec2 antialiasing = vec2(1.0, 1.0); // Set to 2x2 if your computer can handle it.\nbool shadows = false; // Set to true for shadows but it may make the shader run slower.\n\n// Light variables:\nvec3 lightDirection = vec3(-0.58, 0.58, -0.58);\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n// Camera variables:\nvec3 cameraPosition = vec3(-10.0, 5.0, -10.0);\nvec3 cameraRight = vec3(1.0, 0.0, 0.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraForward = vec3(0.0, 0.0, -1.0);\nfloat cameraFocalLength = 1.0;\n\n// Ray marching constants:\nconst vec3 GRADIENT_STEP = vec3(0.001, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 80.0;\nconst float MIN_HIT_DISTANCE = 0.001;\nconst float SHADOW_BIAS = MIN_HIT_DISTANCE * 2.0;\nconst int MAX_STEPS = 200;\n\n// Raymarching structures:\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Surface {\n    vec3 ambientColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float shininess;\n    float signedDistance;\n};\n\n// Constructive Solid Geometry (CSG) Operators:\nSurface Union(in Surface surface1, in Surface surface2) {\n    Surface surfaceUnion = surface1;\n    if (surface2.signedDistance < surfaceUnion.signedDistance) {\n        surfaceUnion = surface2;\n    }\n    return surfaceUnion;\n}\n\n// Transformations:\nvec3 Translate(in vec3 p, in vec3 t) {\n    return p - t;\n}\n\nvec3 Rotate(in vec3 p, in vec3 r) {\n    vec3 rad = radians(-r);\n    vec3 cosRad = cos(rad);\n    vec3 sinRad = sin(rad);\n\n    mat3 xRotation = mat3(1.0,      0.0,       0.0,\n                          0.0, cosRad.x, -sinRad.x,\n                          0.0, sinRad.x,  cosRad.x);\n\n    mat3 yRotation = mat3( cosRad.y, 0.0, sinRad.y,\n                                0.0, 1.0,      0.0,\n                          -sinRad.y, 0.0, cosRad.y);\n\n    mat3 zRotation = mat3(cosRad.z, -sinRad.z, 0.0,\n                          sinRad.z,  cosRad.z, 0.0,\n                               0.0,       0.0, 1.0);\n\n    return zRotation * yRotation * xRotation * p;\n}\n\n// Scene mapping function:\nSurface mapScene(in vec3 p) {\n    vec2 terrainUV = mod(p.xz * 0.5, vec2(2.0)) * 0.5;\n    vec3 terrainTexture = texture(iChannel1, terrainUV).rgb;\n    Surface terrain = Surface(0.2 * terrainTexture,\n                              terrainTexture,\n                              vec3(0.0, 0.0, 0.0), 0.0,\n                              mapCompoundTerrain(p) * 0.6);\n\n    vec2 wallsUV = p.xy * 0.05;\n    if (abs(p.x) > abs(p.z)) {\n        wallsUV = p.yz * 0.05;\n    }\n\n    wallsUV.x *= 0.5;\n    vec3 wallsTexture = texture(iChannel2, wallsUV).rgb;\n    Surface walls = Surface(0.2 * wallsTexture,\n                            wallsTexture,\n                            vec3(0.0, 0.0, 0.0), 0.0,\n                            mapCompoundWalls(p));\n\n    Surface ball = Surface(vec3(0.2, 0.0, 0.0),\n                           vec3(1.0, 0.0, 0.0),\n                           vec3(1.0, 1.0, 1.0), 8.0,\n                           length(p - getBallPos()) - BALL_RADIUS);\n\n    Surface light = Surface(vec3(1.0, 1.0, 1.0),\n                            vec3(0.0, 0.0, 0.0),\n                            vec3(0.0, 0.0, 0.0), 0.0,\n                            length(p - lightDirection * 100.0) - 10.0);\n\n    return Union(terrain, Union(walls, Union(ball, light)));\n}\n\n// Normal calculation function (using gradient):\nvec3 calculateNormal(in vec3 p) {\n    float gradientX = mapScene(p + GRADIENT_STEP.xyy).signedDistance - mapScene(p - GRADIENT_STEP.xyy).signedDistance;\n    float gradientY = mapScene(p + GRADIENT_STEP.yxy).signedDistance - mapScene(p - GRADIENT_STEP.yxy).signedDistance;\n    float gradientZ = mapScene(p + GRADIENT_STEP.yyx).signedDistance - mapScene(p - GRADIENT_STEP.yyx).signedDistance;\n    return normalize(vec3(gradientX, gradientY, gradientZ));\n}\n\n// Shadow mapping function:\nbool visibleFromLight(in vec3 p, in vec3 normal) {\n    p += normal * SHADOW_BIAS;\n    float shadowDistance = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; iterations++) {\n        vec3 shadowTestPosition = p + lightDirection * shadowDistance;\n        Surface occluderSurface = mapScene(shadowTestPosition);\n        if (abs(occluderSurface.signedDistance) < MIN_HIT_DISTANCE) {\n            return false;\n        }\n\n        if (shadowDistance > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        shadowDistance += occluderSurface.signedDistance;\n    }\n\n    return true;\n}\n\n// Surface shader (uses the Phong illumination model):\nvec3 shadeSurface(in Surface surface, in vec3 hitPosition, in Ray ray, in vec3 normal) {\n    vec3 illuminationAmbient = surface.ambientColor * lightColor;\n\n    float lambertian = max(0.0, dot(normal, lightDirection));\n    vec3 illuminationDiffuse = lambertian * surface.diffuseColor * lightColor;\n\n    vec3 reflection = reflect(lightDirection, normal);\n    float specularAngle = max(0.0, dot(reflection, ray.direction));\n    vec3 illuminationSpecular = clamp(pow(specularAngle, surface.shininess), 0.0, 1.0) * surface.specularColor * lightColor;\n\n    float shadow = shadows ? float(visibleFromLight(hitPosition, normal)) : 1.0;\n\n    return illuminationAmbient + shadow * (illuminationDiffuse + illuminationSpecular);\n}\n\n// Raymarching loop:\nvec4 rayMarch(in Ray ray) {\n    float distanceTraveled = 0.0;\n\n    vec3 color = backgroundColor;\n    vec3 currentPosition, normal;\n    Surface sceneSurface;\n\n    bool rayHit = false;\n    for (int iterations=0; iterations < MAX_STEPS; iterations++) {\n        currentPosition = ray.origin + ray.direction * distanceTraveled;\n        sceneSurface = mapScene(currentPosition);\n        if (abs(sceneSurface.signedDistance) < MIN_HIT_DISTANCE) {\n            rayHit = true;\n            break;\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        distanceTraveled += sceneSurface.signedDistance;\n    }\n\n    if (rayHit) {\n        normal = calculateNormal(currentPosition);\n        color = shadeSurface(sceneSurface, currentPosition, ray, normal);\n    }\n\n    return vec4(color, 1.0);\n}\n\n// Pixel shader output function:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 halfResolution = 0.5 * iResolution.xy;\n    vec2 mouse = radians((iMouse.xy - vec2(0.0, halfResolution.y)) * 0.5);\n\n    vec2 c = cos(mouse);\n    vec2 s = sin(mouse);\n\n    cameraRight = vec3(c.x, 0.0, s.x);\n    cameraUp = vec3(s.x * -s.y, c.y, -c.x * -s.y);\n    cameraForward = vec3(s.x * c.y, s.y, -c.x * c.y);\n\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    for (float yOffset=0.0; yOffset < antialiasing.y; yOffset++) {\n        for (float xOffset=0.0; xOffset < antialiasing.x; xOffset++) {\n            vec2 pixel = (fragCoord + vec2(xOffset, yOffset) / antialiasing - halfResolution) / iResolution.y;\n            vec3 rayOrigin = cameraPosition + cameraForward * cameraFocalLength;\n            vec3 rayDirection = normalize(rayOrigin - (cameraPosition - cameraRight * pixel.x - cameraUp * pixel.y));\n            fragColor += rayMarch(Ray(rayOrigin, rayDirection));\n        }\n    }\n\n    fragColor /= antialiasing.y * antialiasing.x;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Starting values:\n    if (ivec2(fragCoord) == ivec2(0, 0)) {\n        fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n    }\n\n    if (ivec2(fragCoord) == ivec2(1, 0)) {\n        fragColor = vec4(0.1, 0.6, 0.1, 1.0);\n    }\n\n    if (iFrame > 0) {\n        // Update values (after initializing them):\n        vec3 ballPos = getBallPos();\n        vec3 ballVel = getBallVel();\n\n        float distToEnv = mapEnvironment(ballPos);\n        if (distToEnv < BALL_RADIUS) {\n            vec3 hitNormal = getNormal(ballPos);\n            ballVel = reflect(ballVel, hitNormal) * DECAY;\n        }\n\n        ballPos.y = max(sampleHeightmap(ballPos.xz) + BALL_RADIUS, ballPos.y);\n\n        ballVel.y -= GRAVITY;\n        ballPos += ballVel;\n        if (ivec2(fragCoord) == ivec2(0, 0)) {\n            fragColor = vec4(ballPos, 1.0);\n        }\n\n        if (ivec2(fragCoord) == ivec2(1, 0)) {\n            fragColor = vec4(ballVel, 1.0);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Variable retrieval functions:\n#define getBallPos() texelFetch(iChannel0, ivec2(0, 0), 0).xyz\n#define getBallVel() texelFetch(iChannel0, ivec2(1, 0), 0).xyz\n\n#define BALL_RADIUS 1.0\n\n#define GRAVITY 0.01\n#define DECAY 1.0\n\n// Not exact:\nfloat noise1(in float x) {\n    return fract(sin(x * 12.527) * 573.173);\n}\n\nfloat noise2(in float x) {\n    return fract(sin(x * 13.753) * 593.123);\n}\n\nfloat continuousNoise1(in float x) {\n    const float r = 1.1;\n\n    float x1 = floor(x * r) / r;\n    float y1 = noise1(x1);\n\n    float x2 = ceil(x * r) / r;\n    float y2 = noise1(x2);\n\n    return y1 + (0.5 + 0.5 * sin((2.0 * (x - x1) / (x2 - x1) - 1.0) * 1.57)) * (y2 - y1);\n}\n\nfloat continuousNoise2(in float x) {\n    const float r = 1.1;\n\n    float x1 = floor(x * r) / r;\n    float y1 = noise2(x1);\n\n    float x2 = ceil(x * r) / r;\n    float y2 = noise2(x2);\n\n    return y1 + (0.5 + 0.5 * sin((2.0 * (x - x1) / (x2 - x1) - 1.0) * 1.57)) * (y2 - y1);\n}\n\nfloat sampleHeightmap(in vec2 p) {\n    vec2 sp = p * 0.5;\n    float height = 2.0 * (continuousNoise1(sp.x + 0.5 * continuousNoise2(sp.y)) + continuousNoise2(sp.y + continuousNoise1(sp.x)));\n    return height;\n}\n\nfloat mapCompoundTerrain(in vec3 p) {\n    return p.y - sampleHeightmap(p.xz);\n}\n\nfloat mapCompoundWalls(in vec3 p) {\n    vec3 q = abs(p);\n\n    float outer = max(q.y - 15.0, max(q.x, q.z) - 30.0);\n    float inner = max(q.y - 1000.1, max(q.x, q.z) - 29.9);\n\n    return max(outer, -inner);\n}\n\nfloat mapEnvironment(in vec3 p) {\n    return min(mapCompoundTerrain(p), mapCompoundWalls(p));\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapEnvironment(p + vec3(0.001, 0.0, 0.0)) - mapEnvironment(p - vec3(0.001, 0.0, 0.0)),\n                          mapEnvironment(p + vec3(0.0, 0.001, 0.0)) - mapEnvironment(p - vec3(0.0, 0.001, 0.0)),\n                          mapEnvironment(p + vec3(0.0, 0.0, 0.001)) - mapEnvironment(p - vec3(0.0, 0.0, 0.001))));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}