{
    "Shader": {
        "info": {
            "date": "1681756154",
            "description": "Hey, this one looks OK!  Trick was to use a modulo on the radius.  Getting the golden variables is pretty tricky, though.  Just guessing really, mixing a handful of irrational numbers until it looks OK.  Proper treatment would require some sort of search.",
            "flags": 0,
            "hasliked": 0,
            "id": "cdySWt",
            "likes": 9,
            "name": "Fibonacci Spheres",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "delajor",
            "viewed": 254
        },
        "renderpass": [
            {
                "code": "#define NUM_SPHERES 2048\n#define PSI  1.533751168755204288118041 \n#define PHI  sqrt(2.0)\n#define GPHI 0.5 * (1.0 +  sqrt(5.0))\n\n#define LIGHT_POWER 30.\n#define SPECULAR_POWER 20.\n#define AMBIENT .3\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\nstruct quat\n{\n    float s;\n    vec3 v;\n};\n\nvec3 rotate(quat q, vec3 p) // NOTE: order of parameters copies order of applying rotation matrix: M v\n{\n    return p + 2.0 * cross(q.v, cross(q.v, p) + q.s * p); // suggested by mla, requires q to be unit (i.e. normalized)\n\n    // Derive to https://en.wikipedia.org/wiki/Euler%E2%80%93Rodrigues_formula#Vector_formulation\n    //return p + 2.0 * cross(q.v, cross(q.v, p)) + 2.0 * cross(q.v, q.s * p); // cross-product is distributive\n    //return p + 2.0 * cross(q.v, q.s * p) + 2.0 * cross(q.v, cross(q.v, p)); // vector addition is commutative\n    //return p + 2.0 * q.s * cross(q.v, p) + 2.0 * cross(q.v, cross(q.v, p)); // scalar can be factored-out\n    // translate variable names\n    vec3 x = p;\n    float a = q.s;\n    vec3 omega = q.v;\n    return x + 2.0 * a * cross(omega, x) + 2.0 * cross(omega, cross(omega, x)); // Euler Rodrigues' Formula\n}\n\nstruct Ray { vec3 o, d; };\nstruct Sphere {\n\tfloat r;\n\tvec3 p, c;\n};\n\nmat3 rotate_around_z(float angle){\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, -_sin, 0, _sin, _cos, 0, 0, 0, 1);\n}\n\n\nmat3 rotate_around_y(float angle){\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, 0, _sin, 0, 1, 0, -_sin, 0, _cos);\n}\n\nSphere getSphere(int i){\n    float N = float(NUM_SPHERES);\n    float t = float(i) / N;\n\n    float sqti = sqrt(t);\n    float sqt1i = sqrt(1.0 - t);\n\n    float u = iMouse.x / iResolution.x;\n    float v = iMouse.y / iResolution.y;\n    float golden = 0.5 * (1.0 + sqrt(5.0));\n    float sup_golden =1.4655712318767680266567312;\n    float psi4 = 1.533751168755204288118041;\n    float plastic = 1.32471795724474602596;\n    float root2 = sqrt(2.0);\n    float root3 = sqrt(3.0);\n    float good_guess = 1.57801;\n    float test = pow(1.0 / 2.0 / PI, 0.5);\n    \n    //float phi = plastic;\n    //float psi = sup_golden;\n    \n    //float phi = sup_golden;\n    //float psi = 0.1*plastic;\n\n    //float phi = root2;\n    float psi = plastic;\n    \n    float phi = golden;\n    //float psi = sup_golden;\n    float Nt = N * t;\n    \n\n    float NtP =(Nt) * plastic;\n    float thet = 2.0 * PI * Nt;\n    \n    float t0 = NtP - floor(NtP);\n    float x0 =  sqti * sin(thet / phi);\n    float x1 =  sqti * cos(thet / phi);\n    float y0 =  sqt1i * sin(thet / psi);\n    float y1 =  sqt1i * cos(thet / psi);\n    quat q = quat(y0, vec3(y1, x0, x1));\n    //vec3 p = rotate_around_y(0.1*float(iMouse.x)) * vec3(10.0 * x1, 10.0 * x0,t0);\n    \n    //vec3 c0 = vec3(1.0, 0.3, 0.2);\n    vec3 p0 = 3.0 * pow(t0, 1.0/3.0)* vec3(1.0, 0.0, 0.0);\n    vec3 p = rotate(q, p0);\n    //ugly keyframe ifs... blech\n    int tB = 600;\n    int tBh = tB/2;\n    int tBq = tB/4;\n    //vec3 p = 3.0 * vec3(x0, y0, z0);\n    float rest = -1.0 * PI / 3.0;\n    \n    if(iFrame%tB > tBh){\n        int fF = iFrame%tB - tBh;\n        float fl = 2.0 * float(fF % tBq)/ float(tBq) - 1.0;\n        if(fF <= tBq){\n           float zm = fl;\n            if(p[2] < zm - 0.2)\n                 return Sphere(0.0, vec3(-1.0), vec3(0.0));\n            if(p[2] > zm + 0.2)\n                return Sphere(0.0, vec3(-1.0), vec3(0.0));\n        }\n        if(fF > tBq){\n            float xm = fl;\n            if(p[0] < xm - 0.2)\n                return Sphere(0.0, vec3(-1.0), vec3(0.0));\n            if(p[0] > xm + 0.2)\n                return Sphere(0.0, vec3(-1.0), vec3(0.0));\n        }\n         p = rotate_around_y(rest) * p;\n    }\n    else\n        p = rotate_around_y(rest + 2.0 * PI * float(iFrame) / float(tBh)) * p;\n    //vec3 p = rotate_around_y(0.1*float(iMouse.x)) * vec3(10.0 * x1, 10.0 * x0,t0);\n    \n    vec3 c0 = vec3(\n        pow(cos(1.0 * PI*t + 0.0 * PI/3.0),2.0),\n        pow(cos(1.0 * PI*t + 2.0 * PI/3.0),2.0), \n        pow(cos(1.0 * PI*t + 4.0 * PI/3.0),2.0));\n\n    //p0 = rotate_around_y(0.2*float(iTime)) * p0;\n;\n    vec3 c = c0;\n    \n    \n    return Sphere(0.15, p, c);\n}\n\n#define MAX_STEPS 600\n#define MAX_DIST 1e10\n#define EPS .001\n\n// Find a nearest ray-sphere intersection\n// o - ray origin\n// l - ray direction (normalized)\n// ignore - sphere to ignore when detecting intersection (used for shadows)\n// d - distance output\n// Returns sphere number, -1 if no intersection found\nint findIntersection(vec3 o, vec3 l, int ignore, out float d) {\n\n    int imin = -1;\n    d = 1e5;\n    \n    for (int i = 0; i < NUM_SPHERES; i++) {\n        if (i == ignore) {\n            continue;\n        }\n        Sphere sphere = getSphere(i);\n        vec3 c = sphere.p;\n        float r = sphere.r;\n\n        // Ray-sphere intersection formula\n        vec3 t1 = o - c;\n        float t1l = length(t1);\n        float t2 = dot(l, t1);\n        float s = t2 * t2 - t1l * t1l + r * r;\n        if (s >= 0.) {\n            float ss = sqrt(s);\n            float sd = min(-t2 + ss, -t2 - ss);\n            if (sd >= 0. && sd < d) {\n                imin = i;\n                d = sd;\n            }\n        }\n    }\n    return imin;\n}\n\n// Trace a single ray\n// camO - camera origin\n// camL - camera ray direction (normalized)\n// Returns a fragment color\nvec3 trace(vec3 camO, vec3 camL) {\n    float d = 0.;\n    int i_s = findIntersection(camO, camL, -1, d);\n    \n    if (i_s == -1) {\n        // There was no intersection, return background color\n        return vec3(0, 0, 0);\n    }\n    \n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n    \n    vec3 lightPoint = vec3(-5.0, 5.0, -5.0);\n    Sphere sph = getSphere(i_s);\n    \n    // Sphere color\n    vec3 sColor = sph.c;\n    vec3 aColor = sColor * vec3(AMBIENT, AMBIENT, AMBIENT);\n\n    // Intersection point\n    vec3 iPoint = camO + camL * d;\n    vec3 iNormal = normalize(iPoint - sph.p);\n\n    // Light direction vector\n    vec3 lightDir = normalize(lightPoint - iPoint );\n    \n    // Check if there's another sphere between this one and the light source\n    float dShadow = 0.;\n    int shadowedBy = findIntersection(iPoint, lightDir, i_s, dShadow);\n    dShadow = float(shadowedBy + 1) / 5.0;\n    if (shadowedBy > -1) {\n        // We're under shadow, use ambient color\n        return aColor;\n    }\n    \n    // Lighting (diffusion and specular)\n    float cosA = clamp(dot(iNormal, lightDir), 0., 1.);\n    float cosS = clamp(dot(-camL, reflect(-lightDir, iNormal)), 0., 1.);\n\n    float dSquared = pow(length(iPoint - lightPoint), 2.);\n    \n    return aColor +\n        sColor * lightColor * cosA * LIGHT_POWER / dSquared +\n        lightColor * pow(cosS, SPECULAR_POWER) * LIGHT_POWER / dSquared;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Camera\n    vec3 camO = vec3(0, 0, -25);\n    vec3 camL = normalize(vec3(uv.x, uv.y,6));\n    \n    // Ray-tracing\n    fragColor = vec4(trace(camO, camL), 1.);      \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}