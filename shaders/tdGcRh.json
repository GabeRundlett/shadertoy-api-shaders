{
    "Shader": {
        "info": {
            "date": "1602236037",
            "description": "Catmull-Rom Spline.\n\nThe first and last point are considered control points thus they aren't rendered.",
            "flags": 0,
            "hasliked": 0,
            "id": "tdGcRh",
            "likes": 25,
            "name": "Catmull-Rom Splines",
            "published": 3,
            "tags": [
                "spline"
            ],
            "usePreview": 0,
            "username": "Danguafer",
            "viewed": 2092
        },
        "renderpass": [
            {
                "code": "// Reference: https://qroph.github.io/2018/07/30/smooth-paths-using-catmull-rom-splines.html\n\n// Constants\n\n#define time (iTime/1.0)\n#define LINES 32\n#define STEP 1.0/float(LINES)\n\n#define POINTS 10\n#define MAX_POINTS POINTS\n\nconst float PI = acos(-1.0);\nconst float TAU = PI * 2.0;\n\n// Draw helpers\n\nvec2 p;\n\nfloat line(vec2 a, vec2 b) {\n\tvec2 v  = b-a;\n    vec2 p0 = p-a;\n    float k = min(length(p0)/length(v),1.0);\n    return smoothstep(4.0/iResolution.y,0.0,length(p0-k*v));\n}\n\nfloat point(vec2 o) { return smoothstep(10.0/iResolution.y,7.5/iResolution.y,length(p-o)); }\n\nvoid drawPoint(inout vec3 color, vec3 drawColor, vec2 p) {\n    color = mix(color, drawColor, point(p));\n}\n\nvoid drawPoints(inout vec3 color, vec3 drawColor, vec2 p[MAX_POINTS], int count) {\n    for (int i = 0; i < count; i++)\n        drawPoint(color, drawColor, p[i]);\n}\n\nvoid drawLine(inout vec3 color, vec3 drawColor, vec2 p[MAX_POINTS], int count) {\n    for (int i = 0; i < count - 1; i++) {\n        color = mix(color, drawColor, line(p[i], p[i+1]));\n    }\n}\n\nvec2 splineInterpolation(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n    float alpha = 1.0;\n    float tension = 0.0;\n    \n    float t01 = pow(distance(p0, p1), alpha);\n\tfloat t12 = pow(distance(p1, p2), alpha);\n\tfloat t23 = pow(distance(p2, p3), alpha);\n\n\tvec2 m1 = (1.0f - tension) *\n    \t(p2 - p1 + t12 * ((p1 - p0) / t01 - (p2 - p0) / (t01 + t12)));\n\tvec2 m2 = (1.0f - tension) *\n    \t(p2 - p1 + t12 * ((p3 - p2) / t23 - (p3 - p1) / (t12 + t23)));\n    \n\tvec2 a = 2.0f * (p1 - p2) + m1 + m2;\n\tvec2 b = -3.0f * (p1 - p2) - m1 - m1 - m2;\n\tvec2 c = m1;\n\tvec2 d = p1;\n\n\treturn a * t * t * t +\n           b * t * t +\n           c * t +\n           d;\n\n}\n\nfloat spline(vec2 p0, vec2 p1, vec2 p2, vec2 p3) {\n    float curve = 0.0;\n    vec2 a = p1;\n\n    for (int i = 1; i <= LINES; i++) {\n        vec2 b = splineInterpolation(p0, p1, p2, p3, STEP*float(i));\n        curve = mix(curve,1.0, line(a, b));\n        a = b;\n    }\n    \n    return curve;\n}\n\nvoid drawSpline(inout vec3 color, vec3 drawColor, vec2 p[MAX_POINTS], int count) {\n    for (int i = 0; i < count - 3; i++) {\n        color = mix(color, drawColor, spline(p[i], p[i+1], p[i+2], p[i+3]));\n    }\n}\n\nvec2[MAX_POINTS] deformedCircle(int count) {\n    vec2 p[MAX_POINTS];\n    for (int i = 0; i < count; i++) {\n        float a = float(i) / float(count) * TAU;\n        p[i] = vec2(3.0, 1.5) * vec2(cos(a), sin(a)) * (0.3 + 0.1 * sin(iTime) + 0.15 * sin(a * 3.456 + iTime));\n    }\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0.94);\n    \n    vec2 p[MAX_POINTS] = deformedCircle(POINTS);\n    \n    drawLine(color, vec3(0.0), p, POINTS);\n    drawPoints(color, vec3(0.0), p, POINTS);\n    drawSpline(color, vec3(1.0, 0.0, 0.0), p, POINTS);\n    \n\tfragColor = vec4(color ,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}