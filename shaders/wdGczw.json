{
    "Shader": {
        "info": {
            "date": "1602443262",
            "description": "This is my attempt to create a humanoid using only primitives. Drag the mouse too rotate.",
            "flags": 0,
            "hasliked": 0,
            "id": "wdGczw",
            "likes": 2,
            "name": "Humanoid Attempt",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "humanoid"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 153
        },
        "renderpass": [
            {
                "code": "/*\nThis shader uses my Raymarcher Template shader (https://www.shadertoy.com/view/3styDs).\n*/\n\n// Default (background) color:\nvec3 backgroundColor = vec3(0.0, 0.0, 0.0);\n\n// Light variables:\nvec3 lightDirection = vec3(-0.58, 0.58, 0.58);\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n// Camera variables:\nvec3 cameraPosition = vec3(0.0, 0.0, 2100.0);\nvec3 cameraRight = vec3(1.0, 0.0, 0.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraForward = vec3(0.0, 0.0, -1.0);\nfloat cameraFocalLength = 400.0;\n\n// Ray marching constants:\nconst vec3 GRADIENT_STEP = vec3(0.001, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 2500.0;\nconst float MIN_HIT_DISTANCE = 0.001;\nconst int MAX_STEPS = 300;\n\n// Signed Distance Functions (SDFs):\nfloat sdRoundedCuboid(vec3 p, vec3 b, float r) {\n  vec3 q = abs(p) - 0.5 * b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\nfloat sdCylinder(in vec3 p, in float h, in float r) {\n    return max(abs(p.y) - 0.5 * h, length(p.xz) - r);\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// Constructive Solid Geometry (CSG) Operators:\nfloat SmoothUnion(float sdf1, float sdf2, float smoothness) {\n    float interpolation = clamp(0.5 + 0.5 * (sdf2 - sdf1) / smoothness, 0.0, 1.0);\n    return mix(sdf2, sdf1, interpolation) - smoothness * interpolation * (1.0 - interpolation);\n}\n\nfloat Union(in float sdf1, in float sdf2) {\n    return min(sdf1, sdf2);\n}\n\n// Transformations:\nvec3 Translate(in vec3 p, in vec3 t) {\n    return p - t;\n}\n\nvec3 Rotate(in vec3 p, in vec3 r) {\n    vec3 rad = radians(-r);\n    vec3 cosRad = cos(rad);\n    vec3 sinRad = sin(rad);\n\n    mat3 xRotation = mat3(1.0,      0.0,       0.0,\n                          0.0, cosRad.x, -sinRad.x,\n                          0.0, sinRad.x,  cosRad.x);\n\n    mat3 yRotation = mat3( cosRad.y, 0.0, sinRad.y,\n                                0.0, 1.0,      0.0,\n                          -sinRad.y, 0.0, cosRad.y);\n\n    mat3 zRotation = mat3(cosRad.z, -sinRad.z, 0.0,\n                          sinRad.z,  cosRad.z, 0.0,\n                               0.0,       0.0, 1.0);\n\n    return zRotation * yRotation * xRotation * p;\n}\n\n// Scene mapping function:\nfloat mapScene(in vec3 p) {\n    p = Rotate(p, vec3((iMouse.yx - 0.5 * iResolution.yx) * vec2(0.5, -0.5), 0.0));\n    float head = sdSphere(Translate(p, vec3(0.0, 442.5, 0.0)), 100.0);\n    float neck = sdCylinder(Translate(p, vec3(0.0, 337.5, 0.0)), 60.0, 55.0);\n    float torso = sdRoundedCuboid(Translate(p, vec3(0.0, 107.5, 0.0)), vec3(225.0, 300.0, 100.0), 50.0);\n    float rightShoulder = sdSphere(Translate(p, vec3(200.0, 257.5, 0.0)), 50.0);\n    float leftShoulder = sdSphere(Translate(p, vec3(-200.0, 257.5, 0.0)), 50.0);\n    float rightArm = Union(sdCylinder(Translate(p, vec3(200.0, 122.5, 0.0)), 275.0, 50.0), sdSphere(Translate(p, vec3(200.0, -15.0, 0.0)), 50.0));\n    float leftArm = Union(sdCylinder(Translate(p, vec3(-200.0, 122.5, 0.0)), 275.0, 50.0), sdSphere(Translate(p, vec3(-200.0, -15.0, 0.0)), 50.0));\n    float rightHip = sdSphere(Translate(p, vec3(100.0, -92.5, 0.0)), 50.0);\n    float leftHip = sdSphere(Translate(p, vec3(-100.0, -92.5, 0.0)), 50.0);\n    float rightLeg = Union(sdCylinder(Translate(p, vec3(100.0, -242.5, 0.0)), 300.0, 50.0), sdSphere(Translate(p, vec3(100.0, -392.5, 0.0)), 50.0));\n    float leftLeg = Union(sdCylinder(Translate(p, vec3(-100.0, -242.5, 0.0)), 300.0, 50.0), sdSphere(Translate(p, vec3(-100.0, -392.5, 0.0)), 50.0));\n    return SmoothUnion(head, SmoothUnion(neck, Union(SmoothUnion(Union(SmoothUnion(torso, Union(rightShoulder, leftShoulder), 50.0), Union(rightArm, leftArm)), Union(rightHip, leftHip), 20.0), Union(rightLeg, leftLeg)), 20.0), 20.0);\n}\n\n// Normal calculation function (using gradient):\nvec3 calculateNormal(in vec3 p) {\n    float gradientX = mapScene(p + GRADIENT_STEP.xyy) - mapScene(p - GRADIENT_STEP.xyy);\n    float gradientY = mapScene(p + GRADIENT_STEP.yxy) - mapScene(p - GRADIENT_STEP.yxy);\n    float gradientZ = mapScene(p + GRADIENT_STEP.yyx) - mapScene(p - GRADIENT_STEP.yyx);\n    return normalize(vec3(gradientX, gradientY, gradientZ));\n}\n\n// Material calculation functions:\nvec3 calculateAmbient(in vec3 p, in vec3 normal) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 calculateDiffuse(in vec3 p, in vec3 normal) {\n    return vec3(0.878, 0.675, 0.412);\n}\n\nvec3 calculateSpecular(in vec3 p, in vec3 normal) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\nfloat calculateShininess(in vec3 p, in vec3 normal) {\n    return 0.0;\n}\n\n// Raymarching loop:\nvec4 rayMarch(in vec3 ro, in vec3 rd) {\n    float distanceTraveled = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; ++iterations) {\n        vec3 currentPosition = ro + rd * distanceTraveled;\n        float distanceToClosest = mapScene(currentPosition);\n        if (distanceToClosest < MIN_HIT_DISTANCE) {\n            vec3 normal = calculateNormal(currentPosition);\n\n            // Illumination is calculated using the Phong illumination model.\n            vec3 materialAmbient = calculateAmbient(currentPosition, normal);\n            vec3 materialDiffuse = calculateDiffuse(currentPosition, normal);\n            vec3 materialSpecular = calculateSpecular(currentPosition, normal);\n            float materialShininess = calculateShininess(currentPosition, normal);\n\n            vec3 illuminationAmbient = materialAmbient * lightColor;\n            float lambertian = max(0.0, dot(normal, lightDirection));\n            vec3 illuminationDiffuse = lambertian * materialDiffuse * lightColor;\n            vec3 reflection = reflect(lightDirection, normal);\n            float specularAngle = max(0.0, dot(reflection, rd));\n            vec3 illuminationSpecular = pow(specularAngle, materialShininess) * materialSpecular * lightColor;\n\n            return vec4(illuminationAmbient + illuminationDiffuse + illuminationSpecular, 1.0);\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        distanceTraveled += distanceToClosest;\n    }\n\n    return vec4(backgroundColor, 1.0);\n}\n\n// Pixel shader output function:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 halfResolution = 0.5 * iResolution.xy;\n    vec2 xy = fragCoord - halfResolution;\n    vec3 rayOrigin = cameraPosition + cameraForward * cameraFocalLength;\n    vec3 rayDirection = normalize(rayOrigin - (cameraPosition - cameraRight * xy.x - cameraUp * xy.y));\n    fragColor = rayMarch(rayOrigin, rayDirection);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}