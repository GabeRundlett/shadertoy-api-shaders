{
    "Shader": {
        "info": {
            "date": "1513989935",
            "description": ".",
            "flags": 0,
            "hasliked": 0,
            "id": "lljcWK",
            "likes": 3,
            "name": "Squids",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "squid",
            "viewed": 1468
        },
        "renderpass": [
            {
                "code": "vec2 hash22(vec2 p)\n{\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\n#define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nvec4 hash44(vec4 p)\n{\n\tvec4 p4 = fract(p * HASHSCALE4);\n    p4 += dot(p4.wzxy, p4+19.19);\n    return fract(vec4(p4.x * p4.y, p4.x*p4.z, p4.y*p4.w, p4.x*p4.w));\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) {\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat tntl(vec3 q, vec4 h) {\n    q.y += .8;\n    const float an = 6.28 / 8.;\n    const mat2 inc = mat2( cos(an),sin(an),-sin(an),cos(an));\n    \n\tfloat fa = (atan(q.z,q.x)+an*0.52)/an;\n    float ia = floor( fa );\n    \n    float sym = an*ia;\n    vec2 r = mat2(cos(sym),-sin(sym),\n                  sin(sym), cos(sym))*q.xz;\n        \n    if( fract(fa)>0.0 ) r = r*inc; // rotate one backwards\n\n    float d = 2.0 + length(q);\n    for( int i=0; i<2; i++ )\n    {        \n        vec2 p = (r - vec2(0.5,0.0));\n\t\tvec4 hh = hash43(vec3(h.xy, ia));\n        d = sdCapsule(vec3(p.x, q.y, p.y), \n                      vec3(0.),\n                      vec3(sin(q.y*4.+iTime*0.5+hh.x*30.)*0.2+1., \n                           -2.8,\n                           cos(q.y*.5)*0.1), \n                      .12);\n        \n        r = inc*r;\n\t}\n    return d;\n}\n\nmat2 rot2(float t) { return mat2(cos(t), -sin(t), sin(t), cos(t)); }\n\nfloat map(vec3 pos) {\n    pos.y -= 4.;\n    vec4 h = hash43(floor(pos/16.));\n    pos = mod(pos, 16.) - 8.;\n    h.xyz = h.xyz*2.-1.;\n    pos += (h.xyz)*2.;\n    pos.xy *= rot2(h.x);\n    pos.yz *= rot2(h.y);\n    pos.xz *= rot2(h.z);\n    pos.y += sin(iTime*.7+h.w*30.)*0.1;\n    float mantle =\n        max(sdEllipsoid(pos, vec3(1., 2., 1.)), \n               -sdEllipsoid(pos-vec3(0.0, -2.25, 0.0), vec3(1., 2., 1.)));\n    mantle = smin(mantle,\n                 sdEllipsoid(pos-vec3(0.0, 2.2, 0.0), \n                             vec3(.36, .8, .45+abs(sin(pos.y))*.4)), \n                  .1);\n    vec3 ep = pos;\n    ep.z = abs(ep.z);\n    ep-=vec3(.5, -.45, 0.5);\n    float eyes = length(ep)-0.4;\n    mantle = smin(mantle, eyes,.1);\n    return min(mantle, tntl(pos, h)*0.7);\n}\n\nvec3 norm(vec3 pos) {\n\tvec2 e = vec2(0.01, 0.0);\n    return normalize(vec3(\n        map(pos+e.xyy)-map(pos-e.xyy),\n        map(pos+e.yxy)-map(pos-e.yxy),\n        map(pos+e.yyx)-map(pos-e.yyx)));\n}\n\nfloat intersect(vec3 ro, vec3 rd) {\n    float t = 0.;\n\n    for(int i = 0; i < 128; ++i) {\n        float h = map(ro+rd*t);\n        if(h < 0.001 || t>100.) break;\n        t += h;\n    }\n    return t;\n}\n\nconst vec3 lig = normalize(vec3(0.2, .8, 0.));\n\nconst vec3 lc = vec3(0.5, 0.6, 0.65);\n\nvec3 shade(float t, vec3 p, vec3 rd) {\n    vec3 n = norm(p);\n    float sha = intersect(p+0.05*n, lig) < 10. ? 0. : 1.;\n    vec3 matCol = vec3(0.2, 0.1, 0.15);\n    vec3 col = matCol*lc*clamp(dot(n, lig), 0.0, 1.0)*sha;\n    col += matCol*(1.-lc)*(n.y*0.5+0.5)*0.1;\n    col += matCol*pow(clamp(dot(n, normalize(rd+lig)), 0., 1.),2.);\n\treturn col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    vec2 a = (iMouse.xy/iResolution.xy)*6.2-3.1+vec2(3.1,0.);\n    vec3 LA = vec3(sin(iTime*0.1)*3., -0.6+cos(iTime*0.2)*0.2, iTime*0.2),\n        ro = LA + vec3(cos(a.x), sin(a.y), sin(a.x))*6.,\n        c = vec3(0.0,0.01,0.0),sp;\n    \n    vec3 f = normalize(LA-ro),\n        r = normalize(vec3(f.z, 0., -f.x)),\n        u = cross(f, r),\n        rd = normalize(f + uv.x*r + uv.y*u);\n    \n    float t = intersect(ro, rd);\n    vec3 col = vec3(0.0, 0.0, rd.y*0.1+0.1);\n    \n    \n    if(t < 100.) {\n        vec3 p = ro + rd*t;\n        col += shade(t,p,rd) * 20./t;\n    }\n    \n    float v = pow(.95-length(uv), 0.8);\n\tfragColor = vec4(pow(col * v, vec3(0.4545)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}