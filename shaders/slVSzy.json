{
    "Shader": {
        "info": {
            "date": "1641479985",
            "description": "This shader implements of a \"deterministic\" ray tracer (as contrary to MC). It was used for educational purpose only. It is close to a Whitted Path Tracer. It obviously misses the refraction part to keep the code simple.",
            "flags": 0,
            "hasliked": 0,
            "id": "slVSzy",
            "likes": 10,
            "name": "Deterministic Ray Tracer",
            "published": 3,
            "tags": [
                "raytracer",
                "whitted"
            ],
            "usePreview": 0,
            "username": "stack_overflow",
            "viewed": 583
        },
        "renderpass": [
            {
                "code": "// Simple Deterministic Ray Tracer\n// ================================\n//\n// This shadertoy renders a simplistic scene using a deterministic ray tracing\n// technique. It is close to a Whitted Ray but lacks refractions. Due to\n// limitation of GLSL, it is not trivial to implement a recursion needed in\n// such a ray tracer. While workaround may be possible, that would over\n// complicate the code.\n//\n// In fact, the main intent for this code was to showcase the basics of ray\n// tracing for educational purposes and KISS.\n\n\n#define T_MIN 0.01\n#define T_MAX 1000.0\n#define N_BOUNCES 5\n\n\nstruct ray \n{\n    vec3 origin;\n    vec3 direction;\n};\n\n\nstruct hit_rec \n{\n  vec3 position;\n  vec3 normal;\n  float dist;\n  int diff;\n  vec2 uv;\n};\n\n\n// ----------------------------------------------------------------------------\n// Materials\n// ----------------------------------------------------------------------------\n\n#define DIFF_GREEN        0\n#define DIFF_YELLOW       1\n#define DIFF_CHECKERBOARD 2\n\n\nbool checkerboard(in vec2 uv, float cols, float lines)\n{\n    uv = vec2(cols, lines) * uv;\n    \n    return (mod(uv.x + floor(mod(uv.y, 2.0)), 2.0) < 1.0);\n}\n\n\nvec3 eval_diffuse(in hit_rec rec) {\n    switch (rec.diff) {\n        case DIFF_GREEN:  return vec3(0.0, 0.8, 0.0);\n        case DIFF_YELLOW: return vec3(0.8, 0.8, 0.0);\n        case DIFF_CHECKERBOARD:\n            if (checkerboard(rec.uv, 6., 6.)) {\n                return vec3(.8, 0., 0.);\n            } else {\n                return vec3(.8);\n            }\n        default: return vec3(0.);\n    }\n}\n\n\n// ----------------------------------------------------------------------------\n// Hit functions and Geometry\n// ----------------------------------------------------------------------------\n\n// Sphere\n\nstruct sphere\n{\n    vec3 center;\n    float radius;\n    int diff;\n};\n\n\nbool hit_sphere(in sphere s, in ray r, out hit_rec rec)\n{\n\tvec3 l = s.center - r.origin;\n    float u = dot(l, r.direction);\n    float l_sqr = dot(l, l);\n    float r_sqr = s.radius*s.radius;\n    \n    // No hit found so far\n    rec.dist = -1.0;\n    \n    if (u < 0.0 && l_sqr > r_sqr) {\n        return false;\n    }\n    \n    float m_sqr = l_sqr - u*u;\n    \n    if (m_sqr > r_sqr) {\n        return false;\n    }\n    \n    // Hit found\n    float q = sqrt(r_sqr - m_sqr);\n    \n    if (l_sqr > r_sqr) {\n        // outside\n        rec.dist = u - q;\n        rec.position = r.origin + rec.dist*r.direction;\n    \trec.normal   = normalize(rec.position - s.center);\n    } else {\n        // inside\n        rec.dist = u + q;\n        rec.position = r.origin + rec.dist*r.direction;\n    \trec.normal   = normalize(s.center - rec.position);\n    }\n    \n    rec.diff = s.diff;\n    \n    return true;\n}\n\n\n// ----------------------------------------------------------------------------\n\n// Triangle\n\nstruct triangle \n{\n    vec3 a, b, c;\n    vec2 uv_a, uv_b, uv_c;\n   \tint diff;\n};\n\n\nbool hit_triangle(in triangle t, in ray r, out hit_rec rec) \n{\n\tvec3 e1 = t.b - t.a;\n    vec3 e2 = t.c - t.a;\n    vec3 q = cross(r.direction, e2);\n    float a = dot(e1, q);\n    \n    // No hit found so far\n    rec.dist = -1.0;\n    \n    if (a < T_MIN) {\n        return false;\n    }\n    \n    float f = 1. / a;\n    vec3 s = r.origin - t.a;\n    float u = f * dot(s, q);\n    \n    if (u < 0. || u > 1.) {\n        return false;\n    }\n    \n    vec3 rt = cross(s, e1);\n    float v = f * dot(r.direction, rt);\n    \n    if (v < 0.0 || (u + v) > 1.0) {\n        return false;\n    }\n    \n    float w = (1. - u - v);\n\n    // Hit found\n    rec.dist     = f * dot(e2, rt);\n    rec.position = r.origin + rec.dist*r.direction;\n    rec.normal   = normalize(cross(e1, e2));\n    rec.diff = t.diff;\n    rec.uv = u * t.uv_b + v * t.uv_c + w * t.uv_a;\n    \n    return true;\n}\n\n\n// ----------------------------------------------------------------------------\n// Scene definition\n// ----------------------------------------------------------------------------\n\n// Lighting\n\nvec3 ambiant = vec3(0.01, 0.01, 0.05);\n\n\nstruct light\n{\n    vec3 position;\n    vec3 power;\n};\n\n\nconst int n_lights = 1;\n\nlight[1] lights = light[](\n     light(vec3(-3, 3., 1.), vec3(15.))\n);\n\n\n// ----------------------------------------------------------------------------\n\n// Geometry\n\nconst int n_spheres = 2;\n\nsphere[2] spheres = sphere[](\n    //           Center             radius     diffuse\n    sphere(vec3(-0.125, 0.25, 0.35),  0.25,  DIFF_GREEN),\n    sphere(vec3( 0.18,  0.25, -0.12), 0.25,  DIFF_YELLOW)    \n);\n\n\nconst int n_triangles = 2;\n\ntriangle[2] triangles = triangle[](\n    triangle(\n        // Coords\n        vec3(-1., 0., -1.), \n        vec3(-1., 0.,  1.),\n        vec3( 1., 0., -1.),\n        // uv\n        vec2(0, 0),\n        vec2(1, 0),\n        vec2(0, 1),\n        // Diffuse\n        DIFF_CHECKERBOARD\n    ),\n    triangle(\n        // Coords\n        vec3(-1., 0.,  1.),\n        vec3( 1., 0.,  1.), \n        vec3( 1., 0., -1.),\n        // uv\n        vec2(1, 0),\n        vec2(1, 1),\n        vec2(0, 1),\n        // Diffuse\n        DIFF_CHECKERBOARD\n    )\n);\n\n\n// ----------------------------------------------------------------------------\n// Ray tracing\n// ----------------------------------------------------------------------------\n\n// Hit function to check if a ray hit something in the scene\nbool hit(in ray r_in, inout hit_rec rec) \n{\n    hit_rec curr_rec;\n    rec.dist = -1.;\n    \n    bool hit_found = false;\n    \n    // Find closest sphere intersection\n    for (int i = 0; i < n_spheres; i++) {\n        if (   hit_sphere(spheres[i], r_in, curr_rec) \n            && (curr_rec.dist < rec.dist || rec.dist < 0.)) {\n            rec = curr_rec;\n            hit_found = true;\n        }\n    }\n\n    // Find closest triangle intersection\n    for (int i = 0; i < n_triangles; i++) {\n        if (   hit_triangle(triangles[i], r_in, curr_rec)\n            && (curr_rec.dist < rec.dist || rec.dist < 0.)) {\n            rec = curr_rec;\n            hit_found = true;\n        }  \n    }\n    \n    return hit_found;\n}\n\n\n// Trace ray and return the resulting contribution of this ray\nvec3 trace_ray(in ray r, in int n_bounces)\n{\n    hit_rec rec;\n    \n    vec3 ret_col = vec3(0.);\n    vec3 attenuation = vec3(1.);\n    \n    for (int i = 0; i < n_bounces; i++) {\n        if (hit(r, rec)) {\n            // get the diffuse color\n            vec3 diffuse = eval_diffuse(rec);\n                \n            for (int l = 0; l < n_lights; l++) {\n                vec3 light_dir = lights[i].position - rec.position;\n                float light_dist = length(light_dir);\n\n                light_dir = normalize(light_dir);\n\n                // check if in shade: launch a ray from the lightsource to the sphere\n                ray shadow_ray = ray(lights[i].position, -light_dir);\n\n                hit_rec shadow_ray_rec;\n                hit(shadow_ray, shadow_ray_rec);\n\n                if (shadow_ray_rec.dist > light_dist - T_MIN) {\n                    // BRDF: the geometry is directly light by the lightsource\n                    float lambert = max(0., dot(light_dir, rec.normal));\n                    vec3 light_power = lights[i].power / (light_dist * light_dist);\n                    ret_col += attenuation * diffuse * lambert * light_power;\n                }\n            }\n            \n            // Ambiant lighting, always affecting the hitpoint\n            ret_col += attenuation * ambiant * diffuse;\n            \n            // Generate the reflected ray\n            r.direction = normalize(reflect(r.direction, rec.normal)); \n            r.origin = rec.position + r.direction * 5. * T_MIN;\n            \n            // Compute the Fresnel term using Schlick's approximation\n            float n1 = 1.;\n            float n2 = 2.1;\n            float r0 = (n1 - n2)/(n1 + n2);\n            r0 = r0*r0;\n            float fresnel = r0 + (1. - r0) * pow(1. - dot(rec.normal, r.direction), 5.);\n            \n            attenuation *= fresnel;\n        } else {\n            // No hit found, use the background instead\n            ret_col += attenuation * ambiant;\n            break;\n        }\n    }\n    \n    return ret_col;\n}\n\n\n// ----------------------------------------------------------------------------\n// Camera\n// ----------------------------------------------------------------------------\n\nstruct camera \n{\n  \tvec3 look_from;\n  \tvec3 look_at;\n    vec3 up;\n    float fov;\n    float aspect;\n};\n\n\n// Generate a primary ray\nray get_ray(in camera c, in vec2 uv) \n{\n\tfloat theta = c.fov * 3.14/180.0;\n    float h_height = tan(theta/2.0);\n    float h_width = c.aspect * h_height;\n    \n    vec3 w = normalize(c.look_from - c.look_at);\n    vec3 u = normalize(cross(c.up, w));\n    vec3 v = normalize(cross(w, u));\n    \n    vec3 ll = c.look_from - h_width*u - h_height*v - w;\n    vec3 horizontal = 2.0 * h_width * u;\n    vec3 vertical   = 2.0 * h_height * v;\n    \n    return ray(\n        c.look_from, \n        normalize(ll + uv.x*horizontal + uv.y*vertical - c.look_from)\n    );\n}\n\n\n// ----------------------------------------------------------------------------\n// Main image\n// ----------------------------------------------------------------------------\n\n// linear sRGB to gamma corrected sRGB\nfloat to_sRGB(in float c) {\n    if (abs(c) < 0.0031308) {\n        return c * 12.92;\n    } else {\n     \treturn 1.055 * pow(c, 1./2.4) - 0.055;        \n    }    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Rotate the camera around\n\n    vec3 look_from = vec3(0., 1., 2.);\n    \n    float theta = iTime / 3.;\n    \n    mat3 rot = mat3(\n        cos(theta), 0., -sin(theta),\n        0., 1., 0.,\n        -sin(theta), 0., cos(theta));\n        \n    look_from = rot * look_from;\n    \n    camera cam = camera(\n        look_from,        // Look-from\n        vec3(0., 0., 0.), // Look-at\n        vec3(0., 1., 0.), // Up\n        35.,              // fov: 2.0*atan(sensor_width/(2.0*focal_length))\n        iResolution.x/iResolution.y\n    );\n    \n    // Generate a primary ray\n    ray r = get_ray(cam, uv);\n    \n    // Trace this ray\n    vec3 col = trace_ray(r, N_BOUNCES);\n    \n    // Linear to gamma corrected sRGB\n    for (int i = 0; i < 3; i++) {\n        col[i] = to_sRGB(col[i]);\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}