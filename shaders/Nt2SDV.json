{
    "Shader": {
        "info": {
            "date": "1628674629",
            "description": "practice on line drawing and the ways to smooth them, for curved lines i used the tech from IQ's article:\nhttps://iquilezles.org/articles/distance/\nThe origin idea is from one picture on https://thebookofshaders.com/05",
            "flags": 0,
            "hasliked": 0,
            "id": "Nt2SDV",
            "likes": 16,
            "name": "animated lines",
            "published": 3,
            "tags": [
                "line",
                "sin",
                "cos",
                "animation"
            ],
            "usePreview": 0,
            "username": "jcyuan",
            "viewed": 637
        },
        "renderpass": [
            {
                "code": "#define PI 3.141592653589793\n\nconst float CYCLE = 2.;\nconst float R = .35;\nconst float CenterX = .65;\nconst float PadRight = .15;\nconst vec3 GreyColor = vec3(.8);\n\nfloat circle(in vec2 p, in float r, bool solid) {\n     float d = length(p) - r;\n     return solid ? d : abs(d);\n}\nfloat circle(in vec2 p, in float r) {\n    return circle(p, r, false);\n}\n\nfloat line(in vec2 p, in vec2 p0, in vec2 p1, bool solid) {\n    vec2 pa = p - p0, ba = p1 - p0;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    float d = length(pa - ba * h);\n    return solid ? d : abs(d);\n}\nfloat line(in vec2 p, in vec2 p0, in vec2 p1) {\n    return line(p, p0, p1, false);\n}\n\nfloat box(in vec2 p, in vec2 b, bool solid) {\n    vec2 d = abs(p) - b;\n    float s = length(max(d, 0.)) + min(max(d.x, d.y), 0.);\n    return solid ? s : abs(s);\n}\nfloat box(in vec2 p, in vec2 b) {\n    return box(p, b, false);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n    float fw = length(fwidth(uv));\n    float DotSize = fw * 1.5;\n    \n    float CS = cos(iTime * CYCLE);\n    float SS = sin(iTime * CYCLE);\n    \n    float rightArea = step(uv.x, CenterX);\n    vec3 col = vec3(0.);\n    \n    float d = 0.;\n    \n    float axis = min(line(uv, vec2(-5., 0.), vec2(5., 0.)), line(uv, vec2(CenterX, -5.), vec2(CenterX, 5.)));\n    d = axis;\n    \n    vec2 offset = (vec2(CenterX, 0.) + PadRight + R) * vec2(-1., 1.);\n    vec2 circlePos = uv + offset;\n    float mainCircle = circle(circlePos, R);\n    d = min(mainCircle, d);\n    \n    vec2 posOnCircle = vec2(CS, SS) * R - offset;\n    \n    float circleDot = circle(circlePos, DotSize, true);\n    float circleDot2 = circle(posOnCircle - uv, DotSize, true);\n    d = min(circleDot, d);\n    d = min(circleDot2, d);\n    \n    float pointerLine = line(uv, -offset, posOnCircle);\n    d = min(pointerLine, d);\n    \n    float xLine = line(uv, posOnCircle, vec2(posOnCircle.x, 0.));\n    float yLine = line(uv, posOnCircle, vec2(CenterX, posOnCircle.y));\n    d = min(xLine, d);\n    d = min(yLine, d);\n    float xLineDot = circle(uv - vec2(posOnCircle.x, 0.), DotSize, true);\n    float yLineDot = circle(uv - vec2(CenterX, posOnCircle.y), DotSize, true);\n    d = min(xLineDot, d);\n    d = min(yLineDot, d);\n    \n    col = vec3(smoothstep(-fw, fw, d));\n    \n    float maskBox = box(uv - vec2(CenterX - 2., .5), vec2(2., .5), true);\n    maskBox = min(maskBox, box(uv - vec2(-2., -.5), vec2(4., .5), true));\n    vec2 centerPos = uv - vec2(CenterX, 0.);\n    float quatCircle1 = circle(centerPos, PadRight);\n    float quatCircle2 = circle(centerPos, PadRight + R);\n    float quatCircle3 = circle(centerPos, PadRight + R * 2.);\n    float qd = max(quatCircle1, -maskBox);\n    qd = min(max(quatCircle2, -maskBox), qd);\n    qd = min(max(quatCircle3, -maskBox), qd);\n    \n    col = mix(GreyColor, col, smoothstep(-fw, fw, qd));\n    \n    float cs01 = CS * .5 + .5;\n    float csY = cs01 * R * 2.;\n    float animCircle = circle(centerPos, PadRight + csY);\n    float qd2 = max(animCircle, -maskBox);\n    float yLineDot2 = circle(uv - vec2(CenterX, PadRight + csY), DotSize, true);\n    qd2 = min(yLineDot2, qd2);\n    \n    col *= smoothstep(-fw, fw, qd2);\n    \n    vec2 wave = vec2(\n        sin((uv.x - CenterX) / R + iTime * CYCLE) * R,\n        cos((uv.x - CenterX) / R + iTime * CYCLE) * R\n    );\n    vec2 dWave = wave.yx / R;\n    vec2 baseY = vec2(uv.y + R + PadRight, uv.y - R - PadRight);\n    // https://iquilezles.org/articles/distance\n    vec2 waveLines = 1. - smoothstep(fw, -fw, abs(wave - baseY) / sqrt(1. + dWave * dWave)) * rightArea;\n    vec3 waveColor = vec3(waveLines.x * waveLines.y);\n    \n    col *= waveColor;\n    \n    float maskBar = box(vec2(-5., uv.y - PadRight - R), vec2(5. + CenterX, R), true);\n    maskBar = min(maskBar, box(vec2(-5., uv.y + PadRight + R), vec2(5. + CenterX, R), true));\n    maskBar = min(maskBar, box(vec2(uv.x - CenterX * 2., uv.y), vec2(CenterX, PadRight), true));\n    float timeCycle = iTime * CYCLE * R;\n    float gridMoveTime = rightArea * timeCycle;\n    vec2 grid = 1. - smoothstep(fw, 0., vec2(\n            mod(uv.x - CenterX - PadRight * (1. - rightArea) + gridMoveTime, mix(R, R * PI * .5, rightArea)),\n            mod(abs(uv.y) - PadRight, R)\n        )\n    ) * smoothstep(fw, -fw, maskBar) * smoothstep(fw, -fw, maskBox);\n    \n    col *= mix(GreyColor, col, grid.x * grid.y);\n    \n    fragColor = vec4(col, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}