{
    "Shader": {
        "info": {
            "date": "1656082245",
            "description": "windy day\nI'm looking for a more efficient way to do this.",
            "flags": 0,
            "hasliked": 0,
            "id": "sdtfzH",
            "likes": 9,
            "name": "windy day",
            "published": 3,
            "tags": [
                "wind"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 236
        },
        "renderpass": [
            {
                "code": "#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat SK = 0.03;\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat barX(vec2 uv, float w){\n    uv.x -= clamp( uv.x, -w, w );\n    float d = length(uv)-0.02;\n    return d;\n}\n\nfloat barY(vec2 uv, float h){\n    uv.y -= clamp( uv.y, -h, h );\n    float d = length(uv)-0.02;\n    return d;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nfloat circle(vec2 uv, float dir) {\n    vec2 prevUV = uv;\n    float d = 1.0;\n    \n    float w[9] = float[](\n        0.09,\n        0.17,\n        0.21,\n        0.23,\n        0.25,\n        0.23,\n        0.21,\n        0.17,\n        0.09\n    );\n    \n    for(float i = 0.; i<float(w.length()); i++){\n        uv = prevUV;      \n        \n        uv.x+=dir*sin(dir*iTime*(dir*20.5)+i)*(0.01+(i*0.001));\n        uv.y+=(i*0.045);\n                  \n        uv*=Rot(radians(sin(iTime*(dir*30.0)+i)*5.0+i));\n        \n        float d2 = barX(uv,w[int(i)]);\n        d = smin(d,d2,SK);\n    }\n    return d;\n}\n\nfloat bg(vec2 uv, float dir, float num){\n    vec2 prevUV = uv;\n    float d = 1.0;\n    \n    for(float i = 1.; i<=num; i++){\n        uv = prevUV;      \n       \n        uv.x+=dir*sin(dir*iTime*(dir*20.5)+i)*(0.01+(i*0.001));\n        uv.y+=(i*0.045);\n                  \n        uv*=Rot(radians(sin(iTime*(dir*sin(i)*30.0)+i)));\n        \n        float d2 = barX(uv,0.85);\n        d = smin(d,d2,SK);\n    }\n    return d;\n}\n\nfloat triangle(vec2 uv, float dir, float h, float w) {\n    vec2 prevUV = uv;\n    float d = 1.0;\n    \n    for(float i = 1.; i<h; i++){\n        uv = prevUV;      \n        \n        uv.x+=dir*sin(dir*iTime*(dir*20.5)+i)*(0.01+(i*0.001));\n        uv.y+=(i*0.045);\n                  \n        uv*=Rot(radians(sin(2.*iTime*(dir*sin(i)*30.0))*sin(i*0.5)*5.0));\n        \n        float d2 = barX(uv,i*w);\n        d = smin(d,d2,SK);\n    }\n    return d;\n}\n\n\nfloat cloud(vec2 uv, float dir, float h) {\n    vec2 prevUV = uv;\n    float d = 1.0;\n    \n    for(float i = 1.; i<=h; i++){\n        uv = prevUV;      \n        \n        uv.x+=dir*sin(dir*iTime*(dir*20.5)+i)*(0.01+(i*0.001));\n        uv.y+=(i*0.045);\n                  \n        uv*=Rot(radians(sin(2.*iTime*(dir*sin(i)*30.0))*sin(i*0.5)*5.0));\n        \n        float d2 = barX(uv,sin(i*0.5+0.5)*0.17);\n        d = smin(d,d2,SK);\n    }\n    return d;\n}\n\nvec3 tree(vec2 uv, vec3 col, float dir){\n    vec2 prevUV = uv;\n    uv.y+=0.27;\n    uv*=Rot(radians(2.*sin(iTime*(dir*20.0))*3.0));\n    float d = barY(uv,0.2);\n    col=mix(col,vec3(0.3,0.3,0.2),S(d,0.0)); \n    \n    uv = prevUV;\n    d = triangle(uv,dir, 6., 0.03);\n    uv.y+=0.15;\n    float d2 = triangle(uv,dir, 6., 0.03);\n    d = smin(d,d2,SK);\n    col=mix(col,mix(vec3(0.5,0.8,0.5),vec3(0.3,0.4,0.3),uv.y*-3.),S(d,0.0)); \n    return col;\n}\n\nvec3 treeSmall(vec2 uv, vec3 col, float dir){\n    vec2 prevUV = uv;\n    uv.y+=0.42;\n    uv*=Rot(radians(2.*sin(iTime*(dir*20.0))*3.0));\n    float d = barY(uv,0.1);\n    col=mix(col,vec3(0.4,0.4,0.3),S(d,0.0)); \n    \n    uv = prevUV;\n    uv.y+=0.2;\n    d = triangle(uv,dir, 6., 0.03);\n    col=mix(col,mix(vec3(0.3,0.9,0.3),vec3(0.3,0.4,0.3),uv.y*-3.),S(d,0.0)); \n    return col;\n}\n\nvec3 grass(vec2 uv, vec3 col, float dir){\n    vec2 prevUV = uv;\n    float d = 1.0;\n    \n    for(float i = 1.; i<=6.; i++){\n        uv = prevUV;      \n        \n        uv.x+=(i*0.05);        \n        uv*=Rot(radians(sin(2.*iTime*(dir*sin(i)*30.0))*10.0));\n        \n        float d2 = barY(uv,0.03+sin(i)*0.01);\n        d = smin(d,d2,SK);\n    }\n    col=mix(col,mix(vec3(0.1,0.2,0.1),vec3(0.3,0.4,0.3),uv.y*-10.),S(d,0.0)); \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    \n    float glitchBlock = 30.0;\n    vec2 uv2 = fract(uv*glitchBlock)-0.5;\n    vec2 id = floor(uv2);\n    \n    vec2 n2 = fract(sin(id*123.456)*789.125);\n    n2+=dot(id.x,id.y*567.89);\n    \n    float glitchDist = 0.02;\n    float glitchTime = iTime*10.0;\n    uv.x-=(fract(floor(uv.y+n2.y*glitchBlock)*glitchTime)*glitchDist);\n    uv.x+=sin(floor(uv.y*glitchBlock*10.0)*iTime*30.)*0.01;\n    \n    \n    vec2 prevUV = uv;\n    \n    vec3 col = vec3(1.0);\n    \n    uv.y-=0.52;\n    float d = bg(uv,-1.0,19.);\n    col=mix(col,mix(vec3(0.6,0.8,1.0),vec3(0.5,0.9,1.0),uv.y),S(d,0.0));\n    uv = prevUV;\n    \n    uv.y+=0.35;\n    d = bg(uv,1.0,3.);\n    col=mix(col,mix(vec3(0.6,0.3,0.2),vec3(0.3,0.2,0.1),uv.y*10.0),S(d,0.0));\n    \n    uv = prevUV;\n    uv.x-=0.45;\n    uv.y-=0.45;\n    d = circle(uv,1.0);\n    col=mix(col,mix(vec3(0.9,0.83,0.63),vec3(0.7,0.7,0.6),uv.y*20.0),S(d,0.0));    \n    uv = prevUV;\n    \n    uv.x+=iTime*0.2;\n    uv.x = mod(uv.x,2.0)-1.;\n    d = triangle(uv,1.0, 9., 0.05);\n    col=mix(col,mix(vec3(0.2,0.4,0.2),vec3(0.1,0.3,0.1),uv.y*10.0),S(d,0.0));    \n    uv = prevUV;\n    \n    uv.x+=iTime*0.2;\n    uv.x-=1.35;\n    uv.x = mod(uv.x,2.0)-1.;\n    uv.y+=0.03;\n    d = triangle(uv,-1.2, 8., 0.05);\n    col=mix(col,mix(vec3(0.2,0.3,0.2),vec3(0.1,0.2,0.1),uv.y*5.0),S(d,0.0));    \n    uv = prevUV;      \n    \n    uv.x+=iTime*0.2;\n    uv.x-=0.9;\n    uv.x = mod(uv.x,2.0)-1.;\n    uv.y+=0.13;\n    d = triangle(uv,1.3, 6., 0.05);\n    col=mix(col,mix(vec3(0.2,0.5,0.2),vec3(0.1,0.2,0.1),uv.y*4.0)*0.8,S(d,0.0));    \n    uv = prevUV;       \n    \n    uv.x+=iTime*0.2;\n    uv.x-=0.5;\n    uv.x = mod(uv.x,2.0)-1.;\n    uv.y+=0.1;\n    d = triangle(uv,-1.0, 7., 0.05);\n    col=mix(col,mix(vec3(0.2,0.6,0.2),vec3(0.1,0.2,0.1),uv.y*3.0)*0.8,S(d,0.0));    \n    uv = prevUV;    \n    \n    uv.x+=iTime*0.25;\n    uv.x = mod(uv.x,1.6)-0.8;\n    uv.y-=0.45;\n    d = cloud(uv,-1.2, 4.);\n    col=mix(col,mix(vec3(0.88),vec3(0.5),uv.y*2.0),S(d,0.0)); \n    uv.x-=0.2;\n    uv.y-=0.05;\n    d = cloud(uv,1.2, 3.);\n    col=mix(col,mix(vec3(0.92),vec3(0.6),uv.y),S(d,0.0));\n    uv.x-=0.4;\n    uv.y+=0.28;\n    uv.x*=1.6;\n    d = cloud(uv,-1.3, 3.);\n    col=mix(col,mix(vec3(0.92),vec3(0.6),uv.y*-3.0),S(d,0.0));  \n    uv = prevUV;    \n    \n    uv*=2.0;\n    uv.x+=iTime*0.3;\n    uv.x = mod(uv.x,1.2)-0.6;\n    uv.y+=0.4;\n    col = tree(uv,col,1.0);\n    uv = prevUV;    \n    \n    uv*=2.0;\n    uv.x+=iTime*0.3;\n    uv.x +=0.5;\n    uv.x = mod(uv.x,1.2)-0.6;\n    uv.y+=0.4;\n    col = treeSmall(uv,col,-1.1);\n    uv = prevUV; \n    \n    uv.x+=iTime*0.3;\n    uv.x = mod(uv.x,0.6)-0.3;\n    uv.y+=0.5;\n    col = grass(uv,col,1.0);\n    \n    uv.x+=iTime*2.0;\n    col+=Hash21(uv*100.0)*0.3;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}