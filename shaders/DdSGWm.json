{
    "Shader": {
        "info": {
            "date": "1697181049",
            "description": "voxel traversal",
            "flags": 0,
            "hasliked": 0,
            "id": "DdSGWm",
            "likes": 1,
            "name": "voxel_traversal",
            "published": 3,
            "tags": [
                "voxel",
                "traversal"
            ],
            "usePreview": 0,
            "username": "danzabarr",
            "viewed": 137
        },
        "renderpass": [
            {
                "code": "\nconst int MAX_STEPS = 100;\nconst int SIZE = 8;\n\n\nint blocks[SIZE * SIZE * SIZE] = int[SIZE * SIZE * SIZE]\n(\n    1,1,1,1,1,1,1,1, \n    0,0,0,0,0,0,0,1, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0,\n    \n    1,1,1,1,1,1,1,1, \n    0,0,0,0,0,0,0,1, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0,\n    \n    1,1,1,1,1,1,1,1, \n    0,0,0,0,0,0,0,1, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0,\n    \n    1,1,1,1,1,1,1,1, \n    0,0,0,0,0,0,0,1, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0,\n    \n    1,1,1,1,1,1,1,1, \n    0,0,0,0,0,0,0,1, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0,\n    \n    1,1,1,1,1,1,1,1, \n    0,0,0,0,0,0,0,1, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0,\n    \n    1,1,1,1,1,1,1,1, \n    0,0,0,0,0,0,0,1, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0,\n    \n    1,1,1,1,1,1,1,1, \n    0,0,0,0,0,0,0,1, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0\n    \n   \n    \n    \n);\n\n\n\nstruct Result {\n\n    vec3 position;\n    vec3 cell;\n    vec3 normal;\n    float depth;\n    int block_id;\n};\n\n    \nfloat Frac0(float x)\n{\n    return x - floor(x);\n}\n\nfloat Frac1(float x)\n{\n    return 1. + ceil(x) - x;\n}\n\nvec3 color(int block_id)\n{\n\n    if (block_id == 1) return vec3(1, 0, 0);\n    if (block_id == 2) return vec3(0, 1, 0);\n    if (block_id == 3) return vec3(0, 0, 1);\n\n    return vec3(0);\n}\n    \n\n\nint getBlock(int x, int y, int z)\n{\n    if (x < 0 || x >= SIZE)\n        return 0;\n    if (y < 0 || y >= SIZE)\n        return 0;\n    if (z < 0 || z >= SIZE)\n        return 0;\n\n    int index = (x + y * SIZE + z * SIZE * SIZE);\n    \n    return blocks[index];\n}\n\nint setBlock(int x, int y, int z, int block_id)\n{\n    if (x < 0 || x >= SIZE)\n        return -1;\n    if (y < 0 || y >= SIZE)\n        return -1;\n    if (z < 0 || z >= SIZE)\n        return -1;\n\n    int index = (x + y * SIZE + z * SIZE * SIZE);\n    \n    int old_id = blocks[index];\n\n    blocks[index] = block_id;\n    \n    return old_id;\n}\n\nfloat intbound(float s, float ds) \n{\n\n    if (ds < 0. && abs(round(s) - s) < 0.0001)\n        return 0.;\n\n    if (ds > 0.)\n        return (1. + ceil(s) - s) / abs(ds);\n    else\n        return (s - floor(s)) / abs(ds);\n}\n\nvec3 intbound(vec3 s, vec3 ds)\n{\n    return vec3\n    (\n        intbound(s.x, ds.x),\n        intbound(s.y, ds.y),\n        intbound(s.z, ds.z)\n    );\n}\n\n\nResult voxelTraversal(vec3 ro, vec3 rd)\n{\n    \n    vec3 tMax, tDelta;\n    vec3 cell = floor(ro);\n    vec3 st = sign(rd);\n    vec3 normal;\n\n    tDelta = st / rd;\n    tMax = intbound(ro, rd);\n    \n    cell = floor(ro);\n    float depth = 0.;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 pos = ro + rd * depth;\n        int block_id = getBlock(int(cell.x), int(cell.y), int(cell.z));\n\n        if (block_id != 0)\n            return Result(pos, cell, normal, depth, block_id);\n        \n        depth = min(tMax.x, min(tMax.y, tMax.z));\n\n        \n        if (tMax.x < tMax.y)\n        {\n        \n            if (tMax.x < tMax.z)\n            {\n                tMax.x += tDelta.x;\n                cell.x += st.x;\n                normal = vec3(-st.x, 0, 0);\n            }\n            else \n            {\n                tMax.z += tDelta.z;\n                cell.z += st.z;\n                normal = vec3(0, 0, -st.z);\n            }\n        }\n        else\n        {\n            if (tMax.y < tMax.z)\n            {\n                tMax.y += tDelta.y;\n                cell.y += st.y;\n                normal = vec3(0, -st.y, 0);\n            }\n            else \n            {\n                tMax.z += tDelta.z;\n                cell.z += st.z;\n                normal = vec3(0, 0, -st.z);\n            }\n        }\n    }\n    \n\n    return Result(vec3(0), vec3(0), vec3(0), 10000000000000.0, 0);\n}\n\nfloat GetLight(vec3 p, vec3 cell, vec3 n) {\n    vec3 lightPos = vec3(-1, 5, -3);\n    lightPos.xz -= vec2(sin(iTime), cos(iTime)) * 8.;\n    vec3 l = normalize(lightPos);\n    \n    //diffuse\n    float dif = 1.;\n    dif = clamp(dot(l, n), 0., 1.);\n\n    float lightDist = 30.0;\n    //shadows\n    \n    Result traversal = voxelTraversal(p + n * 0.01, l);\n    float d = traversal.depth;\n    \n    //float d = RayMarch(p + n * SURF_DIST * 2., l);\n    if (traversal.block_id != 0 && d <= lightDist) dif *= .1;\n    \n    return dif;\n}\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat PI = 3.1415926535;\nfloat EPSILON = 0.001;\n\n\n// a[0]i + a[1]j + a[2]k + a[3]\nvec4 qmult(vec4 a, vec4 b) {\n    return vec4(\n        a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0],\n        -a[0] * b[2] + a[1] * b[3] + a[2] * b[0] + a[3] * b[1],\n        a[0] * b[1] - a[1] * b[0] + a[2] * b[3] + a[3] * b[2],\n        - a[0] * b[0] - a[1] * b[1] - a[2] * b[2] + a[3] * b[3]\n    );\n}\n\n// rotation by quaternion\nvec3 qrot(vec4 q, vec3 x) {\n    vec4 x_prime = vec4(x, 0.0);\n    vec4 q_bar = vec4(-q.xyz, q.w);\n    return qmult(qmult(q, x_prime), q_bar).xyz;\n}\n\nbool mouse_dragging(out vec2 disp) {\n    vec2 du = vec2(1.0, 1.0) / iResolution.xy;\n    vec4 p_mouse = 2.0 * texture(iChannel0, du) - 1.0;\n    vec4 mouse = iMouse / iResolution.xyxy;\n    disp = mouse.xy - p_mouse.xy;\n    return p_mouse.z > 0.0 && mouse.z > 0.0;\n}\n\nvec3 lerp(vec3 a, vec3 b, float t)\n{\n    return b * t + a * (1. - t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n\n    vec2 du = vec2(1.0, 1.0) / iResolution.xy;\n    vec4 rot = 2.0 * texture(iChannel0, vec2(1.0, 1.0) - du) - 1.0;\n    \n    vec3 ro = vec3(4.,14.,-4.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    vec2 mouse = iMouse.xy / iResolution.xy - .5;\n    \n    float tilt = PI / 3.;//mouse.y;//PI / 12.; //15 degree tilt\n    float pan = 0.;//-mouse.x;//0.;\n\n    rd *= rotateX(tilt) * rotateY(pan);\n    \n    //ro = rd * -10.;\n    //rd *= -1.;\n    \n    //vec3 pos = qrot(rot, vec3(0.0, 0.0, 1.0));\n    //rd = qrot(rot, vec3(0.0, 0.0, 1.0));\n\n    //rd = qrot(rot, rd);\n\n    Result vt = voxelTraversal(ro, rd);\n\n    vec3 color = color(vt.block_id);\n    float light = GetLight(vt.position, vt.cell, vt.normal);\n    float depth = vt.depth;\n    \n    color *= light;\n    \n    \n    color = lerp(color, vec3(.2,.23,.4), 1. - clamp(30000. / pow(depth, 4.), 0., 1.));\n    \n    //color *= 12. / depth / depth;\n    \n    fragColor = vec4(color, 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}