{
    "Shader": {
        "info": {
            "date": "1510249861",
            "description": "A series of tools in order to modify properties",
            "flags": 32,
            "hasliked": 0,
            "id": "4lBcD3",
            "likes": 16,
            "name": "Shader UI Toolkit",
            "published": 3,
            "tags": [
                "2d",
                "ui",
                "iteration",
                "tool",
                "sliders",
                "widgets",
                "tools",
                "helpful",
                "toolkit"
            ],
            "usePreview": 0,
            "username": "BeardThings",
            "viewed": 1184
        },
        "renderpass": [
            {
                "code": "#define DEBUG_OVERLAY\n\nconst vec2 cSliderStore = vec2(0);\n\nvec4 LoadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 sliders = LoadValue(cSliderStore);\n    \n    fragColor = sliders;\n    \n    \n#ifdef DEBUG_OVERLAY\n    vec4 debugOverlay = texture(iChannel0, uv);\n    fragColor = mix(fragColor, debugOverlay, debugOverlay.a);\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Store your save data positions as constants for easy retrieval and storage\nconst vec2 cSliderStore = vec2(0);\nconst vec2 cPreviousMouseClickStore = vec2(1.0, 0.0);\n\n// State storing taken from: https://www.shadertoy.com/view/MddGzf\nfloat IsInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nvec4 LoadValue( in vec2 re )\n{\n    return textureLod( iChannel0, (0.5+re) / iChannelResolution[0].xy, 0.0 );\n}\n\nvoid StoreValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( IsInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvec4 LoadData(in ivec2 pos)\n{\n    return texelFetch(iChannel0, pos, 0);\n}\n\nfloat Equal(in vec2 rhs, in vec2 lhs) \n{\n    vec2 signOf = sign(rhs - lhs);\n    return max(1.0 - abs(signOf.x + signOf.y), 0.0);\n}\n\nfloat Not(in float l)\n{\n    return 1.0 - l;\n}\n\n// Draw a slider, and update it's value based on the mouse position\nvec4 Slider(in vec2 uv, in vec2 pos, inout float currentSlider)\n{   \n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    \n\t// Draw the slider bar\n    const vec2 cSquareHalfSize = vec2(0.01, 0.1);\n    vec2 relativeAbsPoint = abs(uv - pos);\n    vec2 inSquareV = step(relativeAbsPoint, cSquareHalfSize);\n    float inSquare = inSquareV.x * inSquareV.y;\n    \n    // Draw the actual slider\n    const vec2 cSliderHalfSize = vec2(0.02, 0.01);\n    vec2 sliderAbsPoint = abs(uv - (pos + vec2(0.0, currentSlider * 2.0 * cSquareHalfSize.y - cSquareHalfSize.y)));\n    vec2 inSliderV = step(sliderAbsPoint, cSliderHalfSize);\n    \n    // Collapse the vector into a single float to determine if we're in the square in both axis\n    float inSlider = inSliderV.x * inSliderV.y;\n    \n    // Check collision against the slider\n    const vec2 cColliderBox = vec2(0.02, 0.1);\n    vec2 relativeMousePoint = (mouseUV - pos);\n    vec2 mouseInCollider = step(abs(relativeMousePoint), cColliderBox);\n    \n\t// Update the slider's position if we're in the collider\n    float sliderHeight = (relativeMousePoint.y + cColliderBox.y) / (2.0 * cColliderBox.y);\n    \n    // Collapse the vector into a single float to determine if we're in the square in both axis\n    currentSlider = mix(currentSlider, sliderHeight, mouseInCollider.x * mouseInCollider.y);\n    \n    // Draw out the slider\n    return vec4(0.5, 0.8, 0.4, 1.0) * inSquare + vec4(1.0) * inSlider;\n}\n\nvec4 Toggle(in vec2 uv, in vec2 pos, inout float currentToggle)\n{\n    vec2 previousMouseClick = LoadValue(cPreviousMouseClickStore).xy;\n    \n    vec2 clickUV = iMouse.zw / iResolution.xy;\n    \n    float hasClickStateChanged = Not(Equal(clickUV.xy, previousMouseClick.xy));\n    \n    float aspect = iResolution.x / iResolution.y;\n    vec2 cSquareHalfSize = vec2(0.02 / aspect, 0.02);\n    vec2 relativeAbsPoint = abs(uv - pos);\n    vec2 inSquareV = step(relativeAbsPoint, cSquareHalfSize);\n\t// Collapse the vector into a single float to determine if we're in the square in both axis\n    float inSquare = inSquareV.x * inSquareV.y;\n    \n    vec2 relativeAbsMousePoint = abs(previousMouseClick - pos);\n    vec2 mouseInCollider = step(relativeAbsMousePoint, cSquareHalfSize);\n    \n    currentToggle = mix(currentToggle, 1.0 - currentToggle, mouseInCollider.x * mouseInCollider.y * hasClickStateChanged);\n    \n    vec2 cOutlineHalfSize = vec2(0.025 / aspect, 0.025);\n    vec2 inOutlineV = step(relativeAbsPoint, cOutlineHalfSize);\n\t// Collapse the vector into a single float to determine if we're in the square in both axis\n    float inOutline = inOutlineV.x * inOutlineV.y;\n    \n    vec4 outlinecolor = vec4(1.0);\n    \n    relativeAbsMousePoint = abs(clickUV - pos);\n    mouseInCollider = step(relativeAbsMousePoint, cSquareHalfSize);\n    \n    vec4 toggleColor = mix(vec4(0.5,0.5,0.5,1.0), vec4(0.5, 0.8, 0.4, 1.0), currentToggle);\n    toggleColor = mix(toggleColor, toggleColor * 0.95,  mouseInCollider.x * mouseInCollider.y);\n    return mix(outlinecolor * inOutline, toggleColor, inSquare);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\t// Load the values that you stored a previous frame\n    vec4 sliderValues = LoadValue(cSliderStore);\n\n    // Draw the sliders and update the slider values based on the mouse input\n\tvec4 sliderColor = Slider(uv, vec2(0.05, 0.85), sliderValues.x);\n    sliderColor += Slider(uv, vec2(0.1, 0.85), sliderValues.y);\n    sliderColor += Slider(uv, vec2(0.15, 0.85), sliderValues.z);\n    sliderColor += Toggle(uv, vec2(0.2, 0.85), sliderValues.w);\n    \n    // Draw out the sliders\n    fragColor = sliderColor;\n    \n    // Store the values into the buffer\n    StoreValue(cSliderStore, sliderValues, fragColor, fragCoord);\n    StoreValue(cPreviousMouseClickStore, vec4(iMouse.zw / iResolution.xy, 0, 0), fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}