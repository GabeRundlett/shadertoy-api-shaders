{
    "Shader": {
        "info": {
            "date": "1495408643",
            "description": "glyphs are put into tiles. so that every fragment only checks for one glyph (in the same tile)\nthis has a tile-set function that does BASIC automatic type-setting.\nword-wrap is planned, but I needed to debug simpler things first.\nis memory inefficient.",
            "flags": 0,
            "hasliked": 0,
            "id": "4dlBR7",
            "likes": 0,
            "name": "line wrap tiled glyph",
            "published": 3,
            "tags": [
                "tiled",
                "text",
                "ascii",
                "tile",
                "set",
                "wrap",
                "tiles",
                "wordwrap",
                "glyphs",
                "case"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 511
        },
        "renderpass": [
            {
                "code": "//#extension GL_OES_standard_derivatives : enable\n//#extension GL_ARB_arrays_of_arrays : enable\n\n//self    : https://www.shadertoy.com/view/4dlBR7\n//dad     : https://www.shadertoy.com/view/XssBzM\n//grandad : https://www.shadertoy.com/view/lsfcRX (glyph bitmap)\n//grandmom: https://www.shadertoy.com/view/4sXBzr (tiling (with glyph distancefield))\n\n\n//show word\n#define debug 0\n//show word#\n//#define debug 1\n//show number of glyphs per word\n//#define debug 2\n\nconst int wordl=6;//max length of any word\nconst int words=9;//number of words\n//beware, this creades a squared (fake2d) array for each fragment. nor good style.\n//and tha alone does not make this worthwhile for a pure fragment shader solution.\n\n\n/*\nthis goes for a function that takes an integer array of any length (possibly a max length), and startPositionCoordinates, to place a tile-grid and fill it with glyphs, according to the array. and then doing only 1 pass per array|tile, to allow offsets of strings of with overlapping tiling (and overlapping glyphs).\n*/\n\n/*\nway too many people use glyphs, either bitmap glyphs \n... or iChannel0 \"font1\" from otaviogood\n... WITHOUT utilizing any tiling.\n\nnot using tiles means, every fragment checks for EVERY glyph anywhere, \n... with almost all of them being \"out of frame|range\"\nusing tiled glyphs, means the tile frames the glyph\n... and every fragment only checks its brightness on ONE glyph.\n\ntiled glyphs can be done with multiple passes, offset and scaled, \n...with different \"strings\" of glyphs for each tile\nTo allow for offset or overlapping or \"dancing\" glyphs (as in Undertale)\n... you need oversized and overlapping tiles similar to\n... https://www.shadertoy.com/view/Xt23zG\n\nboth parents have different issues due to bilinear interpolation of mipmaps,\n... or for lacking mipmapping.\n*/\n\n//I would rather use a buffer to store an array of ascii-pointers \n//....than use a buffer to store a bitmap of glyphs.\n//(why not both? , because tiling makes bitmaps a lot faster, and i prefer sharp glyphs)\n\n\n//grand-dad legacy (is disabled in here):\n//ABOORTED merger of my \"ascii text wrapper\" (includes someone elses ascii text renderer)\n//and \"texture morph\" from https://www.shadertoy.com/view/ltcXzs\n//\n//splits functions into a container that displays some overlay text\n//and a content function that has the rest of the shader.\n//\n//2 elements work, but are too seperate, shouls use more of the same subroutines.\n//goal is simply to have sdf font replace ascii text here.\n\n//oh, it no longer scales with changing char size, it goes all italics.\n#define CHAR_SIZE vec2(8,12)\n\n#define f4 vec4\n\n//start.Glyphs.iChannel0 \n/*\n// --- access to the image of ascii code c\nf4 char(vec2 p, int C) {\n  //if(isInside2(p)==0.)return f4(0);return f4(0,0,0,1e5);\n  if (p.x<0.|| p.x>1. || p.y<0.|| p.y>1.) return f4(0,0,0,1e5);\n  //terrible branching framing \n  //return texture(iChannel0,p/16.+fract(vec2(C,15-C/16)/16.));\n  //return textureLod( iChannel0, p/16. + fract( vec2(C, 15-C/16) / 16. ) , \n  //                   log2(length(fwidth(p/16.*iResolution.xy))) );\n    return textureGrad( iChannel0, p/16. + fract( vec2(C, 15-C/16) / 16. ) , \n                       dFdx(p/16.),dFdy(p/16.) );\n    // possible variants: (but better separated in an upper function) \n    //     - inout pos and include pos.x -= .5 + linefeed mechanism\n    //     - flag for bold and italic \n}\n//xy has [0.0] on the top left, coplying with reading direction.\n//f4 chargrid(vec2 p,int c,vec2 xy){\n//}\n\nf4 charmorph(in vec2 U){float t=3.*iTime;\n f4 O=char(U,int(t));// try .xxxx for mask, .wwww for distance field.\n f4 O2=char(U,int(++t));\n O=mix(O,O2,fract(t));             //linear morphing \n //O = sqrt(mix(O*O,O2*O2,fract(t)));  // quadratic morphing\n O =  smoothstep(.5,.49,O.wwww)\n *O.yzww;// comment for B&W\n //O+=.5;O*=O*O;O-=.5;//cubic contrast;\n return O;}\n\n//isInside returns distance to a square \n//with center offset by offsetXY=.5;\n//and with HalfSizeXY=.5;\nfloat isInside(vec2 p, vec2 c){\n p.x*=2.;c.x*=2.;//scaling\n float offsetXY=.0;\n vec2 d=abs(p-offsetXY-c)-.5;\n return-max(d.x,d.y);}\n//offsetXY and HalfSizeXY could easily be the same input parameter.\n//scaling for IsInside() may be fster if it takes a mat2 as input.\n\nvoid mainImage2(out f4 O,vec2 p){\n p/=iResolution.y;\n O=.1*texture(iChannel0,p);\n O=max(O,charmorph(p));//morphing char.\n}\n\n/**/\n\n//end__.Glyphs.iChannel0 \n//start.Glyphs.bitmap\n\n//the line that contains \"greaterThanEqual\" nicely shows integer 2d clipping\n#define DOWN_SCALE 1.//poor scaling\n#define MAX_INT_DIGITS 4\n#define CHAR_SPACING vec2(8,12)\n#define STRWIDTH(c)(c*CHAR_SPACING.x)\n#define STRHEIGHT(c)(c*CHAR_SPACING.y)\nint TEXT_MODE=0;//0=normal 1=inverted 2=underlined\n/* glyph bitmap codec: it uses 4x24 bits of a f4() of type float, set in hexadecimal.\n--------   //\"-\" -> 0 , \"X\"-> 1\n-XXX----\nXX-XX--- -> 0x0070D8\nXX-XX---\n-XXX----\nXXXXX-X- -> 0xD870FA\nXX-XXXX-\nXX--XX--\nXX-XXX-- -> 0xDECCDC\n-XXX-XX-\n--------\n-------- -> 0x760000\nAutomatically generated from the 8x12 font sheet:\nhttp://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n*/\n#define hex0 0x000000\n#define hexC 0xCCCCCC\n#define cc87 0x0078CC \n#define he78 0x780000\n#define he30 0x303030\n#define _ ,uv)+char( \n//the first [0..31] ascii pointers are ignored here:\n//ASCII range with operators ()*/+-\nf4 gOpr[16]=f4[16](\n f4(hex0,hex0,hex0,hex0),/*space*/\n f4(0x003078,0x787830,0x300030,0x300000),/*!*/\n f4(0x006666,0x662400,hex0,hex0),/*\" double abostrophe*/\n f4(0x003030,0x306000,hex0,hex0),/*single aposrophe*/\n f4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000),/*hash*/\n f4(0x30307C,0xC0C078,0x0C0CF8,0x303000),/*dollar*/\n f4(hex0,0xC4CC18,0x3060CC,0x8C0000),/*%*/\n f4(0x0070D8,0xD870FA,0xDECCDC,0x760000),/*&*/\n f4(0x000C18,0x306060,0x603018,0x0C0000),/*(*/\n f4(0x006030,0x180C0C,0x0C1830,0x600000),/*)*/\n f4(hex0,0x663CFF,0x3C6600,hex0),/* * */\n f4(hex0,0x18187E,0x181800,hex0),/*+*/\n f4(hex0,hex0,0x000038,0x386000),/*,*/\n f4(hex0,0x0000FE,hex0,hex0),/*-*/\n f4(hex0,hex0,0x000038,0x386000),/*.*/\n f4(0x000002,0x060C18,0x3060C0,0x800000)/* / */);\n\n#define _spc 0/*space*/\n#define _exc 1/*!*/\n#define _quo 2/*\"*/\n#define _hsh 3/*hash*/\n#define _dol 4/*dollar*/\n#define _per 5/*%*/\n#define _amp 6/*&*/\n#define _apo 7/*single aposrophe*/\n#define _lbr 8/*(*/\n#define _rbr 9/*)*/\n#define _ast 10/* * */\n#define _crs 11/*+*/\n#define _com 12/*,*/\n#define _dsh 13/*-*/\n#define _dot 14/*.*/\n#define _lsl 15/* / */\n//ASCII range with numerals 0123456789:;<=>?\nf4 gNum[16]=f4[16](f4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000),f4(0x001030,0xF03030,he30,0xFC0000),f4(cc87,0xCC0C18,0x3060CC,0xFC0000),f4(cc87,0x0C0C38,0x0C0CCC,he78),f4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000),f4(0x00FCC0,0xC0C0F8,0x0C0CCC,he78),f4(0x003860,0xC0C0F8,hexC,he78),f4(0x00FEC6,0xC6060C,0x183030,0x300000),f4(cc87,0xCCEC78,0xDCCCCC,he78),f4(cc87,0xCCCC7C,0x181830,0x700000),f4(hex0,0x383800,0x003838,hex0),/*:*/f4(hex0,0x383800,0x003838,0x183000),/*;*/f4(0x000C18,0x3060C0,0x603018,0x0C0000),/*<*/f4(hex0,0x007E00,0x7E0000,hex0),/*=*/f4(0x006030,0x180C06,0x0C1830,0x600000),/*>*/f4(cc87,0x0C1830,0x300030,0x300000)/*?*/);\n#define _0 16\n#define _1 17\n#define _2 18\n#define _3 19\n#define _4 20\n#define _5 21\n#define _6 22\n#define _7 23\n#define _8 24\n#define _9 25\n#define _col 26/*:*/\n#define _scl 27/*;*/\n#define _les 28/*<*/\n#define _equ 29/*=*/\n#define _grt 30/*>*/\n#define _que 31/*?*/\n//ASCII range wih @ + UpperCase Alphabet+ [\\]^_\nf4 gUpp[32]=f4[32](f4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000),/*at*/f4(0x003078,hexC,0xFCCCCC,0xCC0000),/*A*/f4(0x00FC66,0x66667C,0x666666,0xFC0000),/*B*/f4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000),/*C*/f4(0x00F86C,0x666666,0x66666C,0xF80000),/*D*/f4(0x00FE62,0x60647C,0x646062,0xFE0000),/*E*/f4(0x00FE66,0x62647C,0x646060,0xF00000),/*F*/f4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000),/*G*/f4(0x00CCCC,0xCCCCFC,hexC,0xCC0000),/*H*/f4(0x007830,he30,he30,he78),/*I*/f4(0x001E0C,0x0C0C0C,hexC,he78),/*J*/f4(0x00E666,0x6C6C78,0x6C6C66,0xE60000),/*K*/f4(0x00F060,0x606060,0x626666,0xFE0000),/*L*/f4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000),/*M*/f4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000),/*N*/f4(0x00386C,0xC6C6C6,0xC6C66C,0x380000),/*O*/f4(0x00FC66,0x66667C,0x606060,0xF00000),/*P*/f4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00),/*Q*/f4(0x00FC66,0x66667C,0x6C6666,0xE60000),/*R*/f4(cc87,0xCCC070,0x18CCCC,he78),/*S*/f4(0x00FCB4,he30,he30,he78),/*T*/f4(0x00CCCC,hexC,hexC,he78),/*U*/f4(0x00CCCC,hexC,0xCCCC78,0x300000),/*V*/f4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000),/*W*/f4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000),/*X*/f4(0x00CCCC,0xCCCC78,he30,he78),/*Y*/f4(0x00FECE,0x981830,0x6062C6,0xFE0000),/*Z*/f4(0x003C30,he30,he30,0x3C0000),/*[*/f4(0x000080,0xC06030,0x180C06,0x020000),/*\\*/f4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000),/*]*/f4(0x10386C,0xC60000,hex0,hex0),/*^*/f4(hex0,hex0,hex0,0x00FF00)/*_*/);\n#define _ats 32\n#define _A 33\n#define _B 34\n#define _C 35\n#define _D 36\n#define _E 37\n#define _F 38\n#define _G 39\n#define _H 40\n#define _I 41\n#define _J 42\n#define _K 43\n#define _L 44\n#define _M 45\n#define _N 46\n#define _O 47\n#define _P 48\n#define _Q 49\n#define _R 50\n#define _S 51\n#define _T 52\n#define _U 53\n#define _V 54\n#define _W 55\n#define _X 56\n#define _Y 57\n#define _Z 58\n#define _lsb 59/*[*/\n#define _rsl 60/*\\*/\n#define _rsb 61/*]*/\n#define _pow 62/*^*/\n#define _usc 63/*_*/\n//ASCII range wih ´ + LowerCase Alphabet + {|}~ + _lar\nf4 gLow[32]=f4[32](f4(0x003030,0x306000,hex0,hex0),/*single aposrophe*/f4(hex0,0x00780C,0x7CCCCC,0x760000),/*a*/f4(0x00E060,0x607C66,0x666666,0xDC0000),/*b*/f4(hex0,cc87,0xC0C0CC,he78),/*c*/f4(0x001C0C,0x0C7CCC,hexC,0x760000),/*d*/f4(hex0,cc87,0xFCC0CC,he78),/*e*/f4(0x00386C,0x6060F8,0x606060,0xF00000),/*f*/f4(hex0,0x0076CC,0xCCCC7C,0x0CCC78),/*g*/f4(0x00E060,0x606C76,0x666666,0xE60000),/*h*/f4(0x001818,0x007818,0x181818,0x7E0000),/*i*/f4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78),/*j*/f4(0x00E060,0x60666C,0x786C66,0xE60000),/*k*/f4(0x007818,0x181818,0x181818,0x7E0000),/*l*/f4(hex0,0x00FCD6,0xD6D6D6,0xC60000),/*m*/f4(hex0,0x00F8CC,hexC,0xCC0000),/*n*/f4(hex0,cc87,hexC,he78),/*o*/f4(hex0,0x00DC66,0x666666,0x7C60F0),/*p*/f4(hex0,0x0076CC,hexC,0x7C0C1E),/*q*/f4(hex0,0x00EC6E,0x766060,0xF00000),/*r*/f4(hex0,cc87,0x6018CC,he78),/*s*/f4(0x000020,0x60FC60,0x60606C,0x380000),/*t*/f4(hex0,0x00CCCC,hexC,0x760000),/*u*/f4(hex0,0x00CCCC,0xCCCC78,0x300000),/*v*/f4(hex0,0x00C6C6,0xD6D66C,0x6C0000),/*w*/f4(hex0,0x00C66C,0x38386C,0xC60000),/*x*/f4(hex0,0x006666,0x66663C,0x0C18F0),/*y*/f4(hex0,0x00FC8C,0x1860C4,0xFC0000),/*z*/f4(0x001C30,0x3060C0,0x603030,0x1C0000),/*{*/f4(0x001818,0x181800,0x181818,0x180000),/*|*/f4(0x00E030,0x30180C,0x183030,0xE00000),/*}*/f4(0x0073DA,0xCE0000,hex0,hex0),/*~*/f4(hex0,0x10386C,0xC6C6FE,hex0)/*hut*/);\n#define _app 64\n#define _a 65\n#define _b 66\n#define _c 67\n#define _d 68\n#define _e 69\n#define _f 70\n#define _g 71\n#define _h 72\n#define _i 73\n#define _j 74\n#define _k 75\n#define _l 76\n#define _m 77\n#define _n 78\n#define _o 79\n#define _p 80\n#define _q 81\n#define _r 82\n#define _s 83\n#define _t 84\n#define _u 85\n#define _v 86\n#define _w 87\n#define _x 88\n#define _y 89\n#define _z 90\n#define _lpa 91/*{*/\n#define _bar 92/*|*/\n#define _rpa 93/*}*/\n#define _tid 94/*~*/\n#define _lar 95/*hut*/\n\nvec2 print_pos=vec2(0);//cursor position, (0,0)==bottom left.\n//get bit b from given number; Shift right (num / 2^bit), AND the result with 1 (mod(result,2.))\nfloat ebi(float n,float b){b=clamp(b,-1.,24.);return floor(mod(floor(n/pow(2.,floor(b))),2.));}\n//Return pixel at v in the given bit-packed sprite.\nfloat sprite(f4 j, vec2 s,vec2 v){v=floor(v);\n if(all(greaterThanEqual(v,vec2(0)))&&all(lessThan(v,s))){//Clipping bound\n   float b=(s.x-v.x-1.)+v.y*s.x;//Calculate bit to extract (x+y*width)(flipped on x-axis)\n   return ebi(j.x,b-72.)+ebi(j.y,b-48.)+ebi(j.z,b-24.)+ebi(j.w,b);}return 0.;}\n//Print character and move print_pos forward by 1 character width.\nfloat char(f4 ch,vec2 uv){//modify uv by any offset.\n      if(TEXT_MODE==1)ch=pow(2.,24.)-1.-ch;//Inverts all bits in the character.\n //else if(TEXT_MODE==2)ch.w=floor(ch.w/256.)*256.+255.;//set bottom 8 bits all 1. //i dislike this option\n float r=sprite(ch,CHAR_SIZE,uv-print_pos);print_pos.x+=CHAR_SPACING.x;return r;}\n//Return digit sprite for the given number.\nf4 get_dig(float x){return gNum[int(floor(x))];}\n//Print number, starting at pos.\n#define d10 float d=mod(n/pow(10.,float(i)),10.);\n//return bitmap of [a] as vec4, shifted by -32; 0=\" \"; 16=\"0\";32=\"@\";33=\"A\"65=a\nvec4 ascii2glyph(int a){\n if(a<16)return gOpr[a];\n if(a<32)return gNum[a-16];\n return mix(gUpp[a-32],gLow[a-64],step(64.,float(a)));\n if(a-64<0)return gUpp[a-32];return gLow[a-64];}\n\nfloat print_number(float n,vec2 v){\n float r=0.;for(int i=3;i>-2;i--){d10 if(i==-1)r+=char(ascii2glyph(_per),v);//decimal point\n  if(abs(n)>pow(10.,float(i))||i==0)r+=char(get_dig(d),v);}return r;}\n/*\n//used for an overlay that LSOWLY writes some Uniform values with bitmap sprites.\nfloat intP(float n,int z,vec2 v){float r=0.;for(int i=MAX_INT_DIGITS;i>=0;i--){d10\n if(abs(n)>pow(10.,float(i))||z>i||i==0)r+=char(get_dig(d),v);}return r;}\n//int getDigCD(float d){return int(1./pow(10.,d));}//return number of decimal digits\n#define _ ,uv)+char( \n#define tmi TEXT_MODE=1;r+=char(\n#define tmn TEXT_MODE=0;r+=char(\n float textfps(vec2 uv){print_pos=vec2(2,2.+STRHEIGHT(1.));\n float r=intP(1./iTimeDelta,0 _ _amp _ _spc,uv)//fps\n     +intP(float(iFrame)/iTime,0 _ _f _ _p _ _s _ _equ,uv)//total average fps\n     +intP(float(iFrame),0 _ _f _ _r _ _a _ _m _ _e _ _lsl,uv)+intP(iTime*1000.,0 _ _m _ _s,uv)\n     ;\n print_pos=vec2(2,2.+STRHEIGHT(0.));tmi _D _ _a _ _t _ _e,uv);tmn _col,uv);\n r+=intP(iDate.x,4 _ _dsh,uv)+intP(iDate.y+1.,2 _ _dsh,uv)+intP(iDate.z,2 _ _lsl,uv);//date\n r+=intP(floor(iDate.w/3600.),2 _ _col,uv)+intP(floor(mod(iDate.w/60.,60.)),2 _ _col,uv)//hour+min\n +intP(floor(mod(iDate.w,60.)),2,uv);tmn _spc,uv);//sec\n tmi _R _ _e _ _s,uv); tmn _col,uv);return r+intP(iResolution.x,0 _ _x,uv)+intP(iResolution.y,0,uv);}//res\n/**/\n//end__.Glyphs.bitmap\n//start.Glyphs.tiling\n\n\n//return [i]tileId, and [l]localPositionWithinTile of [u], tiled by [s]tileSize;\nvoid aTile(in vec2 u,in vec2 s,out vec2 i,out vec2 l){l=fract(u/s);i=floor(u/s);}\n\n#define time0 (cos(iTime*.2)*.5+.5)\n\n//textArray() is the tricky and buffer memory wasting part\n//... that defines what glyph will be displayed in what tile\n//this should actually just be a channel buffer or a uniform array.\n//return glyph index of text\nint textArray(int u){\n int o[16]=int[16](33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48);\n //above is a demo of a string of the alphabeticallysorted letters [A till P]\n return o[u%16];\n return o[u];\n}\n\n//I went a bit overboard, using 2 tilings, where 1 tiling would likely be enough.\n\n\n//you only want to get 1 pixel from 1 character.\n//its a simple stack:\n//return ascii of character at tile position u\n//getCharacterOfTile DEFINES a string (or multiple lines), but returns only a single ascii-pointer.\n//[u] has a positive up+right ditetion, counter intuitive to written script line-endianness.\n//a lot of calculation, like \"length of numerical values\" and \"line breaking\" \n//...may be included in getCharacterOfTile()\n//getCharacterOfTile(can be VERY branching and should return \"-1\" for \"trapsparent\" or \"space\" rather quickly)\n\n//return cell of FAKE 2d array.\nint arr2(int[wordl*words] a,ivec2 u){\n return a[u.x%wordl+u.y];}\n//overwrite [l]line of [a]fake2dArray with [w]word\n#define arr2v(z) void arr2w(inout int[wordl*words] a,int[z] w,int l){for(int i=0;i<z;i++){a[i+l*wordl]=w[i];}}\n//void arr2w(inout int[wordl*words] a,int[z] w,int l){for(int i=0;i<z;i++){a[i+l*z]=w[i];}}\narr2v(1)arr2v(2)arr2v(3)arr2v(4)arr2v(5)arr2v(6)arr2v(7)arr2v(8)arr2v(9)arr2v(10)\n//above lists allowed WRITABLE word lengths <=[wordl]\n\n#define addW(l) wl[wc]=l;arr2w(wa,int[abs(l)]\n\nint getleftmostdigit(int i,int d){\n return i/int(pow(10.,float(-d-1)));\n    /*\n if(d==-10)return i/1000000000;\n if(d==-9)return i/100000000;\n if(d==-8)return i/10000000;\n if(d==-7)return i/1000000; \n if(d==-6)return i/100000;\n if(d==-5)return i/10000;\n if(d==-4)return i/1000;\n if(d==-3)return i/100;\n if(d==-2)return i/10;\n return i;*/\n}\n    \n//retuen [r]array of ascii pointers of integer[p], with length [l] and [d] digits (for shifting)\n void i2a(int p,out int r[wordl],int d){int e=p;\n //if(p>999999999)r[wordl-11-d]=17;//dirty fix, only works because the 10th digit is either 0 or 0 due to unt range limit.\n for(int i=0;i<wordl-1;i++){ r[-i-1-d]=p%10+16;p/=10;}\n r[(-d-wordl)*2]=getleftmostdigit(e,d)+16;//this is a dirty fix, otherwise leftmost digit is [0]\n }\n//if (d<wordl) this messes up endianness, resulting setting #0<-0 ;\n\nint getNumberOfGlyphs(int n){for(int i=0;i<wordl;i++){if(n<=0)return i;n/=10;}return wordl;}\n\n//shorthand to write integer [n] as glyphs into tiles.\n#define addNumGly(n) le=-getNumberOfGlyphs(n);i2a(n,r,le);wl[wc]=le;arr2w(wa,r,wc);wc++;\n\n//return ascii character pointer to character of tile [u]\n//this function DEFINES and typeSets a string of text till it reaches [u]\nint getCharacterOfTile(ivec2 u, int lineWidth){\n if(u.x>lineWidth||u.x<0)return -1;//tile is outside of column\n if(u.y<0)return -1;//tile is above column start.\n if(u.y>int(time0*100.))return -1;//simple early solution,. only 2 lines allowed.\n //above frame makes it a bit faster, but memory is already \"wasted\" per fragment   \n    \n //well. pseudo 2d arrays are a bitch in opengl\n //having long arrays per fragment wastes a lot of memory.\n \n //i owe you a line-feed command.\n //but that should possibly just a second call co a copy of getCharacterOfTile() \n //with diffrent word input instead.\n     \n int wl[words];//stores length of words negative means, it ends with a separator?\n int wa[wordl*words];//yeah, thats what you get for no 2d arrays.  \n \n //buffer for numerical values.\n int r[wordl];//buffers digits of numerical word /sadly can not declare dynamic length array here.   \n int le;//buffers length of digits in glyphs\n\n //all \"words\" are generated and  buffered here, uncompressed, they eat a lot of memory.\n //could save a lot by making \"paragraphs\", \n //...=basically multi-passing the function getCharacterOfTile() with a line offset\n int wc=0;//makes it easier to swap words by swapping lines of codes that add a word\n //each line adds a \"word\", negative values are \"-word.length\"\n addW(-5)(_H,_e,_l,_l,_o),wc);wc++; \n addW(-6)(_W,_o,_r,_l,_d,_exc),wc);wc++; \n addNumGly(int(iTime*100.))\n addNumGly(int(iFrameRate))\n addW(-3)(_f,_p,_s),wc);wc++;\n addNumGly(int(iMouse.x))\n addW(-2)(_x,_y),wc);wc++;\n addNumGly(int(iMouse.y))\n addW(-5)(_a,_b,_c,_d,_e),wc);wc++;\n addW(-6)(_0,_1,_dot,_2,_3,_4),wc);wc++;\n //a reminder that my bitmap for \"_dot\" is still a \"comma\"\n  \n //i should possiby split this function in 2, \n //above half to set the array of words, below half to word warp through the array.  \n\n int posInLine;//cursor position in currLine;\n for(int i=0;i<words;i++){\n  //rebuild from scratch, assuming every word to be followed by a seperator.\n  //assuming there is only 1 line.\n  int w=wl[i];\n  if(w!=0){//by default, there may be a lot of \"void words\", skilled over here.\n   posInLine-=w;//assuming word length be negative.\n   if(posInLine>=u.x){//if set a word past u.x;\n    if(posInLine==u.x)return _spc;//essential,as long as my integer fills glyphs with \"0\", neds to be overwritten with \" \" \n    #if (debug==1)\n     return 16+i;//show # of word.\n    #endif\n    #if (debug==2)\n     return 16-w;//show # of letters of this word\n    #endif\n    return wa[(u.x-posInLine-w)+i*wordl];\n   }\n   posInLine+=1;//add the separator\n  }\n }\n    \n //below was older initial concept, it failed to solve Wort-wrapping\n    \n /*\n\n //tricky part now is calculating the number of columns.\n //now,setting word wraps;\n //for each SEPARATOR, the question is, can i add it to the line without wrap or not,\n //if(word has negative length) word is abs(wl(wordNumber))+1 long\n //... because the negative lengths indicates a \"SPACE\" separator after the word.\n //may look ugly for \"direct speech  she:\" blah bah\"., but thats minor aestetics.\n //if(word has positive length, add next word, till one has egative length.)\n int GlyphsPerLine=16;//max glyphs per line. longer lines do NOT eat more memory!\n //int currWord=0;//word number that is currntly being put into a line.\n int currLine=0;//line that we currently set words into.\n int posInLine;//cursor position in currLine;\n int acclen=0;//accumulative length for words without seperator\n for(int i=0;i<words;i++){\n  int w=wl[i];//w=word length.\n  if(w>-1){//word is NOT followed by a seperator,\n   acclen+=wl[i];\n  }else{//word is followed by sepertor, test if line breaking is needed\n   //and if it fits in the same line, see if we did set a glyph in the tile we care for.\n   if(posInLine+acclen-w<GlyphsPerLine){//if(accumulated word fits in line) add to line\n    posInLine+=acclen-w+1;//+1 for the \"space\" seperator.\n    wa[i*words-wl[i]]=0;\n    //posInLine++;\n    if(u.x<=posInLine){\n     posInLine+=w-1;//rewind by current word length AND by -1\n     u.x-=posInLine;//u.x now points at a glyph within [w]\n     return arr2(wa,ivec2(u.x,i))+16;//yeah that should work...\n    }\n   \n   }else{//this word is too long for this line, needs word wrap\n    currLine++;\n    posInLine=0;//note that we still keep acclen. \n    //because we may have accumulated a lot of words without seperator.\n   // if(u.y<=currLine){\n     if(u.x<=posInLine){\n      posInLine+=w-1;//rewind by current word length AND by -1\n      //repeat that rewind till we get a word with a seperator\n      //worst case, no word with separator, so we loop troug hall words?\n      int accRew=0;\n      for (int j=0;j<words;j++){\n       int wwl=wl[i-1-j];if(wl[i-1-j]<0)break;accRew+=wwl;}\n      u.x-=posInLine+accRew;//u.x now points at a glyph within [w]\n      return arr2(wa,ivec2(u.x,i))+16;;//yeah that should work...\n      //but more likely i have a few sign typos here and there.\n     }\n    }\n  // }\n  }\n       \n }\n/**/\n return 0;//return \"space\"\n}\n\nfloat GetPixelOfCharacter(ivec2 l,int c){return char(ascii2glyph(c),vec2(l)*CHAR_SIZE);}\n\n\nvoid mainImage(out f4 O,vec2 U){\n //U-=(iMouse.xy-iResolution.xy*.5)*1.;\n U*=time0+.5;\n U*=1.; \n vec2 t=vec2(0),l=vec2(0);\n aTile(U,vec2(CHAR_SIZE),t,l);\n float ll=.5*max(l.x,l.y);\n O=vec4(ll,fract(t/16.),1);//repeating tile colors in an interval of 16. makes good address space.\n ivec2 g=ivec2(floor(t));\n g.x-=g.y;//offsetting lines diagonally.\n int i=getCharacterOfTile(g,50);//50==max glyphs per line of glyphs.\n vec4 v=ascii2glyph(i);\n float s=char(v,l*CHAR_SIZE);\n O=max(O,vec4(s,s,s,1));\n    \n /*\n c=f4(0);c.w=1.;      //initial tinting for compatibility.\n float t=textfps(i);  //overlay test\n if(t==1.)c=f4(1.0);  //if (fragment is 100%text) skip rendering of content\n else mainImage2(c,i);//render content\n*/\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}