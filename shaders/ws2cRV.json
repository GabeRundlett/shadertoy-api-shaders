{
    "Shader": {
        "info": {
            "date": "1587007786",
            "description": "worked on this a lot more and ended up with something that looks a lot better!\n\nold version here. be warned that it compiles VERY slow: https://www.shadertoy.com/view/wsjczK",
            "flags": 0,
            "hasliked": 0,
            "id": "ws2cRV",
            "likes": 72,
            "name": "Apple (redux)",
            "published": 3,
            "tags": [
                "apple"
            ],
            "usePreview": 1,
            "username": "blackle",
            "viewed": 1222
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nuniform int donttouch;\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(p,ax)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a, b-a)/dot(b-a,b-a);\n  return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n  float k = dot(p-a, b-a)/dot(b-a,b-a);\n  return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat smin(float a, float b, float k) {\n  float h = max(0., k-abs(a-b))/k;\n  return min(a,b) - k*h*h*h/6.;\n}\n\nfloat hash(float a, float b) {\n  return fract(sin(dot(vec2(a,b), vec2(12.9898, 78.233))) * 43758.5453)*2.-1.;\n}\n\nfloat apple(vec3 p) {\n  p.x += sin(dot(p, vec3(4,2,5)))*0.02;\n  p.z += sin(dot(p, vec3(2,3,7)))*0.02;\n  p.y += sin(dot(p, vec3(2,6,2)))*0.01;\n  \n  vec2 cords = vec2(sqrt(pow(length(p.xy),2.)+0.005), p.z);\n  float sphere1 = length(cords-vec2(0.1,-0.1))-0.85;\n  float sphere2 = length(cords-vec2(0.6,0.6))-0.5;\n  float sphere3 = length(cords-vec2(0.4,-0.8))-0.3;\n  float profile = smin(smin(sphere1, sphere2, 0.9), sphere3, 0.5);\n  float linez = -1.2;\n  float linesub1 = linedist(p, vec3(0,-5,linez), vec3(0,5,linez)) - 0.2;\n  float linesub2 = linedist(p, vec3(-5,0,linez), vec3(5,0,linez)) - 0.2;\n  //return linedist(vec2(profile, p.x), vec2(0), vec2(-10,0))-0.1;\n  return -smin(-profile, smin(linesub1, linesub2, 0.3), 0.4);\n}\n\nvec3 globalstemcoords;\nfloat stem(vec3 p) {\n  float rad = 0.8;\n  float len = 0.6;\n  vec2 torcords = vec2(length(p.xz-vec2(rad,0))-rad, p.y);\n  float tor = length(torcords)-(smoothstep(0., len, p.z)*0.03+0.04);\n  float stemsurf = -smin(-tor, -length(p)+len, 0.06);\n  vec3 stemcords = vec3(atan(torcords.x, torcords.y)*0.1, atan(p.x-rad,p.z), tor);\n  globalstemcoords = stemcords;\n  return stemsurf;\n}\n\nint mat;\nfloat scene(vec3 p) {\n  float body = apple(p - vec3(0,0,1.15));\n  float stm = stem(erot(p, vec3(0,0,1), -0.8)-vec3(0,0,2));\n  float gnd = p.z;\n  float appl = min(stm,body);\n  if (appl < gnd) {\n    mat = 0;\n    if (stm < body) {\n      mat = 2;\n      return stm;\n    }\n    return appl;\n  }\n  mat = 1;\n  return gnd;\n}\n\nfloat scene_proxy(vec3 p) {\n  return min(p.z, min(length(abs(p)-vec3(0,0,1.3))-1., length(abs(p)-vec3(.1,.1,0.5))-0.5));\n}\n\nfloat noise_comp(vec2 p) {\n  vec2 id = floor(p);\n  p = fract(p);\n  float h1 = hash(id.x, id.y);\n  float h2 = hash(id.x+1., id.y);\n  float h3 = hash(id.x, id.y+1.);\n  float h4 = hash(id.x+1., id.y+1.);\n  return mix(mix(h1, h2, p.x), mix(h3, h4, p.x), p.y);\n}\n\nfloat noise(vec2 p) {\n  float n = 0.;\n  for (int i = 0; i < 6; i++) {\n    float h1 = hash(float(i), 8.);\n    float h2 = hash(h1, float(i));\n    float h3 = hash(h2, float(i));\n    n += noise_comp(erot(vec3(p*sqrt(float(i+1))/1.5 + vec2(h2, h3)*100.,0), vec3(0,0,1), h1*100.).xy);\n  }\n  return n/6.;\n}\n\nfloat dots(vec3 p, float scale) {\n  float m = 10000.;\n  for(int i = 0; i < 10; i++) {\n    float ax1 = hash(float(i),68.);\n    float ax2 = hash(ax1,float(i));\n    float ax3 = hash(ax2,float(i));\n    float rot = hash(ax3,float(i));\n    float off = hash(rot,float(i));\n    vec3 ax = normalize(tan(vec3(ax1, ax2, ax3)));\n    vec3 lp = erot(p + off, ax, rot*100.);\n    m = min(m, length((fract(lp/scale)-0.5)*scale));\n  }\n  return m;\n}\n\n/*\nvec3 norm(vec3 p) {\n  mat3 k  = mat3(p,p,p) - mat3(0.001);\n  return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}*/\n// suggested from tdhooper. Thanks!\n// improve compilation time & overall fps.\nconst int NORMAL_STEPS = 6;\nvec3 norm(vec3 pos) {\n    vec3 eps = vec3(.01, 0, 0);\n    vec3 nor = vec3(0);\n    float invert = 1.;\n    for (int i = 0; i < NORMAL_STEPS; i++) {\n        nor += scene(pos + eps * invert) * eps * invert;\n        eps = eps.zxy;\n        invert *= -1.;\n    }\n    return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 cam = normalize(vec3(2,uv));\n  vec3 init = vec3(-9,0,1.1);\n  \n  float yrot = 0.3;\n  float zrot = sin(iTime)*0.4-0.9;\n  cam = erot(cam, vec3(0,1,0), yrot);\n  init = erot(init, vec3(0,1,0), yrot);\n  cam = erot(cam, vec3(0,0,1), zrot);\n  init = erot(init, vec3(0,0,1), zrot);\n  vec3 p = init;\n  bool hit = false;\n  for (int i = 0; i < 200 + donttouch; i ++){\n    float dist = scene(p);\n    if (dist*dist < 1e-6) {\n      hit = true;\n      break;\n    }\n    p+=dist*cam;\n  }\n  vec3 localstemcoords = globalstemcoords;\n  int matloc = mat;\n  vec3 n = norm(p);\n  float ao = sqrt(scene_proxy(p+n*0.5)+0.5);\n  ao *= sqrt(scene_proxy(p+n*0.2)/0.2*0.5+0.5);\n  ao *= sqrt(scene_proxy(p+vec3(1))/sqrt(2.)*0.5+0.5);\n  ao *= sqrt(scene_proxy(p+vec3(.5))/sqrt(2.)+0.55);\n  //ao *= smoothstep(0., 0.5, length(p.xy))*0.2+0.8;\n  vec3 r = reflect(cam, n);\n  float wildness = 3.5;\n  float powr = 20.;\n  float specmult = 1.5;\n  vec3 darkcol;\n  vec3 litecol;\n\n  \n  float splaty = noise(p.zy*vec2(2,10))*0.3+0.6;\n  float splatx = noise(p.zx*vec2(2,10)+100.)*0.3+0.6;\n  float splatz = noise(vec2(length(p.xy), atan(p.x,p.y)*5.)+200.)*0.3+0.6;\n  float marble = mix(mix(splaty, splatx, abs(n.y)), splatz, abs(n.z));\n  if (matloc == 1) {\n    darkcol = vec3(0.01);\n    litecol = mix(vec3(1.,0.05,0.04), vec3(0.1), smoothstep(-1.2, 1.8, scene_proxy(p+r)/dot(r,n))*0.7+0.5);\n  } else if (matloc == 0) {\n    litecol = vec3(1.,0.05,0.04);\n    litecol = mix(vec3(1.,0.2,0.15), litecol, sqrt(marble*0.5+0.5));\n    float d = pow(smoothstep(0.01, 0.06, dots(p, 0.26)), 0.4);\n    litecol = mix(vec3(1.1,0.01,0.05), litecol, d);\n    litecol = mix(vec3(1.5,0.45,0.2), litecol, pow(d, 0.2));\n    litecol *= marble;\n    darkcol = litecol*0.02;\n\n    vec3 noffset = vec3(0);\n    noffset.x += cos(dot(p, 8.*vec3(3,2,2)));\n    noffset.z += cos(dot(p, 8.*vec3(4,1,8)));\n    noffset.y += cos(dot(p, 8.*vec3(4,2,2)));\n    noffset.z += cos(dot(p, 10.*vec3(5,2,4)));\n    noffset.y += cos(dot(p, 10.*vec3(1,1,6)));\n    noffset.y += cos(dot(p, 10.*vec3(1,6,2)));\n    noffset.x += cos(dot(p, 10.*vec3(2,1,5)));\n    noffset.x += cos(dot(p, 10.*vec3(3,6,1)));\n    n = normalize(n+noffset*0.01);\n  } else {\n    float grad = smoothstep(2.56, 2.3, p.z);\n    vec2 messscale = vec2(500.,50.);\n    float mess = noise(1.5+localstemcoords.xy*messscale);\n    float mess2 = noise(1.+localstemcoords.xy*messscale);\n    float mess3 = noise(0.5+localstemcoords.xy*messscale);\n    float stemmix = cos(localstemcoords.z*90.-0.8)*0.5+0.5;\n    n = normalize(n - normalize(tan(vec3(mess,mess2,mess3)))*0.3*(stemmix*0.5+0.5));\n    litecol = mix(vec3(0.5,0.07,0.02), vec3(0.4,0.03,0.025), grad);\n    litecol = mix(vec3(0.6,0.3,0.2), litecol, stemmix);\n    powr = 5.;\n    specmult = mix(0.25, 0.1, grad);\n    litecol *= marble;\n    darkcol = litecol*0.04;\n  }\n  r = reflect(cam, n);\n  float spec = pow(length(sin(r*wildness)*0.5+0.5)/sqrt(3.), powr)*specmult;\n  float diff = length(sin(n*wildness)*0.5+0.5)/sqrt(3.)*0.6;\n  vec3 diffcol = mix(darkcol, litecol, diff);\n  vec3 speccol = vec3(1,0.7,0.7)*spec;\n  fragColor.xyz = hit ? ao*(diffcol + speccol) : vec3(0.05);\n  fragColor.xyz = sqrt(fragColor.xyz);\n  fragColor.xyz = mix(fragColor.xyz, smoothstep(vec3(0),vec3(1), fragColor.xyz), 0.3) + hash(hash(uv.x, uv.y), iTime)*0.02;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}