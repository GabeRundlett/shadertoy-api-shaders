{
    "Shader": {
        "info": {
            "date": "1639309582",
            "description": "a very lazy way to dither stuff / fun UI editable version using dat.gui - [url]https://codepen.io/pjkarlik/pen/QWqKvbV[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "7lcSWn",
            "likes": 19,
            "name": "Truchet Experiment 023",
            "published": 3,
            "tags": [
                "raymarching",
                "truchet",
                "tiles"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 361
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Truchet Experiment 023\n    12/12/2021  @byt3_m3chanic\n    \n*/\n\n#define R           iResolution\n#define M           iMouse\n#define T           iTime\n#define PI          3.14159265358\n#define PI2         6.28318530718\n#define MIN_DIST    .0001\n#define MAX_DIST    50.\n\n// globals & const\nvec3 hit,hitPoint;\nvec4 gtile,stile;\nmat2 flip;\n\nconst vec3 colorA = vec3(0.890,0.722,0.110);\nconst vec3 colorB = vec3(0.039,0.322,0.741);\nconst vec3 colorC = vec3(0.831,0.125,0.047);\n// cell size\nconst float size = 2.75;\nconst float hlf = size/2.;\n// grid size\nconst vec2  grid = vec2(5,2);\n// tube size\nconst float thick = .85/size;\n// floor tile scale\nconst vec3 bs = vec3(hlf*.95);\n// random hash - in a steady state\nfloat u_hash = 0.12482938;\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234); }\n\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\nfloat cap(vec3 p,float r,float h){\n    vec2 d = abs(vec2(length(p.xy),p.z))-vec2(h,r);\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n \nfloat trs( vec3 p,vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nvec2 map(vec3 p){\n    vec2 res = vec2(1e5,0.);\n    p.yz*=flip;\n    vec3 q = p;\n\n    vec2 id = floor((q.xz + hlf)/size)-grid;\n\n    q.xz = q.xz-size*clamp(round(q.xz/size),-grid,grid);\n    vec3 fq = q;\n\n    float ht = .75+.75*sin(p.x*.3+T*.8);\n    q.y-=ht;\n    float hs = hash21(id+u_hash);\n    if(hs>.5) q.z*=-1.;\n\n    vec2 d2 = vec2(length(q.xz-hlf), length(q.xz+hlf));\n    vec2 gx = d2.x<d2.y ? vec2(q.xz-hlf) : vec2(q.xz+hlf);\n    vec3 tq = vec3(gx.x,q.y,gx.y);\n\n    float xhs = fract(2.*hs+id.y);\n    float rhs = fract(hs+id.x);\n    float trh = 1e5;\n    if(rhs>.9){\n        trh = length(vec3(abs(q.x),q.yz)-vec3(hlf,.25,0))-thick;\n        trh = min(length(vec3(q.xy,abs(q.z))-vec3(0,.25,hlf))-thick,trh);\n    }else if(rhs>.7){\n        //if(fract(xhs+id.x)>.75) q.zx*=rot(1.5707);\n        float qy = .15+.15*sin((q.z+.5)*size);\n        float qx = .15+.15*sin((q.x+.5)*size);\n        trh = cap(q-vec3(0,.25+qy,0),hlf,thick);\n        trh = min(cap(q.zyx-vec3(0,.25-qx,0),hlf,thick),trh);\n    } else{\n        trh = trs(tq-vec3(0,.25,0),vec2(hlf,thick));\n\n    }\n    \n    float brh=trh;\n    trh=max(abs(trh)-.075,-trh);\n    trh=max(trh,box(q,bs));\n\n    if(trh<res.x ) {\n        float mt = xhs>.725?5.:xhs>.61?4.:xhs>.25?2.:3.;\n        gtile.xyz = vec3(id,1.);\n        gtile.w=mt;\n        res = vec2(trh,mt);\n        hit = tq;\n    } \n    \n    float bls = cap(vec3(q.xy,abs(q.z))-vec3(0,.25,hlf),thick*.4,thick*1.1);\n    bls = min(cap(vec3(q.zy,abs(q.x))-vec3(0,.25,hlf),thick*.4,thick*1.1),bls);\n    \n    float crt = cap(vec3(q.xy,abs(q.z))-vec3(0,.25,hlf),thick*.34,thick*1.45);  \n    crt = min(cap(vec3(q.zy,abs(q.x))-vec3(0,.25,hlf),thick*.34,thick*1.45),crt);\n    \n    bls=max(crt,-bls);\n    \n    if(bls<res.x) {\n       res = vec2(bls,1.);\n       hit = q;\n    } \n    \n    float flr = box(fq+vec3(0,2,0),vec3(bs.x,.05,bs.xy));\n    flr=max(flr,-brh);\n    if(flr<res.x) {\n       res = vec2(flr,7.);\n       gtile.xyz = vec3(id,0.);\n       gtile.w=6.;\n       hit = fq;\n    } \n    \n    return res;\n}\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nfloat stripes(vec3 p){\n    vec2 uv = p.xz;\n    uv*=rot(.785);\n    vec2 ff = floor(uv);\n    float f = clamp(mod(ff.x,2.)*1.-.5,0.,1.);\n    float h = mix(1.,.0,f);\n    return h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    uv = floor(uv*(216.*R.x/R.y))/(126.*R.x/R.y);\n\n    u_hash+=floor(T*.3);\n    vec3 ro = vec3(0, -1.5, 12.5);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    // mouse //\n    float x = M.z < 0. || M.xy==vec2(0) ? 0.0 : (M.y/R.y*2.-1.)*PI;\n    float y = M.z > 0. ? (M.x/R.x * 2. - 1.) * PI : T*.1;\n    mat2 rx =rot(-.65);\n    mat2 ry =rot(y);\n    flip=rot(x);\n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C = vec3(.0);\n    float m = 0.;\n    float d = 0.;\n    vec3 p = ro;\n    \n    for(int i=0;i<128;i++)\n    {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<32? ray.x*.75: ray.x *.95;\n        m  = ray.y;\n    } \n\n    \n    float alpha = 1.;\n    if(d<MAX_DIST)\n    {\n    \n        hitPoint = hit;\n        alpha *=1e-5;\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(0,15,-5.);\n        vec3 l = normalize(lpos);\n        float spec = pow(max(dot(reflect(l, n), rd ), .1), 32.)*.75;\n        float shdw = 1.0;\n        float t=.001;\n        for( int i =1; i<20; i++ ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 24.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n\n        vec3 h = vec3(.0);\n        float diff = clamp(dot(n,l),0. , 1.);\n        if(m==1.) {h=vec3(.43);}\n        if(m==2.) {h=colorB;}\n        if(m==3.) {h=colorC;}\n        if(m==4.) {h=colorA;}\n        if(m==5.) {h=vec3(.075);}\n        if(m==7.) {h=mix(colorB*.3,colorB*.1,stripes(hitPoint));}\n        \n        h = mix(h,h*shdw,.15);\n        if(diff<.3) h=clamp(h*.5,vec3(0),vec3(1));\n        if(diff<.4&&(mod(F.x,4.)==mod(F.y,4.))) h*=.3;\n        if(shdw<.5&&(mod(F.x,2.)==mod(F.y,2.))) h*=.2;\n        if(spec>.25) h=clamp(h*1.15,vec3(0),vec3(1));\n        if(spec>.5&&(mod(F.x,2.)==mod(F.y,2.))) h=clamp(h*1.5,vec3(0),vec3(1));\n        C = h;\n    }\n    float mask = smoothstep(.1,.7,length(uv)-.5);\n    vec3 clr = mix(colorA,colorA*.05 ,mask );\n    \n    uv*=rot(.785);\n    vec2 ff = floor(uv*8.);\n    float f = clamp(mod(ff.x,2.)*1.-.5,0.,1.);\n    clr = mix(clr*.5,clr*.2,f);\n    C = mix(C,clr,alpha);\n    if(C.r<.2&&C.g<.2&&C.b<.2) C = hash21(uv)>.5 ? C+.005 : C;\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}