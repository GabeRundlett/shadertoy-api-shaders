{
    "Shader": {
        "info": {
            "date": "1580407579",
            "description": "The blending led to this. Simplest emotion I could think of.\nNeed to work on the lighting in the eyes. \n\nOn Android chrome, (and maybe other platforms), eyes are not \nrendering correctly. They move along with the light, and not with\nthe head. Any guidance",
            "flags": 0,
            "hasliked": 0,
            "id": "tttXR8",
            "likes": 6,
            "name": "Highly suspicious",
            "published": 3,
            "tags": [
                "3d",
                "animation",
                "face"
            ],
            "usePreview": 0,
            "username": "samhattangady",
            "viewed": 558
        },
        "renderpass": [
            {
                "code": "/*\nday004: \n30 Jan 2020\n\nThe blending led to this. Simplest emotion I could think of.\nNeed to work on the lighting in the eyes. Want to make that\na little more \"glossy\"? Also shadows may help.\n\n*/\nvec3 rotate3D(vec3 point, vec3 rotation) {\n    vec3 r = rotation;\n\tmat3 rz = mat3(cos(r.z), -sin(r.z), 0,\n                   sin(r.z),  cos(r.z), 0,\n                   0,         0,        1);\n    mat3 ry = mat3( cos(r.y), 0, sin(r.y),\n                    0       , 1, 0       ,\n                   -sin(r.y), 0, cos(r.y));\n    mat3 rx = mat3(1, 0       , 0        ,\n                   0, cos(r.x), -sin(r.x),\n                   0, sin(r.x),  cos(r.x));\n    return rx * ry * rz * point;\n}\n\nfloat sdfSphere(vec3 position, vec3 center, float radius) {\n    return distance(position, center) - radius;\n}\nfloat sdfEllipsoid(vec3 position, vec3 center, vec3 radii) {\n    position -= center;\n    float k0 = length(position/radii);\n    float k1 = length(position/(radii*radii));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdfEllipsoidRotated(vec3 position, vec3 center, vec3 radii, vec3 rotation) {\n\tposition -= center;\n    position = rotate3D(position, rotation);\n    float k0 = length(position/radii);\n    float k1 = length(position/(radii*radii));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdfPlane( vec3 position, vec4 n ) {\n    return dot(position, normalize(n.xyz)) + n.w;\n}\nfloat sdfRoundBoxRotated(vec3 position, vec3 center, vec3 box, vec3 rotation, float radius) {\n    position -= center;\n    position = rotate3D(position, rotation);\n    vec3 q = abs(position) - box;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius;\n}\n\nfloat dot2(vec2 v) {\n\treturn dot(v, v);\n}\nvec4 sdfJoint3DSphere(vec3 position, vec3 start, vec3 rotation, float len, float angle, float thickness) {\n    vec3 p = position;\n    float l = len;\n    float a = angle;\n    float w = thickness;\n    p -= start;\n    p = rotate3D(p, rotation);\n\n    \n    if( abs(a)<0.001 ) {\n        return vec4( length(p-vec3(0,clamp(p.y,0.0,l),0))-w, p );\n    }\n    \n    vec2  sc = vec2(sin(a),cos(a));\n    float ra = 0.5*l/a;\n    p.x -= ra;\n    vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n    float u = abs(ra)-length(q);\n    float d2 = (q.y<0.0) ? dot2( q+vec2(ra,0.0) ) : u*u;\n    float s = sign(a);\n    return vec4( sqrt(d2+p.z*p.z)-w,\n               (p.y>0.0) ? s*u : s*sign(-p.x)*(q.x+ra),\n               (p.y>0.0) ? atan(s*p.y,-s*p.x)*ra : (s*p.x<0.0)?p.y:l-p.y,\n               p.z );\n}\n\nfloat smin(float d1, float d2, float k) {\n    //float res = exp2( -k*d1 ) + exp2( -k*d2 );\n    //return -log2( res )/k;\n    \n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\nfloat smax(float d1, float d2, float k) {  \n    float h = max(k-abs(d1-d2),0.0);\n    return max(d1, d2) + h*h*0.25/k;\n}\n\nfloat pow5Timing(float i) {\n\tfloat cosPiCycle = -1.0 + 2.0*step(0.0, cos(i*3.14159));\n    float sin2PiCycle = -1.0 + 2.0*step(0.0, sin(i*3.14159*2.0));\n    float pow5 = 1.0 - (pow(fract(i*2.0*sin2PiCycle), 6.0));\n    return pow5 * cosPiCycle;\n}\n\nvec4 faceField(vec3 position) {\n    float animTime = sin(iTime*1.8);\n    float lagAnimTime = sin((iTime-0.1)*1.8);\n    //float posTiming = (abs(animTime) / animTime) * abs(pow(animTime, 0.4));\n    //float lagTiming = (abs(lagAnimTime) / lagAnimTime) * abs(pow(lagAnimTime, 0.4));\n    \n    float speedUp = 0.6;\n    float posTiming = pow5Timing(iTime*speedUp);\n    float lagTiming = pow5Timing((iTime-0.1)*speedUp);\n    position = rotate3D(position, vec3(-0.1+(abs(lagTiming)*0.1), 0.0+(0.13*lagTiming), 0.0));\n\tvec3 symPosX = vec3(abs(position.x), position.yz);\n    float material = 1.0;\n    \n    float d = sdfSphere(position, vec3(0.0), 0.55);\n    float d1 = sdfSphere(position, vec3(0.0, -0.55, -.15), 0.4);\n    d = smin(d, d1, 0.5);   \n    // brow\n    d1 = sdfEllipsoid(position, vec3(0.0, 0.04, -0.35), vec3(0.35, 0.2, 0.2));\n    d = smin(d, d1, 0.1);\n    // eye socket\n    d1 = sdfSphere(symPosX, vec3(0.4, -0.08, -.55), 0.1);\n    d = smax(d, -d1, 0.3);\n    \n    \n    // right eyebrow\n    d1 = sdfJoint3DSphere(position, vec3(-0.15, 0.03+(0.05*lagTiming), -0.535+(0.015*lagTiming)), vec3(0.5, 0.0, 1.75), 0.2-(0.05*lagTiming), 0.4, 0.01).x;\n    d = smin(d, d1, 0.2);\n    // left eyebrow\n    d1 = sdfJoint3DSphere(position, vec3(0.15, 0.03-(0.05*lagTiming), -0.535-(0.015*lagTiming)), vec3(0.5, 0.0, -1.75), 0.2+(0.05*lagTiming), -0.4, 0.01).x;\n    d = smin(d, d1, 0.2);\n    \n    \n    // bottom eyebrow?\n    d1 = sdfJoint3DSphere(symPosX, vec3(0.2, -0.25, -0.48), vec3(0.52, 0.0, -1.95), 0.15, -0.4, 0.001).x;\n    d = smin(d, d1, 0.22);\n    \n    \n    // nose\n    d1 = sdfEllipsoidRotated(position, vec3(0.0, -0.28, -0.55), vec3(0.07, 0.15, 0.1), vec3(3.14159/4.0, 0.0, 0.0));\n    d1 = sdfRoundBoxRotated(position, vec3(0.0, -0.28, -0.49), vec3(0.03, 0.19, 0.1), vec3(3.14159/6.0, 0.0, 0.0), 0.02);\n    d = smin(d, d1, 0.1);\n    \n    // eye\n    d1 = sdfSphere(symPosX, vec3(0.18, -0.12, -.38), 0.2);\n    if (d1 < d) {\n    \td = d1;\n        material = 2.0;\n    }\n    // iris\n    vec3 irisPos = position;\n    irisPos.x += posTiming * 0.06;\n    d1 = sdfSphere(irisPos, vec3(0.23, -0.12, -0.545), 0.06);\n    if (d1 < d) {\n    \td = d1;\n        material = 3.0;\n    }\n    d1 = sdfSphere(irisPos, vec3(-0.23, -0.12, -0.545), 0.06);\n    if (d1 < d) {\n    \td = d1;\n        material = 3.0;\n    }\n    return vec4(d, material, 0.0, 0.0);\n}\n\nvec4 distanceField(vec3 position) {\n\tvec4 d = faceField(position);\n    return d;\n}\n\nvec3 calcNormal( vec3 p ) \n{\n    // We calculate the normal by finding the gradient of the field at the\n    // point that we are interested in. We can find the gradient by getting\n    // the difference in field at that point and a point slighttly away from it.\n    const float h = 0.0001;\n    return normalize( vec3(\n        \t\t\t       -distanceField(p).x+ distanceField(p+vec3(h,0.0,0.0)).x,\n                           -distanceField(p).x+ distanceField(p+vec3(0.0,h,0.0)).x,\n                           -distanceField(p).x+ distanceField(p+vec3(0.0,0.0,h)).x \n    \t\t\t\t ));\n}\n\nvec4 raymarch(vec3 direction, vec3 start) {\n    // We need to cast out a ray in the given direction, and see which is\n    // the closest object that we hit. We then move forward by that distance,\n    // and continue the same process. We terminate when we hit an object\n    // (distance is very small) or at some predefined distance.\n    float far = 15.0;\n    vec3 pos = start;\n    float d = 0.0;\n    vec4 obj = vec4(0.0, 0.0, 0.0, 0.0);\n    for (int i=0; i<100; i++) {\n    \tobj = distanceField(pos);\n        float dist = obj.x;\n        pos += dist*direction;\n        d += dist;\n        if (dist < 0.01) {\n        \tbreak;\n        }\n        if (d > far) {\n        \tbreak;\n        }\n    }\n    return vec4(d, obj.yzw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalise and set center to origin.\n    vec2 p = fragCoord/iResolution.xy;\n    p -= 0.5;\n    p.y *= iResolution.y/iResolution.x;\n    \n    float mouseX = ((iMouse.x/iResolution.x)-0.5) * 2.0 * 3.14159/2.0;\n    mouseX = 0.0;\n    vec3 cameraPosition = vec3(0.0, 0.0, -3.0);\n    vec3 planePosition = vec3(p, 1.0) + cameraPosition;\n\n    mat2 camRotate = mat2(cos(mouseX), -sin(mouseX), sin(mouseX), cos(mouseX));\n    cameraPosition.xz = camRotate * cameraPosition.xz;    \n    planePosition.xz = camRotate * planePosition.xz;    \n    vec3 lookingDirection = (planePosition - cameraPosition);\n    \n    // This was fun to sort out, but is it the best way?\n    float lightTime = iTime/3.0;\n    float multiplier = -1.0 + (step(-0.0, sin(lightTime*3.14159)) *2.0);\n    float parabola = (4.0 * fract(lightTime) * (1.0-fract(lightTime)));\n    float lightX = multiplier*parabola *-1.2;\n    vec3 lightPoint = normalize(vec3(lightX, 1.0, -1.0));\n    vec3 lightFacing = lightPoint - vec3(0.0);\n    //lightFacing = vec3(1.0, 1.0, -0.3) - vec3(0.0);\n    \n    // raymarch to check for colissions.\n    vec4 obj = raymarch(lookingDirection, planePosition);\n    float dist = obj.x;\n    vec3 color = vec3(0.01);\n    if (dist < 15.0) {\n        vec3 normal = calcNormal(planePosition+ dist*lookingDirection);\n        float light = dot(lightFacing, normal);\n        light = max(light, 0.0);\n        if (obj.y < 1.5) {\n            // skin\n        \tcolor = vec3(0.505, 0.205, 0.105);\n            color += 0.4* smoothstep(0.3, 1.0, light);\n        } else if (obj.y < 2.5) {\n            //eyes\n        \tcolor = vec3(0.55, 0.55, 0.65);\n            color += 0.3 * smoothstep(0.5, 1.0, light);\n            color += 0.7 * pow(light, 15.0);\n        } else if (obj.y < 3.5) {\n        \tcolor = vec3(0.01);\n            color += 0.7 * smoothstep(0.4, 1.0, pow(light, 5.0));\n        }\n    }\n    \n    // gamma correction\n    color = pow( color, vec3(1.0/2.2) );\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}