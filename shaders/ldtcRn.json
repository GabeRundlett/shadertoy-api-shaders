{
    "Shader": {
        "info": {
            "date": "1517816618",
            "description": "test pt v. please click screen to readjust camera.",
            "flags": 32,
            "hasliked": 0,
            "id": "ldtcRn",
            "likes": 0,
            "name": "(WIP) refractive glossy MIS NEE",
            "published": 3,
            "tags": [
                "testptv"
            ],
            "usePreview": 0,
            "username": "dtoadq",
            "viewed": 823
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 r = texture(iChannel1, uv);\n\t\n    // gamma\n    r = clamp(r,0.0,1.0);\n\tr = vec4( pow( r , vec4(1.0/2.2)));    \n    \n    if ( r.w == 0.0 ) r = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    fragColor =  r;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//------------------------------------------------------------------------------\n//-------- SETTINGS (FOR UTILITY LIBRARY) --------------------------------------\n\n#define Scene_width  8.0\n#define Scene_height 3.0\n#define Scene_depth  5.0\n// Uncomment below to have light move along with scene (you have to undefine\n// collect in Buf c)\n//#define Rotatal\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//-------- UTILITY LIBRARY -----------------------------------------------------\n//------------------------------------------------------------------------------\n#define float4 vec4\n#define float3 vec3\n#define float2 vec2\n\n#define PI   3.141592653589793\n#define IPI  0.318309886183791\n#define IPI2 0.159154943091895\n#define TAU  6.283185307179586\n#define ITAU 0.159154943091895\n\n#define SQR(X) ((X)*(X))\n\n#define MOUSEX (iMouse.x/iResolution.x)\n#define MOUSEY (iMouse.y/iResolution.y)\n\nuniform vec3 u_eye3d;\nuniform vec3 u_centre3d;\nuniform vec3 u_up3d;\n\nstruct Ray { float3 ori, dir; };\n\nfloat2 Map ( float3 o );\n\nfloat2 March ( in Ray ray ) {\n  float dist = 0.0;\n  float2 cur;\n  for ( int i = 0; i != 64; ++ i ) {\n    cur = Map(ray.ori + ray.dir*dist);\n    if ( cur.x <= 0.0005 || dist > 256.0 ) break;\n    dist += cur.x;\n  }\n  if ( dist > 256.0 || dist < 0.0 ) return float2(-1.0);\n  return float2(dist, cur.y);\n}\n\nfloat3 Normal ( float3 p ) {\n  float2 e = float2(1.0, -1.0)*0.001;\n  return normalize(\n                   e.xyy*Map(p + e.xyy).x +\n                   e.yyx*Map(p + e.yyx).x +\n                   e.yxy*Map(p + e.yxy).x +\n                   e.xxx*Map(p + e.xxx).x);\n}\n\nRay Look_At ( float2 uv ) {\n  //----origin\n  #ifdef Rotatal\n    float3 ori = float3(Scene_width*0.0+Scene_width*(sin(iTime*0.2)),\n                        Scene_height*sin(iTime*0.02),\n                        Scene_depth*5.0+Scene_depth*abs(cos(iTime*0.1)))*0.2;\n  #else\n    float2 M = float2(MOUSEX, MOUSEY);\n    if ( M.x == 0.0f ) M = float2(0.5f);\n    float3 ori = float3(Scene_width*0.0+Scene_width*sin(2.0*M.x-1.0),\n                        Scene_height*(2.0*M.y-1.0),\n                        Scene_depth*0.5+Scene_depth*cos(2.0*M.x-1.0));\n  #endif\n  //----etc\n  float3 center = float3(0.0),\n         up     = float3(0.0, 1.0, 0.0);\n  float3 ww = normalize(center - ori),\n         uu = normalize(cross(up, ww)),\n         vv = normalize(cross(ww, uu));\n  return Ray(ori, normalize(uv.x*uu + uv.y*vv + 2.5*ww));\n}\n\n// -- maps --\nfloat sdSphere ( float3 o, float r ) { return length(o) - r; }\nfloat length8 ( float2 o ) {\n  o = o*o; o = o*o; o = o*o;\n  return pow(o.x + o.y, 1.0/8.0);\n}\nfloat sdTorus ( float3 p, float hole, float radius ) {\n  return length8(float2(length8(p.xz) - radius, p.y)) - hole;\n}\nfloat sdHexagonCircumcircle ( float3 p, float2 h ) {\n  float3 q = abs(p);\n  return max(q.y - h.y, max(q.x*sqrt(3.0)*0.5 + q.z*0.5, q.z) - h.x);\n}\nfloat sdBox    ( float3 o, float3 b ) {\n  float3 d = abs(o) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nvoid Union ( inout float2 t, float d, in float ID ) {\n  if ( t.x > d ) t = float2(d, ID);\n}\n\nvoid opRotate(inout float2 p, in float a ) {\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// -- random --\n\nfloat Sample_Uniform(inout float seed) {\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\nvec2 Sample_Uniform2(inout float seed) {\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 Sample_Uniform3(inout float seed) {\n    return fract(sin(vec3(seed+=0.1,seed+=0.1,seed+=0.1))*\n                 vec3(43758.5453123,22578.1459123,842582.632592));\n}\n\n// -- sampler --\nfloat3 To_Cartesian ( float cos_theta, float phi ) {\n  float sin_theta = sqrt(max(0.0, 1.0 - cos_theta));\n  return float3(cos(phi)*sin_theta, sin(phi)*sin_theta, cos_theta);\n}\n\nvec3 Reorient_Hemisphere ( vec3 wo, vec3 N ) {\n  vec3 binormal = vec3(0.0, 1.0, 0.0);//(abs(N.x) < 1.0 ? vec3(1.0, 0.0, 0.0) :\n                   //vec3(0.0, 1.0, 0.0));\n  binormal = normalize(cross(N, binormal));\n  vec3 bitangent = cross(binormal, N);\n  return bitangent*wo.x + binormal*wo.y + wo.z*N;\n}\n\nfloat PDF_Cosine_Hemisphere ( float3 wi, float3 N ) {\n  return abs(dot(wi, N)) * IPI;\n}\n\nvec3 Sample_Cos_Hemisphere ( float3 wi, float3 N, out float pdf, inout float seed ) {\n  vec2 u = Sample_Uniform2(seed);\n  float cos_theta = sqrt(u.y);\n  float3 wo = Reorient_Hemisphere(normalize(To_Cartesian(cos_theta, TAU*u.x)), N);\n  pdf = PDF_Cosine_Hemisphere(wi, N);\n  return wo;\n}\n\nfloat PDF_Glossy ( float lobe ) {\n  if ( lobe < 0.001 ) return 1.0;\n  return (TAU*SQR(sin(0.5*lobe)));\n}\n\nfloat3 Sample_Uniform_Cone ( float lobe, out float pdf, inout float seed ) {\n  float2 u = Sample_Uniform2(seed);\n  float phi = TAU*u.x,\n        cos_theta = 1.0 - u.y*(1.0 - cos(lobe));\n  pdf = PDF_Glossy(lobe);\n  return To_Cartesian(cos_theta, phi);\n}\n\nfloat3 Sample_Glossy ( float3 wi, float3 N, out float pdf, float lobe,\n                       inout float seed ) {\n  return Reorient_Hemisphere(Sample_Uniform_Cone(lobe, pdf, seed),\n                             reflect(wi, N));\n}\n\nfloat3 Sample_Translucent ( float3 wi, float3 N, out float pdf, float lobe,\n                            float refr, inout float seed ) {\n  return Reorient_Hemisphere(Sample_Uniform_Cone(lobe, pdf, seed),\n                             refract(wi, N, refr));\n}\n\n//------------------------------------------------------------------------------\n//-------- MATERIALS -----------------------------------------------------------\n//------------------------------------------------------------------------------\n\nstruct Light {\n  float3 ori, emission;\n  float radius, SA;\n};\n\n#define LIGHTS_LEN 1\nLight lights[LIGHTS_LEN];\n\nvoid Construct_Light ( int idx, float3 ori, float3 emission, float radius ) {\n  lights[idx] = Light(ori, emission, radius, SQR(lights[idx].radius));\n}\n\nvoid Initialize_Lights ( ) {\n  lights[0].ori = float3(0.0, 4.98, -0.3);\n  lights[0].emission = float3(0.9, 0.9, 0.9)*25.0;\n  lights[0].radius = 1.0;\n  lights[0].SA = SQR(lights[0].radius);\n}\nstruct Material { float3 colour; int mat_type; float lobe; float refr; };\n\n#define MDIFFUSE 0\n#define MSPECULAR 1\n#define MTRANSMITTIVE 2\n#define MGLOSSY 3\n#define MTRANSLUCENT 4\n\nMaterial RMaterial ( float3 O, float idx ) {\n  if ( idx == 1.0 ) return Material(float3(0.3,  0.8, 0.3), MDIFFUSE,0.0,0.0 );\n  if ( idx == 2.0 ) return Material(float3(0.3,  0.3, 0.8), MDIFFUSE,0.0,0.0 );\n  if ( idx == 3.0 ) return Material(float3(0.5,  0.5, 0.5), MDIFFUSE,0.0,0.0 );\n  if ( idx == 4.0 ) return Material(float3(0.9,  0.5, 0.5), MDIFFUSE,0.0,0.0 );\n  if ( idx == 5.0 ) return Material(float3(0.5,  0.5, 0.5), MDIFFUSE,0.0,0.0 );\n  if ( idx == 6.0 ) return Material(float3(0.2,  0.2, 0.2), MDIFFUSE, 0.4, 0.8 );\n  if ( idx == 7.0 ) return Material(float3(0.9,  0.8, 0.1), MSPECULAR,0.0,0.0);\n  if ( idx == 11.0 ) {\n    if ( sin(O.x*2.0)*sin(O.y*2.0) >= 0.0 )\n      return Material(float3(0.01), MSPECULAR,0.0,0.0);\n    return Material(float3(1.0), MGLOSSY, 0.5,0.0);\n  }\n  if ( idx == 10.0 ) {\n    if ( sin(O.x*2.0)*sin(O.y*2.0) >= 0.0 )\n      return Material(float3(0.6), MTRANSMITTIVE,0.2,0.8);\n    return Material(float3(0.4), MTRANSLUCENT, 0.2,0.8);\n  }\n  return Material(float3(lights[0].emission), MDIFFUSE,0.0,0.0);\n}\n\n//------------------------------------------------------------------------------\n//-------- SHADER --------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nfloat Shell ( float dist, float r ) {\n  return abs(dist) - r*0.5;\n}\n\nfloat2 Map ( in vec3 o ) {\n  float2 res = float2(999.0);\n  //-----------wall--------\n  // left/right\n  Union(res, sdBox(o-vec3( 10.0,  0.0,  0.0), vec3(0.01, 15.00, 15.00)), 1.0);\n  Union(res, sdBox(o-vec3(-10.0,  0.0,  0.0), vec3(0.01, 15.00, 15.00)), 2.0);\n  // up/down\n  Union(res, sdBox(o-vec3( 0.0,  5.0,  0.0), vec3(15.00, 0.01, 15.00)), 3.0);\n  Union(res, sdBox(o-vec3( 0.0, -3.0,  0.0), vec3(15.00, 0.01, 15.00)), 4.0);\n  // back\n  Union(res, sdBox(o-vec3( 0.0,  0.0, -10.0), vec3(15.00, 15.00, 0.01)), 5.0);\n  Union(res, sdBox(o-vec3( 0.0,  0.0, 15.0), vec3(15.00, 15.00, 0.01)), 5.0);\n  //-----------boxes--------\n  // -- left box\n  vec3 to = o-vec3(-5.0, -1.0, -0.5);\n  opRotate(to.xz, -PI*0.22);\n  float bu = texture(iChannel0, abs(sin(o.xy))).x;\n  Union(res, sdBox(to, vec3(0.5+bu*0.4, 2.0, 0.6)), 6.0);\n  // -- right box\n  to = o-vec3(0.0, -1.0, 1.5);\n  opRotate(to.yz, 0.45);\n  to.y += cos(to.x*10.0)*0.008;\n  float mts = sdTorus(to, 0.5, 2.6);\n  Union(res, mts, 7.0);\n  // -- shell\n  \n  to = o-vec3(0.0, 0.0, -1.0);\n  float disp = sqrt(length(to));\n  opRotate(to.xy, PI*0.5);\n  mts = sdSphere(o, 2.0) + sin(o.x*5.0)*0.05;\n  Union(res, Shell(mts, 0.005)*0.5, 10.0);\n\n  to = o-vec3(0.0, 0.0, -1.0);\n  Union(res, sdSphere(to, 1.0), 11.0);\n  // to = o-vec3(0.0, 0.0, 0.0);\n  // Union(res, sdSphere(to, 2.7), 11.0);\n  //-----------light--------\n  Union(res, sdBox(o-lights[0].ori, vec3(lights[0].radius, 0.01, lights[0].radius)), 8.0);\n  //----\n  return res;\n}\n\nfloat3 BSDF_Sample ( float3 N, float3 wi, float3 P, Material mat, out float pdf,\n                     inout float seed) {\n  if ( mat.mat_type == MDIFFUSE )\n    return Sample_Cos_Hemisphere(wi, N, pdf, seed);\n  //specular\n  if ( mat.mat_type == MSPECULAR ) {\n    pdf = 1.0;\n    return reflect(wi, N);\n  }\n  if ( mat.mat_type == MTRANSMITTIVE ) {\n    pdf = 1.0;\n    return refract(wi, N, mat.refr);\n  }\n  if ( mat.mat_type == MGLOSSY ) {\n    return Sample_Glossy(wi, N, pdf, mat.lobe, seed);\n  }\n  if ( mat.mat_type == MTRANSLUCENT ) {\n    return Sample_Translucent(wi, N, pdf, mat.lobe, mat.refr, seed);\n  }\n}\n\nfloat3 BSDF_F ( float3 N, float3 wi, float3 wo, Material mat ) {\n  // just simple lambertian....\n  if ( mat.mat_type == MDIFFUSE )\n    return float3(IPI)*mat.colour;\n  if ( mat.mat_type == MSPECULAR ||\n       mat.mat_type == MTRANSMITTIVE ) return float3(1.0)*mat.colour;\n  if ( mat.mat_type == MGLOSSY || mat.mat_type == MTRANSLUCENT )\n    return float3(IPI)*mat.colour;\n}\n\nfloat BSDF_PDF ( float3 N, float3 wi, float3 wo, Material mat ) {\n  if ( mat.mat_type == MDIFFUSE )\n    return PDF_Cosine_Hemisphere(wi, N);\n  if ( mat.mat_type == MSPECULAR ||\n       mat.mat_type == MTRANSMITTIVE ) return -1.0;\n  if ( mat.mat_type == MGLOSSY ) {\n    // check in bounds\n    float3 NN = reflect(wi, N);\n    if ( dot(wo, NN) < cos(mat.lobe) ) return -1.0;\n    return PDF_Glossy(mat.lobe);\n  }\n  if ( mat.mat_type == MTRANSLUCENT ) {\n    float3 NN = refract(wi, N, mat.refr);\n    if ( dot(wo, NN) < cos(mat.lobe) ) return -1.0;\n    return PDF_Glossy(mat.lobe);\n  }\n}\n\n//   /*\n//     Láµ¢(T)(P, Ïáµáµ¢) if ( T == (B)RDF || T == (E)mitter ) =\n//       Láµ¢(P, Ïáµáµ¢)*Fâ(P, Ïáµáµ¢ â Ïâ)*cosÎ¸áµ¢\n//       ââââââââââââââââââââââââââââââââ +\n//          pá´±(Ïáµáµ¢) + Pá´®(Ïáµáµ¢)\n\n//     Lâ = Lâ(P, Ïá´±â) + Láµ¢(P, Ïá´®â)\n//   */\nfloat3 Sample_Emitter ( float3 O, inout float seed ) {\n  float3 lorig = normalize((Sample_Uniform3(seed)-0.5)*2.0);\n  lorig *= float3(lights[0].radius, 0.01, lights[0].radius);\n  lorig += lights[0].ori;\n  return normalize(lorig - O);\n}\n\nfloat REmit_PDF ( float3 Ln, float3 On, float3 wo, float dist ) {\n  return ((1.0/lights[0].SA) * (abs(dot(Ln, -wo)*dot(On, wo))))/\n         SQR(dist);\n}\n\nint Illumination ( inout float3 O, float3 N, float3 wi, inout float3 bsdf_wo,\n                   Material mat, inout float3 radiance,\n                   inout float3 direct_radiance, inout float seed ) {\n  int return_enum = 0;\n  float bsdf_pdf, emit_pdf;\n  bsdf_wo = BSDF_Sample(N, wi, O, mat, bsdf_pdf, seed);\n  float2 bsdf_res = March(Ray(O+bsdf_wo*0.1, bsdf_wo));\n  //---radiance---\n  float3 prev_radiance = radiance;\n  radiance *= (BSDF_F(N, wi, bsdf_wo, mat)*abs(dot(N, wi)))/bsdf_pdf;\n\n  //---indirect---\n  if ( bsdf_res.x < 0.0 ) return -1;\n  if ( bsdf_res.y == 8.0 ) {\n    float3 Lo = O + bsdf_wo*bsdf_res.x,\n           Ln = float3(0.0, -1.0, 0.0);\n    emit_pdf = REmit_PDF(Ln, N, bsdf_wo, bsdf_res.x);\n    float3 dr = lights[0].emission * BSDF_F(N, wi, bsdf_wo, mat) * prev_radiance;\n    // balanced heuristic\n    dr *= float3(bsdf_pdf/(bsdf_pdf+emit_pdf));\n    direct_radiance += clamp(dr, float3(0.0), float3(1.0));\n    return 2;\n  }\n  //---direct---\n  float3 emit_wo = Sample_Emitter(O, seed);\n  float2 emit_res = March(Ray(O+emit_wo*0.01, emit_wo));\n                            \n  bsdf_pdf = BSDF_PDF(N, wi, emit_wo, mat);\n  if ( emit_res.y == 8.0 && bsdf_pdf > 0.0 ) {\n    float3 Lo = O + emit_wo*emit_res.x,\n           Ln = float3(0.0, -1.0, 0.0);\n    emit_pdf = REmit_PDF(Ln, N, emit_wo, emit_res.x);\n    float3 dr = lights[0].emission * BSDF_F(N, wi, emit_wo, mat) * prev_radiance;\n    // balanced heuristic\n    dr *= emit_pdf/(bsdf_pdf+emit_pdf);\n    direct_radiance += clamp(dr, float3(0.0), float3(1.0));\n    if ( return_enum != 2 )\n      return_enum = 1;\n  }\n\n  // prepare origin\n  O = O + bsdf_wo * bsdf_res.x;\n  return return_enum;\n}\n\nint Propagate ( inout float3 radiance, inout float3 indirect_radiance,\n                inout Ray eye, inout float seed ) {\n  float2 res = March(eye);\n\n  //-- accumulate radiance --\n  if ( res.x < 0.0 ) return 0;\n  //-- gather material and reflection information --\n  float3 O  = eye.ori + eye.dir*res.x,\n         N  = Normal(O),\n         wi = eye.dir,\n         wo;// to be calculated by direct light contribution\n  Material mat = RMaterial(O, res.y);\n  int return_enum = Illumination(O, N, wi, wo, mat, radiance, indirect_radiance,\n                                 seed);\n  //-- prepare for next propagation --\n  eye.ori = O+wo*0.01;\n  eye.dir = wo;\n\n  return return_enum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float2 uv = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n  uv.x *= iResolution.x/iResolution.y;\n\n  float seed = uv.x + uv.y*3.829614823 + fract(3.19520814*iTime);\n\n  Ray eye = Look_At(uv);\n  fragColor = float4(0.0);\n  float3 radiance          = float3(1.0),\n         indirect_radiance = float3(0.0);\n\n  Initialize_Lights();\n\n  int hit = 0;\n  for ( int i = 0; i != 5; ++ i ) {\n    int res = Propagate(radiance, indirect_radiance, eye, seed);\n    if ( res == 1 ) {\n      hit = 1;\n    }\n    if ( res == 2 ) {\n      hit = 1;\n      break;\n    }\n    if ( res == -1 ) break;\n  }\n\n  fragColor.xyz = indirect_radiance;\n  #ifdef ROTATAL\n  fragColor.w = 0.0;\n  #else\n  fragColor.w = hit==1 ? 1.0 : 0.0;\n  #endif\n}\n\n//------------------------------------------------------------------------------",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  \n    // vec4( camAngx , camAngy , timeWhenStoppedMoving , 0);    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 old = texture(iChannel0, uv);\n    \n    if( iMouse.z > 0.0 )\n        old = vec4( (iMouse.z-iMouse.x)/100.0 ,\n                    (iMouse.w-iMouse.y)/250.0 , float(iFrame) , 0.0);\n    \n    fragColor = old;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define SAMPLES 64.0\n#define COLLECT\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 xy = gl_FragCoord.xy/iResolution.xy;\n  float f_delta = float(iFrame) - texture(iChannel2, vec2(0.5)).z;\n\n  vec4 c0 = texture(iChannel0, xy),\n       c1 = texture(iChannel1, xy);\n\n  if ( f_delta <= 1.0 ) {\n    c1 = fragColor = vec4(0.0);\n  }\n    \n  #ifndef COLLECT\n    if ( c0.w != 0.0 )\n      fragColor = vec4(c0.xyz, 1.0);\n  #else\n  if ( c0.w == 0.0 || c1.w >= 1.0 ) { // miss/end\n    fragColor = c1;\n  } else {\n    float t = c1.w*SAMPLES; // 0.01 => 1.0, 1.0 => 100.0\n    fragColor.xyz = mix(c0.xyz, c1.xyz, (t/(t+1.0)));\n    fragColor.w = c1.w+(1.0/SAMPLES);\n  }\n  #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}