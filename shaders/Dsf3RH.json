{
    "Shader": {
        "info": {
            "date": "1665618022",
            "description": "Added a glow around the sun and sun disc. Still quite simple, and totally non physically based but it looks super good! Mouse moves the sun",
            "flags": 0,
            "hasliked": 0,
            "id": "Dsf3RH",
            "likes": 11,
            "name": "Sky Gradient improved",
            "published": 3,
            "tags": [
                "gradient"
            ],
            "usePreview": 0,
            "username": "fishy",
            "viewed": 482
        },
        "renderpass": [
            {
                "code": "// Sky Gradient by Hazel Quantock\n#define sphere false\n#define ground true\n\nmat2 rotMat(float r){ return  mat2(cos(r), -sin(r), sin(r), cos(r)); }\n\n\nvec3 rotX(vec3 p, float r)\n{\n    return vec3(p.x, p.yz * rotMat(r));\n}\n\nvec3 aces_tonemap(vec3 color) // https://www.shadertoy.com/view/XsGfWV\n{\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nvec3 skyTex(vec3 ray, vec3 sun)\n{\n    //ray.y = abs(ray.y);\n    float raySun = dot(ray,sun);\n    \n    vec3 col = exp2(-(ray.y-raySun*0.5)/vec3(.1,.3,.6)); // Base gradient\n    col *= sqrt(max(0.00001, dot(vec3(sun.x, sun.y+0.3, sun.z), vec3(0.0, 1.0, 0.0)))); //Darken the sky the lower the sun is\n    return mix(col, vec3(10.0, 3.0, 0.2), smoothstep(0.9995, 1.0, max(0.0, raySun))) * sqrt(max(0.0, (dot(ray, vec3(0.0, 1.0, 0.0))))); // Sun disc\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ray;\n    ray.xy = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    ray.z = .7;\n\tray.z -= dot(ray.xy,ray.xy)*.5; // fisheye lens\n    ray = normalize(ray);\n    \n    // tilt upwards\n    vec3 k = normalize(vec3(0,sphere?-.5:.8,1));\n    vec3 i = normalize(cross(vec3(0,1,0),k));\n    vec3 j = cross(k,i);\n    ray = ray.x*i+ray.y*j+ray.z*k;\n    \n    if ( sphere )\n    {\n        // reflect ray off sphere\n        vec3 c = k*1.8;\n        float t = dot(c,ray);\n        float t2 = sqrt(dot(c,c)-t*t);\n        if ( t2 < 1. )\n        {\n            t -= sqrt(1.-t2*t2);\n            vec3 n = ray*t-c;\n            ray = reflect(ray,n);\n        }\n    }\n    \n    vec3 tint = vec3(1);\n    \n    float mouse = -iMouse.y/iResolution.y;\n    \n    if(iMouse.x == (0.0))\n    {\n        mouse = (sin(iTime)/8.-0.2);\n    }\n\n    vec3 lDir = rotX(vec3(0.0, 0.0, 1.0), mouse*5.0 + 0.5);\n\n    fragColor.rgb = aces_tonemap(skyTex( ray, lDir ));\n\n\t// signature\n\t#define L(m,n,u,v,l,f) min(f,max(abs(dot(fragCoord-vec2(m,n),vec2(u,v)))-l,abs(dot(fragCoord-vec2(m,n),vec2(-v,u)))-1.))\n\tfloat sig=L(3,7,0,1,3.5,L(7,7,0,1,3.5,L(5,7,1,0,2.,L(14.5,5,.7071,-.7071,2.5,abs(length(fragCoord-vec2(12.7,7))-3.)-1.))));\n    fragColor.rgb = .6+(clamp(fragColor.rgb,0.,1.)-.6)*sig/(.1+abs(sig));\n    \n    fragColor.rgb = fragColor.rgb;\n    fragColor.a = 1.;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}