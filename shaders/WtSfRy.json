{
    "Shader": {
        "info": {
            "date": "1599306817",
            "description": "Fake post-processing smoke colorshifted.",
            "flags": 32,
            "hasliked": 0,
            "id": "WtSfRy",
            "likes": 5,
            "name": "Fake smoke colorshift",
            "published": 3,
            "tags": [
                "2d",
                "postprocessing",
                "fake",
                "fluid",
                "smoke",
                "feedback"
            ],
            "usePreview": 0,
            "username": "Jaromir",
            "viewed": 722
        },
        "renderpass": [
            {
                "code": "//bufA = fake smoke post-processing effect\n//bufB = postProccesing slide\n//bufC = raymarching swirly lines\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 smoke = texture(iChannel0,uv)-0.05;\n    vec4 shape = texture(iChannel1,uv);\n    float mask = length(shape.rgb*10.);\n    \n    vec4 col = smoke-mask;\n    col.rgb = pow(col.rgb,vec3(0.4545));\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define M_PI 3.14159265359\n#define M_TWOPI 6.28318530718\n\nmat2 rot(float a)\n{\nreturn mat2(\n  cos(a), sin(a),\n  -sin(a), cos(a)\n  );\n}\n\nfloat hash11(float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise31(in vec3 n)\n{\n\tvec3 p = floor(n);\n    vec3 f = fract(n);\n    f = f*f*(3.-2.*f);\n    float q = p.x+p.y*57.+p.z*113.;\n    float r = mix(mix(mix(hash11(q+0.),hash11(q+1.),f.x),\n                      mix(hash11(q+57.),hash11(q+58.),f.x),f.y),\n                  mix(mix(hash11(q+113.),hash11(q+114.),f.x),\n                      mix(hash11(q+170.),hash11(q+171.),f.x),f.y),f.z);\n    return r;\n}\n\nfloat fbm(vec3 x, in float H ){//iq's fbm    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<6; i++ )\n    {\n        x.xy*=rot(0.2*M_PI);\n        t += a*noise31(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\nvec2 poltocar(float magnitude, float angle) {\n\tfloat x = magnitude * cos(angle);\n\tfloat y = magnitude * sin(angle); \n\treturn vec2(x, y);\n}\n\n//from https://www.shadertoy.com/view/XljGzV\nvec3 rgb2hsl( vec3 c ){\n  float h = 0.0;\n\tfloat s = 0.0;\n\tfloat l = 0.0;\n\tfloat r = c.r;\n\tfloat g = c.g;\n\tfloat b = c.b;\n\tfloat cMin = min( r, min( g, b ) );\n\tfloat cMax = max( r, max( g, b ) );\n\n\tl = ( cMax + cMin ) / 2.0;\n\tif ( cMax > cMin ) {\n\t\tfloat cDelta = cMax - cMin;\n        \n        //s = l < .05 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) ); Original\n\t\ts = l < .0 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) );\n        \n\t\tif ( r == cMax ) {\n\t\t\th = ( g - b ) / cDelta;\n\t\t} else if ( g == cMax ) {\n\t\t\th = 2.0 + ( b - r ) / cDelta;\n\t\t} else {\n\t\t\th = 4.0 + ( r - g ) / cDelta;\n\t\t}\n\n\t\tif ( h < 0.0) {\n\t\t\th += 6.0;\n\t\t}\n\t\th = h / 6.0;\n\t}\n\treturn vec3( h, s, l );\n}\n\nvec3 hsl2rgb(vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 oUv = fragCoord.xy/iResolution.xy;\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;    \n    \n    vec4 s = texture(iChannel1,oUv);\n    \n    float scale = 7.;\n    vec3  p = vec3(uv*scale,iTime);\n    float n = fbm(p,1.);\n    \n    float mag =  1.5;\n    vec2 v = poltocar(n*mag,n*M_TWOPI)/iResolution.xy;\n    oUv+=v;    \n\n    \n    float feedback = 0.923;\n    vec4 t = texture(iChannel0,oUv);\n    vec4 oT = t;\n    t.rgb = rgb2hsl(t.rgb);\n    //shift color\n    t.rgb+=vec3(0.33,0.9,0.01);\n    \n    t.rgb = mix(hsl2rgb(t.rgb),oT.rgb,0.93);\n   \n\n    \n    fragColor = s+t*feedback;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float decay = 0.1;\n    \n    vec2 oUv = fragCoord.xy/iResolution.xy;\n    \n    vec4 t1 = texture(iChannel0,oUv);\n    vec4 t2 = texture(iChannel1,oUv);\n\n    vec4 sOut = vec4(0.);\n    \n\tsOut = ((t1 - t2) * decay) + t2;\n    sOut = clamp(sOut,-1.,1.);\n    \n    fragColor = sOut;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define MAX_STEPS 64\n#define MAX_DIST  100.\n#define SURF_DIST .01\n\nmat2 rot(float a)\n{\nreturn mat2(\n  cos(a), sin(a),\n  -sin(a), cos(a)\n  );\n}\n\n//from iq https://iquilezles.org/articles/distfunctions\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat getDist(vec3 p){\n\n  vec3 rotPos = p;\n  rotPos.xz*=rot(-p.y*0.8+iTime);\n  rotPos.x+=cos(p.x*1.  +iTime*0.5);\n  rotPos.x+=cos(p.x*.5  +iTime*0.2);\n  rotPos.x+=sin(p.x*.25 +iTime*0.1);\n\n  rotPos = mix(rotPos,p,0.2+sin(iTime)*0.1);\n\n  float shape = sdLink(rotPos,10.,p.y*0.2+1.,abs(sin(p.y+iTime)*0.05+0.01));\n  shape*=0.5;\n\n  return shape;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd){\n  float dO = 0.;\n  float dS;\n\n  for(int i = 0; i < MAX_STEPS; i++){\n    vec3 p = ro + dO * rd;\n    dS = getDist(p);\n    dO += dS;\n    //if(dS < 0.01 || dO > MAX_DIST) break; //slightly cheaper but with some artefacts\n    if(abs(dS) < SURF_DIST || dO > MAX_DIST) break;\n\t\n  }//for\n\n  return dO;\n}\n\nvec3 getNormal(vec3 p){\n  vec2 e = vec2(0.01, 0.);\n\n  vec3 n = getDist(p) - vec3(\n    getDist(p-e.xyy),\n    getDist(p-e.yxy),\n    getDist(p-e.yyx)\n  );\n\n  return normalize(n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;    \n\n    \n    uv*=rot(iTime*0.334);\n    \n    vec3 ro = vec3(0.,0.,-3.);\n\n      \n    vec3 rd = normalize(vec3(uv,1.));\n\n\tfloat d = rayMarch(ro,rd);\n\n    vec4 col = vec4(0.);\n    \n    if(d < MAX_DIST){\n\n\t  vec3 p = ro + rd *d;\n\t  vec3 n = getNormal(p);\n\t\t\t  \n\t  col.rgb = mix(vec3(0.5,0.3,0.),vec3(0.1,0.3,.3),n.z);\n\n\t}\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}