{
    "Shader": {
        "info": {
            "date": "1698649832",
            "description": "Click to show grid & to control spot.\ncheckerboarded+noised alternating ꓕT-crossing & whiteMask pushes T-intersections to the top/Right\nnow with hexes, because https://www.youtube.com/watch?v=Lgio_ygetbo\nIntended for lookup with floats.",
            "flags": 0,
            "hasliked": 0,
            "id": "DsGBDK",
            "likes": 22,
            "name": "Moving GilbertTesselat┣┳┻┫ꓕTiles",
            "published": 3,
            "tags": [
                "grid",
                "random",
                "animated",
                "animation",
                "t",
                "blocks",
                "double",
                "morph",
                "spot",
                "regular",
                "alternating",
                "irregular",
                "asymmetric",
                "symmetric"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 271
        },
        "renderpass": [
            {
                "code": "//#define zoom 2. already exists, called scale, not oto be confused with time_scale\n\n#define RipplesOscillate\n//oscillate between circle and ripples, for eccect-amplitude\n\n#define innerCircleRadius 2.5\n#define transitionRadius  5.\n//outerCircleradius=innerCircleRadius+transitionRadius\n//negative innerCircleRadius -> lower peak, aborted transition\n//negative transitionRadius  -> valley instead of hill\n//transitionRadius also limits==sets to/by how much ANY rectangle is stretched|squashed\n//as long as transitionRadius!=0, triangles will never be squashed down to 0.\n\n//#define linearMixOnly\n//define in to have it soimple, fast, linear only (unclamped)\n//undefine to add at least 50% smoothstep (only smoothstep is clamped)\n\n// https://www.shadertoy.com/view/mdyfD1 asymmetric blocks w regular spot, 2023 by jt\n// based on https://www.shadertoy.com/view/dstfzf asymmetric blocks compactified float\n\n// Change the regularity in the pattern of\n// random-blocks-by-alternating-double-T-crossings\n// (aka asymmetric/irregular)\n// based on distance to \"spotlight\" position.\n// This implementation is intended for lookup with floats.\n// Click to show grid & control spot.\n// Click to lower left returns to demo mode.\n\n// This can be used to place windows into walls of asymmetric blocks:\n// see https://www.shadertoy.com/view/dtl3Wf Asymmetric Blocks Wall\n\n// tags: random, t, blocks, double, alternating, irregular, asymmetric, morph, grid, animation, animated, regular, symmetric\n\n// The MIT License\n// Copyright (c) 2023 Jakob Thomsen\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define time_scale 10.0\n\n#define pi 3.1415926\n\n// https://www.shadertoy.com/view/WttXWX \"Best\" Integer Hash by FabriceNeyret2,\n// implementing Chris Wellons https://nullprogram.com/blog/2018/07/31/\nuint triple32(uint x) // calculate two hashes in parallel\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\n//// Wellons lowbias32 from http://nullprogram.com/blog/2018/07/31\n//// perhaps the best ever devised for this op count, great distribution and cycle\n//uint lowbias32(uint x)\n//{\n//    x ^= x >> 16;\n//    x *= 0x7feb352du;\n//    x ^= x >> 15;\n//    x *= 0x846ca68bu;\n//    x ^= x >> 16;\n//    return x;\n//}\n\n#define HASH(u) triple32(u)\n//#define HASH(u) lowbias32(u)\n\nuint uhash(ivec2 v, bool choose)\n{\n//return uvec2(0u); // verify grid alignment\n    return HASH((uint(v.x)*2u+uint(choose) + HASH(uint(v.y)*2u+uint(choose))) /*+ uint(iFrame / 120)*/);\n}\n\nvec2 hash22(vec2 p) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nstruct block\n{\n    vec2 center;\n    vec2 extent;\n    ivec2 id;\n};\n\n#define RES 8\n\n#define scale (float(RES*12))\n\n//to get a smoothstepped grid: uv=smoothstep(-.1,.1,ss2t(fract(uv*gridSize/iResolution.xy)))\n//ss2t() turns a seesaw wave to triangle wave\n#define ss2t(a) a=abs(a*2.-1.)\n\n\n#define sat(a) clamp(a,0.,1.)\n#define applyRadii(r) r=sat((r-innerCircleRadius)/transitionRadius)\n\n//from https://www.shadertoy.com/view/wtdSzX\n#ifdef FLAT_TOP_HEXAGON\nconst vec2 shiiit = vec2(1.7320508, 1);\n#else\nconst vec2 shiiit = vec2(1, 1.7320508);\n#endif\n// The 2D hexagonal isosuface function: If you were to render a horizontal line and one that\n// slopes at 60 degrees, mirror, then combine them, you'd arrive at the following. As an aside,\n// the function is a bound -- as opposed to a Euclidean distance representation, but either\n// way, the result is hexagonal boundary lines.\nfloat hex(in vec2 p\n){p = abs(p);    \n    #ifdef FLAT_TOP_HEXAGON\n    return max(dot(p, shiiit*.5), p.y);} // Hexagon.\n    #else\n    return max(dot(p, shiiit*.5), p.x);} // Hexagon.\n    #endif    \n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID -- in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything -- in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\n\nvec4 getHex(vec2 p)\n{   // The hexagon centers: Two sets of repeat hexagons are required to fill in the space, and\n    // the two sets are stored in a \"vec4\" in order to group some calculations together. The hexagon\n    // center we'll eventually use will depend upon which is closest to the current point. Since \n    // the central hexagon point is unique, it doubles as the unique hexagon ID.\n  \n    #ifdef FLAT_TOP_HEXAGON\n    vec4 hC = floor(vec4(p, p - vec2(1, .5))/shiiit.xyxy) + .5;\n    #else\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/shiiit.xyxy) + .5;\n    #endif\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*shiiit, p - (hC.zw + .5)*shiiit);\n    \n    \n    // Nearest hexagon center (with respect to p) to the current point. In other words, when\n    // \"h.xy\" is zero, we're at the center. We're also returning the corresponding hexagon ID -\n    // in the form of the hexagonal central point.\n    //\n    // On a side note, I sometimes compare hex distances, but I noticed that Iomateron compared\n    // the squared Euclidian version, which seems neater, so I've adopted that.\n    return dot(h.xy, h.xy) < dot(h.zw, h.zw) \n        ? vec4(h.xy, hC.xy) \n        : vec4(h.zw, hC.zw + .5);\n}\n\nfloat spot(vec2 v){//the actual whiteness\n   bool demo = !any(greaterThan(vec2(iMouse), vec2(10))); //= iMouse.z <0.;\n    //bool demo = any(lessThan(vec2(iMouse), vec2(10)));\n    float speed=pi*3.;\n    if(demo)\n        v -= vec2(cos(speed*iTime/time_scale)\n                , sin(speed*iTime/time_scale) )*scale/vec2(RES);\n    else   {\n        // hacky screenspace mouse\n        vec2 R = iResolution.xy;\n        vec2 m = iMouse.xy;\n        m = (2.0 * m - R) / R.y;\n        v -= m * scale/float(RES);    }\n\n\n\n    float r=length(v);//a circle pattern for effect-strenght\n        \n    #ifdef RipplesOscillate\n    float R=r;\n    R*=.2;\n    R=fract(R);\n    R=ss2t(R);\n    R*=9.;\n    //applyRadii(r);                            //single circle\n    applyRadii(R);                              //multiple rings\n    r=sat(abs(sat(hex(getHex(v*.1).xy))-.5)*4.);//hexagonal grid\n    r=mix(r,R,-cos(iTime*.5)*.5+.5);\n    #else \n\n    applyRadii(r);\n    #endif\n \n        return r;\n}\n\n\nfloat whiteEffect(ivec2 d,ivec2 t,int x,bool choose,bool mirror,inout float m){//poorly named function\n//this ewqas turned into a subroutine to understand it, but THAT was all mostly useless.\n     m=spot(vec2(t+d));\n\n    //vec2 r = fract(hash22(vec2(t+d)))+vec2(d); // float hash\n    //return choose?r.y:r.x;\n    float r = fract(float(uhash(t+d, choose) % uint(RES))/float(RES))+float(choose?d.y:d.x); // integer hash with fixed resolution\n    \n    float h=float(choose?d.y:d.x);\n    \n    #ifdef linearMixOnly\n    //h= mix(h+1.,h-1.,m*.5)*.5;\n    #else \n    //h=hex(vec2(t+d))*.5;\n    return h;}\n\n\nfloat block_hash(ivec2 t, int x, int y, bool choose, bool mirror)\n{\n    float m = 1.0;\n    ivec2 d = (mirror?ivec2(y, x):ivec2(x, y));\n    //if(all(lessThanEqual(abs(t+d), ivec2(2))))\n    //if(length(vec2(t+d)) < 2.5)\n    //    //return float(choose?d.y:d.x);\n    //    m = 0.;\n    float h=whiteEffect(d,t,x,choose,mirror,m);\n    //at least 50% smoothstep. the final result is clamped afterwards (discontinuity)\n    h= mix(h+1.,h-1.,m*.5)*.5;\n    h+=smoothstep(0.,.5,h)*.5;  //dodo: i fail to get 100% smoothtep?\n    #endif\n    //becausde smoothstep includes a clamp that mix() does not have\n    //and that clamping causes artefacts.\n    return h;\n}\n\n// Inspired by https://www.shadertoy.com/view/Ws3GRs Asymmetric Blocks by Shane.\n// Checkerboard tiling of alternating (horizontal vs. vertical) (double-T-) crossings.\n// Returns minimum, maximum, id.\n// Compactified using implicit matrix transpose & deferred hash calls.\n//(NOTE: inlining the hash-function and using out parameters instead of block structure\n//       could be used to turn this into a stand-alone function.)\nblock blocks_layout(vec2 p) // https://www.shadertoy.com/view/dstfzf asymmetric blocks compactified f by jt\n{\n    ivec2 tile = ivec2(floor(vec2(p))); // global coordinates of tile\n    vec2 local = fract(p);\n\n    //bool flip = (tile.x % 2) != (tile.y % 2); // XXX breaks on windows XXX\n    bool flip = (tile.x & 1) != (tile.y & 1); // alternate direction of double T crossings: vertical or horizontal\n    //flip = !flip; // \"dual\" pattern (i.e. T-crossings flipped)\n    \n    // layout (NOTE: matrix notation upside down compared to coordinate system!)\n    // NW N NE\n    //  W C E\n    // SW S SE\n       \n    // transposed (NOTE: matrix notation upside down compared to coordinate system!)\n    // SE W NE\n    //  N C S\n    // SW E NW\n    \n    if(flip) // horizontal line goes through: swap vertical with horizontal\n    {\n        // swap components\n        local = local.yx;\n    }\n\n    // vertical line goes through (on flip transpose for horizontal line)\n\n    //                 c\n    //   +-+---------+---+-------+\n    //   | |         |   |       |\n    //   | |         |   #-------+ d\n    // d +-#-#-------+---M       |\n    //   |   |       |   |       |\n    //   +---+-------+---+-------+\n    //   |   |       |   |       |\n    //   |   m-------+---#---#---+\n    //   +---#       |       |   |\n    //   |   |       |       |   |\n    //   +---+-------+-------+---+\n    float c = block_hash(tile, 0, 0,  flip, flip); // offset of central line\n    int x = 1-int(local.x < c); // [0,1]\n    int X = 2*x-1; // [-1,+1]\n    float d = block_hash(tile,+X, 0, !flip, flip); // offset of branching line\n    int y = 1-int(local.y < d); // [0,1]\n    int Y = 2*y-1; // [-1,+1]\n\n    vec2 v0 =vec2(c,d);   // primary corner in (0,0) tile\n    vec2 v1 =        vec2(       \n            block_hash(tile,X,Y, flip, flip),\n            block_hash(tile,0,Y,!flip, flip));     // primary corner in (X,Y) tile\n    if(flip) tile = tile.yx;\n    v0 += vec2(tile);\n    v1 += vec2(tile);\n    ivec2 id = tile + ivec2(x,y);\n    if(flip){// horizontal line goes through: unswap vertical with horizontal\n        v0 = v0.yx;\n        v1 = v1.yx;\n        id = id.yx;    }\n    bool flag = v0.y > v1.y;\n    // fix order of min/max corners\n    vec2 center = (v0.xy+v1.xy)/2.0;\n    vec2 extent = abs(v0.xy-v1.xy)/2.0;\n    return block(center, extent, id);}\n\nvec3 hash32(vec2 p) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) // https://iquilezles.org/articles/distfunctions2d/\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 colorize(ivec2 id){\n    vec3 color = hash32(vec2(id));\n    if(((id.x^id.y)&1)==0)\n        color = 1.0 - color;\n    return color;}\n\n\n\n//i forgot how to use p,mod here, and remembered, all I need is ss2t() instead:\n/*\n#define vec1 float\n//domain-general pmod():\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)\n    //repetitive only for less repetitive legacy namespace support.\n/*\n//hg_sdf pmod extensions of https://www.shadertoy.com/view/4ttyDN\n//problem, pMod alone has no good efficient interval bound with gradients outside of the bound interval\n//pmodInterval() exists, but it has (numerically) bad branches.\n//pModr() fixes this\n//[s] sets period-length, n sets number of [c0 discontinuities] == [tileBorderCount]\nfloat pmod(inout float u,float s){float r=floor(u/s+.5);u=fract(u/s+.5)*s;return r;} //http://mercury.sexy/hg_sdf/                 \nvec2 pmod(inout vec2 u,vec2 s){vec2 r=floor(u/s+.5);u=fract(u/s+.5)*s;return r;} //http://mercury.sexy/hg_sdf/                 \n//vec2 pMod(vec1 u,vec1 s){return vec2( ff(u/s+.5)*vec2(s,1));}//silly variant\nvec1 pModr(inout vec1 p,vec1 s,vec1 n//n==number of repeats (discontinuities), where the smallest discontinuity is at [s]\n){float q=p,f=pmod(q,s);p=p+.5*s;vec2 r=vec2(mix(mix(q,p-s*n,step(n,f)),p,step(f,0.)),clamp(f,0.,n))\n ;p=r.x;return r.y;}\n//for u<0 and u>s*n the space condinues linearily, without repetition, this is different from hg_sdf.\n//it also does not set a start, you must just shift u instead\nfloat pModR(inout float p,vec1 s,vec1 n){float r=pModr(p,s,n);p-=s*.5;return r;}//offset the output for more utility.\n//minor flaw; for s==0. special linear case, it still splits a line in 2 segments.\n*/\n\n//i failed to use euclideanbeat instead of ss2t()\n//Because i could not get the scaling right.\n//,euclideanbeat is THE best hairline-grid function\n//,becauseits hauirlines do not vanish on smaller respolutions (unless used wrongly)\n\n#define u5(a) ((a*.5)+.5)\n\nvoid mainImage(out vec4 fragColor, in vec2 p){\n    vec2 R = iResolution.xy;\n    vec2 P=p;\n    p = (2.0 * p - R) / R.y;\n\n    //p+=.2;\n    //vec2 m = (2.0 * iMouse.xy- R) / R.y;\n\n    block b = blocks_layout(p*scale/vec2(RES));\n    b.center *= float(RES);\n    b.extent *= float(RES);\n\n    vec3 color = colorize(b.id);\n    //color *= spot(p*scale/vec2(RES));\n    \n    color = mix(max(color, 1.0-spot(p*scale/vec2(RES))),color,u5(sin(iTime*.1*u5(sqrt(5.)))));//white overlay\n    \n    //color = mix(vec3(color.x+color.y+color.z)/3.0, color, spot(p*scale/vec2(RES)));\n    //color = mix(1.0-color, color, spot(p*scale/vec2(RES)));\n    \n    // differences between pixel-position and corners\n    vec2 q0 = p-vec2(b.center-b.extent)/scale;\n    vec2 q1 = p-vec2(b.center+b.extent)/scale;\n    // visualize edges\n    float a=0.005/scale*32.;\n    float e=0.01/scale*32.;\n    color = min(color, vec3(smoothstep(a,e,+q0.x)));\n    color = min(color, vec3(smoothstep(a,e,+q0.y)));\n    color = min(color, vec3(smoothstep(a,e,-q1.x)));\n    color = min(color, vec3(smoothstep(a,e,-q1.y)));\n\n    if(iMouse.z > 0.0)    {\n        //snoothed grid!\n        vec2 q = fract(p*scale/float(RES)+.5);\n        q=ss2t(q);\n        q*=2.;//optionally steeper slope dims the gradient out faster, leaving  a black square instead of a black dot.\n        q=smoothstep(-.2,.2, q);//essential for smaller resolutions\n        //q=sqrt(q);   //optionally more exponential\n        color -= vec3(1.-min(q.x, q.y))*.5; //ADD grid+background\n        /*\n        #ifdef checkerboard \n        lazy slow GLOBAL checkerboard\n        vec2 r = p*scale/2.0;\n        color *= mix(0.5, 1.0, step(0.0, sin(r.x*pi*2.0)*sin(r.y*pi*2.0))); // checker\n        #endif \n        /**/\n    }\n    \n    color = sqrt(color);\n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}