{
    "Shader": {
        "info": {
            "date": "1513203854",
            "description": "Demo of algorithm for brick pattern (for simple raymarcher)\nsimulation of siren light\n\nThe annoying thing about this is that at the edge of the light I get some weird aliasing effects, probably a loss precision when doing all the normal calculations etc\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "XlXBWS",
            "likes": 3,
            "name": "brick pattern, hashing, siren",
            "published": 3,
            "tags": [
                "raymarch",
                "glow",
                "brick"
            ],
            "usePreview": 0,
            "username": "benhardy",
            "viewed": 627
        },
        "renderpass": [
            {
                "code": "\nvec3 ORIGIN = vec3(0,0,0);\nvec3 BRICK_REPEAT = vec3(2,1,1);\nfloat BRICK_GAP = 0.01;\nfloat BRICK_ROUNDING = 0.05;\nvec3 BRICK_SIZE = vec3(0.43, 0.40, 0.43);\n\nvec3 light_1_position = vec3(5, 5.25, 5);\nvec3 light_2_position = vec3(-7, 2, -6);\nvec3 light_1_color = vec3(1,1,1);\nvec3 light_2_color = vec3(1,1,0);\nfloat light_1_power = 100.0;\nfloat light_2_power = 1000.0;\n\nvec3 ball_position = vec3(13,3.5,0);\nfloat ball_radius = 3.0;\n\nfloat light_radius = 0.3;\n\n#define MAX_STEP 400\n#define MAX_DIST 150.0\n#define STEP_RATIO 0.5\n#define EPSILON 0.001\n\n//shadows *really* slow things down\n//#define SHADOWS\n\n#define SHADOW_HARDNESS 1.0\n\nint brick_hash(vec2 where) {\n\tint brick_id = 1877*int(where.x) + 4095 * int(where.y);\n    return brick_id % 17;\n}\n\n\nfloat measure_to_building(vec3 global_where) {\n    vec3 local_where = mod(global_where - vec3(25,0,25), 80.0);\n    vec3 bl = abs(local_where) - vec3(40,20,40);\n    return length(max(bl, ORIGIN));\n\t\n}\n\nfloat measure_to_brick(vec3 where) {\n    float brick_row_bump = floor(mod(where.z,2.0));\n\n    vec3 local = vec3(\n        mod(where.x, 1.0) - 0.5,\n        where.y,\n        mod(where.z, 1.0) - 0.5\n    );\n    vec3 bases = where - local;\n\n    int hash = brick_hash(bases.xz);\n    vec2 other = where.zx;\n    int p = brick_hash(other);\n    float sin_bump = float(p);\n    local.y -= 0.01  * sin(iTime + sin_bump) * float(hash);\n    vec3 block = max(ORIGIN, abs(local)-BRICK_SIZE);\n    return length(block) - BRICK_ROUNDING;\n}\n\nfloat measure_to_light_1(vec3 where) {\n    return length(where - light_1_position) - light_radius;\n}\nfloat measure_to_light_2(vec3 where) {\n    return length(where - light_2_position) - light_radius;\n}\n\n// really it's a bowl\n\n#define PI 3.141592654\n\nfloat measure_to_ball(vec3 global_where) {\n    // get some radial symmetry going\n    float radius = length(global_where.xz);\n    float angle = atan(global_where.x, global_where.z) + PI;\n    angle = mod(angle+PI/16.0, PI/8.0)-PI/16.0;\n    vec3 where = vec3(radius *cos(angle), global_where.y, radius *sin(angle));\n    \n    float plane_d = where.y - ball_position.y +2.0;\n    vec3 br = where - ball_position; \n    float wobble = 0.9 * sin(15.0 * (atan(br.x,br.z)));\n    wobble *= clamp(1.0/pow(br.y,2.0)-0.13, 0.0, 1.0);\n    float ball_d = abs(length(br) - ball_radius + wobble);\n    float edge = length(vec2(plane_d, ball_d));\n    return min(edge -0.1, max(plane_d, ball_d - 0.1));\n}\n\nfloat torus(vec3 where, float major, float minor) {\n  vec2 q = vec2(length(where.xy) - major, where.z);\n  return length(q) - minor;\n}\n\nfloat measure_to_pole(vec3 global_where) {\n    vec3 local_where = mod(global_where, 20.0)- light_1_position;\n    local_where.x -= 1.0;\n    local_where.y = global_where.y;\n    float radius = length(local_where.xz);\n    float plane_d = local_where.y - 6.6;\n    float thick;\n    if (local_where.y < 1.3) {\n        thick = 0.2;\n    } else if (local_where.y < 1.4) {\n        thick = 0.1 + (1.4 - local_where.y);\n    } else if (local_where.y < 5.5) {\n        thick = 0.1;\n    } else if (local_where.y < 5.55) {\n        thick = 0.1 + local_where.y - 5.50;\n    } else if (local_where.y < 6.50) {\n        thick = 0.15;\n    } else if (local_where.y < 6.55) {\n        thick = 6.65 - local_where.y;\n    } else {\n        thick = 0.1;\n    }\n    vec3 tor_local = local_where + vec3(0.5, -5.5, 0);\n    float roundbit = max(-tor_local.y, torus(tor_local, 0.5, 0.05));\n    tor_local = local_where + vec3(0.0, -5.5, 0);\n    float roundbit2 = max(tor_local.x, max(-tor_local.y, torus(tor_local, 1.0, 0.05)));\n    float pole = max(radius - thick, plane_d);\n    return min(pole, min(roundbit, roundbit2));\n}\nvec2 closest(vec2 best, vec2 next) {\n    return (best.x < next.x) ? best : next;\n}\nvec2 measure(vec3 where) {\n    vec2 res = vec2(measure_to_brick(where), 1.5);\n    res = closest(res, vec2(measure_to_ball(where), 4.5));\n    res = closest(res, vec2(measure_to_pole(where), 5.5));\n    res = closest(res, vec2(measure_to_building(where), 6.5));\n    return res;\n}\nfloat measure_for_shadow(vec3 where) {\n    return min(measure_to_brick(where),\n               min(measure_to_ball(where), measure_to_pole(where))\n\t);\n}\n/**\n * iq's soft shadow algo\n */\nfloat soft_shadow( in vec3 start, in vec3 ray, float min_dist, float max_dist, float k )\n{\n    float res = 1.0;\n    for( float t=min_dist; t < max_dist; )\n    {\n        float h = measure_for_shadow(start + ray * t);\n        if( h < 0.0001 )\n            return 0.0; // hit something.\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n/**\n * currently just used for shadows\n * returns how far we went, and how close we came to hitting anything\n */\nvec2 trace_for_shadow(vec3 start, vec3 ray, float max_dist) {\n    vec3 where = start;\n    float total_dist = 0.0;\n    int steps = 0;\n    vec2 current;\n    float closest = max_dist + 1.0;\n    for (int steps = 0; steps < MAX_STEP; steps++) {\n        float current_dist = measure_for_shadow(where);\n        if (current_dist < EPSILON) {\n            return vec2(total_dist, current_dist);\n        }\n        \n        if (current_dist < closest) {\n            closest = current_dist;\n        }\n\n        total_dist += current_dist * STEP_RATIO;\n        if (total_dist > max_dist) {\n            break;\n        }\n        where = start + total_dist * ray;\n    }\n    return vec2(max_dist, closest);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screen_pos = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.y / iResolution.x;\n    screen_pos.y *= aspect;\n    screen_pos -= 0.5;\n    vec3 look_at= vec3(5,7,5);\n//    vec3 look_at= vec3(0.0, 4.0+ 3.0*sin(iTime*0.13), 5.0+ 13.0*sin(iTime*0.3));\n    vec3 up = vec3(0,1,0);\n    vec3 eye = vec3(sin(iTime*0.11)*30.0+27.0, 8.0 + sin(iTime/1.3)*5.0, cos(iTime*0.71)*10.0);\n//    vec3 eye = vec3(sin(iTime*0.1)*20.0+5.0, 8.0 + sin(iTime/5.0)*5.0, cos(iTime*0.1)*10.0);\n    vec3 look_center = normalize(look_at - eye);\n    vec3 look_right = cross(up, look_center);\n    vec3 look_up = cross(look_center, look_right);\n        \n\tvec3 ray = normalize(look_center + screen_pos.x * look_right + screen_pos.y * look_up);\n    vec3 p_normal = vec3(0,1,0);\n    float p_dist = 0.0;\n    \n    vec3 where = eye;\n    float total_dist = 0.0;\n    vec2 current;\n    for(int steps =0;steps < MAX_STEP; steps++) {\n        current = measure(where);\n        float current_dist = current.x;\n        if (current_dist < EPSILON) {\n            break;\n        }\n        total_dist += current_dist * STEP_RATIO;\n        if (total_dist > MAX_DIST) {\n            break;\n        }\n        where = eye + total_dist * ray;\n    }\n\tvec3 hit = where;\n\n    vec3 base_color = vec3(0,0,0);\n    vec3 paint = vec3(0,0,0);\n    int who = int(current.y);\n    if (who == 3) { // red light\n        fragColor = vec4(light_2_color, 1.0);\n        return;\n    }\n    if (who == 2) { // white light\n        fragColor = vec4(light_1_color, 1.0);\n        return;\n    }\n    // add glow for white light\n    vec3 eye_to_light_1 = light_1_position - eye;\n    float dp_1 = dot(ray, normalize(eye_to_light_1));\n    if (dp_1 > 0.0 && length(eye_to_light_1) < total_dist) {\n    \tvec3 short_1 = eye_to_light_1 * dp_1;\n        float diff = length(eye_to_light_1 - short_1);\n\t    //float light_1_dist =  diff / dp_1;\n\t    base_color += light_1_color * (0.0001 * (dp_1*dp_1) / (diff *diff));\n    }\n    // add glow for yellow light\n    vec3 eye_to_light_2 = light_2_position - eye;\n    float dp_2 = dot(ray, normalize(eye_to_light_2));\n    if (dp_2 > 0.0) {\n    \tvec3 short_2 = eye_to_light_2 * ray;\n        float diff_2 = length(eye_to_light_2 - short_2);\n\t    //float light_2_dist =  diff / dp_2;\n\t    base_color += light_2_color * (0.0001 * (dp_2*dp_2) / (diff_2 *diff_2));\n    }\n    if (who > 0) {\n        vec3 col = vec3(0.7,0.5,0.2);\n        // delta for normal calculation\n        float dnc = 0.001;\n        vec3 surface_normal = normalize(vec3(\n            measure(hit+vec3(dnc, 0.0, 0.0)).x - measure(hit-vec3(dnc, 0.0, 0.0)).x,\n            measure(hit+vec3(0.0, dnc, 0.0)).x - measure(hit-vec3(0.0, dnc, 0.0)).x,\n            measure(hit+vec3(0.0, 0.0, dnc)).x - measure(hit-vec3(0.0, 0.0, dnc)).x\n        ));\n        if (who == 1) {\n\t        col = vec3(0.7,0.5,0.2);\n        } else if (who == 4) {\n\t        col = vec3(0.3, 0.44, 1.0);\n        } else if (who == 5) {\n\t        col = vec3(0.2, 0.2, 0.22);\n        } else if (who == 6) {\n\t        col = vec3(0.7, 0.7, 0.7);\n        }\n        // how much illumination is the hit surface getting from light 1?\n        vec3 hit_to_light_1 = light_1_position - hit;\n        vec3 nhit_to_light_1 = normalize(hit_to_light_1);\n        float length_to_light_1 = length(hit_to_light_1);\n        float light_1_angle = max(0.0, dot(surface_normal, nhit_to_light_1));\n        float light_1_illum = light_1_power * light_1_angle / (1.0 + pow(length_to_light_1, 2.0));\n        \n        // but wait, is it shadowed?\n        #ifdef SHADOWS\n        if (light_1_angle > 0.0) {\n            /*\n            vec2 shadow_check = trace_for_shadow(hit + nhit_to_light_1 *epsilon, nhit_to_light_1, length_to_light_1);\n            float k = clamp(0.001*shadow_check.x /shadow_check.y, 0.0, 1.0);\n            light_1_illum *= k;\n            */\n            float shadow_check = trace_for_shadow(hit + nhit_to_light_1 *EPSILON, nhit_to_light_1, length_to_light_1).x;\n            if (shadow_check < length_to_light_1 - light_radius - EPSILON * 10.0) {\n                light_1_illum = 0.0;\n            }\n        }\n        #endif\n\n        vec3 hit_to_light_2 = light_2_position - hit;\n        vec3 nhit_to_light_2 = normalize(hit_to_light_2);\n        float length_to_light_2 = length(hit_to_light_2);\n        float light_2_angle = max(0.0, dot(surface_normal, nhit_to_light_2));\n        float light_2_illum = light_2_power * light_2_angle / (1.0 + pow(length_to_light_2, 2.0));\n        vec2 attenuation = vec2(sin(iTime*4.0), cos(iTime*4.0));\n        light_2_illum *= pow(dot(attenuation, nhit_to_light_2.xz), 16.0);\n        // shadow calculation really seems to slow this down :-(\n        #ifdef SHADOWS\n        if (light_2_angle > 0.0) {\n            float shadow_check = trace_for_shadow(hit + nhit_to_light_2 *EPSILON, nhit_to_light_2, length_to_light_2).x;\n            if (shadow_check < length_to_light_2 - light_radius - EPSILON * 10.0) {\n                light_2_illum = 0.0;\n            }\n        }\n        #endif\n\n        paint = vec3(col * (light_1_color*light_1_illum + light_2_color*light_2_illum));\n    }\n    fragColor += vec4(base_color + paint, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}