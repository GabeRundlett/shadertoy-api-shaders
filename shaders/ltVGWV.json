{
    "Shader": {
        "info": {
            "date": "1476937959",
            "description": "I had this shader in mind for a while. Now that it's outside my head it's inside yours. Time to get some sleep!",
            "flags": 96,
            "hasliked": 0,
            "id": "ltVGWV",
            "likes": 3,
            "name": "z5(oR_HÂµRTJ^k____",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "tunnel",
                "raymarch",
                "horror"
            ],
            "usePreview": 1,
            "username": "Klems",
            "viewed": 938
        },
        "renderpass": [
            {
                "code": "\n// from mpeg artifacts by kusma\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float time = texture(iChannel0, uv).a; // fetch the time from Buffer A for channel playback\n    float intensity = smoothstep(10.0, 120.0, time) * 0.8;\n\tvec2 block = floor(fragCoord.xy / vec2(32));\n\tvec2 uv_noise = block / iChannelResolution[1].xy;\n\tuv_noise += floor(vec2(time) * vec2(1234.0, 3543.0)) / iChannelResolution[1].xy;\n\t\n\tfloat block_thresh = pow(fract(time * 1236.0453), 2.0) * intensity;\n\tfloat line_thresh = pow(fract(time * 2236.0453), 3.0) * intensity;\n\t\n\tvec2 uv_r = uv, uv_g = uv, uv_b = uv;\n\n\t// glitch some blocks and lines\n\tif (texture(iChannel1, uv_noise).r < block_thresh ||\n\t\ttexture(iChannel1, vec2(uv_noise.y, 0.0)).g < line_thresh) {\n\t\tvec2 dist = (fract(uv_noise) - 0.5) * 0.3;\n\t\tuv_r += dist * 0.1;\n\t\tuv_g += dist * 0.2;\n\t\tuv_b += dist * 0.125;\n\t}\n\n\tfragColor.r = texture(iChannel0, uv_r).r;\n\tfragColor.g = texture(iChannel0, uv_g).g;\n\tfragColor.b = texture(iChannel0, uv_b).b;\n\n\t// loose luma for some blocks\n\tif (texture(iChannel1, uv_noise).g < block_thresh)\n\t\tfragColor.rgb = fragColor.ggg;\n\n\t// discolor block lines\n\tif (texture(iChannel1, vec2(uv_noise.y, 0.0)).b * 3.5 < line_thresh)\n\t\tfragColor.rgb = vec3(0.0, dot(fragColor.rgb, vec3(1.0)), 0.0);\n\n\t// interleave lines in some blocks\n\tif (texture(iChannel1, uv_noise).g * 1.5 < block_thresh ||\n\t\ttexture(iChannel1, vec2(uv_noise.y, 0.0)).g * 2.5 < line_thresh) {\n\t\tfloat line = fract(fragCoord.y / 3.0);\n\t\tvec3 mask = vec3(3.0, 0.0, 0.0);\n\t\tif (line > 0.333)\n\t\t\tmask = vec3(0.0, 3.0, 0.0);\n\t\tif (line > 0.666)\n\t\t\tmask = vec3(0.0, 0.0, 3.0);\n\t\t\n\t\tfragColor.xyz *= mask;\n\t}\n    \n    fragColor.a = 1.0;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define PI 3.14159265359\n#define PHI 1.61803398875\n\nfloat time = 0.0;\n\n// hash functions\nfloat hash( in float n ){ return fract(cos(n)*45758.5453); }\nfloat hash( in vec3 p ){ return fract(sin(dot(p, vec3(7, 157, 113)))*45758.5453); }\n\n// dithering function\nfloat dithering( in float value, in float noise ) {\n    value += (noise * 2.0 - 1.0) / (256.0 + 0.05);\n    value = floor(value*256.0) / (256.0 - 1.0);\n    value = clamp(value, 0.0, 1.0);\n    return value;\n}\n\n// fabrice's rotation matrix\nmat2 rot( in float th ){\n    vec2 a = sin(vec2(1.5707963, 0) + th);\n    return mat2(a, -a.y, a.x);\n}\n\n// iq's noise\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    f = smoothstep(0.0, 1.0, f); // smoother output\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z)*2.0-1.0;\n}\n\n// 1D perlin noise\nfloat perlin( in float x, in float seed ) {\n    float a = floor(x);\n    float b = a+1.0;\n    return mix(hash(a+PHI*seed), hash(b+PHI*seed), smoothstep(0.0, 1.0, fract(x)));\n}\n\n// iq's smin and smax\nfloat smin( in float a, in float b , in float s ){    \n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\nfloat smax( in float a, in float b, in float s ){\n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n// iq's box function\nfloat sdBox( in vec2 p, in vec2 b ) {\n\tvec2 d = abs(p) - b;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d,0.0));\n}\n\n// same in 3D\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// 2D distance function for the tunnel\nfloat dist2D( in vec2 uv, in float seed ) {\n    \n    float de = 0.4 - length(uv);\n    \n    // extrude a few boxes here and here\n    for (int i = 0 ; i < 3 ; i++) {\n        float f = float(i)+1.0;\n        \n        // size of the box\n        float dim = perlin(seed*1.02314, f);\n        vec2 b = vec2( dim, 1.0/dim );\n        \n        // rotation and offset\n        float theta = perlin(seed*0.5324, f*12.4412)*PI*2.0;\n        vec2 off = vec2( \n            perlin(seed*1.0984, f*21.4441), \n            perlin(seed*1.0578, f*61.4738)) * 2.0 - 1.0;\n        vec2 p = (uv+off)*rot(theta);\n        \n        // twist it for added funk\n        p *= rot(length(p));\n        \n        // box distance\n        float d = sdBox(p, b);\n        \n        // blend with the background\n        de = smax(de, -d, 0.2);\n    }\n    \n    return de;\n}\n\n// get the mouth opening fraction\nfloat mouthDist( ) {\n    float scream = smoothstep(0.0, 0.4, texture(iChannel1, vec2(0.8, 0.0)).r);\n    float base = sin(time*10.0)*0.5+0.5;\n    base = 0.7*scream + perlin(time*7.234, 1478.1248)*0.3;\n    return base;\n    //return texture(iChannel1, vec2(0.2, 0.0)).r;\n}\n\n// monster distance function\nfloat distMonster( in vec3 p, in vec3 from, in float distToTunnel, out int id, out vec3 texCoord ) {\n\t\n    float intensity = 1.0-smoothstep(10.0, 120.0, time);\n    float dist = 0.5 + 20.0*intensity + sin(time)*4.0*intensity;\n    \n    vec3 fromMonster = from + vec3(0, 0, 1.0 + dist);\n    vec3 inMonster = p-fromMonster;\n    vec3 n = vec3(0.0, 0.0, time*0.3);\n    \n    float plane = -inMonster.z;\n    \n    // bounding box optimization\n    float nearPlane = plane - 1.0;\n    if (nearPlane > 0.0) return plane;\n   \t\n    // distorted flesh base\n    vec3 inNoise = inMonster + vec3(0.231, 0.134, 0.345)*time;\n    inNoise.xz *= rot(1.1124);\n    vec3 inNoise2 = inNoise * 3.1234;\n    inNoise.yz *= rot(1.4578);\n    inNoise2.yz *= rot(1.9451);\n    vec3 inNoise3 = inNoise2 * 1.2314;\n    inNoise3.xz *= rot(0.7842);\n    float deBase = plane - noise(inNoise)*0.2 - noise(inNoise2)*0.03;\n    // more flesh along the wall\n    float more = pow(5.0, -distToTunnel*10.0);\n    float evenMore = 0.2+length(inMonster.xy)*0.2 + noise(inNoise3)*0.3;\n    deBase -= evenMore*more;\n    \n    // add a big mouth and some teeth\n    vec3 pTeeth = p;\n    pTeeth.xy *= rot((perlin(time*0.731, 456.1124)-0.5)*0.2);\n    pTeeth.xy += (vec2(\n        perlin(time*0.4578, 84.1774),\n        perlin(time*0.6878, 98.1247)) - 0.5) * 0.8;\n    pTeeth.z -= 0.6;\n    float teethDist = 0.75 + mouthDist()*0.65;\n    vec3 teethCenter = vec3(pTeeth.xy, fromMonster.z);\n    teethCenter.x = floor(teethCenter.x * 4.0 + 0.5) / 4.0;\n    teethCenter.y = (step(0.0, teethCenter.y)-0.5)*teethDist;\n    vec3 teethDelta = pTeeth-teethCenter;\n    float deTeeth = sdBox(teethDelta, vec3(0.07, 0.3, 0.05)) - 0.06;\n    deTeeth += sin(pTeeth.x*10.0)*0.01;\n    // dent to form the mouth\n    float mouth = pow(60.0, -abs(pTeeth.y));\n    deBase += mouth*1.5;\n    \n    // add some eyes\n    vec3 pEye = p;\n    pEye.x -= 0.2314*time;\n    pEye.xy *= rot(0.8134);\n    vec3 eyeCenter = vec3(pEye.xy, fromMonster.z);\n    eyeCenter.xy = floor(eyeCenter.xy*0.75 + 0.5) / 0.75;\n    float eyeID = eyeCenter.x+eyeCenter.y*PHI;\n    float eyeRadiusRand = hash(eyeID);\n    eyeRadiusRand *= eyeRadiusRand;\n    float eyeRadius = 0.1 + 0.3*eyeRadiusRand;\n    eyeRadius *= 1.0 - smoothstep(0.0, 0.3, mouth);\n    vec2 eyeOffset = (vec2(\n        perlin(time*(0.35+hash(eyeID*58.124)*0.5), eyeID*12.1314),\n        perlin(time*(0.35+hash(eyeID*94.315)*0.5), eyeID*34.4875)) - 0.5) * 0.7;\n    vec3 eyeDelta = pEye-(eyeCenter+vec3(eyeOffset, 0));\n    float deEye = length(eyeDelta) - eyeRadius;\n    \n    if (deEye < deBase && deEye < deTeeth) {\n        // eye\n        id = 2;\n        texCoord = eyeDelta / eyeRadius;\n        // rotate the eye\n        float x = 0.0;\n        x += (perlin(time*2.1248, eyeID*8241.221)-0.5)*1.2;\n        x += (perlin(time*15.234, eyeID*4589.864)-0.5)*0.2;\n        texCoord.xz *= rot(x);\n        float y = 0.0;\n        y += (perlin(time*2.9827, eyeID*7894.789)-0.5)*1.2;\n        y += (perlin(time*17.148, eyeID*5761.254)-0.5)*0.2;\n        texCoord.yz *= rot(y);\n        return deEye;\n    } else if (deTeeth < deBase) {\n        // teeth\n        id = 3;\n        texCoord = teethDelta;\n        return deTeeth;\n    } else {\n        // base\n        id = 1;\n        texCoord = inMonster;\n\t\t// blend with the eye and mouth distance\n        return smin(deBase, deEye, eyeRadius*0.8);\n    }\n}\n\n// main distance function\nfloat de( in vec3 p, in vec3 from, out int id, out vec3 texCoord ) {\n    // extrude the tunnel along the Z axis\n    float distT = dist2D(p.xy, p.z*0.04 - 100.0);\n    // add the monster\n    int idMonster = 0;\n    vec3 texCoordMonster = vec3(0);\n    float distM = distMonster(p, from, distT, idMonster, texCoordMonster);\n    \n    if (distT < distM) {\n        id = 0;\n        texCoord = p;\n    } else {\n        id = idMonster;\n        texCoord = texCoordMonster;\n    }\n    \n    return min(distT, distM);\n}\n\n// normal function\nvec3 normal( in vec3 p, in vec3 from ) {\n\tint dummy = 0;\n    vec3 dummyTex = vec3(0);\n    vec3 e = vec3(0.0, 0.01, 0.0);\n    float d = de(p, from, dummy, dummyTex);\n\treturn normalize(vec3(\n\t\td - de(p-e.yxx, from, dummy, dummyTex),\n\t\td - de(p-e.xyx, from, dummy, dummyTex),\n\t\td - de(p-e.xxy, from, dummy, dummyTex)));\t\n}\n\n// bi-planar mapping from NVIDIA gems\nvec3 tex3D( in vec3 p, in vec3 n ) {\n    mat2 rot1 = rot(2.0*PI*1.123412);\n    mat2 rot2 = rot(2.0*PI*0.412547);\n    vec2 nn = abs(n.xy);\n    nn /= (nn.x + nn.y);\n\treturn texture(iChannel0, p.yz*rot1).rgb*nn.x + texture(iChannel0, p.xz*rot2).rgb*nn.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    time = iChannelTime[1];\n    \n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.y *= iResolution.y / iResolution.x;\n\t\n\tvec3 from = vec3(0, 0, -time*7.0);\n\tvec3 dir = normalize(vec3(uv*0.75, 1.0));\n    \n    float rotX = (1.0-smoothstep(0.0, 12.0, time))*0.8+sin(time*0.312)*0.15;\n    float rotY = (1.0-smoothstep(1.0, 18.0, time))*3.1+sin(time*0.254)*0.1;\n    dir.xz *= rot(rotX);\n    dir.yz *= rot(rotX);\n\n\tfloat totdist = 0.0;\n    bool set = false;\n   \tint id = 0;\n    vec3 texCoord = vec3(0);\n    float ao = 0.0;\n    \n    // randomize first raymarch step\n    totdist += de(from, from, id, texCoord)*hash(vec3(uv, 0));\n\t\n    #define STEPS 70\n\tfor (int steps = 0 ; steps < STEPS ; steps++) {\n        if (set) continue;\n\t\tvec3 p = from + totdist * dir;\n\t\tfloat dist = de(p, from, id, texCoord)*0.75;\n        totdist += dist;\n        if (dist < 0.001) {\n            set = true;\n            ao = 1.0 - float(steps) / float(STEPS-1);\n        }\n\t}\n    \n    vec3 p = from + totdist * dir;\n    vec3 norm = normal(p, from);\n    vec3 col = vec3(0);\n    \n    if (id == 0) {\n        col = tex3D(texCoord*0.1547, norm).gbr;\n        col *= ao;\n    } else {\n        float fresnel = max(0.0, dot(dir, -norm));\n        col = vec3(0);\n        \n        if (id == 1) {\n            col = mix(vec3(1.0, 0.0, 0.3), vec3(1.0, 0.2, 0.4), fresnel);\n        } else if (id == 2) {\n            float cornea = sin(atan(texCoord.y, texCoord.x)*12.0);\n            float iris = dot(texCoord, vec3(0, 0, -1));\n            col = mix(vec3(0.8, 0.0, 0.4), vec3(1.0, 0.1, 0.2), cornea);\n            col = mix(vec3(1), col, smoothstep(0.8, 0.85, iris));\n            col = mix(col, vec3(0), smoothstep(0.95, 0.98, iris));\n        } else if (id == 3) {\n            col = vec3(1);\n        }\n        \n        col *= ao;\n        float high = pow(fresnel, 350.0);\n        col += high;\n        col = clamp(col, 0.0, 1.0);\n    }\n    \n    // fog\n    fragColor.rgb = mix(col, vec3(0), smoothstep(0.0, 20.0, totdist));\n    \n    // vignette\n    vec2 vign = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    float intensity = smoothstep(10.0, 120.0, time) * 0.8;\n    fragColor.rgb -= dot(vign, vign)*(0.2+intensity*0.2);\n    \n    // fade to black\n    float fade = 1.0 - smoothstep(0.0, 8.0, time) + smoothstep(119.0, 120.0, time);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), fade);\n    \n    // apply dithering to avoid banding\n    fragColor.r = dithering(fragColor.r, hash(vec3(fragCoord.xy, 147.2214)));\n    fragColor.g = dithering(fragColor.g, hash(vec3(fragCoord.xy, 234.1127)));\n    fragColor.b = dithering(fragColor.b, hash(vec3(fragCoord.xy, 684.3975)));\n    \n    // save playback in alpha channel\n    fragColor.a = time;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 5118,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/user-791861942/screams-1"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}