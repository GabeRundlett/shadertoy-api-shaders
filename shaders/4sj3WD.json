{
    "Shader": {
        "info": {
            "date": "1642366088",
            "description": "Revisiting a very old shader that I never got around to finishing! Tweaking my 8-year-old messy code for the final touches today was a mouthful...",
            "flags": 0,
            "hasliked": 0,
            "id": "4sj3WD",
            "likes": 1,
            "name": "Gemstone Collection",
            "published": 3,
            "tags": [
                "gem",
                "stone",
                "collection",
                "gems",
                "raymarchtone"
            ],
            "usePreview": 0,
            "username": "HLorenzi",
            "viewed": 362
        },
        "renderpass": [
            {
                "code": "#define RAYMARCH_ITERATIONS 40\n#define SHADOW_ITERATIONS 50\n#define SHADOW_STEP 1.0\n#define SHADOW_SMOOTHNESS 4.0\n#define SHADOW_DARKNESS 0.75\n\n\nfloat hash(float x)\n{\n    return fract(sin(x) * 43758.5453) * 2.0 - 1.0;\n}\n\nfloat hashp(float x)\n{\n    return fract(sin(x) * 43758.5453);\n}\n\n\n// Distance functions from iquilezles.org\n\nfloat fSubtraction(float a, float b) {return max(-a,b);}\nfloat fIntersection(float d1, float d2) {return max(d1,d2);}\nfloat fUnion(float d1, float d2) {return min(d1,d2);}\nfloat pSphere(vec3 p, float s) {return length(p)-s;}\nfloat pRoundBox(vec3 p, vec3 b, float r) {return length(max(abs(p)-b,0.0))-r;}\nfloat pTorus(vec3 p, vec2 t) {vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y;}\nfloat pTorus2(vec3 p, vec2 t) {vec2 q = vec2(length(p.xy)-t.x,p.z); return length(q)-t.y;}\nfloat pCapsule(vec3 p, vec3 a, vec3 b, float r) {vec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 ); return length( pa - ba*h ) - r;}\nfloat pPlane(vec3 p, vec4 n) {return dot(p,n.xyz) + n.w;}\n\nfloat pMineral(vec3 p, vec2 h, float r) {\n\tvec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5) - r;\n}\n\n\nmat3 rotmat(vec3 u, float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\tfloat ic = 1.0 - c;\n\t\n\tfloat x = u.x;\n\tfloat y = u.y;\n\tfloat z = u.z;\n\t\n\treturn mat3(x*x*ic+c, x*y*ic-z*s, x*z*ic+y*s,\n\t\t\t\ty*x*ic+z*s, y*y*ic+c, y*z*ic-x*s,\n\t\t\t\tz*x*ic-y*s, z*y*ic+x*s, z*z*ic+c);\n}\n\n#define CYCLE_TIME 3.0\n#define TRANSITION_TIME 0.25\n\nfloat distf(vec3 p)\n{\n\tfloat dFinal = 50.0;\n    \n    float indexHash = hashp(floor((iTime + 126.0) / CYCLE_TIME));\n    \n    float t = mod(iTime, CYCLE_TIME) / CYCLE_TIME;\n    \n    if (t < TRANSITION_TIME)\n    {\n        float t2 = (1.0 - (t / TRANSITION_TIME));\n        p.y += t2 * t2 * t2 * 20.0;\n    }\n    \n    if (t > 1.0 - TRANSITION_TIME)\n    {\n        float t2 = ((t - (1.0 - TRANSITION_TIME)) / TRANSITION_TIME);\n        p.y -= t2 * t2 * t2 * 20.0;\n    }\n\n    for(float j = 0.0; j < 2.0; j += 1.0)\n    {\n        float d = 0.0;\n        for(float i = 0.0; i < 3.0; i += 1.0)\n        {\n            float iterHash = 7.6 * j + 3.7 * i;\n            d = fIntersection(d, pMineral(\n                vec3(\n                    3.0 * (hashp(iterHash + 1.4 + indexHash) - 0.5),\n                    3.0 * (hashp(iterHash + 7.3 + indexHash) - 0.5),\n                    3.0 * (hashp(iterHash + 8.9 + indexHash) - 0.5))\n                 * hashp(iterHash + 3.3 + indexHash) * 1.0 +\n                    rotmat(normalize(vec3(hash(iterHash+0.1+indexHash),hash(iterHash+0.2+indexHash),hash(iterHash+0.3+indexHash))),\n                           hashp(iterHash+0.4+indexHash)*3.14159*2.) * p,\n                vec2(5.0,hashp(iterHash + 4.6 + indexHash) * 5.0),\n                hashp(iterHash + 8.5 + indexHash) * 0.25));\n        }\n        dFinal = fUnion(dFinal, d);\n    }\n\treturn dFinal;\n}\n\nvec3 normal(vec3 p)\n{\n\tconst float eps = 0.01;\n\tfloat m;\n    vec3 n = vec3( (distf(vec3(p.x-eps,p.y,p.z)) - distf(vec3(p.x+eps,p.y,p.z))),\n                   (distf(vec3(p.x,p.y-eps,p.z)) - distf(vec3(p.x,p.y+eps,p.z))),\n                   (distf(vec3(p.x,p.y,p.z-eps)) - distf(vec3(p.x,p.y,p.z+eps)))\n\t\t\t\t );\n    return normalize(n);\n}\n\nstruct raymarch_data {\n\tbool hit;\n\tvec3 hitPos;\n\tvec3 backPos;\n\tvec3 backDir;\n};\n\nvec3 raymarch_thru(vec3 from, vec3 increment)\n{\n\tconst float maxDist = 200.0;\n\tconst float minDist = 0.001;\n\tconst int maxIter = RAYMARCH_ITERATIONS;\n\t\n\tfloat dist = 10.0;\n\t\n\tfor(int i = 0; i < maxIter; i++) {\n\t\tvec3 pos = (from + increment * dist);\n\t\tfloat distEval = distf(pos);\n\t\t\n\t\tif (distEval < minDist) {\n\t\t\tbreak;\n\t\t}\n\t\t\t\n\t\tdist -= distEval;\n\t}\n\t\n\treturn from + increment * dist;\n}\n\nraymarch_data raymarch(vec3 from, vec3 increment)\n{\n\tconst float maxDist = 200.0;\n\tconst float minDist = 0.001;\n\tconst int maxIter = RAYMARCH_ITERATIONS;\n\t\n\tfloat dist = 0.0;\n\t\n\tfor(int i = 0; i < maxIter; i++) {\n\t\tvec3 pos = (from + increment * dist);\n\t\tfloat distEval = distf(pos);\n\t\t\n\t\tif (distEval < minDist) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tdist += distEval;\n\t}\n\t\n\tfloat mat = 1.0;\n\tif (dist >= maxDist) mat = 0.0;\n\t\n\tvec3 p = from + increment * dist;\n\tvec3 n = -normal(p);\n\tvec3 pdir = refract(increment, n, 1.0 / 2.0);\n\t\n\treturn raymarch_data(\n\t\t\t\tmat == 1.0,\n\t\t\t\tp,\n\t\t\t\traymarch_thru(p, pdir),\n\t\t\t\tpdir\n\t\t\t);\n}\n\nfloat shadow(vec3 from, vec3 increment)\n{\n\tconst float minDist = 1.0;\n\t\n\tfloat res = 1.0;\n\tfloat t = 1.0;\n\tfor(int i = 0; i < SHADOW_ITERATIONS; i++) {\n        float h = distf(from + increment * t);\n        if(h < minDist)\n            return 0.0;\n\t\t\n\t\tres = min(res, SHADOW_SMOOTHNESS * h / t);\n        t += SHADOW_STEP;\n    }\n    return res;\n}\n\nvec4 HSVtoRGB(vec3 hsv)\n{\n\tfloat i = floor(mod(floor(hsv.x / 60.0),6.0));\n\tfloat f = mod(hsv.x / 60.0, 6.0) - i;\n\tfloat p = hsv.z * (1.0 - hsv.y);\n\tfloat q = hsv.z * (1.0 - f * hsv.y);\n\tfloat t = hsv.z * (1.0 - (1.0 - f) * hsv.y);\n\t\n\tif (i == 0.) return vec4(hsv.z,t,p,1);\n\tif (i == 1.) return vec4(q,hsv.z,p,1);\n\tif (i == 2.) return vec4(p,hsv.z,t,1);\n\tif (i == 3.) return vec4(p,q,hsv.z,1);\n\tif (i == 4.) return vec4(t,p,hsv.z,1);\n\treturn vec4(hsv.z,p,q,1);\n}\n\n\nfloat time;\nvec4 getPixel(vec2 p, vec3 from, vec3 increment)\n{\n\tvec3 light = normalize(vec3(0,0,1));\n\t\n\traymarch_data c = raymarch(from, increment);\n\tvec3 n1 = normal(c.hitPos);\n\tfloat diff1 = clamp(dot(n1, -light), 0.0, 1.0) * 0.5 + 0.5;\n\tfloat spec1 = pow(max(0.0, dot(reflect(-light, n1), normalize(from - c.hitPos))), 5.0);\n\t\n\tvec3 n2 = -normal(c.backPos);\n\tfloat diff2 = clamp(dot(n2, -light), 0.0, 1.0) * 0.5 + 0.5;\n\tfloat spec2 = pow(max(0.0, dot(reflect(-light, n2), normalize(from - c.backPos))), 5.0);\n\t\n\tif (!c.hit) return texture(iChannel0, normalize(c.hitPos.xzy));\n    \n    float indexHash = hashp(floor((iTime + 195.0) / CYCLE_TIME));\n    vec4 mainColor = vec4(\n        hashp(indexHash * 3.5),\n        hashp(indexHash * 2.7),\n        hashp(indexHash * 1.9),\n        1.0);\n    \n\tvec4 color = mix(\n\t\t\n\t\t\t\tmix(\n\t\t\t\t\tmix(mainColor * diff1,\n\t\t\t\t\t\ttexture(iChannel0, normalize(reflect(increment,n1).xzy)),\n\t\t\t\t\t\t0.1),\n\t\t\t\t\tmix(\n\t\t\t\t\t\tmix(mainColor * 1.2 * diff2,\n\t\t\t\t\t\t\ttexture(iChannel0, normalize(c.backDir.xzy)),\n\t\t\t\t\t\t\t0.1),\t\t\t\t\t\t\t\n\t\t\t\t\t\tvec4(1,1,1,1), spec2),\n\t\t\t\t\t0.3\n\t\t\t\t),\n\t\t\t\t\n\t\t\t\tvec4(1,1,1,1), spec1);\n\t\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\ttime = iTime;\n\t\n\t// pixel position\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= -iResolution.x/iResolution.y;\n\t\n\t// mouse\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\t//if (iMouse.z == 0.0 && iMouse.w == 0.0)\n    {\n\t\tm = vec2(time * 0.06 + 1.67, 0.5 + 0.3 * sin(time * 0.5));\t\n\t}\n\tm = -1.0 + 2.0 * m;\n\tm *= vec2(4.0,-0.9);\n\n\t// camera position\n\tfloat dist = 15.0;\n\tvec3 ta = vec3(0,0,0);\n\tvec3 ro = vec3(cos(m.x) * cos(m.y) * dist, sin(m.x) * cos(m.y) * dist, sin(m.y) * dist);\n\t\n\t// camera direction\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 0.0, 1.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n\t// calculate color\n\tvec4 col = getPixel(p, ro, rd);\n    col = pow(col, vec4(1.0 / 2.2));\n    col = col*1.5-0.4;\n\tfragColor = col;\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}