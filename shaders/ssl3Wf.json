{
    "Shader": {
        "info": {
            "date": "1714456105",
            "description": "三角函数关系图",
            "flags": 0,
            "hasliked": 0,
            "id": "ssl3Wf",
            "likes": 2,
            "name": "三角函数关系图",
            "published": 3,
            "tags": [
                "trigonometric"
            ],
            "usePreview": 0,
            "username": "haiyoucuv",
            "viewed": 113
        },
        "renderpass": [
            {
                "code": "\n\n    #define PI 3.14159265358979323846\n\n    #define RED vec4(1.0, 0.0, 0.0, 1.0)\n    #define GREEN vec4(0.0, 1.0, 0.0, 1.0)\n    #define BLUE vec4(0.0, 0.0, 1.0, 1.0)\n    #define WHITE vec4(1.0, 1.0, 1.0, 1.0)\n\n    #define LINE_COLOR vec4(0.3, 0.8, 0.3, 1.0)\n    #define SIN_COLOR vec4(0.8, 0.3, 0.3, 1.0)\n    #define COS_COLOR vec4(0.3, 0.3, 0.8, 1.0)\n    #define TAN_COLOR vec4(0.8, 0.8, 0.3, 1.0)\n\n    #define AXIS_COLOR vec3(0.8);\n\n// 画圆 原点向外延伸\nvec4 Circel(in vec2 uv, in vec2 pos, in float radius, in float blur){\n    float edge = length(uv - pos) - radius - blur;\n    return vec4(smoothstep(blur, -blur, edge));\n}\n\n// 画环 内环 大圆-小圆\nvec4 Ring(in vec2 uv, in vec2 pos, in float radius, in float w, in float blur){\n    float edge = length(uv - pos) - radius - blur;\n    float res = smoothstep(blur, -blur, edge) - smoothstep(blur, -blur, edge + w);\n    return vec4(res);\n}\n\n// 画矩形 原点向外延伸\nvec4 Rectangle(in vec2 uv, in vec2 size, in float blur){\n    // *2.0 修复abs的两倍数据\n    uv = abs(uv) * 2.0;\n    float lr = smoothstep(blur, -blur, uv.x - size.x);\n    float tb = smoothstep(blur, -blur, uv.y - size.y);\n    return vec4(lr * tb);\n   \n}\n\n// 画线 原点向x轴正半轴延伸\nvec4 Line(in vec2 uv, in float l, in float w, in float blur){\n    // *2.0 修复abs的两倍数据\n    uv.y = abs(uv.y);\n\n    float left = smoothstep(-blur, blur, uv.x);\n    float right = smoothstep(blur, -blur, uv.x - l);\n    float tb = smoothstep(blur, -blur, uv.y - w / 2.0);\n    return vec4(tb * left * right);\n}\n\n// 顺时针旋转\nvec2 rotate2D(vec2 uv, float angle){\n    uv *= mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    return uv;\n}\n\n// 画y的集合\nfloat plot(in vec2 pos, in float y, in float w){\n   // return smoothstep(y - w, y, pos.y) - smoothstep(y, y + w, pos.y);\n   // return smoothstep( w, 0., abs( pos.y - y ));\n   return smoothstep( 3.*fwidth(pos.y-y), 0.0, abs( pos.y - y ));\n\n}\n\n// 坐标轴\nvec4 Axis(in vec2 uv){\n    float x = step(abs(uv.x), 0.0015);\n    float y = step(abs(uv.y), 0.0015);\n    vec3 color = mix(x, y, y) * AXIS_COLOR;\n    return vec4(color, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec4 color = vec4(vec3(0.2), 1.0);\n\n    float t = iTime / 6.0;\n\n    // t = 1.0;\n\n    //uv -= 0.5;// 原点移到中心点\n    uv.x -= 0.3;// 放右边一点\n\n    vec4 axis = Axis(uv);// 画个坐标轴\n    color = mix(color, axis, axis.r);\n\n    uv *= 5.0;\n    // uv.x += 0.5;\n\n\n    float radius = 1.0;// 圆环半径\n    float ringWidth = 0.03;// 圆环宽度\n    float blur = 0.0004;// 模糊\n    vec2 ringPos = vec2(radius * 1.5, 0.0);// 圆环位置\n\n    // 圆圈\n    vec4 ring = Ring(uv, ringPos, radius, ringWidth, blur) * LINE_COLOR;\n\n    vec2 rotateUv = rotate2D(uv - ringPos, -t);\n    // 圆上的点\n    vec4 point = Circel(rotateUv, vec2(radius * 0.98, 0.0), ringWidth * 1.5, blur) * LINE_COLOR;\n\n    // 画个连接\n    vec4 line = Line(rotateUv, 1.0, ringWidth, blur) * LINE_COLOR;\n\n    // 画出sin图像和sin(x)图像在y轴上运动的点\n    float sinY = sin(uv.x + t);\n    vec4 sinPlot = plot(uv, sinY, 0.03) * SIN_COLOR;\n    vec4 sinPoint = Circel(uv, vec2(0.0, sin(t)), ringWidth * 1.5, blur) * SIN_COLOR;\n\n    // 画出cos图像和cos(x)图像在y轴上运动的点\n    float cosY = cos(uv.x + t);\n    vec4 cosPlot = plot(uv, cosY, 0.03) * COS_COLOR;\n    vec4 cosPoint = Circel(uv, vec2(0.0, cos(t)), ringWidth * 1.5, blur) * COS_COLOR;\n\n    // 画出tan图像和tan(x)图像在y轴上运动的点\n    float tanY = tan(uv.x + t);\n    vec4 tanPlot = plot(uv, tanY, 0.03) * TAN_COLOR;\n    vec4 tanPoint = Circel(uv, vec2(0.0, tan(t)), ringWidth * 1.5, blur) * TAN_COLOR;\n\n    // 只画负半轴，此计算得出负半轴为1.0，正半轴为0.0\n    float xEdge = step(uv.x, 0.0);\n\n    // 合并函数图像  * xEdge 只画负半轴\n    vec4 funMix = vec4(0.0);\n    funMix = mix(funMix, sinPlot, sinPlot.a);\n    funMix = mix(funMix, cosPlot, cosPlot.a);\n    funMix = mix(funMix, tanPlot, tanPlot.a) * xEdge;\n\n    // 合并环，点，和线\n    color = mix(color, ring, ring.a);\n    color = mix(color, point, point.a);\n    color = mix(color, line, line.a);\n\n    color = mix(color, funMix, funMix.a);\n\n    // 函数在y轴上的运动轨迹点\n    color = mix(color, sinPoint, sinPoint.a);\n    color = mix(color, cosPoint, cosPoint.a);\n    color = mix(color, tanPoint, tanPoint.a);\n\n    fragColor = color;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}