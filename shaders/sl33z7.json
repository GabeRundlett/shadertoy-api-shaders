{
    "Shader": {
        "info": {
            "date": "1635872785",
            "description": "At least wasn't last this time :D \nWill burn your GPU / CPU just for simple shapes and very unoptimized code, perfect for heating during christmas.\nDo I understand what I done ? Absolutly not ? Did I just randomly write stuff until it please me ? Hell yea",
            "flags": 32,
            "hasliked": 0,
            "id": "sl33z7",
            "likes": 10,
            "name": "[Inercia 2021] Inerciaaaaaa",
            "published": 3,
            "tags": [
                "exegfx",
                "inercia"
            ],
            "usePreview": 0,
            "username": "totetmatt",
            "viewed": 472
        },
        "renderpass": [
            {
                "code": "\n/******\nThanks the Shader Showdown Scene folks for all the fun ! \nThanks yx for the blossom !  \n\n\nObrigado Inercia organiser jeenio, ps, alien and also all folks that participated !\n--- \n/******\nThis work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n\n== Do not buy NFT ==\n== Do not make NFT with Creative-Commons artworks ==\n== If you respect the art and the artists, remember and apply this ==\n\n01000110011101010110001101101011 011011100110011001110100\n\n                                                                               \n _|_|_|_|                      _|            _|      _|  _|_|_|_|  _|_|_|_|_|  \n _|        _|    _|    _|_|_|  _|  _|        _|_|    _|  _|            _|      \n _|_|_|    _|    _|  _|        _|_|          _|  _|  _|  _|_|_|        _|      \n _|        _|    _|  _|        _|  _|        _|    _|_|  _|            _|      \n _|          _|_|_|    _|_|_|  _|    _|      _|      _|  _|            _|      \n                                                                          \n\n01000110011101010110001101101011 011011100110011001110100\n\n******/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n  vec4 pframe = texture(iChannel0,fragCoord.xy/iResolution.xy);\n    // Output to screen\n    fragColor = vec4(min(pframe.xyz/pframe.a,vec3(1.,1.,1.)),1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nconst float pi = acos(-1.);\nmat2 rot(float a){float c=cos(a),s=sin(a); return mat2(c,-s,s,c);}\nfloat displace(vec3 p){\n    //p.xy = vec2(log(length(p.xy)),atan(p.y,p.x))*.9;\n    p = asin(sin(p)*.9);\n    float q = 1.;\n    vec4 pp = vec4(p,1.);\n    float lim = 8.;\n    for(float i=0.;i<=lim;i++){\n        q += clamp(\n        asin(sin(pp.x*6.))+acos(cos(pp.y*4.))+\n        \n        asin(sin(pp.z*2.))/pp.a,-.3,.3)/6.;\n        pp*=1.2;\n        pp.xz *=rot(.785);\n    }\n    return q/lim;\n}\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n}\nfloat diam2(vec2 p, float s){\n    p = abs(p)-s;\n    return (p.x+p.y-s)*inversesqrt(3.);\n}\n\nvec3 gp ;\n\nvec2 sdf(vec3 p){\n    float dis = displace(p);\n    vec3 dis3 = vec3(0.,0.,dis);\n    p.yz*=rot(atan(1./sqrt(2.)));\n    p.xz*=rot(3.1415/4.);\n    p.yz *=rot(-.785*1.5);\n    vec2 h;\n    vec3 hp =p;\n    hp += vec3(.7,-1.3,0.);\n    h.x = box(hp,vec3(.5)+dis3);\n    hp.y += 2.;\n    \n    h.x = min(h.x,box(hp,vec3(.5,1.1,.5)+dis3));\n    h.y = 1.;\n    \n    vec2 t;\n    vec3 tp =p;\n    tp.x -=.3;\n    \n    t.x = max(abs(tp.z)-.5-+dis,length(tp.xy)-1.8);\n    t.x = max(-(length(tp.xy)-.8),t.x);\n    t.x = max(-tp.x,t.x);\n    tp.y = abs(tp.y);\n    tp -=vec3(-.13,1.3,0.);\n    t.x = min(box(tp,vec3(.2,.5,.5)+dis3),t.x);\n    t.y = 2.;\n    h= t.x <h.x ? t:h;\n\n    \n     \n    tp =p;\n    tp.xz *=rot(-.1+tp.y*.3);\n    float dd = tp.x > 0. ? 1.:2.;\n    tp.x = abs(tp.x)-4.25;\n    \n   // tp.xz *=rot(3.1415*.3+tp.y*.1);\n\n\n    t.x = diam2(tp.xz,.15+(sin(p.y*dis)*.1))*.9;\n    t.y = dd;\n    h = t.x < h.x ? t:h;\n    \n    tp = p;\n    tp.zy *=rot(-.985);\n    tp.z +=float(iFrame)*.1;\n    dis = displace(tp);\n    t.x = dot(tp,normalize(vec3(0,1.,0.)))+1.+dis*2.;\n    t.y = 3.;\n    t.x = max(t.x,-(abs(h.x)-.1));\n    \n  \n    h = t.x < h.x ? t:h;\n    \n    tp = p;\n     tp.yz *=rot(-.785/2.);\n   \n   \n  \n   // tp.z = abs(tp.z)-.25;\n    vec2 q = vec2(diam2(tp.xy,1.5),tp.z);\n   \n    q *=rot(atan(tp.y,tp.x)*2.); q.x = abs(q.x)-.5;\n      t.y  =mod(floor(q.x),2.)==.0 ? 1.:2. ;\n    t.x = diam2(q,.05+dis*.1);\n   \n      h = t.x < h.x ? t:h;\n    gp = p;\n    return h;\n}\n\n\nvec3 q(vec3 p, vec3 s) { return s*sdf(p+s).x; }\nvec3 norm(vec3 p,float ee){vec2 e = vec2(-ee,ee);return normalize(q(p,e.xyy)+q(p,e.yxy)+q(p,e.yyx)+q(p,e.xxx));}\nfloat ao(vec3 rp,vec3 n, float k){ return sdf(rp+n*k).x/k ;}\nfloat gao(vec3 rp,vec3 n){ return ao(rp,n,.1)+ao(rp,n,.5)+ao(rp,n,.7);}\n\n// hash functions adapted from Devour\n// https://www.shadertoy.com/view/3llSzM\nfloat seed;\nfloat hash() {\n\tfloat p=fract((seed++)*.1031);\n\tp+=(p*(p+19.19))*3.;\n\treturn normalize(tan((p+p)*p));\n}\nvec2 hash2(){return vec2(hash(),hash());}\nvec2 hash22(vec2 p) {\n    p = fract(p * vec2(6.159, 7.853));\n    p += dot(p.yx, p.xy +  vec2(35.511, 7.584));\n    return fract(vec2(p.x * p.y * 195.714, p.x * p.y * 174.78));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n// seed the RNG (again taken from Devour)\n\tseed = float(((iFrame*73856093)^int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n  \n  \n  float shutterAperture = 0.6;\n\n    float focusDistance = float(iFrame)*.5;\n    float blurAmount = 0.55*(1./(1.5+float(iFrame)*.8));\n    int   numLevels = 5;\n\n\n\t// set up UVs, jittered for antialiasing\n\tvec2 uv = (gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n      uv *=1.+(fract(sin(float(iFrame)))*.1*length(uv))*(1./(.5+float(iFrame)*.08));\n      uv*=rot(sin(float(iFrame))*.01);\n\tvec3 gcol = vec3(0.);\n\n    vec3 col = vec3(0.1);\n   // vec3 ro = vec3(uv*6.+hash2()*inversesqrt(exp(iFrame)),-20.);\n   vec3 ro = vec3(uv*6.,-20.);\n    vec3 rt = vec3(0.);\n    vec3 rp = ro;\n\n    vec3 er = normalize(vec3(0.,0.,1.));\n    vec3 rd = er;\n\n     vec3 go = blurAmount*vec3( -2.5+ 5.0*hash2(), 0.0 );\n        go.xy *=rot(seed*.1);\n         go.xz *=rot(seed*.1);\n     vec3 gd = normalize( er*focusDistance - go );\n\n        ro += go*.1;\n        rd += gd*.1;;\n    vec3 light = vec3(-5,2.,-3.);\n    \n    vec3 acc = vec3(.0);\n    float s = 1.;\n    float dd = 1.;\n    for(float i=0.;i<=128.;i++){\n        vec2 d = sdf(rp);\n        vec3 mat_col = vec3(0.);\n        \n        d.x *=s;\n        if(d.y == 1.){\n            mat_col = vec3(.2,.8,.2);\n        } else if (d.y == 2.){\n            mat_col = vec3(.8,.2,.2);\n        }\n        if(d.y == 1. || d.y == 2.){\n         acc += mat_col*exp(.125*-abs(d.x*d.x))/30.;\n        }\n        if(d.x<.001){\n            vec3 n = norm(rp,.001);\n            vec3 nn = norm(rp,.005);\n            float diff = max(0.,dot(normalize(light-rp),n));\n            \n              float spc = max(0.,dot(normalize(ro-rp),reflect(normalize(rp-light),n)));\n            spc = pow(spc,32.);\n             if(d.y == 3.){\n                col = vec3(.3)*diff-vec3(1.)*step(.3,length(n-nn));\n                col = mix(col*.1,col,vec3(gao(rp,n))/3.);\n                break;\n            } else {\n            col += mat_col*smoothstep(.0,.1,length(n-nn));\n            \n            rp += rd*.1;\n            s*=-1.;\n           \n           if((gp.y) > -.99) { \n                vec3 ccol = 1.5*col*spc+diff*mat_col; \n                ccol = mix(ccol*.1,ccol,vec3(gao(rp,n))/2.);\n                col = mix(ccol,col,smoothstep(1.,-.545, gp.y+.8));\n                break;\n            }}\n            \n        }\n        rp += rd*d.x;\n    }\n    col += acc;\n     vec4 pframe = vec4(texture(iChannel0,fragCoord.xy/iResolution.xy));\n  col +=acc;\n\tcol +=pframe.xyz;\n   \n    \n\tfragColor = vec4(col,pframe.a+2.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}