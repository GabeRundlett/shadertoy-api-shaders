{
    "Shader": {
        "info": {
            "date": "1581664367",
            "description": "Soyombo with special change for Valentine's Day.",
            "flags": 0,
            "hasliked": 0,
            "id": "3ttSRS",
            "likes": 0,
            "name": "大龙猫 - Валентины Соёмбо",
            "published": 3,
            "tags": [
                "valentine",
                "soyombo"
            ],
            "usePreview": 0,
            "username": "totetmatt",
            "viewed": 296
        },
        "renderpass": [
            {
                "code": "/*Source : \n -  https://www.shadertoy.com/view/XsdyWr for the Rose Code\n -  https://www.shadertoy.com/view/Msc3WB inspiration for yin yang\n -  https://www.shadertoy.com/view/Msc3WB for the basic shape code\n -  Diverse HBHS Stream from Flopine (https://www.twitch.tv/flopine) for some GLSL tricks and the Ray March framework\n*/\n\n#define ITER 64.\n#define dtime pow(fract(iTime*.654),1.)+floor(iTime*.654)\n#define ttime sin(iTime*.8) *pow(cos(pow(iTime*.8,.125)),2.)\n\nconst float PI = 3.14159265359;\nconst float PI2 = 6.28318530718;\nconst float DEG_TO_RAD = PI / 180.0;\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n// 2D matrix Rotation\n\nmat2 r(float a){return mat2(cos(a),sin(a),\n                           -sin(a),cos(a));}\n// Using a shadertoy \n// https://www.shadertoy.com/view/XsdyWr\n///\nmat3 rotationXY( vec2 angle ) {\n    vec2 c = cos( angle );\n    vec2 s = sin( angle );\n    \n    return mat3(\n        c.y      ,  0.0, -s.y,\n        s.y * s.x,  c.x,  c.y * s.x,\n        s.y * c.x, -s.x,  c.y * c.x\n    );\n} \nfloat opI(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opU(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opS(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat sdPetal(vec3 p, float s) {\nfloat ratio = 7.;\n    p*=ratio+cos(fract(iTime))* sin(fract(iTime)*2.) ;\n    s/=1.5;\n    p = p * vec3(0.8, 1.5, 0.6) + vec3(0.1, 0.0, 0.0)*ratio;\n    vec2 q = vec2(length(p.xz), p.y);\n    \n    float lower = length(q) - 1.0;\n    lower = opS(length(q) - 0.97, lower);\n    lower = opI(lower, q.y);\n    \n    float upper = length((q - vec2(s, 0)) * vec2(1, 1)) + 1.0 - s;\n    upper = opS(upper, length((q - vec2(s, 0)) * vec2(1, 1)) + 0.97 - s);\n    upper = opI(upper, -q.y);\n    upper = opI(upper, q.x - 2.0);\n    \n    float region = length(p - vec3(1.0, 0.0, 0.0)) - 1.0;\n\n    return opI(opU(upper, lower), region)/16.;\n}\nfloat flower(vec3 p) {\np.xy*=r(PI);\np.yz*=r(PI/12.);\np.xz*=r(iTime*.33);\n float ratio = .8;\n p*=ratio;\n \n float d = 1000., s = 2.0;\n    mat3 r = rotationXY(vec2(0.01, PI2 * 0.618034));\n    r = r * mat3(1.08,0.,max(0.0,sin(dtime)*.2) ,0.0,0.995,max(0.0,cos(dtime)*.1), 0.0,max(0.0,cos(dtime)*.1),1.08);\n    for (int i = 0; i < 24; i++) {\n        d = opU(d, sdPetal(p, s));\n        p = r * p;\n        p += vec3(0.0, -0.001, 0.0);\n        s *= 1.05;\n    }\n    return d/ratio;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n/// Basic Shape & Operation\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat sdBox (vec3 p, vec3 corner)\n{ \n    vec3 q = abs(p)-corner;\n    return  min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.)); \n}\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat hash21(vec2 p) {\n  p = fract(p * vec2(247.34, 961.21324));\n  p += dot(p, p + 21.87);\n  return fract(p.x * p.y);\n}\n/////////////////////\n// Scene Shape\nfloat moon(vec3 pos) {\npos .xz*=r(-iTime+PI/2.);\nfloat visible = sdCappedCylinder(pos.xyz,vec3(0.,.0,-.1),vec3(.0,.0,.1),.4);\nfloat remove = sdCappedCylinder(pos.xyz-vec3(0.,.2,.0),vec3(0.,.0,-.2),vec3(.0,.0,.2),.5);\n    return max(visible,-remove);\n    return mix(remove,visible,sin(iTime));\n}\n\n\n\n\n\n\nfloat yin(vec3 pos, float p){\n       pos.xy *= r(p);\n   \n\n   float q = pos.y >0. ? sdCappedCylinder(pos.xyz-vec3(0.,0.0,.0),vec3(0.,0.0,-.1),vec3(0.0,0.0,.1), 0.6 ) : 1. ;\n   float r = sdCappedCylinder(pos.xyz-vec3(0.30,0.0,.0),vec3(0.,0.0,-.1),vec3(0.0,0.0,.1), 0.3 );\n   float t = sdCappedCylinder(pos.xyz-vec3(-0.30,0.0,.0),vec3(0.,0.0,-.2),vec3(0.0,0.0,.2), 0.3 );\n   float v = sdCappedCylinder(pos.xyz-vec3(0.30,0.0,.0),vec3(0.,0.0,-.2),vec3(0.0,0.0,.2), 0.1 );\n  \n   return max(-v,max(-t,min(r,q)));\n}\nfloat yinyang(vec3 pos) {\n        float ratio = 2.7;\n        pos *=ratio;\n      pos.xy *= r(PI/2.);\n        pos .zy*=r(tan(sin(iTime))*.25);\n       pos .xz*=r(tan(cos(iTime*.45))*.25);\n     return min(\n       yin(pos+vec3(.0,-.05,.0),0.),\n       yin(pos+vec3(.0,+.05,.0),PI)\n    )/ratio;\n}\nfloat flame(vec3 pos) {\n\n     float ratio = 2.5;\n    pos.y -=1.6;\n    pos*=2.5;\n    float q = pos.y <0. ? sdCappedCylinder(pos.xyz-vec3(0.,0.0,.0),vec3(0.,0.0,-.1),vec3(0.0,0.0,.1), 0.6 ) : ratio;\n    float f = pos.y >0. ? sdRoundCone(abs(pos)-vec3(0.4+(sin(pos.y*12.+iTime)+1.)*.04,0.,0.),.1,.01,.5)  : ratio ;\n    float central_flame = pos.y > 0. ? sdRoundCone(pos-vec3(-0.025+(sin(PI/2.+pos.y*12.+iTime*.7)+1.)*.04,0.,0.),.1,.01,.8) : ratio ;\n    return opSmoothUnion(q,opSmoothUnion(central_flame,f,0.5),0.25)/ratio ;\n    return min(q,min(central_flame,f))/ratio;\n\n}\n\nfloat sideBox(vec3 pos) {\n  pos.x = abs(pos.x);\n  pos = pos-vec3(.6,.0,.0);\n  pos.xz *= r(pow(sin(pos.y*2.*PI),2.)+iTime*.1);\n return sdBox(pos,vec3(0.16,0.6,0.1));\n}\n\nfloat backflower( in vec3 p, in float c, in vec3 l )\n{\n    p*=.5;\n      vec3 id = round(p/c);\n     p.x += .25+sign(sin(4.*id.z))*sin(iTime*.16);\n   \n    p.y -= .25+sign(cos(4.*id.z))*cos(iTime*.23);\n    \n   \n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    \n    q.zx*=r(iTime*.2+length(p.xz));\n   \n    return flower(q);\n}\n\nvec2 SDF(vec3 pos) {\n     vec3 ppos = pos;\n         pos.xz*=r(cos(iTime*.9)*.2);\n      pos.yz*=r(cos(iTime*.78)*.1);\n      \n    float sideBox =sideBox(pos);\n    \n    vec3 pos_tri = pos;\n    pos_tri.xy *= r(3.141592);\n    pos_tri.xy *= vec2(.5,1.3);\n    \n    float triangle = sdTriPrism(pos_tri+vec3(0.,.67,.0),vec2(0.2,0.1));\n    float box = sdBox(pos-vec3(.0,.29,.0),vec3(0.35,0.05,0.1));\n    float box2 = sdBox(pos-vec3(.0,-.29,.0),vec3(0.35,0.05,0.1));\n    \n    float triange2 = sdTriPrism(pos_tri+vec3(0.,-.6,.0),vec2(0.2,0.1));\n    float moon = moon(pos-vec3(.0,1.05,.0));\n    \n    float yy= yinyang(pos);\n    float fl = flame(pos);\n    float flow   = flower( (pos.xzy)+vec3(.0,-.01,-1.08));\n   \n    float flowrz = backflower(pos.xzy+vec3(0.,-10.,0.),1.,vec3(4.,.1,4.));\n    \n   float dist = min(fl,min(yy,min(moon,min(min(box,box2),min(min(triange2,triangle),min(sideBox,flowrz))))));\n    dist = min(dist,flow);\n   if(dist == flow && pos.y > .75) { // A DIRTY TRICK TO REMOVE BUG\n    \treturn vec2(dist,1.0);\n   } else if (dist == flowrz){\n   \t\treturn vec2(dist,2.0);\n   } else {\n       \treturn vec2(dist,0.0);\n   }\n}\n\n// Main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  \n  // Initialization of the Ray Marching algorithm\n  vec3 ray_origin = vec3(.01,.61,-3.); // Were we start \n  vec3 ray_direction = normalize(vec3(uv,1.)); // going forward\n  vec3 position = ray_origin ; \n  \n  vec3 color = vec3(.0,.3,.6); // By default, everything will be black\n  \n  bool hit = false; \n  \n  float shad = 0.;\n  float part = 0.;\n  for(float i=0.; i<ITER; ++i) { // We iterate the ray\n  \n    vec2 _distance = SDF(position); // Find the closest distance from the current position\n    if(_distance.x <0.001) { // If we are close enough, it's a hit, we put the shad and break the loop\n        shad = i / ITER;\n        hit = true;\n        break;\n     }\n     part = _distance.y;\n      \n      float f = position.z > 0.1 ? 1.9:1.; // Speedup for background\n     \n     position += _distance.x*f * ray_direction; // Otherwise we conditnue the marching, updating the ray position\n  }\n  \n  if(hit) { \n     color = vec3(1.-shad*.766); // Yeah no real lighting here, I like the render as it is\n    if(part == 0.){\n     color = mix(vec3(1.0,0.1,.0), vec3(.9,.9,0.1)+vec3(0.,0.,length(uv)), color)*(1.-shad); \n     } else if(part== 1.) {\n        color = mix(vec3(0.0,0.0,0.0), vec3(1.0,0.0,0.4)+vec3(0.,0.,length(uv)), color)*(1.-shad);\n        color-=max(0.,sin(iTime*1.3))*vec3(.0,.3,.6);\n    } else if(part ==2.) {\n    \tcolor = mix(vec3(.0,.3,.6), vec3(.0,.3,.6), color)*(1.75-shad);   \n        \n    }\n     \n  } \n \n  fragColor = vec4(color,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}