{
    "Shader": {
        "info": {
            "date": "1531667913",
            "description": "Utilizing the layout from DjinnKahn's \"Icosohedon Weave\" example to render something similar, but in a different style. I hope I did his original some justice.",
            "flags": 0,
            "hasliked": 0,
            "id": "MttczH",
            "likes": 48,
            "name": "Polyhedral Weave",
            "published": 3,
            "tags": [
                "polyhedra",
                "weave"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 1807
        },
        "renderpass": [
            {
                "code": "/*\n\n\tPolyhedral Weave\n\t----------------\n\t\n    Every now and again, someone will release a really cool -- not to mention, helpful -- \n\texample with little fanfare. One such case is DjinnKahn's \"Icosahedron Weave\" shader.\t\n\t\n\tProducing icosahedral geometry using a brute force vertice and triangle list is\n\tpretty straight forward. Folding space isn't really my thing, but that's not too\n\ttaxing either. However, I remember trying to weave something using a folding space\n\tmethod a while back and getting nowhere, and that was because when folding space\n\twith the standard algorithm you lose polarity. This became obvious to me... once \n\tsomeone with more brain power put up a polyhedral weave example. :D\n\n\tI hope I did some justice to the original. Code-wise, I didn't feel it necessary to \n\tmake many structural changes to the setup. Comparing the two examples, you can see \n\tthat DjinnKahn took a nice methodical approach, whereas I made everything up as I \n\twent along -- just for something different. :) Having said that, I did try to make up \n\tfor it by explaining a thing or two, so hopefully that'll help.\n\n\tI also wanted to produce a different capsule line look, which necessitated an\n\torthonormal approach. It's probably more expensive, but my fast machine didn't seem \n\tto notice. Having said that, I'll get in and try to speed things up later.\n\n\tUltimately, I'd like to post some more sophisticated examples, but figured I'd\n\tbetter get a polyhedral weave on the board first.\n\n\tBy the way, the \"opIcosahedronWithPolarity\" gives you triangle face information that\n\tis further subdivided into three sections, each with its own X-axis... 60 times \n\ticosahedral symmetry. Don't quote me on it, but I think the resultant object you're\n    working with is a trapezoidal (or deltoidal) hexecontahedron. If you look the object \n\tup on the net, it should make it more clear. Alternatively, you could uncomment the \n\t\"SHOW_EDGES\" and \"SHOW_FACE_SYMMETRY\" directive.\n\n\t\n\t// Based on:\n\t\n    // Not the easiest of geometry to wrap one's head around at the best of times, and \n\t// from what I understand, DjinnKahn (Tom Sirgedas) was learning about shaders and \n\t// SDF at the same time. Quite amazing.\n    Icosahedron Weave - DjinnKahn\n\thttps://www.shadertoy.com/view/Xty3Dy\n\n\tOther examples:\n\n\t// Knighty is more comfortable folding space than most. I fold space about \n    // as well as I fold laundry. :)\n\tPolyhedron again - knighty\n\thttps://www.shadertoy.com/view/XlX3zB\n\n    // Tdhooper has some awesome icosahedral examples.\n    Icosahedron twist - tdhooper\n\thttps://www.shadertoy.com/view/Mtc3RX\n\n\t// Really nice example with a different kind of weave using an alternate method to\n\t// obtain the icosahedral triangle information.\n\tmedusas hairdo with uv - flockaroo \n\thttps://www.shadertoy.com/view/ltBcDw\n\n*/\n\n#define FAR 20.\n\n// Visual guides to show the 3D weave pattern on the individual triangular faces and\n// the three repeat subregions.\n//\n// Dislays the 20 face icosahedral edges -- Not all the edges.\n//#define SHOW_EDGES\n// Combined with the above, this will show all edges. By itself, it'll produce the edges\n// (Although, not straight) of the icosahedral dual, namely, a dodecahedron.\n//#define SHOW_FACE_SYMMETRY \n// 20 face icosahedral vertices.\n//#define SHOW_VERTICES\n\n// This line emulates no polarity across the triangle face X axis... X axes, but let's\n// not confuse ourselves. :) The pattern is still interesting, but there's no weave.\n//#define NO_POLARITY\n\n\n// 2D rotation formula.\nmat2 rot2(float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// I paid hommage to the original and kept the same rotation... OK, I'm lazy. :D\nvec3 rotObj(vec3 p){\n    \n    p.yz *= rot2(iTime*.2);\n    p.zx *= rot2(iTime*.5);\n    return p;    \n}\n\n\n// There's a neat way to construct an icosohedron using three mutually perpendicular rectangular \n// planes. If you reference something along the lines of icosahedron golden rectangle, you'll \n// get a pretty good idea. There's a standard image here:\n// https://math.stackexchange.com/questions/2538184/proof-of-golden-rectangle-inside-an-icosahedron\n//\n// Anyway, even a cursory glance will give you a fair idea where the figures below originate. In \n// a vertex\\indice list environment, you could produce an icosahedron without too much trouble at \n// all. However, in a realtime raymarching situation, you need to get to the triangle face \n// information in as few operations as possible. That's achieved via a bit of space folding using \n// the same information in a different way.\n//\n// If weaving wasn't necessary, you could use the concise \"opIcosahedron\" function and be done\n// with it. Unfortunately, the \"abs\" calls throw out the triangular polarity information, which\n// you need to distinguish one side of the triangle from the other -- I wasted a lot of time not\n// realizing this until Djinn Kahn posted his example. He rewrote the folding function with an\n// additional variable to track polarity (signs) during each iteration.\n//\n// With this function, you can obtain the triangle face information and use it to render in the\n// three regions of symmetry -- each with a left and right X axis. From there, you can do whatever \n// you wish. \n\n// Vertices: vec3(0, A, B), vec3(B, 0, A), vec3(-B, 0, A).\n// Face center: (vec3(0, A, B) + vec3(0, 0, A)*2.)/3..\n// Edges: (vec3(0, A, B) + vec3(B, 0, A))/2.,  etc.\n\n\n// The following have come from DjinnKahn's \"Icosahedron Weave\" example, here:\n// https://www.shadertoy.com/view/Xty3Dy\n//\n// It works fine, just the way it is, so I only made trivial changes. I'd like to cut down the\n// number of operations in the \"opIcosahedronWithPolarity\" function, but so far, I can't see\n// a way to do that.\n\nconst float PHI = (1. + sqrt(5.))/2.;\nconst float A = PHI/sqrt(1. + PHI*PHI);\nconst float B = 1./sqrt( 1. + PHI*PHI);\nconst float J = (PHI - 1.)/2.; // .309016994375;\nconst float K = PHI/2.;        //J + .5;\nconst mat3 R0 = mat3(.5,  -K,   J   ,K ,  J, -.5   ,J , .5,  K);\nconst mat3 R1 = mat3( K,   J, -.5   ,J , .5,   K   ,.5 ,-K,  J);\nconst mat3 R2 = mat3(-J, -.5,   K  ,.5 , -K,  -J   ,K ,  J, .5);\n\n// I wanted all vertices hardcoded. The size factor effectively increases the size\n// of the weave object.\n#define size 1.25\nconst vec3 v0 = vec3(0, A, B)*size;\nconst vec3 v1 = vec3(B, 0, A)*size;\nconst vec3 v2 = vec3(-B, 0, A)*size;\n// Unlike DjinnKahn's example, I wanted to raise the center of the icosahedral triangle\n// face a bit... The \"1.06\" figure is a hack. If you want the point coplanar with the triangle, \n// take out the \"1.06\" figure. \"1.1547\" will roughly produce straight dodecahedron edges.\nconst vec3 cent = ((v0 + v1 + v2)/3.)*1.06;\n\n\n// Same as opIcosahedron, except without mirroring symmetry, so X-coordinate may be negative.\n// (note: when this is used as a distance function, it's possible that the nearest object is\n// on the opposite polarity, potentially causing a glitch).\nvec3 opIcosahedronWithPolarity(in vec3 p){\n   \n\tvec3 pol = sign(p);\n    p = R0*abs(p);\n\tpol *= sign(p);\n    p = R1*abs(p);\n\tpol *= sign(p);\n    p = R2*abs(p);\n\tpol *= sign(p);\n    vec3 ret = abs(p);\n    return ret * vec3(pol.x*pol.y*pol.z, 1, 1);\n}   \n\n/*\n// The original function -- sans polarity information -- is neat and concise.\nvec3 opIcosahedron(vec3 p){ \n  \n    p = R0*abs(p);\n    p = R1*abs(p);\n    p = R2*abs(p);\n    return abs(p);  \n} \n*/\n\n\n// A cheap orthonormal basis vector function - Taken from Nimitz's \"Cheap Orthonormal Basis\" example, then \n// modified slightly.\n//\n//Cheap orthonormal basis by nimitz\n//http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n//via: http://psgraphics.blogspot.pt/2014/11/making-orthonormal-basis-from-unit.html\nmat3 basis(in vec3 n){\n    \n    float a = 1./(1. + n.z);\n    float b = -n.x*n.y*a;\n    return mat3(1. - n.x*n.x*a, b, n.x, b, 1. - n.y*n.y*a, n.y, -n.x, -n.y, n.z);\n                \n}\n \n// A line segment formula that orients via an orthanormal basis. It'd be faster to use\n// IQ's 3D line segment formula, but this one allows for more interesting cross sections,\n// like hexagons and so forth.\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, float lf){ // Length factor on the end.\n\n\n    b -= a;\n    float l = length(b);\n    \n    p = basis(normalize(b))*(p - a - b*.5);\n    \n    p = abs(p);\n    //p.x = abs(p.x - .035);\n    //return = max(length(p.xy) - r, p.z - l*lf);\n    //return max((p.x + p.y)*.7071 - r, p.z - l*lf);\n    //return max(max(p.x, p.y) - r, p.z - l*lf);\n    //return max(max(max(p.x, p.y), (p.y + p.x)*.7071) - r, p.z - l*lf);\n    return max(max(p.y*.866025 + p.x*.5, p.x) - r, p.z - l*lf);\n}\n\n\n/*\n// IQ's 3D line segment formula. Simpler and cheaper, but doesn't orient carved cross-sections.\nfloat sdCapsule(vec3 p, vec3 a, vec3 b){\n\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    pa = abs(pa - ba*h);\n    return length( pa );\n}\n*/\n    \nvec4 objID;\n\n\nfloat dist(vec3 p, float r){\n    \n    return length(p) - r;\n    //p = abs(p);\n    //return max(length(p.yz) - r, p.x - r);\n    //return max(max(p.x, p.y), p.z) - r;\n    \n}\n\nfloat map(in vec3 p){\n   \n    \n    // Back plane. Six units behind the center of the weaved object.\n    float pln = -p.z + 6.;\n    \n    \n    // Rotate the object.\n    p = rotObj(p);\n    \n    // DjinnKahn's icosahedral distance function that produces a triangular face\n    // and allows you to determine between the negative and positive X axis.\n    //\n    // Weaves are simple: Connect lines from one edge to another and arrange for\n    // them to cross over one another inbetween. For instance, lines from the left\n    // should meet at a join that sits lower than the join connecting lines from\n    // the other direction... With that stand icosaheron function, you can't \n    // determine which side of the face you're one, so it's not possible. \n    // Thankfully, the following contains positive and negative X values.\n    p = opIcosahedronWithPolarity(p);\n    \n    \n    #ifdef NO_POLARITY\n    // This line emulates no polarity across the triangle face X axis. The pattern is \n    // still interesting, but the weave is gone. Not accounting for X polarity was the \n    // reason my original weaving attempts using a space folding formula didn't work --\n    // It's a bit hard to use negative values when there aren't any... Thankfully, \n    // DjinnKahn was learned up much more gooderer than me. :D\n    p.x = abs(p.x);\n    #endif\n\n \n    // Some constant variables.  \n    const vec3 flip = vec3(-1, 1, 1); // Quick way to swap from one side to the other.\n    const float lw = .02; // Capsule line thickness.\n    float lf = .45; // Capsule line length factor.\n    \n    // Height difference factor: The Z coordinate pushes things in or out. To create \n    // the weave, the mid point of the lines from one direction has to be higher or \n    // lower than those coming from the other. A lower number gives a tighter -- and\n    // probably nicer looking -- weave, but I wanted the object to look like it was\n    // hacked together... Kind of like this code. :D\n    const vec3 hd = vec3(0, 0, .08); \n    \n    \n    // Three distance field values. They're distinguishable for object identification\n    // purposes.\n    float d = 1e5, d2 = 1e5, d3 = 1e5;\n    \n    \n    #ifdef SHOW_EDGES\n    // Note the \"abs(p).\" That's just a quick way to make the coordinates non-polar, which\n    // allow you to render just one point, side, etc, and have all three show up. Space\n    // folding can do your head in sometimes. :)\n    //\n    // Showing the icosahedral frame -- for those like myself who require a visual understanding \n    // of what's happening... or for those who enjoy spoiling the illusion for themselves. :)\n    d = min(d, sdCapsule(abs(p), v0, v1, .0125, .55)); // Edges.\n    #endif\n    \n    #ifdef SHOW_VERTICES\n    d2 = min(d2, length(v0 - p) - .04); // Vertices.\n    #endif\n    \n    #ifdef SHOW_FACE_SYMMETRY\n    d2 = min(d2, sdCapsule(abs(p), mix(v0, v1, .5), cent, .0125, .55)); \n    #endif\n   \n    \n    // The weave pattern: The best way to see how this works is to uncomment the \n    // \"SHOW_EDGES\" and \"SHOW_VERTICES\" directives at the top of the page.\n    // In essence, we're using the prefolded coordinate symmetry and X polarity \n    // to render three woven crosses. By the way, the easiest way to see what \n    // something does is to comment it out.\n    //\n    // One thing that can get a little confusing is that the icosahedral folding\n    // formula gives you the cordinates a triangle that is subdivided a further\n    // three times. The lines of symmetry run between the face center and the \n    // mid points between the three sides. Each of those regions has a polar\n    // X-axis. Of course, descriptions don't mean a thing until you can look at\n    // a visual, so uncomment \"SHOW_EDGES\" and \"SHOW_FACE_REGIONS.\" \n    \n    // A point 21.5% of the way from v0 along the v0-v1 edge. This is a standard\n    // way to obtain a linear position between two points.\n    vec3 a = mix(v0, v1, .425*.5);\n    // 37.5% if the way between the middle of edge v0-v2 and the triangular face center.\n    vec3 b = (mix(mix(v0, v2, .5), cent, .375));\n    vec3 mid = (mix(a, b, .5)); // Half way between points \"a\" and \"b\".\n    \n    // Render the first cross. Note that the mid point dips at the midpoint on one\n    // stoke and raises on the other.\n    d = min(d, sdCapsule(p, a, mid - hd, lw, lf));\n    d = min(d, sdCapsule(p, mid - hd, b, lw, lf));\n    d = min(d, sdCapsule(p, flip*a, flip*mid + hd, lw, lf));\n    d = min(d, sdCapsule(p, flip*mid + hd, flip*b, lw, lf));\n\n    // There are two rails in all. This is another rendered next to the first.\n    // The result is double rails.\n    vec3 a2 = (mix(v0, v1, .575*.5));\n    vec3 b2 = (mix(mix(v0, v2, .5), cent, .625));\n    vec3 mid2 = (mix(a2, b2, .5));\n    \n    d = min(d, sdCapsule(p, a2, mid2 - hd, lw, lf));\n    d = min(d, sdCapsule(p, mid2 - hd, b2, lw, lf));\n    d = min(d, sdCapsule(p, flip*a2, flip*mid2 + hd, lw, lf));\n    d = min(d, sdCapsule(p, flip*mid2 + hd, flip*b2, lw, lf)); \n    \n    const float lw2 = .035; // Thicker joiner capsule lines.\n    lf = 1.; // Longer joiner capsule lines.\n    \n    // The gold joiner capsules connecting one rail to the other.\n    d2 = min(d2, sdCapsule(abs(p), a, a2, lw2, lf));\n    d2 = min(d2, sdCapsule(abs(p), flip*b, flip*b2, lw2, lf));\n    \n    \n    // The ball bearing joiners at the mid points.\n    const float jw = .02;\n    d3 = min(d3, dist(mid - hd - p, jw));\n    d3 = min(d3, dist(mid2 - hd - p, jw));  \n    d3 = min(d3, dist(flip*mid + hd - p, jw));    \n    d3 = min(d3, dist(flip*mid2 + hd - p, jw));  \n     \n    \n    // Store the individual object values for sorting later. Sorting multiple objects\n    // inside a raymarching loop probably isn't the best idea. :)\n    objID = vec4(d, d2, d3, pln);\n    \n    return min(min(d, d2), min(d3, pln));\n}\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ. In instances where there's no descernible \n// aesthetic difference between it and the six tap version, it's worth using.\nvec3 calcNormal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n*/\n\n/*\n// Standard normal function. 6 taps.\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Normal calculation, with some edging and curvature bundled in.\nvec3 calcNormal(vec3 p, inout float edge, inout float crv, float t) { \n\t\n    // It's worth looking into using a fixed epsilon versus using an epsilon value that\n    // varies with resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    vec2 e = vec2(2.5/mix(400., iResolution.y, .5), 0);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n/*    \n    // Wider sample spread for the curvature.\n    e = vec2(12./450., 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n*/\n    \n    e = vec2(.001, 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// Raymarching: The distance function is a little on the intensive side, so I'm \n// using as fewer iterations as necessary. Even though there's a breat, the compiler\n// still has to unroll everything, and larger numbers make a difference.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    float t = 0., d;\n    \n    for(int i = 0; i<64; i++){\n    \n        d = map(ro + rd*t);\n        if(abs(d) < .001*(1. + t*.05) || t > FAR) break;\n        t += d;\n    }\n    \n    return min(t, FAR);\n}\n\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function and have been looking for an excuse to use it. For a better version, and usage, \n// refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO( in vec3 p, in vec3 n, float maxDist )\n{\n\tfloat ao = 0.0, l;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte + .5; i++ ){\n    \n        l = (i + hash(i))*.5/nbIte*maxDist;\n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n\n// The iterations should be higher for proper accuracy.\nfloat softShadow(in vec3 ro, in vec3 rd, float t, in float end, in float k){\n\n    float shade = 1.0;\n    // Increase this and the shadows will be more accurate, but more iterations slow things down.\n    const int maxIterationsShad = 24; \n\n    // The \"start\" value, or minimum, should be set to something more than the stop-threshold, so as to avoid a collision with \n    // the surface the ray is setting out from. It doesn't matter how many times I write shadow code, I always seem to forget this.\n    // If adding shadows seems to make everything look dark, that tends to be the problem.\n    float dist = .001*(1. + t*.1);\n    float stepDist = end/float(maxIterationsShad);\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n        // End, or maximum, should be set to the distance from the light to surface point. If you go beyond that\n        // you may hit a surface not between the surface and the light.\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n        \n        // What h combination you add to the distance depends on speed, accuracy, etc. To be honest, I find it impossible to find \n        // the perfect balance. Faster GPUs give you more options, because more shadow iterations always produce better results.\n        // Anyway, here's some posibilities. Which one you use, depends on the situation:\n        // +=max(h, 0.001), +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\n        \n        dist += clamp(h, 0.01, 0.25);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if (abs(h)<0.0001 || dist > end) break; \n    }\n\n    // I usually add a bit to the final shade value, which lightens the shadow a bit. It's a preference thing. Really dark shadows \n    // look too brutal to me.\n    return min(max(shade, 0.) + 0.1, 1.0); \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Aspect correct screen coordinates.\n    vec2 p = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(p, 1.));\n    \n    // Ray origin, doubling as the camera postion.\n    vec3 ro = vec3(0.0, 0.0, -3.);\n    \n    // Light position. Near the camera.\n    vec3 lp = ro + vec3(0.25, 2, 0);\n    \n    // Ray march.\n    float t = trace(ro, rd);\n    \n    // Object identification: Back plane: 3, Golden joins: 2., \n    // Ball joins: 1., Silver pipes:  0.\n    float svObjID = objID.x<objID.y && objID.x<objID.z && objID.x<objID.w? 0.: \n    objID.y<objID.z && objID.y<objID.w ? 1. : objID.z<objID.w? 2. : 3.;\n\n    \n    // Initiate the scene color zero.\n    vec3 col = vec3(0);\n    \n    // Surface hit. Color it up.\n    if(t < FAR){\n    \n        // Position.\n        vec3 pos = ro + rd*t;\n        // Normal.\n        //vec3 nor = calcNormal(pos);\n        // Normal, plus edges and curvature. The latter isn't used.\n        float edge = 0., crv = 1.;\n        vec3 nor = calcNormal(pos, edge, crv, t);\n        \n        //vec3 rp = rotObj(pos);\n        \n        // Light direction vector.\n        vec3 li = lp - pos;\n        float lDist = max(length(li), .001);\n        li /= lDist;\n        \n        // Light falloff - attenuation.\n        float atten = 1.5/(1. + lDist*.05 + lDist*lDist*0.01);\n        \n        // Soft shadow and occlusion.\n        float shd = softShadow(pos + nor*.0015, li, t, lDist, 8.); // Shadows.\n        float ao = calculateAO(pos, nor, 4.);\n        \n        \n        float diff = max(dot(li, nor), .0); // Diffuse.\n        float spec = pow(max(dot(reflect(-li, nor), -rd), 0.), 16.); // Specular.\n        // Ramping up the diffuse. Sometimes, it can make things look more metallic.\n        diff = pow(diff, 4.)*2.; \n        \n        \n        float Schlick = pow( 1. - max(dot(rd, normalize(rd + li)), 0.), 5.0);\n\t\tfloat fre2 = mix(.5, 1., Schlick);  //F0 = .5.\n\t\t\n        col = vec3(.6); // Silver pipes.\n        \n        if(svObjID == 1.) { // Golden joins\n            col = vec3(1, .55, .2);\n            col = mix(col, col.yxz, rd.y*.5);\n        }\n        //if(svObjID == 2.) col = vec3(1, .55, .2).zyx/1.5; // Ball joins.\n        if(svObjID == 3.) { // Back plane.\n            \n            // Subtle blue gradient with fine lines.\n            col = vec3(1, .55, .2).zyx/7.;\n            col = mix(col, col.yxz, rd.y*.1 + .1);\n            col *= clamp(sin((pos.x - pos.y)*iResolution.y/8.)*2. + 1.5, 0., 1.)*.5 + .5;\n        }\n        \n        // Diffuse plus ambient term.\n        col *= diff + .25; \n        \n        // Specular term.\n        if(svObjID == 3.) col += vec3(1, .6, .2).zyx*spec*.25; // Less specular on the back plane.\n        else col += vec3(.5, .75, 1.)*spec*2.;\n        \n        col *= 1. - edge*.7;\n        //col = col*.7 + edge*.3;\n        \n        col *= atten*shd*ao; // Light falloff.\n        \n         \n    }\n    \n    // Screen color. Rough gamma correction. No fog or postprocessing.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}