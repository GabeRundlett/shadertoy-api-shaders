{
    "Shader": {
        "info": {
            "date": "1680488582",
            "description": "made for hex house's first birthday. uses a lot of SDF functions from https://mercury.sexy/hg_sdf/\nrounded cylinder and rounded cone function from https://iquilezles.org/articles/distfunctions/",
            "flags": 0,
            "hasliked": 0,
            "id": "cs3XDf",
            "likes": 4,
            "name": "isometric cake",
            "published": 3,
            "tags": [
                "cake",
                "isomentric"
            ],
            "usePreview": 0,
            "username": "charstiles",
            "viewed": 212
        },
        "renderpass": [
            {
                "code": "#define PI 3.141592\n\n//the following functions are from mercury.sexy/hg_sdf\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\nvec3 fade(vec3 x) { return x * x * x * (x * (x * 6. - 15.) + 10.); }\n\nvec3 phash(vec3 p)\n{\n    p = fract(mat3(1.2989833, 7.8233198, 2.3562332,\n                   6.7598192, 3.4857334, 8.2837193,\n                   2.9175399, 2.9884245, 5.4987265) * p);\n    p = ((2384.2345 * p - 1324.3438) * p + 3884.2243) * p - 4921.2354;\n    return normalize(fract(p) * 2. - 1.);\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\nfloat noise(vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    float d000 = dot(phash(ip), fp);\n    float d001 = dot(phash(ip + vec3(0, 0, 1)), fp - vec3(0, 0, 1));\n    float d010 = dot(phash(ip + vec3(0, 1, 0)), fp - vec3(0, 1, 0));\n    float d011 = dot(phash(ip + vec3(0, 1, 1)), fp - vec3(0, 1, 1));\n    float d100 = dot(phash(ip + vec3(1, 0, 0)), fp - vec3(1, 0, 0));\n    float d101 = dot(phash(ip + vec3(1, 0, 1)), fp - vec3(1, 0, 1));\n    float d110 = dot(phash(ip + vec3(1, 1, 0)), fp - vec3(1, 1, 0));\n    float d111 = dot(phash(ip + vec3(1, 1, 1)), fp - vec3(1, 1, 1));\n    fp = fade(fp);\n    return mix(mix(mix(d000, d001, fp.z), mix(d010, d011, fp.z), fp.y),\n               mix(mix(d100, d101, fp.z), mix(d110, d111, fp.z), fp.y), fp.x);\n}\n// Same, but mirror every second cell at the diagonal as well\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n    vec2 c = floor((p + size*0.5)/size);\n    p = mod(p + size*0.5, size) - size*0.5;\n    p *= mod(c,vec2(2.))*2. - vec2(1);\n    p -= size/2.;\n    if (p.x > p.y) p.xy = p.yx;\n    return floor(c/2.);\n}\n\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n    vec2 halfsize = size*0.5;\n    vec2 c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    p *= mod(c,vec2(2.))*2. - vec2(1);\n    return c;\n}\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n    return max(max(v.x, v.y), max(v.z, v.w));\n}\n\n//end mercury functions\n\n// these 2 functions are from https://iquilezles.org/articles/distfunctions/\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}  \n\n\nfloat scene(vec3 pos){\n    \n   pR(pos.xz,sin(iTime/4.));\n   \n   vec2 id = pModMirror2(pos.xz,vec2(40,60));\n   \n    float r0 = 2.;\n   float cake0 = sdRoundedCylinder(pos + vec3(0,6,0), r0,r0,0.4);\n   float r1 = 1.5;\n   float cake1 = sdRoundedCylinder(pos + vec3(0,3,0), r1,r1,0.5);\n   float r2 = 1.;\n   float cake2 = sdRoundedCylinder(pos + vec3(0,0.5,0), r2,r2,0.4);\n   float r3= .1;\n   float cand0 = sdRoundedCylinder(pos + vec3(0,-1.3,0), r3,r3,0.4);\n    float light = sdRoundCone(pos + vec3(0,-2.1,0), 0.2,0.05,0.3 );\n    cand0 = min(light,cand0);\n    pModPolar(pos.xz,15.);\n    float decor = sdRoundCone(pos + vec3(-3.2,4.,0), 0.2,0.05,0.3 );\n     decor = min(decor, sdRoundCone(pos + vec3(-2.,1.,0), 0.2,0.05,0.3 ));\n     decor = min(decor, sdRoundCone(pos + vec3(-3.9,7,0), 0.2,0.05,0.3 ));\n    float s = 0.4;\n    float fl = smin(cand0,smin(cake2,smin(cake0,cake1,s),s),0.1);\n    return smin(decor,fl,0.1);\n}\n\n vec3 estimateNormal(vec3 p) {\n    float smallNumber = 0.002;\n    vec3 n = vec3(\n    scene(vec3(p.x + smallNumber, p.yz)) -\n    scene(vec3(p.x - smallNumber, p.yz)),\n    scene(vec3(p.x, p.y + smallNumber, p.z)) -\n    scene(vec3(p.x, p.y - smallNumber, p.z)),\n    scene(vec3(p.xy, p.z + smallNumber)) -\n    scene(vec3(p.xy, p.z - smallNumber)));\n    return normalize(n);\n}\n\n\n\nvec4 lighting(vec3 ray, vec2 id){\n    vec3 norm = estimateNormal(ray);\n    vec3 light= vec3(0,.0,0);\n    float dif = dot(norm, light);\n    vec4 retCol = vec4(dif) - rand(id);\n    vec3 lightRayDir = normalize(light-ray) ;\n    //retCol = min(vec4(traceShadow(ray, lightRayDir)),retCol);\n    return retCol + vec4(norm,1) + rand(vec2(ray.xy)) ;\n}\n\n\n\nvec4 trace(vec3 rayO, vec3 dir){\n\n    vec3 ray = rayO;\n    float dist = 0.;\n    float totalDist = 0.;\n    vec3 s;\n    vec4 bg = vec4(0);\n    for(int i =0; i< 32; ++i){\n        \n        dist = scene(ray);\n        totalDist+=dist;\n        ray += dist * dir ;\n        \n        if(dist < 0.01){\n            vec4 retCol = 1.-(vec4(totalDist)/5.);\n            retCol = lighting(ray, s.yz);// * retCol; \n            return retCol;\n        }\n        if(totalDist >5.){return bg;}\n    }\n     return bg;\n}\n\n\nvec3 getRdIsometric(inout vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 rd = normalize(\n        lookAt -\n        ro\n    );\n    \n    vec3 right = normalize(cross(vec3(0,1,0), rd));\n    vec3 up = normalize(cross(rd, right));\n    \n    float zoom = 10.;\n    ro += right*uv.x*zoom;\n    ro += up*uv.y*zoom;\n    return rd;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = -1. + 2. * uv;\n    uv.y -= 0.3;\n    uv.y*= iResolution.y/iResolution.x;\n    uv.y*= 1.2;\n    vec3 cam =vec3(1,0,1);\n    \n    vec3 lookAt = vec3(0,-1.,-1);\n    \n    \n    vec3 ro = vec3(0,-0,-3);\n   \n    vec3 dir = getRdIsometric(ro, lookAt, uv); \n\n    vec4 col = trace(ro, dir);\n    \n    fragColor = col.rrra ;//+ rand(v_texcoord.xy+time )*0.3; //texture2D(texture4, v_texcoord);//\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}