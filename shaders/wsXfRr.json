{
    "Shader": {
        "info": {
            "date": "1587595616",
            "description": "Trying to understand sl2c's very interesting Up the River shader: [url]https://www.shadertoy.com/view/Wd2yzd[/url]\n\nBackground, by John Conway: [url]https://www.maths.ed.ac.uk/~v1ranick/papers/conwaysens.pdf[/url]",
            "flags": 16,
            "hasliked": 0,
            "id": "wsXfRr",
            "likes": 6,
            "name": "Further Up the River",
            "published": 3,
            "tags": [
                "tiling",
                "quadratic",
                "conway",
                "hyperbolic"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 372
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Further Up the River, Matthew Arcus, mla, 2020.\n// Derived from https://www.shadertoy.com/view/Wd2yzd by sl2c\n//\n// Shows the (2,3,infinity) hyperbolic tiling, with a hyperbolic\n// translation preserving the fixed points of a Mobius transform\n// (+-1/sqrt(2) in fact). Apeirogon borders are shown forming a\n// \"river\" with tributaries (as described below).\n//\n// Controls:\n// b: unshifted map as background\n// f: highlight fixed points\n// h: halfplane\n// r: highlight river\n// t: tiling\n// \n// Shader shows the (2,3,infinity) tiling of the hyperbolic plane, either\n// the disc or halfplane model. This tiling divides the plane up into\n// an infinite number of apeirogons - infinite sided polyhedra - which\n// touch the real line at rational points, in the halfplane\n// model. Define an integral (real) Mobius transformation, T(x) =\n// (ax+b)/(cx+d), lift this to work on the whole complex plane,\n// preserving the real axis (or unit circle). Generally T \n// has two fixed points (solve the quadratic) which divide the real\n// line in two parts, with T(x)-x < 0 in one part, T(x)-x > 0 in the\n// other part. If x is rational, we can expand T(x)-x = T(p/q)-p/q to\n// get a binary quadratic form (substitute p/q for x and expand): Ap^2\n// + Bpq + Cq^2, which takes values < 0 in one of those parts, and > 0\n// in the other part, so we can divide the apeirogons of the tiling\n// into two sets, depending on the quadratic form's value at the point\n// the apeirogon touches the real line, so the River of the title is\n// the line that divides these sets, and in fact has a periodic\n// structure.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Original copyright header:\n////////////////////////////////////////////////////////////////////////////////\n// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \n////////////////////////////////////////////////////////////////////////////////\n\nfloat PI = 3.1415927;\n\n// Keep track of scaling factor\nvoid invert(inout vec2 z, inout float ds) {\n  float k = 1.0/dot(z,z);\n  z *= k;\n  ds *= k;\n}\n\nvoid invert(inout vec2 z, float r2, inout float ds) {\n  float k = r2/dot(z,z);\n  z *= k;\n  ds *= k;\n}\n\n// (a,b,c,d) => (a,a+b,c,c+d);\nmat2 L = mat2(1,1,0,1); // {b+=a; d+=c;}\nmat2 R = mat2(1,0,1,1); // {a+=b; c+=d;}\n\nbool alert = false;\n\nvec2 color(vec2 z, float ds) {\n  bool parity = false;\n  for(int i = 0; i < 60; i++) {\n    z.x = fract(z.x); // Unit grid\n    if (z.x > 0.5) {\n      z.x = 1.0-z.x; // Reflected\n      parity = !parity;\n    }\n    if (dot(z,z) >= 1.0) break;\n    // Unit circle inversion\n    invert(z,ds);\n    parity = !parity;\n  }\n  // ds = scale factor = pixel width (more or less)\n  float c = 0.0;\n  float d = min(z.x,0.5-z.x);\n  // d = |z|-1 = sqrt(z.z) - 1 = 0.5*z.z - 1 (approx)\n  float d1 = 0.5*(dot(z,z) - 1.0);\n  d = min(d,d1);\n  if (d < ds) {\n    c = 0.5 - 0.5*d/ds;\n  }\n  //c = min(max(c,2.0*ds),0.5); // Grey out highly magnified areas\n  if (parity) c = 1.0 - c;\n  return vec2(c,d1);\n}\n\nbool key(int code) {\n  return texelFetch(iChannel3, ivec2(code,2),0).x != 0.0;\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_H = 72;\nconst int CHAR_J = 74;\nconst int CHAR_L = 76;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_Z = 90;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 z = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n  float ds = 1.0/iResolution.y;\n    \n  vec3 col;\n  float r2 = dot(z,z);\n  bool halfplane = key(CHAR_H);\n  if (halfplane || r2 < 1.0) {\n    // Map to halfplane,\n    if (halfplane) {\n      z.y += 1.0;\n    } else {\n      z.y = -z.y;\n      z.y -= 1.0;\n      invert(z,2.0,ds);\n      z.y += 1.0;\n    }\n    // Construct our Mobius transform starting from the identity.\n    mat2 T = mat2(1,0,0,1);\n    // L and R preserve det(T) = 1. Stern-Brocot connection here.\n    T = L*R*R*L*T; // (3,2,4,3)\n#if 0\n    if (a+d<=2) {\n      // treat null rotations specially\n      if (c>0) {\n        z.x += 0.5;\n      } else {\n        z.x = 0.5 - z.x;\n      }\n      invert(z,ds);\n      z.x -= 0.1 * iTime;\n      vec2 cdata = color(z,ds);\n      fragColor = vec4(cdata.x,1.0);  // gamma correction suggested by FabriceNeyret2\n      fragColor = pow(fragColor, vec4(1./2.2));\n      return;\n    }\n#endif\n    // Fixed points are (a-d +- sqrt(disc))/(2c)\n    // Note that ad-bc = 1, so we get a simple form for the discriminant.\n    float a = T[0].x, b = T[1].x, c = T[0].y, d = T[1].y;\n    float disc = sqrt((a+d)*(a+d)-4.0);\n    float fixed0 = (a-d+disc) / (2.0*c); // Map to 0\n    float fixed1 = (a-d-disc) / (2.0*c); // Map to infinity\n    float inverse_diff = float(c) / disc; \n    float period = 2.0*log(0.5*(a+d+disc)); // Period - where does this come from?\n\n    vec2 z0 = z;\n    float k = 1.0;\n    if (!key(CHAR_B)) k *= 0.8+0.2*color(z,ds).x; // Show unshifted map\n\n    // Conjugate dilation with map of fixed points to (0,inf).\n    z.x -= fixed0;\n    invert(z,ds);\n    z.x += inverse_diff;\n\n    float t = 0.5*iTime;\n    t = mod(t,period);\n    z *= exp(t); ds *= exp(t);\n\n    z.x -= inverse_diff;\n    invert(z,ds);\n    z.x += fixed0;\n\n    vec2 cdata = color(z,ds);\n    k *= 0.3+0.7*cdata.x;\n    col = vec3(1);\n    if (!key(CHAR_T)) col *= k;\n    if (!key(CHAR_R)) col = mix(vec3(1,0,0),col,smoothstep(-0.05,+0.05,cdata.y));\n    if (!key(CHAR_F)) {\n      float d = distance(z0,vec2(fixed0,0));\n      d = min(d,distance(z0,vec2(fixed1,0)));\n      col = mix(vec3(1,0,0),col,smoothstep(0.0,0.05,d));\n    }\n  } else {\n    col = vec3(1,1,0.75);\n  }\n  if (alert) col.r = 1.0;\n  fragColor = vec4(pow(col, vec3(0.4545)),1);  // gamma correction suggested by FabriceNeyret2\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}