{
    "Shader": {
        "info": {
            "date": "1539551546",
            "description": "TestInstrument4Times() and its subroutines are quite efficient at making a random melody with 4x overlap, of an instrument with many sharp overtones with a slow fallof (banjo)",
            "flags": 8,
            "hasliked": 0,
            "id": "MltfDH",
            "likes": 4,
            "name": "FM Random Banjo",
            "published": 3,
            "tags": [
                "fm",
                "overlap",
                "fibonacci",
                "banjo",
                "overtones"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 616
        },
        "renderpass": [
            {
                "code": "//\"audiovisual\" tag means it uses moudular arithmetic (fourier analysis, roots of unity)\n//, or at least some sort of audio-visualization, if only a blinking lights show\n//,to use the same functions to render audio and video\n//all code is in commons tab\n\n\nvoid mainImage(out vec4 o,vec2 u){o=image(u,iMouse.xyzw,iResolution.xy,iTime);}\n//vec2 mainSound( in int samp,float t){return sound(t);}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//fork of\n//https://www.shadertoy.com/view/4ldfDr\n//for the sake of its TestInstrument4Times() function\n//that is quite efficient in generatinga random melody\n//with fibonacci sequencing\n//, seeded by iDate.zw, with 4x overlap\n//,using fast vectorization.\n\n//currently a messy union of 2 instrument collections\n//, to get roughly one third added to them.\n//its messy, full of dupes, and sortign it is a longer process...\n//while sorting  and comparing, you notice a lot of patterns/aliases\n//and permutations of them are an emergend process.\n\n//i started naming my excustions in toing this wirth FM synthesis alphabetically\n//because i delayed the trickier process of comparing ALL the hulls/gains/amps/windowFunctions...\n//for 2 years, and collected enough examples, top sort their files alphjabetically\n//and i oince again skilled most of my [d]rum instruments...\n//because i needed a a good union of my previous FM collection:\n//so this is now a mess of 2 collections...\n\n\n\n//self:   https://www.shadertoy.com/view/4ldfDr\n//parent: https://www.shadertoy.com/view/XttfWn\n//parent: https://www.shadertoy.com/view/Ml3fDr\n//parent: https://www.shadertoy.com/view/ldXBzj \n\n//end of intro, start of UI parameters (change these, without risking to break much)\n\n     \n//dft dempt is a recource hog, because of bad memory management and no recursion/tree.\n//iterscaDFT sets how many dft iterations you want\n//iterMaxDFT sets a limit. there is a n=min(iterscaDFT,iterMaxDFT*u.x) somewhere\n//and a resource hogging loop over that [n]\n//the dft is easier to read while iterscaDFT*u.x<iterMaxDFT (right side of the red bar)\n//because overtoners then live on other diagonals than the local extrema. \n//but when iterscaDFT iterMaxDFT (left sifde of the bar) the image \"flattens\"\n\n//may want to remove this to get 10* fps.\n#define showDFT\n//ideally iterMaxDFT should share many prime factors of 440.\n#define iterMaxDFT 220.\n//the mouse inoput is funy iff bot hlimits are set to the same, which simplifies intuition\n#define iterscaDFT iterMaxDFT\n//the trick here is that iterscaDFT looks better AND computes faster\n//, once you get used to the diagonals of the overtones.\n//a less diagonal-overtone view still persists as mental anchor on the left half of the red bar\n\n\n//this is a namespace mess of globals: YAY:\n\n\n//reverb slows down parsing a lot, and may crash opengl iff there is not enough vRam\n//for all the instruments/sets that have reverb/echo defined.\n#define doReverb true\n\n\n#define base_a4 440.\n//vibrato for ap() as subroutine of arp()\n#define apVibratoDelay .1\n\n//https://www.shadertoy.com/view/Xtl3DB\n//buzz electric, with doppler erffect\n//for doppler shift\n#define SPEEDOFSOUND 20.\n//for doppler shift\n#define DAMPING 1.\n\n\n//int globalTranspose=0;\nfloat baseFreq=1.0;\nfloat globalTime=0.0;\nfloat speed=1.2;\nfloat tempo = 0.0;\nfloat tune  = 0.0;\n\n//RES .02 for DrWho intro\n#define RES .02\n\n\n#define globalTranspose 0\n\n\n//i keep confusing these 2 labels all the time\n\n\n\n//__end__ UI modes\n//_start_ credit licenses\n\n//MdjXWc is by Dmitry Andreev - and'2014\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//__end__ credit licenses\n//__start_ structure\n\n//bijectively linear-project [u] from domain [s1,s2] to range [t1,t2]\n//easily works for 4d vectors, for domaon-stretching portals and window-contexts.\n#define biject(u,s1,s2, t1, t2) mix(t1,t2,(u)/(s2-(s1)))\n//nonlinear bijections are more special, and should be seperated.\n\n//(sorted/sequential) [a] divides a domain with 3 cuts, return b[t]\nfloat bilinT(float t,vec3 a,vec4 b){\n   return  mix(mix(b.w,b.z,step(t,a.z)),mix(b.y,b.x,step(t,a.x)),step(t,a.y));}\n\n#define vec1 float\n#define dd(a) dot(a,a)\n#define u2(a) ((a)*2.-1.)\n#define u5(a) ((a)*.5+.5)\n#define sat(a) clamp(a,0.,1.)\n#define pow2 exp2\n#define TT(d) mod(mod(time,1.0)-d,1.0)\n#define trunc(a) float(int(a))\n#define ma0(a) max(0.,a)\nvec2 fr(float a){return vec2(fract(a),floor(a));}\nfloat su(vec4 a){return a.x+a.y+a.z+a.w;}\n\n\nvec2 pan(float p){return vec2(0.5-p*0.5,0.5+p*0.5);}\n\n\nconst float beatLength = 1.0/7.5;\n\n\n\nstruct w11{vec1 a;vec1 b;};\nstruct w12{vec1 a;vec2 b;};\nstruct w13{vec1 a;vec3 b;};\nstruct w14{vec1 a;vec4 b;};\n    \n\n//explicit integer modulo\nint imod(int x, int y){return x -(x / y) * y;}\n\nvec3 mx(vec3 a,vec3 b,vec3 c){return mix(a,b,c);}\nvec3 mx(float a,vec3 b,vec3 c){return mix(vec3(a),b,c);}\nvec2 cs(float a){return vec2(cos(a),sin(a));}\nvec1 suv(vec4 a){return dot(vec4(1),a);}vec1 suv(vec3 a){return dot(vec3(1),a);}vec1 suv(vec2 a){return a.x+a.y;}//sum of vector\n\n\n//___end__ structure\n//__start_ hash noise\n\n//hashes and noises (messy namespace function stuff, instrument lib specific, oh well:\nfloat noise1(float t, float seed){return 1.0+sin(t * 0.02 * seed+sin(t * 0.05 * seed)) * 0.25;}\n//zsed for drums, a sin(dot()) noise tends to be more pseudo-fractal.\nfloat rand(vec2 co){return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);}\n// Hash from https://www.shadertoy.com/view/4djSRW\nvec2 hash2(vec2 p\n){p=fract(p * vec2(5.3983, 5.4427))\n ;p+=dot(p.yx,p.xy+ vec2(21.5351, 14.3137))\n ;return fract(p.x*p.y*vec2(95.4337,97.597));}\nfloat rand(float a){return fract(sin(a) * 43758.5453123);}\nfloat noise(float a){return sin(mix(rand(floor(a)),rand(floor(a+1.)),fract(a)));}\nfloat fbm(float a\n){float s=0.\n ;for (float i=1.;i<5.;i++\n ){s+=noise(a)/i\n  ;a*=2.\n  ;}return s;}\nvec2 noise2(float t){return hash2(vec2(t, t * 1.423)) * 2.0-1.0;}\nfloat hash(float x){return fract(sin(x)*265871.1723);}\nfloat noize(float t){return fract(sin(t*3314.9)*342.0);}\nfloat rand21(vec2 co){return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);}\n\n\n// Hash from https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p\n){p=fract(p * vec2(5.3983, 5.4427))\n ;p+=dot(p.yx,p.xy+vec2(21.5351, 14.3137))\n ;return fract(vec2(p.x*p.y*95.4337,p.x*p.y*97.597));}\n/*\n//vec2 noise(float t){return hash22(vec2(t,t*1.423))*2.-1.;}\nvec2 lpnoise(float t, float f\n){vec2 g=fr(t*f)\n ;return mix(noise(g.y/f),noise((g.y+1.)/f),smoothstep(0.,1.,g.x));}*/\n\n\n//https://www.shadertoy.com/view/MdjXWc\nvec2 lpnoise(float t, float fq//FM lp-noise for reverb\n){t*=fq\n ;float f=fract(t)\n ;vec2 r=floor(t-f+vec2(0,1))/fq\n ;f=smoothstep(0.,1.,f)//;f=step(f,0.)//harder and faster\n ;return mix(noise2(r.x),noise2(r.y),f);}\n\n\n\n\n\n//__end___ hash noise\n//_start__ elemenraty fourier epicircles\n\n#define pi acos(-1.)\n#define pi2(a) (2.*pi*(a))\n#define co2p(a) cos(pi2(a))\n#define si2p(a) sin(pi2(a)) \n//exp(i*pi2)=0.; i*i=-1.; should be utilized to define pi2=6.28...\n//above is eulers identity, with pi*2, going \"full rotation\"\n#define tau (pi*2.)\n#define CON tau\n#define TWOPI tau\n#define PI2 tau\n\n//https://www.shadertoy.com/view/llG3Ry\nfloat TAU = acos(-1.)*2.;\nfloat TWOTAU = acos(-1.)*4.;\n\n//note2frequency http://en.wikipedia.org/wiki/MIDI_Tuning_Standard\nfloat midi_freq(int m){return 440.*pow(2.,float(m-69)/12.);}\nfloat wav(float hz, float dB,float time){return 20.*pow(10.,dB/10.)*(pow(sin(pi*hz*time), 2.)-.5);}\n\n\nfloat Sine(float t,float f){return si2p(f*t);}\n\n\nfloat Tri(float t){return u2(abs(fract(t)-.5)*2.);}\nfloat Saw(float t){return -u2(fract(t));}//is time reversed\n//float Tri( float t ){\treturn abs(fract( t ) * 4.0-2.0)-1.0;}\n//float Saw( float t ){\treturn fract( t ) * 2.0-1.0;}\nfloat ssaw(float t){return 4.0*(abs(fract(t+0.75)-0.5)-0.25);}\n\n\n\nfloat Square(float t ){return step(fract(t),.5)*2.-1.;}\nfloat rect(float t){if (fract(t/pi/2.)<.5)return 1.;return 0.;}//this sounds just bad!\n\nfloat saw_wave(float t){return fract(t)-.5;}\nfloat Squ(float t){return u2(step(fract(t),.5));}\nfloat square_wave(float t){return (fract(t)>.5) ? 0.125 : -0.1;}\n\nfloat sinsaw_wave(float t){float x=fract(t);return .5-x*x;}\n\nfloat sin_wave(float t){return sin(t*pi*2.);}\nfloat sine(float t){return sin(t*pi*2.);}\nvec2  sine(vec2 t){return vec2(sine(t.x),sine(t.y));}\nfloat Sin(float t){return sin(t*pi*2.);}\nfloat Cos(float t){return cos(t*radians(360.));}\n\n\n\n//elementary\n// Sine wave\n//#define sine(freq, time) (sin(6.28318531*time*freq))\n// Saw wave\n//#define saw(freq, time) ((time*freq - floor(time*freq)) * 2.0 - 1.0)\n// Square wave\n//#define square(freq, time) (sign(sin(6.28318531*time*freq)))\n// Triangle wave\n//#define tri(freq, time) (1.0 - abs(mod(freq*time, 1.0)-2.0))\n//https://www.shadertoy.com/view/Mt2GDz\n//elementary\nfloat ntof(float n){if(n<12.0)return 0.0;return 440.0 * pow(2.0, (n - 67.0) / 12.0);}\nfloat ssaw2(float t){return 4.0*abs(fract(t)-0.5)-1.0;}\nfloat rnd(float t){return fract(sin(t*341.545234)*1531.2341);}\nfloat srnd(float t){float t2=fract(t);return mix(rnd(floor(t)),rnd(floor(t+1.0)),t2*t2*(3.0-2.0*t2));}\n//https://www.shadertoy.com/view/MlXGDn\n//elementary\nfloat osc_noise(float p){p *= 20000.;float F = floor(p), f = fract(p);\n return mix(hash(F), hash(F+1.), f);}\nfloat osc_sine(float p){return sin(p*tau);}\nfloat osc_saw(float p){return p*2.-1.;}\nfloat osc_square(float p,float x){return -1.+2.*step(x,p);}\nfloat osc_sinefm(float pc, float pm, float b){return sin(pc*tau+b*sin(pm*tau));}\nfloat osc_tri(float p, float x//https://www.shadertoy.com/view/MlfGRM\n){float a=smoothstep(0.,x,p),b=smoothstep(1.,x,p)\n ;return (a*b)*2.-1.;}\n//elementary Basic waveforms with note and octave input\nfloat sn(float t, float note, float octave){\n\treturn sin(t*note*exp2(octave)*pi);}\nfloat saw(float t, float note, float octave){\n\treturn fract(t*note*exp2(octave-1.))-0.5;}\nfloat tri(float t, float note, float octave){\n\treturn (abs(fract(t*note*exp2(octave-1.))-0.5)*2.-0.5)*2.;}\nfloat sqr(float t, float note, float octave){\n\treturn step(fract(t*note*exp2(octave-1.)), 0.5)-0.5;}\n//elementary bitwise square wave //https://www.shadertoy.com/view/4dlyWl\nconst int seq1[] = int[](66,89,125,54,89,66,54,37);\nconst int seq2[] = int[](81,106,125,54,106,81,54,37);\nint g(int i,int x,int t,int o){return((3&x&(i*(((3&i>>16)!=0?seq1[t%8]:seq2[t%8])+51)>>o))<<4);}\n//elementary\n// regular sine\nfloat wave0(float x){return sin(tau*x);}\n// half sine + pause\nfloat wave1(float x){return max(sin(x*tau),0.0);}\n// half sine, double frequency\nfloat wave2(float x){return abs(sin(x*tau));}\n// quarter sine + pause, double frequency\nfloat wave3(float x) {return abs(sin(x*tau))*step(fract(x*2.0),0.5);}\n// sine + pause, double frequency\nfloat wave4(float x){return sin(x*tau*2.0)*step(fract(x),0.5);}\n// half sine + pause, double frequency\nfloat wave5(float x) {return abs(sin(x*tau*2.0))*step(fract(x),0.5);}\n// square wave\nfloat wave6(float x) {return step(fract(x),0.5)*2.0-1.0;}\n// saw wave\nfloat wave7(float x) {return 1.-2.*fract(x);}\n// normalizes arguments so the sum is 1\nvec4 normsum(vec4 p) {return p / (p.x+p.y+p.z+p.w);}\n\n//elementary\nfloat si(float i){return sin(fract(i)* pi*2.); }\n//clamped siene sounds more like a metallic flute if(with overtones)\nfloat csi(float i){return clamp(si(i),-.707,.707); }             \nfloat saw(float i){return fract(i)*2.-1.;}\nfloat sq(float i){return mix(0.,1.,step(fract(i),.5));}\n//(https://www.shadertoy.com/view/4sSSWz)\n//elementary\n#define trunc(a) float(int(a))\nfloat notetrunc(float t){return trunc(sin(0.25*t)*4.+cos(0.375*t)*4.0);}\n//https://www.shadertoy.com/view/4sXSWf\n//elementary\nfloat n2f      (float n){return 55. *pow(2.,(n- 3.)/12.);}\nfloat noteFreq (int n  ){return n2f(float(n+39));}\nfloat noteMIDI (float n){return 440.*pow(2.,(n-69.)/12.);}\nfloat calcHertz(float n){return 440.*pow(2.,(n    )/12.);}\n\n\n\n//ldlSD2 is band limited waves are less hurting, Written by Alan Wolfe\n//http://demofox.org/\n//http://blog.demofox.org/\n//http://blog.demofox.org/2012/06/18/diy-synth-3-sampling-mixing-and-band-limited-wave-forms/\n// the frequency of the tone\n#define TONE_FREQUENCY \t440.+(cos(t*0.61))*u5(-cos(t*3.61))*2.\n//the waveform refreshes every fpsWave-frames, because 60 fps flickers too much oif there is any aperiodic phase shift.\n#define fpsWave 7.\n// how long each tone plays, in seconds\n#define TONE_LENGTH 2.\n// how long to fade in and out each wave form\n#define epsEnv  (TONE_LENGTH*.3)\n// how many harmonics (sine waves) for each bandlimited wave form\n#define NUM_HARMONICS_SQU \t11.\n#define NUM_HARMONICS_SAW \t9.\n#define NUM_HARMONICS_TRI\t3.\n//https://www.shadertoy.com/view/ldlSD2\n//band limited waves are less hurting\n#define iterSawBL(t,i) sin(pi*2.*t*(i+1.))/(i+1.)\n#define iterSquBL2(t,i) sin(pi*2.*t*i)/i\n#define iterSquBL(t,i) iterSquBL2(t,(i*2.+1.))\n#define iterTriBl2(t,h,i) (sin(pi*2.*(t-.25)*h)*(mod(i,2.)*2.-1.)/(h*h))\n#define iterTriBl(t,i)  iterTriBl2(t,(i*2.+1.),i)   \n#define endTriBl 8./pi/pi\n#define endSawBl 2./pi\n#define endSquBl 4./pi*0.9\n// the 0.9 shouldn't be needed, but for some reason the amplitude seems wrong without it...                 \n#define blEnd(a,b,c) {float v=0.;for (float i= 0.; i < a; ++i){v+=b(t,i);}return v*c;}\nfloat SawBL(float t)blEnd(NUM_HARMONICS_SAW,iterSawBL,endSawBl)\nfloat SquBL(float t)blEnd(NUM_HARMONICS_SQU,iterSquBL,endSquBl)\nfloat TriBL(float t)blEnd(NUM_HARMONICS_TRI,iterTriBl,endTriBl)\n\n//__end___ common\n//__start_ hulls\n\n//*exp(-3.0*time);//fadeout over time    \n\n//https://www.shadertoy.com/view/MdjXWc\nfloat remap(float l,float h,float x){return sat((x-l)/(h-l));}\n\n                          \n//Pan11 mono-waveform[a] by[p]; 0==left; .5=center; 1.=right channel\n#define pan01(a,p) mix(vec2(a,0),vec2(0,a),p)\n//Pan11 mono-waveform[a] by[p]; -1==left; 0=center; 1.=right channel\n#define pan11(a,p) pan01(a,u5(p))\n\nfloat drummyHull(float t){return max(0.,(1.-mod(t * 4.0, 1.0)*2.));}\nfloat drumExclusion(float t){return 1.-float(mod(t,16.)>=3.&&mod(t,2.)>=1.);}\n\nfloat ss(float u,vec2 m){return smoothstep(m.x,m.y,u);}\n//smoothstep utility; m.y=0 is a step-function\n//root is at m.x; y=1 intersection at m.x-m.y, negative m.y ascend over u++\nfloat ssimple(float u,vec2 m){return ss(u,vec2(m.x,m.x-m.y));}\n//ssimpleLin is the linear to the parametricallyIdentical ssimple()\nfloat ssimpleLin(float u,vec2 m){return sat((m.x-u)/m.y);}\n//clamped linear interpolation since [s] over distance.y=[a] during time [l] over [t]\n//float decLin(float t, float s, float l, float a//time,start,length,amount\n//){return clamp((t-s)/l,0.,a);}//linear decay //https://www.shadertoy.com/view/Mt2GDz\n//todo i still need that declamp context where i get the identity that\n//has clamo(a,0,b) use clamo(a,0,1) useas its subroutine!\n//sign of [a] and [r] should be the same. then its ss up from 0 il la, and then backk down from a toll e\n//else, its an convoluted single smoothstep for 2 smoothsteps.\nfloat ssAr(float t, float a, float e){return smoothstep(0.,a,t)*smoothstep(e,0.,t-a);}\n//env_ar generalization, but with 3 points,and good chanves for a flat center.\nfloat ssAsr(float t, float s, float a, float e\n){return smoothstep(0.,a,t)*smoothstep(e,0.,t-a-s);}\n//https://www.shadertoy.com/view/MlfGRM\n\n\n//hull\n//smooth abs() ==??\nfloat sAbs1(float x,float k){return sqrt(x*x+k);}\n//nice smin?\nfloat sMin(float a, float b, float k){return(a+b-sAbs1(a-b,k))*.5;}\nfloat sMax(float a, float b, float k){return -sMin(-a,-b,k); }\n//identity of SMOOTH clamp\nfloat sClamp(float x, float a, float b, float k){return sMin(b,sMax(a,x,k),k);}\n//smooth clamped sine instrument\nfloat sndsmoothclampedsin(float time\n){return sClamp(pow(sin(6.2831*440.0*fract(time*.94)),64.),-.25,.55,.04);}\n\n\nvec4 debugEnv(vec2 u,vec2 r,vec4 m){\n ;u=u/r     ;u-=.5;u*=4.;u.x *=r.x /r.y\n ;m=m/r.xyxy;m-=.5;m*=4.;m.xz*=r.xx/r.yy\n ;vec4 c=vec4(0)\n ;c.x=ssimpleLin(u.x,m.xy)\n ;c.y=ssimple   (u.x,m.xy)\n ;c.z=ssAsr     (u.x,m.x,m.y,m.z)\n ;c.xyz-=u.y\n ;c=abs(c)\n ;c=smoothstep(.01,-.01,c-.1)\n ;c.w=1.\n ;return c;}\n\n//__end___ hulls\n//_start__ modulation (fourier hyperslices)\n\n//arp = Arpeggiator, = chord with offset over time, can overlap or not.\n// https://en.wikipedia.org/wiki/Arpeggio   is common for string instruments.\n//https://www.shadertoy.com/view/4ssfzj\n//emulates a whole xm-chip, and xm-sequencer.\n//#define PHI_INC(cnt, val)cnt< 0.0?0.0:exp2(float(val)/12.0)*clamp(cnt, 0.0, 1.0), cnt -= 1.0\n#define PHI_REP(cnt, val)cnt< 0.0?0.0:exp2(float(val)/12.0)*max(cnt, 0.0)\nfloat arpeggio3(float p, int d0, int d1, int d2\n){vec3 j=vec3(d0,d1,d2)\n ;vec2 r=vec2(0)\n ;float o=mod(p,3.),f=floor(p/3.)\n ;for(int i=0;i<4;i++){float e=exp2(j[i]/12.0),v=0.;if(o>=0.){v=e*max(o,0.);o-=1.;}r+=vec2(v,e)\n ;}return r.x+r.y*f;}\n//https://www.shadertoy.com/view/XlBGz3\n\n\n//arp\n//https://www.shadertoy.com/view/XscXzn\n//ap(...int...) is being iterated over by ap(...int[3]...),an arp commonly uses at least 3 iterations.\nfloat ap(float t,int n,float speed,float delay,int noteId//time,overtoneI,speed,delay,IterationNumber\n){n+=globalTranspose\n ;t+=float(noteId)*delay\n ;float f=base_a4*pow(2.,float(n)/12.)*baseFreq*speed\n ;f+=1.+sin(t*20.*speed)/pi*.0005*f*step(0.,t-apVibratoDelay)\n ;vec2 e=max(1.-(t),0.)*f+vec2(0,cos(t*5.0)/pi)//create sqr duty wave on .y\n ;return clamp(e.x-e.y,-1.,1.)*pow(max(0.,1.-(t*baseFreq)),1.5);}\nfloat ap(float t,int n[3],float s,float d//time,overtones,speed,delay\n){float c=0.;for(int i=0;i<3;i++){c+=ap(t,n[i],s,d,i);}return c;}\n#define ARP(d,n)   c+=ap(TT(d),n,1.0/speed,delay) \nfloat arp(float t\n){float c=0.\n ;float speed=4.\n ;float delay=-0.4\n ;float time=mod(t*speed,4.0*speed)\n ;float  g=time/speed\n ;int i[3]\n ;      if(g<1.){i[0]=0;i[1]=3;i[2]=7;ARP(0.0,i)\n ;}else if(g<2.){int a=-2;i[0]=0+a;i[1]=4+a;i[2]=7+a;ARP(0.0,i)\n ;}else if(g<3.){int a=-4;i[0]=0+a;i[1]=4+a;i[2]=7+a;ARP(0.0,i)\n ;}else if(g<4.){int a=-4;i[0]=0+a;i[1]=4+a;i[2]=7+a;ARP(0.0,i)\n ;}return c*.4;}//https://www.shadertoy.com/view/XscXzn\n                          \n\n//deform doppler\nfloat snd(float t){float s=ssaw(50.*t);return sign(s)*pow(abs(s),1.1+sin(t*20.));}\nvec2 rep(vec2 p,vec2 a){return abs(mod(p+a,a*2.)-a);}//doppler subroutine //https://www.shadertoy.com/view/Xtl3DB\nfloat DEL(vec3 z//doppler subroutine //https://www.shadertoy.com/view/Xtl3DB\n){z.xz=rep(z.xz,vec2(7,6))\n ;return length(abs(z)-vec3(2.74,.83,2.74)+vec3(-.82,0,-1));}\nvec3 herert(vec3 fw,vec3 up){fw=normalize(fw);return normalize(cross(fw,normalize(up)));}\nfloat phys(float time, float dist//doppler subroutine //https://www.shadertoy.com/view/Xtl3DB\n){float tim=time-dist/SPEEDOFSOUND\n ;return snd(tim)*exp(-dist*DAMPING);}\nvec2 demoDopper(float t\n){float tim=t*.25\n ;vec3 o=vec3(sin(tim)*(2.+tim),4.5,cos(tim))-4.\n ;vec3 rt=.1*herert(vec3(-4,-.6,-4)-o,vec3(0,1,0))\n ;return vec2(phys(t,DEL(o)),phys(t,DEL(o+rt)));}\n\n\n//__end___ modulation\n//__start_ standalone sequences:\n\n\n\n//boolean filter over [t] for drum sequence\n\nfloat dumbSequence(float t){return floor(fract(t*(sqrt(5.)*.5+.5))*8.);}\nvec4 dumbSequence(vec4 t){return floor(fract(t*(sqrt(5.)*.5+.5))*8.);}\n\nfloat sequenceThemDrWho(float nr//dr who theramin sequence //https://www.shadertoy.com/view/4dSXRm\n){//a tree structure, for benchmarking and testtng purposes, it seems to outperform linear branching.\n ;if (46.0<nr||nr<15.)return -120.//left and right end\n ;if(nr>42.5)return mix(43.,44.,step(nr,43.));\n ;if (nr<33.5){if(nr<23.)return bilinT(nr,vec3(0,1,6)+16.   ,vec4(31,56,55,-120))\n              ;else      return bilinT(nr,vec3(0,1,6)+24.   ,vec4(58,42,43,-120))\n ;}else{       if(nr<39.)return bilinT(nr,vec3(0,1,2.5)+34.5,vec4(43,39,31,34))\n              ;else      return bilinT(nr,vec3(0,1,1.5)+39.5,vec4(42,31,-120,31))\n ;}}//damn i messed up the timing a bit, and fail to fix it.\n\n//__end___ standalone sequences\n//__start_ instruments-shiftable\n\n\n\n//instrument flute/violing/horn (strong overtomes, no keyboard, but dynamic holes or pipe lengths for modulation\nfloat introHorn(int note, float t//https://www.shadertoy.com/view/MljGRd\n){t=t-1.5\n ;if(t<-1.)t=-pow(-t,1.-(t+1.)*0.4)\n     ;else{t+=u5(-sin(t*2.)*.2)+.2;note-=2;}//optionally, broken record coth trig-time.\n ;float baseFreq=pi*2.*noteFreq(note)*t*.5\n ;float[6] ots=float[6](1.,.75,.75,.5,.75,.5)//overtones\n ;float r=.0;for(int i=1;i<=6;i++){r+=sin(baseFreq*float(i))*ots[i];};return r;}\n\n//DrWho sequence+instrument\nfloat DrWho2Tap(float time, float tt, float FM){\n    tt -= mod(tt,RES);\n    float note1 = sequenceThemDrWho(tt);\n    float note2 = sequenceThemDrWho(tt+0.5);\n    if (note1 <0.0)     return 0.0;    \n    float stepper = smoothstep(0.1,0.5,mod(tt,0.5));\n    float note = mix(note1,note2,stepper);    \n    float angle = PI2*n2f(note)*time;\n    return sin(angle+FM*sin(angle*2.033));}\nvec2 DrWhoTheramin(float time, float tt\n){tt=mod(tt,48.)\n ;tt += 1.33\n ;float FM = 0.0\n ;if (tt>=32.)FM = PI2/2.\n ;float sampl\n ;float ta = mod(tt-RES/2.0,RES)-RES/2.\n ;float halfSin = RES/4.0;//4.0/frequency\n ;if (abs(ta)<halfSin\n ){float sample1=DrWho2Tap(time,tt-RES/2.,FM)//oh please be overlapping magic!\n  ;float sample2=DrWho2Tap(time,tt+RES/2.,FM)\n  ;sampl = mix(sample1,sample2,smoothstep(-halfSin,halfSin,ta))\n ;}else sampl=DrWho2Tap(time,tt,FM)\n  ;return vec2(sampl);}////https://www.shadertoy.com/view/4dSXRm\n//instrument\nfloat stringElectric(const in vec2 vFreqTime//https://www.shadertoy.com/view/MdsGzr\n){float f=vFreqTime.x\n ;float t=vFreqTime.y\n ;if(t<0.)return 0.\n ;float x=0.\n ;float a=1.\n ;float h=1.\n ;for(int i=0;i<4;i++ //3 overtones\n ){x+=Sin(f*t*h)*exp2(t*-a)\n  ;x+=Sin(f*(t+0.005)*h*.5)*exp2(t*-a*2.)\n  ;h=h+1.01\n  ;a=a*2.\n  ;}return x;}//return vec2(Instrument(vec2(440.,time)));\n\n\n//instrument PianoLight\nvec2 PianoLight(float de,float time//Instr3() //https://www.shadertoy.com/view/llsSDf\n){float f0=440.0*de*0.001953125\n ;float f=sin(f0*pi*time)*.02;\n ;vec4 abce=vec4(1,2,4,16)*2.\n ;vec4 g=vec4(0,80,40,1)*.001\n ;float a=sin(abce.x*f0*pi*time)\n ;abce=sin(abce*f0*pi*time)*g\n ;return vec2((su(abce)+f)*0.5*exp(-0.6*time)*exp(-1.0*time));}\n//instrument PianoBase\nvec2 PianoBase(float de,float t//Instr1() //https://www.shadertoy.com/view/llsSDf\n){float f0=440.*de*.001953125\n ;vec4 g=vec4(80,40,0,1)*.001\n ;vec4 bcef=vec4(1,2,4,16)*2.\n ;bcef=sin(bcef*f0*pi*t)*g\n ;float a=sin(f0*pi*t)*.02 \n ;return vec2((a+su(bcef))*.5*exp(-t));}\n//instrument Bass\nvec2 Instr2(float de,float t //https://www.shadertoy.com/view/llsSDf\n){float x=pi*t*2.\n ;float f0=de*110.0*0.015625\n ;float a=sin(f0*2.*pi*t)\n ;float c=.2*t+.25*a\n ;float b=sin(a*c*2.*pi)\n ;return vec2(b*.9*exp(-.3*t)\n                  *exp(-.3*t)\n                  *exp(-.1*t));}\n\n\n//instrument organ with soft overtones\nfloat organ(float t,int k){if(k<1||k>=0xC0)return 0.;//null key\n float f=27.5*pow(2.,float(k)/12.),r=0.;t*=f;\n for(int i = 1;i<8;i++){\n  r+=csi(float(i)*t)*pow(.6,float(i));}\n //*pow(.6,float(i)) diminishes amplitude exponentially for each overtone.\n r*=(1.+si(t*10.)/8.);\n return r*5.*inversesqrt(f);}//https://www.shadertoy.com/view/lstXWS\n//instrument harp+bell with echo ,final fantasy 7\n//instrument\nfloat HarpBell(float f, float t//[f]frequency [t]time\n){f*=t\n ;float y=.7*sin(   tau*f)*exp(-.0075*f)\n ;y+=.2*sin(2.*tau*f)*exp(-.0055*f);return y*sat(t/.004);}\nfloat HarpBell2(float f,float t){    \n float p=.2+0.8*max(0.,6.-.01*f);f*=t;\n p*=sin(tau*f)*exp(-f*0.2);\n float y=.70*sin(     tau*f+p)*exp(-.005*f);\n      y+=.20*sin(2.01*tau*f+p)*exp(-.0055*f);\n      y+=.16*sin(4.01*tau*f+p)*exp(-.009*f);\n return y*sat(t/.004);}\n//https://www.shadertoy.com/view/XllXWN\n//instrument snippet\n/*\n{ //soothing harry potter sine\n    //...  //https://www.shadertoy.com/view/lssXWS\n    // calc frequency and time for note\t  \n    float noteFreq = 440.0*pow( 2.0, (n-69.0)/12.0 );\n    float noteTime = 0.18*(t-x);\n    // compute instrument\t\n    float y  = 0.5*sin(6.2831*1.00*noteFreq*noteTime)*exp(-0.0015*1.0*noteFreq*noteTime);\n\t      y += 0.3*sin(6.2831*2.01*noteFreq*noteTime)*exp(-0.0015*2.0*noteFreq*noteTime);\n\t      y += 0.2*sin(6.2831*4.01*noteFreq*noteTime)*exp(-0.0015*4.0*noteFreq*noteTime);\n          y += 0.1*y*y*y;\t  \n          y *= 0.9 + 0.1*cos(40.0*noteTime);\n\t      y *= smoothstep(0.0,0.01,noteTime); \n    // accumulate echo\t  \n    tot += y * vec2(0.5+0.2*h,0.5-0.2*h) * (1.0-sqrt(h)*0.85);\n      ///... tot is an accumulator for echo outside of a loop\n}*/\n\nfloat EnvEps(float m){;float e =1.\n ;     if(m<epsEnv)              e=m/epsEnv\n ;else if(m>(TONE_LENGTH-epsEnv))e=1.-((m-(TONE_LENGTH-epsEnv))/epsEnv)  \n ;return e;}\n////////\nfloat demoBandMix(float t//_ldlSD2\n){float m=mod(t,TONE_LENGTH)\n ;float e =1.\n ;     if(m<epsEnv)              e=m/epsEnv\n ;else if(m>(TONE_LENGTH-epsEnv))e=1.-((m-(TONE_LENGTH-epsEnv))/epsEnv)  \n //above envelope [e] figured out how much to scale the volume to account for envelope\n //on the front and back of each wave form\n ;m=mod(t / TONE_LENGTH, 6.0) // play the apropriate wave form based on time \n ;//m=3.2;\n ;t*=TONE_FREQUENCY\n ;if     (m>5.)return e*SquBL(t) \n ;else if(m>4.)return e*Squ  (t) \n ;else if(m>3.)return e*SawBL   (t) \n ;else if(m>2.)return e*Saw(t) \n ;else if(m>1.)return e*TriBL(t) \n ;else         return e*Tri(t)\n ;}\nvec2 demoBandLimit(float t){return vec2(demoBandMix(t));}\n\n//instrument\nfloat instrumentBanjo( float freq, float time//https://www.shadertoy.com/view/ldXXDj <---\n){freq = 440.0*pow(freq/440.0,1.003) // spread\n ;float ph=1.\n ;ph*=sin(6.2831*freq*time)\n ;ph*=.2+.8*max(0.0,6.0-0.01*freq)\n ;ph*=exp(-time*freq*0.2)\n ;vec3[8]ob;\n  ;ob[0]=vec3(.70,1,.007)\n  ;ob[1]=vec3(.20,2.01,.011)\n  ;ob[2]=vec3(.20,3.01,.015)\n  ;ob[3]=vec3(.16,4.01,.018)\n  ;ob[4]=vec3(.13,5.01,.021)\n  ;ob[5]=vec3(.10,6.01,.027)\n  ;ob[7]=vec3(.09,8.01,.030)\n ;float y=0.\n     ;float ft=freq*time\n ;for(int i=0;i<=7;i++){\n  ;vec3 o=ob[i]\n  //;y+=o.x*sin(o.y*pi*2.*ft+ph)*exp(-.5*o.z*ft)\n ;}\n ;y+=.70*sin(1.00*6.2831*freq*time+ph)*exp(-.5*.007*freq*time)\n ;y+=.20*sin(2.01*6.2831*freq*time+ph)*exp(-.5*.011*freq*time)\n ;y+=.20*sin(3.01*6.2831*freq*time+ph)*exp(-.5*.015*freq*time)\n ;y+=.16*sin(4.01*6.2831*freq*time+ph)*exp(-.5*.018*freq*time)\n ;y+=.13*sin(5.01*6.2831*freq*time+ph)*exp(-.5*.021*freq*time)\n ;y+=.10*sin(6.01*6.2831*freq*time+ph)*exp(-.5*.027*freq*time)\n ;y+=.09*sin(8.01*6.2831*freq*time+ph)*exp(-.5*.030*freq*time)\n ;y+=.07*sin(9.01*6.2831*freq*time+ph)*exp(-.5*.033*freq*time)\n ;y+=.45*y*y*y\n ;y*=1.+1.5*exp(-8.0*time)\n ;y*=sat(time/0.004)\n ;y*=2.5-1.5*sat(log2(freq)/10.)\n ;return y;}//return vec2(instrumentBanjo(440.,time));\n\n\n//dr who bass (sans sequence)\nvec2 DrWhoBass(float time, float tt, float note//bass() //https://www.shadertoy.com/view/4dSXRm\n){if (tt<0.0)return vec2(0.)\n ;float freqTime = 6.2831*time*n2f(note)\n ;return vec2(( sin(freqTime   +sin(freqTime)*7.0*exp(-2.0*tt))\n               +sin(freqTime*2.+cos(freqTime*2.0)*1.0*sin(time*3.14)\n               +sin(freqTime*8.0)*0.25*sin(1.0+time*3.14))*exp(-2.0*tt)\n               +cos(freqTime*4.+cos(freqTime*2.0)*3.0*sin(time*3.14+0.3))*exp(-2.0*tt)\n                )*exp(-1.0*tt) );}\n\n//sine wave with vibrato, nice lead (background).\nfloat sineVib(float time,int note,float speed,float arpVolume\n){note+=globalTranspose\n ;float baseFreq=1.\n ;float globalTime=0.\n ;float freq=base_a4*pow(2.0,float(note)/12.0)*baseFreq\n ;freq*=speed\n ;freq+=freq*step(mod(time,0.1),0.05)*arpVolume\n ;float vibratoDelay=.2//vibrato\n ;freq+=1.0+sin(time*20.0*speed)/pi*0.001*freq*step(0.0,time-vibratoDelay)\n ;float t=1.0-(time*1.0)\n ;t=max(t,0.)\n ;float duty=cos(time*2.0+globalTime*0.5)/pi//sqr duty wave\n ;duty=duty*.2+.8\n ;float f1=fract(t*freq)\n ;float f2=fract(duty+t*freq)\n ;float f=f1-f2\n ;f=clamp(f,-1.,1.)\n ;float t2=time*baseFreq\n ;f*=pow(max(0.,1.-(t2*1.)),1.5)\n ;f+=rand(time)*.2*pow(1.-t2,16.)//hihat\n ;return f;}\n\n\n//instrument testuing range, with  cycling 4x overlap and iDate randomizing sheet-seed over time\n//while somehow the note stays form a past seed. YAY.\n\n vec4 midi_freq(vec4 m){return 440.*pow(vec4(2),(m-69.)/12.);}\n\nfloat datesec(//cire issue is that iDate.w runs into very high numbers very fast\n){float interval =6.61/99.\n ;return iDate.z+floor(fract(iDate.w/interval)*interval)\n ;return 0.;}\n\nfloat TestInstrument4Times(vec4 freq, vec4 time){\n ;float c=0.\n ;for(int i=0;i<5;i++\n ){\n  ;c+=instrumentBanjo(freq[i],time[i])\n  ;};return c;}\nvec2 debugInstrument(float t//4 overlappign neighborhoods to debug an instrument quickly\n){t*=4.\n ;vec4 f=vec4(0,1,2,3)\n  ;vec4 t4=t+vec4(0,1,2,3)\n ;vec4 r=dumbSequence(((.61+(f+5.))+datesec())*floor((t-f*7.)/4.)*4.)\n ;//yes,datesec() changes every second, and this sequence is still continuous over time\n ;r=mod(r*2.,62.)\n ;if(r.x<13.||r.x>55.)r.x=-999.//rather play inaudibl/silent frequencies than a very wide range.\n ;if(r.y< 7.||r.y>50.)r.y=-999.//this also fives timeslices semi--exclusive instrument-ranges.\n ;if(r.z< 5.||r.z>45.)r.z=-999.\n ;if(r.w< 3.||r.w>40.)r.w=-999.\n ;r=midi_freq(floor(r*2.)+22.)//optionally not a cocaphony \n ;//r=110.*(1.+f)+r*55.-110.//sans harmony\n ;vec2 c=vec2(TestInstrument4Times(r,fract(t4/4.)*4.))\n ;return c*.25;\n ;}\n\n\nvec2 bass(float time, float tt, float note\n ){\n    if (tt<0.0)\n      return vec2(0.0);\n\n    float freqTime = 6.2831*time*n2f(note);\n    \n    return vec2(( sin(     freqTime\n                      +sin(freqTime)*7.0*exp(-2.0*tt)\n                     )+\n                  sin(     freqTime*2.0\n                      +cos(freqTime*2.0)*1.0*sin(time*3.14)\n                      +sin(freqTime*8.0)*0.25*sin(1.0+time*3.14)\n                    )*exp(-2.0*tt)+\n                  cos(     freqTime*4.0\n                      +cos(freqTime*2.0)*3.0*sin(time*3.14+0.3)\n                    )*exp(-2.0*tt)\n                )\n                \n                *exp(-1.0*tt) );\n}\n\nvec2 duhduh(float time, float tt)\n{\n   float bn = 0.0;\n   tt = mod(tt,48.0);\n   if (tt>=16.0)\n      if (tt>=40.0)\n         bn -= 5.0;\n      else\n         if (mod(tt,8.0)>=4.0)\n            bn -= 5.0;\n       \n   tt = mod(tt,8.0);\n   if (tt <4.0)\n     tt = mod(tt,2.0);\n   else\n     tt = mod(tt,4.0);\n   return bass(time,tt-3.0,bn+3.)+\n          bass(time,tt-2.0,bn+3.)+\n          bass(time,tt-1.0,bn+0.)+\n          bass(time,tt-0.0,bn+0.);\n}\n\nvec2 duhduh2(float time, float tt)\n{\n   float bn = 0.0;\n   tt = mod(tt,48.0);\n   if (tt>=16.0)\n      if (tt>=40.0)\n         bn -= 5.0;\n      else\n         if (mod(tt,8.0)>=4.0)\n            bn -= 5.0;\n       \n   int ti = int(mod(tt,8.0)/2.0);\n   tt = mod(tt,2.0);\n   if (ti == 0)\n     return bass(time,tt-0.83,bn+12.0)+\n            bass(time,tt-0.50,bn+12.0)+\n            bass(time,tt-0.17,bn+12.0);\n    \n   if (ti == 3)\n     return bass(time,tt-0.66,bn+15.)+\n            bass(time,tt-0.0,bn+15.);\n    \n   return bass(time,tt-0.66,bn+12.)+\n          bass(time,tt-0.0,bn+12.);\n}\n\n\n\nfloat getSample(float time, float tt, float FM//tt a mod(time(,b) sequenceTap\n){tt-=mod(tt,RES)\n ;float note1=sequenceThemDrWho(tt)\n ;if (note1<0.)return 0.\n ;float n=mix(note1,sequenceThemDrWho(tt+0.5), smoothstep(0.1,0.5,mod(tt,0.5)))\n ;n=PI2*n2f(n)*time\n ;return sin(n+FM*sin(n*2.033));}\n\nvec2 theramin(float time, float tt//tt is a mid(time) seuqence-context\n){tt = mod(tt,48.0)\n ;tt += 1.33\n ;float FM=0.\n ;if(tt>=32.)FM = PI2/2.\n ;float ta = mod(tt-RES/2.0,RES)-RES/2.0\n ;float h=RES/4.0//4.0/frequency;//\"halfsin\"\n ;if (abs(ta)<h)return vec2(mix(getSample(time,tt-RES/2.0,FM)\n                               ,getSample(time,tt+RES/2.0,FM)\n                               ,smoothstep(-h,h,ta)))\n ;return vec2(getSample(time,tt,FM));}\n\nfloat sequenceDrWho1(float t,float tt//only at half volume on the right channel\n){return clamp(duhduh(t,tt    ).x,-.8,.8)*1.3\n        +clamp(duhduh(t,tt-.33).x,-.5,.5)*1.4\n        +clamp(duhduh(t,tt-.66).x,-.3,.3)*2.;}\nfloat sequenceDrWho2(float t,float tt//only at half volume on the left channel\n){return clamp(duhduh2(t,tt    ).x,-.8,.8)*.3\n        +clamp(duhduh2(t,tt-.33).x,-.8,.8)*.2\n        +clamp(duhduh2(t,tt-.66).x,-.8,.8)*.1;}\nvec2 sequenceDrWho3(float t,float tt\n){return theramin(t,tt-0.75)*vec2(0.2,0.4)\n        +theramin(t,tt)*vec2(0.6,0.4)\n        +theramin(t,tt-0.506)*vec2(.4,.2)\n        +theramin(t,tt-1.00)*vec2(.1,.2);}\nvec2 DemoDrWho(float t\n){float tt=t*2.4\n ;vec2 r=vec2(0)\n ;//r+=sequenceDrWho1(t,tt)*vec2(1,.5)\n ;//r+=sequenceDrWho2(t,tt)*vec2(.5,1.)\n ;r+=sequenceDrWho3(t,tt) \n ;return r*.33;}\n\n\n\n\n//electric base guitar, electric shaver\nfloat GuitarElectricBase(float time,int note//https://www.shadertoy.com/view/XscXzn  ???\n){float t=max(1.-time,0.)\n ;float freq=110.*pow(2.,float(note)/12.0)*baseFreq*t//or is it time instead ot t?\n ;vec2 a=freq+vec2(0,u5(cos(time*4.)/pi))//duty sqare-wave\n ;a.x=clamp(a.x-a.y,-1.,1.)*pow(max(0.,1.-(time*2.)),3.)\n ;return a.x;}//https://www.shadertoy.com/view/XscXzn\n\n//bad chord dependency\n//instruments should be outside of chords?\nfloat strings(float t//this sounds just bad, oh it was just 5x too loud, DUH!\n){float c=0.\n ;vec4 h=mix(vec4(24,28,31,35),vec4(23,26,30,33),step(mod(t,8.),4.))//chord varies\n ;for (int i=0;i<5;i++){c+=rect(t*calcHertz(h[i]));}//4 key chord\n ;return c*drummyHull(t);\n ;}                         \n// Instruments from MusicBox2 shader by ztri\nvec2 tb303(vec3 k//https://www.shadertoy.com/view/MslSD2\n){float s = abs(sin(tune*0.7)+1.0)*0.3\n ;float a = pow(1.0-k.y,0.2)\n ;float f = pow(1.0-k.y,2.0)\n ;float osc = sin(k.x*4.40*tune*2.0)\n ;osc = pow(abs(osc),pow(2000.0,s+(f*0.8)))\n ;osc = clamp(osc*1.1,-1.0,1.0)*a\n ;return vec2(osc,osc)*0.3;}\nvec2 pad(vec3 k//https://www.shadertoy.com/view/MslSD2\n){float osc = 0.\n ;osc += smoothstep(0.0,0.4,sin(k.x*4.4*tune*8.0))\n ;osc += smoothstep(0.0,0.4,sin(k.x*4.4*tune*16.1))\n ;osc += smoothstep(0.0,0.4,sin(k.x*4.4*tune*15.9))\n ;osc = clamp(pow(osc,0.1),-1.0,1.0)\n ;osc = osc*smoothstep(1.0,0.0,k.y)\n ;return vec2(pow(osc,abs(sin(tune))),pow(osc,abs(cos(tune))))*.4;}\nvec2 piano(vec3 k//https://www.shadertoy.com/view/MslSD2\n){float osc = 0.0\n ;osc += sin(k.x*4.4*tune*4.0);\n    osc = clamp(pow(abs(osc),20.0),-1.0,1.0);\n    osc = osc*smoothstep(1.8,0.0,k.y);  \n    return vec2(osc*sin(k.z),osc*cos(k.z*2.0))*0.5; }\n//instrument demo\nvec2 debugInstruments(float t//https://www.shadertoy.com/view/XttfWn\n){vec2 c=vec2(0)\n ;c+=strings(t)*.2\n ;return c;}\n\n//__end__ instruments shiftable\n//_start_ sfx\n\n//https://www.shadertoy.com/view/4djSzR\n//lava bubbles = chaos*Hull\nfloat bubbles(float t, float p, float l, float ff//time,period,length\n){float c=floor(t/p)*p//this is NOT mod, but its semi-inverse\n ;t-=c+u5(sin(c*12.))*p*.8//interestring time folding!\n ;return \n //step(-.2,cos(c*199.0*l))//more code for less bubbles, seems like a dumb approach\n sin(ff*(5000.+cos(c*70.)*2000.)*(t+.1)*t)//lots of pingpong lines\n *(smoothstep(.0,.07*l,t)-smoothstep(.1*l,.2*l,t))//and a basic dumb hull\n ;}\nvec2 bubbles2(float t\n){vec3 p=1./(vec3(1,2,3)+.61)\n// ;return vec2(.9*bubbles(t   ,p.x,1.2,1.)\n //            +.1*bubbles(t+1.,p.y,.5,2.)\n  //           +.5*bubbles(t+2.,p.z,.7,1.))*.75;}//hard params here\n ;return vec2(0.9*bubbles(t,2.0,1.2,1.0)\n             +0.1*bubbles(t,0.5,0.5,2.0)\n             +0.2*bubbles(t,0.2,0.2,2.0))*0.75;}\n\n\nfloat fourier(float a){return .25*sin(a)+.25*sin(2.*a+.2)+.5*sin(4.*a+.3);}\nvec2 teslaCoil( float t//https://www.shadertoy.com/view/4lcXDM\n){float m=mod(t,15.)\n ;if (m<3.)return vec2(0)\n ;return vec2(4.*fourier(400.*t)// base wave\n *pow(fbm(20.*noise(40.*t)*t) //amplitude modulation\n ,2.))\n ;}\n\n\n//___end__ sfx\n//__start_ instruments-percussion\n\n//drums:\n//percussion\nfloat drum(float time \n){float freq=100.0*baseFreq\n ;float vol=.4\n ;float depth=4.\n ;float t=1.-(time*4.)\n ;t=max(t,0.)\n ;t=pow(t,depth)\n ;float f=cos(t*freq)/pi\n ;float t2=time*baseFreq\n ;f*=pow(1.0-t2,8.0)\n ;//f=ws(f,2.)\n ;f+=rand(time)*pow(1.0-t2,1464.0)*0.5\n ;return clamp(f*vol,-1.,1.);}//https://www.shadertoy.com/view/XscXzn\n//percussion\n//percussion bad cheap start //https://www.shadertoy.com/view/4l3GD2\nfloat bassDrum(float time//too digital.lacks timbre/echo\n){float f=fract(time)/3.*8.//https://www.shadertoy.com/view/4l3GD2\n ;return sin(time*(440.))*ma0(1.-f*8.)*2.;}\nfloat snereDrum(float t){float f=fract(t+.5);return rand(vec2(t*32.,0))*ma0(1.-f*4.);}\n\n//kick\nvec2 kick(vec3 k//https://www.shadertoy.com/view/MslSD2\n){float a = pow(1.0-k.y,1.0)\n ;float osc = sin(pow(a,5.0)*k.x)\n ;return vec2(smoothstep(-0.9,0.9,osc*pow(a,2.0)));}\n//percussion\nfloat kick(float time //https://www.shadertoy.com/view/MljGRd\n){float sinWave = sin(pow(time*1000.0,0.6));\n   const float fadeInTime = 0.00015;\n    float fadeIn = max(0.0,min(1.0,(time/fadeInTime)));    \n    const float fadeOutTime = 1.0;\n    float fadeOut = max(0.0,min(1.0,((fadeOutTime-time)/fadeOutTime)));\n    return sinWave*fadeIn*fadeOut;}\n\n//Hat\nfloat hiHat(float t){//if (drumExclusion(t)==0.)return 0.;\n ;return drumExclusion(t)*rand(vec2(t*32.,0))*ma0(1.-fract(t)*4.);}//noise\n//percussion\nvec2 hat(vec3 k\n){float n = fract(sin(k.x * tune * 110.082) * 19871.8972)\n ;float a = pow(1.0-k.y,1.0)\n ;float osc = clamp(n,-1.0,1.0)*pow(a,8.0+k.x*0.1)\n ;return vec2(osc*osc,osc)*0.4;}//.x is pianoKey    .y is [TimeSinceStart] .z is period \nfloat hihatClosed(float time //https://www.shadertoy.com/view/MljGRd\n){float sinWaveA = sin(pow(time*8700.0,0.99))\n ;float sinWaveB = sin(pow(time*7200.0,0.99))\n ;float sineFadeIn = max(0.0,min(1.0,(time/0.15)))\n ;float sineFadeOut = max(0.0,min(1.0,(1.0-(time))))\n ;float noiseWave = noise(time)\n ;float noiseFadeOut = max(0.0,min(1.0,(1.0-(time/0.75))))\n ;noiseFadeOut = pow(noiseFadeOut,2.0)\n ;return noiseWave*noiseFadeOut*0.5 + (sinWaveA+sinWaveB)*sineFadeIn*sineFadeOut*0.05\n ;}\n\n//Bell\n//percussion bell are perc, because they have a const dominant resonance.\nvec2 bell(float t,float f){t=fract(t);return vec2(sin(dot(TWOTAU,TAU)*f*t)*exp(-3.0*t) );} \n//percussion bells are perc, because they have a const dominant resonance.\nfloat bx_cos(float a){return clamp(abs(mod(a,8.0)-4.0)-2.0,-1.0,1.0);}\nfloat tx_cos(float a){return abs(mod(a,4.0)-2.0)-1.0;}\n#define Cos tx_cos\nvec2 bellSqua(float t//cosine bell with overtone loop and a tripple canon modulo sequence without harmony.\n){float f=floor(t*2.)//https://www.shadertoy.com/view/lstXR8\n ;float n=dumbSequence(f)+dumbSequence(f*2.61+1.)+dumbSequence(f*3.61+2.)\n ;float o=0.,a=t*660.,r=1.,scale=n//step site for overtone loop.\n ;for(int i=0;i<5;i++//overtones\n ){o+=Cos(a)*r\n  ;a*=scale;r/=scale\n  ;a+=Cos(t*60.)*.01;}\n ;float bt=fract(t*2.);\n ;o*=clamp(bt*100.,0.,0.5)*(1.-bt)\n ;o=clamp(o,-1.0,1.0)\n ;return vec2(o);}    \n//percussion\n//percussion snare\nfloat snare(float time //https://www.shadertoy.com/view/MljGRd\n){float sinWave = sin(pow(time*1000.0,0.7))\n ;float sineFadeIn = max(0.0,min(1.0,(time/0.00015)))\n ;float sineFadeOut = max(0.0,min(1.0,(1.0-(time/0.25))))\n ;float noiseWave = noise(time)\n ;float noiseFadeIn = max(0.0,min(1.0,(time/0.00015)))\n ;float noiseFadeOut = max(0.0,min(1.0,(1.0-(time/0.25))))\n ;return noiseWave*noiseFadeIn*noiseFadeOut*0.75 + sinWave*sineFadeIn*sineFadeOut*0.5;}\n//percussion\n//percussion instrument elemet of //https://www.shadertoy.com/view/XscXzn\nfloat ws(float x,float a){return x*(abs(x)+a)/(x*x+(a-1.)*abs(x)+1.);}\n//percussion Drum Snare (high pitch)\nfloat Bounchy(float x //https://www.shadertoy.com/view/XscXzn\n){float freq=660.*baseFreq\n ;float c=0.\n ;const int  num=11\n ;for(int i=0;i<num;i++\n ){float time=x-float(i)*(.09+float(i)*0.01)\n  ;if(time<0.)continue\n  ;float t=1.-(time*1.)\n  ;t=max(t,0.)\n  ;t=pow(t,2.)\n  ;float f=sin(t*freq)/pi\n  ;f=ws(f,2.9)\n  ;t=time*baseFreq\n  ;f*=pow(max(0.,1.-(t*6.)),4.)\n  ;f=ws(f+rand(time)*.4*pow(1.-t,20.),1.9)\n  ;c+=clamp(f,-1.,1.)*.7/float(1+(i*i*4))\n ;}return c*.35;}\nfloat clap(vec3 k //https://www.shadertoy.com/view/MslSD2\n){float n = fract(sin(tune * 110.082 * k.x) * 19871.8972)\n ;float a = pow(1.0-k.y,1.0)\n ;if (k.x>0.)return (sin(n*a)*a+(sin(a*8.4*k.x)*pow(a,8.0-k.x*0.02)))\n ;return 0.;}\n//percussion\n//percussion-sequence alias to 2 percussion in truments\n#define BD(d)   c+=drum(TT(d));\n#define SN(d)   c+=Bounchy(TT(d));\nfloat drums(float t\n){float c=0.\n ;float n=0.,b=0.,x=0.\n ;float time=mod(t,4.0)\n ;      if(time<1.){BD(.0);SN(.5 );BD(.75)\n ;}else if(time<2.){BD(.0);SN(.5 )\n ;}else if(time<3.){BD(.0);SN(.5 );BD(.75)\n ;}else if(time<4.){BD(.0);SN(.25);SN(.5 );SN(.75)\n ;}return c;}//https://www.shadertoy.com/view/XscXzn     \n//percussion-sequence\nvec2 debugDrums(float t//https://www.shadertoy.com/view/XttfWn\n){vec2 c=vec2(0)\n ;c+=Bounchy(fract(t))\n ;//+=hiHat(t)\n ;//c+=hiHat(t)*.5\n ;//c+=snereDrum(t)*.5\n ;//c+=bassDrum(t)*.5\n ;return c;}\n\n//__end___ instruments-percussion\n//_start__ sequences that inclcude instruments\n\n//- this is BAD style, instead a sequence should be fed to an instrument function!  \n//sequence\n#define TT(d) mod(mod(time,1.0)-d,1.0)\n#define LD(d,n)   c+=sineVib(TT(d),n,1./speed,arpVolume)*step(0.0,time-d)\nfloat lead(float t,float arpVolume\n){float c=0.,speed=.5,time=mod(t*speed,32.0),f=0.\n ;int i=0\n ;if(time>8.0 && time<16.0)time-=8.0\n ;if(time<1.0){LD(0.0,i);LD(0.5,i+2)\n ;}else if(time<2.0){time=fract(time);LD(0.0,i+3);LD(0.125*1.0,i+5);LD(0.125*3.0,i);LD(0.125*5.0,i-2)\n ;}else if(time<3.){time=fract(time);LD(0.0,i);LD(0.5,i+2)\n ;}else if(time<4.){time=fract(time);LD(.0,i+3);LD(.125*1.,i+5);LD(.125*3.,i+10);LD(.125*5.,i+7)\n ;}else if(time<5.0){time=fract(time);LD(0.0,i);LD(0.5,i+2)\n ;}else if(time<6.0){time=fract(time);LD(0.0,i+3);LD(0.125*1.0,i+5);LD(0.125*3.0,i);LD(0.125*5.0,i-2)\n ;}else if(time<7.0){time=fract(time);LD(0.0,i);LD(0.5,i-2)\n ;}else if(time<8.0){time=fract(time);i=-12;LD(0.0,i+7);LD(0.125*1.0,i+10);LD(0.125*2.0,i+5)\n  ;LD(0.125*3.0,i+7)\n ;}return c;}\nvec2 synthWave2(float t){t=mod(t,32.);return vec2(lead(t,.0));}\n//sequence, this crashes opengl, when used with a slow dft and complex arp-ed instruments:\n#define k0 0.\n#define k12 19.2\n#define k1 38.4\n#define k2 76.8\n#define h0 0.\n#define h1 32.7\n#define p0 0.\n// guitar\n#define F10 349. / 4.4\n#define A8s 233. / 4.4\n//#define A8 175. / 8.\n// bass\n#define No\t0.\n#define Eb 155.6 / 4.4\n#define Gg    98. / 4.4\n#define Bb  58.3 / 4.4\n//this is why you wrap sequences in instruments and not instruments in sequences\nfloat bass(float t//sequence with dull instrument\n){t=mod(t,8.)\n ;if(t<2.0)       return rect(t*calcHertz(0.))\n ;if(t<3.5&&3.0<t)return rect(t*calcHertz(0.))//todo frame this!\n ;if(t<4.0)       return rect(t*calcHertz(12.))\n ;if(t<6.0)       return rect(t*calcHertz(11.))\n ;if(t<8.0)       return rect(t*calcHertz(-1.))\n ;return 0.;}\nvec3 p8(float p,mat4 a//this works for pat16 and pat8, instead of many floats, it  now takes a matrix.\n){float t = fract(p/16.)\n ;vec2 i=vec2(1,4)*(floor(t*4.))\n ;return vec3(a[int(i.x)][int(floor(t*16.)-i.y)],fract(t)-1.,p);}//the -1 may actually just be halfspace overlap!\nvec3 pat8(float t,mat4 a\n){vec2 i=vec2(mod(t,4.),0)\n ;return vec3(a[int(step(3.,fract(t/8.)*8.))][int(i.x)],fract(fract(t/8.)*8.),t);}\nvec3 pat8(float t,float p1,float p2,float p3,float p4,float p5,float p6,float p7,float p8\n){t=mod(t,8.)\n ;return pat8(t,mat4(p1,p2,p3,p4,p5,p6,p7,p8,0,0,0,0,0,0,0,0));}\n //;if(t>7.)return vec3(p8,fract(t),t);if(t>6.)return vec3(p7,fract(t),t)\n //;if(t>5.)return vec3(p6,fract(t),t);if(t>4.)return vec3(p5,fract(t),t)\n //;if(t>3.)return vec3(p4,fract(t),t);if(t>2.)return vec3(p3,fract(t),t)\n //;if(t>1.)return vec3(p2,fract(t),t);if(t>0.)return vec3(p1,fract(t),t);return vec3(0.);}\nvec2 Play2(float time\n){vec2 snd = vec2(0.)\n ;tempo = time * 4.6\n ;tune=mod(time, 8.0); // * 1.0\n ;if (tempo < 24.0\n ){snd += 0.25*hat(pat8(tempo,mat4(1.,1.,1.,1.,1.,1.,1.,1.,0,0,0,0,0,0,0,0)))\n  ;//snd +=     clap(pat8(tempo,mat4(k12,k12,k0,k0, k12,k0,k0,k0,0,0,0,0,0,0,0,0)))\n  ;//snd += 0.5*kick(pat8(tempo,mat4(k0,k0,k1,k1, k0,k0,k1,k1,0,0,0,0,0,0,0,0)))\n ;}else if (tempo >= 24.0 && tempo < 28.\n ){//snd += 0.25*hat(pat8(tempo,mat4(h1,h1,h1,h1, h1,h1,h1,h1,0,0,0,0,0,0,0,0)))\n  ;//snd +=     clap(pat8(tempo,mat4(k12,k12,k0,k0, k12,k0,k0,k0,0,0,0,0,0,0,0,0)))\n  ;//snd += 0.5*kick(pat8(tempo,mat4(k0,k0,k1,k1, k0,k0,k1,k1,0,0,0,0,0,0,0,0)))\n ;}else if ((tempo >= 28.0) && (tempo < 32.)\n ){//snd +=     clap(pat8(tempo,mat4(k12,k12,k12,k12, k0,k0,k0,k0,0,0,0,0,0,0,0,0)))\n  //;snd +=     clap(pat8(2.*tempo,mat4(k12,k12,k12,k12, k0,k0,k0,k0,0,0,0,0,0,0,0,0)));\n  //;snd += 0.5*kick(pat8(2.*tempo,mat4(k0,k0,k0,k0, k1,k1,k1,k1,0,0,0,0,0,0,0,0)))\n ;}else{/*\n        snd += 0.25*hat(pat16(tempo, h1,h1,h1,h1, h1,h1,h1,h1, h1,h1,h1,h1, h1,h1,h1,h1));\n\t    snd +=     clap(pat16(tempo, k0,k0,k12,k0, k0,k0,k12,k0, k0,k0,k12,k0, k0,k0,k12,k12));\n        snd += 0.5*kick(pat16(tempo, k1,k1,k0,k0, k1,k1,k0,k0, k1,k1,k0,k1, k0,k1,k0,k0));\n        float mt = mod(tempo, 32.);\n        if (mt < 16.) snd+=tb303(pat16(mt, Eb,No,Eb,Eb, Eb,Eb,Eb,Eb, G,No,G,G, No,G,G,G));\n        else\t\t  snd+=tb303(pat16(mt, Bb,No,Bb,Bb, Bb,Bb,Bb,Bb, G,No,G,G, No,G,G,G));\n        if (tempo>96.)snd+=.5*pad(pat16(tempo, F10,No,A8s,No, F10,No,A8s,No, F10,A8s,No,F10, No,No,A8s,No));\n        /**/\n }return snd * smoothstep(0.0,0.5,time) * smoothstep(60.0,59.0,time);}\n//#define A8 175. / 8.\n#define No\t0.\nvec2 Play(float time\n ){vec2 snd = vec2(0.)\n  ;tempo = time * 4.6\n  ;tune  = mod(time, 8.0); // * 1.0\n  ;snd += 0.5*pad(p8(tempo,mat4(F10,No,A8s,No, F10,No,A8s,No, F10,A8s,No,F10, No,No,A8s,No)/4.4))\n  ;return snd * smoothstep(0.0,0.5,time) * smoothstep(60.0,59.0,time);}\n//\t    snd += 0.5*pad(pat16(tempo, F10,No,A8s,No, F10,No,A8s,No, F10,A8s,No,F10, No,No,A8s,No));\nvec2 DecentBase(float t\n){vec2 c=vec2(0)\n ;return Play2(t)\n ;t=mod(t,16.)\n ;float p = t *5.;//period length\n ;//c+=vec2(clap(pat8(p, 19.,29.,0.,0., 19.,0.,15.,13.)))\n ;//c+=vec2(clap(p8(p,mat4(20,22,0,26,28,30,32,34,0,0,0,0,0,0,0,0))))\n ;//c+pad(p8(p,mat4(349,349,0,349,349,349,32,34,0,0,0,0,0,0,0,0)/4.4))\n ;//c+0.5*pad(pat16(tempo, 349.,0.,233.,0., 349.,0.,233.,0., 349.,233.,0.,349., 0.,0.,233.,0.)/5.);\n ;//c+0.5*pad(p8(tempo, mat4(349.,0.,233.,0., 349.,0.,233.,0., 349.,233.,0.,349., 0.,0.,233.,0.))/5.);\n     //piano(vec3(11,t,5.))\n ;return c;}\n//sequence          \nvec2 synthWave(float t//https://www.shadertoy.com/view/MdjXWc\n){bool do_reverb = mod(t, 8.0) > 4.0\n ;float m = mod(t, 2.0)\n ;vec2 f=cs(t-m)\n ;float f0 =220.*cos(t-m)+880.//FM over time makes it easier to debug timing.\n ;f0+=cos(2.*t)*440.\n     // this cos()  illustrates the reverb in the dft(), as cos() breaks some symmetry ofer time.\n ;vec2 w = vec2(co2p(m * f0) * exp(-m * 2.5))\n #ifdef doReverb\n ;vec2 r=lpnoise(m, 100.)\n        +lpnoise(m, 550.)*.2\n        +lpnoise(m,1050.)*.1*exp(-t*5.)//3 octaves of overtones.\n ;float a=exp(-m*2.)//exponential falloff for reverb\n ;w+=(co2p(m*f0+r*.1)-co2p(m*f0))*a//differential of 2 offset samples. pigmentation-interferrence.\n #endif\n ;w*=1.-exp(-m*800.)//instrument falloff hull\n ;return w;}\n\n\n\n//___end__ sequences that inclcude instruments\n//_start__ dump\n\n\n\n\n\n\n    \n\n\n\n    \n\n\n\n                          \n\n                \n\n                          \nvec2 debugCompositionB(float t//this composition is a nice rythmic backdrop\n){float f=fract(t)\n ;vec2 c=vec2(0)\n ;c+=debugDrums(t)\n ;c+=strings(t)*.2\n ;c+=bubbles2(t*2.)*.2//bubbles are in 3 golden ratio intervals.\n ;c+=bellSqua(t)\n ;c+=bell(t,220.-cos(f-t)*110.)*.2\n ;c+=synthWave(t)*.2\n ;return c\n ;}\n                          \n\n                          \n\n\n\n\n//this is a maess of namespace conflicts \n//...and very different approaches to very similar things.\n//just look at all the ways they define a rotation:\n//which leads to my conclusion:\n//most people have no clue what they are doing,\n//...just by looking at their low efficiency.\n\n\n\n\n//instrument krakenSynth\nfloat krakenSynth(int note, float time, float octave, float sawTweak//earthbound sfx \n){float baseFreq = noteFreq(note)\n ;float sinFreq = baseFreq*pow(2.0,octave+2.0)\n ;float sawFreq = baseFreq*pow(2.0,octave-3.0-sawTweak)\n ;float sinWave = cos(6.2831*time*sinFreq)\n ;float sawWave = 1.0-mod(time*sawFreq,1.0)\n ;sawWave = pow(sawWave,8.0)\n ;return sawWave*sinWave - sawWave; }\n\n//instrument sequence that contains instrument-krakenSynth()\nfloat krakenLead(float songTime\n){float beatNum =songTime/beatLength\n ;float beatStep=mod(floor(beatNum),32.)\n ;if(fract(beatNum)>=.68)return 0.//beat filter\n ;float barStep=floor(beatNum/32.)\n ;float triplet=floor(beatStep/3.)\n ;float withinTriplet = mod(beatStep,3.0)\n ;if (beatStep >= 16.0\n ){triplet = 5.0-floor((beatStep-16.0)/3.0)\n  ;withinTriplet = mod(beatStep-16.0,3.0);}\n ;if (beatStep >= 29.0)withinTriplet++\n ;int curNote=3\n ;if((barStep>0.)&&(mod(barStep,2.0)==0.0)) curNote += 4\n ;float octave = -triplet\n ;if(withinTriplet == 2.)octave++\n ;return krakenSynth(curNote,mod(songTime,beatLength),octave,-triplet)\n ;}\n\n\nfloat bassSynth(int note, float time){    \n    const float noteLength = 0.5;    \n    if (time > noteLength) return 0.0;    \n    float baseFreq = 6.2831*time*noteFreq(note);    \n    float fadeIn = 1.0-pow(1.0-(time/noteLength),32.0);\n    float fadeOut = 1.0-pow(time/noteLength,8.0);\n     return (\n        sin(baseFreq*pow(2.0,-6.0))*1.5 +\n        sin(baseFreq*pow(2.0,-5.0))*0.5 + \n        sin(baseFreq*pow(2.0,-4.0))*0.05\n    )*fadeIn*fadeOut;}\n\nfloat krakenBass(float songTime){    \n    // this redundancy isn't great but whatev\n    float beatNum = songTime/beatLength;\n    float beatStep = mod(floor(beatNum),8.0);//DIFFERENT BAR LENGTH FOR BASSLINE\n    float barStep = mod(floor(beatNum/8.0),4.0);\n    if ( beatStep == 3.0 && barStep < 2.0) return 0.0;\n    if ( beatStep == 6.0 && barStep < 3.0) return 0.0;\n    if ( beatStep == 7.0 && barStep == 3.0) return 0.0;    \n    int bassNote = (mod(floor(beatNum/32.0),2.0) == 0.0) ? 8 : 4 ;    \n    return bassSynth(bassNote, mod(beatNum,1.0));}\n\n\nfloat wailSynth(int note, float time){    \n    const float noteEnd = 32.0;\n    const float noteStart = 4.0;    \n    float noteFrac = max(0.0,min(1.0,(time-noteStart)/(noteEnd-noteStart)));\n    float fadeIn = pow(noteFrac,2.0);\n    float fadeOut = 1.0-(pow(noteFrac,2.0));    \n    float baseFreq = 6.2831*time*noteFreq(note)*0.25;\n    baseFreq += sin(time*4.5)*3.0;    \n    return (\n        sin(baseFreq)+\n        sin(baseFreq*3.0)+\n        sin(baseFreq*4.0)*0.75\n    )*fadeIn*fadeOut*0.5;}\n\nfloat krakenWail(float songTime){    \n    float beatNum = songTime/beatLength;    \n    int wailNote = (mod(floor(beatNum/32.0),2.0) == 0.0) ? 2 : 3;    \n    return wailSynth(wailNote, mod(beatNum,32.0));    }\n\n\n\n\n//hull\nfloat fadeIn(float t,float e){float f=sat(t/e);return f*f;}\nfloat fadeOut(float s,float e,float t){return 1.-fadeIn(t-s,e-s);}//earthbound fadeout\nfloat fadeOut4(float s,float e,float t//earthbound fadeout\n){float f=sat((t-s)/(e-s));return 1.-f*f*f*f;}\n\nfloat hihatOpen(float time\n){float noiseVol\n ;float sineVolA\n ;float sineVolB\n ;if (time < 0.125\n ){noiseVol = 2.0\n  ;sineVolA = 0.1;\n   sineVolB = 0.15;        \n    } else if (time < 1.0) {        \n        noiseVol = 0.6;        \n        sineVolA = 0.1;\n        sineVolB = 0.15;        \n    } else if (time < 2.0) {        \n        noiseVol = max(0.0,min(1.0,(2.0-(time*1.0))));\n        noiseVol = pow(1.0-noiseVol,1.0);\n        noiseVol *= 0.1;        \n        sineVolA = max(0.0,min(1.0,(2.0-(time*0.5))));\n        sineVolA = 1.0-pow(1.0-sineVolA,1.0);\n        sineVolA *= 0.0125;        \n        sineVolB = sineVolA*1.5;        \n    } else return 0.0\n   ;float mi = 0.\n   ;mi += noise(time)*noiseVol\n   ;mi += sin(time*6300.0) * sineVolA\n   ;mi += sin(time*7200.0) * sineVolB\n   ;return mi;}\n\nvec2 EarthBoundBattleIntro(float time,float introEndTime//no idea how there is suddenly a fadein envelope.\n){vec2 mi=vec2(0)\n  ;for(float i=0.; i<3.;i++//3 echos\n  ){float ep=time-i*.03//echo phase\n   ;mi+=((introHorn(-4,ep)*pan(-.6))\n        +(introHorn( 3,ep)*pan(-.2))\n        +(introHorn( 5,ep)*pan( .2))\n        +(introHorn(10,ep)*pan( .6))\n        +(introHorn(14,ep)*.5*pan(.0)))*.2*(1.-(i/3.));}        \n  ;float volEnv = u5(cos(pow(time*0.5,0.8)*pi*2.))\n  ;const float volEnvMin = 0.3\n  ;volEnv = volEnv*(1.0-volEnvMin)+volEnvMin\n  //;float fadeInEnd =  introEndTime+ 0.3\n // ;float fadeIn = max(0.0,min(1.0,(time)/(fadeInEnd)))      \n // ;fadeIn = 1.0-pow(1.0-fadeIn,2.0)\n  ;return mi*volEnv*fadeOut4(introEndTime-.45,introEndTime-.1, time)\n      *fadeIn(time,0.3)\n      ;}\n\n\nvec2 EarthBoundBattle(float time,float introEndTime\n){float songTime=time-introEndTime\n ;float mi=0.\n ;float beatNum = songTime/beatLength\n ;float barStep  = floor(beatNum/32.0)\n ;float beatStep = fract(floor(beatNum)/32.)*32.\n ;if(barStep==0.)mi+=krakenLead(songTime)\n ;else           mi+=krakenLead(songTime)+krakenLead(songTime-0.1)*0.3\n ;if (barStep>0.\n ){if (barStep==1.\n  ){if(beatStep<28.)mi+=kick(fract(beatNum/4.)*4.)*1.5\n   ;else            mi+=kick(fract(beatNum))*1.5\n   ;float snareHatBeat\n   ;float snareHatVol\n   ;if(beatStep<=24.\n   ){snareHatBeat=fract(beatNum/2.)*2.\n    ;if (fract(beatStep/8.)*8.>=4.)snareHatBeat=mod(beatNum+1.,2.)\n    ;snareHatVol=1.\n   ;}else{\n    ;snareHatBeat=mod(beatNum,1.0)\n    ;snareHatVol=1.25+.5*((beatStep-24.)/8.)\n   ;}\n   ;mi += snare(snareHatBeat)*snareHatVol\n   ;mi += hihatClosed(snareHatBeat)*0.5*snareHatVol\n  ;}else\n   {float beatStepHalf=mod(beatStep,16.0)\n   ;if(any(equal(vec4(beatStepHalf),vec4(0,8 ,10,14)))||beatStep==21.)mi+=kick (mod(beatNum,1.))*1.5\n   ;if(any(equal(vec4(beatStepHalf),vec4(4,7 , 9,12)))               )mi+=snare(mod(beatNum,1.))*1.5\n   ;if(any(equal(vec3(beatStepHalf),vec3(3,11,13   )))               )mi+=snare(mod(beatNum,1.))*.5\n   ;float hihatBeatNum = beatNum-2.\n   ;if(fract(floor(beatStep/2.)/8.)*8.<=4.)hihatBeatNum+=2.\n   ;mi+=hihatOpen(fract(hihatBeatNum/4.)*4.)*1.3\n   ;mi+=krakenBass(songTime)*1.15\n   ;mi+=krakenWail(songTime)*1.8//made louder by ollj\n   ;mi+=krakenWail(songTime-0.1)*2.//made louder by ollj\n ;}}\n ;return vec2(mi)*.3*fadeOut(128.,128.+64.,beatNum);}//https://www.shadertoy.com/view/MljGRd\n    \n\n\nvec2 DemoEarthBoundBattle(float time//sequence is quite \"noisy\" ==discontinuous\n){const float introEndTime=4.\n ;time=mod(time,30.)\n ;if (time<0.)return vec2(0)\n ;if (time<introEndTime){return EarthBoundBattleIntro(time,introEndTime)\n ;}else return EarthBoundBattle(time,introEndTime);}\n\n\n\n\n\n\n\n\n\n\n                          \n\n\n//bubble noise  //n += note(C4, m, 0.0, 2.0, time);\nfloat noteBubble(float hz, int type, float s, float d, float t) {\n    float f=0.4;\n    s *= f;\n    d *= f;\n    if(t >= s && t <= s+d) {\n        t -= s;\n        float rt = t;\n\t\tt *= CON;\n    \tif(type == 1) {\n            rt = pow(rt+1.0,10.0);\n            if(rt < 1.0) {\n                rt = 1.0;\n            }\n    \t\treturn (sin(t*hz)/rt);\n        } else if(type == 2) {\n            float n = sin(t*hz);\n            n *= fract(rt*hz);\n            return n;\n        } else if(type == 3) {\n            t += sin(t*5.0)*0.005;\n            float n = sin(t*hz);\n            return n;\n        } else if(type == 4) {\n            t *= rt*4.0+0.5;\n        \tfloat n = sin(t*hz);\n            rt = pow(rt*4.0+0.5,20.0);\n            if(rt < 1.0) {\n                rt = 1.0;\n            }\n            return n/rt;\n        }}}//https://www.shadertoy.com/view/XdScDy\n\n\n\n\n//sfx\nfloat collisBall(float s,float t//start,time;    //https://www.shadertoy.com/view/MtSXR1\n){t-=s;return clamp(sin(t*(0.18-t)*10000.0)*exp(t*-50.)*3.,-.4,.4);}\n//sfx\nfloat explosionSound(float time//https://www.shadertoy.com/view/4l2GzR\n){if (time>=0.5 || time<=0.0)return 0.\n ;float freq = 1000.0 * (1.0-time*2.0)\n ;float freqintegrated = 1000.0 * (-time*time*1.0+time)\n ;float r=noize(float(int(freqintegrated)))\n ;//r+=fract(freqintegrated)>0.5 ? -0.2 : 0.2\n ;return r;}\n\n\n\n\n\n\n//hull adsr(); time, vec4(attack,decay,hold,release), s = sustain amplitude\nfloat adsr(float t, vec4 v, float s//https://www.shadertoy.com/view/ll23RK\n){v.xyw = max(vec3(2.2e-05),v.xyw)\n ;float ta = t/v.x// attack term\n ;float td = max(s, 1.0-(t-v.x)*(1.0-s)/v.y)// decay / sustain amplitude term\n ;float tr = (1.0 - max(0.0,t-(v.x+v.y+v.z))/v.w)// length / release term\n ;return max(0.0, min(ta, tr*td))\n ;}\n\n#define BPM 112.\n//same idea (bitwise square wave?) but with an AR envelope\nfloat seqAR(float t, float gate, float atk, float rel, float ofst\n){float p=((t*pi*BPM/120.)-ofst*TAU-pi*0.5+gate)\n ;float tp = fract(p/pi*.5)\n ;gate = clamp(gate,-1.,1.)//scale envelope, based on the gate length\n ;float scl = (1.-abs(gate))\n ;atk *= scl\n ;rel *= scl\n ;if (tp > 0.5) return smoothstep( gate-atk, gate+atk, cos(p)) //Attack envelope\n ;return smoothstep( gate-rel, gate+rel, cos(p));} //Release envelope\n\n//simple frequency modulation (3->1)\nfloat fmsq(float t, float note, float octave){\n\tfloat fm = sn(t,note,octave-1.)*.0008;\n\tfloat fm2 = sn(t,note,octave+1.)*.0007;\n\tfloat fm3 = sn(t,note,octave+2.)*.00055;\n\treturn sqr(t+fm+fm2+fm3,note,octave);}\n//very fake filtered saw (not used)\nfloat filterSaw(float t, float note, float octave, float cutoff, float q){\n    float saw = fract(t*note*exp2(octave-1.))-0.5;\n    float sn = cos((t*note*exp2(octave)*pi)+pi*0.5);\n    float filt = smoothstep(cutoff-q,cutoff+q,abs(saw)*2.);\n    return mix(saw,sn,filt);}\n//a slightly more complex intrument using the sequencer for harmonic envelopes\n//freq is how often the note is triggered\nfloat additive(float t, float note, float octave, float freq){\n    float x = t*freq;\n    float rz = 0.;\n    float atk = 0.01;\n    float rel = 1.;\n    float h = 1.;\n    float pw = 1.;\n    float dcy = .0;    \n    for(int i=0;i<6;i++)    {\n        rz += sn(t*h, note, octave)*seqAR(x, dcy ,atk, rel, 0.)*pw;\n        dcy += .1;\n        pw  -= .1;\n        h = float(i)+1.001;\n    }\n    rz = saw(rz*0.002,note,octave)*seqAR(x, .0 ,atk, rel, 0.);\n    return rz;}//https://www.shadertoy.com/view/MdfXW2\n\n\n\n#define C 1046.50\n#define D 1174.66\n#define E 1318.51\n#define F 1396.91\n#define G 1567.98\n#define A 1760.00\n#define B 1975.53\n#define C2 2093.00\nfloat[] notes = float[](C, D, E, F, G, A, B, C2); \nfloat note(int idx, int octave, float amp, float t) {\n\treturn amp*sin(exp2(float(octave))*notes[idx%8]*mod(t,2.0)*6.28318*0.2);   \n}//https://www.shadertoy.com/view/ldXBzH\nfloat noteSaw(int idx, int octave, float amp, float t) {\n\treturn amp*tan(sin(exp2(float(octave))*notes[idx%8]*mod(t,2.0)*6.28318*0.2));   \n}//https://www.shadertoy.com/view/ldXBzH\nfloat noteSquare(int idx, int octave, float amp, float t) {\n\treturn 3.0*amp*pow(fract(exp2(float(octave))*notes[idx%8]*floor(mod(4.0*t,2.0)+1.0)*mod(t,2.0)*0.05)-0.5,1.0);   \n}//https://www.shadertoy.com/view/ldXBzH\n#undef E\n#undef C\n#undef D\n#undef F\n#undef G\n#undef A\n#undef B\n#undef C2\n//float rand(float t){ return fract(sin(t*1793.326) * 43758.5453);}//https://www.shadertoy.com/view/XscXzn\n//hihat\n//f+=rand(time)*0.5*pow(1.0-t2,16.0);*/\n\n\n       \n\n\n//___end__ dump\n//__start audiovisual\n\n\n/*\n//return silly slow 4 color ramp, famous for fourier transforms.\nvec3 blueRedYellowWhite(float y){vec3 c=mix(vec3(0)//overly precise and slow fragiend function\n        ,vec3(0.2,0.2,0.7),remap(.00,0.25,y));//blue\n c=mix(c,vec3(0.9,0.1,0.0),remap(.25,0.50,y));//red\n c=mix(c,vec3(1.0,1.0,0.3),remap(.50,0.75,y));//yellow\n return mix(c,vec3(1.0,1.0,1.0),remap(.75,1.00,y));}//white\n*/\n\n\n//rgba colorspace matrices\n//rgba colorspace matrices\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nvec3 rainbowt(float a,float b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbowt(float a){return rainbowt(-a,1./3.);}\nvec3 rainbows(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbows(float a){return rainbows(-a,1./3.);}\n#define ToRgb(w) return c.z*mix(vec3(1.),sat(w(-c.x)),c.y);}\nvec3 rainbows(vec3 c){ToRgb(rainbows)//3 tri waves, most blurry  , fast and precise cos-mix (blurriest because it is only linear)\nvec3 rainbowt(vec3 c){ToRgb(rainbowt)//3 cos waves, medium blurry, linear-mix not identical to hsv2rgb ,but close\n//hsv2rgb uses a capped triangle-wave, as such it appears to be the brighttest/sharpest because at any moment only 2/3 colors swap.\n#define hsv2rgb(c) c.z*mix(vec3(1),sat(abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),c.y)\n//below is inverse of above, it swivels quite a lot, i think i once made this much smarter!, like in 2008, but code is lost\n#define rgb2hsv2(a,b,c,d,e,f) mx(vec4(a,b),vec4(c,d),st(e,f))\n#define rgb2hsv3(K) rgb2hsv2(a.zy,K.wz,a.yz,K.xy,a.z,a.y)\n#define rgb2hsv4(P) rgb2hsv2(P.xyw,a.x,a.x,P.yzx,P.x,a.x)\n#define rgb2hsv5(D,q) abx(vec2(q.w-q.y,D)/(vec2(6.*D,q.x)+1e-10)+vec2(q.z,0))\n#define rgb2hsv6(q) vec3(rgb2hsv5((q.x-min(q.w,q.y)),q),q.x)\n#define rgb2hsv(a) rgb2hsv6(rgb2hsv4(rgb2hsv3((vec4(0,-1,2,-3)/3.))))//https://www.shadertoy.com/view/MdGfWm\n//common legacy namespaces\n#define hsv2rgbR     rainbowt //3 tri waves, most blurry, fast and precise, considder for mobile\n#define angleToColor rainbows //3 cos waves, medium blurry\n//hsv2rgb() most commonly implies a [capped triangle waveform]\n//vec3 HsvToRgb(vec3 c){vec3 p;p=abs(fract(c.xxx+vec3(3,2,1)/3.)*6.-3.);return c.z*mix(vec3(1),sat(p-1.),c.y);}\n//general [Poeter-Duff] \"Compositing Digital Images\" siggraph 1984;\n//https://en.wikipedia.org/wiki/Alpha_compositing\n//https://doc.qt.io/archives/qq/qq17-compositionmodes.html \n//#define pdC(a,b,c,d,m,f)mix(a,b,m.w)*c*d*f+pdCx(a,b,c,d,m)\nvec3 pdC(vec3 a,vec3 b,float c,float d,vec4 m,float f){return mix(a,b,m.w)*f*c*d+b*m.z*(1.-c)+a*m.y*(1.-d);}//many contextual simplifications possible.\n#define pdA(c,d,m)suv(m*vec3(c*d,c*(1.-d),d*(1.-c)))\n//#define pdA(c,d,m)m.x*c*d+m.y*c*(1.-d)+m.z*d*(1.-c)\n//xor case is simpler,likely worth making it a subroutine of pdC;\n//#define pdCx(a,b,c,d,m)m.y*a*(1.-d)+m.z*b*(1.-c)\n//vec3 pdCx(vec3 a,vec3 b,float c,float d){return a*d+b*c;}\nvec4 pd(vec4 a,vec4 b,vec4 m,float f){\n vec4 r=vec4(pdC(a.rgb,b.rgb,a.w,b.w,m,f),1);//ceneral case color\n r.w=pdA(a.w,b.w,m.rgb);//general case alpha is sometimes neglible.\n return r;}\n//return a*a.w+b*b.w*(1.-a.w);//general case reduction shortcut\nvec4 sOver(vec4 a,vec4 b){return pd(a,b,vec4(1,1,1,0),1.);}\nvec4 sAtop(vec4 a,vec4 b){return pd(a,b,vec4(1,0,1,0),1.);}\nvec4 sIn (vec4 a,vec4 b){return pd(a,b,vec4(1,0,0,1),1.);}\nvec4 sXor(vec4 a,vec4 b){return pd(a,b,vec4(0,1,1,1),0.);}\nvec4 sOut(vec4 a,vec4 b){return pd(a,b,vec4(0,0,1,0),0.);}\nvec4 sCut(vec4 a,vec4 b){return pd(a,b,vec4(0,0,1,1),0.);}\n                          \n\n//we define segments NOT by start and end times, BUT by center and width!\n//because this simplifies inequalities, allowing us to utilize abs() and calculus\n//thish in the long run simplifies many interlolations\n// , contextual framing and boke/CoC/Kerning with overlapping segments!\n//by substituting an inequalit with mix(step())\n//, and substituting step() with smoothstep()\n\nvec2 debugCompositionA(float t//this composition is played first and has high variance.\n){vec2 c=vec2(0);\n ;//c+=strings(t)*.2\n ;//c+=DemoEarthBoundBattle(t)\n ;//c+=DrWhoTheramin(t,t*2.))\n ;//c+=DemoDrWho(t)\n ;//c+=debugInstruments(t)\n ;//c+=demoBandLimit(t)\n ;c+=debugInstrument(t)\n ;return c;}\n                          \nvec2 soundFrames(float t){\n ;return debugCompositionA(t)\n ;vec2 c=vec2(0)\n ;     if(0.<8.-abs(t-13.))c+=debugCompositionA(t)\n ;else if(0.<8.-abs(t-13.-16.-8.)) c+=synthWave2(t+3.-8.)//8. seds the halfWidth of segment. -13 sets CenterOffset of segment\n //starting point is =13-8=3, and this must be the time offset of all within the segment\n ;else if(0.<14.-abs(t-14.-16.-8.-12.-6.-2.)) c+=demoBandLimit(t)*.5\n //13 is previous segment midpoint, -8 and .4 are halfwidths of 2 segments -2 is a \"nomalsland\" between 2 segments.\n ;else c+=debugCompositionB(t)//background rythmic, profices constant feel to time/tempo, semi-metrum:\n ;return c;}\n                          \nvec2 sound(float t//entry point for mainSound( in int samp,),waveForm and dft()\n){//float f=fract(t)\n //;t+=8.//fast forward\n ;vec2 c=vec2(0)\n ;//c+=debugDrums(t)\n ;//c+=debugInstruments(t)\n ;//c+=drums(t)\n ;//c+=DecentBase(t)//watning subobtimal sequencer and big instruments,takes long to parse!\n ;//return AlienHum(t)//delayed, too complex sequence and way too many octaves in instrument crash it!\n ;//return teslaCoil(t)\n ;c=soundFrames(t)\n ;return c\n ;return vec2(co2p(440.*t)*exp(-3.0*t))// A 440 Hz wave that attenuates quickly overt time\n ;}\n//vec2 mainSound( in int samp,float t){return sound(t);}\n                         \n//to render a waveform, for the sake of performance (in favor of DFT)\n//, audio visualizers are single taps without calculis, no normalized line thickness.\nvec4 VisWaveForm(vec2 u,vec2 m,vec2 r,float t//https://www.shadertoy.com/view/ldlSD2\n){u.y=(u.y*2.-1.)*2.\n ;float zoom=100.\n ;u.x=biject(u.x+(floor(t*fpsWave)*zoom/fpsWave),1.,0.,0.,-1./zoom)\n ;float v = sound(u.x).x\n ;//float dx=fwidth(v);v=abs(v-u.y)/sqrt(1.+dx*dx)//way too many c0 dicsontinuities here to look decent\n ;//this needs multitapping for half devend width differentials.\n ;v=smoothstep(.02,-.02,abs(v-u.y)-.1)//waveform  line thickness\n ;\n ;//c.x=abs(dx-u.y)/sqrt(1.+dx*dx)//euclidean_scale by firct derivative. (bad near very shin extrema)\n ;return vec4(v);}\n\nvec3 gradOllj(float T,vec2 u\n){T=T*1.5-.8\n ;vec3 c=rainbows(((((2.-T)/pi)*pi)-.5)/2.+1./6.,1./6.)\n ;if(u.x<0.)T-=0.34\n ;if(u.x<0.)c=1.-rainbows(((((2.+T)/pi)*pi)-.5)/2.+1./6.)\n ;c=c/max(c.r,max(c.g,c.b))*u5(((c.g)/(c.r+c.b)))//optional norm\n  ;return c;}\n                          \n//various basic gain/amplify/constrast/gamma/rainbow() \n//to show a DFT-image nicer, to ballance contrasts.\n//to highight amplutude with a filter that gets harder near [p]==timeNow/iMouse\n//that filters out weaker frequencies, only greyscaling the strongest.\n//whille further in past/future hue is used to distinguish more amplitude-range\n//this whole function is a woven mess of options: m.xy sets some parameters:\n//all that sets [c] may be mixed and matched, depending on [p]; mix(c1,c2,p)\n//some that set [c] take [p] as parameter, that sets hue by [p]\n//functions are ordered in a way that makes most contextual sense, i hope.\nvec3 oilyDftRainbow(float l,vec2 u,vec4 m//DFTamplitudeAtUV,uv,iMouse //.x is time,.y is frequency.\n){float p=abs(m.x-u.x)\n ;l*=4.\n ;float q=smoothstep(.1,-.1,p*.4)\n ;l/=32. //must have this or the line below\n ;//l/=mix(64.,4.,q)//or global factor dynamic variant!   \n ;//l=.3+.8*(l/mix(64.,2.,1.))//optional  tiny green bias experiment, good for visibility.\n  //above line uses MORE hue, to make an overall brighter image, uses more green/blue as backdrop.\n ;vec3 c=vec3(0)\n ;l=sat((l))\n ;c=mix(gradOllj(l,u)*l,l+hsv2rgb(vec3(l*.6,2./(l+.1),l)),u5(l));//simpler times or oilyUse:\n #define oilyUse rainbow2 //see hsv2rdb functions.\n ;//vec3 c=oilyUse(l*0.61)*u5(l)//simple \n ;//l/=sqrt(l+.1);//optional flatten colors, highlight lower amplitudes\n ;//l/=1.+l//optional enhance\n ;//l=sat(l/(abs(acos(abs(l-.1)))+.2));//OR BAD optional push all towards \"1\"\n ;//l=sqrt(l)//Extra optioal gamma slow\n ;//float a=1.-sqrt(p*1.5);l=mix(l*.1,l-a,a);//parametric illumination\n ;//c=oilyUse(l,-q-.33)*l//simple (only 1 variable parameter to rainbor2()\n ;//c=oilyUse(q*.5,p)*l //(p+1.025)\n ;//c=oilyUse(l,p)*l/(p+1.025)//nice dynamic contrast\n ;//c=oilyUse(l*2.,mix(0.,1.2,p))/(p+1.025)//merged mess \n ;//c=oilyUse((abs(m.x)/l/p))*l*p///interestring reciprocals\n ;//c=oilyUse((u.x-.5),l)//experimental, parameter swap kinda works here\n //super contrast disregards hue,good for colorblindness\n ;//c*=1.2//oversaturate\n ;//c+=l*.5;//basic highight dark\n ;//vec3 c2=c*8./(log(l)+.1);//good extreme contrast  \n ;//c= (2.-m.y)*c+(m.y*8.)*sat(c2)//you likely want to mix the above and not 100% the above!\n ;if(abs(u.x-m.x)<.005)c+=.5;//to debug [b] brighter vertical line at \"now\"\n ;//c=pow(c,vec3(3.))//high gamma helps here\n ;c=sat(c)//oten optional, but with all the exponentials this function has, better be safe!\n ;return c;}\n    \n\n//main Fourier Transform DFT loop, generlized by ollj https://www.shadertoy.com/view/MdjXWc   \n//[r] scales an overlapping modulo [roots of unity].\n//... with a circilar complex-plane \"ovetone echo\". \n//... This is the confusing part about Fourier Transformation.\n//.1  circles trough 3 octaves. \n//.7to.5 makes sense for most tracks.\n//.05 circles trough 5 octaves.\n//.03 circles trough 8 octaves. \nvec2 dft(vec2 u,float r,float n//uv,scaleRoots\n){//r=.1//default, can be set by iMouse.y\n ;//n=256.//defent default\n ;n=min(n,iterMaxDFT)//hard limit to avoid unintended crashes or hangups\n ;vec2 c=cs(pi2(floor(u.y*n*.5)/n)),d=vec2(1,0),f=vec2(0)\n ;for(float i=0.;i<n;i++ //resursion of DFT as accumulating loop\n ){float x=i/n//fractal butterfly scaling context\n  //the +u.x is a time offset, that some dft() loops make more explicit.\n  ;vec2 w=sound(x*r+u.x)//dft() ttaps the same sound() function that mainSound( in int samp,) calls.\n  ;f+=d*(w.x+w.y)*.25*(1.-co2p(x))// Hann window-function\n  ;d=d.xy*c.x+vec2(-1,1)*d.yx*c.y;//fourier Butterfly\n ;}return f;}//length() of f is useful\n//you want to do;\n//vec2 f=dft(u,scaleY)\n//;f.x=.5*length(f)\n//;return sat(sqrt(f.x/1./f.x))\n                          \n\nvec2 c2p(vec2 a){return vec2(length(a),atan(a.y,a.x));}\nvec2 p2c(vec2 a){return cs(a.x)*a.y;}\n                          \nvec4 imageB(vec2 u,vec4 m,vec2 r,float t//c for [c]implicity\n){if(m.xy==vec2(0))m=r.xyxy*.5\n ;u/=r.xy\n ;m/=r.xyxy\n ;//u.y*=8.//optionally zoom out .y to highlight the freeze-group of dft()\n ;vec2 v=u\n ;v.x*=.5\n #ifdef TodoDefineLogarythmicTime\n  //i am not sure how to best make \"logarythmic time\" YET\n  //, so this is a playground to find out what i avtually want to do\n  //the final result will likely be a parametcit CDF in leu of an AMP function.\n  //and its low exponential varian will be a lot like my \"lerpsnake\" function\n  //anything that is a bit like a timeline magnifier:\n  //this one kinda sucks, so itts rather \"undefined\"\n ;v.x=1.-v.x\n ;float z=(t-v.x)*2.-1.*t\n    ;z*=t/sqrt(t);\n ;v.x=v.x*(z+t)\n ;v.x=(z*t*.9)/(v.x)\n #else\n #define scrollspeedXZoom 5.//*u5(m.x)       \n ;v.x=floor((u.x+t/scrollspeedXZoom)*iterscaDFT)/iterscaDFT//old\n ;v.x+=.5\n ;v.x=(v.x-1.)*scrollspeedXZoom//old\n #endif\n ;float b=abs(t-v.x)//a NOW-timeline, that gets wider over time\n ;//float d=t/(v.x+t)+.5\n ;//v.x=biject(v.x*t,-t,t,-1.,1.)\n ;//v.x=v.x/(t)\n ;//attempt to prepresent a lot of spacial information in a single list \n ;//by squashing the future preview to the right. past flashes by, zoomed out\n ;//over time, more past memories cramp on the left, as everything seems to zoom out.\n\n ;//v.x+=t+.5\n ;//v.x=((1.-m.y)*32.)/v.x+t\n ;//v.x+=t-m.x*4.+2.\n ;float n=sqrt(abs(m.x-u.x+1.))\n #ifdef showDFT\n ;vec2 f=dft(vec2(v.x,v.y/n),m.y*8./sqrt(iterMaxDFT),iterscaDFT*n)\n ;//f*=ThicknesMultiplier<1.\n ;float l=length(f)\n\n ;b=smoothstep(.1,-.1,b)\n ;vec3 c=oilyDftRainbow(l,u,m)\n #else \n ;float d=sound(t+u.x/44.).x-u.y*6.+1.\n ;d=smoothstep(.01,-.01,abs(d)-.2)\n ;vec3 c=vec3(d,0,0)\n  #endif\n  ;if(u.y>.9)c=vec3(b)//draw  [b]as grey bat on top\n ;vec3 w=VisWaveForm(vec2(u.x,u.y),m.xy,r,t).xyz\n ;c+=w*.5\n //;c=y*.5+hsv2rgb(vec3(y*.49,2./(y+.1),y));//Fourier transform infrared image\n ;return vec4(c, 1.0);}\n\n\n//void mainImage(out vec4 o,vec2 u){o=image(u,iResolution.xy,iTime);}\nvec4 image(vec2 u,vec4 m,vec2 r,float t){\n ;//vec2 p=mod(u,2.)\n ;//return debugEnv(u,r,m)\n ;return imageB(u,m,r,t)\n ;}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//\"audiovisual\" tag means it uses moudular arithmetic (fourier analysis, roots of unity)\n//, or at least some sort of audio-visualization, if only a blinking lights show\n//,to use the same functions to render audio and video\n//all code is in commons tab\n\n\n//void mainImage(out vec4 o,vec2 u){o=image(u,iMouse.xyzw,iResolution.xy,iTime);}\nvec2 mainSound( in int samp,float t){return sound(t);}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}