{
    "Shader": {
        "info": {
            "date": "1629629183",
            "description": "Conformal texture map, based on [url]https://www.shadertoy.com/view/tdGfzz[/url], but computing the R4 torus dimensions from the R3. See code for controls etc..",
            "flags": 48,
            "hasliked": 0,
            "id": "ssc3Dn",
            "likes": 22,
            "name": "Conformal Torus Texture Map II",
            "published": 3,
            "tags": [
                "torus",
                "texture",
                "conformal",
                "quartic",
                "clifford"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 574
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Torus Conformal Texture Map II\n//\n// Controls:\n// <mouse>: change view direction\n// <up/down>: zoom\n// <left/right>, <page up/page down>: change texture proportions\n// 'a': multisampling AA\n// 'b': background\n// 'c': no circles\n// 'r': autorotation\n// 's': no reflections\n// 't': transparency\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat torusr2, torusR2; // R3 torus dimensions\nfloat N = 16.0, M = 17.0; // Subdivisions for xy and zw torus components\n\n// Clifford torus (in R4)\n// The Clifford torus is the intersection of the hypersurface x²+y²=S² with\n// the unit hypersphere x²+y²+z²+w² = 1, so it also satisfies z²+w²=s² where\n//  S²+s² = 1.\n//\n// Stereographic projection to R3 (from eg. (0,0,0,1)) gives a normal R3\n// torus with radii R and r, where S = 1/R and s = r/R, so R = 1/S and\n// r = s/S and R² = r²+1:\n//\n// The projection is equivalent to inversion in a sphere, radius² = 2,\n// centre (0,0,0,-1) so points (S,0,0,-s) and (S,0,0,s) project to \n// (X,0,0) and (Y,0,0) on the x-axis, where X = S/(1-s),0,0) Y = S/(1+s),\n// and (X+Y)/2 = R and (X-Y)/2 = r where R & r are major and minor\n// axes of the R3 torus. Some algebra shows that S = 1/R, s = r/R and\n// we have the requirement that R² = 1+r² to ensure the projection\n// lies on the hypersphere, but the R3 torus can be scaled to R' = tR \n// and r' = tr, for some t to ensure this is true.\n//\n// If we want particular proportions between S and s, with eg.\n// s/S = M/N, so r = M/N, R = (r²+1) are the required dimensions.\n\nbool getcolor(vec3 p3, out vec3 color) {\n  // Find scaling factor.\n  // (1+k²r²)/(k²R²) = 1 ∴ k² = 1/(R²-r²)\n  float k = sqrt(1.0/(torusR2-torusr2)); // Scale factor\n  float R = sqrt(torusR2), r = sqrt(torusr2);\n  R *= k; r *= k; p3 *= k;       // Rescale\n  float S = 1.0/R, s = r/R;      // Clifford torus radii\n\n  // Invert to hyperspace, ie. do an inverse stereographic projection,\n  // equivalent to inverting in sphere, radius² = 2, centre (0,0,0,-1).\n  // This is also the forward projection from R4 to R3.\n  vec4 p = vec4(p3,0);\n  p.w += 1.0; \n  p *= 2.0/dot(p,p);\n  p.w -= 1.0;\n\n  // Find coordinates on R4 torus\n  float phi = atan(p.x,p.y)/(2.0*PI);\n  float theta = atan(p.z,p.w)/(2.0*PI);\n  if (phi < 0.0) phi += 1.0;\n  if (theta < 0.0) theta += 1.0;\n  vec2 uv = vec2(phi,s*theta/S); // Scale by Clifford radii\n  uv *= N; // Subdivide\n  vec2 uv2 = floor(uv);\n  uv -= uv2;\n  uv -= 0.5; // Centre cell\n  float l = length(uv), d = 0.8*fwidth(l);\n  color = h2rgb(hash((int(uv2.x)<<10) + int(uv2.y)));\n  if (key(CHAR_C)) return true;\n  if (key(CHAR_T))return l < 0.45;\n  color = mix(color,vec3(0),smoothstep(-d,d, l-0.4 )); // AA by Fabrice\n  return true;\n}\n\n// R3 torus intersection and normal\nint torus(vec3 p, vec3 r, out vec4 res) {\n  // Parametrization of the torus by phi and theta angles.\n  // x = (R+r*cos(theta))*cos(phi)\n  // y = (R+r*cos(theta))*sin(phi)\n  // z = r*sin(theta)\n    \n  // U*t^2 + V*t + W = 2*r*R*cos(theta)\n  float A,B,C,D,E;\n  if (key(CHAR_X)) {\n    float U = 1.0; //dot(r,r);\n    float V = 2.0*dot(p,r);\n    float W = dot(p,p) - (torusR2+torusr2);\n    \n    // A*t^4 + B*t^3 + C*t^2 + D*t + E = 0\n    A = 1.0; //U*U;\n    B = 2.0*U*V;\n    C = V*V + 2.0*U*W + 4.0*torusR2*r.z*r.z;\n    D = 2.0*V*W + 8.0*torusR2*p.z*r.z;\n    E = W*W + 4.0*torusR2*(p.z*p.z-torusr2);\n  } else {\n    // If we have fixed p so p.r = 0, simplifications are possible\n    float W = dot(p,p) - (torusR2+torusr2);\n    A = 1.0;\n    B = 0.0;\n    C = 2.0*W + 4.0*torusR2*r.z*r.z;\n    D = 8.0*torusR2*p.z*r.z;\n    E = W*W + 4.0*torusR2*(p.z*p.z-torusr2);\n  }\n  int n = quartic(A,B,C,D,E,res);\n  return n;\n}\n\nvec3 torusnormal(vec3 p) {\n  float k = sqrt(torusR2/dot(p.xy,p.xy));\n  p.xy -= k*p.xy;\n  return normalize(p);\n}\n\nint AA = 1;\n\n// Lighting\nvec3 light;\nfloat ambient;\nfloat diffuse;\nfloat specular = 0.4;\nfloat specularpow = 4.0;\nvec3 specularcolor = vec3(1);\n\nvec3 applylighting(vec3 basecolor, vec3 p, vec3 n, vec3 r) {\n  if (dot(r,n) > 0.0) n = -n; // Face forwards\n  vec3 c = basecolor*ambient;\n  c += basecolor*diffuse*(max(0.0,dot(light,n)));\n  float s = pow(max(0.0,dot(reflect(light,n),r)),specularpow);\n  c += specular*s*specularcolor;\n  return c;\n}\n\nstruct Result {\n  vec3 p;\n  vec3 n;\n  vec3 color;\n  float t;\n};\n\nbool solve(vec3 p0, vec3 r, float tmin, inout Result result) {\n  vec4 roots;\n  int nroots = torus(p0,r,roots);\n  if (nroots == 0) return false;\n  // Sort the roots.\n  if (roots.x > roots.y) roots.xy = roots.yx; \n  if (nroots > 2) {\n    if (roots.y > roots.z) roots.yz = roots.zy; \n    if (roots.x > roots.y) roots.xy = roots.yx;\n  }\n  if (nroots > 3) {\n    if (roots.z > roots.w) roots.zw = roots.wz; \n    if (roots.y > roots.z) roots.yz = roots.zy; \n    if (roots.x > roots.y) roots.xy = roots.yx; \n  }\n  for (int i = 0; i < nroots; i++) {\n    float t = roots[i];\n    if (t < tmin) continue;\n    vec3 p = p0 + t*r;\n    vec3 n = torusnormal(p);\n    if (dot(n,r) > 0.0) n = -n;\n    vec3 basecolor;\n    if (getcolor(p, basecolor)) {\n      result.p = p; \n      result.n = n; \n      result.color = applylighting(basecolor,p,n,r);\n      return true;\n    }\n  }\n  return false;\n}\n\nvec3 scene(vec3 p, vec3 r) {\n  vec3 color = vec3(0);\n  float attenuation = 1.0;\n  for (int i = 0; i < 6; i++) {\n    // Solve from closest point to origin.\n    // This makes p.r = 0.\n    float tmin = 0.0;\n    if (!key(CHAR_X)) tmin = -dot(p,r);\n    p += tmin*r;\n    Result res = Result(vec3(0),vec3(0),vec3(0),1e8);\n    if (!solve(p,r,-tmin,res)) break;\n    if (key(CHAR_S)) return res.color;\n    color += attenuation*res.color;\n    attenuation *= 0.5;\n    p = res.p;\n    r = reflect(r,res.n);\n    p += 0.001*r;\n  }\n  if (!key(CHAR_B)) color += attenuation*pow(abs(r),vec3(2));\n  return color;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) {\n    float t = iTime;\n    //t += 3.5;\n    p.yz = rotate(p.yz, 0.1*t);\n    p.zx = rotate(p.zx, 0.222*t);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  if (key(CHAR_A)) AA = 2;\n  // Set torus parameters\n  N += float(keycount(KEY_RIGHT)-keycount(KEY_LEFT));\n  M += float(keycount(KEY_PAGE_DOWN)-keycount(KEY_PAGE_UP));\n  torusr2 = M*M/(N*N);\n  torusR2 = torusr2+1.0;\n  \n  light = vec3(1,1,-1);\n  ambient = 0.4;\n  diffuse = 1.0-ambient;\n  specular = 0.8;\n  specularpow = 10.0;\n\n  float camera = 2.0;\n  camera *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  vec3 p = vec3(0.0, 0.0, -camera);\n  p = transform(p);\n  light = transform(light);\n  light = normalize(light);\n  vec3 color = vec3(0);\n  for (int i = 0; i < AA; i++) {\n     for (int j = 0; j < AA; j++) {\n       vec2 uv = (2.0*(fragCoord.xy+vec2(i,j)/float(AA)) - iResolution.xy)/iResolution.y;\n       vec3 r = vec3(uv, 2.0);\n       r = transform(r);\n       r = normalize(r);\n       color += scene(p,r);\n     }\n  }\n  color /= float(AA*AA);\n  color = pow(color,vec3(0.4545));\n  if (alert) color.r = 1.0;\n  fragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\nvoid mainImage(out vec4 t, vec2 uv) {\n  //setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n#if 0\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        //vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < scale*0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n    } else if (iFrame == 0) {\n      t.xy = initselection(i-1); // Current coordinates\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n#endif\n  }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n// common\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n// Debug\nbool alert = false;\n\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\nbool eq(float x, float y) {\n  return abs(x-y) < 1e-4;\n}\n\nbool eq(vec4 p, vec4 q) {\n  return eq(p.x,q.x) && eq(p.y,q.y) && eq(p.z,q.z) && eq(p.w,q.w);\n}\n\nbool eq(mat4 m, mat4 n) {\n  return eq(m[0],n[0]) && eq(m[1],n[1]) && eq(m[2],n[2]) && eq(m[3],n[3]);\n}\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store((key),0).x))\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_X = 88;\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nfloat evalquadratic(float x, float A, float B, float C) {\n  return (A*x+B)*x+C;\n}\n\nfloat evalcubic(float x, float A, float B, float C, float D) {\n  return ((A*x+B)*x+C)*x+D;\n}\n\nfloat sgn(float x) {\n  return x < 0.0 ? -1.0: 1.0; // Return 1 for x == 0\n}\n\n// Quadratic solver from Kahan\nint quadratic(float A, float B, float C, out vec2 res) {\n  float b = -0.5*B, b2 = b*b;\n  float q = b2 - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    res[0] = C/A;\n    res[1] = -res[0];\n  } else {\n    res[0] = C/r;\n    res[1] = r/A;\n  }\n  return 2;\n}\n\n// Numerical Recipes algorithm for solving cubic equation\nint cubic(float a, float b, float c, float d, out vec3 res) {\n  if (a == 0.0) {\n    return quadratic(b,c,d,res.xy);\n  }\n  if (d == 0.0) {\n    res.x = 0.0;\n    return 1+quadratic(a,b,c,res.yz);\n  }\n  float tmp = a; a = b/tmp; b = c/tmp; c = d/tmp;\n  // solve x^3 + ax^2 + bx + c = 0\n  float Q = (a*a-3.0*b)/9.0;\n  float R = (2.0*a*a*a - 9.0*a*b + 27.0*c)/54.0;\n  float R2 = R*R, Q3 = Q*Q*Q;\n  if (R2 < Q3) {\n    float X = clamp(R/sqrt(Q3),-1.0,1.0);\n    float theta = acos(X);\n    float S = sqrt(Q); // Q must be positive since 0 <= R2 < Q3\n    res[0] = -2.0*S*cos(theta/3.0)-a/3.0;\n    res[1] = -2.0*S*cos((theta+2.0*PI)/3.0)-a/3.0;\n    res[2] = -2.0*S*cos((theta+4.0*PI)/3.0)-a/3.0;\n    return 3;\n  } else {\n    float alpha = -sgn(R)*pow(abs(R)+sqrt(R2-Q3),0.3333);\n    float beta = alpha == 0.0 ? 0.0 : Q/alpha;\n    res[0] = alpha + beta - a/3.0;\n    return 1;\n  }\n}\n\nfloat qcubic(float B, float C, float D) {\n  vec3 roots;\n  int nroots = cubic(1.0,B,C,D,roots);\n  // Select the largest\n  float psi = roots[0];\n  if (nroots > 1) psi = max(psi,roots[1]);\n  if (nroots > 2) psi = max(psi,roots[2]);\n  \n  // Give a quick polish with Newton-Raphson\n  for (int i = 0; i < 2; i++) {\n    float delta = evalcubic(psi,1.0,B,C,D)/evalquadratic(psi,3.0,2.0*B,C);\n    psi -= delta;\n  }\n  return psi;\n}\n\n// The Lanczos quartic method\nint lquartic(float c1, float c2, float c3, float c4, out vec4 res) {\n  float alpha = 0.5*c1;\n  float A = c2-alpha*alpha;\n  float B = c3-alpha*A;\n  float a,b,beta,psi;\n  psi = qcubic(2.0*A-alpha*alpha, A*A+2.0*B*alpha-4.0*c4, -B*B);\n  // There _should_ be a root >= 0, but sometimes the cubic\n  // solver misses it (probably a double root around zero).\n  psi = max(0.0,psi);\n  a = sqrt(psi);\n  beta = 0.5*(A + psi);\n  if (psi <= 0.0) {\n    b = sqrt(max(beta*beta-c4,0.0));\n  } else {\n    b = 0.5*a*(alpha-B/psi);\n  }\n  int resn = quadratic(1.0,alpha+a,beta+b,res.xy);\n  vec2 tmp;\n  if (quadratic(1.0,alpha-a,beta-b,tmp) != 0) { \n    res.zw = res.xy;\n    res.xy = tmp;\n    resn += 2;\n  }\n  return resn;\n}\n\nint quartic(float A, float B, float C, float D, float E, out vec4 roots) {\n  int nroots;\n  // Sometimes it's advantageous to solve for the reciprocal (if there\n  // are very large solutions), but this doesn't seem needed here.\n  if (true) { //abs(B/A) < abs(D/E)) {\n    nroots = lquartic(B/A,C/A,D/A,E/A,roots);\n  } else {\n    nroots = lquartic(D/E,C/E,B/E,A/E,roots);\n    for (int i = 0; i < nroots; i++) {\n      roots[i] = 1.0/roots[i];\n    }\n  }\n  assert(nroots == 0 || nroots == 2 || nroots == 4);\n  return nroots;\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash(int x) {\n  return float(ihash(uint(x)))/pow(2.0,32.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}