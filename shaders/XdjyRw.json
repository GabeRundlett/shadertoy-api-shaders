{
    "Shader": {
        "info": {
            "date": "1491345011",
            "description": "bool Grid(vec2 p){bvec2 a=lessThan(vec2(wi),abs(p));return !(a.x&&a.y);}\n\n== bool variant of one entry of https://www.shadertoy.com/view/MdjyRW \n== sign-modified https://www.shadertoy.com/view/ldScRm",
            "flags": 0,
            "hasliked": 0,
            "id": "XdjyRw",
            "likes": 0,
            "name": "grid.lessThan()",
            "published": 3,
            "tags": [
                "grid",
                "floor",
                "fract",
                "boolean",
                "bool",
                "lessthan",
                "greaterthan",
                "bvec2"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 674
        },
        "renderpass": [
            {
                "code": "//the main point of this is to memorize multidimensional boolean operators\n//for better performance.\n\n//bool Grid() is efficient for grid and cross textures.\n//Found by randomly modifying boolean operators and input signs \n//...of a boolean variant of a BoundingBox of https://www.shadertoy.com/view/ldScRm\n//\n//then realized its equivalency to one entry of https://www.shadertoy.com/view/MdjyRW\n//by someone else, which is neat for; parallel programming and collapsing core symmetry.\n\n//modifiable-const.Start;\nconst float tiles=4.;//number of tiles along .y\n\nconst float wi=.03;//width of grid lines, default uses a dynamic [wd] instead\n//modifiable-const.End;\n\n/*\nbelow functions return a boolean-bounding-box, and not a float-distance:\nThey are more useful for textures than for distance fields.\nAnyways...\nTo utilize this for ditance fields:\nuse this bool function to banch between 2 distance fields.\none distanceField containing \"grid\", eg, dotted lines,\nand one distanceField being =\"infinity\"=1e32;\nthe shortest distance to that then is min()ed against a non-grid-distance-field.\nas in this example:\n//[i] is the point that we alculate a distance to.\nfloat a=Grid(i)?DistancetoDottedLines(i):1e32;\ndistance=min(distanceField(i),a);\n//the purpose of this is to skip the calculations of DistancetoDottedLines(i)\n//which is than more often skipped than not on thinner lines.\n*/\n\n/*\n//unobfuscated, barely changed from source inspiration\nfloat whiteRectangleX(vec2 u){\n    u=abs(u);\n    bvec2 a=lessThan(vec2(wi),u);\n    return 1.-float(a.x&&a.y);\n} //see https://www.shadertoy.com/view/ldScRm\n\n#define r1 wi),abs(u));return 1.-float(a.x&&a.y\nfloat Grid2(vec2 u){bvec2 a=lessThan(vec2(r1          );}\nfloat Grid3(vec3 u){bvec3 a=lessThan(vec3(r1&&a.z     );}\nfloat Grid4(vec4 u){bvec4 a=lessThan(vec4(r1&&a.z&&a.w);}\n//bvec4 a=lessThan(vec4(.01),u);//==//bvec4 a=greaterThan(vec2(.1), uv); \n*/\n//above are float variants of below, returned float is either 1.0 or 0.0;\n\nbool Grid(vec2 p){bvec2 a=lessThan(vec2(wi),abs(p));return !(a.x&&a.y);}\n\n//bool variant:\n//bool Grid (vec2 p        ){bvec2 a=lessThan(vec2(wi),abs(p));return !(a.x&&a.y);}\n//bool variant, [w]==line width\nbool GridW(vec2 p,float w){bvec2 a=lessThan(vec2(w ),abs(p));return !(a.x&&a.y);}\n//3d variant of GridW()\nbool GridV(vec3 p,float w){bvec3 a=lessThan(vec3(w ),abs(p));return !(a.x&&a.y&&a.z);}\n//4d variant of GridW()\nbool GridV(vec4 p,float w){bvec4 a=lessThan(vec4(w ),abs(p));return !(a.x&&a.y&&a.z&&a.w);}\n\nvoid mainImage(out vec4 fragColor,in vec2 i ){\n  //i.transform.Start;\n i=i.xy/iResolution.xy;\n i.x*=iResolution.x/iResolution.y;\n i*=tiles;//scaling to fit [tiles] number of tiles in the viewframe.\n float wd=(sin(iDate.w*9.)*.5+.6)*.3;\n //wd=wi;//overwrite, wd(dynamic line width) with [wi] constant line width.\n i+=wd*.5;//optional: ofset by half [wi]==half lineWidth to have center of lone == tile border.\n i/=sin(iDate.w)*.3+.8;//optional: modify scaling over time\n vec2 d=floor(i);\n i=fract(i);//optional: without this it is not a grid, but a single \"infinite cross\"\n //i.transform.End;\n    \n //vec3 c=vec3(Grid(i));          //constant   line width\n vec3 c=vec3(GridW(i,wd));      //parametric line width\n    \n //c*=vec3(1,0,1);//optional: tint by multiply \n c*=vec3(1.)-vec3(d,0)/tiles;//optional: tint by multiply, color coding tile index\n fragColor = vec4(c,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}