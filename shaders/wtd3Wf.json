{
    "Shader": {
        "info": {
            "date": "1577834786",
            "description": "Molecular dynamics in 3d on a shader lol^3",
            "flags": 32,
            "hasliked": 0,
            "id": "wtd3Wf",
            "likes": 7,
            "name": "Molecular dynamics 3D v1",
            "published": 3,
            "tags": [
                "3d",
                "voronoi",
                "particles",
                "chaos",
                "lorentz"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 461
        },
        "renderpass": [
            {
                "code": "// Fork of \"Lorentz Attractor 3D\" by michael0884. https://shadertoy.com/view/3lt3WX\n// 2019-12-31 20:33:24\n\n// Fork of \"Volumetric shader template\" by michael0884. https://shadertoy.com/view/tlc3Wf\n// 2019-12-30 20:57:24\n\n//#define VOLUMETRIC\n#define FULL_UNION\n#define sphere_rad 1.5\n\nfloat SDF_particle(vec3 p0, vec3 p)\n{\n    particle point = get(ch0, p0);\n    return length(point.pos.xyz - p) - sphere_rad;\n}\n\nvec4 opunion(vec4 a, vec4 b)\n{\n    if(a.w < b.w) return a;\n    else return b;\n}\n\n//distance estimator to the voronoi particle field\nfloat DE(vec3 p)\n{\n\tfloat de = 1e5;\n   \n   \tvec3 p0 =  round(clamp(p, vec3(0), size3d));\n    if(length(p - size3d*0.5) > 0.7*length(size3d)) \n        de = length(p - size3d*0.6);\n    else\n    {\t\n        de = min(de, SDF_particle(p0, p));\n        de = min(de, SDF_particle(p0+vec3(1,0,0), p));\n        de = min(de, SDF_particle(p0+vec3(-1,0,0), p));\n        de = min(de, SDF_particle(p0+vec3(0,1,0), p));\n        de = min(de, SDF_particle(p0+vec3(0,-1,0), p));\n        de = min(de, SDF_particle(p0+vec3(0,0,1), p));\n        de = min(de, SDF_particle(p0+vec3(0,0,-1), p));\n    }\n    \n    if(de < sphere_rad*2.)\n    {\n\t\tde = min(de, SDF_particle(p0+vec3(1,1,0), p));\n        de = min(de, SDF_particle(p0+vec3(-1,-1,0), p));\n        de = min(de, SDF_particle(p0+vec3(0,1,1), p));\n        de = min(de, SDF_particle(p0+vec3(0,-1,-1), p));\n        de = min(de, SDF_particle(p0+vec3(1,0,1), p));\n        de = min(de, SDF_particle(p0+vec3(-1,0,-1), p));\n        //reduces the number of artifacts even further, since it is using all neighboring voxels in a 3*3*3 cube\n        #ifdef FULL_UNION\n            de = min(de, SDF_particle(p0+vec3(1,-1,0), p));\n            de = min(de, SDF_particle(p0+vec3(-1,1,0), p));\n            de = min(de, SDF_particle(p0+vec3(0,-1,1), p));\n            de = min(de, SDF_particle(p0+vec3(0,1,-1), p));\n            de = min(de, SDF_particle(p0+vec3(-1,0,1), p));\n            de = min(de, SDF_particle(p0+vec3(1,0,-1), p));\n            de = min(de, SDF_particle(p0+vec3(1,-1,0), p));\n            de = min(de, SDF_particle(p0+vec3(-1,1,0), p));\n            de = min(de, SDF_particle(p0+vec3(0,1,-1), p));\n            de = min(de, SDF_particle(p0+vec3(0,-1,1), p));\n            de = min(de, SDF_particle(p0+vec3(1,0,-1), p));\n            de = min(de, SDF_particle(p0+vec3(-1,0,1), p));\n            de = min(de, SDF_particle(p0+vec3(1,1,1), p));\n            de = min(de, SDF_particle(p0+vec3(1,1,-1), p));\n            de = min(de, SDF_particle(p0+vec3(1,-1,1), p));\n            de = min(de, SDF_particle(p0+vec3(1,-1,-1), p));\n            de = min(de, SDF_particle(p0+vec3(-1,1,1), p));\n            de = min(de, SDF_particle(p0+vec3(-1,1,-1), p));\n            de = min(de, SDF_particle(p0+vec3(-1,-1,-1), p));\n        #endif\n    }\n    \n    return de;\n}\n\nvec3 particle_color(vec3 p)\n{\n    vec4 a = vec4(1e5);\n    vec3 p0 = round(p);\n    for( int i=-1; i<=1; i++ )\n        for( int j=-1; j<=1; j++ )\n            for( int k=-1; k<=1; k++ )\n    {\n        vec3 dx = vec3(i,j,k);\n        particle thisp = get(ch0, p0+dx);\n        a = opunion(a, vec4(jet_range(thisp.pos.w, -0.1, 1.2), SDF_particle(p0+dx, p)));\n    }\n    return a.xyz;\n}\n\nvec3 COL(vec3 p)\n{\n    if(inside(p))\n    {\n        return particle_color(p)*exp(-0.25*pow(max(DE(p),0.),2.));\n    }\n    else return vec3(0.);\n}\n\n#define MAX_MARCHES 130\n#define DX 1.5\n#define OPACITY 0.2\nvec4 ray_march_vol(vec3 p, vec3 r)\n{\n    vec4 color = vec4(0., 0., 0., 0.);\n    vec4 background = vec4(0.1);\n    for(int i = 0; i < MAX_MARCHES; i++)\n    {\n        vec3 tcolor = COL(p);\n        float density = length(tcolor);\n        float noise  =(1.+0.25*sin(1754.*length(p)+p.x));\n        float d = DX*exp(-2.*min(density,2.))*noise;\n        float opacity = 1.-exp(-OPACITY*density*d);\n        float newa = max(color.w + (1. - color.w)*opacity,0.0001);\n        color.xyz = (color.xyz*color.w + (1.-color.w)*opacity*tcolor)/newa;\n        color.w = newa;\n        if(1. - newa < 0.01) break;\n        p += r*d;\n    }\n    return background + color;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdLineBox(vec3 p, vec3 b, float r)\n{\n    p = abs(p);\n    float cx = sdCapsule(p, b, vec3(b.x,b.y,0), r);\n    float cy = sdCapsule(p, b, vec3(0,b.y, b.z), r);\n    float cz = sdCapsule(p, b, vec3(b.x,0, b.z), r);\n    return min(min(cx, cy),cz);\n}\n\nvec3 sdcolor(vec3 p)\n{\n    vec3 c = vec3(0.);\n    if(inside(0.8*(p-size3d*0.5) + size3d*0.5))\n    {  \n        c = particle_color(p);\n    }\n    else c = vec3(0.1);\n    if(sdLineBox(p - size3d*0.5, size3d*0.5, 0.5) < 1. || p.z < 1.) c = vec3(1.);\n    return c;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat map(vec3 p)\n{\n    float de_partic = DE(p); \n    de_partic = min(de_partic, sdPlane(p, vec4(0,0,1,0)));\n    return min(de_partic, sdLineBox(p - size3d*0.5, size3d*0.5, 0.5));\n}\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*map(p + k.xyy*dx) +\n\t\t\t k.yyxx*map(p + k.yyx*dx) +\n\t\t\t k.yxyx*map(p + k.yxy*dx) +\n\t\t\t k.xxxx*map(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n//usual ray marching stuff\nfloat rayfov;\nvec3 light;\n\n#define shadow_steps 256\n#define MIN_DIST 0.001\n#define MAX_DIST 1000.\nfloat shadow_march(vec4 pos, vec4 dir, float distance2light, float light_angle)\n{\n\tfloat light_visibility = 1.;\n\tfloat ph = 1e5;\n\tfloat dDEdt = 0.;\n\tpos.w = map(pos.xyz);\n\tint i = 0;\n\tfor (; i < shadow_steps; i++) {\n\t\n\t\tdir.w += pos.w;\n\t\tpos.xyz += pos.w*dir.xyz;\n        float noise  =(1.+0.1*sin(1754.*length(pos)+pos.x));\n\t\tpos.w = noise*map(pos.xyz);\n\t\t\n\t\tfloat y = pos.w*pos.w/(2.0*ph);\n        float d = (pos.w+ph)*0.5*(1.-dDEdt);\n\t\tfloat angle = d/(max(MIN_DIST,dir.w-y)*light_angle);\n\t\t\n        light_visibility = min(light_visibility, angle);\n\t\t\n\t\t//minimizing banding even further\n\t\tdDEdt = dDEdt*0.75 + 0.25*(pos.w-ph)/ph;\n\t\t\n\t\tph = pos.w;\n\t\t\n        if(dir.w >= distance2light)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(dir.w > MAX_DIST || pos.w < max(0.5*rayfov*dir.w, MIN_DIST))\n\t\t{\n\t\t\treturn 0.;\n\t\t}\n\t}\n\t\n\tif(i >= shadow_steps)\n\t{\n\t\tlight_visibility=0.;\n\t}\n\t//return light_visibility; //bad\n\tlight_visibility = clamp(2.*light_visibility - 1.,-1.,1.);\n\treturn  0.5 + (light_visibility*sqrt(1.-light_visibility*light_visibility) + asin(light_visibility))/3.14159265; //looks better and is more physically accurate(for a circular light source)\n}\n\nfloat ambient_occlusion(in vec4 pos, in vec4 norm)\n{\t\n\tvec3 pos0 = pos.xyz;\n\t\n\tfloat occlusion_angle = 0.;\n\tvec3 direction = normalize(norm.xyz);\n\t//step out\n\tpos.xyz += 0.1*norm.w*direction;\n\t//march in the direction of the normal\n\tfor(int i = 0; i < 2; i++)\n\t{\n\t\tpos.xyz += pos.w*direction;\n\t\tpos.w = map(pos.xyz);\n\t\t\n\t\tnorm.w = length(pos0 - pos.xyz);\n\t\tocclusion_angle += clamp(pos.w/norm.w,0.,1.);\n\t}\n\t\n\tocclusion_angle /= 2.; // average weighted by importance\n\treturn (0.5-cos(3.14159265*occlusion_angle)*0.5);\n}\n\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float td = 0.;\n    int i;\n    for(i = 0; i < 100; i++)\n    {\n    \tfloat de = map(p);\n        if(de < rayfov*td || td > MAX_DIST)\n        {\n            break;\n        }\n        p += de*r;\n        td += de;\n    }\n    vec3 col =sdcolor(p);\n    vec4 norm = calcNormal(p,MIN_DIST);\n    p += r*(norm.w-rayfov*td);\n    float ao = ambient_occlusion(vec4(p,0.), vec4(norm.xyz, td));\n    float shad = shadow_march(vec4(p+norm.xyz*0.05,0.), vec4(light,0.), 400.,0.03);\n    float ill = max(dot(norm.xyz, light)*(shad  + 0.35*ao*(1. - shad)), 0.0);\n    return vec4(col*ill,1.);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rayfov = FOV/iResolution.x;\n     SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n   \n    vec2 uv = (fragCoord - 0.5*size)/max(size.x, size.y);\n\n    vec2 angles = vec2(2.*PI, PI)*(iMouse.xy/iResolution.xy - 0.5);\n\n    if(iMouse.w < 1.)\n    {\n        angles = vec2(0.2*iTime, 0.3*sin(0.2*iTime)+0.2);\n    }\n    vec3 ray = getRay(angles, uv);\n    vec3 cray = getRay(angles, vec2(0.));\n    light = vec3(0.6,0.50,1.);\n    light.z = max(light.z, 0.9);\n    light = normalize(light);\n    float d = sqrt(dot(vec3(size3d), vec3(size3d)))*0.55;\n    vec3 pos = vec3(size3d)*0.5 - cray*d;\n\n    // Output to screen\n    vec4 t = texel(ch0, fragCoord);\n    vec3 p = dim3from2(fragCoord);\n    #ifdef VOLUMETRIC\n   \t fragColor = 2.*ray_march_vol(pos, ray);\n    #else\n     fragColor = 1.5*ray_march(pos, ray);\n\t#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//definitions\n#define size iResolution.xy\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define pixel(a, p, s) texture(a, p/vec2(s))\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define dt 2.\n\n#define ar vec2(1.35,0.8)\nvec2 SCALE;\nvec3 size3d;\n\nvec2 dim2from3(vec3 p3d)\n{\n    float ny = floor(p3d.z/SCALE.x);\n    float nx = floor(p3d.z) - ny*SCALE.x;\n    return vec2(nx, ny)*vec2(size3d.xy) + p3d.xy;\n}\n\nvec3 dim3from2(vec2 p2d)\n{\n    return vec3(p2d - size3d.xy*floor(p2d/size3d.xy),(floor(p2d.x/size3d.x) + SCALE.x*floor(p2d.y/size3d.y)));\n}\n\nvec4 voxel(sampler2D ch, vec3 p3d)\n{\n    return pixel(ch, dim2from3(p3d), textureSize(ch, 0));\n}\n\n//trilinear interpolation = linear interp between layers\nvec4 trilinear(sampler2D ch, vec3 p3d)\n{\n    return mix(voxel(ch, vec3(p3d.xy, floor(p3d.z))),voxel(ch, vec3(p3d.xy, ceil(p3d.z))), fract(p3d.z));\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nbool inside(vec3 p)\n{\n    if(p.x > 1. && p.y > 1. && p.z > 1. && p.x < float(size3d.x)-1. && p.y < float(size3d.y)-1. && p.z < float(size3d.z)-1.)\n    {\n        return true;\n    }\n    else return false;\n}\n\n#define FOV 2.5\nmat3 getCamera(vec2 angles)\n{\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,   cos(angles.y),  sin(angles.y),\n                          0,  -sin(angles.y),  cos(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),   sin(angles.x), 0.,\n        \t\t       -sin(angles.x),   cos(angles.x), 0.,\n        \t\t        0.,              0.,            1.); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\nfloat minv(vec3 a)\n{\n    return min(min(a.x, a.y),a.z);\n}\n\nfloat maxv(vec3 a)\n{\n    return max(max(a.x, a.y),a.z);\n}\n\nfloat distance2border(vec3 p)\n{\n    vec3 a = vec3(size3d + 1.) - p;\n    return min(minv(p),minv(a));\n}\n\nvec4 border_grad(vec3 p)\n{\n    const float dx = 0.001;\n    const vec3 k = vec3(1,-1,0);\n\treturn  (k.xyyx*distance2border(p + k.xyy*dx) +\n\t\t\t k.yyxx*distance2border(p + k.yyx*dx) +\n\t\t\t k.yxyx*distance2border(p + k.yxy*dx) +\n\t\t\t k.xxxx*distance2border(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n\n//encoding 2 values in one number\nfloat scaleFactor = 65530.0;\nfloat cp = 256.0 * 256.0;\n\n\n/* packs given two floats into one float */\nvec4 enc(vec4 x, vec4 y) {\n    vec4 x1 = floor(x * scaleFactor);\n    vec4 y1 = floor(y * scaleFactor);\n    vec4 f = (y1 * cp) + x1;\n    return f;\n}\n\n/* unpacks given float to two floats */\nvoid dec(in vec4 f, out vec4 x, out vec4 y){\n  vec4 dy = floor(f / cp);\n  vec4 dx = f - (dy * cp);\n  y = (dy / scaleFactor);\n  x = (dx / scaleFactor);\n}\n\nstruct particle\n{\n    vec4 pos;\n    vec4 vel;\n};\n\nparticle get(sampler2D ch, vec3 p)\n{\n    p = clamp(p, vec3(0.), size3d);\n    vec4 data = voxel(ch, p);\n    particle part;\n    dec(data, part.pos, part.vel);\n    part.pos.xyz *= size3d;\n    part.vel *= 10.;\n    return part;\n}\n\nvec4 save(particle a)\n{\n    //scale the numbers to be in a [-1,1] range\n    a.pos.xyz /= size3d;\n    return enc(a.pos, 0.1*a.vel);\n}\n    \nfloat force(float d)\n{\n    d *= 2.3;\n    return -(0.5*exp(-0.5*d) - 3.*exp(-3.*d));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//3d voronoi particle tracking\n\nvoid Check(inout particle U, vec3 pos, vec3 dx)\n{\n    particle neighbor = get(ch0, pos + dx);\n    //check if the stored neighbouring particle is closer to this position \n    if(length(neighbor.pos.xyz - pos) < length(U.pos.xyz - pos))\n    {\n        U = neighbor; //copy the particle info\n    }\n}\n\nvoid CheckRadius(inout particle U, vec3 p, int r)\n{\n    Check(U, p, vec3(-r, 0, 0));\n    Check(U, p, vec3(r, 0, 0));\n    Check(U, p, vec3(0, -r, 0));\n    Check(U, p, vec3(0, r, 0));\n    Check(U, p, vec3(0, 0, -r));\n    Check(U, p, vec3(0, 0, r));\n}\n\n//get the force from a particle in p0 to a particle at p\nvec3 getForce(vec3 p0, vec3 p)\n{\n\tparticle neighbor = get(ch0, p0);\n    vec3 dx = neighbor.pos.xyz - p;\n    //only count if neighbor particle is inside of its cell to exclude repeated forces\n    if(maxv(abs(neighbor.pos.xyz - p0)) <= 0.5)\n        return normalize(dx)*force(length(dx));\n    else\n        return vec3(0.);\n}\n\nvec3 calc_force(vec3 p)\n{\n    vec3 p0 = round(p);\n    vec3 force = vec3(0.);\n    for( int i=-2; i<=2; i++ )\n        for( int j=-2; j<=2; j++ )\n            for( int k=-2; k<=2; k++ )\n    {\n        vec3 dx = vec3(i,j,k);\n        if(dx != vec3(0))\n          force += getForce(p0+dx, p);\n    }\n    \n    return force;\n}\n\n\nvoid mainImage( out vec4 pix, in vec2 pos )\n{\n    SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n    //voxel\n    vec3 p = dim3from2(pos);\n    \n    //this particle\n    particle U;\n    if(iFrame < 1)\n    {\n        if(distance2border(p) > 10.)\n        {\n             U.pos.xyz = vec3(2.*round(p.xyz/2.));\n             U.pos.w = hash13(U.pos.xyz+10.);\n             U.vel.xyz = 0.4*(hash33(U.pos.xyz+0.1)*2. - 1.);\n        }    \n        else\n        {\n            U.pos = vec4(1e5);\n        \tU.vel = vec4(1e5);\n        }\n    }\n    else\n    {\n        //this particle\n        U = get(ch0, p);\n\n        //check neighbours \n        CheckRadius(U, p, 1);\n        CheckRadius(U, p, 2);\n        CheckRadius(U, p, 3);\n        CheckRadius(U, p, 4);\n\n        vec4 border = border_grad(U.pos.xyz);\n\n        U.vel.xyz =  U.vel.xyz*0.6 + dt*(4.*normalize(border.xyz)*exp(-0.4*border.w*border.w)+calc_force(U.pos.xyz)-vec3(0, 0., 0.01));\n        U.pos.xyz += dt*U.vel.xyz;\n \n    }\n    pix = save(U);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}