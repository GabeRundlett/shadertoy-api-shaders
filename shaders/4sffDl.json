{
    "Shader": {
        "info": {
            "date": "1498688176",
            "description": "Playing around with SDF manipulation. \n\nSword is composed of 4 distinct parts: blade, guard, grip, and pommel.",
            "flags": 0,
            "hasliked": 0,
            "id": "4sffDl",
            "likes": 12,
            "name": "Steel Sword",
            "published": 3,
            "tags": [
                "raymarch",
                "sdf",
                "sword"
            ],
            "usePreview": 0,
            "username": "ssell",
            "viewed": 798
        },
        "renderpass": [
            {
                "code": "/**\n * Created by Steven Sell (ssell) / 2017\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * Lighting implementation from https://www.shadertoy.com/view/MsXBzl\n */\n\n#define Epsilon              0.0001\n#define NearClip              Epsilon\n#define FarClip               20.0\n#define IBLSteps              16.0\n\n#define PI                    3.14159\n#define ONE_OVER_PI           0.31831\n#define ONE_OVER_TWO_PI       0.15915\n\n#define MaterialPolishedSteel 1.0\n#define MaterialSteel         2.0\n#define MaterialLeather       3.0\n\n#define EnableAA\n\n#define AssignM(x,y) hit.material = StepValue(sdf, x, y, hit.material); sdf = min(sdf, x)\n#define IsM(x) (hit.material <= x + Epsilon)\n\n//------------------------------------------------------------------------------------------\n// Math Functions\n//------------------------------------------------------------------------------------------\n\n// if(a > b) { return ra; } else { return rb; }\nfloat StepValue(float a, float b, float ra, float rb)\n{\n    return mix(ra, rb, step(a, b));\n}\n\nvec3 StepValue3(float a, float b, vec3 ra, vec3 rb)\n{\n    return mix(ra, rb, step(a, b));\n}\n\nfloat Subtraction(float a, float b)\n{\n    return max(-a, b);\n}\n\nvec3 Translate(in vec3 p, in vec3 v)\n{\n    return (p - v);\n}\n\nvec3 Repeat(in vec3 p, in vec3 s)\n{\n    return (mod(p, s) - (s * 0.5));   \n}\n\nvec3 RotX(in vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return vec3(p.x, (c * p.y) - (s * p.z), (s * p.y) + (c * p.z));\n}\n\nvec3 RotY(in vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return vec3((c * p.x) + (s * p.z), p.y, (-s * p.x) + (c * p.z));\n}\n\n//------------------------------------------------------------------------------------------\n// Ray Structures and Functions\n//------------------------------------------------------------------------------------------\n    \nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n    \nstruct RayHit\n{\n    bool  hit;\n  \tvec3  surfPos;\n    vec3  surfNorm;\n    float material;\n};\n    \n//------------------------------------------------------------------------------------------\n// Camera Structures and Functions\n//------------------------------------------------------------------------------------------\n\nstruct Camera\n{\n    vec3 right;\n    vec3 up;\n    vec3 forward;\n    vec3 origin;\n};\n\nRay Camera_GetRay(in Camera camera, vec2 uv)\n{\n    Ray ray;\n    \n    uv    = (uv * 2.0) - 1.0;\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    ray.origin    = camera.origin;\n    ray.direction = normalize((uv.x * camera.right) + (uv.y * camera.up) + (camera.forward * 2.5));\n\n    return ray;\n}\n\nCamera Camera_LookAt(vec3 origin, vec3 lookAt)\n{\n\tCamera camera;\n    \n    camera.origin  = origin;\n    camera.forward = normalize(lookAt - camera.origin);\n    camera.right   = normalize(cross(camera.forward, vec3(0.0, 1.0, 0.0)));\n    camera.up      = normalize(cross(camera.right, camera.forward));\n    \n    return camera;\n}\n\n//------------------------------------------------------------------------------------------\n// SDF Functions\n//------------------------------------------------------------------------------------------\n\nfloat Box_SDF(in vec3 point, in vec3 bounds)\n{\n \treturn length(max(abs(point) - bounds, 0.0));   \n}\n\nfloat TriPrism0_SDF(in vec3 p, in vec2 e)\n{\n\tvec3 q = abs(p);\n    return max(q.z - e.y, max(q.x * 0.366025 + p.y * 0.5, -p.y) - e.x * 0.5);\n}\n\nfloat TriPrism1_SDF(in vec3 p, in vec2 e)\n{\n\tvec3 q = abs(p);\n    return max(q.z - e.y, max(q.x * 0.366025 - p.y * 0.9, p.y) - e.x * 0.5);\n}\n\nfloat Fuller_SDF(in vec3 p, in vec3 b)\n{\n    // Modified rounded box that gets thinner and shallower as z decreases\n    float zmod = p.z * 0.005;\n    return length(max(abs(p) - vec3(b.x + zmod * 1.5, b.y, b.z), 0.0)) - (0.1 + zmod * 0.75);\n}\n\nfloat Blade_SDF(in vec3 point)\n{\n\tfloat blade = Box_SDF(point, vec3(0.55, 0.025, 6.0));  // Plain old box to carve away\n    float zwave = sin(point.z * 15.0) * 0.005;\n    float edges = min(TriPrism1_SDF(Repeat(point, vec3(1.0, 0.0, 0.0)), vec2(0.175 + zwave * 0.5, 6.1)),                // Edge near guard\n                  min(TriPrism0_SDF(RotY(Translate(point, vec3(1.1, 0.0, 0.0)), 2.95), vec2(0.2 + zwave, 6.1)),         // Point right edge\n                  min(TriPrism0_SDF(RotY(Translate(point, vec3(-1.1, 0.0, 0.0)), -2.95), vec2(0.2 + zwave, 6.1)),       // Point left edge\n                  min(TriPrism1_SDF(RotY(Translate(point, vec3(-0.5, 0.0, -1.0)), 0.025), vec2(0.2 + zwave, 6.1)),      // Mid left edge\n                      TriPrism1_SDF(RotY(Translate(point, vec3(0.5, 0.0, -1.0)), -0.025), vec2(0.2 + zwave, 6.1))))));  // Mid right edge\n    \n    float fuller = Fuller_SDF(Translate(point, vec3(0.0, 0.165, 1.9)), vec3(0.05 + zwave, 0.05, 3.9));  // Groove inset in middle\n    \n    blade = Subtraction(fuller, Subtraction(edges, blade));\n    \n    return blade;\n}\n\nfloat Guard_SDF(in vec3 point)\n{\n    vec3 tpoint = Translate(point, vec3(0.0, 0.025, 5.625));\n    vec3 bounds = vec3(2.9, 0.12, 0.19);\n    \n    float guard = length(max(abs(\n                             vec3(\n                                 tpoint.x,\n                                 tpoint.y,\n                                 tpoint.z - (cos(abs(tpoint.x)) * 0.515))) -   // Note to self: this is the line causing the normal glitch\n                             vec3(\n                                 bounds.x, \n                                 bounds.y - (abs(tpoint.x) * 0.065),      // Guard gets thinner as we go along the width (x)\n                                 bounds.z - sin(abs(tpoint.x)) * 0.125),  // Adjust z-thickness along the width (x) of the guard\n                             0.0));\n    \n    return guard;\n}\n\nfloat Grip_SDF(in vec3 point)\n{\n\tvec3  tpoint = Translate(point, vec3(0.0, 0.025, 7.35));\n    vec3  bounds = vec3(0.125, 0.0005, 1.0);\n    float radius = 0.075;\n    \n    float grip = length(max(abs(\n                            vec3(\n                                tpoint.x, \n                                tpoint.y, \n                                tpoint.z)) - \n                            vec3(\n                                bounds.x - (tpoint.z * 0.045), \n                                bounds.y, \n                                bounds.z) + clamp((cos(tpoint.z * 20.0) * 0.02), 0.0, 1.0), \n                            0.0)) - radius;\n   \n    return grip;\n}\n\nfloat PommelCarve_SDF(in vec3 p, in vec3 c)\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    \n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat Pommel_SDF(in vec3 point)\n{\n    vec3  tpoint = Translate(point, vec3(0.0, 0.025, 8.75));\n    vec3  bounds = vec3(0.08, 0.01, 0.35);\n    float radius = 0.075;\n    \n    float pommel = length(max(abs(\n                            vec3(\n                                tpoint.x, \n                                tpoint.y, \n                                tpoint.z)) - \n                            vec3(\n                                bounds.x,\n                                bounds.y, \n                                bounds.z), \n                            0.0)) - (radius + (sin(tpoint.z) * 0.15));\n    \n    tpoint = Translate(tpoint, vec3(0.0, 0.0, 0.0));\n    tpoint = Repeat(tpoint, vec3(0.75, 0.1, 0.0));\n    tpoint = RotX(tpoint, 1.57);\n    \n    float carve = PommelCarve_SDF(tpoint, vec3(0.8, 0.75, 0.5));\n    \n    pommel = Subtraction(carve, pommel);\n    \n    return pommel;\n}\n\n\nfloat Scene_SDF(vec3 point, inout RayHit hit)\n{\n  \tfloat sdf = FarClip;\n    \n    float blade = Blade_SDF(point);\n    AssignM(blade, MaterialPolishedSteel);\n    \n    float guard = Guard_SDF(point);\n    AssignM(guard, MaterialSteel);\n    \n    float grip = Grip_SDF(point);\n    AssignM(grip, MaterialLeather);\n    \n    float pommel = Pommel_SDF(point);\n    AssignM(pommel, MaterialSteel);\n    \n    return sdf;\n}\n\nvec3 Scene_Normal(vec3 p)\n{\n    RayHit hit;\n    \n    float e = Epsilon;\n    \n\treturn clamp(normalize(vec3(\n        (Scene_SDF(vec3(p.x + e, p.y, p.z), hit) - Scene_SDF(vec3(p.x - e, p.y, p.z), hit)),\n        (Scene_SDF(vec3(p.x, p.y + e, p.z), hit) - Scene_SDF(vec3(p.x, p.y - e, p.z), hit)),\n        (Scene_SDF(vec3(p.x, p.y, p.z + e), hit) - Scene_SDF(vec3(p.x, p.y, p.z - e), hit)))), -1.0, 1.0);\n}\n\n//------------------------------------------------------------------------------------------\n// Light Structures and Functions\n//------------------------------------------------------------------------------------------\n\nvec3 SampleEnvironment(in vec3 r)\n{\n    return texture(iChannel3, r).rgb;\n}\n\nfloat CalcNDF(in vec3 n,in vec3 h, in float r)\n{\n    float a = (r * r);\n    return (a / (PI * pow((pow(dot(n, h), 2.0) * (a - 1.0) + 1.0), 2.0)));\n}\n\nfloat CalcAtten(in vec3 n, in vec3 v, in float k)\n{\n    float d = max(dot(n, v), 0.0);\n \treturn (d / ((d * (1.0 - k)) + k));\n}\n\nfloat CalcAttenAnalytical(in vec3 n, in vec3 l, in vec3 v, in float r)\n{\n    float k = pow((r + 1.0), 2.0) * 0.125;\n    \n    float la = CalcAtten(n, l, k);\n    float va = CalcAtten(n, v, k);\n    \n    return (la * va);\n}\n\nfloat CalcAttenIBL(in float r, in float nol, in float nov)\n{\n    float k = pow(r, 2.0) * 0.5;\n    \n    float la = (nol / ((nol * (1.0 - k)) + k));\n    float va = (nov / ((nov * (1.0 - k)) + k));\n    \n    return (la * va);\n}\n\nvec3 CalcFresnel(in vec3 n, in vec3 v,in vec3 f0)\n{\n\tfloat d = max(dot(n, v), 0.0); \n    float p = ((-5.55473 * d) - 6.98316) * d;\n        \n    return f0 + ((1.0 - f0) * pow(1.0 - d, 5.0));\n}\n\nvec3 CalcDiffuse(in vec3 a)\n{ \n    return (a * ONE_OVER_PI);\n}\n\nvec3 CalcSpecularAnalytical(in vec3 n, in vec3 l, in vec3 v, in vec3 f0, inout vec3 f1, in float r)\n{\n    f1 = CalcFresnel(n, v, f0);\n    return ((f1 * CalcNDF(n, normalize(l + v), r) * CalcAttenAnalytical(n, l, v, r)) / (4.0 * dot(n, l) * dot(n, v)));\n}\n        \nvec2 Hammersley(float i, float n)\n{   \n    uint b = uint(i);\n    \n    b = (b << 16u) | (b >> 16u);\n    b = ((b & 0x55555555u) << 1u) | ((b & 0xAAAAAAAAu) >> 1u);\n    b = ((b & 0x33333333u) << 2u) | ((b & 0xCCCCCCCCu) >> 2u);\n    b = ((b & 0x0F0F0F0Fu) << 4u) | ((b & 0xF0F0F0F0u) >> 4u);\n    b = ((b & 0x00FF00FFu) << 8u) | ((b & 0xFF00FF00u) >> 8u);\n    \n    float r = float(b) * 2.3283064365386963e-10;\n    \n    return vec2((i / n), r);\n} \n\nvec3 ImportanceSample(in vec2 xi, in float r, in vec3 n)\n{\n\tfloat a = (r * r);\n    \n    float phi = 2.0 * PI * xi.x;\n    float cosTheta = sqrt((1.0 - xi.y) / (1.0 + (a * a - 1.0) * xi.y));\n    float sinTheta = sqrt(1.0 - (cosTheta * cosTheta));\n    \n    vec3 H = vec3((sinTheta * cos(phi)), (sinTheta * sin(phi)), cosTheta);\n    \n    vec3 upVector = StepValue3(0.999, n.z, vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    vec3 tangentX = normalize(cross(upVector, n));\n    vec3 tangentY = cross(n, tangentX);\n    \n    return ((tangentX * H.x) + (tangentY * H.y) + (n * H.z));\n}\n\nvec3 CalcSpecularIBL(in vec3 n, in vec3 v, in vec3 f0, inout vec3 f1, in float r)\n{\n    vec3 totalSpec = vec3(0.0);\n    vec3 toSurfaceCenter = reflect(-v, n);\n    \n    for(float i = 0.0; i < IBLSteps; ++i)\n    {\n    \tvec2 xi = Hammersley(i, IBLSteps);\n        vec3 H  = ImportanceSample(xi, r, n);\n        vec3 L  = (2.0 * dot(v, H) * H) - v;\n        \n        float NoV = clamp(dot(n, v), 0.0, 1.0);\n        float NoL = clamp(dot(n, L), 0.0, 1.0);\n        float NoH = clamp(dot(n, H), 0.0, 1.0);\n        float VoH = clamp(dot(v, H), 0.0, 1.0);\n        \n        if(NoL > 0.0)\n        {\n            vec3 color = SampleEnvironment(L);\n            \n            float geoAtten = CalcAttenIBL(r, NoL, NoV);\n            vec3  fresnel  = CalcFresnel(n, v, f0);\n            \n            f1 += fresnel;\n            totalSpec += (color * fresnel * geoAtten * VoH) / (NoH * NoV);\n        }\n    }\n    \n    f1 /= IBLSteps;\n    \n    return (totalSpec / IBLSteps);\n}\n\nvec3 CalculateLightingAnalytical(in vec3 n, in vec3 l, in vec3 v, in vec3 a, in float r, in float m)\n{\n    vec3 f0 = mix(vec3(0.04), a, m);\n    vec3 ks = vec3(0.0);\n    vec3 d  = CalcDiffuse(a);\n    vec3 s  = CalcSpecularAnalytical(n, l, v, f0, ks, r);\n    vec3 kd = (1.0 - ks);\n    \n    return ((kd * d) + s) * clamp(dot(n, l), 0.0, 1.0);\n}\n\nvec3 CalculateLightingIBL(in vec3  n, in vec3  v, in vec3  a, in float r, in float m)\n{\n    vec3 f0 = mix(vec3(0.04), a, m);\n    vec3 ks = vec3(0.0);\n    vec3 d  = CalcDiffuse(a);\n    vec3 s  = CalcSpecularIBL(n, v, f0, ks, r);\n    vec3 kd = (1.0 - ks);\n    \n    return ((kd * d) + s);\n}\n\n//------------------------------------------------------------------------------------------\n// Raymarching\n//------------------------------------------------------------------------------------------\n\nRayHit RaymarchScene(in Ray ray)\n{\n    RayHit hit;\n    \n    hit.hit      = false;\n    hit.material = 0.0;\n    \n    float sdf = FarClip;\n    \n    for(float depth = NearClip; depth < FarClip; )\n    {\n    \tvec3 pos = ray.origin + (ray.direction * depth);\n        \n        sdf = Scene_SDF(pos, hit);\n        \n        if(sdf < Epsilon)\n        {\n            hit.hit      = true;\n            hit.surfPos  = pos;\n            hit.surfNorm = Scene_Normal(pos);\n            \n            return hit;\n        }\n        \n        depth += sdf;\n    }\n    \n    return hit;\n}\n\n//------------------------------------------------------------------------------------------\n// Render\n//------------------------------------------------------------------------------------------\n\nvec4 Material_ApplyPolishedSteel(in RayHit hit, in vec3 toView)\n{\n    vec4 steel     = vec4(0.8, 0.8, 0.8, 0.15);\n    vec4 highlight = vec4(0.9, 0.9, 0.9, 0.20);\n    \n    float ratio = mix(1.0, 0.0, clamp((hit.surfPos.y * 10000.0), 0.0, 1.0));\n    \n    return mix(steel, highlight, ratio);\n}\n\nvec3 Material_ApplySteel(in RayHit hit, in vec3 toView)\n{\n    vec3 base = vec3(0.9517, 0.9902, 0.9068);\n    vec3 tex = vec3(texture(iChannel1, hit.surfPos.xz).r);\n    \n    tex = clamp((tex + 1.0) * 0.5, vec3(0.0), vec3(1.0));\n    \n    return base;\n}\n\nvec3 Material_ApplyLeather(in RayHit hit, in vec3 toView)\n{\n    vec3 base = vec3(0.059, 0.032, 0.024);\n    vec3 tex = texture(iChannel2, hit.surfPos.xz * 3.47).rgb * 1.25;\n    \n    return base;\n}\n\nvec3 Material_Apply(in RayHit hit, vec3 toView)\n{\n    vec3 lightDir = normalize(vec3(0.0, 1.0, -0.65));\n    vec3 albedo = vec3(1.0);\n    \n    float roughness = 1.0;\n    float metallic  = 0.0;\n    \n    if(IsM(MaterialPolishedSteel))\n    {\n        vec4 material = Material_ApplyPolishedSteel(hit, toView);\n        \n        albedo    = material.rgb;\n        roughness = material.a;\n        metallic  = 0.8;\n    }\n    else if(IsM(MaterialSteel))\n    {\n        albedo = Material_ApplySteel(hit, toView);\n        roughness = 0.15;\n        metallic  = 0.7;\n    }\n    else if(IsM(MaterialLeather))\n    {\n        albedo = Material_ApplyLeather(hit, toView);\n        roughness = 0.55;\n        metallic = 0.0;\n    }\n    \n    vec3 direct  = 2.0 * CalculateLightingAnalytical(hit.surfNorm, lightDir, toView, albedo, roughness, metallic);\n    vec3 ambient = 0.5 * CalculateLightingIBL(hit.surfNorm, toView, albedo, roughness, metallic);\n    \n    vec3 color = (direct + ambient);\n    \n    if(IsM(MaterialSteel)) \n    {\n         // Awful, no good, very bad (and hopefully temporary) fix for a normal glitch on the guard\n        color = max(vec3(0.207), color);\n    }\n    \n    return color;\n}\n\nfloat Vignette(in vec2 uv)\n{\n    return 0.2 + (0.8 * pow(32.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.2));\n}\n\nvec3 Background(vec2 uv)\n{\n    return mix(vec3(0.1), vec3(0.3), uv.y) * Vignette(uv);\n}\n\nvec3 Render(vec2 fragCoord, Camera camera, inout bool hit)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    vec3 final = Background(uv);\n    \n    Ray ray = Camera_GetRay(camera, uv);\n    RayHit rayHit = RaymarchScene(ray);\n    \n    if(rayHit.hit)\n    {\n        final.rgb = Material_Apply(rayHit, normalize(camera.origin - rayHit.surfPos));\n    }\n    \n    return final;\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nvec3 OrbitAround(vec3 origin, float radius, float rate)\n{\n  \treturn vec3((origin.x + (radius * cos(iTime * rate))),\n                (origin.y),\n                (origin.z + (radius * sin(iTime * rate))));\n}\n\nconst vec2 AAPoints[4] = vec2[](\n    vec2(-0.1,  0.4),\n    vec2( 0.4,  0.1),\n    vec2( 0.1, -0.4),\n    vec2(-0.4, -0.1));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = OrbitAround(vec3(0.0, 9.0, 2.325), 7.25, 0.2);\n    Camera camera = Camera_LookAt(cameraPos, vec3(0.0, 0.0, 2.325));\n    \n    bool hit = false;\n    \n    fragColor -= fragColor;\n    \n#ifdef EnableAA\n    for(int i = 0; i < 4; ++i)\n    {\n        fragColor.rgb += Render(fragCoord + AAPoints[i], camera, hit);\n    }\n    \n    fragColor.rgb *= 0.25;\n#else\n    fragColor.rgb = Render(fragCoord, camera, hit);\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}