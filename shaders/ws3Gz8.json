{
    "Shader": {
        "info": {
            "date": "1567731756",
            "description": "Click to move. All 2D noise functions. No raymarching.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ws3Gz8",
            "likes": 14,
            "name": "Liquid Orb",
            "published": 3,
            "tags": [
                "noise",
                "orb"
            ],
            "usePreview": 0,
            "username": "BradyInstead",
            "viewed": 1090
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n// from: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat noise1D(float p){\n    float fl = floor(p);\n    float fc = fract(p);\n    return (mix(rand(fl), rand(fl + 1.0), fc)-.5)*2.;\n}\n\n// from: https://github.com/BrianSharpe/Wombat/blob/master/Perlin3D.glsl\nfloat perlin( vec3 P )\n{\n    // establish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi.zzz * ZINC ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi_inc1.zzz * ZINC ) );\n    vec4 hashx0 = fract( Pt * lowz_mod.xxxx );\n    vec4 hashx1 = fract( Pt * highz_mod.xxxx );\n    vec4 hashy0 = fract( Pt * lowz_mod.yyyy );\n    vec4 hashy1 = fract( Pt * highz_mod.yyyy );\n    vec4 hashz0 = fract( Pt * lowz_mod.zzzz );\n    vec4 hashz1 = fract( Pt * highz_mod.zzzz );\n\n    // calculate the gradients\n    vec4 grad_x0 = hashx0 - 0.49999;\n    vec4 grad_y0 = hashy0 - 0.49999;\n    vec4 grad_z0 = hashz0 - 0.49999;\n    vec4 grad_x1 = hashx1 - 0.49999;\n    vec4 grad_y1 = hashy1 - 0.49999;\n    vec4 grad_z1 = hashz1 - 0.49999;\n    vec4 grad_results_0 = inversesqrt( grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x0 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y0 + Pf.zzzz * grad_z0 );\n    vec4 grad_results_1 = inversesqrt( grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x1 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1 );\n\n    // Classic Perlin Interpolation\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    float final = dot( res0, blend2.zxzx * blend2.wwyy );\n    return ( final * 1.1547005383792515290182975610039 );  // scale things to a strict -1.0->1.0 range  *= 1.0/sqrt(0.75)\n}\n\nfloat perlin(vec2 pos, float time)\n{\n    return (perlin(vec3(pos, time))+1.)*.5;\n}\n\nfloat noise(vec2 pos, float dist, float rotation, float time)\n{\n    time *= 1.+dist/100.;\n    pos += vec2(time*rotation, 0.)*.5;\n    pos -= vec2(iMouse.x/iResolution.x, iMouse.y/iResolution.y);\n    return perlin(pos*dist + vec2(dist), time*2.);\n}\n\nvec3 fbm(vec2 pos, float time)\n{\n    vec3 n = vec3(.05);\n\n    pos += perlin(pos*.5, time)*.1;\n    \n    n += noise(pos, 1., .01, time)      * vec3(.25, 1., .5);\n    n += noise(pos, 5., .025, time)*.85 * vec3(.75, 1., 1.);\n    n += noise(pos, 10., .05, time)*.5  * vec3(.25, 1., 1.);\n    n += noise(pos, 20., .1, time)*.25  * vec3(1., 0., .2);\n    n += noise(pos, 75., .15, time)*.1  * vec3(1.,1., 1.);\n    \n    return n;\n}\n\n\nfloat circle(vec2 pos, float radius)\n{\n    return smoothstep(30./iResolution.y, -30./iResolution.y, length(pos)- radius);\n}\n\nfloat highlight(float circle, vec2 pos, float radius)\n{\n    float h = smoothstep(0., radius, length(pos));\n    h -= 1.-circle;\n    return h*(.4+(sin(iTime)+1.)*.1);\n}\n\n// from: https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786\nvec3 hueShift( vec3 color, float hueAdjust ){\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I       = dot (color, kRGBToI);\n    float   Q       = dot (color, kRGBToQ);\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    hue += hueAdjust;\n\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // position\n    vec2 pos = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    \n    // distortions\n    pos.x += noise1D(iTime)*.05;\n    pos.y += noise1D(iTime+10.)*.05;\n    pos += perlin(pos*2., iTime)*.1;\n    pos *= 1.1;\n    \n    // variables\n    float radius = .9 + sin(iTime*4.)*.1;\n    float time = iTime;\n    \n    // fisheye\n    pos *= .5 + pow(length(pos), 10.);\n\n    // forms\n    vec3 noise = fbm(pos, time);\n    vec3 circ = vec3(circle(pos, radius));\n    vec3 hl = vec3(highlight(circ.r, pos, radius));\n    \n    // post processing\n    vec3 res = clamp(circ - noise, vec3(0.), vec3(1.));\n    res.rgb = res.bgr;\n    res *= 2.;\n    res += hl*vec3(1., .2, .5);\n    res = hueShift(res, 5. + sin(iTime));\n    res *= 1.4;\n    \n    // output\n    fragColor = vec4(res, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}