{
    "Shader": {
        "info": {
            "date": "1485817389",
            "description": "Simple Chromatic Aberration and Contrast Loss",
            "flags": 32,
            "hasliked": 0,
            "id": "ltVSDG",
            "likes": 22,
            "name": "80's CRT",
            "published": 3,
            "tags": [
                "chromaticaberration"
            ],
            "usePreview": 0,
            "username": "arda",
            "viewed": 2543
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 O,  vec2 U )\n{\n\tvec2 R = iResolution.xy;\n    float US1 = sin(U.y)/2.+.7;\t\t\t\t\t//Screen Stripes\n    vec3 US2;\n    US2.x = sin(20./iResolution.y*U.y+(-iTime*2.-.4))/10.+.85;\t//R Chromatic Screen Waves\n   \tUS2.y = sin(20./iResolution.y*U.y+(-iTime*2.))/10.+.85;\t\t//G Chromatic Screen Waves\n    US2.z = sin(20./iResolution.y*U.y+(-iTime*2.+.4))/10.+.85;\t//B Chromatic Screen Waves\n    vec3 US = US1 * US2;\t\t\t\t\t\t\t\t\t\t\t\t//Screen Stripes & Screen Waves Combined\n    U =U/R;\n    vec2 UR = U + vec2(.001,0.);\t//Red UV\n    vec2 UG = U + vec2(0.,0.);\t\t//Green UV\n    vec2 UB = U + vec2(-.001,0.);\t//Blue UV\n    vec4 C = texture(iChannel0, U.xy);\n    vec4 CR = texture(iChannel0, UR.xy) * vec4(.8,.1,.1,0.);\t//Red Channel\n    vec4 CG = texture(iChannel0, UG.xy) * vec4(.1,.8,.1,0.);\t//Green Channel\n    vec4 CB = texture(iChannel0, UB.xy) * vec4(.1,.1,.8,0.);\t//BLue Channel\n    vec4 CL = 1.+vec4(vec3(.2),0.);\t\t\t\t//Contrast Loss\n    O = (CR+CB+CG)/CL;\t\t\t\t\t\t//RGB Channels / Contrast Loss * Screen Stripes * Compensation\n\tO *= vec4(US*1.1,0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 O,  vec2 U )\n{\nvec2 R = iResolution.xy;\n\tfloat C = (1.-pow(U.y/R.y,3.));\n    U =5.* (U+U-R) / R.y;         // normalized coordinates\n    U.y = 1.-U.y*2.;                   // swap vertical\n    U /= 1.+U.y/8.;                // perspective\n    U.y -= iTime;\n    vec2 UA = U;\n    vec2 UB = U;\n    U = abs(fract(U)- .50);\t\t\t// distance to axis\n    UA = abs(fract(UA+C/15.)-.50);\n    UB = abs(fract(UB+C/30.)-.50);\n    float gVal = .1;\t\t\t\t\t\t//Glow value\n    U = gVal*C/ sqrt(U);                // turn to blured line\n    UA = gVal*C/ sqrt(UA);\n    UB = gVal*C/ sqrt(UB);\n    O = (U.x+U.y) * vec4(0,0,.8,0)\n        +                 vec4(.22,.20,.20,0) \n        + (UA.x+UA.y)   * vec4(.8,0.,0.,0)\n        + (UB.x+UB.y)   * vec4(0.,.7,0.,0) ; // combine H&V + color * inverted fade\n    O *= C;\n    O = clamp(O,0.,pow(C,1.8));\t\t\t\t//Getting rid of horizontal noise by clamping.\n\tO *= 1.5*O;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}