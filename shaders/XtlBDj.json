{
    "Shader": {
        "info": {
            "date": "1513504214",
            "description": "reproducing [url]http://twistedsifter.com/2017/11/renaissance-portraits-made-from-single-thread-on-circular-loom/[/url]\nWait long enough: ~2-5 mn\nYou can go fullscreen and back *after* the target is chosen.\ntry -7. bufC:5 for more precision (slower).\n",
            "flags": 32,
            "hasliked": 0,
            "id": "XtlBDj",
            "likes": 10,
            "name": "threads portrait (wait...)",
            "published": 3,
            "tags": [
                "lines",
                "art",
                "reproduction",
                "gpmipmap"
            ],
            "usePreview": 1,
            "username": "FabriceNeyret2",
            "viewed": 2948
        },
        "renderpass": [
            {
                "code": "// === Reproduce an image with a single thread wired between pins around a disk ( cf http://twistedsifter.com/2017/11/renaissance-portraits-made-from-single-thread-on-circular-loom ).\n//     Start with random wiring, then swap one thread pin passage at random,\n//     kept only if it decrease globlal image difference (evaluated using ultimate MIPmap level)\n//        Another implementation from code to physical object: https://eheitzresearch.wordpress.com/implementation-and-realization-of-petros-vrellis-knitting/\n\n#define INVERSE                                              // uncomment for white BG\n\n#define T(i) ( texelFetch(iChannel2, ivec2(U*3.+R*vec2(.17,-i)), 0) / 6. )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2  R = iResolution.xy;\n    O = texelFetch(iChannel0, ivec2(U), 0) * R.y/6e2;        // array of threads\n#if 1                                                        // display info\n    O += T(2).r;                                             // ref image\n    O += T(1).g;                                             // blured reproduction\n    O += sqrt(T(0).b);                                       // error image\n    O.r += texelFetch(iChannel3, ivec2(U), 0).z;             // error curve\n#endif\n\n    #ifdef INVERSE\n    O = 1.-O; \n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// === manage the wiring in the array of threads\n\n#define N   4000. // 600. 4000.        // number of nodes ( = a loop of pin indices )\n#define pin  200. //  50.  200.        // number of pins around the circle\n\n#define rnd(p)  fract( 3758.5453 * sin( 1.+ dot( p, vec2(12.9898, -78.233))) )\n#define rndN(p) floor( N * rnd(p) )    // a random node\n#define rndP(p) 6.283/pin * floor( pin * rnd(p) ) // a random pin position\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U -= .5;\n    vec2 R = iResolution.xy;\n    const float W = floor(sqrt(N));\n    float i = U.x + W*U.y, i0,n; \n    if (U.x>= W || i >= N) {           // nodes encoded in the bottom-left ~square W x (N/W)\n        if ( iFrame < 600 && iChannelTime[2] < 3.86 ) {  // --- capture a frame of Britney\n            O = texture( iChannel2, 1.2*U/iResolution.xy); \n            O = vec4(1.7*O.r-O.g);\n            if (U==vec2(W,0)) O.zw = R;\n        }                              // if resize, resample the target image\n        else O.xy = texture(iChannel0,(U+.5)/R*texelFetch(iChannel0,ivec2(W,0),0).zw/R).ww,\n             O.zw = texelFetch( iChannel0,ivec2(U), 0).zw; \n        return;\n    }\n    \n    if (iFrame==0) {                   // --- choose inital random location for nodes\n        O = vec4(rndP(U), 0,0, rnd(U+.5)*.5*6.283/pin ); // NB: only N = W x (N/W) are used \n        return;                        // O.w = random offset of each pin\n    }   \n    O = texelFetch(iChannel0, ivec2(U), 0);\n    if ( U==vec2(0) && iTime > 10. && iChannelTime[2] > 3.86 ) O.w = 1.; // grab done. go !\n    \n    i0 = rndN(vec2(N, iFrame));        // --- propose to change location for a node at random \n    n  = rndP(vec2(N+1., iFrame));     // proposed new random location\n    if ( i0 != texelFetch(iChannel0,ivec2(0),0).z ) { // don't try twice the same node\n        if (i == i0) O.y = O.x, O.x = n;   // replace, keep prev in zw\n        if ( U==vec2(0) ) O.z = i0;        // request for draw update\n    } \n    else if ( U==vec2(0) ) O.z = -1.;\n                                       // --- treat evaluation of previous proposal\n    if (   textureLod(iChannel1, U/R, 100.).z    // distance to target image\n         > texelFetch(iChannel1,ivec2(0),0).z )  // previous distance\n       {                                         // the change increased the distance: cancel\n        i0 = texelFetch(iChannel0,ivec2(0),0).z; // recover the changed node\n        if (i == i0) O.yx = O.xy;      // swap draw/undraw target\n        if ( U==vec2(1) ) O.z = i0;    // request for new draw update to restore   \n       }\n    else if( U==vec2(1) ) O.z = -1.;   // no restore requested\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// === draws (if resol change) or updates the array of threads\n\n#define N     4000  // 600 4000\n#define pin    200. //  50  200.       \n#define I       .1  //   .4   .1                        // threads intensity\n//#define CS(a)   vec2( cos(a), sin(a) )                // positions around the circle\n#define CS(a)   sin( a + node(int(a*pin/6.283+1e-3)).w + vec2(1.571,0) ) // with jittering\n        //  variant: a + rnd(a)*.5*6.283/pin and no storing of node.w \n#define node(i) texelFetch(iChannel0, ivec2( (i)%W, (i)/W ), 0)  // access threads data\nvec2 R; int W;\n                                                        // --- draw a segment between 2 pins\n#define draw(p0,p1) I* clamp(1.-.5*R.y*segment( U, CS(p0), CS(p1) ) , 0., 1. )\n                    // clamp(1.-.25*R.y*segment( U, CS(p0), CS(p1) ) , 0., 1. )\nfloat segment(vec2 u, vec2 a, vec2 b)  {         \n    b -= a, u -= a;\n    return length( u - b * clamp(dot(b, u) / dot(b, b), 0., 1.));\n}\n\nfloat redraw(vec2 U, int r) {                           // --- treat a node position change \n    int i = int( texelFetch(iChannel0,ivec2(r), 0).z ), // ivec2(r).z contains node id\n        p = (i-1+N) % N, n = (i+1) % N;                 // prev, next to i\n\tif (i<0) return 0.;                                 // no change request\n    float ap = node(p).x, an = node(n).x,               // pos of prev and next nodes\n          ai = node(i).x, ao = node(i).y;               // new and old pos of node\n    return    draw( ap, ai ) + draw( ai, an )           // draw new 2 connection to i\n            - draw( ap, ao ) - draw( ao, an );          // undraw prev 2 connection to i\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    R = iResolution.xy;\n    W = int(sqrt(float(N)));\n    vec2 U = ( u+u - R ) / R.y;\n    \n    if ( texelFetch(iChannel1, ivec2(0), 0).xy != R ) { // --- redraw array of threads\n        O -= O;                                         // if frame=0 or resolution change\n        for (int i=0; i<N; i++)\n            O += draw( node(i).x, node((i+1)%N).x );\n        if (u==vec2(.5)) O.xy = R;                      // to check resolution change\n    }\n    else O = texelFetch(iChannel1, ivec2(u), 0);        // no redraw needed\n\n    if (iFrame==0) return;\n    O += redraw(U,0);                                   // --- treat node change request\n    O += redraw(U,1);                                   // --- treat node restore request\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// === prepare comparison to target image via quadratic distance (read in ultimate MIPmap)\n\n#define SOURCE iChannel3 // 3: Britney 2: pebbles (change also T below)\n#define INVERSE                                                // uncomment for white BG\n#define lod(T)   ceil(log2(T.y)) - 6.                          // blur level for analyze\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          T = iChannelResolution[3].xy,  // to update with #SOURCE \n          U = u/R;\n    \n    O.w = textureLod( SOURCE ,  U, lod(T)).x;                  // --- target image\n#ifdef INVERSE\n    O.w = 1.-O.w;\n#endif\n    O.w *= step(length( (u+u-R)/R.y ),1.);                     // clamp by disk\n\tO.x = O.w / textureLod(iChannel1, U, 100.).w;              // normalize\n    O.y =   textureLod(iChannel0, U, lod(R)).x                 // --- blurred thread array\n\t      / textureLod(iChannel0, U, 100.).x;                  // normalize\n\n    if (u==vec2(.5)) {                                         // --- quadratic difference\n        O.xy = R;\n        O.z =  texelFetch(iChannel1, ivec2(0), 0).xy != R      // if resolution change\n            || texelFetch(iChannel3, ivec2(0), 0).w !=1.       // or 'go' ( was iFrame==0 )\n              ? 1e5                                            //   reset energy\n              : min ( texelFetch(iChannel1, ivec2(0), 0).z,\n                      textureLod(iChannel1, U, 100.).z );      // best previous distance\n    } else {\n        O.z = O.x -  O.y;   O.z *= O.z;                        // quadratic difference\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// === curve of convergence statistics\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    O = U.x==.5 + .5*R.x+.5*R.y                                   // plot new value\n        ? vec4( step( abs( U.y - textureLod(iChannel1, U/R, 100.) *.2 *R.y ) , vec4(1) ) )\n        : texelFetch(iChannel0,ivec2(U)-ivec2(1,0), 0);           // scroll\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}