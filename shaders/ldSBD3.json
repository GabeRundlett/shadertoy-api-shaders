{
    "Shader": {
        "info": {
            "date": "1502422006",
            "description": "Endless zooming yin yangs with some values tweaked to make the dots larger. I think this one kind of looks like a face.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldSBD3",
            "likes": 32,
            "name": "Infinite Yin Yangs 2",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "fractal",
                "zoom",
                "recursion"
            ],
            "usePreview": 0,
            "username": "KilledByAPixel",
            "viewed": 6778
        },
        "renderpass": [
            {
                "code": "//////////////////////////////////////////////////////////////////////////////////\n// Infinite Yin Yang Zoom - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= -0.4;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.08;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst float saturation\t\t\t= 0.4;\t// how much to scale saturation (0 == black and white)\nconst float turnSpeed\t\t\t= 0.7;\t// how fast to rotate (0 = no rotation)\nconst int   recursionCount\t\t= 10;\t// how deep to recurse\nconst float dotSize \t\t\t= 0.6;\t// how much to scale recursion at each step\nconst float blur\t\t\t\t= 5.0;\t// how much blur\nconst float outline\t\t\t\t= 0.12;\t// how thick is the outline\nconst float timeWarp\t\t\t= 1.0;\t// time warp to add curvature\n\n//////////////////////////////////////////////////////////////////////////////////\n    \nconst float pi = 3.14159265359;\nconst float e = 2.718281828459;\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nvec2 Rotate(vec2 p, float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return vec2((p.x*c - p.y*s), (p.x*s + p.y*c));\n}\nvec4 HsvToRgb(vec4 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec4(s_n) + vec4(s) * cos(2.0 * pi * (c.x + vec4(1.0, 0.6666, .3333, 1.0)));\n}\n\nfloat GetFocusRotation(int i) \n{ \n    float theta = 2.0*pi*RandFloat(i);\n    float s = mix(-1.0, 1.0, RandFloat(30+i));\n    //s += ((s < 0.0)? -.5 : 0.5);\n    return theta + turnSpeed*s*iTime; \n}\n\nvec2 GetFocusPos(int i) \n{ \n    bool side = (RandFloat(50+i) < 0.5);\n    vec2 p = vec2(0.0, side? -0.5 : 0.5); \n    return Rotate(p, GetFocusRotation(i));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nfloat YinYang2( vec2 p, out float dotDistance, float co, float scale)\n{\n   \tfloat b = blur*scale/min(iResolution.y, iResolution.x);\n    float d = dotSize;\n    \n    float c = 1.0;\n    float r;\n    \n    // bottom\n    r = length(2.0*p + vec2(0, 1));\n    if (p.x < 0.0)\n\t   c = mix(c, 0.0, smoothstep(1.0-b, 1.0+b, r));\n    dotDistance = r;\n    \n    // top\n    r = length(2.0*p - vec2(0, 1));\n    if (p.x >= 0.0)\n\t\tc = mix(0.0, c, smoothstep(1.0-b, 1.0+b, r));\n    if (p.y >= 0.0)\n         dotDistance = r;\n    \n    // outline\n    r = length(p);\n    c = mix(c, co, smoothstep(1.0-b, 1.0, r));\n    \n    return c;\n}\n\nvec4 RecursiveYinYang(vec2 p, int iterations, float scale)\n{\n    // recursive iteration\n    float co = 0.0;\n    for (int r = 0; r < recursionCount; ++r)\n    {\n        // apply rotation\n  \t\tfloat theta = -GetFocusRotation(iterations + r);\n        p = Rotate(p, theta);\n        \n        float dotDistance = 0.0;\n        co = YinYang2(p, dotDistance, co, scale);\n        \n        if (dotDistance > dotSize || r == recursionCount)\n        {\n            float co2 = (p.y < 0.0)? 0.0 : 1.0;\n   \t\t\tfloat b = blur*scale/min(iResolution.y,iResolution.x);\n            \n            co = mix(co2, co, smoothstep(dotSize+outline,dotSize+outline+b,dotDistance));\n            int i2 = (dotDistance < dotSize+outline+b && p.y > 0.0)? 1 : 0;\n            float hue = 0.233*float(iterations + r + i2);\n            return vec4(hue, saturation*co, co, 1.0); // stop if outside or reached limit\n        }\n     \t\n\t\t// check if top or bottom\n        co = (p.y > 0.0)? 1.0 : 0.0;\n        p.y += mix(0.5, -0.5, co);\n        \n        scale *= 2.0/dotSize;\n        p *= 2.0/dotSize;\t\t// apply recursion scale\n        p = Rotate(p, -theta);\t// cancel out rotation\n    }\n    return vec4(0);\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 color, in vec2 uv )\n{\n    // fixed aspect ratio\n\tvec2 p = (2.0*uv-iResolution.xy)/min(iResolution.y,iResolution.x);\n    vec2 p2 = p;\n    \n    // wander center\n\tp.x += 0.5*sin(0.234*iTime);\n\tp.y += 0.5*sin(0.2*iTime);\n    \n    // time warp\n    float time = iTime + timeWarp*length(p);\n    \n\t// get time \n\tfloat timePercent = time*zoomSpeed;\n\tint iterations = int(floor(timePercent));\n\ttimePercent -= float(iterations);\n    \n\t// update zoom, apply pow to make rate constant\n    const float recursionSize = 2.0 / dotSize;\n\tfloat zoom = pow(e, -log(recursionSize)*timePercent);\n\tzoom *= zoomScale;\n    \n\t// get focus offset\n\tvec2 offset = GetFocusPos(iterations);\n\tfor (int i = 0; i < 10; ++i)\n\t\toffset += (GetFocusPos(iterations+i+1) / recursionSize) * pow(1.0 / recursionSize, float(i));\n    \n    // apply zoom and offset\n\tp = p*zoom + offset;\n    \n    // make the yin yang\n    color = RecursiveYinYang(p, iterations, zoom);\n    \n    // wander hue\n    color.x += (0.1*p2.y + 0.1*p2.x + 0.05*time);\n    \n    // map to rgp space\n    color = HsvToRgb(color);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}