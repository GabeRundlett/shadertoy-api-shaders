{
    "Shader": {
        "info": {
            "date": "1658990579",
            "description": "\"BezierExtrude\" by Del:\n[url]https://www.shadertoy.com/view/7dyBz3[/url]\n",
            "flags": 48,
            "hasliked": 0,
            "id": "fsyfDt",
            "likes": 35,
            "name": "BLF Repetition on BezierExtrude",
            "published": 3,
            "tags": [
                "bezier",
                "repetition",
                "extrude",
                "maptoy"
            ],
            "usePreview": 1,
            "username": "iY0Yi",
            "viewed": 472
        },
        "renderpass": [
            {
                "code": "#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define UI_ISOLINE 0\n\n#define VIEW_QUAD 1\n\n#define DBG_MATCAP 0\n#define DBG_NORMAL 0\n#define DBG_COST 0\n\n#define CAM_SCALE 3.\n#define TURN_TABLE 0\n#define TURN_TABLE_SPEED .5\n\n// 1D version of iq's limited repetition\n// https://www.shadertoy.com/view/3syGzz\nfloat opRepLim( in float p, in float s, in float lima, in float limb ){\n    return p-s*clamp(round(p/s),lima,limb);\n}\n\n// \"BezierExtrude\" by Del:\n// https://www.shadertoy.com/view/7dyBz3\n// --------------------------------------------------------------------\n// returns xyz = position, w = spline position (t)\nvec4 sdBezierExtrude(vec3 pos, vec3 A, vec3 B, vec3 C)\n{    \n    // check for colinear\n    //if (abs(dot(normalize(B - A), normalize(C - B)) - 1.0) < 0.0001)\n    //    return sdLinearSegment(pos, A, C);\n\n\t// first, calc curve T value\n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\tfloat t;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        t = uv.x+uv.y-kx;\n        // 1 root\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 tt = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n\t\t// 3 roots, but only need two\n\t\tvec3 r1 = d + (c + b * tt.x) * tt.x;\n\t\tvec3 r2 = d + (c + b * tt.y) * tt.y;\n\t\t//t = length(r2.xyz) < length(r1.xyz) ? tt.y : tt.x;\n        t = dot(r2,r2) < dot(r1,r1) ? tt.y : tt.x; // quicker\n        \n    }\n    // now we have t, calculate splineposition and orient to spline tangent\n    t = clamp(t,0.,1.); // clamp spline start/end\n    vec3 ttan = normalize((2.0 - 2.0 * t) * (B - A) + 2.0 * t * (C - B));  // spline tangent\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 binormal = normalize(cross(up, ttan));\n    vec3 _normal = cross(ttan, binormal);\n//\tvec3 t1 = normalize(cross(_normal, ttan));\n\tvec3 t1 = cross(_normal, ttan); // no need to normalize this?\n\tmat3 mm = mat3(t1, cross(ttan, t1), ttan);\n    vec3 tp = mix(mix(A, B, t), mix(B, C, t), t);\n    pos.xyz = tp - pos; // spline position\n    pos *= mm;\n    \n    return vec4(pos, t);\n}\n\n// iq\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat map( in vec3 pos )\n{\n    vec3 a = vec3(sin(iTime*.5)*-3.,cos(iTime*.5)*3.,0);\n    vec3 b = vec3(0.0,sin(iTime*.5)*3.,sin(iTime*4.)*2.0);\n    vec3 c = vec3(sin(iTime*.5)*3.,cos(iTime*.5)*3.,0);\n    vec4 bz = sdBezierExtrude(pos,a,b,c);\n    \n    // here\n    float l = floor(fract(iTime*.25)*30.);\n    float s = .5;\n    vec3 bzr = bz.xyz;\n    bzr.z -= (bz.w-.5)*l;\n    bzr.z = opRepLim(bzr.z, s, -l, l) * ((bzr.z<-l*.5 || bzr.z>l*.5) ? 1. : s);\n    //\n    \n    float rad = .1-.05*abs(sin(iTime*.25));\n    float st = bz.w;//smoothstep(.5, .1, abs(bz.w-.5))+.5;\n    float h = .6*st+.2;//(cos(bz.w*TAU*4.)+.5)*.2+.8 - .6*st;\n    float d = sdBox(bzr.xyz, vec3(h,rad*3.,rad));\n    d = min(sdBox(bzr.xyz, vec3(rad*3.,h,rad)),d);\n    \n    //d = min(length(bz.xyz)-.15*st,d);\n    \n    d = min(length(pos-a)-.15,d);\n    d = min(length(pos-b)-.15,d);\n    d = min(length(pos-c)-.15,d);\n    return d*.8;\n}\nrender();\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//   __  __    __    ____  ____  _____  _  _ \n//  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n//   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n//  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n//\n//  Version: 1.0.5\n//\n//  This is a \"Maptoy\" template.\n//  I wanted an editor dedicated to distance functions, so I created it in Shadertoy.\n//  You can bookmark this page, fork, and edit it.\n//  I've tried to keep everything but the map functions in the Common tab.\n//\n//  Update:\n//\n//  1.0.5 @ 2022/09/14    \n//        - Fixed long compilation in Quad view.\n//\n//  1.0.4 @ 2021/11/03    \n//        - Added Isoline draw.\n//\n//  1.0.3 @ 2021/10/22    \n//        - Added Matcap debug mode.\n//\n//  1.0.2 @ 2021/10/20    \n//        - Added Quad view mode.\n//\n//  1.0.1 @ 2021/10/15    \n//        - Added Axis draw.\n//        - Added Hotkeys for Camera View angle.\n//         ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n//\n//  1.0.0 @ 2021/10/14   \n//        - Released.\n//\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define THM_BACKGROUND (vec3(0.071,0.071,0.071)*.8)\n#define THM_GRID vec3(0.078,0.078,0.078)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(0.820,0.820,0.820)\n#define THM_MATCAP_TYPE 1\n// Matcaps 0:CURVATURE/1:METAL/2:RED_WAX\n\n#define DIST_MIN .001\n#define DIST_MAX 10.\n#define STEP_MAX 100\n#define INIT_CAM_POS vec3(0,0,2)\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist)\n    {\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc col+= char(U,64+CAPS+c).rgb;\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(1,0)\n#define C_MOUSE_VEC vec2(2,0)\n#define C_MOUSE_POS vec2(3,0)\n#define CAM_DIST 6.\n#define render() \\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nvec4 char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) /* thighly y-clamped to allow dense text*/\\\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\\\n    return vec4(0);\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1e5) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=0; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=0; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5))\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && bool(TURN_TABLE))\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED), -1, cos(iTime*TURN_TABLE_SPEED))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n        if(length(mou.xyz)<=.0)pos=INIT_CAM_POS;\\\n    }\\\n    vec3 cw = normalize(-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= CAM_SCALE/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = -pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(-2,2,-2);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(bool(DBG_NORMAL))col = (n*.5+.5)*.5;\\\n        if(bool(DBG_MATCAP)){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(THM_MATCAP_TYPE == 0){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 1){\\\n                float corrosion = clamp(-curvature * 8.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 3.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.047,0.067,0.094);\\\n                vec3 diffuse = mix(mix(vec3(0.259,0.380,0.290), vec3(0.431,0.549,0.549), corrosion),\\\n                vec3(0.761,0.655,0.439), shine) - ambient;\\\n                vec3 specular = mix(vec3(0), vec3(1) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 2){\\\n                float dirt = clamp(0.15 - curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.251,0.082,0.008);\\\n                vec3 diffuse = mix(vec3(0.565,0.224,0.078), vec3(0.996,0.843,0.843), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.3) - ambient, vec3(0.0), dirt);\\\n                float shininess = 16.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz);\\\n    if(iMouse.z<.5 && (fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx+gy+gz)*.333;\\\n    if(bool(DBG_COST))\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, THM_GRID, g);\\\n    if(bool(UI_ISOLINE)) {\\\n        vec4 n;\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(axisX>0. && (bool(UI_ISOLINE) || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(axisY>0. && (bool(UI_ISOLINE) || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(axisZ>0. && (bool(UI_ISOLINE) || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    caps C(_c) low C(_a)C(_m)C(_e)C(_r)C(_a) caps C(-6) spc\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e)}\\\n    col = mix(col, pow(vec3(.8),vec3(.4545)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    if(bool(VIEW_QUAD)){\\\n        vec3 Res = vec3(iResolution.xy, 0);\\\n        forceView = vec2(1,1);\\\n        vec2 offset;\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,1);offset=Res.zz;}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(1,7);offset=Res.zy;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,3);offset=Res.xz;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);offset=Res.xy;}\\\n        fragColor = vec4(renderRect(fragCoord*2.-offset),1);\\\n        if((fragCoord.x>Res.x*.5-1. && fragCoord.x<Res.x*.5+1.) || (fragCoord.y>Res.y*.5-1. && fragCoord.y<Res.y*.5+1.))fragColor = vec4(pow(THM_GRID,vec3(.4545)),1);\\\n    }else{\\\n        fragColor = vec4(renderRect(fragCoord),1);\\\n    }\\\n}int dummy\\\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// User Inputs\n\n// References:\n// \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n// \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n// \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n// \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n// Shows how to use the mouse input (only left button supported):\n//\n//      mouse.xy  = mouse position during last button down\n//  abs(mouse.zw) = mouse position during last button click\n// sign(mouze.z)  = button is down\n// sign(mouze.w)  = button is clicked\n\nconst int K_NUMP_0 = 96;\nconst int K_NUMP_1 = 97;\nconst int K_NUMP_2 = 98;\nconst int K_NUMP_3 = 99;\nconst int K_NUMP_4 = 100;\nconst int K_NUMP_5 = 101;\nconst int K_NUMP_6 = 102;\nconst int K_NUMP_7 = 103;\nconst int K_NUMP_8 = 104;\nconst int K_NUMP_9 = 105;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 2 ) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec2 C = fragCoord;\n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){\n    \n        // Mouse\n        if(sign(iMouse.z)>.0)\n            fragColor = iMouse;\n        else\n            fragColor = last;\n        return;\n        \n    }\n    else\n    if(ID(C_CAMERA)){\n    \n        // Numpad\n        fragColor = last;\n        bool isFreeCamera = bool(last.y);\n        \n        if(getKeypress(K_NUMP_0) && sign(iMouse.z)<=.0)fragColor = vec4(0, 0, 0, 0);\n        \n        //if(getState(K_NUMP_0))fragColor = vec4(0, true, 0, 0);\n        if(getState(K_NUMP_1))fragColor = vec4(1, true, 0, 0);\n        //if(getState(K_NUMP_2))fragColor = vec4(2, true, 0, 0);\n        if(getState(K_NUMP_3))fragColor = vec4(3, true, 0, 0);\n        //if(getState(K_NUMP_4))fragColor = vec4(4, true, 0, 0);\n        //if(getState(K_NUMP_6))fragColor = vec4(6, true, 0, 0);\n        if(getState(K_NUMP_7))fragColor = vec4(7, true, 0, 0);\n        //if(getState(K_NUMP_8))fragColor = vec4(8, true, 0, 0);\n        //if(getState(K_NUMP_9))fragColor = vec4(9, true, 0, 0);\n        return;\n        \n    }\n    else\n    {\n        // Blank\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}