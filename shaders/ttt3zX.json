{
    "Shader": {
        "info": {
            "date": "1577107396",
            "description": "Alien engine, based upon: https://www.shadertoy.com/view/4ds3zn",
            "flags": 0,
            "hasliked": 0,
            "id": "ttt3zX",
            "likes": 13,
            "name": "Alien engine",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 572
        },
        "renderpass": [
            {
                "code": "// Alien engine\n// Based upon: https://www.shadertoy.com/view/4ds3zn\n\n#define PI         3.141592654\n#define TAU        (2.0*PI) \n#define TOLERANCE  0.0003\n#define REPS       11\n#define MAX_DIST   20.\n#define MAX_ITER   120\n\nconst vec3  green  = vec3(1.5, 2.0, 1.0);\nconst vec3  dark   = vec3(0.2);\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvoid r45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\nfloat apollian(vec3 p, float tolerance, out int layer) {\n  const float s = 1.9;\n  float scale = 1.0;\n\n  float r = 0.2;\n  vec3 o = vec3(0.22, 0.0, 0.0);\n\n  float d = 0.0;\n\n  for(int i = 0; i < REPS; ++i) {\n    p = (-1.00 + 2.0*fract(0.5*p+0.5));\n//    rot(p.xz, -float(i)*PI/4.0);\n    r45(p.xz);\n\n    float r2 = dot(p,p) + 0.0;\n    float k = s/r2;\n    float ss = pow((1.0 + float(i)), -0.15);\n    p *= pow(k, ss);\n    scale *= pow(k, -ss*ss);\n    d = 0.25*abs(p.y)*scale;\n    layer = i;\n    if(abs(d) < tolerance) break;\n  }\n  \n  return d;\n}\n\nfloat df(vec3 p, float tolerance, out int layer) { \n  float d = apollian(p, tolerance, layer);\n  return d;\n} \n\n\nfloat intersect(vec3 ro, vec3 rd, out int iter, out int layer) {\n  float res;\n  float t = 1.6;\n  iter = MAX_ITER;\n    \n  for(int i = 0; i < MAX_ITER; ++i) {\n    vec3 p = ro + rd * t;\n    float tolerance = TOLERANCE * t;\n    res = df(p, tolerance, layer);\n    if(res < tolerance || res > MAX_DIST) {\n      iter = i;\n      break;\n    }\n    t += res;\n  }\n    \n  if(res > MAX_DIST) t = -1.;\n    \n  return t;\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n  float stepSize = 0.012;\n  float t = stepSize;\n\n  float oc = 0.0;\n  \n  int layer;\n\n  for(int i = 0; i < 12; i++) {\n    float tolerance = TOLERANCE * t;\n    float d = df(p + n * t, tolerance, layer);\n    oc += t - d;\n    t += stepSize;\n  }\n\n  return clamp(oc, 0.0, 1.0);\n}\n\nvec3 normal(in vec3 pos) {\n  vec3 eps = vec3(.001,0.0,0.0);\n  vec3 nor;\n  int layer;\n  float tolerance = TOLERANCE * eps.x;\n  nor.x = df(pos+eps.xyy, tolerance, layer) - df(pos-eps.xyy, tolerance, layer);\n  nor.y = df(pos+eps.yxy, tolerance, layer) - df(pos-eps.yxy, tolerance, layer);\n  nor.z = df(pos+eps.yyx, tolerance, layer) - df(pos-eps.yyx, tolerance, layer);\n  return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )  { \n  vec2 q=fragCoord.xy/iResolution.xy; \n  vec2 uv = -1.0 + 2.0*q; \n  uv.x*=iResolution.x/iResolution.y; \n    \n  vec3 la = vec3(0.0,0.5,0.0); \n  vec3 ro = vec3(2.5, 1.5, 0.0);\n  rot(ro.xz, iTime/40.0);\n\n  vec3 cf = normalize(la-ro); \n  vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n  vec3 cu = normalize(cross(cs,cf)); \n  vec3 rd = normalize(uv.x*cs + uv.y*cu + 3.0*cf);\n\n  vec3 bg = mix(dark*0.25, dark*0.5, smoothstep(-1.0, 1.0, uv.y));\n  vec3 col = bg;\n\n  vec3 p=ro; \n\n  int iter = 0;\n  int layer = 0;\n  \n  float t = intersect(ro, rd, iter, layer);\n    \n  if(t > -1.0) {\n    p = ro + t * rd;\n    vec3 n = normal(p);\n    float fake = float(iter)/float(MAX_ITER);\n    float fakeAmb = exp(-fake*fake*4.0);\n    float amb = ambientOcclusion(p, n);\n    \n\n    vec3 dif;\n\n    float ll = length(p);\n\n    if (layer == 0)\n    {\n      dif = 0.75*green;\n    } else {\n      dif = green*pow((1.0 + 0.5*cos(-PI*2.0*float(layer)/float(REPS) + iTime*0.25 - 0.5*PI*ll)), 4.0)/pow(float(layer), 1.5);\n    }\n\n\n    const float fogPeriod = TAU*2.0;\n    float fogHeight = 0.25 + 0.325*(abs(p.y) + 0.125*(sin(fogPeriod*p.x) * cos(fogPeriod*p.z)));\n    float dfog = (fogHeight - ro.y)/rd.y;\n    float fogDepth = t > dfog && dfog > 0.0 ? t - dfog : 0.0;\n    float fogFactor = exp(-fogDepth*4.0);\n\n    col = dif;\n    col *= vec3(mix(1.0, 0.125, pow(amb, 3.0)))*vec3(fakeAmb);\n    col = mix(green*0.5, col, fogFactor); \n    col = mix(bg, col, exp(-0.0125*t*t)); \n  } \n\n  float pp = 1.0 - (1.0 - step(0.5, q.y))*smoothstep(0.85, 1.3, length(2.0*q-1.0));\n  \n    \n  col *= pp;\n    \n\n  fragColor=vec4(col.x,col.y,col.z,1.0); \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}