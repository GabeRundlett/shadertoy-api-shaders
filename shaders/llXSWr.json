{
    "Shader": {
        "info": {
            "date": "1435769209",
            "description": "My first shadertoy production! :D (updated)\n2015, 30th AMIGA Anniversary. \nThis shader represent  the Amiga Juggler , a raytracing animation created by Eric Graham in 1986/87.\nmore info on www.ereticus.com\n@pellicus",
            "flags": 0,
            "hasliked": 0,
            "id": "llXSWr",
            "likes": 51,
            "name": "AMIGA's 30th The Juggler",
            "published": 3,
            "tags": [
                "raytracing",
                "sphere",
                "amiga",
                "juggler",
                "mirror",
                "humanoid"
            ],
            "usePreview": 1,
            "username": "pellicus",
            "viewed": 7327
        },
        "renderpass": [
            {
                "code": "\n// My AMIGA's 30th anniversary contribution.\n\n// started from iq primitives.\n// switched to a pure raytracing approach\n// added the text title borrowing code from https://www.shadertoy.com/view/Mt2GWD\n//\n// This is my first shadertoy.com production :D\n// so veeery far to be considered a well written and optimized code :D.\n// Heavly inspired from http://meatfighter.com/juggler/ and totally rebuilt on GLSL.\n\n// This is the Amiga Juggler , a raytracing animation by Eric Graham 86/87 ... yes,\n// 28 years ago!. I think this is one of the most inspiring piece\n// of digital art made on Amiga after all :D.\n// I desired to see it in real time since I've seen it\n// on my Amiga, tons of years ago, It was provided as a playback of a precalculated movie.\n\n// I'll try to post a little more about this shader on my new blog next days\n//  www.ereticus.com\n// a site where I , @pellicus, will rant some heresies ;) and ideas about graphic stuff, shaders,\n// raytracing and alternative rendering techs, engine3ds, unity plugins, and stuff like\n// that looking at videogames\n// and multimedia productions perspective.\n\n// Thanks you all for watching. :D\n// Genoa (Italy), 1 july 2015\n// Dario Pelella (@pellicus or dario.pelella on FB)\n\n\n// ===============================================================\n// VECTOR TEXT TITLE  ============================================\n// ===============================================================\nvec2 g_pen;\nvec4 g_out_color;\n\nvoid tris(vec2 a, vec2 c,vec2 b)\n{\n    vec2 pa = g_pen-a;\n    bool si = (b.x-a.x)*pa.y-(b.y-a.y)*pa.x > 0.0;\n    vec2 ca= c-a;\n    if ((ca.x)*pa.y-(ca.y)*pa.x > 0.0 == si) return;\n    vec2 cb=c-b;\n    if (cb.x*(g_pen.y-b.y)-cb.y*(g_pen.x-b.x) > 0.0 != si) return;\n    g_out_color = vec4(1,1,1,1);\n}\n\nvoid vector_text()\n{\n    vec2 uv=g_pen;\n    \n    \n    vec2 off= abs(uv-vec2(0.125000,0.125000)) - vec2(0.125000); if( off.x <= 0.0 || off.y <=  0.0)\n    { tris(vec2(0.207,0.005),vec2(0.210,0.010),vec2(0.133,0.006));tris(vec2(0.090,0.005),vec2(0.095,0.012),vec2(0.005,0.005));tris(vec2(0.095,0.012),vec2(0.000,0.011),vec2(0.005,0.005));tris(vec2(0.210,0.010),vec2(0.129,0.012),vec2(0.133,0.006));tris(vec2(0.095,0.012),vec2(0.002,0.016),vec2(0.000,0.011));tris(vec2(0.210,0.010),vec2(0.205,0.017),vec2(0.129,0.012));tris(vec2(0.095,0.012),vec2(0.090,0.017),vec2(0.002,0.016));tris(vec2(0.205,0.017),vec2(0.136,0.018),vec2(0.129,0.012));tris(vec2(0.205,0.017),vec2(0.196,0.019),vec2(0.136,0.018));\n        tris(vec2(0.090,0.017),vec2(0.078,0.020),vec2(0.002,0.016));tris(vec2(0.196,0.019),vec2(0.148,0.021),vec2(0.136,0.018));tris(vec2(0.196,0.019),vec2(0.181,0.026),vec2(0.148,0.021));tris(vec2(0.078,0.020),vec2(0.021,0.026),vec2(0.002,0.016));tris(vec2(0.181,0.026),vec2(0.155,0.029),vec2(0.148,0.021));tris(vec2(0.078,0.020),vec2(0.071,0.035),vec2(0.021,0.026));tris(vec2(0.071,0.035),vec2(0.072,0.072),vec2(0.021,0.026));tris(vec2(0.072,0.072),vec2(0.072,0.086),vec2(0.021,0.026));tris(vec2(0.131,0.072),vec2(0.072,0.086),vec2(0.072,0.072));\n        tris(vec2(0.122,0.086),vec2(0.131,0.072),vec2(0.075,0.154));tris(vec2(0.131,0.072),vec2(0.122,0.086),vec2(0.072,0.086));tris(vec2(0.072,0.086),vec2(0.075,0.154),vec2(0.021,0.026));tris(vec2(0.181,0.026),vec2(0.131,0.072),vec2(0.155,0.029));tris(vec2(0.054,0.205),vec2(0.131,0.072),vec2(0.181,0.026));tris(vec2(0.075,0.154),vec2(0.032,0.203),vec2(0.021,0.026));tris(vec2(0.131,0.072),vec2(0.054,0.205),vec2(0.075,0.154));tris(vec2(0.075,0.154),vec2(0.054,0.205),vec2(0.032,0.203));tris(vec2(0.054,0.205),vec2(0.042,0.209),vec2(0.032,0.203));\n        tris(vec2(0.287,0.000),vec2(0.230,0.008),vec2(0.258,0.002));tris(vec2(0.287,0.000),vec2(0.333,0.008),vec2(0.230,0.008));tris(vec2(0.275,0.089),vec2(0.272,0.094),vec2(0.173,0.094));tris(vec2(0.275,0.089),vec2(0.173,0.094),vec2(0.171,0.090));tris(vec2(0.275,0.089),vec2(0.171,0.090),vec2(0.177,0.083));tris(vec2(0.269,0.083),vec2(0.275,0.089),vec2(0.177,0.083));tris(vec2(0.258,0.081),vec2(0.269,0.083),vec2(0.177,0.083));tris(vec2(0.258,0.081),vec2(0.177,0.083),vec2(0.190,0.080));tris(vec2(0.252,0.071),vec2(0.258,0.081),vec2(0.190,0.080));\n        tris(vec2(0.252,0.071),vec2(0.190,0.080),vec2(0.202,0.061));tris(vec2(0.268,0.018),vec2(0.252,0.071),vec2(0.202,0.061));tris(vec2(0.268,0.018),vec2(0.202,0.061),vec2(0.215,0.016));tris(vec2(0.268,0.018),vec2(0.215,0.016),vec2(0.230,0.008));tris(vec2(0.295,0.017),vec2(0.268,0.018),vec2(0.230,0.008));tris(vec2(0.295,0.017),vec2(0.230,0.008),vec2(0.333,0.008));tris(vec2(0.196,0.156),vec2(0.181,0.158),vec2(0.189,0.153));tris(vec2(0.196,0.156),vec2(0.197,0.170),vec2(0.181,0.158));tris(vec2(0.197,0.170),vec2(0.175,0.175),vec2(0.181,0.158));\n        tris(vec2(0.197,0.170),vec2(0.198,0.189),vec2(0.175,0.175));tris(vec2(0.198,0.189),vec2(0.168,0.196),vec2(0.175,0.175));tris(vec2(0.287,0.191),vec2(0.212,0.193),vec2(0.258,0.181));tris(vec2(0.212,0.193),vec2(0.168,0.196),vec2(0.198,0.189));tris(vec2(0.287,0.191),vec2(0.168,0.196),vec2(0.212,0.193));tris(vec2(0.287,0.191),vec2(0.178,0.203),vec2(0.168,0.196));tris(vec2(0.287,0.191),vec2(0.208,0.207),vec2(0.178,0.203));\n    }\n    if(g_out_color.a>0.0)return;\n    off= abs(uv-vec2(0.375000,0.125000)) - vec2(0.125000); if( off.x <= 0.0 || off.y <=  0.0)\n    { tris(vec2(0.287,0.000),vec2(0.230,0.008),vec2(0.258,0.002));tris(vec2(0.287,0.000),vec2(0.333,0.008),vec2(0.230,0.008));\n        tris(vec2(0.275,0.089),vec2(0.272,0.094),vec2(0.173,0.094));tris(vec2(0.275,0.089),vec2(0.173,0.094),vec2(0.171,0.090));tris(vec2(0.275,0.089),vec2(0.171,0.090),vec2(0.177,0.083));tris(vec2(0.269,0.083),vec2(0.275,0.089),vec2(0.177,0.083));tris(vec2(0.258,0.081),vec2(0.269,0.083),vec2(0.177,0.083));tris(vec2(0.258,0.081),vec2(0.177,0.083),vec2(0.190,0.080));tris(vec2(0.252,0.071),vec2(0.258,0.081),vec2(0.190,0.080));tris(vec2(0.252,0.071),vec2(0.190,0.080),vec2(0.202,0.061));tris(vec2(0.268,0.018),vec2(0.252,0.071),vec2(0.202,0.061));\n        tris(vec2(0.268,0.018),vec2(0.202,0.061),vec2(0.215,0.016));tris(vec2(0.268,0.018),vec2(0.215,0.016),vec2(0.230,0.008));tris(vec2(0.295,0.017),vec2(0.268,0.018),vec2(0.230,0.008));tris(vec2(0.295,0.017),vec2(0.230,0.008),vec2(0.333,0.008));tris(vec2(0.333,0.008),vec2(0.319,0.030),vec2(0.295,0.017));tris(vec2(0.333,0.008),vec2(0.370,0.034),vec2(0.319,0.030));tris(vec2(0.370,0.034),vec2(0.332,0.071),vec2(0.319,0.030));tris(vec2(0.370,0.034),vec2(0.386,0.077),vec2(0.332,0.071));tris(vec2(0.386,0.077),vec2(0.322,0.116),vec2(0.332,0.071));\n        tris(vec2(0.386,0.077),vec2(0.356,0.148),vec2(0.322,0.116));tris(vec2(0.356,0.148),vec2(0.297,0.154),vec2(0.322,0.116));tris(vec2(0.356,0.148),vec2(0.258,0.181),vec2(0.297,0.154));tris(vec2(0.356,0.148),vec2(0.287,0.191),vec2(0.258,0.181));tris(vec2(0.287,0.191),vec2(0.212,0.193),vec2(0.258,0.181));tris(vec2(0.287,0.191),vec2(0.168,0.196),vec2(0.212,0.193));tris(vec2(0.287,0.191),vec2(0.178,0.203),vec2(0.168,0.196));tris(vec2(0.287,0.191),vec2(0.208,0.207),vec2(0.178,0.203));tris(vec2(0.510,0.005),vec2(0.512,0.010),vec2(0.415,0.006));\n        tris(vec2(0.512,0.010),vec2(0.409,0.012),vec2(0.415,0.006));tris(vec2(0.512,0.010),vec2(0.506,0.016),vec2(0.409,0.012));tris(vec2(0.506,0.016),vec2(0.414,0.018),vec2(0.409,0.012));tris(vec2(0.506,0.016),vec2(0.496,0.019),vec2(0.414,0.018));tris(vec2(0.496,0.019),vec2(0.425,0.019),vec2(0.414,0.018));tris(vec2(0.496,0.019),vec2(0.484,0.027),vec2(0.425,0.019));tris(vec2(0.484,0.027),vec2(0.431,0.029),vec2(0.425,0.019));tris(vec2(0.484,0.027),vec2(0.439,0.183),vec2(0.431,0.029));tris(vec2(0.439,0.183),vec2(0.387,0.182),vec2(0.431,0.029));\n        tris(vec2(0.439,0.183),vec2(0.451,0.188),vec2(0.387,0.182));tris(vec2(0.451,0.188),vec2(0.370,0.190),vec2(0.387,0.182));tris(vec2(0.451,0.188),vec2(0.460,0.194),vec2(0.370,0.190));tris(vec2(0.460,0.194),vec2(0.362,0.195),vec2(0.370,0.190));tris(vec2(0.460,0.194),vec2(0.452,0.202),vec2(0.362,0.195));tris(vec2(0.452,0.202),vec2(0.368,0.202),vec2(0.362,0.195));tris(vec2(0.556,0.200),vec2(0.487,0.200),vec2(0.489,0.193));tris(vec2(0.510,0.183),vec2(0.556,0.200),vec2(0.489,0.193));\n    }\n    if(g_out_color.a>0.0)return;\n    off= abs(uv-vec2(0.625000,0.125000)) - vec2(0.125000); if( off.x <= 0.0 || off.y <=  0.0)\n    { tris(vec2(0.510,0.005),vec2(0.512,0.010),vec2(0.415,0.006));\n        tris(vec2(0.512,0.010),vec2(0.409,0.012),vec2(0.415,0.006));tris(vec2(0.512,0.010),vec2(0.506,0.016),vec2(0.409,0.012));tris(vec2(0.506,0.016),vec2(0.414,0.018),vec2(0.409,0.012));tris(vec2(0.506,0.016),vec2(0.496,0.019),vec2(0.414,0.018));tris(vec2(0.686,0.011),vec2(0.666,0.012),vec2(0.678,0.007));tris(vec2(0.626,0.006),vec2(0.628,0.011),vec2(0.531,0.006));tris(vec2(0.782,0.007),vec2(0.784,0.011),vec2(0.711,0.006));tris(vec2(0.628,0.011),vec2(0.527,0.011),vec2(0.531,0.006));tris(vec2(0.784,0.011),vec2(0.708,0.012),vec2(0.711,0.006));\n        tris(vec2(0.784,0.011),vec2(0.781,0.017),vec2(0.708,0.012));tris(vec2(0.628,0.011),vec2(0.533,0.018),vec2(0.527,0.011));tris(vec2(0.628,0.011),vec2(0.622,0.018),vec2(0.533,0.018));tris(vec2(0.781,0.017),vec2(0.714,0.018),vec2(0.708,0.012));tris(vec2(0.622,0.018),vec2(0.611,0.019),vec2(0.533,0.018));tris(vec2(0.611,0.019),vec2(0.543,0.020),vec2(0.533,0.018));tris(vec2(0.781,0.017),vec2(0.727,0.020),vec2(0.714,0.018));tris(vec2(0.686,0.011),vec2(0.688,0.021),vec2(0.666,0.012));tris(vec2(0.781,0.017),vec2(0.758,0.026),vec2(0.727,0.020));\n        tris(vec2(0.611,0.019),vec2(0.600,0.029),vec2(0.543,0.020));tris(vec2(0.600,0.029),vec2(0.548,0.030),vec2(0.543,0.020));tris(vec2(0.758,0.026),vec2(0.734,0.032),vec2(0.727,0.020));tris(vec2(0.758,0.026),vec2(0.691,0.160),vec2(0.734,0.032));tris(vec2(0.600,0.029),vec2(0.565,0.161),vec2(0.548,0.030));tris(vec2(0.565,0.161),vec2(0.510,0.183),vec2(0.548,0.030));tris(vec2(0.556,0.200),vec2(0.487,0.200),vec2(0.489,0.193));tris(vec2(0.510,0.183),vec2(0.556,0.200),vec2(0.489,0.193));tris(vec2(0.565,0.161),vec2(0.556,0.200),vec2(0.510,0.183));\n        tris(vec2(0.640,0.073),vec2(0.556,0.200),vec2(0.565,0.161));tris(vec2(0.640,0.073),vec2(0.565,0.161),vec2(0.666,0.012));tris(vec2(0.688,0.021),vec2(0.640,0.073),vec2(0.666,0.012));tris(vec2(0.688,0.021),vec2(0.691,0.160),vec2(0.640,0.073));tris(vec2(0.758,0.026),vec2(0.700,0.182),vec2(0.691,0.160));tris(vec2(0.691,0.160),vec2(0.644,0.199),vec2(0.640,0.073));tris(vec2(0.700,0.182),vec2(0.644,0.199),vec2(0.691,0.160));tris(vec2(0.700,0.182),vec2(0.723,0.196),vec2(0.644,0.199));tris(vec2(0.723,0.196),vec2(0.719,0.202),vec2(0.644,0.199));\n        \n    }\n    if(g_out_color.a>0.0)return;\n    off= abs(uv-vec2(0.875000,0.125000)) - vec2(0.125000); if( off.x <= 0.0 || off.y <=  0.0)\n    { tris(vec2(0.782,0.007),vec2(0.784,0.011),vec2(0.711,0.006));tris(vec2(0.784,0.011),vec2(0.708,0.012),vec2(0.711,0.006));tris(vec2(0.784,0.011),vec2(0.781,0.017),vec2(0.708,0.012));tris(vec2(0.781,0.017),vec2(0.714,0.018),vec2(0.708,0.012));tris(vec2(0.781,0.017),vec2(0.727,0.020),vec2(0.714,0.018));tris(vec2(0.781,0.017),vec2(0.758,0.026),vec2(0.727,0.020));tris(vec2(0.758,0.026),vec2(0.734,0.032),vec2(0.727,0.020));tris(vec2(0.758,0.026),vec2(0.691,0.160),vec2(0.734,0.032));tris(vec2(0.758,0.026),vec2(0.700,0.182),vec2(0.691,0.160));\n        tris(vec2(0.998,0.006),vec2(1.000,0.010),vec2(0.923,0.007));tris(vec2(0.881,0.005),vec2(0.886,0.012),vec2(0.796,0.005));tris(vec2(0.886,0.012),vec2(0.790,0.012),vec2(0.796,0.005));tris(vec2(1.000,0.010),vec2(0.920,0.012),vec2(0.923,0.007));tris(vec2(0.886,0.012),vec2(0.793,0.016),vec2(0.790,0.012));tris(vec2(1.000,0.010),vec2(0.995,0.017),vec2(0.920,0.012));tris(vec2(0.886,0.012),vec2(0.881,0.018),vec2(0.793,0.016));tris(vec2(0.995,0.017),vec2(0.926,0.018),vec2(0.920,0.012));tris(vec2(0.995,0.017),vec2(0.986,0.019),vec2(0.926,0.018));\n        tris(vec2(0.881,0.018),vec2(0.868,0.020),vec2(0.793,0.016));tris(vec2(0.986,0.019),vec2(0.939,0.021),vec2(0.926,0.018));tris(vec2(0.986,0.019),vec2(0.972,0.026),vec2(0.939,0.021));tris(vec2(0.868,0.020),vec2(0.811,0.027),vec2(0.793,0.016));tris(vec2(0.972,0.026),vec2(0.945,0.030),vec2(0.939,0.021));tris(vec2(0.868,0.020),vec2(0.861,0.035),vec2(0.811,0.027));tris(vec2(0.861,0.035),vec2(0.863,0.073),vec2(0.811,0.027));tris(vec2(0.972,0.026),vec2(0.922,0.073),vec2(0.945,0.030));tris(vec2(0.863,0.073),vec2(0.863,0.086),vec2(0.811,0.027));\n        tris(vec2(0.922,0.073),vec2(0.863,0.086),vec2(0.863,0.073));tris(vec2(0.922,0.073),vec2(0.912,0.086),vec2(0.863,0.086));tris(vec2(0.972,0.026),vec2(0.912,0.086),vec2(0.922,0.073));tris(vec2(0.863,0.086),vec2(0.865,0.154),vec2(0.811,0.027));tris(vec2(0.972,0.026),vec2(0.865,0.154),vec2(0.912,0.086));tris(vec2(0.865,0.154),vec2(0.822,0.204),vec2(0.811,0.027));tris(vec2(0.972,0.026),vec2(0.844,0.205),vec2(0.865,0.154));tris(vec2(0.865,0.154),vec2(0.844,0.205),vec2(0.822,0.204));tris(vec2(0.844,0.205),vec2(0.833,0.209),vec2(0.822,0.204));\n        \n    }\n    \n}\n#define PI 3.1415926536\n\nconst vec2 res = vec2(640.0,400.0);\nconst mat3 mRot = mat3(0.9553, -0.2955, 0.0, 0.2955, 0.9553, 0.0, 0.0, 0.0, 1.0);\nconst vec3 ro = vec3(0.0,0.0,-4.0);\n\nconst vec3 cRed = vec3(1.0,0.0,0.0);\nconst vec3 cWhite = vec3(1.0);\nconst vec3 cGrey = vec3(0.66);\nconst vec3 cPurple = vec3(0.51,0.29,0.51);\n\nconst float maxx = 0.378;\n\nvoid mainVectorText( inout vec4 fragColor, in vec2 fragCoord )\n{   g_pen = fragCoord.xy/iResolution.xy;\n    float asp = iResolution.y/iResolution.x;\n    vec2 uvR = floor(g_pen*res);\n    g_pen*=vec2(1.2,1.2*asp);\n    g_pen.x = 0.195+(1.0-g_pen.x);\n    g_out_color = vec4(1,1,1.0,0.0);\n    \n    //  if(distance(g_pen,vec2(1,1))<0.01)g_out_color =vec4(1,0,0,1.0);\n    \n    vector_text();\n    fragColor.rgb =mix(fragColor.rgb,g_out_color.rgb,g_out_color.a);\n    \n    \n    \n    \n    vec2 uv = uvR/res + vec2(-0.046,-0.13);\n    \n    vec3 rd = normalize(vec3((uv)*vec2(2.0,2.0*asp),1.0));\n    \n    float b = dot(rd,ro);\n    float t1 = b*b-15.0;\n    float t = -b-sqrt(t1);\n    vec3 nor = normalize(ro+rd*t)*mRot;\n    vec2 tuv = floor(vec2(atan(nor.x,nor.z)/PI+((floor((iTime)*60.0)/60.0)*0.5),acos(nor.y)/PI)*8.0);\n    fragColor = vec4(mix(fragColor.rgb,mix(cRed,cWhite,clamp(mod(tuv.x+tuv.y,2.0),0.0,1.0)),1.0-step(t1,0.0)),1.0);\n    \n    \n    \n    \n}\n\n\n\n//#######################################################################\n//#######################################################################\n//#######################################################################\n\n#define PRECISION_STEP 0.001\n//----------------------------------------------------------------------\n\n// Inspired by http://meatfighter.com/juggler/\n// I used some values and snippets here and there\n\n#define Math_PI 3.1415926\n\n\n// Materials\n#define MAT_FLOOR  vec3(-1.0,1.0,0.0)\n#define MAT_MIRROR vec3(-1.0,2.0,0.0)\n\n#define MAT_LIMBS  vec3(0.929,0.508,0.508)\n\n#define MAT_TORSO  vec3(0.890,0.000,0.000)\n#define MAT_EYES   vec3(0.087,0.019,0.508)\n#define MAT_HAIR   vec3(0.111,0.054,0.071)\n\n//#define MAT_SKY     10.0\n#define MAT_SKY_COLOR_A   vec3(0.74,0.74,1.0)\n#define MAT_SKY_COLOR_B   vec3(0.13,0.137,0.96)\n\n// Scene constants\n\n#define CAMERA_NEAR 0.03\n#define CAMERA_FAR 25.0\n\n// The global scale of the scene is the same found in meatfighter.com,\n// should be better to change it in meters instead of centimeters but\n// I preferred to respect the original author choice.\n\n#define gSCALE  0.01\n\n// Animations and Modeling parameters\n\n#define JUGGLE_X0  -182.0\n#define JUGGLE_X1  -108.0\n#define JUGGLE_Y0  88.0\n#define JUGGLE_H_Y  184.0\n\n#define JUGGLE_H_VX ( (JUGGLE_X0 - JUGGLE_X1) / 60.0)\n#define JUGGLE_L_VX ((JUGGLE_X1 - JUGGLE_X0) / 30.0)\n\n#define  JUGGLE_H_H (JUGGLE_H_Y - JUGGLE_Y0)\n#define  JUGGLE_H_VY (4.0 * JUGGLE_H_H / 60.0)\n#define  JUGGLE_G (JUGGLE_H_VY * JUGGLE_H_VY/ (2.0 * JUGGLE_H_H))\n\n\n#define  JUGGLE_B_VY (2.0 * JUGGLE_H_H / 30.0)\n#define  JUGGLE_B ((JUGGLE_B_VY * JUGGLE_B_VY )/ (JUGGLE_H_H))\n\n#define JUGGLE_L_VY  (0.5 * JUGGLE_G * 60.0)\n\n#define HIPS_MAX_Y 85.0\n#define HIPS_MIN_Y  81.0\n\n#define HIPS_ANGLE_MULTIPLIER  (2.0 * Math_PI / 30.0)\n\n// by reason of culling and skip unnecessary calculations\nfloat sdCapsule( vec3 pa, vec3 ba, float r )\n{\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat rAABB( in vec3 roo, in vec3 rdd, in vec3 rad )\n{\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n    \n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0) return CAMERA_FAR;\n    \n    return tN;\n}\n// by reason of modeling\n\nfloat rPlane(vec3 o,vec3 d,vec4 pn)\n{\n    float num = pn.w - dot(pn.xyz,o);\n    float denom = dot(pn.xyz,d);\n    float t = num/denom;\n    if(t>PRECISION_STEP)\n        return t;\n    return CAMERA_FAR;\n}\n\n\nfloat rSphere(vec3 o, vec3 d, vec3 c, float r)\n{\n    vec3 e= c - o;\n    float a= dot(e, d);\n    float b= r*r - dot(e,e) + a*a;\n    if(b>0.0)\n    {\n        float t = a- sqrt(b);\n        if(t>PRECISION_STEP)\n            return t;\n    }\n    return CAMERA_FAR;\n}\n\n#define tSPH(v,r,col) { vec3 sp = ((v)+vec3(-150.0,0.0,150.0))*gSCALE;mind = rSphere( ro,rd, sp ,float(r)*gSCALE);if(mind<res.x){res=vec4(mind,col); n_out =normalize((ro+rd*mind)-sp); } }\n\n\n\n// the modeling and animation updates.\n\n// we have 8 spheres per limb\n#define countA 8\n\nvoid tUpdateAppendage(inout vec4 res,vec3 ro,vec3 rd,vec3 p, vec3 q, vec3 w, float A, float B,inout vec3 n_out)\n{\n    vec3 V=q-p;\n    float D=length(V);\n    float inverseD = 1.00 / D;\n    V*= inverseD;\n    \n    vec3 W = normalize(w);\n    vec3 U = cross(V, W);\n    \n    float A2 = A * A;\n    \n    float y = 0.5 * inverseD * (A2 - B * B + D * D);\n    float square = A2 - y * y;\n    if (square < 0.0) {\n        return;\n    }\n    float x = sqrt(square);\n    \n    vec3 j = p+U*x+V*y;\n    float ooA=  1.0 / 8.0;\n    vec3 d= (j- p)*ooA;\n    \n    vec3 k = p;\n    float mind=res.x;\n    \n    \n    \n    for(int i = 0; i <= countA; i++)\n    {\n        float fi=float(i);\n        tSPH((k+d*fi),(2.5+2.5*fi*ooA),MAT_LIMBS);\n    }\n    \n    d= (j- q )*ooA;\n    k = q;\n    for(int i = 0; i < countA; i++)\n    {\n        tSPH((k+d*float(i)),5.0,MAT_LIMBS);\n    }\n    \n    \n}\n\n\n// the juggler sphere animation paths, taken from http://meatfighter.com/juggler/\nvoid juggling(inout vec3 c,float t)\n{\n    if(t<60.0)\n    {\n        c.z = JUGGLE_X1 + JUGGLE_H_VX * t;\n        c.y = JUGGLE_Y0 + ((JUGGLE_H_VY - 0.5 * JUGGLE_G * t) * t);\n    }\n    else\n    {   float h= t-60.0;\n        c.z = JUGGLE_X0 + ((JUGGLE_X1 - JUGGLE_X0)/30.0) * h;\n        c.y = JUGGLE_Y0 + (((2.0 * JUGGLE_H_H / 30.0) - 0.5 * JUGGLE_B * h) * h)*.5;\n    }\n}\n// the raytracing scene function.\nvec4 trace(in vec3 ro, in vec3 rd,out vec3 n_out)\n{   vec4 res=vec4(CAMERA_FAR,-2.0,-2.0,0.0);\n    n_out=vec3(0);\n    float mind = rPlane(ro,rd,vec4(0,1.0,0,0));\n    if(mind<res.x) { res=vec4(mind,MAT_FLOOR); n_out =vec3(0.0,1.0,0.0);}\n    \n    \n    float chkd=rAABB(ro-vec3(0,1,0),rd,vec3(0.6,1.0,0.6));\n    if(chkd<res.x)\n    {\n        float t =  mod(iTime*30.0,90.0);\n        vec3 pos = ro;\n        vec3 c=vec3(110.0);\n        juggling(c,t);\n        tSPH(c,14.0,MAT_MIRROR);\n        \n        juggling(c,mod(t+25.0,90.0));\n        tSPH(c,14.0,MAT_MIRROR);\n        \n        juggling(c,mod(t+55.0,90.0));\n        tSPH(c,14.0,MAT_MIRROR);\n        \n        float T =  mod(iTime*30.0,30.0);\n        \n        float angle = HIPS_ANGLE_MULTIPLIER * T;\n        float oscillation = 0.5 * (1.0 + cos(angle));\n        vec3 o = vec3(151.0, HIPS_MIN_Y + (HIPS_MAX_Y - HIPS_MIN_Y) * oscillation,-151.0);\n        vec3 v=normalize(vec3(0.0,70.0,(HIPS_MIN_Y - HIPS_MAX_Y) * sin(angle)) );\n        vec3 u=vec3(0.0,v.z,-v.y);\n        vec3 w=vec3(1.0,0.0,0.0);\n        vec3 k = o;\n        \n        for(int i = 0; i <= 7; i++)\n        {\n            float percent = float(i) / 7.0;\n            tSPH(( k+v*(32.0*percent)) , (16.0+4.0*percent),MAT_TORSO);\n        }\n        tSPH(o+v*70.0, 14., MAT_LIMBS);\n        tSPH(o+v*55.0, 5., MAT_LIMBS);\n        \n        vec3 p=vec3(159.0,1.5,-133.0);\n        \n#define mapYZ(o,v,w,y,z) (v*y+w*z+o)\n        vec3 q = mapYZ(o,v,u,-9.0,-16.0);\n        tUpdateAppendage(res,ro,rd, p, q, u, 42.58, 34.07,n_out);\n        \n        p=vec3( 139.0,2.5,-164.0);\n        q=mapYZ( o, v, u, -9.0, 16.0);\n        tUpdateAppendage(res,ro,rd, p, q, u, 42.58, 34.07,n_out);\n        \n        vec3 n ;\n        float armAngle = -0.35 * oscillation;\n        p.x = 69.0 + 41.0 * cos(armAngle);\n        p.y = 60.0 - 41.0 * sin(armAngle);\n        p.z = -108.0;\n        \n        q=mapYZ( o, v, u, 45.0, -19.0);\n        n=mapYZ( o, v, u, 45.41217, -19.91111);\n        n-= q;\n        tUpdateAppendage(res,ro,rd, p, q, n, 44.294, 46.098,n_out);\n        \n        p.z = -182.0;\n        q=mapYZ( o, v, u, 45.0, 19.0);\n        n=mapYZ( o, v, u, 45.41217, 19.91111);\n        n= q- n;\n        tUpdateAppendage(res,ro,rd,p, q, n, 44.294, 46.098,n_out);\n        \n        c = mapYZ( o, v, u, 69.0, -7.0);\n        c.x=142.0;\n        tSPH(c, 4.0, MAT_EYES);\n        \n        c = mapYZ( o, v, u, 69.0, 7.0);\n        c.x=142.0;\n        tSPH(c, 4.0, MAT_EYES);\n        \n        c =  o + v*71.0;\n        c.x=152.0;\n        tSPH(c, 14.0, MAT_HAIR);\n        \n    }\n    \n    return res;\n}\n\n\nvec4 castRay( in vec3 ro, in vec3 rd ,out vec3 n_out)\n{\n    float tmin = CAMERA_NEAR;\n    \n    float precis = PRECISION_STEP;\n    \n    vec3 m =  vec3(-2.0);\n    n_out =vec3(0.0);\n    vec4 traced = trace(ro,rd,n_out);\n    float tmax =min(CAMERA_FAR,traced.x);\n    float t = tmin;\n    vec4 res=vec4(CAMERA_FAR,-2.0,-2.0,0.0);\n    \n    if(traced.x < CAMERA_FAR)\n        return traced;\n    \n    \n    n_out=vec3(0);\n    m=vec3(-2.0);\n    return vec4( CAMERA_FAR, m.x,m.y,m.z );\n}\n\n\n\nvec3  LightDirection = vec3(-0.646997, 0.754829, -0.107833);\n\nvec4 render( in vec3 ro, in vec3 rd ,out vec3 pos,out vec3 nor,out vec3 ref)\n{\n    // the sky... ugly dot(viewdir,up) ..\n    float l = pow(rd.y+.21 , .3 );\n    vec3 col =mix(vec3(MAT_SKY_COLOR_A),vec3(MAT_SKY_COLOR_B), l);\n    \n    vec4 res = castRay(ro,rd,nor);\n    float t = res.x;\n    vec3 m = res.yzw;\n    float tm =1.0;\n    if( m.x>=-1.0 )\n    {\n        pos = ro + t*rd;\n        ref = reflect( rd, nor );\n        \n        if( m.x<0.0 )\n        {\n            if(m.y<=1.0)\n            {   // the floor\n                float f = mod( floor(pos.z+.5) + floor(pos.x+0.5), 2.0);\n                col = mix(vec3(1,1,0),vec3(0,1,0),f);\n                col *=mix(vec3(1,1,1),vec3(0.1,.1,.1),t/CAMERA_FAR);\n            }\n            else\n            {   // mirror ball\n                tm=-1.0;\n                col=vec3(1.0);\n            }\n        }else // solid stuff\n            col = m;\n        // lighitng calculation\n        \n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, LightDirection ), 0.0, 1.0 );\n        float spe = pow(clamp( dot( ref, LightDirection ), 0.0, 1.0 ),16.0);\n        vec3 nnn;\n        // a shadow\n        dif *= (castRay(pos,LightDirection,nnn).x<CAMERA_FAR?0.0:1.0);\n        \n        vec3 lit = vec3(dif);\n        lit += 0.20*amb*vec3(0.50,0.50,0.60);\n        col *= lit;\n        // specular on solid stuff, no floor or mirrors\n        if(m.x>0.0)\n            col+= spe*dif;\n    }\n    \n    return vec4( col,tm );\n}\n\n// from iq code :D\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    float time =  iTime;\n    \n    // camera animation , mouse x to spin around the scene.\n    vec3 ro = vec3( -0.5+3.2*cos(0.1*time + 6.0*mo.x), .50 + 1.0, 0.5 + 3.2*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -0.0, 1.0, 0.0 );\n    \n    // mouse y to zoom in and out a little\n    ro = ro+normalize(ta-ro)*mo.y*2.0;\n    \n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,2.5) );\n    \n    // render\n    vec3 pos,nor,ref;\n    vec4 col = render( ro, rd ,pos,nor,ref);\n    // mirrors reflections, the first bounce\n    if(col.w<0.0)\n        col = pow(max(0.0, dot( ref, LightDirection ) ),26.0) + render( pos, ref ,pos,nor,ref);\n    // and a second one\n    if(col.w<0.0)\n        col = render( pos, ref ,pos,nor,ref);\n    \n    // gamma\n    col = pow( col, vec4(0.4545) );\n    \n    fragColor=vec4( col.xyz, 1.0 );\n    \n    // the title\n    //    mainText(fragColor,fragCoord);\n    mainVectorText(fragColor,fragCoord);\n}\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}