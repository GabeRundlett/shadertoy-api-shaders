{
    "Shader": {
        "info": {
            "date": "1485944200",
            "description": "Inspired by CPU's Bezier SDF shader   https://www.shadertoy.com/view/MtVSRD\nand ajs15822's  polyspline https://www.shadertoy.com/view/ltXSDB\n",
            "flags": 0,
            "hasliked": 0,
            "id": "llyXDV",
            "likes": 40,
            "name": "Signed Distance to PolySpline",
            "published": 3,
            "tags": [
                "2d",
                "bezier",
                "spline",
                "distance"
            ],
            "usePreview": 0,
            "username": "arkamarante",
            "viewed": 3800
        },
        "renderpass": [
            {
                "code": "// Signed Distance to a polySpline \n//\n// Inspired by CPU's shader   https://www.shadertoy.com/view/MtVSRD\n// and ajs15822's  https://www.shadertoy.com/view/ltXSDB\n// \n//My first objective was to make an anti-aliased version of CPU's polyspline shader,\n//but without the distance field seems impossible for me, at least without calculating 4 samples of each pixel,\n//so i tried a distance field aproach and mix 3 distance fields.\n\n//Calculating the 3 distance field to the 3 beziers like ajs15822's shader did not work either,\n//but using the sign calculation of the first polyspline shader into this second shader did the job.\n//Pretty slow to use it on anything real.\n\n\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat signBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{ \n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0, \n        step(testCross(A, B, p) * testCross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * testCross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a bezier curve\nfloat sdBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis;    // * signBezier(A, B, C, p);  //No need for this sign\n}\n\n\n#define setX(f) if (f>=0.&& f<1. && mix(mix(a.x,b.x,f),mix(b.x,c.x,f),f)<X) odd=!odd;\n\n\tfloat polySpline(vec2 p,vec2 AA,vec2 BB,vec2 CC,vec2 FF,vec2 GG,vec2 HH) {\n\t\tbool odd = false;\n\t\tfloat eps = 1e-7, root, A, B, C, X = p.x, Y = p.y;\n\t\t\n\t\tvec2 a = AA.xy;// readCell(np - 1., 0.).xy;\n\t\n\t\tvec2 b = BB.xy;\n\t\tvec2 c = CC.xy;\n\t\tA = a.y + c.y - b.y - b.y;\n\t\tB = 2.*(b.y - a.y);\n\t\tC = a.y - Y;\n\t\tif (abs(A)<eps) {\n\t\t\tsetX(-C / B);\n\t\t}\n\t\telse {\n\t\t\tfloat root = B*B - 4.*A*C;\n\t\t\tif (root>0.) {\n\t\t\t\troot = sqrt(root);\n\t\t\t\tsetX((-B - root) / (2.*A));\n\t\t\t\tsetX((-B + root) / (2.*A));\n\t\t\t}\n\t\t}\n\t\ta = c;\n\n\t\t//------\n\t\tb = FF.xy;\n\t\tc = GG.xy;\n\t\tA = a.y + c.y - b.y - b.y;\n\t\tB = 2.*(b.y - a.y);\n\t\tC = a.y - Y;\n\t\tif (abs(A)<eps) {\n\t\t\tsetX(-C / B);\n\t\t}\n\t\telse {\n\t\t\tfloat root = B*B - 4.*A*C;\n\t\t\tif (root>0.) {\n\t\t\t\troot = sqrt(root);\n\t\t\t\tsetX((-B - root) / (2.*A));\n\t\t\t\tsetX((-B + root) / (2.*A));\n\t\t\t}\n\t\t}\n\t\ta = c;\n\t\t\n\t\t//------\n\t\tb = HH.xy;\n\t\tc = AA.xy;\n\t\tA = a.y + c.y - b.y - b.y;\n\t\tB = 2.*(b.y - a.y);\n\t\tC = a.y - Y;\n\t\tif (abs(A)<eps) {\n\t\t\tsetX(-C / B);\n\t\t}\n\t\telse {\n\t\t\tfloat root = B*B - 4.*A*C;\n\t\t\tif (root>0.) {\n\t\t\t\troot = sqrt(root);\n\t\t\t\tsetX((-B - root) / (2.*A));\n\t\t\t\tsetX((-B + root) / (2.*A));\n\t\t\t}\n\t\t}\n\t\ta = c;\n\n\t\treturn float(odd);\n\t}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 m = mix((2.0*iMouse.xy-iResolution.xy)/iResolution.y,\n        vec2(cos(iTime * 1.2) * 0.8, 0.0), step(iMouse.z, 0.0));\n    \n    // Define the control points of our curve\n    vec2 A = vec2(-0.4, -0.6), C = vec2(-0.6, +0.4001), B = (4.0 * m - A - C) / 2.0;\n    B= vec2(-1.4,0.0);\n    \n    vec2 F=vec2(0.5,0.5);\n    vec2 G=vec2(1.25,0.5);\n    vec2 H=vec2(0.5,-0.5);\n    \n    F.x += cos(iTime * 0.5) * 0.8;\n    F.y += cos(iTime * 3.5) * 0.4;\n        \n    H.x += cos(iTime * 0.53) * 0.8;\n    H.y += cos(iTime * 3.35) * 0.4;\n    \n    B.x += 0.7 + cos(iTime * 0.53) * 0.45;\n    B.y += cos(iTime * 3.35) * 0.4;\n        \n    G.x += cos(iTime * 0.3) * 0.4;\n    G.y += cos(iTime * 2.35) * 0.2;\n        \n    A.x += cos(iTime * 0.3) * 0.4;\n    A.y += cos(iTime * 2.35) * 0.2;\n    \n    // Render the control points\n    float d = min(distance(p,H),min(distance(p,G), min(distance(p,B),   min(distance(p, A),(min(distance(p, F),distance(p, C)))))) );\n    if (d < 0.04) { fragColor = vec4(1.0 - smoothstep(0.025, 0.034, d)); return; }\n        \n    B+=(B-((A+C)*0.5));\t\t//Made the curve pass through the points\n    F+=(F-((C+G)*0.5));\n    H+=(H-((G+A)*0.5));\n    \n    // Get the signed distance to bezier curve\n    d = sdBezier(A, B, C, p);\n    float d2 = sdBezier(C,F,G, p);\n    float d3 = sdBezier(G,H,A, p);\n       \n    float spSign =polySpline(p,A,B,C,F,G,H);\n    \n    d=min(abs(d),min(abs(d2),abs(d3)));\n    if (spSign<=0.){\n        d=-d;\n    }\n       \n    // Visualize the distance field using iq's orange/blue scheme\n    fragColor = vec4(1.0) - sign(d)*vec4(0.1,0.4,0.7,1.0);\n    fragColor *= (1.0 - exp(-4.0*abs(d))) * (0.8 + 0.2*cos(140.*d));\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}