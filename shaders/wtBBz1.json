{
    "Shader": {
        "info": {
            "date": "1598363920",
            "description": "Draw by clicking\nHold shift to subtract",
            "flags": 48,
            "hasliked": 0,
            "id": "wtBBz1",
            "likes": 8,
            "name": "Drawing Symbols",
            "published": 3,
            "tags": [
                "symbols"
            ],
            "usePreview": 0,
            "username": "BackwardsCap",
            "viewed": 363
        },
        "renderpass": [
            {
                "code": "//#define GRID\n\nvoid mainImage(out vec4 c, in vec2 f)\n{\n    \n    c=S0(f/R);\n    \n#ifdef GRID\n    f = (2.*f-R)/R.y*res;\n    f=fract(f);\n    if(f.x<.01||f.y<.01)\n        c.rgb+=.1;\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Ancient Symbols\n//by Sam Gates (BackwardsCap)\n\n//Code is gross; I will optimize it at a later date\n#define R iResolution.xy\n#define PI 3.1415927\n#define m vec2(5.+2.*4.,10.)\n#define SS(U) smoothstep(PX, 0., U)\n\n//#define MORPH\n\n//Any advice on fixing the inconsistency on the connecting edges when you resize the screen would be very welcome\n#define PX 30./R.y\n\n\nfloat rand (vec2 p)\n{\n\n    p=floor(p);\n\tp/=res;    \n    vec2 r = ((p*R.y)+R)/2.;\n    r=r/R;\n    if(r.y>.99||r.y<-0.01 || r.x>.99 || r.x<-0.01)return 0.;\n    return S0(r+.01).x;\n}\n\nmat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\n//https://www.shadertoy.com/view/4llXD7\nfloat B(vec2 p, vec2 b, vec4 r)\n{\n    r.xy = p.x>0.0?r.xy : r.zw;\n    r.x = p.y>0.0 ? r.x : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return SS(min(max(q.x,q.y),0.0)+length(max(q,0.0))-r.x);\n}\n\nbool removed(float h, vec2 p)\n{\n    vec2 lp = mod(p,m);\n    \n    return h==0.;\n}\n\n\nfloat C(vec2 p){return SS(length(p-.5)-.4);}\n\nfloat CL(vec2 p, float a)\n{\n    vec2 bp = (p-.5);\n    bp*=rot(PI/4.*a);\n    bp.x+=.5;\n    return B(bp, vec2(.6,.345), vec4(.3));\n}\n\nfloat CE(vec2 p, vec2 o)\n{\n    return B((p+o)*rot(PI/4.), vec2(.5), vec4(0));\n}\n\nfloat EL(vec2 p, float t)\n{\n    vec2 b = vec2(.5,.4-PX);\n    p-=vec2(.5,.5);\n    p*=rot(PI/2.*t);\n    p.x+=PX;\n    vec4 r = vec4(b.x-b.x/2.,b.x-b.x/2.,0,0);\n    return B(p, b, r);\n}\n\nfloat D(vec2 p, float r)\n{\n    p-=.5;\n    p*=rot(PI/2.*r);\n    p+=.13;\n    float b1 = B(p,vec2(.5),vec4(.5,0,0,0));\n    p+=.77;\n    float b2 = B(p,vec2(.5),vec4(0,0,0,.025));\n    return b1-b2;\n}\n\n\nfloat T(vec2 p, float r)\n{\n    p-=.5;\n    p*=rot(PI/2.*r);\n    return B(p,vec2(.4-PX,.6), vec4(0));\n}\n\nfloat render(vec2 p, float h)\n{\n    bool neighbors[9];\n    int ul=6,u=7,ur=8,l=3,me=4,r=5,dl=0,d=1,dr=2;\n    int n=0;\n\n    float o = 0.;\n    float of = 1.;\n    for(float y=-of;y<=of;y+=of)\n    {\n        for(float x=-of;x<=of;x+=of){\n\n            int i = int(ceil(x+1.)+ceil(y+1.)*3.);\n\n            vec2 pos = floor(p+vec2(x,y));\n\n            neighbors[i]= !removed(rand(pos),pos);\n\n            if(i!=me&&neighbors[i])\n            {\n                n++;\n            }\n        }\n    }\n    \n    p=fract(p);\n\t\n    if(neighbors[me])\n    {\n        if(n==0) return C(fract(p));\n\t\t\n        if(neighbors[u]&&neighbors[d]){\n\n            float o = T(p,0.);\n            if(neighbors[l])o+=EL(p+vec2(.175,0),0.);\n            if(neighbors[r])o+=EL(p-vec2(.175,0),2.);\n            return o;\n        }\n        if(neighbors[l]&&neighbors[r])\n        {\n            float o = T(p,1.);\n            if(neighbors[u])o+=EL(p-vec2(0,.25),1.);\n            if(neighbors[d])o+=EL(p+vec2(0,.25),3.);\n            return o;\n        }\n\n\n        if(neighbors[u]&&!neighbors[d]&&!neighbors[l]&&!neighbors[r])\n        {\n            float o = EL(p-vec2(0,.3),1.);\n\n            if(neighbors[dl]) o+=CL(p-vec2(.175),7.);\n            if(neighbors[dr]) o+=CL(p-vec2(-.175,.175),5.);\n\n            return o;\n        }\n\n        if(neighbors[d]&&!neighbors[u]&&!neighbors[l]&&!neighbors[r])\n        {\n            float o = EL(p+vec2(0,.3),3.);\n\n            if(neighbors[ul]) o+=CL(p+vec2(-.175,.175),1.);\n            if(neighbors[ur]) o+=CL(p+vec2(.175),3.);\n\n            return o;\n        }\n\n        if(neighbors[l]&&!neighbors[r]&&!neighbors[d]&&!neighbors[u])\n        {\n            float o = EL(p+vec2(.3,0),0.);\n\n            if(neighbors[ur]) o+=CL(p+vec2(.175,.175),3.);\n            if(neighbors[dr]) o+=CL(p-vec2(-.175,.175),5.);\n\n            return o;\n        }\n\n        if(neighbors[r]&&!neighbors[l]&&!neighbors[d]&&!neighbors[u])\n        {\n            float o = EL(p-vec2(.3,0),2.);\n\n            if(neighbors[ul]) o+=CL(p+vec2(-.175,.175),1.);\n            if(neighbors[dl]) o+=CL(p-vec2(.175),7.);\n\n            return o;\n        }\n        float j = 0.0;\n        if(!neighbors[u]&&neighbors[r]&&!neighbors[l]&&neighbors[d])j+= D(p,3.);\n        if(neighbors[u]&&neighbors[r]&&!neighbors[l]&&!neighbors[d])j+= D(p,2.);\n        if(!neighbors[u]&&!neighbors[r]&&neighbors[l]&&neighbors[d])j+= D(p,0.);\n        if(neighbors[u]&&!neighbors[r]&&neighbors[l]&&!neighbors[d])j+= D(p,1.);\n        if(neighbors[ul]&&!neighbors[l]&&!neighbors[u]) j+=CL(p+vec2(-.175,.175),1.);\n        if(neighbors[dl]&&!neighbors[l]&&!neighbors[d]) j+=CL(p-vec2(.175),7.);\n        if(neighbors[ur]&&!neighbors[r]&&!neighbors[u]) j+=CL(p+vec2(.175,.175),3.);\n        if(neighbors[dr]&&!neighbors[r]&&!neighbors[d]) j+=CL(p-vec2(-.175,.175),5.);\n        \n\n        return  j;\n    }else{\n        float o = 0.0;\n        if(!neighbors[ul]&&neighbors[u]&&neighbors[l])o+= CE(p,vec2(.07,-1.15));\n        if(!neighbors[ur]&&neighbors[u]&&neighbors[r])o+= CE(p, vec2(-1.11));\n        if(!neighbors[dl]&&neighbors[d]&&neighbors[l])o+= CE(p,vec2(.11));\n        if(!neighbors[dr]&&neighbors[d]&&neighbors[r])o+= CE(p,vec2(-1.11,.11));\n        return o;\n    }\n}\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n\n    vec2 p = (2.0*f-R)/R.y*res;\n    float hash = rand(p);\n    vec3 col = vec3(1);\n    c.rgb=vec3(clamp(render(p,hash),0.,1.));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/* Memory / Drawing */\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2 p = (2.*f-R)/R.y * res;\n    vec2 id = floor(p);\n    float v = S0(f/R).r;\n    vec2 m = (2.*iMouse.xy-R)/R.y*res;\n    if(iMouse.z>0. && floor(m)==id){\n        v=holdingShift?0.:1.;\n    }\n    c.rgb = vec3(v);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define R iResolution.xy\n#define S0(U) texture(iChannel0, U)\n#define S1(U) texture(iChannel1, U)\n#define holdingShift (S1(vec2(16.5)/256.).x>0.)\n#define res 5.0",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}