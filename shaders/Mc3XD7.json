{
    "Shader": {
        "info": {
            "date": "1713994214",
            "description": "Drag around with the mouse to move the orb :)",
            "flags": 32,
            "hasliked": 0,
            "id": "Mc3XD7",
            "likes": 10,
            "name": "Water color orb",
            "published": 3,
            "tags": [
                "colors",
                "orb"
            ],
            "usePreview": 0,
            "username": "ianertson",
            "viewed": 192
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float rand(vec2 co, float seed)\n{\n    uvec2 p = floatBitsToUint(co);\n    uint s = floatBitsToUint(seed);\n    uint is = ~s;\n    uvec2 ip = ~p;\n    \n    p ^= p << 17U;\n    p ^= p >> 13U;\n    p ^= p << 5U;\n    p += (ip * s + p.y * p.x);\n    p *= 1013U;\n    \n    uint n = (p.x * is + p.y)*5013U;\n    \n    return float(n) / float(0xFFFFFFFFU);\n}\n\nfloat noise(vec2 co, float seed) {\n    vec2 lv = fract(co); lv = lv*lv*(3.0-2.0*lv);\n    vec2 id = floor(co);\n    \n    return mix(\n        mix(rand(id + vec2(0, 0), seed), rand(id + vec2(1, 0), seed), lv.x),\n        mix(rand(id + vec2(0, 1), seed), rand(id + vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nfloat noise(vec2 co, float seed, int oct) {\n    float n = 0.0;\n    float div = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    \n    for (int i = min(iFrame, 0); i < oct; i++) {\n        n += amp*noise(co*freq, seed);\n        float np = n*6.28;\n        co += 0.15*amp*vec2(sin(np), cos(np));\n        div += amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    \n    return n / div;\n}\n\nvec3 randomColor(vec2 co, float seed) {\n    co *= 9.0;\n    float r = noise(co, seed, 6);\n    float g = noise(co, seed+4.499123, 6);\n    float b = noise(co, seed+19.58389, 6);\n    return vec3(r, g, b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec4 m = vec4((iMouse.xy - 0.5 * iResolution.xy) / iResolution.y, iMouse.zw);\n    vec2 point = vec2(0, 0);\n    \n    if (m.z > 0.001) {\n        point = m.xy;\n    } else {\n        float t = iTime*0.25;\n        point += 0.15*vec2(sin(t), cos(t)); \n    }\n    \n    int st = 1;\n    \n    vec3 right = texelFetch(iChannel0, ivec2(fragCoord.xy) + ivec2(st, 0), 0).rgb;\n    vec3 left = texelFetch(iChannel0, ivec2(fragCoord.xy) + ivec2(-st, 0), 0).rgb;\n    vec3 up = texelFetch(iChannel0, ivec2(fragCoord.xy) + ivec2(0, st), 0).rgb;\n    vec3 down = texelFetch(iChannel0, ivec2(fragCoord.xy) + ivec2(0, -st), 0).rgb;\n\n\n    vec3 old = iFrame <= 1 ? randomColor(uv, iTime) : texelFetch(iChannel0, ivec2(fragCoord.xy), 0).rgb;\n    \n    vec3 col = randomColor(uv, iTime);\n    \n    vec3 cp = cross(col*2.0-1.0, old*2.0-1.0);\n    col = length(cp) > 0.00001 ? abs(normalize(cp)) : col;\n    \n    int comp = 2;\n    float r = 0.15;\n    float f = r*0.5;\n    float h = 0.5;\n    float dist = smoothstep(r-f, r+f, distance(uv, point));\n\n    comp = clamp(int(mix(0.0, 2.05, dist)), 0, 2);\n    h = mix(h, 0.25, dist);\n\n    if (right[comp] > h && left[comp] > h && up[comp] > h && down[comp] > h) {\n        vec3 ot = min(right, min(left, min(up, down))).xyz;\n        col = mix(col, ot, 1.01);        \n    }\n    \n    fragColor = vec4(mix(col, old, mix(0.5, 0.9, smoothstep(2.0, 2.5, min(iTime, 3.0)))), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}