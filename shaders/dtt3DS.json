{
    "Shader": {
        "info": {
            "date": "1683167067",
            "description": "Ray-traversal of two grids of primitives in a single traversal loop\nwith a single-pass depth of field, also an implementation of FXAA 3.11\n\nMouse drag to look around",
            "flags": 32,
            "hasliked": 0,
            "id": "dtt3DS",
            "likes": 44,
            "name": "Two Grid Traversal w/ 1Pass DoF",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "grid",
                "dof",
                "bokeh",
                "box",
                "aa",
                "fxaa"
            ],
            "usePreview": 0,
            "username": "gelami",
            "viewed": 898
        },
        "renderpass": [
            {
                "code": "\n// Single Pass Depth of Field\n// https://www.shadertoy.com/view/dtt3DS\n\n/* \n * Ray-traversal of two grids of primitives in a single traversal loop\n * with a single-pass depth of field, also an implementation of FXAA 3.11\n * \n * Mouse drag to look around\n * \n * Buffer A: Scene\n * Buffer B: FXAA 3.11\n * Buffer C: Single-Pass Depth of Field \n *\n * The two grids are done by traversing the rectangular prism grid normally\n * And when the ray steps into a new cell in the sphere grid,\n * if there is a hit from the previous cell, then there is an intersection on the sphere\n * if not then it only then intersects the sphere grid on that cell\n * \n * Ray differentials were used to calculate the texture gradients\n * for texture filtering of the reflections\n * \n * The single-pass depth of field method and scene is based from:\n * https://blog.voxagon.se/2018/05/04/bokeh-depth-of-field-in-single-pass.html\n * \n * For a change, anti-aliasing only uses FXAA 3.11 based on these tutorials:\n * http://blog.simonrodriguez.fr/articles/2016/07/implementing_fxaa.html\n * https://catlikecoding.com/unity/tutorials/custom-srp/fxaa/\n * \n * Additional resources:\n * \n * FXAA 3.11 source code copy\n * https://gist.github.com/kosua20/0c506b81b3812ac900048059d2383126\n * \n * FXAA 3.9 implementation\n * https://github.com/AmplifyCreations/FXAA/blob/master/Assets/FXAA/Shaders/Fxaa3_9.cginc\n * \n * Ray differentials for reflections formula from:\n * https://graphics.stanford.edu/papers/trd/\n * \n * Shape operator of a sphere:\n * https://jhavaldar.github.io/assets/2017-07-16-diffgeo-notes5.pdf\n * \n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    #ifdef DOF\n    vec3 col = texture(iChannel2, uv).rgb;\n    #else\n    vec3 col = texture(iChannel1, uv).rgb;\n    #endif\n    \n    col = col / (1.0 + col);\n    \n    col = mix(col, smoothstep(vec3(0), vec3(1), col), 0.5);\n    col = linearTosRGB(col);\n    \n    fragColor = vec4(col, 1);\n    fragColor += (dot(hash23(vec3(fragCoord, iTime)), vec2(1)) - 0.5) / 255.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// Defines\n\n#define FXAA\n#define DOF\n\n#define FOG\n#define FOG_STRENGTH 0.002\n#define FOG_START 25.0\n\n#define DOF_CAMERA_Z\n\n#define ROUNDED\n#define RADIUS 0.04\n\n//#define MOTION\n\n#define BOX_SIZE vec2(1, 1.5)\n#define SPHERE_PERIOD vec2(5)\n#define SPHERE_RADIUS 1.0\n#define SPHERE_HEIGHT 5.0\n\n#define MIN_HEIGHT (3.0*RADIUS)\n#define MAX_HEIGHT 8.0\n\n#define STEPS 256\n#define MAX_DIST 150.\n#define EPS 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\nstruct HitInfo\n{\n    float t;\n    vec3 n;\n    vec2 tp;\n    int type;\n};\n\n// Sphere ray-intersection\n// https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec2 sphereIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    if (b > 0.0 && c > 0.0) return vec2(MAX_DIST);\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(MAX_DIST); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// Rounded box ray-intersection\n// https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat roundedboxIntersect( in vec3 pos, in vec3 ro, in vec3 rd, in vec3 size, in float rad )\n{\n    vec3 s = vec3(sign(pos.x), 1, sign(pos.z));\n    ro  *= s;\n    rd  *= s;\n    pos *= s;\n    \n    // Faces\n    pos -= size;\n    pos = max( pos.xyz, pos.yzx );\n    if( min(min(pos.x,pos.y),pos.z) < 0.0 ) return 0.0;\n\n    vec3 oc = ro - size;\n    vec3 dd = rd*rd;\n    vec3 oo = oc*oc;\n    vec3 od = oc*rd;\n    float ra2 = rad*rad;\n\n    float t = MAX_DIST;\n    \n    // Corner\n    {\n        float b = od.x + od.y + od.z;\n        float c = oo.x + oo.y + oo.z - ra2;\n        float h = b*b - c;\n        if( h>0.0 ) t = - b -sqrt(h);\n    }\n    \n    vec3 a = dd.yzx + dd.zxy;\n    vec3 b = od.yzx + od.zxy;\n    vec3 c = oo.yzx + oo.zxy - ra2;\n    vec3 h = b*b - a*c;\n    \n    // Edge X\n    if( h.x>0.0 )\n    {\n        float ht = (-b.x - sqrt(h.x)) / a.x;\n        if( ht>0.0 && ht<t && abs(ro.x+rd.x*ht)<size.x ) t = ht;\n    }\n    \n    // Edge Y\n    if( h.y>0.0 )\n    {\n        float ht = (-b.y - sqrt(h.y)) / a.y;\n        if( ht>0.0 && ht<t && abs(ro.y+rd.y*ht)<size.y ) t = ht;\n    }\n    \n    // Edge Z\n    if( h.z>0.0 )\n    {\n        float ht = (-b.z - sqrt(h.z)) / a.z;\n        if( ht>0.0 && ht<t && abs(ro.z+rd.z*ht)<size.z ) t = ht;\n    }\n    \n    return t;\n}\n\nvec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )\n{\n    return sign(pos)*normalize(max(abs(pos)-siz,0.0));\n}\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat safeacos(float x) { return acos(clamp(x, -1.0, 1.0)); }\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(1)); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nfloat sqr(float x) { return x*x; }\nvec2 sqr(vec2 x) { return x*x; }\nvec3 sqr(vec3 x) { return x*x; }\n\nfloat luminance(vec3 col) { return dot(col, vec3(0.2126729, 0.7151522, 0.0721750)); }\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/smin/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0, .33, .67)));\n}\n\nvec3 palette2(float t)\n{\n    return vec3(0.6, 0.4, 0.4) + 0.4 * vec3(1, 0.3, 0.3) * cos(TAU * (vec3(1) * t + vec3(0, 0.25, 0.75)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n// Scene\n\n// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2023-05-02 21:17:35\n\nfloat map(vec2 p)\n{\n    float h = texture(iChannel0, (p*1.0 - vec2(-4.0, 1.0)) / iChannelResolution[0].xy).r;\n    \n    h = smoothstep(0.52, 0.8, h);\n    //float h = pow(hash12(p), 12.0)*0.8+0.1;\n    \n    #ifdef MOTION\n    h = h*0.8+0.1;\n    h += sin((iTime*0.5 + texture(iChannel0, p / iChannelResolution[0].xy).g) * TAU)*h*0.1;\n    //h += getPillarMotion(p, iTime);\n    #endif\n    \n    //float h = hash12(p * 0.033);\n    return clamp(h * MAX_HEIGHT, MIN_HEIGHT, MAX_HEIGHT);\n}\n\n\n\nvec4 debug = vec4(-1);\nbool trace(vec3 ro, vec3 rd, out HitInfo hit)\n{\n    if ((ro.y > MAX_HEIGHT && rd.y > 0.0) || (ro.y < MIN_HEIGHT && rd.y < 0.0))\n        return false;\n    \n    const vec2 s = BOX_SIZE;\n    const vec2 s2 = s * 0.5;\n    \n    vec2 tp = floor(ro.xz / s);\n    \n    const vec2 sps = SPHERE_PERIOD;\n    const vec2 sps2 = sps * 0.5;\n    const float srad = SPHERE_RADIUS;\n    const float spy = SPHERE_HEIGHT;\n    \n    vec2 spp = vec2(1e5);\n    vec2 sp = floor(ro.xz / sps);\n    bool sphit = false;\n    float st = MAX_DIST;\n    \n    //if (ro.y < map(tp))\n    //    return true;\n    \n    vec3 ird = 1.0 / rd;\n    vec3 srd = sign(rd);\n    vec3 ard = abs(ird);\n    \n    vec3 iro = (ro - vec3(s2.x, 0, s2.y)) * ird;\n    \n    float tmin = MAX_DIST;\n    hit.t = MAX_DIST;\n    hit.n = vec3(-1);\n    \n    int i = 0;\n    for (; i < STEPS; i++)\n    {\n        #if 1\n        if (spp != sp)\n        {\n            if (sphit)\n            {\n                hit.t = st;\n                vec3 pos = ro + rd * hit.t;\n                hit.n = normalize(pos - vec3((spp.x + 0.5) * sps.x, spy, (spp.y + 0.5) * sps.y));\n                hit.tp = spp;\n                hit.type = 1;\n                return true;\n            }\n            \n            vec3 ce = vec3((sp.x + 0.5) * sps.x, spy, (sp.y + 0.5) * sps.y);\n            vec2 spt = sphereIntersect(ro, rd, ce, srad);\n            if (spt.x < 0.0)\n            {\n                /*\n                hit.t = spt.y;\n                hit.n = normalize(ro + rd * spt.y - ce);\n                hit.tp = sp;\n                hit.type = 1;*/\n                return true;\n            }\n            if (spt.x < MAX_DIST)\n            {\n                st = spt.x;\n                sphit = true;\n            }\n            spp = sp;\n        }\n        #endif\n        \n        float d = map(tp) * 0.5;\n        \n        vec3 p = vec3(tp.x * s.x, d, tp.y * s.y);\n        vec3 bs = vec3(s2.x, d, s2.y);\n        vec3 n = iro - p * ird;\n        vec3 k = ard * bs;\n        \n        vec3 t1 = -n - k;\n        vec3 t2 = -n + k;\n        \n        float tN = max(max(t1.x, t1.y), t1.z);\n        float tF = min(min(t2.x, t2.y), t2.z);\n        \n        vec3 pos = ro + rd * tN;\n        \n        if (tN < st && pos.y > MAX_HEIGHT && rd.y > 0.0)\n            return false;\n        \n        if (tN < st && tN >= MAX_DIST)\n            return false;\n        \n        if (tN < st && tN < tF && tN >= 0.0)\n        {\n            #ifndef ROUNDED\n            hit.t = tN;\n            hit.n = -srd * step(t1.yzx, t1) * step(t1.zxy, t1);\n            hit.tp = tp;\n            hit.type = 0;\n            return true;\n            \n            #else\n            \n            const float rad = RADIUS;\n            \n            /*\n            if (d*2.0 < MIN_HEIGHT)\n            {\n                hit.t = tN;\n                hit.n = -srd * step(t1.yzx, t1) * step(t1.zxy, t1);\n                hit.tp = tp;\n                hit.type = 0;\n                return true;\n            }*/\n            \n            vec3 o = p + vec3(s2.x, 0, s2.y);\n            vec3 rp = ro - o;\n            float rt = roundedboxIntersect(pos - o, rp, rd, bs-rad, rad);\n                \n            if (rt != MAX_DIST)\n            {\n                hit.t = rt == 0.0 ? tN : rt;\n                vec3 pos = rp + rd * hit.t;\n                hit.n = normalize(roundedboxNormal(pos, bs-rad, rad));\n                hit.tp = tp;\n                hit.type = 0;\n                return true;\n            }\n            \n            if (ro.y + rd.y * min(t2.x, t2.z) < 0.0)\n            {\n                hit.t = -ro.y * ird.y;\n                hit.n = vec3(0, 1, 0);\n                hit.tp = vec2(0);\n                hit.type = 2;\n                return true;\n            }\n            #endif\n        }\n        \n        tp += step(t2.xz, t2.zx) * srd.xz;\n        sp = floor(tp * s / sps);\n        \n    }\n    return false;\n}\n\nvec3 invReinhard(vec3 color, float exposure)\n{\n    return color / (exposure * max((1.0 - color) / exposure, 1e-3));\n}\n\nvec3 getSky(vec3 rd)\n{\n    vec3 sky = sRGBToLinear(texture(iChannel3, rd).rgb);\n    \n    sky = invReinhard(sky, 400.0);\n    \n    return sky;\n}\n\nvec3 getSky(vec3 rd, vec3 rdDx, vec3 rdDy)\n{\n    vec3 sky = sRGBToLinear(textureGrad(iChannel3, rd, rdDx, rdDy).rgb);\n    \n    sky = invReinhard(sky, 400.0);\n    \n    return sky;\n}\n\nvec3 shade(vec3 pos, HitInfo hit, vec3 ldir, vec3 rd)\n{\n    vec3 col = vec3(0);\n    vec3 alb = palette2(hash12(hit.tp));\n    vec3 skyCol = vec3(1, 0.5, 0.4);\n    \n    HitInfo hitL;\n    bool isHitL = trace(pos + ldir * hit.t*EPS, ldir, hitL);\n    \n    vec3 ref = reflect(rd, hit.n);\n    \n    float dif = max(dot(hit.n, ldir), 0.0) * float(!isHitL);\n    float bou = max(dot(ref, -ldir), 0.0);\n    float ao = smoothstep(0.0, MAX_HEIGHT*0.6, pos.y);\n    \n    col += alb * (dif * 0.9 + 0.1);\n    col += alb * bou * 0.08;\n    col += skyCol * 0.1 * ao;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ndc = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 ndcDx = (2. * (fragCoord + vec2(1, 0)) - iResolution.xy) / iResolution.y;\n    vec2 ndcDy = (2. * (fragCoord + vec2(0, 1)) - iResolution.xy) / iResolution.y;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, 16);\n    vec3 lo = vec3(0.2 * iTime, 2, 0.8 * iTime);\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    float ax = -PI * .7 - iTime * 0.16;\n    float ay = PI * 0.2;\n    \n    if (iMouse.z > 0.0)\n    {\n        if (iMouse.x != 0.0) ax = -m.x * TAU + PI;\n        if (iMouse.y != 0.0) ay = m.y * PI * 0.5 + PI * 0.5;\n    }\n    \n    ro.yz *= rot2D(ay);\n    ro.xz *= rot2D(ax);\n    ro += lo;\n\n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    float tanFov = 2.0;\n    vec3 rd = normalize(cmat * vec3(ndc, tanFov));\n    vec3 rdDx = normalize(cmat * vec3(ndcDx, tanFov));\n    vec3 rdDy = normalize(cmat * vec3(ndcDy, tanFov));\n\n    HitInfo hit;\n    bool isHit = trace(ro, rd, hit);\n\n    float t = hit.t;\n    vec3 n = hit.n;\n    vec2 tp = hit.tp;\n    \n    vec3 col = vec3(0);\n    vec3 alb = palette2(hash12(hit.tp));\n    vec3 skyCol = vec3(1, 0.5, 0.4);\n    //skyCol = vec3(0.5, 0.8, 1);\n    \n    vec3 ldir = normalize(vec3(0.8, 2, 1.2));\n    \n    vec3 pos = ro + rd * t + n * EPS;\n    vec3 posDx = ro - rdDx * dot(ro - pos, n) / dot(rdDx, n);\n    vec3 posDy = ro - rdDy * dot(ro - pos, n) / dot(rdDy, n);\n    \n    vec3 nDx = hit.type == 1 ? (posDx - pos) : vec3(0);\n    vec3 nDy = hit.type == 1 ? (posDy - pos) : vec3(0);\n    \n    if (hit.type == 0)\n    {\n        float d = map(hit.tp) * 0.5;\n        vec3 bpos = pos - vec3((hit.tp + 0.5) * BOX_SIZE, d).xzy;\n        bpos = abs(bpos);\n\n        vec3 size = vec3(BOX_SIZE.x * 0.5, d, BOX_SIZE.y * 0.5) - RADIUS;\n        bpos -= size;\n\n        vec3 bmpos = max( bpos.xyz, bpos.yzx );\n\n        if( min(min(bmpos.x, bmpos.y), bmpos.z) < 0.0 )\n        {\n            nDx = vec3(0);\n            nDy = vec3(0);\n        } else if (all(greaterThan(bpos, vec3(0))))\n        {\n            nDx = (posDx - pos) / RADIUS;\n            nDy = (posDy - pos) / RADIUS;\n        } else\n        {\n            vec3 bm = 1.0 - step(bpos, bpos.yzx) * step(bpos, bpos.zxy);\n            \n            nDx = (posDx - pos) * bm / RADIUS;\n            nDy = (posDy - pos) * bm / RADIUS;\n        }\n    }\n    \n    vec3 ref = reflect(rd, n);\n    vec3 refDx = (rdDx - rd) - 2.0 * (dot(rd, n) * nDx + (dot(rdDx - rd, n) + dot(rd, nDx)) * n);\n    vec3 refDy = (rdDy - rd) - 2.0 * (dot(rd, n) * nDy + (dot(rdDy - rd, n) + dot(rd, nDy)) * n);\n    \n    col = shade(pos, hit, ldir, rd);\n    \n    HitInfo hitR;\n    bool isHitR = trace(pos, ref, hitR);\n    \n    vec3 refPos = pos + ref * hitR.t + hitR.n * EPS;\n    vec3 refCol = shade(refPos, hitR, ldir, ref);\n    \n    if (!isHitR)\n    {\n        #if 1\n        refCol = getSky(ref, refDx, refDy);\n        #else\n        refCol = getSky(ref);\n        #endif\n    }\n    \n    vec3 r0 = hit.type == 1 ? alb : vec3(0.08);\n    vec3 fre = r0 + (1.0 - r0) * pow(1.0 - dot(-rd, n), 5.0);\n    \n    col = mix(col, refCol, fre);\n    \n    //if (hit.type == 1) col = refCol;\n    \n    #ifdef FOG\n    vec3 fog = 1.0 - exp(-max(t - FOG_START, 0.0) * skyCol * FOG_STRENGTH);\n    col = col * (1.0 - fog) + vec3(1, 0.7, 0.5) * fog;\n    #endif\n    \n    if (!isHit)\n    {\n        col = getSky(rd);\n        t = MAX_DIST;\n    }\n    \n    col = max(col, vec3(0));\n    #ifdef FXAA\n    col = col / (1. + col);\n    col = linearTosRGB(col);\n    #endif\n    \n    #ifdef DOF_CAMERA_Z\n    t = t * dot(rd, cmat[2]);\n    #endif\n    \n    fragColor = vec4(col, t);\n    \n    if (debug != vec4(-1))\n        fragColor = debug;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// FXAA\n\n// FXAA Defines\n// Trims the algorithm from processing darks.\n//   0.0833 - upper limit (default, the start of visible unfiltered edges)\n//   0.0625 - high quality (faster)\n//   0.0312 - visible limit (slower)\n#define FXAA_THRESHOLD_MIN 0.0312\n\n// The minimum amount of local contrast required to apply algorithm.\n//   0.333 - too little (faster)\n//   0.250 - low quality\n//   0.166 - default\n//   0.125 - high quality \n//   0.063 - overkill (slower)\n#define FXAA_THRESHOLD_MAX 0.063\n\n// This can effect sharpness.\n//   1.00 - upper limit (softer)\n//   0.75 - default amount of filtering\n//   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n//   0.25 - almost off\n//   0.00 - completely off\n#define FXAA_SUBPIXEL_QUALITY 1.0\n\n// Assumed to be in perceptual/gamma-encoded space\nfloat luma(vec3 col)\n{\n    //return dot(col, vec3(0.2126729, 0.7151522, 0.0721750));\n    return dot(col, vec3(0.299, 0.587, 0.114));\n    return sqrt(dot(col, vec3(0.299, 0.587, 0.114)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 px = 1.0 / iResolution.xy;\n    \n    vec4 col = texture(iChannel0, uv);\n    \n    #ifndef FXAA\n    fragColor = col;\n    #else\n    float lumaCenter = luma(col.rgb);\n    float lumaUp    = luma(texture(iChannel0, uv + vec2(0, px.y)).rgb);\n    float lumaDown  = luma(texture(iChannel0, uv - vec2(0, px.y)).rgb);\n    float lumaLeft  = luma(texture(iChannel0, uv - vec2(px.x, 0)).rgb);\n    float lumaRight = luma(texture(iChannel0, uv + vec2(px.x, 0)).rgb);\n\n    float lumaMin = min(min(min(lumaUp, lumaDown), min(lumaLeft, lumaRight)), lumaCenter);\n    float lumaMax = max(max(max(lumaUp, lumaDown), max(lumaLeft, lumaRight)), lumaCenter);\n\n    float lumaRange = lumaMax - lumaMin;\n\n    if (lumaRange < max(FXAA_THRESHOLD_MIN, lumaMax * FXAA_THRESHOLD_MAX))\n    {\n        col.rgb = sRGBToLinear(col.rgb);\n        col.rgb = col.rgb / (1.0 - col.rgb);\n    \n        fragColor = col;\n        return;\n    }\n    \n    float lumaDownLeft  = luma(texture(iChannel0, uv - vec2(px.x, px.y)).rgb);\n    float lumaUpRight   = luma(texture(iChannel0, uv + vec2(px.x, px.y)).rgb);\n    float lumaDownRight = luma(texture(iChannel0, uv + vec2(px.x, -px.y)).rgb);\n    float lumaUpLeft    = luma(texture(iChannel0, uv + vec2(-px.x, px.y)).rgb);\n    \n    float lumaDownUp = lumaDown + lumaUp;\n    float lumaLeftRight = lumaLeft + lumaRight;\n    \n    float lumaCornerDown = lumaDownRight + lumaDownLeft;\n    float lumaCornerUp = lumaUpRight + lumaUpLeft;\n    float lumaCornerLeft = lumaDownLeft + lumaUpLeft;\n    float lumaCornerRight = lumaDownRight + lumaUpRight;\n\n    float edgeHorizontal = abs(-2.0 * lumaLeft + lumaCornerLeft) +\n                           abs(-2.0 * lumaCenter + lumaDownUp) * 2.0 +\n                           abs(-2.0 * lumaRight + lumaCornerRight);\n    \n    float edgeVertical   = abs(-2.0 * lumaUp + lumaCornerUp) +\n                           abs(-2.0 * lumaCenter + lumaLeftRight) * 2.0 +\n                           abs(-2.0 * lumaDown + lumaCornerDown);\n\n    bool isEdgeHorizontal = edgeHorizontal >= edgeVertical;\n\n    float luma0 = isEdgeHorizontal ? lumaDown : lumaLeft;\n    float luma1 = isEdgeHorizontal ? lumaUp : lumaRight;\n    \n    float grad0 = abs(luma0 - lumaCenter);\n    float grad1 = abs(luma1 - lumaCenter);\n\n    bool gradStep = grad0 >= grad1;\n    \n    float gradScaled = 0.25 * max(grad0, grad1);\n    \n    float stepSize = isEdgeHorizontal ? px.y : px.x;\n    stepSize = gradStep ? -stepSize : stepSize;\n    \n    float lumaLocalAvg = 0.5 * ((gradStep ? luma0 : luma1) + lumaCenter);\n\n    vec2 curUV = uv;\n    \n    if (isEdgeHorizontal)\n        curUV.y += stepSize * 0.5;\n    else\n        curUV.x += stepSize * 0.5;\n    \n    vec2 stepOffset = isEdgeHorizontal ? vec2(px.x, 0) : vec2(0, px.y);\n    \n    vec2 uv0 = curUV - stepOffset;\n    vec2 uv1 = curUV + stepOffset;\n    \n    float lumaEnd0 = luma(texture(iChannel0, uv0).rgb) - lumaLocalAvg;\n    float lumaEnd1 = luma(texture(iChannel0, uv1).rgb) - lumaLocalAvg;\n    \n    bool reached0 = abs(lumaEnd0) >= gradScaled;\n    bool reached1 = abs(lumaEnd1) >= gradScaled;\n    \n    if (!reached0) uv0 -= stepOffset;\n    if (!reached1) uv1 += stepOffset;\n    \n    if (!(reached0 && reached1))\n    {\n        #define ITERATIONS 12\n        const float QUALITY[ITERATIONS] = float[](1.0, 1.0, 1.0, 1.0, 1.0, 1.5, 2.0, 2.0, 2.0, 2.0, 4.0, 8.0);\n        for (int i = 2; i < ITERATIONS; i++)\n        {\n            if (!reached0)\n            {\n                lumaEnd0 = luma(texture(iChannel0, uv0).rgb) - lumaLocalAvg;\n            }\n            if (!reached1)\n            {\n                lumaEnd1 = luma(texture(iChannel0, uv1).rgb) - lumaLocalAvg;\n            }\n            \n            reached0 = abs(lumaEnd0) >= gradScaled;\n            reached1 = abs(lumaEnd1) >= gradScaled;\n            \n            if (!reached0) uv0 -= stepOffset * QUALITY[i];\n            if (!reached1) uv1 += stepOffset * QUALITY[i];\n            \n            if (reached0 && reached1) break;\n        }\n    }\n    \n    float distance0 = isEdgeHorizontal ? (uv.x - uv0.x) : (uv.y - uv0.y);\n    float distance1 = isEdgeHorizontal ? (uv1.x - uv.x) : (uv1.y - uv.y);\n    \n    float lumaDist = distance0 < distance1 ? lumaEnd0 : lumaEnd1;\n    \n    float pixelOffset = -min(distance0, distance1) / (distance0 + distance1) + 0.5;\n    \n    bool correctVar = lumaCenter < lumaLocalAvg != lumaDist < 0.0;\n    \n    float finalOffset = correctVar ? pixelOffset : 0.0;\n    \n    float lumaAvg = (1.0 / 12.0) * (2.0 * (lumaDownUp + lumaLeftRight) + lumaCornerLeft + lumaCornerRight);\n    \n    float subpixelOffset = smoothstep(0.0, 1.0, abs(lumaAvg - lumaCenter) / lumaRange);\n    subpixelOffset = subpixelOffset * subpixelOffset * FXAA_SUBPIXEL_QUALITY;\n    \n    finalOffset = max(finalOffset, subpixelOffset);\n    \n    vec2 finalUV = uv;\n    \n    if (isEdgeHorizontal)\n        finalUV.y += stepSize * finalOffset;\n    else\n        finalUV.x += stepSize * finalOffset;\n    \n    vec3 fcol = texture(iChannel0, finalUV).rgb;\n    \n    fcol = sRGBToLinear(fcol);\n    fcol = fcol / (1.0 - fcol);\n    \n    fragColor = vec4(fcol, col.a);\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// Depth of Field\n\n// DoF Defines\n#define DOF_FOCUS_DIST 16.0\n\n#define DOF_RADIUS 24.0\n#define DOF_FOCUS_SCALE 8.0\n\n#define RADIUS_SCALE 1.\n\n//#define DOF_USE_LOD\n#define DOF_MAX_LOD 4.0\n\n#define DOF_STEPS 32\n\n#define GOLDEN_ANGLE 2.39996323\n\nfloat getCoc(float t, float focalDist, float scale)\n{\n    return saturate(abs(1.0 / focalDist - 1.0 / t) * scale) * DOF_RADIUS;\n}\n\nvec3 depthOfField(sampler2D tex, vec2 uv)\n{\n    float ct = texture(tex, uv).a;\n    // Auto-focus (doesn't work T_T)\n    //float fd = texture(tex, vec2(0.5)).a;\n    float fd = DOF_FOCUS_DIST;\n    \n    float cs = getCoc(ct, fd, DOF_FOCUS_SCALE);\n    \n    #ifdef DOF_USE_LOD\n    vec3 color = textureLod(tex, uv, DOF_MAX_LOD * cs / DOF_RADIUS).rgb;\n    #else\n    vec3 color = texture(tex, uv).rgb;\n    #endif\n    \n    vec2 px = 1.0 / iResolution.xy;\n    float w = 1.0;\n    float radStep = DOF_RADIUS / float(DOF_STEPS);\n    float rad = radStep * 0.5;\n    float ang = 0.0;\n    \n    for (int i = 0; i < DOF_STEPS; i++)\n    {\n        vec2 p = uv + vec2(cos(ang), sin(ang)) * rad * px;\n        #ifdef DOF_USE_LOD\n        vec4 sampCol = textureLod(tex, p, DOF_MAX_LOD * rad / DOF_RADIUS);\n        #else\n        vec4 sampCol = texture(tex, p);\n        #endif\n        \n        float ss = getCoc(sampCol.a, DOF_FOCUS_DIST, DOF_FOCUS_SCALE);\n        \n        if (sampCol.a > ct)\n            ss = clamp(ss, 0.0, cs * 2.0);\n        \n        float m = smoothstep(rad - 0.5, rad + 0.5, ss);\n\n        color += mix(color / w, sampCol.rgb, m);\n        ang += GOLDEN_ANGLE;\n        rad += radStep / rad;\n        w += 1.0;\n    }\n    \n    return color / w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    #ifdef FXAA\n    vec3 col = depthOfField(iChannel1, uv);\n    #else\n    vec3 col = depthOfField(iChannel1, uv);\n    #endif\n    //col = col / (1.0 + col);\n    //col = linearTosRGB(col);\n    \n    fragColor = vec4(col, 1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}