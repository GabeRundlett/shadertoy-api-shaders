{
    "Shader": {
        "info": {
            "date": "1463915249",
            "description": "A Voronoi / Worley implementation, based upon the legions of experiments by IQ and Fabrice Neyret. The randomness changes vertically, and the distance used evolves horizontally. They can be controlled with the mouse.",
            "flags": 0,
            "hasliked": 0,
            "id": "lsVSWz",
            "likes": 13,
            "name": "Another Voronoi",
            "published": 3,
            "tags": [
                "voronoi",
                "noise",
                "worley",
                "distance",
                "cells"
            ],
            "usePreview": 0,
            "username": "Zavie",
            "viewed": 1205
        },
        "renderpass": [
            {
                "code": "/*\n\nA Voronoi implementation, featuring some of the tricks seen\nin other shaders.\n\n--\nZavie\n\n*/\n\nfloat hash(float x) { return fract(sin(x) * 43758.5453); }\nfloat hash(vec2 xy) { return fract(sin(dot(xy, vec2(12.9898, 78.233))) * 43758.5453); }\nvec2 hash2(vec2 xy) { return fract(sin(vec2(dot(xy, vec2(127.1,311.7)), dot(xy, vec2(269.5,183.3)))) * 43758.5453); }\n\nstruct VoronoiInfo\n{\n    float f1;\n    float f2;\n    float f3;\n    float f4;\n    float id;\n    vec2 pos;\n};\n\nVoronoiInfo Voronoi(vec2 p, float frequency, float randomness, float norm)\n{\n    p *= frequency;\n    vec2 p0 = floor(p);\n    float f1 = 1e30;\n    float f2 = 1e30;\n    float f3 = 1e30;\n    float f4 = 1e30;\n    float id = -1.;\n    vec2 pos = vec2(0.);\n\n    for (int j = -1; j <= 1; ++j)\n    for (int i = -1; i <= 1; ++i)\n    {\n        vec2 p_i = p0 + vec2(float(i), float(j));\n        vec2 cellOrigin = p_i + mix(vec2(0.5), hash2(p_i), randomness);\n        float cellId = hash(p_i);\n\n        vec2 delta = abs(cellOrigin - p);\n        float d1 = delta.x + delta.y;\t\t\t\t// Manhattan\n        float d2 = length(delta);\t\t\t\t\t// Euclid\n        float dInfinite = max(delta.x, delta.y);\t// Chebychev\n\n        float d = 0.;\n        if (norm <= 1.)      d = mix(d1, d2, norm);\n        else if (norm <= 2.) d = mix(d2, dInfinite, norm - 1.);\n        else if (norm <= 3.) d = mix(dInfinite, d1, norm - 2.);\n\n        if (d < f1)\n        {\n            f4 = f3;\n            f3 = f2;\n            f2 = f1;\n            f1 = d;\n            id = cellId;\n            pos = cellOrigin;\n        }\n        else if (d < f2)\n        {\n            f4 = f3;\n            f3 = f2;\n            f2 = d;\n        }\n        else if (d < f3)\n        {\n            f4 = f3;\n            f3 = d;\n        }\n        else if (d < f4)\n        {\n            f4 = d;\n        }\n    }\n\treturn VoronoiInfo(f1, f2, f3, f4, id, pos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    float randomness = mix(0.2, 1., smoothstep(0., 1., abs(2. * fract(0.2*iTime + 0.5*uv.y) - 1.)));\n    float norm = 3. * fract(-uv.x + 0.5*iTime);\n    \n    if (iMouse.z > 0.)\n    {\n        randomness = iMouse.y / iResolution.y;\n        norm = 3. * iMouse.x / iResolution.x;\n    }\n    VoronoiInfo vi = Voronoi(uv, 10., randomness, norm);\n    \n    vec3 red = vec3(0.698, 0., 0.082);\n    vec3 green = vec3(0.129, 0.612, 0.);\n    vec3 baseColor = mix(red, green, vi.id);\n    float cellDot = smoothstep(0.05, 0.1, length(10.*uv - vi.pos));\n\n    fragColor = vec4(mix(vec3(1.), baseColor, pow(vi.f2 - vi.f1, 0.2)) * cellDot, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}