{
    "Shader": {
        "info": {
            "date": "1617523078",
            "description": "Path-Tracing and Volumetrics go well together with Worley Noise.",
            "flags": 32,
            "hasliked": 0,
            "id": "NdBGzh",
            "likes": 5,
            "name": "Path-Traced Volumetric Clouds",
            "published": 3,
            "tags": [
                "raymarching",
                "ray",
                "raymarch",
                "raymarched",
                "volumetric",
                "raymarcher",
                "pathtrace",
                "pathtracing",
                "pathtracer",
                "path",
                "pathtraced"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 685
        },
        "renderpass": [
            {
                "code": "// ######### Path-Traced Volumetric Clouds #########\n// Made by Jacob Bingham (Zi7ar21)\n// Made on April 4th, 2021\n// Last Updated: April 4th, 2021 at 02:00 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/NdBGzh\n\n// Check out my Friends:\n// Michael0884\n// https://www.shadertoy.com/user/michael0884\n// LoicVDB\n// https://www.shadertoy.com/user/loicvdb\n\n// This shader isn't as commented as well as I want it to be,\n// come back in a few days if I ever add more comments lmao\n\n// Output the Image to the Screen\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Get the Rendered Image\n    vec3 color = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n\n    // HDR Tonemapping\n    color = tonemap(color);\n\n    // Output the Image to the Screen\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ####### COMMON #######\n/* This tab contains settings and other functions that help make this shader work. */\n\n// ##### PARAMETERS #####\n// Sensitivity of the Mouse Controls\n#define mousesensitivity 8.0\n\n// Image Gamma (Image Preview Only)\n#define gamma 2.2\n\n// Camera Field of View\n#define camfov 1.0\n\n// Fractal Brownian Motion (FBM) Noise Octaves (More = More Detail)\n#define octaves 4U\n\n// Size of the Volumetric Ray-Marching Steps\n#define stepsize 0.05\n\n// Maximum Ray-Marching Steps\n#define maxmarches 1024U\n\n// Scattering Amount\n#define scattering 1.0\n\n// Maximum Distance the Ray can Travel from (0.0, 0.0, 0.0)\n#define scenesize 32.0\n\n// Maximum Distance the Ray can Travel\n#define maxdist 32.0\n\n// Maximum Times the Ray can Bounce\n#define maxbounces 8U\n\n// ### LoicVDB Sky Parameters ###\n// Controls Sky Quality\n#define SkySamples 8\n\n// Controls Sky Color\n#define SkyColor vec3(0.25, 0.5, 1.0)\n\n// Controls Light Color\n#define LightColor vec3(1.0, 1.0, 1.0)\n\n// Controls Sky Direction\n#define SkyUp vec3(0.0, 1.0, 0.0)\n\n// Controls Light Direction\n#define LightDirection normalize(vec3(0.0, 0.25, -1.0))\n\n// Controls Sky Intensity\n#define SkyIntensity 0.2\n\n// Controls Light Intensity\n#define LightIntensity 5.0\n\n// Controls the Radius of the Light\n#define LightRadius 0.125\n\n// Controls Mie Scattering Intensity\n#define MieIntensity 0.05\n\n// Controls Mie Scattering Anisotropy\n#define MieAnisotropy 0.6\n\n// ##### CONSTANTS #####\n// Octuple Precision Pi\n// (for future-proofing, even though Shadertoy can only accurately represent pi as 3.14159265)\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n#define twopi pi*2.0\n#define quarterpi pi*0.25\n\n// ##### CUSTOM DATA TYPES #####\nstruct volumesample{\n    float density;\n    vec3 color;\n};\n\n// ##### MATH #####\n// Clamps a Value to Between 0.0 and 1.0\nfloat saturate(float x){return clamp(x, 0.0, 1.0);}\nvec2  saturate(vec2  x){return clamp(x, 0.0, 1.0);}\nvec3  saturate(vec3  x){return clamp(x, 0.0, 1.0);}\nvec4  saturate(vec4  x){return clamp(x, 0.0, 1.0);}\n\n// Rotation Matrix from LoicVDB\nmat3 rotmat(vec3 rotation){\n    // Precalculate the Trig Functions\n    vec3 s = sin(rotation), c = cos(rotation);\n\n    // X Rotation\n    mat3 rx = mat3(\n    1.0, 0.0, 0.0,\n    0.0, c.x,-s.x,\n    0.0, s.x, c.x);\n\n    // Y Rotation\n    mat3 ry = mat3(\n    c.y, 0.0,-s.y,\n    0.0, 1.0, 0.0,\n    s.y, 0.0, c.y);\n\n    // Z Rotation\n    mat3 rz = mat3(\n    c.z,-s.z, 0.0,\n    s.z, c.z, 0.0,\n    0.0, 0.0, 1.0);\n\n    // Output the Final Matrix\n    return rx*ry*rz;\n}\n\n// Rotate a Vector\nvec3 rotate(vec3 vector, vec3 angle){\n    return vector*rotmat(angle);\n}\n\n// ##### NOISE #####\n// Dave_Hoskins Hash33: https://www.shadertoy.com/view/4djSRW\nvec3 hash(vec3 p3){\n\tp3 = fract(p3*vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yxx)*p3.zyx);\n}\n\n// My very own Worley Noise Implementation, drastically improved by LoicVDB\nfloat noise(vec3 coord){\n    vec3 cell = floor(coord);\n    float mindist = 1000.0;\n    for(int z = -1; z < 2; z++){\n    for(int y = -1; y < 2; y++){\n    for(int x = -1; x < 2; x++){\n        vec3 ncell = cell+vec3(x, y, z);\n        vec3 point = ncell+hash(ncell);\n        mindist = min(dot(coord-point, coord-point), mindist);\n    }\n    }\n    }\n    return sqrt(mindist);\n}\n\n// Fractal Brownian Motion (FBM) Noise\nfloat fbm(vec3 coord){\n    float outCol      = 0.0;\n    float attenuation = 0.5;\n    for(uint i = 0U; i < octaves; i++){\n        outCol += (1.0-noise(coord))*attenuation;\n        coord  *= 2.5;\n        //coord   = rotate(coord, vec3(pi/8.0));\n        attenuation *= 0.5;\n    }\n    return outCol;\n}\n\n/*// ##### DISTANCE ESTIMATORS #####\nfloat sphere(vec3 pos, vec3 sphpos, float sphrad){\n    return length(pos-sphpos)-sphrad;\n}\n\nfloat yplane(vec3 pos, float ypos){\n    return pos.y-ypos;\n}\n\nfloat box(vec3 pos, vec3 box){\n    vec3 q = abs(pos)-box;\n    return length(max(q, 0.0))+min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat de(vec3 raypos){\n    float DE0 = yplane(raypos, 0.0);\n    return DE0;\n}\n\nvec3 calcNormal(vec3 pos){\n    const vec2 k = vec2(1.0, -1.0);\n    return normalize(k.xyy*de(pos+k.xyy*collisiondist)+\n                     k.yyx*de(pos+k.yyx*collisiondist)+\n                     k.yxy*de(pos+k.yxy*collisiondist)+\n                     k.xxx*de(pos+k.xxx*collisiondist));\n}\n\nfloat de(in vec3 raypos, out uint objectid){\n    float DE0 = yplane(raypos, 0.0);\n    float DE1 = sphere(raypos, vec3(0.0, 0.5, 0.0), 0.5);\n    float minimum = min(DE0, DE1);\n    if(minimum == DE0){\n        objectid = 1U;\n        return DE0;\n    }\n    if(minimum == DE1){\n        objectid = 2U;\n        return DE1;\n    }\n    objectid = 0U;\n    return -1.0;\n}\n\n// ##### INTERSECTION FUNCTIONS #####\n// Almost everything is from the great Inigo Quilez:\n// https://iquilezles.org/articles/intersectors\n// Sphere Intersection Function\nfloat sphere(vec3 raydir, vec3 rayori, vec3 sphpos, float sphrad){\n    vec3 oc = rayori-sphpos;\n    float b = dot(oc, raydir);\n    float c = dot(oc, oc)-sphrad*sphrad;\n    float h = b*b-c;\n    if(h < 0.0){return -1.0;}\n    h = sqrt(h);\n    return -b-h;\n}\n\n// Plane Intersection Function (with help from LoicVDB)\n// https://www.shadertoy.com/user/loicvdb\nfloat plane(vec3 raydir, vec3 rayori, vec3 point, vec3 norm){\n    float normdotp = dot(raydir, norm);\n    if(normdotp >= 0.0){return -1.0;}\n    return dot(point-rayori, norm)/normdotp;\n}\n\n// Scene Intersection Function\nfloat intersect(vec3 raydir, vec3 rayori, out vec3 norm, out uint objectid){\n    // Compute all intersections, and find the closest object\n    float int0 = plane(raydir, rayori, vec3(0.0), vec3(0.0, 1.0, 0.0));\n    float int1 = sphere(raydir, rayori, vec3(0.0, 0.5, 0.0), 0.5);\n    float minimum = min(int0, int1);\n    if(int0 <= 0.0){minimum = int1;}\n    if(int1 <= 0.0){minimum = int0;}\n\n    // Find the Normal and Intersection of the Nearest Object\n    if(minimum == int0){\n        norm = vec3(0.0, 1.0, 0.0);\n        objectid = 1U;\n        return int0;\n    }\n\n    if(minimum == int1){\n        norm = normalize((rayori+(raydir*int1))-vec3(0.0, 0.5, 0.0));\n        objectid = 2U;\n        return int1;\n    }\n\n    // NULL Object (just to be safe)\n    norm = vec3(0.0);\n    objectid = 0U;\n    return -1.0;\n}\n\n// ##### MATERIALS #####\nvoid getmat(in uint objectid, out vec3 albedo, out vec3 spec, out vec3 norm, out float rough){\n    if(objectid == 1U){\n        albedo = vec3(0.8);\n        norm   = vec3(0.0, 1.0, 0.0);\n        spec   = vec3(0.6);\n        rough  = 1.0;\n        return;\n    }\n    if(objectid == 2U){\n        albedo = vec3(0.8, 0.2, 0.2);\n        norm   = vec3(0.0, 1.0, 0.0);\n        spec   = vec3(0.6);\n        rough  = 1.0;\n        return;\n    }\n    albedo = vec3(0.0);\n    norm   = vec3(0.0);\n    spec   = vec3(0.0);\n    rough  = 0.0;\n    return;\n}*/\n\n// ##### COLOR MANAGEMENT #####\n// HDR to LDR Tonemapping\nvec3 tonemap(vec3 linearColor){\n    return pow(linearColor/(linearColor+1.0), vec3(1.0/gamma));\n}\n\n/*// All this is from LoicVDB:\nconst mat3 linear2acescg = mat3(\n    0.613117812906440, 0.341181995855625, 0.045787344282337,\n    0.069934082307513, 0.918103037508582, 0.011932775530201,\n    0.020462992637737, 0.106768663382511, 0.872715910619442);\nconst mat3 acescg2linear = inverse(linear2acescg);\n\nvec3 srgb2linear(vec3 c){\n    return pow(max(c, vec3(0.0)), vec3(gamma));\n}\n\nvec3 linear2srgb(vec3 c){\n    return pow(max(c, vec3(0.0)), vec3(1.0/gamma));\n}\n\nvec3 srgb2acescg(vec3 c){\n    return linear2acescg*srgb2linear(c);\n}\n\nvec3 acescg2srgb(vec3 c){\n    return linear2srgb(acescg2linear*c);\n}\n\nvec3 tonemapping(vec3 x){\n    // Probably not proper ACES, but it looks nice\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}*/\n\n// ##### ENVIRONMENT #####\n// LoicVDB's (Slightly Modified) Sky Functions\n// (I don't know where to link to other than his profile page, since this\n// is from a Fragmentarium shader he shared on the Marble Marcher Discord)\nfloat anisotropicWeight(vec3 dirI, vec3 dirO, float a){\n \treturn quarterpi*(1.0-a*a)/pow(1.0+a*(a-2.0*dot(dirI, dirO)), 1.5);\n}\n\nvec3 skyDirectLight(vec3 pos, int i){\n    if(dot(LightDirection, SkyUp) < 0.0){return vec3(0.0);}\n    vec3 volAbs = vec3(1.0), stepAbsRay, stepAbsMie;\n    float alt, dist, ds;\n    for(; i < SkySamples; i++){\n        alt = -log(1.0-sign(dot(LightDirection, SkyUp))*float(i)/float(SkySamples));\n    \tdist = alt/dot(LightDirection, SkyUp);\n        ds = exp(-dot(pos, SkyUp));\n        stepAbsRay = exp(-ds*dist*SkyColor*SkyIntensity);\n        stepAbsMie = exp(-ds*dist*MieIntensity*vec3(1.0));\n        volAbs *= stepAbsMie*stepAbsRay;\n        pos += LightDirection*dist;\n    }\n    return LightColor.rgb*LightColor*volAbs;\n}\n\nvec3 backgroundDirectLight(vec3 dir){\n\tif(dot(dir, LightDirection) < cos(LightRadius)){return vec3(0.0);}\n\tfloat sphericalCapArea = sin(LightRadius)*sin(LightRadius);\n\tfloat lightStrength = LightIntensity/(sphericalCapArea);\n\treturn lightStrength*LightColor.rgb;\n}\n\nvec3 skyScatter(vec3 dir, bool hasSun){\n    vec3 pos = vec3(0.0), volCol = vec3(0.0), volAbs = vec3(1.0);\n    vec3 stepAbsRay, stepAbsMie, stepColRay, stepColMie;\n    float alt, dist, ds;\n    float aw = anisotropicWeight(dir, LightDirection, MieAnisotropy);\n    for(int i = 0; i < SkySamples; i++){\n        alt = -log(1.0-sign(dot(dir, SkyUp))*float(i)/float(SkySamples));\n    \tdist = min(alt/dot(dir, SkyUp), 5.0);\n        ds = exp(-dot(pos, SkyUp));\n        stepAbsRay = exp(-ds*dist*SkyColor.rgb*SkyIntensity);\n        stepAbsMie = exp(-ds*dist*MieIntensity*vec3(1.0));\n        stepColRay = (1.0-stepAbsRay);\n        stepColMie = (1.0-stepAbsMie)*aw;\n        volCol += (stepColMie+stepColRay)*volAbs*skyDirectLight(pos, i);\n        volAbs *= stepAbsRay*stepAbsMie;\n        pos += dir*dist;\n    }\n    return volCol+(hasSun ? backgroundDirectLight(dir)*volAbs:vec3(0.0));\n}\n\n\n// ##### RNG #####\n// All of these are from Michael0884\n// https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = uint(iResolution.x*iResolution.y)*uint(iFrame)+uint(fragCoord.x+fragCoord.y*iResolution.x);\n\nvoid pcg(){\n    uint state = ns*747796405U+2891336453U;\n    uint word = ((state >> ((state >> 28U) + 4U)) ^ state)*277803737U;\n    ns = (word >> 22U) ^ word;\n}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffU);}\nvec2 rand2(){return vec2(rand(), rand());}\nvec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random\n// https://www.shadertoy.com/view/WttyWX\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x   ))*vec2(cos(twopi*Z.y), sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy ))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ####### RENDERING #######\n/* This tab contains all of the Rendering magic. */\n\n// ##### NOISE #####\n// Noise from Sampler (Place Noise Volume in iChannel1)\n/*float noise(vec3 coord){\n    float param = 0.5;\n    return saturate(abs(texture(iChannel1, coord*0.125).r-param)/max(param, 1.0-param));\n}*/\n\n// Volumetric Density Function\nvolumesample densityfunction(vec3 raypos){\n    float height = abs(raypos.y);\n    if(height > 0.6){return volumesample(0.0, vec3(0.0));}\n    float density = (fbm(raypos*0.5)-0.55)-(height*height);\n    return volumesample(max(density*512.0, 0.0), vec3(0.95));\n}\n\n// Path-Tracing\nvec3 pathtrace(vec3 raydir, vec3 rayori){\n    // Set-Up Variables\n    vec3 raypos = rayori, attenuation = vec3(1.0);\n    float disttrav = 0.0, adaptivestep = 0.0;\n    uint bounces = 0U;\n\n    // Perform Ray-Marching\n    for(uint i = 0U; i < maxmarches; i++){\n        if(length(raypos.xz) > scenesize || abs(raypos.y) > 2.0 || disttrav > maxdist){break;}\n        if(bounces > maxbounces){return vec3(0.0);}\n        volumesample density = densityfunction(raypos);\n        float absorbance = exp(-density.density*(stepsize+adaptivestep));\n        if(absorbance < rand()){\n            attenuation *= saturate(density.color*scattering);\n            raydir = normalize(nrand3(1.0, vec3(0.0)));\n            bounces++;\n        }\n        raypos += raydir*(stepsize+adaptivestep);\n        disttrav += (stepsize+adaptivestep);\n        adaptivestep = max((length(raypos.xz)/10.0)-5.0, 0.0)*rand();\n    }\n    return skyScatter(raydir, true)*attenuation;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Progressive Rendering\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0){oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}\n    fragColor = oldFragColor;\n    if(iMouse.z > 0.0){fragColor = vec4(0.0);}\n\n    // Initialize RNG\n    INIT_RNG;\n\n    // Set up Screen UV Coordinates\n    vec2 uv = 2.0*(nrand2(0.5, fragCoord.xy)-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n    // Mouse Controls\n    //vec2 mouse = vec2(-pi*0.9, 0.0);\n    vec2 mouse = mousesensitivity*(iMouse.xy-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n    // Calculate the Direction of the Ray\n    vec3 camtarget = vec3(0.0, 0.5, 0.0);\n    vec3 campos = vec3(-sin(mouse.x)*4.0, 0.5, -cos(mouse.x)*4.0);\n    vec3 targetdir = normalize(camtarget-campos);\n    vec3 left = cross(targetdir, vec3(0.0, 0.5, 0.0));\n    vec3 up = cross(left, targetdir);\n    mat3 rotmat = mat3(left, up, targetdir);\n    vec3 raydir = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Render the Image\n    vec3 color = pathtrace(raydir, campos);\n\n    // Output the Image to the Screen\n    fragColor += vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ####### IMAGE EXPORT #######\n/* This tab is for exporting a 32-Bit per Channel OpenEXR Image.\nTo export, click on the little Image icon at the bottom right of the editor. */\n\n// Output the Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Get the Rendered Image\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // Convert the Image to a Final State\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n\n    // Output the Image\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}