{
    "Shader": {
        "info": {
            "date": "1712428265",
            "description": "Tinkering with mandelbrot mapping",
            "flags": 0,
            "hasliked": 0,
            "id": "lfKGzh",
            "likes": 22,
            "name": "Tinkering with mandelbrot mappin",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 335
        },
        "renderpass": [
            {
                "code": "// CC0: Tinkering with mandelbrot mapping\n\n// Added a truchet variant for Paul\n//#define TRUCHET\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nvec3 palette(float a){\n  return (1.+(sin(vec3(0., 1., 2.)+a)));\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6;\n  float a = 2.51;\n  float b = 0.03;\n  float c = 2.43;\n  float d = 0.59;\n  float e = 0.14;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec3 effect(vec2 p) {\n  const float MaxIter = 22.;\n#ifdef TRUCHET\n  const float zz= 0.125;\n#else\n  const float zz= 0.25;\n#endif\n  const float b = 0.1;\n  \n  vec2 op = p;\n  p.x = pabs(p.x, 0.125);  \n  p = p.yx;\n  vec3 col = vec3(0.);\n  vec2 center = vec2(-0.4, 0.);\n  vec2 c = center+p*0.5;\n  vec2 z = c;\n\n  vec2 z2;\n\n  float s = 1.;\n  float i = 0.;\n  for (; i < MaxIter; ++i) {\n    z2 = z*z;\n    float ss = sqrt(z2.x+z2.y);\n    if (z2.x+z2.y > 1E3) break;\n    s *= 2.;\n    s *= ss;\n    z = vec2(z2.x-z2.y, 2.*z.x*z.y)+c;\n  }\n\n  vec2 p2 = z/zz;\n  float a = 0.1*TIME;\n  p2 *= ROT(a);\n  p2 += sin(vec2(1., sqrt(0.5))*a*b)/b;\n\n#ifdef TRUCHET\n  float fo = 1E-3+7E-3*s*s;\n  vec2 n2 = round(p2);\n  vec2 c2 = p2-n2;\n  float h = hash(n2);\n  if (h > 0.5) c2 = vec2(c2.y, -c2.x);\n  \n  float gd0 = length(c2-0.5)-0.5;\n  float gd1 = length(c2+0.5)-0.5;\n  float gd = min(gd0, gd1);\n  gd = abs(gd);\n  gd -= fo;\n#else\n  float fo = 1E-3+s*3E-3;\n  vec2 c2 = p2;\n  hextile(c2);\n\n  float gd0 = length(c2)-0.25;\n  float gd1 = abs(c2.y);\n  const vec2 n2 = ROT(radians(60.))*vec2(0.,1.);\n  const vec2 n3 = ROT(radians(-60.))*vec2(0.,1.);\n  float gd2 = abs(dot(n2, c2));\n  float gd3 = abs(dot(n3, c2));\n  gd1 = min(gd1, gd2);\n  gd1 = min(gd1, gd3);\n  float gd = gd0;\n  gd = pmax(gd, -(gd1-0.025), 0.075);\n  gd = min(gd, gd1);\n  gd = abs(gd);\n  gd -= fo;\n#endif\n  float f = i-log2(log2(dot(z2, z2)));\n\n  if (i < MaxIter) {\n  } else {\n    float gf = 1E-2/max(gd, fo);\n#ifdef TRUCHET\n#else\n    gf *= sqrt(gf);\n#endif    \n    col += gf*palette(TIME+(p2.x-p2.y)+op.x);\n  }\n\n  col = aces_approx(col);\n  col = sqrt(col);\n  \n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n  \n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}