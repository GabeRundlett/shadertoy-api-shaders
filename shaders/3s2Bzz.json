{
    "Shader": {
        "info": {
            "date": "1589627218",
            "description": "Relax, we'll see the vast ocean again.\n(control the lightsource with mouse)",
            "flags": 64,
            "hasliked": 0,
            "id": "3s2Bzz",
            "likes": 22,
            "name": "Neon Jellyfish",
            "published": 3,
            "tags": [
                "waves",
                "sea",
                "volumetric",
                "jellyfish",
                "vacation"
            ],
            "usePreview": 0,
            "username": "friol",
            "viewed": 933
        },
        "renderpass": [
            {
                "code": "\n//\n// friol 2o2o\n// This time I wanted to do something more immediate\n// I started modeling a jellyfish and then added godrays \n// The technique described in this article helped a lot for volumetric light:\n// https://blog.demofox.org/2020/05/10/ray-marching-fog-with-blue-noise/\n// some sdf functions by iq\n// Music by Ashamaluevmusic\n// 16/5/2020: switched to a better noise function by iq\n//\n\nconst int sdfIterationsAmount=128;\nconst int GODRAYS_RAYMARCH_STEPS=16; // higher gives more accurate volumetrics, but is slower\n\nvec3 sunPos=vec3(0.0,20.,18.0);\n\nvec3 rotx(in vec3 p, float a) \n{\n\treturn vec3(p.x,\n                cos(a) * p.y + sin(a) * p.z,\n                cos(a) * p.z - sin(a) * p.y);\n}\n\nvec3 roty(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotz(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\n//\n//\n//\n\nfloat noise(in vec2 p)\n{\n    float height = mix(texture(iChannel0, p / 810.0, -100.0).x,1.0,0.85);\n    float height2 = mix(texture(iChannel1, p / 700.0, -200.0).x,0.0,-3.5);\n    return height2-height-0.179;\n}\n\nfloat iqnoise2( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//\n//\n//\n\nfloat sdSeaBox( vec3 p, vec3 b )\n{\n    float ns=getwaves(p.xz*0.1,iTime);\n    p.y-=ns/1.0;\n\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n    return dot(p,n.xyz) + n.w;\n}\n\n// by the demogroup mercury - https://mercury.sexy/hg_sdf/\nvec2 pModPolar(inout vec2 p, float repetitions, float fix) {\n\tfloat angle = 2.0*3.141592/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - (angle/2.)*fix;\n\tp = vec2(cos(a), sin(a))*r;\n\n\treturn p;\n}\n\nfloat sdTentacles( vec3 p, float xb )\n{\n    //p=rotx(p,3.141592);\n    p.y+=3.1;\n    //p=roty(p,(p.y*sin(iTime)*.02));\n    //p.x/=.82-(p.y*0.01);\n    //p=rotz(p-vec3(.2,.0,0.0),1.0*(sin(sin(iTime)*1.0*p.y+iTime/2.0)));\n    p.xy+=.104*(sin(-iTime-p.y*2.0))*sin(iTime*1.0);  \n    //p=p-vec3((.1*p.y*(sin(iTime)))*.4,0.0,0.0);\n    p=p-vec3(1.0-p.y/5.0,0.0,0.0);\n\n    float height=3.0*(0.8+0.25*sin(iTime+3.151592));    \n    p.y-=3.0-height;\n\n    float divvv=32.0*xb;\n    vec3 q = abs(p) - vec3(p.y/divvv,height,p.y/divvv);\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//\n//\n//\n\nfloat mapHemisphere(vec3 p,vec3 jfpos)\n{\n    vec3 medusaCenter=vec3(.0,0.0,0.0);\n    \n    p-=jfpos;\n    p.y*=0.8+0.25*sin(iTime+3.151592);\n    p.x*=1.15+.03*(cos(iTime));\n    \n\t//bool s = (abs(p.z) > abs(p.x));\n    //float rangle=mix(3.141592/2.0 + atan(p.z,p.x), atan(p.x,p.z), s);\n    float rangle=atan(abs(p.z),p.x);\n    //rangle+=0.1;\n    \n    //float rangle=atan(abs(p.z)/-p.x);\n    //p.x+=0.5+.01*sin(rangle*3.141592*12.0);\n    float d=distance(p.xz,medusaCenter.xz);\n    //p.y+=0.1*sin(d);\n    //p.y-=0.2*d+.4*sin(iTime);\n    \n    if ((p.y)>abs(0.26+0.04*sin((iTime/14.0+rangle)*3.141592*8.05)))\n    {\n        float rad=1.2+abs(cos(abs(p.y))*sin(abs(p.y)));\n        rad+=.162*sin(rangle*3.141592*3.0);\n        rad+=sin(3.141592*d*1.5-iTime*4.0)*0.032; // pump\n        return (length(p)-rad);\n    }\n    \n    return 10000.0;\n}\n\nfloat mapTentacles(vec3 r)\n{\n    float t=100000.0;\n\n    pModPolar(r.xz,11.0,1.0);\n    float cap=sdTentacles(r-vec3(-.02,.5+.1*sin(iTime),.0),2.0);\n    t=min(t,cap);\n    \n    return t;\n}\n\nfloat mapJelly(vec3 r,vec3 jfpos)\n{\n    float t=10000.0;\n    //vec3 jfpos=vec3(0.1*sin(iTime),(jellyy+8.0)+cos((iTime/8.0)+3.141592)*4.0,29.0);\n    float hemi=mapHemisphere(r,jfpos);\n    float tent=mapTentacles(r-jfpos);\n    t=min(t,hemi);\n    t=min(t,tent);\n\n    return t;\n}\n\nvec2 SDFMainScene(vec3 r)\n{\n    vec3 origR=r;\n    float t=10000.0;\n\n    float seaPlane=sdSeaBox(r-vec3(0.0,12.2,0.0),vec3(10000.0,.002,10000.0));\n    t=min(t,seaPlane);\n    \n    /*vec3 c=vec3(16.0,20.0,80.0);\n    r = mod(r+0.5*c,c)-0.5*c;*/\n\n    float jelleyfish1=mapJelly(r,vec3(0.1*sin(iTime),cos((iTime/8.0)+3.141592)*4.0,8.0));\n    t=min(t,jelleyfish1);\n\n\tfloat jelleyfish2=mapJelly(r,vec3(-7.5,(-5.0+sin((iTime+3.141592)/6.0)*16.0),33.0));\n    t=min(t,jelleyfish2);\n\n\tfloat jelleyfish3=mapJelly(r,vec3(9.0,(-8.0+abs(sin((iTime+3.141592*0.666)/6.0))*16.0),33.0));\n    t=min(t,jelleyfish3);\n\n\tfloat jelleyfish4=mapJelly(r,vec3(-7.5,(-5.0+sin((iTime+3.141592)/6.0)*16.0),13.0));\n    t=min(t,jelleyfish4);\n\n\tfloat jelleyfish5=mapJelly(r,vec3(9.0,(-8.0+abs(sin((iTime+3.141592*0.666)/6.0))*16.0),13.0));\n    t=min(t,jelleyfish5);\n    \n    if (t==seaPlane) return vec2(t,2.0);\n    else if ((t==jelleyfish1)||(t==jelleyfish2)||(t==jelleyfish3)||(t==jelleyfish4)||(t==jelleyfish5)) return vec2(t,1.0);\n\n    return vec2(-1.0,-1.0);\n}\n\nvec2 SDFScatteringGrid(vec3 r)\n{\n    vec3 origR=r;\n    float t=1000.0;\n\n    /*r.x+=iTime;\n    r.z+=iTime;\n    vec3 c=vec3(4.0);\n    r.xz = mod(r.xz+0.5*c.xz,c.xz)-0.5*c.xz;*/\n    \n\t//float abox=sdBox(r-vec3(0.0,2.2,0.0),vec3(1.2,1.2,1.2));\n\t//float abox=sdSphere(r-vec3(hash13(r),2.2,0.0),hash13(r)*2.6);\n    //t=min(t,abox);\n    \n    //if (t==abox) return vec2(t,5.0);\n    //if (t==abox)     return vec2(hash13(r),5.0);\n\n\tfloat jelleyfish1=mapJelly(r,vec3(0.1*sin(iTime),cos((iTime/8.0)+3.141592)*4.0,8.0));\n    t=min(t,jelleyfish1);\n\n\tfloat jelleyfish2=mapJelly(r,vec3(-7.5,(-5.0+sin((iTime+3.141592)/6.0)*16.0),33.0));\n    t=min(t,jelleyfish2);\n\n\tfloat jelleyfish3=mapJelly(r,vec3(9.0,(-8.0+abs(sin((iTime+3.141592*0.666)/6.0))*16.0),33.0));\n    t=min(t,jelleyfish3);\n\n\tfloat jelleyfish4=mapJelly(r,vec3(-7.5,(-5.0+sin((iTime+3.141592)/6.0)*16.0),13.0));\n    t=min(t,jelleyfish4);\n\n\tfloat jelleyfish5=mapJelly(r,vec3(9.0,(-8.0+abs(sin((iTime+3.141592*0.666)/6.0))*16.0),13.0));\n    t=min(t,jelleyfish5);\n    \n    float plane=sdPlane(r-vec3(0.0,10.,0.0),vec4(0.0,-1.0,0.0,1.0));\n    t=min(t,plane);\n\n    if ((t==jelleyfish1)||(t==jelleyfish2)||(t==jelleyfish3)||(t==jelleyfish4)||(t==jelleyfish5)) return vec2(t,1.0);\n    if (t==plane) return vec2(t,5.0);\n    \n    return vec2(-1.0,-1.0);\n}\n\n//\n//\n//\n\nvec3 fog(vec3 c, float dist, vec3 fxcol)\n{\n    float FOG_DENSITY = 0.035;\n    vec3 FOG_COLOR = fxcol.xyz;\n    \n    float fogAmount = 1.0 - exp(-dist * FOG_DENSITY);\n        \n    return mix(c, FOG_COLOR, fogAmount);\n}\n\nvec3 Sky( vec3 ray )\n{\n\treturn mix( vec3(.2), vec3(0), exp2(-(1.0/max(ray.y,.01))*vec3(.3,.6,1.0)) );\n}\n\nvec3 traceSun(vec3 dir,vec3 l) \n{\n\tfloat sun = dot(dir,l);\n\tsun+=1.; \n    sun*=.498; \n    sun= pow(sun,64.0);\n\treturn vec3(sun)*vec3(0.7413,0.65,0.8);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3(( mod(float((i+3)/2),2.0) ),(mod(float(i/2),2.0)),(mod(float(i),2.0)))-1.0);\n        n += e*SDFMainScene(pos+0.0005*e)[0];\n    }\n    return normalize(n);\n}\n\nvec3 calcNormalScattering(vec3 pos)\n{\n\tvec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3(( mod(float((i+3)/2),2.0) ),(mod(float(i/2),2.0)),(mod(float(i),2.0)))-1.0);\n        n += e*SDFScatteringGrid(pos+0.0005*e)[0];\n    }\n    return normalize(n);\n}\n\n// returns 1.0 - light blocked by noise, 666.0 light blocked by jelley, 999.0 light reached\nfloat scatteringRay(vec3 rayOrigin,vec3 rayDir)\n{\n    float t=0.0;\n    bool hit=false;\n    vec2 res;\n    \n    for (int i=0;i<sdfIterationsAmount;i++)\n    {\n        res = SDFScatteringGrid(rayOrigin + rayDir * t);\n        if ((res[0]!=-1.0)&&(res[0] < (0.001*t)))\n        {\n            hit=true;\n            break;\n        }\n\n        t += res[0];\n    }\n\n    if (res[1]==1.0) return 666.0;\n    //if (res[1]==5.0) return fract(noise((rayOrigin+rayDir*t).xz-(iTime/4.0)))<0.35761?1.0:999.0;\n    if (res[1]==5.0) return fract(iqnoise2((rayOrigin+rayDir*t).xyz-(iTime/4.0)))<0.2861?1.0:999.0;\n    return 999.0;\n}\n\nvec3 castRay(vec3 rayOrigin, vec3 rayDir,out float accum )\n{\n    accum=0.0;\n    float t=0.0;\n    bool hit=false;\n    vec2 res;\n    \n    for (int i=0;i<sdfIterationsAmount;i++)\n    {\n        res = SDFMainScene(rayOrigin + rayDir * t);\n        //if (t>=maxDistance) return vec3(-1.0);\n        if (res[0] < (0.001*t))\n        {\n            hit=true;\n            break;\n        }\n\n        t += res[0]*.5;\n       \taccum += 0.015; \n        //t+=res[0];\n    }\n    \n    if (hit==false) return vec3(-1.0);\n    \n    const int rayMarchSteps=GODRAYS_RAYMARCH_STEPS;\n    float totalRayLight=0.0;\n    vec3 pHit=rayOrigin+t*rayDir;\n\n    float startRayOffset = hash13(pHit);\n    for (int s=0;s<rayMarchSteps;s++)\n    {\n        vec3 marchingPoint = rayOrigin + (rayDir * t * ((float(s)+startRayOffset) / float(rayMarchSteps)));\n        \n        float lightContrib=scatteringRay(marchingPoint,normalize(sunPos-marchingPoint));\n        if (lightContrib==999.0)\n        {\n            totalRayLight+=(1.0/float(rayMarchSteps));\n        }\n        else if (lightContrib==666.0)\n        {\n            totalRayLight=clamp(totalRayLight-(2.0/float(rayMarchSteps)),0.0,1.0);\n        }\n    }\n\n    return vec3(t,res[1],totalRayLight);\n}\n\n// beautiful dust function by Yilin Yan - https://www.shadertoy.com/user/greenbird10\nvec2 bubble(vec2 uv, float scale) {\n    if(uv.y > 0.2) return vec2(0.);\n    float t = iTime/4.;\n    vec2 st = uv * scale;\n    vec2 _st = floor(st);\n    vec2 bias = vec2(0., 4. * sin(_st.x*128. + t));\n    float mask = smoothstep(0.1, 0.2, -cos(_st.x*128. + t));\n    st += bias;\n    vec2 _st_ = floor(st);\n    st = fract(st);\n    float size = noise(_st_)*0.07+0.01;\n    vec2 pos = vec2(noise(vec2(t, _st_.y*64.1)) * 0.8 + 0.1, 0.5);\n    if(length(st.xy - pos) < size) {\n        return (st + pos) * vec2(.1, .2) * mask;\n    }\n    return vec2(0.);\n}\n\nvec4 render(vec3 rayOrigin, vec3 rayDir, vec2 uv, vec2 fragCoord)\n{\n    vec3 fogColor=vec3(0.02,0.1,0.2);\n    vec3 col=vec3(0.);\n    vec3 L=normalize(vec3(0.33,.201,-1.0));\n    \n    float accum=0.0;\n    vec3 rayHit = castRay(rayOrigin, rayDir,accum);\n    float mat=rayHit[1];\n    vec3 pHit=rayOrigin+rayDir*rayHit[0];\n    \n    vec3 N=calcNormal(pHit);\n    float dotprod=max(dot(N,L),0.0);\n    //float NoR = -dot(N, rayDir);\n    //NoR = max(NoR, 0.0);    \n    //vec3 R=reflect(rayDir,N);\n    //vec4 ref=reflekkt(pHit,R,uv,fragCoord);\n\n    if (mat==1.0) // jellEyfishes\n    {\n        vec3 q=N;\n        vec2 matuv = vec2( atan(N.x,N.z), acos(N.y ) );\n        \n        col+=vec3(0.0,1.6,3.0)*vec3(accum)*(1.862-exp(1.0-pow(rayHit[0], 3.0)));;\n        //col+=vec3(0.1);\n    \tcol*=accum*1.5*vec3(.24,0.1,0.24);\n\n        vec2 qp = (matuv);\n        float intensity=sin(qp.y*32.0);\n        if ((intensity>=.71)&&(N.y<1.1))\n        {\n            float tt=-iTime+3.141592/8.0;\n            //tt*=.5;\n            col*=vec3(.5,0.5,0.5);\n            if ((N.y>=cos(-tt))&&(N.y<cos(-tt-0.31)))\n            {\n                col/=2.*mix(col,vec3(0.22,0.92,0.92)*(abs(N.y)*abs(cos(tt)))*abs(N.y-1.0),0.1);\n            }\n        }\n        \n        col=fog(col,distance(rayOrigin,pHit),fogColor);\n        //col=vec3(0.0);\n    }\n    else if (mat==2.0) // sea\n    {\n        col=vec3(0.24,0.436,0.746)*vec3(accum*1.5)*(0.22-exp(1.-rayHit[0]));;\n        //dotprod=pow(dotprod,22.0);\n        //col=vec3(0.224,0.536,0.946)*dotprod;//*(0.22-exp(1.-rayHit[0]));;\n        //col/=Sky(rayDir);\n        vec3 refRay=refract(rayDir,N,0.92);\n        col+=traceSun(refRay,normalize(sunPos));\n        float d=distance(pHit,rayOrigin);\n        //if (d>210.0) col/=d*0.2*iTime*0.2;\n        //col=vec3(1.0,0.0,0.0);\n        col*=distance(pHit,rayOrigin)*.2;\n        col=fog(col,distance(pHit,rayOrigin),fogColor);\n    }\n    /*else if (mat==5.0) // debug\n    {\n        vec3 N=calcNormalScattering(pHit);\n        vec3 theL=normalize(vec3(-0.33,-2.2,-1.0));\n        float dp=max(dot(N,theL),0.0);\n        col=vec3(dp);\n    }*/\n    else\n    {\n        //if (rayDir.y>0.1) col=Sky(rayDir);\n        //if (abs(rayDir.y)<.000002) col+=traceSun(rayDir,normalize(vec3(2.0,.2,5.0)));\n        //col+=traceSun(rayDir,normalize(sunPos));\n        //col+=fogColor;\n        //if (distance(rayOrigin,pHit)<10.0) col/=accum;\n    }\n    \n    if (rayHit[2]>=0.0) col*=rayHit[2];\n    \n    col=pow(col,vec3(0.58));\n    return vec4(col,1.0);\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.,1.,0.), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n    return normalize(uv.x * camRight + uv.y * camUp + camForward * 2.0);\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    float fov=1.9;\n    vec2 result = fov*(screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float myTime=iTime/2.0;\n\tvec2 uv = normalizeScreenCoords(fragCoord);\n    uv += bubble(uv, 12.) + bubble(uv, 24.);\n\n    vec3 camPos,camTarget;\n\n    if (iMouse.z>0.0)\n    {\n    \tvec2 mousepos=(iMouse.xy-0.5*iResolution.xy)/iResolution.x;\n        sunPos.x=(mousepos.x)*40.0;\n        sunPos.z=15.0+(-mousepos.y)*40.0;\n    }\n    \n    //float fft = texture( iChannel2, vec2(0.0,0.00) ).x;\n\n    //camPos=vec3(0.0,-2.6,20.0);\n    //camTarget=vec3(0.0,-2.6,21.0);\n\n    \n    camPos=vec3(0.0,-2.6,0.0);\n    camTarget=vec3(0.0,-1.9,1.0);\n    \n    vec3 rayDir = getCameraRayDir(uv, camPos, camTarget);   \n    vec4 finalCol=vec4((render(camPos, rayDir,uv,fragCoord).xyz),1.0);\n\n    fragColor=vec4(finalCol.rgb, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 22732,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/ashamaluevmusic2/relaxing-ambient"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// wave functions by afl_ext - https://www.shadertoy.com/user/afl_ext\n\n#define ITERATIONS_RAYMARCH 12\n#define DRAG_MULT 0.048\n\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\n    float x = dot(direction, position) * frequency + timeshift * speed;\n    float wave = exp(sin(x) - 1.0);\n    float dx = wave * cos(x);\n    return vec2(wave, -dx);\n}\n\nfloat getwaves(vec2 position, float itm){\n\tfloat iter = 0.0;\n    float phase = 6.0;\n    float speed = 2.0;\n    float weight = 1.0;\n    float w = 0.0;\n    float ws = 0.0;\n    for(int i=0;i<ITERATIONS_RAYMARCH;i++){\n        vec2 p = vec2(sin(iter), cos(iter));\n        vec2 res = wavedx(position, p, speed, phase, itm);\n        position += normalize(p) * res.y * weight * DRAG_MULT;\n        w += res.x * weight;\n        iter += 12.0;\n        ws += weight;\n        weight = mix(weight, 0.0, 0.2);\n        phase *= 1.18;\n        speed *= 1.07;\n    }\n    return w / ws;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}