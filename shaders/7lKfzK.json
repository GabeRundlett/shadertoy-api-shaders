{
    "Shader": {
        "info": {
            "date": "1665230048",
            "description": "Pencils of plane cubics of the form LMN + kPⁿ for n = 0..3 and L,M,N,P equations of lines (L,M,N grey, P red). \n\nMove lines by dragging attached discs (N is fixed at y = 0).\n\nup/down zooms, left/right sets power of P, page up/down sets pencil density.\n",
            "flags": 48,
            "hasliked": 0,
            "id": "7lKfzK",
            "likes": 11,
            "name": "Cubic Pencils",
            "published": 3,
            "tags": [
                "curve",
                "pencil",
                "cubic"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 195
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Cubic Pencils, mla 2022\n//\n// Pencils of cubics of the form LMN + kPⁿ for n = 0..3 and \n// L,M,N,P equations of lines (L,M,N grey, P red). Move lines \n// by dragging attached discs (N is fixed at y = 0).\n//\n// For power of P = n:\n// n = 0: P is disregarded, curve intersects L,M,N only at infinity.\n// n = 1: curve intersects L,M,N where they intersect P\n// n = 2: curve is tangent to L,M,N where they intersect P\n// n = 3: curve has inflexion points where L,M,N intersect P\n// L,M,N are asymptotes for n <= 2\n//\n// up/down: zoom\n// left/right: set power of P\n// page up/down: set pencil density.\n// 's': hide control points\n// 't': hide control lines\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvec3 L,M,N,P;\n\nint n = 1; // Power of P\nint NN = 32; \n\n// (FGH)' = F'GH+F(GH)' = F'GH + FG'H + FGH'\nfloat cubic(vec3 p, float k) {\n  float Lp = dot(L,p);\n  float Mp = dot(M,p);\n  float Np = dot(N,p);\n  float Pp = dot(P,p);\n  float cosk = cos(k), sink = sin(k);\n  float t = cosk*Lp*Mp*Np - sink*ipow(Pp,n);\n\n  vec2 dxdy = cosk*(Lp*Mp*N.xy + Lp*M.xy*Np + L.xy*Mp*Np) - sink*float(n)*P.xy*ipow(Pp,n-1);\n  t /= length(dxdy);\n  return t;\n}\n\nvec3 mkline(vec2 p) {\n  return vec3(p,-dot(p,p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    setscale();\n    n = (1+keycount(KEY_RIGHT)-keycount(KEY_LEFT))%4;\n    float NN = float(abs(24+keycount(KEY_PAGE_DOWN)-keycount(KEY_PAGE_UP)));\n    assert(n >= 0);\n    float pwidth = scale*0.02;\n    float lwidth = scale*0.001;\n    vec3 p = vec3(map(fragCoord),1);\n    float px = fwidth(length(p.xy));\n    L = mkline(getselection(0));\n    M = mkline(getselection(1));\n    N = vec3(0,1,0); // x axis\n    //N = L; // cusped curves with n = 3.\n    P = mkline(getselection(2));\n    \n    float LMN = dot(L,p)*dot(M,p)*dot(N,p);\n    float k = LMN/ipow(dot(P,p),n);\n    //k = dot(p,p*p)/(p.x*p.y*p.z); // Hesse pencil\n    k = atan(k);\n    k /= PI; k += 0.5; k *= NN; k -= iTime;\n    k = round(k);\n    float k0 = k;\n    k += iTime; k /= NN; k -= 0.5; k *= PI;\n    float d = cubic(p,k);\n    float t = 16.0*d/scale;\n    vec3 col = vec3(0.2);\n    vec3 lcol = 0.2+0.8*h2rgb(k0/NN);\n    col = mix(lcol,col,smoothstep(0.0,1.0*px,abs(d)));\n    if (!key(CHAR_L)) {\n      float d = line(p,P);\n      if (n != 0) col = mix(vec3(1,0,0),col,smoothstep(0.0,px,d-0.5*lwidth));\n      d = line(p,L);\n      d = min(d,line(p,M));\n      d = min(d,line(p,N));\n      col = mix(vec3(0.75),col,smoothstep(0.0,px,d-0.5*lwidth));\n    }\n    if (!key(CHAR_S)) {\n      // Show point pair locations\n      float d = 1e8;\n      for (int i = 0; i < nselections; i++) {\n        if (n == 0 && i == 2) continue;\n        d = min(d,distance(p.xy,getselection(i)));\n      }\n      col = mix(vec3(0),col,0.25+0.75*smoothstep(0.0,px,d-pwidth));\n    }\n    col = pow(col,vec3(0.4545));\n    if (alert) col.r = 1.0;//col = 1.0-col;\n    // Output to screen\n    fragColor = vec4(col, 1.0);;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage(out vec4 t, vec2 uv) {\n  setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < scale*0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n      if (t.x <= 0.0 && iMouse.z > 0.0) t.zw = map(iMouse.xy); // Default selection\n    } else if (iFrame == 0 || t.w != 12345.0) {\n      t.xy = initselection(i-1); // Current coordinates\n      t.w = 12345.0; // Magic number\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store((key),0).x))\n#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\n#define map(screenpos) (scale*(2.0*(screenpos)-iResolution.xy)/iResolution.y)\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n#define getselected() (texelFetch(iChannel2,ivec2(0,3),0))\n#define setscale() (scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP))))\n#define defaultselection() (texelFetch(iChannel2,ivec2(0,3),0).zw)\n\nfloat scale = 3.0;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst int nselections = 3;\nvec2 initselection(int i) {\n  if (i == 0) return vec2(-0.5,0.5);\n  if (i == 1) return vec2(-2.5,0);\n  if (i == 2) return vec2(0.4,-1.0);\n  return vec2(0);\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n  return rgb;\n}\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nfloat line(vec3 p, vec3 q) {\n  return abs(dot(p,q)/(p.z*length(q.xy)));\n}\n\nfloat line(vec3 p, vec3 q, vec3 r) {\n  return line(p,cross(q,r));\n}\n\nfloat ipow(float x, int n) {\n float y = 1.0;\n for (int i = 0; i < n; i++) y*=x;\n return y;\n}\n\nfloat hcubic(vec3 p, float k) {\n  float A = dot(p*p,p);\n  float B = p.x*p.y*p.z;\n  float cosk = cos(k), sink = sin(k);\n  float t = cosk*A - sink*B;\n\n  vec2 dxdy = cosk*3.0*p.xy*p.xy - sink*p.yz*p.zx;\n  t /= length(dxdy);\n  return t;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}