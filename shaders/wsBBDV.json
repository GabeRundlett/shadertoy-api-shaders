{
    "Shader": {
        "info": {
            "date": "1591465666",
            "description": "Music is synthesized. Clouds too.",
            "flags": 40,
            "hasliked": 0,
            "id": "wsBBDV",
            "likes": 28,
            "name": "The dream of a red paper plane",
            "published": 3,
            "tags": [
                "sdf",
                "landscape",
                "plane",
                "paper",
                "cage"
            ],
            "usePreview": 1,
            "username": "friol",
            "viewed": 693
        },
        "renderpass": [
            {
                "code": "\n//\n// friol 2o2o\n// sdf funtions by iq\n//\n\n// by halcy\nvec3 hexablur(sampler2D tex, vec2 uv) \n{\n    vec2 scale = vec2(1.0) / iResolution.xy;\n    vec3 col = vec3(0.0);\n    float asum = 0.0;\n    float coc = texture(tex, uv).a;\n    for(float t = 0.0; t < 8.0 * 2.0 * 3.14; t += 3.14 / 32.0) {\n    \tfloat r = cos(3.14 / 6.0) / cos(mod(t, 2.0 * 3.14 / 6.0) - 3.14 / 6.0);\n        \n        // Tap filter once for coc\n        vec2 offset = vec2(sin(t), cos(t)) * r * t * scale * coc;\n        vec4 samp = texture(tex, uv + offset * 1.0);\n        \n        // Tap filter with coc from texture\n        offset = vec2(sin(t), cos(t)) * r * t * scale * samp.a;\n        samp = texture(tex, uv + offset * 1.0);\n        \n        // weigh and save\n        col += samp.rgb * samp.a * t;\n        asum += samp.a * t;\n        \n    }\n    col = col / asum;\n    return(col);\n}\n\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel1, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n\nfloat message(vec2 U,int w) \n{\n    vec4 T = vec4(0);\n    if (w==0) { C(116);C(104);C(101); }\n    if (w==1) { C(100);C(114);C(101);C(97);C(109); }\n    if (w==2) { C(111);C(102); }\n    if (w==3) { C(97); }\n    if (w==4) { C(114);C(101);C(100); }\n    if (w==5) { C(112);C(97);C(112);C(101);C(114); }\n    if (w==6) { C(112);C(108);C(97);C(110);C(101); }\n    return length(T.yz)==0. ? -1. : T.x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n\tvec2 screenPos = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // cinema bands\n    if ((screenPos.y<-0.9)||(screenPos.y>0.9)) { fragColor=vec4(0.0,0.0,0.0,1.0); return; }\n    \n    // the dream of a red paper plane\n    if ((iTime>=36.0)&&(iTime<44.0))\n    {\n        const float yadd=0.04;\n        float c=message((fragCoord/iResolution.y-vec2(1.4,.7+yadd))*vec2(8.,8.5),0);\n        if (c>0.8){fragColor=vec4(c*1.0,0.0,0.0,0.0);return;}\n        c=message((fragCoord/iResolution.y-vec2(1.28,.6+yadd))*vec2(8.,8.5),1);\n        if (c>0.8){fragColor=vec4(c*1.0,0.0,0.0,0.0);return;}\n        c=message((fragCoord/iResolution.y-vec2(1.47,.5+yadd))*vec2(8.,8.5),2);\n        if (c>0.8){fragColor=vec4(c*1.0,0.0,0.0,0.0);return;}\n        c=message((fragCoord/iResolution.y-vec2(1.53,.41+yadd))*vec2(8.,8.5),3);\n        if (c>0.8){fragColor=vec4(c*1.0,0.0,0.0,0.0);return;}\n        c=message((fragCoord/iResolution.y-vec2(1.405,.31+yadd))*vec2(8.,8.5),4);\n        if (c>0.8){fragColor=vec4(c*1.0,0.0,0.0,0.0);return;}\n        c=message((fragCoord/iResolution.y-vec2(1.28,.21+yadd))*vec2(8.,8.5),5);\n        if (c>0.8){fragColor=vec4(c*1.0,0.0,0.0,0.0);return;}\n        c=message((fragCoord/iResolution.y-vec2(1.28,.11+yadd))*vec2(8.,8.5),6);\n        if (c>0.8){fragColor=vec4(c*1.0,0.0,0.0,0.0);return;}\n    }\n    \n    // vignette\n\tvec2 uv2 = fragCoord.xy / iResolution.xy;\n    uv2 *=  1.0 - uv2.yx;\n    float vig = uv2.x*uv2.y * 38.0;\n    vig = pow(vig, 0.05);\n    \n    vec2 uv = fragCoord / iResolution.xy;\n\tfragColor = vec4(hexablur(iChannel0, uv)*vig, 0.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// clouds thanks to demofox - https://www.shadertoy.com/view/4tlBz8\n\nfloat hash21(vec2 p) {\n  return fract(sin(dot(p, vec2(425.215, 714.388)))*45758.5453);\n}\n\n#define NUM_STEPS 128\n#define NUM_NOISE_OCTAVES 3\n#define HEIGHT_OFFSET 1.25\n#define WHITE_NOISE_GRID_SIZE 128.0\n\n// from \"Hash without Sine\" https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 443.8975\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat BilinearInterpolateWhiteNoise (vec2 uv)\n{\n    uv = fract(uv);\n    \n    vec2 uvPixels = uv * WHITE_NOISE_GRID_SIZE;\n    \n    vec2 uvFrac = uvPixels - floor(uvPixels);\n    \n    vec2 uvDiscreteFloor = floor(uvPixels) / WHITE_NOISE_GRID_SIZE;\n    vec2 uvDiscreteCeil = ceil(uvPixels) / WHITE_NOISE_GRID_SIZE;\n    \n    float noise00 = hash12(vec2(uvDiscreteFloor.x, uvDiscreteFloor.y));\n    float noise01 = hash12(vec2(uvDiscreteFloor.x, uvDiscreteCeil.y ));\n    float noise10 = hash12(vec2(uvDiscreteCeil.x , uvDiscreteFloor.y));\n    float noise11 = hash12(vec2(uvDiscreteCeil.x , uvDiscreteCeil.y ));\n    \n    float noise0_ = mix(noise00, noise01, uvFrac.y);\n    float noise1_ = mix(noise10, noise11, uvFrac.y);\n    \n    float noise = mix(noise0_, noise1_, uvFrac.x);\n\n    return noise;\n}\n\nfloat RandomNumber(in vec3 position)\n{\n    vec2 uv = (position.xz+ceil(position.y))/float(NUM_STEPS);\n    return BilinearInterpolateWhiteNoise(uv);\n}\n\n// skybox\n\nfloat noise(in vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    f = f * f * (3. - 2. * f);\n    \n    float lb = hash21(i + vec2(0., 0.));\n    float rb = hash21(i + vec2(1., 0.));\n    float lt = hash21(i + vec2(0., 1.));\n    float rt = hash21(i + vec2(1., 1.));\n    \n    return mix(mix(lb, rb, f.x), \n               mix(lt, rt, f.x), f.y);\n}\n\nfloat fbm(in vec2 uv)\n{\n    float value = 0.;\n    float amplitude = .5;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        value += noise(uv) * amplitude;\n        amplitude *= .5;\n        uv *= 2.;\n    }\n    \n    return value;\n}\n\nvec3 Sky(in vec3 ro, in vec3 rd,float iTime,vec3 sundir)\n{\n    const float SC = 1e5;\n\n    float dist = (SC - ro.y) / rd.y; \n    vec2 p = (ro + dist * rd).xz;\n    p *= 1.2 / SC;\n    \n    vec3 lightDir = normalize(vec3(.1, .1, .3));\n    float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n    \n    vec3 colorSky=(iTime<52.0)?vec3(0.3,0.5,0.85):vec3(0.5,0.13,0.1);\n    vec3 colorHor=(iTime<52.0)?vec3(.25, .394, .572):vec3(.65, .25, .25);\n    \n    vec3 cloudCol = vec3(1.);\n    vec3 skyCol = colorSky - rd.y*rd.y*0.5;\n    skyCol = mix( skyCol, 0.85 * vec3(0.7,0.75,0.85), pow( 1.0 - max(rd.y, 0.0), 4.0 ) );\n    \n    vec3 sun = 0.25 * vec3(1.0,0.7,0.4) * pow( sundot,5.0 );\n    sun += 0.25 * vec3(1.0,0.8,0.6) * pow( sundot,64.0 );\n    sun += 0.2 * vec3(1.0,0.8,0.6) * pow( sundot,512.0 );\n    skyCol += sun;\n    \n    float t = -iTime * 0.1;\n    float den = fbm(vec2(p.x - t, p.y - t));\n    skyCol = mix( skyCol, cloudCol, smoothstep(.4, .8, den));\n    \n    skyCol = mix( skyCol, 0.88 * colorHor, pow( 1.0 - max(rd.y, 0.0), 16.0 ) );\n    \n    return clamp(skyCol,vec3(0.0),vec3(1.0));\n}\n\nvec3 nightSky(in vec3 ro, in vec3 rd,float iTime,vec3 moondir)\n{\n    const float SC = 1e5;\n\n    float dist = (SC - ro.y) / rd.y; \n    vec2 p = (ro + dist * rd).xz;\n    p *= 1.2 / SC;\n    \n    vec3 lightDir = normalize(vec3(.1, .1, .3));\n    float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n    \n    vec3 cloudCol = vec3(1.);\n    vec3 skyCol = vec3(0.01,0.05,0.07) - rd.y*rd.y*0.5;\n    skyCol = mix( skyCol, 0.35 * vec3(0.017,0.075,0.085), pow( 1.0 - max(rd.y, 0.0), 4.0 ) );\n    \n    float t = -iTime * 0.1;\n    float den = fbm(vec2(p.x - t, p.y - t));\n    skyCol = mix( skyCol, cloudCol, smoothstep(.6, .8, den));\n    \n    float cloudShade = 1.0 - smoothstep(0.2, 0.9 , den);\n    float moonDot = dot(lightDir, rd);\n    float moonA = smoothstep(0.9985, 0.999, moonDot);\t\t\n    skyCol += (moonA*cloudShade)*vec3(0.421,0.421,0.421);\n    skyCol += vec3(0.05) * smoothstep(0.91, 0.9985, moonDot); \n    \n    if (0.999*fbm(vec2(p.x*t*p.x*t, p.y*t*p.y * t))>0.91) skyCol+=vec3(1.0);\n    skyCol = mix( skyCol, 0.18 * vec3(.01, .01, .01), pow( 1.0 - max(rd.y, 0.0), 16.0 ) );\n    \n    return skyCol;\n}\n\n// wave functions by afl_ext - https://www.shadertoy.com/user/afl_ext\n\n#define ITERATIONS_RAYMARCH 12\n#define DRAG_MULT 0.048\n\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\n    float x = dot(direction, position) * frequency + timeshift * speed;\n    float wave = exp(sin(x) - 1.0);\n    float dx = wave * cos(x);\n    return vec2(wave, -dx);\n}\n\nfloat getwaves(vec2 position, float itm){\n\tfloat iter = 0.0;\n    float phase = 6.0;\n    float speed = 2.0;\n    float weight = 1.0;\n    float w = 0.0;\n    float ws = 0.0;\n    for(int i=0;i<ITERATIONS_RAYMARCH;i++){\n        vec2 p = vec2(sin(iter), cos(iter));\n        vec2 res = wavedx(position, p, speed, phase, itm);\n        position += normalize(p) * res.y * weight * DRAG_MULT;\n        w += res.x * weight;\n        iter += 12.0;\n        ws += weight;\n        weight = mix(weight, 0.0, 0.2);\n        phase *= 1.18;\n        speed *= 1.07;\n    }\n    return w / ws;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n// if you feel brave.\n//#define ANTIALIASED\n\nfloat sdSeaBox( vec3 p, vec4 n )\n{\n    float ns=getwaves(p.xz*0.1,iTime);\n    p.y-=ns/1.0;\n  \treturn dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdVertTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat sdPaperplane(vec3 r)\n{\n\tfloat paperplane;\t\n    r.x=-abs(r.x);\n    float lwing=udTriangle(r,vec3(0.0,0.5,0.8),vec3(-0.05,0.5,0.0),vec3(-0.25,0.5,0.0))-0.005;\n    //float rwing=udTriangle(r,vec3(0.0,0.5,0.8),vec3( 0.05,0.5,0.0),vec3( 0.25,0.5,0.0))-0.005;\n    float lbase=udTriangle(r,vec3(0.0,0.51,0.8),vec3(-0.05,0.5,0.0),vec3(0.0,0.35,0.0))-0.002;\n    //float rbase=udTriangle(r,vec3(0.0,0.51,0.8),vec3(0.0,0.35,0.0),vec3( 0.05,0.5,0.0))-0.002;\n    paperplane=min(lbase,lwing);\n    //paperplane=min(rwing,lwing);\n    //paperplane=min(paperplane,lbase);\n    //paperplane=min(paperplane,rbase);\n    return paperplane;\n}\n\n// by mercury\nfloat pModPolar(inout vec2 p, float repetitions)\n{\n\tfloat angle = 2.0*3.141592/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\treturn c;\n}\n\nvec2 SDFscene(vec3 r)\n{\n\tfloat t=999999.0;\n    \n    vec3 curpoint;\n    curpoint.x=sin(iTime)*0.2;\n    curpoint.y=-3.0+cos(iTime)*0.3;\n    if (iTime<28.0) curpoint.z=13.4+iTime-(iTime*0.06);\n    else curpoint.z=11.0+iTime;\n    r=r-vec3(curpoint.x,curpoint.y+2.0,curpoint.z);\n\n    t=sdPaperplane(r);\n\n    if (t!=999999.0) return vec2(t,1.0);\n    \n    return vec2(-1.0);    \n}\n\nvec2 SDFSeaScene(vec3 r)\n{\n\tfloat t=999999.0;\n\n    float seaplane=sdSeaBox(r,vec4(0.0,1.0,0.0,1.0));\n    t=min(t,seaplane);\n\n    vec3 curpoint;\n    curpoint.x=0.0;\n    if (iTime<65.0) curpoint.y=0.0;\n    else curpoint.y=1.5;\n    if (iTime<60.0) curpoint.z=8.0+iTime*10.0;\n    else if (iTime<65.0) curpoint.z=-58.0+iTime*10.0;\n    else curpoint.z=iTime*10.0;\n    r=r-vec3(curpoint.x,curpoint.y,curpoint.z);\n\n    float paperplane=sdPaperplane(r);\n    t=min(t,paperplane);\n    \n    if (t==paperplane) return vec2(t,1.0);\n    if (t==seaplane) return vec2(t,2.0);\n    \n    return vec2(-1.0);    \n}\n\nvec2 SDFCageScene(vec3 r,int traceMode)\n{\n\tfloat t=999999.0;\n    vec3 origR=r;\n\tconst float barDim=0.005;\n\n    // paperplane\n    if (traceMode==1)\n    {\n        r=r-vec3(0.0,0.0,-0.3+iTime-12.0);\n    }\n    else r=r-vec3(0.0,0.0,-0.3);\n    float paperplane=sdPaperplane(r);\n    t=min(t,paperplane);\n    \n    if ((t==paperplane)&&(traceMode==1)) return vec2(t,1.0);\n    \n    // floor\n    r=origR;\n    float floory=sdPlane(r-vec3(0.0,0.0,0.0),vec4(0.0,1.0,0.0,1.0));\n    t=min(t,floory);\n    \n    // cage structure\n    float base=sdRoundedCylinder(r-vec3(0.0,0.31,0.0),0.37,0.01,0.02);\n\tfloat minBase=sdRoundedCylinder(r-vec3(0.0,0.37,0.0),0.34,0.01,0.06);\n    base=max(-minBase,base);\n    t=min(t,base);\n    float upperCircle=sdTorus(r-vec3(0.0,1.21,0.0),vec2(0.7,barDim));\n    t=min(t,upperCircle);\n    float lowerCircle=sdTorus(r-vec3(0.0,0.7,0.0),vec2(0.7,barDim));\n    t=min(t,lowerCircle);\n    float upperHang=sdVertTorus(r-vec3(0.0,1.98,0.0),vec2(0.08,0.01));\n    t=min(t,upperHang);\n\n    //\n\n    r=origR;\n\tpModPolar(r.xz,12.0);\n    \n    float bar=sdVerticalCapsule(r-vec3(.7,.3,0.0),0.98,barDim);\n    t=min(t,bar);\n    \n\tfloat arc=sdCappedTorus(r-vec3(0.0,1.2,0.0),vec2(1.,.01),0.702,barDim);\n    t=min(t,arc);\n    \n    if (t==paperplane) return vec2(t,1.0);\n    if (t==bar) return vec2(t,3.0);\n    if (t==arc) return vec2(t,3.0);\n    if (t==upperCircle) return vec2(t,3.0);\n    if (t==lowerCircle) return vec2(t,3.0);\n    if (t==upperHang) return vec2(t,3.0);\n    if (t==base) return vec2(t,4.0);\n    if (t==floory) return vec2(t,5.0);\n    \n    return vec2(-1.0);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3(( mod(float((i+3)/2),2.0) ),(mod(float(i/2),2.0)),(mod(float(i),2.0)))-1.0);\n        n += (iTime<20.0)?e*SDFCageScene(pos+0.0005*e,0)[0]:\n        (iTime<52.0)?e*SDFscene(pos+0.0005*e)[0]:\n        (iTime<70.0)?e*SDFSeaScene(pos+0.0005*e)[0]:\n        e*SDFCageScene(pos+0.0005*e,0)[0];\n    }\n    return normalize(n);\n}\n\nvec2 rayMarch(vec3 rayOrigin, vec3 rayDir, out vec3 cloudColor,vec2 fragCoord, int traceMode)\n{\n    float t = 0.0;\n    vec3 pixelColor;\n    vec3 skyColor = vec3(0.9);\n\n    if ((iTime>20.0)&&(iTime<52.0))\n    {\n    \tfloat adder=((iTime>=36.0)&&(iTime<44.0))?(fract(hash12(rayDir.xz))*0.1):0.0;\n        for (int rayStep = 0; rayStep < NUM_STEPS; ++rayStep)\n        {\n            vec3 position = adder+0.05 * float(NUM_STEPS - rayStep) * rayDir;\n            position.z+=iTime;\n            float noiseScale=0.75;\n            float posMulty=((iTime>=28.0)&&(iTime<36.0))?0.35:1.25;\n            float signedCloudDistance = position.y+posMulty;\n            for (int octaveIndex = 0; octaveIndex < NUM_NOISE_OCTAVES; ++octaveIndex)\n            {\n                position *= 2.0;\n                noiseScale *= 2.0;\n                signedCloudDistance -= RandomNumber(position) / noiseScale;\n            }\n            if (signedCloudDistance < 0.0)\n                pixelColor+=(pixelColor-1.-signedCloudDistance * skyColor.zyx)*signedCloudDistance*0.15;\n        }\n\n        cloudColor=pixelColor;\n    }\n    \n    for (int i = 0; i < 128; i++)\n    {\n        vec2 res = (iTime<20.0)?SDFCageScene(rayOrigin + rayDir * t,traceMode):\n        \t(iTime<52.0)?SDFscene(rayOrigin + rayDir * t):\n        \t(iTime<70.0)?SDFSeaScene(rayOrigin + rayDir * t):\n        \tSDFCageScene(rayOrigin + rayDir * t,traceMode);\n        if (res[0] < (0.0001*t))\n        {\n            return vec2(t,res[1]);\n        }\n        t += res[0];\n    }\n     \n    return vec2(-1.0,-1.0);\n}\n\nvec3 fog(vec3 c, float dist, vec3 fxcol)\n{\n    float fogAmount = 1.0 - exp(-dist * .35);\n    return mix(c, fxcol, fogAmount);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = SDFCageScene( pos + h*nor,0 ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n/*\nvec3 reflekkt(vec3 rayOrigin,vec3 rayDir,vec2 fragCoord)\n{\n    vec3 finalColor=vec3(0.0);\n\tvec3 L = normalize( vec3(.1, .9, -.23 ));\n    vec3 cloudColor;\n\n    vec2 rayHit = rayMarch(rayOrigin, rayDir,cloudColor,fragCoord,0);\n    float dist=rayHit[0];\n    float mat=rayHit[1];\n    vec3 pHit=rayOrigin+rayDir*dist;\n\n    vec3 N=calcNormal(pHit);\n    float NoL = max(dot(N, L), 0.0);\n    \n    if (mat==1.0)\n    {\n        finalColor=vec3(NoL)*vec3(0.58,0.12,0.12);\n    }\n    else\n    {\n        vec3 sunPos=normalize(vec3(0.2,1.2,-1.0));\n    \tvec3 skyColor=Sky(pHit,reflect(rayDir,N),iTime,sunPos);\n        finalColor=skyColor;\n    }\n    \n    \n    return finalColor;\n}\n*/\n\nvec4 rayMarchCycle(vec3 rayOrigin, vec3 rayDir,vec2 fragCoord,out vec3 outPhit)\n{\n    vec3 col=vec3(0.);\n\tvec3 L = normalize( vec3(.1, .9, -.23 ));\n\n    vec3 finalColor=vec3(0.0);\n    vec3 cloudColor;\n    vec2 rayHit = rayMarch(rayOrigin, rayDir,cloudColor,fragCoord,0);\n    float dist=rayHit[0];\n    float mat=rayHit[1];\n    vec3 pHit=rayOrigin+rayDir*dist;\n    outPhit=pHit;\n    \n    vec3 N=calcNormal(pHit);\n    float NoL = max(dot(N, L), 0.0);\n    float ao=calcAO(pHit,N);\n\n    vec3 skyColor=Sky(pHit,(mat==2.0)?reflect(rayDir,N):rayDir,iTime,L);\n    vec3 darkSkyColor=nightSky(pHit,(mat==2.0)?reflect(rayDir,N):rayDir,iTime,L);\n    vec3 finSkyCol=skyColor;\n    \n    if (mat==1.0) // paper plane\n    {\n        finalColor=vec3(NoL)*vec3(0.58,0.12,0.12);\n    }\n    else if (mat==2.0) // sea plane sea scene/night\n    {\n        if ((iTime>=60.0)&&(iTime<65.0)) finSkyCol=mix(darkSkyColor,skyColor,(65.0-iTime)/5.0);\n        else if (iTime>=65.0) finSkyCol=darkSkyColor;\n\t\t//vec3 reflektCol=reflekkt(rayOrigin,rayDir,fragCoord);        \n        vec3 col=mix(vec3(pow(NoL,8.0))*vec3(0.01,0.01,0.02),finSkyCol,0.6);\n        finalColor=clamp(col,vec3(0.0),vec3(1.0));\n        // final fadeout\n        if (iTime>=65.0) finalColor=mix(finalColor,vec3(0.0),clamp((iTime-65.0)/3.0,0.0,1.0));\n    }\n    else if (mat==3.0) // cage bars\n    {\n        vec3 barCol=vec3(0.74);\n        finalColor=barCol.xyz*ao;\n        if (iTime>=70.0) finalColor=mix(vec3(0.0),finalColor,clamp((iTime-70.0),0.0,1.0));\n    }\n    else if (mat==4.0) // cage base\n    {\n        vec3 barCol=vec3(0.22);\n        //float d=distance(pHit,vec3(0.0));\n        //vec3 fgcol=fog(barCol,d,vec3(0.8));\n        finalColor=barCol.xyz*ao;\n        if (iTime>=70.0) finalColor=mix(vec3(0.0),finalColor,clamp((iTime-70.0),0.0,1.0));\n    }\n    else if (mat==5.0) // cage floor\n    {\n        float d=distance(pHit,vec3(0.0));\n        vec3 floorCol=vec3(0.01);\n        vec3 fgcol=fog(floorCol,d,vec3(0.8));\n        finalColor=fgcol.xyz;\n        if (iTime>=70.0) finalColor=mix(vec3(0.0),finalColor,clamp((iTime-70.0),0.0,1.0));\n    }\n    else if ((iTime<20.0)||(iTime>=70.0)) // cage scene\n    {\n        finalColor=vec3(0.8);\n    }\n    else\n    {\n        if ((iTime>=60.0)&&(iTime<65.0)) finSkyCol=mix(darkSkyColor,skyColor,(65.0-iTime)/5.0);\n        else if (iTime>=65.0) finSkyCol=darkSkyColor;\n        \n        finalColor=finSkyCol+cloudColor*0.85;\n\n        // final fadeout\n        if (iTime>=65.0) finalColor=mix(finalColor,vec3(0.0),clamp((iTime-65.0)/3.0,0.0,1.0));\n    }\n\n    // ghost mode\n    if ((iTime>12.0)&&(iTime<20.0))\n    {\n    \tvec2 rayHit = rayMarch(rayOrigin, rayDir,cloudColor,fragCoord,1);\n        if (rayHit[1]==1.0)\n        {\n            finalColor+=vec3(NoL)*vec3(0.58,0.12,0.12);\n        }\n    }\n    \n    return vec4(finalColor,-999999.0);    \n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 screenPos = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    screenPos.x=-screenPos.x;\n  \n    vec3 camPos;\n\tvec3 camTarget;\n    float camRot=0.0;\n \n    if (iTime<=20.0)\n    {\n    \tcamPos=vec3(0.0+sin(iTime)*2.0,2.2,(-2.0*3.141592-7.28+iTime*0.8)*cos(iTime*0.19));\n\t\tcamTarget = vec3(0.0,0.7,1.0);\n        if (iTime>12.0) camTarget=vec3(0.0,0.7,iTime-11.0);\n    }\n    else if ((iTime>=20.0)&&(iTime<28.0)) // on clouds\n    {\n        camPos=vec3(0.0,0.5+((27.0-iTime)*0.4),8.0+iTime);\n        camTarget=vec3(0.0,0.7,10.0+iTime);\n        camRot=sin(iTime*0.25)*0.1;\n    }\n    else if ((iTime>=28.0)&&(iTime<36.0)) // plane from bottom vs sky\n    {\n        camPos=vec3(-1.2,-1.8,10.0+iTime);\n        camTarget=vec3(0.0,-1.2,11.0+iTime);\n    }\n    else if ((iTime>=36.0)&&(iTime<44.0)) // upper plane\n    {\n        camPos=vec3(0.0,6.8-((iTime-36.0)/4.0),10.0+iTime);\n        camTarget=vec3(0.0,-1.2,12.0+iTime);\n    }\n    else if ((iTime>=44.0)&&(iTime<52.0)) // plane from below\n    {\n        camPos=vec3(0.0,-2.0,15.0+iTime);\n        camTarget=vec3(0.0,2.5,10.0+iTime);\n    }\n    else if ((iTime>=52.0)&&(iTime<60.0)) // around on water\n    {\n        camPos=vec3(0.0,8.3-(iTime-52.0)*0.5,iTime*10.0);\n        camTarget=vec3(0.0,2.5,8.0+iTime*10.0);\n        camRot=sin(-iTime*0.5)*0.1;\n    }\n    else if ((iTime>=60.0)&&(iTime<65.0))\n    {\n        //camPos=vec3(3.0*sin(-iTime/2.0),5.3-(iTime-35.0)*0.1,3.0*cos(-iTime/4.0)-35.0+iTime*10.0);\n        //camTarget=vec3(0.0,1.5,-33.0+iTime*10.0);\n       \tcamPos=vec3(3.0*sin(-iTime/2.0),5.3-(iTime-35.0)*0.1,3.0*cos(-iTime/4.0)-60.0+iTime*10.0);\n        camTarget=vec3(0.0,1.5,-58.0+iTime*10.0);\n     }\n    else if ((iTime>=65.0)&&(iTime<70.0))\n    {\n        camPos=vec3(2.0*sin(-iTime/2.0),4.3,3.0*cos(-iTime/4.0)+2.0+iTime*10.0);\n        camTarget=vec3(0.0,1.5,iTime*10.0);\n    }\n    else if ((iTime>=70.0))\n    {\n        camPos=vec3(2.0*sin(-iTime/2.0),2.8,1.5*cos(-iTime/4.0)+2.0);\n        camTarget=vec3(0.0,0.0,-0.3);\n    }\n     \n    mat3 ca = setCamera( camPos, camTarget, camRot );\n    vec3 rayDir = ca * normalize( vec3(screenPos.xy,1.5));\n    \n    vec3 outPhit;\n    \n    #ifdef ANTIALIASED\n    vec4 marchCol=vec4(0.0);\n    for (int i=0;i<4;i++)\n    {\n    \tvec3 rayDir = ca * normalize( vec3(screenPos.xy,1.5));\n\t\trayDir.x+=0.001*sin(3.141592*2.0*float(i)/4.0);\n\t\trayDir.y+=0.001*cos(3.141592*2.0*float(i)/4.0);\n    \tmarchCol+=rayMarchCycle(camPos, rayDir,fragCoord,outPhit);\n    }\n    marchCol/=4.0;\n    #else\n    vec4 marchCol=rayMarchCycle(camPos, rayDir,fragCoord,outPhit);\n    #endif\n    \n\tfloat depth = -dot(outPhit - camPos, normalize(camPos - camTarget));\n    float coc = 0.7 * abs(1.0 - length(camPos - camTarget) / depth);\n    vec4 finalCol;\n    if (iTime<6.28) finalCol=vec4(pow(marchCol.rgb,vec3(0.65)),max(0.01, min((6.28-iTime)*0.05, coc)));\n    else finalCol=vec4(pow(marchCol.rgb,vec3(0.65)),0.0001);\n    \n    fragColor = finalCol;\n    \n    if (iTime<2.0) fragColor=mix(vec4(0.0),fragColor,iTime/2.0);\n\tif ((iTime>=18.0)&&(iTime<20.0)) fragColor=mix(fragColor,vec4(1.0),(iTime-18.0)/2.0);\n\tif ((iTime>=20.0)&&(iTime<21.0)) fragColor=mix(vec4(1.0),fragColor,(iTime-20.0));\n\tif ((iTime>=50.0)&&(iTime<52.0)) fragColor=mix(fragColor,vec4(1.0),(iTime-50.0)/2.0);\n\tif ((iTime>=52.0)&&(iTime<53.0)) fragColor=mix(vec4(1.0),fragColor,(iTime-52.0));\n    if (iTime>=80.0) fragColor=mix(fragColor,vec4(0.0),clamp((iTime-80.0)/5.0,0.0,1.0));\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//\n// supersound\n//\n\nfloat frequencyFromNotenum( float n ) { return 440.0 * pow( 2.0, ( n-49.0) / 12.0 ); }\n\n// pads\n\nfloat pads(float t, float s) \n{\n    return mix(fract(t)*2.0-1.0, -sin(t*2.0*3.141592), s);\n}\n\nfloat phatsaw(float t, float form) {\n    float w = 0.0;\n    for (int i=0;i<4;i++) \n    {\n        w+= pads(t + sin(0.4*float(i))*0.2, form)*0.25;\n    }\n    return w;\n}\n\nfloat pitch(float p) \n{\n\treturn pow(1.059460646483, p) * 440.0;\n}\n\nfloat arp_pattern(float t) \n{\n    int tones[16] = int[](0,0,0,0,12,0,0,0,0,7,0,0,0,12,0,0);\n    float arp = 0.0;\n    float at = t;\n    int arpind = int(at*4.0) % 16;\n    float arpnote = float(tones[arpind]) + 0.0;\n    arp = pow(phatsaw(t*pitch(arpnote), 0.7 + sin(t*.2)*0.1), 3.0);\n    arp *= 0.7*(0.4 + sin(float(arpind)*3.0)*0.1)*max(0.4, -pads(at*6.0, 0.8));\n    return arp;\n}\n\n// saw\n\nvec2 ssaw( float t, float f )\n{\n    float m = fract( t * f );\n    vec2 s = vec2(\n        m + fract( t * f * 1.015 ) + 0.5 * fract( t * f * 0.98 ),\n        m + fract( t * f * 0.985 ) + 0.5 * fract( t * f * 1.02 )\n    );\n    s *= 0.08 * t;\n    return s;\n}\n\nfloat saw(float phase) \n{\n\tfloat s = 0.0;\n \n    for (float k = 1.0; k <= 8.0; k++) \n    {\n        s += (sin(2.0*3.141592*float(k)*phase) / float(k));\n    }\n    \n\treturn (1.0/2.0) - (1.0/3.141592)*s - 0.5;\n}\n\n// pad\n\nvec4 sqc( float time, float tick,float BPM )\n{\n\tvec4 s_t;\n\t\n\tfloat s = mod(floor(time/240.*BPM*float(2)),4.);\n\tfloat t = fract(time/240.*BPM*float(tick));\n\tfloat u = mod( floor( time/240.*BPM*float(tick)),tick );\n\tfloat v = floor(time/240.*BPM);\n\t\n\ts_t.x = s;\n\ts_t.y = t;\n\ts_t.z = u;\n\ts_t.w = v;\n\t\n\treturn s_t;\n}\n\nfloat jappad( float time,float semi,float BPM){\n\tfloat s = 0.0; float semitones[4];\n\tsemitones[0] = 0.0; semitones[1] = 4.0;\n\tsemitones[2] = 7.0; semitones[3] =9.0;\n\n\tconst int VOICES = 4;\n\t\n\t/*float t1 = mod(floor(time/240.*BPM*float(2)),4.);\n\tfloat t2 = fract(time/240.*BPM*float(2));\n\tfloat t3 = 1.0;\n\t*/\n\n    float main_seq[4];\n    if ((time<36.0)||(time>=68.0))\n    {\n\t\tmain_seq[0]=0.,main_seq[1]=0.,main_seq[2]=3.,main_seq[3]=3.;\n    }\n    else if (time<52.0)\n    {\n\t\tmain_seq[0]=5.,main_seq[1]=5.,main_seq[2]=7.,main_seq[3]=7.;\n    }\n    else\n    {\n\t\tmain_seq[0]=-5.,main_seq[1]=-5.,main_seq[2]=-7.,main_seq[3]=-7.;\n    }\n\n\tvec4 sq = sqc(time, .5,BPM);\n\n\tfor (int i = 0 ; i < 4; i++) {\n\t \n\t float q = mod(sq.w,4.);\n\t \n\t\t float f = pitch(semi+main_seq[int(q)]+(semitones[i]));\n\t\t \n\t\t const int UNISON = 8;\n\t\t for (int u = 0; u < UNISON-1; u++) {\n\t\t \n\t\t\t float fu = float(u);\n\t\t\t float new_f = f + fu * sin(fu);\n\t\t\n             float t1=mod(time,16.);\n\t\t\t s += saw(t1 * new_f) * (1.0/float(UNISON))\n\t\t\t * (1./float(VOICES))\n\t\t\t *min(1., sq.y*6.)\n\t\t\t *max(0., 1.5-sq.y)\n\t\t\t ;\n\t\t }\n\t }\n\n\t return s;\n}\n\n// kickkkk\n\nfloat kick(float t)\n{\n\treturn sin(315.*t-10.*exp(-50.*t))*exp(-t*3.0);;\n}\n\n// bazz\n\n// parm1 to 0.5 amd parm2 to 0.9\nvec2 bass(float time, float tt, float freq, float parm1,float parm2)\n{\n    float freqTime = 6.2831*time*freq;\n    parm1=0.5; parm2=0.9;\n    \n    return vec2(( sin(     freqTime\n                      +sin(freqTime)*7.0*exp(parm1*tt)\n                     )+\n                  sin(     freqTime*2.0\n                      +cos(freqTime*2.0)*1.0*sin(time*3.14)\n                      +sin(freqTime*8.0)*0.25*sin(1.0+time*3.14)\n                    )*exp(parm2*tt)+\n                  cos(     freqTime*4.0\n                      +cos(freqTime*2.0)*3.0*sin(time*3.14+0.3)\n                    )*exp(-2.0*tt)\n                )\n                \n                *exp(-1.0*tt) );\n}\n\n// hihat\n\nvec2 hihat(float time,float panning)\n{\n    float tb = mod(time,(60.0/120.0)*1.0);\n    float hihat=(fract(cos(time * 32234.523) * 134.) * exp(mod(tb, 1. / 2.0) / 2.0 * -120.)*(fract(tb) + .2));\n\n    float tbr = mod(time+0.135,(60.0/120.0)*1.0);\n    float hihatr=(fract(cos((time+0.135) * 32234.523) * 134.) * exp(mod(tbr, 1. / 2.0) / 2.0 * -120.)*(fract(tbr) + .2));\n    hihat+=hihatr*0.5;\n    \n    float tb2 = mod(time+0.25,(60.0/120.0)*1.0);\n    float hihat2=(fract(cos((time+0.25) * 32234.523) * 134.) * exp(mod(tb2, 1. / 2.0) / 2.0 * -120.)*(fract(tb2) + .2));\n    hihat2*=0.5;\n    return vec2(\n        (hihat*panning)+(hihat2*(1.0-panning)),\n        hihat*(1.0-panning)+hihat2*panning)*.55;\n}\n\n//\n// simple blip with reverb\n//\n\nfloat simpleBlip( float freq, float time )\n{    \n    float y = 0.70*sin(6.2831*freq*time)*exp(-0.009*freq*time);\n    y += 0.20*sin(2.01*6.2831*freq*time)*exp(-0.007*freq*time);\n    y += 0.16*sin(4.01*6.2831*freq*time)*exp(-0.004*freq*time);\n    y *= clamp( time/0.004, 0.0, 1.0 );\n\treturn y;\t\n}\n\nvec2 blipArp(float time)\n{\n    int seqNumNotes=8;\n    float noteseq[8]=float[](37.0,42.0,37.0,42.0,42.0,37.0,33.0,16.0);\n\n    time=mod(time*0.5,float(seqNumNotes));\n    vec2 finalSound=vec2(0.0);\n    for (float i=0.0;i<float(seqNumNotes);i++)\n    {\n        if ((time>=i)&&(time<i+2.0)) finalSound+=simpleBlip(frequencyFromNotenum(noteseq[int(i)]),(time-i)*0.5)*vec2(.4,.6);\n    }\n\n\treturn finalSound;\n}\n\nvec2 blipArpHi(float time)\n{\n    int seqNumNotes=8;\n    float noteseq[8]=float[](100.0,96.0,83.0,73.0,83.0,96.0,100.0,96.0);\n\n    time=mod(time*8.0,float(seqNumNotes));\n    vec2 finalSound=vec2(0.0);\n    for (float i=0.0;i<float(seqNumNotes);i++)\n    {\n        if ((time>=i)&&(time<i+2.0)) \n        {\n            finalSound+=simpleBlip(frequencyFromNotenum(noteseq[int(i)]),(time-i)*0.25)*(8.0-i)/16.0;\n        }\n    }\n\n\treturn finalSound;\n}\n\n#define superSaw(note,timestart,timeend)\\\nif ((internalTime>=timestart)&&(internalTime<=timeend))\\\n{\\\n    float decay=1.0;\\\n \tif (internalTime>=(timeend-2.0)) decay=(timeend-internalTime)/2.0;\\\n    finalSound+=ssaw(mod(internalTime-timestart,16.0),frequencyFromNotenum(note))*decay*0.15;\\\n}\\\n    \n// bladerunnerish sound\n    \nfloat nse(float x)\n{\n\treturn fract(sin(x * 110.082) * 19871.8972);\n}\n\nvec2 windRush(float t)\n{\n    vec2 b=bass(10.0-t,(10.0-t)*2.4,frequencyFromNotenum(6.0),0.1,0.012)*1.*nse(t/900.0);\n    if (t>18.0) b*=(20.0-t)/2.1;\n    return b;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    vec2 finalSound=vec2(0.0);\n    float internalTime=time;\n\n    // chimes\n\tif ((internalTime>=12.0)&&(internalTime<16.0)) finalSound+=blipArpHi(internalTime-4.0)*(16.0-internalTime)*0.125*vec2((internalTime-12.0)/4.0,(16.0-internalTime)/4.0);\n\tif ((internalTime>=48.0)&&(internalTime<52.0)) finalSound+=blipArpHi(internalTime-4.0)*(52.0-internalTime)*0.125*vec2((internalTime-48.0)/4.0,(52.0-internalTime)/4.0);\n    \n    if ((internalTime>10.0)&&(internalTime<20.0)) finalSound+=windRush(internalTime-10.0)*0.1;\n    if ((internalTime>44.0)&&(internalTime<52.0)) finalSound+=windRush(internalTime-44.0)*0.1;\n\n    // intro saw\n\tsuperSaw(25.0,0.0,7.0);\n\tsuperSaw(51.0,0.0,7.0);\n\tsuperSaw(63.0,6.0,16.0);\n\tsuperSaw(44.0,10.0,18.0);\n\tsuperSaw(30.0,16.0,24.0);\n\n\tsuperSaw(51.0,52.0,58.0);\n\tsuperSaw(53.0,56.0,62.0);\n\n\tsuperSaw(54.0,58.0,64.0);\n\tsuperSaw(56.0,62.0,72.0);\n    \n    if ((internalTime>=20.0)&&(internalTime<68.0))\n    {\n        float arpTime=mod(internalTime,2.0);\n        vec2 arp = vec2(arp_pattern(arpTime), arp_pattern(arpTime-0.03)*0.8);\n        arp += vec2(arp_pattern(arpTime-0.3)*0.3, arp_pattern(arpTime-0.6)*0.2);\n        if (internalTime>=20.6) finalSound+=arp*0.5;\n    }\n\n\tfinalSound += jappad(internalTime, -7.0,120.0)*vec2(.9,.4);\n\tfinalSound += jappad(internalTime+.24, -7.0,120.0)*vec2(.3,.8);\n\tfinalSound += jappad(internalTime+.48, -7.0,120.0)*vec2(.7,.7);\n\n    if (internalTime>=20.0)\n    {\n        float kickTime=mod(internalTime,4.0);\n        if (internalTime<68.0) finalSound+=kick(kickTime)*.3;\n        if ((internalTime<68.0)&&(kickTime>0.25)) finalSound+=kick(kickTime-0.25)*.1;\n\n        float bassTime=mod(internalTime,4.0);\n\n        if ((internalTime>52.0)&&(internalTime<68.0))\n        {\n            finalSound+=bass(bassTime,bassTime *2.4,frequencyFromNotenum(13.0),-2.0,-2.0)*0.3;\n            if (bassTime>2.0) finalSound+=bass(bassTime-2.0,(bassTime-2.0)*2.4,frequencyFromNotenum(6.0),-2.0,-2.0)*0.3;\n        }\n        else if (internalTime<68.0)\n        {\n        \tfinalSound+=bass(bassTime,bassTime *2.4,frequencyFromNotenum(18.0),-2.0,-2.0)*0.3;\n        \tif (bassTime>2.0) finalSound+=bass(bassTime-2.0,(bassTime-2.0)*2.4,frequencyFromNotenum(6.0),-2.0,-2.0)*0.3;\n        }\n    }\n    \n    // hihat\n    if ((internalTime>20.0)&&(internalTime<68.0)) finalSound+=hihat(internalTime,0.25);\n    \n    // blipping arp intro bassline\n    if ((internalTime>=8.0)&&(internalTime<20.0)) finalSound+=blipArp(internalTime);\n    \n    if (internalTime<2.0) finalSound*=internalTime/2.0;\n    \n    if (internalTime>=80.0) finalSound=mix(finalSound,vec2(0.0),clamp((internalTime-80.0)/7.0,0.0,1.0));\n    return finalSound;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}