{
    "Shader": {
        "info": {
            "date": "1719428057",
            "description": "original sources https://www.shadertoy.com/view/XlfGRj  https://www.shadertoy.com/view/ltBfDt https://www.shadertoy.com/view/4tyfWy",
            "flags": 0,
            "hasliked": 0,
            "id": "MXdSzl",
            "likes": 9,
            "name": "disco inferno",
            "published": 3,
            "tags": [
                "stars",
                "cosmos",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "orblivius",
            "viewed": 198
        },
        "renderpass": [
            {
                "code": "// Fork of \"star shine\" by nayk. https://shadertoy.com/view/MXdSzX\n// 2024-06-26 18:53:45\n\n\n\n//used https://www.shadertoy.com/view/mtdyD2 as a short template\n\n#define rot2(a)      mat2(cos(a+vec4(0,11,33,0)))                 // rotation\n#define TAU 6.283185\n#define PI 3.14159265359\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.010 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\n#define SIZE 2.8\n#define RADIUS 0.5\n#define INNER_FADE .04\n#define OUTER_FADE 0.01\n#define SPEED .21\n#define BORDER 0.21\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define time iTime\n#define resolution iResolution.xy\n\n\nfloat aafi(vec2 p) {\n    float fi = atan(p.y, p.x);\n    fi += step(p.y, 0.0)*TAU;\n    return fi;\n}\n\n//converts a vector on a sphere to longitude and latitude\nvec2 lonlat (vec3 p)\n{\n    float lon = aafi(p.xy)/TAU;\n    float lat = aafi(vec2(p.z, length(p.xy)))/PI;\n    return vec2(lon, lat);\n}\n\nvec3 point(vec2 ll, float r)\n{\n    float f1 = ll.x * TAU;\n    float f2 = ll.y * PI;\n    float z = r*cos(f2);\n    float d = abs(r*sin(f2));\n    float x = d*cos(f1);\n    float y = d*sin(f1);\n    return vec3(x, y, z);\n}\n\nfloat sdDiscoBall(vec3 pos, float r)\n{\n    vec2 ll = lonlat(pos);\n    float n = 15.;\n    float n2 = 30.;\n    ll.x = floor(ll.x*n2);\n    ll.y = floor(ll.y*n);\n    vec3 a = point(vec2(ll.x/n2, ll.y/n), r);\n    vec3 b = point(vec2(ll.x/n2, (ll.y+1.)/n), r);\n    vec3 c = point(vec2((ll.x + 1.)/n2, (ll.y+1.)/n), r);\n    float d = dot(normalize(cross(b-a, c-a)), (pos - a));\n    return abs(d*0.9);\n}\n\nfloat sdf(vec3 pos) {\n    \n    \n    return sdDiscoBall(pos*.2, .05);\n\n}\n\nvoid mainImage2(out vec4 O, vec2 U)\n{\n    }\n\n\nfloat random (in vec2 p) { \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3. - 2.0 * f);\n\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1. - u.x) + \n            (d - b) * u.x * u.y;\n}\n\nfloat light(in vec2 pos,in float size,in float radius,in float inner_fade,in float outer_fade){\n\tfloat len = length(pos/size);\n\treturn pow(clamp((1.0 - pow( clamp(len-radius,0.0,1.0) , 1.0/inner_fade)),0.0,1.0),1.0/outer_fade);\n}\n\n\nfloat flare(in float angle,in float alpha,in float time){\n\tfloat t = time;\n    float n = noise(vec2(t+0.5+abs(angle)+pow(alpha,0.6),t-abs(angle)+pow(alpha+0.1,0.6))*7.0);\n  \n    float split = (15.0+sin(t*2.0+n*4.0+angle*20.0+alpha*1.0*n)*(.3+.5+alpha*.6*n));\n   \n    float rotate = sin(angle*20.0 + sin(angle*15.0+alpha*4.0+t*30.0+n*5.0+alpha*4.0))*(.5 + alpha*1.5);\n   \n    float g = pow((2.0+sin(split+n*1.5*alpha+rotate)*1.4)*n*4.0,n*(1.5-0.8*alpha));\n\t\n    g *= alpha * alpha * alpha * .5;\n\tg += alpha*.7 + g * g * g;\n\treturn g;\n}\n\nvec2 project(vec2 position, vec2 a, vec2 b)\n{\n\tvec2 q\t \t= b - a;\t\n\tfloat u \t= dot(position - a, q)/dot(q, q);\n\tu \t\t= clamp(u, 0., 1.);\n\treturn mix(a, b, u);\n}\n\nfloat segment(vec2 position, vec2 a, vec2 b)\n{\n\treturn distance(position, project(position, a, b));\n}\nfloat contour(float x)\n{\n\treturn 1.-clamp(x * 2048., 0., 1.);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n\treturn contour(segment(p, a, b));\n}\n\nvec2 neighbor_offset(float i)\n{\n\tfloat c = abs(i-2.);\n\tfloat s = abs(i-4.);\n\treturn vec2(c > 1. ? c > 2. ? 1. : .0 : -1., s > 1. ? s > 2. ? -1. : .0 : 1.);\n}\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    vec2 uv = (U.xy - iResolution.xy * 0.5)/iResolution.y;\n\tfloat f = .0;\n    float f2 = .0;\n    \n\n\n\tvec3 dir=vec3(uv*zoom,1.);\n\n\n\t//mouse rotation\n\n\tvec3 from=vec3(1.,.5,0.5);\n\n\t\n\t//volumetric rendering\n\tfloat s2=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s2*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.05),sin(iTime*0.05),-sin(iTime*0.05),cos(iTime*0.05) );// the magic formula\n\t\t\ta+=abs(length(p)-pa); //\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); \n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm;\n\t\t\n\t\tv+=fade;\n\t\tv+=vec3(s2,s2*s2,s2*s2*s2*s2)*a*brightness*fade;\n\t\tfade*=distfading; \n\t\ts2+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tuv*=0.5;\n\t\n\tvec4 result\t\t= vec4(0.,0.,0.,1.);\n\t\n\tfloat t2 \t\t= abs(sin(time*.1));\n\tfloat c \t\t= cos(t2);\n\tfloat s \t\t= sin(t2);\n\tmat2 rm \t\t= mat2(c, s, -s, c);\n\tvec2 position\t\t= vec2(0.,0.);\n\tfor(float i = 0.; i < 256.; i++)\n\t{\n\n\t\tvec2 sample2\t\t= neighbor_offset(mod(i, 8.))/resolution.y+position*rm;\n\t\tresult \t\t\t+= line(uv, position, sample2);\n\t\tposition\t\t= sample2;\n\t}\n  \n    float t = iTime * SPEED;\n\tfloat alpha = light(uv,SIZE,RADIUS,INNER_FADE,OUTER_FADE);\n\tfloat angle = atan(uv.x,uv.y);\n    float n = noise(vec2(uv.x*10.+iTime,uv.y*20.+iTime));\n   \n\tfloat l = length(uv*v.xy*.01);\n\tif(l < BORDER){\n        t *= .8;\n        alpha = (1. - pow(((BORDER - l)/BORDER),0.22)*0.7);\n        alpha = clamp(alpha-light(uv,0.02,0.0,0.3,.7)*.55,.0,1.);\n        f = flare(angle*1.0,alpha,-t*.5+alpha);\n        f2 = flare(angle*1.0,alpha*1.2,((-t+alpha*.5+0.38134)));\n\n\n\t}\n\tfloat tt=9.,r;\n    vec3  R = iResolution, e = vec3(1e-3,0,0), N,\n          D = normalize(vec3(+U, -18.*R.y) - R),          // ray direction\n          p = vec3(1.5,.85,30.5), q,                             // marching point along ray \n          C = iMouse.z > 0. ? 8.*iMouse.xyz/R -4.             // camera control\n                          : 3.* cos(.3*iTime + vec3(0,11,0)); // demo mode\n    p.yz *= rot2(-C.y),                                    // rotations\n    p.xz *= rot2(-C.x-1.57),\n    D.yz *= rot2(-C.y),                              \n    D.xz *= rot2(-C.x-1.57);\n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )         // march scene\n        q = p, \n        t = min(t, sdf(q) ),                               // soleno√Ød\n        p += .5*t*D;                                       // step forward = dist to obj    \n    \n    N = vec3( sdf(q+e), sdf(q+e.yxy), sdf(q+e.yyx) ) - t ; // normal\n    O.x < 0. ? O = .5*texture(iChannel0, D) :              // uncomment to display environment \n    O += texture(iChannel0, reflect(D,N/length(N) ) ); // reflect of environment map\n\n    f = flare(angle,alpha,t)*1.3;\n\t\n\tO += vec4(vec3(f*(1.0+sin(angle-t*4.)*.3)+f2*f2*f2,f*alpha+f2*f2*2.0,f*alpha*0.5+f2*(1.0+sin(angle+t*4.)*.3)),1.0);\n   \n     uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    O*= .5*vec4(happy_star(uv, anim) * vec3(0.55,0.5,1.15), 1.0);\n    O+= .5*vec4(happy_star(uv, anim) * vec3(0.55,0.5,1.15)*0.01, 1.0);\n}\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}