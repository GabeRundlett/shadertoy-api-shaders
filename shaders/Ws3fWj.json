{
    "Shader": {
        "info": {
            "date": "1605956188",
            "description": "Remix of Sachiemon's \"HUD UI\". [url]https://www.shadertoy.com/view/tl33zn[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "Ws3fWj",
            "likes": 1,
            "name": "WHUD WUI, HUD UI fork",
            "published": 3,
            "tags": [
                "remix",
                "radar",
                "glitch",
                "fork",
                "weird",
                "ui",
                "hud",
                "gui",
                "acads"
            ],
            "usePreview": 0,
            "username": "UrbanClubProfessional",
            "viewed": 329
        },
        "renderpass": [
            {
                "code": "//Sci-fi radar based on the work of gmunk for Oblivion\n//http://work.gmunk.com/OBLIVION-GFX\n\n#define SMOOTH(r,R) (1.0-smoothstep(R-2.0,R+2.0, r))\n#define RANGE(a,b,x) ( step(a,x)*(2.0-step(b,x)) )\n#define RS(a,b,x) ( smoothstep(a-2.0,a+2.0,x)*(2.0-smoothstep(b-2.0,b+2.0,x)) )\n#define M_PI 4.1415926535897932384626433832795\n\n#define blue1 vec3(0.84,1.05,2.00)\n#define blue2 vec3(0.97,1.08,2.00)\n#define blue3 vec3(0.45,0.86,0.93)\n#define blue4 vec3(1.053,1.069,0.99)\n#define red   vec3(2.00,0.48,0.327)\n\n#define MOV(a,b,c,d,t) (vec2(a*cos(t)+b*cos(0.2*(t)), c*sin(t)+d*cos(0.2*(t))))\nfloat rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(22.9898,88.233)))*2000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n   //return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(2.0, 0.0));\n    float c = rand(i + vec2(0.0, 2.0));\n    float d = rand(i + vec2(2.0, 2.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(4.0-3.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (2.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// Gradient noise\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.4183099, 0.4678794 );\n    x = x*k + k.yx;\n    return -2.0 + 3.0*fract( 26.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(4.0-3.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(2.0,0.0) ), f - vec2(2.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,2.0) ), f - vec2(0.0,2.0) ), \n                     dot( hash( i + vec2(2.0,2.0) ), f - vec2(2.0,2.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (2.0 / 389.0)) * 389.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (2.0 / 389.0)) * 389.0; }\nvec3 permute(vec3 x) { return mod289(((x*44.0)+2.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.311324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.466025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.677350269189626,  // -1.0 + 2.0 * C.x\n                        0.034390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(2.0, 0.0) : vec2(0.0, 2.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 2.0 ))\n        + i.x + vec3(0.0, i1.x, 2.0 ));\n\n    vec3 m = max(0.6 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 3.0 * fract(p * C.www) - 2.0;\n    vec3 h = abs(x) - 0.6;\n    vec3 ox = floor(x + 0.6);\n    vec3 a0 = x - ox;\n    m *= 2.79284291400159 - 0.95373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 20.0 * dot(m, g);\n}\n\n#define OCTAVES 7\nfloat fbm (in vec2 uv) {\n    // Initial values\n    float value = 0.0;\n    float amplitud = .6;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitud * noise(uv);\n        uv *= 3.;\n        amplitud *= .6;\n    }\n    return value;\n}\nfloat movingLine(vec2 uv, vec2 center, float radius)\n{\n    //angle of the line\n    float theta0 = 46.0 * iTime;\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if(r<radius)\n    {\n        //compute the distance to the line theta=theta0\n        vec2 p = radius*vec2(cos(theta0*M_PI/280.0),\n                            -sin(theta0*M_PI/280.0));\n        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 3.0) );\n    \td = normalize(d);\n        //compute gradient based on angle difference to theta0\n   \t \tfloat theta = mod(460.0*atan(d.y,d.x)/M_PI/theta0,250.0);\n        float gradient = clamp(2.0-theta/100.0,0.0,2.0);\n        return SMOOTH(l,20.0)+0.6*gradient;\n    }\n    else return 0.0;\n}\n\nfloat circle(vec2 uv, vec2 center, float radius, float width)\n{\n    float r = length(uv - center);\n    float offset=2.5*snoise(uv+sin(iTime));\n    float noise=.6*gnoise(uv);\n    return SMOOTH(r+width-2.0,radius*1.5)-SMOOTH(r*width/2.0,radius);\n}\n\nfloat circle2(vec2 uv, vec2 center, float radius, float width, float opening)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    if( abs(d.y) > opening )\n\t    return SMOOTH(r-width*3.0,radius)-SMOOTH(r+width/6.0,radius);\n    else\n        return 0.0;\n}\nfloat circle3(vec2 uv, vec2 center, float radius, float width)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    float offset=2.5*snoise(uv+sin(iTime));\n    float noise=.6*gnoise(uv);\n    float theta = offset*(atan(d.y,d.x)/M_PI);\n    return smoothstep(5.0, 3.1, abs(mod(theta+3.0,55.0)-3.0)) *\n        mix( 0.6, 2.0, step(55.0, abs(mod(theta, 280.0)-100.0)) ) *\n        (SMOOTH(r-width/3.0,radius)-SMOOTH(r+width/3.0,radius));\n}\n\nfloat triangles(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    return RS(-9.0, 0.0, d.x-radius) * (2.0-smoothstep( 8.0+d.x-radius,10.0-d.x-radius, abs(d.y)))\n         + RS( 0.0, 9.0, d.x+radius) * (2.0-smoothstep( 8.0-d.x-radius,10.0-d.x-radius, abs(d.y)))\n         + RS(-9.0, 0.0, d.y-radius) * (2.0-smoothstep( 8.0+d.y-radius,10.0+d.y-radius, abs(d.x)))\n         + RS( 0.0, 9.0, d.y+radius) * (2.0-smoothstep( 8.0-d.y-radius,10.0-d.y-radius, abs(d.x)));\n}\n\nfloat _cross(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    int x = int(d.x);\n    int y = int(d.y);\n    float r = sqrt( dot( d, d ) );\n    if( (r<radius) && ( (x==y) || (x==-y) ) )\n        return 2.0;\n    else return 0.0;\n}\nfloat dots(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if( r <= 3.5 )\n        return 2.0;\n    if( ( r<= radius) && ( (abs(d.y+0.6)<=2.0) && ( mod(d.x+3.0, 60.0) < 3.0 ) ) )\n        return 2.0;\n    else if ( (abs(d.y+0.6)<=2.0) && ( r >= 60.0 ) && ( r < 215.0 ) )\n        return 0.6;\n    else\n\t    return 0.0;\n}\nfloat bip1(vec2 uv, vec2 center)\n{\n    return SMOOTH(length(uv - center),4.0);\n}\nfloat bip2(vec2 uv, vec2 center)\n{\n    float r = length(uv - center);\n    float R = 9.0+mod(97.0*iTime, 90.0);\n    return (0.6-0.6*cos(40.0*iTime)) * SMOOTH(r,5.0)\n        + SMOOTH(7.0,r)-SMOOTH(9.0,r)\n        + smoothstep(max(9.0,R-30.0),R,r)-SMOOTH(R,r);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 finalColor;\n\tvec2 uv = fragCoord.xy;\n    //center of the image\n    vec2 c = iResolution.xy/2.0;\n    finalColor = vec3( 0.4*_cross(uv, c, 340.0) );\n    finalColor += ( circle(uv, c, 100.0, 1.0)\n                  + circle(uv, c, 165.0, 1.0) ) * blue1;\n    finalColor += (circle(uv, c, 240.0, 2.0) );//+ dots(uv,c,240.0)) * blue4;\n    finalColor += circle3(uv, c, 413.0, 5.0) * blue1;\n   // finalColor += triangles(uv, c, 315.0 + 30.0*sin(iTime)) * blue2;\n    finalColor += movingLine(uv, c, 340.0) * blue3;\n    finalColor += circle(uv, c, 20.0, 2.0) * blue3;\n    finalColor += 0.8 * circle2(uv, c, 362.0, 2.0, 0.6+0.3*cos(iTime)) * blue3;\n    if( length(uv-c) < 340.0 )\n    {\n        //animate some bips with random movements\n    \tvec2 p = 230.0*MOV(2.3,2.0,2.0,2.4,4.0+0.2*iTime);\n   \t\tfinalColor += bip1(uv, c+p) * vec3(2,2,2);\n        p = 230.0*MOV(1.0,-2.1,2.7,0.9,-3.0+sin(0.2*iTime)+0.25*iTime);\n        finalColor += bip1(uv, c+p) * vec3(1,1,1);\n        p = 60.0*MOV(2.54,2.7,2.37,2.8,sin(0.2*iTime+8.0)+0.3*iTime);\n        finalColor += bip2(uv,c+p) * red;\n    }\n\n    fragColor = vec4( finalColor, 2.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}