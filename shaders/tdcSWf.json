{
    "Shader": {
        "info": {
            "date": "1576721687",
            "description": "Inktober, but with shaders\n\nHuge thanks to https://www.shadertoy.com/view/XsfGWN (furball, simesgreen in 2013-05-28), very instructive shader",
            "flags": 0,
            "hasliked": 0,
            "id": "tdcSWf",
            "likes": 19,
            "name": "shadetober #27 (coat)",
            "published": 3,
            "tags": [
                "hair",
                "fur",
                "inktober",
                "shadertober",
                "shadetober",
                "inktober2019"
            ],
            "usePreview": 0,
            "username": "percentcer",
            "viewed": 785
        },
        "renderpass": [
            {
                "code": "#define DMAX 9999.\n#define PI 3.14159\n#define TOR_RAD 1.\n#define TOR_WID .5\n#define ITER_STEPS 32\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\n\nfloat map(vec4 p) {\n    float tor = sdTorus(p.xyz, vec2(TOR_RAD, TOR_WID));\n    return tor;\n}\n\nmat3 rotz(float a) {\n    return mat3(\n    \tcos(a), sin(a), 0.,\n        -sin(a), cos(a), 0.,\n        0.,      0.,     1.\n    );\n}\n\nvec4 furColor(vec3 ro, vec3 rd, float t) {\n    vec3 p = ro + rd * t;\n    vec3 acc_col = vec3(0.); // color accumulation\n    float acc_dns = 0.; // density accumulation\n    \n    // for each step in this march\n    for (int i = 0; i < ITER_STEPS; i++) {\n        // we already did the march to the surface prior to this function\n        // so at this point we know we're marching _into_ the shape:\n        // increment p by (some fraction of) rd\n        //\n        // the fraction is chosen to be the maximum length you'd have to march if the ray hit exactly\n        // along the diameter of a \"polodial slice\", divided by the number of steps\n        // (https://en.wikipedia.org/wiki/Toroidal_and_poloidal#/media/File:Toroidal_coord.png)\n        p += rd * (TOR_WID * 2. / float(ITER_STEPS));\n        \n        // check where you are in the torus ring (u)\n        float u = atan(p.y, p.x);\n\n        // check where you are in the circumferal slice (v) ... these must have actual math names right?\n        // I don't know how to do this the smart, closed-form way, but we can rotate back to the xz plane\n        // and then offset to the origin and then just do an atan\n        vec3 pointRotatedBackToXZPlane = (rotz(-u) * p) - vec3(TOR_RAD, 0., 0.);\n        float v = atan(pointRotatedBackToXZPlane.z, pointRotatedBackToXZPlane.x);\n        \n        // set aside our uvs for convenience\n        // and normalize them so they're not in [-pi, pi]\n        vec2 uvs = vec2(u, v);\n        uvs /= (2. * PI);\n        uvs += .5;\n        \n        // add some motion for __dbg and style points\n        uvs.y += iTime;\n        \n        // we also care how far we are from the center of the tube which we will use to taper the hair\n        float rad = length(pointRotatedBackToXZPlane);\n        \n        // if we've stepped outside of the torus just end, don't worry about the case where we could end up back inside\n        if (rad > TOR_WID) break;\n        \n        // taper should approach zero as we reach the edge of the region\n        // future work: I think this can be tweaked to modify the length of individual hairs\n        float taper = 1. - rad / TOR_WID ;\n        //taper = pow(taper, 1.); // __dbg\n        \n        // use the uv coords to look up density, mul density by taper so that it's less dense as the hair grows outwards\n        // smoothstep to ignore hairs that are below a certain density threshold\n        float dens = smoothstep(0.5, .8, texture(iChannel0, uvs).r) * taper;\n        \n        // use these coords to look up color in the other texture\n        // smoothstep mul to make the roots darker than the tips\n        vec3 col = texture(iChannel1, uvs).rgb * smoothstep(.1, .6, rad);\n        \n        // capacity is an interesting term, lifted from https://www.shadertoy.com/view/XsfGWN\n        // it basically biases the march such that the hair you encounter earlier in the march\n        // is more strongly represented than hair encountered later in the march. It affects\n        // both the density and the color.\n        float capacity = 1. - acc_dns;\n        \n        // mul the color by the density [0., 1.] and add it to color accumulation\n        acc_col += col * dens * capacity;\n            \n        // add density to the density accumulation\n        acc_dns += dens * capacity;\n        \n        // if we are above a density threshold in the accumulator, return color\n        if (acc_dns > .95) {\n            vec4(acc_col, acc_dns);\n        }\n    }\n    return vec4(acc_col, acc_dns);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy)/iResolution.y;\n    \n    // standard camera setup\n    vec3 ro = vec3(0., 0., 2.);\n    vec3 rd = normalize(vec3(uv.xy, -1.));\n\n    // simple background\n    vec4 col = vec4(0., 0., 0., 1.);\n    \n    // standard sphere march\n    vec4 sp;\n    float t = 0.;\n    for (int i = 0; i < 100; i++) {\n        sp = vec4(ro + rd * t, 0.);\n        float d = map(sp);\n        if ( d < .001 ) {\n            // set material?\n            sp.w = 1.;\n            break;\n        }\n        t += d;\n        if (t > DMAX) {\n            break;\n        }\n    }\n    \n    if (sp.w > 0.) {\n    \tcol = furColor(ro, rd, t);\n    }\n\n    // Output to screen\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}