{
    "Shader": {
        "info": {
            "date": "1478334011",
            "description": "Applying some bump mapping and lighting to a variation on IQ's 9-tap Voronoi algorithm to produce some animated, pseudo-lit rounded blocks. 2D made to look like 3D would be another way to put it. :)",
            "flags": 0,
            "hasliked": 0,
            "id": "lt3SzH",
            "likes": 86,
            "name": "Rounded Voronoi Blocks",
            "published": 3,
            "tags": [
                "3d",
                "voronoi",
                "illusion",
                "bump",
                "blocks"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 4988
        },
        "renderpass": [
            {
                "code": "/*\n\n\tRounded Voronoi Blocks\n\t----------------------\n\n    Applying some bump mapping and lighting to a Voronoi variation to produce an \n\tanimated, pseudo-lit, rounded block effect.\n\n\tI had originally intended to do a standard square block version using a first order\n    triangular distance metric, but noticed that IQ, Aeikick and others had already done \n\tit, so I switched to a second order distance setup and experimented with a few different \n\tmetrics. The end result was the oddly distributed round-looking blocks with defined \n\tedges you see.\n\n\tTo add a little more to the illusion, I bump mapped it, put in some fake occlusion,\n\tand some subtle edging. As you can see, there's not a lot of code.\n\n\n\tRelated examples:\n\n\t// Uses the more standard, triangle metric. So stylish.\n\tIQ - Blocks \n\thttps://www.shadertoy.com/view/lsSGRc\n\n\t// Aiekick's tunnelized take on the above. \n\tVoro Tri Tunnel - aiekick\n\thttps://www.shadertoy.com/view/XtGGWy\n\n*/\n\n\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    //return fract(vec2(262144, 32768)*n); \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    // Note the \".25,\" insted of \".5\".\n    return sin( p*6.2831853 + iTime )*.25 + .5; \n    \n}\n\n\n//float tri(float x){ return abs(fract(x) - .5)*2.; }\n\n// 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n// up those if-statements. Since there's less writing, it should go faster. That's how \n// it works, right? :)\n//\nfloat Voronoi(in vec2 p){\n    \n\tvec2 g = floor(p), o; p -= g; // Cell ID, offset variable, and relative cell postion.\n\t\n\tvec3 d = vec3(1); // 1.4, etc. \"d.z\" holds the distance comparison value.\n    \n\tfor(int y=-1; y<=1; y++){\n\t\tfor(int x=-1; x<=1; x++){\n            \n\t\t\to = vec2(x, y); // Grid cell ID offset.\n            o += hash22(g + o) - p; // Random offset.\n\t\t\t\n            // Regular squared Euclidean distance.\n            d.z = dot(o, o); \n            // Adding some radial variance as we sweep around the circle. It's an old\n            // trick to draw flowers and so forth. Three petals is reminiscent of a\n            // triangle, which translates roughly to a blocky appearance.\n            d.z *= cos(atan(o.y, o.x)*3. - 3.14159/2.)*.333 + .667;\n            //d.z *= (1. -  tri(atan(o.y, o.x)*3./6.283 + .25)*.5); // More linear looking.\n            \n            d.y = max(d.x, min(d.y, d.z)); // Second order distance.\n            d.x = min(d.x, d.z); // First order distance.\n                      \n\t\t}\n\t}\n\n    // A bit of science and experimentation.\n    return d.y*.5 + (d.y-d.x)*.5; // Range: [0, 1]... Although, I'd check. :)\n    \n    //return d.y; // d.x, d.y - d.x, etc.\n    \n    \n}\n\n\n// Bump mapping function. Put whatever you want here. If you wish to do some\n// fake shadowing, it's usually helpful to keep the range between zero and one.\nfloat bumpFunc(vec2 p){ \n    \n    return Voronoi(p*4.); // Range: [0, 1] \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    // PLANE ROTATION\n    //\n    // Rotating the canvas back and forth. I don't feel it adds value, in this case,\n    // but feel free to uncomment it.\n    //vec2 a = sin(vec2(1.57, 0) + sin(iTime*0.1)*sin(iTime*0.12)*2.);\n    //uv *= mat2(a, -a.y, a.x);\n  \n    // Position offset.\n    vec3 offs = vec3(-iTime/16., -iTime/8., 0);\n\n    // VECTOR SETUP - surface postion, ray origin, unit direction vector, and light postion.\n    //\n    // Setup: I find 2D bump mapping more intuitive to pretend I'm raytracing, then lighting a bump mapped plane \n    // situated at the origin. Others may disagree. :)  \n    vec3 sp = vec3(uv, 0) + offs; // Surface posion. Hit point, if you prefer. Essentially, a screen at the origin.\n    vec3 rd = normalize(vec3(uv, 1.)); // Unit direction vector. From the origin to the screen plane.\n    vec3 lp = vec3(cos(iTime)*0.5, sin(iTime)*0.2, -2.) + offs; // Light position - Back from the screen.\n\tvec3 sn = vec3(0., 0., -1); // Plane normal. Z pointing toward the viewer.\n \n     \n\n    \n    // BUMP MAPPING - PERTURBING THE NORMAL\n    //\n    // Setting up the bump mapping variables and edge calcultion. Normally, you'd amalgamate a lot \n    // of the following, and roll it into a single function, but I wanted to show the workings.\n    //\n    // f - Function value\n    // fx - Change in \"f\" in in the X-direction.\n    // fy - Change in \"f\" in in the Y-direction.\n    vec2 eps = vec2(3./iResolution.y, 0.);\n    \n    float f = bumpFunc(sp.xy); // Function value.\n    float fx = bumpFunc(sp.xy+eps.xy); // Nearby sample in the X-direction.\n    float fy = bumpFunc(sp.xy+eps.yx); // Nearby sample in the Y-direction.\n  \n    float fx2 = bumpFunc(sp.xy-eps.xy); // Sample on the other side in the X-direction.\n    float fy2 = bumpFunc(sp.xy-eps.yx); // Same on the other side in the Y-direction.\n    \n    // Using the samples to provide an edge measurement. How you do it depends on the\n    // look you're going for.\n    //float edge = abs(fx + fy + fx2 + fy2 - 4.*f); //abs(fx - f) + abs(fy - f);\n    float edge = abs(fx + fy + fx2 + fy2) - 4.*f; //abs(fx - f) + abs(fy - f);\n    //float edge = abs(fx + fx2) + abs(fy + fy2) - 4.*f; //abs(fx - f) + abs(fy - f);\n\n    edge = smoothstep(0., 8., edge/eps.x*4.);\n   \n \t// Controls how much the bump is accentuated.\n\tconst float bumpFactor = 0.35;\n    \n    // Using the above to determine the dx and dy function gradients.\n    fx = (fx-fx2)/eps.x/2.; // Change in X\n    fy = (fy-fy2)/eps.x/2.; // Change in Y.\n    // Using the gradient vector, \"vec3(fx, fy, 0),\" to perturb the XY plane normal \",vec3(0, 0, -1).\"\n    // By the way, there's a redundant step I'm skipping in this particular case, on account of the \n    // normal only having a Z-component. Normally, though, you'd need the commented stuff below.\n    //vec3 grad = vec3(fx, fy, 0);\n    //grad -= sn*dot(sn, grad);\n    //sn = normalize( sn + grad*bumpFactor ); \n    sn = normalize( sn + vec3(fx, fy, 0)*bumpFactor );           \n     \n    \n    // LIGHTING\n    //\n\t// Determine the light direction vector, calculate its distance, then normalize it.\n\tvec3 ld = lp - sp;\n\tfloat lDist = max(length(ld), 0.001);\n\tld /= lDist;\n\n    // Light attenuation.    \n    float atten = 1./(1.0 + lDist*lDist*0.15);\n    \n    // Using the bump function, \"f,\" to darken the crevices. Completely optional, but I\n    // find it gives extra shadowy depth.\n    //atten *= smoothstep(0.1, 1., f)*.9 + .1; // Or... f*f*.7 + .3; //  pow(f, .75); // etc.\n    atten *= ((1.-f)*.9 + .1); // Or... f*f*.7 + .3; //  pow(f, .75); // etc.\n    \n\n\t\n    // TEXTURE COLOR\n    //\n\t// Some fake tri-plannar mapping. I wouldn't take it too seroiusly.    \n    const float ts = 2.;\n    vec3 nsn = max(abs(sn)-.2, .001);\n    nsn /= dot(nsn, vec3(1));\n    vec3 texCol = vec3(0);\n    sp.z += -f*1.; // Pretending that the Z-value is not sitting flat on the plane.\n    // Tri-planar.\n    texCol += texture(iChannel0, sp.xy*ts).xyz*nsn.z;\n    texCol += texture(iChannel0, sp.xz*ts).xyz*nsn.y;\n    texCol += texture(iChannel0, sp.yz*ts).xyz*nsn.x;\n    // sRGB to linar with processing. Basically, minipulating the color a bit.\n    texCol = smoothstep(0.075, .5, texCol*texCol)*1.5;\n    \n    \n    // Diffuse value.\n\tfloat diff = max(dot(sn, ld), 0.);  \n    // Enhancing the diffuse value a bit. Made up.\n    diff = pow(diff, 4.)*0.66 + pow(diff, 8.)*0.34; \n    // Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 8.); \n    // Fresnel reflection. It's one line, so why not.\n    float fres = pow(clamp(dot(rd, sn) + 1., 0., 1.), 16.);\n    \n    \n    // Apply the edging here. You could do it later, but I wanted the specular lighting to \n    // supercede it. Not for a scientific reason. I just thought it looked nicer this way. :)\n    texCol *= 1.-edge*.5;\n    \n    // I did this by accident, but found it added to the depth, so I kept it.\n    texCol *= smoothstep(0.1, .6, atten);\n\t\n    \n    // FINAL COLOR\n    // Using the values above to produce the final color.   \n    vec3 col = (texCol*(diff*2. + 0.2 + vec3(1, 1.4, 2)*fres) + vec3(1., .7, .3)*spec*2.)*atten;\n\n    // Doing the edging here is fine, but it overrides the specular, which wasn't the look I was going for.\n    //col *= 1. - edge*.5;\n    \n    // Postprocesing - A subtle vignette, contrast and coloring.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), 0.125); // Vignette.\n  \n    col = vec3(1.4, 1.2, .9)*pow(max(col, 0.), vec3(1, 1.2, 1.5))*1.5; // Contrast, coloring.\n    \n\n    // Perform some statistically unlikely (but close enough) 2.0 gamma correction. :) \n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}