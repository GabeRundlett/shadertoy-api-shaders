{
    "Shader": {
        "info": {
            "date": "1589825472",
            "description": "Raytraced pong game ( ͡° ͜ʖ ͡°)\nUP & DOWN arrows to take control of one paddle (it turns green).",
            "flags": 48,
            "hasliked": 0,
            "id": "WdjBzW",
            "likes": 0,
            "name": "Pong(?)",
            "published": 3,
            "tags": [
                "game"
            ],
            "usePreview": 0,
            "username": "rblb",
            "viewed": 1182
        },
        "renderpass": [
            {
                "code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 v_rgbNW;\n\tvec2 v_rgbNE;\n\tvec2 v_rgbSW;\n\tvec2 v_rgbSE;\n\tvec2 v_rgbM;\n\n\ttexcoords(fragCoord, iResolution.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\t\n\tfragColor = fxaa(iChannel0, fragCoord, iResolution.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n//\tfragColor = texelFetch(iChannel0, ivec2(fragCoord),0);\n\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "music",
                        "id": 18,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3"
                    },
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "precision highp float;\nprecision highp sampler2D;\nprecision highp samplerCube;\nprecision highp int;\n\n// HELPERS\n#define PI 3.14159265\n\n\nmat4 mat4_rotationFromAngleAxis(in float angle, in vec3 v){\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 mat4_translation(in vec3 v){\n    float x=v.x;\n    float y=v.y;\n    float z=v.z;\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n// Scene\nstruct Camera{\n\tvec3 pos;\n    vec3 dir;\n   \tvec3 right;\n    vec3 up;\n};\n    \n    \nstruct Ray{\n  \tvec3 origin;\n  \tvec3 direction;\n};\n    \n    \nvoid Camera_setDirection(inout Camera cam,in vec3 up,in vec3 direction){\n    cam.dir=direction;\n    cam.right=normalize(cross(up, cam.pos));\n   \tcam.up = cross(cam.dir, cam.right);\n}\n\nvoid Camera_lookAt(inout Camera cam,in vec3 up,in vec3 target){\n    Camera_setDirection(cam,up,normalize(target-cam.pos));\n}\n\nvec3 getCameraOrigin(float time){\n    \n           float m_x = time*0.01;\n        float m_y = (sin(time)*0.5+0.5)*-0.1;    \n    vec3 cameraOrigin = vec3(5.0 * sin(m_x * PI * 2.), m_y * 10.0-1., 5.0 * cos(m_x * PI * 2.));\n\treturn cameraOrigin;\n}\n\nCamera Camera_new(in vec3 pos){\n\tCamera cam;\n    cam.pos=pos;\n    Camera_setDirection(cam,vec3(0,1,0),vec3(0,0,1));\n\treturn cam;\n    \n    \n}\n\nCamera Camera_newDemo(in float time){\n\tvec3 pos=getCameraOrigin(time);   \n    return Camera_new(pos);\n}\n\n\n\n\n\n\n\nRay Ray_fromCam(in Camera cam,in vec2 fragCoord,in vec2 iResolution){\n\tRay ray;\n\n    vec2 uv=(fragCoord.xy / iResolution.xy);\n    \n \tvec2 screenPos=uv*2.-1.;\n    screenPos.x*=iResolution.x/iResolution.y;\n    \n    ray.origin=cam.pos;\n    ray.direction=normalize(cam.right * screenPos.x + cam.up * screenPos.y + cam.dir);\n    return ray;\n    \n}\n    \n    \n// Shapes\nstruct Sphere{\n    vec3 pos;\n    float radius;\n    mat4 rot;\n\n};   \n    \nstruct Box{\n    vec3 pos;\n    vec3 size;\n\tmat4 rot;\n};  \n    \n    \n\n\n// Raytracing\nstruct IRes {\n  \tvec3 pos;\n    vec3 norm;\n    float tmin;\n    bool hit;\n};\n    \n    \n\n        \n\n\n// https://iquilezles.org/articles/boxfunctions\nIRes raytrace(in Ray ray,in Box box ){\n  \tIRes res;\n    res.hit=false;\n  \tres.tmin=-1.;\n\n    vec3 ro=ray.origin;\n    vec3 rd=ray.direction;\n    \n    vec3 rad=box.size;\n    \n    mat4 rot = box.rot;\n\tmat4 tra = mat4_translation(box.pos);\n\tmat4 txi = tra * rot; \n\tmat4 txx = inverse( txi );\n\n    \n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN > tF || tF < 0.0) return res;\n       \n    \n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = normalize((txi * vec4(nor,0.0)).xyz);\n    \n\tres.hit=true;\n    res.pos=ro + tN*rd;\n    res.norm=nor;\n    res.tmin=tN;\n    res.hit=res.tmin>0.;\n\treturn res;\n}\n\n\n\n// Ray-Sphere intersection\nIRes raytrace( in Ray ray,in Sphere sphere ){\n    IRes res;\n\tres.hit=false;\n    res.tmin=-1.;    \n    vec3 ro=ray.origin;\n    vec3 rd=ray.direction;\n    vec4 sph=vec4(sphere.pos,sphere.radius);\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return res;\n    float tN=-b - sqrt( h );   \n    res.pos=ro + tN*rd;\n    res.norm= normalize(res.pos-sphere.pos);\n    res.tmin=tN;\n    res.hit=tN>0.; \n    return res;\n}\n\n\n\n// RENDER\n\nvoid packFb(inout vec4 fb,in Ray ray,in vec3 pos,in vec3 norm,in float material){\n    float dpos=distance(ray.origin,pos);\n    fb.r=dpos;\n    fb.g=floor(material*10.);\n    \n    vec3 n=norm*.5+.5;\n    fb.g+=n.x;\n\tfb.b=n.y;\n    \n}\n\n\nvoid unpackFb(in vec4 fb,in Ray ray,out vec3 pos,out vec3 norm,out float material){\n   pos=ray.origin+ray.direction*fb.r;\n   material=floor(fb.g/10.);\n\n    norm.x=fb.g-(material*10.);\n    norm.y=fb.b;\n    norm.xy=norm.xy*2.-1.;\n    norm.z = sqrt(1.-clamp(dot(norm.xy, norm.xy),0.,1.)); // Reconstruct Z\n        \n}\n\n\nvoid packFb2(inout vec4 fb,in Ray ray,in vec3 pos,in vec3 norm,in float material){\n    fb.a=material;\n}\n\n\n\nvoid unpackFb2(in vec4 fb,in Ray ray,out vec3 pos,out vec3 norm,out float material){\n   material=fb.a;    \n}\n\n\n\n// GAME LOGIC\n\n#define PLAYER1 0\n#define PLAYER2 1\n\n\n\n#define GAME_SPEED 1.\n#define BALL_SPEED 240.\n#define PADDLE_SPEED 200.\n#define PADDLE_SIZE vec2(10,60)\n#define BALL_SIZE vec2(15,15)\n\n\n\n#define SHAPE_RECT 0\n\n\n#define GROUND_SIZE vec2(800,450)\n\nstruct State{\n    vec2 paddle1Pos;\n  \tvec2 paddle2Pos;\n    bool paddle1UnderControl;\n  \tvec2 ballPos;\n  \tvec2 ballDir;\n    float score;\n};\n    \n    \nstruct Paddle{\n    vec2 pos;\n    float speed;    \n    vec2 size;\n    int shape;\n    int playerId;\n    bool underControl;\n};\n\nstruct Ball{\n \tvec2 pos;\n    vec2 speed;\n    vec2 size;\n    int shape;\n};\n\n  \n#define MEMORY_REGION_PADDLE1POS ivec2(0,0)\n#define MEMORY_REGION_PADDLE2POS ivec2(1,0)\n#define MEMORY_REGION_BALLPOS ivec2(2,0)\n#define MEMORY_REGION_BALLDIR ivec2(3,0)\n#define MEMORY_REGION_SCORE1 ivec2(4,0)\n#define MEMORY_REGION_SCORE2 ivec2(5,0)\n    \n#define limitMemoryRegion() if(fragCoord.y>=1.||fragCoord.x>=6.)return;\n#define isInPaddle1ActionRegion() (ivec2(fragCoord.xy)==MEMORY_REGION_PADDLE1POS)\n#define isInPaddle2ActionRegion() (ivec2(fragCoord.xy)==MEMORY_REGION_PADDLE2POS)\n    \n    \n#define _write(at,value) { if(ivec2(fragCoord)==at)fragColor=value; };\n#define _load(at) texelFetch(iChannel1, at, 0)\nvoid writeState(in vec2 fragCoord,in State state,out vec4 fragColor){\n\t_write(ivec2(0,0),vec4(state.paddle1Pos.x,state.paddle1Pos.y,0.,0.));\n\t_write(ivec2(1,0),vec4(state.paddle2Pos.x,state.paddle2Pos.y,0.,0.));\n\t_write(ivec2(2,0),vec4(state.ballPos.x,state.ballPos.y,0.,0.));\n\t_write(ivec2(3,0),vec4(state.ballDir.x,state.ballDir.y,0.,0.));\n\t_write(ivec2(4,0),vec4(state.score,0.,0.,0.));\n\t_write(ivec2(5,0),vec4(state.paddle1UnderControl?1.:0.,0.,0.,0.));\n    \n}\n\nState loadState(in sampler2D iChannel1){\n    State state;\n    state.paddle1Pos=_load(ivec2(0,0)).xy;\n    state.paddle2Pos=_load(ivec2(1,0)).xy;\n    state.ballPos=_load(ivec2(2,0)).xy;\n    state.ballDir=_load(ivec2(3,0)).xy;\n    state.score=_load(ivec2(4,0)).x;\n    state.paddle1UnderControl=_load(ivec2(5,0)).x==1.;\n    return state;\n}\n\n\n\nPaddle getPaddle(in int playerId,in State state){\n\tPaddle paddle;\n    if(playerId==PLAYER1){\n    \tpaddle.pos=state.paddle1Pos;   \n        paddle.underControl=state.paddle1UnderControl;\n    }else{\n     \tpaddle.pos=state.paddle2Pos;  \n        paddle.underControl=false;\n    }\n    paddle.playerId=playerId;    \n    paddle.speed=PADDLE_SPEED*GAME_SPEED;\n    paddle.size=PADDLE_SIZE;\n    paddle.shape=SHAPE_RECT;\n    \n    return paddle;   \n}\n\n\n\nBall getBall(in State state){\n\tBall ball;\n   \n    ball.pos=state.ballPos;\n    ball.speed=state.ballDir*BALL_SPEED*GAME_SPEED;\n\tball.size=BALL_SIZE;\n    ball.shape=SHAPE_RECT;\n    \n    return ball;   \n}\n\n\nvoid setPaddle(inout State state,in Paddle paddle){\n    if(paddle.playerId==PLAYER1){\n    \tstate.paddle1Pos=paddle.pos;   \n    \tstate.paddle1UnderControl=paddle.underControl;\n    }else{\n        state.paddle2Pos=paddle.pos;   \n    }\n    \n}\n\n\nvoid setBall(inout State state,in Ball ball){\n\tstate.ballPos=ball.pos;   \n   \tstate.ballDir=normalize(ball.speed);   \n}\n\n\n\n\n#define MATERIAL_GROUND 1.\n#define MATERIAL_PADDLE 2.\n#define MATERIAL_PADDLE_CONTROLLED 4.\n#define MATERIAL_BALL 3.\n#define MATERIAL_SKY 5.\n\n// fxaa\n/**\nBasic FXAA implementation based on the code on geeks3d.com with the\nmodification that the texture2DLod stuff was removed since it's\nunsupported by WebGL.\n--\nFrom:\nhttps://github.com/mitsuhiko/webgl-meincraft\nCopyright (c) 2011 by Armin Ronacher.\nSome rights reserved.\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above\n      copyright notice, this list of conditions and the following\n      disclaimer in the documentation and/or other materials provided\n      with the distribution.\n    * The names of the contributors may not be used to endorse or\n      promote products derived from this software without specific\n      prior written permission.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n#ifndef FXAA_REDUCE_MIN\n    #define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n    #define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n    #define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent \n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n            vec2 v_rgbNW, vec2 v_rgbNE, \n            vec2 v_rgbSW, vec2 v_rgbSE, \n            vec2 v_rgbM) {\n    vec4 color;\n    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n    vec3 rgbNW = texture(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture(tex, v_rgbSE).xyz;\n    vec4 texColor = texture(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n    \n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    \n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * inverseVP;\n    \n    vec3 rgbA = 0.5 * (\n        texture(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n        texture(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid texcoords(vec2 fragCoord, vec2 resolution,\n\t\t\tout vec2 v_rgbNW, out vec2 v_rgbNE,\n\t\t\tout vec2 v_rgbSW, out vec2 v_rgbSE,\n\t\t\tout vec2 v_rgbM) {\n\tvec2 inverseVP = 1.0 / resolution.xy;\n\tv_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n\tv_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n\tv_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n\tv_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n\tv_rgbM = vec2(fragCoord * inverseVP);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// GAME LOGIC\n\n#define KEY_PLAYER1_UP 38\n#define KEY_PLAYER1_DOWN 40\n\n#define isKey(key) (texelFetch(iChannel0, ivec2(key, 0), 0).x==1.)\n#define isInRect(point,at,size)(point.x>at.x&&point.y>at.y&& point.x<at.x+size.x&&point.y<at.y+size.y)\n\n\nbool ballPaddleCollide(in Ball ball,in Paddle paddle){\n    return isInRect(ball.pos,paddle.pos,paddle.size);\n}\n\nbool ballEdgesCollide(in Ball ball) {\n    return((ball.pos.y>GROUND_SIZE.y||ball.pos.y<0.));\n}\n\nint ballGoal(in Ball ball){\n    return (ball.pos.x>GROUND_SIZE.x?PLAYER1:ball.pos.x<0.?PLAYER2:-1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    limitMemoryRegion();\n    \n    State state=loadState(iChannel1);\n    \n    Paddle paddle1=getPaddle(PLAYER1,state);\n    Paddle paddle2=getPaddle(PLAYER2,state);\n    \n    Ball ball=getBall(state);\n        \n    \n    int goal=ballGoal(ball);\n\n  \n    paddle1.pos.x=0.;\n    paddle2.pos.x=GROUND_SIZE.x-paddle2.size.x;\n    \n    \n    if(isKey(KEY_PLAYER1_UP)){\n        paddle1.pos.y=paddle1.pos.y+paddle1.speed*iTimeDelta;\n        paddle1.underControl=true;\n    }else if(isKey(KEY_PLAYER1_DOWN)){\n        paddle1.pos.y=paddle1.pos.y-paddle1.speed*iTimeDelta;\n        paddle1.underControl=true;\n    }\n    \n    \n    \n    \n    bool reset=length(ball.speed)==0.;\n    \n    if(goal!=-1){\n     \treset=true;\n        if(goal==PLAYER1)state.score++;   \n    }\n    \n    \n    if(reset){\n    \tball.pos=GROUND_SIZE.xy/2.;\n        ball.speed=texture(iChannel2,vec2(iTime,iTime)).rg*2.-1.;\n        ball.speed+=vec2(0.2*sign( ball.speed.x),0);// bias on X\n        ball.speed=normalize(ball.speed);\n        ball.speed*=BALL_SPEED*GAME_SPEED;            \n    }\n\n\n    if(ballEdgesCollide(ball)) ball.speed.y*=-1.;    \t   \n    \n    \n    if(isInPaddle2ActionRegion()){\n    \tfloat d=GROUND_SIZE.x-ball.pos.x;\n        if(d>0.){\n       \t\tpaddle2.pos.y+=sign(ball.pos.y-paddle2.pos.y)*paddle2.speed*iTimeDelta;\n        }        \n    }else if(isInPaddle1ActionRegion()&&!paddle1.underControl){\n    \tfloat d=GROUND_SIZE.x-ball.pos.x;\n        if(d>0.){\n       \t\tpaddle1.pos.y+=sign(ball.pos.y-paddle1.pos.y)*paddle1.speed*iTimeDelta;\n        }        \n    }\n    \n    \n    \n   \n    if(ballPaddleCollide(ball,paddle1)) {\n\t\tif(ball.speed.x<0.)ball.speed.x*=-1.;\n    }else if(ballPaddleCollide(ball,paddle2)){\n    \tif(ball.speed.x>0.)ball.speed.x*=-1.;\n    }\n        \n        \n    ball.pos+=ball.speed*iTimeDelta;\n    \n    \n    paddle1.pos.y=clamp(paddle1.pos.y,0.,GROUND_SIZE.y-paddle1.size.y);\n    paddle2.pos.y=clamp(paddle2.pos.y,0.,GROUND_SIZE.y-paddle2.size.y);\n\n    \n    setPaddle(state,paddle1);\n    setPaddle(state,paddle2);\n    setBall(state,ball);\n    \n    \n    writeState(fragCoord,state,fragColor);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// RENDERER\n\n\nstruct RenderContext{\n  IRes lastMerge;\n};\n    \nRenderContext RenderContext_new(){\n\tRenderContext ctx;\n    ctx.lastMerge.hit=false;\n    ctx.lastMerge.tmin=-1.;\n    return ctx;\n}\n\n    \nbool merge(inout RenderContext ctx,in IRes a){\n    bool m=a.hit&&(!ctx.lastMerge.hit||ctx.lastMerge.tmin>a.tmin);\n\tif(m){\n    \tctx.lastMerge.tmin=a.tmin;\n    \tctx.lastMerge.hit=a.hit;\n \t}   \n\treturn m;\n}\n    \n\n\n#define GROUND_HEIGHT 5.\n#define PADDLE_HEIGHT 32.\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    fragColor=vec4(0);\n\n\n    RenderContext ctx=RenderContext_new();\n\n    State state=loadState(iChannel1);\n\n    Paddle paddle1=getPaddle(PLAYER1,state);\n    Paddle paddle2=getPaddle(PLAYER2,state);\n\n\n\n            \n\n    Camera cam=Camera_newDemo(iTime);\n    Camera_lookAt(cam,vec3(0,1,0),vec3(0,0,0));\n    \n\n   \n\n       \n            \n    Ray r=Ray_fromCam(cam,fragCoord.xy,iResolution.xy);\n\n    IRes res;\n\n    packFb(fragColor,r,r.direction*1000.,-r.direction,MATERIAL_SKY);\n    packFb2(fragColor,r,r.direction*1000.,-r.direction,MATERIAL_SKY);\n\n\n\n     const float scale=0.010;\n                \n    vec3 groundExt=(vec3(GROUND_SIZE.x,GROUND_HEIGHT,GROUND_SIZE.y)/2.)*scale;\n\n    mat4 baseRot=mat4_rotationFromAngleAxis(0.,vec3(0,1,0));\n\n\n    \n    vec3 paddleExt=(vec3(PADDLE_SIZE.x,PADDLE_HEIGHT,PADDLE_SIZE.y)/2.)*scale;\n\n    \t\n    vec3 paddle1Pos=vec3(paddle1.pos.x,GROUND_HEIGHT,paddle1.pos.y)*scale;\n    paddle1Pos.x-=groundExt.x;\n    paddle1Pos.z-=groundExt.z;\n    paddle1Pos.y-=paddleExt.y*2.;\n    paddle1Pos.x+=paddleExt.x;\n    paddle1Pos.z+=paddleExt.z;\n\n    Box paddle1Shape=Box(paddle1Pos,paddleExt,baseRot);\n    res=raytrace(r,paddle1Shape);\n\n    if(merge(ctx,res)){\n        packFb(fragColor,r,res.pos,res.norm,paddle1.underControl?MATERIAL_PADDLE_CONTROLLED:MATERIAL_PADDLE);\n    }\n    \n\n   \n        \t\n    vec3 paddle2Pos=vec3(paddle2.pos.x,GROUND_HEIGHT,paddle2.pos.y)*scale;\n    paddle2Pos.x-=groundExt.x;\n    paddle2Pos.z-=groundExt.z;\n    paddle2Pos.y-=paddleExt.y*2.;\n    paddle2Pos.x+=paddleExt.x;\n    paddle2Pos.z+=paddleExt.z;\n    Box paddle2Shape=Box(paddle2Pos,paddleExt,baseRot);\n\n    res=raytrace(r,paddle2Shape);\n\n    if(merge(ctx,res)){\n        packFb(fragColor,r,res.pos,res.norm,MATERIAL_PADDLE);\n    }\n\n    Ball ball=getBall(state);\n\n    vec3 ballPos=vec3(ball.pos.x,GROUND_HEIGHT-(ball.size.x),ball.pos.y);\n    ballPos*=scale;\n    ballPos=ballPos-groundExt;\n\n\n    Sphere ballShape=Sphere( ballPos,ball.size.x*scale,baseRot);\n    res=raytrace(r,ballShape);\n    if(merge(ctx,res)){\n        packFb(fragColor,r,res.pos,res.norm,MATERIAL_BALL);\n    }\n\n    \n    \n    Box groundShape=Box(vec3(0.,0.,0.),groundExt,baseRot);\n\n    IRes groundHit=raytrace(r,groundShape);\n\n    if(merge(ctx,groundHit)){\n    \tfloat mat=MATERIAL_GROUND;\n            packFb(fragColor,r,groundHit.pos,groundHit.norm,MATERIAL_GROUND);\n\n        Ray reflection;\n        reflection.origin=groundHit.pos;\n        reflection.direction=reflect(r.direction, groundHit.norm);\n\n        res=raytrace(reflection,paddle1Shape);\n        if(merge(ctx,res)){\n            packFb2(fragColor,r,groundHit.pos,groundHit.norm,paddle1.underControl?MATERIAL_PADDLE_CONTROLLED:MATERIAL_PADDLE);\n        }\n        \n        res=raytrace(reflection,paddle2Shape);\n        if(merge(ctx,res)){\n            packFb2(fragColor,r,res.pos,res.norm,MATERIAL_PADDLE);\n        }\n        \n \t\tres=raytrace(reflection,ballShape);\n        if(merge(ctx,res)){\n            packFb2(fragColor,r,res.pos,res.norm,MATERIAL_BALL);\n        }\n        \n        \n\n    }\n\n     \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n\nvec4 getDisplacement(in vec3 pos,in float displacementStrength){\n        vec4 disp=texture(iChannel2,pos.xz*vec2(2,1))*displacementStrength;\nreturn disp;\n}\nvoid lighting(in vec3 pos,in vec3 norm,in vec3 color,in float reflectionStrength,in float displacementStrength,inout vec4 fragColor){\n    \n\tconst float specularStrength=12.4;\n    const vec3 lightDir = normalize(vec3(0.0, -1.0, -0.4));\n    const vec3 lightColor=vec3(1);\n\n    \n    //vec4 disp=texture(iChannel2,pos.xz*vec2(2,1))*displacementStrength;\n\tvec4 disp=getDisplacement(pos,displacementStrength);\n    \n    vec3 cameraOrigin=getCameraOrigin(iTime);\n    \n    \n\tvec3 viewDir = normalize(cameraOrigin - pos)+disp.xyz;\n\t\n    \n    float diff = max(dot(norm, lightDir), 0.0);\n\tvec3 diffuse = diff * lightColor;\n\n    \n    \n    vec3 reflectDir = reflect(-lightDir, norm);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.);\n    vec3 specular = specularStrength * spec * lightColor;  \n    \n    \n    vec3 R = reflect(viewDir, normalize(norm));\n    \n    \n    vec3 reflection=texture(iChannel3,R).rgb;\n    \n    vec3 result = ( reflection*reflectionStrength+diffuse*(1.-reflectionStrength) + specular) *color;\n    \n  \n\tfragColor = vec4(result, 1.0);  \n    \n}\n\nvoid shadeBall(in vec3 pos,in vec3 norm,inout vec4 fragColor){\n  \tlighting(pos,norm,vec3(1,1,0),0.4,0.6,fragColor);\n}\n\nvoid shadeGround(in vec3 pos,in vec3 norm,inout vec4 fragColor){\n\n\tlighting(pos,norm,vec3(1),.7,0.1,fragColor);\n    \n}\n\nvoid shadePaddle(in vec3 pos,in vec3 norm,inout vec4 fragColor,bool controlled){\n   \tlighting(pos,norm,vec3(1,0,0),.3,0.3,fragColor);    \n   if(controlled) fragColor.g=1.;    \n}\n\nvoid shadeSky(in Ray ray,in vec3 pos,in vec3 norm,inout vec4 fragColor){        \n\n    fragColor=texture(iChannel3,-ray.direction);\n}\n\n\n//Random number [0:1] without sine\n#define HASHSCALE1 .1031\nfloat hash(float p){\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n\nvoid edges(in Ray r,in vec3 pos,in vec3 norm,in float mat,in vec2 fragCoord,inout vec4 fragColor){\n    float edge=0.;\n    const int SAMPLES=32;\n    const float maxDist=6.;\n\tfor( int i=0; i<SAMPLES; i++ ){\n\t\tvec2 rand=(vec2(hash(float(i)),hash(float(i)+10000.))*2.-1.)*maxDist;       \n    \tvec3 pos2;\n        vec3 norm2;\n        float matx2;\n    \tunpackFb(texelFetch(iChannel0,ivec2(fragCoord+rand),0), r,pos2, norm2, matx2);\n       \tvec3 cameraOrigin=getCameraOrigin(iTime);\n\n        float d1=distance(pos,cameraOrigin);\n        float d2=distance(pos2,cameraOrigin);\n        \n        edge += d2 >= d1 || matx2==mat?1.0:0.0;\n    }\n    \n    edge=clamp(edge/float(SAMPLES),0.,1.);\n    fragColor*=edge;\n}\n\nvoid shade(in Camera cam,in Ray ray,in vec3 pos,in vec3 norm,in float mat,out vec4 fragColor,in bool sky,in bool ground){\n    if(ground&&mat==MATERIAL_GROUND){\n        shadeGround(pos,norm,fragColor);      \n    }else if(mat==MATERIAL_BALL){\n        shadeBall(pos,norm,fragColor);\n    }else if(mat==MATERIAL_PADDLE){\n        shadePaddle(pos,norm,fragColor,false);\n    }else if(mat==MATERIAL_PADDLE_CONTROLLED){\n        shadePaddle(pos,norm,fragColor,true);\n    }else if(sky&&mat==MATERIAL_SKY){\n        shadeSky(ray,pos,norm,fragColor);\n    }else{\n        fragColor=vec4(0);\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n    fragColor=vec4(0,0,0,1);\n    \n        \n    Camera cam=Camera_newDemo(iTime);\n    Camera_lookAt(cam,vec3(0,1,0),vec3(0,0,0));\n    Ray r=Ray_fromCam(cam,fragCoord.xy,iResolution.xy);\n\n      \n    vec3 pos;\n    vec3 norm;\n    float mat;\n    unpackFb(texelFetch(iChannel0,ivec2(fragCoord),0),r, pos, norm, mat);\n   \n    vec3 rpos;\n    vec3 rnorm;\n   \tfloat rmat;\n    vec4 refDisp= getDisplacement( pos,1.);\n\n    unpackFb2(texelFetch(iChannel0,ivec2(fragCoord),0),r, rpos, rnorm, rmat);\n    \n    vec4 c=vec4(0);\n    shade(cam,r,pos,norm,mat,c,true,true);\n    if(mat==MATERIAL_GROUND){        \n\n      vec4 ref=vec4(0); \n       shade(cam,r,pos,rnorm,rmat,ref,false,false);\n       if(length(ref)>0.)c=mix(c,ref,.5*refDisp.x);\n    }\n    fragColor.rgb=c.rgb;\n    fragColor.a=1.;\n\n    edges(r,pos,norm,mat,fragCoord,fragColor);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 v_rgbNW;\n\tvec2 v_rgbNE;\n\tvec2 v_rgbSW;\n\tvec2 v_rgbSE;\n\tvec2 v_rgbM;\n\n\ttexcoords(fragCoord, iResolution.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\t\n    //vec2 uv=fragCoord/iResolution.xy;\n   // fragColor=texture(iChannel0,uv);\n    \n    fragColor = fxaa(iChannel0, fragCoord, iResolution.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n    //vec4 previousFrame=texelFetch(iChannel1,ivec2(fragCoord),0);\n   \tvec4 previousFrame = fxaa(iChannel1, fragCoord, iResolution.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n\tfragColor.b=mix(fragColor.b,previousFrame.b,0.4);\n\t//fragColor.r=mix(fragColor.r,previousFrame.b,0.1);\n\t//fragColor.g=mix(fragColor.g,previousFrame.b,0.2);\n////\tfragColor.g=mix(fragColor.g,previousFrame.g,0.8);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}