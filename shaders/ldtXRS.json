{
    "Shader": {
        "info": {
            "date": "1460062261",
            "description": "An update...",
            "flags": 0,
            "hasliked": 0,
            "id": "ldtXRS",
            "likes": 15,
            "name": "Visible Clock 2",
            "published": 3,
            "tags": [
                "raymarching",
                "gears",
                "clock"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 790
        },
        "renderpass": [
            {
                "code": "// \"Visible Clock 2\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  The mechanics of timekeeping; when the clock is open time speeds up\n  to show all the gears rotating. This is an improved version that is\n  much faster (and less likely to browser-crash) than the original;\n  the second hand is now shown by default and the mouse is active. \n*/\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrOBoxDf (vec3 p, vec3 b)\n{\n  return length (max (abs (p) - b, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrOBox2Df (vec2 p, vec2 b)\n{\n  return length (max (abs (p) - b, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  vec2 q;\n  q = vec2 (length (p.xy) - rc, p.z);\n  return length (q) - ri;\n}\n\nvec3 ltDir, szCase;\nfloat ntt[12], gRot[6], dstFar, tCur, todCur, tCyc, tSeq, aVelFac, axDist, axRad,\n   wlGap, ttWid, hFac1, hFac2, fadeCase, openMech;\nint idObj, showCase;\nbool visCase;\nconst int idBody = 10, idGearS = 11, idGearB = 12, idAxH = 13, idAxM = 14,\n   idAxS = 15, idAxF = 16, idAxB = 17, idBar = 18, idCase = 19, idRing = 20,\n   idFoot = 21;\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec2 u;\n  float a;\n  rd.z *= -1.;\n  ro.z *= -1.;\n  a = 0.5 * atan (length (rd.xy), rd.z);\n  rd = normalize (vec3 (rd.xy * tan (a), 1.));\n  u = vec2 (ro.xy + 2. * tCur + rd.xy * (100. - ro.z) /rd.z);\n  return mix (mix (vec3 (0.2, 0.2, 0.6), vec3 (1.), 0.7 * Fbm2 (0.1 * u)),\n     vec3 (0.3, 0.3, 0.6), smoothstep (0.35 * pi, 0.4 * pi, a));\n}\n\nfloat GearWlDf (vec3 p, float rtFac, float nth, float aRot, float tWid,\n   float wlThk, float dMin, int idGear)\n{\n  vec3 q, qq;\n  float nspi, rad, d, a, g, r;\n  q = p;\n  nspi = 1./8.;\n  rad = rtFac * nth;\n  r = rad - 1.5 * tWid;\n  d = PrOBox2Df (vec2 (length (q.xz) - r, q.y), vec2 (2. * tWid, wlThk));\n  q.zx = Rot2D (q.zx, aRot);\n  g = atan (q.z, - q.x);\n  if (d < dMin) {\n    qq = q;\n    a = 2. * pi / nth;\n    qq.xz = Rot2D (qq.xz, a * floor (g / a + 0.5));\n    d = 0.4 * max (d, - (r + clamp (2. * (abs (qq.z) - tWid) - abs (qq.x),\n       qq.x - tWid, qq.x + tWid)));\n  }\n  d = min (d, PrCylDf (q.xzy, 5.2 * wlThk, 2. * wlThk));\n  a = 2. * pi * nspi;\n  q.xz = Rot2D (q.xz, a * floor (g / a + 0.5));\n  q.x += 0.5 * (rad - tWid);\n  d = min (d, PrOBoxDf (q, vec3 (0.5 * rad - 2. * tWid, wlThk, 0.03 * rad)));\n  if (d < dMin) { dMin = d;  idObj = idGear; }\n  return dMin;\n}\n\nfloat GearsDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, angRot, rtFac, sx, tw, rtFacB, wlThk, f1, f2;\n  int kk;\n  wlThk = 0.16;\n  rtFacB = (7./32.);\n  kk = int (floor (3. - p.y / wlGap));\n  if (kk >= 0 && kk < 6) {\n    sx = -1.;\n    for (int k = 0; k < 6; k ++) {\n      sx = - sx;\n      wlThk *= 0.92;\n      f1 = ntt[2 * k];\n      f2 = ntt[2 * k + 1];\n      angRot = gRot[k];\n      if (k == kk) break;\n    }\n    rtFac = rtFacB;\n    tw = ttWid;\n    if (kk == 1) rtFac *= 0.8;\n    else if (kk == 4) {\n      rtFac *= 0.66667;\n      tw *= 0.65;\n    }\n    q = p;\n    q.y = mod (q.y, wlGap) - 0.5 * wlGap;\n    q.x -= sx * axDist;\n    dMin = GearWlDf (q, rtFac, f1, angRot, ttWid, wlThk, dMin, idGearB);\n    angRot = - (f1 / f2) * angRot + pi / f2;\n    q.x -= -2. * sx * axDist;\n    dMin = GearWlDf (q, rtFac, f2, angRot, tw, wlThk, dMin, idGearS);\n  }\n  return dMin;\n}\n\nfloat GearsRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float d, dHit, srd, dda;\n  srd = - sign (rd.y);\n  dda = - srd / (rd.y + 0.00001);\n  dHit = PrOBoxDf (ro, vec3 (szCase.x, 3. * wlGap, szCase.z));\n  for (int j = 0; j < 200; j ++) {\n    p = ro + dHit * rd;\n    d = GearsDf (p, dstFar);\n    dHit += min (d, wlGap * (0.3 + max (0.,\n       fract (dda * fract (srd * p.y / wlGap)))));\n    if (d < 0.0001 || dHit > dstFar) break;\n  }\n  if (d >= 0.0001) dHit = dstFar;\n  return dHit;\n}\n\nfloat AxlesDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;  q.xy -= vec2 (- axDist, 2. * wlGap);\n  d = PrCylDf (q.xzy, axRad, 0.9 * wlGap);\n  q = p;  q.xy -= vec2 (- axDist, 1.5 * wlGap);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.3 * wlGap));\n  q = p;  q.xy -= vec2 (- axDist, 0.);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.9 * wlGap));\n  q = p;  q.xy -= vec2 (axDist, -0.5 * wlGap);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.4 * wlGap));\n  q = p;  q.xy -= vec2 (axDist, - wlGap);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.9 * wlGap));\n  q = p;  q.xy -= vec2 (axDist, -1.5 * wlGap);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.4 * wlGap));\n  q = p;  q.xy -= vec2 (- axDist, -2. * wlGap);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.9 * wlGap));\n  if (d < dMin) { dMin = d;  idObj = idAxB; }  \n  q = p;  q.y = abs (q.y) - 2.75 * wlGap;\n  d = PrOBoxDf (q, vec3 (axDist - 1.8 * axRad, 0.3 * axRad, 0.7 * axRad));\n  q.x = abs (q.x) - axDist;\n  d = min (d, PrCylDf (q.xzy, 2. * axRad, 0.3 * axRad));\n  if (d < dMin) { dMin = d;  idObj = idBar; }\n  q = p;  q.xy -= vec2 (- axDist, 0.);\n  d = PrCylDf (q.xzy, 0.5 * axRad, 3.05 * wlGap);\n  if (d < dMin) { dMin = d;  idObj = idAxF; }  \n  return dMin;\n}\n\nfloat HandsDf (vec3 p, float dMin)\n{\n  vec3 q, pp;\n  float d, angRot;\n  pp = p;\n  p.y -= 2.5 * wlGap;\n  q = p;  q.xy -= vec2 (axDist, 0.25 * wlGap);\n  d = PrCylDf (q.xzy, 1.5 * axRad, 0.7 * wlGap);\n  if (d < dMin) { dMin = d;  idObj = idAxH; }  \n  p.y += 2. * wlGap;\n  q = p;  q.xy -= vec2 (axDist, 1.5 * wlGap);\n  d = PrCylDf (q.xzy, axRad, 2. * wlGap);\n  if (d < dMin) { dMin = d;  idObj = idAxM; }  \n  p.y += 3. * wlGap;\n  q = p;  q.xy -= vec2 (axDist, 3.2 * wlGap);\n  d = PrCylDf (q.xzy, 0.5 * axRad, 3.6 * wlGap);\n  if (d < dMin) { dMin = d;  idObj = idAxS; }  \n  p = pp;\n  p.xy -= vec2 (axDist, 0.5 * wlGap);\n  angRot = - gRot[0];\n  q = p;\n  q.xz = Rot2D (q.xz, angRot - 0.5 * pi);\n  q.xy -= vec2 (-2., 2.85 * wlGap);\n  d = PrCapsDf (q.zyx, 0.5 * ttWid, 2.);\n  if (d < dMin) { dMin = d;  idObj = idAxH; }\n  angRot *= hFac1;\n  q = p;\n  q.xz = Rot2D (q.xz, angRot - 0.5 * pi);\n  q.xy -= vec2 (-2.5, 3.25 * wlGap);\n  d = PrCapsDf (q.zyx, 0.5 * ttWid, 2.5);\n  if (d < dMin) { dMin = d;  idObj = idAxM; }\n  angRot *= hFac2;\n  q = p;\n  q.xz = Rot2D (q.xz, angRot - 0.5 * pi);\n  q.xy -= vec2 (-2.7, 3.65 * wlGap);\n  d = PrCapsDf (q.zyx, 0.3 * ttWid, 3.2);\n  if (d < dMin) { dMin = d;  idObj = idAxS; }\n  return dMin;\n}\n\nfloat CaseDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  p.y -= -0.8 + 0.5 * wlGap;\n  q = p;\n  d = PrRoundBoxDf (q, szCase - 0.5, 0.5);\n  if (d < dMin) { dMin = d;  idObj = idCase; }\n  q.xy -= vec2 (-8., 4.3);\n  d = PrTorusDf (q.xzy, 0.22, 3.2);\n  q = p;\n  q.xy -= vec2 (axDist, 4.3);\n  d = min (d, PrTorusDf (q.xzy, 0.22, 7.2));\n  if (d < dMin) { dMin = d;  idObj = idRing; }\n  q = p;  q.xy = abs (q.xy) - vec2 (10., 2.4);  q.z -= 8.7;\n  d = PrCylDf (q, 1., 0.5);\n  if (d < dMin) { dMin = d;  idObj = idFoot; }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  if (visCase) dMin = CaseDf (p, dMin);\n  else dMin = AxlesDf (p, dMin);\n  dMin = HandsDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  if (d >= 0.001) dHit = dstFar;\n  return dHit;\n}\n\nfloat ObjNDf (vec3 p)\n{\n  float dMin;\n  dMin = ObjDf (p);\n  if (! visCase) dMin = GearsDf (p, dMin);\n  return dMin;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjNDf (p + e.xxx), ObjNDf (p + e.xyy),\n     ObjNDf (p + e.yxy), ObjNDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nvec4 ObjCol (vec3 ro)\n{\n  vec4 objCol;\n  vec2 s;\n  float a;\n  if (idObj == idCase) {\n    objCol = vec4 (0.9, 0.9, 1., 1.);\n    if (ro.y > 0.) {\n      s = ro.xz - vec2 (axDist, 0.);\n      if (length (s) < 7.) {\n        objCol = vec4 (0.8, 0.8, 0.6, 0.5);\n        a = 6. * (atan (s.y, - s.x) / pi + 1.);\n        if (abs (mod (a + 0.5, 1.) - 0.5) < 0.05 &&\n           abs (length (s.xy) - 5.9) < 0.9) objCol *= 0.1;\n      } else if (length (ro.xz - vec2 (-8., 0.)) < 3.) objCol =\n         vec4 (0.8, 0.75, 0.8, 0.) * (1. - 0.5 * Noisefv2 (50. * ro.xz));\n    }\n  } else if (idObj == idRing) objCol = vec4 (0.7, 0.7, 0.1, 1.);\n  else if (idObj == idGearB) objCol = vec4 (1., 1., 0.5, 1.);\n  else if (idObj == idGearS) objCol = vec4 (0.8, 0.8, 0.2, 1.);\n  else if (idObj == idAxB) objCol = vec4 (0.6, 0.6, 0.3, 1.);\n  else if (idObj == idAxH) objCol = vec4 (1., 0.3, 0.2, 1.);\n  else if (idObj == idAxM) objCol = vec4 (0.3, 0.2, 1., 1.);\n  else if (idObj == idAxS) objCol = vec4 (0.3, 1., 0.2, 1.);\n  else if (idObj == idAxF || idObj == idBar) objCol = vec4 (0.6, 0.3, 0.2, 1.);\n  else if (idObj == idFoot) objCol = vec4 (0.4, 0.4, 0.4, 0.1);\n  return objCol;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 vn, roo, col, colC, colNC;\n  float dstObj, d, f;\n  int idObjT, showMode;\n  colC = vec3 (0., 0., 0.2);\n  colNC = colC;\n  showMode = showCase;\n  if (fadeCase == 0.) showMode = 0;\n  else if (fadeCase == 1.) showMode = 2;\n  if (showMode > 0) {\n    roo = ro;\n    visCase = true;\n    dstObj = ObjRay (ro, rd);\n    if (dstObj < dstFar) {\n      ro += rd * dstObj;\n      idObjT = idObj;\n      vn = ObjNf (ro);\n      idObj = idObjT;\n      objCol = ObjCol (ro);\n      colC = objCol.rgb * (0.2 + max (dot (vn, ltDir), 0.) +\n         objCol.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.));\n      if (idObj == idCase && objCol.a > 0.5)\n         colC = mix (colC, BgCol (ro, reflect (rd, vn)), 0.15);\n    }\n    ro = roo;\n  }\n  if (showMode < 2) {\n    visCase = false;\n    dstObj = GearsRay (ro, rd);\n    idObjT = idObj;\n    d = ObjRay (ro, rd);\n    if (d < dstObj) {\n      dstObj = d;\n    } else {\n      idObj = idObjT;\n    }\n    if (dstObj < dstFar) {\n      ro += rd * dstObj;\n      idObjT = idObj;\n      vn = ObjNf (ro);\n      idObj = idObjT;\n      objCol = ObjCol (ro);\n      colNC = objCol.rgb * (0.2 + max (dot (vn, ltDir), 0.) +\n         objCol.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.));\n    }\n  }\n  if (showMode == 1) col = mix (colNC, colC, fadeCase);\n  else col = (showMode == 0) ? colNC : colC;\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid SetConfig ()\n{\n  tCyc = 40.;\n  tSeq = mod (tCur, tCyc);\n  if (showCase == 1) {\n    fadeCase = 1. - SmoothBump (0.15, 0.85, 0.05, tSeq / tCyc);\n    openMech = SmoothBump (0.25, 0.75, 0.05, tSeq / tCyc);\n  } else if (showCase == 0) {\n    fadeCase = 0.;\n    openMech = 1.;\n  } else {\n    fadeCase = 1.;\n    openMech = 0.;\n  }\n  aVelFac = 2. * pi / (12. * 3600.);\n  if (showCase < 2) aVelFac *=\n     (1. + 69. * SmoothBump (0.4, 0.6, 0.002, tSeq / tCyc));\n  wlGap = 1.4 * (1. + 1.3 * openMech);\n  szCase = vec3 (13.5, 4.4, 8.5);\n  axDist = 4.83;\n  axRad = 0.3;\n  ttWid = 0.35;\n  ntt[0] = 36.; ntt[1] = 12.; ntt[2] = 48.;  ntt[3] = 12.;\n  ntt[4] = 32.; ntt[5] = 16.; ntt[6] = 36.;  ntt[7] = 12.;\n  ntt[8] = 60.; ntt[9] = 12.; ntt[10] = 32.; ntt[11] = 16.;\n  hFac1 = (ntt[0] / ntt[1]) * (ntt[2] / ntt[3]);\n  hFac2 = (ntt[4] / ntt[5]) * (ntt[6] / ntt[7]) * (ntt[8] / ntt[9]) *\n     (ntt[10] / ntt[11]);\n  gRot[0] = - todCur * aVelFac;\n  for (int k = 0; k < 5; k ++)\n     gRot[k + 1] = - gRot[k] * ntt[2 * k] / ntt[2 * k + 1];\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  showCase = 1;\n  dstFar = 80.;\n  az = pi;\n  el = 0.5 * pi;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el -= pi * mPtr.y;\n  }\n  el = clamp (el, 0.4 * pi, 0.9 * pi);\n  SetConfig ();\n  if (showCase == 1) az +=\n     (1. - 2. * floor (mod (tCur / (3. * tCyc), 2.))) * 2. * pi * tSeq / tCyc;\n  el -= 0.04 * pi * openMech;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  rd = vuMat * normalize (vec3 (uv, 4.));\n  ro = vuMat * vec3 (0., 0., -50.);\n  ltDir = vuMat * normalize (vec3 (1., 0.5, -1.));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}