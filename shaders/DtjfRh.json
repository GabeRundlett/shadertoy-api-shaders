{
    "Shader": {
        "info": {
            "date": "1693759802",
            "description": "Live long and prosper.",
            "flags": 96,
            "hasliked": 0,
            "id": "DtjfRh",
            "likes": 53,
            "name": "Star Wars: The Force Awakens",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "reflections",
                "scifi",
                "movie"
            ],
            "usePreview": 1,
            "username": "dean_the_coder",
            "viewed": 918
        },
        "renderpass": [
            {
                "code": "// 'Star Wars: The Force Awakens' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/DtjfRh\n// YouTube: https://youtu.be/WMf8LMZy3l0\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Tricks to aid performance:\n//   - Precalculate function results and simplify calculations\n//     when possible (see GLSL Shader Shrinker).\n//   - SDF fine details only modelled when ray is near a surface.\n//   - Using bump maps over SDF displacement where possible.\n//     (Displacing an SDF is much more expensive at the code is\n//     ever time the ray moves, whereas a bump is only applied once\n//     when the ray has hit a surface.)\n//   - AA only applied on pixels where the neighbouring\n//     pixel is a significantly different color.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n#define CHROMATIC\t0.003\n#define LENS\t0.005\n\n#define _res iResolution\n#define _tex0 iChannel0\n\nvec2 fisheye(vec2 uv) {\n\tuv -= 0.5;\n\tuv *= pow(dot(uv, uv), LENS);\n\treturn uv + 0.5;\n}\n\n// Thnx Dave_Hoskins\nvec2 h22(vec2 p) {\n\tvec3 v = fract(p.xyx * vec3(.1031, .1030, .0973));\n\tv += dot(v, v.yzx + 333.33);\n\treturn fract((v.xx + v.yz) * v.zy);\n}\n\nfloat h21(vec2 p) {\n\tp += 353.627;\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .11369, .13787));\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat film(vec2 uv) {\n\t// Film grain.\n\tfloat c = (h21(uv * _res.xy) - 0.5) / 64.;\n\n\t// Lens dust.\n\tuv *= 4.;\n\tfloat sm = 0.1;\n\tfor (int i = 0; i < 3; i++, uv++) {\n\t\tvec2 p = fract(uv) - 0.5,\n\t\t     id = floor(uv);\n\t\tfloat s = h21(id) * sm;\n\t\tp += h22(id) * (1.0 - sm) * 0.5;\n\t\tc = max(c, smoothstep(s, s * 0.5, length(p)) * 0.02);\n\t\tsm *= 0.5;\n\t\tuv *= 2.282;\n\t}\n\n\treturn c;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 uv = fragCoord / _res.xy;\n\n\t// Lens distortion.\n\tuv = fisheye(uv);\n\n\t// Chromatic aberration.\n\tvec2 ca = (uv - 0.5) * CHROMATIC;\n\tfragColor = vec4(texture(_tex0, uv + ca).r, texture(_tex0, uv).g, texture(_tex0, uv - ca).ba);\n\tif (fragColor.w > 0.0) fragColor.rgb += film(uv * vec2(1, _res.y / _res.x));\n\n\t// Color correction.\n\tfragColor = pow(fragColor, vec4(0.4545));\n\n\t// Vignette.\n\tuv -= 0.5;\n\tfragColor *= 1.0 - 0.5 * dot(uv, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 34626,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/planewhitenoise/plane-engine"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// 'Star Wars: The Force Awakens' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/DtjfRh\n// YouTube: https://youtu.be/WMf8LMZy3l0\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n//#define AA    // Disable if your GPU is melting.\n\n#define LIGHT_RGB\tvec3(2, 1.6, 1.4)\n#define R\t_res\n#define Z0\tmin(_t, 0.)\n#define I0\tmin(int(_t), 0)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S\tsmoothstep\n#define S01(a)\tS(0., 1., a)\n\n#define _res iResolution\n#define _tex0 iChannel0\n#define _t iTime\n\nfloat t, xw, roll,\n      fade = 1.;\nvec2 g;\nvec3 lp, xp;\n\nstruct Hit {\n\tfloat d, id;\n\tvec3 p;\n};\n\nvoid U(inout Hit h, float d, float id, vec3 p) { if (d < h.d) h = Hit(d, id, p); }\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat dot3(vec3 v) { return dot(v, v); }\n\nfloat sum2(vec2 v) { return dot(v, vec2(1)); }\n\nfloat mul2(vec2 v) { return v.x * v.y; }\n\nvec2 h22(vec2 p) {\n\tvec3 v = fract(p.xyx * vec3(.1031, .103, .0973));\n\tv += dot(v, v.yzx + 333.33);\n\treturn fract((v.xx + v.yz) * v.zy);\n}\n\nfloat h31(vec3 p) {\n\tp = fract(p * .3183099 + .1);\n\tp *= 17.;\n\treturn fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat h21(vec2 p) {\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .11369, .13787));\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat n21(vec2 p) {\n\tvec2 i = floor(p),\n\t     f = fract(p);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(mix(h21(i), h21(i + vec2(1, 0)), f.x), mix(h21(i + vec2(0, 1)), h21(i + 1.), f.x), f.y);\n}\n\nfloat n31(vec3 p) {\n\tvec3 i = floor(p),\n\t     f = fract(p);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(mix(mix(h31(i), h31(i + vec3(1, 0, 0)), f.x), mix(h31(i + vec3(0, 1, 0)), h31(i + vec3(1, 1, 0)), f.x), f.y), mix(mix(h31(i + vec3(0, 0, 1)), h31(i + vec3(1, 0, 1)), f.x), mix(h31(i + vec3(0, 1, 1)), h31(i + 1.), f.x), f.y), f.z);\n}\n\nfloat fbm(vec3 p, float roughness) {\n\tint octaves = 4;\n\tfloat sum = 0.,\n\t      amp = 1.,\n\t      tot = 0.;\n\troughness = sat(roughness);\n\tfor (int i = I0; i < octaves; i++) {\n\t\tsum += amp * n31(p);\n\t\ttot += amp;\n\t\tamp *= roughness;\n\t\tp *= 2.;\n\t}\n\treturn sum / tot;\n}\n\nvec3 randomPos(float seed) {\n\tvec4 s = vec4(seed, 0, 1, 2);\n\treturn vec3(h21(s.xy), h21(s.xz), h21(s.xw)) * 1e2 + 1e2;\n}\n\nfloat fbmDistorted(vec3 p, float roughness, float distortion) {\n\tp += (vec3(n31(p + randomPos(0.)), n31(p + randomPos(1.)), n31(p + randomPos(2.))) * 2. - 1.) * distortion;\n\treturn fbm(p, roughness);\n}\n\nfloat sabs(float f) { return sqrt(f * f + .1); }\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 ryz(vec3 p, float a) {\n\tp.yz *= rot(a);\n\treturn p;\n}\n\nvec3 dx(vec3 p, float e) {\n\tp.x += e;\n\treturn p;\n}\n\nvec3 dy(vec3 p, float e) {\n\tp.y += e;\n\treturn p;\n}\n\nvec3 dz(vec3 p, float e) {\n\tp.z += e;\n\treturn p;\n}\n\nvec3 ay(vec3 p, float d) { return vec3(p.x, abs(p.y) - d, p.z); }\n\nvec3 az(vec3 p) { return vec3(p.xy, abs(p.z) + .05); }\n\nfloat weld(float a, float b, float r) {\n\t// Thanks Mercury - http://mercury.sexy/hg_sdf/\n\treturn min(min(a, b), (a - r + b) * .70711);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.zy), p.x)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cap(vec3 p, float r) {\n\tp.x -= clamp(p.x, 0., .3);\n\treturn length(p) - r;\n}\n\nfloat hex3D(vec3 p, vec2 h) {\n\tconst vec3 k = vec3(-.8660254, .5, .57735);\n\tp = abs(p);\n\tp.zy -= 2. * min(dot(k.xy, p.zy), 0.) * k.xy;\n\tvec2 d = vec2(length(p.zy - vec2(clamp(p.z, -k.z * h.x, k.z * h.x), h.x)) * sign(p.y - h.x), p.x - h.y);\n\treturn min(max2(d), 0.) + length(max(d, 0.));\n}\n\nfloat greeble(vec3 p) {\n\tfloat h = .005,\n\t      d = p.y;\n\tfor (float i = 1.; i <= 3.; i++) {\n\t\tvec3 q = p;\n\t\tq.xz = fract(p.xz) - .5;\n\t\tvec2 r = h22(floor(p.xz) + i * 2.2);\n\t\td = min(d, box(q, vec3(.05 + .35 * r, h * (.5 + .5 * fract(r.x * 157.324))).xzy));\n\t\th *= 1.5;\n\t\tp.xz *= 1.5;\n\t\tp.xz += .5 / i;\n\t}\n\n\treturn d * .8;\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvec3 skyCol(float y) { return pow(vec3(max(1. - y * .5, 0.)), vec3(6, 3, 1.5)) * vec3(.95, 1, 1) * (1. - pow(vec3(2), -vec3(35, 14, 7))); }\n\nvec3 sky(vec3 rd) {\n\tvec3 p,\n\t     col = skyCol(rd.y);\n\tfloat den,\n\t      d = 10. / rd.y;\n\tif (d < 0.) return col;\n\tp = rd * d + vec3(4, .2, 1) * t * .2;\n\tp.xz *= .2;\n\tden = 1.;\n\tfor (int i = 0; i < 3; i++)\n\t\tden *= exp(-.06 * fbm(p, .5));\n\n\treturn mix(col, LIGHT_RGB, S(.8, 1., den) * (1. - sat(d / 1e2)));\n}\n\nfloat fakeEnv(vec3 n) {\n\t// Thanks Blackle.\n\treturn length(sin(n * 2.5) * .5 + .5) / 1.73205;\n}\n\nfloat texScratches(vec3 p) {\n\tfloat sh = S(.85, 1., n31(p * vec3(80, 12, 1)));\n\tp.xy = p.yx * mat2(.76031, .64956, -.64956, .76031);\n\treturn max(sh, S(.85, 1., n31(p * vec3(80, 10, 1))));\n}\n\nfloat taperHex(vec3 p, float w, float h1, float h2, float l, float s, float wt) {\n\tw *= 1. - (p.x / l + .5) * wt;\n\treturn max(hex3D(p, vec2(w * .5, l * .5) - s) - s, abs(p.y) - mix(h1, h2, p.x / l + .5) * .5);\n}\n\nfloat wing(inout vec3 op) {\n\top.x += .25;\n\top.z = abs(op.z);\n\top = ryz(ay(dz(op, -.26), .02), xw * -.2);\n\tvec3 q,\n\t     p = op;\n\n\t// Wing.\n\tfloat d, l,\n\t      f = .05;\n\tf += p.z * .1;\n\tf += .065 * step(p.z, .5);\n\td = box(dx(p, -f), vec3(.4 - f, .005, 1.6));\n\tp.x -= .15;\n\tp.z -= .4;\n\n\t// Engine.\n\tf = .2 - .05 * S(.2, 0., p.x);\n\td = weld(d, max(cyl(p, vec2(f, .45)), -p.y - .005), .04 * step(0., p.y));\n\n\t// Exhaust.\n\tq = p - vec3(-.72, .16, 0);\n\tf = .04 - .003 * sat(sin(atan(q.y, q.z) * 16.)) * S(.05, .04, q.x);\n\tf += .003 * S(.02, .03, abs(abs(q.x - .15) - .05));\n\tf = cap(q, f);\n\tl = length(q + vec3(.06, 0, 0));\n\tf = max(f, .08 - l);\n\td = weld(d, f, .015);\n\tg.x += .02 / (.01 + l * l * 10.) * S(.05, -.05, q.x);\n\n\t// Inlet.\n\td = smin(d, -max(max(length(p.yz) - .17, -.02 - p.y), abs(p.x - .45) - .05), -.05);\n\n\t// Gunz.\n\tp -= vec3(.05, .026, 1.2);\n\td = min(d, cyl(p, vec2(.03 - .01 * S(.31, .32, abs(p.x)), .33)));\n\tp.x -= .5;\n\td = min(d, cyl(p, vec2(step(p.x, 0.) * .005, .4)));\n\tp.x -= .32;\n\tp.yz *= mat2(.49757, .86742, -.86742, .49757);\n\tf = length(p.xy);\n\treturn min(d, max(max(max(f - .04, .045 - f), p.x), abs(p.z) - .006)) * .95;\n}\n\nfloat mountains(vec3 p) {\n\tp.z = abs(p.z);\n\tp += vec3(32. * t * .3, 2, -45);\n\tfloat d = length(p.yz);\n\t\n\tif (d < 13.0)\n\t    d -= fbm(vec3(p.x * .5, 0, p.z) * .1, .4) * 12.;\n\treturn smin(d, p.y + 2., 8.) * .9;\n}\n\nHit sdf(vec3 p) {\n\tp.x += .5;\n\t\n\tvec3 q,\n\t     op = p;\n\tHit h;\n\th.d = 1e7;\n\tU(h, mountains(p), 7., p);\n\t\n\t// Movement.\n\tp -= xp * vec3(1, 2, 1);\n\tp.yz *= rot(roll);\n\n\t// Rear body.\n\tfloat f, d = taperHex(az(p), .6, .7, .5, .9, 0., .19);\n\td = smin(d, max(box(p, vec3(.45, .35, .2)), -p.y), .02);\n\td = max(d, abs(p.z) + p.y * .45 - .3);\n\td = max(d, p.y - p.x * .2 - .38);\n\td = max(d, -p.y - p.x * .1 - .24);\n\n\t// Rear end bit.\n\td = weld(d, box(ay(dy(dx(p, .4), -.05), .1), vec3(.12, .08, .08)), .02);\n\n\t// Wings.\n\tq = p;\n\tif (abs(p.z) < 7.0)\n\t    U(h, wing(q), 3.005, q);\n\n\t// Fuselage.\n\tq = p;\n\tq.x -= 1.7;\n\td = min(d, taperHex(q, .4, .36, .21, 2.5, 0., .3));\n\n\t// Nose.\n\tq.x -= 1.45;\n\tf = taperHex(q, .32, .26, .05, .6, .03, .4);\n\tf = max(f, q.y * .5 - q.x - .25);\n\tq.y -= .1;\n\tf = max(f, -box(q, vec3(.15, .04, .06)));\n\td = min(d, f);\n\n\t// BB-8\n\tq = p - vec3(.15, .37, 0);\n\tf = box(q, vec3(.23, .05, .1));\n\td = max(d, -f);\n\t\n\tif (f < 0.1)\n\t    f = max(f, greeble(dy(p, -.32) * vec3(6, 1, 6)));\n\td = min(d, f);\n\tf = length(p - vec3(.25, .31, 0));\n\td = max(d, .082 - f);\n\tU(h, d, 2.005, p);\n\tq = p - vec3(.25, .37, 0);\n\tU(h, f - .05, 8.01, q);\n\tq.xz *= rot(n21(vec2(t, t)) * 2.5 - 1.8);\n\tU(h, length(q) - .03, 8.01, q);\n\td = max(cyl(dy(q, -.015), vec2(0, .032)), -q.x);\n\td = min(d, cyl(dy(q.yxz, .01), vec2(-.008, .06)));\n\tU(h, d, 6.045, q);\n\n\t// Cockpit.\n\tq = p;\n\tq.xy -= vec2(.865, .16);\n\td = taperHex(q, .35, .4, .02, .8, 0., .4);\n\tU(h, d, 6.045, p);\n\n\t// Water level.\n\tp = op;\n\td = p.y + 2.;\n\n\t// Water plume.\n\tif (xp.y < 0.8) {\n    \tq = p.zyx;\n    \tq.z += 2. + xp.y * 10.;\n    \tq.x = sabs(q.x) - 2. * (1. - xp.y) + q.z * .3;\n    \tq.xy *= rot(-.4 * (1. - xp.y));\n    \tq.y += 5. + S(-4., 0., p.x) + xp.y * 4.;\n    \tf = cyl(q, vec2(4, sin((p.x + sign(p.z) * 4.) * .2 + t * 5.5) * .2));\n    \td = smin(d, f, 1. + 2. * S(0., -6., p.x) + sat(abs(p.z) * .5));\n    \tg.y += .01 / (.1 + f * f) * S(-.2, .1, q.x);\n\t}\n\n\tU(h, d, 4.3, p);\n\n\t// Nothing is perfectly sharp.\n\th.d -= .01;\n\treturn h;\n}\n\nvec3 N(vec3 p, float d) {\n\tfloat h = d * .05;\n\tvec3 n = vec3(0);\n\tfor (int i = I0; i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdf(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld, vec3 n) {\n\t// Quick abort if light is behind the normal.\n\tif (dot(ld, n) < -.1) return 0.;\n\n\tfloat s = 1.,\n\t      l = .01,\n\t      mxL = length(p - lp);\n\tfor (float i = Z0; i < 30.; i++) {\n\t\tfloat d = sdf(l * ld + p).d;\n\t\ts = min(s, mix(50., 7., .8) * d / l);\n\t\tl += max(.03, d);\n\t\tif (mxL - l < .5 || s < .001) break;\n\t}\n\n\treturn S01(s);\n}\n\nfloat ao(vec3 p, vec3 n) {\n\tconst vec2 h = vec2(.1, 1);\n\tvec2 ao;\n\tfor (int i = I0; i < 2; i++)\n\t\tao[i] = sdf(h[i] * n + p).d;\n\n\treturn sat(mul2(.2 + .8 * ao / h));\n}\n\nvec3 lights(vec3 p, vec3 ro, vec3 rd, inout vec3 n, Hit h, float fogAdjust) {\n\tif (h.id == 0.) return sky(rd);\n\tfloat _ao, sha, fogY, fg,\n\t      spe = 10.,\n\t      shine = 1.;\n\tvec3 c, l, col, uv,\n\t     ld = normalize(lp - p);\n\n\t// Calculate ambient occlusion and shadows.\n\t_ao = ao(p, n);\n\tsha = shadow(p, ld, n);\n\n\tif (h.id == 6.045) {\n\t\tc = vec3(-.01);\n\t\tshine = 1.5 + n31(h.p * 40.);\n\t}\n\telse if (h.id == 2.005 || h.id == 3.005) {\n\t\tshine = 5.;\n\t\tspe = 150.;\n\t\tc = vec3(.03);\n\n\t\t// Orange.\n\t\tfloat f,\n\t\t      b = 0.;\n\t\tif (h.id == 2.005) {\n\t\t\t// Fuselage.\n\t\t\tif (abs(h.p.y - .035) < .04 && h.p.x > -.42 && h.p.x < 2.875 + h.p.y * .6) b = S(1., .995, sin(h.p.x * 5.));\n\t\t\telse b = float(abs(h.p.x - 2.2) < .2 && h.p.y > .09);\n\t\t}\n\t\telse {\n\t\t\t// Wings.\n\t\t\tif (abs(h.p.x - .52) < .02 && h.p.z < 1.) b = 1.;\n\t\t\telse b = float(abs(h.p.z - 1.1) < .35 && h.p.x - abs(h.p.z) * .15 > 0.);\n\n\t\t\tif (abs(h.p.x - .6) < .02 && h.p.z < 1.) c = vec3(.1, .1, .15);\n\t\t}\n\n\t\tb *= .5 + .5 * n31(h.p * 40.);\n\t\tc = mix(c, vec3(.4, .12, .01), b);\n\n\t\t// BB-8's nest.\n\t\tif (abs(h.p.x - .145) < .21 && abs(h.p.z) < .088 && h.p.y > .334) c *= 8.;\n\n\t\t// Dirt/scratches.\n\t\tf = texScratches(h.p.zyx * vec3(2, 12, 15) + 13.34);\n\t\tc += f * .1;\n\t\tshine *= 1. + f * 5.;\n\t\tc *= .1 + .9 * n31(h.p * 8.);\n\t}\n\telse if (h.id == 4.3) {\n\t\tc = vec3(.07, .12, .1);\n\n\t\t// Bump map the surface detail.\n\t\tfloat f = n31((p + vec3(t * 32., t, 0)) * vec3(1, 1, 10)) - .5;\n\t\tn = normalize(n + f * .1);\n\n\t\t// Plume.\n\t\tf = S(0., 1., h.p.y + 2.);\n\t\tf += S(.8, 1., h.p.y + 2.);\n\t\tc += vec3(.2 + 1. * fbmDistorted(p + vec3(t * 9.6, 0, 0), f, 3. * f)) * f;\n\t\tn = normalize(dz(n, sin(p.z * 8. * (1. - xp.y)) * f * .5));\n\t}\n\telse if (h.id == 7.) c = vec3(.1, .12, .06);\n\telse{\n\t\tc = vec3(.35, .35, .4);\n\t\tif (abs(h.p.y + .015) < .005 || abs(abs(h.p.y - .015) - .015) < .002 || length(h.p.yz + vec2(.06, 0)) < .03) c = vec3(.32, .1, .08);\n\t\telse if (abs(h.p.y - .036) < .002) c *= .5;\n\t}\n\n\tl = sat(vec3(dot(ld, n),  // Key light.\n\tdot(-ld.xz, n.xz),  // Reverse light.\n\tn.y // Sky light.\n\t));\n\n\tl.x *= fakeEnv(ld * 4.); // Light mask.\n\tl.xy = .1 + .9 * l.xy; // Diffuse.\n\tl.yz *= _ao; // Ambient occlusion.\n\tl *= vec3(1, .6, .2); // Light contributions (key, reverse, sky).\n\n\t// Apply tinted shadows.\n\tl.x *= .1 + .9 * sha;\n\tvec3 skyTop = pow(vec3(max(.5, 0.)), vec3(6, 3, 1.5)) * vec3(.95, 1, 1) * (1. - pow(vec3(2), -vec3(35, 14, 7)));\n\tc += skyTop * (1. - sha) * .2;\n\n\t// Specular (Blinn-Phong)\n\tshine *= sha; // No specular in the shadows.\n\tl.x += pow(sat(dot(normalize(ld - rd), n)), spe) * shine;\n\n\t// Light falloff.\n\tl.x *= dot(lp, lp) / (1. + dot(lp - p, lp - p));\n\n\t// Combine the lights (key, reverse, sky).\n\tcol = mix((sum2(l.xy) * LIGHT_RGB + l.z * skyTop) * c, skyTop, S(.6, 1., 1. + dot(rd, n)) * .02);\n\n\t// Simple fog layer.\n\tfogY = -1.; // Fog surface Y.\n\tuv = vec3(p.xz, fogY) * .4 + t * vec3(32, 0, .2); // Fog uv.\n\tfloat fogTex = fbm(uv, .5); // Depth (distance) from fogY to max fog.\n\tfogY -= (1. - fogTex) * .3; // Surface deviation.\n\tfg = S(0., -.3, p.y - fogY);\n\n\tfg *= .1 + .3 * fogTex; // Fog texture.\n\tfg *= 1. - sat(-rd.y); // Shallow angle = More fog.\n\n\t// Distance Fog.\n\tfg += (1. - exp(dot3(p - ro) / -fogAdjust * 1e-4));\n\n\treturn mix(pow(vec3(max(1., 0.)), vec3(6, 3, 1.5)) * vec3(.95, 1, 1) * (1. - pow(vec3(2), -vec3(35, 14, 7))), col, 1. - sat(fg));\n}\n\nvec3 xwingPos() {\n\tvec3 p = vec3(0, .8 + .2 * sin(t * .5), sin(t) + sin(t * .3));\n\tfloat f = S(14., 10., t) + S(18., 20., t) * 1.1;\n\tp.zy *= f;\n\troll = (cos(t) + .3 * cos(t * .3)) * .1;\n\txw = S(12., 14., t);\n\tp.xz *= .1 + .9 * S(3., 6., t);\n\treturn p;\n}\n\nfloat addFade() { return min(1., abs(t)); }\n\nvec4 march(vec3 ro, vec3 rd) {\n\tg = vec2(0);\n\tfade = addFade();\n\txp = xwingPos();\n\tlp = vec3(0, .001, -20);\n\tlp.yz *= mat2(.41305, -.91071, .91071, .41305);\n\tlp.xz *= mat2(.4536, -.89121, .89121, .4536);\n\n\t// March the scene.\n\tvec3 n,\n\t     p = ro,\n\t     col = vec3(0);\n\tfloat i, dof,\n\t      d = 1.;\n\tHit h;\n\tfor (i = Z0; i < 1e2; i++) {\n\t\tif (d > 1e2) {\n\t\t\th.id = 0.;\n\t\t\tbreak;\n\t\t}\n\n\t\th = sdf(p);\n\t\tif (abs(h.d) < 2e-4 * d) break;\n\t\td += h.d;\n\t\tp += h.d * rd;\n\t}\n\n\tdof = sat(d / 1e2);\n\n\t// Brighten scene when facing the sun.\n\tcol += .2 * dof * LIGHT_RGB * S(.5, 1., pow(sat(dot(rd, normalize(lp))), 3.));\n\n\t// Engine glow.\n\tcol += g.x * vec3(1, .2, .25) * (.7 + .5 * n31(dx(p, 10.8 * t)));\n\tcol += g.y * LIGHT_RGB;\n\n\tn = N(p, d);\n\n\tcol += lights(p, ro, rd, n, h, 1.);\n\tif (fract(h.id) > 0.) {\n\t\t// We hit a reflective surface, so march reflections.\n\t\tfloat opac = 1.,\n\t\t      refl = fract(h.id);\n\t\trd = reflect(rd, n);\n\t\tp += n * .01;\n\t\tro = p;\n\t\td = .01;\n\t\tfor (i = Z0; i < 64.; i++) {\n\t\t\tif (d > 20.) {\n\t\t\t\th.id = 0.;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\th = sdf(p);\n\t\t\tif (abs(h.d) < 2e-4 * d) break;\n\t\t\td += h.d;\n\t\t\tp += h.d * rd;\n\t\t}\n\n\t\t// Add a hint of the reflected color.\n\t\topac *= refl;\n\t\tn = N(p, d);\n\t\tcol += opac * (1. - col) * lights(p, ro, rd, n, h, .2);\n\t}\n\n\treturn max(vec4(0), vec4(col, dof));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tt = mod(_t, 60.);\n\tvec2 uv = (fc - .5 * R.xy) / R.y;\n\tvec3 col,\n\t     lookAt = vec3(0, 1.6, 0),\n\t     ro = vec3(0, 1.001, 0);\n\tro.x += 4. * (S(10., 14., t) - S(20., 24., t) * 1.5);\n\tlookAt.y -= S(10., 14., t) - S(32., 35., t);\n\tro.z = mix(.12, .3, S(0., 7., t)) * -20.;\n\tro.yz *= rot(mix(.4, .14, S(4., 6., t)) * -1.57);\n\tro.xz *= rot((mix(.25, .54, S(5., 10., t)) * 2. - 1.) * -3.1415);\n\tro += vec3(1, .5, 2) * S(25., 30., t);\n\n\t// View bob.\n\tro += .5 * sin(t * vec3(.9, .7, .3));\n\tvec4 rgbz = march(ro, rayDir(ro, lookAt, uv));\n\tcol = rgbz.rgb;\n\t\n#ifdef AA\n\tif (fwidth(col.r) > .1) {\n\t\tfor (float dx = -.5; dx <= .5; dx++) {\n\t\t\tfor (float dy = -.5; dy <= .5; dy++)\n\t\t\t\tcol += march(ro, rayDir(ro, lookAt, uv + vec2(dx, dy) / R.xy)).rgb;\n\t\t}\n\n\t\tcol /= 5.;\n\t}\n#endif\n\n\tfragColor = vec4(col * fade, sat(rgbz.w));\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define BLUR 6.0\n\n#define _res iResolution\n#define _tex0 iChannel0\n\nfloat h31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 333.3456);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord / _res.xy;\n\n    // Apply basic depth of field blur.\n    vec4 col = texture(_tex0, uv);\n    float blur = smoothstep(0.5, 1.0, col.w) * BLUR;\n    \n    if (blur > 0.0) {\n        float samples = 40.0;\n        for (float i = 0.0; i < samples; i++) {\n            float a = 3.1415 * 2.0 / samples * i;\n            vec2 tuv = uv + vec2(blur * h31(vec3(uv, i)), 0) * mat2(cos(a), sin(a), -sin(a), cos(a)) / _res.xy;\n            col += texture(_tex0, tuv);\n        }\n        \n        col /= samples + 1.0;\n    }\n    \n    fragColor = col;    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}