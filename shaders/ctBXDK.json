{
    "Shader": {
        "info": {
            "date": "1676574132",
            "description": "Draw multiple discrete polygons in a single pass with controls for colors, blur, border size, and border blur.",
            "flags": 0,
            "hasliked": 0,
            "id": "ctBXDK",
            "likes": 2,
            "name": "Arbitrary Polygons, Blur/Border",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "blur",
                "draw",
                "polygon",
                "sdh"
            ],
            "usePreview": 0,
            "username": "adremeaux",
            "viewed": 506
        },
        "renderpass": [
            {
                "code": "// Multiple Arbitrary Polygons with Blur and Border\n// Adapted from https://www.shadertoy.com/view/WdSGRd\n//\n// This shader can draw single or multiple polygons in a single pass\n// Overlap is supported and works as expected, no weirdness\n// The shader supports Blur, Border Thickness, and Border Blur\n// \n// New polygons should be marked by an extra point with a value > CUTOFF\n// This is a totally arbitrary value but can be easily changed\n//\n// Note that is a bit of a visual hitch between BorderBlur 0 and >0\n// There is also some weirdness in the overlap edges when blur is enabled, I'm not\n//   sure how to fix\n// If desired, it shouldn't be too hard to have it use multiple colors for the different\n//   polys, although the arbitrary amount of polys coupled with a hardcoded set of colors\n//   would be pretty ugly\n\n#define N 9\n#define CUTOFF 10.\n\nfloat cross2d(vec2 v0, vec2 v1) {\n    return v0.x * v1.y - v0.y * v1.x;\n}\n\n// https://www.shadertoy.com/view/XsfGDH\nvec4 lerp(vec4 colorone, vec4 colortwo, float value)\n{\n\treturn (colorone + value * (colortwo - colorone));\n}\n\n// signed distance to a 2D polygon\n// adapted from triangle\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdPoly( in vec2[N] poly, in vec2 p, int cornerCount ) {\n    vec2[N] edgeDist;\n    vec2[N] pointDist;\n    vec2[N] pq;\n    \n    int lastMark = 0; //start position of each successive poly\n    \n    // data\n    for (int i=0; i < cornerCount; i++) {\n       int i2 = i + 1;\n       if (i2 == cornerCount) i2 = lastMark;\n       \n       if (poly[i].x >= CUTOFF) {\n           pq[i] = vec2(1000.);\n           lastMark = i + 1;\n           continue;\n       }\n       if (poly[i2].x >= CUTOFF) {\n           i2 = lastMark;\n       }\n       \n\t\tedgeDist[i] = poly[i2] - poly[i];\n        pointDist[i] = p - poly[i];\n        float dotE = dot(edgeDist[i], edgeDist[i]);\n        if (dotE == 0.) dotE = .0001;\n        pq[i] = pointDist[i] - edgeDist[i] * \n            clamp( dot(pointDist[i], edgeDist[i]) / dotE, 0.0, 1.0 );\n    }\n    \n    //distance\n    float d = dot(pq[0], pq[0]); \n\tfor (int i = 1; i < cornerCount; i++) {\n    \td = min(d, dot(pq[i], pq[i]));\n    }\n\t\n    //winding number\n    // from http://geomalgorithms.com/a03-_inclusion.html\n    int wn = 0;\n    lastMark = 0;\n    bool runningVal = true;\n    \n    for (int i = 0; i < cornerCount; i++) {\n        if (poly[i].x >= CUTOFF) {\n            runningVal = runningVal && (wn == 0);\n            lastMark = i + 1;\n            continue;\n        }\n\n        int i2 = i + 1;\n        if (poly[i2].x >= CUTOFF) {\n            i2 = lastMark;\n        }\n        if (i2 == cornerCount) i2 = lastMark;\n        \n        bool cond1 = 0. <= pointDist[i].y;\n        bool cond2 = 0. > pointDist[i2].y;\n        float val3 = cross2d(edgeDist[i], pointDist[i]); //isLeft\n        wn +=  cond1 &&  cond2 && val3 > 0. ? 1 : 0; // have  a valid up intersect\n        wn -= !cond1 && !cond2 && val3 < 0. ? 1 : 0; // have  a valid down intersect\n    }\n    \n    runningVal = runningVal && (wn == 0);\n    float s = runningVal ? 1. : -1.;\n    return sqrt(d) * s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float blurMax = 0.5;\n    float borderSizeMax = 20.0; \n    float borderBlurMax = 5.0; \n    \n    vec3 col2 = 0.5 + 0.5 * cos(iTime + vec3(0, 2, 4));\n    \n    vec4 innerColor = vec4(col2, 1.);//vec4(.75, .12, .67, 1.);\n    vec4 outerColor = vec4(.05, .01, .27, 0.); \n    vec4 borderColor = vec4(1.); \n    \n    float blur = clamp(cos(iTime) * blurMax, 0., blurMax);\n    float borderSize = clamp(cos(iTime * 1.5 + 0.3) * borderSizeMax, 0., borderSizeMax);\n    float borderBlur = clamp(cos(iTime * 1.2 + 0.6) * borderBlurMax, 0., borderBlurMax);\n\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tp *= 1.5;\n    \n    vec2 offset = vec2(.5, .5);\n\tvec2 v1 = cos( iTime + vec2(0.0,1.40) + 0.3 ) + offset;\n\tvec2 v2 = cos( iTime + vec2(0.0,1.10) + 1.5 ) + offset;\n\tvec2 v3 = cos( iTime + vec2(0.0,0.70) + 4.0 ) + offset;\n\tvec2 v4 = cos( iTime + vec2(0.0,0.50) - 2.0 ) + offset;\n    \n    vec2 v6 = vec2(CUTOFF * 2.);\n    \n    offset = -offset;\n    vec2 v7 = cos( iTime + vec2(0.0,1.50) - 0.0) + offset;\n\tvec2 v8 = cos( iTime + vec2(0.0,2.50) - 1.5 ) + offset;\n\tvec2 v9 = cos( iTime + vec2(0.0,2.20) - 4.0 ) + offset;\n\tvec2 v10 = cos( iTime + vec2(0.0,1.80) + 2.0 ) + offset;\n    \n    vec2[N] poly= vec2[N](\n    v1,\n    v2,\n    v3,\n    v4,\n    v6,\n    v7,\n    v8,\n    v9,\n    v10);\n    \n    float dist = -sdPoly(poly, p, N);\n    float rawDist = abs(dist);\n    float pos = sign(dist);\n    if (blur == 0.) blur = 0.001;\n    dist /= blur;\n    dist = clamp(dist, -1., 1.);\n\n    float ic = dist * .5 + .5;\n    float oc = -dist * .5 + .5;\n\n    vec4 col = lerp(outerColor, innerColor, ic);\n    if (pos < 1.) col = lerp(innerColor, outerColor, oc);\n\n    float bs = borderSize / iResolution.x;\n    float bBlur = bs * (borderBlur + 1.);\n    if (rawDist < bBlur) {\n        float lowBound = 0.;\n        float highBound = bBlur;\n        float blurDist = borderBlur <= 0. ? 0. : (rawDist - lowBound) / (highBound - lowBound);\n        blurDist = clamp(blurDist, 0., 1.);\n        col = lerp(borderColor, col, blurDist);\n    }\n    fragColor = col;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}