{
    "Shader": {
        "info": {
            "date": "1535226661",
            "description": "Raytracing the floor plane instead of marching it - fewer iterations to reach the SDF surface, even for the other objects in the scene.",
            "flags": 0,
            "hasliked": 0,
            "id": "4tGczD",
            "likes": 5,
            "name": "Fast Plane Tracing",
            "published": 3,
            "tags": [
                "tracing"
            ],
            "usePreview": 0,
            "username": "yx",
            "viewed": 712
        },
        "renderpass": [
            {
                "code": "#define STEPS 32\n#define MAX_DIST 100.\n\nvec2 rotate(vec2 p,float a){return cos(a)*p+sin(a)*vec2(-p.y,p.x);}\n\nvec3 spin(vec3 p)\n{\n   \tp.xy = rotate(p.xy, iTime);\n   \tp.xz = rotate(p.xz, iTime);\n\treturn p;\n}\n\nfloat sdFloor(vec3 p, float y)\n{\n    return p.y-y;\n}\n\nfloat sdFloorFast(vec3 p, vec3 d, float y)\n{\n    float t = (y-p.y)/d.y;\n    return t >= 0. ? t * .999 : MAX_DIST;\n    \n    // the .999 is a shitty hack so that we don't overshoot through the floor (yay floating point)\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat scene(vec3 p)\n{\n    return min(\n        sdBox(spin(p),vec3(1.)),\n        sdFloor(p,-1.)\n    );\n}\n\nfloat sceneFast(vec3 p, vec3 d)\n{\n    return min(\n        sdBox(spin(p),vec3(1.)),\n        sdFloorFast(p,d,-1.)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 cam = vec3(0,0,-5);\n    vec3 dir = normalize(vec3(uv,1));\n    \n    int i;\n    vec3 p = cam;\n    for(i=0;i<STEPS;++i)\n    {\n    \tfloat k;\n        if (fragCoord.x < (iMouse.z > 0. ? iMouse.x : iResolution.x * .5))\n        \tk = scene(p);\n        else\n            k = sceneFast(p,dir);\n        if (k < .001 || k > MAX_DIST)\n            break;\n    \tp += dir * k;\n    }\n    \n    const vec2 o = vec2(.001,0);\n    vec3 n = normalize(vec3(\n\t\tscene(p+o.xyy)-scene(p-o.xyy),\n\t\tscene(p+o.yxy)-scene(p-o.yxy),\n\t\tscene(p+o.yyx)-scene(p-o.yyx)\n    ));\n    \n    // alternative normal calculation\n   \t//n = normalize(cross(dFdy(p),dFdx(p)));\n    \n    // brighter means fewer iterations\n    \n    float cost = float(i)/float(STEPS);\n\tfragColor = vec4(1.-cost);\n    //fragColor = vec4(fract(p*4.+.5),1);\n\t//fragColor *= vec4(n*.5+.5,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}