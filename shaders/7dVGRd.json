{
    "Shader": {
        "info": {
            "date": "1632000997",
            "description": "First time raymarching so I think it's going well!\n\n( this is me just trying to break things)",
            "flags": 0,
            "hasliked": 0,
            "id": "7dVGRd",
            "likes": 4,
            "name": "Ethereal capsule",
            "published": 3,
            "tags": [
                "cool"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 222
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 10\n#define MAX_DIST 100.\n#define SURF_DIST 1.\n\nfloat myLength(vec3 p) {\n    float theta = atan(p.y, p.x);\n    float beta = atan(p.y, p.z);\n    float x = 0.5 * (1. + cos(beta + 0.3 * iTime));\n    float z = 0.5 * (1. + sin(theta + 0.3 * iTime));\n    x = 16. * x * x * (1.-x) * (1.-x);\n    z = 16. * z * z * (1.-z) * (1.-z);\n    return sqrt(pow(p.x + x, 2.) + p.y * p.y + pow(p.z + z, 2.));\n\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n\n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    //t = 0.8 * t + 0.2 * 4. * t * (1.-t);\n    vec3 c = a + t * ab;\n    float d = myLength(p - c) - r;\n    return d;\n}\n\nfloat GetDist(vec3 p) {\n    vec4 s = vec4(0, 1.3 + 0.2 * cos(iTime), 6, 1);\n    float sphereDist = length(p - s.xyz) - s.w;\n    float planeDist = p.y;\n    \n    float b = 0.5 * (1. + cos(0.5 * iTime));\n    \n    float cd = sdCapsule(p, vec3(-cos(-iTime),1.5,6. + sin(-iTime)), vec3(cos(-iTime),1,6.-sin(-iTime)), .8);\n   // float cd2 = sdCapsule(p, vec3(-sin(-iTime),1,6. + cos(-iTime)), vec3(sin(-iTime),1.5,6.-cos(-iTime)), .8);\n   \n   \n    float d = min(cd, planeDist);\n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + 1.4 * dO * rd;\n        float dS = GetDist(p);\n        dO += dS;\n        if (dO>MAX_DIST || dO<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.01,0);\n    \n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n        \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 7. + 3. * cos(0.45 * iTime), 3);\n    vec3 lightPos2 = lightPos;\n    vec2 v = 6. * vec2(cos(0.4 * iTime), sin(0.4 * iTime));\n    lightPos.xz += v;\n    lightPos2.xz -= v;\n    vec3 l = normalize(lightPos - p);\n    vec3 l2 = normalize(lightPos2 - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l), 0., 1.);\n    float dif2 = clamp(dot(n,l2),0.,1.);\n    //dif = 16. * dif * dif * (1.-dif) * (1.-dif);\n    dif *= dif;\n    dif2 *= dif2;\n    float d = RayMarch(p + n * SURF_DIST * 2., l);\n   // if (d<length(lightPos-p))\n     //   dif *= .1;\n\n    return dif + dif2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) /iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,1.,0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro,rd);\n    \n    vec3 p = ro - 2. * rd * d;\n    \n    float dif = GetLight(p); \n    dif = 16. * dif * dif *(1.-dif) * (1.-dif);\n    col = vec3(dif);\n\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}