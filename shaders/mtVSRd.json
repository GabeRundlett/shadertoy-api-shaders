{
    "Shader": {
        "info": {
            "date": "1686570172",
            "description": "Lens flare post-processing effect featuring ghosts, halo, glare, and bloom\n\nMouse drag to look around\nDefines in Common",
            "flags": 32,
            "hasliked": 0,
            "id": "mtVSRd",
            "likes": 50,
            "name": "Lens Flare Post-Processing",
            "published": 3,
            "tags": [
                "lens",
                "post",
                "effect",
                "bloom",
                "chromatic",
                "aberration",
                "flare",
                "halo",
                "processing",
                "glare",
                "ghosts"
            ],
            "usePreview": 0,
            "username": "gelami",
            "viewed": 1159
        },
        "renderpass": [
            {
                "code": "\n// Lens Flare Post-Processing - gelami\n// https://www.shadertoy.com/view/mtVSRd\n\n/* \n * Lens flare post-processing effect featuring ghosts, halo, glare, and bloom\n * \n * Mouse drag to look around\n * Defines in Common\n * \n * Resources:\n * \n * Custom Lens-Flare Post-Process in Unreal Engine - Froyok\n * https://www.froyok.fr/blog/2021-09-ue4-custom-lens-flare/\n * \n * Pseudo Lens Flare - John Chapman\n * http://john-chapman-graphics.blogspot.com/2013/02/pseudo-lens-flare.html\n * \n * Bloom pass based from:\n * 2-Pass Buffer Bloom - gelami\n * https://www.shadertoy.com/view/cty3R3\n * \n */\n\n\n// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2023-06-09 09:23:00\n\nvec2 fisheye(vec2 uv)\n{\n    uv = uv * 2.0 - 1.0;\n    \n    const float f = 0.5;\n    const float scale = f * atan(1.0 / f);\n    float rd = length(uv) * scale;\n    float ru = f*tan(rd / f);\n    float phi = atan(uv.y, uv.x);\n    uv = (vec2(cos(phi), sin(phi)) * ru + 1.0) * 0.5;\n\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pv = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 px = 1.0 / iResolution.xy;\n    vec2 aspect = vec2(iResolution.x / iResolution.y, 1);\n    \n    vec3 ro = getCameraPos(iMouse, iResolution.xy, iTime);\n    vec3 lo = getLookAtPos();\n    \n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    vec2 iuv = 1.0 - uv;\n    \n    const float k = length(vec2(0.5));\n    \n    float l = length(0.5 - iuv) / k;\n    \n    // Dirt texture\n    float dirt = 1.0 - textureLod(iChannel3, (pv + 1.0) * 0.5, 1.0).r;\n    dirt = dirt*dirt * 0.4 + 0.6;\n    \n    float crot = cmat[0].z + cmat[1].y + cmat[2].x;\n    \n    vec2 suv = rot2D(crot) * pv;\n    \n    // Starburst texture\n    float star = atan(suv.y, suv.x) / TAU + 0.5;\n    star = textureLod(iChannel3, vec2(star * 2.5, 0), 0.0).b;\n    star = smoothstep(0.1, 0.65, star);\n    star = mix(star, 0.1, smoothstep(1.0, 0.35, l));\n    \n    dirt *= star;\n    \n    #ifdef GHOSTS\n    float gstr = GHOSTS_OFFSET;\n    vec2 guv = (0.5 - iuv) * gstr;\n    \n    const float ca = CHROMATIC_ABERRATION_STRENGTH;\n    vec3 caStr = vec3(-px.y, 0, px.y) * ca;\n    vec2 dir = normalize(guv);\n    \n    vec3 res = vec3(0);\n    for (int i = 0; i < GHOSTS_COUNT; i++)\n    {\n        vec2 p = iuv + guv * float(i);\n        \n        float d = length(0.5 - p) / k;\n        float w = pow(max(1.0 - d, 0.0), 8.0);\n    \n        float f = texture(iChannel3, vec2(0.12 * d, 0)).b * 5.0;\n        \n        vec3 c = palette2(f) * 3.0;\n        \n        #ifdef CHROMATIC_ABERRATION\n        res += sampleDistorted(iChannel0, p, dir, caStr) * w * c;\n        #else\n        res += sampleBuffer(iChannel0, p) * w * c;\n        #endif\n    }\n    \n    col += res * dirt * GHOSTS_STRENGTH;\n    \n    #endif\n    \n    #ifdef HALO\n    const float hstr = HALO_RADIUS;\n    vec2 huv = normalize(pv) * hstr;\n    \n    vec2 fuv = fisheye(iuv);\n    float hw = length(0.5 - fract(huv / aspect + iuv)) / k;\n    hw = pow(max(1.0 - hw, 0.0), 8.0) * smoothstep(0.1, 0.0, length(pv) - hstr * 2.0) * HALO_STRENGTH;\n    \n    #ifdef CHROMATIC_ABERRATION\n    col += sampleDistorted(iChannel0, huv / aspect + iuv, dir, caStr) * hw * dirt;\n    #else\n    col += sampleBuffer(iChannel0, huv / aspect + iuv) * hw * dirt;\n    #endif\n    \n    #endif\n    \n    #ifdef BLOOM\n    vec3 bloom = vec3(0);\n    \n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 0).rgb;\n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 1).rgb;\n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 2).rgb;\n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 3).rgb;\n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 4).rgb;\n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 5).rgb;\n    \n    bloom /= 6.0;\n    \n    col += bloom * BLOOM_STRENGTH;\n    #endif\n    \n    #ifdef GLARE\n    col += texture(iChannel2, uv * 0.5).rgb * GLARE_STRENGTH;\n    #endif\n    \n    col *= EXPOSURE;\n    col = max(col, vec3(0));\n    \n    #ifdef SHOW_FALSE_COLOR\n    col = palette(saturate(luminance(col)));\n    \n    if (fragCoord.y < 10.0)\n        col = palette(uv.x);\n    #endif\n    \n    col = ReinhardJodie(col);\n    //col = ReinhardExtLuma(col, 2.5);\n    //col = ACESFilm(col * 0.35);\n    \n    fragColor = vec4(linearTosRGB(col), 1);\n    fragColor += (dot(hash23(vec3(fragCoord, iTime)), vec2(1)) - 0.5) / 255.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// Defines\n\n#define EXPOSURE 0.7\n\n#define ENV_MAP_WHITE_POINT 100.0\n\n#define CHROMATIC_ABERRATION\n#define CHROMATIC_ABERRATION_STRENGTH 1.5\n\n#define GHOSTS\n#define GHOSTS_COUNT 4\n#define GHOSTS_OFFSET 0.2\n#define GHOSTS_STRENGTH 0.6\n\n#define HALO\n#define HALO_RADIUS 0.6\n#define HALO_STRENGTH 0.4\n\n#define GLARE\n#define GLARE_COUNT 20\n#define GLARE_STEP_SIZE 4.0\n#define GLARE_STRENGTH 0.6\n\n#define BLOOM\n#define BLOOM_MAX_LOD 6\n#define BLOOM_THRESHOLD 2.0\n#define BLOOM_STRENGTH 0.4\n\n//#define SHOW_FALSE_COLOR\n\n#define STEPS 512\n#define MAX_DIST 100.\n#define EPS 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec3 getLookAtPos()\n{\n    return vec3(0, 0, 0);\n}\n\nvec3 getCameraPos(vec4 mouse, vec2 res, float time)\n{\n    vec2 m = mouse.xy / res.xy;\n    \n    vec3 ro = vec3(0, 0, 1);\n    \n    float ax = mouse.z < 0. || mouse.x == 0. ? -0.5 + time * PI / 10.0 : -m.x * TAU + PI;\n    float ay = mouse.z < 0. || mouse.y == 0. ? -PI * 0.1 : -m.y * PI + PI * 0.5;\n    \n    ro.yz *= rot2D(ay);\n    ro.xz *= rot2D(ax);\n    ro += getLookAtPos();\n    \n    return ro;\n}\n\n#define TEX_BIAS 1.0\n#define TEX_SCALE 0.4\n\nvec3 sampleBuffer(sampler2D tex, vec2 uv)\n{\n    return max(textureLod(tex, uv, 2.5).rgb - TEX_BIAS, vec3(0)) * TEX_SCALE;\n}\n\nvec3 sampleBufferLod(sampler2D tex, vec2 uv, float lod)\n{\n    return max(textureLod(tex, uv, lod).rgb - TEX_BIAS, vec3(0)) * TEX_SCALE;\n}\n\nvec3 sampleDistorted(sampler2D tex, vec2 uv, vec2 dir, vec3 str)\n{\n    return vec3(\n        sampleBuffer(tex, uv + dir * str.r).r,\n        sampleBuffer(tex, uv + dir * str.g).g,\n        sampleBuffer(tex, uv + dir * str.b).b\n    );\n}\n\nvec4 SampleLod(sampler2D tex, vec2 uv, vec2 res, const int lod)\n{\n    vec2 hres = floor(res / 2.0);\n    \n    vec2 nres = hres;\n    float xpos = 0.0;\n    int i = 0;\n    for (; i < lod; i++)\n    {\n        xpos += nres.x;\n        \n        nres = floor(nres / 2.0);\n    }\n    \n    vec2 nuv = uv * vec2(nres);\n    \n    nuv = clamp(nuv, vec2(0.5), vec2(nres)-0.5);\n    nuv += vec2(xpos, 0);\n    \n    return texture(tex, nuv / res);\n}\n\n\nvec3 uvToDir(vec2 uv)\n{\n    uv -= 0.5;\n    float phi = uv.x * TAU;\n    float theta = uv.y * PI;\n    return vec3(cos(phi) * cos(theta), sin(theta), sin(phi) * cos(theta));\n}\n\nvec2 dirToUv(vec3 dir)\n{\n    float theta = atan(dir.z, dir.x);\n    float phi = atan(dir.y, length(dir.xz));\n    \n    return vec2(theta / TAU, phi / PI) + 0.5;\n}\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat safeacos(float x) { return acos(clamp(x, -1.0, 1.0)); }\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(1)); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nfloat sqr(float x) { return x*x; }\nvec2 sqr(vec2 x) { return x*x; }\nvec3 sqr(vec3 x) { return x*x; }\n\nfloat luminance(vec3 col) { return dot(col, vec3(0.2126729, 0.7151522, 0.0721750)); }\n\n// https://iquilezles.org/articles/smin/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0, .33, .67)));\n}\n\nvec3 palette2(float t)\n{\n    return .5 + .5 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0, .25, .5)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvec3 ReinhardExtLuma(vec3 col, const float w)\n{\n    float l = luminance(col);\n    float n = l * (1.0 + l / (w * w));\n    float ln = n / (1.0 + l);\n    return col * ln / l;\n}\n\n// From Jodie\n// https://www.shadertoy.com/view/4dBcD1\nvec3 ReinhardJodie(vec3 v)\n{\n    float l = luminance(v);\n    vec3 tv = v / (1.0f + v);\n    return mix(v / (1.0f + l), tv, tv);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n// Skybox pass\n\n// Formula found from\n// Inverse Aces Tonemap Operator - Chrisy\n// https://www.shadertoy.com/view/wlfyWr\nvec3 inverseReinhard(vec3 color, float exposure)\n{\n    return color / (exposure * max((1.0 - color) / exposure, 1e-3));\n}\n\nvec3 getSky(vec3 rd)\n{\n    vec3 sky = sRGBToLinear(texture(iChannel0, rd).rgb);\n    \n    sky = inverseReinhard(sky, ENV_MAP_WHITE_POINT);\n    sky /= vec3(1, 0.5, 0.4);\n    \n    vec3 dir = normalize(vec3(1, 0.5, -1));\n    \n    //sky += vec3(1) * smoothstep(0.995, 1.0, dot(rd, dir)) * 20.0;\n    \n    return sky;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pv = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 ro = getCameraPos(iMouse, iResolution.xy, iTime);\n    vec3 lo = getLookAtPos();\n\n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    const float invTanFov = 1.25;\n    \n    vec3 rd = normalize(cmat * vec3(pv, invTanFov));\n\n    vec3 col = getSky(rd);\n    \n    fragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// Bloom pass based from:\n// 2-Pass Buffer Bloom - gelami\n// https://www.shadertoy.com/view/cty3R3\n\nconst int rad = 5;\nconst float sigma = float(rad) * 0.4;\n\n#if 1\nvec4 prefilter(vec4 col)\n{\n    const float threshold = BLOOM_THRESHOLD;\n    float brightness = max(max(col.r, col.g), col.b);\n    float contrib = max(brightness - threshold, 0.0) / max(brightness, 1e-5);\n    return col * contrib;\n}\n#else\nvec4 prefilter(vec4 col)\n{\n    return col;\n}\n#endif\n\nfloat gaussian(vec2 i, float sigma) {\n    return exp(-(dot(i,i) / (2.0 * sigma*sigma)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 hres = floor(iResolution.xy / 2.0);\n        \n    vec2 res = hres;\n    float xpos = 0.0;\n    int lod = 0;\n    for (; lod < BLOOM_MAX_LOD; lod++)\n    {\n        xpos += res.x;\n        \n        if (xpos > fragCoord.x || res.x <= 1.0)\n            break;\n        res = floor(res / 2.0);\n    }\n    \n    if (fragCoord.y >= res.y)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    fragColor = vec4(0);\n    \n    vec2 px = 1.0 / iResolution.xy;\n    vec2 p = (fragCoord - vec2(xpos - res.x, 0)) / iResolution.xy;\n    vec2 uv = (fragCoord - vec2(xpos - res.x, 0)) / vec2(res);\n    \n    // Skip blurring LOD 0 for performance\n    #if 1\n    if (lod == 0)\n    {\n        fragColor = prefilter(textureLod(iChannel0, uv, 1.0));\n        return;\n    }\n    #endif\n    \n    float sc = exp2(float(lod));\n    float w = 0.0;\n    for (int x = -rad; x <= rad; x++)\n    {\n        for (int y = -rad; y <= rad; y++)\n        {\n            vec2 o = vec2(x, y);\n            float wg = gaussian(o, sigma);\n            vec2 p = uv + o / vec2(res);\n            \n            //p = clamp(p, 0.5 / res, (res - 0.5) / res);\n            \n            if (p == clamp(p, vec2(0.5) / res, (res - 0.5) / res))\n                fragColor += wg * prefilter(textureLod(iChannel0, p, float(lod)));\n            w += wg;\n        }\n    }\n    fragColor /= w;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// Glare pass\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fc = fragCoord * 2.0;\n    \n    if (fc.x >= iResolution.x || fc.y >= iResolution.y)\n        discard;\n\n    vec2 uv = fragCoord / iResolution.xy * 2.0;\n    \n    #ifdef GLARE\n    \n    vec2 gdir = normalize(vec2(sqrt(0.5))) / iResolution.xy;\n    vec2 gdir2 = normalize(vec2(-1, 1)) / iResolution.xy;\n    \n    vec3 glare = vec3(0);\n    float glarew = 0.0;\n    \n    for (int i = -GLARE_COUNT; i <= GLARE_COUNT; i++)\n    {\n        float d = float(i) * GLARE_STEP_SIZE;\n        vec2 p = uv + gdir * d;\n        vec2 p2 = uv + gdir2 * d;\n        \n        float k = float(i) / float(GLARE_COUNT);\n        \n        vec3 c = palette2(k * 3.0) * 0.8 + 0.2;\n        \n        const float sigma = float(GLARE_COUNT) * GLARE_STEP_SIZE * 0.45;\n        float w = exp(-d*d / (2.0 * sigma*sigma));\n        //glare += textureLod(iChannel0, p, 1.0).rgb;\n        //glare += textureLod(iChannel0, p2, 1.0).rgb;\n        \n        glare += sampleBufferLod(iChannel0, p, 1.0) * w * c;\n        glare += sampleBufferLod(iChannel0, p2, 1.0) * w * c;\n        glarew += w;\n    }\n    \n    vec3 col = glare / (2.0 * glarew);\n    \n    fragColor = vec4(col, 1);\n    \n    #else\n    \n    fragColor = vec4(0,0,0,1);\n    \n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}