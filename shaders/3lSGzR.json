{
    "Shader": {
        "info": {
            "date": "1558173800",
            "description": "A simple raymarcher that renders a starfield\nThe stars are rendered as a voxel grid, while the gas clouds are \nsimply raymarched.                \n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "3lSGzR",
            "likes": 10,
            "name": "Star trip",
            "published": 3,
            "tags": [
                "raymarching",
                "space",
                "galaxy",
                "starfield"
            ],
            "usePreview": 0,
            "username": "skythedragon",
            "viewed": 1321
        },
        "renderpass": [
            {
                "code": "\n// Update 1: Improved stepping\n// Update 2: Added gas clouds (WIP)\n// Update 3: Added first version of clusters (WIP)\n// Update 4: Added funky mode\n// Update 5: Changed the star rendering system (resets when the voxel size is increased)\n// Update 6: Added extra noise to the gas clouds to make them look better (and have more dark spaces)\n\n\n// TODO: \n//\t\t Add clusters\n//\t\t Add some sort of galaxies (like big clusters)\n//\t\t Cone trace the stars so that they will always take up at least one pixel\n\n// uncomment and add music to iChannel0 for some fun color changes\n// #define FUNKY_MODE\n\n// constants\n// =============================================================================================================================\n\nconst int STEPS = 32; // steps for the gas cloud marcher\nconst int MAJOR_STEPS = 8; // how many times the box size is doubled\nconst int MINOR_STEPS = 8; // how many steps before the box size is doubled\nconst int BOX_INCREMENT = 4; // how much bigger the box gets each major step\nconst float FOV = 45.0;\nconst float STEP_SIZE = 0.8; // step size for the gas clouds\nconst float STEP_MULTIPLIER = 1.05; // how much bigger the step gets every iteration\nconst float STAR_SIZE = 0.04;\nconst float SPEED = 8.0;\n\n// noise and random\n// =============================================================================================================================\n\n// random float\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// these hash functions are by dave hoskins\n\n// random vector\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// noise\n// =============================================================================================================================\n\n// by iq, https://www.shadertoy.com/view/4sfGzS\n\nfloat fnoise(vec3 x) {\n\n\tvec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash13(p+vec3(0,0,0)), \n                        hash13(p+vec3(1,0,0)),f.x),\n                   mix( hash13(p+vec3(0,1,0)), \n                        hash13(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash13(p+vec3(0,0,1)), \n                        hash13(p+vec3(1,0,1)),f.x),\n                   mix( hash13(p+vec3(0,1,1)), \n                        hash13(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 vnoise(vec3 x) {\n\n\tvec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash33(p+vec3(0,0,0)), \n                        hash33(p+vec3(1,0,0)),f.x),\n                   mix( hash33(p+vec3(0,1,0)), \n                        hash33(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash33(p+vec3(0,0,1)), \n                        hash33(p+vec3(1,0,1)),f.x),\n                   mix( hash33(p+vec3(0,1,1)), \n                        hash33(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// star functions\n// =============================================================================================================================\n\n// wether there is a star\nbool has_star(ivec3 voxel, float chance) {\n    float n = fnoise(vec3(voxel)/32.0); \n\treturn hash13(abs(vec3(voxel))) < chance*n*n*n;\n}\n\n// xyz is pos, w is size\nvec4 get_star(ivec3 voxel) {\n    vec3 o = vec3(1.0 - STAR_SIZE);\n    return (abs(hash43(vec3(voxel))+vec4(o/2.0, 0.0))*vec4(o, STAR_SIZE)) + vec4(voxel, 0); \n}\n\n// wether the star can be seen by the ray\nbool is_star_visible(vec3 eye, vec3 dir, vec4 star, float cone) {\n\tfloat r = (dot(dir, star.xyz) - dot(dir, eye)) / dot(dir, dir);\n    vec3 p = eye + r*dir;\n    // if p is behind the camera, return the distance to the camera\n    if (dot(normalize(p - eye), dir) < 0.0) {\n        p = eye;\n    }\n    return distance(p, star.xyz) - star.w < cone*length(p);\n\t\n    // get the angle between the star view\n    //float cosine_angle = dot(dir, normalize(eye - star.xyz));\n    // get the angle the star is visible at\n    //return cosine_angle < 0.1;\n    \n    // get the angle between the star and the dir\n    //return dot(normalize(star.xyz - eye), dir) + sin(distance(star.xyz, eye) / star.w) <= cone ;\n}\n\n// raymarching\n// =============================================================================================================================\n\n// ray direction\nvec3 ray_dir(vec2 size, vec2 pos) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( radians( 90.0 - FOV * 0.5 ) );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// cone\n\n// the color of the current position\nvec3 get_color(vec3 eye, vec3 dir, vec3 pos, float step_size) {\n\t// gas cloud color\n    float n = fnoise(pos/10.0);\n    #ifndef FUNKY_MODE\n   \treturn (fnoise(pos/10.0) * vnoise(pos/50.0) ) * step_size * n * fract(n); // * (1.0/step_size);\n    #else\n    return (fnoise(pos/10.0) * vnoise(pos/50.0) ) * step_size * n * texture(iChannel0, vec2(0.2)).r * 2.0;\n    #endif\n}\n\n// wether a star was hit\nbool was_star_hit(vec3 eye, vec3 dir, vec3 pos, float cone) {\n\t// get the star\n    if (has_star(ivec3(pos), 0.3)) {\n    \t// get the star distance\n        vec4 star = get_star(ivec3(pos));\n        // if the distance is 0 or smaller, the star was hit, so return white\n        return (is_star_visible(eye, dir, star, cone));\n    }\n}\n\n// the point on the box boundary to move to\nvec3 get_next_point(float dist, vec3 current, vec3 dir) {\n    // return the new point\n    return current + dir*dist;\n}\n\n// get the distance to the next point\nfloat get_dist_to_next(float box_size, vec3 current, vec3 dir) {\n    // get the local point in  the box\n\tvec3 local = fract(current / box_size);\n    // get the box position\n    vec3 box = floor(current / box_size);\n    // trace to box boundary\n    vec3 m = 1.0 / dir;\n    vec3 n = m*(local-vec3(0.5));\n    vec3 k = abs(m);\n    vec3 t = k - n;\n    float dist = min(min(t.x, t.y), t.z) + 0.0001;\n    // transform to global space again\n    return dist*box_size;\n}\n\n// march through the space\nvec3 march(vec3 eye, vec3 dir, float cone) {\n    /*\n    float s = STEP_SIZE;\n    vec3 col = vec3(0.0);\n    vec3 pos = eye;\n\t// main loop\n    for (int i = 0; i < STEPS; ++i) {\n        // get the color\n        col += get_color(eye, dir, pos, s);\n        // if the color is white, break (optimization)\n        if (col.x >= 1.0 && col.y >= 1.0 && col.z >= 1.0) {\n        \tbreak;\n        }\n        pos += dir*s;\n        s *= STEP_MULTIPLIER;\n    }\n    return col;\n\t*/\n    // raymarching for the stars\n    // the big box step\n    for (int i = 0, box_size = 1; i < MAJOR_STEPS; ++i, box_size *= BOX_INCREMENT) {\n        // start\n        vec3 pos = eye;\n        // minor step\n        for (int j = 0; j < MINOR_STEPS; ++j) {\n    \n            // distance to the next point\n            float dist = get_dist_to_next(float(box_size), pos, dir);\n        \t// get the color\n            //col += get_color(eye, dir, pos, dist, cone);\n            // if the star was hit, break and return\n            if (was_star_hit(eye, dir, pos, cone)) {\n            \treturn vec3(1.0);\n            }\n            // get the next point\n            pos = get_next_point(dist, pos, dir);\n        }\n    }\n    // raymarching for the cloud\n    vec3 col = vec3(0.0);\n    vec3 pos = eye+dir*STEP_SIZE;\n    float s = STEP_SIZE;\n    float tot = 0.0;\n    // loop\n    for (int i = 0; i < STEPS; ++i) {\n        // get the color\n        col += get_color(eye, dir, pos, s);\n        // increment step size\n        s *= STEP_MULTIPLIER;\n        // increase step\n        pos += dir*s;\n        // increase total\n        tot += s;\n    }\n    return col / tot;\n}\n\n// image\n// =============================================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // default ray dir\n\tvec3 dir = ray_dir(iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3(100.0, 100.0, -iTime*SPEED);\n    \n    // get the color\n    vec3 col = march(eye, dir, 0.0);\n\n    // Output to screen\n    fragColor = vec4(col, 0.1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}