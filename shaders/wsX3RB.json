{
    "Shader": {
        "info": {
            "date": "1550038550",
            "description": "During the last few months of 2018 I've somehow ended up putting together a small collection of Shadertoy mods. I figured I should probably share them - this silly shader is my way of making an announcement :)\n\nSee the code for links/details.",
            "flags": 32,
            "hasliked": 0,
            "id": "wsX3RB",
            "likes": 71,
            "name": "Inessentials 2019",
            "published": 3,
            "tags": [
                "script",
                "extension",
                "tampermonkey"
            ],
            "usePreview": 1,
            "username": "adx",
            "viewed": 1855
        },
        "renderpass": [
            {
                "code": "/*\n\tShadertoy Inessentials 2019 Home Edition\n\tA small, cheekily named collection of Shadertoy mods\n\t================================================================\n\n\tUPDATE (2019-02-14): Half of the initial scripts are now redundant,\n\tsince their functionality is now built-in! The other two scripts,\n\tplus a new one adding comment preview support, are now here:\n\t\n\thttps://github.com/andrei-drexler/shadertoy-userscripts/\n\n\tFor other ways to extend Shadertoy, check out @FabriceNeyret2's blog\n\thttps://shadertoyunofficial.wordpress.com/2017/07/25/extending-shadertoy/\n\n\tFor a frame exporter add-on, check out @tdhooper's repository\n\thttps://github.com/tdhooper/shadertoy-frame-exporter\n\n\t--- original text below ---\n\n\n\tFirst things first, these tweaks come in the form of so-called \"userscripts\".\n\tThey're like mini browser extensions, except you can't use them on their own,\n\tyou need a \"userscript manager\" extension to run them.\n\tPersonally, I use Tampermonkey (on Chrome/Firefox), but Greasemonkey + Firefox,\n\tfor example, should also work.\n\n    Tampermonkey website:\n    https://tampermonkey.net/\n\n    Tampermonkey on the Chrome web store (10M+ downloads):\n    https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo\n\n\tOnce you have Tampermonkey, the easiest way to install these scripts\n\tfrom Github is to go to the \"Raw\" view - Tampermonkey should detect\n\tthe .user.js suffix and bring up a confirmation screen.\n\n\tI've also looked into packaging the scripts into a standalone extension,\n\tso if you prefer that solution, let me know.\n\n\tOn to the actual mods:\n\n\n\t1. Compilation timing (OBSOLETE):\n\t------------------------\n\n\tWhen working on large shaders compile times can become a major issue.\n    Being able to time compilation more precisely than counting Mississippi's\n\tallows you to compare different approaches and make informed decisions\n\tregarding potential optimizations.\n\n\tDemo (14 sec):\n\thttps://youtu.be/N2Ai8Fdi7ec\n\t\n\tScript:\n\thttps://gist.github.com/andrei-drexler/98754c911e6d9be05086a03e94547430\n\n\tTODO (maybe):\n\t- replace timing info with next/prev error controls if compilation was\n\t  unsuccessful\n\n\n\t2. FPS mode (as in First-Person-Shooter, not Frames-Per-Second):\n\t------------------------\n\n\tThis adds a new button to the player bar which toggles the new FPS mode.\n\tWhen it is enabled, you only have to click once on the canvas and then\n\tyou can move the mouse freely, without the need to keep the mouse button\n\tpressed, or worry about going out of bounds. It's meant primarily for\n\tFPS-like shaders, of course, but it works nicely with pretty much any\n\tshader where you use the mouse to look around or scroll.\n\n\tDemo (41 sec) - note the absence of fast and furious clicking in FPS mode:\n\thttps://youtu.be/Ecl2wHdDm3M\n\t\n\tScript:\n\thttps://gist.github.com/andrei-drexler/7b5829750e41650173bfb7add9ecc61c\n\n\tTODO (maybe):\n\t- add sensitivity control\n\n\n\t3. Page titles (OBSOLETE)\n\t------------------------\n\n\tIf you have multiple Shadertoy tabs open it can be pretty hard to tell them apart.\n\tThis script replaces the familiar 'Shadertoy BETA' tab title with ones such as\n\t'Profile - Shadertoy', 'Page 3 - Shadertoy', or 'Shane - Shadertoy'.\n\n\tScript:\n\thttps://gist.github.com/andrei-drexler/b383896268f5e9a1ce21259848706540\n\n\n\t4. Video capture\n\t------------------------\n\n\tThe built-in video recording feature is pretty handy, but the default settings\n\tdon't work well with noisy shaders (e.g. ones with unfiltered SSAO with low sample\n\tcounts). Also, if the shader runs at 144 Hz, so will the video recording, and that's\n\tsomewhat overkill. This script adds an explicit (high) bitrate, limits the recording\n\tframerate to 60 fps (shader still running at full speed), changes the codec to H264\n\tif available (for better compatibility with video editing/playback software), generates\n\ta more descriptive output file name (e.g. Quake_Introduction-20190130-1948.webm), and\n\talso resumes the shader (if paused) when you begin recording and pauses it when you're\n\tdone.\n\n\tScript:\n\thttps://gist.github.com/andrei-drexler/0898fb9753e5a60240bd72be0e95f3cb\n\n\t----\n\n\tThat is all, for now. Nothing groundbreaking, just some minor tweaks -\n\thence the name, \"Shadertoy Inessentials\".\n\n\tI have some ideas for a few more of these, such as line bookmark support (F2/Ctrl+F2)\n\tfor easier navigation in larger shaders and GPU query-based timing (for some basic\n\tbuffer profiling), but I can't promise anything right now. We'll see :)\n*/\n\n////////////////////////////////////////////////////////////////\n\nconst int ANTIALIAS\t\t\t= 4;\n\n#define ENABLE_REFLECTION\t1\n#define CREEPY_EYE\t\t\t0\n\n////////////////////////////////////////////////////////////////\n\n#define COLOR_SCHEME 1\n\n#if COLOR_SCHEME == 1\nconst vec4\n    BACKGROUND_COLOR\t\t= vec4(.15, .15, .4, 1),\n    SPOTLIGHT_COLOR\t\t\t= vec4(.4, .4, 1., 1),\n    GROUND_TEXT_COLOR\t\t= vec4(1),\n    OVERLAY_COLOR\t\t\t= vec4(.2, .2, .5, 1),\n\tOVERLAY_TEXT_COLOR\t\t= vec4(0, 0, 0, 1),\n\tOVERLAY_TEXT2_COLOR\t\t= vec4(0, 0, 0, .75),\n    OVERLAY_ICON_COLOR\t\t= vec4(0, 0, 0, 1),\n    BOX_COLOR1\t\t\t\t= vec4(.01, .01, .01, 1),\n    BOX_COLOR2\t\t\t\t= vec4(.015, .015, .06, 1),\n    BOX_LINE_COLOR\t\t\t= vec4(.75, .25, 0, 1),\n    BOX_TITLE_COLOR\t\t\t= vec4(1),\n    HOME_EDITION_COLOR\t\t= vec4(1, 1, 1, .125),\n    TAMPERMONKEY_TEXT_COLOR\t= vec4(.3, .3, .3, 1),\n    BLURB_TEXT_COLOR\t\t= vec4(1),\n    USER_QUOTE_COLOR\t\t= vec4(.3, .3, .3, 1)\n;\n#else\nconst vec4\n    BACKGROUND_COLOR\t\t= vec4(.6, .2, .1, 1),\n    SPOTLIGHT_COLOR\t\t\t= vec4(1, .4, .2, 1),\n    GROUND_TEXT_COLOR\t\t= vec4(1),\n    OVERLAY_COLOR\t\t\t= vec4(.75, .25, .12, 1),\n\tOVERLAY_TEXT_COLOR\t\t= vec4(0, 0, 0, 1),\n\tOVERLAY_TEXT2_COLOR\t\t= vec4(0, 0, .02, .75),\n    OVERLAY_ICON_COLOR\t\t= vec4(0, 0, 0, 1),\n    BOX_COLOR1\t\t\t\t= vec4(vec3(.875), 1),\n    BOX_COLOR2\t\t\t\t= vec4(.015, .015, .06, 1),\n    BOX_LINE_COLOR\t\t\t= vec4(.75, .25, 0, 1),\n    BOX_TITLE_COLOR\t\t\t= vec4(1),\n    HOME_EDITION_COLOR\t\t= vec4(1, 1, 1, .125),\n    TAMPERMONKEY_TEXT_COLOR\t= vec4(0, 0, 0, 1),\n    BLURB_TEXT_COLOR\t\t= vec4(1),\n    USER_QUOTE_COLOR\t\t= vec4(0, 0, 0, 1)\n;\n#endif\n\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n\n// Yes, this shader could be MUCH smaller, just that\n// I like long names and I cannot lie\n\n#define SETTINGS_CHANNEL iChannel1\n#define NO_UNROLL min(0, iFrame)\n\nconst float\n    PHI\t= 1.61803408,\n    PI\t= 3.14159265,\n    TAU\t= 2. * PI\n;\n\nfloat min_component(vec2 v)\t\t{ return min(v.x, v.y); }\nfloat min_component(vec3 v)\t\t{ return min(v.x, min(v.y, v.z)); }\nfloat min_component(vec4 v)\t\t{ return min(min(v.x, v.y), min(v.z, v.w)); }\n\nfloat max_component(vec2 v)\t\t{ return max(v.x, v.y); }\nfloat max_component(vec3 v)\t\t{ return max(v.x, max(v.y, v.z)); }\nfloat max_component(vec4 v)\t\t{ return max(max(v.x, v.y), max(v.z, v.w)); }\n\nfloat smoothen(float f)\t\t\t{ return f * f * (3. - 2. * f); }\nvec2  smoothen(vec2 f)\t\t\t{ return f * f * (3. - 2. * f); }\n\nfloat linear_step(float low, float high, float value) {\n    return clamp((value-low)*(1./(high-low)), 0., 1.);\n}\n\nfloat fadeinout(float in0, float in1, float out1, float out0, float x) {\n    return min(linear_step(in0, in1, x), linear_step(out0, out1, x));\n}\n\nfloat around(float peak, float range, float x) {\n    return clamp(1.-abs(x-peak)*(1./range), 0., 1.);\n}\n\nfloat elastic(float cycles, float x) {\n#if 0 // faster, does not reach 1.0 at the end\n\t// https://joshondesign.com/2013/03/01/improvedEasingEquations\n    // http://shader-playground.timjones.io/b23ffee8f0686827dd9a907fcdc8e015\n    return 1. - exp2(x*-10.) * cos(x * cycles * TAU);\n#else // slightly slower, hits 1.0 at the end\n    return 1. - pow(max(0., 1.-x), 6.) * cos(x * cycles * TAU);\n#endif\n}\n\nfloat bounce(float cycles, float x) {\n    x = elastic(cycles, x);\n    return x - max(0., x - 1.) * 2.;\n}\n\nfloat repeat(float div, float x) {\n    return fract(x / div + .5) * div - .5 * div;\n}\n\nvec2 repeat(float div, float minval, float maxval, float x) {\n    x = x / div + .5;\n    float y = clamp(floor(x), minval, maxval);\n    return vec2((x - y) * div - .5 * div, y);\n}\n\nfloat alternate(float speed, float bias, float x) {\n    return clamp(abs(fract(x) - .5) * speed - speed * .25 + bias + .5, 0., 1.);\n}\n\nfloat alternate(float speed, float x) {\n    return alternate(speed, 0., x);\n}\n\n////////////////////////////////////////////////////////////////\n\n// Dave Hoskins/Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\n\nconst vec4 HASHSCALE = vec4(.1031, .1030, .0973, .1099);\n\nfloat hash(float p) {\n    p = fract(p * HASHSCALE.x);\n    p += 3. * p * (p + 19.19);\n    return fract(2. * p * p);\n}\n\nfloat hash(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE.x);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash2(float p) {\n\tvec3 p3 = fract(p * HASHSCALE.xyz);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 hash3(float p) {\n   vec3 p3 = fract(p * HASHSCALE.xyz);\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat smooth_noise(float f) {\n    float i = floor(f);\n    return mix(hash(i), hash(i + 1.), smoothen(f - i));\n}\n\nfloat smooth_noise(vec2 p) {\n    vec2 i = floor(p);\n    p = smoothen(p - i);\n    float s00 = hash(i),\n    \t  s01 = hash(i + vec2(1, 0)),\n    \t  s10 = hash(i + vec2(0, 1)),\n    \t  s11 = hash(i + vec2(1, 1));\n    return mix(mix(s00, s01, p.x), mix(s10, s11, p.x), p.y);\n}\n\nvec2 smooth_noise2(float f) {\n    float i = floor(f);\n    return mix(hash2(i), hash2(i + 1.), smoothen(f - i));\n}\n\n// SDF operations //////////////////////////////////////////////\n\nfloat sdf_exclude(float from, float what) {\n    return max(from, -what);\n}\n\nfloat sdf_union(float a, float b) {\n    return min(a, b);\n}\n\nfloat sdf_intersection(float a, float b) {\n    return max(a, b);\n}\n\nfloat sdf_overlay_wire(float dist, float over, float thickness) {\n    return sdf_union(sdf_exclude(dist, over), abs(over) - thickness);\n}\n\n// SDF generators //////////////////////////////////////////////\n\nfloat line(vec2 p, vec2 a, vec2 b, float thickness) {\n    vec2 ab = b-a, ap = p-a;\n    float t = clamp(dot(ap, ab)/dot(ab, ab), 0., 1.);\n    return length(ap - ab*t) - thickness*.5;\n}\n\nfloat disk(vec2 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat circle(vec2 p, float radius, float thickness) {\n    return abs(length(p) - radius) - thickness * .5;\n}\n\nfloat box(vec2 p, vec2 size) {\n    p = abs(p) - size;\n    return min(0., max(p.x, p.y)) + length(max(p, 0.));\n}\n\n// signed distance to a 2D triangle\n// https://www.shadertoy.com/view/XsXSz4\nfloat sdTriangle(vec2 p, vec2 p0, vec2 p1, vec2 p2) {\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n////////////////////////////////////////////////////////////////\n\nmat2 rotation(float angle) {\n    angle = radians(angle);\n    float c = cos(angle), s = sin(angle);\n    return mat2(c, s, -s, c);\n}\n\nvec2 mod_polar(float divs, vec2 p) {\n    float angle = repeat(TAU/divs, atan(p.y, p.x));\n    return vec2(cos(angle), sin(angle)) * length(p);\n}\n\nfloat mask(float dist) {\n    return clamp(.5-dist, 0., 1.);\n}\n\n// Icons ///////////////////////////////////////////////////////\n\nfloat comment_preview(vec2 p, float time) {\n    float bubble = disk(p - vec2(3.4, 2.1), 4.);\n    bubble = sdf_exclude(bubble, disk(p-vec2(4.5, .5), 4.));\n    bubble = sdf_intersection(bubble, p.y - .25);\n    bubble = sdf_union(bubble, box(p - vec2(0, .5), vec2(.875, .5)) - .25);\n    bubble = abs(bubble) - .0625;\n    \n#if CREEPY_EYE\n    float which = step(.975, hash(floor(time*14.)));\n\n    vec2 p2 = vec2(p.x, abs(p.y - .5));\n    float interior = circle(p2 - vec2(0, -.5), .875, .125);\n    interior = sdf_union(interior, disk(p2, .25));\n    interior = mix(interior, line(p, vec2(-.75, .5), vec2(.75, .5), .125), which);\n#else\n    p.y -= .5;\n    const float\n        LINE_SPACING = .375,\n        LINE_HSIZE = .75;\n    const vec2 CHECKMARK[] = vec2[3](vec2(-.5, 0.), vec2(-.25, -.375), vec2(.5, .375));\n    const vec4 LINES[] = vec4[2*3](\n        vec4(CHECKMARK[0],\tCHECKMARK[1]),\n        vec4(CHECKMARK[1],  CHECKMARK[2]),\n        vec2(CHECKMARK[1]).xyxy,\n        vec4(-LINE_HSIZE, -LINE_SPACING,\tLINE_HSIZE, -LINE_SPACING),\n        vec4(-LINE_HSIZE,  0.,\t\t\t\tLINE_HSIZE,  0.),\n        vec4(-LINE_HSIZE,  LINE_SPACING,\tLINE_HSIZE,  LINE_SPACING)\n    );\n    \n    float which = alternate(4., -.25, time/4.);\n    which = elastic(2., smoothen(which));\n\t\n    #define LINE(idx) line(p, mix(LINES[idx].xy, LINES[idx+3].xy, which), mix(LINES[idx].zw, LINES[idx+3].zw, which), .125)\n    \n    float interior = sdf_union(LINE(0), LINE(1));\n    if (which > 0.)\n        interior = sdf_union(interior, LINE(2));\n#endif\n    return sdf_union(bubble, interior);\n}\n\nfloat compilation_timing(vec2 p, float time) {\n    p.x -= .5;\n    float dist = circle(p, 1., 1./8.);\n    float angle = -fract(time) * TAU + PI*.5;\n    vec2 hand = vec2(cos(angle), sin(angle)) * .625;\n    dist = sdf_union(dist, disk(p, 1./8.));\n    dist = sdf_union(dist, disk(mod_polar(12., p)-vec2(.75,0.), 1./16.));\n    dist = sdf_union(dist, line(p, vec2(0), hand, 1./8.));\n    \n    dist = sdf_union(dist, line(p, vec2(-.25, 1.25), vec2(.25, 1.25), .25));\n    //dist = sdf_union(dist, line(p, vec2(0., 1.), vec2(0., 1.25), 1./4.));\n    dist = sdf_union(dist, line(p * rotation(-45.), vec2(-1./12., 1.25), vec2(1./12., 1.25), 1.5/8.));\n    //dist = sdf_union(dist, line(p * rotation(-45.), vec2(0., 1.15), vec2(0., 1.), 1.5/8.));\n    \n    const float LINES = 3.;\n    float y = clamp(floor(p.y * LINES), -LINES, LINES - 1.) + .5;\n    float len = hash(y - floor(time * 6.));\n    dist = sdf_union(dist, line(p, vec2(-2., y/LINES), vec2(mix(-1.875, -1.25, len), y/LINES), 1./8.));\n    //float len = mix(.0625, .375, hash(y - floor(time * 6.)));\n    //dist = sdf_union(dist, box(p - vec2(-2.+len, y/LINES), vec2(len, 1./16.)));\n    \n    return dist;\n}\n\nfloat target(vec2 p, float time) {\n    p = abs(p);\n    if (p.y > p.x)\n        p = p.yx;\n    float dist = disk(p, 1./8.);\n    dist = sdf_union(dist, line(p, vec2(3./8., 0), vec2(1, 0), 1./8.));\n    return dist;\n}\n\nfloat mouse(vec2 p, float time) {\n    float dist = box(p, vec2(.2, .5)) - .25;\n    dist = sdf_exclude(dist, box(p - vec2(0, .5), vec2(.0625, .3)));\n    dist = sdf_exclude(dist, abs(p.y - .25) - .0625);\n    if (hash(floor(time*7.)) > .75 && p.x < 0. && p.y > .25)\n        dist += .0625;\n    return dist;\n}\n\nfloat fps_mode(vec2 p, float time) {\n    p += smooth_noise2(time * 2.) - .5;\n    float which = alternate(32., time/8.);\n    return mix(target(p, time), mouse(p, time), which);\n}\n\nfloat page_title(vec2 p, float time) {\n    const float\n        THICKNESS\t\t= .0625,\n        MAX_TITLE_LEN\t= .375;\n    const vec2\n        PAGE_SIZE\t\t= vec2(.75, 1),\n        SHADOW\t\t\t= .25 * vec2(1,-1);\n\n    float\n        loop\t\t\t= time / 2.,\n        t\t\t\t\t= fract(loop),\n        fadein\t\t\t= elastic(1., linear_step(.5, 1., t)),\n        fadeout\t\t\t= linear_step(0., .75, t),\n        dist\t\t\t= abs(box(p - SHADOW, PAGE_SIZE)) - THICKNESS,\n        title_length\t= elastic(2., linear_step(0., .25, t)) * MAX_TITLE_LEN * mix(.25, 1., hash(floor(loop)));\n\n    dist = sdf_overlay_wire(dist, box(p - SHADOW * fadeout, PAGE_SIZE), THICKNESS);\n\tdist = sdf_union(dist, line(p - SHADOW * fadeout, vec2(-title_length, .75), vec2(title_length, .75), .125));\n    if (fadein > 0.)\n    \tdist = sdf_overlay_wire(dist, box(p, PAGE_SIZE*fadein), THICKNESS);\n    \n    return dist;\n}\n\nfloat video(vec2 p, float time) {\n    float dist = box(p, vec2(.625, .5)) - .25;\n    dist = sdf_union(dist, sdTriangle(p, vec2(.75,0), vec2(1.25,.375), vec2(1.25,-.375)) - .125);\n    dist = sdf_exclude(dist, circle(p, .3125, .125));\n    p *= rotation(-45. * elastic(2., fract(time)));\n    dist = sdf_exclude(dist, line(mod_polar(8., p), vec2(.375, 0), vec2(.4375, 0), 1.5/8.));\n    return dist;\n}\n\nfloat tampermonkey(vec2 p) {\n    p.x = abs(p.x);\n    float dist = box(p, vec2(.5)) - .25;\n    dist = sdf_exclude(dist, disk(p - vec2(.35, -.35), .3));\n    return dist;\n}\n\n// Text handling ///////////////////////////////////////////////\n\n// Keeping all string data in a giant table leads to a very compact representation\n// for arbitrary length strings and even multi-line strings.\n// Downside: long compilation times on Angle/DX\n\n// TODO: some kind of compression, 2.75 bytes per char is... not good\nconst int STRING_DATA[]=int[637](0x98a7d0d0,0xd0959c99,0x9b829f87,0xd0979e99,0x9dd09e9f,0x85a1d089,0xd0959b91,0x94919883,\n0xd0dc8295,0x81d0b9d0,0x9b939985,0x82d0899c,0x999c9195,0xd094958a,0x84919884,0x9d9f93d0,0x959c9980,0x9d9984d0,0x95878395,\n0x97d09582,0x979e999f,0xd09f84d0,0x91d09592,0x9a919dd0,0x99d0829f,0x95858383,0x9f83d0dc,0x9ed0b9d0,0x95949595,0x9f84d094,\n0xd09592d0,0x959c9291,0xd09f84d0,0x9984809f,0x958a999d,0xd09e9fd0,0x84919884,0x83998891,0x99a3d0de,0xd095939e,0xd0859f89,\n0xd79e9193,0x809fd084,0x999d9984,0x87d0958a,0xd0849198,0xd0859f89,0xd79e9193,0x959dd084,0x82858391,0xb9d0dc95,0x94919dd0,\n0xd091d095,0x93998581,0x9e91dd9b,0x9994dd94,0xd0898482,0x99829383,0x96d08480,0xa4d0829f,0x95809d91,0x9e9f9d82,0xd089959b,\n0x84919884,0x918284d0,0x94959b93,0x9d9f93d0,0x919c9980,0x9e9f9984,0x9d9984d0,0xa7d0de95,0xd0988499,0x84919884,0x989e99d0,\n0xdc949e91,0x87d0b9d0,0x91d08391,0xd0959c92,0x95d09f84,0x82958088,0x9e959d99,0x9987d084,0x86d09884,0x9f998291,0x93d08385,\n0xd095949f,0x839e9f93,0x93858284,0xd0dc8384,0x8291959c,0x979e999e,0x879f98d0,0x9bd09f84,0xd0809595,0x809d9f93,0xd0959c99,\n0x959d9984,0x9e99d083,0x959893d0,0xd0de9b93,0x8496b1d0,0x91d08295,0x999887d0,0xd0dc959c,0x8483d0b9,0x95848291,0x9f87d094,\n0x8295949e,0xd0979e99,0x84959887,0xd0829598,0x9ed0829f,0x84d0849f,0x99d09598,0x8485809e,0x84959dd0,0xd0949f98,0x9c859f93,\n0x839c9194,0x9592d09f,0x809d99d0,0x95869f82,0x83d0dc94,0x95939e99,0x9d9983d0,0xd0899c80,0x9b9f9f9c,0xd0979e99,0x859f8291,\n0x99d0949e,0x9884d09e,0x9986d095,0x91858482,0x9f87d09c,0xd0949c82,0x9f869e99,0x9495869c,0x9f9cd091,0x969fd084,0x999c93d0,\n0x9e999b93,0x9e91d097,0x8294d094,0x99979791,0x91d0979e,0x96d0949e,0xd0849c95,0x99949584,0xd083859f,0x809d9f93,0x94958291,\n0xd09f84d0,0x91d09e91,0x91858493,0x9197d09c,0xb5de959d,0x8295849e,0xd0899dd0,0x9f939583,0xa4d0949e,0x95809d91,0x9e9f9d82,\n0xd089959b,0x99829383,0xd0dc8480,0x99949491,0x91d0979e,0x998783d0,0x91989384,0xd0959c92,0xd0a3a0b6,0x95949f9d,0x919884d0,\n0x87d0dc84,0x959e9598,0x9c92919e,0xd0dc9495,0x9f9c9c91,0xd0949587,0x84d0959d,0x9983d09f,0x899c809d,0x999c93d0,0x9fd09b93,\n0xd095939e,0x99839e99,0x84d09594,0x93d09598,0x91869e91,0x9e91d083,0x9884d094,0x9dd09e95,0xd095869f,0x9d959884,0x9583859f,\n0x958296d0,0xdc899c95,0x849987d0,0x84859f98,0x959884d0,0x95959ed0,0x9f84d094,0x95959bd0,0x9f98d080,0x9e99949c,0x9884d097,\n0x8592d095,0x9e9f8484,0x879f94d0,0xd0d0de9e,0xd09c9cb1,0xd0839187,0x9c9c9587,0x949e91d0,0x9f9f97d0,0x83d0dc94,0xd0b9d09f,\n0x82918483,0xd0949584,0x9e999884,0x979e999b,0x9f9291d0,0x9dd08485,0x95928991,0x9f9883d0,0x979e9987,0x96969fd0,0x959884d0,\n0x94919883,0xd0de8295,0xd09598a4,0x9c998592,0x9e99dd84,0x949986d0,0x82d09f95,0x829f9395,0x979e9994,0x919596d0,0x95828584,\n0xd08399d0,0x89829586,0x9e9198d0,0xd0dc8994,0xd0848592,0xd0959884,0x91969594,0x83849c85,0x99848495,0xd083979e,0xd79e9f94,\n0x9f87d084,0x86d09b82,0xd0898295,0x9c9c9587,0x849987d0,0xd091d098,0x83999f9e,0x9d99d089,0xde959791,0x839cb1d0,0x99d0dc9f,\n0x9f89d096,0x83d08285,0x95949198,0x8582d082,0x8491839e,0xc4c4c1d0,0x838096d0,0x83d0d0dc,0x9f94d09f,0x84d08395,0x86d09598,\n0x9f959499,0x939582d0,0x9994829f,0xd0dc979e,0x949e91d0,0x919884d0,0xd083d784,0x84839f9d,0x9b999cd0,0xd0899c95,0x8295869f,\n0x9c9c999b,0x8495a9de,0x9f9e91d0,0x82959884,0x829383d0,0xd0848099,0xd0839187,0x9e829f92,0x9fd0d0dc,0x84d0959e,0xd0849198,\n0x93829f96,0x91d09495,0x8895d09e,0x93999c80,0x92d08499,0x91828499,0x96d09584,0x86d0829f,0x9f959499,0x9f939582,0x9e999482,\n0x9cd0dc97,0x84999d99,0x84d09495,0x93d09598,0x85848091,0x96d09582,0x959d9182,0x95849182,0xd09f84d0,0x96d0c0c6,0xd0d08380,\n0x919883d8,0xd0829594,0x9c998483,0x8582d09c,0x9e999e9e,0x8491d097,0x9c9c8596,0x958083d0,0xdcd99495,0x958385d0,0xd091d094,\n0x95829f9d,0x839594d0,0x80998293,0x95869984,0x969594d0,0x849c8591,0x9d919ed0,0x9f96d095,0x9884d082,0x859fd095,0x84858084,\n0x9c9996d0,0x91d0dc95,0x9c91949e,0x83d09f83,0x84829184,0x84d09495,0x83d09598,0x95949198,0x9887d082,0x82d09e95,0x829f9395,\n0x979e9994,0x979592d0,0x91d09e91,0x80d0949e,0x95838591,0x8499d094,0x959887d0,0x8499d09e,0x949e95d0,0xd0de9495,0x9198a3d0,\n0x84829594,0x99d0899f,0x8280d083,0x89848495,0x949491d0,0x99849399,0xd0de9586,0x9393bfd7,0x9f998391,0x9c9c919e,0xd0dcd789,\n0x9996d0b9,0x9dd0949e,0x9c958389,0x9987d096,0x83d09884,0x82958695,0x91849c91,0x9fd08392,0xdc9e9580,0x9e85d0d0,0x959c9291,\n0xd09f84d0,0x9c9c9584,0xd08491d0,0x9c97d091,0x95939e91,0x999887d0,0x99d09893,0x9887d083,0xde989399,0x9db1d0d0,0x91d0b9d0,\n0x929184d0,0x919f98d0,0x82959482,0x93d0b9cf,0x949c859f,0x9f8483d0,0x9f84d080,0x999884d0,0x91d09b9e,0x84859f92,0x919884d0,\n0x9f96d084,0xd091d082,0x959d9f9d,0xd0dc849e,0x9dd0829f,0x95928991,0x93d0b9d0,0x949c859f,0x998287d0,0x91d09584,0x98849f9e,\n0x93838295,0x84809982,0xd09f84d0,0x9c809582,0xd0959391,0xd0959884,0x999d9196,0x8291999c,0x98a3d7d0,0x82959491,0xd0899f84,\n0xb1a4b5b2,0x9184d0d7,0x9984d092,0xd0959c84,0x98849987,0x959e9fd0,0x8583d083,0x91d09893,0x82a0d783,0x9c99969f,0xd0ddd095,\n0x949198a3,0x9f848295,0xd0dcd789,0x9791a0d7,0xd0c3d095,0x98a3d0dd,0x82959491,0xd7899f84,0x829fd0dc,0x98a3d7d0,0xd0959e91,\n0x98a3d0dd,0x82959491,0xd7899f84,0xa9dedede,0x87d0859f,0x84d79e9f,0xbcb5b2d0,0xb5a6b5b9,0x919887d0,0x9198d084,0x9e958080,\n0x959ed083,0xd18488,74,9546,19018,28489,37833,47135,0,51146,60619,70219,79820,89548,99263,0,107338,116811,126411,136011,\n145611,155212,164938,174409,0,183755,193355,202957,212811,222406,0,231332,0xa2a4beb9,0xb3a5b4bf,0xa3b7beb9,0xb5b4b1b8,\n0xa9bfa4a2,0xb5beb9d0,0xbeb5a3a3,0xbcb1b9a4,0xc0c2d0a3,0x9fb8c9c1,0xb5d0959d,0x99849994,0x95a49e9f,0x94958483,0x849987d0,\n0x9d91a498,0x9d829580,0x959b9e9f,137,257803,259212,0x9d83d0b1,0xd09c9c91,0x9c9c9f93,0x99849395,0x9fd09e9f,0x98a3d096,\n0x82959491,0xd0899f84,0x91958784,0x9fb3839b,0x9e959d9d,0x8280d084,0x95998695,0x8a91b487,0xd0959c8a,0x87d08385,0xd0988499,\n0x82859f89,0x979184d0,0x9f9c93dd,0x979e9983,0x999b83d0,0xb3839c9c,0x99809d9f,0x9984919c,0x84d09e9f,0x9e999d99,0x9e91b397,\n0x9fd084d7,0x9d998480,0xd0958a99,0x84919887,0x859f89d0,0x9e9193d0,0x9dd084d7,0x85839195,0x99b69582,0xdd848382,0x83829580,\n0x99d09e9f,0x8485809e,0x949f9dd0,0x9195a295,0x9cd09893,0x9c958695,0xd0c0c3d0,0xa1d09e99,0x959b9185,0x91bdd0de,0xbd959289,\n0xd095829f,0x93839594,0x84809982,0xd0958699,0x95979180,0x849984d0,0xb683959c,0x84d0829f,0x84d09598,0x98d09291,0x9482919f,\n0xd0838295,0x9e9f9d91,0x8385d097,0x959499a6,0x9193d09f,0x82858480,0x8784d095,0x839b9195,0x989799b8,0x849992d0,0x95849182,\n0xa0bdd0dc,0xc2b8dfc4,0x99d0c4c6,0x8583d096,0x829f8080,0xbe949584,0xd0b4b5b5,0xbfd0bfa4,0xbdb9a4a0,0xb3b5aab9,0xb9a0bdbf,\n0xa4d0b5bc,0xa3b5bdb9,207,301968,304014,0xa4beb1a7,0xd0bfa4d0,0xb5a6b1b8,0xa2bfbdd0,0xbea5b6b5,0xa0a8b5d0,0xb9a2bfbc,\n0xcfb7be,307217,309390,0xd7beb1b3,0xb5b7d0a4,0xbeb5d0a4,0xb8b7a5bf,0xa3d0b6bf,0xb5b4b1b8,0xa9bfa4a2,207,312336,314381,\n0x859fa9d2,0x859f87d0,0xd79e949c,0x9597d084,0x9884d084,0x96d08399,0xd09d9f82,0xd0899e91,0x9598849f,0x8597d082,0x99a2d289,\n0x82919893,0xdeb1d094,0x8291d0dc,0x84839984,317482,322834),STRBEGIN=7,STRLEN=(1<<STRBEGIN)-1,MULTILINE=1<<19,BACK_BLURB=\n583326,INTRODUCING=251403,SHADERTOY_MODS=252827,HOME_EDITION=256268,FOR_TAMPERMONKEY=589570,SMALL_COLLECTION=262182,\nCOMMENT_PREVIEW=267023,DESC_COMMENT=268966,COMPILATION_TIMING=273810,DESC_TIMING=276133,FPS_MODE=280855,DESC_FPS=283806,\nPAGE_TITLES=287644,DESC_TITLES=291229,VIDEO_CAPTURE=294932,DESC_VIDEO=297507,INTRO_OPTIMIZE=600834,INTRO_FPS=602114,\nINTRO_TABS=603394,USER_QUOTE=605570;\n\nstruct Font {\n    vec2 size;\n    float weight;\n    vec2 align;\n    vec4 color;\n};\n\nFont default_font() {\n    return Font(iResolution.y/vec2(40,16), 1., vec2(0), vec4(0,0,0,1));\n}\n\nint substr(int string, int start, int len) {\n    return (string & ~STRLEN) + (start << STRBEGIN) + len;\n}\n\nint trim(int string, int begin, int end) {\n    return string + (begin << STRBEGIN) - (begin + end);\n}\n\nfloat text(vec2 fragCoord, float px, Font font, int string) {\n    fragCoord /= font.size;\n    int num_lines = ((string & MULTILINE) != 0) ? string & STRLEN : 1;\n    fragCoord.y += font.align.y * float(num_lines);\n    int line = int(floor(fragCoord.y));\n    if (uint(line) >= uint(num_lines))\n        return 0.;\n    line = num_lines - 1 - line;\n\n    if ((string & MULTILINE) != 0)\n        string = STRING_DATA[((string ^ MULTILINE) >> STRBEGIN) + line];\n    fragCoord.x += font.align.x * float(string & STRLEN);\n    int glyph\t= int(floor(fragCoord.x)),\n        begin\t= string >> STRBEGIN,\n\t\tend\t\t= begin + (string & STRLEN);\n    if (uint(glyph) >= uint(end - begin))\n        return 0.;\n\n    glyph += begin;\n    glyph = (STRING_DATA[glyph >> 2] >> ((glyph & 3) << 3)) & 255;\n    fragCoord = fract(fragCoord);\n    fragCoord.x = (fragCoord.x - .5) * .52 + .5;\n    fragCoord += vec2(glyph & 15, glyph >> 4);\n    \n    px *= 2./length(font.size);\n    float alpha = textureLod(iChannel0, fragCoord/16., 0.).w - .5;\n    return 1. - smoothstep(-px*.5, px*.5, alpha - (font.weight - 1.) * px);\n}\n\nfloat text(vec2 fragCoord, Font font, int string) {\n    return text(fragCoord, 1., font, string);\n}\n\nvoid print(inout vec3 fragColor, vec2 fragCoord, float px, Font font, int string) {\n    fragColor.rgb = mix(fragColor.rgb, font.color.rgb, font.color.a * text(fragCoord, px, font, string));\n}\n\nvoid print(inout vec3 fragColor, vec2 fragCoord, Font font, int string) {\n    print(fragColor, fragCoord, 1., font, string);\n}\n\n// QR code (no spoilers, please!) //////////////////////////////\n\nconst int QR[]=int[20](0x7c03b880,0xf2898161,0x4ca51277,0xd204ea20,0xa019c637,494897831,0xa096aae7,0xb9c1d9c5,0x9f1104a6\n,349813413,498351938,0xb7954703,404798302,-60817579,0xf00aaa03,0xba27d3d5,0x749448ba,582772881,0x807d125f,765);\n\nint qr_bit(vec2 uv) {\n    ivec2 iuv = ivec2(floor(uv * 25.));\n    if (max(uint(iuv.x), uint(iuv.y)) >= 25u)\n        return 1;\n    int index = iuv.y * 25 + iuv.x;\n    return (QR[index >> 5] >> (index & 31)) & 1;\n}\n\n// Timing //////////////////////////////////////////////////////\n\nconst float\n    T0_NEED_OPT\t\t= .5,\n    T1_NEED_OPT\t\t= T0_NEED_OPT + 2.,\n    T0_EXPLORE\t\t= T1_NEED_OPT,\n    T1_EXPLORE\t\t= T0_EXPLORE + 2.,\n    T0_TABS\t\t\t= T1_EXPLORE,\n    T1_TABS\t\t\t= T0_TABS + 2.,\n    T0_INTRODUCING\t= T1_TABS,\n    T1_INTRODUCING\t= T0_INTRODUCING + 1.,\n    T0_SPIN\t\t\t= T1_INTRODUCING,\n    T1_SPIN\t\t\t= T0_SPIN + 1.\n;\n\nstruct Anim {\n    bool loaded;\n    float time;\n    float delay;\n    float need_opt;\n    float explore;\n    float tabs;\n    float intro;\n    float spin;\n} g_anim;\n\nvoid init_anim() {\n    // After the font texture gets loaded we want to skip the intro\n    // if we're in thumbnail mode (since the first frame is a plain color)\n    bool is_thumbnail\t= all(lessThan(iResolution.xy, vec2(500, 281)));\n    float time_bias\t\t= is_thumbnail ? 10. : 0.;\n\n    float time_loaded\t= texelFetch(SETTINGS_CHANNEL, ivec2(0), 0).x;\n    g_anim.loaded\t\t= time_loaded >= 0.;\n    g_anim.time\t\t\t= g_anim.loaded ? max(0., iTime - time_loaded + time_bias) : 0.;\n\n    g_anim.delay\t\t= linear_step(0., T0_NEED_OPT, g_anim.time);\n    g_anim.need_opt\t\t= linear_step(T0_NEED_OPT, T1_NEED_OPT, g_anim.time);\n    g_anim.explore\t\t= linear_step(T0_EXPLORE, T1_EXPLORE, g_anim.time);\n    g_anim.tabs\t\t\t= linear_step(T0_TABS, T1_TABS, g_anim.time);\n    g_anim.intro\t\t= linear_step(T0_INTRODUCING, T1_INTRODUCING, g_anim.time);\n    g_anim.spin\t\t\t= smoothstep(T0_SPIN, T1_SPIN, g_anim.time);\n}\n\n// Scene rendering /////////////////////////////////////////////\n\nconst vec3\n    BOX_SIZE\t= vec3(13, 18, 2),\n    BOX_MINS\t= vec3(-BOX_SIZE.x*.5,\t0,\t\t\t-BOX_SIZE.z*.5),\n    BOX_MAXS\t= vec3( BOX_SIZE.x*.5,\tBOX_SIZE.y,\t BOX_SIZE.z*.5),\n    BOX_CENTER\t= (BOX_MINS + BOX_MAXS) * .5\n;\n\nconst int\n    HIT_NOTHING\t\t= -1,\n    HIT_BOX_SIDE\t= 0,\n    HIT_GROUND\t\t= 6\n;\n\nstruct HitResult {\n    int\t\tid;\n    float\tfraction;\n    vec3\tnormal;\n    // filled after intersection\n    vec3\tpoint;\n    float\tpx;\n};\n    \nHitResult no_hit() {\n    return HitResult(HIT_NOTHING, 1., vec3(0), vec3(0), 0.);\n}\n\nbool intersect_ground(vec3 ray_origin, vec3 rcp_ray_delta, inout HitResult result) {\n    float t = -ray_origin.y * rcp_ray_delta.y;\n    if (t < 0. || t > result.fraction)\n        return false;\n\n    result.id \t\t\t= HIT_GROUND;\n    result.fraction\t\t= t;\n    result.normal\t\t= vec3(0, 1, 0);\n\n    return true;\n}\n\nbool intersect_box(vec3 ray_origin, vec3 rcp_ray_delta, vec3 aabb_mins, vec3 aabb_maxs, inout HitResult result)\n{\n    vec3 t0 = (aabb_mins - ray_origin) * rcp_ray_delta;\n    vec3 t1 = (aabb_maxs - ray_origin) * rcp_ray_delta;\n    vec4 tmin = vec4(min(t0, t1), 0.);\n    vec4 tmax = vec4(max(t0, t1), result.fraction);\n    float t = max_component(tmin);\n    if (t > min_component(tmax))\n        return false;\n    \n    int axis =\n        (t == tmin.x) ? 0 :\n    \t(t == tmin.y) ? 1 :\n    \t2;\n    \n    bool side = rcp_ray_delta[axis] > 0.;\n\tresult.id\t\t\t= HIT_BOX_SIDE + (axis << 1) + int(side);\n    result.fraction\t\t= t;\n    result.normal\t\t= vec3(0);\n    result.normal[axis]\t= side ? -1. : 1.;\n    \n    return true;\n}\n\nvoid intersect(vec3 pos, vec3 dir, out HitResult hit) {\n    hit = no_hit();\n    \n    vec3 rcp_dir = 1./dir;\n    if (pos.y > 0.)\n    \tintersect_ground(pos, rcp_dir, hit);\n    intersect_box(pos, rcp_dir, BOX_MINS, BOX_MAXS, hit);\n    \n    hit.point = pos + dir * hit.fraction;\n    hit.px = hit.fraction * max_component(fwidth(dir));\n}\n\nvoid add_text(inout vec3 color, HitResult hit) {\n    Font font = default_font();\n    vec2 text_pos;\n    int string = 0;\n    \n    if (hit.id == HIT_GROUND) {\n        if (g_anim.time > T0_INTRODUCING) {\n            float intro = smoothstep(.25, .75, g_anim.intro);\n            float outro = linear_step(.125, 0., g_anim.spin);\n            string\t\t\t= INTRODUCING;\n            text_pos\t\t= vec2(0, BOX_MAXS.z + .5);\n            font.size\t\t= vec2(1.5, 3) * outro;\n            font.align\t\t= vec2(.5, 1. - min(intro, outro));\n        \ttext_pos\t\t= hit.point.xz - text_pos;\n            if (text_pos.y < -.5)\n                string = 0;\n        } else if (g_anim.time > T0_TABS) {\n            float f\t\t\t= linear_step(1., .95, g_anim.tabs);\n            string\t\t\t= INTRO_TABS;\n            text_pos\t\t= vec2(BOX_MAXS.z + 4., 0);\n            font.size\t\t= vec2(3.*f, 7);\n            font.align\t\t= vec2(0, .5);\n        \ttext_pos\t\t= (hit.point.zx - text_pos) * vec2(1, -1);\n        } else if (g_anim.explore > 0.) {\n            float f\t\t\t= 1.;\n            string\t\t\t= INTRO_FPS;\n            text_pos\t\t= vec2(BOX_MAXS.z + 4., 0);\n            font.size\t\t= vec2(3.*f, 7);\n            font.align\t\t= vec2(1, .5);\n        \ttext_pos\t\t= (hit.point.zx - text_pos) * vec2(-1, 1);\n        } else if (g_anim.need_opt > 0.) {\n            float f\t\t\t= elastic(1., linear_step(0., .4, g_anim.need_opt));\n            string\t\t\t= INTRO_OPTIMIZE;\n            text_pos\t\t= vec2(BOX_MAXS.z + 4., 0);\n            font.size\t\t= vec2(3.*f, 7);\n            font.align\t\t= vec2(0, .5);\n        \ttext_pos\t\t= (hit.point.zx - text_pos) * vec2(1, -1);\n        }\n        font.color\t\t= GROUND_TEXT_COLOR;\n        font.weight\t\t= 1.2;\n    }\n    \n    if (uint(hit.id - HIT_BOX_SIDE) < 6u) {\n        int side = hit.id - HIT_BOX_SIDE;\n        if (side == 5) {\n            if (hit.point.y < 3.) {\n                string\t\t= FOR_TAMPERMONKEY;\n                text_pos\t= vec2(BOX_MINS.x + 2., BOX_MINS.y + 1.5);\n                font.align\t= vec2(0, .5);\n                font.size\t= vec2(.17, .35);\n                font.color\t= TAMPERMONKEY_TEXT_COLOR;\n                font.weight = 1.;\n            } else if (hit.point.y < 8.5) {\n                string\t\t= HOME_EDITION;\n                text_pos\t= vec2(BOX_CENTER.x + 3.4, 8.5);\n                font.align\t= vec2(.5, 1);\n                font.size\t= vec2(.3, .7);\n                font.color\t= HOME_EDITION_COLOR;\n                font.weight = .875;\n            } else {\n                text_pos\t= BOX_CENTER.xy + vec2(1, -.5);\n                font.size\t= vec2(.55, 2.2);\n                font.color\t= BOX_TITLE_COLOR;\n                font.weight\t= 1.2;\n\n                if (hit.point.x > text_pos.x) {\n                    string\t\t\t= substr(SHADERTOY_MODS, 23, 4);\n                    font.size\t\t= vec2(1, 6);\n                    text_pos\t\t+= vec2(.5, -.85);\n                } else if (hit.point.y > text_pos.y + font.size.y) {\n                    string\t\t\t= substr(SHADERTOY_MODS, 0, 9);\n                    font.align.x\t= 1.;\n                    text_pos.y\t\t+= font.size.y;\n                } else {\n                    string\t\t\t= substr(SHADERTOY_MODS, 10, 12);\n                    font.align.x\t= 1.;\n                }\n            }\n\n            text_pos = hit.point.xy - text_pos;\n        } else if (side == 4) {\n            if (hit.point.y < 2.) {\n                string\t\t= USER_QUOTE;\n                text_pos\t= vec2(.7, 1.75);\n                font.align\t= vec2(.7, 1);\n                font.size\t= vec2(.15, .3);\n                font.color\t= USER_QUOTE_COLOR;\n                font.weight = 1.1;\n            } else {\n                string\t\t= BACK_BLURB;\n                text_pos\t= vec2(5.75, 14);\n                font.align\t= vec2(0, 1);\n                font.size\t= vec2(.15, .3);\n                font.color\t= BLURB_TEXT_COLOR;\n                font.weight = .875;\n            }\n            \n            text_pos = (hit.point.xy - text_pos) * vec2(-1, 1);\n        } else if (side == 1) {\n            string\t\t= SHADERTOY_MODS;\n            text_pos\t= BOX_CENTER.yz;\n            font.align\t= vec2(.375, .5);\n            font.size\t= vec2(.3, .7);\n            font.color\t= BOX_TITLE_COLOR;\n            font.weight = 1.;\n            text_pos = (hit.point.yz - text_pos);\n        }\n    }\n    \n    if (string != 0)\n    \tprint(color, text_pos, hit.px, font, string);\n}\n\nconst float\n    FOV = radians(30.),\n    MAX_DRAW_DISTANCE = 1e4\n;\n\nvec3 unproject(vec2 uv) {\n    return vec3(uv * tan(FOV*.5), 1.);\n}\n\nstruct Camera {\n    vec3 pos;\n    vec2 angles; // yaw, pitch\n};\n\nCamera setup_camera() {\n    Camera cam;\n    \n    float spin = 1. - pow(1. - g_anim.spin, 4.);\n    float zoomout = 10.;\n    zoomout = mix(zoomout, 1.5, elastic(1.5, g_anim.delay));\n    zoomout = mix(zoomout, 0., 1.-elastic(1.5, 1.-around(0., 1., g_anim.time - T0_EXPLORE)));\n    zoomout = mix(zoomout, 0., 1.-elastic(1., 1.-around(0., 1., g_anim.time - T0_TABS)));\n    zoomout = mix(zoomout, 4., 1.-elastic(1., 1.-around(0., .5, g_anim.time - T0_INTRODUCING)));\n    zoomout = mix(zoomout, 0., elastic(1., g_anim.intro));\n    zoomout = mix(zoomout, 0., spin);\n    \n    cam.pos = vec3(0, 9, -60);\n    cam.pos = mix(cam.pos, vec3(12, 9, -45), spin);\n    cam.pos.z *= exp2(zoomout);\n   \n    cam.angles = vec2(90, -90);\n    cam.angles.x += 180. * smoothen(g_anim.delay);\n    cam.angles.x -= 180. * smoothstep(-.25, .25, g_anim.time - T1_NEED_OPT);\n    cam.angles.x += 180. * smoothstep(-.25, .25, g_anim.time - T1_EXPLORE);\n    cam.angles.x -= 270. * pow(smoothstep(0., .875, g_anim.intro), 2.);\n    cam.angles += vec2(-315, 95) * spin;\n\n    if (iMouse.z > 0.)\n        cam.angles += vec2(180, 90) * (iMouse.xy - abs(iMouse.zw)) / iResolution.xy;\n    \n    const vec3 PIVOT = vec3(0, 9, 0);\n    const float MIN_CAMERA_HEIGHT = .5;\n    cam.pos -= PIVOT;\n    cam.pos.yz *= rotation(cam.angles.y);\n    cam.pos.xz *= rotation(cam.angles.x);\n    cam.pos /= max(1., -cam.pos.y / (PIVOT.y - MIN_CAMERA_HEIGHT));\n    cam.pos += PIVOT;\n\n    return cam;\n}\n\nvoid spawn_ray(Camera camera, in vec2 fragCoord, out vec3 pos, out vec3 dir) {\n    pos = camera.pos;\n    dir = MAX_DRAW_DISTANCE * unproject((2.*fragCoord - iResolution.xy) / iResolution.y);\n    dir.yz *= rotation(camera.angles.y);\n    dir.xz *= rotation(camera.angles.x);\n}\n\nvec3 shade(vec3 pos, vec3 dir, HitResult hit) {\n    vec3 color = BACKGROUND_COLOR.rgb;\n    \n    if (hit.id == HIT_GROUND) {\n        float light = 1. / (1. + dot(hit.point, hit.point)/96.);\n        color = mix(color, SPOTLIGHT_COLOR.rgb, light * SPOTLIGHT_COLOR.a);\n\n        // authentically fake box shadow\n        float dist = box(hit.point.xz, BOX_SIZE.xz * .5);\n        color *= 1. - .75 / (1. + dist);\n    }\n    \n    if (uint(hit.id - HIT_BOX_SIDE) < 6u) {\n        const float\n            QR_SIZE\t\t= 2.7,\n            QR_MARGIN\t= .55,\n            QR_DIST\t\t= QR_MARGIN + QR_SIZE * .5\n        ;\n        const vec2 QR_POS = BOX_MINS.xy + QR_DIST;\n\n        vec3 middle = BOX_COLOR2.rgb * (.5 + smooth_noise(hit.point.xy * vec2(.2, .31)));\n        float dist;\n\n        dist = abs(hit.point.y - sin(hit.point.x) * .3 - 6.);\n        middle *= 1. + 1.3 * clamp(1. -  dist * .3, 0., 1.);\n        dist = abs(hit.point.y - sin(hit.point.x * .7) * .5 - 6.5);\n        middle *= 1. + .3 * clamp(1. - dist * .6, 0., 1.);\n\n        dist = hit.point.y - 3.5 + sin(.1 + hit.point.x / 5.1);\n        dist = min(dist, -(hit.point.y - 15. - .5 * sin(.7 + -hit.point.x / 5.1)));\n\n        color = BOX_COLOR1.rgb;\n        color = mix(color, middle, clamp(dist/hit.px, 0., 1.) * BOX_COLOR2.a);\n        color = mix(color, BOX_LINE_COLOR.rgb, clamp(1. - (abs(dist) - .1) / hit.px, 0., 1.) * BOX_LINE_COLOR.a);\n\n        int side = hit.id - HIT_BOX_SIDE;\n        if (side == 4 && max_component(abs(hit.point.xy - QR_POS)) < QR_SIZE*.55) {\n            vec2 qr_uv = (hit.point.xy - QR_POS + QR_SIZE*.5) / QR_SIZE;\n            qr_uv.x = 1. - qr_uv.x;\n            color = vec3(qr_bit(qr_uv));\n        }\n        \n        if (side == 5) {\n            const float TAMPERMONKEY_LOGO_SIZE = .5;\n            dist = tampermonkey((hit.point.xy - vec2(-5.25, 1.5))/TAMPERMONKEY_LOGO_SIZE) * TAMPERMONKEY_LOGO_SIZE;\n            color = mix(color, TAMPERMONKEY_TEXT_COLOR.rgb, clamp(1.-dist/hit.px, 0., 1.) * TAMPERMONKEY_TEXT_COLOR.a);\n        }\n    }\n\n    add_text(color, hit);\n    \n    if (uint(hit.id - HIT_BOX_SIDE) < 6u) {\n        // We want the box edges to appear slightly rounded\n        const float FILLET = .1;\n        vec3 bent_normal = normalize(hit.point - clamp(hit.point, BOX_MINS+FILLET, BOX_MAXS-FILLET));\n        float NoL = clamp(-dot(normalize(dir), bent_normal), 0., 1.);\n        color *= mix(NoL, 1., .25);\t\t// diffuse + ambient\n        color += pow(NoL, 32.) / 12.;\t// specular\n    }\n    \n    return color;\n}\n\nvec3 render_scene(Camera camera, vec2 fragCoord) {\n    vec3 pos, dir;\n    spawn_ray(camera, fragCoord, pos, dir);\n    \n    HitResult hit;\n    intersect(pos, dir, hit);\n    \n    vec3 color = shade(pos, dir, hit);\n\n#if ENABLE_REFLECTION\n    pos.y = -pos.y;\n    dir.y = -dir.y;\n    \n    // Note: we intersect the reflection unconditionally to avoid divergence\n    // when computing the intersection footprint\n    HitResult reflection;\n    intersect(pos, dir, reflection);\n\n    if (hit.id == HIT_GROUND) {\n        // fakey mcfake\n        float cos_theta = max(0., normalize(dir).y);\n        float noise = mix(.5, 1., smooth_noise(hit.point.xz / 3.));\n        float spec = mix(.0625, .5, pow(1. - cos_theta, 5.) * noise);\n        if (uint(reflection.id - HIT_BOX_SIDE) < 6u)\n            color = mix(color, shade(pos, dir, reflection), spec);\n    }\n#endif\n    \n    return color;\n}\n\nvec2 hammersley(int i, int total) {\n    uint r = uint(i);\n\tr = ((r & 0x55u) << 1u) | ((r & 0xAAu) >> 1u);\n\tr = ((r & 0x33u) << 2u) | ((r & 0xCCu) >> 2u);\n\tr = ((r & 0x0Fu) << 4u) | ((r & 0xF0u) >> 4u);\n    return vec2(float(i)/float(total), float(r)*(1./256.)) + .5/float(total);\n}\n\nvec3 render_scene_aa(Camera camera, vec2 fragCoord) {\n    const int AA = clamp(ANTIALIAS, 1, 256);\n    vec3 color = vec3(0);\n    for (int i=0+NO_UNROLL; i<AA; ++i)\n    \tcolor += render_scene(camera, fragCoord + hammersley(i, AA) - .5);\n    return color/float(AA);\n}\n\n////////////////////////////////////////////////////////////////\n\nbool loading_screen(out vec4 fragColor, in vec2 fragCoord) {\n    if (g_anim.loaded)\n        return false;\n    \n    vec2  p\t\t\t= fragCoord - .5 - floor(iResolution.xy * .5);\n    float radius\t= length(p),\n\t\t  dist\t\t= abs(radius - 12.5) - 2.5,\n    \t  intensity\t= clamp(1. - dist/fwidth(dist), 0., 1.),\n    \t  highlight\t= floor(fract(-iTime) * 8.),\n          segment\t= fract(atan(p.y, p.x) / TAU) * 8.;\n    intensity *= mix(.4, .84, floor(segment) == highlight);\n    intensity *= smoothstep(0., 1.3, (.5-abs(fract(segment)-.5)) * radius);\n    fragColor.rgb = vec3(intensity);\n    fragColor.a = 1.;\n\n    return true;\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid add_overlay(inout vec4 fragColor, in vec2 fragCoord) {\n\tfloat LINE_HEIGHT\t\t= iResolution.y * 60./450.;\n\tfloat BASE_ICON_SIZE\t= iResolution.y * 16./450.;\n    vec2 FONT_SIZE\t\t\t= iResolution.y / vec2(40, 16);\n    \n    vec2 slide_coord = fragCoord;\n    slide_coord.x -= iResolution.x * (1. - elastic(.7, linear_step(.0, .9, g_anim.spin)));\n    fragColor.rgb = mix(fragColor.rgb, OVERLAY_COLOR.rgb,\n                        OVERLAY_COLOR.a * smoothstep(.35, .55, slide_coord.x/iResolution.x));\n    \n    Font font = default_font();\n    font.color = OVERLAY_TEXT_COLOR;\n    int string = 0;\n    vec2 text_pos = iResolution.xy*vec2(.525, .55) + vec2(BASE_ICON_SIZE*-4., 2.*LINE_HEIGHT);\n    \n    float anim = 1. - smoothstep(.0, 1., g_anim.spin);\n\tfloat icon_size = BASE_ICON_SIZE * (1. - pow(anim, 4.));\n\n    if (slide_coord.y >= text_pos.y) {\n        font.size\t= FONT_SIZE * .875;\n        font.weight\t= 1.1;\n        string\t\t= SMALL_COLLECTION;\n    } else {\n        text_pos.y -= BASE_ICON_SIZE * 1.25;\n        text_pos.x += icon_size * 4.;\n\n        const int LINES[] = int[10](COMMENT_PREVIEW, COMPILATION_TIMING, FPS_MODE, PAGE_TITLES, VIDEO_CAPTURE,\n                                   DESC_COMMENT, DESC_TIMING, DESC_FPS, DESC_TITLES, DESC_VIDEO);\n\n        float line = floor((text_pos.y - slide_coord.y) / LINE_HEIGHT);\n        int line_index = int(line);\n        if (uint(line_index) < 5u) {\n            slide_coord.x -= line * LINE_HEIGHT * (1. - elastic(1., 1. - anim));\n\n            text_pos.y -= (line + .5) * LINE_HEIGHT;\n            font.align\t= vec2(0);\n            font.weight\t= 1.;\n            bool is_description = slide_coord.y < text_pos.y;\n            if (is_description) {\n                string\t\t\t= LINES[5 + line_index];\n                font.align.y\t= 1.;\n                font.size\t\t= FONT_SIZE * .66 * vec2(1., elastic(.75, 1. - anim));\n                font.color\t\t= OVERLAY_TEXT2_COLOR;\n            } else {\n                font.size\t\t= FONT_SIZE * .85;\n                string\t\t\t= LINES[line_index];\n            }\n\n            vec2 icon_pos = slide_coord - text_pos;\n            icon_pos /= icon_size;\n            icon_pos.x += 2.5;\n    \t\tfloat dist = 1e6,\n                  icon_time = g_anim.time - T1_SPIN;\n            switch (line_index) {\n                case 0:  dist = comment_preview(icon_pos, icon_time); break;\n                case 1:  dist = compilation_timing(icon_pos, icon_time); break;\n                case 2:  dist = fps_mode(icon_pos, icon_time); break;\n                case 3:  dist = page_title(icon_pos, icon_time); break;\n                case 4:  dist = video(icon_pos, icon_time); break;\n            }\n            dist *= icon_size;\n            fragColor.rgb = mix(fragColor.rgb, OVERLAY_ICON_COLOR.rgb, mask(dist) * OVERLAY_ICON_COLOR.a);\n        }\n    }\n\n    if (string != 0)\n    \tprint(fragColor.rgb, slide_coord - text_pos, font, string);\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat linear_to_srgb(float x) {\n    return x <= 0.00031308 ? 12.92*x : 1.055*pow(x, 1./2.4)-.055;\n}\n\nvec3 linear_to_srgb(vec3 c) {\n    return vec3(linear_to_srgb(c.r), linear_to_srgb(c.g), linear_to_srgb(c.b));\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    init_anim();\n\n    if (loading_screen(fragColor, fragCoord))\n        return;\n\n    fragColor.rgb = render_scene_aa(setup_camera(), fragCoord);\n    fragColor.a = 1.;\n    \n    add_overlay(fragColor, fragCoord);\n    \n    // vignette\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    fragColor.rgb *= 1. - smoothen(dot(uv, uv));\n    \n    // gamma correction\n    fragColor.rgb = linear_to_srgb(fragColor.rgb);\n    \n    // dithering\n    fragColor.rgb += (hash(fragCoord + iTime*PHI) - .5) / 128.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This shader would look broken without the font texture\n// so we wait for it to get loaded before doing anything else\n\n#define WAIT_FOR_TEXTURE 1\n\nbool is_loaded(sampler2D tex) {\n    return textureSize(tex, 0).x > 1;\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (any(greaterThan(fragCoord, vec2(1))))\n        discard;\n\n#if WAIT_FOR_TEXTURE\n    if (!is_loaded(iChannel1)) {\n        fragColor = vec4(-1);\n        return;\n    }\n#endif\n    \n    fragColor = (iFrame == 0) ? vec4(-1) : texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (fragColor.x < 0.)\n        fragColor = vec4(iTime);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}