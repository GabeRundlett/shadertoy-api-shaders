{
    "Shader": {
        "info": {
            "date": "1675346558",
            "description": "Edge sharpen filter from Media Player Classic-Home Cinema, changed into creating a Matrix-style result. Discovered by accident, as it so often happens.",
            "flags": 0,
            "hasliked": 0,
            "id": "mlXXWj",
            "likes": 1,
            "name": "Matrix Filter",
            "published": 3,
            "tags": [
                "video",
                "filter",
                "greenscreen",
                "matrix",
                "mpc"
            ],
            "usePreview": 0,
            "username": "TimoKinnunen",
            "viewed": 201
        },
        "renderpass": [
            {
                "code": "/****************************************/\n/* Matrix Filter by Timo Kinnunen, 2023 */\n/****************************************/\n/*\n * (C) 2003-2006 Gabest\n * (C) 2006-2013 see Authors.txt\n *\n * This file is part of MPC-HC.\n *\n * MPC-HC is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * MPC-HC is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n//sampler s0 : register(s0);\n//float4 p0 :  register(c0);\n\n//#define width  (p0[0])\n//#define height (p0[1])\n//#define counter (p0[2])\n//#define clock   (p0[3])\n\n#define NbPixel     2.5\n#define Edge_threshold  0.2\n#define Sharpen_val0    2.0\n#define Sharpen_val1    ((Sharpen_val0) * 0.125 - 0.125)\n\n//float4 main(float2 tex : TEXCOORD0) : COLOR\nfloat4 mainCOLOR(float2 tex)\n{\n\tfloat fracY = saturate(0.5+0.5*sin(clock* -3.0+tex.y*1.0+2.*(sin(clock*.5+tex.x*5.0)*2.0+(1.5+0.5*sin(clock*1.5+tex.x*36.0))*(3.0+sin(clock* -0.5+tex.x*47.0)))));\n\tfloat fracX = saturate(8.0*(sin((clock-tex.y*0.75)* -0.375) - 0.75));\n    float4 Res = float4(0);\n\n\t// size of NbPixel pixels\n\tfloat dx = 1.0 / width;\n\tfloat dy = 1.0 / height;\n\tdx *= round(1.0+(NbPixel-1.0)*fracY+0.5*sin(1.1*fracY+0.333*clock+tex.x*256.));\n\tdy *= round(1.0+(NbPixel-1.0)*fracY+0.5*sin(1.3*fracY+0.331*clock+tex.y*256.));\n\t//float4 Res = 0;\n\n\t// Edge detection using Prewitt operator\n\t// Get neighbor points\n\t// [ 1, 2, 3 ]\n\t// [ 4, 0, 5 ]\n\t// [ 6, 7, 8 ]\n\tfloat4 c0 = tex2D(s0, tex);\n\tfloat4 c1 = tex2D(s0, tex + float2(-dx, -dy));\n\tfloat4 c2 = tex2D(s0, tex + float2(  0, -dy));\n\tfloat4 c3 = tex2D(s0, tex + float2( dx, -dy));\n\tfloat4 c4 = tex2D(s0, tex + float2(-dx,   0));\n\tfloat4 c5 = tex2D(s0, tex + float2( dx,   0));\n\tfloat4 c6 = tex2D(s0, tex + float2(-dx,  dy));\n\tfloat4 c7 = tex2D(s0, tex + float2(  0,  dy));\n\tfloat4 c8 = tex2D(s0, tex + float2( dx,  dy));\n\n\t// Computation of the 3 derived vectors (hor, vert, diag1, diag2)\n\tfloat4 delta1 = (c6 + c4 + c1 - c3 - c5 - c8);\n\tfloat4 delta2 = (c4 + c1 + c2 - c5 - c8 - c7);\n\tfloat4 delta3 = (c1 + c2 + c3 - c8 - c7 - c6);\n\tfloat4 delta4 = (c2 + c3 + c5 - c7 - c6 - c4);\n\n\t// Computation of the Prewitt operator\n\tfloat value = length(abs(delta1) + abs(delta2) + abs(delta3) + abs(delta4)) / 6.;\n\n\t// If we have an edge (vector length > Edge_threshold) => apply sharpen filter\n\t{\n\t\tfloat f = value*(2.0/Edge_threshold)-1.0;\n\t\tif (f > 0.0) {\n\t\t\tRes = c0 * Sharpen_val0 - (c1 + c2 + c3 + c4 + c5 + c6 + c7 + c8) * Sharpen_val1;\n\t\t\tif (f <  1.0) {\n\t\t\t\tRes = (Res - c0) * (f)+ c0;\n\t\t\t}\n\t\t} else {\n\t\t\tRes = c0;\n\t\t}\n\t}\n\t\n\t{\n\t\tfloat4  Res2 = frac(abs(Res-c0)*16.0);\n\t\tRes2.g = saturate(value*32.0);\n\t\tRes = lerp(Res2, Res, saturate(1.5*fracX-0.125-0.25*fracY));\n\t}\n\treturn Res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = mainCOLOR(uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 29,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv"
                    },
                    {
                        "channel": 1,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 texmix(vec4 a, vec4 b) {\n    vec4 gs = vec4(13,163,37,0)/255.;\n    float d = distance(gs.rgb,b.rgb);\n    const float threshold = 0.625;\n    float t = smoothstep(0.,threshold,d);\n    float t2 = smoothstep(0.5*threshold,0.75*threshold,d);\n    return mix(a,mix(b-gs,b,t2),t);\n}\n#define s0 iChannel0\n#define width  iResolution.x\n#define height iResolution.y\n#define clock   iTime\n#define float4 vec4\n#define float2 vec2\n#define saturate(a) clamp((a), 0., 1.)\n#define frac fract\n#define lerp mix\n//#define tex2D(a,b) texelFetch(a, ivec2(b), 0)\n#define tex2D(a,b) texmix(texture(a, b),texture(iChannel1, b))\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}