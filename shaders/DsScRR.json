{
    "Shader": {
        "info": {
            "date": "1688282536",
            "description": "sdf",
            "flags": 0,
            "hasliked": 0,
            "id": "DsScRR",
            "likes": 1,
            "name": "Experiment Ek",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "rohtas",
            "viewed": 143
        },
        "renderpass": [
            {
                "code": "const int MAX_STEPS = 20;\nconst float HIT_DISTANCE = 1e-2;\nconst float TRACE_DISTANCE = 20.0;\n// Focal Distance\nconst float focalDistance = 1.5;\n// Scene Geometry\nconst int SPHERE_GRID_RESOLUTION = 3;\nconst int COLUMNS = SPHERE_GRID_RESOLUTION;\nconst int ROWS = SPHERE_GRID_RESOLUTION;\nconst int COUNT = COLUMNS * ROWS;\nconst float SPHERE_RADIUS = 0.2;\nconst float PI = 3.141;\n\nfloat random(float x) {\n  return fract(sin(x) * 43758.5453);\n}\n\nfloat perlinNoise(float x) {\n  float x0 = floor(x);\n  float x1 = x0 + 1.0;\n  \n  float t = x - x0;\n  \n  float r0 = random(x0);\n  float r1 = random(x1);\n  \n  float n0 = mix(r0, r1, smoothstep(0.0, 1.0, t));\n  \n  return n0;\n}\n\nvec3 rotateRayDirection(vec3 rayDirection) {\n  // Get the normalized mouse position\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    // Convert mouse position to rotation angles\n    float rotationX = mouse.x * 2.0 * 3.14159;\n    float rotationY = mouse.y * 2.0 * 3.14159;\n    \n    // Compute camera rotation matrix\n    mat2 rotationMatrix = mat2(cos(rotationX), -sin(rotationX),\n                               sin(rotationX), cos(rotationX));\n    \n    // Apply camera rotation to the ray direction\n    rayDirection.xy = rotationMatrix * rayDirection.xy;\n    return rayDirection;\n}\n\n// credit: http://erkaman.github.io/glsl-cos-palette/\nvec3 cosPalette(  float t,  vec3 a,  vec3 b,  vec3 c, vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n// Function to retrieve audio data from texture\nvec4 getAudioSample(float position) {\n  vec2 uv = vec2(position / 512., 0.5);\n  return texture(iChannel0, uv);\n}\n\nfloat getFrequencyBand(float frequency) {\n  float bandWidth = 48.;\n  float bandIndex = floor(frequency / bandWidth);\n  float bandStart = bandIndex * bandWidth;\n  float bandEnd = (bandIndex + 1.0) * bandWidth;\n  float bandCenter = (bandStart + bandEnd) * 0.5;\n  return bandCenter;\n}\n\nvec3 applyNormalMap(vec3 p, vec3 n) {\n    return 0.01*n;;\n}\n\nvec3 getSphereCenter(int index) {\n    \n    if ( COUNT == 1 ) {\n        return vec3(0.0, 0.0, 0.);\n    }\n    \n    int colIndex = index % COLUMNS;\n    int rowIndex = index / COLUMNS;\n    float x = (float(colIndex) / float(COLUMNS / 2) - 1.) * iResolution.x / iResolution.y;\n    float y = 1. - float(rowIndex) / float(ROWS / 2);\n    return vec3(x, y, 0.0);\n}\n\n\nvec2 mapTheSpheres(vec3 p, float map) {\n    int mapIndex = -1;\n    for(int i=0; i<COUNT; i+=1) {\n        vec3 location = getSphereCenter(i);\n        vec4 sphere = vec4(location, SPHERE_RADIUS);\n        float distanceToSurface = length(p-sphere.xyz) - sphere.w;\n        if(distanceToSurface < map) {\n            map = distanceToSurface;\n            mapIndex = i;\n        }\n    }\n    return vec2(map, mapIndex);\n}\n\n\nvec2 mapTheStage(vec3 p, float map) {\n    \n    // Plane\n    vec2 zPlane = vec2(0.0, 0.0);\n    \n    // Set Distance\n    float planeDist = zPlane.x - p.z;\n    \n    if(planeDist < map) {\n        return vec2(planeDist, COUNT);\n    } else {\n        return vec2(map, -1);\n    }\n\n}\n\n\n\nvec2 mapTheScene(vec3 p) {\n\n    vec2 map_stage = mapTheStage(p, TRACE_DISTANCE);\n    vec2 map_spheres = mapTheSpheres(p, map_stage.x);\n    vec2 map = map_spheres.y == -1.0 ? map_stage : map_spheres;\n    return map;\n}\n\nvec3 GetNormal(vec3 p) {\n\n    const vec3 small_step = vec3(HIT_DISTANCE, 0.0, 0.0);\n    float gradient_x = mapTheScene(p + small_step.xyy).s - mapTheScene(p - small_step.xyy).s;\n    float gradient_y = mapTheScene(p + small_step.yxy).s - mapTheScene(p - small_step.yxy).s;\n    float gradient_z = mapTheScene(p + small_step.yyx).s - mapTheScene(p - small_step.yyx).s;\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nvec3 GetLight(vec3 p, vec3 n, float power) {\n\n    vec3 lightPos = vec3(0., 0., -1.);\n    vec3 lightColor = vec3(1.0);\n    // lightPos.xy += vec2(cos(iTime * 0.2), sin(iTime * 5.8));\n    // lightPos.xz += vec2(sin(1.*iTime), cos(1.*iTime));\n    vec3 l = normalize(lightPos-p);\n    // Diffuse Light\n    float diffuse_intensity = max(0.0, dot(n, l));\n    vec3 lightIntensity = diffuse_intensity*lightColor;\n    return power*lightIntensity;\n}\n\n\n\nvec3 getShader(vec3 p, vec2 uvCoord, vec2 reflectAt) { \n    \n    // Init Color\n    vec3 material = vec3(0.0);\n    \n        \n    // Set Material\n    if(reflectAt.y < float(COUNT)) {\n        material = vec3(0.0, 0.0, 1.0);\n        //material = vec3(0.0, 0.0, 1.0);\n        vec3 closestCenter = getSphereCenter(int(reflectAt.y));\n        float d = distance(p.xy, closestCenter.xy);\n       \n        material = vec3(\n            cosPalette(\n                1.0 - (d / SPHERE_RADIUS)*0.7,\n                vec3(0.31,0.83,0.95),\n                vec3(0.97,1.00,0.00),\n                vec3(0.83,0.64,0.00),\n                vec3(0.92,1.00,0.39)\n             )\n        );\n        d = sin(2.*PI*40.0*d - 5.*iTime);\n        material = material * ( d > 0.5 ? 1.0 : 0.0);    \n    } else {\n    \n        vec2 map = mapTheSpheres(p, TRACE_DISTANCE);\n        vec3 closestCenter = getSphereCenter(int(map.y));\n        float d = distance(p.xy, closestCenter.xy) - SPHERE_RADIUS;\n        \n        if(d < 0.02) {\n          material = vec3(sin(2.0*PI*d + iTime) + 0.8\n          );\n        } else if (d < 0.03) {\n           material = vec3(1.0, 1.0, 0.0);\n        } else {\n           \n            material = vec3(1.0, 0.0, 0.0);\n            \n            // Animation progress between 0 and 1\n            // float progress = mod(iTime * 1.0, 1.0); \n            // Convert progress to sample position\n            //float samplePosition = progress * 512.; \n            //  float waveform = getAudioSample(samplePosition).r;\n            // vec3 audioPalette = cosPalette(\n            //    waveform * 5.,\n            //    vec3(0.8,0.5,0.4),\n            //    vec3(0.2,0.4,0.2),\n            //    vec3(1.0,1.0,1.0),\n            //    vec3(0.0,0.25,0.25)\n            // );\n            // material += (audioPalette * 5.0 * d); \n            \n            material = material * (1.0 - 3.5*d);\n            d = (1.0 - abs(sin(2.*PI*20.0*d - iTime))) <0.3 ? 0. : 1.;\n            material = material*d;\n        }\n    }\n    // Filter\n    return material;\n}\n\n\n\nvec3 RayMarch(vec3 rayOrigin, vec2 uvCoord) {\n    // Define State Variables\n    vec3 intersectionAtImagePlane = vec3(uvCoord, focalDistance);\n    vec3 rayDirection = normalize(intersectionAtImagePlane);\n    // Rotate Ray Direction\n    if (iMouse.z > 0.0) {\n        rayDirection = rotateRayDirection(rayDirection);\n    }\n    // Run Accumulator \n    float distanceToScene = 0.0;\n    vec3 p = vec3(0.0);\n    // Set Environment Lighting\n    vec3 light = vec3(0.0);\n    vec3 color = vec3(0.0);\n    // Get March on the Scene and Set Color\n    for(int i=0; i<MAX_STEPS;i+=1) {\n        p = rayOrigin + distanceToScene * rayDirection;\n        vec2 reflectAt = mapTheScene(p);\n        vec3 n = GetNormal(p);\n        distanceToScene += reflectAt.x;\n        if(reflectAt.x<HIT_DISTANCE) {\n            // Get Light\n            color = GetLight(p, n, 2.50);\n            // Get Material\n            color = color*getShader(p, uvCoord, reflectAt);\n            // Get Sound Effect\n            // vec3 sound = getSoundEffect(uvCoord);\n            // color = color+(0.1*sound);\n            break;\n        }\n        if(distanceToScene > TRACE_DISTANCE) {\n            break;\n        }\n    }\n    // Return the color at raymarch\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uvCoord = fragCoord.xy / iResolution.xy;\n    // Translate origin to center and scale coordinates to -1 to 1\n    uvCoord = (uvCoord - 0.5) * 2.0;\n    \n    // Scale coordiantes to aspect ratio\n    uvCoord.x *= iResolution.x / iResolution.y;\n    \n    // Save Original Value\n    vec2 uv0 = uvCoord;\n    \n    // Locate the camera\n    vec3 p = vec3(0, 0, -2);\n    // Run the RayMarcher renderer\n    vec3 color = RayMarch(p, uvCoord);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}