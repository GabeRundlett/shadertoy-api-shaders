{
    "Shader": {
        "info": {
            "date": "1704961782",
            "description": "This is a pixel inspector.\nIt just shows rgb value of the pixel. It just shows rgb value of the pixel.",
            "flags": 32,
            "hasliked": 0,
            "id": "csVfzh",
            "likes": 28,
            "name": "Pixel Inspector",
            "published": 3,
            "tags": [
                "pixel",
                "debug",
                "tool"
            ],
            "usePreview": 1,
            "username": "iY0Yi",
            "viewed": 562
        },
        "renderpass": [
            {
                "code": "/*\n  ██████  ██ ██   ██ ███████ ██                                          \n  ██   ██ ██  ██ ██  ██      ██                                          \n  ██████  ██   ███   █████   ██                                          \n  ██      ██  ██ ██  ██      ██                                          \n  ██      ██ ██   ██ ███████ ███████                                     \n\n  ██ ███   ██ ███████ ██████  ███████  ██████ ████████  ██████  ██████  \n  ██ ████  ██ ██      ██   ██ ██      ██         ██    ██    ██ ██   ██ \n  ██ ██ ██ ██ ███████ ██████  █████   ██         ██    ██    ██ ██████  \n  ██ ██  ████      ██ ██      ██      ██         ██    ██    ██ ██   ██ \n  ██ ██   ███ ███████ ██      ███████  ██████    ██     ██████  ██   ██\n  \n  Version: 1.0.0\n  Author : iY0Yi\n\n  This is a pixel inspector.\n  It just shows rgb value of the pixel.\n  \n  1. Copy & Paste all of the code in the Common tab to yours.\n  2. Add BufferX and move your \"Image\" code into it.\n  3. Setup the asset panel, and write code to inspect your pixels. This toy's \"Image\" is the example.\n  4. Adjust \"ISP_SIZE\" in the common tab to resize the inspector if you need. (recommend: 80px)\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  \n  // initInspector( fragCoord )\n  // initialize the inspector.\n  initInspector(fragCoord);\n\n  // inspectPixel( vec2 pixel coord )\n  // pass the pixel coord to inspect.\n  // you can inspect multiple pixels at the same time.\n  inspectPixel(iMouse.xy);\n  inspectPixel(iResolution.xy*.5+vec2(sin(iTime*.1),cos(iTime*.1))*300.);\n  inspectPixel(vec2(75,105));\n  \n  // show the result.\n  drawInspector();\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n  ██████  ██ ██   ██ ███████ ██                                          \n  ██   ██ ██  ██ ██  ██      ██                                          \n  ██████  ██   ███   █████   ██                                          \n  ██      ██  ██ ██  ██      ██                                          \n  ██      ██ ██   ██ ███████ ███████                                     \n\n  ██ ███   ██ ███████ ██████  ███████  ██████ ████████  ██████  ██████  \n  ██ ████  ██ ██      ██   ██ ██      ██         ██    ██    ██ ██   ██ \n  ██ ██ ██ ██ ███████ ██████  █████   ██         ██    ██    ██ ██████  \n  ██ ██  ████      ██ ██      ██      ██         ██    ██    ██ ██   ██ \n  ██ ██   ███ ███████ ██      ███████  ██████    ██     ██████  ██   ██\n  \n  Version: 1.0.0\n  Author : iY0Yi\n\n  This is a pixel inspector.\n  It just shows rgb value of the pixel.\n  \n  1. Copy & Paste all of the code in the Common tab to yours.\n  2. Add BufferX and move your \"Image\" code into it.\n  3. Setup the asset panel, and write code to inspect your pixels. This toy's \"Image\" is the example.\n  4. Adjust \"ISP_SIZE\" in the common tab to resize the inspector if you need. (recommend: 80px)\n*/\n\n#define ISP_SIZE 80. //px\n\n// Font renderer\n// ============================================================================\n// \"000Tools: Font Rendering\" by foodini:\n// https://www.shadertoy.com/view/cdtBWl\n\n//TODO:\n//* Have the float's width take an ivec2 in printf %5.12f fashion.\n\n#define DC(name, val) const int name = val\n\nDC(_NULL,127); //I may want as non-null since the font has a character there.\n\nDC(_SPACE,32); DC(_BANG,33); DC(_QUOTE,34); DC(_HASH,35); \nDC(_DOLLAR,36); DC(_PERCENT,37); DC(_AMPERSAND,38); DC(_APOSTROPHE,39); \nDC(_PREN,40); DC(_NERP,41); DC(_STAR,42); DC(_PLUS,43); \nDC(_COMMA,44); DC(_MINUS,45); DC(_PERIOD,46); DC(_SLASH,47);\n\nDC(_0,48); DC(_1,49); DC(_2,50); DC(_3,51);\nDC(_4,52); DC(_5,53); DC(_6,54); DC(_7,55);\nDC(_8,56); DC(_9,57); DC(_COLON,58); DC(_SEMICOLON,59);\nDC(_LFTANGL,60); DC(_EQUAL,61); DC(_RGTANGL,62); DC(_QUESTION,63);\n\nDC(_AT,64); DC(_A,65); DC(_B,66); DC(_C,67); \nDC(_D,68); DC(_E,69); DC(_F,70); DC(_G,71); \nDC(_H,72); DC(_I,73); DC(_J,74); DC(_K,75); \nDC(_L,76); DC(_M,77); DC(_N,78); DC(_O,79); \n\nDC(_P,80); DC(_Q,81); DC(_R,82); DC(_S,83); \nDC(_T,84); DC(_U,85); DC(_V,86); DC(_W,87); \nDC(_X,88); DC(_Y,89); DC(_Z,90); DC(_LFTSQR,91); \nDC(_BACKSLASH,92); DC(_RGTSQR,93); DC(_CARET,94); DC(_UNDERSCORE,95); \n\nDC(_GRAVE,96); DC(_a,97); DC(_b,98); DC(_c,99); \nDC(_d,100); DC(_e,101); DC(_f,102); DC(_g,103); \nDC(_h,104); DC(_i,105); DC(_j,106); DC(_k,107); \nDC(_l,108); DC(_m,109); DC(_n,110); DC(_o,111); \n\nDC(_p,112); DC(_q,113); DC(_r,114); DC(_s,115); \nDC(_t,116); DC(_u,117); DC(_v,118); DC(_w,119); \nDC(_x,120); DC(_y,121); DC(_z,122); DC(_LFTSQUIG,123); \nDC(_PIPE,124); DC(_RGTSQUIG,125); DC(_TILDE,126);\n\nDC(_alpha,128); DC(_beta,129); DC(_gamma,130); DC(_delta,131); \nDC(_epsilon,132); DC(_theta,133); DC(_lambda,134); DC(_mu,135); \nDC(_xi,136); DC(_pi,137); DC(_rho, 138); DC(_sigma,139); \nDC(_tau,140); DC(_phi,141); DC(_psi,142); DC(_omega,143); \n\nDC(_GAMMA,144); DC(_DELTA,145); DC(_THETA,146); DC(_LAMBDA,147); \nDC(_PI,148); DC(_SIGMA,149); DC(_PHI,150); DC(_PSI,151); \nDC(_OMEGA,152); DC(_INFINITY,153); DC(_FORTE,154); DC(_degrees,155); \nDC(_INTEGRAL, 156); DC(_PARTIAL_DIFF, 157); DC(_NABLA,158); DC(_SQRT, 159); \n\n                     DC(_GNAB,161); DC(_CENT,162); DC(_POUND,163); \nDC(_VECTOR_OUT,164); DC(_YEN,165); DC(_BROKEN_PIPE,166); DC(_CONTOUR_INTEGRAL,167); \n                     DC(_COPYRIGHT,169); DC(_superscript_a,170); DC(_LEFT_SHIFT,171); \n                                         DC(_REGISTERED,174); DC(_OVERBAR,175); \n                                         \nDC(_DEGREES, 176); DC(_PLUSMINUS,177); DC(_superscript2,178); DC(_superscript3,179); \nDC(_ACCENT, 180); DC(_MU,181); DC(_PARAGRAPH,182); DC(_DOT,183);\n                  DC(_superscript_1,185); DC(_superscript_0,186); DC(_RIGHT_SHIFT,187); \nDC(_QUARTER,188); DC(_HALF,189); DC(_THREE_QUARTERS,190); DC(_NOITSEUQ,191); \n\nvec4 print_char(sampler2D font_channel, int c, float size, vec2 char_pos, vec2 uv) {\n    //This took me a while to get my brain around: uv and char_pos are in the same\n    //vector space. What that space is is irrelevant. It can be fragCoord, a\n    //square-pixel uv, a 0->1 by 0->1 uv, a -1->1 by -1->1 uv, or anything else. The\n    //only thing that matters is whether uv is within a box \"size\" units on a side.\n    //Check to make sure that uv lies within the extents of the character to be printed:\n\n    //font_uv_offset goes from -1.0->1.0 in both dimensions and is the position \n    //within the rendered character of uv.\n    vec2 font_uv_offset = (uv - char_pos) / size;\n    \n    if(font_uv_offset.x < -1.0 ||\n       font_uv_offset.x >  1.0 ||\n       font_uv_offset.y < -1.0 ||\n       font_uv_offset.y >  1.0) {\n        return vec4(0.0);\n    }\n    \n    \n    float row = float(15 - c/16);\n    float col = float(c%16);\n    \n    const float half_char_width = 1.0/32.0;\n    const float char_width = 1.0/16.0;\n    \n    vec2 font_uv = \n        vec2(half_char_width + char_width * col, half_char_width + char_width * row); \n    font_uv += font_uv_offset * half_char_width;\n    \n    return texture(font_channel, font_uv);\n}\n\nconst float log10 = log(10.0);\nint digits(int i) {\n    i = abs(i);\n    int retval = 0;\n    //TODO: this might be faster as a for loop with a break because of the way\n    //      for loops are unrolled? It would certainly be faster with a binary\n    //      search of ifs.\n    do {\n        retval++;\n        i /= 10;\n    } while(i > 0);\n    return retval;\n}\n\nvec4 print_int(sampler2D font_channel, int i, float size, vec2 pos, vec2 uv, \n               bool right, out int count) {\n    vec4 retval = vec4(0.0);\n    bool neg = i<0;\n    i = abs(i);\n    \n    if(!right) {\n        pos.x += size * (float(digits(i) - 1));\n        if(neg) {\n            pos.x += size;\n        }\n    }\n\n    count = 0;\n    do {\n        int c = 48 + i%10;\n        i /= 10;\n        retval += print_char(font_channel, c, size, pos, uv);\n        pos.x -= size;\n        count ++;\n    } while(i > 0);\n\n    if(neg) {\n        retval += print_char(font_channel, 45, size, pos, uv);\n        count++;\n    }\n    return retval;\n}\nvec4 print_int(sampler2D font_channel, int i, float size, vec2 pos, vec2 uv, \n               bool right) {\n    int _count;\n    return print_int(font_channel, i, size, pos, uv, right, _count);\n}\n\nvec4 print_float(sampler2D font_channel, float f, float size, vec2 pos, vec2 uv, \n                 bool right, int frac_digits, out int count) {\n    vec4 retval = vec4(0.0);\n    count = 0;\n    bool neg = false;\n\n    if(f < 0.0) {\n        neg = true;\n        f = abs(f);\n    }\n    \n    int frac_int = int(0.001 + fract(f) * pow(10.0, float(frac_digits)));\n    int mant_int = int(f);\n    \n    if(!right) {\n        int width = (neg?1:0) + digits(mant_int);\n        if(frac_digits > 0) {\n            width += 1 + frac_digits;\n        }\n        pos.x += size * float(width-1);\n\n        //retval += print_int(font_channel, digits(frac_int), size/2.0, pos + vec2(0.0, size), uv, true, tmp); \n    }\n    \n    \n    if(frac_digits > 0) {\n        retval += print_int(font_channel, frac_int, size, pos, uv, true, count);\n        pos.x -= size * float(count);\n        while(count < frac_digits) {\n            retval += print_char(font_channel, 48, size, pos, uv);\n            pos.x -= size;\n            count ++;\n        }\n        retval += print_char(font_channel, 46, size, pos, uv);\n        pos.x -= size;\n    }\n    int printed;\n    retval += print_int(font_channel, mant_int, size, pos, uv, true, printed);\n    count += printed;\n    if(neg) {\n        pos.x -= size * float(printed);\n        retval += print_char(font_channel, 45, size, pos, uv);\n        count ++;\n    }\n   \n    return retval;\n}\nvec4 print_float(sampler2D font_channel, float f, float size, vec2 pos, vec2 uv, \n                 bool right, int frac_digits) {\n    int _count;\n    return print_float(font_channel, f, size, pos, uv, right, frac_digits, _count);\n}\n\nfloat accumulating_left;\nvec2 accumulating_pos;\nfloat accumulating_size;\nvoid init_printing(vec2 pos, float size) {\n    accumulating_pos = pos;\n    accumulating_left = pos.x;\n    accumulating_size = size;\n}\n\nvoid newline() {\n    accumulating_pos.x = accumulating_left;\n    accumulating_pos.y -= accumulating_size*1.7;\n}\n\nconst float tab_width = 8.0;\nvoid tab() {\n    float x = accumulating_pos.x;\n    float printed = (x-accumulating_left)/accumulating_size;\n    float dx = tab_width - mod(printed, tab_width);\n    accumulating_pos.x += accumulating_size * dx;\n}\n\nvec4 print(sampler2D font_channel, int i, vec2 uv) {\n    int printed;\n    vec4 retval;\n    retval = print_int(font_channel, i, accumulating_size, accumulating_pos, uv, false, printed);\n    accumulating_pos.x += float(printed) * accumulating_size;\n    \n    return retval;\n}\n\nvec4 print(sampler2D font_channel, float f, vec2 uv, int frac_digits) {\n    int printed;\n    vec4 retval;\n    //return print_float(font_channel, f, size, pos, uv, right, frac_digits, _count);\n    retval = print_float(font_channel, f, accumulating_size, accumulating_pos, \n                         uv, false, frac_digits, printed);\n    accumulating_pos.x += float(printed+1) * accumulating_size;\n    \n    return retval;\n}\n\n#define DECL_PRINT_STRING(len) \\\nvec4 print(sampler2D font_channel, int c[len], vec2 uv) { \\\n    vec4 retval; \\\n    for(int i=0; i<len; i++) { \\\n        retval += print_char(font_channel, c[i], accumulating_size, accumulating_pos, uv); \\\n        accumulating_pos.x += accumulating_size; \\\n    } \\\n    return retval; \\\n}\n\nDECL_PRINT_STRING(1)\nDECL_PRINT_STRING(2)\nDECL_PRINT_STRING(3)\nDECL_PRINT_STRING(4)\nDECL_PRINT_STRING(5)\nDECL_PRINT_STRING(6)\nDECL_PRINT_STRING(7)\nDECL_PRINT_STRING(8)\nDECL_PRINT_STRING(9)\n\n\n// Inspector\n// ============================================================================\n\n#define ISP_MAG (ISP_SIZE/5.)\n#define ISP_FONT_SIZE (ISP_SIZE*.1)\n#define ISP_TEX_TARGET iChannel0\n#define ISP_TEX_FONT iChannel1\n\nvec2 gCoord = vec2(0);\nvec3 gCol = vec3(0);\nvec2 gRes = vec2(0);\n\nvoid _initInspector(vec2 coord, sampler2D tex, vec2 res){\n    gCol = texelFetch(tex, ivec2(coord),0).rgb;\n    gCoord = coord;\n    gRes = res;\n}\n\n#define initInspector(c) _initInspector(c, ISP_TEX_TARGET, iResolution.xy)\n\nvoid _inspectPixel(vec2 pixelCoord, sampler2D txTarget, sampler2D txFont){\n    float ratio = gRes.y/gRes.x;\n    \n    vec2 uv = 2.0*gCoord/gRes-1.0;\n    uv.y *= ratio;\n    \n    pixelCoord = floor(pixelCoord);\n    \n    vec2 pixc = pixelCoord/gRes*2.-1.;\n    pixc.y*=ratio;\n    \n    vec2 ioff = vec2(0);\n    vec2 off = vec2(0);\n    if(pixelCoord.x>gRes.x-ISP_SIZE*2.)ioff.x=-ISP_SIZE*4.;\n    if(pixelCoord.y>gRes.y-ISP_SIZE)ioff.y=-ISP_SIZE*2.;\n    off = ioff/gRes;\n    off.y*=ratio;\n    \n    vec2 fuv = vec2(ISP_SIZE*2.+ISP_FONT_SIZE*3., ISP_SIZE+ISP_FONT_SIZE*5.75)/gRes;\n    fuv.y*=ratio;\n    init_printing(pixc+off+fuv, ISP_FONT_SIZE/gRes.y);\n    \n    // the pixel value\n    vec4 pix = texelFetch(txTarget, ivec2(pixelCoord),0);\n\n    // difference draw\n    #define show(v,a) gCol=mix(gCol, abs(clamp(gCol,0.,1.)-vec3(.8, .77, .7)*a),v)\n    \n    // background\n    if(uv.x>pixc.x+off.x && uv.x<pixc.x+off.x+(ISP_SIZE*4.-2.)/gRes.x)\n    if(uv.y>pixc.y+off.y && uv.y<pixc.y+off.y+(ISP_SIZE*2.-2.)/gRes.y*ratio)\n    gCol = vec3(.1);\n    \n    // text rendering\n    {\n        // coords\n        show(print(txFont, int(pixelCoord.x), uv).x, 1.);\n        show(print(txFont, int[](_SLASH), uv).x, 1.);\n        show(print(txFont, int(pixelCoord.y), uv).x, 1.);\n        newline();\n        // r\n        show(print(txFont, int[](_R, _COLON), uv).x, 1.);\n        show(print(txFont, pix.r, uv, 3).x, 1.);\n        newline();\n        // g\n        show(print(txFont, int[](_G, _COLON), uv).x, 1.);\n        show(print(txFont, pix.g, uv, 3).x, 1.);\n        newline();\n        // b\n        show(print(txFont, int[](_B, _COLON), uv).x, 1.);\n        show(print(txFont, pix.b, uv, 3).x, 1.);\n        newline();\n        // a\n        show(print(txFont, int[](_A, _COLON), uv).x, 1.);\n        show(print(txFont, pix.a, uv, 3).x, 1.);\n        newline();\n    }\n    \n    // zoomed pixels\n    if(uv.x>pixc.x+off.x && uv.x<pixc.x+off.x+(ISP_SIZE*2.-2.)/gRes.x)\n    if(uv.y>pixc.y+off.y && uv.y<pixc.y+off.y+(ISP_SIZE*2.-2.)/gRes.y*ratio){\n        vec2 zuv = gCoord-pixelCoord;\n        zuv/=ISP_MAG;\n        zuv+=pixelCoord-ISP_SIZE*.5/ISP_MAG+.5;\n        zuv-=ioff/ISP_SIZE*2.+ioff/ISP_SIZE/2.;\n        \n        // sampling the texture\n        gCol = texelFetch(txTarget, ivec2(zuv),0).rgb;\n        \n        // draw pixel grid\n        show(float(mod(gCoord.x-pixelCoord.x,ISP_MAG)<1.), .1);\n        show(float(mod(gCoord.y-pixelCoord.y,ISP_MAG)<1.), .1);\n\n        // darken neighbors\n        if(gCoord.x<pixelCoord.x+(off.x*gRes.x)*.5+ISP_MAG*2. ||\n        gCoord.x>pixelCoord.x+(off.x*gRes.x)*.5+ISP_MAG*3.+1. ||\n        gCoord.y<pixelCoord.y+(off.y/ratio*gRes.y)*.5+ISP_MAG*2. ||\n        gCoord.y>pixelCoord.y+(off.y/ratio*gRes.y)*.5+ISP_MAG*3.+1.)\n        show(1.,.2);\n    }\n    \n    // crosshair\n    if(gCoord.x>pixelCoord.x-8. && gCoord.x<pixelCoord.x+8.-1.)\n    if(gCoord.y>pixelCoord.y-8. && gCoord.y<pixelCoord.y+8.-1.){\n        show(1.-step(1.,abs(gCoord.x-pixelCoord.x+.5)), 1.);\n        show(1.-step(1.,abs(gCoord.y-pixelCoord.y+.5)), 1.);\n    }\n}\n#define inspectPixel(c) _inspectPixel(c, ISP_TEX_TARGET, ISP_TEX_FONT)\n#define drawInspector() fragColor = vec4(gCol,1)",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    //if(fragCoord.x>=(100.)&&fragCoord.x<=(101.)&&fragCoord.y>=(100.)&&fragCoord.y<=(101.))col=vec3(1,0,0);\n    \n    vec4 rnd = texture(iChannel1, fragCoord/iChannelResolution[1].xy);\n    if(rnd.r>.999)col=vec3(1,0,0);\n    if(rnd.g>.999)col=vec3(0,1,0);\n    if(rnd.b>.999)col=vec3(0,0,1);\n    \n    fragColor = vec4(col,1.0);\n    \n    // works with negative values.\n    // fragColor = fragColor*2.-1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}