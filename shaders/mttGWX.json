{
    "Shader": {
        "info": {
            "date": "1683606166",
            "description": "Fast traversal of a dense grid of rectangular pillars using an implicit quadtree acceleration structure",
            "flags": 0,
            "hasliked": 0,
            "id": "mttGWX",
            "likes": 31,
            "name": "Rectangular Pillar LOD Traversal",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "grid",
                "lod",
                "box",
                "quadtree"
            ],
            "usePreview": 0,
            "username": "gelami",
            "viewed": 556
        },
        "renderpass": [
            {
                "code": "\n// Rectangular Pillar LOD Traversal - gelami\n// https://www.shadertoy.com/view/mttGWX\n\n/*\n * Fast traversal of a dense grid of rectangular pillars\n * using an implicit quadtree acceleration structure\n * \n * Mouse drag to look around\n * Defines in Common\n * \n * The idea is to have the height on each level be multiplied\n * with all of the heights of the levels above it\n * This ensures the height is smaller than than ones above,\n * and allowing us to traverse it as a quadtree structure\n * \n * Though the bounds for each level isn't tightly fit,\n * it works as long as it is conservative\n * \n * Another way to do this with proper bounds is using interval arithmetic,\n * which allows us to query the height over a range to have proper bounds\n * \n * No AA this time unfortunately,\n * the very dense grid didn't bode well with TAA or FXAA v_v\n * \n * My previous shader that also did minmax traversal\n * which precomputes the minmax mipmap in a buffer\n * \n * Fast Minmax Terrain Traversal - gelami\n * https://www.shadertoy.com/view/msj3Dh\n * \n */\n\n// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2023-05-05 04:42:46\n\nvec2 ce;\nfloat map(vec2 p, float lod)\n{\n    #ifdef ENABLE_LOD\n    \n    float st = (sin(iTime * TAU * 0.05)*0.5+0.5)*0.5 + 0.4;\n    \n    float h = 1.0;\n    for (float i = MAX_LOD; i >= lod; i--)\n    {\n        #if 0\n        float f = hash12(floor(p * exp2(MAX_LOD-i)));\n        \n        f = sin((f + iTime * 0.25) * TAU)*0.5+0.5;\n        f = mix(1.0, f, 0.4);\n        \n        #else\n        float s = exp2(MAX_LOD-i);\n        vec2 o = floor(p * s) / exp2(MAX_LOD-i);\n        vec2 o2 = (o - ce) * st + ce;\n        \n        float f = (sin(o2.x)*0.5+0.5 + cos(o2.y)*0.5+0.5)*0.5;\n        \n        float g = texture(iChannel0, 0.2 * o2 / iChannelResolution[0].xy).r;\n        \n        float of = texture(iChannel0, o * 0.0004).x;\n        f = sin((f + g + iTime * 0.25 + of) * TAU)*0.5+0.5;\n        \n        float f2 = hash12(-floor(p * exp2(MAX_LOD-i)));\n        f -= f2 * 0.1;\n        f = mix(1.0, f, 0.15);\n        #endif\n        \n        h *= f;\n    }\n    #else\n    float st = (sin(iTime*0.08)*0.5+0.5) + 0.2;\n    st *= 0.25;\n    float f = (sin(p.x * st)*0.5+0.5 + cos(p.y * st)*0.5+0.5)*0.5;\n    f = sin((f + iTime * 0.25) * TAU)*0.5+0.5;\n    float h = f;\n    #endif\n    \n    return clamp(h * 0.9999 * MAX_HEIGHT, MIN_HEIGHT, MAX_HEIGHT);\n}\n\nstruct HitInfo\n{\n    float t;\n    vec3 n;\n    vec2 tp;\n    float lod;\n    int i;\n};\n\nbool trace(vec3 ro, vec3 rd, out HitInfo hit)\n{\n    if ((ro.y > MAX_HEIGHT && rd.y > 0.0) || (ro.y < MIN_HEIGHT && rd.y > 0.0))\n        return false;\n    \n    vec2 tp = floor(ro.xz);\n    vec2 ltp = tp;\n    \n    float lod = MAX_LOD;\n    float bs = 1.0;\n    \n    vec3 ird = 1.0 / rd;\n    vec3 srd = sign(rd);\n    vec3 ard = abs(ird);\n    \n    vec3 iro = ro * ird;\n    \n    hit.t = MAX_DIST;\n    hit.n = vec3(-1);\n    \n    int i = 0;\n    for (; i < STEPS; i++)\n    {\n        float d = map(tp * bs, lod) * 0.5;\n        \n        vec3 p = vec3((tp.x + 0.5) * bs, d, (tp.y + 0.5) * bs);\n        vec3 s = vec3(bs * 0.5, d, bs * 0.5);\n        vec3 n = iro - p * ird;\n        vec3 k = ard * s;\n        \n        vec3 t1 = -n - k;\n        vec3 t2 = -n + k;\n        \n        float tN = max(max(t1.x, t1.y), t1.z);\n        float tF = min(min(t2.x, t2.y), t2.z);\n        \n        vec3 pos = ro + rd * tN;\n        \n        if (pos.y > MAX_HEIGHT && rd.y > 0.0)\n            return false;\n        \n        if (tN < tF && tN >= 0.0)\n        {\n            if (tN >= MAX_DIST)\n                return false;\n\n            #ifndef ENABLE_LOD\n            hit.t = tN;\n            hit.n = -srd * step(t1.yzx, t1) * step(t1.zxy, t1);\n            hit.tp = tp;\n            hit.i = i;\n            return true;\n            \n            #else\n            \n            float maxLod = log2(tN);\n            \n            if (lod > 0.0)\n            {\n                tp *= 2.0;\n                tp += step(vec2(0), pos.xz - p.xz);\n                ltp = tp;\n                \n                bs *= 0.5;\n                lod--;\n                continue;\n            } else\n            {\n                #ifndef ROUNDED\n                hit.t = tN;\n                hit.n = -srd * step(t1.yzx, t1) * step(t1.zxy, t1);\n                hit.tp = tp * bs;\n                hit.lod = lod;\n                hit.i = i;\n                return true;\n                \n                #else\n                float rad = RADIUS;\n                vec3 o = p;\n                vec3 rp = ro - o;\n                vec3 rs = max(s-rad, vec3(0));\n                float rt = roundedboxIntersect(pos - o, rp, rd, rs, rad);\n                \n                if (rt != MAX_DIST)\n                {\n                    hit.t = rt == 0.0 ? tN : rt;\n                    vec3 pos = rp + rd * hit.t;\n                    hit.n = normalize(roundedboxNormal(pos, rs, rad));\n                    hit.tp = tp * bs;\n                    hit.lod = lod;\n                    hit.i = i;\n                    return true;\n                }\n                #endif\n            }\n            #endif\n        }\n        \n        ltp = tp;\n        tp += step(t2.xz, t2.zx) * srd.xz;\n        \n        #ifdef ENABLE_LOD\n        if (floor(ltp*0.5) != floor(tp*0.5) && lod < MAX_LOD)\n        {\n            tp = floor(tp*0.5);\n            ltp = tp;\n            bs *= 2.0;\n            lod++;\n        }\n        #endif\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pv = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    #ifdef ENABLE_LOD\n    vec3 ro = vec3(0, 0, 16);\n    #else\n    vec3 ro = vec3(0, 0, 60);\n    #endif\n    vec3 lo = vec3(0, MAX_HEIGHT*0.7, 0);\n    \n    lo.xz += vec2(1, 0.3) * iTime;\n    ce = lo.xz;\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    float ax = iMouse.z < 0. || iMouse.x == 0. ? -PI * .7 + iTime * .2 : -m.x * TAU + PI;\n    float ay = iMouse.z < 0. || iMouse.y == 0. ? PI * 0.23 : -m.y * PI + PI * 0.5;\n    \n    ro.yz *= rot2D(ay);\n    ro.xz *= rot2D(ax);\n    ro += lo;\n\n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    vec3 rd = normalize(cmat * vec3(pv, 2));\n\n    vec3 col = vec3(0);\n    \n    vec3 pl = ro;\n    float pt = 0.0;\n    if (pl.y > MAX_HEIGHT)\n    {\n        pt = -(pl.y - MAX_HEIGHT) / rd.y;\n        pl = pl + rd * pt;\n    }\n    \n    HitInfo hit;\n    bool isHit = trace(pl, rd, hit);\n    \n    vec3 pos = pl + rd * hit.t;\n    \n    float t = hit.t + pt;\n    \n    vec3 alb = palette2(map(hit.tp, 0.0) / MAX_HEIGHT * 2.0 + (hash12(hit.tp)-0.5)*0.15);\n    \n    col = alb;\n\n    col *= dot(abs(hit.n), vec3(0.85, 1, 0.7));\n    col *= smoothstep(MAX_HEIGHT*0.3, MAX_HEIGHT*0.8, pos.y)*0.8+0.2;\n    \n    vec3 ldir = normalize(vec3(1, 2.5, 0.6));\n    vec3 ref = reflect(rd, hit.n);\n    \n    HitInfo hitL;\n    bool isHitL = trace(pos + hit.n * EPS, ldir, hitL);\n    \n    float diff = max(dot(ldir, hit.n), 0.0) * float(!isHitL);\n    float bou = max(dot(ref, -ldir), 0.0);\n    \n    col *= diff*0.8+0.25;\n    col += alb * bou * 0.03;\n    \n    vec3 refCol = sRGBToLinear(textureLod(iChannel1, ref, 2.0).rgb) * palette2(0.0);\n    \n    float r0 = 0.08;\n    float fre = r0 + (1.0 - r0) * pow(1.0 - dot(-rd, hit.n), 5.0);\n    \n    col = mix(col, refCol, fre * 0.6);\n    \n    #if 0\n    float a = 0.03;\n    float b = 0.1;\n    float fog = (a / b) * exp(-ro.y * b) * (1.0 - exp(-max(t - 20.0, 0.0) * rd.y * b)) / rd.y;\n    #else\n    float fog = 1.0 - exp(-max(t - 20.0, 0.0) * 0.01);\n    #endif\n    \n    #ifdef FOG\n    col = mix(col, palette2(0.0), saturate(fog));\n    #endif\n    \n    if (!isHit)\n        col = palette2(0.0);\n    \n    //float f = exp2(float(hit.i) / float(STEPS) * 4.0);\n    //f = float(hit.i) / float(STEPS) * 2.0;\n    //col = palette(f);\n      \n    col = max(col, vec3(0));\n    col = col / (1. + col);\n    \n    col = mix(col, smoothstep(vec3(0), vec3(1), col), 0.2);\n    //col = ACESFilm(col);\n    fragColor = vec4(linearTosRGB(col), 1);\n    fragColor += (dot(hash23(vec3(fragCoord, iTime)), vec2(1)) - 0.5) / 255.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define DYNAMIC_LOD\n#define FOG\n\n#define ENABLE_LOD\n\n#ifdef DYNAMIC_LOD\n#define MAX_LOD min(floor((cos(iTime*0.6)*0.5+0.5)*5.0), 3.0)\n#else\n#define MAX_LOD 3.0\n#endif\n\n#define ROUNDED\n//#define RADIUS 0.02\n#define RADIUS 0.012*(4.0 - MAX_LOD)\n\n#define MIN_HEIGHT 0.01\n#define MAX_HEIGHT 10.0\n\n#define STEPS 512\n#define MAX_DIST 1e2\n#define EPS 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\n// Rounded box ray-intersection\n// https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat roundedboxIntersect( in vec3 pos, in vec3 ro, in vec3 rd, in vec3 size, in float rad )\n{\n    vec3 s = sign(pos);\n    ro  *= s;\n    rd  *= s;\n    pos *= s;\n    \n    // Faces\n    pos -= size;\n    pos = max( pos.xyz, pos.yzx );\n    if( min(min(pos.x,pos.y),pos.z) < 0.0 ) return 0.0;\n\n    vec3 oc = ro - size;\n    vec3 dd = rd*rd;\n    vec3 oo = oc*oc;\n    vec3 od = oc*rd;\n    float ra2 = rad*rad;\n\n    float t = MAX_DIST;\n    \n    // Corner\n    {\n        float b = od.x + od.y + od.z;\n        float c = oo.x + oo.y + oo.z - ra2;\n        float h = b*b - c;\n        if( h>0.0 ) t = - b -sqrt(h);\n    }\n    \n    vec3 a = dd.yzx + dd.zxy;\n    vec3 b = od.yzx + od.zxy;\n    vec3 c = oo.yzx + oo.zxy - ra2;\n    vec3 h = b*b - a*c;\n    \n    // Edge X\n    if( h.x>0.0 )\n    {\n        float ht = (-b.x - sqrt(h.x)) / a.x;\n        if( ht>0.0 && ht<t && abs(ro.x+rd.x*ht)<size.x ) t = ht;\n    }\n    \n    // Edge Y\n    if( h.y>0.0 )\n    {\n        float ht = (-b.y - sqrt(h.y)) / a.y;\n        if( ht>0.0 && ht<t && abs(ro.y+rd.y*ht)<size.y ) t = ht;\n    }\n    \n    // Edge Z\n    if( h.z>0.0 )\n    {\n        float ht = (-b.z - sqrt(h.z)) / a.z;\n        if( ht>0.0 && ht<t && abs(ro.z+rd.z*ht)<size.z ) t = ht;\n    }\n    \n    return t;\n}\n\nvec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )\n{\n    return sign(pos)*normalize(max(abs(pos)-siz,0.0));\n}\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat safeacos(float x) { return acos(clamp(x, -1.0, 1.0)); }\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(1)); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nfloat sqr(float x) { return x*x; }\nvec2 sqr(vec2 x) { return x*x; }\nvec3 sqr(vec3 x) { return x*x; }\n\nfloat luminance(vec3 col) { return dot(col, vec3(0.2126729, 0.7151522, 0.0721750)); }\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/smin/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0, .33, .67)));\n}\n\nvec3 palette2(float t)\n{\n    return .55 + .45 * cos(TAU * (vec3(1, 0.95, 1) * t + vec3(0, .25, .75)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}