{
    "Shader": {
        "info": {
            "date": "1456067486",
            "description": "Seeing what happens if you use a smaller than full resolution gbuffer to render.  Using two buffers to simulate having a larger format buffer to store more data.",
            "flags": 32,
            "hasliked": 0,
            "id": "ldG3zV",
            "likes": 8,
            "name": "G-Buffer Upsizing",
            "published": 3,
            "tags": [
                "3d",
                "interpolation",
                "upsize"
            ],
            "usePreview": 0,
            "username": "demofox",
            "viewed": 1603
        },
        "renderpass": [
            {
                "code": "/*============================================================\n\nBlog post with more details:\nhttp://blog.demofox.org/2016/02/21/g-buffer-upsizing/\n\n\nThis shader reads in the ray vs world info and shades the pixel\nbased on that information.  This shader does image upsizing\nif needed.\n\n============================================================*/\n\nconst float c_gamma = 2.2;\n\n#define AA_AMOUNT 7.0 / iResolution.x\n\n//============================================================\n// SHARED CODE BEGIN\n//============================================================\n\nconst float c_pi = 3.14159265359;\n\n// Distance from the camera to the near plane\nconst float c_cameraDistance = 2.0; \n\n// The vertical field of view of the camera in radians\n// Horizontal is defined by accounting for aspect ratio\nconst float c_camera_FOV = c_pi / 2.0;  \n\n// camera orientation\nvec3 c_cameraPos   = vec3(0.0);\nvec3 c_cameraRight = vec3(1.0, 0.0, 0.0);    \nvec3 c_cameraUp    = vec3(0.0, 1.0, 0.0);\nvec3 c_cameraFwd   = vec3(0.0, 0.0, 1.0);    \n\nconst float c_buttonSize = 0.075;      // size on x and y\nconst float c_buttonPadding = 0.025; // between buttons\n\nconst vec2 txState = vec2(0.0,0.0);\n// x = size mode\n// y = interpolation mode\n// z = interpolate image instead of data (1.0)\n// w = unused\n\n//============================================================\nvoid GetRayInfo (in vec2 adjustedFragCoord, out vec3 rayOrigin, out vec3 rayDirection)\n{\n    // calculate a uv of the pixel such that:\n    // * the top of the screen is y = 0.5, \n    // * the bottom of the screen in y = -0.5\n    // * the left and right sides of the screen are extended based on aspect ratio.\n    // * left is -x, right is +x\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = (adjustedFragCoord / iResolution.xy) - vec2(0.5);\n    uv.x *= aspectRatio;\n    \n    // set up the ray for this pixel.\n    // It starts from the near plane, going in the direction from the camera to the spot on the near plane.\n    vec3 rayLocalDir = vec3(uv * sin(c_camera_FOV), c_cameraDistance);\n    rayOrigin =\n        c_cameraPos +\n        rayLocalDir.x * c_cameraRight * c_cameraDistance +\n        rayLocalDir.y * c_cameraUp * c_cameraDistance +\n        rayLocalDir.z * c_cameraFwd * c_cameraDistance;\n    rayDirection = normalize(rayOrigin - c_cameraPos);      \n}\n\n//============================================================\nvec3 MaterialDiffuseColor (int materialIndex)\n{\n    if (materialIndex == 0)\n        return vec3(0.2, 0.4, 0.8);\n    else if (materialIndex == 1)\n        return vec3(1.0, 0.0, 0.0);\n    else if (materialIndex == 2)\n        return vec3(0.0, 1.0, 0.0);\n    else if (materialIndex == 3)\n        return vec3(0.9, 0.3, 0.0);    \n    else if (materialIndex == 4)\n        return vec3(0.0, 0.0, 1.0);     \n    else if (materialIndex == 5)\n        return vec3(0.1, 0.1, 0.1);        \n    else\n        return vec3(1.0);\n}\n\n//============================================================\nfloat MaterialSpecularPower (int materialIndex)\n{\n    if (materialIndex == 3)\n        return 80.0;\n    else if (materialIndex == 5)\n        return 100.0;\n    else\n    \treturn 10.0;\n}\n\n//============================================================\n// SHARED CODE END\n//============================================================\n\n//============================================================\n// save/load code from IQ's shader: https://www.shadertoy.com/view/MddGzf\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 );\n}\n\n//============================================================\n// Signed Distance Functions taken/adapted/inspired by from:\n// https://iquilezles.org/articles/distfunctions\n\n//============================================================\nfloat UDAARectangle (in vec2 coords, in vec2 pos, in vec2 halfSize)\n{        \n\t// make coords relative to pos\n    coords -= pos;\n\n    // calculate closest point\n    vec2 closestPoint;\n    closestPoint.x = clamp(coords.x, -halfSize.x, halfSize.x);\n    closestPoint.y = clamp(coords.y, -halfSize.y, halfSize.y);\n    \n    // return length to closest point\n    return length(coords - closestPoint);\n}\n\n\n//=======================================================================================\nfloat CubicHermite (float A, float B, float C, float D, float t)\n{\n\tfloat t2 = t*t;\n    float t3 = t*t*t;\n    float a = -A/2.0 + (3.0*B)/2.0 - (3.0*C)/2.0 + D/2.0;\n    float b = A - (5.0*B)/2.0 + 2.0*C - D / 2.0;\n    float c = -A/2.0 + C/2.0;\n   \tfloat d = B;\n    \n    return a*t3 + b*t2 + c*t + d;\n}\n\n//=======================================================================================\nvec2 CubicHermite (vec2 A, vec2 B, vec2 C, vec2 D, float t)\n{\n\tfloat t2 = t*t;\n    float t3 = t*t*t;\n    vec2 a = -A/2.0 + (3.0*B)/2.0 - (3.0*C)/2.0 + D/2.0;\n    vec2 b = A - (5.0*B)/2.0 + 2.0*C - D / 2.0;\n    vec2 c = -A/2.0 + C/2.0;\n   \tvec2 d = B;\n    \n    return a*t3 + b*t2 + c*t + d;\n}\n\n//=======================================================================================\nvec3 CubicHermite (vec3 A, vec3 B, vec3 C, vec3 D, float t)\n{\n\tfloat t2 = t*t;\n    float t3 = t*t*t;\n    vec3 a = -A/2.0 + (3.0*B)/2.0 - (3.0*C)/2.0 + D/2.0;\n    vec3 b = A - (5.0*B)/2.0 + 2.0*C - D / 2.0;\n    vec3 c = -A/2.0 + C/2.0;\n   \tvec3 d = B;\n    \n    return a*t3 + b*t2 + c*t + d;\n}\n\n//=======================================================================================\nvec4 CubicHermite (vec4 A, vec4 B, vec4 C, vec4 D, float t)\n{\n\tfloat t2 = t*t;\n    float t3 = t*t*t;\n    vec4 a = -A/2.0 + (3.0*B)/2.0 - (3.0*C)/2.0 + D/2.0;\n    vec4 b = A - (5.0*B)/2.0 + 2.0*C - D / 2.0;\n    vec4 c = -A/2.0 + C/2.0;\n   \tvec4 d = B;\n    \n    return a*t3 + b*t2 + c*t + d;\n}\n\n//============================================================\nvec3 SampleInterpolationTexturePixel (vec2 pixel)\n{\n    pixel = mod(pixel, 2.0);\n    \n    // Used only for the interpolation buttons!\n    return vec3(\n        pixel.x / 3.0,\n    \tpixel.y / 3.0,\n        mod(pixel.x + pixel.y, 2.0)\n    );    \n}\n\n//============================================================\nvec3 SampleInterpolationTextureNearest (vec2 uv)\n{\n    vec2 pixel = clamp(floor(uv*2.0), 0.0, 1.0);\n\treturn SampleInterpolationTexturePixel(pixel);\n}\n\n//============================================================\nvec3 SampleInterpolationTextureBilinear (vec2 uv)\n{\n    vec2 pixel = uv * 2.0 - 0.5;\n    vec2 pixelFract = fract(pixel);\n    \n    vec3 pixel00 = SampleInterpolationTexturePixel(floor(pixel) + vec2(0.0, 0.0));\n    vec3 pixel10 = SampleInterpolationTexturePixel(floor(pixel) + vec2(1.0, 0.0));\n    vec3 pixel01 = SampleInterpolationTexturePixel(floor(pixel) + vec2(0.0, 1.0));\n    vec3 pixel11 = SampleInterpolationTexturePixel(floor(pixel) + vec2(1.0, 1.0));\n    \n    vec3 row0 = mix(pixel00, pixel10, pixelFract.x);\n    vec3 row1 = mix(pixel01, pixel11, pixelFract.x);\n    \n    return mix(row0, row1, pixelFract.y);\n}\n\n//============================================================\nvec3 SampleInterpolationTextureBicubic (vec2 uv)\n{\n    vec2 pixel = uv * 2.0 - 0.5;\n    vec2 pixelFract = fract(pixel);\n    \n    vec3 pixelNN = SampleInterpolationTexturePixel(floor(pixel) + vec2(-1.0, -1.0));\n    vec3 pixel0N = SampleInterpolationTexturePixel(floor(pixel) + vec2( 0.0, -1.0));\n    vec3 pixel1N = SampleInterpolationTexturePixel(floor(pixel) + vec2( 1.0, -1.0));\n    vec3 pixel2N = SampleInterpolationTexturePixel(floor(pixel) + vec2( 2.0, -1.0));\n    \n    vec3 pixelN0 = SampleInterpolationTexturePixel(floor(pixel) + vec2(-1.0,  0.0));\n    vec3 pixel00 = SampleInterpolationTexturePixel(floor(pixel) + vec2( 0.0,  0.0));\n    vec3 pixel10 = SampleInterpolationTexturePixel(floor(pixel) + vec2( 1.0,  0.0));\n    vec3 pixel20 = SampleInterpolationTexturePixel(floor(pixel) + vec2( 2.0,  0.0));   \n    \n    vec3 pixelN1 = SampleInterpolationTexturePixel(floor(pixel) + vec2(-1.0,  1.0));\n    vec3 pixel01 = SampleInterpolationTexturePixel(floor(pixel) + vec2( 0.0,  1.0));\n    vec3 pixel11 = SampleInterpolationTexturePixel(floor(pixel) + vec2( 1.0,  1.0));\n    vec3 pixel21 = SampleInterpolationTexturePixel(floor(pixel) + vec2( 2.0,  1.0));     \n    \n    vec3 pixelN2 = SampleInterpolationTexturePixel(floor(pixel) + vec2(-1.0,  2.0));\n    vec3 pixel02 = SampleInterpolationTexturePixel(floor(pixel) + vec2( 0.0,  2.0));\n    vec3 pixel12 = SampleInterpolationTexturePixel(floor(pixel) + vec2( 1.0,  2.0));\n    vec3 pixel22 = SampleInterpolationTexturePixel(floor(pixel) + vec2( 2.0,  2.0));     \n    \n    vec3 rowN = CubicHermite(pixelNN, pixel0N, pixel1N, pixel2N, pixelFract.x);\n    vec3 row0 = CubicHermite(pixelN0, pixel00, pixel10, pixel20, pixelFract.x);\n    vec3 row1 = CubicHermite(pixelN1, pixel01, pixel11, pixel21, pixelFract.x);\n    vec3 row2 = CubicHermite(pixelN2, pixel02, pixel12, pixel22, pixelFract.x);\n    \n    return CubicHermite(rowN, row0, row1, row2, pixelFract.y);\n}\n\n//============================================================\nvec4 SampleNearest (in vec2 adjustedFragCoord)\n{\n\tvec2 uv = adjustedFragCoord / iResolution.xy;\n    return texture(iChannel0, uv);\n}\n\n//============================================================\nvec4 SampleBilinear (in vec2 adjustedFragCoord)\n{\n    adjustedFragCoord-= 0.5;\n    vec2 fragFract = fract(adjustedFragCoord);\n    \n    // get the four data points\n    vec2 uvMin = adjustedFragCoord / iResolution.xy;\n    vec2 uvMax = (adjustedFragCoord + vec2(1.0)) / iResolution.xy;\n    vec4 data00 = texture(iChannel0, uvMin);\n    vec4 data10 = texture(iChannel0, vec2(uvMax.x, uvMin.y));\n    vec4 data01 = texture(iChannel0, vec2(uvMin.x, uvMax.y));\n    vec4 data11 = texture(iChannel0, uvMax);\n    \n    // bilinear interpolate\n    vec4 datax0 = mix(data00, data10, fragFract.x);\n    vec4 datax1 = mix(data01, data11, fragFract.x);\n    return mix(datax0, datax1, fragFract.y);\n}\n\n//============================================================\nvec4 SampleBicubic (in vec2 adjustedFragCoord)\n{\n    adjustedFragCoord-= 0.5;    \n    vec2 fragFract = fract(adjustedFragCoord);\n    \n    // get the 16 data points\n    vec4 dataNN = texture(iChannel0, (adjustedFragCoord + vec2(-1.0, -1.0)) / iResolution.xy);\n    vec4 data0N = texture(iChannel0, (adjustedFragCoord + vec2( 0.0, -1.0)) / iResolution.xy);\n    vec4 data1N = texture(iChannel0, (adjustedFragCoord + vec2( 1.0, -1.0)) / iResolution.xy);\n    vec4 data2N = texture(iChannel0, (adjustedFragCoord + vec2( 2.0, -1.0)) / iResolution.xy);\n    \n    vec4 dataN0 = texture(iChannel0, (adjustedFragCoord + vec2(-1.0,  0.0)) / iResolution.xy);\n    vec4 data00 = texture(iChannel0, (adjustedFragCoord + vec2( 0.0,  0.0)) / iResolution.xy);\n    vec4 data10 = texture(iChannel0, (adjustedFragCoord + vec2( 1.0,  0.0)) / iResolution.xy);\n    vec4 data20 = texture(iChannel0, (adjustedFragCoord + vec2( 2.0,  0.0)) / iResolution.xy);    \n    \n    vec4 dataN1 = texture(iChannel0, (adjustedFragCoord + vec2(-1.0,  1.0)) / iResolution.xy);\n    vec4 data01 = texture(iChannel0, (adjustedFragCoord + vec2( 0.0,  1.0)) / iResolution.xy);\n    vec4 data11 = texture(iChannel0, (adjustedFragCoord + vec2( 1.0,  1.0)) / iResolution.xy);\n    vec4 data21 = texture(iChannel0, (adjustedFragCoord + vec2( 2.0,  1.0)) / iResolution.xy);     \n    \n    vec4 dataN2 = texture(iChannel0, (adjustedFragCoord + vec2(-1.0,  2.0)) / iResolution.xy);\n    vec4 data02 = texture(iChannel0, (adjustedFragCoord + vec2( 0.0,  2.0)) / iResolution.xy);\n    vec4 data12 = texture(iChannel0, (adjustedFragCoord + vec2( 1.0,  2.0)) / iResolution.xy);\n    vec4 data22 = texture(iChannel0, (adjustedFragCoord + vec2( 2.0,  2.0)) / iResolution.xy);     \n    \n    // bicubic interpolate\n    vec4 dataxN = CubicHermite(dataNN, data0N, data1N, data2N, fragFract.x);\n    vec4 datax0 = CubicHermite(dataN0, data00, data10, data20, fragFract.x);\n    vec4 datax1 = CubicHermite(dataN1, data01, data11, data21, fragFract.x);\n    vec4 datax2 = CubicHermite(dataN2, data02, data12, data22, fragFract.x);\n    return CubicHermite(dataxN, datax0, datax1, datax2, fragFract.y);\n}\n\n\n//============================================================\nvoid DrawUI (in vec2 fragCoord, inout vec3 pixelColor, int sizeMode, int interpolationMode, bool upsizeImage)\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = (fragCoord / iResolution.xy);\n    uv.x *= aspectRatio;\n    uv.y = 1.0 - uv.y;\n    \n    vec2 buttonClickRelative = mod(uv, c_buttonSize+c_buttonPadding);\n    vec2 buttonIndex = floor(uv / (c_buttonSize+c_buttonPadding));\n    \n    const float c_darkTint = 1.0 / 10.0;\n    \n    // draw the size mode buttons\n    \n    // full size\n    {\n        float tint = (sizeMode == 0) ? 1.0 : c_darkTint;\n        vec2 center = vec2(c_buttonSize*0.5 + c_buttonPadding);\n        center += vec2(0.0, 0.0) * (c_buttonSize+c_buttonPadding);\n        float dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.5));\n        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);\n        pixelColor = mix(pixelColor, vec3(tint), dist); \n    }\n    \n    // half size horizontally\n    {\n        float tint = (sizeMode == 1) ? 1.0 : c_darkTint;\n        vec2 center = vec2(c_buttonSize*0.5 + c_buttonPadding);\n        center += vec2(1.0, 0.0) * (c_buttonSize+c_buttonPadding);;\n        float dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.5));\n        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);\n        pixelColor = mix(pixelColor, vec3(0.0), dist); \n        \n        center.x -= c_buttonSize * 0.25;\n\t\tdist = UDAARectangle(uv, center, vec2(c_buttonSize*0.25, c_buttonSize*0.5));\n        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);\n        pixelColor = mix(pixelColor, vec3(tint), dist);\n    }\n    \n    // half size vertically\n    {\n        float tint = (sizeMode == 2) ? 1.0 : c_darkTint;\n        vec2 center = vec2(c_buttonSize*0.5 + c_buttonPadding);\n        center += vec2(2.0, 0.0) * (c_buttonSize+c_buttonPadding);;\n        float dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.5));\n        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);\n        pixelColor = mix(pixelColor, vec3(0.0), dist); \n        \n        center.y += c_buttonSize * 0.25;\n        dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.5, c_buttonSize*0.25));\n        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);\n        pixelColor = mix(pixelColor, vec3(tint), dist);         \n    }      \n    \n    // quarter size\n    {\n        float tint = (sizeMode == 3) ? 1.0 : c_darkTint;\n        vec2 center = vec2(c_buttonSize*0.5 + c_buttonPadding);\n        center += vec2(3.0, 0.0) * (c_buttonSize+c_buttonPadding);;\n        float dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.5));\n        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);\n        pixelColor = mix(pixelColor, vec3(0.0), dist);\n        \n        center -= vec2(c_buttonSize * 0.25, -c_buttonSize * 0.25);\n        dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.25, c_buttonSize*0.25));\n        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);\n        pixelColor = mix(pixelColor, vec3(tint), dist);          \n    }     \n    \n    // eighth size\n    {\n        float tint = (sizeMode == 4) ? 1.0 : c_darkTint;\n        vec2 center = vec2(c_buttonSize*0.5 + c_buttonPadding);\n        center += vec2(4.0, 0.0) * (c_buttonSize+c_buttonPadding);\n        float dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.5));\n        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);\n        pixelColor = mix(pixelColor, vec3(0.0), dist);\n        \n        center -= vec2(c_buttonSize * 0.375, -c_buttonSize * 0.375);\n        dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.125, c_buttonSize*0.125));\n        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);\n        pixelColor = mix(pixelColor, vec3(tint), dist);\n    }    \n    \n    // draw the blend mode icons\n    \n    // nearest neighbor\n    {\n        float tint = (interpolationMode == 0) ? 1.0 : c_darkTint;\n        vec2 center = vec2(c_buttonSize*0.5 + c_buttonPadding);\n        center += vec2(0.0, 1.0) * (c_buttonSize+c_buttonPadding);  \n        \n        vec2 percent = (uv - (center - vec2(c_buttonSize*0.5))) / c_buttonSize;\n        vec3 buttonColor = vec3(\n            clamp(floor(percent.x * 4.0) / 3.0, 0.0, 1.0),\n            clamp(floor(percent.y * 4.0) / 3.0, 0.0, 1.0),\n\t\t\t0.0);\n        \n        buttonColor = SampleInterpolationTextureNearest(percent);\n        \n        float dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.5));\n        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);\n        pixelColor = mix(pixelColor, buttonColor * tint, dist);        \n    }\n\n    // bilinear\n    {\n        float tint = (interpolationMode == 1) ? 1.0 : c_darkTint;\n        vec2 center = vec2(c_buttonSize*0.5 + c_buttonPadding);\n        center += vec2(1.0, 1.0) * (c_buttonSize+c_buttonPadding);  \n        \n        vec2 percent = (uv - (center - vec2(c_buttonSize*0.5))) / c_buttonSize;\n        vec3 buttonColor = vec3(\n            clamp(floor(percent.x * 4.0) / 3.0, 0.0, 1.0),\n            clamp(floor(percent.y * 4.0) / 3.0, 0.0, 1.0),\n\t\t\t0.0);\n        \n        buttonColor = SampleInterpolationTextureBilinear(percent);\n        \n        float dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.5));\n        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);\n        pixelColor = mix(pixelColor, buttonColor * tint, dist);       \n    }  \n    \n    // bicubic\n    {\n        float tint = (interpolationMode == 2) ? 1.0 : c_darkTint;\n        vec2 center = vec2(c_buttonSize*0.5 + c_buttonPadding);\n        center += vec2(2.0, 1.0) * (c_buttonSize+c_buttonPadding);  \n        \n        vec2 percent = (uv - (center - vec2(c_buttonSize*0.5))) / c_buttonSize;\n        vec3 buttonColor = vec3(\n            clamp(floor(percent.x * 4.0) / 3.0, 0.0, 1.0),\n            clamp(floor(percent.y * 4.0) / 3.0, 0.0, 1.0),\n\t\t\t0.0);\n        \n        buttonColor = SampleInterpolationTextureBicubic(percent);\n        \n        float dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.5));\n        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);\n        pixelColor = mix(pixelColor, buttonColor * tint, dist);       \n    }   \n    \n    // draw the image resample toggle\n    \n    // data\n    {\n        float tint = (!upsizeImage) ? 1.0 : c_darkTint;\n        vec2 center = vec2(c_buttonSize*0.5 + c_buttonPadding);\n        center += vec2(0.0, 2.0) * (c_buttonSize+c_buttonPadding);  \n        \n        vec2 percent = (uv - (center - vec2(c_buttonSize*0.5))) / c_buttonSize;\n        vec3 buttonColor = vec3(\n            clamp(floor(percent.x * 4.0) / 3.0, 0.0, 1.0),\n            clamp(floor(percent.y * 4.0) / 3.0, 0.0, 1.0),\n\t\t\t0.0);\n        \n        buttonColor = vec3(1.0);\n        \n        float dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.5));\n        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);\n        pixelColor = mix(pixelColor, buttonColor * tint, dist);        \n    }    \n    \n    // image\n    {\n        float tint = (upsizeImage) ? 1.0 : c_darkTint;\n        vec2 center = vec2(c_buttonSize*0.5 + c_buttonPadding);\n        center += vec2(1.0, 2.0) * (c_buttonSize+c_buttonPadding);  \n        \n        vec2 percent = (uv - (center - vec2(c_buttonSize*0.5))) / c_buttonSize;\n        vec3 buttonColor = vec3(\n            clamp(floor(percent.x * 4.0) / 3.0, 0.0, 1.0),\n            clamp(floor(percent.y * 4.0) / 3.0, 0.0, 1.0),\n\t\t\t0.0);\n        \n        buttonColor = vec3(1.0);\n        \n        float dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.5));\n        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);\n        pixelColor = mix(pixelColor, buttonColor * tint, dist);        \n    }        \n}\n\n//============================================================\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // get the state from the buffer\n    vec4 state = loadValue(txState);\n    int sizeMode = int(state.x);\n    int interpolationMode = int(state.y);\n    bool upsizeImage = state.z == 1.0;\n    \n    // adjust coordinates based on size mode if we are upsizing data, not the final image\n    vec2 adjustedFragCoord = fragCoord;\n    if (upsizeImage) {\n        if (sizeMode == 1 || sizeMode == 3)\n            adjustedFragCoord.x /= 2.0;\n\n        if (sizeMode == 2 || sizeMode == 3)\n            adjustedFragCoord.y /= 2.0;\n\n        if (sizeMode == 4)\n            adjustedFragCoord /= 4.0;\n    }\n    else\n        interpolationMode = 0;    \n    \n    // sample texture\n    vec3 pixelColor;\n    if (interpolationMode == 0)\n    \tpixelColor = SampleNearest(adjustedFragCoord).rgb;        \n    else if (interpolationMode == 1)\n        pixelColor = SampleBilinear(adjustedFragCoord).rgb;\n    else\n        pixelColor = SampleBicubic(adjustedFragCoord).rgb; \n        \n    // draw the UI. from the original, restoring interpolationMode since it might have been artifically modified above\n    interpolationMode = int(state.y);\n    DrawUI(fragCoord, pixelColor, sizeMode, interpolationMode, upsizeImage);\n        \n    // gamma correct\n\tpixelColor = pow(pixelColor, vec3(1.0/c_gamma));\n    fragColor = vec4(pixelColor, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define SHADER_INDEX 0\n\n/*============================================================\n\nThis shader does the ray vs world tests and writes information\nabout the surface it finds for a ray in the output pixel.\n\nFormat:\n\n--Shader Index 0--\nR, G = X,Y part of normal.  Z part of normal calculated on demand.\nB, A = R,G,B stored in 8 bits each, leaving 8 bits unused. (aprox)\n\n--Shader Index 1--\nR = distance down ray to hit (depth essentially)\nG = material index (could do in 1 byte if that'd be helpful)\nB,A = texture coordinates u,v\n\n============================================================*/\n\n//============================================================\n// SHARED CODE BEGIN\n//============================================================\n\nconst float c_pi = 3.14159265359;\n\n// Distance from the camera to the near plane\nconst float c_cameraDistance = 2.0; \n\n// The vertical field of view of the camera in radians\n// Horizontal is defined by accounting for aspect ratio\nconst float c_camera_FOV = c_pi / 2.0;  \n\n// camera orientation\nvec3 c_cameraPos   = vec3(0.0);\nvec3 c_cameraRight = vec3(1.0, 0.0, 0.0);    \nvec3 c_cameraUp    = vec3(0.0, 1.0, 0.0);\nvec3 c_cameraFwd   = vec3(0.0, 0.0, 1.0);    \n\nconst float c_buttonSize = 0.075;      // size on x and y\nconst float c_buttonPadding = 0.025; // between buttons\n\nconst vec2 txState = vec2(0.0,0.0);\n// x = size mode\n// y = interpolation mode\n// z = interpolate image instead of data (1.0)\n// w = unused\n\n//============================================================\nvoid GetRayInfo (in vec2 adjustedFragCoord, out vec3 rayOrigin, out vec3 rayDirection)\n{\n    // calculate a uv of the pixel such that:\n    // * the top of the screen is y = 0.5, \n    // * the bottom of the screen in y = -0.5\n    // * the left and right sides of the screen are extended based on aspect ratio.\n    // * left is -x, right is +x\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = (adjustedFragCoord / iResolution.xy) - vec2(0.5);\n    uv.x *= aspectRatio;\n    \n    // set up the ray for this pixel.\n    // It starts from the near plane, going in the direction from the camera to the spot on the near plane.\n    vec3 rayLocalDir = vec3(uv * sin(c_camera_FOV), c_cameraDistance);\n    rayOrigin =\n        c_cameraPos +\n        rayLocalDir.x * c_cameraRight * c_cameraDistance +\n        rayLocalDir.y * c_cameraUp * c_cameraDistance +\n        rayLocalDir.z * c_cameraFwd * c_cameraDistance;\n    rayDirection = normalize(rayOrigin - c_cameraPos);      \n}\n\n//============================================================\nvec3 MaterialDiffuseColor (int materialIndex)\n{\n    if (materialIndex == 0)\n        return vec3(0.2, 0.4, 0.8);\n    else if (materialIndex == 1)\n        return vec3(1.0, 0.0, 0.0);\n    else if (materialIndex == 2)\n        return vec3(0.0, 1.0, 0.0);\n    else if (materialIndex == 3)\n        return vec3(0.9, 0.3, 0.0);    \n    else if (materialIndex == 4)\n        return vec3(0.0, 0.0, 1.0);     \n    else if (materialIndex == 5)\n        return vec3(0.1, 0.1, 0.1);        \n    else\n        return vec3(1.0);\n}\n\n//============================================================\nfloat MaterialSpecularPower (int materialIndex)\n{\n    if (materialIndex == 3)\n        return 80.0;\n    else if (materialIndex == 5)\n        return 100.0;\n    else\n    \treturn 10.0;\n}\n\n//============================================================\n// SHARED CODE END\n//============================================================\n\n\n//============================================================\n// save/load code from IQ's shader: https://www.shadertoy.com/view/MddGzf\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n//============================================================\nvec4 EncodeData (in vec3 normal, vec3 diffuse, int materialIndex, float hitDist, vec2 uv)\n{   \n    #if SHADER_INDEX == 0\n    \tfloat R = floor(diffuse.x * 255.0);\n    \tfloat G = floor(diffuse.y * 255.0);\n    \tfloat B = floor(diffuse.z * 255.0);\n    \n    \treturn vec4\n\t\t(\n        \tnormal.x,\n        \tnormal.y,\n        \tR*256.0 + G,\n        \tB\n\t\t);\n    #else\n    \treturn vec4\n        (\n            hitDist,\n            float(materialIndex),\n            uv.x,\n            uv.y\n        );\n    #endif\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear\n// returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in mat4 boxTransform, in mat4 inverseBoxTransform, in vec3 boxHalfSizes, out vec2 uv ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (boxTransform*vec4(rayDirection,0.0)).xyz;\n\tvec3 roo = (boxTransform*vec4(rayOrigin,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*boxHalfSizes;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\tvec3 normal = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n\t// texture coordinates \n\tvec3 uaxis = vec3(1.0,0.0,0.0);\n\tvec3 vaxis = vec3(0.0,1.0,0.0);\n\t\n\tif (abs(normal.x) > 0.9)\n\t{\n\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\tvaxis = vec3(0.0,0.0,1.0);\n\t}\n\telse if (abs(normal.y) > 0.9)\n\t{\n\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\tvaxis = vec3(0.0,0.0,1.0);\t\t\n\t}\n    \n    vec3 relPoint = roo + rdd * timeNear;\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis) * 0.25,\n\t\tdot(relPoint, vaxis) * 0.25\n\t);    \n\n    // convert to ray space\n\t\n\tnormal = (inverseBoxTransform * vec4(normal,0.0)).xyz;\n\n\treturn vec4( timeNear, normal );\n}\n\n\n//============================================================\n// matrix functions also from https://www.shadertoy.com/view/ld23DV\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n/*\nmat4 inverse( in mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}\n*/\n\n//============================================================\n// returns t and normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere, out vec2 uv)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    // NOTE: this will report a miss if ray starts inside the sphere.\n\tfloat collisionTime = -b - sqrt(discr);\n    \n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz);\n    \n    // texture coordinates are just the angular part of spherical coordiantes of normal\n    uv = vec2\n\t(\n\t\tatan(normal.z, normal.x),\n\t\tacos(normal.y)\n\t);\n    \n    return vec4 (collisionTime, normal);\n}\n\n//============================================================\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    // set up our default ray hit info\n    int hitMaterial = 0;    \n\tvec4 hitInfo = vec4(1000.0, -c_cameraFwd);\n    vec2 hitInfoUV = vec2(0.0);\n    \n    // load, initialize and handle state\n    vec4 state = loadValue(txState);\n    if (iFrame == 0)\n        state = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    if (iMouse.z > 0.0)\n    {\n        float aspectRatio = iResolution.x / iResolution.y;\n        vec2 uv = (iMouse.zw / iResolution.xy);\n        uv.x *= aspectRatio;\n        uv.y = 1.0 - uv.y;\n\n        vec2 buttonClickRelative = mod(uv, c_buttonSize+c_buttonPadding);\n        vec2 buttonIndex = floor(uv / (c_buttonSize+c_buttonPadding));\n\n        if (buttonClickRelative.x > c_buttonPadding && buttonClickRelative.y > c_buttonPadding)\n        {\n            if (buttonIndex.y == 0.0 && buttonIndex.x >= 0.0 && buttonIndex.x <= 4.0)\n        \t\tstate.x = buttonIndex.x;\n            else if (buttonIndex.y == 1.0 && buttonIndex.x >= 0.0 && buttonIndex.x <= 2.0)\n                state.y = buttonIndex.x;\n            else if (buttonIndex.y == 2.0 && buttonIndex.x >= 0.0 && buttonIndex.x <= 1.0)\n                state.z = buttonIndex.x;\n        }\n    }\n    \n    int sizeMode = int(state.x);\n    int interpolationMode = int(state.y);\n    \n    // adjust uv based on size mode\n    vec2 adjustedFragCoord = fragCoord;\n    if (sizeMode == 1 || sizeMode == 3)\n    {\n        adjustedFragCoord.x *= 2.0;\n        if (adjustedFragCoord.x > iResolution.x)\n        {\n            fragColor = EncodeData(hitInfo.yzw, MaterialDiffuseColor(hitMaterial), hitMaterial, hitInfo.x, hitInfoUV);\n\t\t\treturn;\n        }\n    }\n    \n    if (sizeMode == 2 || sizeMode == 3)\n    {\n        adjustedFragCoord.y *= 2.0;\n        if (adjustedFragCoord.y > iResolution.y)\n        {\n            fragColor = EncodeData(hitInfo.yzw, MaterialDiffuseColor(hitMaterial), hitMaterial, hitInfo.x, hitInfoUV);\n\t\t\treturn;\n        }       \n    }\n    \n    if (sizeMode == 4)\n    {\n        adjustedFragCoord.x *= 4.0;\n        if (adjustedFragCoord.x > iResolution.x)\n        {\n            fragColor = EncodeData(hitInfo.yzw, MaterialDiffuseColor(hitMaterial), hitMaterial, hitInfo.x, hitInfoUV);\n\t\t\treturn;\n        }   \n        adjustedFragCoord.y *= 4.0;\n        if (adjustedFragCoord.y > iResolution.y)\n        {\n            fragColor = EncodeData(hitInfo.yzw, MaterialDiffuseColor(hitMaterial), hitMaterial, hitInfo.x, hitInfoUV);\n\t\t\treturn;\n        }        \n    }  \n\n    // get the ray info\n    vec3 rayOrigin;\n    vec3 rayDirection;\n    GetRayInfo(adjustedFragCoord, rayOrigin, rayDirection);\n\n    float time = iTime;\n    \n    // raytrace a box\n    mat4 rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), time );\n    mat4 tra = translate( 0.0, 0.0, 5.0 );\n    mat4 txi = tra * rot; \n    mat4 txx = inverse( txi );    \n\tvec2 uv;\n    vec4 info = RayIntersectBox(rayOrigin, rayDirection, txx, txi, vec3(0.25), uv);\n    if (info.x > 0.0 && info.x < hitInfo.x) {\n        hitMaterial = 1;\n        hitInfo = info;\n        hitInfoUV = uv;\n    }\n    \n    // raytrace another box\n    rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), 0.5 );\n    tra = translate( -2.0, 0.0, 8.0 );\n    txi = tra * rot; \n    txx = inverse( txi );    \n    info = RayIntersectBox(rayOrigin, rayDirection, txx, txi, vec3(2.0, 1.75, 0.25), uv);\n    if (info.x > 0.0 && info.x < hitInfo.x) {\n        hitMaterial = 5;\n        hitInfo = info;\n        hitInfoUV = uv;\n    }    \n\n    // raytrace a sphere\n    info = RayIntersectSphere(rayOrigin, rayDirection, vec4(sin(time)*0.5-1.5, 0.0, 5.0, 0.25), uv);\n    if (info.x > 0.0 && info.x < hitInfo.x) {\n        hitMaterial = 2;\n        hitInfo = info;\n        hitInfoUV = uv;\n    }\n\n    // raytrace another sphere\n    info = RayIntersectSphere(rayOrigin, rayDirection, vec4(1.0, sin(time), 5.0, 0.25), uv);\n    if (info.x > 0.0 && info.x < hitInfo.x) {\n        hitMaterial = 3;\n        hitInfo = info;\n        hitInfoUV = uv;\n    } \n    \n    // raytrace another sphere, showing where the light source is\n    vec3 c_pointLightPos = vec3(cos(iTime), sin(iTime / 0.25) * 0.25, sin(iTime) + 5.5);\n    info = RayIntersectSphere(rayOrigin, rayDirection, vec4(c_pointLightPos, 0.0625), uv);\n    if (info.x > 0.0 && info.x < hitInfo.x) {\n        hitMaterial = 4;\n        hitInfo = info;\n        hitInfoUV = uv;\n    }     \n    \n\tfragColor = EncodeData(hitInfo.yzw, MaterialDiffuseColor(hitMaterial), hitMaterial, hitInfo.x, hitInfoUV);\n    storeValue(txState, state, fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define SHADER_INDEX 1\n\n/*============================================================\n\nThis shader does the ray vs world tests and writes information\nabout the surface it finds for a ray in the output pixel.\n\nFormat:\n\n--Shader Index 0--\nR, G = X,Y part of normal.  Z part of normal calculated on demand.\nB, A = R,G,B stored in 8 bits each, leaving 8 bits unused. (aprox)\n\n--Shader Index 1--\nR = distance down ray to hit (depth essentially)\nG = material index (could do in 1 byte if that'd be helpful)\nB,A = texture coordinates u,v\n\n============================================================*/\n\n//============================================================\n// SHARED CODE BEGIN\n//============================================================\n\nconst float c_pi = 3.14159265359;\n\n// Distance from the camera to the near plane\nconst float c_cameraDistance = 2.0; \n\n// The vertical field of view of the camera in radians\n// Horizontal is defined by accounting for aspect ratio\nconst float c_camera_FOV = c_pi / 2.0;  \n\n// camera orientation\nvec3 c_cameraPos   = vec3(0.0);\nvec3 c_cameraRight = vec3(1.0, 0.0, 0.0);    \nvec3 c_cameraUp    = vec3(0.0, 1.0, 0.0);\nvec3 c_cameraFwd   = vec3(0.0, 0.0, 1.0);    \n\nconst float c_buttonSize = 0.075;      // size on x and y\nconst float c_buttonPadding = 0.025; // between buttons\n\nconst vec2 txState = vec2(0.0,0.0);\n// x = size mode\n// y = interpolation mode\n// z = interpolate image instead of data (1.0)\n// w = unused\n\n//============================================================\nvoid GetRayInfo (in vec2 adjustedFragCoord, out vec3 rayOrigin, out vec3 rayDirection)\n{\n    // calculate a uv of the pixel such that:\n    // * the top of the screen is y = 0.5, \n    // * the bottom of the screen in y = -0.5\n    // * the left and right sides of the screen are extended based on aspect ratio.\n    // * left is -x, right is +x\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = (adjustedFragCoord / iResolution.xy) - vec2(0.5);\n    uv.x *= aspectRatio;\n    \n    // set up the ray for this pixel.\n    // It starts from the near plane, going in the direction from the camera to the spot on the near plane.\n    vec3 rayLocalDir = vec3(uv * sin(c_camera_FOV), c_cameraDistance);\n    rayOrigin =\n        c_cameraPos +\n        rayLocalDir.x * c_cameraRight * c_cameraDistance +\n        rayLocalDir.y * c_cameraUp * c_cameraDistance +\n        rayLocalDir.z * c_cameraFwd * c_cameraDistance;\n    rayDirection = normalize(rayOrigin - c_cameraPos);      \n}\n\n//============================================================\nvec3 MaterialDiffuseColor (int materialIndex)\n{\n    if (materialIndex == 0)\n        return vec3(0.2, 0.4, 0.8);\n    else if (materialIndex == 1)\n        return vec3(1.0, 0.0, 0.0);\n    else if (materialIndex == 2)\n        return vec3(0.0, 1.0, 0.0);\n    else if (materialIndex == 3)\n        return vec3(0.9, 0.3, 0.0);    \n    else if (materialIndex == 4)\n        return vec3(0.0, 0.0, 1.0);     \n    else if (materialIndex == 5)\n        return vec3(0.1, 0.1, 0.1);        \n    else\n        return vec3(1.0);\n}\n\n//============================================================\nfloat MaterialSpecularPower (int materialIndex)\n{\n    if (materialIndex == 3)\n        return 80.0;\n    else if (materialIndex == 5)\n        return 100.0;\n    else\n    \treturn 10.0;\n}\n\n//============================================================\n// SHARED CODE END\n//============================================================\n\n\n//============================================================\n// save/load code from IQ's shader: https://www.shadertoy.com/view/MddGzf\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n//============================================================\nvec4 EncodeData (in vec3 normal, vec3 diffuse, int materialIndex, float hitDist, vec2 uv)\n{   \n    #if SHADER_INDEX == 0\n    \tfloat R = floor(diffuse.x * 255.0);\n    \tfloat G = floor(diffuse.y * 255.0);\n    \tfloat B = floor(diffuse.z * 255.0);\n    \n    \treturn vec4\n\t\t(\n        \tnormal.x,\n        \tnormal.y,\n        \tR*256.0 + G,\n        \tB\n\t\t);\n    #else\n    \treturn vec4\n        (\n            hitDist,\n            float(materialIndex),\n            uv.x,\n            uv.y\n        );\n    #endif\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear\n// returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in mat4 boxTransform, in mat4 inverseBoxTransform, in vec3 boxHalfSizes, out vec2 uv ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (boxTransform*vec4(rayDirection,0.0)).xyz;\n\tvec3 roo = (boxTransform*vec4(rayOrigin,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*boxHalfSizes;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\tvec3 normal = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n\t// texture coordinates \n\tvec3 uaxis = vec3(1.0,0.0,0.0);\n\tvec3 vaxis = vec3(0.0,1.0,0.0);\n\t\n\tif (abs(normal.x) > 0.9)\n\t{\n\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\tvaxis = vec3(0.0,0.0,1.0);\n\t}\n\telse if (abs(normal.y) > 0.9)\n\t{\n\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\tvaxis = vec3(0.0,0.0,1.0);\t\t\n\t}\n    \n    vec3 relPoint = roo + rdd * timeNear;\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis) * 0.25,\n\t\tdot(relPoint, vaxis) * 0.25\n\t);    \n\n    // convert to ray space\n\t\n\tnormal = (inverseBoxTransform * vec4(normal,0.0)).xyz;\n\n\treturn vec4( timeNear, normal );\n}\n\n\n//============================================================\n// matrix functions also from https://www.shadertoy.com/view/ld23DV\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n/*\nmat4 inverse( in mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}\n*/\n\n//============================================================\n// returns t and normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere, out vec2 uv)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    // NOTE: this will report a miss if ray starts inside the sphere.\n\tfloat collisionTime = -b - sqrt(discr);\n    \n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz);\n    \n    // texture coordinates are just the angular part of spherical coordiantes of normal\n    uv = vec2\n\t(\n\t\tatan(normal.z, normal.x),\n\t\tacos(normal.y)\n\t);\n    \n    return vec4 (collisionTime, normal);\n}\n\n//============================================================\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    // set up our default ray hit info\n    int hitMaterial = 0;    \n\tvec4 hitInfo = vec4(1000.0, -c_cameraFwd);\n    vec2 hitInfoUV = vec2(0.0);\n    \n    // load, initialize and handle state\n    vec4 state = loadValue(txState);\n    if (iFrame == 0)\n        state = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    if (iMouse.z > 0.0)\n    {\n        float aspectRatio = iResolution.x / iResolution.y;\n        vec2 uv = (iMouse.zw / iResolution.xy);\n        uv.x *= aspectRatio;\n        uv.y = 1.0 - uv.y;\n\n        vec2 buttonClickRelative = mod(uv, c_buttonSize+c_buttonPadding);\n        vec2 buttonIndex = floor(uv / (c_buttonSize+c_buttonPadding));\n\n        if (buttonClickRelative.x > c_buttonPadding && buttonClickRelative.y > c_buttonPadding)\n        {\n            if (buttonIndex.y == 0.0 && buttonIndex.x >= 0.0 && buttonIndex.x <= 4.0)\n        \t\tstate.x = buttonIndex.x;\n            else if (buttonIndex.y == 1.0 && buttonIndex.x >= 0.0 && buttonIndex.x <= 2.0)\n                state.y = buttonIndex.x;\n            else if (buttonIndex.y == 2.0 && buttonIndex.x >= 0.0 && buttonIndex.x <= 1.0)\n                state.z = buttonIndex.x;\n        }\n    }\n    \n    int sizeMode = int(state.x);\n    int interpolationMode = int(state.y);\n    \n    // adjust uv based on size mode\n    vec2 adjustedFragCoord = fragCoord;\n    if (sizeMode == 1 || sizeMode == 3)\n    {\n        adjustedFragCoord.x *= 2.0;\n        if (adjustedFragCoord.x > iResolution.x)\n        {\n            fragColor = EncodeData(hitInfo.yzw, MaterialDiffuseColor(hitMaterial), hitMaterial, hitInfo.x, hitInfoUV);\n\t\t\treturn;\n        }\n    }\n    \n    if (sizeMode == 2 || sizeMode == 3)\n    {\n        adjustedFragCoord.y *= 2.0;\n        if (adjustedFragCoord.y > iResolution.y)\n        {\n            fragColor = EncodeData(hitInfo.yzw, MaterialDiffuseColor(hitMaterial), hitMaterial, hitInfo.x, hitInfoUV);\n\t\t\treturn;\n        }       \n    }\n    \n    if (sizeMode == 4)\n    {\n        adjustedFragCoord.x *= 4.0;\n        if (adjustedFragCoord.x > iResolution.x)\n        {\n            fragColor = EncodeData(hitInfo.yzw, MaterialDiffuseColor(hitMaterial), hitMaterial, hitInfo.x, hitInfoUV);\n\t\t\treturn;\n        }   \n        adjustedFragCoord.y *= 4.0;\n        if (adjustedFragCoord.y > iResolution.y)\n        {\n            fragColor = EncodeData(hitInfo.yzw, MaterialDiffuseColor(hitMaterial), hitMaterial, hitInfo.x, hitInfoUV);\n\t\t\treturn;\n        }        \n    }  \n\n    // get the ray info\n    vec3 rayOrigin;\n    vec3 rayDirection;\n    GetRayInfo(adjustedFragCoord, rayOrigin, rayDirection);\n\n    float time = iTime;\n    \n    // raytrace a box\n    mat4 rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), time );\n    mat4 tra = translate( 0.0, 0.0, 5.0 );\n    mat4 txi = tra * rot; \n    mat4 txx = inverse( txi );    \n\tvec2 uv;\n    vec4 info = RayIntersectBox(rayOrigin, rayDirection, txx, txi, vec3(0.25), uv);\n    if (info.x > 0.0 && info.x < hitInfo.x) {\n        hitMaterial = 1;\n        hitInfo = info;\n        hitInfoUV = uv;\n    }\n    \n    // raytrace another box\n    rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), 0.5 );\n    tra = translate( -2.0, 0.0, 8.0 );\n    txi = tra * rot; \n    txx = inverse( txi );    \n    info = RayIntersectBox(rayOrigin, rayDirection, txx, txi, vec3(2.0, 1.75, 0.25), uv);\n    if (info.x > 0.0 && info.x < hitInfo.x) {\n        hitMaterial = 5;\n        hitInfo = info;\n        hitInfoUV = uv;\n    }    \n\n    // raytrace a sphere\n    info = RayIntersectSphere(rayOrigin, rayDirection, vec4(sin(time)*0.5-1.5, 0.0, 5.0, 0.25), uv);\n    if (info.x > 0.0 && info.x < hitInfo.x) {\n        hitMaterial = 2;\n        hitInfo = info;\n        hitInfoUV = uv;\n    }\n\n    // raytrace another sphere\n    info = RayIntersectSphere(rayOrigin, rayDirection, vec4(1.0, sin(time), 5.0, 0.25), uv);\n    if (info.x > 0.0 && info.x < hitInfo.x) {\n        hitMaterial = 3;\n        hitInfo = info;\n        hitInfoUV = uv;\n    } \n    \n    // raytrace another sphere, showing where the light source is\n    vec3 c_pointLightPos = vec3(cos(iTime), sin(iTime / 0.25) * 0.25, sin(iTime) + 5.5);\n    info = RayIntersectSphere(rayOrigin, rayDirection, vec4(c_pointLightPos, 0.0625), uv);\n    if (info.x > 0.0 && info.x < hitInfo.x) {\n        hitMaterial = 4;\n        hitInfo = info;\n        hitInfoUV = uv;\n    }     \n    \n\tfragColor = EncodeData(hitInfo.yzw, MaterialDiffuseColor(hitMaterial), hitMaterial, hitInfo.x, hitInfoUV);\n    storeValue(txState, state, fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*============================================================\n\nThis shader reads in the ray vs world info and shades the pixel\nbased on that information.  This shader does g-buffer upsizing\nif needed.\n\n============================================================*/\n\n#define DEBUG_SHOW_NORMALS 0\n#define DEBUG_SHOW_DISTANCE 0\n\nconst float c_gamma = 2.2;\n\n#define AA_AMOUNT 7.0 / iResolution.x\n\n//============================================================\n// SHARED CODE BEGIN\n//============================================================\n\nconst float c_pi = 3.14159265359;\n\n// Distance from the camera to the near plane\nconst float c_cameraDistance = 2.0; \n\n// The vertical field of view of the camera in radians\n// Horizontal is defined by accounting for aspect ratio\nconst float c_camera_FOV = c_pi / 2.0;  \n\n// camera orientation\nvec3 c_cameraPos   = vec3(0.0);\nvec3 c_cameraRight = vec3(1.0, 0.0, 0.0);    \nvec3 c_cameraUp    = vec3(0.0, 1.0, 0.0);\nvec3 c_cameraFwd   = vec3(0.0, 0.0, 1.0);    \n\nconst float c_buttonSize = 0.075;      // size on x and y\nconst float c_buttonPadding = 0.025; // between buttons\n\nconst vec2 txState = vec2(0.0,0.0);\n// x = size mode\n// y = interpolation mode\n// z = interpolate image instead of data (1.0)\n// w = unused\n\n//============================================================\nvoid GetRayInfo (in vec2 adjustedFragCoord, out vec3 rayOrigin, out vec3 rayDirection)\n{\n    // calculate a uv of the pixel such that:\n    // * the top of the screen is y = 0.5, \n    // * the bottom of the screen in y = -0.5\n    // * the left and right sides of the screen are extended based on aspect ratio.\n    // * left is -x, right is +x\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = (adjustedFragCoord / iResolution.xy) - vec2(0.5);\n    uv.x *= aspectRatio;\n    \n    // set up the ray for this pixel.\n    // It starts from the near plane, going in the direction from the camera to the spot on the near plane.\n    vec3 rayLocalDir = vec3(uv * sin(c_camera_FOV), c_cameraDistance);\n    rayOrigin =\n        c_cameraPos +\n        rayLocalDir.x * c_cameraRight * c_cameraDistance +\n        rayLocalDir.y * c_cameraUp * c_cameraDistance +\n        rayLocalDir.z * c_cameraFwd * c_cameraDistance;\n    rayDirection = normalize(rayOrigin - c_cameraPos);      \n}\n\n//============================================================\nvec3 MaterialDiffuseColor (int materialIndex)\n{\n    if (materialIndex == 0)\n        return vec3(0.2, 0.4, 0.8);\n    else if (materialIndex == 1)\n        return vec3(1.0, 0.0, 0.0);\n    else if (materialIndex == 2)\n        return vec3(0.0, 1.0, 0.0);\n    else if (materialIndex == 3)\n        return vec3(0.9, 0.3, 0.0);    \n    else if (materialIndex == 4)\n        return vec3(0.0, 0.0, 1.0);     \n    else if (materialIndex == 5)\n        return vec3(0.1, 0.1, 0.1);        \n    else\n        return vec3(1.0);\n}\n\n//============================================================\nfloat MaterialSpecularPower (int materialIndex)\n{\n    if (materialIndex == 3)\n        return 80.0;\n    else if (materialIndex == 5)\n        return 100.0;\n    else\n    \treturn 10.0;\n}\n\n//============================================================\n// SHARED CODE END\n//============================================================\n\n//============================================================\n// save/load code from IQ's shader: https://www.shadertoy.com/view/MddGzf\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\n//============================================================\nvoid DecodeData (in vec4 encodedDataA, in vec4 encodedDataB, out vec3 normal, out vec3 color, out int materialIndex, out float depth, out vec2 uv)\n{      \n    normal.xy = encodedDataA.xy;\n    normal.z = -sqrt(1.0 - (normal.x*normal.x + normal.y*normal.y));\n    \n    color.x = floor(encodedDataA.z / 256.0) / 255.0;\n    color.y = mod(encodedDataA.z, 256.0) / 255.0;\n    color.z = encodedDataA.w / 255.0;\n    \n    depth = encodedDataB.x;\n    materialIndex = int(encodedDataB.y);\n    uv = encodedDataB.zw;\n}\n\n//=======================================================================================\nfloat CubicHermite (float A, float B, float C, float D, float t)\n{\n\tfloat t2 = t*t;\n    float t3 = t*t*t;\n    float a = -A/2.0 + (3.0*B)/2.0 - (3.0*C)/2.0 + D/2.0;\n    float b = A - (5.0*B)/2.0 + 2.0*C - D / 2.0;\n    float c = -A/2.0 + C/2.0;\n   \tfloat d = B;\n    \n    return a*t3 + b*t2 + c*t + d;\n}\n\n//=======================================================================================\nvec2 CubicHermite (vec2 A, vec2 B, vec2 C, vec2 D, float t)\n{\n\tfloat t2 = t*t;\n    float t3 = t*t*t;\n    vec2 a = -A/2.0 + (3.0*B)/2.0 - (3.0*C)/2.0 + D/2.0;\n    vec2 b = A - (5.0*B)/2.0 + 2.0*C - D / 2.0;\n    vec2 c = -A/2.0 + C/2.0;\n   \tvec2 d = B;\n    \n    return a*t3 + b*t2 + c*t + d;\n}\n\n//=======================================================================================\nvec3 CubicHermite (vec3 A, vec3 B, vec3 C, vec3 D, float t)\n{\n\tfloat t2 = t*t;\n    float t3 = t*t*t;\n    vec3 a = -A/2.0 + (3.0*B)/2.0 - (3.0*C)/2.0 + D/2.0;\n    vec3 b = A - (5.0*B)/2.0 + 2.0*C - D / 2.0;\n    vec3 c = -A/2.0 + C/2.0;\n   \tvec3 d = B;\n    \n    return a*t3 + b*t2 + c*t + d;\n}\n\n//============================================================\nvoid GetDataBilinear (in vec2 adjustedFragCoord, out vec3 normal, out vec3 materialDiffuse, out int materialIndex, out float hitDepth, out vec2 uv)\n{   \n    adjustedFragCoord-= 0.5;\n    vec2 fragFract = fract(adjustedFragCoord);    \n    \n    // get the four data points from each texture\n    vec2 uvMin = adjustedFragCoord / iResolution.xy;\n    vec2 uvMax = (adjustedFragCoord + vec2(1.0)) / iResolution.xy;\n    \n    vec4 dataA00 = texture(iChannel0, uvMin);\n    vec4 dataA10 = texture(iChannel0, vec2(uvMax.x, uvMin.y));\n    vec4 dataA01 = texture(iChannel0, vec2(uvMin.x, uvMax.y));\n    vec4 dataA11 = texture(iChannel0, uvMax);\n    vec4 dataB00 = texture(iChannel1, uvMin);\n    vec4 dataB10 = texture(iChannel1, vec2(uvMax.x, uvMin.y));\n    vec4 dataB01 = texture(iChannel1, vec2(uvMin.x, uvMax.y));\n    vec4 dataB11 = texture(iChannel1, uvMax);    \n    \n    // decode the data\n    vec3 normal00, normal10, normal01, normal11;\n    vec3 materialDiffuse00, materialDiffuse10, materialDiffuse01, materialDiffuse11;\n    float materialIndex00, materialIndex10, materialIndex01, materialIndex11;\n    float hitDepth00, hitDepth01, hitDepth10, hitDepth11;\n    vec2 uv00, uv01, uv10, uv11;\n    DecodeData(dataA00, dataB00, normal00, materialDiffuse00, materialIndex, hitDepth00, uv00); materialIndex00 = float(materialIndex);\n    DecodeData(dataA10, dataB10, normal10, materialDiffuse10, materialIndex, hitDepth10, uv10); materialIndex10 = float(materialIndex);\n    DecodeData(dataA01, dataB01, normal01, materialDiffuse01, materialIndex, hitDepth01, uv01); materialIndex01 = float(materialIndex);\n    DecodeData(dataA11, dataB11, normal11, materialDiffuse11, materialIndex, hitDepth11, uv11); materialIndex11 = float(materialIndex);\n    \n    // bilinear interpolate the data\n    \n    // use nlerp on the normal\n    vec3 normalx0 = mix(normal00, normal10, fragFract.x);\n    vec3 normalx1 = mix(normal01, normal11, fragFract.x);\n    normal = normalize(mix(normalx0, normalx1, fragFract.y));\n    \n    vec3 materialDiffusex0 = mix(materialDiffuse00, materialDiffuse10, fragFract.x);\n    vec3 materialDiffusex1 = mix(materialDiffuse01, materialDiffuse11, fragFract.x);\n    materialDiffuse = mix(materialDiffusex0, materialDiffusex1, fragFract.y);\n\n    /*\n    float materialIndexx0 = mix(materialIndex00, materialIndex10, fragFract.x);\n    float materialIndexx1 = mix(materialIndex01, materialIndex11, fragFract.x);\n    materialIndex = int(mix(materialIndexx0, materialIndexx1, fragFract.y) + 0.5);    \n\t*/\n    \n    // use nearest neighbor for material index.\n    if (fragFract.x >= 0.5)\n    {\n        // it's between 10 and 11\n        \n        if (fragFract.y >= 0.5)\n            materialIndex = int(materialIndex11);\n        else\n    \t\tmaterialIndex = int(materialIndex10);\n    }\n    else\n    {\n        // it's between 00 and 01\n        \n        if (fragFract.y >= 0.5)\n            materialIndex = int(materialIndex01);\n        else\n    \t\tmaterialIndex = int(materialIndex00);        \n    }\n    \n    float hitDepthx0 = mix(hitDepth00, hitDepth10, fragFract.x);\n    float hitDepthx1 = mix(hitDepth01, hitDepth11, fragFract.x);\n    hitDepth = mix(hitDepthx0, hitDepthx1, fragFract.y);\n    \n    vec2 uvx0 = mix(uv00, uv10, fragFract.x);\n    vec2 uvx1 = mix(uv01, uv11, fragFract.x);\n    uv = mix(uvx0, uvx1, fragFract.y);    \n}\n\n//============================================================\nvoid GetDataBicubic (in vec2 adjustedFragCoord, out vec3 normal, out vec3 materialDiffuse, out int materialIndex, out float hitDepth, out vec2 uv)\n{\n\n    adjustedFragCoord-= 0.5;\n    vec2 fragFract = fract(adjustedFragCoord);\n    \n    // get the 16 data points from each texture\n    vec4 dataANN = texture(iChannel0, (adjustedFragCoord + vec2(-1.0, -1.0)) / iResolution.xy);\n    vec4 dataA0N = texture(iChannel0, (adjustedFragCoord + vec2( 0.0, -1.0)) / iResolution.xy);\n    vec4 dataA1N = texture(iChannel0, (adjustedFragCoord + vec2( 1.0, -1.0)) / iResolution.xy);\n    vec4 dataA2N = texture(iChannel0, (adjustedFragCoord + vec2( 2.0, -1.0)) / iResolution.xy);\n    \n    vec4 dataAN0 = texture(iChannel0, (adjustedFragCoord + vec2(-1.0,  0.0)) / iResolution.xy);\n    vec4 dataA00 = texture(iChannel0, (adjustedFragCoord + vec2( 0.0,  0.0)) / iResolution.xy);\n    vec4 dataA10 = texture(iChannel0, (adjustedFragCoord + vec2( 1.0,  0.0)) / iResolution.xy);\n    vec4 dataA20 = texture(iChannel0, (adjustedFragCoord + vec2( 2.0,  0.0)) / iResolution.xy);    \n    \n    vec4 dataAN1 = texture(iChannel0, (adjustedFragCoord + vec2(-1.0,  1.0)) / iResolution.xy);\n    vec4 dataA01 = texture(iChannel0, (adjustedFragCoord + vec2( 0.0,  1.0)) / iResolution.xy);\n    vec4 dataA11 = texture(iChannel0, (adjustedFragCoord + vec2( 1.0,  1.0)) / iResolution.xy);\n    vec4 dataA21 = texture(iChannel0, (adjustedFragCoord + vec2( 2.0,  1.0)) / iResolution.xy);     \n    \n    vec4 dataAN2 = texture(iChannel0, (adjustedFragCoord + vec2(-1.0,  2.0)) / iResolution.xy);\n    vec4 dataA02 = texture(iChannel0, (adjustedFragCoord + vec2( 0.0,  2.0)) / iResolution.xy);\n    vec4 dataA12 = texture(iChannel0, (adjustedFragCoord + vec2( 1.0,  2.0)) / iResolution.xy);\n    vec4 dataA22 = texture(iChannel0, (adjustedFragCoord + vec2( 2.0,  2.0)) / iResolution.xy);   \n    \n    vec4 dataBNN = texture(iChannel1, (adjustedFragCoord + vec2(-1.0, -1.0)) / iResolution.xy);\n    vec4 dataB0N = texture(iChannel1, (adjustedFragCoord + vec2( 0.0, -1.0)) / iResolution.xy);\n    vec4 dataB1N = texture(iChannel1, (adjustedFragCoord + vec2( 1.0, -1.0)) / iResolution.xy);\n    vec4 dataB2N = texture(iChannel1, (adjustedFragCoord + vec2( 2.0, -1.0)) / iResolution.xy);\n    \n    vec4 dataBN0 = texture(iChannel1, (adjustedFragCoord + vec2(-1.0,  0.0)) / iResolution.xy);\n    vec4 dataB00 = texture(iChannel1, (adjustedFragCoord + vec2( 0.0,  0.0)) / iResolution.xy);\n    vec4 dataB10 = texture(iChannel1, (adjustedFragCoord + vec2( 1.0,  0.0)) / iResolution.xy);\n    vec4 dataB20 = texture(iChannel1, (adjustedFragCoord + vec2( 2.0,  0.0)) / iResolution.xy);    \n    \n    vec4 dataBN1 = texture(iChannel1, (adjustedFragCoord + vec2(-1.0,  1.0)) / iResolution.xy);\n    vec4 dataB01 = texture(iChannel1, (adjustedFragCoord + vec2( 0.0,  1.0)) / iResolution.xy);\n    vec4 dataB11 = texture(iChannel1, (adjustedFragCoord + vec2( 1.0,  1.0)) / iResolution.xy);\n    vec4 dataB21 = texture(iChannel1, (adjustedFragCoord + vec2( 2.0,  1.0)) / iResolution.xy);     \n    \n    vec4 dataBN2 = texture(iChannel1, (adjustedFragCoord + vec2(-1.0,  2.0)) / iResolution.xy);\n    vec4 dataB02 = texture(iChannel1, (adjustedFragCoord + vec2( 0.0,  2.0)) / iResolution.xy);\n    vec4 dataB12 = texture(iChannel1, (adjustedFragCoord + vec2( 1.0,  2.0)) / iResolution.xy);\n    vec4 dataB22 = texture(iChannel1, (adjustedFragCoord + vec2( 2.0,  2.0)) / iResolution.xy);       \n    \n    // decode the data\n    vec3 normalNN, normal0N, normal1N, normal2N;\n    vec3 normalN0, normal00, normal10, normal20;\n    vec3 normalN1, normal01, normal11, normal21;\n    vec3 normalN2, normal02, normal12, normal22;\n    vec3 materialDiffuseNN, materialDiffuse0N, materialDiffuse1N, materialDiffuse2N;\n    vec3 materialDiffuseN0, materialDiffuse00, materialDiffuse10, materialDiffuse20;\n    vec3 materialDiffuseN1, materialDiffuse01, materialDiffuse11, materialDiffuse21;\n    vec3 materialDiffuseN2, materialDiffuse02, materialDiffuse12, materialDiffuse22;\n    float hitDepthNN, hitDepth0N, hitDepth1N, hitDepth2N;\n    float hitDepthN0, hitDepth00, hitDepth10, hitDepth20;\n    float hitDepthN1, hitDepth01, hitDepth11, hitDepth21;\n    float hitDepthN2, hitDepth02, hitDepth12, hitDepth22;\n    float materialIndexNN, materialIndex0N, materialIndex1N, materialIndex2N;\n    float materialIndexN0, materialIndex00, materialIndex10, materialIndex20;\n    float materialIndexN1, materialIndex01, materialIndex11, materialIndex21;\n    float materialIndexN2, materialIndex02, materialIndex12, materialIndex22;    \n    vec2 uvNN, uv0N, uv1N, uv2N;\n    vec2 uvN0, uv00, uv10, uv20;\n    vec2 uvN1, uv01, uv11, uv21;\n    vec2 uvN2, uv02, uv12, uv22;\n    DecodeData(dataANN, dataBNN, normalNN, materialDiffuseNN, materialIndex, hitDepthNN, uvNN); materialIndexNN = float(materialIndex);\n    DecodeData(dataA0N, dataB0N, normal0N, materialDiffuse0N, materialIndex, hitDepth0N, uv0N); materialIndex0N = float(materialIndex);\n    DecodeData(dataA1N, dataB1N, normal1N, materialDiffuse1N, materialIndex, hitDepth1N, uv1N); materialIndex1N = float(materialIndex);\n    DecodeData(dataA2N, dataB2N, normal2N, materialDiffuse2N, materialIndex, hitDepth2N, uv2N); materialIndex2N = float(materialIndex);\n    \n    DecodeData(dataAN0, dataBN0, normalN0, materialDiffuseN0, materialIndex, hitDepthN0, uvN0); materialIndexN0 = float(materialIndex);\n    DecodeData(dataA00, dataB00, normal00, materialDiffuse00, materialIndex, hitDepth00, uv00); materialIndex00 = float(materialIndex);\n    DecodeData(dataA10, dataB10, normal10, materialDiffuse10, materialIndex, hitDepth10, uv10); materialIndex10 = float(materialIndex);\n    DecodeData(dataA20, dataB20, normal20, materialDiffuse20, materialIndex, hitDepth20, uv20); materialIndex20 = float(materialIndex);\n    \n    DecodeData(dataAN1, dataBN1, normalN1, materialDiffuseN1, materialIndex, hitDepthN1, uvN1); materialIndexN1 = float(materialIndex);\n    DecodeData(dataA01, dataB01, normal01, materialDiffuse01, materialIndex, hitDepth01, uv01); materialIndex01 = float(materialIndex);\n    DecodeData(dataA11, dataB11, normal11, materialDiffuse11, materialIndex, hitDepth11, uv11); materialIndex11 = float(materialIndex);\n    DecodeData(dataA21, dataB21, normal21, materialDiffuse21, materialIndex, hitDepth21, uv21); materialIndex21 = float(materialIndex);\n    \n    DecodeData(dataAN2, dataBN2, normalN2, materialDiffuseN2, materialIndex, hitDepthN2, uvN2); materialIndexN2 = float(materialIndex);\n    DecodeData(dataA02, dataB02, normal02, materialDiffuse02, materialIndex, hitDepth02, uv02); materialIndex02 = float(materialIndex);\n    DecodeData(dataA12, dataB12, normal12, materialDiffuse12, materialIndex, hitDepth12, uv12); materialIndex12 = float(materialIndex);\n    DecodeData(dataA22, dataB22, normal22, materialDiffuse22, materialIndex, hitDepth22, uv22); materialIndex22 = float(materialIndex);\n    \n    // bicubic interpolate the data\n    \n    // use a bicubic version of nlerp on the normal\n    vec3 normalxN = CubicHermite(normalNN, normal0N, normal1N, normal2N, fragFract.x);\n    vec3 normalx0 = CubicHermite(normalN0, normal00, normal10, normal20, fragFract.x);\n    vec3 normalx1 = CubicHermite(normalN1, normal01, normal11, normal21, fragFract.x);\n    vec3 normalx2 = CubicHermite(normalN2, normal02, normal12, normal22, fragFract.x);\n    normal = normalize(CubicHermite(normalxN, normalx0, normalx1, normalx2, fragFract.y));\n    \n    vec3 materialDiffusexN = CubicHermite(materialDiffuseNN, materialDiffuse0N, materialDiffuse1N, materialDiffuse2N, fragFract.x);\n    vec3 materialDiffusex0 = CubicHermite(materialDiffuseN0, materialDiffuse00, materialDiffuse10, materialDiffuse20, fragFract.x);\n    vec3 materialDiffusex1 = CubicHermite(materialDiffuseN1, materialDiffuse01, materialDiffuse11, materialDiffuse21, fragFract.x);\n    vec3 materialDiffusex2 = CubicHermite(materialDiffuseN2, materialDiffuse02, materialDiffuse12, materialDiffuse22, fragFract.x);\n    materialDiffuse = CubicHermite(materialDiffusexN, materialDiffusex0, materialDiffusex1, materialDiffusex2, fragFract.y);\n    \n    /*\n    float materialIndexxN = CubicHermite(materialIndexNN, materialIndex0N, materialIndex1N, materialIndex2N, fragFract.x);\n    float materialIndexx0 = CubicHermite(materialIndexN0, materialIndex00, materialIndex10, materialIndex20, fragFract.x);\n    float materialIndexx1 = CubicHermite(materialIndexN1, materialIndex01, materialIndex11, materialIndex21, fragFract.x);\n    float materialIndexx2 = CubicHermite(materialIndexN2, materialIndex02, materialIndex12, materialIndex22, fragFract.x);\n    materialIndex = int(CubicHermite(materialIndexxN, materialIndexx0, materialIndexx1, materialIndexx2, fragFract.y) + 0.5);   \n\t*/\n    \n    // use nearest neighbor for material index.\n    if (fragFract.x >= 0.5)\n    {\n        // it's between 10 and 11\n        \n        if (fragFract.y >= 0.5)\n            materialIndex = int(materialIndex11);\n        else\n    \t\tmaterialIndex = int(materialIndex10);\n    }\n    else\n    {\n        // it's between 00 and 01\n        \n        if (fragFract.y >= 0.5)\n            materialIndex = int(materialIndex01);\n        else\n    \t\tmaterialIndex = int(materialIndex00);        \n    }    \n    \n    float hitDepthxN = CubicHermite(hitDepthNN, hitDepth0N, hitDepth1N, hitDepth2N, fragFract.x);\n    float hitDepthx0 = CubicHermite(hitDepthN0, hitDepth00, hitDepth10, hitDepth20, fragFract.x);\n    float hitDepthx1 = CubicHermite(hitDepthN1, hitDepth01, hitDepth11, hitDepth21, fragFract.x);\n    float hitDepthx2 = CubicHermite(hitDepthN2, hitDepth02, hitDepth12, hitDepth22, fragFract.x);\n    hitDepth = CubicHermite(hitDepthxN, hitDepthx0, hitDepthx1, hitDepthx2, fragFract.y);    \n    \n    vec2 uvxN = CubicHermite(uvNN, uv0N, uv1N, uv2N, fragFract.x);\n    vec2 uvx0 = CubicHermite(uvN0, uv00, uv10, uv20, fragFract.x);\n    vec2 uvx1 = CubicHermite(uvN1, uv01, uv11, uv21, fragFract.x);\n    vec2 uvx2 = CubicHermite(uvN2, uv02, uv12, uv22, fragFract.x);\n    uv = CubicHermite(uvxN, uvx0, uvx1, uvx2, fragFract.y);       \n}\n\n//============================================================\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get the state from the buffer\n    vec4 state = loadValue(txState);\n    int sizeMode = int(state.x);\n    int interpolationMode = int(state.y);\n    bool upsizeImage = state.z == 1.0;\n    \n    // adjust coordinates based on size mode if we are upsizing data, not the final image\n    vec2 adjustedFragCoord = fragCoord;\n    if (!upsizeImage) {\n        if (sizeMode == 1 || sizeMode == 3)\n            adjustedFragCoord.x /= 2.0;\n\n        if (sizeMode == 2 || sizeMode == 3)\n            adjustedFragCoord.y /= 2.0;\n\n        if (sizeMode == 4)\n            adjustedFragCoord /= 4.0;\n    }\n    else\n        interpolationMode = 0;\n    \n    // get the interpolated ray hit info from the texture\n    vec3 normal = vec3(0.0);\n    vec3 materialDiffuse = vec3(0.0);   \n    float hitDepth = 0.0;\n    int materialIndex = 0;\n    vec2 hituv = vec2(0.0);\n    if (interpolationMode == 0)\n    {\n        // get the data using nearest neighbor and decode it         \n        vec4 encodedDataA = texture(iChannel0, adjustedFragCoord / iResolution.xy);\n        vec4 encodedDataB = texture(iChannel1, adjustedFragCoord / iResolution.xy);\n        DecodeData(encodedDataA, encodedDataB, normal, materialDiffuse, materialIndex, hitDepth, hituv);\n    }\n   \telse if (interpolationMode == 1)\n    {\n        // interpolate the decdoded data items bilinearly\n        GetDataBilinear(adjustedFragCoord, normal, materialDiffuse, materialIndex, hitDepth, hituv);\n    }\n   \telse\n    {\n        // interpolate the decdoded data items bicubically\n        GetDataBicubic(adjustedFragCoord, normal, materialDiffuse, materialIndex, hitDepth, hituv);\n    }   \n    \n    // get the ray info\n    vec3 rayOrigin;\n    vec3 rayDirection;\n    GetRayInfo(adjustedFragCoord, rayOrigin, rayDirection);   \n    vec3 pixelPos = rayOrigin + rayDirection * hitDepth;\n\n    // lighting parameters\n    vec3 c_reverseLightDir = normalize(vec3(1.0,2.0,-3.0));   \n    const vec3 c_lightColor = vec3(0.95);\n    const vec3 c_ambientLight = vec3(0.00);\n    vec3 c_pointLightPos = vec3(cos(iTime), sin(iTime / 0.25) * 0.25, sin(iTime) + 5.5);\n    const vec3 c_pointLightColor = vec3(0.1, 0.1, 0.6);\n\n    // texture lookup\n    if (materialIndex == 1)\n        materialDiffuse *= texture(iChannel3, hituv * 5.0).rgb;\n\telse if (materialIndex == 2 || materialIndex == 3)\n        materialDiffuse *= texture(iChannel2, hituv).rgb;\n    else if (materialIndex == 5)\n        materialDiffuse *= texture(iChannel3, hituv * 5.0).rgb * texture(iChannel2, hituv).rgb;\n    \n    // shade the pixel: diffuse, specular, ambient.\n    float dp = clamp(dot(normal, c_reverseLightDir), 0.0, 1.0);\n    vec3 pixelColor = (c_lightColor * dp * materialDiffuse);  \n    vec3 reflection = reflect(c_reverseLightDir, normal);\n    dp = clamp(dot(rayDirection, reflection), 0.0, 1.0);\n    pixelColor += vec3(hitDepth < 100.0 ? 1.0 : 0.0) * pow(dp, MaterialSpecularPower(materialIndex));\n    pixelColor += c_ambientLight; \n    \n    // shade the pixel for a point light\n    float pointLightDistance = length(c_pointLightPos - pixelPos);\n    float pointLightAttenuation = 1.0 - clamp(pointLightDistance / 3.0, 0.0, 1.0);\n    pointLightAttenuation = pow(pointLightAttenuation, 3.0);\n    vec3 reversePointLightDir = normalize(c_pointLightPos - pixelPos);\n    dp = clamp(dot(normal, reversePointLightDir), 0.0, 1.0);\n    pixelColor += c_pointLightColor * dp * pointLightAttenuation; \n    reflection = reflect(reversePointLightDir, normal);\n    dp = clamp(dot(rayDirection, reflection), 0.0, 1.0);\n    pixelColor += c_pointLightColor * pow(dp, MaterialSpecularPower(materialIndex)) * pointLightAttenuation;    \n    \n    #if DEBUG_SHOW_NORMALS\n    pixelColor = normal * 0.5 + 0.5;\n    #endif\n    \n    #if DEBUG_SHOW_DISTANCE\n    float shade = clamp(hitDepth / 6.0, 0.0, 1.0);\n    shade = 1.0 - shade;\n    pixelColor = vec3(shade);\n    #endif\n    \n    // hide the variables that we store in the first row of pixels!\n    if (adjustedFragCoord.y < 2.5)\n        pixelColor = vec3(1.0);\n    \n    // write out the pixel\n    fragColor = vec4(pixelColor, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}