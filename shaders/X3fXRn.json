{
    "Shader": {
        "info": {
            "date": "1709149822",
            "description": "A Nishita93-style single scattering atmosphere approximation.\nLMB to select Sun direction.\n1..4 to select distance.",
            "flags": 16,
            "hasliked": 0,
            "id": "X3fXRn",
            "likes": 14,
            "name": "Single scattering atmosphere",
            "published": 3,
            "tags": [
                "scattering",
                "atmosphere"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 330
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// A Nishita93-style single scattering atmosphere approximation.\n// This can serve as a (not quite drop-in) replacement for e.g.\n//     https://github.com/wwwtyro/glsl-atmosphere\n// Inherently provides both the sky model and the aerial perspective\n// in the same code.\n// Works for both surface and space views.\n\n// Consider a spherical planet of radius R, centered at origin.\n// Assuming, for the purposes of scattering computations, a 2-component\n// (Rayleigh and Mie particles) atmosphere with position-dependent\n// relative (i.e. dimensionless) densities Wr(r), Wm(r), the optical\n// depth on the (segment of) ray ro+t*rd is:\n//     D(ro,rd,l,h) = ∫ Ber*Wr(ro+t*rd)+Bem*Wm(ro+t*rd) dt on [l;h]\n// where Ber and Bem are volume-extinction coefficients (in units of m^-1):\n//     Ber=Bsr+Bar\n//     Bem=Bsm+Bam\n//     Bar, Bam - Rayleigh and Mie volume-absorption coefficients, respectively\n//     Bsr, Bsm - Rayleigh and Mie volume-scattering coefficients, respectively\n// at W=1.\n// NOTE: the volume-scattering, etc., coefficients are typically\n// denoted β in literature, and are written as B here to keep the\n// identifiers in ASCII. Similarly, the densities are typically denoted ρ.\n// The integral is typically taken either on [0;+∞), or until the ray\n// hits an obstacle (e.g. the planet itself).\n// From this, transmittance is calculated as usual via Beer-Lambert law:\n//     T=exp(-D)\n// Consider a light source (effectively infinitely far away) in the\n// direction ld (so that the light direction is -ld). In the\n// single-scattering approximation we only consider the following scenario:\n// photons from the light source arrive (attenuated by the atmosphere) from\n// the direction ld at some point on view ray ro+t*rd, experience scattering\n// and arrive (again attenuated by the atmosphere) at viewer. The radiance,\n// in W*sr^-1*m^-2, that the viewer observes in direction rd, then is:\n//     L = E * ∫ S(ro+t*rd)*(Pr*Bsr*Wr(ro+t*rd)+Pm*Bsm*Wm(ro+t*rd))*exp(-(D(ro,rd,0,t)+D(ro+t*rd,ld,0,+∞))) dt\n// where\n//     E      - irradiance from the light source, in W*m^-2\n//     Pr, Pm - Rayleigh and Mie phase functions, dimensionless\n//     S(r)   - shadow/obstruction (0 if a ray from r towards ld intersects an obstacle, 1 otherwise)\n// The irradiance is assumed constant in vicinity of the planet,\n// and the light is only coming from ld (otherwise we would need to\n// integrate the incoming radiance from all possible ld; here\n// we basically assume that Lin(dir)=E*delta(dir-ld)).\n// The phase functions depend on rd and ld, and describe the directional\n// dependence of scattering.\n// If the light is not monochromatic, the quantities L, E, and B* are actually\n// spectral: they depend on the wavelength (or frequency, depending on how\n// you style the spectrum). The units of L and E also change accordingly (e.g.\n// E in W*sr^-1*m^-3 and E in W*m^-3 for spectrum-as-a-function-of-wavelength),\n// but B* is still in m^-1.\n// The entire double integral (since D(...) inside are themselves integrals)\n// for the single-scattering approximation, in TeX:\n//     L_\\lambda=E_\\lambda \\int_0^\\infty S(\\vec{r}_o+t \\vec{r}_d) \\left( P_r(\\vec{r}_d,\\vec{l}_d) B_{s r \\lambda} W_r(\\vec{r}_o+t \\vec{r}_d) + P_m(\\vec{r}_d,\\vec{l}_d) B_{s m \\lambda} W_m(\\vec{r}_o+t \\vec{r}_d) \\right) \\exp \\left( -\\left( \\int_0^t \\left( (B_{s r \\lambda}+B_{a r \\lambda}) W_r(\\vec{r}_o+s \\vec{r}_d)+ (B_{s m \\lambda}+B_{a m \\lambda}) W_m(\\vec{r}_o+s \\vec{r}_d) \\right) \\, ds + \\int_0^\\infty \\left((B_{s r \\lambda}+B_{a r \\lambda}) W_r(\\vec{r}_o+t \\vec{r}_d+s \\vec{l}_d)+ (B_{s m \\lambda}+B_{a m \\lambda}) W_m(\\vec{r}_o+t \\vec{r}_d+s \\vec{l}_d) \\right) \\, ds \\right) \\right)\n// NOTE: this can be also expressed as a differential equation. In this\n// formulation, the computation is similar to alpha-blending infinitely many\n// [t;dt] elements. This blending corresponds to exp(-D(ro,rd,0,t)) part in the\n// integral, which is, therefore, absent from the differential equation.\n//\n// Computing this integral analytically is challenging, even for simple setups,\n// so it is typically tackled numerically.\n// The inner integral, D(...), however, admits fairly reasonable analytical\n// approximations (whether they are faster than numerical methods is a separate\n// question - we can get away with surprisingly few samples for\n// numerical integration). A single-component version is sufficient to explore,\n// since the multi-component version (Rayleigh and Mie) is a simple sum (this\n// is NOT the case for the entire integral L, which is part of the reason\n// for difficulty of computing it).\n// Consider density exponentially decreasing with the altitude (a simple\n// version of barometric formula)\n//     W=exp(-h/H)=exp(-(|r|-R)/H)\n// where H is the scale height (generally, Rayleigh and Mie particles have\n// different scale heights).\n// This, basically, reduces the integral D(...) to the Chapman function, for\n// which several approximations exist.\n// We can approximate the density as a quadratic (gaussian) exponent:\n//     W≈exp(-(r^2-R^2)/(2*R*H))=exp(-h/H-h^2/(2*R*H))\n// In this case, the single-component integral is:\n//     D = ∫ B*W(ro+t*rd) dt = B*sqrt(pi*R*H/2)*exp((R^2+dot(ro,rd)^2-dot(ro,ro))/(2*R*H))*erf((t+dot(ro,rd))/sqrt(2*R*H))\n// This, actually, corresponds an existing approximation of the Chapman\n// function. It has the advantage of being relatively simple and fully analytic.\n// For Earth (R/H≈700) the error is reported ~0.1%.\n// The expression for D above is useful both as a building block for the full\n// radiance integral L, and on its own: for computing the optical depth, e.g.\n// for aerial perspective and irradiance (both magnitude and color!) on a surface.\n// Once we have this, the rest is just numerical intergration\n// to compute L. We use an effective atmosphere radius (tuning parameter, currently\n// const*(Hr+Hm), which balances errors from large integration step vs discarding\n// larger part of atmosphere; more samples incentivize larger effective height) to only\n// integrate on a finite segment where the atmospheric density is considered high\n// enough. We then potentially split the integration segment by the planet's shadow,\n// to only integrate on the lit parts of the ray (an alternative, to integrate on the\n// entire segment, but skip the obstructed samples, seems less attractive, especially\n// if the number of samples is low), since that are the only parts that contribute\n// the light in our model. The integration itself is done using rectangle rule with\n// a specifically chosen offset. This was found to provide better results than\n// the commonly used midpoint rule (i.e. offset=1/2), while being similarly as simple.\n// Notably, same as midpoint rule, there are no samples on segment endpoints,\n// so the (sub-)segments don't share samples, which simplifies the computation.\n// The results may look passable with as few as 4 samples total. The default in this\n// shader is 8.\n\n// Literature:\n//     https://en.wikipedia.org/wiki/Optical_depth\n//     https://en.wikipedia.org/wiki/Rayleigh_scattering\n//     https://en.wikipedia.org/wiki/Mie_scattering\n//     https://en.wikipedia.org/wiki/Beer%E2%80%93Lambert_law\n//     https://en.wikipedia.org/wiki/Sunlight\n//     https://en.wikipedia.org/wiki/Barometric_formula\n//     https://en.wikipedia.org/wiki/Scale_height\n//     https://en.wikipedia.org/wiki/Chapman_function\n//     https://pbr-book.org/4ed/Volume_Scattering\n//     https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky.html\n//     http://www.thetenthplanet.de/archives/4519\n//     https://zero-radiance.github.io/post/analytic-media/\n//     Tomoyuki Nishita, Takao Sirai, Katsumi Tadamura, and Eihachiro Nakamae. 1993. Display of the earth taking into account atmospheric scattering. In Proceedings of the 20th annual conference on Computer graphics and interactive techniques (SIGGRAPH '93). Association for Computing Machinery, New York, NY, USA, 175–182. https://doi.org/10.1145/166117.166140\n//         http://nishitalab.org/user/nis/cdrom/sig93_nis.pdf\n//     Eric Bruneton. 2016. A qualitative and quantitative evaluation of 8 clear sky models. IEEE transactions on visualization and computer graphics 23, 12 (2016), 2641--2655.\n//         https://arxiv.org/pdf/1612.04336.pdf\n//     Joseph T. Kider, Daniel Knowlton, Jeremy Newlin, Yining Karl Li, and Donald P. Greenberg. 2014. A framework for the experimental comparison of solar and skydome illumination. ACM Trans. Graph. 33, 6, Article 180 (November 2014), 12 pages. https://doi.org/10.1145/2661229.2661259\n//         https://spectralskylight.github.io/Kider2014.pdf\n//     Lukas Hosek and Alexander Wilkie. 2012. An analytic model for full spectral sky-dome radiance. ACM Trans. Graph. 31, 4, Article 95 (July 2012), 9 pages. https://doi.org/10.1145/2185520.2185591\n//         https://cgg.mff.cuni.cz/projects/SkylightModelling/HosekWilkie_SkylightModel_SIGGRAPH2012_Preprint.pdf\n//     A. J. Preetham, Peter Shirley, and Brian Smits. 1999. A practical analytic model for daylight. In Proceedings of the 26th annual conference on Computer graphics and interactive techniques (SIGGRAPH '99). ACM Press/Addison-Wesley Publishing Co., USA, 91–100. https://doi.org/10.1145/311535.311545\n//         https://courses.cs.duke.edu/fall01/cps124/resources/p91-preetham.pdf\n//     Naty hoffman & Arcot J. Preetham, Photorealistic Real-Time Outdoor Light Scattering, GDC 2002\n//         https://renderwonk.com/publications/gdm-2002/GDM_August_2002.pdf\n//         https://drivers.amd.com/developer/gdc/GDC02_HoffmanPreetham.pdf\n//     https://github.com/ebruneton/clear-sky-models/tree/master\n//     https://github.com/spectralskylight\n//     https://github.com/wwwtyro/glsl-atmosphere\n\n//==============================================================================\n// Mathematical constants.\n\nconst float INF=1e17;\nconst float pi=3.14159265358979;\n\n//==============================================================================\n// Physical constants.\n\n// Astrophysical Constants\n// Source: https://pdg.lbl.gov/2023/reviews/rpp2022-rev-astrophysical-constants.pdf\n\nconst float au=149597870700.0; // Astronomical unit, in m.\nconst float Rs=6.957e8;        // Nominal Solar equatorial radius, in m.\nconst float Sa=6.79431e-5;     // Solar solid angle from 1 a.u., in sr (=2*pi*(1-sqrt(au^2-rs^2)/au))\nconst float Re=6.3781e6;       // Nominal Earth equatorial radius, in m.\n\nconst float Esc=128e3; // Solar illuminance constant, in lux (https://en.wikipedia.org/wiki/Sunlight).\n// NOTE: you want to compute such constants yourself (perhaps you are dealing with\n// other planet and/or star), you would need the light source's spectrum (spectral\n// radiance, L(λ) in W*sr^-1*m^-2*nm^-1, e.g. AM0 for Sun, see\n// https://www.shadertoy.com/view/4XjGDK), its solid angle S as seen from viewer's\n// position, and, if you want to work with photometric (perceptual) quantities,\n// the lumious efficiency function (see http://www.cvrl.org/cie.htm and\n// e.g. https://www.shadertoy.com/view/msXyDH).\n// Then\n//     Ee =     S*∫     L(λ)*dλ  - irradiance (radiometric quantity, in W/m^2)\n//     Ev = 863*S*∫V(λ)*L(λ)*dλ  - illuminance (photometric quantity, in lux)\n// and the full color (using color matching functions,\n// http://www.cvrl.org/cie.htm), also in lux, is:\n//     X = 863*S*∫x(λ)*L(λ)*dλ\n//     Y = 863*S*∫y(λ)*L(λ)*dλ\n//     Z = 863*S*∫z(λ)*L(λ)*dλ\n// NOTE: V(λ)=y(λ). The relative, dimensionless color would be (X,Y,Z)/Ev.\n// If you don't need photometric quantities (e.g. you are doing spectral\n// render), then you just integrate L(λ) as is. E.g. for the AM0 solar spectrum\n// this yields Ee equal to the solar constant Gsc=1361 W/m^2. The spectral\n// radiance can be approximated as blackbody spectrum (see e.g.\n// https://www.shadertoy.com/view/4XjGDK).\n\nconst float Lsun=Esc/Sa; // Solar luminance, in cd/m^2.\n\n//==============================================================================\n// Colorspace.\n// Following http://www.thetenthplanet.de/archives/4519, we adopt\n// a chromatic adapation space (which we will unimaginatively call\n// CAS) with the aim to make the scattering computations *independent* per\n// channel, see the post for details.\n// The channels in this space ~correspond to point sampling\n// the spectrum at 615 nm, 535 nm, and 445 nm, respectively.\n\nconst mat3 CAS2RGB=transpose(mat3(\n     1.6218,-0.4493, 0.0325,\n    -0.0374, 1.0598,-0.0742,\n    -0.0283,-0.1119, 1.0491));\n    \nconst mat3 RGB2CAS=transpose(mat3(\n     6.2267e-1, 2.6392e-1,-6.2375e-4,\n     2.3324e-2, 9.6056e-1, 6.7215e-2,\n     1.9285e-2, 1.0958e-1, 9.6035e-1));\n\nconst vec3 CASwavelength=vec3(615,535,445);\n\n// Sun color in CAS, normalized to unit luminance.\nvec3 CASsun=vec3(0.9420,1.0269,1.0241);\n\n// Rayleigh volume-scattering coefficient for\n// CAS wavelengths, in m^-1, as per\n// https://www.shadertoy.com/view/43j3zm.\nvec3 CASrayleigh=vec3(7.2865e-6,1.2863e-5,2.7408e-5);\n\n//==============================================================================\n\nvec2 quadratic_solve(float a,float b,float c)\n{\n    float d=b*b-a*c;\n#if 1\n    return d>0.0?(-b+sqrt(d)*vec2(-1,+1))/a:vec2(+INF,-INF);\n#else\n    // Expected to be more accurate.\n    if(!(d>0.0)) return vec2(+INF,-INF);\n    float q=-b+(b<0.0?sqrt(d):-sqrt(d)),l=c/q,h=q/a; // NOT sign(b), in case b=0.\n    return vec2(min(l,h),max(l,h));\n#endif\n}\n\n//==============================================================================\n// Approximations for erf and erfcx.\n\n#if 0\n// From https://www.shadertoy.com/view/ml3yWj\n// Eabs ~ 2.8e-8\n// Erel ~ 2.8e-8\nfloat erf(float x)\n{\n    x=clamp(x,-4.0,+4.0);\n    float x2=x*x;\n    return tanh(x*(1.12837919+x2*(0.275732946+x2*(0.0408672727+x2*0.00200393011)))/(1.0+x2*(0.153282651+x2*(0.0224402472+x2*0.000285807058))));\n}\n\n// Erel=2.89760318e-08\nfloat erfcx(float x)\n{\n    float q=1.0+sqrt(pi)*abs(x);\n    float t=abs(x)>1e9?1.0:abs(x)/(1.0+abs(x));\n    float p=(1.0+t*(-1.83923738+t*(0.716286914+t*(0.798943258+t*(-0.777020726+t*0.196551435)))))/(1.0+t*(-2.48331366+t*(2.67169669+t*(-1.47041333+t*(0.417875249+t*-0.0403214433)))));\n    float y=p/q;\n    return x<0.0?2.0*exp(x*x)-y:y;\n}\n#else\n// See https://www.shadertoy.com/view/4XSGzW\n// Eabs<0.0037.\nfloat erf(float x)\n{\n    x=clamp(x,-3.0,+3.0);\n    return (1.13072*x)/(1.0+(x*x)*(0.357055+(x*x)*-0.01014));\n}\n\n// Eabs<0.00150\n// Erel<0.01100\nfloat erfcx(float x)\n{\n    const float a=0.4956;\n    float y=(1.0+a*abs(x))/(1.0+abs(x)*((2.0/sqrt(pi)+a)+sqrt(pi)*a*abs(x)));\n    return x>=0.0?y:2.0*exp(x*x)-y;\n}\n#endif\n\n//==============================================================================\n// Gaussian integrals.\n// Source: https://www.shadertoy.com/view/4XSGzW.\n\n// Compute exp(x)*(erf(z)-erf(y)).\nfloat gauss_segment(float x,float y,float z)\n{\n    return y*z<0.0?\n        exp(x)*(erf(z)-erf(y)):\n        sign(y+z)*(exp(x-y*y)*erfcx(abs(y))-exp(x-z*z)*erfcx(abs(z)));\n}\n\n// ∫ ρ(R,H,k,r(t)) dt on [l;h]\n// where\n//     r(t) = ro+t*rd\n//     ρ    = k*exp(-(r^2-R^2)/(2*R*H)) = k*exp(-h/H-h^2/(2*H*R))\n//     h    = |r|-R\nfloat density_integral(float R,float H,float k,vec3 ro,vec3 rd,float l,float h)\n{\n    float A=0.5/(R*H);\n    float B=dot(ro,rd)/(R*H);\n    float C=0.5*(dot(ro,ro)-R*R)/(R*H);\n    float W=0.25*B*B/A-C;\n    return 0.5*k*sqrt(pi/A)*gauss_segment(W,sqrt(A)*l+0.5*B/sqrt(A),sqrt(A)*h+0.5*B/sqrt(A));\n}\n\n//==============================================================================\n// Phase functions.\n// We follow the approach from\n//     Johannes Jendersie and Eugene d'Eon. 2023. An Approximate Mie Scattering Function for Fog and Cloud Rendering. In ACM SIGGRAPH 2023 Talks (SIGGRAPH '23). Association for Computing Machinery, New York, NY, USA, Article 47, 1–2. https://doi.org/10.1145/3587421.3595409\n//     https://research.nvidia.com/labs/rtr/approximate-mie/publications/approximate-mie.pdf\n// and approximate the Mie phase function as a weighted sum of Henyey-Greenstein and Draine\n// phase functions.\n// NOTE: this reduces to pure Henyey-Greenstein for phase_mie(vec4(g,0,0,0),x).\n\n// Draine phase function.\n//     B.T. Draine. 2003. Scattering by interstellar dust grains. I. Optical and ultraviolet. The Astrophysical Journal 598, 2 (2003), 1017. https://doi.org/10.1086/379118\n// NOTE: this reduces to Henyey-Greenstein for a=0,\n// to Rayleigh for g=0, a=1 and to Cornette-Shanks for a=1.\nfloat phase_draine(float a,float g,float x)\n{\n    float d=1.0+g*g-2.0*g*x;\n    return 1.0/(4.0*pi)*(1.0-g*g)/(1.0+a*(1.0+2.0*g*g)/3.0)* // <-- constant factor.\n        (1.0+a*x*x)/(d*sqrt(d));\n}\n\nfloat phase_rayleigh(float x)\n{\n    return phase_draine(1.0,0.0,x);\n}\n\n// Parametrization by droplet size.\n// Input: droplet size, in m.\n// Valid range: 5e-6<d<50e-6.\nvec4 phase_params_mie(float d)\n{\n    d*=1e6; // Convert to micrometres.\n    return vec4(\n        exp(-0.0990567/(d-1.67154)),          // gHG\n        exp(-2.20679/(d+3.91029)-0.428934),   // gD\n        exp(3.62489-8.29288/(d+5.52825)),     // alpha\n        exp(-0.599085/(d-0.641583)-0.665888)  // wD\n    );\n}\n\nfloat phase_mie(vec4 M,float x)\n{\n    return mix(phase_draine(0.0,M.x,x),phase_draine(M.z,M.y,x),M.w);\n}\n\n//==============================================================================\n// Convert turbidity (used e.g. by Preetham and Hosek sky models) to Mie \n// volume-scattering coefficient.\n// The turbidity is defined as the ratio of vertical optical depths:\n//     T=(t_mie+t_rayleigh)/t_rayleigh\n// at wavelength 550 nm (since, at least, t_rayleigh is wavelength-dependent).\n// From this we get t_mie=(T-1)*t_rayleigh.\n// Assuming volume-absorption coefficients are negligible, we get an\n// expression for Mie volume-scattering coefficient in terms of\n// Rayleigh volume-scattering coefficient (at 550 nm), scale heights\n// and turbidity.\n\n// To quote \"An analytic model for full spectral sky-dome radiance\"\n// by Hosek and Wilkie:\n// \"This allows the user to easily define sky appearance without worrying\n// too much about the intricacies of meteorology: T = 2 yields a very clear,\n// Arctic-like sky, T = 3 a clear sky in a temperate climate, T = 6 a sky\n// on a warm, moist day, T = 10 a slightly hazy day, and values of T above\n// 50 represent dense fog.\"\n// NOTE: this description doesn't appear to match the visuals: the\n// sky at T>=2 is considerably hazier than the description suggests.\n// The reason is not clear, though it may be partially explained by\n// Hosek model using a simple Henyey-Greenstein phase function for Mie\n// scattering.\n\n// Returns Mie volume-scattering coefficient (scalar, assumed\n// wavelength-independent), in m^-1.\nfloat turbidity2mie(float B550,float Hr,float Hm,float T)\n{\n    // NOTE: the vertical optical depth is just B*H.\n    return (T-1.0)*B550*Hr/Hm;\n}\n\n// Using the reference value of Rayleigh volume-scattering\n// coefficient at 550 nm.\n// See https://www.shadertoy.com/view/43j3zm.\nfloat turbidity2mie(float Hr,float Hm,float T)\n{\n    return turbidity2mie(1.149e-5,Hr,Hm,T);\n}\n\n//==============================================================================\n// Atmospheric scattering.\n\n// The number of samples is 2*NUM_STEPS.\nconst int NUM_STEPS=4;\n\n// Returns color (C, in [0]), and alpha (A, in [1]), of the computed atmospheric scattering,\n// which then can be used in the typical premultiplied alpha blending:\n//     Cresult=C+(1-A)*Cbackground\n//     Aresult=A+(1-A)*Abackground\n// except alpha is per-component.\n// NOTE: the units are for the reference. You can use other\n// set of units, as long as it is consistent (everything in\n// parsecs, etc.) - the internals of this function are not\n// tied to SI.\nmat2x3 atmosphere(\n    vec3 ro,                // Ray origin.\n    vec3 rd,                // Ray direction.\n    vec3 ld,                // Direction toward light source.\n    float E,                // Illuminance from light source, in lux.\n    float R,                // Planet radius, in m.\n    vec3 Bsr,vec3 Bar,      // Rayleigh volume-scattering and volume-absorption coefficients, in m^-1.\n    vec3 Bsm,vec3 Bam,      // Mie volume-scattering and volume-absorption coefficients, in m^-1.\n    float Hr,float Hm,      // Rayleigh and Mie scale height, in m.\n    vec4 M,                 // Mie phase function parameters.\n    vec2 s                  // Initial integration segment.\n    )\n{\n    ld=normalize(ld);\n    rd=normalize(rd);\n    float Ra=R+7.5*(Hr+Hm); // Effective radius of atmosphere.\n    vec2 sp=quadratic_solve(1.0,dot(ro,rd),dot(ro,ro)-R*R);        // Segment inside planet.\n    vec2 sa=quadratic_solve(1.0,dot(ro,rd),dot(ro,ro)-Ra*Ra);      // Segment inside atmosphere.\n    if(sp.x<sp.y&&sp.y>s.x) s.y=min(s.y,sp.x); // Clamp segment by planet.\n    vec3 Ber=Bsr+Bar;\n    vec3 Bem=Bsm+Bam;\n    // Compute alpha. Needs to happen while the segment is still only\n    // clamped by planet.\n    vec3 alpha=1.0-exp(-(\n            Ber*density_integral(R,Hr,1.0,ro,rd,s.x,s.y)+\n            Bem*density_integral(R,Hm,1.0,ro,rd,s.x,s.y)));\n    s=vec2(max(s.x,sa.x),min(s.y,sa.y)); // Clamp segment by atmosphere.\n    vec3 po=ro-dot(ro,ld)*ld;\n    vec3 pd=rd-dot(rd,ld)*ld;\n    vec2 ss=quadratic_solve(dot(pd,pd),dot(po,pd),dot(po,po)-R*R); // Segment inside planet's shadow.\n    if(dot(rd,ld)>0.0) ss.y=min(ss.y,-dot(ro,ld)/dot(rd,ld)); // Shadow is only half\n    else               ss.x=max(ss.x,-dot(ro,ld)/dot(rd,ld)); // of the cylinder.\n    vec2 sl=s,sh=vec2(s.y);\n    if(ss.x<ss.y) sl=vec2(s.x,min(s.y,ss.x)); // Possibly split segment\n    if(ss.x<ss.y) sh=vec2(max(s.x,ss.y),s.y); // into two by shadow.\n    // If there's only one real segment, split it in half, so there\n    // are always 2.\n    if(!(sl.x<sl.y))      {sl=vec2(sh.x,0.5*(sh.x+sh.y));sh=vec2(0.5*(sh.x+sh.y),sh.y);}\n    else if(!(sh.x<sh.y)) {sh=vec2(0.5*(sl.x+sl.y),sl.y);sl=vec2(sl.x,0.5*(sl.x+sl.y));}\n    vec3 Cr=vec3(0);\n    vec3 Cm=vec3(0);\n    float Pr=phase_rayleigh(dot(rd,ld));\n    float Pm=phase_mie(M,dot(rd,ld));\n    // Integrate both segments.\n    s=sl;\n    for(int k=0;k<2;++k)\n    {\n        if(!(s.x<s.y)) continue;\n        // Find the step size, and estimate the optimized offset.\n        float dt=(s.y-s.x)/float(NUM_STEPS);\n        vec3 B=Ber+Bem;\n        float X=max(max(B.x,B.y),B.z)*dt;\n        // The offset is chosen to provide exact answer\n        // for integrating exp(-(X/dt)*t) on [0;dt].\n        float offset=(X<0.25?0.5-X/24.0:log(X/(1.0-exp(-X)))/X);\n        if(k==1) offset=1.0-offset;\n        for(int i=0;i<NUM_STEPS;++i)\n        {\n            float t=s.x+(float(i)+offset)*dt;\n            vec3 r=ro+rd*t;\n            float h=(dot(r,r)-R*R)/(2.0*R);\n            float Dr=density_integral(R,Hr,1.0,ro,rd,0.0,t)+density_integral(R,Hr,1.0,r,ld,0.0,INF);\n            float Dm=density_integral(R,Hm,1.0,ro,rd,0.0,t)+density_integral(R,Hm,1.0,r,ld,0.0,INF);\n            vec3 a=exp(-(Ber*Dr+Bem*Dm));\n            Cr+=exp(-h/Hr)*a*dt;\n            Cm+=exp(-h/Hm)*a*dt;\n        }\n        s=sh;\n    }\n    return mat2x3(E*(Pr*Bsr*Cr+Pm*Bsm*Cm),alpha);\n}\n\n//==============================================================================\n// Main image.\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    float F=1.5;\n    float R=Re;\n    vec3 ro=vec3(0,R+80.0,5.0);\n    vec3 rd=normalize(vec3((2.0*fragCoord-iResolution.xy)/iResolution.y,-F));\n    vec3 md=normalize(vec3((2.0*iMouse.xy-iResolution.xy)/iResolution.y,-F));\n    vec3 ld=normalize(vec3(1,sin(0.5*iTime)+0.875,-2));\n    if(length(iMouse.xy)>16.0) ld=md;\n    float Hr=7.994e3,Hm=1.2e3;\n    if(texture(iChannel0,vec2(49.5,0.5)/vec2(256,3)).x>0.0) ro.z=sqrt(R*Hr);\n    if(texture(iChannel0,vec2(50.5,0.5)/vec2(256,3)).x>0.0) ro.z=R/16.0;\n    if(texture(iChannel0,vec2(51.5,0.5)/vec2(256,3)).x>0.0) ro.z=R/8.0;\n    if(texture(iChannel0,vec2(52.5,0.5)/vec2(256,3)).x>0.0) ro.z=4.0*R;\n    float T=1.375; // Turbidity.\n    float D=17e-6; // Droplet size, in m.\n    vec3 Bsr=CASrayleigh,Bar=vec3(0);\n    vec3 Bsm=vec3(turbidity2mie(Hr,Hm,T)),Bam=vec3(0); //  NOTE: glsl-atmosphere uses Bsm=21e-6\n    vec4 M=phase_params_mie(D);\n    // From https://en.wikipedia.org/wiki/Orders_of_magnitude_(illuminance)#Luminance\n    //     5e3 - Typical photographic scene in full sunlight\n    //     7e3 - Average clear sky\n    float Lref=7e3; // Scale luminance, in cd/m^2.\n    // NOTE: we work entirely in CAS, and only convert to RGB right\n    // before the tonemapping.\n    vec3 col=vec3(1e-7); // Airglow.\n    vec2 s=quadratic_solve(1.0,dot(ro,rd),dot(ro,ro)-R*R);\n    // Render Sun.\n    if(true) col+=Lsun*CASsun*smoothstep(1.0-(0.5*Rs*Rs/(au*au)),1.0,dot(rd,ld));\n    else     col+=Lsun*CASsun*exp(-(1.0-dot(rd,ld))/(2.0*Rs*Rs/(au*au)));\n    // Render planet.\n    if(s.x<s.y&&s.y>0.0)\n    {\n        vec3 a=exp(-(Bsr+Bar)*density_integral(R,Hr,1.0,ro,rd,0.0,s.x)+(Bsm+Bam)*density_integral(R,Hm,1.0,ro,rd,0.0,s.x));\n        col=Esc/pi*CASsun*a*(1.0/128.0+max(dot(ld,normalize(ro+s.x*rd)),0.0))*(RGB2CAS*vec3(0.125,0.25,0.0625));\n    }\n    mat2x3 m=atmosphere(ro,normalize(rd),normalize(ld),Esc,R,Bsr,Bar,Bsm,Bam,Hr,Hm,M,vec2(0.0,INF));\n    col=CASsun*m[0]+col*(1.0-m[1]);\n    col=CAS2RGB*col;\n    // Apply exposure.\n    col=1.0-exp(-col/Lref);\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // sRGB\n    fragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}