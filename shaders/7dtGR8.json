{
    "Shader": {
        "info": {
            "date": "1629312821",
            "description": "This simulates a black hole as if it was an entirely classical effect, if light had mass. Also has light fall downwards due to a very weak gravity.",
            "flags": 0,
            "hasliked": 0,
            "id": "7dtGR8",
            "likes": 5,
            "name": "Classical black hole raytracer",
            "published": 3,
            "tags": [
                "raytracing",
                "physics"
            ],
            "usePreview": 0,
            "username": "copperbotte",
            "viewed": 409
        },
        "renderpass": [
            {
                "code": "\n// random number generator **\n// taken from iq :)\nfloat seed;    //seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\n//another random number generator\n//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat hashrandom( float x )\n{\n    return floatConstruct(hash(floatBitsToUint(x)));\n}\n\n\n//color space transforms\nfloat lsrgb2srgb(in float lsrgb)\n{\n    if(lsrgb < 0.0031308)\n        return lsrgb * 12.92;\n    float a = 1.055;\n    return a * pow(lsrgb, 1.0/2.4) - (a - 1.0);\n}\n\nvec3 lsrgb2srgb(in vec3 lsrgb)\n{\n    return vec3(lsrgb2srgb(lsrgb.x),lsrgb2srgb(lsrgb.y),lsrgb2srgb(lsrgb.z));\n}\n\nfloat srgb2lsrgb(in float srgb)\n{\n    if(srgb < 0.04045)\n        return srgb / 12.92;\n    float a = 1.055;\n    return pow(1.0 + (srgb - 1.0) / a, 2.4);\n}\n\nvec3 srgb2lsrgb(in vec3 srgb)\n{\n    return vec3(srgb2lsrgb(srgb.x),srgb2lsrgb(srgb.y),srgb2lsrgb(srgb.z));\n}\n\n//random point in sphere\nvec3 randSphere()\n{\n    float xi1 = rnd() * 2.0 - 1.0;\n    float xi2 = rnd();\n\n    float theta = xi2 * 2.0 * 3.141592;\n    float sinp = sqrt(1.0 - xi1*xi1);\n\n    float x = sinp * cos(theta);\n    float y = sinp * sin(theta);\n    float z = xi1;\n\n    return vec3(x, y, z);\n}\nvec3 sampleSphere(vec3 normal, out float pdf)\n{\n  \tpdf = 1.0;\n    vec3 rOut = randSphere();\n    \n    if(dot(rOut, normal) < 0.0)\n        rOut = reflect(rOut, normal);\n    \n    //should these be packed into the sampler?\n    //float pdf = 1.0; // no numerator pdf\n    pdf /= 2.0 * 3.141592; // 4pi r^2 / 2, half a sphere's area (clamped)\n    \n    return rOut;\n}\n\n//events are in the form of (x,y,z,t) for ease of programming.\nconst float c = 1.0; //c is merely a scaling factor for r anyway, so using natural units haha\n\nmat4 trace(vec4 tr)\n{\n    mat4 m = mat4(0.0);\n    for(int n=0; n<4; ++n)\n        m[n][n] = tr[n];\n    return m;\n}\n\nvec4 toPolar(vec4 event)\n{\n    vec3 x = event.xzy;\n    float r = length(x);\n    float xyr = length(x.xy);\n    float theta = acos(x.z/xyr);\n    float psi = atan(x.y, x.x);\n    return vec4(r, theta, psi, event.w);\n}\n\nvec4 toEuclid(vec4 p_event)\n{\n    float r = p_event.x;\n    float theta = p_event.y;\n    float psi = p_event.z;\n    \n    float x = r*sin(theta)*cos(psi);\n    float y = r*sin(theta)*sin(psi);\n    float z = r*cos(theta);\n    \n    return vec4(x, z, y, p_event.w);\n}\n\n//calculates the schwarzchild metric for a given 3-vector r measured from an observing coordinate frame.\n//inputs a minkowski event x, and a schwartzchild radius r. \n//returns a 4x4 minkowski metric.\nmat4 schwarzschildMetric(vec4 x, float r)\n{\n    float k = 1.0 - r / length(x.xyz);  \n    \n    vec2 tr = vec2(-k, 1.0/k);\n    //rotate this into minkowski coordinates to eliminate pole problems\n    \n    //for now, rotate coodinate into spherical polar coodinates\n    vec4 rtp_ct = toPolar(x);\n    \n    return mat4(1.0);    \n}\n\n\nmat4 p_schwarzschildMetric(vec4 rtp_ct, float r)\n{\n    float k = 1.0 - r / rtp_ct.x;\n    float r2 = rtp_ct.x * rtp_ct.x;\n    \n    vec4 tr = vec4(1.0/k, r2, r2*sin(rtp_ct.y), -k);\n    mat4 metric = trace(tr);\n    return metric;\n}\n\nbool hitPlane(vec3 p0, vec3 p1, vec3 normal, float offset, out vec3 hit)\n{\n    float d0 = dot(p0, normal) - offset;\n    float d1 = dot(p1, normal) - offset;\n    if(sign(d0) == sign(d1))\n        return false;\n\n    //intermediate value theorem\n    float s = (offset-d0) / (d1-d0);\n    vec3 dp = p1 - p0;\n    hit = dp*s + p0;\n    return true;\n}\n\nbool hitAccrete(vec3 p0, vec3 p1, out vec3 hit)\n{\n    //find if p0 and p1 lie on opposite sides of the xy plane\n    \n    float theta = 3.141592 / 4.0;\n    mat3 rotate = mat3(vec3(1.0, 0.0, 0.0),\n                       vec3(0.0, cos(theta), -sin(theta)),\n                       vec3(0.0, sin(theta), cos(theta)));\n    \n    vec3 x0 = vec3(0,-0.1,0);\n    \n    vec3 normal = normalize(vec3(0,0,1));\n    normal = rotate * normal;\n    vec3 s_hit;\n    if(!hitPlane(p0-x0, p1-x0, normal, 0.0, s_hit))\n        return false;\n    \n    float lh = length(s_hit);\n    if(lh < 0.5 || 1.0 < lh)\n        return false;\n    \n    hit = s_hit;\n    return true;\n}\n\nbool hitFloor(vec3 p0, vec3 p1, out vec3 hit)\n{\n    //find if p0 and p1 lie on opposite sides of the xy plane\n    vec3 x0 = vec3(0,-0.25,0);\n    //x0.y = sin(iTime * 3.141592 / 5.0);\n    vec3 normal = normalize(vec3(0,1,0));\n    \n    vec3 s_hit;\n    if(!hitPlane(p0, p1, normal, dot(normal, x0), s_hit))\n        return false;\n    \n    float planesize = 40000.0;\n    \n    if(planesize < abs(s_hit.x) || planesize < abs(s_hit.z))\n        return false;\n     \n    hit = s_hit;\n    return true;\n}\n\nvec3 colorAccrete(vec3 hit)\n{\n    float theta = 3.141592 / 4.0;\n    mat3 rotate = mat3(vec3(1.0, 0.0, 0.0),\n                       vec3(0.0, cos(theta), -sin(theta)),\n                       vec3(0.0, sin(theta), cos(theta)));\n    hit = rotate * hit;\n\n    float angle = atan(hit.z, hit.x);\n    angle /= 3.141592;\n    angle *= 4.0;\n    bool color = 0.5 < angle - floor(angle);\n    float radius = length(hit.xz);\n    radius = (radius - 0.5)/(1.0 - 0.5);\n    radius *= 1.0;\n    color = color != (0.5 < radius - floor(radius));\n    \n    if(color)\n        return vec3(0.75,0.75,0.75);\n    else\n        return vec3(0.25,0.25,0.25);\n}\n\nvec3 colorPlane(vec3 hit)\n{\n    //vec2 pos = hit.xz / 2.0;\n    //vec2 pos = hit.xz * 4.0;\n\n    //bool color = 0.5 < mod(pos.x, 1.0);\n    //color = color != 0.5 < mod(pos.y, 1.0);\n    \n    //if(color)\n    //    return vec3(0.75,0.25,0.25);\n    //else\n    //    return vec3(0.25,0.0625,0.0625);\n    \n    vec2 pos = hit.xz / 8.0;\n    vec2 t_uv = mod(pos, 1.0);\n    ivec2 xor = ivec2(t_uv * 256.0);\n    float c = float(xor.x ^ xor.y) / 256.0;\n    \n    vec3 highColor = vec3(0.75,0.25,0.25);\n    vec3 lowColor = highColor * 0.25;\n    \n    vec3 albedo = mix(lowColor, highColor, c);\n    return albedo;\n    float mass = .25;\n    \n    float m = 1.0;\n    float s0 = 1.0;\n    \n    vec3 wsum = vec3(0);\n    const int lsamples = 10;\n    for(int j=0; j<lsamples; ++j)\n    {\n        float pdf;\n        vec3 vel0 = s0*sampleSphere(vec3(0,0,1), pdf);\n        float lambert = dot(vel0, vec3(0,0,1)) / 3.141592;\n        vec3 src0 = hit;\n        vec3 src = hit;\n        vec3 vel = vel0;\n        for(int i=0; i<256; ++i)\n        {\n            float dt = 0.1;\n            dt = dot(src, src); //based on distance to save on resources\n            dt /= 500.0; \n            dt = max(0.1, dt);\n            vec3 force = -mass * normalize(src) / dot(src, src);\n            //force *= 0.25;\n            //force *= -1.0;\n\n            //as if light had mass, effected by earth\n            //force += 0.001*m*9.807*vec3(0,-1,0);\n\n            //force *= 0.0;\n\n\n            vel += force * dt;\n\n            src0 = src;\n            src += vel * dt;\n\n            if(10000.0 < length(src))\n            {\n                float hitsun = dot(normalize(vel), normalize(vec3(0,0,1)));\n                hitsun = max(0.0, hitsun);\n                hitsun = pow(hitsun, 30.0);\n            \n                wsum += lambert*vec3(hitsun);//texture(iChannel0, vel).xyz;\n                //wsum += lambert*texture(iChannel0, vel).xyz;\n                break;\n            }\n\n            if(length(src) < mass * 0.2 / 0.25) // this is an artistically tuned value haha\n            {\n                wsum += lambert*vec3(0,0,0);\n                break;\n            }\n\n            if(hitFloor(src0, src, src0))\n            {\n                wsum += lambert*vec3(0,0,0);\n                break;\n            }\n\n            if(hitAccrete(src0, src, src0))\n            {\n                wsum += lambert*colorAccrete(src0);\n                break;\n            }\n\n        }\n    }\n    \n    return 100.0*albedo*wsum/float(lsamples);\n}\n\nvec3 render( in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    //uv /= 5.0;\n    \n    //view rotation matrix\n    //yaw\n    float theta = 3.141592 * iTime / (2.0 * 5.0);\n    //theta = 0.0;\n    mat3 yaw = mat3(vec3(cos(theta), 0.0, -sin(theta)),\n                       vec3(0.0, 1.0, 0.0),\n                       vec3(sin(theta), 0.0, cos(theta)));\n                       \n    //pitch\n    theta = 3.141592 * (0.25 / 2.0);\n    //theta = 0.0;\n    theta = 0.1;\n    mat3 pitch = mat3(vec3(1.0, 0.0, 0.0),\n                      vec3(0.0, cos(theta), sin(theta)),\n                      vec3(0.0,-sin(theta), cos(theta)));\n    \n    mat3 view = yaw * pitch;\n    \n    vec3 dir = normalize(vec3(uv.xy, 1.0));\n    vec3 src = vec3(0.0, 0.0, -10.0);\n    \n    dir = view * dir;\n    src = view * src;\n    //src += dir;\n    \n    vec4 src_t = vec4(src, length(src));\n    \n    //vec4 p_src = toPolar(vec4(src, 0.0));\n    \n    //return vec3(abs(p_src.yz), 0.0);\n    //GR Step\n    \n    //vec4 e_src = toEuclidean(p_src);\n    float R = length(src_t.xyz);\n    float kp = 1.0 + 1.0/(4.0*R);\n    float kn = 1.0 - 1.0/(4.0*R);\n    \n    float sp = kp*kp*kp*kp;\n    float st = -(kn*kn)/(kp*kp);\n    \n    mat4x4 metric = trace(vec4(sp, sp, sp, st));\n    \n    vec3 col = texture(iChannel0, dir).xyz;\n    \n    float mass = .25;\n    //mass = sin(iTime * 3.141592 / 10.0);\n    \n    if(true)\n    {\n    \n    //\"classical\" relativity\n    float m = 1.0;\n    float s0 = 1.0;\n    vec3 vel = dir*s0;\n    \n    vec3 src0 = src;\n    \n    for(int i=0; i<256; ++i)\n    {\n        float dt = 0.1;\n        dt = dot(src, src); //based on distance to save on resources\n        dt /= 500.0; \n        dt = max(0.1, dt);\n        vec3 force = -mass * normalize(src) / dot(src, src);\n        //force *= 0.25;\n        //force *= -1.0;\n\n        //as if light had mass, effected by earth\n        //force += 0.001*m*9.807*vec3(0,-1,0);\n\n        //force *= 0.0;\n        \n        \n        vel += force * dt;\n        \n        src0 = src;\n        src += vel * dt;\n        \n        col = texture(iChannel0, vel).xyz;\n        \n        if(10000.0 < length(src))\n            return col;\n        \n        if(length(src) < mass * 0.2 / 0.25) // this is an artistically tuned value haha\n            return vec3(0,0,0);\n            \n        if(hitFloor(src0, src, src0))\n            return colorPlane(src0);\n            \n        if(hitAccrete(src0, src, src0))\n            return colorAccrete(src0);\n    }\n    \n    if(length(src) < 1.0)\n        return vec3(0,0,0);\n    \n    dir = normalize(vel);\n    \n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec3 col = render(fragCoord);\n    vec3 col = vec3(0.0);\n    \n    seed = hashrandom(iTime + iResolution.y * fragCoord.x + fragCoord.y);\n    \n    bool AntiAlias = true;\n    if(AntiAlias)\n    {\n        const int samples = 4;\n        for(int i=0; i<samples; ++i)\n            col += srgb2lsrgb(render(fragCoord + ((vec2(rnd(), rnd())-0.5))));\n        //for(int i=0; i<4; ++i)\n        //    for(int j=0; j<4; ++j)\n        //        col += srgb2lsrgb(render(fragCoord + ((vec2(i, j)-1.0) / 4.0)));\n        col /= float(samples);\n    }else{\n        col = render(fragCoord);\n    }\n    \n    fragColor = vec4(lsrgb2srgb(col),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}