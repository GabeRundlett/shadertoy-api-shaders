{
    "Shader": {
        "info": {
            "date": "1639903291",
            "description": "an experiment that's been bouncing around my head for a while.\nwhat if you removed a cubic region of space itself, topologically speaking ?\nakin to 6 (3?) portals arranged in a cube.  what would that look like ?\n.. not super surprising, it turns out.",
            "flags": 0,
            "hasliked": 0,
            "id": "fltSWf",
            "likes": 5,
            "name": "space elision box",
            "published": 3,
            "tags": [
                "portal",
                "topology",
                "elision"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 242
        },
        "renderpass": [
            {
                "code": "// Fork of \"space elision box\" by elenzil. https://shadertoy.com/view/fltSWf\n// 2022-01-13 22:32:35\n\n/*\n\n    A cubic portion of space has been removed topologically..\n    Opposite faces of the cube are 'identified' (meaning made identical topologically)\n    so that a ray entering one face immediately leaves from the opposite face.\n    In nature the mineral Ulexite does something similar, but only along a single axis.\n    \n    Also, Panini Projection!\n\n*/\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n#define SSEPS  (4.0 / MINRES)\n#define ZERO (min(iFrame,0))\nconst float pi = 3.14159265359;\n\n#define AA 2\n\nfloat gTime = 0.0;\n\nmat2 rot2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nvec2 opUnion(in vec2 a, in vec2 b) {\n    if (a.x < b.x) {\n        return a;\n    }\n    else {\n        return b;\n    }\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// iq\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBoxRounded( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n// iq\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdB1(vec3 p) {\n    return sdBoxRounded(p, vec3(0.5), 0.1);\n}\n\nfloat sdB2(vec3 p) {\n    return sdBoxFrame(p, vec3(0.5 - 0.1), 0.05) - 0.01;\n}\n\nfloat sdB3(vec3 p) {\n    const vec3 bv = vec3(0.5, 0.5, 0.05);\n    p.xz *= rot2(gTime * 0.2);\n    float d = 1e9;\n    d =  min( d, sdBoxRounded(p, bv.xyz   , 0.01));\n    d =  min( d, sdBoxRounded(p, bv.yzx   , 0.01));\n    d =  min( d, sdBoxRounded(p, bv.zxy   , 0.01));\n    d = -min(-d, sdBoxRounded(p, vec3(0.4), 0.01));\n    return d;\n}\n\nvec2 map(in vec3 P) {\n    vec3 p = P;\n    vec2 q = vec2(1e11, -1.0);\n    p.xz *= rot2(gTime * 0.1);\n    q = opUnion(q, vec2(sdB2(abs(p) - vec3(2.5, 0.0, 0.0)), 1.0));\n    q = opUnion(q, vec2(sdB2(abs(p) - vec3(0.0, 0.0, 2.5)), 1.0));\n    q = opUnion(q, vec2(sdB3(abs(p) - vec3(2.5, 0.0, 2.5)), 1.0));\n    \n    if (iMouse.z < 2.0) {\n        q = opUnion(q, vec2(sdBoxFrame(P, vec3(1.02), 0.04) - 0.01, 2.0));\n    }\n    \n    vec3 s = P;\n    s.y += 1.5;\n    s.yz *= rot2(s.x * 0.7);\n    s.x = mod(s.x + 0.4 + gTime, 0.8) - 0.4;\n    s.z = abs(s.z) - 0.3 * smoothstep(18.0, 1.0, abs(P.x));\n    q = opUnion(q, vec2(sdSphere(s, 0.2), 3.0));\n    \n    return q;\n}\n\nfloat map2(in vec3 p) {\n    return sdBoxRounded(p, vec3(1.0), 0.0);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );\n}\n\nconst bool invisicube = false;\n\nvec4 march(in vec3 ro, inout vec3 rd, out bool portaled) {\n    portaled = false;\n    float t = 0.0;\n    vec2 q;\n    \n    vec3 p = ro;\n    \n    // this is a dual ray-marching loop.\n    // we march both a regular scene and a portal scene.\n    for (int step = 0; step < 200; ++step) {\n    \n        // regular geometry\n        q = map(p);\n        if (q.x < 1e-3) {\n            return vec4(p, q.y);\n        }\n        if (length(p) > 50.0) {\n            return vec4(p, -1.0);\n        }\n    \n        // portal geometry.\n        // I'm cheating here and assuming the geometry is a unit cube at the origin.\n        // todo: stop assuming that. march thru the portal geometry along the normal\n        //       until you come out the other side.\n        float m2d = map2(p);\n        if (m2d < 1e-3) {\n            portaled = true;\n            if (abs(p.x) < 1.0 && abs(p.y) < 1.0) {\n                p.z *= -1.01;\n            }\n            else if (abs(p.x) < 1.0 && abs(p.z) < 1.0) {\n                p.y *= -1.01;\n            }\n            else {\n                p.x *= -1.01;\n            }\n            rd = normalize(rd);\n            p += rd * 4e-3;\n        }\n        \n        // marching step is the smaller of the two scenes.\n        p += rd * (min (q.x, m2d));\n    }\n    \n    return vec4(p, q.y);\n}\n\nfloat Pow2(float x) { return x * x; }\n// PaniniProjection from TinyTexel\n// https://www.shadertoy.com/user/TinyTexel\n// https://www.shadertoy.com/view/Wt3fzB\n// tc ∈ [-1,1]² | fov ∈ [0, π) | d ∈ [0,1]\nvec3 PaniniProjection(vec2 tc, float fov, float d)\n{\n    float d2 = d*d;\n\n    {\n        float fo = pi / 2.0 - fov * 0.5;\n\n        float f = cos(fo)/sin(fo) * 2.0;\n        float f2 = f*f;\n\n        float b = (sqrt(max(0.0, Pow2(d+d2)*(f2+f2*f2))) - (d*f+f)) / (d2+d2*f2-1.0);\n\n        tc *= b;\n    }\n    \n    /* http://tksharpless.net/vedutismo/Pannini/panini.pdf */\n    float h = tc.x;\n    float v = tc.y;\n    \n    float h2 = h*h;\n    \n    float k = h2/Pow2(d+1.0);\n    float k2 = k*k;\n    \n    float discr = max(0.0, k2*d2 - (k+1.0)*(k*d2-1.0));\n    \n    float cosPhi = (-k*d+sqrt(discr))/(k+1.0);\n    float S = (d+1.0)/(d+cosPhi);\n    float tanTheta = v/S;\n    \n    float sinPhi = sqrt(max(0.0, 1.0-Pow2(cosPhi)));\n    if(tc.x < 0.0) sinPhi *= -1.0;\n    \n    float s = inversesqrt(1.0+Pow2(tanTheta));\n    \n    return vec3(sinPhi, tanTheta, cosPhi) * s;\n}\n\nvoid initRay(out vec3 ro, out vec3 rd, in vec2 xy) {\n    // Ray direction in camera space\n    float paniniFOV = 0.5;\n    float paniniD   = 2.0;\n    vec3  rayDirCam = PaniniProjection(xy, paniniFOV, paniniD);\n    \n    // Rotate ray according to camera orientation.\n    vec3  lookTo    = vec3(0.0);\n    vec3  lookFm    = vec3(0.0, 2.0, 6.0);\n    float wobble    = 0.0;\n    vec2  m         = iMouse.xy / RES;\n    if (length(m) < 0.05) {\n        m = vec2(gTime * 0.01, 0.5);\n    }\n    lookFm.yz      *= rot2(( m.y - 0.5) * -2.0 + sin(gTime) * wobble);\n    lookFm.xz      *= rot2((-m.x * pi ) *  2.5 + cos(gTime) * wobble);\n    vec3  camFw     = normalize(lookTo - lookFm);\n    vec3  camRt     = normalize(cross(camFw, vec3(0.0, 1.0, 0.0)));\n    vec3  camUp     = normalize(cross(camRt, camFw));\n    mat3  wldFrmCam = mat3(camRt, camUp, camFw);\n    \n    ro = lookFm;\n    rd = wldFrmCam * rayDirCam;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    gTime = iTime;\n    \n    vec3 accum = vec3(0.0);\n    for (int aaY = ZERO; aaY < AA; ++aaY) {\n    for (int aaX = ZERO; aaX < AA; ++aaX) {\n\n        vec2 aaO = vec2(ivec2(aaX, aaY)) / float(AA) - 0.5;\n\n        vec2 p = (XY + aaO - RES / 2.0) / MINRES * 2.0;\n        p *= 1.2;\n\n        vec3 ro;\n        vec3 rd;\n\n        initRay(ro, rd, p);\n\n        bool portaled;\n        vec4 q = march(ro, rd, portaled);\n\n        vec3 col = vec3(0.0);\n        \n        vec3 sky = texture(iChannel0, rd).rgb;\n\n        if (q.w < 0.0) {\n            // sky\n            col += sky;\n        }\n        else {\n            vec3 p = q.xyz;\n            vec3 nrm = calcNormal(p);\n            vec3 rfl = reflect(rd, nrm);\n\n            // reflection and lighting from cube map\n            if (q.w != 3.0) {\n                col += mix(texture(iChannel0, rfl), texture(iChannel1, rfl), 0.8).rgb;\n            }\n            else {\n                col = 0.7 * vec3(nrm.y * 0.5 + 0.5);\n            }\n\n            // colors\n            if (q.w == 1.0 || q.w == 3.0) {\n                col = mix(col, col * ((p * 0.5) + 0.5), 0.3);\n            }\n            else if (q.w == 2.0) {\n                col = mix(col, vec3(0.0), 0.5);\n            }\n            \n            col = mix(col, sky, smoothstep(6.0, 30.0, length(p)));\n\n        }\n        \n        accum      += col;\n    }}\n    \n    vec3 rgb = accum / float(AA * AA);\n    \n    RGBA = vec4(rgb, 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}