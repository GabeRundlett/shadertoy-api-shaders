{
    "Shader": {
        "info": {
            "date": "1486415571",
            "description": "WIP\nWhen the ray \"almost hit\" a surface by less than a pixel radius, we add an partial contribution+alpha.\n(  differential cone-tracing upon shader https://www.shadertoy.com/view/XtlXRB )\n\nPB: the pixel radius seems bad estimated at the very front. why ?",
            "flags": 0,
            "hasliked": 0,
            "id": "MlGXDt",
            "likes": 44,
            "name": "free AntiAliasing / cone tracing",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "antialiasing",
                "conetracing",
                "short",
                "spheremarching"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 2956
        },
        "renderpass": [
            {
                "code": "// differential cone-tracing version of https://www.shadertoy.com/view/XtlXRB\n// which was the compact simplified version of https://www.shadertoy.com/view/MllXz7\n\n// using the base ray-marcher of Trisomie21: https://www.shadertoy.com/view/4tfGRB#\n\n#define r(t) mat2(C=cos(t*T),S=sin(t*T),-S,C)\n\nvoid mainImage( out vec4 f, vec2 w ) {\n    f-=f;\n    vec2 R = iResolution.xy;\n    float T=iTime, C,S, x,\n        trsp=1.,dist=0.,  _x = 0., pix;         // <><><> for AA\n    vec4 p = vec4( (w-.5*R)/R.y, -.5,-.5), d;\n \n    p.xz *= r(.13);  p.yz *= r(.2); \n    d = normalize(p);  \n    p.z += 5.*T;\n    \n    if (mod(T,2.)>1.) R.y = 1e10;  // demo: AA on/off half-time\n  //if (w.x/R.x>.5) R.y = 1e10;    // demo: AA on/off half-window\n   \n    for (float i=1.; i>0.; i-=.01) {\n        \n        vec4 u = sin(78.+ceil(p/8.)), t = mod(p,8.)-4., a; \n        x = 1e9;\n        \n        for (float j=2.3; j>1.; j-= .3)\n            t.xy *= r(u.x),  t.xz *= r(u.y),\n            a = abs(t),\n            x = min(x, max(abs(length(t.xyz)-j*1.26),  max(a.x,max(a.y,a.z))-j)); \n \n        dist += x; pix = 2.*dist/R.y;           // <><><>  added for AA\n        if(x <.01) {                    // hit\n            f += trsp * vec4(i*i*1.2);          // <><><> += trsp*  added for AA\n            break;  \n        } else if (x<pix && x>_x) {             // <><><> AA: almost hit < pixel radius\n            float da = 1.-x/pix;\n            f += trsp*da* vec4(i*i*1.2); \n            trsp *= 1.-da;\n        }\n        p -= d*x;  \n        _x = x; //dist += x;                    // <><><>  added for AA\n     }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}