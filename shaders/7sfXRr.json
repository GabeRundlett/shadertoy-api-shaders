{
    "Shader": {
        "info": {
            "date": "1618195910",
            "description": "Bounces a classic Windows 3.1 bordered window around the screen where the client area of the window will be a 16 color dither of whatever is drawn beneath it-- in this case Himred's https://www.shadertoy.com/view/ld2yDz shader.",
            "flags": 32,
            "hasliked": 0,
            "id": "7sfXRr",
            "likes": 21,
            "name": "Windowed Anachronism 3.1",
            "published": 3,
            "tags": [
                "2d",
                "retro",
                "dither",
                "bayer",
                "gui",
                "concept"
            ],
            "usePreview": 1,
            "username": "wilkie",
            "viewed": 535
        },
        "renderpass": [
            {
                "code": "// The resolution of the dither.\nconst float ResolutionDivisor = 1.0;\n\n// The number of colors\n// (It treats every color as equidistant... which is not accurate to the\n//  actual hardware, of course)\nconst float PaletteRGBSize = 1.0;\n\n// Can switch between the 4 by 4 and 8 by 8 bayer matrices\n#define BAYER_MATRIX bayer8x8\n//#define BAYER_MATRIX bayer4x4\n\nconst vec3 BUTTON_HIGHLIGHT = vec3(1.0, 1.0, 1.0);\nconst vec3 BUTTON_SHADOW = vec3(129.0/255.0, 129.0/255.0, 129.0/255.0);\n\nconst float BORDER_WIDTH = 4.0;\nconst vec3 BORDER_FILL = vec3(193.0/255.0, 193.0/255.0, 193.0/255.0);\nconst vec3 BORDER_STROKE = vec3(0.0, 0.0, 0.0);\n\nconst vec3 TITLE_FILL = vec3(166.0/255.0, 203.0/255.0, 243.0/255.0);\n\nconst int SYSTEM_BUTTON_MENU = 0;\nconst int SYSTEM_BUTTON_MINIMIZE = 1;\nconst int SYSTEM_BUTTON_MAXIMIZE = 2;\n\nconst int TRIANGLE_UP = 0;\nconst int TRIANGLE_DOWN = 1;\nconst int TRIANGLE_LEFT = 2;\nconst int TRIANGLE_RIGHT = 3;\n\nfloat quantize(float inp, float period)\n{\n\treturn floor((inp + period / 2.) / period) * period;\n}\n\nfloat bayer4x4(vec2 uvScreenSpace, float divisor)\n{\n\tvec2 bayerCoord = floor(uvScreenSpace/divisor);\n\tbayerCoord = mod(bayerCoord, 4.);\n\n\tconst mat4 bayerMat = mat4(\n\t\t\t1,9,3,11,\n\t\t\t13,5,15,7,\n\t\t\t4,12,2,10,\n\t\t\t16,8,14,6) / 16.;\n\tint bayerIndex = int(bayerCoord.x + bayerCoord.y * 4.);\n\tif(bayerIndex == 0) return bayerMat[0][0];\n\tif(bayerIndex == 1) return bayerMat[0][1];\n\tif(bayerIndex == 2) return bayerMat[0][2];\n\tif(bayerIndex == 3) return bayerMat[0][3];\n\tif(bayerIndex == 4) return bayerMat[1][0];\n\tif(bayerIndex == 5) return bayerMat[1][1];\n\tif(bayerIndex == 6) return bayerMat[1][2];\n\tif(bayerIndex == 7) return bayerMat[1][3];\n\tif(bayerIndex == 8) return bayerMat[2][0];\n\tif(bayerIndex == 9) return bayerMat[2][1];\n\tif(bayerIndex == 10) return bayerMat[2][2];\n\tif(bayerIndex == 11) return bayerMat[2][3];\n\tif(bayerIndex == 12) return bayerMat[3][0];\n\tif(bayerIndex == 13) return bayerMat[3][1];\n\tif(bayerIndex == 14) return bayerMat[3][2];\n\treturn bayerMat[3][3];\n}\n\n\nfloat bayer8x8(vec2 uvScreenSpace, float divisor) {\n\n\tvec2 bayerCoord = floor(uvScreenSpace/divisor);\n\tbayerCoord = mod(bayerCoord, 8.);\n    \n\tint bayerIndex = int(bayerCoord.x + bayerCoord.y * 8.);\n    \n    float limit = 0.0;\n\n    if (bayerIndex == 0) limit = 0.015625;\n    if (bayerIndex == 1) limit = 0.515625;\n    if (bayerIndex == 2) limit = 0.140625;\n    if (bayerIndex == 3) limit = 0.640625;\n    if (bayerIndex == 4) limit = 0.046875;\n    if (bayerIndex == 5) limit = 0.546875;\n    if (bayerIndex == 6) limit = 0.171875;\n    if (bayerIndex == 7) limit = 0.671875;\n    if (bayerIndex == 8) limit = 0.765625;\n    if (bayerIndex == 9) limit = 0.265625;\n    if (bayerIndex == 10) limit = 0.890625;\n    if (bayerIndex == 11) limit = 0.390625;\n    if (bayerIndex == 12) limit = 0.796875;\n    if (bayerIndex == 13) limit = 0.296875;\n    if (bayerIndex == 14) limit = 0.921875;\n    if (bayerIndex == 15) limit = 0.421875;\n    if (bayerIndex == 16) limit = 0.203125;\n    if (bayerIndex == 17) limit = 0.703125;\n    if (bayerIndex == 18) limit = 0.078125;\n    if (bayerIndex == 19) limit = 0.578125;\n    if (bayerIndex == 20) limit = 0.234375;\n    if (bayerIndex == 21) limit = 0.734375;\n    if (bayerIndex == 22) limit = 0.109375;\n    if (bayerIndex == 23) limit = 0.609375;\n    if (bayerIndex == 24) limit = 0.953125;\n    if (bayerIndex == 25) limit = 0.453125;\n    if (bayerIndex == 26) limit = 0.828125;\n    if (bayerIndex == 27) limit = 0.328125;\n    if (bayerIndex == 28) limit = 0.984375;\n    if (bayerIndex == 29) limit = 0.484375;\n    if (bayerIndex == 30) limit = 0.859375;\n    if (bayerIndex == 31) limit = 0.359375;\n    if (bayerIndex == 32) limit = 0.0625;\n    if (bayerIndex == 33) limit = 0.5625;\n    if (bayerIndex == 34) limit = 0.1875;\n    if (bayerIndex == 35) limit = 0.6875;\n    if (bayerIndex == 36) limit = 0.03125;\n    if (bayerIndex == 37) limit = 0.53125;\n    if (bayerIndex == 38) limit = 0.15625;\n    if (bayerIndex == 39) limit = 0.65625;\n    if (bayerIndex == 40) limit = 0.8125;\n    if (bayerIndex == 41) limit = 0.3125;\n    if (bayerIndex == 42) limit = 0.9375;\n    if (bayerIndex == 43) limit = 0.4375;\n    if (bayerIndex == 44) limit = 0.78125;\n    if (bayerIndex == 45) limit = 0.28125;\n    if (bayerIndex == 46) limit = 0.90625;\n    if (bayerIndex == 47) limit = 0.40625;\n    if (bayerIndex == 48) limit = 0.25;\n    if (bayerIndex == 49) limit = 0.75;\n    if (bayerIndex == 50) limit = 0.125;\n    if (bayerIndex == 51) limit = 0.625;\n    if (bayerIndex == 52) limit = 0.21875;\n    if (bayerIndex == 53) limit = 0.71875;\n    if (bayerIndex == 54) limit = 0.09375;\n    if (bayerIndex == 55) limit = 0.59375;\n    if (bayerIndex == 56) limit = 1.0;\n    if (bayerIndex == 57) limit = 0.5;\n    if (bayerIndex == 58) limit = 0.875;\n    if (bayerIndex == 59) limit = 0.375;\n    if (bayerIndex == 60) limit = 0.96875;\n    if (bayerIndex == 61) limit = 0.46875;\n    if (bayerIndex == 62) limit = 0.84375;\n    if (bayerIndex == 63) limit = 0.34375;\n  \n    return limit;\n}\n\nvoid drawBox(inout vec3 color, vec3 fill, vec3 stroke, vec2 fragCoord, vec2 position, vec2 size)\n{\n    if (fragCoord.x >= position.x && fragCoord.x < (position.x + size.x) &&\n        fragCoord.y >= position.y && fragCoord.y < (position.y + size.y)) {        \n        color = fill;\n        \n        if (fragCoord.x - 0.5 == position.x ||\n            fragCoord.x - 0.5 == position.x + size.x - 1.0 ||\n            fragCoord.y - 0.5 == position.y ||\n            fragCoord.y - 0.5 == position.y + size.y - 1.0) {\n            color = stroke;\n        }        \n    }\n}\n\nvoid drawBevel(inout vec3 color, vec3 highlight, vec3 shadow, vec2 fragCoord, vec2 position, vec2 size)\n{\n    if (fragCoord.x >= position.x && fragCoord.x < (position.x + size.x) &&\n        fragCoord.y >= position.y && fragCoord.y < (position.y + size.y)) {\n        if (fragCoord.x - 0.5 == position.x + size.x - 1.0 ||\n                 fragCoord.y - 0.5 == position.y) {\n            color = shadow;\n        }  \n        else if (fragCoord.x - 0.5 == position.x ||\n            fragCoord.y - 0.5 == position.y + size.y - 1.0) {\n            color = highlight;\n        }\n    }\n}\n\nvoid drawTriangle(inout vec3 color, vec3 fill, vec2 fragCoord, vec2 position, vec2 size, int direction) {\n    if (fragCoord.x >= position.x && fragCoord.x < (position.x + size.x) &&\n        fragCoord.y >= position.y && fragCoord.y < (position.y + size.y)) {\n        // Get coordinates relative from the center.\n        vec2 xy = fragCoord - vec2(0.5, 0.5) - position - floor(size / 2.0);\n        if (xy.x + xy.y >= 0.0 &&\n            xy.y - xy.x >= 0.0 && direction == TRIANGLE_DOWN) {\n            color = fill;\n        }\n        if (xy.x + xy.y >= 0.0 &&\n            xy.x - xy.y >= 0.0 && direction == TRIANGLE_LEFT) {\n            color = fill;\n        }\n        if (xy.x + xy.y <= 0.0 &&\n            xy.y - xy.x <= 0.0 && direction == TRIANGLE_UP) {\n            color = fill;\n        }\n        if (xy.x + xy.y <= 0.0 &&\n            xy.x - xy.y <= 0.0 && direction == TRIANGLE_RIGHT) {\n            color = fill;\n        }       \n    }\n}\n\nvoid drawBorder(inout vec3 color, vec2 fragCoord, vec2 position, vec2 size)\n{   \n    if (fragCoord.x >= position.x && fragCoord.x < (position.x + size.x) &&\n        fragCoord.y >= position.y && fragCoord.y < (position.y + size.y)) {\n        \n        if (fragCoord.x >= position.x + BORDER_WIDTH &&\n            fragCoord.x < (position.x + size.x - BORDER_WIDTH) &&\n            fragCoord.y >= position.y + BORDER_WIDTH &&\n            fragCoord.y < (position.y + size.y - BORDER_WIDTH)) {\n            // Interior\n        }\n        else if (fragCoord.x >= position.x + BORDER_WIDTH - 1.0 &&\n                 fragCoord.x < (position.x + size.x - BORDER_WIDTH + 1.0) &&\n                 fragCoord.y >= position.y + BORDER_WIDTH - 1.0 &&\n                 fragCoord.y < (position.y + size.y - BORDER_WIDTH + 1.0)) {\n            color = vec3(0.0, 0.0, 0.0);\n        }\n        else {        \n            color = vec3(193.0/255.0, 193.0/255.0, 193.0/255.0);\n        \n            // Overall border\n            drawBox(color, vec3(193.0/255.0, 193.0/255.0, 193.0/255.0), vec3(0.0, 0.0, 0.0), fragCoord, position, size);\n            \n            // Bottom-left\n            drawBox(color, vec3(193.0/255.0, 193.0/255.0, 193.0/255.0), vec3(0.0, 0.0, 0.0), fragCoord, position, vec2(23.0, 23.0));\n            \n            // Top-left\n            drawBox(color, vec3(193.0/255.0, 193.0/255.0, 193.0/255.0), vec3(0.0, 0.0, 0.0), fragCoord, vec2(position.x, position.y + size.y - 23.0), vec2(23.0, 23.0));\n            \n            // Bottom-left\n            drawBox(color, vec3(193.0/255.0, 193.0/255.0, 193.0/255.0), vec3(0.0, 0.0, 0.0), fragCoord, vec2(position.x + size.x - 23.0, position.y), vec2(23.0, 23.0));\n            \n            // Top-left\n            drawBox(color, vec3(193.0/255.0, 193.0/255.0, 193.0/255.0), vec3(0.0, 0.0, 0.0), fragCoord, vec2(position.x + size.x - 23.0, position.y + size.y - 23.0), vec2(23.0, 23.0));\n        }        \n    }\n}\n\nvoid drawSystemButton(inout vec3 color, vec2 fragCoord, vec2 position, vec2 size, int type)\n{\n    drawBox(color, BORDER_FILL, BORDER_STROKE, fragCoord, position, size);\n    \n    if (type != SYSTEM_BUTTON_MENU) {\n        // Draw Bevel\n        drawBevel(color, BUTTON_HIGHLIGHT, BUTTON_SHADOW, fragCoord, position + vec2(1.0, 1.0), size - vec2(2.0, 2.0));\n        drawBevel(color, BORDER_FILL, BUTTON_SHADOW, fragCoord, position + vec2(2.0, 2.0), size - vec2(4.0, 4.0));\n    }\n    \n    if (type == SYSTEM_BUTTON_MENU) {\n        // Draw wacky minus sign thingy\n        drawBox(color, vec3(1.0, 1.0, 1.0), BUTTON_SHADOW, fragCoord, position + vec2(4.0, 8.0), vec2(13.0, 3.0));\n        drawBox(color, vec3(1.0, 1.0, 1.0), BORDER_STROKE, fragCoord, position + vec2(3.0, 9.0), vec2(13.0, 3.0));\n    }\n    else if (type == SYSTEM_BUTTON_MINIMIZE) {\n        // Draw Downward Facing Triangle... which is somehow not a yoga position\n        drawTriangle(color, BORDER_STROKE, fragCoord, position + vec2(6.0, size.y - 15.0), vec2(7.0, 7.0), TRIANGLE_DOWN);\n    }\n    else if (type == SYSTEM_BUTTON_MAXIMIZE) {\n        // Draw Upward Facing Triangle... which is somehow not a yoga position\n        drawTriangle(color, BORDER_STROKE, fragCoord, position + vec2(6.0, size.y - 11.0), vec2(7.0, 7.0), TRIANGLE_UP);\n    }\n}\n\nvoid drawTitle(inout vec3 color, vec2 fragCoord, vec2 position, vec2 size)\n{\n    // Draw title bar box\n    drawBox(color, TITLE_FILL, BORDER_STROKE, fragCoord, position, size);\n    \n    // Draw system buttons\n    drawSystemButton(color, fragCoord, position, vec2(size.y, size.y), SYSTEM_BUTTON_MENU);\n    drawSystemButton(color, fragCoord, vec2(position.x + size.x - size.y - size.y + 1.0, position.y),\n                                       vec2(size.y, size.y), SYSTEM_BUTTON_MINIMIZE);\n    drawSystemButton(color, fragCoord, vec2(position.x + size.x - size.y, position.y),\n                                       vec2(size.y, size.y), SYSTEM_BUTTON_MAXIMIZE);\n}\n\nvoid drawWindow(inout vec3 color, vec2 fragCoord, vec2 position, vec2 size)\n{\n    // Normalize to screen coords\n    position.y = iResolution.y - size.y - position.y;\n    \n    if (fragCoord.x >= position.x && fragCoord.x < (position.x + size.x) &&\n        fragCoord.y >= position.y && fragCoord.y < (position.y + size.y)) {\n                \n        color += (BAYER_MATRIX(fragCoord - position, ResolutionDivisor) - 0.5) * (0.99);\n\n        vec3 quantizationPeriod = vec3(1.0 / PaletteRGBSize);\n\n        color = vec3(\n            quantize(color.r, quantizationPeriod.r),\n            quantize(color.g, quantizationPeriod.g),\n            quantize(color.b, quantizationPeriod.b)\n        );\n\n        vec2 titleSize = vec2(size.x - (BORDER_WIDTH * 2.0) + 2.0, 20.0);\n        vec2 titlePos = vec2(position.x + BORDER_WIDTH - 1.0, position.y + size.y - titleSize.y - BORDER_WIDTH + 1.0);\n        drawTitle(color, fragCoord, titlePos, titleSize);\n        \n        drawBorder(color, fragCoord, position, size);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n\tvec4 tex = texture(iChannel0, uv);\n\tvec3 color = tex.xyz;\n    //vec3 color = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // Position and size of the window (depends on time)\n    vec2 windowPos = vec2(iTime, iTime) / 3.0;\n    vec2 windowSize = vec2(floor(iResolution.y / 2.), floor(iResolution.y / 2.));\n    \n    // Craft our 'fake' screen that is twice the size of our real one\n    vec2 screenSize = vec2(iResolution.x/iResolution.y, 1.) * 2.0;\n    \n    // How big the window is relative to the normal screen\n    vec2 windowSpace = vec2(windowSize.x / iResolution.x, windowSize.y / iResolution.y);\n\n    // The size of the area in which the box can bounce (on the 'fake' screen)\n    vec2 size = screenSize - windowSpace * 2.0;\n    \n    // Remap so (0,0) is bottom left, and (1,1) is top right\n    windowPos = windowPos / size + 0.5;\n    \n    // Constrict movement within the 'normal' screen\n    // We determine how many 'double screens' the object moved\n    // (It loops every time it moves the distance of two screens.)\n    vec2 flip = mod(floor(windowPos), 2.0);\n    \n    // And then subtract the amount it would have moved on the real screen if it\n    // looped on the real resolution... this has it 'bounce' on the edges.\n    windowPos = abs(flip - mod(windowPos, 1.0));\n    \n    // Return to the screen coordinate space\n    windowPos *= vec2(iResolution) - windowSize;\n    windowPos = floor(windowPos);\n    \n    // Draw the window\n    drawWindow(color, fragCoord, windowPos, windowSize);\n\n    // Output the color\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This itself is from: https://www.shadertoy.com/view/ld2yDz\n// I added the gradient background for more variety and slowed\n// down the cube's rotation.\n// The original comments and code follow\n// ----------------------------------------------------------\n\n// 6 shaders mapped on the 6 faces of a cube without any buffer\n//\n// Coded because I love cubes (don't ask me why)\n// and also love the retro amiga scene.\n//\n// The six shaders I love and I used here:\n//\n// Face 1: WWDC14 by capnslipp - https://www.shadertoy.com/view/XdfyRB\n// Face 2: Plasma by Klk - https://www.shadertoy.com/view/XsVSzW\n// Face 3: YaraGui by dila - https://www.shadertoy.com/view/ldlyWS\n// Face 4: Combustible Voronoi by Shane - https://www.shadertoy.com/view/4tlSzl\n// Face 5: Ring twister by Flyguy - https://www.shadertoy.com/view/Xt23z3\n// Face 6: Glenz by myself - https://www.shadertoy.com/view/4lt3R7 \n//\n// The rasterization is from: https://www.shadertoy.com/view/MdS3Rz by Hlorenzi\n// The sinus croll is by myself improved by gPlatl\n//\n// Tune is from the game Xenon2 on Amiga\n\n\nvec3 xcolor = vec3(0.2, 0.5, 1.0);\nvec2 xtp  = vec2(0);  // text position\nvec2 xpos;\nfloat tau = atan(1.0) * 8.0;\nfloat pi = atan(1.0) * 4.0;\nfloat aaSize = 0.0;\nvec3 cubevec;\n\n#define FONT_SIZE1 0.45\n#define FONT_SIZE2 0.3\n#define FONT_SPACE 0.42\n#define SIN_FREQ 0.75\n#define SIN_SPEED 3.0\n#define SCROLL_LEN 65.\n#define SCROLL_SPEED 2.0\n#define SIN_AMP 0.5\n#define S(a) c+=char(float(a)); xtp.x-=FONT_SPACE;\n#define xtime iTime\n#define NUM_FACES 4\n#define IN_RADIUS 0.25\n#define OUT_RADIUS 0.70\n#define XSCROLL_SPEED -0.9\n#define COLOR_1 0.50, 0.90, 0.95\n#define COLOR_2 0.95, 0.60, 0.10\n\nvec3 calcSine(vec2 uv, float frequency, float amplitude, float shift, float offset, vec3 color, float width, float exponent)\n{\n    float y = sin(iTime * frequency + shift + uv.x) * amplitude + offset;\n    float d = distance(y, uv.y);\n    float scale = smoothstep(width, 0.0, distance(y, uv.y));\n    return color * scale;\n}\n\nvec3 Bars(vec2 uv)\n{\n    //vec2 uv = f / iResolution.xy;\n    vec3 color = vec3(0.0);\n    color += calcSine(uv, 2.0, 0.25, 0.0, 0.5, vec3(0.0, 0.0, 1.0), 0.1, 3.0);\n    color += calcSine(uv, 2.6, 0.15, 0.2, 0.5, vec3(0.0, 1.0, 0.0), 0.1, 1.0);\n    color += calcSine(uv, 0.9, 0.35, 0.4, 0.5, vec3(1.0, 0.0, 0.0), 0.1, 1.0);\n    return color;\n}\n\nvec3 Twister(vec3 p)\n{\n    float f = sin(iTime/3.)*1.45;\n    float c = cos(f*p.y);\n    float s = sin(f/2.*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nfloat Cube( vec3 p )\n{\n    p=Twister(p);\n    cubevec.x = sin(iTime) / 0.5;\n    cubevec.y = cos(iTime) / 0.5;\n    mat2 m = mat2( cubevec.y, -cubevec.x, cubevec.x, cubevec.y );\n    p.xy *= m;p.xy *= m;p.yz *= m;p.zx *= m;p.zx *= m;p.zx *= m;\n    cubevec = p;\n    return length(max(abs(p)-vec3(0.4),0.0))-0.08;\n}\n\nfloat Face( vec2 uv )\n{\n        uv.y = mod( uv.y, 1.0 );\n        return ( ( uv.y < uv.x ) != ( 1.0 - uv.y < uv.x ) ) ? 1.0 : 0.0;\n}\n\nvec3 getNormal( in vec3 p )\n{\n    vec2 e = vec2(0.005, -0.005);\n    return normalize(\n        e.xyy * Cube(p + e.xyy) +\n        e.yyx * Cube(p + e.yyx) +\n        e.yxy * Cube(p + e.yxy) +\n        e.xxx * Cube(p + e.xxx));\n}\n\nvec4 Glenz(in vec2 uv )\n{\n    float pat = iTime*5.0;\n    float Step = 1.0;\n    float Distance = 0.0;\n    float Near = -1.0;\n    float Far = -1.0;\n    vec3 lightPos = vec3(1.5, 0, 0);\n    vec2 p = -1.0 + uv *2.0;\n    vec2 kp=uv;\n    vec4 m = iMouse / iResolution.xxxx;\n    float hd=-1.;\n    \n    vec3 ro = vec3( 0.0, 0.0, 2.1 );\n    vec3 rd = normalize( vec3( p, -2. ) );\n    for( int i = 0; i < 256; i++ )\n        {\n        \tStep = Cube( ro + rd*Distance );\n            Distance += Step*.5;\n\n            if( Distance > 4.0 ) break;\n            if( Step < 0.001 )\n            \t{\n                 \tFar = Face( cubevec.yx ) + Face( -cubevec.yx ) + Face( cubevec.xz ) + Face( -cubevec.xz ) + Face( cubevec.zy ) + Face( -cubevec.zy );\n            \t\tif(hd<0.) hd=Distance;\n                    if( Near < 0.0 ) Near = Far;\n            \t\tif(m.z<=0.0) Distance += 0.05; else break; // 0.05 is a magic number \n                }\n        }\n\n    vec3 Color=Bars(uv);\n    if( Near > 0.0 )\n    \t{\n            vec3 sp = ro + rd*hd;\n        \tvec3 ld = lightPos - sp;\n            float lDist = max(length(ld), 0.001);\n            ld /= lDist;\n            float atten = 1./(1. + lDist*.2 + lDist*.1); \n            float ambience = 0.7;\n            vec3 sn = getNormal( sp);\n            float diff = min(0.3,max( dot(sn, ld), 0.0));\n            float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n            if(m.z<=0.) Color = Color/5. + mix( vec3( 0.2, 0.0, 1.0 ), vec3( 1.0, 1.0, 1.0 ), vec3( ( Near*0.45 + Far*Far*0.04 ) ) );\n            else Color = mix( vec3( 0.2, 0.0, 1.0 ), vec3( 1.0, 1.0, 1.0 ), vec3( ( Near*0.45 + Far*Far*0.04 ) ) );\n            Color = Color*(diff+ambience)+vec3(0.78,0.5,1.)*spec/1.5;\n        }\n    return vec4( Color, 1.0 );\n}\n\n\n\nvec4 slice(float x0, float x1, vec2 uv)\n{\n    float u = (uv.x - x0)/(x1 - x0);\n    float w = (x1 - x0);\n    vec3 col = vec3(0);\n    col = mix(vec3(COLOR_1), vec3(COLOR_2), u);\n    col *= w / sqrt(2.0 * IN_RADIUS*IN_RADIUS * (1.0 - cos(tau / float(NUM_FACES))));\n    col *= smoothstep(0.05, 0.10, u) * smoothstep(0.95, 0.90, u) + 0.5;\n    uv.y += iTime * XSCROLL_SPEED; //Scrolling\n    col *= (-1.0 + 2.0 * smoothstep(-0.03, 0.03, sin(u*pi*4.0) * cos(uv.y*16.0))) * (1.0/16.0) + 0.7;\n    float clip = 0.0;\n    clip = (1.0-smoothstep(0.5 - aaSize/w, 0.5 + aaSize/w, abs(u - 0.5))) * step(x0, x1);\n    return vec4(col, clip);\n}\n\nvec4 Ring(in vec2 uv)\n{\n    aaSize = 2.0 / iResolution.y;\n    uv = uv * 2.0 - 1.0;\n    vec2 uvr = vec2(length(uv), atan(uv.y, uv.x) + pi);\n    uvr.x -= OUT_RADIUS;\n    vec3 col = vec3(0.05);\n    float angle = uvr.y + 2.0*iTime + sin(uvr.y) * sin(iTime) * pi;\n    \n    for(int i = 0;i < NUM_FACES;i++)\n    {\n        float x0 = IN_RADIUS * sin(angle + tau * (float(i) / float(NUM_FACES)));\n        float x1 = IN_RADIUS * sin(angle + tau * (float(i + 1) / float(NUM_FACES)));\n        vec4 face = slice(x0, x1, uvr);\n        col = mix(col, face.rgb, face.a); \n    }\n\treturn vec4(col, 1.0);\n}\n\n\nvec3 firePalette(float i){\n\n    float T = 1400. + 1300.*i;\n    vec3 L = vec3(7.4, 5.6, 4.4);\n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n    return 1.0-exp(-5e8/L);\n}\n\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\nfloat xvoronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\tfloat d = 1.; \n\tfor(int j = -1; j <= 1; j++) {\n\t    for(int i = -1; i <= 1; i++) {\n    \t\t\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\t\n\t    }\n\t}\n\t\n\treturn d;\n}\n\nfloat noiseLayers(in vec3 p) {\n    vec3 t = vec3(0., 0., p.z+iTime*1.5);\n\n    const int iter = 5;\n    float tot = 0., sum = 0., amp = 1.;\n\n    for (int i = 0; i < iter; i++) {\n        tot += xvoronoi(p + t) * amp;\n        p *= 2.0;\n        t *= 1.5;\n        sum += amp;\n        amp *= 0.5;\n    }\n    return tot/sum;\n}\n\nvec4 Voronoi(in vec2 uv )\n{\n    uv = uv * 2.0 - 1.0;\n\tuv += vec2(sin(iTime*0.5)*0.25, cos(iTime*0.5)*0.125);\n\tvec3 rd = normalize(vec3(uv.x, uv.y, 3.1415926535898/8.));\n\tfloat cs = cos(iTime*0.25), si = sin(iTime*0.25);\n\trd.xy = rd.xy*mat2(cs, -si, si, cs); \n\tfloat c = noiseLayers(rd*2.);\n\tc = max(c + dot(hash33(rd)*2.-1., vec3(0.015)), 0.);\n    c *= sqrt(c)*1.5;\n    vec3 col = firePalette(c);\n    col = mix(col, col.zyx*0.15+c*0.85, min(pow(dot(rd.xy, rd.xy)*1.2, 1.5), 1.));\n    col = pow(col, vec3(1.5));\n\treturn vec4(sqrt(clamp(col, 0., 1.)), 1.);\n}\n\nfloat char(float ch)\n{\n  vec4 f = texture(iChannel0,clamp(xtp,0.,1.)/16.+fract(floor(vec2(ch,15.999-float(ch)/16.))/16.));\n  return f.x;\n}\n\nvec4 ScrollText(vec2 xuv)\n{\n    xtp = xuv / FONT_SIZE1;  // set font size\n    xtp.x = 2.0*(xtp.x -4. +mod(xtime*SCROLL_SPEED, SCROLL_LEN));\n    xtp.y = xtp.y +1.7 +SIN_AMP*sin(xtp.x*SIN_FREQ +xtime*SIN_SPEED);\n    float c = 0.0;\n    \n    S(32.);S(32.);S(32.);S(32.);S(32.);S(32.);S(72.);S(101.);S(108.);S(108.);S(111.);S(32.);\n    S(115.);S(104.);S(97.);S(100.);S(101.);S(114.);S(116.);S(111.);S(121.);S(32.);S(33.);S(33.);\n    S(32.);S(84.);S(104.);S(105.);S(115.);S(32.);S(105.);S(115.);S(32.);S(97.);S(32.);S(99.);\n    S(117.);S(98.);S(101.);S(32.);S(119.);S(105.);S(116.);S(104.);S(32.);S(97.);S(32.);S(115.);\n    S(104.);S(97.);S(100.);S(101.);S(114.);S(32.);S(109.);S(97.);S(112.);S(112.);S(101.);S(100.);\n    S(32.);S(111.);S(110.);S(32.);S(101.);S(97.);S(99.);S(104.);S(32.);S(102.);S(97.);S(99.);\n    S(101.);S(32.);S(99.);S(111.);S(100.);S(101.);S(100.);S(32.);S(105.);S(110.);S(32.);S(49.);\n    S(57.);S(57.);S(48.);S(32.);S(97.);S(109.);S(105.);S(103.);S(97.);S(32.);S(114.);S(101.);\n    S(116.);S(114.);S(111.);S(32.);S(115.);S(116.);S(121.);S(108.);S(101.);S(32.);S(46.);S(46.);\n    S(46.);S(46.);S(32.);S(73.);S(32.);S(106.);S(117.);S(115.);S(116.);S(32.);S(109.);S(105.);\n    S(120.);S(101.);S(100.);S(32.);S(115.);S(101.);S(118.);S(101.);S(114.);S(97.);S(108.);S(32.);\n    S(115.);S(104.);S(97.);S(100.);S(101.);S(114.);S(115.);S(32.);S(116.);S(111.);S(103.);S(101.);\n    S(116.);S(104.);S(101.);S(114.);S(32.);S(46.);S(46.);S(46.);S(46.);S(32.);S(82.);S(101.);\n    S(97.);S(100.);S(32.);S(116.);S(104.);S(101.);S(32.);S(99.);S(111.);S(100.);S(101.);S(32.);\n    S(102.);S(111.);S(114.);S(32.);S(99.);S(114.);S(101.);S(100.);S(105.);S(116.);S(115.);S(32.);\n    S(46.);S(46.);S(46.);S(46.);S(46.);S(32.);S(73.);S(32.);S(99.);S(111.);S(100.);S(101.);\n    S(100.);S(32.);S(116.);S(104.);S(105.);S(115.);S(32.);S(98.);S(101.);S(99.);S(97.);S(117.);\n    S(115.);S(101.);S(32.);S(73.);S(32.);S(108.);S(111.);S(118.);S(101.);S(32.);S(99.);S(117.);\n    S(98.);S(101.);S(115.);S(32.);S(97.);S(110.);S(100.);S(32.);S(65.);S(109.);S(105.);S(103.);\n    S(97.);S(32.);S(46.);S(46.);S(46.);S(46.);S(46.);S(32.);S(72.);S(105.);S(109.);S(114.);\n    S(101.);S(100.);S(32.);S(46.);S(46.);S(46.);S(46.);S(32.);S(69.);S(79.);S(84.);S(32.);\n    S(46.);S(46.);S(46.);S(46.);\n    return c * vec4(xpos, 0.5+0.5*sin(2.0*xtime),1.0);\n}\n\n\nvec4 Plasma(vec2 uv )\n{\n\tfloat time=iTime*1.0;\n\tuv = (uv-0.0)*6.0;\n    vec2 uv0=uv;\n\tfloat i0=1.0;\n\tfloat i1=1.0;\n\tfloat i2=1.0;\n\tfloat i4=0.0;\n\tfor(int s=0;s<7;s++)\n\t{\n\t\tvec2 r;\n\t\tr=vec2(cos(uv.y*i0-i4+time/i1),sin(uv.x*i0-i4+time/i1))/i2;\n        r+=vec2(-r.y,r.x)*0.3;\n\t\tuv.xy+=r;\n        \n\t\ti0*=1.93;\n\t\ti1*=1.15;\n\t\ti2*=1.7;\n\t\ti4+=0.05+0.1*time*i1;\n\t}\n    float r=sin(uv.x-time)*0.5+0.5;\n    float b=sin(uv.y+time)*0.5+0.5;\n    float g=sin((uv.x+uv.y+sin(time*0.5))*0.5)*0.5+0.5;\n\treturn vec4(r,g,b,1.0);\n}\n\nfloat sdBoxXY( vec3 p, vec3 b )\n{\n  vec2 d = abs(p.xy) - b.xy;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nmat2 rot(float x) {\n\treturn mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat map(vec3 p) {\n    float k = 0.5 * 2.0;\n\tvec3 q = (fract((p - vec3(0.25, 0.0, 0.25))/ k) - 0.5) * k;\n    vec3 s = vec3(q.x, p.y, q.z);\n    float d = udRoundBox(s, vec3(0.1, 1.0, 0.1), 0.05);\n    \n    k = 0.5;\n    q = (fract(p / k) - 0.5) * k;\n    s = vec3(q.x, abs(p.y) - 1.5, q.z);\n    float g = udRoundBox(s, vec3(0.17, 0.5, 0.17), 0.2);\n    \n    float sq = sqrt(0.5);\n    vec3 u = p;\n    u.xz *= mat2(sq, sq, -sq, sq);\n    d = max(d, -sdBoxXY(u, vec3(0.8, 1.0, 0.8)));\n    \n    return smin(d, g, 16.0);\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        t += map(o + r * t);\n    }\n    return t;\n}\n\nvec4 Room(vec2 uv )\n{\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float gt = iTime / 5.0;\n    vec3 r = normalize(vec3(uv, 1.7 - dot(uv, uv) * 0.1));\n    float sgt = sin(gt * 3.141592 * 2.0);\n    r.xy *= rot(sgt * 3.141592 / 8.0);\n    r.xz *= rot(3.141592 * 0.0 + gt * 3.141592 * 2.0);\n    r.xz *= rot(3.141592 * -0.25);\n\n    vec3 o = vec3(0.0, 0.0, gt * 5.0 * sqrt(2.0) * 2.0);\n    o.xz *= rot(3.141592 * -0.25);\n\n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 sn = normal(w);\n    float fd = map(w);\n\n    vec3 col = vec3(0.514, 0.851, 0.933) * 0.5;\n    vec3 ldir = normalize(vec3(-1, -0.5, 1.1));\n\n    float fog = 1.0 / (1.0 + t * t * 0.1 + fd * 100.0);\n    float front = max(dot(r, -sn), 0.0);\n    float ref = max(dot(r, reflect(-ldir, sn)), 0.0);\n    float grn = pow(abs(sn.y), 3.0);\n\n    vec3 cl = vec3(grn);\n    cl += mix(col*vec3(1.5), vec3(0.25), grn) * pow(ref, 16.0);\n    cl = mix(col, cl, fog);\n\n\treturn vec4(cl, 1.0);\n}\n\nvec4 t(vec2 uv)\n{\n    float j = sin(uv.y * 3.14 + iTime * 5.0);\n    float i = sin(uv.x * 15.0 - uv.y * 2.0 * 3.14 + iTime * 3.0);\n    float n = -clamp(i, -0.2, 0.0) - 0.0 * clamp(j, -0.2, 0.0);\n    return 3.5 * (vec4(xcolor, 1.0) * n);\n}\n\nvec4 Twirl(vec2 p)\n{\n    vec2 uv;\n    p=-1.+2.*p;\n    \n    float r = sqrt(dot(p, p));\n    float a = atan(\n        p.y * (0.3 + 0.1 * cos(iTime * 2.0 + p.y)),\n        p.x * (0.3 + 0.1 * sin(iTime + p.x))\n    ) + iTime;\n    \n    uv.x = iTime + 1.0 / (r + .01);\n    uv.y = 4.0 * a / 3.1416;\n    \n    return mix(vec4(0.0), t(uv) * r * r * 2.0, 1.0);\n}\n\nvec4 MetaShader(vec2 uv,int shader)\n{\nif(uv.x<0.005 || uv.y<0.005 || uv.x>0.995 || uv.y>0.995) return vec4(0.8,0.8,0.8,1.);   \nif(shader==0) return Twirl(uv);\nif(shader==1) return Plasma(uv);\nif(shader==2) return Room(uv);\nif(shader==3) return Voronoi(uv);\nif(shader==4) return Ring(uv);\nif(shader==5) return Glenz(uv);\nreturn vec4(0);\n}\n\nvec4 inTriangle(vec2 p0, vec2 p1, vec2 p2, vec2 p)\n{\n\tfloat a = 0.5*(-p1.y*p2.x + p0.y*(-p1.x + p2.x) + p0.x*(p1.y - p2.y) + p1.x*p2.y);\n\tfloat s = 1.0/(2.0*a)*(p0.y*p2.x - p0.x*p2.y + (p2.y - p0.y)*p.x + (p0.x - p2.x)*p.y);\n\tfloat t = 1.0/(2.0*a)*(p0.x*p1.y - p0.y*p1.x + (p0.y - p1.y)*p.x + (p1.x - p0.x)*p.y);\n\t\n\tif (s > 0.0 && t > 0.0 && 1.0 - s - t > 0.0) {\n\t\treturn vec4(1.0,s,t,1.0-s-t);\n\t} else {\n\t\treturn vec4(0.0,s,t,1.0-s-t);\n\t}\n}\n\nvoid triangle(inout vec4 c, vec2 p, int shader, vec3 p0, vec3 p1, vec3 p2, vec2 t0, vec2 t1, vec2 t2)\n{\n\tfloat rx = iTime/3.;\n\tfloat ry = iTime;\n\tfloat rz = iTime;\n\t\n\tfloat cx = cos(rx); float sx = sin(rx);\n\tfloat cy = cos(ry); float sy = sin(ry);\n\tfloat cz = cos(rz); float sz = sin(rz);\n\t\n\tmat4 transform1 =\n\t\tmat4(1, 0, 0, 0,\n      \t\t 0, 1, 0, 0,\n      \t\t 0, 0, 1, 0,\n\t\t\t 0, 0, -2.5, 1);\n\t\n\tmat4 transform2 =\n\t\tmat4(cz*cy, -sz*cy, sy, 0,\n\t\t\t sz*cx + cz*sy*sx, cz*cx - sz*sy*sx, -cy*sx, 0,\n\t\t\t sz*sx - cz*sy*cx,cz*sx + sz*sy*cx, cy*cx, 0,\n\t\t\t 0, 0, 0, 1);\n\t\n\tfloat n = 1.0;\n\tfloat f = 10.0;\n\tfloat r = 1.0 * iResolution.x / iResolution.y;\n\tfloat t = 1.0;\n\tmat4 projection =\n\t\tmat4(n/r, 0, 0, 0,\n      \t\t 0, n/t, 0, 0,\n      \t\t 0, 0, -(f+n)/(f-n), -1,\n\t\t\t 0, 0, -(2.0*f*n)/(f-n), 0);\n\t\n\tvec4 pt0 = vec4(0,0,0,0);\n\tvec4 pt1 = vec4(0,0,0,0);\n\tvec4 pt2 = vec4(0,0,0,0);\n\t\n\tpt0 = projection * transform1 * transform2 * vec4(p0,1);\n\tpt1 = projection * transform1 * transform2 * vec4(p1,1);\n\tpt2 = projection * transform1 * transform2 * vec4(p2,1);\n\t\n\t\n\tvec4 test = inTriangle(pt0.xy / pt0.w, pt1.xy / pt1.w, pt2.xy / pt2.w, p);\n\t\n\tif (test.x != 0.0) {\n\t\tfloat z = ((pt1.z * test.y) / pt1.w +\n\t\t\t\t   (pt2.z * test.z) / pt2.w +\n\t\t\t\t   (pt0.z * test.w) / pt0.w) /\n\t\t\t\t\t(test.y / pt1.w +\n\t\t\t\t\t test.z / pt2.w +\n\t\t\t\t\t test.w / pt0.w);\n\t\tif (z < c.w) {\n\t\t\tfloat tx = ((t1.x * test.y) / pt1.w +\n\t\t\t\t\t\t(t2.x * test.z) / pt2.w +\n\t\t\t\t\t\t(t0.x * test.w) / pt0.w) /\n\t\t\t\t\t   (test.y / pt1.w +\n\t\t\t\t\t\ttest.z / pt2.w +\n\t\t\t\t\t\ttest.w / pt0.w);\n\t\t\t\n\t\t\tfloat ty = ((t1.y * test.y) / pt1.w +\n\t\t\t\t\t\t(t2.y * test.z) / pt2.w +\n\t\t\t\t\t\t(t0.y * test.w) / pt0.w) /\n\t\t\t\t\t   (test.y / pt1.w +\n\t\t\t\t\t\ttest.z / pt2.w +\n\t\t\t\t\t\ttest.w / pt0.w);\n\n            c=MetaShader(vec2(tx,ty),shader);\n            c.w=z;\n\t\t}\n\t}\n}\n\nvec4 pixel(vec2 p, vec4 color)\n{\n\ttriangle(color,p,0,vec3(-1,-1,-1),vec3(1,-1,-1), vec3(-1,1,-1),vec2(0,0),vec2(1,0),vec2(0,1));\n\ttriangle(color,p,0,vec3(1,-1,-1),vec3(1,1,-1),vec3(-1,1,-1),vec2(1,0),vec2(1,1),vec2(0,1));\t\n\ttriangle(color,p,1,vec3(1,1,1),vec3(-1,1,1),vec3(1,-1,1),vec2(0,0),vec2(1,0),vec2(0,1));\n\ttriangle(color,p,1,vec3(-1,1,1),vec3(-1,-1,1),vec3(1,-1,1),vec2(1,0),vec2(1,1),vec2(0,1));   \n    triangle(color,p,2,vec3(-1,1,-1),vec3(-1,1,1),vec3(-1,-1,-1),vec2(0,0),vec2(1,0),vec2(0,1));\n\ttriangle(color,p,2,vec3(-1,1,1),vec3(-1,-1,1),vec3(-1,-1,-1),vec2(1,0),vec2(1,1),vec2(0,1));\t\n    triangle(color,p,3,vec3(1,1,-1),vec3(1,1,1),vec3(1,-1,-1),vec2(0,0),vec2(1,0),vec2(0,1));\n\ttriangle(color,p,3,vec3(1,1,1),vec3(1,-1,1),vec3(1,-1,-1),vec2(1,0),vec2(1,1),vec2(0,1));   \n    triangle(color,p,4,vec3(-1,1,-1),vec3(-1,1,1),vec3(1,1,-1),vec2(0,0),vec2(1,0),vec2(0,1));\n\ttriangle(color,p,4,vec3(-1,1,1),vec3(1,1,1),vec3(1,1,-1),vec2(1,0),vec2(1,1),vec2(0,1));\n    triangle(color,p,5,vec3(-1,-1,-1),vec3(-1,-1,1),vec3(1,-1,-1),vec2(0,0),vec2(1,0),vec2(0,1));\n\ttriangle(color,p,5,vec3(-1,-1,1),vec3(1,-1,1),vec3(1,-1,-1),vec2(1,0),vec2(1,1),vec2(0,1));   \n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n    vec4 color = mix(vec4(0.0, 0.0, 1.0, 1000), vec4(0.0, 0.0, 0.0, 1000), 1.0 - (fragCoord.y / iResolution.y));\n\tuv = uv * 2.0 - vec2(1.0,1.0);\n\tfragColor = pixel(uv, color);\n    xpos = fragCoord.xy / iResolution.xy; //  0 .. 1\n    vec4 sc = 2.*ScrollText(uv);\n    fragColor+=sc;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}