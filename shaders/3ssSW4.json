{
    "Shader": {
        "info": {
            "date": "1553113519",
            "description": "Another family of cubic surfaces, based on the \"double six\" construction in Hilbert & Cohn-Vossen's \"Geometry and the Imagination\". Numerics from Betten & Karaoglu (see code for reference).\n",
            "flags": 48,
            "hasliked": 0,
            "id": "3ssSW4",
            "likes": 6,
            "name": "Hilbert Cohn-Vossen Cubic",
            "published": 3,
            "tags": [
                "cubic",
                "surface",
                "hilbert",
                "clebsch",
                "cohnvossen"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 527
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Hilbert-Cohn-Vossen Cubic surfaces\n//\n// W^3 - W*(X^2+Y^2+Z^2) + 1/a*(a^2+1)XYZ = 0\n//\n// in homogenous coordinates X,Y,Z,W, with parameter a, defines a cubic surface.\n// a = 1 => Cayley Cubic\n// a = sqrt(5) - 2 => Clebsch cubic\n// a = 0 => 3 planes\n//\n// Equations, coordinates etc. from Betten & Karaoglu:\n//\n// https://www.researchgate.net/publication/329131348_Cubic_surfaces_over_small_finite_fields\n//\n// Equation is unchanged under change of sign of any two of x,y,z,\n// so tetrahedral symmetry.\n//\n// Controls:\n// <Mouse>,<Up>,<Down> Change viewpoint\n// 'c': clip to sphere\n// 'f': fog distance\n// 'l': show lines only\n// 'm': model transform\n// 'q': R4 quaternion rotation\n// 'r': rotate around y axis\n// 's': surface type \n// 't': transparency\n// 'v': align surface vertically\n// 'x': show indication of settings\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\nconst float lwidth = 0.04;\nconst float lwidth2 = lwidth*lwidth;\nconst float scale = 1.0;\nconst float camera = 8.0;\nconst float clipradius = 5.0;\nconst float clipradius2 = clipradius*clipradius;\nbool linesonly = false;\nbool vertical = false;\nbool clipsphere = false;\nbool dorotate = false;\nbool transparent = true;\n\nint mtype = 0;\nint qtype = 0;\nint stype = 0;\n\n//float aparam = sqrt(5.0)-2.0;\nfloat aparam = 1.0;\n\nmat4 M, MINV; // P4 transformation and inverse\n\nvec3 light;\nfloat ambient;\nfloat diffuse;\n\nbool alert = false;\n\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\n// Quaternion multiplication as a matrix.\n// w coordinate is real element of quaternion\nmat4 qmat(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, t = q.w;\n  return mat4( t,-z, y, x, \n               z, t,-x, y,\n              -y, x, t, z,\n              -x,-y,-z, t );\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\n// Returns matrix that reflects in n, optimized\nmat4 reflection(vec4 n) {\n  float k = 2.0/dot(n,n);\n  return mat4(1)-k*mat4(n.x*n, n.y*n, n.z*n, n.w*n);\n}\n\n// Rotate p to q.\n// p and q should be the same length!\nmat4 rotation(vec4 p, vec4 q) {\n  return reflection(-q)*reflection(p+q);\n}\n\n// The Kahan algorithm, for explanation see:\n// https://people.eecs.berkeley.edu/~wkahan/Math128/Cubic.pdf\n\nfloat sgn(float x) {\n  return x < 0.0? -1.0: 1.0; // Return 1 for x == 0\n}\n\nbool qdrtc(float A, float B, float C, out vec2 res) {\n  float x1,x2;\n  float b = -0.5*B;\n  float q = b*b - A*C;\n  if (q < 0.0) return false;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    x1 = C/A; x2 = -x1;\n  } else {\n    x1 = C/r; x2 = r/A;\n  }\n  res = (x1 < x2)? vec2(x1,x2): vec2(x2,x1);\n  return true;\n}\n  \nvoid eval(float X, float A, float B, float C, float D,\n          out float Q, out float Q1, out float B1,out float C2) {\n  float q0 = A*X;\n  B1 = q0+B;\n  C2 = B1*X+C;\n  Q1 = (q0+B1)*X + C2;\n  Q = C2*X + D;\n}\n\n// Original Kahan algorithm\nint qbc(float A, float B, float C, float D, out vec3 res) {\n  float X,b1,c2;\n  if (A == 0.0) {\n    X = 1e8; A = B; b1 = C; c2 = D;\n  } else if (D == 0.0) {\n    X = 0.0; b1 = B; c2 = C;\n  } else {\n    X = -(B/A)/3.0;\n    float t,r,s,q,dq,x0;\n    eval(X,A,B,C,D,q,dq,b1,c2);\n    t = q/A; r = pow(abs(t),1.0/3.0); s = sgn(t);\n    t = -dq/A; if (t > 0.0) r = 1.324718*max(r,sqrt(t));\n    x0 = X - s*r;\n    if (x0 != X) {\n      for (int i = 0; i < 10; i++) {\n        //assert(i != 6);\n        X = x0;\n        eval(X,A,B,C,D,q,dq,b1,c2);\n        if (dq != 0.0) x0 -= (q/dq)/1.0001;\n        if (s*x0 <= s*X) break;\n      }\n      if (abs(A)*X*X > abs(D/X)) {\n        c2 = -D/X; b1 = (c2 - C)/X;\n      }\n    }\n  }\n  res.x = X;\n  if (!qdrtc(A,b1,c2,res.yz)) return 1;\n  if (res.x > res.y) res.xy = res.yx;\n  if (res.y > res.z) res.yz = res.zy;\n  return 3;\n}\n\nint qbc0(float A, float B, float C, float D, out vec3 res) {\n  float X,b1,c2;\n  if (A == 0.0) {\n    X = 1e8; A = B; b1 = C; c2 = D;\n  } else if (D == 0.0) {\n    X = 0.0; b1 = B; c2 = C;\n  } else {\n    X = -(B/A)/3.0;\n    float t,r,s,q,dq;\n    eval(X,A,B,C,D,q,dq,b1,c2);\n    t = q/A; r = pow(abs(t),1.0/3.0); s = sgn(t);\n    t = -dq/A; if (t > 0.0) r = 1.324718*max(r,sqrt(t));\n    X -= s*r;\n      // Newton-Raphson, simplified from Kahan to use\n      // a fixed length loop.\n      for (int i = 0; i < 4; i++) {\n        eval(X,A,B,C,D,q,dq,b1,c2);\n        X -= (q/dq);\n      }\n      if (abs(A)*X*X > abs(D/X)) {\n        c2 = -D/X; b1 = (c2 - C)/X;\n      }\n  }\n  res.x = X;\n  if (!qdrtc(A,b1,c2,res.yz)) return 1;\n  if (res.x > res.y) res.xy = res.yx;\n  if (res.y > res.z) res.yz = res.zy;\n  return 3;\n}\n\nint cubic(vec4 coeffs, out vec3 res) {\n  float A = coeffs[0], B = coeffs[1], C = coeffs[2], D = coeffs[3];\n  return qbc(A,B,C,D,res);\n}\n\nvec3 getColor(int i, vec3 normal, vec4 p4) {\n  vec3 p = p4.xyz/p4.w;\n  //p *= 4.0;\n  p += 0.5;\n  p = mod(p,2.0);\n  p = min(p,2.0-p);\n  //if (min(p.x,min(p.y,p.z)) < 0.1) return vec3(0);\n  if (i == -1) return vec3(0,0,0);\n  //if (i == 0) return vec3(0.5,0.5,1);\n  p4 /= p4.w;\n  if (i == 0) return 0.5+0.5*abs(normalize(p4.xyz));\n  if (i == 1) return vec3(1,0,0);\n  if (i == 2) return vec3(0,0,1);\n  if (i == 3) return 0.8*vec3(1);\n  if (i == 4) return vec3(1,1,0);\n  if (i == 5) return vec3(1,1,0);\n  if (i == 6) return vec3(1,1,0);\n  //if (i == 4) return vec3(0,1,0);\n  //if (i == 5) return vec3(0,1,1);\n  //if (i == 6) return vec3(1,0,1);\n  if (i == 7) return vec3(0.5,0.5,0.1);\n  return vec3(0);\n}\n\nfloat eval(vec4 p) {\n  // p is in world coordinates\n  p *= M;\n  float a = aparam;\n  float k = 1.0/a*(a*a+1.0);\n  float x = p.x, y = p.y, z = p.z, w = p.w;\n  float x2 = x*x, y2 = y*y, z2 = z*z, w2 = w*w, w3 = w2*w;\n  return w3 - w*(x2+y2+z2) + k*x*y*z;\n}\n\n// W^3 - (X^2+Y^2+Z^2)*W + 1/a*(a^2+1)XYZ = 0\n// p = (x,y,z),w\n// w^3 - w*(p.p)+k(xyz) = 0\nint surface(vec4 p, vec4 r, out vec3 t) {\n  // W^3 - (X^2+Y^2+Z^2)*W + kXYZ = 0\n  // -W*(X^2+Y^2+Z^2-W^2) + kXYZ = 0\n  // \n  // params from Sage:\n  // -w0*x02 - w0*y02 + k*x0*y0*z0 - w0*z02 + w03\n  // -w1*x02 - 2*w0*x0*x1 - w1*y02 - 2*w0*y0*y1 + k*x1*y0*z0 + k*x0*y1*z0 - w1*z02 + k*x0*y0*z1 - 2*w0*z0*z1 + 3*w02*w1\n  // -2*w1*x0*x1 - w0*x12 - 2*w1*y0*y1 - w0*y12 + k*x1*y1*z0 + k*x1*y0*z1 + k*x0*y1*z1 - 2*w1*z0*z1 - w0*z12 + 3*w0*w12\n  // -w1*x12 - w1*y12 + k*x1*y1*z1 - w1*z12 + w13\n  float a = aparam;\n  float k = 1.0/a*(a*a+1.0);\n  float x0 = p.x, y0 = p.y, z0 = p.z, w0 = p.w;\n  float x1 = r.x, y1 = r.y, z1 = r.z, w1 = r.w;\n#if 1\n  vec4 K = vec4(1,1,1,-1);\n  float A = -w1*dot(K*r,r) + k*x1*y1*z1; \n  float B = -2.0*w1*dot(K*p,r) - w0*dot(K*r,r) + k*dot(p.xyz*r.yzx,r.zxy);\n  float C = -2.0*w0*dot(K*p,r) - w1*dot(K*p,p) + k*dot(p.xyz*r.yzx,p.zxy);\n  float D = -w0*dot(K*p,p) + k*x0*y0*z0;\n#else\n  float x02 = x0*x0, y02 = y0*y0, z02 = z0*z0, w02 = w0*w0, w03 = w02*w0;\n  float x12 = x1*x1, y12 = y1*y1, z12 = z1*z1, w12 = w1*w1, w13 = w12*w1;\n  float A = -w1*x12 - w1*y12 - w1*z12 + w13 + k*x1*y1*z1;\n  float B = -2.0*w1*x0*x1 - 2.0*w1*y0*y1 - 2.0*w1*z0*z1 - w0*x12 - w0*y12 - w0*z12 + k*x1*y1*z0 + k*x1*y0*z1 + k*x0*y1*z1 + 3.0*w0*w12;\n  float C = -w1*x02 - w1*y02 - w1*z02 - 2.0*w0*x0*x1 - 2.0*w0*y0*y1 - 2.0*w0*z0*z1 + k*x1*y0*z0 + k*x0*y1*z0 + k*x0*y0*z1 + 3.0*w02*w1;\n  float D = -w0*x02 - w0*y02 - w0*z02 + w03 + k*x0*y0*z0;\n#endif\n  int nroots = cubic(vec4(A,B,C,D),t);\n  return nroots;\n}\n\n// Find the distance to the line in R3 but using\n// P4 coordinates.\nvoid tryline(vec4 p, vec4 q, vec4 r, int color,\n             inout float d2best, inout int colorindex) {\n  // Rotate lines in P4 so they project to correct\n  // position in R3 before calculating distance.\n  q = q*MINV; r = r*MINV;\n  if (abs(q.w) < abs(r.w)) {\n    vec4 t = q; q = r; r = t;\n  }\n  if (abs(q.w) < 1e-2) return;\n   r = q.w*r - r.w*q; // r.w = 0\n   p = q.w*p-q;\n   float pr = dot(p,r);\n   float d2 = (dot(p,p) - (pr*pr/dot(r,r)))/(q.w*q.w);\n   if (d2 < d2best) {\n      d2best = d2;\n      colorindex = color;\n   }\n}\n\nvoid trylines(vec4 p,float k,\n              inout float d2best,inout int colorindex) {\n#define tryline(x0,y0,z0,w0,x1,y1,z1,w1,c) \\\n  tryline(p,vec4(x0,y0,z0,w0),vec4(x1,y1,z1,w1),c,d2best,colorindex)\n  // It's tempting to put the lines in an array, but this\n  // performs badly on my laptop, perhaps a shortage of registers.\n  float a = aparam, b = 1.0;\n  if (true) {\n    tryline(1,a,0,0, 0,0,1,b, 1);\n    tryline(1,-a,0,0, 0,0,1,-b, 1);\n    tryline(1,0,-1.0/a,0, 0,1,0,-b, 1);\n    tryline(1,0,1.0/a,0, 0,1,0,b, 1);\n    tryline(1,0,0,-b, 0,1,-a,0, 1);\n    tryline(1,0,0, b, 0,1, a,0, 1);\n\n    tryline(1,-1.0/a,0,0, 0,0,1,-b, 2);\n    tryline(1,1.0/a,0,0, 0,0,1,b, 2);\n    tryline(1,0,a,0, 0,1,0,b, 2);\n    tryline(1,0,-a,0, 0,1,0,-b, 2);\n    tryline(1,0,0,b, 0,1,1.0/a,0, 2);\n    tryline(1,0,0,-b, 0,1,-1.0/a,0, 2);\n  }\n  if (true) {\n    float k0 = 2.0*a/(b*(a*a+1.0));\n    float k1 = (a*a-1.0)/(b*(a*a+1.0));\n    tryline(1,0,0,0, 0,1,0,0, 3);\n\n    tryline(0,1,-1,0, k0,k1,0,-1, 4);\n    tryline(0,-1,-1,0, -k0,-k1,0,-1, 4);\n    tryline(1,0,-1,0, -k1,k0,0,-1, 4);\n    tryline(-1,0,-1,0, k1,-k0,0,-1, 4);\n    tryline(0,-1,-1,0, -k0,k1,0,-1, 4);\n    tryline(0,1,-1,0, k0,-k1,0,-1, 4);\n    tryline(-1,0,-1,0, -k1,-k0,0,-1, 4);\n    tryline(1,0,-1,0, k1,k0,0,-1, 4);\n\n    tryline(1,0,0,0, 0,0,1,0, 3);\n\n    float k2 = 2.0*a/(a*a-1.0);\n    float k3 = b*(a*a+1.0)/(a*a-1.0);\n    tryline(-1,0,k2,k3, 0,-1,-k2,-k3, 4);\n    tryline(-1,0,k2,-k3, 0,-1,k2,-k3, 4);\n    tryline(-1,0,-k2,k3, 0,-1,-k2,k3, 4);\n    tryline(-1,0,-k2,-k3, 0,-1,k2,k3, 4);\n\n    tryline(0,1,0,0, 0,0,1,0, 3);\n  }\n#undef tryline\n}\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_X = 88;\n\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nbool doscale = false;\nvec3 solve(vec4 p, vec4 r, float min, float k) {\n  M = mat4(1);\n  float theta = 0.0;\n  theta = iTime*0.2;\n  if (doscale) {\n    mat4 scalemat = mat4(1,0,0,0,\n                         0,0.2,0,0,\n                         0,0,1,0,\n                         0,0,0,0.5);\n    M  *= scalemat;\n  }\n  if (qtype == 1) {\n    // Quaternion rotation (one sided)\n    vec3 a = normalize(vec3(0,1,0));\n    M *= qmat(vec4(-sin(theta)*a,cos(theta)));\n  } else if (qtype == 2) {\n    vec3 a = vec3(1,1,1);\n    M *= qmat(vec4(-sin(theta)*a,cos(theta)));\n  } else if (qtype == 3) {\n    M *= mat4(cos(theta),0,sin(theta),0,\n              0,1,0,0,\n              -sin(theta),0,cos(theta),0,\n              0,0,0,1);\n  }\n  if (vertical) {\n    M *= rotation(vec4(1,1,1,0), vec4(0,sqrt(3.0),0,0));\n  }\n  if (mtype == 1) {\n    mat4 m0 = mat4(-1,1,1,1,\n                   1,-1,1,1,\n                   1,1,-1,1,\n                   -1,-1,-1,1);\n    M *= m0;\n  } else if (mtype == 2) {\n    mat4 m0 = mat4(-1,1,1,-1,\n                   1,-1,1,-1,\n                   1,1,-1,-1,\n                   1,1,1,1);\n    M *= m0;\n  } else if (mtype == 3) {\n    mat4 m0 = mat4(-1,1,1,1,\n                   1,-1,1,1,\n                   1,1,-1,1,\n                   0,0,0,-4);\n    M *= m0;\n  } else if (mtype == 4) {\n    mat4 m0 = mat4(1,0,0,0,\n                   0,1,0,0,\n                   0,0,1,0,\n                  -1,-1,-1,-1);\n    M *= m0;\n  }\n  MINV = inverse(M);\n\n  vec3 res;\n  // Don't try to renormalize r here!\n  // We are now in P4\n  int nroots = surface(p*M,r*M,res);\n  vec3 color = vec3(0);\n  for (int i = nroots-1; i >= 0; i--) {\n    float t = res[i];\n    if (t < min) break;\n    vec4 p1 = p+t*r; // World coordinates\n    if (clipsphere && dot(p1.xyz,p1.xyz)/(p1.w*p1.w) > clipradius2) continue;\n    float d2best = lwidth2;\n    int colorindex = 0;\n    trylines(p1,k,d2best,colorindex);\n    if (linesonly && colorindex == 0) continue;\n\n    float x0 = eval(p1);\n    vec2 eps = vec2(1e-2,0);\n    vec3 normal = vec3(eval(p1+eps.xyyy)-x0,\n                       eval(p1+eps.yxyy)-x0,\n                       eval(p1+eps.yyxy)-x0);\n    normal = normalize(normal);\n    \n    if (dot(vec3(r),normal) > 0.0) {\n      normal = -normal; // Face forwards\n    }\n    vec3 baseColor = mix(getColor(colorindex,normal,p1*M),\n                         getColor(0,normal,p1*M),\n                         smoothstep(0.5*lwidth,lwidth,sqrt(d2best)));\n    vec3 c = baseColor*ambient;\n    c += baseColor*diffuse*(max(0.0,dot(light,normal)));\n    float specular = pow(max(0.0,dot(reflect(light,normal),vec3(r))),4.0);\n    c += 0.5*specular*vec3(1.0,1.0,1.0);\n    //c += 1.0*specular*baseColor;\n    float dist = t - min;\n    float fog = 1.0-smoothstep(0.0,100.0,dist);\n    if (keypress(CHAR_F)) c *= fog;\n    if (keypress(CHAR_T)) color = c;\n    else color = mix(color,c,0.8);\n  }\n  return sqrt(color);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    //p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.2);\n  }\n  return p;\n}\n\nint mtypecount = 5;\nint qtypecount = 3;\nint stypecount = 5;\n\nint getstate(int i) {\n  if (i < 0) return 0;\n  if (i < stypecount) return i == stype? 1: 2;\n  i -= stypecount+1;\n  if (i < 0) return 0;\n  if (i < qtypecount) return i == qtype? 1: 2;\n  i -= qtypecount+1;\n  if (i < 0) return 0;\n  if (i < mtypecount) return i == mtype? 1: 2;\n  i -= mtypecount+1;\n  return 0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  mtype = (0+keycount(CHAR_M))%mtypecount;\n  qtype = (0+keycount(CHAR_Q))%qtypecount;\n  stype = keycount(CHAR_S)%stypecount;\n  vertical = !keypress(CHAR_V);\n  clipsphere = !keypress(CHAR_C);\n  linesonly = keypress(CHAR_L);\n  dorotate = !keypress(CHAR_R);\n  transparent = !keypress(CHAR_T);\n    \n  //qtype = 0; stype = 1; mtype = 0;\n  float k;\n  if (stype == 0) {\n    aparam *= 0.5-0.49999*sin(0.2*iTime);\n  } else if (stype == 1) {\n    aparam = sqrt(5.0)-2.0;\n  } else if (stype == 2) {\n    aparam = 1e-6;\n  } else if (stype == 3) {\n    aparam = 1.0;\n  } else if (stype == 4) {\n    aparam = 0.5;\n  }\n  if (keypress(CHAR_A)) aparam = -aparam;\n  \n  light = normalize(vec3(0.0,1.0,1.0));\n  ambient = 0.4;\n  diffuse = 1.0-ambient;\n\n  vec2 uv = scale*(2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n  vec3 p = vec3(0.0, 0.0, camera);\n  p *= 0.1*float(10+keycount(KEY_DOWN)-keycount(KEY_UP));\n  vec3 r = normalize(vec3(uv, -3.0));\n\n  light = transform(light);\n  p = transform(p);\n  r = transform(r);\n  r = normalize(r);\n  \n  float t = -dot(p,r);\n  p += t*r;\n  vec3 color = solve(vec4(p,1),vec4(r,0),-t,k);\n  if (keypress(CHAR_X)) {\n    int N = mtypecount+1+qtypecount+1+stypecount;\n    vec2 xy = float(N)*fragCoord.xy/iResolution.x;\n    xy.x -= 0.5;\n    float gridx = round(xy.x);\n    int i = int(gridx);\n    int state = getstate(i);\n    if (state != 0) {\n      vec3 c = state==1?vec3(1,1,0):vec3(1);\n      float width = 0.25;\n      float eps = 0.02;\n      color = mix(color,c,1.0-smoothstep(width-eps, width+eps,distance(xy, vec2(gridx,1.0))));\n    }\n  }\n  if (alert) color.x = 1.0;\n  fragColor = vec4(color,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else\n    \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0 ) {\n        t = vec4(0);\n    } else {\n        t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}