{
    "Shader": {
        "info": {
            "date": "1634371330",
            "description": "Another Sailor Moon-inspired background\n\nmobile-friendly version: https://www.shadertoy.com/view/fsySRw",
            "flags": 32,
            "hasliked": 0,
            "id": "ssKSRh",
            "likes": 9,
            "name": "90s Anime Background 2",
            "published": 3,
            "tags": [
                "sunset",
                "sdf",
                "city",
                "90s",
                "anime",
                "skyline",
                "lit"
            ],
            "usePreview": 0,
            "username": "Xibanya",
            "viewed": 726
        },
        "renderpass": [
            {
                "code": "float nrand(float x, float y) \n{\n    return fract(sin(dot(\n        vec2(x, y), vec2(12.9898, 78.233))) * \n        43758.5453); \n}\nvec4 Blend(vec4 top, vec4 bottom) \n{\n\tvec4 result;\n\tresult.a = top.a + bottom.a * (1.0 - top.a);\n\tresult.rgb = (top.rgb * top.aaa + bottom.rgb * bottom.aaa * \n        (vec3(1.0, 1.0, 1.0) - top.aaa)) / result.aaa;\n\treturn result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= (1. - length(uv - vec2(0.5, 0.5))) * 0.025;\n    \n    float jitter = nrand(uv.y, iTime / 20.) * 2. - 1.;\n    uv.x += jitter * step(0.0, abs(jitter)) * 0.0015;\n    \n    vec2 texel = 1. / iResolution.xy;\n\tvec3 duv = texel.xyx * vec3(0.5, 0.5, -0.5);\n\n\tvec3 blur = texture(iChannel0, uv.xy - duv.xy).rgb;\n\tblur += texture(iChannel0, uv.xy - duv.zy).rgb;\n\tblur += texture(iChannel0, uv.xy + duv.zy).rgb;\n\tblur += texture(iChannel0, uv.xy + duv.xy).rgb;\n\tblur /= 4.;\n    \n    float sub = -0.1;\n    float hard = 0.3;\n\n    float modulo = floor(mod(uv.x / texel.x * 0.25, 3.0));\n    vec3 tmp = blur.rgb;\n    float is0 = step(modulo, 0.) * step(0., modulo);\n    float is1 = step(1., modulo) * step(modulo, 1.);\n    tmp -= vec3(0., sub * hard, \n        sub * hard * 2.0) * is0;\n    tmp -= vec3(sub * hard, 0., \n        sub * hard) * step(1., modulo) * step(modulo, 1.);\n    tmp -= vec3(sub * hard * 2.0, \n        sub * hard, 0.) * (1. - is0) * (1. - is1);\n    vec3 col = Blend(vec4(tmp, 0.9), vec4(blur, 1.)).rgb;\n    \n    float scanline = \n        sin((uv.y - sin(iTime / 200.)) * iResolution.y) * 0.01;\n    col.rgb -= scanline;\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#ifdef GL_OES_standard_derivatives\n    #extension GL_OES_standard_derivatives : enable\n#endif\n#define saturate(x) clamp(x, 0., 1.)\n#define EPSILON 0.0001\n#define XTILT 12.\n#define YTILT 19.\n#define MAX_DIST 200.\n#define FOV 30.\n#define LIGHTDIR vec3(1., 0.2, -1.)\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat aastep(float threshold, float value) \n{\n    float afwidth = length(\n        vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n    return smoothstep(\n        threshold - afwidth, threshold+afwidth, value); \n}\nvec3 GetDir(vec3 pos, vec3 dir)\n{\n    vec3 f = normalize(0. - pos);\n    vec3 s = normalize(cross(f, vec3(0., 1., 0.)));\n    vec3 u = cross(s, f);\n    mat4 viewToWorld = mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n    return (viewToWorld * vec4(dir, 0)).xyz;\n}\nfloat cube(vec3 p, vec3 b)\n{\n    return length(max(abs(p)-b,0.));\n}\nfloat Repeat(float p, float f)\n{\n    p = mod(p + f * .25, f);\n    p = abs(p - f * .5 );\n    return p;\n}\nfloat circle(vec2 uv, float radius)\n{\n\tvec2 dist = uv - vec2(0.5, 0.5);\n\treturn 1. - smoothstep(radius - (radius * 0.01),\n\t\tradius + (radius * 0.01),\n\t\tdot(dist, dist) * 4.0);\n}\nfloat Scene(vec3 p, out vec3 color, out float shiny)\n{\n    vec3 pos = p;\n    pos.z = Repeat(pos.z, 10.);\n    vec3 windowColor = vec3(0.5, 0.25, 0.63);\n    vec3 b1Color = vec3(0.83, 0.38, 0.58);\n    vec3 bld1Pos = pos + vec3(10., 4., -1.);\n    vec3 b1Size = vec3(4.75, 2., 2.);\n    float s = cube(bld1Pos, b1Size);\n\n    float b1y = fract(bld1Pos.y + .1);\n    float b1W = aastep(0.5, mod(b1y, 1.));\n    b1W *= step(1., bld1Pos.x);\n    b1W *= aastep(0.8, mod(bld1Pos.z * 1.5 + 1.9, 2.2));\n\n    color = mix(b1Color, windowColor, b1W);\n    shiny = b1W;\n\n    vec3 b2Pos = bld1Pos + vec3(0., -1., -3.);\n    vec3 b2Color = vec3(0.83, 0.38, 0.58);\n    float by = fract(b2Pos.y * 2.);\n    float b2W = aastep(0.5, mod(by, 1.));\n    b2W *= step(1., b2Pos.x);\n    b2W *= aastep(0.5, mod(b2Pos.z * 2. + 2., 0.));\n   \n    float wCirc = saturate(1. - b2Pos.z - 0.75);\n    vec3 accent = vec3(0.65, 0.34, 0.68);\n\n    vec2 cPos = b2Pos.zy * vec2(0.5, 0.2) + vec2(0., .1);\n    float wA = circle(cPos, 0.9);\n    float c2 = circle(cPos, 1.0);\n    wA = smoothstep(0.1, .9, 1. - saturate(distance(\n        cPos, pos.zy * vec2(.05, -0.05) + vec2(0., .2))));\n    wA += max(0., exp(-wA * 0.025) * .3);\n\n    b2Color = mix(b2Color, accent, saturate(wA));\n    windowColor = mix(windowColor, accent, wCirc);\n    b2Color = mix(b2Color, windowColor, b2W);\n\n    vec3 b2Size = vec3(5., 3., 1.);\n    float b2 = cube(b2Pos, b2Size);\n    shiny = b2 < s? b2W : shiny;\n    color = b2 < s? b2Color : color;\n    s = min(b2, s);\n\n    vec3 rdPos = pos + vec3(0., 6., 0.);\n    vec3 rdColor = vec3(0.2);\n    float rd = cube(rdPos, vec3(50., 0., 500.));\n    color = rd < s? rdColor : color;\n    s = min(rd, s);\n    return s;\n}\nvec3 GetNormal(vec3 p) \n{\n    vec3 c;\n    float s;\n    return normalize(vec3(\n        Scene(vec3(p.x + EPSILON, p.y, p.z), c, s) - \n        Scene(vec3(p.x - EPSILON, p.y, p.z), c, s),\n        Scene(vec3(p.x, p.y + EPSILON, p.z), c, s) - \n        Scene(vec3(p.x, p.y - EPSILON, p.z), c, s),\n        Scene(vec3(p.x, p.y, p.z  + EPSILON),c, s) - \n        Scene(vec3(p.x, p.y, p.z - EPSILON), c, s)\n    ));\n}\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 uv) \n{\n    vec2 xy = uv - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nvec3 RotateX(vec3 dir, float degrees)\n{\n    float angleX = radians(degrees);\n\tfloat c = cos(angleX);\n\tfloat s = sin(angleX);\n\tmat4 rotateXMatrix = mat4(1., 0., 0., 0.,\n\t\t0., c, -s, 0.,\n\t\t0., s, c, 0.,\n\t\t0., 0., 0., 1.);\n    return (vec4(dir, 1.) * rotateXMatrix).xyz;\n}\nvec3 RotateY(vec3 dir, float degrees)\n{\n    float angleY = radians(degrees);\n\tfloat c = cos(angleY);\n\tfloat s = sin(angleY);\n\tmat4 rotateYMatrix = mat4(\n        c, 0., s, 0.,\n\t\t0., 1., 0., 0.,\n\t\t-s, 0., c, 0.,\n\t\t0., 0., 0., 1.);\n    return (vec4(dir, 1.) * rotateYMatrix).xyz;\n}         \t\n/////////// FBM ///////////////\n// see: https://thebookofshaders.com/13/\nfloat FBMRandom(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) *\n                    43758.5453123);\n}\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat FBMNoise(in vec2 st)\n{\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = FBMRandom(i);\n    float b = FBMRandom(i + vec2(1.0, 0.0));\n    float c = FBMRandom(i + vec2(0.0, 1.0));\n    float d = FBMRandom(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\nfloat FBM(vec2 st, float octaves)\n{\n    float value = 0.;\n    float amplitude = 0.5;\n    float frequency = 0.;\n    for (float i = 0.; i < octaves; i++)\n    {\n        value += amplitude * FBMNoise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv.y *= iResolution.y / iResolution.x;\n\n    float bgBlend = smoothstep(-0.2, 0.9, dot(uv, vec2(-0.1, 1.)) * 4.);\n    vec3 col = mix(\n        vec3(0.9451, 0.7216, 0.4275), \n        vec3(0.8471, 0.4706, 0.3294), saturate(bgBlend));\n    \n    vec3 dir = rayDirection(FOV, iResolution.xy, fragCoord.xy);\n    dir = RotateX(dir, XTILT);\n    dir = RotateY(dir, YTILT);\n    vec3 p = vec3(0., -5., 0. );\n    \n    vec2 sunPos = vec2(0.25, 0.2);\n    vec3 coronaColor = vec3(0.93, 0.16, 0.31);\n    vec3 lightColor = vec3(0.96, 0.53, 0.29);\n    float coronaDist = distance(uv * vec2(0.8, 1.1),sunPos);\n    float isCorona = 1. - smoothstep(0.05, 0.25, dot(coronaDist, coronaDist) * 5.);\n    col = mix(col, coronaColor, isCorona);\n    float sundist = distance(uv * vec2(0.8, 1.1), sunPos);\n    float isSun = 1. - smoothstep(0.04, 0.06, dot(sundist, sundist) * 4.);\n    col = mix(col, pow(lightColor, vec3(sundist * 5.)) * 1.15, isSun);\n\n    vec2 cloudSpeed = vec2(iTime * 0.05, 0.);\n    float cloud = smoothstep(0.5, 0.9, \n        FBM(uv * vec2(1.5, 10.) + cloudSpeed, 5.));\n    vec3 cloudColor = vec3(0.9608, 0.5098, 0.6);\n    col = mix(col, cloudColor * 1.5, cloud);\n    cloud = smoothstep(0.5, .9, \n        FBM(uv * vec2(1., 10.) + vec2(0.025, -0.25) + cloudSpeed, 8.));\n    col = mix(col, cloudColor * 0.8, cloud);\n\n    float d = 0.;\n    vec3 dCol;\n    float isShiny = 0.;\n    for(float i = 0.; i < MAX_DIST; i++ )\n    {\n        d = Scene(p, dCol, isShiny);\n        p += dir * d;\n    }\n   \n    if (d < .01)\n    {\n        vec3 shadowColor = vec3(0.15, 0.1, 0.3);\n        vec3 normal = GetNormal(p);\n        vec3 lightDir = LIGHTDIR;\n        float mouseTiltY = iMouse.x * 3./iResolution.x - 0.5;\n        float mouseTiltX = iMouse.y/iResolution.y - 1.5;\n        lightDir = RotateY(lightDir, -mouseTiltY);\n        lightDir = RotateX(lightDir, -mouseTiltX);\n        float term = smoothstep(0.4, 0.7, \n            pow(dot(normal, lightDir) * 0.5 + 0.5, 2.));\n        vec3 diffuse = mix(shadowColor, dCol, term);\n        float ndV = min(1., pow(\n            max(0., dot(normal, normalize(lightDir + -dir))), 50.));\n        float specTerm = smoothstep(0.8, 1., ndV) * isShiny;\n        col = diffuse + specTerm * lightColor;\n    }\n    float overlay = smoothstep(0.15, 1., 0.2 - dot(uv.y, 1.));\n    col = mix(col, lightColor, max(0., overlay));\n\n\tfragColor = vec4(col, d);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define EPSILON         1.0e-4\n#define MAX_RADIUS min(0.05, 16. * 4. + 6. / iResolution.y)\n\nfloat Max3(float a, float b, float c)\n{\n    return max(max(a, b), c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 original = texture(iChannel0, uv);\n    vec2 texel = 1. / iResolution.xy;\n\tvec3 duv = texel.xyx * vec3(0.5, 0.5, -0.5);\n\n\tvec4 c0 = texture(iChannel0, uv.xy - duv.xy);\n\tvec3 c1 = texture(iChannel0, uv.xy - duv.zy).rgb;\n\tvec3 c2 = texture(iChannel0, uv.xy + duv.zy).rgb;\n\tvec3 c3 = texture(iChannel0, uv.xy + duv.xy).rgb;\n\tfloat w0 = 1. / (Max3(c0.r, c0.g, c0.b) + 1.);\n\tfloat w1 = 1. / (Max3(c1.r, c1.g, c1.b) + 1.);\n\tfloat w2 = 1. / (Max3(c2.r, c2.g, c2.b) + 1.);\n\tfloat w3 = 1. / (Max3(c3.r, c3.g, c3.b) + 1.);\n\n\tvec3 avg = c0.rgb * w0 + c1 * w1 + c2 * w2 + c3 * w3;\n\tavg /= max(w0 + w1 + w2 + w3, EPSILON);\n\n\tfloat maxRadius = MAX_RADIUS / 0.15;\n    \n\tavg *= smoothstep(0., texel.y * 2., maxRadius);\n    fragColor = vec4(avg, original.a);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define EPSILON         1.0e-4\n#define MAX_RADIUS min(0.05, 16. * 4. + 6. / iResolution.y)\n#define saturate(x) clamp(x, 0., 1.)\nfloat Luminance(vec3 linearRgb)\n{\n\treturn dot(linearRgb, vec3(0.2126729, 0.7151522, 0.0721750));\n}\nfloat Luminance(vec4 linearRgba)\n{\n\treturn Luminance(linearRgba.rgb);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    vec4 original = texture(iChannel0, uv);\n    float margin = 8.;\n    float screenMargin = texel.y * 2.;\n    float depth = original.a;\n    vec4 blur;\n    \n    for (int i = 0; i < 16; i++)\n\t{\n        vec2 disk;\n        // this is ridiculous but it\n        // won't compile on mobile if I try\n        // to use an array!\n        if (i == 0) disk = vec2(0.,0.);\n        else if (i == 1) disk = vec2(0.54545456,0.);\n        else if (i == 2) disk = vec2(0.16855472,0.5187581);\n        else if (i == 3) disk = vec2(-0.44128203,0.3206101);\n        else if (i == 4) disk = vec2(-0.44128197,-0.3206102);\n        else if (i == 5) disk = vec2(0.1685548,-0.5187581);\n        else if (i == 6) disk = vec2(1.,0.);\n        else if (i == 7) disk = vec2(0.809017,0.58778524);\n        else if (i == 8) disk = vec2(0.30901697,0.95105654);\n        else if (i == 9) disk = vec2(-0.30901703,0.9510565);\n        else if (i == 10) disk = vec2(-0.80901706,0.5877852);\n        else if (i == 11) disk = vec2(-1.,0.);\n        else if (i == 12) disk = vec2(-0.80901694,-0.58778536);\n        else if (i == 13) disk = vec2(-0.30901664,-0.9510566);\n        else if (i == 14) disk = vec2(0.30901712,-0.9510565);\n        else if (i == 15) disk = vec2(0.80901694,-0.5877853);\n        \n\t\tvec2 disp = (disk * MAX_RADIUS) / margin;\n\t\tfloat dist = length(disp);\n\t\tfloat aspect = iResolution.x / iResolution.y;\n\t\tvec2 duv = vec2(disp.x * (1. / aspect), disp.y);\n\t\tvec3 samp = texture(iChannel0, uv.xy + duv).rgb;\n\n\t\tfloat avgD = (abs(duv.y) + abs(duv.x)) / 2.;\n\t\tfloat blurZone = max(0., min(avgD / depth, MAX_RADIUS / margin));\n\t\tfloat weight = saturate((blurZone - dist + screenMargin) / screenMargin);\n\t\tblur += vec4(samp.rgb, 1.) * weight;\n\t}\n\tblur.rgb /= max(blur.a, EPSILON);\n\tfloat lum = Luminance(original);\n\tfloat blend = saturate(blur.a) * step(0.01, lum) * step(lum, 1.);\n\tblur = mix(original, blur, blend);\n    fragColor = blur;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}