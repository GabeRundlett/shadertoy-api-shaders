{
    "Shader": {
        "info": {
            "date": "1678162440",
            "description": "gradient 深色色板",
            "flags": 0,
            "hasliked": 0,
            "id": "csy3zh",
            "likes": 0,
            "name": "gradient 深色色板",
            "published": 3,
            "tags": [
                "gradient"
            ],
            "usePreview": 0,
            "username": "tianluo97",
            "viewed": 138
        },
        "renderpass": [
            {
                "code": "const vec2 target_resolution = vec2(940, 86);\n\nvec4 correct(vec4 col1, vec4 col2, float p)\n{\n \tvec4 temp = col1 * col1;\n    vec4 temp2 = col2 * col2;\n    return sqrt(mix(temp, temp2, p));\n}\n\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nmat4 saturationMatrix( float saturation ) {\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    float oneMinusSat = 1.0 - saturation;\n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red.r += saturation;\n    \n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green.g += saturation;\n    \n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue.b += saturation;\n    \n    return mat4( \n        red,     0,\n        green,   0,\n        blue,    0,\n        0, 0, 0, 1 );\n}\n\nvoid brightnessAdjust( inout vec4 color, in float b) {\n    color.rgb += b;\n}\n\nvoid contrastAdjust( inout vec4 color, in float c) {\n    float t = 0.5 - c * 0.5; \n    color.rgb = color.rgb * c + t;\n}\n\nint modi(int x, int y) {\n    return x - y * (x / y);\n}\n\nint and(int a, int b) {\n    int result = 0;\n    int n = 1;\n\tconst int BIT_COUNT = 32;\n\n    for(int i = 0; i < BIT_COUNT; i++) {\n        if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n            result += n;\n        }\n\n        a >>= 1;\n        b >>= 1;\n        n <<= 1;\n\n        if (!(a > 0 && b > 0))\n            break;\n    }\n    return result;\n}\n\n// forked from https://www.shadertoy.com/view/llGSzK\n// performance optimized by Ruofei\nvec4 vibrance(vec4 inCol, float vibrance) //r,g,b 0.0 to 1.0,  vibrance 1.0 no change, 0.0 image B&W.\n{\n \tvec4 outCol;\n    if (vibrance <= 1.0)\n    {\n        float avg = dot(inCol.rgb, vec3(0.3, 0.6, 0.1));\n        outCol.rgb = mix(vec3(avg), inCol.rgb, vibrance); \n    }\n    else // vibrance > 1.0\n    {\n        float hue_a, a, f, p1, p2, p3, i, h, s, v, amt, _max, _min, dlt;\n        float br1, br2, br3, br4, br5, br2_or_br1, br3_or_br1, br4_or_br1, br5_or_br1;\n        int use;\n\n        _min = min(min(inCol.r, inCol.g), inCol.b);\n        _max = max(max(inCol.r, inCol.g), inCol.b);\n        dlt = _max - _min + 0.00001 /*Hack to fix divide zero infinities*/;\n        h = 0.0;\n        v = _max;\n\n\t\tbr1 = step(_max, 0.0);\n        s = (dlt / _max) * (1.0 - br1);\n        h = -1.0 * br1;\n\n\t\tbr2 = 1.0 - step(_max - inCol.r, 0.0); \n        br2_or_br1 = max(br2, br1);\n        h = ((inCol.g - inCol.b) / dlt) * (1.0 - br2_or_br1) + (h*br2_or_br1);\n\n\t\tbr3 = 1.0 - step(_max - inCol.g, 0.0); \n        \n        br3_or_br1 = max(br3, br1);\n        h = (2.0 + (inCol.b - inCol.r) / dlt) * (1.0 - br3_or_br1) + (h*br3_or_br1);\n\n        br4 = 1.0 - br2*br3;\n        br4_or_br1 = max(br4, br1);\n        h = (4.0 + (inCol.r - inCol.g) / dlt) * (1.0 - br4_or_br1) + (h*br4_or_br1);\n\n        h = h*(1.0 - br1);\n\n        hue_a = abs(h); // between h of -1 and 1 are skin tones\n        a = dlt;      // Reducing enhancements on small rgb differences\n\n        // Reduce the enhancements on skin tones.    \n        a = step(1.0, hue_a) * a * (hue_a * 0.67 + 0.33) + step(hue_a, 1.0) * a;                                    \n        a *= (vibrance - 1.0);\n        s = (1.0 - a) * s + a * pow(s, 0.25);\n\n        i = floor(h);\n        f = h - i;\n\n        p1 = v * (1.0 - s);\n        p2 = v * (1.0 - (s * f));\n        p3 = v * (1.0 - (s * (1.0 - f)));\n\n        inCol.rgb = vec3(0.0); \n        i += 6.0;\n        //use = 1 << ((int)i % 6);\n        use = int(pow(2.0,mod(i,6.0)));\n        a = float(and(use , 1)); // i == 0;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p3, p1);\n \n        a = float(and(use , 1)); // i == 1;\n        use >>= 1;\n        inCol.rgb += a * vec3(p2, v, p1); \n\n        a = float( and(use,1)); // i == 2;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, v, p3);\n\n        a = float(and(use, 1)); // i == 3;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, p2, v);\n\n        a = float(and(use, 1)); // i == 4;\n        use >>= 1;\n        inCol.rgb += a * vec3(p3, p1, v);\n\n        a = float(and(use, 1)); // i == 5;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p1, p2);\n\n        outCol = inCol;\n    }\n    return outCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n    uv += .5;\n    uv.y -= 0.5/r - 0.5;    \n    \n    //深色色板\n    float PI = 3.1415926;\n    float time = iTime * 0.05; \n    float scale = 1.;\n    \n    vec4 vcolor0 = vec4(0.259,0.482,1.000,1.0);\n    vec4 vcolor1 = vec4(0.420,0.592,1.000,1.0);\n    vec4 vcolor2 = vec4(0.678,0.765,1.000,1.0);\n    vec4 vcolor3 = vec4(1.000,0.612,0.400,1.0);\n    vec4 vcolor4 = vec4(1.000,0.749,0.502,1.0);\n    \n    float step0 = 0.22 * scale;\n    float step1 = 0.45 * scale;\n    float step2 = 0.65 * scale;\n    float step3 = 0.80  * scale;\n    \n    float offset = uv.x-time;\n    float y = mod(offset,scale);\n    \n    vec4 darkColor; \n    if (y < step0) {\n    float dist0 = smoothstep(0.0, step0, y);\n    darkColor = mix(vcolor0, vcolor1, dist0);\n    darkColor = correct(vcolor0, vcolor1, dist0);\n    }\n    \n    if (y > step0 && y < step1) {\n    float dist1 = smoothstep(step0, step1, y);\n    darkColor = mix(vcolor1, vcolor2, dist1);\n    //darkColor = correct(vcolor1, vcolor2, dist1);\n    }\n    \n    else if (y > step1 && y < step2) {\n    float dist2 = smoothstep(step1, step2, y);\n    darkColor = mix(vcolor2, vcolor3, dist2);\n    darkColor = correct(vcolor2, vcolor3, dist2);\n    }\n    \n    else if (y > step2 && y < step3) {\n    float dist02 = smoothstep(step2, step3, y);\n    darkColor = mix(vcolor3, vcolor4, dist02);\n    darkColor = correct(vcolor3, vcolor4, dist02);\n    }\n    \n    else if (y > step3){\n    float dist3 = smoothstep(step3, 1.0 * scale, y);\n    darkColor = mix(vcolor4, vcolor0, dist3);\n    //darkColor = correct(vcolor4, vcolor0, dist3);\n    }\n    \n    darkColor = sqrt(darkColor);\n    \n    //Debug\n    //fragColor = vec4(maskColor,1.0);\n    //fragColor = vec4(lightColor);\n    fragColor = vec4(darkColor);\n    \n    // Black bars at the sides\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n    \n    if (uv.y<-0.1&&uv.y > -1.2){\n    \n    if (y < step0) {\n    float dist0 = smoothstep(0.0, step0, y);\n    darkColor = mix(vcolor0, vcolor1, dist0);\n    darkColor = correct(vcolor0, vcolor1, dist0);\n    darkColor = vec4(dist0,dist0,dist0,1.0);\n    }\n    \n    if (y > step0 && y < step1) {\n    float dist1 = smoothstep(step0, step1, y);\n    darkColor = mix(vcolor1, vcolor2, dist1);\n    //darkColor = correct(vcolor1, vcolor2, dist1);\n    darkColor = vec4(dist1,dist1,dist1,1.0);\n    }\n    \n    else if (y > step1 && y < step2) {\n    float dist2 = smoothstep(step1, step2, y);\n    darkColor = mix(vcolor2, vcolor3, dist2);\n    darkColor = correct(vcolor2, vcolor3, dist2);\n    darkColor = vec4(dist2,dist2,dist2,1.0);\n    }\n    \n    else if (y > step2 && y < step3) {\n    float dist02 = smoothstep(step2, step3, y);\n    darkColor = mix(vcolor3, vcolor4, dist02);\n    darkColor = correct(vcolor3, vcolor4, dist02);\n    darkColor = vec4(dist02,dist02,dist02,1.0);\n    }\n    \n    else if (y > step3){\n    float dist3 = smoothstep(step3, 1.0 * scale, y);\n    darkColor = mix(vcolor4, vcolor0, dist3);\n    //darkColor = correct(vcolor4, vcolor0, dist3);\n    darkColor = vec4(dist3,dist3,dist3,1.0);\n    }\n    \n    //darkColor = sqrt(darkColor);\n    fragColor = darkColor;\n    }\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}