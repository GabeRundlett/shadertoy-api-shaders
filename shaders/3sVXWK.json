{
    "Shader": {
        "info": {
            "date": "1575016789",
            "description": "Automatic oriented cavity placement on more general solids",
            "flags": 0,
            "hasliked": 0,
            "id": "3sVXWK",
            "likes": 4,
            "name": "Shifting Perforations 2",
            "published": 3,
            "tags": [
                "raytracing",
                "raymarching",
                "metaball",
                "hole",
                "interior"
            ],
            "usePreview": 0,
            "username": "ShnitzelKiller",
            "viewed": 487
        },
        "renderpass": [
            {
                "code": "// size of the windows\n#define STRIDE 0.25\n\n// depth of the holes\n#define DEPTH 0.125\n\n// raymarching\n#define FDIST 0.5\n#define STEPS 50\n#define SHADOWSTEPS 25\n#define MIN_SHADOW_STEP 0.075\n#define TOL 0.005\n#define SHARPNESS 6.5\n\n// distance function for hull geometry\nfloat map(in vec3 ro) {\n    float dist1 = length(ro-vec3(0., 1., 0.))-1.;\n    float dist2 = length(ro-vec3(0., -1., 0.))-1.;\n    float ang = iTime * 0.4564;\n    float dist3 = length(ro-vec3(1.5*cos(ang), 1., 1.5*sin(ang)))-0.4;\n    float dist4 = length(ro-vec3(-1.5*cos(ang), 1., -1.5*sin(ang)))-0.4;\n    float dist5 = length(ro-vec3(0, -1., 0.6))-0.5;\n    \n    float final_dist = -log(exp(-dist1*SHARPNESS) + exp(-dist2*SHARPNESS) + exp(-dist3*SHARPNESS) + exp(-dist4*SHARPNESS))/SHARPNESS;\n    final_dist = log(exp(final_dist*SHARPNESS) + exp(-dist5*SHARPNESS))/SHARPNESS;\n    return final_dist;\n}\n\n// normals of hull geometry\nvec3 grad(in vec3 ro) {\n    vec2 diff = vec2(TOL, 0.);\n    float dx = map(ro + diff.xyy) - map(ro - diff.xyy);\n    float dy = map(ro + diff.yxy) - map(ro - diff.yxy);\n    float dz = map(ro + diff.yyx) - map(ro - diff.yyx);\n    return normalize(vec3(dx, dy, dz));\n}\n\nfloat raymarch(in vec3 ro, in vec3 rd) {\n    float t=0.;\n    for (int i=0; i<STEPS; i++) {\n        float dist = map(ro + rd*t);\n        t += dist;\n        if (abs(dist) < TOL) {\n            return t;\n        }\n    }\n    return -1.;\n}\n\nfloat shadow_march(in vec3 ro, in vec3 rd) {\n    float t=0.;\n    for (int i=0; i<SHADOWSTEPS; i++) {\n        float dist = map(ro + rd*t);\n        t += max(dist, MIN_SHADOW_STEP);\n        if (dist < 0.) return 0.;\n    }\n    return 1.;\n}\n\n\n// Raytrace box, returns (t_in, t_out)\nvec2 box(in vec3 ro, in vec3 rd, in vec3 r, out vec3 no) {\n    vec3 dr = 1.0/rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n    \n    vec3 pout =  k - n;\n    vec3 pin =  - k - n;\n    float tout = min(pout.x, min(pout.y, pout.z));\n    float tin = max(pin.x, max(pin.y, pin.z));\n    if (tin > tout) {\n        return vec2(-1.);\n    }\n    no = -sign(rd) * step(pout.xyz, pout.zxy) * step(pout.xyz, pout.yzx);\n    return vec2(tin, tout);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n\tfloat ang = iTime * 0.3;\n    vec3 eye = 2.5*vec3(cos(ang), sin(ang), .5);\n    vec3 w = -normalize(eye);\n    vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(u*uv.x + v*uv.y + FDIST * w);\n    \n    float t = raymarch(eye, rd);\n    vec3 ro = eye + t * rd;\n\tvec3 n = grad(ro);\n    vec3 col;\n    \n    if (t > 0.) {\n        \n        //get offsets and cell IDs and their centroids/normals\n        vec3 offset = vec3(iMouse.x/iResolution.x, iTime*0.3, iMouse.y/iResolution.y);\n        ro += offset;\n        vec3 mask = 1.-step(0.9,abs(fract(ro/STRIDE)-0.5)*2.);\n        vec3 modro = fract(ro/STRIDE);\n        vec3 id = floor(ro/STRIDE);\n        ro -= offset;\n        // cell centroid, normal at centroid, and offset of centroid from surface\n        vec3 cc = (id+0.5)*STRIDE - offset;\n        vec3 nn = grad(cc);\n        float OFFSET = map(cc);\n        \n        // transform to tangent space for raytracing cavities\n        // offset depth by centroid's distance from the surface\n        vec3 uu = normalize(cross(vec3(0., 0., 1.), nn));\n        vec3 vv = cross(nn, uu);\n        mat3 rot = mat3(uu, vv, nn);\n        mat3 rott = transpose(rot);\n        vec3 rd_inner = rott * rd;\n        vec3 ro_inner = rott * (ro-cc) + vec3(0., 0., OFFSET);\n        vec3 n_inner;\n        vec3 dims = vec3(vec2(0.3*STRIDE), DEPTH);\n        vec2 t_inner = box(ro_inner, rd_inner, dims, n_inner);\n        \n        float shadow_fac = 1.;\n        vec3 sundir = normalize(vec3(1., 2., 1.5));\n        if (t_inner.y > 0. && t_inner.x < 0. && mask.x*mask.y*mask.z > 0.5) {\n            // determine inner shadows\n            vec3 sundir_inner = rott * sundir;\n            vec3 n_shadow;\n            vec3 ro_shadow = ro_inner + t_inner.y * rd_inner;\n\t\t\tvec2 t_shadow = box(ro_shadow, sundir_inner, dims, n_shadow);\n            // where the shadow ray hits the cavity in world space; if it's outside the hull, no shadow\n            ro = cc + rot * (ro_shadow - vec3(0., 0., OFFSET) + t_shadow.y * sundir_inner);\n            shadow_fac = step(0., map(ro));\n            n = rot * n_inner;\n        }\n        // compute global shadows\n        if (shadow_fac > 0.5)\n        \tshadow_fac *= shadow_march(ro + n * TOL, sundir);\n        \n        // shade\n        shadow_fac *= max(0., dot(n, sundir));\n        float ambient = abs(dot(n, -sundir));\n        col = shadow_fac * vec3(1., 1., 0.95) + ambient * vec3(0.05, 0.05, 0.04);\n    } else {\n        col = vec3(0.);\n    }\n    fragColor = vec4(pow(col, vec3(0.45)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}