{
    "Shader": {
        "info": {
            "date": "1497047404",
            "description": "Used as visuals in cooperation of polish demoscene musicians. \nReleased in wild compo at Decrunch copy party, 3 June 2017\n \nhttp://www.pouet.net/prod.php?which=70247",
            "flags": 96,
            "hasliked": 0,
            "id": "MdsfRj",
            "likes": 14,
            "name": "â™« Power Packed Alliance 7",
            "published": 3,
            "tags": [
                "tunnel",
                "demoscene"
            ],
            "usePreview": 0,
            "username": "patu",
            "viewed": 1713
        },
        "renderpass": [
            {
                "code": "/*\n\n\tTunnel7 a.k.a \"inFX.3 Tube scanner\"\n    for cooperation of polish demoscene musicians, called:\n    \n    \n    \"Power Packed Alliance\".\n    -----------------------------------\n\n\thttps://www.youtube.com/watch?v=_lSReW7eRI4\n    http://www.pouet.net/prod.php?which=70247\n\n\t\n    \n    also check my chrome extension for Shadertoy:\n    https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl?hl=pl\n\n*/\n\n\n#define getNormal getNormalHex\n\n#define FAR 70.\n#define INFINITY 1e32\n#define t iTime\n#define mt iChannelTime[1]\n#define FOV 130.0\n#define FOG .091326\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat vol = 0.;\n\nfloat hash(vec2 x){\n\treturn fract(572.612*sin(1413.7613*sin(t*41.12)+1175.2126*fract(dot(x, 1114.41256*vec2(56.0,1.37)))));\n}\nvec3 fromRGB(int r, int g, int b) {\n \treturn vec3(float(r), float(g), float(b)) / 255.;   \n}\n    \nvec3 \n    light = vec3(0.0, 2.0, 70.);\n\nvec3 lightColour = normalize(vec3(1.8, 1.0, 0.3)); \n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n\n// mercury\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2.))*2. - vec2(1.);\n\treturn c;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nstruct geometry {\n    float dist;\n    vec3 space;\n    vec3 hit;\n    vec3 sn;\n    vec3 color;\n    vec2 material;\n    int iterations;\n    float glow;\n};\n\nfloat smin( float a, float b, float k ){\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n    }    \n    \ngeometry geoU(geometry g1, geometry g2) {\n    if (g1.dist < g2.dist) return g1;\n    return g2;\n}\n\ngeometry geoI(geometry g1, geometry g2) {\n    if (g1.dist > g2.dist) return g1;\n    return g2;\n}\n\nvec3 opS2( vec3 d1, vec3 d2 )\n{\t\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\nvec3 opI2( vec3 d1, vec3 d2 ) {\n \tif (d1.x > d2.x) return d1;\n    return d2;\n}\n\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n// mercury\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// mercury\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\n// mercury\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fCross(vec3 p, vec3 size) {\n    float obj = fBox(p, size);\n    obj = opU2(obj, fBox(p, size.zxy));\n    obj = opU2(obj, fBox(p, size.yzx));\n               \n    return obj;\n}\n\nfloat sdCross( in vec3 p, vec3 b ) {\n    float inf = 40.;\n    float da = fBox(p.xyz, b.xyz);//vec3(inf, w, w));\n    float db = fBox(p.yzx, b.yxz);//vec3(w, inf, w));\n    float dc = fBox(p.zxy, b.yzx);//vec3(w, w ,inf));\n    return min(da,min(db,dc));\n} \n\ngeometry DE(vec3 p, float c)\n{\n \tconst float scale = 4.1;\n\tconst float offset = 11.0;\n    const int FRACTALITERATIONS = 5;\n    vec3 modifier = vec3(6.3, 9.4, 1.5) * c;// vec3(sin(t), sin(t / 2.), 0.);\n\tfor(int n=0; n< FRACTALITERATIONS; n++)\n\t{\n        \n        p = abs(p);\n        \n\t\tp.xz = (p.x - p.z < 0.0) ? p.zx : p.xz;\n\t\tp.zy = (p.y - p.z < 0.0) ? p.yz : p.zy;\n\n\n\t\tp.zy += 11.9;\n\n        pR(p.xz, .31364);\n\t\tpR(p.yx, .04112915);\n        \n        \n        p.xyz = scale* p.xyz - offset * (scale-1.0) * modifier.xyz;\n        \n\t}\n \tgeometry obj;\n    obj.dist = length(p.xz) * 1.3 * (pow(scale, -float(FRACTALITERATIONS))) - 0.2; \n\tobj.space = p;\n    return obj;\n}\n\n\ngeometry map(vec3 p) {\n    vec3 bp = p;\n    \n    p.x -= 8.5;\n    \n\tpModMirror2(p.yz, vec2(34.));\n    \n    vec2 c =  pMirrorOctant(p.zy, vec2(58., 38. ));\n    \n    pMirrorOctant(p.xz, vec2(12., 40.));\n    \n    geometry obj;\n  \t\n    obj = DE(p, 1. );\n    obj.material = vec2(1., 0.);\n    obj.space = p;\n    obj.color = fromRGB(204,141,96); \n    \n    geometry obj2;\n    \n    p.yx += 15.;\n    \n    obj2 = DE(p, 1.5 * sin(p.x / 10.) * 10.);\n    obj2.color = vec3(5.);\n\n    p = bp;\n    p += + vec3(-70., 20., 10. + t * 25.);\n    \n    geometry obj3;\n    \n    p += vol;\n    \n    pR(p.xz, t);\n    pR(p.yz, p.x / 10. -t);\n\n    vec3 bo = vec3(.1, 1. + vol * 10., .1);\n    \n\tbo.xz += length(p) / 15.;\n    obj3.dist = sdCross(p, bo);\n    \n    pR(p.xy, PI / 4.);\n    pR(p.zy, PI / 4.);\n    \n    obj3.dist = min(obj3.dist, sdCross(p, bo));\n    \n    pR(p.xy, PI / 2.);\n    pR(p.zy, PI / 2. );\n\n    obj3.dist = min(obj3.dist, sdCross(p, bo.zxy));\n    obj3.color = fromRGB(204,141,96) + 1. - length(p.xy) / 10.; \n    \n    obj3.material = vec2(1. , 0.);\n    obj3.dist = smin(obj3.dist, obj.dist, .4);\n    \n    obj = geoU(obj, obj3);\n    \n    \n    return obj;\n}\n\n\nfloat t_min = 0.01;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 80;\n\ngeometry trace(vec3 o, vec3 d) {\n    float omega = 1.3;//vol;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 1./ 228.;\n    \n    geometry mp = map(o);\n    mp.glow = 0.;\n    \n    float functionSign = mp.dist < 0. ? -1. : +1.;\n    float minDist = INFINITY;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n\n        mp = map(d * t + o);\n\t\tmp.iterations = i;\n        \n        minDist = min(minDist, mp.dist * 3.);\n        if (i < 116) mp.glow = pow(1. / minDist, 1.8);\n        \n        //glow = pow( 1. / minDist, 0.8);\n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength;\n   \t}\n    \n    mp.dist = candidate_t;\n    \n    \n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INFINITY;\n    \n    \n    return mp;\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 8;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = 4.;\n    float dist = 4.5;\n    float end = max(length(rd), 0.01);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).dist;\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.0), 1.0);\n}\n\n#define EPSILON .001\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).dist;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(EPSILON,0,0)).dist-d,\n                map(pos+vec3(0,EPSILON,0)).dist-d,\n                map(pos+vec3(0,0,EPSILON)).dist-d \n        \t)\n    \t);\n}\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos).dist;\n    return clamp(sdist / dist, 0.0, 1.0);\n}\n\nvec3 Sky(in vec3 rd, bool showSun, vec3 lightDir)\n{\n   float sunSize = 3.5;\n   float sunAmount = max(dot(rd, lightDir), 0.4);\n   float v = pow(1.2 - max(rd.y, 0.0), 1.1);\n   vec3 sky = mix(fromRGB(0,136,254), vec3(.1, .2, .3) * 1., v);\n   if (showSun == false) sunSize = .1;\n   sky += lightColour * sunAmount * sunAmount * 1. + lightColour * min(pow(sunAmount, 122.0)* sunSize, 0.2 * sunSize);\n   return clamp(sky, 0.0, 1.0);\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec3 sceneCol = vec3(0.0);\n    lp = sp + lp;\n    vec3 ld = lp - sp; \n    float lDist = max(length(ld / 2.), 0.001); \n    \n    ld /= lDist;\n    float diff = max(dot(sn, ld), 1.);\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), 1.), 1.);\n    vec3 objCol = obj.color;\n    sceneCol += (objCol * (diff + .15) * spec * .2);// * atten;\n    \n    return sceneCol;\n}\n\n// iq\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayOri,   // camera position\n               in vec3  rayDir ) {  // camera to point vector\n    \n    float c = .1;\n    float b = .04;\n    float fogAmount = c * exp(-rayOri.y*b) * (1.0-exp( -distance*rayDir.y*b ))/rayDir.y;\n    vec3  fogColor  = vec3(0.5,0.6,0.7);\n    \n    return mix( rgb, fogColor, fogAmount );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 ouv = fragCoord.xy / iResolution.xy;\n    vec2 uv = ouv - .5;\n    vec2 puv = uv;\n    \n    vol = (texture(iChannel0, vec2(.3, .25)).r) * .6;\n    \n    uv *= tan(radians (FOV) / 2.0) * 1.1;\n\n    float t2 = t - 35.;\n    float \n        sk = sin(-t2 * 1.4) * 166.0, \n        ck = cos(-t2 * .4) * 162.0;\n    \n    light = vec3(0., 10., -30.);        \n        \n    vec3 \n        vuv = vec3(0., 1., sin(t)), // up\n    \t\n    ro = vec3(45., -20., -t * 25.);\n    \n    ro.x += 20.;\n    \n    vec3\n        vrp =  vec3(135. - sk / 2., 50. + sk / 3. , -160.) + ro; // lookat    */\n    \n    vec3 \n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro);\n    \n    vec3 sceneColor = vec3(0.);\n    \n    vec3 lp = light + ro;\n\t\n    geometry tr = trace(ro, rd);    \n    \n    tr.hit = ro + rd * tr.dist;\n    tr.sn = getNormal(tr.hit);\t\n    \n    float sh = softShadow(tr.hit, ro + light, 9.);\n    \n    vec3 sky = vec3(0.); \n    \n    if (tr.dist < FAR) {\n        vec3 col = (doColor(tr.hit, rd, tr.sn, light, tr) * 1.) * 1.;\n        \n        sceneColor = col;\n        sceneColor *= 1.5 + length(\n            max(0., length(normalize(light.yz) - max(vec2(0.), tr.sn.yz)))             \n        );\n        sceneColor *= .2 + length(saturate(tr.sn) - normalize(light));\n        sceneColor = max(sceneColor, col);\n        sceneColor += pow(float(tr.iterations) / 40. , 2.);\n\n    } else {\n        fragColor = vec4(1.);\n        return;\n    }\n    \n    sceneColor = applyFog(sceneColor - sh, tr.dist * 2.5, ro, rd);\n    sceneColor = mix(sceneColor, lightColour, 0.1); \n    //sceneColor = mix(sceneColor, vec3(1.), clamp(tr.dist / FAR / 4., 0., 1.));\n    \n    \n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 2.5), 0.0, 1.0), 1.0);\n\tfragColor += pow(vol * 0.3,  1.2) + vol / 5.;\n    fragColor = pow(fragColor, vec4(1.4));\n    \n    \n    //fragColor = texture(iChannel0, ouv);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// smooth audio texture\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    // smooth\n    float old = pow(texture(iChannel1, uv).r, 1.2);\n    float current = pow(texture(iChannel0, uv).r, 1.2);    \n    \n    float new = max(old, current + .35);\n    \n    new -= 0.001;\n    fragColor = vec4(clamp(new, 0., 1.));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 9964,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/decrunch/power-packed-alliance"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}