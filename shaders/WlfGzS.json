{
    "Shader": {
        "info": {
            "date": "1556620281",
            "description": "Japanese new era \"Reiwa\" starts at May the 1st, 2019.",
            "flags": 0,
            "hasliked": 0,
            "id": "WlfGzS",
            "likes": 9,
            "name": "Japanese new era \"Reiwa\"",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "butadiene",
            "viewed": 1001
        },
        "renderpass": [
            {
                "code": "const float PI = 3.1415926536; \n\nvec4 qmat(vec4 q1, vec4 q2)\n{\n    return vec4(cross(q1.xyz, q2.xyz) + q2.w*q1.xyz + q1.w*q2.xyz, q1.w*q2.w - dot(q1.xyz, q2.xyz));\n}\n\nvec4 qrot(vec4 qwe, vec4 pos)\n{\n    return vec4(qmat(qmat(qwe, pos), vec4(-qwe.xyz, qwe.w)));\n\n}\n\nvec4 norqrot(vec3 bec, float rot, vec4 pos) {\n    vec4 qwe = vec4(normalize(bec)*sin(rot / 360. * PI), cos(rot / 360. * PI));\n    return qrot(qwe, pos);\n}\n//from:https://iquilezles.org/articles/distfunctions\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    b.z *= 0.3;\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) - r\n        + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n float smoothMin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\nfloat rei(vec3 p){\n    vec3 dp = p;\n    p = p+vec3(-0.06,-0.16,0.);\n    p = norqrot(vec3(0,0,1),50.,vec4(p,1)).xyz;\n    float d1 = sdRoundBox(p,vec3(0.1,0.01,0.15),0.);\n    \n    p = dp;\n    p = p+vec3(+0.06,-0.16,0.);\n    p = norqrot(vec3(0,0,1),-50.,vec4(p,1)).xyz;\n    float d2 = sdRoundBox(p,vec3(0.1,0.01,0.15),0.);\n    \n    float d;\n   d = min(d1,d2);\n    \n    p = dp;\n    p = p+vec3(+0.0,-0.12,0.);\n    p = norqrot(vec3(0,0,1),20.,vec4(p,1)).xyz;\n    float d3 = sdRoundBox(p,vec3(0.03,0.01,0.15),0.);\n    d = min(d,d3);\n    \n    p = dp;\n    p = p+vec3(+0.0,-0.08,0.);\n    p = norqrot(vec3(0,0,1),0.,vec4(p,1)).xyz;\n    float d4 = sdRoundBox(p,vec3(0.07,0.01,0.15),0.);\n    d = min(d,d4);\n    \n     p = dp;\n    p = p+vec3(-0.028,-0.048,0.);\n    p = norqrot(vec3(0,0,1),-45.,vec4(p,1)).xyz;\n    float d5 = sdRoundBox(p,vec3(0.04,0.01,0.15),0.);\n    d = min(d,d5);\n    \n     p = dp;\n    p = p+vec3(+0.0,-0.01,0.);\n    p = norqrot(vec3(0,0,1),40.,vec4(p,1)).xyz;\n    float d6 = sdRoundBox(p,vec3(0.03,0.01,0.15),0.);\n    d = min(d,d6);\n    \n\treturn d;\n}\n\nfloat wa(vec3 p){\n    vec3 dp = p;\n    p = p+vec3(+0.08,+0.05,0.);\n    p = norqrot(vec3(0,0,1),-40.,vec4(p,1)).xyz;\n    float d1 = sdRoundBox(p,vec3(0.03,0.01,0.15),0.);\n    \n    p = dp;\n    p = p+vec3(+0.07,+0.1,0.);\n    p = norqrot(vec3(0,0,1),0.,vec4(p,1)).xyz;\n    float d2 = sdRoundBox(p,vec3(0.045,0.01,0.15),0.);\n    \n    float d;\n   d = min(d1,d2);\n    \n    p = dp;\n\tp = p+vec3(+0.07,+0.14,0.);\n    p = norqrot(vec3(0,0,1),0.,vec4(p,1)).xyz;\n    float d3 = sdRoundBox(p,vec3(0.01,0.1,0.15),0.);\n    d = min(d,d3);\n    \n    p = dp;\n \tp = p+vec3(+0.087,+0.135,0.);\n    p = norqrot(vec3(0,0,1),-45.,vec4(p,1)).xyz;\n    float d4 = sdRoundBox(p,vec3(0.05,0.01,0.15),0.);\n    d = min(d,d4);\n    \n    p = dp;\n\tp = p+vec3(+0.055,+0.13,0.);\n    p = norqrot(vec3(0,0,1),40.,vec4(p,1)).xyz;\n    float d5 = sdRoundBox(p,vec3(0.03,0.01,0.15),0.);\n    d = min(d,d5);\n    \n    p = dp;\n\tp = p+vec3(-0.075,+0.15,0.);\n    p = norqrot(vec3(0,0,1),0.,vec4(p,1)).xyz;\n    float d6 = sdRoundBox(p,vec3(0.05,0.05,0.15),0.01);\n    d = min(d,d6);\n    \n    p = dp;\n\tp = p+vec3(-0.075,+0.15,0.);\n    p = norqrot(vec3(0,0,1),0.,vec4(p,1)).xyz;\n    float d7 = sdRoundBox(p,vec3(0.03,0.03,0.35),0.004);\n    d = max(d,-d7);\n    \n    \n    \n   return d;\n}\n\n\nfloat dist(vec3 p)\n{\t\n    vec3 dp =p;\n    \n    float high = min(mod(iTime,10.),10.-mod(iTime,10.));\n    \n    high = min(high,2.)/1.8;\n    \n    high = (high*high)*(3.-2.*high)+0.04*sin(iTime*6.);\n    \n    float arg = mod(iTime,10.);\n    \n    arg = (1./6.)*arg-(1./3.)+0.1;\n    \n    arg = arg*arg;\n    \n    arg = max(arg,0.);\n    \n    p = norqrot(vec3(0.,1.,0.),p.y*400.*(pow(sin(arg*6.28*5.),1.)),vec4(p,1.)).xyz;\n    p = p+vec3(0,0.88-high,0);\n    float d = min(rei(p),wa(p));\n    float d1 = length(dp+vec3(0.,1.1,0.))-0.86;\n    d = smoothMin(d,d1,40.);\n    return d;\n}\n\n\nfloat raymarch (vec3 ro,vec3 rd)\n{\n    float d;\n    float t = 0.000001;\n    float maxdistance =1000.;\n    float hit =0.000001;\n    for (float i = 0.; i < 120.; ++i) {\n\n        d = dist(ro+rd*t);\n        t +=d;\n        if (t > maxdistance || d<hit) break;\n\n    }\n\n    if (t > maxdistance || d>hit){\n        return -1.;\n    }\n    else{\n        return t;\n    }\n\n}\n\n\nvec3 getnormal( in vec3 p)\n{\n    vec2 e = vec2(0.5773,-0.5773)*0.0001;\n    vec3 nor = normalize( e.xyy*dist(p+e.xyy) + e.yyx*dist(p+e.yyx) + e.yxy*dist(p+e.yxy ) + e.xxx*dist(p+e.xxx));\n    nor = normalize(vec3(nor));\n    return nor ;\n}\n\nfloat softray( vec3 ro, vec3 rd , float hn)\n{\n    float t = 0.000001;\n    float jt = 0.0;\n    float res = 1.;\n    for (int i = 0; i < 30; ++i) {\n        jt = dist(ro+rd*t);\n        res = min(res,jt*hn/t);\n        t = t+ clamp(0.02,2.,jt);\n    }\n    return clamp(res,0.,1.);\n}\n\n\nvec4 material(vec3 pos)\n{\n\tvec4  col = vec4(1.,1.,1.,1.);\n    \n    float kt =iTime;\n    \n    float r = abs(sin(kt));\n    \n    float g = abs(sin(kt+1.05));\n    \n    float b = abs(sin(kt+2.1));\n    \n    if(length(pos+vec3(0.,1.1,0.))-0.86<0.01)\n    {\n        col = vec4 (r,g,b,1.);\n    };\n    return col;\n}\n\nvec4 lighting(vec3 pos,vec3 ro)\n{\t\n    vec3 mpos =pos;\n    vec3 normal =getnormal(mpos);\n\n    vec3 viewdir = normalize(pos-ro);\n    vec3 lightdir = normalize(vec3(0.5,0.5,-0.5));\n\n    float sha = softray(mpos,lightdir,3.3);\n    vec4 Color = material(mpos);\n\n    float NdotL = max(0.,dot(normal,lightdir));\n    vec3 R = -normalize(reflect(lightdir,normal));\n    float spec =pow(max(dot(R,-viewdir),0.),10.);\n\n    vec4 col =  sha*(Color* NdotL+vec4(spec,spec,spec,0.))+0.14*Color;\n    col.w =1.;\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n     vec2 uv = (fragCoord* 2.0 - iResolution.xy) / min(iResolution.x,iResolution.y);\n\t\n    vec2 sc =uv;\n    \n    vec3 ro = vec3(0.,0.,-2.2);\n        \n    float knt =20.;\n    \n    ro = norqrot(vec3(0.3,1.,0),iTime*knt-120.,vec4(ro,1.)).xyz;\n    \n     vec3 rd = norqrot(vec3(0.3,1.,0),iTime*knt-120.,vec4(vec3(sc,6.),0.)).xyz;\n    \n     rd = normalize(rd);\n    \n    \n    \n    float kt = iTime-uv.y;\n    \n    float r = abs(sin(kt));\n    \n    float g = abs(sin(kt+1.05));\n    \n    float b = abs(sin(kt+2.1));\n    \n    vec4 baccol = vec4(vec3(r,g,b),1.);\n    \n    float t = raymarch(ro,rd);\n    \n\tvec4 col;\n\n\tif (t==-1.) {\n\t\tcol = baccol;\n\t}\n\telse{\n\t\tvec3 pos = ro+rd*t;\n\t\tcol = lighting(pos,ro);\n\t}\n \n    fragColor = col;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}