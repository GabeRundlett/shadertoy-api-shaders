{
    "Shader": {
        "info": {
            "date": "1686827785",
            "description": "All year long I'm going to just focus on truchet tiles and the likes! (mouseable)\n2d pattern here -> https://www.shadertoy.com/view/ctKSWh",
            "flags": 0,
            "hasliked": 0,
            "id": "DtdSzM",
            "likes": 18,
            "name": "Year of Truchets #037",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "reflection",
                "truchet"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 291
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #037\n    06/15/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    Noise/FBM Based on Morgan McGuire @morgan3d\n    https://www.shadertoy.com/view/4dS3Wd (in common tab)\n*/\n\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI         3.141592653\n#define PI2        6.283185307\n\n#define MAX_DIST    35.\n#define MIN_DIST    1e-5\n\n// globals\nvec3 hit,hitPoint;\nvec2 sid,gid;\nmat2 r90,r45;\nfloat ghs,shs,sd,gd,gtk,stk,speed,flow;\n\n// constants\nconst float size = .85;\nconst float hlf = size/2.;\nconst float db = size*5.;\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 p){return fract(sin(dot(p, vec2(27.609,47.983)+iDate.z))*43758.5453);}\n\n//@iq extrude\nfloat opx(in float sdf, in float pz, in float h){\n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nvec2 map(vec3 pos){\n    vec2 res = vec2(1e5,0);\n    vec2 uv = pos.xz;\n  \n    vec2 r = (uv*size)-.5;\n    vec2 ir = floor(r);\n         r = fract(r)-.5;\n    float ck = mod(ir.x+ir.y,2.)*2.-1.;\n    gid = ir;\n    \n    vec2 id = floor(uv*size); \n    vec2 q = fract(uv*size)-.5;\n    \n    float rnd = hash21(id);\n\n    if (rnd>.5) q.x=-q.x; \n    rnd = fract(rnd*32.381);\n    \n    vec2 cv = vec2(length(q-.5),length(q+.5));\n    vec2 p = cv.x<cv.y ? q-.5:q+.5;\n    \n    float thc = .085+.035*sin(pos.x*1.135);\n    float k = length(p)-.5;k = abs(k)-thc;\n    \n    float sw = .3+.29*sin(pos.x*1.135);\n          sw+= .3+.29*cos(pos.z*.75);\n    ghs = sw;\n\n    if(rnd>.75) k = min(length(q.x)-thc,length(q.y)-thc);\n    gd = k;\n\n    float d3= opx(k+.1,pos.y,.01+sw)-.1;\n    if(d3<res.x) {\n        res = vec2(d3,2.);\n        hit=pos-vec3(0,sw,0);\n    }\n\n    float b = length(r)-.15;\n    float b1= opx(abs(b)-.01,pos.y,ck>.5?1.:.2)-.0025;\n    if(b1<res.x) {\n        gd = b;\n        res = vec2(b1,4.);\n        hit=vec3(r.x,pos.y,r.y);\n    }\n\n    float gnd = pos.y+.01;\n    if(gnd<res.x) {\n        res = vec2(gnd,1.);\n        hit=pos;\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd) {\n    float d = 0., m = 0.;\n    for(int i=0;i<100;i++){\n        vec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32?ray.x*.35:ray.x*.85;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\nvec3 hue(in vec3 t) { \n    t.x+=10.;\n    return .45 + .375*cos(PI2*t.x*(vec3(.985,.98,.95)*vec3(0.941,0.690,0.337))); \n}\n\nvec3 FC = vec3(.3);\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    vec2 ray = marcher(ro,rd);\n    d=ray.x;m=ray.y;\n    \n    // save globals post march\n    hitPoint = hit;  \n    shs = ghs;\n    sd = gd;\n    sid = gid;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(2.,12.,5.);\n        vec3 l = normalize(lpos-p);\n        \n        float diff = clamp(dot(n,l),.09,.99);\n        \n        float shdw = 1.;\n        for( float t=.01; t < 12.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 14.*h/t);\n            t += h;\n            if( shdw<MIN_DIST ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n        \n        vec3 h = vec3(.25);\n        \n        if(m==1.) {\n            float px = 4./R.x;\n            \n            vec3 clr = hue(vec3(hitPoint.z*.08,1.,.5));\n            float ff = fbm(hitPoint.xz*3.);\n            \n            ff=smoothstep(.15,.16,.5+.5*sin(ff*22.));\n            h = mix(vec3(.029),vec3(.1),ff);  \n   \n            float d = smoothstep(px,-px,abs(sd-.045)-.05);\n            float d2 = smoothstep(px,-px,sd-.045);\n            h = mix(h, vec3(.03), d);\n            h = mix(h, clr*.5, d2);\n            \n            ref = vec3(clamp(.55-d,0.,1.));\n        }\n        \n        if(m==2.) { \n            h = hue(vec3(hitPoint.z*.08,1.,.5));\n            ref = h; \n        }\n\n        if(m==4.) { \n            hitPoint.xz*=rot(speed);\n            vec2 uv = vec2(atan(hitPoint.z,hitPoint.x)/PI2,hitPoint.y);\n            vec2 id = floor(uv*10.)+sid;\n            vec2 q = fract(uv*10.)-.5;\n            vec3 clr = hue(vec3(p.z*.08,1.,.5));\n            float ck =mod(id.x+id.y,2.)*2.-1.;\n            float rnd = hash21(id);\n            float rhs = hash21(sid);\n\n            float px = d*.01;\n\n            if (rnd>.5) q.x=-q.x; \n\n            vec2 cv = vec2(length(q-.5),length(q+.5));\n            vec2 p2 = cv.x<cv.y ? q-.5:q+.5;\n\n            float d = abs(length(p2)-.5)-.15;\n            if(fract(rnd*32.381)>.75) d = min(length(q.x),length(q.y))-.15;\n            if(rhs>.5) {\n              d=smoothstep(px,-px,d);\n            } else if(rhs>.3){\n              d = length(p2)-.5;\n              d = (ck>.5^^rnd<.5) ? smoothstep(-px,px,d): smoothstep(px,-px,d);\n            } else {\n              d = smoothstep(-px,px,abs(abs(d)-.15)-.025);\n            }\n\n            h = mix(clr*.5,vec3(.08),d); \n            ref = vec3(d)*.25; \n        }\n \n        C = (diff*h);\n\n        ro = p+n*.005;\n        rd = reflect(rd,n);\n    } \n    return vec4(C,d);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n\n    speed = T*.23;\n    flow = T*.133;\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(12,0,5.25);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    float x = M.xy==vec2(0) || M.z<0. ? 0. : -(M.y/R.y*.125-.0625)*PI;\n    float y = M.xy==vec2(0) || M.z<0. ? 0. : -(M.x/R.x*.5-.25)*PI;\n\n    float ff = -T*.03;\n    mat2 rx = rot(-.86-x), ry = rot(-.78-ff-y);\n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(.95);\n    float d =0.,a=0.;\n    \n    // up to 4 is good - 2 average bounce\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.)a=pass.w;\n    }\n           \n    C = mix(FC,C,exp(-.00008*a*a*a*a*a));\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float rnd (in vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\n// this works on OSX/PC without fracture lines.\nfloat noise (in vec2 uv) {\n    vec2 i = floor(uv), f = fract(uv);\n    float a = rnd(i);\n    float b = rnd(i + vec2(1, 0));\n    float c = rnd(i + vec2(0, 1));\n    float d = rnd(i + vec2(1, 1));\n    vec2 u = f * f * (3. - 2. * f);\n    return mix(a, b, u.x) + (c - a)* u.y * (1. - u.x) + (d - b) * u.x * u.y;\n}\n\nconst vec2 shift = vec2(100.);\nconst mat2 r3 = mat2(cos(.5), sin(.5),-sin(.5), cos(.5));\nfloat fbm ( in vec2 uv) {\n    float v = .0, a = .5;\n    for (float i = 0.; i < 3.; ++i) {\n        v += a * noise(uv);\n        uv = r3 * uv * 2. + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}