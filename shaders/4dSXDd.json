{
    "Shader": {
        "info": {
            "date": "1417127198",
            "description": "A fractal that behaves like a Rubik's cube with a bit of a dyson sphere feel.",
            "flags": 0,
            "hasliked": 0,
            "id": "4dSXDd",
            "likes": 106,
            "name": "Symmetric Origins",
            "published": 3,
            "tags": [
                "procedural",
                "fractal",
                "raymarch"
            ],
            "usePreview": 0,
            "username": "otaviogood",
            "viewed": 8447
        },
        "renderpass": [
            {
                "code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// This will lower the framerate, but looks kinda cool\n//#define TOO_MUCH_FRACTAL\n\n//#define MOVING_SUN\nfloat outerSphereRad = 3.5;\n\n// noise functions\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nfloat PI=3.14159265;\n\n// Variables for animating and rotating the sides of the object\nfloat chunkAnim = 0.0;\nmat3 rotMat;\nvec3 rotDir;\nfloat rotAmount;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 208.0, 100.0) / 4255.0;\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.015 / dist;\n\tsunIntensity = pow(sunIntensity, 0.3)*100.0;\n\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.0425;\n}\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 / dist;\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.025;\n}\n\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.71;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\n// Total hack of the spiral noise function to get a rust look\nfloat RustNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    float pn = noise(p*0.125);\n    pn += noise(p*0.25)*0.5;\n    pn += noise(p*0.5)*0.25;\n    pn += noise(p*1.0)*0.125;\n    for (int i = 0; i < 7; i++)\n    {\n        //n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        float wave = saturate(cos(p.y*0.25 + pn) - 0.998);\n       // wave *= noise(p * 0.125)*1016.0;\n        n += wave;\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.4733;\n    }\n    return n*500.0;\n}\n\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\n\n// This is the big money function that makes the crazy fractally shape\nfloat DistanceToObject(vec3 p)\n{\n    //p += (1.0/p.y)*0.6;\n\n    // Rotate, but only the part that is on the side of rotDir\n    if (dot(p, rotDir) > 1.0) p *= rotMat;\n\n    // Repeat our position so we can carve out many cylindrical-like things from our solid\n    vec3 rep = fract(p)-0.5;\n    //final = max(final, -(length(rep.xz*rep.xz)*1.0 - 0.0326));\n    float final = -(length(rep.xy*rep.xz) - 0.109);\n    final = max(final, -(length(rep.zy) - 0.33));\n\n    //final = max(final, -(length(rep.xz*rep.xz) - 0.03));\n    //final = max(final, -(length(rep.yz*rep.yz) - 0.03));\n    //final = max(final, -(length(rep.xy*rep.xy) - 0.030266));\n\n    // Repeat the process of carving things out for smaller scales\n    vec3 rep2 = fract(rep*2.0)-0.5;\n    final = max(final, -(length(rep2.xz)*0.5 - 0.125));\n    final = max(final, -(length(rep2.xy)*0.5 - 0.125));\n    final = max(final, -(length(rep2.zy)*0.5 - 0.125));\n\n    vec3 rep3 = fract(rep2*3.0)-0.5;\n    final = max(final, -(length(rep3.xz)*0.1667 - 0.25*0.1667));\n    final = max(final, -(length(rep3.xy)*0.1667 - 0.25*0.1667));\n    final = max(final, -(length(rep3.zy)*0.1667 - 0.25*0.1667));\n\n#ifdef TOO_MUCH_FRACTAL\n    vec3 rep4 = fract(rep3*3.0)-0.5;\n    final = max(final, -(length(rep4.xz)*0.0555 - 0.25*0.0555));\n    final = max(final, -(length(rep4.xy)*0.0555 - 0.25*0.0555));\n    final = max(final, -(length(rep4.yz)*0.0555 - 0.25*0.0555));\n\n    vec3 rep5 = fract(rep4*3.0)-0.5;\n    final = max(final, -(length(rep5.xz)*0.0185 - 0.25*0.0185));\n    final = max(final, -(length(rep5.xy)*0.0185 - 0.25*0.0185));\n    final = max(final, -(length(rep5.yz)*0.0185 - 0.25*0.0185));\n#endif\n\n    // Cut out stuff outside of outer sphere\n    final = max(final, (length(p) - outerSphereRad));\n    // Carve out inner sphere\n    final = max(final, -(length(p) - 2.8));\n    //final = max(final, abs(p.x) - 2.0);\t// for that space station look\n    //final = (length(p) - outerSphereRad);\t// for debugging texture and lighting\n    // Slice the object in a 3d grid so it can rotate like a rubik's cube\n    float slice = 0.02;\n    vec3 grid = -abs(fract(p.xyz)) + slice;\n    final = max(final, grid.x);\n    final = max(final, grid.y);\n    final = max(final, grid.z);\n    //final = min(final, abs(p.y));\n    return final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0 + iTime * 0.166;\n\tfloat my=-iMouse.y/iResolution.y*10.0 + sin(iTime * 0.3)*0.8+0.1;//*PI/2.01;\n    // move camera in and out of the sphere\n    float smallTime = iTime*0.2;\n    float inOut = pow(abs(-cos(smallTime)), 0.6)* sign(-cos(smallTime));\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(3.35+inOut*2.0);\n\n    // add randomness to camera for depth-of-field look close up.\n    //camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 relVec = normalize(worldPix - camPos);\n\n\t// -------------------------------- animate ---------------------------------------\n    float localTime = iTime*0.5;\n    float floorTime = floor(localTime);\n    float zeroToOne = max(0.0,fract(localTime)*1.0-0.0);// *4.0-3.0);\n    // This is the 0..1 for the rotation\n    chunkAnim = smoothstep(0.0, 1.0, zeroToOne);\n    // This is for brightening the outer sphere when a rotation happens\n    float pulse = saturate(-log(zeroToOne*30.0)+2.0);\n\n    //float mft = mod(floorTime, 6.0);\n    // Let's make it rotate a random part every time\n    float mft = Hash1d(floorTime * 2.34567);\n    mft = floor(mft * 5.9999);\t// get a random [0..6) integer\n    // randomize where the rotation slice is\n    float uglyRand = Hash1d(floorTime*1.234567);\n    uglyRand = floor(uglyRand*2.999);\t// get a random [0..3) integer\n    uglyRand = 1.0 / (uglyRand + 1.0);\n\n    // Check which axis we should rotate on and make a matrix for it.\n    if (mft <= 1.0)\n    {\n        rotAmount = PI;\n        float cos = cos(chunkAnim * rotAmount);\n        float sin = sin(chunkAnim * rotAmount);\n        rotMat = mat3(1.0, 0.0, 0.0,\n                      0.0, cos, sin,\n                      0.0, -sin, cos);\n        rotDir = vec3(uglyRand, 0.0, 0.0);\n    }\n    else if (mft <= 3.0)\n    {\n        rotAmount = PI;\n        float cos = cos(chunkAnim * rotAmount);\n        float sin = sin(chunkAnim * rotAmount);\n        rotMat = mat3(cos, 0.0, -sin,\n                      0.0, 1.0, 0.0,\n                      sin, 0.0, cos);\n        rotDir = vec3(0.0, uglyRand, 0.0);\n    }\n    else\n    {\n        rotAmount = PI;\n        float cos = cos(chunkAnim * rotAmount);\n        float sin = sin(chunkAnim * rotAmount);\n        rotMat = mat3(cos, sin, 0.0,\n                      -sin, cos, 0.0,\n                      0.0, 0.0, 1.0);\n        rotDir = vec3(0.0, 0.0, uglyRand);\n    }\n    if (mod(floorTime, 2.0) == 0.0) rotDir = -rotDir;\n\n\t// --------------------------------------------------------------------------------\n\tfloat dist = 0.15;\n\tfloat t = 0.2 + Hash2d(uv)*0.1;\t// fade things close to the camera\n\tfloat inc = 0.02;\n\tfloat maxDepth = 11.0;\n\tvec3 pos = vec3(0,0,0);\n    float glow = 0.0;\n\t// ray marching time\n    for (int i = 0; i < 110; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        if ((t > maxDepth) || (abs(dist) < 0.001)) break;\n        pos = camPos + relVec * t;\n        // *******************************************************\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry.\n        // *******************************************************\n        dist = DistanceToObject(pos);\n        // Do some tricks for marching so that we can march the inner glow sphere\n        float lp = length(pos);\n        //if (lp > outerSphereRad + 0.9) break;\n        float inv = max(0.0, 0.1*dist / lp - 0.1);\n        dist = min(max(0.15,lp*0.6 - 0.1), dist);\n        glow += inv;//0.001\n        glow += 0.0025;\n\n        // no deformations messing up the distance function this time. Hurray for getting the math right!\n        t += dist;//*0.9995;\t// because deformations mess up distance function.\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n#ifdef MOVING_SUN\n\tvec3 sunDir = normalize(vec3(sin(iTime*0.047-1.5), cos(iTime*0.047-1.5), -0.5));\n#else\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\n#endif\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n\tif (abs(dist) < 0.75)\n    //if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(0.0025, 0, 0);\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy),\n                           dist - DistanceToObject(pos - smallVec.yxy),\n                           dist - DistanceToObject(pos - smallVec.yyx));\n\n        vec3 normal = normalize(normalU);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff\n        float ambientS = 1.0;\n        //ambientS *= saturate(DistanceToObject(pos + normal * 0.1)*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2)*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4)*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8)*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6)*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\n        //ambient = max(0.05, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.05;\n\t\tfor (int i = 0; i < 30; i++)\n        {\n            vec3 tempPos = pos + sunDir * iter;\n            //if (dot(tempPos, tempPos) > outerSphereRad*outerSphereRad+0.8) break;\n            if (iter > outerSphereRad + outerSphereRad) break;\n            float tempDist = DistanceToObject(tempPos);\n\t        sunShadow *= saturate(tempDist*50.0);\n            if (tempDist <= 0.0) break;\n            //iter *= 1.5;\t// constant is more reliable than distance-based???\n            iter += max(0.01, tempDist)*1.0;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(relVec, normal);\n\n        // make sure the texture gets rotated along with the geometry.\n        vec3 posTex = pos;\n        if (dot(pos, rotDir) > 1.0) posTex = pos * rotMat;\n        posTex = abs(posTex);\t// make texture symetric so it doesn't pop after rotation\n\n        // make a few frequencies of noise to give it some texture\n        float n =0.0;\n        n += noise(posTex*32.0);\n        n += noise(posTex*64.0);\n        n += noise(posTex*128.0);\n        n += noise(posTex*256.0);\n        n += noise(posTex*512.0);\n        n *= 0.8;\n        normal = normalize(normal + n*0.1);\n\n        // ------ Calculate texture color  ------\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\n        vec3 rust = vec3(0.65, 0.25, 0.1) - noise(posTex*128.0);\n        texColor *= smoothstep(texColor, rust, vec3(saturate(RustNoise3D(posTex*8.0))-0.2));\n\n        // make outer edge a little brighter\n\t\ttexColor += (1.0 - vec3(19.0, 5.0, 2.0) * length(normalU))*ambientS;\n        // apply noise\n        texColor *= vec3(1.0)*n*0.05;\n        texColor *= 0.7;\n        texColor = saturate(texColor);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(0.6) * saturate(dot(sunDir, normal)) * sunShadow;\n        // weighted average the near ambient occlusion with the far for just the right look\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\n        // a red and blue light coming from different directions\n        lightColor += (vec3(1.0, 0.2, 0.4) * saturate(-normal.z *0.5+0.5))*pow(ambientAvg, 0.5);\n        lightColor += (vec3(0.1, 0.5, 0.99) * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.5);\n        // blue glow light coming from the glow in the middle of the sphere\n        lightColor += vec3(0.3, 0.5, 0.9) * saturate(dot(-pos, normal))*pow(ambientS, 0.3);\n//        lightColor *= ambient;\n        lightColor *= 4.0;\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n        // sun reflection to make it look metal\n        finalColor += vec3(1.0)*pow(n,4.0)* GetSunColorSmall(ref, sunDir) * sunShadow;// * ambientS;\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\n        //finalColor = mix(vec3(1.0, 0.41, 0.41)*skyMultiplier + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0*sunSet, finalColor, exp(-t*0.003));\n        // pulse the outer edge color when something is about to rotate\n        if (dot(pos, rotDir) > 1.0) finalColor += vec3(0.2, 1.4, 0.8)*pulse*saturate(0.000001 / pow(abs(length(pos)-outerSphereRad), 2.0))*2.0;\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n        //finalColor = saturate(GetSunColorSmall(relVec, sunDir)*0.95-0.01);\n    }\n    // add the ray marching glow\n    finalColor += vec3(0.3, 0.5, 0.9) * glow;\n\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= 1.3;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}