{
    "Shader": {
        "info": {
            "date": "1548158730",
            "description": "ray marching",
            "flags": 0,
            "hasliked": 0,
            "id": "3s2GR1",
            "likes": 1,
            "name": "[Ese] ray marching",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "Eseris",
            "viewed": 263
        },
        "renderpass": [
            {
                "code": "#define POTATO_COMPUTER\n\n#ifdef POTATO_COMPUTER\nconst int MARCHING_STEPS = 160;\nconst int ALIASING_STEPS = 1;\nconst float MIN_DIST = 0.;\nconst float MAX_DIST = 40.;\nconst float EPSILON = 1e-2;\n#else\nconst int MARCHING_STEPS = 200;\nconst int ALIASING_STEPS = 2;\nconst float MIN_DIST = 0.;\nconst float MAX_DIST = 40.;\nconst float EPSILON = 1e-3;\n#endif\n\nstruct Light {\n\tvec3 iamb; // ambient intensity\n\tvec3 idiff; // diffuse intensity\n\tvec3 ispec; // specular intensity\n\tvec3 pos;\n\tfloat shininess;\n};\n\nstruct Material {\n\tvec3 amb; // ambient constant\n\tvec3 diff; // diffuse constant\n\tvec3 spec; // specular constant\n};\n\nmat2 rot(float a) {\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat sdSphere(vec3 p, float radius) {\n\treturn length(p) - radius;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nvec3 repeat(vec3 p, vec3 s) {\n    return mod(p, s) - .5 * s;\n}\n\nfloat map(vec3 p) {\n    float d = 1e10;\n    \n    {\n\t\tvec3 q = p;\n        q.yz *= rot(.2 * cos(iTime));\n\t\tq.zx *= rot(sin(.34* iTime));\n        q.z -= 3. * iTime;\n    \td = sdBox(repeat(q, vec3(5.)), vec3(1.));\n        d -= .1;\n    }\n       \n    //d = max(d, p.y);\n\treturn d;\n}\n\nvec3 mapGradient(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n\t));\n}\n\nfloat rayProcess(vec3 camPos, vec3 rayDir, float start, float end) {\n\tfloat depth = start;\n\tfor(int i = 0; i < MARCHING_STEPS; ++i) {\n\t\tfloat dist = map(camPos + depth * rayDir);\n\t\tif(dist < EPSILON) return depth;\n\t\tdepth += dist;\n\t\tif(dist >= end) return end;\n\t}\n\treturn end;\n}\n\nvec3 rayDirection(float camAngle, vec2 coord) {\n\tvec2 uv = (coord - .5) * iResolution.xy;\n\tfloat focalDist = iResolution.y / 2. / tan(radians(camAngle) / 2.);\n\treturn normalize(vec3(uv, -focalDist));\n}\n\nvec3 applyLight(Material mat, Light light, vec3 p, vec3 eye) {\n\tvec3 n = mapGradient(p);\n\tvec3 l = normalize(light.pos - p);\n\tvec3 v = normalize(eye - p);\n\tvec3 r = reflect(-l, n);\n\n\t// ambient lighting\n\tvec3 col = mat.amb * light.iamb;\n\n\t// diffuse lighting\n    if(dot(l, n) > 0.)\n\t\tcol += mat.diff * light.idiff * dot(l, n);\n\n\t// specular lighting\n    if(dot(r, v) > 0.)\n\t\tcol += mat.spec * light.ispec * pow(dot(r, v), light.shininess);\n    \n    return col;\n}\n\nvec3 processLight(vec3 eye, vec3 p) {\n\tMaterial mat;\n\tmat.amb  = vec3(.2);\n\tmat.diff = vec3(.7, .3, .3); \n\tmat.spec = vec3(1.);\n\n\tLight light;\n\tlight.iamb = vec3(.5, .6, .7);\n\tlight.idiff = vec3(.5);\n\tlight.ispec = vec3(.4);\n\tlight.pos = vec3(2., 5., 0.);\n\tlight.shininess = 6.;\n\n\tvec3 col = applyLight(mat, light, p, eye);\n\treturn col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 tot = vec3(0.);\n    \n    for(int i = 0; i < ALIASING_STEPS; ++i) {\n        for(int j = 0; j < ALIASING_STEPS; ++j) {\n            vec2 offset = vec2(i, j) / 2. - .5;\n            vec3 camPos = vec3(0., 0., 4.);\n            vec3 dir = rayDirection(90., (fragCoord + offset) / iResolution.xy);\n            float depth = rayProcess(camPos, dir, MIN_DIST, MAX_DIST);\n\n            vec3 col = vec3(0.);\n            if(depth < MAX_DIST - EPSILON) {\n                col = processLight(camPos, camPos + depth * dir);\n            }\n            \n            // fog\n            col *= pow(smoothstep(MAX_DIST, 10., depth), 2.);\n            \n            // gamma\n            tot += pow(col, vec3(1. / 1.7));\n        }\n    }\n    \n    tot /= float(ALIASING_STEPS * ALIASING_STEPS);\n\tfragColor = vec4(tot, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}