{
    "Shader": {
        "info": {
            "date": "1634937022",
            "description": "Inverting the texture values and using them as a heightmap to the plane. Finally bending the plane to emulate a circular surface.  All of this combined with a scaled sphere and moving camera create a speedy effect.",
            "flags": 0,
            "hasliked": 0,
            "id": "7sGXzR",
            "likes": 5,
            "name": "Surfing in the moon",
            "published": 3,
            "tags": [
                "moon",
                "speed"
            ],
            "usePreview": 0,
            "username": "LongJohnny",
            "viewed": 267
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DIST 200.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sinDisplacement(vec3 p, float strength) {\n    return sin(strength*-p.y);\n}\n\nfloat smin(float a, float b, float k) {\n    \n    /*float h = max(0., min(1., (b - a)/k + .5));\n    float m = h * (1. - h) * k;\n       \n    return a * k + b * (1. - k) - m * .5;*/\n    \n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    \n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    // Project ap onto ab \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    // Projection cannot exceed the length of ab\n    t = clamp(t, 0., 1.);\n    \n    // Closest point in line segment\n    vec3 c = a + ab * t;\n    \n    // Distance to line segment\n    float d = length(p - c);\n    \n    // Distance to capsule\n    return d - r;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.)) +min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n    float x = length(p.xz) - r.x;\n    float y = p.y;\n    return sqrt(x*x + y*y) - r.y;\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h) {\n    \n    vec2 uv = p.xz;\n    float noise = texture(iChannel1, uv * 0.005).r;\n    \n   \n    return dot(p, normalize(n)) - (h - noise*6.);\n}\n\nfloat opCheapBend(vec3 p )\n{\n    const float k = -0.001; // or some other amount\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n   \n    \n    return sdPlane(q - vec3(0., 0., iTime * 100. + cos(iTime)+1. * 200.), vec3(cos(iTime * 1.5) * .15, 1.,0.),-3.);\n}\n\n\nvec4 GetDist(vec3 p) {\n    vec3 c = vec3(7.);\n    //p = mod(p+0.5*c,c)-0.5*c;\n    \n    float k = sin(iTime * 2.); // or some other amount\n    float e = cos(k*p.z);\n    float s = sin(k*p.z);\n    mat2  m = mat2(e,-s,s,e);\n    //p = vec3(m*p.xy,p.y);\n    \n    // From -1 to 2\n    float pulse = abs(cos(iTime * 4.));\n\n    vec3 sp = p;\n    sp *= vec3(1.,3.,.2);\n    sp -= vec3(cos(iTime*2.)*2., sin(iTime * 2.)*2., (cos(iTime) - 1.) * 3.);\n   \n    //sp. *= Rot(iTime);\n    float d = sdSphere(sp, 1.2);\n    float ds = sdSphere(p + vec3(0., 0.8 + sin(iTime) * 2., 1.2), 0.7);\n    float ds2 = sdSphere(p + vec3(0., 0.8 + sin(iTime) * 2., -1.2), 0.7);\n   \n    float d2 = sdBox(p - vec3(0.,-3., 0. ), vec3(10., .1, 10.));\n    \n    float d3 = sdCapsule(p, vec3(0., 1., 0.), vec3(.0, -1., 0.), 1.2);\n    \n    float d4 = sdTorus(p - vec3(0., pulse, 0.), vec2(1.0, 0.2));\n    \n    //float d5 = sdPlane(p - vec3(0., 0., iTime * 100.), vec3(cos(iTime * 1.5) * .15, 1.,0.),-3.);\n    float d5 = opCheapBend(p);\n    float sk = 1.;\n    \n    float mi = min(d, d5);\n    \n    return mi == d ? vec4(.5,0.01,.01,d) : vec4(vec3(.1),d5);\n}\n\nvec4 RayMarch(vec3 rayOrigin, vec3 rayDirection) {\n\n    // Current marching distance\n\tfloat currentDistance=0.;\n    vec4 curr;\n    \n    for(int i=0; i < MAX_STEPS; ++i) {\n    \n        // March in the ray direction\n    \tvec3 p = rayOrigin + rayDirection*currentDistance;\n        \n        // Get direction to solid using the distance function\n        curr = GetDist(p);\n        float dS = curr.w;\n        \n        // Increase marching distance\n        currentDistance += dS;\n        \n        // Stop ray marching when max distance is surpassed \n        // or when the distance is very small\n        if(currentDistance>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec4(curr.xyz, currentDistance);\n}\n\nfloat IsInShadow(vec3 rayOrigin, vec3 rayDirection) {\n    \n    float currentDistance = 0.;\n    float res = 1.;\n    \n    for (int i = 0; i < 200; ++i) {\n\n        // Get direction to solid using the distance function\n        float dS = GetDist(rayOrigin + rayDirection*currentDistance).w;\n        \n        // Stop ray marching when max distance is surpassed \n        // or when the distance is very small\n        if(dS < 0.001) return 0.;\n        \n        res = min(res, 9.*dS/currentDistance );\n        \n        // Increase marching distance\n        currentDistance += dS;\n    }\n    return res;\n\n}\n\nvec3 GetNormal(vec3 p) {\n\tconst float h = 0.1; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*GetDist( p + k.xyy*h ).w + \n                      k.yyx*GetDist( p + k.yyx*h ).w + \n                      k.yxy*GetDist( p + k.yxy*h ).w + \n                      k.xxx*GetDist( p + k.xxx*h ).w );\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n\n    // Ray from pixel to the scene origin\n    vec3 f = normalize(l-p);\n       \n    // Finding the ray direction\n    vec3 r = normalize(cross(vec3(0,1,0), f));\n    vec3 u = cross(f,r);\n   \n    vec3 c = f*z;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // Moving uv's to the [0,1] range and correcting porportions\n    // using the aspect ratio\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= (iResolution.y/iResolution.x);\n\t//vec2 m = iMouse.xy/iResolution.xy;\n\n    float speed = iTime * 10.;\n    \n    float x = cos(iTime) * 3.;\n    vec3 ro = vec3(x, exp(abs(x) - 4.)*10. + 3.,20.);\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 sceneOrigin = vec3(0.);\n    \n    vec3 rd = GetRayDir(uv, ro, sceneOrigin, 1. );\n    vec3 col = vec3(0);\n       \n    vec4 obj = RayMarch(ro, rd);\n    float d = obj.w;\n    \n    vec3 lightDir = normalize(vec3(0., 1., 2.));\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = refract(rd, n, .5);\n        \n        float shadow = IsInShadow(p + n*SURF_DIST*10., lightDir);\n        \n        //vec3 cr = texture(iChannel0, r).rgb;\n\n        float dif = dot(normalize(n), lightDir) * .5 + .5;\n        col = obj.xyz * dif * (shadow*.9 + .1);\n    } else {\n        col = vec3(.0, .0, .0);\n    }\n    \n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}