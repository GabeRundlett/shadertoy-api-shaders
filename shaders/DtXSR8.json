{
    "Shader": {
        "info": {
            "date": "1674230925",
            "description": "Looking into the depth with shadows never reaching the light.",
            "flags": 0,
            "hasliked": 0,
            "id": "DtXSR8",
            "likes": 1,
            "name": "Bouncing Orb",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "QuantumSuper",
            "viewed": 203
        },
        "renderpass": [
            {
                "code": "// Bouncing Orb v0.91-220120\n// Simple distance-aided ray marching with floor and spheres.\n// Inspired by The Art of Code's ray marching tutorial: youtu.be/PGtv-dBi2wE\n\n// DEFINITIONS\n// Calculation precision\n#define MAX_STEPS 70\n#define MAX_DISTANCE 110.0\n#define MIN_DISTANCE 0.01\n\n// Global objects, lights & cam initializations\nstruct object{\n\tint type; //0: floor; 1: sphere\n\tvec4 param; //horizontal plane: y, y, y, y; sphere: x, y, z, radius\n};\nobject[4] objects; // ...is there a better way to get iterability of different objects?\nstruct light{ //spotlights\n\tvec3 pos; //x,y,z; position of light\n\tvec3 col; //(r,g,b)*amp; color & brightness of light\n};\nlight[2] lights;\nfloat[2] animTime; //time for object operations\nfloat camTime; //time for camera operations\n\n// FUNCTIONS\n// Calculate distance from position p to next object\nfloat getDistance(vec3 pos){\t\n\tfloat minDist = MAX_DISTANCE; //max minDist\n\t\n\tfor (int n=0; n<objects.length(); n++){ //get the distance to each object\n\t\tswitch (objects[n].type){\n\t\t\tcase 0: //hPlane\n\t\t\t\t//minDist = min(minDist, pos.y-objects[n].param.y); break; //hPlane static\n                minDist = min(minDist, pos.y-objects[n].param.y+0.2*sin(animTime[1])*sin(4.0*animTime[0]-length(pos)/0.2)*smoothstep(22.*clamp(0.9+cos(animTime[1]),0.,2.),-0.1,pos.x*pos.x+pos.z*pos.z)); break; //hPlane flubber, ?BUG for long iTime: pattern breaks\n\t\t\tcase 1: //sphere\n\t\t\t\tminDist = min(minDist, length(pos-objects[n].param.xyz)-objects[n].param.w); break;\n\t\t\tcase 2: //flubber sphere\n\t\t\t\tminDist = min(minDist, length(pos-objects[n].param.xyz)-objects[n].param.w+0.1*cos(animTime[1])*smoothstep(-0.2,1.2,abs(cos(pos.x*pos.y*pos.z)))); break;\n\t\t}\n\t}\n\t\n\treturn minDist;\n}\n\n// March the ray through tracing spheres\nfloat rayMarch(vec3 rayOrigin, vec3 rayDirection){\n\tfloat rayLength = MIN_DISTANCE; \n\tfloat radSphere;\n\t\n\tfor (int n=0; n<MAX_STEPS; n++){\n\t\tradSphere = getDistance(rayOrigin+rayLength*rayDirection); //get sphere\n\t\trayLength += radSphere; //march\n\t\tif (rayLength>MAX_DISTANCE || abs(radSphere)<MIN_DISTANCE) break;\n\t}\n\t\n\treturn rayLength;\n}\n\n// Estimate the surface normal at position p\nvec3 guessNormal(vec3 pos){\n\tvec2 tangent = vec2(MIN_DISTANCE, 0);\n\t\n\tvec3 normal = getDistance(pos) - vec3(\n\t\tgetDistance(pos-tangent.xyy),\n\t\tgetDistance(pos-tangent.yxy), \n\t\tgetDistance(pos-tangent.yyx)\n\t\t);\n\t\t\n\treturn normalize(normal);\n}\n\n// Calculate light diffusion\nvec3 getSpotlight(vec3 pos, light myLight){\n\tvec3 lightDirection = normalize(myLight.pos - pos);\n\tvec3 surfaceNormal = guessNormal(pos);\n\t\n\tfloat diffLight = clamp(dot(lightDirection, surfaceNormal), 0.0, 1.0); //intensity\n    diffLight = pow(diffLight,3.)*1.5; //?fake shine\n\tif (rayMarch(pos + 2.0*MIN_DISTANCE*surfaceNormal, lightDirection) < length(myLight.pos-pos)) diffLight *= 0.2; //shadows at 20%\n\treturn myLight.col*vec3(diffLight); //color \n}\n\n// MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t// Misc initialization\n    vec3 col = vec3(0); //fragColor\n\tvec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //normalized true-scaling pixel uv mapping, longer edge square -1..1\n    float myDist; // ray length\n\tanimTime = float[]( //time for object operations\n\t\tmod(2.133333*iTime, 6.283185), //std, mod 2pi because of ?overflow: bug at getDistance case 0 if not mod\n\t\tmod(0.2666666*iTime, 6.283185) //slow\n\t);\n    \n    // Camera initialization\n    vec3 camPos = vec3(0, 2.5, 0); //ray origin, static\n\t//vec3 camDir = normalize(vec3(uv.x, uv.y, 1)); //ray direction, static straight\n\tvec3 camDir = normalize(vec3(uv.x, uv.y*cos(.15)-sin(.1), uv.y*sin(.15)+cos(.1))); //ray direction, static, slightly downwards\n\tcamTime = 0.2*iTime; //time for cam operations\n\tcamPos += vec3(9.*sin(camTime), 0,-9.*cos(camTime)); //rotating on circle\n    camDir = vec3( //rotation on xz-plane about (0,0,0)\n\t\tcamDir.x*cos(camTime)-camDir.z*sin(camTime),\n\t\tcamDir.y,\n\t\tcamDir.x*sin(camTime)+camDir.z*cos(camTime)\n\t);\n\t\n\t// Object initializations\n\tobjects = object[](\n\t\tobject(0, vec4(0)), //hPlane\n\t\tobject(2, vec4(0,2.9,0,2.0+cos(animTime[1]))), //sphere 1, shrink & grow\n        object(1, vec4(-3,0.4+3.*abs(sin(animTime[0])),5,0.5)), //sphere 2, bounce up & down\n\t\tobject(1, vec4(3,0.4+3.*abs(cos(1.5*animTime[0])),-5,0.5)) //sphere 3, bounce up & down\n\t);\n\t\n\t// Spotlight initialization\n    lights = light[]( //light pos, light col\n\t\tlight(vec3(9.*cos(camTime+.1), 3.5, 9.*sin(camTime+.1)), //cam syncronized rotation\n\t\t\tnormalize(vec3(245.*(1.+0.7*cos(animTime[1])),10,193))*1.5), // synthwave pink, dynamic\n\t\tlight(vec3(8.*sin(camTime-0.4), 4.5, 8.*-cos(camTime-0.4)), //cam syncronized rotation\n\t\t\tnormalize(vec3(73,10,245))*0.1) //synthwave blue\n\t);\n\t\n\t// Calculate depth-map\n\tmyDist = rayMarch(camPos, camDir);\n\t\n\t// Calculate diffused spotlight & convert to color\n\tfor (int n=0; n<lights.length(); n++){\n\t\tcol += getSpotlight(camPos+myDist*camDir, lights[n]);\n\t}\n\tcol = pow(col, vec3(.4545)); //gamma correction\n\t\n\tfragColor = vec4(col, 1.0); //output\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}