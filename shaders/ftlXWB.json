{
    "Shader": {
        "info": {
            "date": "1626719607",
            "description": "A silly webcam filter I made for zoom etc. for use with Memix.",
            "flags": 2,
            "hasliked": 0,
            "id": "ftlXWB",
            "likes": 14,
            "name": "The Phantom Zone",
            "published": 3,
            "tags": [
                "zoom",
                "memix"
            ],
            "usePreview": 1,
            "username": "P_Malin",
            "viewed": 730
        },
        "renderpass": [
            {
                "code": "// The Phantom Zone\n// by @P_Malin\n// https://www.shadertoy.com/view/ftlXWB\n\n// A silly shader designed to work with Memix https://www.memix.app/\n// Save the shader as %LOCALAPPDATA%\\Beautypi\\Memix\\shader.txt\n\n// https://github.com/pmalin/pmalin-memix-shaders\n\n// Thanks for the following:\n// Dave Hoskins - hash function from https://www.shadertoy.com/view/4djSRW\n// iq - soft shadow from https://www.shadertoy.com/view/lsKcDD \n// iq - box intersection from https://iquilezles.org/articles/intersectors\n// iq - smooth min from https://iquilezles.org/articles/smin\n\n// Also see a similar shader from dean_the_coder: https://www.shadertoy.com/view/Wd2fzV\n\n#define RAYMARCH_ITER 32\n#define MAX_RAYMARCH_DIST 70.0\n#define SHADOW_STEPS 16\n\n\nvec3 boxDimensions = vec3(1,1,0.02);\nvec3 glassColour = vec3( 0.6, 0.84, 0.9 );\nfloat glassDensity = 40.0;\n\nvec3 sunDir = normalize(vec3(0.3, 0.5, -0.2));\nvec3 sunColor = vec3(1, 0.95, 0.9) * 1.7;\nvec3 ambientColor = vec3(0.3, 0.7, 1.0) * 1.0;\n\nfloat fogDensity= 0.00005;\nfloat fogHeightFalloff = 1.0;\n\nfloat sliceBegin = -3.5f;\nfloat sliceHeight = 1.0f;\n\n#define PI 3.1415925654\n\nvec3 RotateX( vec3 pos, float angle )\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return vec3( pos.x, c * pos.y + s * pos.z, -s * pos.y + c * pos.z);\n}\n\nvec3 RotateY( vec3 pos, float angle )\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return vec3( c * pos.x + s * pos.z, pos.y, -s * pos.x + c * pos.z);\n}\n\nvec3 RotateZ( vec3 pos, float angle )\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return vec3( c * pos.x + s * pos.y, -s * pos.x + c * pos.y, pos.z);\n}\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct CameraState\n{\n    vec3 pos;\n    vec3 target;\n    vec3 up;\n};\n\nmat3 GetCameraMatrix( CameraState cameraState )\n{\n    vec3 zDir = normalize(cameraState.target - cameraState.pos);    \n    vec3 xDir = normalize( cross( cameraState.up, zDir ) );\n    vec3 yDir = normalize( cross( zDir, xDir ) );\n    \n    mat3 mat = mat3( xDir, yDir, zDir );\n    \n    return mat;\n}\n\nRay GetCameraRay( vec2 coord, CameraState cameraState )\n{\n    vec3 viewDir = normalize(vec3( coord.xy, 1.0f ));\n    \n    mat3 mat = GetCameraMatrix( cameraState );\n    \n    Ray ray = Ray( cameraState.pos, mat * viewDir );\n    \n    return ray;\n}\n\n#define MAT_NONE -1\n#define MAT_DEFAULT 0\n#define MAT_QUAD 1\n\n\n// hash from https://www.shadertoy.com/view/4djSRW\n// Hash without Sine\n// by Dave_Hoskins\n\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\nfloat SmoothNoise( vec2 o ) \n{\n\t//vec2 p = floor(o);\n\tvec2 f = fract(o);\n    vec2 p = o-f;\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = hash11(n+  0.0);\n\tfloat b = hash11(n+  1.0);\n\tfloat c = hash11(n+ 57.0);\n\tfloat d = hash11(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\nfloat CircleBomb( vec2 pos, float range )\n{   \n    float dist = MAX_RAYMARCH_DIST;\n    for(float yo=-range; yo<=range; yo+=1.0)\n    {\n        for(float xo=-range; xo<=range; xo+=1.0)\n        {\n            vec2 cellPos = pos + vec2(xo,yo);\n            vec2 cellIndex = floor(cellPos);\n            \n            vec3 hash = hash32( cellIndex );\n            \n            vec2 circleOffset = hash.xy * 0.5;\n            \n            vec2 circlePos = cellIndex + 0.5 + circleOffset;\n            \n            float circleRadius = hash.z * 0.5;\n            float circleDist = length( circlePos - pos ) - circleRadius;\n            \n            if ( circleDist < dist )\n            {\n                dist = circleDist;\n            }\n        }\n    }\n    \n    return dist;\n}\n\nfloat GetSlice( float h )\n{\n    return floor( (h-sliceBegin) / sliceHeight );\n}\n\nstruct RaymarchResult\n{\n\tfloat dist;\n\tint objectId;\n    vec3 uvw;\n};\n\nRaymarchResult Scene_GetDistance( vec3 pos );\n\nRaymarchResult Scene_Raymarch( Ray ray, float minDist, float maxDist )\n{\t\n    RaymarchResult result;\n    result.dist = 0.0;\n    result.uvw = vec3(0.0);\n    result.objectId = MAT_NONE;\n    \n\tfloat t = minDist;\n    \n\tfor(int i=0; i<RAYMARCH_ITER; i++)\n\t{\t\t\n        float epsilon = 0.000001 * t;\n\t\tresult = Scene_GetDistance( ray.pos + ray.dir * t );\n        if ( abs(result.dist) < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n            result.objectId = MAT_NONE;\n\t        t = maxDist;\n            break;\n        }       \n        \n        if ( result.dist > 1.0 )\n        {\n            result.objectId = MAT_NONE;\n        }    \n        \n        t += result.dist; \n\t}\n    \n    result.dist = max( t, minDist );\n\n\n    return result;\n}\n\n\nRaymarchResult Scene_Union( RaymarchResult a, RaymarchResult b )\n{\n    if ( b.dist < a.dist )\n    {\n        return b;\n    }\n    return a;\n}\n\nvec3 Scene_GetNormal(vec3 pos)\n{\n    const float fDelta = 0.0001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal =\n        Scene_GetDistance( e.yxx * fDelta + pos ).dist * e.yxx + \n        Scene_GetDistance( e.xxy * fDelta + pos ).dist * e.xxy + \n        Scene_GetDistance( e.xyx * fDelta + pos ).dist * e.xyx + \n        Scene_GetDistance( e.yyy * fDelta + pos ).dist * e.yyy;\n    \n    return normalize( vNormal );\n} \n\nstruct TraceResult\n{\n\tfloat dist;\n\tint objectId;\n    vec3 uvw;\n    vec3 pos;    \n    vec3 normal;\n};\n\nvec3 BoxDomainRotate( vec3 pos );\nvec3 BoxDomainInvRotate( vec3 pos );\n\n\n// https://iquilezles.org/articles/intersectors\n// axis aligned box centered at the origin, with size boxSize\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\n\nTraceResult Scene_Raytrace( Ray ray, float minDist, float maxDist )\n{\n    TraceResult result;\n    \n    result.dist = MAX_RAYMARCH_DIST;\n    result.objectId = MAT_NONE;\n\n    vec3 boxRayDir = BoxDomainRotate( ray.dir );\n    vec3 boxRayPos = BoxDomainRotate( ray.pos );    \n\n    vec2 t = boxIntersection( boxRayPos, boxRayDir, boxDimensions, result.normal);\n\n    result.normal = BoxDomainInvRotate( result.normal );\n\n    result.uvw = (boxRayPos + boxRayDir * t.x);\n\n    if ( t.x  >= 0.0 )\n    {\n        result.dist = t.x;\n        result.objectId = MAT_QUAD;\n    }\n    \n    return result;\n}\n\n\nTraceResult Scene_Trace( Ray ray, float minDist, float maxDist )\n{\n    TraceResult result;    \n\n    TraceResult raytraceResult = Scene_Raytrace( ray, minDist, maxDist );\n        \n    if (ray.dir.y >= 0.0 )\n    {\n        result.dist = MAX_RAYMARCH_DIST;\n        result.objectId = MAT_NONE;\n        result.normal = -ray.dir;\n        result.uvw = vec3(0);\n        result.pos = ray.pos + ray.dir * result.dist;\n    }\n    else\n    {\n        float yStart = sliceBegin;\n        \n        float t = (yStart - ray.pos.y) / ray.dir.y;\n        \n        if ( t > minDist )\n        {\n            minDist = t;\n        }\n        \n        RaymarchResult raymarchResult;\n        \n        raymarchResult = Scene_Raymarch( ray, minDist, maxDist );        \n\n        result.dist = raymarchResult.dist;\n        result.objectId = raymarchResult.objectId;\n        result.uvw = raymarchResult.uvw;\n        result.pos = ray.pos + ray.dir * result.dist;\n        result.normal = Scene_GetNormal( result.pos );     \n        \n    }\n        \n    if ( raytraceResult.dist < result.dist )\n    {\n        result.dist = raytraceResult.dist;\n        result.objectId = raytraceResult.objectId;\n        result.uvw = raytraceResult.uvw;\n        result.pos = ray.pos + ray.dir * result.dist;\n        result.normal = raytraceResult.normal;             \n    }\n\n    return result;\n}\n\nfloat Scene_TraceShadow( Ray ray, float minDist, float lightDist )\n{\n    // Soft Shadow Variation\n    // https://www.shadertoy.com/view/lsKcDD    \n    // based on Sebastian Aaltonen's soft shadow improvement\n    \n\tfloat res = 1.0;\n    float t = minDist;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n        \n    for( int i=0; i<SHADOW_STEPS; i++ )\n    {\n\t\tfloat h = Scene_GetDistance( ray.pos + ray.dir * t ).dist;\n\n        // use this if you are getting artifact on the first iteration, or unroll the\n        // first iteration out of the loop\n        //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n        \n        t += h;\n        \n        if( res < 0.0001 || t > lightDist ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );    \n}\n\nfloat Scene_GetAmbientOcclusion( Ray ray )\n{\n    float occlusion = 0.0;\n    float scale = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float fOffsetDist = 0.001 + 0.05*float(i)/4.0;\n        vec3 AOPos = ray.dir * fOffsetDist + ray.pos;\n        float dist = Scene_GetDistance( AOPos ).dist;\n        occlusion += (fOffsetDist - dist) * scale;\n        scale *= 0.46;\n    }\n    \n    return clamp( 1.0 - 30.0*occlusion, 0.0, 1.0 );\n}\n\nstruct SurfaceInfo\n{\n    vec3 pos;\n    vec3 normal;\n    vec3 albedo;\n    vec3 r0;\n    float gloss;\n    vec3 emissive;\n};\n    \nSurfaceInfo Scene_GetSurfaceInfo( Ray ray, TraceResult traceResult );\n\nstruct SurfaceLighting\n{\n    vec3 diffuse;\n    vec3 specular;\n};\n\nfloat Light_GIV( float dotNV, float k)\n{\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nfloat AlphaSqrFromGloss( float gloss )\n{\n\tfloat MAX_SPEC = 10.0;\n\treturn 2.0f  / ( 2.0f + exp2( gloss * MAX_SPEC) );\n}\n    \nvoid Light_Add( inout SurfaceLighting lighting, SurfaceInfo surface, vec3 viewDir, vec3 lightDir, vec3 lightColour )\n{\n\tfloat NDotL = clamp(dot(lightDir, surface.normal), 0.0, 1.0);\n\t\n\tlighting.diffuse += lightColour * NDotL;\n\n    if ( surface.gloss > 0.0 )\n    {\n        vec3 H = normalize( -viewDir + lightDir );\n        float NdotV = clamp(dot(-viewDir, surface.normal), 0.0, 1.0);\n        float NdotH = clamp(dot(surface.normal, H), 0.0, 1.0);\n\n        // D\n\n        float alphaSqr = AlphaSqrFromGloss( surface.gloss );\n        float alpha = sqrt( alphaSqr );\n        float denom = NdotH * NdotH * (alphaSqr - 1.0) + 1.0;\n        float d = alphaSqr / (PI * denom * denom);\n\n        float k = alpha / 2.0;\n        float vis = Light_GIV( NDotL, k ) * Light_GIV( NdotV, k );\n\n        float specularIntensity = d * vis * NDotL;    \n        lighting.specular += lightColour * specularIntensity;    \n    }\n}\n\nvoid Light_AddDirectional(inout SurfaceLighting lighting, SurfaceInfo surface, vec3 viewDir, vec3 lightDir, vec3 lightColour)\n{\t\n\tfloat attenuation = 1.0;\n    Ray shadowRay;\n    shadowRay.pos = surface.pos + surface.normal * 0.001;\n    shadowRay.dir = lightDir;\n\tfloat shadowFactor = Scene_TraceShadow( shadowRay, 0.01, 10.0 );\n\t\n\tLight_Add( lighting, surface, viewDir, lightDir, lightColour * shadowFactor * attenuation);\n}\n\nSurfaceLighting Scene_GetSurfaceLighting( Ray ray, SurfaceInfo surfaceInfo );\n\nvec3 Env_GetSkyColor( Ray ray );\n\nvec3 Light_GetFresnel( vec3 view, vec3 normal, vec3 r0, float gloss )\n{\n    float NdotV = max( 0.0, dot( view, normal ) );\n\n    return r0 + (vec3(1.0) - r0) * pow( 1.0 - NdotV, 5.0 ) * pow( gloss, 20.0 );\n}\n\nvec3 Env_ApplyAtmosphere( vec3 colour, Ray ray, float dist );\n\n\nvec3 Scene_GetColour( Ray ray )\n{\n\tvec3 resultColor = vec3(0.0);\n            \n\tTraceResult firstTraceResult;\n    \n    float startDist = 0.0f;\n    float maxDist = MAX_RAYMARCH_DIST;\n    \n    vec3 remaining = vec3(1.0);\n    \n\tfor( int passIndex=0; passIndex < 2; passIndex++ )\n    {\n    \tTraceResult traceResult = Scene_Trace( ray, startDist, maxDist );\n\n        if ( passIndex == 0 )\n        {\n            firstTraceResult = traceResult;\n        }\n        \n        vec3 colour = vec3(0);\n        vec3 reflectAmount = vec3(0);\n        \n\t\tif( traceResult.objectId < 0 )\n\t\t{\n            colour = Env_GetSkyColor( ray );\n\t\t\tcolour = Env_ApplyAtmosphere( colour, ray, traceResult.dist );\n        }\n        else\n        {\n            \n            SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( ray, traceResult );\n            SurfaceLighting surfaceLighting = Scene_GetSurfaceLighting( ray, surfaceInfo );\n                \n            if ( surfaceInfo.gloss <= 0.0 )\n            {\n                reflectAmount = vec3(0.0);\n            }\n            else\n            {\n                // calculate reflectance (Fresnel)\n                reflectAmount = Light_GetFresnel( -ray.dir, surfaceInfo.normal, surfaceInfo.r0, surfaceInfo.gloss );            \n            }\n\t\t\t\n\t\t\tcolour = (surfaceInfo.albedo * surfaceLighting.diffuse + surfaceInfo.emissive) * (vec3(1.0) - reflectAmount); \n            \n            vec3 reflectRayOrigin = surfaceInfo.pos;\n            vec3 reflectRayDir = normalize( reflect( ray.dir, surfaceInfo.normal ) );\n            startDist = 0.001 / max(0.0000001,abs(dot( reflectRayDir, surfaceInfo.normal ))); \n\n            colour += surfaceLighting.specular * reflectAmount;            \n\n\t\t\tcolour = Env_ApplyAtmosphere( colour, ray, traceResult.dist );\n            \n            ray.pos = reflectRayOrigin;\n            ray.dir = reflectRayDir;\n        }\n        \n        resultColor += colour * remaining;\n        remaining *= reflectAmount;                \n        \n        if ( (remaining.x + remaining.y + remaining.z) < 0.01 )\n        {\n            break;\n        }            \n    }\n \n    return vec3( resultColor );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 BoxDomainRotate( vec3 pos )\n{\n    pos = RotateX( pos, iTime );\n    pos = RotateZ( pos, 0.5 );\n    \n    return pos;\n}\n\nvec3 BoxDomainInvRotate( vec3 pos )\n{\n    pos = RotateZ( pos, -0.5 );\n    pos = RotateX( pos, -iTime );\n    \n    return pos;\n}\n\n// https://iquilezles.org/articles/smin\n// polynomial smooth min (k = 0.1);\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nRaymarchResult Scene_GetDistance( vec3 pos )\n{\n    RaymarchResult landscapeResult;\n    landscapeResult.dist = 100000.0;\n    landscapeResult.uvw = pos.xzy;\n    landscapeResult.objectId = MAT_DEFAULT;\n    \n    \n    vec3 landscapeDomain = pos + vec3(30.3,0,iTime);\n    \n    float scale = 10.0;\n    \n    float circleDist = CircleBomb(landscapeDomain.xz / scale, 2.0) * scale;\n\n    circleDist -= CircleBomb(landscapeDomain.xz * 3.0, 1.0) * 0.3;\n\n    float bump = SmoothNoise(landscapeDomain.xz * 5.0) * 0.1;\n\n    float sliceCount = 2.0;\n\n    for ( float slice = 0.0; slice >= -(sliceCount-1.0); slice -= 1.0 )\n    {\n        float sliceDist = circleDist + (slice) * .1 * scale - 1.0;    \n            \n        float sliceY = -slice * slice * sliceHeight + sliceBegin - bump; \n    \n        sliceDist = -sminCubic( -sliceDist, (sliceY - landscapeDomain.y), 0.5 );\n            \n        landscapeResult.dist = sminCubic( landscapeResult.dist, sliceDist, 0.5 );\n    }\n    \n    landscapeResult.dist = sminCubic( landscapeResult.dist, pos.y - (-sliceCount * sliceHeight + sliceBegin) - bump, 0.5 );    \n    \n    RaymarchResult result = landscapeResult;\n\n\n    return result;\n}\n\nSurfaceInfo Scene_GetSurfaceInfo( Ray ray, TraceResult traceResult )\n{\n    SurfaceInfo surfaceInfo;\n    \n    surfaceInfo.pos = traceResult.pos;\n    surfaceInfo.normal = traceResult.normal;\n    \n    surfaceInfo.albedo = vec3(1.0);\n    surfaceInfo.r0 = vec3( 0.02 );\n    surfaceInfo.gloss = 0.0;\n    surfaceInfo.emissive = vec3( 0.0 );\n        \n    if ( traceResult.objectId == MAT_DEFAULT )\n    {\n        surfaceInfo.albedo = vec3(0.95, 0.95, 0.95); \n\t    surfaceInfo.gloss = 0.0;\n    \tsurfaceInfo.r0 = vec3( 0.02 );\n    }\n    \n    if ( traceResult.objectId == MAT_QUAD )\n    {\n        surfaceInfo.albedo = vec3(0);\n\t    surfaceInfo.gloss = 0.9;\n    \tsurfaceInfo.r0 = vec3( 0.02 );\n        \n        \n        vec3 dir = refract( ray.dir, surfaceInfo.normal, 1.0 / 1.33 );\n        \n        vec3 boxRayDir = BoxDomainRotate( normalize( dir ) ) / (boxDimensions);\n        vec3 boxRayPos = traceResult.uvw / (boxDimensions);\n\n        vec3 h = -(boxRayPos - sign(boxRayDir)) / boxRayDir;\n        float t = min(min(h.x, h.y), h.z);\n        \n        vec3 p = boxRayPos + boxRayDir * t;\n\n\n        vec2 uv = p.xy;\n        float d = length( boxRayDir * t * boxDimensions );\n        \n        uv = uv * 0.5 + 0.5;\n        \n        ivec2 tSize = textureSize(iChannel0, 0);\n        uv = uv - 0.5;\n        if ( tSize.x > tSize.y )\n        {\n            uv.x *= float(tSize.y) / float(tSize.x);\n        }\n        else\n        {\n            uv.y *= float(tSize.x) / float(tSize.y);\n        }\n        uv = uv + 0.5;\n        \n        vec3 emissiveSample = texture( iChannel0, uv ).rgb;\n        surfaceInfo.emissive = emissiveSample * emissiveSample;\n\n        surfaceInfo.emissive *= exp( -d * (1.0 - glassColour) * glassDensity );                      \n    }   \n    \n    return surfaceInfo;    \n}\n\nvec3 Env_GetSkyColor( Ray ray )\n{\n    return vec3(0.0);\n}\n\nSurfaceLighting Scene_GetSurfaceLighting( Ray ray, SurfaceInfo surfaceInfo )\n{   \n    SurfaceLighting surfaceLighting;\n    \n    surfaceLighting.diffuse = vec3(0.0);\n    surfaceLighting.specular = vec3(0.0);    \n    \n    Light_AddDirectional( surfaceLighting, surfaceInfo, ray.dir, sunDir, sunColor );\n    \n    \n    Ray aoRay;\n    aoRay.pos = surfaceInfo.pos;\n    aoRay.dir = surfaceInfo.normal;\n    float fAO = Scene_GetAmbientOcclusion(aoRay);    \n    surfaceLighting.diffuse += fAO * (surfaceInfo.normal.y * 0.5 + 0.5) * ambientColor;\n    \n    return surfaceLighting;\n}\n\nfloat Env_GetFogFactor( Ray ray, float dist )\n{    \n\n    float fogAmount = fogDensity * exp(-ray.pos.y*fogHeightFalloff) * (1.0-exp(-dist*ray.dir.y*fogHeightFalloff ))/ray.dir.y;\n    \n\treturn exp(dist * -fogAmount);\t    \n}\n\nvec3 Env_GetFogColour(Ray ray)\n{    \n\treturn vec3(0.1, 0.35, 0.9);\n}\n\nvec3 Env_ApplyAtmosphere( vec3 colour, Ray ray, float dist )\n{\n    vec3 result = colour;\n        \n\tfloat fogFactor = Env_GetFogFactor( ray, dist );\n\tvec3 fogColor = Env_GetFogColour( ray );\n    result = mix( fogColor, result, fogFactor );\n\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 coord = uv - 0.5;\n    coord.x *= iResolution.x / iResolution.y;\n    \n    CameraState camera;\n\n    camera.pos = vec3(0,-0.3,-3);\n    camera.target = vec3(0,0.1,0);\n    camera.up = vec3(0,1,0);\n\n    camera.pos = RotateY( camera.pos, sin(iTime * 0.1) * 0.3 );\n    \n    camera.pos *= (sin( iTime * 0.234 ) * 0.5 + 0.5) * 1.0 + 1.0;\n    \n    Ray ray = GetCameraRay( coord, camera );\n    \n    vec3 sceneColour = Scene_GetColour( ray );\n    \n    vec3 colour = sceneColour;\n    \n    colour = 1.0f - exp( -colour * 1.0 );\n    \n    colour = pow( colour, vec3(1.0f / 2.2f) );\n    \n    fragColor = vec4(colour, 1.0f);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}