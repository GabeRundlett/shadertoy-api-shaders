{
    "Shader": {
        "info": {
            "date": "1599728247",
            "description": "test 2d shadow",
            "flags": 0,
            "hasliked": 0,
            "id": "wtSBDG",
            "likes": 11,
            "name": "test 2d shadow",
            "published": 3,
            "tags": [
                "2d",
                "shadow"
            ],
            "usePreview": 0,
            "username": "eldn",
            "viewed": 503
        },
        "renderpass": [
            {
                "code": "/**\n\n\tHi all,\n\n\tThis is just my playground for a bunch of 2D stuff:\n\n\tSome distance functions and blend functions\n\tCone marched 2D Soft shadows\n\tUse the mouse to control the 3rd light\n\n*/\n\n\n\n//////////////////////////////////////\n// Combine distance field functions //\n//////////////////////////////////////\n\n\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\n\nfloat merge(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\n\nfloat mergeExclude(float d1, float d2)\n{\n\treturn min(max(-d1, d2), max(-d2, d1));\n}\n\n\nfloat substract(float d1, float d2)\n{\n\treturn max(-d1, d2);\n}\n\n\nfloat intersect(float d1, float d2)\n{\n\treturn max(d1, d2);\n}\n\n\n//////////////////////////////\n// Rotation and translation //\n//////////////////////////////\n\n\nvec2 rotateCCW(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n\treturn p * m;\t\n}\n\n\nvec2 rotateCW(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), -sin(a), sin(a), cos(a));\n\treturn p * m;\n}\n\n\nvec2 translate(vec2 p, vec2 t)\n{\n\treturn p - t;\n}\n\n\n//////////////////////////////\n// Distance field functions //\n//////////////////////////////\n\n\nfloat pie(vec2 p, float angle)\n{\n\tangle = radians(angle) / 2.0;\n\tvec2 n = vec2(cos(angle), sin(angle));\n\treturn abs(p).x * n.x + p.y*n.y;\n}\n\n\nfloat circleDist(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\n\nfloat triangleDist(vec2 p, float radius)\n{\n\treturn max(\tabs(p).x * 0.866025 + \n\t\t\t   \tp.y * 0.5, -p.y) \n\t\t\t\t-radius * 0.5;\n}\n\n\nfloat triangleDist(vec2 p, float width, float height)\n{\n\tvec2 n = normalize(vec2(height, width / 2.0));\n\treturn max(\tabs(p).x*n.x + p.y*n.y - (height*n.y), -p.y);\n}\n\n\nfloat semiCircleDist(vec2 p, float radius, float angle, float width)\n{\n\twidth /= 2.0;\n\tradius -= width;\n\treturn substract(pie(p, angle), \n\t\t\t\t\t abs(circleDist(p, radius)) - width);\n}\n\n\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\n\nfloat lineDist(vec2 p, vec2 start, vec2 end, float width)\n{\n\tvec2 dir = start - end;\n\tfloat lngth = length(dir);\n\tdir /= lngth;\n\tvec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n\treturn length( (start - p) - proj ) - (width / 2.0);\n}\n\n\n///////////////////////\n// Masks for drawing //\n///////////////////////\n\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-dist, 0.0, 1.0);\n}\n\n\nfloat innerBorderMask(float dist, float width)\n{\n\t//dist += 1.0;\n\tfloat alpha1 = clamp(dist + width, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\nfloat outerBorderMask(float dist, float width)\n{\n\t//dist += 1.0;\n\tfloat alpha1 = clamp(dist, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist - width, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\n///////////////\n// The scene //\n///////////////\n\n\nfloat sceneDist(vec2 p)\n{\n\tfloat c = circleDist(\t\ttranslate(p, vec2(100, 250)), 40.0);\n\tfloat b1 =  boxDist(\t\ttranslate(p, vec2(200, 250)), vec2(40, 40), \t0.0);\n\tfloat b2 =  boxDist(\t\ttranslate(p, vec2(300, 250)), vec2(40, 40), \t10.0);\n\tfloat l = lineDist(\t\t\tp, \t\t\t vec2(370, 220),  vec2(430, 280),\t10.0);\n\tfloat t1 = triangleDist(\ttranslate(p, vec2(500, 210)), 80.0, \t\t\t80.0);\n\tfloat t2 = triangleDist(\trotateCW(translate(p, vec2(600, 250)), iTime), 40.0);\n\t\n\tfloat m = \tmerge(c, b1);\n\tm = \t\tmerge(m, b2);\n\tm = \t\tmerge(m, l);\n\tm = \t\tmerge(m, t1);\n\tm = \t\tmerge(m, t2);\n\t\n\tfloat b3 = boxDist(\t\ttranslate(p, vec2(100, sin(iTime * 3.0 + 1.0) * 40.0 + 100.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c2 = circleDist(\ttranslate(p, vec2(100, 100)),\t30.0);\n\tfloat s = substract(b3, c2);\n\t\n\tfloat b4 = boxDist(\t\ttranslate(p, vec2(200, sin(iTime * 3.0 + 2.0) * 40.0 + 100.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c3 = circleDist(\ttranslate(p, vec2(200, 100)), \t30.0);\n\tfloat i = intersect(b4, c3);\n\t\n\tfloat b5 = boxDist(\t\ttranslate(p, vec2(300, sin(iTime * 3.0 + 3.0) * 40.0 + 100.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c4 = circleDist(\ttranslate(p, vec2(300, 100)), \t30.0);\n\tfloat a = merge(b5, c4);\n\t\n\tfloat b6 = boxDist(\t\ttranslate(p, vec2(400, 100)),\tvec2(40, 15), \t0.0);\n\tfloat c5 = circleDist(\ttranslate(p, vec2(400, 100)), \t30.0);\n\tfloat sm = smoothMerge(b6, c5, 10.0);\n\t\n\tfloat sc = semiCircleDist(translate(p, vec2(500,100)), 40.0, 90.0, 10.0);\n    \n    float b7 = boxDist(\t\ttranslate(p, vec2(600, sin(iTime * 3.0 + 3.0) * 40.0 + 100.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c6 = circleDist(\ttranslate(p, vec2(600, 100)), \t30.0);\n\tfloat e = mergeExclude(b7, c6);\n    \n\tm = merge(m, s);\n\tm = merge(m, i);\n\tm = merge(m, a);\n\tm = merge(m, sm);\n\tm = merge(m, sc);\n    m = merge(m, e);\n\t\n\treturn m;\n}\n\n\nfloat sceneSmooth(vec2 p, float r)\n{\n\tfloat accum = sceneDist(p);\n\taccum += sceneDist(p + vec2(0.0, r));\n\taccum += sceneDist(p + vec2(0.0, -r));\n\taccum += sceneDist(p + vec2(r, 0.0));\n\taccum += sceneDist(p + vec2(-r, 0.0));\n\treturn accum / 5.0;\n}\n\n\n//////////////////////\n// Shadow and light //\n//////////////////////\n\n\nfloat shadow(vec2 p, vec2 pos, float radius)\n{\n\tvec2 dir = normalize(pos - p);\n\tfloat dl = length(p - pos);\n\t\n\t// fraction of light visible, starts at one radius (second half added in the end);\n\tfloat lf = radius * dl;\n\t\n\t// distance traveled\n\tfloat dt = 0.01;\n\n\tfor (int i = 0; i < 64; ++i)\n\t{\t\t\t\t\n\t\t// distance to scene at current position\n\t\tfloat sd = sceneDist(p + dir * dt);\n\n        // early out when this ray is guaranteed to be full shadow\n        if (sd < -radius) \n            return 0.0;\n        \n\t\t// width of cone-overlap at light\n\t\t// 0 in center, so 50% overlap: add one radius outside of loop to get total coverage\n\t\t// should be '(sd / dt) * dl', but '*dl' outside of loop\n\t\tlf = min(lf, sd / dt);\n\t\t\n\t\t// move ahead\n\t\tdt += max(1.0, abs(sd));\n\t\tif (dt > dl) break;\n\t}\n\n\t// multiply by dl to get the real projected overlap (moved out of loop)\n\t// add one radius, before between -radius and + radius\n\t// normalize to 1 ( / 2*radius)\n\tlf = clamp((lf*dl + radius) / (2.0 * radius), 0.0, 1.0);\n\tlf = smoothstep(0.0, 1.0, lf);\n\treturn lf;\n}\n\n\n\nvec4 drawLight(vec2 p, vec2 pos, vec4 color, float dist, float range, float radius)\n{\n\t// distance to light\n\tfloat ld = length(p - pos);\n\t\n\t// out of range\n\tif (ld > range) return vec4(0.0);\n\t\n\t// shadow and falloff\n\tfloat shad = shadow(p, pos, radius);\n\tfloat fall = (range - ld)/range;\n\tfall *= fall;\n\tfloat source = fillMask(circleDist(p - pos, radius));\n\treturn (shad * fall + source) * color;\n}\n\n\nfloat luminance(vec4 col)\n{\n\treturn 0.2126 * col.r + 0.7152 * col.g + 0.0722 * col.b;\n}\n\n\nvoid setLuminance(inout vec4 col, float lum)\n{\n\tlum /= luminance(col);\n\tcol *= lum;\n}\n\n\nfloat AO(vec2 p, float dist, float radius, float intensity)\n{\n\tfloat a = clamp(dist / radius, 0.0, 1.0) - 1.0;\n\treturn 1.0 - (pow(abs(a), 5.0) + 1.0) * intensity + (1.0 - intensity);\n\treturn smoothstep(0.0, 1.0, dist / radius);\n}\n\n\n/////////////////\n// The program //\n/////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy + vec2(0.5);\n\tvec2 c = iResolution.xy / 2.0;\n\t\n\t//float dist = sceneSmooth(p, 5.0);\n\tfloat dist = sceneDist(p);\n\t\n\tvec2 light1Pos = iMouse.xy;\n\tvec4 light1Col = vec4(0.75, 1.0, 0.5, 1.0);\n\tsetLuminance(light1Col, 0.4);\n\t\n\tvec2 light2Pos = vec2(iResolution.x * (sin(iTime + 3.1415) + 1.2) / 2.4, 175.0);\n\tvec4 light2Col = vec4(1.0, 0.75, 0.5, 1.0);\n\tsetLuminance(light2Col, 0.5);\n\t\n\tvec2 light3Pos = vec2(iResolution.x * (sin(iTime) + 1.2) / 2.4, 340.0);\n\tvec4 light3Col = vec4(0.5, 0.75, 1.0, 1.0);\n\tsetLuminance(light3Col, 0.6);\n\t\n\t// gradient\n\tvec4 col = vec4(0.5, 0.5, 0.5, 1.0) * (1.0 - length(c - p)/iResolution.x);\n\t// grid\n\tcol *= clamp(min(mod(p.y, 10.0), mod(p.x, 10.0)), 0.9, 1.0);\n\t// ambient occlusion\n\tcol *= AO(p, sceneSmooth(p, 10.0), 40.0, 0.4);\n\t//col *= 1.0-AO(p, sceneDist(p), 40.0, 1.0);\n\t// light\n\tcol += drawLight(p, light1Pos, light1Col, dist, 150.0, 6.0);\n\tcol += drawLight(p, light2Pos, light2Col, dist, 200.0, 8.0);\n\tcol += drawLight(p, light3Pos, light3Col, dist, 300.0, 12.0);\n\t// shape fill\n\tcol = mix(col, vec4(1.0, 0.4, 0.0, 1.0), fillMask(dist));\n\t// shape outline\n\tcol = mix(col, vec4(0.1, 0.1, 0.1, 1.0), innerBorderMask(dist, 1.5));\n\n\tfragColor = clamp(col, 0.0, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}