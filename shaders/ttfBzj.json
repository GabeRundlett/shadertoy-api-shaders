{
    "Shader": {
        "info": {
            "date": "1597158257",
            "description": "A low-pass filter with maximally flat pass or stop band that falls off to zero approaching the Nyquist frequency.\nThe discrete kernel of a given size can be computed using a simple recursive procedure.\nDerivation and relevant code are in Buffer A.",
            "flags": 32,
            "hasliked": 0,
            "id": "ttfBzj",
            "likes": 9,
            "name": "FlatBand-FIR filter",
            "published": 3,
            "tags": [
                "fft",
                "filter",
                "nyquist",
                "fourier",
                "lowpass",
                "butterworth"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 706
        },
        "renderpass": [
            {
                "code": "/*\nA low-pass filter with maximally flat pass or stop band that falls off to zero approaching the Nyquist frequency.\nThe discrete kernel of a given size can be computed using a simple recursive procedure.\nI am not totally sure but I believe this is a Butterworth filter: https://en.wikipedia.org/wiki/Butterworth_filter\n\nEDIT: As iq pointed out discrete Butterworth filters seem to be IIR filters, so maybe they are not directly related to this one.\n\nDerivation and relevant code are in Buffer A.\n*/\n\n//2D Signal Inspector template by nimitz 2018 (twitter: @stormoid)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n#ifdef SHOW_FOURIER\n    if (q.x > 0.5)\n    {\n        vec2 dft = textureLod(iChannel1, (q-vec2(0.5,0.)), 0.).xy;\n        // dft = texelFetch(iChannel1, ivec2(fragCoord-vec2(iResolution.x*0.5,0.)-0.5)*2, 0).xy;\n        \n        float amp = length(dft) / SIZE; \n        col = vec3(amp);\n\n        if(amp <= 0.0001) col = vec3(1.0, 0.0, 0.0)*0.25;\n    }\t\n    else\n#endif\n    {\n        float n = textureLod(iChannel0, q, 0.).r;\n        //n= n*0.5+0.5;\n        n = clamp01(n);\n        col = pow(vec3(n), vec3(1.0/2.2));\n    }\n    \n    //Distribution plot\n    float tot = 0.;\n    if (fragCoord.y> SIZE && fragCoord.x < SIZE)\n    {\n        const float bands = 60.;\n        float bt = floor(fragCoord.x*bands/SIZE);\n        float pt = (floor((fragCoord.x)*bands/SIZE)+0.5)/bands;\n        const float width = 6.;\n        for (float j = 0.; j<=width; j++)\n        for (float i = 0.; i<SIZE; i++)\n        {\n            float v = texelFetch(iChannel0, ivec2(bt+j, i + 0.5), 0).x;\n            if (abs(v-pt) < .5/bands)\n            \ttot += 1.;\n        }\n        tot /= SIZE*width;\n        col.rgb = vec3(smoothstep(0.00,1.,tot*SIZE-fragCoord.y + SIZE + 1.))*vec3(.4,.4,.5);\n        col.rgb += vec3(smoothstep(1.,0.,abs(tot*SIZE-fragCoord.y + SIZE + 0.5)))*vec3(.8,.8,.8);\n        if(fragCoord.y < (SIZE+50.))\n        {\n        \tcol.rgb = max(col.rgb, vec3(0.9,0.6,0.1)*vec3(smoothstep(1.4,0.,abs(fragCoord.x - SIZE/2.))));\n        \tcol.rgb = max(col.rgb, vec3(0.55,0.5,0.4)*vec3(smoothstep(1.4,0.,abs(abs(fragCoord.x - SIZE/2.)-SIZE/4.))));\n        }\n    }\n    \n    \n    col *= smoothstep(0.,1.7,abs(fragCoord.y-SIZE+1.));\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n\nA low-pass filter with maximally flat pass or stop band that falls off to zero approaching the Nyquist frequency.\nThe discrete kernel of a given size can be computed using a simple recursive procedure.\n\nDerivation:\n\nSo I was interested in constructing discrete filters that completely remove pixel sized featutes.\nPixel sized features result from the highest possible fequency content, i.e. from cos((x + phase) * pi). \nWhen sampled, this cosine can only produce a pattern of a constant value with alternating sign, i.e s*(.., 1, -1, 1, -1, 1, ...).\nThe factor s is -sec(a * pi):\n\nFullSimplify[Solve[Cos[(i) Pi] == s Cos[((i + 1) + a) Pi], s], Assumptions -> i \\[Element] Integers]\n{{s -> -Sec[a \\[Pi]]}}\n\nSignal content at this frequency, i.e. the Nyquist frequency, therefore can not be correctly represented/reconstructed and \nis generally the result of aliasing (the only exception being the perfectly pixel aligned cosine).\n\nConceptually the most straighforward way to remove these frequency from an image would be to zero out the left most column and \nthe bottom most row of its discrete Fourier transform.\nHowever, the fact that this frequency only produces one unique pattern allows us to derive simple constraines for our\ndiscrete filter kernels that ensure that their frequency responses perfectly fall off to zero at the Nyquist frequency.\n\nLet us considere the simplest case, i.e. a kernel of the of the form (a, 1-2a, a).\nSolving a simple linear equation tells us which choice for 'a' results in a filter that removes pixel sized features completely:\n\nSolve[{-1, 1, -1}.{a, 1 - 2 a, a} == 0, a]\n{{a -> 1/4}}\n\n('.' is Mathematica's dot product)\n\nThe kernel is therefore (1/4, 1/2, 1/4).\n\nThe 2d version can then constructed via the outer product:\n(1/4, 1/2, 1/4) x (1/4, 1/2, 1/4) = ((1/16, 1/8, 1/16),\n\t\t\t\t\t\t\t\t\t (1/ 8, 1/4, 1/ 8),\n\t\t\t\t\t\t\t\t\t (1/16, 1/8, 1/16))\n\n\nIncreasing the filter size from 3 to 5 gives us one more degrees of freedom that we can than use to flatten the pass band:\n\nkern[a_, b_] := {b, a, 1 - 2 (a + b), a, b}\n\nSolve[{1, -1, 1, -1, 1}.kern[a, b] == 0, {a, b}]\n{{a -> 1/4}}\n\nkern5[b_] := kern[1/4, b]\n\nSo 'a' is still strictly constrained to be 1/4, but we can choose 'b' freely.\n\nNext we construct a continuous kernel by interpolating our kernel weights using the normalized sinc function:\n\nsinc[x_] := Sin[x Pi]/(x Pi)\nkern5C[x_, b_] := kern5[b].Table[sinc[x - i], {i, -2, 2}]\n\nThis allows us to perform a (continuous) Fourier transform:\n\nkern5Cfo[x_, b_] = FullSimplify[FourierTransform[kern5C[w, b], w, x]]\n((1 - 4 b + Cos[x] + 4 b Cos[2 x]) (Sign[\\[Pi] - x] + Sign[\\[Pi] + x]))/(4 Sqrt[2 \\[Pi]])\n\nEvery odd derivative of this function already goes to 0 as x->0, so we are only concerned with zeroing out the even derivatives there.\nWith the right choice for 'b' we can zero out the 2nd derivative of kern5Cfo for x->0:\n\nSolve[{Limit[D[kern5Cfo[x, b], {x, 2}], x -> 0] == 0}, {b}]\n{{b -> -(1/16)}}\n\nThe kernel of size 5 is therefore (-1/16, 1/4, 5/8, 1/4, -1/16).\n\n\nFurther increasing the kernel size and zeroing out more even-degree derivatives is straightforward.\n\nThere most certrainly is an elegant, formal way of figuring out how the weights can be computed from the kernel size alone.\nBut what I ended up doing was deriving the kernels up to size 13 using the approach detailed above.\nI then stared at the weights of those kernels until I came up with a recursive formula that can compute them:\n\n\tconst uint r = size / 2u;\n\n\tfloat kern[r];\n\n    float sgn = (uint(r) & 1u) == 0u ? -1.0 : 1.0;\n    \n    kern[r] = 1.0/exp2(float(r) * 2.0) * sgn;\n    \n    float sum = kern[r];\n    float n = 0.0;\n    for(int i = r-1; i > 0; --i, ++n)\n    {\n        kern[i] = kern[i+1] * -((float(r) * 2.0 - n) / (n + 1.0));\n        \n        sum += kern[i];\n    }\n    \n    kern[0] = 1.0 - 2.0 * sum;\n\nI did not actually prove that this formula is correct for larger filter sizes but judging from the results it looks very likely that it is.\n\n\nEDIT:\n\nIt turns out that omitting the negative signs from the filter weights and adapting the central weight accordingly \nresults in the stop band being maximally flat instead of the pass band.\nSo if your goal is to gracefully remove as much high frequency content as possible with a kernel of a given size then\npicking the respective one from the class of kernels presented here is probably not a bad idea. \n\nYou can use the FLATTEN_STOP_BAND define to switch to this filter type.\n\n\nThese are the first few kernels:\n\nflat stop band:\n3: 1.0/2.0, 1.0/4.0\n5: 3.0/8.0, 1.0/4.0, 1.0/16.0\n7: 5.0/16.0, 15.0/64.0, 3.0/32.0, 1.0/64.0\n9: 35.0/128.0, 7.0/32.0, 7.0/64.0, 1.0/32.0, 1.0/256.0\n\nflat pass band:\n3: 1.0/2.0, 1.0/4.0\n5: 5.0/8.0, 1.0/4.0, -1.0/16.0\n7: 11.0/16.0, 15.0/64.0, -3.0/32.0, 1.0/64.0\n9: 93.0/128.0, 7.0/32.0, -7.0/64.0, 1.0/32.0, -1.0/256.0\n\n*/\n\n\n#define SIGNAL_TYPE 0\n/*\n\t0: white noise\n\t1: texture\n\t2: simple pattern\n\t3: simple pattern clamped to [0,1]\n*/\n\n// #if 0 shows unaltered signal\n#if 1\n\n    #define ADD_ERROR_TO_SIGNAL\n\n    #define APPLY_FILTER\n\n#endif\n\nconst int FILTER_RADIUS = 3;\n\n    //#define FLATTEN_STOP_BAND\n\n    //#define APPLY_AS_HIGH_PASS_FILTER\n\n\n\n#ifdef APPLY_AS_HIGH_PASS_FILTER\n\t#undef ADD_ERROR_TO_SIGNAL\n#endif\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c) \n{\n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u; \n}\n\n\nfloat Float01(uint x) { return float(x)      * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nfloat Map(uvec2 uv)\n{\n    uint size = uint(SIZE);\n    \n    if(uv.x > size*4u) uv.x += size;\n    if(uv.y > size*4u) uv.y += size;\n        \n    if(uv.x >= size) uv.x -= size;\n    if(uv.y >= size) uv.y -= size;\n    \n    vec2 tc = vec2(uv);\n    \n    float signal = 0.0;\n    \n    \n   #if SIGNAL_TYPE == 0\n    \n    signal = Float01(WeylHash(uv));\n    \n   #elif SIGNAL_TYPE == 1\n    \n    signal = pow(texelFetch(iChannel0, ivec2(uv), 0).r, 2.2);\n    \n   #elif SIGNAL_TYPE == 2 || SIGNAL_TYPE == 3\n    \n    signal += cos(tc.x*Pi*0.25);\n    signal += cos(tc.y*Pi*0.125);\n    \n    //vec2 tc2 = tc - SIZE*0.5;\n    //tc2 = cmul(tc2, cossin(iTime));\n    //signal = max(abs(tc2.x), abs(tc2.y)) < SIZE/4.0 ? 1.0 : 0.0;\n    \n    #if 1\n    signal += cos(tc.x*Pi*0.5 + tc.y*Pi*0.25);\n    signal += cos(tc.x*Pi*0.5 - tc.y*Pi*0.25);\n    #endif\n    \n    #if 0\n    signal += cos(tc.y*Pi*0.5 + tc.x*Pi*0.25);\n    signal += cos(tc.y*Pi*0.5 - tc.x*Pi*0.25);\n    #endif\n    \n    #if SIGNAL_TYPE == 3\n    signal = clamp01(signal);\n    #endif\n    \n   #endif\n    \n    \n   #ifdef ADD_ERROR_TO_SIGNAL\n\n    float error = 0.0;\n    error += cos((tc.x) * Pi + tc.y*(SIZE-floor((sin(iTime)*0.5+0.5)*SIZE*0.5)*2.0)/SIZE * Pi);\n    error += cos((tc.y) * Pi + tc.x*(SIZE-floor((sin(iTime*0.6173)*0.5+0.5)*SIZE*0.5)*2.0)/SIZE * Pi);\n    \n    signal += error;// add pixel sized error\n    \n    /*\n\t// checker board shenanigans\n    bool m = ((uv.x ^ uv.y) & 1u) == 1u;\n\n    #if 0\n    float s = 0.0;\n    signal *= 1.0 - 4.0 * s;\n    signal += pow(texelFetch(iChannel0, ivec2(uv) + ivec2( 1, 1), 0).r, 2.2) * s;\n    signal += pow(texelFetch(iChannel0, ivec2(uv) + ivec2(-1, 1), 0).r, 2.2) * s;\n    signal += pow(texelFetch(iChannel0, ivec2(uv) + ivec2( 1,-1), 0).r, 2.2) * s;\n    signal += pow(texelFetch(iChannel0, ivec2(uv) + ivec2(-1,-1), 0).r, 2.2) * s;\n    #endif\n    \n    if(m) signal *= 0.0; else signal *= 2.0;\n    */\n        \n   #endif\n    \n    return signal;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n#endif\n    \n    uvec2 uv = uvec2(fragCoord - 0.5);\n    \n    \n#ifndef APPLY_FILTER\n    \n    float v = Map(uv);\n    \n    fragColor = vec4(v, 0.0, 0.0, 0.0);\n    \n    return;\n    \n#else\n    \n  #if 0\n    // ===================================================================================================================================\n    const int r = FILTER_RADIUS;\n    \n    float kern[r+1];\n    \n   #ifdef FLATTEN_STOP_BAND\n    kern[r] = 1.0/exp2(float(r) * 2.0);\n   #else\n    float sgn = (uint(r) & 1u) == 0u ? -1.0 : 1.0;\n\n    kern[r] = 1.0/exp2(float(r) * 2.0) * sgn;\n   #endif\n    \n    float sum = kern[r];\n    float n = 0.0;\n    for(int i = r-1; i > 0; --i, ++n)\n    {\n       #ifdef FLATTEN_STOP_BAND\n        kern[i] = kern[i+1] *  ((float(r) * 2.0 - n) / (n + 1.0));\n       #else\n        kern[i] = kern[i+1] * -((float(r) * 2.0 - n) / (n + 1.0));\n       #endif\n        \n        sum += kern[i];\n    }\n    \n    kern[0] = 1.0 - 2.0 * sum;\n    // ===================================================================================================================================\n  #elif 0\n\n    const int r = 1;\n    \n    float kern[r+1];\n    \n    kern[0] = 1.0/2.0;\n    kern[1] = 1.0/4.0;\n    \n  #elif 0\n\n    const int r = 2;\n    \n    float kern[r+1];\n    \n   #ifdef FLATTEN_STOP_BAND\n    kern[0] = 3.0/8.0; kern[1] = 1.0/4.0; kern[2] =  1.0/16.0;\n   #else\n    kern[0] = 5.0/8.0; kern[1] = 1.0/4.0; kern[2] = -1.0/16.0;\n   #endif\n    \n    //kern[0] = mix(3.0/8.0, 5.0/8.0, sin(iTime)*0.5+0.5); kern[1] = 1.0/4.0; kern[2] = -sin(iTime)/16.0;\n\n  #elif 1\n\n    const int r = 3;\n    \n    float kern[r+1];\n    \n   #ifdef FLATTEN_STOP_BAND\n    kern[0] =  5.0/16.0; kern[1] = 15.0/64.0; kern[2] =  3.0/32.0; kern[3] =  1.0/64.0;\n   #else\n    kern[0] = 11.0/16.0; kern[1] = 15.0/64.0; kern[2] = -3.0/32.0; kern[3] =  1.0/64.0;\n   #endif\n    \n   #if 0\n    kern[0] = 1.0/2.0; kern[1] = 9.0/32.0; kern[2] = 0.0; kern[3] = -1.0/32.0;\n   #endif\n    \n  #elif 0\n\n    const int r = 4;\n    \n    float kern[r+1];\n\n   #ifdef FLATTEN_STOP_BAND\n    kern[0] = 35.0/128.0; kern[1] = 7.0/32.0; kern[2] =  7.0/64.0; kern[3] = 1.0/32.0; kern[4] =  1.0/256.0;\n   #else\n    kern[0] = 93.0/128.0; kern[1] = 7.0/32.0; kern[2] = -7.0/64.0; kern[3] = 1.0/32.0; kern[4] = -1.0/256.0;\n   #endif\n    \n   #if 0\n    kern[0] = 55.0/128.0; kern[1] = 9.0/32.0; kern[2] = 3.0/64.0; kern[3] = -1.0/32.0; kern[4] = -3.0/256.0;\n   #endif\n    \n  #elif 0\n    \n    const int r = 5;\n    \n    float kern[r+1];\n        \n   #ifdef FLATTEN_STOP_BAND\n    kern[0] =  63.0/256.0;  kern[1] = 105.0/512.0; kern[2] =  15.0/128.0;\n    kern[3] =  45.0/1024.0; kern[4] =   5.0/512.0; kern[5] =   1.0/1024.0;\n   #else    \n    kern[0] = 193.0/256.0;  kern[1] = 105.0/512.0; kern[2] = -15.0/128.0;\n    kern[3] =  45.0/1024.0; kern[4] =  -5.0/512.0; kern[5] =   1.0/1024.0;\n   #endif\n    \n   #if 0\n    kern[0] =   1.0/2.0;   kern[1] = 75.0/256.0; kern[2] = 0.0;\n    kern[3] = -25.0/512.0; kern[4] =  0.0;       kern[5] = 3.0/512.0;\n   #endif\n    \n  #elif 0\n    \n    const int r = 6;\n    \n    float kern[r+1];\n    \n   #ifdef FLATTEN_STOP_BAND\n    kern[0] = 231.0/1024.0; kern[1] = 99.0/512.0;  kern[2] =  495.0/4096.0; kern[3] = 55.0/1024.0;\n    kern[4] =  33.0/2048.0; kern[5] =  3.0/1024.0; kern[6] =    1.0/4096.0;\n   #else \n    kern[0] = 793.0/1024.0; kern[1] = 99.0/512.0;  kern[2] = -495.0/4096.0; kern[3] = 55.0/1024.0;\n    kern[4] = -33.0/2048.0; kern[5] =  3.0/1024.0; kern[6] =   -1.0/4096.0;\n   #endif\n    \n   #if 0\n    kern[0] = 231.0/512.0;  kern[1] = 75.0/256.0; kern[2] = 75.0/2048.0; kern[3] =-25.0/512.0;\n    kern[4] = -15.0/1024.0; kern[5] =  3.0/512.0; kern[6] =  5.0/2048.0;\n   #endif\n    \n  #endif\n\n    float v = 0.0;\n    //uv*=2u;\n    for(int y = -r; y <= r; ++y)\n    for(int x = -r; x <= r; ++x)\n    {\n        float v0 = Map(uv + uvec2(x, y));\n\n        v += v0 * (kern[abs(x)] * kern[abs(y)]);\n    }\n    \n   #ifdef APPLY_AS_HIGH_PASS_FILTER\n    v = (Map(uv) - v) * 0.5 + 0.5;\n   #endif\n    \n   #if 0\n    // more radially symmetric versions of flat pass-band kernels for r=2 & r=3\n    {\n        float kern0[] = float[](1.0/ 2.0,  1.0/ 4.0,      0.0,      0.0);\n        float kern1[] = float[](3.0/ 8.0,  1.0/ 4.0, 1.0/16.0,      0.0);\n        float kern2[] = float[](5.0/16.0, 15.0/64.0, 3.0/32.0, 1.0/64.0);\n\n        float lp0 = 0.0;\n        float lp1 = 0.0;\n        float lp2 = 0.0;\n\n        int r = 3;\n        for(int y = -r; y <= r; ++y)\n        for(int x = -r; x <= r; ++x)\n        {\n            float v0 = Map(uv + uvec2(x, y));\n\n            lp0 += v0 * (kern0[abs(x)] * kern0[abs(y)]);\n            lp1 += v0 * (kern1[abs(x)] * kern1[abs(y)]);\n            lp2 += v0 * (kern2[abs(x)] * kern2[abs(y)]);\n        }\n\n        v = lp0;\n        v = lp0 * 2.0 - lp1;// r = 2\n        v = lp0 * 3.0 - lp1 * 3.0 + lp2;// r = 3\n    }\n   #endif\n    \n    fragColor = vec4(v, 0.0, 0.0, 0.0);\n    \n#endif\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//2D Signal Inspector template by nimitz 2018 (twitter: @stormoid)\n\n//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE || fragCoord.y > SIZE) {fragColor = vec4(20.0); return;}\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, fragCoord.y), 0).rr;\n        vec2 yn = texelFetch(iChannel1, ivec2(fragCoord.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (fragCoord-.5 -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n  #define SHOW_FOURIER\n\n  #define SIZE (floor(iResolution.y/2.25)*2.)\n\n\nconst float globalScale = 1.;\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvec2 cossin(float x) { return vec2(cos(x), sin(x)); }\n\nvec2 cmul(vec2 c0, vec2 c1)\n{\n\treturn vec2(c0.x * c1.x - c0.y * c1.y, \n\t\t        c0.y * c1.x + c0.x * c1.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}