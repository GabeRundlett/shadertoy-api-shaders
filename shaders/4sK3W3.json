{
    "Shader": {
        "info": {
            "date": "1456754257",
            "description": "The post process pseudo lens flares from my 64k intros since \"fr-078:  Sweet night dreams\" & from my https://youtu.be/HnePmLm-UWE Revision 2015 techtalk and from my Supraleiter indie racing game project. CC0, but please give credits, if you're using it.",
            "flags": 32,
            "hasliked": 0,
            "id": "4sK3W3",
            "likes": 6,
            "name": "Post process pseudo lens flares",
            "published": 3,
            "tags": [
                "postprocessing",
                "lensflares"
            ],
            "usePreview": 1,
            "username": "BeRo",
            "viewed": 2324
        },
        "renderpass": [
            {
                "code": "// The post process pseudo lens flares from my 64k intros since \"fr-078:  Sweet night dreams\" \n// and from my https://youtu.be/HnePmLm-UWE Revision 2015 techtalk and from my Supraleiter\n// indie racing game project\n\n// Post processing (lens flare + filmic heji HDR color operator + vignette) \n\n// Copyright (C) 2016 by Benjamin 'BeRo' Rosseaux\n// Because the german law knows no public domain in the usual sense,\n// this code is licensed under the CC0 license \n// http://creativecommons.org/publicdomain/zero/1.0/\n\n// But please give credits, if you're using it.\n\nfloat uAspectRatio;\nfloat uInverseAspectRatio;\nconst float uDispersal = 0.3;\nconst float uHaloWidth = 0.6;\nconst float uDistortion = 1.5;\nconst float uBrightDark = 0.5;\n\nvec2 vTexCoord;\n    \nfloat noise(vec2 p){\n  vec2 f = fract(p);\n  f = (f * f) * (3.0 - (2.0 * f));    \n\tfloat n = dot(floor(p), vec2(1.0, 157.0));\n  vec4 a = fract(sin(vec4(n + 0.0, n + 1.0, n + 157.0, n + 158.0)) * 43758.5453123);\n  return mix(mix(a.x, a.y, f.x), mix(a.z, a.w, f.x), f.y);\n} \n\nfloat fbm(vec2 p){\n  const mat2 m = mat2(0.80, -0.60, 0.60, 0.80);\n  float f = 0.0;\n  f += 0.5000*noise(p); p = m*p*2.02;\n  f += 0.2500*noise(p); p = m*p*2.03;\n  f += 0.1250*noise(p); p = m*p*2.01;\n  f += 0.0625*noise(p);\n  return f/0.9375;\n} \n\nvec4 getLensColor(float x){\n  // color gradient values from http://vserver.rosseaux.net/stuff/lenscolor.png\n  // you can try to curve-fitting it, my own tries weren't optically better (and smaller) than the multiple mix+smoothstep solution \n  return vec4(vec3(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(mix(vec3(1.0, 1.0, 1.0),\n                                                                               vec3(0.914, 0.871, 0.914), smoothstep(0.0, 0.063, x)),\n                                                                           vec3(0.714, 0.588, 0.773), smoothstep(0.063, 0.125, x)),\n                                                                       vec3(0.384, 0.545, 0.631), smoothstep(0.125, 0.188, x)),\n                                                                   vec3(0.588, 0.431, 0.616), smoothstep(0.188, 0.227, x)),\n                                                               vec3(0.31, 0.204, 0.537), smoothstep(0.227, 0.251, x)),\n                                                           vec3(0.192, 0.106, 0.286), smoothstep(0.251, 0.314, x)),\n                                                       vec3(0.102, 0.008, 0.341), smoothstep(0.314, 0.392, x)),\n                                                   vec3(0.086, 0.0, 0.141), smoothstep(0.392, 0.502, x)),\n                                               vec3(1.0, 0.31, 0.0), smoothstep(0.502, 0.604, x)),\n                                           vec3(1.0, 0.49, 0.0), smoothstep(0.604, 0.643, x)),\n                                       vec3(1.0, 0.929, 0.0), smoothstep(0.643, 0.761, x)),\n                                   vec3(1.0, 0.086, 0.424), smoothstep(0.761, 0.847, x)),\n                               vec3(1.0, 0.49, 0.0), smoothstep(0.847, 0.89, x)),\n                           vec3(0.945, 0.275, 0.475), smoothstep(0.89, 0.941, x)),\n                       vec3(0.251, 0.275, 0.796), smoothstep(0.941, 1.0, x))),\n                    1.0);\n}\n\nvec4 getLensStar(vec2 p){\n  // just be creative to create your own procedural lens star textures :)\n  vec2 pp = (p - vec2(0.5)) * 2.0;\n  float a = atan(pp.y, pp.x);\n  vec4 cp = vec4(sin(a * 1.0), length(pp), sin(a * 13.0), sin(a * 53.0));\n  float d = sin(clamp(pow(length(vec2(0.5) - p) * 2.0, 5.0), 0.0, 1.0) * 3.14159);\n  vec3 c = vec3(d) * vec3(fbm(cp.xy * 16.0) * fbm(cp.zw * 9.0) * max(max(max(max(0.5, sin(a * 1.0)), sin(a * 3.0) * 0.8), sin(a * 7.0) * 0.8), sin(a * 9.0) * 0.6));\n  c *= vec3(mix(1.0, (sin(length(pp.xy) * 256.0) * 0.5) + 0.5, sin((clamp((length(pp.xy) - 0.875) / 0.1, 0.0, 1.0) + 0.0) * 2.0 * 3.14159) * 0.5) + 0.5) * 0.3275;\n  return vec4(vec3(c * 4.0), d);\t\n}\n\nvec4 getLensDirt(vec2 p){\n  // just be creative to create your own procedural lens dirt textures :)\n  p.xy += vec2(fbm(p.yx * 3.0), fbm(p.yx * 6.0)) * 0.0625;\n  vec3 o = vec3(mix(0.125, 0.25, max(max(smoothstep(0.4, 0.0, length(p - vec2(0.25))),\n                                         smoothstep(0.4, 0.0, length(p - vec2(0.75)))),\n                                         smoothstep(0.8, 0.0, length(p - vec2(0.875, 0.25))))));\n  o += vec3(max(fbm(p * 1.0) - 0.5, 0.0)) * 0.5;\n  o += vec3(max(fbm(p * 2.0) - 0.5, 0.0)) * 0.5;\n  o += vec3(max(fbm(p * 4.0) - 0.5, 0.0)) * 0.25;\n  o += vec3(max(fbm(p * 8.0) - 0.75, 0.0)) * 1.0;\n  o += vec3(max(fbm(p * 16.0) - 0.75, 0.0)) * 0.75;\n  o += vec3(max(fbm(p * 64.0) - 0.75, 0.0)) * 0.5;\n  return vec4(clamp(o, vec3(0.0), vec3(1.0)), 1.0);\t\n}\n\nvec4 textureLimited(const in sampler2D tex, const in vec2 texCoord){\n\tif(((texCoord.x < 0.) || (texCoord.y < 0.)) || ((texCoord.x > 1.) || (texCoord.y > 1.))){\n\t \treturn vec4(0.0);\n\t}else{\n\t \treturn texture(tex, texCoord);// * pow(1.0 - (length(texCoord.y - vec2(0.5)) * 2.0), 4.0);\n\t}\n}\n\nvec4 textureDistorted(const in sampler2D tex, const in vec2 texCoord, const in vec2 direction, const in vec3 distortion) {\n  return vec4(textureLimited(tex, (texCoord + (direction * distortion.r))).r,\n              textureLimited(tex, (texCoord + (direction * distortion.g))).g,\n\t\t\t\t\t\t\ttextureLimited(tex, (texCoord + (direction * distortion.b))).b,\n              1.0);\n}\n\nvec4 getLensFlare(){\n  vec2 aspectTexCoord = vec2(1.0) - (((vTexCoord - vec2(0.5)) * vec2(1.0, uInverseAspectRatio)) + vec2(0.5)); \n  vec2 texCoord = vec2(1.0) - vTexCoord; \n  vec2 ghostVec = (vec2(0.5) - texCoord) * uDispersal;\n  vec2 ghostVecAspectNormalized = normalize(ghostVec * vec2(1.0, uInverseAspectRatio)) * vec2(1.0, uAspectRatio);\n  vec2 haloVec = normalize(ghostVec) * uHaloWidth;\n  vec2 haloVecAspectNormalized = ghostVecAspectNormalized * uHaloWidth;\n  vec2 texelSize = vec2(1.0) / vec2(iChannelResolution[1].xy);\n  vec3 distortion = vec3(-(texelSize.x * uDistortion), 0.0, texelSize.x * uDistortion);\n  vec4 c = vec4(0.0);\n  for (int i = 0; i < 8; i++) {\n    vec2 offset = texCoord + (ghostVec * float(i));\n    c += textureDistorted(iChannel1, offset, ghostVecAspectNormalized, distortion) * pow(max(0.0, 1.0 - (length(vec2(0.5) - offset) / length(vec2(0.5)))), 10.0);\n  }                       \n  vec2 haloOffset = texCoord + haloVecAspectNormalized; \n  return (c * getLensColor((length(vec2(0.5) - aspectTexCoord) / length(vec2(0.5))))) + \n         (textureDistorted(iChannel1, haloOffset, ghostVecAspectNormalized, distortion) * pow(max(0.0, 1.0 - (length(vec2(0.5) - haloOffset) / length(vec2(0.5)))), 10.0));\n} \n\nvec4 hejl(const in vec4 color) {\n  vec4 x = max(vec4(0.0), color - vec4(0.004));\n  return (x * ((6.2 * x) + vec4(0.5))) / max(x * ((6.2 * x) + vec4(1.7)) + vec4(0.06), vec4(1e-8));\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  uAspectRatio = iResolution.x / iResolution.y;\n  uInverseAspectRatio = iResolution.y / iResolution.x;\n  mat4 uCameraMatrix4x4 = mat4(1.0, 0.0, 0.0, 0.0,\n                               0.0, 1.0, 0.0, 0.0,\n                               0.0, 0.0, 1.0, 0.0,\n                               0.0, 0.0, 0.0, 1.0);                               \n  vTexCoord = fragCoord.xy / iResolution.xy;\n  vec2 texCoord = ((vTexCoord - vec2(0.5)) * vec2(uAspectRatio, 1.0) * 0.5) + vec2(0.5);\n  vec4 lensMod = getLensDirt(vTexCoord);\n  float tooBright = 1.0 - (clamp(uBrightDark, 0.0, 0.5) * 2.0),\n        tooDark = clamp(uBrightDark - 0.5, 0.0, 0.5) * 2.0;\n  lensMod = mix(lensMod, pow(lensMod * 2.0, vec4(2.2)) * 0.5, tooBright);\n  float lensStarRotationAngle = ((uCameraMatrix4x4[0].x + uCameraMatrix4x4[1].y + uCameraMatrix4x4[2].z) * 3.14159) * (1.0 / 3.0);\n  vec2 lensStarTexCoord = (mat2(cos(lensStarRotationAngle), -sin(lensStarRotationAngle), sin(lensStarRotationAngle), cos(lensStarRotationAngle)) * (texCoord - vec2(0.5))) + vec2(0.5);\n  lensMod += getLensStar(lensStarTexCoord) * 1.;  \n  vec4 color = texture(iChannel0, vTexCoord) + (getLensFlare() * lensMod);\n  float exposure = 1.0;\n  float vignette = pow(max(0.0, 1.0 - (length(vec2(0.5) - vTexCoord) / length(vec2(0.5)))), 0.4);\n//fragColor = getLensColor(vTexCoord.x);\n//fragColor = getLensStar(vTexCoord);\n//fragColor = getLensDirt(vTexCoord);\n  fragColor = clamp(hejl(color * exposure * vignette), vec4(0.0), vec4(1.0));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Scene stuff\n\nvec3 rotateX(vec3 p,float a){\n  vec2 cs=vec2(cos(a),sin(a));\n  return vec3(p.x,(cs.x*p.y)-(cs.y*p.z),(cs.y*p.y)+(cs.x*p.z));\n}\n\nvec3 rotateY(vec3 p,float a){\n  vec2 cs=vec2(cos(a),sin(a));\n  return vec3((cs.x*p.x)+(cs.y*p.z),p.y,(cs.x*p.z)-(cs.y*p.x));\n}\n\nvec3 rotateZ(vec3 p,float a){\n  vec2 cs=vec2(cos(a),sin(a));\n  return vec3((cs.x*p.x)+(cs.y*p.y),(cs.x*p.y)-(cs.y*p.x),p.z);\n}\n\nconst float PI=3.14159265358979323846264;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 pixel=-1.0+(2.0*(fragCoord.xy/iResolution.xy));\n  float asp=iResolution.x/iResolution.y,m=0.0,roty=0.0,rotx=0.0;\n  vec3 rd=normalize(vec3(asp*pixel.x,-pixel.y,2.0));\n  float time = iTime * 0.25;\n  roty=time*PI*0.5;\n  rotx=cos(time*PI*0.7)*PI*0.5;\n  rd=rotateY(rotateX(rd,rotx),roty);\n  fragColor = vec4(texture(iChannel0, rd).xyz * 1.0,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Thresholding and scaling\n\n// Copyright (C) 2016 by Benjamin 'BeRo' Rosseaux\n// Because the german law knows no public domain in the usual sense,\n// this code is licensed under the CC0 license \n// http://creativecommons.org/publicdomain/zero/1.0/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = max(vec4(0.0), texture(iChannel0, fragCoord.xy / iResolution.xy) - vec4(0.5)) * 10.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Blurring in x direction\n\n// Copyright (C) 2016 by Benjamin 'BeRo' Rosseaux\n// Because the german law knows no public domain in the usual sense,\n// this code is licensed under the CC0 license \n// http://creativecommons.org/publicdomain/zero/1.0/\n\n// You can use any blur variant and any blur size of your taste here \n\nvec4 GaussianBlur63(const in sampler2D pTexSource, const in vec2 pCenterUV, const in float pLOD, const in vec2 pPixelOffset){\n  return ((texture(pTexSource, pCenterUV + (pPixelOffset * 0.6655479694036902)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 0.6655479694036902))) * 0.0599136953241179)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 2.493712921290222)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 2.493712921290222))) * 0.07758097185631951)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 4.488684594173841)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 4.488684594173841))) * 0.07231852189840038)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 6.483658555984297)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 6.483658555984297))) * 0.06476077451799045)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 8.478635821570533)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 8.478635821570533))) * 0.055711220167732625)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 10.473617403111605)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 10.473617403111605))) * 0.04604064682545439)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 12.468604309302684)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 12.468604309302684))) * 0.03655175467912483)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 14.463597544547007)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 14.463597544547007))) * 0.02787680909208401)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 16.458598108155186)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 16.458598108155186))) * 0.02042423735066097)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 18.453606993553194)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 18.453606993553194))) * 0.014375287044873498)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 20.44862518750038)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 20.44862518750038))) * 0.009719748190692979)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 22.443653669318742)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 22.443653669318742))) * 0.006313369798084606)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 24.43869341013483)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 24.43869341013483))) * 0.0039394453026797525)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 26.43374537213539)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 26.43374537213539))) * 0.0023614374738993053)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 28.428810507838012)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 28.428810507838012))) * 0.001359831963351014)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 30.423889759377865)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 30.423889759377865))) * 0.0007522485145337108);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    fragColor = GaussianBlur63(iChannel0, fragCoord.xy / iResolution.xy, 0.0, vec2(1.0, 0.0) / vec2(iChannelResolution[0].xy));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Blurring in y direction\n\n// Copyright (C) 2016 by Benjamin 'BeRo' Rosseaux\n// Because the german law knows no public domain in the usual sense,\n// this code is licensed under the CC0 license \n// http://creativecommons.org/publicdomain/zero/1.0/\n\n// You can use any blur variant and any blur size of your taste here \n\nvec4 GaussianBlur63(const in sampler2D pTexSource, const in vec2 pCenterUV, const in float pLOD, const in vec2 pPixelOffset){\n  return ((texture(pTexSource, pCenterUV + (pPixelOffset * 0.6655479694036902)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 0.6655479694036902))) * 0.0599136953241179)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 2.493712921290222)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 2.493712921290222))) * 0.07758097185631951)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 4.488684594173841)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 4.488684594173841))) * 0.07231852189840038)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 6.483658555984297)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 6.483658555984297))) * 0.06476077451799045)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 8.478635821570533)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 8.478635821570533))) * 0.055711220167732625)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 10.473617403111605)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 10.473617403111605))) * 0.04604064682545439)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 12.468604309302684)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 12.468604309302684))) * 0.03655175467912483)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 14.463597544547007)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 14.463597544547007))) * 0.02787680909208401)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 16.458598108155186)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 16.458598108155186))) * 0.02042423735066097)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 18.453606993553194)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 18.453606993553194))) * 0.014375287044873498)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 20.44862518750038)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 20.44862518750038))) * 0.009719748190692979)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 22.443653669318742)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 22.443653669318742))) * 0.006313369798084606)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 24.43869341013483)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 24.43869341013483))) * 0.0039394453026797525)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 26.43374537213539)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 26.43374537213539))) * 0.0023614374738993053)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 28.428810507838012)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 28.428810507838012))) * 0.001359831963351014)+\n         ((texture(pTexSource, pCenterUV + (pPixelOffset * 30.423889759377865)) +\n           texture(pTexSource, pCenterUV - (pPixelOffset * 30.423889759377865))) * 0.0007522485145337108);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    fragColor = GaussianBlur63(iChannel0, fragCoord.xy / iResolution.xy, 0.0, vec2(0.0, 1.0) / vec2(iChannelResolution[0].xy));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}