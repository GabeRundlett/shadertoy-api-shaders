{
    "Shader": {
        "info": {
            "date": "1622482111",
            "description": "Chinese papercuts of the character \"囍\"",
            "flags": 0,
            "hasliked": 0,
            "id": "ftX3zX",
            "likes": 4,
            "name": "Chinese papercuts 1",
            "published": 3,
            "tags": [
                "papercuts"
            ],
            "usePreview": 0,
            "username": "caogtaa",
            "viewed": 280
        },
        "renderpass": [
            {
                "code": "// Papercut tutorial: https://www.youtube.com/watch?v=2Wgtj-q2Eig\n\n// Chinese papercuts\n// The character \"囍\", aka. \"Red Double Happiness\", is widely used in wedding since acient times in China.\n// Most Chinese are taught this in their childhood.\n// It is interesting that papercuts use symmetry a lot, just like how we play with shaders :-)\n\n#define PI 3.14159265\n\n// Function from iq\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox(in vec2 p, in vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// orange gradient\nvec3 pallette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.);\n    vec3 b = vec3(0.5, 0.31, 0.);\n    vec3 c = vec3(0., 0.15, 0.);\n    vec3 d = vec3(1., 0., 0.);\n    return a + b*cos(2.*PI*(c*t+d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    \n    // keep current uv in st for picking bg color\n    vec2 st = uv;\n    float mask = 1.;\n\n    // scale and cut margins\n    uv *= 1.2;\n    vec2 center = step(abs(uv), vec2(1.));\n    mask *= center.x * center.y;\n    \n    // overlap & cut\n    uv.x = abs(uv.x);\n    uv.x = uv.x > 0.5 ? 1.0 - uv.x : uv.x;\n    \n    // Divide space into 4 * 14 grids, for easy counting\n    // After overlapping, range of x is [0, 0.5], range of y is [-1, 1]\n    const vec2 grids = vec2(4./0.5, 14./2.);\n    \n    vec2 guv = uv * grids;\n    mask = min(mask, sdBox(guv - vec2(1.5, 6.5), vec2(1.5, 0.5)));\n    guv.y = guv.y < -1. ? guv.y + 6. : guv.y;\n    \n    mask = min(mask, sdBox(guv - vec2(2.5, 0.5), vec2(1.5, 0.5)));\n    mask = min(mask, sdBox(guv - vec2(1.5, 2.5), vec2(1.5, 0.5)));\n    mask = min(mask, sdBox(guv - vec2(1.5, 4.5), vec2(1.5, 0.5)));\n    mask = min(mask, sdBox(guv - vec2(0., 0.5), vec2(0.05, 1.5)));\n    \n    float blur = 2./iResolution.y;\n    mask = smoothstep(0., blur, mask);    \n\n    // mix color\n    vec3 col = vec3(0.);\n    col += mix(pallette(length(st)), pallette(2.5), mask);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}