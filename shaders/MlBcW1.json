{
    "Shader": {
        "info": {
            "date": "1508347432",
            "description": "Mouse input modifies 4th dimension of the camera matrix (lens), better while time is paused\npause and click and drag, to make this more \"intuitive?\"\n\nbackup fork of\nhttps://www.shadertoy.com/view/4tjyDz",
            "flags": 0,
            "hasliked": 0,
            "id": "MlBcW1",
            "likes": 4,
            "name": "4d truchet coaster backup ollj",
            "published": 3,
            "tags": [
                "truchet",
                "4d",
                "rollercoaster"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 603
        },
        "renderpass": [
            {
                "code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define dir3(num) vec4(equal(abs(dir),vec4(num)))\n//#define fra(u) (u-.5*iResolution.xy)*1./iResolution.y)\n#define fr(a) (a*2.0-iResolution.xy)/iResolution.y\n\n#define dd(a) dot(a,a)\n\n//#define range .061*log(1.1+dd(uv-fr(iMouse.xy)))\n\n#define range .0061*length(1.1+dd(uv-fr(iMouse2.xy)))*(fr(iMouse2.zw)+fr(iMouse2.xy))\n\n//your lenses 4th dimension is a metaball, set by 2 muse positions.\n//#define range .061*length(uv-fr(iMouse.zw))*(length(uv-fr(iMouse.xy)))\n//deal with it!\n\n\n\n#define pi acos(-1.0)\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\nfloat box(vec4 p, float size) {\n    vec4 p2 = abs(p)-size;\n    return length(max(p2,0.0))+min(0.0,max(max(max(p2.x,p2.y),p2.z),p2.w));\n}\n\nfloat torus2(vec4 p, vec2 r) {//creates 4 toruses\n    return length(vec3(abs(length(p.xy)-r.x),abs(p.zw))-0.1)-r.y;\n}\n\n/*float map(vec4 p) {\n    vec4 p2 = mod(p,4.0)-2.0;\n    \n    //float transition = clamp(abs(mod(iTime*0.2,2.0)-1.0)*5.0-2.0,0.0,1.0);\n    //return min(box(p2,1.0-transition)-transition,length(abs(p2)-1.0)-0.5);\n    //return box(p2,1.0-transition)-transition;\n    return torus(p2,vec2(1.0,0.3));\n}*/\n\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat map(vec4 p) {\n    \n    //vec4 p2 = abs(mod(p,4.0)-2.0)-1.0;\n    //return box(p2,0.5);\n    vec4 p2 = mod(p,2.0)-1.0;\n    vec4 floorpos = floor(p*0.5);\n    \n    //the truchet flipping\n    vec4 orientation = floor(hash44(floorpos)+0.5)*2.0-1.0;\n    //orientation.yz = vec2(1.0);\n    \n    //actually flipping the truchet\n    vec4 p3 = p2*orientation;\n    \n    //positions relative to truchet centers\n    vec4[4] truchet = vec4[4] (\n        vec4(p3.xy+vec2(-1,+1),p3.zw),// +x +y       fixed - +\n        vec4(p3.yz+vec2(-1,+1),p3.xw),//    +y +z    fixed - +\n        vec4(p3.zw+vec2(-1,+1),p3.xy),//       +z +w fixed - +\n        vec4(p3.xw+vec2(+1,-1),p3.yz) // +x       +w fixed + -\n    );\n    \n    //finding distances to the torises\n    vec4 lens = vec4(\n        torus2(truchet[0],vec2(1.0,0.05)),\n        torus2(truchet[1],vec2(1.0,0.05)),\n        torus2(truchet[2],vec2(1.0,0.05)),\n        torus2(truchet[3],vec2(1.0,0.05)));\n    \n    //creating mask for smallest distance,\n    //so in case i want to do some crazy moddeling i can do that without doing it for all the toruses(4x slower!)\n    vec4 mask = vec4(lessThanEqual(lens, min(min(lens.yzwx,lens.zwxy),lens.wxyz)));\n    float len = dot(lens,mask);\n    \n    return len;\n}\n\n//finding a normal, rough approxximation\nvec4 findnormal(vec4 p, float len) {\n    vec2 eps = vec2(0.01,0.0);\n    \n    return normalize(vec4(\n        map(p+eps.xyyy)-len,\n        map(p+eps.yxyy)-len,\n        map(p+eps.yyxy)-len,\n        map(p+eps.yyyx)-len));\n}\n\nvec4 shade(vec4 p, vec4 d, vec4 objnorm, float depth) {\n    vec4 sun = normalize(vec4(-1.0));\n    vec4 reflectnorm = reflect(d,objnorm);\n    vec4 color = objnorm*0.5+0.5;\n    vec4 fragColor = vec4(color*max(0.4,0.8*dot(objnorm,sun)));\n    fragColor /= depth*depth*0.01+1.0;\n    fragColor = max(fragColor,(dot(reflectnorm,sun)-0.9)*3.0/depth/depth);\n    return clamp(fragColor,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy*2.0-iResolution.xy) / iResolution.y;\n\n    \n    vec4 floorpos = vec4(0,0,0,0);\n    vec4 pos = vec4(0,1,1,1);\n    vec4 dir = vec4(1,2,3,4);\n    int num = 0;\n    float time = iTime*0.2;\n    for (float i = 0.0; i <= floor(time); i++) {\n        \n        pos += dir*dir3(1);\n        \n    \tvec4 orientation = floor(hash44(floorpos)+0.5)*2.0-1.0; //the truchet flipping\n        //orientation.xyz = vec3(1.0);\n        \n        dir *= orientation;\n        \n        int num2 = (num-int(dot(dir,dir3(1)))+4)%4;\n        float back = dir[num2];\n        dir[num2] = dir[num];\n        dir[num] = -back;\n        num = num2;\n        \n        dir *= orientation;\n        \n        floorpos += dir*dir3(1);\n        pos += dir*dir3(1);\n    }\n\t\n    vec4 orientation = floor(hash44(floorpos)+0.5)*2.0-1.0; //the truchet flipping\n    vec4 dir2 = dir;\n    \n    dir *= orientation;\n    \n    int num2 = (num-int(dot(dir,dir3(1)))+4)%4;\n    float back = dir[num2];\n    dir[num2] = dir[num];\n    dir[num] = -back;\n    num = num2;\n    \n    dir *= orientation;\n\t\n    //animation\n    pos += dir2*vec4(equal(abs(dir2),vec4(1.0)))*(sin(fract(time)*3.14*0.5));\n    pos += dir*dir3(1)*(1.0-cos(fract(time)*pi*0.5));\n    vec4 forward = dir2*cos(fract(time)*pi*0.5)+dir*sin(fract(time)*pi*0.5);\n    \n    /*\n    mat4 rotation = mat4(\n        vec4(0.0),\n        vec4(0.0),\n        vec4(0.0),\n        vec4(0.0));\n    rotation[3] = forward;\n    rotation[2] = normalize(cross(forward,vec4(1)));\n    rotation[1] = cross(rotation[1],forward);\n    //rotation[0] = cross(rotation[2],rotation[1]);\n    */\n    \n    mat4 rotation = mat4(\n        vec4(0.0),\n        vec4(0.0),\n        vec4(0.0),\n        vec4(0.0));\n    \n    vec2 t = vec2(cos(fract(time)*pi*0.5),sin(fract(time)*pi*0.5));\n\trotation[3] = normalize(dir2*vec4(equal(abs(dir2),vec4(4)))/4.0*t.x+dir*dir3(4)/4.0*t.y);\n    rotation[0] = normalize(dir2*vec4(equal(abs(dir2),vec4(3)))/3.0*t.x+dir*dir3(3)/3.0*t.y);\n    rotation[1] = normalize(dir2*vec4(equal(abs(dir2),vec4(2)))/2.0*t.x+dir*dir3(2)/2.0*t.y);\n    rotation[2] = normalize(dir2*vec4(equal(abs(dir2),vec4(1)))/1.0*t.x+dir*dir3(1)/1.0*t.y);\n    \n    vec4 pos4d = pos;//vec4(0,0,iTime+sin(iTime*pi)/pi-0.1,0).wxyz;\n    \n    vec4 iMouse2=iMouse;//copy to be possibly overwritten\n    if(iMouse2.z<0.){//ib mouse is not dragged, overwrite with automatedMouse\n    float speed=1.;//how fast virtual mouse moves\n    float scale=2.5;//how far virtual mouse drags\n    float time=iTime+sin(speed*iTime)*.5+.5; //oscillate time over time\n    float phi=sqrt(5.)*.5+.5;\n    iMouse2.x=scale*iResolution.x*(sin(speed*time    )*.5+.5);\n    iMouse2.z=scale*iResolution.x*(sin(speed*time*phi)*.5+.5);\n    iMouse2.y=scale*iResolution.y*(cos(speed*time    )*.5+.5);\n    iMouse2.w=scale*iResolution.y*(cos(speed*time*phi)*.5+.5);\n    }\n    \n    vec4 dir4d = normalize(vec4(uv,1.,range)); //range uses imouse2.\n    \n    dir4d = rotation*dir4d;\n    \n    //dir4d.xy *= rot(iTime*0.1);\n    //dir4d.yz *= rot(iTime*0.1);\n    //dir4d.zw *= rot(iTime*0.1);\n    //dir4d.wx *= rot(iTime*0.1);\n    \n    float dist = 0.0;\n    bool hit = false;\n    \n    float reflections = 1.0;\n    float colorlength = 0.0;\n    float len;\n    for (int i = 0; i < 100; i++) {\n        len = map(pos4d);\n        if (abs(len) < 0.01) {\n            hit = true;\n            /*vec4 normal = findnormal(pos4d);\n        \tfragColor += shade(pos4d,dir4d, normal,dist)*reflections;\n            dir4d = reflect(dir4d,normal);\n            pos4d += dir4d*0.1;\n            colorlength += reflections;\n            if (reflections < 1.0) break;\n            reflections *= 0.5;*/\n            break;\n            \n        }\n        pos4d += dir4d*abs(len);\n        dist += abs(len);\n    }\n    fragColor /= colorlength;\n    if (hit)\n    {\n        /*\n        fragColor = (mod(pos4d,3.0)-1.5);\n        /*\n        vec4 sun = normalize(vec4(-1.0));\n        vec4 objnorm = findnormal(pos4d);\n        vec4 reflectnorm = reflect(dir4d,objnorm);\n        fragColor = objnorm*0.5+0.5;\n        fragColor = vec4(fragColor*max(0.6,dot(objnorm,sun)));\n        */\n        fragColor = shade(pos4d,dir4d, findnormal(pos4d,len), dist);\n    }else fragColor=vec4(0,0,0,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}