{
    "Shader": {
        "info": {
            "date": "1608814590",
            "description": "use mouse :)",
            "flags": 0,
            "hasliked": 0,
            "id": "3ldcWr",
            "likes": 22,
            "name": "meta-tetra-toroidal symmetry v0",
            "published": 3,
            "tags": [
                "sdf",
                "sphere",
                "tiling"
            ],
            "usePreview": 0,
            "username": "cyperus",
            "viewed": 734
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"meta-tetra-torodial symmetry v0\"\n//\n// created by Colling Patrik (cyperus) in 2020\n//\n//\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float cam_dist = 5.5; // camera distance\nconst float bb_size = 2.5; // bounding sphere size\nconst float rm_rlmin = 0.0; // ray march ray_length minimum\nconst float rm_rlmax = 50.0; // ray march ray-length maximum\nconst int   rm_imax = 200; // ray march maximal number of iterations\n\nconst float rm_p3slmul = 0.32772; // ray march pow(step length multiplier,3)\n// anti-aliasing\nconst float AA = 2.0;\n\n////////////////////////////////////////////////////////////////////////////////\n\n// const\nconst float PI = 3.14159265359;\n\n// 2D transformations: vec2 => vec2\n// complex\nvec2 cmul(vec2 za,vec2 zb) // za*zb\n{\n    return za*mat2(zb.x,-zb.y,zb.yx);\n}\n\nvec2 cinv(vec2 z) // 1/z\n{\n    return z*vec2(1.,-1.)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z, vec2 w) // z/w\n{\n    return cmul(z,cinv(w));\n}\n\nvec2 cpow(vec2 z, float q) // z^q\n{\n    float r = pow(length(z), q);\n\tfloat a=q* atan(z.y,z.x);\n    return vec2(r*cos(a),r*sin(a));\n}\n\nvec2 cpow(vec2 z, int n) // z^n\n{\n    vec2 w = z;\n    for (int i = 1; i < n; i++){\n    w = cmul(w,z);\n    }\n    return w;\n}\n\nvec2 crot(vec2 z,float a) // z*e^(i*a)\n{\n    return cmul(z, vec2(cos(-a),sin(-a)));\n}\n\nvec2 crpt(vec2 z,float a, int n, float x0) // z_out = (z*e^ia)^n-x0\n{\n\treturn cpow(crot(z, a), n) - vec2(x0, 0.);\n}\n\n// 3D-transformations: vec3 => vec3\n//color\nvec3 hsv2rgb(float h, float s, float v)  // hue, saturation, value\n{\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n    return v * mix( vec3(1.0), rgb, s);\n}\n\nvec2 isphere(in vec3 ro, in vec3 rd, in float r )\n{\n    // sphere centered at the origin, with size rd   \n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;\n    \n    if( h<0.0 ) return vec2(-1.0);\n\n    h = sqrt( h );\n\n    return -b + vec2(-h,h);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfloat map( in vec3 p, out vec4 mat )\n{\n    //// sdf's\n    float time = 0.1 * iTime;\n\tvec3 pn = normalize(p);\n    vec2 z, zk; \n    // F3,3(z) tetrahedral symmetry\n    int k = 3, n = 3;\n    const float a1 = 2.*sqrt(2.);\n    if (pn.z < 0.) // stereographic (north pol)\n    {\n        z = pn.xy/(1.0-pn.z);\n        zk = cpow(z,k);\n        z = 1./(8.*a1) * zk;\n        z = cmul(z, cpow(zk-vec2(a1,0.),k));\n        z = cdiv(z, cpow(zk+ vec2(1./a1,0.0),n));\n    }else        // stereographic (south pol)\n    {\n        z = vec2(pn.x, -pn.y)/(1.+pn.z);\n        zk = cpow(z,k);\n        z = 1./(8.*a1)*cinv(zk);       \n        z = cmul(z, cpow(vec2(1.,0.) - zk * a1 ,k));\n        z = cdiv(z, cpow(vec2(1.,0.) + zk / a1 ,n));    \n    }\n    \n    // polygon properties\n    float sr = float(length(z)>1.0?-n:k);\n\tfloat au = atan(z.y,z.x)-0.5*PI*sign(sr);\n\tfloat av = atan(log(length(z))*0.1);\n\n\t// spherical => cartesian coords\n\tp = length(p)*vec3(\tsin(av)*cos(au),\n                        sin(av)*sin(au),\n                        cos(av));\n\n    // torus \n    au = atan(p.y, p.x);\n    z = vec2( length(p.xy), p.z);\n    z = cmul(z,z); z.x += 4.0;\n\n    float ssr = sign(sr);\n\t// fractal level 1\n    z = crpt(z, -ssr*au/3.0, 3,  2.0+3.0*cos(au));\n\n\t// fractal level 2\n    z = crpt(z, PI*ssr*time, 2, 1. + 0.5 * cos(time) );\n    \n    // actual ray data\n\tmat = vec4(z,au,sr);\n    \n    // step length estimation\n\treturn log(length(z)); // :( Not perfect!\n}\n\nfloat intersect( in vec3 ro, in vec3 rd, out vec4 rescol, in float px )\n{\n    float res = -1.0; // init no rayintersection\n    \n    // boundingshape\n    vec2 dis = isphere( ro, rd ,abs(bb_size));\n    if( dis.y<0.0 ) // does ray hit boundingshape?\n        return -1.0;\n    dis.x = max( dis.x, max(rm_rlmin,0.0) );// start_raylength from bb_near_hit or raylength_minimum\n    dis.y = min( dis.y, rm_rlmax );\t// end_raylength from bb_far_hit or raylength_maximum\n    \n    // raymarch signed distance field\n\tvec4 data; // data from surface hit point and accumulated data while raymarching\n\tfloat fh = (0.5-0.0001)*rm_p3slmul*rm_p3slmul*rm_p3slmul + 0.0001; // fh slider response curve\n\tfloat t = dis.x; // ray iteration starts at boundingshape\n\tfor( int i=0; i<rm_imax; i++  )\n    { \n        vec3 pos = ro + rd*t;\n        float th = 0.005*px*t;// sdf surface hit tolerance\n\t\tfloat h = map(pos, data);\n\t\tif( t>dis.y || abs(h)<th ) break; // ray is outside boundingshape or sdf_surface_hit.\n        t += h*fh; // update ray length  with step_length * step_length_multiplier\n    }\n    \n    if( t<dis.y ) // Is ray inside boundingshape?\n    {\n        rescol = data; // return data\n        res = t; // return ray_length\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos, in float px )\n{\n    vec4 tmp; // dummy variable\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*px;\n    return normalize( e.xyy*map( pos + e.xyy,tmp ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx,tmp ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy,tmp ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx,tmp ) );\n}\n\n// from iq\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<1; i++ )\n    {\n    \tvec4 temp;\n    \tfloat h = map( ro + rd*t, temp );\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\n// from iq\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<1; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n    \tvec4 temp;\n    \tfloat dd = map( aopos, temp );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n// transform from mla\nvec3 transform(in vec4 p)\n{\n\tif (iMouse.x > 0.0)\n\t{\n\t\tfloat phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n\t\tfloat theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n\t\tp.yz = crot(p.yz,theta);\n\t\tp.zx = crot(p.zx,-phi);\n\t}\n\tp.xz = crot(p.xz,p.w*0.01);\n\treturn p.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // time\n    float time = iTime;\n    \n    // camera\n    float fle = 2.0;\n\tvec3 ro = transform(vec4(0,0,-cam_dist,time)).xyz;\n\n\t// anti-aliasing\n\tvec3 aacol = vec3(0);\n\tfor (float i = 0.0; i < max(-time,AA); i++) {\n\t\tfor (float j = 0.0; j < max(-time,AA); j++) {\n        \n\t\t\t// ray direction\n\t\t\tvec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n\t\t\tvec3 rd = normalize(transform(vec4(uv,fle,time)));\n            \n\t\t\t// ray distance\n\t\t\tvec4 mat = vec4(0.0);\n\t\t\tfloat px = 2.0/( iResolution.y*fle );\n\t\t\tfloat t = intersect( ro, rd, mat, px );\n\n\t\t\t// light\n\t\t\tconst vec3 ld = 0.5*vec3(0.,1.,.5); // ligth direction\n\t\t\tconst vec3 lc = vec3(0.4);// ligth color\n\t\t\tvec3 bg = vec3(0.8,0.9,2.0)*0.3*(0.9+0.1*rd.y);\t// background-color\n\n\t\t\t// color\n\t\t\tvec3 col = vec3(0.6,0.4,0.7);\n\n\t\t\tif (t < 0.0){ // sky\n\t\t\t\tcol = bg;\n\t\t\t\tcol += 6.0*vec3(0.8,0.7,0.5)*pow( clamp(dot(rd,lc),0.0,1.0), 32.0 ); // sun\n\t\t\t}\n\t\t\telse{ // object surface\n\t\t\t\tvec3 p = ro + rd * t;\n\t\t\t\tvec3 n = calcNormal( p, px );\n\n\t\t\t\t// texture_coords\n\t\t\t\tfloat u = mat.z*0.5/PI;\n\t\t\t\tfloat v = sign(mat.w)*atan(mat.y,mat.x)*0.5/PI;\n\n\t\t\t\t// texture_color\n\t\t\t\tfloat l = 0.5+0.5*cos(0.3*iTime);\n\t\t\t\tfloat col_h = 1.0;\n\t\t\t\tcol_h *= v;\n\t\t\t\t//col_h *= u;\n\t\t\t\tfloat col_s = 1.0;\n\t\t\t\tfloat col_v = 1.0;\n\t\t\t\tcol = hsv2rgb(col_h,col_s,col_v); //(hue, saturation, value)\n\n\t\t\t\t// lighting\n\t\t\t\tfloat occ = calcAO( p, n );\n\t\t\t\tfloat amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n\t\t\t\tvec4 temp; // dummy variable\n\t\t\t\tfloat dif = clamp( dot( n, ld ), 0.0, 1.0 ) * map( p+n*1.16, temp);\n\t\t\t\tfloat spe = pow(clamp( dot( rd, ld ), 0.0, 1.0 ),16.0);\n\t\t\t\tfloat sss = map( p - n*0.001, temp)/0.01;\n\n\t\t\t\t// shading\n\t\t\t\tdif *= softshadow( p, ld, 0.1, 1. );\n\t\t\t\tvec3 brdf = vec3(0.0);\n\t\t\t\tbrdf += 0.2*dif*vec3(1.00,0.90,0.60);\n\t\t\t\tbrdf += 0.2*spe*vec3(0.8,0.60,0.20)*dif;\n\t\t\t\tbrdf += 0.2*amb*vec3(0.40,0.60,0.40)*occ;\n\t\t\t\tbrdf += 0.4;\n\t\t\t\tcol.rgb *= brdf;\n                \n\t\t\t\t// fog\n\t\t\t\tcol = mix( bg,col, exp( -0.025*t*t));\n\t\t\t}\n\t\t\taacol += col;\n\t\t}\n\t}\n\taacol /= float(AA*AA);\n    // gamma\n    aacol = sqrt(aacol);\n    fragColor = vec4(aacol,1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}