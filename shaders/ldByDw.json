{
    "Shader": {
        "info": {
            "date": "1492394583",
            "description": "ESDF-RW-movement\narrow-space\".\"-movement\n\nfork of https://www.shadertoy.com/view/XsjyDW\n\n",
            "flags": 48,
            "hasliked": 0,
            "id": "ldByDw",
            "likes": 11,
            "name": "012 quaternion,cam,Data,2d",
            "published": 3,
            "tags": [
                "text",
                "water",
                "projection",
                "rain",
                "quaternion",
                "rotation",
                "buffer",
                "channel",
                "canvas"
            ],
            "usePreview": 1,
            "username": "ollj",
            "viewed": 1478
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 Out,in vec2 In){ \n    \n    Out=vec4(0);vec4 t=vec4(0);\n    t=texture(iChannel1,In/iResolution.xy, -100.0);//bufB=3d\n    Out.xyzw+=1.*t;\n    \n    t=texture(iChannel2,In/iResolution.xy, -100.0);//bufC=text\n    Out.xyz+=1.*t.w*t.xyz*t.xyz;\n    \n    //Out+= .2*texture(iChannel3,In/iResolution.xy, -100.0);//bufD=2d\n        \n////post processing:\n    Out*=Out;//f(Out)=Out*Out; simple way to increase contrast.\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//camera IO\n// https://www.shadertoy.com/view/4lVXRm\n// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n//#define SkipThis\n#ifdef SkipThis\nvoid mainImage(out vec4 o,in vec2 i){o=vec4(0);}\n#else\n\n#define store(p,v) if(all(equal(In,p+.5)))Out=v\n#define load(P) texture(iChannel1, (P + 0.5) / iChannelResolution[1].xy, -100.0)\n#define key(K)  step(0.5, texture( iChannel0, vec2(K, 1.0/6.0) ).x)\n\nconst vec2 MEMORY_BOUNDARY=vec2(4,3);\nconst vec2 POSITION=vec2(1,0);\nconst vec2 VMOUSE  =vec2(1,1);\nconst vec2 PMOUSE  =vec2(2,1);\nconst vec2 TARGET  =vec2(0,2);\nconst vec2 RESOLUTION=vec2(3,1);\n\n// Keyboard constants definition\n//#define l(a,b) a=(float(b+64)+.5)/256.\n#define _BSP   -57\n#define _SP    -33\n#define _LEFT  -28\n#define _UP    -27\n#define _RIGHT -26\n#define _DOWN  -25\n#define _COMMA 124\n#define _PER   125\n#define _a 0\n#define _b 1\n#define _c 2\n#define _d 3\n#define _e 4\n#define _f 5\n#define _g 6\n#define _h 7\n#define _i 8\n#define _j 9\n#define _k 10\n#define _l 11\n#define _m 12\n#define _n 13\n#define _o 14\n#define _p 15\n#define _q 16\n#define _r 17\n#define _s 18\n#define _t 19\n#define _u 20\n#define _v 21\n#define _w 22\n#define _x 23\n#define _y 24\n#define _z 25\n#define k(a) key(((float(a+65)+.5)/255.))\n/*usage:\nfloat a= k(_a);\nfloat b= k(1);//alternatively\n*/\n\n//key binds and constains\nvec3 constrainDiagonal(vec3 r){return (r==vec3(0))?r:normalize(r);}\n#define arrows +vec3(k(_RIGHT)-k(_LEFT),k(_UP)-k(_DOWN),k(_SP)-k(_COMMA))\n#define esdf   +vec3(k(_f    )-k(_s   ),k(_e )-k(_d   ),k(_r )-k(_w   ))\n#define wasd   +vec3(k(_d    )-k(_a   ),k(_w )-k(_s   ),k(_e )-k(_q   ))\nvec3 KeyboardInput(){vec3 r= \n +arrows\n //+esdf\n//+esdf\n//above=key binginds | below = constrain sum and diagonal movement.\n ;return clamp(constrainDiagonal(r),vec3(-1),vec3(1));;}\n\nvec3 CameraDirInput(vec2 p){vec2 m=p/iResolution.x;m.y=-m.y;\n vec2 s=sin(m),c=cos(m);\n mat3 rotX=mat3(1.,0.,0.,0.,c.y,s.y,0.,-s.y,c.y);\n mat3 rotY=mat3(cos(m.x),0.,-s.x,0,1,0,s.x,0,c.x);\n return rotY*(rotX*KeyboardInput().xzy);}\n\n//movement.constain\n//void Collision(vec3 prev,inout vec3 p){if(p.y<1.)p=vec3(prev.xz,max(1.0,prev.y)).xzy;}\n\nvoid mainImage(out vec4 Out,in vec2 In){   \n if(any(greaterThan(In,MEMORY_BOUNDARY)))return;\n Out=load(In-.5);\n vec2 re=load(RESOLUTION).xy;\n store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n if(iTime==0.||iFrame==0||any(notEqual(iResolution.xy,re))){\n  //init|reset\n  store(POSITION, vec4(0.0, 2.0, 0.0, 0.0));\n  store(TARGET, vec4(0.0, 2.0, 0.0, 0.0));\n  store(VMOUSE, vec4(0.0));\n  store(PMOUSE, vec4(0.0));\n return;}\n //load\n vec3 target  =load(TARGET).xyz;   \n vec3 position=load(POSITION).xyz;\n vec2 pm      =load(PMOUSE).xy;\n vec3 vm      =load(VMOUSE).xyz;\n //move\n vec3 ptarget=target;\n target+=CameraDirInput(vm.xy)*iTimeDelta*5.;\n //Collision(ptarget, target);\n //store\n store(TARGET,vec4(target,0));\n position+=(target-position)*iTimeDelta*5.; \n store(POSITION,vec4(position,0));\n if(any(greaterThan(iMouse.zw,vec2(0)))){\n     //this {}bracket is mandatory!\n  store(VMOUSE, vec4(pm+(iMouse.zw-iMouse.xy),1,0));\n }else if(vm.z!=0.)store(PMOUSE,vec4(vm.xy,0,0));\n}\n#endif",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//bright pixels near borders/horizon \n//are from rays that ran out of MaxSteps iterations\n//these just calculate a color out of \"thin air\"\n\n// Created by genis sole - 2016\n// https://www.shadertoy.com/view/4lVXRm\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n//#define SkipThis\n#ifdef SkipThis\nvoid mainImage(out vec4 o,in vec2 i){o=vec4(0);}\n#else\n\n//for *1/4 as much performance, have raymarched voronoi raindrops\n#define MakeItRain\n// https://www.shadertoy.com/view/ldjyWw\n\n//DrunkenQuatenrion enables  quaternion rotation demo:\n#define DrunkenQuatenrion\n//by rotating the camera over time as it it is on a boat.\n\n//basic ray-marching loop\n#define MaxSteps 128\n//warping space in the distance for much better fps/MaxSteps\n#define dynamicEps\n//smallest positive 16 bit float is exp2(-126.)\nconst float eps=exp2(-126.);\n//a reasonably small epsion for normal approximation\nconst float SPH=exp2(-10.);\n//making it smaller makes \"sharper\" normals\"\n\n//scale of 2d texturing\n#define zoom 5.\nconst float PI = acos(-1.);\nconst vec2 POSITION = vec2(1.,0.);\nconst vec2 VMOUSE = vec2(1.);\n#define load(P) texture(iChannel1,(P+.5)/iChannelResolution[1].xy,-100.)\n#define pi acos(-1.)\n#define pih acos(0.)\n////phi=golden-Ratios: 1/phi=phi-1=0.61 && 1/Phi=Phi-1=1.61\n#define phi (sqrt(5.)*.5-.5)\n#define Phi (sqrt(5.)*.5+.5)\n\n////return 2x2matrix that mirrors a point on a line, that is rotated by r*0.5 radians.\n#define r2(r) mat2(sin(r+vec4(pih,0,0,-pih)))\n////r2(r) is equal to the matrix of a SINGLE rotation by [r], but (a*r2(r))*r2(r)=a is a double,refletion back and forth.\n////see \"complex number rotation in 2d\", which also uses \"half-angles\"\n\n//////transform.start\n\n//quaternions q()<->creation r()<->rotaition\n//normalize quaternion: true for quaternions <-> nornamoze(q)=q/length(q)==q/length(q*q)=q/dot(q,q)\nvec4 q(vec4 q){return q/dot(q,q);}\n//return quaternin of [axis]&{angle] rotation\nvec4 q(vec3 axis, float angle){angle*=.5;return q(vec4(axis*sin(angle),cos(angle)));}\n//return [r]rotation, rotated by [b] //use like matrix multiplication\nvec4 r(vec4 b,vec4 r){return q(vec4(b.w*r.xyz+r.w*b.xyz+cross(b.xyz,r.xyz),b.w*r.w-dot(b.xyz,r.xyz)));}\n//return [r]vector, rotated by [b] //use like matrix multiplication\nvec3 r(vec4 b,vec3 r){vec3 t=2.*cross(b.xyz, r);return r+b.w*t+cross(b.xyz,t);}\n//from  https://www.shadertoy.com/view/lstSRM\n\n//////transform.end\n//\n//////hassh.start\n\n#define HASHSCALE3 vec3(.1031,.1030,.0973)\n#define HASHSCALE1 .1031\n//hashes from https://www.shadertoy.com/view/4djSRW\n/*\nfloat hash11(float p){vec3 p3=fract(vec3(p)*HASHSCALE1);\n p3+=dot(p3,p3.yzx+19.19);\n return fract((p3.x+p3.y)*p3.z);}\nvec2 hash22(vec2 p){vec3 p3=fract(vec3(p.xyx)*HASHSCALE3);\n p3+=dot(p3,p3.yzx+176.1958);\n return fract((p3.xx+p3.yz)*p3.zy);}\n*/\nvec3 hash33(vec3 p3){p3=fract(p3*HASHSCALE3);\n p3+=dot(p3,p3.yxz+19.19);\n return fract((p3.xxy + p3.yxx)*p3.zyx);}\n\n//////hash.end\n//\n//////hg_sdf.start\n\n//library of components for ditance fiels\n//that promotes namespace conventions:\n//  mercury.sexy/hg_sdf/\nconst float _1=.57735026919;\nconst vec2 _A=normalize(vec2(2.61803398875, 1));\nconst vec2 _B=normalize(vec2(1,Phi));\n//dist2sphere [r]radius [p]vector2sphereCenter\n#define fSphere(p,r) (length(p)-r)\n//dist2plane [n]=plane Normal [d]shortestDistanceOfPlaneTo vec4(0) (see \"hessian normal form\")\n#define fPlane(p,n,d) (dot(p,n)+d)\n//fast 3d only box, max() is fast!\nfloat fBoxCheap(vec3 p,vec3 b){vec3 q=(abs(p)-b);return max(max(q.x,q.y),q.z);}\n\nfloat fBox(vec3 p,vec3 b){\n    vec3 q,d=abs(p)-b;q=min(d,0.);\n    return length(max(d,0.))+max(max(q.x,q.y),q.z);}\n//////hg_sdf.end\n//\n//////DistanceField.Start\n\n#ifdef MakeItRain\n#define vorRainSpeed  .8\n#define vorRainScale 1.0\n//worley rain subroutine\nfloat bias(float s,float b){return s/((((1./b)-2.)*(1.-s))+1.);}\n//worley rain\nvec3 vorRain(vec3 p,float r){\n vec3 vw,xy,xz,s1,s2,xx;\n vec3 yz=vec3(0),bz=vec3(0),az=vec3(0),xw=vec3(0);\n p=p.xzy;p/=vorRainScale;\n vec3 uv2=p,p2=p;\n p=vec3(floor(p)); \n float t=iTime*vorRainSpeed;\n //vec2 rand = vw/vec2(iterations);\n vec2 yx=vec2(0);\n for(int j=-1;j<=1;j++)\n for(int k=-1;k<=1;k++){\n  vec3 offset=vec3(float(j),float(k),0.);\n  //hashed for grid\n  s1.xz=hash33(p+offset.xyz+127.43+r).xz;\n  //hashed for timer for switching positions of raindrop\n  s2.xz=floor(s1.xx + t);\n  //add timer to random value so that everytime a ripple fades, a new drop appears\n  xz.xz=hash33(p+offset.xyz+(s2)+r).xz;\n  xx=hash33(p+offset.xyz+(s2-1.));\n  s1=mod(s1+t,1.);\n  //p2=(p2-p2)+vec3(s1.x,0.0,s1.y);\n  p2=mod(p2,1.0);\n  float op=1.-s1.x;//opacity\n  op=bias(op,.21);//optional smooth blending\n  //change the profile of the timer\n  s1.x=bias(s1.x,.62);//optional harder fadeout\n  float size=mix(4.,1.,s1.x);//ripple.expansion over time\n  //move ripple formation from the center as it grows\n  float size2=mix(.005,2.0,s1.x);\n  // make the voronoi 'balls'\n  xy.xz=vec2(length((p.xy+xz.xz)-(uv2.xy-offset.xy))*size);\n  //xy.xz *= (1.0/9.0);\n  xx=vec3(length((p2)+xz)-(uv2-offset)*1.30);\n  //xx=1.-xx;//optional?\n  xy.x=1.-xy.x;//mandatory!\n  xy.x*=size2;//almost optional viscosity\n  #define ripp if(xy.x>.5)xy.x=mix(1.,0.,xy.x);xy.x=mix(0.,2.,xy.x) \n  ripp;ripp;\n  xy.x=smoothstep(.0,1.,xy.x);\n  xy*=op;// fade ripple over time\n  yz =1.-((1.-yz)*(1.-xy));\n  //ops += mix(0.0,xy.x,op.x);\n  //yz = yz.xxx;\n  //yz = max(yz,xy);\n  //yz += p;\n  //xw = max(xx,xw);\n }return vec3(yz*.1);}\n//less ripples is really prettier than more ripples.\n#define iterRippleCount 1.\n//only problem is that many drops hit at the very same time, so 2 is reasonable minimum.\n//returns height  of water ripples at [p]\nfloat dfRipples(vec3 p){\n vec3 r=vec3(0);\n for(float i=0.;i<iterRippleCount;i++){\n  r+=vorRain(p,i+1.);\n }return p.y-r.x;}\n#endif\n\n//return distance of [p]Point to box [s]size box [r]Roundness\nfloat dfBox(vec3 p,vec3 s,float r){return length(max(abs(p)-s+vec3(r),0.0))-r;}\n\n//#define simpleleGroundAmp .5\n//return distance of [p] to floor with 2 sin()-ripples\nfloat simpleleGround(vec3 p){\n  return p.z-.1*sin(1.5*length(p.xy             )-iTime)\n            -.1*sin(1.5*length(p.xy*.61-vec2(55))-iTime);}\n\n#define opU(a,b) a=min(a,b);\n//offset mod() for repeating space, xplained by \"hg_sdf\"\n#define pMod(x,d) (mod(x+d*.5,d)-d*.5)\nfloat df2(vec3 p){\n \n float r=simpleleGround(p);\n #ifdef MakeItRain\n vec3 pp=p.xzy;\n pp.y=pp.y-1.;\n r-=dfRipples(pp*.5);\n #endif\n    \n p.z+=.5;\n //p.z=pMod(p.z,100.);\n vec3 q=vec3(pMod(p.xy,vec2(20,10)),p.z);\n opU(r,length(q-vec3(0,0,5))-1.);\n q=vec3(pMod(p.xy,vec2(17,13)),p.z);\n opU(r,dfBox(q-vec3( 3, 1,1.),vec3(2),0.15));\n q=vec3(pMod(p.xy,vec2(61,21)),p.z);\n opU(r,dfBox(p-vec3(-3, 1,1.),vec3(2),1.2));\n opU(r,dfBox(p-vec3( 0,-3,1.),vec3(2),.7));\n const float thickness=.2;\n r=abs(r-.4)-r*.1;//hollow out everything with a wall\n return r;}\n\n//distance field returns distance of p to defined geometry\nfloat df(vec3 p){\n  //return dfRipples(p.xzy);\n  return df2(p);\n  vec3 sphereCenter=vec3(0);\n  return length(p-sphereCenter)-1.;\n  //return sin(length(p.xy))-p.z;\n}\n\n//////DistanceField.end\n//\n//////Raymarching.start\n\n\n//#define eps 1e-4\n//[o]=rayOrigin [d]=rayDirection\nvec4 rm2(vec3 o,vec3 d){d=normalize(d);\n float e=0.;//total distance\n for(int i=0;i<MaxSteps;i++){\n  if(df(o+d*e)<eps)break;//surface hit at .xyz with distance .w to [in ro]\n  e+=df(o+d*e);//increment total distance marched on ray\n }return vec4(o,e);}//surface missed\n\n#ifdef dynamicEps\n//this is experimental tweaking\nconst float verysmallpositive=0.0000000000000000000000000000000000000117;//3.5/1e40;//taking 1./1e40 as planck constant for floats in gl.\nconst float almostone=1.+verysmallpositive*2.;\n//i find values like these to cause a scene with a horizon co compile as fast as a scene that looks down at a flat ground.\n#endif\nfloat rm(vec3 o,vec3 i){float e=1e-5,d=0.;\n#ifdef dynamicEps    \n e=1e-24;\n#endif\n for(int j=0;j<MaxSteps;j++){float p=df(o+i*d);if(p<e)return d;d+=p;\n#ifdef dynamicEps    \n e=e+verysmallpositive+e*1.0000000000000000000000000000001;\n#endif\n }return -d;}\n\n//////Raymarching.end\n//\n//////FX.Texture.Start\n\n//projecting an iChannel to 3d space.\nvec4 project(vec2 p){\n //p*=r2(iTime*.1);\n p/=zoom;    \n p.x*=iResolution.y/iResolution.x;\n p+=vec2(.5);\n p=fract(p); \n vec4 r=vec4(0);\n r+= texture(iChannel2,p, -100.0);//BufC=float data\n r+= 0.1*texture(iChannel3,p, -100.0);//BufD=3d canvas\n return r;}\n\nvec3 Grid(vec3 ro,vec3 rd){\n    ro.z+=sin(length(ro.xy));\n float d =-ro.y/rd.y;\n if(d <=0.)return vec3(.4);    \n vec2 p=(ro.xz + rd.xz*d);\n \n //projecting 2d canvases into 3d traversable plane:\n return project(p).xyz;\n    \n p/=zoom;    \n p.x*=iResolution.y/iResolution.x;\n p+=vec2(.5);\n p=fract(p); \n vec4 r=vec4(0);\n r+=texture(iChannel2,p, -100.0);//BufC=float data\n r+=.1*texture(iChannel3,p, -100.0);//BufD=3d canvas\n return r.xyz;\n    \n //vec2 e=min(vec2(1.),fwidth(p));\n //vec2 l=smoothstep(vec2(1.),1.-e,fract(p))+smoothstep(vec2(0.),e,fract(p))-(1.-e);  \n //return mix(vec3(.4),vec3(.8)*(l.x+l.y)*.5,exp(-d*.01));\n}\n\n//////FX.Texture.End\n//\n//////FX.misc.start\n\n//surface normal\n#define cn(a) df(p+vec2(SPH,0.).a)-df(p)\nvec3 normal(vec3 p){return normalize(vec3(cn(xyy),cn(yxy),cn(yyx)));}\n\n//return AmbientOcclusion at [p]point of  [n]normal\nfloat cAO(in vec3 p,in vec3 n){float s=1.5,o=0.;\n for(float i=1.;i<6.;i++){float h=i*.5/6.;        \n  float d=df(p+n*h);o+=(h-d)*s;s*=.7;}\n return clamp(1.- o,0.,1.);}//the blog of iq explains this best\n\n//Shadows.soft\n//[o]=light source position\n//[l]=light ray direction (can be parallel light)\n//return mow much light from [o]origin in direction [l] \n//(to reach point [p]=o+l | o=p-l) does reach point [p] \n//while being blocked or ambientally-occluded.\n//large [k] make shadows harder\n//[t]=distance from camera to [p] ?\nfloat shad(vec3 o, vec3 l, float k, float t){\n // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n const int iter=16;\n vec3 d=l-o; // Unnormalized direction ray.\n float shade=1.;\n float dist=.0025*(t*.125+1.);  // Coincides with the hit condition in the \"trace\" function.  \n float end =max(length(d),0.0001);d/=end;\n //float stepDist = end/float(maxIterationsShad);\n //number to give a decent shadow is the best one to choose. \n for(int i=0;i<iter;i++){\n  float h=df(o+d*dist);\n  //shade = min(shade, k*h/dist);\n  shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n  // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n  dist += clamp(h, .02, .2); \n  // Early exits from accumulative distance function calls tend to be a good thing.\n  if (h<0.||dist>end)break; }\n // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)\n return min(max(shade,0.)+.3,1.);}\n//in search of good shadows:\n//https://www.shadertoy.com/view/XdjyWD\n//iquilezles.org/articles/rmshadows\n\n//////FX.misc.end\n//\n//////Camera.start\n\n//set camera\n#define camPos    vec3(0,4,-4)\n#define camTarget vec3(0)\n#define upDir     vec3(0,1,0)\n//return direction of ray, set by [p]PositionOnScreen and camera data.\n//[o]canPos [t]camTarget [u]upDirection (sets angle)\nvec3 CamCross(vec2 p,vec3 o,vec3 t,vec3 u){vec3\n d=normalize(t-o),r=normalize(cross(u,d)),\n Up=p.y*cross(d,r);r*=p.x*iResolution.x/iResolution.y;\nreturn normalize(((o+d+r+Up)*.86)-(camPos));}\n//shit cam uses too many cross() and normalize()\n\n//return p, rotated by mouse position; simple and intuitive.\nvec3 CamEul(in vec2 p,vec2 m,out vec3 o){m.y=-m.y;\n float a=1./max(iResolution.x, iResolution.y);\n vec3 d=normalize(vec3((p-iResolution.xy*.5)*a,.5));\n mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n d =rotY*(rotX*d);\n return normalize(d);}\n//for a constrained Camera() function go to:\n//https://www.shadertoy.com/view/MsScDz\n\n\n//////camera.end\n//\n//////main.start\n\n#define ccc color=clamp(color,vec3(0),vec3(1));\nvoid mainImage( out vec4 Out, in vec2 fragCoord ){\n vec3 o = load(POSITION).xyz;\n o=vec3(o.x,-o.z,o.y);//simple 90° rotation\n vec3 d = vec3(0.0);\n d=CamEul(fragCoord,load(VMOUSE).xy/iResolution.x,o);//i is rotated by camera\n    \n #ifdef DrunkenQuatenrion\n //vec3()<- angle , the other parameter is the AXIS.\n vec4 q1=q(vec3(1,0,0),sin(iTime)*.1);\n vec4 q2=q(vec3(0,0,1),cos(iTime)*.1);\n //you should avoid rotating a point by a quaternion as much as possible!!!\n //and instead rotate quaternions by quaternions first\n //d=r(q1,d);//rotate [d]vector by [q]quaternion.\n //d=r(q2,d);//rotate [d]vector by [q]quaternion.\n //above code rotates a point by 2 quaternions\n //d=r(q2,d); is computationally more complex, because it contains cross(cross))\n //q1=r(q2,q1) only does 1dot() 1cross) \n //below code rotates ine quaternion b the o ther frrst.\n q1=r(q2,q1);//rotate q1 by q2, right-entian, like matrix multiplicaition\n d=r(q1,d);//and then rotates the point by the rotated rotation \n \n #endif\n \n vec3 color=vec3(0),hit=vec3(0),n=vec3(0);\n o+=vec3(9,6,0);//camera position offset to better fit the distanceField\n d=vec3(d.x,-d.z,d.y);//simple 90° rotation\n float dist=rm(o,d);\n if(dist<0.){//raymarching ended without hittin surface\n  //d=-d;\n }else{\n  hit=o+d*dist;//3d space were ray hit a surface\n  n=normal(hit);\n  color=n*.5+.5;//shift surface normals to visible range\n }\n vec2 a=vec3(hit).xy;\n a.y*=-sign(n.z);\n color-=n.z*project(a).xyz;ccc\n a=vec3(hit).xz;\n a.x*=sign(n.y);\n color-=n.y*project(a*9.).xyz;ccc\n a=vec3(hit).yz;\n a.x*=-sign(n.x);\n color-=n.x*project(a*9.).xyz;ccc\n //color.xyz = Grid(o,d);//optionally add the old raytraced 2d plane grid.\n    \n //my way of doing \"distance fog\"\n color=clamp(color,vec3(0),vec3(1));\n color*=pow(pow(color,vec3(.5e-1)),vec3(dist-3.));\n    \n color.xyz=pow(color.xyz, vec3(0.4545));\n Out = vec4(color.xyz, 1.0);\n}\n#endif",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*character display int|float with glyph-buffer\nalmost identical to its origin:\nhttps://www.shadertoy.com/view/MtyXDV\nbecause sometimes you just forgot what exp2(-4) or 1e-4 really is!\nor you want to see how bad your float rounding actually is:\n*/\n//#define SkipThis\n#ifdef SkipThis\nvoid mainImage(out vec4 o,in vec2 i){o=vec4(0);}\n#else\n\n//exp2(x)=pow(2.,x)\n\n//to shift by decimal points with less test:\n//the \"ex\" or \"e-x\" part of \"aex\" as in \"1e-3\" means;\n//aex = a*pow(10,x);\n\n\n//know your irrationals:\n#define pi acos(-1.)\n//pi=3.14 pih=3.14/2, a lot of function use quater rotaions.\n#define pih acos(0.)\n//defining pi via acos() can be more precise. 16 bit float precision is still bad after 4 decimals.\n//\n////phi=0.61=golden-Ratio: 1/phi=phi-1\n#define phi (sqrt(5.)*.5-.5)\n////Phi=1.61=golden-Ratio: 1/Phi=Phi-1 //Phi>1 is less precise than phi<1\n#define Phi (sqrt(5.)*.5+.5)\n//\n#define eul 2.7182818284590452353602874713527\n//#define eul pow((1.+exp2(-23.)),exp2(23.)) //best opengl can do?\n//e= pow((1+1/x),x), for x-> infinity. = \"limes of deriving\"\n//e= sumOf_Xis0_to_N(1/x!)   , for n-> infinity\n//log(a,x)== inverse of pow(a,x); | log(a,pow(a,x))=1.\n//e= base of natural log;  log(x)=ln(e,x);//fragment shaders have no ln()\n//\n//r=r*ts(a) pithes [r] by [a] semitones on an equal-tempered scale\n#define tsn(a) pow(2.,a/12.)\n//12th root of 2 https://en.wikipedia.org/wiki/Twelfth_root_of_two\n#define ts1 tsn(1.)\n\n//quick check on matrix notation doing columns before rows:\n//const mat3 m=mat3(vec3(0,1,2),vec3(3,4,5),vec3(6,7,8));\n//const float show=m[1].x;//=m[1][0]=3;\n\n//\"show\"= [value to display]:\nconst float show=pi;//tsn(1.);//-.6e-4;//-0.00006;//-0.00000000000000006;//\n//const float small=0.;\nconst float small=0.;//exp2(-63.);//a small offset to show more decimals on smaller values.\n\n//display a value with up to 60 decimal points\nconst float show60=  show-small;\n//display a value with 4 decimals, rounded AFTER the 4th\nconst float show4 =  show-small;// -200.09906;\n//reasonable float precision\n\n//these values take float16 precision errors into account:\n//exp2(-126.0)== smallest positive 16 bit float exp2(-127.0)->0\nconst float showSmall=exp2(-126.);//planck length 16 bit float, scales exponentially.\n\n\nconst vec3 \nheadColor=vec3(.9,.6,.2),\nbackColor=vec3(.1,.1,.1),\nmpColor  =vec3(.9,.9,.0),\nmxColor  =vec3(1.,.0,.0),\nmyColor  =vec3(0.,1.,.0);\n\n//------------ constants above are modifiable for quick responses\n\n#define load(P) texture(iChannel1,(P+.5)/iChannelResolution[1].xy,-100.)\n\n//------------ code below is very identical to:\n//https://www.shadertoy.com/view/MtyXDV\n//==================================================\n// ViewShaderData2.glsl v1.1 2017-04-12 \n// Display shader data;\n//   date, time, frameCount, runtime, fps, resolution & mouse.\n// is based on:\n//      font:  https://www.shadertoy.com/view/MtVXRd\n//   numbers:  https://www.shadertoy.com/view/llySRh\n// version 1:  https://www.shadertoy.com/view/llcXDn\n//==================================================\n\n//--- common data ---\nfloat time = 0.;\nvec2 uv=vec2(0);// -1 .. 1\nvec2 tp=vec2(0);// text position\n\n//== font handling ==\n\n#define FONT_SPACE 0.5\n\nconst vec2 vFontSize  = vec2(8.0, 15.0);  // multiples of 4x5 work best\n\n//----- access to the image of ascii code characters ------\n\n#define SPACE tp.x-=FONT_SPACE;\n\n#define S(a) c+=char(a);   tp.x-=FONT_SPACE;\n\n#define _note  S(10);   //\n#define _star  S(28);   // *\n#define _smily S(29);           \n#define _ tp.x-=FONT_SPACE;\n#define _exc   S(33);   // !\n#define _add   S(43);   // + \n#define _comma S(44);   // ,\n#define _sub   S(45);   // -\n#define _dot   S(46);   // .\n#define _slash S(47);   // /\n\n#define _0 S(48);\n#define _1 S(49);\n#define _2 S(50);\n#define _3 S(51);\n#define _4 S(52);\n#define _5 S(53);\n#define _6 S(54);\n#define _7 S(55);\n#define _8 S(56);\n#define _9 S(57);\n#define _ddot S(58);   // :\n#define _sc   S(59);   // ;\n#define _less S(60);   // <\n#define _eq   S(61);   // =\n#define _gr   S(62);   // >\n#define _qm   S(63);   // ?\n#define _at   S(64);   // at sign \n\n#define _A S(65);\n#define _B S(66);\n#define _C S(67);\n#define _D S(68);\n#define _E S(69);\n#define _F S(70);\n#define _G S(71);\n#define _H S(72);\n#define _I S(73);\n#define _J S(74);\n#define _K S(75);\n#define _L S(76);\n#define _M S(77);\n#define _N S(78);\n#define _O S(79);\n#define _P S(80);\n#define _Q S(81);\n#define _R S(82);\n#define _S S(83);\n#define _T S(84);\n#define _U S(85);\n#define _V S(86);\n#define _W S(87);\n#define _X S(88);\n#define _Y S(89);\n#define _Z S(90);\n\n#define _a S(97);\n#define _b S(98);\n#define _c S(99);\n#define _d S(100);\n#define _e S(101);\n#define _f S(102);\n#define _g S(103);\n#define _h S(104);\n#define _i S(105);\n#define _j S(106);\n#define _k S(107);\n#define _l S(108);\n#define _m S(109);\n#define _n S(110);\n#define _o S(111);\n#define _p S(112);\n#define _q S(113);\n#define _r S(114);\n#define _s S(115);\n#define _t S(116);\n#define _u S(117);\n#define _v S(118);\n#define _w S(119);\n#define _x S(120);\n#define _y S(121);\n#define _z S(122);\n\n//return font image intensity of character ch at text position tp:\n//float char(float ch)    // old versions\n//{ return texture(iChannel0,clamp(tp,0.,1.)/16.+fract(floor(vec2(ch,15.999-float(ch)/16.))/16.));}\n//  vec4 f = texture(iChannel0,clamp(tp,0.,1.)/16.+fract(floor(vec2(ch,16.-(1e-6)-floor(ch)/16.))/16.));  \n\nfloat char(int ch){\n vec4 f=any(lessThan(vec4(tp,1,1),vec4(0,0,tp))) \n   ?vec4(0):texture(iChannel0,0.0625*(tp+vec2(ch-ch/16*16,15-ch/16)));  \n  //if(iMouse.z>0.)\n   return f.x;   // 2d \n  //else return f.x * (f.y+0.3)*(f.z+0.3)*2.0;   // 3d\n}\n\n//== drawings ==\n\n#define tpp tp.x+=FONT_SPACE\n#define tpm tp.x-=FONT_SPACE\n//draw line segment from A to B\nfloat drawSegment(vec2 A, vec2 B, float r){vec2 g=B-A,h=uv-A;\n float d=length(h-g*clamp(dot(g,h)/dot(g,g),0.,1.));\n return smoothstep(r, 0.5*r, d);}\n//display [f]fraction with [d]leadingZeros \nfloat drawFract(int d, float f){float c=0.; \n f=fract(f)*10.; \n for(int i=1;i<60;i++){\n  c+=char(48+int(f));tpm; \n  d--;f=fract(f)*10.;\n  if(d<=0||f==0.) break;\n }tpp*float(d); \n return c;}\n\n//draw [v]int with a minimum # of [m]glyphs\nfloat drawInt(int v,int m){\n float c=0.; \n if(v<0){v=-v; \n  if(m<1)m=1;else m--;\n  _sub}//write \"-\" \n int f=v,d=1; // get number of digits \n for(int n=0;n<10;n++){f/=10;if(f==0)break;d++;} \n d=max(m,d);\n tpm*float(d);\n for(int n=1;n<11;n++){tpp;\n  c += char(48+(v-((v/=10)*10)));\n  if(n>=d)break;} \n tpm*float(d); \n return c;}\n\n//display [v]float with [p]decimalPrecision and [m]maxDigits\nfloat drawFloat(float v,int p,int m){float c=0.,\n tpx=tp.x-FONT_SPACE*float(m);\n if (v<0.){c=char(45);v=-v;}tp.x-=FONT_SPACE; //write \"-\"\n c+=drawInt(int(v),1);    //write floor()\n c+=char(46); SPACE;      //write \".\"\n c+=drawFract(p,fract(v));//write fract() \n tp.x = min(tp.x, tpx); \n return c;}\n//shorter defaults\nfloat drawFloat(float v)      {return drawFloat(v,2,5);} \nfloat drawFloat(float v,int p){return drawFloat(v,p,2);} \nfloat drawInt(int v)          {return drawInt(v,1);}\n\nvec3 \ndotColor =vec3(.5,.5,.0),\ndrawColor=vec3(1.,1.,.0),\nvColor   =backColor;\n\nfloat aspect=1.;\nvec2 pixelPos   = vec2(0.);//pixel position:  0 .. resolution-1\nvec2 mousePos   = vec2(20);//mouse pixel position  \nvec2 lp         = vec2(.5);//last mouse position \nvec2 mp         = vec2(.5);//current mouse position \nvec2 resolution = vec2(.0);//window resolution\n\n\n//utility:\nvoid SetTextPosition(float x,float y){  //x=line, y=column\n tp=10.0*uv;tp.x=tp.x+17.-x;tp.y=tp.y-9.4+y;}\n\nvoid SetColor(float r,float g,float b){drawColor=vec3(b,g,b);}\nvoid WriteFloat(const in float v \n               ,const in int maxDigits \n               ,const in int decimalPlaces){\n vColor=mix(vColor,drawColor,drawFloat(v,decimalPlaces));\n SPACE;}\n\nvoid WriteInteger(const in int v){\n vColor=mix(vColor,drawColor,drawInt(v));SPACE;}\nvoid WriteDate(){float c=0.;\n c+=drawInt(int(iDate.x));    _sub;\n c+=drawInt(int(iDate.y +1.));_sub;\n c+=drawInt(int(iDate.z)); _\n vColor=mix(vColor,drawColor,c);}\nvoid WriteTime(){float c=0.;\n c+=drawInt(int(mod(iDate.w/3600.,24.)));  _ddot;\n c+=drawInt(int(mod(iDate.w/60.  ,60.)),2);_ddot;\n c+=drawInt(int(mod(iDate.w      ,60.)),2);_\n vColor=mix(vColor,drawColor,c);}\nvoid WriteFPS(){\n  float fps=iFrameRate; //float fps=(1./iTimeDelta+.5);\n  SetColor(.8,.6,.3);WriteFloat(fps,6,2);\n  float c=0.;_f _p _s\n  vColor=mix(vColor,drawColor,c);}//https://www.shadertoy.com/view/lsKGWV\n//write [m]iMouse.xy and paint it\nvoid WriteMousePos(float t,vec2 m){\n int digits=3;\n float r=resolution.x/200.;\n if(iMouse.z>0.)dotColor=mpColor;// print dot at mPos.xy \n float s=length(m-pixelPos)-r;\n vColor+=mix(vec3(0),dotColor,(1.-clamp(s,0.,1.)));\n SetTextPosition(1.,t);// print first mouse value\n drawColor = mxColor;// print mouse position\n if(t==7.){\n  WriteFloat(m.x,6,3);SPACE;\n  drawColor = myColor;\n  WriteFloat(m.y,6,3);\n }else{\n  WriteInteger(int(m.x));SPACE;\n  drawColor = myColor;\n  WriteInteger(int(m.y));\n }}    \n\nvoid WriteText1(){\n SetTextPosition(1.,1.);\n float c = 0.0;\n //_star _ _V _i _e _w _ _S _h _a _d _e _r   \n //_ _D _a _t _a _ _2 _ _ _v _1 _dot _1 _ _star \n vColor+=c*headColor;}\n\nvoid WriteTestValues(){float c=0.;\n SetTextPosition(1.,12.);\n   c+=drawInt(123, 8);   \n _ c+=drawInt(-1234567890);    // right now !!!\n _ c+=drawInt(0);                \n _ c+=drawInt(-1);                \n _ c+=drawFloat(-123.456);     // right now !!!\n SetTextPosition(1.,13.);\n   c+=drawInt(-123, 8);   \n _ c+=drawInt(1234567890,11);\n _ c+=drawFloat(0.0,0,0);\n _ c+=drawFloat(1.0,0,0);\n _ c+=drawFloat(654.321);      // nearly right\n _ c+=drawFloat(999.9, 1);\n _ c+=drawFloat(pow(10., 3.),1);   \n _ c+=drawFloat(pow(10., 6.),1);   \n \n SetTextPosition(1.,14.);c+=drawFloat(showSmall,60);\n SetTextPosition(1.,15.);c+=drawFloat(show60,60);\n SetTextPosition(1.,16.);c+=drawFloat(show4+sign(show4)*.5*pow(10.,-4.),4);\n vColor+=c*headColor;}\n\n//draw ring.2d\nfloat ring(vec2 p, float r, float thick){\n  return mix(1.,0.,smoothstep(thick,thick+.01,abs(length(uv-p)-r)));}\n\n#define CC(c) (2.*c/resolution-1.)*ratio;\n\n//////\n//\n//////main.start\n\nvoid mainImage(out vec4 Out, in vec2 In){\n time=iTime;\n resolution=iResolution.xy;\n aspect=resolution.x/resolution.y;    // aspect ratio\n vec2 ratio=vec2(aspect,1.);\n pixelPos=In.xy;    //  0 .. resolution\n mousePos=iMouse.xy;//  0 .. resolution\n uv=CC(pixelPos);   // -1 .. 1\n mp=CC(iMouse.xy);  // -1 .. 1\n lp=CC(iMouse.zw);  // -1 .. 1\n //axis\n vColor=mix(vColor,vec3(.2),drawSegment(vec2(-99.,0.),vec2(99.,0.),.01));\n vColor=mix(vColor,vec3(.2),drawSegment(vec2(0.,-99.),vec2(0.,99.),.01));\n //version & test values   \n WriteText1();     \n WriteTestValues();\n //mouse position & coordinates\n WriteMousePos(5., iMouse.zw);  // last position\n WriteMousePos(6., iMouse.xy);  // current position\n //circle Radius\n float radius = length(mp - lp);\n SetColor (0.9, 0.9, 0.2);\n float c = 0.0;\n _  _r _eq\n vColor += c * drawColor;\n WriteFloat (radius,6,2);    \n // Circle\n float intensity = ring(mp.xy, radius, 0.01);\n drawColor = vec3(1.5, 0.4, 0.5);\n vColor = mix(vColor, drawColor, intensity*0.2);\n // Resolution\n SetTextPosition(27.0, 1.0);\n SetColor (0.8, 0.8, 0.8);\n WriteInteger(int(iResolution.x));  _star _  vColor += c * drawColor;\n WriteInteger(int(iResolution.y));\n SetColor(.9,.9,.4);SetTextPosition(1.,19.);WriteDate();SPACE  // Date\n SetColor(1.,0.,1.);WriteTime();SPACE  //Time.System\n SetColor(.4,.7,.4);WriteInteger(iFrame);SPACE//Sount.Frames\n SetColor (.0,1.,1.);WriteFloat(time, 6, 2);SPACE//Count.Seconds\n WriteFPS();//Frames Per Second\n vColor=clamp(vColor,0.,1.);\n Out=vec4(vColor,1);}\n#endif",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//better documented: https://www.shadertoy.com/view/XsByDW\n\n//this is a core 2d canvas with core basics.\n\n//#define SkipThis\n#ifdef SkipThis\nvoid mainImage(out vec4 o,in vec2 i){o=vec4(0);}\n#else\n\n////A define is identical to an \"alias\" or \"bind\", a useful shorthand.\n#define zoom 5.\n\n#define pi acos(-1.)\n#define pih acos(0.)\n////phi=golden-Ratio: 1/phi=phi-1 && 1/Phi=Phi-1\n#define phi (sqrt(5.)*.5-.5)\n#define Phi (sqrt(5.)*.5+.5)\n\n////return a sinusoid over time with range.y [-1 .. 1] & wavelength of 1 second.\n#define hz sin(iTime*pi*2.)\n////return a sinusoid over time with range.y [ 0 .. 1] & wavelength of 1 second.\n#define hz1 (hz*.5+.5)\n\n////By discarding the whole part (of a line) with x=fract(x), you get a seesaw with range.y [0 .. 1];\n#define frac(a) a=fract(a)\n////ss2t(a) changes a seesaw waves output (range [0..1]) to a triangle wave.\n#define ss2t(a) a=abs(a*2.-1.)\n\n////return 2x2matrix that mirrors a point on a line, that is rotated by r*0.5 radians.\n#define r2(r) mat2(sin(r+vec4(pih,0,0,-pih)))\n////r2(r) is equal to the matrix of a SINGLE rotation by [r], but (a*r2(r))*r2(r)=a is a double,refletion back and forth.\n////see \"complex number rotation in 2d\", which also uses \"half-angles\"\n\n//return polar (distamce,angle) coordinates of carthesian (x,y) input.\n//vec2 c2p(vec2 p){return vec2(length(p),atan(p.y,p.x));}\n//return carthesian (x,y) coordinates of polar (distamce,angle) input.\n//vec2 p2c(vec2 p){return p.x*vec2(cos(p.y),sin(p.y));}\n\nvec2 frame(vec2 p){p/=iResolution.xy;\n    p-=vec2(.5);//move xy=vec2(0,0) to the center of range [0 .. 1].xy\n    p*=zoom;//scale by [zoom]\n    p.x*=iResolution.x/iResolution.y;//m.x scales by aspect ratio.\n  //p=p*r2(iTime);//rotation transform, clockwise over time\n  //p=p*r2(sin(iTime*phi*2.)*.1);//rotation transform, PENDULUM over time\nreturn p;}\n\n//if(a p.dimension is exactly on a cell border && a direction is negative) cubeid.dimension-=1.\n//vec3 getRt(vec3 p, vec3 d){return p-step(d,vec3(0));}//likely faster.\nvec3 getRt(vec3 p, vec3 d){return p-vec3(lessThan(d,vec3(0)));}//works on older gl versions\n//caveat if(on cell border and parallel to it) the lower cell(s) get(s) ignored\n\nfloat df(vec2 p){\n    vec3 pp=vec3(p,0.);\n    //p=getRt2(p,p);\n    vec2 mouse=frame(iMouse.xy)-p;\n    float DitanceToMouse =length(mouse);//distance of p to framed-mouse\n    float DitanceToMetaball=DitanceToMouse*length(p);//simple metaball.\n    float d=0.;\n    d-=hz*.1;//oscillate [d] a little bit over time. (larger oscillations distract too much)\n  //d+=DitanceToMouse;\n  \n  //d+=max(abs(mouse.x),abs(mouse.y));//distance to square\n  //d+=min(abs(p.x),abs(p.y));//distance to cross\n  //d+=max(abs(p.x),abs(p.y))*(3.-hz1)-min(abs(mouse.x),abs(mouse.y));//distance to (distorting) star.\n  \n  d+=DitanceToMetaball-2.;\n  //d+=min(length(p),DitanceToMouse)*phi*4.-2.;//union of 2 distances to 2 points via min(a,b)\n  //d+= min(DitanceToMouse*1.5,DitanceToMetaball)-2.;//union of 2 distances \n////mix(a,b,c) does linear interpolation on a line trough a and b, c=0.0 returns a,c=1.0 returns b:\n  //d+= mix(DitanceToMetaball,min(DitanceToMouse*1.5,DitanceToMetaball),hz)-2.;\n////max(a,b) returns the UNION of 2 distance fields [a] and [b]\n  //d+=max(length(p),  DitanceToMouse     )-1.;//distance to union\n////max(a,-b) returns the distance to shpe [a], substracted by distance to shape [b].\n////(but that is for distances to volumes, in 2d we need an offset (here -2.)):\n  //d+=max(length(p)-2.,-(DitanceToMouse-2.));\n  //d+=(DitanceToMouse+length(p))-2.;//(poorly scaled) oval\n  //d+= DitanceToMouse/length(p)+length(p)-2.;//hearty\n    return d;//return distance to mouse\n}////see http://mercury.sexy/hg_sdf/\n\n//[p]=framed screenspace pixel (position of pixel on screen). [d]=\nvec3 cam(vec2 p,vec3 d){\n mat3 m=mat3(1,0,0,   0,1,0 ,   0,0,1);\n return vec3(p,1.)*m;\n}\n\nvoid mainImage(out vec4 Out,in vec2 In){vec2 p=frame(In);\n                                        \n    \n                                        \n    vec2 p2=p;//we change p soon, and copy a backup of it here.\n    float c=length(p);//length(a.xyzw) returns euclidean distance, pythagrean, squareroot of sum of squares.\n    frac(p);//.xy grid <- seesaw\n    ss2t(p);//.xy grid    seesaw <- triangle\n    p*=p*p; //f(p)=p*p*p; simple way to make p more exponential (for p range[0 .. 1])\n                               \n    frac(c);//distance to point (0,0) <- seesaw\n  //ss2t(c);//distance to point (0,0)    seesaw <- triangle\n    c*=.5;\n    c*=hz1;//multiply [c] by a sinusoid over time see \"#define hz...\"\n    Out=vec4(c,p,1.);//set the \"out vec4 Out\" value, \n\n    float di=df(p2);//di stores [distance of [p2] to distance field df()\n    frac(di);//display distance fiels just as we display distance to point (0,0)\n  //di=step(di+hz1,1.);//display distance field as \"inside and outside of distance 1.0\"\n  //di=1.-di;//optional inversion, with offset\n    Out.xyz+=di*.5;//show distance field. Additive visualization is lazy and fast (and bad style)\n///end of distance field code\n                                        \n    vec3 cent=getRt(vec3(0),vec3(0,1,1));\n    Out.xyz+=step(length(p2-cent.xy),.1);\n            \n////post processing:\n    Out=clamp(Out,0.,.9);\n    Out*=Out;//f(Out)=Out*Out; simple way to increase contrast.\n    Out=clamp(Out,0.,.9);}\n#endif",
                "description": "",
                "inputs": [],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}