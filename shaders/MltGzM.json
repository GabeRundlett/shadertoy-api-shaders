{
    "Shader": {
        "info": {
            "date": "1468485061",
            "description": "( mouse.x : show the trick > see FLAGS & comments )\nMix of simple procedural advection shader + smart blending shader.\n4 procedural layers : 3 vortex splats + background.\nEach done by combining 3 phased regenerated texture.\nMaintains constant contrat.",
            "flags": 0,
            "hasliked": 0,
            "id": "MltGzM",
            "likes": 85,
            "name": "perlin + advection + flownoise 2",
            "published": 3,
            "tags": [
                "procedural",
                "texture",
                "perlin",
                "sprite",
                "blend",
                "advection",
                "variance",
                "flownoise",
                "lagrangian",
                "smartblend"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 3683
        },
        "renderpass": [
            {
                "code": "// variant of advection of procedural flownoise https://www.shadertoy.com/view/lltGRN\n// with smart blendind of multiple splats https://www.shadertoy.com/view/4dcSDr\n\n#define FLOWNOISE 1  // 0: regular Perlin   1: flownoise\n#define MODE 1       // 0: bozo   1: fire   2: cloud\n#define DISP 0       // 0: noise = value    1: noise = displacement (better with bozo)  \n#define SCALE 1.     // noise wavelength\n#define ROT  1       // 1: center fastest   2: center slowest  \n#define radius .3    // radius of the vortices orbit\n#define MORPH 1      // 1: advection 0: final blend (fire only)\n\n// --- texture advection: \n// from https://www.shadertoy.com/view/XsdXWn\n// cf https://hal.inria.fr/inria-00537472  ( also exist in Lagrangian form )\n// here, we only do the simple 3-phase version, each fading-in/out before too much distortion.\n\n// --- flow noise:  \n// from https://www.shadertoy.com/view/MstXWn\n// cf publi http://evasion.imag.fr/~Fabrice.Neyret/flownoise/index.gb.html\n//          http://mrl.nyu.edu/~perlin/flownoise-talk/\n// The raw principle is trivial: rotate the gradients in Perlin noise.\n// Complication: checkboard-signed direction, hierarchical rotation speed (many possibilities).\n// Not implemented here: pseudo-advection of one scale by the other.\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define CS(a)  vec2(cos(a),sin(a))\n\n// --- Perlin noise by inigo quilez - iq/2013   https://www.shadertoy.com/view/XdXGW8\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1. + 2.*fract(sin(p)*43758.5453123);\n}\n\n// noise with flownoise extension (rotation of gradients)\nfloat level=1.;\nfloat noise( vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.-2.*f);\n#if FLOWNOISE\n    float t = exp2(level)* .4*iTime;\n    mat2  R = rot(t);\n#else\n    mat2  R = mat2(1,0,0,1);\n#endif\n    if (mod(i.x+i.y,2.)==0.) R=-R;\n\n    return 2.*mix( mix( dot( hash( i + vec2(0,0) ), (f - vec2(0,0))*R ), \n                        dot( hash( i + vec2(1,0) ),-(f - vec2(1,0))*R ), u.x),\n                   mix( dot( hash( i + vec2(0,1) ),-(f - vec2(0,1))*R ), \n                        dot( hash( i + vec2(1,1) ), (f - vec2(1,1))*R ), u.x), u.y);\n}\n\n// --- turbulence: non-advected version ( for reference )\n\nfloat Mnoise( vec2 uv ) {\n#  if MODE==0\n    return noise(uv);                      // base turbulence\n#elif MODE==1\n    return -1. + 2.* (1.-abs(noise(uv)));  // flame like\n#elif MODE==2\n    return -1. + 2.* (abs(noise(uv)));     // cloud like\n#endif\n}\n\nmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nfloat turb( vec2 uv )\n{ \tfloat f;\n\t\n level=1.;\n    f  = 0.5000*Mnoise( uv ); uv = m*uv; level++;\n\tf += 0.2500*Mnoise( uv ); uv = m*uv; level++;\n\tf += 0.1250*Mnoise( uv ); uv = m*uv; level++;\n\tf += 0.0625*Mnoise( uv ); uv = m*uv; level++;\n\treturn f/.9375; \n}\n\n// --- turbulence: advected version \n\nvec4 early_turb( vec2 uv ) // sample a multiscale vector of linear noise to be interpolated\n{\n    vec4 N;\n    level = 1.;\n    N[0] = noise(uv); uv = m*uv; level++;\n    N[1] = noise(uv); uv = m*uv; level++;\n    N[2] = noise(uv); uv = m*uv; level++;\n    N[3] = noise(uv); uv = m*uv; level++;\n    return N;\n}\n\nvec4 Mnoise( vec4 N ) {   // apply non-linearity 1 (per scale) after blending\n#  if MODE==0\n    return N;                      // base turbulence\n#elif MODE==1\n    return -1. + 2.* (1.-abs(N));  // flame like\n#elif MODE==2\n    return -1. + 2.* (abs(N));     // cloud like\n#endif\n}\n    \nfloat deferred_turb( vec4 N ) // apply cascade + optional non-linearity 2 (LUT) after blending\n{\n    N = Mnoise(N);   \n    float f;\t\n    f  = 0.5000*N[0]; \n\tf += 0.2500*N[1];\n\tf += 0.1250*N[2];\n\tf += 0.0625*N[3];\n\treturn f/.9375;     \n}\n\n\n// --- custom texture fetch\n//#define T(u)  texture(iChannel0, u )     // fetch noise texture\n  #define T(u)    early_turb((u)*3./(SCALE)) // fetch flownoise\n\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    float t = mod(iTime,6.283)*(MODE==1 ? 2. : 1.), Kt=0.;\n\tvec2  R = iResolution.xy,\n         uv = (U -.5*R ) / R.y, uvl,Pl,\n          m = (iMouse.xy -.5*R ) / R.y; if (length(iMouse.xy/R)<.01) m = vec2(0);\n    \n    O-=O;\n    \n    // --- smart blending of splats --------------------------------------\n    for (float k=-1.; k<3.; k++) {   // 4 layers: background (k=-1) + 3 vortices\n    float l,K,v;\n    if (k<0.) { uvl = uv; Pl=vec2(0); K=.3; v=0.;}// k=-1: background motion\n    else {                                        // 3 vortices\n       Pl  = radius*CS(2.1*k - .5*iTime),   // splat center\n       uvl = uv-Pl;                               // local coords in the splat\n       l = length(uvl),\n       K = exp(-.5*l*l/radius/radius),            // kernel of the splat\n   //  K = smoothstep(1.,0.,.7*l/radius),\n#if ROT==1\n       v = 3./(.01+l);                            // rotation(r) within the splat\n#else        \n       v = 30.*l;\n#endif\n    }\n      Kt += K*K;\n       // --- 3-phased advection --------------------------------------\n      for (float i=0.; i<3.; i++) {       // the 3 phases per layer for advection illusion\n        float ti = t+ 6.283/3.*i,\n              wi = K* (.5-.5*cos(ti))/1.5;\n\n        vec2 uvi = uvl*rot(.3*(-.5+fract(ti/6.283))*v); // NB: we should add an offset per splat\n        //if (i>0.) break; else wi=K;  // uncomment to show smearing if naive advection\n        //if (i>0.) break;             // uncomment to show advection trick with 1 layer\n        if (uv.x < m.x)                // left: result\n#if MORPH\n            O += T (.5 + uvi )  * wi;\n#else\n            O += wi * vec4(1,.6,.3,0)* 2.* pow(max(0.,deferred_turb(T (.5 + uvi ))), 2.);\n#endif          \n\t    else                           // right: grid showing the trick\n            O[int(i)] += texture(iChannel1, .5 + uvi ).x  * wi;  // show each phase in colors\n    }\n  }\n  O /= sqrt(Kt); // normalisation by the cumulated std-dev, for constant contrast\n    \n    \n// --- only with procedural advection: deferred noise.    \n    if (uv.x < m.x && MORPH==1) // rendered side\n#if DISP\n        uv.x += .9*deferred_turb(O),\n        O = .5+.5*vec4 (sin(30.*(uv.x-uv.y)) ); \n#else\n#  if   MODE==0\n        O = vec4(.5 + deferred_turb(O));\n#  elif MODE==1\n        O = vec4(1,.6,.3,0)* 2.* pow(max(0.,deferred_turb(O)), 2.); \n#  elif MODE==2\n        O = mix(vec4(0,0,.3,1),vec4(2),.5 + .5*deferred_turb(O)); \n#  endif\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}