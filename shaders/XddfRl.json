{
    "Shader": {
        "info": {
            "date": "1526388906",
            "description": "test couleurs",
            "flags": 32,
            "hasliked": 0,
            "id": "XddfRl",
            "likes": 20,
            "name": "sphere shading",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "louis_C",
            "viewed": 1163
        },
        "renderpass": [
            {
                "code": "\nconst float SAMPLES = 24.; \n\nfloat rand( vec2 p ){ return fract(sin(dot(p, vec2(41.254, 289.256)))*45758.5453); }\nfloat noise ( vec2 uv) {\nfloat a = rand(floor(uv));\nfloat b = rand (floor(uv+vec2(1,0)));\n float c  = rand (floor(uv+vec2(0,1)));\n float d  = rand ( floor(uv+vec2(1,1)));\nvec2 u =smoothstep(0.,1.,fract(uv));\nreturn mix (a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y;}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n    float decay = 0.85; \n    float density =0.4; \n    float weight = 0.03; \n    vec2 tuv =  uv - .5 ;\n    vec2 dTuv = tuv*density/SAMPLES;\n    vec4 col = texture(iChannel0, uv)*0.25;\n    uv += dTuv*(rand(uv+ fract(iTime))*2. - 1.);\n    for(float i=0.; i < SAMPLES; i++){   \n        uv -= dTuv;\n        col += texture(iChannel0, uv) * weight;\n        weight *= decay;      \n    }\n    \n    col *= (1. - dot(tuv, tuv));\n \n   fragColor =mix( vec4(texture(iChannel0, uv2).xyz,1.), sqrt(smoothstep(0., 1., col)),\n                 smoothstep(0.7,1., texture(iChannel0, uv2).w));\n   //fragColor = vec4(texture(iChannel0, uv2).xyz,1.);\n\t\t\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float RGBToL(lowp vec3 color)\n    {\n        lowp float fmin = min(min(color.r, color.g), color.b);    \n        lowp float fmax = max(max(color.r, color.g), color.b);    \n                return (fmax + fmin) / 2.0; \n    }\n lowp vec3 RGBToHSL(lowp vec3 color)\n    {\n        lowp vec3 hsl; \n        lowp float fmin = min(min(color.r, color.g), color.b);   \n        lowp float fmax = max(max(color.r, color.g), color.b);   \n        lowp float delta = fmax - fmin;            \n        hsl.z = (fmax + fmin) / 2.0; \n        if (delta == 0.0)\t\t\n        {\n            hsl.x = 0.0;\t\n            hsl.y = 0.0;\t\n        }\n        else                                    \n        {\n            if (hsl.z < 0.5)\n                hsl.y = delta / (fmax + fmin); \n            else\n                hsl.y = delta / (2.0 - fmax - fmin); \n            \n            lowp float deltaR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\n            lowp float deltaG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\n            lowp float deltaB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\n            \n            if (color.r == fmax )\n                hsl.x = deltaB - deltaG; \n            else if (color.g == fmax)\n                hsl.x = (1.0 / 3.0) + deltaR - deltaB; \n            else if (color.b == fmax)\n                hsl.x = (2.0 / 3.0) + deltaG - deltaR; \n            \n            if (hsl.x < 0.0)\n                hsl.x += 1.0; \n            else if (hsl.x > 1.0)\n                hsl.x -= 1.0; \n        }\n        return hsl;\n    }\n  lowp float HueToRGB(lowp float f1, lowp float f2, lowp float hue)\n    {\n        if (hue < 0.0)\n            hue += 1.0;\n        else if (hue > 1.0)\n            hue -= 1.0;\n        lowp float res;\n        if ((6.0 * hue) < 1.0)\n            res = f1 + (f2 - f1) * 6.0 * hue;\n        else if ((2.0 * hue) < 1.0)\n            res = f2;\n        else if ((3.0 * hue) < 2.0)\n            res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n        else\n            res = f1;\n        return res;\n    }\n lowp vec3 HSLToRGB(lowp vec3 hsl)\n    {\n        lowp vec3 rgb;\n        if (hsl.y == 0.0)\n            rgb = vec3(hsl.z); // Luminance\n        else\n        {\n            lowp float f2;\n            \n            if (hsl.z < 0.5)\n                f2 = hsl.z * (1.0 + hsl.y);\n            else\n                f2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);           \n            lowp float f1 = 2.0 * hsl.z - f2;            \n            rgb.r = HueToRGB(f1, f2, hsl.x + (1.0/3.0));\n            rgb.g = HueToRGB(f1, f2, hsl.x);\n            rgb.b= HueToRGB(f1, f2, hsl.x - (1.0/3.0));\n        }\n        return rgb;\n    }\nfloat rand (vec2 uv ){return fract(sin(dot(floor(uv),vec2(12.326,75.326)))*4589.365);}\nfloat noise ( vec2 uv) {\nfloat a = rand(uv);\nfloat b = rand (uv+vec2(1,0));\n float c  = rand (uv+vec2(0,1));\n float d  = rand ( uv+vec2(1,1));\nvec2 u =smoothstep(0.,1.,fract(uv));\nreturn mix (a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y;}\nfloat fmb ( vec2 uv) {\n\nfloat val = 0.;\nfloat amp = 0.5;\nfloat frec = 0.;\n\nfor (int i =0; i<6; i++){\nval += amp* noise (uv);\nuv*=2.;\namp*=.5;\n}\nreturn val;\n}\nfloat Sph (vec3 pos, float radius){\nreturn length(pos)-radius;\n}\n\nmat2 rotate(float a) {\n    float c = cos(a);\n    float s = sin(a);\n\n    return mat2(c,-s,s,c   );\n}\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 hsv (vec3 col,float h,float s,float v){\nvec4 k = vec4(0.0,-1.0/3.0,2.0/3.0,-1.0);\nvec4 p = mix(vec4(col.zy,k.wz),vec4(col.yz,k.xy),step(col.z,col.y));\nvec4 q = mix (vec4(p.xyw,col.x),vec4(col.x,p.yzx),step(p.x,col.x));\nfloat d = q.x-min(q.w,q.y);\n    float e = 1.0e-10;\n    vec3 a = vec3(abs(q.z+(q.w-q.y)/(6.0*d+e)),d/(q.x+e),q.x);\nreturn  mix(vec3(1.),clamp(3.0*abs(1.0-2.0*fract((h+a.r)+vec3(0.,-1./3.,1./3.)))-1.,0.,1.)\n        ,(s+a.g))*(v+a.b);}\nvec3 opTwist( vec3 p )\n{\n    float fac =mix(-0.15,0.3,noise(vec2(iTime,12.5)));\n    float c = cos(p.z*fac);\n    float s = sin(p.z*fac);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\nfloat map (vec3 pos){\n    pos=opTwist(pos);\nfloat noi =mix(-1.,1., noise (pos.xy*2.))*2.;\nfloat scene = 1.;\nvec3 pos2 =pos;\npos2.xz *= rotate(pos.y);  \nfloat di = mix(-1.,1.,fmb(pos2.xy));\nvec3 pos1 = pos+di*-2.;\n   \npos1 = rep (pos1,vec3(mix(1.,3.,cos(pos.x+iTime))+noi,mix(1.,4.,sin(pos.y+iTime))+noi,0.));   \nfloat s1 = Sph(pos1,2.+di);\n\n scene = s1 ;\n \nreturn scene;\n}\nvec3 getN (vec3 pos) {\n    float e = 0.01;\n    return normalize(vec3(map(pos+vec3(e,0,0))-map(pos-vec3(e,0,0)),\n                          map(pos+vec3(0,e,0))-map(pos-vec3(0,e,0)),\n                          map(pos+vec3(0,0,e))-map(pos-vec3(0,0,e))));}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv =1.-2.* fragCoord/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y; \n   vec2 uv2 =uv; \n \n\tfloat d = length(uv);\n \tfloat m =sin(0.5*178.*(3.1415926535/180.0)); \n \t\n               d=length(uv);\n               float z = sqrt(1.0-d*d);\n               float r = atan(d,z)/3.1415926535;\n               float phi = atan(uv.y,uv.x);\n               uv2.x = r*cos(phi)+0.5;\n               uv2.y = r*sin(phi)+0.5;\n          \n    vec3 eye = vec3(0.,0.,-11.);\n    vec3 ray = normalize(vec3(uv2,1.));   \n    vec3 pos = eye;\n    float shade = 0.;\n    for (int i=0; i<40;++i){\n    float dist = map(pos);\n    if(dist<0.01){\n    shade = 1.-float(i)/40.;\n    break;\n    }\n    pos += ray*dist;\n    }\n \t\n \tvec3 nor = getN(pos);\n \t\nfloat zone = pow(smoothstep(0.2,1.,smoothstep(0.4,1.,pow(smoothstep(5.,0.,length(uv)),(shade)*5.))),shade*0.5);\n    float mask = smoothstep(1.,0.99,length(uv));\n \t  float spec = pow(clamp(dot(nor,vec3(0.,0.,-1)),0.,1.),15.);\n  \tvec3 col = hsv(vec3(0.5,0.,0.),\n                   mix(mix(-0.18,-0.034,shade),mix(-0.3,0.01,shade),zone),\n                   mix(mix(-7.,0.5,shade),mix(1.,-0.2,shade),zone),\n                   mix(mix(3.,-0.25,shade),mix(-1.,0.6,shade),zone));\n    vec3 col2 = col+spec*zone*0.5;\n \tvec3 col3 = mix(vec3(0.38,0.38,0.5)*1.-distance(1.-2.* fragCoord/iResolution.xy,vec2(0.))*0.3,col2, mask) ;\n   \t\n lowp float lightness = RGBToL(col3);\n        lowp vec3 shift = vec3(0, 0, 0.1);\n        const lowp float a = 0.05;\n        const lowp float b = 0.333;\n        const lowp float scale = 0.7;\nlowp vec3 midtones = (clamp((lightness-b)/a+0.5,0.0,1.0)*clamp((lightness + b - 1.0)/-a+0.5,0.0,1.0)*scale)*shift;\n        lowp vec3 newColor = col3 + midtones;\n        newColor = clamp(newColor, 0.0, 1.0); \n\t\tlowp vec3 newHSL = RGBToHSL(newColor);\n        lowp float oldLum = RGBToL(col3);\n        col3 = HSLToRGB(vec3(newHSL.x, newHSL.y, oldLum));\n \n        fragColor= vec4(col3,1.-zone*mask);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}