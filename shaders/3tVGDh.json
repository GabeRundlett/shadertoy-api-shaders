{
    "Shader": {
        "info": {
            "date": "1578908062",
            "description": "This is my attempt to recreate and animate M.C. Eschers 'Rippled Surface'",
            "flags": 0,
            "hasliked": 0,
            "id": "3tVGDh",
            "likes": 17,
            "name": "Escher Puddle",
            "published": 3,
            "tags": [
                "raymarching",
                "reflection",
                "waves",
                "escher",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "SSHantaram",
            "viewed": 581
        },
        "renderpass": [
            {
                "code": "// I have tried to recreate the effect of M.C. Eschers 'Rippled Surface'\n// and animate the scene. The rays are reflected off a displaced\n// plane  into the trees.\n\n// polynomial smooth min (k = 0.1);\n// https://iquilezles.org/articles/smin\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// the wave for each droplet is based on a simple cosine wave\n// the wave in attenuated by the sqared distace to the center\n// for the ring the wave is multiplied by e^(-x^2) to get the rings\n// both the cosine wave and the rings are animated by offsets\n// time is looped in 25 second intervals\n// about the time for the rings to leave the field of view\nfloat waveDisplacement( vec3 p )\n{\n    // drop one\n    float dist = length(p.xz - vec2(-0.5, 6.0));\n    float ring = 10.0*dist - mod(iTime - 8.0, 25.0) + 4.0;\n    float waves = cos(60.0*dist - 10.0*mod(iTime + 2.0, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\n    \n    // drop two\n    dist = length(p.xz - vec2(0.5, 5.5));\n    ring = 10.0*dist - mod(iTime, 25.0) + 4.0;\n    waves += cos(60.0*dist - 10.0*mod(iTime, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\n    \n    // drop three\n    dist = length(p.xz - vec2(-0.0, 5.0));\n    ring = 10.0*dist - mod(iTime - 16.0, 25.0) + 4.0;\n    waves += cos(60.0*dist - 10.0*mod(iTime, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\n    \n    return waves;\n}\n\n// plane with waves\nfloat sdPlane( vec3 p )\n{\n    float dist = p.y;\n    \n    // apply costly displacement only when close\n    if (p.y < 0.1) dist -= 0.0008*waveDisplacement(p);\n    \n    return dist;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// like capsule, but with different radii at each end\n// https://www.shadertoy.com/view/3lsSzf\nfloat sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h));\n}\n\nfloat sdTree( vec3 p )\n{\n    // trunk\n    float dist = sdCapsule( p, vec3(0), vec3(0.0, 2.5, 0.0), 0.3 );\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.0, 2.5, 0.0), vec3(0.0, 6.5, 0.0), 0.2), 0.1);\n    \n    // mirror x-axis\n    p.x = abs( p.x );\n    \n    // big branches\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.15, 1.5, 0.0), vec3(1.4, 3.0, 0.0), 0.11), 0.1);\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.15, 2.5, 0.0), vec3(0.7, 3.5, 0.0), 0.10), 0.1);\n    \n    // mirror z-axis\n    p.z = abs( p.z );\n    \n    // small branches\n    dist = sminCubic( dist, sdStick( p , vec3(1.4, 3.0, 0.1), vec3(3.2, 6.5, 3.0), 0.07, 0.02), 0.1);\n    dist = sminCubic( dist, sdStick( p , vec3(0.7, 3.5, 0.08), vec3(2.8, 7.5, 1.0), 0.05, 0.02), 0.1);\n    \n    // lang thin branches\n    dist = min( dist, sdStick( p , vec3(0.7, 0.0, 0.1), vec3(5.8, 10.5, 2.0), 0.05, 0.01));\n    dist = min( dist, sdStick( p , vec3(1.3, 0.0, 2.5), vec3(.3, 3.5, 2.0), 0.02, 0.01));\n    \n    return dist;\n}\n\n// combined SDF for scene\n// water is handled seperately for optimization\nfloat map( vec3 p ) {\n   \t\n    // slight distortion of the space\n    // makes the trees look more organic\n    // this makes a big difference\n    p += vec3(0.3*cos(1.2*p.x), 0.2*sin(1.2*p.y), 0.1*sin(p.z));\n    \n    vec3 p1 = p;\n    \n\t// rotation matrix based on pythagorean tripel\n    p1 *= mat3( 4.0, 0.0, 3.0,\n                0.0, 5.0, 0.0,\n               -3.0, 0.0, 4.0) / 5.0;\n    \n    float tree1 = sdTree(p1);\n    \n    vec3 p2 = p + vec3(3.0, 0.0, 0.0);\n   \t\n    // rotation matrix based on pythagorean tripel\n    p2 *= mat3(-4.0, 0.0, 3.0,\n                0.0, 5.0, 0.0,\n               -3.0, 0.0, -4.0) / 5.0;\n    \n    float tree2 = sdTree(p2);\n    \n    return min(tree1, tree2);\n}\n\n// optimized normal for water\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcWaterNormal( in vec3 pos)\n{\n    \n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*sdPlane( pos + e.xyy) + \n\t\t\t\t\t  e.yyx*sdPlane( pos + e.yyx) + \n\t\t\t\t\t  e.yxy*sdPlane( pos + e.yxy) + \n\t\t\t\t\t  e.xxx*sdPlane( pos + e.xxx) );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdPlane(pos+0.001*e);\n    }\n    return normalize(n);\n#endif    \n}\n\n// get distance to the water surface\n// the water is close, only a few iterations are needed\n// this helps because the displacement is costly\nfloat ray_march_water( vec3 eye, vec3 ray_dir ) {\n    float dist = 0.0;\n    for (int i = 0; i < 10; i++) {\n        float d = sdPlane( eye + dist * ray_dir );\n        if ( d < 0.001) {\n      \t\tbreak;\n        }\n        dist += d;\n        if ( dist > 10.0 ) {\n            break;\n        }    \n    }\n    return dist;\n}\n\n// get distance to the trees\n// farplane is close to speed things up\nfloat ray_march( vec3 eye, vec3 ray_dir ) {\n    float dist = 0.0;\n    for (int i = 0; i < 70; i++) {\n        float d = map( eye + dist * ray_dir );\n        if ( d < 0.001 * dist) {\n      \t\tbreak;\n        }\n        dist += d;\n        if ( dist > 18.0 ) {\n            break;\n        }\n        \n    }\n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get uv between -1 and 1 and fix aspect ratio\n    vec2 uv = 2.0*fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // camera setup\n    float angle = 0.05*(cos(iTime*0.2)) + 0.25;\n    \n    vec3 eye = vec3(3.0*sin(angle),\n                    1.6 + 0.2*(sin(iTime*0.23)),\n                    3.0*cos(angle));\n    \n    eye += vec3(0.3*sin(iTime*0.32), 0.0, 6.0);\n    \n    vec3 look_at = vec3( 0.0, 0.0, 6.0 );\n    vec3 view_dir = normalize( look_at - eye );\n    vec3 right = cross( vec3( 0.0, 1.0, 0.0 ), view_dir );\n    vec3 up = cross( view_dir, right );\n    float focal_dist = 5.0;\n    vec3 ray_dir = normalize( focal_dist*view_dir + uv.x*right + uv.y*up );\n    \n    // background color\n    vec3 col = vec3(0.5);\n    \n    // reflect ray at water surface\n    float dist = ray_march_water( eye, ray_dir );\n    vec3 p = eye + dist*ray_dir;\n    vec3 normal = calcWaterNormal( p );\n    ray_dir = reflect( ray_dir, normal );\n    \n    // raymarch the trees\n\tdist = ray_march( p + normal * 0.01, ray_dir );\n \n    // color trees black\n    if (dist < 18.0) col = vec3(0);\n    \n    // color moon white\n    // moon is at infinity\n    // render based on angle of the reflected ray\n\telse if ( dot( ray_dir, normalize(vec3(-0.35, 0.6, -1.0))) > 0.997) col = vec3(1);\n\n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}