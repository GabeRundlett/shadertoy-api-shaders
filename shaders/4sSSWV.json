{
    "Shader": {
        "info": {
            "date": "1415789993",
            "description": "Little shader art.",
            "flags": 0,
            "hasliked": 0,
            "id": "4sSSWV",
            "likes": 12,
            "name": "Grinder",
            "published": 3,
            "tags": [
                "art"
            ],
            "usePreview": 0,
            "username": "srtuss",
            "viewed": 490
        },
        "renderpass": [
            {
                "code": "// srtuss, 2014\n\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\nfloat tri(float x, float s)\n{\n    return (abs(fract(x * s) - 0.5)) / s;\n}\n\nfloat trid(float x, float s)\n{\n    return floor(x * s);\n}\n\nfloat hash(float x)\n{\n    return fract(sin(x * 197.9392) * 927293.523);\n}\n\n\n#define pi 3.1415926535897932384626433832795\n\nfloat df(vec3 d, float time, float td)\n{\n    float xx = length(d.xz) - time * 1.0;\n    \n    float id = trid(xx, 0.5);\n    \n    float l0 = tri(xx, 0.5) - 0.0;\n    vec2 pol1 = vec2(l0 - 0.5, d.y);\n    float l1 = length(pol1);\n    vec2 pol0 = vec2(atan(d.z, d.x) + time * (hash(id) - 0.5) * 8.0, 0.0);\n    pol1 = vec2(atan(pol1.y, pol1.x), l1);\n    \n    time = 3.0;\n    float param1 = 2.0 + floor(6.0 * hash(1.1111 + floor(2.0 * time)));\n    float param2 = floor(10.0 * hash(floor(4.0 * time)));\n    \n    float v = (tri(pol0.x, param1 / pi) - param2 * 0.04) * l0;\n    \n    float w = max(tri(pol1.x, param1 * 0.5 / pi) * l1, tri(pol1.x, param2 / pi) * l1);\n    \n    v = max(v, w - 0.05);\n    \n    \n    \n    v = max(v, l1 - 0.3);\n    \n    v = min(v, l1 - 0.1);\n    \n    return v;\n}\n\nfloat scene(vec3 p, float time)\n{\n    //p.y -= time;\n    vec3 d = p;\n    \n    //d.y = tri(d.y, 0.9);\n    \n    float shk = exp(fract(time * 0.5) * -3.0);\n    \n    float id = floor(p.y);\n    float v = df(p, time, 0.0);\n    return v;\n}\n\nfloat amb_occ(vec3 p, float h, float time)\n{\n\tfloat acc = 0.0;\n\tacc += scene(p + vec3(-h, -h, -h), time);\n\tacc += scene(p + vec3(-h, -h, +h), time);\n\tacc += scene(p + vec3(-h, +h, -h), time);\n\tacc += scene(p + vec3(-h, +h, +h), time);\n\tacc += scene(p + vec3(+h, -h, -h), time);\n\tacc += scene(p + vec3(+h, -h, +h), time);\n\tacc += scene(p + vec3(+h, +h, -h), time);\n\tacc += scene(p + vec3(+h ,+h, +h), time);\n\treturn acc / h;\n}\n\nvec3 normal(vec3 p, float time)\n{\n    vec2 h = vec2(0.01, 0.0);\n    return normalize(vec3(\n        scene(p + h.xyy, time) - scene(p - h.xyy, time),\n        scene(p + h.yxy, time) - scene(p - h.yxy, time),\n        scene(p + h.yyx, time) - scene(p - h.yyx, time)));\n}\n\nvec3 pixel(vec2 uv, float time)\n{\n    //uv.x += (hash(uv.y + iTime) - 0.5) * 0.1 * smoothstep(0.2, 0.1, fract(time * 0.2));\n    \n    vec3 ro = vec3(0.0, 0.5, -2.0);\n    vec3 rd = normalize(vec3(uv, 1.66));\n    \n    float tm = time * 0.5;\n    ro.xz = rotate(ro.xz, tm);\n    rd.xz = rotate(rd.xz, tm);\n    ro.xy = rotate(ro.xy, tm * 0.5);\n    rd.xy = rotate(rd.xy, tm * 0.5);\n    \n    float d = 0.0;\n    for(int i = 0; i < 50; i++)\n    {\n        d += scene(ro + rd * d, time);\n    }\n    \n    vec3 col = texture(iChannel0, rd).xyz * 0.7 + vec3(0.2);\n    \n    if(d < 9.0)\n    {\n        vec3 nml = normal(ro + rd * d, time);\n        vec3 ref = reflect(rd, nml);\n        col = exp(d * -1.0) * vec3(1.5);\n        col += texture(iChannel0, ref).xyz * 0.4;\n        col *= smoothstep(-4.0, 7.0, amb_occ(ro + rd * d, 0.03, time));\n        \n        //col = vec3(1.0) * smoothstep(0.01, 0.0, scene((ro + rd * d) + 0.2, time));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float time = iTime;\n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv += (vec2(hash(time), hash(time + 11.1)) - 0.5) * 0.02;\n    \n    vec3 col;\n    float mb = 0.02;\n    col = pixel(uv + 0.5 / iResolution.y, time + hash(uv.x + uv.y * 0.025231) * mb);\n    col += pixel(uv, time + hash(1042.8902 + uv.x + uv.y * 0.025231) * mb);\n    col *= 0.5;\n    \n    col = pow(col, vec3(1.0, 0.9, 0.8) * 1.5) * 4.0;\n    \n    col = pow(col, vec3(1.0 / 2.2));\n    \n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}