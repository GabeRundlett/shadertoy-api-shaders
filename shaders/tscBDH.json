{
    "Shader": {
        "info": {
            "date": "1604963428",
            "description": "Finding the center of a spiral formed by recursively applying a TRS matrix",
            "flags": 0,
            "hasliked": 0,
            "id": "tscBDH",
            "likes": 23,
            "name": "Logarithmic Spiral Center",
            "published": 3,
            "tags": [
                "spiral",
                "logarithmic"
            ],
            "usePreview": 0,
            "username": "tdhooper",
            "viewed": 738
        },
        "renderpass": [
            {
                "code": "/*\n\n    Logarithmic Spiral Center\n    -------------------------\n\n\tThis finds your final position when recursively applying a\n\ttranslation rotation scale matrix, but without doing the\n    actual recursion.\n\n\tSee also the 3d version:\n\thttps://www.shadertoy.com/view/wslyzH\n\n\n\tMETHOD:\n\n\tIt looks at the triangle formed by the first two points and\n\tthe center of the spiral, then calculates the center from known\n\tside and angle relations...\n\n\n\n               4---3\n              /     \\\n             5  x    \\\n              \\_/     2\n                     /\n                    /  \n                   /   \n        0---------1 \n\n\n    triangles formed by first three points and the spiral center:       \n\n\n                x_    \n               /| ```-2\n             /` |    /\n           /`    |  /  \n         /`      | /   \n        0---------1 \n\n\n    note that the segment angle is the same as the iteration rotation:\n\n\n                x_    \n               /| ```-2\n             /`y|    /\n           /`    |  /  \n         /`      | /y \n        0---------1 - - - -\n\n\n\tand that the adjacent sides are related by the iteration scale (s):\n\n\n                x     \n               /|\n          a  /`y| b\n           /`    |\n         /`      | \n        0---------1\n\t\t\t c\n\n\t\tb = a * s\n\n\n    side c is given by law of cosines:\n\n    \tc = sqrt(a^2 + b^2 - 2 * a * b * cos(y))\n\n\n   \tsubstituting a * s for b:\n\n\t\tc = sqrt(a^2 + (a * s)^2 - 2 * a * (a * s) * cos(y))\n\n\n    solve for a:\n    https://www.wolframalpha.com/widgets/view.jsp?id=c778a2d8bf30ef1d3c2d6bc5696defad\n\t\n\t\ta = c / sqrt(s^2 - 2 * s * cos(y) + 1)\n\n\n\tand get b:\n\t\n\t\tb = a * s;\n\n\n    find opposite angle to side b using sine law:\n\n                x     \n               /|\n          a  /`y| b\n           /`    |\n         /`k     | \n        0---------1\n\t\t\t c\n\n        k = a * sin(b * sin(y) / c);\n\n\n\tfind center using side a and angle k...\n\t\n\n*/\n\nvec2 spiralCenter(vec2 translation, float rotation, float scale) {\n\t// find sides and angles of segment triangle\n    float c = length(translation);\n\tfloat a = c / sqrt((scale * scale) - 2. * scale * cos(rotation) + 1.);\n\tfloat b = a * scale;\n\tfloat k = asin(b * sin(-rotation) / c);\n    // add angle from translation and calculate center\n    k += atan(translation.x, translation.y);\n    vec2 center = vec2(sin(k), cos(k)) * a;\n  \treturn center;\n}\n\n\n// shortened version from FabriceNeyret2\n// https://www.shadertoy.com/view/WdVczz\n// I'd like to explain this, but I don't know the steps taken\nvec2 spiralCenter2(vec2 translation, float rotation, float scale) { \n    float l = sqrt(scale * scale - 2. * scale * cos(rotation) + 1.);\n    float S = sin(rotation) * scale / l;\n    float C = sqrt(1. - S * S);\n    return mat2(-S, C, C, S) * translation.yx / l;\n}\n\n\n\n// Matrix functions\n// --------------------------------------------------------\n\nmat3 translateM(vec2 t) {\n\treturn mat3(1, 0, t.x, 0, 1, t.y, 0, 0, 1);\n}\n\nmat3 rotateM(float a) {\n\treturn mat3(cos(a), -sin(a), 0, sin(a), cos(a), 0, 0, 0, 1);\n}\n\nmat3 scaleM(vec2 s) {\n\treturn mat3(s.x, 0, 0, 0, s.y, 0, 0, 0, 1);\n}\n\nmat3 trsMatrix(vec2 translation, float rotation, float scale) {\n\treturn scaleM(vec2(scale)) * rotateM(rotation) * translateM(translation);\n}\n\nvec2 mul(vec2 p, mat3 m) {\n   return (vec3(p, 1) * m).xy;\n}\n\n\n\n// Drawing\n// --------------------------------------------------------\n\nvec3 col;\n\nvoid draw(float d, vec4 c) {\n    d /= fwidth(d);\n    d = clamp(d, 0., 1.);\n    d = 1. - d;\n    d *= c.a;\n    col = mix(col, c.rgb, d);\n}\n\nvoid draw(float d, vec3 c) {\n\tdraw(d, vec4(c, 1));\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n\n// Demo\n// --------------------------------------------------------\n\n#define PI 3.1415926\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.*fragCoord)/iResolution.y;\n\n    p -= vec2(-1,0);\n    \n    col = vec3(.014,.01,.02);\n    \n    float beat = sin(iTime) * .5 + .5;\n    float beat2 = sin(iTime / 2.) * .5 + .5;\n    \n    \n    // Translation, rotation, scale for each iteration\n    \n    float a = mix(PI / 2., -PI / 2., beat) * (beat2) + PI / 2.;\n  \tvec2 trs = vec2(sin(a), cos(a)) * mix(.75, .4, beat2);\n    float rot = mix(1., -1., beat);\n    float scl = mix(.5, .99, beat2);\n    \n    if (iMouse.z > 0.) {\n    \tvec2 m = (-iResolution.xy + 2.*iMouse.xy)/iResolution.y;\n    \tm -= vec2(-1,0);\n        trs = vec2(.5,0);\n        vec2 pt = m - trs;\n        rot = atan(pt.y, pt.x);\n        scl = length(pt) / length(trs);\n    }\n\n    \n    // Calculate center\n    \n    vec2 center = spiralCenter(trs, rot, scl);    \n\n    \n    // Draw spiral\n    \n    mat3 mat = trsMatrix(trs, rot, scl);\n    mat3 compound = mat;   \n    vec2 pt = vec2(0);\n    vec2 lastPt = pt;\n    \n    int n = 20;\n    for (int i = 0; i < n; i++) {\n        \n        float t = float(i) / float(n);\n        t = pow(t, .5);\n        float fade = smoothstep(1., .75, t);\n\n        draw(line(p, center, pt) - .0025, vec4(1, 1, 1, .1 * fade));\n        draw(length(p - pt) - .015, vec4(0,.33,.33, fade));\n        draw(line(p, lastPt, pt) - .01, vec4(0,.33,.33, .2 * fade));\n        \n        lastPt = pt;\n        pt = mul(vec2(0), compound);\n        compound = mat * compound;\n    }\n    \n    \n    // Draw center\n\n    draw(length(p - center) - .03, vec3(1));\t\n    \n    \n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}