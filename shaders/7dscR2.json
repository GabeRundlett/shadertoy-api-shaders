{
    "Shader": {
        "info": {
            "date": "1642436149",
            "description": "Pixel perfect antialiasing of an ellipse.",
            "flags": 0,
            "hasliked": 0,
            "id": "7dscR2",
            "likes": 10,
            "name": "Perfect Ellipse AA",
            "published": 3,
            "tags": [
                "antialiasing",
                "aa",
                "ellipse",
                "perfect"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 189
        },
        "renderpass": [
            {
                "code": "// See https://www.desmos.com/calculator/u1naqzb34q\n\n#define ANTIALIAS\n\nfloat sqr(in float x) { return x * x; }\nfloat arcint(in float x) { return (asin(clamp(x, -1.0, 1.0)) + x * sqrt(max(0.0, 1.0 - x * x))) / 2.0; }\n\n// Indefinite integral of clamp(ab.y * sqrt(1 - (x / ab.x)^2), mi, ma)\nfloat intClampedArc(in float mi, in float ma, in vec2 ab, in float x) {\n    if (ma < 0.0) return ma * x;\n    if (mi > ab.y) return mi * x;\n    if (mi < 0.0 && ma > ab.y) return ab.x * ab.y * arcint(x / ab.x);\n\n    float r1 = ab.x * sqrt(max(0.0, 1.0 - sqr(ma / ab.y)));\n    float r2 = ab.x * sqrt(max(0.0, 1.0 - sqr(mi / ab.y)));\n\n    if (mi < 0.0) {\n        if (abs(x) < r1) return ma * x;\n        return ab.x * ab.y * arcint(x / ab.x) - (ab.x * ab.y * arcint(r1 / ab.x) - ma * r1) * sign(x);\n    }\n\n    if (ma > ab.y) {\n        if (abs(x) < r2) return ab.x * ab.y * arcint(x / ab.x);\n        return mi * x + (ab.x * ab.y * arcint(r2 / ab.x) - mi * r2) * sign(x);\n    }\n\n    if (abs(x) < r2) {\n        if (abs(x) < r1) return ma * x;\n        return ab.x * ab.y * arcint(x / ab.x) - (ab.x * ab.y * arcint(r1 / ab.x) - ma * r1) * sign(x);\n    }\n\n    return mi * x + ((ab.x * ab.y * arcint(r2 / ab.x) - mi * r2) - (ab.x * ab.y * arcint(r1 / ab.x) - ma * r1)) * sign(x);\n}\n\n// Computes pixel coverage of an ellipse\nfloat ellipseAA(in vec2 p, in vec2 w, in vec2 ab) {\n    vec2 r = w / 2.0;\n    vec2 p1 = p - r, p2 = p + r;\n    float yMin = clamp(p1.y, -ab.y, ab.y), yMax = clamp(p2.y, -ab.y, ab.y);\n\n    float u = intClampedArc(p1.x, p2.x, ab.yx, yMax) - intClampedArc(p1.x, p2.x, ab.yx, yMin);\n    float v = intClampedArc(-p2.x, -p1.x, ab.yx, yMax) - intClampedArc(-p2.x, -p1.x, ab.yx, yMin);\n\n    return (u + v) / (w.x * w.y);\n}\n\nvec3 hue2rgb(in float hue) {\n    //return abs(2.0 * smoothstep(0.0, 1.0, fract(vec3(hue, hue - 1.0 / 3.0, hue + 1.0 / 3.0))) - 1.0);\n    return smoothstep(0.0, 1.0, abs(2.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue + 1.0 / 3.0)) - 1.0)) * 1.2;\n    //return clamp(abs(6.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue - 2.0 / 3.0)) - 3.0) - 1.0, 0.0, 1.0);\n    //return smoothstep(0.0, 1.0, clamp(abs(6.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue - 2.0 / 3.0)) - 3.0) - 1.0, 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float pix = 1.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    vec2 ab = vec2(0.3 + 0.25 * cos(iTime), 0.25 + 0.2 * sin(iTime));\n    #ifdef ANTIALIAS\n    color += ellipseAA(uv, vec2(pix), ab);\n    #else\n    uv /= ab;\n    color += step(dot(uv, uv), 1.0);\n    #endif\n\n    // Colorize (a bit distracting from the AA)\n    //color *= hue2rgb(0.5 * (cos(uv.x + iTime) + sin(uv.y)) - 0.25 * iTime);\n    color = pow(color, vec3(0.4545));\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}