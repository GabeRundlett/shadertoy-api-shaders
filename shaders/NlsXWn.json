{
    "Shader": {
        "info": {
            "date": "1626814447",
            "description": "Pseudo random number based whistling improsation, on trivial 2-5-1 \n * obstructed by some passages and scratches. \n * Pseudo random beat features, \n * floating rhytm and tuning,\n * some accidental artifacts that came from bugs, but I like them.",
            "flags": 8,
            "hasliked": 0,
            "id": "NlsXWn",
            "likes": 10,
            "name": "Lofi mansion",
            "published": 3,
            "tags": [
                "audio"
            ],
            "usePreview": 0,
            "username": "mare",
            "viewed": 405
        },
        "renderpass": [
            {
                "code": "\nfloat circle( vec2 uv, vec2 center,float radius )\n{\n    return 1.0 - (smoothstep( radius -.02, radius + .02, length( uv - center ) ) );\n}\nfloat arc( vec2 uv, vec2 a, vec2 b )\n{\n    vec2 diff = b - a;\n    float dist = length(diff);\n    vec2 diff90 = vec2( diff.y, -diff.x );\n    vec2 center = a + .866025 * diff90 + .5 * diff;\n    float distToCenter = length( uv - center );\n    \n    float circleVal = max(.0, 1.0 - 40.0 * abs( distToCenter - dist ) );\n    return circleVal * \n        clamp( 50.0 * dot( diff, uv - a), .0, 1.0 ) * \n        clamp( 50.0 * dot( -diff, uv - b), .0, 1.0 ) * \n        clamp( 50.0 * dot( uv - center, a - center), .0, 1.0 );\n        \n}\n#define INV_MUL(a,b) (1.0-(1.0-(a))*(1.0-(b)))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float time = 2.* iTime + 1.5 * sin( iTime * .5 );\n    vec2 uv = ( fragCoord - vec2( (iResolution.x - iResolution.y) * .5, 0 ) )/iResolution.y - vec2( .5 );\n\n    // Time varying pixel color\n    vec2 a = vec2( .3,.15) + vec2(sin(time*.9+32.)*0.1, sin(time*.2+124.)*.3);\n    vec2 b = vec2( .1,-.2) + vec2(sin(time*.7+98.)*0.1, sin(time*.1+987.)*.35);\n    vec2 c = vec2( -.4,.05) + vec2(sin(time*.8+24.)*0.15, sin(time*.3+156.)*.3);\n    vec2 d = vec2( .0,.25) + vec2(sin(time*.75+95.)*0.07, sin(time*.25+696.)*.1);\n    float col = circle( uv, a, .15 + sin(time*1.94+75.)*0.01);\n    col = INV_MUL( col, circle( uv, b, .075 + sin(time*2.1+26.)*0.01 ) );\n    col = INV_MUL( col, circle( uv, c, .1 + sin(time*1.3+81.)*0.02) );\n    col = INV_MUL( col, circle( uv, d, .1 + sin(time*2.94+81.)*0.003) );\n    col = INV_MUL( col, arc( uv, b,a ) );\n    col = INV_MUL( col, arc( uv, b,c ) );\n    col = INV_MUL( col, arc( uv, a,c ) );\n    col = INV_MUL( col, arc( uv, d,c ) );\n    col = INV_MUL( col, arc( uv, d,a ) );\n    col = INV_MUL( col, arc( uv, d,b ) );\n    float contour = clamp( 30.*(col-.55)*(col - .45),.0,1.0 );\n    col = min(col, 1.0 );\n\n    // Output to screen\n    fragColor = vec4(contour - col * .2 ,contour - col * .07, contour,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define TONE(i,f) sin(c_tg*f*float(i))\n#define TONE_UNTUNED( i, f,d) vec2(TONE(i,(1.-d)*f),TONE(i,(1.+d)*f))\n#define LIMIT(x,l) clamp(x,-l,l)*1./l\n#define TONE_MP(i,f,lp,hp) TONE(i,f)*clamp(min((f-lp)*.01,(hp-f)*.01),.0,1.)\n#define RAND(i) (fract(8023.*sin(float(i)*0.0876))*2.-1.)\n//#define RAND_INT(i,a) (((91331*(i)+15698)/((i)+11))%(a))\n#define RAND_INT(i,a) ((int((RAND(i)+1.0)*1.2e3))%(a))\n\n\n#define SPEED_UP_CYCLE 13\n\nfloat att( int samp, int len, float attack )\n{\n    float dt = float( samp );\n    float x = clamp( min( dt * attack,( float( len ) - dt ) )/ float( len ), .0, 1.0 );\n    x *= x; x *= x; return x;\n}\n\nfloat kick( int samp, float c_tg )\n{\n    float sine = TONE( samp, 30. ) + TONE( samp, 50. ) + TONE( samp, 80. );\n    sine *= att( samp, 15000, 1000.0 );\n    return LIMIT( sine, .8 ) * .2;\n}\nvec2 bass ( int samp, float f, float c_tg )\n{\n    vec2 sine = TONE_UNTUNED( samp, f, .003 ) * .3 + TONE_UNTUNED( samp, f * 2., -.003 ) * .3;\n    sine = vec2( LIMIT( sine.x, .8 ), LIMIT( sine.y, .8 ) );\n    return sine;\n}\n\nfloat hat( int samp )\n{\n    \n    float sine = RAND( samp % 8000 );\n    sine -= .2 * RAND( ( samp - 4 ) % 8000 );\n    sine -= .2 * RAND( ( samp - 3 ) % 8000 );\n    sine -= .2 * RAND( ( samp - 2 ) % 8000 );\n    sine -= .2 * RAND( ( samp - 1 ) % 8000 );\n    sine -= .2 * RAND( ( samp + 1 ) % 8000 );\n    sine -= .2 * RAND( ( samp + 2 ) % 8000 );\n    sine -= .2 * RAND( ( samp + 3 ) % 8000 );\n    sine -= .2 * RAND( ( samp + 4 ) % 8000 );\n    \n    sine *= att( samp, 18000, 30.0 );\n    return sine * 0.02;\n}\n\nfloat snare( int samp )\n{\n    float sine = RAND( samp / 10 );\n    float sine2 = RAND( samp / 3 );\n    float sine3 = RAND( samp );\n    sine *= att( samp, 17000, 1000.0 );\n    sine2 *= att( samp, 15000, 3.0 );\n    sine3 *= ( \n        att( samp, 5000, 10000.0 ) + \n        att( samp - 1500, 5000, 10000.0 ) * .4 + \n        att( samp - 3000, 5000, 10000.0 ) * .16 );\n    \n    return sine * .1 + sine2 * .3 + sine3 * .2;\n}\n\nconst int bpm = 200;\nconst int beatSampCount = 60 * 44100 / bpm;\nconst float progressionRatios[8] = float[8](1.125, 1.5, 1., 1., 2.25, 1.5, 1., 1. );\nconst float relative3rds[8] = float[8](1.2, 1.25, 1.25, 1.2, 1.2, 1.25, 1.2, 1.2 );\nconst float relative7ths[8] = float[8](1.75, 1.75, 1.888889, 1.66667, 1.75, 1.75, 1.888889, 1.888889 );\nconst int phraseQualityOffset[8] = int[8](17,0,0,0,17,0,0,0);\nconst float orderedRations[34] = float[34](\n    .0,\n    1.0,1.125,1.25, 1.33333,\n    1.5,1.666667, 1.75, 1.888888,\n    2.0, 2.25, 2.5, 2.66667,\n    3.0,3.33333, 3.5, 3.777777,\n    // major\n    .0,\n    1.0,1.111111,1.2, 1.33333,\n    1.5,1.666667, 1.75, 1.888888,\n    2.0, 2.222222, 2.4, 2.66667,\n    3.0, 3.142857, 3.5, 3.777777\n    // minor\n    \n    );\n    #define MELODY_LICK_COUNT 10\n    \nconst int melodyIndices[12*MELODY_LICK_COUNT] = int[12*MELODY_LICK_COUNT](\n    0,0,0,0,0,0,9,8,6,5,3,2,\n    1,2,0,2,6,7,9,11,10,0,0,0,\n    0,0,13,14,15,16,9,10,9,10,11,12,\n    13,0,7,0,10,11,5,6,6,5,6,7,\n    0,0,3,0,2,0,1,0,8,0,7,0,\n    5,4,3,2,2,2,1,0,2,0,3,0,\n    5,0,7,0,11,10,9,0,9,8,7,6,\n    0,0,6,8,9,10,8,0,5,6,0,0,\n    0,0,0,0,1,2,3,0,0,5,0,0,\n    17,16,14,13,11,10,9,13,9,5,0,0\n    );\n    \nconst int bassWalk[7] = int[7](\n    1,3,5,7,8,7,3\n    );\n    \n#define RHYTM_SAMPLE(samp) (samp+int(1000.*(TONE(samp,.3)+TONE(samp,.08))))\n    \nfloat chordLayer( int samp, float c_tg )\n{\n    int rhytmSamp = RHYTM_SAMPLE(samp);\n    int phraseLength = beatSampCount * 12;\n   \n    \n    int phraseIndexPrior = rhytmSamp / phraseLength;\n    int speedUpMask = 1 - min( phraseIndexPrior % SPEED_UP_CYCLE, 1);\n    int sustain = ( phraseLength * ( 1 + speedUpMask * 3) )/ 2;\n    rhytmSamp += int( 2. * float( speedUpMask * rhytmSamp ) );\n    \n    \n    \n    int phraseIndex = rhytmSamp / phraseLength;\n    int speedUpCount = ( phraseIndexPrior + SPEED_UP_CYCLE - 1 ) / SPEED_UP_CYCLE;\n    phraseIndex -= speedUpCount;\n    int phraseMod = phraseIndex & 7;\n    int phraseSamp = (rhytmSamp % phraseLength );\n    float f = progressionRatios[phraseMod] * 110.0 * (1.0 + .00004 - .00004 * TONE( samp, 8.02 ));\n    \n    \n    float chord1f = f;\n    float chord3f = relative3rds[phraseMod] * chord1f * 2.0;\n    float chord5f = 1.5 * chord1f * 4.;\n    float chord7f = relative7ths[phraseMod] * chord1f * 4.0;\n    float chord9f =  2.25 * chord1f * 2.0;\n    \n    int sineSamp = samp % ( phraseLength * 5 );\n    return\n    \n        TONE( sineSamp, chord1f) * .03 * att(phraseSamp, sustain, 100.0) + \n        TONE( sineSamp, chord3f) * .03 * att(phraseSamp - 8000, sustain, 100.0) + \n        TONE( sineSamp, chord5f) * .02 * att(phraseSamp - 3000, sustain, 100.0) + \n        TONE( sineSamp, chord7f) * .01 * att(phraseSamp, sustain, 100.0) + \n        TONE( sineSamp, chord9f) * .03 * att(phraseSamp - 3000, sustain, 100.0) + \n        TONE( sineSamp, chord9f) * .04 * att(phraseSamp - 13000, sustain, 100.0) +\n        TONE( sineSamp, chord1f) * .03 * float(RAND_INT(phraseIndex+324,2)) * att(phraseSamp - beatSampCount*(2+RAND_INT(phraseIndex+933,6)), phraseLength/2, 100.0) + \n        TONE( sineSamp, chord3f) * .03 * float(RAND_INT(phraseIndex+957,2)) * att(phraseSamp - beatSampCount*(2+RAND_INT(phraseIndex+462,6)), phraseLength/2, 100.0) + \n        TONE( sineSamp, chord5f) * .02 * float(RAND_INT(phraseIndex+234,2)) * att(phraseSamp - beatSampCount*(2+RAND_INT(phraseIndex+116,6)), phraseLength/2, 100.0) + \n        TONE( sineSamp, chord7f) * .01 * float(RAND_INT(phraseIndex+634,2)) * att(phraseSamp - beatSampCount*(2+RAND_INT(phraseIndex+697,6)), phraseLength/2, 100.0) + \n        TONE( sineSamp, chord9f) * .03 * float(RAND_INT(phraseIndex+199,2)) * att(phraseSamp - beatSampCount*(2+RAND_INT(phraseIndex+555,6)), phraseLength/2, 100.0) + \n        TONE( sineSamp, chord9f) * .04 * float(RAND_INT(phraseIndex+846,2)) * att(phraseSamp - beatSampCount*(2+RAND_INT(phraseIndex+698,6)), phraseLength/2, 100.0);      \n}\n\nfloat beatLayer( int samp, float c_tg )\n{\n    int rythmSamp = RHYTM_SAMPLE(samp);\n    int barLength = beatSampCount * 3;\n    int barSamp = (rythmSamp % barLength );\n    int barIndex = rythmSamp / barLength;\n    int phraseLength = beatSampCount * 12;\n    int phraseIndex = rythmSamp / phraseLength;\n    int phraseMod = phraseIndex & 7;\n    int phraseSamp = (rythmSamp % phraseLength );\n    int kickOffset1 = (RAND_INT(phraseIndex+748,4)- 2);\n    int kickOffset2 = kickOffset1 + (RAND_INT(phraseIndex+748,1 - kickOffset1) ) + 1;\n    \n\n     return \n        kick( phraseSamp, c_tg ) + \n        kick( phraseSamp - phraseLength / 2 + kickOffset1*beatSampCount , c_tg ) + \n        kick( phraseSamp - phraseLength / 2 + kickOffset2*beatSampCount , c_tg ) + \n        \n        hat( phraseSamp ) +\n        hat( barSamp - beatSampCount + 50 ) +\n        hat( barSamp - beatSampCount - beatSampCount ) +\n        hat( phraseSamp - beatSampCount / 2 - beatSampCount * ( RAND_INT( barIndex+493,13 ) ) ) +\n        \n        hat( phraseSamp - 3 * beatSampCount / 2) * .2+\n        hat( barSamp - 3 * beatSampCount / 2 - beatSampCount + 50 ) * .2 +\n        hat( barSamp - 3 * beatSampCount / 2 - beatSampCount - beatSampCount ) * .2 +\n        snare( phraseSamp - phraseLength / 4  ) + \n        snare( phraseSamp - 3 * phraseLength / 4 );\n        \n}\n    \nvec2 mainSound( int samp, float time )\n{\n    float c_tg = 6.2831 / iSampleRate; // sine tangent   \n    int rhytmSamp = RHYTM_SAMPLE(samp);\n    int barLength = 3 * beatSampCount;\n    int phraseLength = beatSampCount * 12;  \n    int phraseIndexPrior = rhytmSamp / phraseLength;\n    int speedUpMask = 1 - min( phraseIndexPrior % SPEED_UP_CYCLE, 1);\n    rhytmSamp += int( 2. * float( speedUpMask * rhytmSamp ) );\n    \n    int beatSamp = (rhytmSamp % beatSampCount );\n    int barSamp = (rhytmSamp % barLength );\n    int barIndex = rhytmSamp / barLength;\n    int beatIndex = rhytmSamp / beatSampCount;\n    \n    int phraseIndex = barIndex / 4;\n    int speedUpCount = ( phraseIndexPrior + SPEED_UP_CYCLE - 1 ) / SPEED_UP_CYCLE;\n    phraseIndex -= speedUpCount;\n    \n    int phraseSamp = (rhytmSamp % phraseLength );\n    int phraseMod = phraseIndex & 7;\n    int sineSamp = samp % ( phraseLength * 5 );\n    \n    \n    float f = progressionRatios[phraseMod] * 110.0 * (1.0 + .000005 * TONE( samp, 8.02 ));\n    float f2  = progressionRatios[phraseMod & 3] * 110.0 * (1.0 + .000005 * TONE( samp, 8.02 ));\n    int cycleRange = int( iSampleRate / (f *4.) );\n    float barBack = 4.0 *  (float (barSamp) / float(barLength) ) * (float (barLength-barSamp) / float(barLength) );\n    \n    int lickIndex = RAND_INT( (barIndex / 2), MELODY_LICK_COUNT);\n    int melodyMod = (beatIndex % 6 ) + 6 * lickIndex;\n    float melodyF1 = f2 * 4.0 * orderedRations[ melodyIndices[ 2 * melodyMod ] + phraseQualityOffset[phraseMod] ];\n    float melodyF2 = f2 * 4.0 * orderedRations[ melodyIndices[ 2 * melodyMod + 1 ] + phraseQualityOffset[phraseMod]];\n    float bassF = f2 * .25 * orderedRations[ bassWalk[ (barIndex*2) % 7 ] + phraseQualityOffset[phraseMod]];\n    float bassF2 = f2 * .25 * orderedRations[ bassWalk[ (barIndex*2 + 1) % 7 ] + phraseQualityOffset[phraseMod]];\n    \n    float scratchMask = ( max( -TONE( rhytmSamp - int(100. * TONE( rhytmSamp, .4 ) ), .125 * iSampleRate / float(phraseLength) ), .96 ) - .96 ) * 25.0;\n    scratchMask = max( scratchMask, clamp( .1 * time - 17.0,  .0, 1.0 ) );\n    int scratchDistortion = int( 6000. * TONE( rhytmSamp, 4.0 ) * scratchMask );\n    float maskFloat = 1.0 - float(speedUpMask);\n    float melodyMask = float(speedUpCount & 1 );\n    float tatTatMask = float((speedUpCount/2) & 1 );\n    \n    vec2 sound =\n        vec2( beatLayer(samp + scratchDistortion, c_tg) ) * maskFloat +\n        vec2( chordLayer(samp + scratchDistortion, c_tg) ) + \n        bass( sineSamp, bassF, c_tg ) * .3 * att(barSamp, barLength, 100.0) * maskFloat + \n        bass( sineSamp, bassF2, c_tg ) * .3 * att(barSamp - 2 * barLength, barLength, 100.0) * maskFloat + \n        TONE_UNTUNED( sineSamp, melodyF1,.01)* .6 * att(beatSamp, beatSampCount/2, 2.0) * maskFloat * melodyMask + \n        TONE_UNTUNED( sineSamp, melodyF2,-.02)* .2 * att(beatSamp - 2*beatSampCount/3, beatSampCount/3, 2.0) * maskFloat * melodyMask + \n        TONE_UNTUNED( sineSamp, 1.5 * f, .001 )*att(barSamp - beatSampCount + 50, beatSampCount, 10.0) * .2 * maskFloat * tatTatMask+ \n        TONE_UNTUNED( sineSamp, 1.5 * 1.2 * f,-.001 )*att(barSamp - beatSampCount - beatSampCount, beatSampCount, 10.0)* .2 * maskFloat * tatTatMask\n        ;\n    return sound * clamp( ( 180.0 - time ) * .2, .0, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}