{
    "Shader": {
        "info": {
            "date": "1716350378",
            "description": "cross eyed 3D ray marching fractal\ninstructions at top of source code.\n",
            "flags": 48,
            "hasliked": 0,
            "id": "4XtGDr",
            "likes": 0,
            "name": "cycle4",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "kosalos",
            "viewed": 110
        },
        "renderpass": [
            {
                "code": "/*\nPress Up/Dn arrow keys to select widget focus.\nPress  Lt/Rt arrow keys to alter widget value.\nDrag mouse on X axis to alter focused widget value.\nPress <Spc> to reset.\n\n\nCross-eyed 3D\nSlightly cross your eyes so that there is a third image in the middle.\nRelax your gaze, and concentrate only on that middle image, which is in 3D.\n\n*/\n\nstruct Dataset {\n    // DE() params\n\tint maxsteps;\n    \n    float offset,kNum,kMax,iterOffset,kOffset;\n    vec3 C,camera,target;\n\n    bool inversion;\n    vec3 invpos;\n    float invradius;\n    float invangle;    \n    \n    float epsilon;\n    float ambient,contrast,vibrant,dim;\n    float fogDistance,fogAmount,fogColor; // distance = 0.0 -> disable effect\n    \n    vec3 lightColor;\n    vec3 lightPosition;\n    vec3 lightParam; // diffuse, specular, ambient\n\n    vec4 orbitTrap;\n    float Ostrength; // 0.0 -> disable orbit trapping\n    float Ocycle;\n    float OXwt,OXcr; // weight, color code\n    float OYwt,OYcr;\n    float OZwt,OZcr;\n    float OWwt,OWcr;\n    vec3  Ocenter;   // origin offset\n    \n    bool stereo;\n    float parallax;  // adjust for best stereo effect 0 ... 0.2\n\n    // calculated params \n    vec3 direction;\n    vec3 normal;\n    vec3 position;\n    vec3 color;\n    float depth;\n    int iter;\n    \n    int focus,row,displayCount;\n};\n\n// --------------------------------------------------------\n\nfloat DE(vec3 p,inout Dataset data) {\n    float iter,k,scale = 1.0;\n    vec3 ot,cc = abs(data.C);\n \n    for(int n=0;n<100;n++) {\n        if(n >= data.maxsteps) break;\n\n        p = 2.0 * clamp(p, -cc,cc) - p;\n\n        iter = float(n) * data.iterOffset;\n        k = max(data.kNum/dot(p,p), (iter * data.kMax));\n\n        scale *= k;\n        k *= (1.0 + data.kOffset);\n        p *= k;\n                \t\t\n\t\tot = p - data.Ocenter;\n\t\tdata.orbitTrap = min(data.orbitTrap, vec4(abs(ot), dot(ot,ot)));\n    }\n\n    float l = length(p.xy);\n    float rxy = l - data.offset;\n    float n = l * p.z;\n    rxy = max(rxy, -n / (length(p))-0.02);\n    return rxy / abs(scale);\n}\n\n// --------------------------------------------------------\n// distance estimation function wrapped by spherical inversion code.\n\nfloat DE_plusSpherical(vec3 pos,inout Dataset data) {\n    if(data.inversion) {\n        pos = pos - data.invpos;\n        float r = length(pos);\n        float r2 = r*r;\n\t\tfloat radius2 = data.invradius * data.invradius;\n        pos = (radius2 / r2) * pos + data.invpos;\n        \n        float an = atan(pos.y,pos.x) + data.invangle;\n        float ra = length(pos.xy);\n        pos.x = cos(an) * ra;\n        pos.y = sin(an) * ra;\n\t\t\t\t\n        float de = DE(pos,data);\n        return r2 * de / (radius2 + r * de);\n    }\n    \n    return DE(pos,data);\n}\n\n// --------------------------------------------------------\n\nvec3 generateColor(float weight,float x) {\n\tif(weight == 0.0) return vec3(0.0);\n\n\tx = cos(x);\n\t//x=abs(sin(x)); // limits colors\n\n    // bezier, you can rearange the functions for different color combos but this one is best\n\tfloat r = (1.0-x)*(1.0-x);\n\tfloat g = x*x;\n\tfloat b = 2.0*(1.0-x)*x;\n\treturn vec3(r,g,b);\n}\n\nvec3 orbitTrapCycle(float cycle,vec3 c, float s) {\n    float ss = s * cycle;\n    return vec3(0.5) + 0.5 * vec3( cos(ss + c.x), cos(ss + c.y), cos(ss + c.z));\n}\n\nvec3 getOrbitColor(inout Dataset data) {\n    vec3 orbitColor;\n    \n    if (data.Ocycle > 0.0) {\n        orbitColor =\n        orbitTrapCycle(data.Ocycle,generateColor(data.OXwt,data.OXcr), data.orbitTrap.x) * data.OXwt * data.orbitTrap.x +\n        orbitTrapCycle(data.Ocycle,generateColor(data.OYwt,data.OYcr), data.orbitTrap.y) * data.OYwt * data.orbitTrap.y +\n        orbitTrapCycle(data.Ocycle,generateColor(data.OZwt,data.OZcr), data.orbitTrap.z) * data.OZwt * data.orbitTrap.z +\n        orbitTrapCycle(data.Ocycle,generateColor(data.OWwt,data.OWcr), data.orbitTrap.w) * data.OWwt * data.orbitTrap.w;\n    } else {\n        orbitColor =\n        \tgenerateColor(data.OXwt,data.OXcr) * data.OXwt * data.orbitTrap.x +\n        \tgenerateColor(data.OYwt,data.OYcr) * data.OYwt * data.orbitTrap.y +\n        \tgenerateColor(data.OZwt,data.OZcr) * data.OZwt * data.orbitTrap.z +\n        \tgenerateColor(data.OWwt,data.OWcr) * data.OWwt * data.orbitTrap.w;\n    }\n    \n    return orbitColor;\n}\n\nvec3 phong_contrib(inout Dataset data) { \n\tvec3 L = normalize(data.lightPosition - data.position);\n\tfloat dotLN = dot(L, data.normal);\n\tif (dotLN < 0.0)\n\t\treturn vec3(0, 0, 0);\n\t\t\n\tfloat t1 = data.lightParam.x * dotLN;\n\n\tvec3 V = normalize(data.camera - data.position);\n\tvec3 R = normalize(reflect(-L, data.normal));\n\tfloat dotRV = dot(R, V);\n\n\tif (dotRV < 0.0)\n\t\treturn vec3(data.lightColor * t1);\n\n\tfloat t2 = data.lightParam.y * pow(abs(dotRV), data.lightParam.z);\n\tdata.color += data.lightColor * (t1 + t2);\n}\n\n\nvoid applyColoring(inout Dataset data) { \n    data.color = vec3(data.ambient) + vec3(1.0 - (data.normal * data.vibrant + sqrt(float(data.iter) * data.dim)));\n    data.color = vec3(0.5) + (data.color - vec3(0.5)) * data.contrast;\n    \n    if(length(data.lightColor) > 0.0) \n\t\tphong_contrib(data);\n        \n        \n    if(data.Ostrength > 0.0) {\n        vec3 oColor = getOrbitColor(data);\n        data.color = mix(data.color, oColor, data.Ostrength);\n    }\n}\n\n// --------------------------------------------------------\n// normal vector for 3D coordinate determined by comparing values of neighboring positions\n\nvoid calcNormal(inout Dataset data) {\n    float ex = data.epsilon;\n    float ey = -ex;\n    vec3 pos = data.position;\n    \n    vec3 t1 = vec3( pos[0] + ex, pos[1] + ey, pos[2] + ey); float a1 = DE(t1,data);\n    vec3 t2 = vec3( pos[0] + ey, pos[1] + ey, pos[2] + ex); float a2 = DE(t2,data);\n    vec3 t3 = vec3( pos[0] + ey, pos[1] + ex, pos[2] + ey); float a3 = DE(t3,data);\n    vec3 t4 = vec3( pos[0] + ex, pos[1] + ex, pos[2] + ex); float a4 = DE(t4,data);\n\n    data.normal = normalize(vec3(\n        ex * a1 + ey * a2 + ey * a3 + ex * a4,\n        ey * a1 + ey * a2 + ex * a3 + ex * a4,\n        ey * a1 + ex * a2 + ey * a3 + ex * a4 ));\n}\n\n// --------------------------------------------------------\n\nvoid setDirection(vec2 fragCoord,inout Dataset data) {\n    vec3 viewVector = normalize(data.target - data.camera);\n    vec3 sideVector = vec3(0.0, 1.0, 0.0);\n    sideVector = cross(sideVector,viewVector);\n    sideVector = normalize(sideVector);\n    vec3 topVector = viewVector;\n    topVector = cross(topVector,sideVector);\n\n    // cross eyed stereo ------------------------------------\n    vec2 srcP = fragCoord;        // copy of pixel coordinate; x is altered for stereo\n    float xsize = iResolution.x;  // copy of window size; x is altered for stereo\n    \n    if(data.stereo) {\n        vec3 soffset = sideVector * data.parallax;\n\t\txsize *= 0.5;             // window x size adjusted for 2 views side by side\n        if(srcP.x >= xsize) {     // right side of stereo pair?\n\t\t\tsrcP.x -= xsize;      // base 0  X coordinate\n\t\t\tdata.camera -= soffset;// adjust for right side parallax\n\t\t}\n\t\telse {\n\t\t\tdata.camera += soffset;// adjust for left side parallax\n\t\t}\n    }\n    \n    vec2 vPos = (srcP - iResolution.xy * 0.5)/iResolution.y;\n    data.direction = normalize(viewVector + vPos.x * sideVector + vPos.y * topVector);\n}\n\n// --------------------------------------------------------\nconst float MIN_DIST = 0.0001;\nconst float MAX_DIST = 20.0;\n\nvoid rayMarch(inout Dataset data) {\n\tvec3 position = data.camera;\n\tfloat distance;\n\tdata.iter = 0;\n\tdata.depth = MIN_DIST;\n\t\n\tfor(int i = 0;i < 50;++i) {\n\t\tdistance = DE_plusSpherical(position,data);\n        if(abs(distance) < MIN_DIST || data.depth > MAX_DIST) break;\n        data.iter += 1;\n\t\t\n        data.depth += distance;\n        position = data.camera + data.direction * data.depth;\n  }\n}\n\n\n// animation routines ----------------------------------------\n\nvoid cycleValue(inout float value, float vmin,float vmax, float speed) {\n    float ratio = 0.5 + 0.5 * cos(iTime * speed);  // 0 ... 1\n    value = vmin + (vmax - vmin) * ratio;\n}\n\nvoid cycleValue2(inout float value, float baseValue, float deviation, float speed) {\n    float ratio = 1.0 + cos(iTime * speed);  // 0 ... 2\n    value = baseValue-deviation + deviation * ratio;\n}\n\nvoid cycleValue3(inout float value, float baseValue, float amount, float speed) {\n    float ratio = 1.0 + cos(iTime * speed);  // 0 ... 2\n    float deviation = baseValue * amount * 0.5;    \n    value = baseValue-deviation + deviation * ratio;\n}\n\nvoid cycleValue3Vec3(inout vec3 value, vec3 baseValue, float amount, float speed) {\n    for(int i=0;i<3;++i)\n        cycleValue3(value[i],baseValue[i],amount,speed);\n}\n\nvoid moveTarget(inout Dataset data) {\n    cycleValue3Vec3(data.target,targetDefault,6.0, 0.1);\n}\n    \nvoid alterLight(inout Dataset data) {\n   cycleValue3(data.lightColor.x,2.5,2.0,0.3);\n   cycleValue3(data.lightColor.y,2.5,2.0,0.4);\n   cycleValue3(data.lightColor.z,2.5,2.0,0.5);\n   \n   cycleValue(data.lightPosition.x,-2.0,2.0,0.3);\n   cycleValue(data.lightPosition.y,-2.0,2.0,0.35);\n   cycleValue(data.lightPosition.z,-2.0,2.0,0.4);\n   \n   cycleValue3(data.lightParam.x,0.5,0.02,0.2); // diffuse\n   cycleValue3(data.lightParam.y,0.5,0.02,0.3); // specular\n   cycleValue3(data.lightParam.z,0.5,0.02,0.4); // ambient\n}\n\nvoid alterOrbitColors(inout Dataset data) {\n    const float weight = 4.0;\n    cycleValue(data.OXwt,-weight,weight,0.02); // weights\n    cycleValue(data.OYwt,-weight,weight,0.03);\n    cycleValue(data.OZwt,-weight,weight,0.05);\n    cycleValue(data.OWwt,-weight,weight,0.07);\n\n    const float color = 5.0;\n    cycleValue(data.OXcr,-color,color,0.01);  // color code\n    cycleValue(data.OYcr,-color,color,0.02);\n    cycleValue(data.OZcr,-color,color,0.03);\n    cycleValue(data.OWcr,-color,color,0.05);\n    \n    cycleValue(data.Ocenter.x,0.0,3.0,0.03);\n    cycleValue(data.Ocenter.y,0.0,3.0,0.05);\n    cycleValue(data.Ocenter.z,0.0,3.0,0.07);\n}\n\n// --------------------------------------------------------\nmakeStr1f(printCx)  _C _x _COL __ _dec(i, 4) _end\nmakeStr1f(printCy)  _C _y _COL __ _dec(i, 4) _end\nmakeStr1f(printCz)  _C _z _COL __ _dec(i, 4) _end\nmakeStr1f(printOffset)  _O _f _f _s _e _t _COL __ _dec(i, 4) _end\nmakeStr1f(printkNum)  _k _N _u _m _COL __ _dec(i, 4) _end\nmakeStr1f(printkMax)  _k _M _a _x _COL __ _dec(i, 4) _end\nmakeStr1f(printiterOffset)  _i _t _e _r _O _f _f _COL __ _dec(i, 4) _end\nmakeStr1f(printkOffset)  _k _O _f _f _s _e _t _COL __ _dec(i, 4) _end\nmakeStr1f(printInvposx)  _I _n _v _P _o _s _X _COL __ _dec(i, 4) _end\nmakeStr1f(printInvposy)  _I _n _v _P _o _s _Y _COL __ _dec(i, 4) _end\nmakeStr1f(printInvposz)  _I _n _v _P _o _s _Z _COL __ _dec(i, 4) _end\nmakeStr1f(printInvRadius)  _I _n _v _R _a _d _i _u _s _COL __ _dec(i, 4) _end\nmakeStr1f(printInvAngle)  _I _n _v _A _n _g _l _e _COL __ _dec(i, 4) _end\nmakeStr1f(printCamerax)  _C _a _m _e _r _a _X _COL __ _dec(i, 4) _end\nmakeStr1f(printCameray)  _C _a _m _e _r _a _Y _COL __ _dec(i, 4) _end\nmakeStr1f(printCameraz)  _C _a _m _e _r _a _Z _COL __ _dec(i, 4) _end\n\nvec3 rowColor(inout Dataset data) {\n if(data.row == data.focus) return vec3(0.,1.,0.);\n return vec3(0.8);\n}\n\nvoid printDebug(inout Dataset data,inout vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.x > iResolution.x * 0.33) return; // no printing in that region\n\n    vec2 uv = fragCoord / iResolution.y;\n    vec3 col = vec3(0);    \n\n    const float font_size = 15.0; // Font Size (higher values = smaller font)\n    uv *= font_size;        // Scale font with font_size\n    uv.y -= font_size - 1.; // Start drawing from the top   \n\n    for(data.row = 0; data.row < 16; ++data.row) {\n       if(data.row >= data.focus-1 && data.row <= data.focus+1) {\n            if(data.row ==  0) col += rowColor(data) * printCx(uv, data.C.x);  \n            if(data.row ==  1) col += rowColor(data) * printCy(uv, data.C.y);\n            if(data.row ==  2) col += rowColor(data) * printCz(uv, data.C.z);\n            if(data.row ==  3) col += rowColor(data) * printOffset(uv, data.offset);\n            if(data.row ==  4) col += rowColor(data) * printkNum(uv, data.kNum);\n            if(data.row ==  5) col += rowColor(data) * printkMax(uv, data.kMax);\n            if(data.row ==  6) col += rowColor(data) * printiterOffset(uv, data.iterOffset);\n            if(data.row ==  7) col += rowColor(data) * printkOffset(uv, data.kOffset);\n            if(data.row ==  8) col += rowColor(data) * printInvposx(uv, data.invpos.x);\n            if(data.row ==  9) col += rowColor(data) * printInvposy(uv, data.invpos.y);\n            if(data.row == 10) col += rowColor(data) * printInvposz(uv, data.invpos.z);\n            if(data.row == 11) col += rowColor(data) * printInvRadius(uv, data.invradius);\n            if(data.row == 12) col += rowColor(data) * printInvAngle(uv, data.invangle);\n            if(data.row == 13) col += rowColor(data) * printCamerax(uv, data.camera.x);\n            if(data.row == 14) col += rowColor(data) * printCameray(uv, data.camera.y);\n            if(data.row == 15) col += rowColor(data) * printCameraz(uv, data.camera.z);\n        }\n        \n        uv.y += 0.8;  \n    }\n    \n    if(length(col) > 0.)\n    fragColor.xyz = col;\n}   \n \n// --------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Dataset data;\n    \n    // read stored data -------------------\n    vec3 sd = fetchData(iChannel0, FOCUS_ADDR).xyz;\n    data.focus = int(sd.x);\n    data.displayCount = int(sd.y);\n    \n    sd = fetchData(iChannel0, P0_ADDR).xyz;\n    data.C = sd;\n    sd = fetchData(iChannel0, P1_ADDR).xyz;\n    data.offset = sd.x;\n    data.kNum = sd.y;\n    data.kMax = sd.z;\n    sd = fetchData(iChannel0, P2_ADDR).xyz;\n    data.iterOffset = sd.x;\n    data.kOffset = sd.y;\n    data.invpos.x = sd.z;\n    sd = fetchData(iChannel0, P3_ADDR).xyz;\n    data.invpos.y = sd.x;\n    data.invpos.z = sd.y;\n    data.invradius = sd.z;\n    sd = fetchData(iChannel0, P4_ADDR).xyz;\n    data.invangle = sd.x;\n    data.camera.x = sd.y;\n    data.camera.y = sd.z;\n    sd = fetchData(iChannel0, P5_ADDR).xyz;\n    data.camera.z = sd.x;\n    \n    // init non-stored data ---------------\n    data.maxsteps = 11;\n\tdata.target = targetDefault;\n    data.orbitTrap = vec4(10000.);\n    data.epsilon = 0.000005; // deviation when calculating normal\n    \n    data.ambient = 0.029;\n    data.contrast = 1.6;\n    data.vibrant = 0.01;\n    data.dim = 0.01; // larger -> dimmer\n\tdata.color = vec3(0,0,0); \n\n    data.fogDistance = -1.; // set to 0.0 to disable fog\n    data.fogAmount = 0.1;\n    data.fogColor = 0.25;\n    \n    data.lightColor = vec3(1.5,1.5,1.5); // set to 0.0 to disable light #1\n    data.lightPosition = vec3(9.0,17.0,-20.0);\n    data.lightParam = vec3(0.1,0.3,10.13);\n    \n    data.inversion = true;\n    \n    data.Ostrength = OstrengthDefault;\n    data.Ocycle = OcycleDefault;\n    data.OXwt = OXwtDefault;\n    data.OXcr = OXcrDefault;\n    data.OYwt = OYwtDefault;\n    data.OYcr = OYcrDefault;\n    data.OZwt = OZwtDefault;\n    data.OZcr = OZcrDefault;\n    data.OWwt = OWwtDefault;\n    data.OWcr = OWcrDefault;\n    data.Ocenter = OcenterDefault;\n    \n    data.stereo = true;\n    data.parallax = 0.006; // use smaller values when viewing closeup objects\n    \n    // animation routines -----\n    moveTarget(data);\n    alterLight(data); \n    alterOrbitColors(data);\n/*\n    cycleValue3(data.Ostrength,OstrengthDefault,1.2,0.1);\n    cycleValue3(data.Ocycle,OcycleDefault,1.2,0.1);\n    alterLight(data); \n*/\n\n    setDirection(fragCoord,data);\n\trayMarch(data);\n    \n\tif(data.depth < MAX_DIST) {  \n        data.position = data.camera + data.direction * data.depth;\n        calcNormal(data);\n\t\tapplyColoring(data);\n    }\n\n    if(data.fogDistance != 0.0) {\n        float f = data.depth - data.fogDistance;\n        if(f > 0.0) {\n            f = min(1.0,f * data.fogAmount);\n            data.color = mix(data.color, vec3(0.2 + f * data.fogColor),f);\n        }\n    }\n\n    fragColor = vec4(data.color,1.0);\n    \n    if(data.displayCount > 0) \n        printDebug(data,fragColor,fragCoord);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec3  cameraDefault = vec3(-3.021484681, 0.88749269, 0.4249795319); \nconst vec3  targetDefault = vec3(0.); // -0.22441644, -0.9516024, -0.20997651); // whatever you want; will be normalized\nconst float OstrengthDefault = 0.05;\nconst float OcycleDefault = 0.0;\nconst float OXwtDefault = 2.0736677;\nconst float OXcrDefault = -3.9815997;\nconst float OYwtDefault = 2.03396538;\nconst float OYcrDefault = 1.71172849;\nconst float OZwtDefault = -2.74972636;\nconst float OZcrDefault = -0.55577678;\nconst float OWwtDefault = 0.25; \nconst float OWcrDefault = -4.24845531;\nconst vec3  OcenterDefault = vec3(-0.5); \n\n// ========================================================================\n\nstruct ParamData {\n    float start,vmin,vmax,delta;\n};\n\nconst ParamData[] pData = ParamData[](  \n    ParamData(1.203, 0., 5., 0.002), // Cx\n    ParamData(0.3239, 0., 5., 0.001), // Cy\n    ParamData(1.789, 0., 5., 0.001), // Cz\n    ParamData(0.98, 0.001, 2.5, 0.1), // offset\n    ParamData(1.777, 0.01, 4., 0.01), // kNum\n    ParamData(1.973, 0.01, 4., 0.02), // kMax\n    ParamData(-0.448, 0.01, 0.2, 0.001), // iterOffset\n    ParamData( 0.001, -0.1, 0.1, 0.001), // kOffset\n    ParamData( 0.058, -15., 15., 0.001), // invpos x\n    ParamData( 0.806, -15., 15., 0.001), // invpos y\n    ParamData( 3.45, -15., 15., 0.001), // invpos z\n    ParamData( 0.94, 0.01, 10., 0.001), // invradius\n    ParamData( -2.78, -5., 5., 0.001), // invangle\n    ParamData( -0.75, -20., 20., 0.01), // camera x\n    ParamData( -2.58, -20., 20., 0.01), // camera y\n    ParamData( -4.59, -20., 20., 0.01)  // camera z\n );\n  \nconst ivec2 FOCUS_ADDR = ivec2(1, 0);\nconst ivec2 P0_ADDR = ivec2(2, 0);\nconst ivec2 P1_ADDR = ivec2(3, 0);\nconst ivec2 P2_ADDR = ivec2(4, 0);\nconst ivec2 P3_ADDR = ivec2(5, 0);\nconst ivec2 P4_ADDR = ivec2(6, 0);\nconst ivec2 P5_ADDR = ivec2(7, 0);\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeDataAddr(buf_pos, addr) ivec2(buf_pos) == addr\n#define storeData(buf_pos, addr,data) if(ivec2(buf_pos) == addr) fragColor = data\n\n// ========================================================================\n// EasyText: https://www.shadertoy.com/view/dsGXDt\n\n// Set to the iChannel containing the alphabet texture\n#define FONT_TEXTURE iChannel3\n\n// Horizontal character spacing (default: 0.5)\n#define CHAR_SPACING 0.44\n\n\n/// STRING CREATION ///\n\n// Create a basic string\n#define makeStr(func_name) float func_name(vec2 u) { _print \n\n// Create a string with an int parameter\n#define makeStr1i(func_name) float func_name(vec2 u, int i) { _print\n\n// Create a string with a float parameter\n#define makeStr1f(func_name) float func_name(vec2 u, float i) { _print\n\n// Create a string with two floats parameter\n#define makeStr2f(func_name) float func_name(vec2 u, float i, float j) { _print\n\n// ... Or create your own strings with any parameters\n#define makeStrXX(func_name) float func_name(vec2 u, ...) { _print\n\n// Terminate a string\n#define _end    ); return d; }\n\n// Dynamic uppercase character\n// i: [0-25]\n#define _ch(i)  _ 65+int(i)\n\n// Dynamic digit\n// i: [0-9]\n#define _dig(i) _ 48+int(i)\n\n// Floating point debug\n// x:   value to print\n// dec: number of decimal places to print\n#define _dec(x, dec) ); d += _decimal(FONT_TEXTURE, u, x, dec); (0\n\n// Space\n#define __    ); u.x -= CHAR_SPACING; (0\n\n#define _EXC  _ 33 // \" ! \"\n#define _DBQ  _ 34 // \" \" \"\n#define _NUM  _ 35 // \" # \"\n#define _DOL  _ 36 // \" $ \"\n#define _PER  _ 37 // \" % \"\n#define _AMP  _ 38 // \" & \"\n#define _QUOT _ 39 // \" ' \"\n#define _LPR  _ 40 // \" ( \"\n#define _RPR  _ 41 // \" ) \"\n#define _MUL  _ 42 // \" * \"\n#define _ADD  _ 43 // \" + \"\n#define _COM  _ 44 // \" , \"\n#define _SUB  _ 45 // \" - \"\n#define _DOT  _ 46 // \" . \"\n#define _DIV  _ 47 // \" / \"\n#define _COL  _ 58 // \" : \"\n#define _SEM  _ 59 // \" ; \"\n#define _LES  _ 60 // \" < \"\n#define _EQU  _ 61 // \" = \"\n#define _GRE  _ 62 // \" > \"\n#define _QUE  _ 63 // \" ? \"\n#define _AT   _ 64 // \" @ \"\n#define _LBR  _ 91 // \" [ \"\n#define _ANTI _ 92 // \" \\ \"\n#define _RBR  _ 93 // \" ] \"\n#define _UND  _ 95 // \" _ \"\n\n// Uppercase letters (65-90)\n#define _A _ 65\n#define _B _ 66\n#define _C _ 67\n#define _D _ 68\n#define _E _ 69\n#define _F _ 70\n#define _G _ 71\n#define _H _ 72\n#define _I _ 73\n#define _J _ 74\n#define _K _ 75\n#define _L _ 76\n#define _M _ 77\n#define _N _ 78\n#define _O _ 79\n#define _P _ 80\n#define _Q _ 81\n#define _R _ 82\n#define _S _ 83\n#define _T _ 84\n#define _U _ 85\n#define _V _ 86\n#define _W _ 87\n#define _X _ 88\n#define _Y _ 89\n#define _Z _ 90\n\n// Lowercase letters (97-122)\n#define _a _ 97\n#define _b _ 98\n#define _c _ 99\n#define _d _ 100\n#define _e _ 101\n#define _f _ 102\n#define _g _ 103\n#define _h _ 104\n#define _i _ 105\n#define _j _ 106\n#define _k _ 107\n#define _l _ 108\n#define _m _ 109\n#define _n _ 110\n#define _o _ 111\n#define _p _ 112\n#define _q _ 113\n#define _r _ 114\n#define _s _ 115\n#define _t _ 116\n#define _u _ 117\n#define _v _ 118\n#define _w _ 119\n#define _x _ 120\n#define _y _ 121\n#define _z _ 122\n\n// Digits (48-57)\n#define _0 _ 48\n#define _1 _ 49\n#define _2 _ 50\n#define _3 _ 51\n#define _4 _ 52\n#define _5 _ 53\n#define _6 _ 54\n#define _7 _ 55\n#define _8 _ 56\n#define _9 _ 57\n\n\n/// Internal functions ///\n\n// Start\n#define _print  float d = 0.; (u.x += CHAR_SPACING\n\n// Update\n#define _       ); u.x -= CHAR_SPACING; d += _char(FONT_TEXTURE, u,\n\n// Print character\nfloat _char(sampler2D s, vec2 u, int id) {\n    vec2 p = vec2(id%16, 15. - floor(float(id)/16.));\n         p = (u + p) / 16.;\n         u = step(abs(u-.5), vec2(.5));\n    return texture(s, p).x * u.x * u.y;\n}\n\n// Floating point debug\nfloat _decimal(sampler2D FONT_TEXTURE, inout vec2 u, float n, int decimals) {\n    float d = 0., N = 1.; // d is the final color, N the number of digits before the decimal\n\n    if (n < 0.) {  // If the number is negative\n        n *= -1.;  // Make it positive\n        (0 _SUB ); // Print a minus sign\n    }\n    \n    // Calculate the number of digits before the decimal point\n    for (float x = n; x >= 10.; x /= 10.) N++;\n\n    // Print the digits before the decimal point\n    for (float i = 0.; i < N; i++) {        \n        float magnitude = pow(10., N-i-1.);\n        float leftDigit = floor(n / magnitude);\n        n -= leftDigit * magnitude;\n        \n        (0 _dig(leftDigit) );\n    }\n\n    (0 _DOT ); // Print a dot\n    \n    // Print the digits after the decimal point\n    for (int i = 0; i < decimals; i++) {\n        float firstDecimal = floor((n - floor(n)) * 10.);\n        n *= 10.;\n        \n        (0 _dig(firstDecimal) );\n    }\n    \n    return d;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// keyboard: https://www.shadertoy.com/view/lsXGzf\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst ivec2[] storeAddr = ivec2[]( P0_ADDR,P1_ADDR,P2_ADDR,P3_ADDR,P4_ADDR,P5_ADDR );\n\n// --------------------------------------------------------\n\nvoid initializeStorage(inout vec4 fragColor,vec2 fragCoord) {\n    if (storeDataAddr(fragCoord, FOCUS_ADDR)) fragColor.xyz = vec3(0.);\n    if (storeDataAddr(fragCoord, P0_ADDR)) fragColor.xyz = vec3(pData[ 0].start,pData[ 1].start,pData[ 2].start);\n    if (storeDataAddr(fragCoord, P1_ADDR)) fragColor.xyz = vec3(pData[ 3].start,pData[ 4].start,pData[ 5].start);\n    if (storeDataAddr(fragCoord, P2_ADDR)) fragColor.xyz = vec3(pData[ 6].start,pData[ 7].start,pData[ 8].start);\n    if (storeDataAddr(fragCoord, P3_ADDR)) fragColor.xyz = vec3(pData[ 9].start,pData[10].start,pData[11].start);\n    if (storeDataAddr(fragCoord, P4_ADDR)) fragColor.xyz = vec3(pData[12].start,pData[13].start,pData[14].start);\n    if (storeDataAddr(fragCoord, P5_ADDR)) fragColor.xyz = vec3(pData[15].start,0.,0.);\n}\n\n\nbool keyClick(int ascii) {\n\treturn (texture(iChannel1,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode, int stateType){\n    return bool(texelFetch(iChannel1, ivec2(keyCode, stateType), 0).x);\n}\n\n// --------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.y > 1.0) return; // skip unused storage locations\n    \n    if(iFrame < 10 || keyClick(32)) {  // reset settings on coldstart or <Spc> keypress\n        initializeStorage(fragColor, fragCoord);\n        return; \n    }\n           \n    bool resetDisplayCount = false;\n    int focus = int(fetchData(iChannel0, FOCUS_ADDR).x);\n    int focusIndex = focus / 3;  // vec3 index\n    int focusField = focus % 3;  // x,y,z field within\n\n    // always fetch current values so 'non changes' don't stomp on them \n    for(int i=0;i<6;++i)\n        if (storeDataAddr(fragCoord, storeAddr[i])) \n            fragColor = fetchData(iChannel0, storeAddr[i]);\n    \n    // lt/rt arrow alters focused variable ---------------\n    if (storeDataAddr(fragCoord, storeAddr[focusIndex])) {\n        fragColor = fetchData(iChannel0, storeAddr[focusIndex]); // current value\n        float changeAmount = 0.0;\n        \n        if(getKeyState(KEY_LEFT,0))  changeAmount = -pData[focus].delta; else\n        if(getKeyState(KEY_RIGHT,0)) changeAmount = +pData[focus].delta;\n                \n        // mouse -------------------------------\n        if(iMouse.z > 0.0) {\n            vec2 mouseEffect = (iMouse.xy - iMouse.zw) * 0.01;\n            changeAmount = mouseEffect.x * pData[focus].delta;\n        }\n        \n        fragColor[focusField] = clamp(fragColor[focusField] + changeAmount,pData[focus].vmin,pData[focus].vmax);\n    }   \n    \n    if(texelFetch( iChannel1, ivec2(KEY_LEFT,1),0 ).x > 0.0 ||\n       texelFetch( iChannel1, ivec2(KEY_RIGHT,1),0 ).x > 0.0 ||\n       iMouse.z > 0.0) resetDisplayCount = true;\n    \n    // alter focus.  update displayCount--------------------------\n    if (storeDataAddr(fragCoord, FOCUS_ADDR)) {\n        fragColor = fetchData(iChannel0, FOCUS_ADDR);\n        \n        float kym = texelFetch( iChannel1, ivec2(KEY_UP,1),0 ).x;\n        float kyp = texelFetch( iChannel1, ivec2(KEY_DOWN,1),0 ).x;\n        \n        if(kym > 0.0) { fragColor.x -= 1.0; resetDisplayCount = true; } \n        if(kyp > 0.0) { fragColor.x += 1.0; resetDisplayCount = true; }\n        \n        const float maxIndex = 15.0;\n        if(fragColor.x < 0.0) fragColor.x = maxIndex;\n        if(fragColor.x > maxIndex) fragColor.x = 0.0;\n\n        if(resetDisplayCount) fragColor.y = iFrameRate; else\n        if(--fragColor.y < 0.0) fragColor.y = 0.0;  // so widget display times out \n    }   \n      \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}