{
    "Shader": {
        "info": {
            "date": "1725831410",
            "description": "This was very unrewarding. Originally wanted a multi-scale truchet on quads with something like this in each cell (but felt unfeasible): https://www.shadertoy.com/view/Mf2fDt\n\nUsing bezier curves may have been better, it's also buggy",
            "flags": 0,
            "hasliked": 0,
            "id": "4XlcR8",
            "likes": 16,
            "name": "Quad Truchet (arcs + lines)",
            "published": 3,
            "tags": [
                "voronoi",
                "grid",
                "truchet",
                "curve",
                "quad"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 117
        },
        "renderpass": [
            {
                "code": "#define pi 3.14159\n#define R iResolution.xy\n#define ss(x) smoothstep(6./R.y, -6./R.y, x)\n#define normal(a) vec2((a).y, -(a).x)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define cro(a,b) ((a).y*(b).x - (a).x*(b).y)\n\n// from Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec2 h22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Distribute points uniformly over radius sqrt(2)/4 circle\n// to avoid delta shapes and ensure quads\nvec2 point(vec2 id, vec2 offset) \n{\n    vec2 h = h22(floor(id + offset));\n    float r = sqrt(2.) / 4. * sqrt(h.x);\n    float a = 4. * pi * h.y + iTime;\n    return r * vec2(cos(a), sin(a)) + offset;\n}\n\n// Intersect p + s*pdir and q + t*qdir lines\nvec2 intersect(vec2 p, vec2 pdir, vec2 q, vec2 qdir) \n{\n    return p + pdir * cro(q-p, qdir) / cro(pdir, qdir);\n}\n\n// seg and arc from iq:\n// https://iquilezles.org/articles/distfunctions2d/\nfloat seg( in vec2 u, in vec2 a, in vec2 b )\n{\n    vec2 pa = u-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// uv, aperture, circle radius, border radius\nfloat arc( in vec2 u, in float ap, in float ra, float rb )\n{\n    vec2 sc = vec2(sin(ap), cos(ap));\n    u.x = abs(u.x);\n    return ((sc.y*u.x>sc.x*u.y) ? length(u-sc*ra) : \n                                  abs(length(u)-ra)) - rb;\n}\n\n// Single quad cell here:\n// https://www.shadertoy.com/view/43fcRH\n\n// Messy diagram of construction here: (DONT READ THE CODE!!!)\n// https://www.shadertoy.com/view/43XyRH\nfloat corner(vec2 u, vec2 pa, vec2 pb, vec2 pd) \n{\n    // Edge midpoints\n    vec2 ab = (pa+pb)/2.,\n         bd = (pb+pd)/2.;\n    \n    // p is intersection of normals from edge midpoints\n    vec2 p = intersect(ab, normal(pb-pa), \n                       bd, normal(pd-pb));\n      \n    // Lengths from midpoints to p\n    float labp = length(ab - p),\n          lbdp = length(bd - p),\n          l = min(labp, lbdp);\n    \n    // Find equidistant points from p towards edge midpoints\n    // (either p1 or p2 will equal a midpoint)\n    vec2 p1 = p + (ab - p) * l/labp,\n         p2 = p + (bd - p) * l/lbdp;\n    \n    // Intersect bisecting line of p-p1, p-p2 with \n    // pb-pa edge or pb-pd edge (whichever it hits)\n    vec2 p3 = labp < lbdp ? pa : pd;\n    p3 = intersect(p3, pb-p3, p, (p1+p2)/2.-p);\n    \n    // Centre u at p3 and rotate so that \"up\" points towards p\n    // for arc calculation (messy but works)\n    vec2 v = u - p3;\n    float a = atan(p3.y-p.y, p3.x-p.x);\n    v *= -mat2(sin(a), -cos(a), cos(a),  sin(a));\n               \n    // Aperture of arc\n    float ap = acos(length(p3-p1) / length(p3 - p));\n    \n    float d = arc(v, ap, length(p1 - p3), 0.);\n    return min(d, min(seg(u, ab, p1), seg(u, bd, p2)));\n}\n\nvoid mainImage( out vec4 o, vec2 u )\n{\n    u = 3.*(u+u-R)/R.y + .2 * iTime;      \n    o = 0.*o;\n     \n    vec2 id = floor(u);\n    vec2 f  = fract(u) - .5;\n    \n    // Random point in each cell becomes corners of quad\n    vec2 c = point(id, vec2( 0,  0)),\n         l = point(id, vec2(-1,  0)),\n         r = point(id, vec2( 1,  0)),\n         b = point(id, vec2( 0, -1)),\n         t = point(id, vec2( 0,  1));\n     \n    // Map corners of square to opposite corners of quad\n    vec2 bl, br, tl, tr; \n     \n    // Top right becomes bottom left\n    if (cro(t-c, f-c) > 0. && cro(c-r, f-r) > 0.) {\n        o.r++;\n        bl = c;\n        br = r;\n        tl = t;\n        tr = point(id, vec2(1, 1));\n    }\n   \n    // Bottom right becomes top left\n    else if (cro(r-c, f-c) > 0. && cro(c-b, f-b) > 0.) {\n        o.g++;\n        bl = b;\n        br = point(id, vec2(1, -1));\n        tl = c;\n        tr = r;\n        id.y--;\n    }\n        \n    // Bottom left becomes top right\n    else if (cro(b-c, f-c) > 0. && cro(c-l, f-l) > 0.) {\n        o.b++;\n        bl = point(id, vec2(-1, -1));\n        br = b;\n        tl = l;\n        tr = c;\n        id--;\n    }\n\n    // Top left becomes bottom right\n    else {    \n        bl = l;\n        br = c;\n        tl = point(id, vec2(-1, 1));\n        tr = t;  \n        id.x--;\n    }\n\n    // Quad outline (mouse click)\n    float d = 1e5;\n    d = min(d, seg(f, bl, br));\n    d = min(d, seg(f, br, tr));\n    d = min(d, seg(f, tr, tl));\n    d = min(d, seg(f, tl, bl));\n    \n    // Truchet\n    float dc;\n    vec2 h = h22(id);\n    if (h.x < .5) dc = min(corner(f, tl, bl, br), corner(f, tl, tr, br));\n    else          dc = min(corner(f, bl, tl, tr), corner(f, tr, br, bl));\n\n    o = mix(.6*o, vec4(1), ss(dc - .03));\n    o = mix(o, vec4(1), .6 * ss(d-.02)); \n    \n    if (iMouse.z <= 0.) o = vec4(ss(dc - .03));\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}