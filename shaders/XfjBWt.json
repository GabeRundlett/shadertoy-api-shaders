{
    "Shader": {
        "info": {
            "date": "1725665396",
            "description": "distance functions to all standard letters (and numbers soon) in sortof the jetbrains mono font, i may improve some of them later\nyou're free to use this in your projects btw, that's why i made it ! just credit me if you can or smth",
            "flags": 0,
            "hasliked": 0,
            "id": "XfjBWt",
            "likes": 6,
            "name": "Signed Distance Font",
            "published": 3,
            "tags": [
                "sdf",
                "font",
                "alphabet",
                "ascii",
                "character",
                "letter"
            ],
            "usePreview": 0,
            "username": "dottedboxguy",
            "viewed": 275
        },
        "renderpass": [
            {
                "code": "//changing the letter is in the top of the scene function, aaaaaaaaall the way down\n\n#define PI 3.14159265359\n#define SQ2OV2 0.707106781187\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdTunnel( in vec2 p, in vec2 wh )\n{\n    p.x = abs(p.x); p.y = -p.y;\n    vec2 q = p - wh;\n\n    float d1 = dot2(vec2(max(q.x,0.0),q.y));\n    q.x = (p.y>0.0) ? q.x : length(p)-wh.x;\n    float d2 = dot2(vec2(q.x,max(q.y,0.0)));\n    float d = sqrt( min(d1,d2) );\n    \n    return (max(q.x,q.y)<0.0) ? -d : d;\n}\n\nfloat sdHalfCircle( in vec2 p, in float r, in float rb )\n{\n    p.x = abs(p.x);\n    return ((0.>p.y) ? length(vec2(p.x-r, p.y)) : \n                                  abs(length(p)-r)) - rb;\n}\n\n//kill me\n//float sdThreeEights(vec2 p, float r){\n    \n//}\n\nfloat sdVerticalCapsule( vec2 p, float h, float r ){\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r; \n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r ){\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\n//sdf is wrong if p.x>p.y\nfloat sdHalfRoundedBox(in vec2 p, in vec2 b, in vec2 r){\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    p.x=abs(p.x);\n    vec2 q = p-b+r.x;\n    return (p.y>0.)?\n        abs(min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x):\n        length(vec2(abs(p.x)-b.x, p.y));\n}\n\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\n//https://www.shadertoy.com/view/l3fcR7\nfloat sdQuarterCircle( in vec2 p, in float r, in float l, in float rb )\n{\n    return (.0>p.y||.0>p.x)?\n        length(p-((p.x>p.y)?vec2(r, -clamp(-p.y, 0., l)):vec2(-clamp(-p.x, 0., l), r)))-rb:\n        abs(length(p)-r) - rb;\n}\n\n// TODO : \n//    - remove the roundness parameter and make it a const for each individual char\n//    - finish numbers\n//    - start on special chars (so much work...)\n\nfloat sdA(vec2 p, float thickness){\n    p.x = abs(p.x);\n    const vec4 long_bar = vec4(0., .4, .175, -.3);\n    const float height_of_middle_bar = .33;\n    const vec2 middle_bar = mix(long_bar.zw, long_bar.xy, height_of_middle_bar);\n    return min(\n        sdSegment(p, long_bar.xy, long_bar.zw)-thickness,\n        sdSegment(p, middle_bar, vec2(0., middle_bar.y))-thickness);\n}\n\nfloat sdB(vec2 p, float thickness){\n    p.y=-abs(p.y-.05);\n    vec2 tunnel_size = vec2(.175);\n    p.y+=tunnel_size.x;\n    p = p.yx;\n    return abs(sdTunnel(p, tunnel_size))-thickness;\n}\n\nfloat sdC(vec2 p, float thickness){\n    p.y=abs(p.y-.05)-.175;\n    return min(\n        sdHalfCircle(p, .175, thickness), \n        sdVerticalCapsule(p+vec2(.175, .175), .175, thickness));\n}\n\nfloat sdD(vec2 p, float thickness){\n    p.y-=clamp(p.y, .0-.13125, .35-.13125);\n    return abs(sdTunnel(p.yx, vec2(.175)))-thickness;\n}\n\nfloat sdE(vec2 p, float thickness){\n    p.y-=.05;\n    p.y=abs(abs(p.y)-.175);\n    return min(\n            sdSegment(p, vec2(.175), vec2(-.175, .175)),\n            sdSegment(p, vec2(-.175, 0.), vec2(-.175, .175)))-thickness;\n}\n\nfloat sdF(vec2 pos, float thickness){\n    pos.y-=.225;\n    vec2 p = pos;\n    p.y=abs(p.y);\n    return min(\n            sdSegment(p, vec2(.175), vec2(-.175, .175)),\n            sdSegment(pos, -vec2(.175, .525), vec2(-.175, .175)))-thickness;\n}\n\nfloat sdG(vec2 pos, float thickness){\n    pos.y-=.05;\n    vec2 p = pos;\n    p.y=abs(p.y)-.175;\n    return min(min(min(\n        sdHalfCircle(p, .175, thickness), \n        sdVerticalCapsule(p+vec2(.175, .175), .175, thickness)),\n        sdVerticalCapsule(pos.yx+vec2(.0875, .0), 0.175, thickness)),\n        sdVerticalCapsule(pos+vec2(-.175, .175), .0875, thickness));\n}\n\nfloat sdH(vec2 p, float thickness){\n    p.y-=.05;\n    p=abs(p);\n    return min(\n        sdVerticalCapsule(p.yx, .175, thickness),\n        sdVerticalCapsule(p-vec2(.175, .0), .35, thickness));\n}\n\nfloat sdI(vec2 p, float thickness){\n    p.y-=.05;\n    p=abs(p);\n    return min(\n        sdVerticalCapsule(p.yx-vec2(.35, .0), .175, thickness),\n        sdVerticalCapsule(p, .35, thickness));\n}\n\nfloat sdJ(vec2 p, float thickness){\n    p.y-=.05;\n    return min(min(\n        sdHalfCircle(vec2(p.x, -.175-p.y), .175, thickness),\n        sdVerticalCapsule(p+vec2(-.175, .175), .525, thickness)),\n        sdVerticalCapsule(p.yx-vec2(.35, .0), .175, thickness));\n}\n\nfloat sdK(vec2 p, float thickness){\n    p.y-=.05;\n    p.y=abs(p.y);\n    return min(min(\n        sdVerticalCapsule(p.yx+vec2(.0, .175), .175, thickness),\n        sdVerticalCapsule(p+vec2(.175, .0), .35, thickness)),\n        sdSegment(p, vec2(.0), vec2(.175, .35))-thickness);\n}\n\nfloat sdL(vec2 p, float thickness){\n    p.y-=.05;\n    return min(\n        sdVerticalCapsule(p.yx+vec2(.35, .175), .350, thickness),\n        sdVerticalCapsule(p+vec2(.175, .35), .7, thickness));\n}\n\nfloat sdM(vec2 p, float thickness){\n    p.y-=.05;\n    p.x=abs(p.x);\n    return min(\n        sdSegment(p, vec2(.0), vec2(.175, .35))-thickness,\n        sdVerticalCapsule(p+vec2(-.175, .35), .7, thickness));\n}\n\nfloat sdN(vec2 pos, float thickness){\n    pos.y-=.05;\n    vec2 p = pos;\n    p.x=abs(p.x);\n    return min(\n        sdSegment(pos, vec2(-.175, .350), vec2(.175, -.35))-thickness,\n        sdVerticalCapsule(p+vec2(-.175, .35), .7, thickness));\n}\n\nfloat sdO(vec2 p, float thickness){\n    p.y+=.125;\n    return abs(sdVerticalCapsule(p, .35, .175))-thickness;\n}\n\nfloat sdP(vec2 p, float thickness){\n    p.y-=.05;\n    return min(\n        abs(sdTunnel(p.yx-vec2(.175, .0), vec2(.175)))-thickness,\n        sdVerticalCapsule(p+vec2(.175, .35), .35, thickness));\n}\n\nfloat sdQ(vec2 p, float thickness){\n    const vec2 tailpos = vec2(cos(-PI/3.-.2), sin(-PI/3.-.2))*.175;\n    return min(\n        sdO(p, thickness),\n        sdSegment(p, vec2(.0, -.125)+tailpos, vec2(.175, -.45))-thickness);\n}\n\nfloat sdR(vec2 p, float thickness){\n    \n    return min(\n        sdP(p, thickness), \n        sdSegment(p, vec2(.0, .05), vec2(.175, -.3))-thickness);\n}\n\nfloat sdS(vec2 pos, float thickness){\n    pos.y-=.05;\n    vec2 p = pos;\n    p.y=abs(p.y);\n    pos.y = sign(pos.x)*pos.y;\n    pos.y+=.175;\n    pos.x = abs(pos.x);\n    return min(\n        sdHalfCircle(pos, .175, thickness),\n        sdHalfCircle(p-vec2(.0, .175), .175, thickness));\n    \n}\n\nfloat sdT(vec2 p, float thickness){\n    return min(\n        sdVerticalCapsule(p+vec2(.0, .3), .7, thickness),\n        sdVerticalCapsule(p.yx+vec2(-.4, .175), .35, thickness));\n}\n\nfloat sdU(vec2 p, float thickness){\n    p.y=-p.y+.4;\n    return sdHalfRoundedBox(p, vec2(.175, .7), vec2(.175))-thickness;\n}\n\nfloat sdV(vec2 p, float thickness){\n    p.x=abs(p.x);\n    return sdSegment(p, vec2(.0, -.3), vec2(.175, .4))-thickness;\n}\n\nfloat sdW(vec2 p, float thickness){\n    p.x=abs(abs(p.x)-0.0875)+0.0875;\n    return sdSegment(p, vec2(.0875, -.3), vec2(.175, .4))-thickness;\n}\n\nfloat sdX(vec2 p, float thickness){\n    p.y-=.05;\n    p=abs(p);\n    return sdSegment(p, vec2(.0), vec2(.175, .35))-thickness;\n}\n\nfloat sdY(vec2 p, float thickness){\n    p.x=abs(p.x);\n    return min(\n        sdSegment(p, vec2(.0), vec2(.175, .4))-thickness,\n        sdVerticalCapsule(p+vec2(.0, .3), .3, thickness));\n}\n\nfloat sdZ(vec2 pos, float thickness){\n    vec2 p = pos;\n    p.y=abs(p.y-.05);\n    return min(\n        sdVerticalCapsule(p.yx-vec2(.35, -.175), .35, thickness),\n        sdSegment(pos, vec2(-.175, -.3), vec2(.175, .4))-thickness);\n}\n\nfloat sda(vec2 p, float thickness){\n    const float roundness = .125;\n    return min(\n        sdQuarterCircle(p-vec2(.0, .025), .175, .1, .0),\n        abs(sdRoundedBox(p+vec2(.0, .175), \n                         vec2(.175, .125), \n                         vec4(.0, vec3(roundness)))))-thickness;\n}\n\nfloat sdb(vec2 p, float thickness){\n    const float roundness = .125;\n    return min(\n    abs(sdRoundedBox(p+vec2(.0, .05), \n                         vec2(.175, .25), \n                         vec4(roundness)))-thickness,\n    sdVerticalCapsule(p+vec2(.175, .3), .7, thickness));\n}\n\nfloat sdc(vec2 p, float thickness){\n    const float roundness = .175;\n    p.y=abs(p.y+.05)-.075;\n    return (p.x-.175+roundness>.0)?\n        sdHalfCircle(p-.175+roundness, roundness, thickness):\n        abs(sdRoundedBox(p+vec2(.0, .075), \n                             vec2(.175, .25), \n                             vec4(roundness)))-thickness;\n}\n\nfloat sdd(vec2 p, float thickness){\n    const float roundness = .125;\n    return min(\n    abs(sdRoundedBox(p+vec2(.0, .05), \n                         vec2(.175, .25), \n                         vec4(roundness)))-thickness,\n    sdVerticalCapsule(p+vec2(-.175, .3), .7, thickness));\n}\n\nfloat sde(vec2 p, float thickness){\n    const float roundness = .125;\n    return (p.y+.0625>0.)?\n        abs(sdTunnel(p-vec2(.0,.025), vec2(.175, .0875)))-thickness:\n        min(min(min(\n            sdQuarterCircle(vec2(-p.x, -p.y-.125), .175, .0, thickness),\n            sdArc(vec2(p.x, -p.y-.125), vec2(SQ2OV2), .175, thickness)),\n            sdVerticalCapsule(p.yx+vec2(.0625, .175), .35, thickness)),\n            sdVerticalCapsule(p+vec2(.175, .125), .075, thickness));\n}\n\nfloat sdf(vec2 p, float thickness){\n    const float roundness = .125;\n    return min(min(\n        sdVerticalCapsule(p.yx+vec2(-.2, .175), .35, thickness),\n        sdQuarterCircle(vec2(-p.x, p.y-.4)+roundness, roundness, .175-roundness, thickness)),\n        sdVerticalCapsule(p+vec2(.0, .3), .525, thickness));\n}\n\nfloat sdg(vec2 p, float thickness){\n    const float roundness = .125;\n    float underbar_length = .1;\n    return min(min(\n        abs(sdRoundedBox(p+vec2(.0, .05), \n                         vec2(.175, .25), \n                         vec4(roundness)))-thickness,\n        sdQuarterCircle(vec2(p.x-.175, -.5-p.y)+roundness, roundness, .175+underbar_length-roundness, thickness)),\n        sdVerticalCapsule(p+vec2(-.175, .325), .525, thickness));\n}\n\nfloat sdh(vec2 p, float thickness){\n    const float roundness = .125;\n    return min(\n    sdVerticalCapsule(p+vec2(.175, .3), .7, thickness),\n    //sdHalfCircle(vec2(p.x-clamp(p.x, .0, .2), p.y+.3-clamp(p.y+.3, .0, .325)), .175, thickness));\n    sdHalfRoundedBox(p+vec2(.0, .3), vec2(.175, .5), vec2(roundness))-thickness);\n}\n\nfloat sdi(vec2 pos, float thickness){\n    const float roundness = .125;\n    vec2 p = pos;\n    return min(min(\n    length(pos-vec2(.0, .4))-.025-thickness,\n    sdVerticalCapsule(p+vec2(.0, .3), .5, thickness)),\n    sdVerticalCapsule(p.yx+vec2((p.y>-.05&&p.x<0.)?-.2:.3, (p.x<.0)?.175:.0), .175, thickness));\n}\n\n//very sad how many distances this one uses, but it is sadly required, not tricks possible afaik\nfloat sdj(vec2 p, float thickness){\n    float roundness = .125;\n    p.x-=.0875;\n    roundness*=2.;\n    return min(min(min(\n    length(p-vec2(.0, .4))-.025-thickness,\n    sdVerticalCapsule(p+vec2(.0, .25), .45, thickness)),\n    sdVerticalCapsule(p.yx+vec2(-.2, .2625), .2625, thickness)),\n    sdQuarterCircle(vec2(-p.y+roundness-.5, p.x+roundness), roundness, .2625-roundness, thickness));\n}\n\nfloat sdk(vec2 pos, float thickness){\n    const float roundness = .125;\n    pos.y-=.05;\n    vec2 p = pos;\n    p.y=abs(p.y+.1);\n    return min(min(\n        sdVerticalCapsule(p.yx+vec2(.0, .175), .175, thickness),\n        sdVerticalCapsule(pos+vec2(.175, .35), .7, thickness)),\n        sdSegment(p, vec2(.0), vec2(.175, .25))-thickness);\n}\n\nfloat sdl(vec2 p, float thickness){\n    const float roundness = .125;\n    p.x+=.05;\n    return min(min(\n    sdVerticalCapsule(p+vec2(.0, .075), .475, thickness),\n    sdVerticalCapsule(p.yx+vec2(-.4, .125), .125, thickness)),\n    sdQuarterCircle(vec2(-p.y+roundness-.3, -p.x+roundness), roundness, .225-roundness, thickness));\n}\n\nfloat sdm(vec2 pos, float thickness){\n    const float roundness = .125;\n    pos.y+=.05;\n    vec2 p = pos;\n    p.x = abs(p.x)-.0875;\n    p.y+=.25;\n    return min(\n    sdVerticalCapsule(pos+vec2(.175, .25), .5, thickness),\n    sdHalfRoundedBox(p, vec2(.0875, .5), vec2(roundness*.5))-thickness);\n}\n\nfloat sdn(vec2 pos, float thickness){\n    const float roundness = .125;\n    pos.y+=.05;\n    vec2 p = pos;\n    p.y+=.25;\n    return min(\n    sdVerticalCapsule(pos+vec2(.175, .25), .5, thickness),\n    sdHalfRoundedBox(p, vec2(.175, .5), vec2(roundness))-thickness);\n}\n\nfloat sdo(vec2 p, float thickness){\n    const float roundness = .125;\n    p.y+=.05;\n    return abs(sdRoundedBox(p, vec2(.175, .25), vec4(roundness)))-thickness;\n}\n\nfloat sdp(vec2 p, float thickness){\n    const float roundness = .125;\n    p.y+=.05;\n    return min(\n    abs(sdRoundedBox(p, vec2(.175, .25), vec4(roundness)))-thickness,\n    sdVerticalCapsule(p+vec2(.175, .45), .7, thickness));\n}\n\nfloat sdq(vec2 p, float thickness){\n    const float roundness = .125;\n    p.y+=.05;\n    return min(\n    abs(sdRoundedBox(p, vec2(.175, .25), vec4(roundness)))-thickness,\n    sdVerticalCapsule(p+vec2(-.175, .45), .7, thickness));\n}\n\nfloat sdr(vec2 p, float thickness){\n    const float roundness = .125;\n    p.y-=.025;\n    return min(\n    sdHalfRoundedBox(p, vec2(.175, .175), vec2(roundness))-thickness,\n    sdVerticalCapsule(p+vec2(.175, .325), .5, thickness));\n}\n\n//very funky, i don't think i like any of it\nfloat sds(vec2 pos, float thickness){\n    float roundness = .175;\n    const float arcSize = 3.5/5.; \n    roundness*=arcSize;\n    pos.y+=.05;\n    vec2 p = pos;\n    \n    bool c = pos.y>-roundness&&pos.y<roundness;\n    p.y*=sign((pos.y>-roundness&&pos.y<roundness)?pos.x:pos.y);\n    p.y+=(c)?roundness:-roundness;\n    \n    pos-=sign(pos)*vec2(.175, roundness);\n    return min(\n    sdHalfRoundedBox(p, vec2(.175, roundness), vec2(roundness))-thickness,\n    length(pos)-thickness);\n}\n\nfloat sdt(vec2 p, float thickness){\n    float roundness = .11;\n    p.x=-p.x;\n    p.x-=.05;\n    roundness*=2.;\n    return min(min(\n    sdVerticalCapsule(vec2(p.x, p.y+.0875), .4875, thickness),\n    sdVerticalCapsule(p.yx+vec2(-.2, .225), .35, thickness)),\n    sdQuarterCircle(vec2(-p.y+roundness-.3, p.x+roundness), roundness, .0, thickness));\n}\n\nfloat sdu(vec2 p, float thickness){\n    const float roundness = .125;\n    p.y=-p.y+.2;\n    return sdHalfRoundedBox(p, vec2(.175, .5), vec2(roundness))-thickness;\n}\n\nfloat sdv(vec2 p, float thickness){\n    p.x=abs(p.x);\n    return sdSegment(p, vec2(.0, -.3), vec2(.175, .2))-thickness;\n}\n\nfloat sdw(vec2 p, float thickness){\n    p.x=abs(abs(p.x)-.0875)+.0875;\n    return sdSegment(p, vec2(.0875, -.3), vec2(.175, .2))-thickness;\n}\n\nfloat sdx(vec2 p, float thickness){\n    p.y+=.05;\n    p=abs(p);\n    return sdSegment(p, vec2(.0), vec2(.175, .25))-thickness;\n}\n\nfloat sdy(vec2 p, float thickness){\n    return min(\n    sdSegment(p, vec2(.0, -.3), vec2(-.175, .2)),\n    sdSegment(p, vec2(.175, .2), vec2(-.07, -.5)))-thickness;\n}\n\nfloat sdz(vec2 pos, float thickness){\n    vec2 p = pos;\n    p.y=abs(p.y+.05);\n    return min(\n        sdVerticalCapsule(p.yx-vec2(.25, -.175), .35, thickness),\n        sdSegment(pos, vec2(-.175, -.3), vec2(.175, .2))-thickness);\n}\n\nfloat sd0(vec2 p, float thickness){\n    //you can adjust the angle to your liking\n    const vec2 tailpos = vec2(-cos(-PI/7.), sin(-PI/7.))*.175;\n    return min(\n        sdO(p, thickness),\n        sdSegment(p, vec2(.0, -.125)+tailpos, vec2(.0, .225)-tailpos)-thickness);\n}\n\nfloat sd1(vec2 p, float thickness){\n    return min(\n    sdT(-p+vec2(.0, .1), thickness),\n    sdSegment(p, vec2(.0, .4), vec2(-.175, .2))-thickness);\n}\n\n\nfloat sd2(vec2 p, float thickness){\n    // position of the segment connected to the circle\n    const vec2 tailpos = vec2(-cos(PI/5.), sin(PI/5.))*.175;\n    vec2 toppos = p - vec2(.0, .225);\n    return min(min(\n    //first two conditions say it'll calculate a half circle everywhere but the bottom right of the space\n    //third condition defines where i want to calculate a full circle instead\n    //the 4/5 factor (or .8) is derived from the ratio of pi to get a 45deg angle being pi/4, and the angle i want to make them tangent being pi/5, with the math to get the right orientation being (pi/5)/(pi/4) which ends up being 4/5. you could extend this to make something that doesn't baloon towards infinity as it nears a 90deg angle\n    (toppos.y>0.||toppos.x<0.||.8*toppos.x<-toppos.y)?\n        //i probably shouldn't use a half circle here, but it was more convenient\n        sdHalfCircle(toppos, .175, thickness):\n        abs(length(toppos)-.175)-thickness,\n    sdSegment(p, -vec2(.175, .3), vec2(.0, .225)-tailpos)-thickness),\n    sdVerticalCapsule(p.yx+vec2(.3,.175), .35, thickness));\n}\n\nfloat sd3(vec2 p, float thickness){\n    const vec2 tailpos = vec2(cos(PI/3.), -sin(PI/3.))*.175;\n    const float ratio = 5./3.;\n    vec2 toppos = vec2(-p.x, -p.y) - vec2(.0, .125);\n    return min(min(\n    (-toppos.x*ratio<toppos.y)?\n        sdHalfCircle(toppos, .175, thickness):\n        abs(length(toppos)-.175)-thickness,\n    sdSegment(p, vec2(.175, .4), vec2(.0, -.125)-tailpos)-thickness),\n    sdVerticalCapsule(p.yx+vec2(-.4,.175), .35, thickness));\n}\n\nfloat sd4(vec2 p, float thickness){\n    return min(min(\n    sdVerticalCapsule(p.yx+vec2(.125, .175), .35, thickness),\n    sdVerticalCapsule(p+vec2(-.175, .3), .35, thickness)),\n    sdSegment(p, -vec2(.175, .125), vec2(.175, .4))-thickness);\n}\n\nfloat sd5(vec2 p, float thickness){\n    vec2 circlepos = p+vec2(.0, .125);\n    circlepos = circlepos.yx;\n    circlepos.y = clamp(-circlepos.y, .0, .175)+circlepos.y;\n    return min(min(\n    sdHalfCircle(circlepos, .175, thickness),\n    sdVerticalCapsule(p+vec2(.175, -.05), .35, thickness)),\n    sdVerticalCapsule(p.yx+vec2(-.4, .175), .325, thickness));\n}\n\nfloat sd6(vec2 p, float thickness){\n    const vec2 segpos = vec2(cos(PI/6.), -sin(PI/6.))*.175;\n    return min(\n    abs(length(p+vec2(.0, .125))-.175),\n    sdSegment(p, vec2(.0, -.125)-segpos, vec2(.125, .4)))-thickness;\n}\n\nfloat sd7(vec2 p, float thickness){\n    //add the following to the min if you want a little notch hanging off the top left\n    //sdVerticalCapsule(p.xy+vec2(.175, -.3125), .0875, thickness)\n    return min(\n    sdSegment(p, -vec2(.175, .3), vec2(.175, .4))-thickness,\n    sdVerticalCapsule(p.yx+vec2(-.4, .175), .35, thickness));\n}\n\nfloat sd8(vec2 p, float thickness){\n    p.y-=.05;\n    p = abs(p)-vec2(.0, .175);\n    return abs(length(p)-.175)-thickness;\n}\n\nfloat sd9(vec2 p, float thickness){\n    p.y-=.1;\n    p=-p;\n    return sd6(p, thickness);\n}\n\nvec4 scene(in vec2 pos){\n    \n    float offset = .6;\n    float thickness = .03 + .02*cos(iTime);\n    vec2 p = pos;\n    p.y-=1.2;\n    //DO NOT LOOK, VERY BAD\n    float d = sdT(p, thickness);p.x-=offset;d=min(d, sdH(p, thickness));p.x-=offset;d=min(d, sdE(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdQ(p, thickness));p.x-=offset;d=min(d, sdU(p, thickness));p.x-=offset;d=min(d, sdI(p, thickness));p.x-=offset;d=min(d, sdC(p, thickness));p.x-=offset;d=min(d, sdK(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdB(p, thickness));p.x-=offset;d=min(d, sdR(p, thickness));p.x-=offset;d=min(d, sdO(p, thickness));p.x-=offset;d=min(d, sdW(p, thickness));p.x-=offset;d=min(d, sdN(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdF(p, thickness));p.x-=offset;d=min(d, sdO(p, thickness));p.x-=offset;d=min(d, sdX(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdJ(p, thickness));p.x-=offset;d=min(d, sdU(p, thickness));p.x-=offset;d=min(d, sdM(p, thickness));p.x-=offset;d=min(d, sdP(p, thickness));p.x-=offset;d=min(d, sdS(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdO(p, thickness));p.x-=offset;d=min(d, sdV(p, thickness));p.x-=offset;d=min(d, sdE(p, thickness));p.x-=offset;d=min(d, sdR(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdT(p, thickness));p.x-=offset;d=min(d, sdH(p, thickness));p.x-=offset;d=min(d, sdE(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdL(p, thickness));p.x-=offset;d=min(d, sdA(p, thickness));p.x-=offset;d=min(d, sdZ(p, thickness));p.x-=offset;d=min(d, sdY(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdD(p, thickness));p.x-=offset;d=min(d, sdO(p, thickness));p.x-=offset;d=min(d, sdG(p, thickness));\n    p = pos;\n    d = min(d, sdt(p, thickness));p.x-=offset;d=min(d, sdh(p, thickness));p.x-=offset;d=min(d, sde(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdq(p, thickness));p.x-=offset;d=min(d, sdu(p, thickness));p.x-=offset;d=min(d, sdi(p, thickness));p.x-=offset;d=min(d, sdc(p, thickness));p.x-=offset;d=min(d, sdk(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdb(p, thickness));p.x-=offset;d=min(d, sdr(p, thickness));p.x-=offset;d=min(d, sdo(p, thickness));p.x-=offset;d=min(d, sdw(p, thickness));p.x-=offset;d=min(d, sdn(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdf(p, thickness));p.x-=offset;d=min(d, sdo(p, thickness));p.x-=offset;d=min(d, sdx(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdj(p, thickness));p.x-=offset;d=min(d, sdu(p, thickness));p.x-=offset;d=min(d, sdm(p, thickness));p.x-=offset;d=min(d, sdp(p, thickness));p.x-=offset;d=min(d, sds(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdo(p, thickness));p.x-=offset;d=min(d, sdv(p, thickness));p.x-=offset;d=min(d, sde(p, thickness));p.x-=offset;d=min(d, sdr(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdt(p, thickness));p.x-=offset;d=min(d, sdh(p, thickness));p.x-=offset;d=min(d, sde(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdl(p, thickness));p.x-=offset;d=min(d, sda(p, thickness));p.x-=offset;d=min(d, sdz(p, thickness));p.x-=offset;d=min(d, sdy(p, thickness));p.x-=offset;p.x-=offset;d=min(d, sdd(p, thickness));p.x-=offset;d=min(d, sdo(p, thickness));p.x-=offset;d=min(d, sdg(p, thickness));\n    p = pos;\n    p.y+=1.2;\n    d = min(d, sd1(p,thickness));p.x-=offset;d = min(d, sd2(p,thickness));p.x-=offset;d = min(d, sd3(p,thickness));p.x-=offset;d = min(d, sd4(p,thickness));p.x-=offset;d = min(d, sd5(p,thickness));p.x-=offset;d = min(d, sd6(p,thickness));p.x-=offset;d = min(d, sd7(p,thickness));p.x-=offset;d = min(d, sd8(p,thickness));p.x-=offset;d = min(d, sd9(p,thickness));p.x-=offset;d = min(d, sd0(p,thickness));p.x-=offset;\n    p = pos;\n    //float d = sd9(p, .03);\n    \n    \n    float d_baseline = sdSegment(p, vec2(-.5, -.3), vec2(.5, -.3));\n    float d_decender_height = sdSegment(p, vec2(-.5, -.5), vec2(.5, -.5));\n    float d_x_height = sdSegment(p, vec2(-.5, .2), vec2(.5, .2));\n    float d_caps_height = sdSegment(p, vec2(-.5, .4), vec2(.5, .4));\n    float d_ascender_height = sdSegment(p, vec2(-.5, .5), vec2(.5, .5));\n    float d_char_width = sdSegment(abs(p), vec2(.175, .5), vec2(.175, -.5));\n    \n    //coloring taken from iq\n    vec3 color = vec3(0.);\n    float px = 2./iResolution.y;\n    color = (d>0.0) ? vec3(.9,.6,.3) : vec3(.65,.85,1.);\n    color *= 1. - exp2(-.06/px*abs(d));\n    color *= .8 + .2*cos(iResolution.x*.06*abs(d));\n    color = mix(color, vec3(1.), 1.-smoothstep(-px*12.,px*12.,abs(d)-0.005));\n    \n    //better coloring for looking at individual chars\n    //color = (d>0.0) ? vec3(.9,.6,.3) : vec3(.65,.85,1.);\n    //color *= 1. - exp2(-.09/px*abs(d));\n    //color *= .8 + .2*cos(iResolution.x*.6*abs(d));\n    //color = mix(color, vec3(1.), 1.-smoothstep(-px*1.,px*1.,abs(d)-0.005));\n    \n    \n    //debug lines i used to make the characters the same dimentions\n    //color = mix(color, vec3(1., 0., 0.), 1.-smoothstep(-px,px,abs(d_baseline)-0.005));\n    //color = mix(color, vec3(1., 0., 0.), 1.-smoothstep(-px,px,abs(d_decender_height)-0.005));\n    //color = mix(color, vec3(1., 0., 0.), 1.-smoothstep(-px,px,abs(d_x_height)-0.005));\n    //color = mix(color, vec3(1., 0., 0.), 1.-smoothstep(-px,px,abs(d_caps_height)-0.005));\n    //color = mix(color, vec3(1., 0., 0.), 1.-smoothstep(-px,px,abs(d_ascender_height)-0.005));\n    //color = mix(color, vec3(1., 0., 0.), 1.-smoothstep(-px,px,abs(d_char_width)-0.005));\n    \n    return vec4(color, d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec2 p = uv-.5;\n    m-=.5;\n    p.x = p.x*iResolution.x/iResolution.y;\n    m.x = m.x*iResolution.x/iResolution.y;\n    p.x+=.81;\n    p*=15.5;\n    m.x+=.81;\n    m*=15.5;\n    vec3 col = scene(p).xyz;\n    \n    float px = 2./iResolution.y;\n    \n    float d = scene(m).w;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, px, abs(length(p-m)-abs(d))-4.*px));\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(p, 0., 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}