{
    "Shader": {
        "info": {
            "date": "1499442774",
            "description": "Combining elements and ideas from IQ, Tomkh, Abje, Fabrice and Dr2's work to produce correct rounded Voronoi borders... Correct enough, anyway. :)",
            "flags": 0,
            "hasliked": 0,
            "id": "lsSfz1",
            "likes": 32,
            "name": "Round Voronoi Borders 2",
            "published": 3,
            "tags": [
                "voronoi",
                "round",
                "line",
                "distance",
                "bump",
                "smooth",
                "edges"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 3329
        },
        "renderpass": [
            {
                "code": "/*\n\n\tRound Voronoi Borders 2\n\t-----------------------\n\t\n\tI'd been racking my brain for ages trying to come up with a way to produce those \n\tcool-looking rounded Voronoi web lattice images in a shader. It's possible to produce \n\tcheap approximations (see my last example), but I couldn't see a way to do it \n\tcorrectly, until Abje posted a really simple solution not long ago.\n\n\tThe idea was incredibly simple: Find the distance from the cell point to the nearest \n\tedge using a \"smooth\" distance metric. That's it... I'm kicking myself. :D I think\n\tDr2 may have produced a hexagonal based variant earlier, but I haven't checked the \n\tspecifics yet.\n\n\tAnyway, all I had to do was apply it to a more generalized Voronoi example that\n\tdisplayed the correct cell point to closest edge values. IQ wrote one of those ages\n\tago, namely, \"Voronoi - distances,\" so I used a variation on that... More precisely, \n\tI used an adapted variation of Tomkh's \"Faster Voronoi Edge Distance\" example, which \n\twas based on IQ's. I've provided links to all the shaders below.\n\n\tFor anyone interested in the specifics, refer to the Voronoi function. If you're \n\tfamiliar with IQ's point to cell-edge example, it should be pretty straight forward.\n\tBy the way, I attempted to speed it up a little, but it wouldn't surprise me if I'd \n\tslowed it down instead, so if anyone knows of ways to improve it, feel free to let me\n\tknow.\n\n\tI've kept things low tech, so this is just a simple 2D bump mapped example with some\n\tadded bump-based edging. The grungy, edged, comic rendering style is a bit of a cliche. \n\tHowever, I thought it was effective in bringing out the geometry. As you can see, the \n\tlines are uniform, rounded, equiwidthed (is that a word?), and don't show any \n\tinconsistancies when a gradient or edging is applied. \n\n\tI've also produced a few hybird 2D-3D examples that I'll put up at a later date.\n\n\tAs for the comments: They're pretty rushed, so I'll tidy them up pretty soon.\n\n\n\tUses elements from the following:\n\n\t// Such a great idea. Released this with no fan fare, so it went relatively unnoticed.\n\tRound Voronoi - abje\n\thttps://www.shadertoy.com/view/ldXBDs\n\n\t// I love this example. The original from which all shaders listed here are based on.\n\tVoronoi distances - iq\n\thttps://www.shadertoy.com/view/ldl3W8\n\t// His well written article that describes the process in more detail.\n\t// https://iquilezles.org/articles/voronoilines\n\n\t// Tomkh's examples are always cleverly constructed and insightful.\n\tFaster Voronoi Edge Distance - tomkh\n\thttps://www.shadertoy.com/view/llG3zy\n\n\t// Rounded hexagonal based Voronoi. I haven't checked the specifics yet, to see how\n\t// Dr2's algorithm holds up, but it's fast, and the pattern is nicely distributed.\n\tDesert Town - dr2\n\thttps://www.shadertoy.com/view/XslBDl\n\n\n*/\n\n// Rigid scroller, which no animation, for those who require rigid metal. :)\n//#define SCROLL\n\n// Scene object ID, and individual cell IDs. Used for coloring.\nfloat objID; // The rounded web lattice, or the individual Voronoi cells.\nvec2 cellID; // Individual Voronoi cell IDs.\n\n// vec2 to vec1 hash.\nfloat hash21(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(27, 57)));\n    return fract(n*43758.5453);\n    \n    // Animated.\n    //return sin(n*6.283 + iTime)*.5 + .5;\n    \n}\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(27, 57)));\n    \n    #ifdef SCROLL\n    return fract(vec2(262144, 32768)*n)*.7; \n    #else\n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    // Note the \".45,\" insted of \".5\" that you'd expect to see. When edging, it can open \n    // up the cells ever so slightly for a more even spread. In fact, lower numbers work \n    // even better, but then the random movement would become too restricted. Zero would \n    // give you square cells.\n    return sin( p*6.2831853 + iTime )*.35 + .35; \n    #endif\n}\n\n// IQ's polynomial-based smooth minimum function.\nfloat smin( float a, float b, float k ){\n\n    float h = clamp(.5 + .5*(b - a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1. - h);\n}\n\n// Commutative smooth minimum function. Provided by Tomkh and taken from \n// Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin2(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\n// IQ's exponential-based smooth minimum function. Unlike the polynomial-based\n// smooth minimum, this one is associative and commutative.\nfloat sminExp(float a, float b, float k)\n{\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\n\n// This is a variation on a regular 2-pass Voronoi traversal that produces a Voronoi\n// pattern based on the interior cell point to the nearest cell edge (as opposed\n// to the nearest offset point). It's a slight reworking of Tomkh's example, which\n// in turn, is based on IQ's original example. The links are below:\n//\n// On a side note, I have no idea whether a faster solution is possible, but when I\n// have time, I'm going to attempt to find one anyway.\n//\n// Voronoi distances - iq\n// https://www.shadertoy.com/view/ldl3W8\n//\n// Here's IQ's well written article that describes the process in more detail.\n// https://iquilezles.org/articles/voronoilines\n//\n// Faster Voronoi Edge Distance - tomkh\n// https://www.shadertoy.com/view/llG3zy\nvec2 Voronoi(in vec2 p){\n    \n    // One of Tomkh's snippets that includes a wrap to deal with\n    // larger numbers, which is pretty cool.\n\n#if 1\n    // Slower, but handles big numbers better.\n    vec2 n = floor(p);\n    p -= n;\n    vec2 h = step(.5, p) - 1.5;\n    n += h; p -= h;\n#else\n    vec2 n = floor(p - 1.);\n    p -= n;\n#endif\n    \n    // Storage for all sixteen hash values. The same set of hash values are\n    // reused in the second pass, and since they're reasonably expensive to\n    // calculate, I figured I'd save them from resuse. However, I could be\n    // violating some kind of GPU architecture rule, so I might be making \n    // things worse... If anyone knows for sure, feel free to let me know.\n    //\n    // I've been informed that saving to an array of vectors is worse.\n    //vec2 svO[3];\n    \n    // Individual Voronoi cell ID. Used for coloring, materials, etc.\n    cellID = vec2(0); // Redundant initialization, but I've done it anyway.\n\n    // As IQ has commented, this is a regular Voronoi pass, so it should be\n    // pretty self explanatory.\n    //\n    // First pass: Regular Voronoi.\n\tvec2 mo, o;\n    \n    // Minimum distance, \"smooth\" distance to the nearest cell edge, regular\n    // distance to the nearest cell edge, and a line distance place holder.\n    float md = 8., lMd = 8., lMd2 = 8., lnDist, d;\n    \n    for( int j=0; j<3; j++ )\n    for( int i=0; i<3; i++ ){\n    \n        o = vec2(i, j);\n        o += hash22(n + o) - p;\n        // Saving the hash values for reuse in the next pass. I don't know for sure,\n        // but I've been informed that it's faster to recalculate the had values in\n        // the following pass.\n        //svO[j*3 + i] = o; \n  \n        // Regular squared cell point to nearest node point.\n        d = dot(o, o); \n\n        if( d<md ){\n            \n            md = d;  // Update the minimum distance.\n            // Keep note of the position of the nearest cell point - with respect\n            // to \"p,\" of course. It will be used in the second pass.\n            mo = o; \n            cellID = vec2(i, j) + n; // Record the cell ID also.\n        }\n       \n    }\n    \n\n    // Second pass: Distance to closest border edge. The closest edge will be one of the edges of\n    // the cell containing the closest cell point, so you need to check all surrounding edges of \n    // that cell, hence the second pass... It'd be nice if there were a faster way.\n    for( int j=0; j<3; j++ )\n    for( int i=0; i<3; i++ ){\n        \n        // I've been informed that it's faster to recalculate the hash values, rather than \n        // access an array of saved values.\n        o = vec2(i, j);\n        o += hash22(n + o) - p;\n        // I went through the trouble to save all sixteen expensive hash values in the first \n        // pass in the hope that it'd speed thing up, but due to the evolving nature of \n        // modern architecture that likes everything to be declared locally, I might be making \n        // things worse. Who knows? I miss the times when lookup tables were a good thing. :)\n        // \n        //o = svO[j*3 + i];\n        \n        // Skip the same cell... I found that out the hard way. :D\n        if( dot(o-mo, o-mo)>.00001 ){ \n            \n            // This tiny line is the crux of the whole example, believe it or not. Basically, it's\n            // a bit of simple trigonometry to determine the distance from the cell point to the\n            // cell border line. See IQ's article for a visual representation.\n            lnDist = dot( 0.5*(o+mo), normalize(o-mo));\n            \n            // Abje's addition. Border distance using a smooth minimum. Insightful, and simple.\n            //\n            // On a side note, IQ reminded me that the order in which the polynomial-based smooth\n            // minimum is applied effects the result. However, the exponentional-based smooth\n            // minimum is associative and commutative, so is more correct. In this particular case, \n            // the effects appear to be negligible, so I'm sticking with the cheaper polynomial-based \n            // smooth minimum, but it's something you should keep in mind. By the way, feel free to \n            // uncomment the exponential one and try it out to see if you notice a difference.\n            //\n            // // Polynomial-based smooth minimum.\n            lMd = smin(lMd, lnDist, .15); \n            //\n            // Exponential-based smooth minimum. By the way, this is here to provide a visual reference \n            // only, and is definitely not the most efficient way to apply it. To see the minor\n            // adjustments necessary, refer to Tomkh's example here: Rounded Voronoi Edges Analysis - \n            // https://www.shadertoy.com/view/MdSfzD\n            //lMd = sminExp(lMd, lnDist, 20.); \n            \n            // Minimum regular straight-edged border distance. If you only used this distance,\n            // the web lattice would have sharp edges.\n            lMd2 = min(lMd2, lnDist);\n        }\n\n    }\n\n    // Return the smoothed and unsmoothed distance. I think they need capping at zero... but \n    // I'm not positive.\n    return max(vec2(lMd, lMd2), 0.);\n}\n\n// Bump mapping function. The Voronoi function above returns two cell point to edge distances: \n// One is the distance using a smooth metric, and the other uses a regular metric. I wanted\n// both for aesthetic reasons. The smoothed distance is used for the web lattice, and the \n// other is used for the cell interiors. No smoothing allows the nice sharp edges to show.\n// \nfloat bumpFunc(vec2 p){ \n\n\tvec2 v = Voronoi(p*4.5); // Range: [0, 1]\n   \n    \n    /*\n    float c;\n    if(v.x<.1) {c = abs(v.x - .2); objID = 1.; }\n    else c = (v.y - .1)/(1. - .1);\n    */\n    \n    \n    float c;\n    if(v.x<.1) {c = .1 - v.x; objID = 1.; }\n    else c = max((v.y - .1)/(1. - .1), 0.);\n    \n    return c;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n  \n\n    // VECTOR SETUP - surface postion, ray origin, unit direction vector, and light postion.\n    //\n    // Setup: I find 2D bump mapping more intuitive to pretend I'm raytracing, then lighting a bump mapped plane \n    // situated at the origin. Others may disagree. :)  \n    vec3 sp = vec3(uv, 0); // Surface posion. Hit point, if you prefer. Essentially, a screen at the origin.\n    vec3 rd = normalize(vec3(uv, 1.)); // Unit direction vector. From the origin to the screen plane.\n    vec3 lp = vec3(cos(iTime)*0.5, sin(iTime)*0.2, -2.); // Light position - Back from the screen.\n\tvec3 sn = vec3(0., 0., -1); // Plane normal. Z pointing toward the viewer.\n \n\t// Scrolling.\n    #ifdef SCROLL\n    sp.x -= iTime/8.;\n    lp.x -= iTime/8.;\n    #endif\n    \n    // BUMP MAPPING - PERTURBING THE NORMAL\n    //\n    // Setting up the bump mapping variables. Normally, you'd amalgamate a lot of the following,\n    // and roll it into a single function, but I wanted to show the workings.\n    //\n    // f - Function value\n    // fx - Change in \"f\" in in the X-direction.\n    // fy - Change in \"f\" in in the Y-direction.\n    vec2 eps = vec2(2.5/iResolution.y, 0.);\n    \n    float f = bumpFunc(sp.xy); // Sample value multiplied by the amplitude. \n    \n    float svObjID = objID; // Save the scene object ID here.\n    \n    float fx = bumpFunc(sp.xy-eps.xy); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunc(sp.xy-eps.yx); // Same for the nearby sample in the Y-direction.\n  \n    float fx2 = bumpFunc(sp.xy+eps.xy); // Same for the nearby sample in the X-direction.\n    float fy2 = bumpFunc(sp.xy+eps.yx); // Same for the nearby sample in the Y-direction.\n    float edge = abs(fx+fy+fx2+fy2 - 4.*f);//abs(fx - f)+ abs(fy - f);\n    edge = smoothstep(0., 8., edge/eps.x);//sqrt(edge/eps.x*8.)\n   \n \t// Controls how much the bump is accentuated.\n\tconst float bumpFactor = 0.15;\n    \n    // Using the above to determine the dx and dy function gradients.\n    fx = (fx-f)/eps.x; // Change in X\n    fy = (fy-f)/eps.x; // Change in Y.\n    // Using the gradient vector, \"vec3(fx, fy, 0),\" to perturb the XY plane normal \",vec3(0, 0, -1).\"\n    // By the way, there's a redundant step I'm skipping in this particular case, on account of the \n    // normal only having a Z-component. Normally, though, you'd need the commented stuff below.\n    //vec3 grad = vec3(fx, fy, 0);\n    //grad -= sn*dot(sn, grad);\n    //sn = normalize( sn + grad*bumpFactor ); \n    sn = normalize( sn + vec3(fx, fy, 0)*bumpFactor );           \n   \n    \n    // LIGHTING\n    //\n\t// Determine the light direction vector, calculate its distance, then normalize it.\n\tvec3 ld = lp - sp;\n\tfloat lDist = max(length(ld), .001);\n\tld /= lDist;\n\n    // Light attenuation.    \n    float atten = 3./(1. + lDist*lDist*.15);\n    \n    // Using the bump function, \"f,\" to darken the crevices. Completely optional, but I\n    // find it gives extra depth.\n    atten *= f*.95 + .05; // Or... f*f*.7 + .3; //  pow(f, .75); // etc.\n\t\n\n\t// Diffuse value.\n\tfloat diff = max(dot(sn, ld), 0.);  \n    // Enhancing the diffuse value a bit. Made up.\n    diff = pow(diff, 4.)*.66 + pow(diff, 8.)*.34; \n    // Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 12.); \n\n\t\n    // TEXTURE COLOR\n    //\n\t// Fake tri-planar texel lookup, and by that I mean, I've moved the Z-position up by a fraction\n    // of the heightmap amount to give the impression that this is a 3D lookup. The rest is a  regular\n    // tri-planar lookup. Not sure if it made a difference, but it can't hurt.\n    vec3 nsn = max(abs(sn), .001);\n    nsn /= dot(nsn, vec3(1));\n    vec3 texCol = vec3(0), txA, txB, txC;\n    sp.z = -f*.25; // Moving the Z position out a bit - That's the fake bit.\n    txA = texture(iChannel0, sp.xy*2.).xyz;\n    txB = texture(iChannel0, sp.zx*2.).xyz;\n    txC = texture(iChannel0, sp.yz*2.).xyz;\n    // Rough sRGB to linear conversion... That's a whole other conversation. :)\n    texCol = mat3(txA*txA, txB*txB, txC*txC)*nsn.zyx; \n    \n    texCol = smoothstep(.02, .57, texCol)*3.; // Enhancing, tweaking the color, etc.\n    \n    // Individual scene coloring.\n    //\n    // The interior Voronoi cells.\n    if(svObjID<.5) {\n        \n        // A couple of random numbers. \n    \tfloat rnd = hash21(cellID); // Range: [0, 1].\n    \tfloat rnd2 = hash21(cellID + .53); // Range: [0, 1].\n\n        // Color some cells shades of gold. \n        if(rnd2>.5) texCol *= mix(vec3(1, .4, .0)*2., vec3(1), .45); // Lazy. I'll hardcode these later.\n        else texCol *=  mix(vec3(1, .7, .3)*2., vec3(1), .15);\n        \n        // Fade the cells between green and gold... I seemed like a good idea at the time. :)\n        rnd = smoothstep(0.4, .6, sin(rnd*6.283 + iTime)*.5 + .5);\n        texCol = mix(texCol, texCol*vec3(.8, 1.2, 1), rnd);\n         \n       \n    }\n    else { // The webbing. Lighten it a bit. I'll tidy up the logic later.\n        texCol *= vec3(1, .97, .92)*1.5; \n        \n    }\n    \n    // Ramp up the diffuse to make it look a little more metallic.\n    //diff = pow(diff, 2.)*1.5;\n    \n    \n    \n    // FINAL COLOR\n    // Using the values above to produce the final color.   \n    vec3 col = texCol*(diff + .25 + vec3(1., .7, .4)*spec*4.)*atten;\n\n    // Make the inner cell edging a little darker than the web edging.\n    if(svObjID < .5) col *= 1. - edge*.75;\n    else {\n        col *= 1. - edge*.65;\n        \n    }\n    \n    // Using the gradients in an odd way to give the impression of shadows.\n    col *= max(1. + (fy + fx*.5)*.125, 0.); \n    col *= smoothstep(0., .06, f) + .1; // Extra cell border darkening.\n    \n    // Evening out the highlights.\n    col = 1. - exp(-col*1.15);\n    \n    // Alternative coloring.\n    //vec3 refF = max(1. - abs(reflect(rd, sn)).xzy, 0.);\n    //col = dot(col, vec3(.299, .587, .114)) + col*pow(refF, vec3(4)).xzy*2.5;\n    \n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .25)*1.2;\n    // Colored variation... Interesting - I'll give it that much. :)\n    //col = mix(pow(min(vec3(1.5, 1, 1)*col, 1.), vec3(1, 2.5, 12.)).zyx, col, \n                    //pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125))*1.2;\n   \n\n    // Perform some statistically unlikely (but close enough) 2.0 gamma correction. :) \n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}