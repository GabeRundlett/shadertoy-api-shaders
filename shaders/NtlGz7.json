{
    "Shader": {
        "info": {
            "date": "1621794144",
            "description": "Simulation of ball shaped bodies. It solves normal and frictional impulses. There's no broad phase so the complexity is n^2. Press mouse to add explosion force.",
            "flags": 32,
            "hasliked": 0,
            "id": "NtlGz7",
            "likes": 58,
            "name": "2D Physics (balls)",
            "published": 3,
            "tags": [
                "2d",
                "collision",
                "simulation",
                "ball",
                "solver",
                "physics",
                "angular",
                "friction",
                "elasticity"
            ],
            "usePreview": 0,
            "username": "TDM",
            "viewed": 2103
        },
        "renderpass": [
            {
                "code": "/*\n * \"2D Physics (balls)\" by Alexander Alekseev aka TDM - 2021\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n *\n * Render\n */\n \n#define PIX length(fwidth(p))\nconst vec3[] COLORS = vec3[4] (\n    vec3(72, 123, 240) / 255.,\n    vec3(240, 46, 80) / 255.,\n    vec3(255, 191, 0) / 255.,\n    vec3(68, 188, 98) / 255.\n);\n\nfloat circle(vec2 p, vec2 c, float w) {\n    float dist = length(p - c) - w;\n    return smoothstep(PIX,0.0,dist);\n}\n\nfloat frame(vec2 p, vec2 size, float w) {\n    const float SMOOTH = 0.2;\n    size -= SMOOTH;\n\tp = abs(p)-size;\n    float dist = length(p-min(p,0.0)) - SMOOTH;\n    float shad = 1.0 - dist * 2.0;\n    shad = 1.0 - shad * shad * shad;\n    shad = 1.0 - (1.0 - shad) * smoothstep(0.0,PIX,dist);\n    return shad * 0.1 + 0.9;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    mouse.y = 0.0;\n    \n    vec3 c = vec3(1.0);\n    vec2 ires = 1.0 / iChannelResolution[0].xy;\n        \n    \n    // objects\n    for(int i = 0; i < NUM_OBJECTS; i++) {\n        Body body = getBody(iChannel0, ires, i);\n        float ba = circle(uv,body.pos,BALL_SIZE*0.98);\n        ba *= 1.0-circle(uv,body.pos,BALL_SIZE*0.3);\n                  \n        for(int j = 0; j < 5; j++) {\n            float ang = body.ang + float(j) * (360./5.) * DEG2RAD;\n            vec2 o = rotateZ(vec2(0.0,BALL_SIZE*1.25), ang);\n            ba *= 1.0 - circle(uv, body.pos + o, BALL_SIZE * 0.4);\n        }  \n        c = mix(c,COLORS[i%4],ba);\n    }\n    c *= frame(uv,vec2(FRAME_SIZE*1.08),0.01);\n    \n    // final\n\tfragColor = vec4(c,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n * \"2D Physics (balls)\" by Alexander Alekseev aka TDM - 2021\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com \n */\n \nconst int NUM_OBJECTS = 20;\nconst float BALL_SIZE = 0.15;\nconst float MAX_VELOCITY = 4.0;\nconst float ELASTICITY = 0.5;\nconst vec2 FRAME_SIZE = vec2(1.2,0.8);\nconst vec2 GRAVITY = vec2(0.0,-1.0);\n\nconst float PI = 3.141592;\nconst float DEG2RAD = PI / 180.0;\n\n/*\n * math\n */\n \nvec3 hash3( uint n ) {\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\nfloat cross2(vec2 a, vec2 b) {\n    return a.x * b.y - a.y * b.x;\n}\nvec2 cross2(vec2 a, float b) {\n    return vec2(a.y * b, a.x * -b);\n}\nvec2 cross2(float a, vec2 b) {\n    return vec2(b.y * -a, b.x * a);\n}\nvec2 rotateZ(vec2 v, float a) {\n    lowp vec2 sc = vec2(sin(a),cos(a));\n    lowp vec2 ret = v;\n    ret.x = v.x * sc.y - v.y * sc.x;\n    ret.y = v.x * sc.x + v.y * sc.y;\n    return ret;\n}\n\n/*\n * body\n */\n\nstruct Body {\n    vec2 pos;\n    vec2 vel;\n    float ang;\n    float ang_vel;\n    float inv_mass;\n    float inv_inertia;\n};\n\nBody getBody(sampler2D buf, vec2 ires, int i) {\n    vec4 data0 = texture(buf, (vec2(float(i),0.0) + 0.5) * ires);\n    vec4 data1 = texture(buf, (vec2(float(i),1.0) + 0.5) * ires);\n    \n    Body body;\n    body.pos = data0.xy;\n    body.vel = data0.zw;\n    body.ang = data1.x;\n    body.ang_vel = data1.y;\n    body.inv_mass = data1.z;\n    body.inv_inertia = data1.w;\n    return body;\n}\n\nvoid initBody(int id, inout Body body) {\n    vec3 rnd = hash3(uint(id));\n    body.pos = (rnd.xy * 2.0 - 1.0) * 0.4;\n    body.vel = cross2(1.0,body.pos) * 2.0;\n    body.ang_vel = length(body.pos) * -8.0;\n    body.inv_mass = 1.0;\n    body.inv_inertia = 1.0 / (0.5 * (1.0/body.inv_mass) * BALL_SIZE * BALL_SIZE);\n}\n\n/*\n * solver\n */\n\nvec2 collisionWithPlane(inout Body b0, vec3 plane) {\n    vec2 normal = normalize(plane.xy);\n    float dist = dot(b0.pos,normal) + plane.z;\n    float penetration = BALL_SIZE - dist;\n    if(penetration > 0.0) {\n        vec2 r0 = -normal * BALL_SIZE;        \n\n        // normal\n        vec2 vel0 = b0.vel + cross2(b0.ang_vel,r0);\n        vec2 rel_vel = vel0;  \n        \n        float w1 = cross2(r0,normal);\n\n        float a = (1.0 + ELASTICITY) * dot(normal,rel_vel);\n        float b = b0.inv_mass + w1 * w1 * b0.inv_inertia;\n        float lambda = max(-a / b, 0.0);\n\n        b0.vel += normal * (lambda * b0.inv_mass);\n        b0.ang_vel += cross2(r0, normal) * lambda * b0.inv_inertia;\n\n        // friction\n        vel0 = b0.vel + cross2(b0.ang_vel,r0);\n        rel_vel = vel0;  \n\n        vec2 tangent = cross2(normal,1.0);\n        w1 = cross2(r0,tangent);\n\n        a = (1.0 + ELASTICITY) * dot(tangent,rel_vel);\n        b = b0.inv_mass + w1 * w1 * b0.inv_inertia;\n        float lambdaF = clamp(-a / b, -lambda, lambda);\n\n        b0.vel += tangent * (lambdaF * b0.inv_mass);\n        b0.ang_vel += cross2(r0, tangent) * lambdaF * b0.inv_inertia;\n        \n        return normal * penetration;\n    }\n    return vec2(0.0);\n}\n\nvec2 collisionWithBody(inout Body b0, in Body b1) {\n    vec2 normal = b0.pos - b1.pos;\n    float dist = length(normal);\n    float penetration = 2.0 * BALL_SIZE - dist;\n    if(penetration > 0.0) {\n        normal /= dist;\n\n        vec2 r0 = -normal * BALL_SIZE;\n        vec2 r1 = normal * BALL_SIZE;\n        \n        // normal\n        vec2 vel0 = b0.vel + cross2(b0.ang_vel,r0);\n        vec2 vel1 = b1.vel + cross2(b1.ang_vel,r1);\n        vec2 rel_vel = vel0 - vel1;\n        \n        float w1 = cross2(r0,normal);\n        float w2 = cross2(r1,normal);\n\n        float a = (1.0 + ELASTICITY) * dot(normal,rel_vel);\n        float b = b0.inv_mass + b1.inv_mass +\n            w1 * w1 * b0.inv_inertia +\n            w2 * w2 * b1.inv_inertia;\n        float lambda = max(-a / b, 0.0);\n\n        b0.vel += normal * (lambda * b0.inv_mass);\n        b0.ang_vel += cross2(r0, normal) * lambda * b0.inv_inertia;\n        b1.vel -= normal * (lambda * b1.inv_mass);\n        b1.ang_vel -= cross2(r1, normal) * lambda * b1.inv_inertia;\n\n        // friction\n        vel0 = b0.vel + cross2(b0.ang_vel,r0);\n        vel1 = b1.vel + cross2(b1.ang_vel,r1);\n        rel_vel = vel0 - vel1;  \n\n        vec2 tangent = cross2(normal,1.0);\n        w1 = cross2(r0,tangent);\n        w2 = cross2(r1,tangent);\n\n        a = (1.0 + ELASTICITY) * dot(tangent,rel_vel);\n        b = b0.inv_mass + b1.inv_mass +\n            w1 * w1 * b0.inv_inertia +\n            w2 * w2 * b1.inv_inertia;\n        float lambdaF = clamp(-a / b, -lambda, lambda);\n\n        b0.vel += tangent * (lambdaF * b0.inv_mass);\n        b0.ang_vel += cross2(r0, tangent) * lambdaF * b0.inv_inertia;\n        \n        return normal * penetration * 0.5;\n    }\n    return vec2(0.0);\n}\n\nvoid solve(sampler2D data, inout Body b0, int id, vec2 ires) {\n    vec2 displace = vec2(0.0);\n    \n    // collision detection\n    for(int i = 0; i < NUM_OBJECTS; i++) {\n        if(i == id) continue;\n        \n        Body b1 = getBody(data, ires, i);\n        displace += collisionWithBody(b0,b1);\n    }\n    \n    // walls\n    displace += collisionWithPlane(b0, vec3(0.0,1.0,FRAME_SIZE.y));\n    displace += collisionWithPlane(b0, vec3(0.0,-1.0,FRAME_SIZE.y));\n    displace += collisionWithPlane(b0, vec3(1.0,0.0,FRAME_SIZE.x));\n    displace += collisionWithPlane(b0, vec3(-1.0,-.0,FRAME_SIZE.x));\n\n    b0.pos += displace;\n}\n\n/*\n * store\n */\n\nfloat isInside( vec2 p, vec2 c ) { \n    vec2 d = abs(p-0.5-c) - 0.5;\n    return -max(d.x,d.y);\n}\nvoid storeBody(in int id, in Body b, inout vec4 col, in vec2 uv) {\n    col = isInside(uv,vec2(float(id),0)) > 0.0 ? vec4(b.pos,b.vel) : col;\n    col = isInside(uv,vec2(float(id),1)) > 0.0 ? vec4(b.ang,b.ang_vel,b.inv_mass,b.inv_inertia) : col;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*\n * Dynamics\n */\n \nvec2 getForce(vec2 x, vec2 v) {\n    vec2 force = vec2(0.0);\n    \n    if(iMouse.z > 0.5) {\n        vec2 mouse = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n        mouse.x *= iResolution.x / iResolution.y;\n        vec2 dir = x.xy - mouse;\n        float p = length(dir);        \n        force += 5.0 * normalize(dir) / p;\n    }\n    \n    return force;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int id = int(fragCoord.x);\n    if(id >= NUM_OBJECTS) discard;\n    vec2 ires = 1.0 / iChannelResolution[0].xy;\n    \n    // load    \n    Body body = getBody(iChannel0, ires, id);\n    if(iFrame == 0) initBody(id, body); // init\n    \n    float dt = min(iTimeDelta, 0.07);\n    \n    // integrate forces\n    vec2 pvel = body.vel;\n    float pang_vel = body.ang_vel;\n    vec2 force = getForce(body.pos, body.vel);\n    body.vel += (force * body.inv_mass + GRAVITY) * dt;\n    \n    // limit max velocity\n    float len2 = dot(body.vel,body.vel);\n    if(len2 > MAX_VELOCITY * MAX_VELOCITY)\n        body.vel *= inversesqrt(len2) * MAX_VELOCITY;\n    \n    // integrate velocity\n    body.pos += (pvel + body.vel) * 0.5 * dt;\n    body.ang += (pang_vel + body.ang_vel) * 0.5 * dt;\n    \n    // store\n    fragColor = vec4(0.0);\n    storeBody(id, body, fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n * Collision solver (1st iteration)\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int id = int(fragCoord.x);\n    if(id >= NUM_OBJECTS) discard;\n    vec2 ires = 1.0 / iChannelResolution[0].xy;\n    \n    // solve collisions    \n    Body body = getBody(iChannel0, ires, id);\n    solve(iChannel0,body,id,ires);\n    \n    // store\n    fragColor = vec4(0.0);\n    storeBody(id, body, fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n * Collision solver (2nd iteration)\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int id = int(fragCoord.x);\n    if(id >= NUM_OBJECTS) discard;\n    vec2 ires = 1.0 / iChannelResolution[0].xy;\n    \n    // solve collisions    \n    Body body = getBody(iChannel0, ires, id);\n    solve(iChannel0,body,id,ires);\n    \n    // store\n    fragColor = vec4(0.0);\n    storeBody(id, body, fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}