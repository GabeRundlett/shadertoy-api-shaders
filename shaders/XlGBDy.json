{
    "Shader": {
        "info": {
            "date": "1543870200",
            "description": "This is a ray-marched GLSL implementation of the \"Here be dragons\" scene ; I'm trying to recreate/render the same 3D scene using multiple graphics techniques, frameworks and platforms. \nMore info: [url]http://simonrodriguez.fr/dragon[/url]\n",
            "flags": 0,
            "hasliked": 0,
            "id": "XlGBDy",
            "likes": 5,
            "name": "Here be dragons",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "dragon",
                "herebdedragons"
            ],
            "usePreview": 1,
            "username": "kosua20",
            "viewed": 607
        },
        "renderpass": [
            {
                "code": "/* Here be dragons, by Simon Rodriguez, 2018.\n   More details on the overall project at http://simonrodriguez.fr/dragon\n   Code for each version of the scene available at https://github.com/kosua20/herebedragons\n*/\n\n/* Uncomment to disable the soft min/max operations and use basic \n unions/intersections instead. This will speed up the compilation\n but degrade the look. */\n//#define NO_SOFT_OPS\n\n/* Comment to remove the monkey. */\n#define SHOW_MONKEY\n\n/* Comment to remove the dragon. */\n#define SHOW_DRAGON\n\n\n/* Comment to disable any texture use. */\n#define USE_TEXTURES\n\n/* Comment to remove the cloud noise in the sky. */\n#define USE_NOISE\n\n//// PI defines\n\n#define M_PI (3.14159)\n#define M_PI_2 (2.0*M_PI)\n#define M_PI_O_2 (M_PI/2.0)\n\n\n//// Transformations\n\n// vector to transform, angle *in radians* \nvec2 rotate(vec2 v, float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec2(\n        c * v.x - s * v.y,\n        s * v.x + c * v.y\n    );\n}\n\n// vector to transform, translation to apply, ZYX euler angles *in degrees*\nvec3 transform(vec3 p, vec3 t, vec3 r){\n    vec3 rP = p - t;\n    vec3 angles = M_PI/180.0 * r;\n    rP.xy = rotate(rP.xy, angles.x);\n    rP.xz = rotate(rP.xz, angles.y);\n    rP.yz = rotate(rP.yz, angles.z);\n    return rP;\n}\n\n//// Noise utilities\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec3 interpolation(vec3 x){\n    return x * x * x * (x * (x * 6.0 - 15.0) + 10.0);\n}\n\nfloat grad(vec3 corner, vec3 p){\n    // Position relative to current corner.\n    p = p - corner;\n    // \"Random\" number.\n  \tfloat t = floor(permute(permute( permute(corner.x) + corner.y) + corner.z));\n    // We use 16 gradients.\n    vec4 tmods = mod(vec4(t), vec4(16.0, 8.0, 4.0, 2.0));\n   \t// Compute dot(p, gradient)\n    float mul0 = 1.0-2.0*tmods.w;\n    float mul1 = tmods.z < 2.0 ? 1.0 : -1.0;\n    float num0 = tmods.x < 8.0 ? p.x : p.y;\n    float num1 = tmods.y < 4.0 ? p.y : p.z;\n    return mul0*num0+mul1*num1;\n}\n\nfloat pnoise(vec3 p){\n\t// Find the cube we are in.\n    vec3 base = floor(p);\n\tvec3 blend = interpolation(p - base);\n    vec2 bins = vec2(0.0,1.0);\n    // Mix between corner gradients, using the inteprolation weights.\n    float res = mix(\n    \tmix(\n        \tmix(grad(base+bins.xxx, p), grad(base+bins.yxx,p), blend.x),\n   \t\t\tmix(grad(base+bins.xyx, p), grad(base+bins.yyx,p), blend.x),\n        \tblend.y),\n    \tmix(\n        \tmix(grad(base+bins.xxy,p), grad(base+bins.yxy,p), blend.x),\n   \t\t\tmix(grad(base+bins.xyy,p), grad(base+bins.yyy,p), blend.x),\n        \tblend.y),\n        blend.z);\n\treturn res * 0.5 + 0.5;\n}\n\n\nfloat fbm(vec3 pos){\n\tfloat n;\n\tn = pnoise(pos*0.0625)*0.5;\n\tn += pnoise(pos*0.125)*0.25;\n\tn += pnoise(pos*0.25)*0.125;\n\treturn n/0.875;\n}\n\n\n//// Primitive signed distance functions.\n//// (source: IQ, https://iquilezles.org/articles/distfunctions)\n\nfloat sdSphere(vec3 p, vec3 c, float r){\n    return length(p-c) - r*r;\n}\n\nfloat sdBox(vec3 p, vec3 r){\n    vec3 d = abs(p) - (r);\n    return length(max(d, 0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdSmoothBox(vec3 p, vec3 r, float s){\n    vec3 d = abs(p) - (r - s);\n    return length(max(d, 0.0)) - s + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdPlaneH(vec3 p, float h){\n    float dist = p.y + h;\n    return max(abs(dist), 0.0);\n}\n\nfloat sdVerticalCapsule(vec3 p, float h, float r){\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat sdCone(vec3 p, float h, float r1){\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(0.0,h);\n    vec2 k2 = vec2(-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:0.0), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h){\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCylinder(vec3 p, vec2 h){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n/* pos, main radius/height, cap radius,  */\nfloat sdRoundedCylinder(vec3 p,  vec2 h, float rb){\n    vec2 d = vec2( length(p.xz)-2.0*h.x+rb, abs(p.y) - h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdTorus(vec3 p, vec2 t){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n//// Sharp boolean operators.\n\n// float min(float a, float b);\n// float max(float a, float b);\n\nvec2 mini(vec2 a, vec2 b){\n    return a.x < b.x ? a : b;\n}\n\nvec2 maxi(vec2 a, vec2 b){\n    return a.x < b.x ? b : a;\n}\n\n\n//// Soft boolean operators.\n//// (source: IQ, https://iquilezles.org/articles/smin)\n\nfloat minSoft(float a, float b, float k){\n#ifdef NO_SOFT_OPS\n    return min(a,b);\n#endif\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*h/(6.0*k*k);\n}\n\nfloat maxSoft(float a, float b, float k){\n#ifdef NO_SOFT_OPS\n    return max(a,b);\n#endif\n    float h = clamp( 0.5 - 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) + k*h*(1.0-h);\n}\n\nvec2 miniSoft(vec2 a, vec2 b, float k){\n    float s = minSoft(a.x, b.x, k);\n    return vec2(s, a.x < b.x ? a.y : b.y);\n}\n\nvec2 maxiSoft( vec2 d1, vec2 d2, float k ) {\n    float s = maxSoft( d1.x, d2.x, k);\n    return vec2(s, d1.x < d2.x ? d2.y : d1.y);\n}\n\n\n//// Helpers\n//// Generate a primitive with a custom position and orientation.\n\nfloat cylinderSmooth(vec3 p, vec3 t, vec3 r, vec2 h){\n    vec3 rP = transform(p, t, r);\n    return sdRoundedCylinder(rP, h, 0.2);\n}\n\nfloat cylinderFlat(vec3 p, vec3 t, vec3 r, vec2 h){\n    vec3 rP = transform(p, t, r);\n    return sdCylinder(rP, h);\n}\n\nfloat coneSmooth(vec3 p, vec3 t, vec3 r, vec3 h){\n    vec3 rP = transform(p, t, r);\n    return sdRoundCone(rP, h.x, h.y, h.z);\n}\n\nfloat coneFlat(vec3 p, vec3 t, vec3 r, vec2 h){\n    vec3 rP = transform(p, t, r);\n    return sdCone(rP, h.y, h.x);\n}\n\nfloat cubeFlat(vec3 p, vec3 t, vec3 r, vec3 s){\n    vec3 rP = transform(p, t, r);\n    return sdBox(rP, s);\n}\n\nfloat cubeSmooth(vec3 p, vec3 t, vec3 r, vec3 s, float m){\n    vec3 rP = transform(p, t, r);\n    return sdSmoothBox(rP, s, m);\n}\n\n\n\n//// Object signed distance functions.\n\n//// Monkey signed distance function.\n\nvec2 mapMonkey(vec3 p){\n    // The head:\n    // The main skull shape\n    float headBase = sdSphere(p, vec3(0.01, 0.2, 0.124), 0.84);\n    // Two rotated boxes for the face around the eyes\n    vec3 rP = transform(p, vec3(-0.264, 0.168, -0.574), vec3(30.6, 3.0, 14.8));\n    headBase = minSoft(headBase, sdSmoothBox(rP, vec3( 0.489, 0.368, 0.140), 0.25), 0.5);\n    rP = transform(p, vec3(0.264, 0.168, -0.574), vec3(-30.6, 177.0, -14.8));\n    headBase = minSoft(headBase, sdSmoothBox(rP, vec3( 0.489, 0.368, 0.140), 0.25), 0.5);\n    // The chin\n    headBase = minSoft(headBase, sdCylinder(p - vec3(0.0, -0.59, -0.569), vec2(0.15, 0.3)), 0.5);\n    headBase = minSoft(headBase, sdVerticalCapsule(p.yxz - vec3(-0.819, -0.1,-0.546), 0.25, 0.1), 0.5);\n    // The ears\n    vec3 earLP = transform(p, vec3(-0.844, 0.15 ,0.151), vec3(-70.7, 0.0, 0.0)); \n    vec3 earRP = transform(p, vec3(0.844, 0.15, 0.151), vec3(70.7, 180.0, 0.0));\n    float ears = min(sdRoundedCylinder(earLP , vec2(0.12, 0.25), 0.26), sdRoundedCylinder(earRP, vec2(0.12, 0.25), 0.26));\n    headBase = minSoft(headBase, ears, 0.5);\n    // Add the base material\n    vec2 monkey = vec2(headBase, 1.0);\n    \n    // The nose\n    float nose = minSoft(sdSphere(p, vec3( -0.05, -0.213, -0.748), 0.3), sdSphere(p, vec3(  0.05, -0.213, -0.748), 0.3), 0.07);\n    monkey = miniSoft(monkey, vec2(nose, 7.0), 0.07);\n    // The mouth (difference)\n    monkey = maxiSoft(monkey, vec2(-sdVerticalCapsule(p.yxz - vec3(-0.8, -0.0,-0.74), 0.1, 0.05), 5.0), 0.05);\n   \n    // The inside of the ears (difference)\n    float innerEars = min(sdRoundedCylinder(earLP + vec3(0.02, -0.15, 0.1) , vec2(0.1,0.04), 0.2), sdRoundedCylinder(earRP + vec3(0.02, -0.15, -0.1) , vec2(0.1, 0.04), 0.2));\n    monkey = maxiSoft(monkey, vec2(-innerEars, 6.0), 0.2);\n     \n    // The eyes, with their pupils and irises\n    vec2 leftEye = vec2(sdSphere(p,  vec3( -0.338, 0.228, -0.67), 0.42), 2.0);\n    vec2 rightEye = vec2(sdSphere(p,  vec3( 0.338, 0.228, -0.67), 0.42), 2.0);\n    vec2 leftEyeI = vec2(sdSphere(p, vec3( -0.338, 0.228, -0.75), 0.34), 3.0);\n    vec2 leftEyeP = vec2(sdSphere(p, vec3( -0.338, 0.228, -0.805), 0.26), 4.0);\n    vec2 rightEyeI = vec2(sdSphere(p,vec3(  0.338, 0.228, -0.75), 0.34), 3.0);\n    vec2 rightEyeP = vec2(sdSphere(p,vec3(  0.338, 0.228, -0.805), 0.26), 4.0);\n    \n    // Merge everything.\n    leftEye = mini(mini(leftEye, leftEyeI), leftEyeP);\n    rightEye = mini(mini(rightEye, rightEyeI), rightEyeP);\n    monkey = mini(mini(monkey, leftEye), rightEye);\n    return monkey;\n}\n\n//// Dragon signed distance function.\n\nvec2 mapFoot(vec3 p){\n    // The fingers.\n    float footFingers = coneSmooth(p, vec3(0.0), vec3(-0.0, 0.0, -90.0), vec3(0.12, 0.08, 0.3));\n    footFingers = min(footFingers, coneSmooth(p, vec3(0.0), vec3(-0.0, 30.0, -90.0), vec3(0.12, 0.08, 0.3)));\n    footFingers = min(footFingers, coneSmooth(p, vec3(0.0), vec3(-0.0, -30.0, -90.0), vec3(0.12, 0.08, 0.3)));\n    // The nails.\n    float footNails = coneSmooth(p, vec3(0.15, 0.0, 0.3), vec3(-0.0, 15.0, -90.0), vec3(0.07, 0.01, 0.15));\n    footNails = min(footNails, coneSmooth(p, vec3(0.0, 0.0, 0.35), vec3(-0.0, 0.0, -90.0), vec3(0.07, 0.01, 0.15)));\n    footNails = min(footNails, coneSmooth(p, vec3(-0.15, 0.0, 0.28), vec3(-0.0, -15.0, -90.0), vec3(0.07, 0.01, 0.15)));\n    // Merge and assign the proper material.\n    return mini(vec2(footFingers, 8.0), vec2(footNails, 9.0));\n}\n\nvec2 mapJaw(vec3 p){\n    // Two cylinders for the jaw itself.\n    float jawbase = cylinderFlat(p, vec3(-0.012, -0.128, -0.043), vec3(95.2, -188.0, 7.3 ), vec2(0.048, 0.323));\n    jawbase = minSoft(jawbase, cylinderFlat(p, vec3(-0.012, -0.128, 0.178), vec3(-86.0, -173.0, 172.0), vec2(0.048, 0.323)), 0.2);\n    // Add a half torus at the front.\n    vec3 rP = p - vec3(-0.32, -0.12, 0.02);\n    float jawFrontBottom = sdTorus(rP, vec2(0.12, 0.04));\n    // Cut it in half by intersecting with a box.\n    jawFrontBottom = maxSoft(jawFrontBottom, sdBox(rP + vec3(0.5, 0.0, 0.0), vec3(0.5, 1.0, 1.0)), 0.1);\n    // Merge, assign material.\n    vec2 jawBottom = vec2(minSoft(jawbase, jawFrontBottom, 0.1), 8.0);\n    // The tongue.\n    float tongue = cubeFlat(p, vec3(-0.029, -0.105, 0.067), vec3(0.0, -98.6, 0.0), vec3(0.02, 0.001,0.3));\n    // Merge with the jaw.\n    jawBottom = miniSoft(jawBottom, vec2(tongue, 5.0), 0.14) ;\n    // The teeth.\n    // Two fangs, using cones.\n    float toothBottom = coneFlat(p, vec3(-0.32, -0.058, 0.1), vec3(0.0, -25.2, 0.0), vec2(0.04, 0.08));\n    toothBottom = min(toothBottom, coneFlat(p, vec3(-0.3, -0.058, -0.05), vec3(0.0, -25.2, 0.0), vec2(0.04, 0.08)));\n    return mini(vec2(toothBottom, 6.0), jawBottom);\n}\n\nvec2 mapDragonHead(vec3 p){\n    // Bottom jaw.\n    vec2 jawBottom = mapJaw(p);\n    // Add the pointy tongue.\n    vec2 spikingTongue = vec2(coneSmooth(p, vec3(-0.30, -0.12, 0.02), vec3(-54.2, -22.9, 6.23), vec3(0.025, 0.005, 0.2)), 5.0);\n    jawBottom = miniSoft(jawBottom, spikingTongue, 0.1);\n    // Top jaw.\n    vec3 rP = p ;\n    // Flip the jaw and orient it.\n    rP.y = -rP.y;\n    rP.xy = rotate(rP.xy, -0.3);\n    vec2 jawtop = mapJaw(rP);\n    // Add the nose and chin bumps.\n    jawtop = miniSoft(jawtop, vec2(sdSphere(p, vec3(-0.3, 0.25, 0.025), 0.22), 8.0), 0.1);\n    jawBottom = miniSoft(jawBottom, vec2(sdSphere(p, vec3(-0.4, -0.2, 0.025), 0.15), 8.0), 0.15);\n    vec2 combinedHead = mini(jawBottom, jawtop);\n    // Merge both jaws with the base head.\n    float baseHead = cubeSmooth(p, vec3(0.163, 0.25, 0.1), vec3(9.41, -7.33, 0.0), vec3(0.2, 0.04, 0.15), 0.07);\n    combinedHead = miniSoft(combinedHead, vec2(baseHead, 8.0), 0.3);\n\n    // Spikes on both sides and the neck.\n    // Left spikes: a series of rounded cones.\n    float leftSpikes = coneSmooth(p, vec3(0.286, 0.236,-0.04), vec3(60.0, -29.1, -4.2), vec3(0.05, 0.01, 0.32));\n    leftSpikes = min(leftSpikes, coneSmooth(p, vec3(0.35,0.16,-0.05), vec3(82.6, -26.9, -5.0), vec3(0.056, 0.01, 0.34)));\n    leftSpikes = min(leftSpikes, coneSmooth(p, vec3(0.40,0.064,-0.09), vec3(84.1,-30.5,14.1), vec3(0.056,0.01,0.28)));\n    leftSpikes = min(leftSpikes, coneSmooth(p, vec3(0.42,-0.037,-0.12), vec3(105.0,-0.0,15.0), vec3(0.056,0.01,0.28)));\n    // Same for the right spikes.\n    float rightSpikes = coneSmooth(p, vec3(0.286, 0.236,0.22), vec3(60.0, -29.1, 0.0), vec3(0.05, 0.01, 0.32));\n    rightSpikes = min(rightSpikes, coneSmooth(p, vec3(0.35,0.16,0.23), vec3(82.6, -26.9, -15.0), vec3(0.056, 0.01, 0.34)));\n    rightSpikes = min(rightSpikes, coneSmooth(p, vec3(0.43,0.064,0.27), vec3(84.1,-20.5,-28.0), vec3(0.056,0.01,0.28)));\n    rightSpikes = min(rightSpikes, coneSmooth(p, vec3(0.44,-0.037,0.3), vec3(105.0,-10.0,-35.0), vec3(0.056,0.01,0.28)));\n    // And the center spikes.\n    float centerSpikes = coneSmooth(p, vec3(0.45,0.2,0.1), vec3(70.0,0.0,-0.0), vec3(0.06,0.02,0.5));\n    centerSpikes = min(centerSpikes, coneSmooth(p, vec3(0.58,0.3,0.1), vec3(20.0,0.0,-0.0), vec3(0.04,0.01,0.2)));\n    // Merge all spikes.\n    vec2 spikes = vec2(min(min(leftSpikes, rightSpikes), centerSpikes), 8.0);\n    // Add them to the head.\n    combinedHead = miniSoft(combinedHead, spikes, 0.1);\n    \n    // Finally the eyes.\n    float eyes = sdSphere(p, vec3(-0.07, 0.25, 0.12), 0.18);\n    eyes = min(eyes, sdSphere(p, vec3(-0.05, 0.25, -0.0), 0.18));\n    // Pupils.\n    float eyeDots = sdSphere(p, vec3(-0.09, 0.26, 0.115), 0.12);\n    eyeDots = min(eyeDots, sdSphere(p, vec3(-0.07, 0.26, -0.0), 0.12));\n    // Combine everything.\n    vec2 mergedEyes = mini(vec2(eyes, 11.0), vec2(eyeDots, 4.0));\n    return mini(combinedHead, mergedEyes);;\n}\n\nvec2 mapDragon(vec3 p){\n\t// Body: combine tori and cylinders.\n\t// Four tori, each intersected with one (or two) boxes to only keep half of it..\n    vec3 rP = p - vec3(-0.35, 0.8, -0.9);\n    float topbody = sdTorus(rP.yxz, vec2(0.35, 0.2));\n    topbody = maxSoft(topbody, sdBox(rP - vec3(0.0, 0.5, 0.0), vec3(1.0, 0.5, 1.0)), 0.15);\n    rP = p - vec3(-0.35, 0.25, -0.1);\n    float topbody1 = sdTorus(rP.yxz, vec2(0.35, 0.2));\n    topbody1 = maxSoft(topbody1, sdBox(rP + vec3(0.0, 0.5, 0.0), vec3(1.0, 0.5, 1.0)), 0.15);\n    rP = p - vec3(-0.55, 0.25, -1.45);\n    rP.xz = rotate(rP.xz, 0.6);\n    float topbody2 = sdTorus(rP.yxz, vec2(0.34, 0.2));\n    topbody2 = maxSoft(topbody2, sdBox(rP + vec3(0.0, 0.5, 0.0), vec3(1.0, 0.5, 1.0)), 0.15);\n    rP = p - vec3(-0.35, 0.8, 0.5);\n    float topbody3 = sdTorus(rP.yxz, vec2(0.34, 0.2));\n    topbody3 = maxSoft(topbody3, sdBox(rP - vec3(0.0, 0.5, 0.0), vec3(1.0, 0.5, 1.0)), 0.15);\n    topbody3 = maxSoft(topbody3, sdBox(rP - vec3(0.0, 0.5, -1.0), vec3(1.0, 0.5, 1.0)), 0.15);\n    // Merge the tori.\n    float dragonBody = topbody3;\n    dragonBody = min(topbody1, dragonBody);\n    dragonBody = min(topbody, dragonBody);\n    dragonBody = min(topbody2, dragonBody);\n    // Add junction cylinders.\n    dragonBody = minSoft(cylinderSmooth(p, vec3(-0.35,0.51,0.2), vec3(0.0, -0, 10.0), vec2(0.105, 0.25)), dragonBody, 0.1);\n    dragonBody = minSoft(cylinderSmooth(p, vec3(-0.35,0.55,-0.51), vec3(0.0, -0, 10.0), vec2(0.105, 0.25)), dragonBody, 0.1);\n    dragonBody = minSoft(cylinderSmooth(p, vec3(-0.35,0.51,-1.2), vec3(0.0, -0, 10.0), vec2(0.105, 0.25)), dragonBody, 0.1);\n    // Smooth a bit the whole body.\n    dragonBody -= 0.025;\n    // Add the tail.\n    dragonBody = minSoft(coneSmooth(p, vec3(-0.75,0.32,-1.74), vec3(30.0, -50.0, -20.0), vec3(0.18, 0.01, 0.8)), dragonBody, 0.1);\n    \n    // The end of the tail: two flat boxes rotated by 45° and merged.\n    vec3 tP = p - vec3(-0.7, 1.2, -1.6);\n    tP.xy = rotate(tP.xy, -0.7);\n    tP.yz = rotate(tP.yz, 0.4);\n    tP.xz = rotate(tP.xz, 0.4);\n    float dragonTail = sdSmoothBox(tP, vec3(0.02,0.18, 0.18), 0.04);\n    tP.yz = rotate(tP.yz, 0.6);\n    dragonTail = min(dragonTail, sdSmoothBox(tP, vec3(0.02,0.18, 0.18), 0.04));\n    // Add the end of the tail to the body.\n    float dragonMain = minSoft(dragonBody, dragonTail, 0.25);\n    \n    // Legs.\n    // The left back leg has three components because of the weird knee-spike.\n    float leftBackLeg = cylinderSmooth(p, vec3(-0.7, 0.298, -1.15), vec3(15.2, 80.0, 46.9), vec2(0.071, 0.296));\n    leftBackLeg = min(leftBackLeg, cylinderSmooth(p, vec3(-0.85, 0.2, -1.2), vec3(-5.0, 15.2, -1.0), vec2(0.071, 0.296)));\n    leftBackLeg = minSoft(leftBackLeg, coneSmooth(p, vec3(-0.85, 0.7, -1.2), vec3(20.0, 25.0, -1.0), vec3(0.09, 0.03, 0.3)), 0.1);\n    // Merge with the foot.\n    vec2 leftBackFoot = mini(mapFoot(p - vec3(-0.85, -0.2, -1.2)), vec2(leftBackLeg, 8.0));\n    \n    // Right back leg, only one cylinder needed.\n    float rightBackLeg = cylinderSmooth(p, vec3(-0.2, -0.13, -1.4), vec3(20.0, 20.0, 80.0), vec2(0.071, 0.2));\n    vec2 rightBackFoot = mini(mapFoot(p - vec3(-0.1, -0.2, -1.2)), vec2(rightBackLeg, 8.0));\n    \n    // Right front leg, two cylinders.\n    float rightFrontLeg = cylinderSmooth(p, vec3(-0.05, -0.15, -0.1), vec3(20.0, 20.0, 90.0), vec2(0.071, 0.1));\n    rightFrontLeg = min(rightFrontLeg, cylinderSmooth(p, vec3(-0.05, 0.05, -0.05), vec3(-90.0, 40.0, 90.0), vec2(0.071, 0.18)));\n    vec2 rightFrontFoot = mini(mapFoot(p - vec3(-0.0, -0.2, 0.1)), vec2(rightFrontLeg, 8.0));\n    \n    // Left front leg: two cylinders.\n    float leftFrontLeg = cylinderSmooth(p, vec3(-0.7, -0.0, -0.1), vec3(10.0, -20.0, 110.0), vec2(0.071, 0.1));\n    leftFrontLeg = min(leftFrontLeg, cylinderSmooth(p, vec3(-0.65, 0.05, -0.05), vec3(-90.0, 40.0, 90.0), vec2(0.071, 0.18)));\n    // For the left front leg, the foot is custom, to wrap it around the blue stone.\n    vec3 lP = p - vec3( -0.8, 0.05, 0.1);\n    // Fingers.\n    float leftFrontFootBase = coneSmooth(lP, vec3(0.0), vec3(-0.0, 0.0, -90.0), vec3(0.12, 0.08, 0.3));\n    leftFrontFootBase = min(leftFrontFootBase, coneSmooth(lP, vec3(0.0), vec3(-0.0, 30.0, -90.0), vec3(0.12, 0.08, 0.3)));\n    leftFrontFootBase = min(leftFrontFootBase, coneSmooth(lP, vec3(0.0), vec3(-0.0, -30.0, -100.0), vec3(0.12, 0.08, 0.3)));\n    // Nails.\n    float leftFrontFootNails = coneSmooth(lP, vec3(0.15, 0.0, 0.3), vec3(-0.0, 15.0, -150.0), vec3(0.07, 0.02, 0.15));\n    leftFrontFootNails = min(leftFrontFootNails, coneSmooth(lP, vec3(0.0, 0.0, 0.35), vec3(-0.0, 0.0, -150.0), vec3(0.07, 0.02, 0.15)));\n    leftFrontFootNails = min(leftFrontFootNails, coneSmooth(lP, vec3(-0.15, -0.08, 0.28), vec3(-0.0, -15.0, -150.0), vec3(0.07, 0.02, 0.15)));\n    // Merge the fingers and nails.\n    vec2 leftFrontFoot = vec2(min(leftFrontFootBase, leftFrontFootNails), leftFrontFootBase < leftFrontFootNails ? 8.0 : 9.0);\n    // Add the leg.\n    leftFrontFoot = miniSoft(leftFrontFoot, vec2(leftFrontLeg, 8.0), 0.1);\n    // And add a blue sphere under the foot.\n    leftFrontFoot = mini(leftFrontFoot, vec2(sdSphere(p, vec3(-0.75, -0.1, 0.3), 0.45), 10.0)); \n    // Merge all feet.\n    vec2 feetMerged = mini(mini(mini(leftBackFoot, rightBackFoot),rightFrontFoot), leftFrontFoot);\n    \n    // Finally the head.\n    vec3 headPos = p - vec3(-0.45, 1.2, 0.7);\n    headPos.xz = rotate(headPos.xz, M_PI_O_2);\n    vec2 dragonHead = mapDragonHead(headPos);\n\n    // Merge everything.\n    return miniSoft(miniSoft(vec2(dragonMain, 8.0), feetMerged, 0.2), dragonHead, 0.2);\n}\n\n//// Scene signed distance function.\n\nvec2 map(vec3 p){\n    \n    // Ground.\n    float ground = sdPlaneH(p, 1.01);\n    vec2 res = vec2(ground, 0.0);\n   \n    // Monkey.\n#ifdef SHOW_MONKEY\n    // Compute position.\n    const float monkeyScale = 0.35;\n    const vec3 monkeyShift = vec3(-1.25, -0.2, 0.25);\n    vec3 monkeyP = p - monkeyShift;\n    monkeyP /= monkeyScale;\n    // Animate the monkey.\n    monkeyP.xz = rotate(monkeyP.xz, mod(iTime, M_PI_2));\n    // Basic culling: approximate as a sphere, and use its SDF if far enough.\n    float monkeyCull = monkeyScale*(sdSphere(p, monkeyShift, 1.0) );\n    if(monkeyCull < 1.0){\n        // Get our distance to the monkey.\n        vec2 monkey = mapMonkey(monkeyP);\n        // Compensate the scaling.\n        monkey.x *= monkeyScale;\n        // Store the result if closer.\n        res = mini(res, monkey);\n    } else {\n        // Use the sphere SDF instead, adjusted so that isolines align with the full SDF isolines.\n        res = mini(res, vec2(2.0*monkeyCull + 0.57));\n    }\n#endif\n    \n    // Dragon.\n#ifdef SHOW_DRAGON\n    // Compute position.\n    const vec3 dragonShift = vec3(0.5, -0.75, 0.5);\n    vec3 dragonP = p - dragonShift;\n    // Basic culling: approximate as a sphere, and use its SDF if far enough.\n    float dragonCull = (sdSphere(dragonP, vec3(-0.3,0.5,-0.7), 1.3) );\n    if(dragonCull<1.0){\n        // Get our distance to the dragon.\n        vec2 dragon = mapDragon(dragonP);\n         // Store the result if closer.\n        res = mini(res, dragon);\n    } else {\n         // Use the sphere SDF instead, adjusted so that isolines align with the full SDF isolines.\n        res = mini(res, vec2(dragonCull));\n    }\n #endif\n    \n    return res;\n}\n\n\n\n///// Geometry helpers.\n\n// Compute the normal to the surface of the scene at a given world point.\n/*vec3 normal(vec3 p){\n    const vec2 epsilon = vec2(0.02, 0.0); //...bit agressive.\n    // Use centered finite differences scheme.\n    return normalize(vec3(\n        map(p + epsilon.xyy).x - map(p - epsilon.xyy).x,\n        map(p + epsilon.yxy).x - map(p - epsilon.yxy).x,\n        map(p + epsilon.yyx).x - map(p - epsilon.yyx).x\n    ));\n    \n}*/\n\n// Compute the normal to the surface of the scene at a given world point.\nvec3 normalCheap(vec3 p){\n    const vec2 epsilon = vec2(0.02, 0.0); //...bit agressive.\n    float dP = map(p).x;\n    // Forward differences scheme, cheaper.\n    return normalize(vec3(\n        map(p + epsilon.xyy).x - dP,\n        map(p + epsilon.yxy).x - dP,\n        map(p + epsilon.yyx).x - dP \n    ));\n}\n\n// Origin and direction of the ray, distance to the hit, last step distance and material id.\nbool raymarch(vec3 orig, vec3 dir, out float t, out vec2 res){\n    // Reset.\n    t = 0.0;\n    res = vec2(0.0);\n    // Step through the scene.\n    for(int i = 0; i < 96; ++i){\n        // Current position.\n        vec3 pos = orig + t * dir;\n        // Query the distance to the closest surface in the scene.\n        res = map(pos);\n        // Move by this distance.\n        t += res.x;\n        // If the distance to the scene is small, we have reached the surface.\n        if(res.x < 0.01){\n            return true;\n        }\n    }\n    return false;\n}\n\nconst vec3 lightDir = normalize(vec3(-1.0, 1.0, 1.0));\nconst vec3 groundTint = vec3(0.9, 0.9, 1.0);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Compute ray in view space.\n    vec2 uv = 2.0*fragCoord.xy/iResolution.xy-1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 dir = normalize(vec3(uv, 1.0));\n    vec3 eye = vec3(0.0, 0.0, -2.25);\n    // Move camera around center based on cursor position.\n    \n    float horizAngle = -iMouse.x/iResolution.x * M_PI_2 + M_PI * 1.25 + M_PI;\n    float vertAngle = M_PI_O_2 - iMouse.y/iResolution.y * (M_PI_O_2);\n\t// Hack for when the page is just loaded, so that the default viewpoint is interesting.\n\tif(iMouse.x == 0.0 && iMouse.y == 0.0){\n        horizAngle = M_PI * 1.25;\n        vertAngle = 0.0;\n    }\n    // Move eye and dir to world space.\n    eye.yz = rotate(eye.yz, vertAngle);\n    dir.yz = rotate(dir.yz, vertAngle);\n    eye.xz = rotate(eye.xz, horizAngle);\n    dir.xz = rotate(dir.xz, horizAngle);\n    \n    // Check if we intersect something along the ray.\n    float t; vec2 res;\n    bool didHit = raymarch(eye, dir, t, res);\n    \n    // Compute the color of the pixel.\n    vec3 outColor = vec3(0.0);\n    // If we hit a surface, compute it's appearance.\n    if(didHit){\n        // Compute position and normal.\n        vec3 hit = eye + t * dir;\n        vec3 n = normalCheap(hit);\n        \n        // See if the light is occluded by another surface, by marching in the light direction.\n        float tDummy; vec2 resDummy;\n        float shadowingFactor = float(raymarch(hit + 0.02*n, lightDir, tDummy, resDummy));\n\n        // Diffuse lighting.\n        float diffuse = max(dot(n, lightDir), 0.0);\n        diffuse *= (1.0-shadowingFactor);\n        // Specular lighting.\n\t\tfloat specular = max(dot(reflect(-lightDir, n), -dir), 0.0);\n        \n        vec3 baseColor = vec3(1.0,0.0,0.0);\n        if(res.y < 0.5){\n            // Plane texture.\n#ifdef USE_TEXTURES\n            float stones = texture(iChannel0, fract(hit.xz * 0.4)).r;\n#else\n            float stones = clamp(pow(2.0*pnoise(4.0*hit), 2.0), 0.0, 1.0);\n#endif\n            // When reaching the horizon, fade the texture into a unique flat color.\n            float fadingHorizon = 0.5 * clamp(length(hit) / 10.0, 0.0, 1.0) + 0.5;\n            baseColor = mix(stones, 0.2, fadingHorizon) * groundTint;\n            specular = pow(specular, 50.0);\n            \n        } else if(res.y < 1.5){\n            // Monkey skin.\n            baseColor = vec3(122.0, 86.0, 65.0)/255.0;\n\t\t\tspecular = 0.0;\n            \n        } else if(res.y < 2.5){ \n            // Monkey eye. \n            baseColor = vec3(1.0);\n\t\t\tspecular = pow(specular, 100.0);\n\n        } else if(res.y < 3.5){ \n            // Monkey eye iris.\n            baseColor = vec3(0.1, 0.4, 1.0);\n\t\t\tspecular = pow(specular, 100.0);\n\n        } else if(res.y < 4.5){ \n            // Monkey eye pupil.\n            baseColor = vec3(0.0);\n\t\t\tspecular = pow(specular, 100.0);\n\n        } else if(res.y < 5.5){ \n            // Monkey mouth.\n            baseColor = vec3(0.29, 0.12, 0.13);\n\t\t\tspecular = pow(specular, 80.0);\n\n        } else if(res.y < 6.5){ \n            // Monkey ears.\n            baseColor = vec3(227.0, 180.0, 100.0)/255.0;\n\t\t\tspecular = 0.0;\n\n        } else if(res.y < 7.5){ \n            // Monkey nose.\n            baseColor = 0.9*vec3(0.84, 0.7, 0.69);\n\t\t\tspecular = 0.0;\n            \n        } else if(res.y < 8.5){ \n            // Dragon skin.\n            // Apply some high frequency details.\n#ifdef USE_TEXTURES\n            float scales = 0.25 * texture(iChannel1, 2.0 * hit.yz).r + 0.25;\n#else\n            float scales = 0.25*pnoise(40.0*hit.yxz)+0.25;\n#endif\n            baseColor = scales * vec3(0.2, 0.9, 0.1);\n\t\t\tspecular = pow(specular, 100.0);\n\n        } else if(res.y < 9.5){ \n            // Dragon nails.\n            baseColor = vec3(0.8, 0.9, 0.5);\n\t\t\tspecular = 0.0;\n\n        } else if(res.y < 10.5){ \n            // Dragon blue stone.\n            // Apply some high frequency details.\n#ifdef USE_TEXTURES\n            float scales = texture(iChannel1, n.xy).r;\n#else\n            float scales = pnoise(30.0*hit.yxz);\n#endif\n            baseColor = scales * vec3(0.0, 0.7, 1.0);\n\t\t\tspecular = pow(specular, 100.0);\n\n        } else if(res.y < 11.5){ \n            // Dragon eye.\n            baseColor = vec3(1.0, 0.15, 0.0);\n\t\t\tspecular = pow(specular, 100.0);\n        }\n\n        //Apply diffuse and ambient shading to the base color.\n        outColor = (diffuse + 0.1) * baseColor + specular;\n  \n    } else {\n        // We haven't hit anything, it's the sky.\n        // Mix between two colors picked from the \"miramar\" cubemap.\n        // Use FBM noise based on Perlin noise.\n#ifdef USE_NOISE\n        float scale = fbm(dir*45.0);\n#else\n        float scale = clamp(dir.y+0.2, 0.0, 1.0);\n#endif\n        outColor = mix(vec3(0.24, 0.27, 0.33), 1.5*vec3(0.53, 0.67, 0.72), scale*scale);\n    }\n\n    // Output to screen, apply gamma correction.\n    fragColor = vec4(pow(outColor, vec3(1.0/2.2)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}