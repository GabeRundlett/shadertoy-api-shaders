{
    "Shader": {
        "info": {
            "date": "1574933666",
            "description": "Testing automatically orienting carved regions on a curved surface",
            "flags": 0,
            "hasliked": 0,
            "id": "wdKXWG",
            "likes": 4,
            "name": "Shifting Perforations",
            "published": 3,
            "tags": [
                "raytracing",
                "sphere"
            ],
            "usePreview": 0,
            "username": "ShnitzelKiller",
            "viewed": 461
        },
        "renderpass": [
            {
                "code": "#define FDIST 0.5\n\n//size of the windows\n#define STRIDE 0.25\n\n//radius of the sphere\n#define RADIUS 1.\n\n//depth of the holes\n#define DEPTH 0.125\n\n//offset of the holes\n//#define OFFSET -0.125\n\n\n// Raytrace sphere\nfloat sphere(in vec3 ro, in vec3 rd, in float r, out vec3 ni) {\n\tfloat pd = dot(ro, rd);\n    float disc = pd*pd + r*r - dot(ro, ro);\n    if (disc < 0.) return -1.;\n    float tdiff = sqrt(disc);\n    float tin = -pd - tdiff;\n    ni = normalize(ro + tin * rd);\n    \n    return tin;\n}\n\n\n// Raytrace box, returns (t_in, t_out)\nvec2 box(in vec3 ro, in vec3 rd, in vec3 r, out vec3 no) {\n    vec3 dr = 1.0/rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n    \n    vec3 pout =  k - n;\n    vec3 pin =  - k - n;\n    float tout = min(pout.x, min(pout.y, pout.z));\n    float tin = max(pin.x, max(pin.y, pin.z));\n    if (tin > tout) {\n        return vec2(-1.);\n    }\n    no = -sign(rd) * step(pout.xyz, pout.zxy) * step(pout.xyz, pout.yzx);\n    return vec2(tin, tout);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n\tfloat ang = iTime * 0.5;\n    vec3 eye = 1.5*vec3(cos(ang), sin(ang), 1.);\n    vec3 w = -normalize(eye);\n    vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(u*uv.x + v*uv.y + FDIST * w);\n    \n    vec3 n;\n    float t = sphere(eye, rd, RADIUS, n);\n    vec3 col;\n    \n    if (t > 0.) {\n        \n        //get offsets and cell IDs and their centroids/normals\n        vec3 ro = eye + t * rd;\n        vec3 offset = vec3(iMouse.x/iResolution.x, iTime*0.3, iMouse.y/iResolution.y);\n        ro += offset;\n        vec3 mask = 1.-step(0.9,abs(fract(ro/STRIDE)-0.5)*2.);\n        vec3 modro = fract(ro/STRIDE);\n        vec3 id = floor(ro/STRIDE);\n        ro -= offset;\n        vec3 cc = (id+0.5)*STRIDE - offset;\n        float OFFSET = length(cc) - RADIUS;\n        vec3 nn = normalize(cc);\n        vec3 sundir = normalize(vec3(1., 1., 1));\n        \n        // transform to tangent space for raytracing cavities\n        vec3 uu = normalize(cross(vec3(0., 0., 1.), nn));\n        vec3 vv = cross(nn, uu);\n        mat3 rot = mat3(uu, vv, nn);\n        mat3 rott = transpose(rot);\n        vec3 rd_inner = rott * rd;\n        vec3 ro_inner = rott * (ro-cc) + vec3(0., 0., OFFSET);\n        vec3 n_inner;\n        vec3 dims = vec3(vec2(0.3*STRIDE), DEPTH);\n        vec2 t_inner = box(ro_inner, rd_inner, dims, n_inner);\n        float fac = 1.;\n        if (t_inner.y > 0. && t_inner.x < 0. && mask.x*mask.y*mask.z > 0.5) {\n            // determine shadows\n            vec3 sundir_inner = rott * sundir;\n            vec3 n_shadow;\n            vec3 ro_shadow = ro_inner + t_inner.y * rd_inner;\n\t\t\tvec2 t_shadow = box(ro_shadow, sundir_inner, dims, n_shadow);\n            // where the shadow ray hits the cavity in world space; if it's outside the hull, no shadow\n            vec3 ro_light = cc + rot * (ro_shadow - vec3(0., 0., OFFSET) + t_shadow.y * sundir_inner);\n            fac = step(RADIUS, length(ro_light));\n            n = rot * n_inner;\n        }\n        // shade\n        fac *= max(0., dot(n, sundir));\n        float fac2= max(0., dot(n, -sundir));\n        col = fac * vec3(1., 1., 0.95) + fac2 * vec3(0.1, 0.1, 0.2);\n    } else {\n        col = vec3(0.);\n    }\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}