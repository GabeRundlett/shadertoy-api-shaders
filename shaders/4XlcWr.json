{
    "Shader": {
        "info": {
            "date": "1726061886",
            "description": "originals from shadertoy",
            "flags": 0,
            "hasliked": 0,
            "id": "4XlcWr",
            "likes": 2,
            "name": "tunnel cinema",
            "published": 3,
            "tags": [
                "fractal",
                "tunnel",
                "cinema"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 68
        },
        "renderpass": [
            {
                "code": "vec2 rot(vec2 uv,float a){\nreturn vec2(uv.x*cos(a)-uv.y*sin(a),uv.y*cos(a)+uv.x*sin(a));\n}\n\n#define iterations 15\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000\n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\nvoid mainImage(out vec4 O, vec2 I) {\n\n    float A = 1.65   * .5;\n    mat2 m = mat2(cos(A), -sin(A), sin(A), cos(A));\n    O *= 0.;\n    for(vec2 aa; aa.x < 2.; aa.x+= .70)\n    for(aa.y=0.; aa.y < 2.; aa.y+= .7) {\n        float a, k, y, i, r, f = 1.;\n        vec2 p = (I + I + aa - iResolution.xy) / iResolution.y * 8.;\n       \n        for(i = 0.; i < 13.; i++) {    \n  a = ceil(a);\n            a = (atan(p.y, p.x) / 3.14 + 1.) * .5;\n            k = log(length(p) / (sin(p.y) * .1 + 1.2)) * 1.3 - a;\n            y = fract(k);\n               \n           \n            p = p / dot(p,p);  \n               p.xy+=rot(p.xy,-iTime*0.01*i);\n            if(i <= 2. || floor(k) >= 3. || y >= .13 + i / 1e2) continue;\n            if(y >= .11) { f *= ((y - .11) / (.02 + i / 1e2)); continue; }\n           \n            r = max( abs(fract(a * 60.) - .5), abs(y - .055) / .055 );\n            if(r > .2) break;\n            if(r > .17) { f = 0.; break; }\n            f *= .55;\n        }\n\n        if(abs(y - .055) < .045)\n            O.xyz += (vec3(.2,0.2,1.20) + sin(i * vec3(0.1,1.1,2.11)) * vec3(.15,2.1,1.35)) * (1. - (i / 20.)) * f;\n    }\n    //get coords and direction\nvec2 uv=I.xy/iResolution.xy-.5;\nuv.y*=iResolution.y/iResolution.x;\nvec3 dir=vec3(uv*zoom,1.);\nfloat time=iTime*speed+.25;\n\n//mouse rotation\nfloat a1=.5+iMouse.x/iResolution.x*2.;\nfloat a2=.8+iMouse.y/iResolution.y*2.;\nmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\nmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\ndir.xz*=rot1;\ndir.xy*=rot2;\nvec3 from=vec3(1.,.5,0.5);\nfrom+=vec3(time*2.,time,-2.);\nfrom.xz*=rot1;\nfrom.xy*=rot2;\n\n//volumetric rendering\nfloat s=0.1,fade=1.;\nvec3 v=vec3(0.);\nfor (int r=0; r<volsteps; r++) {\nvec3 p=from+s*dir*.5;\np = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\nfloat pa,a=pa=0.;\nfor (int i=0; i<iterations; i++) {\np=abs(p)/dot(p,p)-formuparam; // the magic formula\na+=abs(length(p)-pa); // absolute sum of average change\npa=length(p);\n}\nfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\na*=a*a; // add contrast\nif (r>6) fade*=1.2-dm; // dark matter, don't render near\n//v+=vec3(dm,dm*.5,0.);\nv+=fade;\nv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\nfade*=distfading; // distance fading\ns+=stepsize;\n}\nv=mix(vec3(length(v)),v,saturation); //color adjust\nO*= vec4(v*.03,1.);\n    O.xyz = pow(O.xyz / 9., vec3(.45));\n   \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}