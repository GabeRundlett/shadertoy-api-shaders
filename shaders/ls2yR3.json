{
    "Shader": {
        "info": {
            "date": "1493173972",
            "description": "B-DNA with \"proteins\" traveling along them. Not exactly scientific, but fun to look at.",
            "flags": 0,
            "hasliked": 0,
            "id": "ls2yR3",
            "likes": 8,
            "name": "CRISPY Tunes",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "music",
                "dna"
            ],
            "usePreview": 0,
            "username": "wolf",
            "viewed": 1079
        },
        "renderpass": [
            {
                "code": "// Another shader kluged together from everyone else's stuff.\n// I did make the DNA distance function though...\n// (it's not too incredible, but it took awhile because I'm pretty new at this)\n// There's some jank in the way that the DNA is generated (and I did use a mod(x, 0.0))\n// but I might fix that later.\n\n// The B-DNA 5' and 3' base pairs aren't exactly aligned, but I think I'll recreate the DNA\n// to fix that.\n\n// Used techniques:\n\n// Log-Bisection Tracing by nimitz (twitter: @stormoid)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// contact: nmz at stormoid.com\n\n// iq's Raymarching Primitives\n// https://www.shadertoy.com/view/Xds3zN\n\n// Shane's Entangled Vines\n// https://www.shadertoy.com/view/MlBSDW\n\n//Max iterations and max distance\n#define ITR 200\n#define FAR 500.\n#define PRECISION 0.00008\n\n//determines how fast the root finder moves in, needs to be lowered when dealing with thin \"slices\"\n//the potential problem is the intersector crossing the function twice in one step.\n#define BASE_STRIDE .25\n\n//Used by the Hybrid marcher (if the distance from the root is high enough we use d instead of log(d)\n#define FAR_STRIDE 0.3\n\n//To cross faster, a minimum step size\n#define MIN_STEP .001\n\nconst float logvl = 1. + MIN_STEP;\n#define time iTime\n#define pi 3.1415926535\nmat2 mm2(in float a)\n{\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdSphere( vec3 p, float s)\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nfloat opU( float d1, float d2 )\n{\n  return min(d1, d2);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n// angstroms to world units\n#define ANG_TO_WORLD 0.1\n#define DNA_RADIUS 10.72 * ANG_TO_WORLD\n#define RISE 3.32 * ANG_TO_WORLD\n#define OFFSET 21.44 * ANG_TO_WORLD\n//#define ROTATION_PER_BP -0.5986479 / 3.32 / ANG_TO_WORLD\n#define ROTATION_PER_BP -0.180315633 / ANG_TO_WORLD\n#define BP_APOTHEM 3.84170 * ANG_TO_WORLD\n#define BP_WIDTH 20.01596 * ANG_TO_WORLD / 2.0\n\nvec3 opDNATwist(vec3 p, float twistFactor) // 20 angs wide\n{\n    float c = cos(ROTATION_PER_BP * p.y * twistFactor); // angs / 10\n    float s = sin(ROTATION_PER_BP * p.y * twistFactor);\n    mat2 m = mat2(c, -s, s, c); // rotation matrix\n \treturn vec3(m * p.xz, p.y);\n}\n\nfloat mapDNA(vec3 pos, float ySplit, float twistFactor, float basePairY) {\n    \n    float splitWidth = 0.2;\n    float splitOffset = exp(-pow(splitWidth * (pos.y - ySplit), 2.0)) * .9;\n    float direction = atan(pos.z, pos.x);\n    \n    vec3 split = vec3(\n        cos(direction) * splitOffset,\n        0.0,\n        sin(direction) * splitOffset\n    );\n    \n    vec3 splitOther = vec3(\n        cos(direction) * splitOffset,\n        sin(direction) * splitOffset,\n        0.0\n    );\n    \n    // dna base pair\n    float dnaBasePairs1 = sdBox(\n        opRep(\n            opDNATwist(\n                pos - vec3(0, - RISE / 2.0, 0),\n                twistFactor\n            ) + vec3(BP_APOTHEM, BP_WIDTH / 2., basePairY) + vec3(0,splitOffset,0),\n            vec3(0, 0, RISE)\n        ),\n        vec3(.07, BP_WIDTH / 2., .1)\n    );\n    \n    float dnaBasePairs2 = sdBox(\n        opRep(\n            opDNATwist(\n                pos - vec3(0, - RISE / 2.0, 0),\n                twistFactor\n            ) + vec3(BP_APOTHEM, -BP_WIDTH / 2., basePairY) - vec3(0,splitOffset,0),\n            vec3(0, 0, RISE)\n        ),\n        vec3(.07, BP_WIDTH / 2., .1)\n    );\n    \n    float strands = opU(\n        sdBox(\n            opDNATwist(\n                pos - split,\n                twistFactor\n            ) - vec3(0, DNA_RADIUS, 0),\n            vec3(.225, .125, 1e10)\n        ),\n        sdBox(\n            opDNATwist(\n                pos + vec3(0, OFFSET, 0) - split,\n                twistFactor\n            ) - vec3(0, DNA_RADIUS, 0.0),\n            vec3(.225, .125, 1e10)\n        )\n    );\n    \n    float completeBP = opU(\n        dnaBasePairs1,\n        dnaBasePairs2\n    );\n    \n    float res = opU(\n        strands,\n        completeBP\n    );\n    \n    // Get rid of color, because I'm too lazy to rewrite the base functions\n    return res;\n}\n\n#define REPEAT vec3(5, 0, 5)\n\nfloat mapProtein(vec3 pos, float yPos)\n{\n    float proteins = opS(\n        sdSphere(\n            opRep(pos, REPEAT) + vec3(0, yPos, 0),\n            DNA_RADIUS * 2.2\n        ),\n    \tsdCylinder(\n            opRep(pos, REPEAT) + vec3(0, yPos, 0),\n            vec2(DNA_RADIUS * 2., DNA_RADIUS * 2.4)\n        )\n    );\n    \n    return proteins;\n}\n\nfloat map(in vec3 pos)\n{\n    vec3 posRep = opRep(pos, REPEAT);\n    vec2 id = floor(pos.xz / REPEAT.xz);\n    \n    float direction = -(mod(floor(pos.x / REPEAT.x), 2.) * 2.0 - 1.0);\n    \n    float res = mapDNA(\n        posRep,\n        id.x == 0. && id.y == 0. ?\n        \ttime * 2.0 :\n        \tcos((id.x / 5. + id.y / 10.) * time) * 30. + time * 2.0,\n        1.,\n        direction * time * 0.5\n    );\n    \n    // add random spheres\n    float proteins = mapProtein(\n        pos,\n        id.x == 0. && id.y == 0. ?\n        \ttime * 2.0 :\n        \t-(cos((id.x / 5. + id.y / 10.) * time) * 30. + time * 2.0)\n    );\n    \n    res = opU(\n        res,\n        proteins\n    );\n    \n    \n    return res;\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    for( float t=mint; t < maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\nfloat bisect( in vec3 ro, in vec3 rd, in float near, in float far)\n{\n    float mid = 0.;\n    float sgn = sign(map(rd*near+ro));\n    for (int i = 0; i < 6; i++)\n    { \n        mid = (near + far)*.5;\n        float d = map(rd*mid+ro);\n        if (abs(d) < PRECISION) break;\n        d*sgn < 0. ? far = mid : near = mid;\n    }\n    return (near+far) * .5;\n}\n\nfloat intersect( in vec3 ro, in vec3 rd)\n{\n    float t = 0.;\n    const int itr = ITR;\n    float d = map(rd*t+ro);\n    #ifdef OPTIMIZE\n    bool sgn = (d > 0.0) ? true : false;\n    #else\n    float sgn = sign(d);\n    #endif\n    float told = t;\n    bool doBisect = false;\n    \n    for (int i=0; i<=itr; i++)\n    {\n        \n        if (abs(d) < PRECISION || t > FAR) break;\n        else if (i == itr) t = 1000.;\n            \n        //if we crossed but didn't detect, use bisection method\n        #ifdef OPTIMIZE\n        if ((d > 0.0) != sgn)\n        #else\n        if (sign(d) != sgn)\n        #endif\n        {\n            doBisect = true;\n            break;\n        }\n        \n        told = t;\n        #if 1\n        if (d > 1.)t += d * FAR_STRIDE;\n        else t += log(abs(d) + logvl) * BASE_STRIDE;\n        #else\n        t += log(abs(d) + logvl) * BASE_STRIDE;\n        #endif\n        d = map(rd * t + ro);\n    }\n    \n    if (doBisect) t = bisect(ro, rd, told, t);\n    \n    return t;\n}\n\n// Gray scale.\nfloat getGray(vec3 p)\n{\n    return p.x * 0.299 + p.y * 0.587 + p.z * 0.114;\n}\n\n// 2x2 rotation matrix.\nmat2 rot(float th)\n{\n    float cs = cos(th), sn = sin(th); return mat2(cs, -sn, sn, cs);\n}\n\nvec3 firePalette(float i)\n{\n    float T = 1600. + 1300.*i; // Temperature range (in Kelvin).\n    //vec3 L = vec3(7.4, 5.6, 4.4); // Red, green, blue wavelengths (in hundreds of nanometers).\n    //L = vec3(1.0, 5.0, 5.0);\n    //L = vec3(5.0, 1.0, iMouse.x / iResolution.x * 10.);\n    vec3 L = vec3(\n        5.0,\n        1.0,\n        (texture(iChannel0, vec2(.1, .2)).x + 0.01) * 10.\n    );\n    L = pow(L, vec3(5.0)) * (exp(1.43876719683e5 / ( T * L )) - 1.0);\n    return 1.0 - exp(-5e8 / L); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\n\n// Hash to return a scalar value from a 3D vector.\nfloat hash31(vec3 p)\n{\n    return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);\n}\n\n// Standard hash algorithm that you'll see all over the place.\nvec3 hash33(vec3 p)\n{ \n    // Faster, but doesn't disperse things quite as nicely as the block below it. However, when framerate\n    // is an issue, and it often is, this is the one to use. Basically, it's a tweaked amalgamation I put\n    // together, based on a couple of other random algorithms I've seen around... so use it with caution,\n    // because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec3(7, 157, 113)));\n    return fract(vec3(2097152, 262144, 32768)*n)*2.-1.;  \n    //p = fract(vec3(2097152, 262144, 32768)*n); \n    //return sin(p*TAU + time); // Cheap...ish animation.\n\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.01;\n  return normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n           e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n\n// Code block to produce four layers of fine mist. Not sophisticated at all.\n// If you'd like to see a much more sophisticated version, refer to Nitmitz's\n// Xyptonjtroz example. Incidently, I wrote this off the top of my head, but\n// I did have that example in mind when writing this.\nfloat trig3(in vec3 p)\n{\n    p = cos(p*2. + (cos(p.yzx) + 1. + time * 4.)*1.57);\n    return dot(p, vec3(0.1666)) + 0.5;\n}\n\n// Basic low quality noise consisting of three layers of rotated, mutated \n// trigonometric functions. Needs work, but it's OK for this example.\nfloat trigNoise3D(in vec3 p)\n{\n    // 3D transformation matrix.\n    const mat3 m3RotTheta = mat3(0.25, -0.866, 0.433, 0.9665, 0.25, -0.2455127, -0.058, 0.433, 0.899519 )*1.5;\n  \n    float res = 0.;\n\n    float t = trig3(p * pi);\n    p += (t - time * 0.25);\n    p = m3RotTheta * p;\n    //p = (p+0.7071)*1.5;\n    res += t;\n    \n    t = trig3(p * pi);\n    p += (t - time * 0.25) * 0.7071;\n    p = m3RotTheta * p;\n     //p = (p+0.7071)*1.5;\n    res += t * 0.7071;\n\n    t = trig3(p * pi);\n    res += t * 0.5;\n     \n    return res / 2.2071;\n}\n\n// Four layers of cheap trigonometric noise to produce some subtle mist.\n// Start at the ray origin, then take four samples of noise between it\n// and the surface point. Apply some very simplistic lighting along the \n// way. It's not particularly well thought out, but it doesn't have to be.\nfloat getMist(in vec3 ro, in vec3 rd, in vec3 lp, in float t)\n{\n    float mist = 0.;\n    ro += rd * t / 8.; // Edge the ray a little forward to begin.\n    \n    for (int i = 0; i < 4; i++)\n    {\n        // Lighting. Technically, a lot of these points would be\n        // shadowed, but we're ignoring that.\n        float sDi = length(lp-ro)/FAR; \n        float sAtt = min(1. / (1. + sDi * 0.25 + sDi * sDi * 0.05), 1.);\n        // Noise layer.\n        mist += trigNoise3D(ro * 2.) * sAtt;\n        // Advance the starting point towards the hit point.\n        ro += rd * t / 4.;\n    }\n    \n    // Add a little noise, then clamp, and we're done.\n    return clamp(mist / 2. + hash31(ro) * 0.1 - 0.05, 0., 1.);\n}\n\n// The iterations should be higher for proper accuracy, but in this case, the shadows are a subtle background feature, so\n// hopefully, it's not too noticeable.\nfloat softShadow(in vec3 ro, in vec3 rd, in float start, in float end, in float k)\n{\n    float shade = 1.0;\n    const int maxIterationsShad = 12; // 24 or 32 would be better. Even 16 would be good, but my computer says, \"No.\" :)\n\n    // The \"start\" value, or minimum, should be set to something more than the stop-threshold, so as to avoid a collision with \n    // the surface the ray is setting out from. It doesn't matter how many times I write shadow code, I always seem to forget this.\n    // If adding shadows seems to make everything look dark, that tends to be the problem.\n    float dist = start;\n    float stepDist = end / float(maxIterationsShad);\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i < maxIterationsShad; i++)\n    {\n        // End, or maximum, should be set to the distance from the light to surface point. If you go beyond that\n        // you may hit a surface not between the surface and the light.\n        float h = map(ro + rd * dist);\n        shade = min(shade, k * h / dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n        \n        // What h combination you add to the distance depends on speed, accuracy, etc. To be honest, I find it impossible to find \n        // the perfect balance. Faster GPUs give you more options, because more shadow iterations always produce better results.\n        // Anyway, here's some posibilities. Which one you use, depends on the situation:\n        // +=max(h, 0.001), +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\n        \n        // In this particular instance the light source is a long way away. However, we're only taking a few small steps\n        // toward the light and checking whether anything \"locally\" gets in the way. If a part of the vine a long distance away\n        // is between our hit point and the light source, it won't be accounted for. Technically that's not correct, but the local\n        // shadows give that illusion... kind of.\n        dist += clamp(h, 0.0001, .2);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if (abs(h) < 0.001 || dist > end) break; \n    }\n\n    // I usually add a bit to the final shade value, which lightens the shadow a bit. It's a preference thing. Really dark shadows \n    // look too brutal to me.\n    return min(max(shade, 0.) + 0.4, 1.0); \n}\n\n// Standard ambient occlusion. Based on the original by IQ.\nfloat calculateAO(vec3 p, vec3 n)\n{\n    const float AO_SAMPLES = 5.0;\n    float r = 0.0, w = 1.0, d;\n    \n    for (float i = 1.0; i < AO_SAMPLES + 1.1; i++)\n    {\n        d = i/AO_SAMPLES;\n        r += w*(d - map(p + n*d));\n        w *= 0.5;\n    }\n    \n    return 1.0-clamp(r, 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n  // Screen coordinates.\n  vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    // Ray origin. Traversing with time along the Z-axis.\n    vec3 ro = vec3(REPEAT.x/2. + 0.00001, time * 2., REPEAT.z/2.);\n    // for some reason adding a very small float fixes issues on linux\n    \n    // Lazy way to construct a unit direction ray.\n    vec3 rd = normalize(vec3(uv, 0.5));\n    \n    // Equally lazy way to look around the scene by rotating the unit direction vector. \n    mat2 m2 = rot(time * 0.25);\n    rd.xz *= m2;\n    rd.xy *= m2;\n    rd.yz *= m2;\n    \n\n    // The light position. In this case, it's the quasi-distant sun position, which is situated about 30 units in front\n    // of the viewing position, \"ro.\" I've arranged for it to rotate about its postion just a little.\n    // \"rd*10.\" is not realistic. No distant light source rotates around like that, but it makes the shadows move a little.\n    // Obviously, a real sun would be much, much further away, but by keeping it within a workable distance, you can\n    // get a bit of a point light effect.\n    vec3 lp = vec3(0., 0., FAR) + ro + rd * 10.;\n    \n    // Standard way to put a light in the sky. Dot the unit direction vector with the unit light direction vector.\n    // Normalize the result, then ramp up the power. In this case, I want to spread the brightness out, so a lower figure \n    // of about \"4\" is being chosen. For a more contrasty sky with intense sun, larger values are used. \n    float bgShade = pow(max(dot(rd, normalize(lp - ro)), 0.) * 0.5 + 0.5, 4.);\n    // Background (or sky) color. Blend the shade between two colors. These two aren't very inspiring, but the coloring\n    // is being done post process, so it's essentially dark to bright for now.\n    vec3 bc = mix(vec3(.0, .0, .05), vec3(1.), bgShade);\n    \n    // Initiate the scene color to the background (sky) color.\n    vec3 sc = bc;\n    \n    // Use Nimitz's really fancy raymarching algorithm. :)\n    float t = intersect(ro, rd);\n\n    \n    if(t<FAR)\n    {    \n        // Surface position.\n        vec3 sp = ro + rd * t;\n        \n        // Normal.\n        vec3 sn = normal(sp);\n        \n        // Obtain the texel color at the surface position.\n        vec3 objCol = vec3(1.0, 0.5, 0.7);\n        // Light direction vector. From the sun to the surface point.\n        vec3 ld = lp - sp;\n        \n        // Distance from the surface postion to the light source (sun position).\n        float lDist = max(length(ld), 0.001);\n        \n        ld /= lDist; // Normalize the light direct vector.\n      \n        // Attenuation, based on the distance of the light (sun) to the surface point.\n        lDist /= FAR; // Bringing the light distance down to the zero to one range, which is more workable.\n        float sAtten = min(1. / (1. + lDist * 0.125 + lDist * lDist * 0.05), 1.);\n        \n      \n        // Shadowing and occlusion. \n        float shad = softShadow(sp, ld, 0.05, FAR, 8.);\n        float ao = calculateAO(sp, sn);\n      \n        // Standard diffuse and specular calculations.\n        float diff = max(dot(sn, ld), 0.);\n        float spec = pow(max(dot(reflect(-ld, sn), -rd ), 0.0 ), 8.);\n       \n        // Combining the properties above to produce the lit color.\n        sc = (objCol*(diff + 0.5) + spec) * sAtten;\n       \n        // Applying the shadows and occlusion.\n        sc = min(sc, 1.) * shad * ao;\n        //sc = vec3(1.0, 0, 0);\n    }\n    \n    \n    // Fog.\n    //\n    // Fog - Based on distance from the viewing position. Not to be confused with the misty haze.\n    // Mix the background color (sky color above) and the object color according to a falloff value,\n    // which is analogous to fog, so we call it that. Pretty standard.\n    float fog = min(1.0 / (1. + (t * 0.25) + (t * t * 0.025)), 1.);\n    sc = mix(bc, sc, fog);\n    //sc = mix(sc, bc, smoothstep(0.0, FAR-20., t)); // Another way to mix things, but using a quick transition.\n    \n    \n    // Color post processing. Fading from orange to the original color... for no particular reason.\n    // Comment the following block out to see the original effect minus the orange.\n    vec3  sc2 = firePalette(getGray(sc));\n    float fadeFactor = min(1.0 / (1. + t), 1.); // Color fade factor. Made up to suit the conditions.\n    sc = mix(sc, sc2, fadeFactor * 0.34 + 0.66);\n    \n    \n    // Fake misty overlay.\n    //\n    // Adding the misty haze... otherwise known as the lamest volumetric effect ever. :)\n    // Start at the ray origin, then accumulate four layers between it and the hit position.\n    float mist = getMist(ro, rd, lp, t);\n    \n    // Combining the mist value, sky color (bgShade, etc) and fog to give a fog color.\n    // Part science, part made up.\n    vec3 fogCol = mix(vec3(bgShade * 0.8 + 0.2) * vec3(1., 0.85, 0.6), sc, mist * fog);\n    // Toning down the fog color. Totally made up. :)\n    sc = sc * 0.65 + fogCol * 0.35;\n     \n    \n    // Done.\n    fragColor = vec4(clamp(sc, 0., 1.), 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 19,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}