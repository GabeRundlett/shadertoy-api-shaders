{
    "Shader": {
        "info": {
            "date": "1638155013",
            "description": "For Tokyo Demo Fest 2021 GLSL Graphics Compo https://tokyodemofest.jp/",
            "flags": 0,
            "hasliked": 0,
            "id": "7lyGRt",
            "likes": 5,
            "name": "[TDF2021] Quake",
            "published": 3,
            "tags": [
                "3d",
                "fractal"
            ],
            "usePreview": 0,
            "username": "soma_arc",
            "viewed": 253
        },
        "renderpass": [
            {
                "code": "/*\nCreated by soma_arc - 2021\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                 fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nstruct Plane{\n    vec3 p1;\n    vec3 p2;\n    vec3 p3;\n    vec3 normal;\n};\n\n\nconst vec3 BLACK = vec3(0);\nconst vec3 RED = vec3(1, 0, 0);\nconst vec3 LIGHT_POS = vec3(100, 100, 100);\nconst vec3 LIGHT_DIR = normalize(LIGHT_POS);\nconst float AMBIENT_FACTOR = 0.1;\n\nconst float EPSILON = 0.001;\nconst float PI = 3.14159265;\nconst float PI_2 = 3.14159265 / 2.;\nconst float RT_3 = sqrt(3.);\nconst float RT_3_INV = 1.0 / sqrt(3.);\n\nconst Plane PL1 = Plane(vec3(0, 5, RT_3_INV),\n                vec3(1, 1, 0),\n                vec3(2, 2, -RT_3_INV),\n                normalize(vec3(RT_3 * 0.5, 0, 1.5)));\n\nconst Plane PL2 = Plane(vec3(0, 3, -RT_3_INV),\n                        vec3(1, 3, 0),\n                        vec3(2, 2, RT_3_INV),\n                        normalize(vec3(RT_3 * 0.5, 0, -1.5)));\nconst Plane PL3 = Plane(\n    vec3(-0.5, 0, 1),\n    vec3(-0.5, 1, 0),\n    vec3(-0.5, 2, 1),\n    vec3(-1, 0, 0));\n\nvec4 s2, s4, s6;\nvec4 s2A, s4A, s6A;\nvec4 s2B, s4B, s6B;\nvec4 s2C, s4C, s6C;\nvec4 gSpheres0, gSpheres1, gSpheres2, gSpheres3, gSpheres4, gSpheres5;\nvec4 inversionSphere;\n\nvec3 vertexes0, vertexes1, vertexes2, vertexes3, vertexes4,vertexes5, vertexes6, vertexes7;\nPlane dividePlane;\nvec4 convexSphere;\n\nfloat gInvNum = 0.;\nfloat gBoundingPlaneY = -9999999999.;\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 Hsv2rgb(float h, float s, float v){\n    vec3 c = vec3(h, s, v);\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid computeCubeSphairahedronA(float zb, float zc) {\n    float r2 = 0.5 + (zb * zc) / 3.0;\n    float r4 = 0.5 + (zb * zb - zb * zc) / 3.0;\n    float r6 = 0.5 + (-zb * zc + zc * zc) / 3.0;\n    s2 = s2A = vec4(1. - r2, 0, 0, r2);\n    s4 = s4A = vec4(-(1. - r4) * 0.5, zb, sqrt(3.) * (1. - r4) * 0.5, r4);\n    s6 = s6A = vec4(-(1. - r6) * 0.5, zc, -sqrt(3.) * (1. - r6) * 0.5, r6);\n    inversionSphere = vec4(-s6.x, -s6.y, s6.z, s6.w);\n}\n\nvoid computeCubeSphairahedronB(float zb, float zc) {\n    float r2 = (3. * RT_3 + 2. * RT_3 * zb * zc) / 9.0;\n    float r4 = (3. * zb * zb - 4. * zb * zc + 3.) / 9.0;\n    float r6 = (3. * zc * zc - 2. * zb * zc + 6.) / 9.0;\n    s2 = s2B = vec4((2. - RT_3 * r2) * 0.5, 0, r2 * 0.5, r2);\n    s4 = s4B = vec4(-(1. - r4) * 0.5, zb, RT_3 * (1. - r4) * 0.5, r4);\n    s6 = s6B = vec4(-(1. - r6) * 0.5, zc, -RT_3 * (1. - r6) * 0.5, r6);\n    inversionSphere = vec4(-s6.x, -s6.y, s6.z, s6.w);\n}\n\nvoid computeCubeSphairahedronC(float zb, float zc) {\n    float r2 = (zb * zb + 2. * zb * zc + 6.) / (5. * RT_3);\n    float r4 = (3. * zb * zb - 4. * zb * zc + 3.) / (5. * RT_3);\n    float r6 = (-zb * zb - 2. * zb * zc + 5. * zc * zc + 9.) / 15.0;\n    s2 = s2C = vec4((2. - RT_3 * r2) * 0.5, 0, r2 * 0.5, r2);\n    s4 = s4C = vec4(-0.5, zb, RT_3 / 2. - r4, r4);\n    s6 = s6C = vec4(-(1. - r6) * 0.5, zc, -RT_3 * (1. - r6) * 0.5, r6);\n    inversionSphere = vec4(-s6.x, -s6.y, s6.z, s6.w);\n}\n\n\nfloat MAX_FLOAT = 1e20;\nconst float THRESHOLD = 0.001;\n\nbool intersectBoundingPlane(const vec3 n, const vec3 p,\n\t\t\t\t\t\t\tconst vec3 rayOrigin, const vec3 rayDir,\n\t\t\t\t\t\t\tinout float t0, inout float t1) {\n\tfloat d = -dot(p, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(THRESHOLD < t){\n\t\tif(v < 0.) {\n\t\t\tt0 = max(t, t0);\n\t\t\tt1 = MAX_FLOAT;\n\t\t} else {\n\t\t\tt0 = t0;\n\t\t\tt1 = t;\n\t\t}\n\t\treturn true;\n    }\n    t0 = t0;\n    t1 = MAX_FLOAT;\n\treturn (v < 0.);\n}\n\n/*\nfloat[12] pivoting(float[12] mat, int n, int k){\n    int col = k;\n    float maxValue = abs(mat[k*4 + k]);\n    for (int i = k + 1; i < n; i++) {\n        if (abs(mat[i*4 + k]) > maxValue) {\n            col = i;\n            maxValue = abs(mat[i*4 + k]);\n        }\n    }\n    if (k != col) {\n        float tmp[4];\n        tmp[0] = mat[col*4 + 0];\n        tmp[1] = mat[col*4 + 1];\n        tmp[2] = mat[col*4 + 2];\n        tmp[3] = mat[col*4 + 3];\n        mat[col*4 + 0] = mat[k*4 + 0];\n        mat[col*4 + 1] = mat[k*4 + 1];\n        mat[col*4 + 2] = mat[k*4 + 2];\n        mat[col*4 + 3] = mat[k*4 + 3];\n        mat[k*4 + 0] = tmp[0];\n        mat[k*4 + 1] = tmp[1];\n        mat[k*4 + 2] = tmp[2];\n        mat[k*4 + 3] = tmp[3];\n    }\n    return mat;\n}\n*/\n\nvec4 sphereFromPoints(vec3 p0, vec3 p1, vec3 p2, vec3 p3){\n    /*\n    float coefficient[12];\n    for (int i = 0; i < 3; i++) {\n        coefficient[i * 4 + 0] = 2. * (p[i + 1].x - p[i].x);\n        coefficient[i * 4 + 1] = 2. * (p[i + 1].y - p[i].y);\n        coefficient[i * 4 + 2] = 2. * (p[i + 1].z - p[i].z);\n        coefficient[i * 4 + 3] = -(pow(p[i].x, 2.) + pow(p[i].y, 2.) + pow(p[i].z, 2.)) +\n                pow(p[i + 1].x, 2.) + pow(p[i + 1].y, 2.) + pow(p[i + 1].z, 2.);\n    }\n    */\n    float coefficient0, coefficient1, coefficient2, coefficient3, coefficient4;\n    float coefficient5, coefficient6, coefficient7, coefficient8, coefficient9;\n    float coefficient10, coefficient11;\n    coefficient0 = 2. * (p1.x - p0.x);\n    coefficient1 = 2. * (p1.y - p0.y);\n    coefficient2 = 2. * (p1.z - p0.z);\n    coefficient3 = -(pow(p0.x, 2.) + pow(p0.y, 2.) + pow(p0.z, 2.)) +\n                     pow(p1.x, 2.) + pow(p1.y, 2.) + pow(p1.z, 2.);\n    coefficient4 = 2. * (p2.x - p1.x);\n    coefficient5 = 2. * (p2.y - p1.y);\n    coefficient6 = 2. * (p2.z - p1.z);\n    coefficient7 = -(pow(p1.x, 2.) + pow(p1.y, 2.) + pow(p1.z, 2.)) +\n                     pow(p2.x, 2.) + pow(p2.y, 2.) + pow(p2.z, 2.);\n    coefficient8 = 2. * (p3.x - p2.x);\n    coefficient9 = 2. * (p3.y - p2.y);\n    coefficient10 = 2. * (p3.z - p2.z);\n    coefficient11 = -(pow(p2.x, 2.) + pow(p2.y, 2.) + pow(p2.z, 2.)) +\n                      pow(p3.x, 2.) + pow(p3.y, 2.) + pow(p3.z, 2.);\n    \n    /*\n    const int n = 3;\n    for (int k = 0; k < n - 1; k++) {\n        coefficient = pivoting(coefficient, n, k);\n\n        float vkk = coefficient[k * 4 + k];\n        for (int i = k + 1; i < n; i++) {\n            float vik = coefficient[i * 4 + k];\n            for (int j = k; j < n + 1; ++j) {\n                coefficient[i * 4 + j] = coefficient[i*4 + j] - vik * (coefficient[k * 4 + j] / vkk);\n            }\n        }\n    }\n    \n    coefficient[(n - 1) * 4 + n] = coefficient[(n - 1) * 4 + n] / coefficient[(n - 1) * 4 + n - 1];\n    for (int i = n - 2; i >= 0; i--) {\n        float acc = 0.0;\n        for (int j = i + 1; j < n; j++) {\n            acc += coefficient[i * 4 + j] * coefficient[j * 4 + n];\n        }\n        coefficient[i * 4 + n] = (coefficient[i * 4 + n] - acc) / coefficient[i * 4 + i];\n    }\n    */\n        //coefficient = pivoting(coefficient, 3, 0);\n    int col = 0;\n    float maxValue = abs(coefficient0);\n    if (abs(coefficient4) > maxValue) {\n        col = 1;\n        maxValue = abs(coefficient4);\n    }\n    if (abs(coefficient8) > maxValue) {\n        col = 2;\n        maxValue = abs(coefficient8);\n    }\n    \n    if (col == 1) {\n        float tmp0 = coefficient4;\n        float tmp1 = coefficient5;\n        float tmp2 = coefficient6;\n        float tmp3 = coefficient7;\n        coefficient4 = coefficient0;\n        coefficient5 = coefficient1;\n        coefficient6 = coefficient2;\n        coefficient7 = coefficient3;\n        coefficient0 = tmp0;\n        coefficient1 = tmp1;\n        coefficient2 = tmp2;\n        coefficient3 = tmp3;\n    }\n    \n    if (col == 2) {\n        float tmp0 = coefficient8;\n        float tmp1 = coefficient9;\n        float tmp2 = coefficient10;\n        float tmp3 = coefficient11;\n        coefficient8 = coefficient0;\n        coefficient9 = coefficient1;\n        coefficient10 = coefficient2;\n        coefficient11 = coefficient3;\n        coefficient0 = tmp0;\n        coefficient1 = tmp1;\n        coefficient2 = tmp2;\n        coefficient3 = tmp3;\n    }\n\n    \n        float vkk = coefficient0;\n        float vik = coefficient4;    \n        coefficient4 = coefficient4 - vik * (coefficient0 / vkk);\n        coefficient5 = coefficient5 - vik * (coefficient1 / vkk);\n        coefficient6 = coefficient6 - vik * (coefficient2 / vkk);\n        coefficient7 = coefficient7 - vik * (coefficient3 / vkk);\n    \n        vik = coefficient8;            \n        coefficient8 = coefficient8 - vik * (coefficient0 / vkk);\n        coefficient9 = coefficient9 - vik * (coefficient1 / vkk);\n        coefficient10 = coefficient10 - vik * (coefficient2 / vkk);\n        coefficient11 = coefficient11 - vik * (coefficient3 / vkk);\n\n        \n        //coefficient = pivoting(coefficient, 3, 1);\n    col = 1;\n    maxValue = abs(coefficient5);\n    \n        if (abs(coefficient9) > maxValue) {\n            col = 2;\n            maxValue = abs(coefficient9);\n        }\n    \n    if (col == 2) {\n        float tmp0 = coefficient8;\n        float tmp1 = coefficient9;\n        float tmp2 = coefficient10;\n        float tmp3 = coefficient11;\n        coefficient8 = coefficient4;\n        coefficient9 = coefficient5;\n        coefficient10 = coefficient6;\n        coefficient11 = coefficient7;\n        coefficient4 = tmp0;\n        coefficient5 = tmp1;\n        coefficient6 = tmp2;\n        coefficient7 = tmp3;\n    }\n\n        vkk = coefficient5;\n        vik = coefficient9;\n            \n        coefficient9 = coefficient9 - vik * (coefficient5 / vkk);\n        coefficient10 = coefficient10 - vik * (coefficient6 / vkk);\n        coefficient11 = coefficient11 - vik * (coefficient7 / vkk);\n\n\n    \n    coefficient11 = coefficient11 / coefficient10;\n\n    float acc = 0.0;\n    acc += coefficient6 * coefficient11;\n        \n    coefficient7 = (coefficient7 - acc) / coefficient5;\n        \n    acc = 0.0;\n    acc += coefficient1 * coefficient7;\n    acc += coefficient2 * coefficient11;\n\n    coefficient3 = (coefficient3 - acc) / coefficient0;\n    \n    //vec3 center = vec3(coefficient[0 * 4 + 3], coefficient[1 * 4 + 3], coefficient[2 * 4 + 3]);\n    vec3 center = vec3(coefficient3, coefficient7, coefficient11);\n    float r = length(center - p0);\n    return vec4(center, r);\n}\n\nvec3 invertOnPoint(vec4 sphere, vec3 p) {\n    vec3 d = p - sphere.xyz;\n    float len = length(d);\n    return d * (sphere.r * sphere.r / (len * len)) + sphere.xyz;\n}\n\nvec4 invertOnSphere(vec4 invSphere, vec4 s) {\n    float r = s.w;\n    float coeffR = r * RT_3 / 3.;\n    vec3 p1 = invertOnPoint(invSphere, s.xyz + vec3(coeffR, coeffR, coeffR));\n    vec3 p2 = invertOnPoint(invSphere, s.xyz + vec3(-coeffR, -coeffR, -coeffR));\n    vec3 p3 = invertOnPoint(invSphere, s.xyz + vec3(coeffR, -coeffR, -coeffR));\n    vec3 p4 = invertOnPoint(invSphere, s.xyz + vec3(coeffR, coeffR, -coeffR));\n    return sphereFromPoints(p1, p2, p3, p4);\n}\n\nvec4 invertOnPlane(vec4 invSphere, Plane p) {\n    return sphereFromPoints(invertOnPoint(invSphere, p.p1),\n                            invertOnPoint(invSphere, p.p2),\n                            invertOnPoint(invSphere, p.p3),\n                            invSphere.xyz);\n}\n\nvoid computeGSpheres(){\n    gSpheres0 = invertOnPlane(inversionSphere, PL1);\n    gSpheres1 = invertOnSphere(inversionSphere, s2);\n    gSpheres2 = invertOnPlane(inversionSphere, PL2);\n    gSpheres3 = invertOnSphere(inversionSphere, s4);\n    gSpheres4 = invertOnPlane(inversionSphere, PL3);\n    gSpheres5 = invertOnSphere(inversionSphere, s6);\n    \n}\n\nvec3 computeVertex(vec4 a, vec4 b, vec4 c) {\n    float AB = (dot(a.xyz, a.xyz) - dot(b.xyz, b.xyz) - a.w * a.w + b.w * b.w) * 0.5 -\n               dot(a.xyz, a.xyz) + dot(a.xyz, b.xyz);\n    float AC = (dot(a.xyz, a.xyz) - dot(c.xyz, c.xyz) - a.w * a.w + c.w * c.w) * 0.5 -\n               dot(a.xyz, a.xyz) + dot(a.xyz, c.xyz);\n    float x = -dot(a.xyz, a.xyz) - dot(b.xyz, b.xyz) + 2. * dot(a.xyz, b.xyz);\n    float y = -dot(a.xyz, a.xyz) - dot(c.xyz, c.xyz) + 2. * dot(a.xyz, c.xyz);\n    float z = -dot(a.xyz, a.xyz) + dot(a.xyz, b.xyz) +\n               dot(a.xyz, c.xyz) - dot(b.xyz, c.xyz);\n    float s = (AB * y - AC * z) / (x * y - z * z);\n    float t = (AC * x - AB * z) / (x * y - z * z);\n    return a.xyz + (b.xyz - a.xyz) * s + (c.xyz - a.xyz) * t;\n}\n\n\n/*\n0, 1, 2, \n0, 3, 4, \n2, 4, 5,\n0, 1, 3,\n3, 4, 5,\n1, 2, 5,\n1, 3, 5,\n0, 2, 4\n*/\nvoid computeVertexes(){\n    vertexes0 = computeVertex(gSpheres0,\n                                gSpheres1,\n                                gSpheres2);\n    vertexes1 = computeVertex(gSpheres0,\n                                gSpheres3,\n                                gSpheres4);\n    vertexes2 = computeVertex(gSpheres2,\n                                gSpheres4,\n                                gSpheres5);\n    vertexes3 = computeVertex(gSpheres0,\n                                gSpheres1,\n                                gSpheres3);\n    vertexes4 = computeVertex(gSpheres3,\n                                gSpheres4,\n                                gSpheres5);\n    vertexes5 = computeVertex(gSpheres1,\n                                gSpheres2,\n                                gSpheres5);\n    vertexes6 = computeVertex(gSpheres1,\n                                gSpheres3,\n                                gSpheres5);\n    vertexes7 = computeVertex(gSpheres0,\n                                gSpheres2,\n                                gSpheres4);\n    /*\n    for(int i = 0; i < 8; i++) {\n        vertexes[i] = computeVertex(gSpheres[index[i*3 + 0]],\n                                    gSpheres[index[i*3 + 1]],\n                                    gSpheres[index[i*3 + 2]]);\n    }\n    */\n}\n\nPlane computePlane() {\n        vec3 p1 = invertOnPoint(inversionSphere, vertexes0);\n        vec3 p2 = invertOnPoint(inversionSphere, vertexes1);\n        vec3 p3 = invertOnPoint(inversionSphere, vertexes2);\n\n        vec3 v1 = p2 - p1;\n        vec3 v2 = p3 - p1;\n        vec3 normal = normalize(cross(v1, v2));\n        if (normal.y < 0.) {\n            normal = normal * -1.;\n        }\n        Plane p = Plane(p1, p2, p3, normal);\n        \n        return p;\n}\n\nvec4 computeConvexSphere(){\n    return invertOnPlane(inversionSphere, dividePlane);\n}\n\n// p: center of the plane\n// n: normal of the plane\nbool intersectPlane(vec3 p, vec3 n, \n                    vec3 rayOrigin, vec3 rayDir,\n                     inout float minDist,\n                    inout vec3 intersection, inout vec3 normal){\n    float d = -dot(p, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(EPSILON < t && t < minDist){\n\t\tintersection = rayOrigin + t * rayDir;\n        normal = n;\n        minDist = t;\n        return true;\n    }\n    return false;\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat distSphere(vec3 p, vec4 sphere){\n\treturn distance(p, sphere.xyz) - sphere.w;\n}\n\nfloat distPlane(vec3 pos, vec3 p, vec3 n) {\n    return dot(pos - p, n);\n}\n\nfloat distPrism(const vec3 pos) {\n    float d = -1.;\n\td = max(distPlane(pos, PL1.p1,\n\t\t\t\t\t  PL1.normal),\n\t\t\td);\n    d = max(distPlane(pos, PL2.p1,\n\t\t\t\t\t  PL2.normal),\n\t\t\td);\n    d = max(distPlane(pos, PL3.p1,\n\t\t\t\t\t  PL3.normal),\n\t\t\td);\n    return d;\n}\n\nfloat distInfSphairahedra(const vec3 pos) {\n    float d = distPrism(pos);\n    d = max(distPlane(pos, dividePlane.p1,\n                           dividePlane.normal),\n            d);\n\td = max(-distSphere(pos, s2),\n\t\t\td);\n    d = max(-distSphere(pos, s4),\n\t\t\td);\n    d = max(-distSphere(pos, s6),\n\t\t\td);\n    return d;\n}\n\nvoid SphereInvert(inout vec3 pos, inout float dr, vec4 s) {\n    vec3 diff = pos - s.xyz;\n    float lenSq = dot(diff, diff);\n    float k = (s.w * s.w) / lenSq;\n    dr *= k; // (r * r) / lenSq\n    pos = (diff * k) + s.xyz;\n}\n\nfloat distLimitSetTerrain(vec3 pos, out float invNum) {\n    float dr = 1.;\n    invNum = 0.;\n\n    float d;\n    for(int i = 0; i < 200; i++) {\n        if(25 <= i) break;\n        bool inFund = true;\n\t\tif(distance(pos, s2.xyz) < s2.w) {\n            invNum ++;\n\t\t\tSphereInvert(pos, dr, s2);\n\t\t\tinFund = false;\n\t\t}\n        if(distance(pos, s4.xyz) < s4.w) {\n            invNum ++;\n\t\t\tSphereInvert(pos, dr, s4);\n\t\t\tinFund = false;\n\t\t}\n        if(distance(pos, s6.xyz) < s6.w) {\n            invNum ++;\n\t\t\tSphereInvert(pos, dr, s6);\n\t\t\tinFund = false;\n\t\t}\n\n\t\tpos -= PL1.p1;\n\t\td = dot(pos, PL1.normal);\n\t\tif(d > 0.) {\n            //invNum += 1.;\n\t\t\tpos -= 2. * d * PL1.normal;\n\t\t\tinFund = false;\n\t\t}\n\t\tpos += PL1.p1;\n        \n        pos -= PL2.p1;\n\t\td = dot(pos, PL2.normal);\n\t\tif(d > 0.) {\n            //invNum += 1.;\n\t\t\tpos -= 2. * d * PL2.normal;\n\t\t\tinFund = false;\n\t\t}\n\t\tpos += PL2.p1;\n        \n        pos -= PL3.p1;\n\t\td = dot(pos, PL3.normal);\n\t\tif(d > 0.) {\n            //invNum += 1.;\n\t\t\tpos -= 2. * d * PL3.normal;\n\t\t\tinFund = false;\n\t\t}\n\t\tpos += PL3.p1;\n\n        if(inFund) break;\n    }\n    return distInfSphairahedra(pos) / abs(dr) * 0.1;\n}\n\nvec2 distFunc(vec3 p) {\n\tvec2 d = vec2(distLimitSetTerrain(p, gInvNum), 1);\n    return d;\n}\n\nconst vec2 NORMAL_COEFF = vec2(0.001, 0.);\nvec3 computeNormal(const vec3 p){\n  return normalize(vec3(distFunc(p + NORMAL_COEFF.xyy).x - distFunc(p - NORMAL_COEFF.xyy).x,\n                        distFunc(p + NORMAL_COEFF.yxy).x - distFunc(p - NORMAL_COEFF.yxy).x,\n                        distFunc(p + NORMAL_COEFF.yyx).x - distFunc(p - NORMAL_COEFF.yyx).x));\n}\n\nconst int MAX_MARCH = 300;\nint march (vec3 rayOrg, vec3 rayDir, inout float minDist,\n           inout vec3 intersection, inout vec3 normal) {\n    vec2 dist = vec2(-1);\n    float rayLength = minDist;\n    vec3 rayPos = rayOrg + rayDir * rayLength;\n\n    for(int i = 0 ; i < MAX_MARCH ; i++){\n        dist = distFunc(rayPos);\n        rayLength += dist.x;\n        rayPos = rayOrg + rayDir * rayLength;\n        if(dist.x < EPSILON){\n            int objId = int(dist.y);\n            intersection = rayPos;\n            normal = computeNormal(intersection);\n            minDist = rayLength;\n            return objId;\n        }\n    }\n    return -1;\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(fov * .5);\n  vec3 v = normalize(target - eye);\n  vec3 xaxis = normalize(cross(v, up));\n  vec3 yaxis =  normalize(cross(v, xaxis));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst vec4 K = vec4(1.0, .666666, .333333, 3.0);\nvec3 hsv2rgb(const vec3 c){\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 getMatColor(int objId, vec3 normal, vec3 intersection, float t){\n    if(objId == 1){\n        vec3 col = Hsv2rgb((1., -0.01 + (gInvNum) * 0.02), 1., 1.);;\n        return col; \n    }\n\treturn BLACK;\n}\n\nvec3 sky(vec3 rayDir){\n\treturn clamp(vec3(.7, .8, 1.) + exp(dot(rayDir, LIGHT_DIR))*0.1, 0.0, 1.0);\n}\n\nfloat computeShadowFactor (vec3 rayOrg, vec3 rayDir,\n                           float mint, float maxt, float k) {\n    float shadowFactor = 1.0;\n    float t = mint;\n    for(int n = 0; n < 1000; n++){\n        if(t > maxt) break;\n        float d = distFunc(rayOrg + rayDir * t).x;\n        if(d < 0.0001) return 0.;\n\n        shadowFactor = min(shadowFactor, k * d / t);\n        t += d;\n    }\n    return clamp(shadowFactor, 0.0, 1.0);\n}\n\n\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    return pow(clamp(dot(reflect(e,n),l),0.0, 1.),s);\n}\n\nconst float FOG_START = 5.;\nconst float FOG_END = 100.;\nconst float FOG_END_START_RECIPROCAL = 1. / (FOG_END - FOG_START);\nconst vec3 FOG_F = vec3(1.);\nvec3 calcColor(float time, vec3 eye, vec3 ray){\n  \tvec3 l = BLACK;\n\n    float tmin = 0.;\n    float t = 9999999.;\n    const int maxLoop = 10;\n    \tvec3 intersection, normal;\n    \tbool isect;\n    \tint objId = -1;\n        \n        \n    bool hit = intersectBoundingPlane(vec3(0, 1, 0), vec3(0, gBoundingPlaneY, 0),\n                                 eye, ray,\n                                 tmin, t);\n    if(hit && tmin < 30.) {\n        objId = march(eye, ray, tmin,\n                      intersection, normal);\n        if(objId != -1){\n            vec3 matColor = getMatColor(objId, normal, intersection, t);\n            float k = computeShadowFactor(intersection + 0.0001 * normal,\n                                         LIGHT_DIR,\n                                         0.001, 5., 100.);\n            vec3 diffuse =  clamp(dot(normal, LIGHT_DIR), 0., 1.) * matColor;\n            vec3 ambient = matColor * AMBIENT_FACTOR;\n    \t\tl += k * diffuse + ambient;\n            \n            l = mix(FOG_F, l, clamp((FOG_END - tmin) * FOG_END_START_RECIPROCAL, 0.1, 1.0));\n        }\n                      \n    } else {\n        l = mix( sky(ray), l, exp( -0.000000009*t * t ) );\n    }\n    \n  \treturn l;\n}\n\n//w: start time\n//s: duration\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;\n}\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\n\nfloat circEasingIn(float t){\n\treturn -  (sqrt(1. - t*t) - 1.);\n}\n\nfloat circEasingOut(float t){\n    return sqrt(1. - pow(t - 1., 2.));\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nconst vec3 target = vec3(0, 0, 0);\nvec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nconst float SAMPLE_NUM = 1.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float t = mod(iTime, 31.);\n    \n    float rad = mix(0.0001, 1.0, circEasingInOut(scene(t, 1.0, 15.)));\n    float rotationT = mix(0., 50., (scene(t, 0., 15.)));\n    if(t < 21.) {\n        \n        float tb = rad * cos(rotationT);\n        float tc = rad * sin(rotationT);\n        tb = mix(tb, 0., circEasingInOut(scene(t, 15., 1.)));\n        tc = mix(tc, 0., circEasingInOut(scene(t, 15., 1.)));\n        \n        tb = mix(tb, 1.2224464245160123, circEasingInOut(scene(t, 16., 1.)));\n        tc = mix(tc, 0.612090457867328, circEasingInOut(scene(t, 16., 1.)));\n        \n        tb = mix(tb, -0.8661174154839888, circEasingInOut(scene(t, 17., 1.)));\n        tc = mix(tc, 0., circEasingInOut(scene(t, 17., 1.)));\n        \n        tb = mix(tb, 0.61096041060052, circEasingInOut(scene(t, 18., 1.)));\n        tc = mix(tc, -0.6110480831254523, circEasingInOut(scene(t, 18., 1.)));\n        \n        tb = mix(tb, -0.6144427845492827, circEasingInOut(scene(t, 19., 1.)));\n        tc = mix(tc, 0.6155169219301033, circEasingInOut(scene(t, 19., 1.)));\n        \n        tb = mix(tb, -0.6492253932449349, circEasingInOut(scene(t, 20., 1.)));\n        tc = mix(tc, -1.1670917737220714, circEasingInOut(scene(t, 20., 1.)));\n        \n        computeCubeSphairahedronA(tb, tc);\n    } else if(t < 22.) {\n        computeCubeSphairahedronA(-0.6492253932449349, -1.1670917737220714);\n        computeCubeSphairahedronB(-1.4263771231354925, -0.4114778978502866);\n        s2 = mix(s2A, s2B, circEasingInOut(scene(t, 21., 1.)));\n        s4 = mix(s4A, s4B, circEasingInOut(scene(t, 21., 1.)));\n        s6 = mix(s6A, s6B, circEasingInOut(scene(t, 21., 1.)));\n        inversionSphere = vec4(-s6.x, -s6.y, s6.z, s6.w);\n    } else if(t < 26.){\n        float tb = -1.4263771231354925;\n        float tc = -0.4114778978502866;\n        tb = mix(tb, 0.9480876782578194, circEasingInOut(scene(t, 22., 1.)));\n        tc = mix(tc, -0.27487295833102093, circEasingInOut(scene(t, 22., 1.)));\n        \n        tb = mix(tb, -0.7341647058410344, circEasingInOut(scene(t, 23., 1.)));\n        tc = mix(tc, -0.8016177852310659, circEasingInOut(scene(t, 23., 1.)));\n        \n        tb = mix(tb, -1.1021579831206387, circEasingInOut(scene(t, 24., 1.)));\n        tc = mix(tc, 0., circEasingInOut(scene(t, 24., 1.)));\n        \n        tb = mix(tb, 0.7341944231647511, circEasingInOut(scene(t, 25., 1.)));\n        tc = mix(tc, 0.8010951070853616, circEasingInOut(scene(t, 25., 1.)));\n        computeCubeSphairahedronB(tb, tc);\n    } else if(t < 27.){\n        computeCubeSphairahedronB(0.7341944231647511, 0.8010951070853616);\n        computeCubeSphairahedronC(0.80897179163727, -0.6172090398213005);\n        s2 = mix(s2B, s2C, circEasingInOut(scene(t, 26., 1.)));\n        s4 = mix(s4B, s4C, circEasingInOut(scene(t, 26., 1.)));\n        s6 = mix(s6B, s6C, circEasingInOut(scene(t, 26., 1.)));\n        inversionSphere = vec4(-s6.x, -s6.y, s6.z, s6.w);\n\n    } else if(t < 30.){\n        float tb = 0.80897179163727;\n        float tc = -0.6172090398213005;\n        tb = mix(tb, -1.0724597039839807, circEasingInOut(scene(t, 27., 1.)));\n        tc = mix(tc, 0.10239062161550339, circEasingInOut(scene(t, 27., 1.)));\n        \n        tb = mix(tb, -0.4626628191468804, circEasingInOut(scene(t, 28., 1.)));\n        tc = mix(tc, -0.7985798919860417, circEasingInOut(scene(t, 28., 1.)));\n        \n        tb = mix(tb, 1.0842163989231046, circEasingInOut(scene(t, 29., 1.)));\n        tc = mix(tc, -0.09944669059450531, circEasingInOut(scene(t, 29., 1.)));\n        \n        computeCubeSphairahedronC(tb, tc);\n    } else {\n        computeCubeSphairahedronC(1.0842163989231046, -0.09944669059450531);\n        computeCubeSphairahedronA(0., 0.);\n        s2 = mix(s2C, s2A, circEasingInOut(scene(t, 30., 1.)));\n        s4 = mix(s4C, s4A, circEasingInOut(scene(t, 30., 1.)));\n        s6 = mix(s6C, s6A, circEasingInOut(scene(t, 30., 1.)));\n        inversionSphere = vec4(-s6.x, -s6.y, s6.z, s6.w);\n    }\n\n    computeGSpheres();\n    computeVertexes();\n    dividePlane = computePlane();\n    convexSphere = computeConvexSphere();\n    gBoundingPlaneY = max(gBoundingPlaneY, s2.y + .01);\n    gBoundingPlaneY = max(gBoundingPlaneY, s4.y + .01);\n    gBoundingPlaneY = max(gBoundingPlaneY, s6.y + .01);\n    vec3 eye = vec3(2. , 2., 2. );\n    eye = mix(eye, vec3(-2, 2, 2), circEasingInOut(scene(t, 15.0, 1.)));\n    eye = mix(eye, vec3(-2, 2, -2), circEasingInOut(scene(t, 20.0, 1.)));\n    eye = mix(eye, vec3(2, 2, -2), circEasingInOut(scene(t, 25.0, 1.)));\n    eye = mix(eye, vec3(2, 2, 2), circEasingInOut(scene(t, 30.0, 1.)));\n    \n    vec3 sum = vec3(0);\n  \tfor(float i = 0. ; i < SAMPLE_NUM ; i++){\n    \tvec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n          \n    \tvec3 ray = calcRay(eye, target, up, fov,\n        \t               iResolution.x, iResolution.y,\n            \t           gl_FragCoord.xy + coordOffset);\n        \n    \tsum += calcColor(t, eye, ray);\n  \t}\n \tvec3 col = (sum/SAMPLE_NUM);\n  \n    \n  \tfragColor = vec4(gammaCorrect(col), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}