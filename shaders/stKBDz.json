{
    "Shader": {
        "info": {
            "date": "1664460487",
            "description": "Vasarely vibes inspire by https://www.fondationvasarely.org/periode-structures-universelles-expansives-regressives/",
            "flags": 0,
            "hasliked": 0,
            "id": "stKBDz",
            "likes": 5,
            "name": "Moving Vasarely",
            "published": 3,
            "tags": [
                "vasarely",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "rubioh",
            "viewed": 191
        },
        "renderpass": [
            {
                "code": "#define N_tile 21.\n\nvec2 hash( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(175.1,311.7)),\n             dot(p,vec2(260.5,752.3)));\n    return fract(sin(p+455.)*18.5453);\n}\n\n\nvec3 mix3ColorGradient(float ratio, vec3 start, vec3 mid, vec3 end){\n    float h = .5;\n    return\nmix(mix(start, mid, ratio/h), mix(mid, end, (ratio - h)/(1.0 - h)), step(h, ratio));\n}\n\n\n\nvec3 cell_shade(in vec2 uv, in vec2 uv_floor, \n                vec3 col_int_orig, vec3 col_int_mid, vec3 col_int_target, \n                vec3 col_ext_orig, vec3 col_ext_mid, vec3 col_ext_target,\n                vec3 col_ring_orig, vec3 col_ring_mid, vec3 col_ring_target, vec2 st) {\n    vec3 res = vec3(.0);\n    \n    // Activation/Step things\n    //float radius = length(uv); // Change size of the ring\n    \n    float N = 10.*(1.-abs(cos(iTime*.2)))+2.; // Norm 2 to norm 12 (circle to square) if using norm 1 -> losange\n    \n    float absX = pow(abs(uv.x), N);\n    float absY = pow(abs(uv.y), N);\n    \n    float radius = pow(absX+absY, 1./N); \n    \n    \n    float ring_dist = (1.-length(st))/2.;\n    float ring_thickness = 0.15;\n    float activation_ext = smoothstep(ring_dist+ring_thickness - 0.04, ring_dist+ring_thickness, radius);\n    float activation_int = (1.-smoothstep(ring_dist-0.04, ring_dist, radius));\n    float activation_ring = (1.-activation_int)*(1.-activation_ext);\n    \n    // Color things\n    \n    vec3 col_interior = mix3ColorGradient(length(uv_floor)/N_tile*2.5, col_int_orig, col_int_mid, col_int_target);\n    vec3 col_exterior = mix3ColorGradient(length(uv_floor)/N_tile*2.5, col_ext_orig, col_ext_mid, col_ext_target);\n    vec3 col_ring = mix3ColorGradient(length(uv_floor)/N_tile*2.5, col_ring_orig, col_ring_mid, col_ring_target);\n    \n    //Render\n    res += col_interior*activation_int;\n    res += col_exterior*activation_ext;\n    res += col_ring*activation_ring;\n    \n    return res;\n}\n\nvec3 sphere_warp(in vec2 uv) {\n\n//uv += floor(uv);\n    vec2 st = (uv+.5) * 2.;\n\n    vec2 corner = floor(st);\n    vec2 sphere_coord = (fract(st) - corner)/2.;\n    //return sphere_coord;\n    sphere_coord *= N_tile/(N_tile/2.-.5);\n    vec2 sphere_uv = normalize(sphere_coord)*(asin(length(sphere_coord)) / 3.1415926);\n    float mask = max(0., 1. - length(sphere_uv));\n    \n    \n    // Moving Sphere\n\n    return vec3(sphere_uv, mask);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy-.5;    \n    \n    float center_scale = 1.0 + sin(iTime/2.0) / 2.0;\n    float angle = iTime / 2.0;\n    mat2 rotation = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    \n    \n    // Sphere texture\n    vec3 sphere_uv = sphere_warp(uv);\n    vec2 sphere_uv_floor = floor(-1.*(sphere_uv.xy)*N_tile);// *-1. move the center on the corner\n    \n    vec2 corner = floor((uv+.5) * 2. )- .5;\n    sphere_uv.xy += iTime / 20. * normalize(-corner);\n   \n \n    vec3 col_int_target = vec3(38., 51., 160.)/255.;\n    vec3 col_int_orig = vec3(176., 200., 223.)/255.;\n    vec3 col_int_mid = vec3(118., 160., 227.)/255.;\n\n    vec3 col_ext_target = vec3(70., 24., 24.)/255.;\n    vec3 col_ext_orig = vec3(222., 147., 139.)/255.;\n    vec3 col_ext_mid = vec3(185., 25., 12.)/255.;\n\n    vec3 col_ring_target = vec3(38., 51., 160.)/255.;\n    vec3 col_ring_orig = vec3(98., 85., 155.)/255.;\n    vec3 col_ring_mid = vec3(110., 96., 169.)/255.;\n\n    vec3 col = cell_shade((fract(sphere_uv.xy*N_tile)-.5)*2., sphere_uv_floor, \n                           col_int_orig, col_int_mid, col_int_target, \n                           col_ext_orig, col_ext_mid, col_ext_target,\n                           col_ring_orig, col_ring_mid, col_ring_target, vec2(1.-length(uv)))*(1.-step(0., -sphere_uv.z)); \n    //Lumi√®re add *pow(sphere_uv.z*1.5, 2.)\n    \n    // Plane texture\n    vec2 cell_uv = (fract(rotation*center_scale*uv*(N_tile)+vec2(0.5,0.5))-.5)*2.;\n    vec2 cell_uv_floor = floor(rotation*center_scale*uv*N_tile+.5);\n    \n    \n    col_int_target = vec3(31., 13., 28.)/255.;\n    col_int_orig = vec3(235., 163., 157.)/255.;\n    col_int_mid = vec3(159., 11., 10.)/255.;\n \n    col_ext_target = vec3(11., 13., 137.)/255.;\n    col_ext_orig = vec3(140., 183., 237.)/255.;\n    col_ext_mid = vec3(29., 43., 174.)/255.;\n\n\n    col_ring_target = vec3(20., 12., 13.)/255.;\n    col_ring_orig = vec3(24., 14., 18.)/255.;\n    col_ring_mid = vec3(24., 14., 18.)/255.;\n\n    vec3 col2 = cell_shade(cell_uv, cell_uv_floor, \n                           col_int_orig, col_int_mid, col_int_target,\n                           col_ext_orig, col_ext_mid, col_ext_target,\n                           col_ring_orig, col_ring_mid, col_ring_target, uv)*step(0., -sphere_uv.z);\n    \n  \n    fragColor = vec4(max(col, col2)*(1.-step(.5, uv.x)), 1.0);\n        \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}