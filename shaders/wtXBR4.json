{
    "Shader": {
        "info": {
            "date": "1596208063",
            "description": "try a cartoon style with a kind of adaptative anti-aliasing.",
            "flags": 32,
            "hasliked": 0,
            "id": "wtXBR4",
            "likes": 23,
            "name": "Cartoon ride",
            "published": 3,
            "tags": [
                "cartoon",
                "edge"
            ],
            "usePreview": 1,
            "username": "iapafoto",
            "viewed": 757
        },
        "renderpass": [
            {
                "code": "// based on one desert canyon of the fantastic Shane shader\n\n// best for small size\n#define WITH_AA\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 res = texture(iChannel0, uv);\n\n#ifdef WITH_AA\n    \n    vec3 dp = vec3(1./iResolution.xy, 0);\n    float needAA = 0.;\n    for (int j=-1; j<3; j++) {\n        for (int i=-1; i<3; i++) {\n            needAA += texture(iChannel0, uv).w;\n        }\n    }\n    \n    // Antialising only on edges and big curvature\n    if (needAA > .5) {\n    \tfor (int k=0; k<4; k++)\n        \tres += render(fragCoord+.66*vec2(k%2-1,k/2-1)-.33, iTime, iResolution.xy, iChannel0);\n        res /= 5.;\n    }\n    \n#endif\n\n    fragColor = res;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = render(fragCoord.xy, iTime, iResolution.xy, iChannel0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define FAR 400.\n//#define PRECISE\n//#define WITH_AO\n\n#define ID_SKY    0.\n#define ID_SHIP   1.\n#define ID_GROUND 2.\n#define ID_PATH   3.\n\n#define EDGE_WIDTH 5e-3\n\n\n\n// Frequencies and amplitudes of the \"path\" function, used to shape the tunnel and guide the camera.\nconst float freqA = .34*.15/3.75;\nconst float freqB = .25*.25/2.75;\nconst float ampA = 20.;\nconst float ampB = 4.;\n\n\nvec3 gRO;\nmat3 gbaseShip;\n\nfloat gedge;\nfloat gedge2;\nfloat glastt;\n\n\n// 2x2 matrix rotation. Angle vector, courtesy of Fabrice.\nmat2 rot2( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// 1x1 and 3x1 hash functions.\nfloat hash(float n){ return fract(cos(n)*45758.5453); }\nfloat hash(vec3 p){ return fract(sin(dot(p, vec3(7, 157, 113)))*45758.5453); }\n\n\n// Smooth maximum, based on the function above.\nfloat smaxP(float a, float b, float s){    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r ) {\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvoid pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*3.141592/repetitions;\n\tfloat a = atan(p.y, p.x) + angle*.5;\n\ta = mod(a,angle) - angle*.5;\n\tp = vec2(cos(a), sin(a))*length(p);\n}\n\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n    return vec2(ampA*sin(z * freqA) + 2.*cos(z*.0252) - 1., 10.+ ampB*cos(z * freqB) * (.5+ .5*sin(z*0.0015)));\n}\n\nfloat sdGround(in vec3 p, sampler2D channel){\n    p += vec3(0,2,0);\n    float tx1 = 2.5*textureLod(channel, p.xz/28. + p.xy/100., 0.).x;\n    float tx2 = 2.*textureLod(channel, p.xy/vec2(31.,15.), 0.).x;\n  \tfloat tx = tx1 - tx2;\n\n    vec3 q = p*.125;\n    float h = dot(sin(q)*cos(q.yzx), vec3(.222)) + dot(sin(q*1.5)*cos(q.yzx*1.5), vec3(.111));\n\n    float d = p.y + h*6.;\n    q = p*.07125;\n    float h3 = dot(sin(q)*cos(q.yzx), vec3(.222)) + dot(sin(q*1.5)*cos(q.yzx*1.5), vec3(.111));\n    float d3 = p.y + h3*22.-22.;\n  \n    q = sin(p*.5 + h);\n    float h2 = q.x*q.y*q.z;\n  \n    vec3 p0 = p;\n    p.xy -= path(p.z);\n    \n    float dPath = length(p.xy)-38.;\n    \n    vec3 p1 = p;\n    float tnl = 1.5 - length(p.xy*vec2(1.2, 1.96)) + h2;// - (1. - tx)*.25;\n    \n    p.xz = mod(p0.xz+150.,300.)-150.; \n    \n    float dCaps = mix(999., sdVerticalCapsule(p+vec3(45,60,50), 130., 15.) + tx1, step(2500., p0.z));\n    \n    p = p1;\n    p.z = mod(p.z+250.,500.)-250.; \n    \n    float dGate = sdTorus(p.yzx-vec3(25,25,5), vec2(50.,15.))+tx1;\n\tdCaps = mix(dCaps, dGate, step(4600., p0.z));\n            \n    p.xz = mod(p0.xz+450.,900.)-450.;\n    float dCaps2 = sdVerticalCapsule(p+vec3(20,55,0), 100., 30.) + .5*tx;\n        \n    float d4 = smaxP(d - tx*.5+ tnl*.4, .2*tnl, 8.);\n    d3 = mix(d3, d4, smoothstep(.5,1., .5+.5*(sin(p0.z*.001-.8))));\n    \n    d = min(dCaps, smaxP(d3, d4, 10.));\n    float dend = max(p0.y-60., -dPath-.5*tx+.25*tx2);\n    d = mix(d, dend, smoothstep(7000.,9000., p0.z)*smoothstep(12000.,9000., p0.z));\n    d = smaxP(-dCaps2, d,2.);\n            \n    return d;\n}\n\nfloat sdShip(in vec3 p0) {\n    p0 -= vec3(4,0,0);\n    float d = length(p0) -4.;\n    \n    vec3 pRot = p0;\n    pModPolar(pRot.zy, 16.);\n    pRot.x = abs(pRot.x);\n    d = min(d, length(pRot-vec3(2.6,0,3.))-.2);\n\td = min(d, sdBox(pRot-vec3(4.5,0,.8), vec3(.5,.1,.2)));    \n    \n    vec3 p = p0;\n    p.zy = abs(p.zy);\n    p -= vec3(-5.6,2.5,2);\n    pR45(p.yz);\n    pR45(p.xy);\n    return min(d, sdBox(p, vec3(1.,2,.2)));  \n}\n\nfloat sdPath(in vec3 p0) {\n    float d2 = length(path(p0.z)-p0.xy)-.5;\n    return max(d2, -gRO.z + p0.z);\n}\n\nfloat map(in vec3 p0, sampler2D channel) {\n    float d = sdGround(p0,channel);\n    float dPath = sdPath(p0-vec3(0,0,0));\n    return min(dPath,d); \n}\n\nfloat mapFull(in vec3 p0, sampler2D channel) {\n    float d = sdGround(p0,channel);\n    float dPath = sdPath(p0);\n    return min(sdShip((p0-gRO)*gbaseShip),min(dPath,d)); \n}\n\nvec2 min2(vec2 c0, vec2 c1) {\n\treturn c0.x < c1.x ? c0 : c1;\n}\n\nvec2 mapColor(in vec3 p0, sampler2D channel) {\n    float d = sdGround(p0, channel);\n    float dPath = sdPath(p0);\n    return min2(vec2(sdShip((p0-gRO)*gbaseShip), ID_SHIP), \n                min2(vec2(dPath, ID_PATH), vec2(d, ID_GROUND))); \n}\n\n\nfloat logBisectTrace(in vec3 ro, in vec3 rd, sampler2D channel){\n    float t = 0., told = 0., mid, dn;\n    float d = map(rd*t + ro, channel);\n    float sgn = sign(d);\n\n    float lastDistEval = 1e10, lastt = 0.;\n\tvec3 rdShip = rd*gbaseShip;\n\tvec3 roShip = (ro-gRO)*gbaseShip;\n\n    for (int i=0; i<164; i++){\n        if (sign(d) != sgn || d < 0.01 || t > FAR) break;\n \n        told = t;    \n        t += step(d, 1.)*(log(abs(d) + 1.1) - d) + d;\n        \n        d = map(rd*t + ro, channel);\n        d = min(d, sdShip(rdShip*t + roShip));\n        \n        if (d < lastDistEval) {\n            lastt = t;\n            lastDistEval = d;\n        } else {\n            if (d > lastDistEval + 0.0001 &&  lastDistEval/mix(30., lastt, smoothstep(FAR*.75, FAR*.9, t)) < EDGE_WIDTH) {\n            \tgedge = 1.f;\n                if (glastt == 0.) glastt = lastt;\n            }\n            if (d > lastDistEval + 0.0001 && (lastDistEval < EDGE_WIDTH*40. || lastDistEval/lastt < EDGE_WIDTH*2.)) {\n            \tgedge2 = 1.f;\n            }\n\t\t\t//edge = smoothstep(-EDGE_WIDTH,-EDGE_WIDTH*.5f,-(lastDistEval/100.));///lastt));\n\t\t}\n    }\n    if (glastt == 0.)  glastt = lastt;\n\n#ifdef PRECISE\n    // If a threshold was crossed without a solution, use the bisection method.\n    if (sign(d) != sgn){\n    \n        // Based on suggestions from CeeJayDK, with some minor changes.\n\n        dn = sign(map(rd*told + ro, channel));\n        \n        vec2 iv = vec2(told, t); // Near, Far\n\n        // 6 iterations seems to be more than enough, for most cases...\n        // but there's an early exit, so I've added a couple more.\n        for (int ii=0; ii<8; ii++) { \n            //Evaluate midpoint\n            mid = dot(iv, vec2(.5));\n            float d = map(rd*mid + ro, channel);\n            if (abs(d) < 0.001)break;\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\n        }\n\n        t = mid;       \n    }\n#endif\n    \n    return min(t, FAR);\n}\n\n\nvec3 normal(in vec3 p, sampler2D channel) {  \n    vec2 e = vec2(-1, 1)*.001;   \n\treturn normalize(e.yxx*mapFull(p + e.yxx, channel) + e.xxy*mapFull(p + e.xxy, channel) + \n\t\t\t\t\t e.xyx*mapFull(p + e.xyx, channel) + e.yyy*mapFull(p + e.yyy, channel) );   \n}\n\n\nfloat softShadow(in vec3 ro, in vec3 rd, in float start, in float end, in float k, sampler2D channel){\n    ro += rd*hash(ro);\n    vec3 rdShip = rd*gbaseShip;\n\tvec3 roShip = (ro-gRO)*gbaseShip;\n    float shade = 1.;\n    const int maxIterationsShad = 24; \n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = min(map(ro + rd*dist, channel), sdShip(roShip + dist*rdShip));\n        shade = min(shade, smoothstep(0., 1., k*h/dist));\n        dist += clamp(h, .2, stepDist*2.);\n        if (abs(h)<.001 || dist > end) break; \n    }\n    return min(max(shade, 0.) + .1, 1.); \n}\n\n#ifdef WITH_AO\n\nfloat calculateAO( in vec3 p, in vec3 n, float maxDist, sampler2D channel )\n{\n\tfloat ao = 0., l;\n\tconst float nbIte = 6.;\n    for(float i=1.; i< nbIte+.5; i++){\n        l = (i + hash(i))*.5/nbIte*maxDist;\n        ao += (l - mapFull( p + n*l, channel))/(1. + l);\n    }\n    return clamp(1. - ao/nbIte, 0., 1.);\n}\n#endif\n\n// Pretty standard way to make a sky. \nvec3 getSky(in vec3 ro, in vec3 rd, vec3 sunDir){\n\treturn vec3(smoothstep(.97,1.,max(dot(rd, sunDir), 0.)));\n}\n\n// Curve function, by Shadertoy user, Nimitz.\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\nfloat curve(in vec3 p, sampler2D channel){\n    const float eps = .05, amp = 4., ampInit = .5;\n\tvec2 e = vec2(-1, 1)*eps; // 0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\n    float t1 = mapFull(p + e.yxx, channel), t2 = mapFull(p + e.xxy, channel);\n    float t3 = mapFull(p + e.xyx, channel), t4 = mapFull(p + e.yyy, channel);\n    return clamp((t1 + t2 + t3 + t4 - 4.*mapFull(p, channel))*amp + ampInit, 0., 1.);\n}\n\n\nvec4 render(in vec2 fragCoord, float Time, vec2 Resolution, sampler2D channel){\n        \n    gedge = 0.;\n    gedge2= 0.;\n    glastt = 0.;\n\t\n\t// Screen coordinates.\n\tvec2 u = (fragCoord - Resolution.xy*.5)/Resolution.y;\n    float dBox = sdBox(u, vec2(.5*Resolution.x/Resolution.y-.1,.4));\n    \n    vec3 col = vec3(.2);\n   \tfloat needAA = 0.; \n    float ed = 0., ed2 = 0., lastt1 = 0.;\n    \n    if (dBox <0.){\t\n\n        // Camera Setup.\n        vec3 lookAt = vec3(0, 0, Time*100.);  // \"Look At\" position.\n        vec3 ro = lookAt + vec3(0, 0, -.25); // Camera position, doubling as the ray origin.\n\n        lookAt.xy += path(lookAt.z);\n        ro.xy += path(ro.z);\n        lookAt.y -= .071;\n\n        // Using the above to produce the unit ray-direction vector.\n        float FOV = 3.14159/2.; // FOV - Field of view.\n\n        vec3 forward = normalize(lookAt - ro);\n        vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \n\n        right.xy *= rot2( path(lookAt.z).x/64.);\n        right.xy *= rot2( -.7*cos(Time*.12));\n\n\n        vec3 up = cross(forward, right);\n\n        vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\n        vec3 lp = vec3(.5*FAR, FAR, 1.5*FAR) + vec3(0, 0, ro.z);\n\n\n        gRO = ro+vec3(0,0,1);\n        gRO.xy = path(gRO.z);\n        vec3 p2 = vec3(path(gRO.z+1.), gRO.z+1.);\n\n        forward = normalize(p2 - gRO);\n        right = normalize(vec3(forward.z, 0, -forward.x )); \n        right.xy *= rot2( path(lookAt.z).x/32.);\n        up = cross(forward, right);\n        gbaseShip = mat3(forward, up, right);\n\n        float dist = mix(35., 15., smoothstep(7000.,8500., gRO.z));\n        dist = mix(dist, 45., smoothstep(10000.,12000., gRO.z));\n        ro += (dist*(.5+.5*cos(.31*Time))+2.)*vec3(.3,1,-2.);\n        ro.x += .3*dist*cos(.31*Time);\n\n        float t = logBisectTrace(ro, rd, channel);\n        ed = gedge; ed2 = gedge2;  lastt1 = glastt;\n\n\n        vec3 sky = getSky(ro, rd, normalize(lp - ro));\n\n        col = sky;\n\n        vec2 mapCol = mapColor(ro+t*rd, channel);\n\n        vec3 sp;\n\t\tfloat cur;\n        if (t < FAR){\n\n            sp = ro+t*rd; // Surface point.\n            vec3 sn = normal(sp, channel); // Surface normal.\n            vec3 ld = lp-sp;\n            ld /= max(length(ld), 0.001); // Normalize the light direct vector.\n\n            float shd = softShadow(sp, ld, .1, FAR, 8., channel); // Shadows.\n            cur = curve(sp, channel);\n            float curv = cur*.9 +.1; // Surface curvature.\n#ifdef WITH_AO\n            float ao = calculateAO(sp, sn, 4., channel); // Ambient occlusion.\n#else\n            float ao = 1.;//calculateAO(sp, sn, 4., channel); // Ambient occlusion.\n#endif\n            float dif = max( dot( ld, sn ), 0.); // Diffuse term.\n            float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0. ), 5.); // Specular term.\n            float fre = clamp(1.0 + dot(rd, sn), 0., 1.); // Fresnel reflection term.\n            float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n            float fre2 = mix(.2, 1., Schlick);  //F0 = .2 - Hard clay... or close enough.\n            float amb = fre*fre2 + .06*ao;        \n\n            col = clamp(mix(vec3(.8, .5, .3), vec3(.5, .25, .125),(sp.y+1.)*.15), vec3(.5, .25, .125), vec3(1));\n            col = pow(col, vec3(1.5));\n            col = (col*(dif + .1) + fre2*spe)*shd*ao + amb*col;      \n        }\n\n        col = pow(max(col, 0.), vec3(.75));\n\n        u = fragCoord/Resolution.xy;\n\n        vec3 cGround = vec3(248,210,155)/256.;\n        vec3 cSky = vec3(177,186,213)/256.;\n\n        if (t < FAR){\n            \n            vec3 cFill;\n            if (mapCol.y == ID_PATH) {\n                cFill = vec3(1,.01,0.01);//mix(vec3(248,210,155)/256., vec3(248,185,155)/256., smoothstep(12.0,12.1,(sp.y)));\n            }\n            else if (mapCol.y == ID_SHIP) {\n               \tvec3 pShip = (sp-gRO)*gbaseShip;\n                cFill = mix(vec3(0,1,1),vec3(.7),smoothstep(.0,.1, pShip.x-1.3));\n            } else {\n                cFill = mix(vec3(248,210,155)/256., vec3(248,185,155)/256., smoothstep(.0,.1,sp.y-8.));\n                cFill = mix(cFill, vec3(1,0,0), .4*smoothstep(1000.,3000., gRO.z));\n            \tvec3 col3 = cos(sp.y*.08+1.1)*clamp(mix(vec3(.8, .5, .3), vec3(.5, .25, .125),(sp.y+1.)*.15), vec3(.5, .25, .125), vec3(1));\n\n                cFill = mix(cFill, col3, .5*smoothstep(6000.,8500., gRO.z));\n            }\n\n            col = mix(cFill,cSky,t/FAR)*(.5+.5*smoothstep(.4,.5,length(col)));\n            col = mix(col, vec3(.0), ed);\n            col = mix(vec3(0), col, .5+.5*smoothstep(.4,.41,cur)); // Surface curvature.;\n            ed2 += cur<.35?1.:0.;\n\n        } else {\n            col = mix(cSky*abs(1.-rd.y),vec3(1),smoothstep(1.3,1.4,length(col)));\n            col = mix(col, vec3(.1), ed);\n        \tfloat sun = max(dot(rd, normalize(lp - ro)), 0.); // Sun strength.\n\t\t\tcol = mix(vec3(0), col, smoothstep(.09/Resolution.y,.2/Resolution.y, abs(sun-.9892)));//.zyx;\t\n        }\n\n        col = mix(col, cSky*abs(1.-rd.y), sqrt(smoothstep(FAR - (ed <0. ? 200. : 100.), FAR, lastt1)));\n        \n    }  \n    \n    // BD frame\n    col = mix(col, vec3(.2),smoothstep(.0,1./Resolution.y,dBox));\n    col = mix(col, vec3(0.),smoothstep(1./Resolution.y,.0,abs(dBox)-.005));\n\n    return vec4(clamp(col, 0., 1.), ed2);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}