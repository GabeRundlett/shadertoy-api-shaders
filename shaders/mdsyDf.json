{
    "Shader": {
        "info": {
            "date": "1687280849",
            "description": "A bloom demo that allows to mix and match different mip mapping filters for down and up sampling.\nNote: the frist down sampling and the last up sampling filter don't seem to work correctly without ANGLE being turned on in the browser.",
            "flags": 48,
            "hasliked": 0,
            "id": "mdsyDf",
            "likes": 16,
            "name": "Bloom.",
            "published": 3,
            "tags": [
                "filtering",
                "bloom",
                "glow",
                "glare"
            ],
            "usePreview": 1,
            "username": "TinyTexel",
            "viewed": 475
        },
        "renderpass": [
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n// https://twitter.com/Mirko_Salm/status/1694024936040411509\n\n/*\n   A bloom demo that allows to mix and match different mip mapping filters for down and up sampling.\n   Note: the frist down sampling and the last up sampling filter don't seem to work correctly without ANGLE being turned on in the browser.\n  \n   Controls:\n   \n       Space - toggle off/on bloom + post-proc\n       Shift - toggle off/on post-proc\n       Tab   - toggle off/on ui\n       Ctrl  - toggle on/off quantization (useful for examining aliasing (crank up exposure))\n       <-/-> - decrease/increase exposure\n       1,2,3 - change test image\n       \n       Q - use BloomUpKernel4\n       W - use BloomUpKernel4B\n       E - use BloomUpKernel9\n       R - use BloomUpKernel9B\n       \n       A - use BloomDownKernel4\n       S - use BloomDownKernel9\n       D - use BloomDownKernel9B\n       E - use BloomDownKernel13\n       \n       -> filters can also be changed by clicking the arrows ui\n       \n       Common        : filtering + test image code\n       Buffer A/B/C/D: mip chain (down + up-sampling)\n       Image         : last up-sampling step + tonemapping + ui\n       \n \n    \n   Write-up structure:\n  #####################\n   \n       1. General approach\n\n       2. Relative sample alignment between mipmap levels\n\n       3. Buffer boundary handling\n\n       4. Filter kernels\n\n\n\n   1. General approach\n  #####################\n   \n   Typical state-of-the-art bloom implementations achieve their very wide blurs via mipmap filter chains.\n   The mip-mapping/blending approach implemented here looks like this (assuming only 4 mip levels):\n   \n  -> [mip0] -blend-> [result] ->\n      \n       |               ᗅ\n    1/2x1/2           2x2\n       V               |\n       \n    [mip1A] -blend-> [mip1B]\n      \n       |               ᗅ\n    1/2x1/2           2x2\n       V               |\n       \n    [mip2A] -blend-> [mip2B]   \n      \n       |               ᗅ\n    1/2x1/2           2x2\n       V               |\n                       |\n    [mip3A] -----------+\n   \n   '1/2x1/2' and '2x2' denote down-sampling and up-sampling steps, respectively.\n   \n   Since Shadertoy offers only a quite limited number of passes, the implementation here ended up being a bit less straightforward.\n   However, it still emulates the process described above faithfully (i.e. it does not just repeatedly blur a full-res buffer and blend it with itself).\n   \n  (Basically, I had to pack all mip levels starting with mip1 into a single buffer and distribute the mipmapping process over multiple frames. \n   Mip0 is re-computed with a frame offset at the very end. This way the entire image (every mip level) consistently lags a set number of frames behind.\n   An unfortunate consequence of this is that swapping filter kernels or changing the test image takes a couple of frames. And therefore can't really\n   be done while the shader is paused.)\n\n\n   \n   2. Relative sample alignment between mipmap levels\n  ####################################################\n   \n   There are basically two options for the relative sample alignment between two consecutive mip levels ('XX' marks a texel center):\n   \n   \n   StyleA:\n   \n   mip0: ---XX------XX------XX---\n                                               \n   mip1: -----XX----------XX-----              vec2 texcoord_mip1 = (vec2(texel_uv_uint) + 0.5) / texel_count_mip1;\n   \n   \n   StyleB:\n   \n   mip0: ---XX------XX------XX---\n                                               \n   mip1: -------XX--------------XX-------      vec2 texcoord_mip1 = vec2(texel_uv_uint * 2u + 1u) / texel_count_mip0;\n   \n   \n   StyleA evenly distributes the samples of mip1 so that they cover the same space as those of mip0.\n   StyleB, on the other hand, places mip1 samples strictly half way between mip0 samples.\n   \n   The major advantage of StyleB is that it allows the use of discrete kernels with fixed weights for down- and up-sampling.\n   To handle filtering with StyleA correctly one would need to compute a discrete kernel for each target sample individually at runtime.\n   Well, at least if the number of samples at the upper mip level is odd: \n   in the case that there is an even number of samples at the upper mip level both styles produce equivalent results.\n   \n   There is probably little reason not to favor StyleB. \n   At least as long as one does not care about the sample placement sometimes not being symmetric about the center of the buffer. \n   \n   \n   \n   3. Buffer boundary handling\n  #############################\n   \n   The sample distribution of a typical mipmap chain looks like an upside-down pyramid. For mipmaps of tiled textures this works just fine.\n   But for a bloom implementation it means we unnecessarily lose information during down-sampling and have to \n   extrapolate at the buffer edges during up-sampling which produces rather unreliable results.\n   A more elegant way to handle the buffer boundary is to pad each mip level (starting with mip1) with additional boundary samples:\n   \n   BoundaryWidth = 0: (default)\n   \n   mip0:                         -XX--XX--XX--XX--XX--XX--XX--XX-\n                                 \n   mip1:                         ---XX------XX------XX------XX---\n                                 \n   mip2:                         -------XX--------------XX-------\n                                                    \n                                                    \n   BoundaryWidth = 1: (minimal padding)\n\n   mip0:                         -XX--XX--XX--XX--XX--XX--XX--XX-\n                   \n   mip1:                 ---XX------XX------XX------XX------XX------XX---\n           \n   mip2: -------XX--------------XX--------------XX--------------XX--------------XX-------\n                                      \n                                      \n   Setting BoundaryWidth to the radius of the widest filter kernel ensures that texels at the edges of mip0 produce glare patterns that \n   are no different to the ones produces by texels closer to the center of the buffer (ignoring differences due to aliasing).\n   \n   For down-sampling the demo emulates a black borders address mode.\n   \n   \n   \n   4. Filter kernels\n  ###################\n\n   All filter kernels implemented here use hardware bilinear sampling to fetch and blend 4 texture samples at once. \n   The number at the end of each kernel's name denotes the number of bilinear samples used (the number of effective samples is not necessarily 4x as many).\n   \n<  BloomDownKernel4  - 16 samples; has about the same amount of aliasing as BloomDownKernel5; smallest reasonable kernel\n   BloomDownKernel5  - 16 samples; taken from \"Bandwidth-Efficient Rendering\" (Siggraph 2015); BloomDownKernel4 works just as well\n  (BloomDownKernel8  - 24 samples; not really a good tradeoff to lose 12 effective samples for 1 less bilinear sample compared to BloomDownKernel9)\n<  BloomDownKernel9  - 36 samples; pretty much optimal with regard to aliasing\n<  BloomDownKernel9B - 36 samples; improved radial symmetry, but slightly more aliasing when compared to BloomDownKernel9\n<  BloomDownKernel13 - 36 samples; taken from \"Next Generation Post Processing in Call of Duty Advanced Warfare\" (Siggraph 2014) but with better weights\n   \n>  BloomUpKernel4    - 16 samples; less aliasing than BloomUpKernel4B, but worse radial symmetry\n>  BloomUpKernel4B   - 12 samples; very good approximation of BloomUpKernel8; a bit more aliasing than BloomUpKernel4, but better radial symmetry\n   BloomUpKernel8    - 13 samples; taken from \"Bandwidth-Efficient Rendering\" (Siggraph 2015); BloomUpKernel4B works just as well\n>  BloomUpKernel9    - 36 samples; pretty much optimal with regard to aliasing, but worse radial symmetry than BloomUpKernel4B\n>  BloomUpKernel9B   - 16 samples; taken from \"Next Generation Post Processing in Call of Duty Advanced Warfare\" (Siggraph 2014)\n                                   more aliasing than BloomUpKernel9 + worse radial symmetry; less ALU though\n   \n   Filters highlighted by an '<' or '>' can be swapped in via the arrows ui (or the respective hot keys; see 'Controls').\n   \n   Useful filter combinations, from expensive to cheap:\n   \n   [1]: BloomDownKernel9 + BloomUpKernel9 : least amount of aliasing     | radial symmetry is okay\n   [2]: BloomDownKernel9 + BloomUpKernel4B: more aliasing than [1]       | good radial symmetry\n   [3]: BloomDownKernel4 + BloomUpKernel9 : more aliasing than [2]       | worse radial symmetry than [1] (but still acceptable)\n   [4]: BloomDownKernel4 + BloomUpKernel4B: a lot more aliasing than [3] | decent radial symmetry\n   \n   Alternatively, one could use different filters for different mip levels. For example, replacing BloomDownKernel9 with BloomDownKernel4 at\n   the first mip level (i.e. when down-sampling the full-res buffer) for [1] and [2] might result in significant performance savings.\n   \n   Using BloomDownKernel9B instead of BloomDownKernel9 improves the radial symmetry only marginally (in exchange for more aliasing).\n   Trying to improve the radial symmetry during up-sampling seems to be more effective. Down-sampling should probably focus more on antialiasing.\n   \n   The cheapest filter combination ([4]) stills works quite well at more moderate exposure levels.\n   \n   \n   A good way to test the filters is to use scene 2,3,4, or 5, crank up the exposure and toggle on the quantization.\n   Any inconsistencies in the iso lines of the glare pattern are usually due to aliasing. \n   Scene 4 is useful to catch bugs resulting from low-precision bilinear sampling (explained here: https://www.shadertoy.com/view/cslczj).\n   Scene 5 makes it easier to compare the differences in the shapes of the glare patterns\n   (pausing the shader does not really work for that since it takes a couple of frames to fully switch filters).\n   \n   \n   Related:\n    \n        visualization of the amplitude response of some of the down-sampling filters used here: \"Bloom Downsampling Filter\" \n        https://www.shadertoy.com/view/cslczj\n       \n        13 samples kernel design: \"Next Generation Post Processing in Call of Duty Advanced Warfare\" (Siggraph 2014)\n        http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\n        \n        source of BloomDownKernel5 + BloomUpKernel8: \"Bandwidth-Efficient Rendering\" (Siggraph 2015)\n        https://community.arm.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-20-66/siggraph2015_2D00_mmg_2D00_marius_2D00_notes.pdf\n        \n        9 samples kernel that tries to match the original 13 samples kernel: \"The Rendering of Inside, High Fidelity, Low Complexity\" (GDC 2016)\n        https://loopit.dk/rendering_inside.pdf#page=17\n        https://twitter.com/pixelmager/status/1691731512004071785\n*/\n\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel3, ivec2(keyCode, 2), 0).x;}\n\n//////////////////////////////////////////////////  Tonemapping  /////////////////////////////////////////////////////\n// ================================================================================================================ //\n\nfloat Pow2Toe(float x, float s, float end)\n{\n    if(x < end)\n    {\n        x *= 1.0 / end;\n        \n        return mix(x, x*x, s) * end; \n    }\n    else\n    {\n        float d = 1.0 + s;\n        \n        return x * d + (end - end * d);\n    }\n}\n\nfloat Reinhard(float x, float s, float start)\n{    \n    if(x <= start) return x;\n \n    float sx = 1.0 / (1.0 - start);\n    float ax = -start * sx;\n    \n    float sy = 1.0 - start;\n    float ay = start;\n    \n    x = x * sx + ax;\n    \n    x += x * x * s;\n    \n    float y = x / (x + 1.0);\n    \n    return y * sy + ay;\n}\n\n// x: [0, inf], s: (-1, 1]\nfloat SoftClip(float x, float s)\n{\n    return (1.0 + x - sqrt(1.0 - 2.0 * s * x + x*x)) / (1.0 + s);\n}\n\nfloat Bias(float x, float bias)\n{\n    float b = 1.0/bias;\n    \n    return x / ((2.0 - b) * x + b - 1.0);\n}\n\n// https://www.shadertoy.com/view/stsfzM\nvec3 Tonemap_sRGB(vec3 col, float toeStrength, vec2 linSeg, float shoulderStrength, float desatBias)\n{\n    if(col.r <= 0.0 || col.g <= 0.0 || col.b <= 0.0) return vec3(0.0);\n\n    vec3 wL = vec3(0.2126, 0.7152, 0.0722);\n    \n    float L0 = dot(col, wL);\n\n    float L0t = Reinhard(Pow2Toe(L0, toeStrength, linSeg.x), \n                                shoulderStrength, linSeg.y);\n\n    col *= L0t / L0;\n\n\n    float L1 = max(col.r, max(col.g, col.b));\n\n    float L1t = SoftClip(L1, 0.9);\n\n    col *= L1t / L1;\n\n\n    float L2 = dot(col, wL);\n\n    float sat = max(0.0, (L2 - L0t) / (L2 - 1.0));\n    \n    sat = Bias(sat, desatBias);\n    \n    col = mix(col, vec3(1.0), sat);\n\n    return col;\n}\n\n// ================================================================================================================ //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    Resolution = iResolution.xy;\n    Time = iTime;\n    Frame = iFrame;\n    \n    ReadState(iChannel1);\n    \n    vec2 uv = floor(uv0);\n    \n    vec3 col = vec3(0.0);\n\n    vec2 tc = uv0 / iResolution.xy;\n    \n    float image = EvalImage(uv0, DelayedTime);\n    \n    float v = mix(Upsample2x2(iChannel2, uv0, 1).a, image, 0.25);\n    v *= 2048.0;\n    v *= exp2(Exposure);\n    \n    col = vec3(v);\n    \n    if(ReadKeyToggle(KEY_SHIFT) == 0.0)\n    {\n        col *= mix(vec3(1.0, 0.05, 0.01), vec3(1.0), 0.04);\n        //col += vec3(0.0, 0.009, 0.015)*1.0;\n\n        col = Tonemap_sRGB(col, 0., vec2(0.18, 0.5), 0.0, 0.5);\n        //col.b = pow(col.b, 0.8); col.gb *= mix(col.gb, vec2(1.0), 0.75);\n    } \n    \n    outCol = vec4(pow(col, vec3(1.0/2.2)), 1.0);\n    \n    #if 1\n    if(ReadKeyToggle(KEY_CTRL) == 0.0)\n    {\n        float r2 = fract(dot(uv, vec2(0.7548776662, 0.56984029)));\n\n        outCol.rgb += (r2 - 0.5) * (1.0/256.0);\n    }\n    #endif\n\n    if(ReadKeyToggle(KEY_CTRL) != 0.0)\n    {\n        outCol.rgb = floor(outCol.rgb * 8.0) / 8.0;\n    }\n\n    if(ReadKeyToggle(KEY_SPACE) != 0.0)\n    {\n        outCol.rgb = vec3(pow(image, 1.0/2.2));\n    }\n    \n    if(ReadKeyToggle(KEY_TAB) == 0.0)\n    {\n        vec2 uvI;\n        vec2 ui = EvalUI(uv0, /*out:*/ uvI);\n        \n        outCol.rgb = mix(outCol.rgb, vec3(ui.y) * mix(vec3(0., 0.6, 1.0), vec3(1.0), 0.9), ui.x);\n    }\n    \n}\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    Resolution = iResolution.xy;\n    Time = iTime;\n    Frame = iFrame;\n    \n    ReadState(iChannel0);\n    \n    outCol = vec4(0.0);\n    \n    outCol.r = EvalImage(uv0, iTime);\n    outCol.g = Downsample2x2(iChannel0, uv0, 4).r;\n    \n    outCol.b = Upsample2x2(iChannel0, uv0, 7).g;\n    outCol.a = Upsample2x2(iChannel0, uv0, 3).b;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    Resolution = iResolution.xy;\n    ReadState(iChannel2);\n    \n    outCol = vec4(0.0);\n\n    outCol.r = Downsample2x2(iChannel0, uv0, 1).r;\n    outCol.g = Downsample2x2(iChannel0, uv0, 5).g;\n    \n    outCol.b = Upsample2x2(iChannel0, uv0, 6).b;\n    outCol.a = Upsample2x2(iChannel0, uv0, 3).a;    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    Resolution = iResolution.xy;\n    ReadState(iChannel2);\n    \n    outCol = vec4(0.0);\n\n    outCol.r = Downsample2x2(iChannel0, uv0, 2).r;\n    outCol.g = Downsample2x2(iChannel0, uv0, 6).g;\n    \n    outCol.b = Upsample2x2(iChannel0, uv0, 5).b;\n    outCol.a = Upsample2x2(iChannel0, uv0, 2).a;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel3, ivec2(keyCode, 2), 0).x;}\nfloat ReadKey(int keyCode) {return texelFetch(iChannel3, ivec2(keyCode, 1), 0).x;}\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    Resolution = iResolution.xy;\n    ReadState(iChannel1);\n    \n    outCol = vec4(0.0);\n\n    outCol.r = Downsample2x2(iChannel0, uv0, 3).r;\n    outCol.g = Downsample2x2(iChannel0, uv0, 7).g;\n    \n    outCol.b = Upsample2x2(iChannel0, uv0, 4).b;\n    \n    // global state\n    {\n        int x = int(floor(uv0.x));\n        int y = int(floor(uv0.y));\n        \n        float v = texelFetch(iChannel1, ivec2(x, 0), 0).a;\n        \n        if(y == 0)\n        {\n            if(x == 0)\n            {\n                if(ReadKey(KEY_N1) != 0.0) v = 0.0;\n                if(ReadKey(KEY_N2) != 0.0) v = 1.0;\n                if(ReadKey(KEY_N3) != 0.0) v = 2.0;\n                if(ReadKey(KEY_N4) != 0.0) v = 3.0;\n                if(ReadKey(KEY_N5) != 0.0) v = 4.0;\n                if(ReadKey(KEY_N6) != 0.0) v = 5.0;\n            }\n            else if(x == 1)\n            {\n                if(ReadKey(KEY_Q) != 0.0) v = 0.0;\n                if(ReadKey(KEY_W) != 0.0) v = 1.0;\n                if(ReadKey(KEY_E) != 0.0) v = 2.0;\n                if(ReadKey(KEY_R) != 0.0) v = 3.0;\n            }\n            else if(x == 2)\n            {\n                if(ReadKey(KEY_A) != 0.0) v = 0.0;\n                if(ReadKey(KEY_S) != 0.0) v = 1.0;\n                if(ReadKey(KEY_D) != 0.0) v = 2.0;\n                if(ReadKey(KEY_F) != 0.0) v = 3.0;\n            }\n            else if(x == 3)\n            {\n                if(ReadKey(KEY_LEFT ) != 0.0) v -= 1.0;\n                if(ReadKey(KEY_RIGHT) != 0.0) v += 1.0;\n            }\n            \n            if(x == 1 || x == 2)\n            {\n                vec2 uvI;\n                if(EvalUI(iMouse.zw, /*out:*/ uvI).y != 0.0)\n                {\n                    if((1.0 - uvI.y) + 1.0 == float(x))\n                    {\n                        v = uvI.x;\n                    }\n                }\n            }\n        }\n        \n        if(y == 1)\n        {\n            if(x == 0)\n            {\n                v = iTime;\n            }\n            else\n            {\n                v = texelFetch(iChannel1, ivec2(x - 1, 1), 0).a;\n            }\n        }\n        \n        outCol.a = v;\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    - UTILS + GLOBAL STATE\n    \n    - DOWN-SAMPLING\n    \n    - UP-SAMPLING\n    \n    - RNG\n    \n    - IMAGE\n    \n    - ARROWS UI\n*/\n\n/////////////////////////////////////////////////////////////////////////////////// UTILS + GLOBAL STATE\n//===============================================================================//\n\n#define READ_TEXTURE_COND (ReadKeyToggle(KEY_TAB) != 0.0)\n#define NO_DOWNSAMPLING_COND (ReadKeyToggle(KEY_SPACE) != 0.0)\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n/* http://keycode.info/ */\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_TAB 9\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n\n#define KEY_Q 81\n#define KEY_W 87\n#define KEY_E 69\n#define KEY_R 82\n#define KEY_T 84\n\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_F 70\n#define KEY_G 71\n\n#define KEY_N1 49\n#define KEY_N2 50\n#define KEY_N3 51\n#define KEY_N4 52\n#define KEY_N5 53\n#define KEY_N6 54\n#define KEY_N7 55\n#define KEY_N8 56\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvec2 cossin(float x) { return vec2(cos(x), sin(x)); }\n\nvec2 cmul(vec2 c0, vec2 c1)\n{\n\treturn vec2(c0.x * c1.x - c0.y * c1.y, \n\t\t        c0.y * c1.x + c0.x * c1.y);\n}\n\n\nvec2 Resolution;\nfloat Time;\nint Frame;\n\nfloat SceneId;\nfloat UpId;\nfloat DownId;\nfloat Exposure;\nfloat DelayedTime;\n\nvoid ReadState(sampler2D Tex)\n{\n    SceneId  = texelFetch(Tex, ivec2(0, 0), 0).a;\n    UpId     = texelFetch(Tex, ivec2(1, 0), 0).a;\n    DownId   = texelFetch(Tex, ivec2(2, 0), 0).a;\n    Exposure = texelFetch(Tex, ivec2(3, 0), 0).a;\n    \n    DelayedTime = texelFetch(Tex, ivec2(3, 1), 0).a;\n}\n\nconst float BoundaryWidth = 2.0;\n\nbool IsUVinBounds(vec2 uv, vec4 rect)\n{\n    uv -= rect.xy;\n    \n    return uv.x >= 0.0 && uv.x < rect.z && \n           uv.y >= 0.0 && uv.y < rect.w;\n}\n\nvoid GetRects(float n, out vec4 rectA, out vec4 rectB)\n{\n    vec2 res = Resolution.xy;\n    \n    res = ceil(res * 0.5) + BoundaryWidth * 2.0;\n\n    rectA = vec4(0.0, 0.0, Resolution.xy);\n    rectB = vec4(0.0, 0.0, res);\n    \n    float x = 0.0;\n    float y = res.y;\n    \n    for(float i = 1.0; i < n; ++i)\n    {\n        rectA = rectB;\n\n        res = ceil(res * 0.5) + BoundaryWidth * 2.0;\n\n        rectB = vec4(x, y, res);\n        \n        x += res.x;\n    }\n}\n\nfloat EvalImage(vec2 uv, int frameOff);\n\n\n\nvec4 SrcRect;\nvec4 Read(sampler2D Tex, vec2 tc)\n{\n#if 1\n    // read from rect region (mip chain is packed in single buffer (except mip0))\n    vec2 uv = tc * Resolution;\n    \n    vec2 m = clamp01(SrcRect.zw*0.5+0.5 - abs(uv - SrcRect.xy - 0.5 * SrcRect.zw));\n    \n    tc = clamp(uv, SrcRect.xy + 0.5, SrcRect.xy + SrcRect.zw - 0.5) / Resolution;\n    \n#else\n\n    vec2 m = clamp01(Resolution*0.5+0.5 - abs(tc-0.5) * Resolution);\n    \n#endif    \n\n    vec4 col = textureLod(Tex, tc, 0.0);\n        \n    return col * (m.x*m.y);// emulate black border address mode\n}\n\n//===============================================================================//\n/////////////////////////////////////////////////////////////////////////////////// UTILS + GLOBAL STATE\n\n\n/////////////////////////////////////////////////////////////////////////////////// DOWN-SAMPLING\n//===============================================================================//\n\n// 4x4 samples downsampling kernel implemented via 4 bilinear samples\nvec4 BloomDownKernel4(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 2.0 + 1.0;\n    uv -= BoundaryWidth * 2.0;\n    \n    vec2 tc = uv * RcpSrcTexRes;\n    \n    // optimal stop band\n    // float la = 1.0/4.0 + 1.0/16.0 + 1.0/32.0;//0.34375 ~ 0.3533943809268811\n    \n    // pascal kernel; more pleasant aliasing (matches BloomDownKernel5 well)\n    float la = 1.0/4.0;\n    \n\tvec2 o = (0.5 + la) * RcpSrcTexRes;\n    \n\tvec4 c = vec4(0.0);\n\tc += Read(Tex, tc + vec2(-1.0,-1.0) * o) * 0.25;\n\tc += Read(Tex, tc + vec2( 1.0,-1.0) * o) * 0.25;\n\tc += Read(Tex, tc + vec2(-1.0, 1.0) * o) * 0.25;\n\tc += Read(Tex, tc + vec2( 1.0, 1.0) * o) * 0.25;\n    \n    return c;\n}\n\n// \"Bandwidth-Efficient Rendering\" (Siggraph 2015)\n// works about as well as BloomDownKernel4\nvec4 BloomDownKernel5(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 2.0 + 1.0;\n    uv -= BoundaryWidth * 2.0;\n    \n    vec2 tc = uv * RcpSrcTexRes;\n    \n    vec2 o = RcpSrcTexRes;\n\n\tvec4 c = vec4(0.0);\n\n\tc += Read(Tex, tc) * 0.5;\n\n\tc += Read(Tex, tc + vec2(-1.0, -1.0) * o) * 0.125;\n\tc += Read(Tex, tc + vec2( 1.0,  1.0) * o) * 0.125;\n\tc += Read(Tex, tc + vec2( 1.0, -1.0) * o) * 0.125;\n\tc += Read(Tex, tc + vec2(-1.0,  1.0) * o) * 0.125;\n    \n    return c;\n}\n\n// 24 samples downsampling kernel implemented via 8 bilinear samples (meh)\nvec4 BloomDownKernel8(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 2.0 + 1.0;\n    uv -= BoundaryWidth * 2.0;\n    \n    vec2 tc = uv * RcpSrcTexRes;\n    \n    float a  = 0.13433339843769723; \n    float la = 1.0/2.0 + 1.0/4.0 + 1.0/8.0 + 1.0/32.0;// ~ 0.91081327364113440;\n    float lb = 1.0/4.0 + 1.0/8.0;// ~ 0.37269896061302266;\n\n\tvec2 oa = (1.5 + la) * RcpSrcTexRes;\n\tvec2 ob = (0.5 + lb) * RcpSrcTexRes;\n    \n\tvec4 ca = vec4(0.0);\n\tca += Read(Tex, tc + vec2(-1.0, 0.0) * oa);\n\tca += Read(Tex, tc + vec2( 1.0, 0.0) * oa);\n\tca += Read(Tex, tc + vec2( 0.0,-1.0) * oa);\n\tca += Read(Tex, tc + vec2( 0.0, 1.0) * oa);\n    \n    vec4 cb = vec4(0.0);\n\tcb += Read(Tex, tc + vec2(-1.0,-1.0) * ob);\n\tcb += Read(Tex, tc + vec2( 1.0,-1.0) * ob);\n\tcb += Read(Tex, tc + vec2(-1.0, 1.0) * ob);\n\tcb += Read(Tex, tc + vec2( 1.0, 1.0) * ob);\n    \n    return cb * (0.25 - a * 0.25) + \n           ca * (       a * 0.25);\n}\n\n// 36 samples downsampling kernel implemented via 9 bilinear samples \n// pretty much optimal with regard to aliasing\nvec4 BloomDownKernel9(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 2.0 + 1.0;\n    uv -= BoundaryWidth * 2.0;\n    \n    vec2 tc = uv * RcpSrcTexRes;\n    \n    // optimal stop band but o is chosen so as to keep frequency response \n    // symmetric despite lower-precision hardware bilinear filtering\n    float a = 7.49862 / 32.0;\n\tfloat b = 1.0 - a * 2.0;\n\tfloat o = 1.5 + (0.25+1.0/64.0);\n\n    vec2 off = o * RcpSrcTexRes;\n\n\tvec4 c = vec4(0.0);\n    \n    c += Read(Tex, tc) * (b * b);\n    \n\tc += Read(Tex, tc + vec2(-1.0, 0.0) * off) * (a * b);\n\tc += Read(Tex, tc + vec2( 1.0, 0.0) * off) * (a * b);\n\tc += Read(Tex, tc + vec2( 0.0,-1.0) * off) * (a * b);\n\tc += Read(Tex, tc + vec2( 0.0, 1.0) * off) * (a * b);\n    \n\tc += Read(Tex, tc + vec2(-1.0,-1.0) * off) * (a * a);\n\tc += Read(Tex, tc + vec2( 1.0,-1.0) * off) * (a * a);\n\tc += Read(Tex, tc + vec2(-1.0, 1.0) * off) * (a * a);\n\tc += Read(Tex, tc + vec2( 1.0, 1.0) * off) * (a * a);    \n\n\treturn c;\n}\n\n// non-separable variant; improved radial symmetry (but more aliasing)\nvec4 BloomDownKernel9B(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 2.0 + 1.0;\n    uv -= BoundaryWidth * 2.0;\n    \n    vec2 tc = uv * RcpSrcTexRes;\n    \n#if 1\n    // radial symmetry\n    float w0 = 0.302001;\n\tfloat a  = 0.127963;\n\tfloat b  = 0.0465365;\n\tfloat oa = 1.5 + 0.25;// ~ 0.250795\n\tfloat ob = 1.5 + (0.125+1.0/16.0);       \n#else\n    // params by Mikkel Gjoel; half Nyquist = 0 (along x & y)\n    // (https://twitter.com/pixelmager/status/1691731512004071785)\n    float w0 = 4.0/16.0;\n\tfloat a  = 2.0/16.0;\n\tfloat b  = 1.0/16.0;\n\tfloat oa = 1.5 + 0.25;\n\tfloat ob = 1.5 + 0.2052; //(1.0 - 0.7948);\n#endif\n\n    vec2 oa2 = oa * RcpSrcTexRes;\n    vec2 ob2 = ob * RcpSrcTexRes;\n\n\tvec4 c = vec4(0.0);\n    \n    c += Read(Tex, tc) * w0;\n\n\tc += Read(Tex, tc + vec2(-1.0, 0.0) * oa2) * a;\n\tc += Read(Tex, tc + vec2( 1.0, 0.0) * oa2) * a;\n\tc += Read(Tex, tc + vec2( 0.0,-1.0) * oa2) * a;\n\tc += Read(Tex, tc + vec2( 0.0, 1.0) * oa2) * a;\n    \n\tc += Read(Tex, tc + vec2(-1.0,-1.0) * ob2) * b;\n\tc += Read(Tex, tc + vec2( 1.0,-1.0) * ob2) * b;\n\tc += Read(Tex, tc + vec2(-1.0, 1.0) * ob2) * b;\n\tc += Read(Tex, tc + vec2( 1.0, 1.0) * ob2) * b;\n\n\treturn c;\n}\n\n// \"Next Generation Post Processing in Call of Duty Advanced Warfare\" (Siggraph 2014)\nvec4 BloomDownKernel13(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 2.0 + 1.0;\n    uv -= BoundaryWidth * 2.0;\n    \n    vec2 tc = uv * RcpSrcTexRes;\n\n#if 0\n    // radial symmetry\n    float w0 = 0.144622;\n    float wa = 0.105596;\n    float wb = 0.0822943;\n    float wc = 0.0259547;\n#elif 1\n    // optimal stop band\n    float w0 = 0.173633;\n    float wa = 0.0991668;\n    float wb = 0.0744867;\n    float wc = 0.0329382;\n#else\n    // original weights; half Nyquist = 0 \n    float w0 = 4.0/32.0;// 0.125\n    float wa = 4.0/32.0;// 0.125\n    float wb = 2.0/32.0;// 0.0625\n    float wc = 1.0/32.0;// 0.03125\n#endif\n\n    vec2 off = RcpSrcTexRes;\n\n\tvec4 c = vec4(0.0);\n\n\tc += Read(Tex, tc) * w0;\n    \n\tc += Read(Tex, tc + vec2(-1.0,-1.0) * off) * wa;\n\tc += Read(Tex, tc + vec2( 1.0, 1.0) * off) * wa;\n\tc += Read(Tex, tc + vec2( 1.0,-1.0) * off) * wa;\n\tc += Read(Tex, tc + vec2(-1.0, 1.0) * off) * wa;\n    \n\tc += Read(Tex, tc + vec2( 2.0, 0.0) * off) * wb;\n\tc += Read(Tex, tc + vec2(-2.0, 0.0) * off) * wb;\n\tc += Read(Tex, tc + vec2( 0.0, 2.0) * off) * wb;\n\tc += Read(Tex, tc + vec2( 0.0,-2.0) * off) * wb;\n    \n\tc += Read(Tex, tc + vec2( 2.0, 2.0) * off) * wc;\n\tc += Read(Tex, tc + vec2(-2.0, 2.0) * off) * wc;\n\tc += Read(Tex, tc + vec2( 2.0,-2.0) * off) * wc;\n\tc += Read(Tex, tc + vec2(-2.0,-2.0) * off) * wc;\n\n    return c;\n}\n\nvec4 Downsample2x2(sampler2D Tex, vec2 uv0, int n)\n{\n    vec4 col = textureLod(Tex, uv0 / Resolution.xy, 0.0);\n    \n    if(n == 1) col = vec4(0.0);\n    \n    vec4 rectA, rectB;\n    GetRects(float(n), rectA, rectB);\n    \n    if(IsUVinBounds(uv0, rectB))\n    {\n        SrcRect = rectA;\n    \n        vec2 uv = floor(uv0) - rectB.xy + rectA.xy * 0.5;\n        \n        if(DownId == 0.0) col = BloomDownKernel4 (Tex, uv);\n        if(DownId == 1.0) col = BloomDownKernel9 (Tex, uv);\n        if(DownId == 2.0) col = BloomDownKernel9B(Tex, uv);\n        if(DownId == 3.0) col = BloomDownKernel13(Tex, uv);\n    }\n    \n    return col;\n}\n\n//===============================================================================//\n/////////////////////////////////////////////////////////////////////////////////// DOWN-SAMPLING\n\n\n/////////////////////////////////////////////////////////////////////////////////// UP-SAMPLING\n//===============================================================================//\n\nvec4 BloomUpKernel4(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 0.5 + 0.5;\n    uv += BoundaryWidth;\n    \n    vec2 uvI = floor(uv);\n    vec2 uvF = uv - uvI;\n\n    vec2 tc = uvI * RcpSrcTexRes.xy;\n\n    // optimal stop-band\n    float lw = 0.357386;\n    float la = 25.0/32.0;// 0.78125  ~ 0.779627; \n    float lb =  3.0/64.0;// 0.046875 ~ 0.0493871;\n     \n    vec2 l = vec2(-1.5 + la, 0.5 + lb);\n    \n    vec2 lx = uvF.x == 0.0 ? l.xy : -l.yx;\n    vec2 ly = uvF.y == 0.0 ? l.xy : -l.yx;\n    \n    lx *= RcpSrcTexRes.xx;\n    ly *= RcpSrcTexRes.yy;\n    \n    vec4 c00 = Read(Tex, tc + vec2(lx.x, ly.x));\n    vec4 c10 = Read(Tex, tc + vec2(lx.y, ly.x));\n    vec4 c01 = Read(Tex, tc + vec2(lx.x, ly.y));\n    vec4 c11 = Read(Tex, tc + vec2(lx.y, ly.y));\n    \n    vec2 w = abs(uvF * 2.0 - lw);\n    \n    vec4 cx0 = c00 * (1.0 - w.x) + (c10 * w.x);\n    vec4 cx1 = c01 * (1.0 - w.x) + (c11 * w.x);\n    \n    vec4 cxy = cx0 * (1.0 - w.y) + (cx1 * w.y);\n    \n    return cxy;\n}\n\n// very good approximation of BloomUpKernel8; good radial symmetry\n// but more aliasing than BloomUpKernel4\nvec4 BloomUpKernel4B(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 0.5 + 0.5;\n    uv += BoundaryWidth;\n    \n    vec2 uvI = floor(uv);\n    vec2 uvF = uv - uvI;\n\n    vec2 tc = uvI * RcpSrcTexRes.xy;\n    \n   #if 1\n    vec2 l00 = vec2(11.0/32.0, 17.0/32.0);// 0.34375  ~ 0.347209 \n    vec2 l10 = vec2( 7.0/64.0, 11.0/32.0);// 0.109375 ~ 0.109840 \n    vec2 l01 = vec2(11.0/32.0,  7.0/64.0);// 0.34375  ~ 0.334045 \n    vec2 l11 = vec2(17.0/32.0, 11.0/32.0);// 0.53125  ~ 0.526425 \n   #else\n    vec2 l00 = vec2(0.347209, 0.526425);\n    vec2 l10 = vec2(0.109840, 0.334045);\n    vec2 l01 = vec2(0.334045, 0.109840);\n    vec2 l11 = vec2(0.526425, 0.347209);\n   #endif\n    \n    vec4 w = vec4(0.288971, 0.211029, 0.211029, 0.288971);\n    \n    bool flipX = uvF.x != 0.0;\n    bool flipY = uvF.y != 0.0;\n    \n    if(flipX)\n    {\n        vec2 tmp = l11; l11 = l10; l10 = tmp;\n        \n        l00.x = 1.0 - l00.x;\n        l10.x = 1.0 - l10.x;\n        l01.x = 1.0 - l01.x;\n        l11.x = 1.0 - l11.x;\n        \n        w = vec4(w.x, w.w, w.z, w.y);\n    }\n    \n    if(flipY)\n    {\n        vec2 tmp = l00; l00 = l01; l01 = tmp;\n        \n        l00.y = 1.0 - l00.y;\n        l10.y = 1.0 - l10.y;\n        l01.y = 1.0 - l01.y;\n        l11.y = 1.0 - l11.y;\n        \n        w = vec4(w.z, w.y, w.x, w.w);\n    }\n    \n    vec4 col = vec4(0.0);\n    \n    col += Read(Tex, tc + (vec2(-0.5, -1.5) + l00) * RcpSrcTexRes) * w.x;\n    col += Read(Tex, tc + (vec2( 0.5, -0.5) + l10) * RcpSrcTexRes) * w.y;\n    col += Read(Tex, tc + (vec2(-0.5,  0.5) + l01) * RcpSrcTexRes) * w.z;\n    col += Read(Tex, tc + (vec2(-1.5, -0.5) + l11) * RcpSrcTexRes) * w.w;\n    \n    return col;\n}\n\n\n// \"Bandwidth-Efficient Rendering\" (Siggraph 2015)\n// good radial symmetry\nvec4 BloomUpKernel8(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 0.5 + 0.25;\n    uv += BoundaryWidth;\n    \n    vec2 tc = uv * RcpSrcTexRes.xy;\n    \n    float a = 1.0/12.0;\n    float b = 2.0/12.0;\n    \n    vec2 s = RcpSrcTexRes;    \n    vec4 col = vec4(0.0);\n    \n    col += a * Read(Tex, tc + vec2( 1.0, 0.0) * s);\n    col += a * Read(Tex, tc + vec2(-1.0, 0.0) * s);\n    col += a * Read(Tex, tc + vec2( 0.0, 1.0) * s);\n    col += a * Read(Tex, tc + vec2( 0.0,-1.0) * s);\n    \n    col += b * Read(Tex, tc + vec2( 0.5, 0.5) * s);\n    col += b * Read(Tex, tc + vec2(-0.5, 0.5) * s);\n    col += b * Read(Tex, tc + vec2( 0.5,-0.5) * s);\n    col += b * Read(Tex, tc + vec2(-0.5,-0.5) * s);\n    \n    return col;\n}\n\n// low aliasing; radial symmetry worse than BloomUpKernel8/BloomUpKernel4B\nvec4 BloomUpKernel9(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 0.5 + 0.5;\n    uv += BoundaryWidth;\n    \n    vec2 uvI = floor(uv);\n    vec2 uvF = uv - uvI;\n\n    vec2 tc = uvI * RcpSrcTexRes.xy;\n\n    // optimal stop-band\n    float la = 57.0/64.0;// 0.890625 ~ 0.897872\n    float lb =  7.0/16.0;// 0.4375   ~ 0.438573\n    float lc =  1.0/64.0;// 0.015625 ~ 0.0194411\n    \n    float wa = 0.206516;\n    float wb = 0.712722;\n    float wc = 0.0807621;\n\n    vec3 l = vec3(-2.5 + la, -0.5 + lb, 1.5 + lc);\n    \n    vec3 lx = uvF.x == 0.0 ? l.xyz : -l.zyx;\n    vec3 ly = uvF.y == 0.0 ? l.xyz : -l.zyx;\n    \n    vec3 wx = vec3(uvF.x == 0.0 ? wa : wc, wb, uvF.x == 0.0 ? wc : wa);\n    vec3 wy = vec3(uvF.y == 0.0 ? wa : wc, wb, uvF.y == 0.0 ? wc : wa);\n    \n    lx *= RcpSrcTexRes.xxx;\n    ly *= RcpSrcTexRes.yyy;\n    \n    vec4 col = vec4(0.0);\n    \n    col += Read(Tex, tc + vec2(lx.x, ly.x)) * (wx.x * wy.x);\n    col += Read(Tex, tc + vec2(lx.y, ly.x)) * (wx.y * wy.x);\n    col += Read(Tex, tc + vec2(lx.z, ly.x)) * (wx.z * wy.x);\n    \n    col += Read(Tex, tc + vec2(lx.x, ly.y)) * (wx.x * wy.y);\n    col += Read(Tex, tc + vec2(lx.y, ly.y)) * (wx.y * wy.y);\n    col += Read(Tex, tc + vec2(lx.z, ly.y)) * (wx.z * wy.y);\n    \n    col += Read(Tex, tc + vec2(lx.x, ly.z)) * (wx.x * wy.z);\n    col += Read(Tex, tc + vec2(lx.y, ly.z)) * (wx.y * wy.z);\n    col += Read(Tex, tc + vec2(lx.z, ly.z)) * (wx.z * wy.z);\n    \n    return col;\n}\n\n// \"Next Generation Post Processing in Call of Duty Advanced Warfare\" (Siggraph 2014)\n//  more aliasing than BloomUpKernel9 + worse radial symmetry; less ALU though\nvec4 BloomUpKernel9B(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 0.5 + 0.25;\n    uv += BoundaryWidth;\n    \n    vec2 tc = uv * RcpSrcTexRes.xy;\n    \n    float a = 2.0/16.0;\n    float b = 1.0/16.0;\n    float c = 4.0/16.0;\n    \n    vec2 s = RcpSrcTexRes;\n    \n    vec4 col = vec4(0.0);\n    \n    col += a * Read(Tex, tc + vec2( 1.0, 0.0) * s);\n    col += a * Read(Tex, tc + vec2(-1.0, 0.0) * s);\n    col += a * Read(Tex, tc + vec2( 0.0, 1.0) * s);\n    col += a * Read(Tex, tc + vec2( 0.0,-1.0) * s);\n    col += b * Read(Tex, tc + vec2( 1.0, 1.0) * s);\n    col += b * Read(Tex, tc + vec2(-1.0, 1.0) * s);\n    col += b * Read(Tex, tc + vec2( 1.0,-1.0) * s);\n    col += b * Read(Tex, tc + vec2(-1.0,-1.0) * s);\n    col += c * Read(Tex, tc + vec2( 0.0, 0.0) * s);\n    \n    return col;\n}\n\nvec4 Upsample2x2(sampler2D Tex, vec2 uv0, int n)\n{\n    vec4 col = textureLod(Tex, uv0 / Resolution.xy, 0.0);\n    \n    vec4 rectA, rectB;\n    GetRects(float(n), rectA, rectB);\n    \n    if(IsUVinBounds(uv0, rectA))\n    {\n        SrcRect = rectB;\n    \n        vec2 uv = floor(uv0) - rectA.xy + rectB.xy * 2.0;\n        \n        vec4 col2 = col;\n        \n        if(UpId == 0.0) col2 = BloomUpKernel4 (Tex, uv);\n        if(UpId == 1.0) col2 = BloomUpKernel4B(Tex, uv);\n        if(UpId == 2.0) col2 = BloomUpKernel9 (Tex, uv);\n        if(UpId == 3.0) col2 = BloomUpKernel9B(Tex, uv);\n        \n        //col = mix(col, col2, exp2(-float(n - 1) * 0.125*0.5));\n        col = n == 1 ? col2 : mix(col2, col, 0.1);\n    }\n    \n    return col;\n}\n\n//===============================================================================//\n/////////////////////////////////////////////////////////////////////////////////// UP-SAMPLING\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// RNG\n//==============================================================================================================================================//\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n// https://probablydance.com/2018/06/16/fibonacci-hashing-the-optimization-that-the-world-forgot-or-a-better-alternative-to-integer-modulo/\nconst float rPhif1 =      0.6180340;\nconst vec2  rPhif2 = vec2(0.7548777, 0.5698403);\nconst vec3  rPhif3 = vec3(0.8191725, 0.6710436, 0.5497005);\nconst vec4  rPhif4 = vec4(0.8566749, 0.7338919, 0.6287067, 0.5385973);\n\nconst uint  rPhi1 =       2654435769u;\nconst uvec2 rPhi2 = uvec2(3242174889u, 2447445413u);\nconst uvec3 rPhi3 = uvec3(3518319153u, 2882110345u, 2360945575u);\nconst uvec4 rPhi4 = uvec4(3679390609u, 3152041523u, 2700274805u, 2313257605u);\n\n// low bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\n// minimal bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c)\n{ \n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u;\n}\n\n// Pierre L'Ecuyer - \"TABLES OF LINEAR CONGRUENTIAL GENERATORS OF DIFFERENT SIZES AND GOOD LATTICE STRUCTURE\"\n// https://www.ams.org/journals/mcom/1999-68-225/S0025-5718-99-00996-5/S0025-5718-99-00996-5.pdf\nconst uint lcgM = 2891336453u;// ideal for 32 bits with odd c\n\nuint lcg(uint h)\n{\n    return h * lcgM + 0x5C995C6Du;\n}\n\n#define SEED uvec4(0x5C995C6Du, 0x6A3C6A57u, 0xC65536CBu, 0x3563995Fu)\n\n// Melissa E. O’Neill - \"PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation\"\n// https://www.cs.hmc.edu/tr/hmc-cs-2014-0905.pdf\n\n// Mark Jarzynski & Marc Olano - \"Hash Functions for GPU Rendering\"\n// http://jcgt.org/published/0009/03/02/ | https://www.shadertoy.com/view/XlGcRh\nuvec3 pcg3Mix(uvec3 h)\n{\n    h.x += h.y * h.z; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    \n    return h;\n}\n\nuvec3 pcg3Permute(uvec3 h)\n{\n    h = pcg3Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg3Mix(h);\n}\n\nuvec3 pcg3(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg3Permute(uvec3(2447445413u, state, 3242174889u));\n}\n\nuvec3 pcg3(uvec3 h, uint seed)\n{\n    uvec3 c = (seed << 1u) ^ SEED.xyz;\n    \n    return pcg3Permute(h * lcgM + c);\n}\n\nuvec4 pcg4Mix(uvec4 h)\n{\n    h.x += h.y * h.w; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    h.w += h.y * h.z;\n    \n    return h;\n}\n\nuvec4 pcg4Permute(uvec4 h)\n{\n    h = pcg4Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg4Mix(h);\n}\n\nuvec4 pcg4(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg4Permute(uvec4(2882110345u, state, 3518319153u, 2360945575u));\n}\n\nuvec4 pcg4(uvec4 h, uint seed)\n{\n    uvec4 c = (seed << 1u) ^ SEED;\n\n    return pcg4Permute(h * lcgM + c);\n}\n\nuint pcg(inout uint state)\n{\n    state = lcg(state);\n    \n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    \n    return (word >> 22u) ^ word;\n}\n\nuint pcg(uint h, uint seed)\n{\n    uint c = (seed << 1u) ^ SEED.x;\n\n    h = h * lcgM + c;\n    \n    h = ((h >> ((h >> 28u) + 4u)) ^ h) * 277803737u;\n    \n    return (h >> 22u) ^ h;\n}\n\n#undef SEED\n\n//---------------------------------------------------------------------------------------------//\n\nuint  Hash(inout uint state  ) { return pcg(state); }\nuint  Hash(uint  h, uint seed) { return pcg(h, seed); }\nuvec2 Hash(uvec2 h, uint seed) { return pcg3(uvec3(h, 0u), seed).xy; }\nuvec3 Hash(uvec3 h, uint seed) { return pcg3(h, seed); }\nuvec4 Hash(uvec4 h, uint seed) { return pcg4(h, seed); }\n\nvec4  Hash01x4(inout uint state) { return Float01(uvec4(pcg(state), pcg(state), pcg(state), pcg(state))); }\nvec3  Hash01x3(inout uint state) { return Float01(uvec3(pcg(state), pcg(state), pcg(state))); }\nvec2  Hash01x2(inout uint state) { return Float01(uvec2(pcg(state), pcg(state))); }\nfloat Hash01  (inout uint state) { return Float01(      pcg(state)); }\n\nvec4  Hash11x4(inout uint state) { return Float11(uvec4(pcg(state), pcg(state), pcg(state), pcg(state))); }\nvec3  Hash11x3(inout uint state) { return Float11(uvec3(pcg(state), pcg(state), pcg(state))); }\nvec2  Hash11x2(inout uint state) { return Float11(uvec2(pcg(state), pcg(state))); }\nfloat Hash11  (inout uint state) { return Float11(      pcg(state)); }\n\n\nvec4 Hash01x4(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed)); }\nvec4 Hash01x4(vec3  v, uint seed) { return Hash01x4(vec4(v, 0.0          ), seed); }\nvec4 Hash01x4(vec2  v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash01x4(float v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash01x3(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash01x3(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed)); }\nvec3 Hash01x3(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed); }\nvec3 Hash01x3(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash01x2(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash01x2(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash01(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).x); }\nfloat Hash01(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).x); }\nfloat Hash01(vec2  v, uint seed) { return Float01(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash01(float v, uint seed) { return Float01(pcg(asuint2(v), seed)); }\n\n\nvec4 Hash11x4(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed)); }\nvec4 Hash11x4(vec3  v, uint seed) { return Hash11x4(vec4(v, 0.0          ), seed); }\nvec4 Hash11x4(vec2  v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash11x4(float v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash11x3(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash11x3(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed)); }\nvec3 Hash11x3(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed); }\nvec3 Hash11x3(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash11x2(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash11x2(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash11(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).x); }\nfloat Hash11(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).x); }\nfloat Hash11(vec2  v, uint seed) { return Float11(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash11(float v, uint seed) { return Float11(pcg(asuint2(v), seed)); }\n\n//==============================================================================================================================================//\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// RNG\n\n\n/////////////////////////////////////////////////////////////////////////////////// IMAGE\n//===============================================================================//\n\n// https://www.shadertoy.com/view/cdjBzc\nfloat disk_mb_aa(vec2 tc, float r, float s, vec2 a, vec2 b)\n{\n    vec2 vec = b - a;\n    \n    tc -= a;\n    \n    float tt = dot(vec, vec);\n        \n    float rcptt = 1.0 / tt;\n    \n    vec2 dirX = vec * rcptt;\n    \n    vec2 dirY = vec2(-dirX.y, dirX.x);\n        \n    float x = dot(tc, dirX);\n    float y = dot(tc, dirY);\n    \n    float r0 = sqrt(max(0.0, r*r * rcptt - y*y));\n    \n    float u = r0 + 0.5;\n    \n    float v = clamp(u - abs(-x - r0 + u), 0.0, min(2.0 * r0, 1.0));\n    \n    if(tt == 0.0) v = dot(tc, tc) < r*r ? 1.0 : 0.0;\n    \n    // aa\n    {\n        vec2 p = vec * (tt == 0.0 ? 0.0 : clamp(x, 0.0, 1.0));\n\n        float l = length(tc - p);\n\n        float m = clamp((r - l) * s * 0.5, 0.0, 1.0);\n        //m = m > 0.5 ? 1.0 : 0.0;\n        v *= m*m*(3.0-2.0*m);\n    }\n    \n    return v;\n}\n\nfloat EvalImage0B(vec2 uv, float ang0, float speed, vec2 rr, uint seed, float time)\n{\n    uv = cmul(uv, cossin(ang0));\n    \n    float t = time * 60.0;\n    \n    uv.x -= t * speed;\n\n    float s = 128.0;\n    \n    uv /= s;\n    \n    uv += Hash11x2(vec2(1.0, 2.0), seed);\n    \n    vec2 uvI = floor(uv);\n    vec2 uvF = uv - uvI;\n    \n    vec4 h = Hash11x4(uvI, seed);\n    vec4 h2 = Hash11x4(uvI, seed ^ 1426236u);\n    \n    vec2 uv2 = (uvF - 0.5);\n    \n    float rs = rr.y / s;\n    float u = 0.5 - rs;\n    \n    float ang = h.x * Pi;\n    vec2 dir = vec2(cos(ang), sin(ang));\n    float o = 1.0;// h.y;\n    \n    vec2 p = vec2(0.0);\n    \n    p += dir * vec2(0.0, (u)*(1.0-abs(o)));\n    \n    vec2 p2 = p;\n    \n    p.x += sin(t * 0.005 + Pi * h2.z) * (u);//TODO speed\n    p.y += sin(t * 0.01  + Pi * h.z) * (u * 0.5 * o);\n    p.y += sin(t * 0.001 + Pi * h.w) * (u * 0.5 * o);\n\n    float to = 1.5;\n    float t2 = t - to;\n    p2.x += sin(t2 * 0.005 + Pi * h2.z) * (u);//TODO speed\n    p2.y += sin(t2 * 0.01  + Pi * h.z) * (u * 0.5 * o);\n    p2.y += sin(t2 * 0.001 + Pi * h.w) * (u * 0.5 * o);\n\n    p2.x -= speed / s * to;\n    p2.x = max(-0.5+rs, p2.x);\n\n    float z = 0.0;\n    z += cos(t * 0.01  + Pi * h.z) * (0.5*o);\n    z += cos(t * 0.001 + Pi * h.w) * (0.5*o);\n    \n    float r = mix(rr.x, rr.y, pow(z*0.5+0.5,2.0));\n    \n    float v = disk_mb_aa(uv2, r/s, s, p, p2);\n    \n    return v * mix(0.125, 1.0, sin(t * 0.02 + Pi * h2.x)*0.5+0.5)/(r*r*r*r);\n}\n\nfloat EvalImage0A(vec2 uv, float time)\n{\n    float a = 0.05;\n    \n    float v = 0.0;\n    v += EvalImage0B(uv, (a +  0.01) * Pi, 4.7, vec2(1.5, 4.0), 325852u, time)*1.0;\n    v += EvalImage0B(uv, (a + -0.01) * Pi, 3.9, vec2(4.0, 8.0), 152678u, time)*0.15;\n    v += EvalImage0B(uv, (a + -0.03) * Pi, 3.1, vec2(8.0, 16.0), 3457267u, time)*0.125;\n    \n    return v;\n}\n\nfloat EvalImage0(vec2 uv, float time)\n{\n    float fo = float(time);\n    \n#if 0\n    float v = 0.0;\n    float count = 8.0;\n    float wa = 0.0;\n    for(float i = 0.0; i < count; ++i)\n    {\n        float w = 1.0 - i/(count);\n        //w *= w;\n        w = 1.0;\n        \n        v += EvalImage0A(uv, fo - i/(count)*1.5) * w;\n        wa += w;\n    }\n    return v / wa;\n#else\n    return EvalImage0A(uv, time);\n#endif\n}\n\nfloat EvalImage1(vec2 uv, float time, float r)\n{\n    vec2 uvr = Resolution * 0.5 + 0.;\n\n    float t = time * 1.0;\n\n    uvr += vec2(cos(t), sin(t)) * floor(Resolution.y*0.5+0.0) * vec2(1.0, 1.0) * r;\n\n    // aa\n    if(false)\n    {\n        float r = 2.5;\n        \n        float l = length(uv - uvr);\n\n        float m = clamp((r - l) * 1.0 * 0.125, 0.0, 1.0);\n        m = 1.0-m;\n        m*=m;\n        m*=m;\n        m = 1.0-m;\n        \n        return m*m*(3.0-2.0*m);\n    }\n    \n    uvr = floor(uvr) + 0.5;\n    \n    return uv.x == uvr.x && uv.y == uvr.y ? 1.0 : 0.0;\n\n    return 0.0;\n}\n\nfloat EvalImage1b(vec2 uv, float time)\n{\n    vec2 uvr = Resolution * 0.5 + 0.;\n\n    float t = time * 2.0;\n\n    float t0 = floor(fract(t) * 4.0);\n    \n    float x, y;\n    \n    if(t0 < 2.0)\n    {\n        x = t0;\n        y = 0.0;\n    }\n    else\n    {\n        x = 3.0 - t0;\n        y = 1.0;\n    }\n\n    uvr += vec2(x, y);\n\n    uvr = floor(uvr) + 0.5;\n    \n    return uv.x == uvr.x && uv.y == uvr.y ? 1.0 : 0.0;\n\n    return 0.0;\n}\n\nfloat EvalImage2(vec2 uv, float time)\n{\n    vec2 res = Resolution;\n    vec2 o = floor(Resolution * (sin(time * 0.5) * 0.5 + 0.5));\n    if(uv.x == o.x + 0.5                  && uv.y == 0.5        ) return 1.0;\n    if(uv.x == (Resolution.x - o.x) - 0.5 && uv.y == res.y - 0.5) return 1.0;\n    if(uv.y == (Resolution.y - o.y) - 0.5 && uv.x == 0.5        ) return 1.0;\n    if(uv.y == o.y + 0.5                  && uv.x == res.x - 0.5) return 1.0;\n    \n    return 0.0;\n}\n\nfloat EvalImage(vec2 uv, float time)\n{\n    if(SceneId == 0.0) return EvalImage0(uv, time);\n    if(SceneId == 1.0) return EvalImage1(uv, time, 1.);\n    if(SceneId == 2.0) return EvalImage1(uv, time, 0.25);\n    if(SceneId == 3.0) return EvalImage1b(uv, time);\n    if(SceneId == 4.0) return EvalImage1(uv, time, 0.0);\n    if(SceneId == 5.0) return EvalImage2(uv, time);\n    \n    return 0.0;\n}\n\n//===============================================================================//\n/////////////////////////////////////////////////////////////////////////////////// IMAGE\n\n\n/////////////////////////////////////////////////////////////////////////////////// ARROWS UI\n//===============================================================================//\n\nfloat tri0(vec2 tc, float r, float r2)\n{\n    float v = -tc.y;\n    \n    float ang = Pi * 0.1666;\n    vec2 dir = vec2(cos(ang), sin(ang));\n    \n    v = max(v, dot(tc, dir));\n    v = max(v, dot(tc, vec2(-dir.x, dir.y)));\n    \n    float m = clamp((r - v)  * 0.5, 0.0, 1.0);\n     m *= clamp(-(r2-1.5 - v)  * 0.5, 0.0, 1.0);\n\n    v = m*m*(3.0-2.0*m); \n    \n    return v;\n}\n\nfloat tri(vec2 tc, float r, float r2)\n{\n    return tri0(tc, r, r2) * tri0(vec2(tc.x, -tc.y), r * 1.4, r2);\n}\n\nvec2 EvalUI(vec2 uv0, out vec2 uvI)\n{\n    vec2 s = vec2(29.0, 36.0);\n\n    vec2 uv = uv0;\n    uv.x -= s.x * 0.15;\n    uv.y += s.y * 0.15;\n\n         uvI = floor(uv / s);\n    vec2 uvF = uv - uvI * s;\n\n    vec2 tc = uvF-s*0.5;\n    if(uvI.y == 0.0) tc.y = -tc.y;\n    tc.y += s.y * 0.2;\n\n    float k = 0.5;\n    if(uvI.y == 0.0)\n    {\n        if(uvI.x == DownId) k = 0.875;\n    }\n    else\n    {\n        if(uvI.x == UpId) k = 0.875;\n    }\n\n    float v = tri(tc, s.y*0.25, k != 0.875 ? s.y*0.15 : s.y*0.0);\n\n    if(uvI.y > 1.0 || uvI.x < 0.0 || uvI.x > 3.0) { v = 0.0; k = 0.0; }\n    //if(uvI.y == 1.0 && (uvI.x == 3.0)) { v = 0.0; k = 0.0; }// mask out unused up kernels\n\n    return vec2(v, k);\n}\n\n//===============================================================================//\n/////////////////////////////////////////////////////////////////////////////////// ARROWS UI\n\n\n\n/*\n\n// first attempt at approx BloomUpKernel8, 16 effective samples, but not nearly as good as BloomUpKernel4B\nvec4 BloomUpKernel4B0(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 0.5 + 0.5;\n    uv += BoundaryWidth * 0.5;\n    \n    vec2 uvI = floor(uv);\n    vec2 uvF = uv - uvI;\n\n    vec2 tc = uvI * RcpSrcTexRes.xy;\n    \n    vec2 l00 = vec2(0.7171050, 0.7171050);\n    vec2 l10 = vec2(0.0713251, 0.7944620);\n    vec2 l01 = vec2(0.7944620, 0.0713251);\n    vec2 l11 = vec2(0.0329773, 0.0329773);\n    \n    vec4 w = vec4(1.39257, 0.85375, 0.85375, 0.474184);\n    w /= w.x + w.y + w.z + w.w;\n    \n    bool flipX = uvF.x != 0.0;\n    bool flipY = uvF.y != 0.0;\n    \n    if(flipX)\n    {\n        vec2 tmp;\n        \n        tmp = l00; l00 = l10; l10 = tmp;\n        tmp = l01; l01 = l11; l11 = tmp;\n        \n        l00.x = 1.0 - l00.x;\n        l10.x = 1.0 - l10.x;\n        l01.x = 1.0 - l01.x;\n        l11.x = 1.0 - l11.x;\n        \n        w = vec4(w.y, w.x, w.w, w.z);\n    }\n    \n    if(flipY)\n    {\n        vec2 tmp;\n        \n        tmp = l00; l00 = l01; l01 = tmp;\n        tmp = l10; l10 = l11; l11 = tmp;\n        \n        l00.y = 1.0 - l00.y;\n        l10.y = 1.0 - l10.y;\n        l01.y = 1.0 - l01.y;\n        l11.y = 1.0 - l11.y;\n        \n        w = vec4(w.z, w.w, w.x, w.y);\n    }\n    \n    vec4 col = vec4(0.0);\n    \n    col += Read(Tex, tc + (vec2(-1.5, -1.5) + l00) * RcpSrcTexRes) * w.x;\n    col += Read(Tex, tc + (vec2( 0.5, -1.5) + l10) * RcpSrcTexRes) * w.y;\n    col += Read(Tex, tc + (vec2(-1.5,  0.5) + l01) * RcpSrcTexRes) * w.z;\n    col += Read(Tex, tc + (vec2( 0.5,  0.5) + l11) * RcpSrcTexRes) * w.w;\n    \n    return col;\n}\n\n\n// very slight improvement of BloomUpKernel4B; not worth it\nvec4 BloomUpKernel5(sampler2D Tex, vec2 uv0)\n{\n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n\n    vec2 uv = uv0 * 0.5 + 0.5;\n    uv += BoundaryWidth * 0.5;\n    \n    vec2 uvI = floor(uv);\n    vec2 uvF = uv - uvI;\n\n    vec2 tc = uvI * RcpSrcTexRes.xy;\n    \n    vec2 l00 = vec2(0.348324, 0.467528);\n    vec2 l10 = vec2(0.164815, 0.265081);\n    vec2 l01 = vec2(0.264857, 0.164846);\n    vec2 l11 = vec2(0.468550, 0.348326);\n    \n    vec2 lc  = vec2(0.557242, 0.556469);\n    \n    vec4 w = vec4(1.34843, 0.713947, 0.714223, 1.35102);\n    float wc = 1.10538;\n    float wsum = w.x + w.y + w.z + w.w + wc;\n    \n    w  /= wsum;\n    wc /= wsum;\n    \n    \n    bool flipX = uvF.x != 0.0;\n    bool flipY = uvF.y != 0.0;\n    \n    if(flipX)\n    {\n        vec2 tmp;\n        \n        tmp = l11; l11 = l10; l10 = tmp;\n        \n        l00.x = 1.0 - l00.x;\n        l10.x = 1.0 - l10.x;\n        l01.x = 1.0 - l01.x;\n        l11.x = 1.0 - l11.x;\n        lc.x  = 1.0 - lc.x;\n        \n        w = vec4(w.x, w.w, w.z, w.y);\n    }\n    \n    if(flipY)\n    {\n        vec2 tmp;\n        \n        tmp = l00; l00 = l01; l01 = tmp;\n        \n        l00.y = 1.0 - l00.y;\n        l10.y = 1.0 - l10.y;\n        l01.y = 1.0 - l01.y;\n        l11.y = 1.0 - l11.y;\n        lc.y  = 1.0 - lc.y;\n        \n        w = vec4(w.z, w.y, w.x, w.w);\n    }\n    \n    vec4 col = vec4(0.0);\n    \n    col += Read(Tex, tc + (vec2(-0.5, -1.5) + l00) * RcpSrcTexRes) * w.x;\n    col += Read(Tex, tc + (vec2( 0.5, -0.5) + l10) * RcpSrcTexRes) * w.y;\n    col += Read(Tex, tc + (vec2(-0.5,  0.5) + l01) * RcpSrcTexRes) * w.z;\n    col += Read(Tex, tc + (vec2(-1.5, -0.5) + l11) * RcpSrcTexRes) * w.w;\n    \n    col += Read(Tex, tc + (vec2(-0.5, -0.5) + lc ) * RcpSrcTexRes ) * wc;\n    \n    return col;\n}\n\n\n#if 0\nvec3 ReadImage(vec2 tc)\n{\n    vec2 uv = tc * Resolution;\n    \n    uv -= 0.5;\n    \n    vec2 uvI = floor(uv);\n    vec2 uvF = uv - uvI;\n    \n    uvI += 0.5;\n    \n    return mix(mix(EvalImage(uvI + vec2(0.0, 0.0)), EvalImage(uvI + vec2(1.0, 0.0)), uvF.x),\n               mix(EvalImage(uvI + vec2(0.0, 1.0)), EvalImage(uvI + vec2(1.0, 1.0)), uvF.x), uvF.y);\n}\n#endif\n\nvec4 BloomUpKernel4(sampler2D Tex, vec2 uv0)\n{\n    vec2 uv = floor(uv0) * 0.5 + 0.5;\n    uv += BoundaryWidth * 0.5;\n    \n    vec2 uvI = floor(uv);\n    vec2 uvF = uv - uvI;\n\n    // optimal stop-band\n    float la = 0.779627; \n    float lb = 0.0493871;\n    float ll = 0.357386;\n    \n    #if 0\n    // b-spline\n    la = 0.896947;\n    lb = 0.00819672;\n    ll = 0.317708;\n    #endif\n    \n    #if 0\n    // stop-band 2\n    la = 0.598347;\n    lb = 0.129794;\n    ll = 0.364298;\n    #endif\n    \n    #if 0\n    // radial symmetry\n    la = 0.91466;\n    lb = 0.00786767;\n    ll = 0.293837;\n    #endif\n        \n    vec2 ln = vec2(-1.5 + la, 0.5 + lb);\n    vec2 lu = vec2(-0.5 - lb, 1.5 - la);\n    \n    vec2 lx = uvF.x == 0.0 ? ln : lu;\n    vec2 ly = uvF.y == 0.0 ? ln : lu;\n    \n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n    \n    uvI *= RcpSrcTexRes.xy;\n    lx  *= RcpSrcTexRes.xx;\n    ly  *= RcpSrcTexRes.yy;\n    \n    vec4 c00 = Read(Tex, uvI + vec2(lx.x, ly.x));\n    vec4 c10 = Read(Tex, uvI + vec2(lx.y, ly.x));\n    vec4 c01 = Read(Tex, uvI + vec2(lx.x, ly.y));\n    vec4 c11 = Read(Tex, uvI + vec2(lx.y, ly.y));\n    \n    vec2 w = abs(uvF * 2.0 - ll);\n    \n    vec4 cx0 = c00 * (1.0 - w.x) + (c10 * w.x);\n    vec4 cx1 = c01 * (1.0 - w.x) + (c11 * w.x);\n    \n    vec4 cxy = cx0 * (1.0 - w.y) + (cx1 * w.y);\n    \n    return cxy;\n}\n\nvec4 BloomUpKernel9(sampler2D Tex, vec2 uv0)\n{\n    vec2 uv = floor(uv0) * 0.5 + 0.5;\n    uv += BoundaryWidth * 0.5;\n    \n    vec2 uvI = floor(uv);\n    vec2 uvF = uv - uvI;\n\n    // optimal stop-band\n    float la = 0.897872; \n    float lb = 0.438573;\n    float lc = 0.0194411;\n    \n    float wa = 0.206516;\n    float wb = 0.712722;\n    float wc = 0.0807621;\n\n#if 0\n    // radial symmetry\n    la = 63.0/64.0;//0.9821 \n    lb = 23.0/64.0;//0.35766\n    lc = 0.;\n    \n    wa = 0.0987087;\n    wb = 0.88551;\n    wc = 0.0158843;\n#endif\n\n    vec3 ln = vec3(-2.5 + la, -0.5 + lb, 1.5 + lc);\n    vec3 lu = vec3(-1.5 - lc,  0.5 - lb, 2.5 - la);\n    \n    vec3 lx = uvF.x == 0.0 ? ln : lu;\n    vec3 ly = uvF.y == 0.0 ? ln : lu;\n    \n    vec3 wx = vec3(uvF.x == 0.0 ? wa : wc, wb, uvF.x == 0.0 ? wc : wa);\n    vec3 wy = vec3(uvF.y == 0.0 ? wa : wc, wb, uvF.y == 0.0 ? wc : wa);\n    \n    vec2 RcpSrcTexRes = 1.0 / Resolution.xy;\n    \n    uvI *= RcpSrcTexRes.xy;\n    lx  *= RcpSrcTexRes.xxx;\n    ly  *= RcpSrcTexRes.yyy;\n    \n    vec4 col = vec4(0.0);\n    \n    col += Read(Tex, uvI + vec2(lx.x, ly.x)) * (wx.x * wy.x);\n    col += Read(Tex, uvI + vec2(lx.y, ly.x)) * (wx.y * wy.x);\n    col += Read(Tex, uvI + vec2(lx.z, ly.x)) * (wx.z * wy.x);\n    \n    col += Read(Tex, uvI + vec2(lx.x, ly.y)) * (wx.x * wy.y);\n    col += Read(Tex, uvI + vec2(lx.y, ly.y)) * (wx.y * wy.y);\n    col += Read(Tex, uvI + vec2(lx.z, ly.y)) * (wx.z * wy.y);\n    \n    col += Read(Tex, uvI + vec2(lx.x, ly.z)) * (wx.x * wy.z);\n    col += Read(Tex, uvI + vec2(lx.y, ly.z)) * (wx.y * wy.z);\n    col += Read(Tex, uvI + vec2(lx.z, ly.z)) * (wx.z * wy.z);\n    \n    return col;\n}\n\n\nvec4 BloomDownKernel9B(sampler2D Tex, vec2 uv0)\n{\n    vec2 uv = uv0 * 2.0 + 1.0;\n    uv -= BoundaryWidth;\n    \n    vec2 tc = uv * (1.0 / Resolution);\n    \n#if 0\n    // optimal stop-band\n    float w0 = 0.28397;\n\tfloat a = 0.124413;\n\tfloat b = 0.0545943;\n\tfloat oa = 1.5 + 0.262180;\n\tfloat ob = 1.5 + 0.262641;\n#elif 0\n    // radial symmetry\n    float w0 = 0.340645;\n\tfloat a = 0.134777;\n\tfloat b = 0.0300612;\n\tfloat oa = 1.5 + 0.226953;\n\tfloat ob = 1.5 + 0.;\n#elif 0\n    // radial symmetry\n    float w0 = 0.316221;\n\tfloat a = 0.130564;\n\tfloat b = 0.0403808;\n\tfloat oa = 1.5 + 0.241873;\n\tfloat ob = 1.5 + 0.125;\n#elif 1\n    // radial symmetry\n    float w0 = 0.309247;\n\tfloat a = 0.129306;\n\tfloat b = 0.0433824;\n\tfloat oa = 1.5 + 0.246235;\n\tfloat ob = 1.5 + (0.125+1.0/32.0);\n#elif 1\n    float w0 = 0.218567;\n\tfloat a = 0.128518;\n\tfloat b = 0.0668404;\n\tfloat oa = 1.5 + 0.34447;\n\tfloat ob = 1.5 + 0.314137;\n#endif\n\n    vec2 oa2 = oa * (1.0 / Resolution);\n    vec2 ob2 = ob * (1.0 / Resolution);\n\n\tvec4 c = vec4(0.0);\n    \n    c += Read(Tex, tc) * w0;\n\n\tc += Read(Tex, tc + vec2(-1.0, 0.0) * oa2) * a;\n\tc += Read(Tex, tc + vec2( 1.0, 0.0) * oa2) * a;\n\tc += Read(Tex, tc + vec2( 0.0,-1.0) * oa2) * a;\n\tc += Read(Tex, tc + vec2( 0.0, 1.0) * oa2) * a;\n    \n\tc += Read(Tex, tc + vec2(-1.0,-1.0) * ob2) * b;\n\tc += Read(Tex, tc + vec2( 1.0,-1.0) * ob2) * b;\n\tc += Read(Tex, tc + vec2(-1.0, 1.0) * ob2) * b;\n\tc += Read(Tex, tc + vec2( 1.0, 1.0) * ob2) * b;\n\n\treturn c;\n}\n\nfloat EvalImage(vec2 uv, int frameOff)\n{\n    vec2 uv2 = uv - 0.5;\n    \n    float o = 120.0;\n    \n    float v = 0.0;\n    v += uv2.x == 600.0 && uv2.y == o ? 1000.0 : 0.0;\n    v += uv2.x == 600.0 && uv2.y == Resolution.y - 1.0 - o ? 1000.0 : 0.0;\n    v += uv2.y == 330.0 && uv2.x == Resolution.x - 1.0 - o ? 1000.0 : 0.0;\n    v += uv2.y == 330.0 && uv2.x == o ? 1000.0 : 0.0;\n    \n    //return vec3(v*100.2);\n    \n    //return uv2.y == 66.0 || uv2.y == Resolution.y - 67.0 ? vec3(30.0) : vec3(0.0);\n    //return uv2.y == 16.0 || uv2.y == Resolution.y - 17.0 ? vec3(1.0) : vec3(0.0);\n    //return uv2.y == 0.0 || uv2.y == Resolution.y - 1.0 ? vec3(1.0) : vec3(0.0);\n    //return uv2.x == 0.0 || uv2.x == Resolution.x - 1.0 ? vec3(1.0) : vec3(0.0);\n\n    vec2 uvr = Resolution * 0.5;\n    \n    float t = float(Frame + frameOff) * 0.02;\n    \n    float a = mix(0.2, 0.3, sin(t) * 0.5 + 0.5) * Pi;\n    //a = mix(-0.03, 0.02, sin(t) * 0.5 + 0.5) * Pi;\n    a = t;\n    \n    uvr += vec2(cos(a), sin(a)) * floor(Resolution.y*0.5+0.0) * vec2(1.0, 1.0);\n    //uvr += vec2(cos(a), sin(a)) * (256.0+64.0) * vec2(1.0, 1.0);\n    //uvr += vec2(-1.0, 0.0) * (256.0+343.0) * vec2(1.0, 0.0);\n    \n    vec2 vec = uv - uvr;\n    float ll = dot(vec, vec);\n    //return vec3(exp2(-ll * 2.0)) * 100.0;//20000.0;\n    \n    //uvr = vec2(Resolution.x*0.5, Resolution.y-1.0);\n    //uvr = vec2(Resolution.x-1.0, Resolution.y*0.5);\n    \n    uvr = floor(uvr) + 0.5;\n    //uvr = vec2(512.0, 337.0 + round(sin(Time)*4.0)) + 0.5;\n    \n    //if(false)\n    {\n        float s = 0.02;\n        \n        float s2 = s * 0.01;\n        \n        uv += t * 64.0;\n        \n        float v = max(0.0, cos(uv.x * s) * cos(uv.y * s) - (1.0-s2)) / s2;\n        \n        return v*v;\n        //return cos(uv.x * s) * cos(uv.y * s) > 0.99 ? vec3(1.0) : vec3(0.0);\n    }\n   // return vec3(1.0);\n    \n    return uv.x == uvr.x && uv.y == uvr.y ? 1.0 : 0.0;\n}\n\n// 24 samples downsampling kernel implemented via 8 bilinear samples\nvec4 BloomDownKernel8(sampler2D Tex, vec2 tc)\n{\n#if 1\n    float a  = 0.13433339843769723; \n    float la = 0.9108132736411344;\n    float lb = 0.37269896061302266;\n#else\n    float a  = 0.125143; \n    float la = 0.701224;\n    float lb = 0.330373; \n#endif\n\n\tvec2 oa = (1.5 + la) * (1.0 / Resolution);\n\tvec2 ob = (0.5 + lb) * (1.0 / Resolution);\n    \n\tvec4 ca = vec4(0.0);\n\tca += Read(Tex, tc + vec2(-1.0, 0.0) * oa);\n\tca += Read(Tex, tc + vec2( 1.0, 0.0) * oa);\n\tca += Read(Tex, tc + vec2( 0.0,-1.0) * oa);\n\tca += Read(Tex, tc + vec2( 0.0, 1.0) * oa);\n    \n    vec4 cb = vec4(0.0);\n\tcb += Read(Tex, tc + vec2(-1.0,-1.0) * ob);\n\tcb += Read(Tex, tc + vec2( 1.0,-1.0) * ob);\n\tcb += Read(Tex, tc + vec2(-1.0, 1.0) * ob);\n\tcb += Read(Tex, tc + vec2( 1.0, 1.0) * ob);\n    \n    return cb * (0.25 - a * 0.25) + \n           ca * (       a * 0.25);\n}\n\n// 36 samples downsampling kernel implemented via 9 bilinear samples\nvec4 BloomDownKernel9(sampler2D Tex, vec2 tc)\n{\n#if 0\n    // pascal kernel (gauss approx)\n\tfloat a = 6.0 / 32.0;\n\tfloat b = 1.0 - a * 2.0;\n\tfloat o = 1.5 + 0.5 * (2.0 / 6.0);\n#elif 0\n    float a = 8.0 / 32.0;\n\tfloat b = 1.0 - a * 2.0;\n\tfloat o = 1.5 + 0.893356 * (2.0 / 6.0);\n#elif 1\n    float a = 7.46602 / 32.0;\n    //a = 7.44733 / 32.0;\n\tfloat b = 1.0 - a * 2.0;\n\tfloat o = 1.5 + 0.784887 * (2.0 / 6.0);    \n\t//o = 1.5 + 0.778 * (2.0 / 6.0);    \n#elif 1\n    float a = 7.37167 / 32.0;\n\tfloat b = 1.0 - a * 2.0;\n\tfloat o = 1.5 + 0.25;//0.75 * (1.0 / 6.0);    \n#endif\n\n    vec2 off = o * 1.0 / Resolution;\n\n\tvec4 c = vec4(0.0);\n    c += Read(Tex, tc + vec2(0.0)) * (b * b);\n    \n\tc += Read(Tex, tc + vec2(-1.0, 0.0) * off) * (a * b);\n\tc += Read(Tex, tc + vec2( 1.0, 0.0) * off) * (a * b);\n\tc += Read(Tex, tc + vec2( 0.0,-1.0) * off) * (a * b);\n\tc += Read(Tex, tc + vec2( 0.0, 1.0) * off) * (a * b);\n    \n\tc += Read(Tex, tc + vec2(-1.0,-1.0) * off) * (a * a);\n\tc += Read(Tex, tc + vec2( 1.0,-1.0) * off) * (a * a);\n\tc += Read(Tex, tc + vec2(-1.0, 1.0) * off) * (a * a);\n\tc += Read(Tex, tc + vec2( 1.0, 1.0) * off) * (a * a);    \n\n\treturn c;\n}\n\n// 24 samples downsampling kernel implemented via 8 bilinear samples\nvec4 BloomDownKernel8B(sampler2D Tex, vec2 tc)\n{\n#if 1\n    // optimal stop band\n    float la = 0.553811;\n    float lb = 0.35856; \n#else\n    float la = 0.245966;\n    float lb = 0.333333;\n#endif\n    \n    vec2 s = 1.0/Resolution;\n\tvec2 o = vec2(1.5 + la, 0.5 + lb);\n   \n\tvec4 col = vec4(0.0);\n\tcol += Read(Tex, tc + (vec2( 1.0, 1.0) * o.xy * s)) * 0.125;\n\tcol += Read(Tex, tc + (vec2(-1.0, 1.0) * o.xy * s)) * 0.125;\n\tcol += Read(Tex, tc + (vec2( 1.0,-1.0) * o.xy * s)) * 0.125;\n\tcol += Read(Tex, tc + (vec2(-1.0,-1.0) * o.xy * s)) * 0.125;\n    col += Read(Tex, tc + (vec2( 1.0, 1.0) * o.yx * s)) * 0.125;\n\tcol += Read(Tex, tc + (vec2(-1.0, 1.0) * o.yx * s)) * 0.125;\n\tcol += Read(Tex, tc + (vec2( 1.0,-1.0) * o.yx * s)) * 0.125;\n\tcol += Read(Tex, tc + (vec2(-1.0,-1.0) * o.yx * s)) * 0.125;\n    \n    return col;\n}\n\n\nvec4 bspline(float x)\n{\n\tfloat x2 = x * x;\n\tfloat x3 = x2 * x;\n\tvec4 w;\n\tw.x = -x3 + 3.0 * x2 - 3.0 * x + 1.0;\n\tw.y = 3.0 * x3 - 6.0 * x2 + 4.0;\n\tw.z = -3.0 * x3 + 3.0 * x2 + 3.0 * x + 1.0;\n\tw.w = x3;\n\treturn w / 6.0;\n}\n\nvec4 SampleCubic(sampler2D Tex, vec2 uvI, vec2 uvF, vec2 rcpTexSize)\n{\n\tvec4 cubicX = bspline(uvF.x);\n\tvec4 cubicY = bspline(uvF.y);\n\n\tvec2 cX = uvI.xx + vec2(-0.5, 1.5);\n\tvec2 cY = uvI.yy + vec2(-0.5, 1.5);\n\n\tvec2 sX = cubicX.xz + cubicX.yw;\n\tvec2 sY = cubicY.xz + cubicY.yw;\n\n\tvec2 offsetX = cX + cubicX.yw / sX;\n\tvec2 offsetY = cY + cubicY.yw / sY;\n\n\tvec4 value0 = textureLod(Tex, vec2(offsetX.x, offsetY.x) * rcpTexSize, 0.0);\n\tvec4 value1 = textureLod(Tex, vec2(offsetX.y, offsetY.x) * rcpTexSize, 0.0);\n\tvec4 value2 = textureLod(Tex, vec2(offsetX.x, offsetY.y) * rcpTexSize, 0.0);\n\tvec4 value3 = textureLod(Tex, vec2(offsetX.y, offsetY.y) * rcpTexSize, 0.0);\n\n\tfloat lX = sX.x / (sX.x + sX.y);\n\tfloat lY = sY.x / (sY.x + sY.y);\n\n\treturn mix(mix(value3, value2, lX),\n\t\t       mix(value1, value0, lX), lY);\n}\n\nvec4 SampleCubic(sampler2D Tex, vec2 uv, vec2 rcpTexSize)\n{\n\tuv -= 0.5;\n\n\tvec2 uvI = floor(uv);\n\tvec2 uvF = uv - uvI;\n\t\n\tvec4 r = SampleCubic(Tex, uvI, uvF, rcpTexSize);\n    \n    return r;\n}\n\n\n    {\n        // 2x2 box filter\n        v = 0.0;\n        v += Read(uv, vec2(0.0, 0.0)) * 0.25;\n        v += Read(uv, vec2(1.0, 0.0)) * 0.25;\n        v += Read(uv, vec2(0.0, 1.0)) * 0.25;\n        v += Read(uv, vec2(1.0, 1.0)) * 0.25;\n    }\n    \n        float size = SIZE*InputScale;\n        if(uv.x < 0.0) uv.x += size;\n        if(uv.y < 0.0) uv.y += size;\n\n        if(uv.x >= size) uv.x -= size;\n        if(uv.y >= size) uv.y -= size;\n\n        v = Hash01(uv, 0u);\n        \n        v = v > 0.99 ? 8.0 : 0.0;\n        \n// [1/32, 5/32, 10/32, 10/32, 5/32, 1/32]^2\nvec4 Pascal6x6Ref(vec2 uv)\n{\n\tvec4 c = vec4(0.0);\n\tfor(float y = -1.25; y <= 1.25; y += 0.5)\n\tfor(float x = -1.25; x <= 1.25; x += 0.5)\n\t{\n\t\tvec2 o = vec2(x, y);\n\n\t\tfloat wx = abs(o.x) == 0.25 ? 10.0 / 32.0 :\n\t\t\t       abs(o.x) == 0.75 ?  5.0 / 32.0 : 1.0 / 32.0;\n        float wy = abs(o.y) == 0.25 ? 10.0 / 32.0 :\n\t\t\t       abs(o.y) == 0.75 ?  5.0 / 32.0 : 1.0 / 32.0;\n\n\t\tc += Read(uv + 0.5 + o * 2.0) * (wx * wy);\n\t}\n\n\treturn c;\n}\n\nfloat Read2(vec2 uv)\n{\n    //if(ReadKeyToggle(KEY_TAB) != 0.0) \n    return Read(uv);\n    \n    vec2 uvI = floor(uv);\n    vec2 uvF = uv - uvI;\n    \n    return mix(mix(Read(uvI + vec2(0.0, 0.0)), Read(uvI + vec2(1.0, 0.0)), uvF.x),\n               mix(Read(uvI + vec2(0.0, 1.0)), Read(uvI + vec2(1.0, 1.0)), uvF.x), uvF.y);\n}\n\n// \"Bandwidth-Efficient Rendering\" (Siggraph 2015)\nvec4 Moo3x3(vec2 uv)\n{\n    uv += 0.5;\n    float o = 2.0;\n\n    float b = 4.0;\n\n\tvec4 sum = vec4(0.0, 0.0, 0.0, 0.0);\n\n\tsum += b * Read2(uv);\n\n\tsum += Read2(uv + vec2(-1.0, -1.0) * 0.5 * o);\n\tsum += Read2(uv + vec2( 1.0,  1.0) * 0.5 * o);\n\tsum += Read2(uv + vec2( 1.0, -1.0) * 0.5 * o);\n\tsum += Read2(uv + vec2(-1.0,  1.0) * 0.5 * o);\n    \n    return sum / (b + 4.0);\n}\n\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}