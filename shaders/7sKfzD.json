{
    "Shader": {
        "info": {
            "date": "1669139596",
            "description": "a basic render of a noob",
            "flags": 0,
            "hasliked": 0,
            "id": "7sKfzD",
            "likes": 3,
            "name": "Shadow and Noob",
            "published": 3,
            "tags": [
                "noob"
            ],
            "usePreview": 0,
            "username": "snack19",
            "viewed": 129
        },
        "renderpass": [
            {
                "code": "vec2 opU(in vec2 a, in vec2 b){\n    return (a.x < b.x) ? a : b;\n}\n\n\nvec3 fog(in vec3 col, in float t){\n    vec3 ext = exp2(-t*1.25*vec3(0.000,0.518,1.000));\n    return col*ext + (1.0-ext)*vec3(0.55,0.55,0.58);\n}\n\nvec2 sdNoob(in vec3 pos){\n    vec2 res = vec2(1000.0, -1.0);\n    vec3 torsoPos = vec3(0.0,0.0,0.0);\n    \n    vec3 ju = torsoPos + vec3(0.0,0.10,0.0);\n    vec3 jd = torsoPos + vec3(0.0,-0.10,0.0);\n    \n    vec3 jul = ju + vec3(0.0,0.0,0.17);\n    vec3 jur = ju + vec3(0.0,0.0,-0.17);\n    \n    vec3 jdl = jd + vec3(0.0,0.0,0.055);\n    vec3 jdr = jd + vec3(0.0,0.0,-0.055);\n    \n    vec3 headEuler = vec3(0.0,0.0,0.0);\n    \n    res = opU(res, vec2(sdSphere(pos - ju, 0.025), 3.0));\n    res = opU(res, vec2(sdRoundBox(pos - torsoPos , vec3(0.05,0.10,0.10), 0.01), 6.0));//Torso\n    \n    res = opU(res, vec2(sdRoundedCylinder((pos - ju  - vec3(0.0,0.067,0.0)), 0.032, 0.025, 0.032), 7.0));//Head\n    \n    res = opU(res, vec2(sdRoundBox(pos - jul - vec3(0.0,-0.1,0.0), vec3(0.05,0.10,0.05), 0.01), 7.0));//Left arm(z)\n    res = opU(res, vec2(sdRoundBox(pos - jur - vec3(0.0,-0.1,-0.0), vec3(0.05,0.10,0.05), 0.01), 7.0));//Right arm(-z)\n    \n    res = opU(res, vec2(sdRoundBox(pos - jdl - vec3(0.0,-0.12,0.0), vec3(0.05,0.10,0.045), 0.01), 8.0));//Left leg(z)\n    res = opU(res, vec2(sdRoundBox(pos - jdr - vec3(0.0,-0.12,0.00), vec3(0.05,0.10,0.045), 0.01), 8.0));//Left leg(z)\n    \n    return res;\n}\n\nvec2 map(in vec3 pos){\n    vec2 res = vec2(pos.y+0.5, 2.0);\n    res = opU(res, vec2(sdSphere(pos - vec3(0.5,0.0,0.0), 0.025), 3.0));\n    res = opU(res, vec2(sdSphere(pos - vec3(0.0,0.5,0.0), 0.025), 4.0));\n    res = opU(res, vec2(sdSphere(pos - vec3(0.0,0.0,0.5), 0.025), 5.0));\n    res = opU(res, sdNoob(pos));\n    return res;\n}\n\nvec2 rayCast(in vec3 ro, in vec3 rd, in int steps){\n    float t = 0.0;\n    float mate = -1.0;\n    for(int i=0;i<steps;i++){\n        vec2 d = map(ro + t*rd);\n        mate = d.y;\n        if(d.x < 0.0001 || t > 1000.0) break;\n        t += d.x;\n    }\n    if(t > 1000.0) mate = -1.0;\n    return vec2(t, mate);\n}\n\nvec3 calcNormal(vec3 p){\n    /*\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy).x - map(p - e.xyy).x,\n        map(p + e.yxy).x - map(p - e.yxy).x,\n        map(p + e.yyx).x - map(p - e.yyx).x\n    ));\n    */\n    \n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.0005*e).x;\n    }\n    return normalize(n); \n}\n\nmat3 setCam(in vec3 ori, in vec3 tar, in vec3 up){\n    vec3 a = normalize(tar - ori);\n    vec3 b = normalize(cross(a, up));\n    vec3 c = normalize(cross(b, a));\n    return mat3(b, c, a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float mo = (1.0 - iMouse.x / iResolution.x);\n    float moy = iMouse.y / iResolution.y;\n    float moz = iMouse.w / 800.0;\n    //vec3 ro = vec3(1.0*moz*cos(3.0*mo*radians(360.0)),2.0*moy-1.0 ,1.0*moz*sin(3.0*mo*radians(360.0)));\n    vec3 ro = vec3(0.0,0.5,0.0) * fromEuler(vec3(moy*1.0*radians(180.0),mo*1.0*radians(360.0),0.0));\n    vec3 rd =  setCam(ro, vec3(0.0,0.0,0.0), vec3(0.0,1.0,0.0))*normalize(vec3(uv, 1.5));\n    if(iMouse.xy == vec2(0)) ro = 5.*vec3(cos(iTime), 0., sin(iTime));\n    vec3 lightPos = normalize(vec3(1.0,1.0,0.5));\n    \n    float m = 9.0;\n    vec3 col = mix(vec3(0.831,0.961,0.969), vec3(0.090,0.569,0.631), -exp(-m*rd.y) + 1.0);\n    \n    vec2 hit = rayCast(ro, rd, 200);//Lighting\n    float t = hit.x;\n    float mate = hit.y;\n    if(mate > 0.0){\n        //Basic lighting\n        vec3 hitPos = ro + t*rd;\n        vec3 nor = calcNormal(hitPos);\n        \n        vec3 materialColor = vec3(0.471,0.471,0.471);\n        switch(int(mate)){\n            case 1:\n                materialColor = vec3(0.580,0.580,0.580);\n            break;\n            case 2:\n                materialColor = vec3(0.522,0.522,0.522);\n            break;\n            case 3:\n                materialColor = vec3(1.0,0.0,0.0);    \n            break;\n            case 4:\n                materialColor = vec3(0.0,1.0,0.0);\n            break;\n            case 5:\n                materialColor = vec3(0.0,0.0,1.0);\n            break;\n            case 6:\n                materialColor = vec3(25.0, 89.0, 154.0)/255.0;\n            break;\n            case 7:\n                materialColor = vec3(237, 230, 14)/255.0;\n            break;\n            case 8:\n                materialColor = vec3(144, 181, 74)/255.0;\n            break;\n            \n            \n        }\n        \n        float lightDif = clamp(dot(nor, lightPos), 0.0, 1.0);\n        float shaDif = step(rayCast(hitPos + 0.0001*nor, lightPos, 100).y, 0.0);\n        \n        col = vec3(0.529,0.529,0.529)*materialColor + lightDif * materialColor * vec3(0.902,0.686,0.216) * shaDif;\n        \n        //Fog\n        \n        int shadowStep = 40;\n        float fogLitPercent = 0.0f;\n        /*\n        for(int i=0;i<shadowStep;i++){\n            vec3 testPos = ro + rd * t * float(i)/float(shadowStep);\n            vec2 shaHit = rayCast(testPos, lightPos, 100);\n            fogLitPercent = mix(fogLitPercent, step(shaHit.y, 0.0), 1.0 / float(i+1));\n            \n        } \n        */\n        \n        //vec3 fogColor = mix(vec3(0.459,0.459,0.459), vec3(0.831,0.929,0.910), fogLitPercent);\n        //float absorb = exp(-t*0.2);\n        \n        \n        \n        col = fog(col, t);\n    }\n         \n         \n    if(mate < 0.0){\n    float sun = clamp(dot(lightPos, rd),0.0,1.0);\n    col += 1.5*vec3(0.8,0.4,0.2)*pow( sun, 13.0 );\n    }\n    col = pow(col, vec3(0.9));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\n\nmat3 rotateX(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(\n        1,0,0,\n        0,c,s,\n        0,-s,c\n    );\n}\n\nmat3 rotateY(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(\n        c,0,s,\n        0,1,0,\n        -s,0,c\n    );\n}\n\nmat3 rotateZ(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(\n        c,s,0,\n        -s,c,0,\n        0,0,1\n    );\n}\n\nmat3 fromEuler(vec3 ro){\n    return rotateX(ro.x) * rotateY(ro.y) * rotateZ(ro.z);\n}\n\nfloat Noise(vec2 pixel, int frame) \n{\n    pixel += (float(frame) * 5.588238f);\n    return fract(52.9829189f * fract(0.06711056f*float(pixel.x) + 0.00583715f*float(pixel.y)));  \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}