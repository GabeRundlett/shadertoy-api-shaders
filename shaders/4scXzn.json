{
    "Shader": {
        "info": {
            "date": "1457616325",
            "description": "Constructing some objects around a winding path.",
            "flags": 0,
            "hasliked": 0,
            "id": "4scXzn",
            "likes": 187,
            "name": "Winding Menger Tunnel",
            "published": 3,
            "tags": [
                "fractal",
                "tunnel",
                "raymarched",
                "menger"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 20279
        },
        "renderpass": [
            {
                "code": "/*\n\n\tWinding Menger Tunnel\n\t---------------------\n\n\tI got bored and decided to wrap a Menger object around a curvy tunnel, then I got even more bored and \n\tincorporated some tubing and some curved screens... I have no idea what they're for either. :)\n\n\tAnyway, if you put aside the cheesy, Quake-2-style graphics, it's nothing more than a couple of \n\tinterwoven fractal objects perturbed sinusoidally about the \"XY\" plane. In code:\n\n\tpos.xy -= sinPath(pos.z);\n\tdist = FractalObjects(pos);\n\n\tObviously, the camera has to follow the path as well, but that's basically it. You can ignore everything \n\telse, which is just less-than-adequate window dressing. I've been on a bit of an oldschool demo trip \n\tlately, which probably explains the simplistic lighting style.\n\n\tOther tunnel related examples worth looking at:\n\n\t// Awesome example. Makes the lighting effort in this one look lazy... which it is. :)\n    Castle Tunnel - Hamneggs\n    https://www.shadertoy.com/view/Xs3Xzn\n\n    // Love this. It inspired me to interweave the metal tubing in this particular shader.\n    Metro Tunnel - fb39ca4\n    https://www.shadertoy.com/view/ldsGRS\n\n    // Like all of dr2's stuff, it has a higher level of difficulty. :)\n    Gotthard Tunnel - dr2\n    https://www.shadertoy.com/view/MlSXRR \n\n*/\n\n\n// Used to identify individual scene objects. In this case, there are only three: The metal framework, the walls,\n// and the lights.\nfloat objID = 0.; // Metal = 1., Walls = 2., Screens = 3..\n\n// Simple hash function.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n), 0.001); // n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z); \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n}\n\n// Common formula for rounded squares, for all intended purposes.\nfloat lengthN(in vec2 p, in float n){ p = pow(abs(p), vec2(n)); return pow(p.x + p.y, 1.0/n); }\n\n// 2D path displacement.\nvec2 path(in float x){\n    \n    //return vec2(0); // Trivial, straight path.\n    //return vec2(cos(x*0.25)*1.8 + cos(x*0.15)*2., 0); // Perturbing \"X\" only.\n    return vec2(cos(x*0.25)*1.8 + cos(x*0.15)*1.5, sin(x*0.25)*1.2 + sin(x*0.15)); // Perturbing \"X\" and \"Y.\"\n    \n    \n}\n\n// Camera path. Arranged to coincide with the frequency of the tunnel.\nvec3 camPath(float t){\n  \n    return vec3(path(t), t);\n    \n}\n\n// Smooth minimum function. There are countless articles, but IQ explains it best here:\n// https://iquilezles.org/articles/smin\nfloat sminP( float a, float b, float s ){\n\n    float h = clamp( 0.5+0.5*(b-a)/s, 0.0, 1.0 );\n    return mix( b, a, h ) - s*h*(1.0-h);\n}\n\n// I have a \"Menger Sponge Variation\" example somewhere, if you'd like to look into this.\nfloat Menger(in vec3 q){\n    \n    float s = 4.;\n    // Layer one. The \".05\" on the end varies the hole size.\n \tvec3 p = abs(fract(q/s)*s - s*.5);\n \tfloat d = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - s/3.;// + .05;\n    \n    s /= 2.;\n    // Layer two.\n    p = abs(fract(q/s)*s - s*.5);\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - s/3.);//+ .05\n   \n    s /= 3.;\n    // Layer three. 3D space is divided by two, instead of three, to give some variance.\n    p = abs(fract(q/s)*s - s*.5);\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - s/3.); //- .015 \n    \n    \n    //float floor = max(abs(q.x) - 2., abs(q.y) - 1.5);//abs(q.x) - 2.;//\n    //return q.y + .8;\n    return min(d, q.y + .8);\n \n}\n\n// I have a \"Steel Lattice\" example somewhere, if you'd like to look into this. There's not\n// much to it, though.\nfloat tubing(in vec3 p){\n \n    // SECTION 1\n    //\n    // Repeat field entity one, which is just some tubes repeated in all directions every \n    // two units, then combined with a smooth minimum function. Otherwise known as a lattice.\n    p = fract(p/2.)*2. - 1.;\n    float x1 = sminP(length(p.xy),sminP(length(p.yz),length(p.xz), 0.25), 0.25)-0.5; // EQN 1\n    //float x1 = sqrt(min(dot(p.xy, p.xy),min(dot(p.yz, p.yz),dot(p.xz, p.xz))))-0.5; // EQN 2\n    //p = abs(p); float x1 = min(max(p.x, p.y),min(max(p.y, p.z),max(p.x, p.z)))-0.5; // EQN 3\n\n    // SECTION 2\n    //\n    // Repeat field entity two, which is just an abstract object repeated every half unit. \n    p = abs(fract(p*2.)*.5 - .25);\n    //float x2 = min(p.x,min(p.y,p.z)); // EQN 1\n    //float x2 = min(max(p.x, p.y),min(max(p.y, p.z),max(p.x, p.z)))-0.15; //-0.175, etc. // EQN 2\n    float x2 = min(p.x, min(p.y,p.z))-.025; // EQN 1\n    \n    // SECTION 3\n    //\n    // Combining the two entities above.\n    return max(abs(x1), abs(x2)) - .0175;\n    \n}\n\n// Creating the scene geometry. This is the process:\n//\n// Use the sinusoidal path function to perturb the original position. Create the Menger object\n// using the perturbed postion. Do the same for the tubing and again with the screens.\n// Return the minimum of the objects, and also use the relative minimums to return the object's\n// individual ID. That's basically it.\nfloat map(in vec3 p){\n   \n\n\t// Partial anti-warping solution, based on Gaz's \"Square Sin Curve\" shader below:\n    // https://www.shadertoy.com/view/MscGzf\n    //\n    // As you could imagine, tunnels (columns) get a little warped when you bend them. Countering \n    // that by taking the curvature into account helps quite a bit. Unfortunately, it slows things \n    // down, so isn't being used here, which is a shame, because I like it a lot more. Anyway, if \n    // you can spare the cycles, it gives the tunnel's \"X\" and \"Y\" (width and height) dimensions a \n    // little more consistency.\n    //vec2 g = (path(p.z + 0.01) - path(p.z - 0.01))/0.02;\n    //g = cos(atan(g));\n    \n    \n    // \"Windy Tunnels 101\" - Use \"Z\" to perturb the \"XY\" plane. If you're not sure how it'd done,\n    // I have a few tunnel examples where I explain the process.\n    p.xy -= path(p.z);\n    \n    //p.xy *= g; // See the anti-warping explanation above.\n\n\n    // A bit of tubing, using a combination of repeat objects.\n    float tube = tubing(p);\n    \n    \n    // Again a little expensive, but it's a surprisingly effective way to bump the tunnel walls.\n    // This is a variation, but you can thank \"aeikick\" for this little snippet. :)\n    //vec3 u = p;\n    //p.x -= sign(u.x)*(texture(iChannel0, u.yz/8.).x - .0)*.03;//-.2;\n\t//p.y -= sign(u.y)*(texture(iChannel0, u.xz/8.).x - .0)*.03;  \n\n    \n    // The walls. I have another Menger example, if you'd like to look into that more closely.\n    float walls = Menger(p);\n    // Simpler alternatives.\n    //float walls = 1. - max(abs(p.x), abs(p.y));\n    //float walls = 1.25 - lengthN(p.xy, 4.0);\n    \n    // The curved screens. Kind of worth the effort, but not really. Fine details always overcomplicate \n    // things, not to mention, halve the frame rate. :) Anyway, it's basically repeated square box-related \n    // stuff... Add this, take that, etc. Fiddly, hacky, not all that interesting, and probably not the\n    // best way to do it. Chipping away at a cylinder might raymarch better. \n    //\n    p += vec3(sign(p.x)*(-.11 + (sin(p.z*3.14159*2. + 1.57/1.))*.05), 0., 0.); // Screen curve, and repositioning.\n    vec3 q = abs(mod(p + vec3(.0, .5, 0.), vec3(1., 1., 2.)) - vec3(.5, .5, 1.)); // Repeat space.\n    float screen = max(max(q.y, q.z) - .22, q.x-.05); // Box.\n    screen = max(screen, max(abs(p.x) - .5, abs(p.y) - .22)); // Chopping off anything outside the tunnel... Kind of.\n    \n    // Object ID: Equivalent to: if(tube<walls)objID=2; else objID = 1.; //etc.\n    //\n    // By the way, if you need to identify multiple objects, you're better off doing it in a seperate pass, \n    // after the raymarching function. Having multiple \"if\" statements in a distance field equation can slow \n    // things down considerably. Alternatively, there's the \"vec2 objA = vec2(objectADist, objAID)\" option \n    // that many are fond of. It seems to be slower on my machines, but seems to work well enough.\n    objID = 1. + step(tube, walls) + step(screen, tube)*step(screen, walls)*2.;\n   \n\n    // Returning the minimum of the three objects.\n    return min(min(tube, walls), screen);\n    \n/*    \n    //Two object combinations. Spoils the illusion, but helps visualize things.\n\n    //objID = 2. + step(screen, tube);\n    //return min(tube, screen); \n        \n        \n    //objID = 1. + step(tube, walls);\n    //return min(tube, walls);        \n        \n    objID = 1. + step(screen, walls)*2.;\n    return min(screen, walls);    \n*/     \n    \n    \n}\n\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 calcNormal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\n/*\n// Standard normal function.\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original .\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translate to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.002, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Standard hue rotation formula.\nvec3 rotHue(vec3 p, float a){\n\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr, 0., 1.);\n}\n\n// Screen pattern. Simple, but effective. The idea to go with this was inspired by Dmitry Andreev's \n// really cool \"pixelScreen\" shader, here: https://www.shadertoy.com/view/XdG3Wc\n//\n// His example is a little fancier, mainly because he's using way more code... The fact that he won \n// Assembly a couple of times might also be a factor. :)\nfloat dotPattern(vec2 p){\n    \n    // Partition space into multiple squares.\n    vec2 fp = abs(fract(p)-0.5)*2.;\n    \n    // Rounded circle, for the overlay, or vignette, if you prefer.\n    fp = pow(fp, vec2(8.));\n    float r = max(1. - pow(fp.x + fp.y, 1.), 0.);\n    \n    // More squarish (Chebyshev) version of the above.\n    //fp = pow(fp, vec2(8.));\n    //float r = 1. - max(fp.x, fp.y);\n    \n    // Single value for each square. Used for IDs and a bunch of other things, but in this \n    // case it'll give the square a homogeneous color.\n    p = floor(p); \n    \n    // The blocky pattern value. Made up, but you could use all kinds of things, like Voronoi, etc. \n    float c = dot(sin(p/4. - cos(p.yx/.2 + iTime/4.)), vec2(.5));\n\n    c = fract(c * 7.0); // Mixing it up, for no particular reason.\n\n    return c*r; // Pixel shade, multiplied by the rounded square vignette. Range: [0, 1].\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n   \n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n    vec3 ro = camPath(iTime*1.5); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime*1.5 + .1);  // \"Look At\" position.\n    vec3 lp = camPath(iTime*1.5 + 2.) + vec3(0, 2, 0); // Light position, somewhere near the moving camera.\n\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.57; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    vec3 rd = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n \n    vec2 a = sin(vec2(1.5707963, 0) - camPath(lk.z).x/12.); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xy = rd.xy*rM; // Apparently, \"rd.xy *= rM\" doesn't work on some setups. Crazy.\n    \n    // Mouse controls, as per Dave Hoskins's suggestion. A bit hacky, but I'll fix them.    \n\tvec2 ms = vec2(0);\n    if (iMouse.z > 1.0) ms = (2.*iMouse.xy - iResolution.xy)/iResolution.xy;\n    a = sin(vec2(1.5707963, 0) - ms.x); \n    rM = mat2(a, -a.y, a.x);\n    rd.xz = rd.xz*rM; \n    a = sin(vec2(1.5707963, 0) - ms.y); \n    rM = mat2(a, -a.y, a.x);\n    rd.yz = rd.yz*rM;\n    \n\n    \n    // Raymarching.\n    const float FAR = 50.0;\n    float t = 0.0, h;\n    for(int i = 0; i < 96; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.001*(t*.75 + .25) || t>FAR) break;//*(t*.5 + 1.)\n        t += h*.75;\n        //t += step(.5, t)*h*.25 + h*.5;\n        \n    }\n    \n    // Initialize the scene color.\n    vec3 col = vec3(0);\n    \n    // Scene hit, so color the pixel. \n    if(t<FAR){\n        \n        // This looks a little messy and haphazard, but it's really just some basic lighting, and application\n        // of the following material properties: Metal = 1., Walls = 2., Screens = 3..\n    \n        float ts = 2.;\n        // Global object ID. It needs to be saved just after the raymarching equation, since other \"map\" calls,\n        // like normal calculations will give incorrect results. Found that out the hard way. :)\n        float saveObjID = objID; \n        \n        \n        vec3 pos = ro + rd*t; // Scene postion.\n        vec3 pOffs = pos - vec3(camPath(pos.z).xy, 0); // Postion, offset by the path. \n        vec3 nor = calcNormal(pos); // Normal.\n        \n        // Apply some subtle texture bump mapping to the walls and the metal tubing, but not the screen.\n        // I should probably get rid of that \"if\" statement later, but it seems OK for now.\n        if(saveObjID<2.5) nor = texBump(iChannel0, pOffs*ts, nor, 0.002 + step(saveObjID, 1.5)*0.012);\n        \n        \n\t\tcol = tex3D(iChannel0, pOffs*ts, nor); // Texture pixel at the scene postion.\n        col = smoothstep(-.3, .8, col)*vec3(1., .8, .7); // Process the color a little.\n\n        // More fake lighting. This was just a bit of trial-and-error to produce some repetitive,\n        // slightly overhead, spotlights in each of the modules. Cylinder in XY, sine repeat\n        // in the Z direction... Something like that.\n        float spot = max(2. - length(pOffs.xy - vec2(0, 1)), 0.)*(sin((pOffs.z)*3.14159 + 1.57)*.5+.5);\n        spot = smoothstep(0.25, 1., spot);\n        \n        \n        \n        float occ = calcAO( pos, nor ); // Occlusion.\n\t\tvec3  li = normalize( lp - pos ); // Point light.\n        float dif = clamp(dot(nor, li), 0.0, 1.0); // Diffuse.\n        float spe = pow(max(dot(reflect(-li, nor), -rd), 0.), 8.); // Object specular.\n        float spe2 = 0.; // Global specular.\n\n            \n\n        vec3  rCol = vec3(0); // Reflection color. Mostly fake.\n        \n        // If the metal tubing or the screen is hit, apply the individual properties.\n        if(saveObjID>1.5){ \n\t\t\t\n            // Grey out the limestone wall color.\n            col = vec3(1)*dot(col*.7+.2, vec3(.299, .587, .114));\n            // Add some fake reflection. Not reliable, but it's subtle.\n            rCol = tex3D(iChannel0, (pOffs + reflect(rd, nor))*ts, nor);\n            col += rCol*.25 + spot*.125;\n            spe2 = spe*spe*.25; // Ramp up the global specular a bit.\n            if(saveObjID<2.5) dif = pow(dif, 2.)*1.25;\n            \n        }         \n        \n        // If just the screen has been hit, apply some extra properties, then draw the screen image.\n        // I could just write \"saveObjID == 3.,\" but I get a little paranoid where floats are concerned. :)\n        if(saveObjID>2.5){\n\n            // For the screen image, we're interested in the offset height and depth positions. Ie: pOffs.zy.\n            \n            // Pixelized dot pattern shade.\n            float c = dotPattern(pOffs.zy*36.+.5);\n            \n            // Applying some color to the shade.\n            col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.));\n            // Mixing the colors around a little. Made up.\n            col = mix(col.zyx, col, sin(dot(pos, vec3(.333))*3.14159*6.)*.34+.66);\n\t\t\t\n            // Individual screen ID or sorts.\n            float id = hash(dot(floor(pOffs + vec3(.0, .5, .5)), vec3(7, 157, 113)));\n            \n            // Use the screen ID to give it a different random hue.\n            col = rotHue(col, floor(id*12.)/12.*6.283/2.); \n            \n            col += rCol*rCol*.5; // Screen reflection.            \n            \n            dif += .5; // Make the screen appear self illuminating, but increasing the diffuse.\n            spe += .25;\n            \n        }\n       \n        // Combining everything together to produce the scene color.\n        col *= (dif + .25 + spot*.5 + vec3(.25, .3, .5)*spe) + spe2;\n        col *= occ; // Applying occlusion.\n       \n        \n    }\n    \n    // Applying some very slight fog in the distance. This is technically an inside scene...\n    // Or is it underground... Who cares, it's just a shader. :)\n    col = mix(min(col, 1.), vec3(0), 1.-exp(-t*t/FAR/FAR*15.));//smoothstep(0., FAR-20., t)\n    \n    // Done.\n    fragColor = vec4(col, 1.0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}