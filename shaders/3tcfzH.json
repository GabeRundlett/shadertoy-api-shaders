{
    "Shader": {
        "info": {
            "date": "1612205104",
            "description": "I made a simple implementation of GGX.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tcfzH",
            "likes": 1,
            "name": "Simple GGX Implementation",
            "published": 3,
            "tags": [
                "raymarching",
                "ray",
                "raymarch",
                "shadow",
                "raymarcher",
                "specular",
                "metal",
                "hard",
                "ggx",
                "metallic",
                "hardshadow"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 627
        },
        "renderpass": [
            {
                "code": "// Simple GGX Implementation by Zi7ar21 --- February 1st, 2021\n// Updated February 1st, 2021 11:45 Mountain Time\n\n// If you didn't find this on Shadertoy, the original (and possibly updated version) can be found at: https://www.shadertoy.com/view/3tcfzH\n\n// Sensitivity of Mouse Controls\n#define mousesensitivity 4.0\n// Camera Field of View\n#define camfov 1.0\n// Maximum Number of Ray-Marches\n#define maxmarches 1024\n// Collision Distance\n#define collisiondist 1e-4\n// Scene Size\n#define scenesize 7.75\n// Light Direction\n#define lightdir normalize(vec3(1.0, 1.0, -0.5))\n// FBM Noise Octaves\n#define NUM_OCTAVES 8\n\n// Pi (Quadruple Precision Float Future-Proof)\n#define pi 3.1415926535897932384626433832795028\n\n// Test Object SDF\nfloat test(vec3 raypos){\n    float sphere0 = length(raypos+vec3( 0.0, -0.5, 0.0))-0.5;\n    float sphere1 = length(raypos+vec3(-0.5, -0.5, 0.0))-0.5;\n    float sphere2 = length(raypos+vec3( 0.0, -0.5, 0.0))-0.45;\n    float sphere3 = length(raypos+vec3(-0.5, -0.5, 0.0))-0.4;\n    float sphere4 = length(raypos+vec3( 0.0, -0.5, 0.0))-0.35;\n    return min(sphere4, max(-sphere3, min(sphere2, max(-sphere1, sphere0))));\n}\n\n// Ground SDF\nfloat plane(vec3 raypos){\n    return raypos.y;\n}\n\n// Scene Distance Estimators\nfloat DE(vec3 raypos){\n    float DE0 = test(raypos);\n    float DE1 = plane(raypos);\n    return min(DE0, DE1);\n}\n\n// Lookup Material ID\nint getmat(vec3 raypos){\n    float DE0 = test(raypos);\n    float DE1 = plane(raypos);\n    float minimum = min(DE0, DE1);\n    if(minimum == DE0){return 0;}\n    if(minimum == DE1){return 1;}\n    return -1;\n}\n\n// FBM Noise https://www.shadertoy.com/view/3dSBRh\n// Hash https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx)*0.1031);\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.x+p3.y)*p3.z);\n}\n\nfloat noise(vec2 n){\n    vec4 b = vec4(floor(n), ceil(n)); \n    vec2 f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(hash12(b.xy), hash12(b.zy), f.x), mix(hash12(b.xw), hash12(b.zw), f.x), f.y);\n}\n\nfloat fbm(vec2 x){\n\tfloat v = 0.0;\n\tfloat a = 0.4;\n\tfor (int i = 0; i < NUM_OCTAVES; i++){\n\t\tv += a*noise(x);\n\t\tx = x*2.0;\n\t\ta *= 0.6;\n\t}\n\treturn v;\n}\n\n// Material Properties (Color, Specular)\nvec4 matprop(int material, vec3 raypos){\n    // Sphere Object\n    if(material == 0){\n        return vec4(vec3(0.75, 0.8, 0.95), 0.45);\n    }\n    // Ground\n    if(material == 1){\n        return vec4((vec3(0.95, 0.8, 0.75)/length(raypos))-0.125, clamp((fbm(raypos.xz*2.0)/1.0), 0.0, 1.0));\n    }\n    // Non-Defined Material\n    return vec4(0.0);\n}\n\n// Forwards and Central Differences\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 raypos){\n    vec2 diff = vec2(collisiondist, 0.0);\n    return normalize(vec3(DE(raypos+diff.xyy)-DE(raypos-diff.xyy),\n                          DE(raypos+diff.yxy)-DE(raypos-diff.yxy),\n                          DE(raypos+diff.yyx)-DE(raypos-diff.yyx)));\n}\n\n// https://learnopengl.com/PBR/Theory\nfloat GGX(vec3 normal, vec3 highlightdir, float a){\n    float a2     = a*a;\n    float NdotH  = max(dot(normal, highlightdir), 0.0);\n    float NdotH2 = NdotH*NdotH;\n    float nom    = a2;\n    float denom  = (NdotH2*(a2-1.0)+1.0);\n          denom  = pi*denom*denom;\n    return nom/denom;\n}\n\n// Shading\nvec3 shade(vec3 reflection, float specularity){\n    return vec3(GGX(reflection, lightdir, specularity));\n}\n\n// Ray-Marching\nvec3 raymarch(vec3 raydir, vec3 rayori){\n    // Define our distance estimate\n    float distest;\n\n    // Define our ray position\n    vec3 raypos = rayori;\n\n    // Define the closest point to the Sscene (Not Colliding)\n    vec3 closestpos = raypos;\n\n    // Define our output color\n    vec3 outCol = vec3(1.0);\n\n    // Define our material properites\n    vec4 matprops;\n\n    // Start the Ray-Marching\n    for(int i = 0; i < maxmarches; i++){\n        // Check the distance to the scene\n        distest = DE(raypos);\n        // If the ray is not colliding then it is the nearest non-colliding point so far\n        if(distest > collisiondist){closestpos = raypos;}\n        // If the ray is colliding...\n        if(distest < collisiondist){\n            // Find the properties of our material\n            matprops = matprop(getmat(raypos), raypos);\n            // Find the normal of where we collided\n            vec3 normals = normal(raypos);\n            // Multiply the output color by the material color\n            outCol *= matprops.rgb;\n            // Return our shaded color\n            return shade(reflect(raydir, normals), matprops.w)*outCol;\n        }\n        // If we didn't collide, March the Ray\n        raypos += raydir*distest;\n        // If the ray flies off to who knows where, we yeet it\n        if(length(raypos) > scenesize){break;}\n    }\n    // Our ray never hit anything so we just return 0.0\n    return vec3(0.0);\n}\n\n// Main Function\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    // Sceen UV Coorinates Centered on [0.0, 0.0]\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n    // Mouse\n    vec2 mouse = ((iMouse.xy/iResolution.xy)-0.5)*pi*mousesensitivity;\n    //vec2 mouse = vec2(iTime*pi*0.125, 0.0);\n\n    // Rotation Matrix\n    mat3 rotmat = mat3(cos(mouse.x), 0.0, -sin(mouse.x), 0.0, 1.0, 0.0, sin(mouse.x), 0.0, cos(mouse.x));\n\n    // Direction of the Ray\n    vec3 raydir = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Perform Ray-Marching\n    vec3 raymarched = raymarch(raydir, vec3(-sin(mouse.x)*2.0, 0.5, -cos(mouse.x)*2.0));\n\n    // Gamma Correction\n    vec3 color = pow(raymarched, vec3(1.0/2.2));\n\n    // Output the Image\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}