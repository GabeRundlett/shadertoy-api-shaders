{
    "Shader": {
        "info": {
            "date": "1586889121",
            "description": "The Nine Point Conic, mapped projectively to a sphere (ie. (x,y,z) -> normalize(x,y,z). The line at infinity is a bit weird.\n\nSee also:\n\n[url]https://www.shadertoy.com/view/Wd2cRG[/url]\n[url]https://www.shadertoy.com/view/WsscRB[/url]",
            "flags": 48,
            "hasliked": 0,
            "id": "wsjczG",
            "likes": 5,
            "name": "Nine Point Conic on Sphere",
            "published": 3,
            "tags": [
                "conic",
                "projective",
                "ninepoint"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 356
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// \"Nine Point Conic\" on a projective sphere.\n//\n// <mouse>: rotate\n// <up>/<down>: move in and out\n// b: show background\n// r: autorotation\n// s: show sphere\n\n// See also:\n// https://www.shadertoy.com/view/Wd2cRG\n// https://www.shadertoy.com/view/WsscRB\n//\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// The Nine Point Conic\n// Matthew Arcus, 2020.\n//\n// Given a triangle ABC and a point P, can draw a conic between:\n// The midpoints of the triangle sides\n// The midpoints of the lines from P to each vertex\n// The points where these lines cut the sides of the triangle\n//\n// The conic changes from ellipse to hyperbola when it crosses one of\n// the extended triangle sides, and becomes a circles when P coincides\n// with the orthocentre (intersection of altitudes).\n//\n////////////////////////////////////////////////////////////////////////////////\n\nbool check = false;\n\nvoid assert(bool b) { if (!b) check = true; }\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// Geometric constructions\n//\n// Homogeneous coordinates used throughout (so the lines and points are\n// \"projective\"):\n// (x,y,z) represents the point (x/z,y/z) for z != 0\n// (x,y,0) represents a \"point at infinity\" which acts like a direction.\n// (a,b,c) represents the line ax + by + cz = 0\n// (0,0,c) represents the \"line at infinity\"\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// The line between two projective points, or the intersection of two\n// projective lines, is just their cross product.\nvec3 join(vec3 p, vec3 q) {\n  return cross(p,q);\n}\n\n// The midpoint between p and q (also conjugate with point at infinity)\nvec3 midpoint(vec3 p, vec3 q) {\n  return p*q.z + p.z*q;\n}\n\nfloat distance2(vec3 p, vec3 q) {\n  p /= p.z; q /= q.z;\n  return abs(dot(p-q,p-q));\n}\n\n// Perpendicular bisector (a line)\nvec3 bisector(vec3 p,vec3 q) {\n  // (p-r).(p-r) = (q-r).(q-r) // r equidistant from p and q\n  // pp - 2pr + rr = qq - 2qr + rr\n  // pp - qq = 2pr - 2qr\n  // 2r.(p-q) = pp - qq\n  p /= p.z; q /= q.z;\n  return vec3(2.0*(p.xy-q.xy),dot(q,q)-dot(p,p));\n}\n\n// Drop perpendicular from p onto line q.\nvec3 perpendicular(vec3 p, vec3 q) {\n  // (p + kq.xy).q = 0\n  // p.q + k(q.yx).q = 0\n  float k = dot(p,q)/dot(q.xy,q.xy);\n  return p - k*vec3(q.xy,0);\n}\n\n// Find a projective mapping taking p0,p1,p2,p4 to\n// triangle of reference and unit point, ie:\n// p0 -> (1,0,0), p1 -> (0,1,0), p2 -> (0,0,1), p3 -> (1,1,1)\n// No three points collinear.\nmat3 rproject(vec3 p0, vec3 p1, vec3 p2, vec3 p3) {\n  // Just an inverse for the first three points\n  // (the triangle of reference). No inverse if collinear.\n  mat3 m = inverse(mat3(p0,p1,p2)); // column major!\n  vec3 p3a = m*p3;\n  // Then scale each row so the unit point (1,1,1) is correct\n  m = transpose(m);\n  // zero components here only if not collinear\n  m[0] /= p3a[0];\n  m[1] /= p3a[1];\n  m[2] /= p3a[2];\n  m = transpose(m);\n  return m;\n}\n\n// Construct the conic defined by 5 points.\n// Method taken from \"Geometry\", Brannan, Esplan & Gray, CUP, 2012\nmat3 solve(vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n  // p takes p0,p1,p2,p3 to triangle of reference and unit point\n  mat3 p = rproject(p0,p1,p2,p3);\n  // Now construct a conic through the images of p0-p4,\n  vec3 p4a = p*p4;\n  float a = p4a.x, b = p4a.y, c = p4a.z;\n  float d = c*(a-b);\n  float e = b*(c-a);\n  float f = a*(b-c);\n  mat3 m = mat3(0,d,e,\n                d,0,f,\n                e,f,0);\n  // And combine the two.\n  mat3 res = transpose(p)*m*p;\n  assert(abs(determinant(res)) > 0.1);\n  return res;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Distance functions\n////////////////////////////////////////////////////////////////////////////////\n\nfloat point(vec3 p, vec3 q) {\n  float pz = p.z, qz = q.z;\n  p *= qz; q *= pz;\n  return distance(p,q)/abs(p.z);\n}\n\nfloat line(vec3 p, vec3 q) {\n  return abs(dot(p,q)/(p.z*length(q.xy)));\n}\n\nfloat line(vec3 p, vec3 q, vec3 r) {\n  return line(p,join(q,r));\n}\n\nfloat segment(vec3 p, vec3 q, vec3 r) {\n  p /= p.z; q /= q.z; r /= r.z; // normalize\n  vec3 pa = p-q;\n  vec3 ba = r-q;\n  float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n  float d = length(pa-h*ba);\n  return d;\n}\n\nfloat conic(vec3 p, mat3 m) {\n  float s = dot(p,m*p);\n  vec3 ds = 2.0*m*p; // Gradient\n  return abs(s/(p.z*length(ds.xy))); // Normalize for Euclidean distance\n}\n\nfloat circle(vec3 p, vec4 c) {\n  // (x-a)^2 + (y-b)^2 = r^2\n  // x2 -2ax + a2 + y2 -2by + b2 -r2 = 0\n  vec3 q = c.xyz;\n  float r2 = c.w;\n  q /= q.z;\n  return conic(p,mat3(1,0,-q.x,\n                      0,1,-q.y,\n                     -q.x,-q.y,dot(q.xy,q.xy)-r2));\n}\n\nfloat quad(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d) {\n  float t = 1e8;\n  t = min(t,segment(p,a,b));\n  t = min(t,segment(p,b,c));\n  t = min(t,segment(p,c,d));\n  t = min(t,segment(p,d,a));\n  return t;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Drawing functions\n////////////////////////////////////////////////////////////////////////////////\n\nvoid getmin(inout float d, inout int index, int i, float t) {\n  if (t < d) { d = t; index = i; }\n}\n\nvec3 colors[] =\n  vec3[](vec3(1,0,0),\n         vec3(1,1,0),\n         vec3(0,0,1),\n         vec3(0,0.8,0),\n         vec3(0,1,1),\n         vec3(0.8),\n         vec3(1,0,1),\n         vec3(1,1,1)\n         );\n\nvec3 getcol(int i) {\n  return colors[i];\n}\n\nvec3 diagram(vec3 p, vec3 P) {\n  vec3 pcol = vec3(0.3);\n  float lwidth = 0.005;\n  float dwidth = 1.5*fwidth(p.x/p.z);\n  float pwidth = 0.03;\n  // The triangle (P is parameter)\n  vec3 A = vec3(1.0,1.0,1), B = vec3(-1.5,-0.5,1), C = vec3(1,-1,1);\n  vec3 AB = join(A,B), BC = join(B,C), CA = join(C,A);\n  vec3 PA = join(P,A), PB = join(P,B), PC = join(P,C);\n  vec3 mBC = midpoint(B,C), mCA = midpoint(C,A), mAB = midpoint(A,B);\n  vec3 mPA = midpoint(P,A), mPB = midpoint(P,B), mPC = midpoint(P,C);\n  vec3 aA = join(PA,BC), aB = join(PB,CA), aC = join(PC,AB);\n  vec3 pA = perpendicular(A,BC);\n  vec3 pB = perpendicular(B,CA);\n  vec3 pC = perpendicular(C,AB);\n  vec3 H = join(join(A,pA),join(B,pB));\n  mat3 X = solve(mAB,mBC,mCA,mPA,mPB);\n\n  vec3 bA = bisector(A,B);\n  vec3 bB = bisector(B,C);\n  // Intersect at the circumcentre\n  vec3 O = join(bA,bB);\n  // centre of the circumcircle.\n  vec4 C1 = vec4(O,distance2(O,A));\n  \n  float d = 1e8;\n  int index = -1;\n  getmin(d,index,0,line(p,AB));\n  getmin(d,index,0,line(p,BC));\n  getmin(d,index,0,line(p,CA));\n\n  getmin(d,index,1,line(p,PA));\n  getmin(d,index,1,line(p,PB));\n  getmin(d,index,1,line(p,PC));\n\n  getmin(d,index,4,line(p,A,pA));\n  getmin(d,index,4,line(p,B,pB));\n  getmin(d,index,4,line(p,C,pC));\n\n  if (false) {\n    getmin(d,index,3,quad(p,mAB,mCA,mPC,mPB));\n    getmin(d,index,3,quad(p,mBC,mAB,mPA,mPC));\n    getmin(d,index,3,quad(p,mCA,mBC,mPB,mPA));\n  }\n  getmin(d,index,2,conic(p,X));\n  getmin(d,index,5,circle(p,C1));\n\n  //vec3 bgcolor = 0.1*vec3(0.75,0.25,1); //vec3(1,1,0.8);\n  vec3 col = vec3(1,1,0.8);  \n  col = mix(0.9*getcol(index),col,smoothstep(lwidth,lwidth+dwidth,d));\n  d = 1e8;\n  getmin(d,index,0,point(p,P));\n\n  getmin(d,index,0,point(p,A));\n  getmin(d,index,0,point(p,B));\n  getmin(d,index,0,point(p,C));\n\n  getmin(d,index,0,point(p,mBC));\n  getmin(d,index,0,point(p,mCA));\n  getmin(d,index,0,point(p,mAB));\n\n  getmin(d,index,0,point(p,mPA));\n  getmin(d,index,0,point(p,mPB));\n  getmin(d,index,0,point(p,mPC));\n  \n  getmin(d,index,0,point(p,aA));\n  getmin(d,index,0,point(p,aB));\n  getmin(d,index,0,point(p,aC));\n\n  getmin(d,index,0,point(p,H));\n  \n  col = mix(pcol,col,smoothstep(pwidth,pwidth+dwidth,d));\n  return col;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// The Sphere\n////////////////////////////////////////////////////////////////////////////////\n\nconst float AA = 2.0;\nconst int maxiterations = 50;\n\nbool dobackground = true;\nbool dorotate = true;\nbool dosphere = true;\n\nconst float PI = 3.14159265;\n\n// R3 inversion in sphere, centre q, square radius r2.\nvec3 invert(vec3 p, vec3 q, float r2) {\n  p -= q;\n  p *= r2/dot(p,p);\n  p += q;\n  return p;\n}\n\nvec3 stereographic0(vec3 p) {\n  return invert(p,vec3(0,0,-1),2.0);\n}\n\n// Invert in sphere radius sqrt(2), centre (0,0,-1)\n// is stereographic projection from the unit sphere\n// to z=0 (and its inverse).\nvec2 stereographic(vec3 p) {\n  return stereographic0(p).xy;\n}\n\nvec3 istereographic(vec2 z) {\n  return stereographic0(vec3(z,0));\n}\n\nvec3 transform(in vec3 p);\n\nvec3 getspherecolor(vec3 p3) {\n  //if (p3.z < 0.0) return vec3(0,0,0.2);\n  // Map to the plane\n  p3 = transform(p3);\n  vec2 p = p3.xy/p3.z;\n  vec3 P = iMouse.x <= 0.0 ? vec3(0,0,1)\n    : vec3((2.0*iMouse.xy-iResolution.xy)/iResolution.y,1);\n  P = vec3(cos(iTime),sin(1.1*iTime),1);\n  return diagram(vec3(p,1),P);\n}\n\nstruct Ray {\n  vec3 q;               // origin\n  vec3 d;               // direction\n};\n\nstruct Hit {\n  float t;      // solution to p=q+t*d\n  vec3 n;       // normal\n};\n\nstruct Sphere {\n  vec3 p;       // centre\n  float r;      // radius\n};\n\nbool intersectSphere(Sphere s, Ray ray, out Hit hit[2]) {\n  vec3 p = s.p;\n  float r = s.r;\n  float c = length(p);\n  vec3 q = ray.q, d = ray.d;\n  // Formula for x^2 + 2Bx + C = 0\n  // |q + t*d - p|^2 = r^2\n  float B = dot(q-p,d);\n  float C = dot(q,q)-2.0*dot(q,p)+(c+r)*(c-r);\n  float D = B*B - C;\n  if (D < 0.0) return false;\n  D = sqrt(D);\n  float t0,t1;\n  if (B >= 0.0) {\n    t0 = -B-D; t1 = C/t0;\n  } else {\n    t1 = -B+D; t0 = C/t1;\n  }\n  hit[0] = Hit(t0,(q+t0*d-p)/r);\n  hit[1] = Hit(t1,(q+t1*d-p)/r);\n  return true;\n}\n\nbool intersectScene(Ray r, out Hit hit[2]) {\n  Sphere s = Sphere(vec3(0),1.0);\n  if (intersectSphere(s,r,hit)) {\n    return true;\n  }\n  return false;\n}\n\nvec3 light;\n\nvec3 solve(Ray r,vec2 uv) {\n  Hit hit[2];\n  vec3 c = vec3(0);\n  if (!dosphere || !intersectScene(r,hit)) {\n    if (dobackground) {\n      vec3 p = istereographic(uv);\n      c = getspherecolor(p);\n      c *= dosphere ? 0.2 : 0.8;\n    }\n  } else {\n    for (int i = 0; i < 2; i++) {\n      vec3 p = r.q+hit[i].t*r.d;\n      vec3 n = hit[i].n;\n      vec3 basecolor = getspherecolor(hit[i].n);\n      if (basecolor == vec3(0)) continue;\n      vec3 color = vec3(0);\n      float ambient = 0.5;\n      float diffuse = 0.5;\n      color += basecolor*ambient;\n      color += basecolor*diffuse*max(0.0,dot(light,n));\n      float specular = pow(max(0.0,dot(reflect(light,n),r.d)),5.0);\n      vec3 speccolor = basecolor; //vec3(1);\n      color += 1.0*specular*speccolor;\n      return color;\n    }\n  }\n  return c;\n}\n\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\n\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nbool key(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (dorotate) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.2);\n  }\n  return p;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  dobackground = !key(CHAR_B);\n  dorotate = !key(CHAR_R);\n  dosphere = !key(CHAR_S);\n\n  light = vec3(0.5,1.0,1.0);\n  light = normalize(light);\n\n  vec3 p = vec3(0,0,6);\n  p.z *= exp(-0.1*float(keycount(KEY_UP)-keycount(KEY_DOWN)));\n  vec3 col = vec3(0);\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 r = vec3(uv,-6);\n      r = normalize(r);\n      col += solve(Ray(p,r),uv);\n    }\n  }\n  col = pow(col/(AA*AA),vec3(0.4545));\n  //if (check) fragColor = 3(1,0,0);\n  fragColor = vec4(col,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0) {\n      t = vec4(0);\n    } else {\n      t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}