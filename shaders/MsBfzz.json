{
    "Shader": {
        "info": {
            "date": "1499127060",
            "description": "first 3d thing\nfeedback/suggestions/improvements would be greatly appreciated",
            "flags": 0,
            "hasliked": 0,
            "id": "MsBfzz",
            "likes": 4,
            "name": "rayz 4 dayz",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "DJDoomz",
            "viewed": 678
        },
        "renderpass": [
            {
                "code": "#define t iTime\n#define pi 3.14159\n\n//marching codes from iq & http://www.alanzucconi.com/2016/07/01/volumetric-rendering/\n//and thank you to ollj for the tips\n\nfloat noise(float x){ return abs(sin(34343.338*(x-1.)*(x+485.)*x));}\n\nfloat cube(vec3 rp, vec3 c, float s){\n    return length(max(abs(rp-c)-s,0.))-.1;//slightly modified\n}\n\nfloat cylinder( vec3 p, vec3 c, vec2 h){\n\tp -= c;\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n\treturn length(max(d,0.0));\n}\n\nvec2 map(vec3 p){\n    \n    vec2 podium = vec2(cylinder(p, vec3(0.,5.,0.), vec2(1.,4.)),1.);\n    \n    p.y += .2*sin(t)+.2; //moves thing up & down\n    vec2 thing = vec2(length(p)-1.,0.);\n    float a = p.y*pi/2.+.4*t; //twists thing\n    float s = sin(a), c = cos(a);\n    p.xz *= mat2(s,c,c,-s);\n    p.y += .1*sin(4.*atan(p.x,p.z))*length(p.xz);\n    \n    //subtracts a (twisted) cube from 6 sides\n    vec3 i = vec3(0);\n    i.x++;\n    for(int j = 0; j < 3; j++)\n    {\n\t\tthing.x = max(thing.x,-cube(p,i,.5));\n        thing.x = max(thing.x,-cube(p,-i,.5));\n        i.xyz = i.yzx;\n    }\n    \n    return thing.x < podium.x ? thing : podium;\n}\n\nfloat shadow(in vec3 ro, in vec3 rd){\n    //starts at surface, heads towards lightsource\n   \tfloat d =0.02;\n    \n    for( int a=0; a < 60; a++)\n    {\n        float h = map(ro + rd*d).x;\n        if( h<0.001 )\n            return .6;\n        d += h*.7;\n    }\n    return 1.0;\n}\n\nvec4 renderBackGround(vec2 uv){\n    vec3 col1 = vec3(.9,.6,.9);\n    vec3 col2 = vec3(0.6,.7,.9);\n    \n\treturn vec4(mix(col1,col2,-(uv.y-1.+sin(t+uv.x))),1.);\n}\n\nvec4 simpleLambert(vec3 ro, vec3 norm, vec3 rd, in float obj){\n\tvec3 lDir = normalize(vec3(.8*sin(t),-.2,.8*cos(t))); //light direction\n    vec3 lCol = normalize(renderBackGround(ro.xy).xyz); //light color\n    vec3 oCol;\n    if(obj < .5)\n    oCol = vec3(0.6,.6,1.); //weird thing color\n    else\n    oCol = vec3(1);\t//pillar color\n    \n    vec3 h = (lDir-rd)/2.;\n    float s = pow(dot(norm,h),8.)*.7; //shininess\n    \n    float NdotL = max(dot(norm,lDir),.5); \n    \n    float sh = shadow(ro, lDir);\n    \n    vec3 light = (oCol*lCol*NdotL+s)*sh;\n    return vec4(light,1.);\n}\n\nvec3 normal(in vec3 p){ //calcs angle of a surface\n\tconst float eps = 0.001; \n    \n    //float base = map(p).x;\n\n    return normalize(\n        vec3(\n            map(p+vec3(eps,0.,0.)).x - map(p-vec3(eps,0.,0.)).x,\n            map(p+vec3(0.,eps,0.)).x - map(p-vec3(0.,eps,0.)).x,\n            map(p+vec3(0.,0.,eps)).x - map(p-vec3(0.,0.,eps)).x\n            )\n        );\n}\n\nvec4 renderSurface(in vec3 p, in vec3 rd, in float obj){\n\tvec3 n = normal(p);\n    return simpleLambert(p, n, rd, obj);\n}\n\n\nvec4 march(vec3 ro, vec3 rd){\n\tfloat t = 0.; //distance marched along ray\n    vec2 d;\t//.x: dist from nearest obj, .y: nearest obj number\n    vec3 p; //current position\n    \n    for(int i = 0; i < 170; i++){\n        p = ro + rd*t;\n\t\td = map(p);\n        t += d.x*.7;\n        if(d.x < 0.001) break; //if we hit something, exit the loop\n        if(d.x > 6.) break;\n    }\n    if(d.x < 1.)\n  \t\treturn renderSurface(p, rd, d.y); //render whatever we were closest to on exiting the loop\n    else\n        return renderBackGround(ro.xy);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = 2.*(uv-.5);\n    uv.y /= iResolution.x/iResolution.y;\n    \n    //uv += .01*noise(uv.x+sin(t)); //cool glass/rain-like effect\n    \n    //ray origin & ray direction\n    vec3 ro = vec3(0.,-1.,-3.+1.*sin(t/5.));\n    vec3 rd = normalize(vec3(uv,1.));\n    \n    float a = 1.6*pi+.1*sin(t/5.); //camera rot up/down\n    rd.yz *= mat2(sin(a),cos(a),cos(a),-sin(a));\n    \n    float rot = 2.*pi*abs(fract(t/16.)-.5); //camera rot xz\n    float s = sin(rot), c = cos(rot);\n    rd.xz *= mat2(s,c,c,-s);\n    ro.xz *= mat2(s,c,c,-s);\t//camera move xz\n    \n    vec4 t = march(ro,rd);\n    \n\tfragColor = pow(t+cos(uv.y*2.)-1., vec4(.5));//vignettes make everything look nicer\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}