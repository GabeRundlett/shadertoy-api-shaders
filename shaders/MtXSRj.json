{
    "Shader": {
        "info": {
            "date": "1437863139",
            "description": "New to raymarching, playing around with stuff. \nCredit to IÃ±igo QuÃ­lez for the distance field functions, which I've mutilated horribly. :)",
            "flags": 0,
            "hasliked": 0,
            "id": "MtXSRj",
            "likes": 16,
            "name": "City road",
            "published": 3,
            "tags": [
                "basic",
                "raymarch"
            ],
            "usePreview": 0,
            "username": "Cubed",
            "viewed": 2074
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 128\n#define MAX_DISTANCE 200.0\n#define SURF_DIST 0.001\n\nconst float PI = 3.14159265359;\n\nvec3 opRep(vec3 p, vec3 c) {\n    return mod(p, c) - 0.5 * c;\n}\n\nfloat opU(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nmat2 rotation(float theta) {\n    float s = sin(theta);\n    float c = cos(theta);\n    return mat2(c, -s, s, c);\n}\n\nfloat map(vec3 p) {\n    float res = sdBox(opRep(p, vec3(11.0, 0.0, 11.0)), vec3(3.0, 8.0, 3.0));\n    res = opU(res, sdBox(opRep(p + vec3(0.0, -4.0, 5.0), vec3(0.0, 0.0, 10.0)), vec3(1.0, 0.2, 5.0)));\n    res = opU(res, sdBox(opRep(p + vec3(0.0, -4.3, 0.0), vec3(0.0, 0.0, 4.0)), vec3(0.1, 0.05, 0.8)));\n    res = opU(res, p.y);\n    return res;\n}\n\nfloat trace(vec3 origin, vec3 direction, out int steps) {\n    float t = 0.0;\n    steps = 0;\n\n    for (int i = 0; i < MAX_STEPS; i++) {\n        if (t > MAX_DISTANCE) break;\n        vec3 p = origin + direction * t;\n        float d = map(p);\n        if (d < SURF_DIST) {\n            break;\n        }\n        t += d;\n        steps++;\n    }\n\n    return t;\n}\n\nvec3 calcNormal(vec3 pos) {\n    vec3 n = vec3(0.0);\n    for(int i = 0; i < 4; i++) {\n        vec3 e = 0.5773 * (2.0 * vec3(((i+3)>>1)&1, (i>>1)&1, i&1) - 1.0);\n        n += e * map(pos + 0.0005 * e);\n    }\n    return normalize(n);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt) {\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 24; i++) {\n        float h = map(ro + rd * t);\n        if (h < SURF_DIST){\n            return 0.0;\n        }\n        float s = clamp(8.0 * h / t, 0.0, 1.0);\n        res = min(res, s);\n        t += clamp(h, 0.01, 0.2);\n        if(res < 0.004 || t > maxt) break;\n    }\n    res = clamp(res, 0.0, 1.0);\n    return res * res * (3.0 - 2.0 * res);\n}\n\nfloat ambientOcclusion(vec3 pos, vec3 nor) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.12 * float(i) / 4.0;\n        float d = map(pos + h * nor);\n        occ += (h - d) * sca;\n        sca *= 0.95;\n        if(occ > 0.35) break;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0) * (0.5 + 0.5 * nor.y);\n}\n\nvec3 skyHorizonColor = vec3(0.6, 0.8, 1.0);\nvec3 skyZenithColor = vec3(0.0, 0.0, 0.3);\n\nvec3 addSun(vec3 rayDir) {\n    vec3 sunDir = normalize(vec3(0.2, 0.8, 0.5));\n    float sunIntensity = pow(max(dot(rayDir, sunDir), 0.0), 100.0);\n    vec3 sunColor = vec3(1.0, 0.9, 0.6);\n    return sunColor * sunIntensity;\n}\n\nvec3 getSkyColor(vec3 rayDir) {\n    float t = clamp(rayDir.y * 0.5 + 0.5, 0.0, 1.0);\n    vec3 skyColor = mix(skyHorizonColor, skyZenithColor, t);\n    skyColor += addSun(rayDir);\n    return skyColor;\n}\n\nfloat D_GGX(vec3 N, vec3 H, float roughness) {\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH * NdotH;\n\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return a2 / denom;\n}\n\nfloat G_SchlickGGX(float NdotV, float roughness) {\n    float r = roughness + 1.0;\n    float k = (r * r) / 8.0;\n    float denom = NdotV * (1.0 - k) + k;\n    return NdotV / denom;\n}\n\nfloat G_Smith(vec3 N, vec3 V, vec3 L, float roughness) {\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float G1 = G_SchlickGGX(NdotV, roughness);\n    float G2 = G_SchlickGGX(NdotL, roughness);\n    return G1 * G2;\n}\n\nvec3 F_Schlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 cookTorranceBRDF(vec3 N, vec3 V, vec3 L, vec3 F0, float roughness) {\n    vec3 H = normalize(V + L);\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float NdotH = max(dot(N, H), 0.0);\n    float VdotH = max(dot(V, H), 0.0);\n\n    float D = D_GGX(N, H, roughness);\n    float G = G_Smith(N, V, L, roughness);\n    vec3 F = F_Schlick(VdotH, F0);\n\n    vec3 numerator = D * G * F;\n    float denominator = 4.0 * NdotV * NdotL + 0.001;\n    vec3 specular = numerator / denominator;\n\n    vec3 kD = vec3(1.0) - F;\n    kD *= 1.0;\n    vec3 diffuse = kD * vec3(0.3);\n\n    return (diffuse + specular) * NdotL;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float speed = 32.0;\n\n    float oscillateFrequency = 0.5;\n    float oscillateAmplitudeX = 1.7;\n    float oscillateAmplitudeY = 4.5;\n    float baseHeight = 5.5;\n\n    float oscillateX = sin(iTime * oscillateFrequency) * oscillateAmplitudeX;\n    float oscillateY = cos(iTime * oscillateFrequency) * oscillateAmplitudeY + baseHeight;\n\n    vec3 cameraPos = vec3(oscillateX, oscillateY, iTime * speed);\n\n    vec3 target = cameraPos + vec3(0.0, 0.0, 1.0);\n\n    vec3 forward = normalize(target - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n\n    float tiltAmount = 0.1;\n    vec3 tiltedRight = normalize(right + up * tiltAmount * sin(iTime * oscillateFrequency));\n    vec3 tiltedUp = normalize(up - right * tiltAmount * sin(iTime * oscillateFrequency));\n\n    vec3 rayDir = normalize(uv.x * tiltedRight + uv.y * tiltedUp + forward);\n\n    int steps;\n    float t = trace(cameraPos, rayDir, steps);\n\n    bool hit = t < MAX_DISTANCE;\n\n    vec3 color = vec3(0.0);\n\n    if (hit) {\n        vec3 hitPoint = cameraPos + rayDir * t;\n\n        vec3 normal = calcNormal(hitPoint);\n\n        vec3 V = normalize(cameraPos - hitPoint);\n        vec3 L = normalize(vec3(1.0, 1.0, 0.5));\n\n        vec3 F0 = vec3(0.04);\n        float roughness = 0.5;\n\n        vec3 brdf = cookTorranceBRDF(normal, V, L, F0, roughness);\n\n        float shadow = softShadow(hitPoint + normal * SURF_DIST, L, 0.01, 10.0);\n\n        float ao = ambientOcclusion(hitPoint, normal);\n\n        vec3 ambientBase = vec3(0.1);\n        vec3 ambientAO = vec3(0.3) * ao;\n        vec3 ambient = ambientBase + ambientAO;\n        ambient = clamp(ambient, 0.0, 1.0);\n\n        vec3 finalLighting = ambient + brdf * shadow;\n\n        color = finalLighting;\n    } else {\n        color = getSkyColor(rayDir);\n    }\n\n    color = pow(color, vec3(1.0 / 2.2));\n\n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}