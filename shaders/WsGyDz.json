{
    "Shader": {
        "info": {
            "date": "1602677399",
            "description": "An animated asymmetric hexagon-based random stringy woven Truchet jigsaw pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "WsGyDz",
            "likes": 49,
            "name": "Animated Hexagon Truchet Chords",
            "published": 3,
            "tags": [
                "voronoi",
                "hexagon",
                "truchet",
                "string",
                "jigsaw",
                "weave",
                "zentangle",
                "chord",
                "asymmetric"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 755
        },
        "renderpass": [
            {
                "code": "/*\n\n\tAsymmetric Hexagon Truchet\n    --------------------------\n\n\tI was just thinking the other day that there weren't enough animated \n    asymmetric hexagon-based random stringy woven Truchet jigsaw examples \n    on Shadertoy, so finally we have one... Yeah, I'm not sure where I was\n\theading with this either. :D\n    \n    I haven't seen code for hexagon jigsaw patterns, but it would likely \n    exist. I doubt there'd be any for animated asymmetric ones, but you \n    never know. As for multitiled woven Truchet patterns on this kind of \n    setup, I doubt anyone would get bored enough to code that up, so I \n    imagine this example is unique in that sense. :)\n\n    Anyway, it looks interesting enough, plus it pulls together a few \n    simple concepts that aren't particularly difficult to grasp, like \n    repetition, offsetting grid vertices, layering and Bezier curve \n    rendering. \n\n    I intend to put together a quasi 3D version at some stage, but that'll\n\trequire a little more thought. By the way, the define options are in \n    the \"Common\" tab.\n\n\n    Other examples:\n\n    // Uses a very similar formula, but includes extrusion.\n\tAsymmetric Hexagon Landscape - Shane\n \thttps://www.shadertoy.com/view/tdtyDs\n\n    // It doesn't contain strings in the strictest sense, but it's stringy and \n    // just plain pretty to watch.\n\tSinuous - nimitz\n\thttps://www.shadertoy.com/view/4sGSDw\n\n*/ \n\n\n \n// Global vertices and local coordinates of the triangle cell.\n// It's lazy putting them here, but I'll tidy them up later.\nvec2[6] gV;\nvec2 gP;\n\n// A grid of asymmetrical hexagons grid. Four packed hexagons are constructed\n// in a checkered space filling arrangement, then the matching vertices are\n// randomly offset to give a pseudo Vornoi look, but with the benefit of \n// maintaining access to the vertex information, which can be beneficial for\n// all kinds of things.\nvec4 blocks(vec2 q){\n    \n\n    // Block dimension: Length to height ratio with additional scaling.\n    const vec2 dim = GSCALE;\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.;\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n     // Four block corner postions.\n    const vec2 ll = vec2(.5);\n    // Pointed top.\n    #ifdef FLAT_TOP\n    // Flat top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll + vec2(0., ll.y), -ll, vec2(ll.x, -ll.y) + vec2(0., ll.y));\n    #else\n    // Pointed top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll + vec2(ll.x, 0), vec2(ll.x, -ll.y) + vec2(ll.x, 0));\n    #endif   \n  \n    \n    float hexID = 0.; // Triangle ID. Not used in this example, but helpful.\n    \n\n    // Initializing the global vertices and local coordinates of the triangle cell.\n    gV = vec2[6](vec2(0), vec2(0), vec2(0), vec2(0), vec2(0), vec2(0));\n    gP = p;\n    \n    for(int i = min(0, iFrame); i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.; \n         \n        p = q.xy; // Local coordinates.\n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        \n        // Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n        // Hexagon vertices. \n        vec2[6] vert = vID;  \n      \n        #ifdef OFFSET_VERTICES\n        // Offsetting the vertices. Note that accuracy is important here. I had a bug for\n        // a while because I was premultiplying by \"s,\" to save some calculations, which meant\n        // points were not quite meeting at the joins... I won't bore you with the rest,\n        // except to say that it's necessary to keep these numbers simple.\n        const float vo = .1;\n        vert[0] += hash22B((idi + vert[0]/2.))*vo;\n   \t\tvert[1] += hash22B((idi + vert[1]/2.))*vo;\n        vert[2] += hash22B((idi + vert[2]/2.))*vo;  \n        vert[3] += hash22B((idi + vert[3]/2.))*vo; \n        vert[4] += hash22B((idi + vert[4]/2.))*vo;  \n        vert[5] += hash22B((idi + vert[5]/2.))*vo;\n        #endif\n \n        \n        // Scaling to enable rendering back in normal space.\n        vert[0] *= dim;\n        vert[1] *= dim;\n        vert[2] *= dim;\n        vert[3] *= dim; \n        vert[4] *= dim;\n        vert[5] *= dim;\n        \n        // Scaling the cell ID.\n\t    //idi = idi*s;\n           \n        // The polygon. This is IQ's robust polygon formula, but you could use\n        // a faster, specialized one if speed was the utmost concern, which I\n        // don't believe is the case here.\n        float face = sdPoly(p, vert);\n        //vec2 inC = (vert[0] + vert[1] + vert[2] + vert[3] + vert[4] + vert[5])/6.;\n        //idi += inC.xy;\n        \n        // If applicable, update the overall minimum distance value,\n        // ID, and object ID. \n        if(face<d){\n            d = face;\n            id = idi;\n            hexID = float(i);\n            \n            // Setting the vertices and local coordinates.\n            gV = vert;\n            gP = p;\n     \n        }\n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return vec4(d, id, hexID);\n}\n\n \nvoid swap(inout int a, inout int b){ int tmp = a; a = b; b = tmp; }\n// A swap without the extra declaration -- It works fine on my machine, but I'm\n// not game  enough to use it, yet. :)\n//void swap(inout int a, inout int b){ a = a + b; b = a - b; a = a - b; }\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Set the global time, since the \"Common\" tab doesn't recognize\n    // the \"iTime\" variable.\n    setTime(iTime);\n    \n    // Global scale. Rendundant here.\n    const float gSc = 1.;\n    // Smoothing factor.\n    float sf = gSc/iResolution.y;\n    \n    // Scaled than transalated coordinates.\n    vec2 p = uv*gSc + vec2(0, .5)*iTime/8.;\n    \n    // The asymmetric hexagon shadow information for the current cell.\n    vec4 d4Sh = blocks(p - vec2(-.01, -.015));\n    vec2 svPSh = gP; // Shadow local coordinates.\n    vec2[6] svVSh = gV; // Shadow offset vertex information.\n    \n    // The asymmetric hexagon information for the current cell.\n    vec4 d4 = blocks(p);\n    vec2 svP = gP; // Local coordinates.\n    vec2[6] svV = gV; // The offset vertex information.\n    \n    // Time varying pixel color\n    vec3 col = vec3(1, .8, .6);\n   \n     \n    // A random number associated with this particular tile. Note that\n    // the scaling factor has been applied. It's not necessary, but looks\n    // better when using textures... which we're not doing. :)\n    vec2 s = GSCALE;\n    float rndH = hash21(d4.yz*s);\n    \n    // Containers for the midpoint edges and corresponding\n    // normals for the string and string shadows.\n    vec4 svEP[6];\n    vec4 svEPSh[6];\n    \n    for(int j = 0; j<6; j++){\n        \n        // Constructing the edge midpoints and normals at those\n        // points for both the string and corresponding shadows.\n        vec2 g, g1, nj;\n        \n        g = svV[j];\n        g1 = svV[(j + 1)%6];\n        nj = normalize(g1 - g).yx*vec2(1, -1);\n        svEP[j] = vec4(mix(g, g1, .5), nj);\n        \n        g = svVSh[j];\n        g1 = svVSh[(j + 1)%6]; \n        nj = normalize(g1 - g).yx*vec2(1, -1);\n        svEPSh[j] = vec4(mix(g, g1, .5), nj);\n        \n    }\n   \n    for(int j = 0; j<6; j++){\n            \n       \n        // Randomly adding or subtracing jigsaw nodules to the hexagon tile sides.\n        // The logic is straight forward, but I tend to forget it after a while,\n        // which is why I always have to refer to my old examples. :)\n\n        // Random number holder -- Used for coloring.\n        float rndC = 0.;\n        // The unique random number of the current tile edge.\n        float rndj = hash21(d4.yz + float(j));\n        // The unique random number of the same tile edge, but from the\n        // neighboring tile. As an aside, I forget this logic every single\n        // time, and if I try to reason it out too much, it confuses me all \n        // over again. :D\n        float rndjNeigh = hash21((d4.yz + eID[j]) + float((j + 3)%6));\n         \n        float nodule = length(svP - svEP[j].xy) - .025 - .0075;\n        /*\n        // Mid edge points via polar coordinates. If you render an \n        // object requiring orientation (like a square nodule), rotation\n        // will play a part.\n        float ang = atan(svEP[j].y, svEP[j].x); \n        vec2 spos = vec2(cos(ang), sin(ang))*length(svEP[j].xy);\n        vec2 newP = rot2(-atan(svEP[j].z, svEP[j].w))*(svP - spos);\n        float nodule = sBoxS(newP, vec2(.026, .026), .007);\n        */\n        \n        // Annoying equality hack. I'll come up with something better than this.\n        if(rndj==rndjNeigh) {\n            // If the two random numbers are equal, add a nodule to the tile\n            // with the largest ID distance. \n            if(length(d4.yz)<length(d4.yz + eID[j])) rndjNeigh += 1e-6;\n        }\n   \n        // If the random number associated with this side is greater that the\n        // random number associated with the same side, but from the neighboring\n        // tile, add a jigsaw nodule to that side. Otherwise, take one away.\n        if(rndj<rndjNeigh){\n            \n            // Add a jigsaw nodule to the hexagonal tile side and give it \n            // the same color as the current tile.\n            rndC = rndH;\n            d4.x = min(d4.x, nodule);\n        }\n        else {\n            \n            // Subtrace a jigsaw nodule from the hexagonal tile side (in effect adding \n            // it to the neighbor) and give it the same color as the neighboring tile.\n            rndC = hash21((d4.yz + eID[j])*s);\n            d4.x = max(d4.x, -(nodule));\n        } \n        \n        // Applying the colored nodule to this particular tile edge.\n        vec3 nCol = .5 + .45*cos(6.2831853*rndC/4. + vec3(0, 1, 2));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, nodule + .005));\n        col = mix(col, nCol, 1. - smoothstep(0., sf, nodule + .01));\n          \n    }\n    \n    // Applying the newly constructed hexagon jigsaw tile.\n    //float sh2 = max(.75 - d4.x/.1, 0.);\n    vec3 cCol = .5 + .45*cos(6.2831853*rndH/4. + vec3(0, 1, 2));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, d4.x + .005));\n    col = mix(col, cCol, 1. - smoothstep(0., sf, d4.x + .01)); \n    \n    \n \n    // For aesthetic purposes and visual interest, we won't connect all points, \n    // so these numbers represent the total connection points for the string and shadows.\n    int numP = 0;\n    int numPSh = 0;   \n    \n    // Distance field for the edge points and the corresponding shadows.\n    float ePnt = 1e5;\n    float ePntSh = 1e5;\n    \n    for(int j = 0; j<6; j++){\n        \n        // Continuous chord pattern\n        #ifdef CONTINUOUS\n        \n        // The edge point distance field.\n        ePnt = min(ePnt, length(svP - svEP[j].xy));\n        // Saving the end points and corresponding normals\n        svEP[numP++] = svEP[j];\n        // Shadow.\n        ePntSh = min(ePntSh, length(svPSh - svEPSh[j].xy));\n        svEPSh[numPSh++] = svEPSh[j];\n        \n        #else\n        // Broken chord pattern.\n        // Randomly select just a few edges.\n        \n        // Connected edge threshold -- Higher numbers convert to more edges.\n        const float th = .9;  \n        \n        /*\n        if(hash21(d4.yz + eID[j]/2.)<th){\n             //ePnt = min(ePnt, length(svP - svEP[j].xy));\n             svEP[numP++] = svEP[j];\n        }\n        \n        // Do the same for the shadows.\n        if(hash21(d4Sh.yz + eID[j]/2.)<th){\n            //ePntSh = min(ePntSh, length(svPSh - svEPSh[j].xy));\n            svEPSh[numPSh++] = svEPSh[j];\n        }\n        */\n         \n        if(hash21(d4.yz + float(j))<th && hash21(d4.yz + eID[j] + float((j + 3)%6))<th){\n            // The edge point distance field.\n            ePnt = min(ePnt, length(svP - svEP[j].xy));\n            // Saving the end points and corresponding normals\n            svEP[numP++] = svEP[j];\n        }\n        \n        // Do the same for the shadows.\n        if(hash21(d4Sh.yz + float(j))<th && hash21(d4Sh.yz + eID[j] + float((j + 3)%6))<th){\n            ePntSh = min(ePntSh, length(svPSh - svEPSh[j].xy));\n            svEPSh[numPSh++] = svEPSh[j];\n        }\n        #endif\n        \n    }\n \n    \n    #ifdef SHOW_CHORDS\n    \n    // Rendering the edge point shadows first.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*3., ePntSh - .02))*.7);\n    \n    // Rendering the edge point plug-looking things on the edges of the jigsaw pieces.\n    vec3 svC = col;\n    float jsh2 = max(.3 - (ePnt - .0225)/.021, 0.); // Matches the arcs.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ePnt - .0215));\n    col = mix(col, min(svC*2., 1.)*jsh2*1.5, 1. - smoothstep(0., sf, ePnt - .0215 + .005));\n    \n    float jSh = max(.3 - (ePnt - .012)/.02, 0.); // Matches the arcs.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ePnt - .012));\n    col = mix(col, vec3(1, .95, .9)*jSh*jSh*2., 1. - smoothstep(0., sf, ePnt - .012 + .005));\n\n    // Putting in a quick Z-buffer, so that shadows go underneath the right objects, etc.\n    // Anything added to the buffer won't be overwritten by shadows. It's a cheap hacky\n    // trick, but it works.\n    float zInd = 0.;\n    zInd = mix(zInd, 1., 1. - smoothstep(0., sf, max(ePntSh - .02, -(ePnt - .0215))));\n    #endif\n    \n    \n    // Forcing an even number of chord end points.\n    if((numP&1)==1) numP--;\n    if((numPSh&1)==1) numPSh--;\n    \n    \n    // Indices for shuffling, in order to render the chords in random order.\n    const int N2 = 6;\n    int shuff[N2] = int[N2](0, 1, 2, 3, 4, 5);  // Initializing the shuffle array.\n\n    \n    // Shuffling the variable array of points and normals -- Six is the maximum. I think this \n    // is the Fisherâ€“Yates method, but don't quote me on it. It's been a while since I've used \n    // a shuffling algorithm, so if there are inconsistancies, etc, feel free to let me know.\n    //\n    // For various combinatorial reasons, some non overlapping tiles will probably be \n    // rendered more often, but generally speaking, the following should suffice.\n    //\n    //int index = N;\n    for(int i = numP - 1; i>0; i--){\n\n        \n        // Using the cell ID and shuffle number to generate a unique random number.\n        float fi = float(i);\n        \n        // Random number for each edge position.\n        float rs = hash21(d4.yz + fi/float(numP));\n        \n        // Other array point we're swapping with.\n        //int j = int(floor(mod(rs*float(index)*1e6, fi + 1.)));\n        // I think this does something similar to the line above, but if not, let us know.\n        int j = int(floor(rs*(fi + .9999)));\n        swap(shuff[i], shuff[j]);\n         \n    }\n     \n    #ifdef SHOW_CHORDS\n    \n    // Rendering the chords.\n    for(int j = 0; j<6; j+=2){\n        \n        // Shuffle index for the end points.\n        int jj =  shuff[j];\n        int jj2 = shuff[(j + 1)%6];\n        \n        // Chord end points and corresponding normals to be fed into the Bezier function.\n        vec4 a = svEP[jj]; // End point one.\n        vec4 b = svEP[jj2]; // End point two.\n        vec4 aSh = svEPSh[jj]; // Shadow end point one.\n        vec4 bSh = svEPSh[jj2]; // hadow end point two.\n        \n        // Bezier chord distance fields and the arc width.\n        const float aw = .012; //.015*(n2D3G(p*6.)*.6 + .9);\n        float arc = 1e5, arcSh = 1e5;\n         \n        // Render the shadow chord first.\n        if(j<numPSh){\n           arcSh = doSeg(svPSh, aSh, bSh, length(aSh.xy)/4.) - aw;\n           arcSh = min(arcSh, min(length(svPSh - aSh.xy), length(svPSh - bSh.xy)) - aw );\n        }\n        \n        // Render the chord.\n        if(j<numP){\n            arc = doSeg(svP, a, b, length(a.xy)/4.) - aw;\n            arc = min(arc, min(length(svP - a.xy), length(svP - b.xy)) - aw);\n        }\n        \n      \n        // Rendering the chord shadow first.\n        // I don't like this hack, but it works. There is unintentional shadow\n        // coverage at the cell edges, and the last term stops it from happening.\n        if(zInd<1e-5 || step(0., d4Sh.x + .025)==0.){\n          col = mix(col, vec3(0), (1. - smoothstep(0., sf*3., arcSh))*.7);\n         \n        }\n      \n         \n        // Rendering the chord. \n        float sh = max(.3 - arc/.02, 0.);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, arc));\n        col = mix(col, vec3(1, .95, .9)*sh*sh*2., 1. - smoothstep(0., sf, arc + .005));\n        \n        // Updating the Z-buffer with the chord information.\n        zInd = mix(zInd, 1., 1. - smoothstep(0., sf, arc));\n\n   \n    } \n    \n    #endif\n \n \n    // Mixing in a bit of gradient color.\n    col = mix(col, col.xzy, length(uv)*.4);\n    \n    //col = mix(col.zyx, col.yxz, .8); // Other colors.\n                          \n\n    // Rough gamma correction, and we're done.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// Comment this out if you want to see the background jigsaw pattern on its own. \n#define SHOW_CHORDS\n\n// A continuous chord pattern -- No gaps.\n//#define CONTINUOUS\n\n// The example is less interesting with offset vertices, but much easier to construct. :)\n#define OFFSET_VERTICES\n\n// Hexagon arrangement. Flat top or pointed top.\n#define FLAT_TOP\n\n\n// This sets the scale of the extruded shapes.\n#ifdef FLAT_TOP\n#define GSCALE vec2(1./5.)*vec2(.8660254, 1)\n#else \n#define GSCALE vec2(1./5.)*vec2(1, .8660254)\n#endif\n\n#ifdef FLAT_TOP\n// Vertices and edge midpoints: Clockwise from the left.\nvec2[6] vID = vec2[6](vec2(-2./3., 0), vec2(-2./6., .5), vec2(2./6., .5), \n                      vec2(2./3., 0), vec2(2./6., -.5), vec2(-2./6., -.5)); \nvec2[6] eID = vec2[6](vec2(-.5, .25), vec2(0, .5), vec2(.5, .25), \n                      vec2(.5, -.25), vec2(0, -.5), vec2(-.5, -.25));\n#else\n//  Vertices and edge midpoints: Clockwise from the bottom left. -- Basically, the ones \n// above rotated anticlockwise. :)\nvec2[6] vID = vec2[6](vec2(-.5, -2./6.), vec2(-.5, 2./6.), vec2(0, 2./3.), \n                      vec2(.5, 2./6.), vec2(.5, -2./6.), vec2(0, -2./3.));\nvec2[6] eID = vec2[6](vec2(-.5, 0), vec2(-.25, .5), vec2(.25, .5), vec2(.5, 0), \n                      vec2(.25, -.5), vec2(-.25, -.5));\n#endif\n////////\n\n// Work around for the time variable.\nfloat gTime = 0.;\nvoid setTime(float tm){ gTime = tm; }\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Dave Hoskins's vec2 to float hash.\n// You can find the details here:\n//\n// Hash without Sine - Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash21(vec2 p){ \n    \n    //  2 in, 1 out. \n\tvec3 p3  = fract(vec3(p.xyx)*.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n    \n    // An annoying, but necessary, hack for systems with less sin\n    // function accuracy. If anyone knows a way around it, feel \n    // free to let me know.\n    //p = floor(p*1048576.)/1048576.;\n    //return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); \n}\n\n// Dave Hoskins's vec2 to float hash.\n// You can find the details here:\n//\n// Hash without Sine - Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW \nvec2 hash22B(vec2 p){ \n    \n     \n    // I've struggled with accuracy when offsetting vertices. However,\n    // Dave's function seems to work. If anyone experiences artifacts,\n    // feel free to let me know, and I'll try to work something out.\n    //\n    // 2 in, 2 out.\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    p = fract((p3.xx + p3.yz)*p3.zy)*2. - 1.;\n    \n    return sin(p*6.2831853 + gTime);\n     \n    /*\n    p = (floor(p*1024.) + .5)/1024.;\n    // IQ's vec2 to float hash.\n    p = vec2(dot(p, vec2(27.619, 113.583)), dot(p, vec2(57.527, 85.491)));\n    p = fract(sin(p)*43758.5453)*2. - 1.; \n    //return p;\n    \n    return sin(p*6.2831853 + gTime);\n    */\n} \n\n/*\n// vec2 to vec2 hash.\nvec2 hash22C(vec2 p) {\n    \n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    vec2 n = sin(vec2(dot(p, vec2(27.29, 57.81)), dot(p, vec2(7.14, 113.43))));\n    return fract(vec2(262144.1397, 32768.8793)*n)*2. - 1.; \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n);\n    //return sin(p*6.2831853 + gTime); \n    \n}\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22C(i), p);\n    v.y = dot(hash22C(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22C(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22C(i + 1.), p - 1.);\n\n#if 1\n    // Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    \n}\n\n*/\n\n// IQ's distance to a regular pentagon, without trigonometric functions. \n// Other distances here:\n// https://iquilezles.org/articles/distfunctions2d\n//\n#define NV 6\n//\nfloat sdPoly(in vec2 p, in vec2[NV] v){\n\n    const int num = v.length();\n    float d = dot(p - v[0],p - v[0]);\n    float s = 1.0;\n    for( int i = 0, j = num - 1; i < num; j = i, i++){\n    \n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1. );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\n// IQ's standard box function.\nfloat sBox(in vec2 p, in vec2 b){\n   \n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n \n\n// IQ's signed distance to a quadratic Bezier. Like all of IQ's code, it's\n// quick and reliable. :)\n//\n// Quadratic Bezier - 2D Distance - IQ\n// https://www.shadertoy.com/view/MlKcDD\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){\n  \n    // p(t)    = (1 - t)^2*p0 + 2(1 - t)t*p1 + t^2*p2\n    // p'(t)   = 2*t*(p0 - 2*p1 + p2) + 2*(p1 - p0)\n    // p'(0)   = 2*(p1 - p0)\n    // p'(1)   = 2*(p2 - p1)\n    // p'(1/2) = 2*(p2 - p0)\n    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n     // If I were to make one change to IQ's function, it'd be to cap off the value \n    // below, since I've noticed that the function will fail with straight lines.\n    float kk = 1./max(dot(b,b), 1e-6); // 1./dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\n// Rendering the smooth Bezier segment. The idea is to calculate the midpoint\n// between \"a.xy\" and \"b.xy,\" then offset it by the average of the combined normals\n// at \"a\" and \"b\" multiplied by a factor based on the length between \"a\" and \"b.\"\n// At that stage, render a Bezier from \"a\" to the midpoint, then from the midpoint\n// to \"b.\" I hacked away to come up with this, which means there'd have to be a more\n// robust method out there, so if anyone is familiar with one, I'd love to know.\nfloat doSeg(vec2 p, vec4 a, vec4 b, float r){\n    \n    // Mid way point.\n    vec2 mid = (a.xy + b.xy)/2.; // mix(a.xy, b.xy, .5);\n    \n    // The length between \"a.xy\" and \"b.xy,\" multiplied by... a number that seemed\n    // to work... Worst coding ever. :D\n    float l = length(b.xy - a.xy)/3.;//1.732/6.; // ;//\n \n    // Points on the same edge each have the same normal, and segments between them\n    // require a larger arc. There was no science behind the decision. It's just \n    // something I noticed and hacked a solution for. Comment the line out, and you'll \n    // see why it's necessary. By the way, replacing this with a standard semicircular \n    // arc would be even better, but this is easier.\n//    if(abs(length(b.zw - a.zw))<.01) l = r; \n  \n    // Offsetting the midpoint between the exit points \"a\" and \"b\"\n    // by the average of their normals and the line length factor.\n    mid += (a.zw + b.zw)/2.*l;\n\n    // Piece together two quadratic Beziers to form the smooth Bezier curve from the\n    // entry and exit points. The only reliable part of this method is the quadratic\n    // Bezier function, since IQ wrote it. :\n    float b1 = sdBezier(p, a.xy, a.xy + a.zw*l, mid);\n    float b2 = sdBezier(p, mid, b.xy + b.zw*l, b.xy);\n    \n    // Return the minimum distance to the smooth Bezier arc.\n    return min(b1, b2);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}