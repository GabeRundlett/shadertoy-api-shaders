{
    "Shader": {
        "info": {
            "date": "1662110647",
            "description": "Solving the Laplace equation in a domain specified by an SDF using the walk-on-spheres algorithm\n\nVariant of lisyarus [url] https://shadertoy.com/view/7lVcz3 [/url]\nusing animation-compatible boundary conditions + MIPmap for filtering ( click to compare).",
            "flags": 32,
            "hasliked": 0,
            "id": "7tGcWy",
            "likes": 10,
            "name": "Walk on spheres for Laplace eq2b",
            "published": 3,
            "tags": [
                "montecarlo",
                "pde",
                "laplace",
                "walkonspheres"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 433
        },
        "renderpass": [
            {
                "code": "// variant of https://shadertoy.com/view/7lVczc\n// Fork of \"Walk on spheres for Laplace eqn\" by lisyarus. https://shadertoy.com/view/7lVcz3 \n\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    U /= iResolution.xy;\n//  O = texture(iChannel0,U, 2.); O = vec4( O.w > 0. ? .5+.5*sin(40.*O.y/O.w) : 0. );\n\n    O = texture(iChannel0,U, iMouse.z>0. ? 0. : 3.);\n    O = vec4( texture(iChannel0,U).w > 0. ? .5+.5*sin(40.*O.x ) : 0. );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define C(p,r) ( r - length(p) )                             // circle SDF\n#define B(p,r) ( r - max(abs(p).x,abs(p).y) )                // box SDF\n#define D(c,v) l = c, l < d ? d=l, b=v : v  \n\n#define T iTime\n\nfloat SDF(vec2 p, out float b ) {                            // scene SDF. out = border id or value\n    float d = 1e4, l; \n          D( B(p, 1.) , 1. );\n          D( -C(p - 1., .4) , 1. );\n          D( -C(p - vec2(-1, 1), .7) , 1. );\n          D( -C(p - vec2( 1,-1), .5), 1. );\n          D( -C(p +  1., .8), 1. );\n          D( -C(p+.3*vec2(cos(T),sin(1.3*T)), .5), 0. );\n    return   d;\n}\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy, s,\n          p = ( u+u - R ) / R.y; \n    float v = 0., j,i = v, b,  N = 256.;\n    \n    if ( SDF(p,b) < -.05 ) { O-=O; return; }\n\n    for ( ; i++ < N                                          // diffusion = averaging N random walks\n          ; v += b                                           // boundary condition\n        ) \n        for ( s = p, j = 0.; j++ < 8.; )                     // random walk from sphere marching ( S steps )\n            s += SDF(s,b) * cos( 6.28* fract(sin( dot(s,R-17.) + (i-T)*269. ) *4e4 ) // CosSin( 2pi*hash(s) )\n                               + vec2(0,11));\n    \n    O =  vec4(  v/N , SDF(p,b) < 0. ? 0. : v/N, 0, SDF(p,b) > 0.);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}