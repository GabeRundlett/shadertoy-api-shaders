{
    "Shader": {
        "info": {
            "date": "1723243084",
            "description": "ps : it's a bit broken rn cuz i'm working on rotations",
            "flags": 0,
            "hasliked": 0,
            "id": "XXyGRG",
            "likes": 1,
            "name": "potted plant",
            "published": 3,
            "tags": [
                "sdf",
                "tree",
                "plant"
            ],
            "usePreview": 0,
            "username": "dottedboxguy",
            "viewed": 177
        },
        "renderpass": [
            {
                "code": "//thxs to iq for the SDFs and a few other things\n\n#define MAXSTEP 1024\n#define MAXDIST 200.0\n#define MINDIST 0.001\n#define TWOPI 6.28318530718\n\nfloat dot2(vec2 v){return v.x*v.x - v.y*v.y;}\n\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(1.,.0,.0),    vec3(.0,ca,sa),   vec3(.0,-sa,ca));}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(ca,.0,sa),    vec3(.0,1.,.0),   vec3(-sa,.0,ca));}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(ca,sa,.0),    vec3(-sa,ca,.0),  vec3(.0,.0,1.));}\n\nfloat opUnion( float d1, float d2 ){\n    return min(d1,d2);\n}\n\nfloat opSubtraction( float d1, float d2 ){\n    return max(-d1,d2);\n}\n\nfloat opIntersection( float d1, float d2 ){\n    return max(d1,d2);\n}\n\nfloat opSmoothUnion( in float d1, in float d2, in float k ){\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( in float d1, in float d2, in float k ){\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s ){\n  return length(p)-s;\n}\n\nfloat sdCapsule( vec3 p, float h, float r )\n{\n  p.z -= clamp( p.z, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat dot2(in vec3 v ) { return dot(v,v); }\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h ){\n  vec2 d = vec2( length(p.xy)-2.0*ra+rb, abs(p.z) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb){\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\nfloat sdPot(vec3 p){\n    float d = sdCappedCone(p, vec3(.0,.0,-0.2), vec3(.0,.0,.1), 0.1, 0.2) - 0.01;\n    vec3 top_part = vec3(.0, .0, .09);\n    d = opSmoothUnion(d, sdRoundedCylinder(p - top_part, .11, .01, .02), 0.02);\n    d = opSmoothSubtraction(sdCappedCone(p, vec3(.0,.0,-0.1), vec3(.0,.0,.2), 0.11, 0.21), d, 0.01);\n    return d;\n}\n\nfloat sdDirt(vec3 p){\n    return sdCappedCone(p, vec3(.0,.0,-0.1), vec3(.0,.0,.09), 0.11, 0.21);\n}\n\nvec3 angledCircle(in float t, in float r, in float a_x, in float a_z){\n    float cx = cos(a_x*TWOPI);\n    float sx = sin(a_x*TWOPI);\n    float cz = cos(a_z*TWOPI);\n    float sz = sin(a_z*TWOPI);\n    return r*(cos(t*TWOPI)*vec3(cz, -sz, 0.) + sin(t*TWOPI)*vec3(sz*cx, cx*cz, -sx)); //x-z order\n}\n\nfloat nextBranchAngle(in float angle_range, in float branch_count,  //these should be constant over a tree\n                in float branch_id, in float last_branch_orientation){\n    return last_branch_orientation+angle_range-(2.*angle_range*branch_id/(branch_count-1.));\n}\n\n\nfloat sdTree(in vec3 p, in int dep){\n\n    const float branch_count = 5.;\n    const int brnch_count = 5;\n    float angle_range = cos(iTime/2.);\n    const float thickness = .05;\n    float initial_d = length(p); // (; https://www.youtube.com/watch?v=dv13gl0a-FA\n    \n    float depth = 1.;\n    float branch = 1.;\n\n    float d = initial_d - thickness;\n    vec3 current_pos = vec3(0.);\n    \n    vec3 working_pos = vec3(0.);\n    float working_d = 0.;\n    \n    vec3 chosen_pos = current_pos;\n    float chosen_d = 0.;\n    \n    vec3 last_pos = vec3(0., 0., -1.);\n    \n    float angle_z = .0;\n    float angle_x = .05;\n    \n    \n    for (int dep_i = 0;dep_i<dep;dep_i++){\n    \n        //angle_z = acos(normalize((current_pos - last_pos).xy).x);\n        //angle_x = acos(normalize((rotate_z(-angle_z)*(current_pos - last_pos)).xz).x)/TWOPI;\n        angle_z = angle_z/TWOPI;\n    \n        chosen_pos = current_pos + normalize((current_pos - last_pos))*.3/depth + angledCircle(0., .2/depth, angle_x, angle_z);\n        chosen_d = sdRoundCone(p, chosen_pos, current_pos, thickness/(depth+.9), thickness/depth);\n        \n        if (dep_i == dep-1){\n            chosen_d = sdRoundCone(p, chosen_pos, current_pos, thickness, thickness/depth);\n        }\n        \n        for(int brnch = 1; brnch<=brnch_count-1;brnch++){\n            \n            working_pos = current_pos + normalize((current_pos - last_pos))*.3/depth + angledCircle(branch/branch_count, .2/depth, angle_x, angle_z);\n            working_d = sdRoundCone(p, working_pos, current_pos, thickness/(depth+.9), thickness/depth);\n            \n            if (dep_i == dep-1){\n                working_d = sdRoundCone(p, working_pos, current_pos, thickness, thickness/depth);\n            }\n            \n            if (working_d < chosen_d){\n                chosen_pos = working_pos;\n                chosen_d = working_d;\n            }\n            \n            branch++;\n        }\n        \n        \n        d = min(d,chosen_d);\n        \n        last_pos = current_pos;\n        current_pos = chosen_pos;\n        \n        chosen_d = initial_d;\n        branch = 1.;\n        depth++;\n    }\n    \n    return d;\n}\n\n\n\n\nfloat sdFlowerPot(vec3 p){\n    float d = sdPot(p);\n    d = opUnion(sdDirt(p), d);\n    d = opUnion(sdCapsule(p, .4, .05), d);\n    d = opUnion(sdTree(p-vec3(0.,0.,.4), 4), d);\n    //d = sdTree(p, 4);\n    return d;\n}\n\nfloat map(in vec3 p){\n    //float d = sdSphere(p, 1.5);\n    float d = sdFlowerPot(p);\n    //color = vec4(gridTexture(color.yw));\n    //float d = sdHeart(p);\n    return d;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\nvec3 color(vec3 p){\n    float dPot = sdPot(p);\n    float dDirt = sdDirt(p);\n    float dTree = opUnion(sdCapsule(p, .5, .05), sdTree(p-vec3(0.,0.,.4), 4));\n    vec3 col = mix(vec3(.686, .353, .196), vec3(.32, .2, .097), clamp(3000.*(dPot-dDirt), 0., 1.));\n    col = mix(col, vec3(0.388, 0.194, 0.0), clamp(30.*(dDirt-dTree), 0., 1.));\n    col = mix(col, vec3(0.101, 0.325, 0.098), clamp((p.z-.9)*16.,0., 1.));\n   \n    //lighting, comes from iq, i just fiddled with the values a bit\n    vec3 nor = calcNormal(p);\n    float dif = clamp(dot(nor,vec3(0.57703)), 0.0, 1.0);\n    float amb = 0.5 + 0.5*dot(nor,vec3(.0,.0,1.));\n    col *= amb + vec3(0.5,0.5,0.5)*dif;\n    \n    return col;\n}\n\nvec3 render(in vec3 p, in vec2 fragCoord){\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.xy;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 dir = normalize(vec3(uv.x, 1.0, uv.y));\n    dir *= rotate_x(.3);\n    dir *= rotate_z(iTime);\n    float init_d =  map(p + dir);\n    float d = init_d;\n    float t = d;\n    \n    for (int i = 0; i < MAXSTEP; i++){\n        if (d < MINDIST*init_d){\n            return color(p + dir*t);\n            //return vec3(0.);\n        }\n        else if (t > MAXDIST){\n            return vec3(.992, .961, .902);\n        }\n        d = map(p + dir*t);\n        t += d;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //vec3 p = vec3(cos(iTime), -4.0, sin(iTime));\n    //vec3 p = vec3(0.);\n    vec3 p = vec3(0., -5., 1.89);\n    //vec3 p = vec3(0., -5., .89);\n    p *= rotate_z(iTime);\n \n    vec3 col = render(p, fragCoord).xyz;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}