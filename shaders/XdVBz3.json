{
    "Shader": {
        "info": {
            "date": "1529821145",
            "description": "This is a simple tweak to roice3's awesome work here:\n\nhttps://www.shadertoy.com/view/MstcWr\n\nJust to give it a little bit of animation and some color pulse.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdVBz3",
            "likes": 6,
            "name": " Isometries Hyperbolic 3 Tweak",
            "published": 3,
            "tags": [
                "fractal",
                "surface"
            ],
            "usePreview": 0,
            "username": "Chris_M_Thomasson",
            "viewed": 743
        },
        "renderpass": [
            {
                "code": "// Little color and animation tweak by Chris M. Thomasson\n\n// Isometries of Hyperbolic 3-Space, by Roice Nelson\n// license: Creative Commons Attribution-Share Alike 4.0 International license.\n//\t\t\thttps://creativecommons.org/licenses/by-sa/4.0/deed.en\n//\n// Coloring adapted from: https://www.shadertoy.com/view/ld3GWS\n//\n// See http://roice3.org/h3/isometries/ for more explanation than below.\n//\n// This shader shows basic isometries (length preserving transformations) of hyperbolic \n// 3-space in the upper half space model. The z=0 plane is the boundary plane-at-infinity.\n// There are four classes of transformations: parabolic, elliptic, hyperbolic, and loxodromic. \n// These may fix 1 or 2 ideal points on the boundary plane. \n//\n// In general, any Mobius transformation applied to the boundary plane will extend to an isometry\n// of hyperbolic 3-space, but all can be built by composition of the basic transformations.\n//\n// Controls:\n// Key 1 - toggle elliptic on/off\n// Key 2 - toggle hyperbolic on/off\n// \t\tIf both are off, parabolic will be shown.\n// \t\tIf both are on, loxodromic will be shown (default).\n// Key F - for transformations with 2 fixed points, toggles the location of the fixed points.\n// Key A - toggle between two different grid spacings.\n//\n// -- 2 fixed point cases (elliptic, hyperbolic, loxodromic) --\n// The surface above the plane is a Dupin cyclide, or an inversion of a cone, which touches\n// the boundary at two fixed points. Except for elliptic (which fixes all points along a line \n// in the space), these are the only fixed points. A given point in hyperbolic space will be \n// confined to one cyclide (in a family of nested cyclides). Loxodromic transformations are a \n// combination of elliptic and hyperbolic, and may be more or less twisted depending on the \n// relative contribution of each.\n//\n// -- 1 fixed point case (parabolic) --\n// The sphere is a horosphere that kisses the plane at the origin, which is also \n// the center of the horosphere and the single fixed point of the transformation.  \n// A given point in hyperbolic space will be confined to one horosphere (in a family of nested \n// horospheres). Parabolic transformations are conjugate to translations (where the fixed point \n// is at infinity).\n\n\nbool applyMobius = true;\nbool elliptic = true;\nbool hyperbolic = true;\n\n// These will get set based on values above, so editing won't do anything.\nbool parabolic;\nbool loxodromic;\n\n// You can change the grid by editing these.\nfloat modPhase = 7.;\t\t// pi/X \nfloat modModulus = .4;\t\t// hyperbolic distance\n\n// Time factor, <1. for slow motion, >1. for faster movement\nconst float time_factor = 0.5;  \n\n// Controls how fast the color changes.\n// This is kind of high by default because I wanted to make looping gifs.\nconst float hue_time_factor = 1.0/3.;\n\n// Returns a scaling factor to make the raymarching work well.\nMobius fixedPointMobius;\nfloat ApplyMobius( inout vec3 p )\n{\n    if( !applyMobius )\n        return 1.0;\n    \n    vec4 t = M_Apply( fixedPointMobius, vec4( p, 0 ) );\n    p = t.xyz;\n    \n    // Needed to make the raymarching work well.\n    float scale = length( p );\n    if( scale > 1. ) scale = 1./scale;\n    return scale;\n}\n\nvoid IsometryHyperbolic( inout vec2 p )\n{   \n    float mag = length( p );\n    mag = UHStoH( mag ) - iTime*time_factor*modModulus;\n    Mod( mag, modModulus );\t\t// This avoids running out of resolution.\n    p = normalize( p ) * HtoUHS( mag );\n}\n\nvoid IsometryElliptic( inout vec2 p )\n{\n    p.xy = Rotate2( p.xy, iTime*time_factor*pi/modPhase );\n}\n\nvoid IsometryParabolic( inout vec2 p )\n{\n    float spacing = modModulus / 3.;\n    p.xy += 1.0*vec2( iTime*spacing, 0. );\n}\n\n// Signed distance function for a sphere kissing the origin with radius r.\nfloat sphereSdf( vec3 p, float r ) \n{\n\tp.z -= r;\n    return length( p ) - r;\n}\n\n// Signed distance function for a cone kissing the origin with radius r at z = 1.\n// c must be normalized\nfloat coneSdf( vec3 p, vec2 c )\n{\n\tfloat t = 1.0;\n    if( applyMobius )\n    {\n        t = ApplyMobius( p );\n    \tp = normalize( p );\n    }\n    \n    // https://iquilezles.org/articles/distfunctions\n    float q = length( p.xy );\n    return dot( c, vec2(q,-p.z) ) * t;\n}\n\n// Signed distance function for the z=0 plane\nfloat planeSdf( vec3 p )\n{\n\treturn length( p.z );\n}\n\nfloat planeSdf( vec3 p, float planeOffset )\n{\n    return length( p.z ) - planeOffset;\n}\n\n// Parabolic case\nvec2 sceneSdf1( vec3 samplePoint ) \n{  \n    float horosphereEuclideanRadius = 0.9;\n    if( !applyMobius )\n    {\n        // The horosphere as a plane will be at the height of\n        // its north pole inverted in the unit sphere.\n        float height = 1.0 / ( 2.0 * horosphereEuclideanRadius );\n     \treturn vec2( true, planeSdf( samplePoint, height ) );   \n    }\n    \n    float plane = planeSdf( samplePoint );\n    float sphere = sphereSdf( samplePoint, horosphereEuclideanRadius );\n\n    if( plane < sphere )\n        return vec2( false, plane );\n    return vec2( true, sphere );\n}\n\n// 2 fixed points cases\nvec2 sceneSdf2( vec3 samplePoint )\n{\n    float plane = planeSdf( samplePoint );\n    float cone = coneSdf( samplePoint, normalize( vec2( 1.5, 1. ) ) );\n\n    if( plane < cone )\n        return vec2( false, plane );\n    return vec2( true, cone );\n}\n\n// Intensity constants\nconst float intensity_divider = 4000.;\t\t\t// Divisor of the intensity. Tweak this value to make the particles more or less bright\nconst float intensity_factor_max = 7.2;        \t// Maximum initial intensity \nconst float center_intensity = 1.5;            \t// Initial intensity of the central highlights\nconst float dist_factor = 3.;              \t\t// Distance factor applied before calculating the intensity\nconst float ppow = 1.9;  \n\n// Color constants\nconst float min_hue = -0.13;                \t// Minimum hue shift (spectrum width = 1.)\nconst float max_hue = 0.13;                 \t// Maximum hue shift (spectrum width = 1.)\nconst float min_saturation = 0.5;           \t// Minimum saturation (0. to 1.)\nconst float max_saturation = 0.9;           \t// Maximum saturation (0. to 1.)\nconst float center_saturation = 0.18;        \n\n// Shape constants\nconst float strong_factor = 7.;              \t// Intensity factor of for brighter portion of the shape\nconst float weak_factor = .8;              \t\t// Intensity factor of the weaker portion of the shape\nconst vec2 hv_dfac = vec2(30., 1.);         \t// x-y transformation vector of the distance to get the horizontal and vertical star branches\nconst vec2 diag_dfac = vec2(35., 1.);         \t// x-y transformation vector of the distance to get the diagonal star branches\n\n\nvec3 getColor( float pint, vec2 p, bool lighten )\n{\n    float hue;\n    float saturation;\n\n    saturation = 0.75/pow(pint, 2.5) + center_saturation;\n    float time2 = parabolic ? \n        time_factor*hue_time_factor*iTime - length(p.y)/5. :\n    \ttime_factor*hue_time_factor*iTime - UHStoH( length(p) )/7.;\n    hue = .7 + time2;\n\n    vec3 result = hsv2rgb(vec3(hue, saturation, pint));\n    \n    if( lighten )\n    {\n        vec3 solid = hsv2rgb(vec3(hue, saturation, 0.8));\n        result = mix( result, solid, .04 );\n\t}\n    \n    return result;\n}\n\n// Intensity function in parabolic case.\nfloat intensity1( vec2 p )\n{\n    float dist = length( p );\n\n    // Horizontal and vertical branches\n    vec2 uvppos = p;\n    float distv = length(uvppos*hv_dfac);\n    float disth = length(uvppos*hv_dfac.yx);\n    \n    // Diagonal branches\n    vec2 uvpposd = 0.7071*vec2(dot(uvppos, vec2(1., 1.)), dot(uvppos, vec2(1., -1.)));\n    float distd1 = length(uvpposd*hv_dfac);\n    float distd2 = length(uvpposd*hv_dfac.yx);\n    // Middle point intensity star inensity\n    float pint1 = 1./(dist*dist_factor + 0.015) + \n        strong_factor/(disth*dist_factor + 0.01) + \n        weak_factor/(distv*dist_factor + 0.01) + \n        weak_factor/(distd1*dist_factor + 0.01) + \n        weak_factor/(distd2*dist_factor + 0.01);\n\n    if (intensity_factor_max*pint1>6.)\n    {\n        float ppow_anime = 1.0 + abs(sin(iTime)) * 3.0;\n        float pint = intensity_factor_max*(pow(pint1, ppow_anime)/(5.*intensity_divider))*center_intensity;\n        return pint;\n    }\n    \n    return 0.;\n}\n\n// Intensity function for 2 fixed points cases.\nfloat intensity2( vec2 p )\n{\n    float angle = atan( modModulus, pi/modPhase );\n    float dist = length( p );\n    //float dist = length( vec2( modModulus/2. - abs(p.x), pi/modPhase/2. - abs(p.y) ) );\t// May not be right because modModulus is in hyperbolic metric.\n\n    // Horizontal and vertical branches\n    vec2 uvppos = p;\n    float distv = length(uvppos*hv_dfac);\n    float disth = length(uvppos*hv_dfac.yx);\n\n    // Diagonal branches\n    vec2 uvpposd = Rotate2( uvppos, angle );\n    float distd1 = length(uvpposd*hv_dfac);\n    uvpposd = Rotate2( uvppos, -angle );\n    float distd2 = length(uvpposd*hv_dfac);\n\n    // Middle point intensity star inensity\n    float pint1 = 1./(dist*dist_factor + 0.015);\n\n    if( loxodromic )\n    {\n        pint1 += \n            weak_factor/(disth*dist_factor + 0.01) + \n            weak_factor/(distv*dist_factor + 0.01) + \n            strong_factor/(distd2*dist_factor + 0.01);     \n    }\n    else if( elliptic )\n    {\n        pint1 += \n            weak_factor/(disth*dist_factor + 0.01) + \n            strong_factor/(distv*dist_factor + 0.01) + \n            weak_factor/(distd1*dist_factor + 0.01) + \n            weak_factor/(distd2*dist_factor + 0.01);\n    }\n    else\n    {\n        pint1 += \n            strong_factor/(disth*dist_factor + 0.01) + \n            weak_factor/(distv*dist_factor + 0.01) + \n            weak_factor/(distd1*dist_factor + 0.01) + \n            weak_factor/(distd2*dist_factor + 0.01);\n    }\n\n    //if( intensity_factor_max*pint1>6. )\n    {\n        float ppow_anime = 1.0 + abs(cos(iTime)) * 3.0;\n        return intensity_factor_max*(pow(pint1, ppow_anime)/intensity_divider)*center_intensity;\n    }\n    \n    return 0.;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.00001;\nvec3 shortestDistanceToSurface( vec3 eye, vec3 marchingDirection, float start, float end, out vec2 p ) \n{\n    float depth = start;\n    float accum = 0.;\n    vec2 sceneInfo;\n    for( int i = 0; i < MAX_MARCHING_STEPS; i++ ) \n    {\n        vec3 current = eye + depth * marchingDirection;\n       \tsceneInfo = parabolic ? sceneSdf1( current ) : sceneSdf2( current );\n        float dist = sceneInfo.y;\n        if( dist < EPSILON ) \n        {\n            vec3 samplePoint = current;\n\n            float pint = 0.;\n\n            if( parabolic )\n            {\n\t\t\t\t// Invert depending on the fixed point setting.\n                float t = 1.0;\n                if( applyMobius )\n                {\n                \tfloat t = dot( samplePoint, samplePoint );\n            \t\tsamplePoint /= t;\n                }\n               \tp = samplePoint.xy;\n                \n                IsometryParabolic( samplePoint.xy );\n        \t\tfloat spacing = modModulus / 2.;\n                Mod2D( samplePoint.xy, vec2( spacing, spacing ) );\n \t\t\t\tpint = intensity1( samplePoint.xy );\n            }\n            else\n            {\n                // Set the fixed points.\n                ApplyMobius( samplePoint );\n                p = samplePoint.xy;\n\n                // Move the points and mod to get a repeating grid.\n                if( hyperbolic )\n                    IsometryHyperbolic( samplePoint.xy );\n                if( elliptic )\n                    IsometryElliptic( samplePoint.xy );\n                Mod2DPolar( samplePoint.xy, vec2( modModulus, pi/modPhase ) );\n                \n                // Calc the point intentsity.\n                pint = intensity2( samplePoint.xy );\n            }\n\n            return vec3( pint, depth, sceneInfo.x );\n        }\n\n        depth += dist;\n        if( depth >= end ) \n        {\n            return vec3( 0., end, sceneInfo.x );\n        }\n    }\n    \n    return vec3( 0., end, sceneInfo.x );\n}\n\nconst int CHAR_1 = 49;\nconst int CHAR_2 = 50;\nconst int CHAR_A = 65;\nconst int CHAR_F = 70;\n\n// https://www.shadertoy.com/view/lsXGzf\nbool keypress( int code ) \n{\n\treturn texelFetch( iChannel0, ivec2(code,2), 0 ).x != 0.0;\n}\n\nvec4 image( in vec2 fragCoord, in vec2 iResolution, in float iTime ) \n{   \n    float sr2 = sqrt( 1.0 + abs(cos(iTime * 2.0)) );\n    fixedPointMobius.A = vec2( -sr2, cos(iTime) );\n    fixedPointMobius.B = vec2( sr2, abs(cos(iTime)) );\n    fixedPointMobius.C = vec2( -sr2, abs(sin(iTime)) );\n    fixedPointMobius.D = vec2( -sr2, sin(iTime) );\n    \n    // Handle key toggles.\n\tapplyMobius = !keypress( CHAR_F );\n    if( keypress( CHAR_A ) )\n    {\n        modPhase = 2.5;\n        modModulus = .3;\n    }\n    elliptic = !keypress( CHAR_1 );\n    hyperbolic = !keypress( CHAR_2 );\n    parabolic = !(elliptic || hyperbolic);\n    loxodromic = elliptic && hyperbolic;\n    \n    // Setup the view.\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float t = iTime;\n    vec3 eye = vec3(-1.5,-2.,1.0)*2.5;\n    //eye.xy = Rotate2( eye.xy, iTime * 0.1 );\n    vec3 lookat = vec3( 0., 0., 0.6 );\n    mat3 viewToWorld = viewMatrix(eye, lookat, vec3(0.0, 0.0, 1.0));    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    // Raymarch.\n    vec2 p;\n    vec3 marchResults = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST, p);\n\n    // Color.\n    vec3 color = vec3( 0, 0, 0 );\n    if( marchResults.x > 0. )\n    {\n\t\tcolor = getColor( marchResults.x, p, bool(marchResults.z) );\n    }\n    \n    return vec4( 10.0*color, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = image( fragCoord, iResolution.xy, iTime );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//\n// View Helpers\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n// \n//\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n//\n// CSG Helpers\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n//\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n//\n// Color functions\n//\n\n#define pi 3.14159265359\n#define twopi 6.28318530718\n#define e_ 2.71828182846\n\n// From https://www.shadertoy.com/view/ldtGDn\nvec3 hsv2rgb (vec3 hsv) \n{ \n    // from HSV to RGB color vector\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z*(0.63*hsv.y*(cos(twopi*(hsv.x + vec3(0.0, 2.0/3.0, 1.0/3.0))) - 1.0) + 1.0);\n}\n\n//\n// Functions for working with hyperbolic geometry.\n//\n\n// Convert from a euclidean value in the UHS model to a hyperbolic dist \nfloat UHStoH( float e )\n{\n\t// Zero is at e = 1.\n    return log( e ); \n}\n\nfloat HtoUHS( float h )\n{\n \treturn pow( e_, h );    \n}\n\n//\n// Misc\n//\n\nvec2 Rotate2(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvoid Mod( inout float f, float size )\n{\n\tf = mod( f + size*0.5, size ) - size*0.5;\n}\n\n// Repeat a square grid in two dimensions\nvoid Mod2D( inout vec2 p, vec2 size ) \n{\n\tp = mod( p + size*0.5, size ) - size*0.5;\n}\n\n// Used to make a spherical grid in two dimensions\n// One pole is at the origin and the other at infinity.\nvoid Mod2DPolar( inout vec2 p, vec2 size )\n{\n\tfloat phase = atan( p.y, p.x );\n    float modulus = UHStoH( length( p ) );\n    Mod( phase, size.y );\n    Mod( modulus, size.x );\n    //modulus = HtoUHS( modulus );\n    //p = vec2( modulus*sin(phase), modulus*cos(phase) );\n    p = vec2( modulus, phase );\n}\n\n//\n// Complex number operations\n//\n\nvec2 C_Conj( vec2 c )\n{\n\treturn vec2( c.x, -c.y );\n}\n\nvec2 C_Mult( vec2 a, vec2 b )\n{\n\treturn vec2( a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y );\n}\n\nfloat C_MagSquared( vec2 c )\n{\n\treturn c.x * c.x + c.y * c.y;\n}\n\nvec2 C_Div( vec2 a, vec2 b )\n{\n\treturn C_Mult( a, C_Conj( b ) ) / C_MagSquared( b );\n}\n\nvec2 C_Inv( vec2 c )\n{\n\treturn C_Conj( c ) / C_MagSquared( c );\n}\n\n// https://math.stackexchange.com/a/44410/300001\nvec2 C_Sqrt( vec2 c )\n{\n    float r2 = C_MagSquared( c );\n    float sqrtR = sqrt( sqrt( r2 ) );\n    float theta = atan( c.y, c.x );\n\treturn vec2( cos( theta / 2. ), sin( theta / 2. ) ) * sqrtR;\n}\n\n//\n// Quaternion operations\n//\n\nfloat Q_MagSquared( vec4 q )\n{\n\treturn dot( q, q );\n}\n\nvec4 Q_Mult( vec4 a, vec4 b )\n{\n    return vec4(\n        a.x*b.x - a.y*b.y - a.z*b.z - a.w*b.w,\n        a.x*b.y + a.y*b.x + a.z*b.w - a.w*b.z,\n        a.x*b.z - a.y*b.w + a.z*b.x + a.w*b.y,\n        a.x*b.w + a.y*b.z - a.z*b.y + a.w*b.x );\n}\n\nvec4 Q_Div( vec4 a, vec4 b )\n{\n    float magSquared = Q_MagSquared( b );\n    vec4 bInv = vec4( b.x / magSquared, -b.y / magSquared, -b.z / magSquared, -b.w / magSquared );\n    return Q_Mult( a, bInv );\n}\n\t\t\t\n\n//\n// Mobius transformations\n//\n\nstruct Mobius\n{\n\tvec2 A;\n\tvec2 B;\n\tvec2 C;\n\tvec2 D;\n};\n\nMobius M_Scale( in Mobius m, vec2 s )\n{\n\tMobius result;\n\tresult.A = C_Mult( m.A, s );\n\tresult.B = C_Mult( m.B, s );\n\tresult.C = C_Mult( m.C, s );\n\tresult.D = C_Mult( m.D, s );\n\treturn result;\n}\n\nMobius M_Normalize( in Mobius m )\n{\n\t// See Visual Complex Analysis, p150\n\tvec2 k = C_Inv( C_Sqrt( m.A * m.D - m.B * m.C ) );\n\treturn M_Scale( m, k );\n}\n\nMobius M_Mult( in Mobius a, in Mobius b )\n{\n\tMobius result;\n\tresult.A = C_Mult( a.A, b.A ) + C_Mult( a.B, b.C );\n\tresult.B = C_Mult( a.A, b.B ) + C_Mult( a.B, b.D );\n\tresult.C = C_Mult( a.C, b.A ) + C_Mult( a.D, b.C );\n\tresult.D = C_Mult( a.C, b.B ) + C_Mult( a.D, b.D );\n\treturn M_Normalize( result );\n}\n\nvec2 M_Apply( in Mobius m, in vec2 z )\n{\n\treturn C_Div( C_Mult( m.A, z ) + m.B, C_Mult( m.C, z ) + m.D );\n}\n\n// Apply to a quaternion.\nvec4 M_Apply( in Mobius m, in vec4 q )\n{\n    vec4 a = vec4( m.A, 0., 0. );\n    vec4 b = vec4( m.B, 0., 0. );\n    vec4 c = vec4( m.C, 0., 0. );\n    vec4 d = vec4( m.D, 0., 0. );\n\treturn Q_Div( Q_Mult( a, q ) + b, Q_Mult( c, q ) + d ); \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}