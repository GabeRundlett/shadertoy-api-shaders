{
    "Shader": {
        "info": {
            "date": "1701367214",
            "description": "gold ig\n\ni spent way to long making the goldIOR and goldExtinction functions in desmos...\n\nfeel free to use the N/K approximate functions but pls use credit",
            "flags": 32,
            "hasliked": 0,
            "id": "Dt3fWN",
            "likes": 2,
            "name": "Accurate Gold BRDF",
            "published": 3,
            "tags": [
                "tonemapping",
                "fresnel",
                "wavelength",
                "gold",
                "conductor"
            ],
            "usePreview": 0,
            "username": "ThePlaneGuy45",
            "viewed": 203
        },
        "renderpass": [
            {
                "code": "vec3 tonemap(vec3 color) {\n\n    return 1.0-1.0/(color+1.0);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    col.rgb *= EXPOSURE;\n    col.rgb /= col.w;\n    \n    \n    fragColor = vec4(tonemap(col.rgb), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define EXPOSURE 10.0\n\n\n/*\n\nAccurate Gold BRDF © 2023 by ThePlaneGuy45 is licensed under CC BY-SA 4.0 \n\nThe reason I claim this is \"accurate\" is that it uses a correct Fresnel equation\n(not a schlick approximation) and it also is wavelength-based, not RGB-based.\nHowever, this does mean that the standard method of color-specific IOR/extinction\nvalues is not going to work. I spent an hour or two making two Taylor's series to\napproximate the correct IOR/extinction values for a given wavelength. The data I \nused to create these functions can be found here: \nhttps://refractiveindex.info/?shelf=main&book=Au&page=Johnson\nThe data on that website is subsequently from a 1972 research paper:\nP. B. Johnson and R. W. Christy. Optical constants of the noble metals\nand can be found here:\nhttps://journals.aps.org/prb/abstract/10.1103/PhysRevB.6.4370\n\nOTHER CREDITS:\n\nsphere intersection function:\nhttps://iquilezles.org/articles/intersectors/\n\ndielectric-conductor fresnel function:\nhttps://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/\n\n*/\n\nfloat goldIOR(float w) {\n    float w2 = w *w;\n    float w3 = w2*w;\n    float w4 = w3*w;\n    return \n        w<0.188?1.28:\n        w<0.5?-77.1267*w4+76.864*w3-39.4179*w2+12.076*w:\n        w<0.7?134.363*w4-426.744*w3+506.806*w2-266.53*w+52.4802:\n        w<1.937?0.46148*w2-0.62019*w+0.38851:\n        0.92;\n}\nfloat goldExtinction(float w) {\n    float w2 = w *w;\n    float w3 = w2*w;\n    float w4 = w3*w;\n    return \n        w<0.188?1.188:\n        w<0.5?283.4*w4-326.327*w3+109.469*w2-4.83043*w:\n        w<0.7?18.3333*w4-36.2*w3+14.7817*w2+16.3835*w-6.6343:\n        w<1.937?-0.25913*w2+8.52819*w-1.82265:\n        13.78;\n}\nvec2 goldNK(float wavelength) {\n    return vec2(goldIOR(wavelength), goldExtinction(wavelength));\n}\n\n/* Special wavelengths:\n * 0.645µm: red   (#FF0000)\n * 0.510µm: green (#00FF00)\n * 0.440µm: blue  (#0000FF)\n */\n \nfloat Fresnel(float etaN, float etaK, float ct) {\n\n    float ct2 = ct*ct;\n    float st2 = 1.0 - ct2;\n    float etaN2 = etaN*etaN;\n    float etaK2 = etaK*etaK;\n    \n    float t0 = etaN2 - etaK2 - st2;\n    float pyt = sqrt(t0*t0+4.0*etaN2*etaK2);\n    float t1 = pyt+ct2;\n    float a = sqrt(0.5*(pyt+t0));\n    float t2 = 2.0 * a * ct;\n    float rs = (t1-t2)/(t1+t2);\n    \n    float t3 = ct2*pyt + st2*st2;\n    float t4 = t2*st2;\n    float rp = rs*(t3-t4)/(t3+t4);\n    \n    return 0.5*(rp+rs);\n\n}\n\nfloat sharpstep(float e0, float e1, float x) {\n    return clamp((x-e0)/(e1-e0),0.0,1.0);\n}\nvec3 rgbFromWavelength(float w) {\n\n    float r0 = w-4.0;\n    r0*=-3.125*r0;\n    r0+=0.5;\n    float r = max(r0, min(\n        sharpstep(5.1, 5.775, w),\n        1.0-sharpstep(7.0, 7.9, w)\n    ));\n    float g = min(\n        sharpstep(4.4, 4.75, w),\n        1.0-sharpstep(5.775, 6.45, w)\n    );\n    float b = min(\n        sharpstep(3.6, 4.0, w),\n        1.0-sharpstep(4.75, 5.1, w)\n    );\n    return vec3(r, g, b);\n}\n \nstruct BRDF {\n\n    vec3 l;\n    vec3 c;\n    \n};\n\nBRDF goldBRDF(vec3 rd, vec3 n, float wavelength) {\n\n    vec3 v = -rd;\n    \n    float cosThetaVN = dot(v, n);\n    \n    vec2 nk = goldNK(wavelength*0.1);\n    \n    float fres = Fresnel(nk.x, nk.y, cosThetaVN);\n    \n    return BRDF(\n    \n        reflect(rd, n),\n        fres * rgbFromWavelength(wavelength)\n    \n    );\n\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// iq\nstruct sph {\n    vec2 i;\n    vec3 n;\n    bool hit;\n};\nsph sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, in float ra ) {\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) {\n        return sph(\n            vec2(0),\n            vec3(0),\n            false\n        );\n    }\n    h = sqrt( h );\n    return sph(\n        vec2(-b-h, -b+h),\n        normalize(ro+(-b-h)*rd-ce),\n        true\n    );\n}\n\nvec3 random(inout uvec3 v) {\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v ^= v >> 16u;\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    return vec3(v)*(1.0/float(0xffffffffU));\n}\nvec3 GGX(in vec2 a, in vec3 n, inout uvec3 state) {\n\n    vec2 rn = random(state).xy;\n\n    vec3 vh = normalize(vec3(a.x * n.x, a.y * n.y, n.z));\n    float ls = vh.x*vh.x+vh.y*vh.y;\n    \n    vec3 t0 = ls>0.0 ? vec3(-vh.y,vh.x,0) / sqrt(ls) : vec3(1,0,0);\n    vec3 t1 = cross(vh, t0);\n    \n    float r = sqrt(rn.x);\n    float phi = 6.283185307179586 * rn.y;\n    vec2 tr = sin(phi+vec2(1.570796326794897,0));\n    vec2 t = r*tr;\n    float s = 0.5*(1.0+vh.z);\n    t.y = (1.0-s)*sqrt(1.0-t.x*t.x)+s*t.y;\n    \n    vec3 nh = t.x*t0 + t.y*t1 + sqrt(max(0.0, 1.0 - t.x*t.x - t.y*t.y)) * vh;\n    return normalize(vec3(a.x*nh.x, a.y*nh.y, max(0.0, nh.z)));\n\n}\nvec3 worldSpace(vec3 map, vec3 t, vec3 b, vec3 n) {\n\n    mat3x3 tbn = mat3x3(t.x, b.x, n.x, t.y, b.y, n.y, t.z, b.z, n.z);\n    return normalize(map * tbn);\n\n}\n\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel3, ivec2(fragCoord), 0);\n    uvec3 state = uvec3(fragCoord, iFrame);\n    fragCoord -= iResolution.xy*0.5;\n    fragCoord /= iResolution.y;\n    vec2 mouse = iMouse.xy - iResolution.xy*0.5;\n    mouse /= iResolution.y;\n    \n    vec3 ro = vec3(0, 0, -3);\n    vec3 rd = normalize(vec3(fragCoord, 1.0));\n    \n    mat2x2 rot;\n    rot = rot2(-8.0 * mouse.y);\n    ro.yz *= rot;\n    rd.yz *= rot;\n    rot = rot2(-8.0 * mouse.x);\n    ro.xz *= rot;\n    rd.xz *= rot;\n    \n    sph rayCast = sphIntersect(ro, rd, \n        vec3(0, 0, 0),\n        1.0\n    );\n    \n    vec3 color = vec3(0.0);\n    \n    if(rayCast.hit) {\n    \n        vec3 t = normalize(vec3(rayCast.n.z, 0.0, -rayCast.n.x));\n        vec3 b = normalize(cross(rayCast.n, t));\n        \n        vec3 microfacet = GGX(vec2(0.01, 0.01), vec3(0,0,1), state);\n    \n        const float ot = 1.0/3.0;\n    \n        vec3 rand = random(state);\n        \n        vec3 wrgb = vec3(\n        \n            4.000+rand.x*0.750,\n            4.750+rand.y*1.025,\n            5.775+rand.z*1.225\n        \n        );\n        \n        rand = random(state);\n    \n        float wavelength = rand.x<ot?wrgb.x:rand.y<2.0*ot?wrgb.y:wrgb.z;\n    \n        BRDF shader = goldBRDF(rd, worldSpace(microfacet, t,b,rayCast.n), wavelength);\n        \n        color = texture(iChannel0, shader.l).rgb * shader.c;\n    \n    } else {\n    \n        color = texture(iChannel0, rd).rgb;\n    \n    }\n    \n    fragColor += vec4(color, 1.0);\n    \n    if(iFrame==0||iMouse.z>0.0){fragColor = vec4(color, 1.0);}\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float sunBrightness = 3.0;\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n\n    #if 0\n\n    float d = dot(rayDir, normalize(vec3(1,1,1)));\n    d = clamp(d, 0.0, 1.0);\n    \n    float sd = pow(d, 100.0);\n    \n    vec3 skyColor = vec3(0.2, 0.3, 0.3);\n    vec3 sunColor = vec3(10.0, 9.5, 9.0);\n    \n    fragColor = vec4(mix(skyColor, sunBrightness*sunColor, sd), 1.0);\n    \n    #elif 0\n    \n    fragColor = texture(iChannel0, rayDir);\n    \n    #else\n    \n    const vec3  sunLightPosition = vec3(1, 1, 1);\n    const float sunFocus = 50.0;\n    const float sunIntensity = 10.0;\n    \n    const vec3 skyColorHorizon = vec3(1.0);\n    const vec3 skyColorZenith  = vec3(0.5, 0.8, 1.0);\n    \n    const vec3 groundColor = vec3(0.5, 0.5, 0.5);\n    \n    \n    float gradT = pow(smoothstep(0.0, 0.4, rayDir.y), 0.35);\n    vec3  grad  = mix(vec3(1.0), vec3(0.5, 0.8, 1.0), gradT);\n    float sun   = pow(max(dot(rayDir, normalize(sunLightPosition)), 0.0), sunFocus) * sunIntensity;\n    \n    float groundT = smoothstep(-0.01, 0.0, rayDir.y);\n    float sunMask = float(groundT >= 1.0);\n    vec3 sky = mix(groundColor, grad, groundT) + sun*sunMask;\n    \n    fragColor = vec4(sky, 1.0);\n    \n    #endif\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}