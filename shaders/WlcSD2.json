{
    "Shader": {
        "info": {
            "date": "1581683986",
            "description": "No words needed (mouse overrides autopaging)",
            "flags": 32,
            "hasliked": 0,
            "id": "WlcSD2",
            "likes": 8,
            "name": "Live Assembly Instructions",
            "published": 3,
            "tags": [
                "toy",
                "train",
                "book"
            ],
            "usePreview": 1,
            "username": "dr2",
            "viewed": 507
        },
        "renderpass": [
            {
                "code": "// \"Live Assembly Instructions\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0  // optional antialiasing\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat SmoothMin (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\n#define N_CAR 6\n\nvec3 qHit, ltDir, ltDirEx, pgSize;\nvec2 rlSize, cId;\nfloat dstFar, tCur, szFac, angX, rgHSize, trkWid, dstFarEx, tpBook, phsTurn, idPage;\nint idObj, showTrn, showDec, trkSeg;\nbool sigStop, isCol, trkWide;\nconst float pi = 3.14159;\nconst int nPage = 8;\n\nconst int idRail = 1, idRbase = 2, idXingV = 3, idXingB = 4, idPlatB = 5, idPlatU = 6,\n   idSig = 7, idSigV = 8, idTun = 9, idTrunk = 10, idTree = 11, idCar = 21,\n   idCon = 22, idWhl = 23, idFLamp = 24, idBLamp = 25;\nconst int dirNS = 0, dirEW = 1, dirSW = 2, dirNW = 3, dirSE = 4, dirNE = 5, dirX = 6;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid SetTrkParms ()\n{\n  vec2 s;\n  int isq;\n  s =  mod (cId + rgHSize, 2. * rgHSize);\n  isq = int (2. * rgHSize * s.y + s.x);\n  trkSeg = -1;\n  if (isq == 1 || isq == 2 || isq == 3 || isq == 4 || isq == 13 ||\n     isq == 16 || isq == 19 || isq == 22 || isq == 31 || isq == 34) trkSeg = dirEW;\n  else if (isq == 6 || isq == 11 || isq == 24 || isq == 26 || isq == 27 ||\n     isq == 29) trkSeg = dirNS;\n  else if (isq == 12 || isq == 30 || isq == 33) trkSeg = dirSE;\n  else if (isq == 17 || isq == 32 || isq == 35) trkSeg = dirSW;\n  else if (isq == 0 || isq == 15 || isq == 18) trkSeg = dirNE;\n  else if (isq == 5 || isq == 14 || isq == 23) trkSeg = dirNW;\n  else if (isq == 20 || isq == 21) trkSeg = dirX;\n}\n\nvec2 SimpTrkSeg (vec3 q, int indx)\n{\n  float dB, dR;\n  if (indx == dirEW) q.xz = q.zx;\n  else if (indx == dirNW) q.z *= -1.;\n  else if (indx == dirSE) q.x *= -1.;\n  else if (indx == dirNE) q.xz *= -1.;\n  if (indx <= dirEW) {\n    q.x = abs (q.x);\n  } else {\n    q.xz += 0.5;\n    q.x = abs (length (q.xz) - 0.5);\n  }\n  dB = PrBox2Df (q.xy, vec2 (2. * trkWid, 0.2 * rlSize.y));\n  q.xy -= vec2 (trkWid, 0.7 * rlSize.y);\n  dR = PrRoundBox2Df (q.xy, rlSize, 0.5 * rlSize.x);\n  return vec2 (dB, dR);\n}\n\nvec2 CrossTrkSeg (vec3 q)\n{\n  vec3 qq;\n  float dB, dR;\n  qq = q;\n  q = qq;  q.x = abs (q.x);\n  dB = PrBoxDf (q, vec3 (2. * trkWid, 0.2 * rlSize.y, 0.5));\n  q = qq;  q.xz = q.zx;   q.x = abs (q.x);\n  dB = min (dB, PrBoxDf (q, vec3 (2. * trkWid, 0.2 * rlSize.y, 0.5)));\n  qq.y -= 0.7 * rlSize.y;\n  q = qq;  q.x = abs (q.x) - trkWid;  q.z += 0.5;\n  dR = PrRoundBox2Df (q.xy, rlSize, 0.5 * rlSize.x);\n  q = qq;  q.xz = q.zx;  q.z += 0.5;  q.x = abs (q.x) - trkWid;\n  dR = min (dR, PrRoundBox2Df (q.xy, rlSize, 0.5 * rlSize.x));\n  q = qq;  q.xz = abs (q.xz) - trkWid + 2.1 * rlSize.x;\n  dR = max (dR, - min (PrBox2Df (q.xz, vec2 (trkWid, 0.7 * rlSize.x)),\n     PrBox2Df (q.zx, vec2 (trkWid, 0.7 * rlSize.x))));\n  return vec2 (dB, dR);\n}\n\nfloat TrackDf (vec3 p)\n{\n  vec3 q;\n  vec2 d2;\n  float dMin, d, dUsq;\n  dMin = dstFar;\n  q = p;  q.xz -= cId + 0.5;\n  if (trkSeg >= 0 && trkSeg <= dirX) {\n    q.y -= 0.5 * rlSize.y;\n    d2 = (trkSeg < dirX) ? SimpTrkSeg (q, trkSeg) : CrossTrkSeg (q);\n    dUsq = PrBox2Df (p.xz, vec2 (rgHSize));\n    d = max (d2.y, dUsq);\n    DMIN (idRail);\n    d = max (d2.x, dUsq);\n    DMIN (idRbase);\n  }\n  return dMin;\n}\n\nfloat TrackRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  vec2 cIdP, s;\n  float dHit, d, eps;\n  eps = 0.0001;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  rdi.xz = 1. / rd.xz;\n  cIdP = vec2 (-999.);\n  dHit = max (0., PrBox2Df (ro.xz, vec2 (rgHSize)));\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    cId = floor (p.xz);\n    if (cId != cIdP) {\n      cIdP = cId;\n      SetTrkParms ();\n    }\n    d = TrackDf (p);\n    s = (cId + step (0., rd.xz) - p.xz) * rdi.xz;\n    dHit += min (d, 0.001 + max (0., min (s.x, s.y)));\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nfloat CarDf (vec3 p, float dMin, float dir)\n{\n  vec3 q;\n  float d, s, ds;\n  q = p;\n  s = 0.25;\n  if (q.z * dir > 0.5) {\n    ds = -0.25 * (q.z * dir - 0.5);\n    s += ds;\n    q.y -= ds;\n  }\n  d = PrRoundBoxDf (q, vec3 (0.3, s, 1.55), 0.4);\n  DMINQ (idCar);\n  q = p;  q.xz = abs (q.xz);  q.z = abs (q.z - 0.9);\n  q -= vec3 (0.39, -0.6, 0.2);\n  d = PrCylDf (q.yzx, 0.15, 0.07);\n  DMINQ (idWhl);\n  q = p;  q.z = (dir == 0.) ? abs (q.z) - 1.8 : q.z + 1.8 * dir;\n  d = PrCylDf (q.xzy, 0.3, 0.5);\n  DMIN (idCon);\n  if (dir > 0.) {\n    q = p;  q.yz -= vec2 (-0.25, 1.9);\n    d = PrCylDf (q, 0.1, 0.1);\n    DMINQ (idFLamp);\n  } else if (dir < 0.) {\n    q = p;  q.x = abs (q.x) - 0.2;  q.yz -= vec2 (-0.25, -1.9);\n    d = PrCylDf (q, 0.08, 0.1);\n    DMINQ (idBLamp);\n  }\n  return 0.9 * dMin;\n}\n\nfloat SceneDf (vec3 p)\n{\n  vec4 pCar;\n  vec3 q;\n  float dMin, d;\n  int pxcMin;\n  dMin = dstFar;\n  if (showDec >= 1) {\n    q = p;  q.z = abs (q.z - 0.5);\n    d = PrBoxDf (q, vec3 (0.3, 0.7 * rlSize.y, 0.3));\n    DMIN (idRbase);\n    q = p;  q.xy -= vec2 (0.27 * sign (q.z - 0.5), 0.05);\n    q.z = abs (q.z - 0.5) - 0.16;\n    d = PrCapsDf (q.xzy, 0.017, 0.05);\n    DMIN (idXingV);\n    q = p;  q -= vec3 (0.25, 0.03, 0.66);\n    q.xy = Rot2D (q.xy, angX);  q.xy -= vec2 (-0.22, 0.05);\n    d = PrBoxDf (q, vec3 (0.2, 0.008, 0.005)); \n    DMINQ (idXingB);\n    q = p;  q -= vec3 (-0.25, 0.03, 0.34);\n    q.xy = Rot2D (q.xy, - angX);  q.xy -= vec2 (0.22, 0.05);\n    q.x *= -1.;\n    d = PrBoxDf (q, vec3 (0.2, 0.008, 0.005)); \n    DMINQ (idXingB);\n    q = p;  q.yz -= vec2 (1.5 * rlSize.y, -2.32);\n    d = PrBoxDf (q, vec3 (0.9, 1.5 * rlSize.y, 0.12));\n    DMIN (idPlatB);\n    q.x = abs (q.x) - 0.4;  q.yz -= vec2 (0.07, 0.08);\n    d = max (PrBoxDf (q, vec3 (0.24, 0.09, 0.035)),\n       - PrBoxDf (q, vec3 (0.22, 0.08, 0.04)));\n    DMIN (idPlatU);\n  }\n  if (showDec >= 2) {\n    q = p;  q.yz -= vec2 (1.5 * rlSize.y, -2.32);\n    q -= vec3 (0.8, 0.1, -0.05);\n    d = PrCylDf (q.xzy, 0.01, 0.1);\n    DMIN (idSigV);\n    q.y -= 0.1;\n    d = PrSphDf (q, 0.02);\n    DMIN (idSig);\n    q = p;  q.x = abs (q.x) - 2.48;  q.z -= 1.5;\n    d = max (PrCylAnDf (q, 0.16, 0.005, 0.4), - q.y - 0.04);\n    DMINQ (idTun);\n    q = p;  q.xz = abs (q.xz) - 1.5;  q.y -= 0.14 - 0.04;\n    d = PrCylDf (q.xzy, 0.03 * (1. - q.y), 0.14);\n    DMINQ (idTrunk);\n    q.y -= 0.17;\n    d = PrCapsDf (q.xzy, 0.1 * (1. - 2. * q.y), 0.03);\n    DMINQ (idTree);\n  }\n  if (showTrn > 0) {\n    dMin /= szFac;\n    pxcMin = 5;\n    for (int k = VAR_ZERO; k < N_CAR; k ++) {\n      pCar = Loadv4 (pxcMin + (showTrn - 1) * N_CAR + k);\n      pCar.y = 2.7 * rlSize.y + 0.06;\n      q = p;  q -= pCar.xyz;\n      q.xz = Rot2D (q.xz, pCar.w);\n      dMin = CarDf (q / szFac, dMin, (k > 0) ? ((k < N_CAR - 1) ? 0. : -1.) : 1.);\n    }\n    dMin *= szFac;\n  }\n  return dMin;\n}\n\nfloat SceneRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d, eps;\n  eps = 0.0001;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = SceneDf (ro + dHit * rd);\n    dHit += d;\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 TrackNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  v = vec4 (- TrackDf (p + e.xxx), TrackDf (p + e.xyy), TrackDf (p + e.yxy), TrackDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 SceneNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  v = vec4 (- SceneDf (p + e.xxx), SceneDf (p + e.xyy), SceneDf (p + e.yxy), SceneDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 20; j ++) {\n    h = SceneDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec4 CarCol ()\n{\n  vec4 col4;\n  col4 = vec4 (0.1, 0.3, 1., 0.3);\n  if (idObj == idCar) {\n    if (abs (qHit.y - 0.22) < 0.26) col4 = vec4 (0.2, 0.2, 0.2, 0.3);\n    else if (abs (abs (qHit.y - 0.22) - 0.28) < 0.02) col4 = vec4 (1., 0.2, 0.2, 0.3);\n  } else if (idObj == idWhl) {\n     col4 = (length (qHit.yz) < 0.07) ? vec4 (0.2, 0.2, 0.2, 0.1) :\n        vec4 (0.6, 0.6, 0.6, 0.2);\n  } else if (idObj == idFLamp) {\n    if (qHit.z > 0.1) col4 = vec4 (1., 1., 0., -1.);\n  } else if (idObj == idBLamp) {\n    if (qHit.z < -0.1) col4 = vec4 (1., 0., 0., -1.);\n  }\n  return col4;\n}\n\nfloat BrickSurfShd (vec2 p)\n{\n  vec2 q, iq;\n  q = p;\n  iq = floor (q);\n  if (2. * floor (iq.y / 2.) != iq.y) {\n    q.x += 0.5;  iq = floor (q);\n  }\n  q = smoothstep (0.015, 0.025, abs (fract (q + 0.5) - 0.5));\n  return 0.5 + 0.5 * q.x * q.y;\n}\n\nfloat BrickShd (vec3 p, vec3 n)\n{\n  return dot (vec3 (BrickSurfShd (p.zy), BrickSurfShd (p.xz), BrickSurfShd (p.xy)),\n     abs (n));\n}\n\nvec4 SceneCol (vec3 ro, vec3 vn)\n{\n  vec4 col4;\n  if (isCol) {\n    if (idObj == idRail) col4 = vec4 (0.7, 0.7, 0.7, 0.2);\n    else if (idObj == idRbase) col4 = vec4 (mix (vec3 (0.25, 0.25, 0.27),\n       vec3 (0.32, 0.32, 0.34), smoothstep (0.6, 0.9, Noisefv2 (512. * ro.xz))), 0.1);\n    else if (idObj == idXingV) col4 = vec4 (0.7, 0.8, 0.7, 0.3);\n    else if (idObj == idXingB) col4 = mix (vec4 (1., 0., 0., 1.),\n       vec4 (1.), step (0.5, mod (10. * qHit.x, 1.)));\n    else if (idObj == idPlatB) col4 = mix (vec4 (0.2, 0.2, 0.22, 0.1),\n       vec4 (0.25, 0.25, 0.2, 0.1), Noisefv2 (1024. * ro.xz));\n    else if (idObj == idPlatU) col4 = vec4 (0.5, 0.3, 0.1, 0.2) *\n       BrickShd (50. * ro, vn);\n    else if (idObj == idSig) col4 = sigStop ? vec4 (1., 0., 0., -1.) : vec4 (0., 1., 0., -1.);\n    else if (idObj == idSigV) col4 = vec4 (0.7, 0.7, 0.8, 0.1);\n    else if (idObj == idTun) col4 = vec4 (0.7, 0.3, 0.1, 0.05) *\n       (1. - 0.4 * Noisefv2 (vec2 (512. * (1. + atan (qHit.y, qHit.x) / pi), 128. * qHit.z)));\n    else if (idObj == idTree) col4 = vec4 (0., 0.4, 0., 0.) *\n       (1. - 0.5 * Noisefv2 (vec2 (64. * (1. + atan (qHit.x, qHit.z) / pi), 128. * qHit.y)));\n    else if (idObj == idTrunk) col4 = vec4 (0.3, 0.1, 0., 0.02) *\n       (1. - 0.3 * Noisefv2 (vec2 (32. * (1. + atan (qHit.x, qHit.z) / pi), 64. * qHit.y)));\n  } else {\n    if (idObj == idRail) col4.rgb = vec3 (0.6);\n    else if (idObj == idRbase) col4.rgb = vec3 (0.4);\n    else if (idObj == idXingV) col4.rgb = vec3 (0.7);\n    else if (idObj == idXingB) col4.rgb = vec3 (0.9);\n    else if (idObj == idPlatB) col4.rgb = vec3 (0.3);\n    else if (idObj == idPlatU) col4.rgb = vec3 (0.4);\n    else if (idObj == idSig) col4.rgb = vec3 (1.);\n    else if (idObj == idSigV) col4.rgb = vec3 (0.7);\n    else if (idObj == idTun) col4.rgb = vec3 (0.5);\n    else if (idObj == idTree) col4.rgb = vec3 (0.3);\n    else if (idObj == idTrunk) col4.rgb = vec3 (0.2);\n    col4.a = 0.;\n  }\n  return col4;\n}\n\nvec3 GrndCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  vec2 w, e;\n  float f;\n  if (isCol) {\n    e = vec2 (0.01, 0.);\n    w = 5. * ro.xz;\n    f = Fbm2 (w);\n    vn = normalize (vec3 (f - Fbm2 (w + e), 0.04, f - Fbm2 (w + e.yx)));\n    col = 0.4 * mix (vec3 (0.4, 0.3, 0.1), vec3 (0.4, 0.5, 0.2), f) *\n       (1. - 0.1 * Noisefv2 (31. * w));\n    col *= 0.1 + 0.9 * max (dot (vn, ltDir), 0.);\n  } else {\n    col = vec3 (0.5);\n  }\n  return col;\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  vec3 col;\n  float f;\n  col = vec3 (0.05, 0.1, 0.25) + 0.2 * pow (1. - rd.y, 8.) +\n     0.4 * min (pow (max (dot (rd, ltDir), 0.), 256.), 0.3);\n  f = Fbm2 ((4. / rd.y) * rd.xz);\n  col = mix (col, vec3 (1.), clamp (0.1 + 0.8 * f * rd.y, 0., 1.));\n  return col;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  if (rd.y > 0.) col = SkyCol (rd);\n  else col = GrndCol (ro - (ro.y / rd.y) * rd, rd);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 rdd, qHitT, col, vn;\n  float dstObj, d, reflFac, sh;\n  int idObjT;\n  bool isTrk;\n  dstObj = dstFar;\n  d = TrackRay (ro, rd);\n  if (d < dstObj) {\n    dstObj = d;\n    isTrk = true;\n  }\n  idObjT = idObj;\n  qHitT = qHit;\n  d = SceneRay (ro, rd);\n  if (d < dstObj) {\n    dstObj = d;\n    isTrk = false;\n  } else {\n    idObj = idObjT;\n    qHit = qHitT;\n  }\n  reflFac = 0.;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    idObjT = idObj;\n    qHitT = qHit;\n    vn = isTrk ? TrackNf (ro) : SceneNf (ro);\n    idObj = idObjT;\n    qHit = qHitT;\n    if (idObj == idCar) {\n      rdd = reflect (rd, vn);\n      reflFac = (abs (qHit.y - 0.22) < 0.26) ? 0.6 : 0.2;\n    }\n    if (idObj < idCar) {\n      if (idObj == idRbase || idObj == idTun || idObj == idTree) vn = VaryNf (128. * ro, vn, 2.);\n      col4 = SceneCol (ro, vn);\n    } else col4 = CarCol ();\n    col = col4.rgb;\n    if (col4.a >= 0.) {\n      sh = (showTrn == 1) ? ObjSShadow (ro, ltDir) : 1.;\n      col = col * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.) +\n         col4.a * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.));\n    }\n  } else if (rd.y < 0.) {\n    dstObj = - ro.y / rd.y;\n    ro += dstObj * rd;\n    vn = vec3 (0., 1., 0.);\n    if (showTrn == 1) {\n      sh = (dstObj < dstFar) ? ObjSShadow (ro, ltDir) : 1.;\n      col = GrndCol (ro, rd);\n      col = col * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.));\n      col = mix (col, SkyCol (abs (rd)), smoothstep (0.7, 1., dstObj / dstFar));\n    } else {\n      col = (max (abs (ro.x) - 2.8, abs (ro.z) - 3.2) < 0.) ?\n         vec3 (0., 0.25, 0.) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) : vec3 (0.15);\n    }\n  } else {\n    col = (showTrn == 1) ? BgCol (ro, rd) : vec3 (0.15);\n  }\n  if (showTrn == 1 && reflFac > 0.) col = mix (col, 0.7 * BgCol (ro, rdd), reflFac);\n  if (! isCol) col = Maxv3 (smoothstep (0., 1., col)) * vec3 (1., 1., 0.9);\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvoid InitSys ()\n{\n  vec4 stDat;\n  float trMov, trCyc, t;\n  int trStop;\n  rgHSize = 3.;\n  szFac = 0.08;\n  trkWid = 0.03;\n  rlSize = trkWide ? vec2 (0.006, 0.005) : vec2 (0.003, 0.005);\n  stDat = Loadv4 (2);\n  trMov = stDat.x;\n  trCyc = stDat.w;\n  stDat = Loadv4 (4);\n  trStop = int (stDat.x);\n  t = mod (trMov / trCyc, 1.);\n  angX = 0.3 * pi * (1. - SmoothBump (0.55, 0.69, 0.02, t));\n  sigStop = (trStop != 2);\n}\n\nvoid ExMain  (out vec3 fCol, in vec2 fCoord)\n{\n  mat3 vuMat;\n  vec4 pVu;\n  vec3 ro, rd, col, u, vd;\n  float zmFac, f;\n  int vuMode;\n  dstFar = 20.;\n  isCol = true;\n  if (idPage == 1.) {\n    vuMode = 0;\n    showDec = 0;\n    showTrn = 0;\n    isCol = false;\n  } else if (idPage == 2.) {\n    vuMode = 0;\n    showDec = 1;\n    showTrn = 0;\n    isCol = false;\n  } else if (idPage == 3.) {\n    vuMode = 0;\n    showDec = 2;\n    showTrn = 0;\n    isCol = false;\n  } else if (idPage == 4.) {\n    vuMode = 0;\n    showDec = 2;\n    showTrn = 2;\n    isCol = false;\n  } else {\n    vuMode = int (mod (idPage - 5., 4.));\n    showDec = 2;\n    showTrn = 1;\n  }\n  InitSys ();\n  if (vuMode == 0) {\n    vuMat = StdVuMat (-0.2 * pi, -0.25 * pi);\n    ro = vuMat * vec3 (0., -0.1, -50.);\n    zmFac = 39.;\n    dstFar = 80.;\n  } else if (vuMode == 1) {\n    ro = vec3 (0., 2., -5.);\n    vd = normalize (Loadv4 (5 + 2).xyz - ro);\n    u = - vd.y * vd;\n    f = 1. / sqrt (1. - vd.y * vd.y);\n    vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n    zmFac = 16. * (atan (length (vd.xz), vd.y) / pi);\n  } else if (vuMode == 2 || vuMode == 3) {\n    pVu = Loadv4 ((vuMode == 2) ? 0 : 1);\n    ro.xz = pVu.xz;\n    ro.y = 0.4;\n    vuMat = StdVuMat (-0.1 * pi, - pVu.w);\n    zmFac = 5.4;\n  }\n  trkWide = (showTrn != 1 || vuMode <= 1);\n  ltDir = normalize (vec3 (1., 2., -1.));\n  rd = vuMat * normalize (vec3 (fCoord, 0.5 * zmFac));\n  col = ShowScene (ro, rd);\n  fCol = col;\n}\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, rRad, hRad, hOff, np, bc, thFac, nRing, y, s, w;\n  dMin = dstFarEx;\n  rRad = 0.4;\n  hRad = 0.08;\n  nRing = 5.;\n  hOff = 0.15;\n  thFac = 2.2;\n  np = float (nPage - 1);\n  q = p;\n  s = mod (nRing, 2.);\n  w = pgSize.x / nRing;\n  bc = q.x;\n  bc = mod (bc + s * w, 2. * w) - w;\n  for (int k = 0; k < nPage; k ++) {\n    q = p;\n    q.y -= 0.5 * np * thFac * pgSize.y;\n    y = q.y + np * thFac * pgSize.y * phsTurn;\n    if (k == 0) q.zy = Rot2D (vec2 (q.z, y), 2. * pi * phsTurn);\n    else q.y -= thFac * pgSize.y * (phsTurn - float (k));\n    d = hRad - length (vec2 (q.z + rRad, bc));\n    q.z -= - (pgSize.z - hOff + rRad);\n    d = max (PrRoundBoxDf (q, pgSize - pgSize.y, pgSize.y), d);\n    DMINQ (k + 1);\n  }\n  q = p;\n  d = abs (q.x) - pgSize.x;\n  q.x = bc;\n  q = q.zyx;\n  d = max (PrTorusDf (q, 0.5 * hRad, rRad + 0.3 * hRad), d);\n  DMINQ (nPage + 1);\n  return dMin;\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFarEx) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  v = vec4 (- ExObjDf (p + e.xxx), ExObjDf (p + e.xyy), ExObjDf (p + e.yxy), ExObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ExObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ExObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, c, vn;\n  vec2 s, w;\n  float dstObj, sh, npCyc, tpCyc, tpWait, nDotL, t;\n  bool isImg;\n  pgSize = vec3 (3.2, 0.011, 1.8);\n  tpCyc = 3.;\n  tpWait = 4.;\n  t = (tpBook < 0.) ? (- tpBook * float (nPage - 1) * (tpCyc + tpWait)) :\n     mod (tpBook - tpWait, float (nPage) * (tpCyc + tpWait));\n  npCyc = mod (floor (t / (tpCyc + tpWait)), float (nPage));\n  phsTurn = min (mod (t / (tpCyc + tpWait), 1.) * (tpCyc + tpWait) / tpCyc, 1.);\n  isImg = false;\n  dstObj = ExObjRay (ro, rd);\n  if (dstObj < dstFarEx) {\n    ro += dstObj * rd;\n    vn = ExObjNf (ro);\n    nDotL = max (dot (vn, ltDirEx), 0.);\n    if (idObj <= nPage) {\n      idPage = mod ((float (idObj - 1) + npCyc), float (nPage)) + 1.;\n      c = HsvToRgb (vec3 ((idPage - 1.) / float (nPage), 0.3, 1.));\n      s = pgSize.xz - abs (qHit.xz);\n      col4 = vec4 (0.9, 0.9, 0.8, 0.2);\n      if (qHit.y > 0.) {\n        w = qHit.xz / pgSize.z;\n        if (min (s.x, s.y) > 0.3) {\n          isImg = true;\n          ExMain (col, w);\n        } else if (min (s.x, s.y) > 0.27) {\n          col4 = vec4 (0.6 * c, 0.2);\n        } else {\n          col4 = vec4 (c, 0.2);\n        }\n      } else {\n        col4 = vec4 (c, 0.2);\n      }\n    } else if (idObj == nPage + 1) {\n      col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n      nDotL *= nDotL;\n    }\n    sh = ExObjSShadow (ro + 0.001 * vn, ltDirEx);\n    if (isImg) col *= 0.2 + 0.8 * sh;\n    else col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDirEx - rd), vn), 0.), 32.);\n  } else {\n    col = vec3 (1., 1., 0.9) * (0.5 + 0.1 * rd.z);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  stDat = Loadv4 (3);\n  tpBook = stDat.x;\n  el = stDat.y;\n  az = stDat.z;\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., -1.7, -20.);\n  zmFac = 9.;\n  dstFarEx = 40.;\n  ltDirEx = normalize (vec3 (0.3, 1., 0.3));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ExShowScene (ro, rd);\n  }\n  col = pow (col, vec3 (0.8));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 64.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Live Assembly Instructions\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define N_CAR 6\n#define TRK_LEN 24\n\nvec3 drP;\nvec2 rP;\nfloat ti[TRK_LEN + 1], tCur, trCyc, rgHSize, tC, aP;\nconst float pi = 3.14159;\n\n#define SLIN(k,d) ti[k + 1] = ti[k] + d\n#define SCRV(k) ti[k + 1] = ti[k] + tC\n\nvoid TrSetup ()\n{\n  tC = 0.25 * pi;\n  ti[0] = 0.;\n  SCRV(0);  SLIN(1, 4.);  SCRV(2);  SLIN(3, 1.);  SCRV(4);  SLIN(5, 1.);  SCRV(6);\n  SLIN(7, 2.);  SCRV(8);  SLIN(9, 1.);  SCRV(10);  SLIN(11, 1.);  SCRV(12);\n  SLIN(13, 4.);  SCRV(14);  SLIN(15, 1.);  SCRV(16);  SLIN(17, 1.);  SCRV(18);\n  SLIN(19, 2.);  SCRV(20);  SLIN(21, 1.);  SCRV(22);  SLIN(23, 1.);\n  trCyc = ti[TRK_LEN];\n  rgHSize = 3.;\n}\n\nvec2 TrackPath (float t)\n{\n  t = mod (t, trCyc);\n  drP = vec3 (0., 0., 99.);\n  if (t < ti[6]) {\n    if (t < ti[1]) {\n      rP = vec2 (0., 0.);  drP = vec3 (1., 1., 0.5 * tC + 0.25 * (t - ti[0]));\n    } else if (t < ti[2]) {\n      rP = vec2 (1., 0.5);  drP.x = (t - ti[1]);\n    } else if (t < ti[3]) {\n      rP = vec2 (5., 0.);  drP = vec3 (0., 1., 0.75 * tC + 0.25 * (t - ti[2]));\n    } else if (t < ti[4]) {\n      rP = vec2 (5.5, 1.);  drP.y = (t - ti[3]);\n    } else if (t < ti[5]) {\n      rP = vec2 (5., 2.);  drP.z = 0. * tC + 0.25 * (t - ti[4]);\n    } else {\n      rP = vec2 (5., 2.5);  drP.x = - (t - ti[5]);\n    }\n  } else if (t < ti[12]) {\n    if (t < ti[7]) {\n      rP = vec2 (4., 2.);  drP = vec3 (0., 1., 0.75 * tC - 0.25 * (t - ti[6]));\n    } else if (t < ti[8]) {\n      rP = vec2 (3.5, 3.);  drP.y = (t - ti[7]);\n    } else if (t < ti[9]) {\n      rP = vec2 (3., 5.);  drP = vec3 (1., 0., 0.5 * tC - 0.25 * (t - ti[8]));\n    } else if (t < ti[10]) {\n      rP = vec2 (4., 5.5);  drP.x = (t - ti[9]);\n    } else if (t < ti[11]) {\n      rP = vec2 (5., 5.);  drP.z = 0.25 * tC - 0.25 * (t - ti[10]);\n    } else {\n      rP = vec2 (5.5, 5.);  drP.y = - (t - ti[11]);\n    }\n  } else if (t < ti[18]) {\n    if (t < ti[13]) {\n      rP = vec2 (5., 3.);  drP = vec3 (0., 1., 0. * tC - 0.25 * (t - ti[12]));\n    } else if (t < ti[14]) {\n      rP = vec2 (5., 3.5);  drP.x = - (t - ti[13]);\n    } else if (t < ti[15]) {\n      rP = vec2 (0., 3.);  drP = vec3 (1., 1., 0.75 * tC - 0.25 * (t - ti[14]));\n    } else if (t < ti[16]) {\n      rP = vec2 (0.5, 4.);  drP.y = (t - ti[15]);\n    } else if (t < ti[17]) {\n      rP = vec2 (0., 5.);  drP = vec3 (1., 0., 0.5 * tC - 0.25 * (t - ti[16]));\n    } else {\n      rP = vec2 (1., 5.5);  drP.x = (t - ti[17]);\n    }\n  } else {\n    if (t < ti[19]) {\n      rP = vec2 (2., 5.);  drP.z = 0.25 * tC - 0.25 * (t - ti[18]);\n    } else if (t < ti[20]) {\n      rP = vec2 (2.5, 5.);  drP.y = - (t - ti[19]);\n    } else if (t < ti[21]) {\n      rP = vec2 (2., 2.);  drP = vec3 (0., 1., 0. * tC - 0.25 * (t - ti[20]));\n    } else if (t < ti[22]) {\n      rP = vec2 (2., 2.5);  drP.x = - (t - ti[21]);\n    } else if (t < ti[23]) {\n      rP = vec2 (0., 2.);  drP = vec3 (1., 0., 0.25 * tC + 0.25 * (t - ti[22]));\n    } else {\n      rP = vec2 (0.5, 2.);  drP.y = - (t - ti[23]);\n    }\n  }\n  if (drP.z != 99.) {\n    drP.z *= 2. * pi / tC;\n    rP += 0.5 * vec2 (cos (drP.z), sin (drP.z));\n  }\n  rP += drP.xy - rgHSize;\n  return rP;\n}\n\nconst float txRow = 64.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[2], pCar, pVu, stDat, mPtr;\n  vec2 iFrag, canvas, ust, vo, p1, p2;\n  float el, az, asp, cGap, tCurP, trVar, trSpd, trMov, t1, t2, t, ntStop, tpBook;\n  int pxId, trStop, pxcMin;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 2 * N_CAR + 5) discard;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  el = 0.;\n  az = 0.;\n  if (iFrame <= 5) {\n    tpBook = 0.;\n    trMov = 0.;\n    trStop = 2;\n    ntStop = 0.;\n    trVar = 0.25;\n  } else {\n    stDat = Loadv4 (2);\n    trMov = stDat.x;\n    trSpd = stDat.y;\n    tCurP = stDat.z;\n    stDat = Loadv4 (3);\n    tpBook = stDat.x;\n    el = stDat.y;\n    az = stDat.z;\n    trVar = stDat.w;\n    stDat = Loadv4 (4);\n    trStop = int (stDat.x);\n    ntStop = stDat.y;\n  }\n  tpBook = tCur;\n  az = 0.;\n  el = -0.5 * pi;\n  if (mPtr.z > 0.) {\n    tpBook = - clamp (1.05 * mPtr.y + 0.5, 0., 1.);\n  }\n  trSpd = 1.2 * trVar;\n  if (trSpd < 0.01) trSpd = 0.;\n  TrSetup ();\n  t = mod (trMov / trCyc, 1.);\n  if (trStop == 0) {\n    if (t > 0.122) {\n      trStop = 1;\n      trSpd = 0.;\n      ntStop = 100.;\n    }\n  } else if (trStop == 1) {\n    if (-- ntStop > 0.) trSpd = 0.;\n    else trStop = 2;\n  } else if (trStop == 2) {\n    if (t < 0.07) trStop = 0;\n  }\n  trMov += trSpd * (tCur - tCurP);\n  cGap = 0.33;\n  pxcMin = 5;\n  if (pxId >= pxcMin) {\n    if (pxId - pxcMin < N_CAR) t = trMov - float (pxId - pxcMin) * cGap;\n    else t = 0.122 * trCyc - float (pxId - pxcMin - N_CAR) * cGap;\n    p1 = TrackPath (t + 0.3 * cGap);\n    p2 = TrackPath (t - 0.3 * cGap);\n    pCar.xz = 0.5 * (p1 + p2);\n    pCar.y = 0.;\n    vo = p1 - p2;\n    pCar.w = atan (vo.x, vo.y);\n  } else if (pxId == 0 || pxId == 1) {\n    if (pxId == 0) {\n      t1 = trMov - (float (N_CAR - 1) + 2.5) * cGap;\n      t2 = t1 + 2. * cGap;\n    } else {\n      t1 = trMov + 2.5 * cGap;\n      t2 = t1 - 2. * cGap;\n    }\n    p1 = TrackPath (t1);\n    p2 = TrackPath (t2);\n    pVu.xz = p1;\n    pVu.y = 0.;\n    vo = p2 - p1;\n    pVu.w = - atan (vo.x, vo.y);\n  }\n  tCurP = tCur;\n  if (pxId < 2) stDat = pVu;\n  else if (pxId == 2) stDat = vec4 (trMov, trSpd, tCurP, trCyc);\n  else if (pxId == 3) stDat = vec4 (tpBook, el, az, trVar);\n  else if (pxId == 4) stDat = vec4 (float (trStop), ntStop, 0., 0.);\n  else if (pxId >= pxcMin) stDat = pCar;\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}