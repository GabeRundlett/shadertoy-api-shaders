{
    "Shader": {
        "info": {
            "date": "1558184917",
            "description": "pause time near 1,25 seconds  for a horn-shape (if mouse clicks in upper half)\nlast 3 days i thought a bit more about shape generalizations and 3d shadows of 4d objects. \ninspired by the head shader\nhttps://www.shadertoy.com/view/wlf3WX\n",
            "flags": 0,
            "hasliked": 0,
            "id": "3tSGRR",
            "likes": 15,
            "name": "cone+Ellipsoid=Unicorn 4d",
            "published": 3,
            "tags": [
                "cone",
                "4d",
                "ellipsoid",
                "parabola",
                "hyperbola",
                "hyperbolic",
                "parabolic",
                "generalization",
                "hypercone",
                "lathe",
                "ellipticparaboloid",
                "eccentric"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1537
        },
        "renderpass": [
            {
                "code": "/*\npause time near 1,25 seconds  for a horn-shape (if mouse clicks in upper half)\nlast 3 days i thought a bit more about shape generalizations and 3d shadows of 4d objects. \ninspired by the head shader:\n- head-shape almost only uses ellipsoid() and very few other shapes.\n- what if i add a useful generalization to such shapes.\n- sure, it gegs to be 3d shadows of 4d objects.\n\nself     : https://www.shadertoy.com/view/3tSGRR\nparent   : https://www.shadertoy.com/view/Md2XDV  (3d shadow of 4d canvas)\nparent   : https://www.shadertoy.com/view/4lyfzw  (extrude and lathe)\ninpiring : https://www.shadertoy.com/view/wlf3WX\n\nshape generalizations are in CommonTab with detailed rants about them\n\n/Md2XDV is Created by Sebastien Durand - 2014\n License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n To understand what it is, look at part \"Where is the Inside?\" at url:\n http://eusebeia.dyndns.org/4d/vis/09-interp-1\n\ni have many issues with the parent shader canvas\n, it is rather sloppy, but gets the basics done.. \nThere are  only like 4 shaders that do 3d shadows of 4d objects\n, and this one is still the fastest of them (while surely not the most elegant)\n, performance and context/reference wins here.\n\nI only use this to debug and define 4d distance fields, which is tricky enough.\n*/\n\n//4d, generalization,cone,ellipsoid,Hypercone,hyperbolic,parabolic,hyperbola,parabola,lathe,EllipticParaboloid\n\n// less calcul and loop \n#define FAST \n\n\n#ifdef FAST\nvec4 v0000,v1000,v0100,v0010,v0001,v1100,v1010,v1001;\n#endif\n\n\n// From 4D to 3D \nvec3 line4D(in vec3 p, vec4 p1, vec4 dp) {\n    p1+=mv4D;\n    //dp+=mv4D;\n \tvec3 pa = p-p1.xyz, ba = dp.xyz;\n    float k = clamp(dot(pa,ba)/dot(ba,ba),0., 1.);\n    return vec3(length(pa - ba*k) - RAYON ,k, p1.w +k*dp.w);}\n\n\n#ifdef FAST\n// FASTER like this but uggly and not working in firefox\nvec3 sdTesserac(in vec3 p\n){vec3 d;    \n        d = // 000\n            miX(line4D(p, v0000, B[3]),\n\t\t\tmiX(line4D(p, v0000, B[2]),\n\t\t    miX(line4D(p, v0000, B[1]), \n                 line4D(p, v0000, B[0]))));\n        d = miX(d, // 100\n            miX(line4D(p, v1000, B[3]),\n\t\t\tmiX(line4D(p, v1000, B[2]),\n\t\t    miX(line4D(p, v1000, B[1]), \n                 line4D(p, v0100, B[0])))));\n        d = miX(d, // 010\n            miX(line4D(p, v0100, B[3]),\n\t\t\tmiX(line4D(p, v0100, B[2]),\n\t\t    miX(line4D(p, v0010, B[1]), \n                 line4D(p, v0010, B[0])))));\n        d = miX(d, // 110\n            miX(line4D(p, v1100, B[3]),\n\t\t\tmiX(line4D(p, v1100, B[2]),\n\t\t    miX(line4D(p, v1010, B[1]), \n                 line4D(p,-v1001, B[0])))));\n        d = miX(d, // 001\n            miX(line4D(p, v0010, B[3]),\n\t\t\tmiX(line4D(p, v0001, B[2]),\n\t\t    miX(line4D(p, v0001, B[1]), \n                 line4D(p, v0001, B[0])))));\n        d = miX(d, // 101\n            miX(line4D(p, v1010, B[3]),\n\t\t\tmiX(line4D(p, v1001, B[2]),\n\t\t    miX(line4D(p, v1001, B[1]), \n                 line4D(p,-v1010, B[0])))));\n        d = miX(d, // 011\n            miX(line4D(p,-v1001, B[3]),\n\t\t\tmiX(line4D(p,-v1010, B[2]),\n\t\t    miX(line4D(p,-v1100, B[1]), \n                 line4D(p,-v1100, B[0])))));\n        d = miX(d, // 111\n            miX(line4D(p,-v0001, B[3]),\n\t\t\tmiX(line4D(p,-v0010, B[2]),\n\t\t    miX(line4D(p,-v0100, B[1]), \n                 line4D(p,-v1000, B[0])))));    \n\treturn d;\n}\n#else\n// Tesserac projection (smartest but loop make it a little bit slower)\nvec3 sdTesserac(in vec3 p) {\n\tvec3 d = vec3(100.,-1.,0.);\n\tvec4 k = vec4(-.5);    \n\t// Simple initialisation of the 32 Edges of tesserac \n\tfor (int i=0; i<8; i++) {\n\t\tk.x = mod(float(i),2.)-.5; k.y = mod(float(i/2),2.)-.5; k.z = mod(float(i/4),2.)-.5; \n        d = miX(d,\n            miX(line4D(p, B*k    ,  B[3]),\n\t\t\tmiX(line4D(p, B*k.xywz, B[2]),\n\t\t    miX(line4D(p, B*k.xwyz, B[1]), \n                 line4D(p, B*k.wxyz, B[0])))));\n\t}\n\treturn d;\n} \n#endif\n\n/**/\n\n\n//WCurrent==m.x is the 4th domain (3d hyperslice of 4d object)\n//... as global var\n\nvec3 unicorn(vec3 p,vec4 m,float chubby  //uv,mouse.xy,chubbyness\n){//p-=.5\n ;p*=2.\n ;//overwriting m.y like that ruins some normalization,\n ;//m.y=iMouse.x/iResolution.x*.5+.5 //negative m.y work, but shapes are cocave.\n ;vec3 e=vec3(cone4(vec4(p,WCurrent)*B-vec4(.5,0,0,0),normalize(vec2(.5-m.y*.5)-chubby)),-1,m.x)//\n ;e=-miX(-e,-vec3(length(vec4(p,WCurrent)*B)-2.5-chubby,-1,m.x  )  )\n     //union with sphere to cap infinity \n     //...and to keep camera outside this object.\n ;e.x/=2.\n ;return e\n ;}\n\n// x: distance, y : distance on segment, z : 4th dimension coord\nvec3 map(vec3 p //time,uv, m.x==WCurrent m.y=RAYON\n){vec4 m;\n ;float t=iTime\n ;m.x=WCurrent\n ;m.y=RAYON\n // ;float chubby=mix(0.,.4,abs(p.x)) //silly bot not useless\n ;float chubby=mix(0.,.2,cos(t)*.5+.5)                    //interior roundness\n ;vec3 d=sdTesserac(p)+vec3(chubby,0.,0.)//+vec3(chubby,0,0)\n ;d=miX(d,unicorn(p,m,chubby))\n ;//d.y=0.//anti.seizute from rapid flickering (cone is often close to a singularity, as it has a division)\n ;//d=miX(d,vec3(box(vec4(p,WCurrent)*B, vec4(.5-m.y*.5)-chubby),-1,m.x))  \n ;//d=miX(d,vec3(length(vec4(p,m.x)*B)-.5-chubby2,-1,m.x      ))//sphere  \n ;//d=miX(d,vec3(sdCubinder(vec4(p,m.x)*B,vec3(.5-m.y*.5)-chubby),-1,m.x))\n ;//d=miX(d,vec3(cylinderDuo(vec4(p,m.x)*B,vec2(.5-m.y*.5)-chubby),-1,m.x))\n ;return d-chubby//+vec3(chubby,0.,0.)\n     ;}\n/*\nbeware:\nA 3d object casts a 2d shadow next to a point in a 2d plane\nThe smallest signed distance between the point on the plane and the 2d shadow of the 3d object.\n...is unlikely the same as....\nThe smallest signed distance between the point on the plane and the                  3d object.\n\nA 4d object casts a 3d shadow, next to a point in a 3d space\nThe smallest signed distance between the point on the plane and the 3d shadow of the 4d object.\n...is unlikely the same as....\nThe smallest signed distance between the point on the plane and the                  4d object.\n/**/ \n\n\n\n\n\n// Classical AO calculation\nfloat calcAO(float t,in vec3 pos, in vec3 nor,vec4 m,mat4 B) {\n    float hr=.01, ao=.0, sca=1.;\n    for(int aoi=0; aoi<5; aoi++) {\n        ao += -(map(nor*hr+pos).x-hr)*sca;\n        sca *= .7;\n        hr += .05;\n    }\n    return clamp(1.-4.*ao, 0., 1.);\n}\n\n\nfloat softshadow(float tt, vec3 ro, in vec3 rd, float k ,vec4 m,mat4 B) {\n    float res=1., z=0.02, h=1.;\n    for(int i=0; i<53; i++){\n        h = map(ro + rd*z).x;\n        res = min( res, k*h/z );\n\t\tz += clamp( h, 0.015, 1.0 );\n\t\tif( h<0.012 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n#if __VERSION__ <300\nmat4 outerProduct(vec4 a,vec4 b){return mat4(a*b.x,a*b.y,a*b.z,a*b.w);}\n#endif\nfloat ad(vec4 a){return a.x+a.y+a.z+a.w;}\n\nvec3 normalT(vec3 p,vec3 ray,float t,vec4 m,mat4 B//4tap tetrahedral derivative in3d\n){vec2 e=vec2(E.y,-E.y); \n ;p=e.xyy*map(p+e.xyy).x\n   +e.yyx*map(p+e.yyx).x\n   +e.yxy*map(p+e.yxy).x\n   +e.xxx*map(p+e.xxx).x\n ;if(p==vec3(0))return vec3(1)//NaN-evasion, normalize(vec3(0)) divides by /0. \n ;return normalize(p);}//volumeMarching may see gradient (close to) 0 trough volumes  \n\nvec3 normal(vec3 p,vec3 ray,float t,vec4 m,mat4 B//4tap tetrahedralOffset derivative in3d.\n){mat4 n=(outerProduct(vec4(p,0),vec4(1))\n +(((mat4(0,0,0,2,0,4,4,2,4,0,4,2,4,4,0,2)-2.)*t/iResolution.x)))\n ;vec4 a=vec4(map(n[0].xyz).x\n             ,map(n[1].xyz).x\n             ,map(n[2].xyz).x\n             ,map(n[3].xyz).x)\n ;p=(n*a).xyz-p*ad(a)\n ;p-=max(.0,dot(p,ray))*ray\n ;if(p==vec3(0))return vec3(1)//NaN-evasion, normalize(vec3(0)) divides by /0.\n ;return normalize(p);}//volumeMarching may see gradient (close to) 0 trough volumes   \n\n//  s = softshadow(x, L, 32.); // faster with soft shadow but need to find good params   \nvoid shadowSoft(inout float s,inout vec3 x,inout float j,float t,vec4 m,mat4 B\n){float h\n ;for(int i=0;i<64;i++\n ){h=map(x+lightDir*j).x\n  ;j+=clamp(h, .032, 1.);\n               \ts = min(s, h/j);\n             \tif(j>7.|| h<.001) break;\n            } \n}\n\n// Classical 3D to 2D rendering loop\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){vec4 mouse = iMouse.xwzy\n ;mouse=iMouseZwFix(mouse,true)\n ;vec2 r = iResolution.xy\n ,m = mouse.xy/r\n ,q = fragCoord.xy/r.xy\n ,p =q+q-1.\n ;p.x *= r.x/r.y\n ;float j=.032, s=1., h = .1;\n ;WCurrent=iMouse.y/iResolution.y*2.-1.\n ;vec3 c = vec3(.22,.26,.28)\n ;float k = 0.\n ;if(q.x>.95//right side bar\n ){float w = 2.*(fragCoord.y/iResolution.y)-1.\n  ;c=mix(C1,C2, .5+1.2*w)\n  ;k=1.-smoothstep(abs(w-WCurrent),-.003,.003)\n  ;} else if (true     //length(q-.5)<.4 //optional screenspace Bound\n   ){float hs = iTime*.61//hash(4.+floor(10.+.15*iTime));\n\t;float time = iTime//1.*(15.+.5*iTime * hs + 10.2*hash(hs)); //+ .08*hash(iTime);;\n    ;// Rotation Matrix to apply to 4D objects\n    ;float aaa = 10.+time*.4,bbb = 11.+time*.61, ccc = 11.+time*1.32\n    ;float c1 = cos(aaa), s1 = sin(aaa)\n    ;float c2 = cos(bbb), s2 = sin(bbb)\n    ;float c3 = cos(ccc), s3 = sin(ccc)\n    ;B = mat4(c2,  s2*s3,   0, -s2*c3\n             ,0,  c1*c3, -s1,  c1*s3\n             ,0,  c3*s1,  c1,  s1*s3\n             ,s2, -c2*s3,   0,  c2*c3);\n#ifdef FAST\n    \tv0000 = B*vec4(-.5,-.5,-.5,-.5);\n    \tv1000 = B*vec4( .5,-.5,-.5,-.5);\n    \tv0100 = B*vec4(-.5, .5,-.5,-.5);\n    \tv0010 = B*vec4(-.5,-.5, .5,-.5);\n    \tv0001 = B*vec4(-.5,-.5,-.5, .5);\n    \tv1100 = B*vec4( .5, .5,-.5,-.5);\n    \tv1010 = B*vec4( .5,-.5, .5,-.5);\n    \tv1001 = B*vec4( .5,-.5,-.5, .5);\n#endif\n ;float roty=m.x\n  ;vec3 res,\n            o = 3.*normalize(vec3(cos(time+4.*roty), c1, s1*sin(time+4.*roty))),\n             w = normalize(-o),\n        \t u = normalize(cross(w, vec3(0,1,0))), v = cross(u, w),\n         \t d = normalize(p.x * u + p.y * v + w+w), n, x;\n\n\t\tfloat t=0.;\n        \n        for(int i=0;i<56;i++) { \n            if (h<.003 || t>4.) break;\n            t += h = map(o+d*t).x;\n        }\n        // Rendering    \n        if (h <= .003) {\n            x = o + t * d;\n            res = map(x);\n            n = normal(x,d,t,vec4(WCurrent,RAYON,0,0),B);\n\n            // Calculate Shadows\n\n ;shadowSoft( s,x, j,iTime,vec4(WCurrent,RAYON,0,0),B)\n            \n            \n            \n            \n            ;float ao= calcAO(iTime,x, n,vec4(WCurrent,RAYON,0,0),B);\n            // Teserac color\n            vec3 co = (mod(res.y,.25)>.1?.7:1.) * mix(C1,C2, .5+1.2*res.z); \n            co*=ao;\n            if (res.y >= 0.)  k=1.-smoothstep(abs(res.z-WCurrent),-.002,.002);\n            // Shading\n            c = mix(c, mix(sqrt((clamp(3.*s,0.,1.)+.3)*co), vec3(pow(max(dot(reflect(lightDir,n),d),0.),99.)),.4),2.*dot(n,-d));\n        } \n    }\n    \n\tvec4 col = vec4(c+vec3(2,2,.8)*k,1);\n   \n    if (q.x<.95) {\n    \tcol *= pow(16.0*q.x*q.y*(1.-q.x)*(1.-q.y),.3);\n    }\n    fragColor = col;\n    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n\nconst float RAYON = .02;\nconst vec3 C1 = vec3(.2,.9,1), C2 = vec3(1,.3,.5);  // Colors for w coord\nconst vec3 E = vec3(0,.001,0); // epsilon\nvec3 lightDir = normalize(vec3(0.6, 0.7, 0.5)); // light\nmat4 B;\nfloat WCurrent;\nvec4 mv4D;\n\nvec3 miX(vec3 v1,vec3 v2){return v1.x<v2.x ? v1 : v2;}\n\n//generalized BaseShapes\n//work with 2d, 3d or 4d inputs\n//basic higher dimensions assert lathe around .x axis ,OR hypercubes\n//u=uv point we measure a distance to, if its more than 1*[uuu] it only works for as many domais as there are [uuu]s\n//r=radius (some shapes may bave multiple radii, eppipsoids or bicapsules\n\n//in higher dimensional generalization, it makes sense to substitute terms:\n//radius ==r==ThicknessEublidean\n//height ==h==thicknessCarthesian\n//BUT there is likely more than 1 heightDomain or more than one radius domain\n//AND box(u,h)-r can be used like box(u,h-r)-r \n//AND all params that are [neither height nor radius (nor both)] are usually [points in carthesian space] that usualy refer to (Lie)sphere centers\n\n\n#define dd(a)dot(a,a)\n#define sat(a)clamp(a,0.,1.)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\nfloat mi(vec2 a){return min(a.x,a.y);}\nfloat mi(vec3 a){return min(mi(a.xy),a.z);}\nfloat mi(vec4 a){return min(mi(a.xy),mi(a.zw));}\n#define ma(a)-mi(-a)\n//beware, ellipsoid is far from precise\n#define ellipsoid(u,r) (length(u/r)-1.)*mi(r)\n//umb()==distance to box(not rounded) [unsigned mean boundingBox]\n#define umb(u,h) (abs(u)-(h))\n\n//round*() functions tend to be the (optional) wrapper \n//Their sinplest example is [[RoundedCube] == round(cube()) ]\n//RoundXY() opens the option for euclidean-smoothed \n//...higher dimensional/domain objects.\n//by only taking the max() of the .xy domains\n//, but adding length() to all domains.\n//rounded   SIGNED distance to box\n#define box(u,h) Round(umb(u,h))\n//rounded UNSIGNED distance to HOLLOW box (shortcut : the abs() simplifies)\n#define boxU(u,h) length(max(umb(u,h),0.))\n//\n//return [euclidean round distance] of [upper bound corner]\n#define Round(a)   min(ma(a     ),0.)+length(max(a,0.))\n#define RoundXy(a) min(ma((a).xy),0.)+length(max(a,0.))\n//roundedExtrusion/lathe   https://www.shadertoy.com/view/4lyfzw\n#define  extrude(u,a,h) RoundXy(vec2(a,umb(u,h))\n//box (rounded) is a spheroid; where ever b==0.\n//you may transition a [roundness [R]], by doing s=box(u,h-r)\n//instead of  s=box(u,h)-r for a box with added rounded thickness\n//*S==subRoutine\n#define capsuleS(u,a,b) length(u-b*sat(dot(u,b)/dd(b)))\n#define capsule(u,a,b) capsuleS((u-a),a,(b-a))\n\n//to composite hint: set some of the [.rr][.rh] parameters to 0 or 1.\n//this likely gets you a simpler special case shape.\n//-------3d composite of lower domain objects\n//circle.lathe   (torus of thickness), ring() allows for more input types.\n#define torus(uuu,r ) latheYz(uuu,vec2(r,0))\n#define latheYz(uuu,rr)  length(     vec2(length((uuu ).x ),   (uuu ).yz  )-rr)\n#define ringDuo(uuuu,rr) length(sqrt(vec2(    dd((uuuu).xw),dd((uuuu).yz)))-rr)\n\nfloat cone(vec3 u,vec2 c//c must be normalized\n){return dot(c,vec2(u.x,length(u.yz)));}\n//as far as cone4 is concerned, the term [hypercone] seems to be VERY ambiguous:\n//cone4 is not a spacetime-funnel shape, but a unicorn-horn-shape\n//cone4 is an unholy union of: a cone and an ellipsoid \n\n\n//------distance to 3d shadow of 4d (ish) object:\n\nfloat cone4(vec4 u,vec2 c//c must be normalized, sphere is in .yzw plane\n){return dot(c,vec2(u.x,length(u.yzw)));}\n\n//circle.y_extrude=cylinder\n//https://iquilezles.org/articles/distfunctions\nfloat cylinder(vec3 u,vec2 rh\n){return RoundXy(vec2(length(u.xy),u.z)-rh);}\n\n//4d composites of lower-domain objects\n\n//sphere.w_extruded  http://eusebeia.dyndns.org/4d/duocylinder  \n#define cylinderDuo(uuuu,rr) RoundXy(abs(sqrt(vec2(dd((uuuu).xz),dd((uuuu).yw))))-rr)\n\n//cylinder.w_extruded  http://eusebeia.dyndns.org/4d/cubinder    \n//no used in here\nfloat sdCubinder(vec4 u,vec3 rhh){return Round(abs(vec3(length(u.xy),u.zw))-rhh);}\n\n//a box.w_extruded is still a box()\n\n\n/*shape rants\n\nI wanted to see if I could get the cone4() function defined\n, and it was surprisingly simple.\n\ncone4() is is a 4d extension to cone()      ,sdCone()      of \nhttps://iquilezles.org/articles/distfunctions\ncone4() is is a 4d extension to ellipsoid() ,sdEllipsoid() of \nhttps://iquilezles.org/articles/distfunctions\n...it is both in one...\nIt takes a while to wrap your head around the not too intuitive fact\n, that sdCone() and sdEllipsoid are to 3/4rd identical\n, and there exists a 4d generalization of both 3d shapes, which i name cone4()\n, because Hypercone() would be to ambiguous and too long.\nhttps://imgur.com/gallery/vv7fG\nillustrates this in gif form.\n\nwe could need a more user friendly context for those 4d rotations?\n\nRound() RoundXy() and lathe() are functions that you can get a lot of utility from.\n\n\nit seems that cones are a verc2, where one of them is a length(), so i put the length() as .y\nit seems that cylindricals end up being vec3(), with at leadst one length(vec2), so i pit that as .x component.\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}