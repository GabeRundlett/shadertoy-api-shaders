{
    "Shader": {
        "info": {
            "date": "1600911880",
            "description": "A man from my shader art piece \"A LOST MEMORY\".\n[url]https://iy0yi.me/work/a-lost-memory/[/url]\nSorry for the long compiling time!\nAnd this can run only under a 32bit float environment.",
            "flags": 32,
            "hasliked": 0,
            "id": "Ws3yW4",
            "likes": 161,
            "name": "A man from \"A LOST MEMORY\"",
            "published": 3,
            "tags": [
                "npr",
                "human",
                "alostmemory"
            ],
            "usePreview": 1,
            "username": "iY0Yi",
            "viewed": 2769
        },
        "renderpass": [
            {
                "code": "//////////////////////////////////////////////////////////////////////////////////////////\n//  .--.   .-.    .--.  .--. .-----.  .-..-. .--. .-..-. .--. .---. .-..-.              //\n// : .; :  : :   : ,. :: .--'`-. .-'  : `' :: .--': `' :: ,. :: .; :: :: :              //\n// :    :  : :   : :: :`. `.   : :    : .. :: `;  : .. :: :: ::   .'`.  .'              //\n// : :: :  : :__ : :; : _`, :  : :    : :; :: :__ : :; :: :; :: :.`. .' ;               //\n// :_;:_;  :___.'`.__.'`.__.'  :_;    :_;:_;`.__.':_;:_;`.__.':_;:_;:_,'                //\n//                                                                                      //\n//  A man from \"A LOST MEMORY\" by iY0Yi                                                 //\n//  https://www.shadertoy.com/view/Ws3yW4                                               //\n//                                                                                      //\n//  Created by Atsushi Hashimoto 2020                                                   //\n//                                                                                      //\n//  This is a part of my shader art piece \"A LOST MEMORY\":                              //\n//  https://iy0yi.me/work/a-lost-memory/                                                //\n//                                                                                      //\n//  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. //\n//                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////\n\n// Effect pass\n\n//#define DEBUG_PASSES\n\n// https://www.shadertoy.com/view/3ssSz2\nfloat originalSigmoidContrast(float color, float contrast, float mid)\n{\n    contrast = contrast < 1.0 ? 0.5 + contrast * 0.5 : contrast;\n    float scale_l = 1.0 / mid;\n    float scale_h = 1.0 / (1.0 - mid);\n    float lower = mid * pow(scale_l * color, contrast);\n    float upper = 1.0 - (1.0 - mid) * pow(scale_h - scale_h * color, contrast);\n    return color < mid ? lower : upper;\n}\n\n// Read data from BufA\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 readAlbedo(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return unpack(data.y);\n}\n\nvec3 readNormal(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return unpack4(data.x).xyz;\n}\n\nfloat readShadow(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return unpack4(data.x).w;\n}\n\nfloat readDepth(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return data.w;\n}\n\nfloat readDiffuse(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    vec3 spec_diffuse_ao = unpack(data.z)*.5+.5;\n    return spec_diffuse_ao.y;\n}\n\nfloat readSpecular(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    vec3 spec_diffuse_ao = unpack(data.z)*.5+.5;\n    return spec_diffuse_ao.x;\n}\n\nfloat readAO(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    vec3 spec_diffuse_ao = unpack(data.z);\n    return spec_diffuse_ao.z;\n}\n\nvec3 readSharpenNormal(in vec2 fragCoord, float strength)\n{\n    vec3 res =\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1,-1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0,-1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1,-1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 0)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 0)), 0).x).xyz*2.-1.) *   9. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 0)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 1)), 0).x).xyz*2.-1.) *  -1.\n    ;\n    return mix((unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2(0, 0)), 0).x).xyz), res , strength);\n}\n\nfloat readSharpenSpecular(in vec2 fragCoord, float strength)\n{\n    float res =\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1,-1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0,-1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1,-1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 0)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 0)), 0).z)*.5+.5).x *   9. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 0)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 1)), 0).z)*.5+.5).x *  -1.\n    ;\n    return mix((unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(0, 0)), 0).z)*.5+.5).x, res , strength);\n}\n\nfloat readSharpenDiffuse(in vec2 fragCoord, float strength)\n{\n    float res =\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1,-1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0,-1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1,-1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 0)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 0)), 0).z)*.5+.5).y *   9. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 0)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 1)), 0).z)*.5+.5).y *  -1.\n    ;\n    return mix((unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(0, 0)), 0).z)*.5+.5).y, res , strength);\n}\n\nfloat readSharpenAO(in vec2 fragCoord, float strength)\n{\n    float res =\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1,-1)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0,-1)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1,-1)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 0)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 0)), 0).z)*.5+.5).z *   9. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 0)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 1)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 1)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 1)), 0).z)*.5+.5).z *  -1.\n    ;\n    return mix((unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(0, 0)), 0).z)*.5+.5).z, res , strength);\n}\n\n\n// NPR effects\n// Maybe, you can better ways for these effects in somewhere else...\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat dithering(float v, vec2 fragCoord)\n{\n    v=pow(v, 8.);\n    vec2 p = fragCoord;\n    p = mod(p.xx + vec2(p.y, -p.y), vec2(.1));\n    float res=0.;\n    vec2 coords = fragCoord;\n\n    float angle = dot(readSharpenNormal(fragCoord, 1.), vec3(0,0,1));\n\n    coords.xy*= mat2(cos(angle*PI+vec4(0,11,33,0)));\n    coords.y *= .75+.25*hash12(p);\n    float rand_ditherVal = fbm(coords*.75, 2);\n    const float paletteDist = 1.15;\n    res=v + (rand_ditherVal - .5) * paletteDist;\n    res=smoothstep(0.1,1.,res);\n    res=saturate(floor(res*6.)/5.);\n\n    return res;\n}\n\nfloat calcEdge(vec3 nlm1, vec3 nlm2)\n{\n    vec2 difN = abs(nlm1.xy - nlm2.xy);\n    return smoothstep(.41, .3, difN.x + difN.y);\n}\nfloat getOutline(vec2 fragCoord)\n{\n    vec2 coord = fragCoord;\n    vec3 offset = vec3(1, -1, 0) * .5;\n    float edge = 1.0;\n    edge *= calcEdge(readNormal(coord+offset.xx), readNormal(coord+offset.yy));\n    edge *= calcEdge(readNormal(coord+offset.xy), readNormal(coord+offset.yx));\n    edge *= calcEdge(readNormal(coord+offset.zy), readNormal(coord+offset.zx));\n    edge *= calcEdge(readNormal(coord+offset.yz), readNormal(coord+offset.xz));\n    return edge;\n}\n\nfloat getShadowEdge( vec2 fragCoord )\n{\n    vec2 coord = fragCoord;\n    float sha = readShadow(coord);\n    sha -= .5;\n    sha = abs(sha);\n    sha = smoothstep(.1,.2,sha);\n    return sha;\n}\n\nfloat getDottedShadow(vec2 fragCoord)\n{\n    vec2 uv = fragCoord;\n    uv *= mat2(cos(.8+vec4(0, 11, 33, 0)));\n    uv = mod(uv*.25, 1.);\n    float res = 0.;\n    float shadow = readShadow(fragCoord);\n    shadow = max(.65,shadow*.85) + .35*readAO(fragCoord);\n    shadow = 1. - shadow;\n    res = smoothstep(shadow, shadow+1., pow(length(uv-.5), 4.));\n    res = smoothstep(.0, .2, pow(res, .05));\n    return res;\n}\n\nfloat hatching(vec2 fragCoord, float tickness, float angle, float dark, float light, bool centered)\n{\n    vec2 v = fragCoord.xy / iResolution.xy;\n    vec3 n = readNormal(fragCoord);\n\n    float f = smoothstep(.1, 1., saturate(-n.y)*saturate(-n.x));\n    // tickness /= f+PI;\n\n    v *= mat2(cos(n.z*PI*.25 + angle + vec4(0, 11, 33, 0)));\n    v.y = mod(v.y*iResolution.y/tickness, 1.);\n    v.y += fbm(fragCoord.yx*.05, 2)*.0005;\n\n    float shading = readSharpenDiffuse(fragCoord, 2.);\n    shading = mix(shading, (1.-shading)*.3+.7*readAO(fragCoord), 1.-readShadow(fragCoord));\n    shading *= 1.5;\n    shading = smoothstep(dark, light, pow(shading, 1.8));\n    if(centered)\n    {\n        shading = (shading-.5)*2.;\n        shading = saturate(shading);\n        shading = abs(shading-.5)*2.;\n    }\n    else\n        shading = saturate(shading-.5)*2.;\n\n    shading = originalSigmoidContrast(shading*.95+.05*saturate(fbm(fragCoord*.025, 2)), noise(fragCoord*.02)*noise(fragCoord.yx*.03)*.5, .7);\n    float face = smoothstep(.5, 1.8, saturate(-n.y)*saturate(-n.x));\n    float line = smoothstep(-.3, shading+.5, 1.-abs(v.y-.5)*2.);\n    line = saturate(pow(line+shading+face, 5.));\n\n    return line;\n}\n\nfloat getHatching(vec2 fragCoord)\n{\n    if(readDepth(fragCoord)>.9)\n    return 1.;\n\n    float ln = 1.;\n    const float mul = 1.;\n        ln*= pow(hatching(fragCoord, 4.*mul, .6, .6, .8, true), 10.);\n        ln*= pow(hatching(fragCoord, 3.5*mul, -.4, -1.4, 1.4, false), 50.5);\n        ln*= pow(hatching(fragCoord, 3.5*mul, .4, -1.4, 1.4, false), 50.5);\n    return ln;\n}\n\nfloat hatchingSpecular(vec2 fragCoord, float tickness, float angle, float dark, float light, bool centered)\n{\n    vec2 v = fragCoord.xy / iResolution.xy;\n    vec3 n = readNormal(fragCoord);\n    if(length(n)<.1)\n        return -1.;\n    float f = smoothstep(.1, 1., saturate(-n.y)*saturate(-n.x));\n    // tickness /= f+PI;\n\n    v *= mat2(cos(n.z*PI*.25 + angle + vec4(0, 11, 33, 0)));\n    v.y = mod(v.y*iResolution.y/tickness, 1.);\n    v.y += fbm(fragCoord.yx*.05, 2)*.0005;\n\n    float shading = readSpecular(fragCoord);\n    shading *= readShadow(fragCoord);\n    //shading *= 1.5;\n    shading = smoothstep(dark, light, pow(shading, 1.8));\n    if(centered)\n    {\n        shading = (shading-.5)*2.;\n        shading = saturate(shading);\n        shading = abs(shading-.5)*2.;\n    }\n    else\n        shading = saturate(shading-.5)*2.;\n    \n\tshading = originalSigmoidContrast(shading*.98+.03*saturate(fbm(fragCoord*.025, 2)), noise(fragCoord*.02)*noise(fragCoord.yx*.03)*.5, .7);\n    shading = 1.-saturate(shading*.55);\n    float face = smoothstep(.5, 1.8, saturate(-n.y)*saturate(-n.x));\n    float line = smoothstep(-.3, shading+.5, 1.-abs(v.y-.5)*2.);\n    line = saturate(pow(line+shading+face, 5.));\n\n    return line;\n}\n\nfloat getHatchingSpecular(vec2 fragCoord)\n{\n    float ln = 1.;\n        ln*= pow(hatchingSpecular(fragCoord, 3.5, -.4, -1.4, 1.4, false), 50.5);\n        ln*= pow(hatchingSpecular(fragCoord, 3.5, .4, -1.4, 1.4, false), 50.5);\n    return 1.-ln;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = vec3(.8, .77, .7);\n\n    float shading = readDiffuse(fragCoord);\n    shading *= readShadow(fragCoord);\n    shading = shading*.7+.3*readAO(fragCoord);\n    shading = smoothstep(.3, 1., shading);\n\n    float contrast = 8.8;\n    float midpoint = .5;\n    shading = originalSigmoidContrast(shading, contrast, midpoint);\n    shading = saturate(shading);\n\tif(readDepth(fragCoord)>.9)\n        shading = 1.;\n    \n    col*=dithering(shading+smoothstep(.3, .9, readDepth(fragCoord)*.6)*.25, fragCoord);\n\n    col+=.05*dithering((smoothstep(.95,1.,shading)), fragCoord);\n    col+=.05*dithering((smoothstep(.97,1.,shading)), fragCoord);\n    col+=.05*dithering((smoothstep(.99,1.,shading)), fragCoord);\n    col*=.65+.25*shading;\n    col+=fbm(fragCoord*.5, 3)*.05;\n    col*= getHatching(fragCoord);\n    \n    col *= getOutline(fragCoord);\n    col *= getShadowEdge(fragCoord);\n    col *= getDottedShadow(fragCoord);\n    col *= .4 + .6*(readShadow(fragCoord)*.8+.2*readAO(fragCoord));\n\n    col *= dithering(pow(saturate(readSharpenAO(fragCoord, 2.)), 1.5), fragCoord);\n    vec3 albedo = readAlbedo(fragCoord);\n    col*= albedo;\n\n    float spec = readSharpenSpecular(fragCoord, 1.5)*readShadow(fragCoord);\n    if(spec>.1)\n    {\n    \tcol+=dithering(spec, fragCoord);\n    \tcol+=getHatchingSpecular(fragCoord);\n    }\n    col*=.8+.2*pow(1.-smoothstep(.0, 2., readDepth(fragCoord)), 3.);\n\n    col*= dithering(noise(fragCoord*.18+iTime*5.)+noise(fragCoord*.15-iTime*5.)+.8, fragCoord);\n    col+= 1.-dithering((1.-noise(fragCoord*.3+iTime*5.)*noise(fragCoord*.1-iTime*5.))+.8, fragCoord);\n\n    col *= vec3(.5+.5*smoothstep(.8, .5, readDepth(fragCoord)));\n\n    col = pow(col, vec3(.4545));\n    col = pow(col, vec3(.4545)); // intended one...\n    \n    fragColor = vec4(col, 1.);\n    \n#ifdef DEBUG_PASSES\n    if(iFrame==2)\n    fragColor.xyz = vec3(readDiffuse(fragCoord));\n    if(iFrame==3)\n    fragColor.xyz = vec3(readShadow(fragCoord));\n    if(iFrame==4)\n    fragColor.xyz = vec3(readSharpenSpecular(fragCoord, 1.5));\n    if(iFrame==5)\n    fragColor.xyz = vec3(readDepth(fragCoord));\n    if(iFrame==6)\n    fragColor.xyz = vec3(readAO(fragCoord));\n    if(iFrame==7)\n    fragColor.xyz = readAlbedo(fragCoord);\n    if(iFrame==8)\n    fragColor.xyz = readNormal(fragCoord)*.5+.5;\n    if(iFrame==9)\n    fragColor.xyz = vec3(getOutline(fragCoord));\n    if(iFrame==10)\n    fragColor.xyz = vec3(getShadowEdge(fragCoord));\n    if(iFrame==11)\n    fragColor.xyz = vec3(getDottedShadow(fragCoord));\n    if(iFrame==12)\n    fragColor.xyz = vec3(getHatching(fragCoord));\n    if(iFrame==13)\n    fragColor.xyz = vec3(getHatchingSpecular(fragCoord));\n#endif\n\n    fragColor.w = 1.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#pragma optimize(off)\n\n// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define ZERO min(0,iFrame)\n#define CHARM min(0,iFrame) /* about 6 sces faster compilation... */\n#define PI 3.14159265\n#define TAU (2.0*PI)\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n// Data Paker/Unpacker\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nuint packSnorm3x10(vec3 x) {\n    x = clamp(x,-1., 1.) * 511.;\n    uvec3 sig = uvec3(mix(vec3(0), vec3(1), greaterThanEqual(sign(x),vec3(0))));\n    uvec3 mag = uvec3(abs(x));\n    uvec3 r = sig.xyz << 9 | mag.xyz;\n    return r.x << 22 | r.y << 12 | r.z << 2;\n}\n\nvec3 unpackSnorm3x10(uint x) {\n    uvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n    uvec3 sig = r >> 9;\n    uvec3 mag = r & uvec3(0x1FF);\n    vec3 fsig = mix(vec3(-1), vec3(1), greaterThanEqual(sig, uvec3(1)));\n    vec3 fmag = vec3(mag) / 511.;\n    return fsig * fmag;\n}\n\nuint packSnorm4x8(vec4 x) {\n    x = clamp(x,-1.0, 1.0) * 127.0;\n    uvec4 sig = uvec4(mix(vec4(0), vec4(1), greaterThanEqual(sign(x),vec4(0))));\n    uvec4 mag = uvec4(abs(x));\n    uvec4 r = sig << 7 | mag;\n    return r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\n\nvec4 unpackSnorm4x8(uint x) {\n    uvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n    uvec4 sig = r >> 7;\n    uvec4 mag = r & uvec4(0x7F);\n    vec4 fsig = mix(vec4(-1), vec4(1), greaterThanEqual(sig,uvec4(1)));\n    vec4 fmag = vec4(mag) / 127.0;\n    return fsig * fmag;\n}\n#define pack(x) uintBitsToFloat(packSnorm3x10(x))\n#define unpack(x) unpackSnorm3x10(floatBitsToUint(x))\n#define pack4(x) uintBitsToFloat(packSnorm4x8(x))\n#define unpack4(x) unpackSnorm4x8(floatBitsToUint(x))\n\n// Random & Noise\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n\n//  1 out, 1 in...\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//  1 out, 2 in...\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 n, int rep){\n    float sum = 0.0;\n    float amp= 1.0;\n    for (int i = 0; i <rep; i++){\n        sum += noise(n) * amp;\n        n += n*4.0;\n        amp *= 0.25;\n    }\n    return sum;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Ray marching pass\n\n#define MIN_DIST 0.001\n#define MAX_DIST 20.0\n#define ITERATION 200\n#define MAT_VOID vec3(-1)\n#define MAT_SHOE_LACE vec3(0.1265, 0.9774, 0.8157)\n#define MAT_SKIN vec3(0.4743, 0.9774, 0.7076)\n#define MAT_PANTS vec3(0.5000, 1.0000, 0.6375)\n#define MAT_WALL vec3(0.7874, 0.6056, 0.6457)\n#define MAT_SHOE vec3(0.8900, 0.5034, 0.4153)\n#define MAT_TOPS vec3(0.4675, 0.7156, 0.8073)\n#define MAT_FLOOR vec3(0.6986, 0.8128, 0.8900)\n#define AMB_COL vec3(0.7874, 0.6056, 0.6457)\n\n//#define SHOW_SHOE\n\nvec3 ro = vec3(0), rd = vec3(0), col = vec3(0), camup, ldir = normalize(vec3(-.5, 1.,-.85));\n\n// SDF functions by iq and HG_SDF\n// https://iquilezles.org/articles/distfunctions\n// https://mercury.sexy/hg_sdf/\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n    R(p.xz, r.y);\n    R(p.yx, r.z);\n    R(p.zy, r.x);\n    return p;\n}\n\nfloat vmax(vec3 v){\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSphere(in vec3 p,in float r)\n{\n    return length(p)-r;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r)\n{\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\nfloat sdCapsule(vec3 p, float r, float c)\n{\n    return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdCappedTorus(vec3 p, vec2 r, float per)\n{\n    p.x = abs(p.x);\n    vec2 sc = vec2(sin(per),cos(per));\n    float k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n    return sqrt( dot(p,p) + r.x*r.x - 2.0*r.x*k ) - r.y;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return ((min(max(d.x,d.y),0.0) + length(max(d,0.0))))-0.0;\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\nfloat sdBox(vec3 p,vec3 b)\n{\n    vec3 d=abs(p)-b;\n    return length(max(d,vec3(0)))+vmax(min(d,vec3(0.0)));\n}\n\nfloat fOpUnion(in float a,in float b)\n{\n    return a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b)\n{\n    return a.x<b.x?a:b;\n}\n\nfloat fOpUnionStep(float a, float b, float r, float n)\n{\n    float s = r/(n+1.);\n    float u = b-r;\n    return min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2.0 * s)) - s)));\n}\n\nfloat fOpUnionSmooth(float a,float b,float r)\n{\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nvec4 v4OpUnionSmooth(vec4 a,vec4 b,float r)\n{\n    float h=clamp(0.5+0.5*(b.x-a.x)/r,0.0,1.0);\n    float res = mix(b.x,a.x,h)-r*h*(1.0-h);\n    return vec4(res, mix(b.yzw,a.yzw,h));\n}\n\nfloat fOpSubstraction(in float a,in float b)\n{\n    return max(-a, b);\n}\n\nfloat fOpSubstractionSmooth( float a,float b,float r)\n{\n    vec2 u = max(vec2(r + b,r + -a), vec2(0));\n    return min(-r, max (b, -a)) + length(u);\n}\n\nfloat pMirror(float x, float k){\n    return sqrt(x * x + k);\n}\n\nvoid pElongate(inout float p, in float h )\n{\n    p = p-clamp(p,-h,h);\n}\n\nvoid pRepPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*length(p);\n}\n\n// Shapes.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 sdFoot(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p), bsr=0.2500;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n    \n\tvec3 cpFoot = p;\n\t{\n\t\tvec3 q = cpFoot;\n#ifdef SHOW_SHOE\n        float patapata = -q.z*(sin(iTime*5.)*.5+.05)+cos(iTime*5.)*.5;\n#else\n        float patapata = 0.;\n#endif\n        q.yz*=mat2(cos(-q.z*1.25+patapata+vec4(0,11,33,0)));\n        cpFoot=q;\n\t}\n\tvec3 cpFoot_Main = cpFoot;\n\tcpFoot_Main.xyz += vec3(0.0000, 0.0000, 0.1273);\n\tpElongate(cpFoot_Main.y, 0.0125);\n\t{\n\t\tvec3 q=cpFoot_Main;\n        vec3 pq=q;pq.yz *= mat2(cos(.6 + vec4(0, 11, 33, 0)));\n        float ycl = smoothstep(.002,.2,q.y);\n        float zcl = 1.-smoothstep(-.2,.5,q.z);\n        float zcl2 = smoothstep(-.2,.0,q.z);\n        q.z+=fbm(vec2(pq.x*20.5,pq.y*80.), 1)*.05*ycl*zcl*zcl2;\n        cpFoot_Main=q;\n\t}\n\n    // Shoe\n\td = fOpUnion(sdEllipsoid(rot(cpFoot_Main+vec3(-0.0005, 0.0274, 0.1042), vec3(0.0818, -0.6861, 0.0566)), vec3(0.1102, 0.1233, 0.1214)), d);\n\td = fOpUnionSmooth(sdEllipsoid(rot(cpFoot_Main+vec3(0.0028, -0.0093, -0.1258), vec3(-0.0291, -0.2744, -0.0364)), vec3(0.0870, 0.2295, 0.0880)), d, 0.1438);\n\td = fOpSubstractionSmooth(sdBox(cpFoot_Main+vec3(0.0000, 0.1085, 0.0000), vec3(0.1676, 0.1089, 0.2519)), d, 0.0080);\n\td = fOpSubstractionSmooth(sdBox(cpFoot+vec3(0.0000, -0.194, 0.0019), vec3(0.1676, 0.0551, 0.1171)), d, 0.0100);\n\td = fOpSubstraction(sdBox(rot(cpFoot+vec3(0.0000, 0.0171, 0.1521), vec3(-1.4413, 0.0000, 0.0000)), vec3(0.1676, 0.0912, 0.0116)), d);\n\td = fOpUnionSmooth(sdCappedTorus(cpFoot+vec3(0.0028, -0.1578, 0.0014), vec2(0.0519, 0.0264), 3.1413), d, 0.0100);\n\tres = v4OpUnion(vec4(d,vec3(0.8900, 0.5034, 0.4153)), res);\n\td = MAX_DIST;\n\t// Shoe lace\n\td = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0579, 0.1827), vec3(1.5708, 0.0000, 0.0000)), vec2(0.0636, 0.0064), 0.6283), d);\n\td = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.1001, 0.0608), vec3(2.2401, -0.3407, 0.2843)), vec2(0.0636, 0.0064), 0.6283), d);\n\td = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0639, 0.1321), vec3(1.7335, 0.4446, -0.0513)), vec2(0.0636, 0.0064), 0.6283), d);\n\td = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.1001, 0.0608), vec3(2.2463, 0.3180, -0.2669)), vec2(0.0636, 0.0064), 0.6283), d);\n\td = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0639, 0.1321), vec3(1.7334, -0.4468, 0.0515)), vec2(0.0636, 0.0064), 0.6283), d);\n\tres = v4OpUnion(vec4(d,vec3(0.1265, 0.9774, 0.8157)), res);\n\treturn res;\n}\n\nvec4 sdHand(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, 0.0000, 0.1000)), bsr=0.1500;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\n\td = fOpUnion(sdEllipsoid(rot(p+vec3(0.0010, -0.0040, 0.0686), vec3(-0.0288, 0.0000, 0.0000)), vec3(0.0688, 0.0519, 0.0687)), d);\n\td = fOpUnion(sdEllipsoid(rot(p+vec3(0.0351, 0.0504, 0.2394), vec3(0.6982, -0.1114, -0.0032)), vec3(0.0219, 0.0219, 0.0217)), d);\n\td = fOpUnion(sdEllipsoid(rot(p+vec3(-0.0359, 0.0375, 0.2293), vec3(0.6982, 0.2210, -0.0032)), vec3(0.0219, 0.0219, 0.0217)), d);\n\td = fOpUnion(sdEllipsoid(rot(p+vec3(-0.0964, 0.0273, 0.1847), vec3(0.6982, 0.4986, -0.0032)), vec3(0.0170, 0.0170, 0.0168)), d);\n\td = fOpUnionSmooth(sdEllipsoid(rot(p+vec3(0.0264, 0.0006, 0.1607), vec3(0.3540, -0.1114, -0.0032)), vec3(0.0156, 0.0156, 0.0311)), d, 0.0318);\n\td = fOpUnionSmooth(sdEllipsoid(rot(p+vec3(-0.0176, -0.0145, 0.1488), vec3(0.3540, 0.2210, -0.0032)), vec3(0.0156, 0.0156, 0.0311)), d, 0.0318);\n\td = fOpUnionSmooth(sdEllipsoid(rot(p+vec3(-0.0657, -0.0072, 0.1285), vec3(0.3540, 0.4986, -0.0032)), vec3(0.0121, 0.0121, 0.0241)), d, 0.0318);\n\td = fOpUnionSmooth(sdEllipsoid(rot(p+vec3(0.0732, 0.0290, 0.0942), vec3(0.5542, -0.2213, 0.1170)), vec3(0.0176, 0.0176, 0.0361)), d, 0.0250);\n\td = fOpUnionSmooth(sdEllipsoid(rot(p+vec3(0.0966, 0.0611, 0.1302), vec3(0.5976, 0.0302, 0.2065)), vec3(0.0241, 0.0241, 0.0264)), d, 0.0250);\n\td = fOpUnionSmooth(sdEllipsoid(rot(p+vec3(0.0320, 0.0270, 0.2116), vec3(0.6982, -0.1114, -0.0032)), vec3(0.0166, 0.0166, 0.0277)), d, 0.0223);\n\td = fOpUnionSmooth(sdEllipsoid(rot(p+vec3(-0.0297, 0.0141, 0.2021), vec3(0.6982, 0.2210, -0.0032)), vec3(0.0166, 0.0166, 0.0277)), d, 0.0223);\n\td = fOpUnionSmooth(sdEllipsoid(rot(p+vec3(-0.0865, 0.0100, 0.1666), vec3(0.6982, 0.4986, -0.0032)), vec3(0.0128, 0.0128, 0.0214)), d, 0.0223);\n\tres = v4OpUnion(vec4(d,vec3(0.4743, 0.9774, 0.7076)), res);\n\treturn res;\n}\n\nvec4 sdHead(vec3 p){\n\treturn vec4(sdSphere(p+vec3(0.0000, -0.1000, 0.0000), 0.0646), vec3(0.4743, 0.9774, 0.7076));\n}\n\nvec4 sdHip(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p), bsr=0.5000;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n    \n\tvec3 cpHip = p;\n\tvec3 cpHip_mir0_Pos = max(vec3(0), sign(cpHip));\n\tvec3 cpHip_mir0_Neg = max(vec3(0),-sign(cpHip));\n\tcpHip.x = pMirror(cpHip.x, 0.0050);\n\t{\n\t\tvec3 q=cpHip;\n        vec3 pq=p;\n        pq.xy*=mat2(cos(1.9*vec4(0,5,8,0)));\n        q.y+=cos(pq.y*5.)*.1*sin(p.x*20.)*.1;\n        q.x+=sin(p.y*5.)*.25*cos(pq.x*15.)*.1;\n        cpHip=q;\n\t}\n\n\td = fOpUnion(sdEllipsoid(rot(cpHip+vec3(-0.1456, -0.1908, 0.0040), vec3(0.0000, 0.0000, 0.4597)), vec3(0.1544, 0.1207, 0.1090)), d);\n\tres = v4OpUnion(vec4(d,vec3(0.5000, 1.0000, 0.6375)), res);\n\treturn res;\n}\n\nvec4 sdLowerArm(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, 0.1200, 0.0000)), bsr=0.2500;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\tvec3 cpLowerArm = p;\n\n\td = fOpUnion(sdEllipsoid(cpLowerArm+vec3(0, 0.1393, 0), vec3(0.1054, 0.2352, 0.1054)), d);\n\td = fOpUnionSmooth(sdEllipsoid(rot(cpLowerArm, vec3(0.1191, 1.1406, 0.9428)), vec3(0.1168, 0.1070, 0.1070)), d, 0.0500);\n\tres = v4OpUnion(vec4(d,vec3(0.4675, 0.7156, 0.8073)), res);\n\treturn res;\n}\n\nvec4 sdLowerLeg(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, 0.1500, 0.0000)), bsr=0.2500;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\tvec3 cpLowerLeg = p;\n\tvec3 cpLowerLeg_mir0_Pos = max(vec3(0), sign(cpLowerLeg));\n\tvec3 cpLowerLeg_mir0_Neg = max(vec3(0),-sign(cpLowerLeg));\n\tcpLowerLeg.x = pMirror(cpLowerLeg.x, 0.0000);\n\t{\n\t\tvec3 q=cpLowerLeg;\n        vec3 pq=p;pq.yz *= mat2(cos(-1.1 + vec4(0, 11, 33, 0)));\n        q.x+=sin(pq.y*50.)*.01;\n        cpLowerLeg=q;\n\t}\n\td = fOpUnion(sdEllipsoid(rot(cpLowerLeg+vec3(0.0240, 0.1194, -0.0009), vec3(0.0000, 0.0004, -0.0041)), vec3(0.1450, 0.2824, 0.1450)), d);\n\td = fOpUnionSmooth(sdCappedTorus(rot(cpLowerLeg+vec3(0.0164, 0.0039, -0.0422), vec3(0.1978, 0.0000, -3.1416)), vec2(0.1025, 0.0102), 3.1413), d, 0.0200);\n\td = fOpUnionSmooth(sdCappedTorus(rot(cpLowerLeg+vec3(0.0088, 0.0352, -0.0548), vec3(0.5139, -0.0273, 0.0000)), vec2(0.0913, 0.0114), 3.1413), d, 0.0200);\n\td = fOpUnionSmooth(sdCappedTorus(rot(cpLowerLeg+vec3(0.0129, 0.0511, -0.0293), vec3(0.0638, -0.0185, 0.0000)), vec2(0.1024, 0.0096), 3.1413), d, 0.0200);\n\td = fOpUnionSmooth(sdConeSection(rot(cpLowerLeg+vec3(0.0000, 0.3047, 0.0000), vec3(0.0000, 0.0008, -0.0040)), 0.1353, 0.1402, 0.0670), d, 0.0601);\n\tres = v4OpUnion(vec4(d,vec3(0.5000, 1.0000, 0.6375)), res);\n\treturn res;\n}\n\nvec4 sdSodeguchi(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p), bsr=0.0750;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\tvec3 cpSodeguchi = p;\n\n\tvec3 cpSodeguchi_Mizo = cpSodeguchi;\n\tpRepPolar(cpSodeguchi_Mizo.xz, 19.0000);\n\n\td = fOpUnion(sdTorus(cpSodeguchi, vec2(0.0496, 0.0310)), d);\n\td = fOpUnionSmooth(sdCappedCylinder(cpSodeguchi, vec2(0.0370, 0.0370)), d, 0.0100);\n\td = fOpUnionSmooth(sdCapsule(rot(cpSodeguchi_Mizo+vec3(-0.0380, 0.0266, 0.0000), vec3(0.1747, 0.0000, 0.0000)), 0.0020, 0.0543), d, 0.0010);\n\td = fOpUnionSmooth(sdTorus(cpSodeguchi+vec3(0.0000, 0.0852, 0.0000), vec2(0.0393, 0.0045)), d, 0.0250);\n\tres = v4OpUnion(vec4(d,vec3(0.4675, 0.7156, 0.8073)), res);\n\treturn res;\n}\n\nvec4 sdTorso(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, -0.3500, 0.0000)), bsr=0.4250;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n    \n\tvec3 cpTorso = p;\n\t{\n\t\tvec3 q=cpTorso;vec3 pq=p;\n        pq.xy*=mat2(cos(-.25+vec4(0,11,33,0)));\n        q.z+=fbm(vec2(pq.z*1.5,pq.y*10.+sin(pq.z*13.)*.25), 1)*.125*(1.-smoothstep(0.,1.,q.y));\n        q.x+=fbm(vec2(pq.x*1.5,pq.y*10.+sin(pq.x*13.)*.25), 1)*.075*(1.-smoothstep(0.,1.,q.y));\n        cpTorso=q;\n\t}\n\tvec3 cpTorso_Elongate = cpTorso;\n\tcpTorso_Elongate.xyz += vec3(-0.0577, -0.0147, -0.0036);\n\tcpTorso_Elongate.xyz = rot(cpTorso_Elongate, vec3(0.0000, 0.0000, 0.2252));\n\tpElongate(cpTorso_Elongate.x, 0.1000);\n \n\td = fOpUnion(sdEllipsoid(rot(cpTorso+vec3(-0.0501, -0.0879, -0.0794), vec3(0.2961, 0.0000, 0.0000)), vec3(0.2447, 0.1408, 0.1837)), d);\n\td = fOpUnionSmooth(sdTorus(rot(cpTorso_Elongate+vec3(-0.0406, -0.0183, 0.0804), vec3(0.2204, -0.0303, 0.0000)), vec2(0.1647, 0.0776)), d, 0.1720);\n\td = fOpUnionSmooth(sdEllipsoid(rot(cpTorso+vec3(0.0000, -0.5773, -0.0088), vec3(0.8164, 0.0000, 0.0000)), vec3(0.2890, 0.2029, 0.1701)), d, 0.4600);\n\td = fOpUnionSmooth(sdTorus(rot(cpTorso+vec3(-0.0417, -0.2882, -0.0229), vec3(0.3365, 1.4599, -0.4932)), vec2(0.1800, 0.0540)), d, 0.1100);\n\td = fOpUnionSmooth(sdTorus(rot(cpTorso+vec3(-0.0736, -0.4293, -0.0080), vec3(-0.4843, 1.5645, -0.3815)), vec2(0.2008, 0.0301)), d, 0.1120);\n\td = fOpUnionSmooth(sdTorus(rot(cpTorso+vec3(0.0594, 0.0184, -0.0297), vec3(-0.2545, 1.4571, 0.1212)), vec2(0.2037, 0.0458)), d, 0.1480);\n\tres = v4OpUnion(vec4(d,vec3(0.4675, 0.7156, 0.8073)), res);\n\treturn res;\n}\n\nvec4 sdUpperArm(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, 0.1600, 0.0000)), bsr=0.2500;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\n\td = fOpUnion(sdEllipsoid(p+vec3(0.0000, 0.2187, 0.0000), vec3(0.1173, 0.2786, 0.1173)), d);\n\td = fOpUnionSmooth(sdEllipsoid(rot(p+vec3(0.0814, 0.0000, 0.0000), vec3(-3.3018, -2.1277, 1.2590)), vec3(0.1273, 0.1165, 0.1165)), d, 0.0500);\n\tres = v4OpUnion(vec4(d,vec3(0.4675, 0.7156, 0.8073)), res);\n\treturn res;\n}\n\nvec4 sdUpperLeg(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, 0.1500, 0.0000)), bsr=0.2500;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n    \n\tvec3 cpUpperLeg = p;\n\tvec3 cpUpperLeg_mir0_Pos = max(vec3(0), sign(cpUpperLeg));\n\tvec3 cpUpperLeg_mir0_Neg = max(vec3(0),-sign(cpUpperLeg));\n\tcpUpperLeg.x = pMirror(cpUpperLeg.x, 0.0000);\n\t{\n\t\tvec3 q=cpUpperLeg;\n        vec3 pq=p;pq.yz *= mat2(cos(-1.1 + vec4(0, 11, 33, 0)));\n        q.x+=sin(pq.y*50.)*.01;\n        cpUpperLeg=q;\n\t}\n\n\td = fOpUnion(sdEllipsoid(cpUpperLeg+vec3(-0.0007, 0.0001, -0.0010), vec3(0.1475, 0.1477, 0.1408)), d);\n\td = fOpUnionSmooth(sdEllipsoid(p+vec3(0.1774, -0.0475, 0.0664), vec3(0.0716, 0.0717, 0.0684)), d, 0.0421);\n\td = fOpUnionSmooth(sdEllipsoid(cpUpperLeg+vec3(-0.0007, 0.2607, 0.0151), vec3(0.1540, 0.2725, 0.1543)), d, 0.1201);\n\tres = v4OpUnion(vec4(d,vec3(0.5000, 1.0000, 0.6375)), res);\n\treturn res;\n}\n\nvec4 sdMan_Walking(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, -0.9400, 0.0000)), bsr=0.7617;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\tvec3 cpMan_Root = p;\n\n\tvec3 cpArm_L = cpMan_Root;\n\tcpArm_L.xyz += vec3(-0.2285, -1.7683, 0.0147);\n\tcpArm_L.xyz = rot(cpArm_L, vec3(-0.0259, -0.4911, -0.5401));\n\n\tvec3 cpArm_R = cpMan_Root;\n\tcpArm_R.xyz += vec3(0.2970, -1.7732, -0.0896);\n\tcpArm_R.xyz = rot(cpArm_R, vec3(0.8591, 0.0411, 0.1902));\n\t{\n\t\tvec3 q = cpArm_R;\n        q.x*=-1.;\n        cpArm_R=q;\n\t}\n\tvec3 cpLeg_L = cpMan_Root;\n\tcpLeg_L.xyz += vec3(-0.1887, -1.0209, 0.0000);\n\tcpLeg_L.xyz = rot(cpLeg_L, vec3(0.2961, -0.0255, 0.0072));\n\t\n\tvec3 cpLeg_R = cpMan_Root;\n\tcpLeg_R.xyz += vec3(0.1440, -1.0291, 0.0000);\n\tcpLeg_R.xyz = rot(cpLeg_R, vec3(-0.4479, -0.0237, -0.0120));\n\t{\n\t\tvec3 q = cpLeg_R;\n        q.x*=-1.;\n        cpLeg_R=q;\n\t}\n\tvec3 cp003_004 = cpArm_R;\n\t{\n\t\tvec3 q=cp003_004;\n        vec3 pq=p;\n        pq.yz *= mat2(cos(-1.1 + vec4(0, 11, 33, 0)));\n        q.x+=sin(pq.y*30.)*.01;\n        cp003_004=q;\n\t}\n    {\n\t\tvec3 q=cp003_004;\n        vec3 pq=p;\n        pq.xy *= mat2(cos(noise(pq.xy*vec2(5,1))*PI*.3+vec4(0,11,33,0)));\n        float size = 12.;\n        float strength = .1;\n        q.x+=(fbm(vec2(pq.x*size,pq.y*size), 1)-.5)*strength*(smoothstep(0.,-1.,q.y));\n        q.z+=(fbm(vec2(pq.z*size,pq.y*size), 1)-.5)*strength*(smoothstep(0.,-1.,q.y));\n        cp003_004=q;\n\t}\n\tvec3 cp003 = cpArm_L;\n\t{\n\t\tvec3 q=cp003;\n        vec3 pq=p;\n        pq.yz *= mat2(cos(-1.1 + vec4(0, 11, 33, 0)));\n        q.x+=sin(pq.y*50.)*.01;\n        cp003=q;\n\t}\n    {\n\t\tvec3 q=cp003;\n        vec3 pq=p;\n        pq.xy *= mat2(cos(noise(pq.xy*vec2(2,1))*PI*.3+vec4(0,11,33,0)));\n        float size = 12.;\n        float strength = .1;\n        q.x+=(fbm(vec2(pq.x*size,pq.y*size), 1)-.5)*strength*(smoothstep(0.,-1.,q.y));\n        q.z+=(fbm(vec2(pq.z*size,pq.y*size), 1)-.5)*strength*(smoothstep(0.,-1.,q.y));\n        cp003=q;\n\t}\n#ifndef SHOW_SHOE\n\tres = v4OpUnionSmooth(sdUpperLeg(cpLeg_L), res, 0.0100);\n\tres = v4OpUnionSmooth(sdUpperLeg(cpLeg_R), res, 0.0100);\n\tres = v4OpUnion(sdHead(rot(cpMan_Root+vec3(0.0000, -1.9264, 0.0946), vec3(0.3161, 0.0000, 0.0000))), res);\n\tres = v4OpUnionSmooth(sdHip(rot(cpMan_Root+vec3(-0.0025, -0.8238, -0.1085), vec3(0.0000, 0.2785, 0.0000))), res, 0.0500);\n\tres = v4OpUnionSmooth(sdLowerLeg(rot(cpLeg_L+vec3(0.0000, 0.4296, 0.0000), vec3(0.3358, 0.0429, 0.0051))), res, 0.0500);\n\tres = v4OpUnionSmooth(sdLowerLeg(rot(cpLeg_R+vec3(0.0000, 0.4296, 0.0000), vec3(0.3358, 0.0429, 0.0051))), res, 0.0500);\n    const float fY = 1.0400;\n#else\n    const float fY = 1.0350;\n#endif\n\tres = v4OpUnion(sdFoot(rot(cpLeg_R+vec3(0.0122, fY, -0.2127), vec3(0.3358, 0.0429, 0.0051))), res);\n#ifndef SHOW_SHOE\n\tres = v4OpUnion(sdFoot(rot(cpLeg_L+vec3(0.0122, 1.0400, -0.2127), vec3(0.3713, 0.0430, 0.0045))), res);\n\tres = v4OpUnionSmooth(sdSodeguchi(rot(cpArm_L+vec3(0.0494, 0.6329, 0.1930), vec3(-0.6206, 0.0266, 0.3167))), res, 0.0050);\n\tres = v4OpUnionSmooth(sdSodeguchi(rot(cpArm_R+vec3(0.0184, 0.6838, 0.1199), vec3(-0.7478, -0.0227, 0.2680))), res, 0.0050);\n\tres = v4OpUnionSmooth(sdTorso(rot(cpMan_Root+vec3(0.0000, -1.1769, -0.0665), vec3(0.0574, 0.0000, 0.0000))), res, 0.0200);\n\tres = v4OpUnionSmooth(sdUpperArm(cp003), res, 0.0750);\n\tres = v4OpUnionSmooth(sdUpperArm(cp003_004), res, 0.0500);\n\tres = v4OpUnionSmooth(sdLowerArm(rot(cp003+vec3(0.0000, 0.3702, 0.0000), vec3(-0.6301, -0.2742, -0.1053))), res, 0.0400);\n\tres = v4OpUnionSmooth(sdLowerArm(rot(cp003_004+vec3(0.0000, 0.3702, 0.0000), vec3(-0.3764, -0.1114, -0.0029))), res, 0.0250);\n\tres = v4OpUnion(sdHand(rot(cpArm_L+vec3(0.0702, 0.7357, 0.2618), vec3(0.9016, 0.1943, 0.6602))), res);\n\tres = v4OpUnion(sdHand(rot(cpArm_R+vec3(0.0368, 0.7749, 0.1977), vec3(1.5493, 0.9155, 0.6787))), res);\n#endif\n\treturn res;\n}\n\nvec4 sdScene(vec3 p)\n{\n    float d = MAX_DIST;\n    vec4 res = vec4(MAX_DIST, MAT_VOID);\n    \n    vec4 grnd = res;\n    if(length(p.xz)<3.) grnd = vec4(p.y+.03, vec3(0.6986, 0.8128, 0.8900)); \n\tres = v4OpUnion(sdMan_Walking(p-vec3(0,0,.025)), grnd);\n    \n    return res;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 intersect()\n{\n    float d = MIN_DIST;\n    vec3  m = MAT_VOID;\n\n    for (int i = ZERO; i < ITERATION+CHARM; i++)\n    {\n        vec3 p = ro + d * rd;\n        vec4 res = sdScene(p);\n        res.x*=.5;\n        m = res.yzw;\n        if (abs(res.x) < MIN_DIST)break;\n        d += res.x;\n        if (d >= MAX_DIST) return vec4(MAX_DIST, MAT_VOID);\n    }\n    if(d>MAX_DIST) return vec4(MAX_DIST, MAT_VOID);\n    return vec4(d,m);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 normal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4+CHARM; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n}\n\n// iq's soft shadow\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat shadow(vec3 o)\n{\n    float mint=0.01;\n    float maxt=30.;\n    float k = 64.;\n    float res = 1.;\n    float ph = 1e20;\n    float t=mint;\n    for( int i=ZERO; i < 60+CHARM; i++)\n    {\n        float h = sdScene(o + ldir*t).x;\n        if(abs(h)<MIN_DIST) return 0.;\n\n        res = min( res, k*h/t);\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y));\n        ph = h;\n        t += h;\n\n        if(t >= maxt) break;\n    }\n    return res;//smoothstep(.5, .51, res);\n}\n\n// \"Hemispherical SDF AO\" by XT95:\n// https://www.shadertoy.com/view/4sdGWN\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 randomSphereDir(vec2 rnd)\n{\n    float s = rnd.x*PI*2.;\n    float t = rnd.y*2.-1.;\n    return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n    vec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n    return v * sign(dot(v, dir));\n}\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n    const int nbIte = 12;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n\n    float ao = 0.0;\n\n    for( int i=ZERO; i<nbIte+CHARM; i++ )\n    {\n        float l = hash11(float(i))*maxDist;\n        vec3 aord = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal// for self occlusion problems!\n\n        ao += (l - max(sdScene( p + aord ).x,0.)) / maxDist * falloff;\n    }\n\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat specular(vec3 p, vec3 n, vec3 ld, float power)\n{\n    vec3 to_eye = normalize(p - ro);\n    vec3 reflect_light = normalize(reflect(ld, n));\n    return pow(max(dot(to_eye, reflect_light), 0.), power);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat diffuse = 0.;\nfloat spec = 0.;\nfloat shdw = 1.;\nfloat ao = 1.;\nfloat depth = 0.;\nvec3 albedo = vec3(0);\nvec3 nml = vec3(0);\n\nvoid render()\n{\n    vec4 hit = intersect();\n    vec3 p = ro + hit.x * rd;\n    albedo = hit.yzw;\n    \n    if (hit.x>=MAX_DIST)\n    {\n        nml = vec3(0);\n        albedo = AMB_COL;\n        spec = 0.;\n        depth = 1.;\n        diffuse = 0.;\n        return;\n    }\n\n    vec3 n = normal(p);\n    vec3 offset = n * .005;\n    \n    // Camera localized normal\n    vec3 up = camup;\n    vec3 side = cross(rd, up);\n    nml.x = dot(n+offset,  side);\n    nml.y = dot(n+offset,  up);\n    nml.z = dot(n+offset,  -rd);\n    \n    diffuse = dot(n+offset,  ldir)*.5+.5; // Half-Lanbert\n    shdw = shadow(p+offset);\n\n    ao = ambientOcclusion(p+n*0.01, n, .5, 2.);\n    ao += ambientOcclusion(p+n*0.01, n, .1, 2.);\n    ao = smoothstep(0., 2., ao);\n    ao = pow(ao, .25);\n\n    depth = distance(ro, p)/MAX_DIST;\n\n    const float thresh = .01;\n    if(!(distance(albedo, MAT_SHOE) < thresh) && !(distance(albedo, MAT_FLOOR) < thresh)) return;\n\n    if(distance(albedo, MAT_SHOE) < thresh)\n    {\n        // Shoe\n        spec = specular(p+offset, n, ldir, 10.);\n    }\n\n    {\n        // Floor\n        vec2 uv = vec2(p.z, p.y);\n\n        vec3 q = p;\n\n        uv.x = q.x;\n        uv.y = q.z;\n        uv.x *= 2.;\n        uv*=1.5;\n\n        int offset = int(uv.x)%2;\n        vec2 ratio = vec2(1,4);\n        float gridGap = 0.001;\n        if(offset==0)uv.y+=ratio.y*.5;\n\n        vec2 id = floor(uv/ratio);\n        uv = mod(uv, ratio)-ratio*.5;\n\n        float d =sdBox(uv, ratio*.5-gridGap);\n        if(noise(uv*5.*id)<.75)\n            diffuse *= step(.1, 1.0 - exp(-8.0*abs(d)));\n        if(noise(uv*90.)<.75)\n        {\n            uv.y+=fbm(uv*16., 2)*.025;\n            uv *= mat2(cos(noise(uv*vec2(5,1)+id)*PI*.3+vec4(0,11,33,0)));\n            diffuse *= smoothstep(.4, .5, abs(sin(uv.x*40.)));\n        }\n\n    }\n}\n\n// \"camera\": create camera vectors.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid camera(vec2 uv)\n{\n#ifdef SHOW_SHOE\n    const float pY = .5;\n    const float cL = 2.;\n    const vec3 forcus = vec3(-.15,.1,-.34);\n    const float fov = .08;\n#else\n    const float pY = 1.;\n    const float cL = 9.;\n    const vec3 forcus = vec3(0,1,0);\n    const float fov = .125;\n#endif\n    vec3 up = vec3(0,1,0);\n    vec3 pos = vec3(0,pY,0);\n    pos.xz = vec2(sin(iTime),cos(iTime))*cL;\n    if(iMouse.z>.5)\n        pos.xz = vec2(sin(iMouse.x/iResolution.x*TAU),cos(iMouse.x/iResolution.x*TAU))*cL;\n    vec3 dir = normalize(forcus-pos);\n    vec3 target = pos-dir;\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\tcamup = cv;\n    mat3 camMat = mat3(cu, cv, cw);\n    rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n    ro = pos;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv*2.-1.);\n    uv.x *= iResolution.x / iResolution.y;\n\n    camera(uv);\n    render();\n\n    vec3 spec_diffuse_ao = vec3(spec, diffuse, ao)*2.-1.;\n    \n    fragColor = vec4(\n        pack4(vec4(nml, shdw)),\n        pack(albedo),\n        pack(spec_diffuse_ao),\n        depth\n    );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}