{
    "Shader": {
        "info": {
            "date": "1487177133",
            "description": "Tokyo Demo Fest 2017 compo entry.  By cxw/Incline",
            "flags": 0,
            "hasliked": 0,
            "id": "XdXcRN",
            "likes": 0,
            "name": "ncl01: Road Trip",
            "published": 3,
            "tags": [
                "compo",
                "tdf2017"
            ],
            "usePreview": 0,
            "username": "cxw",
            "viewed": 608
        },
        "renderpass": [
            {
                "code": "//tdf17.frag by cxw/incline.  CC-BY-SA 3.0\n//ncl01: Road Trip.  Released at Tokyo Demo Fest 2017.\n//This file is generated from tdf17.frag.in using perlpp.  DO NOT EDIT.\n//Use https://github.com/cxw42/perlpp/, branch 'defines'.\n\n\n\n// Reminder: OpenGL-style coord system: +X right, +Y up, +Z toward viewer\n// CONFIG CONSTANTS STRUCTS GLOBALS ///////////////////\n// {{{1\n\n\n#define LOADING_FREQ (0.2)\n\n#define S_SINE_FREQ (0.02380952380952380952380952380952)\n    // 1/42.  sine letter frequency in cycles per X unit.\n#define S_SINE_GROUP_FREQ (0.03125)\n    // 1/32.  sine group frequency.  If > S_SINE_FREQ, sine gradually\n    // shifts right on screen.\n#define CYL_RADIUS (15.0)\n    // radius of the cylinder for CYL and later parts\n#define TUNNEL_ACCEL (17.0)\n    // Acceleration during TUNNEL, in x units per sec^2\n#define CUBE_FADEIN_TIME (3.0)\n    //fadein in seconds\n\n#define TWOSIDED_RATE (0.3)\n    // how fast you go back and forth\n\n#define PI (3.1415926535897932384626433832795028841971)\n    // from memory :)\n#define PI_OVER_2 (1.5707963267948966192313216916398)\n#define PI_OVER_4 (0.78539816339744830961566084581988)\n#define THREE_PI_OVER_4 (2.3561944901923449288469825374596)\n#define TWO_PI (6.283185307179586)\n#define ONE_OVER_TWO_PI (0.15915494309644431437107064141535)\n    // not from memory :) :)\n\n#define TEE_ZERO (0.001)\n#define TEE_ONE (99999999999999999999.0)\n    // +Inf => 1.0/0.0 gives \"divide by zero during constant folding\" error\n\n#define LTR_Z_THICKNESS (1.0)\n    // in voxels\n#define EPS (0.000001)\n    // Arbitrary choice\n\n#define MAX_VOXEL_STEPS (60)\n    // Empirical - gives a nice disappearing effect at the edges on my\n    // test system\n#define MAX_DIST (100.0)\n\n// xport config\n#define XP_GAIN_HZ (3.0)\n\n#define XP_SHINE_LOW (6.0)\n#define XP_SHINE_HIGH (32.0)\n#define XP_SHINE_AIM (24.0)\n    // what it settles down to\n#define XP_SHINE_HZ (5.5)\n\n// Sinusoids across the u axis (horz)\n\n#define XP_H0_PER_U (30.00000000000000000000)\n    // cycles per screen width (u coordinate 0..1)\n#define XP_H0_PHASE (0.00000000000000000000)\n    // initial phase\n#define XP_H0_PHASE_PER_SEC (1.36590984938686665906)\n    // how much the phase of the sinusoid changes per second\n\n#define XP_H1_PER_U (10.00000000000000000000)\n    // cycles per screen width (u coordinate 0..1)\n#define XP_H1_PHASE (1.00000000000000000000)\n    // initial phase\n#define XP_H1_PHASE_PER_SEC (0.10000000000000000555)\n    // how much the phase of the sinusoid changes per second\n\n#define XP_H2_PER_U (5.00000000000000000000)\n    // cycles per screen width (u coordinate 0..1)\n#define XP_H2_PHASE (0.00000000000000000000)\n    // initial phase\n#define XP_H2_PHASE_PER_SEC (1.00000000000000000000)\n    // how much the phase of the sinusoid changes per second\n\n\n// }}}1\n\n// CHARSET FOR WORLD-COORDINATE LETTERS ///////////////\n// {{{1\n/*\n9    00000\n8  1   2   3\n7  1   2   3\n6  1   2   3\n5    44444\n4  5       6\n3  5       6\n2 858      6\n1 88877777\n0 888\n   0 12345 6\n(lowercase x, dot, and bang are handled separately)\n*/\n\n// Character storage\n#define NSEGS (9)\nvec4 SEG_SHAPES[NSEGS];\n    // All polys will be quads in the X-Y plane, Z=0.\n    // All quad edges are parallel to the X or Y axis.\n    // These quads are encoded in a vec4: (.x,.y) is the LL corner and\n    // (.z,.w) is the UR corner (coords (x,y)).\n\nvec4 SEG_VOXELS[NSEGS];\n    // Same deal, but voxel offsets, start->last+1\n\n// Grid parameters - 2D\n#define GRID_CHARHT (10.0)\n#define GRID_CHARWD (6.0)\n    // Size of each character\n#define GRID_PITCH (7.0)\n    //each char takes up this much space.  Margin is added on the right\n    //and is GRID_PITCH-GRID_CHARWD wide.\n#define GRID_PITCH_RECIP (0.14285714285714285714285714285714)\n    // avoid a division\n#define GRID_VPITCH (12.0)\n    // margin is added on top\n#define THICKNESS (1.0)\n    // how thick each stroke is\n\n#define GRID_XSHIFT (GRID_PITCH * 0.5)\n    // + pitch/0.5 because letters were snapping into\n    // existence at the right side of the screen.\n\n// Grid parameters - voxels.  Twice the size.\n#define VGRID_CHARHT (GRID_CHARHT*2.0)\n#define VGRID_CHARWD (GRID_CHARWD*2.0)\n#define VGRID_PITCH (GRID_PITCH*2.0)\n#define VGRID_PITCH_RECIP (GRID_PITCH_RECIP*0.5)\n#define VGRID_VPITCH (GRID_VPITCH*2.0)\n\n// For upright chars, each char (X,Y) goes from (PITCH*ofs, 0)->(.+WD,HT).\n\nvoid init_charset()\n{\n    float halft = THICKNESS*0.5;\n    float halfht = GRID_CHARHT * 0.5;\n\n    SEG_SHAPES[0] = vec4(THICKNESS, GRID_CHARHT - THICKNESS, GRID_CHARWD-THICKNESS, GRID_CHARHT);\n    SEG_SHAPES[1] = vec4(0.0,                   halfht, THICKNESS,             GRID_CHARHT - halft);\n    SEG_SHAPES[2] = vec4(GRID_CHARWD*0.5-halft, halfht, GRID_CHARWD*0.5+halft, GRID_CHARHT - halft);\n    SEG_SHAPES[3] = vec4(GRID_CHARWD-THICKNESS, halfht, GRID_CHARWD,           GRID_CHARHT - halft);\n    SEG_SHAPES[4] = vec4(THICKNESS, halfht - halft, GRID_CHARWD-THICKNESS, halfht + halft);\n    SEG_SHAPES[5] = vec4(0.0,                   halft,    THICKNESS,             halfht );\n    SEG_SHAPES[6] = vec4(GRID_CHARWD-THICKNESS, halft,    GRID_CHARWD,           halfht );\n    SEG_SHAPES[7] = vec4(THICKNESS, 0, GRID_CHARWD-THICKNESS, THICKNESS);\n    SEG_SHAPES[8] = vec4(0.0, 0.0, THICKNESS, THICKNESS); //dot\n\n    // Voxel grid #1 - not currently in use\n    //Grid_Origin = vec3(GRID_XSHIFT, 0, 0);\n    //Grid_Spacings = vec3(1.0);\n    //Grid_Spacings_Inv = vec3(1.0)/Grid_Spacings;\n\n    // TODO rewrite in terms of #defines.\n    // Z, W are +1 so can use IsPointInRectXY, which does not include the\n    // UR corner in the poly.\n    // Size has been doubled, so we can use multiples of 0.5.\n    SEG_VOXELS[0] = vec4(1.0, 9.0, 5.0,10.0)*vec4(2.0);\n    SEG_VOXELS[1] = vec4(0.0, 5.5, 1.0, 9.5)*vec4(2.0);\n    SEG_VOXELS[2] = vec4(3.0, 6.0, 4.0, 9.0)*vec4(2.0);\n    SEG_VOXELS[3] = vec4(5.0, 5.5, 6.0, 9.5)*vec4(2.0);\n    SEG_VOXELS[4] = vec4(1.0, 5.0, 5.0, 6.0)*vec4(2.0);\n    SEG_VOXELS[5] = vec4(0.0, 1.5, 1.0, 5.5)*vec4(2.0);\n    SEG_VOXELS[6] = vec4(5.0, 1.5, 6.0, 5.5)*vec4(2.0);\n    SEG_VOXELS[7] = vec4(1.0, 1.0, 6.0, 2.0)*vec4(2.0);\n    SEG_VOXELS[8] = vec4(0.0, 0.0, 2.0, 2.0)*vec4(2.0);\n\n} //init_charset\n\n// }}}1\n\n// MESSAGE ////////////////////////////////////////////\n// No music sync found\n// Parts and start times\n#define LOADING (0.0)\n#define LOADING_START (0.00000000000000000000)\n#define NOP (1.0)\n#define NOP_START (30.00000000000000000000)\n#define HEY (2.0)\n#define HEY_START (31.00000000000000000000)\n#define FALKEN (3.0)\n#define FALKEN_START (32.00000000000000000000)\n#define NOP2 (4.0)\n#define NOP2_START (33.50000000000000000000)\n#define LINE1 (5.0)\n#define LINE1_START (34.25000000000000000000)\n#define XPORT (6.0)\n#define XPORT_START (41.00000000000000000000)\n#define LINE2 (7.0)\n#define LINE2_START (49.00000000000000000000)\n#define LINE3 (8.0)\n#define LINE3_START (58.75000000000000000000)\n#define HOWTO (9.0)\n#define HOWTO_START (85.75000000000000000000)\n#define ENDPART (10.0)\n#define ENDPART_START (98.00000000000000000000)\n\nvec4 get_story(in float time)\n{   //returns vec4(partnum, charidx_frac, first_charidx, clip_charidx)\n    // NOTE: charidx_frac restarts at 0 each part!\n    // first_charidx and clip_charidx are with respect to the whole messge.\n    // Character indices starting with clip_charidx should not be displayed.\n    float partnum, charidx_frac, first_charidx, clip_charidx;\n    if(time<30.00000000000000000000) {\n        partnum=LOADING;\n        charidx_frac=(time-LOADING_START)*0.36666666666666664076;\n        first_charidx=0.0;\n        clip_charidx=10.0;\n    } else\n\n    if(time<31.00000000000000000000) {\n        partnum=NOP;\n        charidx_frac=(time-NOP_START)*1.00000000000000000000;\n        first_charidx=11.0;\n        clip_charidx=11.0;\n    } else\n\n    if(time<32.00000000000000000000) {\n        partnum=HEY;\n        charidx_frac=(time-HEY_START)*8.00000000000000000000;\n        first_charidx=12.0;\n        clip_charidx=19.0;\n    } else\n\n    if(time<33.50000000000000000000) {\n        partnum=FALKEN;\n        charidx_frac=(time-FALKEN_START)*8.00000000000000000000;\n        first_charidx=20.0;\n        clip_charidx=31.0;\n    } else\n\n    if(time<34.25000000000000000000) {\n        partnum=NOP2;\n        charidx_frac=(time-NOP2_START)*1.33333333333333325932;\n        first_charidx=32.0;\n        clip_charidx=32.0;\n    } else\n\n    if(time<41.00000000000000000000) {\n        partnum=LINE1;\n        charidx_frac=(time-LINE1_START)*4.00000000000000000000;\n        first_charidx=33.0;\n        clip_charidx=56.0;\n    } else\n\n    if(time<49.00000000000000000000) {\n        partnum=XPORT;\n        charidx_frac=(time-XPORT_START)*1.50000000000000000000;\n        first_charidx=60.0;\n        clip_charidx=71.0;\n    } else\n\n    if(time<58.75000000000000000000) {\n        partnum=LINE2;\n        charidx_frac=(time-LINE2_START)*4.00000000000000000000;\n        first_charidx=72.0;\n        clip_charidx=107.0;\n    } else\n\n    if(time<85.75000000000000000000) {\n        partnum=LINE3;\n        charidx_frac=(time-LINE3_START)*4.00000000000000000000;\n        first_charidx=111.0;\n        clip_charidx=215.0;\n    } else\n\n    if(time<98.00000000000000000000) {\n        partnum=HOWTO;\n        charidx_frac=(time-HOWTO_START)*4.00000000000000000000;\n        first_charidx=219.0;\n        clip_charidx=264.0;\n    } else\n\n    if(time<100.00000000000000000000) {\n        partnum=ENDPART;\n        charidx_frac=(time-ENDPART_START)*0.50000000000000000000;\n        first_charidx=268.0;\n        clip_charidx=268.0;\n    } else\n\n    {\n        partnum=0.0;\n        charidx_frac=0.0;\n        first_charidx=0.0;\n        clip_charidx=0.0;\n    }\n\n    return vec4(partnum,charidx_frac,first_charidx,clip_charidx);\n} //get_story\n\nvec4 get_seg_vec4(float vecidx) {\n    if(vecidx>=34.0){\n        if(vecidx>=51.0){\n            if(vecidx>=59.0){\n                if(vecidx>=63.0){\n                    if(vecidx>=65.0){\n                        if(vecidx>=67.0) return vec4(0.0,0.0,0.0,0.0);\n                        if(vecidx>=66.0) return vec4(0.0,0.0,0.0,0.0);\n                        if(vecidx>=65.0) return vec4(235.0,235.0,107.0,258.0);\n                    }else{\n                        if(vecidx>=64.0) return vec4(11.0,219.0,0.0,211.0);\n                        if(vecidx>=63.0) return vec4(19.0,27.0,15.0,21.0);\n                    }\n                }else{\n                    if(vecidx>=62.0) return vec4(107.0,179.0,178.0,0.0);\n                    if(vecidx>=61.0) return vec4(178.0,16.0,248.0,256.0);\n                    if(vecidx>=60.0) return vec4(162.0,123.0,107.0,179.0);\n                    if(vecidx>=59.0) return vec4(178.0,235.0,256.0,59.0);\n                }\n            }else{\n                if(vecidx>=55.0){\n                    if(vecidx>=58.0) return vec4(0.0,122.0,235.0,30.0);\n                    if(vecidx>=57.0) return vec4(0.0,27.0,26.0,178.0);\n                    if(vecidx>=56.0) return vec4(114.0,187.0,19.0,118.0);\n                    if(vecidx>=55.0) return vec4(0.0,0.0,0.0,163.0);\n                }else{\n                    if(vecidx>=54.0) return vec4(0.0,0.0,0.0,0.0);\n                    if(vecidx>=53.0) return vec4(234.0,258.0,258.0,0.0);\n                    if(vecidx>=52.0) return vec4(248.0,0.0,218.0,235.0);\n                    if(vecidx>=51.0) return vec4(211.0,0.0,123.0,11.0);\n                }\n            }\n        }else{\n            if(vecidx>=42.0){\n                if(vecidx>=46.0){\n                    if(vecidx>=48.0){\n                        if(vecidx>=50.0) return vec4(51.0,178.0,0.0,59.0);\n                        if(vecidx>=49.0) return vec4(0.0,248.0,3.0,21.0);\n                        if(vecidx>=48.0) return vec4(19.0,26.0,219.0,15.0);\n                    }else{\n                        if(vecidx>=47.0) return vec4(26.0,19.0,19.0,0.0);\n                        if(vecidx>=46.0) return vec4(211.0,0.0,19.0,15.0);\n                    }\n                }else{\n                    if(vecidx>=45.0) return vec4(27.0,0.0,242.0,35.0);\n                    if(vecidx>=44.0) return vec4(30.0,123.0,0.0,178.0);\n                    if(vecidx>=43.0) return vec4(107.0,242.0,123.0,107.0);\n                    if(vecidx>=42.0) return vec4(16.0,0.0,118.0,235.0);\n                }\n            }else{\n                if(vecidx>=38.0){\n                    if(vecidx>=41.0) return vec4(26.0,178.0,187.0,0.0);\n                    if(vecidx>=40.0) return vec4(0.0,15.0,2.0,11.0);\n                    if(vecidx>=39.0) return vec4(18.0,123.0,211.0,178.0);\n                    if(vecidx>=38.0) return vec4(187.0,3.0,218.0,0.0);\n                }else{\n                    if(vecidx>=37.0) return vec4(114.0,187.0,0.0,26.0);\n                    if(vecidx>=36.0) return vec4(123.0,178.0,0.0,178.0);\n                    if(vecidx>=35.0) return vec4(123.0,248.0,187.0,0.0);\n                    if(vecidx>=34.0) return vec4(0.0,16.0,0.0,15.0);\n                }\n            }\n        }\n    }else{\n        if(vecidx>=17.0){\n            if(vecidx>=25.0){\n                if(vecidx>=29.0){\n                    if(vecidx>=31.0){\n                        if(vecidx>=33.0) return vec4(0.0,19.0,124.0,30.0);\n                        if(vecidx>=32.0) return vec4(11.0,187.0,0.0,16.0);\n                        if(vecidx>=31.0) return vec4(11.0,19.0,18.0,21.0);\n                    }else{\n                        if(vecidx>=30.0) return vec4(0.0,16.0,0.0,21.0);\n                        if(vecidx>=29.0) return vec4(163.0,162.0,235.0,72.0);\n                    }\n                }else{\n                    if(vecidx>=28.0) return vec4(0.0,0.0,0.0,107.0);\n                    if(vecidx>=27.0) return vec4(0.0,0.0,0.0,0.0);\n                    if(vecidx>=26.0) return vec4(235.0,107.0,258.0,0.0);\n                    if(vecidx>=25.0) return vec4(59.0,187.0,35.0,211.0);\n                }\n            }else{\n                if(vecidx>=21.0){\n                    if(vecidx>=24.0) return vec4(0.0,21.0,11.0,0.0);\n                    if(vecidx>=23.0) return vec4(178.0,187.0,11.0,248.0);\n                    if(vecidx>=22.0) return vec4(11.0,0.0,123.0,178.0);\n                    if(vecidx>=21.0) return vec4(21.0,0.0,19.0,123.0);\n                }else{\n                    if(vecidx>=20.0) return vec4(0.0,211.0,27.0,0.0);\n                    if(vecidx>=19.0) return vec4(0.0,0.0,0.0,0.0);\n                    if(vecidx>=18.0) return vec4(0.0,0.0,0.0,0.0);\n                    if(vecidx>=17.0) return vec4(178.0,179.0,35.0,0.0);\n                }\n            }\n        }else{\n            if(vecidx>=8.0){\n                if(vecidx>=12.0){\n                    if(vecidx>=14.0){\n                        if(vecidx>=16.0) return vec4(211.0,59.0,235.0,35.0);\n                        if(vecidx>=15.0) return vec4(178.0,35.0,123.0,107.0);\n                        if(vecidx>=14.0) return vec4(0.0,0.0,0.0,0.0);\n                    }else{\n                        if(vecidx>=13.0) return vec4(178.0,114.0,123.0,178.0);\n                        if(vecidx>=12.0) return vec4(21.0,178.0,114.0,0.0);\n                    }\n                }else{\n                    if(vecidx>=11.0) return vec4(26.0,59.0,0.0,30.0);\n                    if(vecidx>=10.0) return vec4(35.0,35.0,218.0,0.0);\n                    if(vecidx>=9.0) return vec4(0.0,0.0,122.0,234.0);\n                    if(vecidx>=8.0) return vec4(0.0,0.0,0.0,0.0);\n                }\n            }else{\n                if(vecidx>=4.0){\n                    if(vecidx>=7.0) return vec4(179.0,107.0,258.0,0.0);\n                    if(vecidx>=6.0) return vec4(51.0,123.0,162.0,118.0);\n                    if(vecidx>=5.0) return vec4(0.0,0.0,0.0,0.0);\n                    if(vecidx>=4.0) return vec4(122.0,179.0,218.0,0.0);\n                }else{\n                    if(vecidx>=3.0) return vec4(0.0,0.0,0.0,0.0);\n                    if(vecidx>=2.0) return vec4(256.0,256.0,0.0,0.0);\n                    if(vecidx>=1.0) return vec4(21.0,11.0,219.0,256.0);\n                    if(vecidx>=0.0) return vec4(162.0,235.0,123.0,248.0);\n                }\n            }\n        }\n    }\n    return vec4(0.0);\n} //get_seg_vec4\n\n#define NUM_CHARS_IN_MESSAGE (269.0)\nfloat get_seg_mask(float charidx)\n{\n    if(charidx>=NUM_CHARS_IN_MESSAGE) return 0.0; //blank at the end\n    float vecidx = charidx * 0.250000000;\n    float subidx = mod(charidx, 4.0);\n    vec4 v = get_seg_vec4(vecidx);\n    float rv = v[0];\n    rv = mix(rv, v[1], step(1.0, subidx));\n    rv = mix(rv, v[2], step(2.0, subidx));\n    rv = mix(rv, v[3], step(3.0, subidx));\n    return rv;\n} //get_seg_mask\n\n// Camera and light prototypes\n\nvoid do_cl_loading(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_nop(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_hey(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_falken(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_nop2(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_line1(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_xport(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_line2(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_line3(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_howto(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_endpart(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\n\nvoid do_camera_light(in float partnum, in float charidx_frac,\n                        out vec3 camera_pos,\n                        out vec3 camera_look_at, out vec3 camera_up,\n                        out float fovy_deg, out vec3 light_pos)\n{   // Camera and light dispatcher\n    if(partnum>=LINE1) {\n\n        if(partnum==LINE1) {\n            do_cl_line1(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==XPORT) {\n            do_cl_xport(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==LINE2) {\n            do_cl_line2(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==LINE3) {\n            do_cl_line3(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==HOWTO) {\n            do_cl_howto(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==ENDPART) {\n            do_cl_endpart(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        {\n            camera_pos=vec3(0.0,0.0,10.0);    //default\n            camera_look_at=vec3(0.0);\n            camera_up=vec3(0.0, 1.0, 0.0);\n            fovy_deg=45.0;\n            light_pos=camera_pos;\n        }\n    } else {\n\n        if(partnum==LOADING) {\n            do_cl_loading(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==NOP) {\n            do_cl_nop(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==HEY) {\n            do_cl_hey(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==FALKEN) {\n            do_cl_falken(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==NOP2) {\n            do_cl_nop2(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        {\n            camera_pos=vec3(0.0,0.0,10.0);    //default\n            camera_look_at=vec3(0.0);\n            camera_up=vec3(0.0, 1.0, 0.0);\n            fovy_deg=45.0;\n            light_pos=camera_pos;\n        }\n    }\n} //do_camera_light\n\n#define HEY_REALSTART (16.00000000000000000000)\n#define FALKEN_REALSTART (24.00000000000000000000)\n#define XPORT_NCHARS (11.00000000000000000000)\n#define LOADING_NCHARS (10.00000000000000000000)\n#define XPORT_FADEIN_DURATION (5.0)\n\n\n// UTIL ///////////////////////////////////////////////\n// {{{1\nmat4 my_transpose(in mat4 inMatrix)\n\n{\n    // Modified from\n    // http://stackoverflow.com/a/18038495/2877364 by\n    // http://stackoverflow.com/users/2507370/jeb\n    vec4 i0 = inMatrix[0];\n    vec4 i1 = inMatrix[1];\n    vec4 i2 = inMatrix[2];\n    vec4 i3 = inMatrix[3];\n\n    vec4 o0 = vec4(i0.x, i1.x, i2.x, i3.x);\n    vec4 o1 = vec4(i0.y, i1.y, i2.y, i3.y);\n    vec4 o2 = vec4(i0.z, i1.z, i2.z, i3.z);\n    vec4 o3 = vec4(i0.w, i1.w, i2.w, i3.w);\n\n    mat4 outMatrix = mat4(o0, o1, o2, o3);\n\n    return outMatrix;\n}\n\nvoid lookat(in vec3 in_eye, in vec3 in_ctr, in vec3 in_up,\n            out mat4 view, out mat4 view_inv)\n{\n    // From Mesa glu.  Thanks to\n    // http://learnopengl.com/#!Getting-started/Camera\n    // and https://www.opengl.org/wiki/GluLookAt_code\n\n    vec3 forward, side, up;\n\n    forward=normalize(in_ctr-in_eye);\n    up = in_up;\n    side = normalize(cross(forward,up));\n    up = cross(side,forward);   // already normalized since both inputs are\n        //now side, up, and forward are orthonormal\n\n    mat4 orient, where;\n\n    // Note: in Mesa gluLookAt, a C matrix is used, so the indices\n    // have to be swapped compared to that code.\n    vec4 x4, y4, z4, w4;\n    x4 = vec4(side,0);\n    y4 = vec4(up,0);\n    z4 = vec4(-forward,0);\n    w4 = vec4(0,0,0,1);\n    orient = my_transpose(mat4(x4, y4, z4, w4));\n\n    where = mat4(1.0); //identity (1.0 diagonal matrix)\n    where[3] = vec4(-in_eye, 1);\n\n    view = (orient * where);\n\n    // Compute the inverse for later\n    view_inv = mat4(x4, y4, z4, -where[3]);\n    view_inv[3][3] = 1.0;   // since -where[3].w == -1, not what we want\n        // Per https://en.wikibooks.org/wiki/GLSL_Programming/Vertex_Transformations ,\n        // M_{view->world}\n} //lookat\n\nvoid gluPerspective(in float fovy_deg, in float aspect,\n                    in float near, in float far,\n                    out mat4 proj, out mat4 proj_inv)\n{   // from mesa glu-9.0.0/src/libutil/project.c.\n    // Thanks to https://unspecified.wordpress.com/2012/06/21/calculating-the-gluperspective-matrix-and-other-opengl-matrix-maths/\n\n    float fovy_rad = radians(fovy_deg);\n    float dz = far-near;\n    float sin_fovy = sin(fovy_rad);\n    float cot_fovy = cos(fovy_rad) / sin_fovy;\n\n    proj=mat4(0);\n    //[col][row]\n    proj[0][0] = cot_fovy / aspect;\n    proj[1][1] = cot_fovy;\n\n    proj[2][2] = -(far+near)/dz;\n    proj[2][3] = -1.0;\n\n    proj[3][2] = -2.0*near*far/dz;\n\n    // Compute the inverse matrix.\n    // http://bookofhook.com/mousepick.pdf\n    float a = proj[0][0];\n    float b = proj[1][1];\n    float c = proj[2][2];\n    float d = proj[3][2];\n    float e = proj[2][3];\n\n    proj_inv = mat4(0);\n    proj_inv[0][0] = 1.0/a;\n    proj_inv[1][1] = 1.0/b;\n    proj_inv[3][2] = 1.0/e;\n    proj_inv[2][3] = 1.0/d;\n    proj_inv[3][3] = -c/(d*e);\n} //gluPerspective\n\nvoid compute_viewport(in float x, in float y, in float w, in float h,\n                        out mat4 viewp, out mat4 viewp_inv)\n{\n    // See https://en.wikibooks.org/wiki/GLSL_Programming/Vertex_Transformations#Viewport_Transformation\n    // Also mesa src/mesa/main/viewport.c:_mesa_get_viewport_xform()\n\n    viewp = mat4(0);\n    // Reminder: indexing is [col][row]\n    viewp[0][0] = w/2.0;\n    viewp[3][0] = x+w/2.0;\n\n    viewp[1][1] = h/2.0;\n    viewp[3][1] = y+h/2.0;\n\n    // assumes n=0 and f=1,\n    // which are the default for glDepthRange.\n    viewp[2][2] = 0.5;  // actually 0.5 * (f-n);\n    viewp[3][2] = 0.5;  // actually 0.5 * (n+f);\n\n    viewp[3][3] = 1.0;\n\n    //Invert.  Done by hand.\n    viewp_inv = mat4(1.0);\n    viewp_inv[0][0] = 2.0/w;    // x->x\n    viewp_inv[3][0] = -1.0 - (2.0*x/w);\n\n    viewp_inv[1][1] = 2.0/h;    // y->y\n    viewp_inv[3][1] = -1.0 - (2.0*y/h);\n\n    viewp_inv[2][2] = 2.0;      // z->z\n    viewp_inv[3][2] = -1.0;\n\n}  //compute_viewport\n\n// https://www.opengl.org/wiki/Compute_eye_space_from_window_space\n\nvec4 wts(in mat4 modelviewproj, in mat4 viewport,\n                in vec3 pos)\n{   // world to screen coordinates\n    vec4 clipvertex = modelviewproj * vec4(pos,1.0);\n    vec4 ndc = clipvertex/clipvertex.w;\n    vec4 transformed = viewport * ndc;\n    return transformed;\n} //wts\n\n// screen to world: http://bookofhook.com/mousepick.pdf\nvec4 WorldRayFromScreenPoint(in vec2 scr_pt,\n    in mat4 view_inv,\n    in mat4 proj_inv,\n    in mat4 viewp_inv)\n{   // Returns world coords of a point on a ray passing through\n    // the camera position and scr_pt.\n\n    vec4 ndc = viewp_inv * vec4(scr_pt,0.0,1.0);\n        // z=0.0 => it's a ray.  0 is an arbitrary choice in the\n        // view volume.\n        // w=1.0 => we don't need to undo the perspective divide.\n        //      So clip coords == NDC\n\n    vec4 view_coords = proj_inv * ndc;\n        // At this point, z=0 will have become something in the\n        // middle of the projection volume, somewhere between\n        // near and far.\n    view_coords = view_coords / view_coords.w;\n        // Keepin' it real?  Not sure what happens if you skip this.\n    //view_coords.w = 0.0;\n        // Remove translation components.  Note that we\n        // don't use this trick.\n    vec4 world_ray_point = view_inv * view_coords;\n        // Now scr_pt is on the ray through camera_pos and world_ray_point\n    return world_ray_point;\n} //WorldRayFromScreenPoint\n\nvec3 hsv2rgb(vec3 c) {\n    // by hughsk, from https://github.com/hughsk/glsl-hsv2rgb/blob/master/index.glsl .\n    // All inputs range from 0 to 1.\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat scalesin(in float bot, in float top, in float x)\n{   //rescale [-1,1] to [bot, top]\n    return mix(bot, top, clamp((x+1.0)*0.5, 0.0, 1.0));\n}\n\n\n\n// }}}1\n\n// VOXEL MARCHING\n// {{{1\n\n// Variables for voxel marching\nstruct VM2State {\n    // Parameters\n    vec3 origin;\n    vec3 direction;\n    vec3 world_min;\n    vec3 world_max;\n\n    // Internals\n    vec3 curr;      //where we are now - was x, y, z vars\n    vec3 stepdir;   //was step[XYZ]\n    vec3 tMax;\n    vec3 tDelta;\n    float max_t;\n}; //VM2State\n\n// By http://gamedev.stackexchange.com/users/8806/maxim-kamalov , aka\n// dogfuntom, https://gist.github.com/dogfuntom .\n// See http://gamedev.stackexchange.com/questions/47362/cast-ray-to-select-block-in-voxel-game#comment188335_49423\n// Modified from https://gist.github.com/cc881c8fc86ad43d55d8.git\n//// Heavily based on:\n//// http://gamedev.stackexchange.com/a/49423/8806\n\nfloat intbound(float s, float ds)\n{\n    // Some kind of edge case, see:\n    // http://gamedev.stackexchange.com/questions/47362/cast-ray-to-select-block-in-voxel-game#comment160436_49423 :\n        // \"The edge case is where a coordinate of the ray origin is an\n        //integer value, and the corresponding part of the ray direction is\n        //negative. The initial tMax value for that axis should be zero, since\n        //the origin is already at the bottom edge of its cell, but it is\n        //instead 1/ds causing one of the other axes to be incremented instead.\n        //The fix is to write intfloor to check if both ds is negative and s is\n        //an integer value (mod returns 0), and return 0.0 in that case. â€“\n        //codewarrior Dec 24 '14 at 12:00\"\n\n    // by http://gamedev.stackexchange.com/users/57468/codewarrior\n    bool sIsInteger = (fract(s)==0.0);  //TODO check against epsilon?\n    if (ds < 0.0 && sIsInteger)\n        return 0.0;\n\n    return (\n        ( (ds > 0.0) ? (ceil(s) - s) : (s - floor(s)) ) / abs(ds)\n    );\n} //intbound\n\nbool VM2_init(out VM2State state,\n    in vec3 origin, in vec3 direction, in float max_dist,\n    in vec3 world_min, in vec3 world_max)\n{ //The initialization portion of VM2_raycast (q.v.).\n  //Returns true if successful.\n\n    if(length(direction)==0.0) {\n        return false;   // *** EXIT POINT ***\n    }\n\n    state.origin = origin;\n    state.direction = direction;\n    state.world_min = world_min;     // TODO? make sure they are ints?\n    state.world_max = world_max;\n\n    state.curr = floor(origin);\n    state.stepdir = sign(direction);\n\n    state.tMax.x = intbound(origin.x, direction.x);\n    state.tMax.y = intbound(origin.y, direction.y);\n    state.tMax.z = intbound(origin.z, direction.z);\n\n    state.tDelta.x = state.stepdir.x / direction.x;\n    state.tDelta.y = state.stepdir.y / direction.y;\n    state.tDelta.z = state.stepdir.z / direction.z;\n\n    state.max_t = max_dist / length(direction);\n    return true;\n} //VM2_init\n\n//DEBUG: these are floats.  For production, change them back to int.\n#define VM2_HIT (1.0)\n#define VM2_NOTYET (-1.0)\n#define VM2_DONE (0.0)\n\nvec4 VM2_step(inout VM2State state,\n                out vec3 voxel, out vec3 hitpoint, out vec3 normal)\n{ //returns:\n  // VM2_HIT    if we hit a voxel in the world;\n  // VM2_NOTYET if we have not yet reached the world; or\n  // VM2_DONE   if we have traced off the end of the world or have gone\n  //            too far along the ray.\n  // If VM2_HIT, voxel and normal are filled in:\n  //    voxel       coordinates of the voxel we're in\n  //    hitpoint    The actual point where the ray hit the voxel\n  //    normal      normal of the voxel at hitpoint\n\n    vec3 ret_normal;    //value to be returned\n    float hit_t;        //where we actually hit\n\n    // Go to the next voxel.\n    //DEBUG: The *0.05's below are to rescale for visibility, and are debug.\n    if (state.tMax.x < state.tMax.y) {\n        if (state.tMax.x < state.tMax.z) {\n            if (state.tMax.x > state.max_t) return vec4(state.tMax*0.05,VM2_DONE);\n            state.curr.x += state.stepdir.x;    // Update which cube we are now in.\n            hit_t = state.tMax.x;               // Record where we hit the cube\n            state.tMax.x += state.tDelta.x;\n                // Adjust state.tMax.x to the next X-oriented crossing\n            ret_normal = vec3(-state.stepdir.x, 0.0, 0.0);\n                // Record the normal vector of the voxel we just entered.\n        } else {\n            if (state.tMax.z > state.max_t) return vec4(state.tMax*0.05,VM2_DONE);\n            state.curr.z += state.stepdir.z;\n            hit_t = state.tMax.z;\n            state.tMax.z += state.tDelta.z;\n            ret_normal = vec3(0.0, 0.0, -state.stepdir.z);\n        }\n    } else {\n        if (state.tMax.y < state.tMax.z) {\n            if (state.tMax.y > state.max_t) return vec4(state.tMax*0.05,VM2_DONE);\n            state.curr.y += state.stepdir.y;\n            hit_t = state.tMax.y;\n            state.tMax.y += state.tDelta.y;\n            ret_normal = vec3(0.0, -state.stepdir.y, 0.0);\n        } else {\n            if (state.tMax.z > state.max_t) return vec4(state.tMax*0.05,VM2_DONE);\n            state.curr.z += state.stepdir.z;\n            hit_t = state.tMax.z;\n            state.tMax.z += state.tDelta.z;\n            ret_normal = vec3(0.0, 0.0, -state.stepdir.z);\n        }\n    } //end conditionals\n\n    // Check if we're past the world\n    if( (state.stepdir.x>0.0) ?\n        (state.curr.x>=state.world_max.x) : (state.curr.x<state.world_min.x) )\n        return vec4(1.0,0.0,0.0,VM2_DONE);\n    if( (state.stepdir.y>0.0) ?\n        (state.curr.y>=state.world_max.y) : (state.curr.y<state.world_min.y) )\n        return vec4(0.0,1.0,0.0,VM2_DONE);\n    if( (state.stepdir.z>0.0) ?\n        (state.curr.z>=state.world_max.z) : (state.curr.z<state.world_min.z) )\n        return vec4(0.0,0.0,1.0,VM2_DONE);\n\n    // Check if we're not yet at the world.\n    // TODO in VM2_init, fast-forward to the boundary of the world so that\n    // this case never happens.\n    if( (state.stepdir.x>0.0) ?\n        (state.curr.x<state.world_min.x) : (state.curr.x>=state.world_max.x) )\n        return vec4(0.5,0.0,0.0,VM2_NOTYET);\n    if( (state.stepdir.y>0.0) ?\n        (state.curr.y<state.world_min.y) : (state.curr.y>=state.world_max.y) )\n        return vec4(0.0,0.5,0.0,VM2_NOTYET);\n    if( (state.stepdir.z>0.0) ?\n        (state.curr.z<state.world_min.z) : (state.curr.z>=state.world_max.z) )\n        return vec4(0.0,0.0,0.5,VM2_NOTYET);\n\n    // If we made it here, we are in a voxel cell.\n    voxel = state.curr;\n    hitpoint = state.origin + hit_t*state.direction;\n    normal = ret_normal;\n    return vec4(voxel,VM2_HIT);     //voxel is debug\n} //VM2_step\n\n// }}}1\n\n// GEOMETRY HIT-TESTING ///////////////////////////////\n// {{{1\n\n\n\n// Faster routine for the special case of the main text\nvec3 HitZZero(vec3 camera_pos, vec3 rayend)\n{   // Find where the ray meets the z=0 plane.  The ray is\n    // camera_pos + t*(rayend - camera_pos) per Hook.\n    float hit_t = -camera_pos.z / (rayend.z - camera_pos.z);\n    return (camera_pos + hit_t * (rayend-camera_pos));\n} //HitZZero\n\n// --- IsPointInRectXY ---\n// All polys will be quads in the X-Y plane, Z=0.\n// All quad edges are parallel to the X or Y axis.\n// These quads are encoded in a vec4: (.x,.y) is the LL corner and\n// (.z,.w) is the UR corner (coords (x,y)).  The UR corner is not\n// inclued in the poly.\n\nbool IsPointInRectXY(in vec4 poly_coords, in vec2 world_xy_of_point)\n{\n    // return true if world_xy_of_point is within the poly defined by\n    // poly_coords in the Z=0 plane.\n    // I.e., xy >= poly_coords.xy, and xy < poly_coords.zw.\n    // I can test in 2D rather than 3D because all the geometry\n    // has z=0 and all the quads are planar.\n\n    float x_test, y_test;\n    x_test = step(poly_coords.x, world_xy_of_point.x) *\n            (1.0 - step(poly_coords.z, world_xy_of_point.x));\n        // step() is 1.0 if world.x >= poly_coords.x\n        // 1-step() is 1.0 if world.x < poly_coords.z\n    y_test = step(poly_coords.y, world_xy_of_point.y) *\n            (1.0 - step(poly_coords.w, world_xy_of_point.y));\n\n    return ( (x_test>=0.9) && (y_test >= 0.9) );\n        // Not ==1.0 because these are floats!\n\n} //IsPointInRectXY\n\n\n\n// }}}1\n\n// TEXT RENDERING /////////////////////////////////////\n// {{{1\n\n// Text-rendering internal parameters\n#define LETTER_EPSILON (0.001)\n    // small enough for our purposes.\n#define SIDE_LETTERS (4)\n    // How many letters to render on each side of the current one.\n    // Set to fill the screen at the desired aspect ratio and orientation.\n\nbool is_in_zzero_message(in vec2 world_xy_of_point,\n                         in float middle_charidx, in float middle_x,\n                         in float clip_charidx)\n{   // returns true iff world_xy_of_point is in a letter\n    // upright in the z=0 plane.\n    // Letters are extracted from the message, with message[middle_charidx]\n    // being displayed with its LL corner at (middle_x, 0, 0).\n    // Characters starting from clip_charidx are not hit.\n\n    // Check each letter in turn\n    for(int ltr_idx=0; ltr_idx<(2*SIDE_LETTERS+1); ++ltr_idx) {\n        float letter_delta = float(ltr_idx-SIDE_LETTERS-1);\n        float thisletterindex = letter_delta + middle_charidx;\n            // so the middle element of ltr_idx maps to middle_charidx\n\n        if(thisletterindex >= clip_charidx) {\n            break;  // no more letters\n        }\n\n        float mask = get_seg_mask(thisletterindex);\n            // the segments for this letter\n\n        // Early exit on spaces\n        if(mask <= LETTER_EPSILON) {\n            continue; //to next letter\n        }\n\n        // Where is this letter on the X axis?\n        float ofs = (letter_delta*GRID_PITCH) + middle_x;\n\n        // check each segment in turn\n        for(int seg_idx=0; seg_idx<NSEGS; ++seg_idx) {\n            if(mod(mask, 2.0)>LETTER_EPSILON) {\n                // Where is this segment of this letter?\n                vec4 theshape = SEG_SHAPES[seg_idx];\n                theshape += vec4(ofs, 0.0, ofs, 0.0);\n                    //shift it over to the right place\n\n                // Check if we are in the segment\n                if(IsPointInRectXY(theshape, world_xy_of_point)) {\n                    return true;    // as soon as we're in a segment, we don't need to check any others\n                }\n\n            } //endif this segment is in mask\n\n            mask = floor(mask * 0.5);\n                //move to next bit and drop fractional part\n\n            // Early exit when you run out of segments\n            if(mask<=LETTER_EPSILON) {\n                break; //to next letter\n            }\n        } //foreach segment\n\n    } //foreach letter\n\n    return false;\n} //is_in_zzero_message\n\nbool is_in_basic_message(in vec2 pt,\n    in float first_charidx, in float clip_charidx)\n{   // returns true iff world_xy_of_point is the message for this part,\n    // which begins with first_charidx at x=0, upright in the z=0 plane.\n\n    float nchars = (clip_charidx-first_charidx);\n        //not ()+1 because clip_charidx is one past the last char to show.\n    if( (pt.x<0.0) || (pt.x>=nchars*GRID_PITCH) ) {\n        return false;   //outside - can't hit\n    }\n\n    if( (pt.y<0.0) || (pt.y>GRID_CHARHT*GRID_VPITCH) ) {\n        return false;   //ditto\n    }\n\n    // Which letter are we in?  There can be only one.\n    float ltridx = floor(pt.x/GRID_PITCH);\n    float ofs = ltridx * GRID_PITCH;\n    float mask = get_seg_mask(first_charidx + ltridx);\n\n    // Early exit on spaces\n    if(mask <= LETTER_EPSILON) {\n        return false;\n    }\n\n    // check each segment in turn\n    for(int seg_idx=0; seg_idx<NSEGS; ++seg_idx) {\n        if(mod(mask, 2.0)>LETTER_EPSILON) {\n            // Where is this segment of this letter?\n            vec4 theshape = SEG_SHAPES[seg_idx];\n            theshape += vec4(ofs, 0.0, ofs, 0.0);\n                //shift it over to the right place\n\n            // Check if we are in the segment\n            if(IsPointInRectXY(theshape, pt)) {\n                return true;    // as soon as we're in a segment,\n            }                   // we don't need to check any others\n\n        } //endif this segment is in mask\n\n        mask = floor(mask * 0.5);\n            //move to next bit and drop fractional part\n\n        // Early exit when you run out of segments\n        if(mask<=LETTER_EPSILON) {\n            return false;       // no more chances\n        }\n    } //foreach segment\n\n    return false;\n} //is_in_basic_message\n\n// }}}1\n\n// LETTER RENDERING ///////////////////////////////////\n// {{{1\n\n// Text-rendering internal parameters\n#define LETTER_EPSILON (0.001)\n    // small enough for our purposes.\n\n/*vec3*/ bool voxel_is_in_message(\n    in vec3 origin, in vec3 direction,\n    in float charidx_frac, in float first_charidx, in float clip_charidx,\n    out vec3 voxel, out vec3 hitpoint, out vec3 normal)\n{   //Determine whether _hitlocn_ is in the upright message at the current\n    //point in the story, as determined by charidx_frac.\n    //Returns true on hit.  If true, _voxel_ holds the grid coordinates of the\n    //voxel that was hit, _hitpoint_ holds the actual point hit, and\n    //_normal_ is the normal of the voxel face that was hit.\n\n    //Retval storage, so we don't trash the out parameters if there's no hit.\n    vec3 ret_voxel, ret_hitpoint, ret_normal;\n\n    // Setup voxel marching\n    bool ok;\n    VM2State state;\n    ok = VM2_init(state, origin, direction, MAX_DIST,\n        vec3(0.0,0.0,-LTR_Z_THICKNESS),  //world_min\n        vec3((clip_charidx-first_charidx)*VGRID_PITCH,   //world_max - last+1\n            VGRID_CHARHT,\n            1.0));  // 1.0 => voxels (:,:,0) are the farthest voxels forward.\n                    // (+Z is towards viewer normally)\n\n    if(!ok) return false;   // *** EXIT POINT *** can't init => can't hit\n\n    // Run the marching loop.  At each voxel, check the mask for only\n    // the letter that voxel might be in.\n    for(int step_idx=0; step_idx<MAX_VOXEL_STEPS; ++step_idx) {\n        vec4 /*int*/ hit = VM2_step(state, ret_voxel, ret_hitpoint, ret_normal);\n\n        if(hit.w == VM2_DONE) return false;   // *** EXIT POINT ***\n\n        if(hit.w == VM2_NOTYET) continue;     // to the next voxel step\n\n        // If we got here, we are in a voxel that is in the world.\n\n        // Determine which character cell this voxel is in.\n        // The text starts at x=0 for each part.\n        float voxel_rel_charidx = floor(ret_voxel.x * VGRID_PITCH_RECIP);\n            //which grid cell we're in\n        float voxel_abs_charidx = voxel_rel_charidx + first_charidx;\n            // Where we are in the story.\n            // Don't need to check clip_charidx since that is rolled into\n            // the world_max limits in VM2_init().\n        float mask = get_seg_mask(voxel_abs_charidx);\n            // the segments for this letter\n        //return vec3(mask/255.0); //DEBUG\n\n        // Early exit on spaces\n        if(mask <= LETTER_EPSILON) {\n            continue; //to next voxel step\n        }\n\n        // Where is this letter on the X axis?\n        float letter_xorigin = voxel_rel_charidx * VGRID_PITCH;\n        float voxel_x_within_cell = ret_voxel.x - letter_xorigin;\n            // since voxel cells are every 1 unit at present\n\n        //return vec3(voxel_x_within_cell/20.0, voxel.y/10.0, voxel.z/10.0);  //DEBUG\n\n        // check each segment in turn\n        for(int seg_idx=0; seg_idx<NSEGS; ++seg_idx) {\n            if(mod(mask, 2.0)>LETTER_EPSILON) {     //this segment is lit\n                // Are we in this segment?\n                if(IsPointInRectXY(SEG_VOXELS[seg_idx],\n                                    vec2(voxel_x_within_cell, ret_voxel.y))) {\n                   // A hit!  A very palpable hit.\n                   voxel = ret_voxel;\n                   hitpoint = ret_hitpoint;\n                   normal = ret_normal;\n                   return /*vec3(1.0)*/ true;\n                }\n            } //endif this segment is in mask\n\n            mask = floor(mask * 0.5);\n                //move to next bit and drop any fractional part\n\n            // Early exit when you run out of segments\n            if(mask<=LETTER_EPSILON) {\n                break;  //done with this letter - go to next voxel step\n            }\n        } //foreach segment\n\n    } //for each voxel step\n\n    return false;   //else return no-hit\n} //voxel_is_in_message\n\n// }}}1\n\n// CAMERA AND LIGHT ///////////////////////////////////\n// {{{1\n\n// --- Helpers ---\n\n#define GAMMA (2.2)\n#define ONE_OVER_GAMMA (0.45454545454545454545454545454545)\n\nvec3 phong_color(\n    in vec3 pixel_pos, in vec3 normal, in vec3 camera_pos,      // Scene\n    in vec3 light_pos, in vec3 ambient_matl,                    // Lights\n    in vec3 diffuse_matl, in vec3 specular_matl,                // Lights\n    in float shininess)                                         // Material\n{   // Compute pixel color using Blinn-Phong shading with a white light.\n    // Modified from\n    // https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\n    // Normal must be normalized on input.  All inputs are world coords.\n    // Set shininess <=0 to turn off specular highlights.\n    // Objects are one-sided.\n\n    vec3 light_dir = normalize(light_pos - pixel_pos);\n    vec3 eye_dir = normalize(camera_pos - pixel_pos);\n\n    if(dot(light_dir, eye_dir) < 0.0) {\n        return ambient_matl;       // Camera behind the object\n    }\n\n    float lambertian = max(0.0, dot(light_dir, normal));        // Diffuse\n\n    float specular = 0.0;\n    if((lambertian > 0.0) && (shininess > 0.0)) {               // Specular\n        vec3 reflectDir = reflect(-light_dir, normal);\n        float specAngle = max(dot(reflectDir, eye_dir), 0.0);\n        specular = pow(specAngle, shininess);\n    }\n    lambertian = pow(lambertian, ONE_OVER_GAMMA);\n    specular = pow(specular, ONE_OVER_GAMMA);\n\n    vec3 retval = ambient_matl + lambertian*diffuse_matl +\n        specular*specular_matl;\n\n    return clamp(retval, 0.0, 1.0);     // no out-of-range values, please!\n\n} //phong_color\n\nhighp vec3 pos_clelies(in float the_time, in float radius)\n{   //Clelies curve\n    //thanks to http://wiki.roblox.com/index.php?title=Parametric_equations\n    vec3 pos; float m = 0.8;\n    highp float smt = sin(m*the_time);\n    pos.x = radius * smt*cos(the_time);\n    pos.y = radius * smt*sin(the_time);\n    pos.z = radius * cos(m*the_time);\n    return pos;\n} //camerapos\n\n// --- Per-part routines ---\n\nvoid do_cl_nop(in float partnum, in float charidx_frac, out vec3 camera_pos,\n     out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg,\n     out vec3 light_pos)\n{\n    camera_pos = vec3(0.0,0.0,10.0);    //default\n    camera_look_at = vec3(0.0);\n    camera_up = vec3(0.0, 1.0, 0.0);\n    fovy_deg = 45.0;\n    light_pos = camera_pos;\n} //do_cl_nop\n\nvoid do_cl_loading(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_nop(pn, cf, cp, cla, cu, fd, lp); }\nvoid do_cl_hey(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_nop(pn, cf, cp, cla, cu, fd, lp); }\nvoid do_cl_falken(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_nop(pn, cf, cp, cla, cu, fd, lp); }\nvoid do_cl_nop2(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_nop(pn, cf, cp, cla, cu, fd, lp); }\n\n//s_plain = Scroller, Plain\nvoid do_cl_s_plain(in float partnum, in float charidx_frac, out vec3 camera_pos,\n     out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg,\n     out vec3 light_pos)\n{\n    camera_pos = vec3(charidx_frac*GRID_PITCH-5.0, GRID_CHARHT*0.5, 10.0);\n    camera_look_at = vec3(camera_pos.x+3.0, GRID_CHARHT*0.5,0);\n    camera_up = vec3(0.0, 1.0, 0.0);\n    fovy_deg = 45.0;\n    light_pos = camera_pos;\n    light_pos.y += 4.0 * sin(charidx_frac);\n} //do_cl_s_plain\n\nvoid do_cl_line1(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_s_plain(pn, cf, cp, cla, cu, fd, lp); }\n\nvoid do_cl_xport(in float partnum, in float charidx_frac, out vec3 camera_pos,\n     out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg,\n     out vec3 light_pos)\n{ //static camera\n    camera_pos = vec3(/*charidx_frac*/\n        floor(XPORT_NCHARS/2.0)*GRID_PITCH+GRID_PITCH*0.3, GRID_CHARHT*0.5 + 0.5, 10.0);\n    camera_look_at = vec3(camera_pos.x, GRID_CHARHT*0.5,0);\n    camera_up = vec3(0.0, 1.0, 0.0);\n    fovy_deg = 68.0;\n    light_pos = camera_pos;\n} //do_cl_xport\n\nvoid do_cl_line2(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_s_plain(pn, cf, cp, cla, cu, fd, lp); }\n\nvoid do_cl_line3(in float partnum, in float charidx_frac, out vec3 camera_pos,\n     out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg,\n     out vec3 light_pos)\n{ //For the voxel part.\n    camera_pos = vec3(charidx_frac*VGRID_PITCH-5.0, VGRID_CHARHT*0.5+0.5, 20.0);\n    camera_look_at = vec3(camera_pos.x-0.5, VGRID_CHARHT*0.5,0.0);\n\n    camera_up = vec3(0.0, 1.0, 0.0);\n    fovy_deg = 45.0;\n    light_pos = vec3(\n        camera_pos.x + VGRID_PITCH*sin(TWO_PI*0.125*charidx_frac),\n        camera_pos.y+6.0,\n        camera_pos.z-2.0\n    );\n} //do_cl_line3\n\nvoid do_cl_howto(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_line3(pn, cf, cp, cla, cu, fd, lp); }\n\nvoid do_cl_endpart(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_nop(pn, cf, cp, cla, cu, fd, lp); }\n\n// }}}1\n\n// ARTISTRY ///////////////////////////////////////////\n// {{{1\nvoid do_hey(in float partnum, in vec2 charpos, in float clip_charidx,\n            out vec3 diffuse_matl)\n{\n    vec2 pos;\n    diffuse_matl = vec3(0.0);\n\n    //\"Hey\"\n    pos = charpos - vec2(0.0, 1.0*GRID_VPITCH); // move up one line\n    if(is_in_zzero_message(pos, HEY_REALSTART+4.0, GRID_PITCH*5.0, clip_charidx)) {\n        diffuse_matl = vec3(1.0, 0.0, 0.0);\n        return;\n    }\n\n    pos = charpos; // - vec2(0.0, 0.0*GRID_VPITCH);\n    if( (partnum==FALKEN) &&\n        is_in_zzero_message(pos, FALKEN_REALSTART+4.0, GRID_PITCH*5.0, clip_charidx)) {\n        diffuse_matl = vec3(1.0, 1.0, 1.0);\n        return;\n    }\n} //do_hey\n\nvoid color_xport(in vec2 wpt, in vec2 uvpt, in float dt,\n                out vec3 ambient_matl, out vec3 diffuse_matl,\n                out float shininess)\n{ // World point, Fragment point ([0,1] range), time within the effect.\n  // Fades in over time=[0, XPORT_FADEIN_DURATION].\n\n    float ramp = smoothstep(0.0, XPORT_FADEIN_DURATION, dt);\n    ambient_matl = vec3(0.0);   //for now\n\n    // Shininess\n    float s_dt = scalesin(-PI_OVER_2, PI_OVER_2, dt/XPORT_FADEIN_DURATION);\n        // s_dt goes from 0 to pi/2\n    float s_top = mix(XP_SHINE_HIGH, XP_SHINE_AIM, dt/XPORT_FADEIN_DURATION);\n    float s_bot = mix(XP_SHINE_LOW, XP_SHINE_AIM, dt/XPORT_FADEIN_DURATION);\n    float shine = sin(TWO_PI*XP_SHINE_HZ*dt);\n    shininess = scalesin(s_bot, s_top, shine); // [XP_SHINE_LOW, X~_HIGH]\n\n    // Overall gain\n    float g_top = clamp(ramp*1.5, 0.0, 1.0);\n    float g_bot = ramp*ramp;    // <=ramp, so <= g_top\n    float gain = sin(TWO_PI*XP_GAIN_HZ*dt);\n    gain = scalesin(g_bot, g_top, gain);    // [0,1]\n\n    // Localized gain - horizontal\n    float s;\n    \n        s = sin(TWO_PI*XP_H0_PER_U * uvpt.x +\n            TWO_PI*XP_H0_PHASE +\n            TWO_PI*XP_H0_PHASE_PER_SEC * dt);\n        s = mix(s, 1.0, ramp);     // gain effects are 1.0 at the end\n        gain *= scalesin(0.0, 1.0, s);\n    \n        s = sin(TWO_PI*XP_H1_PER_U * uvpt.x +\n            TWO_PI*XP_H1_PHASE +\n            TWO_PI*XP_H1_PHASE_PER_SEC * dt);\n        s = mix(s, 1.0, ramp);     // gain effects are 1.0 at the end\n        gain *= scalesin(0.0, 1.0, s);\n    \n        s = sin(TWO_PI*XP_H2_PER_U * uvpt.x +\n            TWO_PI*XP_H2_PHASE +\n            TWO_PI*XP_H2_PHASE_PER_SEC * dt);\n        s = mix(s, 1.0, ramp);     // gain effects are 1.0 at the end\n        gain *= scalesin(0.0, 1.0, s);\n    \n\n    diffuse_matl = gain * vec3(0.2, 0.2, 1.0);\n} //color_xport\n\n// }}}1\n\n// MAIN ///////////////////////////////////////////////\n// {{{1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Init\n    float the_time = iTime; //0.5*mod(iTime, 16.0)+S_PLAIN_START;\n    //float the_time = iTime + XPORT_START - 2.0;\n    //float the_time = mod(iTime,LINE2_START-XPORT_START)+XPORT_START; //DEBUG\n        //0.05*mod(3.48, 20.0)+S_PLAIN_START; //DEBUG test case\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    init_charset();\n\n#if 0\n    // Grayscale ramp for reference\n    if(fragCoord.y<10.0) {\n        fragColor = vec4(vec3(fragCoord.x/iResolution.x),1.0);\n        return; //EXIT POINT\n    }\n#endif\n\n    // --- Story ---\n    vec4 story = get_story(the_time);\n    float partnum=story[0], charidx_frac=story[1];\n    float first_charidx=story[2], clip_charidx=story[3];\n\n    // --- Camera and light ---\n    vec3 camera_pos, camera_look_at, camera_up, light_pos;\n    float fovy_deg;\n\n    do_camera_light(partnum, charidx_frac,\n        camera_pos, camera_look_at, camera_up, fovy_deg, light_pos);\n\n    // Camera processing\n    mat4 view, view_inv;\n    lookat(camera_pos, camera_look_at, camera_up,\n            view, view_inv);\n\n    mat4 proj, proj_inv;\n    gluPerspective(fovy_deg, iResolution.x/iResolution.y, 1.0, 10.0,\n                    proj, proj_inv);\n\n    mat4 viewport, viewport_inv;\n    compute_viewport(0.0, 0.0, iResolution.x, iResolution.y,\n                        viewport, viewport_inv);\n\n    // --- Geometry ---\n\n    vec3 rayend = WorldRayFromScreenPoint(fragCoord,\n                                    view_inv, proj_inv, viewport_inv).xyz;\n    vec3 ray_direction = rayend - camera_pos;\n\n    // Each part determines world coords of the hit, normal at the\n    // hit point, and base color of the geometry.\n\n    vec3 wc_pixel;  // world coords of this pixel\n    vec3 wc_normal; // ditto for the normal\n    vec3 ambient_matl = vec3(0.1);\n    vec3 diffuse_matl = vec3(0.0);\n        // material - light is always white.  Alpha is always 1.\n    float shininess = 4.0;  //Phong shininess\n    bool did_hit = false;   //if not did_hit, just use _diffuse_.\n\n    if(partnum == LOADING) {\n        // Are we in the message?\n        \n            // Grid of character cells\n\n        vec3 hitlocn = HitZZero(camera_pos, rayend);\n            // hitlocn is where it hits z=0, where the letters are\n\n        // Size and move the letters\n        hitlocn.xy *= vec2( 5.00000000000000000000, 3.00000000000000000000);\n        hitlocn.xy += vec2( -15.00000000000000000000, 24.00000000000000000000);\n        did_hit = is_in_basic_message(hitlocn.xy, first_charidx, clip_charidx);\n\n        if(did_hit) {\n            float dt = mod(the_time * 0.2, 1.0);\n            diffuse_matl = hsv2rgb(vec3(\n                mod(the_time, 1.0),\n                1.0,\n                smoothstep(0.0, 0.5, dt) * (1.0-smoothstep(0.5, 1.0, dt))\n            ));\n            did_hit = false;    // only use diffuse_matl\n        } else {    // not in the text\n            // GLSL Sandbox default, tweaked slightly\n            float color = 0.0;\n            float rotation = mod(LOADING_FREQ*the_time, TWO_PI);\n            mat2 rot = mat2(cos(rotation), sin(rotation), -sin(rotation), cos(rotation));\n            vec2 position = rot * uv;\n            color += sin( position.x * cos( the_time / 15.0 ) * 80.0 ) + cos( position.y * cos( the_time / 15.0 ) * 10.0 );\n            color += sin( position.y * sin( the_time / 10.0 ) * 40.0 ) + cos( position.x * sin( the_time / 25.0 ) * 40.0 );\n            color += sin( position.x * sin( the_time / 5.0 ) * 10.0 ) + sin( position.y * sin( the_time / 35.0 ) * 80.0 );\n            color *= sin( the_time / 10.0 ) * 0.5;\n\n            diffuse_matl = vec3( color, color * 0.5, sin( color + the_time / 3.0 ) * 0.75 );\n        } //endif in text else\n\n        diffuse_matl *= (1.0-smoothstep(NOP_START-2.0, NOP_START, the_time));\n            // fade out gently\n\n    } else if( (partnum == NOP) || (partnum == ENDPART) ) {    // black screens\n        diffuse_matl = vec3(0.0);\n\n    } else if( (partnum == HEY) || (partnum == FALKEN) ) {  // Static text\n        // Straight 2d\n        // Grid for this part is 9 chars across and 3 high,\n        // offset by half a character vertically.\n        vec2 charpos = uv * vec2(9.0,3.0);\n            //now charpos is 0..8 horz and 0..3 vert\n        charpos.y -= 0.5;    // now -0.5..2.5 vert are on screen\n        charpos *= vec2(GRID_PITCH, GRID_VPITCH);\n            // Now in coordinates of the segments\n\n        do_hey(partnum, charpos, clip_charidx, diffuse_matl);\n            //did_hit stays false so we just use diffuse_matl.\n\n    } else if(partnum == XPORT) {                       // Beam me up\n        diffuse_matl = vec3(0.0);\n        vec3 hitlocn = HitZZero(camera_pos, rayend);\n            // hitlocn is where it hits z=0, where the letters are\n        did_hit = is_in_basic_message(hitlocn.xy, first_charidx, clip_charidx);\n        if(did_hit) {\n            color_xport(hitlocn.xy, uv, the_time - XPORT_START,\n                ambient_matl, diffuse_matl, shininess);\n            did_hit = false;    // only use diffuse_matl\n            //diffuse_matl = vec3(0.0,1.0,0.0); did_hit = false; //DEBUG\n        }\n    } else if(partnum <= LINE2) {      // Basic scrollers, 2d\n\n        vec3 hitlocn = HitZZero(camera_pos, rayend);\n            // hitlocn is where it hits z=0, where the letters are\n        did_hit = is_in_basic_message(hitlocn.xy, first_charidx, clip_charidx);\n        if(did_hit) {\n            wc_pixel = hitlocn;\n            wc_normal = vec3(0.0,0.0,-1.0 + 2.0*step(0.0, camera_pos.z));\n                // normal Z is -1 if camera_pos.z<0.0, and +1 otherwise.\n                // This benefits TWOSIDED.\n            ambient_matl = vec3(0.2, 0.2, 0.1);\n            diffuse_matl = vec3(0.6,0.6,0.3);\n            shininess = 50.0;\n        }  // else diffuse is the default (0,0,0).\n\n    } else {        // Basic scrollers, voxel\n        diffuse_matl = vec3(0.0);\n        vec3 voxel;\n        did_hit =\n            voxel_is_in_message(camera_pos, ray_direction,\n                                  charidx_frac, first_charidx, clip_charidx,\n                                  voxel, wc_pixel, wc_normal);\n        if(did_hit) {\n            diffuse_matl = vec3(0.2, 0.3, 0.9);\n            shininess = 20.0;\n        }\n    } //endif part switch\n\n    // --- Lighting ---\n    // Phong shading based on the Geometry section's output values\n\n    if(did_hit) {               // a hit\n        vec3 rgb = phong_color(\n            wc_pixel, wc_normal, camera_pos, light_pos,\n            ambient_matl, diffuse_matl, vec3(1.0), shininess);\n\n        fragColor = vec4(rgb, 1.0);\n    } else {                    // no hit - just use diffuse_matl\n        fragColor = vec4(diffuse_matl, 1.0);\n    }\n\n} //mainImage\n\n// }}}1\n\n// vi: set ts=4 sts=4 sw=4 et ai foldmethod=marker foldenable foldlevel=0: //\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}