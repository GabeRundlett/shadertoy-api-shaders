{
    "Shader": {
        "info": {
            "date": "1593935984",
            "description": "@samzanemesis\ninspired by a gag chain from twitter\nbox intersection code from https://www.shadertoy.com/view/ld23DV",
            "flags": 0,
            "hasliked": 0,
            "id": "WlBcRm",
            "likes": 2,
            "name": "low poly box (0 triangles)",
            "published": 3,
            "tags": [
                "box",
                "lowpoly",
                "joke"
            ],
            "usePreview": 0,
            "username": "samzanemesis",
            "viewed": 420
        },
        "renderpass": [
            {
                "code": "// @samzanemesis\n// inspired by a gag chain from twitter\n// box intersection code from https://www.shadertoy.com/view/ld23DV\n\nfloat cubeTex[] = float[](\n0.35,0.35,0.35,0.35,0.35,0.35,0.35,0.35,\n0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,\n0.5,0.35,0.5,0.5,0.5,0.5,0.35,0.5,\n0.5,0.35,0.5,0.5,0.5,0.5,0.35,0.5,\n0.5,0.35,0.5,0.5,0.5,0.5,0.35,0.5,\n0.5,0.35,0.35,0.35,0.35,0.35,0.35,0.5,\n0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,\n0.7,0.7,0.7,0.7,0.7,0.7,0.7,0.7);\n\n// https://iquilezles.org/articles/boxfunctions\nvec4 iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\nfloat sampleCubeTexture(vec2 uv)\n{\n    uv += 0.3;\n    uv /= 0.6;\n    return cubeTex[int(uv.x*8.0) + ( int(uv.y*8.0) * 8 ) ];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.4*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n    // rotate and translate box\t\n\tmat4 txi = translate( 0.0, 0.0, 0.0 ); \n    if(iMouse.w > 0.1)\n    {\n    \tmat4 rot = rotationAxisAngle( normalize(vec3(0.0,1.0,0.0)), -iMouse.x * 0.01 );\n    \trot *= rotationAxisAngle( normalize(vec3(1.0,0.0,0.0)), -iMouse.y * 0.01 );\n        txi*= rot;\n    }\n\tmat4 txx = inverse( txi );\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat oid = 0.0;\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{\n\t\tpos = ro + h*rd;\n        if( mod(pos.z,1.0) < 0.02 || mod(pos.x,1.0) < 0.02 )\n        {\n            tmin = h; \n            nor = vec3(0.0,1.0,0.0); \n            oid = 1.0;\n        }\n\t}\n\n\t// trace box\n\tvec3 box = vec3(0.3,0.3,0.3) ;\n\tvec4 res = iBox( ro, rd, txx, txi, box);\n\tif( res.x>0.0 && res.x<tmin )\n\t{\n\t\ttmin = res.x; \n\t\tnor = res.yzw;\n\t\toid = 2.0;\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.3);\n\tif( tmin<100.0 )\n\t{\n\t\tpos = ro + tmin*rd;\n\t\t\n        // Floor\n\t\tfloat occ = 1.0;\n\t\tfloat mate = 1.0;\n\t\tif( oid<1.5 ) // plane\n\t\t{\n\t\t    mate = 0.4;\n\t\t}\t\t\n\t\telse // box\n\t\t{\n            // recover box space data (we want to do shading in object space)\t\t\t\n\t\t    vec3 opos = (txx*vec4(pos,1.0)).xyz;\n\t\t\tvec3 onor = (txx*vec4(nor,0.0)).xyz;\n            mate = abs(onor.x)*sampleCubeTexture(opos.zy) + \n                   abs(onor.y)*0.5 + \n                   abs(onor.z)*sampleCubeTexture(opos.xy);\n\n\t\t}\n\t\t\n        // material * lighting\t\t\n\t\tcol = vec3(mate);\n\t}\n\n\tfragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}