{
    "Shader": {
        "info": {
            "date": "1671865208",
            "description": "Maybe WIP",
            "flags": 0,
            "hasliked": 0,
            "id": "mtfGD4",
            "likes": 3,
            "name": "Volumetric Glorb ",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "Aurcereal",
            "viewed": 144
        },
        "renderpass": [
            {
                "code": "#define XPY 1.7777 // x per y = resx/resy\n\n//TODO\n//create ray intersection not march system for spheres and planes, their surface area coordinates\n//  in their respective area systems (theta, phi) for spherical and (x, y) for cartesian\n//try to create a marched glow, if we can march a step size and get a glow from a source\n//  like in the center of the sphere, that could be some cool volumetric lighting\n\n//current plan:\n//  ray sphere intersection using X = O + normalize(u)d and ||X - C||^2 = R^2\n//  check the closest if cut, check the farther if cut, draw skybox\n//  next - This is the most expensive part I think - we'll send out a stepped ray that'll sample glow\n//  each step, we check if we're exposed to light inside the sphere, if we are we'll add some glow\n//  possible extra bit of glow if we hit the sphere not just dodge it\n//  can maybe put glorb inside sphere for light\n\nvec3 shapeColor;\n\nvec3 accumulateGlow(vec3 ro, vec3 rd, vec4 sphere, float maxDist, float size, float c, float thickness, float insulation)\n{\n    float exposed, d = 0.;\n    vec3 sp, cp, glow = vec3(0.);\n    int steps = min(MAXSTEPS, int(maxDist/size));\n    \n    for(int i=0; i<steps; i++)\n    {\n        d += size;\n        \n        cp = ro + rd*d - sphere.xyz;\n        sp = cartesianToSpherical(cp);\n        exposed = 1.-insulation*smoothstep(c-thickness*.5,c+thickness*.5, sphereFunc(sp.x, sp.y));\n        glow += getGlow(sp.z, 1.0, 1.5) * size * (normalize(cp)*.5+.5) * .7*exposed;\n    }\n    \n    return glow;\n}\n\nfloat hash(vec2 i)\n{\n    i = fract(vec2(293.591, 512.052)*i);\n    i += dot(i, i+47.);//i*i*49.-(i+2.)*53.;\n    return fract((i.x+i.y)*(i.y+i.x*i.x)*exp(-i.x*0.0001));\n}\n\nvec2 dust(vec2 p)\n{\n    //draw circles\n    float centerLen = length(p - vec2(XPY*.5, .5));\n    p = (rot(p, centerLen*.1) - vec2(XPY*.5, .5))*.9 + vec2(XPY*.5, .5);\n    p += t * vec2(0.1, 0.07)*0.15;\n\n    float size = 0.05;\n    \n    vec2 lp = mod(p, size);\n    float id1 = hash(p - lp);\n    float id2 = hash(p - mod(p, size*2.));\n    \n    float d = length(lp + hash(vec2(id1, id2)) * size * 1.7 - vec2(size*.5)) - size*.03 * (1. - id1);\n    \n    //pulse\n    float opacity = clamp(sin(0.05*t+(id1*.2+id2*.8)*14.), 0., 1.);\n    opacity *= smoothstep(0.37, 0.45, centerLen);\n    //opacity *= step(0.1, id1);\n    \n    return vec2(step(d, 0.)*opacity, id1);\n}\n\nvec3 render(vec2 fragCoord)\n{\n    //set time\n    t = iTime;\n    \n    //shape specs\n    vec4 sphere = vec4(0.,0.,0.,2.);\n    float c = 2.1*sin(iTime)+3.3;\n    shapeColor = vec3(.2, .1, .5)+(sin(iTime*.4)*0.5+0.5)*(vec3(.1, .3, .8) - vec3(.2, .1, .5));\n     //maybe make dust volumetric lighting by \n     //checking whether to draw a dust and how bright by taking into account the glow accumulated (just mult dust rand by glow accum), dist travelled, and a rand that has ray pos\n     //look up a glitter tutorial since one of the shadertoy ppl on your playlist did a glitter tutorial\n    \n    //cam specs\n    vec3 camPos = vec3(5.*cos(iTime*1.1), 0.0, 5.*sin(iTime*1.1));                                //HARDCODE cam pos    \n    vec3 fo = normalize(vec3(0.) - camPos), up = vec3(0.0, 1.0, 0.0), ri = cross(fo, up); //assume perp HARDCODE cam space\n    float fovMultX = 1.0, fovMultY = .57735;                                              //HARDCODE fov TRIG\n                              \n    //make rayWS\n    vec3 ray = normalize(vec3(((fragCoord/iResolution.xy)*2.0-1.0) * vec2(fovMultX, fovMultY), 1.0));\n    ray = ray.z * fo + ray.y * up + ray.x * ri;\n    \n    //trace\n    float dist = raySphCutFor(camPos, ray, sphere, c);\n    float glorbDist = raySphFor(camPos, ray, vec4(sphere.xyz, sphere.w * 0.2));\n    \n    //glow\n    vec3 glow = accumulateGlow(camPos, ray, sphere, min(MAXDIST, dist), 0.1, c, 2., .8);\n    \n    //dust\n    float dustAppear = mix(0.04, 0.8, smoothstep(.7, 1.0, glow.x + glow.y + glow.z));//pow((glow.x+glow.y+glow.z)*.5, 4.0);\n    vec2 dustData = dust(fragCoord/iResolution.y);\n    vec3 dust = dustData.x * step(.1, dustData.y+dustAppear*0.7) * dustAppear * vec3(.6); //.3\n    \n    //skybox\n    if(min(dist, glorbDist) >= MAXDIST) { return acos(-ray.y) * .15*shapeColor+glow + dust; }\n    \n    //hit\n    vec3 hitPntLocal = (camPos+ray*dist)-vec3(0.);\n    vec3 unGlowCol = mix(shapeColor, hitPntLocal*.5+.5, sin(iTime)*.3+.4);\n    return dust + mix(unGlowCol+glow, vec3(1.), 1.-max(step(dist, glorbDist),step(MAXDIST, glorbDist)));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 d = vec2(.5, 0.);\n    vec3 col = render(fragCoord);//render(fragCoord + d.xy) + render(fragCoord + d.yx) + render(fragCoord + d.xx) + render(fragCoord + d.yy);\n    //col *= .25;\n    fragColor = vec4(col, 1.0);\n    //fragColor = vec4(dust(fragCoord/iResolution.y).x);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define D2R .0174533\n#define R2D 57.29578\n#define PI 3.14159265\n\n#define MAXSTEPS 100\n#define MAXDIST 100.0\n#define SDEPS 0.05\n#define NORMEPS 0.05\n\n//-=-=- HELP -=-=-\nvec2 rot(vec2 p, float o)\n{\n    vec2 right = normalize(p);\n    vec2 perp = cross(vec3(right, 0.), vec3(0., 0., 1.)).xy;\n    \n    return length(p) * sin(o) * perp + length(p) * cos(o) * right;\n}\n\nfloat t;\n\nvec2 raySph(vec3 ro, vec3 rd, vec4 sphere) //assume all normalized\n{\n    //|| dU + O - C ||^2 = R^2\n    //d^2 + d(2U dot (O-C)) + (O-C)^2 - R^2 = 0\n    \n    float a = 1.0;\n    float b = 2. * dot(rd, ro - sphere.xyz);\n    float c = dot((ro - sphere.xyz),(ro-sphere.xyz)) - sphere.w*sphere.w;\n    \n    //-b/2a +- sqrt(b^2-4ac)/2a\n    \n    float radicand = b*b - 4.*a*c;\n    if(radicand < 0.) return vec2(MAXDIST); //handle unreal\n    \n    return vec2((-b - sqrt(radicand))/(2.*a), (-b + sqrt(radicand))/(2.*a));\n}\n\n//-=-=-=- SPHERE FUNCS -=-=-=-\nfloat f1(float theta, float phi)\n{\n    float time = t;\n    return 4.+sin(phi*5.0+time*(theta+1.)*2.0);\n}\n\nfloat f2(float theta, float phi)\n{\n    float time = t;\n    return 4.+sin(phi*5.0+time*(theta+1.)*2.0) + cos(phi*(3.0+sin(time)*2.0));\n}\n\nfloat f3(float theta, float phi)\n{\n    float time = t*5.0;\n    theta *= 2.0;//+sin(time*.8);\n    phi *= 2.0;\n    return 4.+sin(time*.4)+sin(theta*4.0+time)+1.2*sin(phi*3.0+5.+time*1.5);\n}\n\nfloat f4(float theta, float phi)\n{\n    float time = t*5.0;\n    theta *= 2.0;\n    phi *= 2.0;\n    return 4.+sin(time*.4+sin(theta*10.)*.1+cos(phi*20.)*.1)+sin(theta*4.0+time)+1.2*sin(phi*3.0+5.+time*1.5);\n}\n\nfloat f5(float theta, float phi)\n{\n    float time = t*2.;\n    theta *= 2.0;\n    phi *= 2.0;\n    phi += pow(abs(theta), 0.7) -0.5;\n    return 4.+sin(time*.4+sin(theta*10.)*.1+cos(phi*10.)*.1)+sin(theta*(4.0+sin(phi*12.)*.0)+time)+1.2*sin(phi*(3.0+sin(theta*9.)*.14)+5.+time*1.5);\n}\n\n//-=-=-=-\n\nfloat sphereFunc(float theta, float phi)\n{\n    //f3, f5\n    float i = clamp(sin(.4*t)*1.2+.5, 0., 1.);\n    return f3(theta, phi) * i + (1.-i) * f5(theta, phi);\n}\n\nvec3 cartesianToSpherical(vec3 p)\n{\n    return vec3(atan(p.z, p.x), acos(p.y/length(p)), length(p)); //can rewrite to use arbitrary space\n}\n\nfloat raySphFor(vec3 ro, vec3 rd, vec4 sphere)\n{\n    //get raw dist\n    vec2 rawDists = raySph(ro, rd, sphere);\n    \n    //clamp\n    rawDists += (-rawDists+MAXDIST)*(1.-step(0., rawDists));\n    \n    //return\n    return min(rawDists.x, rawDists.y);\n}\n\nfloat raySphCutFor(vec3 ro, vec3 rd, vec4 sphere, float c) //ray sphere surface cut POSITIVE DIST ONLY\n{\n    //get raw dist\n    vec2 rawDists = raySph(ro, rd, sphere);\n    \n    //clamp\n    rawDists += (-rawDists+MAXDIST)*(1.-step(0., rawDists));\n   \n    //cut\n    vec2 thetaPhi;\n    \n    vec3 p1 = vec3((ro + rd*rawDists.x) - sphere.xyz);\n    thetaPhi = cartesianToSpherical(p1).xy;\n    rawDists.x += (-rawDists.x + MAXDIST)*(1.-step(c, sphereFunc(thetaPhi.x, thetaPhi.y)));\n    \n    vec3 p2 = vec3((ro + rd*rawDists.y) - sphere.xyz);\n    thetaPhi = cartesianToSpherical(p2).xy;\n    rawDists.y += (-rawDists.y + MAXDIST)*(1.-step(c, sphereFunc(thetaPhi.x, thetaPhi.y)));\n    \n    //return\n    return min(rawDists.x, rawDists.y);\n}\n\n//-=-=-=- GLOW -=-=-=-\nfloat getGlow(float d, float radius, float sharpness)\n{\n    return 1.-exp(-pow(radius / d, sharpness));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}