{
    "Shader": {
        "info": {
            "date": "1617546944",
            "description": "Slightly polished version of my Revision 2021 4k Executable Graphics entry ",
            "flags": 32,
            "hasliked": 0,
            "id": "fdSGRy",
            "likes": 117,
            "name": "You Are Here",
            "published": 3,
            "tags": [
                "revision2021"
            ],
            "usePreview": 0,
            "username": "tdhooper",
            "viewed": 3381
        },
        "renderpass": [
            {
                "code": "/*\n\n    You Are Here\n    ------------\n\n    I created this sofa for the room in my Revision 2021 Animated Gif\n    entry, and went a little over the top with detailing so felt it\n    deserved its own 4k Graphics entry!\n    \n    This is modified a little but from the compo version, I've added\n    feet, and made the wood shinier.\n    \n    Massive thanks to yx for sharing her framework, Blossom, without\n    which I probably wouldn't have got this into the competition:\n    \n    https://github.com/lunasorcery/Blossom\n    \n    The edge wrinkles are created by modulating the radius of corners\n    and smooth unions, which is a technique Blackle demonstrated for\n    the welds in 'Bending an SDF':\n    \n    https://www.shadertoy.com/view/3llfRl\n    \n    Surface wrinkles use the same modulation, but as a height map; and\n    the cloth texture is created by warping the whole model with a high\n    frequency sine.\n    \n    Wood grain is concentric circles warped with more sines, which also\n    alters the specular response, as shown by LucaRood:\n    \n    https://twitter.com/LucaRood/status/1375369105327464448\n \n    Clouds are stylised as I knew I couldn't make some that looked\n    as realistic as the models. They are formed by swirling space in\n    a hexagon arrangement, at different scales, over the top of a simple\n    light-to-dark blob.\n \n*/\n\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\n// colour grading from tropical trevor's scripts\n// https://github.com/trevorvanhoof/ColorGrading\nfloat Luma(vec3 color) { return dot(color, vec3(0.2126, 0.7152, 0.0722)); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec4 tex = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n\tvec3 col = tex.rgb / tex.a;\n\n    vec3 uGain = vec3(1.8);\n    vec3 uLift = vec3(.002,-.003,.007)/3.;\n    vec3 uOffset = vec3(.00,.00,.00);\n    vec3 uGamma = vec3(-.25);\n    col = pow(max(vec3(0.0), col * (1.0 + uGain - uLift) + uLift + uOffset), max(vec3(0.0), 1.0 - uGamma));\n    col = pow( col, vec3(1./2.2) );\n    col = aces(col);\n\n    fragColor = vec4(col, 1);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n//========================================================\n// Tools\n//========================================================\n\n#define PI 3.1415926\n\n// HG_SDF\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat vmax2(vec2 v) {\n\treturn max(v.x, v.y);\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\nfloat vmin2(vec2 v) {\n\treturn min(v.x, v.y);\n}\nfloat sum(vec3 v) {\n    return v.x + v.y + v.z;\n}\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sign(t);\n}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax2(min(d, vec2(0)));\n}\nfloat fHalfCapsule(vec2 p, float r) {\n    p.y = max(p.y, 0.);\n    return length(p) - r;\n}\n\nfloat smax(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\n// Rotate on axis, blackle https://suricrasia.online/demoscene/functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\n\nfloat unlerp(float vmin, float vmax, float value) {\n    return clamp((value - vmin) / (vmax - vmin), 0., 1.);\n}\n\nfloat smoothbump(float a, float b, float x) {\n    float c = mix(a, b, .5);\n    return smoothstep(a, c, x) - smoothstep(c, b, x);\n}\n\n\n\n//========================================================\n// Noise\n//========================================================\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n    p += 1.61803398875; // fix artifacts when reseeding\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n// https://suricrasia.online/demoscene/functions/\nvec3 rndunit(float seed) {\n  return normalize(tan(hash31(seed)));\n}\n\n\n\n\n//========================================================\n// Background\n//========================================================\n\nconst float sqrt3 = 1.7320508075688772;\nconst float i3 = 0.5773502691896258;\n\nconst mat2 cart2hex = mat2(1, 0, i3, 2. * i3);\nconst mat2 hex2cart = mat2(1, 0, -.5, .5 * sqrt3);\n\nvoid swirl(inout vec2 p, float scale, float radius, float power, vec2 seed) {\n\n    p += seed;\n    \n    p *= scale;\n\n    mat2 sc = mat2(1,0,0,.785);\n    mat2 sci = inverse(sc);\n    \n    vec2 h = p * sc * cart2hex;\n    vec2 hf = floor(h);\n    float d = 1e12;\n    float c = 0.;\n    float dc;\n    \n    for (int j = -2; j <= 2; j++)\n    for (int i = -2; i <= 2; i++) {\n        vec2 cellId = hf + vec2(i,j);\n        float rnd = hash12(cellId);\n        vec2 hp = cellId * hex2cart * sci;\n    \tdc = length(p - hp);\n        if (dc < d) {\n        \td = dc;\n            c = mix(.1, 1., rnd);            \n        }\n\n        p -= hp;\n        pR(p, smoothstep(radius, 0., length(p)) * power * (rnd * 2. - 1.));\n        p += hp;\n    }\n    \n    p /= scale;\n\n    p -= seed;\n}\n\nvec4 cloudDist(vec2 p, vec2 s, float r, float blur)\n{\n    p /= s;\n    blur = mix(0., blur, smoothstep(r*2., -r*2., p.y));\n    float d = (length(p) - r + blur / 2.) / blur;\n    d = smoothstep(1., 0., d);\n    r += blur / 2.;\n    p /= r;\n    vec3 n = vec3(p, max(0., sqrt(1. - dot(p, p))));\n    return vec4(n, d);\n}\n\n\nvec4 cloud(vec2 p, vec2 s, float r, float blur) {\n    vec4 res = cloudDist(p, s, r, blur);\n    vec3 ld = normalize(vec3(.5,1,.5));\n    float l = dot(res.xyz, ld);\n    l = l * .5 + .5;\n    l = clamp(l, 0., 1.);\n    vec3 col = vec3(l);\n    float a = res.w;\n    return vec4(col, a);\n\n}\n\nvec2 warp(vec2 p, vec2 seed) {\n    p += seed;\n    swirl(p, 4., .3, 8., vec2(0));\n    swirl(p, 2., .3, 6., vec2(.9));\n    swirl(p, 2., .5, 6., vec2(.5));\n    swirl(p, .76, .75, 4., vec2(1. / 4.));\n    swirl(p, 1.72, .75, 3., vec2(1. * .1));\n    //swirl(p, 4., .75, 6., vec2(.5 + 1. / 6.));\n    swirl(p, 6., 1., 5., vec2(.5 + 1. / 6.));\n    p -= seed;\n    return p;\n}\n\n// return distance, and cell id\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash22( n + g );\n\t    vec2  r = g - f + o;\n        float size = hash12( n + g );\n\t\tfloat d = length(r) - mix(-.05, .05, size);\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( m.x, m.y+m.z );\n}\n\nvoid scatterclouds(vec2 p, inout vec4 col) {\n    float smallestDist = 1e12;\n    vec2 closestPoint = vec2(0);\n    vec2 cellId;\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            vec2 cell = round(p) + vec2(x,y);\n            vec2 offset = hash22(cell) * 2. - 1.;\n            vec2 point = cell + offset * .5;\n            float r = hash12(cell);\n            vec4 cl = cloud(p - point, vec2(.2), mix(.5, 2., r), 5.);\n            col.rgb = mix(col.rgb, cl.rgb, cl.w);\n            col.a = max(col.a, cl.a);\n\t\t}\n    }\n}\n\nvec3 skyTex(vec2 p)\n{   \n    p = warp(p, vec2(0));\n    \n    vec2 p2 = p;\n    vec2 p3 = p;\n    \n    swirl(p2, .2, .75, 3., vec2(0.));\n    swirl(p3, .2, .75, 3., vec2(10.));\n    \n    vec4 col = vec4(.5,.5,.5,0);\n\n    vec2 sc = vec2(18.,6.);\n    scatterclouds(p2 / sc, col);\n    scatterclouds(p3 / sc, col);\n\n    return col.rgb;\n}\n\n\n\n\n\n//========================================================\n// Modelling\n//========================================================\n\nstruct Material {\n    vec3 albedo;\n    float specular;\n    float roughness;\n};\n\nstruct Model {\n    float d;\n    vec3 uvw;\n    vec3 albedo;\n    int id;\n};\n\nMaterial shadeModel(Model model, inout vec3 nor) {\n    int id = model.id;\n    vec3 p = model.uvw;\n\n    // floorboards\n    if (id == 2) {\n        vec3 col = mix(model.albedo * vec3(.5,.3,.2), model.albedo + .1, .9);\n        vec2 size = vec2(.1,.02);        \n        vec2 c = floor((p.zx + size / 2.) / size);\n        p.z += mod(c.y, 2.) * size.x * .5;\n        c = floor((p.zx + size / 2.) / size);\n        p.zx = (fract(p.zx / size + .5) - .5);\n        p.zx *= size;\n        c *= size;\n        float d = fBox2(p.zx, size / 2.);\n        float r = hash12((c+120.) * 80.);\n        float r2 = hash12((c+1.) * 60.);\n        col = mix(col / 2., col * vec3(1.05,.95,1.05), r2);\n        col *= mix(.1, 1., smoothstep(.0, -.0006, d));\n        col *= mix(.5, 1., r);\n        vec3 ax = rndunit(r * 5.);\n        //nor = erot(nor, ax, (r * 2. - 1.) * .01);\n        p /= 2.;\n        p += length(sin(sin(p * 100. + r * 10.) * 10.)) * .0005;\n        p.xz += size * (hash22(c * 20.) * 2. - 1.);\n        p.z /= 10.;\n        p = erot(p, ax, (r * 2. - 1.) * 2.2);\n        p += sin((p + r * 100.) * 200.) * .04;\n        d = length(p);\n        d = sin(d * 1500.) * .5 + .5;\n        col *= mix(.5, 1., d);\n        return Material(col, .8, mix(.4, .2, d));\n    }\n\n    return Material(model.albedo, 0., 0.);\n}\n\nvec3 sofasz = vec3(.2, .1, .1) / 2.;\n    \nModel fSofa(vec3 p) {\n    \n    p += sum(sin(erot(p, vec3(1), 1.) * 6000.)) * .000015;\n    \n    float fade, d2, d3, d4, ar, armang, ar0, ar1, arw, footh, psx, vary, baseh, cs, cr, axisx, axisz, crw, seam, buttpatch, br;\n    vec2 armtopp;\n    vec3 isofasz, pp, armsz, pc, col, backsz, cushionsz;\n\n    armsz = vec3(.012,.026,sofasz.z);\n    footh = .0075;\n    isofasz = sofasz - vec3(armsz.x * 2., 0, 0);\n\n    psx = sign(p.x);\n    vary = max(psx, 0.);\n    pp = p;\n\n    // arms\n    p.x = abs(p.x);\n    p.x -= sofasz.x - armsz.x;\n    p.y -= footh - sofasz.y + armsz.y;\n    d2 = fHalfCapsule(p.xy - vec2(0, armsz.y), armsz.x);\n    armtopp = p.xy - vec2(.004, armsz.y + .005);\n    d2 = smin(d2, length(armtopp) - armsz.x - .002, .01);\n    d3 = d2 + armsz.x * .4;\n    ar = .007;\n    armang = atan(armtopp.y, armtopp.x);\n    ar0 = sin(sin(sin(armang) * 10. - vary*2.) * 5. + length(armtopp) * 500. + p.z * 100.);\n    ar1 = sin(sin(sin((p.y + 1.) * 65.) * 10.) * 5. + p.x * 300. + p.z * 100.);\n    arw = mix(ar0, ar1, smoothstep(.01, -.01, p.y - armsz.y / 3.));\n    arw *= smoothstep(0., armsz.z, abs(p.z));\n    fade = mix(.33, 0., arw) * smoothstep(.01, .0, length(vec2(d2, 2. * abs(abs(p.z) - armsz.z + .0035)))) * smoothstep(-.03, .06, p.y);// mix(1., 0., arw) // * mix(.5, 1., smoothstep(.005, 0., abs(abs(p.z) - armsz.z + .005)));\n    d2 = smax(d2 + arw * .0001, abs(p.z) - armsz.z, ar + arw * .0005);\n    d3 = max(d3, -p.z);\n    if (d3 > 0.) {\n        fade = max(fade, smoothbump(.5, 3., mod(armang - .5, PI * 2.)) * smoothbump(-armsz.z / 2., armsz.z * 1.5, p.z)) *  mix(1., .5, arw);\n    }\n    ar = .00725;\n    d4 = smax(d3, abs(p.z) - armsz.z - .003, ar);\n    d2 = smax(d2, -d4, .001);\n    ar += sin(sin(sin((p.y + 1.) * 80.) * 10.) * 5. + p.x * 300.) * .0003;\n    d4 = smax(d3, abs(p.z) - armsz.z - .003, ar);\n    d2 = min(d2, d4);\n    d2 = smax(d2, -p.y - armsz.y, .003);\n\t\n\n    // base\n    p = pp;\n    baseh = .012;\n    p.y -= footh - sofasz.y + baseh;\n    br = .002;\n    br += sin(sin(sin(p.x * 55. + 2.) * 10.) * 5. + p.y * 100.) * .00025;\n\t\n    d3 = fBox(p, vec3(isofasz.x + .0068, baseh, isofasz.z) - br) - br;\n\n    d2 = min(d2, d3);\n    p.x = abs(p.x);\n    p.xy -= vec2(sofasz.x / 2.5, 0.);\n    p.y += sin(p.x * 250.) * .0005;\n    p.xy *= vec2(.4, 1);\n    fade = max(fade, pow(smoothstep(.025, .0, length(p.xy)), 3.)/2.);\n\n\t/*\n    // back\n    p = pp;\n    backsz = vec3(isofasz.x + .001, armsz.y + .005, .005);\n    p.y -= footh - sofasz.y + baseh + backsz.y;\n    p.z -= -sofasz.z + backsz.z;\n    d3 = fBox(p.zyx, backsz.zyx - .006) - .006;\n    d2 = min(d2, d3);\n\t*/\n    // cushion\n    p = pp;\n    p.x = abs(p.x);\n    cushionsz = vec3(isofasz.x / 2. + .001, .01, sofasz.z - .018);\n    p.y -= footh - sofasz.y + baseh * 2. - .001;\n    p.y -= cushionsz.y * 2.;\n    p.x -= isofasz.x / 2.;\n    p.z -= sofasz.z - cushionsz.z * 2. + .005;\n    vary += pReflect(p, normalize(vec3(0,-.66,1)), 0.);\n    p.y += cushionsz.y;\n    p.z -= cushionsz.z - .004;\n\n    cs = mix(.95, 1.01, length(sin(sin((p + vary * 240.) * 30.) * 3.) * .5 + .5));\n    cs = 1. + sum(sin((p + vary * 2. + 1.) * 100.) * vec3(1,0,1)) * .02;\n    cr = .008;\n    axisx = max(vmin2(p.xz), vmin2(-p.xz));\n    axisz = min(vmin2(p.xz), vmin2(-p.xz));\n\t\t\n    crw = sin(sin(sin((axisx + mix(.4, .6, vary)) * (48. + vary)) * 10.) * 5. + p.y * 300. + p.z * 300.);\n    crw *= smoothstep(0., .0005, abs(dot(abs(p.xz), cushionsz.zx * vec2(1,-1))));\n    crw *= unlerp(.5, 1., vmax2(abs(p.xz) / cushionsz.xz));\n    cr += crw * .0003;\n\n    cs += smoothstep(cushionsz.x * 1.2, 0., length(p.xz)) * .4;\n    pc = p;\n    pc.x += sin(pc.z * 150. + vary * 3.) * .02;\n    pR(pc.xz, -vary * .2 + 1.6);\n    buttpatch = sum(sin((sin(2. + vec3(pc.x, pc.y, 0) * 122. * (1. + abs(vary - 1.) * .2)) + vary * 30.) * 8.));\n    \n    buttpatch *= smoothstep(cushionsz.z, 0., length(p.xz));\n    cs += buttpatch * .03;\n\n    d3 = (fBox(p / cs, cushionsz - cr - crw * .0001) - cr) * cs* .9;\n    seam = abs(p.y) - cushionsz.y * .75;\n    d3 = smax(d3, -abs(seam), .001);\n\n    if (d3 < d2) {\n        d2 = d3;\n        fade = 0.;\n        fade += smoothbump(.0, .0015, seam) * mix(.5, .25, crw);\n        fade += smoothbump(.0, .00075, -seam) * mix(.5, .25, crw);\n        fade = max(fade, smoothstep(cushionsz.x * 1.1, 0., length(p.xz)));\n        if (psx < 0.) {\n            fade /= 3.;\n        } else {\n            fade *= 1.2;\n            fade += .1;\n        }\n    }\n    \n\n    col = pow(vec3(0.55,0.29,0.23), vec3(2.2));\n    col = mix(col, vec3(1.,.1,.0) * .05 * 6., .6);\n    col.r -= .05;\n    col.g += .006;\n    col.b += .006;\n    col = mix(col, mix(col * 1.75, vec3(.2), .04), fade);\n\n    return Model(d2, p, col, 15);\n}\n\n\nModel map(vec3 p) {\n    p.x = -p.x;\n\n    Model m = fSofa(p);\n    \n    p.y += sofasz.y;\n    float d = fBox(p, vec3(.14,.003,.14));\n        \n    Model m2 = Model(d, p, vec3(0.714,0.43,0.19), 2);\n    if (m2.d < m.d) m = m2;    \n    \n    p.y -= .0015;\n    p.xz = abs(p.xz);\n    p.xz -= sofasz.xz * vec2(.93,.68);\n    d = min(d, max(fBox(p, vec3(0,.01,0)) - .005, -p.y));  \n    m2 = Model(d, p, vec3(.01), 3);\n    if (m2.d < m.d) m = m2;    \n    \n    return m;\n}\n\n\n//========================================================\n// Rendering\n//========================================================\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 0.0001;\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h).d;\n    }\n    return normalize(n);\n}\n\nvec3 sunPos = normalize(vec3(-5,4,.5)) * 100.;\nvec3 skyColor = vec3(0.50,0.70,1.00);\n\nvec3 env(vec3 dir) {\n    vec3 col = mix(vec3(.5,.7,1) * .05, vec3(.5,.7,1) * 1., smoothstep(-.4, .4, dir.y));\n    vec2 pc = vec2(atan(dir.z, dir.x), dir.y) * 30. - 28.96 * 10.;\n    vec3 cl = skyTex(pc);\n    col *= cl;\n    col += pow(cl, vec3(15.)) * 2.;\n    return col;\n}\n\nstruct Hit {\n    Model model;\n    vec3 pos;\n};\n\nHit march(vec3 origin, vec3 rayDirection, float maxDist, float understep) {\n\n    vec3 rayPosition;\n    float rayLength, dist = 0.;\n    Model model;\n\n    for (int i = 0; i < 200; i++) {\n        rayPosition = origin + rayDirection * rayLength;\n        model = map(rayPosition);\n        rayLength += model.d * understep;\n\n        if (abs(model.d) / rayLength < .0002) break;\n\n        if (rayLength > maxDist) {\n            model.id = 0;\n            break;\n        }\n    }\n    return Hit(model, rayPosition);\n}\n\n// tracing/lighting setup from yx\n// https://www.shadertoy.com/view/ts2cWm\nvec3 ortho(vec3 a){\n    vec3 b=cross(vec3(-1,-1,.5),a);\n    // assume b is nonzero\n    return (b);\n}\n\n// re-borrowed from yx from\n// http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec3 getSampleBiased(vec3  dir, float power, vec2 seed) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = seed;\n\tr.x=r.x*2.*PI;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 getConeSample(vec3 dir, float extent, vec2 seed) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  seed;\n\tr.x=r.x*2.*PI;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\n// main path tracing loop, based on yx's\n// https://www.shadertoy.com/view/ts2cWm\n// with a bit of demofox's\n// https://www.shadertoy.com/view/WsBBR3\nvec4 draw(vec2 fragCoord) {\n\n    vec2 p = (-iResolution.xy + 2.* fragCoord) / iResolution.y;\n    //p /= 2.;\n\n    vec2 seed = hash22(fragCoord + (float(iFrame)) * sqrt3);\n    \n    // jitter for antialiasing\n    p += 2. * (seed - .5) / iResolution.xy;\n\n    vec3 col = vec3(0);\n\n    float focalLength = 6.;\n    vec3 camPos = vec3(.04, .01, .1) * focalLength * 1.2;\n    if (iMouse.x > 0.) {\n        vec2 im = (iMouse.xy / iResolution.xy) - .5;\n        pR(camPos.yz, -im.y * 1.5);\n        pR(camPos.xz, -im.x * PI * 1.5);\n    }\n\n    vec3 camTar = vec3(0);\n    \n    vec3 ww = normalize(camTar - camPos);\n    vec3 uu = normalize(cross(vec3(0,1,0),ww));\n    vec3 vv = normalize(cross(ww,uu));\n    mat3 camMat = mat3(-uu, vv, ww);\n    \n    vec3 rayDir = normalize(camMat * vec3(p.xy, focalLength));\n    vec3 origin = camPos;\n\n    Hit hit = march(origin, rayDir, 1., .9);\n\n    vec3 nor, ref;\n    Material material;\n    vec3 accum = vec3(1);\n    vec3 bgCol = skyColor;\n\n    const int MAX_BOUNCE = 6;\n\n    for (int bounce = 0; bounce < MAX_BOUNCE; bounce++) {\n   \n        if (hit.model.id == 0) {\n            col += env(rayDir) * accum;\n            break;\n        }\n\n        nor = calcNormal(hit.pos);\n        material = shadeModel(hit.model, nor);\n\n        // calculate whether we are going to do a diffuse or specular reflection ray \n        bool doSpecular = hash12(seed) < material.specular;\n\n        // update the colorMultiplier\n       \taccum *= material.albedo;\n\n        // Calculate diffuse ray direction\n        seed = hash22(seed);\n        vec3 diffuseRayDir = getSampleBiased(nor, 1., seed);\n\n        if ( ! doSpecular) {\n            \n            // calculate direct lighting\n            vec3 directLight = vec3(0);\n            seed = hash22(seed);\n\n            vec3 lightDir = (sunPos - hit.pos);\n            vec3 lightSampleDir = getConeSample(lightDir, .005, seed);\n            float diffuse = dot(nor, lightSampleDir);\n            vec3 shadowOrigin = hit.pos + nor * (.0002 / abs(dot(lightSampleDir, nor)));\n            if (diffuse > 0.) {\n                Hit sh = march(shadowOrigin, lightSampleDir, 1., 1.);\n                if (sh.model.id == 0) {\n                    col += accum * vec3(8.10,6.00,4.20)/10. * diffuse;\n                }\n            }\n\n            rayDir = diffuseRayDir;\n        } else {\n            // Calculate specular ray direction\n            vec3 specularRayDir = reflect(rayDir, nor);\n            rayDir = normalize(mix(specularRayDir, diffuseRayDir, material.roughness * material.roughness));\n        }\n\n        // offset from sufrace https://www.shadertoy.com/view/lsXGzH\n        origin = hit.pos + nor * (.0002 / abs(dot(rayDir, nor)));\n        seed = hash22(seed);\n        hit = march(origin, rayDir, 1., 1.);\n    }\n\n\n    return vec4(col, 1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 col = draw(fragCoord);\n    \n    if (iFrame > 0 && iMouse.z <= 0.) {\n        vec4 lastCol = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n        col += lastCol;\n    }\n    \n    fragColor = col;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}