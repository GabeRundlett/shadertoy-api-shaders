{
    "Shader": {
        "info": {
            "date": "1655858162",
            "description": "A raymarched 3D scene with well-annotated rendering functions, for easy adaptation and extension. Includes support for shading and anti-aliasing.",
            "flags": 0,
            "hasliked": 0,
            "id": "7syyRc",
            "likes": 1,
            "name": "3D Test Bench - Solid Shape",
            "published": 3,
            "tags": [
                "sdf",
                "shading"
            ],
            "usePreview": 0,
            "username": "MasterEric",
            "viewed": 193
        },
        "renderpass": [
            {
                "code": "/**\n * A raymarched 3D scene with well-annotated rendering functions,\n * for easy adaptation and extension.\n * Includes support for shading and anti-aliasing.\n * @author MasterEric\n * \n * References:\n * - https://iquilezles.org/articles/distfunctions/\n * - http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n * - https://www.shadertoy.com/view/Wtl3zN\n * - http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n * - https://www.shadertoy.com/view/4tf3WH\n * - https://github.com/electricsquare/raymarching-workshop\n */\n\n// The number of subdivisions of the draw distance we check the raycast at.\n// Higher numbers produce a sharper image.\n#define ITERATIONS 100\n// The distance at which we are considered to be at an object.\n// Smaller numbers produce a sharper image.\n#define MIN_D 0.0001\n// The draw distance.\n// Larger numbers need more iterations to produce a sharp image.\n#define MAX_D 30.0\n\n#define SHADOW_SOFTNESS 10.0\n\n// 1 = sample 1 pixel, no anti-aliasing\n// 2 = sample 2x2 pixels for MSAA\n// 3 = sample 3x3 pixels for MSAA\n#define AA_SAMPLE 2\n\n#define GAMMA 0.4545\n\n// Random junk.\nprecision highp float;\n\n/**\n * UTILITY FUNCTIONS\n */\nfloat dot2(in vec3 v) {\n    return dot(v, v);\n}\n\n/**\n * TRANSFORM FUNCTIONS\n */\n\n// To apply rotation or translation to a mesh,\n// we simply apply a transformation to the point being sampled.\n// This function rotates a point about an arbitrary axis by the given angle.\nvec3 rotate(vec3 point, vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    mat4 rotMatrix = mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0, oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0, oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c, 0.0, 0.0, 0.0, 0.0, 1.0);\n\n    vec3 result = (rotMatrix * vec4(point, 1.0)).xyz;\n\n    return result;\n}\n\n// This function translates a point by a given vector.\nvec3 translate(vec3 point, vec3 transform) {\n    return point + transform;\n}\n\n// Combine two shapes into one.\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\nvec2 opUnion( vec2 d1, vec2 d2 ) { return min(d1,d2); }\nvec3 opUnion( vec3 d1, vec3 d2 ) { return min(d1,d2); }\nvec4 opUnion( vec4 d1, vec4 d2 ) { return min(d1,d2); }\n\n// Subtract one shape from another shape.\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nvec2 opSubtraction( vec2 d1, vec2 d2 ) { return max(-d1,d2); }\nvec3 opSubtraction( vec3 d1, vec3 d2 ) { return max(-d1,d2); }\nvec4 opSubtraction( vec4 d1, vec4 d2 ) { return max(-d1,d2); }\n\n// Returns only the space where two shapes only overlap.\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\nvec2 opIntersection( vec2 d1, vec2 d2 ) { return max(d1,d2); }\nvec3 opIntersection( vec3 d1, vec3 d2 ) { return max(d1,d2); }\nvec4 opIntersection( vec4 d1, vec4 d2 ) { return max(d1,d2); }\n\n// Returns the space where only one shape (not both) exist.\nfloat opXor( float d1, float d2 ) { return max(-min(d1, d2), max(d1, d2)); }\nvec2 opXor( vec2 d1, vec2 d2 ) { return max(-min(d1, d2), max(d1, d2)); }\nvec3 opXor( vec3 d1, vec3 d2 ) { return max(-min(d1, d2), max(d1, d2)); }\nvec4 opXor( vec4 d1, vec4 d2 ) { return max(-min(d1, d2), max(d1, d2)); }\n\n// NOTE TO SELF: To scale a mesh:\n// divide the input point by the scale factor,\n// then multiply the result by the scale factor.\n\n/*\n * SHAPE FUNCTIONS\n */\n\n// signed distance to a sphere\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// signed distance to an infinite 2D plane\nfloat sdPlane(vec3 p) {\n    return p.y;\n}\n\n// Unsigned distance to a trangle (with vertices a, b, c)\nfloat udTriangle(vec3 p, vec3 a, vec3 b, vec3 c) {\n    vec3 ba = b - a;\n    vec3 pa = p - a;\n    vec3 cb = c - b;\n    vec3 pb = p - b;\n    vec3 ac = a - c;\n    vec3 pc = p - c;\n    vec3 nor = cross(ba, ac);\n\n    return sqrt((sign(dot(cross(ba, nor), pa)) +\n        sign(dot(cross(cb, nor), pb)) +\n        sign(dot(cross(ac, nor), pc)) < 2.0) ? min(min(dot2(ba * clamp(dot(ba, pa) / dot2(ba), 0.0, 1.0) - pa), dot2(cb * clamp(dot(cb, pb) / dot2(cb), 0.0, 1.0) - pb)), dot2(ac * clamp(dot(ac, pc) / dot2(ac), 0.0, 1.0) - pc)) : dot(nor, pa) * dot(nor, pa) / dot2(nor));\n}\n\n// Signed distance to an n-sided polygon\n// Via: https://math.stackexchange.com/questions/1641859/distance-function-for-n-prism\nfloat sdNGon(int nSides, vec2 pos, float radius) {\n    // these 2 lines can be precomputed\n    float an = 6.2831853 / float(nSides);\n    float he = radius * tan(0.5 * an);\n\n    // rotate to first sector\n    pos = -pos.yx; // if you want the corner to be up\n    float bn = an * floor((atan(pos.y, pos.x) + 0.5 * an) / an);\n    vec2 cs = vec2(cos(bn), sin(bn));\n    pos = mat2(cs.x, -cs.y, cs.y, cs.x) * pos;\n\n    // side of polygon\n    return length(pos - vec2(radius, clamp(pos.y, -he, he))) * sign(pos.x - radius);\n}\n\n// Signed distance to an n-sided 2D plane\nfloat sdNPlane(int nSides, vec3 pos, float radius) {\n    return sdNGon(nSides, pos.xy, radius);\n}\n\nfloat sdNPrism(int nSides, vec3 pos, float radius, float height) {\n    // for the distance result of any 2D SDF, returns a 3D prism for the 3rd axis position value v\n    float d2d = sdNGon(nSides, pos.xy, radius);\n    vec2 d = vec2(d2d, abs(pos.z) - 0.5 * height);\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// signed distance to a cube with side length b\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n/**\n * SCENE FUNCTIONS\n */\n\n// Number of objects in the scene.\n#define OBJECT_COUNT 4\n\n// Collection of object distances in the scene.\nfloat distS[OBJECT_COUNT];\n\nfloat map(in vec3 pos) {\n    // The stored result.\n    float result = MAX_D;\n\n    // For each shape, we check if it's closer than a shape we've already evaluated.\n\n    // Ground plane.\n    result = opUnion(result, sdPlane(pos - vec3(0.0, 0.0, 0.0)));\n\n    // Sphere.\n    float customShape = sdSphere(pos - vec3(0.0, 0.75, 0.0), 0.5);\n    customShape = opSubtraction(sdSphere(pos - vec3(0.25, 1.0, 0.5), 0.5), customShape);\n    result = opUnion(result, customShape);\n\n    return result;\n}\n\n/**\n * RENDER FUNCTIONS\n */\n\n// Applies a soft shadow effect to the scene.\nfloat softShadow(in vec3 ro, in vec3 rd, float mint, float maxt) {\n    float res = 1.0;\n    float ph = 1e20;\n    for(float t = mint; t < maxt;) {\n        float h = map(ro + rd * t);\n        if(h < 0.001)\n            return 0.0;\n        float y = h * h / (2.0 * ph);\n        float d = sqrt(h * h - y * y);\n        res = min(res, SHADOW_SOFTNESS * d / max(0.0, t - y));\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n// Renders the scene using a ray-marching algorithm.\nfloat castRay(vec3 rayOrigin, vec3 rayDir) {\n    vec3 rayPosition = rayOrigin;\n    float inc = 0.0;\n    float dist = 0.0;\n\n    for(int i = 0; i < ITERATIONS; i++) {\n        // Increment the ray position.\n        rayPosition = rayOrigin + dist * rayDir;\n\n        // Get the distance from the ray position to the closest object.\n        // When the distance is less than MIN_D, we have hit an object.\n        // inc = map(rayPosition);\n\n        inc = map(rayPosition);\n\n        // Increase the distance for the next iteration.\n        // The distance we move along the ray is equal to the distance to the closest object.\n        // This improves performance by skipping large distances but has performance issues if you skim past an edge.\n        dist += inc;\n\n        // If we've reached the maximum distance, return -1.\n        if(dist > MAX_D)\n            return -1.0;\n\n        // If we've hit an object, exit the loop.\n        if(inc < MIN_D)\n            break;\n    }\n\n    return dist;\n}\n\nfloat ambientOcclusion(in vec3 pos, in vec3 nor) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float h = 0.001 + 0.15 * float(i) / 4.0;\n        float d = map(pos + h * nor);\n        occ += (h - d) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 1.5 * occ, 0.0, 1.0);\n}\n\nvec3 normal(in vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy) +\n        e.yyx * map(pos + e.yyx) +\n        e.yxy * map(pos + e.yxy) +\n        e.xxx * map(pos + e.xxx));\n}\n\nvec3 gamma(vec3 col) {\n    return pow(col, vec3(GAMMA));\n}\n\nvec3 render(vec3 rayOrigin, vec3 rayDir) {\n    vec3 resultColor = vec3(0.0);\n\n    float t = castRay(rayOrigin, rayDir);\n\n    if(t >= 0.0) {\n        vec3 position = rayOrigin + t * rayDir;\n        vec3 normal = normal(position);\n\n        // Material color\n        // TODO: Add support for multiple materials.\n        vec3 material = vec3(0.3);\n\n        vec3 lightPosition = normalize(vec3(0.0, 0.3, 0.5));\n\n        vec3 hal = normalize(lightPosition - rayDir);\n\n        // Calculate and apply the diffuse.\n        float diffuse = clamp(dot(normal, lightPosition), 0.0, 1.0) *\n            softShadow(position, lightPosition, 0.01, 3.0);\n        resultColor = material * 4.0 * diffuse * vec3(1.00, 0.70, 0.5);\n\n        // Calculate and apply the specular.\n        float specular = pow(clamp(dot(normal, hal), 0.0, 1.0), 16.0) *\n            diffuse *\n            (0.04 + 0.96 * pow(clamp(1.0 + dot(hal, rayDir), 0.0, 1.0), 5.0));\n        resultColor += 12.0 * specular * vec3(1.00, 0.70, 0.5);\n\n        // Calculate and apply ambient light.\n        float occ = ambientOcclusion(position, normal);\n        float ambient = clamp(0.5 + 0.5 * normal.y, 0.0, 1.0);\n        resultColor += material * ambient * occ * vec3(0.0, 0.08, 0.1);\n\n        // Apply black fog based on distance.\n        resultColor *= exp(-0.0005 * t * t * t);\n    }\n\n    return resultColor;\n}\n\n// Given an XYZ camera position, and an XYZ camera focus, and the current position in screen space,\n// determine the direction of our raycast.\n// Includes a parameter to modify the camera roll.\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget, float camRoll)\n{\n    // Calculate camera's \"orthonormal basis\", i.e. its transform matrix components\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 cameraAngle = vec3(sin(camRoll), cos(camRoll), 0.0);\n    vec3 camRight = normalize(cross(cameraAngle, camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 2.0;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\n// Determines the ray position and direction,\n// and performs the render() function.\n// \nvec3 antiAliasedRender(vec2 fragCoord, vec3 cameraPosition, vec3 cameraFocus, float cameraRoll) {\n    vec3 resultColor = vec3(0.0);\n\n    #if AA_SAMPLE > 1\n\n    for(int m = 0; m < AA_SAMPLE; m++) {\n        for(int n = 0; n < AA_SAMPLE; n++) {\n            vec2 aaOffset = vec2(float(m), float(n)) / float(AA_SAMPLE) - 0.5;\n            vec2 normalizedScreenCoord = (-iResolution.xy + 2.0 * (fragCoord + aaOffset)) / iResolution.y;\n\n            // ray direction\n            vec3 rayDirection = getCameraRayDir(normalizedScreenCoord, cameraPosition, cameraFocus, cameraRoll);\n\n            // render\t\n            vec3 col = render(cameraPosition, rayDirection);\n\n\t    \t// Correct colors by applying gamma\n            col = pow(col, vec3(0.4545));\n\n            resultColor += col;\n        }\n    }\n    resultColor /= float(AA_SAMPLE * AA_SAMPLE);\n\n    #else\n\n    vec2 normalizedScreenCoord = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n    vec3 rayDirection = getCameraRayDir(normalizedScreenCoord, cameraPosition, cameraFocus, cameraRoll);\n    vec3 col = render(cameraPosition, rayDirection);\n\n\t// Correct colors by applying gamma\n    resultColor = pow(col, vec3(0.4545));\n\n    #endif\n\n    return resultColor;\n}\n\n/**\n * MAIN FUNCTION\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Easy variables to manipulate the camera and the resulting scene.\n    float cameraRoll = 0.0;\n    float cameraSpinRate = 2.0;\n    float cameraHeight = 1.14;\n\n    // The point the camera focuses its view on.\n    vec3 cameraFocus = vec3(0.0, 1.0, 0.0);\n\n    // The point the camera is currently looking from.\n    float cameraAngle = 3.0 + (sin(iTime) * 8.0);\n\n    vec3 cameraPosition = vec3(3.0, cameraHeight, -3.0);\n\n    // By multipying the X and Z by the cosine and sine,\n    // we rotate the cameraPosition around the origin.\n    cameraPosition.x *= cos(0.1 * cameraAngle);\n    cameraPosition.z *= sin(0.1 * cameraAngle);\n\n    vec3 resultColor = antiAliasedRender(fragCoord, cameraPosition, cameraFocus, cameraRoll);\n\n    fragColor = vec4(resultColor, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}