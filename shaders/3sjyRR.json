{
    "Shader": {
        "info": {
            "date": "1585954674",
            "description": "Simple chocolate waterfall using traditional raymarching methods",
            "flags": 0,
            "hasliked": 0,
            "id": "3sjyRR",
            "likes": 2,
            "name": "Chocolate Waterfall",
            "published": 3,
            "tags": [
                "raymarching",
                "chocolate"
            ],
            "usePreview": 0,
            "username": "propagant",
            "viewed": 462
        },
        "renderpass": [
            {
                "code": "// By Matej Vanco 2020 - for educational purposes & for fun!\n\n#define MAX_RENDER 64\n#define MIN_RENDER 16.\n#define EPSILON 0.001\n\nstruct ray\n{\n\tvec3 o;\n    vec3 d;\n    float l;\n};\n\n//---Iq's smooth opu\nvec4 opu(vec4 a, vec4 b)\n{\n    float k = 0.35;\n    float d1 = a.w;\n    float d2 = b.w;\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return vec4(mix(b.rgb,a.rgb,h),mix( d2, d1, h ) - k*h*(1.0-h));\n}\n\n//---'Geometry' calculation\nvec4 geo(vec3 p)\n{   \n    float fsin = sin(iTime * 1. + p.y * 8.); //---'Chocolate effect'\n\tvec4 s = vec4(vec3(0.5,0.3,0.1)*0.5, pow(length(p - vec3(fsin*0.5,0.2,1.5)) - 0.2,2.)); //---'Sphere'\n\n    vec4 pp = vec4(vec3(0.5,0.3,0.1)*0.2, p.y + 0.25); //---Ground\n    \n    vec4 g0 = opu(s,pp); //---Combine\n    return g0;\n}\n\n//---Normals calculation\nvec3 normal(vec3 p)\n{\n\tvec2 of = vec2(EPSILON,0.);\n    float copy = geo(p).w;\n    return normalize(copy - vec3(geo(p - of.xyy).w, geo(p - of.yxy).w, geo(p - of.yyx).w)); //---Subtract from copy\n}\n\n//---Soft shadows\nfloat shadow(vec3 ro, vec3 rd, float b)\n{\n\tfloat t = EPSILON;\n    float r = 1.;\n    for(int i = 0; i < 16; i++)\n    {\n        float g = geo(ro + rd * t).w;\n        r = min(r, b * g / t);\n        t += g;\n        if(g < EPSILON)\n            break;\n        \n        if(g >= 4.)\n            break;\n    }\n    return clamp(r,0.4,1.);\n}\n\n//---Traditional Lambert lighting model + Phong reflection specular\nfloat lighting(vec3 p)\n{\n\tvec3 lpos = vec3(2.5,2.5,-2.5);\n    vec3 lposVec = normalize(p - lpos);\n    vec3 n = normal(p);\n    \n    float spec = pow(max(dot(p, reflect(lposVec,n))*1.5,1.0),2.);\n    \n    float light = clamp(dot(lposVec, p),0.,1.) * shadow(p, lpos,0.4) * spec;\n    return light;\n}\n\n\n//---Ray-march\nvec4 march(ray r)\n{\n\tvec3 col = vec3(1.);\n    for(int i = 0; i < MAX_RENDER; i++)\n    {\n        vec3 p = r.o + r.d * r.l;\n        vec4 g = geo(p);\n        r.l += g.w;\n        col = g.rgb;\n    \tif(r.l > MIN_RENDER)\n        \tbreak;   \n    }\n    return vec4(col, r.l);\n}\n\n// Final img\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    ray r;\n    r.o = vec3(0.);\n    r.d = vec3(uv, 1.);\n    vec4 m = march(r);\n    vec3 col = m.rgb * lighting(r.o + r.d * m.w);\n    col*=exp(-0.1 * m.w * m.w * m.w); //---Fog\n    if(m.w > 2.5)\n        col = mix(col,vec3(0.5,0.3,0.), uv.y+0.2); //---'Gradient' background\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}