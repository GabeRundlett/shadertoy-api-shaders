{
    "Shader": {
        "info": {
            "date": "1545259958",
            "description": "This is a rainbow gradient from blue on the left to red on the right. It's basically the code from \"heatmap generation\" by uynet, deconstructed by me with once again lots and lots and lots of comments. Time element added for flash.",
            "flags": 0,
            "hasliked": 0,
            "id": "wdsGz4",
            "likes": 2,
            "name": "craving a slice of ùõë",
            "published": 3,
            "tags": [
                "gradient",
                "rainbow",
                "gradation",
                "timebased"
            ],
            "usePreview": 0,
            "username": "_kitzume_",
            "viewed": 787
        },
        "renderpass": [
            {
                "code": "// FRAGMENT SHADER for ShaderToy\n\n////////////////////////////////////////////////////\n//                                               //\n//         Code partially based on             //\n//      \"heatmap generation\" by uynet        //\n//  https://www.shadertoy.com/view/WslGRN  //\n//                                          //\n//         Code edited by ‚´∂‚´∑‚à∂‚ä§‚´ì‚à™‚à©‚ÑÆ.           //\n//      Comments composed by ‚´∂‚´∑‚à∂‚ä§‚´ì‚à™‚à©‚ÑÆ.         //\n//                                             //\n//////////////////////////////////////////////////\n\n// #include math.h  \n// ERROR : Invalid Directive: include\n/* \"Shaders can't read files and thus, you will never find an include \n    statement in one.\"\n*/\n\n// Pi calculated out to 360 decimal places!\n// float pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481117450284102701938521105559644622948954930381964428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273724587006606315588174881520920962829254091715364367892590360;\n// ERROR: token too long (Oddly, KodeLife seems to be okay with this super long value.)\n\n/* \"Using pi(ùõë) calculated out to only 39 decimal places would allow one \n    to compute the circumference of the entire universe to the accuracy of \n    less than the diameter of a hydrogen atom. As it turns out, it‚Äôs totally \n    overkill to get that precise with it. Dividing 22 by 7 gives an estimate \n    that works for most everyday needs, such as carpentry and construction \n    (it‚Äôs roughly 99% accurate).\"\n*/\n\n   float pi = 3.141592653589793238462643383279502884197;\n\n// float  ùõë = 3.141592653589793238462643383279502884197;\n\n/* ShaderToy doesn't seem to mind if I use ùõë as a variable name, but KodeLife \n   converts the ùõë to a ? and complains that there is a syntax error. Since I like\n   to port, I will stay away from special characters in variable names. They are\n   too hard to type anyways.\n*/\n\n/* Definition of pi used in math.h C library:\n\n     #define M_PI 3.1415926535897932384;\n\n   \"Dividing 22 by 7 gives an estimate that works for most everyday needs.\n\n     #define M_PI 3.142857142857143;\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n /* fragCoord (or gl_fragCoord) is a special read-only input variable \n    with global scope (available to both the CPU and the GPU). fragCoord\n    can only be referenced from within a fragment shader.\n */\n\n    vec2 pixelCoord = fragCoord.xy/iResolution.xy; \n /* pixelCoord normalizes the x,y values of fragCoord to be between 0 and 1.\n\n        The x coordinate represents the horizontal value.\n        When x = 0, the pixel is on the leftmost side of the screen.\n        When x = 1, the pixel is on the rightmost side of the screen.\n        \n        The y coordinate represents the vertical value.\n        When y = 0, the pixel is at the bottom of the screen.\n        When y = 1, the pixel is at the top of the screen.\n */\n        \n    float R = 0.0;\n    float G = 0.0;\n    float B = 0.0;\n    \n    vec3 color = vec3 ( R, G, B);   // initializing color to black\n\n/* color represents the mixed RGB color, which is later passed to fragColor\n    The individual values can also be referenced as:\n\n        color.r = red\n        color.g = green\n        color.b = blue\n*/       \n    \n// This is where the fun begins.     :)\n    \n//  R = 3.143141592653589793238462643383279502884197;\n//  R = pi;\n//  R = ùõë;\n//  R = pi/2.0;\n//  R = 1.57;\n/*  The lines above all create a completely red screen because the maximum \n    value of a color in fragColor is 1.\n*/\n    \n//  R = pixelCoord.x;\n/*  The code above produces a smooth, even gradient from black on the left \n    to red on the right.\n*/\n\n//  R = pixelCoord.x * pi;   \n/*  The code above creates a screen where the leftmost 1/3 of the screen is a black to red \n    gradient while the rightmost side is completely red. (pi * 0.318 = 1, therefore for every x\n    coordinate pixel between 0.318 and 1, when multiplied by pi, the value is greater than 1 and\n    thus a solid red.\n*/\n\n//  R = pixelCoord.x * (pi/2.0) ; \n/*  The maximum value of ùõë/2 is roughly 1.57, this makes the black to red gradient on \n    the left-hand side of the screen cover roughly 2/3. Smart! Because it approximates\n    the beautiful GOLDEN RATIO ! üí© (Nothing shitty here. Just want to see if I can \n    use emojis in the comments of my code.) The Greek letter phi œÜ \"varphi\" or \n    œï \"phi\" represents the golden ratio. The golden ration = 1.61803398875.\n*/\n\n//  R = pixelCoord.x/2.0;\n/*  Gradient is in the middle and begins with black on the left up to maroon on the right. */\n\n// R = 0.5;\n/* Entire screen is maroon. */\n\n// R = sin(pixelCoord.x*(pi));\n/* Black on the left, red in the middle, black on the right. Why?\n   The x coordinate has a range from 0 to 1.\n\n\t0 * 3.14 = 0\n\t1 * 3.14 = 3.14\n\n   Therefore the range of x * pi is 0 to 3.14.\n\n\tThe sin(0) = 0 \n\tThe sin(3.14) = 0.05\n\n   0 = black and 0.05 is close enough to 0 to be black to the human eye.\n\n   The middle of the screen, where it is bright red, has an x-coordinate of 0.5.\n\n\t0.5 * 3.14 = 1.57\n\n\tsin(1.57) = 0.03\n\n   I‚Äôm lost. 0.03 is closer to black than 0.05, so why is it red in the middle?\n*/\n\n// R = sin(pixelCoord.x*pi/2.0) ;\n   R = sin(pixelCoord.x*pi/2.0) * abs(cos(iTime)) ;\n\n\n// G = pixelCoord.x*pi ;\n// G = pixelCoord.x*(pi) ;\n// G = sin(iTime); \n// G = sin(pixelCoord.x*(pi));\n\n// G = sin(pixelCoord.x*(pi)) ;\n   G = sin(pixelCoord.x*(pi)) * abs(cos(iTime)) ;\n\n    \n// B = pixelCoord.x;  // evenly distributed gradient from black (left) to blue (right)\n// B = cos(pixelCoord.x);  // nearly a completely blue screen, slightly dimmer on right edge\n/* The cosine of 0 is 1.\n   The cosine of 1 is 0.999847695156391.\n*/\n// B = cos(pixelCoord.x*(pi));  \n// B = cos(pixelCoord.x*pi);\n// B = cos(pixelCoord.x*pi/2.0);\n\n// B = cos(pixelCoord.x*pi/2.0) ;\n   B = cos(pixelCoord.x*pi/2.0) * abs(cos(iTime));\n\n    \n    color = vec3 ( R, G, B);\n\n\n// Output to screen\n\n    fragColor = vec4 (color,1.0);\n\n// This part is for testing purposes to see what each of the color values are doing standalone. \n\n//   fragColor = vec4 (color.r, 0.0, 0.0, 1.0); // red channel\n//   fragColor = vec4 (0.0, color.g, 0.0, 1.0); // green channel\n//  fragColor = vec4 (0.0, 0.0, color.b, 1.0); // blue channel\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}