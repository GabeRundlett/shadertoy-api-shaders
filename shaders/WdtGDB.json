{
    "Shader": {
        "info": {
            "date": "1569240748",
            "description": "Learning ray marching and calculate light to make a sphere.",
            "flags": 0,
            "hasliked": 0,
            "id": "WdtGDB",
            "likes": 1,
            "name": "Learning Ray Marching Sphere ",
            "published": 3,
            "tags": [
                "ray",
                "sphere",
                "marching",
                "chun"
            ],
            "usePreview": 0,
            "username": "chunza2542",
            "viewed": 346
        },
        "renderpass": [
            {
                "code": "#define NO_OF_STEP 100\n#define MIN 0.001\n#define MAX 1000.\n\n// Get Distance of the sphere\nfloat get_dist(vec3 p) {\n    // define sphere location and radius\n    vec3 loc = vec3(0, 1. + 2. * abs(sin(iTime * 3.)), 7);\n    float r = 1.0;\n    \n    // sphere dist and plane dist\n    float s_dist = length(p - loc) - r;\n    float p_dist = p.y;\n    \n    float d = min(s_dist, p_dist);\n    return d;\n}\n\n// Implement ray marching\nfloat ray_march(vec3 ro, vec3 rd) {\n    float dist = 0.;\n    \n    for (int i = 0; i < NO_OF_STEP; ++i) {\n     \tvec3 point = ro + dist * rd;\n        float d = get_dist(point);\n        \n        dist += d;\n        \n        if (d <= MIN || d >= MAX) break;\n    }\n    \n    return dist;\n}\n\nvec3 get_normal(vec3 p) {\n\tfloat d = get_dist(p);\n  \t// calculate normal\n    vec2 e = vec2(.01, 0);\n    vec3 n = d - vec3(\n    \tget_dist(p - e.xyy),\n        get_dist(p - e.yxy),\n        get_dist(p - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat get_diffuse_light(vec3 p) {\n    vec3 light_pos = vec3(4. + 4. * cos(iTime / 10.), 5., 4. + 2. * sin(iTime / 10.));\n    // get light and normal vector\n    vec3 l = normalize(vec3(light_pos - p));\n  \tvec3 n = get_normal(p);\n    float dif = clamp(dot(l, n), 0., 1.);\n    \n    // calculate the shadow\n    float d = ray_march(p + n * MIN, l);\n    if (d < length(light_pos - p)) {\n     \tdif *= 0.1;\n    }\n    \n    return dif;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // camera position\n    vec3 ro = vec3(0, 1, 0);\n    // ray direction\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = ray_march(ro, rd);\n    \n    // calculate the light\n    vec3 p = ro + rd * d;\n    float l_dif = get_diffuse_light(p);\n    vec3 col = vec3(l_dif);\n\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}