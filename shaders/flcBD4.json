{
    "Shader": {
        "info": {
            "date": "1663107514",
            "description": "curvastic experience with a lot of twistic rotations",
            "flags": 32,
            "hasliked": 0,
            "id": "flcBD4",
            "likes": 22,
            "name": "Baroque Fractal Pattern",
            "published": 3,
            "tags": [
                "gold",
                "baroque"
            ],
            "usePreview": 0,
            "username": "leon",
            "viewed": 378
        },
        "renderpass": [
            {
                "code": "\n// Baroque Fractal Pattern\n// a golden wood baroque painting frame pattern generator\n//\n// previous iterations:\n// https://www.shadertoy.com/view/NddSWs\n// https://www.shadertoy.com/view/ftcBW8\n// https://www.shadertoy.com/view/fsdfW8\n// https://www.shadertoy.com/view/7syXDy\n// https://www.shadertoy.com/view/fdd3Ws\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 data = texture(iChannel0, uv);\n    float total = data.a;\n    vec4 color = vec4(0);\n    \n    if (total > .001 && total < max_dist)\n    {\n        // lighting\n        float shade = data.r;\n        float timeline = data.g;\n        float mat = data.b;\n        data = texture(iChannel1, uv);\n        vec3 normal = data.xyz;\n        float ao = data.a;\n        vec3 light = normalize(vec3(0,1,2));\n        float lamp = dot(normal, light)*.5+.5;\n        float gray = (1.-ao)*lamp;\n        gray += .25*pow(lamp, 40.);\n        gray *= .7+.3*smoothstep(.1,0.,ao);\n        color = mix(vec4(0.239,0,0,1),vec4(0.996,0.863,0.384,1),gray);\n        color *= shade;\n    }\n    else\n    {\n        // background\n        color = vec4(1) * smoothstep(2., -2., length(uv-.5));\n    }\n    \n    fragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// globals\nconst float delay = 15.;\nfloat timeline, mat;\n\nfloat map(vec3 p)\n{\n    float dist = 100.;\n    float shape = 100.;\n    float t = timeline;\n    float w = fract(t/delay);\n    \n    // shape parameters\n    float a = 1.;\n    float n = 196.+t*.2;\n    float r = 1.;\n    float f = 1.7;\n    float b = 1.;\n    float s = .05;\n    const float count = 8.;\n    \n    for (float i = 0.; i < count; ++i)\n    {\n        p.xy *= rot(n/a);\n        p.yz *= rot(n*a);\n        p.x = abs(p.x)-r*a;\n        shape = length(p)-s*a;\n        mat = mix(i, mat, smoo(dist, shape, b*a));\n        dist = smin(dist, shape, b*a);\n        a /= f;\n    }\n    \n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/R.xy;\n    vec4 frame = texture(iChannel0, uv);\n    \n    const float count = 3.;\n    for (float frames = 0.; frames < count; ++frames)\n    {\n        // init globals\n        float f = float(iFrame) * 123. + frames * 196.;\n        vec3 rng = hash(uvec3(fragCoord, f));\n        timeline = rng.x*.1+iTime;\n        mat = 0.;\n\n        // raymarch\n        vec2 p = 1.*(fragCoord-R.xy/2.)/R.y;\n        vec3 pos = vec3(0,0,10.);\n        vec3 ray = normalize(vec3(p, -4));\n        float total = 0.;\n        float steps = 0.;\n        const float count = 20.;\n        for (steps = count; steps > 0.; --steps) {\n            float dist = map(pos);\n            if (dist < .001 * total || total > max_dist) break;\n            total += dist;\n            pos += ray * dist;\n        }\n\n        // draw if closer\n        if (total < max_dist && (total < frame.a || frame.a < .001))\n        {\n            // data pack\n            float shade = steps/count;\n            float time = fract(timeline/delay);\n            fragColor = vec4(shade, time, mat, total);\n            frame = fragColor;\n        }\n        else\n        {\n            // store result\n            fragColor = frame;\n        }\n    }\n    \n    // wipe\n    fragColor *= step(.01, fract(iTime/delay));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define R iResolution\n#define T(uv) texture(iChannel0, uv).a\nconst float max_dist = 20.;\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n// Inigo Quilez https://iquilezles.org/articles/distfunctions/\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat smoo( float d1, float d2, float k )\n{\n     return clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n}\n\n// Victor Shepardson + Inigo Quilez \n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n// compute ao and normal\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    \n    // ao\n    float ao = 0.;\n    const float count = 6.;\n    for (float f = 0.; f < count; ++f)\n    {\n        vec3 rng = hash(uvec3(fragCoord, float(iFrame)+196.*f));\n        vec2 offset = 20.*rng.z*normalize(rng.xy*2.-1.)/R.xy;\n        float total = texture(iChannel0, uv+offset).r;\n        ao += 2.*abs(color.r - total)/count;\n    }\n    \n    float frame = texture(iChannel1, uv).a;\n    fragColor.a = mix(frame, ao, .1);\n    \n    // normal\n    vec3 unit = vec3(1./R.xy, 0);\n    float w = T(uv+unit.xz);\n    float e = T(uv-unit.xz);\n    float n = T(uv+unit.zy);\n    float s = T(uv-unit.zy);\n    bool edge = w * e * n * s < .001;\n    if (color.a > .001 && color.a < max_dist && !edge)\n    {\n        vec3 normal = normalize(vec3(w-e, n-s, unit.y));\n        fragColor.rgb = normal;\n    }\n    else\n    {\n        fragColor.rgb = vec3(0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}