{
    "Shader": {
        "info": {
            "date": "1558672056",
            "description": "ray tracing ",
            "flags": 0,
            "hasliked": 0,
            "id": "3t2GRD",
            "likes": 4,
            "name": "ray tracing the next  week",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "littlebird",
            "viewed": 580
        },
        "renderpass": [
            {
                "code": "precision  highp float;\n\n#ifdef LOC_SHADER\nuniform vec2 iResolution;\nout vec4 FragColor;\nuniform samplerCube skybox;\nuniform sampler2D cacheImage;\nuniform vec3 iCameraPos;\nuniform vec3 iCameraDir;\nuniform vec3 iCameraUp;\nuniform float iRandSeed;\nuniform int iRenderMode;  //是否是预览\nint Sample=2;\nint TraceDepth=1;\n#else\n#define skybox iChannel0\nint Sample = 100;\nint TraceDepth = 10;\n#endif\n\nfloat rand(float p){return fract(sin(p) * 43758.5453123);}\nfloat rand (in vec2 p) { return fract(sin(dot(p.xy, vec2(12.9898,78.233))) * 43758.5453123); }\nvec3 rand(vec3 p){\n \tconst vec3 k = vec3( 3.1415926, 2.71828,6.62607015);\n \tp = p*k + p.yzx;\n \treturn -1.0 + 2.0*fract( 2.0 * k * fract( p.x*p.y*(p.x+p.y)) );\n}\n\nfloat noise(vec3 p){\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    \n    //随机梯度\n    vec3 g1 = rand(i+vec3(0.0,0.0,0.0));\n    vec3 g2 = rand(i+vec3(1.0,0.0,0.0));\n    vec3 g3 = rand(i+vec3(0.0,1.0,0.0));\n    vec3 g4 = rand(i+vec3(1.0,1.0,0.0));\n    vec3 g5 = rand(i+vec3(0.0,0.0,1.0));\n    vec3 g6 = rand(i+vec3(1.0,0.0,1.0));\n    vec3 g7 = rand(i+vec3(0.0,1.0,1.0));\n    vec3 g8 = rand(i+vec3(1.0,1.0,1.0));\n    \n    //方向向量\n    vec3 d1 = f - vec3(0.0,0.0,0.0);\n    vec3 d2 = f - vec3(1.0,0.0,0.0);\n    vec3 d3 = f - vec3(0.0,1.0,0.0);\n    vec3 d4 = f - vec3(1.0,1.0,0.0);\n    vec3 d5 = f - vec3(0.0,0.0,1.0);\n    vec3 d6 = f - vec3(1.0,0.0,1.0);\n    vec3 d7 = f - vec3(0.0,1.0,1.0);\n    vec3 d8 = f - vec3(1.0,1.0,1.0);\n    \n    //点积求权重\n    float n1 = dot(g1, d1);\n    float n2 = dot(g2, d2);\n    float n3 = dot(g3, d3);\n    float n4 = dot(g4, d4);\n    float n5 = dot(g5, d5);\n    float n6 = dot(g6, d6);\n    float n7 = dot(g7, d7);\n    float n8 = dot(g8, d8);\n    \n    //加权求和\n    float a = mix(n1,n2,u.x);\n    float b = mix(n3,n4,u.x);\n    float c1 = mix(a,b,u.y);\n    a = mix(n5,n6,u.x);\n    b = mix(n7,n8,u.x);\n    float c2 = mix(a,b,u.y);\n    float c = mix(c1,c2,u.z);\n    \n    return c;\n}\n\nfloat fbm(vec3 p){\n    p *= 2.0;         //这里调整频率\n    float f = 0.;\n    f += 1.0 * abs(noise(p)); p=2.*p;\n    f += 0.5 * abs(noise(p)); p=2.*p;\n    f += 0.25 * abs(noise(p)); p=2.*p;\n    f += 0.125 * abs(noise(p)); p=2.*p;\n    //f += 0.0625 * noise(p); p=2.*p;\n    return f;\n}\n\nconst float PI = 3.1415926535897932384626;\nconst float MAX_DISTANCE=999999.0;\nconst float GAMMA =2.2;\nconst int MAT_LAMB = 1;   //漫反材质\nconst int MAT_METAL = 2;   //金属材质\nconst int MAT_DIEL = 3;   //电解质材质\n\n//随机数生成\n//返回 [0.0f, 1.0f) 的随机数\nfloat rand(float x, float y){\n    return fract(cos(x * (12.9898) + y * (4.1414)) * 43758.5453);\n}\n\nfloat rndSeed = 1.;//iRandSeed;\nfloat rand(){\n    return rand(rand(gl_FragCoord.x, gl_FragCoord.y), rndSeed++);\n}\n\n//产生 -1，1之间的单位向量\nvec3 rand_unit_vec3(){\n    return normalize(2.0 * vec3(rand(), rand(), rand()) - vec3(1.0));\n}\n\nstruct Ray { vec3 o, d; float tm; };                 //光线 (原点，方向, 运动模糊中，代表是哪一个时刻发出的光线)\nstruct Hit{ float t; vec3 p; vec3 n; int mat; };     //碰撞信息 (距离光原点的距离，交点，交点处的法线，材质索引)\nstruct Sphere{ vec3 o; float r; int mat; vec3 speed; }; //球体（原点，半径，材质索引, 速度大小和方向）\nstruct Plane {vec3 n; vec3 p; int mat; };            //平面 (法线，平面内一个点)\nstruct Texture {int type; vec3 col1; vec3 col2;};    //1. 单色   2. 棋盘\nstruct Material { int type; int albedo; float v; }; //材质 （类型[1. lambertian ]，材质索引，模糊度或者折射率）\n\n\n//摄像机\nstruct Camera{\n    vec3 pos, dir, up, right;\n    vec3 ll_corner, horizontal, vertical;\n    float aperture; //光圈大小\n    float duration; //快门打开的时间\n}camera;\n\nvoid BuildCamera(vec3 pos, vec3 dir, vec3 up, float hfov, float aspect, float aperture, float focus, float duration){\n    camera.pos = pos;\n    camera.dir = normalize(dir);\n    camera.up = normalize(up);\n    camera.right = cross(camera.dir, camera.up);\n    camera.up = cross(camera.right, camera.dir);\n    camera.aperture = aperture;\n    camera.duration = duration;\n    \n    vec3 center = camera.pos + focus * camera.dir;\n    float h = tan(hfov/180.0*PI) * focus * 2.0;\n    float w = h * aspect;\n    \n    camera.horizontal = w * camera.right;\n    camera.vertical = h * camera.up;\n    camera.ll_corner = center - 0.5 * camera.horizontal - 0.5 * camera.vertical;\n}\n\nRay BuildRay(vec2 fragCoord){\n    vec2 uv = fragCoord / vec2(iResolution.x, iResolution.y);\n    vec3 offset = camera.right * camera.aperture * rand()+ camera.up * camera.aperture * rand();\n    vec3 position = camera.pos + offset;\n    float tm = pow(rand() * camera.duration, 0.45); //随机一个时间点\n    return Ray(position, camera.ll_corner + uv.x*camera.horizontal + uv.y*camera.vertical - position, tm);\n}\n\nTexture textures[5];\nMaterial materials[10];\nSphere spheres[10];\nPlane planes[2];\nconst int planeCount = 0;\nint sphereCount = 0;\n\n//\nvec3 Texture_Checker(Texture tx, float u, float v, vec3 p){\n    float sines = sin(5.0*p.x) * sin(5.0*p.z) ; \n    if(sines < 0.){\n        return tx.col1;\n    }\n    return tx.col2;\n}\n\nvec3 Texture_Perlin(Texture tx, float u, float v, vec3 p){\n    return vec3(fbm(p));\n}\n\nvec3 Texture_Value(Texture tx, float u, float v, vec3 p){\n    vec3 color = vec3(0);\n\n    if(tx.type == 1){\n        color = tx.col1;\n    }\n    else if(tx.type == 2){\n        color = Texture_Checker(tx, u, v, p);\n    }\n    else if(tx.type == 3){\n        color = Texture_Perlin(tx, u, v, p);\n    }\n\n    return color;\n}\n\n//完全漫反射\nbool Scatter_Lambertian(Hit ht, inout Ray r, inout vec3 attenuation){\n    r.o = ht.p;\n    r.d = normalize(ht.n + rand_unit_vec3());\n    attenuation *= Texture_Value(textures[materials[ht.mat].albedo], 0., 0., ht.p);\n    return true;\n}\n\nbool Scatter_Metal(Hit ht, inout Ray r, inout vec3 attenuation){\n    //反射方向\n    vec3 ref = reflect(r.d, ht.n);\n    \n    //加一个随机值，大小由v控制\n    ref += rand_unit_vec3() * materials[ht.mat].v;\n    \n    //反射和法线同向，则有效\n    if(dot(ref, ht.n) > 0.0){\n        r.o = ht.p;\n        r.d = normalize(ref);\n        attenuation *= Texture_Value(textures[materials[ht.mat].albedo], 0., 0., ht.p);\n        return true;\n    }\n    \n    return false;\n}\n\n//近似菲涅尔方程\nfloat schlick(float cosine, float IOR)\n{\n    float r0 = (1.0 - IOR) / (1.0 + IOR);\n    r0 *= r0;\n    return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0);\n}\n\nbool Scatter_Dielectric(Hit ht, inout Ray r, inout vec3 attenuation){\n    float eta = materials[ht.mat].v;\n    float dt = dot(r.d, ht.n);\n    vec3 outward_normal = ht.n;\n    float cosine;\n    \n    if (dt > 0.0) { //由内向外\n        outward_normal = - ht.n;\n        cosine = eta * dt / length(r.d);\n    }\n    else {\n        eta = 1.0 / eta;\n        cosine = - dt / length(r.d);\n    }\n    \n    vec3 refracted = refract(r.d, outward_normal, eta);\n    float reflect_prob;\n    if(refracted != vec3(0.0)){ reflect_prob = schlick(cosine, eta); }\n    else { reflect_prob = 1.0;  } //全反射\n    \n    r.o = ht.p;\n    if (rand() < reflect_prob) { r.d = reflect(r.d, ht.n); }\n    else { r.d = refracted; }\n    return true;\n}\n\nbool Scatter(Hit ht, inout Ray r, inout vec3 attenuation){\n    if(materials[ht.mat].type == MAT_LAMB)\n        return Scatter_Lambertian(ht, r, attenuation);\n    else if(materials[ht.mat].type == MAT_METAL)\n        return Scatter_Metal(ht, r, attenuation);\n    else if(materials[ht.mat].type == MAT_DIEL)\n        return Scatter_Dielectric(ht, r, attenuation);\n}\n\nbool Intersect(Plane p, Ray r, out Hit ht){\n    float t = dot(r.d, p.n);\n    if(t >= 0.){\n        return false;\n    }\n    \n    ht.t = dot(p.n, (p.p - r.o))/ t;\n    ht.p = r.o + ht.t * r.d;\n    ht.n = p.n;\n    ht.mat = p.mat;\n    return true;\n}\n\nbool Intersect(Sphere s, Ray r, out Hit ht){\n    vec3 so = s.o + s.speed * r.tm;\n    vec3 oc = r.o - so;\n    float a = dot(r.d, r.d);\n    float b = 2.0 * dot(r.d, oc);\n    float c = dot(oc, oc) - s.r * s.r;\n    float delt = b * b - 4.0 * a * c;\n    if(delt > 0.0) {\n        float t = 0.;\n        t = (-b - sqrt(delt)) / (2.0 * a);\n        if(t < 0.001){\n            t = (-b + sqrt(delt)) / (2.0 * a);\n        }\n        if(t > 0.001){\n            ht.t = t;\n            ht.p = r.o + ht.t * r.d;\n            ht.n = normalize(ht.p - so);\n            ht.mat = s.mat;\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nvec3 BackDrop(Ray r){\n    return pow(texture(skybox, r.d).xyz, vec3(GAMMA));//把图片颜色恢复为线性空间\n}\n\nbool HitTest(Ray r, float t_min, float t_max, out Hit result){\n    float far = t_max;\n    for(int i = 0; i < sphereCount; i++){\n        Hit ht;\n        if(Intersect(spheres[i], r, ht)){\n            if(ht.t > t_min && ht.t < far){\n                result = ht;\n                far = ht.t;\n            }\n        }\n    }\n    \n    for(int i = 0; i < planeCount; i++){\n        Hit ht;\n        if(Intersect(planes[i], r, ht)){\n            if(ht.t > t_min && ht.t < far && ht.t < 10.){\n                result = ht;\n                far = ht.t;\n            }\n        }\n    }\n    return far<t_max;\n}\n\nvec3 Trace(Ray r){\n    Hit ht;\n    vec3 attenuation = vec3(1.0);\n    \n    for(int i = 0; i < TraceDepth; i++){\n        if(HitTest(r, 0.001, MAX_DISTANCE, ht)){\n            if(!Scatter(ht, r, attenuation)){\n                attenuation *= vec3(0);\n            }\n        }\n    }\n    \n    return attenuation * BackDrop(r);\n}\n\nvoid BuildTextures(){\n    textures[0] = Texture(1, vec3(0.6,0.6,0.9), vec3(0));\n    textures[1] = Texture(1, vec3(1), vec3(0));\n    textures[2] = Texture(1, vec3(0.6,0.9,0.6), vec3(0));\n    textures[3] = Texture(3, vec3(0.2,0.2,0.4), vec3(0.7,0.9,0.1));\n    textures[4] = Texture(2, vec3(0.0), vec3(1.0));\n}\n\nvoid BuildScene(){\n    BuildTextures();\n\n    materials[0] = Material(MAT_LAMB, 0,0.0);\n    materials[1] = Material(MAT_METAL, 1, 0.0);\n    materials[2] = Material(MAT_LAMB, 3, 0.1);\n    materials[3] = Material(MAT_DIEL, 2,1.7);\n    materials[4] = Material(MAT_LAMB, 3,1.7);\n    materials[5] = Material(MAT_LAMB, 4, 0.0);\n    \n    sphereCount = 0;\n    spheres[sphereCount++] = Sphere(vec3(0, 0, -1), 0.49, 0, vec3(0,1,0));\n    spheres[sphereCount++] = Sphere(vec3(-2, 0, -1), 0.49, 1, vec3(-1,0,0));\n    spheres[sphereCount++] = Sphere(vec3(2, 0, -1), 0.49, 2, vec3(0,0,0));\n    spheres[sphereCount++] = Sphere(vec3(-3, 0, -2), 0.49, 3, vec3(0,0,0));\n    spheres[sphereCount++] = Sphere(vec3(-2, 0, -5), 0.49, 3, vec3(0));\n    spheres[sphereCount++] = Sphere(vec3(3, 0, -3), 0.49, 4, vec3(0,0,0));\n    spheres[sphereCount++] = Sphere(vec3(2, 2, -2), 1.49, 3, vec3(0));\n    spheres[sphereCount++] = Sphere(vec3(-4, 2, -2), 1.49, 1, vec3(0));\n    spheres[sphereCount++] = Sphere(vec3(0, -170.5, -1), 170., 5, vec3(0));\n}\n\n//copy from https://www.shadertoy.com/view/XtyyDh\nvec4 quat(vec3 axis, float angle) { return vec4(axis*sin(angle*0.5), cos(angle*0.5)); }\nvec4 quat_i() { return vec4(0,0,0,1); }\nvec4 quat_conj(vec4 q) { return vec4(-q.xyz,q.w); }\nvec4 quat_mul(vec4 a, vec4 b) { return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz)); }\nvec3 quat_mul(vec4 q, vec3 v) { return v-2.0*cross(cross(q.xyz,v)-q.w*v,q.xyz); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n#ifdef LOC_SHADER\n    BuildCamera(iCameraPos, iCameraDir, iCameraUp, 45.0, iResolution.x/iResolution.y, 0.00, 1.0, 0.1);\n    if(iRenderMode == 3){\n        Sample = 2000;\n        TraceDepth = 15;\n    }\n    else if(iRenderMode == 2){\n        Sample = 50;\n        TraceDepth = 15;\n    }\n    else {\n        Sample = 2;\n        TraceDepth = 1;\n    }\n#else\n    Sample = 50;\n    TraceDepth = 2;\n    vec3 pos = quat_mul(quat(normalize(vec3(0,1,0)),iTime), vec3(0,0,5));\n    \n    BuildCamera(pos, vec3(0,0,-4) - pos, vec3(0,1,0), 45.0, iResolution.x/iResolution.y, 0.0, 1.0, 0.0);\n#endif\n    \n    BuildScene();\n    \n    vec3 col = vec3(0);\n    for(int i = 0; i < Sample; i++){\n        Ray r = BuildRay(fragCoord.xy+vec2(rand(), rand()));\n        col += Trace(r);\n    }\n    col /= float(Sample);\n    \n    fragColor = vec4(pow(col, vec3(1.0/GAMMA)), 1.0);\n}\n\n#ifdef LOC_SHADER\nvoid main(){\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    mainImage(FragColor, gl_FragCoord.xy);\n}\n#endif\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}