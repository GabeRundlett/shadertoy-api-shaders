{
    "Shader": {
        "info": {
            "date": "1636650725",
            "description": "Raymarched Fractal\n\nDepth",
            "flags": 32,
            "hasliked": 0,
            "id": "NtdGDB",
            "likes": 1,
            "name": "Fractelligence LG 02",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal"
            ],
            "usePreview": 0,
            "username": "PsyPhi",
            "viewed": 196
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 fractal = texture(iChannel0, uv);\n    vec4 blured = texture(iChannel1, uv);\n    float focusPoint = 0.5;\n    \n    float minDistance = 0.25;\n    float maxDistance = 2.5;\n    \n    float blur = smoothstep(minDistance, maxDistance,abs(fractal.z - focusPoint));\n    \n    fragColor = mix(fractal,blured,blur);\n    //fragColor = vec4(blur,blur,blur,1.0);\n    //fragColor = fractal;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Transforms\nfloat RotX = 1.0; //0 to 3\nfloat RotY = 1.2;\nfloat RotZ = 1.1;\nfloat TransX = 0.1; //0 to 5\nfloat TransY = -0.1;\nfloat TransZ = 0.0;\nfloat Scale = 0.;\nfloat Range = 0.001;\n\nfloat TwistY = 0.; //0 to 0.2\nint MirrorX = 1;\nint MirrorY = 0;\nint MirrorZ = 1;\n//Rectange\nint Rectangle = 1;\nfloat RecScale = 0.75;\n//Sphere\nint Sphere = 0;\nfloat SphereScale = 0.75;\nfloat SphereTX = 0.;\nfloat SphereTY = 0.;\nfloat SphereTZ = 0.;\n//Shapes\nint InfPre = 0;\nint InfPost = 0;\nint Merge = 0;\nfloat ShapeMix = 0.;\nfloat FractalScale = 0.1;\nfloat NearClip = 5.;\n//Color\nint Iterations = 1;\nfloat IHue = 1.;\nfloat Proximity = 1.;\nfloat PHue = 1.;\nfloat Distance = 1.;\nfloat DHue = 1.;\nfloat light = 0.;\nfloat DepthHue = 0.1;\nfloat ProxHue = 0.;\n//Time\nfloat TimeRotX = 1.0;\nfloat TimeRotY = 0.0;\nfloat TimeTransX = 0.1;\nfloat TimeTransY = 0.1;\nint TimeEnable = 1;\nint TimeDisabled = 0;\n\n#define MAX_STEPS 50\n\n#define MAX_DIST 25.\n\n#define SURF_DIST .001\n\n#define FRACT_STEPS 20\n\n#define PI 3.14159\n\nfloat map(float x, float inMin, float inMax, float outMin, float outMax) {\n    return (x - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n}\n\nvec3 hs(vec3 c, float s){\n    vec3 m=vec3(cos(s),s=sin(s)*.5774,-s);\n    return c*mat3(m+=(1.-m.x)/3.,m.zxy,m.yzx);\n}\n\nmat2 rotate(float a){\n\tfloat c = cos(a),\n\ts = sin(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ){\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdRectangle( vec3 p, float s){\n        float recDist = length(max(abs(p) - s, 0.));\n        return recDist;\n}\n\n\n\n//_+_+_+_+_+_+_SHAPING FUNCTIONS_+_+_+_+_+_+_+_\nfloat GetDist(vec3 p) {\n\tfloat d = 1.; //Just to have the d var declaired\n    \n\tfor (int i = 0; i < FRACT_STEPS ; i++){\n        if(InfPre == 1) p = mod(p+2.5, 5.)-2.5;   //Createts infinity\n\n\t\tif(MirrorX == 1) p.x = abs(p.x); //Mirror X\n\t\tif(MirrorY == 1) p.y = abs(p.y); //Mirror Y\n\t\tif(MirrorZ == 1) p.z = abs(p.z); //Mirror Z\n\n\t\tp.x -= TransX\n        +iMouse.x*Range\n        +TimeTransX*sin(iTime*0.1);\n        \n\t\tp.y -= TransY+iMouse.y*Range\n        +iMouse.y*Range\n        +TimeTransY*cos(iTime*0.1);\n        \n\t\tp.z -= TransZ;\n\n\t\tp.xy *= rotate(RotX+sin(iTime*0.2)*TimeRotX); \n\t\tp.xz *= rotate(RotY+cos(iTime*0.1)*TimeRotY);\n\t\tp.yz *= rotate(RotZ);\n\n        p.xz *= rotate(p.y*TwistY); //Twist\n\n        if(InfPost == 1)\t\tp = mod(p+2.5, 5.)-2.5;   //Createts infinity\n    }\n\n    if (Sphere == 1){\n\t\tvec4 sphere = vec4(SphereTX, SphereTY, SphereTZ, SphereScale);\n        float sphereDist =  length(p-sphere.xyz)-sphere.w;\n        if(Merge == 1) d = opSmoothUnion(sphereDist, d, ShapeMix);\n        else d = min(sphereDist,d);\n    }\n\n\n    if (Rectangle == 1){//Adds in the Rectangle\n        d = sdRectangle(vec3(0.0, 0.0, 0.0), RecScale);\n    }\n   \n    \n    d = sdOctahedron(p,1.0);\n\n    return d;\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) {\n\tvec3 dO = vec3(NearClip,0.,10.);  //  x = distance ray has traveled, y = Iterations to hit, z = Closest distance to surface\n\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO.x;\n        float dS = GetDist(p);\n        dO.x += dS;\n\t\t\t\tdO.z = min(dS, dO.z);\n\t\t\t\tdO.y = float(i);\n        if(dO.x>MAX_DIST || dS<SURF_DIST) break;\n    }\n\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 1, -6);\n    //lightPos.xz += vec2(sin(TIME), cos(TIME))*2.; //light movement\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).x;\n    if(d<length(lightPos-p)) dif *= .1;\n\n    return dif;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord, in vec3 _ro, in vec3 _rd)\n\n{\n\n    if (TimeEnable == 0 && TimeDisabled == 0) {\n    TimeRotX = 0.;\n    TimeRotY = 0.;\n    TimeTransX = 0.;\n    TimeTransY = 0.;\n    int TimeDisabled = 1;\n    }\n    \n\n    vec2 uv = (fragCoord+fragCoord - (iResolution.xy) ) / iResolution.y ;\n    \n\n    vec3 color = vec3(0);\n    vec3 iterationsColor;\n\tvec3 proxColor;\n    vec3 distColor;\n    vec3 normalColor = vec3(0.);\n\n    vec3 ro = vec3(0, 0, -6+(InfPre+InfPost));\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    ro = _ro;\n    rd = _rd;\n\n    vec3 d = RayMarch(ro, rd);\n    \n    vec3 d2 = RayMarch(ro+vec3(0.5,0.,0.), rd);\n    \n    d = opSmoothSubtraction( d, d2, 0.5 );\n\n    vec3 p = ro + rd * d.x;\n\n    float dif = GetLight(p);  //lighting\n\n\tvec3 n = GetNormal(p);\n\n\n    //+_+_+_+_+_+_+COLORING_+_+_+_+_+_+_\n    //Iterations\n\titerationsColor.r = (d.y*0.05-(1.-step(d.x*0.04, 1.)))*float(Iterations);\n    iterationsColor = hs(iterationsColor, IHue);\n    color = iterationsColor;\n    \n    //Distance\n    distColor.b = (1.-d.x*0.04)*Distance;\n    distColor = hs(distColor, DHue);\n    color += distColor;\n    //color = hs(color, -(1.-d.x*0.04));\n\n    color.g = (1.-(d.z+step(d.x*0.04, 1.)))*Proximity;\n\n    color = hs(color, PHue);\n    color.b = (1.-d.x*0.04)*Distance;\n\n    color = hs(color, DHue);\n    \n    color += dif*light;       //light\n    //color = hs(color, 5.0*dif*light);       //light hue rotate\n    \n    //Normals\n    //normalColor.b = n.b;\n    normalColor.b = n.g;\n    normalColor.r = n.r;\n    normalColor.g = 0.0;\n    normalColor = hs(normalColor, 1.6);\n   // color =+ hs(color, -n.b); //Y\n   // color =+ hs(color, n.r); //X\n   // color = mix(color, normalColor, Color.w);\n   \n    //Proximity\n    proxColor.g = (1.-(d.z+step(d.x*0.04, 1.)))*Proximity;\n    proxColor = hs(proxColor, PHue);\n    color += proxColor;\n\n\t//color = hs(color, d.y*DepthHue); //iterations to hue rot\n    //color = iterationsColor;\n    //color = distColor;\n    color = mix(iterationsColor, 1.-iterationsColor, normalColor.b);\n    color = mix(color, distColor, normalColor.r);\n    color += proxColor;\n    color = iterationsColor;\n    \n    //Light\n    //color += dif*light; //Light\n    //color = hs(color, -5.0*dif*light);       //light hue rotate\n\n    fragColor = vec4(normalColor,1.);\n    \n\n}\n\n\n\n#define QAA\t2                                     \n\nconst float\tsideAngle       = radians(35.0);\nconst float\thorizontalAngle = radians(14.0);\nconst float\tcameraSize      = 8.;\nconst float\taspectRatio     = 0.75;\nconst float quiltColumns\t= 8.0;\nconst float quiltRows\t\t= 6.0;\nconst float nearClip        = 8.0; \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2\tcoord = fragCoord * vec2(quiltColumns,quiltRows) / iResolution.xy;\n\tvec2\tfract = fract(coord);\n\tvec2\tfloor = floor(coord);\n\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\t\n\tvec3\tcamPos = mix(vec3(minCam,0,dist),vec3(-minCam,0,dist),valueId);\n\tvec3\tscreenPos = vec3((fract.x-0.5)*cameraSize,(fract.y-0.5)*cameraSize / aspectRatio,0);\n\t\n\tvec4\tcolor;\n\tvec3 \tdirRay = normalize(screenPos-camPos);\n    dirRay.z = -dirRay.z;\n\tmainImage( color, fract * iResolution.xy, screenPos - nearClip * dirRay, dirRay );\n\n    fragColor = color;\n\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pxlSize = vec2(1.0)/iResolution.xy;\n    float blurSize = 1.;\n    \n    pxlSize *= blurSize;\n\n    \n    vec4 kernel[9] = vec4[9](vec4(0.0),vec4(0.0),vec4(0.0),vec4(0.0),vec4(0.0),vec4(0.0),vec4(0.0),vec4(0.0),vec4(0.0));\n    \n    int arrayInc = 0;\n    \n for (int i = 0; i < 3 ; i++){\n     for(int j = 0;j<3;j++){\n         kernel[arrayInc] = texture(iChannel0, uv+vec2((-1+j),-1+i)*pxlSize);\n         arrayInc++;\n           }\n   \t\t}\n    \n    //kernel[4] = texture(iChannel0, uv+vec2(1,1)*pxlSize);\n    \n    vec4 bTotal = vec4(0.0);\n    \n    for(int i = 0;i<9;i++){\n     \tbTotal += kernel[i]*0.111;   \n    }\n    \n    \n    //bTotal = bTotal/vec4(9.0);\n    \n\n    // Time varying pixel color\n    vec4 col = bTotal;\n\n    // Output to screen\n    fragColor = bTotal;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}