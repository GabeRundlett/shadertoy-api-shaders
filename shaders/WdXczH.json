{
    "Shader": {
        "info": {
            "date": "1584103504",
            "description": "Sorting and storing 4 particle id's in 1 texel based on the distance to the texel. This allows extremely cheap interactions between particles.\nIn this example I'm using an atomic force approximation to model molecular dynamics.",
            "flags": 32,
            "hasliked": 0,
            "id": "WdXczH",
            "likes": 12,
            "name": "Smooth fast molecular dynamics",
            "published": 3,
            "tags": [
                "particles"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 573
        },
        "renderpass": [
            {
                "code": "// Fork of \"Quadruple voronoi diagram\" by michael0884. https://shadertoy.com/view/tdscRr\n// 2020-03-13 12:18:57\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    ivec4 sp = get(p);\n   \n    vec4 p0 = getParticle(sp.x);\n   \tivec4 cp = get(ivec2(p0.xy));\n    vec4 p1 = getParticle(cp.y);\n    vec4 p2 = getParticle(cp.z);\n    vec4 p3 = getParticle(cp.w);\n   \n    \n    float intensity = gauss(distance(pos, p0.xy), prad);\n    intensity += gauss(distance(pos, p1.xy), prad);\n    intensity += gauss(distance(pos, p2.xy), prad);\n    intensity += gauss(distance(pos, p3.xy), prad);\n    \n    col = .5+.5*sin(vec4(5., 6., 7., 8.)*intensity) ; \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//particle buffer\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\n//force scalar\nfloat F(float d)\n{\n    return 0.5*(d - 2.*prad)*gauss(d, 2.*prad);\n}\n\n//force vector\nvec2 Fv(vec2 p0, vec2 p1)\n{\n    if(!all(equal(p0,p1)))\n   \t return normalize(p1-p0)*F(distance(p1,p0));\n    else\n     return vec2(0.);\n}\n\n//get particle from array\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n   \t\t\n        //neighbors\n   \t\tivec4 cp = get(ivec2(U.xy));\n   \t    vec4 p1 = getParticle(cp.y);\n   \t    vec4 p2 = getParticle(cp.z);\n   \t    vec4 p3 = getParticle(cp.w);\n        \n        vec2 F = Fv(U.xy, p1.xy) +\n            \t Fv(U.xy, p2.xy) +\n            \t Fv(U.xy, p3.xy) +\n            \t vec2(0.,-0.02);\n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, U.xy);\n            F += 3.*normalize(iMouse.xy - U.xy)/(sqrt(d)+2.);\n        }\n        \n        U.zw += dt*F;\n        U.zw *= 1. - 0.004*dt*length(U.zw); //cooling\n        U.xy += U.zw*dt;\n        \n        //border conditions\n        if(size.x - U.x < 2.) U.z = -abs(U.z);\n        if(U.x < 2.) U.z = abs(U.z);\n        if(size.y - U.y < 2.) U.w = -abs(U.w);\n        if(U.y < 2.) U.w = abs(U.w);\n \n        //this pixel value\n        if(iFrame<1)\n        {\n            U.xy = size*hash22(pos);\n\t\t\tU.zw = 2.*(hash22(3.14159*pos) - 0.5);\n        }\n    }\n    else discard;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n//particle array\n//can be up to the resolution of the buffer\n//zero performance impact btw\n#define N ivec2(30,30)\n#define dt 0.8\n#define prad 8.\n\n//save N last iterations\n#define LN 1.\n\nint tot_n = N.x*N.y;\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\nuniform sampler2D fake;\n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(fake, p));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nvoid swap(inout int x, inout int y)\n{\n    int b = x;\n    x = y;\n    y = b;\n}\n\nvoid swap(inout float x, inout float y)\n{\n    float b = x;\n    x = y;\n    y = b;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nvoid sort(inout ivec4 u, inout vec4 d, int utemp, ivec2 p)\n{\n    vec2 pos = vec2(p)+0.5;\n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(utemp != u.x && d.x > dtemp)\n    {\n        swap(u.x, utemp);\n        swap(d.x, dtemp);\n    }\n    if(!any(equal(ivec2(utemp), u.xy)) && d.y > dtemp)\n    {\n        swap(u.y, utemp);\n        swap(d.y, dtemp);\n    }\n    if(!any(equal(ivec3(utemp), u.xyz)) && d.z > dtemp)\n    {\n        swap(u.z, utemp);\n        swap(d.z, dtemp);\n    }\n    if(!any(equal(ivec4(utemp), u.xyzw)) && d.w > dtemp)\n    {\n        u.w = utemp;\n        d.w = dtemp;\n    }\n}\n\nvoid upd(inout ivec4 u, inout vec4 d, ivec2 p, ivec2 dx)\n{\n    ivec4 t = get(p+dx);\n    sort(u, d, t.x, p);\n    sort(u, d, t.y, p);\n    sort(u, d, t.z, p);\n    sort(u, d, t.w, p);\n}\n\nvoid randupd(inout ivec4 u, inout vec4 d, ivec2 p )\n{\n    //go through the entire array\n    for(int i = 1; i < 8; i++)\n    {\n    \tint t = ((iFrame + p.x + p.y*int(iResolution.x))^(1<<i))%tot_n;\n   \t\tsort(u, d, t, p);\n    }\n}\n\n\nvoid updrad(inout ivec4 u, inout vec4 d, ivec2 p, int R)\n{\n    int r = 1<<R;\n    upd(u, d, p, ivec2(r, 0));\n    upd(u, d, p, ivec2(-r, 0));\n    upd(u, d, p, ivec2(0, r));\n    upd(u, d, p, ivec2(0, -r));\n}\n\nvoid update(inout ivec4 u, inout vec4 d, ivec2 p)\n{\n    randupd(u, d, p);\n    updrad(u, d, p, 0);\n    updrad(u, d, p, 3);\n    updrad(u, d, p, 5);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    //particle indecies \n    ivec4 sp = get(p);\n    \n    sp.yzw = ivec3(0); \n    \n   \t//particle distances to this point\n    vec4 dist = vec4(particleDistance(sp.x, pos), 1e10, 1e10, 1e10);\n        \n   \n    update(sp, dist, p);\n    \n    U = save(sp);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}