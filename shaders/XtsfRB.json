{
    "Shader": {
        "info": {
            "date": "1512357745",
            "description": "The first raymarching-demo I saw years ago was probably a variation of such a truchet-structure. It fascinated me back then and still does now! At least today I'm able to replicate it myself... mostly. Still, I had to peek in one of Shane's examples.",
            "flags": 0,
            "hasliked": 0,
            "id": "XtsfRB",
            "likes": 13,
            "name": "MacSlow's 1st 3D-truchet attempt",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "phong",
                "shadow",
                "spheretracing",
                "truchet",
                "blinn",
                "fresnel"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 758
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// raymarched 3D-truchet structure \n//\n// Copyright 2017 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// Just for the record... standing on the shoulder of giants like iq, Shane et al\n// of course. For a first attempt ok-ish.\n//\n// Wanted to toss it into the public in the current form, hoping I can get some\n// feedback from more experienced folks here. Thanks in advance!\n//\n// Interaction: LMB-drag controls pitch and yaw of the truchet-structure, when\n// dragged to the right half of the \"screen\" a raymarch-cost (depth) view is\n// displayed\n//\n// Update: Thanks to the input from Shane and Fabrice, I got rid of the artefacts.\n// Renders much cleaner and a bit faster now (even faster in the desktop-GL version).\n// Now stuff like AA and PBR are on my ToDo for this one... and I have to\n// give it my own personal twist to bring something new to the table (to ShaderToy)\n//\n////////////////////////////////////////////////////////////////////////////////\n\nprecision highp float;\n\n#define MAX_ITER 128\n#define STEP_SIZE .95\n#define EPSILON .001\n\nconst vec4 red     = vec4 (1.0, 0.0, 0.0, 1.0);\nconst vec4 green   = vec4 (0.0, 1.0, 0.0, 1.0);\nconst vec4 blue    = vec4 (0.0, 0.0, 1.0, 1.0);\n\nmat3 rotX (in float a) {float c = cos(a); float s = sin (a); return mat3 (vec3 (1., .0, .0), vec3 (.0, c, s), vec3 (.0, -s, c));}\nmat3 rotY (in float a) {float c = cos(a); float s = sin (a); return mat3 (vec3 (c, .0, s), vec3 (.0, 1., .0), vec3 (-s, .0, c));}\nmat3 rotZ (in float a) {float c = cos(a); float s = sin (a); return mat3 (vec3 (c, s, .0), vec3 (-s, c, .0), vec3 (.0, .0, 1.));}\nmat2 rot2d (in float a) { float c = cos (a); float s = sin (a); return mat2 (vec2 (c, s), vec2 (-s, c)); }\n\nvec4 gradient (float v) {\n    float steps = 2.;\n    float step = 1. / steps;\n    vec4 col = green;\n\n    if (v >= .0 && v < step) {\n        col = mix (green, blue, v * steps);\n    } else if (v >= step && v < 2.0 * step) {\n        col = mix (blue, red, (v - step) * steps);\n    }\n    \n    return col;\n}\n\n// basic sdf toolbox\nvec3 opRepeat (in vec3 p, in vec3 size) {return mod (p, 2. * size) - size;}\nfloat sdTorus (in vec3 p, in vec2 t) { vec2 q = vec2 (length (p.xz) - t.x, p.y); return length (q) - t.y; }\n\n// one single truchet-cell with the three tori\n// t.x -> torus radius\n// t.y -> torus \"thickness\"\n// t.z -> the offset by which the torus should be moved from the center\nfloat sdTruchet (in vec3 p, in vec3 t)\n{\n    float offset = t.z;\n    vec3 p1 = vec3 (p - vec3 (offset, offset, .0)) * rotX (radians (90.));\n    vec3 p2 = vec3 (p - vec3 (.0, -offset, offset)) * rotZ (radians (90.));\n    vec3 p3 = vec3 (p - vec3 (-offset, .0, -offset)) * rotY (radians (90.));\n    \n    float t1 = sdTorus (p1, t.xy);\n    float t2 = sdTorus (p2, t.xy);\n    float t3 = sdTorus (p3, t.xy);\n\n    return min (t1, min (t2, t3));\n}\n\nfloat scene (in vec3 p)\n{\n    vec2 mouse = iMouse.xy;\n    if (iMouse.xy == vec2(.0)) mouse.xy = vec2 (212., 192.);\n    mat3 rot = rotX (radians (180. + mouse.y / iResolution.y * 360.)) * rotY (radians (-180. + mouse.x / iResolution.x * 360.));\n\tp *= rot;\n\n    // \"move the camera\" (actually, we're moving space)\n    p.x -= iTime * .3;\n\n    vec3 cellParam = vec3 (.5, .07 + .04 * (.5 + .5 * cos (3.*iTime)), .5);\n\n    // these random functionsand the used values are still major WTF's for me\n    float selector = fract(sin(dot(floor(p) + 13.37, vec3(7., 157., 113.)))*43758.5453);\n\n    // I _hate_ myself for having to peek into one of Shane's truchet-examples for getting a\n    // clue about the cell-rotation and not coming up with coordinate-swiveling... it's so\n    // simple and obvious... argl!\n    if (selector > .75) {\n        p = p;\n    } else if (selector > .5) {\n    \tp = p.yzx;\n    } else if (selector > .25) {\n\t    p = p.zxy;\n    }\n\n    float d = sdTruchet (opRepeat (p, vec3 (.5)), cellParam);\n\n\treturn d;\n}\n\nfloat raymarch (in vec3 ro, in vec3 rd, out int iter)\n{\n    float t = .0;\n\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        iter = i;\n        vec3 p = ro + t * rd;\n        float d = scene (p);\n        if (abs (d) < EPSILON * (1. + .125*d)) break;\n        t += d * STEP_SIZE;\n    }\n\n    return t;\n}\n\nvec3 normal (in vec3 p)\n{\n    vec3 e = vec3(.0001, .0, .0);\n    float d = scene (p);\n    vec3 n = vec3 (scene (p + e.xyy) - d, scene (p + e.yxy) - d, scene (p + e.yyx) - d);\n    return normalize(n);\n}\n\nfloat shadow (in vec3 p, in vec3 n, in vec3 lPos)\n{\n    float distanceToLight = distance (p, lPos);\n    int ignored = 0;\n    float distanceToObject = raymarch (p + .01*n, normalize (lPos - p), ignored);\n    bool isShadowed = distanceToObject < distanceToLight;\n    return isShadowed ? .1 : 1.;\n}\n\n// blinn-phong shading... as much as I can remember it\nvec3 shade (in vec3 ro, in vec3 rd, in float d)\n{\n    vec3 p = ro + d * rd;\n\n    vec3 ambColor = vec3 (.1, .05, .05);\n    vec3 diffColor = vec3 (1.9, 1.4, 1.2);\n    vec3 specColor = vec3 (.95, .85, .85);\n    float shininess = 120.;\n\n    vec3 lightPos = ro + vec3 (cos (iTime) * .5, .5, sin (iTime) * .5);\n    vec3 lightDir = lightPos - p;\n    vec3 lightNDir = normalize (lightDir);\n    vec3 nor = normal (p);\n    vec3 h = normalize (lightDir - rd);\n\n    float diffuse = max (dot (lightNDir, nor), .0);\n    float specular = pow (max (dot (h, nor), .0), shininess);\n\n    float sha = shadow (p, nor, lightPos);\n    float distanceToLight = distance (p, lightPos);\n    float attenuation = 1. / (distanceToLight*distanceToLight);\n\n    vec3 specTerm = ((sha > .1) ? attenuation * specular * specColor : vec3 (.0));\n    return ambColor + sha * attenuation * diffuse * diffColor + specTerm;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    // normalizing and aspect-correction\n\tvec2 uvRaw = fragCoord.xy / iResolution.xy;\n\tvec2 uv = uvRaw;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // create origin and view-ray\n    vec3 ro = vec3 (.0, .0, -.75);\n    vec3 rd = normalize (vec3 (uv, 1.) - ro);\n\n    // \"shake the camera\" around a bit\n    rd.xy *= rot2d (cos (iTime) * .075);\n    rd.xz *= rot2d (sin (iTime) * .15);\n\n    // do the ray-march...\n    int iter = 0;\n    float d = raymarch (ro, rd, iter);\n    float depth = float (iter) / float (MAX_ITER);\n    vec3 cc = gradient (depth).rgb;\n    float fog = 1. / (1. + d * d * .1);\n    vec3 c = shade (ro, rd, d);\n\n    // secondary/1st reflection-ray\n    vec3 p = ro + d*rd;\n    vec3 n = normal (p);\n    vec3 refl = normalize (reflect (rd, n));\n    float refd = raymarch (p + .01*n, refl, iter);\n    vec3 refp = p + refd*refl;\n    vec3 refcol = shade (p, refl, refd);\n\n    // restricting (fresnel) reflections to grazing view-angles\n\tfloat fakeFresnel = pow (1. - max (dot (n, -rd), .0), 1.25);\n    vec3 lPos = ro + vec3 (cos (iTime) * .5, .5, sin (iTime) * .5);\n    float lDist = distance (lPos, p);\n    float attenuation = 1. / (lDist*lDist);\n    c += fakeFresnel*attenuation*.125*refcol;\n\n    // fog, tonemapping, \"gamma-correction\", tint, vignette\n    c *= fog;\n\tc = c / (1. + c);\n    c = .2 * c + .8 * sqrt (c);\n    c *= vec3 (.9, .8, .7);\n    c *= .2 + .8 * pow (16. * uvRaw.x * uvRaw.y * (1. - uvRaw.x) * (1. - uvRaw.y), .3);\n\n    if (iMouse.x / iResolution.x < .5) {\n\t\tfragColor = vec4(c, 1.);\n    } else {\n\t\tfragColor = vec4(cc, 1.);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}