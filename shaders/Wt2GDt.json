{
    "Shader": {
        "info": {
            "date": "1561563863",
            "description": "A remake of an old shader that I made, in an attempt to improve the quality of the shader visually.\n\nOriginal shader: https://www.shadertoy.com/view/4syXRV",
            "flags": 1,
            "hasliked": 0,
            "id": "Wt2GDt",
            "likes": 4,
            "name": "Teacups Remake",
            "published": 3,
            "tags": [
                "lighting",
                "remake",
                "raymarcher",
                "teacup",
                "repetiton"
            ],
            "usePreview": 0,
            "username": "jackdavenport",
            "viewed": 473
        },
        "renderpass": [
            {
                "code": "// Teacups Remake by jackdavenport\n// Created 2019\n// All code is free to use with credit :)\n\n#define MAX_ITER 256\n#define MIN_DIST .001\n#define MAX_DIST 15.\n\n#define PI 3.14159\n\nstruct Material {\n    vec3 albedo;\n    vec3 specular;\n    float shine;\n    float reflectivity;\n};\n\nvoid camera(inout vec3 ro);\nvoid getMaterial(inout Material mat, in vec3 p, in vec3 n, in vec2 t);\n\nvec2 dstScene(vec3 p) {\n    vec2 d = vec2(p.y + .1, 0.); // floor\n    \n    // teacups\n    vec2 c = vec2(.6);\n    p.xz = mod(p.xz,c)-.5*c;\n    p.xz = rot2D(p.xz, iTime * PI * 0.2);\n    vec3 q = p;\n    q.xy = rot2D(q.xy, -PI * .5);\n    float cup = sdCappedCylinder(p, vec2(.1, .1));\n    cup = sdSubtract(sdCappedCylinder(p-vec3(0.,.1,0.), vec2(.087,.2)), cup);\n    cup = smin(cup, sdCappedTorus(q-vec3(.005,.1,0.), vec2(.5,0.), .05, .015), .007);\n    d = sdUnion(d, cup, 1.);\n    \n    // end scene\n    return d;\n}\n\nvec2 raymarch(vec3 ro, vec3 rd) {\n    float t  = .01;\n    float id = -1.;\n    for(int i = 0; i < MAX_ITER; i++) {\n        vec2 scn = dstScene(ro+rd*t);\n        if(t > MAX_DIST || scn.x <= MIN_DIST) {\n            id = scn.y;\n            break;\n        }\n        t += scn.x * .5;\n    }\n    return vec2(t,id);\n}\n\nvec3 calcNormal(vec3 p, float t) {\n    vec2 e = vec2(MIN_DIST,0.);\n    vec3 n = vec3(dstScene(p+e.xyy).x-dstScene(p-e.xyy).x,\n                  dstScene(p+e.yxy).x-dstScene(p-e.yxy).x,\n                  dstScene(p+e.yyx).x-dstScene(p-e.yyx).x);\n    return normalize(n);\n}\n\n// thnx iq!\n// source: https://iquilezles.org/articles/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t < maxt; )\n    {\n        float h = dstScene(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 getLightPos() {\n    vec3 lp = vec3(.75*sin(iTime*.3),.5,.25+.25*cos(iTime*.1));\n\tcamera(lp);\n    return lp;\n}\n\nvoid calcLighting(inout vec3 col, vec3 p, vec3 n, vec3 r, float t, in Material mat) {\n    // light position\n    vec3 lp = getLightPos();\n    \n    // calc light direction and distance\n    vec3 lv = lp - p;\n    float ld = length(lv);\n    lv /= ld;\n    \n    // calculate lighting\n    float ndotl = max(dot(n,lv),0.);\n    float rdotl = max(dot(r,lv),0.);\n    float atten = softshadow(p, lv, .01, ld, 32.);\n    \n    // calculate attenuation\n\tconst float radius = 10.;\n    float a = 1. - clamp((ld*ld)/(radius*radius),0.,1.);\n    atten *= a * a;\n    \n    // calculate final colour\n    col = clamp(mat.albedo * ndotl * atten + (mat.specular * pow(rdotl, mat.shine) * atten), 0., 1.);\n}\n\nvec3 shade(vec3 ro, vec3 rd) {\n    vec2 t = raymarch(ro, rd);\n    vec3 c = vec3(0.,0.,0.);\n    \n    if(t.x < MAX_DIST) {\n        vec3 p = ro + rd * t.x;\n        vec3 n = calcNormal(p, t.x);\n        vec3 r = normalize(reflect(rd, n));\n        \n        Material mat;\n        getMaterial(mat, p, n, t);\n        calcLighting(c, p, n, r, t.x, mat);\n        \n        if(mat.reflectivity > 0.) {\n            float refl = mat.reflectivity;\n            \n            vec2 rt = raymarch(p, r);\n\t\t\tvec3 rc = vec3(0.);\n            if(rt.x < MAX_DIST) {\n                vec3 rp = p+r*rt.x;\n                vec3 rn = calcNormal(rp,rt.x);\n                vec3 rr = normalize(reflect(r, rn));\n                getMaterial(mat, rp, rn, rt);\n\t\t\t\tcalcLighting(rc, rp, rn, rr, rt.x, mat);\n            }\n\n            float fres = pow(min(max(dot(rd,r),0.),1.),2.);\n\t\t\tc = mix(c, rc, mat.reflectivity * fres);\n        }\n    }\n    \n    // add haze around light\n    vec3 lp = getLightPos();\n    vec3 lv = normalize(lp - ro);\n    float haze = pow(clamp(dot(lv,rd),0.,1.),60.);\n    c += vec3(1.) * haze;\n    \n    return c;\n}\n\nvoid shadeRay(vec3 ro, vec3 rd, inout vec4 fragColor) {\n    // correctly translate the camera\n    ro += vec3(0., .3, -1.);\n    camera(ro);\n    \n    // get the scene colour for the ray\n    fragColor.xyz = shade(ro, normalize(rd));\n    fragColor.w   = 1.;\n    \n    // post processing\n    fragColor.xyz = pow(fragColor.xyz, vec3(1.15));\n    fragColor.xyz = ACESFilm(fragColor.xyz);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec3 rd = vec3(uv, 1.);\n    \n    rd.yz = rot2D(rd.yz, .35);\n    shadeRay(vec3(0.), rd, fragColor);\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd) {\n    shadeRay(ro, rd, fragColor);\n}\n\nvoid getMaterial(inout Material mat, in vec3 p, in vec3 n, in vec2 t) {\n    if(t.y == 0.) { // floor\n        vec4 tex = texture(iChannel0, p.xz);\n        mat.albedo = tex.xyz;\n        mat.specular = vec3(.85 + .1 * tex.x);\n        mat.shine = 60.*(1.-tex.x);\n        mat.reflectivity = .1+.2*tex.y;\n    } else if(t.y == 1.) { // teacups\n        vec2 c = vec2(.6);\n    \tp.xz = mod(p.xz,c)-.5*c;\n        p.xz = rot2D(p.xz, iTime * PI * 0.2);\n        vec4 tex = texture(iChannel1, p*vec3(7.,1.,8.));\n        mat.albedo = vec3(.8 + .2 * tex.x);\n        mat.specular = vec3(1.);\n        mat.shine = 60.;\n        mat.reflectivity = .9;\n    }\n}\n\nvoid camera(inout vec3 ro) {\n    ro.z += iTime * .2;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Teacups Remake by jackdavenport\n// Created 2019\n// All code is free to use with credit :)\n\n// Thnx iq!\n// Source: https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n/******************************************************/\n\nvec2 sdUnion(vec2 a, float bt, float bid) {\n    return a.x < bt ? a : vec2(bt, bid);\n}\nfloat sdSubtract(float a, float b) {\n    return max(-a, b);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n/******************************************************/\n\nvec2 rot2D(vec2 p, float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c,s,-s,c) * p;\n}\n\n/******************************************************/\n\n// Source: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}