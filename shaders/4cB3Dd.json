{
    "Shader": {
        "info": {
            "date": "1704828690",
            "description": "A 6x6 noise-free gaussian blur using 9 carefully chosen bilinear samples.",
            "flags": 0,
            "hasliked": 0,
            "id": "4cB3Dd",
            "likes": 2,
            "name": "Gaussian 6x6 (9 taps)",
            "published": 3,
            "tags": [
                "gaussianblur"
            ],
            "usePreview": 0,
            "username": "WizardOfOzzz",
            "viewed": 157
        },
        "renderpass": [
            {
                "code": "vec3 saturate(vec3 v) {\n  return clamp(v, 0.0, 1.0);\n}\n\nfloat gaussian(float v, float twoSigmaSq) {\n  return exp(-(v * v) / twoSigmaSq);  \n}\n\nvec3 gaussian(vec3 v, float twoSigmaSq) {\n  return exp(-(v * v) / twoSigmaSq);\n}\n\nvec3 truncatedGaussian(vec3 v, float twoSigmaSq, float trunc) {\n  return saturate(gaussian(v, twoSigmaSq) - trunc); \n}\n\n// A 6x6 gaussian blur using 9 carefully placed bilinear samples.\nvec4 blur6x6(in vec2 texCoord, float twoSigmaSq, float trunc) {\n  vec2 size = iChannelResolution[0].xy;\n  vec2 texel = 1.0 / size.xy;\n\n  // Fraction of a pixel\n  vec2 a = fract(texCoord * size.xy - vec2(0.5));\n\n  // Compute 6 x/y distances to neighboring 6x6 texels in x/y. The offsets alternate between\n  // two variables so we can compute a ratio later (that determines final sample location).\n  vec3 xDist0 = -a.xxx + vec3(-2.0, 0.0, 2.0);\n  vec3 xDist1 = xDist0 + 1.0;\n  vec3 yDist0 = -a.yyy + vec3(-2.0, 0.0, 2.0);\n  vec3 yDist1 = yDist0 + 1.0;\n\n  // Corresponding gaussian weights in x/y.\n  vec3 gx0 = truncatedGaussian(xDist0, twoSigmaSq, trunc);\n  vec3 gx1 = truncatedGaussian(xDist1, twoSigmaSq, trunc);\n  vec3 gy0 = truncatedGaussian(yDist0, twoSigmaSq, trunc);\n  vec3 gy1 = truncatedGaussian(yDist1, twoSigmaSq, trunc);\n\n  // Final sample offsets in both x/y.\n  vec3 gx01 = gx0 + gx1;\n  vec3 gy01 = gy0 + gy1;\n  vec3 xOffsets = (xDist0 + (gx1 / gx01)) * texel.x;\n  vec3 yOffsets = (yDist0 + (gy1 / gy01)) * texel.y;\n\n  // 3 rows of 3 weights (for the 9 bilinear samples).\n  vec3 w0 = gx01.xyz * gy01.x;\n  vec3 w1 = gx01.xyz * gy01.y;\n  vec3 w2 = gx01.xyz * gy01.z;\n\n  vec4 result = vec4(0);\n  result += texture( iChannel0, texCoord + vec2(xOffsets.x, yOffsets.x)) * w0.x;\n  result += texture( iChannel0, texCoord + vec2(xOffsets.y, yOffsets.x)) * w0.y;\n  result += texture( iChannel0, texCoord + vec2(xOffsets.z, yOffsets.x)) * w0.z;\n  result += texture( iChannel0, texCoord + vec2(xOffsets.x, yOffsets.y)) * w1.x;\n  result += texture( iChannel0, texCoord + vec2(xOffsets.y, yOffsets.y)) * w1.y;\n  result += texture( iChannel0, texCoord + vec2(xOffsets.z, yOffsets.y)) * w1.z;\n  result += texture( iChannel0, texCoord + vec2(xOffsets.x, yOffsets.z)) * w2.x;\n  result += texture( iChannel0, texCoord + vec2(xOffsets.y, yOffsets.z)) * w2.y;\n  result += texture( iChannel0, texCoord + vec2(xOffsets.z, yOffsets.z)) * w2.z;\n\n  float weight = dot(vec3(1.0), w0) + dot(vec3(1.0), w1) + dot(vec3(1.0), w2);\n  return result / weight;\n}\n\n\nvoid mainImage( out vec4 outColor, in vec2 coord )\n{\n  float blurMinSigma = 0.4;\n  float blurMaxSigma = 2.0;\n\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = coord/iResolution.xy;\n    \n  // Use a sine wave for animation.\n  float sine = sin(iTime * 3.0) * 0.5 + 0.5;\n  float sigma = sine * (blurMaxSigma - blurMinSigma) + blurMinSigma;\n  float twoSigmaSq = sigma * sigma * 2.0; \n  float trunc = gaussian(3.0, twoSigmaSq);  \n  outColor.rgb = blur6x6(uv, twoSigmaSq, trunc).rgb;\n  outColor.a = 1.0;\n  \n  // Comparison with bilinear\n  // outColor.rgb = texture( iChannel0, uv).rgb;;\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}