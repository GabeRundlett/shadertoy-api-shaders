{
    "Shader": {
        "info": {
            "date": "1488260137",
            "description": "More playing with cellular automata.\n\nThe level of 'turbulence' is controlled by the x value of the last location clicked, click to change it.",
            "flags": 32,
            "hasliked": 0,
            "id": "llcXWX",
            "likes": 18,
            "name": "Clever Clouds",
            "published": 3,
            "tags": [
                "cellular",
                "pretty"
            ],
            "usePreview": 0,
            "username": "abznak",
            "viewed": 4239
        },
        "renderpass": [
            {
                "code": "/* the interesting code is all in Buf A */\n// old color, reliative to current pixel\nvec4 bufColor(in vec2 fragCoord, in vec2 dxy) {    \n    return texture(iChannel0,  fract((fragCoord.xy + dxy) / iResolution.xy));\n}\n\n// grab the value for a nearby pixel\n#define BC(dx,dy) (bufColor(fragCoord, vec2(dx, dy)))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //apply a slight blur to the image in buffer A \n\tfragColor = (BC(0,0)*4.0 + BC(-1, 0) + BC(1,0)+BC(0, -1) + BC(0, 1))/8.0;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//----------------------------------------------------------------------------------------\n// Pseudorandom number generator, based on https://www.shadertoy.com/view/4djSRW\n///  3 out, 3 in...\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define MAX_ITERATIONS 30\n#define MIN_ITERATIONS 4\n\n// hash33, tweaked to include an extra param\nvec3 hash33(vec3 p3, int i)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19+float(i)/20.);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nvec3 rnd3(vec2 position, int i)\n{\n\n    i += MIN_ITERATIONS;\n    vec3 a = vec3(0.0), b = a;\n    //NOTE - not handling i > MAX_ITERATIONS\n    //will just start scaling down random numbers\n    for (int t = 0; t < MAX_ITERATIONS; t++)  // max_iterations thing is due to GLSL limitations?\n    {\n        if (t == i) {\n            break;\n        }\n        float v = float(t+1)*.132;\n        vec3 pos = vec3(position, iTime*.3) + iTime * 500. + 50.0;\n        a += hash33(pos, i);  //just changing the numer of iterations doesn't work, so we pass in i\n    }\n    vec3 col = a / float(i);\n    return col;\n}\n//----------------------------------------------------------------------------------------\n\n\n// old color, reliative to current pixel\nvec4 oldColor(in vec2 fragCoord, in vec2 dxy) {    \n    return texture(iChannel0,  fract((fragCoord.xy + dxy) / iResolution.xy));\n}\n\n//get the next random number for the current pixel\n#define RND() (rnd3(fragCoord, rndi++))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int rndi = 0;\n\tconst vec4 black = vec4(0., 0., 0., 1.);\n    const vec4 white = vec4(1.);\n    const vec4 red = vec4(1., 0., 0., 1.);\n    // current coordinates, normalised 0..1\n    vec2 uv = fragCoord.xy / iResolution.xy;              \n    \n    vec3 rnd;\n\n    //////////////////////    \n    // sometimes adds a small coloured square at a random location\n    //////////////////////    \n    rnd = RND();\n    if (true) {                   \n        if (true || iTime < 2.0) {\n            if (rnd.x < .00001) {\n                fragColor = vec4(RND(), 1.);  \n                return;\n            }\n        }\n    }\n    \n    \n    \n    \n    //////////////////////\n \t// shuffle pixels around in a way that avoids vertical edges\n \t//////////////////////\n    \n    \n    // get old colour from buffer\n    #define oc(x,y) (oldColor(fragCoord, vec2(x,y)))    \n    \n    vec4 oldcol = oc(0., 0.);          \n    vec4 col = oldcol;\n    //fragColor = col; return;\n\t#define notblack(x) (any(greaterThan(x, black)))\n    #define isblack(x) (!notblack(x))\n    \n\n    \n    float dir = -1.;\n    if (rnd.y < .5) {\n        dir = 1.;\n    }\n    \n    if (isblack(col)) {        \n        // if current color is black, pick a nearby color\n        col = oc(dir, 0.);\n    } else {\n        // pick a nearby color IF it does NOT create a vertical edge\n        vec4 potcol = oc(0, dir);\n        if (potcol == oc(-1., dir) && potcol == oc(1., dir)) {\n            col = potcol;\n        }\n    }\n    \n\n    //////////////////////\n \t// perhaps tweak the result\n \t//////////////////////    \n\n    float change_chance = pow(iMouse.x/iResolution.x, 2.)/9.;\n    if (change_chance == 0.) {\n        //it can be below 0.05, but not exactly 0\n        // so we still have a change_chance when the user hasn't clicked.\n        change_chance = 0.05;\n    }\n      \n    \n    //fragColor = col; return;\n\n    //////////////////////\n \t// pick the dominant pixel from neighbouring pixels (and this pixel).\n    // each colour dominates half the other colors\n \t//////////////////////    \n\n    //iterate over nearby pixels\n    for (float dx = -1.0; dx < 2.0; dx++) {\n        for (float dy = -1.0; dy < 2.0; dy++) {\n            vec4 acol = oc(dx, dy);\n\n            float q = dot(acol, acol);\n            float w = dot(col, col);\n\n            //NB - the distribution of the dot-product of random colours is not uniform\n            //TODO: bigger range of values for change_chance\n            //TODO: use col.y to determine for loops' directions\n            //TODO: use col.z (or acol.z) to modify change_chance\n            q=acol.x;\n            w=col.x; \n            //w=col.y; //+ col.y/10.;\n            //w=acol.y+col.x;\n            //w=acol.y*col.x;\n                \n            \n            // if the colour being replaced is background (black), always replace it with\n            // anything that isn't black.\n            if (isblack(col)&&notblack(acol)) {\n                col = acol;\n            }\n\n            \n            if (notblack(acol)) {\n                float diff = (q - w)/1.5; //    1.5 = 3/2 to rescale -3..3 to -1..1                   \n\n                // different cutoffs are fun, as are varying cutoffs.\n                float cutoff;\n                cutoff = 0.5;\n                //cutoff = sin(float(iFrame/100)) * .5;\n                \n                // designed so ever pixel beats half of the colour space, see https://www.shadertoy.com/view/Mtt3Wn\n                if ((diff < 0. && diff > -cutoff) || (diff > cutoff)) {\n                    if (RND().x < change_chance) {\n                    \tcol = acol;  //note - picked deterministically if multiple pixels qualify\n                    }\n                }\n            }\n        }\n    }        \n   \n    fragColor = col;    \n}\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}