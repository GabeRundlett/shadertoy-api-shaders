{
    "Shader": {
        "info": {
            "date": "1690896668",
            "description": "Combining raymarching and cell-by-cell traversal techniques to produce extruded subdivided equilateral triangles in realtime.",
            "flags": 32,
            "hasliked": 0,
            "id": "mllczn",
            "likes": 91,
            "name": "Extruded Subdivided Triangles",
            "published": 3,
            "tags": [
                "raymarching",
                "grid",
                "triangle",
                "traversal",
                "extrude",
                "subdivide"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 1461
        },
        "renderpass": [
            {
                "code": "/*\n\n    Extruded Subdivided Triangles\n    -----------------------------\n\n    See \"Buffer A\" for an explanation.\n\n*/\n\n\n\n/*\n// Just a very basic depth of field routine -- I find a lot of it is\n// common sense. Basically, you store the scene distance from the camera \n// in the fourth channel, then use it to determine how blurry you want\n// your image to be at that particular distance.\n//\n// For instance, in this case, I want pixels that are 2.25 units away from \n// the camera to be in focus (not blurred) and for things to get more \n// blurry as you move away from that point -- aptly named the focal point \n// for non camera people. :)\n//\n// I based this on old code of mine, but adopted things that I found in \n// IQ and Nesvi7's examples, which you can find here:\n//\n// Ladybug - IQ\n// https://www.shadertoy.com/view/4tByz3\n//\n// Cube surface II - Nesvi7\n// https://www.shadertoy.com/view/Mty3DV\n//\nvec3 DpthFld(sampler2D iCh, vec2 uv){\n\t\n    // Focal point and circle of confusion.\n    const float focD = 1.5, coc = .7;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    float dof = clamp(l/coc, 0., 2.); \n    \n    // Combine samples. Samples with a larger DOF value are taken further \n    // away from the original point, and as such appear blurrier.\n    vec3 acc = vec3(0);\n\n    for(int i = 0; i<25; i++){\n        // Accumulate samples.\n        acc += texture(iCh, uv + (vec2(i/5, i%5) - 2.)/vec2(800, 450)*dof).xyz;\n        //acc.x *= dof/2.;\n    }\n\n    // Return the new variably blurred value.\n    return acc /= 25.;\n    // Visual debug representation of DOF value.\n    //return vec3(length(dof)*450./2.5);\n}\n*/\n\n// Standard 2D rotation formula.\n//mat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's float to float hash. I've added an extra sine wrapping modulo to\n// cater for my annoying AMD based system, which can't wrap sine with a \n// proper degree of accuracy.\nfloat hash11B(float x){ return fract(sin(mod(x,6.2831853))*43758.5453); }\n\n// This is an amalgamation of old blur and DOF functions with a heap of borrowed \n// lines from Dave Hoskins's much nicer Fibonacci based \"Bokeh disc\" function, which \n// you can find here: https://www.shadertoy.com/view/4d2Xzw\n//\n// If you're interested in bokeh, Dave's function above and some of Shadertoy user, \n// Hornet's, are probably the one's you should be looking at. Xor has some cool simple \n// ones on here too.\n//\nvec4 bokeh(sampler2D iCh, vec2 uv){\n\n\n    // UV based DOF. Focused on the horizontal line, then blurring further away.\n    //float r = smoothstep(0., 1., abs(uv.y - .57)/.57)*2.;\n    // Focal point and circle of confusion.\n    const float focD = 2.4, coc = .7;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    float ra = clamp(l/coc, 0., 2.);\n    //float ra = smoothstep(.1, .9, abs(uv.y - .5)*2.)*2.;\n    //float ra = mix(clamp(l/coc, 0., 2.), smoothstep(.3, 1., abs(uv.y - .5)*2.), .25);\n    //float ra = (smoothstep(.2, 1., length(uv - .5)));\n\n    // Standard Fibonacci distribution calculations, compliments of Dave Hoskins.\n    const int iter = 96;\n    float rad = 1.6;//max(2.*ra, .5); // Bokeh radius.\n    float r = 1.;\n\tvec4 tot = vec4(0), div = tot;\n    vec2 vangle = vec2(0., rad*.01/sqrt(float(iter)));\n    #define GA 2.3999632 // Golden angle.\n    const mat2 rot = mat2(cos(GA), sin(GA), -sin(GA), cos(GA));\n\n    // Aspect ratio.\n    vec2 aspect = vec2(iResolution.y/iResolution.x, 1);\n    \n    \n\tfor (int i = 0; i<iter; i++){\n        \n        #if 1\n        \n        // Dave Hoskin's Fibonacci based scattering. Cheaper and much nicer, so\n        // it's set as the default.\n        // The approx increase in the scale of sqrt(0, 1, 2, 3...).\n        r += 1./r;\n\t    vangle = rot*vangle;\n        vec4 col = texture(iCh, uv - (r - 1.)*vangle*aspect, iResolution.y/450.*1.5); \n        \n        #else\n        \n        // A hash based random distribution, for anyone who wants to try it.\n        //int ii = i%10; // For square bokeh.\n        //int jj = i/10;\n    \n        // Random offset contained within a disk or radius n.\n        float fi = float(i) + fract(iTime);\n        //vec2 fi = vec2(ii, jj) - 5. + fract(iTime);\n        vec2 rnd2 = vec2(hash11B(fi), hash11B(fi + .1)*6.2831);\n        vec2 offs = 6.*sqrt(rnd2.x)*vec2(cos(rnd2.y), sin(rnd2.y));\n        ////////\n        /*\n        // Polygons, if desired. Comment out the line above and comment in\n        // the \"rot2\" formula above, if using it.\n        const float N = 6.;\n        float ra = rnd2.y;\n        float a = (floor(ra*N) + .5)*6.2831859/N;\n        vec2 offs  = mix(rot2(a)*vec2(0, 1), rot2(a + 6.2831859/N)*vec2(0, 1), fract(ra*N));\n        offs *= 6.*sqrt(rnd2.x);\n        */\n        ////////\n        offs *= rad;\n        //offs = rad*(offs + (vec2(hash11B(fi), hash11B(fi + .21)) - .5));\n        vec4 col = texture(iCh, uv - offs/iResolution.xy, iResolution.y/450.*1.5);  \n  \n        #endif\n         \n        // Thanks to Dave for figuring out how to tweak the colors to produce brighter \n        // contrast. It's common sense... once someone figures it out for you. :D \n        vec4 bokeh = pow(col, vec4(4));\n\t\ttot += bokeh*col*col;\n\t\tdiv += bokeh;\n        \n\t}\n    \n    \n    // Mixing the original value with the bokeh tweaked value according\n    // to the depth of field.\n    vec4 colOrig = texture(iCh, uv);\n    // Not entirely correct, but no one will notice here. :)\n\treturn mix(colOrig, colOrig*.25 + tot/div*4., ra);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Screen oordinates.\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //vec4 col = DpthFld(iChannel0, uv).xyzz;\n\n    // Retrieving the stored color.\n    //vec4 col = texture(iChannel0, uv);\n\n    vec4 col = bokeh(iChannel0, uv);\n\n\n    // Subtle vignette.\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./32.);\n\n    // Rough gamma correction and screen presentation.\n    fragColor = pow(max(col, 0.), vec4(1./2.2)); \n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n    Extruded Subdivided Triangles\n    -----------------------------\n    \n    Combining raymarching and cell-by-cell prism boundary techniques\n    provides the opportunity to create some grid structures that would\n    normally be considered prohibitively expensive. This is a subdivided\n    triangle prism grid, and it'd be near impossible to raymarch one \n    in realtime using the usual neighboring cell techniques.\n    \n    To be fair, it's kind of expensive doing it this way too, so \n    apologies to those with slower systems. Having said that, a decent\n    machine could run this pretty easily -- Mine can push this out in\n    fullscreen without too much trouble.\n    \n    Anyway, I posted this just to get one of these on the board and to\n    show that raymarching with cell boundary restrictions can work on\n    non rectangular polygon grids as well. The work is a little rushed,\n    but I'll look into improving the sudivision routine later.\n\n\n\n    Similar examples:\n    \n    // This is a cell-by-cell traversal of subdivided equilateral \n    // triangles. Like all of Abje's stuff, it's understated,\n    // underrated and cleverly written. On the surface, his subdivision \n    // routine seems to be faster than the one I hacked together, so I \n    // might take a look at it later.\n    recursive triangles - abje\n    https://www.shadertoy.com/view/3scyR2\n\n    // A 2D Truchet subdivided triangle grid example.\n\tMultiscale Triangle Truchet - Shane\n    https://www.shadertoy.com/view/dllyD7\n\n*/\n\n\n// Maximum ray distance.\n#define FAR 20.\n\n\n// Object ID: Either the back plane, extruded object or beacons.\nint objID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  \n    return fract(sin(mod(dot(p, vec2(27.619, 57.583)), 6.2831853))*43758.5453); \n}\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){\n    \n    n = max(abs(n) - .2, 0.001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(1)); \n    n /= length(n);\n    \n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear \n    // space (squaring is a rough approximation) prior to working with them... or \n    // something like that. :) Once the final color value is gamma corrected, you \n    // should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\n/*\n// Texture sample.\n//\nvec3 getTex(sampler2D iCh, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iCh, p).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n*/\n\n// Height map value, which is just the pixel's greyscale value.\n//float hm(in vec2 p){ return dot(getTex(iChannel0, p), vec3(.299, .587, .114)); }\n\nfloat hm(vec2 p){\n\n    float rnd = hash21(p + .22);\n    rnd = smoothstep(.84, .94, sin(6.2831*rnd + iTime/2.));\n    float sn = dot(sin(p - cos(p.yx*1.25)*3.14159), vec2(.25)) + .5;\n    //float sn = dot(getTex(iChannel0, p/4.), vec3(.299, .587, .114)); \n    return mix(sn, rnd, .2) + .05;\n}\n\n\n\n// IQ;s signed distance to an equilateral triangle.\n// https://www.shadertoy.com/view/Xl2yDW\nfloat getTri(in vec2 p, in float r){\n\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n   \n    p.y = p.y + r/k; \n    if(p.x + k*p.y>0.) p = vec2(p.x - k*p.y, -k*p.x - p.y)/2.;\n    p.x -= clamp(p.x, -2.*r, 0.);\n    return -length(p)*sign(p.y);\n   \n    /*   \n    const float k = sqrt(3.0);\n    p.y = abs(p.y) - r; // This one has been reversed.\n    p.x = p.x + r/k;\n    if( p.y + k*p.x>0.) p = vec2(-k*p.y - p.x, p.y - k*p.x)/2.0;\n    p.y -= clamp( p.y, -2.0, 0.0 );\n    return -length(p)*sign(p.x);\n    */  \n}\n\n\n\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /* \n    // Slight rounding. A little nicer, but slower.\n    const float sf = .01;\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    */\n     \n}\n\n\n// Signed distance to a line passing through A and B.\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\n\n\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning. By the way, this\n// will partition all repeat grid triangles, not just equilateral ones.\n\n\n// Number of possible subdivisions. Larger numbers will work,\n// but will slow your machine down. This example is designed to\n// work with numbers 0 to 2. For 3 and 4, etc, you'll need to change\n// the triangle scale variable below.\n#define DIV_NUM 2\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n// Triangle scale: Smaller numbers mean smaller triangles, oddly enough. :)\nconst float scale = .8;\n\n// Rectangle scale.\nconst vec2 rect = (vec2(1./.8660254, 1))*scale;\n\n// Skewing half way along X, and not skewing in the Y direction.\nconst vec2 sk = vec2(rect.x*.5, 0)/scale; // 12 x .2\n\n\nfloat gTri;\n\n// Triangle routine, with additinal subdivision. It returns the \n// local tringle coordinates, the vertice IDs and vertices.\nvec4 getTriVerts(in vec2 p, inout mat3x2 vID, inout mat3x2 v){\n   \n\n    // Skew the XY plane coordinates.\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //gTri = p.x/rect.x < -p.y/rect.y? 1. : -1.;\n    // Base on the bottom (-1.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 1. : -1.;\n   \n    // Puting the skewed coordinates back into unskewed form.\n    p = unskewXY(p, sk);\n    \n    \n    // Vertex IDs for each partitioned triangle: The numbers are inflated\n    // by a factor of 3 to ensure vertex IDs are precisely the same. The\n    // reason behind it is that \"1. - 1./3.\" is not always the same as\n    // \"2./3\" on a GPU, which can mess up hash logic. However, \"3. - 2.\"\n    // is always the same as \"1.\". Yeah, incorporating hacks is annoying, \n    // but GPUs don't work as nicely as our brains do, unfortunately. :)\n    if(gTri<0.){\n        vID = mat3x2(vec2(-1.5, 1.5), vec2(1.5, -1.5), vec2(1.5));\n    }\n    else {\n        vID = mat3x2(vec2(1.5, -1.5), vec2(-1.5, 1.5), vec2(-1.5));\n    }\n    \n    // Triangle vertex points.\n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect/3., sk); // Unskew.\n  \n    // Centering at the zero point.\n    vec2 ctr = (v[0] + v[1] + v[2])/3.;\n    p -= ctr;\n    v[0] -= ctr; v[1] -= ctr; v[2] -= ctr;\n    \n     // Centered ID, taking the inflation factor of three into account.\n    vec2 ctrID = (vID[0] + vID[1] + vID[2])/3.;//vID[2]/3.;\n    vec2 tID = id*3. + ctrID;   \n    // Since these are out by a factor of three, \"v = vertID*rect/3.\".\n    vID[0] -= ctrID; vID[1] -= ctrID; vID[2] -= ctrID;\n    \n    \n    /////////////////////////////\n    #if DIV_NUM > 0\n    \n    // The random triangle subdivsion addition. I put this together pretty\n    // quickly, so there'd probably be better ways to do it. By the way, if\n    // you know of ways to improve the following, feel free to let me know.\n    for(int j = 0; j<DIV_NUM; j++){\n    \n        // Randomly subdivide.\n        if(hash21(tID + float(j + 6)/32.)<.35){\n\n            // Subdividing an equilateral triangle into four smaller \n            // equilateral ones. Use the \"GRID\" define and refer to the \n            // resultant imagery, if you're not sure.\n\n            mat3x2 mid, midID; // Midpoints.\n            vec3 dl; // Divding lines.\n\n            for(int i = 0; i<3; i++){\n                int ip1 = (i + 1)%3;\n                mid[i] = mix(v[i], v[ip1], .5); // Mid points.\n                midID[i] = mix(vID[i], vID[ip1], .5); // Mid point IDs.\n                // Divinding lines -- separating  the midpoints.            \n                dl[i] = distLineS(p, mid[i], mix(v[ip1], v[(i + 2)%3], .5));  \n            }\n\n            // Choosing which of the four new triangles you're in. The top\n            // triangle is above the first midpoint dividing line, the\n            // bottom right is to the right of the next diving line and the\n            // bottom left is to the left of the third one. If you're not in\n            // any of those triangles, then you much be in the middle one...\n            // By the way, if you know of better, faster, logic to subdivide\n            // a triangle into four smaller ones, feel free to let me know. :)\n            //\n            if(dl[0]<0.){ // Top.   \n                v[0] = mid[0]; vID[0] = midID[0];\n                v[2] = mid[1]; vID[2] = midID[1];        \n            }\n            else if(dl[1]<0.){ // Bottom right.   \n                v[1] = mid[1]; vID[1] = midID[1];\n                v[0] = mid[2]; vID[1] = midID[2];        \n            }\n            else if(dl[2]<0.){ // Bottom left.   \n                v[2] = mid[2]; vID[2] = midID[2];\n                v[1] = mid[0]; vID[1] = midID[0];        \n            }  \n            else { // Center.\n               v[0] = mid[0]; vID[0] = midID[0];\n               v[1] = mid[1]; vID[1] = midID[1];\n               v[2] = mid[2]; vID[2] = midID[2];  \n               gTri = -gTri;\n            }\n\n            // Triangle center coordinate.\n            ctr = (v[0] + v[1] + v[2])/3.;\n            // Centering the coordinate system -- vec2(0) is the triangle center.\n            p -= ctr;\n            v[0] -= ctr; v[1] -= ctr; v[2] -= ctr;\n\n             // Centered ID, taking the inflation factor of three into account.\n            ctrID = (vID[0] + vID[1] + vID[2])/3.;//vID[2]/3.;\n            tID += ctrID;   \n            // Since these are out by a factor of three, \"v = vertID*rect/3.\".\n            vID[0] -= ctrID; vID[1] -= ctrID; vID[2] -= ctrID;\n        }\n    }\n    \n    #endif\n\n    // Triangle local coordinates (centered at the zero point) and \n    // the central position point (which acts as a unique identifier).\n    return vec4(p, tID);\n}\n\nvec2 gTriID;\nmat3x2 gVert, gVertID;\nvec2 gP;\n\n// The subdivided triangle routine.\nfloat tr(vec2 p){\n    \n    \n    // Returns the local coordinates (centered on zero), cellID, the \n    // triangle vertex ID and relative coordinates.\n    mat3x2 v, vID;\n    vec4 p4 = getTriVerts(p, vID, v);\n    vec2 triID = p4.zw;\n    gTriID = p4.zw;\n    \n    // Setting some globals.\n    gVert = v;\n    gVertID = vID;\n    gP = p4.xy;\n    \n    \n    // Grid triangles. Some are upside down.\n    float ew = .01;\n    vec2 q = p4.xy*vec2(1, gTri); // Equivalent to the line above.\n    \n    float rad = length(v[0]); // 2D object radius.\n    float d2D = getTri(q, (rad - ew - rad*.15*2.)*.8660254) - rad*.15; // Triangle.\n    //float d2D = length(q) - (rad*.5 - .001); // Cylinders.\n    \n    // Randomly bore out some of the triangle centers.\n    if(hash21(gTriID + .093)<.5) d2D = max(d2D, -(d2D + .3*sqrt(length(v[0]))));\n\n    // Return the 2D field.\n    return d2D;\n\n\n}\n\n\n\n// Ray origin, ray direction, point on the line, normal. \nfloat rayLine(vec2 ro, vec2 rd, vec2 p, vec2 n){\n   \n   // This it trimmed down, and can be trimmed down more. Note that \n   // \"1./dot(rd, n)\" can be precalculated outside the loop. However,\n   // this isn't a GPU intensive example, so it doesn't matter here.\n   //return max(dot(p - ro, n), 0.)/max(dot(rd, n), 1e-8);\n   float dn = dot(rd, n);\n   return dn>0.? dot(p - ro, n)/dn : 1e8;   \n   //return dn>0.? max(dot(p - ro, n), 0.)/dn : 1e8;   \n\n} \n\nvec3 gRd; // Global ray variable.\nfloat gCD; // Global cell boundary distance.\n\n \n// The scene's distance function: There'd be faster ways to do this, but it's\n// more readable this way. Plus, this  is a pretty simple scene, so it's \n// efficient enough.\nfloat m(vec3 p){\n    \n    \n    // 2D triangle distance -- for the extrusion cross section.\n    float d2D = tr(p.xy);\n    \n    // Back plane.\n    float fl = -p.z;\n\n    \n    // Extrude the 2D Truchet object along the Z-plane. Note that this is a cheap\n    // hack. However, in this case, it doesn't make much of a visual difference.\n    vec2 gTriV = unskewXY(gTriID*rect/3., sk);\n    float h = hm(gTriV);\n    // Proper extrusion formula for comparisson.\n    float obj = opExtrusion(d2D, p.z + h/2., h/2.);\n    \n   \n    // Adding the 2D field to angle the tops a bit.\n    obj -= max(-(d2D + .02), .0)*.1;\n    //obj -= clamp(-(d2D + .02), .0, .08)*.15;\n    //obj += smoothstep(0., .5, sin(d2D*80.))*.002;\n    //obj += smoothstep(0., .5, sin((p.z - h)*60.))*.002;\n    \n    \n    ///////////\n    // Ray to triangle prism wall distances.\n    vec3 rC;\n    rC.x = rayLine(gP.xy, gRd.xy, gVert[0], \n                   normalize(gVert[1] - gVert[0]).yx*vec2(1, -1));\n    rC.y = rayLine(gP.xy, gRd.xy, gVert[1], \n                   normalize(gVert[2] - gVert[1]).yx*vec2(1, -1));\n    rC.z = rayLine(gP.xy, gRd.xy, gVert[2], \n                   normalize(gVert[0] - gVert[2]).yx*vec2(1, -1));\n    /* \n    // Same thing, but using absolute coordinates.\n    rC.x = rayLine(oP.xy, gRd.xy, gTriV + gVert[0], \n                   normalize(gVert[1] - gVert[0]).yx*vec2(1, -1));\n    rC.y = rayLine(oP.xy, gRd.xy, gTriV + gVert[1], \n                   normalize(gVert[2] - gVert[1]).yx*vec2(1, -1));\n    rC.z = rayLine(oP.xy, gRd.xy, gTriV + gVert[2], \n                   normalize(gVert[0] - gVert[2]).yx*vec2(1, -1));\n    */\n\n    // Minimum of all distances, plus not allowing negative distances, which\n    // stops the ray from tracing backwards... or something like that.\n    gCD = max(min(min(rC.x, rC.y), rC.z), 0.) + .0015;\n    \n    \n    ///////////\n    \n   \n    // Object ID.\n    objID = fl<obj? 0 : 1 ;\n    \n    // Minimum distance for the scene.\n    return min(fl, obj);\n    \n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float d, t = 0.; //hash21(r.xy*57. + fract(iTime + r.z))*.5;\n    \n    gRd = rd; // Set the global ray  direction varible.\n    \n    for(int i = min(iFrame, 0); i<96; i++){\n    \n        d = m(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on \n        // accuracy, as \"t\" increases. It's a cheap trick that works in most \n        // situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        // Restrict the maximum ray distance to the prism wall boundaries.\n        t += min(d, gCD); \n    }\n\n    return min(t, FAR);\n}\n\n/*\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. \n// I tried to make it as concise as possible. Whether that translates to speed, \n// or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale \n    // texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), \n                  tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks \n    // to EvilRyu for reminding me why we perform this step. It's been a while, but I \n    // vaguely recall that it's some kind of orthogonal space fix using the Gram-Schmidt \n    // process. However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n*/\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with \n// limited iterations is impossible... However, I'd be very grateful if someone could \n// prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer, but not always affordable for slower machines.\n    const int iter = 32; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n    gRd = rd;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. \n    // Obviously, the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<iter; i++){\n\n        float d = m(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // IQ's subtle refinement.\n        t += clamp(min(d, gCD), .01, .2); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Shadow.\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(iFrame, 0); i<5; i++ ){\n    \n        float hr = float(i + 1)*.2/5.;        \n        float d = m(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n  \n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nr(in vec3 p) {\n\t\n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += m(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\nvoid mainImage(out vec4 c, vec2 u){\n\n    \n    // Aspect correct coordinates. Only one line necessary.\n    u = (u - iResolution.xy*.5)/iResolution.y;    \n    \n    // Unit direction vector, camera origin and light position.\n    vec3 r = normalize(vec3(u, 1)), o = vec3(iTime/4., iTime/8., -3.25),\n         l = o + vec3(1, 2.5, 1);\n    \n    // Rotating the camera about the XY plane.\n    r.yz = rot2(.35)*r.yz;\n    r.xz = rot2(-cos(iTime*3.14159/32.)/16.)*r.xz;\n    r.xy = rot2(sin(iTime*3.14159/32.)/16. + .28)*r.xy; \n    \n    // Rough fish-eye lens.\n    r = normalize(vec3(r.xy, sqrt(max(r.z*r.z - dot(r.xy, r.xy)*.15, 0.))));\n  \n    \n    // Raymarch to the scene.\n    float t = trace(o, r);\n \n    \n    // Object ID: Back plane (0), or the metaballs (1).\n    int gObjID = objID;\n    \n    \n    // Initialize the scene color to zero.\n    c = vec4(0);\n    \n    \n    if(t<FAR){\n    \n        // Very basic lighting.\n        // Hit point and normal.\n        vec3 p = o + r*t, n = nr(p); \n        \n        // Texture base bump mapping.\n        // Slightly better, but I thought we could save the cycles.\n        // If using it, uncomment the \"texBump\" function.\n        //n = texBump(iChannel1, p, n, .003);///(1. + t/FAR)\n        \n         // Basic point lighting.   \n        vec3 ld = l - p;\n        float lDist = length(ld);\n        ld /= lDist; // Light direction vector.\n        float at = 1.5/(1. + lDist*.05); // Attenuation.\n\n        // Very, very cheap shadows -- Not used here.\n        //float sh = min(min(m(p + ld*.08), m(p + ld*.16)), \n        //           min(m(p + ld*.24), m(p + ld*.32)))/.08*1.5;\n        //sh = clamp(sh, 0., 1.);\n        float sh = softShadow(p, l, n, 8.); // Shadows.\n        float ao = calcAO(p, n); // Ambient occlusion.\n\n\n        // UV texture coordinate holder.\n        vec2 uv = p.xy;\n\n\n        // Returns the local coordinates (centered on zero), cellID, the \n        // triangle vertex ID and relative coordinates.\n        mat3x2 v, vID;\n\n\n        // Triangle face distace -- Used to render borders, etc.\n        float d = tr(p.xy);\n\n        /*\n        // Subtle pattern lines for a bit of texture.\n        #ifdef LINES\n        float lSc = 30.;\n        vec2 rUV = rot2(-3.14159/3.)*uv;\n        float pat = (abs(fract(rUV.x*lSc - .5) - .5) - .125)/lSc;\n        #else\n        float pat = 1e5;\n        #endif     \n        */\n\n        // Object color.\n        vec4 oCol;\n\n\n        // Use whatever logic to color the individual scene components. I made it\n        // all up as I went along, but things like edges, textured line patterns,\n        // etc, seem to look OK.\n        //\n        if(gObjID == 1){\n        \n            // Extruded subdivided triangle height.            \n            vec2 gTriV = unskewXY(gTriID*rect/3., sk);\n            float h = hm(gTriV); \n\n         \n            // Metallic texturing.\n            vec4 tx = tex3D(iChannel1, p/2., n).xyzx;\n             \n            // Two colors, used for decorating the prisms.\n            vec4 col1 = tx*(tx*2. + .1)/2.;\n            vec4 col2 = tx/2.;\n\n \n            float bw = .05; // Side band width.\n            float ew = .02; // Dark edge line width.\n            float sf = .007;//3./iResolution.y;\n            oCol = col2*vec4(1, .6, .38, 0)/2.;\n            oCol = mix(oCol, oCol*.05, 1. - smoothstep(0., sf, max(d, (p.z + h - bw))));\n         \n            \n \n            // Darken alternate checkers on the face only.\n            //if(gTri>0.) col1 *= vec4(1, .6, .4, 0);\n            \n            // Giving the triangle faces some subtle random gold hints.\n            vec4 fCol = mix(vec4(1), vec4(1, .7, .4, 0), hash21(gTriV + .08)*.5 + .1);\n            col1 *= fCol;\n            col2 *= fCol*.5 + .5;\n             \n            // Screen gradient... Not for this example. :)\n            //col1 *= mix(vec4(1, .7, .4, 0), vec4(1, .7, .4, 0).zyxw, -u.y + .5);\n            \n            // Fake pearlescence.\n            vec4 pearl = mix(vec4(1, .6, .2, 0), vec4(1, .6, .3, 0).zyxw,\n                                clamp(-n.y*8. + .5, 0., 1.))*2. + .1;\n            col1 *= pearl;\n            col2 *= pearl; \n            \n            // Green falloff.\n            col1 += col1*vec4(.6, 1, .2, 0)/2.*(1. - smoothstep(0., sf*16., (d + .2)));\n            // Line pattern. Uncomment the line pattern block above.\n            //col1 = mix(col1*1.25, col1*.7, 1. - smoothstep(0., sf, pat));\n            \n            // Applying the top face color and edging.\n            oCol = mix(oCol, col2*vec4(1, .77, .5, 0), \n                       1. - smoothstep(0., sf, max(d, (p.z + h - bw + ew))));\n            oCol = mix(oCol, oCol*.05, 1. - smoothstep(0., sf, max(d, (p.z + h ))));\n            \n            \n            // Apply the colored face to the Truchet, but leave enough room\n            // for an edge.\n            oCol = mix(oCol, col2*vec4(1, .8, .6, 0), 1. - smoothstep(0., sf, d + ew));\n            oCol = mix(oCol, oCol*.05, 1. - smoothstep(0., sf, d + ew + .02));\n            oCol = mix(oCol, col1, 1. - smoothstep(0., sf, d + ew*2. + .02));\n\n\n        }\n        else {\n            \n            // The floor. Mostly hidden.\n            oCol = vec4(.02); \n        }\n\n\n\n       \n\n        // Diffuse and specular.\n        float df = pow(max(dot(n, ld), 0.), 2. + 8.*oCol.x)*2.; // Diffuse.\n        float sp = pow(max(dot(reflect(r, n), ld), 0.), 16.); // Specular.\n\n\n        // Specular reflection.\n        vec3 hv = normalize(ld - r); // Half vector.\n        vec3 ref = reflect(r, n); // Surface reflection.\n        vec4 refTx = texture(iChannel2, -ref.yzx); refTx *= refTx; // Cube map.\n        float spRef = pow(max(dot(hv, n), 0.), 5.); // Specular reflection.\n        float rf = mix(.5, 1., 1. - smoothstep(0., .01, d + .02));\n        rf *= (gObjID == 0)? .1 : 1.;\n        oCol += oCol*spRef*refTx.zyxw*rf*24.;\n        \n\n\n        // Apply the lighting and shading. \n        c = oCol*(df*sh + sp*sh*8. + .3)*at*ao;\n    \n    \n    }\n    \n    // Applying fog: This fog begins at 90% towards the horizon.\n    //c = mix(c, vec4(0), smoothstep(.25, .9, t/FAR));\n  \n   \n \n    // Rough gamma correction.\n    c = vec4(max(c.xyz, 0.), t);  \n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}