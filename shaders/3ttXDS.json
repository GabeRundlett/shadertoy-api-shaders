{
    "Shader": {
        "info": {
            "date": "1581624447",
            "description": "Composition using a randomly generated function that maps x, y, and time to color values. The fractional approach demonstrated here (https://www.shadertoy.com/view/lsl3RH) is used.",
            "flags": 0,
            "hasliked": 0,
            "id": "3ttXDS",
            "likes": 2,
            "name": "fn frac 3",
            "published": 3,
            "tags": [
                "2d",
                "abstract"
            ],
            "usePreview": 0,
            "username": "anttikan",
            "viewed": 286
        },
        "renderpass": [
            {
                "code": "\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat noise( float x, float y )\n{\n    \n    vec2 p = vec2(x,y);\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\n\nfloat proc(vec2 p, float iTime){\n    float x = p.x;\n    float y = p.y;\n    return (log(abs((pow((sqrt(pow(sign((sqrt(pow(((noise((sqrt(pow(((x)+(x)),2.0)+pow(((x)-(sin(iTime/0.966987073505152 + 0.6111521249421139))),2.0))),(sin(iTime/0.4363697787300387 + 0.12117539940795363)))/ (abs(noise((sin(iTime/0.5158599562708615 + 0.16600295224153383)),sin(((sin(iTime/0.6756154310519074 + 0.21928104695785633))-(y)))))+0.0001))/ (abs(pow((sqrt(abs(abs((sin(iTime/0.10046810537438944 + 0.16472793169855549))) - floor(abs((sin(iTime/0.06664122762711977 + 0.15718604023595528))))))*sqrt(abs((sin(iTime/0.4570874330557644 + 0.8750506328606864))))),3.0))+0.0001)),2.0)+pow((x),2.0)))),2.0)+pow(((sin((((pow((sin(iTime/0.9411628721004033 + 0.7970329359978641)),2.0)*pow((x),3.0))/ (abs((x))+0.0001))+(y)))-((sqrt(pow(sin(sin(((y)*(y)))),2.0)+pow((abs(noise((x),(y))) - floor(abs(noise((x),(y))))-sqrt(abs(sign((sin(iTime/0.31979339437329113 + 0.6727109187652756)))))),2.0)))-(y)))*pow(((x)+cos(sign(sqrt(abs((sqrt(pow((y),2.0)+pow((y),2.0)))))))),3.0)),2.0))),3.0)+((sqrt(pow(noise(log(abs(pow(log(abs((((y)+(sin(iTime/0.6262793977377104 + 0.19748571464784503)))-(sqrt(pow(((y)/ (abs((x))+0.0001)),2.0)+pow(((x)/ (abs((x))+0.0001)),2.0)))))+0.0001),2.0))+0.0001),sin(sin(((y)+(y))))),2.0)+pow(((sin(iTime/0.16396662366658754 + 0.27674858164238003))-sqrt(abs(((sqrt(pow(((sin(iTime/0.2834978288486667 + 0.5743516223794598))+(sin(iTime/0.15568232361922707 + 0.7840086800987247))),2.0)+pow(sqrt(abs((x))),2.0)))*(sin((sqrt(pow(((y)+(y)),2.0)+pow(pow((y),3.0),2.0))))/ (abs(((sqrt(pow(abs((sin(iTime/0.21214125730436129 + 0.15950010259741676))) - floor(abs((sin(iTime/0.23599852758426532 + 0.8305195272596266)))),2.0)+pow(sign((y)),2.0)))-sign((y))))+0.0001)))))),2.0)))*abs(sin(pow(cos(sin(sin((((y)-(sin(iTime/0.09431146868556373 + 0.24818217157847644)))/ (abs(sqrt(abs((sin(iTime/0.037376425340919894 + 0.43268205672704463)))))+0.0001))))),3.0))) - floor(abs(sin(pow(cos(sin(sin((((y)-(sin(iTime/0.27702937544993445 + 0.797806488383189)))/ (abs(sqrt(abs((sin(iTime/0.7390386126490491 + 0.7347386838432937)))))+0.0001))))),3.0)))))))+0.0001)+(sqrt(pow(sin((y)),2.0)+pow(pow(exp(((abs(((sin(iTime/0.14356340742759954 + 0.7790959326773577))/ (abs(pow(pow((sqrt(pow(((x)+(y)),2.0)+pow(sin((sin(iTime/0.6612596860985003 + 0.11710398818870238))),2.0))),2.0),2.0))+0.0001))) - floor(abs(((sin(iTime/0.4870341755973422 + 0.6541018216662755))/ (abs(pow(pow((sqrt(pow(((x)+(y)),2.0)+pow(sin((sin(iTime/0.825267914962508 + 0.027399235966053315))),2.0))),2.0),2.0))+0.0001))))/ (abs(sign((sin(iTime/0.4859768935419986 + 0.23220255975823956))))+0.0001))/ (abs(sin((log(abs((sin(iTime/0.670649400313476 + 0.8547119247089336)))+0.0001)/ (abs(cos(cos(cos((y)))))+0.0001))))+0.0001))),3.0),2.0))));\n}\n\nfloat pixelfunc(float x, float y, float iTime) {\n\tvec2 p = vec2(x,y);\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*proc( p, iTime )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*proc( p, iTime )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*proc( p, iTime )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*proc( p, iTime )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*proc( p, iTime )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*proc( p, iTime ));\n    return f/0.96875;\n}\n\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return clamp(min2 + (value - min1) * (max2 - min2) / (max1 - min1),min2, max2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float e = 2.0/iResolution.y;\n\n    vec4 on = vec4(0.0);\n    \n        \n    float x = p.x*(0.4 + 0.2*cos(iTime*0.1 + 10.0)) + sin(iTime*0.12 + 10.0);\n    float y = (0.4+0.2*cos(iTime*0.1 + 10.0))*p.y; // p.y*0.2; //\n    float t = iTime*0.2+12.0;\n    \n    float shade = pixelfunc(x, y, t);\n    float mapped_shade = map(shade,-3.0, 3.0, 0.0, 1.0);\n    \n    \n    vec3 col = mix( vec3(0.1,0.6,0.8), vec3(0.1,0.3,0.5), mapped_shade );\n    col = vec3(mapped_shade) - vec3(0.1, 0.1, 0.2);\n    \n    \n    \n    \n \tvec3 nor = normalize( vec3( pixelfunc(x+e,y,t)-shade, \n                                2.0*e,\n                                pixelfunc(x,y+e,t)-shade ) );\n\n    vec3 lig = normalize( vec3( 0.8, 0.2, -0.4 ) );\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n    vec3 lin = vec3(0.25,0.4,0.95)*(nor.y*0.5+0.5) + vec3(0.9,0.30,0.2)*dif;\n    col *= 1.2*lin;\n\tcol = 1.0 - col;\n\tcol = 1.1*col*col;\n    \n    fragColor = vec4( col, 1.0 );\n\n    \n    \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}