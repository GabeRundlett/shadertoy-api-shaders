{
    "Shader": {
        "info": {
            "date": "1622452693",
            "description": "Dynamics of colliding spherocylinders (mouseable, new runs start automatically or by clicking upper-right)",
            "flags": 32,
            "hasliked": 0,
            "id": "stsGRj",
            "likes": 10,
            "name": "Bouncing Sticks",
            "published": 3,
            "tags": [
                "collision",
                "dynamics",
                "physics",
                "rigidbody"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 490
        },
        "renderpass": [
            {
                "code": "// \"Bouncing Sticks\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Based on bits from \"Bouncing Rings 2\" and \"Leaping Glowsticks\", with\n  more effective use of GPU parallelism.\n\n  No. 19 in \"Rigid Body Dynamics\" series\n    \"Stone Spiral\"           (XsyGDc)\n    \"Falling Towers\"         (lsG3W3)\n    \"Destruction\"            (XsKGWc)\n    \"Colliding Blocks\"       (lsG3Wd)\n    \"Jumping Cubes\"          (4s3Xzn)\n    \"Chocolate Dominoes\"     (ldBfz1)\n    \"Boxing Day\"             (ltSfzz)\n    \"Dancing Dumbbells\"      (lstyWr)\n    \"Desert Dumbbells\"       (lsdfD2)\n    \"Bouncing Rings\"         (MdVBD3)\n    \"Bouncing Chain\"         (XdKBDt)\n    \"Molecular Waltz\"        (Wt2GWG)\n    \"Colliding Blocks 2\"     (3tSXWz)\n    \"Dice Leaping\"           (3st3WS)\n    \"Leaping Glowsticks\"     (tttGR4)\n    \"Bouncing Rings 2\"       (3dScWc)\n    \"Floppy Clock With Dice\" (3sXBDr)\n    \"Soup Can Dynamics\"      (3tKyRt)\n*/\n\n#define VAR_ZERO min (iFrame, 0)\n\nmat3 QtToRMat (vec4 q);\nfloat Minv2 (vec2 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nvec3 HsvToRgb (vec3 c);\nfloat Fbm2 (vec2 p);\nvec4 Loadv4 (int idVar);\n\nvec3 qHit, qnHit, ltDir;\nfloat tCur, dstFar, cylRad, cylLen, sphGap, sphOff;\nint idObj;\nconst float pi = 3.1415927;\n\n#define BIG_SYS  1  // same in all shaders\n\n#if BIG_SYS\nconst int nObj = 100, nSphObj = 60;\n#else\nconst int nObj = 60, nSphObj = 45;\n#endif\nconst int nPre = 2;\n\nvec3 GetR (int k)\n{\n  return Loadv4 (nPre + 4 * k).xyz;\n}\n\nvec4 GetQ (int k)\n{\n  return Loadv4 (nPre + 4 * k + 2);\n}\n\nvec4 CapsHit (vec3 ro, vec3 rd, float r, float h)\n{\n  vec3 s, vn;\n  float dMin, d, a, b, w, drz;\n  dMin = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - r * r);\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    d /= max (a, 1e-6);\n    s = ro + d * rd;\n    if (d > 0. && abs (s.z) < h) {\n      dMin = d;\n      vn = vec3 (s.xy, 0.);\n    } else {\n      drz = - h * sign (s.z);\n      ro.z += drz;\n      b = dot (rd, ro);\n      w = b * b - (dot (ro, ro) - r * r);\n      if (w > 0.) {\n        d = - b - sqrt (w);\n        if (d > 0.) {\n          dMin = d;\n          vn = ro + d * rd;\n        }\n      }        \n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nfloat ObjHit (vec3 ro, vec3 rd)\n{\n  mat3 mRot;\n  vec4 cdn4;\n  vec3 rm, rom, rdm;\n  float dMin;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rm = GetR (n);\n    mRot = QtToRMat (GetQ (n));\n    rom = (ro - rm) * mRot;\n    rdm = rd * mRot;\n    cdn4 = CapsHit (rom, rdm, cylRad, cylLen);\n    if (cdn4.x < dMin) {\n      dMin = cdn4.x;\n      qHit = rom + dMin * rdm;\n      qnHit = cdn4.yzw;\n      idObj = n;\n    }\n  }\n  qnHit = QtToRMat (GetQ (idObj)) * normalize (qnHit);\n  return dMin;\n}\n\nfloat ObjHitSh (vec3 ro, vec3 rd, float rng)\n{\n  mat3 mRot;\n  vec4 cdn4;\n  vec3 rm, rom, rdm;\n  float dMin;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rm = GetR (n);\n    mRot = QtToRMat (GetQ (n));\n    rom = (ro - rm) * mRot;\n    rdm = rd * mRot;\n    cdn4 = CapsHit (rom, rdm, cylRad, cylLen);\n    dMin = min (dMin, cdn4.x);\n  }\n  return smoothstep (0.5 * rng, rng, dMin);\n}\n\nvec3 ObjCol (vec3 rd, vec3 vn, float sh)\n{\n  vec3 col;\n  col = HsvToRgb (vec3 (float (idObj) / float (nObj), 0.8, 0.9));\n  if (abs (qHit.z) < 0.3 * cylLen) col *= (0.7 +\n     0.3 * SmoothBump (0.3, 0.7, 0.05, (mod (4. * atan (qHit.y, - qHit.x) / pi, 1.))));\n  col = col * (0.2 +  0.8 * sh * max (dot (vn, ltDir), 0.)) +\n     0.2 * sh * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n  return col;\n}\n\nvec3 BgCol (vec3 ro, vec3 vn, float sh)\n{\n  vec3 col;\n  col = (mix (vec3 (0.7, 0.4, 0.2), vec3 (0.4, 0.2, 0.1), Fbm2 (ro.xz * vec2 (1., 0.15))) *\n     (0.8 + 0.2 * smoothstep (0.07, 0.15, mod (ro.x, 4.)))) * (0.2 + 0.8 * sh * max (ltDir.y, 0.));\n  col *= 0.5 + 0.5 * smoothstep (0.92, 0.96, dot (normalize (200. * ltDir - ro), ltDir));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  float dstObj, sh;\n  bool isBg;\n  cylLen = sphGap * 0.5 * (float (nSphObj / 5) - 1.) - 0.1;\n  cylRad = sphGap * sphOff + 0.35;\n  isBg = false;\n  dstObj = ObjHit (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = qnHit;\n  } else {\n    ro += ((0.5 - ro.y) / rd.y) * rd;\n    vn = vec3 (0., 1., 0.);\n    isBg = true;\n  }\n  sh = 0.6 + 0.4 * ObjHitSh (ro + 0.01 * ltDir, ltDir, 40.);\n  if (! isBg) col = ObjCol (rd, vn, sh);\n  else col = BgCol (ro, vn, sh);\n  if (isBg && rd.y < 0.) {\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    dstObj = ObjHit (ro, rd);\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      vn = qnHit;\n      col = mix (col, ObjCol (rd, vn, 1.), 0.3);\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA    0\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, mPtr;\n  vec3 col, rd, ro;\n  vec2 canvas, uv;\n  float az, el, asp, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (0);\n  sphGap = stDat.y;\n  sphOff = stDat.z;\n  mPtr = Loadv4 (1);\n  dstFar = 250.;\n  az = 0.2 * pi * sin (0.02 * pi * tCur);\n  el = -0.2 * pi;\n  if (mPtr.z > 0. && Minv2 (mPtr.xy + 0.05 * vec2 (1. / asp, 1.) - 0.5) < 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.45 * pi, -0.1 * pi);\n  zmFac = 3.8;\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -140.);\n  ltDir = vuMat * normalize (vec3 (0.5, 0.5, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (mPtr.z > 0. && Minv2 (uv - vec2 (asp, 1.)) > -0.1) col = mix (col, vec3 (0., 1., 0.), 0.3);\n  fragColor = vec4 (col, 1.);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 256.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Bouncing Sticks\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 DirToRMatT (vec3 vd, vec3 vu);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat todCur, nStep, nRun, sphGap, sphOff, farSep;\nconst float pi = 3.1415927;\nconst float txRow = 256.;\n\n#define PAR_SPH 1  // faster (uses extra parallelism, but needs 3 calls to complete)\n\n#define BIG_SYS  1  // = 0/1 (same in all shaders)\n\n#if BIG_SYS\nconst int nObj = 100, nSphObj = 60;\n#else\nconst int nObj = 60, nSphObj = 45;\n#endif\nconst int nSphTot = nObj * nSphObj;\nconst int nPre = 2;\n\nvec3 GetR (int k)\n{\n  return Loadv4 (nPre + 4 * k).xyz;\n}\n\nvec3 GetV (int k)\n{\n  return Loadv4 (nPre + 4 * k + 1).xyz;\n}\n\nvec4 GetQ (int k)\n{\n  return Loadv4 (nPre + 4 * k + 2);\n}\n\nvec3 GetW (int k)\n{\n  return Loadv4 (nPre + 4 * k + 3).xyz;\n}\n\n#if PAR_SPH\n\nvec3 GetAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k).xyz;\n}\n\nvec3 GetWAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k + 1).xyz;\n}\n\nvec3 GetRS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k).xyz;\n}\n\nvec3 GetVS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k + 1).xyz;\n}\n\n#endif\n\nvec3 RSph (float s)\n{\n  return sphGap * vec3 (Rot2D (vec2 (sphOff, 0.), mod (s, 5.) * (2. * pi / 5.)),\n     (s - 0.5 * float (nSphObj)) / 5.);\n}\n\nvec3 FcFun (vec3 dr, float rSep, vec3 dv)\n{\n  vec3 f;\n  float rSepI, vRel, fo, drv;\n  const float fOvlap = 500., fricN = 1., fricT = 2., fricS = 10.;\n  rSepI = 1. / rSep;\n  fo = fOvlap * (rSepI - 1.);\n  drv = dot (dr, dv) * rSepI * rSepI;\n  dv -= drv * dr;\n  vRel = length (dv);\n  fo = max (fo - fricN * drv, 0.);\n  f = fo * dr;\n  if (vRel > 0.001) f -= min (fricT, fricS * abs (fo) * rSep / vRel) * dv;\n  return f;\n}\n\n#if PAR_SPH\n\nvoid StepRS (int sId, out vec3 rms, out vec3 vms)\n{\n  vec3 rs;\n  int mId;\n  mId = sId / nSphObj;\n  rs = QtToRMat (GetQ (mId)) * RSph (float (sId - mId * nSphObj));\n  rms = GetR (mId) + rs;\n  vms = GetV (mId) + cross (GetW (mId), rs);\n}\n\nvoid InitRS (int sId, out vec3 rms, out vec3 vms)\n{\n  rms = vec3 (0.);\n  vms = vec3 (0.);\n}\n\nvoid StepAS (int sId, out vec3 am, out vec3 wam)\n{\n  vec3 dr, rm, rms, vms, fc;\n  float rSep;\n  int mId, sIdN;\n  mId = sId / nSphObj;\n  rm = GetR (mId);\n  rms = GetRS (sId);\n  vms = GetVS (sId);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int mIdN = VAR_ZERO; mIdN < nObj; mIdN ++) {\n    if (mIdN != mId && length (rms - GetR (mIdN)) < farSep) {\n      for (int j = VAR_ZERO; j < nSphObj; j ++) {\n        sIdN = mIdN * nSphObj + j;\n        dr = rms - GetRS (sIdN);\n        rSep = length (dr);\n        if (rSep < 1.) {\n          fc = FcFun (dr, rSep, vms - GetVS (sIdN));\n          am += fc;\n          wam += cross (rms - rm, fc);\n        }\n      }\n    }\n  }\n  rSep = abs (rms.y);\n  if (rSep < 1.) {\n    fc = FcFun (vec3 (0., rms.y, 0.), rSep, vms);\n    am += fc;\n    wam += cross (rms - rm, fc);\n  }\n}\n\nvoid InitAS (int sId, out vec3 am, out vec3 wam)\n{\n  am = vec3 (0.);\n  wam = vec3 (0.);\n}\n\n#endif\n\nvoid StepM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  mat3 mRot;\n  vec3 dr, rs, am, wam, rMom;\n  float rSep, grav, dt;\n#if ! PAR_SPH\n  mat3 mRotN;\n  vec3 rmN, vmN, wmN, rsN, dv, rms, vms, fc;\n#endif\n  grav = 10.;\n  dt = 0.01;\n  rm = GetR (mId);\n  vm = GetV (mId);\n  qm = GetQ (mId);\n  wm = GetW (mId);\n  mRot = QtToRMat (qm);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n#if ! PAR_SPH\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rmN = GetR (n);\n    if (n != mId && length (rm - rmN) < farSep) {\n      vmN = GetV (n);\n      mRotN = QtToRMat (GetQ (n));\n      wmN = GetW (n);\n      for (int j1 = VAR_ZERO; j1 < nSphObj; j1 ++) {\n        rs = mRot * RSph (float (j1));\n        rms = rm + rs;\n        vms = vm + cross (wm, rs);\n        dv = vms - vmN;\n        fc = vec3 (0.);\n        for (int j2 = VAR_ZERO; j2 < nSphObj; j2 ++) {\n          rsN = mRotN * RSph (float (j2));\n          dr = rms - (rmN + rsN);\n          rSep = length (dr);\n          if (rSep < 1.) fc += FcFun (dr, rSep, dv - cross (wmN, rsN));\n        }\n        am += fc;\n        wam += cross (rs, fc);\n      }\n    }\n  }\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rs = mRot * rs;\n    dr = rm + rs;\n    rSep = abs (dr.y);\n    if (rSep < 1.) {\n      fc = FcFun (vec3 (0., dr.y, 0.), rSep, vm + cross (wm, rs));\n      am += fc;\n      wam += cross (rs, fc);\n    }\n  }\n#else\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    am += GetAS (mId * nSphObj + j);\n    wam += GetWAS (mId * nSphObj + j);\n  }\n#endif\n  rMom = vec3 (0.);\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rMom += dot (rs, rs) - rs * rs + 1./6.;\n  }\n  rMom /= float (nSphObj);\n  wam = mRot * (wam * mRot / rMom);\n  am.y -=  grav;\n  vm += dt * am;\n  rm += dt * vm;\n  wm += dt * wam;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid InitM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  float b, fId;\n  fId = float (mId);\n  b = 2. * Hashff (17.31 * fId + floor (todCur) + 2.11 * (nRun + 1.)) - 1.;\n  rm.xz = 35. * sqrt (fId / float (nObj)) * sin (pi * (3. - sqrt(5.)) * fId + vec2 (0.5 * pi, 0.));\n  rm.y = 0.5 * sphGap * float (nSphObj / 5) + 5. + 3. * b;\n  qm = RMatToQt (DirToRMatT (normalize (vec3 (rm.xz, -80. * (1. + 0.2 * b))).xzy, vec3 (0., -1., 0.)));\n  vm = vec3 (-0.2 * (1. + 0.2 * b) * Rot2D (rm.xz, 0.3 * pi * b), - (1. + b)).xzy;\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm, am, wam;\n  vec2 iFrag, canvas;\n  float asp, mxStep, nSubStep;\n  int mId, pxId, kp;\n#if PAR_SPH\n  vec3 rms, vms;\n  int sId, rId;\n#endif\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n#if PAR_SPH\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj + 4 * nSphTot) discard;\n#else\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj) discard;\n#endif\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  kp = nPre + 4 * nObj;\n  mId = (pxId >= nPre && pxId < kp) ? (pxId - nPre) / 4 : -1;\n#if PAR_SPH\n  sId = (pxId >= kp && pxId < kp + 2 * nSphTot) ? (pxId - kp) / 2 : -1;\n  rId = (pxId >= kp + 2 * nSphTot) ? (pxId - (kp + 2 * nSphTot)) / 2 : -1;\n#endif\n  doInit = false;\n  mxStep = 5000.;\n  if (iFrame <= 5) {\n    doInit = true;\n    nRun = 0.;\n    sphGap = 1.5;\n    sphOff = 0.4;\n  } else {\n    stDat = Loadv4 (0);\n    nStep = stDat.x;\n    sphGap = stDat.y;\n    sphOff = stDat.z;\n    stDat = Loadv4 (1);\n    mPtrP.z = stDat.z;\n    nRun = stDat.w;\n    ++ nStep;\n    if (nStep > mxStep || nStep > 50. && mPtr.z > 0. && mPtrP.z < 0. &&\n       Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0.) doInit = true;\n  }\n  if (doInit) {\n    ++ nRun;\n    nStep = 0.;\n  }\n  doInit = (doInit || nStep < 20.);\n  nSubStep = mod (nStep, 3.);\n  farSep = sphGap * float (nSphObj / 5) + 2.;\n#if PAR_SPH\n  if (! doInit && (pxId >= nPre + 4 * nObj && (nSubStep == 2. || nSubStep == 1. && sId < 0 ||\n     nSubStep == 0. && rId < 0))) discard;\n#endif\n  if (mId >= 0) {\n    if (doInit) InitM (mId, rm, vm, qm, wm);\n    else {\n#if PAR_SPH\n      if (nSubStep == 2.) StepM (mId, rm, vm, qm, wm);\n      else {\n        rm = GetR (mId);\n        vm = GetV (mId);\n        qm = GetQ (mId);\n        wm = GetW (mId);\n      }\n#else\n      StepM (mId, rm, vm, qm, wm);\n#endif\n    }\n    kp = nPre + 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n#if PAR_SPH\n  } else if (sId >= 0) {\n    if (doInit) InitAS (sId, am, wam);\n    else StepAS (sId, am, wam);\n    kp = nPre + 4 * nObj + 2 * sId;\n    if      (pxId == kp + 0) stDat = vec4 (am, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (wam, 0.);\n  } else if (rId >= 0) {\n    if (doInit) InitRS (rId, rms, vms);\n    else StepRS (rId, rms, vms);\n    kp = nPre + 4 * nObj + 2 * nSphTot + 2 * rId;\n    if      (pxId == kp + 0) stDat = vec4 (rms, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vms, 0.);\n#endif\n  } else {\n    if      (pxId == 0) stDat = vec4 (nStep, sphGap, sphOff, 0.);\n    else if (pxId == 1) stDat = vec4 (mPtr.xyz, nRun);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nmat3 DirToRMatT (vec3 vd, vec3 vu)\n{\n  vec3 vc;\n  vc = cross (vu, vd);\n  if (length (vc) > 0.) vc = normalize (vc);\n  return mat3 (vc, cross (vd, vc), vd);\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi;\n  fi = float (idVar);\n  if (Maxv2 (abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5)) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Bouncing Sticks\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 DirToRMatT (vec3 vd, vec3 vu);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat todCur, nStep, nRun, sphGap, sphOff, farSep;\nconst float pi = 3.1415927;\nconst float txRow = 256.;\n\n#define PAR_SPH 1  // faster (uses extra parallelism, but needs 3 calls to complete)\n\n#define BIG_SYS  1  // = 0/1 (same in all shaders)\n\n#if BIG_SYS\nconst int nObj = 100, nSphObj = 60;\n#else\nconst int nObj = 60, nSphObj = 45;\n#endif\nconst int nSphTot = nObj * nSphObj;\nconst int nPre = 2;\n\nvec3 GetR (int k)\n{\n  return Loadv4 (nPre + 4 * k).xyz;\n}\n\nvec3 GetV (int k)\n{\n  return Loadv4 (nPre + 4 * k + 1).xyz;\n}\n\nvec4 GetQ (int k)\n{\n  return Loadv4 (nPre + 4 * k + 2);\n}\n\nvec3 GetW (int k)\n{\n  return Loadv4 (nPre + 4 * k + 3).xyz;\n}\n\n#if PAR_SPH\n\nvec3 GetAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k).xyz;\n}\n\nvec3 GetWAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k + 1).xyz;\n}\n\nvec3 GetRS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k).xyz;\n}\n\nvec3 GetVS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k + 1).xyz;\n}\n\n#endif\n\nvec3 RSph (float s)\n{\n  return sphGap * vec3 (Rot2D (vec2 (sphOff, 0.), mod (s, 5.) * (2. * pi / 5.)),\n     (s - 0.5 * float (nSphObj)) / 5.);\n}\n\nvec3 FcFun (vec3 dr, float rSep, vec3 dv)\n{\n  vec3 f;\n  float rSepI, vRel, fo, drv;\n  const float fOvlap = 500., fricN = 1., fricT = 2., fricS = 10.;\n  rSepI = 1. / rSep;\n  fo = fOvlap * (rSepI - 1.);\n  drv = dot (dr, dv) * rSepI * rSepI;\n  dv -= drv * dr;\n  vRel = length (dv);\n  fo = max (fo - fricN * drv, 0.);\n  f = fo * dr;\n  if (vRel > 0.001) f -= min (fricT, fricS * abs (fo) * rSep / vRel) * dv;\n  return f;\n}\n\n#if PAR_SPH\n\nvoid StepRS (int sId, out vec3 rms, out vec3 vms)\n{\n  vec3 rs;\n  int mId;\n  mId = sId / nSphObj;\n  rs = QtToRMat (GetQ (mId)) * RSph (float (sId - mId * nSphObj));\n  rms = GetR (mId) + rs;\n  vms = GetV (mId) + cross (GetW (mId), rs);\n}\n\nvoid InitRS (int sId, out vec3 rms, out vec3 vms)\n{\n  rms = vec3 (0.);\n  vms = vec3 (0.);\n}\n\nvoid StepAS (int sId, out vec3 am, out vec3 wam)\n{\n  vec3 dr, rm, rms, vms, fc;\n  float rSep;\n  int mId, sIdN;\n  mId = sId / nSphObj;\n  rm = GetR (mId);\n  rms = GetRS (sId);\n  vms = GetVS (sId);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int mIdN = VAR_ZERO; mIdN < nObj; mIdN ++) {\n    if (mIdN != mId && length (rms - GetR (mIdN)) < farSep) {\n      for (int j = VAR_ZERO; j < nSphObj; j ++) {\n        sIdN = mIdN * nSphObj + j;\n        dr = rms - GetRS (sIdN);\n        rSep = length (dr);\n        if (rSep < 1.) {\n          fc = FcFun (dr, rSep, vms - GetVS (sIdN));\n          am += fc;\n          wam += cross (rms - rm, fc);\n        }\n      }\n    }\n  }\n  rSep = abs (rms.y);\n  if (rSep < 1.) {\n    fc = FcFun (vec3 (0., rms.y, 0.), rSep, vms);\n    am += fc;\n    wam += cross (rms - rm, fc);\n  }\n}\n\nvoid InitAS (int sId, out vec3 am, out vec3 wam)\n{\n  am = vec3 (0.);\n  wam = vec3 (0.);\n}\n\n#endif\n\nvoid StepM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  mat3 mRot;\n  vec3 dr, rs, am, wam, rMom;\n  float rSep, grav, dt;\n#if ! PAR_SPH\n  mat3 mRotN;\n  vec3 rmN, vmN, wmN, rsN, dv, rms, vms, fc;\n#endif\n  grav = 10.;\n  dt = 0.01;\n  rm = GetR (mId);\n  vm = GetV (mId);\n  qm = GetQ (mId);\n  wm = GetW (mId);\n  mRot = QtToRMat (qm);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n#if ! PAR_SPH\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rmN = GetR (n);\n    if (n != mId && length (rm - rmN) < farSep) {\n      vmN = GetV (n);\n      mRotN = QtToRMat (GetQ (n));\n      wmN = GetW (n);\n      for (int j1 = VAR_ZERO; j1 < nSphObj; j1 ++) {\n        rs = mRot * RSph (float (j1));\n        rms = rm + rs;\n        vms = vm + cross (wm, rs);\n        dv = vms - vmN;\n        fc = vec3 (0.);\n        for (int j2 = VAR_ZERO; j2 < nSphObj; j2 ++) {\n          rsN = mRotN * RSph (float (j2));\n          dr = rms - (rmN + rsN);\n          rSep = length (dr);\n          if (rSep < 1.) fc += FcFun (dr, rSep, dv - cross (wmN, rsN));\n        }\n        am += fc;\n        wam += cross (rs, fc);\n      }\n    }\n  }\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rs = mRot * rs;\n    dr = rm + rs;\n    rSep = abs (dr.y);\n    if (rSep < 1.) {\n      fc = FcFun (vec3 (0., dr.y, 0.), rSep, vm + cross (wm, rs));\n      am += fc;\n      wam += cross (rs, fc);\n    }\n  }\n#else\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    am += GetAS (mId * nSphObj + j);\n    wam += GetWAS (mId * nSphObj + j);\n  }\n#endif\n  rMom = vec3 (0.);\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rMom += dot (rs, rs) - rs * rs + 1./6.;\n  }\n  rMom /= float (nSphObj);\n  wam = mRot * (wam * mRot / rMom);\n  am.y -=  grav;\n  vm += dt * am;\n  rm += dt * vm;\n  wm += dt * wam;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid InitM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  float b, fId;\n  fId = float (mId);\n  b = 2. * Hashff (17.31 * fId + floor (todCur) + 2.11 * (nRun + 1.)) - 1.;\n  rm.xz = 35. * sqrt (fId / float (nObj)) * sin (pi * (3. - sqrt(5.)) * fId + vec2 (0.5 * pi, 0.));\n  rm.y = 0.5 * sphGap * float (nSphObj / 5) + 5. + 3. * b;\n  qm = RMatToQt (DirToRMatT (normalize (vec3 (rm.xz, -80. * (1. + 0.2 * b))).xzy, vec3 (0., -1., 0.)));\n  vm = vec3 (-0.2 * (1. + 0.2 * b) * Rot2D (rm.xz, 0.3 * pi * b), - (1. + b)).xzy;\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm, am, wam;\n  vec2 iFrag, canvas;\n  float asp, mxStep, nSubStep;\n  int mId, pxId, kp;\n#if PAR_SPH\n  vec3 rms, vms;\n  int sId, rId;\n#endif\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n#if PAR_SPH\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj + 4 * nSphTot) discard;\n#else\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj) discard;\n#endif\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  kp = nPre + 4 * nObj;\n  mId = (pxId >= nPre && pxId < kp) ? (pxId - nPre) / 4 : -1;\n#if PAR_SPH\n  sId = (pxId >= kp && pxId < kp + 2 * nSphTot) ? (pxId - kp) / 2 : -1;\n  rId = (pxId >= kp + 2 * nSphTot) ? (pxId - (kp + 2 * nSphTot)) / 2 : -1;\n#endif\n  doInit = false;\n  mxStep = 5000.;\n  if (iFrame <= 5) {\n    doInit = true;\n    nRun = 0.;\n    sphGap = 1.5;\n    sphOff = 0.4;\n  } else {\n    stDat = Loadv4 (0);\n    nStep = stDat.x;\n    sphGap = stDat.y;\n    sphOff = stDat.z;\n    stDat = Loadv4 (1);\n    mPtrP.z = stDat.z;\n    nRun = stDat.w;\n    ++ nStep;\n    if (nStep > mxStep || nStep > 50. && mPtr.z > 0. && mPtrP.z < 0. &&\n       Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0.) doInit = true;\n  }\n  if (doInit) {\n    ++ nRun;\n    nStep = 0.;\n  }\n  doInit = (doInit || nStep < 20.);\n  nSubStep = mod (nStep, 3.);\n  farSep = sphGap * float (nSphObj / 5) + 2.;\n#if PAR_SPH\n  if (! doInit && (pxId >= nPre + 4 * nObj && (nSubStep == 2. || nSubStep == 1. && sId < 0 ||\n     nSubStep == 0. && rId < 0))) discard;\n#endif\n  if (mId >= 0) {\n    if (doInit) InitM (mId, rm, vm, qm, wm);\n    else {\n#if PAR_SPH\n      if (nSubStep == 2.) StepM (mId, rm, vm, qm, wm);\n      else {\n        rm = GetR (mId);\n        vm = GetV (mId);\n        qm = GetQ (mId);\n        wm = GetW (mId);\n      }\n#else\n      StepM (mId, rm, vm, qm, wm);\n#endif\n    }\n    kp = nPre + 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n#if PAR_SPH\n  } else if (sId >= 0) {\n    if (doInit) InitAS (sId, am, wam);\n    else StepAS (sId, am, wam);\n    kp = nPre + 4 * nObj + 2 * sId;\n    if      (pxId == kp + 0) stDat = vec4 (am, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (wam, 0.);\n  } else if (rId >= 0) {\n    if (doInit) InitRS (rId, rms, vms);\n    else StepRS (rId, rms, vms);\n    kp = nPre + 4 * nObj + 2 * nSphTot + 2 * rId;\n    if      (pxId == kp + 0) stDat = vec4 (rms, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vms, 0.);\n#endif\n  } else {\n    if      (pxId == 0) stDat = vec4 (nStep, sphGap, sphOff, 0.);\n    else if (pxId == 1) stDat = vec4 (mPtr.xyz, nRun);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nmat3 DirToRMatT (vec3 vd, vec3 vu)\n{\n  vec3 vc;\n  vc = cross (vu, vd);\n  if (length (vc) > 0.) vc = normalize (vc);\n  return mat3 (vc, cross (vd, vc), vd);\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi;\n  fi = float (idVar);\n  if (Maxv2 (abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5)) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Bouncing Sticks\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 DirToRMatT (vec3 vd, vec3 vu);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat todCur, nStep, nRun, sphGap, sphOff, farSep;\nconst float pi = 3.1415927;\nconst float txRow = 256.;\n\n#define PAR_SPH 1  // faster (uses extra parallelism, but needs 3 calls to complete)\n\n#define BIG_SYS  1  // = 0/1 (same in all shaders)\n\n#if BIG_SYS\nconst int nObj = 100, nSphObj = 60;\n#else\nconst int nObj = 60, nSphObj = 45;\n#endif\nconst int nSphTot = nObj * nSphObj;\nconst int nPre = 2;\n\nvec3 GetR (int k)\n{\n  return Loadv4 (nPre + 4 * k).xyz;\n}\n\nvec3 GetV (int k)\n{\n  return Loadv4 (nPre + 4 * k + 1).xyz;\n}\n\nvec4 GetQ (int k)\n{\n  return Loadv4 (nPre + 4 * k + 2);\n}\n\nvec3 GetW (int k)\n{\n  return Loadv4 (nPre + 4 * k + 3).xyz;\n}\n\n#if PAR_SPH\n\nvec3 GetAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k).xyz;\n}\n\nvec3 GetWAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k + 1).xyz;\n}\n\nvec3 GetRS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k).xyz;\n}\n\nvec3 GetVS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k + 1).xyz;\n}\n\n#endif\n\nvec3 RSph (float s)\n{\n  return sphGap * vec3 (Rot2D (vec2 (sphOff, 0.), mod (s, 5.) * (2. * pi / 5.)),\n     (s - 0.5 * float (nSphObj)) / 5.);\n}\n\nvec3 FcFun (vec3 dr, float rSep, vec3 dv)\n{\n  vec3 f;\n  float rSepI, vRel, fo, drv;\n  const float fOvlap = 500., fricN = 1., fricT = 2., fricS = 10.;\n  rSepI = 1. / rSep;\n  fo = fOvlap * (rSepI - 1.);\n  drv = dot (dr, dv) * rSepI * rSepI;\n  dv -= drv * dr;\n  vRel = length (dv);\n  fo = max (fo - fricN * drv, 0.);\n  f = fo * dr;\n  if (vRel > 0.001) f -= min (fricT, fricS * abs (fo) * rSep / vRel) * dv;\n  return f;\n}\n\n#if PAR_SPH\n\nvoid StepRS (int sId, out vec3 rms, out vec3 vms)\n{\n  vec3 rs;\n  int mId;\n  mId = sId / nSphObj;\n  rs = QtToRMat (GetQ (mId)) * RSph (float (sId - mId * nSphObj));\n  rms = GetR (mId) + rs;\n  vms = GetV (mId) + cross (GetW (mId), rs);\n}\n\nvoid InitRS (int sId, out vec3 rms, out vec3 vms)\n{\n  rms = vec3 (0.);\n  vms = vec3 (0.);\n}\n\nvoid StepAS (int sId, out vec3 am, out vec3 wam)\n{\n  vec3 dr, rm, rms, vms, fc;\n  float rSep;\n  int mId, sIdN;\n  mId = sId / nSphObj;\n  rm = GetR (mId);\n  rms = GetRS (sId);\n  vms = GetVS (sId);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int mIdN = VAR_ZERO; mIdN < nObj; mIdN ++) {\n    if (mIdN != mId && length (rms - GetR (mIdN)) < farSep) {\n      for (int j = VAR_ZERO; j < nSphObj; j ++) {\n        sIdN = mIdN * nSphObj + j;\n        dr = rms - GetRS (sIdN);\n        rSep = length (dr);\n        if (rSep < 1.) {\n          fc = FcFun (dr, rSep, vms - GetVS (sIdN));\n          am += fc;\n          wam += cross (rms - rm, fc);\n        }\n      }\n    }\n  }\n  rSep = abs (rms.y);\n  if (rSep < 1.) {\n    fc = FcFun (vec3 (0., rms.y, 0.), rSep, vms);\n    am += fc;\n    wam += cross (rms - rm, fc);\n  }\n}\n\nvoid InitAS (int sId, out vec3 am, out vec3 wam)\n{\n  am = vec3 (0.);\n  wam = vec3 (0.);\n}\n\n#endif\n\nvoid StepM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  mat3 mRot;\n  vec3 dr, rs, am, wam, rMom;\n  float rSep, grav, dt;\n#if ! PAR_SPH\n  mat3 mRotN;\n  vec3 rmN, vmN, wmN, rsN, dv, rms, vms, fc;\n#endif\n  grav = 10.;\n  dt = 0.01;\n  rm = GetR (mId);\n  vm = GetV (mId);\n  qm = GetQ (mId);\n  wm = GetW (mId);\n  mRot = QtToRMat (qm);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n#if ! PAR_SPH\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rmN = GetR (n);\n    if (n != mId && length (rm - rmN) < farSep) {\n      vmN = GetV (n);\n      mRotN = QtToRMat (GetQ (n));\n      wmN = GetW (n);\n      for (int j1 = VAR_ZERO; j1 < nSphObj; j1 ++) {\n        rs = mRot * RSph (float (j1));\n        rms = rm + rs;\n        vms = vm + cross (wm, rs);\n        dv = vms - vmN;\n        fc = vec3 (0.);\n        for (int j2 = VAR_ZERO; j2 < nSphObj; j2 ++) {\n          rsN = mRotN * RSph (float (j2));\n          dr = rms - (rmN + rsN);\n          rSep = length (dr);\n          if (rSep < 1.) fc += FcFun (dr, rSep, dv - cross (wmN, rsN));\n        }\n        am += fc;\n        wam += cross (rs, fc);\n      }\n    }\n  }\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rs = mRot * rs;\n    dr = rm + rs;\n    rSep = abs (dr.y);\n    if (rSep < 1.) {\n      fc = FcFun (vec3 (0., dr.y, 0.), rSep, vm + cross (wm, rs));\n      am += fc;\n      wam += cross (rs, fc);\n    }\n  }\n#else\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    am += GetAS (mId * nSphObj + j);\n    wam += GetWAS (mId * nSphObj + j);\n  }\n#endif\n  rMom = vec3 (0.);\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rMom += dot (rs, rs) - rs * rs + 1./6.;\n  }\n  rMom /= float (nSphObj);\n  wam = mRot * (wam * mRot / rMom);\n  am.y -=  grav;\n  vm += dt * am;\n  rm += dt * vm;\n  wm += dt * wam;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid InitM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  float b, fId;\n  fId = float (mId);\n  b = 2. * Hashff (17.31 * fId + floor (todCur) + 2.11 * (nRun + 1.)) - 1.;\n  rm.xz = 35. * sqrt (fId / float (nObj)) * sin (pi * (3. - sqrt(5.)) * fId + vec2 (0.5 * pi, 0.));\n  rm.y = 0.5 * sphGap * float (nSphObj / 5) + 5. + 3. * b;\n  qm = RMatToQt (DirToRMatT (normalize (vec3 (rm.xz, -80. * (1. + 0.2 * b))).xzy, vec3 (0., -1., 0.)));\n  vm = vec3 (-0.2 * (1. + 0.2 * b) * Rot2D (rm.xz, 0.3 * pi * b), - (1. + b)).xzy;\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm, am, wam;\n  vec2 iFrag, canvas;\n  float asp, mxStep, nSubStep;\n  int mId, pxId, kp;\n#if PAR_SPH\n  vec3 rms, vms;\n  int sId, rId;\n#endif\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n#if PAR_SPH\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj + 4 * nSphTot) discard;\n#else\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj) discard;\n#endif\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  kp = nPre + 4 * nObj;\n  mId = (pxId >= nPre && pxId < kp) ? (pxId - nPre) / 4 : -1;\n#if PAR_SPH\n  sId = (pxId >= kp && pxId < kp + 2 * nSphTot) ? (pxId - kp) / 2 : -1;\n  rId = (pxId >= kp + 2 * nSphTot) ? (pxId - (kp + 2 * nSphTot)) / 2 : -1;\n#endif\n  doInit = false;\n  mxStep = 5000.;\n  if (iFrame <= 5) {\n    doInit = true;\n    nRun = 0.;\n    sphGap = 1.5;\n    sphOff = 0.4;\n  } else {\n    stDat = Loadv4 (0);\n    nStep = stDat.x;\n    sphGap = stDat.y;\n    sphOff = stDat.z;\n    stDat = Loadv4 (1);\n    mPtrP.z = stDat.z;\n    nRun = stDat.w;\n    ++ nStep;\n    if (nStep > mxStep || nStep > 50. && mPtr.z > 0. && mPtrP.z < 0. &&\n       Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0.) doInit = true;\n  }\n  if (doInit) {\n    ++ nRun;\n    nStep = 0.;\n  }\n  doInit = (doInit || nStep < 20.);\n  nSubStep = mod (nStep, 3.);\n  farSep = sphGap * float (nSphObj / 5) + 2.;\n#if PAR_SPH\n  if (! doInit && (pxId >= nPre + 4 * nObj && (nSubStep == 2. || nSubStep == 1. && sId < 0 ||\n     nSubStep == 0. && rId < 0))) discard;\n#endif\n  if (mId >= 0) {\n    if (doInit) InitM (mId, rm, vm, qm, wm);\n    else {\n#if PAR_SPH\n      if (nSubStep == 2.) StepM (mId, rm, vm, qm, wm);\n      else {\n        rm = GetR (mId);\n        vm = GetV (mId);\n        qm = GetQ (mId);\n        wm = GetW (mId);\n      }\n#else\n      StepM (mId, rm, vm, qm, wm);\n#endif\n    }\n    kp = nPre + 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n#if PAR_SPH\n  } else if (sId >= 0) {\n    if (doInit) InitAS (sId, am, wam);\n    else StepAS (sId, am, wam);\n    kp = nPre + 4 * nObj + 2 * sId;\n    if      (pxId == kp + 0) stDat = vec4 (am, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (wam, 0.);\n  } else if (rId >= 0) {\n    if (doInit) InitRS (rId, rms, vms);\n    else StepRS (rId, rms, vms);\n    kp = nPre + 4 * nObj + 2 * nSphTot + 2 * rId;\n    if      (pxId == kp + 0) stDat = vec4 (rms, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vms, 0.);\n#endif\n  } else {\n    if      (pxId == 0) stDat = vec4 (nStep, sphGap, sphOff, 0.);\n    else if (pxId == 1) stDat = vec4 (mPtr.xyz, nRun);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nmat3 DirToRMatT (vec3 vd, vec3 vu)\n{\n  vec3 vc;\n  vc = cross (vu, vd);\n  if (length (vc) > 0.) vc = normalize (vc);\n  return mat3 (vc, cross (vd, vc), vd);\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi;\n  fi = float (idVar);\n  if (Maxv2 (abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5)) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}