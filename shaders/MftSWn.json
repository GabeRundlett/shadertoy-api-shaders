{
    "Shader": {
        "info": {
            "date": "1713882861",
            "description": "Simple, sparingly commented fractal perlin noise implementation in a shader.\nIf you have any questions don't hesitate to ask :)",
            "flags": 0,
            "hasliked": 0,
            "id": "MftSWn",
            "likes": 2,
            "name": "Fractal Perlin noise ",
            "published": 3,
            "tags": [
                "fractal",
                "noise",
                "perlin",
                "map",
                "mountains",
                "world"
            ],
            "usePreview": 0,
            "username": "Falafel",
            "viewed": 141
        },
        "renderpass": [
            {
                "code": "// This defines the base color based of the height.\nvec3 palette( float t ) {\n    vec3 a = vec3(0.428,0.588,0.488);\n    vec3 b = vec3(0.308,-0.142,0.500);\n    vec3 c = vec3(-0.422,-0.702,-0.382);\n    vec3 d = vec3(0.548,-0.062,-0.472);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n// The randomizer used is a very simple home-grown quadratic offset, seems to work well enough. It produces a random float from 0 - 2*PI and converts it o a vector.\n// This type of RNG is used because for the same inputs it will create the same outputs, meaning we do not need to save a grid of random vectors, but can calculate them on the fly.\nvec2 randomVector(int x, int y, float snapZoom) {\n\n    int u = x + (y + 5) * int(snapZoom);\n    \n    float r = mod(float(u * (u + 1) * 42043), 6.283185307);\n    \n    return vec2(cos(r), sin(r));\n}\n\n// The interpolation function used is known as 'smootherstep', the second-order version of https://en.wikipedia.org/wiki/Smoothstep.\nfloat interpolate(float a, float b, float f) {\n\n    return (b - a) * ((f * (f * 6.0 - 15.0) + 10.0) * f * f * f) + a;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    \n    uv.y += 0.1 * iTime;\n    uv.x += 0.05 + 0.05 * sin(iTime * 0.3);\n    \n    // Offset so division by zero doesn't happen.\n    float o = 0.00001;\n    \n    // The maximum zoom, so the definition of the highest octave.\n    float maxZoom = (sin(iTime) + 1.1) * 512.0;\n    \n    float height = 0.0;\n    \n    for (float zoom = 2.0; zoom < maxZoom + 1.0; zoom *= 2.0) { \n        \n        // Casting to an int is a simple way to create a grid. Floor would probably work too.\n        int x = int(uv.x * zoom);\n        int y = int(uv.y * zoom);\n\n        // The vector pointing from the bottom right of the square to the point, also known as the local vector.\n        vec2 loc = vec2(uv.x * zoom - float(x), uv.y * zoom - float(y));\n\n        // Calculate the Dot product of the vector from the point to each corner, and the random vector at the corner.\n        float bl = dot(vec2(o) - loc, randomVector(x, y, zoom));\n        float br = dot(vec2(1.0 + o, o) - loc, randomVector(x + 1, y, zoom));\n        float tl = dot(vec2(o, 1.0 + o) - loc, randomVector(x, y + 1, zoom));\n        float tr = dot(vec2(1.0 + o, 1.0 + o) - loc, randomVector(x + 1, y + 1, zoom));\n    \n        // Interpolates a point between the bottom two points, and then the same for the top two.\n        float b = interpolate(bl, br, uv.x * zoom - float(x));\n        float t = interpolate(tl, tr, uv.x * zoom - float(x));\n        \n        // Using the square root of zoom creates the fractal effect.\n        height += interpolate(b, t, uv.y * zoom - float(y)) / pow(zoom, 0.5);\n\n    }\n    \n    fragColor = vec4(palette(height + 0.05), 0.0);\n    \n    \n    // The following turns the noise into a simple map - skip if you just need the noise.\n    \n    // Water\n    if (height < -0.07) {\n        fragColor.z += 0.45;\n        fragColor.y -= 0.2;\n        fragColor /= 1.55;\n    }\n    // Shallows\n    else if (height < 0.0) {\n        fragColor.z += 0.5;\n        fragColor.y -= 0.2;\n        fragColor /= 1.1;\n    }\n    // Beach\n    \n    else if (height < 0.05) {\n        fragColor.x += 0.3;\n        fragColor.g += 0.15;\n        fragColor.z += 0.15;\n    }\n    // Snow\n    \n    if (height > 0.3) {\n        fragColor.xyz += 0.9;\n    }\n    // Mountains\n    \n    else if (height > 0.225) {\n    fragColor.y -= 0.2;\n    fragColor.x += 0.23;\n    fragColor.z += 0.3;\n    }\n    // High forest\n    \n    else if (height > 0.11) {\n    fragColor.y -= 0.2;\n    fragColor.z += 0.1;\n    }\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}