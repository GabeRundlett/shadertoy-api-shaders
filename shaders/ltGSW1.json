{
    "Shader": {
        "info": {
            "date": "1484113555",
            "description": "A shader explaining the technique I used to create volumetric shadows in my other shader Pixel Mountains (https://www.shadertoy.com/view/XlGXW1).",
            "flags": 32,
            "hasliked": 0,
            "id": "ltGSW1",
            "likes": 57,
            "name": "2D Volumetric Light Tutorial",
            "published": 3,
            "tags": [
                "2d",
                "tutorial",
                "shadow",
                "light",
                "volumetric"
            ],
            "usePreview": 0,
            "username": "jackdavenport",
            "viewed": 3185
        },
        "renderpass": [
            {
                "code": "// Main Image - Step Animation\n// This shader is purely to show off each individual step in the viewport on the left.\n// None of the tutorial code is in this shader.\n// Start from Buffer A and work your way across.\n\n// Thnx FabriceNeyret2\n// Source: https://www.shadertoy.com/view/ltcXzs\nvec4 char(vec2 p, float c) {\n    if (p.x<0.|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn texture( iChannel3, p/16. + fract( floor(vec2(c, 15.999-c/16.)) / 16. ) );\n}\n\n#define chr(a) ch = char(uv, a); fragColor.xyz = mix(fragColor.xyz, tint, ch.r); uv.x -= .5;\n#define T mod(iTime,16.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 ouv = fragCoord.xy / iResolution.xy;\n    float v = clamp(pow(ouv.y,.5),0.,1.);\n    \n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    uv *= 9.;\n    uv.x += 8.;\n    uv.y += 4.3;\n    \n    float t = iMouse.z > 0. ? (iMouse.x/iResolution.x)*16. : T;\n    int state = (ouv.x < smoothstep(3.,4.,t)   ? 1 : 0) + // 0 - 1\n        \t\t(ouv.x < smoothstep(7.,8.,t)   ? 1 : 0) + // 1 - 2\n        \t\t(ouv.x < smoothstep(11.,12.,t) ? 1 : 0) + // 2 - 3\n        \t\t(ouv.x < smoothstep(15.,16.,t) ? 1 : 0);  // 3 - 4\n    vec4 ch;\n    vec3 tint = vec3(1.);\n   \n    if(state == 0 || state == 4) {\n        fragColor = texture(iChannel0, ouv)*v;\n    \tchr(83.);\n    \tchr(116.);\n    \tchr(101.);\n    \tchr(112.);\n    \tchr(32.);\n    \tchr(49.);\n    \tchr(58.);\n    \tchr(32.);\n    \tchr(50.);\n    \tchr(68.);\n    \tchr(32.);\n    \tchr(83.);\n    \tchr(99.);\n    \tchr(101.);\n    \tchr(110.);\n    \tchr(101.);\n    }\n    if(state == 1) {\n        fragColor = texture(iChannel0,ouv).aaaa;\n        chr(83.);\n        chr(116.);\n        chr(101.);\n        chr(112.);\n        chr(32.);\n        chr(50.);\n        chr(58.);\n        chr(32.);\n        chr(65.);\n        chr(108.);\n        chr(112.);\n        chr(104.);\n        chr(97.);\n        chr(32.);\n        chr(77.);\n        chr(97.);\n        chr(115.);\n        chr(107.);\n    }\n    if(state == 2) {\n        fragColor = texture(iChannel1,ouv);\n        chr(83.);\n        chr(116.);\n        chr(101.);\n        chr(112.);\n        chr(32.);\n        chr(51.);\n        chr(58.);\n        chr(32.);\n        chr(82.);\n        chr(97.);\n        chr(100.);\n        chr(105.);\n        chr(97.);\n        chr(108.);\n        chr(32.);\n        chr(66.);\n        chr(108.);\n        chr(117.);\n        chr(114.);\n    }\n    if(state == 3) {\n        fragColor = texture(iChannel2,ouv)*v;\n        chr(83.);\n        chr(116.);\n        chr(101.);\n        chr(112.);\n        chr(32.);\n        chr(52.);\n        chr(58.);\n        chr(32.);\n        chr(70.);\n        chr(105.);\n        chr(110.);\n        chr(97.);\n        chr(108.);\n    }\n    fragColor.a = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Buffer A - 2D Scene\n// This is where the actual 2D rendering of the scene takes place.\n// The alpha channel is a mask of the light, which turns black when\n// objects pass in front of the light.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // transform the UV into homogenous aspect-correct space\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    \n    // initialize the fragColor variable with our clear color\n    // alpha channel must be 0!\n    fragColor = vec4(.4,.6,.9,0.);\n    \n    // create the light source (can be visible in the scene, but not necessary)\n    float d = clamp(length(uv)-.125,0.,1.);\n    if(d <= 0.) {\n        // set fragColor.a to 1 (do this regardless of whether the light is visible)\n        fragColor = vec4(1.,1.,1.,1.);\n    }\n    \n    // add some 2D objects to occlude the light\n    if(uv.y < -texture(iChannel0, vec2(uv.x+iTime*.05,0.)).r+.45) {\n        // if the light is occluded, make the alpha channel 0 (this is important!)\n        fragColor = vec4(0.,1.,0.,0.);\n    }\n    if(uv.y < -texture(iChannel0, vec2(uv.x+iTime*.2,.25)).r+.5) {\n        fragColor = vec4(1.,0.,0.,0.);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Buffer B - Radial Blur\n// Here, we will perform a radial blur on Buffer A's alpha mask to create\n// the volumetric shadows.\n\n// How many texture samples will we take?\n// The quality improves as this number increases, but it also brings down performance.\n#define VOLUME_SAMPLES 128\n\n// How far the volumetric shadow will is visible.\n// This should be pretty small, otherwise some problems will pop up.\n#define VOLUME_RADIUS .025\n\n// How bright the volume is\n// The volume is added to the scene through screen blending, and will wash out\n// the scene if this is too high.\n#define VOLUME_INTENSITY 1.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Create the UVs\n    // We're sampling Buffer A's texture, so this shouldn't be homogenous.\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // The center of the radial blur is the screen-space position of the light.\n    // This HAS TO BE the same as the 2D pass. If it's not the light won't look right.\n    // If this was a 3D scene, we could probably use some math tricks to find this, but\n    // we'll do it ourselves for the sake of the tutorial.\n    vec2  c = vec2(.5,.5);\n    \n    // The sum of the volumetric light. All our textures samples will be stored here.\n    vec3  s = vec3(0.);\n    \n    // The weight, determining how bright each sample should be, to prevent washing out\n    // the image.\n    float w = 1./float(VOLUME_SAMPLES);\n    \n    // Begin the for loop.\n    for(int i = 0; i < VOLUME_SAMPLES; i++) {\n        // Add one texture sample to the sum.\n        // ONLY ADD THE ALPHA CHANNEL! This is important!\n        s += texture(iChannel0, uv).a;\n        \n        // Calculate the direction of the radial blur. Don't normalize this!\n        vec2 d = c-uv;\n        // Add the direction to the UV, ready to be re-sampled.\n        uv += d * VOLUME_RADIUS;\n    }\n    \n    // Set the output color to the sum of the samples, multiplied by the weight and intensity.\n    // This should give you the final volumetric light effect!\n    fragColor.xyz = s*w*VOLUME_INTENSITY;\n    fragColor.w   = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Buffer C - Final image\n// This buffer isn't necessary, and you should add the volumetric light\n// to the scene's color in one pass, but I'm doing this for the sake of the tutorial\n// and to keep any tutorial code out of the main image (so I can animate it).\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate the UVs\n    vec2 uv = fragCoord / iResolution.xy;\n   \n    // Blend the two passes together, creating the final image\n    vec3 c1 = texture(iChannel0,uv).xyz;\n    vec3 c2 = texture(iChannel1,uv).xyz;\n    fragColor.xyz = 1.-(1.-c1)*(1.-c2);\n    \n    // Make sure the alpha channel is 1\n    fragColor.a = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}