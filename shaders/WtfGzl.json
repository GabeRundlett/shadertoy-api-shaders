{
    "Shader": {
        "info": {
            "date": "1557479425",
            "description": "Glossy pathtracer",
            "flags": 48,
            "hasliked": 0,
            "id": "WtfGzl",
            "likes": 1,
            "name": "progressive_glossy_pathtracer",
            "published": 3,
            "tags": [
                "pathtracer",
                "progressive"
            ],
            "usePreview": 0,
            "username": "gfy_9001",
            "viewed": 290
        },
        "renderpass": [
            {
                "code": "vec3 Tone(vec3 col)\n{\n    return pow( clamp( col, 0.0, 1.0 ), vec3(0.45f, 0.45f, 0.45f) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    \n    if( iFrame > 0 )\n    {\n        col = texture( iChannel0, uv ).xyz;\n        col = Tone(pow( col, vec3(0.4545) ));\n    }\n        \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define SAMPLES 20\n#define PATH_LENGTH 10\n\n#define NUM_OF_SPHERE 3\n#define NUM_OF_BOX 9\n\n// IOR of materials - https://pixelandpoly.com/ior.html\n\n#define AIR 1.0\n#define GLASS 1.5\n#define DIAMOND 2.418\n#define STEEL 2.500\n\nSphere spheres[NUM_OF_SPHERE];\nBox boxes[NUM_OF_BOX];\n\nvoid CreateScene()\n{\n\tspheres[0].position = vec3(-2.0,.0,12.0);\n\tspheres[0].radius = 3.0;\n\tspheres[0].material.colourIOR = vec4(LightColour3, 0.0);\n\tspheres[0].material.isLightisMetal = bvec2(true, false);\n    spheres[0].material.light.intensity = 1.0;\n    spheres[0].material.light.colour = LightColour3;\n    \n\tspheres[1].position = vec3(8.0,2.0,12.0);\n\tspheres[1].radius = 3.0;\n\tspheres[1].material.colourIOR = vec4(vec3(1.0), 0.0);\n\tspheres[1].material.isLightisMetal = bvec2(false, true);\n    \n\tspheres[2].position = vec3(4.0,-8.0,15.0);\n\tspheres[2].radius = 3.3;\n\tspheres[2].material.colourIOR = vec4(vec3(1.0), 0.0);\n\tspheres[2].material.isLightisMetal = bvec2(false, true);\n\n\t// right\n\tboxes[0].material.colourIOR = vec4(vec3(0.95,0.05,0.05), 0.0);\n\tboxes[0].material.isLightisMetal = bvec2(false, true);\n    boxes[0].position = vec3(16.0,-3.0,0.0);\n    boxes[0].size = vec3(2, 10, 30);\n    \n    // T(ranslation) R(otation) S(cale) order\n    // not implemted rotation so the world \n    // matrix will just be the translation matrix\n    boxes[0].world = GetTranslationMatrix(boxes[0].position);\n    // inverting the world matrix back into local coordinate space\n    boxes[0].local = inverse(boxes[0].world);\n    \n    // left\n\tboxes[1].material.colourIOR = vec4(vec3(0.05,0.95,0.05), 0.0);\n\tboxes[1].material.isLightisMetal = bvec2(false, true);\n\tboxes[1].position = vec3(-12.0,-3.0,0.0);\n    boxes[1].size = vec3(0.2, 10, 30);\n    boxes[1].world = GetTranslationMatrix(boxes[1].position);\n    boxes[1].local = inverse(boxes[1].world);\n\t\n    // back\n\tboxes[2].material.colourIOR = vec4(vec3(0.9,0.9,0.9), 0.0);\n\tboxes[2].material.isLightisMetal = bvec2(false, false);\n\tboxes[2].position = vec3(2.0,-3.0,20.0);\n    boxes[2].size = vec3(15, 10, 0.2);\n    boxes[2].world = GetTranslationMatrix(boxes[2].position);\n    boxes[2].local = inverse(boxes[2].world);\n\n    // bottom\n\tboxes[3].material.colourIOR = vec4(vec3(0.9), 0.0);\n\tboxes[3].material.isLightisMetal = bvec2(false, false);  \n\tboxes[3].position = vec3(2.0,-12.0,20.0);\n    boxes[3].size = vec3(20, 0.2, 30);\n    boxes[3].world = GetTranslationMatrix(boxes[3].position);\n    boxes[3].local = inverse(boxes[3].world);\n    \n    // top\n\tboxes[4].material.colourIOR = vec4(vec3(0.9,0.9,0.9), 0.0);\n\tboxes[4].material.isLightisMetal = bvec2(false, false);  \n\tboxes[4].position = vec3(2.0,7.0,0.0);\n    boxes[4].size = vec3(20, 0.2, 30);\n    boxes[4].world = GetTranslationMatrix(boxes[4].position);\n    boxes[4].local = inverse(boxes[4].world);\n    \n    // centre box\n    mat4 rot = GetAARotationMatrix(vec3(0,-1,0), RADS(15.0));\n\tboxes[5].material.colourIOR = vec4(vec3(0.9,0.9,0.9), 0.0);\n\tboxes[5].material.isLightisMetal = bvec2(false, true); \n\tboxes[5].position = vec3(-4.0,-8.0,12.0);\n    boxes[5].size = vec3(3, 3, 3);\n    boxes[5].world = GetTranslationMatrix(boxes[5].position) * rot;\n    boxes[5].local = inverse(boxes[5].world);\n    \n    // ceiling light\n\tboxes[6].material.colourIOR = vec4(vec3(0.9,0.9,0.9), 0.0);\n\tboxes[6].material.isLightisMetal = bvec2(true, false); \n\tboxes[6].position = vec3(1.3,6.96,4.0);\n    boxes[6].size = vec3(3, .2, 3);\n    boxes[6].world = GetTranslationMatrix(boxes[6].position);\n    boxes[6].local = inverse(boxes[6].world);\n\tboxes[6].material.light.intensity = 1.0;\n    boxes[6].material.light.colour = LightColour3;\n    \n    // right box - rotated\n    rot = GetAARotationMatrix(vec3(0,1,0), RADS(45.0));\n\tboxes[7].material.colourIOR = vec4(vec3(0.9,0.9,0.9), 0.0);\n\tboxes[7].material.isLightisMetal = bvec2(false, true);  \n\tboxes[7].position = vec3(8.3,-7.96,10.0);\n    boxes[7].size = vec3(3, 6, 2);    \n    boxes[7].world = GetTranslationMatrix(boxes[7].position) * rot;\n    boxes[7].local = inverse(boxes[7].world);\n\tboxes[7].material.light.intensity = 1.0;\n    boxes[7].material.light.colour = LightColour3;\n    \n    // front\n\tboxes[8].material.colourIOR = vec4(vec3(0.9,0.9,0.9), 0.0);\n\tboxes[8].material.isLightisMetal = bvec2(false, false);   \n\tboxes[8].position = vec3(2.0,-2.0,-16.0);\n    boxes[8].size = vec3(50, 25, 8.5);\n    boxes[8].world = GetTranslationMatrix(boxes[8].position);\n    boxes[8].local = inverse(boxes[8].world);\n}\n\nfloat FindIntersection(Ray ray, out Surface surface)\n{\n    float t = MAX_DISTANCE;    \n    for(int sphereID = 0; sphereID < NUM_OF_SPHERE; ++sphereID)\n    {\n        Sphere sphere = spheres[sphereID];\n        vec4 temp = RaySphereIntersection(ray, sphere);    \n    \tif( temp.x > EPSILON && temp.x < t )\n    \t{\n\t\t\tt = temp.x;\n            Ray tmpRay = ray;\n            tmpRay.origin += t * ray.direction;\n    \t    surface.material = sphere.material;\n            surface.normal = temp.yzw;\n    \t}\n    }\n    \n    for(int boxID = 0; boxID < NUM_OF_BOX; ++boxID)\n    {\n        Box box = boxes[boxID];\n        vec4 temp = RayBoxIntersection(ray, box);\n\t\tif( temp.x > EPSILON && temp.x < t )\n      \t{\n\t\t\tt = temp.x;\n\t\t\tsurface.material = box.material;\n\t\t\tsurface.normal = (box.world * vec4(temp.yzw, 0.0)).xyz;\n      \t}\n    }\n    \n    return t;\n}\n\nvec3 CastRay(Ray ray, float seed)\n{\n    vec3 fCol = vec3(0.0);\n    vec3 col = vec3(1.0);\n    Surface surface;\n    \n    for(int pathID = 0; pathID < PATH_LENGTH; ++pathID)\n    {\n        float p1 = FindIntersection(ray, surface);\n        \n        // POSITION\n        //return ( ray.origin + p1 * ray.direction );\n        \n        // DEPTH\n        //return (vec3(p1)) / 255.0;\n        // or \n        //return 1.0 / vec3(p1);\n        \n        // NORMAL\n        //return surface.normal;\n        \n        // COLOUR\n        //return surface.material.colour;        \n        \n        if(surface.material.colourIOR.r <= -1.0)\n        {\n            return fCol;\n        }\n        \n        if(bool(surface.material.isLightisMetal.x))\n        {\n            fCol += col * (surface.material.light.intensity * surface.material.light.colour);\n            return fCol;\n        }\n        \n        ray.origin += p1 * ray.direction;     \n        \n        if( surface.material.isLightisMetal.y || surface.material.colourIOR.w > 0.0 )\n        {\n            ray.direction = BRDF(surface.normal, surface.material.colourIOR.w, surface.material.isLightisMetal.y, ray.direction, seed);\n        }\n        else\n        {\n            ray.direction = CosWeightedRandomHemisphereDirection(surface.normal, seed);            \n        }        \n        \n        // BRDF Reflection\n        //return ray.direction;\n        \n        col *= surface.material.colourIOR.rgb;\n    }\n    \n    return fCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CreateScene();    \n    \n    vec4 frameInfo = texture( iChannel0, vec2(0.5, 0.5)/iResolution.xy );\n    vec4 moveInfo = texture( iChannel0, vec2(1.5, 0.5)/iResolution.xy );\n    FrameInfo prevFrame = FrameInfo(frameInfo.z>0.0, int(frameInfo.w));    \n    \n    vec4 pixelInfo = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    vec3 oldColor = pixelInfo.xyz;\n    \n    bool textureLoaded = iChannelResolution[2].x > 0.0;\n    \n    bool mouseDown = iMouse.z > 0.0;    \n    \n\t//where's the camera?\n\tvec3 camPos = vec3(1.0, 0.387,-16.0);\n\t\n\t//camera projection settings\n\t//points along the +X/+Y corner of the view frustum\n\tvec3 frustum = vec3(1.0, iResolution.y/iResolution.x, 1.0);\n\t\n\t//where's the pixel?\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t//what's the view ray of the current pixel?\n\tvec3 t2 = vec3(uv,1.0);\n\tt2 = t2 * 2.0 - 1.0;\n\tvec3 viewDir = normalize(frustum * t2);\t\n    \n    Ray ray;\n    ray.origin = camPos;\n    ray.direction = viewDir;\n    \n    float seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n    vec3 newColor;\n    for(int sampleID = 0; sampleID < SAMPLES; ++sampleID)\n    {        \n        // accumulate\n        newColor.rgb += vec3(CastRay(ray,seed));\n    }\n    \n    // average\n    newColor.rgb /= float(SAMPLES);\n    \n    vec4 col_acc;\n    vec2 coord = floor(fragCoord.xy);\n    // Save 'uniforms' in lower left pixels\n    if(all(equal(coord.xy,vec2(0))))\n    {\n        if( mouseDown ) \n        {\n\t\t\tcol_acc = vec4(1.0, 0.0, 0.0, float(iFrame));\n        }\n        else \n        {\n            col_acc = prevFrame.mouseDown ? vec4(0.0, 1.0, 0.0, float(iFrame)) : vec4(0.0, 1.0, 0.0,frameInfo.w);\n        }\n        \n        if(iFrame==0) \n        {\n            col_acc = vec4(0.0, 1.0, 0.0, float(iFrame));\n        }\n    }\n    else if(coord.x==1.0 && coord.y == 0.0)\n    {        \n        if(iFrame==0) \n        {\n            col_acc = vec4(vec3(0.0, 0.0, 0.0), 0.0);\n        }        \n    }\n    else\n    {\n        // progressively accumulate color\n        if(!textureLoaded) \n        {\n            // set pixel seed to 0\n            col_acc = vec4(fragColor.xyz,0.0);\n        } \n        else \n        {\n            // the frame number starting at the last frame when the camera was not moving\n            int progressiveIter = 1 + iFrame - prevFrame.startingFrame;\n            col_acc.xyz = mix(oldColor, newColor.rgb, float(1.0)/float(progressiveIter));\n            col_acc.w = float(seed);\n        }\n    }\n    \n   fragColor = col_acc;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Constants\n#define MAX_DISTANCE 3.402823466E38\n#define EPSILON 0.00001\n\n// vectors\n#define zero3 vec3(0.0,0.0,0.0)\n#define OFF vec3(MAX_DISTANCE,-MAX_DISTANCE,-MAX_DISTANCE)\n\n#define RIGHT vec3(1.0,0.0,0.0)\n#define UP vec3(0.0,1.0,0.0)\n#define FORWARD vec3(0.0,0.0,1.0)\n\n#define PI 3.14159265359\n\n// Colours\n#define white4 vec4(1.0,1.0,1.0,1.0)\n#define white3 vec3(1.0,1.0,1.0)\n\n#define red4 vec4(RIGHT,1.0)\n#define red3 RIGHT\n\n#define green4 vec4(UP,1.0)\n#define green3 UP\n\n#define blue4 vec4(FORWARD,1.0)\n#define blue3 FORWARD\n\n#define LightColour3 vec3( 3.9671136, 5.2174488, 6.9 ) * 0.2\n\n#define RADS(deg) deg * PI / 180.0\n#define DEGS(rad) rad * 180.0 / PI\n\nstruct Light\n{\n    float intensity;\n    vec3 colour;\n};\n\nstruct Material\n{\n    vec4 colourIOR;\n    bvec2 isLightisMetal;\n    Light light;    \n};\n\nstruct Surface\n{\n    Material material;\n    vec3 normal;\n};\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct Sphere\n{\n    vec3 position;\n    float radius;\n    \n    Material material;\n};\n\nstruct Box\n{\n    mat4 world;\n    mat4 local;\n    vec3 position;\n    vec3 size;\n    Material material;\n};\n    \nstruct FrameInfo\n{\n    bool mouseDown; // was the mouse down in the previous frame\n    int startingFrame; // starting frame for the progressive renderer    \n};\n    \n// set column order translation matrix\n// be mindful, it's a translation & identity\n// so if you do use it to update a position and \n// rotation is being used multiply it once again with a rotation matrix\nmat4 GetTranslationMatrix( vec3 position )\n{\n    float x = position.x, \n          y = position.y, \n          z = position.z;\n    \n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                x, \t y,   z,   1.0);\n}\n\n// creates a rotation matrix using the Axis Angle representation\n// https://www.shadertoy.com/view/4djXDy\nmat4 GetAARotationMatrix( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nfloat hash1( inout float seed )\n{\n\treturn fract( sin( seed += 0.1f ) * 43758.5453123f );\n}\n\nuint base_hash(uvec2 p)\n{\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nvec2 hash2(inout float seed)\n{\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 RaySphereIntersection(Ray ray, Sphere sphere)\n{    \n    vec3   SphereRayVector   = sphere.position - ray.origin;\n\tfloat  LengthFromEdge    = dot( SphereRayVector, SphereRayVector ) - ( sphere.radius*sphere.radius );\n\tfloat  DdotSR\t\t     = dot( ray.direction, SphereRayVector );\n\tfloat  DistanceFromRay   = DdotSR * DdotSR - LengthFromEdge;\n\tfloat  IntersectionPoint = DdotSR - sqrt( abs( DistanceFromRay ) );\n    \n\tfloat ComparePoints  = step( 0.0, min( IntersectionPoint, DistanceFromRay ) );\n    float t = mix( -1.0, IntersectionPoint, ComparePoints );\n    vec3  n = mix( vec3(-1.0), ((ray.origin + t * ray.direction) - sphere.position) / sphere.radius, ComparePoints );\n    \n\treturn vec4(t, n);\n}\n\n// Box - point\n// https://www.shadertoy.com/view/4djXDy\nvec4 RayBoxIntersection(Ray ray, Box box)\n{\n    // transform the ray into the box's local coordinate, i.e. 'box' space\n    // note: 0 for vectors, i.e. directions; 1 for points, i.e. positions\n    vec3 boxRayD = (box.local * vec4(ray.direction, 0.0)).xyz;\n\tvec3 boxRayO = (box.local * vec4(ray.origin, 1.0)).xyz;\n    \n    vec3 m = 1.0 / boxRayD;\n    vec3 n = m * boxRayO;\n    vec3 k = abs(m) * box.size;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0)\n    {\n        return vec4(-1.0);\n    }\n    \n\treturn vec4(tN, -sign(boxRayD) * step(t1.yzx,t1.xyz) * step(t1.zxy,t1.xyz));\n}\n\n// Ray\nRay CalculateRay(vec2 screenPos, vec2 screenRes, vec3 origin, vec3 target, float seed, vec3 facing, vec3 side, vec3 up)\n{   \n    vec2 rayOffset = ( 4.0 * hash2( seed ) ) - ( vec2( 2.0, 2.0 ) * screenRes.xy );\n    \n    Ray ray;\n    ray.origin = origin;\n    ray.direction = normalize( ( screenPos.x + rayOffset.x ) * side + ( screenPos.y + rayOffset.y ) * up + 3.0 * facing );\n    \n    return ray;\n}\n\n// Shading\nvec3 BRDF(out vec3 normal, float ior, bool isMetal, vec3 direction, float seed)\n{\n    if( isMetal )\n    {\n        return reflect( direction, normal );\n    }\n    \n\tfloat n1, n2;\n\tfloat NdotR = dot( normal, direction );\n\tfloat refraction0 = step( float(isMetal), 0.0f );\n\tfloat refraction1 = ior;\n\n\tif( NdotR > 0.0f ) {\n\t\tn1 = refraction0;\n\t\tn2 = refraction1;\n\t\tnormal = -normal;\n\t} else {\n\t\tn1 = refraction0;\n\t\tn2 = refraction1;\n\t}\n\n\tfloat r0 = (n1 - n2) / (n1 + n2);\n\tr0 *= r0;\n\tfloat fresnel = r0 + (1.0f - r0) * pow( 1.0f - abs( NdotR ), 5.0f );\n\tif( hash1( seed ) < fresnel ) \n    {\n\t\treturn reflect( direction, normal );\n\t}\n\treturn refract( direction, normal, n2 / n1 );\n}\n\nvec3 CosWeightedRandomHemisphereDirection( const vec3 n, inout float seed )\n{\n\tvec2 r = hash2( seed );\n\t\n    // normal x (forward + up)\n\tvec3  uu = normalize( cross( n, vec3( 0.0f, 1.0f, 1.0f ) ) );\n    \n    // triple product\n    // normal x (normal x (forward + up))\n\tvec3  vv = cross( uu, n );\n\n\tfloat ra = sqrt( r.y );\n\tfloat rx = ra*cos( PI * 2.0 * r.x );\n\tfloat ry = ra*sin( PI * 2.0 * r.x );\n\tfloat rz = sqrt( 1.0f - r.y );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n\n\treturn normalize( rr );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}