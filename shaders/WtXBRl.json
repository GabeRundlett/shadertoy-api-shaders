{
    "Shader": {
        "info": {
            "date": "1597388246",
            "description": "Penrose tiling with two rhombs, where tile color depends on rhomb shape and  orientation; click in upper/lower half to see corresponding atoms or  big/small coloring.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "WtXBRl",
            "likes": 21,
            "name": "Aperiodic Penrose Tiling",
            "published": 3,
            "tags": [
                "quasicrystal",
                "symmetry",
                "pentagon"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 928
        },
        "renderpass": [
            {
                "code": "// \"Aperiodic Penrose Tiling\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Based on an old program that used OpenGL to draw quads; that was much more \n efficient than the present pixel-based version and allowed much larger grids.\n Using de Bruijn's projection method [Math. Proc. A 84 (1981) 39,53]\n\n Projection method also used by knighty (https://www.shadertoy.com/view/XdtBzH) to\n produce a symmetric pattern, but not a full aperiodic tiling.\n An alternative (and faster) substitution method was used by tomkh\n (https://www.shadertoy.com/view/4t2XWG).\n There are other examples (search: penrose) that consider the related kite-and-dart tiles.\n*/\n\n#define BIG  0  // set =1 for larger grid - more work!!!\n\n#define VAR_ZERO min (nFrame, 0)\n\nmat3 VToRMat (vec3 v, float a);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\n\nfloat tCur;\nint nFrame;\nbool showPoly, rhomCol;\nconst float pi = 3.1415927;\n\nbool InTri (vec2 p, vec2 v0, vec2 v1, vec2 v2)\n{\n  vec3 s;\n  vec2 v10, v20, p0;\n  float d;\n  v10 = v1 - v0;\n  v20 = v2 - v0;\n  d = v20.y * v10.x - v20.x * v10.y;\n  p0 = p - v0;\n  s.xy = vec2 (v20.y * p0.x - v20.x * p0.y, - v10.y * p0.x + v10.x * p0.y);\n  s = abs (vec3 (s.xy, d - s.x - s.y) - 0.5 * d);\n  return (Maxv3 (s) < 0.5 * abs (d));\n}\n\nvec3 ShowScene (vec2 uv)\n{\n  vec3 col, vn, ltDir;\n  vec2 vp[5], csn[5], g, gg, mp, offset, up, vm, v[3];\n  float gam[5], gamSum, kCur[5], d, dm, di, rr, pScale, r1, r2, ic, f;\n  bool fatRom, done;\n#if BIG\n  const float kLimit = 7.;\n  pScale = 0.09;\n#else\n  const float kLimit = 4.;\n  pScale = 0.15;\n#endif\n  offset = Rot2D (vec2 (1.7, 0.), 0.05 * pi * tCur);\n  uv /= pScale;\n  uv -= offset;\n  r1 = 0.5 * sin (pi / 5.);\n  r2 = 0.5 * sin (2. * pi / 5.);\n  for (int k = 0; k < 5; k ++) csn[k] = sin (2. * pi * float (k) / 5. + vec2 (0.5 * pi, 0.));\n  gamSum = 0.;\n  for (int k = 0; k < 4; k ++) {\n    gam[k] = 0.1 * float (k + 1);\n    gamSum += gam[k];\n  }\n  gam[4] = - gamSum;\n  done = false;\n  ic = -1.;\n  for (int k1 = VAR_ZERO; k1 <= 3; k1 ++) {\n    for (int k2 = VAR_ZERO + 1; k2 <= 4; k2 ++) {\n      if (k2 >= k1 + 1) {\n        fatRom = (k2 - k1 == 1 || k2 - k1 == 4);\n        rr = fatRom ? r2 * r2 : r1 * r1;\n        ++ ic;\n        gg = - gam[k1] * csn[k2] + gam[k2] * csn[k1];\n        di = 1. / (csn[k1].x * csn[k2].y - csn[k2].x * csn[k1].y);\n        for (float kV1 = - kLimit + float (VAR_ZERO); kV1 <= kLimit; kV1 ++) {\n          kCur[k1] = kV1;\n          for (float kV2 = - kLimit + float (VAR_ZERO); kV2 <= kLimit; kV2 ++) {\n            kCur[k2] = kV2;\n            g = (gg + kV1 * csn[k2] - kV2 * csn[k1]).yx * vec2 (1., -1.);\n            for (int k = 0; k < 5; k ++) {\n              if (k != k1 && k != k2) {\n                d = dot (csn[k], g) * di + gam[k];\n                d += step (0., d);\n                kCur[k] = floor (abs (d)) * sign (d);\n              }\n            }\n            vp[0] = vec2 (0.);\n            for (int k = 0; k < 5; k ++) vp[0] += kCur[k] * csn[k];\n            vp[1] = vp[0] + csn[k1];\n            vp[2] = vp[0] + csn[k1] + csn[k2];\n            vp[3] = vp[0] + csn[k2];\n            mp = 0.25 * (vp[0] + vp[1] + vp[2] + vp[3]) - uv;\n            if (showPoly) done = (InTri (uv, vp[0], vp[1], vp[2]) ||\n               InTri (uv, vp[0], vp[3], vp[2]));\n            else done = (dot (mp, mp) < rr);\n            if (done) break;\n          }\n          if (done) break;\n        }\n      }\n      if (done) break;\n    }\n    if (done) break;\n  }\n  if (done) {\n    if (showPoly) {\n      dm = 99.;\n      vp[4] = vp[0];\n      for (int k = 0; k < 4; k ++) {\n        up = uv - vp[k];\n        v[0] = normalize (vp[k + 1] - vp[k]);\n        if (k == 0) v[1] = v[0];\n        else if (k == 1) v[2] = v[0];\n        f = dot (v[0], up);\n        d = dot (up, up) - f * f;\n        if (d < dm) {\n          dm = d;\n          vm = v[0];\n        }\n      }\n      dm = sqrt (dm);\n      if (rhomCol) col = HsvToRgb (vec3 (0.1 * ic, (fatRom ? 1. : 0.5), 1.));         \n      else col = fatRom ? vec3 (0., 1., 0.) : vec3 (1., 0., 0.);\n      col *= 0.4 + 0.6 * smoothstep (0.01, 0.03, dm);\n      vn = VToRMat (vec3 (vm, 0.), 0.12 * pi * sign (v[1].x * v[2].y - v[2].x * v[1].y) *\n         (1. - smoothstep (0., 0.15, dm))) * vec3 (0., 0., -1.);\n    } else {\n      col = vec3 (1., 1., (fatRom ? 0. : 0.5)) * (1. - smoothstep (0.9, 0.99, dot (mp, mp) / rr));\n      vn = - normalize (vec3 (mp, 0.7));\n    }\n    ltDir = normalize (vec3 (0.4, 0.6, -1.));\n    f = max (dot (vn, ltDir), 0.);\n    col = col * (0.2 + 0.8 * f * f + 0.5 * pow (max (0., dot (ltDir,\n       reflect (vec3 (0., 0., 1.), vn))), 32.));\n    col *= 0.1 + 0.9 * smoothstep (0.1, 0.9, Maxv3 (col));\n  } else col = vec3 (0.1, 0.1, 0.1);\n  return col;\n}\n\n#define AA   0 \n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 col;\n  vec2 canvas, uv, uvv;\n  float asp, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  nFrame = iFrame;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  rhomCol = true;\n  showPoly = true;\n  if (mPtr.z > 0.) {\n    if (mPtr.y > 0.) showPoly = false;\n    else rhomCol = false;\n  }\n  if (abs (uv.x) < 1.) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n      col += (1. / naa) * ShowScene (uvv);\n    }\n  } else col = vec3 (0.82);\n  fragColor = vec4 (col, 1.);\n}\n\nmat3 VToRMat (vec3 v, float a)\n{\n  mat3 m;\n  vec3 w, b1, b2;\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  w = (1. - cs.x) * v * v + cs.x;\n  b1 = (1. - cs.x) * v.zyx * v.xzy;\n  b2 = - cs.y * v;\n  m[0][0] = w.x;  m[1][1] = w.y;  m[2][2] = w.z;\n  m[1][2] = b1.x + b2.x;  m[2][1] = b1.x - b2.x;\n  m[2][0] = b1.y + b2.y;  m[0][2] = b1.y - b2.y;\n  m[0][1] = b1.z + b2.z;  m[1][0] = b1.z - b2.z;\n  return m;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}