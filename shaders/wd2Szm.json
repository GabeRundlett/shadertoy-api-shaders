{
    "Shader": {
        "info": {
            "date": "1553378282",
            "description": "This is a minified version of my recursive Yin Yang shader that I made for JS1K. In addition to the nice infinite recursion, it also features a special smooth yin yang formula I developed.\n\nOfficial JS1k Entry Here: https://js1k.com/2019-x/demo/4187",
            "flags": 0,
            "hasliked": 0,
            "id": "wd2Szm",
            "likes": 12,
            "name": "Infinite Yin Yangs Mini",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "fractal",
                "zoom",
                "recursion"
            ],
            "usePreview": 0,
            "username": "KilledByAPixel",
            "viewed": 843
        },
        "renderpass": [
            {
                "code": "//////////////////////////////////////////////////////////////////////////////////\n// Infinite Yin Yangs Mini - By Frank Force - Copyright 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\n// official JS1k entry - https://js1k.com/2019-x/demo/4187\n\n#define T iTime\n#define R iResolution\n#define M iMouse\n\n//////////////////////////////////////////////////////////////////////////////////\n\n// code minified with ctrl-alt-test + a few tweaks\n\n// it may seem like some stuff could be smaller, but for my javascript\n// version it gets compressed with with jscrush which works really\n// well on duplicate code sections. So rather then save a calcuation in\n// a local variable, it's often better to copy paste.\n\n/*\n#define P(i)vec2(-(step(.5,fra\\\nct(3.7*sin(i)))-.5)*sin(A(i)),(step(.5,fract(3.7*sin(i)))-.5)*cos(A(i)))\n#define A(i)(6.283*fract(3.7*sin(i))+.7*mix(-1.,1.,fract(3.7*sin(i)))*T)\nvoid mainImage( out vec4 U, in vec2 Z ){vec2 p=(2.*Z.rg-R.rg)/R.g+.5*ve\\\nc2(sin(.2*T),sin(.3*T));float i=floor(T-length(p)),m=T-i-length(p),z=po\\\nw(2.718,-log(3.333)*m)*.08,v=0.;p=p*z+P(i);for(float r=0.;r<9.;++r)p+=P\\\n(i+r+1.)/3.333*pow(.3,r);for(float r=0.;r<9.;++r){m=-A(i);p=vec2(p.r*co\\\ns(m)-p.g*sin(m),p.r*sin(m)+p.g*cos(m));float b=5.*z/min(R.g,R.r),c=1.,l\\\n=length(2.*p+vec2(0,1)),d=l;if(p.r<0.)c=mix(c,0.,smoothstep(1.-b,1.+b,l\\\n));l=length(2.*p-vec2(0,1));if(p.r>0.)c=mix(0.,c,smoothstep(1.-b,1.+b,l\\\n));if(p.g>0.)d=l;v=mix(c,v,smoothstep(1.-b,1.,length(p)));if(d>.6){v=mi\\\nx(step(0.,p.g),v,smoothstep(.72,.72+b,d));if(d<.72+b&&p.g>0.)++i;break;\\\n}p.g+=mix(.5,-.5,v=step(0.,p.g));z*=2./.6;p*=2./.6;m=A(i);p=vec2(p.r*co\\\ns(m)-p.g*sin(m),p.r*sin(m)+p.g*cos(m));++i;}U=vec4(v*vec3(1.+sin(i+T+i)\\\n,1.+sin(i+T+1.),1.+sin(i+T+2.)),1.);} // Infinite Yin Yangs Mini\n*/\n\n// magic stuff\n#define A(i)(6.283*fract(3.7*sin(i))+.7*mix(-1.,1.,fract(3.7*sin(i)))*T)\n#define P(i)vec2(-(step(.5,fract(3.7*sin(i)))-.5)*sin(A(i)),(step(.5,fract(3.7*sin(i)))-.5)*cos(A(i)))\n\nvoid mainImage( out vec4 _FragColor, in vec2 _FragCoord )\n{\n    // standard uv fixup\n\tvec2 p = (2.0*_FragCoord.xy-R.xy)/R.y + 0.5*vec2(sin(0.2*T),sin(0.3*T));\n    \n    // get the recursion values\n\tfloat i = floor(T-length(p)),\n        m = T - i-length(p), \n        z = pow(2.718, -log(3.333)*m) * .08,\n        v = 0.;\n    \n    // get the zoom position\n    p = p*z+ P(i);\n\tfor (float r = 0.; r < 9.; ++r)\n\t\tp += (P(i+r+1.) / 3.333) * pow(1. / 3.333, r);\n    \n\t// recursion\n    for (float r = 0.; r<9.; ++r)\n    {\n        // rotate\n        m = -A(i);\n        p=vec2(p.x*cos(m) - p.y*sin(m), p.x*sin(m) + p.y*cos(m));\n\n        // yin yang function\n        float b = 5.*z/min(R.y, R.x),\n        c = 1.0,\n        l = length(2.0*p + vec2(0, 1)),\n        d = l;\n        if (p.x < 0.0)\n            c = mix(c, 0.0, smoothstep(1.0-b, 1.0+b, l));\n\n        l = length(2.0*p - vec2(0, 1));\n        if (p.x > 0.0)\n            c = mix(0.0, c, smoothstep(1.0-b, 1.0+b, l));\n        if (p.y > 0.0)\n            d = l;\n\n        v = mix(c, v, smoothstep(1.0-b, 1.0, length(p)));\n\n        if (d > .6)\n        {\n\t\t\t// stop if outside\n            v = mix(step(0.0, p.y), v, smoothstep(.6+.12,.6+.12+b,d));\n\n\t\t\t// fix color around the edges\n            if (d < .72+b && p.y > 0.0) ++i;\n            break;\n        }\n\n        // which side are we on?\n        p.y += mix(0.5, -0.5,  v = step(0.0,p.y));\n\n        // update zoom and position\n        z *= 2./.6;\n        p *= 2./.6;\t \n        \n        // unrotate\n        m = A(i);\n        p=vec2(p.x*cos(m) - p.y*sin(m), p.x*sin(m) + p.y*cos(m));\n       \t++i;\n    }\n    \n\t// final coloring\n    _FragColor = vec4(v*vec3(1.+sin(i+T+i),1.+sin(i+T+1.),1.+sin(i+T+2.)),1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}