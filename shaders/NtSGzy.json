{
    "Shader": {
        "info": {
            "date": "1624113845",
            "description": "Distance to a weighted \"rational\" quadratic bezier which is pretty much a parametrized conic (unweighted quadratic beziers form parabolas, a special case). It requires solving a quartic equation.",
            "flags": 0,
            "hasliked": 0,
            "id": "NtSGzy",
            "likes": 12,
            "name": "Distance to Weighted Bezier",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "distance",
                "quartic",
                "quadraticbezier",
                "weighted",
                "rationalbezier"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 739
        },
        "renderpass": [
            {
                "code": "/*\nDistance to a weighted \"rational\" quadratic bezier which\nis pretty much a parametrized conic (unweighted quadratic beziers\nform parabolas, a special case). It requires solving a quartic equation.\n\nI didn't know about this generalization until I saw this shader\nalso showing the distance to a rational bezier by @kajbostrom:\nhttps://www.shadertoy.com/view/stjGRh\n\nI learned a bit more about them from demofox's webpage: http://demofox.org/bezquadrational.html\nI'm working on simplifying and trying to increase the precision currently.\n\nBtw, the calculations turned out to have lots of patterns!\nDesmos graph of the workthrough: https://www.desmos.com/calculator/d68abzjzi9\n\nPython implementation: https://replit.com/@hathnoname/Euclidean-Distance-to-Weighted-Quadratic-Bezier#main.py\n*/\n\n// a, b, c: vec3(x, y, weight)\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat cbrt(in float x) { return sign(x) * pow(abs(x), 1.0 / 3.0); }\nfloat sdWeightedBezier(in vec2 p, in vec3 a, in vec3 b, in vec3 c) {\n    // Weighted vertex positions\n    vec2 wa = a.xy * a.z, wb = b.xy * b.z, wc = c.xy * c.z;\n\n    // Conversion to power basis makes it less messy\n    vec2 p2 = wa - 2.0 * wb + wc, p1 = 2.0 * (wb - wa), p0 = wa;\n    float w2 = a.z - 2.0 * b.z + c.z, w1 = 2.0 * (b.z - a.z), w0 = a.z;\n\n    // Reused calculations\n    float  pp0 = dot(p,  p0),  pp1 = dot(p,  p1),  pp2 = dot(p,  p2);\n    float p0p0 = dot(p0, p0), p1p1 = dot(p1, p1), p2p2 = dot(p2, p2);\n    float p0p1 = dot(p0, p1), p0p2 = dot(p0, p2), p1p2 = dot(p1, p2);\n\n    float w0w0 = w0 * w0, w1w1 = w1 * w1, w2w2 = w2 * w2;\n    float w0w1 = w0 * w1, w0w2 = w0 * w2, w1w2 = w1 * w2;\n\n    // Quartic coefficients (t4*t^4 + t3*t^3 + t2*t^2 + t1*t + t0)\n    float t4 = w1 * p2p2 - w2 * p1p2 + w2w2 * pp1 - w1w2 * pp2;\n    float t3 = 2.0 * (w0 * p2p2 - w2 * p0p2  + w2w2 * pp0 - w0w2 * pp2) + w1w2 * pp1 - w1w1 * pp2 + w1 * p1p2 - w2 * p1p1;\n    float t2 = 3.0 * (w0 * p1p2 - w2 * p0p1) + 2.0 * (w1w2 * pp0 - w0w1 * pp2) + w0w2 * pp1 - w0w1 * pp2 + w1w2 * pp0 - w0w2 * pp1;\n    float t1 = 2.0 * (w0 * p0p2 - w2 * p0p0  + w0w2 * pp0 - w0w0 * pp2) + w1w1 * pp0 - w0w1 * pp1 + w0 * p1p1 - w1 * p0p1;\n    float t0 = w0 * p0p1 - w1 * p0p0 + w0w1 * pp0 - w0w0 * pp1;\n\n    // Solve and minimize\n    float d = min(dot2(p - a.xy), dot2(p - c.xy)); // Minimize at the boundaries (bezier end points)\n\n    t3 /= t4; t2 /= t4; t1 /= t4; t0 /= t4; // Divide by leading coefficient to make it 1\n\n    // Depress the quartic to t^4 + pt^2 + qt + r by substituting t-b/4a\n    // This can be found by substituting t+u and the solving for the value\n    // of u that makes the t^3 term go away\n    float t3t3 = t3 * t3;\n    float dp = (8.0 * t2 - 3.0 * t3t3) / 8.0;\n    float dq = (8.0 * t1 - 4.0 * t2 * t3 + t3t3 * t3) / 8.0;\n    float dr = (256.0 * t0 - 64.0 * t1 * t3 + 16.0 * t2 * t3t3 - 3.0 * t3t3 * t3t3) / 256.0;\n\n    // Solve for a root to (x^2)^3 + 2p(x^2)^2 + (p^2 - 4r)(x^2) - q^2 which resolves the\n    // system of equations relating the product of two quadratics to the depressed quartic\n    float ra =  2.0 * dp;\n    float rb =  dp * dp - 4.0 * dr;\n    float rc = -dq * dq;\n\n    // Depress using the method above\n    float ru = ra / 3.0;\n    float rp = rb - ra * ru;\n    float rq = rc - (rb - 2.0 * ra * ra / 9.0) * ru;\n\n    float lambda;\n    float rh = 0.25 * rq * rq + rp * rp * rp / 27.0;\n    if (rh > 0.0) { // Use Cardano's formula in the case of one real root\n        rh = sqrt(rh);\n        float ro = -0.5 * rq;\n        lambda = cbrt(ro - rh) + cbrt(ro + rh) - ru;\n    }\n\n    else { // Use complex arithmetic in the case of three real roots\n        float rm = sqrt(-rp / 3.0);\n        lambda = -2.0 * rm * sin(asin(1.5 * rq / (rp * rm)) / 3.0) - ru;\n    }\n\n    // Solve two quadratics factored from the quartic using the cubic root\n    float x = sqrt(lambda); // Because we solved for x^2 but want x\n    float alpha = 2.0 * dq / x, beta = lambda + ra;\n\n    float u = 0.25 * t3;\n    x *= 0.5;\n\n    float z = -alpha - beta;\n    if (z > 0.0) {\n        z = sqrt(z) * 0.5;\n        float h = +x - u;\n        vec2 t = vec2(h + z, h - z);\n        if (t.x > 0.0 && t.x < 1.0) d = min(d, dot2(p - ((p2 * t.x + p1) * t.x + p0) / ((w2 * t.x + w1) * t.x + w0)));\n        if (t.y > 0.0 && t.y < 1.0) d = min(d, dot2(p - ((p2 * t.y + p1) * t.y + p0) / ((w2 * t.y + w1) * t.y + w0)));\n    }\n\n    float w = +alpha - beta;\n    if (w > 0.0) {\n        w = sqrt(w) * 0.5;\n        float h = -x - u;\n        vec2 t = vec2(h + w, h - w);\n        if (t.x > 0.0 && t.x < 1.0) d = min(d, dot2(p - ((p2 * t.x + p1) * t.x + p0) / ((w2 * t.x + w1) * t.x + w0)));\n        if (t.y > 0.0 && t.y < 1.0) d = min(d, dot2(p - ((p2 * t.y + p1) * t.y + p0) / ((w2 * t.y + w1) * t.y + w0)));\n    }\n\n    return sqrt(d);\n}\n\n// Parametric definition of a rational quadratic bezier\n// I prefer to call it \"weighted\"\nvec2 weightedBezier(in vec3 a, in vec3 b, in vec3 c, in float t) {\n    a.xy *= a.z, b.xy *= b.z, c.xy *= c.z;\n    return mix(mix(a.xy, b.xy, t), mix(b.xy, c.xy, t), t) /\n           mix(mix(a.z, b.z, t), mix(b.z, c.z, t), t);\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    // Control points with weights\n    float r = 0.5 * iTime;\n    vec2 anim = 0.1 * vec2(cos(r), sin(r));\n    vec3 a = vec3(-0.3 + anim.y, -0.2 + anim.x, 0.5);\n    vec3 b = vec3(0.2 * cos(iTime), 0.2 + 0.2 * sin(iTime), mix(-0.3, 3.0, 0.5 + 0.5 * cos(iTime)));//0.7 + cos(2.5 * iTime));\n    vec3 c = vec3(0.3 + anim.x, -0.2 + anim.y, 1.5);\n\n    // Set middle control point to the mouse position\n    // on mouse down\n    if (iMouse.z > 0.0) b.xy = mouse;\n\n    float dist = sdWeightedBezier(uv, a, b, c);\n\n    // Trying a slightly different style\n    vec3 color = vec3(0.0);\n    color += (0.6 + 0.4 * sin(dist * 300.0)) * vec3(1.0, 0.5, 0.6);\n    color *= clamp(pow(3.0 * dist, 0.4), 0.0, 1.0);\n\n    // Hull\n    drawSDF(sdLine(uv, a.xy, b.xy) - 0.002, vec3(0.0, 0.0, 1.0));\n    drawSDF(sdLine(uv, b.xy, c.xy) - 0.002, vec3(0.0, 0.0, 1.0));\n\n    // Curve\n    drawSDF(dist - 0.003, vec3(1.0));\n\n    // Testing\n    //vec2 prev = a.xy;\n    //float tStep = 0.01;\n    //for (float t=0.0; t < 1.0; t += tStep) {\n    //    vec2 cur = weightedBezier(a, b, c, t);\n    //    drawSDF(sdLine(uv, prev, cur) - 0.003, vec3(0.0, 1.0, 0.0));\n    //    prev = cur;\n    //}\n\n    // Draw control points\n    drawSDF(length(uv - a.xy) - 0.013, vec3(1.0, 1.0, 0.0));\n    drawSDF(length(uv - b.xy) - 0.013, vec3(1.0, 0.0, 0.0));\n    drawSDF(length(uv - c.xy) - 0.013, vec3(1.0, 1.0, 0.0));\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/* Backup (I'm paranoid about making mistakes ;))\n// Quartic solver I made here: https://www.shadertoy.com/view/fsB3Wt\nint solveQuartic(in float a, in float b, in float c, in float d, in float e, inout vec4 roots) {\n    b /= a; c /= a; d /= a; e /= a; // Divide by leading coefficient to make it 1\n\n    float bb = b * b;\n    float p = c - 0.375 * bb;\n    float q = d - 0.5 * b * c + 0.125 * bb * b;\n    float r = e - 0.25 * b * d + bb * c / 16.0 - 3.0 * bb * bb / 256.0;\n    int n = 0;\n\n    // Solve for an arbitary root to x^3 + 2px^2 + (p^2 - 4r)x - q^2\n    // I really want to use my simpler solver but it has worse precision :(\n    float ra = 2.0 * p;\n    float rb = p * p - 4.0 * r;\n    float rc = -q * q;\n\n    float raa = ra * ra;\n    float inflect = ra / 3.0;\n\n    float rp = rb - raa / 3.0;\n    float rq = raa * ra / 13.5 - ra * rb / 3.0 + rc;\n    float rppp = rp * rp * rp, rqq = rq * rq;\n\n    float p2 = abs(rp);\n    float v1 = 1.5 / rp * rq;\n\n    float lambda;\n    if (rqq * 0.25 + rppp / 27.0 > 0.0) {\n        float v2 = v1 * sqrt(3.0 / p2);\n        if (rp < 0.0) lambda = sign(rq) * cosh(acosh(v2 * -sign(rq)) / 3.0);\n        else lambda = sinh(asinh(v2) / 3.0);\n        lambda = -sqrt(p2 / 3.0) * lambda;\n    }\n\n    else lambda = sqrt(-rp / 3.0) * cos(acos(v1 * sqrt(-3.0 / rp)) / 3.0);\n    lambda = 2.0 * lambda - inflect;\n\n    // Solve two quadratic equations factored from the quartic using the cubic root\n    if (lambda < 0.0) return n;\n    float sqrtLambda = sqrt(lambda);\n\n    float pLambda = p + lambda, qLambda = q / sqrtLambda;\n    float offs = 0.25 * b;\n\n    float foo = lambda - 2.0 * (pLambda + qLambda);\n    float bar = lambda - 2.0 * (pLambda - qLambda);\n\n    if (foo >= 0.0) {\n        roots.xy = (vec2(1.0, -1.0) * sqrt(foo) + sqrtLambda) * 0.5 - offs;\n        n += 2;\n    }\n\n    if (bar >= 0.0) {\n        vec2 others = (vec2(1.0, -1.0) * sqrt(bar) - sqrtLambda) * 0.5 - offs;\n        if (n > 0) roots.zw = others;\n        else roots.xy = others;\n        n += 2;\n    }\n\n    return n;\n}\n\n// a, b, c: vec3(x, y, weight)\nfloat sdWeightedBezier(in vec2 p, in vec3 a, in vec3 b, in vec3 c) {\n    // Weighted vertex positions\n    vec2 wa = a.xy * a.z, wb = b.xy * b.z, wc = c.xy * c.z;\n\n    // Conversion to power basis makes it less messy\n    vec2 p2 = wa - 2.0 * wb + wc, p1 = 2.0 * (wb - wa), p0 = wa;\n    float w2 = a.z - 2.0 * b.z + c.z, w1 = 2.0 * (b.z - a.z), w0 = a.z;\n\n    // Reused calculations\n    float  pp0 = dot(p,  p0),  pp1 = dot(p,  p1),  pp2 = dot(p,  p2);\n    float p0p0 = dot(p0, p0), p1p1 = dot(p1, p1), p2p2 = dot(p2, p2);\n    float p0p1 = dot(p0, p1), p0p2 = dot(p0, p2), p1p2 = dot(p1, p2);\n\n    float w0w0 = w0 * w0, w1w1 = w1 * w1, w2w2 = w2 * w2;\n    float w0w1 = w0 * w1, w0w2 = w0 * w2, w1w2 = w1 * w2;\n\n    // Quartic coefficients (t4*t^4 + t3*t^3 + t2*t^2 + t1*t + t0)\n    float t4 = w1 * p2p2 - w2 * p1p2 + w2w2 * pp1 - w1w2 * pp2;\n    float t3 = 2.0 * (w0 * p2p2 - w2 * p0p2  + w2w2 * pp0 - w0w2 * pp2) + w1w2 * pp1 - w1w1 * pp2 + w1 * p1p2 - w2 * p1p1;\n    float t2 = 3.0 * (w0 * p1p2 - w2 * p0p1) + 2.0 * (w1w2 * pp0 - w0w1 * pp2) + w0w2 * pp1 - w0w1 * pp2 + w1w2 * pp0 - w0w2 * pp1;\n    float t1 = 2.0 * (w0 * p0p2 - w2 * p0p0  + w0w2 * pp0 - w0w0 * pp2) + w1w1 * pp0 - w0w1 * pp1 + w0 * p1p1 - w1 * p0p1;\n    float t0 = w0 * p0p1 - w1 * p0p0 + w0w1 * pp0 - w0w0 * pp1;\n\n    // Solve\n    vec4 roots;\n    int nroots = solveQuartic(t4, t3, t2, t1, t0, roots);\n\n    // Minimize distance (todo: avoid checking unecessary roots)\n    vec2 ta = p - a.xy, tc = p - c.xy;\n    float d = min(dot(ta, ta), dot(tc, tc));\n    for (int n=0; n < nroots; n++) {\n         float t = roots[n];\n         if (t > 0.0 && t < 1.0) {\n             vec2 to = p - ((p2 * t + p1) * t + p0) / ((w2 * t + w1) * t + w0);\n             d = min(d, dot(to, to));\n         }\n    }\n\n    return sqrt(d);\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}