{
    "Shader": {
        "info": {
            "date": "1696522133",
            "description": "Backrooms inspired scenery shader with hacky water and a VHS filter.",
            "flags": 32,
            "hasliked": 0,
            "id": "DdyyWR",
            "likes": 35,
            "name": "Backroom Pools",
            "published": 3,
            "tags": [
                "sdf",
                "water",
                "pool",
                "backroom"
            ],
            "usePreview": 0,
            "username": "servostar",
            "viewed": 659
        },
        "renderpass": [
            {
                "code": "\n#define CIRCLE\n\nconst float TWO_PI = 6.283185307179586;\n\nfloat seed = 0.0;\nfloat rand()\n{\n    seed += .2874365;\n    return fract(sin(seed * 475.89756) * 45.487);\n}\n\nfloat luminance(in vec3 rgb)\n{\n    return dot(rgb, vec3(0.21, 0.72, 0.07));\n}\n\n/**\n* Intensifies the brightest pixels of the applied kernel based on the luminance() function\n* This is a modified dilation filter\n*/\nvec3 bokeh(in sampler2D tex, in vec2 uv, in float sep)\n{\n    vec3 cc = texture(tex, uv).rgb;\n    vec3 tc = cc;\n    float cl = luminance(cc);\n\n    vec2 texSize = sep/vec2(textureSize(tex, 0));\n\n    for (float i = 0.0; i < 64.0; i++)\n    {\n        vec2 rr = vec2(rand(), rand())*vec2(TWO_PI, 1);\n        vec2 xy = vec2(sin(rr.x), cos(rr.x))*rr.y;\n\n        vec2 off = xy*texSize;\n        vec3 s = texture(tex, uv + off).rgb;\n        float b = luminance(s);\n\n        if (cl < b)\n        {\n            cl = b;\n            tc = s;\n        }\n    }\n    \n    return tc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // linear RGB\n    vec3 col = bokeh(iChannel0, uv, 12.*pow(length(uv-.5), 3.));\n\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Noise/hash algorithms from: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat rand(vec3 n) { \n\treturn fract(sin(dot(n, vec3(12.9898, 4.1414, 7.829754))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Rotate a 2D vector\nvoid mkrot(inout vec2 v, in float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    v *= mat2(c,-s,s,c);\n}\n\n// SDF of box\nfloat box(in vec3 p, in vec3 s)\n{\n    vec3 q = abs(p) - s;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// SDF of cylinder\nfloat cylinder(in vec3 p, in float h, in float r)\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat map(in vec3 p, in vec3 bp)\n{\n    float h = max(p.y-5., -box(p-vec3(0,1,0), vec3(12, 3, 11)) );\n    h = max(h, -cylinder( (p.xyz*vec3(1,.85,1)-vec3(-.3, 0, 10)).xzy, 8.0, 3.0));\n    h = max(h, -(box(p-vec3(1, 1, 23), vec3(1.5,2,5))-1.));\n\n    h = min(h,  box(p-vec3( 3.5,-1.5,10), vec3(2,2,9)));\n\n    h = max(h, -cylinder(p - vec3(0,4,6), 9.0, 1.4) );\n\n    h = max(h, -cylinder(p - vec3(-2,0,6), 3.0, 2.0) );\n    h = max(h, -cylinder(p - vec3(-1,0,6), 4.0, 2.0) );\n\n    h = max(h, -box(p - vec3(-1,4,20), vec3(2)) );\n    \n    h = min(h, cylinder(vec3(p.x-.5,p.y, p.z - 4.*round(p.z*.25)) - vec3(+3.5,2,0), 12.0, .4) );\n    h = min(h, cylinder(vec3(p.x+2.,p.y, p.z - 3.*round(p.z*.33)) - vec3(-3.5,2,0), 12.0, .4) );\n    h = min(h, cylinder(vec3(p.x+2.,p.y-2.8, p.z - 3.*round(p.z*.33)) - vec3(-3.5,2,0), 1.0, .6) );\n    h = min(h, cylinder(vec3(p.x+2.,p.y+2.8, p.z - 3.*round(p.z*.33)) - vec3(-3.5,2,0), 1.0, .86) );\n    \n    h = max(h, -box(p-vec3(0, 2, 18), vec3(6,3,4)));\n    \n    h = min(h, length(p - bp)-.5 );\n    \n    return h;\n}\n\nconst float eps = 1e-3;\n\nfloat water(in vec3 p, in vec3 bp)\n{\n    return p.y + noise(p.xz * 6. - vec2(iTime*.5, iTime)) * .01\n            + sin(length(p.xz - bp.xz) * 10. - iTime * 6.)*.01 / length(p.xz - bp.xz)*2.;\n}\n\nconst vec3 sun = normalize(vec3(.2, 1, -.1));\n\nfloat shadow(in vec3 ro, in vec3 rd, in float d, in vec3 bp)\n{\n    float k = 8.;\n    float res = 1.0;\n    float t = 1e-1;\n    for(int i = 0; i < 128 && t < d; i++)\n    {\n        float h = map(ro + rd * t, bp);\n\n        if (h < 5e-3)\n            return 0.0;\n\n        res = min(res, k*h/t);\n        t += h;\n    }\n    return res;\n}\n\n// Compute point light intensitywith soft shadows\nfloat pointlight(in vec3 p, in vec3 n, in vec3 t, in float i, in vec3 bp)\n{\n    vec3 d = normalize(t - p);\n    float l = shadow(p, d, length(p-t), bp);\n    return l * dot(-d, n) / length(t-p) * i;\n}\n\n// Compute specular reflection with no reflection depth \nvec3 spec(in vec3 p, in vec3 n, in vec3 rd, in vec3 bp)\n{\n    float t = 1e-2;\n    vec3 d = reflect(rd, n);\n    for(int i = 0; i < 256; i++)\n    {\n        float h = map(p + d * t, bp);\n\n        if (h < 1e-3)\n            return max(mix(vec3(.7,1,1), vec3(0,.1,.4), rand(floor((p + d * t) * 16.)) ) * clamp(0., 1., t*.1), vec3(0));\n\n        t += h;\n    }\n    return vec3(5);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord -.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(2, 1.8, sin(iTime*2.)*.05 );\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    // static camera rotation\n    mkrot(rd.yz, 0.12);\n    mkrot(rd.xz, 0.2);\n    \n    // dynamic camera wiggle\n    mkrot(rd.xy, sin(iTime*1.)*.02 );\n    mkrot(rd.yz, cos(iTime*2.2)*.01 );\n\n    vec3 col = vec3(0);\n    \n    vec3 p = ro;\n    vec4 wr = vec4(0); // water reflection and cos theta\n    bool ref = true;   // if water surface was hit\n\n    // precompute position of water ball\n    float bt = iTime * .16;\n    vec3 bp = vec3(-2. +cos(bt) , sin(iTime*3.)*.05 + .2, 5. +sin(bt) );\n    \n    for (int i = 0; i < 256; i++)\n    {\n        float h = map(p, bp);\n        float wh = water(p, bp);\n    \n        if (h < 1e-3)\n        {\n            // normal of geometry\n            vec3 nor = normalize(map(p, bp) - vec3(\n                map(p + vec3(eps, 0, 0), bp),\n                map(p + vec3(0, eps, 0), bp),\n                map(p + vec3(0, 0, eps), bp)\n            ));\n\n            // direct sun light\n            float lum = shadow(p, sun, 1e3, bp) * 3.;\n            float key = lum; // save direct sun light for later\n\n            // atrium\n            lum = max(lum, pointlight(p, nor, vec3(0,0,6), 3., bp) );\n            lum = max(lum, pointlight(p, nor, vec3(-1,2,6), 2., bp) );\n\n            // back room\n            lum = max(lum, pointlight(p, nor, vec3(-2.5,0,20), 2., bp) );\n            lum = max(lum, pointlight(p, nor, vec3(-.5,1,23), .5, bp) );\n\n            // albedo for tiles\n            vec3 alb = mix(vec3(.7,1,1), vec3(0,.1,.4), rand(floor(p * 12.)) );\n            \n            // specular reflection\n            vec3 spec = spec(p, nor, rd, bp);\n\n            // mask out water ball for custom material\n            if (distance(bp, p) < 1.)\n            {\n                // offset origin to center of ball\n                // rotate ball\n                vec3 pm = p - bp;\n                mkrot(pm.xz, -iTime * .2);\n                mkrot(pm.yz,  iTime * .3);\n                \n                // texture the ball\n                alb = mix(vec3(1,0,0), vec3(1,1,0), step(.0, sin(atan(pm.z/pm.x) * 4.)) );\n                alb = mix(alb, vec3(1), step(.49, abs(pm.y)) );\n                \n                // apply specular and diffuse illumination\n                col = mix(spec, alb * (lum * .7 + .3), pow(dot(nor, rd), .6) );\n            }\n            else\n                // we hit the tile environment\n                // apply specular and diffuse illumination\n                col = mix(spec, alb * lum, pow(dot(nor, rd), .2) );\n\n            // check if water surface was hit before geometry\n            if (!ref)\n            {\n                // water caustics\n                vec3 s = smoothstep(0.95, 1., cos(p*16. + (noise(p.xy) + noise(p.yz)) * 32. + iTime*6.));\n                col += (s.x+s.z+s.y) * lum * key;\n\n                col = mix(col, vec3(.2,.8,1) * lum, clamp( pow(abs(p.y), 2.) * 7e-2, .0, .7) );\n                col = mix(wr.rgb, col, wr.a);\n            }\n\n            break;\n        } else if (ref && wh < 1e-6)\n        {\n            vec3 n = normalize(wh + vec3(\n                water(p + vec3(eps, 0, 0), bp),\n                water(p + vec3(0, eps, 0), bp),\n                water(p + vec3(0, 0, eps), bp)\n            ));\n\n            rd = refract(rd, n, 1./1.45);\n            ref = false;\n            wr = vec4(spec(p, n, rd, bp), dot(-n, rd));\n        }\n\n        h = ref ? min(h, wh) : h;\n        p += rd * h;\n    }\n    \n    col = mix(max(col, vec3(0)), texture(iChannel0, (fragCoord.xy+.5)/iResolution.xy).rgb, .5);\n\n    fragColor = vec4(col, distance(ro, p));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec3 uncharted2_tonemap_partial(vec3 x)\n{\n    float A = 0.15f;\n    float B = 0.50f;\n    float C = 0.10f;\n    float D = 0.20f;\n    float E = 0.02f;\n    float F = 0.30f;\n    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvec3 uncharted2_filmic(vec3 v)\n{\n    float exposure_bias = 2.0f;\n    vec3 curr = uncharted2_tonemap_partial(v * exposure_bias);\n\n    vec3 W = vec3(11.2f);\n    vec3 white_scale = vec3(1.0f) / uncharted2_tonemap_partial(W);\n    return curr * white_scale;\n}\n\nvec3 conv(in sampler2D tex, in vec2 uv, in mat3 ker)\n{\n    vec3 sum = vec3(0);\n    \n    for (int x = 0; x < 3; x++)\n    for (int y = 0; y < 3; y++)\n    {\n        vec2 off = (vec2(x,y)*.3333-.5)/iResolution.xy;\n        sum += texture(tex, uv + off).rgb * ker[x][y];\n    }\n    \n    return sum;\n}\n\nvec3 laplace(in sampler2D tex, in vec2 uv, in float strength)\n{\n    float k = -strength;\n    mat3 ker = mat3(\n        vec3(k, k, k),\n        vec3(k, 8.*strength+1., k),\n        vec3(k, k, k)\n    );\n    \n    return conv(tex, uv, ker);\n}\n\nvec3 emboss(in sampler2D tex, in vec2 uv, in float theta)\n{\n    // init kernel\n    mat3 ker = mat3(\n        vec3(0),\n        vec3(0),\n        vec3(0)\n    );\n    \n    // direction of edge detection\n    vec2 dir = vec2(sin(theta), cos(theta));\n    \n    // fill kernel with values\n    for (int x = -1; x < 2; x++)\n    for (int y = -1; y < 2; y++)\n        ker[x+1][y+1] = dot(dir, vec2(x,y));\n    \n    return conv(tex, uv, ker)+.5;\n}\n\nconst float Samples = 4.;\nconst float Strength = 0.02;\n\nvec3 chromatic_aberration(in sampler2D tex, in vec2 uv)\n{\n    vec3 col = vec3(0);\n    \n    uv -= .5;\n    \n    vec3 f = 1. - length(uv) * Strength*vec3(2.,1.,0.);\n    \n    for (float i = 0.; i < Samples; i++)\n    {\n        vec3 fs = mix(f, vec3(1), i/Samples);\n        col += vec3(\n            texture(tex, uv * fs.x+.5).r,\n            texture(tex, uv * fs.y+.5).g,\n            texture(tex, uv * fs.z+.5).b\n        );\n    }\n    return col / Samples;\n}\n\nvec3 vhs(in vec2 uv)\n{\n    // sharpen the image\n    // + filmic tonemap\n    vec3 col = laplace(iChannel0, uv, 1.3);\n    \n    // add chromatic aberration\n    vec3 abbr = chromatic_aberration(iChannel0, uv);\n    col = col + (abbr - texture(iChannel0, uv).rgb);\n    \n    // add grunge\n    col *= texture(iChannel1, uv).rgb * .8 + .2 + .4;\n    \n    // bleach out\n    col = col * .92 + rand(uv * 345.3567 + iTime)*.08;\n     \n    return uncharted2_filmic(col);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // VHS glitch\n    float i = sin(iTime / 5.);\n    i *= i * i;\n    i *= i * i;  // <<-- pow() function generated some weird NaN value\n    i *= i * i;  //            while testing on AMD GPU\n    i *= i * i;\n    i *= i * i;\n    uv.x += fract(uv.y * uv.y + iTime * 4.) * sign(sin(iTime + uv.y * rand(vec2(iTime)) * 8.)) * i * 5e-2;\n\n    // linear RGB\n    vec3 col = texture(iChannel0, uv).rgb * 2.;\n    \n    col = vhs(uv);\n    \n    // grainy stripe\n    col += rand(uv.yy+iTime) * .01;\n    col -= rand(uv.yy-iTime) * .01;\n\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}