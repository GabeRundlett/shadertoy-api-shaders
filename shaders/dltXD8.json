{
    "Shader": {
        "info": {
            "date": "1685362056",
            "description": "Controls: \nQ/E changes object type (grab, point, line, orbit points)\nZ undoes last action\nClick on screen/objects to place and grab them (orbit points can't be placed on orbit points)",
            "flags": 48,
            "hasliked": 0,
            "id": "dltXD8",
            "likes": 9,
            "name": "Interactive Objects",
            "published": 3,
            "tags": [
                "game",
                "interactive",
                "line",
                "point",
                "placement"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 241
        },
        "renderpass": [
            {
                "code": "// time\nfloat t;\n\n// Motivation:\n// I wanted to make an interactive kinematics placement program so you\n// could make something like this by hand:\n// https://www.shadertoy.com/view/cltXzN\n// More complicated objects require chains of references to other objects,\n// so I've given up on it for now\n\nvoid drawObj(inout vec3 col, vec2 uv, float i) {\n    vec4 obj = cell(ch0, vec2(i, 0));\n    vec2 p = (obj.xy - 0.5 * res) / res.y;\n    if (obj.w == 1.) { // Point (x, y, 0, 1)\n        float d = length(uv - p);\n        float s = ss(1., thick[1] - d);\n        col = mix(col, vec3(1), s);\n    } else if (obj.w == 2.) { // Line (start, end, 0, 2)\n        vec2 start = getPosition(obj.x);\n        vec2 end   = getPosition(obj.y);\n        start = (start.xy - 0.5 * res) / res.y;\n        end   = (end.xy   - 0.5 * res) / res.y;\n        vec2 dir = 1.5 * thick[1] * normalize(end - start);\n        float d = seg(uv, start + dir, end - dir);\n        float s = ss(1., thick[2] - d);\n        col = mix(col, vec3(1, 0, 0), s);\n    } else if (obj.w == 3.) { // Orbit point (start, angle, radius, 3)\n        vec2 start = cell(ch0, vec2(obj.x, 0) + 0.5).xy;\n        vec2 p = start + Dir(obj.y + t) * obj.z;\n        p = (p - 0.5 * res) / res.y;\n        float d = length(uv - p);\n        float s = ss(1., thick[1] - d);\n        col = mix(col, vec3(1, 1, 0), s);\n    } else if (obj.w == 4.) { // Orbit point (reverse) \n        vec2 start = cell(ch0, vec2(obj.x, 0) + 0.5).xy;\n        vec2 p = start + Dir(obj.y - t) * obj.z;\n        p = (p - 0.5 * res) / res.y;\n        float d = length(uv - p);\n        float s = ss(1., thick[1] - d);\n        col = mix(col, vec3(1, 0, 1), s);\n    }\n}\n\nvoid drawObjIndicator(inout vec3 col, vec2 uv, float objType) {\n    float r = 0.1;\n    uv -= (0.5 * res / res.y - r - 0.03) * vec2(-1, 1);\n    \n    float opacity = 0.9;\n    \n    // Draw box\n    float dBox = box(uv, vec2(r));\n    float sBox = ss(1., 0.01 - abs(0.01 - dBox));\n    col = mix(col, vec3(1), 0.5 * sBox);\n    \n    // Draw object indicator\n    if (objType == 0.) { // Grab\n        vec2 v = vec2(-1, 1) * 0.032;\n        float d1 = seg(uv, v.xx, v.yy);\n        float d2 = seg(uv, v.xy, v.yx);\n        float s = ss(1., 0.01 - min(d1, d2));\n        col = mix(col, vec3(0.8), opacity * s);\n    } else if (objType == 1.) { // Point\n        float d = length(uv);\n        float s = ss(1., 0.02 - d);\n        col = mix(col, vec3(1), opacity * s);\n    } else if (objType == 2.) { // Line\n        float d = seg(uv, vec2(-0.06), vec2(0.06));\n        float s = ss(1., 0.008 - d);\n        col = mix(col, vec3(1, 0, 0), opacity * s);\n    } else if (objType == 3.) { // Orbit point\n        vec2 p = 0.06 * Dir(3. * iTime);\n        float d = length(uv);\n        float dp = length(uv - p);\n        float s = ss(1., 0.005 - abs(0.04 - d));\n        float sp = ss(1., 0.01 - dp);\n        col = mix(col, vec3(1), opacity * s);\n        col = mix(col, vec3(1, 1, 0), opacity * sp);\n    } else if (objType == 4.) { // Orbit point (reverse)\n        vec2 p = 0.06 * Dir(-3. * iTime);\n        float d = length(uv);\n        float dp = length(uv - p);\n        float s = ss(1., 0.005 - abs(0.04 - d));\n        float sp = ss(1., 0.01 - dp);\n        col = mix(col, vec3(1), opacity * s);\n        col = mix(col, vec3(1, 0, 1), opacity * sp);\n    }\n}\n\nvoid drawCursor(inout vec3 col, vec2 uv, vec2 ms) {\n    float d = abs(0.015 - length(uv - ms));\n    float s  = ss(1., 0.009 - d);\n    float s2 = ss(1., 0.003 - d);\n    vec3 colCursor = mix(vec3(s), vec3(0), s2);\n    col = mix(col, colCursor, 0.5 * s);\n}\n\nvoid mainImage( out vec4 O, in vec2 px )\n{\n    vec2 uv = (px - 0.5 * res) / res.y;\n    vec2 ms = (iMouse.xy - 0.5 * res) / res.y;\n    \n    float lastIndex = cell(ch0, pxIndex).r;  \n    float objType = cell(ch0,pxObjType).x;\n    \n    t = spd * iTime;   \n    // Pause time when placing non-lines\n    if (iMouse.w <= 0. && iMouse.z > 0. && objType != 2.)\n        t = 0.;\n    \n    vec3 col = vec3(0);\n\n    // Draw line from mouse to closest object\n    float index = getClosestIndex(iMouse.xy, 100.);\n    vec2 q = getPosition(index);\n    q = (q - 0.5 * res) / res.y;\n    float d = seg(uv, ms, q);\n    float s = ss(1., 0.005 - d);\n    col = mix(col, vec3(1), 0.35 * s);\n    \n    // Draw objects\n    for (float i = 0.; i < lastIndex; i++) \n        drawObj(col, uv, i);\n       \n    // Highlight objects when mouse is close to them\n    /*\n    for (float i = 0.; i < lastIndex; i++) {\n        vec2 p = (obj.xy - 0.5 * res) / res.y;\n        float d = length(uv - p);\n        float dMs = length(ms - p);\n        if (dMs <= thick[1]) {\n            float s = ss(1., thick[1] - 0.008 - d);\n            col = mix(col, vec3(0), s);\n        }\n    } //*/\n    \n    drawObjIndicator(col, uv, objType);\n    drawCursor(col, uv, ms);\n\n    O = vec4(col, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define res iResolution.xy\n#define pi 3.14159\n#define dot2(a) dot(a,a)\n#define Dir(a) vec2(cos(a),sin(a))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define ss(a, b) smoothstep(-a/res.y, a/res.y, b)\n\n#define cell(ch, p) texelFetch(ch, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n\n// Speed time runs at (maybe remove)\n#define spd 1.\n\n// Empty, point, line thickness (change to array if using more objects)\n#define thick vec4(0, 0.02, 0.005, 0)\n\n#define pxIndex     vec2(0, res.y - 1.) + 0.5\n#define pxObjType   vec2(0, res.y - 2.) + 0.5\n#define pxGrab      vec2(0, res.y - 3.) + 0.5\n#define pxMouseDown vec2(0, res.y - 4.) + 0.5\n#define pxTempJoin  vec2(0, res.y - 5.) + 0.5\n\n#define KEY_A 65\n#define KEY_W 87\n#define KEY_D 68\n#define KEY_S 83\n#define KEY_Q 81\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_Z 90\n#define KEY_R 82\n\n// SDFs\nfloat box(in vec2 p, in vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat seg(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// Object code (using macros because Common tab hates everything)\n#define getPosition(index) getPosition0(ch0, index, spd * t)\nvec2 getPosition0(sampler2D ch, float index, float time) {\n    vec4 obj = cell(ch, vec2(index, 0));\n    if (obj.w == 1.) // Point\n        return obj.xy;\n    if (obj.w == 3.) { // Orbit point\n        vec2 start = cell(ch, vec2(obj.x, 0)).xy;\n        return start + Dir(obj.y + time) * obj.z;\n    }\n    if (obj.w == 4.) { // Orbit point (reverse)\n        vec2 start = cell(ch, vec2(obj.x, 0)).xy;\n        return start + Dir(obj.y - time) * obj.z;\n    }\n    return vec2(-1);\n}\n\n#define getClosestIndex(p, lastIndex) getClosestIndex0(ch0, res.x, t, p, lastIndex)\nfloat getClosestIndex0(sampler2D ch, float resx, float time, vec2 p, float lastIndex) {\n    float d = 4. * resx * resx;\n    float objIndex = -1.;\n    for (float i = 0.; i < lastIndex; i++) {\n        vec2 q = getPosition0(ch, i, time);\n        if (q == vec2(-1)) \n            continue;\n            \n        float d0 = dot2(p - q);\n        if (d0 < d) {\n            d = d0;\n            objIndex = i;\n        }\n    }\n    return objIndex;\n}\n\n// Hash\nfloat h11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// time\nfloat t;\n\nbool key_pressed(int key) {\n    return int(texelFetch(ch1, ivec2(key, 1), 0).x) == 1;\n}\n\n/*\nfloat getClosestLineIndex(vec2 ms, float lastIndex) {\n    float d = 4. * res.x * res.x;\n    float objIndex = -1.;\n    for (float i = 0.; i < lastIndex; i++) {\n        vec4 obj = cell(ch0, vec2(i, 0));\n        vec2 q = getPosition(i);\n        if (obj.w == 2.) {\n            vec2 start = getPosition(obj.x);\n            vec2 end = getPosition(obj.y);\n            //vec2 q = 0.5 * (start + end);\n            float d0 = seg(ms, start, end);\n            if (d0 < d) {\n                d = d0;\n                objIndex = i;\n            }          \n        }\n    }\n    return objIndex;\n}\n//*/\n\nvoid setGrabObject(inout vec4 O, vec2 px, vec2 ms, float index) {\n    if (px == pxGrab) {\n        float objIndex = getClosestIndex(ms, index);\n        vec2 objPos = getPosition(objIndex).xy;\n        if (objPos != vec2(-1)) {\n            vec2 objUv = (objPos - 0.5 * res) / res.y;\n            vec2 msUv = (ms - 0.5 * res) / res.y;\n            // if mouse is close to object, grab it\n            if (dot2(objUv - msUv) < 6. * thick[1] * thick[1])\n                O.x = objIndex;\n        }\n    }\n}\n// This code is very similar to objection creation code.\n// Could reuse it\nvoid moveGrabObject(inout vec4 O, vec2 px, vec2 ms, float grabIndex) {\n    if (px == vec2(grabIndex, 0) + 0.5) {\n      vec4 obj = cell(ch0, vec2(grabIndex, 0));\n      if (obj.w == 1.) // Point\n          O.xy = ms;\n      else if (obj.w == 3. || obj.w == 4.) { // Orbit points\n          vec4 startObj = cell(ch0, vec2(obj.x, 0));\n          vec2 dir = ms - startObj.xy;\n          float angle = atan(dir.y, dir.x);\n          float radius = length(dir);\n          O.yz = vec2(angle, radius);\n      }\n    }\n}\nvoid releaseGrabObject(inout vec4 O, vec2 px) {\n    if (px == pxGrab) \n        O.x = -1.;\n}\n\nvoid mainImage( out vec4 O, in vec2 px )\n{\n    vec2 ms = iMouse.xy;\n\n    float lastIndex    = cell(ch0, pxIndex).x;\n    float objType      = cell(ch0, pxObjType).x;\n    float grabIndex    = cell(ch0, pxGrab).x;\n    float wasMouseDown = cell(ch0, pxMouseDown).x;\n    \n    t = iTime;\n    if (iMouse.w <= 0. && iMouse.z > 0. && objType != 2.)\n        t = 0.;\n    \n    // Read buffer, and initialize buffer on 1st frame\n    O = (iFrame > 1) ? cell(ch0, ivec2(px)) : vec4(0);\n   \n    // Toggle object type\n    if (px == pxObjType) {\n        if (key_pressed(KEY_E)) \n            O.x = mod(O.x + 1., 5.);\n        else if (key_pressed(KEY_Q))\n            O.x = mod(O.x - 1., 5.);\n    }\n    \n    // Delete last object\n    if (key_pressed(KEY_Z)) {\n        if (px == pxIndex)\n            O.x = max(0., O.x - 1.);\n        else if (px == vec2(lastIndex, 0) + 0.5)\n            O = vec4(0);\n    }\n    \n    // Was mouse down last frame\n    if (px == pxMouseDown) \n        O.x = (iMouse.z > 0.) ? 1. : 0.;\n    \n    // Reset\n    // if (key_pressed(KEY_R)) \n    //     O = vec4(0);\n       \n   \n    // -- Mouse interaction and object placement --\n    \n    // Grab\n    if (objType == 0.) { \n        if (iMouse.w > 0.)           setGrabObject(O, px, ms, lastIndex);\n        else if (iMouse.z > 0.)      moveGrabObject(O, px, ms, grabIndex);\n        else if (wasMouseDown == 1.) releaseGrabObject(O, px);\n    } \n    // Point (x, y, 0, objType)\n    else if (objType == 1.) {\n        if (iMouse.w > 0.) {\n            if (px == pxIndex) \n                O.x = lastIndex + 1.;\n            else if (px == vec2(lastIndex, 0) + 0.5)\n                O = vec4(ms, 0, objType);    \n        } \n    } \n    // Line (startIndex, endIndex, 0, objType)\n    else if (objType == 2.) { \n        if (iMouse.w > 0.) {\n            float startIndex = getClosestIndex(ms, lastIndex);\n            if (startIndex != -1.) {\n                if (px == pxIndex) \n                    O.x = lastIndex + 1.;\n                else if (px == vec2(lastIndex, 0) + 0.5)\n                    O = vec4(startIndex, startIndex, 0, objType);\n            }\n        } else if (iMouse.z > 0.) {\n            float endIndex = getClosestIndex(ms, lastIndex);\n            if (endIndex != -1. && px == vec2(lastIndex - 1., 0) + 0.5)\n                 O.y = endIndex;\n        }     \n    } \n    // Orbit point (startIndex, 0, 0, objType)\n    else if (objType == 3. || objType == 4.) { \n        if (iMouse.w > 0.) {\n            float startIndex = getClosestIndex(ms, lastIndex);\n            if (startIndex != -1.) {\n                vec4 startObj = cell(ch0, vec2(startIndex, 0));\n                float angle = 0.;\n                float radius = length(ms - startObj.xy);\n                if (px == pxIndex) \n                    O.x = lastIndex + 1.;\n                else if (px == vec2(lastIndex, 0) + 0.5)\n                    O = vec4(startIndex, angle, radius, objType);\n            }\n        } else if (iMouse.z > 0.) {\n            vec4 orbitObj = cell(ch0, vec2(lastIndex - 1., 0));\n            vec4 startObj = cell(ch0, vec2(orbitObj.x, 0));\n            vec2 dir = ms - startObj.xy;\n            float angle = atan(dir.y, dir.x);\n            float radius = length(dir);\n            if (px == vec2(lastIndex - 1., 0) + 0.5)\n                O.yz = vec2(angle, radius);\n        }\n    } \n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}