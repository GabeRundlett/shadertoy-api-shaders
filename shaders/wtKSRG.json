{
    "Shader": {
        "info": {
            "date": "1583164183",
            "description": "An implementation of the projection method to generate a non-periodic tiling of the plane\nReference: ยง2.6.1 and ยง2.6.3 from Marjorie Senechal - Quasicrystals and Geometry (1996, Cambridge University Press).",
            "flags": 0,
            "hasliked": 0,
            "id": "wtKSRG",
            "likes": 15,
            "name": "Quasicrystal-v1",
            "published": 3,
            "tags": [
                "tiling",
                "tessellation",
                "penrose"
            ],
            "usePreview": 0,
            "username": "natpbs",
            "viewed": 787
        },
        "renderpass": [
            {
                "code": "// by natpbs\n// suggested usage: click the 'pause' button\n// and drag the mouse around on the canvas\n\n//#define DRAW_GRID\n#define FAST_VERSION\n#define DEBUG\n\nstruct vec5 {\n vec2 a;\n vec3 b;\n};\n\nstruct mat5 {\n mat2 a; mat2x3 b;\n mat3x2 c; mat3 d;\n};\n\nconst float tau = 2.*acos(-1.);\nconst float a = sqrt(2./5.);\nconst float b = 2.*acos(-1.)/5.;\nconst mat5 B = mat5(\n a * mat2(\n  1.,cos(b),\n  0.,sin(b)\n ),\n a * mat2x3(\n  cos(2.*b),cos(3.*b),cos(4.*b),\n  sin(2.*b),sin(3.*b),sin(4.*b)\n ),\n a * mat3x2(\n  1.,cos(2.*b),\n  0.,sin(2.*b),\n  sqrt(.5),sqrt(.5)\n ),\n a * mat3(\n  cos(4.*b),cos(b),cos(3.*b),\n  sin(4.*b),sin(b),sin(3.*b),\n  sqrt(.5),sqrt(.5),sqrt(.5)\n )\n);\n\nvec3 offset3;\nvec5 offset5;\n\nvec5 fiveFromTwo(vec2 p2) {\n vec5 p5 = vec5(\n  B.a * p2,\n  B.b * p2\n );\n return p5;\n}\n\nvec5 fiveFromThree(vec3 p3) {\n vec5 p5 = vec5(\n  B.c * p3,\n  B.d * p3\n );\n return p5;\n}\n\nvec2 twoFromFive(vec5 p5) {\n vec2 p2 = p5.a * B.a + p5.b * B.b;\n return p2;\n}\n\nvec3 threeFromFive(vec5 p5) {\n vec3 p3 = p5.a * B.c + p5.b * B.d;\n return p3;\n}\n\nvec5 snapToGrid(vec5 p) {\n // note that floor(x+.5)\n p.a = floor(.5 + p.a);\n p.b = floor(.5 + p.b);\n return p;\n}\n\nvec5 getNeighbor(vec5 p, int k) {\n float sig = (k&1) == 0 ? 1. : -1.;\n k >>= 1;\n if (k<2) {\n  p.a[k] += sig;\n } else {\n  p.b[k-2] += sig;\n }\n return p;\n}\n\nbool isInWindow(vec5 p5) {\n vec3 p = threeFromFive(p5);\n    p -= offset3;\n const vec3 base[5] = vec3[](\n  vec2(1,0) * B.c,\n  vec2(0,1) * B.c,\n  vec3(1,0,0) * B.d,\n  vec3(0,1,0) * B.d,\n  vec3(0,0,1) * B.d\n );\n\tfor (int i=0; i<4; i++) {\n\t\tfor (int j=i+1; j<5; j++) {\n\t\t\tvec3 n = normalize(cross(base[i],base[j]));\n\t\t\tfloat d = abs(dot(p,n));\n            float t = 0.;\n            for (int k=0; k<5; k++) {\n                if (k==i || k==j) {\n                    continue;\n                }\n                t += abs(dot(base[k],n));\n            }\n            if (d > .5*t) {\n                return false;\n            }\n\t\t}\n\t}\n return true;\n}\n\nfloat drawPoint(vec2 p, vec2 q) {\n float d = distance(p,q);\n d = smoothstep(-.1,0.,-d);\n return d;\n}\n\nfloat drawLine(vec2 p, vec2 a, vec2 b) {\n vec2 ap = p - a;\n vec2 ab = b - a;\n float t = dot(ap,ab) / dot(ab,ab);\n t = clamp(t,0.,1.);\n vec2 q = a + t * ab;\n float d = distance(p,q);\n d = smoothstep(-.03,0.,-d);\n return d;\n}\n\nfloat drawGrid(vec5 p, vec5 q) {\n vec2 a = abs(p.a - q.a);\n vec3 b = abs(p.b - q.b);\n float d = max(\n  max(a.x,a.y),\n  max(b.x,max(b.y,b.z))\n );\n d = smoothstep(.48,.5,d);\n return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n fragColor = vec4(vec3(0),1);\n vec2 p2 = (gl_FragCoord.xy - .5*iResolution.xy) / iResolution.x;\n p2 *= 16.;\n vec5 p5 = fiveFromTwo(p2);\n    if (iMouse.z > 0.) {\n        offset3 = vec3(\n            1. * (iMouse.xy - .5*iResolution.xy) / iResolution.x,\n            0\n        );\n        offset5 = fiveFromThree(offset3);\n        p5.a += offset5.a;\n        p5.b += offset5.b;\n    } else {\n        offset3 = vec3(0);\n        offset5 = vec5(vec2(0),vec3(0));\n    }\n vec5 q5 = snapToGrid(p5);\n vec2 q2 = twoFromFive(q5);\n vec3 q3 = threeFromFive(q5);\n float d = length(q3);\n fragColor.r += drawPoint(p2,q2);\n int count = 0;\n for (int j=0; j<10; j++) {\n  vec5 r5 = getNeighbor(q5,j);\n  if (isInWindow(r5)) {\n   count++;\n   vec2 r2 = twoFromFive(r5);\n   fragColor.r += drawPoint(p2,r2);\n   fragColor.b += drawLine(p2,q2,r2);\n   #ifndef FAST_VERSION\n   for (int k=0; k<10; k++) {\n       if ((k|1)==(j|1) && (k&1) != (j&1)) {\n           continue;\n       }\n    vec5 s5 = getNeighbor(r5,k);\n    if (isInWindow(s5)) {\n     vec2 s2 = twoFromFive(s5);\n     fragColor.r += drawPoint(p2,s2);\n     fragColor.b += drawLine(p2,r2,s2);\n    }\n   }\n   #endif\n  }\n }\n    #ifdef DRAW_GRID\n\t\tfragColor.rgb += .4*drawGrid(p5,q5);\n    #endif\n    #ifdef DEBUG\n if (!isInWindow(q5)) {\n  fragColor.rb = vec2(1.);\n }\n count = 0\n  | ((count & 1) << 4)\n  | ((count & 2) << 1)\n  | ((count & 4) >> 1)\n  | ((count & 8) >> 5);\n fragColor.rgb += float(count) / 64.;\n    #endif\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}