{
    "Shader": {
        "info": {
            "date": "1505644828",
            "description": "iMouse.y lowers max iterations; 0..450\niMouse.x lowers stepLengthFactor for each step; 0..1\nlower right=high precision,low performance\n\nfork of\nhttps://www.shadertoy.com/view/4llyz2\n\nextends the ray-march loop with a log_dynamiceps() break condition.",
            "flags": 0,
            "hasliked": 0,
            "id": "4lfyRX",
            "likes": 15,
            "name": "kali flower 2 dynamic",
            "published": 3,
            "tags": [
                "3d",
                "kali",
                "dynamiceps",
                "logeps"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1068
        },
        "renderpass": [
            {
                "code": "//L 3d kali d 2\n//parent: https://www.shadertoy.com/view/4llyz2\n// Created by SHAU - 2017 , License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//self  : https://www.shadertoy.com/new\n//adds dynamicEps to parent:\n// where the break-condition of the marching loop is log(squared_function);\n//  t   ==accumulated distance to camera.\n//  ns.x==current distance field return value == distance to \"surface\", gradient descent\n//  if (t>FAR|| log(t*t*EPS/ns.x)>0.) break;\n\n//You go down a special type of non euclidean geometry rabbit hole\n// when you make Epsilon non consant over distance.\n//\n//[Alice in Wonderland] was the resolve \n// of someone tryigng and failing to understand non-euclidean geoometry and topology\n// ,where distance and scale suddenly matter less than curvature.\n// The resolution was to break up with topology to became a famous writer instead.\n//[DynamicEps] extends on this.\n\n#define DynamicEps\n\n\n//setting EPS 1e-5 gets you some almost free surface scattering, due to fractal geometry.\n#define EPS 1e-4\n//set eps=0.01 to see some strance scattering, and som,e \"thicker material_ID outlines\"\n\n#define FAR 20.0 \n#define PI 3.1415\n#define T iTime\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\nfloat rand(vec2 co) {return fract(sin(dot(co.xy ,vec2(12.9898, 78.233))) * 43758.5453);}\n\nvec3 lc = vec3(0.0);\n\n// IQ - cosine based palette\n//https://iquilezles.org/articles/palettes\nvec3 palette(in float t) {\n    vec3 CP1A = vec3(0.5, 0.5, 0.5);\n    vec3 CP1B = vec3(0.5, 0.5, 0.5);\n    vec3 CP1C = vec3(2.0, 1.0, 0.0);\n    vec3 CP1D = vec3(0.50, 0.20, 0.25);\n    return CP1A + CP1B * cos(6.28318 * (CP1C * t + CP1D));\n}\n\nfloat sdBox(vec3 p, vec3 bc, vec3 b) {    \n    vec3 d = abs(bc - p) - b; \n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));;\n}\n\n/*\nfloat map(vec3 rp) {\n    \n    float msd = FAR;\n    for (int i = 0; i < 16; i++) {    \n       rp = abs(rp) / dot(rp, rp) - .25;  \n       msd = min(msd, sdBox(rp, 1.0 - rp, vec3(1.0)));\n    }\n    \n    return msd;\n}\n*/\n\nvec2 near(vec2 new, vec2 old) {\n    if (new.x < old.x) return new;\n    return old;\n}\n\nvec2 map(vec3 rp) {\n    \n    vec2 msd = vec2(FAR, 0);\n    for (int i = 0; i < 10; i++) {  \n        //this is so sensitive\n       float c = 0.3;// + sin(T * 0.2) * 0.1; //clamp(0.3 + sin(T * 0.4) * 0.06, 0.24, 0.32); //0.1 - 0.3\n       float q = 1.0 + sin(T) * 0.1;  //1.6 + sin((T - PI)  * 0.1) * 0.4; // 3.6 - 1.0\n       rp = abs(rp) / dot(rp, rp) - c;\n       rp.xy *= rot(float(i));\n       msd = near(msd, vec2(sdBox(rp, q - rp, vec3(1.0)), i)); \n    }\n    \n    return msd;\n}\n\n//from shane\nvec3 normal(vec3 rp, out float edge) {\n    \n    vec2 e = vec2(EPS, 0.0);\n\tfloat d1 = map(rp + e.xyy).x;\n    float d2 = map(rp - e.xyy).x;\n\tfloat d3 = map(rp + e.yxy).x;\n    float d4 = map(rp - e.yxy).x;\n\tfloat d5 = map(rp + e.yyx).x;\n    float d6 = map(rp - e.yyx).x;\n\tfloat d = map(rp).x * 2.0;\n\n    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface \n    // curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    \n    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n    \n    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you \n    // do that is up to you. This is what I came up with for now, but I might tweak it later.\n    edge = smoothstep(0.0, 1.0, sqrt(edge / e.x * 2.0));\n    \n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n//spheretrack Logeps VolumeGlow\nvec3 marchScene(vec3 ro, vec3 rd\n){vec2 m=1.-iMouse.xy/iResolution.xy;//m could be identical to ScreenSpace.xy\n //[l] lazily coutneracts overstepping for higher precision in its gradient descent.\n //     by intentional understepping, assuming lipschits constant >1,\n float l=m.x;//set by iMouse.x\n //dynamic number of iterations lacks backwards compatibility.\n float iterMax=450.*m.y;//set by Mouse.y\n //float EPS=0.001; ish.\n //loop accumulators:\n float t=.0,     // t=distanceToCamera (without epsilon)\n       g=.0;     // VolumeMarched smoothstep glow: +=lerp((exp(-SquaredDistanceToGlowCenter)))\n vec2  r=vec2(0);// .x=distanceToSurface .y=MaterialID\n for (float i = 0.; i < iterMax; i++){\n     vec3 p=ro + rd * t;//pointOnRay\n     vec2 r = map(p);   //shortest euclideanPointDistance to distanceField of pointOnRay.\n #ifdef DynamicEps\n     if (t>FAR|| log(t*t*EPS/r.x)>0.) break;//zFar || logEps        exits\n     //above is very basic logeps, IFF (scene is scaled properly) it relpaces the line below.\n #else\n     if (t>FAR||         EPS>r.x    ) break;//zFar || zNearSurface  exits\n #endif\n     g += smoothstep(0.,1.,1.2*exp(-dot(p,p)));//increment glow\n     t += r.x*l ;}//march along ray\n return vec3(t,g,r.y);}//vec3(distanceToCamera,GlowIntensity,MaterialID)\n\n/**/\nvoid setupCamera(out vec3 ro, out vec3 rd, vec2 uv) {\n    vec3 lookAt = vec3(0);\n    vec3 camera = vec3(0.0, 0.5, -3.6);\n    camera.xz *= rot(1.0);\n    camera.xy *= rot(T * 0.5);\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI / 3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt.xyz - camera.xyz);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);    \n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n    ro = camera;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec3 pc = vec3(0.0); //pixel colour\n    vec3 lp = vec3(4.0, 5.0, -2.0);\n    lc = palette(T * 0.05);\n    float pulse = (sin(T * 16.0) + 1.0) * 0.5;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n \n    vec3 ro, rd;\n    setupCamera(ro, rd, uv);\t\n\n    vec3 t = marchScene(ro, rd);\n    \n    if (t.x > 0.0 && t.x < FAR) {\n        vec3 rp = ro + rd * t.x;\n        float edge = 0.0;\n        vec3 n = normal(rp, edge);\n        vec3 ld = normalize(lp - rp);\n        float diff = clamp(dot(n, ld), 0.0, 1.0);\n        float fres = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 64.0);;\n        vec3 refl = reflect(n, rd);    \n        float spec = pow(clamp(dot(refl, rd), 0.0, 1.0), 16.0);\n        \n        float rt = length(rp);   \n        \n        pc += edge * palette(t.z * 0.1 + T * 0.1) * 2.0 * exp(rt * -rt * 0.8);;\n        pc += spec * lc * exp(rt * -rt) * clamp(pulse, 0.1, 1.0);    \n        \n        pc += vec3(1.0) * diff / (rt * rt * rt);\n        pc += lc * exp(rt * -rt * 0.6) * diff * clamp(pulse, 0.1, 1.0);\n        pc += lc * t.y * clamp(pulse, 0.1, 1.0);\n        \n        pc += vec3(0.8, 0.0, 0.3) * max(n.y, 0.0) * 0.02;\n    }\n\n    float gfog = 1.0 - exp(-t.x * t.x * 0.1 / FAR);\n    pc = mix(pc, vec3(0.0), gfog);\n    \n\tfragColor = vec4(sqrt(clamp(pc, 0., 1.)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}