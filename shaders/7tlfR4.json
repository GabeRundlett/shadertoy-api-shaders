{
    "Shader": {
        "info": {
            "date": "1650593532",
            "description": "Newton's fractal is generated using Newton-Raphson iteration",
            "flags": 0,
            "hasliked": 0,
            "id": "7tlfR4",
            "likes": 2,
            "name": "Custom Newton's fractal",
            "published": 3,
            "tags": [
                "fractal",
                "iteration"
            ],
            "usePreview": 0,
            "username": "Fraktoler",
            "viewed": 241
        },
        "renderpass": [
            {
                "code": "precision highp float;\n\n#define PI 3.1415926535897932384626433832795028841\n\nvec3 HSLtoRGB(vec3 hsl) {\n    //0 <= h <= 360\n    //0 <= s <= 1\n    //0 <= l <= 1\n    float chroma = hsl.y * (1.0 - abs(2.0 * hsl.z - 1.0));\n    float h_prime = hsl.x / 60.0;\n    float x = chroma * (1.0 - abs(mod(h_prime, 2.0) - 1.0));\n    vec3 rgb;\n    if (0.0 <= h_prime && h_prime < 1.0) {\n        rgb = vec3(chroma, x, 0.0);\n    } else if (1.0 <= h_prime && h_prime < 2.0) {\n        rgb = vec3(x, chroma, 0.0);\n    } else if (2.0 <= h_prime && h_prime < 3.0) {\n        rgb = vec3(0.0, chroma, x);\n    } else if (3.0 <= h_prime && h_prime < 4.0) {\n        rgb = vec3(0.0, x, chroma);\n    } else if (4.0 <= h_prime && h_prime < 5.0) {\n        rgb = vec3(x, 0.0, chroma);\n    } else {\n        rgb = vec3(chroma, 0.0, x);\n    }\n    float m = hsl.z - 0.5 * chroma;\n    return rgb + m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float zoom = 3.0;\n    vec2 center = vec2(0.0);\n    vec2 z = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.x * zoom + center;\n    float exponent = 2.0 + iTime * 0.2;\n    float iter = 0.0;\n    const float max_iter = 256.0;\n    while (iter < max_iter) {\n        vec2 oldz = z;\n        vec2 f = power(z, exponent) - vec2(1.0, 0.0); //Function f(z)\n        vec2 df = exponent * power(z, exponent - 1.0); //f'(z)\n        z = z - div(f, df);\n\n        float r = mag2(z - oldz);\n        if (r < 1.0e-6) {\n            break;\n        }\n        iter += 1.0;\n    }\n\n    if (iter >= max_iter) {\n        fragColor = vec4(vec3(0.0), 1.0);\n    } else {\n        float h = arg(z) / PI;\n        if (h < 0.0) {\n            h = h + 2.0;\n        }\n        vec3 col = HSLtoRGB(vec3(h * 180.0, 1.0, 0.5));\n        fragColor = vec4(col, 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float mag(vec2 z) {\n    return length(z);\n}\n\nfloat mag2(vec2 z) {\n    return dot(z, z);\n}\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 conj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\nvec2 flip(vec2 z) {\n    return vec2(-z.x, z.y);\n}\n\nvec2 swap(vec2 z) {\n    return vec2(z.y, z.x);\n}\n\nvec2 rabs(vec2 z) {\n    return vec2(abs(z.x), z.y);\n}\n\nvec2 iabs(vec2 z) {\n    return vec2(z.x, abs(z.y));\n}\n\nvec2 cis(float t) {\n    return vec2(cos(t), sin(t));\n}\n\nvec2 mul(vec2 z, vec2 w) {\n    return z.x * w + z.y * vec2(-w.y, w.x);\n}\n\nvec2 mulI(vec2 z) {\n    return vec2(-z.y, z.x);\n}\n\nvec2 div(vec2 z, vec2 w) {\n    return (w.x * z + w.y * vec2(z.y, -z.x)) / mag2(w);\n}\n\nvec2 rec(vec2 z) {\n    return conj(z) / mag2(z);\n}\n\nvec2 squ(vec2 z) {\n    return vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y);\n}\n\nvec2 cube(vec2 z) {\n    return z * vec2(z.x * z.x - 3.0 * z.y * z.y, 3.0 * z.x * z.x - z.y * z.y);\n}\n\nvec2 power(vec2 z, float p) {\n    return pow(mag2(z), p * 0.5) * cis(p * arg(z));\n}\n\nvec2 powervec2(vec2 z, vec2 w) {\n    float r = mag2(z);\n    float argz = arg(z);\n    float argzw = w.x * argz + 0.5 * w.y * log(r);\n    return pow(r, w.x * 0.5) * exp(-w.y * argz) * cis(argzw);\n}\n\nvec2 sqrtp(vec2 z) {\n    float r = mag(z);\n    return vec2(1.0, sign(z.y)) * sqrt(0.5 * vec2(r + z.x, r - z.x));\n}\n\nvec2 powexp(vec2 z) {\n    return exp(z.x) * cis(z.y);\n}\n\nvec2 ln(vec2 z) {\n    return vec2(log(mag2(z)) * 0.5, arg(z));\n}\n\nvec2 logb(vec2 z, vec2 b) {\n    return div(ln(z), ln(b));\n}\n\nvec2 sine(vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 cosine(vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\nvec2 sub_tan(vec2 z) {\n    vec2 squ_exp = powexp(mulI(z + z));\n    return div(squ_exp - vec2(1.0, 0.0), mulI(squ_exp + vec2(1.0, 0.0)));\n}\n\nvec2 tangent(vec2 z) {\n    if (z.y < -21.0) {\n        return conj(sub_tan(conj(z)));\n    } else {\n        return sub_tan(z);\n    }\n}\n\nvec2 sub_cot(vec2 z) {\n    vec2 squ_exp = powexp(mulI(z + z));\n    return div(mulI(squ_exp + vec2(1.0, 0.0)), squ_exp - vec2(1.0, 0.0));\n}\n\nvec2 cot(vec2 z) {\n    if (z.y < -21.0) {\n        return conj(sub_cot(conj(z)));\n    } else {\n        return sub_cot(z);\n    }\n}\n\nvec2 sec(vec2 z) {\n    return rec(cosine(z));\n}\n\nvec2 csc(vec2 z) {\n    return rec(sine(z));\n}\n\nvec2 arcsin(vec2 z) {\n    return mulI(ln(sqrtp(vec2(1.0, 0) - squ(z)) - mulI(z)));\n}\n\nvec2 arccos(vec2 z) {\n    return -mulI(ln(mulI(sqrtp(vec2(1.0, 0) - squ(z))) + z));\n}\n\nvec2 arctan(vec2 z) {\n    return -0.5 * mulI(ln(div(vec2(0.0, 1.0) - z, vec2(0.0, 1.0) + z)));\n}\n\nvec2 arccot(vec2 z) {\n    return -0.5 * mulI(ln(div(z + vec2(0.0, 1.0), z - vec2(0.0, 1.0))));\n}\n\nvec2 arcsec(vec2 z) {\n    return arccos(rec(z));\n}\n\nvec2 arccsc(vec2 z) {\n    return arcsin(rec(z));\n}\n\nvec2 sinhyp(vec2 z) {\n    return vec2(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y));\n}\n\nvec2 coshyp(vec2 z) {\n    return vec2(cosh(z.x) * cos(z.y), sinh(z.x) * sin(z.y));\n}\n\nvec2 sub_tanh(vec2 z) {\n    vec2 squ_exp = powexp(z + z);\n    return div(squ_exp - vec2(1.0, 0.0), squ_exp + vec2(1.0, 0.0));\n}\n\nvec2 tanhyp(vec2 z) {\n    if (z.x > 21.0) {\n        return flip(sub_tanh(flip(z)));\n    } else {\n        return sub_tanh(z);\n    }\n}\n\nvec2 sub_coth(vec2 z) {\n    vec2 squ_exp = powexp(z + z);\n    return div(squ_exp + vec2(1.0, 0.0), squ_exp - vec2(1.0, 0.0));\n}\n\nvec2 coth(vec2 z) {\n    if (z.x > 21.0) {\n        return flip(sub_coth(flip(z)));\n    } else {\n        return sub_coth(z);\n    }\n}\n\nvec2 sech(vec2 z) {\n    return rec(coshyp(z));\n}\n\nvec2 csch(vec2 z) {\n    return rec(sinhyp(z));\n}\n\nvec2 arcsinh(vec2 z) {\n    return ln(z + sqrtp(squ(z) + vec2(1.0, 0.0)));\n}\n\nvec2 arccosh(vec2 z) {\n    return ln(z + mul(sqrtp(z + vec2(1.0, 0.0)), sqrtp(z - vec2(1.0, 0.0))));\n}\n\nvec2 arctanh(vec2 z) {\n    return 0.5 * ln(div(vec2(1.0, 0.0) + z, vec2(1.0, 0.0) - z));\n}\n\nvec2 acoth(vec2 z) {\n    return 0.5 * ln(div(z + vec2(1.0, 0.0), z - vec2(1.0, 0.0)));\n}\n\nvec2 asech(vec2 z) {\n    return arccosh(rec(z));\n}\n\nvec2 acsch(vec2 z) {\n    return arcsinh(rec(z));\n}\n\nvec2 linear(vec2 z, vec2 a, vec2 b) {\n    return mul(z, a) + b;\n}\n\nvec2 quadratic(vec2 z, vec2 a, vec2 b, vec2 c) {\n    return mul(squ(z), a) + mul(z, b) + c;\n}\n\nvec2 cubic(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d) {\n    return mul(cube(z), a) + mul(squ(z), b) + mul(z, c) + d;\n}\n\nvec2 linearroot(vec2 z, vec2 a, vec2 b) {\n    return div(-b, a);\n}\n\nvec4 quadraticroots(vec2 a, vec2 b, vec2 c) {\n    vec2 sqrtdelta = sqrtp(squ(b) - 4.0 * mul(a, c));\n    vec2 twoa = a + a;\n    return vec4(div(sqrtdelta - b, twoa), -div(b + sqrtdelta, twoa));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}