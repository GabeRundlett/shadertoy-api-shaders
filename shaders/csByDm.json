{
    "Shader": {
        "info": {
            "date": "1687753809",
            "description": "👽🏳‍🌈",
            "flags": 0,
            "hasliked": 0,
            "id": "csByDm",
            "likes": 9,
            "name": "Rainbow Planet",
            "published": 3,
            "tags": [
                "alien",
                "rainbow",
                "mirror",
                "pride"
            ],
            "usePreview": 1,
            "username": "ufffd",
            "viewed": 343
        },
        "renderpass": [
            {
                "code": "// used for video render or beastly gpu\n// #define HI_QUALITY\n// uncomment this if your pc is strugglin\n//#define LO_QUALITY\n// common vals\n#define PI 3.1415927\n#define EPSILON 0.0001\n// implement quality options\n#ifdef HI_QUALITY\n    #define STEP_MAX 600.\n    #define DIST_MAX 35.\n    #define STEP_FAC 0.4\n#elif defined(LO_QUALITY)\n    #define STEP_MAX 100.\n    #define DIST_MAX 20.\n    #define STEP_FAC 1.\n#else\n    #define STEP_MAX 160.\n    #define DIST_MAX 35.\n    #define STEP_FAC 0.7\n#endif\n// RAY_MAX > 1 is pretty busted currently\n#define RAY_MAX 1.\n#define SPECULAR_POWER 100.\n#define SPECULAR_INTENSITY .5\n\n// 🌈\n#define PRIDE\n\n// define textures\n// note: most of these are unused\nstruct Tex {\n    vec3  c; // color\n    float m; // mirror\n    float r; // rough\n};\n// tex setup. takes object and global position as inputs\nTex T1(in vec3 p, in vec3 gp) {\n    // green, nonreflective\n    Tex T;\n    T.c = vec3(0.,1.,0.);\n    T.m = 0.;\n    return T;\n}\nTex T2(in vec3 p, in vec3 gp) {\n    // black and white stripes\n    // the black part is reflective\n    Tex T;\n    float tt = iTime * 0.1;\n    float stripes = sin(40.*(p.x + sin(p.z*-.5)));\n    stripes = SS(0.,0.01,stripes);\n    T.c = vec3(stripes);\n    T.m = 1.-stripes;\n    return T;\n}\nTex T3(in vec3 p, in vec3 gp) {\n    // show position\n    Tex T;\n    T.c = normalize(p);\n    T.m = 0.;\n    return T;\n}\nTex T4(in vec3 p, in vec3 gp) {\n    // black mirror\n    Tex T;\n    T.c = vec3(.001);\n    T.m = .8;\n    return T;\n}\nTex T5(in vec3 p, in vec3 gp) {\n    // white mattte\n    Tex T;\n    T.c = vec3(1.);\n    T.m = .0;\n    return T;\n}\nTex T6(in vec3 p, in vec3 gp) {\n    // voronoi\n    Tex T;\n    T.c = voronoi(gp*.5 - iTime).rrr * voronoi(gp*3. - iTime) * voronoi(gp*8. - iTime);\n    T.c = mix(T.c, vec3(0.,1.8,1.),gp.y/3.);\n    T.c = clamp(vec3(0.),vec3(1.),T.c);\n    T.c = hueShift(T.c, T.c.g*8.);\n    T.c.g -= 0.5;\n    T.c = hueShift(T.c, noise(gp*2. + iTime*0.1)*3.);\n    T.m = 0.;\n    return T;\n}\nTex T7(in vec3 p, in vec3 gp) {\n    // horiz stripes\n    Tex T;\n    T.c = vec3(smoothstep(0.,0.01,sin(p.y*40.)));\n    T.m = 0.;\n    return T;\n}\nvec3 rainbowSmooth(float x, float k){\n    // return vec3(1.);\n    vec3 r1 = vec3(1.,0.,0.)*1.;\n    vec3 r2 = vec3(1.,.5,0.)*1.;\n    vec3 r3 = vec3(1.,1.,0.)*1.;\n    vec3 r4 = vec3(0.,.5,0.)*1.;\n    vec3 r5 = vec3(0.,0.,1.)*1.;\n    vec3 r6 = vec3(.5,0.,.5)*1.;\n    x = fract(x+0.5/6.);\n\t\n\tfloat level = x * 6.0;\n    // float mixamt = fract(level); // full linear mix\n    float mixamt = smoothstep(0.5-k,0.5+k,fract(level)); // smoothstep\n    vec3 col = vec3(0.);\n    if (level<1.) col = mix(r1,r2,mixamt);\n    else if (level<2.) col = mix(r2,r3,mixamt);\n    else if (level<3.) col = mix(r3,r4,mixamt);\n    else if (level<4.) col = mix(r4,r5,mixamt);\n    else if (level<5.) col = mix(r5,r6,mixamt);\n    else if (level<6.) col = mix(r6,r1,mixamt);\n    return col;\n}\nTex T8(in vec3 p, in vec3 gp) {\n    // rainbow stripes with mirrors\n    Tex T;\n    float tt = iTime * 0.1;\n    float stripes = sin(40.*(p.x + sin(p.z*-.5)));\n    vec3 rb = rainbowSmooth(0.2+1.06*(p.x+sin(p.z*-.5)), 0.2);\n    stripes = SS(0.,0.1,stripes);\n    stripes = stripes*0.8 + 0.2; // glowy rainbow on the mirrors - disable for cleaner color palette (ie for printing)\n    rb *= stripes;\n    \n    T.c = rb;\n    T.m = 1.-stripes;\n    return T;\n}\nTex T9(in vec3 p, in vec3 gp) {\n    // horiz rainbow stripes\n    Tex T;\n    T.c = rainbowSmooth(-p.y*3.,0.025);\n    T.m = 0.;\n    return T;\n}\n// structs for abstracting march process\nstruct MapData {\n    vec4  c; // color\n    float d; // distance\n    float m; // mirror\n    bool  h; // hit\n};\nstruct MarchData {\n    vec4  c; // color\n    vec3  p; // intersection point\n    float d; // distance\n    float s; // steps\n    bool  h; // hit\n    // bounces\n    // attenuation\n    // steps in this bounce\n};\nvoid drawTex(in vec3 p, in vec3 gp, inout MapData m, int tx) {\n    Tex T;\n    if (tx==1) T = T1(p,gp);\n    if (tx==2) T = T2(p,gp);\n    if (tx==3) T = T3(p,gp);\n    if (tx==4) T = T4(p,gp);\n    if (tx==5) T = T5(p,gp);\n    if (tx==6) T = T6(p,gp);\n    if (tx==7) T = T7(p,gp);\n    if (tx==8) T = T8(p,gp);\n    if (tx==9) T = T9(p,gp);\n    float color_mix = 1.; // this should be set based on material & incidence angle\n    m.c = vec4(T.c,color_mix);\n    m.m = T.m;\n}\n// 3d scene\nvoid addObject(in float sdf, in int tx, in vec3 p, in vec3 gp, inout MapData m) {\n    m.h = m.h || sdf < EPSILON; // register hit\n    if (sdf < m.d) { // this is the closest object so far\n        m.d = sdf;\n        if (m.h) drawTex(p,gp,m,tx);\n    }\n}\nMapData map(in vec3 p) {\n    // returns distance to nearest surface from a given point in 3d space\n    MapData m;\n    m.d = 9999.; // start high, use min(d,x) to add geometry to scene\n    m.m = 0.; // no reflective surfaces yet\n    m.h = false; // no surfaces at all yet really\n    m.c = vec4(0.); // sure is dark in here...\n    \n    // base gyroid\n    float gy1 = sdGyroid(p, pow(p.y,.125) - p.y*.2 - 2.);\n    int gyroid_mat = 7; // 6\n    #ifdef PRIDE\n        gyroid_mat = 9;\n    #endif\n    // if (cell_rand > 0.5) gyroid_mat = 5;\n    addObject(gy1, gyroid_mat, sin(p*0.5), p, m);\n    \n    \n    // ground/floor plane\n    float ground = p.y;\n    \n    vec3 gy1_1p = p;\n    // gy1_1p.y = floor(gy1_1p.y*10.)/10.;\n    float gy1_1 = sdGyroid(gy1_1p, -1.4 * p.y);\n    // ground = smin(ground, gy1_1, 0.2);\n    ground = fOpUnionStairs(ground, gy1+p.y-.5, .5, 10.);\n    // addObject(gy1_1, gy1_1mat, p, p, m);\n    int ground_mat = 2;\n    #ifdef PRIDE\n        ground_mat = 8;\n    #endif\n    addObject(ground, ground_mat, p, p, m);\n    // orbs\n    // float orbs = sdOrb(p, 1.4);\n    // int orbs_mat = 3;\n    // if (cell_rand > 0.5) gyroid_mat = 5;\n    // addObject(orbs, orbs_mat, p, p, m);\n    \n    vec3 orbonoi = voronoi(p/2.);\n    float orbs = orbonoi.x - .3*pow(hash11(orbonoi.z),3.);\n    int orbs_mat = 2;\n    #ifdef PRIDE\n        orbs_mat = 8;\n    #endif\n    addObject(orbs, orbs_mat, p, p, m);\n        \n    return m;\n}\nvec3 getNorm(vec3 p, float spread) { \n    float d = map(p).d; // Distance\n    vec2 e = vec2(.02*spread,0); // Epsilon\n    vec3 n = d - vec3(\n        map(p-e.xyy).d,  \n        map(p-e.yxy).d,\n        map(p-e.yyx).d);   \n    return normalize(n);\n}\nvec3 getNorm(vec3 p) {\n    return getNorm(p, 0.005); // default spread\n}\n\n\n// raymarch\nMarchData raymarch(in vec3 ro, in vec3 rd) {\n    MarchData d;\n    d.h = false;\n    d.d = 0.;\n    d.c = vec4(0.);\n    float atten = 1.;\n    int bounces = 0;\n    for (d.s=0.;d.s<STEP_MAX&&d.d<DIST_MAX;d.s++) {\n        vec3 p = ro + rd*d.d;\n        MapData m = map(p);\n        if (m.h) { // hit\n            d.h = true; // record hit\n            d.p = p; // hit location\n            d.c.rgb += m.c.rgb*m.c.a*atten; // l.o.l adds hit color to return color\n            if (m.m<0.01) break; // if not a mirror, we're done\n            // else, we hit a mirror. reflect and keep steppin\n            bounces++;\n            if (bounces>2) break;\n            atten *= m.m; // - step(.5,p.y);\n            vec3 n = getNorm(p);\n            rd = reflect(rd, n);\n            d.d = 0.;\n            // d.c = vec4(n,1.); break; // debug\n            ro = p + rd*EPSILON; // step away from surface\n        } else\n            d.d += m.d*STEP_FAC; // * .5; // halfstep riddim\n    }\n    return d;\n}\nfloat nnoise2(in vec3 x) { // -1 to 1\n    float nn = noise(x)*2.-1.;\n    return nn*nn; // curved\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // setup\n    vec2 R = iResolution.xy;\n    vec2 uvc = (fragCoord-R/2.)/R.y;\n    vec3 col = vec3(0.);\n    float t = iTime;\n    // t = 44.06;\n    float carloop = mod(t*2.-2.2,101.);\n    vec3 carpos = vec3(sin(t*0.3)+2.,.5,t*0.5);\n    carpos.y -= smoothstep(32.,40.,carloop) - smoothstep(70.,80.,carloop);\n    vec3 sideview = vec3(iMouse.xy/R,-1.);\n    // vec3 ro = iMouse.z>0.?sideview:carpos;\n    vec3 ro = carpos;\n    float fov = 0.6;\n    vec3 rd = normalize(vec3(uvc,fov));\n    \n    if (iMouse.z>0.) {\n        vec2 muv = (iMouse.xy - R/2.) / R.y;\n        rd.yz = rotate(rd.yz,muv.y);\n        rd.xz = rotate(rd.xz,muv.x);\n    } else {\n        // rd.yz = rotate(rd.yz,-0.5);\n        float lookdown = smoothstep(29.,33.,carloop) - smoothstep(36.,41.,carloop);\n        lookdown += smoothstep(70.,73.,carloop) - smoothstep(71.,81.,carloop);\n        rd.yz = rotate(rd.yz,-lookdown);\n        float twist = smoothstep(35.,45.,carloop) + smoothstep(75.,85.,carloop);\n        rd.xy = rotate(rd.xy, twist*PI);\n        \n        rd.yz = rotate(rd.yz,nnoise2(vec3(t*0.1+20.)));\n        rd.xz = rotate(rd.xz,nnoise2(vec3(t*0.1+80.)));\n        // cam jitter - i'm preferring smooth look\n        // rd.yz = rotate(rd.yz,nnoise(vec3(iTime*2.))*0.01);\n        // rd.xz = rotate(rd.xz,nnoise(vec3(iTime*2.1+100.))*0.01);\n        if (ro.y<0.) {\n            rd.y *= -1.;\n            ro.y *= -1.;\n        }\n    }\n    \n    // raymarch\n    for (float M=0.;M<RAY_MAX;M++) { // multiple rays per pixel\n        ro += hash31(M)/100000000.; // randomize\n        MarchData d = raymarch(ro,rd);\n        vec3 raycol = d.c.rgb;\n        // col = vec3(1./d.d, d.s/STEP_MAX, float(d.h)); // debug march data\n        // col = vec3(d.d);\n        // lighting - should all of this happen within raymarch for each intersection? probably\n        vec3 n = d.h?getNorm(d.p):vec3(0,0,1);\n        n += hash33(d.p*100.)*.005; // scatter - ought to be based on material roughness\n        vec3 bounceAngle = reflect(rd,n); \n\n        float amb = d.h?0.001:0.; // add ambient light for all hit pixels\n\n        vec3 light1pos = vec3(d.p+1.);\n        vec3 light1dir = normalize(light1pos-d.p);\n        vec3 light2pos = vec3(d.p-vec3(.5,.9,1.));\n        vec3 light2dir = normalize(light2pos-d.p);\n        \n        float diff1 = max(0.0, dot(n, light1dir)) * 1.;\n        float spec1 = pow(max(0.0, dot(bounceAngle, light1dir)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n        // float fade = pow (1.0 - d / RAY_LENGTH_MAX, FADE_POWER);\n        float light1result = diff1 + spec1;\n        \n        float diff2 = max(0.0, dot(n, light2dir)) * 1.;\n        float spec2 = pow(max(0.0, dot(bounceAngle, light1dir)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n        // float fade = pow (1.0 - d / RAY_LENGTH_MAX, FADE_POWER);\n        float light2result = diff2 + spec2;\n\n        raycol *= vec3(amb + light1result + light2result); // apply lighting\n        // raycol = vec3(amb + light1result + light2result); //d.c.rgb;\n        col += raycol;\n        // col = vec3(1./d.d);\n    }\n    col /= RAY_MAX;\n    // post fx\n    float gamma = 2.2;\n    col = pow(col, vec3(1.0/gamma));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define SS(a,b,c) smoothstep(a-b,a+b,c)\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n// sdfs\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdOrb(vec3 p, float b) {\n  return length(p) - b;\n}\nfloat sdGyroid(vec3 p, float b) {\n    float g = dot(sin(p),cos(p.yzx));\n    return g - b;\n}\n// sdf ops\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n\n// hash - rand - noise\n//--------------------\n// 1 out, 1 in\nfloat hash11(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n//  1 out, 3 in...\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n///  3 out, 3 in...\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n//\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n//\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43758.5453123);\n}\n\n// returns closest, second closest, and cell id\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n\n\n// iq box intersect\nfloat boxIntersect( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return tF;\n}\n\n\n// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786\nvec3 hueShift( vec3 color, float hueAdjust ){\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I       = dot (color, kRGBToI);\n    float   Q       = dot (color, kRGBToQ);\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    hue += hueAdjust;\n\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}