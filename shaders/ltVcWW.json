{
    "Shader": {
        "info": {
            "date": "1536405491",
            "description": "DCCI Super Resolution \nreference from:[url]http://www.nlpr.ia.ac.cn/2012papers/gjkw/gk46.pdf[/url]\nHere is just scale 2x image.\nPress \"SPACE“ key:See difference with DCCI\nPress \"W\" key: Reference with DCCI\nUse Mouse drag picture.",
            "flags": 48,
            "hasliked": 0,
            "id": "ltVcWW",
            "likes": 16,
            "name": "Super Resolution DCCI",
            "published": 3,
            "tags": [
                "filter",
                "upscale",
                "superresolution",
                "dcci",
                "imgaezoom"
            ],
            "usePreview": 0,
            "username": "834144373",
            "viewed": 1821
        },
        "renderpass": [
            {
                "code": "/*\n\tCreated by 834144373 \n\tImage Zooming is also one of Super Resolution \n\t\n\tPS:at the past few years,I read the paper by accident,hum...so interested \n\tthe students talk about.\n\t\n\tDCCI is called Directional Cubic Convolution Interpolation\n\tAbout the Knowledge:\n\thttp://www.nlpr.ia.ac.cn/2012papers/gjkw/gk46.pdf D.Zhou X.Shen W.Dong\n\thttps://en.wikipedia.org/wiki/Directional_Cubic_Convolution_Interpolation\n\t--------------------------------------------------------------------------\n\tBufferA: Original Image\n\tBufferB: Copy Image to 2x space\n\tBufferC: DCCI StepI\n\tBufferD: DCCI StepII\n\tImage  : Compare Result\n\n\tPress \"SPACE“ key:See difference with DCCI\n\tPress \"W\" key: Reference with DCCI\n\tUse Mouse drag picture.\n\n\tShow Result Code From https://www.shadertoy.com/view/ltsczl by and\n*/\n\n/*\n\t-------------Some with CNN Super Resolution---------------\n\tSRCNN https://www.shadertoy.com/view/ltsczl by and\n\t-----------------Some CNN------------------\n\tCNN https://www.shadertoy.com/view/XdjBRR by rory618\n*/\n\n#define _ASCIITex iChannel2\n#define _CharTex iChannel3\n#define R iResolution.xy\n#define KEY_SPECE 32 \n#define KEY_W 87\n#define KEY_D 68\n\nbool ReadKey(const int key);\nvec3 drawHud(vec3 clr, vec2 fragCoord);\n\nvoid mainImage( out vec4 C, in vec2 U){\n    vec2 i = 1.-step(vec2(1024.),U);\n    \n    if(U.x < R.x/3.){\n\t\t//NN\n        C = texelFetch(iChannel1,ivec2(U)>>1,0);\n        if(ReadKey(KEY_SPECE))\n        \tC = 5.*abs(C-texelFetch(iChannel0,ivec2(U.x,U.y)-1,0));\n        if(ReadKey(KEY_W)){\n            //Reference with DCCI\n    \t\tC = texelFetch(iChannel0,ivec2(U.x,U.y)-1,0);\n    \t}\n    }\n    else if(U.x > R.x/3.*2.){\n    \t//Blinear\n        C = texture(iChannel1,U/R/2. - vec2(1./3.,0.));\n        if(ReadKey(KEY_SPECE))\n        \tC = 5.*abs(C-texelFetch(iChannel0,ivec2(U.x-R.x/3.*2.,U.y)-1,0));\n        if(ReadKey(KEY_W)){\n            //Reference with DCCI\n    \t\tC = texelFetch(iChannel0,ivec2(U.x-R.x/3.*2.,U.y)-1,0);\n    \t}\n        \n    }\n    else{\n        //DCCI\n    \tC = texelFetch(iChannel0,ivec2(U.x-R.x/3.,U.y)-1,0);\n    }\n    \n    C.rgb = drawHud(C.rgb,U);\n}\n\n\nbool ReadKey(const int key){\n\treturn texelFetch(_ASCIITex,ivec2(key,0),0).r > 0.5;\n}\n//From https://www.shadertoy.com/view/ltsczl by and\nvec4 putChar(vec4 r, vec2 ouv, const int cx, const int cy){\n    r = all(greaterThan(ouv, r.zw)) && all(lessThan(ouv, r.zw + vec2(1.0 / 34.0, 1.0 / 16.0)))\n        ? vec4(ouv - r.zw + vec2(cx, cy) / 16.0 + vec2(1.0 / 60.0, 0.0), r.z, r.w) : r;\n\n    r.z += 1.0 / 34.0;\n\n    return r;\n}\nvec3 drawHud(vec3 clr, vec2 fragCoord){\n    float s = iResolution.x / iResolution.y;\n    vec2  uv = fragCoord.xy / iResolution.yy;\n    vec2  ouv = uv;\n    vec4  r = vec4(0);\n\n    #define C(x, y) r = putChar(r, ouv, x, y);\n\n    // NN\n    r.zw = vec2(0.108 * s, 0.93);\n    C(0,5)C(0,5)C(0,5)C(14,11)C(14,11)\n\n    // DCCI //SRCNN\n    r.zw = vec2(0.458 * s, 0.93);\n    C(4,11)C(3,11)C(3,11)C(9,11)\n\n    // BiLinear\n    r.zw = vec2(0.767 * s, 0.93);\n    C(2,11)C(9,9)C(12,9)C(9,9)C(14,9)C(5,9)C(1,9)C(2,8)\n\n    uv = r.xy;\n\n    // textureGrad is not supported in some browsers. Use mips bias instead.\n    // float d = textureGrad(iChannel1, uv, dFdx(ouv) * 0.5, dFdy(ouv) * 0.5).w;\n    float d = texture(_CharTex, uv, -10.0).w;\n\n    float q = fwidth(ouv.y) * 10.0;\n    float text = smoothstep(-q, q, 0.49 - d);\n    float shadow = smoothstep(-q * 2.0, q * 2.0, 0.52 - d);\n\n    // Header bar.\n    if (ouv.y > 0.92)\n        clr *= 0.3;\n\n    // Separation lines.\n    if (floor(fragCoord.x) == floor(iResolution.x / 3.0) || floor(fragCoord.x) == floor(iResolution.x * 2.0 / 3.0))\n        clr = vec3(0.0);\n\n    clr = mix(mix(clr, clr * 0.18, shadow), vec3(1.0), text);\n\n    return clr;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const ivec2 I_ZERO = ivec2(0);\nconst ivec2 I_ONE  = ivec2(1);\n\n//-------------------------YCoCg----------------------------\n/*\n Y = R/4 + G/2 + B/4\nCo = R/2 - B/2\nCg =-R/4 + G/2 - B/4\n*/\nvec3 RGB2YCoCg(vec3 RGB) {\n\tvec3 YCoCg;\n\tYCoCg.x = RGB.r / 4. + RGB.g / 2. + RGB.b / 4.;\n\tYCoCg.y = RGB.r / 2. - RGB.b / 2.;\n\tYCoCg.z = -RGB.r / 4. + RGB.g / 2. - RGB.b / 4.;\n\treturn YCoCg;\n}\n/*\n R = Y + Co - Cg\n G = Y + Cg\n B = Y - Co - Cg\n*/\nvec3 YCoCg2RGB(vec3 YCoCg) {\n\tvec3 RGB;\n\tRGB.r = YCoCg.x + YCoCg.y - YCoCg.z;\n\tRGB.g = YCoCg.x + YCoCg.z;\n\tRGB.b = YCoCg.x - YCoCg.y - YCoCg.z;\n\treturn RGB;\n}\n//------------------------------------DCCI---------------------------------------\nvec3 ArrCol[16];\nvec3 GetD1() {\n    return\n          abs(ArrCol[0] - ArrCol[5] ) + abs(ArrCol[1] - ArrCol[6] ) + abs(ArrCol[2]  - ArrCol[7])\n        + abs(ArrCol[4] - ArrCol[9] ) + abs(ArrCol[5] - ArrCol[10]) + abs(ArrCol[6]  - ArrCol[11])\n        + abs(ArrCol[8] - ArrCol[13]) + abs(ArrCol[9] - ArrCol[14]) + abs(ArrCol[10] - ArrCol[15]);\n}\nvec3 GetD2() {\n    return\n          abs(ArrCol[1] - ArrCol[4] ) + abs(ArrCol[2]  - ArrCol[5])  + abs(ArrCol[3]  - ArrCol[6])\n        + abs(ArrCol[5] - ArrCol[8] ) + abs(ArrCol[6]  - ArrCol[9])  + abs(ArrCol[7]  - ArrCol[10])\n        + abs(ArrCol[9] - ArrCol[12]) + abs(ArrCol[10] - ArrCol[13]) + abs(ArrCol[11] - ArrCol[14]);\n}\n//--------------------------------Show Char--------------------------------\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//From https://www.shadertoy.com/view/ltsczl by and\nvec4 loadSelf(int x, int y){\n    return texelFetch(iChannel1,ivec2(x, y),0);\n}\nvec2 mirror_uv(vec2 uv){\n    return 2.0 - (abs(fract(uv / 2.0) - 0.5) + 0.5) * 2.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 stc = floor(fragCoord);\n    vec4 self = loadSelf(0, 0);\n    vec4 new_self = self;\n    if (iMouse.z >= 0.0 && iMouse.w >= 0.0)\n        new_self.xy = floor(self.zw + (iMouse.xy - iMouse.zw));\n    else\n        new_self.zw = self.xy;\n    if (iMouse.x == iMouse.z && iMouse.y == iMouse.w)\n        new_self.xyzw = self.xyxy;\n    if (stc.x == 0.0 && stc.y == 0.0)\n        fragColor = new_self;\n    if (iFrame == 0){\n        new_self = -vec2(625, 405).xyxy;\n        fragColor = new_self;\n    }\n    if (!(stc.x == 0.0 && stc.y == 0.0)){\n        vec2 mpos  = new_self.xy;\n        vec2 offs  = 0.5 - floor(floor(mpos / 3.0) / 2.0) * 2.0;\n        vec2 tsize = iChannelResolution[0].xy;\n        float bias = -1.0;\n        vec3 tl = texture(iChannel0, mirror_uv((stc.xy * 1.0 + vec2(-0.25,-1  ) + offs) / tsize)).rgb;\n        fragColor.rgb = tl;\n        if (floor(fragCoord.x) > iResolution.x * 0.75){\n            vec2 uv = (stc - floor(vec2(iResolution.x * 0.75, 0.0)) + 0.5 - floor(mpos / 3.0)) / iChannelResolution[0].xy;\n        }\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage(out vec4 C,in vec2 U)\n{\n   \tivec2 iU = ivec2(U);\n   \t//Copy Original Texel\n    C = all(equal( iU&1 , I_ZERO)) ? texelFetch(iChannel0,iU>>1,0) : C-C;\n}\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void ArrayPixel(sampler2D _Tex,ivec2 iU) {\n    iU -= 3;\n    for (int y = 0;y < 4;y++) {\n        for (int x = 0;x < 4;x++) {\n            int id = y * 4 + x;\n            ArrCol[id] = texelFetch(_Tex,(iU+ivec2(x,y)*2),0).rgb*255.;\n        }\n    }\n}\nvec3 DCCI_StepI(ivec2 iU){\n\tvec3 OutColor = vec3(0.);\n    //Copy BufferA,calculate O\n    /*\n\t\t*  *   *  *\n\n\t\t*  *   *  *\n\t\t\t 0\n\t\t*  *   *  *\n\n\t\t*  *   *  *\n\t*/\n    if(all(equal( iU&1 , I_ONE))){\n\t\tArrayPixel(iChannel0,iU);\n        vec3 d1 = GetD1(), d2 = GetD2();\n        \n        vec3 DownRightPixel = -ArrCol[3] + 9.*ArrCol[6] + 9.*ArrCol[9] - ArrCol[12];\n        vec3 UpRightPixel = -ArrCol[15] + 9.*ArrCol[10] + 9.*ArrCol[5] - ArrCol[0];\n        \n        vec3 w1 = 1. / (1. + d1*d1*d1*d1*d1);\n        vec3 w2 = 1. / (1. + d2*d2*d2*d2*d2);\n        vec3 weight1 = w1 / (w1 + w2);\n        vec3 weight2 = w2 / (w1 + w2);\n        vec3 BlendPixel = DownRightPixel * weight1 + UpRightPixel * weight2;\n        \n        vec3 A = step(0.,((1. + d1) / (1. + d2)) - 1.15);\n        vec3 B = step(0.,((1. + d2) / (1. + d1)) - 1.15);\n\t\tvec3 C = (1.-A)*(1.-B);\n        \n        OutColor = DownRightPixel*A + UpRightPixel*B + C*BlendPixel;\n        \n        OutColor /= 16.;\n        OutColor /= 255.;\n    }\n    else{\n    \tOutColor = texelFetch(iChannel0,iU,0).rgb;\n    }\n    return OutColor;\n}\nvoid mainImage(out vec4 C,in vec2 U)\n{\n   \tivec2 iU = ivec2(U);\n\tC = vec4(DCCI_StepI(iU),1.); \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void ArrayPixel(sampler2D _Tex,ivec2 iU) {\n    iU -= 3;\n    for (int y = 0;y < 4;y++) {\n        for (int x = 0;x < 4;x++) {\n            int id = y * 4 + x;\n            ArrCol[id] = texelFetch(_Tex,(iU+ivec2(x,3-x)+y),0).rgb*255.;\n        }\n    }\n}\nvec3 DCCI_StepII(ivec2 iU){\n\tvec3 OutColor = vec3(0.);\n    //Copy BufferB,calculate C\n    /*\n\t\t        *                  *  O   *  O\n\t\t\t  O   O            \n\t\t    *   *   *      Rot     O  *   O  *\n\t\t  O\t  O C O\t  O  ======> \n\t\t\t*   *   *              *  O   *  O\n\t\t\t  O   O\n\t\t        *                  O  *   O  *\n\t*/\n    if(((iU.x+iU.y) & 1) == 1){\n        ArrayPixel(iChannel0,iU+1);\n\t\tvec3 d1 = GetD1(), d2 = GetD2();\n        \n        vec3 DownRightPixel = -ArrCol[3] + 9.*ArrCol[6] + 9.*ArrCol[9] - ArrCol[12];\n        vec3 UpRightPixel = -ArrCol[15] + 9.*ArrCol[10] + 9.*ArrCol[5] - ArrCol[0];\n        \n        vec3 w1 = 1. / (1. + d1*d1*d1*d1*d1);\n        vec3 w2 = 1. / (1. + d2*d2*d2*d2*d2);\n        vec3 weight1 = w1 / (w1 + w2);\n        vec3 weight2 = w2 / (w1 + w2);\n        vec3 BlendPixel = DownRightPixel * weight1 + UpRightPixel * weight2;\n        \n        vec3 A = step(0.,((1. + d1) / (1. + d2)) - 1.15);\n        vec3 B = step(0.,((1. + d2) / (1. + d1)) - 1.15);\n\t\tvec3 C = (1.-A)*(1.-B);\n        \n        OutColor = DownRightPixel*A + UpRightPixel*B + C*BlendPixel;\n        \n        OutColor /= 16.;\n        OutColor /= 255.;\n    }\n    else{\n    \tOutColor = texelFetch(iChannel0,iU,0).rgb;\n    }\n    return OutColor;\n}\nvoid mainImage(out vec4 C,in vec2 U)\n{\n   \tivec2 iU = ivec2(U);\n\tC = vec4(DCCI_StepII(iU),1.); \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}