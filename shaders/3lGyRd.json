{
    "Shader": {
        "info": {
            "date": "1611528646",
            "description": "A fork of MMSE specifically tuned for path tracing",
            "flags": 48,
            "hasliked": 0,
            "id": "3lGyRd",
            "likes": 22,
            "name": "Fractal Path Tracer",
            "published": 3,
            "tags": [
                "game"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 1087
        },
        "renderpass": [
            {
                "code": "// Fork of \"Marble Marcher: SE\" by michael0884. https://shadertoy.com/view/3lKyDR\n// 2021-01-24 21:45:11\n\n//Marble Marcher Shadertoy Edition\n//Version 0.9 BETA\n\n//Ported by michael0884 (Mykhailo Moroz)\n\n//Original Marble Marcher by CodeParade\n//https://github.com/HackerPoet/MarbleMarcher\n\n//Also check out Marble Marcher Community Edition!\n//https://github.com/WAUthethird/Marble-Marcher-Community-Edition\n\n//Notable features:\n//Temporal antialiasing with disocclusion rejection, velocity vectors and neighbor clamping\n//Lots of blue noise\n//Ambient occlusion \n//PBR rendering\n//Path tracing support, uncomment the define in Common\n//Path tracer is also PBR with refraction support\n//Physics in purely shader based\n\n//Instructions\n//WASD/Arrows and mouse to move marble. Q/E camera distance. \n//R - restart level\n//SPACE - next level(only when you completed this one)\n//Backspace - return to main menu\n//F - go to free camera mode, in this mode Q/E regulate camera speed\n//Change parameters in Common tab\n//level transition buttons \n//P - next level\n//O - previous level\n//M - restart frame accumulation\n\n//comment if the compiler wasn't able to optimize text rendering\n#define RENDER_TEXT\n\n#define STRINGS 8\n#define TOTCHARS STRLENGTH*STRINGS\n/*\nconst uint[] TEXT_ARRAY = uint[](\n  STRING(M,a,r,b,l,e,_,M,a,r,c,h,e,r,_,_,_,_,_,_,_,_,_,_),     //0\n  STRING(S,h,a,d,e,r,t,o,y,_,E,d,i,t,i,o,n,_,_,_,_,_,_,_),     //1\n  STRING(P,o,r,t,_,b,y,_,m,i,c,h,a,e,l,_0,_8,_8,_4,_,_,_,_,_), //2\n  STRING(O,r,i,g,i,n,a,l,_,b,y,_,C,o,d,e,P,a,r,a,d,e,_,_),     //3\n  \n  STRING(P,r,e,s,s,_,S,p,a,c,e,_,t,o,_,C,o,n,t,i,n,u,e,_),     //4\n  STRING(P,r,e,s,s,_,R,_,t,o,_,R,e,s,t,a,r,t,_,L,e,v,e,l),     //5\n  \n  STRING(P,l,a,y,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_),     //6\n  STRING(L,e,v,e,l,s,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_),      //7\n  \n  STRING(B,a,c,k,_,t,o,_,M,a,i,n,_,M,e,n,u,_,_,_,_,_,_,_),\n  STRING(J,u,m,p,_,t,h,e,_,c,r,a,t,e,r,_,_,_,_,_,_,_,_,_),\n  STRING(T,o,o,_,m,a,n,y,_,t,r,e,e,s,_,_,_,_,_,_,_,_,_,_),\n  STRING(H,o,l,e,_,i,n,_,o,n,e,_,_,_,_,_,_,_,_,_,_,_,_,_),\n  STRING(B,e,w,a,r,e,_,o,f,_,b,u,m,p,s,_,_,_,_,_,_,_,_,_),\n  STRING(M,o,u,n,t,a,i,n,_,c,l,i,m,b,i,n,g,_,_,_,_,_,_,_),\n  STRING(M,i,n,d,_,t,h,e,_,g,a,p,_,_,_,_,_,_,_,_,_,_,_,_),\n  STRING(T,h,e,_,s,p,o,n,g,e,_,_,_,_,_,_,_,_,_,_,_,_,_,_),\n  STRING(B,u,i,l,d,_,u,p,_,s,p,e,e,d,_,_,_,_,_,_,_,_,_,_),\n  STRING(A,r,o,u,n,d,_,t,h,e,_,c,i,t,a,d,e,l,_,_,_,_,_,_),\n  STRING(T,o,p,_,o,f,_,t,h,e,_,c,i,t,a,d,e,l,_,_,_,_,_,_),\n  STRING(M,e,g,a,_,C,i,t,a,d,e,l,_,_,_,_,_,_,_,_,_,_,_,_)\n);\n\n#define CONTOUR 1.1\n#define CHAR_WIDTH 0.5\n\nvoid draw_char(inout vec3 incol, vec2 p, vec3 tcol, vec2 pos, float size, uint char)\n{        \n  p.y = iResolution.y - p.y;\n  p = (p - pos)/vec2(size*CHAR_WIDTH, size); \n  if(p.x < 0.0 || p.x > 1.0 || p.y < 0.0 || p.y > 1.0) return; \n  int code = int(char);\n  \n  p.x=(fract(p.x) - 0.5)*CHAR_WIDTH + 0.5; p.y=1.-p.y;                 \n  p+=vec2(code%16,15-code/16);                          \n  float sdf = (texture(iChannel3, p/16.).w - 0.5 + 1.0/256.0)*size;\n  \n  float blend = smoothstep(CONTOUR, 0.0, sdf);\n  vec3 color = tcol*(2.*smoothstep(CONTOUR, -CONTOUR, sdf) - smoothstep(1.2*CONTOUR, 0.0, sdf));\n  incol = mix(incol, color, blend);\n}\n\nvoid draw_string(inout vec3 incol, vec2 p, vec3 tcol, vec2 pos, float size, int string) \n{        \n  vec2 p0 = p; p.y = iResolution.y - p.y;\n  p = (p - pos)/vec2(size*CHAR_WIDTH, size);\n  if(p.x < 0.0 || p.x > float(STRLENGTH) || p.y < 0.0 || p.y > 1.0) return;\n  draw_char(incol, p0, tcol, pos + vec2(floor(p.x)*size*CHAR_WIDTH,0.), size, TEXT_ARRAY[int(p.x) + string*STRLENGTH]);   \n}\n\nvoid draw_string(inout vec3 incol, in vec2 p, in vec3 tcol, in vec2 pos, in float size, in uint[8] string) \n{        \n  vec2 p0 = p; p.y = iResolution.y - p.y;\n  p = (p - pos)/vec2(size*CHAR_WIDTH, size);\n  if(p.x < 0.0 || p.x > float(8) || p.y < 0.0 || p.y > 1.0) return;\n  \n  //compiler doesn't want to optimize dynamic array indexing, idk why\n  //a loop doesn't work either\n  draw_char(incol, p0, tcol, pos + vec2(0.0*size*CHAR_WIDTH,0.), size, string[0]);\n  draw_char(incol, p0, tcol, pos + vec2(1.0*size*CHAR_WIDTH,0.), size, string[1]);\n  draw_char(incol, p0, tcol, pos + vec2(2.0*size*CHAR_WIDTH,0.), size, string[2]);\n  draw_char(incol, p0, tcol, pos + vec2(3.0*size*CHAR_WIDTH,0.), size, string[3]);\n  draw_char(incol, p0, tcol, pos + vec2(4.0*size*CHAR_WIDTH,0.), size, string[4]);\n  draw_char(incol, p0, tcol, pos + vec2(5.0*size*CHAR_WIDTH,0.), size, string[5]);\n  draw_char(incol, p0, tcol, pos + vec2(6.0*size*CHAR_WIDTH,0.), size, string[6]);\n  draw_char(incol, p0, tcol, pos + vec2(7.0*size*CHAR_WIDTH,0.), size, string[7]);\n}\n  */\n#define SHARPEN 1.\n#define LOWSAMPLE_BLUR 1.\nvec4 tone(vec4 col)\n{\n   return tanh(EXPOSURE*pow(col, vec4(1.0/2.)));\n}\n\nvec4 sample_adaptive(sampler2D ch, vec2 uv)\n{\n    vec3 dx = vec3(1.0/vec2(textureSize(ch, 0)),0.);\n    \n    vec4 c = tone(texture(ch, uv));\n    vec2 v = decode(texelFetch(iChannel0, ivec2(uv*iResolution.xy), 0).w);\n    float k = mix(-LOWSAMPLE_BLUR, SHARPEN, smoothstep(0.1, 0.5, v.y));\n    \n    vec4 u = tone(texture(ch, uv + dx.zy));\n    vec4 d = tone(texture(ch, uv - dx.zy));\n    vec4 r = tone(texture(ch, uv + dx.xz));\n    vec4 l = tone(texture(ch, uv - dx.xz));\n    return (1.+k)*c - 0.25*k*(u+d+r+l); \n}\n  \nvoid mainImage( out vec4 c, in vec2 p )\n{\n    load_scene(iChannel2, iTime, iResolution.xy);\n    \n    vec2 uv = p/iResolution.xy;\n    c.xyz = sample_adaptive(iChannel0, p/iResolution.xy).xyz;\n    //c.xyz = texture(iChannel1, p/(MR_SCALE*iResolution.xy)).xyz/5.0;\n    c.xyz = clamp(c.xyz, 0., 1.0);\n    \n    float ms = timers.x*100.0/60.0;\n    float fps = 1./timers.z;\n    float se = mod(timers.x/60., 60.);\n    float se0 = mod(-timers.x/60., 60.);\n    float dse0 = mod(se0, 1.0);\n    float mi = timers.x/3600.;\n    uint[8] timer = uint[](NUM2CHAR(mi/10.0),NUM2CHAR(mi),C(co),NUM2CHAR(se/10.0),NUM2CHAR(se),C(co),NUM2CHAR(ms/10.0),NUM2CHAR(ms));   \n    uint[8] fps_text = uint[](NUM2CHAR(fps/10.0),NUM2CHAR(fps),C(_),C(F),C(P),C(S),C(_),C(_));   \n    \n    float font_size = FONT_SCALE;\n    c.w = 1.0;\n    \n    //draw_string(c.xyz, p, vec3(1.), vec2(0.9, 0.01)*iResolution.xy, 20.0*font_size,  fps_text);\n    switch(int(MODE/64.0))\n    {\n    case GAMEMODE_MENU: //MAIN MENU\n       // draw_string(c.xyz, p, vec3(1.), vec2(0.03, 0.03)*iResolution.xy, 62.0*font_size,  0);\n        //draw_string(c.xyz, p, vec3(1.), vec2(0.40, 0.15)*iResolution.xy, 35.0*font_size,  1);\n       // draw_string(c.xyz, p, vec3(1.), vec2(0.03, 0.85)*iResolution.xy, 27.0*font_size,  2);\n       // draw_string(c.xyz, p, vec3(1.), vec2(0.03, 0.91)*iResolution.xy, 27.0*font_size,  3);\n       \n        break;\n    case GAMEMODE_LEVELS: //LEVELS MENU\n        \n        break;\n    case GAMEMODE_GAME: //TIMER\n        if(timers.x>=0.)\n        {\n           // draw_string(c.xyz, p, vec3(1.), vec2(0.39, 0.01)*iResolution.xy, 40.0*font_size,  timer);\n        }\n        else\n        {\n           // draw_char(c.xyz, p, vec3(1.), vec2(0.47 - 0.008*dse0, 0.01)*iResolution.xy, (80.0 + 40.0*dse0)*font_size,  NUM2CHAR(se0+1.0));\n        }\n        return;    \n    case GAMEMODE_FINISH: \n        //draw_string(c.xyz, p,  vec3(0.000,0.702,1.000), vec2(0.39, 0.01)*iResolution.xy, 40.0*font_size,  timer);\n        //draw_string(c.xyz, p, vec3(1.), vec2(0.03, 0.85)*iResolution.xy, 27.0*font_size,  4);\n        //draw_string(c.xyz, p, vec3(1.), vec2(0.03, 0.91)*iResolution.xy, 27.0*font_size,  5);\n        break;    \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//standard constants\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\n//rendering settings\n#define MAX_STEPS 90\n#define MIN_DIST 1e-5\n#define MAX_DIST 60.0\n#define LIGHT_BRIGHTNESS 2.0\n#define FRACTAL_ITER 12\n#define FOV 1.0\n#define EXPOSURE 1.0\n#define ADAPTIVE_PHYSICS_ITERATIONS\n//#define FORCE_ALONG_CAMERA\n\n//multiresolution scaling\n#define MR_SCALE 3.0\n\n#define PATH_TRACING\n#define BOUNCES 6\n#define DIRECT_LIGHT\n#define AMBIENT 5.0\n#define APERTURE 0.00\n\n//TAA\n#define DISOCCLUSION_REJECTION 6e-4\n#define CAMERA_MOVEMENT_REJECTION 5e-3\n\n#ifdef PATH_TRACING\n    #define REPROJECTION 1.0\n#else\n    #define REPROJECTION 0.9\n#endif\n\n//#define AMBIENT_OCCLUSION\n//#define SHADOWS\n#define DIRECT_BRIGHTNESS vec3(6.0)\n\n#define FRACTAL_F0 vec3(0.1)\n#define FRACTAL_ROUGHNESS 0.02\n#define FRACTAL_TRANSPARENT false\n#define FRACTAL_WHITE 0.9\n\n#define DISOCCLUSION_REJECTION_STR 1.0\n#ifdef PATH_TRACING\n    #define NEIGHBOR_CLAMP_RADIUS 2\n#else\n    #define NEIGHBOR_CLAMP_RADIUS 2\n#endif\n\n\n//#define AUTO_FOCUS\n#define FOCAL_PLANE 0.3\n\n\n//gameplay defines\n#define NUM 16\n\n#define MOUSE_       0\n#define CAM_ANGLE_   1\n#define CAM_POS_     2\n#define PCAM_ANGLE_  3\n#define PCAM_POS_    4\n#define PRESOLUTION_ 5\n#define CAM_VEL_     6\n//scene\n#define LIGHT_POS_   7\n#define MARBLE_POS_  8\n#define DMARBLE_POS_ 9\n#define MARBLE_VEL_  10\n#define TIMER_MODE_  11\n#define FLAG_POS_    12\n\n//fractal angles, scale\n#define FRAC_PARAM1_ 13\n//shift\n#define FRAC_PARAM2_ 14\n//color\n#define FRAC_PARAM3_ 15\n\n#define GAMEMODE_MENU 0\n#define GAMEMODE_LEVELS 1\n#define GAMEMODE_GAME 3\n#define GAMEMODE_FINISH 4\n#define GAMEMODE_FREE 5\n\n#define GET_DATA(ch, i) texelFetch(ch, ivec2(i, 0), 0)\n\nfloat CAM_ANGLE;\n\n//fractal\nfloat iFracScale, iFracAng1, iFracAng2;\nvec3 iFracShift, iFracCol;\n\nvec4 iMarblePos, iFlagPos;\nvec3 iMarbleVel; vec4 dMarblePos;\n\nvec3 iLightDir;\nfloat isPlanet;\n\n//current and prev camera\nvec4 ang, pang; \nvec4 pResolution;\nmat3 cam, pcam;\nvec3 campos, pcampos;\nvec3 camvel;\nfloat radius;\n\nfloat time;\nvec3 timers;\nfloat MODE;\n\n\n//CAMERA stuff\nmat3 get_cam(vec2 ang)\n{\n    vec3 x_dir = vec3(cos(ang.x)*sin(ang.y), cos(ang.y), sin(ang.x)*sin(ang.y));\n    vec3 y_dir = normalize(cross(x_dir, vec3(0,1,0)));\n    vec3 z_dir = normalize(cross(y_dir, x_dir));\n    return mat3(-x_dir, y_dir, z_dir);\n}\n\n//use previous camera matrix and camera position to reproject a point onto previous frame\nvec3 reproject(mat3 pcam_mat, vec3 pcam_pos, vec2 iRes, vec3 p)\n{\n    float td = distance(pcam_pos, p);\n    vec3 dir = (p - pcam_pos)/td;\n    vec3 screen = vec3(dot(pcam_mat[0],dir),dot(pcam_mat[1],dir),dot(pcam_mat[2],dir));\n    return vec3(screen.yz*iRes.y/(FOV*screen.x) + 0.5*iRes.xy, td);\n}\n\n//SCENE\nvoid load_scene(sampler2D data, float t, vec2 res)\n{\n    time = t;\n    CAM_ANGLE = 1./res.y;\n    vec4 d1 = GET_DATA(data, FRAC_PARAM1_);        \n    iFracScale = d1.x; iFracAng1 = d1.y+0.000*sin(t); iFracAng2 = d1.z; //Scale, Angle1, Angle2\n    isPlanet = d1.w;\n    iFracShift = GET_DATA(data, FRAC_PARAM2_).xyz;                //Offset\n    iFracCol =   GET_DATA(data, FRAC_PARAM3_).xyz;                    //Color\n    iMarblePos = GET_DATA(data, MARBLE_POS_);                //Marble radius + size\n    iFlagPos =  GET_DATA(data, FLAG_POS_);           //Flag radius + size\n    vec4 MV_ = GET_DATA(data, MARBLE_VEL_);\n    iMarbleVel = MV_.xyz;\n    radius = MV_.w;\n    \n    dMarblePos = GET_DATA(data, DMARBLE_POS_);\n    \n    vec4 TM_ = GET_DATA(data, TIMER_MODE_);\n    timers = TM_.xyz;\n    MODE = TM_.w;\n    \n    //current camera\n    ang = GET_DATA(data, CAM_ANGLE_);\n    campos = GET_DATA(data, CAM_POS_).xyz;\n    camvel = GET_DATA(data, CAM_VEL_).xyz;\n    cam = get_cam(ang.xy);\n    \n    //previous camera\n    pang = GET_DATA(data, PCAM_ANGLE_);\n    pcampos = GET_DATA(data, PCAM_POS_).xyz;\n    pcam = get_cam(pang.xy);\n    \n    iLightDir = normalize(GET_DATA(data, LIGHT_POS_).xyz);\n    \n    pResolution = GET_DATA(data, PRESOLUTION_);\n}\n\n//marble physics\nconst float ground_force = 0.008f;\nconst float air_force = 0.004f;\nconst float ground_friction = 0.99f;\nconst float air_friction = 0.995f;\nconst float orbit_speed = 0.005f;\nconst int max_marches = 10;\nconst int num_phys_steps = 6;\nconst float marble_bounce = 1.2f;\nconst float gravity = 0.005f;\n\n//##########################################\n//   Space folding\n//##########################################\nvoid planeFold(inout vec3 z, vec3 n, float d) {\n\tz.xyz -= 2.0 * min(0.0, dot(z.xyz, n) - d) * n;\n}\nvoid sierpinskiFold(inout vec3 z) {\n\tz.xy -= min(z.x + z.y, 0.0);\n\tz.xz -= min(z.x + z.z, 0.0);\n\tz.yz -= min(z.y + z.z, 0.0);\n}\nvec2 mp = vec2(-1.,1.);\nvoid mengerFold(inout vec3 z) \n{\n\tz.xy += min(z.x - z.y, 0.0)*mp;\n\tz.xz += min(z.x - z.z, 0.0)*mp;\n\tz.yz += min(z.y - z.z, 0.0)*mp;\n}\nvoid boxFold(inout vec3 z, vec3 r) {\n\tz.xyz = clamp(z.xyz, -r, r) * 2.0 - z.xyz;\n}\n//##########################################\n//   Primitive DEs\n//##########################################\nfloat de_plane(vec3 p, vec4 d)\n{\n    return dot(p,d.xyz) + d.w;\n}\nfloat de_sphere(vec3 p, float r) {\n\treturn (length(p.xyz) - r);\n}\nfloat de_box(vec3 p, vec3 s) {\n\tvec3 a = abs(p.xyz) - s;\n\treturn (min(max(max(a.x, a.y), a.z), 0.0) + length(max(a, 0.0)));\n}\nfloat de_tetrahedron(vec3 p, float r) {\n\tfloat md = max(max(-p.x - p.y - p.z, p.x + p.y - p.z),\n\t\t\t\tmax(-p.x + p.y + p.z, p.x - p.y + p.z));\n\treturn (md - r) / sqrt(3.0);\n}\nfloat de_capsule(vec3 p, float h, float r) {\n\tp.y -= clamp(p.y, -h, h);\n\treturn (length(p.xyz) - r);\n}\n//##########################################\n//   Main DEs\n//##########################################\n\nvec2 opUnion(vec2 a, vec2 b)\n{\n    return (a.x < b.x)?a:b;\n}\n\nvec4 fractal(vec3 p)\n{\n    vec2 a1 = vec2(sin(iFracAng1), cos(iFracAng1));\n    vec2 a2 = vec2(sin(iFracAng2), cos(iFracAng2));\n\tmat2 rmZ = mat2(a1.y, a1.x, -a1.x, a1.y);\n\tmat2 rmX = mat2(a2.y, a2.x, -a2.x, a2.y);\n    float scale = 1.0;\n    vec3 orbit = vec3(0.); \n    for (int i = 0; i < FRACTAL_ITER; ++i) {\n\t\tp.xyz = abs(p.xyz);\n\t\tp.xy *= rmZ;\n\t\tmengerFold(p);\n\t\tp.yz *= rmX;\n\t\tp *= iFracScale; scale*=iFracScale;\n\t\tp.xyz += iFracShift;\n        orbit = max(orbit, p.xyz*iFracCol);\n\t}\n    return vec4(clamp(orbit, 0., 1.), de_box(p, vec3(6.0))/scale);\n}\n\n\nvec4 mandelbulb(in vec3 p)\n{\n    p = p - 0.*iFlagPos.xyz + vec3(0., 2.4, 0.);\n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec3 orbitrap = vec3(1.0);\n\tfloat dz = 1.0;\n    \n\tfor( int i=0; i<3; i++ )\n    {\n        dz = 8.0*pow(sqrt(m),7.0)*dz + 1.0;\n        \n        float r = length(w);\n        float b = 8.0*acos( w.y/r);\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );     \n        \n        orbitrap = min( orbitrap, abs(w) );\n\n        m = dot(w,w);\n\t\tif( m > 2.0 )\n            break;\n    }\n\n    return vec4(orbitrap, 0.25*log(m)*sqrt(m)/dz);\n}\n\nvec2 de_fractal(vec3 p)\n{\n    return vec2(fractal(p).w, 0);\n}\n\nvec3 color_fractal(vec3 p)\n{\n    return fractal(p).xyz;\n}\n\nvec2 de_marble(vec3 p) \n{\n\tfloat de = de_sphere(p - iMarblePos.xyz, iMarblePos.w*0.98);\n    return vec2(de, 1);\n}\n\nvec2 de_flag(vec3 p) \n{\n\tvec3 f_pos = iFlagPos.xyz + vec3(1.5, 4, 0)*iFlagPos.w;\n\tvec3 p_s = p/iFlagPos.w;\n\tvec3 d_pos = p - f_pos;\n\tvec3 caps_pos = p - (iFlagPos.xyz + vec3(0, iFlagPos.w*2.4, 0));\n\t//animated flag\n\tfloat speed = 14.0;\n\tfloat oscillation = sin(8.0*p_s.x - 1.0*p_s.y - speed*time) +\n                    0.4*sin(11.0*p_s.x + 2.0*p_s.y - 1.2*speed*time) + \n                    0.15*sin(20.0*p_s.x - 5.0*p_s.y - 1.4*speed*time);\n\t//scale the flag displacement amplitude by the distance from the flagpole\n\tvec2 flag = vec2(0.6*de_box(d_pos + caps_pos.x*vec3(0,(0.02+ caps_pos.x* 0.5+0.01*oscillation),0.04*oscillation),\n                        vec3(1.5, 0.8, 0.005)*iFlagPos.w), 2);\n\tvec2 capsule = vec2(de_capsule(caps_pos, iFlagPos.w*2.4, iFlagPos.w*0.05), 3);\n    \n\treturn opUnion(flag, capsule);\n}\n\nvec2 physics_scene(vec3 p)\n{\n    vec2 fractal = de_fractal(p);\n    //\\\\vec2 bulb = vec2(mandelbulb(p).w, 5);\n    //vec2 mandelbox = vec2(mb(p).w,5.0);\n    vec2 plane =vec2(de_plane(p, vec4(0., 1.0, 0., 3.5)),6.);\n    return opUnion(fractal, plane);\n}\n\nvec2 scene(vec3 p)\n{\n    vec2 physical = physics_scene(p);\n    vec2 marble = de_marble(p);\n   // vec2 flag = de_flag(p);\n   \n    return opUnion(physical, marble);\n}\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn  0.25*(k.xyyx*scene(p + k.xyy*dx).x +\n\t\t\t      k.yyxx*scene(p + k.yyx*dx).x +\n\t\t\t      k.yxyx*scene(p + k.yxy*dx).x +\n\t\t\t      k.xxxx*scene(p + k.xxx*dx).x)/vec4(dx,dx,dx,1.0);\n}\n\nvec3 closestPoint(vec3 p) {\n\tconst vec3 k = vec3(1,-1,0);\n    const float dx = 1e-3;\n    vec4 n = 0.25*(k.xyyx*physics_scene(p + k.xyy*dx).x +\n\t\t\t       k.yyxx*physics_scene(p + k.yyx*dx).x +\n\t\t\t       k.yxyx*physics_scene(p + k.yxy*dx).x +\n\t\t\t       k.xxxx*physics_scene(p + k.xxx*dx).x); \n\tn.xyz = normalize(n.xyz);\n    p -= n.w*n.xyz;\n    //trace a few steps to the surface\n    for(int i = 0; i<1; i++)\n    {\n    //    p -= n.xyz*physics_scene(p).x;\n    }\n    return p;\n}\n\nstruct material\n{\n    vec3 color;\n    vec3 emission;\n    vec3 normal;\n    vec3 cpoint; //closest point\n    vec3 velocity;\n    float roughness;\n    bool transparent;\n    vec3 F0;\n    float inside;\n};\n\nmaterial getMaterial(inout vec4 p)\n{\n    material cur;\n    float mindistance = 0.75*max(CAM_ANGLE*p.w,MIN_DIST);\n    cur.normal = normalize(calcNormal(p.xyz, mindistance).xyz);\n    vec2 scene = scene(p.xyz);\n    cur.inside = sign(scene.x);\n    vec3 dsurface = cur.normal*scene.x;\n    cur.cpoint = p.xyz - dsurface;\n     \n    int id = int(scene.y);\n    cur.F0 = vec3(0.15);\n    cur.transparent = false; \n    cur.emission = vec3(0.0);\n    switch(id)\n    {\n    case 0:\n        cur.color = mix(vec3(1.0), color_fractal(cur.cpoint).xyz,FRACTAL_WHITE);\n        cur.F0 = FRACTAL_F0;\n        cur.roughness = FRACTAL_ROUGHNESS;\n        cur.transparent = FRACTAL_TRANSPARENT; \n        cur.velocity = vec3(0.);//TODO with animations\n        cur.emission = 0.0*vec3(1.000,1.000,1.000)*exp(-300.*clamp(pow(abs(length( cur.color - vec3(0.000,0.298,1.000) )),2.),0.,1.));\n        break;\n    case 1:\n        cur.color = vec3(1.);\n        cur.roughness = 0.02;\n        cur.F0 = vec3(0.03);\n        cur.velocity = dMarblePos.xyz;\n        cur.emission = vec3(.0);\n        cur.transparent = true;\n        break;\n    case 2:\n        cur.color = vec3(1.000,0.078,0.078);\n         cur.transparent = true;\n        cur.roughness = 0.02;\n        cur.velocity = vec3(0.); //TODO\n        break;\n    case 3:\n        cur.color = vec3(1.000,0.867,0.000);\n        cur.roughness = 0.5;\n        cur.velocity = vec3(0.);\n        break;\n    case 4:\n        cur.color = vec3(0.000,0.118,1.000);\n        cur.roughness = 0.01;\n        cur.velocity = vec3(0.);\n        break;\n    case 5:\n        cur.F0 = FRACTAL_F0;\n        cur.roughness = 0.008;\n        cur.transparent = true; \n        cur.color = mix(vec3(1.),mandelbulb(p.xyz).xyz, 1.0);\n        cur.velocity = vec3(0.);\n        break;\n    default:\n        cur.color = vec3(1.000,1.000,1.000);\n        cur.roughness = 0.5;\n        cur.velocity = vec3(0.);\n        break;\n    }\n    cur.color = pow(cur.color, vec3(1.62));\n    return cur;\n}\n\nbool trace(inout vec4 ro, vec3 rd)\n{\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        float de = abs(scene(ro.xyz).x); \n        float md = max(CAM_ANGLE*ro.w,MIN_DIST);\n        ro += vec4(rd, 1.0)*(de - 2.0*step(de, md)*md); \n        if(de < md) return true;\n        if(ro.w > MAX_DIST) return false;\n    }\n    return true;\n}\n\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec3 rand3()\n{\n    pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\n//random blue noise sampling pos\nivec2 shift2()\n{\n    pcg4d(s1); \n    return (pixel + ivec2(s1.xy%0x0fffffffu))%1024;\n}\n\nvec2 rand2t()\n{\n    pcg4d(s1); return vec2(s1.xy)/float(0xffffffffu);\n}\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\n// halton low discrepancy sequence, from https://www.shadertoy.com/view/wdXSW8\nvec2 halton(int index)\n{\n    const vec2 coprimes = vec2(2.0f, 3.0f);\n    vec2 s = vec2(index, index);\n\tvec4 a = vec4(1,1,0,0);\n    while (s.x > 0. && s.y > 0.)\n    {\n        a.xy = a.xy/coprimes;\n        a.zw += a.xy*mod(s, coprimes);\n        s = floor(s/coprimes);\n    }\n    return a.zw;\n}\n\nfloat HenyeyGreenstein(float g, float costh)\n{\n    return (1.0 - g * g) / (4.0 * PI * pow(1.0 + g * g - 2.0 * g * costh, 3.0/2.0));\n}\n\n \nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 rot(float ang)\n{\n    return mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n}\n\n//Keyboard constants\nconst int KEY_SPACE = 32;\nconst int KEY_BSPACE = 8;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n\n//from https://www.shadertoy.com/view/XsSXDy\nvec4 powers( float x ) { return vec4(x*x*x, x*x, x, 1.0); }\n\nconst vec4 ca = vec4(   3.0,  -5.0,   0.0,  2.0 ) /  2.0;\nconst vec4 cb = vec4(  -1.0,   5.0,  -8.0,  4.0 ) /  2.0;\n\nvec4 spline( float x, vec4 c0, vec4 c1, vec4 c2, vec4 c3 )\n{\n    // We could expand the powers and build a matrix instead (twice as many coefficients\n    // would need to be stored, but it could be faster.\n    return c0 * dot( cb, powers(x + 1.0)) + \n           c1 * dot( ca, powers(x      )) +\n           c2 * dot( ca, powers(1.0 - x)) +\n           c3 * dot( cb, powers(2.0 - x));\n}\n\n\n#define SAM(a,b)  texture(tex, (i+vec2(float(a),float(b))+0.5)/res, -99.0)\n\nvec4 texture_Bicubic( sampler2D tex, vec2 t )\n{\n    vec2 res = vec2(textureSize(tex,0));\n    vec2 p = res*t - 0.5;\n    vec2 f = fract(p);\n    vec2 i = floor(p);\n\n    return spline( f.y, spline( f.x, SAM(-1,-1), SAM( 0,-1), SAM( 1,-1), SAM( 2,-1)),\n                        spline( f.x, SAM(-1, 0), SAM( 0, 0), SAM( 1, 0), SAM( 2, 0)),\n                        spline( f.x, SAM(-1, 1), SAM( 0, 1), SAM( 1, 1), SAM( 2, 1)),\n                        spline( f.x, SAM(-1, 2), SAM( 0, 2), SAM( 1, 2), SAM( 2, 2)));\n}\n\n\nuvec2 unpack_uint2x(uint x)\n{\n    return uvec2(x%0x00010000u,x/0x00010000u);\n}\n\nuint pack_uint2x(uvec2 x)\n{\n    return x.x + x.y*0x00010000u;\n}\n\nvec2 decode(float data)\n{\n    return vec2(unpack_uint2x(floatBitsToUint(data)))/100.;\n}\n\nfloat encode(vec2 data)\n{\n    return uintBitsToFloat(pack_uint2x(uvec2(data*100.0)));\n}\n\n//simplified ttg's GLSL character printing library\n//https://www.shadertoy.com/view/Wd2SDt\nconst struct CHARS {\n  uint\n    _,   em,  dq,  ha,  ds,  mo,  am,  sq,  lp,  rp,  as,  pl,  cm,  hm,  pe,  sl,\n    _0,  _1,  _2,  _3,  _4,  _5,  _6,  _7,  _8,  _9,  co,  sc,  lt,  eq,  gt,  qm,\n    at,   A,   B,   C,   D,   E,   F,   G,   H,   I,   J,   K,   L,   M,   N,   O,\n     P,   Q,   R,   S,   T,   U,   V,   W,   X,   Y,   Z,  lb,  bs,  rb,  up,  un,\n    bt,   a,   b,   c,   d,   e,   f,   g,   h,   i,   j,   k,   l,   m,   n,   o,\n     p,   q,   r,   s,   t,   u,   v,   w,   x,   y,   z,  lc,  ba,  rc,  ti, _U0,\n   alp, bet, gam, del, eps, the, lam,  mu,  xi,  pi, rho, sig, tau, phi, psi, ome,\n   Gam, Del, The, Lam,  Pi, Sig, Phi, Psi, Ome, inf,flor,ring,intg,pdrv, nab,sqrt,\n   _U1, iem, cen, pou, cur, yen, bba, sec, dia, cop, fem, lda, not, _U2, reg, mac,\n   deg, pms, su2, su3, acu, mic, pil, mid, ced, su1, mas, rda, v14, v12, v34, iqm,\n    AG,  AA,  AC,  AT,  AD,  AR,  AE,  CC,  EG,  EA,  EC,  ED,  IG,  IA,  IC,  ID,\n   Eth,  NT,  OG,  OA,  OC,  OT,  OD, mul,  OS,  UG,  UA,  UC,  UD,  YA, Tho, Sha,\n    aG,  aA,  aC,  aT,  aD,  aR,  ae,  cC,  eG,  eA,  eC,  eD,  iG,  iA,  iC,  iD,\n   eth,  nT,  oG,  oA,  oC,  oT,  oD, div,  oS,  uG,  uA,  uC,  uD,  yA, yho,  yD,  \n  _nul;\n} CHAR = CHARS(\n  0x20u,0x21u,0x22u,0x23u,0x24u,0x25u,0x26u,0x27u,0x28u,0x29u,0x2au,0x2bu,0x2cu,0x2du,0x2eu,0x2fu,\n  0x30u,0x31u,0x32u,0x33u,0x34u,0x35u,0x36u,0x37u,0x38u,0x39u,0x3au,0x3bu,0x3cu,0x3du,0x3eu,0x3fu,\n  0x40u,0x41u,0x42u,0x43u,0x44u,0x45u,0x46u,0x47u,0x48u,0x49u,0x4au,0x4bu,0x4cu,0x4du,0x4eu,0x4fu,\n  0x50u,0x51u,0x52u,0x53u,0x54u,0x55u,0x56u,0x57u,0x58u,0x59u,0x5au,0x5bu,0x5cu,0x5du,0x5eu,0x5fu,\n  0x60u,0x61u,0x62u,0x63u,0x64u,0x65u,0x66u,0x67u,0x68u,0x69u,0x6au,0x6bu,0x6cu,0x6du,0x6eu,0x6fu,\n  0x70u,0x71u,0x72u,0x73u,0x74u,0x75u,0x76u,0x77u,0x78u,0x79u,0x7au,0x7bu,0x7cu,0x7du,0x7eu,0x7fu,\n  0x80u,0x81u,0x82u,0x83u,0x84u,0x85u,0x86u,0x87u,0x88u,0x89u,0x8au,0x8bu,0x8cu,0x8du,0x8eu,0x8fu,\n  0x90u,0x91u,0x92u,0x93u,0x94u,0x95u,0x96u,0x97u,0x98u,0x99u,0x9au,0x9bu,0x9cu,0x9du,0x9eu,0x9fu,\n  0xa0u,0xa1u,0xa2u,0xa3u,0xa4u,0xa5u,0xa6u,0xa7u,0xa8u,0xa9u,0xaau,0xabu,0xacu,0xadu,0xaeu,0xafu,\n  0xb0u,0xb1u,0xb2u,0xb3u,0xb4u,0xb5u,0xb6u,0xb7u,0xb8u,0xb9u,0xbau,0xbbu,0xbcu,0xbdu,0xbeu,0xbfu,\n  0xc0u,0xc1u,0xc2u,0xc3u,0xc4u,0xc5u,0xc6u,0xc7u,0xc8u,0xc9u,0xcau,0xcbu,0xccu,0xcdu,0xceu,0xcfu,\n  0xd0u,0xd1u,0xd2u,0xd3u,0xd4u,0xd5u,0xd6u,0xd7u,0xd8u,0xd9u,0xdau,0xdbu,0xdcu,0xddu,0xdeu,0xdfu,\n  0xe0u,0xe1u,0xe2u,0xe3u,0xe4u,0xe5u,0xe6u,0xe7u,0xe8u,0xe9u,0xeau,0xebu,0xecu,0xedu,0xeeu,0xefu,\n  0xf0u,0xf1u,0xf2u,0xf3u,0xf4u,0xf5u,0xf6u,0xf7u,0xf8u,0xf9u,0xfau,0xfbu,0xfcu,0xfdu,0xfeu,0xffu,\n  0x7fu);\n\n#define C(c) CHAR.c\n#define NUM2CHAR(x) (CHAR._0 + uint(x)%10u)\n#define STRLENGTH 24\n#define STRING(c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19,c20,c21,c22,c23) \\\n     C(c0),C(c1),C(c2),C(c3),C(c4),C(c5),C(c6),C(c7),C(c8),C(c9),C(c10),C(c11), \\\n     C(c12),C(c13),C(c14),C(c15),C(c16),C(c17),C(c18),C(c19),C(c20),C(c21),C(c22),C(c23)\n\n\n#define MAIN_POS vec2(0.03, 0.30)*iResolution.xy\n#define LEVELS_POS vec2(0.03, 0.03)*iResolution.xy\n\n#define FONT_SCALE min(iResolution.x,iResolution.y)/400.0\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//Controller\n\n#define CAMERA_SPEED 5./60.\n#define MOUSE_SENSITIVITY 0.2/60.\n\nbool KeyPressEvent(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,1), 0 ).x > 0.5;\n}\n\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nstruct Level\n{\n    float FracScale, FracAng1, FracAng2;\n    vec3 FracShift, FracCol; \n    vec4 MarblePos, FlagPos;\n    bool isPlanet;\n};\n\nconst int levelnum = 11;\nconst Level[] Levels = Level[]( \n//Jump the crater\nLevel(1.8, -0.12, 0.5,vec3(-2.12, -2.75, 0.49),vec3(0.42, 0.38, 0.19),\n      vec4(-2.95862, 2.68825, -1.11868, 0.035),vec4(2.95227, 2.65057, 1.11848, 0.035),false),\n//Too many trees\nLevel(1.9073f, -9.83f, -1.16f, vec3(-3.508, -3.593, 3.295),vec3(-0.34, 0.12, -0.08),\n      vec4(-3.40191, 4.14347, -3.48312, 0.04),vec4(3.40191, 4.065, 3.48312, 0.04),false),\n//Hole in one\nLevel(2.02f, -1.57f, 1.62f, vec3(-3.31f, 6.19f, 1.53f),vec3(0.12f, -0.09f, -0.09f),\n      vec4(3.18387f, 5.99466f, 0.0f, 0.009f),vec4(0.0f, -6.25f, 0.0f, 0.009f),false),\n////Around the world\n//Level(1.65f, 0.37f, 5.26f, vec3(-1.41f, -0.22f, -0.77f),vec3(0.14f, -1.71f, 0.31f),\n//      vec4(0.0f, 2.29418f, 0.0f, 0.01f),vec4(0.0f, -2.25f, 0.0f, 0.01f),true),\n//Beware Of Bumps     \nLevel(1.66f, 1.52f, 0.19f,vec3(-3.83f, -1.94f, -1.09f),vec3(0.42f, 0.38f, 0.19f),\n      vec4(0.68147f, 2.80038f, 2.52778f,0.02f),vec4(0.0f, 2.84448f, -2.71705f, 0.02f),false),\n//Mountain Climbing\nLevel(1.58f, -1.45f, 3.95f,vec3(-1.55f, -0.13f, -2.52f),vec3(-1.17f, -0.4f, -1.0f),\n      vec4(0.0f, 3.36453f, 2.28284f, 0.02f),vec4(0.0f, 3.68893f, -0.604513f, 0.02f),false),\n//Mind the gap                        \nLevel(1.81,-4.84,-2.99,vec3(-2.905, 0.765, -4.165),vec3(0.251,0.337,0.161),\n      vec4(-4.63064f, 3.8365f, 0.0f, 0.022f),vec4(4.63f, 3.61f, 0.0f, 0.022f),false),\n//The Sponge\nLevel(1.88f, 1.52f, 4.91f,vec3(-4.54f, -1.26f, 0.1f),vec3(-1.0f, 0.3f, -0.43f),\n      vec4(-2.8896f, 3.76526f, 0.0f, 0.03f),vec4(2.88924f, 3.73f, 0.0f, 0.03f),false),\n//Build Up Speed\nLevel(2.08f, -4.79f, 3.16f,vec3(-7.43f, 5.96f, -6.23f),vec3(0.16f, 0.38f, 0.15f),\n      vec4(6.06325f, 6.32712f, 0.0f, 0.023f),vec4(0.0f, 6.72f, 0.0f, 0.023f),false),\n//Around The Citadel\nLevel(2.0773f, -9.66f, -1.34f,vec3(-1.238f, -1.533f, 1.085f),vec3(0.42f, 0.38f, 0.19f),\n      vec4(1.03543f, 1.06432f, 1.22698f, 0.01f),vec4(-1.39536f, 0.641835f, 0.0f, 0.01f),false),\n//Top Of The Citadel\nLevel(2.0773f, -9.66f, -1.34f,vec3(-1.238f, -1.533f, 1.085f),vec3(0.42f, 0.38f, 0.19f),\n      vec4(1.04172f, 1.41944f, 1.09742f, 0.005f),vec4(-1.04172f, 1.414f, -1.09742f, 0.005f),false),\n//Mega Citadel\nLevel(1.4731, 0.0f, 0.0f, vec3(-10.27, 3.28, -1.90),vec3(1.17, 0.07, 1.27),\n      vec4(-0.05, 14.69, 0.02, 0.009),vec4(-14.76, 0.01, -0.00, 0.009),false)\n );\n\nint GMODE, curLVL;\n\nvoid LoadLevel(Level LVL)\n{\n    iFracScale = LVL.FracScale;\n    iFracAng1 = LVL.FracAng1;\n    iFracAng2 = LVL.FracAng2;\n    iFracShift = LVL.FracShift;\n    iFracCol = LVL.FracCol;\n    iMarblePos = LVL.MarblePos;\n    iMarbleVel = vec3(0.);\n    iFlagPos = LVL.FlagPos;\n    isPlanet = float(LVL.isPlanet);\n    \n    //set cemera to point to the flag\n    vec3 m2f = normalize(iFlagPos.xyz - iMarblePos.xyz);\n    float phi = atan(m2f.z, m2f.x);\n    float theta = acos(m2f.y);\n    ang.xy = vec2(phi - PI,PI - theta);\n    //camera distance from marble\n    radius = 10.;\n}\n\nvoid PhysicsIteration(float dt, vec3 marble_force, float frictionm)\n{\n    vec3 closest_fractal_point = closestPoint(iMarblePos.xyz);\n    vec3 dx = closest_fractal_point - iMarblePos.xyz;\n    float dist = length(dx);\n    dx = normalize(dx);\n    float onGround = step(dist, iMarblePos.w);\n    float force = ((dist < iMarblePos.w*1.14)?ground_force:air_force)*iMarblePos.w;\n    float friction =((dist < iMarblePos.w*1.14)?ground_friction:air_friction);\n    vec3 Gvec = (isPlanet==1.0)?normalize(iMarblePos.xyz):vec3(0.,1.,0);\n    //unintersect\n    iMarblePos.xyz += 0.3*onGround*dx*(dist - iMarblePos.w);\n    //momentum update\n    iMarbleVel += -marble_bounce*onGround*max(0.,dot(iMarbleVel, dx))*dx;\n\n    //update velocity\n    iMarbleVel += (-iMarblePos.w*gravity*Gvec +  frictionm*(friction - 1.0)*iMarbleVel + force*marble_force)*dt;\n    //update position\n    iMarblePos.xyz += iMarbleVel*dt;\n}\n\nvoid START(int levelid)\n{\n    levelid = levelid%levelnum;\n    timers = vec3(-3.*60., 0., iTimeDelta);\n    GMODE = GAMEMODE_GAME;\n    curLVL = levelid;\n    LoadLevel(Levels[levelid]);\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    ivec2 pi = ivec2(p);\n    if(pi.x >= NUM && pi.y >= 1) discard;\n    \n    ///Loading Data\n    c = GET_DATA(iChannel2, pi.x);\n\n    vec4 mouse = GET_DATA(iChannel2,MOUSE_);\n    vec2 mousespeed = mouse.xy;\n\n    load_scene(iChannel2, iTime, iResolution.xy);\n\n    GMODE = int(MODE/64.0);\n    curLVL = int(MODE)%64;     \n\n    //Initialization\n    if(iFrame < 5)\n    {\n      \n        START(1);\n    }\n\n    if(GMODE < GAMEMODE_GAME) //Menus\n    {\n        pang = ang;\n        ang.xy = vec2(0.2*iTime, PI*0.35);         \n        ang.y = clamp(ang.y, PI*0.01, PI*0.99);\n\n        //////////update matrix\n        cam = get_cam(ang.xy);\n\n        pcampos = campos;\n        campos = cam*vec3(-12.0, 0, 0) + vec3(0, 2, 0);\n\n        bool MB = (iMouse.w > 1.0);\n        vec2 MP = iMouse.xy;\n        \n        float font_size = FONT_SCALE;\n        if(MB)\n        {\n           \n       } \n    }\n    else //Gameplay\n    {\n        //Go into free camera mode\n        if(KeyPressEvent(KEY_F))\n        {\n            GMODE = (GMODE == GAMEMODE_FREE)?GAMEMODE_GAME:GAMEMODE_FREE;\n        }\n        if(KeyPressEvent(KEY_BSPACE))\n        {\n            GMODE = 0;\n        }\n        if(KeyPressEvent(KEY_R) || iMarblePos.y < -15.0)\n        {\n            START(curLVL);\n        }\n        if((KeyPressEvent(KEY_SPACE) && GMODE == GAMEMODE_FINISH) || KeyPressEvent(KEY_P))\n        {\n            START(curLVL+1);\n        }\n        if(KeyPressEvent(KEY_O))\n        {\n            START(abs(curLVL-1));\n        }\n\n        /////////cam update\n        pang = ang;\n        ang.xy = ang.xy + ang.zw*MOUSE_SENSITIVITY; // angle delta\n        ang.y = clamp(ang.y, PI*0.01, PI*0.99);\n        ang.zw += vec2(-1.0, 1.0)*mouse.xy; //velocity\n        ang.zw *= 0.76;\n\n        //////////update matrix\n        cam = get_cam(ang.xy);\n\n        //marble update\n        vec3 marble_force = vec3(0.);\n        float frictionm = 1.0; //friction multiplier\n\n        if(isKeyPressed(KEY_UP) || isKeyPressed(KEY_W))\n        {\n            marble_force += cam[0];\n        }\n        if(isKeyPressed(KEY_DOWN) || isKeyPressed(KEY_S))\n        {\n            marble_force -= cam[0];\n        }\n        if(isKeyPressed(KEY_RIGHT) || isKeyPressed(KEY_D))\n        {\n            marble_force += cam[1];\n        }\n        if(isKeyPressed(KEY_LEFT) || isKeyPressed(KEY_A))\n        {\n            marble_force -= cam[1];\n        }\n\n        if(GMODE == GAMEMODE_GAME)\n        {\n            #ifndef FORCE_ALONG_CAMERA\n                marble_force = vec3(marble_force.x, 0., marble_force.z);\n                marble_force = marble_force/(length(marble_force)+1e-4);\n            #endif\n\n            marble_force = marble_force/max(length(marble_force), 1.);       \n        }\n\n        if(GMODE == GAMEMODE_FINISH)\n        {\n            vec3 flagmarble = (iFlagPos.xyz + vec3(0,8.*iFlagPos.w,0) - iMarblePos.xyz)/iFlagPos.w;\n            marble_force = 2.5*normalize(flagmarble)*min(length(flagmarble), 3.); \n            frictionm = 12.;\n        }\n\n        //PHYSICS\n        #ifdef ADAPTIVE_PHYSICS_ITERATIONS\n            float iterations = clamp(10.*timers.z*60.0, 4., 32.);\n        #else\n            float iterations = 10.;\n        #endif\n        float dt = 0.1;\n        vec4 pMarblePos = iMarblePos;\n        if(GMODE == GAMEMODE_GAME || GMODE == GAMEMODE_FINISH)\n        for(float i = 0.0; i<iterations; i++)\n            PhysicsIteration((timers.x >= 0.)?dt:0.0, marble_force, frictionm);\n        \n\n        dMarblePos = iMarblePos - pMarblePos;\n\n        //update camera position\n        pcampos = campos;\n\n        if(isKeyPressed(KEY_Q))\n        {\n            radius *= 1.0 - iterations*0.002;\n        }\n        if(isKeyPressed(KEY_E))\n        {\n            radius *= 1.01 + iterations*0.002;\n        }\n\n        if(GMODE == GAMEMODE_GAME || GMODE == GAMEMODE_FINISH)\n        {\n            //camera unintersection\n            vec3 rd = -cam[0];\n            float camd =iMarblePos.w*radius;\n            vec4 ro = vec4(iMarblePos.xyz + rd*iMarblePos.w*1.03,1e8);\n            if(scene(iMarblePos.xyz + cam*vec3(-camd,0,0)).x <= iMarblePos.w*0.2)\n            { ro.w = 0.;  trace(ro,rd); camd = ro.w; }  \n            campos = iMarblePos.xyz + cam*vec3(-camd, 0, 0);\n        }\n        else\n        {\n            //reuse radius as the speed regulator\n            camvel += - camvel*0.1 + CAMERA_SPEED*iMarblePos.w*marble_force*radius/10.; \n            campos += camvel;\n        }\n\n        //Win condition\n        if(GMODE == 3 && distance(iMarblePos.xyz, iFlagPos.xyz) < iFlagPos.w*4.0) GMODE = 4;\n\n        timers = vec3(timers.x + ((GMODE == 3)?dt*iterations:0.0), 0., mix(timers.z,iTimeDelta,0.03)); \n\n    }\n\n    //////////mouse update\n    if(length(iMouse.zw - iMouse.xy) > 10.)\n    {\n        mouse.xy = iMouse.xy - c.zw; // mouse delta\n        if(iFrame < 1)\n        {\n            mouse.xy = vec2(0.);\n        }\n    }\n    else\n    {\n        mouse.xy = vec2(0.); // mouse delta\n    }\n    mouse.zw = iMouse.xy; // mouse pos\n\n    switch(pi.x)\n    {\n    case MOUSE_: \n        c = mouse;\n        break;\n    case CAM_ANGLE_:  \n        c = ang;\n        break;\n    case CAM_POS_:  \n        c.xyz = campos;\n        break;\n    case CAM_VEL_:  \n        c = vec4(camvel, 0.);\n        break;\n    case LIGHT_POS_:\n        c.xyz = vec3(0.2, 2.0, 1.5);\n        break;\n    case PCAM_ANGLE_:\n        c = pang;\n        break;\n    case PCAM_POS_:\n        c.xyz = pcampos;\n        break;\n    case PRESOLUTION_:\n        c.xy = pResolution.zw;\n        c.zw = iResolution.xy;\n        break;\n    case MARBLE_POS_:  \n        c = iMarblePos;\n        break;\n    case DMARBLE_POS_:  \n        c = dMarblePos;\n        break;      \n    case MARBLE_VEL_:  \n        c = vec4(iMarbleVel, radius);\n        break;\n    case TIMER_MODE_:  \n        c = vec4(timers, float(GMODE*64 + curLVL));\n        break;\n    case FLAG_POS_:\n        c = iFlagPos;\n        break;\n    case FRAC_PARAM1_:\n        c = vec4(iFracScale, iFracAng1, iFracAng2, isPlanet);\n        break;\n    case FRAC_PARAM2_:\n        c = vec4(iFracShift, 0.);\n        break;\n    case FRAC_PARAM3_:\n        c = vec4(iFracCol, 0.);\n        break;  \n    }   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Multiresolution ray marching/Cone marching \n//http://www.fulcrum-demo.org/wp-content/uploads/2012/04/Cone_Marching_Mandelbox_by_Seven_Fulcrum_LongVersion.pdf\n\nvec2 sResolution;\n\nvoid getRay(in vec2 p, inout vec3 ro, inout vec3 rd, float aperture)\n{\n    vec2 uv = (p  - 0.5*sResolution.xy)/sResolution.y;\n    vec4 r = vec4(0.);\n    vec2 ap = aperture*vec2(sin(TWO_PI*r.x), cos(TWO_PI*r.x))*sqrt(r.y);\n    vec3 daperture = ap.x*cam[1] + ap.y*cam[2];\n    ro = campos + daperture;\n    #ifdef AUTO_FOCUS\n        float focus = radius*iMarblePos.w;\n    #else\n        float focus = FOCAL_PLANE;\n    #endif \n    rd = normalize(focus*(cam*vec3(1, FOV*uv)) - daperture);\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    sResolution = iResolution.xy/MR_SCALE;\n    if(any(greaterThan(p, sResolution))) discard;\n    \n    rng_initialize(p, iFrame);\n    load_scene(iChannel2, iTime, sResolution);\n    CAM_ANGLE = 1.0/sResolution.y;\n    vec4 ro = vec4(0.); vec3 rd;\n    getRay(p, ro.xyz, rd, APERTURE);\n\n    trace(ro, rd);\n\n    c = vec4(ro.w);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//blue noise\nvec4 rand4blue()\n{\n    return texelFetch(iChannel1, shift2(), 0);\n}\n\nfloat SG(vec3 rd, vec3 l, float r)\n{\n    float lamb = 1.0/r;\n    float ldotr = dot(rd,normalize(l)); \n    return lamb*exp(lamb*(ldotr - 1.0))/(2.0*PI*(1. - exp(-2.0*lamb)));\n}\n\nvec3 sky(vec3 rd)\n{\n    vec3 light = vec3(1., 0., 0.)*SG(rd, iLightDir + vec3(0,.1,0), 0.01)\n               + vec3(0.067,0.000,1.000)*SG(rd, iLightDir + vec3(.1,0,0), 0.01)\n               + vec3(0.000,1.000,0.067)*SG(rd, iLightDir + vec3(0,0,.1), 0.01);\n    vec3 ambi = vec3(0.120,0.37,1.000)*SG(rd, vec3(0,-1,0), 0.6);\n    return 0.*AMBIENT*light + 6.*ambi;\n}\n\n#define LIGHT_ANGLE 0.2\n\nfloat shadowtrace(vec3 ro, vec3 rd, float maxd)\n{\n    float td = 0.;\n    //noise to remove shadow artifacts\n    float phase = rand() - 0.5;\n    float angle = 1e10;\n    for(int i = 0; i < 40; i++)\n    {\n        float de = scene(ro).x*(1. + 0.2*phase);\n        if(de < max(CAM_ANGLE*td,MIN_DIST)) {angle*= 0.0; break;}\n        if(td > maxd) break;\n        td += de; ro += rd*de;\n        angle = min(angle, de/td); \n    }\n    return smoothstep(0.02, LIGHT_ANGLE, angle);\n}\n\nfloat ambitrace(vec3 ro, vec3 rd)\n{\n    float td = 0.;\n    float angle = 1e10;\n    for(int i = 0; i < 6; i++)\n    {\n        float de = 1.2*scene(ro).x;\n        if(de < max(CAM_ANGLE*td,MIN_DIST)) {angle*= 0.0; break;}\n        td += de; ro += rd*de;\n        angle = min(angle, de/td); \n    }\n    return smoothstep(0.0, 0.35, angle);\n}\n\n\n//rendering samplers\nvoid basis(in vec3 n, out vec3 f, out vec3 r)\n{\n    if(n.z < -0.999999) {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    } else {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n}\n\nmat3 mat3FromNormal(in vec3 n)\n{\n    vec3 x; vec3 y;\n    basis(n, x, y);\n    return mat3(x,y,n);\n}\n\nvec3 ggxSample(vec3 wi, float alphax, float alphay, vec2 xi)\n{   \n    //stretch view\n    vec3 v = normalize(vec3(wi.x * alphax, wi.y * alphay, wi.z));\n\n    //orthonormal basis\n    vec3 t1 = (v.z < 0.9999) ? normalize(cross(v, vec3(0.0, 0.0, 1.0))) : vec3(1.0, 0.0, 0.0);\n    vec3 t2 = cross(t1, v);\n\n    //sample point with polar coordinates\n    float a = 1.0 / (1.0 + v.z);\n    float r = sqrt(xi.x);\n    float phi = (xi.y < a) ? xi.y / a*PI : PI + (xi.y - a) / (1.0 - a) * PI;\n    float p1 = r*cos(phi);\n    float p2 = r*sin(phi)*((xi.y < a) ? 1.0 : v.z);\n\n    //compute normal\n    vec3 n = p1*t1 + p2*t2 + v*sqrt(1.0 - p1*p1 - p2*p2);\n\n    //unstretch\n    return normalize(vec3(n.x * alphax, n.y * alphay, n.z));\n}\n\nvec2 sampleDisk(vec2 xi)\n{\n\tfloat theta = TWO_PI * xi.x;\n\tfloat r = sqrt(xi.y);\n\treturn vec2(cos(theta), sin(theta)) * r;\n}\n\nvec3 cosineHemisphere(vec2 xi)\n{\n    vec2 disk = sampleDisk(xi);\n\treturn vec3(disk.x, disk.y, sqrt(max(0.0, 1.0 - dot(disk, disk))));\n}\n\nfloat pow2(float x)\n{\n    return x*x;\n}\n\nvec3 fresnel(vec3 V, vec3 H, vec3 F0)\n{\n    return F0 + (1. - F0)*pow(1.0 - max(dot(V,H), 0.0), 5.0);\n}\n\nfloat NDF_ggx(vec3 m, vec3 n, float alpha)\n{\n    float alpha2 = alpha*alpha; \n    return alpha2/(PI*pow2( pow2(max(dot(n,m), 0.)) * (alpha2 - 1.0) + 1.0 ));\n}\n\nfloat G_ggx(float NdotV, float alpha)\n{\n    float alpha2 = alpha*alpha;\n    return 2.0*NdotV/(NdotV + sqrt( mix(NdotV*NdotV, 1.0, alpha2) ));\n}\n\nvec3 simple_shading(inout vec4 ro, vec3 rd)\n{\n    vec3 col = vec3(0.);\n    bool hit = trace(ro, rd);\n    if(hit)\n    {\n        material mat = getMaterial(ro); \n        \n        vec3 V = - rd;\n        vec3 N = mat.normal;\n        vec3 R = reflect(rd, N);\n        vec3 L = iLightDir;\n        vec3 H = normalize(V + L);\n        \n        vec3 kS = fresnel(V, N, mat.F0);\n        vec3 kD = 1.0 - kS;\n        \n        float NdotL = max(dot(N, L), 2e-3);\n        float NdotV = max(dot(N, V), 2e-3);\n        \n        #ifdef SHADOWS\n            float shadow = 0.;\n            if(NdotL > 0.0) shadow = shadowtrace(ro.xyz, iLightDir, MAX_DIST);\n        #else\n            float shadow = 0.0;\n        #endif\n        \n        float selfshadow = G_ggx(NdotL,mat.roughness)*G_ggx(NdotV,mat.roughness)/max(4.0*NdotL*NdotV,1e-3);\n        vec3 specular = selfshadow*kS*NDF_ggx(H, N, mat.roughness);  \n        \n        vec3 direct = shadow * (kD * mat.color / PI + specular) * DIRECT_BRIGHTNESS * NdotL;\n        \n        //AO\n        #ifdef AMBIENT_OCCLUSION\n            vec4 rnd = rand4blue();\n            float ambientshadow = ambitrace(ro.xyz + mat.normal*ro.w*0.001, \n                                            normalize(mat.normal + udir(rnd.xy)));\n        #else\n            float ambientshadow = 0.5 + 0.5*NdotL;\n        #endif\n        \n        \n        vec3 reflection = kS*texture(iChannel3, R).xyz;\n        vec3 ambient =AMBIENT*0.25*mat.color*(ambientshadow + reflection);\n        \n        col = ambient + direct;\n    }\n    else\n    {\n        col = AMBIENT*texture(iChannel3, rd).xyz;\n    }\n    return col;\n}\n\nvec3 pathtrace(inout vec4 ro0, vec3 rd)\n{\n    vec3 col = vec3(0.);\n    vec3 absorption = vec3(1.);\n    vec4 ro = ro0; \n    for(int i = 0; i < BOUNCES; i++)\n    {\n        float id = 0.;\n        bool hit = trace(ro, rd);\n        if(i == 0) {ro0 = ro;}\n        if(hit)\n        {\n            vec4 rnd = rand4();\n            \n            material mat = getMaterial(ro);\n            \n            float F0avg = (mat.F0.x + mat.F0.y + mat.F0.z)/3.0; \n            float IOR = (1.0 - sqrt(F0avg))/(1.0 + sqrt(F0avg));\n            \n            vec3 V = - rd;\n            vec3 N = mat.normal*mat.inside;\n            vec3 R = reflect(rd, N);\n            vec3 L = (mat.inside==1.0)?iLightDir:refract(iLightDir, mat.normal, IOR);\n            vec3 H = normalize(V + L);\n            \n            vec3 kS = fresnel(V, N, mat.F0);\n            \n            //specular probability\n            float pS = (kS.x + kS.y + kS.z)/3.0;\n            \n            mat3 basis = mat3FromNormal(N);\n            mat3 inv = inverse(basis);\n            vec3 V_local = inv*V;\n           \n            vec3 incoming = mat.emission; \n            \n            #ifdef DIRECT_LIGHT\n                float NdotL = max(dot(N, L), 2e-5);\n                float NdotV = max(dot(N, V), 2e-5);\n                \n                float selfshadowL = G_ggx(NdotL,mat.roughness)*G_ggx(NdotV,mat.roughness);\n                \n                vec3 specular = vec3(1.0)*NDF_ggx(H, N, mat.roughness)/max(4.0*NdotL*NdotV,1e-5);  \n                vec3 refracted = mat.color*((mat.transparent)?((mat.inside == 1.0)?vec3(0.):(specular)):(vec3(1.0/ PI))) ;\n                specular = selfshadowL*((mat.inside == -1.0)?vec3(0.0):specular);\n                vec3 direct = ((1. - kS)*refracted + kS*specular) * NdotL;\n                \n                float shadow = 0.;\n                vec3 rf = (mat.inside == -1.0)?(10.0*(mat.cpoint - ro.xyz)):(vec3(0.));\n                if(length(direct) > 0.005) shadow = shadowtrace(ro.xyz + rf, iLightDir, MAX_DIST);\n\n                col += absorption*DIRECT_BRIGHTNESS * shadow * direct;\n            #endif\n            \n            \n            //sample microfacet normal\n            vec3 M = ggxSample(V_local, mat.roughness, mat.roughness, rnd.xy);\n            \n            rd = reflect(-V_local, M); //new reflected ray direction\n\n            float selfshadowR = G_ggx(rd.z,mat.roughness)*G_ggx(V_local.z,mat.roughness);\n            \n            if(rnd.z < pS*selfshadowR) //specular bounce\n            {\n                absorption *= kS/pS;\n            }\n            else //diffuse/refraction bounce\n            { \n                if(mat.transparent) //refraction\n                {\n                    vec3 newrd = refract(-V_local, M, pow(IOR,mat.inside));\n                    if(length(newrd) > 0.5) //not total internal reflection\n                    {\n                        absorption *= mat.color;\n                        rd = newrd;\n                        //reflect point inside\n                        ro.xyz = ro.xyz + 10.0*(mat.cpoint - ro.xyz);\n                    }\n                }\n                else //diffuse\n                { \n                    absorption *= mat.color;\n                    rd = cosineHemisphere(rnd.xy);  \n                }  \n            }\n            \n            col += absorption*incoming;\n            \n            if((absorption.x + absorption.y + absorption.z) < 0.03) break; \n          \n            \n           \n            rd = basis*rd; //return ray direction into world space\n        }\n        else\n        {\n            #ifdef DIRECT_LIGHT\n            float ambient = AMBIENT*0.5;\n            #else\n            float ambient = AMBIENT;\n            #endif\n            col += absorption*sky(rd);\n            break;\n        }\n        \n    }\n    return col;\n}\n\nvoid getRay(in vec2 p, inout vec3 ro, inout vec3 rd, float aperture)\n{\n    vec2 uv = (p  - 0.5*iResolution.xy)/iResolution.y;\n    vec4 r = rand4blue();\n    vec2 ap = aperture*vec2(sin(TWO_PI*r.x), cos(TWO_PI*r.x))*sqrt(r.y);\n    vec3 daperture = ap.x*cam[1] + ap.y*cam[2];\n    ro = campos + daperture;\n    #ifdef AUTO_FOCUS\n        float focus = radius*iMarblePos.w;\n    #else\n        float focus = FOCAL_PLANE;\n    #endif\n    \n    rd = normalize(focus*(cam*vec3(1, FOV*uv)) - daperture);\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    rng_initialize(p, iFrame);\n    load_scene(iChannel2, iTime, iResolution.xy);\n    \n    vec4 col = vec4(0.);\n    \n    float td_PREV = texelFetch(iChannel0, ivec2(p/MR_SCALE), 0).x;\n    \n    vec4 ro = vec4(0.); vec3 rd; \n    vec2 jitter = halton(iFrame%16) - 0.5; \n    getRay(p + jitter, ro.xyz, rd, APERTURE);\n    \n    ro += vec4(rd, 1.0)*td_PREV;\n    \n    #ifdef PATH_TRACING\n        col += vec4(pathtrace(ro, rd), 1.0);\n    #else\n        col += vec4(simple_shading(ro, rd), 1.0);\n    #endif\n\n    c.xyz =min(col.xyz/col.w, 1000.0);\n    c.w = distance(ro.xyz, campos);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//TAA\n\nvec3 encodePalYuv(vec3 rgb)\n{\n    return vec3(\n        dot(rgb, vec3(0.299, 0.587, 0.114)),\n        dot(rgb, vec3(-0.14713, -0.28886, 0.436)),\n        dot(rgb, vec3(0.615, -0.51499, -0.10001))\n    );\n}\n\nvec3 decodePalYuv(vec3 yuv)\n{\n    return vec3(\n        dot(yuv, vec3(1., 0., 1.13983)),\n        dot(yuv, vec3(1., -0.39465, -0.58060)),\n        dot(yuv, vec3(1., 2.03211, 0.))\n    ); \n}\n\nbool KeyPressEvent(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,1), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    rng_initialize(p, iFrame);\n    load_scene(iChannel2, iTime, iResolution.xy);\n    vec2 jitter = halton(iFrame%16) - 0.5; \n    vec4 bufB = texture(iChannel0, (p-jitter)/iResolution.xy);\n    \n    vec4 col = vec4(bufB.xyz, 1.);\n    \n    vec2 uv = (p  - 0.5*iResolution.xy)/iResolution.y;\n    vec4 ro = vec4(campos, bufB.w);    \n    vec3 rd = normalize(cam*vec3(1, FOV*uv));\n    ro.xyz += ro.w*rd;\n    vec4 X = ro;\n    material mat = getMaterial(X);\n    ro.xyz -= mat.velocity;\n    \n    vec3 reprj = reproject(pcam, pcampos, pResolution.xy, ro.xyz);\n    vec2 puv = reprj.xy/iResolution.xy;\n    vec2 dpuv = abs(puv - vec2(0.5));\n\n    vec3 prev_col = abs(texture_Bicubic(iChannel1, puv).xyz);\n    \n    //neighborhood clamping\n    vec3 minc = vec3(1e10); \n    vec3 maxc = vec3(0.);\n    for(int i = -NEIGHBOR_CLAMP_RADIUS; i < NEIGHBOR_CLAMP_RADIUS; i++)\n        for(int j = -NEIGHBOR_CLAMP_RADIUS; j < NEIGHBOR_CLAMP_RADIUS; j++)\n    {\n        vec3 pix = encodePalYuv(texelFetch(iChannel0, ivec2(p) + ivec2(i,j), 0).xyz);\n        minc = min(pix, minc);\n        maxc = max(pix, maxc);\n    }\n    \n    vec3 preclamp = encodePalYuv(prev_col);\n    //prev_col = clamp(preclamp, minc, maxc);\n    //prev_col = mix(preclamp, prev_col, 0.9);\n    float delta = distance(prev_col, preclamp);\n    //prev_col = decodePalYuv(prev_col);\n     \n    \n    vec2 v = decode(texelFetch(iChannel1, ivec2(puv*iResolution.xy), 0).w);\n    \n    vec4 prev = vec4(prev_col, 1.0)*v.y/0.02;\n    float prev_td = 4.0/v.x;\n    \n    vec3 prev_pos = normalize(ro.xyz - pcampos)*prev_td + pcampos;\n    float ang_distance = distance(normalize(prev_pos - campos),normalize(ro.xyz - campos));\n    \n    if(iFrame < 2) prev*=0.0;\n    //prev*=mix(1.0, smoothstep(0.6, 0.5, delta), 0.1);\n    prev*=mix(1.0, step(ang_distance, DISOCCLUSION_REJECTION), DISOCCLUSION_REJECTION_STR);\n    float dist = distance(prev.xyz/prev.w, col.xyz/col.w);\n    prev*=mix(1.0, smoothstep(CAMERA_MOVEMENT_REJECTION, 0., distance(campos, pcampos)),0.14);\n    if(KeyPressEvent(KEY_M)) prev*= 0.0;\n\n    //prev*=mix(1.0, smoothstep(0.7, 0.6, dist),1.0);\n    col += prev*REPROJECTION*step(dpuv.x, 0.5)*step(dpuv.y, 0.5); \n    \n    c.xyz = col.xyz/col.w;\n    c.w = encode(vec2(4.0/ro.w, 0.02*col.w));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}