{
    "Shader": {
        "info": {
            "date": "1620573989",
            "description": "duality for:\n\nhttps://www.twitch.tv/sableraph",
            "flags": 0,
            "hasliked": 0,
            "id": "7dBXzV",
            "likes": 6,
            "name": "duality for twitch.tv/sableraph",
            "published": 3,
            "tags": [
                "spiral",
                "signeddistance",
                "ornament"
            ],
            "usePreview": 0,
            "username": "morisil",
            "viewed": 311
        },
        "renderpass": [
            {
                "code": "// check out https://www.twitch.tv/sableraph\n// sableraph is posting creative coding chanllange every week and then review\n// sketches on the stream every Sunday. This time the topic was \"duality\"\n\n// Some comments:\n\n// I like that using trigonometric shapes is reducing the need of antialiasing whatsover\n\n// I started with grayscale, but then decided to apply distance based and angular\n// based chromatic abberration, which gives more video synthesis-like aesthetics\n// Maybe my childhood CRT experience makes me love vaporwave aesthetics so much :)\n\n\n#define SCALE                  70.0\n#define ROTATION_SPEED         -1.\n#define DISTANCE_SPREAD        -.02\n#define ANGLE_SPREAD           .1\n#define SHAPE_RANGE            2.\n#define OSCILLATION_SPEED      .15\n#define OSCILLATION_AMPLITUDE  .2\n#define MIRROR_TRUE            1.\n#define MIRROR_FALSE           -1.\n\n\nfloat getColorComponent(float dist, float angle, float mirror) {\n    return clamp(\n        sin(\n            (dist * SCALE)\n                + angle * mirror\n                + (cos(dist * SCALE))\n                - (iTime * ROTATION_SPEED) * mirror\n        )\n        - dist * SHAPE_RANGE\n        ,0. // try putting small negative value here, like -.2 :)\n        ,1.\n    );\n}\n\nvec3 getSwirl(vec2 center, float dist, float mirror) {\n    float angle = atan(center.x, center.y);\n    return vec3(\n        getColorComponent(dist * (1. - DISTANCE_SPREAD), angle - ANGLE_SPREAD, mirror),\n        getColorComponent(dist * (1. + 0.)             , angle - 0.          , mirror),\n        getColorComponent(dist * (1. + DISTANCE_SPREAD), angle + ANGLE_SPREAD, mirror)\n    );    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    vec2 oscillation = vec2(\n        sin(iTime * OSCILLATION_SPEED),\n        0.\n    ) * OSCILLATION_AMPLITUDE;\n    vec2 uv1 = uv + oscillation;\n    vec2 uv2 = uv - oscillation;\n    float dist1 = length(uv1);\n    float dist2 = length(uv2);\n    vec3 color =\n        getSwirl(uv1, dist1, MIRROR_TRUE)\n        + getSwirl(uv2, dist2, MIRROR_FALSE);\n    fragColor = vec4(color, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}