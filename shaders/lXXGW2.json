{
    "Shader": {
        "info": {
            "date": "1707921762",
            "description": "This effect was provided several years ago to a private VTuber, \"徳川ゆめの\". Upon her retirement, we decided to distribute it under CC BY 4.0.",
            "flags": 0,
            "hasliked": 0,
            "id": "lXXGW2",
            "likes": 3,
            "name": "macaroonia..",
            "published": 3,
            "tags": [
                "fbm",
                "cloud",
                "macaroon"
            ],
            "usePreview": 0,
            "username": "IWBTShyGuy",
            "viewed": 121
        },
        "renderpass": [
            {
                "code": "// Copyright © 2021 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n/******************* Config *******************/\n\nconst vec3 BACK_GROUND = vec3(70, 13, 67) / 255.0;\nconst vec3 CLOUD_COLOR0 = vec3(235, 200, 220) / 255.0;\nconst vec3 CLOUD_COLOR1 = vec3(235, 119, 159) / 255.0;\nconst vec3 LIGHT_COLOR = vec3(1.0, 0.8, 0.9);\nconst float UP_VELO = 0.1;\nconst float MEAN_ROT_VELO = 1.0;\nconst float MACAROON_SIZE = 1.0 / 6.0;\nconst float MACAROON_RATIO = 0.8;\nconst float NEAR = 2.0;\nconst float FAR = 5.0;\n\n/******************* 3D Toolkit *******************/\nconst float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float h = tan(camera.fov * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\nmat3 rot(vec3 axis, float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat3(\n        axis[0] * axis[0] * (1.0 - c) + c,\n        axis[0] * axis[1] * (1.0 - c) + axis[2] * s,\n        axis[0] * axis[2] * (1.0 - c) - axis[1] * s,\n        axis[0] * axis[1] * (1.0 - c) - axis[2] * s,\n        axis[1] * axis[1] * (1.0 - c) + c,\n        axis[1] * axis[2] * (1.0 - c) + axis[0] * s,\n        axis[0] * axis[2] * (1.0 - c) + axis[1] * s,\n        axis[1] * axis[2] * (1.0 - c) - axis[0] * s,\n        axis[2] * axis[2] * (1.0 - c) + c\n    );\n}\n\nfloat microfacet(vec3 normal, vec3 cameraDir, vec3 lightDir, float metal, float roughness) {\n    vec3 middle = normalize(cameraDir + lightDir);\n    float dotCN = clamp(-dot(cameraDir, normal), 0.0, 1.0);\n    float dotLN = clamp(-dot(lightDir, normal), 0.0, 1.0);\n    float dotNM = clamp(-dot(normal, middle), 0.0, 1.0);\n    float dotCM = clamp(dot(cameraDir, middle), 0.0, 1.0);\n    float alpha = roughness * roughness;\n    \n    // diffuse BRDF\n    float diffuse = 1.0 - metal;\n    \n    // microfacet distribution\n    float alpha2 = alpha * alpha;\n    float tmp = 1.0 - dotNM * dotNM * (1.0 - alpha2);\n    float distribution = alpha2 / (tmp * tmp);\n\n    // schlick approxy & geometric decay\n    float alp = alpha * 0.5;\n    float sal = dotLN / (dotLN * (1.0 - alp) + alp);\n    float sac = dotCN / (dotCN * (1.0 - alp) + alp);\n    float decay = sal * sac;\n\n    // fresnel\n    float c = 1.0 - dotCM;\n    c = c * c * c * c * c;\n    float fresnel = metal + (1.0 - metal) * c;\n\n    // specular BRDF\n    tmp = 4.0 * dotCN * dotLN;\n    float specular = distribution * decay / tmp * fresnel;\n    if (tmp < 0.0001) specular = 0.0;\n    \n    return (diffuse + specular) * dotLN;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCylinder( vec3 p, vec2 rh ) { return length(max(rh=abs(vec2(length(p.xz),p.y))-rh,0.))+min(max(rh.x,rh.y),0.); }\nfloat sdCylinder( vec3 p, float r, float h ) { return sdCylinder(p, vec2(r,h)); }\n\n/******************* Hash *******************/\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n#define DEFINE_THREE_DIM_NOISE(type, noise, smoothnoise, hash) \\\ntype noise(vec3 p) { \\\n    vec3 t = fract(p); \\\n    p = floor(p) + vec3(1.465, -0.593, 2.1985); \\\n    vec2 e = vec2(0, 1); \\\n    return mix( \\\n        mix( \\\n            mix(hash(p + e.xxx), hash(p + e.yxx), t.x), \\\n            mix(hash(p + e.xyx), hash(p + e.yyx), t.x), \\\n            t.y \\\n        ), \\\n        mix( \\\n            mix(hash(p + e.xxy), hash(p + e.yxy), t.x), \\\n            mix(hash(p + e.xyy), hash(p + e.yyy), t.x), \\\n            t.y \\\n        ), \\\n        t.z \\\n    ); \\\n}\n\nDEFINE_THREE_DIM_NOISE(float, noise13, smoothnoise13, hash13)\nDEFINE_THREE_DIM_NOISE(vec3, noise33, smoothnoise33, hash33)\n\n#define DEFINE_FBM(fbm, noise, type0, type1, numOctaves) \\\ntype0 fbm( in type1 x, in float H ) { \\\n    float G = exp2(-H); \\\n    float f = 1.0; \\\n    float a = 1.0; \\\n    type0 t = type0(0.0); \\\n    for( int i=0; i<numOctaves; i++ ) { \\\n        t += a*noise(f*x); \\\n        f *= 2.0; \\\n        a *= G; \\\n    } \\\n    return t; \\\n}\n\nDEFINE_FBM(fbm135, noise13, float, vec3, 5)\nDEFINE_FBM(fbm333, noise33, vec3, vec3, 3)\n\n/******************* Macaroon *******************/\nfloat sdMacaroon(in vec3 p) {\n    float dist = max(0.025 - abs(p.y), sdCylinder(p, 0.3, 0.025) - 0.2);\n    dist = min(dist, sdCylinder(abs(p) - vec3(0, 0.05, 0), 0.5, 0.0) - 0.025);\n    dist = min(dist, sdCylinder(p, 0.45, 0.0) - 0.025);\n    return dist;\n}\n\nvec3 normalMacaroon(in vec3 p) {\n    float len = length(p.zx);\n    const vec2 e = vec2(0.0001, 0);\n    vec3 normal = normalize(vec3(\n        sdMacaroon(p + e.xyy) - sdMacaroon(p - e.xyy),\n        sdMacaroon(p + e.yxy) - sdMacaroon(p - e.yxy),\n        sdMacaroon(p + e.yyx) - sdMacaroon(p - e.yyx)\n    ));\n    if (len > 0.499 || abs(p.y) < 0.07) {\n        if (len > 0.499 || abs(p.y) > 0.023) {\n            vec3 disp = 2.0 * fbm333(p * 10.0, 0.0) / 4.0 - 1.0;\n            normal = normalize(normal + disp * 0.5);\n        }\n    } else {\n        vec3 disp = 2.0 * fbm333(p * 10.0, 0.0) / 4.0 - 1.0;\n        normal = normalize(normal + disp * 0.1);\n    }\n    return normal;\n}\n\nvec3 colMacaroon(in vec3 p, in vec3 normal, in Ray ray, in float t, in vec3 albedo) {\n    float len = length(p.zx);\n    if (abs(p.y) < 0.024) {\n        float c = microfacet(\n            normal,\n            ray.direction,\n            ray.direction,\n            0.02,\n            0.8\n        );\n        return c * vec3(0.9);\n    } else if (len > 0.499) {\n        float c = microfacet(\n            normal,\n            ray.direction,\n            ray.direction,\n            0.02,\n            1.0\n        );\n        return c * albedo;\n    } else {\n        float c = microfacet(\n            normal,\n            ray.direction,\n            ray.direction,\n            0.1,\n            0.5\n        ) * 0.8;\n        c += microfacet(\n            normal,\n            ray.direction,\n            normalize(p - vec3(-1.0, 2.0, 0.0)),\n            0.1,\n            0.5\n        ) * 1.0;\n        return c * albedo;\n    }\n}\n\nmat3 rotateMacaroon(in vec3 p, in float t) {\n    float velo = hash13(floor(p)) * MEAN_ROT_VELO * 2.0;\n    return rot(vec3(0, 0, 1), 0.28) * rot(vec3(0, 1, 0), velo * (t + 120.635));\n}\n\nvec3 cellPosition(in vec3 p, in float t) {\n    mat3 mat = rotateMacaroon(p, t);\n    vec3 maxDisp = vec3(0.2, 0.4, 0.2);\n    vec3 disp = hash33(floor(p)) * maxDisp * 2.0 - maxDisp;\n    p = (fract(p) - 0.5 + disp) / MACAROON_SIZE;\n    return mat * p;\n}\n\nfloat cellDist(in vec3 p, in vec3 q, in float t) {\n    mat3 mat = rotateMacaroon(q, t);\n    float a = hash13(floor(q));\n    if (a < 1.0 - MACAROON_RATIO) return 1.0;\n    vec3 diff = p - q;\n    q = cellPosition(q, t);\n    p = q + mat * diff / MACAROON_SIZE;\n    return sdMacaroon(p) * MACAROON_SIZE;\n}\n\nfloat sDist(in vec3 p, in vec3 dir, in float t) {\n    p -= vec3(0, t, 0) * UP_VELO;\n    float dist = cellDist(p, p, t);\n    if (floor(p + dist * dir) != floor(p)) {\n        dist = min(dist, cellDist(p, p + dist * dir, t));\n    }\n    return dist;\n}\n\nvec3 calcNormal(in vec3 p, in vec3 dir, in float t) {\n    p -= vec3(0, t, 0) * UP_VELO;\n    mat3 mat = rotateMacaroon(p, t);\n    return transpose(mat) * normalMacaroon(cellPosition(p, t));\n}\n\nvec3 calcColor(in vec3 p, in vec3 normal, in Ray ray, in float t) {\n    p -= vec3(0, t, 0) * UP_VELO;\n    vec3 albedo = hash33(floor(p));\n    p = cellPosition(p, t);\n    return colMacaroon(p, normal, ray, t, albedo);\n}\n\nvoid macaroons0(out vec4 fragColor, in vec2 fragCoord) {\n    Camera camera = Camera(\n        vec3(0, 0, 0),\n        normalize(vec3(0.1, 0, -1)),\n        vec3(0, 1, 0),\n        PI / 4.0,\n        iResolution.x / iResolution.y\n    );\n    Ray ray = cameraRay(camera, fragCoord / iResolution.xy);\n\n    float dist = -NEAR / ray.direction.z;\n    vec3 p = ray.origin + dist * ray.direction;\n    for (int _i = 0; _i < 100; _i++) {\n        float dist0 = sDist(p, ray.direction, iTime);\n        if (dist0 < 0.00001 || -p.z > FAR) break;\n        dist += dist0;\n        p = ray.origin + dist * ray.direction;\n    }\n\n    vec3 col = pow(BACK_GROUND, vec3(2.2));\n    if (-p.z < FAR) {\n        vec3 normal = calcNormal(p, ray.direction, iTime);\n        col = calcColor(\n            p,\n            normal,\n            ray,\n            iTime\n        ) * pow(LIGHT_COLOR, vec3(2.2)) * 0.7;\n    }\n\n    fragColor = vec4(pow(col, vec3(0.4545)), 1);\n}\n\n#define AA 2\nvoid macaroons(out vec4 O, vec2 U) {\n    macaroons0(O,U);\n    \n// smart anti-aliasing\n// reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\n// If defined, visualize anti-aliased pixels.\n//#define VISUALIZE_AA\n#ifdef AA\n    if (fwidth(length(O.xyz)) > 0.1) {\n\n        O.xyz = pow(O.xyz, vec3(2.2));\n        vec4 o;\n#if (AA == 2)\n        for (int k = 0; k < 4; k++) {\n              macaroons0(o,U + (vec2(k % 2, k / 2) - 0.5) / 1.5);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 5.0;\n#elif (AA == 3)\n        for (int k = 0; k < 9; k += k == 3 ? 2 : 1 ) {\n              macaroons0(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.0);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 9.0;\n#endif\n#ifdef VISUALIZE_AA\n        O = vec4(1);\n    } else {\n        O = vec4(0,0,0,1);\n#endif\n        O.xyz = pow(O.xyz, vec3(0.4545));\n    }\n#endif\n    O.w = 1.0;\n}\n\nfloat stars(in vec2 uv) {\n    uv *= 20.0;\n    float p = hash12(floor(uv) + vec2(1.235, -0.925));\n    if (p < 0.6) return 0.0;\n    vec2 disp = hash22(floor(uv)) * 0.5 - 0.25;\n    float dist = length(fract(uv) - 0.5 + disp);\n    float c = clamp(1.0 - dist / 0.1, 0.0, 1.0);\n    return c * c;\n}\n\nfloat densityCloud(in vec3 p) {\n    //return 0.1 - length(p) + fbm135(p * 0.3, 0.0) / 6.0;\n    return -p.y * 0.2 + fbm135(p * 0.1, 0.0) / 7.5;\n}\n\nfloat cloudEffect(in vec2 fragCoord) {\n    Camera camera = Camera(\n        vec3(0, 8.0, -iTime),\n        vec3(0, -0.1, -1),\n        vec3(0, 1, 0),\n        PI / 4.0,\n        iResolution.x / iResolution.y\n    );\n    Ray ray = cameraRay(camera, fragCoord / iResolution.xy);\n    if (ray.direction.y > -0.1) return 0.0;\n\n    const float FAR = 40.0;\n    const int SAMPLE = 48;\n    const float LIGHT_FAR = 20.0;\n    const int LIGHT_SAMPLE = 4;\n    float c = 0.0;\n    float trans = 1.0; // transmittance\n    for (int i = 0; i < SAMPLE; i++) {\n        float t = FAR * float(i) / float(SAMPLE);\n        vec3 p = ray.origin + t * ray.direction;\n        float density = densityCloud(p);\n        if (density > 0.0) {\n            float tmp = density / float(SAMPLE);\n            trans *= 1.0 - tmp * 100.0;\n            if (trans < 0.01) break;\n            float transLight = 1.0;\n            float decay = smoothstep(0.0, 1.0, t / FAR);\n            decay *= decay;\n            float opaity = 150.0;\n            float c0 = opaity * tmp * trans;\n            c += c0 * (1.0 - decay);\n        }\n    }\n    return min(c, 1.0);\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    macaroons(O, U);\n\n    O.xyz = pow(O.xyz, vec3(2.2));\n    float c = cloudEffect(U);\n    float c0 = clamp(c / 0.3, 0.0, 1.0);\n    O.xyz = (1.0 - c0) * O.xyz\n        + 2.0 * (1.0 - c) * c * pow(CLOUD_COLOR1, vec3(2.2))\n        + 0.5 * c * c * pow(CLOUD_COLOR0, vec3(2.2));\n    O.xyz = pow(O.xyz, vec3(0.4545));\n\n    if (length(O.xyz - BACK_GROUND) < 0.01) {\n        float star = stars(U / iResolution.y);\n        O.xyz = clamp(O.xyz * (1.0 - star) + star * 0.6, 0.0, 1.0);\n    }\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}