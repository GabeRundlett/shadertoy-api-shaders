{
    "Shader": {
        "info": {
            "date": "1723181564",
            "description": "origianals  https://glslsandbox.com/e#81778.0 https://www.shadertoy.com/view/tdKcWh",
            "flags": 0,
            "hasliked": 0,
            "id": "4c2cDd",
            "likes": 1,
            "name": "warp tunnel 3",
            "published": 3,
            "tags": [
                "tunnel",
                "warp"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 65
        },
        "renderpass": [
            {
                "code": "#define time iTime\n#define resolution  iResolution.xy\n#define PI 3.1415926535897932384626433832795\n\n#define ITER 50\n\nvec2 rotate(vec2 p, float a)\n\t{\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n\t}\n\n#define mod01 floor(mod(time * 4.0, 16.0))\n#define mod02 floor(mod(time * 2.0, 8.0))\n\nfloat gg = 0.0;\n\nmat2 rot(float a)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca, sa, -sa, ca);\n}\n\nstruct matter\n{\n \tfloat m;\n    int type;\n    bool reflected;\n};\n    \nfloat box(vec3 p, vec3 s)\n{\n\tp = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\n\nfloat sphere(vec3 p, float s)\n{\n\t\n    return length(p) - s;\n}\n\nvec3 kifs(vec3 p)\n{\n    float t1 = 0.5 + (time * 0.1 * 0.25);\n    float s = 2.0;\n    \n    for(int i = 0; i < 4; ++i)\n    {\n     \tp.yz *= rot(t1 + float(i) * 0.1);\n        p.yz = abs(p.xz);\n        p.yz -= s;\n    }\n    \n    \n    \n    return p;\n}\n\nvoid map(inout matter mat, vec3 p)\n{\n\tfloat mat01, mat02, mat03;\n    \n   \n    \n    \n    \n    p.xz *= rot(time * 0.2) * 1.05;\n    p.yz *= rot(time * 0.15) * 1.15;\n    p.xy *= rot(time * 0.05);\n    \n    vec3 p01 = p, p02 = p, p03 = p, p04 = kifs(p);\n    \n    mat02 = box(p, vec3(0.55 + 0.45 * abs(sin(time * 0.25))));\n    //mat02 = min(mat02, -box(p, vec3(3.5)));\n    \n    if(mat02 < 0.01)\n    {\n     \tmat.type = 1;   \n    }\n    \n    if(mod(mod02, 4.0) <= 1.0)\n    \tmat01 = box(p, vec3(1.05 + 0.10 * mod02));\n    if(mod(mod02, 4.0) > 1.0)\n        mat01 = sphere(p, 1.05 + 0.10 * mod02);\n    \n    float rep01 = 0.45;\n    \n    p02.y = (fract(abs(p04.y + time * 0.05) / rep01 - 0.5) - 0.5) * rep01;\n    float id = (floor(abs(p.y) / rep01 - 0.5) - 0.5) * rep01 * (16.0 * abs(sin(time * 0.5)));\n    \n    p03.y = (fract(abs(p04.y + time * 0.05) / rep01 - 0.5) - 0.5) * rep01;\n    float id02 = (floor(abs(p.y) / rep01 - 0.5) - 0.5) * rep01 * (16.0 * abs(sin(time * 0.5)));\n    \n   \t/*p02.xz *= rot(time * 0.2);\n    p02.yz *= rot(time * 0.1);\n    p02.xy *= rot(time * 0.1);*/\n    \n    mat01 = max(mat01, -box(p02 - vec3(0.5 * sin(p.x * 0.2), 0.0, 0.0), vec3(10.0, 0.15 + (sin(p.x * 0.1 * id * mod01) * 0.25) + (sin(p.z * 0.1) * 0.25), 10.0)));\n    \n    mat01 = max(mat01, -box(p02 - vec3(0.0, 0.0, 0.0), vec3(0.15 + (sin(p.z * 0.1 * id * mod01) * 0.25) + (sin(p.z * 0.1) * 0.25),10.0, 10.0)));\n    \n    \n    gg += 0.15/(0.11+abs(mat01));\n    \n    mat.m = min(mat01, mat02);\n}\n\nvec3 normals(vec3 p)\n{\n \tvec2 uv = vec2(0.01, 0.0);\n    \n    matter m01,m02,m03,m04;\n    \n    map(m01, p);\n    map(m02, p - uv.xyy);\n    map(m03, p - uv.yxy);\n    map(m04, p - uv.yyx);\n    \n    return normalize(m01.m - vec3(m02.m, m03.m,m04.m));\n}\n\nvec2 circuit(vec2 p)\n\t{\n\tp = fract(p);\n\tfloat r = 0.523;\n\tfloat v = 0.0, g = 0.0;\n\tfloat test = 0.0;\n\tr = fract(r * 9184.928);\n\tfloat cp, d;\n\t\n\td = p.x;\n\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 160.0);\n\td = p.y;\n\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 160.0);\n\td = p.x - 1.0;\n\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 160.0);\n\td = p.y - 1.0;\n\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 280.0);\n\t\n\tfor(int i = 0; i < ITER; i ++)\n\t\t{\n\t\tcp = 0.5 + (r - 0.5) * 1.5;\n\t\td = p.x - cp;\n\t\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 160.0);\n\t\tif(d > 0.0)\n\t\t\t{\n\t\t\tr = fract(r * 14829.013);\n\t\t\tp.x = (p.x - cp) / (1.0 - cp);\n\t\t\tv += 1.0;\n\t\t\ttest = r;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tr = fract(r * 1239.528);\n\t\t\tp.x = p.x / cp;\n\t\t\ttest = r;\n\t\t\t}\n\t\tp = p.yx;\n\t\t}\n\tv /= float(ITER);\n\treturn vec2(v, g);\n\t}\n\nfloat box(vec2 p, vec2 b, float r)\n\t{\n\treturn length(max(abs(p) - b, 0.0)) - r;\n\t}\n\nfloat rand(float p)\n\t{\n\treturn fract(sin(p * 591.32) * 43758.5357);\n\t}\n\nfloat rand2(vec2 p)\n\t{\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5357);\n\t}\n\nvec2 rand2(float p)\n\t{\n\treturn fract(vec2(sin(p * 591.32), cos(p * 391.32)));\n\t}\n\nvec3 sky(vec3 rd, float t)\n\t{\n\tfloat u = atan(rd.z, rd.x) / PI / 2.0;\n\tfloat v = rd.y / length(rd.xz);\n\tfloat fg = exp(-0.04 * abs(v));\n\tvec2 ca = circuit(vec2(u, (v - t * 3.0) * 0.03));\n\tvec2 cb = circuit(vec2(-u, (v - t * 4.0) * 0.06));\n\tfloat c = (ca.x - ca.y * 0.2) + cb.y * 0.7;\n\tvec3 glow = pow(vec3(c), vec3(0.18, 0.4, 1.0) * 3.0);\n\tvec2 cr = vec2(u, (v - t * 5.0) * 0.03);\n\tfloat crFr = fract(cr.y);\n\tfloat r = smoothstep(0.8, 0.82, abs(crFr * 2.0 - 1.0));\n\tfloat vo = 0.0, gl = 0.0;\n\tfor(int i = 0; i < 6; i ++)\n\t\t{\n\t\tfloat id = float(i);\n\t\tvec2 off = rand2(id);\n\t\tvec2 pp = vec2(fract(cr.x * 5.0 + off.x + t * 8.0 * (0.5 + rand(id))) - 0.5, fract(cr.y * 12.0 + off.y * 0.2) - 0.5);\n\t\tfloat di = box(pp, vec2(0.2, 0.01), 0.02);\n\t\tvo += smoothstep(0.999, 1.0, 1.0 - di);\n\t\tgl += exp(max(di, 0.0) * -60.0);\n\t\t}\n\tvo = pow(vo * 0.4, 2.0);\n\tvec3 qds = vec3(1.0);\n\tvec3 col = mix(glow, qds, clamp(vo, 0.0, 1.0)) + vec3(0.0, 0.5, 1.0) * gl * 0.5;\n\treturn col + (1.0 - fg);\n\t}\n\nvec3 colorset(float v)\n\t{\n\treturn pow(vec3(v), vec3(0.2, 0.4, 1.0) * 2.0);\n\t}\n\n\n\nvec3 pixel(vec2 uv)\n\t{\n\tuv /= resolution.xy;\n\tuv = uv * 2.0 - 1.0;\n\tuv.x *= resolution.x / resolution.y;\n \n\tvec3 ro = vec3(0.0, 0.0, -0.0);\n\tvec3 rd = normalize(vec3(uv,0.076));\n\tfloat t = time* 0.5;\n\trd.yz = rotate(rd.yz,90.);\n\n\tvec3 col = sky(rd, t * 0.7);\n\treturn pow(col, vec3(2.5)) * 1.3;\n\t}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\t{\n\tvec2 uv = gl_FragCoord.xy;\n\tvec3 col;\n\tvec2 h = vec2(0.1, 0.0);\n\tuv += rand2(time) * 1.0;\n\tcol = pixel(uv);\n\tcol += pixel(uv + h.xy);\n\n   // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv2 = fragCoord/iResolution.xy-0.35;\n      \n    uv2*=4.;\n   \n    uv2 -= 0.5;\n    uv2.x+=cos(iTime);\n      uv2.y+=sin(iTime);\n    uv2 /= vec2(iResolution.y/iResolution.x, 1.0);\n    \n   // Normalized pixel coordinates (from 0 to 1)\n\n    \n    vec3 o = vec3(0.0, 0.0, 4.0+cos(iTime)), t= vec3(0.0);\n    vec3 fr = normalize(t-o);\n    vec3 ri = normalize(cross(vec3(0.0, 1.0, 0.0), fr));\n    vec3 up = normalize(cross(fr, ri));\n    vec3 dir = normalize(fr + uv2.x * ri + uv2.y * up);\n    vec3 p = o + dir * 0.5;\n    \n   \tmatter mat;\n    vec3 col2 = vec3(0.0);\n    for(int i = 0; i < 150; ++i)\n    {\n        //p.xy *= rot(0.001);\n        \n     \tmap(mat, p);\n        \n        if(mat.m < 0.01)\n        {\n            if(mat.type == 1)\n            {\n                vec3 n = normals(p);\n                dir = reflect(dir, -n);\n                \n                mat.m = 0.15;\n                mat.type = 0;\n                mat.reflected = true;\n            }\n         \tmat.m = 0.1;\n        }\n        \n        if(mod(mod02, 4.0) <= 1.0)\n        \tcol2 += gg * 0.00030 * vec3(0.0, 0.5, 1.0);\n        if(mod(mod02, 4.0) > 1.0)\n        \tcol2 += gg * 0.00030 * vec3(1.0, 0.5, 0.0);\n        \n        p += dir * mat.m * 0.5;\n    }\n\n\tcol /= 4.0;\n\tfragColor = vec4(col*vec3(0.2,0.2,3.)+col2, 1.0);\n\t}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}