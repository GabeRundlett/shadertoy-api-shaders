{
    "Shader": {
        "info": {
            "date": "1699545994",
            "description": "Hireth. A shader for the composer David Julyan [url]https://davidjulyan.bandcamp.com/album/hireth[/url]\n\nThe house appears as distant smoke at first at 190s\n\nSorry of you GPU in screaming at you. I wanted it to be glitch free.\n\n",
            "flags": 112,
            "hasliked": 0,
            "id": "ddGyWV",
            "likes": 37,
            "name": "Hireth",
            "published": 3,
            "tags": [
                "hireth"
            ],
            "usePreview": 0,
            "username": "Dave_Hoskins",
            "viewed": 498
        },
        "renderpass": [
            {
                "code": "// Hireth (shader video)\n// by David Hoskins.\n// Licensed under Attribution-NonCommercial-NoDerivatives 4.0 International\n// https://creativecommons.org/licenses/by-nc-nd/4.0/?ref=chooser-v1\n\n// Video for a friend of mine, the composer David Julyan. https://davidjulyan.com/\n// The album can be found here:\n\n// https://davidjulyan.bandcamp.com/album/hireth\n// All rights to the music belong to David Julyan...\n\n\nvec3 sunDir;\nmat3 camMat;\nvec3 cameraPos, cameraTar;\nvec3 sunPos;\n\nfloat gTime;\nfloat roll;\n\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\n\n//----------------------------------------------------------------------------------------\n// Crepuscular light rays...\nfloat godRays(vec2 uv)\n{\n   \tfloat ra =0.0;\n    vec3 sun = sunDir+vec3(0,.4,0);\n    // Find where the sun is in 2D then drag sky pixels accross that direction.\n    // It's not perfect here, but I like the effect.\n\tvec2 sunLoc = vec2(dot( sun, camMat[0] ),dot( sun, camMat[1] ) );\n   \t\n    vec2 p = uv-sunLoc;\n    float add = hash12(uv*4000.)*.05;\n    \n    \n \tfor (float x = .2; x < 1.; x+=.05)\n\t{\n\t\tfloat z = textureLod(iChannel1,(sunLoc+(p*(x+add))+1.)*.5, 0.).w;\n\t\tra+= z*(x-.1);\n\t}\n   \n    return ra*.025;\n}\n\n//-------------------------------------------------------------------------------------------------------\nvec3 getCamera(vec2 uv)\n{\n    return getStore(iChannel0, CAMERA_MAT0).xyz;\n    vec3 dir \t= camMat * normalize( vec3(uv, PROG_Z));\n}\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\n\nfloat PrintValue(vec2 fragCoord, vec2 pixelCoord, vec2 fontSize, float value,\n\t\tfloat digits, float decimals) {\n\tvec2 charCoord = (fragCoord - pixelCoord) / fontSize;\n\tif(charCoord.y < 0.0 || charCoord.y >= 1.0) return 0.0;\n\tfloat bits = 0.0;\n\tfloat digitIndex1 = digits - floor(charCoord.x)+ 1.0;\n\tif(- digitIndex1 <= decimals) {\n\t\tfloat pow1 = pow(10.0, digitIndex1);\n\t\tfloat absValue = abs(value);\n\t\tfloat pivot = max(absValue, 1.5) * 10.0;\n\t\tif(pivot < pow1) {\n\t\t\tif(value < 0.0 && pivot >= pow1 * 0.1) bits = 1792.0;\n\t\t} else if(digitIndex1 == 0.0) {\n\t\t\tif(decimals > 0.0) bits = 2.0;\n\t\t} else {\n\t\t\tvalue = digitIndex1 < 0.0 ? fract(absValue) : absValue * 10.0;\n\t\t\tbits = DigitBin(int (mod(value / pow1, 10.0)));\n\t\t}\n\t}\n\treturn floor(mod(bits / pow(2.0, floor(fract(charCoord.x) * 4.0) + floor(charCoord.y * 5.0) * 4.0), 2.0));\n}\n\nfloat drawValues(vec2 cor)\n{\n\nfloat c = 0.0;\n\n    vec3 camPos = getStore(iChannel0, CAMERA_POS).xyz;\n    vec2 camRot = getStore(iChannel0, CAMERA_ROT).xy;\n    c += PrintValue(cor, vec2(100.,10.),vec2(20,20) , camPos.x, 1.0, 0.);\n    c += PrintValue(cor, vec2(250.,10.),vec2(20,20) , camPos.y, 1., 0.);\n    c += PrintValue(cor, vec2(400.,10.),vec2(20,20) , camPos.z, 1., 0.);\n    \n    c += PrintValue(cor, vec2(100.,40.),vec2(20,20) , camRot.x, 1., 0.);\n    c += PrintValue(cor, vec2(250.,40.),vec2(20,20) , camRot.y, 1., 0.);\n    \n    vec4 sunCol = getStore(iChannel0, SUN_COLOUR);\n    \n    c += PrintValue(cor, vec2(500.,10.),vec2(20,20) , sunCol.w*1000.0, 1., 0.);\n    c += PrintValue(cor, vec2(500.,40.),vec2(20,20) , gTime, 1., 0.);\n    \n    //int t = int(iTime);c += PrintValue(cor, vec2(140.,130.),vec2(20,20) , float((t-1) % 4), 1., 0.);\n    //c += PrintValue(cor, vec2(280.,130.),vec2(20,20) , float(t), 1., 0.);\nreturn c;\n}\n\n\n//-------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.xy;\n    vec2 uv = fragCoord /  iResolution.xy;\n    camMat  = getStoreMat33(iChannel0, CAMERA_MAT0);\n    sunDir  = getStore(iChannel0, SUN_DIR).xyz;\n\n    vec4 temp= getStore(DATA_CHANNEL, SUN_COLOUR);\n    sunColour = temp.xyz;\n    sunUp = max(temp.w, 0.0);\n\n    sunPos = sunDir * 20000.;\n\n    vec4 te = getStore(iChannel0, GLOBAL_TIME);\n    gTime = te.x;\n    roll = te.y;\n    \n    \n    vec4 col = texelFetch(iChannel1,ivec2(fragCoord),0);\n\n    col += godRays(xy) * vec4(mix(vec3(.2), sunColour, .7) *sunUp, 1);\n\n   \n    //col = col*col*(3.0-2.0* col);\n    \n    col.xyz = aces(col.xyz);\n    col = fader(0.,8.,gTime)*fader(370.0, 355.0, gTime)*col;   \n    \n    col = sqrt(col);\n    #ifdef SEE_NUMBERS\n    col += drawValues(fragCoord);\n    #endif\n    \n    col *= .6+0.4*pow(80.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.3 );\t// Vignette\n    col += hash12(fragCoord+iTime*4400.)/64.0; //...Mega-Dither\n  \n\n    fragColor = clamp(col, 0.0, 1.0);\n    \n    \n     \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 35201,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://on.soundcloud.com/iTnaf"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define RENDERED_VERSION\n//#define SEE_NUMBERS\n//#define DEBUG\n\n#define TSIZE 256.\n#define TWRAP 255\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\n\n#define ZERO min(0, iFrame)\n\n#define TAU 6.28318530718\n\n#define FOG_COLOUR vec3(.4, .4, .45)\n\n#define CAMERA_POS\t\t0\n#define CAMERA_ROT\t\t1\n#define CAMERA_BASE\t\t2\n\n#define CAMERA_VEL      3\n#define GLOBAL_TIME\t\t6\n#define CAMERA_ROLL\t\t7\n\n#define SUN_DIR\t\t    8\n#define SUN_COLOUR\t    9\n#define PROG_Z\t\t    1.4\n\n\n#define CAMERA_MAT0\t\t20\n#define CAMERA_MAT1\t\t21\n#define CAMERA_MAT2\t\t22\n//#define SUN_DIRECTION \t5\n#define LAST \t\t\t10\n\n#define DATA_CHANNEL   iChannel0\n\n#define LIGHT_COLOUR vec3(1., .6, .4)\n\n#ifdef RENDERED_VERSION\n#define FAR 20000.\n#else\n#define FAR 9000.\n#endif\n\n\nvec3 sunColour;\nfloat sunUp;\n\n\n//----------------------------------------------------------------------------------------\nfloat hash11(uint q)\n{\n\tuvec2 n = q * UI2;\n\tq = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\nfloat hash11(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tuint q = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n//----------------------------------------------------------------------------------------\nfloat hash12(uvec2 q)\n{\n\tq *= UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n//----------------------------------------------------------------------------------------\nvec2 hash22(uvec2 q)\n{\n\tq *= UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash31(uint q)\n{\n\tuvec3 n = q * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\nvec3 hash31(float p)\n{\n\n\tuvec3 n = uint(int(p)) * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\n//----------------------------------------------------------------------------------------\nvoid rot(inout vec2 p, float a)\n{\n    p = cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n//----------------------------------------------------------------------------------------\nfloat noise1( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float res = mix(hash11(p), hash11(p + 1.0),f);\n\n    return res;\n}\n\n\n\n//----------------------------------------------------------------------------------------\nvec2 noise2( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 res = mix(mix( hash22(p), hash22(p + vec2(1.0,0.0)),f.x),\n                   mix( hash22(p + vec2(0.0,1.0)), hash22(p + vec2(1.0,1.0)),f.x),f.y);\n    return res-vec2(.5);\n}\n\n//----------------------------------------------------------------------------------------\nfloat noise12( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float res = mix(mix( hash12(p), hash12(p + vec2(1.0,0.0)),f.x),\n                   mix( hash12(p + vec2(0.0,1.0)), hash12(p + vec2(1.0,1.0)),f.x),f.y);\n    return res;\n}\n\n//----------------------------------------------------------------------------------------\nfloat fbm(in vec2 x )\n{\n    float h = noise12(x)*.5 +\n              noise12(x*2.0+100.)*.3 +\n              noise12(x*4.0+200.)*.2;\n    \n    return h;\n}\n\n//----------------------------------------------------------------------------------------\nint storeIndex(ivec2 p)\n{\n\treturn p.x + 64 * p.y;\n}\n\n//----------------------------------------------------------------------------------------\nvec4 getStore(sampler2D tex,int num)\n{\n\treturn  texelFetch(tex, ivec2(num, 0), 0);\n}\n\n//----------------------------------------------------------------------------------------\nmat3 getStoreMat33(sampler2D tex,int num)\n{\n    vec3 m0 = texelFetch(tex, ivec2(num, 0),   0).xyz;\n    vec3 m1 = texelFetch(tex, ivec2(num+1, 0), 0).xyz;\n    vec3 m2 = texelFetch(tex, ivec2(num+2, 0), 0).xyz;\n    return mat3(m0, m1, m2);\n}\n\n//----------------------------------------------------------------------------------------\nmat3 viewMat (float ay, float az)\n{\n  vec2 o, ca, sa;\n  o = vec2 (ay, az);\n  ca = cos (o);\n  sa = sin (o);\n  return mat3 (ca.y, 0., sa.y,    0., 1., 0.,   -sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n//----------------------------------------------------------------------------------------\nfloat roundedBox( vec3 p, vec3 b, float r )\n{\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\n\n\n// Exponential fader...\nfloat fader(const in float edge0, const in float edge1, const in float x)\n{\n    float t = (x - edge0) / (edge1 - edge0);\n    return  clamp(exp((t-.9825)*3.)-.0525, 0.0, 1.0);\n}\n\n// https://iquilezles.org/articles/distfunctions/\n//----------------------------------------------------------------------------------------\nfloat dot2(in vec3 v ) { return dot(v,v); }\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n\n//----------------------------------------------------------------------------------------\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n//----------------------------------------------------------------------------------------\nfloat sdHorizontalCapsule( vec3 p, float h, float r )\n{\n  p.x -= clamp( p.x, 0.0, h );\n  return length( p ) - r;\n}\n    \n//----------------------------------------------------------------------------------------\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2022.\n\n\n// Derivative pre-process...\n\nfloat derivHash(ivec2 q2)\n{\n   uvec2 q = uvec2((q2+9) & TWRAP);  // ...Seeded and wrapped.\n   float f = hash12(q);\n   return pow(f, 1.5 );\n}\n\n//---------------------\n//|                   |\n//|                   |\n//|                   |\n//|                   |\n//|                   |\n//|****               |\n//|****               |\n//|****               |\n//---------------------\n// The block is in the bottom left 256x256 of buffer texture\nvoid mainImage( out vec4 colour, in vec2 coord )\n{\n\n// Draw it only once to relavent area...\n\n// It seems the buffers are also doubled as I need to draw 2 frames...\n  if (iFrame < 2 && coord.x < TSIZE && coord.y < TSIZE)\n  {\n\n    vec4 data, n;\n    ivec2 co = ivec2(floor(coord));\n\n    float a = derivHash(co);\n    float b = derivHash((co+ivec2(1,0)));\n    float c = derivHash((co+ivec2(0,1)));\n    float d = derivHash((co+ivec2(1,1)));\n\n// Pre-calc all we can...\n    data.x = a;\t \t\t\n    data.y = b-a; \t\t\t\n    data.z = c-a; \t\t\t\n    data.w = a - b - c + d;\n\n    colour = data;\n  }\n  else discard;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//#define FLY_CAMERA\n\n#define START_TIME 0.\n//330 is before the house\n\n//Time muliplier, use 1.0 For Hireth music track.\n#define TIME_MULTI 1.  \n\n\n// Movement...\n// * * CONTROLS * *\n// WASD or CURSOR keys\n// Mouse drag to turn.\n// SHIFT & SPACE for 2X & 4X speed\n\n\n#define INVERT_Y 0\n#define ACCEL .005\n#define DECAY  .8 // how much velocity is preserved per frame (proportionally)\n#define MAX_SPEED  10.0\n#define TAU 6.28318530718\n\n\n#if INVERT_Y\nconst float yMul = 1.0;\n#else\nconst float yMul = -1.0;\n#endif\nconst int KEY_W\t\t= 87;\nconst int KEY_A\t\t= 65;\nconst int KEY_S\t\t= 83;\nconst int KEY_D\t\t= 68;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_SPACE\t= 32;\nconst int KEY_SHIFT\t= 16;\nstruct Camera\n{\n    vec3 pos;\n    vec2 rot;\n};\n\n#ifndef FLY_CAMERA\n // Catmull-rom spline coords & rotations...\nCamera camPos[] = Camera[](\n    Camera(vec3(-129, 393, 17460), vec2(14,191)),\n    Camera(vec3(-422, 400, 18000), vec2(0,200)), // Back from start\n    Camera(vec3(-822, 420, 17900), vec2(-20,220)),\n    Camera(vec3(-1768, 327, 17900), vec2(00,180)),\n    Camera(vec3(-1968, 327, 17000), vec2(00,180)),\n    Camera(vec3(-2100, 546, 16200), vec2(00,224)),\n    Camera(vec3(-2710, 223, 15303), vec2(4,152)),\n    Camera(vec3(-2755, 316, 14919), vec2(36,217)),\n    Camera(vec3(-2408, 465, 14637), vec2(11,242)),// Over side nodule.\n    Camera(vec3(-1991, 582, 14380), vec2(13,278)),\n    Camera(vec3(-1493, 428, 14618), vec2(13,268)),// First plane.\n    Camera(vec3(-693, 249, 14678), vec2(2,202)),\n    Camera(vec3(-693, 249, 14678), vec2(2,142)),\n    Camera(vec3(-826, 274, 14352), vec2(17,160)),\n    Camera(vec3(-859, 400, 14271), vec2(-20,173)),//Chopper style lift\n    Camera(vec3(-1332, 408, 13776), vec2(4,132)),\n    Camera(vec3(-2475, 258, 13507), vec2(-10,108)),\n    Camera(vec3(-2732, 270, 13423), vec2(-10,103)),\n    Camera(vec3(-3139, 404, 12999), vec2(1,146)),\n    Camera(vec3(-3581, 406, 11841), vec2(-5,174)), // Black mount om left\n    Camera(vec3(-2873, 341, 9728), vec2(-3,218)),\n    Camera(vec3(-2873, 541, 9628), vec2(-3,248)),\n    Camera(vec3(-2543, 396, 9651), vec2(-10,205)),\n    Camera(vec3(-2157, 254, 9538), vec2(-20,206)),\n    Camera(vec3(-2205, 225, 8378), vec2(-2,193)),\n    Camera(vec3(-2369, 286, 7384), vec2(16,166)),\n    Camera(vec3(-2714, 228, 6717), vec2(8,179)),\n    Camera(vec3(-2472, 312, 6464), vec2(-16,204)),\n    Camera(vec3(-2186, 365, 5913), vec2(-45,197)),\n    Camera(vec3(-2237, 220, 5330), vec2(-13,178)),\n    Camera(vec3(-2879, 361, 4766), vec2(-13,159)),\n    Camera(vec3(-2965, 371, 4592), vec2(-11,202)),\n    Camera(vec3(-2851, 371, 4332), vec2(-10,225)),\n    Camera(vec3(-2541, 135, 4107), vec2(-3,209)),\n    Camera(vec3(-2541, 80, 4007), vec2(10,209))\n\n    );\n\n\n        \n#endif\n         \n\n//----------------------------------------------------------------------------------------\nfloat ReadKey( int key )\n{\n   \treturn step(.5,texture( iChannel3, vec2( (float(key)+.5)/256.0, .25)).x);\n}\n\n//----------------------------------------------------------------------------------------\nfloat Scale = 4.;\nfloat MinRad2 = 0.25;\nfloat sr = 4.0;\nvec3 fo =vec3 (0.7,.9528,.9);\nvec3 gh = vec3 (.8,.7,0.5638);\nvec3 gw = vec3 (.3, 0.5 ,.2);\n\n#ifndef FLY_CAMERA\n\n// Catmull-rom spline\nvec3 spline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t){\n\n    vec3 c2 = -.5 * p0\t+ 0.5*p2;\n\tvec3 c3 = p0\t\t+ -2.5*p1 + 2.0*p2 + -.5*p3;\n    vec3 c4 = -.5 * p0\t+ 1.5*p1 + -1.5*p2 + 0.5*p3;\n\treturn(((c4 * t + c3) * t + c2) * t + p1);\n}\n\n//-----------------------------------------------------------------------------------------------------------\nCamera getPosAtTime(float t)\n{\n    Camera cam;\n\n\n    int i = int(t);\n    \n\n    ivec4 id = ivec4(i-1, i, i+1, i+2);\n    // Don't scrub memory with illegal indexing...\n    id = clamp(id, 0, camPos.length()-1);\n    \n \n    vec3 p0 = camPos[id.x].pos;\n    vec3 p1 = camPos[id.y].pos;\n    vec3 p2 = camPos[id.z].pos;\n    vec3 p3 = camPos[id.w].pos;\n\n    t = fract(t);\n    \n    cam.pos = spline(p0, p1, p2, p3, t);\n    \n    t = t*t*(3.0-2.0*t);\n    float x1 = camPos[id.y].rot.x;\n    float x2 = camPos[id.z].rot.x;\n    x1 = mix(x1, x2, t);\n    \n    float y1 = camPos[id.y].rot.y;\n    float y2 = camPos[id.z].rot.y;\n    y1 = mix(y1, y2, t);\n\n    cam.rot = vec2(x1, y1);\n    \n    return cam;\n\n} \n\n#endif\t\n\n\n//-----------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 colour, in vec2 coord )\n{\n    colour = vec4(0.0,0.0,0.0,1.0);\n    int  index = storeIndex(ivec2(coord));\n\n    #ifdef FLY_CAMERA\n \n        if ( index == CAMERA_POS)\n        {\n            vec3 camPos = getStore( DATA_CHANNEL, CAMERA_POS).xyz;\n            vec3 camVel = getStore( DATA_CHANNEL, CAMERA_VEL).xyz;\n\n            if (iFrame == 0)\n\t\t    {\n        \t\tcolour = vec4(-2300., 250., 3900.,0);\n            }else\n            {\n                camVel *= 200.*(1.0+ReadKey(KEY_SHIFT)+ReadKey(KEY_SPACE));\n                vec3 oldCam = camPos;\n                camPos += camVel;\n            \tcolour = vec4(camPos, 0);\n            }\n        }\n        else if ( index <= CAMERA_BASE )\n        {\n            vec4 baseCamRot = getStore( DATA_CHANNEL, CAMERA_BASE);\n            vec4 camRot =  getStore( DATA_CHANNEL, CAMERA_ROT);\n\n\n            vec2 mouseRot = -(iMouse.yx/iResolution.yx-.5)*vec2(.5*yMul,1.) *360.0;\n            \n            camRot.w = iMouse.z;\n            \n            bool press = (camRot.w > .0);\n            bool lastPress = (baseCamRot.w > .0);\n            \n            bool click = press && !lastPress;\n            if ( click )\n            {\n                baseCamRot.xy -= mouseRot;\n            }\n            \n            if ( press )\n            {\n                camRot.xy = baseCamRot.xy + mouseRot;\n            }\n            else\n            {\n                //update the base pos\n                baseCamRot = camRot;\n            }\n            //\n\n            baseCamRot.w = camRot.w;\n            \n            // store\n            if ( index == 1 )\n            {\n\t\t\t\tif (iFrame == 0)\n\t\t    \t{\n        \t\t\tcolour = vec4(14, 191, .0,0);\n            \t}else\n                {\n                    //camRot = fract(camRot/360.0) * 360.0;\n                    colour = camRot;\n                }\n            }\n            else\n            {\n            \tcolour = baseCamRot;\n                baseCamRot = fract(baseCamRot/360.0) * 360.0;\n            }\n        }\n        else if ( index == CAMERA_VEL)\n        {\n            vec4 camVel = getStore( DATA_CHANNEL, CAMERA_VEL);\n            mat3 camMat = getStoreMat33(iChannel0, CAMERA_MAT0);\n            vec3 forward = camMat[2] * ACCEL;\n            vec3 right \t = camMat[0] * ACCEL;\n            if (iFrame == 0) camVel = vec4(0);\n\n            camVel *= DECAY; // exponential decay\n            camVel.xyz += (ReadKey(KEY_W)-ReadKey(KEY_S)+ReadKey(KEY_UP)-ReadKey(KEY_DOWN)) * forward;\n            camVel.xyz += (ReadKey(KEY_D)-ReadKey(KEY_A)+ReadKey(KEY_RIGHT)-ReadKey(KEY_LEFT)) * right;\n \n\n\n            float lim = length(camVel);\n            if (lim > MAX_SPEED)\n            {\n                camVel = normalize(camVel) * MAX_SPEED;\n            }\n        \n            \n            colour = camVel;\n        }\n    \n    #else\n    \n    float t = getStore(iChannel0, GLOBAL_TIME).x*.1;\n \n    if ( index == CAMERA_POS)\n    {\n\t\tCamera camInfo = getPosAtTime(t);\n        vec3 pos = camInfo.pos;\n\t\tcolour = vec4(pos, 1.0);\n    }else\n    if ( index == CAMERA_ROT)\n    {\n        Camera camInfo = getPosAtTime(t);\n        colour.xy = camInfo.rot;\n    }\n        \n    #endif\n    \n    if (index >= CAMERA_MAT0 && index <= CAMERA_MAT2)\n    {\n        float roll = 0.0;\n        vec3 dir;\n        vec2 cam =  getStore( DATA_CHANNEL, CAMERA_ROT).xy;\n        cam *= TAU/360.;\n        mat3 mat = viewMat(cam.x, cam.y);\n        switch (index)\n        {\n            case CAMERA_MAT0:\n                colour.xyz = mat[0];\n            break;\n            case CAMERA_MAT1:\n                colour.xyz = mat[1];\n            break;\n            case CAMERA_MAT2:\n                colour.xyz = mat[2];\n            break;\n         }\n      }\n      else if ( index == GLOBAL_TIME)\n      {\n            float gTime = iTime * TIME_MULTI + START_TIME;\n            float roll = .05 * sin(iTime*.3);\n            colour = vec4(gTime, roll,0,0);    \n            \n    }\n    else if (index == SUN_DIR)\n    { \n        float t = getStore(iChannel0, GLOBAL_TIME).x*.0064+.93;\n        //t = -.5;\n        vec3 sun = vec3(0,0,1);\n        rot(sun.yz, -t);\n        rot(sun.xy, -.5);\n        //colour.xyz = normalize( vec3(  0.3, .3, -.4 ) );\n        colour.xyz = sun;\n        \n    }else\n    if (index == SUN_COLOUR)\n    {\n        float t = clamp(getStore(iChannel0, SUN_DIR).y, 0.0, 1.0);\n        t = sqrt(t);\n        \n        \n    \n        colour.xyz = vec3(1.0, .2+sqrt(t)*.8, .1+t*.9  );\n        \n        //colour.yz -= pow(t, 100.)*.3;\n        \n        \n        colour.w = clamp(t, 0.0, 1.0);\n        colour = clamp(colour, 0.0, 1.0);\n    }\n    \n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Atmosphere stuff thanks to:\n// https://www.shadertoy.com/view/MtBcz1\n\n#define ANG2 1.33\n#define ANG3 1.8\nbool houseVisible;\nbool doorHit;\n\nfloat smokeDist = 0.0;\n#ifdef DEBUG\nfloat iterations;\n#endif\n\n\nconst mat2 rotMat = mat2(cos(ANG2), sin(ANG3), -sin(ANG3), cos(ANG2)) * 2.;\n//const vec3 PARALLEL_DIR = normalize(vec3(.35 , .2, .5));\nvec3 sunDir;\n\nvec3 cameraPos, cameraTar;\nmat3 cameraMat;\n\nconst vec3 camHouse = vec3(-2350., 70., 3800.);\nconst vec3 chimney = camHouse+vec3(-97,120,0);\n//const vec3 houseLight = vec3(-2500., 100., 3800.);\nconst vec3 houseLight = vec3(-2350., 100., 3850.);\n\nvec3 camRay;\nfloat gTime;\nfloat movement = 0.0;\nfloat fade;\nfloat roll;\n\nfloat sphereFog( vec3  ro, vec3  rd,   // ray origin, ray direction\n                  vec3  sc, float sr,   // sphere center, sphere radius\n                  float dbuffer )       // depth buffer\n{\n    // normalize the problem to the canonical sphere\n    float ndbuffer = dbuffer / sr;\n    vec3  rc = (ro - sc)/sr;\n\t\n    // find intersection with sphere\n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n\n    // not intersecting\n    if( h<0.0 ) return 0.0;\n\t\n    h = sqrt( h );\n    \n    \n\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    // not visible (behind camera or behind ndbuffer)\n    if( t2 < 0.0 || t1 > ndbuffer ) return 0.0;\n\n    //return h*h*h*h;\n    // clip integration segment from camera to ndbuffer\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    // analytical integration of an inverse squared density\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\n//----------------------------------------------------------------------------------------------------------\n// Thanks to iq for the derivative solution, many years ago...\nvec3 noiseD(in vec2 x) \n{\n    vec2 f = fract(x);\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.*f*f*(f*(f-2.0)+1.);\n\n\tvec4 n = texelFetch(iChannel2, ivec2(floor(x)) & TWRAP, 0);\n\treturn vec3(n.x + n.y * u.x + n.z * u.y + n.w * u.x*u.y,\n\t\t\t\tdu * (n.yz + n.w*u.yx));\n}\n\n//----------------------------------------------------------------------------------------------------------\n// Add random rocks with random heights...\nfloat rocks(in vec2 p)\n{\n    float d = 0.0;\n    p *= 8.;\n    p += fbm(p)-.5;\n\tvec2 v2 = fract(p)-.5;\n    float str = noise12((p));\n    str = pow(str, 20.0)*30.;\n    d += max(.8-(length(v2)), 0.0)*(str)*.5;\n    return d*4.;\n}\n\n//-------------------------------------------------------------------------------------------------------\nfloat roads(in vec2 p)\n{\n    float n = fbm(p*.695+vec2(2.14, 0.0))-.5;\n    n = 1.-abs(n);\n    n = min(pow(n, 50.0), noise12(p*8.)*.4+.5);\n    return n*6.;\n}\n\nfloat noise13(in vec3 x)\n{\n    // Use 2D texture...\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel1, (uv+ 0.5)/256.0, -99.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n \n//-------------------------------------------------------------------------------------------------------\n float sdfHouse(vec3 p, float d)\n {\n     //d = 1000.0;\n     d = sdBox(p, vec3(100,50,50));\n     \n    if (d< -4.5)\n         houseVisible = true;\n    else\n         houseVisible = false;\n\n    d = min(d, sdBox(p-vec3(-95,40,0), vec3(10,100,10)));\n\n    vec3 q = p- vec3(0,50,0);\n    rot(q.yz, .78);\n    d = min(d, roundedBox(q, vec3(96,40,40), 4.));\n\n    d = max(d, -sdBox(p, vec3(90,38,45)));     \n    p.x = abs(p.x);\n\n    d = max(d, -sdBox(p - vec3(60,0,50), vec3(20, 14, 25)));\n    d = max(d, -sdBox(p - vec3(5,-20,50), vec3(10, 30, 25)));\n    \n    float dor = sdBox(p - vec3(5,-20,40), vec3(10, 30, 5));\n    \n    if (dor < .5)\n        doorHit = true;\n    d = min(d, dor);\n   \n    // Cheap windows...\n    d = min(d, sdVerticalCapsule(p-vec3(52, -20,48), 35.,.5));\n    d = min(d, sdVerticalCapsule(p-vec3(67, -20,48), 35.,.5));\n    d = min(d, sdHorizontalCapsule(p-vec3(40, 0,48), 40.,.5));\n    \n    \n    //d = min(d, sdRoundCone(p, camHouse, camHouse-vec3(0,200,0), 100.0, 400.0));\n    if (!doorHit)\n        d+=noise13(p*.25)*.5;\n\n     \n\n\n     return d;\n}\n\n//-------------------------------------------------------------------------------------------------------\n float sdfHouseShad(vec3 p, float d)\n {\n    p = p - camHouse;\n     d = roundedBox(p, vec3(100,50,50), .1);\n\n     d = min(d, roundedBox(p-vec3(-95,70,0), vec3(10,70,10), .1));\n     vec3 q = p- vec3(0,50,0);\n     rot(q.yz, .78);\n     d = min(d, roundedBox(q, vec3(100,40,40)*.9, 10.1));\n     \n\n     return d;\n}\n \n \n \n//-------------------------------------------------------------------------------------------------------\nfloat house(in vec3 p)\n{\nfloat d = 1000.0;\n\n    p = p - camHouse;\n    float bound = sdBox(p, vec3(130,160,120));\n    if (bound < 0.0)\n    {\n  \n        d = sdfHouse(p, bound);\n    }\n\nreturn d;\n}\n\n//-------------------------------------------------------------------------------------------------------\nfloat terrainSDF( in vec3 p, float z)\n{\n    float a = 0.0;\n    float h = length(p.xz-camHouse.xz);\n    vec2  d = vec2(0.0);\n    float b = 400.;//smoothstep(0.0, 2000.0, h)*500.0+40.;\n    b*= (.2+smoothstep(00.0,1500.0,h)*1.5);\n    p = p*0.0007;    \n    \n    int iter = 1;\n\n    // Decrease iteration detail with distance, but always do furniture..\n    if (z >= 0.0)\n    {\n        // Up to 14 levels of fractal...\n        iter = 14-int(log2(z*.01+1.0));\n        iter = clamp(iter, 2, 14);\n        //iter = 14;\n        \n        a -= roads(p.xz*4.);\n        a += rocks(p.xz*6.);\n        #ifdef DEBUG\n        iterations = float(iter);\n        #endif\n        \n    }\n    \n\tfor (int i = 0; i < iter; i++)\n\t{\n        vec3 n = noiseD(p.xz);\n        \n        d += n.yz;\n        a += b*n.x/(.85+dot(d,d));\n\n\t\tb *= 0.43;\n        p.xz = rotMat*p.xz;\n        //p.xz -= n.yz*.2;\n        p.xz += n.zy*.2;\n\t}\n    \n\n\treturn a;\n}\n\n//-------------------------------------------------------------------------------------------------------\nfloat smokeCone(vec3 p)\n{\n    float t = gTime*.6;\n    float sm = sdRoundCone(p, chimney, chimney+vec3(sin(p.y*.015+t*1.)*40.+p.y*.5,1000, cos(p*0.01+t)*40.), 4.0, 200.0);\n    return sm;\n\n}\n\n//-------------------------------------------------------------------------------------------------------\nfloat map(vec3 p, float z)\n{\n    float h = p.y-terrainSDF(p, z);\n    h = min(h, house(p));\n    \n\n    // Check for smoke volume...\n    float s = smokeCone(p);\n    if (smokeDist < 0.0 && s < 0.1)\n        smokeDist = z;\n\n    return min(h, max(s, 35.));\n}\n\n//-------------------------------------------------------------------------------------------------------\nfloat mapShad(vec3 p, float z)\n{\n    float h = p.y-terrainSDF(p, z);\n    h = min(h, sdfHouseShad(p,0.0));\n    return h;\n}\n\n//-------------------------------------------------------------------------------------------------------\nvec3 getCamPos(float t)\n{\n\tvec3 p = vec3(sin(t)*1500.-4500.+cos(t*.5)*1000., 300.+sin(t)*250., cos(t*1.1)*1500.-1400.+cos(t*.3)*1000.);\n    return p;\n}\n\n//-------------------------------------------------------------------------------------------------------\nvec3 getCamera(vec2 uv)\n{\n    cameraPos = getStore(DATA_CHANNEL, 0).xyz;\n    \n   \tvec2 camRot = getStore(DATA_CHANNEL, 1).xy;\n    \n    vec2 cam = camRot * TAU / 360.0;\n\n  \n\tvec3 dir = normalize(vec3(uv,PROG_Z));\n    cameraMat = getStoreMat33(iChannel0, CAMERA_MAT0);\n    dir = cameraMat *dir;\n    return dir;\n}\n\n//-------------------------------------------------------------------------------------------------------\n\nvec3 getSky(vec3 raydir)\n{\n\tvec3 sundir = sunDir;\n    sundir.y = max(sundir.y, -.07);\n    float a = dot(raydir, sunDir);\n\tfloat special_trick = 1.0 / (raydir.y * 1.0 + 0.1);\n\tfloat special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);\n\tfloat raysundt = pow(abs(dot(sundir, raydir)), 3.0);\n\tfloat sundt = pow(max(0.0, dot(sundir, raydir)), 2.0);\n\tfloat mymie = sundt * special_trick * 0.4;\n\tvec3 suncolor = mix(vec3(1.), max(vec3(0.0), vec3(1.0) - vec3(10.5, 20.0, 22.4) / 22.4), special_trick2);\n\tvec3 bluesky= vec3(5.5, 13.0, 22.4) / 22.4 * suncolor;\n\tvec3 bluesky2 = max(vec3(.2), bluesky - vec3(5.5, 13.0, 22.4) * 0.004 * (special_trick + -6.0 * sundir.y * sundir.y));\n\tbluesky2 *= special_trick * (0.24 + raysundt * 0.24);\n    \n    \n\tbluesky2 = max(bluesky2 + mymie * suncolor,0.0)+.0;\n    bluesky2 = mix(bluesky2, FOG_COLOUR, sunUp*.3)*.5+vec3(0.01,0.01,.02);\n     \n    bluesky2 += pow(max(a, .0), 2000.0) * 20. * sunColour;\n\n    bluesky2  = clamp(bluesky2, 0.0, 1.0);\n    \n    \n    \n\n    \n    return bluesky2;\n} \n/*\nvec3 getSky(vec3 dir)\n{\n\tvec3 col = mix(vec3(FOG_COLOUR), vec3(.3,.5,1.0),clamp((1.-exp(-dir.y))*1., 0.0, 1.))*.1;\n    float a = dot(dir, sunDir);\n    col += pow(max(a, .0), 800.0) * 40. * sunColour;\n    \n    float red   = max(.9  - sunUp, 0.0);\n    col.x += pow(max(.8 - dir.y,0.0), 4.)* 30.0 * red;\n    float horiGlow   = max(.8 -sunUp, 0.0);\n    col += pow(max(.5 - dir.y,0.0), 2.)*15.0 * horiGlow;\n    //col += pow(max(.4 - dir.y,0.0), .5)*.5;\n    //col*=pow(max(a, 0.0), 10.0)*.4;\n    col *= sunUp;\n\n    return col+.02;\n}\n*/\n\n//-------------------------------------------------------------------------------------------------------\nfloat softShadow(in vec3 ro, in vec3 rd, float dis )\n{\n    float minStep = .4;\n\n    float res = 1.0;\n    float t = 0.01;\n\n\tfor( int i=0; i<25; i++ )\n\t{\n\t    vec3  p = ro + t*rd;\n        float h = mapShad(p, dis);\n\t\tres = min( res, 25.0*h/t );\n\t\tt += max(minStep,h);\n\t\tif( res<0.2) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n//-------------------------------------------------------------------------------------------------------\n// From here: https://www.shadertoy.com/view/3lsSzf\nvec3 getNormal(const in vec3 pos, float ds)\n{\n    \n    ds = max(ds*ds*.001/iResolution.y, .1 );\n    vec3 n = vec3(0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+ds*e, ds);\n    }\n    return normalize(n);\n}\n\n\n//----------------------------------------------------------------------------------------------------------\nvec3 lighting(vec3 p, vec3 nor, vec3 dir, float dis)\n{\n    vec3 li;\n    float l = max(dot(dir, nor), 0.0);\n    vec3 ref = reflect(nor, camRay);\n    float sh = softShadow(p+nor*.5, dir, dis);\n    l *= sh;\n    li = l * sunColour*sunUp;\n    li = li+pow(max(dot(ref, sunDir), 0.0), 100.0)*sunColour*sh;\n    li = li*sunUp+.01;\n    li = clamp(li, 0.0, 1.0);\n    if (houseVisible)\n    {\n        vec3 fpos = camHouse+vec3(-50,0,0);\n        float fl = length(fpos - p);\n\n        vec3 fp = (fpos-p) / fl;\n        vec3 fire = fp/fl;\n        fl = (fl*fl)*.00001;\n        \n        l = max(dot(fire, nor) / fl, 0.0)*2.0;\n        li += l * vec3(1.0+noise1(gTime*8.),.2,0);\n    }\n    \n    ref = houseLight - p;\n    l = length(ref);\n    // Lamp outside house...\n    if (l < 150.0)\n    {\n        vec3 n = ref / l;\n        l = smoothstep(100.0, 0.0, l);\n        float a = max(dot(n, nor), 0.0);\n        float dim = smoothstep(-.5, -1.5,dot(n, vec3(0,-1,0)));\n        l = l*dim;\n        li += l * LIGHT_COLOUR;\n    }\n\n    return clamp(li, 0.0, 1.0);\n    \n}\n\nvec3 brickt(vec2 p2)\n{\n    p2 += noise2(p2*1.)*.05;\n    p2.x+=floor(p2.y)*.5;\n\n    vec2 fp2=fract(p2);\n    float brick=length(max(vec2(0.0),abs(fp2-vec2(0.5))-vec2(0.46,0.43))*vec2(2,1));\n    return mix(texture(iChannel3, p2.xy*.2).xyz, vec3(.0),smoothstep(0.0,0.1,brick));\n}\n\n//----------------------------------------------------------------------------------------------------------\nvec3 material(vec3 p, vec3 nor)\n{\n\n    if (house(p) <= 0.2)\n    {\n        if (nor.y> .3 && nor.y < .8) return vec3(.1);\n        if (doorHit)\n            return vec3(.0,.1,0.1);\n        else\n            return (nor.z > .8)? brickt(p.xy*vec2(.065, .1))*.5:brickt(p.zy*vec2(.065, .1));\n\n    }\n    \n\n    float n = fbm(p.xz*.025);\n\n    vec3 mat = vec3(n*.8);\n    float g = fbm(p.xz*.006);\n\n    mat  = mat*g*.3;\n    mat  = mix(mat, min(vec3(1),vec3(.2+nor.y)), smoothstep(.91, .99, nor.y));\n    \n    return mat+vec3(0.04,0.04,nor.y*.1);\n}\n\n\n\n//-------------------------------------------------------------------------------------------------------\nfloat rayMarch(in vec3 rO, in vec3 rD, in float t)\n{\n\tfloat d;\n    float adj = .2;// Estimate error adjust starts very small\n    doorHit = false;\n    smokeDist = -1.0;\n    \n    #ifdef RENDERED_VERSION\n    for(int j = ZERO; j < 320 && t < FAR; j++)\n    #else\n    for(int j = ZERO; j < 260 && t < FAR; j++)\n    #endif\n\t{\n        d = map(rO + t*rD, t);\n        if (abs(d) < .2) break;\n        t += d * adj;\n        adj += .001;\n\t}\n \n\treturn t;\n}\n\n\nfloat collectSmoke(in vec3 rO, in vec3 rD, in float d)\n{\n    \n    float a = 0.0;\n   \n    for(int j = ZERO; j < 50; j++)\n\t{\n        vec3 pos = rO + rD * d;\n        \n        float h = smokeCone(pos)-.1;\n        if (h > 0.0) break;\n        float n = noise13(pos*.02-vec3(gTime*.3,gTime*.2,0));\n        \n        a += .03 * n*n*3. * smoothstep(1300.0, 400.0, pos.y);\n        if (a > 1.0 )\n        {\n            break;\n        }\n        d += 3.;\n     }\n     return clamp(a, 0.0, 1.0);\n}\n\n\n//-------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gTime = getStore(DATA_CHANNEL,GLOBAL_TIME).x;\n    gTime += hash12(fragCoord)*.2;\n    sunDir = getStore(DATA_CHANNEL, SUN_DIR).xyz;\n    vec4 temp= getStore(DATA_CHANNEL, SUN_COLOUR);\n    sunColour = temp.xyz;\n    sunUp = max(temp.w, 0.0);\n    houseVisible = false;\n\n    vec4 te = getStore(DATA_CHANNEL, GLOBAL_TIME);\n    gTime = te.x;\n    roll = te.y;\n\n    vec2 xy = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x / iResolution.y, 1.0);\n    camRay = getCamera(uv);\n\n    vec3 col = getSky(camRay);\n    //col = vec3(.5);\n    \n    float dis = rayMarch(cameraPos, camRay, hash12(fragCoord)*1.);\n    \n    float godBri = 0.0;\n\n    \n    if (dis < FAR)\n    {\n        vec3 pos = cameraPos+camRay * dis;\n        float d = dis*.0001;\n        vec3 nor = getNormal(pos, dis);\n        col = material(pos,nor) * lighting(pos, nor, sunDir, dis);\n        col = mix(FOG_COLOUR*sunUp, col, exp(-d*d*1.2));\n    }else\n    {\n        godBri = 1.0;\n    }\n    //col = clamp(col, 0.0, 1.0);\n    \n    if (smokeDist > 0.0)\n    {\n        //col = clamp(col, 0.0, 1.0);\n        col = mix(col, vec3(0), collectSmoke(cameraPos, camRay, smokeDist)*.6);\n    }\n\n    col = clamp(col, 0.0, 1.0);\n    //col = col*col*(3.0-2.0*col);\n\n    vec3 lamp = (houseLight - cameraPos);\n    float d  = length(lamp);\n    \n    if (d< dis+40.)\n    {\n        lamp /= d;\n        float l = max(dot(lamp, camRay), 0.0);\n        col += pow(l, 8000.0)*.2 * LIGHT_COLOUR;\n     }\n     #ifdef DEBUG\n     col = mix(col, hash31(iterations*30.), .2); \n     #endif\n    \n    \n    float localFog = sphereFog(cameraPos, camRay, camHouse+ vec3(0,0,40), 300.0, dis);\n    \n    col += pow(localFog, 2.0) * vec3(1, .5 , .3)*.1;\n    \n//    float sphereFog( vec3  ro, vec3  rd,   // ray origin, ray direction\n//                  vec3  sc, float sr,   // sphere center, sphere radius\n//                  float dbuffer )       // depth buffer\n\n    \n    \n\n\n    fragColor = vec4(col,godBri);\n     \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}