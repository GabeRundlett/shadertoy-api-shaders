{
    "Shader": {
        "info": {
            "date": "1576530908",
            "description": "Infinite columns.\nUse the mouse to look around",
            "flags": 0,
            "hasliked": 0,
            "id": "3tdGWM",
            "likes": 24,
            "name": "Colonnato",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "lucasassone",
            "viewed": 529
        },
        "renderpass": [
            {
                "code": "\nconst float PI = 3.141592;\n\nvec3 rotate(vec3 p, float angle, vec3 axis) {\n\tvec3 a = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat r = 1.0 - c;\n\tmat3 m = mat3(\n\t\ta.x * a.x * r + c,\n\t\ta.y * a.x * r + a.z * s,\n\t\ta.z * a.x * r - a.y * s,\n\t\ta.x * a.y * r - a.z * s,\n\t\ta.y * a.y * r + c,\n\t\ta.z * a.y * r + a.x * s,\n\t\ta.x * a.z * r + a.y * s,\n\t\ta.y * a.z * r - a.x * s,\n\t\ta.z * a.z * r + c\n\t);\n\treturn m * p;\n}\n\nfloat random (in float x) {\n\treturn fract(sin(x) * 1e4);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec3 p) {\n\tconst vec3 step = vec3(110.0, 241.0, 171.0);\n\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\n    // For performance, compute the base input to a\n    // 1D random from the integer part of the\n    // argument and the incremental change to the\n    // 1D based on the 3D -> 1D wrapping\n\tfloat n = dot(i, step);\n\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\n\treturn mix( mix(mix(random(n + dot(step, vec3(0,0,0))),\n                        random(n + dot(step, vec3(1,0,0))),\n                        u.x),\n                    mix(random(n + dot(step, vec3(0,1,0))),\n                        random(n + dot(step, vec3(1,1,0))),\n                        u.x),\n                u.y),\n                mix(mix(random(n + dot(step, vec3(0,0,1))),\n                        random(n + dot(step, vec3(1,0,1))),\n                        u.x),\n                    mix(random(n + dot(step, vec3(0,1,1))),\n                        random(n + dot(step, vec3(1,1,1))),\n                        u.x),\n                u.y),\n                u.z);\n}\n\nfloat marble(vec3 p) {\n\tfloat m = noise(vec3(10.0 * p.x, 30.0 * (p.x + 0.25 * p.y + p.z), 10.0 * p.z));\n\treturn m * m;\n}\n\nvec3 lerp(vec3 a, vec3 b, float f) {\n\treturn a + f * (b - a);\n}\n\nfloat plintoDist(vec3 p) {\n\tfloat l1 = max(length(max(abs(mod(p.xz, 4.0) - 2.0) - 0.35, 0.0)), p.y + 1.95);\n\tfloat l2 = max(length(max(abs(mod(p.xz, 4.0) - 2.0) - 0.30, 0.0)), p.y + 1.40);\n\tfloat l3 = length(vec3(mod(p.xz, 4.0) - 2.0, 4.0 * (p.y + 1.35))) - 0.25;\n\treturn min(min(l1, l2), l3);\n}\n\nfloat colonnaDist(vec3 p) {\n\treturn length(mod(p.xz, 4.0) - 2.0) - 0.2;\n}\n\nfloat capitelloDist(vec3 p) {\n\tfloat l1 = length(vec3(mod(p.xz, 4.0) - 2.0, 4.0 * (2.0 - p.y))) - 0.35;\n\tfloat l2 = length(vec3(mod(p.xz, 4.0) - 2.0, 4.0 * (1.7 - p.y))) - 0.3;\n\tfloat l3 = max(length(max(abs(mod(p.xz, 4.0) - 2.0) -0.21, 0.0)), 1.7 - p.y);\n\treturn min(min(l1, l2), l3);\n}\n\nfloat soffittoDist(vec3 p) {\n\tfloat voltax = 1.8 - length(vec2(mod(p.z - 2.0, 4.0) - 2.0, p.y - 2.0));\n\tfloat voltaz = 1.8 - length(vec2(mod(p.x - 2.0, 4.0) - 2.0, p.y - 2.0));\n\tfloat ceiling = 2.0 - p.y;\n\treturn max(ceiling, max(voltax, voltaz));\n}\n\nvec3 lampadaVect(vec3 p) {\n\tvec3 v = vec3(-(mod(p.xz + 6., 12.0) - 6.0), 1.5 - p.y);\n\treturn vec3(v.x, v.z, v.y);\n}\n\nfloat lampadaGamboDist(vec3 p) {\n\treturn max(length(mod(p.xz - 6.0, 12.0) - 6.0) - 0.01, 1.7 - p.y);\n}\n\nfloat lampadaGloboDist(vec3 p) {\n\treturn length(lampadaVect(p)) - 0.2;\n}\n\nfloat lampadaDist(vec3 p) {\n\treturn min(lampadaGloboDist(p), lampadaGamboDist(p));\n}\n    \n// distance estimator\nfloat sceneDist(vec3 p) {\n\treturn min(min(plintoDist(p), min(colonnaDist(p), soffittoDist(p))), min(capitelloDist(p), lampadaDist(p)));\n}\n\nfloat illuminazione(vec3 rp, vec3 norm) {\n\tvec3 lv = lampadaVect(rp);\n\tfloat l1 = length(lv) - 0.19; // tolta la dimensione della lampada\n\tfloat v = max(dot(normalize(lv), norm), 0.1); // 0.1 = luce ambiente\n\treturn v * 3.0 / l1; // intensit√† della luce inversamente proporzionale alla distanza\n}\n\n    \n// --------------------------------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec2 mo = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n\n\tvec3 cameraPos = vec3(0., 0., 3. * iTime);\n    \n\t// angolo visuale\n\tvec2 a = 0.8 * uv;\n\tvec3 rayDirection = normalize(vec3(sin(a.x) * cos(a.y), sin(a.y), cos(a.x) * cos(a.y)));\n    \n\t// rotazione vista\n\trayDirection = rotate(rayDirection, 0.25 * PI * mo.y, vec3(1., 0., 0.));\n\trayDirection = rotate(rayDirection, PI * mo.x, vec3(0., 1., 0.));\n    \n\tconst vec3 bgcol = vec3(0.5); // colore foschia\n\tconst vec3 lightcol = vec3(1.00, 0.95, 0.90); // colore luci\n    \n\tvec3 col = bgcol;\n\tfloat depth = 0.0;\n\tfloat depthPav = 1000.0; // distanza dal pavimento\n\tbool mirror = false; // riflesso sul pavimento\n\tvec3 colPav = vec3(1.);\n\n\tconst float threshold = 0.0001; // soglia distanza minima\n\n\t// ray marching\n\tfor (int i = 0; i < 400; i++) {\n\t\tvec3 rayPos = cameraPos + rayDirection * depth;\n\t\tvec3 rayPosPav;\n        \n\t\t// riflessione sul pavimento\n\t\tif(rayPos.y < -2.) {\n\t\t\trayPos.y = -4. - rayPos.y;\n\t\t\tif (!mirror) {\n\t\t\t\tmirror = true;\n\t\t\t\tdepthPav = (cameraPos.y + 2.) / -rayDirection.y;\n\t\t\t\trayPosPav = cameraPos + rayDirection * depthPav;\n\t\t\t\tint b1 = int(mod(rayPosPav.x + rayPosPav.z, 2.0));\n\t\t\t\tint b2 = int(mod(rayPosPav.x - rayPosPav.z, 2.0));\n\t\t\t\tint b3 = (b1 > 0) ? b2 : 1 - b2;\n\t\t\t\t// colore pavimento\n\t\t\t\tcolPav = vec3(0.20 + 0.78 * float(b3), 0.22 + 0.78 * float(b3), 0.20 + 0.76 * float(b3));\n\t\t\t}\n\t\t}\n        \n\t\tfloat dist = sceneDist(rayPos);\n\t\tif (dist < threshold) {\n            \n            // soffitto\n\t\t\t// vettore normale alla superficie (molto approssimato)\n\t\t\tvec3 norm = vec3(0.0, -1.0, 0.0);\n\t\t\tcol = vec3(1.0, 0.9, 0.8);\n\n\t\t\t// plinto\n\t\t\tif(plintoDist(rayPos)  < threshold) {\n\t\t\t\tcol = lerp(vec3(0.45, 0.50, 0.55), vec3(0.25, 0.30, 0.35), marble(rayPos));\n\t\t\t\tvec2 v = mod(rayPos.xz, 4.0) - 2.0;\n\t\t\t\tnorm = normalize(vec3(v.x, 0.0, v.y));\n\t\t\t}\n\t\t\t// colonna\n\t\t\telse if(colonnaDist(rayPos) < threshold) {\n\t\t\t\tcol = lerp(vec3(0.90, 0.90, 0.85), vec3(0.80, 0.60, 0.55), marble(rayPos));\n\t\t\t\tvec2 v = mod(rayPos.xz, 4.0) - 2.0;\n\t\t\t\tnorm = normalize(vec3(v.x, 0.0, v.y));\n\t\t\t}\n\t\t\t// capitello\n\t\t\telse if(capitelloDist(rayPos) < threshold) {\n\t\t\t\tcol = lerp(vec3(0.45, 0.50, 0.55), vec3(0.25, 0.30, 0.35), marble(rayPos));\n\t\t\t\tvec2 v = mod(rayPos.xz, 4.0) - 2.0;\n\t\t\t\tnorm = normalize(vec3(v.x, 0.0, v.y));\n\t\t\t}\n\t\t\t// lampada\n\t\t\telse if (lampadaGamboDist(rayPos) < threshold) col = vec3(0.0);\n\t\t\telse if (lampadaGloboDist(rayPos) < threshold) col = lightcol;\n\n\t\t\t// luci\n\t\t\tcol = col * lightcol * illuminazione(rayPos, norm);\n\t\t\tif (mirror) colPav = colPav * lightcol * illuminazione(rayPosPav, vec3(0.0, 0.3, 0.0));\n            \n\t\t\tcol /= 0.6 + 0.03 * float(i); // accentua i bordi\n\t\t\tbreak;\n        }\n\t\tdepth += dist;\n    }\n\n\t// colore riflesso nel pavimento\n\tif (mirror) col = 0.5 * col + 0.5 * colPav;\n\n\t// fog\n\tcol = lerp(col, bgcol, clamp(1.0 - 10.0 / (min(depthPav, depth) + 5.0), 0., 1.));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}