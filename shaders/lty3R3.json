{
    "Shader": {
        "info": {
            "date": "1475776052",
            "description": "Part 07: Multipart\nIntro to democoding using ShaderToy\nBy cxw/Incline - Demosplash 2016",
            "flags": 0,
            "hasliked": 0,
            "id": "lty3R3",
            "likes": 3,
            "name": "demosplash2016-cxw-07",
            "published": 3,
            "tags": [
                "tutorial",
                "demoparty"
            ],
            "usePreview": 0,
            "username": "cxw",
            "viewed": 521
        },
        "renderpass": [
            {
                "code": "precision highp int;precision highp float;\n\n// Parameters for your demo\n\n// Parts and timing\n#define BLACK_ID (0)\n    // black screen - always starts at 0\n\n#define COLORS_ID (1)\n    // part number.  Use a float if you want to pack it in a vector.\n#define COLORS_START (1.0)\n    // seconds\n#define MOIRE_ID (2)\n#define MOIRE_START (COLORS_START + 5.0)\n\n#define DEMO_DURATION_SEC (15.0)\n    // How long a whole loop is\n#define DEAD_TIME (1.0)\n    // duration of black screen at the end of each part\n\n// blinds\n#define BLIND_CYCLE_TIME (MOIRE_START - COLORS_START)\n#define BLIND_RAMP_TIME (1.0)\n#define NBLINDS (7)\n#define BLIND_EDGE_STEP (0.14285714285714285714285714285714)\n\n// moire\n#define THICKNESS (0.65)\n#define SPACING (200.0)\n#define SPEED (0.6)\n#define FADEOUT_TIME_SEC (2.0)\n\n// Computed parameters //////////////////////////////////////////////////\n#define BLIND_END_RAMPDOWN_TIME (BLIND_CYCLE_TIME - DEAD_TIME)\n#define BLIND_RAMP_RATE (1.0/BLIND_RAMP_TIME)\n#define MOIRE_END_TIME (DEMO_DURATION_SEC - MOIRE_START - DEAD_TIME)\n\n// Library routines and functions from earlier //////////////////////////\n\nvec3 hsv2rgb(vec3 c) {\n    // All inputs range from 0 to 1.  By hughsk, from\n    // https://github.com/hughsk/glsl-hsv2rgb/blob/master/index.glsl .\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n} //hsv2rgb\n\n/*from #04*/ float get_base_y(in float time, in float A, in float b, in float m, in float omega, in float phi) { return abs( A*exp(-b*time/(2.0*m))*cos(omega*time-phi) ); }\n/*from #06*/ float get_sine_01( in float time, in vec2 coords, in vec2 center, in float radius, in float speed) { float whereami = radius*distance(center,coords) - speed*time; return 0.5+0.5*sin(whereami); }\n/*from #06*/ float squish(in float f) { return (f+1.0)*0.5; }\n/*from #06*/ vec2 lisa(in float time, in float a, in float b, in float delta) { return vec2(squish(sin(a*time+delta)), squish (sin(b*time))); }\n\nfloat get_blind_mask(in float percent, in float x_01) {\n    if(percent >= 1.0) { return 1.0; }\n        // because at some resolutions, some pixels were failing **A**, below,\n        // leaving black lines.  ** See debug notes 1 **\n    float edges[NBLINDS+1];\n    for(int edge_idx = 0; edge_idx < NBLINDS+1; ++edge_idx) {\n        float edge_idx_f = float(edge_idx);   //explicit typecast\n        edges[edge_idx] = smoothstep(0.0, 1.0, edge_idx_f * BLIND_EDGE_STEP);\n    } //for each edge\n    for(int blind_idx = 0; blind_idx < NBLINDS; ++blind_idx) {\n        float left_edge = edges[blind_idx]; float right_edge = edges[blind_idx+1]; float center = mix(left_edge, right_edge, 0.5); float open_left = mix(center, left_edge, percent); float open_right = mix(center, right_edge, percent);\n        if( (x_01 >= open_left) && (x_01 <= open_right) ) { // **A**\n            return 1.0;     // This pixel is visible!\n        }\n    } //for each blind\n    return 0.0;     // If we get here, the pixel is hidden by the blinds.\n} //get_blind_mask\n\n// Effect: colors ///////////////////////////////////////////////////////\n\nvec4 do_colors(in float time_in_part, in vec2 pixel_coord_01)\n{ // NOT global time, so we can move the effect around\n    vec4 retval = vec4(     // A nice color stripe pattern\n        hsv2rgb(vec3(pixel_coord_01.x+pixel_coord_01.y + time_in_part,\n                        1.0,1.0)),   1.0);\n\n    // Venetian blinds in, then out, on this.  As in #06.\n    float blind_time = mod(time_in_part, BLIND_CYCLE_TIME);\n    float blind_rise = blind_time * BLIND_RAMP_RATE;\n    float blind_fall = (BLIND_END_RAMPDOWN_TIME - blind_time) * BLIND_RAMP_RATE;\n    float blind_percent = clamp(min(blind_rise, blind_fall), 0.0, 1.0);\n    float blind_mask = get_blind_mask(blind_percent, pixel_coord_01.x);\n    retval = mix(vec4(0.0), retval, blind_mask);\n    return retval;\n} //do_colors\n\n// Effect: moire ////////////////////////////////////////////////////////\n\nvec4 do_moire(in float time, in vec2 pixel_coord_01 )\n{ //used to be mainImage() - now it's moire() and has a \"time\" parameter.\n    // Bounce it in - modify pixel_coord_01.  As in #04.\n    float base_y = get_base_y(time, 1.0, 3.0, 1.0, 4.5, 0.0);\n    vec4 retval = vec4(0.0);    //black by default\n\n    if(pixel_coord_01.y >= base_y) {\n        pixel_coord_01.y -= base_y;     // Shift the base\n\n        // Code from last time\n        vec2 ca=lisa(time*0.5*SPEED,5.0,4.0,0.0); vec2 cb=lisa(time*0.835744*SPEED,3.0,2.0,1.8); cb=mix(ca, cb, 0.6); float sa=get_sine_01(time, pixel_coord_01, ca, SPACING, 10.0); float sb=get_sine_01(time, pixel_coord_01, cb, SPACING, 10.0); sa=step(THICKNESS,sa); sb=step(THICKNESS,sb);\n        //retval = vec4(max(sa,sb),0.0,0.0,1.0);\n        retval = vec4(sa,0.0,sb*(1.0-step(0.1,sa)),1.0);\n        // sb unless sa>=0.1 ^^^^^^^^^^^^^^^^^^^^^\n\n        // Fade out at the end\n        float fade_amount =\n            clamp( (MOIRE_END_TIME - time) / FADEOUT_TIME_SEC, 0.0, 1.0);\n        retval = mix(vec4(0.0), retval, fade_amount);\n    }\n    return retval;\n} //do_moire\n\n// mainImage() //////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = mod(iTime, DEMO_DURATION_SEC);\n        // Now you know one reason _t_ exists!\n    vec2 pixel_coord_01 = fragCoord.xy / iResolution.xy;\n\n    // Which part are we in?\n    int part_id;\n    float time_in_part;\n\n    if(t < COLORS_START) {      //black screen\n        part_id = BLACK_ID;\n    } else if(t < MOIRE_START) {  //colors\n        part_id = COLORS_ID;\n        time_in_part = t - COLORS_START;\n    } else {                    //moire\n        part_id = MOIRE_ID;\n        time_in_part = t - MOIRE_START;\n    }\n\n    // Run that part.  Separate if() block since some parts may share code.\n    if(part_id == BLACK_ID) {                   //black screen\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    } else if(part_id == COLORS_ID) {           //colors\n        fragColor = do_colors(time_in_part, pixel_coord_01);\n    } else {                                    //moire\n        fragColor = do_moire(time_in_part, pixel_coord_01);\n    }\n} //mainImage\n\n// vi: set ts=4 sts=4 sw=4 et ai: //\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}