{
    "Shader": {
        "info": {
            "date": "1641763220",
            "description": "See https://github.com/Fewes/MinimalAtmosphere for original HLSL source",
            "flags": 0,
            "hasliked": 0,
            "id": "fsXcRN",
            "likes": 8,
            "name": "MinimalAtmosphere_GLSL",
            "published": 3,
            "tags": [
                "sky"
            ],
            "usePreview": 0,
            "username": "ForestCSharp",
            "viewed": 455
        },
        "renderpass": [
            {
                "code": "// Copyright (c) 2021 Felix Westin\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// -------------------------------------\n// Defines\n#define EPS                 1e-6\n#define PI                  3.14159265359\n#define INFINITY            1.0 / 0.0\n#define PLANET_RADIUS       6371000.0\n#define PLANET_CENTER       vec3(0, -PLANET_RADIUS, 0)\n#define ATMOSPHERE_HEIGHT   100000.0\n#define RAYLEIGH_HEIGHT     (ATMOSPHERE_HEIGHT * 0.08)\n#define MIE_HEIGHT          (ATMOSPHERE_HEIGHT * 0.012)\n\n// -------------------------------------\n// Coefficients\n#define C_RAYLEIGH          (vec3(5.802, 13.558, 33.100) * 1e-6)\n#define C_MIE               (vec3(3.996,  3.996,  3.996) * 1e-6)\n#define C_OZONE             (vec3(0.650,  1.881,  0.085) * 1e-6)\n\n#define ATMOSPHERE_DENSITY  1.0\n#define EXPOSURE            20.0\n\n// -------------------------------------\n// Math\nvec2 SphereIntersection(vec3 rayStart, vec3 rayDir, vec3 sphereCenter, float sphereRadius)\n{\n\trayStart -= sphereCenter;\n\tfloat a = dot(rayDir, rayDir);\n\tfloat b = 2.0 * dot(rayStart, rayDir);\n\tfloat c = dot(rayStart, rayStart) - (sphereRadius * sphereRadius);\n\tfloat d = b * b - 4.0 * a * c;\n\tif (d < 0.0)\n\t{\n\t\treturn vec2(-1);\n\t}\n\telse\n\t{\n\t\td = sqrt(d);\n\t\treturn vec2(-b - d, -b + d) / (2.0 * a);\n\t}\n}\nvec2 PlanetIntersection(vec3 rayStart, vec3 rayDir)\n{\n\treturn SphereIntersection(rayStart, rayDir, PLANET_CENTER, PLANET_RADIUS);\n}\nvec2 AtmosphereIntersection(vec3 rayStart, vec3 rayDir)\n{\n\treturn SphereIntersection(rayStart, rayDir, PLANET_CENTER, PLANET_RADIUS + ATMOSPHERE_HEIGHT);\n}\n\n// -------------------------------------\n// Phase functions\nfloat PhaseRayleigh(float costh)\n{\n\treturn 3.0 * (1.0 + costh*costh) / (16.0 * PI);\n}\n\nfloat PhaseMie(float costh, float g)\n{\n\tg = min(g, 0.9381);\n\tfloat k = 1.55*g - 0.55*g*g*g;\n\tfloat kcosth = k*costh;\n\treturn (1.0 - k*k) / ((4.0 * PI) * (1.0-kcosth) * (1.0-kcosth));\n}\n\n// -------------------------------------\n// Atmosphere\nfloat AtmosphereHeight(vec3 positionWS)\n{\n\treturn distance(positionWS, PLANET_CENTER) - PLANET_RADIUS;\n}\nfloat DensityRayleigh(float h)\n{\n\treturn exp(-max(0.0, h / RAYLEIGH_HEIGHT));\n}\nfloat DensityMie(float h)\n{\n\treturn exp(-max(0.0, h / MIE_HEIGHT));\n}\nfloat DensityOzone(float h)\n{\n\t// The ozone layer is represented as a tent function with a width of 30km, centered around an altitude of 25km.\n\treturn max(0.0, 1.0 - abs(h - 25000.0) / 15000.0);\n}\nvec3 AtmosphereDensity(float h)\n{\n\treturn vec3(DensityRayleigh(h), DensityMie(h), DensityOzone(h));\n}\n\n// Optical depth is a unitless measurement of the amount of absorption of a participating medium (such as the atmosphere).\n// This function calculates just that for our three atmospheric elements:\n// R: Rayleigh\n// G: Mie\n// B: Ozone\n// If you find the term \"optical depth\" confusing, you can think of it as \"how much density was found along the ray in total\".\nvec3 IntegrateOpticalDepth(vec3 rayStart, vec3 rayDir)\n{\n\tvec2 intersection = AtmosphereIntersection(rayStart, rayDir);\n\tfloat  rayLength    = intersection.y;\n\n\tint    sampleCount  = 8;\n\tfloat  stepSize     = rayLength / float(sampleCount);\n\t\n\tvec3 opticalDepth = vec3(0);\n\n\tfor (int i = 0; i < sampleCount; i++)\n\t{\n\t\tvec3 localPosition = rayStart + rayDir * (float(i) + 0.5) * stepSize;\n\t\tfloat  localHeight   = AtmosphereHeight(localPosition);\n\t\tvec3 localDensity  = AtmosphereDensity(localHeight);\n\n\t\topticalDepth += localDensity * stepSize;\n\t}\n\n\treturn opticalDepth;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth)\n{\n\t// Note that Mie results in slightly more light absorption than scattering, about 10%\n\treturn exp(-(opticalDepth.x * C_RAYLEIGH + opticalDepth.y * C_MIE * 1.1 + opticalDepth.z * C_OZONE) * ATMOSPHERE_DENSITY);\n}\n\n// Integrate scattering over a ray for a single directional light source.\n// Also return the transmittance for the same ray as we are already calculating the optical depth anyway.\nvec3 IntegrateScattering(vec3 rayStart, vec3 rayDir, float rayLength, vec3 lightDir, vec3 lightColor, out vec3 transmittance)\n{\n\t// We can reduce the number of atmospheric samples required to converge by spacing them exponentially closer to the camera.\n\t// This breaks space view however, so let's compensate for that with an exponent that \"fades\" to 1 as we leave the atmosphere.\n\tfloat  rayHeight = AtmosphereHeight(rayStart);\n\tfloat  sampleDistributionExponent = 1.0 + clamp(1.0 - rayHeight / ATMOSPHERE_HEIGHT, 0.0, 1.0) * 8.0; // Slightly arbitrary max exponent of 9\n\n\tvec2 intersection = AtmosphereIntersection(rayStart, rayDir);\n\trayLength = min(rayLength, intersection.y);\n\tif (intersection.x > 0.0)\n\t{\n\t\t// Advance ray to the atmosphere entry point\n\t\trayStart += rayDir * intersection.x;\n\t\trayLength -= intersection.x;\n\t}\n\n\tfloat  costh    = dot(rayDir, lightDir);\n\tfloat  phaseR   = PhaseRayleigh(costh);\n\tfloat  phaseM   = PhaseMie(costh, 0.85 /* Default */);\n\n\tint    sampleCount  = 64;\n\n\tvec3 opticalDepth = vec3(0);\n\tvec3 rayleigh     = vec3(0);\n\tvec3 mie          = vec3(0);\n\n\tfloat  prevRayTime  = 0.0;\n\n\tfor (int i = 0; i < sampleCount; i++)\n\t{\n\t\tfloat  rayTime = pow(float(i) / float(sampleCount), sampleDistributionExponent) * rayLength;\n\t\t// Because we are distributing the samples exponentially, we have to calculate the step size per sample.\n\t\tfloat  stepSize = (rayTime - prevRayTime);\n\n\t\tvec3 localPosition = rayStart + rayDir * rayTime;\n\t\tfloat  localHeight   = AtmosphereHeight(localPosition);\n\t\tvec3 localDensity  = AtmosphereDensity(localHeight);\n\n\t\topticalDepth += localDensity * stepSize;\n\n\t\t// The atmospheric transmittance from rayStart to localPosition\n\t\tvec3 viewTransmittance = Absorb(opticalDepth);\n\n\t\tvec3 opticalDepthlight  = IntegrateOpticalDepth(localPosition, lightDir);\n\t\t// The atmospheric transmittance of light reaching localPosition\n\t\tvec3 lightTransmittance = Absorb(opticalDepthlight);\n\n\t\trayleigh += viewTransmittance * lightTransmittance * phaseR * localDensity.x * stepSize;\n\t\tmie      += viewTransmittance * lightTransmittance * phaseM * localDensity.y * stepSize;\n\n\t\tprevRayTime = rayTime;\n\t}\n\n\ttransmittance = Absorb(opticalDepth);\n\n\treturn (rayleigh * C_RAYLEIGH + mie * C_MIE) * lightColor * EXPOSURE;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //camera position\n    vec3 ray_start = vec3(0,0,0);\n    \n    vec2 mouse_vec = iMouse.xy/iResolution.xy;\n    \n    vec3 cam_dir = normalize(vec3(mouse_vec, 1.0));\n    vec3 u = normalize(cross(cam_dir, vec3(0., 1., 0.)));\n    vec3 v = cross(u, cam_dir);\n    float fdist = 0.3;\n    vec3 ray_dir = normalize(cam_dir*fdist+(fragCoord.x/iResolution.x-0.5)*u+(fragCoord.y-iResolution.y/2.0)/iResolution.x*v);\n    \n    const float ray_length = 1000000000.0f;\n    vec3 light_dir = vec3(0.25,1,0);\n    vec3 light_color = vec3(1,1,1);\n    vec3 transmittance;\n    vec3 sky_color = IntegrateScattering(ray_start, ray_dir, ray_length, light_dir, light_color, transmittance);\n    \n    fragColor = vec4(sky_color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}