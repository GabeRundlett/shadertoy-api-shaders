{
    "Shader": {
        "info": {
            "date": "1571773013",
            "description": "Clicks and pops",
            "flags": 40,
            "hasliked": 0,
            "id": "3stSWn",
            "likes": 4,
            "name": "Shadertober 22 Sounds -jaburns",
            "published": 3,
            "tags": [
                "raymarch",
                "sound",
                "music"
            ],
            "usePreview": 0,
            "username": "jaburns",
            "viewed": 480
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture( iChannel0, fragCoord.xy / iResolution.xy );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define EPS          0.0001\n#define ITERATIONS  99\n#define MAX_DIST   200.0\n#define PI           3.14159265358979\n\n#define TIME  (iTime * PI * .5)\n\nfloat thud()\n{\n    float t = 2.*mod(iTime, .5);\n    return (1. - t) + smoothstep(.9, 1., t);\n}\n\nfloat hat()\n{\n    float t1 = mod(iTime, 4.); \n    t1 = t1 < 3.74 ? 0. : 1. - .2*clamp(t1 - 3.75, 0., 1.);\n    float t = mod(iTime - .5, 1.);\n    t = max(t, t1);\n    return (1. - t) + smoothstep(.9, 1., t);\n}\n\nfloat heroRamp()\n{\n    return clamp((iTime - 4.) /  12., 0., 1.);\n}\n\nmat2 rot( float theta )\n{\n    float c = cos( theta );\n    float s = sin( theta );\n    return mat2( c, s, -s, c );\n}\n\nvec3 repeatRadial( vec3 p )\n{\n    float r = length(p.xy);\n    float t = atan(p.y, p.x);\n    t += 2.*3.14159;\n    float c = 3.14159/6.;\n    t = mod(t - c/2., c) + c/2.;\n    p.xy = r * vec2(cos(t), sin(t));\n    return p;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat tunnel( vec3 p )\n{   \n    p.xy *= rot(0.015*sin(TIME)*p.z);    \n    p.z -= 10.*TIME;\n    p.z = mod(p.z + 2., 4.) - 2.;\n    \n    vec3 q = repeatRadial( p )  - (2.+sin(.5*TIME))*vec3( 5., 3., 0. );\n    return sdHexPrism( q, vec2( 1., thud() ));\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat hero( vec3 p )\n{\n    float R = heroRamp();\n    if (R < .01) {\n        return 10000.;\n    }\n    \n    float T = R*1.2*(.5 + .5*hat());\n    \n    p /= T;\n    \n    float t = TIME;\n    float dist = 1000.;\n    \n    vec3 dim0 = vec3( 2., .75, .75 );\n    vec3 dim1 = vec3( .75, 1.5+sin(TIME), .75 );\n    vec3 dim2 = vec3( .75, .75, 2.+cos(TIME) );\n    \n    mat2 A = rot(0.1 * TIME);\n    mat2 B = rot(0.14 * TIME);\n    mat2 C = rot(0.17 * TIME);\n    mat2 D = rot(0.23 * TIME);\n    \n    for (int i = 0; i < 10; ++i) {\n        p.xz *= A;\n        p.zy *= B; \n        p.yx *= C;\n        p.yz *= D;\n        int m = i % 3;\n        dist = opSmoothUnion(dist, sdEllipsoid( p, m == 0 ? dim0 : m == 1 ? dim1 : dim2 ), 0.5);\n    }\n    return dist * T;\n}\n\nvec2 matMin( vec2 a, vec2 b )\n{\n    return a.x < b.x ? a : b;\n}\n\nvec2 map( vec3 p, bool includeHero )\n{\n    if (! includeHero) return vec2( tunnel( p ), 0. );\n    return matMin(\n        vec2( tunnel( p ), 0. ),\n        vec2( hero( p ), 1. ));\n}\n\nstruct MarchResult\n{\n    float dist;\n    vec3 pos;\n    float ao;\n    float material;\n};\n    \nMarchResult march( vec3 ro, vec3 rd, bool includeHero )\n{\n    vec2 dist;\n    float totalDist = 0.0;\n    int i = 0;\n    for(; i < ITERATIONS; ++i )\n    {\n        dist = map( ro, includeHero );\n        if( dist.x < EPS ) break;\n        totalDist += dist.x;\n        if( totalDist > MAX_DIST ) break;\n        ro += dist.x * rd;\n    }\n    \n    return MarchResult( dist.x < EPS ? totalDist : -1.0, ro, 1.0 - float( i ) / 75.0, dist.y );\n}\n\nvec3 getNormal( vec3 p )\n{\n    vec2 e = vec2( EPS, 0 );\n    return normalize(vec3(\n        map( p + e.xyy, true ).x - map( p - e.xyy, true ).x,\n        map( p + e.yxy, true ).x - map( p - e.yxy, true ).x,\n        map( p + e.yyx, true ).x - map( p - e.yyx, true ).x));\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 sp = fragCoord.xy / iResolution.yy - vec2( .5 * iResolution.x / iResolution.y, .5 );\n    \n    vec3 ro = vec3( 0, 0, 10 );\n    vec3 rd = normalize( vec3( sp, -1 ));    \n    \n    MarchResult m = march( ro, rd, true );\n    \n    float mao = m.ao;\n    float l = smoothstep(.05, .2, length(sp));\n    fragColor = l * vec4(vec3(57., 62., 81.)/255. * (mao),0);\n    \n    if( m.dist > 0. ) {\n        vec3 color;\n        if (m.material > .5) {\n            float R = heroRamp();\n            color = R*vec3(255., 20., 20.)/255.;\n            \n            MarchResult mr = march( m.pos, reflect( rd, getNormal( m.pos ) ), false );\n            if (mr.dist > 0.) \n            \tfragColor.rgb += R*vec3(2. / mr.dist) * vec3(233., 230., 201.)/255.;\n            \n        } else {\n            color = vec3(233., 230., 201.)/255.;\n        }\n            \n        float lightness = m.ao * exp( -0.025 * m.dist );\n        fragColor.rgb = mix( fragColor.rgb, color, lightness);\n        return;\n    }\n    \n    fragColor = .75 * (texture( iChannel0, fragCoord.xy / iResolution.xy ) * .6 + fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//#define DEBUG\n\n#define PI 3.14159265358979\n#define TRACK_LEN 16\n\nconst int KICKS[] = int[]( 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0 );\nconst int HATS[]  = int[]( 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1 );\n\nfloat latestStartTime( float time, const int[TRACK_LEN] track )\n{\n    time *= 4.;\n    \n    float result = -10.;\n    \n    for( int i = 0; i < TRACK_LEN; ++i ) {\n        float t = float( i );\n        if( t >= time ) break;\n        if( track[i] > 0 ) result = t;\n    }\n    \n    return result / 4.;\n}\n\nfloat hash( float i )\n{\n    return fract( sin( i * 12.9898 ) * 43758.5453 );\n}\n    \nfloat funcRand( float x )\n{\n    float a = hash( floor( x ));\n    float b = hash( floor( x + 1. ));\n    return 1. - 2. * mix( a, b, smoothstep( 0., 1., fract( x )));\n}\n\nfloat taylorSquareWave( float x )\n{\n    float result = 0.;\n    \n    for( int i = 1; i <= 5; i += 2 )\n    {\n        float n = float( i );\n        result += 4. / PI / n * sin( n * x );\n    } \n    \n    return result;\n}\n\nfloat kick( float time )\n{\n    float attack = clamp( 400.*time, 0., 1. );\n    float decay = 1. - smoothstep( .4, .5, time );\n    return attack * decay * sin( 220. * pow( time, .65 ));\n}\n\nfloat hat( float time )\n{\n    return .33 * funcRand( 20000. * exp( -10.*time )) * exp( -30.*time );\n}\n\nfloat padFreq( float time )\n{\n    float detune;\n    if( time < 0. ) {\n        detune = 0.;\n    } else {\n        time = mod( time, 12.0 );        \n        if( time < 2. ) detune = 6.3;\n        else if( time < 4. ) detune = 4.1;\n    }    \n            \n    return 32. * pow( 2., detune / 12. );\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    float t = mod( time, float( TRACK_LEN ) / 4. );\n    \n#ifdef DEBUG\n    float sineRamp = 1.;\n    float sqrRamp  = 1.;\n#else\n    float sineRamp = clamp((time - 4.) / 12., 0., 1.);\n    float sqrRamp  = clamp((time - 8.) /  8., 0., 1.);\n#endif\n    \n    float padF = padFreq( time );\n    \n    float signal =\n        1.00 * kick( t - latestStartTime( t, KICKS )) +\n        0.50 * hat( t - latestStartTime( t, HATS )) +\n        0.25 * sqrRamp * taylorSquareWave( 2. * PI * (padF + 2.) * time ) +\n        0.50 * sineRamp * sin( 4. * PI * padF * time );\n    \n    return vec2( signal );\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}