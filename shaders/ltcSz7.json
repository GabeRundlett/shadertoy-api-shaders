{
    "Shader": {
        "info": {
            "date": "1478704374",
            "description": "Animgif remake of davidope's work\nhttp://dvdp.tumblr.com/post/96924050968/testing-toon-shaders-for-an-illustration-project\n\nStill learning distance field modelling and animation.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ltcSz7",
            "likes": 78,
            "name": "Acid geometry",
            "published": 3,
            "tags": [
                "raymarching",
                "cartoon",
                "npr",
                "codevember",
                "dvdp"
            ],
            "usePreview": 0,
            "username": "xorxor",
            "viewed": 2922
        },
        "renderpass": [
            {
                "code": "// Created by XORXOR, 2016\n// Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)\n// https://www.shadertoy.com/view/4ldXR4\n//\n// Remake of davidope's animgif\n// http://dvdp.tumblr.com/post/96924050968/testing-toon-shaders-for-an-illustration-project\n\n#define PI 3.141592653589793\n#define TWO_PI 6.283185307179586\n#define SQRT_2 1.4142135623730951\n\nvec3 hash3( float n )\n{\n    return fract( sin( vec3( n, n + 1.0, n + 2.0 ) ) *\n            vec3( 13.5453123, 31.1459123, 37.3490423 ) );\n}\n\n// from iq\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs( p );\n    return max( q.y - h.y, max( ( q.x * 0.866025 + q.z * 0.5 ), q.z ) - h.x );\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    return ( length( p / r ) - 1.0 ) * min( min( r.x, r.y ), r.z );\n}\n\nvec2 opU( vec2 d2, vec2 d1 )\n{\n    return ( d2.x < d1.x ) ? d2 : d1;\n}\n\nvec2 opS( vec2 d2, vec2 d1 )\n{\n    return( -d1.x > d2.x ) ? vec2( -d1.x, d1.y ) : d2;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 *( b - a ) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\n// from hg_sdf\nfloat sdCapsule( vec3 p, float r, float c )\n{\n    return mix( length( p.yz ) - r,\n                length( vec3( p.y, abs( p.x ) - c, p.z ) ) - r,   step( c, abs( p.x ) ) );\n}\n\nvec2 opRep( vec2 p, vec2 size, vec2 start, vec2 stop )\n{\n    vec2 halfSize = size * 0.5;\n    vec2 c = floor( p / size );\n    p = mod( p , size ) - halfSize;\n    if ( c.y > stop.y )\n    {\n        p.y += size.y * ( c.y - stop.y );\n    }\n    if ( c.y < start.y )\n    {\n        p.y += size.y * ( c.y - start.y );\n    }\n    return p;\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR( inout vec2 p, float a )\n{\n    p = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45( inout vec2 p )\n{\n    p = ( p + vec2( p.y, -p.x ) ) * sqrt( 0.5 );\n}\n\nvec2 sdSmokingCube( vec3 p, float t, float minDistance )\n{\n    vec2 cube = opS( vec2( sdBox( p, vec3( 1.0 ) ), 1.0 ),\n                      vec2( sdBox( p - vec3( 0.0, 0.0, 0.1 ), vec3( 0.72, 0.72, 1.0 ) ), 2.0 ) );\n    vec2 smoke = vec2( 9999.0, 7.0 );\n    vec3 smokeDir = vec3( 1.0 );\n\n    // rendering the smoke from spheres is really slow\n    // trying a quick speedup by checking the distance from the smoke bounding sphere first\n    float smokeBounds = length( p - vec3( 0.5, 0.5, 1.3 ) ) - 1.0;\n    if ( smokeBounds < min( cube.x, minDistance ) )\n    {\n#define NUM_PARTICLES 15\n\n        for ( int i = 0; i < NUM_PARTICLES; i++ )\n        {\n            float pt = fract( t + float( i ) / float( NUM_PARTICLES ) );\n            float d = length( p + vec3( 0.0, 0.0, -0.8 ) +\n                         0.15 - hash3( float( i ) ) * 0.3\n                         - pt * ( smokeDir + 0.5 * hash3( float( i ) ) - vec3( 0.25 ) ) ) - 0.25 * ( 1.0 - pt );\n            smoke.x = min( smoke.x, d );\n        }\n    }\n\n    return opU( cube, smoke );\n}\n\nvec2 sdPyramid( vec3 p, vec2 h )\n{\n    const float a = 0.866025;\n    vec3 q = abs( p );\n    float dx = max( q.x - h.y, max( q.z * a + p.y * 0.5, -p.y ) - h.x * 0.5 );\n    float dz = max( q.z - h.y, max( q.x * a + p.y * 0.5, -p.y ) - h.x * 0.5 );\n    return vec2( max( dx, dz ), 3.0 );\n}\n\nvec2 sdWorm( vec3 p, vec2 t )\n{\n    vec2 q = vec2( length( p.xy ) - t.x, p.z );\n    float dt = length( q ) - t.y;\n\n    vec3 d = abs( p + vec3( 0.0, 1.0, 0.0 ) ) - vec3( t.x * 2.0, t.x, t.x );\n    float dc = min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n\n    return vec2( max( dt, -dc ), 4.0 );\n}\n\nvec2 sdPearl( vec3 p )\n{\n    return opU( vec2( length( p ) - 0.7, 6.0 ),\n                opS( vec2( length( p ) - 1.0, 5.0 ),\n                     vec2( sdHexPrism( p + vec3( 1.0, 0.0, 0.0 ) , vec2( 1.0, 1.1 ) ), 5.0 ) ) );\n}\n\nvec2 sdCloud( vec3 p )\n{\n    float d = sdCapsule( p, 0.5, 1.0 );\n    d = smin( d, length( p + vec3( 0.0, -0.3, 0.0 ) ) - 0.6, 0.7 );\n    d = smin( d, length( p + vec3( 0.3, 0.4, 0.0 ) ) - 0.2, 0.7 );\n    d = smin( d, length( p + vec3( -0.4, 0.35, -0.1 ) ) - 0.3, 0.2 );\n\n    return vec2( d, 6.0 );\n}\n\nvec2 map( vec3 pos )\n{\n    float t = iTime * 0.4;\n    float tMod = fract( t );\n\n    vec2 plane = vec2( abs( pos.y + 1.0 ), 0.0 );\n\n    float pyramidSize = tMod * 1.16;\n    vec2 pyramidBottom = sdPyramid( pos + vec3( 3.0, 1.0 - pyramidSize * 0.5, -2.0 ),\n                              vec2( pyramidSize ) );\n    vec2 pyramidTop = sdPyramid( pos + vec3( 3.0, 0.4 - pyramidSize * 1.7, -2.0 ),\n                              vec2( 1.16 - pyramidSize ) );\n\n    float wormOffset = tMod * -2.0;\n    wormOffset += ( wormOffset <= -1.0 ) ? 2.0 : 0.0;\n    wormOffset /= SQRT_2;\n    vec3 wormPos = pos + vec3( 0.0 + wormOffset, 1.0, -4.0 + wormOffset );\n    pR45( wormPos.xz );\n    pR( wormPos.xy, tMod * TWO_PI );\n    vec2 worm = sdWorm( wormPos, vec2( 1.0, 0.5 ) );\n\n    vec3 pearlPos = pos - vec3( 3.0, 0.0, 2.0 );\n    pR( pearlPos.xz, tMod * TWO_PI );\n    vec2 pearl = sdPearl( pearlPos );\n\n    float cloudSpeed = ( tMod * -8.0 ) * SQRT_2;\n    vec3 cloudPos = pos - vec3( 4.0 + cloudSpeed, 3.0, 0.0 + cloudSpeed );\n    pR45( cloudPos.xz );\n    cloudPos.xz = opRep( cloudPos.xz, vec2( 8.0 ) , vec2( 0.0 ), vec2( 0.0 ) );\n    vec2 cloud = sdCloud( cloudPos );\n\n    vec2 res = opU( pyramidBottom,\n               opU( pyramidTop,\n               opU( worm,\n               opU( pearl,\n               opU( cloud, plane ) ) ) ) );\n\n    vec2 cube = sdSmokingCube( pos, tMod, res.x );\n\n    return opU( cube, res );\n}\n\nvec2 scene( vec3 ro, vec3 rd )\n{\n    float t = 0.01;\n    for ( int i = 0; i < 100; i++ )\n    {\n        vec3 pos = ro + t * rd;\n        vec2 res = map( pos );\n        if ( res.x < 0.01 )\n        {\n            return vec2( t, res.y );\n        }\n        t += res.x;\n    }\n    return vec2( -1.0 );\n}\n\n// from eiffie\n// https://www.shadertoy.com/view/4ss3WB\nfloat calcEdge( vec3 pos )\n{\n    vec3 eps = vec3( 0.05, 0.0, 0.0 );\n    float d000 = map( pos ).x;\n    float d_100 = map( pos - eps.xyy ).x;\n    float d100 = map( pos + eps.xyy ).x;\n    float d0_10 = map( pos - eps.yxy ).x;\n    float d010 = map( pos + eps.yxy ).x;\n    float d00_1 = map( pos - eps.yyx ).x;\n    float d001 = map( pos + eps.yyx ).x;\n    float edge = abs( d000 - 0.5 * ( d_100 + d100 ) ) +\n                 abs( d000 - 0.5 * ( d0_10 + d010 ) ) +\n                 abs( d000 - 0.5 * ( d00_1 + d001 ) );\n\n    return clamp( 1.0 - edge * 200.0, 0.0, 1.0 );\n}\n\nfloat calcShadow( vec3 ro, vec3 rd, float mint, float maxt )\n{\n    float t = mint;\n    float res = 1.0;\n    for ( int i = 0; i < 20; i++ )\n    {\n        float h = map( ro + rd * t ).x;\n        res = min( res, 22.0 * h / t );\n        t += h;\n        if ( ( h < 0.001 ) || ( t > maxt ) )\n        {\n            break;\n        }\n    }\n    return clamp( res + 0.7, 0.0, 1.0 );\n}\n\nvec3 generateRay( vec2 fragCoord, vec3 eye, vec3 target )\n{\n    vec2 uv = ( fragCoord.xy - 0.5 * iResolution.xy ) / iResolution.y;\n    vec3 cw = normalize( target - eye );\n    vec3 cu = cross( cw, vec3( 0, 1, 0 ) );\n    vec3 cv = cross( cu, cw );\n    mat3 cm = mat3( cu, cv, cw );\n    vec3 rd = cm * normalize( vec3( uv, 2.5 ) );\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mo = 2.0 + 0.5 * iMouse.x / iResolution.x;\n    vec3 target = vec3( 1.0, 0.0, 0.0 );\n    vec3 eye = vec3( 20.0 * cos( mo ), 6.0, 20.0 * sin( mo ) );\n    vec3 rd = generateRay( fragCoord.xy, eye, target );\n    vec3 rdLeft = generateRay( fragCoord.xy + vec2( 2.0, 0.0 ), eye, target );\n    vec3 rdBottom = generateRay( fragCoord.xy + vec2( 0.0, 2.0 ), eye, target );\n\n    vec3 col = vec3( 1.0, 0.0, 1.0 );\n    vec2 res = scene( eye, rd );\n    float edge = 1.0;\n    if ( res.x > 0.0 )\n    {\n        vec3 pos = eye + res.x * rd;\n        col = res.y < 0.5 ? vec3( 0.29, 0.00, 0.47 ) :\n              res.y < 1.5 ? vec3( 0.20, 0.64, 0.38 ) :\n              res.y < 2.5 ? vec3( 0.93, 0.20, 0.0 ) :\n              res.y < 3.5 ? vec3( 0.90, 0.81, 0.14 ) :\n              res.y < 4.5 ? vec3( 0.81, 0.00, 0.28 ) :\n              res.y < 5.5 ? vec3( 0.07, 0.31, 0.82 ) :\n              res.y < 6.5 ? vec3( 1.0 ) :\n              res.y < 7.5 ? vec3( 0.13 ) : vec3( 0.0 );\n\n        edge = calcEdge( pos );\n\n        vec3 ldir = normalize( vec3( -7.0, 13.0, 7.0 ) );\n        float sh = calcShadow( pos, ldir, 0.1, 8.0 );\n        col *= sh;\n    }\n\n    if ( res.y < 0.5 || res.y > 3.5 )\n    {\n        // edge detection by iq\n        // https://www.shadertoy.com/view/4slSWf\n        vec2 resLeft = scene( eye, rdLeft );\n        vec2 resBottom = scene( eye, rdBottom );\n        edge = clamp( 1.0 - 1.0 * max( abs( res.x - resLeft.x ), abs( res.y - resBottom.y ) ), 0.0, 1.0 );\n    }\n\n    col *= edge;\n\n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}