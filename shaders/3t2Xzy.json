{
    "Shader": {
        "info": {
            "date": "1566304770",
            "description": "based on https://en.wikipedia.org/wiki/File:Belt_Trick.ogv",
            "flags": 0,
            "hasliked": 0,
            "id": "3t2Xzy",
            "likes": 9,
            "name": "Belt Trick",
            "published": 3,
            "tags": [
                "raymarcher"
            ],
            "usePreview": 0,
            "username": "_polymath",
            "viewed": 561
        },
        "renderpass": [
            {
                "code": "#define MAXITERS 300.0\n#define LENFACTOR .25\n#define NDELTA 0.001\n\n// #define GRIDCOLS\n#define LIGHTING\n// #define NORMALS\n#define COLOURS\n//#define SPINCAM\n#define SPINSPEED 0.3\n//#define SPINUP\n//#define DRAW_AXIS\n\n#define NDELTAX vec3(NDELTA, 0., 0.)\n#define NDELTAY vec3(0., NDELTA, 0.)\n#define NDELTAZ vec3(0., 0., NDELTA)\n\nfloat box(vec3 p, vec3 centre, vec3 dims) {\n    vec3 d = abs(p - centre) - dims;\n    return max(d.x, max(d.y, d.z));\n}\n\nconst vec3 rDir = normalize(vec3(-3.0, 4.0, -2.0)), rCol = vec3(1.0, 0.6, 0.4),\n    bDir = normalize(vec3(2.0, 3.0, -4.0)), bCol = vec3(0.3, 0.7, 1.0),\n    gDir = normalize(vec3(4.0, -3.0, 0.0)), gCol = vec3(0.7, 1.0, 0.8);\n\n// from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    // axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, // 0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, // 0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);          // 0.0,\n               // 0.0,                                0.0,                                0.0,                                1.0);\n}\n\nconst float pi = 3.1415926536;\n\nmat2 rot(float t) {\n\tfloat s = sin(t), c = cos(t);\n    return mat2(c, s, -s, c);\n}\n\nvec3 axis() {\n    return vec3(\n        cos(iTime * SPINSPEED),\n        0.,\n        sin(iTime * SPINSPEED));\n}\n\nvec3 rotSpace(vec3 p) {\n    // rotate space!!!\n    float angle = pi * pow(smoothstep(100., 2., dot(p, p)), 5.);\n    #ifdef SPINUP\n    \tangle *= smoothstep(10.0, 15.0, iTime);\n    #endif\n    if (angle <= 0.) return p;\n    return p * rotationMatrix(axis(), angle);\n}\n\nfloat scene(vec3 p) {\n    p = rotSpace(p);\n    \n    float l = iTime * 0.2 - .2;\n    l = max(0., min(pow(l, 6.), 1000.));\n    float d = min(box(p, vec3(0.), vec3(0.7, 0.1, l)),\n              min(box(p, vec3(0.), vec3(0.1, l, 0.7)),\n              min(box(p, vec3(0.), vec3(l, 0.7, 0.1)),\n                  box(p, vec3(0.), vec3(1.))\n              )));\n    #ifdef DRAW_AXIS\n    \tvec3 a = axis();\n    \td = min(d, length(cross(p, a)) - 0.1);\n    #endif\n    return d;\n}\n    \nvec3 sceneNormal(vec3 p) {\n    return normalize(vec3(\n        scene(p + NDELTAX) - scene(p - NDELTAX),\n        scene(p + NDELTAY) - scene(p - NDELTAY),\n        scene(p + NDELTAZ) - scene(p - NDELTAZ)\n\t));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec3 ray = normalize(vec3(uv, 1.));\n    ray.yz *= rot(-0.12);\n    ray.xz *= rot(-0.7853981634);\n    vec3 cam = vec3(10., 2., -10.);\n    #ifdef SPINCAM\n    \tcam.xz *= rot(pi * 0.75 - iTime * SPINSPEED);\n    \tray.xz *= rot(pi * 0.75 - iTime * SPINSPEED);\n    #endif\n    \n    vec3 pos = cam;\n    float i = 0.;\n    for (; i < MAXITERS; ++i) {\n        float dist = scene(pos);\n        if (dist < 0.001) break;\n        pos += ray * dist * LENFACTOR;\n    }\n\n    #ifdef GRIDCOLS\n    \tfragColor = vec4(fract(pos), 1.);\n    #endif\n    \n    #ifdef NORMALS\n    \tfragColor = vec4(sceneNormal(pos) * 0.5 + 0.5, 1.);\n    #endif\n    \n    #ifdef LIGHTING\n        vec3 col = vec3(1.);\n        #ifdef COLOURS\n            vec3 p2 = rotSpace(pos);\n            if (abs(p2.x) > 1.001) col = vec3(1., .757, .224);\n            else if (abs(p2.y) > 1.001) col = vec3(0., .576, .5255);\n            else if (abs(p2.z) > 1.001) col = vec3(.2902, .204, .365);\n        #endif\n    \tfragColor = vec4(col * (\n            rCol * abs(dot(rDir, sceneNormal(pos))) +\n            gCol * pow(dot(gDir, sceneNormal(pos)), 5.) +\n            bCol * abs(dot(bDir, sceneNormal(pos)))\n        ), 1.0) * (1.0 - pow(i / 300., 2.));\n    #endif\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}