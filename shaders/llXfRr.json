{
    "Shader": {
        "info": {
            "date": "1510763647",
            "description": "the idea is to rotate the fractal based on distance from the camera.\ni used it to make this gif https://media.giphy.com/media/l2QE1mlTRVy7Y7Hfa/giphy.gif",
            "flags": 0,
            "hasliked": 0,
            "id": "llXfRr",
            "likes": 244,
            "name": "fractal trees gif",
            "published": 3,
            "tags": [
                "fractal",
                "raymarch",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "macbooktall",
            "viewed": 279527
        },
        "renderpass": [
            {
                "code": "#define MAXDIST 50.\n\nstruct Ray {\n\tvec3 ro;\n    vec3 rd;\n};\n  \n// from netgrind\nvec3 hue(vec3 color, float shift) {\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI     = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ     = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR   = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG   = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB   = vec3 (1.0, -1.107, 1.704);\n\n    // Convert to YIQ\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I      = dot (color, kRGBToI);\n    float   Q      = dot (color, kRGBToQ);\n\n    // Calculate the hue and chroma\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    // Make the user's adjustments\n    hue += shift;\n\n    // Convert back to YIQ\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    // Convert back to RGB\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n    color.r = dot (yIQ, kYIQToR);\n    color.g = dot (yIQ, kYIQToG);\n    color.b = dot (yIQ, kYIQToB);\n\n    return color;\n}\n\n// ------\n\n// by iq\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat length6( vec3 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y + p.z, 1.0/6.0 );\n}\n\n// ------\n\n// from hg_sdf \n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// -------\n\n\nfloat fractal(vec3 p)\n{\n    const int iterations = 20;\n\t\n    float d = iTime*5. - p.z;\n   \tp=p.yxz;\n    pR(p.yz, 1.570795);\n    p.x += 6.5;\n\n    p.yz = mod(abs(p.yz)-.0, 20.) - 10.;\n    float scale = 1.25;\n    \n    p.xy /= (1.+d*d*0.0005);\n    \n\tfloat l = 0.;\n\t\n    for (int i=0; i<iterations; i++) {\n\t\tp.xy = abs(p.xy);\n\t\tp = p*scale + vec3(-3. + d*0.0095,-1.5,-.5);\n        \n\t\tpR(p.xy,0.35-d*0.015);\n\t\tpR(p.yz,0.5+d*0.02);\n\t\t\n        l =length6(p);\n\t}\n\treturn l*pow(scale, -float(iterations))-.15;\n}\n\nvec2 map(vec3 pos) \n{\n    float dist = 10.; \n    dist = opU(dist, fractal(pos));\n    dist = smin(dist, fPlane(pos,vec3(0.0,1.0,0.0),10.), 4.6);\n    return vec2(dist, 0.);\n}\n\nvec3 vmarch(Ray ray, float dist)\n{   \n    vec3 p = ray.ro;\n    vec2 r = vec2(0.);\n    vec3 sum = vec3(0);\n    vec3 c = hue(vec3(0.,0.,1.),5.5);\n    for( int i=0; i<20; i++ )\n    {\n        r = map(p);\n        if (r.x > .01) break;\n        p += ray.rd*.015;\n        vec3 col = c;\n        col.rgb *= smoothstep(.0,0.15,-r.x);\n        sum += abs(col)*.5;\n    }\n    return sum;\n}\n\nvec2 march(Ray ray) \n{\n    const int steps = 50;\n    const float prec = 0.001;\n    vec2 res = vec2(0.);\n    \n    for (int i = 0; i < steps; i++) \n    {        \n        vec2 s = map(ray.ro + ray.rd * res.x);\n        \n        if (res.x > MAXDIST || s.x < prec) \n        {\n        \tbreak;    \n        }\n        \n        res.x += s.x;\n        res.y = s.y;\n        \n    }\n   \n    return res;\n}\n\nvec3 calcNormal(vec3 pos) \n{\n\tconst vec3 eps = vec3(0.005, 0.0, 0.0);\n                          \n    return normalize(\n        vec3(map(pos + eps).x - map(pos - eps).x,\n             map(pos + eps.yxz).x - map(pos - eps.yxz).x,\n             map(pos + eps.yzx).x - map(pos - eps.yzx).x ) \n    );\n}\n\nvec4 render(Ray ray) \n{\n    vec3 col = vec3(0.);\n\tvec2 res = march(ray);\n   \n    if (res.x > MAXDIST) \n    {\n        return vec4(col, 50.);\n    }\n    \n    vec3 pos = ray.ro+res.x*ray.rd;\n    ray.ro = pos;\n   \tcol = vmarch(ray, res.x);\n    \n    col = mix(col, vec3(0.), clamp(res.x/50., 0., 1.));\n   \treturn vec4(col, res.x);\n}\n\nmat3 camera(in vec3 ro, in vec3 rd, float rot) \n{\n\tvec3 forward = normalize(rd - ro);\n    vec3 worldUp = vec3(sin(rot), cos(rot), 0.0);\n    vec3 x = normalize(cross(forward, worldUp));\n    vec3 y = normalize(cross(x, forward));\n    return mat3(x, y, forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.y -= uv.x*uv.x*0.15;\n    vec3 camPos = vec3(3., -1.5, iTime*5.);\n    vec3 camDir = camPos+vec3(-1.25,0.1, 1.);\n    mat3 cam = camera(camPos, camDir, 0.);\n    vec3 rayDir = cam * normalize( vec3(uv, .8));\n    \n    Ray ray;\n    ray.ro = camPos;\n    ray.rd = rayDir;\n    \n    vec4 col = render(ray);\n    \n\tfragColor = vec4(1.-col.xyz,clamp(1.-col.w/MAXDIST, 0., 1.));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}