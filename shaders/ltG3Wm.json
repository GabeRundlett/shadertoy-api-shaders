{
    "Shader": {
        "info": {
            "date": "1475009038",
            "description": "Burning Ship fractal. Click to zoom!",
            "flags": 32,
            "hasliked": 0,
            "id": "ltG3Wm",
            "likes": 2,
            "name": "Zoomable Burning Ship",
            "published": 3,
            "tags": [
                "fractal",
                "burning",
                "ship"
            ],
            "usePreview": 0,
            "username": "sixstring982",
            "viewed": 805
        },
        "renderpass": [
            {
                "code": "#define TAU 6.28318530718\n\n#define COLOR_MAP_CHANGE_DURATION 5.0\n#define COLOR_MAP_SEED 1.23245e3\n#define MAX_ITERS 2048\n\n// Set to 1 to see mandelbrot set instead\n#define MANDELBROT 0\n\n// from https://www.shadertoy.com/view/4djSRW (thanks Dave_Hoskins)\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));    \n}\n\n\n\n#define RAM_SIZE 128.0\n\n// Convert a linear index to a vec2 used to \n// index into the 128 * 128 virtual \"RAM\".\nvec2 cellFromIndex(float idx) {\n    return vec2(floor(idx / RAM_SIZE), floor(mod(idx, RAM_SIZE))) / iChannelResolution[0].xy;\n}\n\n// Read a value from \"RAM\", given an index.\n// This assumes that \"RAM\" is a 128 * 128 region,\n// which gives 128 * 128 = 16384 floats of memory.\n// This function assumes that this is indexed linearly,\n// sort of like RAM would be indexed in C.\nvec4 read(in float index) {\n    return texture(iChannel0, cellFromIndex(index));\n}\n\n\n\nvec4 getZoomWindow() {\n    return read(12.0);\n}\n\nvec2 complexSquare(vec2 z) {\n    return vec2(z.x * z.x - z.y * z.y,\n                2.0 * z.x * z.y);\n}\n\nfloat burningShip(in vec2 z) {\n    vec2 c = z;\n    \n    int f;\n    for (int i = 0; i < MAX_ITERS; i++) {\n        f = i;\n        if (length(z) > 4.0) {\n            break;\n        }\n        \n        #if MANDELBROT\n        z = complexSquare(z) + c;\n        #else\n        z = complexSquare(abs(z)) + c;\n        #endif\n    }\n    \n    if (f == MAX_ITERS - 1) {\n        return 0.0;\n    }\n    \n    return float(f) / float(MAX_ITERS);\n}\n\nfloat colorMapSeed() {\n    return hash11(floor((iTime + COLOR_MAP_SEED) / COLOR_MAP_CHANGE_DURATION));\n}\n\nfloat colorChannel(float s, float x) {\n    vec4 p = hash41(s);\n    return p.x + p.y * cos(TAU * (p.z + p.w * x));\n}\n\nvec3 colorMap(float n) {\n    float seed = colorMapSeed();\n    vec3 seeds = hash31(seed);\n    \n    float x = (iTime + log2(n * 240.0)) / COLOR_MAP_CHANGE_DURATION;\n    \n    return vec3(colorChannel(seeds.x, x),\n                colorChannel(seeds.y, x),\n                colorChannel(seeds.z, x));\n}\n\nvec4 colorFor(vec2 uv) {\n    float iters = burningShip(uv);\n    if (iters == 0.0) {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    } else {\n\t\treturn vec4(colorMap(burningShip(uv)),1.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 window = getZoomWindow();\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv - vec2(0.5)) * window.xy + window.zw;\n    \n    fragColor = colorFor(uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define RAM_SIZE 128.0\n\n// Convert a linear index to a vec2 used to \n// index into the 128 * 128 virtual \"RAM\".\nvec2 cellFromIndex(float idx) {\n    return vec2(floor(idx / RAM_SIZE), floor(mod(idx, RAM_SIZE))) / iChannelResolution[0].xy;\n}\n\n// Read a value from \"RAM\", given an index.\n// This assumes that \"RAM\" is a 128 * 128 region,\n// which gives 128 * 128 = 16384 floats of memory.\n// This function assumes that this is indexed linearly,\n// sort of like RAM would be indexed in C.\nvec4 read(in float index) {\n    return texture(iChannel0, cellFromIndex(index));\n}\n\n// Checks to see if the current fragCoord is in a \n// target RAM cell. This allows checking for each\n// cell in parallel.\nbool isCell(in vec2 uv, in float index) {\n    vec2 target = cellFromIndex(index);\n    return uv.x >= target.x - 0.005 &&\n           uv.x <= target.x + 0.005 &&\n           uv.y >= target.y - 0.005 &&\n           uv.y <= target.y + 0.005;\n}\n\nbool mouseEdgeDetect() {\n    vec4 oldMouse = read(0.0);\n    return oldMouse.z < 0.5 && iMouse.z > 0.5 &&\n           oldMouse.w < 0.5 && iMouse.w > 0.5;\n}\n    \nvec4 initialize(in vec2 uv) {\n    if (isCell(uv, 0.0)) {\n        // Cache mouse clicks to detect clicks\n        return iMouse;\n    } else if (isCell(uv, 12.0)) {\n        return vec4(4.0, -3.2, -0.4, -0.4);\n    }\n    \n    return vec4(0.0);\n}\n\nvec4 update(in vec2 uv) {\n    if (isCell(uv, 0.0)) {\n        return iMouse;\n    } else if (isCell(uv, 12.0)) {\n        vec4 oldWindow = read(12.0);\n        if (mouseEdgeDetect()) {\n            vec2 dims = oldWindow.xy / 2.0;\n            vec2 relative = (iMouse.zw / iChannelResolution[0].xy) * oldWindow.xy;\n            vec2 center = relative + oldWindow.zw;\n            vec2 newPos = center - dims;\n            return vec4(dims, newPos);\n        } else {\n            return oldWindow;\n        }\n    }\n    \n    return vec4(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    if (iTime < 1.0) {\n        fragColor = initialize(uv);\n    } else {\n        fragColor = update(uv);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}