{
    "Shader": {
        "info": {
            "date": "1664189080",
            "description": "This shader uses interval arithmetic to draw implicit surfaces. Keyboard/mouse controls listed in Buffer A. ",
            "flags": 48,
            "hasliked": 0,
            "id": "7tKfz1",
            "likes": 50,
            "name": "Implicit Surface Renderer",
            "published": 3,
            "tags": [
                "3d",
                "interactive",
                "plotter",
                "arithmetic",
                "interval"
            ],
            "usePreview": 1,
            "username": "fad",
            "viewed": 1376
        },
        "renderpass": [
            {
                "code": "//-------------------------Implicit Surface Renderer--------------------------//\n\n// How It Works:\n// This shader raytraces implicit surfaces by recursively subdividing the ray,\n// calculating bounding boxes for sections of the ray and using interval\n// arithmetic to test for the possible presence of solutions to f(x,y,z)=0\n// within the bounding boxes.\n\n// Implicit Surface Equation:\n// This function uses interval types (defined in the Common tab).\niFloat f(iFloat x, iFloat y, iFloat z) {\n    // Heart \n    // Pulse from https://www.shadertoy.com/view/XsfGRn\n    // Implicit Equation from https://www.shadertoy.com/view/XtXGR8\n    float tt = mod(iTime, 1.5) / 1.5;\n    float ss = pow(tt, 0.2) * 0.5 + 0.5;\n    iFloat iss = iAdd(1.0, iMul(ss * 0.5 * exp(-tt * 4.0), iSin(iAdd(tt * 6.0 * PI, iMul(0.5, y)))));\n    x = iMul(x, iAdd(0.5, iMul(iss, 0.5)));\n    y = iMul(y, iSub(1.5, iMul(iss, 0.5)));\n    z = iMul(z, iAdd(0.5, iMul(iss, 0.5)));\n    iFloat xx = iSquare(x);\n    iFloat yy = iSquare(y);\n    iFloat zz = iSquare(z);\n    iFloat yyy = iMul(yy, y);\n    iFloat a = iSub(iAdd(iAdd(xx, iMul(2.25, zz)), yy), 1.0);\n    return iSub(iMul(iMul(a, a), a), iMul(iAdd(xx, iMul(0.1125, zz)), yyy));\n\n    // Genus 2\n    //iFloat x2 = iSquare(x);\n    //iFloat y2 = iSquare(y);\n    //iFloat z2 = iSquare(z);\n    //return iIf(\n    //    iAND(iLessThan(iAbs(x), 2.0), iLessThan(iAbs(z), 2.0)),\n    //    iAdd(\n    //        iAdd(\n    //            iMul(iMul(iMul(2.0, z), iSub(z2, iMul(3.0, x2))), iSub(1.0, y2)), \n    //            iSquare(iAdd(x2, z2))\n    //        ), \n    //        iMul(iSub(iMul(9.0, y2), 1.0), iSub(y2, 1.0))\n    //    ),\n    //    ifloat(1.0)\n    //);\n\n    // Sphere\n    //return iSub(iAdd(iAdd(iSquare(x), iSquare(y)), iSquare(z)), 2.0);\n}\n\n// Ray Domain:\nconst float tMin = 0.001;\nconst float tMax = 100.0;\n\n// Precision:\n// The amount of times to recursively subdivide the ray. \nconst int maxDepth = 20;\n// The depth of the quadtree used to search for grid lines.\nconst int maxGridLineDepth = 10;\n\n// Discontinuity Tolerance:\n// If the interval returned by the implicit function over a section of the ray\n// has a width bigger than or equal to discontinuityTolerance, that section is\n// counted as containing a discontinuity and is not counted as an intersection.\n// It can be set to INFINITY if the surface is known to be continous.\nconst float discontinuityTolerance = 1000.0 * (tMax - tMin) / pow(2.0, float(maxDepth - 1));\n\n// Display Settings:\nconst float fovY = 50.0;\nconst bool doVignette = true;\nconst bool useCubemapAsBackgroundForPBR = true;\n\nconst bool renderGridLines = true;\nconst float gridLineSpacing = 0.4;\nconst float gridLineWidth = 0.02;\n\n// Rendering Mode:\nconst int regular = 1;\nconst int pbr = 2;\nconst int normalMap = 3;\n\nconst int renderingMode = pbr;\n\n\n\n//============================================================================//\n\n\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n\n// Main Intersection Function:\n// Performs a depth-first search of the ray's t domain, descending if the\n// current segment possibly contains an intersection. Once the max depth is\n// reached, if there's still an intersection in the segment and it is also \n// considered continous, then it is counted as an intersection and returned.\nfloat intersect(Ray r) {\n    if (maxDepth < 1) {\n        return -1.0;\n    }\n    \n    float tRange = tMax - tMin;\n    int depth = 0;\n    int pos = 0;\n    \n    while (true) {\n        // Calculate the current t domain at this location in the tree\n        float size = float(1 << depth);\n        iFloat ti = iFloat(\n            tMin + tRange * float(pos) / size,\n            tMin + tRange * float(pos + 1) / size\n        );\n        // Find the bounding box of the ray segment and use it to calculate an\n        // interval of possible values for f\n        iFloat fi = f(\n            iAdd(r.o.x, iMul(r.d.x, ti)),\n            iAdd(r.o.y, iMul(r.d.y, ti)),\n            iAdd(r.o.z, iMul(r.d.z, ti))\n        );\n        \n        if (fi.u < 0.0 || 0.0 <= fi.l || depth == maxDepth - 1) {\n            if (fi.l <= 0.0 && 0.0 <= fi.u && fi.u - fi.l < discontinuityTolerance) {\n                // We are at a leaf of the tree and there appears to be an\n                // intersection, so return it\n                return (ti.l + ti.u) / 2.0;\n            }\n\n            // The segment of the ray this node of the tree represents\n            // definitely does not contain any intersections, so don't descend\n            // into its children and instead move onto the next node in the DFS\n            while (pos % 2 == 1) {\n                --depth;\n                pos /= 2;\n            }\n            \n            ++pos;\n            \n            if (depth == 0 && pos == 1) {\n                // We are back at the root of the tree after having searched the\n                // entire tree, so break out of the loop\n                break;\n            }\n\n            continue;\n        }\n        \n        // Descend the tree to look for possible intersections\n        ++depth;\n        pos *= 2;\n    }\n    \n    // There were no intersections\n    return -1.0;\n}\n\n// Grid Line Intersection Function: \n// too lazy to explain ;)\n// why does it have to be so complicated to get constant width grid lines!?!?\n\nconst int xAxis = 0;\nconst int yAxis = 1;\nconst int zAxis = 2;\n\nbool intersectsGridLine(vec3 p, int axis) {\n    if (maxGridLineDepth < 1) {\n        return false;\n    }\n    \n    float t = p.x;\n    float u = p.y;\n    float v = p.z;\n    float w = gridLineWidth;\n    float s = gridLineSpacing;\n    float uMin = u - w / 2.0;\n    float vMin = v - w / 2.0;\n    int depth = 0;\n    int uPos = 0;\n    int vPos = 0;\n    \n    while (true) {\n        float size = float(1 << depth);\n        iFloat ui = iFloat(uMin + w * float(uPos) / size, uMin + w * float(uPos + 1) / size);\n        iFloat vi = iFloat(vMin + w * float(vPos) / size, vMin + w * float(vPos + 1) / size);\n        iFloat ti = ifloat(s * round(t / s));\n        iFloat di = iAdd(iAdd(iSquare(iSub(u, ui)), iSquare(iSub(v, vi))), (ti.l - t) * (ti.l - t));\n        iFloat fi;\n        \n        switch (axis) {\n            case xAxis: fi = f(ti, ui, vi); break;\n            case yAxis: fi = f(vi, ti, ui); break;\n            case zAxis: fi = f(ui, vi, ti); break;\n        }\n                          \n        if (depth == maxGridLineDepth - 1 && di.u <= w * w / 4.0 && fi.l <= 0.0 && 0.0 <= fi.u) {\n            return true;\n        }\n        \n        if (di.l > w * w / 4.0 || 0.0 < fi.l || fi.u < 0.0 || depth == maxGridLineDepth - 1) {\n            while (uPos % 2 == 1 && vPos % 2 == 1) {\n                --depth;\n                uPos /= 2;\n                vPos /= 2;\n            }\n            \n            if (vPos % 2 == 0) {\n                ++vPos;\n            } else {\n                ++uPos;\n                --vPos;\n            }\n            \n            if (depth == 0 && vPos == 1) {\n                break;\n            }\n            \n            continue;\n        }\n\n        ++depth;\n        uPos *= 2;\n        vPos *= 2;\n    }\n    \n    return false;\n}\n\nbool isPointInGridLine(vec3 p) {\n    return renderGridLines && (\n        intersectsGridLine(p.xyz, xAxis) ||\n        intersectsGridLine(p.yzx, yAxis) || \n        intersectsGridLine(p.zxy, zAxis)\n    );\n}\n\nvec3 normal(vec3 p) {\n    const float e = 1e-3;\n    return normalize(vec3(\n        f(ifloat(p.x + e), ifloat(p.y), ifloat(p.z)).l - f(ifloat(p.x - e), ifloat(p.y), ifloat(p.z)).l,\n        f(ifloat(p.x), ifloat(p.y + e), ifloat(p.z)).l - f(ifloat(p.x), ifloat(p.y - e), ifloat(p.z)).l,\n        f(ifloat(p.x), ifloat(p.y), ifloat(p.z + e)).l - f(ifloat(p.x), ifloat(p.y), ifloat(p.z - e)).l\n    ));\n}\n\nvec3 normal(vec3 rd, vec3 p) {\n    vec3 n = normal(p);\n    return faceforward(n, rd, n);\n    return n;\n}\n\n\n\n//============================================================================//\n\n// Start of modified PBR code from https://www.shadertoy.com/view/XsfXWX\n\nfloat somestep(float t) {\n    return pow(t,4.0);\n}\n\nvec3 textureAVG(samplerCube tex, vec3 tc) {\n    const float diff0 = 0.35;\n    const float diff1 = 0.12;\n \tvec3 s0 = texture(tex,tc).xyz;\n    vec3 s1 = texture(tex,tc+vec3(diff0)).xyz;\n    vec3 s2 = texture(tex,tc+vec3(-diff0)).xyz;\n    vec3 s3 = texture(tex,tc+vec3(-diff0,diff0,-diff0)).xyz;\n    vec3 s4 = texture(tex,tc+vec3(diff0,-diff0,diff0)).xyz;\n    \n    vec3 s5 = texture(tex,tc+vec3(diff1)).xyz;\n    vec3 s6 = texture(tex,tc+vec3(-diff1)).xyz;\n    vec3 s7 = texture(tex,tc+vec3(-diff1,diff1,-diff1)).xyz;\n    vec3 s8 = texture(tex,tc+vec3(diff1,-diff1,diff1)).xyz;\n    \n    return (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8) * 0.111111111;\n}\n\nvec3 textureBlured(samplerCube tex, vec3 tc) {\n   \tvec3 r = textureAVG(tex,vec3(1.0,0.0,0.0));\n    vec3 t = textureAVG(tex,vec3(0.0,1.0,0.0));\n    vec3 f = textureAVG(tex,vec3(0.0,0.0,1.0));\n    vec3 l = textureAVG(tex,vec3(-1.0,0.0,0.0));\n    vec3 b = textureAVG(tex,vec3(0.0,-1.0,0.0));\n    vec3 a = textureAVG(tex,vec3(0.0,0.0,-1.0));\n        \n    float kr = dot(tc,vec3(1.0,0.0,0.0)) * 0.5 + 0.5; \n    float kt = dot(tc,vec3(0.0,1.0,0.0)) * 0.5 + 0.5;\n    float kf = dot(tc,vec3(0.0,0.0,1.0)) * 0.5 + 0.5;\n    float kl = 1.0 - kr;\n    float kb = 1.0 - kt;\n    float ka = 1.0 - kf;\n    \n    kr = somestep(kr);\n    kt = somestep(kt);\n    kf = somestep(kf);\n    kl = somestep(kl);\n    kb = somestep(kb);\n    ka = somestep(ka);    \n    \n    float d;\n    vec3 ret;\n    ret  = f * kf; d  = kf;\n    ret += a * ka; d += ka;\n    ret += l * kl; d += kl;\n    ret += r * kr; d += kr;\n    ret += t * kt; d += kt;\n    ret += b * kb; d += kb;\n    \n    return ret / d;\n}\n\n// GGX code from https://www.shadertoy.com/view/MlB3DV\nfloat G1V ( float dotNV, float k ) {\n\treturn 1.0 / (dotNV*(1.0 - k) + k);\n}\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n    \tfloat alpha = roughness*roughness;\n\tvec3 H = normalize (V + L);\n\n\tfloat dotNL = clamp (dot (N, L), 0.0, 1.0);\n\tfloat dotNV = clamp (dot (N, V), 0.0, 1.0);\n\tfloat dotNH = clamp (dot (N, H), 0.0, 1.0);\n\tfloat dotLH = clamp (dot (L, H), 0.0, 1.0);\n\n\tfloat D, vis;\n\tfloat F;\n\n\t// NDF : GGX\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.1415926535;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr / (pi * denom * denom);\n\n\t// Fresnel (Schlick)\n\tfloat dotLH5 = pow (1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\t// Visibility term (G) : Smith with Schlick's approximation\n\tfloat k = alpha / 2.0;\n\tvis = G1V (dotNL, k) * G1V (dotNV, k);\n\n\treturn /*dotNL */ D * F * vis;\n}\n\nvec3 shade(vec3 ray, vec3 normal, vec3 materialColor) {\n    // material\n    float metallic = 0.07;\n    float roughness = 0.1;\n    float fresnel_pow = mix(5.0, 3.5, metallic);\n    vec3 color_mod = vec3(1.0);\n    vec3 light_color = pow(texture(iChannel1,vec3(1.0,0.0,0.0)).xyz * 1.2, vec3(2.2));\n\n\n    // IBL\n    vec3 ibl_diffuse = pow(textureBlured(iChannel1,normal), vec3(2.2));\n    vec3 ibl_reflection = pow(textureBlured(iChannel1,reflect(ray,normal)), vec3(2.2));\n\n    // fresnel\n    float fresnel = max(1.0 - dot(normal,-ray), 0.0);\n    fresnel = pow(fresnel,fresnel_pow);    \n\n    // reflection        \n    vec3 refl = pow(texture(iChannel1,reflect(ray,normal)).xyz, vec3(2.2));\n    refl = mix(refl,ibl_reflection,(1.0-fresnel)*roughness);\n    refl = mix(refl,ibl_reflection,roughness);\n\n    // specular\n    vec3 light = normalize(vec3(-0.5,1.0,0.0));\n    float power = 1.0 / max(roughness * 0.4,0.01);\n    vec3 spec = light_color * GGX(normal,-ray,light,roughness*0.7, 0.2);\n    refl -= spec;\n\n    // diffuse\n    vec3 diff = ibl_diffuse * pow(materialColor, vec3(2.2));\n    diff = mix(diff * color_mod,refl,fresnel);        \n\n    vec3 color = mix(diff,refl * color_mod,metallic) + spec;\n    return pow(color, vec3(1.0/2.2));\n}\n\n// End of modified PBR code from https://www.shadertoy.com/view/XsfXWX\n\n//============================================================================//\n\nvec3 saturate(vec3 color, float amount) {\n    vec3 gray = vec3(dot(vec3(0.2126,0.7152,0.0722), color));\n    return clamp(mix(gray, color, 1.0 + amount), vec3(0.0), vec3(1.0));\n}\n\nvec3 calculateColor(Ray r) {\n    vec3 color;\n    float t = intersect(r);\n    \n    if (t > 0.0) {\n        vec3 p = r.o + r.d * t;\n        vec3 n = normal(r.d, p);\n        float gridLineColor = isPointInGridLine(p) ? 0.1 : 1.0;\n        \n        switch (renderingMode) {\n            case regular: {\n                vec3 lv = normalize(vec3(-1.0, 2.0, -3.0));\n                float ld = dot(lv, n);\n                float l = mix(max(ld, 0.0), mix(0.02, 1.0, ld * 0.5 + 0.5), 0.1);\n                vec3 c = vec3(1.0, 1.0, 1.0) * gridLineColor;\n                color = pow(c * l, vec3(1.0 / 2.2));\n                break;\n            }\n            case normalMap: {\n                color = (n * 0.5 + 0.5) * gridLineColor;\n                break;\n            }\n            case pbr: {\n                color = shade(r.d, n, saturate(n * 0.5 + 0.5, 0.7) * gridLineColor);\n                break;\n            }\n        }\n    }\n    \n    // If I make this an \"else\" for the above if statement then it bugs on macOS\n    if (t <= 0.0) {\n        switch (renderingMode) {\n            case regular: {\n                vec3 lv = normalize(vec3(-1.0, 2.0, -3.0));\n                float ld = dot(lv, r.d);\n                float l = pow(mix(0.4, 1.0, ld * 0.5 + 0.5), 5.0);\n                vec3 c = vec3(0.2);\n                color = pow(c * l, vec3(1.0 / 2.0));\n                break;\n            }\n            case normalMap: {\n                color = vec3(0.2);\n                break;\n            }\n            case pbr: {\n                if (useCubemapAsBackgroundForPBR) {\n                    color = texture(iChannel1, r.d).rgb;\n                } else {\n                    color = vec3(0.2);\n                }\n                break;\n            }\n        }\n    }\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Calculate camera configuration from keyboard & mouse input buffer\n    vec2 camRot = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec2 cr = cos(camRot);\n    vec2 sr = sin(camRot);\n    mat3 v2wRotMat = mat3(\n            cr.y,         0.0,  -sr.y,\n            sr.x * sr.y,  cr.x,  cr.y * sr.x,\n            cr.x * sr.y, -sr.x,  cr.x * cr.y);\n    vec4 camPosD = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec3 camPos = camPosD.xyz + v2wRotMat * vec3(0.0, 0.0, 1.0) * camPosD.w; \n    vec2 tanHalfFov = vec2(tan(radians(fovY) * 0.5)); \n    tanHalfFov.x *= iResolution.x / iResolution.y;\n    vec2 cCoord = fragCoord / iResolution.xy * 2.0 - 1.0;\n    vec3 vDir = normalize(vec3(cCoord * tanHalfFov, -1.0));\n    vec3 wDir = v2wRotMat * vDir;\n    Ray r = Ray(camPos, wDir);\n    \n    // Calculate color\n    fragColor = vec4(calculateColor(r), 1.0);\n    \n    if (doVignette) {\n        fragColor.rgb *= 1.0 - 0.8 * pow(distance(vec2(0.5, 0.5), fragCoord / iResolution.xy), 3.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//------------------------Interval Arithmetic Library-------------------------//\n\n// Interval Types:\n// These types keep track of a lower and upper bound throughout computation, \n// giving definitive bounds for the end result.\n\nstruct iFloat {\n    float l;\n    float u;\n};\n\nstruct iVec3 {\n    iFloat x;\n    iFloat y;\n    iFloat z;\n};\n\nstruct iBool {\n    bool l;\n    bool u;\n};\n\n// Functions: \n// Most of these functions have the same domains as the native GLSL equivalents. \n// If the arguments are outside of the domain, an empty set is returned. To be \n// correct, these should be propagated like NaNs, however, it slows down the\n// shader a lot and isn't necessary most of the time so propagation is optional.\n// These functions are overloaded so they can be called without having to\n// convert floats to iFloats or bools to iBools when mixing them with non-\n// interval types.\n\n#define PROPAGATE_EMPTY_SETS 0\n\niFloat iAdd(iFloat x, iFloat y);\niFloat iSub(iFloat x, iFloat y);\niFloat iMul(iFloat x, iFloat y);\niFloat iDiv(iFloat x, iFloat y);\n\niFloat iNeg(iFloat x); // -x\niFloat iInv(iFloat x); // 1 / x\n\niFloat iSin(iFloat x);\niFloat iCos(iFloat x);\niFloat iTan(iFloat x);\n\niFloat iAsin(iFloat x);\niFloat iAcos(iFloat x);\niFloat iAtan(iFloat x);\niFloat iAtan(iFloat y, iFloat x); // never undefined\n\niFloat iSinh(iFloat x);\niFloat iCosh(iFloat x);\niFloat iTanh(iFloat x);\n\niFloat iAsinh(iFloat x);\niFloat iAcosh(iFloat x);\niFloat iAtanh(iFloat x);\n\niFloat iExp(iFloat x);\niFloat iExp2(iFloat x);\n\niFloat iLog(iFloat x);\niFloat iLog2(iFloat x);\n                                                                                \niFloat iPow(iFloat x, iFloat y); // defined for x >= 0.0 or when y is an integer\n\niFloat iSqrt(iFloat x);\niFloat iCbrt(iFloat x);\niFloat iSquare(iFloat x);\n\niFloat iSign(iFloat x);\niFloat iAbs(iFloat x);\niFloat iFloor(iFloat x);\niFloat iCeil(iFloat x);\niFloat iRound(iFloat x);\niFloat iTrunc(iFloat x);\niFloat iMod(iFloat x, iFloat y);\niFloat iFract(iFloat x);\n\niFloat iMin(iFloat x, iFloat y);\niFloat iMax(iFloat x, iFloat y);\niFloat iClamp(iFloat x, iFloat minVal, iFloat maxVal);\n\niFloat iMix(iFloat x, iFloat y, iFloat a);\niFloat iSmoothstep(iFloat edge0, iFloat edge1, iFloat x);\niFloat iStep(iFloat edge, iFloat x);\n\niFloat iIf(iBool P, iFloat x, iFloat y); // use this as the ternary operator\n\niBool iEqual(iFloat x, iFloat y);\niBool iGreaterThan(iFloat x, iFloat y);\niBool iGreaterThanEqual(iFloat x, iFloat y);\niBool iLessThan(iFloat x, iFloat y);\niBool iLessThanEqual(iFloat x, iFloat y);\n\niBool iNOT(iBool x);\niBool iAND(iBool x, iBool y);\niBool iOR(iBool x, iBool y);\niBool iXOR(iBool x, iBool y);\n\n// Constructors:\n// Aren't necessary most of the time since the functions are already overloaded.\niFloat ifloat(float x);\niBool ibool(bool x);\n\n// Constants:\nconst float INFINITY = uintBitsToFloat(0x7F800000u);\nconst float PI = 3.14159265;\n\n\n\n//============================================================================//\n\n\n\n// Overloads:\n#define MAKE_OVERLOADSB(fn) iBool fn(bool x,iBool y){return fn(ibool(x),y);}iBool fn(iBool x,bool y){return fn(x,ibool(y));}\n#define MAKE_OVERLOADSBF(fn) iBool fn(float x,iFloat y){return fn(ifloat(x),y);}iBool fn(iFloat x,float y){return fn(x,ifloat(y));}\n#define MAKE_OVERLOADS2(fn) iFloat fn(float x,iFloat y){return fn(ifloat(x),y);}iFloat fn(iFloat x,float y){return fn(x,ifloat(y));}\n#define MAKE_OVERLOADS3(fn) iFloat fn(float x,iFloat y,iFloat z){return fn(ifloat(x),y,z);}iFloat fn(iFloat x,float y,iFloat z){return fn(x,ifloat(y),z);}iFloat fn(iFloat x,iFloat y,float z){return fn(x,y,ifloat(z));}iFloat fn(float x,float y,iFloat z){return fn(ifloat(x),ifloat(y),z);}iFloat fn(float x,iFloat y,float z){return fn(ifloat(x),y,ifloat(z));}iFloat fn(iFloat x,float y,float z){return fn(x,ifloat(y),ifloat(z));}\n\nMAKE_OVERLOADS2(iAdd)\nMAKE_OVERLOADS2(iSub)\nMAKE_OVERLOADS2(iMul)\nMAKE_OVERLOADS2(iDiv)\nMAKE_OVERLOADS2(iPow)\n\nMAKE_OVERLOADS2(iMod)\n\nMAKE_OVERLOADS2(iMin)\nMAKE_OVERLOADS2(iMax)\nMAKE_OVERLOADS3(iClamp)\n\nMAKE_OVERLOADS3(iMix)\nMAKE_OVERLOADS3(iSmoothstep)\nMAKE_OVERLOADS2(iStep)\n\nMAKE_OVERLOADSBF(iEqual)\nMAKE_OVERLOADSBF(iGreaterThan)\nMAKE_OVERLOADSBF(iGreaterThanEqual)\nMAKE_OVERLOADSBF(iLessThan)\nMAKE_OVERLOADSBF(iLessThanEqual)\n\nMAKE_OVERLOADSB(iAND)\nMAKE_OVERLOADSB(iOR)\nMAKE_OVERLOADSB(iXOR)\n\n// Empty Sets:\nconst iFloat EMPTY_SET = iFloat(-INFINITY, -INFINITY);\nconst iBool EMPTY_BSET = iBool(true, false);\n\n#if PROPAGATE_EMPTY_SETS\n    #define CHECK_IF_EMPTY_SET_F(x) if ((x) == EMPTY_SET) return EMPTY_SET\n    #define CHECK_IF_EMPTY_SET_B(x) if ((x) == EMPTY_SET) return EMPTY_BSET\n    #define CHECK_IF_EMPTY_BSET_F(x) if ((x) == EMPTY_BSET) return EMPTY_SET\n    #define CHECK_IF_EMPTY_BSET_B(x) if ((x) == EMPTY_BSET) return EMPTY_BSET\n#else\n    #define CHECK_IF_EMPTY_SET_F(x)\n    #define CHECK_IF_EMPTY_SET_B(x)\n    #define CHECK_IF_EMPTY_BSET_F(x)\n    #define CHECK_IF_EMPTY_BSET_B(x)\n#endif\n\n// Constructors:\niFloat ifloat(float x) {\n    return iFloat(x, x);\n}\n\n\niBool ibool(bool x) {\n    return iBool(x, x);\n}\n\n// Helper Functions:\niFloat iMinMax(float x, float y, float z, float w) {\n    return iFloat(\n        min(x, min(y, min(z, w))),\n        max(x, max(y, max(z, w)))\n    );\n}\n\niBool iMinMax(bool x, bool y, bool z, bool w) {\n    return iBool(\n        x || y || z || w,\n        x && y && z && w\n    );\n}\n\n\n// Function Implementations:\n\niFloat iAdd(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x); \n    CHECK_IF_EMPTY_SET_F(y);\n    return iFloat(x.l + y.l, x.u + y.u);\n}\n\niFloat iSub(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x); \n    CHECK_IF_EMPTY_SET_F(y);\n    return iFloat(x.l - y.u, x.u - y.l);\n}\n\niFloat iMul(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x); \n    CHECK_IF_EMPTY_SET_F(y);\n    return iMinMax(x.l * y.l, x.l * y.u, x.u * y.l, x.u * y.u);\n}\n\niFloat iDiv(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    return iMul(x, iInv(y));\n}\n\n\niFloat iNeg(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(-x.u, -x.l);\n}\n\niFloat iInv(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x); \n    \n    if (x.l > 0.0 || x.u < 0.0) {\n        return iFloat(1.0 / x.u, 1.0 / x.l);\n    } else if (x.l < 0.0 && x.u > 0.0) {\n        return iFloat(-INFINITY, INFINITY);\n    } else if (x.u == 0.0) {\n        return iFloat(-INFINITY, 1.0 / x.l);\n    } else {\n        return iFloat(1.0 / x.u, INFINITY);\n    }\n}\n\n\niFloat iSin(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    float u = PI * round(x.l / PI) + PI * 1.5;\n    \n    if (u < x.u) {\n        return iFloat(-1.0, 1.0);\n    }\n    \n    u -= PI;\n    vec2 s = vec2(sin(x.l), sin(x.u));\n    vec2 r = vec2(min(s.x, s.y), max(s.x, s.y));\n    \n    if (u < x.u) {\n        float s = sin(u);\n        return iFloat(min(r.x, s), max(r.y, s));\n    }\n    \n    return iFloat(r.x, r.y);\n}\n\niFloat iCos(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iSin(iAdd(x, ifloat(PI / 2.0)));\n}\n\niFloat iTan(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iDiv(iSin(x), iCos(x));\n}\n\n\niFloat iAsin(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u < -1.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.l <= -1.0) {\n        if (x.u < 1.0) {\n            return iFloat(-PI / 2.0, asin(x.u));\n        }\n        \n        return iFloat(-PI / 2.0, PI / 2.0);\n    }\n    \n    if (x.u < 1.0) {\n        return iFloat(asin(x.l), asin(x.u));\n    }\n    \n    if (x.l < 1.0) {\n        return iFloat(asin(x.l), PI / 2.0);\n    }\n    \n    if (x.l == 1.0) {\n        return ifloat(PI / 2.0);\n    }\n    \n    return EMPTY_SET;\n}\n\niFloat iAcos(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u < -1.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.l <= -1.0) {\n        if (x.u < 1.0) {\n            return iFloat(acos(x.u), PI);\n        }\n        \n        return iFloat(0.0, PI);\n    }\n    \n    if (x.u < 1.0) {\n        return iFloat(acos(x.u), acos(x.l));\n    }\n    \n    if (x.l < 1.0) {\n        return iFloat(0.0, acos(x.l));\n    }\n    \n    if (x.l == 1.0) {\n        return ifloat(0.0);\n    }\n    \n    return EMPTY_SET;\n}\n\niFloat iAtan(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(atan(x.l), atan(x.u));\n}\n\niFloat iAtan(iFloat y, iFloat x) {\n    CHECK_IF_EMPTY_SET_F(y);\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u < 0.0) {\n        if (y.u < 0.0) {\n            return iFloat(atan(y.u, x.l), atan(y.l, x.u));\n        }\n        \n        if (y.l < 0.0) {\n            return iFloat(-PI, PI);\n        }\n        \n        return iFloat(atan(y.u, x.u), atan(y.l, x.l));\n    }\n    \n    if (x.u == 0.0) {\n        if (x.l < 0.0) {\n            if (y.u < 0.0) {\n                return iFloat(atan(y.u, x.l), -PI / 2.0);\n            }\n            \n            if (y.l < 0.0) {\n                return iFloat(-PI, PI);\n            }\n            \n            if (y.l == 0.0) {\n                return iFloat(0.0, PI);\n            }\n            \n            return (iFloat(PI / 2.0, atan(y.l, x.l)));\n        }\n        \n        if (y.u < 0.0) {\n            return ifloat(-PI / 2.0);\n        }\n        \n        if (y.u == 0.0) {\n            if (y.l < 0.0) {\n                return iFloat(-PI / 2.0, 0.0);\n            }\n            \n            return ifloat(0.0);\n        }\n        \n        if (y.l < 0.0) {\n            return iFloat(-PI / 2.0, PI / 2.0);\n        }\n        \n        if (y.l == 0.0) {\n            return iFloat(0.0, PI / 2.0);\n        }\n        \n        return ifloat(PI / 2.0);\n    }\n    \n    if (x.l < 0.0) {\n        if (y.u < 0.0) {\n            return iFloat(atan(y.u, x.l), atan(y.u, x.u));\n        }\n        \n        if (y.u == 0.0) {\n            if (y.l == 0.0) {\n                return iFloat(0.0, PI);\n            }\n            \n            return iFloat(-PI, PI);\n        }\n        \n        if (y.l < 0.0) {\n            return iFloat(-PI, PI);\n        }\n        \n        if (y.l == 0.0) {\n            return iFloat(0.0, PI);\n        }\n        \n        return iFloat(atan(y.l, x.u), atan(y.l, x.l));\n    }\n    \n    if (x.l == 0.0) {\n        if (y.u <= 0.0) {\n            return iFloat(atan(y.u, x.u), -PI / 2.0);\n        }\n        \n        if (y.l < 0.0) {\n            return iFloat(-PI / 2.0, PI / 2.0);\n        }\n        \n        if (y.l == 0.0) {\n            return iFloat(0.0, PI / 2.0);\n        }\n        \n        return iFloat(atan(y.l, x.u), PI / 2.0);\n    }\n    \n    return iAtan(iDiv(y, x));\n}\n\n\niFloat iSinh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(sinh(x.l), sinh(x.u));\n}\n\niFloat iCosh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u <= 0.0) {\n        return iFloat(cosh(x.u), cosh(x.l));\n    }\n    \n    if (x.l <= 0.0 && 0.0 < x.u) {\n        return iFloat(1.0, cosh(max(-x.l, x.u)));\n    }\n    \n    return iFloat(cosh(x.l), cosh(x.u));\n}\n\niFloat iTanh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(tanh(x.l), tanh(x.u));\n}\n\n\niFloat iAsinh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(asinh(x.l), asinh(x.u));\n}\n\niFloat iAcosh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u < 1.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.u == 1.0) {\n        return ifloat(0.0);\n    }\n    \n    if (x.l <= 1.0) {\n        return iFloat(0.0, acosh(x.u));\n    }\n    \n    return iFloat(acosh(x.l), acosh(x.u));\n}\n\niFloat iAtanh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u <= -1.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.l <= -1.0) {\n        if (x.u < 1.0) {\n            return iFloat(-INFINITY, atanh(x.u));\n        }\n        \n        return iFloat(-INFINITY, INFINITY);\n    }\n    \n    if (x.l < 1.0) {\n        if (x.u < 1.0) {\n            return iFloat(atanh(x.l), atanh(x.u));\n        }\n        \n        return iFloat(atanh(x.l), INFINITY);\n    }\n    \n    return EMPTY_SET;\n}\n\n\niFloat iExp(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(exp(x.l), exp(x.u));\n}\n\niFloat iExp2(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(exp2(x.l), exp2(x.u));\n}\n\n\niFloat iLog(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l > 0.0) {\n        return iFloat(log(x.l), log(x.u));\n    }\n    \n    if (x.u > 0.0) {\n        return iFloat(-INFINITY, log(x.u));\n    }\n    \n    return EMPTY_SET;\n}\n\niFloat iLog2(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l > 0.0) {\n        return iFloat(log2(x.l), log2(x.u));\n    }\n    \n    if (x.u > 0.0) {\n        return iFloat(-INFINITY, log2(x.u));\n    }\n    \n    return EMPTY_SET;\n}\n\n\niFloat iPow(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    \n    if (x.l < 0.0 && y.l == y.u && fract(y.l) == 0.0) {\n        float y = y.l;\n        \n        if (y == 0.0) {\n            return ifloat(1.0);\n        }\n\n        if (y > 0.0) {\n            if (mod(y, 2.0) == 1.0) {\n                return iFloat(-pow(-x.l, y), pow(abs(x.u), y) * sign(x.u));\n            }\n\n            if (x.u > 0.0) {\n                return iFloat(0.0, pow(max(-x.l, x.u), y));\n            }        \n\n            return iFloat(pow(-x.u, y), pow(-x.l, y));;\n        }\n\n        if (mod(y, 2.0) == 1.0) {\n            if (x.u > 0.0) {\n                return iFloat(-INFINITY, INFINITY);\n            }\n\n            if (x.u == 0.0) {\n                return iFloat(-INFINITY, -pow(-x.l, y));\n            }\n\n            return iFloat(-pow(-x.u, y), -pow(-x.l, y));\n        }\n\n        if (x.u > 0.0) {\n            return iFloat(min(pow(-x.l, y), pow(x.u, y)), INFINITY);\n        }\n\n        if (x.u == 0.0) {\n            return iFloat(pow(-x.l, y), INFINITY);\n        }\n\n        return iFloat(pow(-x.l, y), pow(-x.u, y));\n    }\n    \n    if (x.u < 0.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.u == 0.0) {\n        if (y.l == 0.0 && y.u == 0.0) {\n            return EMPTY_SET;\n        }\n        \n        return ifloat(0.0);\n    }\n    \n    x.l = max(x.l, 0.0);\n    \n    if (x.l == 0.0) {\n        if (y.u <= 0.0) {\n            if (y.l == 0.0) {\n                return ifloat(1.0);\n            }\n            \n            if (x.u < 1.0) {\n                return iFloat(pow(x.u, y.u), INFINITY);\n            }\n            \n            return iFloat(pow(x.u, y.l), INFINITY);\n        }else\n        \n        if (y.l < 0.0) {\n            return iFloat(0.0, INFINITY);\n        }\n        \n        if (y.l == 0.0) {\n            return iFloat(0.0, max(1.0, pow(x.u, y.u)));\n        }\n    }\n    \n    return iMinMax(pow(x.l, y.l), pow(x.l, y.u), pow(x.u, y.l), pow(x.u, y.u));\n}\n\n\niFloat iSqrt(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l > 0.0) {\n        return iFloat(sqrt(x.l), sqrt(x.u));\n    }\n    \n    if (x.u > 0.0) {\n        return iFloat(0.0, sqrt(x.u));\n    }\n    \n    if (x.u == 0.0) {\n        return ifloat(0.0);\n    }\n    \n    return EMPTY_SET;\n}\n\niFloat iCbrt(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(pow(abs(x.l), 1.0 / 3.0) * sign(x.l), pow(abs(x.u), 1.0 / 3.0) * sign(x.u));\n}\n\niFloat iSquare(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l <= 0.0 && 0.0 <= x.u) {\n        float t = max(-x.l, x.u);\n        return iFloat(0.0, t * t);\n    }\n    \n    if (x.u <= 0.0) {\n        return iFloat(x.u * x.u, x.l * x.l);\n    }\n    \n    return iFloat(x.l * x.l, x.u * x.u);\n}\n\n\niFloat iSign(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(sign(x.l), sign(x.u));\n}\n\niFloat iAbs(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l >= 0.0) {\n        return x;\n    }\n    \n    if (x.u <= 0.0) {\n        return iNeg(x);\n    }\n    \n    return iFloat(0.0, max(-x.l, x.u));\n}\n\niFloat iFloor(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(floor(x.l), floor(x.u));\n}\n\niFloat iCeil(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(ceil(x.l), ceil(x.u));\n}\n\niFloat iRound(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(round(x.l), round(x.u));\n}\n\niFloat iTrunc(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(trunc(x.l), trunc(x.u));\n}\n\niFloat iMod(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    return iSub(x, iMul(y, iFloor(iDiv(x, y))));\n}\n\niFloat iFract(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iSub(x, iFloor(x));\n}\n\n\niFloat iMin(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    return iFloat(min(x.l, y.l), min(x.u, y.u));\n}\n\niFloat iMax(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    return iFloat(max(x.l, y.l), max(x.u, y.u));\n}\n\niFloat iClamp(iFloat x, iFloat minVal, iFloat maxVal) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(minVal);\n    CHECK_IF_EMPTY_SET_F(maxVal);\n    return iFloat(clamp(x.l, minVal.l, maxVal.l), clamp(x.u, minVal.u, maxVal.u));\n}\n\n\niFloat iMix(iFloat x, iFloat y, iFloat a) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    CHECK_IF_EMPTY_SET_F(a);\n    return iAdd(x, iMul(iSub(y, x), a));\n}\n\niFloat iSmoothstep(iFloat edge0, iFloat edge1, iFloat x) {\n    CHECK_IF_EMPTY_SET_F(edge0);\n    CHECK_IF_EMPTY_SET_F(edge1);\n    CHECK_IF_EMPTY_SET_F(x);\n    iFloat t = iClamp(iDiv(iSub(x, edge0), iSub(edge1, edge0)), 0.0, 1.0);\n    return iMul(iSquare(t), iSub(3.0, iMul(2.0, t)));\n}\n\niFloat iStep(iFloat edge, iFloat x) {\n    CHECK_IF_EMPTY_SET_F(edge);\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (edge.u <= x.l) {\n        return ifloat(1.0);\n    }\n    \n    if (x.u < edge.l) {\n        return ifloat(0.0);\n    }\n    \n    return iFloat(0.0, 1.0);\n}\n\n\niFloat iIf(iBool P, iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_BSET_F(P);\n    \n    if (P.l) {\n        return x;\n    }\n    \n    if (!P.u) {\n        return y;\n    }\n    \n    if (x == EMPTY_SET) {\n        return y;\n    }\n    \n    if (y == EMPTY_SET) {\n        return x;\n    }\n    \n    return iFloat(min(x.l, y.l), max(x.u, y.u));\n}\n\niFloat iIf(bool P, iFloat x, iFloat y) {\n    return iIf(ibool(P), x, y);\n}\niFloat iIf(bool P, float x, iFloat y) {\n    return iIf(ibool(P), ifloat(x), y);\n}\niFloat iIf(bool P, iFloat x, float y) {\n    return iIf(ibool(P), x, ifloat(y));\n}\niFloat iIf(iBool P, float x, iFloat y) {\n    return iIf(P, ifloat(x), y);\n}\niFloat iIf(iBool P, float x, float y) {\n    return iIf(P, ifloat(x), ifloat(y));\n}\niFloat iIf(iBool P, iFloat x, float y) {\n    return iIf(P, x, ifloat(y));\n}\n\niBool iEqual(iFloat x, iFloat y) {\n    if (x == y) {\n        return ibool(true);\n    }\n    \n    if (x.l <= y.u && y.l <= x.l) {\n        return iBool(false, true);\n    }\n    \n    return ibool(false);\n}\n\niBool iGreaterThan(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_B(x);\n    CHECK_IF_EMPTY_SET_B(y);\n    \n    if (x.l > y.u) {\n        return ibool(true);\n    }\n    \n    if (x.u <= y.l) {\n        return ibool(false);\n    }\n    \n    return iBool(false, true);\n}\n\niBool iGreaterThanEqual(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_B(x);\n    CHECK_IF_EMPTY_SET_B(y);\n    \n    if (x.l >= y.u) {\n        return ibool(true);\n    }\n    \n    if (x.u < y.l) {\n        return ibool(false);\n    }\n    \n    return iBool(false, true);\n}\n\niBool iLessThan(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_B(x);\n    CHECK_IF_EMPTY_SET_B(y);\n    \n    if (x.u < y.l) {\n        return ibool(true);\n    }\n    \n    if (x.l >= y.u) {\n        return ibool(false);\n    }\n    \n    return iBool(false, true);\n}\n\niBool iLessThanEqual(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_B(x);\n    CHECK_IF_EMPTY_SET_B(y);\n    \n    if (x.u <= y.l) {\n        return ibool(true);\n    }\n    \n    if (x.l > y.u) {\n        return ibool(false);\n    }\n    \n    return iBool(false, true);\n}\n\n\niBool iNOT(iBool x) {\n    CHECK_IF_EMPTY_BSET_B(x);\n    \n    if (x.l && x.u) {\n        return ibool(false);\n    }\n    \n    if (!x.l && !x.u) {\n        return ibool(true);\n    }\n    \n    return iBool(false, true);\n}\n\niBool iAND(iBool x, iBool y) {\n    CHECK_IF_EMPTY_BSET_B(x);\n    CHECK_IF_EMPTY_BSET_B(y);\n    \n    return iMinMax(x.l && y.l, x.l && y.u, x.u && y.l, x.u && y.u);\n}\n\niBool iOR(iBool x, iBool y) {\n    CHECK_IF_EMPTY_BSET_B(x);\n    CHECK_IF_EMPTY_BSET_B(y);\n    \n    return iMinMax(x.l || y.l, x.l || y.u, x.u || y.l, x.u || y.u);\n}\n\niBool iXOR(iBool x, iBool y) {\n    CHECK_IF_EMPTY_BSET_B(x);\n    CHECK_IF_EMPTY_BSET_B(y);\n    \n    return iMinMax(x.l ^^ y.l, x.l ^^ y.u, x.u ^^ y.l, x.u ^^ y.u);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//-----------------------Keyboard & Mouse Input Handler-----------------------//\n\n// Settings: \nconst float MOUSE_SENSITIVITY = 5.0;  \nconst float MOVEMENT_SPEED = 4.0; // Units per second\n\n// Controls:\nconst float KEY_W = 87.0;     // forwards\nconst float KEY_A = 65.0;     // left\nconst float KEY_S = 83.0;     // backwards\nconst float KEY_D = 68.0;     // right\nconst float KEY_UP = 38.0;    // forwards\nconst float KEY_LEFT = 37.0;  // left\nconst float KEY_DOWN = 40.0;  // backwards\nconst float KEY_RIGHT = 39.0; // right\nconst float KEY_SPACE = 32.0; // up\nconst float KEY_SHIFT = 16.0; // down\nconst float KEY_J = 74.0;     // up\nconst float KEY_N = 78.0;     // down\nconst float KEY_K = 75.0;     // decrease orbit radius\nconst float KEY_M = 77.0;     // increase orbit radius\n\n\n\n//============================================================================//\n\n\n\nbool keyPressed(float keyCode) {\n    return texture(iChannel0, vec2((keyCode + 0.5) / 256.0, 0.5 / 3.0)).r > 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n    \n    if (fragCoord == vec2(0.5, 0.5)) {\n        if (iMouse.z > 0.0) {\n            vec2 oldCamRot = texelFetch(iChannel1, ivec2(0, 0), 0).zw;\n            float mouseSens = -MOUSE_SENSITIVITY / iResolution.x;\n            fragColor = vec4(clamp(oldCamRot.x - (iMouse.y - abs(iMouse.w)) * mouseSens, -PI * 0.5, PI * 0.5),\n                                   oldCamRot.y + (iMouse.x - abs(iMouse.z)) * mouseSens,\n                                   oldCamRot);\n        } else {\n            vec2 camRot = texelFetch(iChannel1, ivec2(0, 0), 0).xy;\n            fragColor = camRot.xyxy;\n        }\n        \n        if (iFrame == 0 || iMouse.x == 0.0 && iMouse.z == 0.0) {\n            fragColor.x = mix(-0.3, 0.1, 0.5 - 0.5 * cos(iTime * 0.5));\n            fragColor.y = -0.5 + iTime * 0.3;\n        }\n    } else if (fragCoord == vec2(1.5, 0.5)) {\n        fragColor = texelFetch(iChannel1, ivec2(1, 0), 0);\n        float camRotY = texelFetch(iChannel1, ivec2(0, 0), 0).y;\n        float c = cos(camRotY);\n        float s = sin(camRotY);\n        mat3 rotMat = mat3(\n                c,   0.0,  -s,\n                0.0, 1.0,  0.0,\n                s,   0.0,  c\n            ) * MOVEMENT_SPEED * iTimeDelta;\n        vec3 right = vec3(1.0, 0.0, 0.0);\n        vec3 up = vec3(0.0, 1.0, 0.0);\n        vec3 forward = vec3(0.0, 0.0, -1.0);\n        \n        if (keyPressed(KEY_W) || keyPressed(KEY_UP)) {\n            fragColor.xyz += rotMat * forward;\n        }\n        if (keyPressed(KEY_S) || keyPressed(KEY_DOWN)) {\n            fragColor.xyz -= rotMat * forward;\n        }\n        \n        if (keyPressed(KEY_D) || keyPressed(KEY_RIGHT)) {\n            fragColor.xyz += rotMat * right;\n        }\n        if (keyPressed(KEY_A) || keyPressed(KEY_LEFT)) {\n            fragColor.xyz -= rotMat * right;\n        }\n        \n        if (keyPressed(KEY_SPACE) || keyPressed(KEY_J)) {\n            fragColor.xyz += rotMat * up;\n        }\n        if (keyPressed(KEY_SHIFT) || keyPressed(KEY_N)) {\n            fragColor.xyz -= rotMat * up;\n        }\n            \n        if (keyPressed(KEY_K)) {\n            fragColor.w   -= MOVEMENT_SPEED * iTimeDelta;\n        }\n        if (keyPressed(KEY_M)) {\n            fragColor.w   += MOVEMENT_SPEED * iTimeDelta;\n        }\n        \n        fragColor.w = iFrame == 0 ? 4.0 : max(fragColor.w, 0.0);\n    } else if (fragCoord == vec2(0.5, 1.5)) {\n        if (keyPressed(KEY_W)     || keyPressed(KEY_A)     || \n            keyPressed(KEY_S)     || keyPressed(KEY_D)     || \n            keyPressed(KEY_UP)    || keyPressed(KEY_LEFT)  || \n            keyPressed(KEY_DOWN)  || keyPressed(KEY_RIGHT) || \n            keyPressed(KEY_SPACE) || keyPressed(KEY_SHIFT) || \n            keyPressed(KEY_J)     || keyPressed(KEY_N)     || \n            keyPressed(KEY_K)     || keyPressed(KEY_M)     || \n            \n            iMouse.z > 0.0) {\n            fragColor.x = 1.0;\n        } else {\n            fragColor.x = texelFetch(iChannel1, ivec2(0, 1), 0).x + 1.0;\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}