{
    "Shader": {
        "info": {
            "date": "1612639241",
            "description": "I probably saw something like this on my PC in 1994, but hey, this time I made (some of) it myself.",
            "flags": 0,
            "hasliked": 0,
            "id": "WltBD8",
            "likes": 5,
            "name": "Coulomb plasma",
            "published": 3,
            "tags": [
                "plasma"
            ],
            "usePreview": 0,
            "username": "DukeOfStraylight",
            "viewed": 304
        },
        "renderpass": [
            {
                "code": "const float pi = 3.14159;\n\nfloat hash11(float x) {\n    return fract(sin(x*543.543)*1364.34);\n}\n\nconst float charges = 8.;\n\nvec2 gradient(vec2 x)\n{\n    float charge = -1.;\n    vec2 rv = vec2(0.);\n    for (float n = 0.; n < charges; n += 1.) {\n        float t = (n * 2. * pi / charges) + iTime * 0.5 + hash11(n) * iTime;\n        vec2 pos = vec2(cos(t), sin(t) * n / charges);\n        vec2 d = x - pos;\n        float l = length(d);\n        rv += normalize(d)/l * charge;\n        charge = -charge;\n    }\n    return rv;\n}\n\n// original numeric gradient calculation\n/*\nfloat potential(vec2 uv) {\n    float charge = 1.;\n    float pot = 0.;\n    const int charges = 8;\n    for (int n = 0; n < charges; n += 1) {\n        float t = (float(n) * 2. * pi / float(charges)) + iTime * 0.5 + hash11(float(n)) * iTime;\n        pot += charge / length(uv - vec2(cos(t), sin(t) * float(n) / float(charges)));\n        charge = -charge;\n    }\n    return pot;\n}\n\nvec2 gradient(vec2 x)\n{\n    vec2 h = vec2( 0.01, 0.0 );\n    return vec2( potential(x+h.xy) - potential(x-h.xy),\n                 potential(x+h.yx) - potential(x-h.yx) )/(2.0*h.x);\n}\n*/\n\n// from https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// All components are in the range [0â€¦1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.a = 1.;\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv *= 3.;\n\n    vec2 f = gradient(uv);\n    float dir = atan(f.y, f.x);\n    fragColor.rgb = hsv2rgb(vec3(fract((dir/pi+1.)*0.5), 1., 1.));\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}