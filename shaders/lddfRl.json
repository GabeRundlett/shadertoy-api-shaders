{
    "Shader": {
        "info": {
            "date": "1527067526",
            "description": "zooms into a cube.\n\nreduce levels a little if too slow. if your computer complains about loop variables, undef OVERSAMPLE (you'll get aliasing / anisotropy problems, though)",
            "flags": 0,
            "hasliked": 0,
            "id": "lddfRl",
            "likes": 11,
            "name": "cubezoomer",
            "published": 3,
            "tags": [
                "cube",
                "zoom"
            ],
            "usePreview": 0,
            "username": "halcy",
            "viewed": 682
        },
        "renderpass": [
            {
                "code": "// Various knobs to twiddle\n#define MIN_DIST 0.001\n#define STEP_MULTIPLIER 1.0\n#define NORMAL_OFFSET 0.001\n#define MAX_STEPS 128\n#define LEVELS 5\n#define SPEED 10.0\n#define OVERSAMPLE\n\n// Timing\nfloat zoomtimer() {\n    return(sin(iTime * 0.2) * SPEED);\n}\n\n// Palette helper\nvec3 color(float inVal) {\n\tvec3 a = vec3(0.5, 0.5, 0.5);\n\tvec3 b = vec3(0.5, 0.5, 0.5);\n\tvec3 c = vec3(1.0, 1.0, 0.5);\n\tvec3 d = vec3(0.8, 0.9, 0.3);\n\treturn(a + b * cos(6.28318 * (c * inVal + d)));\n}\n\n// World\nvec4 distfunc(vec3 pos) {\n  \tvec4 box = vec4(0.0);\n    box.a = max(max(abs(pos.y) - 0.5, abs(pos.z) - 0.5), abs(pos.x) - 0.5);\n    return(box);\n}\n\n// For fuzzing up stuff\nvec3 hash33(vec3 p){ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n// View setup\nvoid camera(vec2 coords, out vec3 eye, out vec3 ray, float level) {\n    // Zoom-in\n    float zoomtime = zoomtimer();\n    float zoom = mod(zoomtime, 1.0) - level;\n    float zoomlevel = floor(zoomtime) + level;\n    \n    // Calculate an eye position\n    eye = normalize(vec3(\n        sin(zoomlevel), \n        sin(iTime + zoomlevel),\n        cos(zoomlevel * 2.0))) * 1.75;\n    \n    float tolevel = zoomlevel;\n    vec3 eyeto = normalize(vec3(\n        sin(tolevel), \n        sin(iTime + zoomlevel),\n        cos(tolevel * 2.0))) * 1.75;\n    \n    if(abs(eyeto.x) > abs(eyeto.z)) {\n    \teyeto = vec3(sign(eyeto.x),  0.0, 0.0);\n    }\n    else{\n        eyeto = vec3(0.0, 0.0, sign(eyeto.z));\n    }\n    \n    // Camera as eye + imaginary screen at a distance\n    eye = mix(eye, eyeto, zoom);   \n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    vec3 lookdir = normalize(lookat - eye);\n    vec3 left = normalize(cross(lookdir, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(left, lookdir));\n    vec3 lookcenter = eye + lookdir;\n\tvec3 pixelpos = lookcenter + coords.x * left + coords.y * up;\n    ray = normalize(pixelpos - eye);\n}\n\n// Raymarch one hit\nvec4 march(vec2 coords, out float iters, float level) {\n    // Set up view\n    vec3 eye, ray;\n    camera(coords, eye, ray, level);   \n    \n    // March\n    vec3 pos = eye;\n    float dist = 0.0;\n    float curdist = 1.0;\n    iters = float(MAX_STEPS);\n    for(int i = 0; i < MAX_STEPS; i++) {\n        curdist = distfunc(pos).a;\n        dist += curdist * STEP_MULTIPLIER;\n        pos = eye + ray * dist;\n        if(curdist < MIN_DIST) {\n        \titers = float(i);\n            break;\n        }\n    }\n    \n    // Check hit\n    if(int(iters) == MAX_STEPS) {\n    \t return(vec4(pos, -1.0));  \n    }\n    \n    return(vec4(pos, dist));\n}\n\n// Colour a hit\nvec3 shade(vec2 coords, vec3 pos, float dist, float iters, vec3 matColor, float level) {\n    // Set up view, again\n    vec3 eye, ray;\n    camera(coords, eye, ray, level);\n    vec3 lightpos = eye;\n    \n    // Finite-difference normals\n   \tvec2 d = vec2(NORMAL_OFFSET, 0.0);\n    vec3 normal = normalize(vec3(\n        distfunc(pos + d.xyy).a - distfunc(pos - d.xyy).a,\n        distfunc(pos + d.yxy).a - distfunc(pos - d.yxy).a,\n        distfunc(pos + d.yyx).a - distfunc(pos - d.yyx).a\n    ));\n    \n    // Shading\n    vec3 shadowray = normalize(lightpos - pos);    \n    float light = max(0.0, dot(normal, shadowray)) + 0.1;\n    vec3 itershade = vec3(iters / float(MAX_STEPS));\n    vec3 colorval = light * matColor + itershade * 0.3;\n    \n\treturn(colorval);\n}\n\n// Colour a non-hit\nvec3 background(vec2 coords, float level) {\n    float zoom = 0.0;\n    float zoomtime = zoomtimer();\n    zoom = mod(zoomtime, 1.0) - level;\n\t\n    // Try to deal with anisotropy / aliasing\n    // Might need more tuning\n    vec3 backColorFinal = vec3(0.0);\n    float fuzzReq = level -  mod(zoomtime, 1.0);\n    float fuzzPow = pow(fuzzReq * 0.24, 3.0);\n    float fuzzIters = floor(pow(zoom * 2.0, 2.0) + 1.0);\n    \n    // Level 0 gets extra zoomy\n    if(level == 0.0) {\n        coords /= (1.0 + zoom);\n        fuzzPow = 0.001;\n    }\n    fuzzPow *= 0.1;\n    \n#ifdef OVERSAMPLE\n    for(float s = 0.0; s < 100.0; s += 1.0) {\n        if(s >= fuzzIters) { break; } // Probably better in some implementations\n        vec2 scoords = coords + hash33(vec3(coords.x, coords.y, s)).xy * fuzzPow;\n        float shade = sin((scoords.x - scoords.y * 0.7 + iTime * 0.03) * 30.0) * 0.5;\n        shade += sin((0.7 * scoords.x + scoords.y + iTime * 0.1) * 100.0) * 0.1;\n        vec3 backColor = color(0.2);\n        if(shade > 0.0) {\n            backColor = color(0.8);\n        }\n        if(abs(shade) < 0.1) {\n            backColor = color(0.9);\n        }\n        backColorFinal += backColor;\n    }\n    backColorFinal /= fuzzIters;\n#else\n    vec2 scoords = coords;\n    float shade = sin((scoords.x - scoords.y * 0.7 + iTime * 0.03) * 30.0) * 0.5;\n    shade += sin((0.7 * scoords.x + scoords.y + iTime * 0.1) * 100.0) * 0.1;\n    vec3 backColor = color(0.2);\n    if(shade > 0.0) {\n        backColor = color(0.8);\n    }\n    if(abs(shade) < 0.1) {\n        backColor = color(0.9);\n    }\n    backColorFinal = backColor;\n#endif\n    return(backColorFinal);\n}\n\n// Texture a cube\nvec2 hitCoords(vec3 hitPos) {\n    vec2 coords;\n\tif(abs(abs(hitPos.x) - 0.5) < MIN_DIST) {\n        coords = hitPos.zy * 2.0;\n        coords.x *= -sign(hitPos.x);\n    }\n    if(abs(abs(hitPos.y) - 0.5) < MIN_DIST) {\n        coords = hitPos.xz * 2.0;\n    }\n    if(abs(abs(hitPos.z) - 0.5) < MIN_DIST) {\n        coords = hitPos.xy * 2.0;\n    }   \n    return(coords);\n}\n\n// Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 coords[LEVELS + 2];\n    float iters[LEVELS + 1];\n\tvec4 hit[LEVELS + 1];\n   \tcoords[1] = (2.0 * fragCoord.xy  - iResolution.xy) / max(iResolution.x, iResolution.y);\n    \n    // Trace all hits\n    for(int i = 1; i < LEVELS + 1; i++) {\n        if(i == 1 || hit[i - 1].w > 0.0) {\n    \t\thit[i] = march(coords[i], iters[i], float(i - 1));\n            coords[i+1] = hitCoords(hit[i].xyz);\n        }\n        else {\n        \thit[i].w = -1.0;   \n        }\n    }\n    \n    // Shade\n    vec3 stackColor = color(0.2);\n    for(int i = LEVELS; i >= 1; i--) {\n        if(hit[i].w > 0.0) {\n            stackColor = shade(coords[i], hit[i].xyz, hit[i].w, iters[i], stackColor, float(i - 1));\n        }\n        else {\n            stackColor = background(coords[i], float(i));   \n        }\n    }\n    fragColor = vec4(stackColor, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}