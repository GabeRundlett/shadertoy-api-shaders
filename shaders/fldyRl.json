{
    "Shader": {
        "info": {
            "date": "1660415421",
            "description": "working on a procedural occlusion window to use instead of `length(x) > 1.0` and trying to learn how to do all this procedural stuff as I go.",
            "flags": 0,
            "hasliked": 0,
            "id": "fldyRl",
            "likes": 0,
            "name": "porthole",
            "published": 3,
            "tags": [
                "procedural",
                "wip"
            ],
            "usePreview": 0,
            "username": "sh1boot",
            "viewed": 191
        },
        "renderpass": [
            {
                "code": "vec4 overlay(vec4 top, vec4 bottom) {\n    return bottom * (1.0 - top.a) + top;\n}\n\nfloat hash(vec2 uv) {\n    // Seeing some weird discontinuity coming from overflow cases -- this'll fix it!\n    uv = vec2(ivec2(floatBitsToUint(uv.x), floatBitsToUint(uv.y))) / 65537.0;\n\n    const vec2 swiz = vec2(12.9898, 78.233);\n    return fract(sin(dot(uv, swiz)) * 43758.5453);\n}\n\nfloat hash(float f) {\n    return hash(vec2(f));\n}\n\nfloat noise(vec2 uv, float p) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    f = smoothstep(0.0, 1.0, f);\n    vec4 o = vec4(vec2(-0.5), vec2(0.5)) + fract(p * 1.73737373);\n    return mix(mix(hash(i + o.xy), hash(i + o.zy), f.x),\n               mix(hash(i + o.xw), hash(i + o.zw), f.x),\n               f.y);\n}\n\nfloat noise(vec2 uv) {\n    return noise(uv, 0.0);\n}\n\n   \nfloat bumpmap(float dx, float dy, float shine) {\n    vec3 n = cross(normalize(vec3(1.0, 0.0, dx * 4.0)),\n                   normalize(vec3(0.0, 1.0, dy * 4.0)));\n    vec3 light = normalize(vec3(sin(iTime * 1.445), 4.0, 6.0 - cos(iTime)));\n    float diff = max(0.0, dot(light, n));\n    float spec = pow(max(0.0, dot(light, normalize(n + vec3(0.0, 0.0, 1.0)))), 20.0);\n    return 0.15 + 0.85 * diff + spec * shine;\n}\n\n\n\nfloat bevel(float lo, float hi, float x) {\n    if (x <= lo) return 0.0;\n    if (x >= hi) return 1.0;\n    x = (x - lo) / (hi - lo);\n    return sqrt(x * (2.0 - x));\n}\n\nfloat nbevel(float lo, float hi, float x) {\n    return 1.0 - bevel(-hi, -lo, -x);\n}\n\nvec4 wood(vec2 uv) {\n    const mat2 grain = mat2(1.0, 0.0, 0.0, 12.0);\n    const float offcentre = 0.2345;\n    const float planks_per_unit = 3.0;\n    float edge = uv.y * planks_per_unit + offcentre;\n    float plank = round(edge);\n    float d = noise(uv * grain, plank) * 24.0;\n\n    // Pedantry: each plank is cut at a different depth into the trunk.\n    d += (hash(plank) - 0.5) * 12.0;\n\n    // summer and winter growth rings\n    const vec3 woods = vec3(0.50, 0.31, 0.06);\n    const vec3 woodw = vec3(0.40, 0.22, 0.00);\n    // summer/winter rings for heart.\n    const vec3 hearts = vec3(0.32, 0.14, 0.00);\n    const vec3 heartw = vec3(0.28, 0.12, 0.00);\n    float w1 = smoothstep(3.0, 10.0, d);\n    float w0 = abs(sin(d));  // mostly near 1, so these are the summer rings\n    float lip = 0.2 + 0.8 * smoothstep(0.005, 0.04, 0.5 - abs(plank - edge));\n    return vec4(mix(mix(heartw, hearts, w0), mix(woodw, woods, w0), w1) * lip, 1.0);\n}\n\nfloat smoothmax(float x, float y, float k) {\n    float f_k = pow(max(0.0, k - abs(y - x)), 3.0) / (6.0 * k * k);\n\n    return max(x, y) + f_k;\n}\n\nvec4 bolt(vec2 uv, float t) {\n    const float size = 0.075;\n    const float sides = 5.0;\n    float r = length(uv);\n    const float roundoff = 2.0 * 3.14159265358979 / sides;\n    t = fract(atan(uv.y, uv.x) / roundoff + t) * roundoff;\n    t = size / smoothmax(cos(t), cos(roundoff - t), 0.35);\n \n    const vec3 metal = vec3(0.4, 0.3, 0.0);\n    vec3 colour = metal;\n    float bevel = 1.0 - nbevel(-0.015, 0.0, r -t);\n    float light = bumpmap(dFdx(bevel), dFdy(bevel), 1.0);\n    colour = clamp(colour * light, 0.0, 1.0);\n    \n    float w = 0.75 * fwidth(r);\n    float alpha = 1.0 - smoothstep(-w, w, r - t);\n    return vec4(colour, 1.0) * alpha;\n}\n\nfloat pock(vec2 uv) {\n    mat2 r0 = mat2(0.866, 0.50, -0.50, 0.866) * 31.0;\n    mat2 r1 = mat2(1.0, 0.0, 0.0, 1.0) * 18.0;\n    float f = 0.66 * noise(uv * r0, 0.0) + 0.34 * noise(uv * r1, 1.0); \n    return smoothstep(0.75, 0.95, f);\n}\n\nvec4 flange(vec2 uv, float t, float r) {\n    const vec3 brass0 = vec3(0.70, 0.60, 0.1);\n    const vec3 brass1 = vec3(0.42, 0.34, 0.0);\n    float w0 = pock(uv);\n    float bevel = bevel(1.00, 1.05, r) - nbevel(1.20, 1.25, r);\n    float alpha = 1.0 - smoothstep(1.24, 1.25, r);\n\n    vec3 colour = mix(brass0, brass1, w0);\n\n    float light = bumpmap(dFdx(bevel), dFdy(bevel), 1.0)\n                * bumpmap(dFdx(-w0), dFdy(-w0), 0.7);\n    colour = clamp(colour * light, 0.0, 1.0);\n\n    return vec4(colour, 1.0) * alpha;\n}\n\nvec4 cracks(vec2 uv) {\n    const vec2 v[] = vec2[](\n        // random.gauss(0.62, 0.18), random.gauss(0.59, 0.18)\n        vec2(0.631, 0.598),\n        vec2(0.609, 0.749),\n        vec2(0.452, 0.935),\n        vec2(0.483, 0.568),\n        vec2(0.357, 0.525),\n        vec2(0.627, 0.596),\n        vec2(0.662, 0.712),\n        vec2(0.863, 0.683),\n        vec2(0.718, 0.260),\n        vec2(0.739, 0.991),\n        vec2(1.000, 0.625),\n        vec2(0.554, 0.661),\n        vec2(0.617, 0.563)\n    );\n    int m0 = 0, m1 = 0;\n    float d0 = 100.0, d1 = 100.0;\n    \n    vec2 wiggle = vec2(sin(1.0 + uv.y * 1.53) * 0.231,\n                       cos(uv.x * 1.7) * 0.221);\n    uv += wiggle;\n\n    for (int i = 0; i < v.length(); ++i) {\n        float d = distance(uv, v[i]);\n        if (d < d0) {\n            d1 = d0;\n            m1 = m0;\n            d0 = d;\n            m0 = i;\n        } else if (d < d1) {\n            d1 = d;\n            m1 = i;\n        }\n//        if (distance(uv, v[i]) < 0.02) return vec4(1.0, 1.0, 0.0, 1.0);\n    }\n\n    vec2 v0 = v[m0];\n    vec2 r = normalize(v[m1] - v0);\n    float d = dot(uv - v0, r);\n    float w = dot(uv - v0, vec2(r.x, -r.y));\n    float mid = distance(v0, v[m1]) / 2.0;\n    const vec4 glass = vec4(0.3, 1.0, 0.6, 1.0);\n    const vec4 white = vec4(1.0);\n    const vec4 black = vec4(vec3(0.0), 1.0);\n\n    float threshold = 0.01 + noise(uv * 3.0, 1.0) * 0.02;\n    vec4 colour = mix(mix(glass, white, abs(r.y)), black, abs(r.x));\n\n    return colour * smoothstep(0.0, 0.01, threshold - abs(mid - d));\n\n#if 0\n    // Nope, this bit is all wrong!\n    vec2 b = vec2(min(d, dw), max(d, dw));\n    float alpha = smoothstep(b.x - 0.02, b.x, mid) - smoothstep(b.y, b.y + 0.02, mid);\n    alpha *= 1.0 - (mid - b.x) / (b.y - b.x);\n    if (alpha > 0.01) return glass * vec4(vec3(0.9975), 1.0) * alpha;\n#endif    \n    return vec4(0.0);\n}\n\nvec4 f(vec2 uv) {\n    float t = atan(uv.y, uv.x);\n    float r = length(uv);\n\n    vec4 colour = vec4(0.0);\n    float w = 0.75 * fwidth(r);\n    float alpha = smoothstep(-w, w, r - 1.0);\n    if (alpha > 0.01) {\n        colour = wood(uv);\n        colour *= clamp(step(1.00, r), 0.0, 1.0);\n\n        colour = overlay(flange(uv, t, r), colour);\n\n        const float roundoff = 8.0 / (2.0 * 3.14159265358979);\n        float bt = round(t * roundoff) / roundoff;\n        vec2 bolt_uv = vec2(cos(bt), sin(bt)) * 1.125;\n\n        colour = overlay(bolt(uv - bolt_uv, hash(bolt_uv)), colour);\n    }\n    if (alpha < 0.99) {\n        colour = overlay(colour * alpha, cracks(uv));\n    }\n\n    return colour;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 d = 0.06125 * vec2(noise(fragCoord, iTime), noise(fragCoord.yx, 2.0 + iTime));\n    vec2 uv = (fragCoord + d - iResolution.xy * 0.5) * 4.0 / iResolution.x;\n\n    vec4 colour = f(uv);\n    vec3 back = 0.3 + 0.3*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec4 s = uv.xyxy * 3.0 + vec4(iTime, iTime * 0.382, -iTime, -iTime * 0.618);\n    back = vec3(noise(s.xy, 0.0), noise(s.zw, 1.0), noise(s.yz, 2.0)) * 3.0 - 1.0;\n\n    fragColor = overlay(colour, vec4(back, 1.0));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}