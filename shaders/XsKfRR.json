{
    "Shader": {
        "info": {
            "date": "1527450479",
            "description": "Here is my take on implementing a basic ray marcher, nothing fancy.",
            "flags": 0,
            "hasliked": 0,
            "id": "XsKfRR",
            "likes": 1,
            "name": "Marching Infinitely",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "Julius",
            "viewed": 549
        },
        "renderpass": [
            {
                "code": "struct ray { vec3 origin; vec3 normalizedDirection; };\n\nray cameraRay(vec2 uv, vec3 camera) {    \n    vec2 pos = uv - vec2(.5, .5);\n    \n\treturn ray(camera, normalize(vec3(pos.x, pos.y, 1)));\n}\n\nfloat dPlane(vec3 p) {\n\treturn p.y;\n}\n\nfloat dSphere(vec3 p, float radius) {\n\treturn length(p) - radius;\n}\n\nfloat dTorus(vec3 p, float radius, float strength) {\n\tvec2 mapped = vec2(length(p.xy) - radius, p.z);\n        \n    return length(mapped) - strength;\n}\n\nfloat dUnion(float d1, float d2)\n{\n    return min(d1,d2);\n}\n\nfloat smin(float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat dBlend(float d1, float d2, float k)\n{\n    return smin(d1,d2, k);\n}\n\nfloat rand(vec3 v){\n    return fract(sin(dot(v ,vec3(12.9898,78.233,.0235))) * 43758.5453);\n}\n\nvec3 stars(vec3 direction) {\n\tif(rand(direction) > .0001)\n        return vec3(0,0,0);\n    else\n        return vec3(1,1,1);\n}\n\nvec3 checkered(vec2 location) {\n\treturn ((mod(location.x, 2.) > 1.) != (mod(location.y, 2.) > 1.)) ? vec3(.3,.7,.3) : vec3(.4,1,.4);\n}\n\nvec3 foggy(vec3 color, float d, float view) {\n    float viewFactor = max(1. - d / view, 0.);\n    \n\treturn color * viewFactor + vec3(.5, .5, .5) * (1. - viewFactor);\n}\n\nfloat dRepeatStuff(vec3 p, vec3 period)\n{\n    vec3 mapped = mod(p, period)-0.5*period;\n    return dBlend(dTorus(mapped, 3., .3), dSphere(mapped - vec3(0, 2.3,0), .3), .3);\n}\n\nfloat dist(vec3 p) {\n    float d = dPlane(p);\n    d = dBlend(d, dRepeatStuff(p, vec3(0, 0, 10.)), 2.);\n    return d;\n}\n\nvec3 normal(vec3 p) {\n    float epsilon = .0005;\n    \n    float base = dist(p);\n    \n    return normalize(vec3(\n        dist(p + vec3(epsilon, 0, 0)) - base, \n        dist(p + vec3(0, epsilon, 0)) - base, \n        dist(p + vec3(0, 0, epsilon)) - base));\n}\n\nvec3 marchColor(ray r) {\n    vec3 p = r.origin;\n    float total = 100.;\n    vec3 color = stars(r.normalizedDirection);\n    vec3 n = vec3(-1, 1, -1);\n    for(int i=0; i<300; i++) {\n        float d = dist(p);\n        if(d < .001) {\n        \tcolor = checkered(p.xz);\n            total = length(p - r.origin);\n            n = normal(p);\n        }\n        \n        p += d * r.normalizedDirection;\n    }\n    \n    float lightFactor = dot(n, vec3(-.5, .5, -.5));\n    vec3 shadedColor = color * (.1 + .9 * lightFactor);\n    \n    return foggy(shadedColor, total, (r.origin.z + 150.) * .1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - vec2(0, .5 * (iResolution.y - iResolution.x))) /iResolution.xx;\n\n    ray r = cameraRay(uv, vec3(0,1.5,iTime * iTime));\n    \n    vec3 col = marchColor(r);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}