{
    "Shader": {
        "info": {
            "date": "1584808604",
            "description": "Messing with projection matrices and Fibonacci samplings",
            "flags": 0,
            "hasliked": 0,
            "id": "WslcW4",
            "likes": 15,
            "name": "Uniform spherical sampling ",
            "published": 3,
            "tags": [
                "hmmm"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 586
        },
        "renderpass": [
            {
                "code": "#define M_PI 3.141592653\n\nconst float PHI = 0.5*(sqrt(5.) + 1.);\n\nvec2 fibonacci_lattice(int i, int N)\n{\n    return vec2((float(i)+0.5)/float(N), mod(float(i)/PHI, 1.)); \n}\n\nvec3 fibonacci_sphere(int i, int N)\n{\n    vec2 xy = fibonacci_lattice(i, N);\n    vec2 pt = vec2(2.*M_PI*xy.y, acos(2.*xy.x - 1.) - M_PI*0.5);\n    return vec3(cos(pt.x)*cos(pt.y), sin(pt.x)*cos(pt.y), sin(pt.y)); \n}\n\nmat4 getPerspective(float fov, float aspect, float n, float f)\n{   \n    float scale = tan(fov * M_PI / 360.) * n; \n    float r = aspect * scale, l = -r; \n    float t = scale, b = -t; \n\n\t\n    return mat4(2. * n / (r - l), 0, 0, 0,\n                0, 2. * n / (t - b), 0, 0,\n                (r + l) / (r - l), (t + b) / (t - b), -(f + n) / (f - n), -1,\n                0, 0, -2. * f * n / (f - n), 0);\n}\n\nmat4 getRot(vec2 a)\n{\n    \n   mat4 theta_rot = mat4(1, 0, 0, 0,\n                         0, cos(a.y), sin(a.y), 0,\n                         0, -sin(a.y), cos(a.y), 0,\n                         0, 0, 0, 1); \n        \n   mat4 phi_rot = mat4(cos(a.x), sin(a.x), 0, 0,\n        \t\t       -sin(a.x), cos(a.x), 0, 0,\n        \t\t        0, 0, 1, 0,\n                      \t0, 0, 0, 1); \n   return transpose(phi_rot*theta_rot);\n}\n\nmat4 getModel(vec3 dx)\n{\n   return transpose(mat4(1, 0, 0, dx.x,\n        \t   0, 1, 0, dx.y,\n               0, 0, 1, dx.z,\n               0, 0, 0, 1)); ;\n}\n\nvec3 toScreen(vec4 X)\n{\n    return vec3(0.5*X.xy/X.w + 0.5, X.z);\n}\n\nfloat POINT(vec2 pos, float R, vec4 X)\n{\n    vec3 spos = toScreen(X);\n    return exp(-distance(pos, iResolution.xy*spos.xy)*spos.z/R);\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return mix(y0, y1, (val-x0)/(x1-x0));\n}\n\nfloat base(float x) \n{\n    if ( x <= -0.75 ) return 0.0;\n    else if ( x <= -0.25 ) return interpolate( x, 0.0, -0.75, 1.0, -0.25 );\n    else if ( x <= 0.25 ) return 1.0;\n    else if ( x <= 0.75 ) return interpolate( x, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n \tivec2 p = ivec2(pos.xy);\n    \n    int N = 128;\n    fragColor.xyz = vec3(0.);\n    \n    mat4 perspec = getPerspective(60., iResolution.x/iResolution.y, 0.001, 10.);\n    vec2 angles = (iMouse.z>0.)?(iMouse.xy/iResolution.xy)*vec2(2.*M_PI, M_PI):vec2(iTime, M_PI*0.5);\n    mat4 rot = getRot(angles);\n    mat4 sh = getModel(vec3(0.,0.,-2.5));\n    int R = 32;\n    int a = (R*(500/10))%N;\n    //rasterizer\n    for(int i = 0; i < N; i++)\n    {\n        int id = i;\n        vec3 d = fibonacci_sphere(id, N);\n        vec4 X = vec4(d, 1.);\n        vec4 XCAM = perspec*sh*rot*X;\n        \n        fragColor.xyz += 2.*jet_range(float(i), float(0), float(N))*POINT(pos, 10., XCAM);     \n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}