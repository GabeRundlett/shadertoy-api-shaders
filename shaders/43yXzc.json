{
    "Shader": {
        "info": {
            "date": "1720251126",
            "description": "used here: [url]https://www.shadertoy.com/view/4XyXzc[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "43yXzc",
            "likes": 14,
            "name": "tuto: triangle/hex coord + 3syms",
            "published": 3,
            "tags": [
                "tuto",
                "short",
                "symmetries"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 201
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 O, vec2 u )\n{                     // sqrt(3)/2\n    mat2 M = mat2(1,.5,0,.87);               // transform to tilted coordinates\n    vec2 R = iResolution.xy,\n         U = 2.*( 2.*u - R ) / R.y,\n         T = fract( U * inverse(M) );        // lozange coordinates\n    if ( T.x+T.y > 1.) T = 1.-T.yx;          // fold 2nd half â†’ triangle coordinates\n    O = vec4( T,0,0);                        // show local mapping = RG\n    T = T*M - vec2(.5,.33);                  // restore screen parallel coordinates, then centers\n    O -= smoothstep(.1,0.,length(T));        // show center = black\n    T = length(T) * cos( mod( atan(T.y,T.x)+1., 2.1 )-1. + vec2(0,11) ); // rot3-symmetry (*)\n    O += smoothstep(6./R.y,0.,abs(T.y)-.02); // trace line \n}\n\n/* (*): rot3-symmetry \n   sorry for the code-golfing style :-) . This is equivalent to:\n   \n    float m = 2.*Pi/3.,\n          a = mod( atan(T.y,T.x)+ m/2. , m ) - m/2.;\n    T = length(T) * vec2( cos(a), sin(a) );\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}