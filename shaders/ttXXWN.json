{
    "Shader": {
        "info": {
            "date": "1563550721",
            "description": "Another room with transparent objects, adding refraction without recursive tracing. \n\nThe previous room -> https://www.shadertoy.com/view/ttjGWt\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ttXXWN",
            "likes": 12,
            "name": "Transparent objects",
            "published": 3,
            "tags": [
                "reflection",
                "transparency",
                "refraction"
            ],
            "usePreview": 0,
            "username": "zxxuan1001",
            "viewed": 1183
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926\n#define EPSILON 0.001\n#define DEPTH 2\nconst int MAX_STEPS = 60;\nconst float MAX_DISTANCE = 80.0;\n\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n};\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n};\n    \nLight lightInfo = Light(vec3(3.0, 10.0, 0.0), vec3(10.0));\n\nstruct Material {\n    vec3 albedo;\n    float diffuse;\n    float specular;\n    float reflection;\n    float refraction;\n};\n    \nstruct Hit {\n    float dist;\n    int matIndex; //material info at the intersection point\n};\n\nfloat planeSDF(vec3 p) {\n    return p.y;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p, n.xyz) + n.w;\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nHit unionSDF(Hit d1, Hit d2) \n{\n    if (d1.dist < d2.dist) {\n        return d1;\n    } else {\n        return d2;\n    }  \n}\n\nvec3 doTranslate(vec3 p, vec3 offset) \n{\n    return p - offset;\n}\n\nvec3 rotX(vec3 p, float d) \n{\n    mat4 rotM= mat4(1.0, 0.0, 0.0, 0.0, \n                    0.0, cos(d), -sin(d), 0.0, \n                    0.0, sin(d), cos(d), 0.0, \n                    0.0, 0.0, 0.0, 1.0);\n    return vec3(rotM * vec4(p, 1.0));\n}\n\nHit sceneSDF(vec3 p) {\n    Hit rst;\n    vec3 p1 = doTranslate(p, vec3(6.0, 3.1, -3.0));\n    Hit is0 = Hit(sphereSDF(p1, 3.0), 2);\n    p1 = doTranslate(p, vec3(-2.0, 2.1, 8.0));\n    Hit is1 = Hit(sphereSDF(p1, 2.0 ), 2);\n    p1 = doTranslate(p, vec3(3.0, 1.5 + 10.0 * abs(sin(2.0*iTime)), 1.0));\n    Hit is2 = Hit(sphereSDF(p1, 1.5 ), 1);\n    \n   \t/*\n    Hit is3 = Hit(sdPlane(p, vec4(0.0, 1.0, 0.0, 0.0)), 0);\n    Hit is4 = Hit(sdPlane( p, vec4(0.0, 0.0, 1.0, 20.0)), 0);\n    Hit is5 = Hit(sdPlane( p, vec4(1.0, 0.0, 0.0, 20.0)), 0);\n    Hit is6 = Hit(sdPlane( p, vec4(-1.0, 0.0, 0.0, 20.0)), 0);\n    Hit is7 = Hit(sdPlane( p, vec4(0.0, 0.0, -1.0, 20.0)), 0);\n    Hit is8 = Hit(sdPlane( p, vec4(0.0, -1.0, 0.0, 30.0)), 0);\n    */\n    \n    Hit outerBox = Hit(sdBox(p-vec3(0.0,20.0,0.0), vec3(20.0,20.0,20.0)), 0); \n    outerBox.dist = -outerBox.dist;\n    \n    p1 = doTranslate(p, vec3(0.0, 3.5, -1.0));\n    Hit is9 = Hit(sdBox( p1, vec3(1.0, 3.0, 4.0)), 3);\n    \n    rst = unionSDF(is0, is1);\n    rst = unionSDF(rst, is2);\n    rst = unionSDF(rst, outerBox);\n    /*\n    rst = unionSDF(rst, is3);\n    rst = unionSDF(rst, is4);\n    rst = unionSDF(rst, is5);\n    rst = unionSDF(rst, is6);\n    rst = unionSDF(rst, is7);\n    rst = unionSDF(rst, is8);\n\t*/\n    rst = unionSDF(rst, is9);\n    return rst;\n}\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).dist - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).dist,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).dist - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).dist,\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)).dist - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).dist\n    ));\n}\n\nHit marching(vec3 ro, vec3 rd, float signInd) \n{\n    float tmax = MAX_DISTANCE;\n    float t = EPSILON;\n    Hit result = Hit(-1.0, -1);\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * t;\n        Hit res = sceneSDF(p); \n        float dist = res.dist * signInd;\n        \n        if (dist < 0.0 )\n        {\n            return result;\n        }\n        else if (t > tmax)\n        {\n            result.matIndex = -1;\n            result.dist = tmax;\n            break;\n        }\n        \n        t += max(dist, EPSILON); //faster than abs()\n        result.dist = t;\n        result.matIndex = res.matIndex;\n    }\n    \n    return result;\n}\n\nvec3 background(vec2 p) \n{\n    return vec3(0.0);//mix(vec3(0.2, 0.5, 0.5), vec3(0.4, 0.3, 0.3), pow(0.8, (p.y + 0.5) * 0.1));\n}\n\nvec3 getColor(vec3 ro, vec3 p, vec3 nor, int matIdx, in Material mat) {\n\tvec3 col = vec3(0.0);\n    vec3 N = nor;\n    vec3 V = normalize(ro - p);\n    vec3 L = normalize(lightInfo.position - p);\n    vec3 R = reflect(-L, N);\n    float spec = pow(max(dot(V, R), 0.0), mat.specular);\n    \n    // floor\n    if (matIdx < 1 && N.y > 0.5) {\n    \tmat.albedo = mix(vec3(0.0), vec3(0.95), mod(floor(p.x * 0.3) + floor(p.z * 0.3), 2.0));\n    } \n    vec3 ambient = vec3(0.1) * mat.albedo;\n    col += ambient;\n    \n    col += float(matIdx) * spec * lightInfo.color; \n    \n    return col;\n}\n\nmat3 getCamera( in vec3 ro, in vec3 ta) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//hacks for non-constant index expression\nMaterial getMaterial(int index) {\n    Material mat[4];\n    mat[0] = Material(vec3(0.6, 0.75, 0.8), 0.5, 16.0, 0.8, 0.0); \n    mat[1] = Material(vec3(1.0, 0.5, 0.5), 0.1, 128.0, 0.4, 0.9); \n    mat[2] = Material(vec3(0.1,0.1,0.2), 0.1, 128.0, 0.4, 0.9); \n    mat[3] = Material(vec3(0.2, 0.6, 0.6), 0.1, 128.0, 0.4, 0.9); \n    if (index == 0) {\n        return mat[0];\n    } else if (index == 1) {\n        return mat[1];\n    } else if (index == 2) {\n        return mat[2];\n    } else if (index == 3) {\n        return mat[3];\n    }\n}\n\nvec3 reflectionRay(in vec3 ori, in vec3 dir, in vec3 backColor, in vec3 pixColor, inout vec3 att) {\n\tfor (int i = 0; i < DEPTH; i++) {\n        Hit icp = marching(ori, dir, 1.0);\n        vec3 interP = ori + icp.dist * dir; \n        vec3 nor = getNormal(interP);\n        Material mat = getMaterial(icp.matIndex);\n        if (icp.matIndex < 0) {\n            pixColor += vec3(0.0);//mix(pixColor, backColor, att);\n        } else {\n            vec3 localColor = getColor(ori, interP, nor, icp.matIndex, mat); \n            pixColor = mix(pixColor, localColor, att);\n            dir = reflect(dir, nor);\n            ori = interP + dir * EPSILON;\n            att *= mat.reflection;\n        }\n    }\n    return pixColor;\n}\nvec3 refractionRay(in vec3 ori, in vec3 dir, in vec3 backColor, in vec3 pixColor, in float refractionRatio, inout float signInd, inout vec3 att) {\n    for (int i = 0; i < 4; i++) {\n        Hit icp = marching(ori, dir, signInd);\n        vec3 interP = ori + icp.dist * dir; \n        vec3 nor = signInd * getNormal(interP);\n        Material mat = getMaterial(icp.matIndex);\n        if (icp.matIndex < 0) {\n            pixColor += vec3(0.0); //mix(pixColor, backColor, att);\n        } else {\n            if (signInd > 0.0) { \n                vec3 localColor = getColor(ori, interP, nor, icp.matIndex, mat); \n                pixColor = mix(pixColor, localColor, att);\n            }\n            \n            vec3 refractDir = refract(dir, nor, refractionRatio);\n            vec3 reflectDir = reflect(dir, nor);\n            \n            if (dot(refractDir, refractDir) < EPSILON ) {\n                //total internal reflection\n                dir = reflectDir;\n                ori = interP + dir * EPSILON;\n                att *= mat.reflection;\n            } else {\n                //flip normal direction and refractionRatio for the next ray\n                dir = refractDir;\n                ori = interP + dir * EPSILON;\n                signInd = -signInd;\n                refractionRatio = 1.0/ refractionRatio;\n                att *= mat.refraction; \n            } \n        }\n    }\n    return pixColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5; \n    uv.x *= iResolution.x/iResolution.y;  \n   \n    vec3 col = vec3(0.0);\n    vec2 mouse = vec2(0.01) + iMouse.xy  / iResolution.xy ;\n    mouse.x -= 0.5;\n    float rot = mouse.x + iTime*0.05;\n    vec3 ro = vec3(-20.0 * cos(rot * 2.0 * PI), 2.0+8.0 * mouse.y, -20.0 * sin(rot * 2.0 * PI));\n    vec3 ta = vec3(0.0, 2.0, -2.0);\n    mat3 cam = getCamera(ro, ta);\n    vec3 rd = normalize(cam * vec3(uv, 1.0));\n    \n    vec3 nor = vec3(0.0);  \n    vec3 ori = ro;\n    vec3 dir = rd;\n    vec3 interP = vec3(0.0);\n    float signInd = 1.0;\n    vec3 reflectDir = vec3(0.0);\n    vec3 refractDir = vec3(0.0);\n    float refractionRatio = 1.0/1.4;\n    vec3 localColor = vec3(0.0);\n    vec3 f0 = vec3(0.03);\n    vec3 refractAtt = vec3(1.0);\n    vec3 reflectAtt = vec3(1.0);\n    vec3 refractCol = vec3(0.0);\n    vec3 reflectCol = vec3(0.0);\n    \n    //initial ray\n    Hit icp = marching(ori, dir, 1.0); //reserved for future use\n    Hit initRay = icp;\n    interP = ori + icp.dist * dir; \n    nor = signInd * getNormal(interP);\n    Material mat = getMaterial(icp.matIndex);\n    vec3 backColor = background((ori + MAX_DISTANCE * dir).xy);\n    if (icp.matIndex < 0) {\n        col += vec3(0.0);\n    } else {\n        col += getColor(ori, interP, nor, icp.matIndex, mat);\n    }\n    \n    refractDir = refract(dir, nor, refractionRatio);\n    reflectDir = reflect(dir, nor);\n    \n    //reflection ray\n    dir = reflectDir;\n    ori = interP + dir * EPSILON;\n    reflectAtt *= mat.reflection;\n    reflectCol = reflectionRay(ori, dir, backColor, col, reflectAtt);\n    \n    //refraction ray\n    if (dot(refractDir, refractDir) < EPSILON ) {\n        //total internal reflection\n        dir = reflectDir;\n        ori = interP + dir * EPSILON;\n    } else {\n        //flip normal direction and refractionRatio for the next ray\n        dir = refractDir;\n        ori = interP + dir * EPSILON;\n        signInd = -signInd;\n        refractionRatio = 1.0/refractionRatio;\n    }\n    refractAtt *= mat.refraction;\n    refractCol = refractionRay(ori, dir, backColor, col, refractionRatio, signInd,refractAtt);\n    \n    col = reflectCol + refractCol;\n    \n\tcol = pow(col, vec3(1.0/2.2)); \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}