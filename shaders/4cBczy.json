{
    "Shader": {
        "info": {
            "date": "1722653489",
            "description": "nausea",
            "flags": 0,
            "hasliked": 0,
            "id": "4cBczy",
            "likes": 5,
            "name": "noisea",
            "published": 3,
            "tags": [
                "2d",
                "noise",
                "gradient"
            ],
            "usePreview": 0,
            "username": "spac",
            "viewed": 101
        },
        "renderpass": [
            {
                "code": "#define TAU 6.28318530717958647693\n#define E   2.71828182845904523536\n#define PHI 1.618033988749894\n\nvec2 iexp(float i) {\n    return vec2(cos(i), sin(i));\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nint hash(int seed) {\n    // Thomas Wang hash\n    // http://www.burtleburtle.net/bob/hash/integer.html\n    seed = (seed ^ 61) ^ (seed >> 16);\n    seed *= 9;\n    seed = seed ^ (seed >> 4);\n    seed *= 0x27d4eb2d;\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nint hash(ivec2 seed) {\n    return hash(hash(seed.x) + seed.y);\n}\n\nint hash(ivec3 seed) {\n    return hash(hash(seed.xy) + seed.z);\n}\n\nfloat hash(float seed) {\n    int hash = hash(floatBitsToInt(seed));\n    return intBitsToFloat(0x3f800000 | (0x007fffff & hash)) - 1.0; \n}\n\nvec2 hash(vec2 seed) {\n    return vec2(hash(seed.x), hash(seed.y));\n}\n\nvec3 hash(vec3 seed) {\n    return vec3(hash(seed.x), hash(seed.y), hash(seed.z));\n}\n\n// random 32-bit integer\nint rand(inout int seed) {\n    // Xorshift algorithm from George Marsaglia's paper.\n    seed ^= (seed << 13);\n    seed ^= (seed >> 17);\n    seed ^= (seed << 5);\n    return seed;\n}\n\n// random float in the range [0.0f, 1.0f)\nfloat frand(inout int seed) {\n    return intBitsToFloat(0x3f800000 | (0x007fffff & rand(seed))) - 1.0;\n}\nvec2 frand2(inout int seed) {\n    return vec2(frand(seed), frand(seed));\n}\nvec3 frand3(inout int seed) {\n    return vec3(frand(seed), frand(seed), frand(seed));\n}\n\nfloat noise(in vec2 p) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd);\n}\n\nfloat noise(in vec2 p, in int octaves) {\n    vec2 scale = 2.0 * iexp(TAU*PHI);\n\n    float v = 0.0;\n    float d = 0.0;\n    float s = 1.0;\n    for (int i = 0; i < octaves; i++) {\n        v += s*noise(p);\n        d += s;\n\n        p = cmul(scale, p);\n        s /= 4.0;\n    }\n    return v / d;\n}\n\nvec3 palette(float x, float t) {\n    x *= 0.5;\n    \n    vec2 phase = 0.5-0.5*(iexp(TAU*t));\n    phase.x *= 1.0;\n    phase *= 0.33;\n\n    vec3 a = vec3(0.5, 0.6, 0.2);\n    vec3 b = vec3(0.4, 0.3, 0.8);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0+phase.x, 0.33+phase.y, 0.67);\n\n    return a + b*cos(TAU*(c*x + d));\n}\n\nfloat brown(inout int seed, float iterations) {\n    float d = 0.0;\n    for (float i = 0.0; i < iterations; i++) {\n        d += frand(seed);\n    }\n    return d / iterations;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int seed = hash(floatBitsToInt(fragCoord));\n    // Normalized pixel coordinates (from 0 to 1)\n    float t = 0.25*iTime;\n    vec2 uv = 1.0- 2.0*fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv = cmul(iexp(0.5*TAU), uv);\n    //uv *= 0.9;\n    // uv = cmul(iexp(-0.05*TAU*dot(uv, uv)*sin(0.25*t)), uv);\n\n    //uv.x -= 0.5;\n    vec2 p  = uv + 0.0*noise(2.0*cmul(iexp(TAU*0.025*(t+15.0)), 0.75*uv) + vec2(-t, 0.0), 8 );\n    p *= (1.5 + 0.75*sin(TAU*3.0*length(p)+0.5*t) + 2.5*cos(TAU*(0.5*uv.x + 0.15*t)));\n    \n    float v = 0.3*length(palette(p.x, t));\n    p += 0.7*vec2(brown(seed, 8.0), brown(seed, 8.0)) * v;\n    //p /= 0.5+abs(1.5*uv.y);\n\n    // Time varying pixel color\n    vec3 col = palette(p.x, t-(0.5*v*length(uv-3.67*iexp(+0.167*TAU*t))));\n\n    col = 1.0*vec3(noise(uv, 8));\n    // Output to screen\n    fragColor = vec4(col*col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}