{
    "Shader": {
        "info": {
            "date": "1723613478",
            "description": "originals https://www.shadertoy.com/view/MfXBWr https://www.shadertoy.com/view/Xcsfz4 and other https://www.shadertoy.com/view/lfVXRc",
            "flags": 0,
            "hasliked": 0,
            "id": "4flfDn",
            "likes": 2,
            "name": "cosmos and fbm noise",
            "published": 3,
            "tags": [
                "fbm",
                "stars",
                "cosmos"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 183
        },
        "renderpass": [
            {
                "code": "uniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define time iTime\n#define resolution iResolution.xy\n#define PI2 6.28318530718\n#define MAX_ITER 5\n\n\nuniform float spectrum;\nfloat snow(vec2 uv,float scale)\n{\nfloat w=smoothstep(1.,0.,-uv.y*(scale/10.));if(w<.0)return 0.;\n\nuv*=scale;vec2 s=floor(uv),f=fract(uv),p;float k=40.,d;\np=.5+.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;d=length(p);k=min(d,k);\nk=smoothstep(0.,k,sin(f.x+f.y)*0.003);\n    return k*w;\n}\n#define MAX_DISTANCE 1.0e+30\n\nstruct Plane {\n  vec3 origin;\n  vec3 normal;\n  vec3 color;\n};\n\nstruct Sphere {\n  float radius;\n  vec3 origin;\n  vec3 color;\n};\n\nstruct AABox {\n  vec3 min;\n  vec3 max;\n  vec3 color;\n};\n\nstruct Intersection {\n  float t;\n  vec3 point;\n  vec3 normal;\n  vec3 color;\n};\n\n// from: https://gist.github.com/Shtille/1f98c649abeeb7a18c5a56696546d3cf\nvec3 normalAtPointOnAABB (AABox aabox, vec3 point) {\n  float eps = -0.001;\n  vec3 hs = (aabox.max - aabox.min) * 0.5;\n  vec3 cb = (aabox.min + aabox.max) * 0.5;\n  vec3 vp = point - cb;\n  return normalize( sign(vp) * step(eps, abs(vp) - hs) );\n}\n\n// from: https://jcgt.org/published/0007/03/04/paper.pdf\nIntersection intersectAABB (vec3 rayOrg, vec3 rayDir, AABox aabox, Intersection info) {\n  vec3 invDir = 1.0 / rayDir;\n  vec3 rMin = (aabox.min - rayOrg) * invDir;\n  vec3 rMax = (aabox.max - rayOrg) * invDir;\n  vec3 vMin = min(rMin,rMax);\n  vec3 vMax = max(rMin,rMax);\n  float tMin = max(vMin.x,max(vMin.y,vMin.z));\n  float tMax = min(vMax.x,min(vMax.y,vMax.z));\n  if (tMax < 0.0) return info; // box is behind\n  if (tMin > tMax) return info; // never intersects\n//float t = (tMin < 0.0) ? tMax : tMin; // tMin<0=inside\n  float t = tMin;\n  if ((t > 0.0) && (t < info.t)) {\n    info.t = t;\n    info.point = rayOrg + rayDir * t;\n    info.normal = normalAtPointOnAABB(aabox, info.point);\n    info.color = aabox.color;\n  }\n  return info;\n}\n\nIntersection intersectSphere (vec3 rayOrg, vec3 rayDir, Sphere sphere, Intersection info) {\n  vec3 v = sphere.origin - rayOrg;\n  float b = dot(v,rayDir);\n  float d = b * b - dot(v,v) + sphere.radius * sphere.radius;\n  if (d < 0.0) return info;\n  float root = sqrt(d);\n  float t = b - root; // tmin\n//if (t < 0.0) t = b + root; // tmax\n  if ((t > 0.0) && (t < info.t)) {\n    info.t = t;\n    info.point = rayOrg + rayDir * t;\n    info.normal = normalize(info.point - sphere.origin);\n    info.color = sphere.color;\n  }\n  return info;\n}\n\nIntersection intersectPlane (vec3 rayOrg, vec3 rayDir, Plane plane, Intersection info) {\n  float c = dot(rayDir, plane.normal);\n  if (c >= 0.0) return info;\n  float d = dot(plane.origin, plane.normal);\n  float t = -(dot(rayOrg, plane.normal) - d) / c;\n  if ((t > 0.0) && (t < info.t)) {\n    info.t = t;\n    info.point = rayOrg + rayDir * t;\n    info.normal = plane.normal;\n    // 1x1 checker pattern\n    float m = abs(floor(info.point.x) + floor(info.point.z));\n    info.color = plane.color * (mod(m,2.0) < 1.0 ? 0.5 : 1.0);\n  }\n  return info;\n}\n\nIntersection intersectScene (vec3 rayOrg, vec3 rayDir)\n{\n  Intersection info;\n  info.t = MAX_DISTANCE;\n//info.point = vec3(...);\n//info.normal = vec3(...);\n  info.color = vec3(0.0, 0.0, 0.0); // black background\n\n  Plane plane = Plane(\n    vec3(0.0,0.0,0.0), // origin\n    vec3(0.0,1.0,0.0), // normal\n    vec3(1.0,1.0,1.0)); // color\n\n  Sphere sphere = Sphere(\n    0.5, // radius\n    vec3(0.0,0.5,0.0), // origin\n    vec3(1.0,1.0,1.0)); // color\n\n  AABox aabox = AABox(\n    vec3(-1.5,0.0,0.5), // min\n    vec3(-0.5,2.0,1.5), // max\n    vec3(1.0,1.0,1.0)); // color\n\n\n\n\n  return info;\n}\n\n\n// matrix operations adapted from:\n// https://www.shadertoy.com/view/ltyXWh\nmat4 translate (vec3 t) {\n  return mat4(\n    vec4(1.0,0.0,0.0,0.0),\n    vec4(0.0,1.0,0.0,0.0),\n    vec4(0.0,0.0,1.0,0.0),\n    vec4(t.x,t.y,t.z,1.0));\n}\n\nmat4 scale (vec3 s) {\n  return mat4(\n    vec4(s.x,0.0,0.0,0.0),\n    vec4(0.0,s.y,0.0,0.0),\n    vec4(0.0,0.0,s.z,0.0),\n    vec4(0.0,0.0,0.0,1.0));\n}\n\nmat4 ortho (float l, float r, float b, float t, float n, float f) {\n  return scale(vec3(2.0/(r-l),2.0/(t-b),2.0/(f-n))) *\n     translate(vec3(-(l+r)/2.0,-(t+b)/2.0,-(f+n)/2.0));\n}\n\nmat4 projection (float n, float f) {\n  return mat4(\n    vec4(n,0.0,0.0,0.0),\n    vec4(0.0,n,0.0,0.0),\n    vec4(0.0,0.0,n+f,1.0),\n    vec4(0.0,0.0,-f*n,0.0));\n}\n\nmat4 perspective (float fov, float aspect, float n, float f) {\n  float l = tan(fov * 0.5) * n;\n  float b = l / aspect;\n  return ortho(-l,l,-b,b,n,f) * projection(n,f) * scale(vec3(1.0,1.0,-1.0));\n}\n\nmat4 lookAt (vec3 eye, vec3 center, vec3 up) {\n  vec3 z = normalize(eye-center);\n  vec3 x = normalize(cross(up,z));\n  vec3 y = normalize(cross(z,x));\n  mat4 m = mat4(\n    vec4(x.x,y.x,z.x,0.0),\n    vec4(x.y,y.y,z.y,0.0),\n    vec4(x.z,y.z,z.z,0.0),\n    vec4(0.0,0.0,0.0,1.0));\n  return m * translate(-eye);\n}\n#define PI 3.141592\n#define TWOPI 6.283184\n\n#define R2D 180.0/PI*\n#define D2R PI/180.0*\n\nmat2 rotMat(in float r){float c = cos(r);float s = sin(r);return mat2(c,-s,s,c);}\n\n//fract -> -0.5 -> ABS  : coordinate absolute Looping\nfloat abs1d(in float x){return abs(fract(x)-0.5);}\nvec2 abs2d(in vec2 v){return abs(fract(v)-0.5);}\n\n#define OC 15.0\n\n\n\n#define OC 15.0\nvec3 Oilnoise(in vec2 pos, in vec3 RGB)\n{\n    vec2 q = vec2(0.0);\n    float result = 0.0;\n   \n    float s = 2.2;\n    float gain = 0.44;\n    vec2 aPos = abs2d(pos)*0.5;//add pos\n\n    for(float i = 0.0; i < OC; i++)\n    {\n        pos *= rotMat(D2R 30.);\n        float time = (sin(iTime)*0.015+0.5)*0.2+iTime*0.08;\n        q =  pos * s + time;\n        q =  pos * s + aPos + time;\n        q = vec2(cos(q));\n\n        result += abs1d(dot(q, vec2(0.3))) * gain;\n\n        s *= 1.07;\n        aPos += cos(q);\n        aPos*= rotMat(D2R 5.0);\n        aPos*= 1.2;\n    }\n   \n    result = pow(result,4.0);\n    return clamp( RGB / result, vec3(0.0), vec3(1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\nvec2 position = (gl_FragCoord.xy/resolution.xy) -0.5;\n   \nvec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\nvec3 finalColor=vec3(0);\n   \n    float time = time * .12;\n   float lightPower = 10.0;\n  float lightSpeed = 1.0 * iTime;\n  float lightAngle = mod(lightSpeed, 2.0 * 3.14);\n  vec3 lightOrg = vec3(\n    8.0 * sin(lightAngle),\n    2.0,\n    8.0 * cos(lightAngle)\n  );\n\n  float aspect = iResolution.x / iResolution.y;\n  mat4 projMatrix = perspective(radians(90.0),aspect,0.001,1000.0);\n\nvec3 col2 = vec3(0.0,0.0,0.0);\n    vec2 st = (fragCoord/iResolution.xy);\n            st.x = ((st.x - 0.5) *(iResolution.x / iResolution.y)) + 0.5;\n    float stMask = step(0.0, st.x * (1.0-st.x));\n\n\n    //st-=.5; //st move centor. Oil noise sampling base to 0.0 coordinate\n    st*=3.;\n   \n    vec3 rgb = vec3(1.30, .8, 1.200);\n   \n   \n    //berelium, 2024-06-07 - anti-aliasing\n    float AA = 1.0;\n    vec2 pix = 1.0 / iResolution.xy;\n    vec2 aaST = vec2(0.0);\n   \n    for(float i = 0.0; i < AA; i++)\n    {\n        for(float j = 0.0; j < AA; j++)\n        {\n            aaST = st + pix * vec2( (i+0.5)/AA, (j+0.5)/AA );\n            col2 += Oilnoise(aaST, rgb);\n        }\n   \n    }\n   \n    col2 /= AA * AA;\n   \n  vec3 rayOrg = vec3(2.0,2.0,15.0);\n  vec3 target = vec3(0.0,0.0,0.0);\n  mat4 viewMatrix = lookAt(rayOrg,target,vec3(0.0,1.0,0.0));\n\n  vec2 ndcPixel = fragCoord.xy / iResolution.xy * 2.0 - 1.0; // [-1..1]\n  vec4 viewDir = inverse(projMatrix) * vec4(ndcPixel, -1.0, 1.0); // view space\n  viewDir.w = 0.0; // project to infinity\n  vec3 rayDir = normalize((inverse(viewMatrix) * viewDir).xyz); // world space\n\n  Intersection info = intersectScene(rayOrg,rayDir);\n\n  if (info.t < MAX_DISTANCE)\n  {\n    //\n    // 3D lighting effects\n    //\n\n    vec3 shadowOrg = info.point;\n    vec3 shadowDir = lightOrg - shadowOrg;\n    float shadowLen2 = dot(shadowDir,shadowDir);\n    float shadowLen = sqrt(shadowLen2);\n    shadowDir /= shadowLen; // normalize\n\n    Intersection shadowInfo = intersectScene(shadowOrg,shadowDir);\n\n    float direct = (shadowInfo.t > shadowLen) ? 1.0 : 0.0;\n    float lambertian = max(0.0, dot(info.normal, shadowDir));\n    float attenuation = lightPower / shadowLen2;\n    float shaders = min(1.0, direct * lambertian * attenuation);\n\n    vec3 shadedColor = info.color * shaders;\n    vec3 tonedColor = pow(shadedColor, vec3(1.0 / 2.2));\n\n    info.color = tonedColor;\n  }\n\n\n  vec4 sunOrg = vec4(lightOrg, 1.0);\n  \n  sunOrg = viewMatrix * sunOrg;\n \n  sunOrg = projMatrix * sunOrg;\n  \n  sunOrg.xyz /= sunOrg.w;\n\n  sunOrg.xy = (sunOrg.xy + 1.0) * 0.5;\n\n  sunOrg.xy = sunOrg.xy * iResolution.xy - 1.0;\n\n\nvec2 cPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n   \n    // distance of current pixel from center\nfloat cLength = length(cPos);\n\nuv+= (cPos/cLength)*cos(cLength*12.0-iTime*10.0) * 0.03;\n   \n   \n  float sunSize = iResolution.y * 3.25; // scale by screen size\n  sunSize /= distance(lightOrg, rayOrg); // scale by view distance\n  float sunDist = distance(sunOrg.xy, fragCoord.xy);\n  vec3 sunColor = vec3(1.0, 0.5, 2.1) * sunSize / sunDist;\n  vec3 tonedSunColor = pow(sunColor, vec3(1.0 / 2.2));\n\n  // combine 3D and 2D color effects\n  info.color = min((info.color + tonedSunColor) * 0.5, vec3(1.0));\n\n\n    vec2 p3 = mod(uv * PI2, PI2) - 254.0  ;\n    vec2 i = vec2(p3);\n    float c3 = 1.2;\n    float inten =  0.0064;\n\n    for (int n = 0; n < MAX_ITER; n++) {\n        float t = time * (1.0 - (3.2 / float(n + 1)));\n        i = p3 + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n        c3 += 1.0 / length(vec2(p3.x / (sin(i.x + t) / inten + spectrum), p3.y / (cos(i.y + t) / inten)));\n    }\n\n    c3 /= float(MAX_ITER);\n    c3 = 0.22-pow(c3, 1.22);\n    vec3 colour = vec3(0.098, 0.098, 0.098+pow(abs(c3), 5.2));\nfloat c=smoothstep(0.1,0.0,clamp(uv.x*.11+.99,0.,.99));\nc+=snow(uv,3.)*.8;\nc+=snow(uv,5.)*.7;\nc+=snow(uv,7.)*.6;\n\nc+=snow(uv,9.)*.5;\n\nc+=snow(uv,11.)*.4;\n\nc+=snow(uv,13.)*.3;\n\nc+=snow(uv,15.)*.2;\n\nc+=snow(uv,17.)*.1;\n\n vec2 center = iResolution.xy * 0.5;\n\n  vec2 orbit = iResolution.yy * 0.4;\n\n  float speed = iTime * 0.1;\n\n  float twoPI = 2.0 * 3.14;\n\n  float angle = mod(speed * twoPI, twoPI);\n\n  vec2 xform = vec2(sin(angle), cos(angle));\n\n  vec2 origin = orbit * xform + center;\n\n  float size = iResolution.y * 0.1;\n\n  float dist = length(fragCoord - origin);\n\n  vec3 color = vec3(1.0, 1.0, 1.0) * size / dist;\nvec2 p = gl_FragCoord.xy / resolution.xy;\n    vec2 q = p - vec2(0.5, 0.5);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * sin(vec3(0,2,4) + time / 2.);\n   \n    float r = 0.4 + 0.1 * cos(atan(-p.x + 2., q.y / 2.) * 60.0 + 20.0 * -q.x + ((length(mouse / .4) / .25) * 2.));\n\n    float r1 = 0.2 + 0.1 * cos(atan(-p.x + 2., -p.y / 2.) * 5.0 + 20.0 * -q.x + time * 0.5);\n    float r2 = 0.4 + 0.1 * cos(atan(-p.x + 4., -q.y / 2.) * 10.0 + 20.0 * -q.x + time * 0.5);\n    float r3 = 0.6 + 0.1 * cos(atan(-p.x + 6., -q.y / 2.) * 20.0 + 20.0 * -q.x + time * 0.5);\n   \n    col /= smoothstep(r / 100., r, length(q)) / .2;\n\n    col.x /= smoothstep(r1 / 100., r1, length(q)) / .2;\n    col.y /= smoothstep(r2 / 100., r2, length(q)) / .2;\n    col.z /= smoothstep(r3 / 100., r3, length(q)) / .2;\nfloat y = 0.2 * position.y * sin(200.0*position.y - 20.0*time*1.35);\nfragColor = vec4(y *5., y, y* 5., 1.0);\ny = 1.0 / (600. * abs(position.y - y));\ny += 1./(665.*length(position - vec2(0., position.y)));\nfloat saule = 1./(65.*length(position - vec2(0, 0)));\nfragColor = vec4(vec3(c*10.0,c*5.1,c*01.9)+ info.color+color*0.1, 1.0);\n   \n\nfragColor+=vec4(finalColor*10.+colour*0.25*col2*6.5,1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}