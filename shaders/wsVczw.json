{
    "Shader": {
        "info": {
            "date": "1602519481",
            "description": "aaa",
            "flags": 32,
            "hasliked": 0,
            "id": "wsVczw",
            "likes": 4,
            "name": "Metaballs but it's in 2d",
            "published": 3,
            "tags": [
                "metaballs"
            ],
            "usePreview": 0,
            "username": "Pork",
            "viewed": 512
        },
        "renderpass": [
            {
                "code": "const vec4 edgeColor = vec4(1.0, 1.0, 1.0, 1.0);\n\nfloat grayscale(vec4 col)\n{\n\treturn (col.r+col.g+col.b)/3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 c1 = (fragCoord.xy + vec2(-1, 1)) / iResolution.xy;\n    vec2 c2 = (fragCoord.xy + vec2(0, 1)) / iResolution.xy;\n    vec2 c3 = (fragCoord.xy + vec2(1, 1)) / iResolution.xy;\n    vec2 c4 = (fragCoord.xy + vec2(-1, 0)) / iResolution.xy;\n    vec2 c5 = (fragCoord.xy + vec2(0, 0)) / iResolution.xy;\n    vec2 c6 = (fragCoord.xy + vec2(1, 0)) / iResolution.xy;\n    vec2 c7 = (fragCoord.xy + vec2(-1, -1)) / iResolution.xy;\n    vec2 c8 = (fragCoord.xy + vec2(0, -1)) / iResolution.xy;\n    vec2 c9 = (fragCoord.xy + vec2(1, -1)) / iResolution.xy;\n    \n    vec4 s1 = texture(iChannel0, c1);\n    vec4 s2 = texture(iChannel0, c2);\n    vec4 s3 = texture(iChannel0, c3);\n    vec4 s4 = texture(iChannel0, c4);\n    vec4 s5 = texture(iChannel0, c5);\n    vec4 s6 = texture(iChannel0, c6);\n    vec4 s7 = texture(iChannel0, c7);\n    vec4 s8 = texture(iChannel0, c8);\n    vec4 s9 = texture(iChannel0, c9);\n    \n    float v1 = grayscale(s1);\n    float v2 = grayscale(s2);\n    float v3 = grayscale(s3);\n    float v4 = grayscale(s4);\n    float v5 = grayscale(s5);\n    float v6 = grayscale(s6);\n    float v7 = grayscale(s7);\n    float v8 = grayscale(s8);\n    float v9 = grayscale(s9);\n    \n    \n    //sobel filter, see https://homepages.inf.ed.ac.uk/rbf/HIPR2/sobel.htm\n    float sobelVal = abs((v1+2.0*v1+v3)-(v7+2.0*v8+v9))+abs((v3+2.0*v6+v9)-(v1+2.0*v4+v7));\n    \n    vec4 col = texture(iChannel0, uv);\n    \n    fragColor = vec4(sobelVal * edgeColor) + col;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float aR = 16.0/9.0;\n \n\nfloat remap(float value, float low1, float high1, float low2, float high2)\n{\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);      \n}\n// polynomial smooth min (k = 0.1); (IQuilez)\nfloat smin(float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nstruct Circle\n{\n\tvec2 pos;\n    float radius;\n};\n    \nCircle circle1 = Circle(vec2(.3, .3), .2);\nCircle circle2 = Circle(vec2(1, .5), .2);\nCircle circle3 = Circle(vec2(1, .5), .2);\n\n//settings\nconst float timeStep = 1.0;\nconst float smoothFactor = 0.2;\n\n\nfloat distToCenter(vec2 point, Circle circle)\n{\n    return sqrt(pow(point.x - circle.pos.x, 2.0) + pow(point.y - circle.pos.y, 2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    //Circle Movement\n\tfloat timeSine = (sin(iTime/timeStep)+1.0)/2.0;\n    float timeCos = (cos(iTime/.7)+1.0)/2.0;\n  \tfloat timeTan = (tan(iTime/timeStep)+1.0)/2.0;\n\n    circle1.pos.x = mix(0.0 + circle1.radius, aR - circle1.radius, timeSine);\n    circle1.pos.y = mix(0.0 + circle1.radius, 1.0 - circle1.radius, timeSine);\n    circle2.pos.x = aR-mix(0.0 + circle2.radius, aR - circle2.radius, timeSine);\n    \n    circle3.pos.y = mix(0.0 + circle3.radius, 1.0 - circle3.radius, timeCos);\n    circle3.pos.x = mix(0.0 + circle3.radius, aR - circle3.radius, 1.0-timeCos);\n\n    //For coloring based on distance to closest center\n    float centerDist = distToCenter(uv, circle1);\n    float centerDist2 = distToCenter(uv, circle2);  \n    float centerDist3 = distToCenter(uv, circle3);\n    float closestCenterDist = min(min(centerDist, centerDist2), centerDist3);\n    float circleDist = centerDist - circle1.radius;    \n\n    circleDist = smin(circleDist, centerDist2 - circle2.radius, smoothFactor);\n    circleDist = smin(circleDist, centerDist3 - circle3.radius, smoothFactor);\n    if(circleDist <= .01)\n    {        \n        //centreDist ranges from 0 (center) to radius (circumpherence)\n        //normalize in 0...1 range by dividing by radius\n        closestCenterDist /= .2;\n        centerDist /=.2;\n        centerDist2 /=.2;\n        centerDist3 /=.2;\n        \n        //Weighted distribution of color, the closest you are to a sphere the more its color \n        //bleeds onto the current pixel.\n        //    distanceToCircle\n        //    ----------------\n        //  distanceToAllCircles\n        //Thought i had to do 1 - this but apparently it works like this so eh ill take it\n        \n        float c1Infl = centerDist / (centerDist + centerDist2 + centerDist3);\n        float c2Infl = centerDist2 / (centerDist + centerDist2 + centerDist3);\n        float c3Infl = centerDist3 / (centerDist + centerDist2 + centerDist3);\n\n        vec3 col1 = vec3(146, 0, 255) * c1Infl;\n        vec3 col2 = vec3(255, 146, 0) * c2Infl;\n        vec3 col3 = vec3(0, 255, 146) * c3Infl;\n        \n        fragColor = vec4(/*closestCenterDist * */(col1+col2 + col3)/255.0, 1.0);\n    }\n    else\n    {\n    \tfragColor = vec4(0);   \n    }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Box blur to thicken outlines\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n    \n    vec2 c1 = (fragCoord.xy + vec2(-1, 1)) / iResolution.xy;\n    vec2 c2 = (fragCoord.xy + vec2(0, 1)) / iResolution.xy;\n    vec2 c3 = (fragCoord.xy + vec2(1, 1)) / iResolution.xy;\n    vec2 c4 = (fragCoord.xy + vec2(-1, 0)) / iResolution.xy;\n    vec2 c5 = (fragCoord.xy + vec2(0, 0)) / iResolution.xy;\n    vec2 c6 = (fragCoord.xy + vec2(1, 0)) / iResolution.xy;\n    vec2 c7 = (fragCoord.xy + vec2(-1, -1)) / iResolution.xy;\n    vec2 c8 = (fragCoord.xy + vec2(0, -1)) / iResolution.xy;\n    vec2 c9 = (fragCoord.xy + vec2(1, -1)) / iResolution.xy;\n    \n    vec4 s1 = texture(iChannel0, c1);\n    vec4 s2 = texture(iChannel0, c2);\n    vec4 s3 = texture(iChannel0, c3);\n    vec4 s4 = texture(iChannel0, c4);\n    vec4 s5 = texture(iChannel0, c5);\n    vec4 s6 = texture(iChannel0, c6);\n    vec4 s7 = texture(iChannel0, c7);\n    vec4 s8 = texture(iChannel0, c8);\n    vec4 s9 = texture(iChannel0, c9);\n    \n    fragColor = (s1+s2+s3+s4+s5+s6+s7+s8+s9)/9.0;\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}