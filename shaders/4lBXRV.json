{
    "Shader": {
        "info": {
            "date": "1444821679",
            "description": "One pentagonal prototile can cover a plane.\nThis is a newly discovered type of pentagonal tiling, few months ago only 14 types were known. \nPrototyped in [url=http://polycu.be]PolyCube[/url]: [url]http://polycu.be/edit/?h=OewoGS[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "4lBXRV",
            "likes": 35,
            "name": "15th Pentagonal Tiling",
            "published": 3,
            "tags": [
                "tiling",
                "bsp",
                "pentagon",
                "pentagonal",
                "prototile"
            ],
            "usePreview": 0,
            "username": "tomkh",
            "viewed": 1277
        },
        "renderpass": [
            {
                "code": "// Pentagonal tiling of type 15th\n// by Tomkh @2015\n\n// Prototyped in PolyCube:\n//   http://polycu.be/edit/?h=OewoGS - derivation of unit cell and BSP\n//   http://polycu.be/edit/?h=ckcP5s - original shader\n\n// Background:\n//   One pentagonal prototile can cover a plane.\n//   This is a newly discovered type of pentagonal tiling,\n//   few months ago only 14 types were known.\n\n// Related paper (pre-print):\n//   http://arxiv.org/abs/1510.01186\n//   Casey Mann, Jennifer McLoud-Mann, David Von Derau\n//   \"Convex pentagons that admit i-block transitive tilings\"\n\n// Method used:\n//   First tiles and edges in unit cell are found,\n//   then BSP is calculated for the edges,\n//   and generated into shader code.\n\n// Do you like colors? \n//  Put 0 if not ;)\n//  Put 1 for unique coloring\n//  Put 2 for isohedral coloring\n#define USE_COLORS 2\n\nconst int iterations = 64;\nconst float dist_eps = .001;\nconst float ray_max = 200.0;\nconst float fog_density = .04;\nconst float fog_start = 16.;\n\nconst float cam_dist = 13.5;\n\n//---------------------------------------------\n// Tiling code\n\n#define N 5\nvec3 edge[N];\nmat3 u2t[24];\nmat3 s2u, u2s;\n\n#define REC0(nx,ny,nd) n=vec3(nx,ny,nd);d=dot(n.xy,q)-n.z;if(d<0.){\n#define REC1 }else{\n#define END }\n#define LEAF0(nx,ny,nd,type,tile) REC0(nx,ny,nd) c=type; m=u2t[tile];\n#define LEAF1(type,tile) REC1 c=type; m=u2t[tile];\n\nvoid initTiling()\n{\n// Auto-generated unit cell, tile transformations and edges\nu2s = mat3(8.175694346,-9.400439218,0,2.638958434,0.707106781,0,0,0,1);\ns2u = mat3(0.023116785,0.307319821,0,-0.086273015,0.267280376,0,0,0,1);\nu2t[0] = mat3(0.866025404,-0.5,0,-0.5,-0.866025404,0,-0.448287736,-1.673032607,1);\nu2t[1] = mat3(0.5,0.866025404,0,0.866025404,-0.5,0,2.897777479,-3.60488426,1);\nu2t[2] = mat3(0.5,-0.866025404,0,0.866025404,0.5,0,2.897777479,3.60488426,1);\nu2t[3] = mat3(1,0,0,0,1,0,0,0,1);\nu2t[4] = mat3(0.866025404,0.5,0,-0.5,0.866025404,0,-2.380139389,-0.258819045,1);\nu2t[5] = mat3(0.866025404,-0.5,0,-0.5,-0.866025404,0,-2.380139389,0.258819045,1);\nu2t[6] = mat3(0.5,0.866025404,0,0.866025404,-0.5,0,0.965925826,-5.536735913,1);\nu2t[7] = mat3(0.866025404,0.5,0,0.5,-0.866025404,0,0.258819045,-6.243842694,1);\nu2t[8] = mat3(0.5,-0.866025404,0,0.866025404,0.5,0,0.965925826,5.536735913,1);\nu2t[9] = mat3(-0.866025404,-0.5,0,-0.5,0.866025404,0,1.673032607,6.243842694,1);\nu2t[10] = mat3(1,0,0,0,1,0,-2.638958434,-0.707106781,1);\nu2t[11] = mat3(0.5,0.866025404,0,0.866025404,-0.5,0,-0.965925826,-7.468587565,1);\nu2t[12] = mat3(0.866025404,0.5,0,0.5,-0.866025404,0,-2.380139389,-6.950949475,1);\nu2t[13] = mat3(-1,0,0,0,-1,0,1.931851653,0,1);\nu2t[14] = mat3(-1,0,0,0,-1,0,10.107545999,-9.400439218,1);\nu2t[15] = mat3(-0.866025404,-0.5,0,0.5,-0.866025404,0,11.073471825,-3.346065215,1);\nu2t[16] = mat3(-0.866025404,0.5,0,0.5,0.866025404,0,11.073471825,3.346065215,1);\nu2t[17] = mat3(-0.5,-0.866025404,0,-0.866025404,0.5,0,-2.121320344,7.916875301,1);\nu2t[18] = mat3(-0.866025404,-0.5,0,-0.5,0.866025404,0,4.311991041,6.950949475,1);\nu2t[19] = mat3(-0.5,0.866025404,0,-0.866025404,-0.5,0,-2.121320344,-7.916875301,1);\nu2t[20] = mat3(-0.866025404,-0.5,0,0.5,-0.866025404,0,13.005323478,-1.414213562,1);\nu2t[21] = mat3(-0.866025404,0.5,0,0.5,0.866025404,0,13.005323478,1.414213562,1);\nu2t[22] = mat3(-0.5,-0.866025404,0,-0.866025404,0.5,0,-0.189468691,9.848726954,1);\nu2t[23] = mat3(-0.5,0.866025404,0,-0.866025404,-0.5,0,-0.189468691,-9.848726954,1);\nedge[0] = vec3(0,-1,0);\nedge[1] = vec3(0.707106781,-0.707106781,0);\nedge[2] = vec3(0.258819045,0.965925826,-0.866025404);\nedge[3] = vec3(-0.258819045,0.965925826,-1.5);\nedge[4] = vec3(-0.965925826,-0.258819045,-1.866025404);\n}\n\nvec2 dTile(in vec2 p)\n{\n   // Transform to unit cell space\n   vec3 p2 = s2u * vec3(p, 1.);\n   \n   // Repeat\n   p2.xy = fract(p2.xy);\n   \n   // Transform back\n   vec2 q = vec2(u2s * p2);\n   \n   vec3 n;\n   int c;\n   float d;\n   mat3 m;\n\n// Auto-generated BSP\nREC0(0.707106781,-0.707106781,6.464101615)\n REC0(0.866025404,-0.5,3.60488426)\n  REC0(0.258819045,-0.965925826,1.5)\n   REC0(0.258819045,0.965925826,0.5)\n    LEAF0(0.258819045,0.965925826,-0.866025404,2,0)\n    REC1\n     REC0(0,1,0)\n      LEAF0(0.965925826,0.258819045,1.866025404,0,3)\n      LEAF1(2,5)\n      END\n     LEAF1(6,13)\n     END\n    END\n   REC1\n    LEAF0(-0.707106781,0.707106781,-1.366025404,0,10)\n    LEAF1(6,13)\n    END\n   END\n  REC1\n   REC0(0.707106781,0.707106781,0)\n    LEAF0(0.707106781,-0.707106781,2.732050808,2,0)\n    LEAF1(3,1)\n    END\n   REC1\n    LEAF0(0.5,0.866025404,0.258819045,1,4)\n    LEAF1(2,5)\n    END\n   END\n  END\n REC1\n  REC0(0.258819045,0.965925826,-1.866025404)\n   REC0(0.258819045,-0.965925826,4.598076211)\n    LEAF0(0.965925826,-0.258819045,4.232050808,5,2)\n    REC1\n     LEAF0(0.866025404,-0.5,5.536735913,3,6)\n     LEAF1(5,8)\n     END\n    END\n   REC1\n    REC0(0.5,-0.866025404,6.243842694)\n     LEAF0(0.965925826,0.258819045,3.232050808,4,7)\n     LEAF1(5,8)\n     END\n    LEAF1(10,9)\n    END\n   END\n  REC1\n   REC0(0.5,0.866025404,0.258819045)\n    LEAF0(0.965925826,-0.258819045,4.232050808,1,4)\n    REC1\n     LEAF0(0.866025404,-0.5,5.536735913,3,6)\n     LEAF1(5,8)\n     END\n    END\n   REC1\n    REC0(0.866025404,-0.5,5.536735913)\n     LEAF0(0.707106781,-0.707106781,4.098076211,2,5)\n     LEAF1(3,6)\n     END\n    REC1\n     LEAF0(0.965925826,-0.258819045,6.598076211,5,8)\n     LEAF1(3,11)\n     END\n    END\n   END\n  END\n END\nREC1\n REC0(0.258819045,0.965925826,-4.598076211)\n  REC0(0.258819045,0.965925826,-5.598076211)\n   REC0(-0.258819045,0.965925826,-10.196152423)\n    LEAF0(-0.965925826,-0.258819045,-5.464101615,6,14)\n    LEAF1(8,16)\n    END\n   REC1\n    LEAF0(-0.5,-0.866025404,3.346065215,7,15)\n    LEAF1(8,16)\n    END\n   END\n  REC1\n   REC0(-0.707106781,0.707106781,-11.062177826)\n    LEAF0(0.707106781,0.707106781,0.5,7,15)\n    LEAF1(8,21)\n    END\n   REC1\n    REC0(-0.965925826,0.258819045,-7.964101615)\n     LEAF0(0.707106781,0.707106781,0.5,7,15)\n     LEAF1(9,22)\n     END\n    REC1\n     LEAF0(-0.866025404,0.5,-7.916875301,9,17)\n     LEAF1(11,19)\n     END\n    END\n   END\n  END\n REC1\n  REC0(-0.258819045,0.965925826,-7.098076211)\n   REC0(-0.866025404,0.5,-9.848726954)\n    REC0(-0.5,-0.866025404,1.414213562)\n     LEAF0(-0.965925826,0.258819045,-10.330127019,7,20)\n     LEAF1(9,22)\n     END\n    REC1\n     LEAF0(-0.707106781,0.707106781,-11.062177826,8,21)\n     LEAF1(9,22)\n     END\n    END\n   REC1\n    REC0(-0.866025404,0.5,-7.916875301)\n     LEAF0(0.965925826,-0.258819045,7.964101615,9,17)\n     LEAF1(11,23)\n     END\n    LEAF1(11,19)\n    END\n   END\n  REC1\n   REC0(0.258819045,0.965925826,-3.232050808)\n    LEAF0(0.707106781,-0.707106781,7.330127019,10,9)\n    REC1\n     REC0(0.707106781,-0.707106781,8.696152423)\n      LEAF0(-0.965925826,-0.258819045,-4.098076211,10,18)\n      LEAF1(11,19)\n      END\n     LEAF1(11,23)\n     END\n    END\n   REC1\n    REC0(0.5,-0.866025404,6.950949475)\n     LEAF0(0.258819045,-0.965925826,4.598076211,3,11)\n     LEAF1(4,12)\n     END\n    REC1\n     LEAF0(0.707106781,-0.707106781,8.696152423,10,18)\n     LEAF1(11,23)\n     END\n    END\n   END\n  END\n END\nEND\n\n   // Transform to prototile\n   q = vec2(m * vec3(q,1));\n   \n   // Calculate closest distance to edges\n   float sd = 1.;\n   for(int i=0; i<N; ++i) {\n      vec3 n = edge[i];\n      sd = min(sd, abs(dot(n.xy,q)-n.z));\n   }\n   \n   return vec2(float(c),sd);\n}\n\n//---------------------------------------------\n\nconst float bump = .1;\nconst float ground = .2;\n\nfloat dField(in vec3 p)\n{\n   float d = p.y + ground;\n   \n   vec2 tile = dTile(p.xz);\n   float d3;\n   //d3 = min(.05,smoothstep(0.,1.,tile.y*20.)*.05)*.5;\n   d3 = min(.05,tile.y)*.5;\n   d3 += tile.y*.3;\n   d3 = min(d3,bump);\n   //d3 = smoothstep(0.,1.,d3/cut)*cut;\n   d -= d3;\n   return d;\n}\n\nvec3 dNormal(in vec3 p, in float eps)\n{\n   vec2 e = vec2(eps,0.);\n   return normalize(vec3(\n      dField(p + e.xyy) - dField(p - e.xyy),\n      dField(p + e.yxy) - dField(p - e.yxy),\n      dField(p + e.yyx) - dField(p - e.yyx) ));\n}\n\nvec4 trace(in vec3 ray_start, in vec3 ray_dir)\n{\n   float ray_len = 0.0;\n   vec3 p = ray_start;\n   \n   // Intersect with ground plane first\n   \n   if (ray_dir.y >= 0.) return vec4(0.);\n   \n   float dist;\n   dist = (ray_start.y + ground - bump)/-ray_dir.y;\n   p += dist*ray_dir;\n   ray_len += dist;\n   if (ray_len > ray_max) return vec4(0.);\n   //return vec4(p, ray_len);\n   \n   for(int i=0; i<iterations; ++i) {\n   \t  dist = dField(p);\n      if (dist < dist_eps*ray_len) break;\n      if (ray_len > ray_max) return vec4(0.0);\n      p += dist*ray_dir;\n      ray_len += dist;\n   }\n   return vec4(p, ray_len);\n}\n\nvec3 shade(in vec3 ray_start, in vec3 ray_dir,\n   in vec3 light_dir, in vec3 fog_color, in vec4 hit)\n{   \n   vec3 dir = hit.xyz - ray_start;\n   vec3 norm = dNormal(hit.xyz, .015);//*hit.w);\n   float diffuse = max(0.0, dot(norm, light_dir));\n   float spec = max(0.0,dot(reflect(light_dir,norm),normalize(dir)));\n   spec = pow(spec, 32.0)*.7;\n\n   vec2 tile = dTile(hit.xz);\n   float sh = tile.x;\n#if USE_COLORS == 2\n   sh = (mod(sh,6.)+3.)*(1./9.);\n#else\n   sh *= (1./12.);\n#endif\n   float sd = min(tile.y,.05)*20.;\n#if USE_COLORS == 0\n   vec3 base_color = vec3(.5);\n#else\n   vec3 base_color =\n    vec3(exp(pow(sh-.75,2.)*-10.),\n         exp(pow(sh-.50,2.)*-20.),\n         exp(pow(sh-.25,2.)*-10.));\n#endif\n   vec3 color = mix(vec3(0.),vec3(1.),diffuse)*base_color +\n      spec*vec3(1.,1.,.9);\n   color *= sd;\n   \n   float fog_dist = max(0.,length(dir) - fog_start);\n   float fog = 1.0 - 1.0/exp(fog_dist*fog_density);\n   color = mix(color, fog_color, fog);\n\n   return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   initTiling();\n   \n   vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    \n   vec3 light_dir = normalize(vec3(.5, 1.0, .25));\n   \n   // Simple model-view matrix:\n   float ms = 2.5/iResolution.y;\n   float ang, si, co;\n   ang = (iMouse.z > 0.0) ? (iMouse.x - iResolution.x*.5) * -ms :\n      -iTime*.25;\n   si = sin(ang); co = cos(ang);\n   mat3 cam_mat = mat3(\n      co, 0., si,\n      0., 1., 0.,\n     -si, 0., co);\n   ang = (iMouse.z > 0.0) ? (iMouse.y - iResolution.y) * -ms - .1:\n      cos(-iTime*.5)*.4 + .8;\n   ang = max(0.,ang);\n   si = sin(ang); co = cos(ang);\n   cam_mat = cam_mat * mat3(\n      1., 0., 0.,\n      0., co, si,\n      0.,-si, co);\n\n   vec3 pos = cam_mat*vec3(0., 0., -cam_dist);\n   vec3 dir = normalize(cam_mat*vec3(uv, 1.));\n\n   vec3 color;\n   vec3 fog_color = vec3(min(1.,.4+max(-.1,dir.y*.8)));\n   vec4 hit = trace(pos, dir);\n   if (hit.w == 0.) {\n      color = fog_color;\n   } else {\n      color = shade(pos, dir, light_dir, fog_color, hit);\n   }\n   \n   // gamma correction:\n   color = pow(color,vec3(.7));\n   \n   fragColor = vec4(color, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}