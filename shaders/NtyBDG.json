{
    "Shader": {
        "info": {
            "date": "1665117025",
            "description": "compute and draw interpolated parameters",
            "flags": 32,
            "hasliked": 0,
            "id": "NtyBDG",
            "likes": 3,
            "name": "interpolated parameters v3",
            "published": 3,
            "tags": [
                "sampling",
                "interpolation"
            ],
            "usePreview": 0,
            "username": "cyperus",
            "viewed": 229
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"interpolated parameters\" created by Colling Patrik (cyperus) in 2022\n//\n// BASED ON\n// - by FabriceNeyret2\n//   https://www.shadertoy.com/view/4ljyWc \"compared interpolation\"\n//\n// DESCRIPTION:\n//\n// - The animsystem alows to define and interpolate animation parameter sets.\n//   The interpolation mode for each parameter can be set individually.\n//   Interpolation modes are Jump, Linear, Cubic-Linear, Catmull-Rom.\n//\n// - Buffer A\n//   Compute and store loop-times and time interpolated parameters.\n//   Draw the parameter curves as picture.\n//\n// - Image\n//   Test the interpolated parameters by\n//   ,reading interpolated parameters from Buffer A into an 1D-array.\n//   ,drawing loop-times and interpolated parameters as bars.\n//   ,show the parameter curves picture from Buffer A.\n//   ,show the parameter buffer (texels) from Buffer A.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst bool \n    PARAMETER_BARS_DRAW = true,\n    BARS_LOOPTIMES_DRAW = true;\n\n// helper \nvec4 T3(ivec2 id) { return texelFetch(iChannel3,id,0); }\n\nvoid mainImage( out vec4 O, in vec2 U)\n{\n    /// read app state from Buffer A\n    // get animation times  \n    vec4 anim_ts = T3(buf_loop_tO);\n    \n    // get time interpolated parameters and store them into an 1D-array\n    const int a_pa_ipvR = buf_pa_ipvR.y * 4;\n    float[a_pa_ipvR] pa_ipv;    \n    for( int j = 0; j < buf_pa_ipvR.y; j++)\n    {\n        vec4 temp = T3(ivec2(0,j) + buf_pa_ipvO);\n        for( int k = 0; k<4; k++)\n            pa_ipv[4*j+k] = temp[k];\n    }\n    \n    /// draw\n    // uv coordinates\n    vec2 uv = vec2( U.x/iResolution.x, (2.*U.y/iResolution.y-1.) );  // uv.x in[0.,1.], uv.y in[-1.,1.]                                    \n    float pix = 1./iResolution.y; // pixel size        \n    \n    float a, h, f, u_id; // alpha, hue, value, id\n    O = vec4(0.);\n    \n    if(PARAMETER_BARS_DRAW) {\n    u_id = floor(uv.x*float(a_pa_ipvR));\n    f = map_v( pa_ipv[int(u_id)] );\n    a = abs(uv.y) <= abs(f) && sign(f) == sign(uv.y) ? 1.: 0.;\n    h = u_id/float(a_pa_ipvR);\n    O += (1.-O.a) * vec4( hsv2rgb(h, 1., .7),1.) * a;\n    }\n    \n    if(BARS_LOOPTIMES_DRAW) {\n    u_id = floor(4. * uv.x);\n    f = map_v( anim_ts[int(u_id)] );\n    a = abs(uv.y) < f ? 1.: 0.;\n    h = u_id/4.;\n    O += (1.-O.a) * vec4(hsv2rgb(h, 1., .1),1.) * a;\n    }\n        \n    /// mix Buffer A with Image\n    O = mix(T3(ivec2(U)), O, MIX_FACTOR);\n    \n    // gamma correction (in the last pass)\n    O.xyz = pow(O.xyz, vec3(1./2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const bool\n    PARAMETER_PRESETS_INTERPOLATION_BUFFERED = false,  // (compile + time reset) (GOTO: **)\n    MAP_V_LINEAR = false; // Viewport v-axis mapping (comment to see all values form -INF to +INF)\n\n/// const\nconst float \n    PI_2 = acos(0.),\n    PI   = 2.*PI_2,\n    PI2  = 2.*PI;\n\nconst float loop_t = 36.;  // animation loop time in seconds\nconst ivec2 pa_preR = ivec2(8,3); // number of ivec2(parameter-presets, texels per preset), (4 parameters per texel)\n\nconst ivec2\n/// Buffer A: app state memory layout (O: offset, R: range)\n    buf_O = ivec2(40,10),             // buffer offset (compile + time reset)\n// state variables\n    buf_loop_tO = ivec2(3,0)+buf_O,   // loop times\n// parameter interpolated values (buffer 1D-array)\n    buf_pa_ipvO = ivec2(5,0)+buf_O,\n    buf_pa_ipvR = ivec2(1,pa_preR.y),\n// parameter presets (buffer 2D-array)  (GOTO: **)\n    buf_pa_preO = ivec2(6,0)+buf_O,\n    buf_pa_preR = pa_preR;\n\n/// viewport\nconst float \n    SUBDIV_V   = 10.,\n    MIX_FACTOR = 0.2;     // Mix Buffer A with Image \n\n// remap the v-axis for drawing, the parameter values in the Buffer A are not changed\nfloat map_v(float f)\n{\n    if(MAP_V_LINEAR)\n      return f/SUBDIV_V;            // axis-v subdivision\n    else\n      return atan(f/SUBDIV_V)/PI_2; // [-inf, +inf] --> [-1.,+1,]\n    \n}\n\nfloat inv_map_v(float f)\n{\n    if(MAP_V_LINEAR)\n      return f*SUBDIV_V;            // linear\n    else\n      return SUBDIV_V*tan(PI_2*f);  // [-1.,+1,] --> [-inf, +inf] \n}\n\n/// sdf shapes\nfloat line(vec2 p, vec2 a, vec2 b) // line segment with disc ends\n{ \n    // a,b : line start end point\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.); // proj coord on line\n    return length(p - b * h);                       // dist to segment\n}\n\nfloat line0(vec2 p, vec2 a,vec2 b) // line segment without disc ends\n{ \n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b),       // proj coord on line\n          c = clamp(h, 0., 1.);\n    return h==c ? length(p - b * h) : 1e5; // dist to strict segment\n}\n\nfloat linehv(float u, float r) // line horizontal or vertical\n{\n    return abs(u) - r;\n}\n\nfloat disk( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat circle(vec2 p, float r)\n{\n    return abs(length(p) - r);\n}\n\n// sdf operators\n\nfloat opR( in float sdf, in float r ) // round\n{\n  return sdf - r;\n}\n\nfloat opO( in float sdf, in float r ) // onion\n{\n  return abs(sdf) - r;\n}\n\n// smooth\nfloat S(float sdf, float pix)\n{\n    // pix : pixel size\n    // smooth pixel cut equal sided\n    return smoothstep(1.5, -1.5, sdf/pix);    \n}\n\n/// color\nvec3 h2rgb(float h)\n{\n    return vec3(.6*(1.+cos(2.*PI*(h+vec3(0,1,2)/3.))));\n}\n\nvec3 hsv2rgb(float h, float s, float v)\n{\n    // hue, saturation, value\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n    return v * mix( vec3(1.0), rgb, s);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const bool\n    TIME_LINE_MOVE       = true,\n    PARAMETER_CURVE_DRAW = true;\n\n// helpers \nvec4 T3(ivec2 id) { return texelFetch(iChannel3,id,0); }\n\nbool inside(ivec2 id, ivec2 idR) {\n    return (0 <= id.x && id.x < idR.x ) && (0 <= id.y && id.y < idR.y ); }\n\n// interpolation modes\nconst int iJUMP = 0, iLINEAR = 1, iCUBLIN = 2, iCATMULL = 3;\n\n// define parameter interpolation mode for each parameter\nconst ivec4[pa_preR.y]\n    pa_imode = ivec4[](\n        ivec4(iJUMP,iLINEAR ,iCUBLIN ,iCATMULL),\n        ivec4(iJUMP,iLINEAR ,iCUBLIN ,iCATMULL),\n        ivec4(iJUMP,iLINEAR ,iCUBLIN ,iCATMULL));\n\nconst vec4[pa_preR.x * pa_preR.y]\n    pa_sets = vec4[](\n        // pa_set0:\n        vec4( 0.),\n        vec4( 0.),\n        vec4( -5.),\n\n        // pa_set1:\n        vec4( 1.),\n        vec4( 4.),\n        vec4( 5.),\n\n        // pa_set2:\n        vec4( 2.),\n        vec4( 8.),\n        vec4( -5.),\n\n        // pa_set3\n        vec4( 3.),\n        vec4( 4.),\n        vec4( 5.),\n\n        // pa_set4\n        vec4( 4.),\n        vec4( 0.),\n        vec4( -5.),\n\n        // pa_set5\n        vec4( 5.),\n        vec4( -4.),\n        vec4( 5.),\n\n        //pa_set6\n        vec4( 6.),\n        vec4( -8.),\n        vec4( -5.),\n\n        //pa_set7\n        vec4( 7.),\n        vec4( -4.),\n        vec4( 5.));\n\nvec4 buf_pa_init(ivec2 pa_tex_id) // (GOTO: **)\n{\n     // initialize parameter sets buffer\n     // id.x : parameters set index, id.y : parameter texel index\n     // return texel with 4 parameter values. \n    return pa_sets[ pa_tex_id.x * pa_preR.y +  pa_tex_id.y ];\n}\n\nvec4 loop_times(in float time, in float loop_length, in int seg_num) {\n    // the segment-times are equidistant.\n    float loop_ntimec  = time / loop_length; // loop-normalized-time continious for periodic functions\n    float loop_ntime = fract(loop_ntimec);   // in [0.,1.]          loop-normalized-time\n    time = loop_ntime * float(seg_num);      // in [0., seg_num[    loop-time\n    float seg_id = floor(time);              // in [0., seg_num-1.] segment-index\n    float seg_ntime = time-seg_id;           // in [0., 1.]         segment-normalized-time\n    return vec4(seg_ntime, seg_id, loop_ntime, loop_ntimec);\n    }\n\nivec4 seg_cp_idv4_get(in int seg_id, in int seg_num) {\n    // calculate interpolation segment control point indexes\n    return (seg_num+seg_id + ivec4(-1,0,1,2))%seg_num;                      \n    }\n\nfloat jump(vec4 cps, float t) {\n    return cps.y;} \n\nfloat linear(vec4 cps, float t) {\n    return mix(cps.y,cps.z,t);}\n\nfloat cubiclinear(vec4 cps, float t) {\n    return mix(cps.y,cps.z,smoothstep(0.,1.,t));}\n\nfloat catmull(vec4 cps, float t) {\n\tfloat A0 = mix( cps.x, cps.y, t+1.),\n\t      A1 = mix( cps.y, cps.z, t),\n\t      A2 = mix( cps.z, cps.w, t-1.),\n          B0 = mix( A0, A1, .5*t + .5),\n\t      B1 = mix( A1, A2, .5*t);\n\treturn mix( B0, B1, t);}\n\nfloat interpolate(vec4 cps, int im, float seg_nt)\n{\n    float iv = 1.; // interpolated value (default value)\n    iv = im<2? im<1? jump(cps, seg_nt)        // im == 0 \n                   : linear(cps, seg_nt)      // im == 1\n             : im<3? cubiclinear(cps, seg_nt) // im == 2\n                   : catmull(cps, seg_nt);    // im == 3\n    return iv;\n}\n\nvec4 interpolatev4( in mat4 cpm4, in ivec4 imv4, in float seg_nt)\n{\n    return vec4(interpolate(vec4(cpm4[0][0], cpm4[1][0], cpm4[2][0], cpm4[3][0]), imv4.x, seg_nt),\n                interpolate(vec4(cpm4[0][1], cpm4[1][1], cpm4[2][1], cpm4[3][1]), imv4.y, seg_nt),\n                interpolate(vec4(cpm4[0][2], cpm4[1][2], cpm4[2][2], cpm4[3][2]), imv4.z, seg_nt),\n                interpolate(vec4(cpm4[0][3], cpm4[1][3], cpm4[2][3], cpm4[3][3]), imv4.w, seg_nt));\n}\n\nvoid pa_curves_draw(inout vec4 O, in vec2 U, in float loop_nt)\n{\n    // normalized coords\n    float pix_u = 1./iResolution.x;\n    float pix_v = 1./iResolution.y;\n    U /=iResolution.xy;\n    // uv graph\n    float u = (TIME_LINE_MOVE) ? U.x : U.x+0.5+loop_nt;\n          u *= float(pa_preR.x); // u in[0, pa_preR.x]\n    float v = (2.*U.y-1.);       // v in[-1., 0., +1]\n\n    // interpolation segment coordinates (local segment coordinates)\n    float u_id = floor(u); float u_lo = u - u_id;         // index parameterset, u-local                          \n    ivec4 cp_idv4 = seg_cp_idv4_get(int(u_id),pa_preR.x); // parameter-set contolpoint ids\n    \n    // draw from front to back\n    O = vec4(0);\n\n    // parameter curves\n    for(int j = 0; j < pa_preR.y; j++) // j = index texel \n    {\n        // get controlpoint values from 4 adjacent preset texels\n        mat4 cpm4;\n        if(PARAMETER_PRESETS_INTERPOLATION_BUFFERED) { // (GOTO: **)\n        // read from buffer presets\n        cpm4 = mat4( T3( ivec2(cp_idv4.x, j) + buf_pa_preO )   // preset -1\n                   , T3( ivec2(cp_idv4.y, j) + buf_pa_preO )   // preset  0\n                   , T3( ivec2(cp_idv4.z, j) + buf_pa_preO )   // preset +1\n                   , T3( ivec2(cp_idv4.w, j) + buf_pa_preO )); // preset +2\n        }else {\n        // read from array presets\n        cpm4 = mat4( pa_sets[ cp_idv4.x * pa_preR.y +  j ]   // preset -1\n                   , pa_sets[ cp_idv4.y * pa_preR.y +  j ]   // preset  0\n                   , pa_sets[ cp_idv4.z * pa_preR.y +  j ]   // preset +1\n                   , pa_sets[ cp_idv4.w * pa_preR.y +  j ]); // preset +2 \n        }\n        \n        // interpolate texel  \n        vec4 ipvv4 = interpolatev4(cpm4, pa_imode[j], u_lo);\n        \n        // draw curves        \n        for(int k = 0; k < 4; k++) // k = index component of texel (x,y,z,w)\n        {\n            float ipv = map_v(ipvv4[k]);                     // interpolated value\n            float a = (pa_imode[j][k] == iJUMP)              // JUMP not continuous function, needs special case\n                ? S( opR(line(vec2(u,v),vec2(u_id,ipv),vec2(u_id+1.,ipv)), pix_v * 1.25 ),pix_v)\n                : smoothstep(1.5,-1.5, abs(ipv-v)/fwidth(ipv-v));\n            //a *= ivec2(0,3) == PA_SELECTED ? 1.0: 0.3;     // hightlight selected parameter\n            O += (1.-O.a) * vec4( hsv2rgb(float(4*j + k)/float(pa_preR.y * 4), 1., 1.), 1.) * a;\n        }    \n    }\n    float x;\n    // time line\n    x = (TIME_LINE_MOVE) ? U.x - loop_nt : U.x - 0.5;\n    vec4 tl_C = vec4(1,1,0,1);\n         tl_C.a *= S(linehv( x, .5 * pix_u), pix_u);\n    O += (1.-O.a) * vec4(tl_C.rgb,1.) * tl_C.a;\n    \n    // coord lines\n    // horizontal\n    vec4 coordlh_C = vec4(1.);\n         coordlh_C.a = S(linehv( v, pix_v), pix_v); // 0.\n         O += (1.-O.a) * vec4(coordlh_C.rgb,1.) * coordlh_C.a;     \n    for (float i = 0.; i < 4.; i++) // {1.,10.,100.,1000.,}\n        {coordlh_C.a = S(linehv( abs(v) - map_v( pow(10., i)), pix_v) ,pix_v);       \n         O += (1.-O.a) * vec4(coordlh_C.rgb,1.) * coordlh_C.a;}    \n        \n    // vertical   \n    x = (TIME_LINE_MOVE) ? U.x : U.x - 0.5 + loop_nt;\n    x = fract(x-.5)-0.5;\n    vec4 coordlv_C = vec4(1.);\n         coordlv_C.a *= S(linehv( x, .5 * pix_u), pix_u);\n    O += (1.-O.a) * vec4(coordlv_C.rgb,1.) * coordlv_C.a;\n       \n    // coords pattern\n    v = inv_map_v(v);\n    vec4 C0 = vec4( vec3( 0.05+(0.05*( sign(fract(0.5*u) - 0.5) * sign(fract(0.5*v) - 0.5) )) ) , 1.);\n    \n    if(MAP_V_LINEAR) {\n        O += (1.-O.a) * C0;}\n    else {\n        vec4 C1 = vec4( vec3( 0.075 ), 1.);\n        O += (1.-O.a) * mix(C0, C1, smoothstep(10., 40. ,abs(v))); } // mask false pattern for high values of v\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    bool Init = (iFrame < 10);\n    ivec2 U_id = ivec2(U);\n    vec4 loop_ts = loop_times( iTime, loop_t, pa_preR.x);\n\n    /// update app state in Buffer A\n    // store loop_times\n    if (U_id == buf_loop_tO)\n    {\n        O = loop_ts;\n        return;\n    }\n    // compute and store time interpolated parameter values\n    if (inside(U_id - buf_pa_ipvO, buf_pa_ipvR))\n    {\n         // get controlpoints ids\n        ivec4 cp_idv4 = seg_cp_idv4_get(int(loop_ts.y), pa_preR.x);\n        \n        // get controlpoint values from 4 adjacent preset texels\n        int j = U_id.y-buf_pa_ipvO.y;\n        mat4 cpm4;\n        if (PARAMETER_PRESETS_INTERPOLATION_BUFFERED) { // (GOTO: **)\n        cpm4 = mat4( T3(ivec2(cp_idv4.x, j) + buf_pa_preO)   // preset -1\n                   , T3(ivec2(cp_idv4.y, j) + buf_pa_preO)   // preset  0\n                   , T3(ivec2(cp_idv4.z, j) + buf_pa_preO)   // preset +1\n                   , T3(ivec2(cp_idv4.w, j) + buf_pa_preO)); // preset +1\n        }else {                \n        // read from array presets\n        cpm4 = mat4( pa_sets[ cp_idv4.x * pa_preR.y +  j ]   // preset -1\n                   , pa_sets[ cp_idv4.y * pa_preR.y +  j ]   // preset  0\n                   , pa_sets[ cp_idv4.z * pa_preR.y +  j ]   // preset +1\n                   , pa_sets[ cp_idv4.w * pa_preR.y +  j ]); // preset +2\n        }               \n        // interpolate texel  \n        O = interpolatev4(cpm4, pa_imode[U_id.y], loop_ts.x);\n        return;        \n    }\n    \n    // initialize parameter texel buffer\n    if(PARAMETER_PRESETS_INTERPOLATION_BUFFERED) { // (GOTO: **)\n        if (inside(U_id - buf_pa_preO, buf_pa_preR))\n        {\n            if (Init)\n                O = buf_pa_init(U_id - buf_pa_preO);\n            else\n                O = T3(U_id); // refresh with previous state\n            return;    \n        }\n    }\n    // draw\n    if(PARAMETER_CURVE_DRAW) {\n        pa_curves_draw(O, U, loop_ts.z);}\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}