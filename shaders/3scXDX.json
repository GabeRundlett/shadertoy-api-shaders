{
    "Shader": {
        "info": {
            "date": "1572966767",
            "description": "Doodling session #9",
            "flags": 32,
            "hasliked": 0,
            "id": "3scXDX",
            "likes": 15,
            "name": "Doodling #9",
            "published": 3,
            "tags": [
                "raymarch"
            ],
            "usePreview": 0,
            "username": "lsdlive",
            "viewed": 818
        },
        "renderpass": [
            {
                "code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nDoodling #9.\n\nGeometries are generated with sphere-tracing algorithms:\nhttp://www.michaelwalczyk.com/blog/2017/5/25/ray-marching\nhttps://iquilezles.org/articles/distfunctions\nhttp://mercury.sexy/hg_sdf/\n\nSome notation:\np: position (usually in world space)\nrd: ray direction (eye or view vector)\n*/\n\n\n// Radial blur postfx from XT95:\n// https://github.com/XT95/VisualLiveSystem/blob/master/release/data/postFX/green-pink%20blur.glsl\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    float amt_blur = 45.;\n\tfloat amt_dist = 50.;\n    \n\tvec2 offset =  normalize(uv-.5)*pow(length(uv-.5),4.)/amt_blur;\n\tvec2 offset2 = (uv-.5)/amt_dist;\n\tvec3 col = vec3(0.);\n\tfor(int i=0; i<16; i++)\n\t{\n\t\t//RGB distortion\n\t\tcol.r += texture(iChannel0,uv+offset*float(i)+offset2).r;\n\t\tcol.g += texture(iChannel0,uv+offset*float(i)).g;\n\t\tcol.b += texture(iChannel0,uv+offset*float(i)-offset2).b;\n\t}\n\tcol /= 16.; // box blur\n    \n    // vignetting\n    col *= 0.5 + 0.5*pow(16.0*uv.x*uv.y*(1.0 - uv.x)*(1.0 - uv.y), 0.25);\n    \n    fragColor.rgb = col;\n\tfragColor.a = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nDoodling #9.\n\nGeometries are generated with sphere-tracing algorithms:\nhttp://www.michaelwalczyk.com/blog/2017/5/25/ray-marching\nhttps://iquilezles.org/articles/distfunctions\nhttp://mercury.sexy/hg_sdf/\n\nSome notation:\np: position (usually in world space)\nrd: ray direction (eye or view vector)\n*/\n\nfloat bpm = 120.;\nfloat gtime;\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 path(float t) {\n\tfloat a = sin(t * .2 + 1.5), b = sin(t * .2);\n\treturn vec2(a * b, a * 2.);\n}\n\nfloat od(vec3 p, float d) {\n\treturn dot(p, normalize(sign(p))) - d;\n}\n\n// hglibs\n// http://mercury.sexy/hg_sdf/\nfloat re(float p, float d) {\n\treturn mod(p - d * .5, d) - d * .5;\n}\nvoid amod(inout vec2 p, float m) {\n\tfloat a = re(atan(p.x, p.y), m); // not hglib\n\tp = vec2(cos(a), sin(a)) * length(p);\n}\nvoid mo(inout vec2 p, vec2 d) {\n\tp = abs(p) - d;\n\tif (p.y > p.x)\n\t\tp = p.yx;\n}\n\n\n// sdf\nfloat g = 0.; // glow/coloring\nfloat de(vec3 p) {\n\tp.xy += path(p.z);\n\n\tp.z = re(p.z, 4.);\n\n    // segment 1: triangles\n\tvec3 q = p;\n\tq.xy *= r2d(-iTime);\n\tamod(q.xy, 6.28 / 3.);\n\tmo(q.yz, vec2(.3, .5));\n\tmo(q.xy, vec2(.1, .1));\n\tmo(q.xy, vec2(.1, .8));\n\tq.x = abs(q.x) - 1.5 + sin(sin(iTime*(bpm / 60.)*3.)*3.)*.7;\n\tfloat cyl = length(q.xy) - .02;\n\n    // segment 2: main shapes\n\tp.xy *= r2d(iTime);\n\tamod(p.xy, 6.28 / 8.);\n\tmo(p.xy, vec2(1.1, 1.3));\n\tamod(p.xy, 6.28 / 7.);\n\tmo(p.zy, vec2(.2, .2));\n\n\tfloat d = od(p, .7);\n\tg += .025 / (.013 + d * d);\n\td = min(cyl, d);\n\tg -= .01 / (.013 + d * d);\n\treturn d;\n}\n\nvec3 camera(vec3 ro, vec3 ta, vec2 uv) {\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = normalize(cross(vec3(0, 1, 0), fwd));\n\tvec3 up = normalize(cross(fwd, left));\n\treturn normalize(fwd + left * uv.x + up * uv.y);\n}\n\nfloat random(vec2 uv) {\n\treturn fract(sin(dot(uv, vec2(12.2544, 35.1571))) * 5418.548416);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tgtime = iTime * 4.;\n\tvec3 ro = vec3(0, 0, -3. + gtime);\n\n\tvec3 ta = vec3(0, 0, gtime);\n\tro.xy -= path(ro.z);\n\tta.xy -= path(ta.z);\n\tvec3 rd = camera(ro, ta, uv);\n\n\tfloat dither = random(uv);\n\n\tvec3 p;\n\tfloat t = 0., ri = 0.;\n\tfor (float i = 0.; i < 1.; i += .02) {\n\t\tri = i;\n\t\tp = ro + rd * t;\n\t\tfloat d = de(p);\n\t\td *= 1. + dither * .1;\n\t\td = max(abs(d), .002);\n\t\tt += d * .7;\n\t}\n\n\tvec3 c = mix(vec3(.2, .2, .6), vec3(.1, .1, .22), abs(uv.x*uv.y) + ri);\n\tc += g * (.012) + .2 + (.5 + .5*sin(sin(iTime*(bpm / 60.)*2.)*3.))*.2;\n\n\n\t// color correction\n\tc *= c;\n\tfragColor = vec4(c, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}