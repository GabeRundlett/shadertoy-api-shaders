{
    "Shader": {
        "info": {
            "date": "1554051304",
            "description": "this is a smaller, semi-crunched version of parent: \nhttps://www.shadertoy.com/view/4llfR4",
            "flags": 0,
            "hasliked": 0,
            "id": "3djSDm",
            "likes": 4,
            "name": "CSG cull small frustrum",
            "published": 3,
            "tags": [
                "shadow",
                "csg",
                "frustrumculling"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 490
        },
        "renderpass": [
            {
                "code": "#define sat(a) clamp(a,0.,1.)\n\n\n//this is a smaller, semi-crunched version of \n//parent: https://www.shadertoy.com/view/4llfR4\n//parent uses a 2d library, that often is overly convoluted structure (https://www.shadertoy.com/view/lslXW8)\n//because it implements logox-turtle plotter command-structure\n//, but i think this is silly in the context of distance fields with parallel processing\n//and more often than not just way too obfuscating\n//this dismantles that a unnecessary/unused structure a bit, and uses left-endian punctuation/context\n//this has the side effect of defining many global variables, bad style for efficient/compatible opengl code.\n\n// Frustum CSG Tree Intersection 2\n// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\n// set to 1 to show CSG operator debug setup\n#define DEBUG_CSG_OP CSG_ANDN\n#define TEST_SETUP 0\n\n#define PERSPECTIVE\n\nvec2 ray_origin0;\nvec2 ray_origin1;\nvec2 ray_dir0;\nvec2 ray_dir1;\n\nconst int op_set=0;\nconst int op_or=1;\nconst int op_and=2;\nconst int op_and_not=3;\nconst int empty=-1;\nconst int solid=-2;\nconst float infinity=9999.;\nconst vec2 empty_interval=vec2(infinity,-infinity);\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\n\n// represents the current drawing context\n// you usually don't need to change anything here\n\nvec4 Sposition;\nvec2 Sshape;\nvec2 Sclip;\nvec2 Sscale;\nfloat Sline_width=11.;\nbool Spremultiply;\nvec2 Sblur;\nvec4 Ssource;\nvec2 Sstart_pt;\nvec2 Slast_pt;\nint Ssource_blend;\nbool Shas_clip;\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\n\nfloat AA;\nfloat AAINV;\nvec3 _color=vec3(1);\nconst int Replace=0;// default: replace the new source with the old one\nconst int Alpha=1;// alpha-blend the new source on top of the old one\nconst int Multiply=2;// multiply the new source with the old one\n\n\n// these brushes are usually imported using a SSBO\n// here we provide a small local array\n#if TEST_SETUP\n #define NUM_BRUSHES 3\n #define NUM_CSG_OPS 3\n#else\n #define NUM_BRUSHES 7\n #define NUM_CSG_OPS 7\n#endif\n\nstruct CSG_OP{int brush;int product;};\nCSG_OP csg_ops[NUM_CSG_OPS];\nbool keep[NUM_CSG_OPS];\nbool clip[NUM_CSG_OPS];\nvec3 brushes[NUM_BRUSHES];\nvec4 brush_intervals[NUM_BRUSHES];// vec2: front interval, vec2: back interval\n\nvec2 iCircle(in vec2 o, in vec2 d, in vec3 s\n){d=normalize(d)\n ;o-=s.xy\n ;float k=dot(o,d)\n ;float D=k*k-dot(o,o)+s.z*s.z\n ;float q=sqrt(D)\n ;if(D<0.)return vec2(infinity, -infinity)\n ;return (vec2(-q,q)-k)*d.x;}\n\nfloat dCircle(vec2 p, vec3 i){return length(p-i.xy)-i.z;}\n\n\nvec2 length2(vec4 a){return vec2(length(a.xy),length(a.zw));}\nvec2 dot2(vec4 a,vec2 b){return vec2(dot(a.xy,b),dot(a.zw,b));}\nfloat mus(){return min(Sscale.x,Sscale.y);}\nvoid add_field(vec2 d){Sshape=min(Sshape,d/Sscale);}\nvoid move_to(vec2 p){Sstart_pt=p;Slast_pt=p;}\nvec3 hue(float hue){return sat(abs(mod(hue*6.+vec3(0,4,2),6.)-3.)-1.);}\nvec3 hsl(float h,float s,float l){return l+s*(hue(h)-.5)*(1.-abs(2.*l-1.));}\nvec4 hsl(float h, float s,float l,float a){return vec4(hsl(h,s,l),a);}\nvoid circle(vec2 p, float r\n){vec4 c=Sposition-p.xyxy\n ;add_field(vec2(length(c.xy),length(c.zw))-r);}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r\n){s*=.5\n ;r=min(r, min(s.x, s.y))\n ;o+=s\n ;s-=r\n ;vec4 d=abs(o.xyxy-Sposition)-s.xyxy\n ;vec4 dmin=min(d,0.)\n ;vec2 df=max(dmin.xz, dmin.yw)+length2(max(d,0.))\n ;add_field(df-r);}\nvoid rounded_rectangle(float ox,float oy,float sx,float sy,float r\n){rounded_rectangle(vec2(ox,oy),vec2(sx,sy),r);}\nvoid rounded_rectangle(float x,float y,float sx,float sy\n){rounded_rectangle(vec2(x,y),vec2(sx,sy),0.);}\n\nfloat det(vec2 a, vec2 b){return a.x*b.y-b.x*a.y;}\nmat3 mat2x3_invert(mat3 s\n){float d=det(s[0].xy,s[1].xy)\n ;d=(d!=0.)?(1./d):d\n ;return mat3(s[1].y*d,-s[0].y*d,0,-s[1].x*d,s[0].x*d,0\n ,det(s[1].xy,s[2].xy)*d,det(s[2].xy,s[0].xy)*d,1.);}\nvoid transform(mat3 mtx\n){mtx=mat2x3_invert(mtx)\n ;Sposition.xy=(mtx*vec3(Sposition.xy,1.)).xy\n ;Sposition.zw=(mtx*vec3(Sposition.zw,1.)).xy\n ;Sscale *= vec2(length(mtx[0].xy), length(mtx[1].xy));}\nvoid scale(float s){transform(mat3(s,0,0,0,s,0,0,0,1));}\n\nvec2 stroke_shape(){return abs(Sshape)-Sline_width/Sscale;}\n\nbool is_solid(vec4 range){return range[1]<=range[2];}\nbool has_surface(vec4 range){return range[0] != infinity;}\nbool in_range(float x, vec2 r){return x>=r[0]&&x<r[1];}\n\nvoid write_color(vec4 rgba, float w\n){float src_a=w*rgba.a\n ;float dst_a=Spremultiply?w:src_a\n ;_color=_color*(1.0-src_a)+rgba.rgb*dst_a;}\n\nfloat calc_aa_blur(float w\n){vec2 blur=Sblur\n ;w-=blur.x\n ;return sat(-w*AA*min(1.,Sscale.x/Sscale.y))*sat(-w/blur.x+blur.y);}\n\nvoid line_to(vec2 p\n){vec4 pa=Sposition-Slast_pt.xyxy\n ;vec2 ba=p-Slast_pt\n ;vec2 h=sat(dot2(pa, ba)/dot(ba,ba))\n ;vec2 s=sign(pa.xz*ba.y-pa.yw*ba.x)\n ;vec2 d=length2(pa-ba.xyxy*h.xxyy)\n ;add_field(d)\n ;Sclip=max(Sclip,d*s/Sscale)\n ;Shas_clip=true;\n ;Slast_pt=p;}\n\nvoid shadow(\n){float z=infinity\n ;float z_local=infinity\n ;int last_product=0\n ;int last_start_offset=0\n #ifdef PERSPECTIVE\n  ;vec2 ro=vec2(0)\n  ;vec2 rd=vec2(Sposition.xy)\n #else\n  ;vec2 ro=vec2(0,Sposition.y)\n  ;vec2 rd=vec2(1,0)\n #endif\n ;for(int i=0;i<NUM_CSG_OPS;++i\n ){CSG_OP op=csg_ops[i]\n  ;if (op.product != last_product\n  ){last_product=op.product\n   ;z=min(z, z_local)\n   ;z_local=infinity\n   ;last_start_offset=i;}\n  ;if(!keep[i])continue\n  ;int brush=abs(op.brush)\n  ;vec2 d=iCircle(ro,rd,brushes[brush])\n  ;if(d[0]!=infinity\n  ){float q=(op.brush<0)?d[1]:d[0]\n   ;for(int k=last_start_offset;k<NUM_CSG_OPS;++k\n   ){CSG_OP rhs_op=csg_ops[k]\n    ;if(rhs_op.product!=op.product)break\n    ;if((!keep[k]&&!clip[k])||(k==i))continue\n    ;int rhs_brush=abs(rhs_op.brush)\n    ;vec2 rhs_d=iCircle(ro, rd, brushes[rhs_brush])\n    ;if(rhs_op.brush<0\n    ){if (q>=rhs_d[0]&&q<=rhs_d[1])q=infinity;\n     }else {if(q<=rhs_d[0]||q>=rhs_d[1])q=infinity;}}\n    ;z_local=min(z_local,q);}}    \n ;z=min(z,z_local)\n ;add_field(vec2(z-Sposition.x))\n ;Ssource=hsl(0.,1.,.5,.3)\n ;write_color(Ssource, calc_aa_blur(Sshape.x))\n ;if (Shas_clip)write_color(Ssource, calc_aa_blur(Sclip.x))\n ;Sshape=vec2(DEFAULT_SHAPE_V)\n ;Sclip=vec2(DEFAULT_CLIP_V)\n ;Shas_clip=false;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){aspect=vec2(iResolution.x/iResolution.y,1)\n ;ScreenH=min(iResolution.x,iResolution.y)\n ;AA=ScreenH*.4\n ;AAINV=1./AA\n ;uv=fragCoord.xy/iResolution.xy\n ;vec2 m=iMouse.xy/iResolution.xy\n ;position=(uv*2.-1.)*aspect\n ;query_position=(m*2.-1.)*aspect\n ;Sposition=vec4(position, query_position)\n ;Sshape=vec2(DEFAULT_SHAPE_V)\n ;Sclip=vec2(DEFAULT_CLIP_V)\n ;Sscale=vec2(1)\n ;Spremultiply=false\n ;Sblur=vec2(0,1)\n ;Ssource=vec4(0,0,0,1)\n ;Sstart_pt=vec2(0)\n ;Slast_pt=vec2(0)\n ;Ssource_blend=Replace\n ;Shas_clip=false\n ;float rdot=AAINV\n ;scale(3.)\n ;transform(mat3(1,0,0,0,1,0,-.5,0,1))\n ;float frustum_offset=0.\n ;float frustum_half_width=0.04 //0.025\n ;if(iMouse.z>.5\n ){frustum_offset=Sposition.w\n  ;frustum_half_width=.001*pow(100.0,Sposition.z);}\n  #ifdef PERSPECTIVE\n   ;ray_origin0=ray_origin1=vec2(0)\n   ;ray_dir0=vec2(1,-frustum_half_width+frustum_offset)\n   ;ray_dir1=vec2(1, frustum_half_width+frustum_offset)\n  #else\n   ;ray_origin0=vec2(0,-frustum_half_width+frustum_offset)\n   ;ray_origin1=vec2(0, frustum_half_width+frustum_offset)\n   ;ray_dir0=vec2(1,0)\n   ;ray_dir1=vec2(1,0)\n  #endif\n   ;float t=iTime\n   ;brushes[0]=vec3(.3,0,.1)\n   ;brushes[1]=vec3(mix(.25,.35,sin(t*.7)*.5+.5),.26,.29)\n   ;brushes[6]=vec3(.3,mix(.0,.1,sin(t*.6)*.5+.5),.12)\n   ;vec2 c=vec2(.8,.03)\n   ;float r0=.08,r1=.09\n   ;float a0=t,a1=a0+radians(90.)\n   ;brushes[2]=vec3(c.x+cos(a0)*r0,c.y+sin(a0)*r0,.1)\n   ;brushes[3]=vec3(c.x-cos(a0)*r0,c.y-sin(a0)*r0,.1)\n   ;brushes[4]=vec3(c.x+cos(a1)*r1,c.y+sin(a1)*r1,.1)\n   ;brushes[5]=vec3(c.x-cos(a1)*r1,c.y-sin(a1)*r1,.1)\n   ;int product=1,idx=0\n   #define CSG_FACTOR(X) csg_ops[idx++]=CSG_OP(X, product)\n   ;product++\n   ;CSG_FACTOR(2)\n   ;CSG_FACTOR(3)\n   ;CSG_FACTOR(4)\n   ;CSG_FACTOR(5)\n   ;product++\n   ;CSG_FACTOR(0)\n   ;CSG_FACTOR(-1)\n   ;CSG_FACTOR(-6)\n   ;for(int i=0;i<NUM_BRUSHES;++i\n   ){vec4 c=vec4(iCircle(ray_origin0,ray_dir0,brushes[i])\n               ,iCircle(ray_origin1,ray_dir1,brushes[i])) \n   ;c=vec4(min(c.x,c.z),max(c.y,c.w),max(c.x,c.z),min(c.y,c.w))\n   ;if (c.x>c.y)c.xy=vec2(infinity,-infinity)\n   ;if (c.z>c.w)c.zw=vec2(infinity,-infinity)\n   ;vec2 p0=brushes[i].xy-vec2(brushes[i].z,0.)\n   ;vec2 p1=brushes[i].xy+vec2(brushes[i].z,0.)\n   ;vec3 pl0=vec3(normalize(vec2( ray_dir0.y,-ray_dir0.x)),0.)\n   ;vec3 pl1=vec3(normalize(vec2(-ray_dir1.y, ray_dir1.x)),0.)\n   ;pl0.z=-dot(pl0.xy,ray_origin0)\n   ;pl1.z=-dot(pl1.xy,ray_origin1)\n   ;if((dot(vec3(p0,1.),pl0)<0.)&&(dot(vec3(p0,1.),pl1)<0.))c.x=min(c.x,p0.x)\n   ;if((dot(vec3(p1,1.),pl0)<0.)&&(dot(vec3(p1,1.),pl1)<0.))c.y=max(c.y,p1.x)\n   ;brush_intervals[i]=vec4(c.x, min(c.z, c.y),max(c.w,c.x),c.y);}\n   ;Sline_width=mus()*AAINV\n   ;vec2 p=Sposition.xy\n   ;{float z=infinity\n    ;float d=infinity\n    ;int last_product=0\n    ;for (int i=0;i<NUM_CSG_OPS;++i\n    ){CSG_OP op=csg_ops[i]\n     ;if (op.product != last_product\n     ){last_product=op.product\n      ;z=min(z,d)\n      ;d=-infinity;}         \n     ;int brush=op.brush;\n     ;float c=dCircle(p, brushes[abs(brush)])\n     ;d=max(d,(brush<0)?-c:c);}    \n    ;z=min(z,d)\n    ;add_field(vec2(z));}\n   ;Ssource=vec4(hsl(.6,.7,.95),1)\n   ;write_color(Ssource, calc_aa_blur(Sshape.x))\n   ;if(Shas_clip)write_color(Ssource,calc_aa_blur(Sclip.x))\n   ;Ssource=vec4(hsl(.6,.2,.5),1)\n   ;write_color(Ssource, calc_aa_blur(stroke_shape().x))\n   ;Sshape=vec2(DEFAULT_SHAPE_V)\n   ;Sclip=vec2(DEFAULT_CLIP_V)\n   ;Shas_clip=false\n   ;// paint brushes\n   ;Ssource=hsl(.6,.2,.5,.3)\n   ;for (int i=0;i<NUM_BRUSHES;++i\n   ){vec3 brush=brushes[i]\n    ;circle(brush.xy, brush.z)\n    ;write_color(Ssource,calc_aa_blur(stroke_shape().x))\n   ;Sshape=vec2(DEFAULT_SHAPE_V)\n    ;Sclip=vec2(DEFAULT_CLIP_V)\n    ;Shas_clip=false;}\n   ;Ssource=vec4(0,0,0,.2)\n   ;move_to(vec2(0,ray_origin0.y))\n   ;line_to(vec2(0,ray_origin1.y))\n   ;write_color(Ssource, calc_aa_blur(stroke_shape().x))\n   ;Sshape=vec2(DEFAULT_SHAPE_V)\n   ;Sclip=vec2(DEFAULT_CLIP_V)\n   ;Shas_clip=false;\n   ;for (int i=0;i<2;++i\n   ){vec2 ro=(i==0)?ray_origin0:ray_origin1\n    ;vec2 rd=(i==0)?ray_dir0:ray_dir1\n    ;// paint ray    \n    ;Ssource=vec4(0,0,0,.2)\n    ;move_to(ro)\n    ;line_to(ro+rd)\n    ;write_color(Ssource, calc_aa_blur(stroke_shape().x))\n    ;Sshape=vec2(DEFAULT_SHAPE_V)\n    ;Sclip=vec2(DEFAULT_CLIP_V)\n    ;Shas_clip=false\n    ;Ssource=vec4(0,0,0,1)\n    ;circle(ro,rdot)\n    ;write_color(Ssource,calc_aa_blur(Sshape.x))\n    ;if(Shas_clip)write_color(Ssource,calc_aa_blur(Sclip.x))\n    ;Sshape=vec2(DEFAULT_SHAPE_V)\n    ;Sclip=vec2(DEFAULT_CLIP_V)\n    ;Shas_clip=false\n    ;vec2 u=normalize(rd)\n    ;vec2 v=normalize(vec2(-rd.y,rd.x))\n    ;move_to(ro+rd+v*rdot)\n    ;line_to(ro+rd+v*-rdot)\n    ;line_to(ro+rd+u*rdot*3.)\n    ;line_to(Sstart_pt)\n    ;write_color(Ssource, calc_aa_blur(Sshape.x))\n    ;if(Shas_clip)write_color(Ssource, calc_aa_blur(Sclip.x))\n    ;Sshape=vec2(DEFAULT_SHAPE_V)\n    ;Sclip=vec2(DEFAULT_CLIP_V)\n    ;Shas_clip=false;}\n   ;if(true //(iMouse.z > 0.5){\n   ){\n    ;float y=ray_origin0.y\n    ;float h=.01\n    ;float ht=ray_origin1.y-ray_origin0.y\n    ;int num_products=0\n    ;for(int i=0;i<NUM_CSG_OPS;++i\n    ){CSG_OP op=csg_ops[i]\n     ;num_products=max(op.product-1, num_products);}\n    ;float maxz=infinity\n    ;int maxz_op=-1\n    ;for (int i=0;i<NUM_CSG_OPS;++i\n    ){CSG_OP op=csg_ops[i]\n     ;float hue=float(op.product)/float(num_products)\n     ;int brush=abs(op.brush)\n     ;y=ray_origin0.y+ht+h*float(NUM_CSG_OPS-i-1)\n     ;vec4 range=brush_intervals[brush]\n     ;bool is_surf=false\n     ;bool is_clip=false\n     ;bool is_occluder=false\n     ;vec4 r=(op.brush<0)?range.zwxy:range\n     ;if(has_surface(range)\n     ){is_occluder=(op.brush<0)||is_solid(range)\n      ;vec4 cliprange=range\n      ;for(int k=0;k<NUM_CSG_OPS;++k\n      ){CSG_OP rhs=csg_ops[k]\n       ;if((i==k)||(op.product!=rhs.product)) continue\n       ;vec4 rhs_range=brush_intervals[abs(rhs.brush)]\n       ;vec4 rhs_r=(rhs.brush<0)?rhs_range.zwxy:rhs_range\n       ;if (rhs.brush<0\n       ){if(has_surface(rhs_range)&&(r[1]>= rhs_range[0])&&(r[1]<=rhs_range[3]))is_occluder=false;\n        }else if(!has_surface(rhs_range)||!is_solid(rhs_range)\n                  ||r[1]<=rhs_range[1]||r[1]>=rhs_range[2])is_occluder=false\n      ;if (rhs.brush<0\n      ){if(has_surface(rhs_range)&&is_solid(rhs_range)\n       ){if(in_range(cliprange[0],rhs_range.yz))cliprange[0]=max(cliprange[0],rhs_range[2])\n        ;if(in_range(cliprange[1],rhs_range.yz))cliprange[1]=min(cliprange[1],rhs_range[1])\n        ;if(in_range(cliprange[2],rhs_range.yz))cliprange[2]=max(cliprange[2],rhs_range[2])\n        ;if(in_range(cliprange[3],rhs_range.yz))cliprange[3]=min(cliprange[3],rhs_range[1])\n     ;}}else{\n      ;cliprange[0]=max(cliprange[0],rhs_range[0])\n      ;cliprange[1]=min(cliprange[1],rhs_range[3])\n      ;cliprange[2]=max(cliprange[2],rhs_range[0])\n      ;cliprange[3]=min(cliprange[3],rhs_range[3])\n    ;}}\n    ;if(cliprange[0]<=cliprange[1]){is_clip=true;if(op.brush >= 0){is_surf=true;}}\n    ;if(cliprange[2]<=cliprange[3]){is_clip=true;if (op.brush<0){is_surf=true;}}               \n   ;}\n   ;float z=(is_surf&&is_occluder)?((op.brush<0)?range[3]:range[1]):infinity\n   ;if(z<maxz){maxz=z;maxz_op=i;}\n   ;rounded_rectangle(range[0], y, range[3]-range[0], h)\n   ;Ssource=hsl(hue,1.,.5,.1)\n   ;write_color(Ssource, calc_aa_blur(Sshape.x))\n   ;if(Shas_clip)write_color(Ssource, calc_aa_blur(Sclip.x))\n   ;Sshape=vec2(DEFAULT_SHAPE_V)\n   ;Sclip=vec2(DEFAULT_CLIP_V)\n   ;Shas_clip=false\n   ;rounded_rectangle(range[0],y,range[1]-range[0],h)\n   ;rounded_rectangle(range[2],y,range[3]-range[2],h)\n   ;Ssource=hsl(hue,1.,.5,.3)\n   ;write_color(Ssource, calc_aa_blur(Sshape.x))\n   ;if(Shas_clip)write_color(Ssource, calc_aa_blur(Sclip.x))\n   ;Sshape=vec2(DEFAULT_SHAPE_V)\n   ;Sclip=vec2(DEFAULT_CLIP_V)\n   ;Shas_clip=false\n   ;Ssource=vec4(0,0,0,1)\n   ;Sline_width=mus()*AAINV*2.\n   ;clip[i]=is_surf||is_clip\n   ;keep[i]=is_surf\n   ;if(is_surf&&(op.brush>=0)\n   ){move_to(vec2(range[0],y))\n    ;line_to(vec2(range[0],y+h))\n    ;write_color(Ssource, calc_aa_blur(stroke_shape().x))\n    ;Sshape=vec2(DEFAULT_SHAPE_V)\n    ;Sclip=vec2(DEFAULT_CLIP_V)\n    ;Shas_clip=false;}\n   ;if(is_surf&&(op.brush<0) \n   ){move_to(vec2(range[3],y))\n    ;line_to(vec2(range[3],y+h))\n    ;write_color(Ssource, calc_aa_blur(stroke_shape().x))\n    ;Sshape=vec2(DEFAULT_SHAPE_V)\n    ;Sclip=vec2(DEFAULT_CLIP_V)\n    ;Shas_clip=false;}\n   ;Ssource=vec4(0,0,0,.5)\n   ;Sline_width=mus()*AAINV*1.3\n   ;if (is_clip&&(op.brush<0)\n   ){move_to(vec2(range[0],y))\n    ;line_to(vec2(range[0],y+h))\n    ;write_color(Ssource, calc_aa_blur(stroke_shape().x))\n    ;Sshape=vec2(DEFAULT_SHAPE_V)\n    ;Sclip=vec2(DEFAULT_CLIP_V)\n    ;Shas_clip=false;}\n   ;if(is_clip&&(op.brush >= 0)\n   ){move_to(vec2(range[3],y))\n    ;line_to(vec2(range[3],y+h))\n    ;write_color(Ssource,calc_aa_blur(stroke_shape().x))\n    ;Sshape=vec2(DEFAULT_SHAPE_V)\n    ;Sclip=vec2(DEFAULT_CLIP_V)\n    ;Shas_clip=false;}\n   ;Sline_width=mus()*AAINV\n   ;rounded_rectangle(r[0],y,r[1]-r[0],h)\n   ;Ssource=vec4(hsl(hue,1., .3),1)\n   ;write_color(Ssource, calc_aa_blur(stroke_shape().x))\n   ;Sshape=vec2(DEFAULT_SHAPE_V)\n   ;Sclip=vec2(DEFAULT_CLIP_V)\n   ;Shas_clip=false;}\n  ;Ssource=vec4(0,0,0,.5)\n  ;Sline_width=mus()*AAINV\n  ;move_to(vec2(maxz,-1))\n  ;line_to(vec2(maxz,1))\n  ;write_color(Ssource, calc_aa_blur(stroke_shape().x))\n  ;Sshape=vec2(DEFAULT_SHAPE_V)\n  ;Sclip=vec2(DEFAULT_CLIP_V)\n  ;Shas_clip=false\n  ;shadow()\n ;}\n ;fragColor=vec4(_color,1.);}\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}