{
    "Shader": {
        "info": {
            "date": "1682971782",
            "description": "Birds drawn using SDFs",
            "flags": 0,
            "hasliked": 0,
            "id": "dl33R2",
            "likes": 3,
            "name": "Cute Birds",
            "published": 3,
            "tags": [
                "2d",
                "cute",
                "sdf",
                "bird"
            ],
            "usePreview": 0,
            "username": "aeveis",
            "viewed": 155
        },
        "renderpass": [
            {
                "code": "// View Options\n#define BIRD_AMOUNT    3.0\n#define BIRD_SCALE     0.35\n#define SCROLL_SPEED   0.2\n#define FLOOR_SCROLL   false\n#define SEED           124\n#define SATURATION     0.85\n\n// SDF Options\n#define LINE_SOFTNESS  0.005\n#define LINE_THICKNESS 0.015\n\n// Base Colors\n#define BG_COLOR       vec3(0.459, 0.878, 0.808)\n#define GLOW_COLOR     vec3(1.000, 1.000, 1.000)\n#define OUTLINE_COLOR  vec3(0.132, 0.045, 0.016)\n#define BIRD0_COLOR    vec3(0.84, 0.48, 0.53)\n#define BIRD1_COLOR    vec3(0.19, 0.95, 0.85)\n#define BIRD2_COLOR    vec3(0.91, 0.85, 0.47)\n#define EYEBASE_COLOR  vec3(0.934, 0.882, 0.753)\n#define EYE_COLOR      vec3(0.830, 0.618, 0.074)\n\n// Bird Variation\nfloat _HeadRoundness;\nfloat _BodyVariation;\nfloat _TailVariation;\n    \n// Noise https://blog.demofox.org/2022/01/01/interleaved-gradient-noise-a-different-kind-of-low-discrepancy-sequence/\nfloat IGN(int pixelX, int pixelY)\n{\n    return mod(52.9829189f * mod(0.06711056*float(pixelX) + 0.00583715*float(pixelY), 1.0), 1.0);\n}\n\n// https://www.shadertoy.com/view/WttXWX\nfloat Hash(float f)\n{\n    uint x = uint(f)+uint(SEED);\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return float(x) / float( 0xffffffffU );\n}\n\n// HSV conversion https://www.shadertoy.com/view/XljGzV\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n// Rotation\nvec2 Rotate2D(float angle, vec2 original)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return original * mat2(c, -s, s, c);\n}\n\n// SDF https://iquilezles.org/articles/distfunctions2d/\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n// Bird Drawing\nfloat SDFOval(vec2 uv, float r, float angle)\n{\n    float sdf = sdEllipse(Rotate2D(angle, uv), vec2(r*(1.7 + 0.2 * _BodyVariation),r));\n    return sdf;\n}\n\nfloat SDFLine(vec2 uv, float l, float angle)\n{\n    float sdf = sdBox(Rotate2D(angle, uv), vec2(l,0.018));\n    return sdf;\n}\n\nfloat SDFFlatTriangle(vec2 uv, float l, float angle)\n{\n    float sdf = sdUnevenCapsule(Rotate2D(angle, uv), 0.015, 0.01, l);\n    return sdf;\n}\n\nfloat SDFFoot(vec2 uv)\n{\n    uv.y += 0.03 + 0.01 * _BodyVariation;\n    uv.x += 0.02 * _BodyVariation;\n    float toeAdd = 0.01 * _BodyVariation;\n    float legsdf = SDFLine(vec2((uv.x - 0.055), (uv.y+0.28)), 0.12, -0.8);\n    float footl1sdf = SDFFlatTriangle(vec2((uv.x+0.02), (uv.y+0.365)), 0.12 + toeAdd, 4.6);\n    float footl2sdf = SDFFlatTriangle(vec2((uv.x+0.01), (uv.y+0.365)), 0.1 + toeAdd, 4.33);\n    float footl3sdf = SDFFlatTriangle(vec2((uv.x+0.02), (uv.y+0.36)), 0.1 + toeAdd, 4.8);\n    float footl4sdf = SDFFlatTriangle(vec2((uv.x+0.025), (uv.y+0.365)), 0.08 + toeAdd, 1.57);\n    float sdf = min(legsdf, footl1sdf);\n    sdf = min(sdf, footl2sdf);\n    sdf = min(sdf, footl3sdf);\n    sdf = min(sdf, footl4sdf);\n    return sdf;\n}\n                \nfloat SDFHead(vec2 uv, float r, float angle)\n{\n    float roundsdf = sdEllipse(Rotate2D(angle, uv), vec2(r*(1.8 + 0.2 * _BodyVariation),r));\n    uv.x -= 0.03 + 0.05*(1.0 - _HeadRoundness);\n    float sharpersdf = sdUnevenCapsule(Rotate2D(angle - 1.6, uv), \n                        0.17, \n                        0.03 + 0.05 * _HeadRoundness, \n                        r*(1.9 + 0.2 * _BodyVariation) + 0.05 * (1.0 - _HeadRoundness));\n    uv.x += 0.04;\n    uv.y -= 0.05;\n    float sdf = mix(sharpersdf, sdCircle(uv, 0.22), 0.15);\n    sdf = mix(sdf, roundsdf, _HeadRoundness);\n    return sdf;\n}\n\nvoid SDFEye(vec2 uv, vec3 eyecolor, inout vec3 col)\n{\n    float eyeadj = 0.01 * (1.0 - _HeadRoundness);\n    uv.x += 0.15 + 0.02 * _BodyVariation;\n    uv.y -= 0.14;\n    float sdf = sdEllipse(uv, vec2(0.1 - eyeadj,0.12- eyeadj));\n    float eyeoutlineblend = smoothstep(0.0,LINE_SOFTNESS * 3.5, -sdf);\n    float eyeblend = smoothstep(0.0,LINE_SOFTNESS * 3.5, -(sdf + LINE_THICKNESS));\n\n    uv.x += 0.03;\n    float pupilsdf = sdEllipse(uv, vec2(0.065- eyeadj,0.09- eyeadj));\n    float pupiloutlineblend = smoothstep(0.0,LINE_SOFTNESS, -pupilsdf);\n    float pupilblend = smoothstep(0.0, LINE_SOFTNESS * 3.5, -sdEllipse(uv, vec2(0.028- eyeadj/2.0,0.05- eyeadj)));\n\n    col = mix(col, OUTLINE_COLOR.rgb, eyeoutlineblend);\n    col = mix(col, EYEBASE_COLOR.rgb, eyeblend);\n    col = mix(col, OUTLINE_COLOR.rgb, pupiloutlineblend);\n    col = mix(col, eyecolor, pupilblend);\n    uv -= 0.05 - 0.01 * (1.0 - _HeadRoundness);\n    col = mix(col, GLOW_COLOR.rgb, smoothstep(0.0, LINE_SOFTNESS * 3.5, -sdCircle(uv, 0.022)));\n}\n                \nvoid SDFBird(vec2 uv, float cell, inout vec3 col)\n{\n    // Random bird variations\n    _HeadRoundness = Hash(cell * 78523.0);\n    _BodyVariation = (Hash(cell * 34443.0) - 0.5) * 2.0;\n    _TailVariation = (Hash(cell * 43523.0) - 0.5) * 2.0;\n    \n    // Select Color and add variation\n    float colorChoice = mod(floor(Hash(cell * 12516.0) * 3.0),3.0);\n    vec3 birdColor = float(colorChoice == 0.0) * BIRD0_COLOR + float(colorChoice == 1.0) * BIRD1_COLOR + float(colorChoice == 2.0) * BIRD2_COLOR;\n    vec3 eyecolor = EYE_COLOR;\n\n    birdColor = rgb2hsv(birdColor);\n    birdColor.x += mix(-0.1, 0.1, Hash(cell * 1837.0));\n    birdColor.y += mix(-0.07, 0.0, Hash(cell * 8547.0));\n    birdColor.z += mix(-0.1, 0.05, Hash(cell * 2253.0));\n    birdColor = hsv2rgb(birdColor);\n    \n    eyecolor = rgb2hsv(eyecolor);\n    eyecolor.x += mix(-0.05, 0.2, Hash(cell * 3242.0));\n    eyecolor.y += mix(-0.3, 0.0, Hash(cell * 5643.0));\n    eyecolor.z += mix(0.0, 0.3, Hash(cell * 7545.0));\n    eyecolor = hsv2rgb(eyecolor);\n\n    // Random Flip\n    float flip = float(!FLOOR_SCROLL) * Hash(cell * 15632.0) + float(FLOOR_SCROLL);\n    uv.x = float(flip>0.5)*-uv.x + float(flip<0.5)*uv.x;\n\n    // Tweaks for placement\n    float scale = 1.35 + 2.0 * (1.0 - BIRD_SCALE);\n    uv *= scale;\n    uv.x += 0.11;\n    uv.y -= 0.1;\n    \n    // Draw Legs\n    float leg1sdf = SDFFoot(uv);\n    float leg2sdf = SDFFoot(vec2(uv.x - 0.08, uv.y + 0.05));\n    float legsdf = min(leg2sdf, leg1sdf);\n\n    // Random Rotation of main body\n    uv = Rotate2D(mix(-0.18, 0.1, Hash(cell * 898.0)), uv);\n    \n    // Draw Head, Body, Wing, and Tail\n    float headsdf = SDFHead(vec2(uv.x+0.18, uv.y-0.12), 0.16, -0.1);\n    float bodysdf = SDFOval(vec2(uv.x-0.13- 0.03 * _BodyVariation, uv.y+0.1), 0.2, 0.1 - 0.05 * _BodyVariation);\n    float rwingsdf = SDFOval(vec2(uv.x-0.25, uv.y+0.09), 0.2, 0.23);\n    float tailsdf = SDFOval(vec2(uv.x-0.45 - 0.05 * _TailVariation, uv.y+0.12- 0.02 * _TailVariation), 0.2, 1.0 + 0.5 * _TailVariation);\n    float rbacksdf = SDFOval(vec2((uv.x-0.56), (uv.y-0.45)), 0.6, 0.9);\n    float sdf = min(headsdf, bodysdf);\n    sdf = min(sdf, tailsdf);\n    sdf = max(sdf, -rwingsdf);\n    sdf = min(sdf, rwingsdf + LINE_THICKNESS - LINE_THICKNESS * mix(0.0, 0.5, LINE_SOFTNESS * 200.0));\n    sdf = max(sdf, -rbacksdf);\n    \n    // Scale adjustment to renormalize scale from tweaks\n    sdf /= scale;\n\n    // Get blend values for coloring\n    float birdbodyblend = smoothstep(0.0,LINE_SOFTNESS, -sdf);\n    float outlineblend = smoothstep(0.0,LINE_SOFTNESS, -(sdf - LINE_THICKNESS));\n    sdf = min(sdf- LINE_THICKNESS, legsdf);\n    float glowlineblend = smoothstep(0.0,LINE_SOFTNESS, -(sdf - LINE_THICKNESS));\n    float legblend = smoothstep(0.0,LINE_SOFTNESS * 2.0, -legsdf);\n\n    // Draw Mouth \n    float mouthsdf = SDFFlatTriangle(\n                        vec2((uv.x+0.34 + 0.03 * _BodyVariation + 0.08 * (1.1 - _HeadRoundness)), \n                        (uv.y+0.015 - 0.06 * (1.0 - _HeadRoundness))), \n                        0.06 + 0.04 * (1.0 - _HeadRoundness), \n                        0.6 + 0.65 * (1.0 - _HeadRoundness));\n    float mouthblend = smoothstep(0.0,LINE_SOFTNESS, -mouthsdf);\n\n    // Draw Beak \n    float beaksdf = sdEllipse(Rotate2D(-0.7,\n                        vec2(uv.x+0.52 + 0.02 * _BodyVariation+0.03 * (1.0 - _HeadRoundness), \n                              uv.y)), \n                        vec2(0.288, 0.19));\n    beaksdf = max(beaksdf, sdf + LINE_THICKNESS);\n    float beakblend = smoothstep(0.0,LINE_SOFTNESS, -beaksdf);\n    \n    // Slight shade warmer or cool depending on color\n    float shade = min(1.0, uv.y + 0.8);\n    float iscooler = float((birdColor.r - 0.3) <=birdColor.b);\n    float iswarmer = 1.0 - iscooler;\n    birdColor.rg = iscooler * mix(birdColor.rg/2.0, birdColor.rg, shade) + iswarmer * birdColor.rg;\n    birdColor.gb = iswarmer * mix(birdColor.gb/2.0, birdColor.gb, shade) + iscooler * birdColor.gb;\n\n    // Add colors\n    col = mix(col, GLOW_COLOR.rgb, glowlineblend);\n    col = mix(col, OUTLINE_COLOR.rgb, legblend);\n    col = mix(col, OUTLINE_COLOR.rgb, outlineblend);\n    col = mix(col, birdColor.rgb, birdbodyblend);\n    // Add colors for beak\n    col.rg *= beakblend * 0.65 + (1.0 - beakblend);\n    col.b *= beakblend * 0.85 + (1.0 - beakblend);\n    col = mix(col, OUTLINE_COLOR.rgb, mouthblend);\n    // Add eye wholesale\n    SDFEye(uv, eyecolor, col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x -= (iResolution.x-iResolution.y)/iResolution.y/2.0;\n\n    vec3 col = BG_COLOR;\n    \n    // 100 times different birds\n    float scale = 100.0;\n    float time = mod(iTime * SCROLL_SPEED, scale);\n    \n    time = floor(time) * float(FLOOR_SCROLL) + time * float(!FLOOR_SCROLL);\n    uv += time;\n    vec2 scaleduv = uv*scale;\n    \n    // Scale back to specified amount\n    scaleduv *= BIRD_AMOUNT/scale;\n    \n    // Offset even rows\n    float evenrow = float(mod(scaleduv.y,2.0) > 1.0);\n    scaleduv.x += evenrow * 0.5;\n    \n    // Get random value for each cell\n    float cell = IGN(int(mod(scaleduv.x,scale)),int(mod(scaleduv.y,scale)));\n    uv = (fract(scaleduv) - 0.5);\n    SDFBird(uv, cell, col);\n    \n    col = rgb2hsv(col);\n    col.y *= SATURATION;\n    col = hsv2rgb(col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}