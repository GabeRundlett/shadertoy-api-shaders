{
    "Shader": {
        "info": {
            "date": "1633193530",
            "description": "point distribution gradient, rather than pixel noise gradient as in https://shadertoy.com/view/fscSWH\nclick to see tiles.\ncompeting with 2xiterated-costasArray-noise of a 4th line",
            "flags": 0,
            "hasliked": 0,
            "id": "7stXDN",
            "likes": 3,
            "name": "costas || random point grad",
            "published": 3,
            "tags": [
                "gradient",
                "poisson",
                "poisson",
                "hash",
                "dithering",
                "bluenoise",
                "whitenoise",
                "galois",
                "pointdistribution"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 348
        },
        "renderpass": [
            {
                "code": "//i never did a gradient of a costas array.\n//may as well use this canvas.\n\n//code almost entirely from forked https://www.shadertoy.com/view/fdcXWH\n//adding a costas-line\n//costas-noise itterates 2 times over a costas array to get a cheap 2d-pseuo-costas.\n//this mixes 7 X2 costas arrqays of prime lengths: 241,239,281,269,19,17,13 \n//a costas array is pattern free (within its length==period)\n//because every difference (over every derivative down to its length) is unique.\n//not too many longer costas arrays are known (barely any longer than 1000)\n//this mises 7 shorter lists of prime lengths to use a shorter buffer.\n\n//code of forked source\n// Lagrangian variant of https://shadertoy.com/view/fscSWH\n\n#define hash(p)  fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define T(c)     texelFetch(c, ivec2(U) % textureSize(c,0).xy, 0).xy \n\nvoid mainImage( out vec4 O, vec2 u\n){\n    vec2 R = iResolution.xy, U, P = u/R, T,D,H;\n    u.x += float(iFrame);\n    T = u / 16.;\n    O-=O;\n    float d = 99.;\n    \n    if (P.y<.25){ \n    //weighted mix of 7 costas arrays of prime-periods:\n    //241,239,281,269,19,17,13 \n    //each costas array is tapped 2x recurrsively to turn a list into a 2d plane.\n    //this recursion sometimes causes a strong meta.pattern.\n    //costas arrays are chosen where that pattern is weakest for the used itteration function.\n    vec2 p = u/iResolution.xy;\n    //animated, diminished high frequencies:\n    //O.xyz=vec3(wrap(p*iResolution.y*4.,iFrame,iTime,vec4(1)));\n    //static, diminished high frequencies:\n    //O.xyz=vec3(wrap(p*iResolution.y*4.,1,1.,vec4(1.)));\n    //static, high and low frewuences equally mixed:\n    //O.xyz=vec3(wrap(p*iResolution.y*4.,1,1.,vec4(0,1,0,1)));\n    \n    //the vec4 is made for an iMouse canvas:\n    O.xyz=2.*vec3(wrap(p*iResolution.y*4.,1,1.,vec4(abs(iMouse.zw),abs(iMouse.zw))/iResolution.xyxy));\n    \n    //with animation, it  shows the high freqencies too much\n    //O.xyz=vec3(wrap(p*iResolution.y*4.,iFrame,1.,vec4(abs(iMouse.zw),abs(iMouse.zw))/iResolution.xyxy));\n    \n    \n    //O.xyz=sat(O.xyz*O.xyz);   \n    //O.xyz=sqrt(O.xyz)*sqrt(1.-P.x);     //sqrt() falloff\n    O.xyz=O.xyz*(1.-P.x);             //linear falloff\n    //O.xyz=sqrt(O.xyz)\n    \n    ;}else{ //forked source shader, unchanged, b3esides adding +1 line\n    \n    for ( float i=0.; i < 256.*(1.-P.x); i++ ){\n        U = floor(T) + i*13.7;        \n        H =   P.y > .75 ? hash(U)\n            : P.y > .50 ? T(iChannel0)\n            : P.y > .25 ? T(iChannel1)\n            :             vec2(0) ; //should really be outside the loop\n        D = fract(T) - H;\n        d = min(d, dot(D,D));\n     // O = max(O, 1.3 - 16.*sqrt(d) );\n      O += (1.-O) * clamp( 1.3 - 16.*sqrt(d) , 0.,1.);\n    }\n    //O = vec4( 1.3 - 16.*sqrt(d) );   // draw closest point\n    }\n        \n    if (fract(iTime/4.)<.5){ //alternate greyxcale monochrome over time\n    if(O.x>.5)O.xyz=vec3(1);//optionally to monochrome\n    else O=vec4(0.)\n    ;}\n \n    \n    //below like is VERY hacky to turn 3 separators into 4.\n   if ( int(u.y*4./3.-1.)*3 % int(R.y) == 0 ) O = vec4(1,0,0,1); // horizontal separator\n    u = fract((u-.5)/16.);\n    if ( iMouse.z>0. && u.x*u.y==0.) O = vec4(0,0,1,1);  // if click, draw grid\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//code copied from the shader [Costas7]*\n\n#define v0 float\n#define v2 vec3 \n#define pi acos(-1.)\n\n#define sat(a) clamp(a,0.,1.)\n#define u5(a) ((a)*.5+.5)\n#define u2(a) ((a)*2.-1.) \n#define ab012(a,b)(a+b*v2(0,1,2))  //desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nv2 rainbow(v0 a,v0 b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nv2 rainbowt(v0 a,v0 b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nv2 rainbow(v0 a){return rainbow(a,1./3.);}\nv2 rainbowt(v0 a){return rainbowt(a,1./3.);}\n\nvec3 blackbodyLike(float T){\n ;vec3 c=rainbow(((((2.-T)/pi)*pi)-.5)/2.+1./6.,1./6.)\n //;c=c/max(c.r,max(c.g,c.b))*u5(((c.g)/(c.r+c.b)))//optional norm\n ;return c;\n}\n\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Type 1 = Orbit noise (https://www.shadertoy.com/view/4t3yDn)\n//Type 2 = Bicubic noise (https://www.shadertoy.com/view/XlVcWV)\n//Type 3 = Value noise\n//Type 4 = Gradient noise (from iq : https://www.shadertoy.com/view/XdXGW8)\n//Type 5 = Simplex noise (modified from iq's to use normalized gradients as per the original paper)\n//Type 6 = FBM (base noise can be defined in buffer A)\n#define NOISE_TYPE 1\n\n//#define SCROLL_COORDS\n#define DIAGONAL_DERIVATIVES\n#define SHOW_FOURIER\n#define SIZE (floor(iResolution.y/2.5)*2.)\n\nconst float globalScale = 1.;\n\n//end of signal inspector (global parameters)\n//\n//start of costas array:\n\n/*\n//the idea, cycle multiple pallettes of multiple tiled costas arrays, each of them a prime in size.\n//and then do a weighted mix\n//the result should be a weightable noise/dither, with very large period (depending on LUT sizes)\n\n//this can come close to a VERY large animarteable 2d bluenoise, that is generated on runtime, and hashable.\n\n//currently in experimental stage.\n//the diagonal banding is a bit diasssapointing.\n//this is due to, where ever mod(x,n)=mod(y,n) for quite similar N\n//gets the same inputs for small tiles (which are stronger in blue noise)\n    \n//lets just try larger primes&tiles\n//and hope that prime-gaps being less repetitie will remove the banding.\n\n//added NAIVE detection of both diagonal mirrorings\n\n//todo, with this i am very close to ANIMATED blue noise\n\n\nmixed prime base animated bluenoise\nthe idea is, to have a number, where each digit has a different base\n, and each base is a prime\n, and the 0th digit has the largest prime (like 13) \n, and the Nth digit has the smallest prime == 3\nthis way, small primes auromatically have an exponential effect\non the generated cumulative number\n(this may not be worth its calculation though, but i will solve for it once)\n\neach prime is a tiled layer, animated with a different offset, over time, set by \na pqfm, primal quadratic field matrix.\nso that 2 space domains, and 1 dtime domain, bith have period as long as possible.\n\ni also have a bias for costasArrays (of prime-size), that are \n- diagonally mirror symmetric\n- animate NICELY, when tiled and pallette shifted.\n/**/\n\n#define arrLen 7\n    \n#define animatePaletteSpeed .9\n\n/*  //simpler idea outdated\nfloat mixArrayFloat[](int a[7],int b[7],float c,int l){\n    for(i=0;i<l;i++)\n      a[i]=mix(a[i],b[i],c);\n    }return a;}\n*/      \n\n//gpo() returns sizes of used tiles (of costas arrays in them) by index a.\n//this is also a list of used frequencies in terms of how blue your noise is.\n//values share no prime factors to maximize the permuted period\nint gpo(int a){int b[arrLen]=int[7](241,239,281,269,19,17,13);return b[a];}\n\n//costas arrays of tile sizes\nint getCostasOf(int a,int p){//return costas at Position of Array#\n bool r=false;\n if(a<4){\n  if(a<2){\n   if(a==0){\n          int c[]=int[241](1,38,3,156,46,114,231,141,9,155,15,226,55,39,138,205,60,100,161,203,209,186,160,181,66,8,27,71,233,223,170,169,45,25,184,194,78,173,165,196,120,117,102,57,172,69,159,131,76,108,180,236,145,58,163,157,241,73,179,125,127,214,143,225,175,74,28,140,238,166,201,59,204,232,198,124,49,24,6,17,81,52,77,213,99,149,215,62,22,185,218,89,26,146,34,23,106,240,135,105,123,75,90,136,68,122,2,98,33,182,234,210,116,35,30,202,11,70,10,104,121,37,118,111,227,109,112,50,64,91,48,171,197,195,32,85,206,207,94,12,235,150,113,151,192,42,228,31,86,82,144,44,56,29,115,224,107,154,193,101,63,174,96,47,5,13,20,229,134,164,239,137,142,219,40,19,53,36,129,133,221,152,139,208,67,158,97,167,187,211,88,191,92,80,41,126,162,222,200,148,84,93,237,178,16,65,230,4,199,14,190,176,119,132,21,177,168,216,128,87,43,212,103,217,110,188,54,130,79,183,147,220,7,72,95,153,18,61,83,51,189\t);if(r)return c[(241-p)%241];return c[p%241];\t//\t76\t\tgood very\n       ;}else{\n      int c[]=int[239](4,151,89,144,236,156,6,229,193,21,65,56,227,101,226,28,201,105,207,154,125,17,185,167,7,100,11,96,106,163,121,122,135,130,64,18,221,90,198,40,73,199,37,212,83,149,141,19,98,146,202,132,107,23,60,172,42,208,225,215,219,119,131,171,168,214,45,150,170,230,138,145,234,61,134,33,210,186,159,213,237,161,27,43,51,114,142,81,239,22,41,224,129,118,194,116,197,157,5,26,232,231,216,110,162,189,36,3,53,203,191,47,72,86,180,209,160,55,178,10,147,233,67,85,25,140,95,39,152,133,192,111,113,235,177,94,169,153,123,126,74,195,204,92,139,32,12,76,102,52,238,49,79,20,166,127,80,183,228,173,88,84,77,109,179,75,217,97,59,120,29,218,82,220,143,115,44,1,70,35,14,206,9,108,205,137,190,184,223,136,57,187,38,15,158,16,50,181,24,200,87,188,48,54,69,104,78,34,2,13,165,124,8,66,182,71,58,99,176,174,196,63,128,164,91,175,30,68,46,211,112,117,103,222,31,148,62,93,155\t);if(r)return c[(239-p)%239];return c[p%239];\t//\t47\t\tgood very\n  ;}}else{\n   if(a==2){\n           int c[]=int[281](108,277,20,24,177,157,241,58,204,270,106,59,30,265,127,84,208,140,86,143,130,128,193,203,161,111,38,5,87,252,125,149,218,98,36,70,97,210,75,76,185,180,201,226,121,279,238,14,219,207,31,91,122,105,233,35,244,102,189,50,181,27,221,142,21,133,172,178,266,236,79,229,165,264,18,89,187,115,191,268,171,69,271,215,54,51,7,22,242,167,199,8,131,237,188,224,186,6,196,247,146,174,113,256,278,129,19,198,182,136,216,163,46,28,47,137,42,158,67,53,225,12,1,217,272,41,49,72,32,200,117,126,258,213,119,61,248,255,169,134,281,173,4,261,257,104,124,40,223,77,11,175,222,251,16,154,197,73,141,195,138,151,153,88,78,120,170,243,276,194,29,156,132,63,183,245,211,184,71,206,205,96,101,80,55,160,2,43,267,62,74,250,190,159,176,48,246,37,179,92,231,100,254,60,139,260,148,109,103,15,45,202,52,116,17,263,192,94,166,90,13,110,212,10,66,227,230,274,259,39,114,82,273,150,44,93,57,95,275,85,34,135,107,168,25,3,152,262,83,99,145,65,118,235,253,234,144,239,123,214,228,56,269,280,64,9,240,232,209,249,81,164,155,23,68,162,220,33,26,112,147\t);if(r)return c[(281-p)%281];return c[p%281];\t//\t1121\te\tgood, very good\n           ;}else{\n          int c[]=int[269](77,170,158,48,161,199,10,258,227,75,209,203,165,187,151,11,207,94,79,110,175,255,248,3,98,17,109,67,12,253,40,27,212,154,193,141,223,167,168,159,69,18,192,174,225,127,190,237,123,264,13,80,202,90,222,172,246,83,82,143,213,72,140,112,107,121,208,39,247,37,198,33,183,21,244,53,96,131,144,14,134,15,1,118,245,243,197,130,201,108,8,200,76,19,25,230,250,259,180,229,97,218,221,265,220,228,89,62,241,171,66,78,215,236,269,135,191,188,84,267,142,211,256,59,145,74,57,38,232,239,92,20,224,266,182,93,148,41,210,184,4,177,23,137,35,46,70,122,150,102,16,217,47,88,49,113,189,149,234,166,63,251,105,71,160,32,85,179,155,114,162,68,156,233,125,216,100,51,226,153,73,99,263,136,235,205,185,26,242,219,176,260,52,106,124,268,257,204,196,132,169,58,54,64,147,249,104,133,101,128,164,262,252,5,152,117,56,31,61,139,95,36,86,120,45,91,206,129,7,194,30,126,9,24,173,231,116,28,138,178,34,186,55,60,238,240,42,146,163,195,261,103,43,214,181,44,119,254,87,50,29,157,6,22,81,65,2,111,115\t);if(r)return c[(269-p)%269];return c[p%269];\t//\t678\t\tgood very\n ;}}}else{\n   if(a==4){int c[]=int[19](1,12,16,18,19,10,15,8,14,17,9,5,3,2,11,6,13,7,4);if(r)return c[(19-p)%19];return c[p%197];}//is too symmetrical\n   if(a==5){\n       int c[]=int[17](2,11,8,6,16,17,12,3,14,10,13,15,5,4,9,1,7);if(r)return c[(17-p)%17];return c[p%17];\t//\t11\t\tgood\n    }else {int c[]=int[13](0,6,8,4,5,9,12,2,7,1,11,10,3);if(r)return c[(13-p)%13];return c[p%13];\t//\t144\n//more best ofs (alternative arrays)\n/*\tint c[]=int[17](2,11,8,6,16,17,12,3,14,10,13,15,5,4,9,1,7);if(r)return c[(17-p)%17];return c[p%17];\t//\t11\t\tgood\n/*\tint c[]=int[11](0,4,10,7,8,2,1,9,5,3,6);if(r)return c[(11-p)%11];return c[p%11];\t//\t57\t\tgood very\n/*\tint c[]=int[13](0,6,8,4,5,9,12,2,7,1,11,10,3);if(r)return c[(13-p)%13];return c[p%13];\t//\t144\n/*\tint c[]=int[ 7](1,4,5,3,0,6,2);if(r)return c[(7-p)%7];return c[p%7];\t//\t22\t\tgood very\n/*\tint c[]=int[ 5](1,2,4,0,3);if(r)return c[(5-p)%5];return c[p%5];\t//\t4 good\n/**/\n;}}}\n\n\n//cs() does 2 iterations over getCostasOf()\n//a 1d costas array (==list) is usually shown as square of binary tiles.\n//but i need a 2d heightmap and not a 1d heightmap.\n//but a 2d costasArray (for a 2d heightmap) is useless here\n//(because it has elements that are NaN (==mod(a,0) )\n//because 3d costas arrays are MUCH trickier to calculate (and usually kept secret)\n//we instead do 2 iterations over a 1d costasArray, to get a PSEUDO-2d-costasArray\nint Cs(ivec2 u,int a,int iFrame){\n ;int r=0\n ;int per=gpo(a)\n ;u=u%per //integer modulo (tile to positive infinity)\n ;//if(max(u.x,u.y)>per-1)return 0; //only show one tile\n ;int c=getCostasOf(a,per-u.y)\n ;//if(c+1==u.x)return per;return 0;//monochrome (makes nice starfields)\n ;r=c-u.x\n ;if(r<0)r+=per\n ;r=getCostasOf(a,per-r)  //we reverse the second pass, (habbitually, there may be a better approach)\n ;//r+=getCostasOf(a,per)//optional for a better match with simpler mode \n ;//r=r%per;\n ;r=(r+iFrame/4)%(per);\n ;return r;}\n\n\n//biased mixing of multiple modulo tiles (that are set by Cs(parameter) )\nvec4 CostasNoise(ivec2 u,int iFrame,vec4 m){\n ;u/=2\n ;float r=0.;\n //last 3 entries are better set to 0, they are very small and too symmetrical costas arrays (cause diagonal bands)\n //;float f[]=float[7](1.,0.,0.,0.,0.,0.,0.)//singleton    \n ;float f[]=float[7](1.,1.,1.,1.,1.,1.,1.)//flat (strong banding)\n //;float f[]=float[7](4.,3.,2.,1.,0.,0.,0.)//valley\n;float blue[]=float[7](1.,2.,4.,8.,16.,32.,0.)//blue (most banding?)\n //;float f[]=float[7](1.,2.,2.,1.,0.,0.,0.)//windowed \n ;float yellow[]=float[7](64.,32.,16.,8.,4.,2.,0.)//anti-blue /least banding)\n     //dissappointingly, even small prime tiles as small as 19*19 salready have too stron giagonal banding\n     //so i guess, i just need larger tiles and larger primes.\n     //i take a bet that it is a bad idea to repeat prime-gaps (espoecially short ones), which may result in the banding\n ;m=clamp(m,0.,1.)\n \n ;for(int i=0;i<7;i++){\n      blue[i]=mix(blue[i],yellow[i],m.x);\n }    \n;for(int i=0;i<7;i++){\n      f[i]=mix(blue[i],f[i],m.y);//mix to flat\n }\n ;r+=float(Cs(u,0,iFrame))/float(gpo(0))*f[0];\n ;r+=float(Cs(u,2,iFrame))/float(gpo(2))*f[2];\n ;u=u.yx//addition, to make half of the arrays diagonally flipped\n ;r+=float(Cs(u,1,iFrame))/float(gpo(1))*f[1];\n ;r+=float(Cs(u,3,iFrame))/float(gpo(3))*f[3];\n //large above, small below\n ;r+=float(Cs(u,4,iFrame))/float(gpo(4))*f[4];    \n ;u=u.yx//addition, to make half of the arrays diagonally flipped\n ;r+=float(Cs(u,5,iFrame))/float(gpo(5))*f[5];\n ;r+=float(Cs(u,6,iFrame))/float(gpo(6))*f[6]; \n    \n ;float a=r/(f[0]+f[1]+f[2]+f[3]+f[4]+f[5]+f[6])//divide by sum of weights\n ;return vec4(a,a,a,1);\n}\n\n\nfloat wrap(vec2 u,int iFrame,float iTime,vec4 m){//O=getCostasOfFloat(u);\n ;if(m.z<=0.){m.y=0.;m.x=cos(iTime*.3)*.5+.5;}\n ;//u*=2.2\n ;u.x*=2.5   //note, this likely is TERRIBLE uv scaling.\n ;float g=(sqrt(5.)*.5+.5)\n ;float speed=.00003*iTime\n ;vec2 s= (vec2(cos(speed),sin(speed*g))*.5+.5)*10000000. \n     //i am pleased that this noise still has a strong pattern to make scrolling easily noticable.\n     //thile its color palette cycles.\n ;ivec2 scroll=ivec2(0);\n ;//ivec2 scroll=ivec2(s);\n ;//u.x+=u.y*(sqrt(5.)*.5+.5) //optionally skew diagonal banding by goldenRatio (sucks)\n ;//u.x+=u.y*u.y*g\n ;return CostasNoise(ivec2(u)+scroll,iFrame,m).x;}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}