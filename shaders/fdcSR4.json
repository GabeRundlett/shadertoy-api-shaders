{
    "Shader": {
        "info": {
            "date": "1632693035",
            "description": "Playing around; sines, Voronoi, triangle, kinda spheres. Also, kinda slow (:",
            "flags": 0,
            "hasliked": 0,
            "id": "fdcSR4",
            "likes": 8,
            "name": "hello_triangle",
            "published": 3,
            "tags": [
                "2d",
                "voronoi"
            ],
            "usePreview": 0,
            "username": "rytis_p",
            "viewed": 299
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n\nfloat pretty_sine(vec2 uv)\n{\n    float d = (sin(uv.x) - uv.y);\n    float d1 = 4.0 * d;\n    float d2 = 16.0 * d;\n    float sine = 0.5 * sin(uv.x + iTime);\n    float s = mix(d1, d2, sine + 0.5);\n    float result = 1.0 + 0.75 * (-sine + 0.5) - abs(s);\n    return result;\n}\n\nfloat circle(vec2 p, float r) \n{\n    float result = length(p) - r;\n    return result;\n}\n\n// NOTE(rytis): Taken from https://iquilezles.org/articles/smin\nvec2 smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*0.5;\n    float s = m*k*(1.0/2.0);\n    return (a<b) ? vec2(a-s,m) : vec2(b-s,m-1.0);\n}\n\nvec2 random2(vec2 p)\n{\n    vec2 result = fract(sin(vec2(dot(p, vec2(389.9, 441.1)),\n                                 dot(p, vec2(598.3, 290.4)))) * PI * 20000.0);\n    return result;\n}\n\nstruct Pretty_Sine_Data\n{\n    vec2 uv;\n    vec3 color;\n    float multiplier;\n};\nvec4 edge(vec2 uv, vec2 p0, vec2 p1)\n{\n    vec2 diff = p1 - p0;\n    vec2 n_diff = normalize(diff);\n    float half_diff_length = 0.5 * length(diff);\n    vec2 uv_x = vec2(1.0, 0.0);\n    vec2 uv_y = vec2(0.0, 1.0);\n    \n    float cos_a = dot(uv_x, n_diff);\n    float sin_a = dot(uv_y, n_diff);\n    vec2 p = vec2(cos_a * uv.x + sin_a * uv.y,\n                  -sin_a * uv.x + cos_a * uv.y);\n\n    vec2 offset = 0.5 * (p0 + p1);\n    vec2 xn = cos_a * uv_x + sin_a * uv_y;\n    vec2 yn = -sin_a * uv_x + cos_a * uv_y;\n    \n    vec2 new_offset = vec2(dot(offset, xn), dot(offset, yn));\n    \n    p -= new_offset;\n    \n    Pretty_Sine_Data data[8] = Pretty_Sine_Data[8](\n        Pretty_Sine_Data(      vec2(p.x + 0.22 * iTime, 2.0 * p.y),       vec3(0.5, 0.5, 2.0),  1.0),\n        Pretty_Sine_Data(      vec2(p.x + 0.13 * iTime, 1.6 * p.y),       vec3(0.3, 0.7, 1.0),  1.0),\n        Pretty_Sine_Data(2.0 * vec2(p.x + iTime, 2.0 * p.y),              vec3(0.8, 0.2, 0.6),  1.0),\n        Pretty_Sine_Data(1.3 * vec2(p.x + 0.5 * iTime, 1.7 * p.y),        vec3(0.4, 0.3, 0.7),  1.0),\n        Pretty_Sine_Data(0.8 * vec2(p.x - iTime, 2.5 * p.y),              vec3(0.8, 1.3, 0.8),  0.5),\n        Pretty_Sine_Data(0.8 * vec2(p.x - iTime + 0.5, 2.5 * p.y), 0.8  * vec3(0.8, 1.3, 0.8),  0.5),\n        Pretty_Sine_Data(0.8 * vec2(p.x - iTime + 0.9, 2.5 * p.y), 0.64 * vec3(0.8, 1.3, 0.8),  0.5),\n        Pretty_Sine_Data(3.5 * vec2(p.x - 1.24 * iTime, p.y),             vec3(1.7, 0.7, 0.0),  1.0)\n    );\n    \n    float output_dist = 0.0;\n    vec3 output_color = vec3(0.0);\n    \n    for(int i = 0; i < 8; ++i)\n    {\n        float d = pretty_sine(data[i].uv);\n        float limit = (p.x < -half_diff_length || p.x > half_diff_length) ? 0.0 : 1.0;\n        float cd = limit * data[i].multiplier * clamp(d, 0.0, 1.0);\n        output_color += cd * data[i].color;\n        output_dist += cd;\n    }\n    return vec4(output_color, -0.125 * output_dist);\n}\n\n// NOTE(rytis): Taken from https://fgiesen.wordpress.com/2013/02/06/the-barycentric-conspirac/\nfloat edge_f(vec2 p, vec2 e0, vec2 e1)\n{\n    float result = (e0.y - e1.y) * p.x + (e1.x - e0.x) * p.y + e0.x * e1.y - e0.y * e1.x;\n    return result;\n}\n\nstruct Point\n{\n    vec3 color;\n    float d;\n    vec2 p;\n};\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    uv.x *= aspect_ratio;\n    uv.x -= 0.5 * (aspect_ratio - 1.0);\n    uv = uv * 2.0 - 1.0;\n    \n    uv *= 8.0;\n\n    vec2 p0 = vec2(-3.0 + sin(iTime), -5.0 + cos(iTime));\n    vec2 p1 = vec2(7.0 + cos(0.5 * iTime), 0.0 - sin(iTime));\n    vec2 p2 = vec2(-2.0 + cos(0.5 * iTime), 5.0 - sin(0.44 * iTime));\n\n    Point points[3] = Point[3](\n        Point(vec3(0.5), circle(uv - p0, 1.2), p0),\n        Point(vec3(0.5), circle(uv - p1, 1.2), p1),\n        Point(vec3(0.5), circle(uv - p2, 1.2), p2)\n    );\n    \n    vec3 color = vec3(0.0);\n    float area_tri = 0.5 * edge_f(p0, p1, p2);\n    float inv_area_tri = 1.0 / area_tri;\n    float area_p01 = edge_f(uv, p0, p1);\n    float area_p12 = edge_f(uv, p1, p2);\n    float area_p20 = edge_f(uv, p2, p0);\n\n    float multiplier = smoothstep(-0.25, 0.5, -inv_area_tri * min(min(area_p01, area_p12), area_p20));\n    float waves = 0.0;\n    waves += multiplier * smoothstep(1.0, 1.5, pretty_sine(uv / 8.0));\n    waves += multiplier * smoothstep(1.0, 1.5, pretty_sine(vec2(uv.x, -uv.y) / 4.0));\n    waves += multiplier * smoothstep(1.0, 1.5, pretty_sine(uv / 2.0));\n    \n    vec2 i_uv = floor(uv);\n    vec2 f_uv = fract(uv);\n\n    float min_dist = 1.0;\n    for(int i = -1; i <= 1; ++i)\n    {\n        for(int j = -1; j <= 1; ++j)\n        {\n            vec2 neighbor = vec2(float(i), float(j));\n            vec2 random_point = random2(i_uv + neighbor);\n            random_point = 0.5 + 0.5 * vec2(sin(2.0 * PI * random_point + 0.5 * iTime));\n            vec2 diff = neighbor + random_point - f_uv;\n            float dist = length(diff);\n            min_dist = min(dist, min_dist);\n        }\n    }\n    vec2 waves_smooth = smin(min_dist, waves, 0.1);\n    color += multiplier * 3.0 * smoothstep(0.5, -0.5, -waves_smooth.y) * vec3(0.20, 0.23, 0.3);\n    color += multiplier * min_dist * vec3(0.20, 0.23, 0.3);\n    \n    \n    if(area_p01 >= 0.0 && area_p12 >= 0.0 && area_p20 >= 0.0)\n    {\n        color = mix(color, vec3(0.5), 3.0 * inv_area_tri * min(min(area_p01, area_p12), area_p20));\n    }\n    \n    vec4 e0 = edge(uv, p0, p1);\n    vec4 e1 = edge(uv, p1, p2);\n    vec4 e2 = edge(uv, p2, p0);\n    color += e0.xyz;\n    color += e1.xyz;\n    color += e2.xyz;\n    float edge_dist = min(min(e0.w, e1.w), e2.w);\n    for(int i = 0; i < 3; ++i)\n    {\n        if(points[i].d < edge_dist)\n        {\n            vec2 smooth_dist = smin(points[i].d, edge_dist, 0.3);\n            vec2 p_on_sphere = uv - points[i].p;\n            vec3 sphere_normal = normalize(vec3(p_on_sphere.x, p_on_sphere.y, smooth_dist.x));\n            vec3 light_dir = normalize(-vec3(uv.x, uv.y, 4.0));\n            float atten = max(dot(sphere_normal, light_dir), 0.0);\n            color = mix(points[i].color * (0.5 + 0.5 * atten * atten), color, smooth_dist.y);\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}