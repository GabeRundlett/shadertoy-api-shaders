{
    "Shader": {
        "info": {
            "date": "1521884672",
            "description": "Derived from Fabrice's [url]https://www.shadertoy.com/view/XsGyRm[/url]\n\nSelected points on a star polygon can be connected to make more polygons.\n\n1,2,3,4: toggle elements\nn,m,a,b,c: params, shift to reverse\nx: show params\n<space>: toggle mode",
            "flags": 48,
            "hasliked": 0,
            "id": "XdVcRw",
            "likes": 12,
            "name": "Nearly a Hypocycloid",
            "published": 3,
            "tags": [
                "2d",
                "star",
                "polygon",
                "hypocycloid"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 704
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Created by Matthew Arcus, 2018\n//\n// Derived from https://www.shadertoy.com/view/XsGyRm by\n// Fabrice Neyret\n//\n// A circle of radius M, rotating inside a circle of radius N,\n// traces out a hypocycloid curve:\n//\n// https://en.wikipedia.org/wiki/Hypocycloid\n//\n// and a circle of radius N-M traces out the same hypocycloid -\n// this is Daniel Bernoulli's \"double generation theorem\".\n//\n// Such hypocyloids closely approximate N-pointed stars, ie.\n// regular polygons with N vertices with an edge between\n// vertices M units apart, so conversely, choosing appropriate\n// points on such a polygon will define approximations to the\n// original circles\n//\n// Here the parameters are N and M as above, defining polygons\n// with sides M and N-M, A and B control the spacing of the\n// connected points within these polygons. M*(N-M)/C\n// points are shown, C is normally 1, but  can be used to decrease\n// the number of points shown and simplify the pattern (if\n// the division is not exact, results may be unsatisfactory).\n//\n// We can also generate curious patterns by connecting (multiples\n// of) N points together - <space> toggles this mode. In this\n// mode, A is just the spacing used for the red lines, B the\n// same for blue, and C*N points are displayed.\n//\n// Use the 'x' key for a display of the numeric parameters\n//\n// Controls (keys for numeric parameters increase when unshifted,\n// decrease when shifted):\n//\n// 1: show star polygon\n// 2: show red polygon\n// 3: show blue polygon\n// 4: show points\n// n,m,a,b,c: increase/decrease N,M,A,B,C\n// <space>: switch modes.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n#define PI 3.14159\n\nfloat line(vec2 p, vec2 a, vec2 b) { // draw a line\n  b -= a; p -= a;\n  return length(p - b*clamp(dot(b,p)/dot(b,b),0.0,1.0));\n}\n\nfloat N,M,K,A,B,C,P,Q,T,theta;\n\n//vec2 vertices[20];\n\n//#define P(i) (vertices[int(i)%int(N)])\n#define P(i) (vec2( sin(theta*(i)),cos(theta*(i))))\n\nvec2 point(float n) {            // point(n,t) on ngram  \n  float t = mod(T/5.0 + n*N/K,N);\n  float i = floor(t);\n  return mix( P(i), P(i+1.), .5-.5*cos(PI*fract(t)) );\n}\n\nconst int KEY_SPACE = 32;\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\n\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nbool keypress(int key) {\n  //return false;\n  return texelFetch(iChannel0, ivec2(key,2),0).x != 0.0;\n}\nvec4 store(int i,int j) {\n  //return vec4(0);\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nvoid init() {\n  N = float(keycount(CHAR_N))+3.0;\n  N = min(N,20.0);\n  M = float(keycount(CHAR_M))+1.0;\n  //N = 11.0; M = 5.0; K = M*(N-M);\n  theta = 2.0*PI*M/N; // angle between ngram vertices\n  A = float(keycount(CHAR_A))+1.0;\n  B = float(keycount(CHAR_B))+1.0;\n  C = float(keycount(CHAR_C))+1.0;\n  if (!keypress(KEY_SPACE)) {\n    // P regular Q-gons (or Q-grams)\n    // Q regular P-gons (or P-grams)\n    P = A*M, Q = B*(N-M), K = M*(N-M)/C;\n  } else {\n    P = A, Q = B; K = C*N;\n  }\n}\n\nvoid mainImage( out vec4 outColor,  vec2 fragCoord )\n{\n  bool showparams = keypress(CHAR_X);\n  bool dostar = !keypress(CHAR_0+1);\n  bool dored = !keypress(CHAR_0+2);\n  bool doblue = !keypress(CHAR_0+3);\n  bool dopoints = !keypress(CHAR_0+4);\n  init();\n  vec2 U = ( 2.0*fragCoord - iResolution.xy ) / iResolution.y;\n  T = 0.5*iTime;\n  if (keypress(CHAR_S)) T *= 0.5;\n  float ymin = 1e8, pmin = 1e8, rmin = 1e8, bmin = 1e8;\n  float k = 0.0125, l = 0.035;\n  float delta = 0.007;\n  float aa = 2.0/iResolution.y;\n  vec3 col = vec3(0.2,0.4,0.4);    \n  float tmp;\n  \n  for (float i=0.0; i<N; i++) {\n    ymin = min(ymin,line( U, P(i), P(i+1.0)));\n  }\n  for (float n=0.0; n<K; n++) {  \n    vec2 P0 = point(n);\n    vec2 P1 = point(n+P);\n    vec2 P2 = point(n+Q);\n    \n    // Remember the topmost red and blue lines\n    pmin = min (pmin, distance(P0,U)); // dots\n    tmp = line( U, P0, P1 );           // A shape\n    if (tmp < k+aa) rmin = tmp;\n    tmp = line( U, P0, P2 );           // B shape\n    if (tmp < k+aa) bmin = tmp;\n  }\n  // Lines have a smoothstepped edge, width delta,\n  // which itself has a smoothstepped edge, width aa\n  // for antialiasing.\n  if (dostar) {\n    col = mix(mix(vec3(1,1,0), vec3(0),\n                  smoothstep(k-delta,k,ymin)),\n              col,smoothstep(k,k+aa,ymin));\n  }\n  if (doblue) {\n    col = mix(mix(vec3(0,0,1), vec3(0),\n                  smoothstep(k-delta,k,bmin)),\n              col,smoothstep(k,k+aa,bmin));\n  }\n  if (dored) {\n    col = mix(mix(vec3(1,0,0), vec3(0),\n                  smoothstep(k-delta,k,rmin)),\n              col,smoothstep(k,k+aa,rmin));\n  }\n  if (dopoints) {\n    col = mix(mix(vec3(0),vec3(0.2),\n                  smoothstep(l-delta,l,pmin)),\n              col,smoothstep(l,l+aa,pmin));\n  }\n\n  if (showparams) {\n    // Simple display of N,M,A,B,C as rows of dots\n    int max = 20;\n    vec2 xy = fragCoord;\n    xy.y = iResolution.y- xy.y;\n    xy =20.0*xy/iResolution.x;\n    xy -= 0.5;\n    vec2 gridxy = round(xy);\n    if (distance(xy, gridxy) < 0.3) {\n      float i = floor(gridxy.x);\n      float j = floor(gridxy.y);\n      if (j == 0.0 && i < N ||\n          j == 1.0 && i < M ||\n          j == 2.0 && i < A ||\n          j == 3.0 && i < B ||\n          j == 4.0 && i < C) {\n        col = vec3(1,1,0);\n      }\n    }\n  }\n  outColor = vec4(col,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nconst int CHAR_A = 65;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else\n    \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0 ) {\n        t = vec4(0);\n        if (i == 0) {\n\t\t\tif (j == CHAR_N) t = vec4(10,0,0,0);\n            else if (j == CHAR_M) t = vec4(6,0,0,0);\n            else if (j == CHAR_A) t = vec4(1,0,0,0);               \n         }\n    } else {\n        t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        // Look for when the toggled state changes\n        // This handles key repeats\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n          \tif (keystate(16,0).x != 0.0) t.x--;\n           \telse t.x++;\n       \t\tt.x = max(t.x,0.0);\n        }\n    }     \n        \n#endif           \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}