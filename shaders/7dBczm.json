{
    "Shader": {
        "info": {
            "date": "1643255416",
            "description": "Recreation of the classic flash game. Started this a long time ago and kinda forgot about it. All it needed was hit detection. (Arrow keys to move, R to reset game.) Original game: https://www.cubefield.org.uk/ ",
            "flags": 48,
            "hasliked": 0,
            "id": "7dBczm",
            "likes": 15,
            "name": "Cubefield (Game)",
            "published": 3,
            "tags": [
                "3d",
                "game",
                "cube",
                "field",
                "recreation",
                "cubefield",
                "flashgame"
            ],
            "usePreview": 0,
            "username": "Plento",
            "viewed": 5238
        },
        "renderpass": [
            {
                "code": "// Fork of \"cubefield 5\" by Plento. https://shadertoy.com/view/Wd3SWM\n// 2022-01-27 01:59:38\n\n// By Cole Peterson (Plento)\n\n// A recreation of the classic flash game: https://www.cubefield.org.uk/\n\n/*\nControls:\n\nLeft and Right arrow keys (side movement)\nR to reset game.\n\n*/\n\n// How long can you go?\n\n\n// Main image\n\nfloat t(vec2 p){return texture(iChannel1, p).w;}\nvec4 t2(vec2 p){return texture(iChannel2, p);}\n\nfloat t0(){return texture(iChannel0, vec2(0.48, 0.03)).w;}\nfloat t1(){return texture(iChannel0, vec2(0.48, 0.03)).y;}\n\nvec4 letter(vec2 p, vec2 c){\n    vec2 p2 = p - .5;\n    p /= 16.;\n    p += (1. / 16.) * c;\n    vec4 col = t2(p);\n    col *= (1.-step(.3 / 16., abs(p2.x / 16.)));\n    col *= (1.-step(.4 / 16., abs(p2.y / 16.)));\n    return col;\n}\n\nfloat gameOver(vec2 p){\n    float c = 0.;\n    c += letter((p - vec2(.0, 0.5)) * 5., vec2(7., 11.)).x;\n    c += letter((p - vec2(.1, 0.5)) * 5., vec2(1., 11.)).x;\n    c += letter((p - vec2(.2, 0.5)) * 5., vec2(13., 11.)).x;\n    c += letter((p - vec2(.3, 0.5)) * 5., vec2(5., 11.)).x;\n    c += letter((p - vec2(.3, 0.2)) * 5., vec2(15., 11.)).x;\n    c += letter((p - vec2(.4, 0.2)) * 5., vec2(6., 10.)).x;\n    c += letter((p - vec2(.5, 0.2)) * 5., vec2(5., 11.)).x;\n    c += letter((p - vec2(.6, 0.2)) * 5., vec2(2., 10.)).x;\n    //c += letter((p - vec2(.7, 0.2)) * 5., vec2(1., 13.)).x;\n    return c;\n}\n\n\nfloat timer(vec2 p, float t, float stop){\n    float c = 0.;\n    \n    vec4 n = vec4(mod(floor(t), 10.), mod(floor(t / 10.), 10.),\n                mod(floor(t / 100.), 10.), mod(floor(t / 1000.), 10.));\n    \n    if(stop > 0.) n = vec4(0);\n    \n    c += letter((p - vec2(.5, 0.0)) * 5., vec2(n.x, 12.)).x;\n    c += letter((p - vec2(.4, 0.0)) * 5., vec2(n.y, 12.)).x;\n    c += letter((p - vec2(.3, 0.0)) * 5., vec2(n.z, 12.)).x;\n    c += letter((p - vec2(.2, 0.0)) * 5., vec2(n.w, 12.)).x;\n    \n    return c;\n}\n\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = u / R;\n    vec2 uv2 = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec4 bB = texture(iChannel1, uv);\n    vec4 bA = texture(iChannel0, uv);\n    vec3 col = bB.xyz;\n    \n    col = mix(col, vec3(.1), timer((uv - vec2(.67, 0.))*2.8, iTime - t1(), bA.w));\n    \n    if(bA.w > 0.){\n        uv.y += cos(uv.x*3. + iTime)*.11;\n        float dt = iTime - t0();\n        float t = clamp(0., 1., dt * 2.);\n        float a = t * gameOver(uv-vec2(.08, 0.5 - t*.4));\n        col = mix(col, vec3(0.8, 0.1, 0.), a);\n    }\n    col *= min(1., iTime*4.);\n    \n    f = vec4(col, 1.0);\n}\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Keyboard input + player values\n\nvec4 buf(vec2 p){return texture(iChannel1, p);   }\nfloat t(vec2 p){return texture(iChannel2, p).w;}\n\n// Check if player should be dead\nint playerState(){\n    float blft = t(vec2(0.48, 0.03));\n    float brgt = t(vec2(0.523, 0.03));\n    float ulft = t(vec2(0.48, 0.095));\n    float urgt = t(vec2(0.523, 0.095));\n    \n    if(ulft > 0. || urgt > 0. &&  (blft < 1. && brgt < 1.))\n        return 1;\n    else if(ulft < 1. && urgt < 1. &&  (blft > 0. || brgt > 0.))\n        return 0;\n    else\n        return 0;\n}\n\n// Will get time of death\nfloat t0(){return texture(iChannel1, vec2(0.48, 0.03)).w;}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n\tvec2 uv = u.xy / R.xy;\n    vec4 bA = buf(uv);\n    \n\tfloat pos = bA.x;\n    float tilt = bA.z;\n    float state = bA.w;\n    float resetTime = bA.y;\n    float RESET = texelFetch( iChannel0, ivec2(KEY_R, 0), 0 ).x;\n    \n    // Reset the game\n    if(RESET > 0.){\n        state = 0.;\n        pos = 0.; \n        tilt = 0.0;\n        resetTime = iTime;\n        f = vec4(pos, resetTime, tilt, state);\n        return;\n    }\n    \n    // Player is dead, \n    if(state != 0.0){\n        state = t0();\n        f = vec4(pos, resetTime, tilt, state);\n        return;\n    }\n    \n    // Save time of death\n    if(playerState() == 1) state = iTime;\n     \n       \n    float left = texelFetch( iChannel0, ivec2(KEY_LEFT,0), 0 ).x;\n    float right = texelFetch( iChannel0, ivec2(KEY_RIGHT,0), 0 ).x;\n    float up = texelFetch( iChannel0, ivec2(KEY_UP,0), 0 ).x;\n    float down = texelFetch( iChannel0, ivec2(KEY_DOWN,0), 0 ).x;\n    \n    \n    pos += moveSpeed * right;\n    pos -= moveSpeed * left;\n    \n    \n    tilt += tiltspeed * right;\n    tilt += -1. * tiltspeed * left;\n    tilt -= 0.008 * sign(tilt);\n    tilt = clamp(tilt, -0.1, 0.1);\n    \n    // Init\n    if(iFrame < 5){\n    \tpos = 0.; \n        tilt = 0.0;\n        state = 0.0;\n        resetTime = 0.;\n    }\n    \n    f = vec4(pos, resetTime, tilt, state);\n}\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Raymarched graphics and death detection\n\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat triangle( in vec2 p ){\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n\n// Game speed\nfloat speed(float t){\n    t *= speedMultiplier;\n    return min((t + 12.) * (t + 12.) * acc, 1000.);\n}\n\n// Mat id cuz theres 3 seperate grids\nfloat mat = 0.;\nfloat md = 99.;\nvoid newmat(float d, float nm){\n    if(d < md){\n        md = d;\n        mat = nm;\n    }\n}\n\n// Distance field\nfloat map(vec3 rp){\n    float d = 999.;\n    \n    vec3 p = rp - vec3(0., -.4, 0.);\n    vec3 p2 = rp - vec3(1.4, -.4, 4.);\n    vec3 p3 = rp - vec3(2.1, -.4, 4.);\n    \n    float id = floor(p.z / b);\n    float id2 = floor(p2.z / b);\n    float id3 = floor(p3.z / b);\n    \n    p.xz = mod(p.xz, b)-.5*vec2(b);\n    p2.xz = mod(p2.xz, b)-.5*vec2(b);\n    p3.xz = mod(p3.xz, b)-.5*vec2(b);\n    \n    p.x += (2.*hash11(id*100.)-1.) * 0.5;\n    p2.x += (2.*hash11(id2*500. + 44.4)-1.) * 0.5;\n    p3.x += (2.*hash11(id3*500. + 44.4)-1.) * 0.5;\n    \n    d = min(sdBox(p,vec3(0.15))-0.008, d);\n    newmat(d, 0.);\n    d = min(sdBox(p2,vec3(0.15))-0.008, d);\n    newmat(d, 1.);\n    d = min(length(rp)-0.05, d);\n    newmat(d, 2.);\n    \n    d = sub(sdBox(rp, vec3(12.)), d);\n\n    return d;\n}\n\nvec3 getNormal( in vec3 pos){\n    vec2 e = vec2(0.004, -0.004);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nfloat edge(vec3 n){\n    float i = abs(dot(vec3(1., 0., 0.), n));\n    float j = abs(dot(vec3(0., 1., 0.), n));\n    float k = abs(dot(vec3(0., 0., 1.), n));\n    return i + j + k;\n}\n\nfloat t0(){return texture(iChannel0, vec2(0.48, 0.03)).w;}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec2 uv2 = uv;\n    \n    vec3 ro = vec3(0.0, 0.17, -7.);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    vec4 data = texture(iChannel0, u/R); // Player data\n    \n    float tilt = data.z;\n    if(abs(tilt) < .01) tilt = 0.0;\n    \n    // Move player and stuff\n    if(data.w == 0.) ro.z += speed(iTime - data.y);\n    else ro.z += speed(t0() - data.y);\n        \n    ro.x += data.x*3.;\n    \n    rd.xy*=rot(tilt);\n    uv*=rot(tilt);\n    \n    // Raymarch stuff\n    float d = 0., t = 0., md = 99., g = 0., ol = 0.;   \n    float asp = R.y / R.x;\n    \n    for(int i = 0; i < 80; i++){\n    \td = map(ro + rd*t); \t   \n        md = min(md, d);\n        if(d < 0.002 || t > FAR){\n            break;\n        }\n        if(d >= md && abs(d) > .12){\n            ol += ss(.01, .018, md);\n            g++;\n        }\n        t += d * .85;\n    }\n    \n    ol /= max(g, .00001);\n    \n    vec3 p = ro+rd*t;\n    vec3 n = getNormal(p);\n    \n    vec3 bgcol = mix(vec3(0.65, 0.65, 0.7), vec3(.93), ss(0.0,0.009, uv.y+0.045)); // bg color\n    \n    float fade = ss(FAR-3.5, FAR, t);\n    \n    // Mat id because there's 3 offset grids\n    float of = 440.;\n    if(mat == 1.){\n        p.x -= 1.7;\n        of = 800.;\n    }\n    else if(mat == 2.){\n        p.x -= 2.1;\n        of = 544.4;\n    }\n    \n    vec2 id = floor(p.xz / vec2(b));\n    float h = 111. * (id.x*50. + id.y * 80.);\n    \n    vec3 cubecol = mix(vec3(0.9, 0.4, 0.0), vec3(0.9, 0.8, 0.0), hash11(h + 22. + of));\n    vec3 col = mix(cubecol, bgcol, fade);\n    \n    float ol2 = min(1.0, 1.-ss(1.0, 1.6, edge(n))+fade);\n    col *= ol;\n    col *= ol2;\n    \n    vec2 tv = uv+vec2(0.0, 0.45);\n    \n    // Death \"explode\" effect\n    if(data.w > 0.){\n        vec2 dir = normalize(vec2(0.0, 0.45) - uv);\n        float k = min((iTime - data.w) * .5, 0.11);\n        vec2 hh = u + iTime*(1.-step(.11, k));\n        vec2 h = dir * (1.-2.*hash22(hh)) * k;\n        tv += vec2(h.x*5., h.y*.3);\n    }\n    \n    col = mix(vec3(0.3), col, ss(0.0, 0.1, triangle((tv)*25.)));\n    \n    // 2D Hit box\n    float kill = (1.-step(.04, abs(uv2.x))) * (1.-step(.04, abs(uv2.y + .443)));\n    float death = 0.;\n    if(t < 3. && kill > 0.) death = 1.;\n    \n    col = mix(vec3(.25), col, ss(.8, .796, abs(uv2.x)));\n    //col += .2*vec3(kill); // show player hitbox\n    f = vec4(col, death);\n}\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define R iResolution.xy\n#define KEY(v,m) texelFetch(iChannel1, ivec2(v, m), 0).x\n#define ss(a, b, t) smoothstep(a, b, t)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n// Game params\nconst float speedMultiplier = 1.0;\nconst float moveSpeed = 0.006;\nconst float tiltspeed = 0.015;\nconst float acc = 0.08;  // speed acceleration\n\nconst float b = 2.5; // grid space\n\nconst float FAR = 10.; // render distance\n\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_R  = 82;\n\nfloat hash11(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}