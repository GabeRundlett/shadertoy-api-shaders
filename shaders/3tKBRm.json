{
    "Shader": {
        "info": {
            "date": "1614093066",
            "description": "first raymarching shader made in a cours at my university",
            "flags": 0,
            "hasliked": 0,
            "id": "3tKBRm",
            "likes": 2,
            "name": "raymarchingbasicTuTo",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "gourki",
            "viewed": 289
        },
        "renderpass": [
            {
                "code": "//thanks remy\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n//thanks iq\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n   p.x += sin(p.y*10.+iTime*2.0)*0.1;\n   p.y += sin(p.z*10.+iTime*5.0)*0.1;\n   p.z += sin(p.x*10.+iTime*2.0)*0.1;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n\nvec3 opRep(vec3 p, vec3 c){\n    return mod(p+0.5*c,c) -0.5*c;\n\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nfloat map(vec3 pos)\n{\n    pos = opRep(pos,vec3(6));\n    \n    float world = sdRoundBox(pos, vec3(0.5),0.5);\n    pos.xz *= rot(iTime);\n    pos.yz *= rot(iTime);\n    pos.xy += sin(iTime)*2.0;\n    world = opSmoothUnion(world, sdRoundBox(pos, vec3(0.5),0.5),0.5);\n    return world;\n}\n\n\n\n\nfloat CastRay(vec3 ro, vec3 rd)\n{\n    float c = 0.0;\n    \n    for(int i = 0; i<64; i++)\n    {\n        float ray = map(ro + rd *c);\n        \n        if(ray < (0.001*c))\n        {\n            return float(i)/32.;\n        }\n        \n        c += ray;\n    }    \n\n    return -1.0;\n}\n\n\nvec3 render(vec3 ro, vec3 rd)// ray origin & ray direction )\n{\n    float contact = CastRay(ro,rd); \n    \n    \n    vec3 col = vec3(0.0);\n    \n    if (contact == -1.0)\n    {\n    col = vec3(mix(vec3(0.0,1.0,1.0),vec3(0.,0.,1.),abs(rd.y)));\n    }\n    else{\n        col = palette(contact, vec3(0.5), vec3(0.5),vec3(1.0),vec3(0.0,0.33,0.));\n        //col = mix(vec3(0.2,0.0,0.0),vec3(1.0,0.0,0.0),(1.0-contact));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   //Centrer camera \n   vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n   uv.x *= iResolution.x/iResolution.y;\n   \n   //Camera\n   \n   vec3 cameraPos = vec3(iTime*10.0,-10.*cos(iTime*1.), -10.*sin(iTime*1.));\n   vec3 cameraTar = vec3(iTime,0.0,5.0);\n   \n   // view Direction / Ray Direction \n   vec3 forward = normalize(cameraTar - cameraPos);\n   vec3 right = normalize(cross(vec3(0.0, -1.0,0.0), forward));\n   vec3 up = normalize(cross(right, forward));\n   vec3 viewDir = normalize(uv.x* right + uv.y * up + forward * 2.0);\n   \n   //Time varying pixel color\n   vec3 col = vec3(uv.x, uv.y, 0.0);\n   \n   col = render(cameraPos, viewDir);\n   \n   //output to screen \n   fragColor = vec4(col,1.0);\n   \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}