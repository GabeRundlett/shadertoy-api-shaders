{
    "Shader": {
        "info": {
            "date": "1612626449",
            "description": "Shifting landscapes using simplex noise and a color palette.\nVideo at https://twitter.com/icylavah/status/1358086037461958663",
            "flags": 0,
            "hasliked": 0,
            "id": "tt3BDH",
            "likes": 6,
            "name": "Shifting Landscapes",
            "published": 3,
            "tags": [
                "noise",
                "random"
            ],
            "usePreview": 0,
            "username": "icylavah",
            "viewed": 407
        },
        "renderpass": [
            {
                "code": "// \t<www.shadertoy.com/view/XsX3zB>\n//\tnoise functions by Nikita Miropolskiy\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    \n\t/*vec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;*/\n    \n    return fract(j*vec3(64,8,512)) -.5;\n}\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\nfloat snoise(vec3 p) {\n\n\tvec3 s = floor(p + dot(p, vec3(F3)));\n\tvec3 x = p - s + dot(s, vec3(G3));\n\t \n\tvec3 e = step(vec3(0.0), x - x.yzx);\n\tvec3 i1 = e*(1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\tvec3 x1 = x - i1 + G3;\n\tvec3 x2 = x - i2 + 2.0*G3;\n\tvec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\tvec4 w, d;\n\t \n\tw.x = dot(x, x);\n\tw.y = dot(x1, x1);\n\tw.z = dot(x2, x2);\n\tw.w = dot(x3, x3);\n\t \n\tw = max(0.6 - w, 0.0);\n\t \n\td.x = dot(random3(s), x);\n\td.y = dot(random3(s + i1), x1);\n\td.z = dot(random3(s + i2), x2);\n\td.w = dot(random3(s + 1.0), x3);\n\t \n\tw *= w;\n\tw *= w;\n\td *= w;\n\t \n\treturn dot(d, vec4(52.0));\n}\n\nfloat snoiseFractal(vec3 m) {\n\treturn   0.5333333* snoise(m)\n\t\t\t\t+0.2666667* snoise(2.0*m)\n\t\t\t\t+0.1333333* snoise(4.0*m)\n\t\t\t\t+0.0666667* snoise(8.0*m);\n}\n\n// ------\n\n#define fast false // Change to true for faster algorithm with AA\nconst int compareDistance = 4; // >= 1\n\nconst int r2 = compareDistance * compareDistance;\nconst int steps = 6;\nconst vec3 colors[steps] = vec3[](vec3(0.133, 0.223, 0.345), vec3(0.270, 0.458, 0.690), vec3(0.458, 0.725, 0.745), vec3(0.815, 0.839, 0.709), vec3(0.976, 0.709, 0.674), vec3(0.933, 0.462, 0.454));\n\nint getPixelStepi(vec2 pixel, vec2 dimensions, float t) {\n    return min(max(int(((snoiseFractal(vec3(pixel / dimensions.y, t * 0.05)) + 0.5)) * float(steps)), 0), steps - 1);\n}\n\nfloat getPixelStepf(vec2 pixel, vec2 dimensions, float t) {\n    return ((snoiseFractal(vec3(pixel / dimensions.y, t * 0.05)) + 0.5)) * float(steps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fast) {\n        float step = getPixelStepf(fragCoord, iResolution.xy, iTime);\n        fragColor = vec4(colors[int(step)],1) * smoothstep(2.,4., abs(fract(step+.5)-.5) / fwidth(step) ) ;\n    } else {\n        int step = getPixelStepi(fragCoord.xy, iResolution.xy, iTime) - 0;\n\n        for (int y = -compareDistance; y <= compareDistance; y++) {\n            for (int x = -compareDistance; x <= compareDistance; x++) {\n                if (x * x + y * y > r2) continue;\n                if (getPixelStepi(fragCoord.xy + vec2(x, y), iResolution.xy, iTime) != step) {\n                    fragColor = vec4(vec3(0.0), 1.0);\n                    return;\n                }\n            }\n        }\n\n        fragColor = vec4(colors[int(step)], 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}