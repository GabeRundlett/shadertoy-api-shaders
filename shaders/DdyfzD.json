{
    "Shader": {
        "info": {
            "date": "1698005808",
            "description": "Colorful version!\n\nENTER to restart.",
            "flags": 48,
            "hasliked": 0,
            "id": "DdyfzD",
            "likes": 8,
            "name": "Nyan Dot Writer",
            "published": 3,
            "tags": [
                "2d",
                "text",
                "dots",
                "dot",
                "transform",
                "multipass",
                "writer"
            ],
            "usePreview": 0,
            "username": "misol101",
            "viewed": 214
        },
        "renderpass": [
            {
                "code": "float FPS = 10.f;\nivec2 AtlasSize = ivec2(6, 1);\nivec2 FrameSize = ivec2(40.f, 32.f);\n\nvoid getNyan( inout vec4 fragColor, in vec2 uv ) {\n    int frame = int(floor(iTime*FPS));\n    int frameNum = frame % (AtlasSize.x * AtlasSize.y);\n    ivec2 currentFramePosition = ivec2(frameNum % AtlasSize.x, frameNum / AtlasSize.x);\n    \n    vec4 color = texture(iChannel1, uv/vec2(AtlasSize) + vec2(currentFramePosition*FrameSize)/iChannelResolution[1].xy);\n    if (color.w > 0.9) fragColor = color*color*1.55;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 v3 = texelFetch( iChannel0, ivec2(int(fragCoord.x),int(fragCoord.y)), 0 ).xyz;\n\n    vec2 uv = (fragCoord - (0.5 * iResolution.xy)) / iResolution.y;\n    vec3 white = abs(uv.y) < 0.43 && abs(uv.y) > 0.427 && abs(uv.x)<0.85 ? vec3(0.8,1,1) : vec3(0.);\n    fragColor = vec4( v3 + white, 1.0 );\n\n    ivec2 r = ivec2(iResolution.xy);\n    ivec4 npos = ivec4(texelFetch(iChannel2, ivec2(2,0), 0 ));\n\n    vec2 sp = getStartPos(npos.y, iResolution.xy, iTime);\n    if (int(texelFetch(iChannel2, ivec2(1,0), 0 ).x) == 1) { sp = vec2(float(int(npos.x)%r.x), iResolution.y - float(int(npos.x)/r.x)); }\n        \n    vec2 pos = (sp/iResolution.y) - 0.5;\n    pos.x += (1. - iResolution.x/iResolution.y) * 0.5;\n\n    vec2 siz = vec2(0.077,0.067);\n    if (abs(uv.x-pos.x) < siz.x && abs(uv.y-pos.y)< siz.y) {\n        vec2 uv2 = ((uv-pos)/siz*0.5 + 0.5);\n        getNyan(fragColor, uv2);\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// send away dots\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (readKey(KEY_ENTER)) { fragColor=vec4(0); return; }\n    if (int(texelFetch(iChannel1, ivec2(0,0), 0).w) != int(iResolution.x)) { fragColor=vec4(0); return; }\n    \n    int pxi = int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x) - 3;\n    if (pxi > NOF_DOTS) discard;\n\n    ivec2 r = ivec2(iResolution.xy);\n\n    if (ivec2(0,0) == ivec2(fragCoord)) {\n        ivec4 val = ivec4(texelFetch(iChannel0, ivec2(0,0), 0 ));\n        int tv = (1-int(texelFetch(iChannel0, ivec2(1,0), 0 ).x))*2-1;\n        if (iFrame < 2) {\n            val = ivec4(0);\n        } else {\n            int v=val[DOTS_PER_FRAME-1];\n            for (int j = 0; j<DOTS_PER_FRAME; j++) {\n                for (int i = 0; i < 5000; i++) { // search for lit pixel\n                    v+=1*tv;\n                    vec2 p=vec2(v%r.x,r.y-v/r.x);\n\n                    if (texelFetch(iChannel1,ivec2(p),0).x > 0.1) {\n                        break;\n                    }\n                }\n                val[j] = v;\n            }\n        }\n        fragColor = vec4(val);\n        return;\n    }\n\n    if (ivec2(1,0) == ivec2(fragCoord)) {\n        ivec4 val = ivec4(texelFetch(iChannel0, ivec2(0,0), 0 ));\n        int tv =  int(texelFetch(iChannel0, ivec2(1,0), 0 ).x);\n        if (iFrame < 2) {\n            tv = 0;\n        } else {\n            if (val.x > int(iResolution.x*iResolution.y)+5000*NOF_STEPS*3) tv=1;\n            if (val.x < 0) tv=0;\n        }\n        fragColor = vec4(tv);\n        return;\n    }\n    if (ivec2(2,0) == ivec2(fragCoord)) {\n        fragColor = texelFetch(iChannel0, ivec2(0,0), 0 );\n        return;\n    }\n\n    vec2 sp=vec2(0), ep=vec2(0);\n    int dotFound = -1;\n    for (int i=0; i<DOTS_PER_FRAME; i++) {\n        if ((pxi+i*(NOF_STEPS+1)) % NOF_DOTS == iFrame % NOF_DOTS)\n            dotFound = i;\n    }\n\n    if (dotFound >= 0) { // initialize new dot\n        int i = int(texelFetch(iChannel0, ivec2(0,0), 0 )[dotFound]);\n        vec2 p=vec2(i%r.x,r.y-i/r.x);\n\n        if (texelFetch(iChannel1,ivec2(p),0).x > 0.1) {\n            sp = getStartPos(i, iResolution.xy, iTime);\n            ep = p;\n            if (int(texelFetch(iChannel0, ivec2(1,0), 0 ).x) == 1) { ep=sp; sp=p; }\n        }\n        fragColor = vec4(sp, ep);\n    }\n    else { // update active dot\n        vec4 cs = texelFetch(iChannel0, ivec2(fragCoord), 0 );\n        int count = (int(cs.w) >> 12) + 1;\n        int ai = int(cs.w) & 4095;\n        cs.w = float((count<<12) | ai);\n        vec2 ep = vec2(cs.z, ai);\n        \n        if (count >= NOF_STEPS) {\n            cs.x=ep.x; cs.y=ep.y; cs.w=float((NOF_STEPS<<12) | ai);\n        } else {\n            vec2 cp = cs.xy;\n            vec2 ap = (ep-cp)/(float(NOF_STEPS)-float(count));\n            cs.x += ap.x;\n            cs.y += ap.y;\n        }\n        fragColor = cs;\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const int NOF_STEPS = 120;\n\nconst int DOTS_PER_FRAME = 4; // 1-4, higher value writes faster\n\nconst int NOF_DOTS = (NOF_STEPS + 1) * DOTS_PER_FRAME;\n\nconst int NOF_REGIONS = 9; // 2-9\nconst int BPC = NOF_REGIONS * NOF_REGIONS /4 + 1;\n\n#define LARGE_DOTS\n\nconst int KEY_SPACE = 32;\nconst int KEY_ENTER = 13;\nconst int KEY_D     = 68;\n\n#define readKey(key) (texelFetch( iChannel3, ivec2(key, 0), 0).x > .5)\n#define readKeyToggle(key) (texelFetch( iChannel3, ivec2(key, 2), 0).x > .5)\n\nconst vec4 rainbow[6] = vec4[]( vec4(1,0,0,0), vec4(1,0.66,0,0), vec4(1,1,0,0), vec4(0,1,0,0), vec4(0,0.6,1,0), vec4(1,0.3,1,0) );\n\nvec2 getStartPos(int i, vec2 resolution, float time) {\n    vec2 sp;\n    float progr = float(i / int(resolution.x)) / resolution.y;\n    if (progr > 0.7)\n        sp = vec2(resolution.x*0.5+sin(time*8.)*(resolution.x*0.25), resolution.y*0.82);\n    else if (progr > 0.4)\n        sp = vec2(0.55*resolution.x+sin(time*3.)*(resolution.x*0.1), 0.44*resolution.y+cos(time*3.)*(resolution.y*0.16));\n    else\n        sp = vec2(resolution.x*0.5+sin(time*6.)*(resolution.x*0.19), resolution.y*0.2);\n    return sp;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// check which regions have dots\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int pxi = int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x) - 3;\n    if (pxi > NOF_DOTS) discard;\n    \n    if (ivec2(0,0)==ivec2(fragCoord)) {\n\n        int xd=int(iResolution.x) / NOF_REGIONS + 1;\n        int yd=int(iResolution.y) / NOF_REGIONS + 1;\n        ivec2 r = ivec2(iResolution.xy);\n\n        ivec4 regions = ivec4(0);\n        for (int i=3; i<NOF_DOTS+3; i++) {\n            ivec2 p=ivec2(i%r.x,i/r.x); \n            vec2 px = texelFetch(iChannel0, p, 0 ).xy;\n            \n            int xr=int(px.x) / xd;\n            int yr=int(px.y) / yd;\n            int reg = xr + yr * NOF_REGIONS;\n            int cp = reg / BPC;\n            int bp = reg % BPC;\n            regions[cp] |= (1<<bp);\n        }\n        fragColor = vec4(regions);\n        return;\n    }\n\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// draw dots in place and fade old ones\n\nconst float END_VAL = 10.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (readKey(KEY_ENTER)) { fragColor=vec4(0); return; }\n    if (int(texelFetch(iChannel2, ivec2(0,0), 0).w) != int(iResolution.x)) { fragColor=vec4(0); return; }\n\n    ivec2 r = ivec2(iResolution.xy);\n\n    float cellx = iResolution.x / 32.;\n    vec4 rcol = rainbow[int(fragCoord.x/cellx) % 6];\n\n    vec4 org = max(vec4(0.),texelFetch(iChannel1, ivec2(fragCoord), 0 ) - vec4(vec3(0.15),0.));\n    \n    if (org.w >= END_VAL) { // keep this finished dot, unless it is one of our current start dots when reversing\n        bool isInit = false;\n        ivec4 inits = ivec4(texelFetch(iChannel0, ivec2(2,0), 0 ));\n        for (int i=0; i<DOTS_PER_FRAME; i++) {\n            if(ivec2(fragCoord)==ivec2(inits[i]%r.x,r.y-inits[i]/r.x))\n                isInit = true;\n        }\n        fragColor = vec4(texelFetch(iChannel2, ivec2(fragCoord), 0 ).xyz*rcol.xyz, isInit ? 0. : END_VAL);\n        return;\n    }\n\n    vec4 regions = texelFetch(iChannel0, ivec2(0,0), 0 ); //regions = vec4(2097151.0);\n    int xd=int(iResolution.x) / NOF_REGIONS + 1;\n    int xr=int(fragCoord.x) / xd;\n    int yd=int(iResolution.y) / NOF_REGIONS + 1;\n    int yr=int(fragCoord.y) / yd;\n    int reg = xr + yr * NOF_REGIONS;\n    int cp = reg / BPC;\n    int bp = reg % BPC;\n    if ((int(regions[cp]) & (1<<bp)) == 0) {\n        fragColor = org;\n        if (readKeyToggle(KEY_D)) fragColor = vec4(0.5); // see skipped regions\n        return;\n    }\n\n    float hitadd = 1.0;\n    int ended = 0;\n\n    for (int i=3; i<NOF_DOTS+3; i++) {\n        ivec2 p=ivec2(i%r.x,i/r.x); \n        vec4 pxzw = texelFetch(iChannel0, p, 0 );\n        vec2 px = pxzw.xy;\n#ifdef LARGE_DOTS\n        if (distance(px,fragCoord) < 2.5) {\n            if ((int(pxzw.w) >> 12) >= NOF_STEPS) { if (ended==0) ended=1; if (ivec2(px) == ivec2(fragCoord)) ended = 2; }\n#else\n        if (ivec2(px) == ivec2(fragCoord)) {\n            if ((int(pxzw.w) >> 12) >= NOF_STEPS) ended = 2;\n#endif\n            vec4 my_rcol = rainbow[int(pxzw.z/cellx) % 6];\n            org = hitadd * my_rcol;\n            // break; // slows things down, a lot...\n        }\n    }\n    if (ended > 0) { fragColor = vec4(texelFetch(iChannel2, ivec2(fragCoord), 0 ).xyz * rcol.xyz, ended == 1 ? org.w : END_VAL); return; }\n    vec4 cols[2] = vec4[]( vec4(0,0,1,0),vec4(0,1,0,0) );\n    fragColor = min(vec4(1.),org);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// text to write\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (ivec2(0,0)==ivec2(fragCoord)) {\n        fragColor=vec4(0,0,0,iResolution.x); return;\n    }\n\n    fragColor = vec4(0.);\n    vec2 UO = 18.*(fragCoord)/iResolution.y;\n    vec2 U;\n\n    U = UO;\n    U.x -= 3.;\n    if (U.x >= 0. && U.x <= 6. && U.y >= 14. && U.y <= 15.) {\n        int i = int[](28,78,89,65,78,28)[int(U)];\n        fragColor = vec4(texture( iChannel0, fract(U)*.055 + vec2(i,15-i/16)/16. ).x);\n        if (fract(U.x) < 0.1 || fract(U.x) > 0.97|| fract(U.y) < 0.1 || fract(U.y) > 0.97) fragColor=vec4(0.);\n    }\n    U = UO;\n    U.x -= 3.;\n    if (U.x >= 0. && U.x <= 13. && U.y >= 13. && U.y <= 14.) {\n        int i = int[](99,111,110,115,116,114,117,99,116,105,111,110,33)[int(U)];\n        fragColor = vec4(texture( iChannel0, fract(U)*.055 + vec2(i,15-i/16)/16. ).x);\n        if (fract(U.x) < 0.1 || fract(U.x) > 0.97|| fract(U.y) < 0.1 || fract(U.y) > 0.97) fragColor=vec4(0.);\n    }\n\n    U = UO;\n    U.x -= 22.;\n    if (U.x >= 0. && U.x <= 7. && U.y >= 12. && U.y <= 14.) {\n        int i;\n        switch(int(U.y-12.)) {\n            case 1: i = int[](82,65,73,78,66,79,87)[int(U)]; break;\n            case 0: i = int[](32,80,79,87,69,82,32)[int(U)]; break;\n        }\n        fragColor = vec4(texture( iChannel0, fract(U)*.055 + vec2(i,15-i/16)/16. ).x);\n        if (fract(U.x) < 0.1 || fract(U.x) > 0.97|| fract(U.y) < 0.1 || fract(U.y) > 0.97) fragColor=vec4(0.);\n    }\n    \n    U = UO;\n    U.x -= 7.;\n    if (U.x >= 0. && U.x <= 4. && U.y >= 6. && U.y <= 10.) {\n        int i;\n        switch(int(U.y-6.)) {\n            case 3: i = int[](32,78,89,32)[int(U)]; break;\n            case 2: i = int[](33,32,32,65)[int(U)]; break;\n            case 1: i = int[](84,32,32,78)[int(U)]; break;\n            case 0: i = int[](32,65,67,32)[int(U)]; break;\n        }\n        fragColor = vec4(texture( iChannel0, fract(U)*.055 + vec2(i,15-i/16)/16. ).x);\n        if (fract(U.x) < 0.1 || fract(U.x) > 0.97|| fract(U.y) < 0.1 || fract(U.y) > 0.97) fragColor=vec4(0.);\n    }\n\n    U = UO;\n    U.x -= 15.;\n    if (U.x >= 0. && U.x <= 14. && U.y >= 3. && U.y <= 4.) {\n        int i = int[](32,32,32,32,32,32,32,82,101,112,101,97,116,29)[int(U)];\n        fragColor = vec4(texture( iChannel0, fract(U)*.055 + vec2(i,15-i/16)/16. ).x);\n        if (fract(U.x) < 0.1 || fract(U.x) > 0.97|| fract(U.y) < 0.05 || fract(U.y) > 0.97) fragColor=vec4(0.);\n    }\n\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}