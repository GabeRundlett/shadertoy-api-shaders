{
    "Shader": {
        "info": {
            "date": "1554150134",
            "description": "Trying to use the cell-index for some variation in motion. Also wanted to do something at least slightly artistic. Set REFLECTIONS to false, if your GPU gets stressed.",
            "flags": 64,
            "hasliked": 0,
            "id": "3sSXzy",
            "likes": 22,
            "name": "Breaking up stripes",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "phong",
                "metaballs",
                "shadows",
                "blinn",
                "soundcloud",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 2233
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Breaking up stripes - Making use of the cell-index of domain repetition to\n// vary object motion\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst bool REFLECTIONS = true;\n\nmat2 r2d (float deg) {\n\tfloat rad = radians (deg);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (c, s, -s, c);\n}\n\nfloat smin (float d1, float d2, float k)\n{\n\tfloat h = clamp (.5 + .5*(d2 - d1)/k, .0, 1.);\n\treturn mix (d2, d1, h) - k*h*(1. - h);\n}\n\nfloat sdSphere (vec3 p, float r) {\n\treturn length (p) - r;\n}\n\nfloat ballMerge (float d, vec3 p, float r, float k) {\n\tfloat ball = sdSphere (p, r);\n\treturn smin (d, ball, k);\n}\n\nfloat opRepeat (inout float p, float size) {\n\tfloat c = floor ((p + .5*size)/size);\n\tp = mod (p + .5*size, size) - .5*size;\n\treturn c;\n}\n\nfloat map (vec3 p) {\n\tfloat ground = p.y + 1.5;\n\tfloat wall = p.z + 1.5;\n\tfloat size = 4.;\n\tfloat cell = opRepeat (p.x, 4.);\n\tp.xz *= r2d (45.*iTime + 80.*cell);\n\tp.xy *= r2d (57.*iTime + 50.*cell);\n\tfloat t = iTime;\n\tfloat r1 = .5 + .1*(.5+.5*cos (2.*t));\n\tfloat r2 = .3 + .1*(.5+.5*cos (3.*t));\n\tfloat r3 = .4 + .1*(.5+.5*cos (4.*t));\n\tfloat r4 = .2 + .1*(.5+.5*cos (2.*t));\n\tfloat r5 = .6 + .1*(.5+.5*cos (3.*t));\n\tfloat r6 = .3 + .1*(.5+.5*cos (4.*t));\n\tfloat k1 = .35 + .1*(.5+.5*cos (2.*t));\n\tfloat k2 = .5 + .1*(.5+.5*cos (3.*t));\n\tfloat k3 = .4 + .1*(.5+.5*cos (4.*t));\n\tfloat k4 = .6 + .1*(.5+.5*cos (2.*t));\n\tfloat k5 = .3 + .1*(.5+.5*cos (3.*t));\n\tvec3 c1 = vec3 (cos(2.*t), .1, sin(2.*t));\n\tvec3 c2 = vec3 (cos(3.*t), .2, sin(3.*t));\n\tvec3 c3 = vec3 (cos(4.*t), sin(2.*t), .3);\n\tvec3 c4 = vec3 (cos(2.*t), sin(4.*t), .5);\n\tvec3 c5 = vec3 (.2, cos (3.*t), sin(3.*t));\n\tvec3 c6 = vec3 (.5, cos (4.*t), sin(2.*t));\n\tfloat ball1 = sdSphere (p + c1, r1);\n\tball1 = ballMerge (ball1, p + c2, r2, k1);\n\tball1 = ballMerge (ball1, p + c3, r3, k2);\n\tball1 = ballMerge (ball1, p + c4, r4, k3);\n\tball1 = ballMerge (ball1, p + c5, r5, k4);\n\tball1 = ballMerge (ball1, p + c6, r6, k5);\n\tfloat d = smin (ball1, smin (ground, wall, .7), .9);\n\treturn d;\n}\n\nfloat march (vec3 ro, vec3 rd, inout int iter) {\n\tfloat t = .0;\n\tfloat d = .0;\n\tfor (int i = 0; i < 48; ++i) {\n\t\tvec3 p = ro + d*rd;\n\t\tt = map (p);\n\t\tif (abs (t) < .001*(1. + .125*t)) break;\n\t\td += t*.95;\n\t\titer = i;\n\t}\n\treturn d;\n}\n\nvec3 norm (vec3 p) {\n\tfloat d = map (p);\n\tvec2 e = vec2 (.001, .0);\n\treturn normalize (vec3 (map (p+e.xyy),\n                            map (p+e.yxy),\n                            map (p+e.yyx)) - d);\n}\n\nfloat sha (vec3 p, vec3 lp, vec3 n, float ldist, vec3 ldir)\n{\n\tint foo;\n\tfloat d2w = march (p+.01*n, ldir, foo);\n\treturn ldist < d2w ? 1. : .1;\n}\n\nvec3 shade (vec3 ro, vec3 rd, float d, vec3 n, vec3 lp, vec3 lc, float li) {\n\tvec3 p = ro + d*rd;\n\tvec3 amb = vec3 (.05);\n\tvec3 ldir = normalize (lp - p);\n\tfloat ldist = distance (p, lp);\n\tfloat att = 7. / (ldist*ldist);\n\tfloat diff = max (.0, dot (n, ldir));\n\tvec3 mat = vec3 (.1, .2, 0);\n\tfloat m = smoothstep (.2, .3, .5+.5*cos(4.*(10.+p.z*p.y*p.y)));\n\tmat = mix (vec3 (1.), vec3 (.0), m);\n\tfloat s = sha (p, lp, n, ldist, ldir);\n\tvec3 h = normalize (-rd + ldir);\n\tfloat sp = pow (max (.0, dot (n, h)), 80.);\n\treturn s*att*(amb + diff*lc*li*mat + sp*vec3 (1.));\n}\n\nvec3 cam (vec2 uv, vec3 ro, vec3 aim, float zoom) {\n\tvec3 f = normalize (aim - ro);\n\tvec3 wu = vec3 (.0, 1., .0);\n\tvec3 r = normalize (cross (wu, f));\n\tvec3 u = normalize (cross (f, r));\n\tvec3 c = ro + f*zoom;\n\treturn normalize (c + r*uv.x + u*uv.y - ro);\n}\n\nconst\tvec3 lps[3] = vec3[3](vec3 (.0, .0, 2.),\n                          vec3 (.0, 3., .0),\n                          vec3 (-3., 1., .5));\nconst\tvec3 lcs[3] = vec3[3](vec3 (.9, .8, .7),\n                          vec3 (.8, .7, .9),\n                          vec3 (.8, .9, .7));\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvRaw = fragCoord/iResolution.xy;\n\tvec2 uv = uvRaw*2. - 1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\tuv *= 1. + .75*length (uv);\n\n    vec3 ro = vec3 (2., 2., 1.);\n\tvec3 aim = vec3 (.0);\n\tro.x -= 7.*iTime;\n\taim.x -= 7.*iTime;\n\tvec3 rd = cam (uv, ro, aim, 1.75);\n\tint iter = 0;\n\tfloat d = march (ro, rd, iter);\n\tfloat fog = 1. / (1. + d*d*.1);\n\tfloat glow = float (iter) / 48.;\n\tvec3 p = ro + d*rd;\n\tvec3 n = norm (p);\n\tvec3 col = shade (ro, rd, d, n, p+lps[0], lcs[0], 2. );\n\tcol += shade (ro, rd, d, n, p+lps[1], lcs[1], 3.);\n\tcol += shade (ro, rd, d, n, p+lps[2], lcs[2], 4.);\n\tcol += pow (glow, 1.125)*vec3 (1., .3, .1);\n\n    if (REFLECTIONS) {\n        ro = p+.01*n;\n\t\trd = normalize (reflect (rd, n));\n\t\td = march (ro,rd,  iter);\n\t\tvec3 rcol = shade (ro, rd, d, n, p+lps[0], lcs[0], 2.);\n\t\trcol += shade (ro, rd, d, n, p+lps[1], lcs[1], 3.);\n\t\trcol += shade (ro, rd, d, n, p+lps[2], lcs[2], 4.);\n\t\tcol += .15*rcol;\n    }\n\n\tcol *= fog;\n\tcol = col / (1.25 + col*.5);\t\n\tcol *= 1. - .65*length (uvRaw*2. - 1.);\n\tcol *= mix (1., .75, cos (300.*(uvRaw.y+1.)*(uvRaw.x+uvRaw.y)));\n\tcol = pow (col, vec3 (1./2.2));\n\n\tfragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 18261,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/user4686404/08-danny-byrd-sweet-harmony"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}