{
    "Shader": {
        "info": {
            "date": "1559353662",
            "description": "A simple screensaver done quick, inspired by the Flurry screensaver from OS X. It's not actually simulating the lines but approximating the look with simple curves.",
            "flags": 32,
            "hasliked": 0,
            "id": "Wlj3Dh",
            "likes": 24,
            "name": "Flurry screensaver",
            "published": 3,
            "tags": [
                "line",
                "glow",
                "screensaver",
                "osx",
                "mac"
            ],
            "usePreview": 0,
            "username": "mmerchante",
            "viewed": 2475
        },
        "renderpass": [
            {
                "code": "vec3 EvaluateRandomSpline(vec2 origin, vec2 vel, vec2 p, int curveIndex, float time)\n{\n    float t = time * .75;\n    \n    vec3 dir = vec3(vel, 0.0) * 2.;\n    vec3 up = vec3(-vel.y, vel.x, 0.0) * 2.;\n    \n    vec2 rand = R2seq(curveIndex*123) * 2.0 - 1.0;\n    vec2 rand2 = R2seq(curveIndex*23) * 2.0 - 1.0;\n    \n    rand *= sin(float(curveIndex) * 1.41234);\n    rand2 *= cos(float(curveIndex) * 5.41234);\n    \n    float offset = float(curveIndex) * (.1 + cos(time+float(curveIndex))*.1+.1);\n    float tt = time * .1 + offset;\n    vec3 target = vec3(cos(tt), sin(tt), 0.0);\n        \n    vec3 A = vec3(origin, 0.0);\n    vec3 B = A + dir * rand.x * .85 * cos(t + p.r) + up * rand2.x * .5 * sin(t);\n    vec3 C = A - dir * rand.y * .5 * cos(t) + up * rand2.y * .5;\n    C *= 3.0 * target + cos(t + rand.x) * .25 + .5;\n    \n    B += A * .7 * rand2.y;\n    C += A * .5 * rand2.x;    \n    \n\tCurveSDFSample result = sdBezier(A, B, C, vec3(p, 0.0));\n    float sdf = result.d;\n\n    float distToOrigin = length(p - origin);\n    \n    float thickness = smoothstep(.5, .0, distToOrigin);\n    thickness *= thickness;\n    \n    float hueOffset = float(curveIndex) * .2;\n    \n    float mask = smoothstep(.05 + cos(result.t) * 1.5 * sdf, .0, sdf);\n    mask *= mask * mask * mask;    \n    \n    vec3 color = hsv2rgb_p(vec3(hueOffset + distToOrigin * .8 - t * .9 + rand.x * 2.1235, .2 + cos(result.t) * .5, mask * .7));\n    \n    float glow = smoothstep(.9, -.1, result.d*result.d) * .05;\n    color += .45 * hsv2rgb_p(vec3(distToOrigin * .4 - t * .4 + rand.x * 2.1235, 1.0, glow));    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    float aspect = iResolution.x/iResolution.y;\n    \n    vec4 buffer = texture(iChannel0, vec2(0.0));    \n    vec2 pos = buffer.xy;\n    vec2 velocity = buffer.zw;\n    \n    float time = iTime * .5;\n    \n    vec3 color = vec3(0.0);\n    \n    float glow = smoothstep(1.5, .0, length(pos-uv));\n    color += hsv2rgb_p(vec3(pos.r + pos.y + time, 1.0, glow) * .3);\n    \n    for(int i = 0; i < 15; ++i)\n    {        \n    \tfloat t = time + pow(abs(cos(time * (1.1 + float(i) * .1))), 1.5) * .2;    \n    \tcolor += EvaluateRandomSpline(pos, velocity, uv, i, t);\n    }\n    \n    float vignette = smoothstep(1.5, .0, length(pos-uv));\n    \n    color /= (1.0 + color);\n    color *= color * 2.0;\n    color *= mix(color*color*2.0, vec3(1.0), vignette);\n        \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n    \n    vec2 pos = vec2(.5 * aspect, .5);\n    vec2 velocity = vec2(.1, .1);\n    \n    if(iTime > 0.0)\n    {\n        vec4 buffer = texture(iChannel2, vec2(0.0));\n        \n        vec2 offset = texture(iChannel0, vec2(iTime * .005)).rg * 2.0 - 1.0;    \n        vec2 targetPosition = pos + offset * -.2 + vec2(cos(iTime * .2), sin(iTime * .2)) * .1;\n\n        vec2 targetVelocity = texture(iChannel1, vec2(iTime * .005)).rg * 2.0 - 1.0;\n        \n        pos = mix(buffer.xy, targetPosition, .01);\n        velocity = mix(buffer.zw, targetVelocity, .01);\n        \n        if(iFrame == 0) {\n            pos = targetPosition;\n        }\n    }\n    \n    fragColor = vec4(pos, velocity);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nfloat R1seq(int n)\n{\n\treturn fract(float(n) * 0.618033988749894848204586834365641218413556121186522017520);\n}\n\nvec2 R2seq(int n)\n{\n\treturn fract(vec2(n) * vec2(0.754877666246692760049508896358532874940835564978799543103, 0.569840290998053265911399958119574964216147658520394151385));\n}\n\nstruct CurveSDFSample\n{\n\tfloat d; // Distance to the curve\n    float t; // Parametric T of the closest point on the curve\n};\n  \n// iq: https://www.shadertoy.com/view/ldj3Wh\nCurveSDFSample sdBezier(vec3 A, vec3 B, vec3 C, vec3 pos)\n{    \n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n    \n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    vec2 res;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n        \n        // 1 root\n        vec3 qos = d + (c + b*t)*t;\n        res = vec2( length(qos),t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp(t, 0.0, 1.0);\n\n        // 3 roots\n        vec3 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = vec2(dis,t.x);\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        if( dis<res.x ) res = vec2(dis,t.y);\n        \n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        if( dis<res.x ) res = vec2(dis,t.z);\n        \n        res.x = sqrt( res.x );\n    }\n\n    CurveSDFSample s;\n    s.d = res.x;\n    s.t = res.y;\n    return s;\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 d )\n{\n    return a + b * cos(6.28318 * (t + d));\n}\n\n// Color palette approach\nvec3 hsv2rgb_p(vec3 c) \n{\n    float h = c.x;\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    \n    // Can remove some parameters, but I'll leave them as reference\t\n    return palette(h, vec3(s_n), vec3(s), vec3(1.0, 0.667, .3334));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}