{
    "Shader": {
        "info": {
            "date": "1654912029",
            "description": "Menger Sponge Construction by Animated Mirror Planes",
            "flags": 0,
            "hasliked": 0,
            "id": "7dKyWD",
            "likes": 7,
            "name": "Menger Sponge Construction",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "Ptyonic",
            "viewed": 285
        },
        "renderpass": [
            {
                "code": "struct RayHit {\n    bool hit;\n    vec3 pos;\n    int id;\n};\n\nstruct ObjectDistance {\n    float dist;\n    int id;\n};\n\nconst float pseudoInfty = 3.4e38;\nconst int boxId = 0;\n\n// Coordinate Transformations\nvec3 mengerSponge(vec3 p, int iterations, int step, float t) {\n\tif (iterations == 0) {\n\t\treturn p;\n\t}\n\tfloat mirrorPlaneDistance = 3.5;\n\tmirrorPlaneDistance *= 2.0;\n\tp = p * 0.5 + 0.5;\n\tif (step >= 6) {\n\t\tif (p.y > mix(mirrorPlaneDistance + 0.5, 0.5, t)) {\n\t\t\tp.y = mix(2.0 * mirrorPlaneDistance + 1.0, 1.0, t) - p.y;\n\t\t}\n\t\tt = 1.0;\n\t}\n\tif (step >= 5) {\n\t\tif (p.x > mix(mirrorPlaneDistance + 0.5, 0.5, t)) {\n\t\t\tp.x = mix(2.0 * mirrorPlaneDistance + 1.0, 1.0, t) - p.x;\n\t\t}\n\t\tt = 1.0;\n\t}\n\tif (step >= 4) {\n\t\tif (p.z > mix(mirrorPlaneDistance + 0.5, 0.5, t)) {\n\t\t\tp.z = mix(2.0 * mirrorPlaneDistance + 1.0, 1.0, t) - p.z;\n\t\t}\n\t\tt = 1.0;\n\t}\n\tif (step >= 3) {\n\t\tif (p.x - mix(mirrorPlaneDistance, 0.0, t) > p.z) {\n\t\t\tp.xz = vec2(p.z + mix(mirrorPlaneDistance, 0.0, t), p.x - mix(mirrorPlaneDistance, 0.0, t));\n\t\t}\n\t\tt = 1.0;\n\t}\n\tif (step >= 2) {\n\t\tif (p.y - mix(mirrorPlaneDistance, 0.0, t) > p.z) {\n\t\t\tp.yz = vec2(p.z + mix(mirrorPlaneDistance, 0.0, t), p.y - mix(mirrorPlaneDistance, 0.0, t));\n\t\t}\n\t\tt = 1.0;\n\t}\n\tif (step >= 1) {\n\t\tif (p.z > (mix(mirrorPlaneDistance + 1.0, 1.0, t) / 3.0)) {\n\t\t\tp.z = (mix(2.0 * mirrorPlaneDistance + 2.0, 2.0, t) / 3.0) - p.z;\n\t\t}\n\t\tt = 1.0;\n\t}\n\tif (step >= 0) {\n\t\tp *= mix(1.0, 3.0, t);\n\t\tt = 1.0;\n\t}\n\tfor (int i = 0; i < iterations - 1; i++) {\n\t\tif (p.y > 0.5) {\n\t\t\tp.y = 1.0 - p.y;\n\t\t}\n\t\tif (p.x > 0.5) {\n\t\t\tp.x = 1.0 - p.x;\n\t\t}\n\t\tif (p.z > 0.5) {\n\t\t\tp.z = 1.0 - p.z;\n\t\t}\n\t\tif (p.x  > p.z) {\n\t\t\tp.xz = vec2(p.z, p.x);\n\t\t}\n\t\tif (p.y > p.z) {\n\t\t\tp.yz = vec2(p.z, p.y);\n\t\t}\n\t\tif (p.z > (1.0 / 3.0)) {\n\t\t\tp.z = (2.0 / 3.0) - p.z;\n\t\t}\n\t\tp *= 3.0;\n\t}\n\tp = p * 2.0 - 1.0;\n\treturn p;\n}\n\nfloat scaleFactor(int iterations, int step, float t) {\n\tif (step == 0) {\n\t\treturn pow(3.0, float(iterations - 1)) * mix(1.0, 3.0, t);\n\t}\n\treturn pow(3.0, float(iterations));\n}\n\nfloat gain(float x, float k) {\n\tfloat a = 0.5 * pow(2.0 * ((x < 0.5) ? x : 1.0 - x), k);\n\treturn (x < 0.5) ? a : 1.0 - a;\n}\n\nvec2 gain(vec2 v, float k) {\n\treturn vec2(gain(v.x, k), gain(v.y, k));\n}\n\nfloat sdBox(vec3 pos, vec3 b) {\n\tvec3 posCorner = abs(pos) - b;\n\treturn length(max(posCorner, 0.0)) + min(max(posCorner.x, max(posCorner.y, posCorner.z)), 0.0);\n}\n\n\nObjectDistance sceneDistance(vec3 pos) {\n\tint MAX_ITERATIONS = 7;\n    float time = iTime * 0.9;\n\tint iterations = int(time) / 8 + 1;\n\tint step = int(time) % 8;\n\tfloat k = 8.0;\n\tfloat t = gain(fract(time) * 0.5 + 0.5, k);\n    \n    if (iterations > MAX_ITERATIONS && fract(time) < 0.5 && int(time) % 8 == 0) {\n        iterations = MAX_ITERATIONS + 1;\n    } else {\n        iterations = min(iterations, MAX_ITERATIONS);\n    }\n    \n\tif (step == 0) {\n\t\tt = gain(fract(time), k);\n\t}\n\tif (step == 7) {\n\t\tt = 1.0;\n\t}\n    \n\tfloat d = sdBox(mengerSponge(pos, iterations, step, t), vec3(1.0)) / scaleFactor(iterations, step, t);\n    return ObjectDistance(d, boxId);\n}\n\nRayHit rayMarch(vec3 rayOrigin, vec3 rayDirection) {\n    int maxIterations = 512;\n    float maxT = 25.0;\n    float epsilon = 1.0e-5;\n    \n    float t = 0.0;\n    vec3 pos;\n    ObjectDistance objDist;\n    for (int i = 0; i <= maxIterations; i++) {\n        pos = rayOrigin + t * rayDirection;\n        objDist = sceneDistance(pos);\n        t += objDist.dist / 4.0;\n        if (objDist.dist < epsilon) {\n            return RayHit(true, pos, objDist.id);\n        }\n        if (t > maxT) {\n            return RayHit(false, pos, objDist.id);\n        }\n    }\n    return RayHit(false, pos, objDist.id);\n}\n\nvec3 calculateNormal(vec3 pos) {\n    vec2 epsilon = vec2(1.0e-5, 0.0);\n    vec3 normal = vec3(0.0);\n    normal.x = sceneDistance(pos + epsilon.xyy).dist - sceneDistance(pos - epsilon.xyy).dist;\n    normal.y = sceneDistance(pos + epsilon.yxy).dist - sceneDistance(pos - epsilon.yxy).dist;\n    normal.z = sceneDistance(pos + epsilon.yyx).dist - sceneDistance(pos - epsilon.yyx).dist;\n    return normalize(normal);\n}\n\nvec3 triplanarMap(sampler2D sampler, vec3 n, float k) {\n    vec3 w = pow(abs(n), vec3(k));\n    vec3 tex = (w.x * texture(sampler, 3.0 * (normalize(n).yz * 0.5 + 0.5)) + \n                w.y * texture(sampler, 3.0 * (normalize(n).zx * 0.5 + 0.5)) + \n                w.z * texture(sampler, 3.0 * (normalize(n).xy * 0.5 + 0.5))).rgb;\n    tex /= w.x + w.y + w.z;\n    return tex;\n}\n\nvec4 render(vec2 fragCoord) {\n    vec4 fragColor;\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 screenPos = (fragCoord.xy - iResolution.xy / 2.0) / max(iResolution.y, iResolution.x) * 2.0;\n    \n\tfloat animate = 0.1 * iTime;\n\tvec3 cameraPosition = vec3(2.0 * sin(animate), 2.1, 3.0 * cos(animate));\n    // vec3 cameraPosition = vec3(1.0, 3.0, 3.0);\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    float fov = radians(100.0);\n    \n    vec3 rayOrigin = cameraPosition;\n    vec3 cameraDirection = normalize(cameraTarget - cameraPosition);\n    vec3 screenHorizontal = normalize(vec3(-cameraDirection.z, 0.0, cameraDirection.x));\n    vec3 screenVertical = normalize(cross(screenHorizontal, cameraDirection));\n    vec3 rayDirection = normalize(tan(fov / 2.0) * screenPos.x * screenHorizontal + tan(fov / 2.0) * screenPos.y * screenVertical + cameraDirection);\n    \n    vec3 albedo = vec3(1.0);\n    vec3 lightDirection = normalize(vec3(2.0, 3.0, 1.0));\n    \n    RayHit rayHit = rayMarch(rayOrigin, rayDirection);\n    if (!rayHit.hit) {\n        // Background\n        return vec4(pow(triplanarMap(iChannel0, rayDirection, 8.0) * 0.4, vec3(2.0)), 1.0);\n    }\n    \n    vec3 normal = calculateNormal(rayHit.pos);\n    if (rayHit.id == boxId) {\n        albedo = vec3(0.7, 0.2, 1.0) * 1.4;\n    }\n    vec3 color;\n    rayHit = rayMarch(rayHit.pos + 0.0001 * normal, lightDirection);\n    if (rayHit.hit) {\n        // Shadow\n        color = dot(normal, lightDirection) * albedo * albedo * 0.1;\n    } else {\n        // Light\n        color = clamp(dot(normal, lightDirection), 0.0, 1.0) * albedo;\n    }\n    \n    color = clamp(color, 0.0, 1.0);\n    // Output to screen\n    return vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    \n    // Set higher if your computer allows:\n    int MULTISAMPLE = 1;\n    // Samples MULTISAMPLE x MULTISAMPLE so 4 is plenty\n    \n    for (int x = 0; x < MULTISAMPLE; x++) {\n        for (int y = 0; y < MULTISAMPLE; y++) {\n            fragColor += render(fragCoord + (vec2(x, y) / float(MULTISAMPLE)) - 0.5) / (float(MULTISAMPLE) * float(MULTISAMPLE));\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}