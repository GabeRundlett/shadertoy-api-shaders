{
    "Shader": {
        "info": {
            "date": "1696016879",
            "description": "I'm sorry, but these little guys were just begging for some simple animation!\n\nReal work was done by stb obviously.",
            "flags": 0,
            "hasliked": 0,
            "id": "dsKyDz",
            "likes": 19,
            "name": "random emotes animated",
            "published": 3,
            "tags": [
                "procedural",
                "random",
                "happy",
                "smiley",
                "sad",
                "emoji",
                "emote",
                "emotion",
                "emoticons",
                "smilies",
                "skeptical",
                "concerned",
                "suspicious"
            ],
            "usePreview": 0,
            "username": "misol101",
            "viewed": 530
        },
        "renderpass": [
            {
                "code": "/*\n    random emotes\n    2021 stb\n    \n    animation by misol101 2023\n*/\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n//#define MOD3 vec3(.1031, .11369, .13787) // int range\n#define MOD3 vec3(443.8975, 397.2973, 491.1871) // uv range\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n// circle inversion function\nvec2 cInv(vec2 p, vec2 o, float r) {\n    return (p-o) * r * r / dot(p-o, p-o) + o;\n}\n\n// a line of width w, warped by circle inversion, offset by o\nfloat arc(in vec2 p, float w, in vec2 o) {\n    p = cInv(p, vec2(0.), 1.);\n    p = cInv(p, vec2(0., o.y), 1.);\n    p.y -= o.y;\n\n    return  length(vec2(max(0., abs(p.x-o.x)-w), p.y));\n}\n\nfloat emote(vec2 p, vec2 h, float aa, float time, vec2 lk, bool eyeb) {\n    float f=1., eyes, eyebrows=-.065, mouth, head;\n    vec2 o = vec2(0., 1.);\n    \n    float blinktime = 0.45;\n    float blx = 1.0, bly = 1.0;\n    float blt = (mod(iTime,8.)-(h.x*h.y)*8.);\n    if (blt > 0. && blt < blinktime) {\n        bly = 1. + sin((blt/blinktime)*3.141)*1.5;\n        blx = 1. - sin((blt/blinktime)*3.141)*0.4;\n    }\n    \n    // get eyes\n    eyes = length(vec2((abs(p.x-lk.x)-.36)*blx+.25*pow(lk.x+h.x*0.15+0.3, 0.9+h.y), (p.y-.27-lk.y)*bly )) - (.15);\n    \n    // get eyebrows (symmetrical or not)\n    if(fract(3.447*h.x) < .5)\n        eyebrows += arc(vec2(abs(p.x-lk.x)-.35, p.y-lk.y-.5*fract(1.46*lk.y)-.35), .2, 2.*fract(h*2.31)*h.y*o-.5*o);\n    else\n        eyebrows +=\n            min(\n                arc(vec2(p.x-lk.x-.35, p.y-lk.y-.25*fract(2.31*lk.y)-.4), .2, 2.*fract(h*2.31)*h.y*o-.5*o),\n                arc(vec2(-p.x+lk.x-.35, p.y-lk.y-.25*fract(-1.81*lk.y)-.4), .2, 2.*fract(-h*1.92)*h.y*o-.5*o)\n            );\n    \n    // get mouth\n    mouth = arc(p+vec2(0., .35)-.5*lk, .4*pow(max(0.0,h.x+sin(time*h.y*1.0)+0.8), .5), vec2(.35, 1.)*(fract(2.772*h)-.5)) - .08;\n    if(fract(1.932*h.x) < .10) // some emotes are surprised\n        mouth = length(vec2(((p.x-lk.x)-.36+.25)*(1.0-h.y*0.2), (p.y+.27-lk.y)*1.1)) - (.2+sin(0.2+time*(2.0*h.x+h.y))*(0.005+(h.y)*0.08));\n    \n    // get head\n    head = (abs(length(p)-1.) - .075) ;\n    \n    // combine everything\n    f = min(f, eyes);\n    if(eyeb) // some emotes have eyebrows\n        f = min(f, eyebrows);\n    f = min(f, mouth);\n    f = min(f, head);\n    \n    // result\n    return smoothstep(-aa, aa, f);\n}\n\nvoid mainImage( out vec4 fo, in vec2 fc )\n{\n    vec2 res = iResolution.xy;\n    vec2 p   = (fc-res/2.) / res.y;\n    vec2 m   = (iMouse.xy-res/2.) / res.y;\n    \n    float zoom     = iMouse.x>0. ? .0125 + .5 * iMouse.y / res.y : .2;\n    \n    // zoom\n    p /= zoom;\n    \n    // scroll\n    p.y -= .15 * iTime;\n    \n    // one hash22 to rule them all\n    vec2 h = hash22(ceil(p)+.371);\n\n    float headSize = 1.4;// + sin(iTime*h.x*2.)*0.06;\n    float aa       = 2. / zoom / res.y * headSize;\n\n\n    float time = iTime * (0.8+(h.x*h.y)) * 1.0;\n    \n    // look variable (where the face is facing)\n    vec2 lk = (0.75+sin(time*(min(1.4,0.5+h.y*0.66+h.x*1.33)))*0.5) * (.5 * (h-.5));\n    \n    bool eyebrows = fract(4.932*h.x) < .65; // some emotes have eyebrows\n    if (!eyebrows) lk*=sin(iTime*h.x+h.y*4.); else if (sin(h.x*h.y) < 0.5) lk=-lk;\n\n    p -= lk*0.1;\n\n    // get emote\n    float f = emote((headSize)*(fract(p)*2.-1.), h, aa, time, lk, eyebrows);\n    \n    // set initial color to black/white emote\n    vec3 col = vec3(f);\n    \n    // apply circles of color\n    if(length(fract(p)-.5) < .5/headSize) {\n        col *= 1.*fract(vec3(pow(h.x, .15), pow(fract(1.314*h.y), .15), fract(1.823*h.y)));\n        col *= pow(clamp(2.0*(.75-length(fract(p)-vec2(0.5, 0.6)*1.0)), 0.0, 1.15),1.3);\n    } else {\n        col *= 1.1 * mix( vec3(1.0,0.8,0.3), vec3(0.58, 0.99, 0.99), sqrt((fc/iResolution.y).y) );\n    }\n\n    // output\n    fo = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}