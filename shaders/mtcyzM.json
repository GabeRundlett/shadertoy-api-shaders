{
    "Shader": {
        "info": {
            "date": "1698997858",
            "description": "Use it as a funny mirror.\n\nFeel free to replace the texture in Channel1 to any other texture or video or webcam!",
            "flags": 34,
            "hasliked": 0,
            "id": "mtcyzM",
            "likes": 6,
            "name": "False Mirror Distortions Imp",
            "published": 3,
            "tags": [
                "2d",
                "fractal",
                "distortion"
            ],
            "usePreview": 0,
            "username": "ersh",
            "viewed": 500
        },
        "renderpass": [
            {
                "code": "// Liquid curved mirror - Improved.\n// Feel free to replace the texture in Channel1 to any other texture or video or webcam!\n\n\n// Amount of distortion\n#define SCALE 1.\n\n// Check out settings on the \"Buffer A\" tab.\n\n//// What to do on the border: one of {\n//#define TRANSFORM      NONE\n//#define TRANSFORM      LOOP\n//#define TRANSFORM      MIRROR\n#define TRANSFORM      MIRRORX\n//// }\n\nvec4 T(ivec2 x) { return texelFetch(iChannel0, x, 0); }\n\nvec4 T2(vec2 x) {\n#define NONE(X)           X\n#define LOOP(X)           fract(X)\n#define MIRROR(X)         abs((mod(X + 1., 2.)) - 1.)\n#define MIRRORX(X)         vec2(abs((mod(X.x, 2.)) - 1.), abs((mod(X.y + 1., 2.)) - 1.))\n  return texture(iChannel1, TRANSFORM(x), 0.);\n}\n\n//#define XYSQ   vec2(1., iResolution.x / iResolution.y)\n\n#define XYSQ   (iResolution.x > iResolution.y ? \\\n                vec2(1., iResolution.x / iResolution.y) : \\\n                vec2(1., iResolution.x*iResolution.x / iResolution.y/iResolution.y)) \\\n// EOM\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 v = T(ivec2(fragCoord)).xyz;\n    vec2 sh = v.xy * min(iResolution.x, iResolution.y) / 4000. * SCALE * XYSQ;\n    float scos = cos(v.z*4.), ssin = sin(v.z*4.);\n    sh = vec2(\n        sh.x * scos + sh.y * ssin,\n      - sh.x * ssin + sh.y * scos);\n    fragColor = vec4(\n        T2(uv + sh).rgb,\n        1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define SPEED           1.     /* 0 ... max */\n#define SMOOTH          1      /* 0 or 1 */\n#define SMOOTHNESS      0.48   /* 0: smooth ... 0.5: step */\n#define DISPERSE_TIERS  1      /* 0 or 1 */\n#define WAVE            0      /* 0 or 1 */\n\n\nint imod(int a, int b) { return a % b; }\nint iabs(int x) { return x >= 0 ? x : -x; }\nint isign(int x) { return x >= 0 ? 1 : -1; }\nint maxx;\nvec4 T(ivec2 x) {\n  return\n      x.x < 0 ? texelFetch(iChannel0, ivec2(0, x.y), 0) - texelFetch(iChannel0, ivec2(-x.x, x.y), 0) :\n      x.x > maxx ? texelFetch(iChannel0, ivec2(maxx, x.y), 0) - texelFetch(iChannel0, ivec2(maxx-x.x, x.y), 0) :\n      texelFetch(iChannel0, x, 0);\n\n#define FETCH(X)               texelFetch(iChannel0, X, 0)\n#define SAW(X, MAXX)           ivec2(iabs((imod(X.x + MAXX, MAXX * 2)) - MAXX), X.y)\n#define SGN(X, MAXX)           float(-isign(imod(X.x, MAXX * 2) - MAXX))\n#define MIRROR(FN, X, MAXX)    (FN(SAW(X, MAXX)) * SGN(X, MAXX))\n  // return MIRROR(FETCH, x, maxx);\n}\n\nint tier_n(int x) {\n  if ((x & 0xffff) == 0) { return 16; }\n  int ret = 0;\n  if ((x & 0xff) == 0) { ret += 8; x >>= 8; }\n  if ((x & 0x0f) == 0) { ret += 4; x >>= 4; }\n  if ((x & 3) == 0) { ret += 2; x >>= 2; }\n  if ((x & 1) == 0) { ret += 1; }\n  return ret;\n}\n\nint tier_s(int x) {\n  if ((x & 0xffff) == 0) { return 0x10000; }\n  int ret = 1;\n  if ((x & 0xff) == 0) { ret <<= 8; x >>= 8; }\n  if ((x & 0x0f) == 0) { ret <<= 4; x >>= 4; }\n  if ((x & 3) == 0) { ret <<= 2; x >>= 2; }\n  if ((x & 1) == 0) { ret <<= 1; }\n  return ret;\n}\n\nint pow2ceil(int x) {\n  x |= x >> 1;\n  x |= x >> 2;\n  x |= x >> 4;\n  x |= x >> 8;\n  x |= x >> 16;\n  return x+1;\n}\n\nfloat pow_of_2_adj(vec2 iResolution) {\n  return  1.5 / pow(3., ceil(log(min(iResolution.x,iResolution.y)+1.)/log(2.)) - 5.);\n}\n\nivec2 iResolution_i;\nivec2 tier2(ivec2 v) {\n  return ivec2(\n        tier_n(v.x - iResolution_i.x/2),\n        tier_n(v.y - iResolution_i.y/2));\n}\n\nivec2 tier2_s(ivec2 v) {\n  return ivec2(\n        tier_s(v.x - iResolution_i.x/2),\n        tier_s(v.y - iResolution_i.y/2));\n}\n\n#define min4(x1, x2, x3, x4)                  min(min(x1,x2),min(x3,x4))\n#define min8(x1, x2, x3, x4, x5, x6, x7, x8)  min(min4(x1, x2, x3, x4),min4(x5, x6, x7, x8))\n\nvec4 a_mesh8(ivec2 pt1, ivec2 st) {\n  return\n        (T(pt1.xy + ivec2( st.x,  0.)) +\n         T(pt1.xy + ivec2(-st.x,  0.)) +\n         T(pt1.xy + ivec2( 0.,  st.y)) +\n         T(pt1.xy + ivec2( 0., -st.y)) +\n         T(pt1.xy + ivec2( st.x,  st.y)) +\n         T(pt1.xy + ivec2( st.x, -st.y)) +\n         T(pt1.xy + ivec2(-st.x,  st.y)) +\n         T(pt1.xy + ivec2(-st.x, -st.y))) / 8.;\n}\n\nvec4 a_mesh4(ivec2 pt1, ivec2 st) {\n  return\n        (T(pt1.xy + ivec2( st.x,  0.)) +\n         T(pt1.xy + ivec2(-st.x,  0.)) +\n         T(pt1.xy + ivec2( 0.,  st.y)) +\n         T(pt1.xy + ivec2( 0., -st.y))) / 4.;\n}\n\nvec4 a_mesh_h(ivec2 pt1, ivec2 st) {\n  return\n       (T(pt1.xy + ivec2( st.x,  0.)) +\n        T(pt1.xy + ivec2(-st.x,  0.))) / 2.;\n}\n\nvec4 a_mesh_v(ivec2 pt1, ivec2 st) {\n  return\n       (T(pt1.xy + ivec2( 0.,  st.y)) +\n        T(pt1.xy + ivec2( 0., -st.y))) / 2.;\n}\n\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rand(ivec2 nx, int t, float tm)\n{\n    vec2 p = (vec2(nx) + mod(tm, 200.) * 1501. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    float sh =\n#if WAVE\n        sin(float(t + nx*5) + iTime/2.) / float(t+1) / iResolution.x * iResolution.y;\n#else\n        0.;\n#endif\n    return (fract((p3.x + p3.y) * p3.z) - 0.5 + sh) / 2. / iResolution.x * iResolution.y;\n}\n\n#if SMOOTH\n#define SMOOTH_TIME  fract(tm)\n#else\n#define SMOOTH_TIME  0.\n#endif\n\nfloat randt(ivec2 nx, int t, float y) {\n#if DISPERSE_TIERS\n    float tm = ((100. + iTime*SPEED + y*33.33) + float(nx.x)/100.) / float(t+1);\n#else\n    float tm = (100. + iTime*SPEED);\n#endif\n    float tt = floor(tm), tf = SMOOTH_TIME;\n    return mix(rand(nx, t, tt), rand(nx, t, tt+1.), smoothstep(SMOOTHNESS, 1.-SMOOTHNESS, tf));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 fragCoord_i = ivec2(fragCoord);\n    ivec2 iResolution_i = ivec2(iResolution);\n    maxx = iResolution_i.x;\n\n    if (fragCoord_i == ivec2(0)/*iResolution_i/2*/) {\n        fragColor.r =\n            0.;\n            //randt(fragCoord_i, tier_n(pow2ceil(iResolution_i.x)), fragCoord.y);\n        return;\n    }\n\n    ivec2 pow2_mid_adj = ivec2(\n        (pow2ceil(iResolution_i.x) - iResolution_i.x) >> 1,\n        (pow2ceil(iResolution_i.y) - iResolution_i.y) >> 1);\n    ivec2 tier = ivec2(\n        tier_n(fragCoord_i.x + pow2_mid_adj.x),\n        tier_n(fragCoord_i.y + pow2_mid_adj.y));\n    ivec2 st = ivec2(1) << tier;\n\n    vec4 avg;\n    int ist;\n    if (st.x < st.y) {\n        st.y = 0; ist = st.x;\n        avg = a_mesh_h(fragCoord_i, st);\n    } else if (st.y < st.x) {\n        st.x = 0; ist = st.y;\n        avg = a_mesh_v(fragCoord_i, st);\n    } else {\n        ist = st.x;\n        avg = a_mesh4(fragCoord_i, st);\n    }\n\n    fragColor.rgb =\n        avg.rgb + vec3(\n            randt(fragCoord_i, min(tier.x, tier.y), fragCoord.y    ) * float(ist) * pow_of_2_adj(iResolution.xy),\n            randt(fragCoord_i, min(tier.x, tier.y), fragCoord.y+0.3) * float(ist) * pow_of_2_adj(iResolution.xy),\n            randt(fragCoord_i, min(tier.x, tier.y), fragCoord.y+0.6) * float(ist) * pow_of_2_adj(iResolution.xy)\n        );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}