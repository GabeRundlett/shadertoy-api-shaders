{
    "Shader": {
        "info": {
            "date": "1592052399",
            "description": "License CC0: Alien Waterworld\n  Been working on space themed shaders\n  Code \"borrowed\" from the usual suspects\n",
            "flags": 0,
            "hasliked": 0,
            "id": "WtXyW4",
            "likes": 40,
            "name": "Alien Waterworld",
            "published": 3,
            "tags": [
                "terrainscifi"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 1425
        },
        "renderpass": [
            {
                "code": "// License CC0: Alien Waterworld\n//  Been working on space themed shaders\n//  Code \"borrowed\" from the usual suspects\n    \n#define PI  3.141592654\n#define TAU (2.0*PI)\n\n#define TOLERANCE       0.00001\n#define MAX_ITER        55\n#define MAX_DISTANCE    31.0\n#define PERIOD          45.0\n#define TIME            mod(iTime, PERIOD)\n\nconst vec3  skyCol1       = vec3(0.35, 0.45, 0.6);\nconst vec3  skyCol2       = skyCol1*skyCol1*skyCol1*3.0;\nconst vec3  sunCol1       = vec3(1.0,0.9,0.8);\nconst vec3  sunCol2       = vec3(1.0,0.9,0.8);\nconst vec3  smallSunCol1  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  smallSunCol2  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  ringColor     = sqrt(vec3(0.95, 0.65, 0.45));\nconst vec4  planet        = vec4(80.0, -20.0, 100.0, 50.0)*1000.0;\nconst vec3  planetCol     = sqrt(vec3(0.9, 0.8, 0.7));\nconst vec3  ringsNormal   = normalize(vec3(1.0, 1.25, 0.0));\nconst vec4  rings         = vec4(ringsNormal, -dot(ringsNormal, planet.xyz));\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(p.x*c + p.y*s, -p.x*s + p.y*c);\n}\n\nfloat psin(float f) {\n  return 0.5 + 0.5*sin(f);\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sphere)\n{\n  vec3 ce = sphere.xyz;\n  float ra = sphere.w;\n  vec3 oc = ro - ce;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - ra*ra;\n  float h = b*b - c;\n  if( h<0.0 ) return vec2(-1.0); // no intersection\n  h = sqrt( h );\n  return vec2( -b-h, -b+h );\n}\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n\nfloat noise2(vec2 x) {\n  vec2 i = floor(x);\n  vec2 w = fract(x);\n    \n#if 1\n  // quintic interpolation\n  vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n#else\n  // cubic interpolation\n  vec2 u = w*w*(3.0-2.0*w);\n#endif    \n\n  float a = hash(i+vec2(0.0,0.0));\n  float b = hash(i+vec2(1.0,0.0));\n  float c = hash(i+vec2(0.0,1.0));\n  float d = hash(i+vec2(1.0,1.0));\n    \n  float k0 =   a;\n  float k1 =   b - a;\n  float k2 =   c - a;\n  float k3 =   d - c + a - b;\n\n  return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;\n}\n\nfloat smoother(float d, float s) {\n  return s*tanh(d/s);\n}\n\nfloat heightMod(vec2 p) {\n  vec2 pp = toPolar(p);\n  pp.y += -pp.x*0.2;\n  p = toRect(pp);\n  return pow((psin(1.0*p.x)*psin(1.0*p.y)), max(0.25, pp.x*0.20))*0.8;\n}\n\nfloat loheight(vec2 p, float d) {\n  const float aa   = 0.5;\n  const float ff   = 2.03;\n  const float tt   = 1.3;\n  const float oo   = 0.93;\n  \n  float hm = heightMod(p);\n  \n  vec2 s = vec2(0.0);\n  float a = 1.0;\n  float o = 0.2;\n  \n  for (int i = 0; i < 3; ++i) {\n    float nn = a*(noise2(2.0*p));\n    s.x += nn;\n    s.y += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  s.x /= s.y;\n  s.x -= 1.0;\n  s.x += 0.7*hm;\n  s.x = smoother(s.x, 0.125);\n  \n  return max(s.x+0.125, 0.0)*0.5;\n}\n\nfloat height(vec2 p, float d) {\n  const float aa   = 0.5;\n  const float ff   = 2.03;\n  const float tt   = 1.3;\n  const float oo   = 0.93;\n  \n  float hm = heightMod(p);\n  \n  vec2 s = vec2(0.0);\n  float a = 1.0;\n  float o = 0.2;\n  \n  for (int i = 0; i < 5; ++i) {\n    float nn = a*(noise2(2.0*p));\n    s.x += nn;\n    s.y += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  s.x /= s.y;\n  s.x -= 1.0;\n  s.x += 0.7*hm;\n  s.x = smoother(s.x, 0.125);\n  \n  return max(s.x+0.125, 0.0)*0.5;\n}\n\nfloat hiheight(vec2 p, float d) {\n  const float aa   = 0.5;\n  const float ff   = 2.03;\n  const float tt   = 1.3;\n  const float oo   = 0.93;\n  \n  float hm = heightMod(p);\n  \n  vec2 s = vec2(0.0);\n  float a = 1.0;\n  float o = 0.2;\n  \n  for (int i = 0; i < 6; ++i) {\n    float nn = a*(noise2(2.0*p));\n    s.x += nn;\n    s.y += abs(a);\n    p += o;\n    a *= aa;\n    p *= ff;\n    o *= oo;\n    rot(p, tt);\n  }\n\n  s.x /= s.y;\n  s.x -= 1.0;\n  s.x += 0.7*hm;\n  s.x = smoother(s.x, 0.125);\n  \n  return max(s.x+0.125, 0.0)*0.5;\n}\n  \nvec3 normal(vec2 p, float d) {\n  vec2 eps = vec2(0.000125, 0.0);\n  \n  vec3 n;\n  \n  n.x = (hiheight(p - eps.xy, d) - hiheight(p + eps.xy, d));\n  n.y = 2.0*eps.x;\n  n.z = (hiheight(p - eps.yx, d) - hiheight(p + eps.yx, d));\n  \n  return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd, float id, out int max_iter) {\n  float dt = 0.1;\n  float d = id;\n  int currentStep = 0;\n  float lastd = d;\n  for (int i = 0; i < MAX_ITER; ++i) {\n    vec3 p = ro + d*rd;\n    float h = height(p.xz, d);\n    \n    if (d > MAX_DISTANCE) {\n      max_iter = i;\n      return MAX_DISTANCE;\n    }\n\n    float hd = p.y - h;\n\n    if (hd < TOLERANCE) {\n      return d;\n    }\n\n    float sl = 0.9;\n\n    dt = max(hd*sl, TOLERANCE+0.0005*d);\n    lastd = d;\n    d += dt;\n  }\n  \n  max_iter = MAX_ITER;\n  return MAX_DISTANCE;\n}\n\nvec3 sunDirection() {\n  return normalize(vec3(-0.5, 0.2, 1.0));\n}\n\nvec3 smallSunDirection() {\n  return normalize(vec3(-0.2, -0.05, 1.0));\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 sunDir = sunDirection();\n  vec3 smallSunDir = smallSunDirection();\n\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  float smallSunDot = max(dot(rd, smallSunDir), 0.0);\n  \n  float angle = atan(rd.y, length(rd.xz))*2.0/PI;\n\n  vec3 sunCol = 0.5*sunCol1*pow(sunDot, 20.0) + 8.0*sunCol2*pow(sunDot, 2000.0);\n  vec3 smallSunCol = 0.5*smallSunCol1*pow(smallSunDot, 200.0) + 8.0*smallSunCol2*pow(smallSunDot, 20000.0);\n\n\n  vec2 si = raySphere(ro, rd, planet);\n  float pi = rayPlane(ro, rd, rings);\n  \n  float dustTransparency = smoothstep(-0.15, 0.075, rd.y);\n\n  vec3 skyCol = mix(skyCol1, skyCol2, sqrt(dustTransparency));\n  skyCol *= (1.0-dustTransparency);\n  \n  \n  vec3 planetSurface = ro + si.x*rd;\n  vec3 planetNormal = normalize(planetSurface - planet.xyz);\n  float planetDiff = max(dot(planetNormal, sunDir), 0.0);\n  float planetBorder = max(dot(planetNormal, -rd), 0.0);\n  float planetLat = (planetSurface.x+planetSurface.y)*0.0005;\n  vec3 planetCol = mix(1.3*planetCol, 0.3*planetCol, pow(psin(planetLat+1.0)*psin(sqrt(2.0)*planetLat+2.0)*psin(sqrt(3.5)*planetLat+3.0), 0.5));\n\n  vec3 ringsSurface = ro + pi*rd;\n\n  float borderTransparency = smoothstep(0.0, 0.1, planetBorder);\n  \n  float ringsDist = length(ringsSurface - planet.xyz)*1.0;\n  float ringsPeriod = ringsDist*0.001;\n  const float ringsMax = 150000.0*0.655;\n  const float ringsMin = 100000.0*0.666;\n  float ringsMul = pow(psin(ringsPeriod+1.0)*psin(sqrt(0.5)*ringsPeriod+2.0)*psin(sqrt(0.45)*ringsPeriod+4.0)*psin(sqrt(0.35)*ringsPeriod+5.0), 0.25);\n  float ringsMix = psin(ringsPeriod*10.0)*psin(ringsPeriod*10.0*sqrt(2.0))*(1.0 - smoothstep(50000.0, 200000.0, pi));\n\n  vec3 ringsCol = mix(vec3(0.125), 0.75*ringColor, ringsMix)*step(-pi, 0.0)*step(ringsDist, ringsMax)*step(-ringsDist, -ringsMin)*ringsMul;\n  \n  vec3 final = vec3(0.0);\n    \n  final += ringsCol*(step(pi, si.x) + step(si.x, 0.0));\n  \n  final += step(0.0, si.x)*pow(planetDiff, 0.75)*mix(planetCol, ringsCol, 0.0)*dustTransparency*borderTransparency + ringsCol*(1.0 - borderTransparency);\n\n  final += skyCol + sunCol + smallSunCol;\n\n  return final;\n}\n\nvec3 shipColor(vec2 p) {\n  vec2 pp = toPolar(p);\n  pp.y += pp.x*0.05;\n  p = toRect(pp);\n\n  float n = mod1(p.x, 0.15);\n  p.y += 3.0-TIME*0.5+0.05*abs(n*n);\n\n  float td = abs(p.x) - (0.005-p.y*0.002);\n  td = abs(td) - (0.02*pow(-p.y, 0.25));\n  float sd = circle(p, 0.05);\n  \n  vec3 trailCol = vec3(0.5)*smoothstep(-5.0, 0.0, p.y)*step(p.y, 0.0)*smoothstep(0.0, 0.025, -td);\n  vec3 shipCol = vec3(0.5+smoothstep(-1.0, 1.0, sin(TIME*15.0*TAU+n)))*smoothstep(0.0, 0.075, -sd);\n  \n  vec3 col = trailCol;\n  col += shipCol;\n\n  float sm = step(abs(n), 2.0);\n  \n  return col*sm;\n}\n\nvec3 getColor(vec3 ro, vec3 rd) {\n  int max_iter = 0;\n  vec3 skyCol = skyColor(ro, rd);\n  vec3 col = vec3(0);\n  \n  const float shipHeight = 1.0;\n  const float seaHeight = 0.0;\n  const float cloudHeight = 0.2;\n  const float upperCloudHeight = 0.5;\n  \n  float id = (cloudHeight - ro.y)/rd.y;\n  \n  if (id > 0.0) {\n    float d = march(ro, rd, id, max_iter);\n    vec3 sunDir = sunDirection();\n    vec3 osunDir = sunDir*vec3(-1.0, 1.0, -1.0);\n    vec3 p = ro + d*rd;\n\n    float loh = loheight(p.xz, d);\n    float loh2 = loheight(p.xz+sunDir.xz*0.05, d);\n    float hih = hiheight(p.xz, d);\n    vec3 normal = normal(p.xz, d);\n\n    float ud = (upperCloudHeight - 4.0*loh - ro.y)/rd.y;\n    \n    float sd = (seaHeight - ro.y)/rd.y;\n    vec3 sp = ro + sd*rd;\n    float scd = (cloudHeight - sp.y)/sunDir.y;\n    vec3 scp = sp + sunDir*scd;\n    \n    float sloh = loheight(scp.xz, d);\n    float cshd = exp(-15.0*sloh);\n\n    float amb = 0.3;\n \n    vec3 seaNormal = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 seaRef = reflect(rd, seaNormal);    \n    vec3 seaCol = .25*skyColor(p, seaRef);\n    seaCol += pow(max(dot(seaNormal, sunDir), 0.0), 2.0); \n    seaCol *= cshd;\n    seaCol += 0.075*pow(vec3(0.1, 1.3, 4.0), vec3(max(dot(seaNormal, seaRef), 0.0)));\n\n    float spe = pow(max(dot(sunDir, reflect(rd, normal)), 0.0), 3.0);\n    float fre = pow(1.0-dot(normal, -rd), 2.0);\n\n    col = seaCol;\n\n    \n    const float level = 0.00;\n    const float level2 = 0.3;\n    // REALLY fake shadows and lighting\n    vec3 scol = sunCol1*(smoothstep(level, level2, hih) - smoothstep(level, level2, loh2));\n    col = mix(vec3(1.0), col, exp(-17.0*(hih-0.25*loh)));\n    col = mix(vec3(.75), col, exp(-10.0*loh*(max(d-ud, 0.0))));\n    col += scol;\n      \n    col += vec3(0.5)*spe*fre;    \n    \n    float ssd = (shipHeight - ro.y)/rd.y;\n\n    col += shipColor((ro + rd*ssd).xz);\n\n    col = mix(col, skyCol, smoothstep(0.5*MAX_DISTANCE, 1.*MAX_DISTANCE, d));\n    \n  } else {\n    col = skyCol;\n  }\n\n//  col += vec3(1.1, 0.0, 0.0)* smoothstep(0.25, 1.0,(float(max_iter)/float(MAX_ITER)));\n  return col;\n}\n\nvec3 postProcess(in vec3 col, in vec2 q) \n{\n  //col = saturate(col);\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 getSample1(vec2 p, float time) {\n  vec3 ro  = vec3(0.5, 5.5, -2.0);\n  vec3 la  = ro + vec3(0.0, -1.+0.9*TIME/PERIOD,  1.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww, uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n\n  vec3 col = getColor(ro, rd)  ;\n \n  return col;\n  \n}\n\nvec3 getSample2(vec2 p, float time) {\n  p.y-=time*0.25;\n  float h = height(p, 0.0);\n  vec3 n = normal(p, 0.0);\n  \n  vec3 lp = vec3(10.0, -1.2, 0.0);\n  \n  vec3 ld = normalize(vec3(p.x, h, p.y)- lp);\n  \n  float d = max(dot(ld, n), 0.0);\n  \n  vec3 col = vec3(0.0);\n\n  col = vec3(1.0)*(h+0.1);\n  col += vec3(1.5)*pow(d, 0.75);\n \n  return col;\n  \n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord.xy/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n  \n  vec3 col = getSample1(p, TIME);\n  \n  col = postProcess(col, q);\n  \n  col *= smoothstep(0.0, 2.0, TIME);\n  col *= 1.0-smoothstep(PERIOD-2.0, PERIOD, TIME);\n  \n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}