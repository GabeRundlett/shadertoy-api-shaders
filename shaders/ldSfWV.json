{
    "Shader": {
        "info": {
            "date": "1502213368",
            "description": "Enable POINTS or Decrease NBITERATIONS for slow GPUs\n\nJoin the [url=https://www.facebook.com/groups/147749602472741]FB Shadertoy Group[/url] !",
            "flags": 40,
            "hasliked": 0,
            "id": "ldSfWV",
            "likes": 91,
            "name": "OscilloStereoXY Trippy Donut ",
            "published": 3,
            "tags": [
                "oscilloscope",
                "sound",
                "torus",
                "music",
                "stereo",
                "lissajou"
            ],
            "usePreview": 0,
            "username": "ttoinou",
            "viewed": 5067
        },
        "renderpass": [
            {
                "code": "\n\nvec3 sampleBuff(vec2 uv)\n{\n    return texture( iChannel0, uv ).xyz;// + vec3(.1); \n}\n\nvec3 sampleBuff(float u,float v)\n{\n    return sampleBuff( vec2(u,v) ); \n}\n\n// https://www.shadertoy.com/view/Ms23DR\n// Loosely based on postprocessing shader by inigo quilez, License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec2 curve(vec2 uv)\n{\n    return uv;\n\t/*uv = (uv - 0.5) * 2.0;\n\tuv *= 1.1;\t\n\tuv.x *= 1.0 + pow((abs(uv.y) / 5.0), 2.0);\n\tuv.y *= 1.0 + pow((abs(uv.x) / 4.0), 2.0);\n\tuv  = (uv / 2.0) + 0.5;\n\tuv =  uv *0.92 + 0.04;\n\treturn uv;*/\n}\n\nvec4 crtBuffA( vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy;// / iResolution.xy;\n    vec2 uv = q;\n    uv = curve( uv );\n    vec3 oricol = sampleBuff(q.x,q.y);\n    vec3 col;\n\tfloat x =  sin(0.3*iTime+uv.y*21.0)*sin(0.7*iTime+uv.y*29.0)*sin(0.3+0.33*iTime+uv.y*31.0)*0.0017;\n\n    col.r = sampleBuff(x+uv.x+0.001,uv.y+0.001).x+0.05;\n    col.g = sampleBuff(x+uv.x+0.000,uv.y-0.002).y+0.05;\n    col.b = sampleBuff(x+uv.x-0.002,uv.y+0.000).z+0.05;\n    col.r += 0.08*sampleBuff(0.75*vec2(x+0.025, -0.027)+vec2(uv.x+0.001,uv.y+0.001)).x;\n    col.g += 0.05*sampleBuff(0.75*vec2(x+-0.022, -0.02)+vec2(uv.x+0.000,uv.y-0.002)).y;\n    col.b += 0.08*sampleBuff(0.75*vec2(x+-0.02, -0.018)+vec2(uv.x-0.002,uv.y+0.000)).z;\n\n    col = clamp(col*0.6+0.4*col*col*1.0,0.0,1.0);\n\n    float vig = (0.0 + 1.0*16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y));\n\tcol *= vec3(pow(vig,0.3));\n\n    col *= vec3(0.95,1.05,0.95);\n\tcol *= 2.8;\n\n\tfloat scans = clamp( 0.35+0.35*sin(4.*iTime+uv.y*iResolution.y*1.), 0.0, 1.0);\n\t\n\tfloat s = pow(scans,1.7);\n\tcol = col*vec3( 0.4+0.7*s) ;\n\n    col *= 1.0+0.01*sin(50.0*iTime);\n\tif (uv.x < 0.0 || uv.x > 1.0)\n\t\tcol *= 0.0;\n\tif (uv.y < 0.0 || uv.y > 1.0)\n\t\tcol *= 0.0;\n\t\n\tcol*=1.0-0.65*vec3(clamp((mod(fragCoord.x, 2.0)-1.0)*2.0,0.0,1.0));\n\t\n    \n    \n    \n    \n    // from https://www.shadertoy.com/view/XsjSzc\n    q = uv;\n\n    float grid = 1.0;\n    grid *= 1.0-smoothstep( 0.98, 0.99, 2.0*abs(fract( q.x*10.0 )-0.5) );\n    grid *= 1.0-smoothstep( 0.96, 0.98, 2.0*abs(fract( q.y*6.0 )-0.5) );\n    grid *= 1.0-smoothstep( 0.90, 0.92, 2.0*abs(fract( q.x*50.0 )-0.5) )*\n                smoothstep( 0.84, 0.85, 2.0*abs(fract( q.y* 6.0 )-0.5) );\n    grid *= 1.0-smoothstep( 0.91, 0.92, 2.0*abs(fract( q.y*30.0 )-0.5) )*\n                smoothstep( 0.85, 0.86, 2.0*abs(fract( q.x*10.0 )-0.5) );\n    col *= 0.5 + 0.5*grid;\n    \n\n    return vec4(col,1.0);\n    \n}\n\n// https://www.shadertoy.com/view/lt2SDK\n// ------------------------------------\n//#define MOUSE_CURVE\n//#define MOUSE_MOVE\n\n#define MAIN_BLOOM_ITERATIONS 10\n#define MAIN_BLOOM_SIZE 0.01\n\n#define REFLECTION_BLUR_ITERATIONS 10\n#define REFLECTION_BLUR_SIZE 0.05\n\n#define WIDTH 0.48\n#define HEIGHT 0.3\n#define CURVE 3.0\n\n#define BEZEL_COL vec4(0.8, 0.8, 0.6, 0.0)\n#define PHOSPHOR_COL vec4(1.)\n#define AMBIENT 0.2\n\n#define NO_OF_LINES iResolution.y*HEIGHT\n#define SMOOTH 0.004\n\n// using normal vectors of a sphere with radius r\nvec2 crtCurve(vec2 uv, float r) \n{\n        uv = (uv - 0.5) * 2.0;// uv is now -1 to 1\n    \tuv = r*uv/sqrt(r*r -dot(uv, uv));\n        uv = (uv / 2.0) + 0.5;// back to 0-1 coords\n        return uv;\n}\n\nfloat roundSquare(vec2 p, vec2 b, float r)\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Calculate normal to distance function and move along\n// normal with distance to get point of reflection\nvec2 borderReflect(vec2 p, float r)\n{\n    float eps = 0.0001;\n    vec2 epsx = vec2(eps,0.0);\n    vec2 epsy = vec2(0.0,eps);\n    vec2 b = (1.+vec2(r,r))* 0.5;\n    r /= 3.0;\n    \n    p -= 0.5;\n    vec2 normal = vec2(roundSquare(p-epsx,b,r)-roundSquare(p+epsx,b,r),\n                       roundSquare(p-epsy,b,r)-roundSquare(p+epsy,b,r))/eps;\n    float d = roundSquare(p, b, r);\n    p += 0.5;\n    return p + d*normal;\n}\n\n// Some Plasma stolen from dogeshibu for testing\nvec4 somePlasma(vec2 uv)\n{\n    if(uv.x < 0.0 || uv.x > 1.0 ||  uv.y < 0.0 || uv.y > 1.0) return vec4(0.0);\n    //return vec4(.5);\n    \n    return crtBuffA(uv)*.8;\n    /*\n    float scln = 0.5 - 0.5*cos(uv.y*3.14*NO_OF_LINES); // scanlines\n    uv *= vec2(80, 24); // 80 by 24 characters\n    uv = ceil(uv);\n    uv /= vec2(80, 24);\n    \n    float color = 0.0;\n    color += 0.7*sin(0.5*uv.x + iTime/5.0);\n    color += 3.0*sin(1.6*uv.y + iTime/5.0);\n    color += 1.0*sin(10.0*(uv.y * sin(iTime/2.0) + uv.x * cos(iTime/5.0)) + iTime/2.0);\n    float cx = uv.x + 0.5*sin(iTime/2.0);\n    float cy = uv.y + 0.5*cos(iTime/4.0);\n    color += 0.4*sin(sqrt(100.0*cx*cx + 100.0*cy*cy + 1.0) + iTime);\n    color += 0.9*sin(sqrt(75.0*cx*cx + 25.0*cy*cy + 1.0) + iTime);\n    color += -1.4*sin(sqrt(256.0*cx*cx + 25.0*cy*cy + 1.0) + iTime);\n    color += 0.3 * sin(0.5*uv.y + uv.x + sin(iTime));\n    return scln*floor(3.0*(0.5+0.499*sin(color)))/3.0; // vt220 has 2 intensitiy levels*/\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\t// aspect-ratio correction\n\tvec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\tuv = 0.5 + (uv -0.5)/ aspect.yx;\n    \n#ifdef MOUSE_CURVE\n    float r = 1.5*exp(1.0-iMouse.y/iResolution.y);\n#else\n    float r = CURVE;\n#endif\n        \n    // Screen Layer\n    vec2 uvS = crtCurve(uv, r);\n#ifdef MOUSE_MOVE\n    uvS.x -= iMouse.x/iResolution.x - 0.5;\n#endif\n\n    // Screen Content\n    vec2 uvC = (uvS - 0.5)* 2.; // screen content coordinate system\n    uvC *= vec2(0.5/WIDTH, 0.5/HEIGHT);\n    uvC = (uvC / 2.0) + 0.5;\n    \n    c += PHOSPHOR_COL * somePlasma(uvC);\n    //c = crtBuffA(uvC);\n    \n    // Simple Bloom\n    /*float B = float(MAIN_BLOOM_ITERATIONS*MAIN_BLOOM_ITERATIONS);\n    for(int i=0; i<MAIN_BLOOM_ITERATIONS; i++)\n    {\n        float dx = float(i-MAIN_BLOOM_ITERATIONS/2)*MAIN_BLOOM_SIZE;\n        for(int j=0; j<MAIN_BLOOM_ITERATIONS; j++)\n        {\n            float dy = float(j-MAIN_BLOOM_ITERATIONS/2)*MAIN_BLOOM_SIZE;\n            c += PHOSPHOR_COL * somePlasma(uvC + vec2(dx, dy))/B;\n        }\n    }*/           \n    \n    // Ambient\n    c += max(0.0, AMBIENT - 0.3*distance(uvS, vec2(0.5,0.5))) *\n        smoothstep(SMOOTH, -SMOOTH, roundSquare(uvS-0.5, vec2(WIDTH, HEIGHT), 0.05));\n  \n\n    // Enclosure Layer\n    vec2 uvE = crtCurve(uv, r+0.25);\n#ifdef MOUSE_MOVE\n    uvE.x -= iMouse.x/iResolution.x - 0.5;\n#endif\n    \n    // Inner Border\n    for( int i=0; i<REFLECTION_BLUR_ITERATIONS; i++)\n    {\n    \tvec2 uvR = borderReflect(uvC + (vec2(rand(uvC+float(i)), rand(uvC+float(i)+0.1))-0.5)*REFLECTION_BLUR_SIZE, 0.05) ;\n    \tc += (PHOSPHOR_COL - BEZEL_COL*AMBIENT) * somePlasma(uvR) / float(REFLECTION_BLUR_ITERATIONS) * \n\t        smoothstep(-SMOOTH, SMOOTH, roundSquare(uvS-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT), 0.05)) * \n\t\t\tsmoothstep(SMOOTH, -SMOOTH, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.05, 0.05));\n    }\n               \n  \tc += BEZEL_COL * AMBIENT * 0.7 *\n        smoothstep(-SMOOTH, SMOOTH, roundSquare(uvS-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT), 0.05)) * \n        smoothstep(SMOOTH, -SMOOTH, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.05, 0.05));\n    \n    // Corner\n  \tc -= (BEZEL_COL )* \n        smoothstep(-SMOOTH*2.0, SMOOTH*10.0, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.05, 0.05)) * \n        smoothstep(SMOOTH*2.0, -SMOOTH*2.0, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.05, 0.05));\n\n    // Outer Border\n    c += BEZEL_COL * AMBIENT *\n       \tsmoothstep(-SMOOTH, SMOOTH, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.05, 0.05)) * \n        smoothstep(SMOOTH, -SMOOTH, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.15, 0.05)); \n\n\n    fragColor = c;\n}\n\n/*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = crtBuffA(fragColor,fragCoord);\n}*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// copy paste this into sound and remove the next define\n//#define SOUNDBUFFER\n//#define POINTS\n#define NBITERATIONS 300 // 1000 if you have a good GPU\n#define DT 1.5\n#define VOLUME .7\n\n#ifdef SOUNDBUFFER\nvec3 iResolution = vec3(.0);\nvec3 iMouse = vec3(.0);\n#endif\n\n#define TAU 6.2831\n#define NBSAMPLES 1\n\n\nmat3 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = -sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c           );\n}\n\nint Shape = 0;\n\nvec2 gen(float t, float f)\n{\n    float q = t*TAU*f;\n    vec2 r;\n    \n    /*\n    float d = 12.;\n    r = vec2(\n    \tcos(12.*q/d)+2.*sin(11.*q/d),\n    \tsin(13.*q/d)+3.*sin(14.*q/d)\n    ) / 4.;\n    */\n    if(Shape==0)\n    {\n        r = vec2(.0);\n        q *= 3.;\n        r += 1.*cos(5.*q+vec2(t,TAU/4.));\n        r += 2.*cos(3.*q+vec2(.0,TAU/2.));\n        r += .6*cos(8.*q+vec2(t*8.,TAU/2.));\n        r /= 4.;\n    }\n    else\n    {\n        mat3 Sys = mat3(.0);\n        Sys[0][0] = 1.;\n        Sys[1][1] = 1.;\n        Sys[2][2] = 1.;\n\n        vec3 p = vec3(.0);\n        float sumRad = 1.;\n        float m = 8.;\n\n        for(float i = 1.; i < 4. ; i++)\n        {\n            float rad = i==1. ?  8.\n                      : i==2. ? 4.\n                      : i==3. ? 1. : .0;//pow(m,-i);;//float[](8.,4.,1.)[int(i)-1]; // pow(m,-i*.5);//\n            float ang = i==1. ? 1.*i*q-t\n                      : i==2. ? m*i*q+t*2.2\n                      : i==3. ? 2.*m*i*q : .0;//float[](1.*i*q-t,m*i*q+t*2.2,2.*m*i*q)[int(i)-1];//i==1. ? 3.*i*q : 4.*i*q+t*2.; // pow(m,i)*i*q;//\n            float ca = cos(ang);\n            float sa = sin(ang);\n            p += Sys*vec3(ca,sa,.0)*rad;\n\n\n            Sys *= mat3(\n                  .0 , .0 , 1. ,\n                  ca , sa , .0 ,\n                 -sa , ca , .0\n            );\n\n            sumRad += rad;\n        }\n\n        p *= rotationMatrix(vec3(2.,-1.*cos(t*2.),1.),TAU*.5*t);\n        r = p.xy/sumRad;\n    }\n    \n    return r;\n}\n\nvec2 mainSound( float t )\n{\n    Shape = (cos(t*.5)+sin(t*3.)) > .8 ? 0 : 1;\n    \n    vec2 r;\n    \n    r += gen(t,mix(13.,min(20.+t*3.,500.),pow(cos(t/24.*TAU)*.499+.501,2.)));\n    //r += gen(t,120.)*mix(0.,1.,cos(t*.16*TAU)*.5+.5);\n    //r += gen(t,48.);\n    \n    //r /= 2.;\n    // limiter\n    //r = tanh(r*1.5);\n    \n    #ifdef SOUNDBUFFER\n      r *= VOLUME;\n    #endif\n    \n    return clamp(r,-1.,1.);\n}\n// segment.x is distance2 to closest point\n// segment.y is barycentric coefficient for closest point\nvec2 segment( vec2 p, vec2 a, vec2 b )\n{\n  #ifndef POINTS\n  float len = length(b-a);\n  //b -= (b-a)*.04;\n  if(len<1e-2)\n  #endif\n      return vec2(dot(p-a,p-a),.0);\n        \n  \n  #ifndef POINTS\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  a = a*(1.-t) + b*t;\n  //return vec2( dot(a,a) , t );\n    \n  if( t < 0. ){\n      return vec2( (k.x) , 0. );\n  } else if( t > 1. ){\n      return vec2( (k.y) , 1.  );\n  } else {\n  \treturn vec2( dot(a,a) , t );\n  }\n    \n  #endif\n}\n\n\n#ifndef SOUNDBUFFER\n\n#define linear(x,a,b,c,d) ((x-a)/(b-a)*(d-c)+c)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv_ = uv - vec2(.5);\n    uv_.x *= iResolution.x / iResolution.y;\n    uv_ += vec2(.5);\n\tfragColor = vec4(0.);\n\n    vec2 uvSound = uv_*2.-vec2(1.);\n    \n    float fps = 60.;\n    float t = iTime;\n    float dt = iTimeDelta*DT;\n    const int nbPoints = NBITERATIONS;\n    float nbPointsF = float(nbPoints);\n    vec4 Color = vec4(1.);\n    \n\tvec2 seg = vec2(.0);\n    vec2 A,B;\n    \n    float LumPower = 6e4;\n    \n    float tBegin = t-dt*.97;\n    float tEnd = t;\n    Color.rgb =  vec3(.2,1.,.1);\n    \n    float tLoop = tBegin;\n    A = mainSound( tLoop);\n    float tStepMin = (tEnd - tBegin)/nbPointsF/4.;\n    float tStep = (tEnd - tBegin)/nbPointsF;\n    tLoop += tStep;\n    \n    for(int i = 1; i <= nbPoints\n        && tLoop <= tEnd // comment this for WebGL 1.0\n        ; i++)\n    {\n        // uncomment this for WebGL 1.0\n        //if(tLoop > tEnd){break;}\n        \n        float iF = float(i);\n    \tB = mainSound(tLoop);\n        seg = segment( uvSound , A , B );\n    \n        \n        #ifndef POINTS\n          float k = (iF+seg.y)/nbPointsF-.5;\n          //Color.rgb = mix(Color.rgb,cos( (k ) * vec3(5.,7.,4.) * 2. - t*.6 )*.5+.5,.8);\n          Color.a = max(1. - k*k*4.,.0);\n          Color.a *= Color.a;\n          //Color.a = smoothstep(.0,1.,Color.a);\n          //Color.a *= cos(k*1e4*TAU)*.5+.5;\n        #endif\n    \n        fragColor += Color*Color.a/(1.+seg.x*LumPower);\n        \n        tStep = (tEnd - tBegin)/nbPointsF;\n        // trying to sample according to derivative... ????\n        //tStep = max( length( (B-A) )*1e-4 , tStepMin );\n        //tStep = max( length( (B-A) )/tStep*1e-6 , tStepMin );\n        //float e = 1e-5;\n        //float der = length( (mainSound( in int samp,tLoop+e)-B))/e;\n        //tStep = max( der*4e-8 , tStepMin );\n        \n        tLoop += tStep;\n        A = B;\n    }\n\n    fragColor += texture(iChannel0,uv)*.85;\n    // comment this for WebGL 1.0\n    fragColor = tanh(fragColor*1.);\n}\n\n#endif",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// copy paste this into sound and remove the next define\n#define SOUNDBUFFER\n//#define POINTS\n#define NBITERATIONS 300 // 1000 if you have a good GPU\n#define DT 1.5\n#define VOLUME .7\n\n#ifdef SOUNDBUFFER\nvec3 iResolution = vec3(.0);\nvec3 iMouse = vec3(.0);\n#endif\n\n#define TAU 6.2831\n#define NBSAMPLES 1\n\n#define CHOOSE(i,a,b,c) (i == 0 ? a : ( i == 1 ? b : c))\n\nmat3 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = -sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c           );\n}\n\nint Shape = 0;\n\nvec2 gen(float t, float f)\n{\n    float q = t*TAU*f;\n    vec2 r;\n    \n    /*\n    float d = 12.;\n    r = vec2(\n    \tcos(12.*q/d)+2.*sin(11.*q/d),\n    \tsin(13.*q/d)+3.*sin(14.*q/d)\n    ) / 4.;\n    */\n    if(Shape==0)\n    {\n        r = vec2(.0);\n        q *= 3.;\n        r += 1.*cos(5.*q+vec2(t,TAU/4.));\n        r += 2.*cos(3.*q+vec2(.0,TAU/2.));\n        r += .6*cos(8.*q+vec2(t*8.,TAU/2.));\n        r /= 4.;\n    }\n    else\n    {\n        mat3 Sys = mat3(.0);\n        Sys[0][0] = 1.;\n        Sys[1][1] = 1.;\n        Sys[2][2] = 1.;\n\n        vec3 p = vec3(.0);\n        float sumRad = 1.;\n        float m = 8.;\n\n        for(float i = 1.; i < 4. ; i++)\n        {\n            float rad = CHOOSE(int(i)-1,   8.,4.,1.);  // pow(m,-i*.5);//\n            float ang = CHOOSE(int(i)-1,   1.*i*q-t,m*i*q+t*2.2,2.*m*i*q);  //i==1. ? 3.*i*q : 4.*i*q+t*2.; // pow(m,i)*i*q;//\n            float ca = cos(ang);\n            float sa = sin(ang);\n            p += Sys*vec3(ca,sa,.0)*rad;\n\n\n            Sys *= mat3(\n                  .0 , .0 , 1. ,\n                  ca , sa , .0 ,\n                 -sa , ca , .0\n            );\n\n            sumRad += rad;\n        }\n\n        p *= rotationMatrix(vec3(2.,-1.*cos(t*2.),1.),TAU*.5*t);\n        r = p.xy/sumRad;\n    }\n    \n    return r;\n}\n\nvec2 mainSound( in int samp, float t )\n{\n    Shape = (cos(t*.5)+sin(t*3.)) > .8 ? 0 : 1;\n    \n    vec2 r;\n    \n    r += gen(t,mix(13.,min(20.+t*3.,500.),pow(cos(t/24.*TAU)*.499+.501,2.)));\n    //r += gen(t,120.)*mix(0.,1.,cos(t*.16*TAU)*.5+.5);\n    //r += gen(t,48.);\n    \n    //r /= 2.;\n    // limiter\n    //r = tanh(r*1.5);\n    \n    #ifdef SOUNDBUFFER\n      r *= VOLUME;\n    #endif\n    \n    return clamp(r,-1.,1.);\n}\n// segment.x is distance2 to closest point\n// segment.y is barycentric coefficient for closest point\nvec2 segment( vec2 p, vec2 a, vec2 b )\n{\n  #ifndef POINTS\n  float len = length(b-a);\n  //b -= (b-a)*.04;\n  if(len<1e-2)\n  #endif\n      return vec2(dot(p-a,p-a),.0);\n        \n  \n  #ifndef POINTS\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  a = a*(1.-t) + b*t;\n  //return vec2( dot(a,a) , t );\n    \n  if( t < 0. ){\n      return vec2( (k.x) , 0. );\n  } else if( t > 1. ){\n      return vec2( (k.y) , 1.  );\n  } else {\n  \treturn vec2( dot(a,a) , t );\n  }\n    \n  #endif\n}\n\n\n#ifndef SOUNDBUFFER\n\n#define linear(x,a,b,c,d) ((x-a)/(b-a)*(d-c)+c)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv_ = uv - vec2(.5);\n    uv_.x *= iResolution.x / iResolution.y;\n    uv_ += vec2(.5);\n\tfragColor = vec4(0.);\n\n    vec2 uvSound = uv_*2.-vec2(1.);\n    \n    float fps = 60.;\n    float t = iTime;\n    float dt = iTimeDelta*DT;\n    int nbPoints = NBITERATIONS;\n    float nbPointsF = float(nbPoints);\n    vec4 Color = vec4(1.);\n    \n\tvec2 seg = vec2(.0);\n    vec2 A,B;\n    \n    float LumPower = 6e4;\n    \n    float tBegin = t-dt*.97;\n    float tEnd = t;\n    Color.rgb =  vec3(.2,1.,.1);\n    \n    float tLoop = tBegin;\n    A = mainSound( in int samp,tLoop);\n    float tStepMin = (tEnd - tBegin)/nbPointsF/4.;\n    float tStep = (tEnd - tBegin)/nbPointsF;\n    tLoop += tStep;\n    \n    for(int i = 1; i <= nbPoints && tLoop <= tEnd ; i++)\n    {\n        float iF = float(i);\n    \tB = mainSound( in int samp,tLoop);\n        seg = segment( uvSound , A , B );\n    \n        \n        #ifndef POINTS\n          float k = (iF+seg.y)/nbPointsF-.5;\n          //Color.rgb = mix(Color.rgb,cos( (k ) * vec3(5.,7.,4.) * 2. - t*.6 )*.5+.5,.8);\n          Color.a = max(1. - k*k*4.,.0);\n          Color.a *= Color.a;\n          //Color.a = smoothstep(.0,1.,Color.a);\n          //Color.a *= cos(k*1e4*TAU)*.5+.5;\n        #endif\n    \n        fragColor += Color*Color.a/(1.+seg.x*LumPower);\n        \n        tStep = (tEnd - tBegin)/nbPointsF;\n        // trying to sample according to derivative... ????\n        //tStep = max( length( (B-A) )*1e-4 , tStepMin );\n        //tStep = max( length( (B-A) )/tStep*1e-6 , tStepMin );\n        //float e = 1e-5;\n        //float der = length( (mainSound( in int samp,tLoop+e)-B))/e;\n        //tStep = max( der*4e-8 , tStepMin );\n        \n        tLoop += tStep;\n        A = B;\n    }\n\n    fragColor += texture(iChannel0,uv)*.85;\n    fragColor = tanh(fragColor*1.);\n}\n\n#endif",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}