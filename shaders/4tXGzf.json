{
    "Shader": {
        "info": {
            "date": "1423650981",
            "description": "Simple cartoonish planet\nfixed for webgl 2",
            "flags": 0,
            "hasliked": 0,
            "id": "4tXGzf",
            "likes": 16,
            "name": "Cartoon Planet",
            "published": 3,
            "tags": [
                "3d",
                "noise",
                "raymarch",
                "earth",
                "planet"
            ],
            "usePreview": 0,
            "username": "kzy",
            "viewed": 1830
        },
        "renderpass": [
            {
                "code": "const float PI = 3.14159265359;\nconst float FOV = 67.0 / 180.0 * PI;\nconst float MAX = 10000.0;\n\n// scatter constants\nconst float K_R = 0.166;\nconst float K_M = 0.025;\nconst float E = 14.3; // light intensity\nconst vec3 C_R = vec3(0.3, 0.7, 1.0); // 1 / wavelength ^ 4\nconst float G_M = -0.85; // Mie g\n\nconst float R_INNER = 1.0;\nconst float R = R_INNER * 1.025;\nconst float SCALE_H = 4.0 / (R - R_INNER);\nconst float SCALE_L = 1.0 / (R - R_INNER);\n\nconst int NUM_OUT_SCATTER = 10;\nconst float FNUM_OUT_SCATTER = 10.0;\n\nconst int NUM_IN_SCATTER = 10;\nconst float FNUM_IN_SCATTER = 10.0;\n\nconst float WATER_HEIGHT = 0.7;\nconst vec3 LIGHT = vec3(0, 0, 1.0);\n\n#define SEED 171.\n\nvec2 ray_vs_sphere(vec3 p, vec3 dir, float r)\n{\n\tfloat b = dot(p, dir);\n\tfloat c = dot(p, p) - r * r;\n\n\tfloat d = b * b - c;\n\tif (d < 0.0)\n\t\treturn vec2(MAX, -MAX);\n\td = sqrt(d);\n\n\treturn vec2(-b - d, -b + d);\n}\n\nfloat phase_mie(float g, float c, float cc)\n{\n\tfloat gg = g * g;\n\n\tfloat a = (1.0 - gg) * (1.0 + cc);\n\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n\tb *= sqrt(b);\n\tb *= 2.0 + gg;\n\n\treturn 1.5 * a / b;\n}\n\nfloat phase_reyleigh(float cc)\n{\n\treturn 0.75 * (1.0 + cc);\n}\n\nfloat density(vec3 p)\n{\n\treturn exp(-(length(p) - R_INNER) * SCALE_H);\n}\n\nfloat optic(vec3 p, vec3 q)\n{\n\tvec3 step = (q - p) / FNUM_OUT_SCATTER;\n\tvec3 v = p + step * 0.5;\n\n\tfloat sum = 0.0;\n\tfor (int i = 0; i < NUM_OUT_SCATTER; i++)\n\t{\n\t\tsum += density(v);\n\t\tv += step;\n\t}\n\tsum *= length(step) * SCALE_L;\n\n\treturn sum;\n}\n\nvec3 in_scatter(vec3 o, vec3 dir, vec2 e, vec3 l)\n{\n\tfloat len = (e.y - e.x) / FNUM_IN_SCATTER;\n\tvec3 step = dir * len;\n\tvec3 p = o + dir * e.x;\n    vec3 pa = p;\n    vec3 pb = o + dir * e.y;\n\tvec3 v = p + dir * (len * 0.5);\n\n\tvec3 sum = vec3(0.0);\n\tfor (int i = 0; i < NUM_IN_SCATTER; i++)\n\t{\n\t\tvec2 f = ray_vs_sphere(v, l, R);\n\t\tvec3 u = v + l * f.y;\n\n\t\tfloat n = (optic(p, v) + optic(v, u)) * (PI * 4.0);\n\n\t\tsum += density(v) * exp(-n * (K_R * C_R + K_M));\n\n\t\tv += step;\n\t}\n\tsum *= len * SCALE_L;\n\n\tfloat c = dot(dir, -l);\n\tfloat cc = c * c;\n\treturn sum * (K_R * C_R * phase_reyleigh(cc) + K_M * phase_mie(G_M, c, cc)) * E;\n}\n\nvec3 scatter(vec3 ro, vec3 rd, vec2 f)\n{\n\tvec2 e = ray_vs_sphere(ro, rd, R);\n\tif (e.x > e.y)\n\t\treturn vec3(0);\n\n\te.y = min(e.y, f.x);\n\n\treturn in_scatter(ro, rd, e, LIGHT);\n}\n//###### end scatter\n\n//###### noise\n// credits to iq for this noise algorithm\n\nmat3 m = mat3(0.00, 0.80, 0.60,\n\t\t-0.80, 0.36, -0.48,\n\t\t-0.60, -0.48, 0.64);\n\nfloat hash(float n)\n{\n\treturn fract(sin(n) * 43758.5453);\n}\n\nfloat noise(in vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 57.0 + 113.0 * p.z;\n\n\tfloat res = mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\tmix(hash(n + 57.0), hash(n + 58.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\tmix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n\treturn res;\n}\n\nfloat fbm(vec3 p)\n{\n\tfloat f;\n\tf = 0.5000 * noise(p);\n\tp = m * p * 2.02;\n\tf += 0.2500 * noise(p);\n\tp = m * p * 2.03;\n\tf += 0.1250 * noise(p);\n\tp = m * p * 2.01;\n\tf += 0.0625 * noise(p);\n\treturn f;\n}\n\n//###### end noise\n\nfloat rnd(float r)\n{\n\treturn r - mod(r, 0.04);\n}\n\nfloat terrain(vec3 p)\n{\n\treturn fbm(p * 10.) / 5. + fbm(p + SEED) - (1. / 5.);\n}\n\nvec3 waterColor(float h)\n{\n\treturn mix(vec3(0, .29, 0.85), vec3(0, 0, .25), h);\n}\n\nvec3 terrainColor(float h)\n{\n//\th *= 1.2;\n\treturn h < .5 ?\n        mix(vec3(1.), vec3(.41, .54, .09), h * 2.) :\n\t\tmix(vec3(.41, .54, .0), vec3(.91, .91, .49), (h - .5) * 2.);\n}\n\nvec3 surfaceColor(float height, float longitude) {\n    if (height < (1.-WATER_HEIGHT))\n        return terrainColor(1.0 - abs(longitude + height + WATER_HEIGHT - 1.0));\n    else\n        return waterColor(height / WATER_HEIGHT);\n}\n\nmat3 rm(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n\t\toc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,\n\t\toc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n\tmat3 r = rm(vec3(0, 1, 0), iTime / 10.);\n    vec2 d = ray_vs_sphere(ro, rd, R_INNER);\n\tvec3 atmosphere = scatter(ro, rd, d);\n    \n    if (d.x < MAX - 1.0)\n\t{\n\t\tvec3 hit = normalize(d.x * rd + ro) * r;\n\t\tfloat h = (fbm(hit * 10.0) / 5.0 + fbm(hit + SEED)) - 0.2;\n\t\treturn surfaceColor(h, hit.y) * length(atmosphere * 1.5) * (atmosphere + 0.75);\n\t}\n    \n    return atmosphere;\n}\n\nvec3 getRay(vec3 pos, vec3 dir, vec3 up, vec2 fragCoord)\n{\n\tvec2 xy = fragCoord.xy / iResolution.xy - vec2(0.5);\n\txy.y *= -iResolution.y / iResolution.x;\n\n\tvec3 eyed = normalize(dir);\n\tvec3 ud = normalize(cross(vec3(0.0, -1.0, 0.0), eyed));\n\tvec3 vd = normalize(cross(eyed, ud));\n\n\tfloat f = FOV * length(xy);\n\treturn normalize(normalize(xy.x * ud + xy.y * vd) + (1.0 / tan(f)) * eyed);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat a = iMouse.x / iResolution.x * 10.;\n\tfloat h = iMouse.y / iResolution.y - 0.5;\n\n\tvec3 pos = vec3(3.5 * cos(a), h * 5., 3.5 * sin(a));\n\tvec3 dir = -normalize(pos);\n\tvec3 up = vec3(0, 1, 0);\n\n\tvec3 color = render(pos, getRay(pos, dir, up, fragCoord));\n\n\tfragColor = vec4(color, 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}