{
    "Shader": {
        "info": {
            "date": "1710172126",
            "description": "Graphs 3D surface defined by f(vec3(p)) = 0 using binary search. Includes bad music.",
            "flags": 8,
            "hasliked": 0,
            "id": "43BSzR",
            "likes": 14,
            "name": "3D Surface Graphing Calculator",
            "published": 3,
            "tags": [
                "3d",
                "math",
                "raycast",
                "binarysearch"
            ],
            "usePreview": 0,
            "username": "me_123",
            "viewed": 269
        },
        "renderpass": [
            {
                "code": "\nconst int MAXITR = 256;\nconst float detail = 0.2;\nconst float eps = 0.001;\n\n//#define SHOWGRID\n\nfloat f(in vec3 p) {\n    const float size = 4.0;\n    return sin(p.x)*sin(p.y)*sin(p.z)*10.+0.3*p.x*p.y*p.z+length(vec2(length(p.yz)-size, p.x)) + length(vec2(length(p.xz)-size, p.y)) + length(vec2(length(p.xy)-size, p.z))-size*1.9;\n}\n\nvec3 getRay(in vec3 cameraDir, in vec2 uv) {\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;\n\treturn normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n}\nfloat raycast(in vec3 ro, in vec3 rd, in float x, out bool hit, out int i) {\n    float k = sign(f(ro));\n    float s0 = k*detail;\n    float kk = abs(s0)*hash13(uvec3(gl_FragCoord.xy, iFrame));\n    for (i = 0; i < MAXITR && abs(s0) > 0.001; i++, x += s0*k) {\n        if (sign(f(ro+rd*(x+kk))) != sign(s0)) s0 = -s0*0.5, kk *= 0.5;\n    }\n    hit = i!=(MAXITR);\n    return x;\n}\nvec3 norm(in vec3 p) {\n    return normalize(vec3(\n        f(p+vec3(eps, 0, 0)) - f(p-vec3(eps, 0, 0)),\n        f(p+vec3(0, eps, 0)) - f(p-vec3(0, eps, 0)),\n        f(p+vec3(0, 0, eps)) - f(p-vec3(0, 0, eps))\n    ));\n}\nfloat grid(in vec2 x) {\n    x = abs(fract(x-0.5)-0.5);\n    return min(x.x, x.y);\n}\nconst float gridScale = 5.0;\nvec3 getColor(in vec3 p, in vec3 ro, in vec3 rd) {\n    vec3 normal = norm(p);\n    float spec = pow(0.4+0.4*dot(reflect(rd, normal), normalize(vec3(1, 2, 3))), 20.)*20.0;\n    vec3 diff = (sign(f(ro)) > 0.0 ? vec3(0.5, 0.5, 1) : vec3(1, 0.5, 0.5))*(dot(normal, normalize(vec3(1, 2, 3)))*0.5+0.5);\n    float color = int(floor(p.z+0.5)+floor(p.x+0.5)+floor(p.y+0.5))%2==0?1.0:0.5;\n    return vec3(0.8*sqrt(spec+color*diff));\n}\nvec3 zGrid(in vec3 ro, in vec3 rd, in float dist) {\n    vec2 p = ro.xy+rd.xy*dist;\n    if (f(vec3(p.x, p.y, 0.0)) < 0.0) return vec3(0, 0, 0); \n    p *= gridScale;\n    return vec3(mix(mix(vec3(0.4), vec3(1), clamp((grid(p)-0.01)/dist*250./gridScale, 0.0, 1.0)), vec3(0), 1.-clamp((grid(p*0.2)-0.01)/dist*2000./gridScale, 0.0, 1.0)));\n}\nvec3 yGrid(in vec3 ro, in vec3 rd, in float dist) {\n    vec2 p = ro.xz+rd.xz*dist;\n    if (f(vec3(p.x, 0, p.y)) < 0.0) return vec3(0, 0, 0); \n    p *= gridScale;\n    return vec3(mix(mix(vec3(0.4), vec3(1), clamp((grid(p)-0.01)/dist*250./gridScale, 0.0, 1.0)), vec3(0), 1.-clamp((grid(p*0.2)-0.01)/dist*2000./gridScale, 0.0, 1.0)));\n}\nvec3 xGrid(in vec3 ro, in vec3 rd, in float dist) {\n    vec2 p = ro.yz+rd.yz*dist;\n    if (f(vec3(0.0, p.x, p.y)) < 0.0) return vec3(0, 0, 0); \n    p *= gridScale;\n    return vec3(mix(mix(vec3(0.4), vec3(1), clamp((grid(p)-0.01)/dist*250./gridScale, 0.0, 1.0)), vec3(0), 1.-clamp((grid(p*0.2)-0.01)/dist*2000./gridScale, 0.0, 1.0)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    vec2 m = iMouse.z>0.0?(iMouse.xy/iResolution.xy)*vec2(6.28, 3.14159263):vec2(iTime*0.5, cos(iTime*0.5)*0.2+1.1);\n    vec3 ro = vec3(sin(m.y) * cos(-m.x), sin(m.y) * sin(-m.x), cos(m.y))*20.0;\n    vec3 rd = getRay(-normalize(ro), uv);\n    bool hit;\n    int i;\n    float dist = raycast(ro, rd, 0.0, hit, i);\n    vec3 color = hit?mix(getColor(ro+rd*dist, ro, rd), vec3(1), float(i)/float(MAXITR)):vec3(1);\n    fragColor = vec4(color, 0);\n    #ifdef SHOWGRID\n    vec3 dists = -ro/rd;\n    if (dists.x < 0.0) dists.x = 100000.;\n    if (dists.y < 0.0) dists.y = 100000.;\n    if (dists.z < 0.0) dists.z = 100000.;\n    \n    vec3 d = pow(abs(normalize(ro)), vec3(10.0));\n    \n    fragColor.xyz += xGrid(ro, rd, dists.x)*d.x;\n    fragColor.xyz += yGrid(ro, rd, dists.y)*d.y;\n    fragColor.xyz += zGrid(ro, rd, dists.z)*d.z;\n    fragColor /= (1.+d.x+d.y+d.z);\n    #endif\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins. May 2018\n\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\n\n// The labeling refers to the number of values - hash(out)(in)...\n//---------------------------------------------------------------------------------------------------------------\nfloat hash11(uint q)\n{\n\tuvec2 n = q * UI2;\n\tq = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\nfloat hash11(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tuint q = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nfloat hash12(uvec2 q)\n{\n\tq *= UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nfloat hash13(uvec3 q)\n{\n\tq *= UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash13(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nfloat hash14(uvec4 q)\n{\n\tq *= UI4;\n\tuint n = (q.x ^ q.y ^ q.z ^ q.w) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash14(vec4 p)\n{\n\tuvec4 q = uvec4(ivec4(p)) * UI4;\n\tuint n = (q.x ^ q.y ^ q.z ^ q.w) * UI0;\n\treturn float(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec2 hash21(uint q)\n{\n\tuvec2 n = q * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n\nvec2 hash21(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec2 hash22(uvec2 q)\n{\n\tq *= UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec2 hash23(uvec3 q)\n{\n\tq *= UI3;\n\tuvec2 n = (q.x ^ q.y ^ q.z) * UI2;\n\treturn vec2(n) * UIF;\n}\n\nvec2 hash23(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuvec2 n = (q.x ^ q.y ^ q.z) * UI2;\n\n\treturn vec2(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash31(uint q)\n{\n\tuvec3 n = q * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\nvec3 hash31(float p)\n{\n\n\tuvec3 n = uint(int(p)) * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash32(uvec2 q)\n{\n\tuvec3 n = q.xyx * UI3;\n\tn = (n.x ^ n.y ^n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\nvec3 hash32(vec2 q)\n{\n\tuvec3 n = uvec3(ivec3(q.xyx)) * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash33(uvec3 q)\n{\n\tq *= UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec4 hash44(uvec4 q)\n{\n\tq *= UI4;\n\tq = (q.x ^ q.y ^ q.z ^ q.w)*UI4;\n\treturn vec4(q) * UIF;\n}\n\nvec3 hash44(vec4 p)\n{\n\tuvec4 q = uvec4(ivec4(p)) * UI4;\n\tq = (q.x ^ q.y ^ q.z ^ q.w)*UI4;\n\treturn vec3(q) * UIF;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "float square(in float x) {\n    return cos(3.14159*x)/sqrt(1.4-pow(sin(3.14159*x), 2.0));\n}\nfloat noise(in float x) {\n    return mix(hash11(floor(x)), hash11(floor(x+1.0)), mod(x, 1.0));\n}\nfloat sound(in float time) {\n    float t = floor(time*5.0);\n    float t1 = floor(time*mod(t, 2.0));\n    float f = abs(mod(t, 3.0)-1.0)+abs(mod(t, 4.)-2.);\n    float v = mix(fract(time*900.), 1.0, sin(time)*0.5+0.5)*0.5*(0.1*sin(time*10000.+sin(time*100.))*exp(mod(time*10., 3.))+exp(-fract(time*2.)*2.)*fract(time*(100.+100.*mod(floor(time*2.0), 2.)))+exp(-fract(time*5.)*5.)*sin(time*1500.)+exp(-fract(time*10.)*2.)*square(time*hash11(floor(time*10.))*1000.)*sin(time*(mod(t1, 2.0)+4.)*400.)*0.5*sin(time*500.*(f+2.)+sin(time*200.+time*400.*(5.-f))));\n    v += (noise(log(fract(time*10.)*100.)*5.))*0.5;\n    v += (sin(log(fract(time*2.)*10.)*10.))*0.5;\n    return mix(v, sin(time*500.+sin(time*1000.)), exp(-fract(time*0.1)*5.));\n}\nvec2 mainSound( int samp, float time )\n{\n    return vec2(sin(5.0*sound(time+5.0)), (sound(time+0.01*sound(time*0.5))));\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}