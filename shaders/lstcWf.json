{
    "Shader": {
        "info": {
            "date": "1521593815",
            "description": "Use the mouse to change text weight and shape. Press space to toggle between demo message and font table.",
            "flags": 16,
            "hasliked": 0,
            "id": "lstcWf",
            "likes": 19,
            "name": "yet another font shader",
            "published": 3,
            "tags": [
                "shader",
                "font",
                "needlesslycomplex"
            ],
            "usePreview": 1,
            "username": "mattz",
            "viewed": 1058
        },
        "renderpass": [
            {
                "code": "/* \"yet another font shader\" by mattz\n   License: https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n   I wanted to make my own procedural distance field font\n   suitable for ray marching, but the code complexity kind of\n   spiraled out of control. \n\n   My goal was to produce something distinct from the technical\n   \"ball and stick\" look achieved by Andre (link below) by \n   supporting elliptical arcs and mitered joints between strokes\n   within the font. For the latter, take a close look at the\n   'G' and '5' glyph shapes in the font table.\n\n   I wrote a python script to develop and debug the font:\n   https://github.com/mzucker/shaderfont\n\n   Here are some other cool procedural fonts (as opposed to\n   otaviogood's https://www.shadertoy.com/view/llcXRl, which \n   is awesome but \"cheats\" by using a texture):\n\n    - \"Shadertext proportional spacing\" by Andre\n      https://www.shadertoy.com/view/4s3XDn\n\n    - \"Kerning? I barely knew her\" by m1el\n      https://www.shadertoy.com/view/ltS3RG\n\n    - \"Temporal Text\" by akohdr\n      https://www.shadertoy.com/view/MddXDs\n\n   I've had limited success getting my font to work inside\n   a 3D raymarcher -- my high-end video card crashes WebGL\n   when the string gets long (presumably because of loop\n   unrolling).\n\n   I have a few ideas on more fun applications for this before\n   I abandon it due to overcomplexity...\n\n*/\n\n\nfloat thickness, slant;\n\nvec3 draw_font_table(vec2 fragCoord) {\n   \n    const vec2 cell_dims = vec2(15, 17);\n    const vec2 table_counts = vec2(16, 6);\n    const float margin = 0.5;\n    const vec2 table_dims = table_counts * (cell_dims + margin) - margin;\n    \n    vec2 s = (iResolution.xy / table_dims);\n    float scl = 1.0 / min(s.x, s.y);\n    \n    // p is coordinates within table\n    vec2 p = (fragCoord.xy - 0.5*iResolution.xy) * scl + 0.5*table_dims + margin;\n    \n    // cell index (relative to table counts)\n    vec2 cell = floor(p / (cell_dims + margin));\n    \n    // remove floor bits\n    p -= cell * (cell_dims + margin) + margin;\n\n    // invert y in table\n    cell.y = table_counts.y - cell.y - 1.;\n    \n    int idx = int(cell.x + cell.y * 16.);\n    \n    if (idx < 0 || idx >= 95) {        \n        return vec3(1);\n    }\n    \n    ivec4 gdata = font_data[idx];\n    \n    vec3 color = vec3(1);\n    \n    vec3 dims;\n    ivec2 clip_sym;\n    glyph_info(gdata, dims, clip_sym);\n    \n    p.x -= 0.5 * (cell_dims.x - dims.x);\n    p.y -= 5.; \n    p.x -= slant * (p.y - 7.);\n    \n    float d = glyph_dist(gdata, dims, clip_sym, p);\n    \n    color = mix(color, vec3(1, 0, 0), 0.25+0.25*cos(2.*d/scl - 10.*iTime));\n    color *= smoothstep(0., scl, d - thickness);\n\n    return color;\n    \n}\n\nvec3 draw_intro_text(vec2 fragCoord) {\n    \n    \n    float line_size = iResolution.y / 8.3;\n    float font_size = 0.7 * line_size;\n    \n    vec4 sz = glyph_size_info(font_size, thickness, slant, 0.);\n    \n    vec2 p = fragCoord;\n    \n    p.y -= iResolution.y - 1.25*font_size;\n    \n    p.x -= 0.25*font_size;\n\n    vec3 color = vec3(1);\n    \n    g_glyph.box_dist = 1e5;\n    \n\tvec4 gpos = vec4(0, 0, 0, line_size);\n\n    #define STRLEN 11\n    \n    ivec4 str[STRLEN] = ivec4[STRLEN](\n        ivec4(0xcbcb2c8, 69006496, 69022457, 0xe9bf761),\n        ivec4(68989672, 0xc7bf970, 0xe5d7265, 0xcc2b661),\n        ivec4(69023599, 0xc987473, 67877221, 0xe5d1049),\n        ivec4(68760297, 0xc9bb0a8, 0xd387320, 87634668),\n        ivec4(68942346, 0xe9bb7e3, 68924641, 68777076),\n        ivec4(0xcb937e3, 0xf5a79a0, 21141349, 69024450),\n        ivec4(0xd083a69, 0xe8839e1, 0xca832e8, 0xe5a7a6e),\n        ivec4(78286949, 69784128, 0x874e08a, 0xe0824c9),\n        ivec4(0xe9bb4f2, 0xcbb3161, 0xc3a31a0, 0xe98f0f2),\n        ivec4(0xe683965, 21707365, 68761441, 0xc9bb0e8),\n        ivec4(69006060, 0, 0, 0)\n    );\n    \n    for (int i=0; i<STRLEN; ++i) {\n        glyph_string(str[i], sz, gpos, p);\n    }\n    \n    vec4 bold = glyph_size_info(font_size, 0.75, 0., 0.);\n    vec4 ital = glyph_size_info(font_size, 0.25, 0.5, 0.);\n    \n    gpos.x += 0.5*font_size * slant;\n    glyph_string(0xc9b37e2, bold, gpos, p);\n    glyph_string(ivec4(0xc9bb0a0, 32, 0, 0), sz, gpos, p);\n    gpos.x += 0.5*font_size * slant;\n    glyph_string(ivec4(0xd987a69, 12777, 0, 0), ital, gpos, p);\n    glyph_string(ivec4(0xe7a720a, 0xf387670, 0xf3d39a0, 98366188), sz, gpos, p);\n    \n    float d = glyph_dist(g_glyph, p);\n    color *= smoothstep(0., 1., d);\n    \n    return color;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    thickness = mix(0.125, 0.7, smoothstep(0.1, 0.9, iMouse.y/iResolution.y));\n    slant = mix(0., 0.5, smoothstep(0.1, 0.9, iMouse.x/iResolution.x));\n    \n    if (max(iMouse.x, iMouse.y) < 20.) {\n        thickness = 0.25;\n        slant = 0.;\n    }\n\n    vec3 color = vec3(1);\n    \n    if (texelFetch(iChannel0, ivec2(32, 2), 0).x > 0.) {\n        color = draw_font_table(fragCoord);\n    } else {\n        color = draw_intro_text(fragCoord);\n    }\n        \n    color = pow(color, vec3(1.0/2.2));\n    \n        \n    fragColor = vec4(color, 1);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Designed to be pasted into other shaders. \n// Sorry it's so long and inscrutable.\n//\n// License: https://creativecommons.org/licenses/by-nc-sa/3.0/\n\nconst int CLIP_X = 0x01;\nconst int CLIP_Y = 0x02;\n\nconst int SYM_X = 1;\nconst int SYM_Y = 2;\nconst int SKEWY = 3;\n\nconst int OP_M = 0;\nconst int OP_T = 1;\nconst int OP_C = 2;\nconst int OP_A = 3;\nconst int OP_E = 4;\nconst int OP_D = 5;\nconst int OP_U = 6;\nconst int OP_L = 7;\n\nconst float PI = 3.141592653589793;\nconst float EPS = 1e-5;\n\n//////////////////////////////////////////////////////////////////////\n// ascii range 32-127\n\nconst ivec4 font_data[95] = ivec4[95](\n    ivec4(268435456, 0x8000000, 0, 0),\n    ivec4(0x8053c23, 679780331, 67386401, 0),\n    ivec4(268770345, 0xc853c08, 859241, 479018056),\n    ivec4(470056131, 671620165, 0x8141ca5, 0),\n    ivec4(432836773, 848606249, 0xc0c1c61, 0x3c000000),\n    ivec4(671628553, 672674084, 537186441, 0),\n    ivec4(504668326, 731150625, 1391721, 42253509),\n    ivec4(0x8051c29, 0xc853c08, 0, 469762048),\n    ivec4(0xc0c3429, 671088640, 0, 0),\n    ivec4(0xc003449, 671088640, 0, 0),\n    ivec4(402971751, 461701221, 663560192, 268435456),\n    ivec4(403471463, 402963621, 0, 0x8000000),\n    ivec4(0x8041c21, 0xc843c00, 0, 0x3c000000),\n    ivec4(402963621, 0x8000000, 0, 268435456),\n    ivec4(0xb842000, 0x8000000, 0, 0),\n    ivec4(335813770, 671088640, 268435456, 0),\n    ivec4(470039753, 671363273, 8663241, 0),\n    ivec4(327950401, 730414088, 0, 0),\n    ivec4(403979297, 688172962, 34945065, 0),\n    ivec4(432582821, 714383360, 402653184, 0),\n    ivec4(403717257, 730111140, 0, 0),\n    ivec4(432648357, 689187849, 302046281, 60104704),\n    ivec4(437567657, 697397283, 58991649, 25301158),\n    ivec4(402996393, 730324992, 0, 0),\n    ivec4(437559296, 671088640, 0x8000000, 0),\n    ivec4(433156263, 731193513, 33850537, 25292836),\n    ivec4(0xb842026, 528793600, 0, 0),\n    ivec4(0x8041c21, 537189414, 8666112, 0x3c000000),\n    ivec4(404249637, 536870912, 671088640, 67108864),\n    ivec4(402947235, 335862950, 0, 0x8000000),\n    ivec4(402676901, 536870912, 671088640, 67108864),\n    ivec4(402959834, 706032805, 327975009, 59514880),\n    ivec4(568783081, 723329155, 35439649, 35463168),\n    ivec4(537115715, 730882115, 0x7912000, 0),\n    ivec4(462173349, 730119201, 0x8000000, 0),\n    ivec4(470889505, 688140034, 0xa1d2000, 0),\n    ivec4(529282249, 730151969, 0, 0),\n    ivec4(403979297, 730119301, 0x8000000, 0),\n    ivec4(461716649, 671399045, 0, 0),\n    ivec4(630288649, 723532965, 0, 0),\n    ivec4(528792773, 731389952, 0x8000000, 0),\n    ivec4(0xb852000, 671088640, 0, 0),\n    ivec4(404044963, 721690624, 0, 0),\n    ivec4(461683781, 731119616, 0x8000000, 0),\n    ivec4(461709345, 731127808, 0, 0),\n    ivec4(663043297, 671088640, 67108864, 0),\n    ivec4(528825537, 731455488, 0, 0),\n    ivec4(572334080, 671088640, 0, 0),\n    ivec4(461716585, 714390565, 0, 0),\n    ivec4(572334243, 731652096, 805306368, 0),\n    ivec4(461716585, 714390565, 572517, 60538880),\n    ivec4(432836773, 714388521, 0xc000000, 0),\n    ivec4(402996393, 671890537, 0, 0),\n    ivec4(403994657, 730144768, 67108864, 0),\n    ivec4(536976513, 671088640, 335544320, 0),\n    ivec4(738311265, 731717632, 335544320, 0),\n    ivec4(537124108, 671194398, 268435456, 0),\n    ivec4(536976547, 672144517, 335544320, 0),\n    ivec4(403979297, 731193344, 0xc000000, 0),\n    ivec4(0xc083c21, 730144768, 0x8000000, 0),\n    ivec4(335895680, 671088640, 268435456, 0),\n    ivec4(0xf883c49, 671088640, 0x8000000, 0),\n    ivec4(410819755, 469762048, 603979776, 0xc000000),\n    ivec4(402922656, 0x8000000, 0, 0x3c000000),\n    ivec4(0x8051c29, 0xc853c0a, 0, 469762048),\n    ivec4(437559457, 596945060, 25251879, 0),\n    ivec4(461709345, 706011136, 0, 0),\n    ivec4(336393249, 553922306, 437575680, 0),\n    ivec4(437575841, 731193344, 0, 0),\n    ivec4(435327143, 588577828, 8663207, 0),\n    ivec4(403192903, 688434707, 34938917, 59809792),\n    ivec4(437575847, 865340435, 18116669, 805306368),\n    ivec4(461709345, 730110119, 60039168, 0),\n    ivec4(0xb84e029, 730144768, 0, 0),\n    ivec4(404044969, 940899488, 25323683, 839360512),\n    ivec4(335854752, 679779528, 302280, 277545),\n    ivec4(0xb852000, 671088640, 0, 0),\n    ivec4(730128417, 595892391, 60039332, 52755745),\n    ivec4(461692961, 595892391, 60039168, 0),\n    ivec4(437575680, 536870912, 0, 0),\n    ivec4(437575742, 797237248, 0, 872415232),\n    ivec4(437575870, 798285824, 0, 872415232),\n    ivec4(461671955, 553922727, 277543, 0),\n    ivec4(432836772, 580162599, 17100059, 34897920),\n    ivec4(403258435, 688401932, 34906151, 59826176),\n    ivec4(402979876, 588521633, 60088320, 0),\n    ivec4(402988129, 536870912, 67108864, 0),\n    ivec4(671423585, 596958406, 67108864, 0),\n    ivec4(402922664, 537205920, 0, 0),\n    ivec4(402979876, 856957095, 60034067, 823423037),\n    ivec4(403979297, 596959232, 0xc000000, 0),\n    ivec4(285240600, 705211911, 688402563, 0),\n    ivec4(0xb852000, 671088640, 0, 0),\n    ivec4(286289159, 705211416, 688402435, 0),\n    ivec4(486837783, 0xe10c8c5, 31264871, 268435456)\n);\n\n//////////////////////////////////////////////////////////\n// closed-form solver from https://www.shadertoy.com/view/XdKyRR \n// but without special-case checks\n\nbvec4 solve_quartic(in vec4 coeffs,\n                    out vec4 roots) {\n        \n    float p = coeffs[0];\n    float q = coeffs[1]; \n    float r = coeffs[2];\n    float s = coeffs[3];\n    \n    ////////////////////////////////////////////////////////////\n    // form resolvent cubic and solve it to obtain one real root\n        \n    float i = -q;\n    float j = p*r - 4.*s;\n    float k = 4.*q*s - r*r - p*p*s;\n    \n    // coefficients of normal form\n    float a = (3.*j - i*i) / 3.;\n    float b = (2.*i*i*i - 9.*i*j + 27.*k) / 27.;\n    \n    float delta1 = b*b / 4.;\n    float delta2 = a*a*a / 27.;\n    \n    float delta = delta1 + delta2;\n    \n    float z1;\n    \n    if (delta >= 0.) {\n        vec2 AB = -0.5*b + vec2(1,-1) * sqrt(max(delta, 0.));\n        AB = sign(AB) * pow(abs(AB), vec2(1.0/3.0));\n        z1 = AB.x + AB.y;\n    } else {\n        float phi = acos( -sign(b) * sqrt(delta1/-delta2) );\n        z1 = 2. * sqrt(-a/3.) * cos( phi / 3.);\n    }\n    \n    // shift back from normal form to root of resolvent cubic\n    z1 -= i/3.;\n    \n    ////////////////////////////////////////////////////////////\n    // now form quartic roots from resolvent cubic root\n\n    float R2 = p*p/4. - q + z1; \n        \n    bool R_ok = (R2 >= 0.);\n\n    float R = sqrt(max(R2, 0.));\n    \n    float foo, bar;\n    \n    if (R == 0.) { \n        float z124s = z1*z1 - 4.*s;\n        R_ok = R_ok && (z124s >= 0.);\n        foo = 3.*p*p / 4. - 2.*q;\n        bar = 2.*sqrt(max(z124s, 0.));\n    } else {\n        foo = 3.*p*p / 4. - R2 - 2.*q;\n        bar = (4.*p*q - 8.*r - p*p*p) / (4.*R);\n    }\n    \n    bool D_ok = R_ok && (foo + bar >= 0.);\n    bool E_ok = R_ok && (foo - bar >= 0.);\n    \n    float D = sqrt(max(foo + bar, 0.));\n    float E = sqrt(max(foo - bar, 0.));\n    \n    roots = vec4(-p/4.) + 0.5 * vec4(R+D, R-D, -(R-E), -(R+E));\n    return bvec4(D_ok, D_ok, E_ok, E_ok);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// unit vector from quantized angle (32 slots/revolution)\n\nvec2 from_angle(float t) {    \n    return cos(vec2(t, t-8.)*PI/16.);    \n}\n\n//////////////////////////////////////////////////////////////////////\n// return perpendicular vector to input\n\nvec2 perp(vec2 t) {\n    return vec2(-t.y, t.x);\n}\n\n//////////////////////////////////////////////////////////////////////\n// return (possibly) sign-flipped vector u such that dot(u, n) >= 0\n\nvec2 align(vec2 u, vec2 n) {\n    return u * (dot(u,n) < 0. ? -1. : 1.);\n}\n\n//////////////////////////////////////////////////////////////////////\n// dist to centerline, stroke dist, type, fill\n\nvec4 line_dist(vec2 pa, vec2 pb, vec2 p) {\n    \n    vec2 t = pb-pa;\n    \n    float l = length(t);\n    \n    if (l < 1e-5) {\n        t = vec2(0, 1);\n    } else {\n        t /= l;\n    }\n    \n    vec2 n = perp(t);\n    \n    mat2 R = mat2(n, t);\n    \n    p -= pa;\n    float dx = dot(p,t);\n    float dy = dot(p,n);\n    \n    vec2 d = vec2(dx, dy) - vec2(clamp(dx, 0., l), 0);\n    \n    float dline = length(d);\n    \n    float dstroke = max(abs(d.x), abs(d.y));\n    float type = dx <= 0. ? 0. : dx >= l ? 2. : 1.; \n    \n    return vec4(dline, dstroke, type, dy);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// construct unit vector from cosine of angle\n\nvec2 from_cos(float u) {\n    u = clamp(u, -1., 1.);\n    return vec2(u, sqrt(1. - u*u));\n}\n\n//////////////////////////////////////////////////////////////////////\n// return whichever vector has smaller x-coordinate\n\nvec2 smaller_x(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\n//////////////////////////////////////////////////////////////////////\n// return distance from point p to ellipse centered at origin\n// with radii given by ab and angular limits given by alim.\n//\n// return (arc dist, stroke dist, type, filled arc dist)\n\nvec4 ellipse_arc_dist(in vec2 p, in vec2 ab, in vec2 alim,\n                     out vec2 p0, out vec2 et0, out vec2 p1, out vec2 et1) {\n    \n    ab = abs(ab);\n        \n    vec2 darc = vec2(1e5, 1);\n    vec2 dfill = vec2(1e5, 1);\n    \n    float orig_sign = -1.;\n    \n    bool full_ellipse = alim[1] == 0.;\n\n    vec2 n0 = from_angle(alim.x);\n    vec2 n1 = from_angle(alim.x + alim.y);\n\n    float delta_sign = sign(alim.y);\n    \n    vec2 t0 = -perp(n0)*delta_sign;\n    vec2 t1 = perp(n1)*delta_sign;\n        \n    vec2 en0 = normalize(ab.yx*n0);\n    vec2 en1 = normalize(ab.yx*n1);\n\n    et0 = normalize(ab*t0);\n    et1 = normalize(ab*t1);\n    \n    p0 = ab * n0;\n    p1 = ab * n1;\n    \n    float dstroke = 1e5;\n    \n    if (!full_ellipse) {\n        \n        vec2 dp0 = p - p0;\n        vec2 dp1 = p - p1;\n        \n        vec2 dn = vec2(dot(dp0, en0), dot(dp1, en1));\n        vec2 dt = vec2(dot(dp0, et0), dot(dp1, et1));\n        \n        vec2 dc = max(abs(dn), abs(dt));\n \n        float dcap = 1e5;\n        \n        if (dt.x >= 0.) { dstroke = min(dstroke, dc.x); }\n        if (dt.y >= 0.) { dstroke = min(dstroke, dc.y); }\n        \n        vec2 dh = vec2(length(dp0 - et0 * max(0., dt.x)),\n                       length(dp1 - et1 * max(0., dt.y)));\n        \n        dfill = smaller_x(vec2(dh.x, sign(dn.x)),\n                          vec2(dh.y, sign(dn.y)));\n        \n        darc = smaller_x(vec2(length(dp0), 0), vec2(length(dp1), 2));\n        \n    }\n    \n    \n    if (abs((ab.x - ab.y) / ab.x) < 1e-2) {\n                \n        if (full_ellipse || max(dot(p, t0), dot(p, t1)) <= .0) {\n            \n            float dc = length(p) - ab.x;\n            \n            darc = smaller_x(darc, vec2(abs(dc), 1));\n            dstroke = min(dstroke, abs(darc.x));\n            dfill = smaller_x(dfill, vec2(abs(dc), sign(dc)));\n            \n        }\n        \n    } else {\n                \n        if (abs(p.x) < abs(p.y)) {\n            p.xy = p.yx;\n            ab.xy = ab.yx;\n            t0 = t0.yx;\n            t1 = t1.yx;\n        }\n        \n        float l = ab.y*ab.y - ab.x*ab.x;\n\n        float ax = ab.x*p.x / l;\n        float by = ab.y*p.y / l;\n\n        float a2x2 = ax*ax;\n        float b2y2 = by*by;\n\n        vec4 coeffs = vec4(2.*ax, (a2x2 + b2y2) - 1., -2.*ax, -a2x2);\n\n        vec4 roots;\n        solve_quartic(coeffs, roots);\n                \n        for (int i=0; i<4; ++i) {\n            \n            vec2 uv = from_cos(roots[i]);\n            \n            for (int j=0; j<2; ++j) {\n\n                if (full_ellipse ||\n                    max(dot(uv, t0), dot(uv, t1)) <= 0.) {\n\n                    vec2 pc = ab*uv;\n                    float dc = length(p - pc);\n                    float s = sign(dot(p-pc, pc));\n                    \n                    darc = smaller_x(darc, vec2(dc, 1));\n                    dstroke = min(dstroke, dc);\n                    dfill = smaller_x(dfill, vec2(dc, s));\n                    \n                }   \n                \n                uv.y *= -1.;\n                \n            }\n        }\n    }\n        \n    return vec4(darc.x, dstroke, darc.y, dfill.x*dfill.y);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// join together two paths\n\nvoid miter(inout vec4 da, inout vec4 dc, \n           in vec2 p, in vec2 ta, in vec2 tc) {\n    \n    vec2 na = align(perp(ta), tc);\n    vec2 nc = align(perp(tc), ta);\n    \n    if (da.z == 2. && dc.z == 0.) {\n        da.y = dc.y = max(dot(p, na), dot(p, nc));\n    }            \n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to glyph in font units. this is basically a big \n// interpreter/state machine\n\nfloat glyph_dist(ivec4 gdata, vec3 dims, ivec2 clip_sym, vec2 p) {\n    \n    vec2 offs = vec2(0, dims.z);\n    vec2 ps = offs + 0.5*dims.xy - abs(p - offs - 0.5*dims.xy);\n    \n    if (clip_sym.y == SYM_X) {\n        p.x = ps.x;\n    } else if (clip_sym.y != 0) {\n        bool above = p.y - dims.z > 0.5*dims.y;\n        p.y = ps.y;\n        if (clip_sym.y == SKEWY && above) {\n            p.x = dims.x - p.x;\n        }\n    }\n    \n    const uvec2 shift = uvec2(13, 0);\n    \n    float dist_field = 1e5;\n    vec2 run = vec2(1e5);\n    \n    // centerline, feature, stroke fill\n    vec4 prev_stroke = vec4(1e5);\n    \n    vec2 p0 = vec2(1.);\n    vec2 ellipse_corner = vec2(1.);\n    bool clip_mode = false;\n    vec2 prev_t1 = vec2(0);\n    vec2 alim = vec2(0);\n    \n    for (int i=0; i<4; ++i) {    \n        \n        for (int j=0; j<2; ++j) {\n                                   \n            ivec3 instr = ivec3(gdata[i] >> shift[j]) >> ivec3(10, 5, 0);\n                        \n            instr &= ivec3(0x7, 0x1f, 0x1f);\n            instr.yz = (instr.yz ^ 16) - 16;\n            \n            int opcode = instr.x;\n            vec2 p1 = vec2(instr.yz);\n            \n            if (opcode <= OP_T) {\n                \n                run = smaller_x(prev_stroke.xy, run);\n                dist_field = min(dist_field, run.y);\n                run = vec2(1e5);\n                prev_stroke = vec4(1e5);\n                prev_t1 = vec2(0);\n                alim = vec2(0);\n                ellipse_corner = p1;\n                p0 = p1;\n                clip_mode = (opcode == OP_T);\n                continue;\n                \n            } else if (opcode == OP_C) {\n                \n                ellipse_corner = p1;\n                continue;\n                \n            } else if (opcode == OP_A) {\n                \n                alim = p1;\n                if (alim.y >= 0.) { alim.y += 1.; }\n                continue;\n                \n            }\n            \n            bool is_ellipse = (opcode >= OP_E && opcode <= OP_U);\n            bool connect_ellipse = false;\n            \n            vec4 estroke = vec4(1e5);\n            vec2 et0, ep1, et1;\n            \n            if (is_ellipse) {\n                \n                vec2 mid = 0.5 * (p1 + p0);\n                vec2 diff = p1 - p0;\n                vec2 sgn = sign(diff);\n                \n                vec2 ctr, rad;\n                \n                if (opcode == OP_D) {\n                    \n                    ctr = vec2(p0.x, mid.y);\n                    rad = diff * vec2(1, .5);\n                    alim = vec2(-sgn.y*8., 16.*sgn.x*sgn.y);\n                    \n                } else if (opcode == OP_U) {\n                    \n                    ctr = vec2(mid.x, p0.y);\n                    rad = diff * vec2(.5, 1);\n                    alim = vec2(8.+sgn.x*8., -16.*sgn.x*sgn.y);\n                    \n                } else {\n                    \n                    ctr = 0.5 * (p1 + ellipse_corner);\n                    rad = 0.5 * (p1 - ellipse_corner);\n                    \n                }\n                \n                rad = abs(rad);\n\n                \n                estroke = ellipse_arc_dist(p-ctr, rad, alim,\n                                           p1, et0, ep1, et1);\n                \n                p1 += ctr;\n                ep1 += ctr;\n                et0 = -et0;\n                \n                connect_ellipse = (!clip_mode &&\n                                   prev_t1 != vec2(0) &&\n                                   length(p1 - p0) > 1e-3);\n                \n                \n                \n            }\n            \n            vec4 cur_stroke = vec4(1e5);\n            vec2 cur_t0, cur_t1;\n            \n            if (opcode == OP_L || connect_ellipse) {\n                \n                cur_stroke = line_dist(p0, p1, p);\n                \n                cur_t0 = p1 - p0;\n                cur_t0 /= max(length(cur_t0), 1e-5);\n                cur_t1 = cur_t0;\n                \n            }\n            \n            if (is_ellipse) {\n                \n                if (connect_ellipse) {\n                    \n                    miter(prev_stroke, cur_stroke, p-p0,\n                          prev_t1, -cur_t0);\n                    \n                    run = smaller_x(prev_stroke.xy, run);\n                  \n                    prev_stroke = cur_stroke;\n                    prev_t1 = cur_t1;\n                    \n                }\n                \n                cur_stroke = estroke;\n\n                p0 = p1;\n                p1 = ep1;\n                cur_t0 = et0;\n                cur_t1 = et1;\n                \n            }\n            \n            if (clip_mode) {\n                \n                dist_field = max(cur_stroke.w, dist_field);\n                prev_stroke = vec4(1e5);\n                prev_t1 = vec2(0);\n                \n            } else {\n    \n                if (prev_t1 != vec2(0) && cur_t1 != vec2(0)) {\n                \n                    miter(prev_stroke, cur_stroke, p-p0,\n                          prev_t1, -cur_t0);\n                    \n                }\n\n                run = smaller_x(prev_stroke.xy, run);\n                prev_stroke = cur_stroke;\n                prev_t1 = cur_t1;\n                                 \n            }\n            \n            p0 = p1;       \n            ellipse_corner = p1;\n            \n        }\n    }\n    \n    run = smaller_x(prev_stroke.xy, run);\n    dist_field = min(dist_field, run.y);\n    \n    vec2 clip = abs(p - 0.5*dims.xy - offs) - 0.5*dims.xy + 1.;\n    \n    clip = mix(vec2(-1e5), clip, bvec2(ivec2(clip_sym.x) & ivec2(CLIP_X, CLIP_Y)));\n    \n    dist_field = max(dist_field, max(clip.x, clip.y));\n       \n    return dist_field;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to glyph bounding box\n\nfloat glyph_bbox_dist(vec3 dims, ivec2 clip_sym, vec2 p) {\n\n    vec2 offs = vec2(0, dims.z);\n    vec2 clip = abs(p - 0.5*dims.xy - offs) - 0.5*dims.xy + 1.;\n    \n    clip -= 0.45*step(vec2( ivec2(clip_sym.x) & ivec2(CLIP_X, CLIP_Y) ), vec2(0.));\n    \n    return max(clip.x, clip.y);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// extract glyph info from uvec4\n\nvoid glyph_info(in ivec4 gdata, \n                out vec3 dims,\n                out ivec2 clip_sym) {\n   \n    ivec4 ctrl = ivec4((gdata >> 26) & 0xf);\n    ctrl.w = (ctrl.w ^ 8) - 8;\n    \n    clip_sym.x = (~(ctrl.z >> 2)) & 0x03;\n    clip_sym.y = ctrl.z & 0x03;\n    \n    dims = vec3(ctrl.xyw);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// for rendering spans of text, holds closest glyph\n\nstruct glyph_info_t {\n    vec2  pos;\n    vec4  sz;\n    ivec4 gdata;\n    vec3  dims;\n    ivec2 clip_sym;\n    float box_dist;\n};\n\n// one global one updated by functions below\nglyph_info_t g_glyph;\n    \n//////////////////////////////////////////////////////////////////////\n// initialize rendering params including userspace <-> font scaling\n\nvec4 glyph_size_info(float size, float thickness, \n                     float slant, float tracking) {\n    \n    if (tracking <= 0.) { tracking = 1.5 - thickness; }\n    float cap_height = 8. + 2.*thickness;\n    \n    return vec4(cap_height/size, slant, thickness, tracking);\n    \n}\n    \n//////////////////////////////////////////////////////////////////////\n// update closest glyph based on input    \n\nvoid glyph_update(in int c,\n                  in vec4 sz,\n                  inout vec4 gpos, \n                  in vec2 p) {\n    \n    if (c == 10 || c == 13) {\n        gpos.x = gpos.z;\n        gpos.y -= gpos.w;\n        return;\n    } else if (c < 32 || c >= 127) {\n        return;\n    }\n    \n    glyph_info_t g;\n    \n    g.pos = gpos.xy;\n    g.sz = sz;\n    g.gdata = font_data[c - 32];\n    \n    glyph_info(g.gdata, g.dims, g.clip_sym);\n\n    p = (p - g.pos) * sz.x + 1. - sz.z;\n    p.x -= sz.y * p.y;\n\n    g.box_dist = (glyph_bbox_dist(g.dims, g.clip_sym, p) - sz.z) / sz.x;\n    \n    gpos.x += (g.dims.x + 2.0*sz.z - 2. + sz.w) / sz.x;\n    \n    if (c != 32 && g.box_dist < g_glyph.box_dist) {\n        g_glyph = g;\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to closest glyph in userspace units\n\nfloat glyph_dist(glyph_info_t g, vec2 p) {\n    \n    p = (p - g.pos) * g.sz.x + 1. - g.sz.z;\n    p.x -= g.sz.y * p.y;\n    \n    return (glyph_dist(g.gdata, g.dims, g.clip_sym, p) - g.sz.z) / g.sz.x;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// iterate over 4 chars contained in one 32-bit int\n\nvoid glyph_string(in int si,\n                  in vec4 sz,\n                  inout vec4 gpos,\n                  in vec2 p) {\n        \n    \n    ivec4 idx = (ivec4(si) >> ivec4(0,7,14,21)) & 127;\n    \n    for (int j=0; j<4; ++j) {\n        if (idx[j] != 0) {\n            glyph_update(idx[j], sz, gpos, p);\n        }\n    }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// iterate over 16 chars contained in one ivec4\n\nvoid glyph_string(in ivec4 string,\n                  in vec4 sz,\n                  inout vec4 gpos, \n                  in vec2 p) {\n    \n    for (int i=0; i<4; ++i) {\n        if (string[i] != 0) {\n            glyph_string(string[i], sz, gpos, p);\n        }\n    }\n    \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}