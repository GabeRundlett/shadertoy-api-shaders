{
    "Shader": {
        "info": {
            "date": "1626392395",
            "description": "Mixing my Skid Row Lemmings Cracktro shader (https://www.shadertoy.com/view/lsKcRh) with some non-physically-based experiments on GI.",
            "flags": 96,
            "hasliked": 0,
            "id": "NlXSDS",
            "likes": 19,
            "name": "Cracktro at the partyplace",
            "published": 3,
            "tags": [
                "2d",
                "amiga",
                "projector",
                "lemmings",
                "cracktro",
                "skidrow",
                "glossiness"
            ],
            "usePreview": 0,
            "username": "merry",
            "viewed": 1183
        },
        "renderpass": [
            {
                "code": "//\tFXAA (autor: Mudlord).\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2  p         = fragCoord.xy/iResolution.xy;\n    vec2  pp        = 1.0 / iResolution.xy;\n    vec4  color     = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3  luma      = vec3(0.299, 0.587, 0.114);\n    float lumaNW    = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.,-1.)) * pp).xyz, luma);\n    float lumaNE    = dot(texture(iChannel0, (fragCoord.xy + vec2( 1.,-1.)) * pp).xyz, luma);\n    float lumaSW    = dot(texture(iChannel0, (fragCoord.xy + vec2(-1., 1.)) * pp).xyz, luma);\n    float lumaSE    = dot(texture(iChannel0, (fragCoord.xy + vec2( 1., 1.)) * pp).xyz, luma);\n    float lumaM     = dot(color.xyz, luma);\n    float lumaMin   = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax   = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2  dir       = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * (1.0/8.0)), (1.0/128.0));\n    float rcpDirMin = 2.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0), max(vec2(-8.0, -8.0), dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * \n    (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1. / 3. -.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2. / 3. -.5)).xyz\n    );\n    vec3 rgbB = rgbA * 0.5 + 0.25 * \n    (\n        texture(iChannel0, fragCoord.xy * pp + dir *-.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * .5).xyz\n    );\n\n    float lumaB = dot(rgbB, luma);\n    fragColor = vec4((lumaB < lumaMin) || (lumaB > lumaMax) ? rgbA : rgbB, color.w);\n\n    fragColor*= (1. / pow(1. + pow(length(p*2.-1.) * .3,  3.), 75.));  // Vignetting.\n    fragColor = pow((((fragColor * (.15 * fragColor + .05) + .004) / (fragColor * (.15 * fragColor + .50) + .06)) - .0667) / .6 * 3.1, vec4(.45)); // Tonemapping & Gamma correction.\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 27825,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/david-canadas-mazo/lff"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Skid Row Lemmings Cracktro Remake by merry^Architect.\n// http://www.pouet.net/prod.php?which=4021 (Pöuet).\n// https://www.youtube.com/watch?v=2YJGHcCkYEw (Youtube).\n// Coded by merry ^ Architect in 2018.\n\n// This cracktro is my favourite of all times (the music by 4mat is probably the actual reason!!!).\n// With this little tribute I wanted to make a homage to all Amiga cracktros that introduced me into the demoscene. \n\n// Common: shared definitions.\n\n#define SCR_WIDTH  320 // Amiga viewport width , in pixels.\n#define SCR_HEIGHT 256 // Amiga viewport height, in pixels.\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Skid Row Lemmings Cracktro Remake by merry^Architect.\n// http://www.pouet.net/prod.php?which=4021 (Pöuet).\n// https://www.youtube.com/watch?v=2YJGHcCkYEw (Youtube).\n// Coded by merry ^ Architect in 2018.\n\n// This cracktro is my favourite of all times (the music by 4mat is probably the actual reason!!!).\n// With this little tribute I wanted to make a homage to all Amiga cracktros that introduced me into the demoscene. \n\n// Buffer A: Mimics the Skid Row Lemmings Cracktro at its original resolution.\n// For those interested, I did the worst approach ever to the UV-to-Amiga coordinates system mapping. Too late to \n// change it now. Further cracktro remakes will do better... :)\n\nconst float kPi = 3.14159265359;\n\n// Default font.\nconst int kDefaultFont[] = int[]\n(\n\t124, 198, 198, 230, 230, 254, 124,  0, // Number 0.\n     56,  24,  24,  56,  56, 254, 254,  0, // Number 1.\n    124, 198,   6, 124, 224, 254, 254,  0, // Number 2.\n    252,   6,   6,  60,  14, 254, 252,  0, // Number 3.\n    198, 198, 198, 126,  14,  14,  14,  0, // Number 4.\n    254, 192, 192, 252,  14, 254, 252,  0, // Number 5.\n    124, 198, 192, 252, 206, 254, 124,  0, // Number 6.\n    252, 254,   6,  14,  14,  14,  14,  0, // Number 7.\n    124, 198, 198, 124, 198, 254, 124,  0, // Number 8.\n    124, 198, 198, 126,  14, 254, 124,  0, // Number 9.\n     16,  16, 254, 124,  56, 108,  68,  0, // Star.\n    124, 198, 198, 254, 230, 230, 230,  0, // A.\n    252, 198, 198, 252, 230, 254, 252,  0, // B.\n    124, 198, 192, 224, 230, 254, 124,  0, // C.\n    252, 198, 198, 230, 230, 230, 252,  0, // D.\n    126, 192, 192, 248, 224, 254, 126,  0, // E.\n    126, 192, 192, 248, 224, 224, 224,  0, // F.\n    124, 198, 192, 238, 230, 254, 124,  0, // G.\n    198, 198, 198, 254, 230, 230, 230,  0, // H.\n    254,  24,  24,  56,  56, 254, 254,  0, // I.\n     12,  12,  12,  14, 206, 254, 124,  0, // J.\n    198, 204, 216, 240, 248, 236, 230,  0, // K.\n    192, 192, 192, 224, 224, 254, 126,  0, // L.\n    238, 254, 214, 230, 230, 230, 230,  0, // M.\n\t252, 198, 198, 230, 230, 230, 230,  0, // N.\n\t124, 198, 198, 230, 230, 254, 124,  0, // O.\n    252, 198, 198, 252, 224, 224, 224,  0, // P.\n\t124, 198, 198, 230, 230, 248, 126,  0, // Q.\n    252, 198, 198, 252, 248, 236, 230,  0, // R.\n    124, 198, 192, 124,   6, 254, 252,  0, // S.   \n    254,  24,  24,  56,  56,  56,  56,  0, // T.\n    198, 198, 198, 230, 230, 254, 124,  0, // U.\n    198, 198, 198, 230, 230, 124,  56,  0, // V.\n    198, 198, 198, 214, 254, 238, 198,  0, // W.    \n    198, 198, 108,  56, 124, 230, 230,  0, // X.\n    198, 198, 198, 126,   6, 254, 252,  0, // Y.\n    254,  12,  24, 112, 224, 254, 254,  0, // Z.\n      0,   0,   0,   0,   0,  48,  48,  0, // Period.\n      0,   0,   0,  60,  60,   0,   0,  0, // Hyphen.\n     56,  56,  56,  56,   0,  56,  56,  0, // Exclamation sign.\n      0,   0,   0,   0,   0,  48, 112,112, // Comma.\n    108, 254, 254, 254, 124,  56,  16,  0, // Heart.\n      0,   0,   0,   0,   0,   0,   0,  0, // Space.\n      0\n);//kDefaultFont.\n\nconst float kCreditsSprite[] = float[]\n(\n    .9,.6,.0,.0,.0,.6,.0,.0,.9,.6,.3,.0,.9,.6,.3,.0,.0,.9,.6,.3,.0,.0,.9,.6,.0,.6,.0,.0,.0,.0,.0,.9,.6,.0,.0,.0,.9,.6,.3,.0,.0,.0,.9,.6,.3,.0,.0,.9,.6,.3,.0,.0,.0,.9,.6,.3,.3,.0,.9,.6,.0,.6,.0,.9,.6,.0,.9,.6,.3,.3,.0,.0,.9,.6,.3,.0,.0,.9,.6,.3,.3,.0,.9,.6,.3,.3,\n    .6,.3,.3,.0,.3,.3,.0,.9,.3,.0,.0,.0,.6,.3,.0,.3,.0,.6,.3,.0,.3,.0,.6,.3,.0,.3,.0,.0,.0,.0,.9,.3,.0,.3,.0,.9,.3,.0,.0,.0,.0,.0,.6,.3,.0,.3,.0,.6,.3,.0,.3,.0,.9,.3,.0,.0,.0,.0,.6,.3,.0,.3,.0,.6,.3,.0,.0,.3,.3,.0,.0,.9,.3,.0,.0,.0,.9,.3,.0,.0,.0,.0,.0,.3,.3,.0,\n    .3,.3,.3,.3,.3,.3,.0,.6,.3,.3,.3,.0,.3,.3,.3,.0,.0,.3,.3,.3,.0,.0,.3,.3,.3,.3,.0,.0,.0,.0,.6,.3,.0,.3,.0,.6,.3,.3,.0,.0,.0,.0,.3,.3,.3,.3,.0,.3,.3,.3,.0,.0,.6,.3,.0,.0,.0,.0,.3,.3,.3,.3,.0,.3,.3,.0,.0,.3,.3,.0,.0,.6,.3,.3,.0,.0,.6,.3,.0,.0,.0,.0,.0,.3,.3,.0,\n    .3,.3,.0,.3,.0,.3,.0,.3,.3,.0,.0,.0,.3,.3,.0,.3,.0,.3,.3,.0,.3,.0,.0,.3,.3,.0,.0,.0,.0,.0,.3,.3,.0,.3,.0,.3,.3,.0,.0,.0,.0,.0,.3,.3,.0,.3,.0,.3,.3,.0,.3,.0,.6,.3,.0,.0,.0,.0,.3,.3,.0,.3,.0,.3,.3,.0,.0,.3,.3,.0,.0,.3,.3,.0,.0,.0,.6,.3,.0,.0,.0,.0,.0,.3,.3,.0,\n    .3,.6,.0,.0,.0,.6,.0,.3,.3,.3,.6,.0,.3,.6,.0,.6,.0,.3,.6,.0,.6,.0,.0,.3,.6,.0,.0,.0,.0,.0,.0,.3,.6,.0,.0,.3,.6,.0,.0,.0,.0,.0,.3,.6,.0,.6,.0,.3,.6,.0,.6,.0,.0,.3,.3,.3,.6,.0,.3,.6,.0,.6,.0,.3,.3,.0,.0,.3,.6,.0,.0,.3,.3,.3,.6,.0,.0,.3,.3,.3,.6,.0,.0,.3,.6,.0\n);//kCreditsSprite.\n\n#define N0  0\n#define N1  1\n#define N2  2\n#define N3  3\n#define N4  4\n#define N5  5\n#define N6  6\n#define N7  7\n#define N8  8\n#define N9  9\n#define XX 10 // Star.\n#define A  11\n#define B  12\n#define C  13\n#define D  14\n#define E  15\n#define F  16\n#define G  17\n#define H  18\n#define I  19\n#define J  20\n#define K  21\n#define L  22\n#define M  23\n#define N  24\n#define O  25\n#define P  26\n#define Q  27\n#define R  28\n#define S  29\n#define T  30\n#define U  31\n#define V  32\n#define W  33\n#define X  34\n#define Y  35\n#define Z  36\n#define DT 37 // Period.\n#define HP 38 // Hyphen.\n#define EX 39 // Exclamation sign.\n#define CM 40 // Comma.\n#define HT 41 // Heart.\n#define _  42 // Space.\n\n#define\tCHR_WIDTH   8\n#define CHR_HEIGHT  8\n#define TXT_WIDTH\t(SCR_WIDTH  / CHR_WIDTH )\n#define TXT_HEIGHT  (SCR_HEIGHT / CHR_HEIGHT)\n#define XCR_SPEED\t80\n#define XCR_MIN_Y   11\n#define XCR_MAX_Y   28\n#define VAR_Y_POS   (SCR_HEIGHT + CHR_HEIGHT + CHR_HEIGHT)\n#define NUM_STARS\t256\n\nbool charPixel(ivec2 pixelIndex, int charIndex) { return bool(kDefaultFont[charIndex * CHR_HEIGHT + (pixelIndex.y % CHR_HEIGHT)] & (1 << (8 - (pixelIndex.x % CHR_WIDTH)))); }\n\n// The static text that appears at the top of the screen character by character.\nconst int kStaticText[] = int[]\n(\n\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , XX, _ , A , R , C , H , I , T , E , C , T , DT, _ , XX, _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Line 0 | * ARCHITECT. * \n    _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , P , R , E , S , E , N , T , S ,\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Line 1 | PRESENTS\n\t_ , _ , _ , _ , _ , _ , _ , A , N , O , T , H , E , R , _ , L , I , G , H , T , S , P , E , E , D , _ , R , E , L , E , A , S , E , _ , _ , _ , _ , _ , _ , _ , // Line 2 | ANOTHER LIGHT_ EED RELEASE\n\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ ,\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ ,\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ ,\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Line 3 | <empty>\n    _ , _ , _ , S , K , I , D , _ , R , O , W , _ , L , E , M , M , I , N , G , S , _ , C , R , A , C , K , T , R , O , _ , R , E , M , A , K , E , DT, _ , _ , _ , // Line 4 | SKID ROW LEMMINGS CRACKTRO REMAKE\n \t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ ,\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ ,\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ ,\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Line 5 | <empty>\n    _ , _ , _ , D , O , N , E , _ , B , Y , _ , M , E , R , R , Y , _ , O , F , _ , A , R , C , H , I , T , E , C , T , _ , I , N , _ , N2, N0, N1, N8, _ , _ , _ , // Line 6 | DONE BY MERRY FROM ARCHITECT IN 2018\n    C , H , E , C , K , _ , S , H , A , D , E , R , T , O , Y , DT, C , O , M , _ , F , O , R , _ , M , O , R , E , _ , F , A , N , C , Y , _ , S , T , U , F , F , // Line 7 | CHECK SHADERTOY.COM FOR MORE FANCY STUFF\n    _ , _ , _ , A , N , D , _ , O , U , R , _ , F , O , R , T , H , C , O , M , I , N , G , _ , P , R , O , D , U , C , T , I , O , N , S , DT, DT, DT, _ , _ , _ , // Line 8 | AND OUR FORTHCOMING PRODUCTIONS...\n    _ , _ , _ , S , E , E , _ , Y , O , U , _ , L , A , T , E , R , _ , I , N , _ , A , N , O , T , H , E , R , _ , I , N , T , R , O , _ , EX, EX, EX, _ , _ , _   // Line 9 | SEE YOU LATER IN ANOTHER INTRO !!!\n);//kStaticText.\n\n// The dynamic text that scrolls right to left using a sinus scroller.\nconst int kScrollingText[] = int[]\n(\n\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , \n\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , \n\tXX, _ , A , R , C , H , I , T , E , C , T , _ , XX,\n\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Text 0: * ARCHITECT *\n    HP, _ , T , H , E , _ , L , E , A , D , I , N , G , _ , F , O , R , C , E , _ , HP, \n\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Text 1: - THE LEADING FORCE - \n    I , S , _ , B , A , C , K , _ , O , N , _ , Y , O , U , R , _ , S , C , R , E , E , N , _ , W , I , T , H ,\n\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Text 2: IS BACK ON YOUR SCREEN WITH\n    XX, _ , S , K , I , D , _ , R , O , W , _ , L , E , M , M , I , N , G , S , _ , C , R , A , C , K , T , R , O , _ , \n    R , E , M , A , K , E , _ , XX, \n\t_ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Text 3: SKID ROW LEMMINGS CRACKTRO REMAKE\n    C , O , D , E , D , _ , B , Y , _ , M , E , R , R , Y , _ , O , F , _ ,\n    A , R , C , H , I , T , E , C , T , _ , I , N , _ , T , H , E , _ , Y , E , A , R , _ , O , F , _ , \n    N2, N0, N1, N8, _ , EX, EX, EX,\n    _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Text 4: CODED BY MERRY FROM ARCHITECT IN THE YEAR OF 2018\n\n    O , R , I , G , I , N , A , L , _ , C , O , D , E , _ , B , Y , _ , D , A , N , _ , O , F , _ , \n    A , N , A , R , C , H , Y , _ , XX, _ ,\n    O , R , I , G , I , N , A , L , _ , M , U , S , I , C , _ , M , O , D , U , L , E , _ ,\n    B , Y , _ , N4, M , A , T ,\n    _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Text 5: ORIGINAL CODE BY DAN OF ANACHY * ORIGINAL MUSIC MODULE BY 4MAT\n    I , F , _ , Y , O , U , _ , W , A , N , T , _ , T , O , _ , E , N , J , O , Y , _ , \n    T , H , E , _ , U , L , T , I , M , A , T , E , _ , N3, D , _ , \n    E , X , P , E , R , I , E , N , C , E , _ , I , N , _ , Y , O , U , R , _ , B , R , O , W , S , E , R , _ , \n    V , I , S , I , T , _ , S , H , A , D , E , R , T , O , Y , DT, C , O , M , _ , EX, EX, EX,\n    _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Text 6: IF YOU WANT TO ENJOY THE ULTIMATE 3D EXPERIENCE IN YOUR BROWSER VISIT SHADERTOY.COM !!!\n    G , R , E , E , T , I , N , G , S , _ , T , O , _ , A , L , L , _ , O , U , R , _ , F , R , I , E , N , D , S , _ ,\n    A , R , O , U , N , D , _ , T , H , E , _ , G , L , O , B , E , _ , EX, EX, EX,\n    _ , _ , _ , _ , _ , _ , _ , \n    HT, _ , A , L , C , A , T , R , A , Z , _ , HT, _ ,\n    A , N , A , R , C , H , Y , _ , HT, _ ,\n    A , N , G , E , L , S , _ , HT, _ ,\n    A , N , T , H , R , O , X , _ , HT, _ ,\n    B , A , M , I , G , A , _ , S , E , C , T , O , R , _ , O , N , E , _ , HT, _ ,\n    C , R , Y , S , T , A , L , _ , HT, _ ,\n    F , A , I , R , L , I , G , H , T , _ , HT, _ ,\n    H , O , R , I , Z , O , N , _ , HT, _ ,\n    L , E , M , O , N , DT, _ , HT, _ ,\n    M , E , L , O , N , _ , D , E , Z , I , G , N , _ , HT, _ ,\n    P , A , R , A , D , O , X , _ , HT, _ ,\n    P , A , R , A , N , O , I , M , I , A , _ , HT, _ ,\n    Q , U , A , R , T , E , X , _ , HT, _ ,\n    R , A , Z , O , R , _ , N1, N9, N1, N1, _ , HT, _ ,\n    R , E , D , _ , S , E , C , T , O , R , CM, _ , I , N , C , DT, _ , HT, _ ,\n    S , A , N , I , T , Y , _ , HT, _ ,\n    S , C , O , O , P , E , X , _ , HT, _ ,\n    S , K , I , D , _ , R , O , W , _ , HT, _ ,\n    S , U , P , P , L , E , X , _ , HT, _ ,\n    T , H , E , _ , S , I , L , E , N , T , S , _ , HT, _ ,\n    T , R , I , S , T , A , R , _ , HT, _ ,\n    V , I , S , I , O , N , _ , F , A , C , T , O , R , Y ,_ , HT , _ ,\n    _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Text 7: GREETINGS TO ALL OUR FRIENDS AROUND THE GLOBE !!!\n\tI , F , _ , Y , O , U , _ , U , S , E , _ , T , H , I , S , _ , \n    P , I , E , C , E , _ , O , F , _ ,\n    S , O , F , T , W , A , R , E , _ , C , A , L , L , E , D , _ , \n    S , H , A , D , E , R , T , O , Y , DT, C , O , M , _ ,\n    P , L , E , A , S , E , _ , C , O , N , S , I , D , E , R , _ , \n    C , O , N , T , R , I , B , U , T , I , N , G , _ , \n    T , O , _ , I , T , _ , O , N , _ , P , A , T , R , E , O , N , \n    _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , // Text 8: IF YOU USE THIS PIECE OF SOFTWARE CALLED SHADERTOY.COM PLEASE CONSIDER CONTRIBUTING TO IT ON PATREON\n    DT, DT, DT, _ ,\n    S , C , R , O , L , L , _ , R , E , S , T , A , R , T , S , _ ,\n    DT, DT, DT \t\t\t\t\t\t\t\t\t\t\t\t// Text 9: ... SCROLL RESTARTS ...\n);//kScrollingText.\n\nconst int kStaticTextScanColors[] = int[]\n(\n\t140,  0,  0,173, 32, 33,206, 69, 66,238,101, 99,206, 69, 66,173, 32, 33,140,  0,  0,0,0,0, // Red.\n\t140, 69,  0,173,101, 33,206,138, 66,238,170, 99,206,138, 66,173,101, 33,140, 69,  0,0,0,0, // Orange.\n    140,138,  0,173,170, 33,206,206, 66,238,239, 99,206,206, 66,173,170, 33,140,138,  0,0,0,0, // Yellow.\n      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,0,0,0, // Black.\n      0,138,  0, 33,170, 33, 66,206, 66, 99,239, 99, 66,206, 66, 33,170, 33,  0,138,  0,0,0,0, // Green.\n      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,0,0,0, // Black.\n      0, 69,140, 33,101,173, 66,138,206, 99,170,238, 66,138,206, 33,101,173,  0, 69,140,0,0,0, // Light blue.\n      0,  0,140, 33, 32,173, 66, 69,206, 99,101,238, 66, 69,206, 33, 32,173,  0,  0,140,0,0,0, // Dark  blue.\n     66,  0,140, 99, 32,173,140, 69,206,173,101,238,140, 69,206, 99, 32,173, 66,  0,140,0,0,0, // Magenta.\n    140,  0,140,173, 32,173,206, 69,206,238,101,238,206, 69,206,173, 32,173,140,  0,140,0,0,0  // Pink.        \n);//kStaticTextScanColors.\n\nfloat rand(vec2 uv) { return fract(sin(dot(uv.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\n// Palette function by iq, see more at https://www.shadertoy.com/view/ll2GD3.\nvec3  pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) { return a + b*cos(6.28318*(c*t + d)); }\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    \n    float tTime = floor(iTime/.02)*.02; // Drops down the perceived frame rate.\n    vec2  uv  = fragCoord / iResolution.xy;\n\tvec4  col = vec4(0); \n    ivec2 wx  = ivec2(fragCoord.x, fragCoord.y); // Local fragment coordinate.\n\tint   chi = int(floor(tTime * 20.));// Static text character index.\n\n    // Writes out the starfield state.\n\tvec4 sfx = vec4(0);\n    if ((wx.y == VAR_Y_POS) && (wx.x < NUM_STARS))\n\t{\n    \tif (0 == iFrame)\n\t    {//\tInitializes starfield data.\n\t\t\tcol = vec4(rand(uv), rand(uv + fragCoord.xx), float(wx.x) / float(NUM_STARS), 0);\n    \t}\n\t    else\n    \t{// Updates the starfield data.\n            vec4 displacement = vec4(sin(tTime * 1.0/0.9) * .01, sin(tTime * 1.0/1.32) * .02, sin(iTime * .25) * .01 ,0.);\n\t\t\tcol = texture(iChannel0, uv);\n\t\t\tcol+= displacement * clamp(col.z, .3, 1.);\n\t\t\tcol = mod(col,1.);            \n\t    }\n\t}\n\t\n    // Oldskool way of \"starfielding\". Really dirty but didn't want an actual 3D approach.\n    if ((wx.y < (SCR_HEIGHT - CHR_HEIGHT)) && (wx.x < SCR_WIDTH))\n    {\n        for (int i = 0; i < NUM_STARS; ++i)\n\t\t{\n            vec2 ruv = vec2(float(i) / iResolution.x, float(VAR_Y_POS + 1) / iResolution.y);\n\t\t\tvec4 rstate = texture(iChannel0, ruv);\n\n            //\tSimulates depth.\n            rstate.xy = rstate.xy * 2.  - 1. ;\n\t\t\trstate.xy*= clamp(rstate.z,.7,2.);\n\t\t\trstate.xy = rstate.xy * .5  + .5 ;\n\t\t\tif ((int(rstate.x * float(SCR_WIDTH)) == wx.x) && (int(rstate.y*float(SCR_HEIGHT)) == wx.y))\n\t\t\t{\n\t\t\t    sfx = mix(vec4(.1), vec4(1), pow(rstate.z, 2.5));\n\t\t\t    break;\n\t\t\t}            \n\t\t}\n    }\n    \n    // Top Copper-like scanline.\n\tif ((wx.x < SCR_WIDTH) && (wx.y == 1))\n\t    col = vec4(pal(uv.x + tTime*.75, vec3(.5), vec3(5), vec3(1), vec3(.0,.33,.67)), 1);\n    \n    // Static text.\n    wx.y +=-8;    \n\tif ((wx.y >= 0) && (wx.y < (CHR_HEIGHT * kStaticText.length() / TXT_WIDTH)))\n    {\n\t\tint x = wx.x / CHR_WIDTH ;\n\t\tint y = wx.y / CHR_HEIGHT;\n        int i = y * TXT_WIDTH + x;\n        \n        if ((x < TXT_WIDTH) && (y < TXT_HEIGHT) && (chi > i))\n        {\n            vec4 mul = mix(vec4(1), vec4(\n\t\t\t    kStaticTextScanColors[wx.y*3    ],\n\t\t\t    kStaticTextScanColors[wx.y*3 + 1],\n\t\t\t    kStaticTextScanColors[wx.y*3 + 2],\n\t\t\t256)/ 256., min(1.,float(chi - i) * (tTime * 10.) - float(chi)));\n\t\t\tcol = vec4(charPixel(wx, kStaticText[i])) * mul;\n        }\n    }\n\n    // Scrolling text buffer.\n    if ((wx.y >= SCR_HEIGHT) && (wx.y < SCR_HEIGHT+CHR_HEIGHT))\n    {\n\t    ivec2 zx = wx;\n        zx.x  = zx.x + int(tTime * float(XCR_SPEED));\n\t\tint x = zx.x / CHR_WIDTH ;\n\t\tint y = (zx.y) / CHR_HEIGHT - CHR_HEIGHT * TXT_HEIGHT;\n        if (((int(fragCoord.x) / CHR_WIDTH) < TXT_WIDTH) && (y < TXT_HEIGHT))\n        \tcol = vec4(charPixel(ivec2(mod(vec2(zx), vec2(CHR_WIDTH, 0))), kScrollingText[x % kScrollingText.length()]));\n    }    \n\n    // Scrolling remap to the viewport area.\n    if ((wx.x < SCR_WIDTH) && (wx.y >= CHR_HEIGHT*XCR_MIN_Y) && (wx.y <= CHR_HEIGHT*XCR_MAX_Y+CHR_HEIGHT))\n    {\n\t\tfloat vv  = ((fragCoord.y) - float(CHR_HEIGHT*XCR_MIN_Y-CHR_HEIGHT)) / float((XCR_MAX_Y - XCR_MIN_Y) * CHR_HEIGHT);\n\t\tvec4  mul = pow(vec4(.4, 0, 0, 1) * (     sin(vv * kPi * 2.)), vec4(1.0))\n\t              + pow(vec4(.6, 0, 0, 1) * (1. - sin(vv * kPi * 2.)), vec4(0.7))\n            \t  + pow(vec4(.6,.4,.2, 1) * (1. - sin(vv * kPi * 2.)), vec4(1.5));\n\n        vec2 fc   = fragCoord;\n\t\tfc.x*=.5;\n\t\tfc.y = float(SCR_HEIGHT + CHR_HEIGHT) \n\t\t     + ((fragCoord.y) - float(CHR_HEIGHT*XCR_MIN_Y+CHR_HEIGHT))*.5 \n             + (sin(tTime + tTime + tTime + tTime - fragCoord.x / float(SCR_WIDTH) * kPi * 1.5) * .25 - .25) * float((XCR_MAX_Y - XCR_MIN_Y - 1) * CHR_HEIGHT);\n\t\tif (fc.y >= float(SCR_HEIGHT+ CHR_HEIGHT) && fc.y <= float(SCR_HEIGHT + CHR_HEIGHT+ CHR_HEIGHT))\n        {        \n\t\t\tfc.y  = fc.y;\n\t\t\tcol   = texture(iChannel0, fc / iResolution.xy) * mul;\n        }\n    }\n\n    // Bottom Copper-like scanline.\n    wx.y += 8;\n\tif ((wx.x < SCR_WIDTH) && (wx.y == (SCR_HEIGHT - 1 - 8)))\n\t    col = vec4(pal(uv.x - tTime*.75, vec3(.5), vec3(5), vec3(1), vec3(.0,.33,.67)), 1);\n    \n    // Credits sprite.\n    wx.y-=SCR_HEIGHT - CHR_HEIGHT + 2;\n    wx.x-=SCR_WIDTH  - kCreditsSprite.length() / 4;\n    int limitMin     = wx.x;\n    \n\tif ((wx.y >= 0) && (wx.y < 5) && (wx.x >= 0) && (wx.x < kCreditsSprite.length()/5))\n    \tcol = vec4(kCreditsSprite[wx.y*kCreditsSprite.length()/5 + wx.x]);\n\n    if (wx.y < 0)\n    {// Mixes with the starfield.\n        col = mix(sfx, col, col.a);\n    }\n    fragColor = col;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Skid Row Lemmings Cracktro Remake by merry^Architect.\n// http://www.pouet.net/prod.php?which=4021 (Pöuet).\n// https://www.youtube.com/watch?v=2YJGHcCkYEw (Youtube).\n// Coded by merry ^ Architect in 2018.\n\n// This cracktro is my favourite of all times (the music by 4mat is probably the actual reason!!!).\n// With this little tribute I wanted to make a homage to all Amiga cracktros that introduced me into the demoscene. \n\n// Buffer B: Remaps the 320x256, 4:3 screen ratio source image to the destination viewport.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv  = fragCoord / iResolution.xy;\n    uv.x =(uv.x - ((float(SCR_HEIGHT) / float(SCR_WIDTH))- (iResolution.y / iResolution.x))*.5) * 4./3.;\n    uv.x = uv.x *   float(SCR_WIDTH ) / iResolution.x;\n    uv.y = 1. - uv.y;\n    uv.y = uv.y *   float(SCR_HEIGHT) / iResolution.y;\n    \n    if (uv.x >= 0.)\n    {\n        fragColor = floor(texture(iChannel0, uv)*16.)/16.;\n\t}\n    else\n    {\n        fragColor = vec4(0);\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Skid Row Lemmings Cracktro Remake by merry^Architect.\n// http://www.pouet.net/prod.php?which=4021 (Pöuet).\n// https://www.youtube.com/watch?v=2YJGHcCkYEw (Youtube).\n// Coded by merry ^ Architect in 2018.\n\n// This cracktro is my favourite of all times (the music by 4mat is probably the actual reason!!!).\n// With this little tribute I wanted to make a homage to all Amiga cracktros that introduced me into the demoscene. \n\n// Buffer C: Remaps the 320x256, 4:3 screen ratio source image to the destination viewport.\n// Same than Buffer B. Due to a Shadertoy limitation, it is not possible to use the same texture twice in a pass with\n// different sampler filtering. Due to this, Buffers B and C prepares the exact same output to be processed \n// as both mipmapped and nearest-neighbor samplers in Image.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv  = fragCoord / iResolution.xy;\n    uv.x =(uv.x - ((float(SCR_HEIGHT) / float(SCR_WIDTH))- (iResolution.y / iResolution.x))*.5) * 4./3.;\n    uv.x = uv.x *   float(SCR_WIDTH ) / iResolution.x;\n    uv.y = 1. - uv.y;\n    uv.y = uv.y *   float(SCR_HEIGHT) / iResolution.y;\n    \n    if (uv.x >= 0.)\n    {\n        fragColor = floor(texture(iChannel0, uv)*16.)/16.;\n\t}\n    else\n    {\n        fragColor = vec4(0);\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float i_kEpsilon   =.005 ; // Epsilon value.\nconst float i_kFov       = 2.5 ; // FOV.\nconst int   i_kSteps     = 64 ; // Raymarching steps.\nconst int   i_kStepsSec  = 32 ; // Raymarching steps for secondary rays.\nconst int   i_kStepsTri  = 32 ; // Raymarching steps for tertiary rays.\nconst float i_kNear      = 0.01  ; // Distance to the near plane.\nconst float i_kFar       = 100.; // Distance to the far  plane.\nconst float i_kPi        = 3.1415927;\nconst int   i_kNumLights = 1   ; // Number of light sources.\nconst vec3  i_kAmbientColor = vec3(.166, .406, .664);\nconst float i_kAmbientLevel =.25  ;\n \nvec2  gTexelSize   ; // Pixel size   (screen domain).\nfloat gTexelRadius ; // Pixel radius (screen domain).\nfloat gDitherLambda; // Dithering lambda.\n\n// Skid Row Lemmings Cracktro Remake by merry^Architect.\n// http://www.pouet.net/prod.php?which=4021 (Pöuet).\n// https://www.youtube.com/watch?v=2YJGHcCkYEw (Youtube).\n// Coded by merry ^ Architect in 2018.\n\n// This cracktro is my favourite of all times (the music by 4mat is probably the actual reason!!!).\n// With this little tribute I wanted to make a homage to all Amiga cracktros that introduced me into the demoscene. \n\n// Image: composes the image. Uses Buffer B for mipmapping, Buffer C for pixel-perfect sampling. Composes the image\n// by mixing different mipmap levels onto the original image, then applies some post-processing.\n\n// Uncomment SHOW_ORIGINAL_RASTERPORT to watch the rasterport without any postprocessing.\n// #define SHOW_ORIGINAL_RASTERPORT\n\n// The CRT tube distortion is driven by this parameter.\n#define CRT_FACTOR 1.1\n\n// Taken from: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// Taken from: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImageSkidRow(out vec4 fragColor, in vec2 uv)\n{\n    vec4 col = vec4(0);\n    float v  = 1.;\n    \n    // Fakes a CRT surface.\n#\tifndef SHOW_ORIGINAL_RASTERPORT    \n    uv = uv * 2. - 1.;\n    v  = length(uv);\n    uv = normalize(uv) * pow(v, CRT_FACTOR);\n    uv = uv * .5 + .5;\n#   endif//SHOW_ORIGINAL_RASTERPORT    \n\n    // Fake brightness using mipmaps.\n#\tifndef SHOW_ORIGINAL_RASTERPORT    \n    col+= clamp(pow(textureLod(iChannel2, uv, 4.), vec4(.1)), 0., 1.) * .01;\n    col+= clamp(pow(textureLod(iChannel2, uv, 3.), vec4(.1)), 0., 1.) * .01;\n    col+= clamp(pow(textureLod(iChannel2, uv, 2.), vec4(.1)), 0., 1.) * .01;\n\tcol+= clamp(textureLod(iChannel2, uv, 1.), 0., 1.) * .16;\n#   endif//SHOW_ORIGINAL_RASTERPORT    \n\tcol+= texture(iChannel3, uv);\t\n\n    vec2 coord = uv * vec2(SCR_WIDTH, SCR_HEIGHT);\n    vec2 coord2= coord;\n#   ifndef SHOW_ORIGINAL_RASTERPORT\n    coord+= vec2(iTime * 25.);\n#   endif//SHOW_ORIGINAL_RASTERPORT\n\n\t// Subpixel pattern.\n#\tifndef SHOW_ORIGINAL_RASTERPORT    \n    col*= vec4(mix(1.2, 1. - mod(coord.x     + coord.y, 3.), .12),\n\t           mix(1.2, 1. - mod(coord.x + 1.+ coord.y, 3.), .12),\n    \t       mix(1.2, 1. - mod(coord.x + 2.+ coord.y, 3.), .12), 1.);\n#   endif//SHOW_ORIGINAL_RASTERPORT    \n\n    // Some HSV correction.\n#\tifndef SHOW_ORIGINAL_RASTERPORT    \n    col = vec4(hsv2rgb(rgb2hsv(col.xyz) * vec3(.95,.95,.75)), 1);\n#   endif//SHOW_ORIGINAL_RASTERPORT    \n\n    // Scanlines & vignetting.\n#\tifndef SHOW_ORIGINAL_RASTERPORT    \n\tcol*= vec4(mix(1.2, 1. - mod(coord.y, 2.), .12));\n    col*= max (.9, 1. - pow(v,5.));\n#   endif//SHOW_ORIGINAL_RASTERPORT    \n       \n    fragColor = col;\n}\n\n//  Gets an N-dimensional random number using given argument as seed for the calculation.\n//  @in     n       Random seed.\n//  @return Resulting value.\nfloat hashi(ivec2 n) { return float((0x3504f333 * n.x * n.x + n.y) * (0xf1bbcdcb * n.y * n.y + n.x)) * (2. / 8589934592.) +.5; }\nfloat hashf(float n) { return hashi(ivec2(n)); }\nvec3  hash3(vec2  p) { return fract(sin(vec3(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)), dot(p, vec2(419.2, 371.9)))) * 43758.5453); }\n\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\nfloat n4rand_ss( vec2 n )\n{\n\tfloat nrnd0 = nrand( n + 0.07*fract( 123.456 ) );\n\tfloat nrnd1 = nrand( n + 0.11*fract( 123.456 + 0.573953 ) );\t\n\treturn 0.23*sqrt(-log(nrnd0+0.00001))*cos(2.0*3.141592*nrnd1)+0.5;\n}\n\nfloat blugausnoise2(vec2 c1) {\n    float nrand1 = n4rand_ss(c1);\n    float nrand0 = n4rand_ss(vec2(c1.x- 1.,c1.y));\n    float nrand2 = n4rand_ss(vec2(c1.x+ 1.,c1.y));\n    return 2.0* nrand1- 0.5* (nrand0+ nrand2);\n}\n\nvec4 tex_triplanar(sampler2D texID, vec3 pos, vec3 nor, vec2 bias, float k)\n{\n    vec3 m = pow(abs(nor), vec3(k));\n    m   /= m.x + m.y + m.z;\n    // Triplanar first component shall be inferred from pos.yz. Changed to pos.zy to make it work with our textures.\n    return  (texture(texID, pos.zy + bias.yx) * m.x + texture(texID, pos.zx + bias.xx) * m.y + texture(texID, pos.xy + bias.xy) * m.z);\n}\n\n//  Gets material information for the given ID and world-space data.\n//  @in     matID   Material ID.\n//  @in     pos     World-space position.\n//  @in     nor     Normal  vector.\n//  @in     t       Tangent vector. DEPRECATED.\n//  @return The material descriptor for given input data.\n//  Materials are set up using a mat4 instance. Input and output material structure is as follows:\n//      [0] Albedo    (XYZ); emissive (W).\n//      [1] Roughness   (X); fresnel  (Y); metalness (Z); SSS (W).\n//      [2] Reflectance (X).\n//      [3] Normal    (XYZ). Output only.\n//  Albedo value present at input is used as texture albedo multiplier.\nmat4 getMaterialInfo(int matID, vec3 pos, vec3 nor /*, vec3 t */)\n{\n  \tmat4 mat = mat4(0);\n    if (0 == matID)\n    {\n    \tmat[0] = vec4(.15,.15,.15,0);\n        mat[1] = vec4(.05+.75*texture(iChannel1,pos.xz*.03).x,.3,.0,.0);\n        mat[2] = vec4(.0,.0,.0,.0);\n        mat[3] = vec4(nor,     .0);\n    }\n    else\n    if (1 == matID)\n    {\n    \tmat[0] = vec4(1,1,1,.0);\n        mat[1] = vec4(.5,.3,.0,.0);\n        mat[2] = vec4(.0,.0,.0,.0);\n        mat[3] = vec4(nor,     .0);\n    }\n    else\n    if (2 == matID)\n    {\n        vec2 uv = pos.xy*vec2(.1,.2)+vec2(.5,.12);\n\t\tmainImageSkidRow(mat[0], uv.xy);\n        mat[0] = clamp(mat[0]*8., 0.03, 8.);\n        mat[0].w = 1.;\n        mat[1] = vec4(.1,.5,.0,.0);\n        mat[2] = vec4(.0,.0,.0,.0);\n        mat[3] = vec4(nor,     .0);\n    }\n    else\n    if (3 == matID)\n    {\n    \tmat[0] = vec4(8,8,8,.1);\n        mat[1] = vec4(.1,.3,.0,.0);\n        mat[2] = vec4(.0,.0,.0,.0);\n        mat[3] = vec4(nor,     .0);\n    }\n    else\n    if (8 == matID)\n    {\n    \tmat[0] = vec4(.1);\n        mat[1] = vec4(.5+.25*texture(iChannel1,pos.xy*.03).x,.3,.0,.0);\n        mat[2] = vec4(.0,.0,.0,.0);\n        mat[3] = vec4(nor,     .0);\n    }\n    return\tmat;\n}\n\n//  Gets light information for the given ID and world-space data.\n//  @in     litID   Light ID.\n//  @in     pos     World-space position.\n//  @return The light material for the given input data.\n//  Lights are set up using a mat4 instance. Output light structure is as follows:\n//      [0] Light position or direction  (XYZ); light type (W), either spot (0) or directional (1).\n//      [1] Light color (XYZ), attenuation (W).\n//      [2] -\n//      [3] (auto) Light direction (XYZ).\nmat4 getLightInfo(int litID, vec3 pos)\n{\n\tmat4 lit = mat4(0);\n    if (0 == litID)\n    {\n\t\tlit[0] = vec4(3,5, 3,0);\n        lit[1] = vec4(0);\n    }\n    lit[3].xyz = mix(normalize(lit[0].xyz - pos), lit[0].xyz, lit[0].w);\n\n\treturn  lit;\n}\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat sdSphere(vec3 p, float s) { return length(p) - s; }\nfloat sdBox   (vec3 p, vec3  b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\nfloat sdChair(vec3 p)\n{\n    float a = sdBox(p,vec3( .25,.01, .25));\n    a = min(a,sdBox(p+vec3(0, -.37, -.25),vec3(.25,.15,.02)));\n    a = min(a,sdBox(p+vec3( .25,.00,-.25),vec3(.01,.50,.01)));\n    a = min(a,sdBox(p+vec3(-.25,.00,-.25),vec3(.01,.50,.01)));\n    a = min(a,sdBox(p+vec3(-.25,.42, .25),vec3(.01,.42,.01)));\n    a = min(a,sdBox(p+vec3( .25,.42, .25),vec3(.01,.42,.01)));\n    return a;\n}\n\n#define MIN(dst, src)   dst = mix(src, dst, step(dst.x, src.x))\nvec2 mapScene(vec3 pos)\n{\n    vec2 a = vec2(i_kFar), b = vec2(i_kFar);\n\n    float q = floor(mod(iTime*.20, 4.));\n    \n    b = vec2(max(-sdBox(pos-vec3(0,4,0), vec3(5)), sdBox(pos, vec3(100))), 8); MIN(a, b);\n    b = vec2(sdBox(pos+vec3(0,.99,0), vec3(100,.01,100)), 0); MIN(a, b);\n    b = vec2(sdBox(pos+vec3(0,0,4.99), vec3(5,5,.01)), 2); MIN(a, b);\n    \n    pos.y+= .5;\n    vec2 c = pMod2(pos.xz, vec2(1, 3));\n    pR(pos.xz, hashi(ivec2(c))*.25);\n    b = vec2(sdChair(pos), 0); MIN(a, b);\n    \n    return\ta;\n}\n    \n//  Gets a rotation matrix within given direction.\n//  @in     dir     Normalized direction in scene center, ground domain (up = [0,1,0]).\n//  @in     upvec   Bias to apply to the up vector to avoid gimbal lock.\n//  @return The resulting rotation matrix.\nmat3 rotationMatrix(vec3 dir, vec3 upvec)\n{\n    vec3 cu = normalize(cross(dir , upvec));\n    return  mat3(cu, normalize(cross(cu, dir)), dir);\n}\n\n//  Calculates the ray direction to draw pixel at the given viewport UV coordinates from the given world-space position.\n//  @in     ro      World-space position within the ray starts from.\n//  @in     rd      World-space position within the ray ends.\n//  @in     uv      Viewport UV coordinates.\n//  @return The resulting ray direction.\nvec3 getCameraDir(vec3 ro, vec3 rd, vec2 uv)\n{\n    return rotationMatrix(normalize(rd - ro), vec3(i_kEpsilon, 1., i_kEpsilon)) \n        * normalize(vec3 (uv * vec2(iResolution.x / iResolution.y, 1.), i_kFov));\n}\n\n//  Gets square of \"x\".\n//  @in     x       Value to get square of.       \n//  @return Square of \"x\".\nfloat sq(float x) { return x * x; }\n\n//  Gets normal vector within a given hit.\n//  @in     pos     World position where hit was found.\n//  @return Normal vector within the hit.\n#define ZERO min(iFrame,0)\nvec3  computeNormal(const vec3 pos)\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*mapScene(pos+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\nfloat ao(vec3 ro, vec3 rd, float kk)\n{\n    float k = 1.0;\n    float d = 0.0;\n    float occ = 0.0;\n    for(int i = 0; i < 32; i++){\n        d = mapScene(ro + 0.1 * k * rd).x;\n        occ += 1.0 / pow(2.0, k) * (k * 0.1 - d);\n        k += 1.0;\n    }\n    return 1.0 - clamp(kk * occ, 0.0, 1.0);\n}\n\n//  Casts a ray along the given direction until a hit is found. Returns a vec4() with distance (X), material ID (Y). \n//  Uses \"over-relaxation raymarching\" and \"screen-space aware intersection point selection\" algorithms depicted at\n//  the  \"Enhanced Sphere Tracing\" paper by Benjamin Kelinert et al.\n//  @in     ro      Ray origin.\n//  @in     rd      Ray direction.\n//  @in     steps   Maximum ray iterations.\n//  @return Raycast result. A vec4() with total distance (X), last step distance (Y), material ID (Z), steps (W).\nvec4 castRay(vec3 ro, vec3 rd, int steps)\n{\n    float t   = i_kNear, stepLength = 0., prevRad = i_kFar, prevErr = i_kFar, err, k = 1.2;\n    vec2  res = vec2(1);\n    for (; (steps >= 0) && (t < i_kFar); --steps)\n    {\n        res = mapScene(ro + rd * t);\n        bool  sor = (k > 1.) && ((prevRad + res.x) < stepLength);\n        if (sor)\n        {\n            stepLength-= k * stepLength;\n            k = 1.;            \n        }        \n        else\n            stepLength = res.x * k;\n\n        prevRad = res.x;\n        err = res.x / t;\n        if (!sor)\n        {\n            if (err < prevErr     ) { res.x = t; prevErr = err; }\n            if (err < gTexelRadius) break;\n        }\n        t  += stepLength;\n    }\n    return vec4(t, res.xy, steps);\n}\n\n//  Lits given point.\n//  @in     pos     Surface position to lit.\n//  @in     nor     Normal  vector to the surface position to lit.\n//  @in     rd      Ray direction.\n//  @in     mat     The material descriptor to use.\n//  @return Surface color at that point.\nvec4 shadeFragment(vec3 pos, vec3 nor, vec3 rd, mat4 mat)\n{\n    vec3  col    = vec3(1), diffuse;\n    vec4  amb    = vec4(0), res;\n    float weight = 0.;\n\n    mat4 lit = getLightInfo(0, pos);\n    diffuse  = mix(mat[0].xyz * clamp(dot(mat[3].xyz, lit[3].xyz), 0., 1.) * (1. - mat[1].z), mat[0].xyz, mat[0].w);\n\n    //  Calculates the Cook-Torrance BRDF terms for a particular point in the 3D space within the given material setup  \n    //  and  light direction.\n    //  BRDF function terms used are:\n    //          * D term (isotropic  ) - GGX.\n    //          * F term (reflectance) - Schlick.\n    //          * G term (geometric  ) - Schlick approximation of Smith solved with GGX.\n \tvec3  h         = normalize   (-rd + lit[3].xyz);\n   \tfloat rsq       = max  (.001, sq(mat[1].x));\n    vec3  terms     = vec3\n    (\n        /* D Term    */ (rsq * rsq / (i_kPi * sq((sq(rsq) - 1.) * sq(clamp(dot(mat[3].xyz, h), 0., 1.)) + 1. ))),   // Isotropic GGX NDF. \n        /* F Term    */ (mat[1].y + (1. - mat[1].y  ) * (pow(1. -    clamp(dot(mat[3].xyz, lit[3].xyz), 0., 1.),  5.))),\n        /* G Term    */ sq(1. / (dot(h , lit[3].xyz) * (1. - rsq * .5) + rsq * .5))\n    );\n\tcol = diffuse * col * terms.y + mix(lit[1].xyz, vec3(1), mat[0].w) * diffuse;\n                                       \n    //  Integrates result with ambient light.\n    col    += mat[0].xyz * i_kAmbientColor * i_kAmbientLevel;\n    return  vec4(col, terms.y);\n}\n\n//  Gets a rotation matrix within given direction.\n//  @in     dir     Normalized direction in scene center, ground domain (up = [0,1,0]).\n//  @in     upvec   The up-vector.\n//  @return The resulting rotation matrix.\nmat3 rotation_matrix(vec3 dir, vec3 upvec)\n{\n    vec3 cu = normalize(cross(dir , upvec));\n    return  mat3(cu, normalize(cross(cu, dir)), dir);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tgTexelSize    = 1. / iResolution.xy;\n\tgTexelRadius  = length(gTexelSize) ;\n \tgDitherLambda = -.25 + .5 * fract(52.9829189  * fract(dot(fragCoord.xy, vec2(.06711056,.00583715))));\n    \n    vec2 uv = (fragCoord.xy + hash3(vec2(iTime*15.,iTime*.23)).x) / iResolution.xy;\n    vec2 qv = uv * 2. - 1.;\n\tvec3 pos, nor;\n    vec4 res;\n    float depth;\n\n\t// Camera setup.\n    float t = .25 * (iTime * 5. + (sin(iTime*.33)*4.+4.)), t2 = mod(iTime * .1, 4.);\n    int  scn = int(floor(mod(t2, 4.)));\n    float t3 = t2 - float(scn);\n    vec3 ro = vec3(sin(t2 * .2) * .2,1,4.8);\n    vec3 rd = getCameraDir(ro, vec3(sin(t2 * .2) * .1,1,0), qv);\n    \n    // Casts ray.\n    res = castRay(ro, rd, i_kSteps);\n    pos = ro + rd * res.x;\n    \n    // Reduces neighbors discontinuity by reprojecting hitpoint sample to be represented by a pixel on the screen.\n    float coneSize  = tan(i_kPi / 6.) / (iResolution.y);\n    float error     = 0.;\n    for (int  i = 0; i < 3; ++i)\n    {\n        pos    -= rd *    (error - mapScene(pos).x);\n        error   = coneSize * length(ro  - pos);\n    }\n    int srcMat  = int(res.z);\n    nor         = computeNormal(pos);\n    depth       = clamp (((i_kFar + i_kNear) / (i_kFar - i_kNear)) + (2. * i_kFar * i_kNear / (i_kFar - i_kNear)) /-abs(res.x), 0., 1.);\n\tmat4 mat    = getMaterialInfo(srcMat, pos, nor);\n    fragColor   = shadeFragment(pos, nor, rd, mat);\n    \n    float pdf;\n    mat3 mm;\n    vec2 hm;\n    pdf = fragColor.a;\n    vec4 dif =(1.-mat[1].z)*vec4(mat[0].xyz, 1);\n    vec4 dif2=vec4(mat[0].xyz,1);\n\n\tvec3 p2 = pos, n2 = nor, r2 = ro, d2 = rd;    \n\tfloat aa = mat[1].x * mat[1].x, metallic = mat[1].z;\n\tvec4 col = vec4(0);\n\tmat4 m2 = mat;\n\n    float att = 1.,att2=.5;\n    for (int i = 0; srcMat != 2 && i < 1; ++i)\n    {\n\t    ro = pos + nor * .01;\n\t    rd = nor;\n\t    if (mat[2].y > 0.)\n\t    {\t\n        ro = pos - nor * .01;\n\t        rd = refract(-rd, nor, mat[2].y);\n\t    }\n\t\trd+= abs(hash3(vec2(float(iTime*.01) / 512., hash3(uv + iTime*.01))))*1.-.5;\n\t    rd = normalize(rd);\n\t    res = castRay(ro, rd, i_kStepsSec);\n\t    pos = ro + rd * res.x;\n\t    nor         = computeNormal(pos);\n\t    depth       = clamp (((i_kFar + i_kNear) / (i_kFar - i_kNear)) + (2. * i_kFar * i_kNear / (i_kFar - i_kNear)) /-abs(res.x), 0., 1.);\n\t\tmat         = getMaterialInfo(int(res.z), pos, nor);\n\t\tcol+= att*dif*mix(mat[0].xyz * clamp(dot(mat[3].xyz, d2), 0., 1.) * (1. - mat[1].z), mat[0].xyz, mat[0].w).xyzz*((3.-float(i))/3.);\n\t\tatt*=att2;\n    }\n    fragColor = mix(fragColor, col, .5);    \n    \n\tpos=p2;nor=n2;ro=r2;rd=d2;\n\tcol = vec4(0);\n    att=1.;\n    \n    for (int i = 0; srcMat != 2 && i < 2; ++i)\n    {\n\t    ro = pos + nor * .001;\n\t    rd = reflect(rd, nor);\n\t\trd*= mix(vec3(1),abs(hash3(vec2(float(iTime*.01) / 512., hash3(uv + iTime*.01)))),aa)*1.-.5;\n\t    rd = normalize(rd);\n\t    res = castRay(ro, rd, i_kStepsTri);\n\t    pos = ro + rd * res.x;\n\t    nor         = computeNormal(pos);\n\t    depth       = clamp (((i_kFar + i_kNear) / (i_kFar - i_kNear)) + (2. * i_kFar * i_kNear / (i_kFar - i_kNear)) /-abs(res.x), 0., 1.);\n\t\tmat         = getMaterialInfo(int(res.z), pos, nor);\n\t    vec4 sf = shadeFragment(pos, nor, rd, mat);\n\t    col+= att*mix(col, (mix(vec4(1),dif2,metallic))*sf*pdf,.5)*((3.-float(i))/3.);\n\t    pdf = sf.a;\n\t\taa = mat[1].x * mat[1].x;\n\t\tatt*=att2;\n    }\n    float m=((2==srcMat)?.7:.05);\n    fragColor = mix(fragColor, col, .5)*m+texture(iChannel0,fragCoord.xy/iResolution.xy)*(1.-m);    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}