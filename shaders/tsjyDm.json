{
    "Shader": {
        "info": {
            "date": "1586793319",
            "description": "Weighted normal blending using @ZigguraVertigo test shader.",
            "flags": 0,
            "hasliked": 0,
            "id": "tsjyDm",
            "likes": 7,
            "name": "Weighted Normal Blending",
            "published": 3,
            "tags": [
                "normals"
            ],
            "usePreview": 0,
            "username": "Donzanoid",
            "viewed": 484
        },
        "renderpass": [
            {
                "code": "\nvec4 RotationBetween(vec3 v0, vec3 v1)\n{\n    // Shortest arc\n    float d = dot(v0, v1);\n    float s = sqrt((1.0 + d) * 2.0);\n    float invs = 1.0 / s;\n    vec3 c = cross(v1, v0);\n    return vec4(c.xyz * invs, 0.5 * s);\n}\n\nvec4 RotationFromZ(vec3 v1)\n{\n    // Shortest arc from <0, 0, 1>\n    int x = floatBitsToInt(2.0 + v1.z * 2.0);\n    //x = 0x1FBD1DF5 + (x >> 1);\n    // rsqrt from Robin's new math paper, allows one less div\n    x = 0x5F37624F - (x >> 1);\n    float s = intBitsToFloat(x);\n    //return vec4(v1.y / s, -v1.x / s, 0.0, 0.5 * s);\n    return vec4(v1.y * s, -v1.x * s, 0.0, 0.5 / s);\n}\n\nvec4 nlerp(vec4 q0, vec4 q1, float t)\n{\n    return normalize(mix(q0, q1, t));\n}\n\nvec4 fnlerp(vec4 l, vec4 r, float t)\n{\n\tfloat ca = dot(l, r);\n\tfloat k = 0.931872f + ca * (-1.25654f + ca * 0.331442f);\n\tfloat ot = t + t * (t - 0.5f) * (t - 1.0) * k;\n    return normalize(mix(l, r, ot));\n}\n\nvec4 slerp(vec4 a, vec4 b, float t)\n{\n    // Get half-angle between quaternions\n    float cos_theta = clamp(dot(a, b), -1.0, 1.0);\n    float theta = acos(cos_theta);\n    float sin_theta = sqrt(1.0 - cos_theta * cos_theta);\n\n    // Slerp\n    float t0 = sin((1.0 - t) * theta) / sin_theta;\n    float t1 = sin(t * theta) / sin_theta;\n    vec4 r;\n    r.x = a.x * t0 + b.x * t1;\n    r.y = a.y * t0 + b.y * t1;\n    r.z = a.z * t0 + b.z * t1;\n    r.w = a.w * t0 + b.w * t1;\n    return r;\n}\n\nvec3 Transform(vec4 q, vec3 v)\n{\n    return v * (q.w * q.w - dot(q.xyz, q.xyz)) + 2.0 * q.xyz * dot(q.xyz, v) + 2.0 * q.w * cross(q.xyz, v);\n    //return v + 2.0 * cross(q.xyz, q.w * v + cross(q.xyz, v));\n}\n\nvec3 TransformZ(vec4 q)\n{\n    // Transforming <0,0,1> by q where q.z = 0 for tangent-space normal\n    vec3 r;\n    r.x = -2.0 * q.w * q.y;\n    r.y =  2.0 * q.w * q.x;\n    r.z =  q.w * q.w - dot(q.xy, q.xy);\n    return r;\n    \n    // c = cross(a, b)\n    // c.x = a.y * b.z - b.y * a.z\n    // c.y = a.z * b.x - b.z * a.x\n    // c.z = a.x * b.y - b.x * a.y\n}\n\nvec3 NormalBlend(vec3 n1, vec3 n2, float t)\n{\n    n1 = n1 * 2.0 - 1.0;\n    n2 = n2 * 2.0 - 1.0;\n    \n    //return n1;\n    \n    //return normalize(mix(n1, n2, 0.8));\n    \n    #if 1\n    \n    //vec4 q1 = RotationBetween(vec3(0.0, 0.0, 1.0), n1);\n    vec4 q1 = RotationFromZ(n1);\n        \n    //vec4 q2 = RotationBetween(vec3(0.0, 0.0, 1.0), n2);\n    vec4 q2 = RotationFromZ(n2);    \n    \n    vec4 qa = nlerp(q1, q2, t);\n    vec4 qb = fnlerp(q1, q2, t);\n    vec4 qc = slerp(q1, q2, t);\n    \n    //vec4 d = qc - qb;\n    //return vec3(abs(dot(d, d)) * 10000.0);\n    \n    //return Transform(qa, vec3(0.0, 0.0, 1.0));\n    return TransformZ(qa);\n    \n    #else\n    \n    vec4 q = RotationBetween(n1, n2);\n    \n    //vec4 qr = slerp(vec4(0.0, 0.0, 0.0, 1.0), q, 0.2);\n    vec4 qr = nlerp(vec4(0.0, 0.0, 0.0, 1.0), q, 1 - t);\n    \n    if (abs(qr.w) < 0.001) return vec3(1.0);\n    \n    //qr.z = 0.0;\n    \n    vec3 p = Transform(qr, n2);\n    \n    return p;\n    \n    #endif\n}\n\n\n// Compute base normal (since we don't have a texture)\nvec3 ComputeBaseNormal(vec2 uv) \n{\n    uv = fract(uv) * 2.0 - 1.0;    \n        \n    vec3 ret;\n    ret.xy = sqrt(uv * uv) * sign(uv);\n    ret.z = sqrt(abs(1.0 - dot(ret.xy,ret.xy)));\n    \n    ret = ret * 0.5 + 0.5;\n    return mix(vec3(0.5,0.5,1.0), ret, smoothstep(1.0,0.95,dot(uv,uv)));\n}\n\n// Compute a detail normal (since we don't have a texture)\nvec3 ComputeDetailNormal(vec2 uv)\n{\n    const vec4 avgRGB0 = vec4(1.0/3.0, 1.0/3.0, 1.0/3.0, 0.0);\n    const float scale = 0.02;\n    const vec2 du = vec2(1.0/512.0, 0.0);\n    const vec2 dv = vec2(0.0, 1.0/512.0);\n\n    float h0  = dot(avgRGB0, texture(iChannel0, uv)) * scale;\n    float hpx = dot(avgRGB0, texture(iChannel0, uv + du)) * scale;\n    float hmx = dot(avgRGB0, texture(iChannel0, uv - du)) * scale;\n    float hpy = dot(avgRGB0, texture(iChannel0, uv + dv)) * scale;\n    float hmy = dot(avgRGB0, texture(iChannel0, uv - dv)) * scale;\n    \n    float dHdU = (hmx - hpx) / (2.0 * du.x);\n    float dHdV = (hmy - hpy) / (2.0 * dv.y);\n    \n    return normalize(vec3(dHdU, dHdV, 1.0)) * 0.5 + 0.5;\n}\n//---------------------------------------------------------------------------------------------\n// Main\n//---------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 uv = fragCoord.xy / iResolution.x;\n    \n    //---------------------------------------------------------------------------------------------------------\n    // [LEFT SIDE] - Combined normal, switches between technique\n    //---------------------------------------------------------------------------------------------------------\n    // Base Normal (Disk)\n    vec2 uvN = uv * (iResolution.x / iResolution.y) * 1.2 - vec2(0.12, 0.16);\n\n  \tvec3 BN = vec3(0.5, 0.5, 1.0);\n    if (uvN.x > 0.0 && uvN.x < 0.83 && uvN.y < 0.83 && uvN.y > 0.0)\n    {\n        BN = ComputeBaseNormal(uvN * vec2(1.2,1.2));\n    }\n    \n    // Detail Normal\n\tvec2 uvDN = uvN;\n    vec3 n1 = ComputeDetailNormal(uvDN);\n    \n    float t = 0.5;\n    t = fract(iTime * 0.1);\n \n\t// Combined Normal\n    vec3 N = NormalBlend(BN, n1, t);\n\n    //---------------------------------------------------------------------------------------------------------\n    // [RIGHT SIDE] - Combined normal with lighting, switches between technique\n    //---------------------------------------------------------------------------------------------------------\n    // Base Normal (Disk)\n    uvN = (uv + vec2(0.28, 0.0)) * (iResolution.x / iResolution.y) * 1.2 - vec2(0.12, 0.16);\n\n  \tBN = vec3(0.5, 0.5, 1.0);\n    if (uvN.x > 1.66 && uvN.y > 0.0 && uvN.y < 0.83 && uvN.x < 2.50)\n    {\n        BN = ComputeBaseNormal(uvN * vec2(1.2,1.2));\n    }\n    \n    // Detail Normal\n\tuvDN = uvN+vec2(0.33,0);\n    n1 = ComputeDetailNormal(uvDN);\n \n\t// Combined Normal\n    vec3 N2 = NormalBlend(BN, n1, t);\n   \t\n\tvec3 light = normalize(vec3(1.0, 0.0, 1.0));    \n    vec3 lit = vec3(clamp(dot(light, N2), 0.0, 1.0));\n\n    // Mix normal and lit result\n\tvec3 color = mix(N*0.5 + 0.5, lit, float(uv.x > 0.5));\n\n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}