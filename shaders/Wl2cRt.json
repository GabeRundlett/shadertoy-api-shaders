{
    "Shader": {
        "info": {
            "date": "1595101811",
            "description": "A dumb fluid sim WIP\n\ndon't run:\ngShaderToy.SetTexture(2, {mSrc:'https://i.ibb.co/pRvFNJf/circles1.png', mType:'texture', mID:1, mSampler:{ filter: 'nearest', wrap: 'clamp', vflip:'true', srgb:'false', internal:'byte' }});\nwith Buffer B selected",
            "flags": 32,
            "hasliked": 0,
            "id": "Wl2cRt",
            "likes": 0,
            "name": "fluidity",
            "published": 3,
            "tags": [
                "fluid"
            ],
            "usePreview": 0,
            "username": "DaMastaCoda",
            "viewed": 331
        },
        "renderpass": [
            {
                "code": "//display\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    // fragColor = vec4(col,1.0);\n    //fragColor = vec4(texture(iChannel1, uv).bbb,0.0);\n    fragColor = vec4(texture(iChannel0, uv).rgb,0.0);\n    vec3 samp = texture(iChannel0, uv).rgb;\n    \n    //fragColor = vec4(hsv2rgb(vec3(samp.rg,1.0)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "struct fluid {\n\tpolar coord;\n    float amount;\n};\n\nvec4 tex(sampler2D te, vec2 coord, vec2 offset) {\n \treturn texture(te, (coord+offset)/iResolution.xy);   \n}\n\nvec4 tex(sampler2D te, vec2 coord) {\n    return tex(te, coord, vec2(0,0));\n}\n\nfluid toFluid(vec4 inp) {\n\treturn fluid(polar(inp.r,decompressS(inp.g)),decompressS(inp.b));    \n}\n\nvec4 fromFluid(fluid inp) {\n    return vec4(inp.coord.angle,compressS(inp.coord.radius),compressS(inp.amount),1.0);\n}\n\n//sim\n\nvoid applyStuff(inout fluid me, vec2 coord, vec2 offset) {\n    \n    \n}\n\nvoid applyStuffb(inout fluid me, vec2 coord, vec2 offset) {\n    \n    fluid side01 = toFluid(tex(iChannel0, coord, offset));\n    \n        float transferRate = dot(toCart(side01.coord)/side01.coord.radius, -offset);\n        if(transferRate > 0.0) {\n            me.amount += transferRate * side01.coord.radius;\n            me.coord = toPolar(toCart(me.coord)+toCart(side01.coord)*transferRate);\n        }\n        if(transferRate < 0.0) {\n            \n            me.amount += transferRate * me.coord.radius;\n            me.coord = toPolar(toCart(me.coord)+toCart(me.coord)*transferRate);\n            \n        }\n\n}\n\nfloat rand(vec4 seed) {\n    return sin(seed.x*5443435345.34235+seed.y*45435343452.435345)/2.0+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //each px holds dir 0..1, radius 0..*, value: 0..*\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fluid oldMe = toFluid(tex(iChannel0, fragCoord));\n    \n    if(iFrame == 0) {\n     \t//oldMe.amount = rand(vec4(fragCoord.x, fragCoord.y,0.0,0.0));\n     \toldMe.coord.radius = 0.0;\n     \toldMe.coord.angle = 0.0;\n    fragColor = fromFluid(oldMe);\n        fragColor = vec4(1.0,0.0,0.0,1.0);\n        return;\n    }\n    \n    if(texture(iChannel1, fragCoord/iResolution.xy).r==1.0){\n        oldMe.amount = 0.0;\n     \toldMe.coord.radius = 0.0;\n     \toldMe.coord.angle = 0.0;\n    fragColor = fromFluid(oldMe);\n        fragColor = vec4(0.0,1.0,0.0,1.0);\n        return;\n        \n    }\n    \n   \t\n    vec4 src =texture(iChannel1, fragCoord/iResolution.xy);\n    src.g;\n    if(src.y>0.5){\n        oldMe.amount = 1.0;\n     \toldMe.coord.radius = 1.0;\n     \toldMe.coord.angle = texture(iChannel1, fragCoord/iResolution.xy).b;\n    fragColor = fromFluid(oldMe);\n        fragColor = vec4(0.0,src.y>0.5,src.y,1.0);\n        return;\n        \n    }\n    \n    // Output to screen\n    //move\n    \n    //vel.angle = mod(vel.angle+0.01,1.0);\n    //vel.radius = mod(vel.radius+0.1,2.0);\n    //applyStuff(oldMe,fragCoord,vec2(0,-1));\n    //applyStuff(oldMe,fragCoord,vec2(-1,-1));\n    //applyStuff(oldMe,fragCoord,vec2(-1,0));\n    //applyStuff(oldMe,fragCoord,vec2(-1,-1));\n    //applyStuff(oldMe,fragCoord,vec2(0,1));\n    //applyStuff(oldMe,fragCoord,vec2(1,1));\n    //applyStuff(oldMe,fragCoord,vec2(1,0));\n    //applyStuff(oldMe,fragCoord,vec2(1,-1));\n    \n    \n\tvec2 around = vec2(0, 0);\n    \n/*\naround += toCart(toFluid(tex(iChannel0, fragCoord, vec2(+0,-1))).coord);\naround += toCart(toFluid(tex(iChannel0, fragCoord, vec2(-1,-1))).coord);\naround += toCart(toFluid(tex(iChannel0, fragCoord, vec2(-1,+0))).coord);\naround += toCart(toFluid(tex(iChannel0, fragCoord, vec2(-1,-1))).coord);\naround += toCart(toFluid(tex(iChannel0, fragCoord, vec2(+0,+1))).coord);\naround += toCart(toFluid(tex(iChannel0, fragCoord, vec2(+1,+1))).coord);\naround += toCart(toFluid(tex(iChannel0, fragCoord, vec2(+1,+0))).coord);\naround += toCart(toFluid(tex(iChannel0, fragCoord, vec2(+1,-1))).coord);\n*/\n    float times = 0.0;\n    #define Blur 1.0\n    for(float xoff = -1.0 * Blur; xoff <= Blur; ++xoff) {\n        for(float yoff = -1.0 * Blur; yoff <= Blur; ++yoff) {\n            vec2 match = toCart(toFluid(tex(iChannel0, fragCoord, vec2(xoff,yoff))).coord);\n\t\t\taround += match;\n                       \n        }\n    }\n    around *= 1.0 / length(around);\n    \n\n\toldMe.coord = toPolar(around);\n    \n    \n    \n    // update vel\n    \n    //vel = toPolar(uv-vec2(0.5,0.5));\n    \n    \n    //fragColor = vec4(0, pol.radius/3.0,0,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Stores image for sim\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel2, fragCoord/iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "precision highp float;\n#define M_PI 3.1415926535897932384626433832795\n\nstruct compressed {\n    float compressedValue;\n};\n\nstruct polar {\n    float angle;\n    float radius;\n};\n    \nvec2 toCart(polar pol) {\n    return vec2(cos((pol.angle-0.5)*2.0*M_PI), sin(pol.angle)) * pol.radius;\n}\n\npolar toPolar(vec2 xy) {\n    if(xy.x == 0.0 && xy.y == 0.0) {\n        return polar(0.0,0.0);\n    }\n    \n    return polar(atan(xy.y, xy.x)/(M_PI*2.0)+0.5, sqrt(xy.x * xy.x + xy.y * xy.y));\n}\n\nfloat compressS(float inp) {\n    return 1.0-(1.0/(inp+1.0));\n}\n\ncompressed compress(float inp) {\n    return compressed(compressS(inp));\n}\n\nfloat decompressS(float inp) {\n    return -1.0-(1.0/(inp-1.0));\n}\n\nfloat decompress(compressed inp) {\n    return decompressS(inp.compressedValue);\n}\n\n\n// credit to http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}