{
    "Shader": {
        "info": {
            "date": "1528236117",
            "description": "moon, ocean, terrain, stars, text, poem, haiku\n\nFour camera takes, 70s time in total.",
            "flags": 32,
            "hasliked": 0,
            "id": "ldyBWR",
            "likes": 14,
            "name": "To the pretty sky it flies --",
            "published": 3,
            "tags": [
                "terrain",
                "text",
                "ocean",
                "stars",
                "moon",
                "haiku",
                "poem"
            ],
            "usePreview": 1,
            "username": "gambhiro",
            "viewed": 1311
        },
        "renderpass": [
            {
                "code": "/*\n\n  To the pretty sky it flies\n  --------------------------\n\n  https://www.shadertoy.com/view/ldyBWR\n\n  > moon in the autumn dawn\n  > to the pretty sky it flies\n  > a mosquito\n  >\n  > - Issa\n\n  (Tr. by David G. Lanoue, http://haikuguy.com/)\n\n  moon, ocean, terrain, stars, text, haiku\n\n  The overall picture is composed for specific camera angles.\n\n  Writing this shader could not have been possible without:\n\n  - Dry Rocky Gorge by Shane                 https://www.shadertoy.com/view/lslfRN\n  - Seascape by TDM                          https://www.shadertoy.com/view/Ms2SD1\n  - Seascape Documented by bteitler          https://www.shadertoy.com/view/llsXD2\n  - Gavoronoise by guil                      https://www.shadertoy.com/view/llsGWl\n  - Mercury craters by guil                  https://www.shadertoy.com/view/llSGRw\n  - Shadertext proportional spacing by Andre https://www.shadertoy.com/view/4s3XDn\n  - Jack-o'-lantern's Revenge by P_Malin     https://www.shadertoy.com/view/Mt2yzK\n  - ... and iq's irreplaceable examples.\n\n  Thank you for sharing your knowledge of this art.\n\n*/\n\n// image composition pass\n\n#define i_time iTime\n#define i_resolution iResolution\n\n#define tex_text iChannel0\n#define tex_raymarch iChannel1\n#define tex_bloom iChannel2\n\nvec4 sample_bloom(vec2 uv);\nvec3 print_line(int line, float width, vec2 offset, vec2 uv);\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  vec3 col = vec3(0.0);\n\n  // --- Camera Takes ---\n\n  float flash, txt1, txt2, txt3 = 0.0;\n\n  float t, t0, t1 = 0.;\n  // four camera takes: 20s, 20s, 20s, 10s\n  t = mod(i_time, 70.0);\n\n  if (t < 20.0) {\n\n    // Take 1.\n    // looking into the bay, low and out\n\n    t0 = 0.; t1 = 20.;\n    txt1 = smoothstep(t0, t1-5., t); txt2 = 0.0; txt3 = 0.0;\n\n  } else if (t < 40.) {\n\n    // Take 2.\n    // the sky with moon behind spaceship\n\n    t0 = 20.; t1 = 40.;\n    txt1 = 1.0; txt2 = smoothstep(t0, t1-5., t); txt3 = 0.0;\n\n  } else if (t < 60.) {\n\n    // Take 3.\n    // looking at the spaceship\n\n    t0 = 40.; t1 = 60.;\n    txt1 = 1.0; txt2 = 1.0; txt3 = smoothstep(t0, t1-5., t);\n\n  } else if (t < 70.) {\n\n    // Take 4.\n    // spaceship in the light\n\n    t0 = 60.; t1 = 70.;\n    txt1 = 0.0; txt2 = 0.0; txt3 = 0.0;\n    // a 3s flash at the end of the last take\n    flash = smoothstep(t1-3., t1-.5, t);\n\n  }\n\n  // --- Scene ---\n\n  // sampling in texture plane, (0,0) is lower-left, (1,1) is top-right\n  vec2 uv = frag_coord.xy / i_resolution.xy;\n  col = texture(tex_raymarch, uv).rgb;\n\n  // --- Bloom ---\n\n  vec3 bloom = 0.0\n    + sample_bloom(uv).rgb * 0.5\n    + sample_bloom((uv - 0.025) * 0.95 + 0.045).rgb * 0.25\n    + sample_bloom((uv + 0.025) * 0.95).rgb * 0.125;\n\n  col += bloom * 0.5;\n\n  // --- Flash ---\n\n  col = mix(col, vec3(1.), flash);\n\n  // --- Gamma ---\n\n  col = pow(col, vec3(2.01)); // stronger colours\n  col = vec3(1.0) - exp(-col * 1.5); // exposure hdr\n  col = pow(col, vec3(1.0/2.2)); // gamma\n\n  // --- Text Overlay ---\n\n  vec2 o = vec2(0.65, 0.5);\n  float sc = 1.9;\n  col += txt1 * print_line(2, sc, o, uv);\n  col += txt2 * print_line(3, sc, o, uv);\n  col += txt3 * print_line(4, sc, o, uv);\n  col += txt3 * print_line(6, sc, o, uv);\n\n  frag_color = vec4(col, 1.0);\n}\n\nvec4 sample_bloom(vec2 uv) {\n  vec2 bloom_size = i_resolution.xy / 4.0;\n  vec4 col = textureLod(tex_bloom, uv * bloom_size / i_resolution.xy, 0.0).rgba;\n  return col;\n}\n\nvec3 print_line(int line, float scale, vec2 offset, vec2 uv) {\n  vec3 col = vec3(0.);\n\n  float r = i_resolution.x / i_resolution.y;\n  vec2 txt_uv = (uv - offset) * scale;\n  float lh = 1.0/10.0; // line height\n\n  if (txt_uv.x < (1.0/r) && txt_uv.x > 0.0 &&\n      txt_uv.y < (1.0 - float(line)*lh) && txt_uv.y > (1.0 - float(line+1)*lh)) {\n\n    txt_uv.x *= r;\n    vec3 txt = texture(tex_text, txt_uv).rgb;\n\n    vec2 eps = vec2(0.001);\n    txt += texture(tex_text, txt_uv + eps).rgb;\n    txt += texture(tex_text, txt_uv - eps).rgb;\n    txt /= 3.0;\n    col += vec3(1.0) - txt;\n  }\n\n  return col;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// sky texture\n\n#define i_resolution iResolution\n#define i_time iTime\n\n#define SPEED 0.02\n\n// globals\nvec3 g_world_up  = vec3(0.0, 1.0, 0.0);\nvec4 g_moon_sph  = vec4(1.9, 2.0, 0.0, 2.0);\n\nvec3 g_camera_pos    = vec3(0.0, 0.0, -25.0);\nvec3 g_camera_lookat = vec3(2.0, -2.5, 0.0);\nvec3 g_light_pos     = vec3(6.0, -2.0, -9.0);\n\nbool g_show_moon = true;\nfloat g_more_light = 0.0;\nfloat g_waves = 0.0;\n\nconst float PI  = 3.14159265359;\nconst float TWO_PI = 2.0*PI;\nconst float HALF_PI = 0.5*PI;\n\n// function signatures\nmat3 rot_xy(vec2 angle);\nvec3 calc_normal_craters(vec3 pos);\nvec3 nor_sphere(vec3 pos, vec4 sph);\nfloat i_sphere(vec3 ro, vec3 rd, vec4 sph);\n\nvec3 material_color(vec3 ro, vec3 rd, float mat_id, float d);\nfloat map(vec3 p);\n\nvec3 checker_board(vec2 uv);\n\n// === Implementations =========================================================\n\nfloat hash( in vec3 p ) {\n  return fract(sin(p.x*15.32758341+p.y*39.786792357+p.z*59.4583127+7.5312) * 43758.236237153)-.5;\n}\n\nvec3 hash3( in vec3 p ) {\n  return vec3(hash(p),hash(p+1.5),hash(p+2.5));\n}\n\nfloat voronoi(in vec3 p) {\n  vec3 ip = floor(p);\n  vec3 fp = fract(p);\n  float rid = -1.;\n  vec2 r = vec2(2.);\n  for (int i=-1; i<=0; i++)\n    for (int j=-1; j<=0; j++)\n      for (int k=-1; k<=0; k++) {\n        vec3 g = vec3(i, j, k);\n        vec3 pp = fp +g +hash3(ip - g)*.6;\n        float d = dot(pp, pp);\n\n        if (d < r.x) {\n          r.y = r.x;\n          r.x = d;\n        } else if(d < r.y) {\n          r.y = d;\n        }\n      }\n  return r.x;\n}\n\nfloat craters(vec3 p) {\n  float v = voronoi(p);\n  return sin(sqrt(v)*TWO_PI)*exp(-4.*v);\n}\n\nfloat fbmabs(vec3 p, int steps) {\n  float f = 1.30;\n  float r = 0.0;\n  for(int i=0; i<steps; i++){\n    r += abs(craters(p*f))/f;\n    f *= 2.9;\n  }\n  return r;\n}\n\nfloat stars(vec3 p){\n  float res, v = 0.0;\n\n  // just two layers, so we're not looping\n  // f = 1.0\n  v = voronoi(p);\n  res += pow(exp(0.075 - 15.0*v), 16.0)*0.35;\n\n  float f = 2.5;\n  v = voronoi(p*f)/f;\n  res += pow(exp(0.075 - 15.0*v), 12.0)*0.35;\n\n  return res;\n}\n\n// a voronoi noise crater heightmap used for the specular normal\nfloat map(vec3 p) {\n  return fbmabs(p, 2)*0.7 + fbmabs(p, 5)*0.3;\n}\n\n// sky background gradient based on the ray direction\nvec3 sky_color(vec3 rd, bool show_stars) {\n  vec3 sky_top = vec3(0.090, 0.180, 0.211)*0.7; // rgb(23, 46, 54) #172E36\n  vec3 sky_bottom = vec3(0.921, 0.698, 0.600); // rgb(235, 178, 153) #EBB299\n  vec3 sky_star = vec3(0.133, 0.952, 0.980);// rgb(34, 243, 250) #22F3FA\n\n  float a = g_more_light;\n  rd.y += 0.2 - a;\n\n  vec3 col = vec3(0.);\n  float horiz = 1. - clamp(max(rd.y, 0.0), 0., 1.);\n  col += sky_bottom*exp(horiz*10.0 - 10.0);\n\n  float sun = clamp(dot(normalize(g_light_pos*vec3(1., 1., -1)), rd), 0., 1.);\n  col += 0.8*sky_bottom*exp(sun*15.0 - 15.0);\n  col = sky_top + pow(col, vec3(1.5));\n\n  if (show_stars) {\n    float c = stars(40.0*rd + vec3(.0, .0, .1));\n\n    // scintillate\n    float w = hash3(rd + vec3(i_time*0.5)).x;\n    sky_star *= abs(w)*3.0;\n\n    vec3 stars = vec3(c, pow(c, 4.0), pow(c, 4.0)) * sky_star * smoothstep(0.0, 0.42, rd.y);\n    col += stars;\n  }\n\n  // vertical sinus waves\n  float w = 0.0 +\n    0.1*sin(rd.x*80.0 + i_time*0.9) +\n    0.1*cos(rd.x*120.0 - i_time*1.5) +\n    0.1*sin(rd.x*200.0 + i_time*1.2) +\n    0.1*cos(rd.x*250.0 - i_time*1.5);\n  vec3 wave = 0.6 * vec3(w);\n  col -= g_waves * wave;\n\n  return col;\n}\n\nvec3 material_color(vec3 ro, vec3 rd, float mat_id, float d) {\n  vec3 final_col = vec3(0.0);\n\n  vec3 bg_base_solid = sky_color(rd, false);\n  vec3 bg_base_stars = sky_color(rd, true);\n\n  if (mat_id == 1.0) {\n\n    // checker board pattern\n    vec3 pos = ro+rd*d;\n    final_col = checker_board(pos.xz);\n\n  } else if (g_show_moon && mat_id == 2.0) {\n\n    // Moon\n\n    vec3 pos = ro+rd*d;\n    vec3 nor = nor_sphere(pos, g_moon_sph);\n\n    vec3 diffuse_color = vec3(1.1);\n\n    vec3 col = diffuse_color;\n\n    vec3 light_dir = normalize(g_light_pos - pos);\n    float diff = max(dot(nor, light_dir), 0.0);\n    vec3 view_dir = normalize(ro - pos);\n    vec3 halfway_dir = normalize(light_dir + view_dir);\n\n    vec3 spec_nor = calc_normal_craters(pos);\n    float spec = pow(max(dot(spec_nor, halfway_dir), 0.0), .3);\n\n    col = pow(col*0.8 + col*spec*0.2, vec3(2.5));\n\n    // mix with the background\n    col = mix(bg_base_solid, col+0.1, pow(diff, .8));\n    // show dark edge\n    //col *= diff;\n\n    final_col = col;\n\n  } else {\n\n    final_col = bg_base_stars;\n\n  }\n\n  return final_col;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  vec3 col = vec3(0.0);\n\n  // normalized image plane, (0,0) is the center, (0.5,0.5) is top right\n  vec2 p = -1.0 + 2.0 * frag_coord.xy / i_resolution.xy;\n  // scale to fit width\n  p.x *= i_resolution.x / i_resolution.y;\n\n  // === Camera takes ===\n\n  float t = 0.;\n\n  // four camera takes: 20s, 20s, 20s, 10s\n  t = mod(i_time, 70.0);\n\n  if (t < 60.0) {\n\n    g_camera_pos    = vec3(0.0, 0.0, -25.0);\n    g_camera_lookat = vec3(2.0, -2.5, 0.0);\n    g_light_pos     = vec3(6.0, -2.0, -9.0);\n\n  } else if (t < 70.) {\n\n    p *= 0.4;\n    g_more_light = 0.5;\n    g_waves = 1.0;\n    g_show_moon = false;\n    g_camera_pos    = vec3(0.0, 0.0, -25.0);\n    g_camera_lookat = vec3(8.0, 2.5, 0.0);\n    g_light_pos     = vec3(6.0, 0.0, -9.0);\n\n  }\n\n  // === Camera ===\n\n  // ray origin is camera position\n  vec3 ro = g_camera_pos;\n\n  // camera vectors\n  vec3 cam_front = normalize(g_camera_lookat - g_camera_pos);\n  vec3 cam_right = normalize(cross(cam_front, g_world_up));\n  vec3 cam_up    = normalize(cross(cam_right, cam_front));\n\n  // ray direction toward camera front vector, shifted with screen pos xy\n  vec3 rd = normalize(p.x*cam_right + p.y*cam_up + 2.0*cam_front);\n\n  // === Render ===\n\n  float d = i_sphere(ro, rd, g_moon_sph);\n\n  float mat_id = -1.0;\n  if (d > 0.0) {\n    mat_id = 2.0;\n  }\n\n  col = material_color(ro, rd, mat_id, d);\n\n  frag_color = vec4(col, 1.0);\n}\n\n// === General Math ============================================================\n\n// general rotation matrix for pitch and yaw\nmat3 rot_xy(vec2 angle) {\n  vec2 c = cos(angle);\n  vec2 s = sin(angle);\n\n  return mat3(c.y      ,   0.0,  -s.y,\n              s.y * s.x,   c.x,   c.y * s.x,\n              s.y * c.x,  -s.x,   c.y * c.x);\n}\n\n// === Raymarch Helpers ========================================================\n\nfloat i_sphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - sph.w*sph.w;\n  float h = b*b - c;\n  if( h<0.0 ) return -1.0;\n  return -b - sqrt( h );\n}\n\nvec3 nor_sphere(vec3 pos, vec4 sph) {\n  return normalize(pos-sph.xyz);\n}\n\nvec3 calc_normal_craters(vec3 pos, float eps) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * map( pos + v1*eps ) +\n                    v2 * map( pos + v2*eps ) +\n                    v3 * map( pos + v3*eps ) +\n                    v4 * map( pos + v4*eps ) );\n}\n\nvec3 calc_normal_craters(vec3 pos) {\n  return calc_normal_craters(pos, 0.002);\n}\n\n// === Lighting Helpers ========================================================\n\nvec3 checker_board(vec2 uv) {\n  float f = mod(floor(5.0*uv.x) + floor(5.0*uv.y), 2.0);\n  vec3 col = 0.4 + 0.1 * f * vec3(1.0);\n  return col;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n  moon in the autumn dawn\n  to the pretty sky it flies\n  a mosquito\n\n  - Issa\n*/\n\n// text drawing pass\n\n// Using:\n// Shadertext proportional spacing by Andre\n// https://www.shadertoy.com/view/4s3XDn\n\n#define line1 BOLD m_ o_ o_ n_  _ i_ n_  _ t_ h_ e_  _ a_ u_ t_ u_ m_ n_  _ d_ a_ w_ n_\n#define line2 BOLD t_ o_  _ t_ h_ e_  _ p_ r_ e_ t_ t_ y_  _ s_ k_ y_  _ i_ t_ _ f_ l_ i_ e_ s_\n#define line3 BOLD a_  _ m_ o_ s_ q_ u_ i_ t_ o_\n#define line4\n#define line5 BOLD ITAL _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _sub _ I_ s_ s_ a_\n#define line6\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h);\n}\n\n//These functions are re-used by multiple letters\nfloat _u(vec2 uv, float w, float v) {\n  return length(vec2(\n                     abs(length(vec2(uv.x,\n                                     max(0.0,-(.4-v)-uv.y) ))-w)\n                     ,max(0.,uv.y-.4)));\n}\nfloat _i(vec2 uv) {\n  return length(vec2(uv.x,max(0.,abs(uv.y)-.4)));\n}\nfloat _j(vec2 uv) {\n  uv.x+=.2;\n  uv.y+=.55;\n  float x = uv.x>0.&&uv.y<0.?\n    abs(length(uv)-.25)\n    :min(length(uv+vec2(0.,.25)),\n         length(vec2(uv.x-.25,max(0.,abs(uv.y-.475)-.475))));\n  return x;\n}\nfloat _l(vec2 uv) {\n  uv.y -= .2;\n  return length(vec2(uv.x,max(0.,abs(uv.y)-.6)));\n}\nfloat _o(vec2 uv) {\n  return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.15)))-.25);\n}\n\n// Here is the alphabet\nfloat aa(vec2 uv) {\n  uv = -uv;\n  float x = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n  x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.2)-.2))));\n  return min(x,(uv.x<0.?uv.y<0.:atan(uv.x,uv.y+0.15)>2.)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254)));\n}\nfloat bb(vec2 uv) {\n  float x = _o(uv);\n  uv.x += .25;\n  return min(x,_l(uv));\n}\nfloat cc(vec2 uv) {\n  float x = _o(uv);\n  uv.y= abs(uv.y);\n  return uv.x<0.||atan(uv.x,uv.y-0.15)<1.14?x:\n    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.15))),//makes df right\n        length(uv+vec2(-.22734,-.254)));\n}\nfloat dd(vec2 uv) {\n  uv.x *= -1.;\n  return bb(uv);\n}\nfloat ee(vec2 uv) {\n  float x = _o(uv);\n  return min(uv.x<0.||uv.y>.05||atan(uv.x,uv.y+0.15)>2.?x:length(vec2(uv.x-.22734,uv.y+.254)),\n             length(vec2(max(0.,abs(uv.x)-.25),uv.y-.05)));\n}\nfloat ff(vec2 uv) {\n  uv.x *= -1.;\n  uv.x += .05;\n  float x = _j(vec2(uv.x,-uv.y));\n  uv.y -= .4;\n  x = min(x,length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y)));\n  return x;\n}\nfloat gg(vec2 uv) {\n  float x = _o(uv);\n  return min(x,uv.x>0.||atan(uv.x,uv.y+.6)<-2.?\n             _u(uv,0.25,-0.2):\n             length(uv+vec2(.23,.7)));\n}\nfloat hh(vec2 uv) {\n  uv.y *= -1.;\n  float x = _u(uv,.25,.25);\n  uv.x += .25;\n  uv.y *= -1.;\n  return min(x,_l(uv));\n}\nfloat ii(vec2 uv) {\n  return min(_i(uv),length(vec2(uv.x,uv.y-.6)));\n}\nfloat jj(vec2 uv) {\n  uv.x+=.05;\n  return min(_j(uv),length(vec2(uv.x-.05,uv.y-.6)));\n}\nfloat kk(vec2 uv) {\n  float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.4));\n  x = min(x,line(uv,vec2(-.15,.0), vec2(0.25,-0.4)));\n  uv.x+=.25;\n  return min(x,_l(uv));\n}\nfloat ll(vec2 uv) {\n  return _l(uv);\n}\nfloat mm(vec2 uv) {\n  //uv.x *= 1.4;\n  uv.y *= -1.;\n  uv.x-=.175;\n  float x = _u(uv,.175,.175);\n  uv.x+=.35;\n  x = min(x,_u(uv,.175,.175));\n  uv.x+=.175;\n  return min(x,_i(uv));\n}\nfloat nn(vec2 uv) {\n  uv.y *= -1.;\n  float x = _u(uv,.25,.25);\n  uv.x+=.25;\n  return min(x,_i(uv));\n}\nfloat oo(vec2 uv) {\n  return _o(uv);\n}\nfloat pp(vec2 uv) {\n  float x = _o(uv);\n  uv.x += .25;\n  uv.y += .4;\n  return min(x,_l(uv));\n}\nfloat qq(vec2 uv) {\n  uv.x = -uv.x;\n  return pp(uv);\n}\nfloat rr(vec2 uv) {\n  uv.x -= .05;\n  float x =atan(uv.x,uv.y-0.15)<1.14&&uv.y>0.?_o(uv):length(vec2(uv.x-.22734,uv.y-.254));\n\n  //)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254))+.4);\n\n  uv.x+=.25;\n  return min(x,_i(uv));\n}\nfloat ss(vec2 uv) {\n  if (uv.y <.225-uv.x*.5 && uv.x>0. || uv.y<-.225-uv.x*.5)\n    uv = -uv;\n  float a = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n  float b = length(vec2(uv.x-.231505,uv.y-.284));\n  float x = atan(uv.x-.05,uv.y-0.2)<1.14?a:b;\n  return x;\n}\nfloat tt(vec2 uv) {\n  uv.x *= -1.;\n  uv.y -= .4;\n  uv.x += .05;\n  float x = min(_j(uv),length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y)));\n  return x;\n}\nfloat uu(vec2 uv) {\n  return _u(uv,.25,.25);\n}\nfloat vv(vec2 uv) {\n  uv.x=abs(uv.x);\n  return line(uv,vec2(0.25,0.4), vec2(0.,-0.4));\n}\nfloat ww(vec2 uv) {\n  uv.x=abs(uv.x);\n  return min(line(uv,vec2(0.3,0.4), vec2(.2,-0.4)),\n             line(uv,vec2(0.2,-0.4), vec2(0.,0.1)));\n}\nfloat xx(vec2 uv) {\n  uv=abs(uv);\n  return line(uv,vec2(0.,0.), vec2(.3,0.4));\n}\nfloat yy(vec2 uv) {\n  return min(line(uv,vec2(.0,-.2), vec2(-.3,0.4)),\n             line(uv,vec2(.3,.4), vec2(-.3,-0.8)));\n}\nfloat zz(vec2 uv) {\n  float l = line(uv,vec2(0.25,0.4), vec2(-0.25,-0.4));\n  uv.y=abs(uv.y);\n  float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.4));\n  return min(x,l);\n}\n\n// Capitals\nfloat AA(vec2 uv) {\n  float x = length(vec2(\n                        abs(length(vec2(uv.x,\n                                        max(0.0,uv.y-.35) ))-0.25)\n                        ,min(0.,uv.y+.4)));\n  return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1) ));\n}\n\nfloat BB(vec2 uv) {\n  uv.y -=.1;\n  uv.y = abs(uv.y);\n  float x = length(vec2(\n                        abs(length(vec2(max(0.0,uv.x),\n                                        uv.y-.25))-0.25)\n                        ,min(0.,uv.x+.25)));\n  return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) ));\n}\nfloat CC(vec2 uv) {\n  float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n  uv.y -= .1;\n  uv.y= abs(uv.y);\n  return uv.x<0.||atan(uv.x,uv.y-0.25)<1.14?x:\n    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))),//makes df right\n        length(uv+vec2(-.22734,-.354)));\n}\nfloat DD(vec2 uv) {\n  uv.y -=.1;\n  //uv.y = abs(uv.y);\n  float x = length(vec2(\n                        abs(length(vec2(max(0.0,uv.x),\n                                        max(0.0,abs(uv.y)-.25)))-0.25)\n                        ,min(0.,uv.x+.25)));\n  return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) ));\n}\nfloat EE(vec2 uv) {\n  uv.y -=.1;\n  uv.y = abs(uv.y);\n  float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n  return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat FF(vec2 uv) {\n  uv.y -=.1;\n  float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n  return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat GG(vec2 uv) {\n  float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n  uv.y -= .1;\n  float a = atan(uv.x,max(0.,abs(uv.y)-0.25));\n  x = uv.x<0.||a<1.14 || a>3.?x:\n    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))),//makes df right\n        length(uv+vec2(-.22734,-.354)));\n  x = min(x,line(uv,vec2(.22734,-.1),vec2(.22734,-.354)));\n  return min(x,line(uv,vec2(.22734,-.1),vec2(.05,-.1)));\n}\nfloat HH(vec2 uv) {\n  uv.y -=.1;\n  uv.x = abs(uv.x);\n  float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y));\n  return min(x,length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))));\n}\nfloat II(vec2 uv) {\n  uv.y -= .1;\n  float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n  uv.y = abs(uv.y);\n  return min(x,length(vec2(max(0.,abs(uv.x)-.1),uv.y-.5)));\n}\nfloat JJ(vec2 uv) {\n  uv.x += .125;\n  float x = length(vec2(\n                        abs(length(vec2(uv.x,\n                                        min(0.0,uv.y+.15) ))-0.25)\n                        ,max(0.,max(-uv.x,uv.y-.6))));\n  return min(x,length(vec2(max(0.,abs(uv.x-.125)-.125),uv.y-.6)));\n}\nfloat KK(vec2 uv) {\n  float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.6));\n  x = min(x,line(uv,vec2(-.1, .1), vec2(0.25,-0.4)));\n  //    uv.x+=.25;\n  return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5))));\n}\nfloat LL(vec2 uv) {\n  uv.y -=.1;\n  float x = length(vec2(max(0.,abs(uv.x)-.2),uv.y+.5));\n  return min(x,length(vec2(uv.x+.2,max(0.,abs(uv.y)-.5))));\n}\nfloat MM(vec2 uv) {\n  uv.y-=.1;\n  float x = min(length(vec2(uv.x-.35,max(0.,abs(uv.y)-.5))),\n                line(uv,vec2(-.35,.5),vec2(.0,-.1)));\n  x = min(x,line(uv,vec2(.0,-.1),vec2(.35,.5)));\n  return min(x,length(vec2(uv.x+.35,max(0.,abs(uv.y)-.5))));\n}\nfloat NN(vec2 uv) {\n  uv.y-=.1;\n  float x = min(length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))),\n                line(uv,vec2(-.25,.5),vec2(.25,-.5)));\n  return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat OO(vec2 uv) {\n  return abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n}\nfloat PP(vec2 uv) {\n  float x = length(vec2(\n                        abs(length(vec2(max(0.0,uv.x),\n                                        uv.y-.35))-0.25)\n                        ,min(0.,uv.x+.25)));\n  return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n}\nfloat QQ(vec2 uv) {\n  float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n  uv.y += .3;\n  uv.x -= .2;\n  return min(x,length(vec2(abs(uv.x+uv.y),max(0.,abs(uv.x-uv.y)-.2)))/sqrt(2.));\n}\nfloat RR(vec2 uv) {\n  float x = length(vec2(\n                        abs(length(vec2(max(0.0,uv.x),\n                                        uv.y-.35))-0.25)\n                        ,min(0.,uv.x+.25)));\n  x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n  return min(x,line(uv,vec2(0.0,0.1),vec2(0.25,-0.4)));\n}\nfloat SS(vec2 uv) {\n  uv.y -= .1;\n  if (uv.y <.275-uv.x*.5 && uv.x>0. || uv.y<-.275-uv.x*.5)\n    uv = -uv;\n  float a = abs(length(vec2(max(0.,abs(uv.x)),uv.y-.25))-.25);\n  float b = length(vec2(uv.x-.236,uv.y-.332));\n  float x = atan(uv.x-.05,uv.y-0.25)<1.14?a:b;\n  return x;\n}\nfloat TT(vec2 uv) {\n  uv.y -= .1;\n  float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n  return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n}\nfloat UU(vec2 uv) {\n  float x = length(vec2(\n                        abs(length(vec2(uv.x,\n                                        min(0.0,uv.y+.15) ))-0.25)\n                        ,max(0.,uv.y-.6)));\n  return x;\n}\nfloat VV(vec2 uv) {\n  uv.x=abs(uv.x);\n  return line(uv,vec2(0.25,0.6), vec2(0.,-0.4));\n}\nfloat WW(vec2 uv) {\n  uv.x=abs(uv.x);\n  return min(line(uv,vec2(0.3,0.6), vec2(.2,-0.4)),\n             line(uv,vec2(0.2,-0.4), vec2(0.,0.2)));\n}\nfloat XX(vec2 uv) {\n  uv.y -= .1;\n  uv=abs(uv);\n  return line(uv,vec2(0.,0.), vec2(.3,0.5));\n}\nfloat YY(vec2 uv) {\n  return min(min(line(uv,vec2(.0, .1), vec2(-.3, 0.6)),\n                 line(uv,vec2(.0, .1), vec2( .3, 0.6))),\n             length(vec2(uv.x,max(0.,abs(uv.y+.15)-.25))));\n}\nfloat ZZ(vec2 uv) {\n  float l = line(uv,vec2(0.25,0.6), vec2(-0.25,-0.4));\n  uv.y-=.1;\n  uv.y=abs(uv.y);\n  float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5));\n  return min(x,l);\n}\n\n//Numbers\nfloat _11(vec2 uv) {\n  return min(min(\n                 line(uv,vec2(-0.2,0.45),vec2(0.,0.6)),\n                 length(vec2(uv.x,max(0.,abs(uv.y-.1)-.5)))),\n             length(vec2(max(0.,abs(uv.x)-.2),uv.y+.4)));\n\n}\nfloat _22(vec2 uv) {\n  float x = min(line(uv,vec2(0.185,0.17),vec2(-.25,-.4)),\n                length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4)));\n  uv.y-=.35;\n  uv.x += 0.025;\n  return min(x,abs(atan(uv.x,uv.y)-0.63)<1.64?abs(length(uv)-.275):\n             length(uv+vec2(.23,-.15)));\n}\nfloat _33(vec2 uv) {\n  uv.y-=.1;\n  uv.y = abs(uv.y);\n  uv.y-=.25;\n  return atan(uv.x,uv.y)>-1.?abs(length(uv)-.25):\n    min(length(uv+vec2(.211,-.134)),length(uv+vec2(.0,.25)));\n}\nfloat _44(vec2 uv) {\n  float x = min(length(vec2(uv.x-.15,max(0.,abs(uv.y-.1)-.5))),\n                line(uv,vec2(0.15,0.6),vec2(-.25,-.1)));\n  return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y+.1)));\n}\nfloat _55(vec2 uv) {\n  float b = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n                length(vec2(uv.x+.25,max(0.,abs(uv.y-.36)-.236))));\n  uv.y += 0.1;\n  uv.x += 0.05;\n  float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.0)))-.3);\n  return min(b,abs(atan(uv.x,uv.y)+1.57)<.86 && uv.x<0.?\n             length(uv+vec2(.2,.224))\n             :c);\n}\nfloat _66(vec2 uv) {\n  uv.y-=.075;\n  uv = -uv;\n  float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n  uv.y-=.175;\n  float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n  return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n             length(uv+vec2(0.2,0.6)));\n}\nfloat _77(vec2 uv) {\n  return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n             line(uv,vec2(-0.25,-0.39),vec2(0.25,0.6)));\n}\nfloat _88(vec2 uv) {\n  float l = length(vec2(max(0.,abs(uv.x)-.08),uv.y-.1+uv.x*.07));\n  uv.y-=.1;\n  uv.y = abs(uv.y);\n  uv.y-=.245;\n  return min(abs(length(uv)-.255),l);\n}\nfloat _99(vec2 uv) {\n  uv.y-=.125;\n  float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n  uv.y-=.175;\n  float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n  return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n             length(uv+vec2(0.2,0.6)));\n}\nfloat _00(vec2 uv) {\n  uv.y-=.1;\n  return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.25)))-.25);\n}\n\n//Symbols\nfloat ddot(vec2 uv) {\n  uv.y+=.4;\n  return length(uv)*0.97;//-.03;\n}\nfloat comma(vec2 uv) {\n  return min(ddot(uv),line(uv,vec2(.031,-.405),vec2(-.029,-.52)));\n}\nfloat exclam(vec2 uv) {\n  return min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y-.2)-.4)))-uv.y*.06);\n}\nfloat question(vec2 uv) {\n  float x = min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y+.035)-.1125))));\n  uv.y-=.35;\n  uv.x += 0.025;\n  return min(x,abs(atan(uv.x,uv.y)-1.05)<2.?abs(length(uv)-.275):\n             length(uv+vec2(.225,-.16))-.0);\n}\nfloat open1(vec2 uv) {\n  uv.x-=.62;\n  return abs(atan(uv.x,uv.y)+1.57)<1.?\n    abs(length(uv)-.8)\n    :length(vec2(uv.x+.435,abs(uv.y)-.672));\n}\nfloat close1(vec2 uv) {\n  uv.x = -uv.x;\n  return open1(uv);\n}\nfloat dotdot(vec2 uv) {\n  uv.y -= .1;\n  uv.y = abs(uv.y);\n  uv.y-=.25;\n  return length(uv);\n}\nfloat dotcomma(vec2 uv) {\n  uv.y -= .1;\n  float x = line(uv,vec2(.0,-.28),vec2(-.029,-.32));\n  uv.y = abs(uv.y);\n  uv.y-=.25;\n  return min(length(uv),x);\n}\nfloat eequal(vec2 uv) {\n  uv.y -= .1;\n  uv.y = abs(uv.y);\n  return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.15));\n}\nfloat aadd(vec2 uv) {\n  uv.y -= .1;\n  return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n             length(vec2(uv.x,max(0.,abs(uv.y)-.25))));\n}\nfloat ssub(vec2 uv) {\n  return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1));\n}\nfloat mmul(vec2 uv) {\n  uv.y -= .1;\n  uv = abs(uv);\n  return min(line(uv,vec2(0.866*.25,0.5*.25),vec2(0.))\n             ,length(vec2(uv.x,max(0.,abs(uv.y)-.25))));\n}\nfloat ddiv(vec2 uv) {\n  return line(uv,vec2(-0.25,-0.4),vec2(0.25,0.6));\n}\nfloat lt(vec2 uv) {\n  uv.y-=.1;\n  uv.y = abs(uv.y);\n  return line(uv,vec2(0.25,0.25),vec2(-0.25,0.));\n}\nfloat gt(vec2 uv) {\n  uv.x=-uv.x;\n  return lt(uv);\n}\nfloat hash(vec2 uv) {\n  uv.y-=.1;\n  uv.x -= uv.y*.1;\n  uv = abs(uv);\n  return min(length(vec2(uv.x-.125,max(0.,abs(uv.y)-.3))),\n             length(vec2(max(0.,abs(uv.x)-.25),uv.y-.125)));\n}\nfloat and(vec2 uv) {\n  uv.y-=.44;\n  uv.x+=.05;\n  float x = abs(atan(uv.x,uv.y))<2.356?abs(length(uv)-.15):1.0;\n  x = min(x,line(uv,vec2(-0.106,-0.106),vec2(0.4,-0.712)));\n  x = min(x,line(uv,vec2( 0.106,-0.106),vec2(-0.116,-0.397)));\n  uv.x-=.025;\n  uv.y+=.54;\n  x = min(x,abs(atan(uv.x,uv.y)-.785)>1.57?abs(length(uv)-.2):1.0);\n  return min(x,line(uv,vec2( 0.141,-0.141),vec2( 0.377,0.177)));\n}\nfloat or(vec2 uv) {\n  uv.y -= .1;\n  return length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n}\nfloat und(vec2 uv) {\n  return length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4));\n}\nfloat open2(vec2 uv) {\n  uv.y -= .1;\n  uv.y = abs(uv.y);\n  return min(length(vec2(uv.x+.125,max(0.,abs(uv.y)-.5))),\n             length(vec2(max(0.,abs(uv.x)-.125),uv.y-.5)));\n}\nfloat close2(vec2 uv) {\n  uv.x=-uv.x;\n  return open2(uv);\n}\nfloat open3(vec2 uv) {\n  uv.y -= .1;\n  uv.y = abs(uv.y);\n  float x = length(vec2(\n                        abs(length(vec2((uv.x*sign(uv.y-.25)-.2),\n                                        max(0.0,abs(uv.y-.25)-.05) ))-0.2)\n                        ,max(0.,abs(uv.x)-.2)));\n  return  x;\n\n}\nfloat close3(vec2 uv) {\n  uv.x=-uv.x;\n  return open3(uv);\n}\n\nvec2 clc(vec2 uv, float cp, float w, float ital) {\n  return uv-vec2(cp-(w*.5)+uv.y*ital,0.);\n}\nbool hit(vec2 uv,inout float cp,float w, float px) {\n  return abs((cp+=w)-uv.x)<w+.2;\n}\n\n//Render char if it's up\n#define ch(l,w) if (hit(uv,cp,w,px)) { x=min(x,l(clc(uv,cp,w,ital))); us=cur;}\n\n//Render char always (no effects anymore)\n//#define ch(l,w) x = min(x,l(clc(uv,cp+=w,w,ital)));\n\n//Make it a bit easier to type text\n#define a_ ch(aa,0.7);\n#define b_ ch(bb,0.7);\n#define c_ ch(cc,0.7);\n#define d_ ch(dd,0.7);\n#define e_ ch(ee,0.7);\n#define f_ ch(ff,0.6);\n#define g_ ch(gg,0.7);\n#define h_ ch(hh,0.7);\n#define i_ ch(ii,0.3);\n#define j_ ch(jj,0.3);\n#define k_ ch(kk,0.7);\n#define l_ ch(ll,0.3);\n#define m_ ch(mm,0.9);\n#define n_ ch(nn,0.7);\n#define o_ ch(oo,0.7);\n#define p_ ch(pp,0.7);\n#define q_ ch(qq,0.7);\n#define r_ ch(rr,0.7);\n#define s_ ch(ss,0.7);\n#define t_ ch(tt,0.7);\n#define u_ ch(uu,0.7);\n#define v_ ch(vv,0.7);\n#define w_ ch(ww,0.9);\n#define x_ ch(xx,0.8);\n#define y_ ch(yy,0.8);\n#define z_ ch(zz,0.7);\n#define A_ ch(AA,0.7);\n#define B_ ch(BB,0.7);\n#define C_ ch(CC,0.7);\n#define D_ ch(DD,0.7);\n#define E_ ch(EE,0.7);\n#define F_ ch(FF,0.7);\n#define G_ ch(GG,0.7);\n#define H_ ch(HH,0.7);\n#define I_ ch(II,0.5);\n#define J_ ch(JJ,0.5);\n#define K_ ch(KK,0.7);\n#define L_ ch(LL,0.5);\n#define M_ ch(MM,0.9);\n#define N_ ch(NN,0.7);\n#define O_ ch(OO,0.7);\n#define P_ ch(PP,0.7);\n#define Q_ ch(QQ,0.7);\n#define R_ ch(RR,0.7);\n#define S_ ch(SS,0.7);\n#define T_ ch(TT,0.7);\n#define U_ ch(UU,0.7);\n#define V_ ch(VV,0.7);\n#define W_ ch(WW,0.9);\n#define X_ ch(XX,0.8);\n#define Y_ ch(YY,0.8);\n#define Z_ ch(ZZ,0.7);\n#define _1 ch(_11,0.7);\n#define _2 ch(_22,0.7);\n#define _3 ch(_33,0.7);\n#define _4 ch(_44,0.7);\n#define _5 ch(_55,0.7);\n#define _6 ch(_66,0.7);\n#define _7 ch(_77,0.7);\n#define _8 ch(_88,0.7);\n#define _9 ch(_99,0.7);\n#define _0 ch(_00,0.7);\n#define _dot ch(ddot,0.3);\n#define _comma ch(comma,0.3);\n#define _exclam ch(exclam,0.3);\n#define _question ch(question,0.8);\n#define _open1 ch(open1,0.7);\n#define _close1 ch(close1,0.7);\n#define _dotdot ch(dotdot,0.3);\n#define _dotcomma ch(dotcomma,0.3);\n#define _equal ch(eequal,0.7);\n#define _add ch(aadd,0.7);\n#define _sub ch(ssub,0.7);\n#define _mul ch(mmul,0.7);\n#define _div ch(ddiv,0.7);\n#define _lt ch(lt,0.7);\n#define _gt ch(gt,0.7);\n#define _hash ch(hash,0.7);\n#define _and ch(and,0.9);\n#define _or ch(or,0.3);\n#define _und ch(und,0.7);\n#define _open2 ch(open2,0.6);\n#define _close2 ch(close2,0.6);\n#define _open3 ch(open3,0.7);\n#define _close3 ch(close3,0.7);\n\n//Space\n#define _ cp+=.5;\n\n//Markup\n#define BOLD cur.w = 1.5-cur.w;\n#define ITAL ital = 0.15-ital;\n#define RED cur.r = 0.8-cur.r;\n#define GREEN cur.g = 0.6-cur.g;\n#define BLUE cur.b = 1.0-cur.b;\n\n//Next line\n#define crlf uv.y += 2.0; cp = 0.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float scale = 1.0;\n  vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.x * 22.0 * scale;\n  uv.y *= iResolution.x / iResolution.y;\n\n  //float ofs = floor(uv.x)+8.;\n  //uv.x = mod(uv.x,1.0)-.5;\n\n  float px = 22.0/iResolution.x*scale;\n  float x = 100.;\n  float cp = 0.;\n  vec4 cur = vec4(0.,0.,0.,0.5);\n  vec4 us = cur;\n  float ital = 0.0;\n  //uv+= .03*cos(uv*7.+iTime);\n  //uv.y += 2.;\n  uv.x += 10.1;\n  //uv.y -= 3.;\n  //uv.x += 5.;\n\n  int lnr = 2-int(floor(uv.y/2.));\n  uv.y = mod(uv.y,2.0)-1.0;\n\n  if (lnr==0) {line1}\n  if (lnr==1) {line2}\n  if (lnr==2) {line3}\n  if (lnr==3) {line4}\n  if (lnr==4) {line5}\n  if (lnr==5) {line6}\n\n  vec3 clr = vec3(0.0);\n\n  float weight = 0.01+us.w*0.02;\n\n  fragColor = vec4(mix(us.rgb, vec3(1.0), smoothstep(weight-px,weight+px, x)), 1.0);\n\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// raymarch pass\n\n#define WAVE_SPEED 0.3\n\n#define ENABLE_AO 1\n\n// show light position\n#define DEBUG 0\n\n#define tex_sky iChannel0\n#define tex_rock iChannel1\n\n#define i_resolution iResolution\n#define i_time iTime\n#define i_mouse iMouse\n\n// globals\n\nvec3 g_camera_pos    = vec3(-30.0, 5.0, -45.0);\nvec3 g_camera_lookat = vec3(0.0, 20.0, 0.0);\n\nvec3 g_light_pos     = vec3(10.0, 50.0, 15.0);\nvec3 g_light_2_pos   = vec3(-25.0, 20.0, 25.0);\n\nvec3 g_world_up      = vec3(0.0, 1.0, 0.0);\n\nfloat g_ocean_reflect_sky = 0.0;\nfloat g_more_light = 0.0;\nfloat g_waves = 0.0;\n\n// don't cut off the far rocks\n#define FAR_CLIP 500.0\n// grazing angles eat your steps\n#define FAR_STEPS 800\n\n#define OCEAN_FAR_CLIP 500.0\n\n#define SPEED 1.0\n\nconst float PI  = 3.14159265359;\nconst float TWO_PI = 2.0*PI;\nconst float HALF_PI = 0.5*PI;\n\n// function signatures\nmat3 rot_xy(vec2 angle);\nvec3 tex_3d(sampler2D t, vec3 p, vec3 n);\n\nvec2 cast_ray(vec3 ro, vec3 rd);\nvec2 cast_ray_debug(vec3 ro, vec3 rd);\nvec3 calc_normal(vec3 pos);\nfloat calc_ao(vec3 pos, vec3 nor);\nfloat light_attenuation(vec3 light_pos, vec3 surf_pos, float radius);\nvec2 op_u(vec2 d1, vec2 d2);\nfloat op_smin(float a, float b, float k);\nfloat op_smax(float a, float b, float k);\nvoid op_r(inout vec2 p, float a);\nfloat op_mod_polar(inout vec2 p, float repetitions);\n\nfloat sd_plane(vec3 p);\nfloat sd_sphere(vec3 p, float s);\nfloat sd_box(vec3 p, vec3 b);\nfloat sd_torus(vec3 p, vec2 t);\nfloat sd_cylinder(vec3 p, float r, float height);\nfloat sd_capsule(vec3 p, float r, float c);\nfloat sd_cone(vec3 p, vec3 c);\nfloat sd_cone_section(vec3 p, float h, float r1, float r2);\n\nvec3 material_color(vec3 ro, vec3 rd, float dist, float mat_id, vec3 pos);\nvec2 map(vec3 p);\nvec2 map_debug(vec3 p);\n\nvec3 checker_board(vec2 uv);\n\n// === Implementations =========================================================\n\n// Shane's Rocky Gorge\n//\n// Cheap and nasty 2D smooth noise function, based on IQ's original. Very trimmed down. In fact,\n// I probably went a little overboard. I think it might also degrade with large time values. I'll\n// swap it for something more robust later.\nfloat n2d(vec2 p) {\n  vec2 i = floor(p); p -= i; p *= p*(3. - p*2.); //p *= p*p*(p*(p*6. - 15.) + 10.);\n\n  return dot(mat2(fract(sin(vec4(0, 41, 289, 330) + dot(i, vec2(41, 289)))*43758.5453))*\n             vec2(1. - p.y, p.y), vec2(1. - p.x, p.x));\n}\n\n// --- Terrain ---\n\nfloat terrain_surface_noise(vec2 p, int iter) {\n  float res = 0.0;\n\n  // scale up the domain first (i.e. start terrain on low frequency)\n  p *= 0.125; // * 1/8\n\n  // amplitude, amp total, accumulative result\n  float amp = 1.0, amp_sum = 0.0, accum_res = 0.0;\n\n  for (int i=0; i<iter; i++) {\n    accum_res += n2d(p)*amp;\n\n    // scaling and skewing\n    p = mat2(1.0, -0.95, 0.60, 1.0) * p*3.0;\n\n    // adding up the amp\n    amp_sum += amp;\n\n    // scaling down the amp\n    amp *= 0.4 - (float(i)*0.05);\n  }\n\n  res = accum_res / amp_sum;\n\n  return res;\n}\n\nfloat sd_terrain(vec3 p) {\n  float res = 0.0;\n  vec3 q = p;\n\n  // bounding volume, a bit tall but helps to gain ~2fps when ray is already past the terrain\n  float a = p.y - 17.0;\n  if (a > 1.0) return a;\n\n  float terrain = terrain_surface_noise(p.xz, 4);\n\n  // raise the top of the cliffs\n  p.y += -15.0;\n  // cliff's 2d space\n  // stretch and lower\n  vec2 c = abs(p.xy*vec2(0.8, 0.465) + vec2(0.0, -1.0));\n  c.x += sin(p.z*0.5) * 1.5;\n\n  // 10.0 = radius\n  // length(c) = cylinder along z axis\n  // max(c.x, c.y) = box along z axis\n  a = 10.0 - mix(length(c), max(c.x, c.y), 0.35);\n\n  res = op_smax(a, p.y, 0.8);\n  // cut off the right side, to leave only the left cliff\n  res = max(res, -sd_box(p + vec3(1000.0, -22.0, 0.0), vec3(1000.0, 40., 1000.)));\n\n  // a bay at the camera start\n  q = p - vec3(12.0, -4.0, 15.0);\n  q.xz *= vec2(0.25, 0.5);\n  res = op_smax(res, -sd_sphere(q, 12.5), 4.0);\n\n  // cave\n  q = p;\n  q -= vec3(40.0, -15.0, 19.0);\n  q.z *= 0.6;\n  op_r(q.xy, radians(90.0));\n  res = op_smax(res, -sd_cylinder(q, 3.0, 20.0), 2.0);\n\n  // bay behind the cliff\n  q = p;\n  q -= vec3(10.0, 15.0, 120.0);\n  q.z *= 0.6;\n  q.y *= 1.15;\n  res = op_smax(res, -sd_sphere(q, 40.0), 2.0);\n\n  q = p;\n  q -= vec3(45.0, -3.0, 120.0);\n  q.y *= 1.6;\n  res = op_smax(res, -sd_sphere(q, 32.0), 2.0);\n\n  res += (0.5 - terrain)*4.0;\n\n  return res;\n}\n\n// --- Ocean ---\n\n// Gavoronoise\n\nfloat hash_ga( in vec2 p ) {\n    return fract(sin(p.x*15.32+p.y*5.78) * 43758.236237153);\n}\n\nvec2 hash2_ga(vec2 p) {\n  return vec2(hash_ga(p*.754),hash_ga(1.5743*p.yx+4.5891))-.5;\n}\n\nvec2 hash2b_ga( vec2 p ) {\n    vec2 q = vec2( dot(p,vec2(127.1,311.7)),\n           dot(p,vec2(269.5,183.3)) );\n  return fract(sin(q)*43758.5453)-.5;\n}\n\nvec2 ga_m = vec2(.8,.2);\n\n// Gabor/Voronoi mix 3x3 kernel (some artifacts for v=1.)\nfloat gavoronoi3(in vec2 p) {\n  vec2 ip = floor(p);\n  vec2 fp = fract(p);\n  float f = 2.*PI;//frequency\n  float v = .8;//cell variability <1.\n  float dv = .4;//direction variability <1.\n  vec2 dir = ga_m;// direction scale\n  float va = 0.0;\n  float wt = 0.0;\n  for (int i=-1; i<=1; i++) {\n    for (int j=-1; j<=1; j++) {\n      vec2 o = vec2(i, j)-.5;\n      vec2 h = hash2_ga(ip - o);\n      vec2 pp = fp +o  -h;\n      float d = dot(pp, pp);\n      float w = exp(-d*4.);\n      wt +=w;\n      h = dv*h+dir;//h=normalize(h+dir);\n      va += cos(dot(pp,h)*f/v)*w;\n    }\n  }\n  return va/wt;\n}\n\nfloat fbmabs_ga( vec2 p ) {\n  float f = 0.8;\n  float r = 0.0;\n    for(int i=0; i<6; i++) {\n    r += abs(gavoronoi3( p*f ))/f;\n    f *= 2.2;\n    p+=vec2(-.01,.07)*r+.2*ga_m*i_time*WAVE_SPEED/(.1-f);\n  }\n  return r;\n}\n\nfloat sd_ocean(vec3 p) {\n  float res = 0.0;\n\n  // bounding volume\n  float a = p.y - 1.0;\n  if (a > 1.0) return a;\n\n  vec2 q = p.xz*0.02 + .2*ga_m*i_time*WAVE_SPEED;\n  float ocean = 1.0;\n  float w = p.z - g_camera_pos.z;\n  if (w < OCEAN_FAR_CLIP) {\n    ocean = 1.-fbmabs_ga(q);\n  }\n  res = p.y - ocean;\n\n  return res;\n}\n\n// --- Spaceship ---\n\nfloat sd_spaceship_body(vec3 p) {\n  float res = 0.0;\n\n  vec3 q = p;\n  q *= vec3(1., .3, .95);\n  vec3 w = q;\n  op_r(w.yz, radians(45.));\n  float a = sd_box(w, vec3(0.2, 5., 5.));\n  q += vec3(2., 5., 0.);\n  float b = sd_box(q, vec3(2., 4., 1.));\n  a = op_smin(a, b, 8.0);\n\n  q = p * vec3(1.5, .6, 1.);\n  float c = sd_sphere(q - vec3(-9.5, -25., 0.), 12.);\n  a = max(a, -c);\n\n  a = max(a, -(p.y + 40.0));\n\n  res = a;\n  return res;\n}\n\nfloat sd_thruster(vec3 p) {\n  float res = 0.0;\n\n  p *= vec3(0.7);\n\n  vec3 q = p;\n  op_r(q.xy, radians(90.));\n  q *= vec3(.2, 1., 1.);\n  q.z = abs(q.z) + 2.1;\n  q.z -= 0.5;\n  op_mod_polar(q.yz, 8.0);\n  float a = sd_cylinder(q, 5.0, 3.0);\n\n  // shaped top\n  float b = sd_cylinder(p + vec3(0., -25., 0.), 0.2, 5.0);\n  a = op_smin(a, b, 4.0);\n\n  // exhaust opening\n  q = p * vec3(1., .7, 1.);\n  float c = sd_sphere(q - vec3(-7.2, 0., 0.), 10.0);\n  a = max(a, -c);\n\n  // cut off the rest\n  a = max(a, -p.y);\n\n  res = a;\n\n  return res;\n}\n\nfloat sd_spaceship(vec3 p) {\n  float res = 0.0;\n\n  // bounding volume\n  float a = sd_box(p - vec3(0., 10., 0.), vec3(5.0, 30.0, 15.0));\n  if (a > 1.0) return a;\n\n  // main body\n  a = sd_spaceship_body(p - vec3(0., 15., 0.));\n\n  // thrusters\n  vec3 q = p;\n  q += vec3(0., 24.0, 0.);\n  q.z = abs(q.z) - 10.2;\n  float b = sd_thruster(q);\n  a = min(a, b);\n\n  res = a;\n\n  return res;\n}\n\nvec2 map(vec3 p) {\n  vec2 res = vec2(FAR_CLIP, 0.0);\n\n  res = op_u(res, vec2(sd_ocean(p*vec3(-1,1,1) - vec3(0.0, -1.4, 0.0)), 1.0));\n  res = op_u(res, vec2(sd_terrain(p), 2.0));\n  res = op_u(res, vec2(sd_spaceship(p - vec3(45.0, 20.0, 120.0)), 3.0));\n\n  return res;\n}\n\n// --- World Map ---\n\nvec2 map_debug(vec3 p) {\n  vec2 res = vec2(FAR_CLIP, 0.0);\n\n  // sphere at light position\n  res = op_u(res, vec2(sd_sphere(p - g_light_pos, 5.0), 1.0));\n\n  return res;\n}\n\nvec2 rotate(vec2 v, float angle)\n{\n  float x = v.x * cos(angle) - v.y * sin(angle);\n  float y = v.x * sin(angle) + v.y * cos(angle);\n\n  return vec2(x, y);\n}\n\n// sky background gradient based on the ray direction\nvec3 sky_color(vec3 rd) {\n  vec3 sky_top = vec3(0.090, 0.180, 0.211)*0.7; // rgb(23, 46, 54) #172E36\n  vec3 sky_bottom = vec3(0.921, 0.698, 0.600); // rgb(235, 178, 153) #EBB299\n  vec3 sky_star = vec3(0.133, 0.952, 0.980);// rgb(34, 243, 250) #22F3FA\n\n  float a = g_more_light;\n  rd.y += 0.2 - a;\n\n  vec3 col = vec3(0.);\n  float horiz = 1. - clamp(max(rd.y, 0.0), 0., 1.);\n  col += sky_bottom*exp(horiz*10.0 - 10.0);\n\n  float sun = clamp(dot(normalize(g_light_pos*vec3(1., 1., -1)), rd), 0., 1.);\n  col += 0.8*sky_bottom*exp(sun*15.0 - 15.0);\n  col = sky_top + pow(col, vec3(1.5));\n\n  // vertical sinus waves\n  float w = 0.0 +\n    0.1*sin(rd.x*80.0 + i_time*0.9) +\n    0.1*cos(rd.x*120.0 - i_time*1.5) +\n    0.1*sin(rd.x*200.0 + i_time*1.2) +\n    0.1*cos(rd.x*250.0 - i_time*1.5);\n  vec3 wave = 0.6 * vec3(w);\n  col -= g_waves * wave;\n\n  return col;\n}\n\nfloat ocean_diffuse(vec3 n, vec3 l, float p) {\n  return pow(dot(n, l) * 0.5, p);\n}\n\nfloat ocean_specular(vec3 n, vec3 l, vec3 e, float s) {\n  float nrm = (s + 8.0) / (PI * 8.0);\n  return pow(max(dot(reflect(e, n), l), 0.0), s) * nrm;\n}\n\nvec3 material_color(vec3 ro, vec3 rd, float dist, float mat_id, vec3 pos) {\n  vec3 final_col = vec3(0.0);\n  vec3 nor = vec3(0.0);\n\n  if (mat_id > -1.0) {\n    nor = calc_normal(pos);\n  }\n\n  if (mat_id == 1.0) {\n\n    // Ocean\n\n    vec3 sea_base = vec3(0.1, 0.19, 0.22);\n    vec3 sea_water_color = vec3(0.8, 0.9, 0.6);\n\n    vec3 col = vec3(0.);\n\n    vec3 light_dir = normalize(g_light_pos - pos);\n    vec3 view_dir = normalize(ro - pos);\n    vec3 halfway_dir = normalize(light_dir + view_dir);\n\n    float fresnel = 1.0 - max(dot(nor, view_dir),0.0);\n    fresnel = pow(fresnel, 3.0) * 0.65;\n\n    vec3 sky_top = vec3(0.090, 0.180, 0.211) + vec3(0.2); // rgb(23, 46, 54) #172E36\n    // reflect on a flat surface normal (pointing up)\n    vec3 ref_rd = reflect(-rd, g_world_up);\n    vec3 ref_sky = sky_color(ref_rd);\n    vec3 reflected = mix(sky_top, ref_sky, g_ocean_reflect_sky);\n\n    float diff = ocean_diffuse(nor, light_dir, 4.0);\n    vec3 refracted = sea_base + diff * sea_water_color * 0.15;\n\n    col = mix(refracted, reflected, fresnel);\n\n    float atten = max(1.0 - dot(dist, dist) * 0.0008, 0.0);\n    float sea_height = 0.6;\n    col += sea_water_color * (pos.y - sea_height) * 0.12 * atten;\n\n    col += vec3(ocean_specular(nor, light_dir, -halfway_dir, 30.0));\n\n    final_col = pow(col, vec3(1.8));\n\n  } else if (mat_id == 2.0) {\n\n    // Terrain\n\n    vec3 brown_a = vec3(0.509, 0.317, 0.188); // rgb(130, 81, 48) #825130\n    vec3 brown_b = vec3(0.607, 0.364, 0.203); // rgb(155, 93, 52) #9B5D34\n    vec3 brown_c = vec3(0.674, 0.611, 0.611); // rgb(172, 156, 156) #AC9C9C\n\n    vec3 sc = vec3(0.006, 0.04, 0.006);\n\n    vec3 view_dir = normalize(ro - pos);\n\n    // light 1\n\n    vec3 light_dir = normalize(g_light_pos);\n    float diff = max(dot(nor, light_dir), 0.0);\n    vec3 halfway_dir = normalize(light_dir + view_dir);\n\n    // base diffuse color from rock texture, acting as ambient component\n    #ifdef TOOL\n    vec3 rock = tex_3d(tex_rock, pos*sc*0.7, nor).rgb*1.05;\n    #else\n    vec3 rock = tex_3d(tex_rock, pos*sc, nor).rgb;\n    #endif\n\n    vec3 col = mix(brown_a, rock, 0.4);\n\n    col = diff*col*0.2 + rock*0.8*smoothstep(0.0, 0.2, diff);\n\n    // light 2\n\n    light_dir = normalize(g_light_2_pos);\n    diff = max(dot(nor, light_dir), 0.0);\n    halfway_dir = normalize(light_dir + view_dir);\n\n    col += pow(diff * brown_c, vec3(2.0)) * 0.2;\n\n    // occlusion\n    // produces some nasty black discontinuities but luckily they are mostly in the shadow\n    #if (ENABLE_AO == 1)\n    col *= calc_ao(pos, nor);\n    #endif\n\n    // fade to dark with distance\n    float a = smoothstep(0.0, 350.0, pos.z - g_camera_pos.z);\n    col = mix(col, brown_a*vec3(.05, .05, .15), a*a);\n\n    // rocks washed by the ocean should be darker\n    a = smoothstep(-1.0, 4.0, -pos.y);\n    col -= col*a;\n\n    final_col = col;\n\n  } else if (mat_id == 3.0) {\n\n    // Spaceship\n\n    vec3 diffuse_color = vec3(0.);\n    vec3 col = diffuse_color;\n\n    vec3 light_dir = normalize(g_light_pos - pos);\n    float diff = max(dot(nor, light_dir), 0.0);\n\n    vec3 view_dir = normalize(ro - pos);\n    vec3 halfway_dir = normalize(light_dir + view_dir);\n\n    float fresnel = 1.0 - max(dot(nor, view_dir),0.0);\n    fresnel = pow(fresnel, 3.0);\n\n    vec3 ref_rd = reflect(-rd, nor);\n    vec3 reflected = sky_color(ref_rd);\n\n    col = mix(diffuse_color, reflected, fresnel);\n\n    float spec = pow(max(dot(nor, halfway_dir), 0.0), 40.0);\n\n    col = max(diff, 0.35)*col + 0.8*spec*reflected;\n\n    final_col = col;\n\n  } else if (mat_id == 100.0) {\n\n    // checker board pattern\n    final_col = checker_board(pos.xz);\n\n  } else if (mat_id == 101.0) {\n\n    final_col = vec3(0., 1., 0.);\n\n  }\n\n  return final_col;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  vec3 col = vec3(0.0);\n\n  // normalized image plane, (0,0) is the center, (0.5,0.5) is top right\n  vec2 p = -1.0 + 2.0 * frag_coord.xy / i_resolution.xy;\n  // scale to fit height\n  p.x *= i_resolution.x / i_resolution.y;\n\n  // scale up to see more, save original scale\n  vec2 po = p;\n  p = po*1.5;\n\n  // === Camera takes ===\n\n  vec3 camera_start_pos, camera_start_lookat, camera_end_pos, camera_end_lookat = vec3(0.);\n  float t, t0, t1 = 0.;\n\n  // four camera takes: 20s, 20s, 20s, 10s\n  t = mod(i_time, 70.0);\n\n  if (t < 20.0) {\n\n    // Take 1.\n    // looking into the bay, low and out\n\n    t0 = 0.; t1 = 20.;\n\n    camera_start_pos    = vec3(-30.0, 10.0, -45.0);\n    camera_start_lookat = vec3(100.0, 20.0, 120.0);\n\n    camera_end_pos    = vec3(-20.0, 10.0, -20.0);\n    camera_end_lookat = vec3(80.0, 20.0, 100.0);\n\n  } else if (t < 40.) {\n\n    // Take 2.\n    // the sky with moon behind spaceship\n\n    p = po*0.7;\n\n    t0 = 20.; t1 = 40.;\n\n    camera_start_pos    = vec3(-20.0, 15.0, 0.0);\n    camera_start_lookat = vec3(100.0, 50.0, 150.0);\n\n    camera_end_pos    = vec3(-20.0, 10.0, 0.0);\n    camera_end_lookat = vec3(45.0, 20.0, 100.0);\n\n  } else if (t < 60.) {\n\n    // Take 3.\n    // looking at the spaceship\n\n    t0 = 40.; t1 = 60.;\n\n    camera_start_pos    = vec3(-10.5, 8.0, 130.0);\n    camera_start_lookat = vec3(45.0, 35.0, 100.0);\n\n    camera_end_pos    = vec3(-20.0, 10.0, 0.0);\n    camera_end_lookat = vec3(35.0, 12.0, 100.0);\n\n  } else if (t < 70.) {\n\n    // Take 4.\n    // spaceship in the light\n\n    t0 = 60.; t1 = 70.;\n\n    camera_start_pos    = vec3(-10.5, 8.0, 110.0);\n    camera_start_lookat = vec3(45.0, 30.0, 110.0);\n\n    camera_end_pos    = vec3(-20.0, 14.0, 90.0);\n    camera_end_lookat = vec3(45.0, 30.0, 110.0);\n\n  }\n\n  g_camera_pos = mix(camera_start_pos, camera_end_pos, smoothstep(t0, t1, t));\n  g_camera_lookat = mix(camera_start_lookat, camera_end_lookat, smoothstep(t0, t1, t));\n\n  // === Camera ===\n\n  // ray origin is camera position\n  vec3 ro = g_camera_pos;\n\n  vec2 mo = -1.0 + 2.0 * i_mouse.xy / i_resolution.xy;\n  mo.x *= i_resolution.x / i_resolution.y;\n\n  // camera vectors\n\n  // rotate the front vector with angles mo.x and mo.y\n  mat3 m = rot_xy(vec2(HALF_PI*mo.y, HALF_PI*mo.x) * vec2(0.5));\n  // FIXME mo (0,0) should be equal to no rotation but currently is looking to left and down\n  //vec3 cam_front = normalize(g_camera_lookat - g_camera_pos) * m;\n  vec3 cam_front = normalize(g_camera_lookat - g_camera_pos);\n  vec3 cam_right = normalize(cross(cam_front, g_world_up));\n  vec3 cam_up    = normalize(cross(cam_right, cam_front));\n\n  // ray direction toward camera front vector, shifted with screen pos xy\n  vec3 rd = normalize(p.x*cam_right + p.y*cam_up + 2.0*cam_front);\n\n  // === Render ===\n\n  vec2 res = cast_ray(ro, rd);\n  if (res.y > 0.0) {\n    col = material_color(ro, rd, res.x, res.y, ro+rd*res.x);\n  } else {\n    vec2 uv = frag_coord.xy / i_resolution.xy;\n    col = texture(tex_sky, uv).rgb;\n  }\n\n  // === Debug Overlay ===\n\n  if (DEBUG == 1) {\n    res = cast_ray_debug(ro, rd);\n    if (res.y > 0.0) {\n      col = vec3(0., 1., 0.);\n    }\n  }\n\n  frag_color = vec4(clamp(col, 0., 1.), 1.0);\n}\n\n// === General Math ============================================================\n\n// general rotation matrix for pitch and yaw\nmat3 rot_xy(vec2 angle) {\n  vec2 c = cos(angle);\n  vec2 s = sin(angle);\n\n  return mat3(c.y      ,   0.0,  -s.y,\n              s.y * s.x,   c.x,   c.y * s.x,\n              s.y * c.x,  -s.x,   c.y * c.x);\n}\n\n// === Textures ================================================================\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex_3d(sampler2D t, in vec3 p, in vec3 n){\n  n = max(abs(n) - .2, 0.001);\n  n /= dot(n, vec3(1));\n  vec3 tx = texture(t, p.yz).xyz;\n  vec3 ty = texture(t, p.zx).xyz;\n  vec3 tz = texture(t, p.xy).xyz;\n\n  // Convert sRGB to linear by squaring approximation\n  return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n// === SDF Operations ==========================================================\n\nvec2 op_u(vec2 d1, vec2 d2) {\n  return (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat op_smin(float a, float b, float k) {\n  float h = clamp(.5+.5*(b-a)/k, 0.0, 1.0 );\n  return mix(b,a,h)-k*h*(1.-h);\n}\n\nfloat op_smax(float a, float b, float k){\n  float h = clamp(.5+.5*(a-b)/k, 0.0, 1.0);\n  return mix(b,a,h)+h*(1.-h)*k;\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid op_r(inout vec2 p, float a) {\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat op_mod_polar(inout vec2 p, float repetitions) {\n  float angle = 2.0*PI/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\n// === SDF Primitives ==========================================================\n\nfloat sd_plane(vec3 p) {\n  return p.y;\n}\n\nfloat sd_sphere(vec3 p, float s) {\n  return length(p)-s;\n}\n\nfloat sd_box(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sd_torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Cylinder standing upright on the xz plane\nfloat sd_cylinder(vec3 p, float r, float height) {\n  float d = length(p.xz) - r;\n  d = max(d, abs(p.y) - height);\n  return d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat sd_capsule(vec3 p, float r, float c) {\n  return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\nfloat sd_cone_section(vec3 p, float h, float r1, float r2) {\n  float d1 = -p.y - h;\n  float q = p.y - h;\n  float si = 0.5*(r1-r2)/h;\n  float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n  return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// === Raymarch Helpers ========================================================\n\nvec2 cast_ray(vec3 ro, vec3 rd) {\n  float tmax = FAR_CLIP;\n  float precis = 0.002; // hit precision\n  float sm = 0.9; // smaller steps\n\n  float t = 0.1; // first step size\n  float m = -1.0; // material id\n\n  for (int i=0; i<FAR_STEPS; i++) {\n    vec2 res = map(ro + rd * t);\n    if (res.x < precis || t > tmax) break;\n    t += res.x * sm;\n    m = res.y;\n  }\n\n  if (t > tmax) m = -1.0;\n\n  return vec2(t,m);\n}\n\nvec2 cast_ray_debug(vec3 ro, vec3 rd) {\n  float tmax = FAR_CLIP;\n  float precis = 0.002; // hit precision\n  float sm = 0.9; // smaller steps\n\n  float t = 0.1; // first step size\n  float m = -1.0; // material id\n\n  for (int i=0; i<FAR_STEPS; i++) {\n    vec2 res = map_debug(ro + rd * t);\n    if (res.x < precis || t > tmax) break;\n    t += res.x * sm;\n    m = res.y;\n  }\n\n  if (t > tmax) m = -1.0;\n\n  return vec2(t,m);\n}\n\n// Template - 3D by iq\n// https://www.shadertoy.com/view/ldfSWs\n// glsl-sdf-normal\n// https://github.com/glslify/glsl-sdf-normal\nvec3 calc_normal(vec3 pos, float eps) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * map( pos + v1*eps ).x +\n                    v2 * map( pos + v2*eps ).x +\n                    v3 * map( pos + v3*eps ).x +\n                    v4 * map( pos + v4*eps ).x );\n}\n\nvec3 calc_normal(vec3 pos) {\n  return calc_normal(pos, 0.02);\n}\n\n// === Lighting Helpers ========================================================\n\n// Light Attenuation\n// http://gamedev.stackexchange.com/a/56934\nfloat light_attenuation(vec3 light_pos, vec3 surf_pos, float radius) {\n  float dist = distance(surf_pos, light_pos);\n  float att = clamp(1.0 - dist / radius, 0.0, 1.0);\n  att *= att;\n  return att;\n}\n\n// iq's\nfloat calc_ao(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for( int i=0; i<5; i++ ) {\n    float hr = 0.01 + 0.12*float(i)/4.0;\n    vec3 aopos =  nor * hr + pos;\n    float dd = map( aopos ).x;\n    occ += -(dd-hr)*sca;\n    sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvec3 checker_board(vec2 uv) {\n  float f = mod(floor(5.0*uv.x) + floor(5.0*uv.y), 2.0);\n  vec3 col = 0.4 + 0.1 * f * vec3(1.0);\n  return col;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Bloom pass\n//\n// Horizontal blur only\n//\n// Jack-o'-lantern's Revenge by P_Malin https://www.shadertoy.com/view/Mt2yzK\n///////////////////////////////////////////////\n\n#define tex_raymarch iChannel0\n#define tex_bloom iChannel1\n\n#define KERNEL_SIZE 8\n#define BLOOM_STRENGTH 16.0\n#define KERNEL_SIZE_F float(KERNEL_SIZE)\n\n#define HORIZONTAL_BLUR_SIZE 128\n#define HORIZONTAL_BLOOM_STRENGTH 128.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 gBloomSize = iResolution.xy / 4.0;\n\n  vec2 vUV = fragCoord.xy / gBloomSize;\n\n  if ( vUV.x > 1.0 || vUV.y > 1.0 ) {\n    discard;\n    return;\n  }\n\n  // output linear color\n  //fragColor = texture( tex_raymarch, vUV );\n  //return;\n\n  vec3 vResult = vec3(0.0);\n\n  float fTot = 0.0;\n\n  {\n    float fY = -KERNEL_SIZE_F;\n\n    for( int y=-KERNEL_SIZE; y<=KERNEL_SIZE; y++ ) {\n\n      float fX = -KERNEL_SIZE_F;\n\n      for( int x=-KERNEL_SIZE; x<=KERNEL_SIZE; x++ ) {\n\n        vec2 vOffset = vec2( fX, fY );\n        vec2 vTapUV =  (fragCoord.xy + vOffset + 0.5) / gBloomSize;\n\n        vec4 vTapSample = textureLod( tex_raymarch, vTapUV, 0.0 ).rgba;\n\n        if( vTapUV.y < 1.0 / iResolution.y ) {\n          vTapSample = vec4(0.0);\n        }\n\n        vec2 vDelta = vOffset / KERNEL_SIZE_F;\n\n        float f = dot( vDelta, vDelta );\n        float fWeight = exp2( -f * BLOOM_STRENGTH );\n        vResult += vTapSample.xyz * fWeight;\n        fTot += fWeight;\n\n        fX += 1.0;\n      }\n\n      fY += 1.0;\n    }\n  }\n\n  {\n    float fY = 0.0;\n    float fX = -float(HORIZONTAL_BLUR_SIZE);\n    for( int x=-HORIZONTAL_BLUR_SIZE; x<=HORIZONTAL_BLUR_SIZE; x++ ) {\n\n      vec2 vOffset = vec2( fX, fY );\n      vec2 vTapUV =  (fragCoord.xy + vOffset + 0.5) / gBloomSize;\n\n      vec4 vTapSample = textureLod( tex_raymarch, vTapUV, 0.0 ).rgba;\n      if( vTapUV.y < 1.0 / iResolution.y ) {\n        vTapSample = vec4(0.0);\n      }\n\n      vec2 vDelta = vOffset / float(HORIZONTAL_BLUR_SIZE);\n\n      float f = dot( vDelta, vDelta );\n      float fWeight = exp2( -f * HORIZONTAL_BLOOM_STRENGTH );\n      vResult += vTapSample.xyz * fWeight;\n      fTot += fWeight;\n\n      fX += 1.0;\n    }\n  }\n\n  vResult /= fTot;\n\n  vec4 vPrevSample = textureLod( tex_bloom, vUV* gBloomSize / iResolution.xy, 0.0 ).rgba;\n  vResult = max( vResult, vPrevSample.xyz * vec3(0.5, 0.6, 0.7) );\n  //vResult += vPrevSample.xyz * 0.9;\n\n  fragColor = vec4(vResult, 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}