{
    "Shader": {
        "info": {
            "date": "1680934342",
            "description": "Basic cellular automata falling sand example which uses a Margolus neighborhood with randomly applied rules to create more interesting behaviors.\n\nArrow keys to move camera\nPlus (+) / Minus (-) to zoom in/out",
            "flags": 48,
            "hasliked": 0,
            "id": "DsjSzc",
            "likes": 8,
            "name": "Falling Sand CA v1",
            "published": 3,
            "tags": [
                "2d",
                "automata",
                "falling",
                "cellular",
                "sand",
                "margolus"
            ],
            "usePreview": 0,
            "username": "gelami",
            "viewed": 347
        },
        "renderpass": [
            {
                "code": "// 2022-12-10 03:05:10\n\n/*\n * Basic cellular automata falling sand example which uses a Margolus neighborhood\n * with randomly applied rules to create more interesting behaviors.\n *\n * Arrow keys to move camera\n * Plus (+) / Minus (-) to zoom in/out\n *\n * This is one of 4 shaders that explores falling sand cellular automata in the GPU\n *\n * Next entries:\n * Falling Sand CA v2 - gelami\n * https://www.shadertoy.com/view/DsSSRd\n * \n * Falling Sand CA Ultimate - gelami\n * https://www.shadertoy.com/view/msBSWK\n * \n */\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 scene = texelFetch(iChannel2, ivec2(0), 0);\n    float scale = scene.x;\n    vec2 center = scene.zw;\n    \n    fragCoord -= RES * 0.5;\n    fragCoord /= scale;\n    fragCoord += center;\n\n    vec4 h = sampleTex0(fragCoord);\n\n    vec4 r = sampleTex1(ivec2(fragCoord) % 256);\n    \n    vec3 bg = vec3(26, 29, 33) / 255.0;\n    \n    #if 1\n    vec3 col = vec3(225, 177, 89) / 255.0;\n    vec3 hsl = RGBtoHSL(col);\n    \n    hsl.x = hsl.x + (r.z - 0.5) * 5.0 / 255.0;\n    hsl.y = hsl.y + (r.x - 0.5) * 20.0 / 255.0;\n    hsl.z = hsl.z + (r.y - 0.5) * 40.0 / 255.0;\n    \n    #else\n    \n    vec3 col = vec3(0.957,0.714,0.184);\n    vec3 hsl = RGBtoHSL(col);\n    \n    hsl.x = hsl.x - r.y * 3.0 / 255.0;\n    hsl.y = hsl.y + r.z * 0.5;\n    hsl.z = mix(hsl.z, 0.95, pow(r.z, 8.0));\n    #endif\n    \n    col = HSLtoRGB(hsl);\n    \n    col *= 0.9 + 0.1 * r.w;\n    col = mix(bg, col, h.x);\n    \n    vec4 r2 = sampleTex1(ivec2(floor(h.zw / 12.0)) % 256);\n    \n    //col = vec3(h.x * HSLtoRGB(r2.xyz));\n    \n    // Output to screen\n    fragColor = vec4(col, 1);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\nint cellToID(vec4 p)\n{\n    return int(dot(p, vec4(1, 2, 4, 8)));\n}\n\nvec4 IDToCell(int id)\n{\n    return vec4(id%2, (id/2)%2, (id/4)%2, (id/8)%2);\n}\n\nvec4 sampleCells(ivec2 p)\n{\n    //if (p.y < 0)\n    //    return vec4(1, 15, 0, 0);\n\n    //if (p.x < 0 || p.x >= IRES.x || p.y >= IRES.y)\n    //    return vec4(0);\n    \n    p = clamp(p, ivec2(0), IRES-1);  \n    \n    return texelFetch(iChannel0, ivec2(p), 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 2)\n    {\n        if (fragCoord.y == 0.5)\n        {\n            fragColor = vec4(1, 15, fragCoord);\n            return;\n        }\n        \n        /*\n        if (fragCoord.y > RES.y / SCALE)\n        {\n            fragColor = vec4(0);\n            return;\n        }*/\n        \n        bool v = sampleTex1(ivec2(fragCoord) % 256).x < 0.05;\n        fragColor = vec4(v, 0, fragCoord);\n        return;\n    }\n\n    if (iMouse.z > 0.0)\n    {\n        vec4 scene = texelFetch(iChannel2, ivec2(0), 0);\n        float scale = scene.x;\n        vec2 center = scene.zw;\n    \n        vec2 m = (iMouse.xy - RES * 0.5) / scale + center;\n        float d = length(fragCoord - m);\n        bool v = sampleTex1((ivec2(fragCoord) + ivec2(3, 7) * iFrame) % 256).x < 0.2;\n        if (d < 10.0)\n        {\n            fragColor = vec4(1, 0, fragCoord);\n            return;\n        }\n    }\n\n    ivec2 p = ivec2(floor(fragCoord));\n    \n    p += iFrame % 2;\n    \n    ivec2 fp = (p / 2) * 2;\n    \n    ivec2 fr = p & 1;\n    \n    int x = fr.x + (1-fr.y) * 2;\n    \n    fp -= iFrame % 2;\n    p -= iFrame % 2;\n    \n    vec4 t00 = sampleCells(fp + ivec2(0, 0));\n    vec4 t10 = sampleCells(fp + ivec2(1, 0));\n    vec4 t01 = sampleCells(fp + ivec2(0, 1));\n    vec4 t11 = sampleCells(fp + ivec2(1, 1));\n    \n    int id = cellToID(vec4(t00.x, t10.x, t01.x, t11.x));\n    \n    const int rules[16] = int[](\n    \n        // http://www.mirekw.com/ca/rullex_marg.html\n        // Note: Values assume Y Down\n        // Sand\n        0,4,8,12,4,12,12,13, 8,12,12,14,12,13,14,15\n        // Billiards\n        //0,8,4,3,2,5,9,7,1,6,10,11,12,13,14,15\n        \n    );\n    \n    const int sideToSide[16] = int[](\n        // Move side to side\n        //0, 2, 1, 3, 8, 6, 5, 11, 4, 10, 9, 7, 12, 14, 13, 15\n        //0, 1, 2, 3, 8, 5, 6, 7, 4, 9, 10, 11, 12, 13, 14, 15\n        0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 13, 14, 15\n    );\n    \n    const int invertY[16] = int[](\n        // Inverted Y\n        0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15\n    );\n    \n    vec4 v = sampleTex1((ivec2(fp) + ivec2(313, 123) * iFrame) % 256);\n    \n    int r = rules[id];\n    \n    ivec2 o = ivec2(fr.x, fr.y);\n    \n    \n    /*\n    if (r == 5 && o.x == 1 && o.y == 0 || r == 10 && o.x == 0 && o.y == 0)\n    {\n        o.x = 1 - o.x;\n        o.y = 1 - o.y;\n    } else if (r != invertY[id] && o.y == 0)\n    {\n        o.y = 1 - o.y;\n    }*/\n    \n    vec4 b = sampleCells(ivec2(fp) - ivec2(0, 2));\n    \n    // Prevent sand from moving to side on contact\n    float b0 = sampleCells(ivec2(fragCoord) + ivec2(-1, -1)).x;\n    float b1 = sampleCells(ivec2(fragCoord) + ivec2(0, -1)).x;\n    float b2 = sampleCells(ivec2(fragCoord) + ivec2(1, -1)).x;\n\n    if (v.y > 0.8)\n        r = invertY[id];\n    else if (v.x < 0.3 && b.y != 15.0)\n    {\n        r = invertY[sideToSide[invertY[r]]];\n        //o.x = 1 - o.x;\n    }\n    vec4 d = sampleCells(fp + o);\n    \n    vec4 cell = IDToCell(r);\n    \n    fragColor = vec4(cell[x], id, d.zw);\n    //fragColor = d;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define SCALE 4.0\n\n#define ZOOM_POINT vec2(RES * 0.5 / SCALE)\n\n#define EPSILON 1e-4\n\n#define RES iResolution.xy\n#define IRES ivec2(iResolution.xy)\n\n#define sampleTex0(p) texelFetch(iChannel0, ivec2(p) % IRES, 0)\n#define sampleTex1(p) texelFetch(iChannel1, ivec2(p), 0)\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\n\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(0)); }\n\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\n\n// https://www.chilliant.com/rgb2hsv.html\n\nvec3 RGBtoHCV(in vec3 RGB)\n{\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (RGB.g < RGB.b) ? vec4(RGB.bg, -1.0, 2.0/3.0) : vec4(RGB.gb, 0.0, -1.0/3.0);\n    vec4 Q = (RGB.r < P.x) ? vec4(P.xyw, RGB.r) : vec4(RGB.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6.0 * C + EPSILON) + Q.z);\n    return vec3(H, C, Q.x);\n}\n  \nvec3 RGBtoHSV(in vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float S = HCV.y / (HCV.z + EPSILON);\n    return vec3(HCV.x, S, HCV.z);\n}\n\nvec3 RGBtoHSL(in vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1.0 - abs(L * 2.0 - 1.0) + EPSILON);\n    return vec3(HCV.x, S, L);\n}\n\n\nvec3 HUEtoRGB(in float H)\n{\n    float R = abs(H * 6.0 - 3.0) - 1.0;\n    float G = 2.0 - abs(H * 6.0 - 2.0);\n    float B = 2.0 - abs(H * 6.0 - 4.0);\n    return saturate(vec3(R,G,B));\n}\n\nvec3 HSVtoRGB(in vec3 HSV)\n{\n    vec3 RGB = HUEtoRGB(HSV.x);\n    return ((RGB - 1.0) * HSV.y + 1.0) * HSV.z;\n}\n\nvec3 HSLtoRGB(in vec3 HSL)\n{\n    vec3 RGB = HUEtoRGB(HSL.x);\n    float C = (1.0 - abs(2.0 * HSL.z - 1.0)) * HSL.y;\n    return (RGB - 0.5) * C + HSL.z;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_PLUS = 187;\nconst int KEY_MINUS = 189;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 pix = ivec2(fragCoord);\n    \n    if (pix == ivec2(0))\n    {\n        if (iFrame == 0)\n        {\n            fragColor = vec4(SCALE, 0, ZOOM_POINT);\n            return;\n        }\n        \n        vec4 prev = texelFetch(iChannel0, pix, 0);\n    \n        float up = texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).r;\n        float down = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).r;\n        float left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).r;\n        float right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).r;\n    \n        float zoomin = texelFetch(iChannel1, ivec2(KEY_PLUS, 0), 0).r;\n        float zoomout = texelFetch(iChannel1, ivec2(KEY_MINUS, 0), 0).r;\n    \n        vec2 speed = vec2(15.0 / prev.x);\n        float zoom = 0.08;\n        \n        if (zoomin > 0.0)\n            prev.x += zoom;\n        if (zoomout > 0.0)\n            prev.x -= zoom;\n        \n        prev.x = max(prev.x, 1.0);\n    \n        prev.w += up * speed.y;\n        prev.w -= down * speed.y;\n        prev.z -= left * speed.x;\n        prev.z += right * speed.x;\n        \n        prev.zw = clamp(prev.zw, RES * 0.5 / prev.x, RES - RES * 0.5 / prev.x);\n        \n        fragColor = prev;\n        return;\n    }\n\n    fragColor = vec4(0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}