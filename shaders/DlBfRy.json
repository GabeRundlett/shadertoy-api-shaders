{
    "Shader": {
        "info": {
            "date": "1694182207",
            "description": "arrow keys / wasd\n\nbeen wanting to do this for a while so I cobbled together a quick prototype during, ironically, a physics lecture.\n\nsee the indentation in the ground - bound SDFs do not work properly. Yet. I'll see if I can find a solution. ",
            "flags": 48,
            "hasliked": 0,
            "id": "DlBfRy",
            "likes": 6,
            "name": "physicsÕè",
            "published": 3,
            "tags": [
                "raymarching",
                "test",
                "basic",
                "physics"
            ],
            "usePreview": 0,
            "username": "01000001",
            "viewed": 165
        },
        "renderpass": [
            {
                "code": "int maxSteps = 512;\nfloat maxDepth = 500.;\nfloat minDist = 0.001;\nvec3 lightDir = vec3(.8, -.3, .8);\nvec3 spherePos = vec3(0);\nfloat hardness = 10.;\nfloat shadow = .2;\n\nfloat pDF(vec3 p){ // Physics distance function\n    return length(p-spherePos)-1.0;\n}\n\nfloat rDF(vec3 p){ // Render distance function\n    return min(\n        pDF(p), \n        DF(p)\n    );\n}\n\nvec3 rnorm(vec3 p, float eps){ // Render normal\n    return vec3(\n        rDF(p + vec3(eps, 0, 0)) - rDF(p - vec3(eps, 0, 0)),\n        rDF(p + vec3(0, eps, 0)) - rDF(p - vec3(0, eps, 0)),\n        rDF(p + vec3(0, 0, eps)) - rDF(p - vec3(0, 0, eps))\n    )/(2.*eps);\n}\n\nvoid mainImage( out vec4 O, in vec2 U ){\n\n    spherePos = texelFetch(iChannel0, ivec2(0), 0).xyz;\n    lightDir = normalize(lightDir);\n\n    vec2 r = iResolution.xy;\n    vec2 uv = (2.*U - r)/r.y;\n    vec2 muv = (iMouse.xy == vec2(0)?vec2(0):(2.*iMouse.xy - r)/r.y - vec2(0, 1))*vec2(1, .5);\n    \n    float depth = 0.0;\n    vec3 camDir = vec3(-sin(-muv.x)*cos(muv.y), cos(-muv.x)*cos(muv.y), sin(muv.y));\n    vec3 o = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).xyz\n        + vec3(0, 0, -.5) - camDir*(8.);// + length(texelFetch(iChannel0, ivec2(.5, 1.5), 0).xyz*10.));\n        // Cool idea but needs smoothing\n    vec3 camRight = normalize(cross(camDir, vec3(0, 0, 1)));\n    vec3 camUp = (cross(camRight, camDir));\n    vec3 dirV = normalize(camDir*2. + camRight * uv.x + camUp * uv.y);\n    vec3 p;\n    \n    for (int i = 0; i++ < maxSteps;){\n    \n        p = o + dirV * depth;\n        float d = rDF(p);\n        \n        depth += d;\n        \n        if (depth > maxDepth){\n            depth = maxDepth;\n            break;\n        }\n        \n        if (d < minDist){\n            break;\n        }\n    }\n    \n    vec3 norm = rnorm(p, depth * .001);\n    \n    vec3 l;\n    float ldepth = minDist;\n    float light = 5.;\n    float b = 1e20;\n    float c = 1e20;\n    float ph = 1e20;\n    float w = 1./hardness;\n    \n    for (int i = 0; i++ < maxSteps;){\n    \n        l = p + norm*minDist + lightDir * ldepth;\n        float d = rDF(l);\n        if (d < b){\n            c = b;\n            b = d;\n        }\n                                \n        float y = (i == 0)?0.:d*d/(2.0*ph);\n        float a = sqrt(d*d-y*y);\n        c = min( c, a/(w*max(0.0,ldepth-y)) );\n        ph = d;\n        ldepth += d;\n\n        if (ldepth > maxDepth){\n            ldepth = maxDepth;\n            break;\n        }\n        \n        if (d < minDist){\n            c = 0.;\n            break;\n        }\n    }\n        \n    O = vec4(.1, .4, .9, 1);\n    light *= smoothstep(0., 1., c+shadow);    \n    light *= max(0., (dot(norm, lightDir))) / depth;\n    O.xyz *= light;    \n    \n    O = pow(O, vec4(1./2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define update;     if (x < minDist) minDist = x;\n    \n#define rot(x) mat2(cos(x + vec4(0, 33, 11, 0)))\n    \nfloat boxDF( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat DF(vec3 p){\n    float minDist = 1e20;\n    float x = 0.;\n    \n    \n    x = length(p-vec3(5, 0, -6)) - 5.;\n    update;\n    \n    \n    x = max(boxDF(p-vec3(-2.5, 8, 0), vec3(3)), -length(p-vec3(0, 5,2.8))+5.);\n    update;\n\n\n    //x = max(boxDF(p-vec3(-10, 17, -5), vec3(6)), -length(p-vec3(-11, 17, 3))+5.);\n        \n    x = max(p.z + 2., -length(p-vec3(-11, 17, 0))+5.);\n    update;\n        \n    p.y -= 1.;\n    p.xy *= rot(1.);\n    x = boxDF(p-vec3(0, 1.5, -2.2), vec3(1));\n    update;\n    \n    \n    p.z += .8;\n    p.yz *= rot(.3);\n    x = boxDF(p-vec3(0, -1., -2), vec3(1));\n    update;\n    \n    \n\n    return minDist;\n}\n\n\n\nvec3 pnorm(vec3 p, float eps){ // Physics normal\n    return vec3(\n        DF(p + vec3(eps, 0, 0)) - DF(p - vec3(eps, 0, 0)),\n        DF(p + vec3(0, eps, 0)) - DF(p - vec3(0, eps, 0)),\n        DF(p + vec3(0, 0, eps)) - DF(p - vec3(0, 0, eps))\n    )/(2.*eps);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define lt  37\n#define up  38\n#define rt  39\n#define dn  40\n#define lup 87\n#define llt 65\n#define ldn 83\n#define lrt 68\n\n\nfloat elasticity = .8;\nfloat drag = .02;\n\nvoid mainImage( out vec4 O, vec2 U ){\n    if (U.y < 2. && U.x < 1.){\n        vec3 P;\n        vec3 V;\n        \n        vec2 r = iResolution.xy;\n        vec2 muv = iMouse.xy == vec2(0)?vec2(0):(2.*iMouse.xy - r)/r.y;\n        vec3 camDir = vec3(-sin(-muv.x)*cos(muv.y), cos(-muv.x)*cos(muv.y), sin(muv.y));\n        vec3 camRight = normalize(cross(camDir, vec3(0, 0, 1))) * length(camDir.xy);\n        \n        if (iFrame < 20){\n            P = vec3(0, 1, 1);\n            V = vec3(0, 0, 0);\n            if (U.y ==  .5) O.xyz = P;\n            if (U.y == 1.5) O.xyz = V;\n        } else {\n            P = texelFetch(iChannel0, ivec2(U.x, 0), 0).xyz;\n            V = texelFetch(iChannel0, ivec2(U.x, 1), 0).xyz; // Expandable to more physics things\n            // Process\n            \n            V.z -= 0.01;\n            \n            float d = DF(P);\n            if (d < 1.){\n                vec3 norm = pnorm(P, 0.0001);\n                V = V*(1.-elasticity) + reflect(V, norm)*elasticity;\n                V -= V*drag;\n                \n                // Solves intersections\n                P += min((DF(P+V*.5)-1.), .0) * -norm;\n            }\n            \n            V.xy += (camRight.xy * (\n                -texelFetch(iChannel3, ivec2(lt, 0), 0).x-texelFetch(iChannel3, ivec2(llt, 0), 0).x+\n                 texelFetch(iChannel3, ivec2(rt, 0), 0).x+texelFetch(iChannel3, ivec2(lrt, 0), 0).x)+ \n            camDir.xy * (\n                 texelFetch(iChannel3, ivec2(up, 0), 0).x+texelFetch(iChannel3, ivec2(lup, 0), 0).x\n                -texelFetch(iChannel3, ivec2(dn, 0), 0).x-texelFetch(iChannel3, ivec2(ldn, 0), 0).x\n            ))*0.02;\n            \n            \n            P = P+V*.5;\n\n            if (U.y ==  .5) O.xyz = P;\n            if (U.y == 1.5) O.xyz = V;\n        }\n    } \n    \n    if (U == vec2(.5, 2.5)){\n        O = mix(texelFetch(iChannel0, ivec2(U), 0), texelFetch(iChannel0, ivec2(0), 0), .1);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}