{
    "Shader": {
        "info": {
            "date": "1554207945",
            "description": "Just messing around with some terrain stuff an layering them textures.",
            "flags": 0,
            "hasliked": 0,
            "id": "3d2SRG",
            "likes": 5,
            "name": "Terrain Example",
            "published": 3,
            "tags": [
                "terrainsnowgrass"
            ],
            "usePreview": 0,
            "username": "peterekepeter",
            "viewed": 305
        },
        "renderpass": [
            {
                "code": "\n// tweakable values ///////////////////////////////////////////////////////////\n\nfloat water_level = 2.0;\nfloat snow_amount = 4.0;\nfloat grass_amount = 5.0;\nfloat sand_amount = 1.0;\nfloat rock_amount = 1.0;\n\nfloat sun_brightness = 12.0;\nfloat sky_brightness = 1.0;\nvec3 sun_direction = normalize(vec3(0.9,0.5,.2));\n\nvec3 color_sun = vec3(0.9,0.8,0.6);\nvec3 color_sky = vec3(0.2,0.4,0.9);\nvec3 color_snow = vec3(0.96, 0.98, 0.99);\nvec3 color_grass = vec3(0.3,0.5,0.2);\nvec3 color_dirt = vec3(0.24,0.16,0.12);\nvec3 color_rock = vec3(0.52,0.54,0.5);\nvec3 color_sand = vec3(0.9,0.8,0.4);\n        \n//#define SHOW_HEIGHT_LEVELS\n//#define SHOW_NORMALS        \n//#define SHOW_SHADOWS\n      \n\n// implementation begins //////////////////////////////////////////////////////\n\n// procedural 2d noise texture, for given (x,y) return value between 0 and 1\nfloat noise_2d(vec2 p);\n\nfloat distance_from_water(vec3 pos){\n    return pos.y+14.0-water_level;\n}\n\n// returns albedo for given (x,y,z) position and (nx, ny, nz) surface normal\nvec3 terrain_material(vec3 pos, vec3 normal){\n    \n    // altitude taken from y component\n    float altitude = pos.y+5.0;\n    \n    vec4 map1 = texture(iChannel0, pos.xz*0.1);\n    vec4 map2 = texture(iChannel1, pos.xz*0.05);\n    vec4 map3 = texture(iChannel2, pos.xz*0.025);\n    \n    vec3 color = vec3(0); // black\n    \n    // add dirt layer\n    color=mix(color_dirt,\n              color_dirt*0.125, // darker shade of dirt\n              map1.x); // use first texture to add variation\n    \n    // add rock layer\n    color=mix(color, \n              color_rock*map3.xyz*1.5-.1, // use third texture to add variation to rock\n              clamp( // clamp makes sure layer mask is valid (values between 0 and 1)\n                  8.0*(length(normal.xz)*rock_amount // slopes should be rocky\n                       + altitude*0.5-3.0+map1.z*0.5)*0.1, // add more rock at higher altitudes\n                    0.0, 1.0));\n    \n    float sand = clamp(normal.y*4.0*sand_amount // don't put sand on slope\n                       - distance_from_water(pos)*16.0 // the further we're from water, the less sand\n                       , 0.0, 1.0);\n    \n    // add sand layer\n    color=mix(color, color_sand, sand);\n    \n    // add grass layer\n    color=mix(color, \n              color_grass*map2.xyz*1.4, \n              clamp(map2.y*8.0 // add variation based on texture\n                    + normal.y*2.5 // add more grass on flat areas (not slope)\n                    + normal.x // more grass on east side of mountains\n                    - altitude*0.1 // less grass on higher altitudes\n                    - 10.0 + grass_amount // constant value to adjust grass amount\n                    - color.y*2.0 // less grass where previous layers have bright color\n                    - sand, // less grass where we have sand\n                    0.0,1.0));\n    \n    // add snow layer\n    color=mix(color, \n              color_snow, \n              clamp(map1.y*2.0 // add variation using texture 1\n                    + normal.y*4.0 // more snow on flat (not slope) terrain\n                    + altitude // more slow on higher altitude\n                    - 6.5 + snow_amount // manual adjustment using constant value\n                    , 0.0, 1.0));\n    \n    // make sure components of final color is not above 1.0f for correct shading\n    return clamp(color, 0.0, 1.0);\n}\n\nfloat heightmap(vec2 coord2d)\n{\n    float altitude =.0;\n    \n    // create a mask for mountain biome\n    float mountains = noise_2d(coord2d*0.05); \n    \n    altitude += noise_2d(coord2d*0.06125)*16.0*mountains; // rough shape of mountain \n    altitude += noise_2d(coord2d*0.25)*4.0*mountains;\n    altitude += noise_2d(coord2d*0.5+altitude*0.5)*2.0*mountains;\n    altitude += noise_2d(coord2d*2.0)*0.5*mountains;\n    altitude += noise_2d(coord2d*8.0)*0.125*mountains; // smaller details of mountain\n    \n    return altitude;\n}\n\nvec3 background_fn(vec3 dir){\n    \n    vec3 background = sky_brightness*color_sky*pow(2.0-abs(dir.y), 4.0);\n    return background + pow(max(.0,dot(dir, sun_direction)), 200.0)*sun_brightness;\n}\n\n// rendering and shading ////////////////////////////////////////////////\n\nfloat df(vec3 pos){ // distance from geometry\n    float terrain = pos.y+4.0;\n    terrain += 10.0-heightmap(pos.xz);\n    return min(terrain, distance_from_water(pos));\n}\n\nvec2 rot(vec2 v, float a){ // rotate\n    float c = cos(a), s = sin(a);\n    return vec2(\n        v.x*c - v.y*s,\n        v.x*s + v.y*c);\n}\n\nvec3 nf(vec3 pos, float smoothing){ // normal function\n    vec2 e = vec2(0, smoothing);\n    float c = df(pos+smoothing);\n    return normalize(vec3(\n        c-df(pos-e.yxx),\n        c-df(pos-e.xyx),\n        c-df(pos-e.xxy)\n    ));\n}\n\nfloat hash(float x); vec3 hash(vec3 v); float hash(vec2 v);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (fragCoord.xy-iResolution.xy*.5)/iResolution.yy;\n    vec2 mouse = (iMouse.xy-iResolution.xy*.5)/iResolution.yy;\n\n    vec3 opos = vec3(0,0,-4. +iTime*2.0);\n    vec3 pos = opos;\n    vec3 dir = normalize(vec3(cuv,1));\n    \n    //pos.xz = rot(pos.xz, mouse.x);\n    dir.xz = rot(dir.xz, mouse.x);\n    dir.yz = rot(dir.yz, mouse.y);\n    \n    \n    pos += hash(cuv)*dir;\n    \n    vec3 ldir = sun_direction;\n    \n    int i, mi=200;\n    float dist, spd=1.0;\n    for(i=0; i<mi; i=i+1){\n        dist = df(pos);\n        pos += dist*dir*spd;\n        if (dist<-0.0){\n            spd*=.5;\n        }\n        else if ((dist>0.005&&dist<0.005)||dist>100.0) { break; }\n    }\n    float totald = length(opos-pos);\n    \n    vec3 background = background_fn(dir);\n    vec3 color = background;\n    \n    if (dist < 0.1){\n        color=vec3(.0);\n        vec3 normal = nf(pos,0.2);\n        vec3 albedo;\n        \n        float refl=0.5;\n        if (distance_from_water(pos)<=dist){\n            refl=0.5;\n            albedo=vec3(0.15,0.19,0.13);\n            normal=vec3(0,1,0);\n        }else {\n        \talbedo = terrain_material(pos, normal);\n            refl=.0;\n        }\n        \n        #ifdef SHOW_HEIGHT_LEVELS\n        albedo = 1.0/(1.0+vec3(pow(abs(sin(pos.y*4.0)),0.5)));\n        refl=.0;\n        #endif\n        \n        #ifdef SHOW_NORMALS\n        albedo = (normal*.5+.5);\n        refl=.0;\n        #endif\n        \n        #ifdef SHOW_SHADOWS\n        albedo = vec3(1.0);\n        refl=.0;\n        #endif\n        \n        vec3 npos = pos;\n        float ao = .0;\n        int ao_i, max_ao_i=4;\n        for (ao_i=0; ao_i<max_ao_i; ao_i++){\n            float d=pow(1.1, float(ao_i-4));\n       \t\tvec3 ndir = (hash(npos)-0.5+vec3(0,0.5,0))*d;\n            npos = pos + ndir;\n            ao += (df(npos)+(d*.5))/d;\n        }\n        ao *= 1./float(max_ao_i);\n        ao=df(pos+normal)*.5+.5;\n        ao=df(pos+normal*0.5)+.5;\n        ao=df(pos+normal*4.0)*.25+.5;\n        color+=albedo*ao*color_sky*sky_brightness;\n        \n        float shadow=1.0;\n        int sh_i, sh_max=40;\n        vec3 spos = pos+ldir;\n        float strav =.1;\n        for(sh_i=0; sh_i<sh_max; sh_i++){\n            float dist = df(spos+ldir*strav);\n            shadow=min(dist/strav,shadow);\n            strav+=dist;\n            if(shadow<.001||dist>100.0){ break; }\n        }\n        shadow=max(.0,shadow);\n        float diffuse = max(0.,dot(normal, ldir));\n        color+=albedo*diffuse*color_sun*sun_brightness*shadow;\n        \n        if (refl>.0){\n            vec3 refldir=reflect(dir, normal);\n            color += background_fn(refldir)*refl;\n        }\n    }\n    color=max(vec3(.0), color);\n\tcolor = mix(background, color, 1.0/(1.0+totald*0.0025));\n    \n    color = color*1.2 / (1.+color);\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n\n// implementation details /////////////////\n\n\nfloat hash(float x){ return fract(pow(sin(x*41.7179)*41.1536, 2.0)*13.145); }\nvec3 hash(vec3 v){ return vec3(hash(v.x+v.y), hash(v.y+v.z), hash(v.z+v.x)); }\nfloat hash(vec2 v){ return hash(v.x-v.y*59.7177); }\n\n// procedural 2d noise texture, for given (x,y) return value between 0 and 1\nfloat noise_2d(vec2 p){\n    vec2 f = fract(p);\n    vec2 id = p - f;\n    float a = hash(id.xy+vec2(0,0));\n    float b = hash(id.xy+vec2(1,0));\n    float c = hash(id.xy+vec2(0,1));\n    float d = hash(id.xy+vec2(1,1));\n    return mix(\n        mix(a,b, f.x),\n        mix(c,d, f.x),\n        f.y\n\t);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}