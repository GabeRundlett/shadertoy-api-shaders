{
    "Shader": {
        "info": {
            "date": "1666627624",
            "description": "Raymarching",
            "flags": 0,
            "hasliked": 0,
            "id": "sltBRr",
            "likes": 3,
            "name": "Raymarching 2.0 WIP",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "FifthStateOfMatter",
            "viewed": 256
        },
        "renderpass": [
            {
                "code": "#define lPos vec3(12, 25, -10)\n#define PI 3.1415926545\n#define degreesToRadians PI/180.0\n#define FOV 90.0*degreesToRadians\n#define epsilon 0.01\n#define maxSteps 500\n#define maxDist 300.0\n#define fogDensity 1.0\n#define fogColor vec3(0.4, 0.7, 0.9)\n\nfloat random(vec3 p){\n    return fract((sin(p.x*203.24 + 20398.243)*sin(p.y*834.29 + 2382.2033)*sin(p.z*405.09))*20384.043);\n}\n\nfloat noise2(vec2 p){\n    vec2 luv = fract(p);\n    vec2 id = floor(p);\n    luv = luv*luv*(3.0 - 2.0*luv);\n    float bl = random(vec3(id, 1));\n    float br = random(vec3(id + vec2(1, 0), 1));\n    float b = mix(bl, br, luv.x);\n    \n    float tl = random(vec3(id + vec2(0, 1), 1));\n    float tr = random(vec3(id + vec2(1, 1), 1));\n    float t = mix(tl, tr, luv.x);\n    return mix(b, t, luv.y);\n}\n\nfloat noise3(vec3 p){\n    vec3 fc = floor(p);\n    vec3 frc = fract(p);\n    frc = smoothstep(0.0, 1.0, frc);\n    \n    float tlf = random(fc + vec3(0, 1, 0));\n    float trf = random(fc + vec3(1, 1, 0));\n    float blf = random(fc + vec3(0, 0, 0));\n    float brf = random(fc + vec3(1, 0, 0));\n    float tlb = random(fc + vec3(0, 1, 1));\n    float trb = random(fc + vec3(1, 1, 1));\n    float blb = random(fc + vec3(0, 0, 1));\n    float brb = random(fc + vec3(1, 0, 1));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    float lerpTopBack = mix(tlb, trb, frc.x);\n    float lerpBottomBack = mix(blb, brb, frc.x);\n    \n    float lerpFront = mix(lerpBottomFront, lerpTopFront, frc.y);\n    float lerpBack = mix(lerpBottomBack, lerpTopBack, frc.y);\n    \n    return mix(lerpFront, lerpBack, frc.z);\n}\n\nfloat f = 1.0/tan(FOV/2.0);\n\nstruct material{\n    vec3 clr;\n    float intensity;\n    float type;\n};\n\nstruct SDF{\n    float dist;\n    material mat;\n};\n\nstruct cam{\n    vec3 pos;\n    vec3 dir;\n};\n\nSDF sphereSDF(vec3 p, float rad, material mat){\n    return SDF(length(p) - rad, mat);\n}\n\nSDF boxSDF(vec3 p, vec3 s, material mat){\n    vec3 q = abs(p) - s;\n    return SDF(length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0), mat);\n}\n\nSDF boxFrameSDF(vec3 p, vec3 s, float sw, float ro, material mat){\n  p = abs(p) - s;\n  vec3 q = abs(p + sw) - sw;\n  return SDF(min(\n      min(\n          length(max(vec3(p.x, q.y, q.z),0.0)) + min(max(p.x, max(q.y, q.z)), 0.0),\n          length(max(vec3(q.x, p.y, q.z),0.0)) + min(max(q.x, max(p.y, q.z)), 0.0)\n      ),\n      length(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0)) - ro, mat);\n}\n\nSDF yPlaneSDF(vec3 p, float y, material mat){\n    return SDF(p.y - y, mat);\n}\n\nSDF opTwist(vec3 p, material mat){\n    const float k = 0.785;\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2 m = mat2(c, -s, s, c);\n    vec3  q = vec3(m*p.xz, p.y);\n    return boxSDF(q, vec3(1, 1, 3), mat);\n}\n\nSDF opRep(in vec3 p, in vec3 c, material mat){\n    vec3 q = mod(p + 0.5*c, c) - 0.5*c;\n    return boxSDF(q, vec3(1, 1, 1), mat);\n}\n\nSDF sceneSDF(vec3 p, float type){\n    float xt = 0.0;\n    float yt = iTime*5.0;\n    float zt = 0.0;\n    \n    mat3 yRotation;\n    yRotation[0] = vec3(cos(yt*degreesToRadians), 0, -sin(yt*degreesToRadians));\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(sin(yt*degreesToRadians), 0, cos(yt*degreesToRadians));\n    \n    mat3 xRotation;\n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, cos(xt*degreesToRadians), -sin(xt*degreesToRadians));\n    xRotation[2] = vec3(0, sin(xt*degreesToRadians), cos(xt*degreesToRadians));\n    \n    mat3 zRotation;\n    zRotation[0] = vec3(cos(zt*degreesToRadians), -sin(zt*degreesToRadians), 0);\n    zRotation[1] = vec3(sin(zt*degreesToRadians), cos(zt*degreesToRadians), 0);\n    zRotation[2] = vec3(0, 0, 1);\n    \n    float f = 2.0;\n    float h = 0.25;\n    float v = -0.0;\n    int d = 1;\n    \n    float n = noise3((p + vec3(5, iTime*v, 0))*f)*h;\n    for(int i = 0; i < d; i++){\n        h /= 2.0;\n        f *= 2.0;\n        v *= 2.0;\n        n += noise3((p + vec3(5, iTime*v, 0))*f)*h;\n    }\n    \n    n /= 2.0;\n    \n    float gf = 0.25;\n    float gh = 0.7;\n    float gv = 0.0;\n    int gd = 2;\n    \n    float gn = noise3((p + vec3(5, iTime*0.5, 2))*gf)*gh;\n    for(int i = 0; i < gd; i++){\n        gh /= 2.0;\n        gf *= 2.0;\n        gv *= 2.0;\n        gn += noise3((p + vec3(5.0 + float(i), iTime*0.5 + float(i), 2.0 + float(i)))*gf)*gh;\n    }\n    \n    gn /= 2.0;\n    \n    //gn += n;\n    \n    SDF ground = yPlaneSDF(p, -0.4, material(vec3(0, 0.1, 0.1), 0.8, 3.0));\n    SDF sun = sphereSDF(p - lPos, 1.0, material(vec3(1), 0.0, 0.0));\n    SDF ball = sphereSDF(p - vec3(0, 1, 10), 1.0, material(vec3(0, 1, 0), 0.8, 2.0));\n    SDF ball2 = sphereSDF(p - vec3(3, 1.5, 12), 1.5, material(vec3(1, 0, 0), 0.4, 2.0));\n    ground.dist -= gn;\n    \n    //Thanks to @dean_the_coder for helping with ray overstepping\n    //ground.dist *= 0.6;\n    \n    float closest;\n    if(type == 0.0){\n        closest = min(sun.dist, min(ground.dist, min(ball.dist, ball2.dist)));\n    }else{\n        closest = min(ground.dist, min(ball.dist, ball2.dist));\n    }\n    \n    if(closest == ground.dist){\n        return ground;\n    }else if(closest == sun.dist){\n        return sun;\n    }else if(closest == ball.dist){\n        return ball;\n    }else if(closest == ball2.dist){\n        return ball2;\n    }\n}\n\nbool raymarch(vec3 orig, vec3 dir, out float t, out material mat, float eps, out float res, float type){\n    t = 0.0;\n    float resol = 1.0;\n    float ph = 1e20;\n    for(int i = 0; i < maxSteps && t < maxDist && t >= 0.0; i++){\n        vec3 r = orig + dir*t;\n        SDF s = sceneSDF(r, type);\n        mat = s.mat;\n        t += s.dist;\n        \n        if(s.dist < eps){\n            resol = 0.0;\n            return true;\n        }\n        \n        float y = s.dist*s.dist/(2.0*ph);\n        float d = sqrt(s.dist*s.dist - y*y);\n        resol = min(resol, 8.0*d/max(0.0, t - y));\n    }\n    res = resol;\n    return false;\n}\n\nvec3 getNormals(vec3 h){\n    return normalize(vec3(\n        sceneSDF(vec3(h.x + epsilon, h.yz), 1.0).dist - sceneSDF(vec3(h.x - epsilon, h.yz), 1.0).dist,\n        sceneSDF(vec3(h.x, h.y + epsilon, h.z), 1.0).dist - sceneSDF(vec3(h.x, h.y - epsilon, h.z), 1.0).dist,\n        sceneSDF(vec3(h.xy, h.z + epsilon), 1.0).dist - sceneSDF(vec3(h.xy, h.z - epsilon), 1.0).dist\n    ));\n}\n\nvec3 reflectRay(vec3 r, vec3 n){\n    return r - 2.0*n*dot(r, n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    cam camera = cam(vec3(0, 4, 0), vec3(5, 0, 0));\n    \n    mat3 projection;\n    \n    projection[0] = vec3(1, 0, 0);\n    projection[1] = vec3(0, 1, 0);\n    projection[2] = vec3(0, 0, f);\n    \n    mat3 xRotation;\n    \n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, cos(camera.dir.x*degreesToRadians), -sin(camera.dir.x*degreesToRadians));\n    xRotation[2] = vec3(0, sin(camera.dir.x*degreesToRadians), cos(camera.dir.x*degreesToRadians));\n    \n    mat3 yRotation;\n    \n    yRotation[0] = vec3(cos(camera.dir.y*degreesToRadians), 0, -sin(camera.dir.y*degreesToRadians));\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(sin(camera.dir.y*degreesToRadians), 0, cos(camera.dir.y*degreesToRadians));\n\n    vec3 orig = camera.pos;\n    vec3 dir = normalize(vec3(uv.xy, 1.0)*xRotation*yRotation*projection);\n    \n    float t;\n    material rMat;\n    float ph;\n    bool r = raymarch(orig, dir, t, rMat, epsilon, ph, 0.0);\n    \n    //Thanks to @spalmer for help with getting the light to display correctly\n    if(!r){\n        t = 500.0;\n    }\n    \n    vec3 lRay = normalize(lPos - (orig + dir*t));\n    \n    vec3 col = mix(fogColor, vec3(1), min(pow(dot(normalize(-lRay), normalize(dir)), 100000.0/(fogDensity*0.1 + 0.7)), 1.0));\n    \n    float d;\n    if(r){\n        vec3 normal = getNormals(orig + dir*t);\n        \n        float lt;\n        material lMat;\n        float shadowClr;\n        bool rL = raymarch((orig + dir*t) + normal*0.1, normalize(lPos - (orig + dir*t)), lt, lMat, 0.0001, shadowClr, 1.0);\n        d = max(dot(normal, lRay), 0.0);\n        float spec = 0.0;\n        if(rMat.type == 1.0){\n            spec = max(pow(d, 15.0), 0.1);\n        }else{\n            spec = 0.0;\n        }\n        \n        float c;\n        \n        if(rMat.type != 0.0){\n            if(rMat.type != 3.0){\n                c = max(d, 0.1)*shadowClr;\n            }else if(rMat.type == 3.0){\n                c = max(d, 0.5);\n            }\n        }else{\n            c = 1.0;\n        }\n        \n        if(rMat.type == 0.0 || lt <= 0.01){\n            shadowClr = 1.0;\n        }\n        \n        float dtl = length(lPos - (orig + dir*t));\n        \n        if(rMat.type != 0.0 && rMat.type != 3.0){\n            col = mix((rMat.clr*max(c, 0.1) + spec)*shadowClr, fogColor, min(t/(1.0/(fogDensity*0.004)), 1.0));\n        }else if(rMat.type == 0.0){\n            col = rMat.clr;\n        }else if(rMat.type == 3.0){\n            //c *= shadowClr;\n            vec3 reflectOrig = (orig + dir*t) + normal*0.01;\n            vec3 reflectD = reflectRay(dir, normal);\n            float reflectT;\n            material reflectMat;\n            float rph;\n            \n            bool reflectMarch = raymarch(reflectOrig + normal*epsilon, normalize(reflectD), reflectT, reflectMat, epsilon, rph, 0.0);\n            if(reflectMarch){\n                float rc;\n                vec3 reflectN = getNormals(reflectOrig + normal*epsilon + normalize(reflectD)*reflectT);\n                if(reflectMat.type != 0.0){\n                    rc = dot(reflectN, normalize(lRay));\n                }else{\n                    rc = 1.0;\n                }\n                col = mix(mix(reflectMat.clr*max(c, 0.5)*max(shadowClr, 0.5)*max(rc, 0.2), rMat.clr*max(c, 0.5)*max(shadowClr, 0.3), rMat.intensity), fogColor, min(t/(1.0/(fogDensity*0.004)), 1.0));\n                //reflectT = 500.0;\n            }else{\n                col = mix(mix(fogColor*max(c, 0.5)*max(shadowClr, 0.5), rMat.clr*max(c, 0.5)*max(shadowClr, 0.3), rMat.intensity), fogColor, min(t/(1.0/(fogDensity*0.004)), 1.0));\n            }\n        }\n        //col = pow(col, vec3(1.0/2.2));\n    }\n    \n    fragColor = vec4(pow(col, vec3(1.0/2.2)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}