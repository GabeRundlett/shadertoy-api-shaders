{
    "Shader": {
        "info": {
            "date": "1502279842",
            "description": "mouse.xy does things.\n\ncane2() tries to make \"m,n\" shapes without the flipped \"r-cane\" or \"u\" \nseems to be not the best approach, but i can not see a better one.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdjBDV",
            "likes": 2,
            "name": "m & mmmmmmmmmm",
            "published": 3,
            "tags": [
                "text",
                "n",
                "h",
                "m",
                "glyph",
                "bisymmetry",
                "cane"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 479
        },
        "renderpass": [
            {
                "code": "//number of extra bows to add to the \"n\" shape, feel free to modify\n#define ExtendNtoM floor((cos(iTime)*.5+.5) *8.)\n//#define ExtendNtoM 8.\n\n//above sets loop iterations, instead of using a \"binary tree of mirrors\".\n//...that would likely outperform a loop with the same result.\n\n/*\nthis is one tricky shape for my \"bisymmetry optimization approach\"\nthat I describe a lot here\nhttps://www.shadertoy.com/view/4dSBWV\n\nits main issue is that the upper bow of the \"n,m,h\" shape is defined by abs(length())\nand you can not pull the length() out of the abs() wrapper too efficiently.\nwhile you usually can do that for many other shapes.\n\nconverting abs() into its branch, into its branchless sign() binomial ...\n...is unlikely worth anything here.\n\nA private (simpler) parent of this shader is \nhttps://www.shadertoy.com/view/Xs2BWV\n*/\n\n#define frame(u) (u-.5*iResolution.xy)*17./iResolution.y\n\n\nfloat maxv(vec2 a){return max(a.x,a.y);}\nfloat maxv(vec3 a){return max(maxv(a.xy),a.z);}\n#define minv(a) -maxv(-a)\n\n//#define stretch(c,m) v=mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch      ; centric, most commonly used, therefore atomic\n#define mStretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus; positive values do not change\n#define mStretchM(u,m) mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u= u+m;return  mStretch(u,m);}\n//stretch plus ; negative values do not change\n#define mStretchP(u,m) mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m) mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n//above is special case that can include the sat() generalization below +u.x;\n//a generalization of clamp(a,0.,1.); for m=vec2(1)\nfloat sat(float a,vec2 m){    \n a=.5*(sign(a)+m.x)*a+m.y;\n a=(sign(2.-a)+1.)*(a-2.)+2.; \n return a*.5;}\nfloat sat(float a){return sat(a,vec2(1));}//return clamp(a,0.,1.); \n\n/*\n//explicit atan2(y,x), hopefully slightly more worksave?\nfloat ata(float x,float y){\n //return atan(x/y);//not quite as work save as below? or rautological either way?\n float a=.5*(1.-sign(x));//pi and -pi are equally valid. doesnt matter which way you rotate?\n float b=atan(x/y);//division by 0 is poblematic, unless multiplied by 0.\n float s=step(y,0.)+step(0.,y)-1.;\n //why do i end u in this tautology?\n //my solution is that equality is an ideal fiction.\n //while the reality is heuristic gradients.\n //the ideal is tautological, art, with null utility.\n return mix(b,a,s);}\n*/\n\n/*\nfloat cane1(vec2 u,vec4 m){\n if(u.y>0.)return abs(length(u)-1.);\n  u.x-=1.;\n if(u.y>m.y)return abs(u.x);return length(u-vec2(0,m.y));\n}*/\n\n\n/*\nfloat halfWorm11(vec2 u){\n float a=length(sign(u.y)*vec2(.5,0)+vec2(abs(u.x)-.5,u.y));\n return abs(a-.5*(1.+sign(u.y)));}\n*/\n\n\n/*\nvec2 left(vec2 u,vec4 m){\n u.y=(mStretchM((u.y-m.x),(m.x+m.y)));\n vec2 e=vec2(u.x+2., u.y );return e;}\nvec2 right(vec2 u,float m){u.y=mStretchM(u.y,m);return u;}\n*/\n\n/*\n//incomplete cane, extension to make m and n...\n//so far this special case has proven obsolete, inferior. therefore i am nt even developing it.\nfloat cane3(vec2 u,vec4 m){\n m=abs(m);\n if(u.y>0.)return abs(length(u)-1.);//the abs outside the length is the main issue here.\n u.x-=1.;   \n return sqrt(abs(dd(vec2(u.x,mStretchM(u.y,m.y)))));\n return abs(length(vec2(u.x,mStretchM(u.y,m.y))));\n}*/\n\n/*\nvec2 halfWorm1h(vec2 u){\n //if(0.>u.y)return inf;\n u.x=abs(u.x)-1.;\n    return u;\n //float c=(u)-1.;\n //return abs(c);\n}*/\n\n\n\n//the above \"cane\" shapes are only needed for \"j\" and \"2\", maybe \"3,6,9,G,R,S\" ?\n//but the \"m,n\" is less efficient when using \"cane\", better use overlapping \"u\"\n\n#define dd(a) dot(a,a)\n\n\n//upside down u-shape\nfloat shapeU(vec2 u,vec4 m){\n m=abs(m);\n if(u.y>0.)return abs(length(u)-1.);//the abs outside the length is the main issue here.\n return sqrt(abs(dd(vec2(abs(u.x)-1.,mStretchM(u.y,m.y)))));}//here the sqrt can be outside.\n\n//mm2() sure simplifies things\n//the dull \"mm2\" shape, suffers from cane3() containing abs(length())\nfloat mm2(vec2 u,vec4 m){m=abs(m);vec2 r;\n r.y=length(vec2(u.x+1.        ,mStretchP(u.y,m.x)   ));   \n r.x=shapeU(vec2(abs(u.x-1.)-1.,u.y),m);                   \n return minv(r.xy);}\n\n//cane2() splits the abs(length) case from the non abs(length) case.\n\n//only the vertical lines of an \"m\" shape! this has some \"fun\" bisymmetry\nvec2 mlines(vec2 u,vec4 m){m=abs(m);\n float o=(ExtendNtoM)*2.;\n if(ExtendNtoM<1.)o=2.;                        \n vec2 e=vec2(u.x+o, (mStretchM((u.y-m.x),(m.x+m.y))) );//left bar(s) \n //(m.x+m.y) can be reduced, depending on ratio\n for(float a=0.;a<ExtendNtoM;a++){u.x=abs(u.x-1.)-1.;} //multiple right bars\n u.y=mStretchM(u.y,m.y);         //right bars\n //by changing the bisymmetry below, you can get multiple \"left bars\"\n //but not in its binomial form as it is below, you need to muultiply that one out...\n float t=sign(dd(u)-dd(e))+1.;//bisymmetry sign\n vec2 l=u+.5*(e-u)*t;         //bisymmetry binomial\n return l;}\n//\"smart n-m shapes, utilizing mlines()\n//the above liikely nicely merges into the below?\nfloat cane2(vec2 u,vec4 m){\n float l=length(mlines(u,m));\n if(u.y<0.)return l;//lower half of fragments skips the calculation of the arc!\n for(float a=0.;a<ExtendNtoM;a++){u.x=abs(u.x)-2.;}//multiple right arcs\n float w=length(vec2(u.x+1.,u.y));//halfWorm1h(u);\n float r=min(w,l+1.);\n     //r=sqrt(dd(w));r=sqrt(dd(l))+1.;\n  //  r=sqrt(min((dd(w))+1.,(dd(l)))); //getting the sqrt() out, seems to not be worth it.\n return abs(r-1.);\n}\n\nvoid mainImage(out vec4 O,in vec2 U){\n vec2 u=frame(U);\n vec4 m=vec4(frame(iMouse.xy),frame(iMouse.zw));\n\n vec3 c=vec3(0);\n u.x+=1.;\n //c.r=cane1(u,m)-.2;\n c.b=shapeU(u,m)-.3;//a base shape for mm2(), \"u\" shape easily defeats \"r\"shape\"\n c.g=mm2(u,m)-.3;   //a straightforward solution, using shapeU()\n u.x-=1.;\n c.r=cane2(u,m)-.3;//me trying to imptove the unimprovable, by not using shapeU()\n //cane2() splits one problem of mm2() into 2 smaller problems.\n //one of these 2 seems unsolvable, the other one is just too hard for me to boher.\n    \n c=abs(c-.4)-.2;//turn into outline of self\n    \n //c.b=smoothstep(.1,-.1,c.b);\n #if 1\n float fuzz=9./min(iResolution.x,iResolution.y);\n c=smoothstep(fuzz,-fuzz,c);\n #else\n c=fract(c*2.);\n #endif\n O= vec4(c,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}