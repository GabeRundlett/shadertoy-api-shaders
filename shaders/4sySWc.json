{
    "Shader": {
        "info": {
            "date": "1502626235",
            "description": "Overdone attempt to make something new and exciting. \nNow it's only something new..",
            "flags": 32,
            "hasliked": 0,
            "id": "4sySWc",
            "likes": 15,
            "name": "Space Quest",
            "published": 3,
            "tags": [
                "fractal",
                "texture",
                "alien",
                "kali"
            ],
            "usePreview": 0,
            "username": "bergi",
            "viewed": 828
        },
        "renderpass": [
            {
                "code": "/** Space Quest \n\thttps://www.shadertoy.com/view/4sySWc\n\n\t(cc) 2016/17, stefan berke\n\n\tBased on \"Cave Quest\" https://www.shadertoy.com/view/XdGXD3\n\n\tKali-Set abused everywhere. \n    Was supposed to look like a creepy endless alien city but got lost\n    in all the parameters.. Quick hacks and all that tend to make the applied \n\tformulas for rendering unreusable.\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 suv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y * 2.;\n        \n    vec3 col = texture(iChannel0, suv).xyz;\n\n    vec2 of = vec2(.5,.6);\n    float zoom=.987;\n    \n    vec4 gat = vec4(0);\n    for (float i=0.; i<20.; ++i)\n    {\n    \tsuv = (suv-of)*zoom+of;\n        float amt = pow(1.-i/20., 2.5);\n        vec3 tcol = texture(iChannel0, suv).xyz;\n        //amt *= dot(tcol, tcol);\n        gat.xyz += tcol * amt;\n        gat.w += amt;\n    }\n    gat.xyz /= gat.w;\n    col = max(col, gat.xyz * smoothstep(0., .3, suv.y));\n    \n    col *= pow(1.-dot(suv-.5,suv-.5)/.5, .6);\n     \n\tfragColor = vec4(pow(col,vec3(.8)),1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/** Space Quest \n\thttps://www.shadertoy.com/view/4sySWc\n\n\t(cc) 2016/17, stefan berke\n\n\tBased on \"Cave Quest\" https://www.shadertoy.com/view/XdGXD3\n\n\tKali-Set abused everywhere. \n    Was supposed to look like a creepy endless alien city but got lost\n    in all the parameters.. Quick hacks and all that tend to make the applied \n\tformulas for rendering unreusable.\n*/\n\n\n// minimum distance to axis-aligned planes in kali-space\n// uses eiffie's mod (/p.w) https://www.shadertoy.com/view/XtlGRj\n// to keep the result close to a true distance function\nvec3 kali_set(in vec3 pos, in vec3 param)\n{\n    vec4 p = vec4(pos, 1.);\n    vec3 d = vec3(100.);\n    for (int i=0; i<9; ++i)\n    {\n        p = abs(p) / dot(p.xyz,p.xyz);\n        d = min(d, p.xyz/p.w);\n        p.xyz = p.zxy - param;\n    }\n    return d;\n}\n\n// average of all iterations in kali-set\nvec3 kali_set_av(in vec3 p, in vec3 param)\n{\n    vec3 d = vec3(0.);\n    for (int i=0; i<13; ++i)\n    {\n        p = abs(p) / dot(p,p);\n        d += exp(-p*8.);\n        p.xyz = p.zxy - param;\n    }\n    return d / 8.;\n}\n\n// endless texture  \nvec3 kali_tex(in vec3 p, in vec3 par)\n{\n    vec3 k = kali_set_av(sin(p*3.)*.3, par);\n    return 3.*k;\n}\n\n// endless texture normal\nvec3 kali_tex_norm(in vec3 p, in vec3 param, vec3 mask, float eps)\n{\n    vec2 e = vec2(eps, 0.);\n    return normalize(vec3(\n        dot(kali_tex(p+e.xyy, param),mask) - dot(kali_tex(p-e.xyy, param),mask),\n        dot(kali_tex(p+e.yxy, param),mask) - dot(kali_tex(p-e.yxy, param),mask),\n        dot(kali_tex(p+e.yyx, param),mask) - dot(kali_tex(p-e.yyx, param),mask)));\n}\n\n\n\n// camera path\nvec3 path(in float z)\n{\n    float t = z;\n    vec3 p = vec3(sin(t)*.9, \n                  0.2*sin(t*1.16), \n                  z);\n    return p;\n}\n\nfloat lengthN(in vec3 p, float e) { vec3 s = abs(pow(p,vec3(e))); return pow(s.x+s.y+s.z,1./e); }\n\nfloat light_trap;\nfloat DE(in vec3 p, in vec3 param)\n{\n    vec3 pat = path(p.z);\n    p.xy += vec2(.0, .065+.04*sin(pat.z*3.));\n \tp.xy -= pat.xy;\n\n    float d = p.y;\n    // tube around path\n    float r = .13+.1*sin(p.z);\n    //vec3 pp = p - path(p.z); float d = r-max(abs(pp.x), abs(pp.y));\n    \n    vec3 mp = abs(mod(p+.2,.4)-.2);\n    d = min(d, .351 - (mp.x+mp.y+mp.z));\n    \n    // displacement\n    vec3 k = kali_set(sin(p), param);\n    //d += k.x+k.y+k.z;\n    //d += max(k.x,max(k.y,k.z));\n    light_trap = min(k.x,min(k.y,k.z));\n    d += (p.y-0.14)*9.*light_trap;\n    return d;\n}\n\nvec3 DE_norm(in vec3 p, in vec3 param, in float eps)\n{\n    vec2 e = vec2(eps, 0.);\n    return normalize(vec3(\n        DE(p+e.xyy, param) - DE(p-e.xyy, param),\n        DE(p+e.yxy, param) - DE(p-e.yxy, param),\n        DE(p+e.yyx, param) - DE(p-e.yyx, param)));\n}\n\n\nconst float max_t = 1.2;\n\n// common sphere tracing\n// note the check against abs(d) to get closer to surface\n// in case of overstepping\nvec3 light;\nfloat traced_iters; \nfloat trace(in vec3 ro, in vec3 rd, in vec3 param)\n{\n    light = vec3(0.);\n    light_trap = 1.;\n    float t = 0.001, d = max_t;\n    for (int i=0; i<50; ++i)\n    {\n        vec3 p = ro + rd * t;\n        d = DE(p, param);\n        light += smoothstep(0.01, .0, light_trap);\n        traced_iters = float(i) / 50.;\n        if (abs(d) <= 0.00001 || t >= max_t)\n            break;\n        t += d * .5; \n    }\n    light /= 10.;\n    return t;\n}\n\n\n// common ambient occlusion\nfloat traceAO(in vec3 ro, in vec3 rd, in vec3 param)\n{\n    float a = 0., t = 0.01;\n    for (int i=0; i<5; ++i)\n    {\n        float d = DE(ro+t*rd, param);\n       \ta += d / t;\n        t += abs(d)*.6;\n    }\n    return clamp(a / 10., 0., 1.);\n}\n\n// environment map, also drawn from kaliset\nvec3 skyColor(in vec3 rd)\n{\n    //vec3 par = vec3(0.075, 0.565, .03);\n    vec3 par = vec3(.9, .81, .71);\n    \n    vec3 c = kali_set(sin(rd*6.), par);\n    c = pow(min(vec3(1.), c*2.+vec3(1.,.86,.6)), 1.+114.*c);\n    \n    return clamp(c, 0., 1.);\n}\n\n\n// trace and color\nvec3 rayColor(in vec3 ro, in vec3 rd)\n{\n    // magic params for kali-set\n    vec3 par1 = vec3(.9, .6+.5*sin(ro.z/50.), 1.),\t// scene geometry \n         par2 = vec3(.63, .55, .73),\t\t\t\t// normal/bump map\n         par3 = vec3(1.02, 0.82, 0.77); \t\t\t// normal/texture\n    \n#if 1\n    float t = trace(ro, rd, par1);\n#else    \n    float t = trace_enhanced(ro, rd, par1);\n#endif    \n    vec3 p = ro + t * rd;\n    float d = DE(p, par1);\n    \n    vec3 col = vec3(0.);\n\n    // did ray hit?\n    if (d < 0.03) \n    {\n        float trap = smoothstep(0.004, .0, light_trap);\n        float scr_eps = max(0.001, (t-0.1)*0.025);\n        // \"some\" texture values\n        vec3 kt = kali_tex(p, par3);\n        vec3 kt3 = kali_tex(p, par3);\n        // surface normal\n        vec3 n = DE_norm(p, par1, 0.5*scr_eps), nn = n;\n        // normal displacement\n        //n = normalize(n + 0.3*kali_tex_norm(p, par3+0.1*n, vec3(1), scr_eps));\n        n = normalize(n + 0.3*DE_norm(sin(n*3.+kt), par2, 2.*scr_eps)); // micro-bumps\n        n = normalize(n + .5*skyColor(n));\n        // reflected ray\n        vec3 rrd = reflect(rd,n);\n\t\t// normal towards light\n        vec3 ln = normalize(path(p.z+.2)+vec3(0,1,0) - p);\n        // \"enviroment map\"\n        vec3 envi = skyColor(rrd);\n        //n = normalize(n + 0.5*envi);\n\t\t// 1. - occlusion\n        float ao = pow(traceAO(p, n, par1), 1.+3.*t);\n        // surface color\n        vec3 col1 = .45 * (vec3(.7,1.,.4));\n        col1 += smoothstep(0., .2, p.y)*pow(kt3, vec3((1.-envi)*25.));\n        vec3 col2 = vec3(1.,.8,.6) + .3 * vec3(1.,.7,-.6) * kali_tex(p, par3);\n        //vec3 k = 110.*kali_set_av(sin(p*(1.+3.*ao))*.3, par3);\n        vec3 surf = (.1 + .9 * ao) \n            \t\t* mix(col1, col2, min(1., pow(ao*2.2-.8*kt.x,5.)));\n\t\t// desaturate\n        surf += .24 * (dot(surf,vec3(.3,.6,.1)) - surf);\n\n        // -- lighting --\n                \n        float fres = pow(max(0., 1.-dot(rrd, n)), 1.) / (1.+3.*t);\n\n        //surf += trap;\n        \n        // phong\n        surf += .45 * ao * max(0., dot(n, ln));\n        // spec\n        float d = max(0., dot(rrd, ln));\n        surf += 1.9 * pow(ao*1.2,5.) * (.5 * d + .7 * pow(d, 8.));\n\n        // fresnel highlight\n        surf += clamp((t-.09)*9., 0.,2.) * \n            \t(.2+.8*ao) * fres * (vec3(.7,.8,1.)+.5*envi);\n        \n        // environment map\n        surf += trap * (1.-fres) * ao * envi;\n    \t\n        col = surf;\n    }\n    // distance fog\n    float fog = pow(clamp(t / max_t, 0.,1.), 1.-p.y);\n    float fog_h = sin(p.z)*.4;\n    vec3 fog_col = .6*pow(vec3(clamp(p.y*2.+fog_h+.3*traced_iters, 0.,2.)), vec3(1.2,1.,.8));\n    col = mix(col, fog_col, fog);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 suv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y * 2.;\n        \n    float ti = (iTime-14.)/8.;\n    \n    vec3 ro = path(ti);\n    vec3 look = path(ti+.5);\n    look.y+=sin(ro.z*1.618)*.15+.15;\n    float turn = (ro.x-look.x)*1.; \n        \n    // lazily copied from Shane\n    // (except the hacky turn param)\n    float FOV = .7; // FOV - Field of view.\n    vec3 fwd = normalize(look-ro);\n    vec3 rgt = normalize(vec3(fwd.z, turn, -fwd.x));\n    vec3 up = cross(fwd, rgt);\n    \n    vec3 rd = normalize(fwd + FOV*(uv.x*rgt + uv.y*up));\n    \n    \n    vec3 col = rayColor(ro, rd);\n    //col = skyColor(rd);\n    \n    col *= pow(1.-dot(suv-.5,suv-.5)/.5, .6);\n    \n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}