{
    "Shader": {
        "info": {
            "date": "1569842394",
            "description": "Cheap approx of a heterogeneous fog using integrals. You can also rotate the cube with your mouse.",
            "flags": 0,
            "hasliked": 0,
            "id": "XlBSDW",
            "likes": 107,
            "name": "Volume Box",
            "published": 3,
            "tags": [
                "volume",
                "fog",
                "integration",
                "integrals"
            ],
            "usePreview": 0,
            "username": "TDM",
            "viewed": 2236
        },
        "renderpass": [
            {
                "code": "/*\n * \"Volume Box\" by Alexander Alekseev aka TDM - 2019\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n */\n\nconst int SLICES = 4;\nconst float DENSITY = 3.0;\n\nfloat integrationFunc(float x, float a) {\n    return x * 0.5 - cos(x * a) / (2.0 * a);\n}\n\nfloat functionMean(float a, float b, float f) {\n    a = -a * 0.5 + 0.5;\n    b = -b * 0.5 + 0.5;\n    float Fa = integrationFunc(a,f);\n    float Fb = integrationFunc(b,f);\n    return (Fb - Fa) / (b - a);\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;   \n    vec2 mouse = iMouse.xy / iResolution.xy * 4.0 - 2.0;\n        \n    // ray   \n    vec3 ang;\n    if(iMouse.z > 0.0) {\n        ang = vec3(0.0,-mouse.y,mouse.x);\n    } else {\n        ang = vec3(sin(iTime*0.4)*2.0,0.0,cos(iTime*0.35)*3.0);\n    }\n\tmat3 rot = fromEuler(ang);    \n    vec3 ori = vec3(0.0,0.0,4.5) * rot;\n    vec3 dir = normalize(vec3(uv.xy,-3.0)) * rot;      \n             \n    // color\n    vec3 p, rp0, rp1;\n    vec3 rcolor = vec3(0.0);\n    if(intersectionRayBox(ori,dir,vec3(1.0),rp0,rp1)) {       \n        for(int i = 0; i < SLICES; i++) {\n            vec3 r0 = rp0;\n            vec3 r1 = rp1;\n            \n            r0 = mix(r0,r1,float(SLICES-i-1)/float(SLICES));\n            r1 = r0 + (rp1-rp0)/float(SLICES);\n            r0 += 1.7;\n            r1 += 1.7;\n\n            // modulate color\n            float fm = 0.6;\n            vec3 color;\n            color.x = functionMean(r0.x,r1.x,7.0*fm);\n            color.y = functionMean(r0.x,r1.x,11.0*fm);\n            color.z = functionMean(r0.x,r1.x,13.0*fm);\n            color.yz *= functionMean(r0.x,r1.x,27.0*fm);\n            color = 1.0 - color;\n\n            color.z *= functionMean(r0.y,r1.y,11.0*fm);\n            color.y *= functionMean(r0.y,r1.y,13.0*fm);\n            color.x *= functionMean(r0.y,r1.y,17.0*fm);\n            color = 1.0 - color;\n\n            color.z *= functionMean(r0.z,r1.z,5.0*fm);\n            color.y *= functionMean(r0.z,r1.z,7.0*fm);\n            color.x *= functionMean(r0.z,r1.z,11.0*fm);\n            color = 1.0 - color;\n            color = pow(color,vec3(8.0));\n            color += 0.02;\n            color = log(1.0+color*1.5);\n\n            // modulate density\n            float d = length(r1 - r0) * functionMean(r0.z+r0.y,r1.z+r1.y,22.0);            \n            rcolor = mix(rcolor, color, clamp(log(1.0+d*DENSITY),0.0,1.0));\n        }\n        \n        // sRGB\n        rcolor = pow(rcolor, vec3(1.0/2.2));\n        rcolor = saturation(rcolor, 2.0);\n    }\n               \n\tfragColor = vec4(rcolor,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 saturation(vec3 c, float t) {\n    return mix(vec3(dot(c,vec3(0.2126,0.7152,0.0722))),c,t);\n}\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nbool intersectionRayBox(vec3 o, vec3 d, vec3 ext, out vec3 r0, out vec3 r1) {\n    vec3 t0 = (-o - ext) / d; \n    vec3 t1 = (-o + ext) / d;    \n    vec3 n = min(t0,t1); n.x = max(max(n.x,n.y),n.z);\n    vec3 f = max(t0,t1); f.x = min(min(f.x,f.y),f.z);\n    r0 = o + d * n.x;\n    r1 = o + d * f.x;\n    return bool(step(n.x,f.x));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}