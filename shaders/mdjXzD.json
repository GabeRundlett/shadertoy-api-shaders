{
    "Shader": {
        "info": {
            "date": "1670008585",
            "description": "six results from prompts like \"a shadertoy glsl program that uses polar coordinates to render a cardioid heart. please include variable names in the style of john donne.\"",
            "flags": 0,
            "hasliked": 0,
            "id": "mdjXzD",
            "likes": 6,
            "name": "chatGPT: six 'hearts'",
            "published": 3,
            "tags": [
                "chatgpt"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 247
        },
        "renderpass": [
            {
                "code": "// via https://chat.openai.com/chat\n\n// version 2 needed a little human help (defining pi, changing '3' to '3.0'),\n// but all the others are unmodified.\n\n// the first few were simple \"shadertoy to draw a heart\",\n// then I added a request for john donne style (hilarious that version 4 mistook TS Eliot for J. Donne!)\n// and then threw in some hints like \"polar coordinates\" or \"cardioid\".\n\n\n\n\n\n/////////////////////////////////////////////////////////////////////////\n\nvoid mainImage1( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    float r = length(uv);\n    float theta = atan(uv.y, uv.x);\n    float f = abs(sqrt(abs(cos(r * 10.0 - theta * 3.0))) - 0.9);\n    fragColor = vec4(f, f, f, 1.0);\n}\n\n\n/////////////////////////////////////////////////////////////////////////\n\nconst float pi = 3.14159265359;\n\n\nvoid mainImage2( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // create a heart shape using bezier curves\n    float x = pow(sin(uv.x*pi),3.0);\n    float y = (13.0*cos(uv.x*pi) - 5.0*cos(2.0*uv.x*pi) - 2.0*cos(3.0*uv.x*pi) - cos(4.0*uv.x*pi))/16.0;\n\n    // color the heart\n    vec3 col = vec3(1.0, 0.5+0.5*y, 0.5+0.5*x);\n\n    // output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n/////////////////////////////////////////////////////////////////////////\n\n// This is a simple GLSL shader that uses the distance function\n// to create a heart shape.\n\nvoid mainImage3(out vec4 fragColor, in vec2 fragCoord) {\n  // Normalize the fragment coordinates to be in the range [-1, 1].\n  vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n\n  // Calculate the distance from the center of the screen.\n  float d = distance(uv, vec2(0.0));\n\n  // Use the distance to create a heart shape.\n  float heart = smoothstep(0.8, 0.5, d) - smoothstep(0.5, 0.3, d);\n\n  // Set the color based on the distance from the center.\n  fragColor = vec4(heart, 0.0, 0.0, 1.0);\n}\n\n/////////////////////////////////////////////////////////////////////////\n\n// Let us go then, you and I,\n// When the evening is spread out against the sky\n// Like a patient etherized upon a table;\n\nvoid mainImage4(out vec4 fragColor, in vec2 fragCoord) {\n  // Let us go, through certain half-deserted streets,\n  // The muttering retreats\n  // Of restless nights in one-night cheap hotels\n  // And sawdust restaurants with oyster-shells:\n\n  // Normalize the fragment coordinates to be in the range [-1, 1].\n  vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n\n  // Convert the cartesian coordinates to polar coordinates.\n  float r = length(uv);\n  float theta = atan(uv.y, uv.x);\n\n  // Use the polar coordinates to create a heart shape.\n  float heart = smoothstep(0.8, 0.5, r) - smoothstep(0.5, 0.3, r);\n\n  // Set the color based on the distance from the center.\n  fragColor = vec4(heart, 0.0, 0.0, 1.0);\n\n  // Streets that follow like a tedious argument\n  // Of insidious intent\n  // To lead you to an overwhelming question ...\n  // Oh, do not ask, \"What is it?\"\n  // Let us go and make our visit.\n}\n\n/////////////////////////////////////////////////////////////////////////\n\n// Oh heart, so bright and red,\n// Thou dost beat within my chest,\n// And fill my every thought with zest,\n// Oh heart, how bold thou art.\n\nvoid mainImage5(out vec4 fragColor, in vec2 fragCoord) {\n  // Normalize the fragment coordinates to be in the range [-1, 1].\n  vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n\n  // Convert the Cartesian coordinates to polar coordinates.\n  vec2 polar = vec2(length(uv), atan(uv.y, uv.x));\n\n  // Use the polar coordinates to create a heart shape.\n  float heart = smoothstep(0.8, 0.5, polar.x) - smoothstep(0.5, 0.3, polar.x);\n\n  // Set the color based on the distance from the center.\n  fragColor = vec4(heart, 0.0, 0.0, 1.0);\n}\n\n/////////////////////////////////////////////////////////////////////////\n\n// Oh heart, my heart, thy name doth lend\n// A thousand virtues to that simple word,\n// And all thy pulses do but speak and mend\n// The love and admiration that is stirred.\n\nvoid mainImage6(out vec4 fragColor, in vec2 fragCoord) {\n  // Normalize the fragment coordinates to be in the range [-1, 1].\n  vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n\n  // Convert the Cartesian coordinates to polar coordinates.\n  vec2 polar = vec2(length(uv), atan(uv.y, uv.x));\n\n  // Use the polar coordinates to create a cardioid shape.\n  float cardioid = (1.0 + cos(polar.y)) * polar.x;\n\n  // Set the color based on the distance from the center.\n  fragColor = vec4(cardioid, 0.0, 0.0, 1.0);\n}\n\n/////////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    float t = iTime * 0.4 + 0.5;\n\n    uint n = uint(t) % 6u;\n    \n    switch(n + 1u) {\n        case 1u:\n            mainImage1(RGBA, XY);\n            break;\n        case 2u:\n            mainImage2(RGBA, XY);\n            break;\n        case 3u:\n            mainImage3(RGBA, XY);\n            break;\n        case 4u:\n            mainImage4(RGBA, XY);\n            break;\n        case 5u:\n            mainImage5(RGBA, XY);\n            break;\n        case 6u:\n            mainImage6(RGBA, XY);\n            break;\n    }\n    \n    float f = fract(t + 0.5);\n    float m = smoothstep(0.1, 0.0, abs(f - 0.5));\n    RGBA.rgb = mix(RGBA.rgb, vec3(0.8), m);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}