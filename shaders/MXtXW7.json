{
    "Shader": {
        "info": {
            "date": "1719280431",
            "description": "robot playing",
            "flags": 48,
            "hasliked": 0,
            "id": "MXtXW7",
            "likes": 24,
            "name": "TowerOfHanoi",
            "published": 3,
            "tags": [
                "simulation"
            ],
            "usePreview": 0,
            "username": "kosalos",
            "viewed": 259
        },
        "renderpass": [
            {
                "code": "void screen(inout vec2 pt) {  pt *= vec2(iResolution.y); } // stetch uv coords to screen size\nvoid screen(inout float v) {  v *= iResolution.x; }\n\n// ------------------------------------------------------------\n\nfloat ptLineDistance(vec2 pt,vec2 lineP1,vec2 lineP2) {\n    vec2 ab = lineP2-lineP1;\n    vec2 be = pt-lineP2;     \n    if(dot(ab,be) > 0.) return length(be);\n\n    vec2 ae = pt-lineP1;\n    if(dot(ab,ae) < 0.) return length(ae); \n    return abs(ab.x * ae.y - ab.y * ae.x) / length(ab);\n}\n\nvoid drawLine(vec2 p1,vec2 p2, float width, vec3 color,inout vec4 fragColor,vec2 fragCoord) {\n    screen(p1);\n    screen(p2);\n    screen(width);\n        \n    float d = ptLineDistance(fragCoord,p1,p2);\n    \n    if(d < 160.) fragColor.xyz += 1./(d * 0.3); // glow\n\n    if(d < width) {\n        float d2 = ptLineDistance(fragCoord - vec2(-width * 0.5,width * 0.5),p1,p2);\n        fragColor.xyz = color - vec3(d2 / (width * 2.5));\n    }\n    if(abs(d - width)< 1.) fragColor.xyz = vec3(0.);\n}\n\nvoid drawCircle(vec2 pt, float radius, vec3 color,inout vec4 fragColor,vec2 fragCoord) {\n    screen(pt);\n    screen(radius);\n\n    float d = length(fragCoord-pt);\n    \n    if(d < 160.) fragColor.xyz += 1./(d * 0.2); // glow\n    \n    if(d < radius) {\n        float d2 = length(fragCoord - vec2(-radius * 0.3,radius * 0.3) - pt);\n        fragColor.xyz = color - vec3(d2 / (radius * 3.5));\n    }\n    if(abs(d - radius)< 1.) fragColor.xyz = vec3(0.);\n}\n\n// ------------------------------------------------------------\n\nvec3[PDATA_ADDR_COUNT] data;\n\nvoid drawRobot(inout vec4 fragColor,vec2 fragCoord) {\n    // arm \n    vec2 p1 = baseTop;    \n    vec2[4] joint;\n\n    float angle = p1Angle;\n    joint[0] = p1 + vec2(cos(angle),sin(angle))* p1Len;\n    drawLine(p1,joint[0],p1Width,robotColor,fragColor,fragCoord);\n    \n    angle += p2Angle;\n    joint[1] = joint[0] + vec2(cos(angle),sin(angle))* p2Len;\n    drawLine(joint[0],joint[1],p2Width,robotColor,fragColor,fragCoord);\n\n    angle += p3Angle;\n    joint[2] = joint[1] + vec2(cos(angle),sin(angle))* p3Len;\n    drawLine(joint[1],joint[2],p3Width,robotColor,fragColor,fragCoord);\n\n    angle += p4Angle;\n    joint[3] = joint[2] + vec2(cos(angle),sin(angle))* p4Len;\n    drawLine(joint[2],joint[3],p4Width,robotColor,fragColor,fragCoord);\n    \n    // gripper\n    vec2[8] grip;\n    grip[0] = joint[3];\n    grip[1] = grip[0]; grip[1].y -= 0.1;\n    grip[2] = grip[1]; grip[2].x -= gripDefault + 0.01;\n    grip[3] = grip[1]; grip[3].x += gripDefault + 0.01;\n    \n    grip[4] = grip[1]; grip[4].x -= gripWidth;\n    grip[5] = grip[4]; grip[5].y -= 0.1;\n    \n    grip[6] = grip[1]; grip[6].x += gripWidth;\n    grip[7] = grip[6]; grip[6].y -= 0.1;\n    \n    drawLine(grip[0],grip[1],gripThick,robotColor,fragColor,fragCoord);\n    drawLine(grip[4],grip[5],gripThick,robotColor,fragColor,fragCoord);\n    drawLine(grip[6],grip[7],gripThick,robotColor,fragColor,fragCoord);\n    drawLine(grip[2],grip[3],gripThick,robotColor,fragColor,fragCoord);   \n\n    drawCircle(joint[0],p1Width*1.3,robotColor,fragColor,fragCoord);\n    drawCircle(joint[1],p2Width*1.3,robotColor,fragColor,fragCoord);\n    drawCircle(joint[2],p3Width*1.3,robotColor,fragColor,fragCoord);\n    drawCircle(joint[3],p4Width*1.3,robotColor,fragColor,fragCoord);\n\n    // base\n    drawCircle(baseTop,0.025,robotColor,fragColor,fragCoord);\n    drawLine(b3,b4,0.05,robotColor,fragColor,fragCoord);\n    drawLine(b1,b2,0.01,robotColor,fragColor,fragCoord);\n    drawLine(b5,b6,0.01,robotColor,fragColor,fragCoord);\n}\n\n// ------------------------------------------------------------\n\nvoid drawPeg(int index,inout vec4 fragColor,vec2 fragCoord) {\n    vec2 base = pegPositions[index];\n    vec2 b3 = base + vec2(0.,0.22);\n    drawLine(base,b3,0.005,robotColor,fragColor,fragCoord);\n    vec2 b1 = base + vec2(-0.15,0.);\n    vec2 b2 = base + vec2(+0.15,0.);\n    drawLine(b1,b2,0.008,robotColor,fragColor,fragCoord);    \n}\n\n// ------------------------------------------------------------\n\nvoid drawDisc(int discIndex, vec3 dat,inout vec4 fragColor,vec2 fragCoord) {\n    vec3 color = discColors[discIndex];\n    float width = discWidth[discIndex];    \n    int pegIndex = int(dat.x);  // 0..2, or -1 == grabbed\n    int height = int(dat.y);\n    \n    vec2 p = pegPositions[pegIndex] - vec2(0., -float(height+1) * discThick * 4.); \n    \n    if(discIndex == int(gripIndex)) p = tipPos;\n    \n    drawLine(vec2(p.x-width,p.y),vec2(p.x+width,p.y),discThick,color,fragColor,fragCoord);\n}\n\n// ------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(iTime * 0.3 + uv.xyx + vec3(0,2,4));\n    fragColor = vec4(col,1.0);\n    \n    for(int i=0;i<PDATA_ADDR_COUNT;++i)  // copy of storage data\n        data[i] = fetchData(iChannel0, storeAddr[i]).xyz;\n\n    drawRobot(fragColor,fragCoord);\n    for(int i=0;i<3;++i)\n        drawPeg(i,fragColor,fragCoord);\n        \n    for(int i=0;i<NUMDISC;++i)\n        drawDisc(i, data[DISC_INDEX+i],fragColor,fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3[PDATA_ADDR_COUNT] data;\n\nbool keyClick(int ascii) {\n\treturn (texture(iChannel1,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\n// ---------------------------------------------------------\n\nvoid initializeStorage(inout vec4 fragColor,vec2 fragCoord) {\n    p1Angle = p1DefaultAngle;\n    p2Angle = p2DefaultAngle;\n    p3Angle = p3DefaultAngle;\n    p4Angle = p4DefaultAngle;\n    gripIndex = FNONE;\n    gripWidth = gripDefault;\n    gripTarget = gripDefault;\n    previousPeg = FNONE;\n    state = FNONE; // so state#1 is executed\n    target = vec2(-1.);\n    \n    disc0.x = 0.; // peg# 0..2 \n    disc0.y = 0.; // height 0..\n    disc1.x = 0.; \n    disc1.y = 1.;\n    disc2.x = 0.; \n    disc2.y = 2.;\n    disc3.x = 0.; \n    disc3.y = 3.;\n    disc4.x = 0.; \n    disc4.y = 4.;\n    disc5.x = 0.; \n    disc5.y = 5.;\n    \n    for(int i=0;i<PDATA_ADDR_COUNT;++i) {\n        if(storeDataAddr(fragCoord, storeAddr[i])) \n            fragColor.xyz = data[i];\n    }\n}\n\n// ---------------------------------------------------------\n\nvec2 calcTipPosition() {\n    float angle = p1Angle;\n    vec2 joint = baseTop + vec2(cos(angle),sin(angle)) * p1Len;\n    angle += p2Angle;\n    joint += vec2(cos(angle),sin(angle)) * p2Len;\n    angle += p3Angle;\n    joint += vec2(cos(angle),sin(angle)) * p3Len;\n    angle += p4Angle;\n    joint += vec2(cos(angle),sin(angle)) * p4Len;\n    return joint + vec2(0.,-0.18);\n}\n\n// ---------------------------------------------------------\n// update specified angle to shorten distance of tip to target\n\nvoid changeAngle(int index,int field,float vmin,float vmax) {\n    const float deflect = 0.031;\n    float old = data[index][field];\n    float oldD = length(target - calcTipPosition());\n    \n    data[index][field] -= deflect;\n    float newD1 = length(target - calcTipPosition());\n    \n    data[index][field] += deflect * 2.;\n    float newD2 = length(target - calcTipPosition());\n    \n    data[index][field] = old;\n    if(newD1 < oldD && newD1 < newD2) data[index][field] -= deflect;\n    if(newD2 < oldD && newD2 < newD1) data[index][field] += deflect;\n  \n   // if(index == 0) // causing movment freeze. need to rethink this part\n     //   data[index][field] = clamp(data[index][field],vmin,vmax);\n}\n\n// ---------------------------------------------------------\n// adjust all joint angles to shorten distance to target \n\nbool movedToTarget() {\n    changeAngle(0,0,p1MinAngle,p1MaxAngle);  // storage addresses of joint angles\n    changeAngle(0,1,p2MinAngle,p2MaxAngle);\n    changeAngle(0,2,p3MinAngle,p3MaxAngle);\n    changeAngle(1,0,p4MinAngle,p4MaxAngle);\n\n    return length(target - calcTipPosition()) < 0.05;\n}\n\n// ------------------------------------------------------------\n\nvoid setTargetAbovePeg(int pegIndex) {\n   target = pegPositions[pegIndex];\n   target.y += 0.4;\n}\n\n// ------------------------------------------------------------\n// index of topmost disk in column, or NONE\n\nint topDiscInColumn(int column) {\n    int height = -1;\n    int dIndex = INONE;\n\n    for (int i = 0; i < NUMDISC; ++i) {\n        int dcolumn = int(data[DISC_INDEX+i].x);\n        if(dcolumn != column) continue;\n        \n        int dheight = int(data[DISC_INDEX+i].y);\n        if(dheight > height) {\n            height = dheight;\n            dIndex = i;\n        }\n    }\n    \n    return dIndex;\n}\n\n// ------------------------------------------------------------\n// find smallest disk to move (not the just moved piece)\n\nint nextColumnInCircle(int currentColumn) {\n    return (currentColumn + 1) % NUMPEGS;\n}\n\n// smallest disc in each column (unless it was the previous destination column) \nint smallestDiscColumn() {\n    int[NUMPEGS] top = int[](INONE,INONE,INONE);\n    \n    for (int i = 0; i < NUMPEGS; ++i) \n        if (i != int(previousPeg))\n            top[i] = topDiscInColumn(i);\n                \n    // larger# -> smaller disc\n    int column = 0;\n    if (top[1] > top[0] && top[1] > top[2]) column = 1;\n    if (top[2] > top[0] && top[2] > top[1]) column = 2;\n    return column;\n}\n\n// ------------------------------------------------------------\n// move the smallest disc around the circle of pegs, unless it was the last move made\n\nvoid determineNextMove() {\n    gripIndex = FNONE;\n\n    // find the smallest legal to move disc -------------------------\n    int srcColumn = smallestDiscColumn();\n    movingDiscIndex = float(topDiscInColumn(srcColumn));\n\n    // note: movingDiskIndex == NONE when just completed a full cycle, and all discs are on the 'previous' column\n    // need to allow picking that column to start a new cycle\n    if (movingDiscIndex == FNONE) {\n        previousPeg = FNONE;\n        srcColumn = smallestDiscColumn();\n        movingDiscIndex = float(topDiscInColumn(srcColumn));\n    }\n\n    sourcePeg = float(srcColumn);\n    \n    // find destination column ------------------------\n    int destColumn = nextColumnInCircle(srcColumn); // assume next column is okay\n    int discAtTopOfColumn = topDiscInColumn(destColumn);\n\n    // illegal destination (disc is larger than top one in column). Next column must be okay\n    if (discAtTopOfColumn != INONE && discAtTopOfColumn > int(movingDiscIndex)) {\n        destColumn = nextColumnInCircle(destColumn);\n        discAtTopOfColumn = topDiscInColumn(destColumn);\n    }\n\n    destinationPeg = float(destColumn);\n    destinationHt = 0.;\n    if(discAtTopOfColumn != INONE) // place on top of topmost disc already there\n       destinationHt = data[DISC_INDEX+discAtTopOfColumn].y + 1.; \n}\n\n// ---------------------------------------------------------\n\nbool gripperAtTarget() {\n  const float gripHop = 0.005;\n  if(gripWidth > gripTarget) gripWidth -= gripHop;\n  if(gripWidth < gripTarget) gripWidth += gripHop;\n\n  if(abs(gripTarget - gripWidth) <= gripHop) {\n      gripWidth = gripTarget;\n      return true;\n  }\n  \n  return false;\n}\n\n// ---------------------------------------------------------\n\nvoid update() {\n    if ((state == FNONE) || (movedToTarget() && gripperAtTarget())) {\n        if(state == FNONE) state = 1.0; // coming out of reset\n        int iState = int(state);\n        \n        if(iState == 1) {\n            determineNextMove();\n            setTargetAbovePeg(int(sourcePeg));\n        }\n        \n        if(iState == 2) { // move down to disc \n            vec3 disc = data[DISC_INDEX + int(movingDiscIndex)];\n            target = pegPositions[int(disc.x)];\n            target.y += (disc.y+1.) * discThick * 4.;\n        }\n        \n        if(iState == 3) { // grab disc \n            gripTarget = discWidth[int(movingDiscIndex)] + 0.01;\n        }\n        \n        if(iState == 4) { // move disc above peg\n            data[DISC_INDEX + int(movingDiscIndex)].x = destinationPeg;\n            data[DISC_INDEX + int(movingDiscIndex)].y = destinationHt;\n            gripIndex = movingDiscIndex;\n            setTargetAbovePeg(int(sourcePeg)); \n        }\n        \n        if(iState == 5) { // move above destination peg\n            setTargetAbovePeg(int(destinationPeg));\n        }\n        \n        if(iState == 6) { // move down to disc\n            target = pegPositions[int(destinationPeg)];\n            target.y += (destinationHt+1.) * discThick * 4.;\n        }\n        \n        if(iState == 7) { // release disc, move above peg,  start over\n            gripIndex = FNONE;\n            gripTarget = gripDefault;\n        }\n        \n        if(iState == 8) {\n            previousPeg = destinationPeg;\n            setTargetAbovePeg(int(destinationPeg));\n            state = 1.0;\n            return;\n        }\n\n        state += 1.0;\n    }\n}\n\n// ---------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.x > float(PDATA_ADDR_COUNT) || fragCoord.y > 1.0) return; // skip unused storage locations\n    \n    if(iFrame < 2 || keyClick(32)) {  // reset settings on coldstart or <Spc> keypress\n        initializeStorage(fragColor, fragCoord);\n        return; \n    }\n            \n    // get all values -----------\n    for(int i=0;i<PDATA_ADDR_COUNT;++i)\n        data[i] = fetchData(iChannel0, storeAddr[i]).xyz;\n            \n    update();\n    tipPos = calcTipPosition();\n    \n    // save all values -----------\n    for(int i=0;i<PDATA_ADDR_COUNT;++i)\n        if (storeDataAddr(fragCoord, storeAddr[i])) \n            fragColor.xyz = data[i];\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const ivec2 P0_ADDR =  ivec2( 0, 0);\nconst ivec2 P1_ADDR =  ivec2( 1, 0);\nconst ivec2 P2_ADDR =  ivec2( 2, 0);\nconst ivec2 P3_ADDR =  ivec2( 3, 0);\nconst ivec2 P4_ADDR =  ivec2( 4, 0);\nconst ivec2 P5_ADDR =  ivec2( 5, 0); \nconst ivec2 P6_ADDR =  ivec2( 6, 0); \nconst ivec2 P7_ADDR =  ivec2( 7, 0); \nconst ivec2 P8_ADDR =  ivec2( 8, 0); \nconst ivec2 P9_ADDR =  ivec2( 9, 0); \nconst ivec2 P10_ADDR = ivec2(10, 0); \nconst ivec2 P11_ADDR = ivec2(11, 0); \nconst int PDATA_ADDR_COUNT = 12;\n\nconst ivec2[] storeAddr = ivec2[](\n    P0_ADDR,P1_ADDR,P2_ADDR,P3_ADDR,P4_ADDR,P5_ADDR,P6_ADDR,P7_ADDR,P8_ADDR,P9_ADDR,\n    P10_ADDR,P11_ADDR );\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeDataAddr(buf_pos, addr) ivec2(buf_pos) == addr\n\n#define p1Angle  data[0].x\n#define p2Angle  data[0].y\n#define p3Angle  data[0].z\n// -----\n#define p4Angle  data[1].x\n#define tipPos   data[1].yz\n// -----\n#define state    data[2].x\n#define target   data[2].yz\n// -----\n#define gripIndex   data[3].x    \n#define gripWidth   data[3].y\n#define gripTarget  data[3].z\n// -----\n#define previousPeg     data[4].x\n#define movingDiscIndex data[4].y\n#define destinationPeg  data[4].z\n// -----\n#define destinationHt   data[5].x\n#define sourcePeg       data[5].y\n// -----\n#define DISC_INDEX 6     // base storage index\n#define disc0    data[6] // x: peg 0...2, or -1 = grabbed; y: height 0...5\n#define disc1    data[7]\n#define disc2    data[8]\n#define disc3    data[9]\n#define disc4    data[10]\n#define disc5    data[11]\n\n// ---------------------------------------------------------\n\n#define PI 3.141592654\n#define INONE -1\n#define FNONE -1.\n\nconst int NUMPEGS = 3;\nconst int NUMDISC = 6;\n\nconst vec3 robotColor = vec3(0.98,0.9,0.85);\nconst vec2 robotPosition = vec2(0.25,0.1);\nconst vec2[] pegPositions = vec2[]( vec2(0.7,0.1),vec2(1.1,0.1), vec2(1.5,0.1));\n\n// discs\nconst float dw = 0.13;\nconst float dwh = 0.0175;\nconst float discThick = 0.008;\nconst float[] discWidth = float[]( dw,dw-dwh*1.,dw-dwh*2.,dw-dwh*3.,dw-dwh*4.,dw-dwh*5.);\nconst vec3[] discColors = vec3[]( vec3(0.,0.,01),vec3(0.,1.,0.), vec3(0.,1.,1.),vec3(1.,0.,0.),vec3(1.,0.,1.),vec3(1.,1.,0.));\n\n// base\nconst vec2 b1 = robotPosition + vec2(-0.125,0.);\nconst vec2 b2 = robotPosition + vec2(+0.125,0.);\nconst vec2 b3 = b1 + vec2(+0.08,0.08);\nconst vec2 b4 = b2 + vec2(-0.08,0.08);\nconst vec2 b5 = b3 + vec2(+0.14,0.09);\nconst vec2 b6 = b4 + vec2(-0.14,0.09);\nconst vec2 baseTop = vec2(robotPosition.x,b5.y + .015);\n\n// arm\nconst vec2 armBase = baseTop;\nconst float p1Len = 0.5;\nconst float p2Len = 0.4;\nconst float p3Len = 0.4;\nconst float p4Len = 0.3;\nconst float p1Width = 0.010;\nconst float p2Width = 0.008;\nconst float p3Width = 0.006;\nconst float p4Width = 0.004;\nconst float gripThick = 0.002;\n\nconst float p1DefaultAngle = PI * 0.5;\nconst float p1MinAngle = PI * 0.2;\nconst float p1MaxAngle = PI * 0.6;\nconst float p2DefaultAngle = -PI * 0.35;\nconst float p2MinAngle = -PI * 0.15;\nconst float p2MaxAngle = -PI * 0.55;\nconst float p3DefaultAngle = -PI * 0.2;\nconst float p3MinAngle = -PI * 0.1;\nconst float p3MaxAngle = -PI * 0.3;\nconst float p4DefaultAngle = -PI * 0.35;\nconst float p4MinAngle = -PI * 0.15;\nconst float p4MaxAngle = -PI * 0.55;\nconst float gripDefault = 0.15;\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}