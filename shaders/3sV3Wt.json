{
    "Shader": {
        "info": {
            "date": "1571763923",
            "description": "DONE: diffuse, reflection, refraction, fresnel\nTODO: internal reflection, beers law",
            "flags": 0,
            "hasliked": 0,
            "id": "3sV3Wt",
            "likes": 1,
            "name": "lighting study",
            "published": 3,
            "tags": [
                "lightingstudy"
            ],
            "usePreview": 0,
            "username": "ich",
            "viewed": 271
        },
        "renderpass": [
            {
                "code": "#define max_marches 100\n#define max_distance 100.\n#define surface_distance .001\n#define max_recursions 3\n#define light_pos vec3(cos(iTime * .125) * 3., 5, sin(iTime * -.241) * 2. - 1.)\n\nfloat sdf_sphere(vec3 p) {\n\treturn length(p);\n}\n\nfloat sdf_cube(vec3 p) {\n\tp = abs(p);\n    return max(p.x, max(p.y, p.z));\n}\n\nfloat sdf_plane(vec3 p) {\n\treturn p.y;\n}\n\nfloat sdf_scene(vec3 p) {\n    float plane0 = sdf_plane(p - vec3(0, -.5, 0));\n\tfloat sphere0 = sdf_sphere(p - vec3(-1.5, .5, 0)) - 1.;\n    float sphere1 = sdf_sphere(p - vec3(-3.2, 2, -1)) - .5;\n    float cube0 = sdf_cube(p - vec3(1., 0, 0)) - .5;\n    float cube1 = sdf_cube(p - vec3(.8, 1, .3)) - .5;\n    float cube2 = sdf_cube(p - vec3(-1, .1, 3.)) - .6;\n    float cube3 = sdf_cube(p - vec3(-1, -.3, -2.)) - .2;\n    float cube4 = sdf_cube(p - vec3(-4, .5, -1)) - 1.;\n    float cube5 = sdf_cube(p - vec3(-3.5, -.3, -2.5)) - .2;\n    \n    return min(min(min(plane0, sphere0), sphere1), min(min(min(cube0, cube1), min(cube2, cube3)), min(cube4, cube5)));\n}\n\nstruct material_t {\n    vec3 diffuse;\n    float fresnelity;\n    float reflectivity;\n    float refractivity;\n    float refract_eta;\n    float density;\n};\n\nmaterial_t material(vec3 p) {\n    float plane0 = sdf_plane(p - vec3(0, -.5, 0));\n\tfloat sphere0 = sdf_sphere(p - vec3(-1.5, .5, 0)) - 1.;\n    float sphere1 = sdf_sphere(p - vec3(-3.2, 2, -1)) - .5;\n    float cube0 = sdf_cube(p - vec3(1., 0, 0)) - .5;\n    float cube1 = sdf_cube(p - vec3(.8, 1, .3)) - .5;\n    float cube2 = sdf_cube(p - vec3(-1, .1, 3.)) - .6;\n    float cube3 = sdf_cube(p - vec3(-1, -.3, -2.)) - .2;\n    float cube4 = sdf_cube(p - vec3(-4, .5, -1.)) - 1.;\n    float cube5 = sdf_cube(p - vec3(-3.5, -.3, -2.5)) - .2;\n    float d = min(min(min(plane0, sphere0), sphere1), min(min(min(cube0, cube1), min(cube2, cube3)), min(cube4, cube5)));\n   \tmaterial_t m;\n    \n    m.diffuse = vec3(1, 1, 1);\n    m.fresnelity = .2;\n    m.reflectivity = .3;\n    m.refractivity = .0;\n    m.refract_eta = .95;\n    m.density = 0.;\n    \n   \tif (sphere0 == d || cube3 == d || cube5 == d) {\n        m.diffuse = vec3(1, 1, 1);\n        m.fresnelity = .6;\n        m.reflectivity = .1;\n        m.refractivity = .8;\n    } else if (cube0 == d || cube1 == d || cube2 == d) {\n    \tm.diffuse = vec3(1, 0, 0);\n        m.fresnelity = .4;\n        m.reflectivity = .1;\n    } else if (cube4 == d || sphere1 == d) {\n    \tm.diffuse = vec3(1, 1, 1);\n        m.reflectivity = .8;\n        //m.refractivity = ;\n    }\n    \n    return m;\n}\n\nbool march(in vec3 ro, in vec3 rd, out vec3 p) {\n    p = ro;\n    float lO = 0.f;\n\n    for (int i = 0; i < max_marches; i++) {\n    \tfloat l = sdf_scene(p);\n        lO += l;\n        p += l * rd;\n        \n        if (l < surface_distance)\n            return true;\n        if (lO > max_distance)\n            return false;\n    }\n    \n\treturn false;\n}\n\nbool inner_march(in vec3 ro, in vec3 rd, out vec3 p) {\n    p = ro;\n    float lO = 0.f;\n\n    for (int i = 0; i < max_marches; i++) {\n    \tfloat l = -sdf_scene(p);\n        lO += l;\n        p += l * rd;\n        \n        if (l < surface_distance)\n            return true;\n        if (lO > max_distance)\n            return false;\n    }\n    \n\treturn false;\n}\n\n// internal_reflection with thickness\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(0, .001);\n    float l = sdf_scene(p);\n    \n    vec3 n = l - vec3(\n    \tsdf_scene(p - e.yxx),\n        sdf_scene(p - e.xyx),\n        sdf_scene(p - e.xxy)\n    );\n    \n    return normalize(n);\n}\n\nvec3 inner_normal(vec3 p) {\n\tvec2 e = vec2(0, .001);\n    float l = sdf_scene(p);\n    \n    vec3 n = l - vec3(\n    \tsdf_scene(p - e.yxx),\n        sdf_scene(p - e.xyx),\n        sdf_scene(p - e.xxy)\n    );\n    \n    return normalize(n);\n}\n\n    \nstruct ray_t {\n    vec3 ro;\n    vec3 rd;\n    float dist;\n    float lum;\n    int depth;\n};\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord)\n{\n    vec2 uv = (frag_coord - iResolution.xy * .5) / iResolution.y;\n    vec2 m = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n    m *= 0.5;\n    vec3 c = vec3(0.);\n    \n    vec3 ro = vec3(vec2(-1, 2) + m * 5., -5);\n    vec3 rd = normalize(vec3(uv - vec2(0, .2), 1));\n    \n    vec3 diff_r = .8 * vec3(1, 0, 0);\n    vec3 spec_r = .2 * vec3(0, 1, 0);\n\n    ray_t rays[int(pow(2., float(max_recursions)))]; // TOOD validate size\n    int rays_size = 0;\n    rays[0].ro = ro;\n    rays[0].rd = rd;\n    rays[0].dist = 1.;\n    rays[0].lum = 1.;\n    rays[0].depth = 0;\n    \n    while (rays_size > -1) {\n        vec3 ro = rays[rays_size].ro;\n        vec3 rd = rays[rays_size].rd;\n        float dist = rays[rays_size].dist;\n        float lum = rays[rays_size].lum;\n        int depth = rays[rays_size].depth;\n        --rays_size;\n        \n        vec3 p0;\n        if (march(ro, rd, p0)) {\n            material_t m0 = material(p0);\n        \tvec3 n0 = normal(p0);\n            \n            vec3 surface = n0 * surface_distance * 2.;\n            vec3 ro_outside = p0 + surface;\n            vec3 rd_light = normalize(light_pos - ro_outside);\n            float d0 = length(ro_outside - ro);\n            float dl = length(light_pos - ro_outside);\n            float da = dist + d0 + dl;\n            float attenuation = da * da * .001 + 1.;\n            float reflectivity = 1. - max(0., dot(rd, -n0)); // fresnel\n            reflectivity = min(1., min(1., pow(reflectivity, 8. - m0.fresnelity * 6.)) * m0.fresnelity + m0.reflectivity);\n            float refractivity = (1. - reflectivity) * m0.refractivity;\n            float diffusity = 1. - reflectivity - refractivity;\n            \n            vec3 p_light;\n            if (!march(ro_outside, rd_light, p_light) || dl < length(p_light - ro_outside) + .01) {\n            \tc += lum * diffusity * m0.diffuse * max(0., dot(n0, rd_light)) / attenuation;\n            }\n            \n            if (depth < max_recursions) {\n            \t++rays_size;\n                rays[rays_size].ro = ro_outside;\n                rays[rays_size].rd = reflect(rd, n0);\n                rays[rays_size].dist = dist + d0;\n                rays[rays_size].lum = lum * reflectivity;\n                rays[rays_size].depth = depth + 1;\n                \n                vec3 rd_refract = refract(rd, n0, m0.refract_eta);\n                vec3 ro_inside = p0 - surface;\n                \n                vec3 p_inside;\n                if (inner_march(ro_inside, rd_refract, p_inside)) {\n                    vec3 n_inside = normal(p_inside);\n                    vec3 surface_inside = n_inside * surface_distance * 2.;\n                    vec3 ro_refract_outside = p_inside + surface_inside;\n                    float di = length(p_inside - ro_inside);\n\n                    ++rays_size;\n                    rays[rays_size].ro = ro_refract_outside;\n                    rays[rays_size].rd = refract(rd_refract, -n_inside, 1. / m0.refract_eta);\n                    rays[rays_size].dist = dist + d0 + di;\n                    rays[rays_size].lum = lum * refractivity;\n                    rays[rays_size].depth = depth + 1;\n                }\n            }\n        }\n        \n        // follor ray -> color\n        // extra rays\n        // light, bears law, reflection, refraction, inner reflection\n    }\n    \n\n    frag_color = vec4(c, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}