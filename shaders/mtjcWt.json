{
    "Shader": {
        "info": {
            "date": "1692460037",
            "description": "My small tribute to Crysis from Crytek.\n(Apologies - This might be a bit GPU-heavy...?)",
            "flags": 96,
            "hasliked": 0,
            "id": "mtjcWt",
            "likes": 54,
            "name": "But Can It Run Crysis?",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "reflections"
            ],
            "usePreview": 1,
            "username": "dean_the_coder",
            "viewed": 1371
        },
        "renderpass": [
            {
                "code": "// 'But Can It Run Crysis?' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/mtjcWt (YouTube: https://youtu.be/rsIRB3Gxtwc)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// My small tribute to Crysis from Crytek.\n//\n// Buffer A - All the Good Stuff.\n//   Check out usages of 'g' (line 30) to see how the glow effect was added.\n//   The sdf() function is where most of the modelling is done. (Lots of domain mirroring/etc)\n//   I use a float for each material ID, where the floating point component\n//   represents how reflective the material is - Very handy for tweaking the\n//   material properties.\n// Buffer B - Small amount of fish eye lens distortion.\n// This buffer - Film grain and lens dust.\n//\n// Tricks to aid performance:\n//   - Precalculate function results and simplify calculations\n//     when possible (see GLSL Shader Shrinker).\n//   - SDF fine details only modelled when ray is near a surface.\n//   - Using bump maps over SDF displacement where possible.\n//     (Displacing an SDF is much more expensive at the code is\n//     ever time the ray moves, whereas a bump is only applied once\n//     when the ray has hit a surface.)\n//   - Lots of domain repetition (missiles, the '80' segments, etc)\n//   - Shadows don't appear much in this scene (it's mostly ambient occlusion)\n//     so the shadow marching code returns early for large areas of the scene.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define CHROMATIC 0.003\n\n// Thnx Dave_Hoskins\nvec2 h22(vec2 p)\n{\n\tvec3 v = fract(p.xyx * vec3(.1031, .1030, .0973));\n    v += dot(v, v.yzx + 333.33);\n    return fract((v.xx + v.yz) * v.zy);\n}\n\nfloat h21(vec2 p) {\n    p += 353.627;\n    vec3 p3  = fract(p.xyx * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat film(vec2 uv) {\n    // Film grain.\n    float c = (h21(uv * iResolution.xy) - 0.5) / 128.;\n\n    // Lens dust.\n    uv *= 4.;\n    float sm = 0.1;\n    for (int i = 0; i < 3; i++, uv++) {\n        vec2 p = fract(uv) - 0.5, id = floor(uv);\n        float s = h21(id) * sm;\n        p += h22(id) * (1.0 - sm) * 0.5;\n        float f = smoothstep(s, s * 0.5, length(p)) * 0.025;\n        f = max(0.0, f - smoothstep(s, s * 0.5, length(p - vec2(-0.01, 0.02))) * 0.015);\n        c = max(c, f * clamp(iTime, 0., 1.));\n        sm *= 0.5;\n        uv *= 2.282;\n    }\n\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Chromatic aberration.\n    vec2 ca = (uv - 0.5) * CHROMATIC;\n\n    fragColor = vec4(\n                    texture(iChannel0, uv + ca).r,\n                    texture(iChannel0, uv).g,\n                    texture(iChannel0, uv - ca).ba);\n                    \n    fragColor += film(uv * vec2(1, iResolution.y / iResolution.x));\n        \n    // Color correction.\n    fragColor = pow(fragColor, vec4(0.4545));\n        \n    // Vignette.\n    uv -= 0.5;\n    fragColor *= 1.0 - 0.4 * dot(uv, uv);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 34514,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/giammarco-simonelli/crysis-2-epilogue-main-theme?si=4f570f1d38a64e14bd0988020691545a&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// 'But Can It Run Crysis?' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/mtjcWt (YouTube: https://youtu.be/rsIRB3Gxtwc)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// My small tribute to Crysis from Crytek.\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST\t2e-4\n#define START_DIST\t1.\n#define MAX_DIST\t140.\n#define MAX_STEPS\t120.\n#define MAX_RDIST\t80.\n#define MAX_RSTEPS\t52.\n#define SHADOW_STEPS\t25.\n#define AO_STRENGTH\t.5\n#define LIGHT_RGB\tvec3(2, 1.6, 1.4)\n#define YELLOW_LIGHT_RGB\tvec3(10, 5, 2)\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define I0\tmin(int(iTime), 0)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S\tsmoothstep\n#define S01(a)\tS(0., 1., a)\n\nfloat t,\n      fade = 1.;\nvec2 g;\nvec3 lp;\nstruct Hit {\n\tfloat d, id;\n\tvec3 p;\n};\n\nvoid U(inout Hit h, float d, float id, vec3 p) { if (d < h.d) h = Hit(d, id, p); }\n\nvoid Uh(inout Hit h, Hit h2) { U(h, h2.d, h2.id, h2.p); }\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat sum2(vec2 v) { return dot(v, vec2(1)); }\n\nfloat sum3(vec3 v) { return dot(v, vec3(1)); }\n\nfloat mul3(vec3 v) { return v.x * v.y * v.z; }\n\n///////////////////////////////////////////////////////////////////////////////\n// Hash/noise functions (Thnx Dave_Hoskins, Shane, iq)\nfloat h11(float p) {\n\tp = fract(p * .1031);\n\tp *= p + 3.3456;\n\treturn fract(p * (p + p));\n}\n\nfloat h31(vec3 p) {\n\tp = fract(p * .3183099 + .1);\n\tp *= 17.;\n\treturn fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat h21(vec2 p) {\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .11369, .13787));\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat n21(vec2 p) {\n\tvec2 i = floor(p),\n\t     f = fract(p);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(mix(h21(i), h21(i + vec2(1, 0)), f.x), mix(h21(i + vec2(0, 1)), h21(i + 1.), f.x), f.y);\n}\n\nfloat n31(vec3 p) {\n\tvec3 i = floor(p),\n\t     f = fract(p);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(mix(mix(h31(i), h31(i + vec3(1, 0, 0)), f.x), mix(h31(i + vec3(0, 1, 0)), h31(i + vec3(1, 1, 0)), f.x), f.y), mix(mix(h31(i + vec3(0, 0, 1)), h31(i + vec3(1, 0, 1)), f.x), mix(h31(i + vec3(0, 1, 1)), h31(i + 1.), f.x), f.y), f.z);\n}\n\nfloat fbm2(vec2 p) {\n\tint octaves = 4;\n\tfloat roughness = .5,\n\t      sum = 0.,\n\t      amp = 1.,\n\t      tot = 0.;\n\troughness = sat(roughness);\n\twhile (octaves-- > 0) {\n\t\tsum += amp * n21(p);\n\t\ttot += amp;\n\t\tamp *= roughness;\n\t\tp *= 2.;\n\t}\n\treturn sum / tot;\n}\n\nfloat fbm(vec3 p) {\n\tint octaves = 4;\n\tfloat roughness = .5,\n\t      sum = 0.,\n\t      amp = 1.,\n\t      tot = 0.;\n\troughness = sat(roughness);\n\twhile (octaves-- > 0) {\n\t\tsum += amp * n31(p);\n\t\ttot += amp;\n\t\tamp *= roughness;\n\t\tp *= 2.;\n\t}\n\treturn sum / tot;\n}\n\nfloat musgraveFbm(vec3 p) {\n\tfloat octaves = 5.,\n\t      sum = 0.,\n\t      amp = 1.,\n\t      pwMul = pow(3., 0.);\n\twhile (octaves-- > 0.) {\n\t\tfloat n = n31(p) * 2. - 1.;\n\t\tsum += n * amp;\n\t\tamp *= pwMul;\n\t\tp *= 3.;\n\t}\n\treturn sum;\n}\n\nvec3 rxz(vec3 p) {\n\tp.xz *= mat2(8e-4, 1, -1, 8e-4);\n\treturn p;\n}\n\nvec3 dx(vec3 p) {\n\tp.x += -5.;\n\treturn p;\n}\n\nvec3 dy(vec3 p, float e) {\n\tp.y += e;\n\treturn p;\n}\n\nvec3 dz(vec3 p, float e) {\n\tp.z += e;\n\treturn p;\n}\n\nvec3 ax(vec3 p, float d) { return vec3(abs(p.x) - d, p.yz); }\n\nvec3 ay(vec3 p) { return vec3(p.x, abs(p.y) - 5.3, p.z); }\n\nvec3 az(vec3 p, float d) { return vec3(p.xy, abs(p.z) - d); }\n\nfloat rep(float p) { return p - 4. * floor(p / 4. + .5); }\n\nvec2 opModPolar(vec2 p, float n) {\n\tfloat angle = 3.141 / n,\n\t      a = mod(atan(p.x, p.y) + angle, 2. * angle) - angle;\n\treturn length(p) * vec2(cos(a), sin(a));\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat box2d(vec2 p, vec2 b) {\n\tvec2 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max2(q), 0.);\n}\n\nfloat boxFrame(vec3 p, vec3 b, float e) {\n\tp = abs(p) - b;\n\tvec3 q = abs(p + e) - e,\n\t     v1 = vec3(q.xz, p.y),\n\t     v2 = vec3(q.xy, p.z),\n\t     v3 = vec3(q.yz, p.x);\n\treturn min(min(length(max(v3, 0.)) + min(max3(v3), 0.), length(max(v1, 0.)) + min(max3(v1), 0.)), length(max(v2, 0.)) + min(max3(v2), 0.));\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat tor(vec3 p) {\n\tconst vec2 r = vec2(12.2, .15);\n\treturn length(vec2(length(p.xz) - r.x, p.y)) - r.y;\n}\n\nfloat pyramid(vec3 p) { return (sum3(abs(p)) - 16.) * .57735027; }\n\nvec3 rayDir(vec3 ro, vec2 uv) {\n\tvec3 f = normalize(vec3(-9, 0, 100) - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvec3 skyCol(float y) {\n\tvec3 c = pow(vec3(max(1. - y * .5, 0.)), vec3(6, 3, 1.5)) * vec3(.95, 1, 1) * (1. - pow(vec3(2), -vec3(35, 14, 7)));\n\tc *= mix(vec3(1), vec3(1, .5, .4), sin(t * .2) * .5 + .5);\n\treturn c * .03;\n}\n\nvec3 sky(vec3 rd) {\n\tvec3 p,\n\t     col = skyCol(rd.y);\n\tfloat den,\n\t      d = 10. / rd.y;\n\tif (d < 0.) return col;\n\tp = rd * d + vec3(1, .2, 1) * t * .2;\n\tp.xz *= .2;\n\tden = 1.;\n\tfor (int i = 0; i < 3; i++)\n\t\tden *= exp(-.06 * fbm(p));\n\n\treturn mix(col, LIGHT_RGB * .05, S(.9, 1., den) * (1. - sat(d / MAX_DIST)));\n}\n\nfloat fakeEnv(vec3 n) {\n\t// Thanks Blackle.\n\treturn length(sin(n * 2.5) * .5 + .5) / 1.73205;\n}\n\n// Shameless self-promotion. :)\nvoid dtc(vec2 p, inout vec3 c) {\n\tif (abs(p.x) > .6 || abs(p.y) > .5) return;\n\tif (step(min2(abs(p - vec2(0, .2))), .08) * step(p.y, .3) * step(abs(p.x), .4) > 0.) {\n\t\tc += vec3(.7, .6, .5);\n\t\treturn;\n\t}\n\n\tfloat f,\n\t      dc = step(.5, -p.x);\n\tp.x = abs(p.x) - .46;\n\tf = dot(p, p);\n\tdc += step(f, .25) * step(.16, f);\n\tif (dc > 0.) c += vec3(.5, .3, .05);\n}\n\nfloat texAluminium(vec3 p) { return S(-1., 1., fbm(p * 7. * musgraveFbm(p * 4.6))); }\n\n// ID.Reflectivity\n#define SKY_ID\t0.\n#define WALL_ID\t2.\n#define GROUND_ID\t3.1\n#define CONCRETE_ID\t4.\n#define GLASS_ID\t5.1\n#define RED_DOOR_ID\t6.\n#define GUN_METAL_ID\t7.\n#define ALI_ID\t8.\n#define WLIGHT_ID\t9.\n#define YLIGHT_ID\t10.\n#define MISSILE_ID\t11.\n\nHit window(vec3 p) {\n\t// Platform.\n\tHit h = Hit(box(dy(p, 9.5), vec3(14, 1, 16)), CONCRETE_ID, p);\n\tif (h.d > 12.) return h;\n\n\t// Safety rail (Safety Is Important)\n\tU(h, boxFrame(ax(dx(p), 0.) + vec3(-4, 7, 15), vec3(4.1, 2, 0), .2), ALI_ID, p);\n\n\t// Window frames.\n\tfloat f = S(.6, .4, abs(p.x)) + S(.8, 1., abs(p.y + 3.) - 1.5);\n\tp.xz *= mat2(.70739, .70683, -.70683, .70739);\n\tf += S(.4, .2, min(abs(p.x), abs(p.z)));\n\n\t// Windows.\n\tU(h, max(pyramid(p), p.y - 1.) - sat(f) * .1, bool(f) ? WALL_ID : GLASS_ID, p);\n\th.d *= .9;\n\treturn h;\n}\n\nfloat door(vec3 p) {\n\tfloat d = box(p, vec3(1.6, 3.2, .1)) - .4;\n\td -= .1 * S(.3, .2, abs(abs(abs(p.x) - .5) - .5)) * S(.6, .5, abs(abs(abs(p.y) - 1.7) - .7));\n\treturn d;\n}\n\nHit missiles(vec3 p) {\n\tp.y += 6.75;\n\tHit h = Hit(boxFrame(az(dz(p, -1.), 1.2), vec3(2.4, 1.7, 1.3), .1), ALI_ID, p);\n\tfloat d,\n\t      f = max(0., -p.z - 2.);\n\tf = 1. - pow(f, 2. + f);\n\tf *= S(5., 1., -p.z);\n\tf += .05 * (S(4.45, 4.5, p.z) - S(.05, 0., abs(p.z - 4.65)));\n\tp.xy = abs(p.xy) - .75;\n\tp.x = abs(p.x) - .75;\n\td = cyl(p, vec2(.7 * f, 5));\n\td = max(d, -3. - p.z);\n\tU(h, d * .7, MISSILE_ID, p);\n\treturn h;\n}\n\nHit eighty(vec3 p) {\n\tfloat d,\n\t      ox = p.x - 6.6;\n\tp.x = abs(p.x - 6.6) - 6.6;\n\tp.y -= .5;\n\tvec3 q = p;\n\tif (ox < 0.) {\n\t\tq.y = abs(q.y) - 3.35;\n\t\tq.y = p.y < 0. ? abs(q.y - 1.) - 1.2 : abs(q.y - .6) - .4;\n\t}\n\telse {\n\t\tq.y = abs(q.y + .6) - 1.2;\n\t\tq.y = abs(q.y) - 2.36;\n\t\tq.y = abs(q.y) - 1.18;\n\t}\n\n\tq.x = abs(q.x) - .8;\n\tq.xy = opModPolar(q.xy, 8.);\n\tq.x -= 3.3;\n\tHit h = Hit(box(q, vec3(.55, 2, .4)), CONCRETE_ID, p);\n\td = box(q, vec3(.3, .8, .6)) - .1;\n\tU(h, d, WLIGHT_ID, p);\n\tg.x += .01 / (.2 + d * d);\n\treturn h;\n}\n\nHit sdf(vec3 p) {\n\t// Building wall.\n\tvec3 tp,\n\t     q = p - vec3(-14.5, 5, 70);\n\tfloat f,\n\t      d = box(dz(q, -10.), vec3(48.6, 13.5, 9.5));\n\td = abs(d) - .5;\n\n\t// Left doorway.\n\ttp = p + vec3(51, 4.6, -70);\n\tf = box2d(tp.xy, vec2(1.5, 2.8));\n\td = max(d, .5 - f);\n\td = min(d, max(abs(f - .5) - .1, abs(tp.z) - .5));\n\tHit h = Hit(d, WALL_ID, q);\n\n\t// Left door.\n\ttp.z -= 1.1;\n\ttp.xz *= mat2(.95534, .29552, -.29552, .95534);\n\ttp.x += 5.;\n\tf = fract((tp.y - .8) * .6);\n\tf = min(f, fract((tp.x - .9) * .6));\n\td = box2d(tp.xy - vec2(.1, 0), vec2(1.3, 3.1));\n\tf = max(f, d - .2);\n\tf = min(f, abs(d - .2));\n\td = box(tp, vec3(1.5, 3.2, .1)) - .4;\n\td = min(d, max(f - .05, abs(tp.z) - .7));\n\tU(h, d, RED_DOOR_ID, p);\n\ttp.x -= 2.2;\n\ttp = az(tp.xzy, 2.);\n\td = cyl(tp, vec2(.5, .1));\n\tU(h, d, GUN_METAL_ID, p);\n\n\t// Right doors.\n\ttp = p + vec3(18, 4.6, -70);\n\td = door(ax(tp, 7.));\n\ttp = az(tp.xzy, 2.);\n\ttp.x = abs(tp.x + 2.) - 7.;\n\td = min(d, cyl(tp, vec2(.5, .1)));\n\tU(h, d, GUN_METAL_ID, p);\n\n\t// Top doors.\n\tU(h, door(ax(p - vec3(22, 22.5, 77), 3.)), CONCRETE_ID, p);\n\n\t// Wall speaker.\n\ttp = p + vec3(16.6, -5, -70);\n\tf = max(length(tp.xz - vec2(.4 + .02 * sin(tp.y), -.05)) - .05, tp.y);\n\ttp.x = abs(tp.x + 20.) - 20.;\n\td = abs(length(tp.xy) - .4 + tp.z * .5) - .05;\n\td = max(d, -1. - tp.z);\n\td = min(d, length(dz(tp, .3)) - .3);\n\td = min(d, box(tp, vec3(.85, .85, .3)));\n\td = min(d, f);\n\tU(h, d, GUN_METAL_ID, p);\n\n\t// Random wires.\n\ttp = p + vec3(54.5, -5, -70);\n\tf = sign(tp.x);\n\ttp.x = abs(tp.x) - .2;\n\td = max(max(length(tp.xz) - .03, tp.y - 5.), f - 3. - tp.y);\n\tU(h, d, ALI_ID, p);\n\n\t// Wall bracket things.\n\ttp = p + vec3(16.6, -2, -70);\n\ttp.x = abs(tp.x) - 16.5;\n\ttp.x = abs(tp.x) - 11.;\n\ttp.x = abs(tp.x) - 1.7;\n\td = box(tp, vec3(1, .1, .5));\n\ttp.y -= .3;\n\td = min(d, box(tp, vec3(1, .3, .2)));\n\td = max(d, p.x - 11.);\n\tU(h, d, GUN_METAL_ID, p);\n\n\t// Spot lights.\n\ttp = ax(p + vec3(31, -9, -69.5), 20.);\n\ttp.y -= sign(p.x + 20.) * 4.;\n\ttp.yz *= mat2(.95534, .29552, -.29552, .95534);\n\tU(h, box(tp, vec3(1. - sat(tp.y + .6) * .9)), GUN_METAL_ID, p);\n\tf = S(.2, 4., -tp.y - max(.4, abs(tp.x * .6)));\n\ttp.y++;\n\td = box(tp, vec3(.8, .05, .8));\n\tU(h, d, YLIGHT_ID, p);\n\tg.y += S(71., 70., p.z) * .04 / (.05 + d * d) * f;\n\n\t// Top walls.\n\td = min(box(q - vec3(0, 0, 8), vec3(48.6, 24, 1)), box(q - vec3(-10, 0, 8), vec3(40, 40, 1)));\n\tU(h, d, WALL_ID, p);\n\n\t// Top-right tower thing.\n\td = box2d(q.xz - vec2(39, 4), vec2(3.5 - p.y * .05)) - 1.;\n\td = max(d, 30. - p.y);\n\tU(h, d, CONCRETE_ID, p);\n\n\t// Right walkway.\n\ttp = q - vec3(52.5, 3.6, 13);\n\tU(h, box(tp, vec3(4, .5, 15)), CONCRETE_ID, p);\n\ttp.y -= 2.;\n\ttp.z += 6.6;\n\tU(h, boxFrame(tp, vec3(3.6, 2, 8), .1), ALI_ID, p);\n\n\t// 80\n\tUh(h, eighty(q - vec3(17, 0, 0)));\n\n\t// Balconies.\n\ttp = q - vec3(7.8, 19.8, 6);\n\ttp = ay(tp);\n\tf = 7.01 + 8. * S(12., -40.8, tp.x);\n\td = box(tp, vec3(41.5, 2, f));\n\tif (q.y > 19.8) d = max(d, tp.x - 34.8);\n\tU(h, d * .95, CONCRETE_ID, q);\n\n\t// Balcony under-struts.\n\ttp = q;\n\ttp.x = rep(tp.x);\n\ttp.y = abs(tp.y - 17.8) - 5.25;\n\tU(h, max(d - 1., max(7. - tp.z - f, box(tp, vec3(.2, .2, 200)))), CONCRETE_ID, q);\n\n\t// Balcony spots.\n\ttp = p - vec3(-18, 32, 65.5);\n\tU(h, box(tp, vec3(3.5, 1, 1)), ALI_ID, p);\n\ttp = ax(ax(tp, 1.2), 1.2);\n\ttp.z += 1.3;\n\td = cyl(tp, vec2(.6, .05));\n\tU(h, d, WLIGHT_ID, p);\n\tg.x += .1 / (.3 + d * d * d) * S(.4, -.4, tp.z);\n\n\t// Ground.\n\tq.y += 13.5;\n\tU(h, max(q.y, q.z - 20.), GROUND_ID, p);\n\n\t// Ground wall.\n\tq.z -= 8.;\n\tU(h, box(q, vec3(200, 3.6, 1)), CONCRETE_ID, p);\n\n\t// Missiles.\n\tif (p.z > 40. && p.y < 0.) {\n\t\tUh(h, missiles(ax(ax(p - vec3(12, 0, 64), 2.8), 2.8)));\n\t\tUh(h, missiles(az(ax(rxz(p - vec3(1.5, 0, 52)), 3.), 25.)));\n\t\tUh(h, missiles(rxz(p - vec3(-23.5, 3.5, 55))));\n\t\tUh(h, missiles(ax(p - vec3(-10, 0, 52), 2.6)));\n\t}\n\n\t// Windows.\n\tq = p - vec3(-62, 28, 78);\n\tUh(h, window(q));\n\tq.y -= 10.6;\n\tUh(h, window(q));\n\n\t// Watch tower.\n\tq.y += 25.;\n\tq.yz = q.zy;\n\td = cyl(q, vec2(10, 5));\n\th.d = max(h.d, -d);\n\td = abs(d) - .15;\n\td = max(d, -box(dy(q, 18.5), vec3(10, 10, 1.6)));\n\tU(h, d, WALL_ID, p);\n\tq.z += 5.;\n\td = min(d, cyl(q, vec2(13, .35)));\n\tU(h, d, CONCRETE_ID, p);\n\tq.yx = opModPolar(q.yx, 22.);\n\td = max(cyl(dy(q, -12.2), vec2(.12, 3)), -q.z);\n\td = min(d, tor(dy(q.xzy, -3.)));\n\tU(h, d, ALI_ID, p);\n\n\t// Boaty McBoatface.\n\tq = p - vec3(65, -8, 93);\n\td = box(q, vec3(15, 5, 3));\n\td = max(d, -11. - q.x - q.y);\n\tf = length(q.xy - vec2(0, 63.5));\n\td = max(d, 60. - f);\n\td += S(60.5, 67., f);\n\td += S(60.5, 61., f) * .1;\n\tU(h, d, ALI_ID, p);\n\tq.x -= 5.;\n\td = box(q, vec3(5, 8, 1));\n\td = min(d, max(box(q, vec3(10, 7, 2)), -10. - q.x + q.y * .5)) + .05 * S(.1, 0., abs(q.y - 5.));\n\tU(h, d, CONCRETE_ID, p);\n\tq.x = abs(q.x + 1.) - 3.;\n\tq.x = abs(q.x) - 2.;\n\tq += vec3(1, -6, 2);\n\td = length(q);\n\tg.y += 1e-4 / (.001 + d * d);\n\n\t// Nothing is perfectly sharp.\n\th.d -= .01;\n\treturn h;\n}\n\nvec3 N(vec3 p, float d) {\n\tfloat h = d * .05;\n\tvec3 n = vec3(0);\n\tfor (int i = I0; i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdf(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld, vec3 n) {\n\t// Quick abort if light is behind the normal.\n\tif (dot(ld, n) < -.1) return 0.;\n\tif (p.y > 20. || p.z < 40.) return 1.;\n    \n\tfloat s = 1.,\n\t      l = .01,\n\t      mxL = length(p - lp);\n\tfor (float i = Z0; i < SHADOW_STEPS; i++) {\n\t\tfloat d = sdf(l * ld + p).d;\n\t\ts = min(s, 7. * d / l);\n\t\tl += max(.05, d);\n\t\tif (mxL - l < .5 || s < .001) break;\n\t}\n\n\treturn S01(s);\n}\n\n// Quick 2-level ambient occlusion.\nfloat ao(vec3 p, vec3 n) {\n\tconst vec3 h = vec3(2, 3, 5);\n\tvec3 ao;\n\tfor (int i = I0; i < 3; i++)\n\t\tao[i] = sdf(h[i] * n + p).d;\n\n\treturn sat(mul3((1. - AO_STRENGTH) + AO_STRENGTH * ao / h));\n}\n\nvec3 lights(vec3 p, vec3 ro, vec3 rd, inout vec3 n, inout Hit h) {\n\tif (h.id == SKY_ID) return sky(rd);\n\tfloat _ao, sha,\n\t      spe = 10.,\n\t      shine = 1.;\n\tvec3 c, l, skyTop, col,\n\t     ld = normalize(lp - p);\n\n\t// Calculate ambient occlusion and shadows.\n\t_ao = ao(p, n);\n\tsha = shadow(p, ld, n);\n\tif (h.id == CONCRETE_ID || h.id == WALL_ID) {\n\t\tc = vec3(.55, .55, .65);\n\t\tfloat f = 0.;\n\t\tif (h.id == WALL_ID) {\n\t\t\t// Concrete slabs.\n\t\t\tf = fract(p.x * .08) - .5;\n\t\t\tc *= .6 + .2 * S(0., .012, abs(f));\n\t\t\tf = floor((p.x - 6.25) * .08);\n\t\t\tc *= 1. + .4 * (h11(f) - .5);\n\t\t\tf = floor(p.x - 6.25);\n\n\t\t\t// Me!\n\t\t\tdtc((p.xy + vec2(11, -.3)) * .6, c);\n\n\t\t\t// Damp.\n\t\t\tc *= .65 + .35 * S(0., 2., 13. + p.y - fbm2(vec2(p.x * .12, 1)) * 10.);\n\t\t}\n\n\t\tc *= texAluminium((p + f) * .015);\n\n\t\t// Dark footer.\n\t\tc *= .2 + .8 * S(0., .2, p.y + 7.8);\n\t}\n\telse if (h.id == GROUND_ID) {\n\t\tc = vec3(.05);\n\n\t\t// White/yellow stripe.\n\t\tfloat b, r,\n\t\t      f = S(1., .7, abs(p.z - 30. - p.x * .05));\n\t\tc += mix(vec3(.5, .25, 0), vec3(.5), S(0., .2, sin(p.x * .4))) * f;\n\n\t\t// Bump map a water effect.\n\t\tb = S(.6, .3, .75 * n21(p.xz * .1) + .25 * n21(p.xz * .3));\n\t\tf = mix(n31(p * 5.) * .4, n31(p * vec3(.7, 1, 3)), b);\n\t\tn.z += .15 * (f - .5);\n\n\t\t// Patchy puddles.\n\t\th.id = floor(h.id) + .01 + .08 * b + S(45., 80., p.z) * .3;\n\t\tc *= .4 + .6 * f;\n\n\t\t// Rain drops.\n\t\tr = h21(floor(p.xz * .3));\n\t\tf = length(fract(p.xz * .3) - .5);\n\t\tf = S(.95, 1., sin(f * 25. - (t + 10.) * r * 6.)) * S(.4, 0., f);\n\t\tf *= step(.6, r);\n\t\tf *= .2 + .8 * b;\n\t\tc *= 1. + f * f * 15.;\n\t\tn = normalize(n);\n\t}\n\telse if (h.id == RED_DOOR_ID) c = vec3(.6, .11, .1);\n\telse if (h.id == WLIGHT_ID) c = vec3(5);\n\telse if (h.id == YLIGHT_ID) c = YELLOW_LIGHT_RGB;\n\telse if (h.id == GUN_METAL_ID) c = vec3(.12, .12, .15);\n\telse if (h.id == ALI_ID) c = vec3(.3);\n\telse if (h.id == MISSILE_ID) {\n\t\tc = vec3(.05, .1, .05);\n\t\tc += S(4.45, 4.5, h.p.z) * .1;\n\t\tc.rg += .15 * S01(sin(h.p.z * 10.)) * step(h.p.z, -.8);\n\t}\n\telse {\n\t\tc = vec3(.1, .1, .05);\n\t\tshine = 7.;\n\t\tspe = 80.;\n\t}\n\n\tl = sat(vec3(dot(ld, n),  // Key light.\n\tdot(-ld.xz, n.xz),  // Reverse light.\n\tn.y // Sky light.\n\t));\n\tl.x *= fakeEnv(ld * 4.); // Light mask.\n\tl.xy = .1 + .9 * l.xy; // Diffuse.\n\tl *= _ao; // Ambient occlusion.\n\tl *= vec3(1, .5, .2); // Light contributions (key, reverse, sky).\n\tl.x *= .1 + .9 * sha;\n\tskyTop = skyCol(1.);\n\tc += skyTop * (1. - sha) * .5;\n\tshine *= sha;\n\tl.x += pow(sat(dot(normalize(ld - rd), n)), spe) * shine;\n\n\t// Light falloff.\n\tl.x *= dot(lp, lp) / (1. + dot(lp - p, lp - p));\n\n\t// Combine the lights (key, reverse, sky).\n\tcol = mix((sum2(l.xy) * LIGHT_RGB + l.z * skyTop) * c, skyTop, S(.6, 1., 1. + dot(rd, n)) * .25);\n\n\t// Distance Fog.\n\treturn mix(skyCol(0.), col, 1. - sat(S(65., 105., length(p.yz))));\n}\n\nfloat addFade() { return min(1., abs(t)); }\n\nvec3 march(vec3 ro, vec3 rd) {\n\tfade = addFade();\n\tlp = vec3(0, .001, -15);\n\tlp.yz *= mat2(.69671, -.71736, .71736, .69671);\n\tlp.xz *= mat2(.2675, -.96356, .96356, .2675);\n\n\t// March the scene.\n\tvec3 n,\n\t     p = ro,\n\t     col = vec3(0);\n\tfloat i,\n\t      d = START_DIST;\n\tHit h;\n\tg = vec2(0);\n\tfor (i = Z0; i < MAX_STEPS; i++) {\n\t\tif (d > MAX_DIST) {\n\t\t\th.id = SKY_ID;\n\t\t\tbreak;\n\t\t}\n\n\t\th = sdf(p);\n\t\tif (abs(h.d) < MIN_DIST * d) break;\n\t\td += h.d;\n\t\tp += h.d * rd;\n\t}\n\n\tcol += g.x * LIGHT_RGB;\n\tcol += g.y * YELLOW_LIGHT_RGB;\n\tn = N(p, d);\n\tcol += lights(p, ro, rd, n, h);\n    \n\tif (fract(h.id) > 0.) {\n\t\t// We hit a reflective surface, so march reflections.\n\t\tfloat refl = fract(h.id);\n\t\trd = reflect(rd, n);\n\t\tp += n * .01;\n\t\tro = p;\n\t\td = .01;\n\t\tg = vec2(0);\n\t\tfor (i = Z0; i < MAX_RSTEPS; i++) {\n\t\t\tif (d > MAX_RDIST) {\n\t\t\t\th.id = SKY_ID;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\th = sdf(p);\n\t\t\tif (abs(h.d) < MIN_DIST * d) break;\n\t\t\td += h.d;\n\t\t\tp += h.d * rd;\n\t\t}\n\n\t\t// Add a hint of the reflected color.\n\t\tcol += refl * g.x * LIGHT_RGB;\n\t\tcol += refl * g.y * YELLOW_LIGHT_RGB;\n\t\tn = N(p, d);\n\t\tcol += refl * (1. - col) * lights(p, ro, rd, n, h);\n\t}\n\n\treturn max(vec3(0), col);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tg = vec2(0);\n\tt = mod(iTime, 30.);\n\n\t// Camera.\n\tvec2 uv = (fc - .5 * R.xy) / R.y;\n\tvec3 col,\n\t     ro = vec3(-10, 0, t * .7 - 10.);\n\n\t// View bob.\n\tro += sin(t * vec3(.9, .7, .3));\n\tcol = march(ro, rayDir(ro, uv));\n\tcol *= 1. + S(.97, 1., n21((uv + vec2(.1, 8) * t) * vec2(100, 2) * mat2(-.41615, .9093, -.9093, -.41615)));\n\tfragColor = vec4(col * fade, 0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define LENS 0.005\n\nvec2 fisheye(vec2 uv) {\n    uv -= 0.5;\n    uv *= pow(dot(uv, uv), LENS);\n    return uv + 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Lens distortion.\n    uv = fisheye(uv);\n\n    fragColor = texture(iChannel0, uv);    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}