{
    "Shader": {
        "info": {
            "date": "1635413954",
            "description": "Simulates particles nucleating into a hexagonal lattice. Hue indicates detected orientation. Mouse to move",
            "flags": 32,
            "hasliked": 0,
            "id": "NsySRc",
            "likes": 15,
            "name": "Nucleation",
            "published": 3,
            "tags": [
                "simulation",
                "particle",
                "lattice"
            ],
            "usePreview": 0,
            "username": "davidar",
            "viewed": 402
        },
        "renderpass": [
            {
                "code": "#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0,0,0,1);\n    \n    float scale = 1. + 9. * smoothstep(0., 10., iTime);\n    vec2 m = iResolution.xy/2.;\n    if (iMouse.xy != vec2(0)) m = iMouse.xy;\n    vec2 p = (fragCoord - m)/scale + m;\n    //if (floor(mod(fragCoord.x, 10.)) == 0. || floor(mod(fragCoord.y, 10.)) == 0.) fragColor += 0.1;\n\n    for (int i = -2; i <= 2; i++) {\n        for (int j = -2; j <= 2; j++) {\n            vec4 data = texelFetch(iChannel0, ivec2(p) + ivec2(i,j), 0);\n            if (data != vec4(0)) {\n                vec4 col = mix(vec4(1), hue(data.w), smoothstep(1., 2., data.z));\n                fragColor += smoothstep(1., 0.67, distance(data.xy, p)) * clamp(data.z, 0., 1.) * col;\n                fragColor = clamp(fragColor, vec4(0), vec4(1));\n            }\n        }\n    }\n    fragColor = sqrt(1. - fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n        vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n        vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n        vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n        p4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define PI 3.1415926536\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0);\n    if (iFrame < 10) {\n        if (hash12(fragCoord) < 1e-2)\n            fragColor = vec4(fragCoord.xy + hash12(1. + fragCoord) - 0.5, 0, 0);\n        return;\n    }\n    \n    vec4 data = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    vec2 pos = data.xy;\n    vec2 force = vec2(0);\n    \n    float minDist = 1e3;\n    \n    vec2 orientation = vec2(0);\n    int count = 0;\n\n    for (int i = -10; i <= 10; i++) {\n        for (int j = -10; j <= 10; j++) {\n            vec2 ij = vec2(i,j);\n            if (ij == vec2(0) || length(ij) > 10.) continue;\n\n            vec4 data2 = texture(iChannel0, (fragCoord + ij) / iResolution.xy);\n            if (data2 != vec4(0)) {\n                vec2 pos2 = data2.xy;\n                vec2 vel2 = data2.zw;\n                vec2 delta = pos - pos2;\n                if (data == vec4(0)) delta = fragCoord - pos2;\n                float dist = length(delta) / 2.;\n\n                // something like an interatomic potential\n                force += mix(10. * delta / pow(dist, 4.), -delta / pow(dist, 2.), smoothstep(0.9, 1., dist));\n\n                if (dist < minDist && data2.z >= 1.)\n                    minDist = dist;\n\n                if (dist < 1.) {\n                    float angle = atan(delta.y, delta.x);\n                    angle = mod(angle, PI/3.);\n                    orientation += vec2(cos(angle), sin(angle));\n                    count++;\n                }\n            }\n        }\n    }\n\n    if (data == vec4(0) && 1. < minDist && minDist < 2. && hash13(vec3(fragCoord, iFrame)) < 1e-3)\n        pos = fragCoord; // new particle\n\n    pos = mod(pos + force/1e3, iResolution.xy);\n    float z = data.z + 0.01;\n    if (z > 1.) z = mix(z, (count < 6) ? 1. : 2., 0.05);\n    fragColor = vec4(pos, z, mix(data.w, atan(orientation.y, orientation.x), 0.01));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0);\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec4 data = texture(iChannel0, fract((fragCoord + vec2(i,j)) / iResolution.xy));\n            if(floor(data.x) == floor(fragCoord.x) && floor(data.y) == floor(fragCoord.y)) {\n                fragColor = data;\n                return;\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}