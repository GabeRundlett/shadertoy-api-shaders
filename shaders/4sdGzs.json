{
    "Shader": {
        "info": {
            "date": "1465056247",
            "description": "See the [url=https://twitter.com/tdhooper/status/738925905796575232]gif export without artefacts[/url], I need a better way of modelling spikes.",
            "flags": 0,
            "hasliked": 0,
            "id": "4sdGzs",
            "likes": 57,
            "name": "Radiolarian #3",
            "published": 3,
            "tags": [
                "sdf",
                "icosahedron",
                "subdivision",
                "polyhedra",
                "geodesic"
            ],
            "usePreview": 0,
            "username": "tdhooper",
            "viewed": 1608
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n\nfloat t;\nfloat pulse;\nfloat move;\n\n// HG_SDF\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n    return dot(p, n) + distanceFromOrigin;\n}\n\nfloat fPlane(vec3 p, vec3 a, vec3 b, vec3 c, vec3 inside, float distanceFromOrigin) {\n    vec3 n = normalize(cross(c - b, a - b));\n    float d = -dot(a, n);\n    \n    if (dot(n, inside) + d > 0.) {\n        n = -n;\n        d = -d;\n    }\n\n    return fPlane(p, n, d + distanceFromOrigin);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif ((-a < r) && (-b < r)) {\n\t\treturn max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n\t} else {\n\t\treturn m;\n\t}\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tfloat m = min(a, b);\n\tif ((a < r) && (b < r) ) {\n\t\treturn min(m, r - sqrt((r-a)*(r-a) + (r-b)*(r-b)));\n\t} else {\n\t return m;\n\t}\n}\n\n\n\n// Knighty https://www.shadertoy.com/view/XlX3zB\n\n\n// Barycentric to Cartesian \nvec3 bToC(vec3 A, vec3 B, vec3 C, vec3 barycentric) {\n\treturn barycentric.x * A + barycentric.y * B + barycentric.z * C;\n}\n\nint Type=5;\n\nvec3 nc,pab,pbc,pca;\nvec3 icoF0;\nvec3 icoF1a;\nvec3 icoA0;\nvec3 icoB0;\nvec3 icoC0;\nvec3 icoA1;\nvec3 icoB1;\nvec3 icoC1;\nvec3 fold1;\nvec3 fold2;\nvec3 fold3;\nvoid initIcosahedron() {//setup folding planes and vertex\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n\tnc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n\tpab=vec3(0.,0.,1.);\n\tpbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n\tpca=vec3(0.,scospin,cospin);\n\tpbc=normalize(pbc);\tpca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :) \n\n    vec3 A = pbc;\n    vec3 C = reflect(A, normalize(cross(pab, pca)));\n    vec3 B = reflect(C, normalize(cross(pbc, pca)));\n    \n    icoF0 = pca;\n    \n\ticoA0 = A;\n\ticoC0 = B;\n\ticoB0 = C;\n\n    vec3 p1 = bToC(A, B, C, vec3(.5, .0, .5));\n    vec3 p2 = bToC(A, B, C, vec3(.5, .5, .0));\n    fold1 = normalize(cross(p1, p2));\n    \n    // Get corners of triangle created by fold\n    vec3 A2 = reflect(A, fold1);\n    vec3 B2 = p1;\n    vec3 C2 = p2;\n    \n    icoF1a = pca;\n    \n    icoA1 = A2;\n    icoB1 = normalize(B2);\n    icoC1 = normalize(C2);\n    \n    p1 = bToC(A2, B2, C2, vec3(.5, .0, .5));\n    p2 = bToC(A2, B2, C2, vec3(.5, .5, .0));\n    fold2 = normalize(cross(p1, p2));\n    \n\tp1 = bToC(A2, B2, C2, vec3(.0, .5, .5));\n    fold3 = normalize(cross(p2, p1));\n}\n\n\n\nfloat pModIcosahedron(inout vec3 p, int subdivisions) {\n    p = abs(p);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    \n    float i = 0.;\n    \n    if (subdivisions > 0) {\n\n        // Fold in corner A \n        i += pReflect(p, fold1, 0.) / 2. + .5;\n        \n        if (subdivisions > 1) {\n            \n            // Fold in corner A\n            pReflect(p, fold2, 0.);\n            \n            // Fold in corner B\n            pReflect(p, fold3, 0.);\n        }\n    }\n\n    return i;\n}\n\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );       \n}\n\nvec3 pRoll(inout vec3 p) {\n    pR(p.yx, PI/3.);\n    pR(p.yz, PI/-5.);\n    mat3 m = rotationMatrix(normalize(icoF1a), t * ((PI*2.)/3.));\n    p *= m;\n    return p;\n}\n\nfloat fCone(vec3 p, float radius, float height, vec3 direction) {\n    p = reflect(p, normalize(mix(vec3(0,1,0), -direction, .5)));\n    //p -= vec3(0,height,0);\n    return fCone(p, radius, height);\n}\n\n\nfloat fHolePart(\n    vec3 p,\n    vec3 a,\n    vec3 b,\n    vec3 c,\n    vec3 d,\n    float round,\n    float thick\n) {\n    vec3 center = (a + b + c + d) / 4.;\n    float f0 = fPlane(p, a, b, c, center, thick);\n    float f1 = fPlane(p, a, c, d, center, thick);\n   \tfloat f = f0;\n   \tf = fOpIntersectionRound(f, f1, round);\n   \treturn f;\n}\n\n    \nfloat fHole(\n    vec3 p,\n    vec3 a,\n    vec3 b,\n    vec3 c\n) {\n    float w = 1.;\n    float h = 1.;\n    float round = .08;\n    float thick = .02;\n\n\tfloat d = 1000.;\n\n    vec3 AB = mix(a, b, 0.5);\n    vec3 AAB = mix(a, b, w);\n    vec3 ABB = mix(a, b, 1. - w);\n    vec3 n = normalize(cross(a, b));\n    vec3 cn = dot(c, n) * n;\n    vec3 AF = c - cn * (1. - h);\n    vec3 AF2 = reflect(AF, n);\n\n    float part1 = fHolePart(p, vec3(0), AF2, AAB, AF, round, thick);\n\tfloat part2 = fHolePart(p, vec3(0), AF2, ABB, AF, round, thick);\n\tfloat hole = fOpIntersectionRound(part1, part2, round);\n    return hole;\n}\n\nfloat holes(vec3 p, float i) {\n    float d = 1000.;\n\n    if (i > 0.) {  \n        return min(d, fHole(p, icoC1, icoB1, icoF1a));\n    }\n    \n    d = min(d, fHole(p, icoC1, icoB1, icoF1a));\n    d = min(d, fHole(p, icoA1, icoB1, icoF1a));\n    return d;\n}\n\n\nfloat spikes(vec3 p) {\n    float d = 1000.;\n    d = min(d, fCone(p, .05, 1.3, icoF1a));\n    d = min(d, fCone(p, .05, 1.7, icoA1));\n    d = min(d, fCone(p, .05, 1.8, icoB1));\n    return d;\n}\n\nfloat shell(vec3 p, float i) {\n\n    float thick = .03;\n    float round = .015;\n\n    float d = length(p) - 1.;\n    d = fOpUnionRound(d, spikes(p), .12);\n    d = max(d, -(length(p) - (1. - thick)));\n\tfloat h = holes(p, i);\n    h = max(h, (length(p) - 1.1)); // Stop holes clipping spikes\n    d = fOpIntersectionRound(d, -h, round);\n    return d;\n}\n\nfloat model(vec3 p) {\n    pRoll(p);\n\n    float d = 1000.;\n    float i = 0.;\n \n    i = pModIcosahedron(p, 1);\n    d = min(d, shell(p, i)); \n    return d;\n}\n\nvec3 doBackground(vec3 rayVec) {\n    return vec3(.13);\n}\n\n\n// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n//const float MAX_STEP_DISTANCE = 0.05;\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n    return (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 p ){  \n    \n    vec2 res = vec2(model(p) ,1.); \n    \n    return res;\n}\n\n\n\n// LIGHTING\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nconst float GAMMA = 2.2;\n\nvec3 gamma(vec3 color, float g)\n{\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB)\n{\n    return gamma(linearRGB, 1.0 / GAMMA);\n}\n\nvec3 doLighting(vec3 col, vec3 pos, vec3 nor, vec3 ref, vec3 rd) {\n\n    // lighitng        \n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize( vec3(-0.6, 0.7, 0.5) );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    //float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    //float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n    \n    dif *= softshadow( pos, lig, 0.02, 2.5 );\n    //dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n    vec3 lin = vec3(0.0);\n    lin += 1.20*dif*vec3(.95,0.80,0.60);\n    //lin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n    lin += 0.80*amb*vec3(0.50,0.70,.80)*occ;\n    //lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n    lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n    lin += 0.20*fre*vec3(1.00,1.00,1.00)*occ;\n    col = col*lin;\n\n    return col;\n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n    float res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n        vec2 m = map( ro+rd*t );\n        h = m.x;\n        //t += min(h, MAX_STEP_DISTANCE);\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse) {\n    vec3 orient = normalize(vec3(.1, 1, 0.));\n    float zoom = 4.;\n    zoom -= mouse.y * 3.5;\n    camPos = zoom * orient;\n    camTar = vec3(0);\n}\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n\n  vec3 color = vec3(.04,.045,.05);\n    \n  if( res.y > -.5 ){\n      \n    vec3 pos = ro + rd * res.x;\n    vec3 norm = calcNormal( pos );\n    vec3 ref = reflect(rd, norm);\n\t//return norm * 0.5 + 0.5;\n      \n\tcolor = vec3(.5);  \n\tcolor = doLighting(color, pos, norm, ref, rd);\n  }\n   \n  return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime;\n    t = mod(t/4., 1.);    \n\n    initIcosahedron();\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 ro = vec3( 0., 0., 2.);\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    // camera movement\n    doCamera(ro, ta, iTime, m);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n\n    \n    vec3 color = render( res , ro , rd );\n\tcolor = linearToScreen(color);\n    \n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}