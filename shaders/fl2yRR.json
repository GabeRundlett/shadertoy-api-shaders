{
    "Shader": {
        "info": {
            "date": "1649045954",
            "description": "A variant of my \"Banded mosaic\" pattern with a more interesting color palette.\nClick and drag to move around.",
            "flags": 40,
            "hasliked": 0,
            "id": "fl2yRR",
            "likes": 6,
            "name": "Fractal mosaic 2 (music)",
            "published": 3,
            "tags": [
                "fractal",
                "mosaic"
            ],
            "usePreview": 0,
            "username": "jarble",
            "viewed": 531
        },
        "renderpass": [
            {
                "code": "#define fmod(x,y) mod(floor(x),y)\n#define fpow(x,y) pow(y,fmod(x,y))\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvec2 f1(vec2 a){\n    return\n        fract(a)\n        //fract(a-fract(a*4.)/2.)\n        //fract(a-floor(2.*a.x+1.5)/2.)\n    ;\n}\n\nvec2 triangle_wave(vec2 a,float num){\n    a = rotate(a,num*radians(180.));\n    //a += sign(a.y)/2.;\n    vec2 to_return = abs(f1((a+vec2(1.,0.5))*1.5)-.5);\n    //to_return /= 1.5; // makes another interesting pattern\n    return to_return;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 36.*1.5*2.;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    uv -= draggedPos/iResolution.y/t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    vec2 t3 = vec2(0.);\n    float rotation_number = 0.;\n    vec3 col1 = col;\n    for(int k = 0; k < 12; k++){\n        //uv.x -= fmod(uv.x,1.5); //lace pattern\n        //uv += floor(uv+vec2(1.,.5))/1.5;\n        //uv += floor(uv/1.5)/1.5;\n        \n        float offset =\n            //Change this to get lots of interesting patterns\n            0.\n            //.25\n            //float(k)/2.\n        ;\n        \n        float p1 = sign(uv.x);\n        //rotation_number -= p1/2.;\n        //float rotation_number = floor(uv.x)/2.+sign(uv.x-uv.y)/2.;\n\n        //uv.x -= sign(uv.x+.5)/scale;\n        //uv += (abs(fract(uv.yx-vec2(0.,1.5)))+1.)/8.;\n        //t2 = abs(t2*2.);\n        uv +=\n            t2\n            //t2/(1.+fmod(uv.x,2.))\n            //t2+fpow(uv.x,2.)/2.\n            //t2+abs(uv)\n        ;\n        //uv = (fract(vec2(uv+vec2(.5,1.5))*scale)-.5)/scale;\n        //uv += (distance(floor(uv),round(uv+.5)));\n\n        //uv += t2-float(k)/(4.-(uv.x-uv.y)/(4.-(uv.x-uv.y))); //this makes an even crazier pattern\n\n        //uv -= floor(t2.y+t2.x)/4.;\n        //if(uv.y>uv.x) {uv = -uv.yx;} else uv *= -sign(uv-uv.yx);\n        uv /= scale;\n        //float rotation_number = ceil((float(k)+uv.y)/(3.-uv.x/4.));\n        //float rotation_number = ((float(k)/2.));\n        \n        //uv += floor(t2.x+t2.y);\n        //uv = max(uv,uv*sign(uv.yx-uv));\n        //if(uv.y>uv.x) uv = -uv.yx; else uv *= -sign(uv-uv.yx);\n        t2 =\n            -p1*triangle_wave(uv+offset-.5,rotation_number)\n            //-p1*triangle_wave(uv+floor(uv.y*2.)+offset-.5,rotation_number)\n            //-p1*triangle_wave(uv+offset-.5+floor(t2.y-t2.x),rotation_number)\n            //-p1*triangle_wave(uv-.5-fmod(t2.x/1.5,2.),rotation_number)\n        ;\n        \n        t3 = p1*triangle_wave(uv.yx+offset,rotation_number);\n        \n        //t3 += dot(t3,t3)/2.; //makes another interesting pattern\n\n        //t2 -= abs(t2-.5)/8.;\n        //t3 -= abs(t3-.5)/8.;\n        uv = t2-t3;\n        //t2 = mix(t2,uv,.5);\n\n        //col.x = abs(col.x-.5);\n        \n        //if(uv.x>uv.y)\n        col.x =\n            max(uv.y-uv.x*p1-col.x,col.x*2.75)\n            //max(length(uv-t2*(uv.x-uv.y))*p1-col.x,col.x*2.75)\n        ;\n        \n        col = abs(col.yzx-vec3(1.5-col.x))/2.;\n        //if(uv.y>uv.x) col.x = col.x/2.;\n        col1 = abs(col1.yzx-col);\n        //uv = max(uv,t2);\n         \n        //if(uv.x>uv.y) {uv=uv.yx;t2=t2.yx;}\n        //col *= col.yzx;\n        //uv.x -= .25; //flower pattern\n        //uv.x += .5;\n        //else uv *= 1.5;\n        //if(uv.x<uv.y) uv.x += .5;\n        //if(uv.x < .5) uv.x += .5;\n        //if(uv.y < .5) uv.y += .5;\n        \n\n    }\n    fragColor =\n        vec4(col*2.,1.0);\n        //vec4(col1*2.,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float fmod2(float a, float b){\n    return mod(floor(a),b)*b;\n}\n\nfloat fmod(float a, float b){\n    //a += fmod2(a,4.);\n    \n    //a += pow(2.,mod(floor(a/8./8.),8.));\n    /*\n    for(int i = 0; i < 3; i++){\n        a += floor(a/4.)*4.;\n    }\n    */\n    \n    \n    /*\n    for(int i = 0; i < 3; i++){\n        a += mod(floor(a/4.),4.);\n    }\n    */\n    //a = a + floor(a/b)/b*8.;\n    //a += pow(2.,mod(floor(a/8.),3.));\n\n    /*\n    for(float i = 1.; i < mod(floor(a/b),8.); i++){\n        a += mod(floor(a/b),b)*i;\n        a *= 1.+mod(floor(a)*2.,2.);\n        i /= 1.+mod(floor(a)*2.,2.);\n    }\n    */\n    //divide by prime numbers to get interesting rhythms\n    float a1 = floor(a);\n    //a /= 1. + mod(floor(a1/11.),2.);\n    //a /= 1. + mod(floor(a1/7.),2.);\n    //a /= 1. + mod(floor(a1/5.),2.);\n    //a /= 1. + mod(floor(a1/3.),2.);\n    //a /= 1. + mod(floor(a1/2.),2.);\n    return\n        mod(floor(a),b)\n        //floor(mod(floor(a),b)-mod(floor(a),b/2.))\n        //max(mod(floor(a*8./b),b),mod(floor(a/2./b),b))\n        //min(b-mod(floor(a*b/8.),b),mod(floor(a/b),b))\n        //mod(floor(a*8./b/4.) + floor(a*b/8./4.),b)\n        //mod(floor(a)*floor(a*2./b),b)\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n        //max(mod(floor(a/4.),b),mod(floor(a),b))\n    ;\n}\n\n//#define fmod(a,b) mod(mod(floor((a)),floor(1.+(a)/5.)),b)\n//#define fmod(x,y) mod(floor(x),y)\n\n//#define fmod(a,b) mod(floor(a) + floor((a)/2.)*2.+floor((a)/4.)*4.+floor((a)/8.)*8.+floor((a)/16.)*16.,b)\n//#define fmod(x,y) mod(floor(x)+floor((x)/8./8.),y)\n//#define fmod(x,y) max(mod(floor((x)/2.),y),mod(floor(x),y))\n\n#define fmod1(x,y) mod(floor(x+floor(t0/y)),y)\n#define fmod2(x,y) mod(floor(y*((x)/y+floor((x)/y)/y)),y)\n\n#define floor1(x) floor(x)*floor(mod((x)/4.,2.))\nvec2 mainSound(int samp, float time){\n float tempo =\n     1.\n     //pow(2.,fmod2(time,2.))\n ;\n time /= tempo;\n \n //crazy awesome remix!\n //time = (time + mod(time*2.,1.+fmod(time/4.,2.))/2.)/2.;\n \n //time /= (1.+fmod(time/2.,2.));\n //time *= (1.+fmod(time*2.,2.));\n \n //time /= 1.5;\n float t0=time, s1 =\n      8.\n      //pow(2.,2.+fmod(time/8.,3.))\n ;\n //time = (time + pow(2.,fmod(time,3.)));\n\n s1 /= pow(2.,fmod(time/s1/2.,2.));\n s1 *= pow(2.,fmod(time/s1/2.,2.))/2.;\n  \n  float f1 = floor(time*s1)/s1;\n  time += f1;\n  //time += floor(time*s1)*fmod(time/s1,s1)/s1;\n  \n  float s2 = 8.,\n  m4 =\n      fmod(time,2.)\n  ,\n  t=\n      time/(1.+m4)\n  ,\n  m1 =\n      fmod(t,s2)\n      //fmod(floor(t/(1.+m4))*floor(t*s1),s2)\n      //fmod(floor(t/s1)*(floor(t*s1)+floor(t)),s2)\n  ,\n  m3 =\n      fmod(floor(t*s1+m1),s2)\n      //fmod(floor(t*s1+m1),s2+m1)\n  ;\n  //t /= max(m1,m3)+1.;\n  t /=\n      (1.+fmod(t/s1,2.))\n      //(1.+fmod(t/(1.+m1),2.))\n  ;\n  \n  float m2 =\n      1. + fmod(t*s1,s1)\n      //1. + fmod(t/s1*sign(m1-m3),s1)\n      //1. + fmod(t/s1+mod(t/s1,s1/2.),s1)\n  ;\n  \n  //time = time*(1. + fmod(time/s1,2.));\n  \n  float a =\n      //64.*sqrt((1.-sqrt(max(fract(t),fract(t*s1)))))*.2\n      4.*((1.-log(max(fract(t),fract(t*s1)))))\n\n      //(log(1.)-log(max(fract(-t*s1/4.),fract(-t/4.))/s1))\n      //2.*(fract(-t)/2.)\n  ,\n\n  nb = pow(2.,(m3+m2)/5.+6.5)*tempo*time;\n\n  return\n      //abs(.5-vec2(fract(nb*.998),fract(nb)))*a\n      //log(abs(.5-vec2(fract(nb*.998),fract(nb)))*a)\n      log(.125+abs(abs(.5-vec2(fract(nb*.998),fract(nb)))*a/2.))\n   ;\n\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "//from https://www.shadertoy.com/view/dtGGzK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}