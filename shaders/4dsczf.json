{
    "Shader": {
        "info": {
            "date": "1489176382",
            "description": "2D Distance Functions in 3D",
            "flags": 0,
            "hasliked": 0,
            "id": "4dsczf",
            "likes": 1,
            "name": "Parallax 3D + 2D Distance",
            "published": 3,
            "tags": [
                "distancefunctions"
            ],
            "usePreview": 0,
            "username": "hopskotchrainbow",
            "viewed": 711
        },
        "renderpass": [
            {
                "code": "#define eps 0.001\n#define epsx vec2(eps, 0.0)\n#define epsy vec2(0.0, eps)\n#define pi 3.14152865\n\nconst float pi2 = pi * 2.;\n\nmat2 rot2D(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\n// convert distance to alpha\nfloat dtoa(float d, float amount)\n{\n    float a = clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\n    return a;\n}\n\n\n\n// distance functions: ------------------------------------------------\n\n\n\n// circle\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\n{\n    float d = length(uv - origin) - radius;\n    return d;\n}\n\n// signed distance to segment of 1D space. like, for making a vertical column\nfloat sdSegment1D(float uv, float a, float b)\n{\n    return max(a - uv, uv - b);\n}\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\n{\n  \tvec2 d = max(tl - uv, uv - br);\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n}\n\n// the big question is what is the best way to INPUT a free rect? tl+br+angle? p1,p2,p3?\nfloat sdRect(vec2 uv, vec2 a, vec2 b, float angle)\n{\n    // flatten the line to be axis-aligned.\n    vec2 rectDimensions = b - a;\n    mat2 rotMat = rot2D(-angle);\n    a *= rotMat;\n    b *= rotMat;\n\treturn sdAxisAlignedRect(uv * rotMat, a, b);\n}\n\n// really a line segment with line width is just a rect expressed differently\nfloat sdLineSegment(vec2 uv, vec2 a, vec2 b, float lineWidth)\n{\n    // flatten the line to be axis-aligned.\n    vec2 rectDimensions = b - a;\n    float angle = atan(rectDimensions.x, rectDimensions.y);\n    mat2 rotMat = rot2D(-angle);\n    a *= rotMat;\n    b *= rotMat;\n    float halfLineWidth = lineWidth / 2.;\n    a -= halfLineWidth;\n    b += halfLineWidth;\n\treturn sdAxisAlignedRect(uv * rotMat, a, b);\n}\n\n// union of line segment and 2 circles\nfloat sdLineSegmentRounded(vec2 uv, vec2 a, vec2 b, float lineWidth)\n{\n    // flatten the line to be axis-aligned.\n    vec2 rectDimensions = b - a;\n    float angle = atan(rectDimensions.x, rectDimensions.y);\n    mat2 rotMat = rot2D(-angle);\n    a *= rotMat;\n    b *= rotMat;\n    float halfLineWidth = lineWidth / 2.;\n\n    uv *= rotMat;\n    vec2 tl = vec2(a.x - halfLineWidth, a.y);\n    vec2 br = vec2(b.x + halfLineWidth, b.y);\n\n    return min(min(sdAxisAlignedRect(uv, tl, br),\n                   sdCircle(uv, a, halfLineWidth)),\n                   sdCircle(uv, b, halfLineWidth));\n}\n\n\n// squircle\n// http://en.wikipedia.org/wiki/Squircle\nfloat sdSquircle(vec2 uv, vec2 origin, float radius, float power, float rot_)\n{\n    mat2 rot = rot2D(rot_);\n\tvec2 v = abs((origin*rot) - (uv*rot));\n    float d = pow(v.x,power) + pow(v.y, power);\n    d -= pow(radius, power);\n    return d;\n}\n\n// distance to edge of hexagon\nfloat sdHexagon(vec2 p, vec2 hexPos, float hexRadius, float hexRotation)\n{\n    mat2 rot = rot2D(hexRotation);\n\tvec2 v = abs((hexPos*rot) - (p*rot));\n\n\tvec2 topBottomEdge = vec2(0., 1.);\n\tconst vec2 sideEdges = vec2(0.86602540358, 0.5);// cos(radians(30)), sin(radians(30))\n\n\tfloat dot1 = dot(v, topBottomEdge);\n\tfloat dot2 = dot(v, sideEdges);\n    float dotMax = max(dot1, dot2);\n\t\n    return dotMax - hexRadius;\n}\n\n\n// signed distance to a 2D triangle\n// thank you iq: https://www.shadertoy.com/view/XsXSz4\nfloat sdTriangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2)\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    vec2 d = min( min( vec2( dot( pq0, pq0 ), v0.x*e0.y-v0.y*e0.x ),\n                       vec2( dot( pq1, pq1 ), v1.x*e1.y-v1.y*e1.x )),\n                       vec2( dot( pq2, pq2 ), v2.x*e2.y-v2.y*e2.x ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat GridPattern(in vec2 uv)\n{\n  return 0.5*clamp(10.*sin(pi*uv.x), 0.0, 1.0)\n       / 0.5*clamp(10.*sin(pi*uv.y), 0.0, 1.0);\n}\n\nfloat HexagonalPattern(in vec2 pos)   // no AA\n{\n    float t = 1.0;\n    \n    pos.y = pos.y * 0.866 + pos.x*0.5;\n    pos = mod(pos, vec2(3.0));\n    \n    if(pos.y > 0.0      \n    && pos.x > 0.0 \n    && pos.y < pos.x+1.0 \n    && pos.y > pos.x-1.0 \n    && pos.y < 2.0 \n    && pos.x < 2.0)\n        t = 0.0;\n    else if(pos.y > 1.0 && (pos.y < pos.x || pos.x < 1.0))\n        t = 0.5;\n    \n    return t;\n}\n\nfloat depth(vec2 coord) {\n    float d1 = sdSquircle(coord, vec2(0.5,0.5+sin(iTime/4.0)*0.4), 0.24, 1.5, pi/4.0);\n    float s = 1.-sqrt(clamp(d1*60.86, 0.0, 1.0));\n    return s;\n}\nvec2 popOut(vec2 coord) {\n    vec2 c = coord;\n    for (float zf=0.0; zf<=1.0; zf+=0.01) {\n        float d = depth(c);\n        if (zf>d) break;\n        c = (coord-0.5)*(1.0-zf*0.4)+0.5;\n    }\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = popOut(uv);\n    float g = HexagonalPattern(p*16.0);\n    vec4 t = texture(iChannel0, p, depth(p)*4.0);\n    vec3 c = mix(t.rgb,vec3(0.0),g);\n    float h = sdLineSegment(p, vec2(0.2,0.2), vec2(0.8,0.2),0.1);\n    if (h <= eps) {\n        c = vec3(0.0,0.2,0.7);\n    }\n\tfragColor = vec4(c,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}