{
    "Shader": {
        "info": {
            "date": "1607426270",
            "description": "sss",
            "flags": 0,
            "hasliked": 0,
            "id": "3dKBzy",
            "likes": 4,
            "name": "uli3se1",
            "published": 3,
            "tags": [
                "sss"
            ],
            "usePreview": 0,
            "username": "uli3se",
            "viewed": 604
        },
        "renderpass": [
            {
                "code": "/*\n\"Diamond test\" by Emmanuel Keller aka Tambako - January 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n\nLamp lamps[3];\n    \nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  int objnr;\n};\n\nvec3 campos = vec3(0., 0.5, 5.);\nvec3 camdir = vec3(0., -0.1, -1.);\nfloat fov = 5.;\n\nconst vec3 ambientColor = vec3(0.7);\nconst float ambientint = 0.08;\n\n#define specular\n//#define color_disp\n//#define only_shape\n//#define show_not_finished\nconst int nb_refr = 7; \n\nconst float specint = 0.2;\nconst float specshin = 20.;\n\nconst float normdelta = 0.0004;\nconst float maxdist = 55.;\n\nconst float ior = 2.418;\nconst float ior_r = 2.408;\nconst float ior_g = 2.424;\nconst float ior_b = 2.432;\nconst vec3 diamondColor = vec3(.98, 0.95, 0.9);\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.9;\nconst int aasamples = 1;\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\n    return rv;\n}\n\nfloat map_simple(vec3 pos)\n{   \n    float angle = 2.*pi*iMouse.x/iResolution.x;\n    float angle2 = -2.*pi*iMouse.y/iResolution.y;\n    \n    vec3 posr = pos;\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle)); \n    \n    float d = 1.05;\n    float s = atan(posr.y, posr.x);\n    \n    vec3 flatvec = vec3(cos(s), sin(s), 1.444);\n    vec3 flatvec2 = vec3(cos(s), sin(s), -1.072);\n     \n    float d1 = dot(flatvec, posr) - d;                        // Crown\n    d1 = max(dot(flatvec2, posr) - d, d1);                    // Pavillon\n    d1 = max(dot(vec3(0., 0., 1.), posr) - 0.35, d1);         // Table\n    return d1;\n}\n\nfloat map(vec3 pos)\n{     \n    float angle = 2.*pi*iMouse.x/iResolution.x;\n    float angle2 = -2.*pi*iMouse.y/iResolution.y;\n    \n    vec3 posr = pos;\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle));\n    \n    float d = 0.94;\n    float b = 0.5;\n\n    float af2 = 4./pi;\n    float s = atan(posr.y, posr.x);\n    float sf = floor(s*af2 + b)/af2;\n    float sf2 = floor(s*af2)/af2;\n    \n    vec3 flatvec = vec3(cos(sf), sin(sf), 1.444);\n    vec3 flatvec2 = vec3(cos(sf), sin(sf), -1.072);\n    vec3 flatvec3 = vec3(cos(s), sin(s), 0);\n    float csf1 = cos(sf + 0.21);\n    float csf2 = cos(sf - 0.21);\n    float ssf1 = sin(sf + 0.21);\n    float ssf2 = sin(sf - 0.21);\n    vec3 flatvec4 = vec3(csf1, ssf1, -1.02);\n    vec3 flatvec5 = vec3(csf2, ssf2, -1.02);\n    vec3 flatvec6 = vec3(csf2, ssf2, 1.03);\n    vec3 flatvec7 = vec3(csf1, ssf1, 1.03);\n    vec3 flatvec8 = vec3(cos(sf2 + 0.393), sin(sf2 + 0.393), 2.21);\n     \n    float d1 = dot(flatvec, posr) - d;                           // Crown, bezel facets\n    d1 = max(dot(flatvec2, posr) - d, d1);                       // Pavillon, pavillon facets\n    d1 = max(dot(vec3(0., 0., 1.), posr) - 0.3, d1);             // Table\n    d1 = max(dot(vec3(0., 0., -1.), posr) - 0.865, d1);          // Cutlet\n    d1 = max(dot(flatvec3, posr) - 0.911, d1);                   // Girdle\n    d1 = max(dot(flatvec4, posr) - 0.9193, d1);                  // Pavillon, lower-girdle facets\n    d1 = max(dot(flatvec5, posr) - 0.9193, d1);                  // Pavillon, lower-girdle facets\n    d1 = max(dot(flatvec6, posr) - 0.912, d1);                   // Crown, upper-girdle facets\n    d1 = max(dot(flatvec7, posr) - 0.912, d1);                   // Crown, upper-girdle facets\n    d1 = max(dot(flatvec8, posr) - 1.131, d1);                   // Crown, star facets\n    return d1;\n}\n\nfloat trace(vec3 cam, vec3 ray, float maxdist, bool inside) \n{\n    float t = 4.2;\n    float dist;\n    \n    // \"Bounding\" tracing\n    if (!inside)\n    {\n  \t\tfor (int i = 0; i < 12; ++i)\n    \t{\n    \t\tvec3 pos = ray*t + cam;\n    \t\tdist = map_simple(pos);\n        \tif (dist>maxdist || abs(dist)<0.001)\n            \tbreak;\n        \tt+= dist*0.95;\n  \t\t}\n    }\n\n    // \"Actual\" tracing\n  \tfor (int i = 0; i < 30; ++i)\n    {\n    \tvec3 pos = ray*t + cam;\n    \tdist = inside?-map(pos):map(pos);\n        if (dist>maxdist)\n            break;\n        t+= dist*(inside?0.4:0.8);\n  \t}\n  \treturn t;\n}\n\n// Old slower version (but a bit more precise)\nfloat trace_sl(vec3 cam, vec3 ray, float maxdist, bool inside) \n{\n    float t = 4.;\n  \tfor (int i = 0; i < 80; ++i)\n    {\n    \tvec3 pos = ray*t + cam;\n    \tfloat dist = inside?-map(pos):map(pos);\n        if (dist>(inside?3.:maxdist) || abs(dist)<0.001 || (inside && i>30))\n            break;\n        t+= dist*0.4;\n  \t}\n  \treturn t;\n}\n\n// From https://www.shadertoy.com/view/MstGDM\nvec3 getNormal(vec3 pos, float e, bool inside)\n{\n    vec2 q = vec2(0, e);\n    return (inside?-1.:1.)*normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),\n                          map(pos + q.xyx) - map(pos - q.xyx),\n                          map(pos + q.xxy) - map(pos - q.xxy)));\n}\n\nvec3 obj_color(vec3 norm, vec3 pos)\n{\n  \t#ifdef only_shape\n  \treturn vec3(0.35, 0.7, 1.0);\n  \t#else\n    return vec3(0.);\n    #endif\n}\n\nvec3 sky_color(vec3 ray)\n{\n\tvec3 rc = texture(iChannel2, ray).rrr;\n    for (int l=0; l<3; l++)\n        rc+= 1.5*normalize(lamps[l].color)*lamps[l].intensity*specint*pow(max(0.0, dot(ray, normalize(lamps[l].position - campos))), 200.);\n    return rc;\n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = clamp(acos(-dot(ray, norm)), -pi/2.15, pi/2.15);\n   float r0 = pow((n1-n2)/(n1+n2), 2.);\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(0., 0.9, r);\n}\n\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, bool inside)\n{\n\tvec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n      \n    vec3 col;\n    \n    // Diffuse shading\n    if (!inside)\n    {\n    \tfloat diff = clamp(dot(norm, pli), 0., 1.);\n    \tcol = ocol*normalize(lamp.color)*lamp.intensity*smoothstep(0., 1.04, pow(diff, 0.78));\n    }\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.position - pos) > 0.0)\n        col+= normalize(lamp.color)*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, bool inside)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, inside);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\nRenderData trace0(vec3 tpos, vec3 ray, bool inside)\n{\n    float tx = trace(tpos, ray, maxdist, inside);\n    vec3 col;\n    int objnr;\n    \n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    if (tx<10.)\n    {\n        norm = getNormal(pos, normdelta, inside);\n        if (!inside)\n        {\n            // Coloring\n        \tcol = obj_color(norm, pos) + ambientColor*ambientint;\n        \tobjnr = 1;\n        }\n        \n        // Shading\n        col = lampsShading(norm, pos, col, inside);\n  }\n  else\n  {\n      // Sky\n      col = sky_color(ray);\n      objnr = 3;\n  }\n  return RenderData(col, pos, norm, objnr);\n}\n\nvec4 render(vec2 fragCoord, vec3 campos, float ior)\n{   \n  lamps[0] = Lamp(vec3(0., 4.5, 10.), vec3(1., 1., 1.), 5., 0.1);\n  lamps[1] = Lamp(vec3(12., -0.5, 6.), vec3(.7, .8, 1.), 5., 0.1);\n  lamps[2] = Lamp(vec3(-1.3, 0.8, -1.5), vec3(1., .95, .8), 3.5, 0.1);\n    \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  RenderData traceinf = trace0(campos, ray, false);\n  vec3 col = traceinf.col;\n    \n  #ifdef only_shape\n  \treturn vec4(col, 1.0);\n  #else\n    \n  if (traceinf.objnr==1)\n  {\n  \t\tvec3 norm = traceinf.norm;\n        vec3 ray_r = refract(ray, traceinf.norm, 1./ior);\n        vec3 ray_r2;\n      \n        int n2;\n        for (int n=0; n<nb_refr; n++)\n        {\n        \ttraceinf = trace0(traceinf.pos, ray_r, true);\n        \tcol+= traceinf.col;\n        \tcol*= diamondColor;\n      \t\tray_r2 = refract(ray_r, traceinf.norm, ior);\n        \tif (length(ray_r2)!=0.)\n            {\n           \t\tcol+= sky_color(ray_r2)*diamondColor;\n                break;\n            }\n            ray_r2 = reflect(ray_r, traceinf.norm);\n            ray_r = ray_r2;\n            n2 = n;\n        }\n        if (n2==nb_refr-1)\n            #ifdef show_not_finished\n            col = vec3(1., 0., 1.);\n      \t\t#else\n            col+= sky_color(ray_r2)*diamondColor;\n      \t\t#endif\n                      \n        // Outer reflection\n        float r = fresnel(ray, norm, ior);\n        col = mix(col, sky_color(reflect(ray, norm)), r);\n  }\n  return vec4(col, 1.0);\n  #endif\n}\n\nvec4 render_rgb(vec2 fragCoord, vec3 campos)\n{\n    #ifdef color_disp\n    \tvec4 col;\n    \tcol.r = render(fragCoord, campos, ior_r).r;\n    \tcol.g = render(fragCoord, campos, ior_g).g;\n    \tcol.b = render(fragCoord, campos, ior_b).b;\n    \tcol.a = 1.;\n\treturn col;\n    #else\n    \treturn render(fragCoord, campos, ior);\n    #endif\n}\n\nvec4 render_aa(vec2 fragCoord, vec3 campos)\n{\n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render_rgb(fragCoord + vec2(ox, oy), campos);\n       }\n    }\n    return vs/vec4(aasamples*aasamples);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n       fragColor = render_aa(fragCoord, campos);    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}