{
    "Shader": {
        "info": {
            "date": "1702275317",
            "description": "Trying to make an effect that is closer to what we see in the original trilogies. Adapted from https://www.shadertoy.com/view/MlKBWw. Soon to be added to X-Wing Alliance. Use the mouse to look around.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ctKBRK",
            "likes": 4,
            "name": "Fork Hyperspace guvacode 290",
            "published": 3,
            "tags": [
                "tunnel",
                "starfield",
                "hyperspace",
                "starwars"
            ],
            "usePreview": 0,
            "username": "guvacode",
            "viewed": 189
        },
        "renderpass": [
            {
                "code": "/*\n\tSimplified and adapted from:\n\thttps://www.shadertoy.com/view/MlKBWw\n*/\n\n#define TAU 6.28318\n\n// Uncomment the following line to get a flare in the center (Disney-style)\n#define FLARE 1\n\n// The way this shader works is by looking at the screen as if it were a disk and then\n// this disk is split into a number of slices centered at the origin. Each slice renders\n// a single trail. So this setting controls the overall density of the effect:\n#define NUM_SLICES 125.0\n//#define NUM_SLICES 50.0\n\n// Each trail is rendered within its slice; but to avoid generating regular patterns, we\n// randomly offset the trail from the center of the slice by this amount:\nconst float MAX_SLICE_OFFSET = 0.4;\n\n// This is the length of the effect in seconds:\nconst float T_MAX = 2.0;\n// T_JUMP is in normalized [0..1] time: this is the time when the \n// trails zoom out of view because we've jumped into hyperspace:\nconst float T_JUMP = 0.75;\n// This is the speed during the final jump:\nconst float jump_speed = 15.0;\n\n// I've noticed that the effect tends to have a bluish tint. In this \n// shader, the blue color is towards the start of the trail, and the \n// white color towards the end:\nconst vec3 blue_col = vec3(0.3, 0.3, 0.5);\n//const vec3 white_col = vec3(0.95, 0.95, 1.0);\nconst vec3 white_col = vec3(0.85, 0.85, 0.9);\nconst vec3 flare_col = vec3(0.9, 0.9, 1.4);\n\nfloat array_mix(in float[4] array, in int n, float index)\n{\n    float dec = fract(index);\n    int i = int(floor(index));\n    if (i >= n - 1)\n        return array[i];\n    else\n    \treturn mix(array[i], array[i+1], dec);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, in float ring )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - ring;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n/*\n\tLens flare from: https://www.shadertoy.com/view/XdfXRX\n\tand: https://www.shadertoy.com/view/4sX3Rs \n*/\nvec3 lensflare(vec3 uv, vec3 pos, float flare_size, float ang_offset)\n{\n    float z = uv.z / length(uv.xy);\n\tvec2 main = uv.xy - pos.xy;\n    float dist = length(main);\n\tfloat num_points = 2.71;\n    float disk_size = 0.2;\n    float inv_size = 1.0 / flare_size;\n\tfloat ang = atan(main.y, main.x) + ang_offset;\n    float fade = (z < 0.0) ? -z : 1.0;\n    //if (z < 0.0) return vec3(0.0);\n    \n    float f0 = 1.0/(dist * inv_size + 1.0);\n    f0 = f0 + f0 * (0.1 * sin((sin(ang*2.0 + pos.x)*4.0 - cos(ang*3.0 + pos.y)) * num_points) + disk_size);\n    if (z < 0.0)\n\t\treturn clamp(mix(vec3(f0), vec3(0.0), 0.75 * fade), 0.0, 1.0);\n    else\n        return vec3(f0);\n}\n\nvec3 cc(vec3 color, float factor, float factor2) // color modifier\n{\n\tfloat w = color.x+color.y+color.z;\n\treturn mix(color, vec3(w) * factor, w * factor2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color = vec3(0.0);\n    float time = mod(iTime, T_MAX);\n    float t = time / T_MAX;\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 mo = (2.0 * iMouse.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    p += vec2(0, -0.2); // In XWA the aiming HUD is not at the screen's center\n    \n    float ta = TAU * mod(iTime, 8.0) / 8.0;\n    //ta = 12.0 * 0.01745;\n    \n    float ay = 0.0, ax = 0.0, az = 0.0;\n    if (iMouse.z > 0.0) {\n        ay = 3.0 * mo.x;\n        ax = 3.0 * mo.y;\n    }\n    mat3 mY = mat3(\n         cos(ay), 0.0,  sin(ay),\n         0.0,     1.0,      0.0,\n        -sin(ay), 0.0,  cos(ay)\n    );\n    \n    mat3 mX = mat3(\n        1.0,      0.0,     0.0,\n        0.0,  cos(ax), sin(ax),\n        0.0, -sin(ax), cos(ax)\n    );\n    \n    /*\n    mat3 mZ = mat3(\n        cos(az), sin(az), 0.0,\n       -sin(az), cos(az), 0.0,\n            0.0,     0.0, 1.0\n    );\n    */\n    mat3 m = mX * mY;\n    //p += vec2(0.0, -0.1); // + 12.0*m;\n    //p = (mX * vec3(p, 1.0)).xy;\n    \n    float p_len = length(p);\n    vec3 v = vec3(p, 1.0);\n    v = m * v;\n    \n    // The following line reverts the effect:\n    //t = 1.0 - t;\n    // DEBUG\n    //t = 0.5;\n    // DEBUG\n    \n    //float[4] flare_size;\n    //flare_size[0] = 0.0\n    \n    float trail_start, trail_end;\n    // Fade all the trails into view from black to a little above full-white:\n    float fade = clamp(mix(0.1, 1.1, t * 2.0), 0.0, 2.0);\n    //fade = 1.0;\n    \n    // Each slice renders a single trail; but we can render multiple layers of\n    // slices to add more density and randomness to the effect:\n\tfor(float i = 0.0; i < 80.0; i++) \n    //float i = 1.0;\n    {\n        vec3 trail_color = vec3(0.0);\n\t\t//float angle = (atan(v.y, v.x) / 3.141592 / 3.0 + 0.5);\n        float angle = atan(v.y, v.x) / 3.141592 / 2.0 + 0.13 * i;\n        \n\t\tfloat slice = floor(angle * NUM_SLICES);\n        float slice_fract = fract(angle * NUM_SLICES);\n        \n        // Don't center the trail in the slice: wiggle it a little bit:\n        float slice_offset = MAX_SLICE_OFFSET * \n            rand(vec2(slice, 4.0 + i * 25.0)) - (MAX_SLICE_OFFSET / 2.0);\n        \n        \n        // Without dist, all trails get stuck to the walls of the\n        // tunnel.\n        //float dist = rand(vec2(slice, 1.0 + i * 10.0)) * (2.0 + i);\n        float dist = 10.0 * rand(vec2(slice, 1.0 + i * 10.0)) - 5.0;\n        float z = dist * v.z / length(v.xy);\n        // When dist is negative we have to invert a number of things:\n        float f = sign(dist);\n        if (f == 0.0) f = 1.0;\n        // This is the speed of the current slice\n        float fspeed = f * (0.1 * rand(vec2(slice, 1.0 + i * 10.0)) + i * 0.01);\n        float fjump_speed = f * jump_speed;\n        \n\t\t//trail_start = 5.0 + 2.0 * rand(vec2(slice, 0.0 + i * 10.0));\n        trail_start = 10.0 * rand(vec2(slice, 0.0 + i * 10.0)) - 5.0;\n        \n        // Accelerate the trail_start:\n        trail_start -= mix(0.0, fjump_speed, smoothstep(T_JUMP, 1.0, t));\n        trail_end = trail_start - t * fspeed;\n        \n        //float trail_x = smoothstep(trail_start, trail_end, p_len);\n        float trail_x = smoothstep(trail_start, trail_end, z);\n        trail_color = mix(blue_col, white_col, trail_x);\n        \n        // This line computes the distance from the current pixel, in \"slice-coordinates\"\n        // to the ideal trail centered at the slice center. The last argument makes the lines\n        // a bit thicker when they reach the edges as time progresses.\n        float h = sdLine(\n            vec2(slice_fract + slice_offset, z),\n            vec2(0.5, trail_start), \n            vec2(0.5, trail_end),\n            //0.0);\n\t       \tmix(0.0, 0.015, t * z));\n        \n        //h = smoothstep(0.075, 0.01, abs(h) - 0.05);\n        // This threshold adds a \"glow\" to the line. This glow grows with\n        // time:\n        //float threshold = mix(0.04, 0.175, smoothstep(0.0, 0.5, t));\n        float threshold = 0.09;\n        h = (h < 0.01) ? 1.0 : 0.85 * smoothstep(threshold, 0.0, abs(h));\n        \n        trail_color *= fade * h;\n        // DEBUG\n        // This part displays the size of each slice.\n        //float r = 0.0;\n        //if (trail_start <= p_len && p_len <= trail_end)\n        //    r = 1.0;\n        //trail_color = vec3(h, h, h);\n        // DEBUG\n        \n        // Accumulate this trail with the previous ones\n        color = max(color, trail_color);\n\t}\n\n#ifdef FLARE\n    // Add the disk at the center to transition into the hyperspace\n    // tunnel\n    float flare_size = mix(0.0, 0.1, smoothstep(0.35, T_JUMP + 0.2, t));\n    flare_size += mix(0.0, 20.0, smoothstep(T_JUMP + 0.05, 1.0, t));\n    vec3 flare = flare_col * lensflare(v, vec3(0.0), flare_size, t);\n    color += cc(flare, 0.5, 0.1);\n    //color += flare;\n    // Whiteout\n    color += mix(0.0, 1.0, smoothstep(T_JUMP + 0.1, 1.0, t));\n#else\n    // Whiteout\n    color += mix(0.0, 1.0, smoothstep(T_JUMP - 0.0, 1.0, t));\n#endif\n\tfragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}