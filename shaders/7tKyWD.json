{
    "Shader": {
        "info": {
            "date": "1662790897",
            "description": "My first shader game exp, just a little hardcore game about cat, bad cat and mooncat-coins; \nDifficult change at pick coins 10-30-50-70-100-150.\n[ arrows ] - moving\n[ space ] -  jump",
            "flags": 48,
            "hasliked": 0,
            "id": "7tKyWD",
            "likes": 11,
            "name": "Cat the Game",
            "published": 3,
            "tags": [
                "game",
                "cat"
            ],
            "usePreview": 0,
            "username": "deni_de",
            "viewed": 359
        },
        "renderpass": [
            {
                "code": "#define catSize 4.3\n#define NormalizeScale uv -= vec2(0.5, 0.5); uv *= catSize; uv += vec2(0.5, 0.5);\n\nvoid storeValue (in ivec2 v, in vec4 va, inout vec4 fragColor, in ivec2 fragCoord)\n{\n    fragColor = ( v.x == fragCoord.x && v.y == fragCoord.y ) ? va : fragColor;\n}\n\nvec2 uvRotate(vec2 uv, vec2 offset, float mul)\n{\n    uv -= vec2(offset.x, offset.y);\n    uv *= vec2(3.7,3.7);\n    //fake rotate\n    //uv.x /= 1.0 * sin(iTime * 2.5 * mul);\n    uv += vec2(offset.x, offset.y);\n    \n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 finaly = vec4(0.0);\n    ivec2 ifragCoord = ivec2( fragCoord-0.5 );\n    vec4 badCatUv = fetchData(iChannel1, badCatPos);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 buv = uv;\n    vec2 m = uv;\n    vec2 hudUv = uv;\n    \n    vec2 bcat = uv;\n    \n    bcat -= badCatUv.xy;\n    \n    NormalizeScale;\n    \n    vec4 pos = fetchData(iChannel1, position);\n    vec4 _jump = fetchData(iChannel1, jump);\n    float dir = fetchData(iChannel1, direction).r;\n    vec4 coinY = fetchData(iChannel1, coinsY);\n    vec4 coinX = fetchData(iChannel1, coinsX);\n    vec4 catP = fetchData(iChannel1, catPos);\n    vec4 sbcatP = fetchData(iChannel1, sbadCatPos);\n    vec4 cl = fetchData(iChannel1, CL);\n    vec4 stg = fetchData(iChannel1, stage);\n    \n    vec4 coin = vec4(0.0);\n    \n    coin += texture( iChannel3, uvRotate(m - vec2(coinX.x,coinY.x),  vec2(0.5,0.5),cl.w)) ;\n    coin += texture( iChannel3, uvRotate(m - vec2(coinX.y,coinY.y),  vec2(0.5,0.5),cl.w)) ;\n    coin += texture( iChannel3, uvRotate(m - vec2(coinX.z,coinY.z),  vec2(0.5,0.5),cl.w)) ;\n    \n    //UI Coin\n    coin += texture( iChannel3, hudUv * 9.5- vec2(-0.35, 8.32)); \n\n    vec2 shdUv = uv;\n    shdUv.y *= -1.0;\n    shdUv.x -= pos.x;\n    shdUv.xy -= vec2(.45, 1.15 + pos.y * 0.1);\n    shdUv.x *= -dir;\n    \n    vec2 catUv = uv - pos.xy; \n    catUv -= vec2(0.5,0.5);\n    catUv.x *= -dir;\n    shdUv.x += 0.2;\n    catUv += vec2(0.5,0.5);\n    \n    bcat -= vec2(0.5,0.5);\n    bcat *= 4.3;\n    bcat.x *= badCatUv.w;\n    bcat += vec2(0.5,0.5);\n    \n    vec4 cat = texture( iChannel0, catUv );\n    vec4 badCat = texture(iChannel0, bcat) * vec4(0.0,0.0,0.0,1.0);\n    vec4 badCatShadow = texture(iChannel0, bcat * vec2(1.0,-2.9) - vec2(0.,-0.8)) * vec4(0.0,0.0,0.0,0.5);\n    float eLR = circleA(bcat, vec2(0.65,0.5), 0.04);\n    eLR += circleA(bcat, vec2(0.8,0.5), 0.04);\n    badCat += eLR * vec4(1.0,0.0,0.0,1.0);\n    badCat += badCatShadow;\n    \n    \n    vec3 back = texture( iChannel2, buv ).rgb;\n\n    //add pink if danger distance\n    if(sbcatP.x >= 0.35)\n    {\n        back.rgb += vec3(0.5,0.0,0.5);\n    }\n    \n    //add red if hit damage \n    if(sbcatP.x >= 0.55)\n    {\n        back.rgb += vec3(1.0,0.0,-1.0);\n    }\n    \n    shdUv.y *= 2.9;\n    vec4 catShadow = texture( iChannel0, shdUv + vec2(0.3, -0.4) ) ;\n    \n    \n    cat.rgb = mix( catShadow.rgb * vec3(0,0,0) * back.r, cat.rgb, cat.a );\n    //Controll of shadow density \n    cat.a += catShadow.a * 0.5 ; //add jump modify to change density\n    cat.a = clamp(cat.a,0.0,1.0);\n    \n    finaly.rgb = mix(back, coin.rgb, coin.a);\n    finaly.rgb = mix(finaly.rgb, cat.rgb, cat.a);\n    finaly.rgb = mix(finaly.rgb, badCat.rgb, badCat.a);\n    \n    //UI lives \n    int count = int(cl.y);\n    \n    for(int i = 0; i < count; i++)\n    {\n        float cly = float(i);\n        \n        //HEART BLOCK------------------\n    \n        vec2 uv2 = fragCoord/iResolution.xy;\n        uv2.x *= 2.0;\n        uv2 /= 0.15;\n        uv2.x += 0.3;\n        uv2.y -= 6.18;\n        vec2 uv3 = uv2;\n        \n        uv2.x -= cly * 0.33;\n        uv3.x -= cly * 0.33;\n\n        uv2 += vec2(0.5,0.0) * uv2.y;\n        uv3 -= vec2(0.5,0.0) * uv2.y;\n\n        float hearth = clamp( circleA( uv2, vec2(0.60,0.29),0.1)\n                        + circleA( uv3, vec2(0.40,0.29),0.1), 0.0, 1.0);\n                        \n        //HEART BLOCK-------------------\n        \n        finaly += hearth * vec4(1.0,0.2,0.0,hearth);\n    }\n    \n    if(stg.z == 0.0)\n    {\n        vec4 _coin =  texture( iChannel3, hudUv * 2.5- vec2(0.5, 1.57));\n        finaly.rgb = mix(back.rgb, _coin.xyz * _coin.w, _coin.w)  ;\n    }\n    \n        \n    fragColor = clamp(vec4( vec3(finaly), 1.0), 0.0, 1.0);\n        \n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 loadValue (in ivec2 v)\n{\n    return texelFetch( iChannel0, v, 0);\n}\n\nvoid saveValue (in ivec2 v, in vec4 va, inout vec4 fragColor, in ivec2 fragCoord)\n{\n    fragColor = ( v.x == fragCoord.x && v.y == fragCoord.y ) ? va : fragColor;\n}\n\nvoid difficult (float score, inout float multiple, inout float stage, inout float uitime)\n{\n    \n    if(score == 10.)\n    {\n        multiple = 1.0;\n        stage += 1.0;\n        uitime = 1.5;\n    }\n    else if(score == 30.)\n    {\n        multiple = 1.5;\n        stage += 1.0;\n        uitime = 1.5;\n    }\n    else if(score == 50.)\n    {\n        multiple = 2.0;\n        stage += 1.0;\n        uitime = 1.5;\n    }\n    else if(score == 70.)\n    {\n        multiple = 2.5;\n        stage += 1.0;\n        uitime = 1.5;\n    }\n    else if(score == 100.)\n    {\n        multiple = 2.9;\n        stage += 1.0;\n        uitime = 1.5;\n    }\n    else if(score == 150.)\n    {\n        multiple = 3.5;\n        stage += 1.0;\n        uitime = 1.5;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    bool  E = texelFetch(iChannel1, ivec2(KEY_ENTER, 0.), 0).x  > 0.0 ?  true : false;\n    bool  S = texelFetch(iChannel1, ivec2(KEY_SPACE, 0.), 0).x  > 0.0 ?  true : false;\n    float L = texelFetch(iChannel1, ivec2(KEY_LEFT,  0.), 0).x  > 0.0 ?  1.0 : 0.0;\n    float R = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0.), 0).x  > 0.0 ? -1.0 : 0.0;\n    \n    //Start Data\n   \n    vec3 catColorRandom = vec3( 0.1 + random(uv,iTime * iDate.z), 0.1 + random(uv,iTime + iDate.z), 0.1 + random(uv,iTime * iDate.w) );\n\n    if (storeData(fragCoord, position))\n        fragColor = vec4(0.0, 0.25, 0.0, 0.0 );\n    if (storeData(fragCoord, jump))\n        fragColor = vec4(1.0, 0.0, 1.0, 0.0 );\n    if (storeData(fragCoord, direction))\n        fragColor = vec4(-1.0, 0.0, 0.0, 0.0 );\n    if (storeData(fragCoord, coinsX))\n        fragColor = vec4(-0.37, 0.0, 0.37, 0.0 );\n    if (storeData(fragCoord, coinsY))\n        fragColor = vec4(1.5, 1.0, 1.5, 0.0 );\n    if (storeData(fragCoord, CL))\n        fragColor = vec4(0.0, 9.0, 1.0, 1.0 );\n    if (storeData(fragCoord, catColor))\n        fragColor = vec4(catColorRandom, 0.0);\n    if (storeData(fragCoord, stage))\n        fragColor = vec4(48, 1.5, 1.0, 0.0);\n    \n    ivec2 ifragCoord = ivec2( fragCoord-0.5 );\n    vec4 pos = loadValue(position);\n    vec4 _jump = loadValue(jump);\n    vec4 dir = loadValue(direction);\n    vec4 coinY = loadValue(coinsY);\n    vec4 coinX = loadValue(coinsX);\n    vec4 bCatPos = loadValue(badCatPos); \n    vec4 sbCatPos = loadValue(sbadCatPos);\n    vec4 cl = loadValue(CL);\n    vec4 ccr = loadValue(catColor);\n    vec4 stg = loadValue(stage);\n    \n    if (iFrame > 0)  \n    {\n       if(stg.z == 2.0)\n       {\n           //Pasuse stage\n       }\n       else if(stg.z == 1.0)\n       {\n//CHARACTER SECTION--------------------------------\n\n            if( L > 0. && R == 0. || L == 0. && R < 0. )\n            {\n                pos.x -= (L + R) * speed;\n                dir.x = L + R;\n            }\n\n//----------------jump-----------------------------\n\n            if( S && _jump.x == 0.0)\n            {\n                _jump.x = 1.0;\n                _jump.y = jumpheight;\n                // add jump iteration\n                _jump.z = 1.0;\n            }\n\n            pos.y += _jump.y;\n\n            // wasting jump energy\n            if(_jump.x > 0.0)\n            {\n                _jump.y -= 0.005;\n            }\n\n            // emulate floor\n            pos.y = clamp(pos.y, border.x, 1.0);\n\n            // reset jump state\n            if(pos.y == border.x)\n            {\n                if(_jump.z > 0.0)\n                {\n                    _jump.z -= 1.0;\n                    _jump.y = jumpheight/3.0;\n                }\n                else\n                {\n                    _jump.x = 0.0;\n                }\n            }\n\n            pos.x = clamp(pos.x, -1.8, 1.8);\n\n//MOONCATCOINS SECTION--------------------------------\n\n            coinY.xyz -= 0.015 * cl.w;\n\n            if(coinY.x < -0.35)\n            {\n                coinY.x += 2.0;\n            }\n            if(coinY.y < -0.35)\n            {\n                coinY.y += 2.0;\n            }\n            if(coinY.z < -0.35)\n            {\n                coinY.z += 2.0;\n            }\n\n            sbCatPos.y = 1.-distance(pos.xy,vec2(coinX.y,coinY.y) * 4.3);\n\n            if(sbCatPos.y >= 0.5)\n            {\n\n                coinY.y = 1.0;\n                cl.x += 1.0;\n                difficult( cl.x, cl.w, stg.x, stg.y);\n            }\n\n            sbCatPos.z = 1.-distance(pos.xy,vec2(coinX.x,coinY.x) * 4.3);\n\n            if(sbCatPos.z >= 0.5)\n            {\n                coinY.x = 1.0;\n                cl.x += 1.0;\n                difficult( cl.x, cl.w, stg.x, stg.y);\n            }\n\n            sbCatPos.w = 1.-distance(pos.xy,vec2(coinX.z,coinY.z) * 4.3);\n\n            if(sbCatPos.w >= 0.5)\n            {\n                coinY.z = 1.0;\n                cl.x += 1.0;\n                difficult( cl.x, cl.w, stg.x, stg.y);\n            }\n\n            coinX.xyz += (L + R) * speed * 0.15;\n\n            coinX.x = clamp(coinX.x, -0.37-0.3, -0.37+0.25);\n            coinX.y = clamp(coinX.y, 0.0-0.3, 0.0+0.25);\n            coinX.z = clamp(coinX.z, 0.37-0.3, 0.37+0.25);\n\n// STAGE -----------------------------------------\n            if(stg.y > 0.0)\n                stg.y -= 0.01;\n\n// BAD CAT SECTION--------------------------------\n            bCatPos.xy = vec2(-0.35,-0.35) + vec2(2. * sin(iTime + 4.0) * .5 *  cl.w, 0.0);\n            vec2 zbCatPos = bCatPos.xy * 4.3;\n\n            //badCatDirection\n            bCatPos.w = sin(iTime) > 0. ? 1.0 : -1.0;\n\n            //distance to character\n            sbCatPos.x = 1.- distance(pos.xy, zbCatPos.xy) ;\n\n            if(sbCatPos.x >= 0.6)\n            {\n                //reset pos\n                pos.x = 0.0; \n                pos.y = 0.0;\n\n                //minus life\n                cl.y -= 1.0;\n\n                //resetcoins pos\n                coinX.x = -0.37;\n                coinX.y = 0.0;\n                coinX.z = 0.37;\n\n                //reset game is hp left\n                if(cl.y <= 0.)\n                {\n                    \n                    //\n                    cl.w = 1.;\n\n                    //start stage _1 and alphatext\n                    stg.x = 48.;\n                    stg.y = 1.5;\n\n                    //game over\n                    stg.z = 0.0;\n\n                    ccr.xyz = vec3( 0.1 + random(uv, fract(iTime)), 0.1 + random(uv, fract(iDate.w)), 0.1 + random(uv, fract(iDate.z)) );\n                }\n\n\n            }\n       }\n       //Restart\n       else if(stg.z == 0.0)\n       {\n           if( E )\n           {\n               //game Stage\n               stg.z = 1.0;\n               //coins\n               cl.x = 0.;\n               //lives\n               cl.y = 9.;\n           }\n       }\n\n        \n        saveValue( position,    vec4(pos),      fragColor,    ifragCoord );\n        saveValue( jump,        vec4(_jump),    fragColor,    ifragCoord );\n        saveValue( direction,   vec4(dir),      fragColor,    ifragCoord );\n        saveValue( coinsY,      vec4(coinY),    fragColor,    ifragCoord );\n        saveValue( coinsX,      vec4(coinX),    fragColor,    ifragCoord );\n        saveValue( badCatPos,   vec4(bCatPos),  fragColor,    ifragCoord );\n        saveValue( sbadCatPos,  vec4(sbCatPos), fragColor,    ifragCoord );\n        saveValue( CL,          vec4(cl),       fragColor,    ifragCoord );\n        saveValue( catColor,    vec4(ccr),      fragColor,    ifragCoord );\n        saveValue( stage,       vec4(stg),      fragColor,    ifragCoord );\n        \n        \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define _speed 21.0\n#define cellAmount 6.0\n\nvec4 cat(vec2 uv)\n{\n    vec2 pos = fetchData(iChannel1, position).rg;\n    vec2 _jump = fetchData(iChannel1, jump).rg;\n    \n    \n    float cSpeed = 0.01 + (pos.x + _jump.y) * 10.0;\n    \n    uv.x = uv.x * 40.0 / 256.0;\n    float cellPercentage = 1.0 / cellAmount;\n    float frame = floor( mod( cSpeed, cellAmount ) );\n    uv.x += frame * 40. / 256.;\n    \n    return texture( iChannel0, uv ).rgba;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = fetchData(iChannel1, catColor).rgb;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 _cat = cat( uv );    \n    _cat.rgb  = _cat.rgb == vec3(0.6) ? color : _cat.rgb;\n    fragColor = vec4( _cat.rgb * _cat.w, _cat.w );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//thx: iq, Bl00dhound, xrx, FabriceNeyret2 for examples and more\n\n//STORE ADDRESS\nconst ivec2 position   = ivec2(21.0, 1.0);\nconst ivec2 jump       = ivec2(21.0, 2.0);\nconst ivec2 direction  = ivec2(21.0, 3.0);\nconst ivec2 coinsY     = ivec2(69.,21.);\nconst ivec2 coinsX     = ivec2(69.,22.);\nconst ivec2 catPos     = ivec2(69.,23.);\nconst ivec2 badCatPos  = ivec2(69., 29.);\nconst ivec2 sbadCatPos = ivec2(69., 30.);\nconst ivec2 CL         = ivec2(69., 31.);\nconst ivec2 catColor   = ivec2(69.,32.);\nconst ivec2 stage      = ivec2(69.,33.);\n\nconst int KEY_SPACE  = 32;\nconst int KEY_LEFT   = 37;\nconst int KEY_UP     = 38;\nconst int KEY_RIGHT  = 39;\nconst int KEY_DOWN   = 40;\nconst int KEY_ENTER  = 13;\n\nfloat circleA(vec2 uv, vec2 pos, float size)\n{\n    float c = length(uv - pos);\n    c = step(size,c);\n    return 1. - c;\n}\n\n//1D random\nfloat random (vec2 xy, float t) \n{\n    return fract( sin( (xy.x * xy.y + t) * 1534345.1234645) );\n}\n\n//DATA\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeData(buf_pos, addr) ivec2(buf_pos) == addr\n\n//PROPS\n#define radius 0.05\n#define jumpheight 0.1\n#define speed  0.05\n#define border vec2(-1.48+radius,1.0 - radius)\n\n//TEXT STUFF\n#define _0 48\n#define _1 49\n#define _2 50\n#define _3 51\n#define _4 52\n#define _5 53\n#define _6 54\n#define _7 55\n#define _8 56\n#define _9 57\n\n//FOR Z MOVEMENT\n    //float U = texelFetch(iChannel1, ivec2(KEY_UP,    0.),0).x  > 0.?  1.0 : 0.0;\n    //float D = texelFetch(iChannel1, ivec2(KEY_DOWN,  0.),0).x  > 0.? -1.0 : 0.0;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "int[] textScore = int[] (_0,_0,_0);\nint[] textStage = int[] (83,84,65, 71, 69, 32, 1);\nint[] textOver = int[] (71,65,77, 69, 32, 79, 86,69,82);\n\nint[] textRestart = int[] (80, 82, 69, 83, 83, 32, \n                            69, 78, 84, 69, 82, 32,\n                                84, 79, 32,\n                            83, 84, 65, 82, 84);\n\nint tSize = 3;\nint tStageSize = 7;\nint tOver = 9;\nint tRestart = 20;\n\nvec4 char(vec2 p, int c) \n{\n  if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n  return textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nfloat prc(float a, float b)\n{\n    return  a - (b * floor(a/b));\n}\n\n//Background\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fetchData(iChannel0, position).rg;\n    vec3 _jump = fetchData(iChannel0, jump).rgb;\n    vec2 cl = fetchData(iChannel0, CL).xy;\n    vec4 stg = fetchData(iChannel0, stage);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 _uv = fragCoord/iResolution.y;\n    vec2 uvs = uv;\n    float xvalue = uv.x + pos.x / 77.; \n    vec2 uvCells = ceil((vec2(xvalue,uv.y))  * vec2(25.,25.));\n    vec2 uvStars = uv;\n    vec2 uvFloor = uv;\n    vec3 gradient = mix( vec3(1.3,0.2,0.9) / 7., vec3(0.6,0.2,1.0) * 0.001, uv.y);\n    \n    //stage up\n    textStage[6] += int(stg.x);\n    \n    //aprox score\n    float n1 = prc(cl.x, 10.);\n    float n2 = prc(cl.x / 10., 10.);\n    float n3 = cl.x / 100.;\n    \n    textScore[0] += int(n3);\n    textScore[1] += int(n2);\n    textScore[2] += int(n1);\n    //aprox end------------\n    \n    uv.x += pos.x / 9.0;\n    \n    uvStars.x += pos.x / 190.0;\n    \n    uvFloor.x = uvFloor.x * 0.01 * ( (uvFloor.y * 90.3 + 0.9) ) ;\n    uvFloor.x += pos.x / 96.0;\n    _uv.x += pos.x / 96.0;\n    uvs.x += pos.x / 96. ;\n    \n    //houses\n    vec2 houses = uvCells *  sin(uvCells + cos(uvCells));\n    houses.y = clamp(houses.y, 0.0, 1.0);\n                \n    float house = clamp(houses.x  * step( 0.19, uvFloor.y ) * step(0.3, 1.0 - uvFloor.y), 0.0, 1.0) ;\n        \n    vec4 stars = pow(texture(iChannel1, uvStars * vec2(1.2, 1.5) + iTime * 0.001), vec4(7.5));\n    \n    vec2 cellsTex = pow(   uvCells / 44.  , vec2(12.0 )) * 3.0;\n    \n    float circle = 1. - smoothstep( 0.15, 0.21, length( _uv * 1.5 - vec2(1.7, 1.1 ) ));\n    \n    //Windows\n    float windowsmask = texture(iChannel3, ceil((uvs + vec2(0.1,0.0))  * 40.) / 40. ).r;\n    vec3 windows = windowsmask > 0.5 ?  vec3(windowsmask) : vec3(0.0) ; //nice random //0.1 + 0.8 * cos(123123.1312 + uvW.xyx * uvW.x * uvW.yyy + vec3(1.,2.,3.) );\n    \n    //floor\n    vec3 _floor = vec3(0.8, 0.9, 1.0) * clamp(1. - step( 0.19, uvFloor.y ),0.0,1.0);\n    vec4 stones = texture(iChannel2, uvFloor * 2.1 + vec2(0.05,0.0) );\n    \n    //application\n    vec3 color = mix(gradient, gradient + _floor * stones.b / 2.0, _floor);\n    color = mix(color, vec3(0.6,0.2,1.0) * 0.03 * house + cellsTex.r * vec3(1.0,0.8,0.0), house);\n    color += vec3(0.6,0.9,1.1) * (stars.r * stars.b * 5.) * clamp(uv.y - 0.1 ,0.0,1.0) * (1. - house);\n    color = mix(color, circle * vec3(1.19,0.9,1.3), clamp(circle - house ,0. ,1.));\n    color += (vec3(1.0,0.5,0.0) * 1.5 * windows.r * house) * clamp(uv.y - 0.1 ,0.0,1.0);\n    \n    //TEXT SCORE BLOCK-------------------------------------\n    vec4 tcolor = vec4(0.0);\n    vec2 _UV = fragCoord / iResolution.y;\n    vec2 position = vec2(.5);\n    \n    \n    \n    float FontSize;// = 3.;\n    float strSz;//= ((float(tSize)*1.0)/FontSize);\n    vec2 uv_;//( _UV - position)*64.0/FontSize;\n    \n    \n    if(stg.z == 1.0)\n    {\n        if(stg.y > 0.0)\n        {\n            //STAGE TEXT\n            FontSize = 14.;\n            strSz = ((float(tStageSize)*1.0)/FontSize);\n            position = vec2(0.35, 0.4);\n            uv_ = ( _UV - position)*64.0/FontSize;\n\n            for (int i=0; i<tStageSize; i++) \n            {\n                int tx = textStage[i];\n                uv_.x -=.5;\n                uv_.y += sin(float(i) * 5.5 - iTime * 7.5) * 0.15;\n                vec4 tc = char(uv_.xy,tx);\n                tcolor += tc * stg.y;\n            }\n        }\n        \n        //SCORE POS IN GAME\n        position = vec2(.5);\n        position.x = 0.03;\n        position.y -= -0.397;\n        FontSize = 3.;\n        strSz = ((float(tSize)*1.0)/FontSize);\n        uv_ = ( _UV - position)*64.0/FontSize;\n    }\n    else if( stg.z == 0.0)\n    {\n        //GAME OVER\n        FontSize = 14.;\n        strSz = ((float(tStageSize)*1.0)/FontSize);\n        position = vec2(0.2, 0.4);\n        uv_ = ( _UV - position)*64.0/FontSize;\n        \n        for (int i=0; i<tOver; i++) \n        {\n            int tx = textOver[i];\n            uv_.x -=.5;\n            uv_.y += sin(float(i) * 2.5 - iTime * 7.5) * 0.15;\n            vec4 tc = char(uv_.xy,tx);\n            color = vec3(0.0,0.0,0.0);\n            tcolor += tc * stg.y;\n        }\n        //PRESS SPACE TO START\n        FontSize = 7.;\n        strSz = ((float(tStageSize)*1.0)/FontSize);\n        position = vec2(0.23, 0.2);\n        uv_ = ( _UV - position)*64.0/FontSize;\n        \n        for (int i=0; i<tRestart; i++) \n        {\n            int tx = textRestart[i];\n            uv_.x -=.5;\n            vec4 tc = char(uv_.xy,tx);\n            color = vec3(0.0,0.0,0.0);\n            tcolor += tc * stg.y;\n        }\n        \n        FontSize = 14.;\n        position = vec2(0.5);\n        position += vec2(.2, .2);\n        strSz = ((float(tSize)*1.0)/FontSize);\n        uv_ = ( _UV - position)*64.0/FontSize;\n    }\n    \n    //SCORE COMBINE\n    \n    for (int i=0; i<tSize; i++) \n    {\n        int tx = textScore[i];\n        uv_.x -=.5; \n        tcolor += char(uv_.xy,tx);\n    }\n    \n    \n    \n    //add all text to background\n    color += tcolor.r;\n    //TEXTS SCORE BLOCK--------------------------------------\n    fragColor = vec4( vec3( color ), 1.0 ) ;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//MOONCATCOIN\nfloat circle(vec2 uv, vec2 pos, float b)\n{\n    uv.y *= 0.93;\n    return step(b, 1. - length(uv  - pos));\n}\n\nfloat circleS(vec2 uv, vec2 pos)\n{\n    float c = circle(uv,pos, 0.89);\n    float s = step(.88, 1. - length(uv - pos));\n    return s - c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mainUv = fragCoord / iResolution.xy;\n    vec4 coinY = fetchData(iChannel1, coinsY);\n    \n    vec2 uv = fragCoord / iResolution.x;\n    float spc = clamp(sin((mainUv.x * (mainUv.y * 25.)) + iTime * 5.5),0.0,1.0);\n    float ci1 = circle(uv, vec2(0.5,0.25), 0.9);\n    float ci2 = circleS(uv, vec2(0.5,0.25));\n    vec3 c = vec3(0.7,0.5,0.8) * ci1;\n    vec3 cc = vec3(0.7,0.5,0.8) * ci2 - circle(uv, vec2(0.5,0.25),0.9);\n    mainUv *= vec2(2.1,2.1);\n    vec4 cat = texture(iChannel0,vec2(mainUv.x/6.0 - 0.07, mainUv.y - 0.44));\n    \n    float pxMask = 0.0;\n    if(cat.rgb == vec3(0.0) && cat.w > 0.0)\n        pxMask = 1.0;\n    else\n        pxMask = 0.0;\n    \n    \n    vec3 catcoin = c * (cat.r * 1.5) + clamp(cc,0.,1.) + vec3(0.21,0.21,0.21) * pxMask * ci1 ;\n    \n    float mask = clamp(pow((catcoin.r + catcoin.g + catcoin.b ) * 25. /3., 25.),0.0,1.0);\n    \n    fragColor = vec4(catcoin + catcoin * (vec3(1.0,0.0,2.0) * spc * 0.7) + (vec3(0.0,2.0,1.0) * spc * 0.05), mask);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}