{
    "Shader": {
        "info": {
            "date": "1575808904",
            "description": "\"Refracted brutalism\" result of a 2.5h improv live coding session on Twitch\nMAJOR THANKX go to: LJ, Crundle and Alkama for the hive mind and help with schlick-fresneled refracted reflections and size coded shadows.\nhttps://www.twitch.tv/evvvvil_",
            "flags": 0,
            "hasliked": 0,
            "id": "wt33RN",
            "likes": 71,
            "name": "[TWITCH] Refracted brutalism",
            "published": 3,
            "tags": [
                "clouds",
                "refraction",
                "demoscene",
                "light",
                "shadows",
                "reflections",
                "fresnel",
                "point",
                "architecture",
                "brutalism",
                "twitch",
                "improv",
                "brutalist"
            ],
            "usePreview": 1,
            "username": "evvvvil",
            "viewed": 2571
        },
        "renderpass": [
            {
                "code": "// \"Refracted brutalism\" - Result of a 2.5h improv live coding session on Twitch\n\n// MAJOR THANKX go to: LJ, Crundle and Alkama for the hive mind and\n// help with schlick-fresneled refracted reflections and size coded shadows\n\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\n// https://www.twitch.tv/evvvvil_\n\n// \"How you expect to run with wolves come night, when you spend all day sparring with puppies.\" Omar - The Wire\n\nvec2 z,v,e=vec2(0.01,0);float t,tt;vec3 np,bp,no,po,ld,al; //global variables\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);} //box primitive\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} //2d rotate function\nvec2 fb( vec3 p )// base geometry piece function\n{  \n  vec2 h,t=vec2(bo(p,vec3(2,5,2)),5); //basic raymarching modelling with primitives and material id\n  t.x=max(t.x,-bo(p,vec3(1.5,15,1.5))); //removing from blue box\n  t.x=min(t.x,bo(p,vec3(15,0.3,0.3))); //adding box to blue box\n  t.x=min(t.x,bo(p,vec3(0.4,15,0.4))); //adding more box to blue box\n  h=vec2(length(p.xz)-8.,3); // black structural cylinder\n  h.x=max(h.x,-(length(p.xz)-6.)); //remove from black cylinder\n  h.x=max(h.x,bo(p,vec3(15,0.5,15))); //intersection cut of black cylinder into flat cross\n  t=t.x<h.x?t:h; //merging blue and black materials\n  h=vec2(length(p.xz)-7.5,6); //white structural cylinder \n  h.x=max(h.x,-(length(p.xz)-6.5)); //removing from white cylinder\n  h.x=max(h.x,bo(p,vec3(15,0.8,15))); //intersection white cylinder into flat cross\n  h.x=min(h.x,bo(p,vec3(0.2,15,0.6))); //adding big white edges to blue. BRUTALISM MEANS BRUTALISM\n  t=t.x<h.x?t:h; //merge blue and black with white material\n  return t;\n}\nvec2 mp( vec3 p )\n{\n  p.xy*=r2(sin(1.57+p.z*.2)*.1); //overall wave\n  np=p; //setup new postion\n  np.z=mod(np.z+tt*2.,30.)-15.; //make it infiniote along z axis\n  for(int i=0;i<6;i++){ //basic kaleidoscopic function\n    np=abs(np)-vec3(8.5,0.0,4.5); //push geom out each iteration with symatery abs creating more geometry\n    np.xz*=r2(.785); //90 degree rotate each iteration\n  }  \n  vec2 h,t=fb(np); //make complex network based on simple basic geometry piece function by passing in the new more complex position np\n  bp=np+vec3(0,-12,0); bp.xy*=r2(1.57);  //derive new position 2 bp out of first new position np\n  h=fb(abs(bp*.5)-vec3(4,7.5,0)); //make more complex geom based on simple basic piece function by passing another new position 2 bp\n  h.x*=2.; t=t.x<h.x?t:h; //adapt size and merge both complex networks of geometry\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd,float _max,int iter ) //main trace  / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(.1); //0.1 is near plane\n  for(int i=0;i<iter;i++){ //march for iter amount of iterations\n    h=mp(ro+rd*t.x); //get distance to geom\n    if(h.x<.0001||t.x>_max) break; //conditional break we hit something or gone too far\n    t.x+=h.x;t.y=h.y; //huge step forward and remember material id\n  }\n  if(t.x>_max) t.y=0.;//if we hit far plane return material id = 0, we will use it later to check if we hit something\n  return t;\n}\n// Rough shadertoy approximation of the bonzomatic noise texture by yx - https://www.shadertoy.com/view/tdlXW4\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5;\n    f+=texture(iChannel0,uv*.25).r*.25;f+=texture(iChannel0,uv*.5).r*.125;\n    f+=texture(iChannel0,uv*1.).r*.125;f=pow(f,1.2);return vec4(f*.45+.05);\n}// We miss you on Twitch Luna... Sending some love.\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs\n  tt=mod(iTime,59.66)+4.72; //modulo time to avoid glitchy artifact and also nicely reset camera / scene\n  vec3 lp=vec3(3.+cos(tt*.2)*10.,6.+sin(tt*.4)*0.5,-10), //light position\n  ro=lp*mix(vec3(1),vec3(-1,2.2,1),ceil(cos(tt))), // ray origin = camera position\n  cw=normalize(vec3(sin(tt*.4)*2.,cos(tt*.2)*10.,0)-ro), //camera forward vector\n  cu=normalize(cross(cw,vec3(0,1,0))), //camera left vector ?\n  cv=normalize(cross(cu,cw)), //camera up vector ?\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo; //ray direction \n  lp+=vec3(0,5.+sin(tt)*.5,5); // light position offset animation\n  v=vec2(abs(atan(rd.x,rd.z)),rd.y); //polar uv for pseudo clouds\n  co=fo=clamp(vec3(.1)+(1.-length(uv))+0.5*texNoise(v).r,0.,1.); // background with pseudo clouds made from noise\n  z=tr(ro,rd,50.,128);t=z.x; // let's trace and get result\n  if(z.y>0.){ // we hit something \n    po=ro+rd*t; // get position where we hit\n    ld=normalize(lp-po); //get light direction from light pos\n    no=normalize(mp(po).x-vec3(mp(po-e.xyy).x,mp(po-e.yxy).x,mp(po-e.yyx).x)); //LJ's \"fit in da pocket\" normals calculation \n    float line=ceil(cos(np.x*2.1))-ceil(cos(np.x*2.1+.1)); // lines on blue geometry\n    al=clamp(line+mix(vec3(0.0,.3,.7),vec3(.1,.5,.7),sin(1.57+np)*.5+.5),0.,1.); //blue geomtry albedo colour: subtle gradient with lines\n    if(z.y<5.) al=vec3(0); if(z.y>5.) al=vec3(1); //material id < 5 -> black; material id > 5 -> white \n    float dif=max(0.,dot(no,ld)), // diffuse lighting\n    fr=pow(1.-abs(dot(rd,no)),4.), // Get schlick fresnel for reflections before we refract. Major thankx to LJ for this\n    spo=exp2(15.*texNoise(0.3*vec2(.05,.1)*vec2(np.x,dot(np.yz,vec2(.5)))).r), // Gloss specular map made from noise\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),spo), //Specular lighting\n    ldd=length(lp-po), attn=1.0-pow(min(1.0,ldd/15.),4.0); //point light attenuation\n    attn*=ldd>tr(po,ld,min(15.,ldd),50).x?.5:1.; // Size coded shadows. Major thankx to crundle and alkama for this\n    co=(sp+al*(a(.05)*a(1.))*(dif+s(.1)))*attn; // mix all lighting into final lighting result\n    if(z.y==5.){ //REFLECTIONS If we hit material ID of 5 (blue geometry)\n      rd=refract(rd,-no,1.+(spo*.002-.05)); // Gloss specular map reused to refract ray for the reflections \n      z=tr(po+rd*0.01,rd,50.,80); //Shoot ray again from surface to refracted reflected ray - Major thankx to shane for +rd*0.01 offset\n      po=po+rd*z.x; ld=normalize(lp-po); // get reflection pos we hit and light direction\n      no=normalize(mp(po).x-vec3(mp(po-e.xyy).x,mp(po-e.yxy).x,mp(po-e.yyx).x)); //LJ's \"fit in da pocket\" normals calculation      \n      al=mix(vec3(0.0,.3,.7),vec3(.1,.5,.7),sin(1.57+np)*.5+.5);//reflected albedo is more simple without lines to simplify & optimize\n      attn=1.0-pow(min(1.0,ldd/20.),4.0);//attenuate reflections lighting bit less than before to fake ambient lighting reflections\n      if(z.y<5.) al=vec3(0); if(z.y>5.) al=vec3(1); //material id < 5 -> black; material id > 5 -> white \n      float dif=max(0.,dot(no,ld));//naive reflections lighting. Just diffuse*albedo. No ao, no sss, no specular to optmize & make reflections more homogenous\n      co+=dif*al*fr*attn;// add reflections lighting to final colour with schlick fresneled and gloss map refractions (line 86-87)\n    }    \n  }\n  co=mix(fo,co,exp(-.00003*t*t*t)); // fog\n  fragColor = vec4( pow(co,vec3(.45)),1); // naive gamma correction\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}