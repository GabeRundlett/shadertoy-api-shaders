{
    "Shader": {
        "info": {
            "date": "1704920407",
            "description": "This is my first working Next Event Estimation Path Tracer",
            "flags": 32,
            "hasliked": 0,
            "id": "lffXRH",
            "likes": 2,
            "name": "My First NEE Path Tracer",
            "published": 3,
            "tags": [
                "light",
                "globalillumination",
                "nee",
                "transport"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 107
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb, 1.0);\n\n    fragColor.rgb *= 1.0;\n\n    fragColor.rgb = tanh(fragColor.rgb);\n\n    fragColor.rgb = pow(max(fragColor.rgb,0.),vec3(1./2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// PI\n#define     PI 3.1415926535897932384626433832795028841971693993751058209749445923\n#define INV_PI 0.3183098861837906715377675267450287240689192914809128974953346881\n\n// 2 * PI\n#define     TAU 6.2831853071795864769252867665590057683943387987502116419498891846\n#define INV_TAU 0.1591549430918953357688837633725143620344596457404564487476673441\n\n#define     UNIT_SPHERE_SURFACE_AREA 12.5663706143591729538505735331180115367886775975004232838997783692\n#define INV_UNIT_SPHERE_SURFACE_AREA  0.0795774715459476678844418816862571810172298228702282243738336720\n\n// https://github.com/loicvdb/VDB-frags/blob/main/Include/Color-Management.frag\nconst mat3 linear2acescg = mat3( 0.613117812906440, 0.069934082307513, 0.020462992637737, 0.341181995855625, 0.918103037508582, 0.106768663382511, 0.045787344282337, 0.011932775530201, 0.872715910619442);\nconst mat3 acescg2linear = mat3( 1.704887331049501,-0.129520935348888,-0.024127059936902,-0.624157274479026, 1.138399326040076,-0.124620612286390,-0.080886773895704,-0.008779241755018, 1.148822109913262);\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec4 pcg4d(uvec4 v) {\n    v = 0x0019660Du * v + 0x3C6EF35Fu;\n\n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n\n    return v;\n}\n\nfloat urand1(inout uvec4 v) {\n    v = pcg4d(v);\n    return float(v.x) / float(~0u);\n}\n\nvec2 urand2(inout uvec4 v) {\n    v = pcg4d(v);\n    return vec2(v.xy) / float(~0u);\n}\n\nvec3 urand3(inout uvec4 v) {\n    v = pcg4d(v);\n    return vec3(v.xyz) / float(~0u);\n}\n\nvec4 urand4(inout uvec4 v) {\n    v = pcg4d(v);\n    return vec4(v) / float(~0u);\n}\n\nvec2 nrand2(float sigma, vec2 mean, inout uvec4 ns) {\n    vec2 Z = urand2(ns);\n    return mean + sigma * sqrt(-2.0*log(Z.x   )) * vec2(cos(TAU * Z.y), sin(TAU * Z.y));\n}\n\nvec3 nrand3(float sigma, vec3 mean, inout uvec4 ns) {\n    vec4 Z = urand4(ns);\n    return mean + sigma * sqrt(-2.0*log(Z.xxy )) * vec3(cos(TAU * Z.z), sin(TAU * Z.z),cos(TAU * Z.w));\n}\n\nvec4 nrand4(float sigma, vec4 mean, inout uvec4 ns) {\n    vec4 Z = urand4(ns);\n    return mean + sigma * sqrt(-2.0*log(Z.xxyy)) * vec4(cos(TAU * Z.z), sin(TAU * Z.z),cos(TAU * Z.w),sin(TAU * Z.w));\n}\n\nvec3 udir3(inout uvec4 ns) {\n    vec2 rng = urand2(ns);\n    vec2 r = vec2(TAU*rng.x, acos(2.0*rng.y-1.0));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define MAX_DEPTH 6\n\nvec2 sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra) {\n    vec3 oc = ro - ce;\n    float b = dot(oc,rd);\n    vec3 qc = oc - b*rd;\n    float h = ra*ra - dot(qc,qc);\n    if(h < 0.0) return vec2(-1.0); // no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h);\n}\n\n/* */\n// https://iquilezles.org/articles/mandelbulb\nfloat mandelbulb( in vec3 p, out vec4 resColor )\n{\n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.0;\n\n\tfor(int i = 0; i < 4; i++)\n    {\n#if 0\n        // polynomial version (no trigonometrics, but MUCH slower)\n        float m2 = m*m;\n        float m4 = m2*m2;\n\t\tdz = 8.0*sqrt(m4*m2*m)*dz + 1.0;\n\n        float x = w.x; float x2 = x*x; float x4 = x2*x2;\n        float y = w.y; float y2 = y*y; float y4 = y2*y2;\n        float z = w.z; float z2 = z*z; float z4 = z2*z2;\n\n        float k3 = x2 + z2;\n        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;\n        float k4 = x2 - y2 + z2;\n\n        w.x = p.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;\n        w.y = p.y + -16.0*y2*k3*k4*k4 + k1*k1;\n        w.z = p.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;\n#else\n        // trigonometric version (MUCH faster than polynomial)\n        \n        // dz = 8*z^7*dz\n\t\tdz = 8.0*pow(m,3.5)*dz + 1.0;\n      \n        // z = z^8+c\n        float r = length(w);\n        float b = 8.0*acos( w.y/r);\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n#endif        \n        \n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\n\t\tif(m > 64.0 || dot(p,p) > 4.6) break;\n    }\n\n    resColor = vec4(m,trap.yzw);\n\n    // distance estimation (through the Hubbard-Douady potential)\n    float d = 0.25*log(m)*sqrt(m)/dz;\n    return (isnan(d)||isinf(d)||(d!=d)) ? 1.0 : d;\n}\n/* */\n\nfloat map(vec3 pos) {\n    vec4 trap;\n    //return min(length(pos) - 1.0, pos.y + 1.0);\n    return min(mandelbulb(pos,trap), pos.y + 1.0);\n}\n\nvec3 calcNorm(vec3 x) {\n    const float k = 0.00001;\n\n    return normalize(vec3(\n    map(x+k*vec3(1,0,0))-map(x-k*vec3(1,0,0)),\n    map(x+k*vec3(0,1,0))-map(x-k*vec3(0,1,0)),\n    map(x+k*vec3(0,0,1))-map(x-k*vec3(0,0,1))));;\n\n    /*\n    vec3 normal = normalize(vec3(\n    map(x+k*vec3(1,0,0))-map(x-k*vec3(1,0,0)),\n    map(x+k*vec3(0,1,0))-map(x-k*vec3(0,1,0)),\n    map(x+k*vec3(0,0,1))-map(x-k*vec3(0,0,1))));\n\n    return (any(isnan(normal))||any(isinf(normal))||(!any(equal(normal,normal)))) ? vec3(0.0, 1.0, 0.0) : normal;\n    */\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n\n    for(int i = 0; i < 256; i++) {\n        vec3 pos = ro + t * rd;\n\n        if(pos.x*pos.x > 9.0 || pos.y*pos.y > 1.0 || pos.z*pos.z > 9.0) {\n            t = 0.9e9;\n\n            break;\n        }\n\n        float dist = map(pos);\n\n        t += dist;\n\n        if(dist < 0.0001) break;\n    }\n\n    return vec2(t > 100.0 ? -1.0 : t, 1e9);\n}\n\nfloat pdf(vec3 normal, vec3 direction) {\n    // multiply by tau = multiply by 2 and divide by unit sphere surface area\n    return INV_TAU * max(dot(normal, direction), 0.001);\n}\n\nvec3 cosineWeightedHemisphere(vec3 n, inout uvec4 ns) {\n    vec2 r = urand2(ns);\n    vec3  uu = normalize(cross(n, abs(n.y) > 0.5 ? vec3(1,0,0) : vec3(0,1,0)));\n    vec3  vv = cross(uu, n);\n    float ra = sqrt(r.y);\n    float rx = ra*cos(TAU*r.x); \n    float ry = ra*sin(TAU*r.x);\n    float rz = sqrt(1.0-r.y);\n    vec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    return normalize(rr);\n}\n\nvec3 brdf(vec3 albedo, vec3 normal, vec3 inDirection, vec3 outDirection) {\n    return INV_TAU * albedo;\n}\n\nvec3 pointNEE(vec3 ro, vec3 normal, vec3 lightPos, vec3 lightCol) {\n    vec3 neesampDir = lightPos - ro;\n\n    float r2 = dot(neesampDir,neesampDir);\n    float r1 = sqrt(r2);\n    neesampDir /= r1;\n\n    float neegeometricFactor = max(dot(normal, neesampDir), 0.0);\n\n    vec2 neeray = rayMarch(ro, neesampDir);\n\n    return ((neeray.x < 0.0) || (neeray.x > r1  && neeray.x > 0.0)) ? ((lightCol*neegeometricFactor)/r2) : vec3(0);\n}\n\nvec3 pathTrace(in vec3 ro, in vec3 rd, inout uvec4 ns) {\n    vec3 rayPos = ro;\n    vec3 rayDir = rd;\n\n    vec3 att = vec3(1);\n    vec3 rad = vec3(0);\n\n    for(int depth = 0; depth < MAX_DEPTH; depth++) {\n        //vec2 t = sphIntersect(rayPos, rayDir, vec3(0.0, 0.0, 0.0), 1.0);\n        vec2 t = rayMarch(rayPos, rayDir);\n\n        if(t.x < 0.0 || t.y < t.x) {\n            //rad += att * pow(linear2acescg*texture(iChannel0, rayDir).rgb,vec3(2.2));\n            //rad += att * pow(linear2acescg*(depth>0?texture(iChannel0, rayDir).rgb:vec3(0.4,0.4,0.4)),vec3(2.2));\n            //rad += att * (linear2acescg*vec3(1))*(dot(rayDir,normalize(vec3(1,0,-1))) > sqrt(0.5) ? 1.0 : 0.0);\n            //rad += att;\n            //rad += linear2acescg*vec3(0.200);\n            return rad;\n        }\n\n        rayPos += t.x*rayDir;\n\n        //vec3 normal = normalize(rayPos);\n        vec3 normal = calcNorm(rayPos);\n\n        //vec3 albedo = vec3(0.800, 0.800, 0.800);\n        float checker = floor(2.0*fract(rayPos.x))+floor(2.0*fract(rayPos.z)) != 1.0 ? 0.8 : 0.2;\n        vec3 albedo = linear2acescg*((rayPos.y > -0.998) ? (rayPos.x > 0.0 ? vec3(1.0,0.5,0.0) : vec3(0.0,0.5,1.0)) : vec3(1.0)*checker);\n        //if(rayPos.x*rayPos.x < 0.1*0.1) rad += 1.0 * att * linear2acescg*vec3(0.5, 1.0, 1.0);\n        //albedo = vec3(1.0);\n\n        rayPos += 0.0001*normal;\n\n        vec3 sampDir = cosineWeightedHemisphere(normal, ns);\n\n        float geometricFactor = max(dot(normal, sampDir), 0.0);\n\n        //att *= geometricFactor * brdf(albedo, normal, rayDir, sampDir) / pdf(normal, sampDir);\n        att *= albedo;\n\n        vec3 lightPos;\n        lightPos = vec3( 1.5, -0.9,  1.5);\n        rad += linear2acescg*(att * (brdf(albedo, normal, rayDir, normalize(lightPos - rayPos))) * pointNEE(rayPos, normal, lightPos, vec3(100.0)));\n        lightPos = vec3(-1.5, -0.9,  1.5);\n        rad += linear2acescg*(att * (brdf(albedo, normal, rayDir, normalize(lightPos - rayPos))) * pointNEE(rayPos, normal, lightPos, vec3(100.0)));\n        lightPos = vec3( 1.5, -0.9, -1.5);\n        rad += linear2acescg*(att * (brdf(albedo, normal, rayDir, normalize(lightPos - rayPos))) * pointNEE(rayPos, normal, lightPos, vec3(100.0)));\n        lightPos = vec3(-1.5, -0.9, -1.5);\n        rad += linear2acescg*(att * (brdf(albedo, normal, rayDir, normalize(lightPos - rayPos))) * pointNEE(rayPos, normal, lightPos, vec3(100.0)));\n\n        rayDir = sampDir;\n        //rayDir = udir3(ns);\n    }\n\n    return vec3(0.000, 0.000, 0.000);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    uvec4 ns = uvec4(fragCoord, iFrame, 42069);\n\n    //vec2 uv = ((fragCoord)-(0.5*iResolution.xy))/(0.5*iResolution.y);\n    //vec2 uv = ((fragCoord+(urand2(ns)-0.5))-(0.5*iResolution.xy))/(0.5*iResolution.y);\n    vec2 uv = (nrand2(0.5, fragCoord, ns)-(0.5*iResolution.xy))/(0.5*iResolution.y);\n\n    //uv *= 0.5;\n    float th = PI*0.2;\n    float c = cos(th), s = sin(th);\n    mat2 rm = mat2(c,s,-s,c);\n    uv = rm*uv;\n\n    vec3 ro = vec3(-1.0, 1.0,  2.0);\n    vec3 rd = vec3(uv.x, uv.y, -1.0);\n\n    rd = normalize(rd);\n\n    th = PI*0.25;\n\n    c = cos(th), s = sin(th);\n    rm = mat2(c,s,-s,c);\n    rd = vec3(rm*rd.xz,rd.y).xzy;\n    th = -PI*0.25;\n\n    c = cos(th), s = sin(th);\n    rm = mat2(c,s,-s,c);\n    rd = vec3(rm*rd.xy,rd.z).xyz;\n\n    fragColor.rgb = pathTrace(ro, rd, ns);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = iFrame != 0 ? texelFetch(iChannel1, ivec2(fragCoord), 0) : vec4(0);\n\n    fragColor += texelFetch(iChannel0, ivec2(fragCoord), 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    fragColor = vec4(fragColor.a != 0.0 ? fragColor.rgb / fragColor.a : fragColor.rgb, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb, 1.0);\n\n    fragColor.rgb = acescg2linear*fragColor.rgb;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}