{
    "Shader": {
        "info": {
            "date": "1637589288",
            "description": "After the video for Joep Beving's \"Sinfonia (After Bach, BWV 248)\": https://youtu.be/mJa6QbJfvHk",
            "flags": 0,
            "hasliked": 0,
            "id": "slG3Dh",
            "likes": 13,
            "name": "Beving (2021)",
            "published": 3,
            "tags": [
                "noise",
                "rain",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "DrNoob",
            "viewed": 319
        },
        "renderpass": [
            {
                "code": "// Author: Thomas Stehle\n// Title: Beving (2021)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// After the video for Joep Beving's \"Sinfonia (After Bach,\n// BWV 248)\": https://youtu.be/mJa6QbJfvHk\n//\n// Try the shader in fullscreen mode. Would make a nice screen\n// saver.\n\nconst float PI = 3.14159;\n\nconst vec3 COLOR_BG = vec3( 17,  26,  46) / 255.0;\nconst vec3 COLOR_FG = vec3(121, 133, 156) / 255.0;\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash(in float p) {\n    p = fract(p * 0.011);\n    p *= p + 7.5;\n    p *= p + p;\n    return fract(p);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash(in vec3 p) {\n    vec3 q = fract(p * 0.1031);\n    q += dot(q, q.yzx + 33.33);\n    return fract((q.x + q.y) * q.z);\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vnoise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Smooth interpolation (smoothstep without clamping)\n    vec2 u = f*f * (3.0 - 2.0*f);\n\n    // Mix 4 corners\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// https://github.com/patriciogonzalezvivo/lygia\nvec3 brightness_contrast(in vec3 color, in float brightness, in float contrast ) {\n    return (color - 0.5) * contrast + 0.5 + brightness;\n}\n\nfloat stripes(in vec2 p, in float nstripes) {\n    // Stripe config\n    vec2 sc = vec2(nstripes, 1.0) * p;\n    vec2 id = floor(sc);\n    vec2 cc = fract(sc);\n    \n    // Random variables\n    float r1 = hash(id.x);\n    float r2 = hash(id.x * 13.37);\n    float r3 = hash(id.x * 47.11);\n    float r4 = hash(id.x * 73.23);\n    \n    // Horizontal variation\n    float freq = nstripes * PI;\n    float f = smoothstep(1.0, 0.0, sin(freq * p.x));\n    \n    // Vertical variation\n    float t = sin(0.25 * iTime + 10.0 * r1);   // Randomized time offset\n    float dt = cos(0.25 * iTime + 10.0 * r1);  // Derivative of time offset\n    float len = 0.9 * r2;                      // Randomized length\n    float slt = -0.01 + 0.02 * r3;             // Randomized slant\n    float ext = 0.2 * t * r4;                  // Randomized extent\n    f *= step(len + slt * cc.x - ext, cc.y);\n    \n    // Fade out when receeding\n    f *= smoothstep(-0.1, 0.5, dt);\n    \n    // Apply noise\n    f *= 0.5 + 0.5 * vnoise(10.0 * (cc + 0.2 * t));\n\n    return f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize input coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Background\n    vec3 col = mix(COLOR_BG, brightness_contrast(COLOR_FG, -0.3, 1.25), 1.0 - length(uv - vec2(0.5, 1.0)));\n    \n    // Stripe layers\n    col = mix(col, COLOR_FG, stripes(uv, 200.0));\n    col = mix(col, brightness_contrast(COLOR_FG, -0.1, 1.0), stripes(uv + vec2(0.123, 0.0), 250.0));\n    col = mix(col, brightness_contrast(COLOR_FG, -0.2, 1.0), stripes(uv + vec2(0.456, 0.0), 150.0));\n    col = mix(col, brightness_contrast(COLOR_FG, -0.3, 1.0), stripes(uv + vec2(0.789, 0.0), 300.0));\n    \n    // Add layer of animated white noise\n    col += 0.1 * vec3(hash(vec3(fragCoord.xy, fract(0.001 * iTime))));\n    \n    // Vignetting\n    float vig = length(uv - vec2(0.5)) * 0.85;\n    vig = vig * vig + 1.0;\n    col *= 1.0 / (vig * vig);\n    \n    // Final result\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}