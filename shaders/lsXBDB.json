{
    "Shader": {
        "info": {
            "date": "1498210997",
            "description": "^title",
            "flags": 0,
            "hasliked": 0,
            "id": "lsXBDB",
            "likes": 6,
            "name": "Reflection and Refraction",
            "published": 3,
            "tags": [
                "raytracing",
                "reflection",
                "refraction",
                "fresnel"
            ],
            "usePreview": 0,
            "username": "Takoa",
            "viewed": 683
        },
        "renderpass": [
            {
                "code": "#define GAMMA 2.2\n\n#define NUM_RAYS 200\n#define MAX_DEPTH 5\n\nvec3 spherePosition = vec3(0.0);\nfloat sphereRadius = 1.0;\nfloat sphereIor = 1.51;\n\n// By hornet: https://www.shadertoy.com/view/4ssXRX\nfloat rand(vec2 n)\n{\n\treturn fract(sin(dot(n + 0.07 * iTime, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat fresnel(vec3 l, vec3 n, float eta1, float eta2)\n{\n    float c = abs(dot(l, n));\n    float g = sqrt((eta2 * eta2) / (eta1 * eta1) - 1.0 + c * c);\n    float gpc = g + c;\n    float gmc = g - c;\n    float f1 = c * gpc - 1.0;\n    float f2 = c * gmc + 1.0;\n    \n    return 0.5 * (gmc * gmc) / (gpc * gpc) * (1.0 + (f1 * f1) / (f2 * f2));\n}\n\nfloat sphere(vec3 rayOrigin, vec3 rayDirection, vec3 center, float radius)\n{\n    vec3 difference = rayOrigin - center;\n    float b = dot(difference, rayDirection);\n    float c = dot(difference, difference) - radius * radius;\n    float d = b * b - c;\n    \n    return mix(-1.0, -b - sqrt(abs(d)), step(0.0, d));\n}\n\nfloat getCoefficient(vec3 rayOrigin, vec3 rayDirection)\n{\n    return sphere(rayOrigin, rayDirection, spherePosition, sphereRadius);\n}\n\nvec3 getNormal(vec3 hitPoint)\n{\n    return normalize(hitPoint - spherePosition);\n}\n\nvec3 getRayDirection(vec2 screenPosition, vec3 origin, vec3 lookingAt, vec3 up, float fov)\n{\n    vec3 d = normalize(lookingAt - origin);\n    vec3 right = normalize(cross(d, up));\n    \n    return normalize(screenPosition.x * right + screenPosition.y * up + 1.0 / tan(radians(fov / 2.0)) * d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 cameraPosition = 2.0 * vec3(cos(iTime), 0.0, sin(iTime));\n    vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n    vec3 cameraLookingAt = vec3(0.0);\n    \n    vec3 color = vec3(0.0);\n    \n    for (int i = 0; i < NUM_RAYS; i++)\n    {\n        vec3 rayOrigin = cameraPosition;\n        vec3 rayDirection = getRayDirection(position, cameraPosition, cameraLookingAt, cameraUp, 90.0);\n        float eta1 = 1.0;\n        float eta2 = sphereIor;\n        vec3 v;\n        \n        for (int j = 0; j < MAX_DEPTH; j++)\n        {\n            float t = getCoefficient(rayOrigin, rayDirection);\n            \n            if (0.0 <= t)\n            {\n                vec3 hitPoint = rayOrigin + rayDirection * t;\n                vec3 normal = getNormal(hitPoint);\n                float f = fresnel(-rayDirection, normal, eta1, eta2);\n                vec3 reflection = reflect(rayDirection, normal);\n                vec3 refraction = refract(rayDirection, normal, eta1 / eta2);\n                float numRays = float(NUM_RAYS);\n                float maxDepth = float(MAX_DEPTH);\n                float r = rand(-uv * (maxDepth + 1.0) * numRays + float(i) * maxDepth + float(j));\n                \n                if (r < f)\n                {\n                    rayDirection = reflection;\n                }\n                else\n                {\n                    float g = eta2;\n                    \n                    eta2 = eta1;\n                    eta1 = g;\n                    rayDirection = refraction;\n                }\n                \n                rayOrigin = hitPoint + rayDirection * 0.00001;\n            }\n            else\n            {\n                v = texture(iChannel0, rayDirection).xyz;\n                \n                break;\n            }\n        }\n        \n        color += v / float(NUM_RAYS);\n    }\n    \n    //fragColor = vec4(powVec3(color, 1.0 / GAMMA), 1.0);\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}