{
    "Shader": {
        "info": {
            "date": "1525972006",
            "description": "This is just some hacky way to draw 2D-Primitives like lines and circles.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "Xsdfz2",
            "likes": 8,
            "name": "Lines, Cube, Triangle",
            "published": 3,
            "tags": [
                "2d",
                "triangle",
                "cube",
                "line",
                "lines",
                "circle",
                "primitives",
                "drawing"
            ],
            "usePreview": 0,
            "username": "kekwizard",
            "viewed": 549
        },
        "renderpass": [
            {
                "code": "/*\n\nThis is just some hacky way to draw 2D-Primitives like lines and circles.\n\n*/\n\nfloat TWO_PI = 6.28318531;\nvec3 lineColor = vec3(1.0, 1.0, 1.0);\nvec3 background = vec3(0.23, 0.23, 0.23);\n\n// Helper for drawing a line\nfloat lineDistance(vec2 start, vec2 end, vec2 p) {\n  float l2 = pow(distance(start, end), 2.0);\n  if (l2 == 0.0) return distance(p, start);\n  float t = max(0., min(1., dot(p - start, end - start) / l2));\n  vec2 projection = start + t * (end - start);\n  return distance(p, projection);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\n// Helper for Circle\nfloat circleDistance(vec2 center, vec2 p, float radius) {\n    vec2 n = center + radius * normalize(p - center);\n\treturn distance(p, n);\n}\n\nfloat shade(float x, float t) {\n    return pow(1. - (x / t), 1.25);    \n}\n\n\n// Draws a circle ;)\nfloat circle(vec2 center, vec2 p, float radius, float thickness) {\n    float d = circleDistance(center, p, radius);\n    if(d < thickness) {\n       return shade(d, thickness);    \n    } else {\n\t\treturn 0.0;\n    }\n}\n\n// Draw a line from start to end\nfloat line(vec2 start, vec2 end, vec2 p, float thickness) {\n    float d = lineDistance(start, end, p);\n    if(d < thickness) {\n       return shade(d, thickness);    \n    } else {\n\t\treturn 0.0;\n    }\n}\n\nfloat cube(vec3 pos, vec2 uv, float size, float thickness) {\n        \n    const int nverts = 8;\n\tvec3 verts[nverts] = vec3[]( \n      \t\t\t\t\t\t\tvec3( -0.5, -0.5, -0.5 ),\n                                vec3( 0.5, -0.5, -0.5 ),\n                                vec3( -0.5, -0.5, 0.5 ),\n                                vec3( 0.5, -0.5, 0.5 ),\n            \t\t\t\t\tvec3( -0.5, 0.5, -0.5 ),\n                                vec3( 0.5, 0.5, -0.5 ),\n                                vec3( -0.5, 0.5, 0.5 ),\n                                vec3( 0.5, 0.5, 0.5 )\n                              );\n   \n    for(int i = 0; i < nverts; i++) {\n        mat4 a = rotationMatrix(vec3(1.0, 0.0, 0.0), iTime);\n        mat4 b = rotationMatrix(vec3(0.0, 1.0, 1.0), iTime * 1.2);\n    \tverts[i] = (a * b * vec4((verts[i] * size) + pos, 1.0)).xyz;\n    }\n        \n        \n\tfloat m = 0.;\n    \n\tm = max(m, line(verts[0].xy, verts[1].xy, uv, thickness));\n\tm = max(m, line(verts[0].xy, verts[2].xy, uv, thickness));\n\tm = max(m, line(verts[2].xy, verts[3].xy, uv, thickness));\n\tm = max(m, line(verts[3].xy, verts[1].xy, uv, thickness));\n    \n\tm = max(m, line(verts[4].xy, verts[5].xy, uv, thickness));\n\tm = max(m, line(verts[4].xy, verts[6].xy, uv, thickness));\n\tm = max(m, line(verts[6].xy, verts[7].xy, uv, thickness));\n\tm = max(m, line(verts[7].xy, verts[5].xy, uv, thickness));\n    \n\tm = max(m, line(verts[4].xy, verts[0].xy, uv, thickness));\n\tm = max(m, line(verts[5].xy, verts[1].xy, uv, thickness));\n\tm = max(m, line(verts[7].xy, verts[3].xy, uv, thickness));\n\tm = max(m, line(verts[6].xy, verts[2].xy, uv, thickness));\n\n    \n    return m;\n}\n\nfloat triangle(vec3 pos, vec2 uv, float radius, float thickness) {\n\t\n    float m = 0.;\n    const int dotN = 3;\n    const float dotNF = float(dotN);\n    vec2 dots[dotN];\n    float a = sin(iTime* 0.08) * 3.1 + 0.5;\n    for(int i = 0; i < dotN; i++) {\n    \tdots[i] = vec2( cos((float(i) + a) * (TWO_PI / dotNF)) * radius, sin((float(i) + a) * (TWO_PI / dotNF)) * radius);\n    }\n    \n    for(int i = 0; i < dotN; i++) {\n        int k = (i + 1) % dotN;\n        m = max(m, line(dots[i], dots[k], uv, thickness));\n    }\n    \n    \n    return m;\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / (iResolution.y);\n    \n    float r = 0.35;\n    vec3 col = background;\n    float m = 0.;\n    \n    float gThickness = 0.0075;\n    \n    // Draw a circle\n    m = max(m, circle(vec2(0.0, 0.0), uv, r, gThickness));\n    \n    // Draw a cube\n    m = max(m, cube(vec3(0.0), uv, 0.1, gThickness));\n    \n    // Draw a triangle\n\tm = max(m, triangle(vec3(0.0), uv, r, gThickness));\n    \n    \n\n    \n    float k = pow(1. - m, 0.275);\n    col = mix(background, lineColor, m);\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}