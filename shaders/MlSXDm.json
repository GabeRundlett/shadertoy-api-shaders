{
    "Shader": {
        "info": {
            "date": "1469477304",
            "description": "Energy problems? You live on a thin crust...Just learn to dig, stupid humans! :) \nYou may need full screen to read it. It uses a sprite sheet in 'Buffer A' to render the font quickly.",
            "flags": 96,
            "hasliked": 0,
            "id": "MlSXDm",
            "likes": 36,
            "name": "Learning to Dig",
            "published": 3,
            "tags": [
                "2d",
                "text",
                "font",
                "learningtodig"
            ],
            "usePreview": 0,
            "username": "Dave_Hoskins",
            "viewed": 3792
        },
        "renderpass": [
            {
                "code": "// Learning to Dig\n// by David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//8x8x1 font access...\n#define _A col += char(vec2(0,0));\n#define _B col += char(vec2(1,0));\n#define _C col += char(vec2(2,0));\n#define _D col += char(vec2(3,0));\n#define _E col += char(vec2(4,0));\n#define _F col += char(vec2(5,0));\n#define _G col += char(vec2(6,0));\n#define _H col += char(vec2(7,0));\n#define _I col += char(vec2(8,0));\n#define _J col += char(vec2(9,0));\n#define _K col += char(vec2(10,0));\n#define _L col += char(vec2(11,0));\n#define _M col += char(vec2(12,0));\n#define _N col += char(vec2(13,0));\n#define _O col += char(vec2(14,0));\n#define _P col += char(vec2(15,0));\n#define _Q col += char(vec2(16,0));\n#define _R col += char(vec2(17,0));\n#define _S col += char(vec2(18,0));\n#define _T col += char(vec2(19,0));\n#define _U col += char(vec2(20,0));\n#define _V col += char(vec2(21,0));\n#define _W col += char(vec2(22,0));\n#define _X col += char(vec2(23,0));\n#define _Y col += char(vec2(24,0));\n#define _Z col += char(vec2(25,0));\n#define _a col += char(vec2(0,1));\n#define _b col += char(vec2(1,1));\n#define _c col += char(vec2(2,1));\n#define _d col += char(vec2(3,1));\n#define _e col += char(vec2(4,1));\n#define _f col += char(vec2(5,1));\n#define _g col += char(vec2(6,1));\n#define _h col += char(vec2(7,1));\n#define _i col += char(vec2(8,1));\n#define _j col += char(vec2(9,1));\n#define _k col += char(vec2(10,1));\n#define _l col += char(vec2(11,1));\n#define _m col += char(vec2(12,1));\n#define _n col += char(vec2(13,1));\n#define _o col += char(vec2(14,1));\n#define _p col += char(vec2(15,1));\n#define _q col += char(vec2(16,1));\n#define _r col += char(vec2(17,1));\n#define _s col += char(vec2(18,1));\n#define _t col += char(vec2(19,1));\n#define _u col += char(vec2(20,1));\n#define _v col += char(vec2(21,1));\n#define _w col += char(vec2(22,1));\n#define _x col += char(vec2(23,1));\n#define _y col += char(vec2(24,1));\n#define _z col += char(vec2(25,1));\n#define _0 col += char(vec2(0,2));\n#define _1 col += char(vec2(1,2));\n#define _2 col += char(vec2(2,2));\n#define _3 col += char(vec2(3,2));\n#define _4 col += char(vec2(4,2));\n#define _5 col += char(vec2(5,2));\n#define _6 col += char(vec2(6,2));\n#define _7 col += char(vec2(7,2));\n#define _8 col += char(vec2(8,2));\n#define _9 col += char(vec2(9,2));\n#define _EXC col += char(vec2(10,2));\n#define _QTN col += char(vec2(11,2));\n#define _STP col += char(vec2(12,2));\n#define _COM col += char(vec2(13,2));\n#define _APO col += char(vec2(14,2));\n#define _SP loc.x+=add.x*.5; \n#define _NL loc.x = caret.x; loc.y-=add.y*.5; \n\n\nvec2 crd;\nvec2 add;\nvec2 loc;\nvec2 size;\nvec2 caret;\n\n\nfloat char(in vec2 b)\n{\n    \n    vec2 p = crd*size-(loc*size);\n    loc.x += add.x;\n    if (!(all(lessThan(p,vec2(8.))) &&  all(greaterThanEqual(p,vec2(0.))))) return 0.0;\n\n\treturn -texture(iChannel0, (p+b*9.)/ iResolution.xy).r;\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 coord )\n{\n    size = vec2(240.0, 150.0);\n    add = vec2(8.0/size.x, 18.0/size.y);\n \n\tvec3 col = texture(iChannel1, coord / iResolution.xy).xyz; \n    \n    crd = (-iResolution.xy + 2.0 * coord ) / iResolution.y;\n    \n    float ti = iTime;\n    if (ti > 1.0)\n    {\n    \tcaret = loc = vec2(-1.38, .8);\n    \t_W _h _e _r _e _SP _i _n _SP _t _h _e _SP _w _o _r _l _d _NL\n    \t_c _a _n _SP _w _e _SP _f _i _n _d _SP _m _o _r _e _SP _E _n _e _r _g _y _QTN \n\t}\n       \n    if (ti > 3.0)\n    {\n\t\tcaret = loc = vec2(-1.5, .4);\n    \t_L _e _t _APO _s _SP _g _r _o _w _SP _B _i _o _F _u _e _l _NL\n\t\t_i _n _s _t _e _a _d _SP _o _f _SP _f _o _o _d _EXC\n\t}\n     \n\tif (ti > 5.0)\n    {\n\t\t caret = loc = vec2(-1.4, .0);\n\t\t_J _u _s _t _SP  _i _g _n _o _r _e _SP _i _t _COM _NL\n    \t_SP _SP _n _o _SP _p _r _o _b _l _e _m _STP\n\t}\n    if (ti > 7.0)\n    {\n\t\tcaret = loc = vec2(-1.3, -.4);\n\t\t_S _o _l _a _r _SP _P _o _w _e _r _COM _NL\n\t\t_t _h _a _t _APO _s _SP _i _t _EXC\n\t}\n    if (ti > 9.0)        \n    {\n\t\tcaret = loc = vec2(-1.15, -0.82);\n\t\t_I _APO _m _SP _f _o _r _SP _N _u _c _l _e _a _r _EXC\n\t}\n\n    if (ti > 2.0)\n    {\n    \tcaret = loc = vec2(.62, .8);\n    \t_I  _s _SP _t _h _e _r _e _SP _a _SP _s _u _b _t _i _t _u _t _e _NL\n    \t_SP _f _o _r _SP _o _i _l _EXC _QTN\n\t}\n        \n    if (ti > 4.0)\n    {\n\t\tcaret = loc = vec2(.89, .38);\n    \t_W _h _a _t _SP _a _b _o _u _t _SP _w _i _n _d _SP  _p _o _w _e _r _EXC\n\t}\n      \n    if (ti > 6.0)\n    {\n\t\tcaret = loc = vec2(1., .0);\n\t\t_W _e _SP _c _o _u _l _d _SP _h _a _r _n _e _s _s _NL\n\t\t_t _h _e _SP _p _o _w _e _r _SP _o _f _SP _t _h _e _SP _s _e _a _EXC\n\t}\n    if (ti > 8.0)\n    {\n    \tcaret = loc = vec2(.9, -.4);\n    \t_S _h _a _l _e _SP _g _a _s _QTN _SP _T _h _a _t _APO _s _NL\n    \t_c _o _s _t _SP _e _f _f _e _c _t _i _v _e _STP _STP _STP\n\t}\n    if (ti > 9.9)\n    {\n    \tcaret = loc = vec2(.62, -.8);\n    \t_L _e _t _APO _s _SP _t _r _y _SP _a _n _d _NL\n\t\t_f _i _n _d _SP _m _o _r _e _SP _o _i _l _SP _h _e _r _e _STP\n     }\n        \n\n\tfragColour = vec4(col, 1);\n    \n    size = vec2(150.0, 110.);\n    add = vec2(8.0/size.x, 16.0/size.y);\n    col = vec3(0);\n    caret = loc = vec2(-.38, -.97);\n\t_L _e _a _r _n _i _n _g _SP _T _o _SP _D _i _g\n    fragColour.xyz -= col*vec3(1.5, .5, .4);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 28724,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/dave-h-3/desert-moon"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Learning to Dig\n// by David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//8x8x1 font data...\n#define _A col += char(vec4(0x386C, 0xC6C6, 0xFEC6, 0xC600));loc.x+=1.;\n#define _B col += char(vec4(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00));loc.x+=1.;\n#define _C col += char(vec4(0x3C66, 0xC0C0, 0xC066, 0x3C00));loc.x+=1.;\n#define _D col += char(vec4(0xF8CC, 0xC6C6, 0xC6CC, 0xF800));loc.x+=1.;\n#define _E col += char(vec4(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00));loc.x+=1.;\n#define _F col += char(vec4(0xFEC0, 0xC0FC, 0xC0C0, 0xC000));loc.x+=1.;\n#define _G col += char(vec4(0x3E60, 0xC0CE, 0xC666, 0x3E00));loc.x+=1.;\n#define _H col += char(vec4(0xC6C6, 0xC6FE, 0xC6C6, 0xC600));loc.x+=1.;\n#define _I col += char(vec4(0x7E18, 0x1818, 0x1818, 0x7E00));loc.x+=1.;\n#define _J col += char(vec4(0x606, 0x606, 0x6C6, 0x7C00));loc.x+=1.;\n#define _K col += char(vec4(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00));loc.x+=1.;\n#define _L col += char(vec4(0x6060, 0x6060, 0x6060, 0x7E00));loc.x+=1.;\n#define _M col += char(vec4(0xC6EE, 0xFEFE, 0xD6C6, 0xC600));loc.x+=1.;\n#define _N col += char(vec4(0xC6E6, 0xF6FE, 0xDECE, 0xC600));loc.x+=1.;\n#define _O col += char(vec4(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00));loc.x+=1.;\n#define _P col += char(vec4(0xFCC6, 0xC6C6, 0xFCC0, 0xC000));loc.x+=1.;\n#define _Q col += char(vec4(0x7CC6, 0xC6C6, 0xDECC, 0x7A00));loc.x+=1.;\n#define _R col += char(vec4(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00));loc.x+=1.;\n#define _S col += char(vec4(0x78CC, 0xC07C, 0x6C6, 0x7C00));loc.x+=1.;\n#define _T col += char(vec4(0x7E18, 0x1818, 0x1818, 0x1800));loc.x+=1.;\n#define _U col += char(vec4(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00));loc.x+=1.;\n#define _V col += char(vec4(0xC6C6, 0xC6EE, 0x7C38, 0x1000));loc.x+=1.;\n#define _W col += char(vec4(0xC6C6, 0xD6FE, 0xFEEE, 0xC600));loc.x+=1.;\n#define _X col += char(vec4(0xC6EE, 0x7C38, 0x7CEE, 0xC600));loc.x+=1.;\n#define _Y col += char(vec4(0x6666, 0x663C, 0x1818, 0x1800));loc.x+=1.;\n#define _Z col += char(vec4(0xFE0E, 0x1C38, 0x70E0, 0xFE00));loc.x+=1.;\n#define _a col += char(vec4(0x0, 0x7C06, 0x7EC6, 0x7E00));loc.x+=1.;\n#define _b col += char(vec4(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00));loc.x+=1.;\n#define _c col += char(vec4(0x0, 0x7EC0, 0xC0C0, 0x7E00));loc.x+=1.;\n#define _d col += char(vec4(0x606, 0x7EC6, 0xC6C6, 0x7E00));loc.x+=1.;\n#define _e col += char(vec4(0x0, 0x7CC6, 0xFEC0, 0x7C00));loc.x+=1.;\n#define _f col += char(vec4(0xE18, 0x7E18, 0x1818, 0x1800));loc.x+=1.;\n#define _g col += char(vec4(0x0, 0x7EC6, 0xC67E, 0x67C));loc.x+=1.;\n#define _h col += char(vec4(0xC0C0, 0xFCC6, 0xC6C6, 0xC600));loc.x+=1.;\n#define _i col += char(vec4(0x1800, 0x3818, 0x1818, 0x7E00));loc.x+=1.;\n#define _j col += char(vec4(0xC00, 0x1C0C, 0xC0C, 0xC78));loc.x+=1.;\n#define _k col += char(vec4(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00));loc.x+=1.;\n#define _l col += char(vec4(0x3818, 0x1818, 0x1818, 0x7E00));loc.x+=1.;\n#define _m col += char(vec4(0x0, 0xFCB6, 0xB6B6, 0xB600));loc.x+=1.;\n#define _n col += char(vec4(0x0, 0xFCC6, 0xC6C6, 0xC600));loc.x+=1.;\n#define _o col += char(vec4(0x0, 0x7CC6, 0xC6C6, 0x7C00));loc.x+=1.;\n#define _p col += char(vec4(0x0, 0xFCC6, 0xC6FC, 0xC0C0));loc.x+=1.;\n#define _q col += char(vec4(0x0, 0x7EC6, 0xC67E, 0x606));loc.x+=1.;\n#define _r col += char(vec4(0x0, 0x6E70, 0x6060, 0x6000));loc.x+=1.;\n#define _s col += char(vec4(0x0, 0x7CC0, 0x7C06, 0xFC00));loc.x+=1.;\n#define _t col += char(vec4(0x1818, 0x7E18, 0x1818, 0x1800));loc.x+=1.;\n#define _u col += char(vec4(0x0, 0xC6C6, 0xC6C6, 0x7E00));loc.x+=1.;\n#define _v col += char(vec4(0x0, 0x6666, 0x663C, 0x1800));loc.x+=1.;\n#define _w col += char(vec4(0x0, 0xB6B6, 0xB6B6, 0x7E00));loc.x+=1.;\n#define _x col += char(vec4(0x0, 0xC6FE, 0x38FE, 0xC600));loc.x+=1.;\n#define _y col += char(vec4(0x0, 0xC6C6, 0xC67E, 0x67C));loc.x+=1.;\n#define _z col += char(vec4(0x0, 0xFE1C, 0x3870, 0xFE00));loc.x+=1.;\n#define _0 col += char(vec4(0x384C, 0xC6C6, 0xC664, 0x3800));loc.x+=1.;\n#define _1 col += char(vec4(0x1838, 0x1818, 0x1818, 0x7E00));loc.x+=1.;\n#define _2 col += char(vec4(0x7CC6, 0xE3C, 0x78E0, 0xFE00));loc.x+=1.;\n#define _3 col += char(vec4(0x7E0C, 0x183C, 0x6C6, 0x7C00));loc.x+=1.;\n#define _4 col += char(vec4(0x1C3C, 0x6CCC, 0xFE0C, 0xC00));loc.x+=1.;\n#define _5 col += char(vec4(0xFCC0, 0xFC06, 0x6C6, 0x7C00));loc.x+=1.;\n#define _6 col += char(vec4(0x3C60, 0xC0FC, 0xC6C6, 0x7C00));loc.x+=1.;\n#define _7 col += char(vec4(0xFEC6, 0xC18, 0x3030, 0x3000));loc.x+=1.;\n#define _8 col += char(vec4(0x78C4, 0xE478, 0x9E86, 0x7C00));loc.x+=1.;\n#define _9 col += char(vec4(0x7CC6, 0xC67E, 0x60C, 0x7800));loc.x+=1.;\n#define _EXC col += char(vec4(0x3838, 0x3830, 0x3000, 0x3000));loc.x+=1.;\n#define _QTN col += char(vec4(0x7CFE, 0xC60C, 0x3800, 0x3800));loc.x+=1.;\n#define _COM col += char(vec4(0x0, 0x0, 0x30, 0x3060));loc.x+=1.;\n#define _APO col += char(vec4(0x3030, 0x3000, 0x0, 0x0));loc.x+=1.;\n#define _STP col += char(vec4(0x0, 0x0, 0x30, 0x3000));loc.x+=1.;\n#define _SP loc.x+=1.; \n\nvec2 loc;\nvec2 crd;\n\nfloat char(in vec4 b)\n{\n\n    vec2 p = crd- (loc * 9.0);\n    if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n    \n\tp = floor(8.0-p);    int c = int(p.y / 2.0);\n    float bin = b[c];\n    if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n\treturn mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n\tif (iFrame > 1) discard;\n    crd = coord;\n    \n    float col = 0.0;\n    \n    loc = vec2(0, 0);\n    _A _B _C _D _E _F _G _H _I _J _K _L _M _N _O _P _Q _R _S _T _U _V _W _X _Y _Z\n     loc = vec2(0, 1);\n    _a _b _c _d _e _f _g _h _i _j _k _l _m _n _o _p _q _r _s _t _u _v _w _x _y _z\n    loc = vec2(0, 2);\n    _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _EXC _QTN _STP _COM _APO\n//    loc = vec2(1.0, 10);\n//    _L _e _a _r _n _i _n _g _SP _T _o _SP _D _i _g\n\n\tfragColor = vec4(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Learning to Dig\n// by David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n//  1 out, 2 in...\n#define HASHSCALE1 .1031\n#define SCALE_X 1.\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//--------------------------------------------------------------------------\nconst vec2 add = vec2(1.0,0.0);\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(1.5-f)*2.0;\n    \n    float res = mix(mix( hash12(p), hash12(p + add.xy),f.x),\n                    mix( hash12(p + add.yx), hash12(p + add.xx),f.x),f.y);\n    return res;\n}\n\n\n\nfloat circle (vec2 p, float d)\n{\n    float f = length(p)-d;\n    return f;\n}\nfloat box( vec2 p, vec2 pos, vec2 b, float r )\n{\n    p-=pos;\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\n// signed distance to a 2D triangle\n// Thanks to rwvens for this triangle distance field...\nfloat arrow(in vec2 p,  in vec2 p0, in vec2 p1)\n{\n    vec2 p2 = normalize(vec2((p1.y-p0.y), -(p1.x -p0.x)))*.025+p0;\n    p.y -= sin((-(length(p0-p)))*10.)*.06;\n    \n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), v0.x*e0.y-v0.y*e0.x ),\n                       vec2( dot( pq1, pq1 ), v1.x*e1.y-v1.y*e1.x )),\n                       vec2( dot( pq2, pq2 ), v2.x*e2.y-v2.y*e2.x ));\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n//----------------------------------------------------------------------------------------\nconst mat2 m = mat2( 0.80,  0.90, -0.90,  0.80 )*2.7;\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p;\n    f += 0.2500*noise( p ); p = m*p;\n    f += 0.1250*noise( p ); p = m*p;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\n// Thanks to iq for writing this warp function, altering this saved me loads of time and experimentation...\n// https://www.shadertoy.com/view/lsl3RH\nvec3 lava(in vec2 q, in float d)\n{\n    q*=2.0;\n    float ql = length( q );\n    q.x += 0.05*sin(0.7*iTime+ql*4.7);\n    q.y += 0.05*sin(0.3*iTime+ql*4.7);\n    q *= 0.7;\n\n\tvec2 o = vec2(0.0);\n    o.x = 0.5 + 0.5*fbm6( vec2(2.0*q          )  );\n    o.y = 0.5 + 0.5*fbm6( vec2(2.0*q)  );\n\n\tfloat ol = length( o );\n    o.x += 0.02*sin(0.12*iTime*14.+ol)/ol;\n    o.y += 0.02*sin(0.14*iTime*14.+ol)/ol;\n\n    vec2 n;\n    n.x = fbm6( vec2(7.0*o+vec2(19.2))  );\n    n.y = fbm6( vec2(7.0*o+vec2(15.7))  );\n\n    vec2 p = 4.0*q + 4.0*n;\n\n    float f = 0.5 + .5 * fbm4( p );\n\n    f = mix( f, f*f*f*3.5, f*abs(n.x) );\n\n    float g = 0.5 + 0.5*sin(4.0*p.x)*sin(4.0*p.y);\n    f *= 1.0-0.5*pow( g, 8.0 );\n\n\t//vec4 on = vec4( o, n );\n\t\n    vec3 col = mix(vec3(f, f, 0), vec3(1.0-f*.3), smoothstep(-.01 , -.4, d));\n    col += mix(vec3(0), vec3(pow(f, 5.0))*.4, smoothstep(-.01 , -.5, d));\n    col =  mix(col, vec3(1,1,0), n.x*.5);\n    col -= vec3(.0,1.,1.) * dot(o,o)*(d+.5);\n    \n    return col;\n}\nfloat flare( vec2 U )                            // rotating hexagon \n{\tvec2 A = sin(vec2(0, 1.83) + iDate.w);\n    U = abs( U * mat2(A, -A.y, A.x) ) * mat2(2.,0,1,1.77); \n    return .2/max(U.x,U.y);                      // glowing-spiky approx of step(max,.2)\n  //return .2*pow(max(U.x,U.y), -2.);\n \n}\n\n#define r(x)     fract(1e4*sin((x)*545.3))      // rand, signed rand   in 1, 2, 3D.\n#define sr2(x)   ( r(vec2(x,x+.1)) *2.-1. )\n\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n    vec3 col = vec3(0);\n    vec2 xy = (-iResolution.xy + 2.0 * coord ) / iResolution.y;\n    float c = 0.0;\n    \n    // Thanks to FabriceNeyret2 for his perfect star field effect\n    //-----------------------------------------------------------\n    for (float i=0.; i< 80.; i++)\n    c += flare (xy*.5-sr2(i+9.))           // rotating flare at random location\n              * r(i+.4)                          // random scale\n              * (1.4+sin(iTime*2.+r(i+1.4)*15.2))*.01;//  // time pulse\n    col = vec3(c);\n\n    \n  \n    float d = circle(xy, .85);\n    col = mix(col, vec3(.2, .2, .2), smoothstep(1. , 0., d));\n    col = mix(col, vec3(.0, .6, 1.0), smoothstep(0.12 , .001, d)*.5);\n    col = mix(vec3(.1,0.2,.1), col, smoothstep(0.0, 0.001, d+noise(xy*100.)*.005));\n    col = mix(col, lava(xy, d), smoothstep(-.01 , -.015, d));\n\tcol = mix(col, vec3(1.0, 1.0, 1.0), smoothstep(-.5 , -.8, d));\n   \n\td = 10.;\n    float ti = iTime;\n    if (ti > 1.)\n    {\n        d = box(xy, vec2(-1.01, .8), vec2(.4, .01),.08);\n    \td = min(d, arrow(xy, vec2(-1., .8),vec2(-.6, .56))); \n    }\n\n    if (ti > 3.)\n    {\n        d = min(d, box(xy, vec2(-1.2, .4), vec2(.3, .01),.08));;\n\t\td = min(d, arrow(xy, vec2(-1.1, .4),vec2(-.85, .15))); \n    }\n\n    if (ti > 5.)\n    {\n        d = min(d, box(xy, vec2(-1.18, .0), vec2(.2, .01),.08));\n        d = min(d, arrow(xy, vec2(-1., .0),vec2(-.85, -.15))); \n    }\n    if (ti > 7.)\n    {\n        d = min(d, box(xy, vec2(-1.1, -.4), vec2(.2, .01),.08));\n        d = min(d, arrow(xy, vec2(-1., -.4),vec2(-.65, -.6))); \n    }\n    if (ti > 9.)\n    {\n        d = min(d, box(xy, vec2(-.9, -.8), vec2(.25, .0),.08));\n        d = min(d, arrow(xy, vec2(-.62, -.8),vec2(-.4, -.7))); \n    }\n    \n     if (ti > 2.)\n    {\n        d = min(d, box(xy, vec2(.92, .8), vec2(.3, .01),.08));\n        d = min(d, arrow(xy, vec2(.8, .8),vec2(.65, .6))); \n    }\n    \n    if (ti > 4.)\n    {\n        d = min(d, box(xy, vec2(1.22, .4), vec2(.3, .01),.08));\n        d = min(d, arrow(xy, vec2(1.1, .33),vec2(.84, .2))); \n    }\n    if (ti > 6.)\n    {\n        d = min(d, box(xy, vec2(1.3, .0), vec2(.3, .01),.08));\n        d = min(d, arrow(xy, vec2(1.1, .0),vec2(.84, -.22))); \n    }\n    if (ti > 8.)\n    {\n        d = min(d, box(xy, vec2(1.18, -.4), vec2(.27, .01),.08));\n        d = min(d, arrow(xy, vec2(1.1, -.4),vec2(.65, -.62))); \n    }\n\n  \n    if (ti > 9.9)\n    {\n        d = min(d, box(xy, vec2(.9, -.8), vec2(.3, .01),.08));\n        d = min(d, arrow(xy, vec2(.52, -.8),vec2(.4, -.7))); \n    }\n\n        \n    col = mix(col, vec3(1.0,.9,.8), smoothstep(0.01,.0, d));\n    col = mix(col, vec3(1.,.2,.0), smoothstep(0.005,.011, d)*smoothstep(0.012,.011, d));\n        \n        \n    fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}