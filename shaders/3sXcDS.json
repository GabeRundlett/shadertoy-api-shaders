{
    "Shader": {
        "info": {
            "date": "1585422751",
            "description": "An experimental wormhole where the exit is a white hole.\nDoesn't work exactly as intended, but is still cool.",
            "flags": 0,
            "hasliked": 0,
            "id": "3sXcDS",
            "likes": 1,
            "name": "Blue's Glitchy Wormhole",
            "published": 3,
            "tags": [
                "pbr"
            ],
            "usePreview": 0,
            "username": "BlueVelvetCake",
            "viewed": 345
        },
        "renderpass": [
            {
                "code": "vec3 cameraPos = vec3(5, 0, 0);\nfloat dist = 45.;\nfloat ang = 0.;\nfloat fov = 1.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 halfCoords = fragCoord - (iResolution.xy / 2.); // UV Coordinates centered on zero\n    vec2 normalUv = halfCoords / iResolution.yy; \n    \n    ang = iMouse.x / 100.;\n    dist = iMouse.y / 5.;\n    \n    if (iMouse.xy == vec2(0)) { dist = 30.; }\n    \n    vec3 orbitPos = vec3(-cos(ang) * dist, dist / 3., -sin(ang) * dist);\n    \n    vec3 startPos = cameraPos + orbitPos; // Starting position and starting velocity\n    vec3 startVel = toSphere(normalUv.x * fov + ang, normalUv.y * fov - 0.3);\n    \n    traceResult mainResult = trace(startPos, startVel); // Pass to trace function\n\n    fragColor = mainResult.hitColor; // Output to screen\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "struct traceResult { vec3 hitPos; vec4 hitColor; };\n\nvec3 bSpherePos = vec3(5, 0, 0);\nvec3 wSpherePos = vec3(-5, 0, 0);\n    \ntraceResult trace( vec3 startPos, vec3 startVel )\n{\n    \n \tvec3 pos = startPos;\n    vec3 vel = startVel;\n    vec4 color = vec4(vec3(0), 1);\n    float life = 0.;\n    \n    while( life < 500. )\n    {\n        \n        bSpherePos = vec3(cos(iTime), 0, sin(iTime))\n        \n        float bSphereDist = max(distance(pos, bSpherePos), 0.01);\n        float wSphereDist = max(distance(pos, wSpherePos), 0.01);\n        float planeDist = pos.y + 10.;\n        \n        float minDist = min(min(bSphereDist, wSphereDist), planeDist);\n        \n        pos += vel * (minDist / 2.);\n        life += 1.;\n        \n        vec3 bForce = normalize( bSpherePos - pos ) * 0.05 / pow( length( bSpherePos - pos ), 2. );\n        vec3 wForce = normalize( wSpherePos - pos ) * 0.05 / pow( length( wSpherePos - pos ), 2. );\n        vel = normalize(vel + bForce + wForce * minDist);\n\n        if( planeDist < 0.01 )\n        {    \n            \n            color = vec4(1);\n            \n        \tif( mod(pos.x, 8.) > 4. && mod(pos.z, 8.) > 4. )\n            {\n                color = vec4(vec3(0), 1);\n                \n                if( pos.x > 0. ){ color = vec4(vec3(1, 0, 0), 1); }\n                \n            }\n        }  \n        else if ( bSphereDist <= 0.1 )\n        {\n         \n            vec3 relative = pos - bSpherePos;\n            pos = wSpherePos + relative;\n            \n        }\n        else if ( length(pos) > 300. ) {\n            \n            color = vec4(vec3(0.3), 1); \n            break;\n        \n        }\n            \n    }\n    \n    return traceResult( pos, color );\n    \n}\n\nvec3 toSphere( float azimuth, float inclination )\n{\n    return vec3(\n        cos(inclination) * cos(azimuth),\n        sin(inclination),\n        cos(inclination) * sin(azimuth)\n  );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}