{
    "Shader": {
        "info": {
            "date": "1557592937",
            "description": "use mouse.\nAll 17of17 walpaperGroup tilings in 1 shader\nuv-mapping is still a bit inconsistent between many wallpapers, but each works on his own.\nUnique TileID are not returned.\n\np6m and p3m1 have a scaleablility bug. sloppy hex-modulo.",
            "flags": 0,
            "hasliked": 0,
            "id": "WtXGWj",
            "likes": 5,
            "name": "full WallpaperGroup",
            "published": 3,
            "tags": [
                "tiling",
                "tiles",
                "lattice",
                "skew",
                "wallpapergroup",
                "wallpapergroup",
                "p6m",
                "p31m",
                "p3m1",
                "p1",
                "p2",
                "wallpapergoup",
                "cmm",
                "pmm",
                "p4g",
                "p4m",
                "pmg",
                "pg"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 805
        },
        "renderpass": [
            {
                "code": "//you might want to pause time at iTime==0\n\n//https://en.wikipedia.org/wiki/Wallpaper_group\n//gives examples how to use this for\n//wallpapers,FbmNoise/textures,weaves,fenches,pavement,brickwork,carpet,tablecloth,decor\n//...,complexTransformations,SphereInversions,MoebiusTransformations\n//May use patterns as visual aid, to distinct monochroime objects from another, useful for colorblind-modes.\n//[WallpaperGroup] is the 2d extension to [friezeGroup] within [SpaceGropu]s:\n//https://www.shadertoy.com/results?query=frieze\n\n//[skewIt] skew()ing barely makes sense for most cases, especially not for the 5of17 hex-tilings, but it is not completely useless.\n//skewit is better implemented within non-hex-ztilings of :: https://www.shadertoy.com/view/tts3D2\n//efine skewIt\n\n//2d zoom\n//#define ViewZoom mix(1.,29.,-cos(iTime*.3)*.5+.5)\n#define ViewZoom 6.\n\n/*\n2 lines of code for editing are named:\n- [[17 of 17 wallpaper group function names]]\n- [[change function name here              ]]\n\n\n--- Tags:\nWallpaperGoup,cmm,pmm,p1,p2,p4g,p4m,pmg,pg,p3m1,p31m,p6m,tiling,lattice,skew,tiles\n\nAll 17of17 walpaperGroup tilings in 1 shader\nthe uv-mapping is still a bit inconsistent between \nmany of 2 different wallpapers, (most of them lack blue)\n, but each works on his own.\nUnique TileID are not returned.\n\n\n\nself         : https://www.shadertoy.com/view/WtXGWj\nparent skew  : https://www.shadertoy.com/view/lltcR7\nparent glide : https://www.shadertoy.com/view/XsfBDH\nrecipe       : https://twitter.com/ollj/status/112690634711778508\ntwitter image: https://twitter.com/ollj/status/1127276851171418112\n\nis still missing some fine tuning\np6m and p3m1 have a scaleablility bug. sloppy hex-modulo.\n\nis still full of older parent code (mostly evacuated to commonRab)\n*/\n\n\n//below are subroutines for WallpaperGroup\n\nvec2 md0(vec2 u//mirror diagonally slash\n){if(u.x<u.y)u=u.yx//*vec2(1,-1)\n ;return u;}\n\nvec2 md1(vec2 u//mirror diagonally backslash\n){u.y=-u.y\n ;u=md0(u)\n ;u.y=-u.y\n ;return u;}\n\nvec2 mh(vec2 u//glideReflect horizontally\n){u.y=abs(u.y)\n ;return u;}\n\n\nvec2 gh(vec2 u//glideReflect horizontally\n){if(u.y<0.)u.x=-u.x\n ;u.y=abs(u.y)\n ;return u;}\n\nvec2 gd0(vec2 u//glideReflect diagonally slash\n){if(u.x<u.y)u.xy=-u.yx\n ;u=md0(u)\n ;return u;}\n\nvec2 gd1(vec2 u//glideReflect diagonally backslash\n){u.y=-u.y\n ;u=gd0(u)\n ;u.y=-u.y  \n ;return u;}\n\nvec2 pmgs(vec2 u//pmg is a special snowflake\n){if(u.x<.0)return vec2(u.x,abs(u.y))\n ;return vec2(0,1)-abs(u);}\n\n//*s functions are subsets, without modulo-context.\n//they are scaling.-oblivious, as this is to be defined by the context!\n\nvec2 p4S(vec2 u){//p4, you are so odd, but i crunched you!\n       /* ;     if(!((u.x>0.||u.y<0.)&&(u.x<0.||u.y>0.)))*/\n ;if(sign(u.x)!=sign(u.y))u=u.yx*vec2(-1,1) \n   // ;else if(u.x>0.&&u.y<0.)u=u.yx*vec2(-1,1)\n  //  ;     if(u.x<0.&&u.y>0.)u=u.yx*vec2(-1,1) \n   // ;else if(u.x>0.&&u.y<0.)u=u.yx*vec2(-1,1) \n;return gh(u);}\n\nvec2 p4gs(vec2 u){return md1(p4S(u)*2.-.5);}//what an offset!\n\nvec2 pggs(vec2 u//tricky bastard!\n){u=gh(u)\n ;vec2 d=vec2(u.x,-u.x)+u.y-1.;\n ;d.x=max(d.x,d.y)\n ;if(d.x>0.)return mix(vec2(1)-gd1(u),gd0(u)+vec2(-1,1),step(u.x,0.))\n ;return u;}\n/* //THAT tricky:\nvec2 pggsbackup(vec2 u){//this one was hard, this was my first sucess to getting pggs()\n ;u=gh(u)\n ;if(u.x+u.y-1.>0.)return (gd1(u)*vec2(-1,-1)+vec2(1,-1)*vec2(-1,-1))+vec2(2,0)\n ;if(u.x-u.y+1.<0.)return gd0(u)+vec2(-1,1)\n ;return u;}*/\n\n//see mercury.sexy/hg.sdf\nvec2 pmod2(vec2 u){return fract(u-.5)-.5;}//no floor returned\n\n//below are beta-wrappers of the above\n//i have not yet decided on how to unify them \n//as scaling are a bit off between a few of them\n\nfloat pModPolar(inout vec2 p, float repetitions// mercury.sexy/hg.sdf\n){float angle = 2.*pi/repetitions\n ;float a = atan(p.y, p.x) + angle/2.\n ;float r = length(p)\n ;float c = floor(a/angle)\n ;a = mod(a,angle) - angle/2.\n ;p = vec2(cos(a), sin(a))*r\n ; // For an odd number of repetitions, fix cell index of the cell in -x direction // (cell index would be e.g. -5 and 5 in the two halves of the cell): \n ;//if (abs(c) >= (repetitions/2.)) c = abs(c); \n ;return c;}\n\nvec2 p3m1S(vec2 u//confirmed, is p3m1, a simple one\n){float g=pModPolar(u,6.)\n ;u-=vec2(sqrt(3.)*2./6.,0.)\n ;float yy=mod(g,2.)\n ;if(yy>0.)u=vec2(u.x,-u.y)//needed for p3m1\n ;return u;}\n\nvec2 p3S(vec2 u//p3 looks strange in its star form, but thisis indeed [p3]\n){float g=pModPolar(u,6.)\n ;u-=vec2(sqrt(3.)*2./6.,0.)\n ;float yy=mod(g,2.)\n ;g=pModPolar(u,3.)\n ;if(yy>0.)u=vec2(-u.x+.575,-u.y)\n ;return u;}\n\nvec2 p6S(vec2 u//confirmed, is p6 (each triangle rotates the same angle)\n){float g=pModPolar(u,6.)\n ;u-=vec2(sqrt(3.)*2./6.,0.)\n ;float yy=mod(g,2.)\n ;g=pModPolar(u,3.)\n ;return -u;}//-u is an arbitiary sign flip, if only to distinguish it by making it blue!\n\nvec2 p31mS(vec2 u//confirmed, is p31m, triangle rotation oscillates, so there is mirror symmetry at triangle borders.\n){float g=pModPolar(u,6.)\n ;u-=vec2(sqrt(3.)*2./6.,0.)\n ;float yy=mod(g,2.)\n ;g=pModPolar(u,3.)\n ;if(yy>0.)u=vec2(u.x,-u.y)\n ;return u;}\n\nvec2 p6mS(vec2 u//confirmed is p6m\n){float g=pModPolar(u,6.)\n ;//u-=vec2(sqrt(3.)*2./6.,0.)//not essential, but shows hex borders\n ;u.y=abs(u.y)//this abs() is p6m specific\n ;u=u.yx//not needed, but you may want to sqivel uv to make the [f]-shape fit.\n ;return u;}\n\n//theres a lot to optimize \n//as the aviove 5 functions are pretty similar:\n\n/*\n//barycentric to carthesian,carthesian is weighted average of barycentrics.\nvec2 b2c(vec3 l,vec2 a,vec2 b,vec2 c){//Barycentric2Carthesian\n ;return vec2(ad(vec3(a.x,b.x,c.x)*l),ad(vec3(a.y,b.y,c.y)*l))\n//;mat3 m=matrixCompMult(transpose(mat3(a,0,b,0,c,0)),mat3(l,l,0,0,0));return vec2(suv(m[0]),suv(m[1]))\n ;}\n//carthesian to barycentric\nvec3 c2b(vec2 u,vec2 a,vec2 b,vec2 c//there are more elegant versions of this with inverse()of the right matrix.\n){u-=c;b.y-=c.y;a.x-=c.x;c.x-=b.x;b.x=b.y*a.x+c.x*(a.y-c.y)//determinant\n ;vec3 r=vec3(ad(u*vec2(b.y,c.x)),ad(u*vec2(c.y-a.y,a.x)),0);r.z=ad(r.xy);r/=b.x;r.z=1.-r.z ;return r;}\n/**/\n\nvec2 pmodHex(vec2 u\n){float s=sqrt(3.)\n ;u.x=(fract(u.x/s-.5)-.5)*s\n ;u=r2(pi/3.)*u\n ;u.x=(fract(u.x/s-.5)-.5)*s \n ;u=r2(pi/3.)*u\n ;u.x=(fract(u.x/s-.5)-.5)*s \n ;u.y=(fract(u.y-.5)-.5)\n/**/\n //u sure hope theres a better way than this, but i cound lot fint it instantly.\n ;//u*=r2(pi/3.)\n ;//u.y=(fract(u.y*s-.5)-.5)/s\n     //do i really need a wallpaper tiling to complete this?\n    /*\n //nope this is nothow that works:\n ;vec2 a=vec2(0,-2)\n ;vec2 b=vec2(0,2)\n ;vec2 c=vec2(1.,sqrt(3.))*2.\n ;vec3 l=c2b(u,a,b,c)\n ;l=fract(l)\n ;u=b2c(l,a,b,c)\n/**/\n ;return u;\n //insert hexagonal tiling here.\n //aw shit this must be a vec3 modulo in barycentric cordinates, right?\n;}\n\nvec2 pmodHexB(vec2 u\n){//this one is a sloppy patch for 2 bad cases:\n ;float s=sqrt(3.)\n ;u.x=(fract(u.x/s-.5)-.5)*s\n ;u=r2(pi/3.)*u\n ;u.x=(fract(u.x/s-.5)-.5)*s \n ;u=r2(pi/3.)*u\n ;u.x=(fract(u.x/s-.5)-.5)*s \n ;u=r2(pi/3.)*u\n ;u.x=(fract(u.x/s-.5)-.5)*s \n ;u=r2(pi/3.)*u\n ;u.x=(fract(u.x/s-.5)-.5)*s \n ;u=r2(pi/3.)*u\n ;u.x=(fract(u.x/s-.5)-.5)*s \n ;u=r2(pi/3.)*u\n ;u.x=(fract(u.x/s-.5)-.5)*s\n // thereare never enough iterations for this, this is a BAD patch\n  ;return u;}\n//p3m1 does not play nice in pmodHex()\n//p6m does not placx nice in pmodHex()\n//really, these need to do a full rotation, and more?\n//sloppy work, but its a first semi-working draft!\n\n\n\n//[[17 of 17 wallpaper group function names]]\nvec2 p3m1(vec2 u){return p3m1S(pmodHexB(u));}\nvec2 p31m(vec2 u){return p31mS(pmodHex(u));}\nvec2 p3  (vec2 u){return   p3S(pmodHex(u));}\nvec2 p6  (vec2 u){return   p6S(pmodHex(u));}\nvec2 p6m (vec2 u){return  p6mS(pmodHexB(u));}\n//above are barycentric (need a hexagonal lattice)\n//below are carthesia, (need a rectangle|square-lattice)\nvec2 cmm(vec2 u){return    md1(md0(pmod2(u)));}\nvec2 cm (vec2 u){return        md0(pmod2(u));}\nvec2 pm (vec2 u){return        mh (pmod2(u));}\nvec2 pmm(vec2 u){return     mh(mh (pmod2(u).yx).yx);}//swivel gallore.\nvec2 p1 (vec2 u){return           (pmod2(u));}\nvec2 p2 (vec2 u){return        gd0(pmod2(u));}\nvec2 p4 (vec2 u){return        p4S(pmod2(u));}\nvec2 p4g(vec2 u){return       p4gs(pmod2(u));}\nvec2 pmg(vec2 u){return       pmgs(pmod2(u/2.)*2.);}//pmg is a special snowflake\nvec2 pgg(vec2 u){return       pggs(pmod2(u   )*2.);}\nvec2 pg (vec2 u){return        gh (pmod2(u));}\nvec2 p4m(vec2 u){return mh(md1(md0(pmod2(u))));}\n//skew() and unskew() kinda work on both types, but not too well.\n\n\nvoid all5Hexos(inout vec2 u,inout vec2 m,float s){\n #ifdef skewIt\n ;u=mix(u,skew(u),s)\n ;m=mix(m,skew(m),s)\n #endif\n ;if(length(u+cs(iTime))<ViewZoom*.3 //central circle\n  ){u=  p3  (u)  \n   ;m=  p3  (m)  \n ;}else{                      //4 corners  \n   if(u.y-sin(u.x+iTime)*.5>0.\n   ){if(u.x-sin(u.y+iTime)*.5>0. //top right\n    ){u=  p6  (u)  \n     ;m=  p6  (m)\n    ;}else{                    //top left\n     ;u=  p3m1  (u)\n     ;m=  p3m1  (m)  \n     ;}  \n   ;}else{\n    ;if(u.x-sin(u.y+iTime)*.5>0.//bottom right\n    ){u=  p31m  (u)  \n     ;m=  p31m  (m)\n    ;}else{                   //bottom left\n     \n     ;u=  p6m  (u)  \n     ;m=  p6m  (m)  \n         ;}}} \n #ifdef skewIt\n ;u=mix(u,unskew(u),s)\n ;m=mix(m,unskew(m),s) \n #endif \n ;}\n\n\nvoid mainImage(out vec4 o,vec2 u\n){o=vec4(1)\n ;vec2 m=fra(iMouse.xy)\n ;if(iMouse.z<=0.)   m.xy=cs(iTime*vec2(.5,.61)*.2)*ViewZoom*.5\n ;u=fra(u)\n ;//o=parent(o,u)\n ;vec2 K=(vec2(1,4)+u5(vec2(.5,2)*cs(iTime*8.                    )))//wiggly j-shape proportions\n ;float s=-cos(iTime)*.5+.5\n ;//s=0.\n  #ifdef skewIt\n  ;u=mix(u,skew(u),s)\n  ;m=mix(m,skew(m),s)\n  #endif\n  ;\n    \n  //#if 1\n  #if 0       //set this to:  #if 1\n  ;u=  pmg  (u)//[[change function name here]]  \n  ;m=  pmg  (m)//[[change function name here]]\n  #else\n  ;all5Hexos(u,m,s*2.-1.)//demo 5 hexagonal wallpaper tiles in one view\n  #endif\n  #ifdef skewIt\n  ;u=mix(u,unskew(u),s)\n  ;m=mix(m,unskew(m),s) \n  #endif\n ;o.xyz=vec3(smoothFf((u-m)*1.5,K))\n ;if(u.x>iResolution.y-u.y)o.x=0.\n ;o.xz=u+.5\n ;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi acos(-1.)\n//float TAU=6.28318530718;\n\n\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y//usually first function of mainImage(),not typecast.\n\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define ss(a,u)smoothstep(a,-a,u)\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\nv0 ad(v3 a){return dot(v3(1),a);}\nv0 ad(v2 a){return dot(v2(1),a);}\nv0 ad(v1 a){return a.x+a.y;}//aka suv()\nv0 ma(v1 a){return max(a.y,a.x);}\nv0 ma(v2 a){return max(a.z,ma(a.xy));}\nv0 ma(v3 a){return max(ma(a.zw),ma(a.xy));}\n#define mi(a)-ma(-a)\n\n#define mStretch(u,m).5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n\n//vec2 c2p(vec2 u){return vec2(length(u),atan(u.y,u.x));}\n//vec2 p2c(vec2 u){return cs(u.y)*u.x;}\nvec2 cs(vec2 a){return vec2(cos(a.x),sin(a.y));}\nvec2 cs(float a){return vec2(cos(a),sin(a));}\nmat2 r2(float a){vec2 s=cs(a);return mat2(s,-s.y,s.x);}\n\n#define mad(a,b,c)((a)*(b)+(c))\n#define ab012(a,b)mad(vec3(0,1,2),b,a)\n#define c11(a,b)clamp(a/b,-1.,1.)*b\n\n#define rs3 sqrt(3.)\n#define rs5 sqrt(5.)\n#define u2(a)((a)*2.-1.)\n#define u3(a)((a)*2.+1.)\n#define u4(a)((a)*.5-.5)\n#define u5(a)((a)*.5+.5)\n#define phi u4(rs5)\n#define Phi u5(rs5)\n//(reciprocal) [skewConstant] arithmetic:   [rs*]==[reciprocal square of *]\n// ske==.36602540378;//==sqrt(3.)*.5-.5\n#define   ske u4(rs3)\n//reSke=.21132486540;//==(sqrt(3.)*.5-.5)/sqrt(3.)==.5-.5/sqrt(3.)\n#define reSke u4(rs3)/rs3\n//enter [0.366025] or [.2113248654] in search engines and be amazed by peoplewho use values without knowing them\nvec2   skew(vec2 u){return u+ad(u)*ske;}\nvec2 unskew(vec2 u){return u-ad(u)*reSke;}\n\n\n#define doublestretch\nfloat jj(vec2 u,vec2 m){u+=m*.5//parametric j-shape m sets limb lengths.\n ;if(!(u.y-1.>0.||u.x+1.<0.))return abs(length(u-vec2(-1,1))-2.)//<-bottom right curve;\n ;m=abs(m)\n ;vec2 b=vec2(u.x-1.,mStretch((u.y-1.),m.y))//<-top right straight has priority\n ;u.y+=1.\n #ifdef doublestretch\n  ;u.x=mStretch(u.x,(m.x+1.));//bottom left straight STRETCH is optional here\n #else\n  ;u.x+=1.\n #endif \n ;vec2 c=u*sign(u.x+u.y+2.001)//<-bottom left straight,includes uncanny reflection\n ;u.y=sign(u.y-1.)+1.\n ;c=.5*u.y*(b+c)-c//c=mix(c,b,sign(u.y-1.)*.5+.5)\n ;return length(c);}\n\nfloat ff(vec2 u,vec2 m//parametric f-shape m sets limb lengths.\n){vec2 v=u\n ;v.x=abs(abs(v.x-.75)-1.)+1.//-.2\n ;//v.x/=2.\n ;//u.x=abs(u.x+2.)\n ;float a=length(v-m+vec2(0,4))\n ;return min(a,jj(-u,m))\n ;}\n\n\nfloat smoothFf(vec2 U,vec2 K){\n ;return smoothstep(.1,-.1,abs(ff(U*19.,K)-.6)-.3);}\n\n\n/*\n//generalized \"rainbow\" by ollj\n//return y of f(u.x)which is a triangle wave,slanted sideways by u.x that is also sinusoidial continuity,but not for:0.!=u.y!=1.\n//looks best if u.y=clamp(m.x,0.,1.)-15./iResolution.y;,for a \"smoothstepSine()wihin 1/15 subpixel.\nfloat sawCos(vec2 u){u.x=fract(u.x);u+=(1.-2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0.,1.)*pi)*.5+.5;}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a,vec3 r){return sawCos(a,1.-15./r.y);}\n\nvec3 sawCos(vec3 a,vec3 b){a=fract(a);vec3 s=step(b,a);return u5(cos(sat(1.-(a-u2(a)*s)/(b-u2(b)*s))*pi));}//b range [0..1]\n//c=sawCos(vec3(u.x*10.),vec3(.25,.5,.75))\n\n/*\nvec3 rainbow(float a,float b){return abs(u2(fract(ab012(a,b))));}//tri rainbow with offsets\nvec3 rainbow2(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//cos rainbow with offsets\n//getting sawcos to generallygo from purple to purple is a challenge that i refuse for now.\nvec3 rainbow3(float a,float b){return (sawCos(ab012(a+.5,b),vec3(.75)));}//sawCos rainbow with offsets\n\n/*\n//good rainbow-gradients ALWAYS center green|white and border purple|black\n//m.x sets saturation==transition by shifting blue|red rang[-.1,.5]\n//m.y sets \"flimmer\",range [-.159 ...159]\n//p is a flimmer-phase that modulates the shorter subwave of red (green)blue;try;p=1.+vec3(-1,0,1)*cos(iGlobalTime*.001)\nvec3 rainbowN(float t,vec2 u,vec2 m,vec3 p,vec3 r\n){vec3 c=vec3(1)//;m=vec2(0)//simple case\n//;c=sawCos(vec3(u.x*10.),vec3(.25,.5,.75))\n ;m.x=c11(-m.x,.5)//good optional bounds,sign negation for utility.\n ;m.y=c11(m.y,.159)//decent optional bounds to stay in visible range\n ;m.y=m.y*pi+.5\n ;m.y=u5(m.y)\n ;c=rainbow3(u.x-m.x*.5,fract(m.x*.6))//the .mx/2 ensures that white/green stays centred and purple stys bordered;\n//;c=mix(c*m.y,c,cos(u.x*p*iResolution.x/4.))\n ;c=mix(c*m.y,c,sawCos(u.x*p*r.x/4.,vec3(.8)))\n ;vec2 v=u\n ;u.x*=m.y\n ;float g=cos(t)//;g=.1//a 3rd domain as time for demoing,whould actually be constant\n//;c=gradVis(c,u,v)//a graph plotter,not included here.\n ;return c;}\nvec3 rainbowN11(float t,vec2 u,vec3 r){return rainbowN(t,u,vec2(1),vec3(1),r);}\n*/\n\n/*\n//do 3x3 taps for a shape with kerning (it repeats AND overlaps skewing AND rotating tile borders)\n#define doNeighborhood\n\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define aa (min(iResolution.x,iResolution.y)/ViewZoom)\n\n\n//color of outlined shape (bound by tile borders)\n#define cOutlined vec3(0,0,0)\n\n//color of cursor\n#define cCursor vec3(u5(cos(iTime*2.)))\n\n\n\n\n\nfloat TinyDith(vec2 a){;if(fract(a.x*a.y)>.5)return 1.;return 0.;}\n\n\nvec4 greyBorderCoss(vec2 U,vec4 o){\n ;U=abs(U)\n ;return smoothstep(.5,-.5,min(U.x,U.y)-1.)*(vec4(.5,.5,.5,1.)-o)+o;}\n\nfloat neighborhood(vec4 o,float t,vec2 u,mat2 r,vec2 m,vec2 U,vec2 K\n#ifndef doNeighborhood\n){return 0.;}           \n#else\n){float d=0.\n ;for (float i=-1.;i<2.;i++){for (float j=-1.;j<2.;j++ //[kerning] 3x3 neighborhood\n ){vec2 a=u-m+vec2(i,j)\n  ;if(U.y<0.)a=mix(a,unskew(a),t)\n  ;a=r*a\n  ;d+=smoothstep(.01,-.01,ff(a*19.,K)-.3)\n  ;}};return d;;}\n#endif\n\n\nvec4 cursor(vec2 U,vec2 M,vec2 K,vec4 o,vec3 c\n){U=(U-M)/iResolution.xy\n ;U.y*=iResolution.y/iResolution.x\n ;U*=3.*iResolution.x/vec2(512.) //very hacky     \n ;o.xyz=mix(o.xyz\n           ,c\n           ,smoothstep(.1,-.1\n                       ,abs(ff(U*19.,K)-.6)-.3))\n ;return o;}\n\n\n\n\n\n//I know this is sloppy, all good prototypes are designed to learn from experimental failures:\n//parent shader was an older semi mess, but full of useful subroutines\nvec4 parent(vec4 o,vec2 u\n){float td=TinyDith(u)//basic dithering of 2 complemenraty,usually alternating complemenraty colors,avoids a mixing to grey.\n ;u     =u        -.5*iResolution.xy\n ;vec2 m=iMouse.xy-.5*iResolution.xy\n ;vec2 U=u\n ;vec2 M=m;\n ;mat2 r=mat2(1)\n ;if(u.x>0.)r=r2(iTime*.1)\n ;u*=r\n ;m*=r\n ;float t=cos(iTime+pi)*.5+.5\n ;o=vec4(1)\n ;u/=164.;m/=164.\n ;if(U.y<0.\n ){u=mix(u,skew(u),t)//t*skew(u)+(1.-t)*u\n  ;m=mix(m,skew(m),t);}\n ;vec2 a=u-fract(u+.5)//fract,with offset\n ;u=u-floor(u+.5)//floor,with offset\n ;m=m-floor(m+.5)//floor,with offset \n #ifdef MirrorTest\n ;if(td>.5){//additional symmetry is ghosted\n  ;if(u.x<.0)u.x=-u.x//works but is not super pretty (the mirror is skewed badly)\n  ;//if(u.x<u.y)u=-u//works but is not pretty (more issues)\n  ;//if(u.y<.0)u.y=-u.y//works but is is dumb and doesnt fo gell with a j-shape (more issues)\n ;}\n #endif\n ;vec2 k=(vec2(1,4)+u5(vec2(.5,2)*cs(iTime*8.+a.x*4.-a.y*sqrt(5.))))//wiggly j-shape proportions tile dependent\n ;vec2 K=(vec2(1,4)+u5(vec2(.5,2)*cs(iTime*8.                    )))//wiggly j-shape proportions\n //uniting both would require to calculate the above wiggle 9 times,witzhin the O(n*n)loop below,not doing that\n ;o.xyz=rainbowN11((a+a.yx)*vec2(phi,.5))//base tile color\n ;o.xyz-=smoothstep(.1,-.1,u.x-u.y)*u2(o.xyz)//changes diagonal half to complementary color.\n ;//if(u.x>u.y)o.xyz=1.-o.xyz//grey line over diagonal instead of complemenraty color on other half.     \n ;float                                 e=neighborhood(o,t,u,r,m,U,K)\n ;o.xyz=mix(o.xyz,vec3(u5(cos(U*.1)),1),e)\n ;if(U.y<0.)u=mix(u,unskew(u),t)//if(lower half of screen) unskew()\n ;//u=r*u //optional rotate of hollow repeated shape\n ;o.xyz=mix(o.xyz\n           ,cOutlined\n           ,smoothstep(.1,-.1\n                       ,abs(ff((u-r*vec2(0,0))*19.,k)-.361)-.1))\n ;o=greyBorderCoss(U,o)\n ;o=cursor(U,M,K,o,cCursor)\n ;return o;}\n\n\n/**/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}