{
    "Shader": {
        "info": {
            "date": "1577735889",
            "description": "Raymarching tutorial exercise with composite object and simple anti alias.",
            "flags": 0,
            "hasliked": 0,
            "id": "wl3GDf",
            "likes": 2,
            "name": "Raymarch Tutorial v03",
            "published": 3,
            "tags": [
                "raymarch",
                "tutorial",
                "antialias",
                "composite"
            ],
            "usePreview": 0,
            "username": "tombla",
            "viewed": 379
        },
        "renderpass": [
            {
                "code": "// Based on youtube tutorial\n// https://www.youtube.com/watch?v=PGtv-dBi2wE\n// Raymarched scene with antialiasing (9 samples).\n\n#define SPHERE_POS_1 vec3(0., 0.7, 6.)\n#define SPHERE_RAD_1 1.\n#define SPHERE_POS_2 vec3(-0.6, 0.7, 5.4)\n#define SPHERE_RAD_2 0.5\n#define PLANE_POS 0.\n#define LIGHT_POS vec3(-0., 6., 2.)\n#define JUMP_SPEED 1.4\n\n#define AA_PIXEL_STEP 0.8\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define CLOSENESS 0.01\n\nvec2 rescale(in vec2 p) {\n    return vec2((p - 0.5 * iResolution.xy) / iResolution.y);\n}\n\nfloat twoUnion(float a, float b) {\n    return min(a, b);\n}\n\nfloat twoSubtract(float a, float b) {\n    return max(a, -b);\n}\n\nfloat twoIntersect(float a, float b) {\n    return max(a, b);\n}\n\n// Get distance to sphere 1.\nfloat getDistSphere1(vec3 p) {\n    vec3 spherePos = SPHERE_POS_1;\n    float x = mod(iTime * JUMP_SPEED, 2.);\n    spherePos.y += 1.7 * (1. - (x - 1.) * (x - 1.));\n    float dS = length(spherePos - p) - SPHERE_RAD_1;\n    return dS;\n}\n\n// Get distance to sphere 2.\nfloat getDistSphere2(vec3 p) {\n    vec3 spherePos = SPHERE_POS_2;\n    float x = mod(iTime * JUMP_SPEED, 2.);\n    spherePos.y += 1.7 * (1. - (x - 1.) * (x - 1.));\n    float dS = length(spherePos - p) - SPHERE_RAD_2;\n    return dS;\n}\n\n// Get distance to both spheres.\nfloat getDistSpheres(vec3 p) {\n    float dS1 = getDistSphere1(p);\n    float dS2 = getDistSphere2(p);\n    return twoSubtract(dS1, dS2);\n}\n\n// Get distance to plane and spheres.\nfloat getDistAll(vec3 p) {\n    float dS = getDistSpheres(p);\n    float dP = p.y - PLANE_POS;\n    return min(dS, dP);\n}\n\nfloat rayMarch(vec3 origin, vec3 direction) {\n    float dist = 0.;\n    for(int i=0; i < MAX_STEPS; ++i) {\n        vec3 ray = origin + direction * dist;\n        float step = getDistAll(ray);\n        dist += step;\n        if (step < CLOSENESS || dist > MAX_DIST) break;\n    }\n    return min(dist, MAX_DIST);\n}\n\nvec3 getNormal(vec3 p) {\n    float toSurface = getDistAll(p);\n    vec2 e = vec2(0.01, 0.);\n    vec3 plane = toSurface - vec3(\n        getDistAll(p - e.xyy),\n        getDistAll(p - e.yxy),\n        getDistAll(p - e.yyx));\n    return normalize(plane);\n}\n\nfloat getLight(vec3 p) {\n    vec3 lightPos = LIGHT_POS;\n    lightPos.xz += 2. * vec2(sin(iTime), cos(iTime));\n    vec3 lightVector = normalize(lightPos - p);\n    vec3 surfaceVector = getNormal(p);\n//    float diffusion = dot(surfaceVector, lightVector);\n    float diffusion = dot(lightVector, surfaceVector);\n    diffusion = clamp(diffusion, 0., 1.);\n\n    float toLight = rayMarch(p + surfaceVector * 1.05 * CLOSENESS, lightVector);\n    if (toLight < length(p - lightPos)) {\n        diffusion *= 0.3;\n    }\n\n    return diffusion;\n}\n\n// Returns non-aliased distance (x) and diffusion (y)\nvec2 singleRay(vec2 uv) {\n    // Camera position\n    vec3 ro = vec3(0., 1., 0.);\n    // Camera direction\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    // Distance to a shape.\n    float dist = rayMarch(ro, rd);\n    // Point at the shape\n    vec3 ray = ro + rd * dist;\n    // Light diffusion\n    float diffusion = getLight(ray);\n    return vec2(dist, diffusion);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv1 = rescale(fragCoord-AA_PIXEL_STEP);\n    vec2 uv2 = rescale(fragCoord+AA_PIXEL_STEP);\n    vec4 uv = vec4(uv1, uv2);\n    vec3 color = vec3(1.);\n\n    vec2 scene = vec2(0, 0);\n    for(float dx = -1.; dx <= 1.1; dx += 1.) {\n        for(float dy = -1.; dy <= 1.1; dy += 1.) {\n            vec2 uv = rescale(vec2(fragCoord.x + dx * AA_PIXEL_STEP, fragCoord.y + dy * AA_PIXEL_STEP));\n            scene += singleRay(uv);\n        }\n    }\n    scene /= 9.;\n    float dist = scene.x;\n    float diffusion = scene.y;\n    color *= diffusion;\n    // Sky\n    vec3 sky = vec3(0.3, 0.3, 0.8);\n    float skyMix = smoothstep(MAX_DIST * 0.5, MAX_DIST * 0.9, dist);\n\n    // Final color\n    vec3 final = mix(color, sky, skyMix);\n\n\n    fragColor = vec4(final, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}