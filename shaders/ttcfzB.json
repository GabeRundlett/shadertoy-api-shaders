{
    "Shader": {
        "info": {
            "date": "1612966108",
            "description": "potato",
            "flags": 32,
            "hasliked": 0,
            "id": "ttcfzB",
            "likes": 11,
            "name": "Day 421",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 339
        },
        "renderpass": [
            {
                "code": "// tri sdf from iq \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord -= 0.5*iResolution.xy;\n    fragCoord *= 0.99;\n    fragCoord += 0.5*iResolution.xy;\n    \n    float n1d = texelFetch(iChannel1,ivec2(mod(fragCoord + vec2(float(iFrame),0.),256.)),0).x;\n    vec3 n  = texelFetch(iChannel1,ivec2(mod(fragCoord  + n1d*200. ,256.)),0).xyz;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    fragColor.xyz =texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(1.1,1.2,1.));\n    \n    //fragColor.xyz = 1. - fragColor.xyz;\n    \n    //fragColor.xyz *= 1. - dot(uv,uv)*0.8;\n    fragColor.xyz = pow(fragColor.xyz, vec3(0.4545 + n*0.15));\n    \n    \n    \n    //fragColor = texture(iChannel2,fragCoord/iResolution.xy);\n    \n    fragColor.xyz += smoothstep(1.,0.,length(fragColor))*n*0.04;\n    \n    fragColor.xyz -= smoothstep(0.,1.,length(fragColor))*n*0.05;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\nmat3 getOrthogonalBasis(vec3 dir){\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return mat3(right,up,dir);\n}\n\nfloat cyclicNoise(vec3 p){\n    \n    //p.yz *= rot(1.4);\n    \n    float n = 0.;\n    float amp = 1.;\n    float gain = 0.5;\n    float lac = 1.1 ;\n    \n    vec3 seed = normalize(vec3(3,-1,2));\n    mat3 rotm = getOrthogonalBasis(seed);\n\n    for(float i = 0.; i < 5.; i++){\n        p -= cos(p.zxy*1.5*gain*2. + iTime + i)*0.1;\n        n += (dot(sin(p), cos(p.zxy)))*amp;\n    \n        amp *= gain;\n        p *= lac*rotm;\n\n    }\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    \n    float vn = valueNoiseStepped(iTime/4.5 ,2.,3.);\n    \n    \n    vec3 col = vec3(1.,0.9,0.9)*1.;\n    \n    uv *= rot(0.5);\n    \n    col -= 0.1*smoothstep(0.4,0.3,texture(iChannel2,(uv + vec2(0,(iTime - vn)*0.1))*0.1 ,1.).x);\n    \n    float dfuv = fwidth(length(uv));\n    \n    vec2 p = uv;\n    float pixelW = dFdx(p.x);    \n    \n    \n    float gd = 10e5;\n    for(float j = 0.; j < 122.; j++){\n        vec2 r = r12(j);\n        float rb = r11(j);\n        vec2 p = uv;\n        \n        \n        \n        float t = iTime + r11(j)*140.;\n        \n        float sp = 1. + r.y*4. + vn*0.5;\n        \n        sp *= 2.8;\n        p.x += (sin(r.x*20.)*1. )*iResolution.x/iResolution.y*0.5;\n        \n        float tid = t/sp/1.95; \n        p.y -= mod(t/sp,1.95) - 1.;\n        \n        \n        p.xy *= rot(iTime*(r.y*1. - 0.5)*1.5 + r.y*20.);\n        \n        \n        vec3 c = vec3(0);\n        \n        vec3 ctri = vec3(1,0.4,1.);\n        vec3 triCol = pal(0.5,0.5*vec3(1.5,0.2,1),vec3(1,5. + 20.*r.y + iTime + uv.x,3),1.,r.x*3. + sin(iTime*0.25 )*0.8);\n        \n        \n        \n        #define getTri(p) sdTriangle( p , vec2(-0.1 - r.y*0.1,0.), vec2(0.1,-0.3*r.x),vec2(0.,0.1)) \n        float tri = getTri(p);\n        float trib = getTri(p + 0.01);\n        float tribD = smoothstep(pixelW,0.,trib);\n        \n        #define getBox(p) sdBox( p, vec2(0.1 + r.y*0.04,0.01))\n        float box = getBox(p);\n        float boxb = getBox(p + 0.01);\n        float boxbd = smoothstep(pixelW,0.,boxb);\n        \n        #define getCirc(p) abs(length( p) - 0.1) - 0.01\n        float ccirc = getCirc(p);\n        float ccircb= getCirc(p + 0.0);\n        float ccircbd = smoothstep(pixelW,0.,ccircb);\n        \n        \n        float circMod = 0.01;\n        float circD = smoothstep(pixelW,0.,length( pmod(p,circMod)) - circMod*0.1);\n        \n        float lineMod = 0.015;\n        float line = length( pmod((p*rot(0.4)).y,lineMod)) - lineMod*0.1;\n        float lineD = smoothstep(pixelW,0.,line);\n        \n        float bboxMod = 0.03;\n        vec2 q = pmod((p*rot(0.4)),bboxMod);\n        q = abs(q) - bboxMod*0.2;\n        float bbox = max(q.x,q.y)  ;\n        float bboxD = smoothstep(pixelW,0.,bbox);\n        \n        \n        \n        float d;\n        \n        if(r.x <  0.4){\n            d = tri;\n            c = triCol;\n             \n            vec3 nc = c*c*0.4;\n            col = mix(col, nc,circD*tribD);\n            c = mix(c,nc, circD*tribD);\n        } else if(r.x < 0.8){\n            d = box;\n            c = mix(triCol,vec3(1),0.5);\n            \n            vec3 nc = c*c*0.1;\n            nc.xz *= rot(0.5);\n            col = mix(col, nc,lineD*boxbd);\n            c = mix(c,nc, lineD*boxbd);\n            //gd = min(gd,max(line,-boxb));\n    \n        } else {\n            d = ccirc;\n            c = mix(triCol,vec3(1)*0.8,0.7);\n            \n            vec3 nc = c*1.*c;\n            nc.xz *= rot(-0.8);\n            col = mix(col, nc,bboxD*ccircbd);\n            c = mix(c,nc, bboxD*ccircbd);\n            \n        \n        \n        }\n        \n        vec3 oc = c;\n        oc -= 1.;\n        oc.xz *= rot(.1);\n        oc += 0.8;\n        c = mix(c, oc,smoothstep(pixelW,0.,gd));\n        \n        col = mix(col, c, smoothstep(pixelW,0.,d + 0.002));\n  \n        //if(vn < 0.1)\n        gd = min(gd,d);\n    }\n     \n    if(iMouse.z > 0.){\n        col =  1. - col;\n        col.xz *= rot(-.9);\n        col.yz *= rot(.3);\n        //col =  1. - col;\n        \n        }\n        \n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float sc = 0. + valueNoise(iTime*14.,2.)*0.1 ;\n    \n    fragColor.x =texture(iChannel0,(fragCoord + sc*vec2(0,8))/iResolution.xy).x;\n    \n    fragColor.y =texture(iChannel0,(fragCoord + sc*vec2(0,-1))/iResolution.xy).y;\n    \n    fragColor.z =texture(iChannel0,(fragCoord + sc*vec2(0,-4))/iResolution.xy).z;\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0., (d)) - 0.5*(d)\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n\nfloat r11(float i){ return fract(sin(i*15.126)*115.6);}\n\nvec2 r12(float i){float r=r11(i );  return vec2(r,r11(i + r + 2.));}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n#define dmin(a,b,c) (max(a.x,-b) < b ? a : vec2(b,c))\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}