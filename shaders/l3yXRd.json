{
    "Shader": {
        "info": {
            "date": "1720360889",
            "description": "I don't know what to call this - I wanted to generalize this shader:\nhttps://www.shadertoy.com/view/mdjcWR\n\nThanks to ollj, poisson and iq whose shaders I've lurked, and iq for the SDF visual :)\n\nImprovements greatly appreciated since it's so big",
            "flags": 0,
            "hasliked": 0,
            "id": "l3yXRd",
            "likes": 10,
            "name": "Uneven Vesica Segment - Distance",
            "published": 3,
            "tags": [
                "2d",
                "distancefield",
                "sdf",
                "line",
                "circle",
                "distance",
                "segment",
                "capsule",
                "egg",
                "moss",
                "vesica"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 147
        },
        "renderpass": [
            {
                "code": "// <-- View Common for explanation and uncommented SDF\n\n//#define DEBUG\n\nfloat seg( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 debug(vec2 u, float rp, float rq, float h, float io) \n{\n    u.x = abs(u.x); \n    vec2 p, q = vec2(0, h); \n    if (rp == rq) rp += .001; \n    float alpha = asin((rp-rq)/length(p-q));  \n    float hpi = 1.57079;\n    float a = hpi * io;\n    a += (1.-abs(io)) * alpha;\n    if (a == alpha) a += .001;\n    vec2 dir = vec2(cos(a), sin(a));\n    vec2 e = q + rq * dir;   \n    vec2 f = e - rp * dir;   \n    vec2 g = .5 * (f + p);   \n    float v1 = f.y / f.x;    \n    float v2 = v1 - h / f.x;\n    float v1v2 = v1 * v2;\n    vec2 w;\n    w.x = (g.x + v1v2 * f.x + v1 * (g.y - f.y)) / (v1v2 + 1.);\n    w.y = v2 * (w.x - f.x) + f.y;    \n    float rw = length(w - e);         \n    \n    vec2 w0, w1;\n    if (a < alpha) { \n        float rp2 = rp*rp, rq2 = rq*rq;\n        if (dot(w-p,w-p) < rp2 || dot(w-q,w-q) < rq2) {\n           w.y = (rp2 - rq2 + h*h) / (2.*h);\n           w.x = sqrt(rp2 - w.y*w.y);\n           rw = 0.;\n        } else if (w.x < rw) { \n            w0 = vec2(0, w.y + sqrt(rw*rw - w.x*w.x));\n            w1 = vec2(0, w.y - sqrt(rw*rw - w.x*w.x));      \n        }\n    }\n    \n    // --- Debug visuals --- \n    {\n    vec3 c;\n    float px = 2. / iResolution.y;\n    float d =  abs(length(u - p) - rp);\n    d = min(d, abs(length(u - q) - rq));\n    d = min(d, abs(length(u - w) - rw));\n    d = min(d, length(u-p)-.01);\n    d = min(d, length(u-q)-.01);\n    if (a < alpha) \n        d = min(d, min(seg(u, p, w), seg(u, q, w)));\n    c.r = smoothstep(-px, px, .01-d);\n    \n    vec2 dir = vec2(cos(alpha), sin(alpha));\n    vec2 pt = p + rp * dir;\n    vec2 qt = q + rq * dir;\n    d = min(length(u - pt), length(u - qt)) - .03;\n    d = min(d, seg(u, pt, qt) - .01);\n    c.g = smoothstep(-px, px, -d);\n    \n    if (w0 != vec2(0) && h > rp + rq) {\n        d = min(seg(u, w0, w), seg(u,w1, w));\n        c += smoothstep(-px, px, .01 - d);\n    }\n    \n    c += smoothstep(-px, px, .02 - length(u-e));\n    c += smoothstep(-px, px, .02 - length(u-w));\n    \n    return c;\n    }\n    // --------------------\n}\n\n\nvoid mainImage( out vec4 o, vec2 u )\n{\n    vec2 R = iResolution.xy;\n    vec2 m = (2.*iMouse.xy-R)/R.y + vec2(0, 0.53);\n         u = (u+u-R)/R.y + vec2(0, 0.53);\n         \n    float t = iTime;\n    \n    // --- Parameters ---\n    float rp = .3 + .1 * sin(.8*t);      // bottom circle radius > 0\n    float rq = .2 + .1 * cos(.9*t);      // top circle radius > 0\n    float h  = .7 + .4 * sin(.7*t);      // height >= 0\n    float io = (.6+.4*sin(.3*t))*cos(t); // in/out in [-1, 1] range\n    // ------------------\n\n    vec3 debugcol = debug(u, rp, rq, h, io);\n    float d = sdUnevenVesicaSegment(u, rp, rq, h, io);\n    \n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdUnevenVesicaSegment(m, rp, rq, h, io);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(u-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(u-m)-0.015));    \n    }\n\n\to.rgb = col;\n    \n    #ifdef DEBUG\n    o.rgb += .6 * debugcol;\n    #endif\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Overview:\n// > Start with two circles at p = (0,0) and q = (0,h)\n//   with radii rp and rq.\n// > Find the angle \"alpha\" from p and q to the mutual tangent\n//   line to both circles (visible in debug mode)\n// > Find a 3rd mutually tangent circle at w with radius rw,\n//   the position w is calculated using the angle pi/2*io\n// > if our inness/outness parameter io has pi/2*io < alpha:\n//    the 3rd circle externally touches the first 2 and we take\n//    the union of the first 2 circles with the inverse of the 3rd\n//    (8 shape)\n// > if pi/2*io > alpha:\n//    the 3rd circle contains the first 2 and we union the middle\n//    of the 3rd circle with the top and bottom of the other circles\n//    (egg shape)\n\n// Artifacts / edge cases (fixed):\n// rp == rq, pi/2*io == alpha, h < abs(rp-rq), w.x < rw\n\n// To try (probably not cheaper):\n// intersect hyperbola (loci of 3rd circles centre)\n// with other circles. either find a min angle and clamp a\n// or replace \"if (dot(w,w) < rp2)\"\n\nfloat sdUnevenVesicaSegment(vec2 u, float rp, float rq, float h, float io) \n{\n    u.x = abs(u.x);\n   \n    // Top circle. (Bottom circle p = vec2(0,0) so isn't used)\n    vec2 q = vec2(0, h);  \n       \n    // Equal sized circles (used to?) cause artifacts\n    // if (rp == rq) rp += .001;    \n        \n    // One circle containing the other causes artifacts\n    if (h <= abs(rp - rq))\n        return min(length(u)-rp, length(u-q)-rq);    \n    \n    // Angle from p and q circles at which the mutual tangent \n    // line touches both, as in:\n    // https://en.wikipedia.org/wiki/Tangent_lines_to_circles#Outer_tangent\n    float alpha = asin((rp-rq)/h);      \n    \n    // Angle from q to w\n    float a = 1.57079 * io; \n    \n    // Add this so io=-1 -> -pi/2, io=0 -> alpha, io=1 -> pi/2\n    a += (1.-abs(io))*alpha; \n\n    // Remove artifacts when 3rd circle approximates tangent line\n    // i.e. when w circle has infinite radius\n    // (a == alpha is insufficent since a = alpha + 1e-5 breaks)\n    if (abs(a - alpha) < .001)\n        a = alpha + .001;\n\n    // Get 3rd circle position w by intersecting the q-e line with \n    // the line normal to the p-f line at (f+p)/2. = f/2., as in:\n    // https://jwilson.coe.uga.edu/EMAT6680Su06/Swanagan/Assignment7/BSAssignment7.html  \n    vec2 dira = vec2(cos(a), sin(a));\n    vec2 e = q + rq * dira; // point on q circle\n    vec2 f = e - rp * dira; // point on q-e line, rp away from e towards q\n    vec2 eq = e - q;\n    float t = dot(e - f/2., f) / dot(eq, f);\n    \n    vec2 w = e - eq * t;\n    float rw = rq * abs(t); // rw = length(w-e) = length(eq*t)\n                    \n    // Vesica inwards (8 shape)\n    if (a < alpha) { \n        // If p and q circles intersect, we can't have w inside them\n        // (it breaks the sdf)\n        // so fix w = intersection of p and q circles\n        //   and rw = 0, since w lies on both circles\n        float rp2 = rp*rp;\n        if (dot(w,w) < rp2) {\n            w.y = (rp2 - rq*rq + h*h) / (2.*h);\n            w.x = sqrt(rp2 - w.y*w.y);\n            rw = 0.;\n        } \n        // Get distance to \"tips\" if :\n        // > w circle intersects x = 0 line \n        // > p,q circles don't intersect\n        // > w.y is between p.y and q.y\n        // (i.e. 8 shape looks like 2 teardrops)\n        else if (w.x < rw && h > rp + rq && 0. < w.y && w.y < h) { \n            // (v, w, w0 all have -w.y to reduce cost)\n\n            // Find the point w0 where w circle intersects x = 0\n            vec2 w0 = vec2(0, sqrt(rw*rw - w.x*w.x));\n            \n            // Mirror u.y in y = w.y line  \n            vec2 v = vec2(u.x, abs(u.y - w.y));  \n            \n            // If u is below w0-w line, use distance to tips\n            vec2 ww0n = vec2(w0.y, w.x);\n            if (dot(ww0n, v-vec2(w.x,0)) < 0.) return length(v-w0);           \n        }\n        \n        // p-w and q-w normals\n        vec2 pwn = vec2(w.y,   -w.x);\n        vec2 qwn = vec2(w.y-h, -w.x);        \n        \n        // Between p-w line and q-w line,\n        // use inverse distance to w circle\n        if (dot(pwn, u) < 0. && dot(qwn, u-q) > 0.) \n            return rw - length(u-w);  \n        \n        // else use min distance to p and q circles\n        return min(length(u) - rp, length(u-q) - rq);\n    } \n    \n    // Vesica outwards (egg shape)\n    else {\n        // p-w and q-w normals\n        vec2 pwn = vec2(w.y, -w.x); \n        vec2 qwn = vec2(-dira.y, dira.x); \n        \n        // Below p-w line, use p circle distance\n        if (dot(pwn, u)   < 0.) return length(u) - rp;  \n        \n        // Above q-w line, use q circle distance\n        if (dot(qwn, u-q) > 0.) return length(u-q) - rq;  \n        \n        // Between both lines use w circle distance\n        return length(u-w) - rw;\n    }\n}\n\n// Uncommented version\nfloat sduvs(vec2 u, float rp, float rq, float h, float io) \n{\n    u.x = abs(u.x); \n    vec2 q = vec2(0, h); \n    if (h <= abs(rp - rq)) return min(length(u)-rp, length(u-q)-rq);    \n    float alpha = asin((rp-rq)/h);      \n    float a = 1.57079 * io + (1.-abs(io))*alpha; \n    if (abs(a-alpha) < .001) a = alpha + .001;\n    vec2 dira = vec2(cos(a), sin(a));\n    vec2 e = q + rq * dira;   \n    vec2 f = e - rp * dira;  \n    vec2 eq = e - q;\n    float t = dot(e-.5*f, f) / dot(eq, f);\n    vec2 w = e - eq * t;\n    float rw = rq * abs(t);                       \n    if (a < alpha) { \n        float rp2 = rp*rp;\n        if (dot(w,w) < rp2) {\n            w.y = (rp2 - rq*rq + h*h) / (2.*h);\n            w.x = sqrt(rp2 - w.y*w.y);\n            rw = 0.;\n        } else if (w.x < rw && h > rp + rq && 0. < w.y && w.y < h) {\n            vec2 v = vec2(u.x, abs(u.y - w.y));  \n            vec2 w0 = vec2(0, sqrt(rw*rw - w.x*w.x));\n            vec2 ww0n = vec2(w0.y, w.x);\n            if (dot(ww0n, v-vec2(w.x,0)) < 0.) return length(v-w0);           \n        }\n        vec2 pwn = vec2(w.y, -w.x), qwn = vec2(w.y-h, -w.x);   \n        if (dot(pwn, u) < 0. && dot(qwn, u-q) > 0.) \n            return rw - length(u-w);  \n        return min(length(u) - rp, length(u-q) - rq);\n    } \n    else {\n        vec2 pwn = vec2(w.y, -w.x), qwn = vec2(-dira.y, dira.x);\n        if (dot(pwn, u) < 0.)   return length(u)   - rp;  \n        if (dot(qwn, u-q) > 0.) return length(u-q) - rq;  \n        return length(u-w) - rw;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}