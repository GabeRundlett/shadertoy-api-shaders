{
    "Shader": {
        "info": {
            "date": "1568299911",
            "description": "A quick example I live coded to demo some shadertoy basics for RVA Game Jams community members. Code has been cleaned up and (almost?) all the coefficients are defines at the top of the shader to make it easier to play around with ",
            "flags": 0,
            "hasliked": 0,
            "id": "wdtGWn",
            "likes": 36,
            "name": "RVA Game Jams Magic Flame Demo",
            "published": 3,
            "tags": [
                "tutorial",
                "flame",
                "demo",
                "magic"
            ],
            "usePreview": 0,
            "username": "samlo",
            "viewed": 1335
        },
        "renderpass": [
            {
                "code": "// FLAME MASK SHAPING\n#define FLAME_SIZE 2.2\n#define FLAME_WIDTH 1.3\n#define DISPLACEMENT_STRENGTH 0.3\n#define DISPLACEMENT_FREQUENCY 5.0\n#define DISPLACEMENT_EXPONENT 1.5\n#define DISPLACEMENT_SPEED 5.0\n#define TEAR_EXPONENT 0.7\n#define BASE_SHARPNESS 4.0\n\n// NOISE\n#define NOISE_SCALE 3.0\n#define NOISE_SPEED -4.2\n#define NOISE_GAIN 0.5\n#define NOISE_MULT 0.35\n\n// FLAME BLENDING\n#define FALLOFF_MIN 0.2\n#define FALLOFF_MAX 1.3\n#define FALLOFF_EXPONENT 0.9\n\n// COLOR\n#define BACKGROUND_MIN 0.0\n#define BACKGROUND_MAX 0.15\n#define RIM_EXPONENT 2.0\n#define BACKGROUND_COLOR_MIN vec3(0.2, 0.0, 0.2)\n#define BACKGROUND_COLOR_MAX vec3(0.6, 0.0, 0.4)\n#define RIM_COLOR vec3(0.0, 0.9, 0.9)\n\n// GLOW\n#define FLICKER_SPEED 4.0\n#define FLICKER_STRENGTH 0.08\n#define GLOW_OFFSET vec2(0.0, 0.1)\n#define GLOW_EXPONENT 4.0\n#define GLOW_WIDTH 1.5\n#define GLOW_SIZE 0.4\n#define GLOW_STRENGTH 0.4\n#define GLOW_COLOR vec3(0.0, 0.8, 1.0)\n\n\nvec3 permute(vec3 x)\n{ \n    return mod(((x*34.0)+1.0)*x, 289.0);\n}\n\nfloat snoise(vec2 v)\n{\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n            -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n   \tfloat aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    vec2 p = uv - vec2(0.5 * aspect, 0.5);\n    vec2 glowP = p; // this is saved for when we do our glow\n    \n    // shape our base flame mask.\n    // first we squish a circle and displace it, then we turn it into a teardrop shape\n    p *= FLAME_SIZE;\n    p.x *= FLAME_WIDTH;\n    \n    float flameDisplacement = max(0.0, sin(iTime * DISPLACEMENT_SPEED + (p.y * DISPLACEMENT_FREQUENCY)) * DISPLACEMENT_STRENGTH * pow(uv.y - 0.1, DISPLACEMENT_EXPONENT));\n    p.x += flameDisplacement;\n    p.x += p.x / pow((1.0 - p.y), TEAR_EXPONENT); // teardrop shaping\n    \n    // next we create our base flame mask, it looks a bit like a spooky ghost\n    float gradient = length(p);\n    float base = 1.0 - pow(gradient, BASE_SHARPNESS);\n    \n\t// next we create our noise mask, which we will use to create the flickering part\n    // of the flame\n    float noise = snoise((uv * NOISE_SCALE) + vec2(0.0, iTime * NOISE_SPEED)) * NOISE_MULT + NOISE_GAIN;\n    \n    // define a gradient that we can use to make the flame fall off at the top,\n    // and apply it to BOTH the flame mask and the noise together\n    float flame = (base * noise);\n    \n    float falloff = smoothstep(FALLOFF_MIN, FALLOFF_MAX, pow(uv.y, FALLOFF_EXPONENT));\n    flame = clamp(flame - falloff, -0.0, 1.0); // we have a flame!\n    \n    // time to give it some color! we will do this with two masks,\n    // a background mask, and a rim light mask\n    float background = smoothstep(BACKGROUND_MIN, BACKGROUND_MAX, flame);\n\tfloat rim = pow(1.0 - flame, RIM_EXPONENT) * background;\n    \n    // first we calculate our background color. I did a vertical gradient from dark purple to light purple,\n    // and it is multiplied by the background mask\n    vec3 color = mix(BACKGROUND_COLOR_MIN, BACKGROUND_COLOR_MAX, uv.y) * background;\n    \n    // now we apply rim light (I did cyan). We mix over our current color using the rim light mask\n    color = mix(color, RIM_COLOR, rim);\n    \n    // we could call it a day now, but lets add a little glow to give our flame a bit more ambience\n    // this time we'll make the glow flicker using noise! noise is a fantastic way to animate things as well\n    float glowFlicker = 1.0 + snoise(vec2(iTime * FLICKER_SPEED)) * FLICKER_STRENGTH;\n    glowP += GLOW_OFFSET;\n    glowP.x *= GLOW_WIDTH;\n    glowP *= GLOW_SIZE;\n        \n    vec3 glow = GLOW_COLOR * (pow(1.0 - length(glowP), GLOW_EXPONENT) * GLOW_STRENGTH * glowFlicker);\n    color += glow;    \n\n    // all done!\n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}