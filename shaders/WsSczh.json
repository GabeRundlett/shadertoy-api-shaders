{
    "Shader": {
        "info": {
            "date": "1586032604",
            "description": "A graph sorting acceleration structure designed to work efficiently with ray marching. The graph sorts an approximation of the voronoi diagram by storing the closest intersection with the bisector plane, which gives the voronoi neighbor in this direction.",
            "flags": 32,
            "hasliked": 0,
            "id": "WsSczh",
            "likes": 8,
            "name": "Voronoi graph ray marching",
            "published": 3,
            "tags": [
                "marching",
                "particles",
                "objects"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 511
        },
        "renderpass": [
            {
                "code": "//Graph is in Buf A, graph traversal is in Buf B\n//You can pause the simulation by setting dt in Common to 0.\n//Change the number of particles by changing N in Common\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    fragColor = texel(ch1, pos);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(8,32)\n#define sN ivec2(32,2)\n#define dt 1.\n\n#define loop(x) for(int i = min(0, iFrame); i < x; i++)\n\nconst int tot_n = N.x*N.y;\n\nivec2 i2xy(ivec3 sid)\n{\n    return sN*ivec2(sid.x%N.x, sid.x/N.x) + sid.yz;\n}\n\nivec3 xy2i(ivec2 p)\n{\n    ivec2 pi = p/sN;\n    return ivec3(pi.x + pi.y*N.x, p.x%sN.x, p.y%sN.y);\n}\n\nfloat F(float d)\n{\n    return 1./(0.1*d*d+1.) - 1.*exp(-1.*d);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nconst int k = 1664525;  \n\nivec4 hash( ivec4 x )\n{\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    return ivec4(x);\n}\n\n#define link0 32\n\nconst float PHI = 0.5*(sqrt(5.) + 1.);\n\nvec2 inverseSF( vec3 p, float n ) \n{\n    float m = 1.0 - 1.0/n;\n    \n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2  F  = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );    \n    \n    mat2 iB = mat2( ka.y, -ka.x, \n                    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    \n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float i = dot(F, uv + c); // all quantities are ingeters (can take a round() for extra safety)\n        \n        float phi = 2.0*PI*fract(i*PHI);\n        float cosTheta = m - 2.0*i/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta );\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return vec2( j, sqrt(d) );\n}\n\nvec4 iSF( vec3 p, float n ) \n{\n    float m = 1.0 - 1.0/n;\n    \n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2  F  = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );    \n    \n    mat2 iB = mat2( ka.y, -ka.x, \n                    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    \n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    vec4 o;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        o[s] = dot(F, uv + c); \n    }\n    return o;\n}\n\nvec3 fibonacci_sphere(int i, int n)\n{\n    vec2 pt = vec2(2.*PI*mod(float(i)/PHI, 1.), acos(1. - float(2*i+1)/float(n)));\n    return vec3(cos(pt.x)*sin(pt.y), sin(pt.x)*sin(pt.y), cos(pt.y)); \n}\n\n    \nstruct object\n{\n    vec3 X;\n    vec4 q;\n    vec3 P;\n    vec3 L;\n    int type;\n    float m;\n};\n\nvec3 qtransform(vec4 q, vec3 v)\n{ \n\treturn v + 2.0*cross(cross(v, q.xyz) + q.w*v, q.xyz);\n} \n\n//intersection with the bisector plane\nfloat rayBisectDist(vec3 p, vec3 d, vec3 a, vec3 b)\n{\n    vec3 n = b - a;\n    float D = length(n);\n    float cosnd = dot(n, d)/D; //ray plane normal angle cosine\n    float l = D*.5 - dot(p - a, n)/D;\n    float t = l/cosnd; //ray parameter\n    return (cosnd>0.)?t:1e10;\n}\n\nfloat dirBisectDist(vec3 d, vec3 a, vec3 b)\n{\n    float cosnd = dot(normalize(b - a), d); //ray plane normal angle cosine\n    return (cosnd>0.)?(distance(b,a)*.5)/cosnd:1e10;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//particle and particle neighbor directional graph buffer \n\nobject obj; vec4 lnk; \n\nvec4 d; int ID; float avgR;\n\nobject getObject(int id)\n{\n    object o;\n    vec4 p = texel(ch0, i2xy(ivec3(id, 0, 0)));\n    o.X = p.xyz; o.type = int(p.w);\n    o.q = texel(ch0, i2xy(ivec3(id, 1, 0)));\n    p = texel(ch0, i2xy(ivec3(id, 2, 0)));\n    o.P = p.xyz;\n    o.m = p.w;\n    o.L = texel(ch0, i2xy(ivec3(id, 3, 0))).xyz;\n    return o;\n}\n\nvec4 getParticlePos(int id);\n\nvec4 saveObject(int i)\n{\n    switch(i)\n    {\n    case 0:  \n        return vec4(obj.X, obj.type);\n    case 1:\n        return obj.q;\n    case 2:\n        return vec4(obj.P, obj.m);\n    case 3:\n        return vec4(obj.L, 0.);\n    }\n}\n\n \nfloat dist2p(vec3 p, int id);\nvoid sort(int idtemp, int R);\nvoid sortlinks(int id, int R, int R0);\nvoid sortneighbors(int id, int R);\nvoid sortrandom(int id, int R);\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(floor(pos));\n    if(any(greaterThan(p, sN*N-1))) discard;\n    \n    ivec3 sid = xy2i(p); ID = sid.x;\n    obj = getObject(ID);\n   \tif(sid.z == 0) //object computation\n    {    \n        if(sid.y > 3) discard;\n        \n        //compute the force and the torque\n        //TODO\n        vec3 F = -0.0002*obj.X;\n\n        obj.P += F*dt;\n        obj.X += obj.P*dt/obj.m;\n        \n        if(iFrame<1) //initial conditions\n        {\n            obj.X = 2.*(hash33(pos.xyx + pos.yyx*4.5743) - 0.5);\n            obj.P = 0.01*2.*(hash33(pos.yxy + pos.xxy*PI) - 0.5);\n            obj.L = vec3(0.);\n            obj.q = vec4(0.);\n            obj.type = 0;\n            obj.m = 1.;\n        } \n        \n        U = saveObject(sid.y);\n    }\n    else //graph computation\n    {\n        d = vec4(1e6);\n        lnk = vec4(-1);\n       \n        sortlinks(ID, sid.y, sid.y);\n        \n        sortneighbors(ID, sid.y);\n        \n        sortrandom(sid.x, sid.y);\n        \n        U = lnk;\n    }\n}\n\nvec4 getParticlePos(int id)\n{ \n    return texel(ch0, i2xy(ivec3(id, 0, 0)));\n}\n\nfloat dist2p(vec3 p, int id)\n{\n    return distance(getParticlePos(id).xyz,p);\n}\n\nbool iscoincidence(int id)\n{\n    bool c = (id == ID) || (id < 0) || any(equal(lnk,vec4(id)));\n    return c;\n}\n\nvoid sort(int idtemp, int R) //sort closest objects in N directions\n{\n    if(iscoincidence(idtemp)) return; //particle already sorted\n    vec4 px = getParticlePos(idtemp);\n    vec3 dir = fibonacci_sphere(R, link0);\n    float t = dirBisectDist(dir, obj.X, px.xyz);\n    //insertion sort\n    if(d.x > t)\n    {\n        d = vec4(t, d.xyz);\n        lnk = vec4(idtemp, lnk.xyz);\n    }\n    else if(d.y > t && t > d.x)\n    {\n        d.yzw = vec3(t, d.yz);\n        lnk.yzw = vec3(idtemp, lnk.yz);\n    }\n    else if(d.z > t && t > d.y)\n    {\n        d.zw = vec2(t, d.z);\n        lnk.zw = vec2(idtemp, lnk.z);\n    }\n    else if(d.w > t && t > d.z)\n    {\n        d.w = t;\n        lnk.w = float(idtemp);\n    }\n}\n\nvoid sortlinks(int id, int R, int R0)\n{\n    vec4 nb = texel(ch0, i2xy(ivec3(id, R, 1)));\n    for(int i = min(0, iFrame); i<4; i++) \n        sort(int(nb[i]), R0);\n}\n\nvoid sortneighbors(int id, int R)\n{\n    vec3 dir = fibonacci_sphere(R, link0);\n    vec4 d4 = iSF(dir, float(link0));\n    for(int i = min(0, iFrame); i < 4; i++)\n    {\n         int dir = int(d4[i]);\n         vec4 nb = texel(ch0, i2xy(ivec3(id, dir, 1)));\n    \t for(int j = min(0, iFrame); j < 4; j++) \n         {\n         \tsortlinks(int(nb[j]), (16*iFrame+4*j+i)%link0, R); \n         }\n    }  \n}\n\nvoid sortrandom(int id, int R)\n{\n    for(int i = min(0, iFrame); i<2; i++) sort((12*iFrame+ID+i)%tot_n, R);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//prev closest particle buffer\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat bisectDist(vec3 p, vec3 a, vec3 b)\n{\n    return distance(a,b)*0.5 - dot(p - a, normalize(b - a));\n}\n\nvoid check_neighbors(vec3 p, inout vec3 cxy, inout int cid)\n{\n    int dir = int(inverseSF(normalize(p - cxy), float(link0)).x);\n    float t = distance(p, cxy);\n    vec4 nb = texel(ch0, i2xy(ivec3(cid, dir, 1)));\n    for(int i = min(0,iFrame); i<4; i++)\n    {\n        vec3 X = texel(ch0, i2xy(ivec3(nb[i], 0, 0))).xyz;\n        float tt = distance(p, X);\n        if(tt < t)\n        {\n            t = tt;\n            cxy = X;\n            cid = int(nb[i]);\n        } \n    }\n}\n\n//find closest voronoi cell \nvoid findClosest(vec3 p, inout vec4 cobj, int mit)\n{    \n    int cid = int(cobj.w);\n    vec3 cxy = cobj.xyz;\n\n    for(int s = min(0,iFrame); s < mit; s++)\n    {\n    \tint pid = cid;\n        check_neighbors(p, cxy, cid);          \n        if(pid == cid) break;\n    }\n   \n    cobj = vec4(cxy,cid);\n}\n\n#define maxd 4.\n#define mind 0.003\n#define maxs 128\n\nfloat map(vec3 p, inout vec4 cobj)\n{\n    findClosest(p, cobj, 32);\n    return sdSphere(p - cobj.xyz, 0.06);\n}\n\nvec3 col(vec3 p, in vec4 cobj)\n{\n    //voronoi neighbors projected on the sphere surface\n    int cid = -1;\n    vec3 D = normalize(p - cobj.xyz);\n    int dir = int(inverseSF(D, float(link0)).x);\n    float t = 1e10;\n    vec4 nb = texel(ch0, i2xy(ivec3(cobj.w, dir, 1)));\n    for(int i = 0; i<4; i++)\n    {\n        vec3 X = texel(ch0, i2xy(ivec3(nb[i], 0, 0))).xyz;\n        float tt = dirBisectDist(D, cobj.xyz, X);\n        if(tt < t)\n        {\n            t = tt;\n            cid = int(nb[i]);\n        } \n    }\n    return 0.5 + 0.5 * sin(vec3(1,2,3)*float(cid));\n}\n\n//voronoi diagram ray marching\nvec4 rayMarch(vec3 p, vec3 d, inout vec4 cobj)\n{\n    if(cobj.w < 0.)\n    {\n        cobj = vec4(texel(ch0, i2xy(ivec3(0, 0, 0))).xyz, 0.);\n    }\n    \n    float td = 0.; \n    for(int i = 0; i < maxs; i++)\n    {\n        //march\n        float DE = map(p, cobj);\n        \n        p += DE*d;\n        td += DE;\n        \n        //outide of the scene\n        if(td > maxd) return vec4(p, -1);\n        //has hit the surface\n        if(DE < mind*td) break;\n    }\n    return vec4(p, cobj.w);\n}\n\n#define FOV 2.\nmat3 getRot(vec2 a)\n{\n    \n   mat3 theta_rot = mat3(1, 0, 0,\n                         0, cos(a.y), sin(a.y),\n                         0, -sin(a.y), cos(a.y)); \n        \n   mat3 phi_rot = mat3(cos(a.x), sin(a.x), 0,\n        \t\t       -sin(a.x), cos(a.x), 0,\n        \t\t        0, 0, 1); \n   return transpose(phi_rot*theta_rot);\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getRot(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, FOV*pos.y, 1.));\n}\n\n#define ldir vec3(1,0,0)\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = (pos - size*0.5)/size.y;\n    vec2 angles = (iMouse.z>0.)?(iMouse.xy/iResolution.xy)*vec2(2.*PI, PI):vec2(0.1*iTime, PI*0.5);\n    \n    vec3 d = getRay(angles, uv);\n    vec3 p = 0.*texel(ch0, i2xy(ivec3(6, 0, 0))).xyz-2.*getRay(angles, vec2(0.));\n    vec4 prev = pixel(ch1, pos);\n    if(iFrame < 1) prev.w = 0.;\n    vec4 cobj = vec4(texel(ch0, i2xy(ivec3(prev.w, 0, 0))).xyz, prev.w);\n    findClosest(p, cobj, 16);\n    float closest = cobj.w;\n    vec4 rm = rayMarch(p, d, cobj);\n    if(rm.w >= 0.) //hit object\n    {\n        vec3 pp = texel(ch0, i2xy(ivec3(rm.w, 0, 0))).xyz;\n    \tvec3 n = 0.2*normalize(rm.xyz - pp) + 0.8;\n        vec3 c = col(rm.xyz, cobj);\n        U.xyz = c*vec3(clamp(dot(ldir, n),0.,1.));\n    }\n    else //background\n    {\n        U = texture(iChannel2,  d.yzx);\n    }\n    U.w = closest;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}