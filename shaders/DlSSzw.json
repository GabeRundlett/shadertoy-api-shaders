{
    "Shader": {
        "info": {
            "date": "1675797180",
            "description": "8 rank convolution. WASD QE and mouse to move. Press R to stop movement.",
            "flags": 48,
            "hasliked": 0,
            "id": "DlSSzw",
            "likes": 21,
            "name": "DOF Kernel convolution",
            "published": 3,
            "tags": [
                "camera"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 404
        },
        "renderpass": [
            {
                "code": "#define exposure 1.2\n#define sqrexposure 0.6\n#define gamma 1.3\n#define bloom 20.0\n\nvec3 expose(vec3 c)\n{\n    return 1.0 - exp(-exposure*c-sqrexposure*c*c);\n}\n\nvec3 saturate(vec3 c)\n{\n    return pow(expose(c),vec3(1.0/gamma));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 convol = texture(iChannel1, 0.5*fragCoord/iResolution.xy);\n    \n    vec3 col = 0.0*acc.xyz/acc.w + bloom*convol.xyz;\n\n    fragColor = vec4(saturate(col), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//controller\n\n//Keyboard constants\nconst int keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n\nbool pressed(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5;\n}\n\nconst float force = 32.0;\nconst float mouse_sens = 100.0;\nconst float roll_speed = 0.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr && p.y > 0.) discard;\n    \n    //get camera data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = get(CamA);\n    \n    float mode = get(CamP).w;\n    if(pressed(keyR)) mode = 1.0 - mode;\n    \n    //initialization\n    if(iFrame == 0)\n    {\n        mode = 1.0;\n        cp =  vec3(6,6,5);\n        ca = aa2q( normalize(vec3(0.0,1,0.)), -1.15);\n    }\n    vec4 oldca = ca;\n    if(p.x == PrevCamP) o = vec4(cp, 0);\n    if(p.x == PrevCamA) o = ca;\n    \n    mat3 cam = getCam(ca);\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    vec4 cav = get(CamAV);\n    \n    float dt = 1./60.0;\n    //update position\n    if(pressed(keyW)) cv += force*dt*cam*vec3(0,0,1);\n    if(pressed(keyS)) cv += force*dt*cam*vec3(0,0,-1);\n    if(pressed(keyA)) cv += force*dt*cam*vec3(-1,0,0);\n    if(pressed(keyD)) cv += force*dt*cam*vec3(1,0,0);\n    \n    cp += dt*cv + 5.0*iTimeDelta*vec3(1,0,0)*mode;\n    cv += -cv*tanh(10.0*dt);\n    \n    //update camera orientation\n    vec2 dmouse = dt*mouse_sens*(iMouse.xy - get(PrevMouse).xy)/iResolution.x;\n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam*vec3(0,1,0), -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), -roll_speed*dt)); \n    if(pressed(keyE)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), roll_speed*dt)); \n    \n    if(p.x == CamP) o = vec4(cp, mode);\n    if(p.x == CamA) o = ca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == CamAV) o = vec4(0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define FOV 0.8\n#define MAX_STEPS 256\n#define MIN_DIST 1e-5\n#define MAX_DIST 60.0\n\n//(reused some of @ollj's code, made it more readible)\n\nfloat CAM_ANGLE = 0.003;\n\n// basic parameters\nfloat R = 2.1;\t\t\t\t\t\t\t\t// planet radius\nfloat H = 0.1;\t\t\t\t\t\t\t// density scale-height of atmosphere (not pressure scale height)\n\nvec3 light = normalize(vec3(1,0.8,-0.6));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\n\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            CamAV = 3.,    //camera rotation velocity\n            PrevCamP = 4., //previous frame camera position\n            PrevCamA = 5., //previous frame camera rotation quaternion\n            PrevMouse = 6.,//previous mouse pos\n            NAddr = 7.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\n\n\n//ollj quaternionRotation math\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\n\n//quaternion Identity\nvec4 qid() \n{\n    return vec4(0, 0, 0, 1);\n}\n\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q) \n{\n    return vec4(q.xyz / sqrt(1.0 - q.w * q.w), acos(q.w) * 2.);\n}\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\n\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f) \n{\n    float d = dot(a, b), t = acos(abs(d)), o = (1. / sin(t));\n    return normalize(a * sin(t * (1.0 - f)) * o * sign(d) + b * sin(t * f) * o);\n}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q) \n{\n    return q / dot(q,q);\n}\n\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\n//http://wiki.secondlife.com/wiki/LlRotBetween\nvec4 qBetween(vec3 a, vec3 b) \n{\n    float v = sqrt(dot(a,a) * dot(a,a));\n\n    if(v == 0.) return qid();\n    \n    v = dot(a, b) / v;\n    vec3 c = a.yzx * b.zxy - a.zxy * b.yzx / v;\n    float d = dot(c,c);\n    \n    if(d != 0.) \n    {\n        float s = (v > - 0.707107) ? 1. + v : d / (1. + sqrt(1. - d));\n        return vec4(c, s) / sqrt(d + s * s);\n    }\n    \n    if(v > 0.) return qid();\n    \n    float m = length(a.xy);\n    \n    return (m != 0.) ? vec4(a.y, - a.x, 0, 0) / m : vec4(1, 0, 0, 0);\n}\n\n//return inverse of quaternion\nvec4 qinv(vec4 q) \n{\n    return vec4(- q.xyz, q.w) / dot(q,q);\n}\n\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q, vec3 p) \n{\n    return qq2q(q, qq2q(vec4(p, .0), qinv(q))).xyz;\n}\n\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it is rotated by VECTOR p (as if it is a quaternion)\nvec3 vq2v(vec3 p, vec4 q) \n{\n    return qq2q(qinv(q), qq2q(vec4(p, 0.0), q)).xyz;\n}\n\nvec3 vq2v(vec4 a, vec3 b) \n{\n    return qv2v(a, b);\n}\n\n//in case of namespace confuction\nvec3 qv2v(vec3 a, vec4 b) \n{\n    return vq2v(a, b);\n}\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a, v = q.xyx * a.xxy;\n    mat3 m = mat3(0.5) + mat3(0, u.x,u.y,u.z, 0, v.x,v.y,v.z, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\n//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\nvec4 m2q(mat3 m) \n{\n#define m2f(a,b) m[a][b]-m[b][a]\n    //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    float q = 2. * sqrt(abs(1. + m[0][0] + m[1][1] + m[2][2]));\n    return vec4(vec3(m2f(2, 1), m2f(0, 1), m2f(1, 0)) / q / 4., q);\n#undef m2f\n}\n\nfloat at2e(vec2 a) \n{\n    a *= 2.;\n    return atan(a.x, 1. - a.y);\n}\n\n//return quaternion of Euler[yaw,pitch,roll]     \nvec4 eYPR2q(vec3 o) \n{\n    o *= .5;\n    vec3 s = sin(o);\n    //https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n    o = cos(o);\n    vec4 a = vec4(s.xz, o.xz);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(-1, 1, -1, 1);\n}\n\nvec4 eYPR2q(vec2 o) \n{\n    o *= .5;\n    vec2 s = sin(o);\n    o = cos(o);\n    vec4 a = vec4(s.x, 0., o.x, 0.);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(- 1, 1, - 1, 1);\n}\n\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\n//The first 8 columns of the U matrix: \nfloat U[408] = float[](0.0000E+00, 0.0000E+00, 0.0000E+00, -2.4065E-02, -6.5613E-02, -8.8278E-02, -1.0483E-01, -1.1767E-01, -1.2821E-01, -1.3687E-01, -1.4408E-01, -1.5008E-01, -1.5533E-01, -1.5957E-01, -1.6274E-01, -1.6579E-01, -1.6779E-01, -1.6971E-01, -1.7091E-01, -1.7188E-01, -1.7259E-01, -1.7293E-01, -1.7312E-01, -1.7327E-01, -1.7335E-01, -1.7338E-01, -1.7335E-01, -1.7327E-01, -1.7312E-01, -1.7293E-01, -1.7259E-01, -1.7188E-01, -1.7091E-01, -1.6971E-01, -1.6779E-01, -1.6579E-01, -1.6274E-01, -1.5957E-01, -1.5533E-01, -1.5008E-01, -1.4408E-01, -1.3687E-01, -1.2821E-01, -1.1767E-01, -1.0483E-01, -8.8278E-02, -6.5613E-02, -2.4065E-02, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, -7.8657E-02, -2.0407E-01, -2.4957E-01, -2.5999E-01, -2.4892E-01, -2.2292E-01, -1.8795E-01, -1.4837E-01, -1.0726E-01, -6.4409E-02, -2.4713E-02, 7.8910E-03, 4.1720E-02, 6.5488E-02, 8.9230E-02, 1.0478E-01, 1.1752E-01, 1.2691E-01, 1.3144E-01, 1.3412E-01, 1.3608E-01, 1.3722E-01, 1.3760E-01, 1.3722E-01, 1.3608E-01, 1.3412E-01, 1.3144E-01, 1.2691E-01, 1.1752E-01, 1.0478E-01, 8.9230E-02, 6.5488E-02, 4.1720E-02, 7.8910E-03, -2.4713E-02, -6.4409E-02, -1.0726E-01, -1.4837E-01, -1.8795E-01, -2.2292E-01, -2.4892E-01, -2.5999E-01, -2.4957E-01, -2.0407E-01, -7.8657E-02, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, -1.2159E-01, -2.8133E-01, -2.6729E-01, -1.7707E-01, -6.2094E-02, 4.9607E-02, 1.3751E-01, 1.9436E-01, 2.1958E-01, 2.1503E-01, 1.8682E-01, 1.4863E-01, 9.5153E-02, 4.9404E-02, -1.6434E-03, -3.9463E-02, -7.1037E-02, -9.4906E-02, -1.0700E-01, -1.1441E-01, -1.1981E-01, -1.2299E-01, -1.2402E-01, -1.2299E-01, -1.1981E-01, -1.1441E-01, -1.0700E-01, -9.4906E-02, -7.1037E-02, -3.9463E-02, -1.6434E-03, 4.9404E-02, 9.5153E-02, 1.4863E-01, 1.8682E-01, 2.1503E-01, 2.1958E-01, 1.9436E-01, 1.3751E-01, 4.9607E-02, -6.2094E-02, -1.7707E-01, -2.6729E-01, -2.8133E-01, -1.2159E-01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, -1.5600E-01, -2.9848E-01, -1.5615E-01, 5.1537E-02, 2.0095E-01, 2.4708E-01, 1.9967E-01, 9.7856E-02, -1.9441E-02, -1.2401E-01, -1.8650E-01, -2.0595E-01, -1.8556E-01, -1.4558E-01, -8.4390E-02, -2.6794E-02, 2.2816E-02, 6.2173E-02, 8.3731E-02, 9.7689E-02, 1.0788E-01, 1.1386E-01, 1.1582E-01, 1.1386E-01, 1.0788E-01, 9.7689E-02, 8.3731E-02, 6.2173E-02, 2.2816E-02, -2.6794E-02, -8.4390E-02, -1.4558E-01, -1.8556E-01, -2.0595E-01, -1.8650E-01, -1.2401E-01, -1.9441E-02, 9.7856E-02, 1.9967E-01, 2.4708E-01, 2.0095E-01, 5.1537E-02, -1.5615E-01, -2.9848E-01, -1.5600E-01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 1.8421E-01, 2.6232E-01, -2.4118E-02, -2.4041E-01, -2.3492E-01, -6.5998E-02, 1.2112E-01, 2.2395E-01, 2.1430E-01, 1.1027E-01, -2.1991E-02, -1.2625E-01, -1.8577E-01, -1.9158E-01, -1.5029E-01, -8.4109E-02, -2.4164E-02, 2.7729E-02, 5.9765E-02, 8.2056E-02, 9.8327E-02, 1.0789E-01, 1.1101E-01, 1.0789E-01, 9.8327E-02, 8.2056E-02, 5.9765E-02, 2.7729E-02, -2.4164E-02, -8.4109E-02, -1.5029E-01, -1.9158E-01, -1.8577E-01, -1.2625E-01, -2.1991E-02, 1.1027E-01, 2.1430E-01, 2.2395E-01, 1.2112E-01, -6.5998E-02, -2.3492E-01, -2.4041E-01, -2.4118E-02, 2.6232E-01, 1.8421E-01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 2.1130E-01, 1.8786E-01, -1.9313E-01, -2.4601E-01, 9.8258E-04, 2.1986E-01, 2.1564E-01, 4.4144E-02, -1.4399E-01, -2.2271E-01, -1.6410E-01, -3.6037E-02, 9.7248E-02, 1.7735E-01, 1.8342E-01, 1.2534E-01, 6.7683E-02, 8.4743E-03, -3.5175E-02, -6.8252E-02, -9.2395E-02, -1.0658E-01, -1.1121E-01, -1.0658E-01, -9.2395E-02, -6.8252E-02, -3.5175E-02, 8.4743E-03, 6.7683E-02, 1.2534E-01, 1.8342E-01, 1.7735E-01, 9.7248E-02, -3.6037E-02, -1.6410E-01, -2.2271E-01, -1.4399E-01, 4.4144E-02, 2.1564E-01, 2.1986E-01, 9.8258E-04, -2.4601E-01, -1.9313E-01, 1.8786E-01, 2.1130E-01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, -2.3655E-01, -8.7412E-02, 2.7781E-01, 6.9412E-02, -2.3542E-01, -1.7407E-01, 9.6584E-02, 2.3436E-01, 1.3063E-01, -8.6081E-02, -2.0729E-01, -1.7278E-01, -3.5397E-02, 1.1059E-01, 1.7336E-01, 1.4387E-01, 1.0570E-01, 4.6991E-02, -8.8410E-03, -5.5153E-02, -8.8956E-02, -1.0882E-01, -1.1530E-01, -1.0882E-01, -8.8956E-02, -5.5153E-02, -8.8410E-03, 4.6991E-02, 1.0570E-01, 1.4387E-01, 1.7336E-01, 1.1059E-01, -3.5397E-02, -1.7278E-01, -2.0729E-01, -8.6081E-02, 1.3063E-01, 2.3436E-01, 9.6584E-02, -1.7407E-01, -2.3542E-01, 6.9412E-02, 2.7781E-01, -8.7412E-02, -2.3655E-01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, -2.6541E-01, 3.2433E-02, 2.4425E-01, -1.5895E-01, -2.0625E-01, 1.3418E-01, 2.2791E-01, -1.3099E-02, -2.2190E-01, -1.4513E-01, 6.7305E-02, 2.0136E-01, 1.5005E-01, -9.3857E-03, -1.1571E-01, -1.3903E-01, -1.4195E-01, -9.2390E-02, -2.2036E-02, 4.2063E-02, 8.8849E-02, 1.1634E-01, 1.2531E-01, 1.1634E-01, 8.8849E-02, 4.2063E-02, -2.2036E-02, -9.2390E-02, -1.4195E-01, -1.3903E-01, -1.1571E-01, -9.3857E-03, 1.5005E-01, 2.0136E-01, 6.7305E-02, -1.4513E-01, -2.2190E-01, -1.3099E-02, 2.2791E-01, 1.3418E-01, -2.0625E-01, -1.5895E-01, 2.4425E-01, 3.2433E-02, -2.6541E-01, 0.0000E+00, 0.0000E+00, 0.0000E+00); \n//The first 8 rows of the V matrix: \nfloat V[408] = float[](0.0000E+00, 0.0000E+00, 0.0000E+00, -5.7941E-04, -1.5797E-03, -2.1254E-03, -2.5239E-03, -2.8331E-03, -3.0869E-03, -3.2953E-03, -3.4690E-03, -3.6134E-03, -3.7398E-03, -3.8420E-03, -3.9183E-03, -3.9915E-03, -4.0397E-03, -4.0860E-03, -4.1149E-03, -4.1384E-03, -4.1554E-03, -4.1635E-03, -4.1682E-03, -4.1717E-03, -4.1737E-03, -4.1743E-03, -4.1737E-03, -4.1717E-03, -4.1682E-03, -4.1635E-03, -4.1554E-03, -4.1384E-03, -4.1149E-03, -4.0860E-03, -4.0397E-03, -3.9915E-03, -3.9183E-03, -3.8420E-03, -3.7398E-03, -3.6134E-03, -3.4690E-03, -3.2953E-03, -3.0869E-03, -2.8331E-03, -2.5239E-03, -2.1254E-03, -1.5797E-03, -5.7941E-04, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 4.5119E-04, 1.1706E-03, 1.4316E-03, 1.4914E-03, 1.4278E-03, 1.2787E-03, 1.0781E-03, 8.5108E-04, 6.1524E-04, 3.6946E-04, 1.4176E-04, -4.5264E-05, -2.3931E-04, -3.7565E-04, -5.1184E-04, -6.0105E-04, -6.7414E-04, -7.2797E-04, -7.5399E-04, -7.6934E-04, -7.8055E-04, -7.8714E-04, -7.8929E-04, -7.8714E-04, -7.8055E-04, -7.6934E-04, -7.5399E-04, -7.2797E-04, -6.7414E-04, -6.0105E-04, -5.1184E-04, -3.7565E-04, -2.3931E-04, -4.5264E-05, 1.4176E-04, 3.6946E-04, 6.1524E-04, 8.5108E-04, 1.0781E-03, 1.2787E-03, 1.4278E-03, 1.4914E-03, 1.4316E-03, 1.1706E-03, 4.5119E-04, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, -3.8974E-04, -9.0176E-04, -8.5676E-04, -5.6758E-04, -1.9903E-04, 1.5901E-04, 4.4076E-04, 6.2300E-04, 7.0383E-04, 6.8924E-04, 5.9881E-04, 4.7642E-04, 3.0500E-04, 1.5835E-04, -5.2677E-06, -1.2649E-04, -2.2770E-04, -3.0421E-04, -3.4296E-04, -3.6671E-04, -3.8404E-04, -3.9422E-04, -3.9754E-04, -3.9422E-04, -3.8404E-04, -3.6671E-04, -3.4296E-04, -3.0421E-04, -2.2770E-04, -1.2649E-04, -5.2677E-06, 1.5835E-04, 3.0500E-04, 4.7642E-04, 5.9881E-04, 6.8924E-04, 7.0383E-04, 6.2300E-04, 4.4076E-04, 1.5901E-04, -1.9903E-04, -5.6758E-04, -8.5676E-04, -9.0176E-04, -3.8974E-04, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 3.4046E-04, 6.5140E-04, 3.4078E-04, -1.1248E-04, -4.3855E-04, -5.3924E-04, -4.3576E-04, -2.1356E-04, 4.2428E-05, 2.7064E-04, 4.0702E-04, 4.4946E-04, 4.0496E-04, 3.1771E-04, 1.8417E-04, 5.8477E-05, -4.9794E-05, -1.3569E-04, -1.8274E-04, -2.1320E-04, -2.3543E-04, -2.4850E-04, -2.5276E-04, -2.4850E-04, -2.3543E-04, -2.1320E-04, -1.8274E-04, -1.3569E-04, -4.9794E-05, 5.8477E-05, 1.8417E-04, 3.1771E-04, 4.0496E-04, 4.4946E-04, 4.0702E-04, 2.7064E-04, 4.2428E-05, -2.1356E-04, -4.3576E-04, -5.3924E-04, -4.3855E-04, -1.1248E-04, 3.4078E-04, 6.5140E-04, 3.4046E-04, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 2.9724E-04, 4.2327E-04, -3.8916E-05, -3.8791E-04, -3.7906E-04, -1.0649E-04, 1.9544E-04, 3.6136E-04, 3.4578E-04, 1.7793E-04, -3.5484E-05, -2.0371E-04, -2.9976E-04, -3.0913E-04, -2.4250E-04, -1.3571E-04, -3.8991E-05, 4.4742E-05, 9.6434E-05, 1.3240E-04, 1.5866E-04, 1.7408E-04, 1.7912E-04, 1.7408E-04, 1.5866E-04, 1.3240E-04, 9.6434E-05, 4.4742E-05, -3.8991E-05, -1.3571E-04, -2.4250E-04, -3.0913E-04, -2.9976E-04, -2.0371E-04, -3.5484E-05, 1.7793E-04, 3.4578E-04, 3.6136E-04, 1.9544E-04, -1.0649E-04, -3.7906E-04, -3.8791E-04, -3.8916E-05, 4.2327E-04, 2.9724E-04, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, -2.6356E-04, -2.3433E-04, 2.4090E-04, 3.0686E-04, -1.2256E-06, -2.7424E-04, -2.6898E-04, -5.5063E-05, 1.7961E-04, 2.7780E-04, 2.0468E-04, 4.4951E-05, -1.2130E-04, -2.2122E-04, -2.2879E-04, -1.5634E-04, -8.4424E-05, -1.0570E-05, 4.3876E-05, 8.5134E-05, 1.1525E-04, 1.3294E-04, 1.3872E-04, 1.3294E-04, 1.1525E-04, 8.5134E-05, 4.3876E-05, -1.0570E-05, -8.4424E-05, -1.5634E-04, -2.2879E-04, -2.2122E-04, -1.2130E-04, 4.4951E-05, 2.0468E-04, 2.7780E-04, 1.7961E-04, -5.5063E-05, -2.6898E-04, -2.7424E-04, -1.2256E-06, 3.0686E-04, 2.4090E-04, -2.3433E-04, -2.6356E-04, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, -2.3591E-04, -8.7177E-05, 2.7706E-04, 6.9226E-05, -2.3478E-04, -1.7360E-04, 9.6324E-05, 2.3373E-04, 1.3028E-04, -8.5850E-05, -2.0674E-04, -1.7232E-04, -3.5302E-05, 1.1029E-04, 1.7289E-04, 1.4348E-04, 1.0542E-04, 4.6865E-05, -8.8172E-06, -5.5004E-05, -8.8717E-05, -1.0853E-04, -1.1499E-04, -1.0853E-04, -8.8717E-05, -5.5004E-05, -8.8172E-06, 4.6865E-05, 1.0542E-04, 1.4348E-04, 1.7289E-04, 1.1029E-04, -3.5302E-05, -1.7232E-04, -2.0674E-04, -8.5850E-05, 1.3028E-04, 2.3373E-04, 9.6324E-05, -1.7360E-04, -2.3478E-04, 6.9226E-05, 2.7706E-04, -8.7177E-05, -2.3591E-04, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 2.1458E-04, -2.6221E-05, -1.9747E-04, 1.2851E-04, 1.6674E-04, -1.0848E-04, -1.8426E-04, 1.0590E-05, 1.7940E-04, 1.1734E-04, -5.4415E-05, -1.6280E-04, -1.2131E-04, 7.5882E-06, 9.3550E-05, 1.1240E-04, 1.1477E-04, 7.4696E-05, 1.7816E-05, -3.4007E-05, -7.1833E-05, -9.4060E-05, -1.0131E-04, -9.4060E-05, -7.1833E-05, -3.4007E-05, 1.7816E-05, 7.4696E-05, 1.1477E-04, 1.1240E-04, 9.3550E-05, 7.5882E-06, -1.2131E-04, -1.6280E-04, -5.4415E-05, 1.1734E-04, 1.7940E-04, 1.0590E-05, -1.8426E-04, -1.0848E-04, 1.6674E-04, 1.2851E-04, -1.9747E-04, -2.6221E-05, 2.1458E-04, 0.0000E+00, 0.0000E+00, 0.0000E+00); \n//center of the convolution \nint Nc = 25; \n//number of ranks \nint Nr = 8; \n//convolution size \nint N = 51; \n\n\n\nvec3 pack2vec3(vec3 a, vec3 b) \n{\n    uvec3 packed = uvec3(packHalf2x16(vec2(a.x,b.x)), packHalf2x16(vec2(a.y,b.y)), packHalf2x16(vec2(a.z,b.z)));\n    return vec3(uintBitsToFloat(packed.x), uintBitsToFloat(packed.y), uintBitsToFloat(packed.z));\n}\n\nvoid unpack2vec3(vec3 packed, out vec3 a, out vec3 b) \n{\n    uvec3 unpacked = uvec3(floatBitsToUint(packed.x), floatBitsToUint(packed.y), floatBitsToUint(packed.z));\n    vec2 unpackedA = unpackHalf2x16(unpacked.x);\n    vec2 unpackedB = unpackHalf2x16(unpacked.y);\n    vec2 unpackedC = unpackHalf2x16(unpacked.z);\n    a = vec3(unpackedA.x, unpackedB.x, unpackedC.x);\n    b = vec3(unpackedA.y, unpackedB.y, unpackedC.y);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define SLICES 50.0\n\nfloat minimum_distance(vec3 v, vec3 w, vec3 p) \n{\n  vec3 dx = w - v;\n  float l2 = dot(dx, dx);  \n  if (l2 == 0.0) return distance(p, v);   \n  float t = max(0.0, min(1.0, dot(p - v, w - v) / l2));\n  vec3 projection = v + t * (w - v);\n  return distance(p, projection);\n}\n\nvec3 blackBody(float T)\n{\n    vec3 O = vec3(0.0);\n    for (float i=0.; i<3.; i++) \n    { \n        float f = 1.+.5*i; \n        O[int(i)] += 10. * (f*f*f) / (exp((19E3*f/T)) - 1.);  // Planck law\n    }\n    return O;\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat region(vec3 pos)\n{\n    return texture(iChannel1, pos/200.0).x;\n}\n\nvec3 sampleVoxel(vec3 ro, vec3 rd, vec3 pos)\n{\n    float r = region(pos);\n    if(r < 0.5) return vec3(0.0);\n    float temp = hash13(pos);\n    vec3 heat = pow(blackBody(temp*temp*temp*20000.), vec3(1.0));\n    vec3 spos = hash33(pos) + pos;\n    float mdist = minimum_distance(ro, ro + rd*100.0, spos);\n    float camdist = distance(ro, spos);\n    float mindist = 1.5*CAM_ANGLE*camdist;\n    float dec = smoothstep(SLICES, SLICES*0.8, camdist);\n    float bright = min(1000.0, 20.0 * dec / (camdist*camdist));\n    return bright * smoothstep(mindist, 0.0, mdist) * heat;\n}\n\nvec3 VoxelRaycast(vec3 ro, vec3 rd, float maxt)\n{\n\tvec3 voxelPos = floor(ro);\n\t\n    vec3 rayInv = 1.0/rd;\n    vec3 rayMask = vec3(greaterThan(rd, vec3(0.0)));\n\tvec3 rayStep = rayMask * 2.0 - 1.0;          \n\tvec3 offset = (rayMask - ro) * rayInv;\n\n\tvec3 mask = vec3(0.0);\n    vec3 sideLength = vec3(0.0);\n    \n    float traveled = 0.0;\n    vec3 col = vec3(0.0);\n\tfor(int i = 0; i < MAX_STEPS; i++) \n\t{\n        col += sampleVoxel(ro, rd, voxelPos);\n        \n        sideLength = voxelPos * rayInv + offset;\n        mask = vec3(lessThanEqual(sideLength.xyz, min(sideLength.yzx, sideLength.zxy)));\n        voxelPos += mask * rayStep;\n        traveled = dot(sideLength, mask);\n        \n        if(traveled > maxt) break;\n\t}\n    \n    ro = ro + rd*traveled;\n\treturn col;\n}\n\nbool getRay(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    mat3 cam = getCam(get(CamA));\n    \n    ro = get(CamP).xyz;\n   \n    rd = normalize(cam*vec3(FOV*uv, 1.0));\n    \n    return true;\n}\n\nvec4 render(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 cp, rd;\n    if(!getRay(uv, cp, rd)) return vec4(0,0,0,1);\n   \n    return vec4(VoxelRaycast(cp, rd, SLICES), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CAM_ANGLE = 1.5 * FOV / iResolution.y;\n    fragColor = vec4(0.0);   \n\n    fragColor += render(fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//first pass of separable convolution\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //do a convolution in the x direction on iChannel0\n    //since we have 6 ranks and we can only store 2 in a vec3 we need to do the partial sums in 1/2 resolution chunks in a single buffer(which means max 8 ranks)\n    ivec2 coord = ivec2(fragCoord.xy) % ivec2(iResolution.xy/2.0);\n    ivec2 block = ivec2(fragCoord.xy) / ivec2(iResolution.xy/2.0);\n    int rank_offset = 2 * (block.x + block.y * 2);\n\n    if(rank_offset >= Nr)\n        discard;\n\n    vec3 sum0 = vec3(0.0);\n    vec3 sum1 = vec3(0.0);\n    for (int i = -Nc; i < Nc; i++) \n    {\n        //use texelFetch to get the pixel at the current index\n        //since we are doing it at 1/2 resolution we need to use 1 mip level higher\n        vec4 pixel = texelFetch(iChannel0, coord + ivec2(i, 0), 1);\n        vec3 pcolor = pow(pixel.xyz/(pixel.w+1e-6), vec3(1.25));\n        \n        //get the rank index\n        int offset = i + Nc;\n        sum0 += pcolor * U[offset + rank_offset * N];\n        sum1 += pcolor * U[offset + (rank_offset + 1) * N];\n    }\n\n    //write the sum packed to the output\n    fragColor = vec4(pack2vec3(sum0, sum1), 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//second pass: do the convolution in the y direction\n//and write the result to the output    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //do a convolution in the y direction on iChannel0\n    ivec2 resol = ivec2(iResolution.xy/2.0);\n    ivec2 coord = ivec2(fragCoord.xy) % resol;\n    ivec2 block = ivec2(fragCoord.xy) / resol;\n\n    //we only need 1 block, since we can sum all the ranks here\n    if(block.x + block.y * 2 >= 1)\n        discard;\n\n    vec3 sum = vec3(0.0);\n    for (int i = -Nc; i < Nc; i++) \n    {\n        //use texelFetch to get the pixel at the current index\n        ivec2 pos = ivec2(coord.x, coord.y + i);\n\n        //skip if the coordinate is outside the image\n        if(pos.x < 0 || pos.x >= resol.x || pos.y < 0 || pos.y >= resol.y)\n            continue;\n        \n        //loop over pairs of ranks\n        for(int j = 0; j < Nr; j += 2)\n        {\n            int block_id = j / 2;\n            ivec2 block_offset = ivec2(block_id % 2, block_id / 2);\n            vec4 pixel = texelFetch(iChannel0, pos + block_offset * resol, 0);\n\n            //unpack the values\n            vec3 val1, val2;\n            unpack2vec3(pixel.xyz, val1, val2);\n\n            //add the values to the sum\n            sum += val1 * V[i + Nc + j * N];\n            sum += val2 * V[i + Nc + (j + 1) * N];\n        }\n    }\n\n    //return the sum\n    fragColor = vec4(sum, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}