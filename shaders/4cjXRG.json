{
    "Shader": {
        "info": {
            "date": "1706497222",
            "description": "Use the mouse to look around",
            "flags": 0,
            "hasliked": 0,
            "id": "4cjXRG",
            "likes": 6,
            "name": "Old wooden crate",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "ray",
                "sdf",
                "box",
                "wood",
                "march",
                "crate"
            ],
            "usePreview": 1,
            "username": "ianertson",
            "viewed": 187
        },
        "renderpass": [
            {
                "code": "#define R iResolution.xy\n#define T ((iTime*0.5)+10.2+0.5*2.64)\n#define M_PI 3.14159\n#define TAU (M_PI*2.0)\n#define ZERO min(0, iFrame)\n#define FAR 50.0\n#define NEAR 0.003\n#define STEPS 50\n#define INV255 0.00392156862745098\n#define rgb(rr,gg,bb) vec3(float(rr)*INV255, float(gg)*INV255, float(bb)*INV255)\n\nmat2 rot(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c);}\n\nvec3 hash(vec2 p, float s) {\n    p = (p + (s * 300.) + fract(p.x * s + p.y * s));\n    return textureLod(iChannel0, p / 256.0, 0.0).rgb;\n}\n\nvec3 shash(vec2 p, float s) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    \n    return mix(\n        mix(hash(id + vec2(0, 0), s), hash(id + vec2(1, 0), s), lv.x),\n        mix(hash(id + vec2(0, 1), s), hash(id + vec2(1, 1), s), lv.x),\n        lv.y\n    );\n}\n\nvec3 noise(vec2 p, float s, float freq, const int octaves) {\n    vec3 n = vec3(0.0);\n    float amp = 1.0;\n    float div = 0.0;\n    \n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * shash(p*freq, s);\n        div += amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    \n    return n / div;\n}\n\nfloat boxSDF(vec3 p, vec3 s) {\n    p = abs(p) - s;\n    \n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sdf(vec3 p) {\n    float size = 1.0;\n    float ind = size*0.75;\n    float dind = ind*0.25;\n    float box = boxSDF(p, vec3(size));\n    float fb = -boxSDF(vec3(abs(p.x), p.y, p.z) - vec3(1., 0, 0), vec3(dind, 1, 1)*vec3(ind));\n    float tb = -boxSDF(vec3(p.x, abs(p.y), p.z) - vec3(0, 1., 0), vec3(1, dind, 1)*vec3(ind));\n    float lr = -boxSDF(vec3(p.x, p.y, abs(p.z)) - vec3(0, 0, 1.), vec3(1, 1, dind)*vec3(ind));\n    return max(box, max(tb, max(fb, lr)));\n}\n\nstruct Data {\n    float d;\n    vec3 p;\n    vec3 n;\n};\n#define NEW_DATA Data(FAR, vec3(0.0), vec3(0.0))\nbool march(vec3 ro, vec3 rd, inout Data data) {\n    float d = 0.0;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(p);\n        \n        if (abs(next) <= NEAR) break;\n        if (abs(next) >= FAR) return false;\n        \n        d += next;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec2 e = vec2(0.0001, 0.0);\n    data.n = normalize(sdf(p) - vec3(\n        sdf(p - e.xyy),\n        sdf(p - e.yxy),\n        sdf(p - e.yyx)\n    ));\n    data.d = d;\n    data.p = p;\n    return true;\n}\n\n#define DEBUG_TEXTURE 0\n\nvec3 woodTexture(in vec2 uv, in vec3 p, inout float z) {\n    vec3 col = vec3(0.0);\n    vec3 brown = rgb(138, 99, 77);\n    \n    vec3 hf = noise(uv, 11.23, 64.0, 4);\n    vec3 mf = noise(uv + 0.004*(hf.xz*2.0-1.0), 1.5, 24.0, 4);\n    vec3 lmf = noise(0.0581+uv - 12.2, -0.4482, 10.0, 4);\n    \n    float cracks = smoothstep(0.07, 0.01, abs(mf.y-mf.x));\n    \n    z += 0.0001*(cracks * 2.0-1.0);\n    z += hf.x*0.0003;\n    \n    float planks = abs(fract((uv.x+lmf.y*0.09*lmf.x)*8.)*2.0-1.0);\n    \n    col += brown * mf.z;\n    col += lmf.x*lmf.x*0.22;\n    col = mix(col, col*col, clamp(cracks*hf.y*hf.x*2., 0.0, 1.0));\n    float plankLines = smoothstep(0.2, 0.0, planks);\n    col = mix(col, col*col, plankLines);\n    col = mix(col, col+col, smoothstep(0.2, 0.6, planks));\n    \n    float dind = 0.25*0.75*0.5;\n    float A = smoothstep(0.0, dind, max(0.0, abs(p.y)-0.85));\n    float B = smoothstep(0.0, dind, max(0.0, abs(p.x)-0.85));\n    float C = smoothstep(0.0, dind, max(0.0, abs(p.z)-0.85));\n    \n    float ABC = (A+B+C);\n    z -= 3.2*plankLines * max(0.0, 1.0 - (A + B + C));\n    col = mix(col, mix(brown, brown*brown*0.5, hf.y), max(A, max(B, C)));\n    \n    const float aof = 0.75;\n    const float XA = 0.55;\n    const float XB = 0.82;\n    col = mix(col, vec3(0, 0, 0),\n    smoothstep(0.0, 0.11, 1.0-abs(0.5-length(p)))*\n    max(\n    smoothstep(0.01, 1.0 - aof, max(0.0, abs(p.y)-XA)) * smoothstep(0.0, 0.1, XB-abs(p.y)),\n    max(\n    smoothstep(0.01, 1.0 - aof, max(0.0, abs(p.x)-XA)) * smoothstep(0.0, 0.1, XB-abs(p.x)),\n    smoothstep(0.01, 1.0 - aof, max(0.0, abs(p.z)-XA)) * smoothstep(0.0, 0.1, XB-abs(p.z))\n    )));\n    \n    return col;\n}\n\nfloat smod(float x, float y) {\n    float pe = abs(fract(x*y)*2.0-1.0);\n    return pe;\n}\n\nmat3 cot( vec3 N, vec3 p, vec2 uv ) {\n  vec3 dp1 = dFdx(p);\n  vec3 dp2 = dFdy(p);\n  vec2 duv1 = dFdx(uv);\n  vec2 duv2 = dFdy(uv);\n  vec3 dp2perp = cross(dp2, N);\n  vec3 dp1perp = cross(N, dp1);\n  vec3 TZ = dp2perp * duv1.x + dp1perp * duv2.x;\n  vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n  float invmax = inversesqrt(max(dot(TZ,TZ), dot(B,B)));\n  return (isnan(invmax) || isinf(invmax) || invmax >= 99999999999.0) ? mat3(vec3(1.0), vec3(1.0), N) : mat3( TZ * invmax, B * invmax, N );\n}\n\nvec3 pet(vec3 N, vec3 V, vec2 texcoord, vec3 zmap) {\n  vec3 map = zmap;// * 2.0078740157480315 - 1.0078740157480315;\n  map.y = -map.y;\n  return normalize(cot(N, -V, texcoord) * map);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc.xy - 0.5 * R.xy) / R.y;\n    \n    #if DEBUG_TEXTURE\n    col = woodTexture(fc.xy/R.xy, vec3(0.0));\n    fragColor = vec4(col, 1.0);\n    return;\n    #endif\n    \n    vec4 m = vec4((iMouse.xy - 0.5 * R.xy) / R.y, iMouse.zw);\n    vec3 ro = vec3(0, 0.03, -4.5);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    bool drag = m.z > 0.01;\n    \n    vec2 va = vec2(0.0);\n    \n    if (drag) {\n        va = vec2(m.x*TAU, m.y*TAU);\n    } else {\n        float t = T;\n        ro.z += cos(t);\n        va = vec2(t, sin(t)*0.33333);\n    }\n    \n    ro.yz *= rot(va.y);\n    ro.xz *= rot(va.x);\n    rd.yz *= rot(va.y);\n    rd.xz *= rot(va.x);\n    \n    Data data = NEW_DATA;\n    \n    \n    vec3 L = normalize(vec3(1, 2, -3));\n    vec3 LC = vec3(0.98, 0.81, 0.79);\n    \n    if (march(ro, rd, data)) {\n        vec3 p = data.p;\n        vec3 n = data.n;\n        vec2 buv = mix(mix(p.xy, p.xz, abs(dot(n, vec3(0, 1, 0)))), p.zy, abs(dot(n, vec3(1, 0, 0))));\n        float z = 0.0;\n        vec3 albedo = woodTexture(buv*0.25, p, z);\n        z *= M_PI;\n        \n        vec2 dx = vec2(dFdx(z), 0.0001);\n        vec2 dy = vec2(0.0001, dFdy(z));\n        vec3 cp = cross(vec3(dx, z), vec3(dy, z));\n        vec3 np = length(cp) <= 0.0000001 ? normalize(n + cp) : pet(n, rd, buv, normalize(cp));\n        n = normalize(mix(n, np, 0.6));\n        \n        float NdotL = max(max(0.1, 0.25*clamp(0.1 -(z*z), 0.0, 1.0)), dot(n, L));\n        col += (albedo / M_PI) * NdotL * LC * 3.0;\n    } else {\n        data.d = length(rd)*FAR;\n        float U = atan(rd.z, rd.y) * M_PI;\n        float V = acos(rd.x) * M_PI;\n        float mm = 0.5;\n        vec2 kv = vec2(smod(U, mm), smod(V, mm));\n        col += LC*mix(noise(kv, 3.321, 3., 2), vec3(0.2, 0.75, 0.97), smoothstep(0.0, 1.0, rd.y));\n    }\n    \n    float dep = data.d / FAR;\n    col = mix(col, col*0.15, smoothstep(0.05, 0.1, dep)*smoothstep(9.0, 0.0, length(ro+rd*(0.5+0.05*data.d))));///smoothstep(0.1, 0.25, data.d / FAR));\n    float RV = max(0.0, dot(rd, L));\n    col += pow(RV, 16.0) * max(LC, 0.5) * smoothstep(0.02, 0.5, dep);\n    col = aces(col);\n    float lm = luma(col);\n    col += (0.5*lm*col)+(0.5*lm);\n    col = pow(col, vec3(1.0 / 2.2));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}