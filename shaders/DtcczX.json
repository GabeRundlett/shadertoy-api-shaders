{
    "Shader": {
        "info": {
            "date": "1699457655",
            "description": "Graphic Design Experiment 10",
            "flags": 0,
            "hasliked": 0,
            "id": "DtcczX",
            "likes": 46,
            "name": "Graphic Design Experiment 10",
            "published": 3,
            "tags": [
                "graphicdesign",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 1274
        },
        "renderpass": [
            {
                "code": "// The box intersection code is based on the iq's. https://www.shadertoy.com/view/ld23DV\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.5),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define deg45 .707\n#define R45(p) (( p + vec2(p.y,-p.x) ) *deg45)\n#define Tri(p,s) max(R45(p).x,max(R45(p).y,B(p,s)))\n#define SymdirY(p) mod(floor(p).y,2.)*2.-1.\n#define BOX_NUM 27.\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nfloat getTime(float t, float duration){\n    return clamp(t,0.0,duration)/duration;\n}\n\nfloat getAnimatedRotValue(float delay){\n    float frame = mod(iTime,9.0+delay)-delay;\n    float time = frame;\n    float duration = 0.7;\n    float rotVal = 0.0;\n    if(frame>=1. && frame<3.){\n        time = getTime(time-1.,duration);\n        rotVal = cubicInOut(time)*90.;\n    } else if(frame>=3. && frame<5.){\n        time = getTime(time-3.,duration);\n        rotVal = 90.+cubicInOut(time)*90.;\n    } else if(frame>=5. && frame<7.){\n        time = getTime(time-5.,duration);\n        rotVal = 180.+cubicInOut(time)*90.;\n    } else if(frame>=7. && frame<9.){\n        time = getTime(time-7.,duration);\n        rotVal = 270.+cubicInOut(time)*90.;\n    }\n    \n    return rotVal;\n}\n\n// https://iquilezles.org/articles/boxfunctions\nvec4 iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x,t1.y),t1.z);\n    float tF = min(min(t2.x,t2.y),t2.z);\n    \n    // no intersection\n\tif( tN>tF || tF<0.0 ) return vec4(-1.0);\n\n    vec4 res = vec4(tN, step(tN,t1) );\n    \n    // add sign to normal and convert to ray space\n\tres.yzw = (txi * vec4(-sign(rdd)*res.yzw,0.0)).xyz;\n\n\treturn res;\n}\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n\nfloat truchetGraphic(vec2 p, float dir){\n    vec2 prevP = p;\n    p.x*=dir;\n    p*=Rot(radians(45.));\n    p.x = abs(p.x)-0.212;\n    \n    p*=Rot(radians(45.));\n    vec2 prevP2 = p;\n    float a = radians(45.);\n    float d = abs(max(-dot(p+vec2(0.095),vec2(cos(a),sin(a))),B(p,vec2(0.15))))-0.03;\n    p+=vec2(0.085);\n    p*=Rot(radians(45.));\n    d = max(-B(p,vec2(0.03,0.003)),d);\n    \n    p = prevP2;\n    p+=vec2(0.105);\n    \n    p*=Rot(radians(45.));\n    p.x = abs(p.x)-0.075;\n    d = max(-B(p,vec2(0.007)),d);\n    \n    p = prevP;\n    p = mod(p,0.03)-0.015;\n    float d2 = length(p)-0.0005;\n    d = min(d,d2);\n    \n    p = prevP;\n    \n    p.y*=dir;\n    p*=Rot(radians(45.));\n    float sdir = SymdirY(p);\n    p.x*=1.7;\n    p.y+=iTime*0.1*sdir;\n    p.y = mod(p.y,0.08)-0.04;\n    p.y*=sdir*-1.;\n    d2 = Tri(p,vec2(0.015));\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x*=dir;\n    p*=Rot(radians(135.));\n    p.y = abs(p.y)-0.17;\n    p*=Rot(radians(45.));\n    d2 = min(B(p,vec2(0.0005,0.01)),B(p,vec2(0.01,0.0005)));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat ui(vec2 p){\n    vec2 prevP = p;\n    p = mod(p,0.06)-0.03;\n    float d = min(B(p,vec2(0.0001,0.006)),B(p,vec2(0.006,0.0001)));\n    p = prevP;\n    d = max(B(p,vec2(0.55,0.3)),d);\n    \n    p.x = abs(p.x)-0.7;\n    vec2 prevP2 = p;\n    float a = radians(-50.);\n    p.y = abs(p.y)-0.2;\n    float d2 = abs(max(-dot(p,vec2(cos(a),sin(a))),B(p,vec2(0.08,0.4))))-0.0001;\n    p = prevP2;\n    d2 = max(p.x-0.05,min(B(p-vec2(-0.08,0.0),vec2(0.003,0.03)),d2));\n    d = min(d,d2);\n    \n    p = prevP2;\n    p.y = abs(p.y)-0.35;\n    p*=Rot(radians(50.));\n    d2 = B(p,vec2(0.0001,0.15));\n    d = min(d,min(B(p,vec2(0.003,0.05)),d2));\n    \n    p = prevP;\n    p.x = abs(p.x)-0.56;\n    p.y = abs(p.y)-0.42;\n    p.x = abs(p.x)-0.012;\n    d2 = abs(length(p)-0.008)-0.0003;\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y = abs(p.y)-0.46;\n    p.y*=-1.;\n    d2 = abs(Tri(p,vec2(0.02)))-0.0005;\n    d = min(d,max(-(p.y+0.016),d2));\n    \n    p = prevP;\n    p.x = abs(p.x)-0.75;\n    p.y = mod(p.y,0.018)-0.009;\n    d2 = B(p,vec2(0.015,0.001));\n    d2 = max(abs(prevP.y)-0.05,d2);\n    d = min(d,d2);\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord-0.5*iResolution.xy) / iResolution.y;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    // camera movement\t\n\tfloat an = radians(90.);\n\tvec3 ro = vec3( 2.5*cos(an), 0., 2.5*sin(an) );\n    \n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.yz *= Rot(radians(5.0));\n        \n        float delay = 2.5;\n        float frame = mod(iTime,11.0+delay)-delay;\n        float time = frame;\n        \n        float duration = 0.7;\n        float rotVal = 0.0;\n        if(frame>=1. && frame<3.){\n            time = getTime(time-1.,duration);\n            rotVal = cubicInOut(time)*90.;\n        } else if(frame>=3. && frame<5.){\n            time = getTime(time-3.,duration);\n            rotVal = 90.+cubicInOut(time)*90.;\n        } else if(frame>=5. && frame<7.){\n            time = getTime(time-5.,duration);\n            rotVal = 180.+cubicInOut(time)*90.;\n        } else if(frame>=7. && frame<9.){\n            time = getTime(time-7.,duration);\n            rotVal = 270.+cubicInOut(time)*90.;\n        } else if(frame>=9.){\n            time = getTime(time-9.,duration+0.5);\n            rotVal = 360.-cubicInOut(time)*360.;\n        }\n        \n        ro.xz *= Rot(radians(-rotVal));\n    }\n    \n    vec3 ta = vec3( 0.0, 0.,0.0 );\n    \n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3 nor = vec3(0.0);\n\tvec3 pos = vec3(0.0);\n\tfloat oid = 0.0;\n    mat4 txxRef = mat4(0.0);\n    float dir = 0.0;\n    \n    float dist = .3;\n    for(float i = 0.; i<BOX_NUM; i+=1.){\n        int index = int(i);\n\n        float x = dist-(float(mod(i,3.))*dist);\n        float y = dist-(floor(mod(i,9.)/3.)*dist);\n        float z = dist-(floor(i/9.)*dist);\n\n        float rotVal = getAnimatedRotValue(i*0.15);\n        mat4 rot = rotationAxisAngle( normalize(mod(i,2.) ==0.?vec3(1.0,0.0,0.0):vec3(0.0,1.0,0.0)), radians(rotVal) );\n        \n        mat4 tra = translate( x, y, z );\n        mat4 txi = tra * rot; \n        mat4 txx = inverse( txi );\n        \n        vec4 res = iBox( ro, rd, txx, txi, vec3(0.15) );\n        if( res.x>0.0 && res.x<tmin  ) { \n            tmin = res.x; \n            nor = res.yzw;\n            oid = i;\n            txxRef = txx;\n            \n            dir = 1.;\n            if(mod(i,5.) == 0.)dir = -1.;\n        }\n    }\n\n\tvec3 col = vec3(0.) ;\n\n\tif( tmin<100.0 )\n\t{\n\t\tpos = ro + tmin*rd;\n\t\t\n        // materials\n\t\tfloat occ = 1.0;\n\t\tvec3 mate = vec3(1.0);\n        \n        for(float i = 0.; i<BOX_NUM; i+=1.){\n            int index = int(i);\n            if(oid == i){\n                vec3 opos = (txxRef*vec4(pos,1.0)).xyz;\n                vec3 onor = (txxRef*vec4(nor,0.0)).xyz;\n\n                vec3 colXZ = mix(col,vec3(1.),S(truchetGraphic(opos.xz,dir),0.0));\n                vec3 colYZ = mix(col,vec3(1.),S(truchetGraphic(opos.yz,dir),0.0));\n                vec3 colXY = mix(col,vec3(1.),S(truchetGraphic(opos.xy,dir),0.0));\n                mate = colXZ*abs(onor.y)+colXY*abs(onor.z)+colYZ*abs(onor.x);\n             }\n        }\n        \n        // lighting\n        vec3 lig = normalize(vec3(0.8,2.4,3.0));\n        float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n        vec3 hal = normalize(lig-rd);\n        \n        float amb = 0.6 + 0.4*nor.y;\n        float bou = clamp(0.3-0.7*nor.y,0.0,1.0);\n        float spe = clamp(dot(nor,hal),0.0,1.0);\n        col  = 4.0*vec3(1.00,0.80,0.60)*dif;\n        col += 2.0*vec3(0.20,0.30,0.40)*amb;\n        col += 2.0*vec3(0.30,0.20,0.10)*bou;\n        col *= mate;                      \n\t} else {\n        float d = ui(p);\n        col = mix(col,vec3(0.7),S(d,0.0));\n    }\n\t\n    // gamma\n    col = pow( col, vec3(0.45) );\n\n\tfragColor = vec4( col, 1.0 );\n}\n\n\n\n\n\n/* // The old shader to test. This one is the ray marching version.\n#define MAX_STEPS 36\n#define MAX_DIST 2.\n#define SURF_DIST .003\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.5),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define deg45 .707\n#define R45(p) (( p + vec2(p.y,-p.x) ) *deg45)\n#define Tri(p,s) max(R45(p).x,max(R45(p).y,B(p,s)))\n#define SymdirY(p) mod(floor(p).y,2.)*2.-1.\n\nvec3 positions[27] = vec3[](vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.));\nmat2 rots[27] = mat2[](mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.));\nfloat dirs[27] = float[](1.,-1.,1.,1.,1.,-1.,1.,-1.,1.,1.,-1.,1.,1.,1.,-1.,1.,-1.,1.,1.,-1.,1.,1.,1.,-1.,1.,-1.,1.);\n\nfloat B3D(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nfloat getTime(float t, float duration){\n    return clamp(t,0.0,duration)/duration;\n}\n\nfloat getAnimatedRotValue(float delay){\n    float frame = mod(iTime,9.0+delay)-delay;\n    float time = frame;\n    float duration = 0.7;\n    float rotVal = 0.0;\n    if(frame>=1. && frame<3.){\n        time = getTime(time-1.,duration);\n        rotVal = cubicInOut(time)*90.;\n    } else if(frame>=3. && frame<5.){\n        time = getTime(time-3.,duration);\n        rotVal = 90.+cubicInOut(time)*90.;\n    } else if(frame>=5. && frame<7.){\n        time = getTime(time-5.,duration);\n        rotVal = 180.+cubicInOut(time)*90.;\n    } else if(frame>=7. && frame<9.){\n        time = getTime(time-7.,duration);\n        rotVal = 270.+cubicInOut(time)*90.;\n    }\n    \n    return rotVal;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    \n    vec2 res = vec2(0.0);\n    float dist = .3;\n    float size = .15;\n    \n    float rotVal = getAnimatedRotValue(0.0);\n    int index = 0;\n\n    positions[index] = vec3(dist);\n    rots[index] = Rot(radians(rotVal));\n    p += positions[index];\n    p.yz*= rots[index];\n    float d = B3D(p,vec3(size));\n\n    res = vec2(d,index);    \n \n    float len = float(positions.length());\n    for(float i = 1.; i<len; i+=1.){\n        p = prevP;\n        float rotVal = getAnimatedRotValue(i*0.15);\n        index = int(i);\n        \n        float x = dist-(float(mod(i,3.))*dist);\n        float y = dist-(floor(mod(i,9.)/3.)*dist);\n        float z = dist-(floor(i/9.)*dist);\n        positions[index] = vec3(x,y,z);\n        rots[index] = Rot(radians(rotVal));\n        p += positions[index];\n        if(dirs[index] == 1.){\n            p.yz*= rots[index];\n        } else {\n            p.xz*= rots[index];\n        }\n        \n        float d = B3D(p,vec3(size));\n\n        vec2 res2 = vec2(d,index);\n        res = mix(res,res2,step(res2.x,res.x));\n    }\n    \n    return res;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,10,-20));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff;\n    diffCol += col*vec3(0.5)*bounceDiff;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.); // spec\n        \n    return diffCol;\n}\n\nfloat truchetGraphic(vec2 p, float dir){\n    vec2 prevP = p;\n    p.x*=dir;\n    p*=Rot(radians(45.));\n    p.x = abs(p.x)-0.212;\n    \n    p*=Rot(radians(45.));\n    vec2 prevP2 = p;\n    float a = radians(45.);\n    float d = abs(max(-dot(p+vec2(0.095),vec2(cos(a),sin(a))),B(p,vec2(0.15))))-0.03;\n    p+=vec2(0.085);\n    p*=Rot(radians(45.));\n    d = max(-B(p,vec2(0.03,0.003)),d);\n    \n    p = prevP2;\n    p+=vec2(0.105);\n    \n    p*=Rot(radians(45.));\n    p.x = abs(p.x)-0.075;\n    d = max(-B(p,vec2(0.007)),d);\n    \n    p = prevP;\n    p = mod(p,0.03)-0.015;\n    float d2 = length(p)-0.0005;\n    d = min(d,d2);\n    \n    p = prevP;\n    \n    p.y*=dir;\n    p*=Rot(radians(45.));\n    float sdir = SymdirY(p);\n    p.x*=1.7;\n    p.y+=iTime*0.1*sdir;\n    p.y = mod(p.y,0.08)-0.04;\n    p.y*=sdir*-1.;\n    d2 = Tri(p,vec2(0.015));\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x*=dir;\n    p*=Rot(radians(135.));\n    p.y = abs(p.y)-0.17;\n    p*=Rot(radians(45.));\n    d2 = min(B(p,vec2(0.0005,0.01)),B(p,vec2(0.01,0.0005)));\n    d = min(d,d2);\n    \n    return d;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    vec3 n2 = n;\n    p+=positions[mat];\n    if(dirs[mat] == 1.){\n        p.yz*= rots[mat];\n        n2.yz*= rots[mat];\n    } else {\n        p.xz*= rots[mat];\n        n2.xz*= rots[mat];\n    }\n    \n    col = diffuseMaterial(n,rd,p,vec3(0.2));\n    \n    vec3 colXZ = mix(col,vec3(1.),S(truchetGraphic(p.xz,dirs[mat]),0.0));\n    vec3 colYZ = mix(col,vec3(1.),S(truchetGraphic(p.yz,dirs[mat]),0.0));\n    vec3 colXY = mix(col,vec3(1.),S(truchetGraphic(p.xy,dirs[mat]),0.0));\n\n    return colXZ*n2.y+colXY*n2.z+colYZ*n2.x;\n}\n\nfloat ui(vec2 p){\n    vec2 prevP = p;\n    p = mod(p,0.06)-0.03;\n    float d = min(B(p,vec2(0.0001,0.006)),B(p,vec2(0.006,0.0001)));\n    p = prevP;\n    d = max(B(p,vec2(0.55,0.3)),d);\n    \n    p.x = abs(p.x)-0.7;\n    vec2 prevP2 = p;\n    float a = radians(-50.);\n    p.y = abs(p.y)-0.2;\n    float d2 = abs(max(-dot(p,vec2(cos(a),sin(a))),B(p,vec2(0.08,0.4))))-0.0001;\n    p = prevP2;\n    d2 = max(p.x-0.05,min(B(p-vec2(-0.08,0.0),vec2(0.003,0.03)),d2));\n    d = min(d,d2);\n    \n    p = prevP2;\n    p.y = abs(p.y)-0.35;\n    p*=Rot(radians(50.));\n    d2 = B(p,vec2(0.0001,0.15));\n    d = min(d,min(B(p,vec2(0.003,0.05)),d2));\n    \n    p = prevP;\n    p.x = abs(p.x)-0.56;\n    p.y = abs(p.y)-0.42;\n    p.x = abs(p.x)-0.012;\n    d2 = abs(length(p)-0.008)-0.0003;\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y = abs(p.y)-0.46;\n    p.y*=-1.;\n    d2 = abs(Tri(p,vec2(0.02)))-0.0005;\n    d = min(d,max(-(p.y+0.016),d2));\n    \n    p = prevP;\n    p.x = abs(p.x)-0.75;\n    p.y = mod(p.y,0.018)-0.009;\n    d2 = B(p,vec2(0.015,0.001));\n    d2 = max(abs(prevP.y)-0.05,d2);\n    d = min(d,d2);\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, -1.57);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.yz *= Rot(radians(-5.0));\n        \n        float delay = 2.5;\n        float frame = mod(iTime,11.0+delay)-delay;\n        float time = frame;\n        \n        float duration = 0.7;\n        float rotVal = 0.0;\n        if(frame>=1. && frame<3.){\n            time = getTime(time-1.,duration);\n            rotVal = cubicInOut(time)*90.;\n        } else if(frame>=3. && frame<5.){\n            time = getTime(time-3.,duration);\n            rotVal = 90.+cubicInOut(time)*90.;\n        } else if(frame>=5. && frame<7.){\n            time = getTime(time-5.,duration);\n            rotVal = 180.+cubicInOut(time)*90.;\n        } else if(frame>=7. && frame<9.){\n            time = getTime(time-7.,duration);\n            rotVal = 270.+cubicInOut(time)*90.;\n        } else if(frame>=9.){\n            time = getTime(time-9.,duration+0.5);\n            rotVal = 360.-cubicInOut(time)*360.;\n        }\n        \n        ro.xz *= Rot(radians(-rotVal));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    } else {\n        float ud = ui(uv);\n        col = mix(col,vec3(0.7),S(ud,0.0));\n    }\n    \n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}