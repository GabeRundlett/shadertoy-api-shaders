{
    "Shader": {
        "info": {
            "date": "1569298792",
            "description": "Help me.\n・ Cylinder wall noise\n・ Fireflies at the box corner\nI don't know why these happen and how to fix them\n\nDebug information can be displayed with the following buttons.\n\nZ - Primary Normal\nX - Reflected Ray\nC - Secondary Normal",
            "flags": 16,
            "hasliked": 0,
            "id": "td3GD2",
            "likes": 3,
            "name": "Why noisy reflections?",
            "published": 3,
            "tags": [
                "reflection"
            ],
            "usePreview": 0,
            "username": "kaneta",
            "viewed": 559
        },
        "renderpass": [
            {
                "code": "#define MAT_FLOOR 0.\n#define MAT_BALL 3.\n#define MAT_LIGHT 4.\n\nconst float pi = acos(-1.0);\nconst float pi2 = pi * 2.0;\n\n/////////////////////////\n\n// Keyboard \n\n\n// Keyboard constants definition\n// https://www.shadertoy.com/view/XdcGWS by P_Malin\n\nconst int KEY_C     = 67;\nconst int KEY_X     = 88;\nconst int KEY_Z     = 90;\n\nbool KeyIsPressed(int key)\n{\n\treturn texelFetch( iChannel0, ivec2(key, 0), 0 ).x > 0.0;\n}\n\n/////////////////////////\n\n// Utility\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvec2 pmod(vec2 p, float r) {\n    float a = pi/r - atan(p.x, p.y);\n    float n = pi2/r;\n    a = floor(a/n)*n;\n    return p * rot(a);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n\treturn a.x < b.x ? a : b;\n}\n///////////////////////////////////////////////\n\n// Distance Functions\n// by https://iquilezles.org/articles/distfunctions\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvec2 lightTube(vec3 p, float r) {\n    p.xz *= rot(pi * 0.2);\n\tp.xz = pmod(p.xz, 5.0);\n    float a = pi * 0.1;\n\tfloat s1 = sdCappedTorus(p, vec2(sin(a), cos(a)), 8.05, 0.1);\n    return vec2(s1, MAT_LIGHT);\n}\n\nvec2 object(vec3 p) {\n    vec2 s = vec2(sphere(p - vec3(0.0, cos(iTime) * 0.1, 0.0), 0.25), MAT_BALL);\n\treturn s;\n}\n\nvec2 room(vec3 p) {\n    return vec2(-cylinder(p, 8.0, 4.0), MAT_FLOOR);\n}\n\nvec2 map(vec3 p) {\n\tvec2 o = object(p - vec3(0.0, -2.0, 0.0));\n    vec2 r = room(p);\n    \n    vec2 d = min2(r, o);\n    \n    d = min2(d, lightTube(p - vec3(0.0, -3.85, 0.0), 5.0));\n    d = min2(d, lightTube(p - vec3(0.0, -0.85, 0.0), 5.0));\n    d = min2(d, vec2(sdBox(p - vec3(0.0, -2.85, 0.0), vec3(0.5)), MAT_FLOOR));\n    \n    return d;\n}\n///////////////////////////////////////////////////////////////////////\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(1.0, -1.0) * 0.0001;\n    return normalize(\n        e.xyy * map(p+e.xyy).x+\n        e.yxy * map(p+e.yxy).x+\n        e.yyx * map(p+e.yyx).x+\n        e.xxx * map(p+e.xxx).x\n        );\n}\n\nvoid getSurfaceParams(vec3 p, vec2 mat, out vec3 outEmission) {\n    outEmission = vec3(0.0);\n    if (mat.y == MAT_FLOOR) {\n    } else if (mat.y == MAT_BALL) {\n        outEmission = vec3(0.6, 0.05, 0.01) * 4.0 * (sin(iTime) * 0.5 + 0.5);\n    } else if (mat.y == MAT_LIGHT) {\n        outEmission = vec3(4.0);\n    }\n}\n\nvoid trace(vec3 p, vec3 ray, float tmax, int ite, out vec3 outPos, out vec2 outMat, out float depth) {\n    float t = 0.1;\n    vec3 result = vec3(0.0), pos;\n    vec2 mat;\n    for(int i = 0; i < ite; i++) {\n        if (t > tmax) break;\n        pos = ray * t + p;\n        mat = map(pos);\n        if (mat.x < 0.001) break;\n        t += mat.x;\n    }\n    depth = t;\n    outPos = pos;\n    outMat = mat;\n}\n\nvec3 render(vec3 p, vec3 ray) {\n    vec3 emission;\n    float depth;\n\n    // Primary ray\n    vec3 primaryPos;\n    vec2 primaryMat;\n    trace(p, ray, 100.0, 256, primaryPos, primaryMat, depth);\n    getSurfaceParams(primaryPos, primaryMat, emission);\n    vec3 n = normal(primaryPos);\n\n    vec3 result = emission;\n\n    // Secondary ray\n    vec3 secondaryPos;\n    vec2 secondaryMat;\n    ray = reflect(ray, n);\n    trace(primaryPos + n * 0.001, ray, 100.0, 128, secondaryPos, secondaryMat, depth);\n    getSurfaceParams(secondaryPos, secondaryMat, emission);\n    \n    // Why noisy???\n    result += emission * 0.04;\n\n    // Debug\n    if(KeyIsPressed(KEY_Z)) {\n        // Primary normal\n    \tresult = normal(primaryPos);\n    }\n    if(KeyIsPressed(KEY_X)) {\n        // Reflected ray\n    \tresult = ray;\n    }\n    if(KeyIsPressed(KEY_C)) {\n        // Secondary normal\n    \tresult = normal(secondaryPos);\n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 col = vec3(0.0);\n\n    vec3 origin = vec3(sin(iTime) * 2.0, -1.0, 5.0);\n    vec3 target = vec3(0.0, -2., 0.);\n    vec3 fo = normalize(target - origin);\n    vec3 si = normalize(cross(vec3(0.0, 1.0, 0.0), fo));\n    vec3 up = normalize(cross(fo, si));\n    vec3 ray = normalize(fo * 4.5 + si * p.x + up * p.y);\n\n\n    col += render(origin, ray);\n\n    col = pow(col, vec3(1.0/2.2));\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}