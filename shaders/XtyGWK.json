{
    "Shader": {
        "info": {
            "date": "1476787587",
            "description": "0.-1A6\nVERSION 0.-1 Î±.4 :\n     Waving Water, Blue.\n-v.0-1A6\n     New color. Special Effect If You Go Further Away From Laptop/Desktop. Move Bouy with mouse.",
            "flags": 16,
            "hasliked": 0,
            "id": "XtyGWK",
            "likes": 3,
            "name": "The shallow buoy",
            "published": 3,
            "tags": [
                "water",
                "raynarching"
            ],
            "usePreview": 0,
            "username": "Imsure1200q_1UWE130",
            "viewed": 878
        },
        "renderpass": [
            {
                "code": "const float pi = asin(1.)*2.;\nconst float KEY_SP = 36.5/256.0;\nvec3 translation( vec3 p, vec3 dl )\n{\n    \n    return p-dl;\n}\nvec3 dilation(vec3 ro)\n{\n    return ro+log2(pi);\n}\nvec3 tespos(vec3 p, float i)\n{\n    vec3 p1 = vec3(\n        p.x,\n        p.y,\n        p.z);\n    return p1;\n}\nvec3 rotation(vec3 p)\n{\n    return p*cos(p.x)*sin(p.z);\n}\nvec3 ftal(vec3 p, vec2 uv)\n{\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 center;\n    if(length(uv)-0.5 > 0.2)\n    {\n        center = vec2(1.);\n    }\n    p = vec3(p.xy+center, p.z);\n    vec3 ro = rotation(p);\n    vec3 dl = dilation(ro);\n    vec3 tr = translation(p, dl);\n    return tr;\n    \n}\nfloat sdPlane( vec3 p, bool water, bool sand )\n{\n    if(water == true)\n    {\n    float f = mod( sin(1.0*p.z-iTime)+\n                           tan(1.0*p.x-iTime), 0.25/max(abs(p.z), 1.25));\n    float g = mod( sin(1.0*p.x-iTime)+\n                           atan(1.0*p.z-iTime), 1.25/max(abs(p.x), 2.25));\n    float h = mod( sin(2.5*p.z-iTime)+\n                           tan(0.5*p.x-iTime), 0.5/max(abs(p.z), 1.5));\n    float i = mod( sin(2.5*p.x-iTime)+\n                           atan(0.5*p.z-iTime), 0.7/max(abs(p.x), 1.7));\n\treturn p.y+(f*g+h*i);\n    }\n    else\n    {\n        return p.y;\n    }\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0))-r;\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nmat3 rotate3d(float a)\n{\n    return mat3(cos(a),-sin(a),sin(a),\n                cos(a),cos(a),-sin(a),\n                sin(a),cos(a),cos(a));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\nfloat blend (float a, float b, float k) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b,a,h) - k*h*(1.0-h);\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\nfloat scDir(float p, float s)\n{\n    vec3 x = vec3(p);\n    return length(cross(sin(x), cos(x))-cross(asin(x),acos(x)))-s;\n}\nfloat snDir(float p, float s)\n{\n    vec3 x = normalize(vec3(p));\n    vec2 y = vec2(p);\n    return scDir(length(x)-s, s);\n}\nvec2 blend(vec2 a, vec2 b, float k)\n{\n    return vec2(blend(a.x,b.x,k),(a.x>b.x) ? b.y : a.y);\n}\nvec2 map( vec3 pos, vec3 mo )\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    float lengthuv = length(uv*2.0-1.0)-1.0;\n    vec3 lv = vec3(lengthuv);\n    lv -= vec3(0.1, 0.6, 0.9);\n    vec3 sun = reflect(lv, pos);\n    vec3 p = vec3(pos.x, pos.y+0.1, pos.z);\n    float d1;\n    float d2;\n    float d3;\n    vec2 x = vec2(sdPlane(p, true, false),1.2);\n    float tf = 0.0;\n    //Putting An Object:\n    /*Copy & Paste:\n    p = vec3(pos.x, pos.y, pos.z); // Position: Add For Negative, Subtract For Positive.\n    //p *= rotate2d(<degrees>); //Rotation' <degrees> means the degrees of rotation. ex.:90, 180, 240, 360.\n    d1 = <fos>(<arguments>);\n    //<fos> means function of shape (sdSphere, sdBox, sdRoundBox, sdHexPrism, etc.);\n    //<arguments> means number of variables that should be extracted to he function.\n    x = opU(vec2(d1, 3.0), x);\n    */\n    p = vec3(pos.x+1., pos.y+(sin(iTime))/8.+0.3, pos.z);\n    \n    // Position: Add For Negative, Subtract For Positive.\n    //p *= rotate2d(<degrees>); //Rotation' <degrees> means the degrees of rotation. ex.:90, 180, 240, 360\n    d1 = sdSphere(p, 0.45);\n    //<fos> means function of shape (sdSphere, sdBox, sdRoundBox, sdHexPrism, etc.);\n    //<arguments> means number of variables that should be extracted to he function.\n    x =  blend(vec2(d1, 1.1), x+vec2(0.001, 0.), 0.2);\n    \n    p = vec3(pos.x-13., pos.y, pos.z-0.1);\n    d1 = sdSphere(p, 2.);\n    p = vec3(pos.x-9.6, pos.y, pos.z+3.6);\n    d2 = sdSphere(p, 1.5);\n    d3 = blend(d1, d2, 3.6);\n    p = vec3(pos.x-12.1, pos.y, pos.z-4.2);\n    d1 = sdSphere(p, 3.);\n    p = vec3(pos.x-16.0, pos.y, pos.z+2.5);\n    d2 = sdSphere(p, 2.5);\n    d3 = blend(blend(d3, d1, 1.8), d2, 1.8);\n    p = vec3(pos.x-10.0, pos.y+2.25, pos.z);\n    d1 = sdSphere(p, 3.);\n    d3 = blend(d3, d1, 0.1);\n    x = blend(vec2(d3, 1.3), x, 0.1);\n    \n    \n    return x;\n    \n}\nvec2 castRay( in vec3 ro, in vec3 rd, in vec3 mo )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t, mo );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in vec3 mo )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ,mo).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\nfloat softreflect( in vec3 ro, in vec3 rd, in float mint, in float tmax, in vec3 mo, vec3 ref )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ,mo).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 )-ref.x;\n}\n\nvec3 calcNormal( in vec3 pos, in vec3 mo )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy,mo).x - map(pos-eps.xyy,mo).x,\n\t    map(pos+eps.yxy,mo).x - map(pos-eps.yxy,mo).x,\n\t    map(pos+eps.yyx,mo).x - map(pos-eps.yyx,mo).x );\n\treturn normalize(nor);\n}\nfloat calcAO( in vec3 pos, in vec3 nor, in vec3 mo )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, mo ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec4 render( in vec3 ro, in vec3 rd, in vec3 mo )\n{\n    \n    vec4 dfcol = vec4(0.7, 0.9, 1.0, 1.0);\n    vec2 res = castRay(ro,rd,mo);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 col = dfcol.xyz;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos,mo );\n        vec3 ref = reflect( rd, nor );\n        vec3 refr = refract(rd, nor, m);\n        \n        vec2 uv = gl_FragCoord.xy / iResolution.xy;\n        float lengthuv = length(uv*2.0-1.0)-1.0;\n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        float occ = calcAO(pos, nor, mo);\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref*refr, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5, mo);\n        dom *= softshadow( pos, ref, 0.02, 2.5, mo );\n        \n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n        if( m==1.2)\n        {\n            \n            float f = mod( sin(1.0*pos.z-iTime)+\n                           tan(1.0*pos.x-iTime), 0.25);\n            float g = mod( sin(1.0*pos.x-iTime)+\n                           tan(1.0*pos.z-iTime), 0.25);\n            float h = mod( sin(2.5*pos.z-iTime)+\n                           tan(2.5*pos.x-iTime), 0.3);\n            float i = mod( sin(2.5*pos.x-iTime)+\n                           tan(2.5*pos.z-iTime), 0.3);\n            col = 0.4 + 0.1*((f*g+h*i))*vec3(1.0)+vec3(0.1, 0.9, 0.6)-vec3(0.4);\n            col -= (vec3(0.1, 0.8, 0.4)*max(\n                sin(pos.y+pos.x*fract(sin(pos.x)))*\n                cos(pos.z+pos.y*pos.x*fract(cos(pos.z))), 0.1));\n            col -= (vec3(0.0, 0.3, -0.3)*max(\n                (sin(pos.z+cos(pos.x+tan(pos.y))+sin(pos.z+pos.x))+\n                cos(pos.z+pos.x+fract(\n                    sin(\n                        dot(pos, vec3(126.1,311.7,496.3)))\n                *43758.5453123))+sin(cos(pos.x)/pos.z))*sin(pos.x), 0.0));\n            col += ref.y*0.1/fre*spe;\n        }\n        else if(m==1.1)\n        {\n            if(nor.y > -0.1)\n            {\n                if(nor.x > 0.1) col = vec3(calcAO(vec3(calcAO(pos, nor,mo)),ref,mo))-\n                    (vec3(1.)-vec3(1.0, 0.0, 0.0));\n                else if(nor.z < -0.1) col = vec3(1.0);\n                else if(nor.z > 0.1) col = vec3(calcAO(vec3(calcAO(pos, nor,mo)),ref,mo))-\n                    (vec3(1.)-vec3(1.0));\n                    \n                else if(nor.z > -0.1 && nor.z < 0.1){col = vec3(0.0);}\n            }\n            if(nor.y > 0.95)\n            {\n                col = vec3(1.0, 1.0, 0.0);\n            }\n        }\n        else if(m==1.3)\n        {\n            col = texture(iChannel1, vec2(pos.y+pos.x, pos.y+pos.z)*2.).rgb -\n                (vec3(1.0)-vec3(0.9, 0.9, 0.8))+vec3(0.25);\n            col /= smoothstep(-0.1, 0.1, lin);\n        }\n\n        // lighitng        \n\t\t\n\t\tcol = col*lin;\n\n    \tdfcol = vec4(vec3(mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) )), 1.);\n\n    }\n\n\treturn vec4( clamp(dfcol,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( 5.*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y,5.*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( 0., 2., 0. );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec4 col = render( ro, rd, vec3(mo, iMouse.z/iResolution.z) );\n\n\tcol = pow( col, vec4(0.4545) );\n\n    fragColor=vec4( col );\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}