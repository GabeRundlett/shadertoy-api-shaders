{
    "Shader": {
        "info": {
            "date": "1720969035",
            "description": "Very simple spectral ray tracer. The index of refraction of dielectric materials depends on the wavelength via the Cauchy equation.",
            "flags": 32,
            "hasliked": 0,
            "id": "Mfsyz7",
            "likes": 20,
            "name": "Spectral Ray Tracing",
            "published": 3,
            "tags": [
                "raytracer",
                "ray",
                "tracing",
                "spectral"
            ],
            "usePreview": 0,
            "username": "javirk",
            "viewed": 284
        },
        "renderpass": [
            {
                "code": "// Spectral Ray Tracing. Created by Javier Gamazo - 2024\n// The MIT License\n//\n// https://www.shadertoy.com/view/tl23Rm\n// Taking some parts from https://www.shadertoy.com/view/tl23Rm and https://www.shadertoy.com/view/tsKyWG\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 col = data.rgb / data.w;\n    \n    // gamma correction\n    col = max( vec3(0), col - 0.004);\n    col = (col*(6.2*col + .5)) / (col*(6.2*col+1.7) + 0.06);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Ray Tracing - Primitives. Created by Javier Gamazo 2024\n//\n// I have combined different intersection routines in one shader (similar \n// to \"Raymarching - Primitives\": https://www.shadertoy.com/view/Xds3zN) and\n// added a simple ray tracer to visualize a scene with all primitives.\n// Functions for CIE from https://www.shadertoy.com/view/tsKyWG\n\n#define PI 3.14159265358979323\n#define PATH_LENGTH 12\n\n#define LOWER_BOUND 450\n#define UPPER_BOUND 750\n#define NUM_WAVELENGTHS 20\n// #define MOVE_CAMERA\n\n#define LAMBERTIAN 0\n#define METAL 1\n#define DIELECTRIC 2\n\nconst mat3 XYZ_2_RGB = (mat3(\n     3.2404542,-0.9692660, 0.0556434,\n    -1.5371385, 1.8760108,-0.2040259,\n    -0.4985314, 0.0415560, 1.0572252\n));\n\nconst mat3 RGB_2_XYZ = (mat3(\n    0.4124564, 0.2126729, 0.0193339,\n    0.3575761, 0.7151522, 0.1191920,\n    0.1804375, 0.0721750, 0.9503041\n));\n\nfloat gaussian(float x, float mu, float sigma)\n{\n    return 1.0 / (sigma * sqrt(2.0 * PI)) * exp(-(x-mu)*(x-mu)/(2.*sigma*sigma));\n}\n\n\n// The CIE color matching functions were taken from  https://www.fourmilab.ch/documents/specrend\n// The tabulated functions then were approximated with gaussians (for G and B) and with a mixture of two gaussiuns (R).\nvec3 wavelength2XYZ(float l)\n{\n\treturn vec3(\n    \t8233.31 * gaussian(l, 593.951, 34.00) + 1891.26 * gaussian(l, 448.89, 18.785),\n        10522.64 * gaussian(l, 555.38, 40.80),\n        11254.78 * gaussian(l, 452.98, 21.57)\n    );\n}\n\nfloat XYZ2WavelengthApprox(float l, vec3 color) {\n    return dot(wavelength2XYZ(l), color) / 100.0;\n}\n\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n    float wavelength;\n};\n\nstruct Material\n{\n    int   materialType;\n    vec3  albedo;\n    float fuzz;\n    float refractionIndex;\n};\n\nstruct Hit\n{\n    float t;\n    vec3 p;\n    vec3 normal;\n    Material mat;\n};\n\nstruct Sphere{\n    vec3 center;\n    float radius;\n    Material mat;\n};\n\nSphere sceneList[] = Sphere[3](\n    Sphere(\n        vec3(0., 0., 0.),\n        1.,\n        Material(DIELECTRIC, vec3(.5, .4, .4), 1., 1.5)\n    ),\n    Sphere(\n        vec3(1.5, 0.2, 0.2),\n        0.2,\n        Material(DIELECTRIC, vec3(.5, .4, .4), 1., 1.5)\n    ),\n    Sphere(\n        vec3(0., -1001., 0.),\n        1000.,\n        Material(LAMBERTIAN, vec3(.5, .5, .2), .4, 0.)\n    )\n);\n\n\nbool Sphere_hit(Sphere sphere, Ray ray, float t_min, float t_max, out Hit rec)\n{\n    vec3 oc = ray.origin - sphere.center;\n    float a = dot(ray.direction, ray.direction);\n    float b = dot(oc, ray.direction);\n    float c = dot(oc, oc) - sphere.radius * sphere.radius;\n\n    float discriminant = b * b - a * c;\n\n    if (discriminant > 0.0f)\n    {\n        float temp = (-b - sqrt(discriminant)) / a;\n\n        if (temp < t_max && temp > t_min){\n            rec.t = temp;\n            rec.p = ray.origin + rec.t * ray.direction;\n            rec.normal = (rec.p - sphere.center) / sphere.radius;\n            rec.mat = sphere.mat;\n            return true;\n        }\n\n        temp = (-b + sqrt(discriminant)) / a;\n\n        if (temp < t_max && temp > t_min){\n            rec.t = temp;\n            rec.p = ray.origin + rec.t * ray.direction;\n            rec.normal = (rec.p - sphere.center) / sphere.radius;\n            rec.mat = sphere.mat;\n            return true;\n        }\n    }\n\n    return false;\n}\n\n\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nuint baseHash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1(inout float seed) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash2(inout float seed) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\n//\n// Ray tracer helper functions\n//\n\nfloat FresnelSchlickRoughness(float cosTheta, float F0, float roughness) {\n    return F0 + (max((1. - roughness), F0) - F0) * pow(abs(1. - cosTheta), 5.0);\n}\n\nvec3 cosWeightedRandomHemisphereDirection(const vec3 n, inout float seed) {\n  \tvec2 r = hash2(seed);\n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tfloat rz = sqrt(1.-r.y);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    return normalize(rr);\n}\n\nvec3 modifyDirectionWithRoughness(const vec3 normal, const vec3 n, const float roughness, inout float seed) {\n    vec2 r = hash2(seed);\n    \n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\t\n    float a = roughness*roughness;\n    \n\tfloat rz = sqrt(abs((1.0-r.y) / clamp(1.+(a - 1.)*r.y,.00001,1.)));\n\tfloat ra = sqrt(abs(1.-rz*rz));\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    \n    vec3 ret = normalize(rr);\n    return dot(ret,normal) > 0. ? ret : n;\n}\n\nvec2 randomInUnitDisk(inout float seed) {\n    vec2 h = hash2(seed) * vec2(1,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r*vec2(sin(phi),cos(phi));\n}\n\n//\n// Scene description\n//\n\nvec3 rotateY(const in vec3 p, const in float t) {\n    float co = cos(t);\n    float si = sin(t);\n    vec2 xz = mat2(co,si,-si,co)*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nbool opU(inout vec2 d, float iResult, in Material mat) {\n    if (iResult < d.y) {\n        d.y = iResult;\n        return true;\n    }\n    return false;\n}\n\n//\n// Palette by Íñigo Quílez: \n// https://www.shadertoy.com/view/ll2GD3\n//\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(6.28318530718 * (c * t + d));\n}\n\nfloat checkerBoard(vec2 p) {\n   return mod(floor(p.x) + floor(p.y), 2.);\n}\n\nbool worldhit(in Ray ray, in vec2 dist, out Hit rec) {\n    Hit temp_rec;\n    bool hit_anything = false;\n    float closest_so_far = dist.y;\n\n    for (int i = 0; i < sceneList.length(); i++) {\n        if (Sphere_hit(sceneList[i], ray, dist.x, closest_so_far, temp_rec)) {\n            hit_anything = true;\n            closest_so_far = temp_rec.t;\n            rec = temp_rec;\n        }\n    }\n    return hit_anything;\n}\n\n\nvec3 getSkyColor(vec3 rd) {\n    vec3 col = mix(vec3(1), vec3(.5, .7, 1), .5 + .5 * rd.y);\n    col = vec3(0.);\n    float sun = clamp(dot(normalize(vec3(-0.3, .7, -.6)), rd), 0., 1.);\n    col += vec3(1, .6, .1) * (pow(sun, 4.) + 10. * pow(sun, 32.));\n    return col;\n}\n\nfloat gpuIndepentHash(float p) {\n    p = fract(p * .1031);\n    p *= p + 19.19;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat reflectivity(float n1_over_n2, float cosTheta, float wavelenght) {\n    float r0 = (n1_over_n2 - 1.) / (n1_over_n2 + 1.);\n    r0 = r0*r0;\n    return r0 + (1. - r0) * pow((1. - cosTheta), 5.);\n}\n\n//\n// Simple ray tracer\n//\n\nfloat schlick(float cosine, float r0) {\n    return r0 + (1. - r0) * pow(abs(1. - cosine), 5.);\n}\n\nvec3 refract_mine(vec3 v, vec3 n, float ni_over_nt) {\n    float cos_theta = min(dot(-v, n), 1.0);\n    vec3 r_out_perp = ni_over_nt * (v + cos_theta * n);\n    vec3 r_out_parallel = -sqrt(abs(1. - dot(r_out_perp, r_out_perp))) * n;\n    return r_out_perp + r_out_parallel;\n}\n\nfloat skyColor(Ray ray) {\n\tvec3 sky = getSkyColor(ray.direction);\n    sky = RGB_2_XYZ * pow(sky, vec3(2.2));\n    return XYZ2WavelengthApprox(ray.wavelength, sky) * 0.5;\n}\n\nfloat n_wavelength(float lambda_nm) {\n    float lambda_um = lambda_nm / 1000.0;\n    \n    // Coefficients for Cauchy's equation, adjusted to fit the range 1 < n < 2 for visible spectrum\n    float A = 0.438;\n    float B = 0.316;\n    \n    // Calculate refractive index\n    float n_lambda = A + B / (lambda_um * lambda_um);\n    \n    return n_lambda;\n}\n\n\nfloat trace(in Ray ray, inout float seed) {\n    vec3 albedo = vec3(1.); \n    float roughness, type;\n    Material mat;\n    Hit rec;\n    float intensity = 1.;\n    \n    for (int i = 0; i < PATH_LENGTH; ++i) {    \n    \tbool didHit = worldhit(ray, vec2(.001, 100), rec);\n        float res = rec.t;\n        Material mat = rec.mat;\n\t\tif (didHit) {\n\t\t\tray.origin += ray.direction * res;\n            //ray.origin -= ray.direction * .0001;  // This should work, but it doesn't\n            \n            if (mat.materialType == LAMBERTIAN) { // Added/hacked a reflection term\n                float F = FresnelSchlickRoughness(max(0.,-dot(rec.normal, ray.direction)), .04, mat.fuzz);\n                if (F > hash1(seed)) {\n                    ray.direction = modifyDirectionWithRoughness(rec.normal, reflect(ray.direction, rec.normal), mat.fuzz, seed);\n                } else {\n\t\t\t        ray.direction = cosWeightedRandomHemisphereDirection(rec.normal, seed);\n                }\n                intensity *= mat.albedo.x * max(0.0, dot(rec.normal, ray.direction) / PI) * PI;  // TODO: Make this more legible. attenuation * scatterPDF / pdf\n            } else if (mat.materialType == METAL) {\n                ray.direction = modifyDirectionWithRoughness(rec.normal, reflect(ray.direction, rec.normal), mat.fuzz, seed);            \n                intensity *= mat.albedo.x;  // TODO: Make this more legible.\n            } else { // DIELECTRIC\n                intensity *= 1.;\n                vec3 normal, refracted;\n                float ni_over_nt, cosine, reflectProb = 1.;\n                float refractionIndex = mat.refractionIndex;\n                refractionIndex = n_wavelength(ray.wavelength);\n                // rec.normal is always pointing outwards\n                if (dot(ray.direction, rec.normal) > 0.) {\n                    // Ray is inside\n                    normal = - rec.normal;\n            \t\tni_over_nt = refractionIndex;\n                    cosine = dot(ray.direction, normal);\n                    cosine = sqrt(1. - (refractionIndex * refractionIndex) - (refractionIndex * refractionIndex) * cosine * cosine);\n                } else {\n                    normal = rec.normal;\n                    ni_over_nt = 1. / refractionIndex;\n                    cosine = - dot(ray.direction, normal);\n                }\n            \n\t            // Refract the ray.\n\t            refracted = refract(normalize(ray.direction), normal, ni_over_nt);\n    \t        \n        \t    // Handle total internal reflection.\n                if(refracted != vec3(0)) {\n                \tfloat r0 = (1. - ni_over_nt)/(1. + ni_over_nt);\n\t        \t\treflectProb = FresnelSchlickRoughness(cosine, r0*r0, mat.fuzz);\n                }\n                \n                ray.direction = hash1(seed) <= reflectProb ? reflect(ray.direction, normal) : refracted;\n                ray.direction = modifyDirectionWithRoughness(normal, ray.direction, roughness, seed);            \n            }\n        } else {\n            intensity *= skyColor(ray);\n\t\t\treturn intensity;\n        }\n    }  \n    return 0.;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = (cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvec3 render(in Ray ray, inout float seed) {\n    vec3 col = vec3(0.);\n    // Loop over the wavelengths\n    for (int i = 0; i < NUM_WAVELENGTHS; i++) {\n        ray.wavelength = float(LOWER_BOUND + i * (UPPER_BOUND - LOWER_BOUND) / NUM_WAVELENGTHS);\n        float intensity = trace(ray, seed);\n        vec3 color = wavelength2XYZ(ray.wavelength);\n\n        col += color * intensity;\n    }\n    col = XYZ_2_RGB * col;\n    col /= float(NUM_WAVELENGTHS);\n    col /= 40.0;\n\tcol = clamp(col, vec3(0.0), vec3(1.0));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    bool reset = iFrame == 0;\n        \n    vec4 data = texelFetch(iChannel0, ivec2(0), 0);\n    \n    vec3 ro = vec3(3., 0., 0.);\n    vec3 ta = vec3(1., 0., 0.);\n    \n    #ifdef MOVE_CAMERA\n        vec2 mo = iMouse.xy == vec2(0) ? vec2(.125) : \n                abs(iMouse.xy)/iResolution.xy - .5;\n            \n        data = texelFetch(iChannel0, ivec2(0), 0);\n        if (round(mo*iResolution.xy) != round(data.yz) || round(data.w) != round(iResolution.x)) {\n            reset = true;\n        }\n        \n        ro = vec3(.5+2.5*cos(1.5+6.*mo.x), 1.+2.*mo.y, -.5+2.5*sin(1.5+6.*mo.x));\n        ta = vec3(.5, -.4, -.5);\n    #endif\n\n    mat3 ca = setCamera(ro, ta, 0.);\n    Material mat;\n\n    float fpd = data.x;\n    if(all(equal(ivec2(fragCoord), ivec2(0)))) {\n        // Calculate focus plane.\n        Hit rec;\n        Ray focus_ray = Ray(ro, normalize(vec3(.5,0,-.5)-ro), 0.);\n        bool didHit = worldhit(focus_ray, vec2(0, 100), rec);\n        fragColor = vec4(rec.t, iResolution.xy, iResolution.x);\n    } else { \n        vec2 p = (-iResolution.xy + 2. * fragCoord - 1.) / iResolution.y;\n        float seed = float(baseHash(floatBitsToUint(p - iTime))) / float(0xffffffffU);\n\n        // AA\n        p += 2. * hash2(seed) / iResolution.y;\n        vec3 rd = ca * normalize(vec3(p.xy, 1.6));  \n\n        // DOF\n        vec3 fp = ro + rd * fpd;\n        ro = ro + ca * vec3(randomInUnitDisk(seed), 0.) * .02;\n        rd = normalize(fp - ro);\n\n        Ray ray = Ray(ro, rd, 0.);\n\n        vec3 col = render(ray, seed);\n\n        if (reset) {\n            fragColor = vec4(col, 1);\n        } else {\n            fragColor = vec4(col, 1) + texelFetch(iChannel0, ivec2(fragCoord), 0);\n            //fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        }\n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}