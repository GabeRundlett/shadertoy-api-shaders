{
    "Shader": {
        "info": {
            "date": "1514132256",
            "description": "Compares single scattering with/without ozone absorption (left/right half of the screen) and two methods of converting 3 spectral samples to sRGB (even/odd quarters of the screen). Other options can be tweaked through defines exposed in the header.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "MllBR2",
            "likes": 21,
            "name": "Scattering with Ozone",
            "published": 3,
            "tags": [
                "scattering",
                "transmittance",
                "atmosphere",
                "ozone"
            ],
            "usePreview": 0,
            "username": "reinsteam",
            "viewed": 2564
        },
        "renderpass": [
            {
                "code": "// Created by reinsteam / Dec 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// 1 - Display transmittance table (mie+rayleigh, ozone only, all) / 0 - Display scattering\n#define ATM_SHOW_TRANSMITTANCE 0\n\n// 1 - Enable / 0 - Disable ozone absorption\n#define ATM_OZONE_ABSORPTION 1\n\n// Projection modes:\n//     1 - view space\n//     2 - equirectangular\n//     3 - fisheye\n#define ATM_PROJECTION_MODE 2\n\n// Tonemapping modes:\n//     1 - John Hable's Filmic ALU tonemapper\n//     2 - John Hable's Uncharted2 tonemapper\n#define ATM_TONEMAPPING_MODE 2\n\n// Options how view direction below horizon are handled\n//     0 - Use simply black color\n//     1 - Clamp view direction to use color at horizon\n#define ATM_CLAMP_BELOW_HORIZON 1\n\n#define ATM_NUM_SCATTERING_STEPS 24u\n#define ATM_NUM_TRANSMITTANCE_STEPS 16u\n\nconst float kAtmRadiusMin = 6360.0;\nconst float kAtmRadiusMax = 6420.0;\nconst float kKilometersToMeters = 1000.0;\n\nconst float kAtmRayHeightScale = 1.0 / 8.0;\nconst float kAtmMieHeightScale = 1.0 / 1.2;\n\n// http://www.iup.physik.uni-bremen.de/gruppen/molspec/databases/referencespectra/o3spectra2011/index.html\n// Version 22.07.2013: Fast Fourier Transform Filter applied to the initial data in the region 213.33 -317 nm\nconst float kAtmOznCrossSection_293K_680nm = 1.36820899679147; // * 10^-25 m^2 * molecule^-1\nconst float kAtmOznCrossSection_293K_550nm = 3.31405330400124; // * 10^-25 m^2 * molecule^-1\nconst float kAtmOznCrossSection_293K_440nm = 0.13601728252538; // * 10^-25 m^2 * molecule^-1\n\n// https://en.wikipedia.org/wiki/Number_density\nconst float kAtmAirNumberDensity_293K = 2.504; // * 10^25 molecule * m^-3\n\n// Choose 6 parts per million which is within 15 parts per million reported here:\n// https://ozonewatch.gsfc.nasa.gov/facts/ozone.html\nconst float kAtmOznConcentration = 6.0e-6;\n\n// Compute ozone absorption coefficients\nconst float kAtmOznNumberDensity_293K = kAtmAirNumberDensity_293K * kAtmOznConcentration;\nconst float kAtmOznAbsorption_293K_680nm = kAtmOznCrossSection_293K_680nm * kAtmOznNumberDensity_293K;\nconst float kAtmOznAbsorption_293K_550nm = kAtmOznCrossSection_293K_550nm * kAtmOznNumberDensity_293K;\nconst float kAtmOznAbsorption_293K_440nm = kAtmOznCrossSection_293K_440nm * kAtmOznNumberDensity_293K;\n\n// \n// Precomputed Rayleigh scattering coefficients for wavelength L using the following formula :\n// ScatteringCoeff(L) = (8.0*pi/3.0) * (n^2.0 - 1.0)^2.0 * ((6.0+3.0*p) / (6.0-7.0*p)) / (L^4.0 * N)\n// where\n// n - refractive index of the air (1.0003) https://en.wikipedia.org/wiki/Refractive_index\n// p - air depolarization factor (0.035) \n// N - air number density under NTP : (2.504 * 10^25 molecule * m^-3) \n// L - wavelength for which scattering coefficient is computed\n//\n// See \"Rayleigh-scattering calculations for the terrestrial atmosphere\" by A.Bucholtz for reference\n// \nconst float kAtmRayScattering_680nm =  5.8e-6;\nconst float kAtmRayScattering_550nm = 13.6e-6;\nconst float kAtmRayScattering_440nm = 33.1e-6;\n\nconst float kAtmMieScattering = 2.0e-6;\nconst float kAtmMieExtinction = kAtmMieScattering * 1.11;\n\n// cosine of horizon angle at top of the atmosphere\nconst float kAtmHorizonSinMin = kAtmRadiusMin / kAtmRadiusMax;\nconst float kAtmHorizonCosMin = -sqrt(max(1.0 - kAtmHorizonSinMin * kAtmHorizonSinMin, 0.0));\n\n// Luminance recovered from \"Reference Solar Spectral Irradiance: ASTM G-173\"\n// (http://rredc.nrel.gov/solar/spectra/am1.5/ASTMG173/ASTMG173.html)\n// Scaled by exp2(-16.0);\nconst float kAtmRadianceResponseToRGB_Lum = 2.225477;\n\n\n// Coefficients to convert 3 spectrum samples to linear sRGB\n// computed using formula 2 from Eric Bruneton's paper \n// \"A Qualitative and Quantitative Evaluation of 8 Clear Sky Models\"\n// Actual values are scaled by exp2(-16.0);\nconst float kAtmRadianceResponseToRGB_680nm = 2.795308;\nconst float kAtmRadianceResponseToRGB_550nm = 2.345072;\nconst float kAtmRadianceResponseToRGB_440nm = 2.079126;\n\nconst float kPi = 3.14159265359;\nconst float kOneOver4Pi = 1.0 / (4.0 * kPi);\n\nfloat Sqrt(float x)\n{\n    return sqrt(max(0.0, x));\n}\n\nfloat phaseR(float VoL)\n{\n    return kOneOver4Pi * 0.75 * (1.0 + VoL * VoL);\n}\n\nfloat phaseM_HG(float VoL, float G)\n{\n    float A = max(0.0, 1.0 + G * (G - 2.0 * VoL));\n    float D = 1.0 / Sqrt(A * A * A);\n    return (1.0 - G * G) * kOneOver4Pi * D;\n}\n\nfloat phaseM_CS(float VoL, float G)\n{\n    return 1.5 * (1.0 + VoL * VoL) * phaseM_HG(VoL, G) / (2.0 + G * G);\n}\n\nfloat AtmHorizonCos(float R)\n{\n    float SinH = kAtmRadiusMin / R;\n    float CosH = -Sqrt(1.0 - SinH * SinH);\n    return CosH;\n}\n\nfloat AtmIntersectTop(float R, float V)\n{\n    float RMaxOverR = kAtmRadiusMax / R;\n    return -R * (V - sqrt(V * V - 1.0 + RMaxOverR * RMaxOverR));\n}\n// V - cosine of the angle between view direction and zenith\n// R - radius at starting point\nvec3 OpticalLengthStep(float R, float V, float Di)\n{\n    // Re-compute radius at distance Di using cosine theorem\n    float Ri = Sqrt((Di + 2.0 * V * R) * Di + R * R);\n    float Hi = Ri - kAtmRadiusMin;\n    \n    // Standard Rayleigh / Mie density profiles\n    float RayDensity = exp(-Hi * kAtmRayHeightScale);\n    float MieDensity = exp(-Hi * kAtmMieHeightScale);\n    \n    // Piecewise linear approximation of the ozone profile from (Page 10) :\n    // ftp://es-ee.tor.ec.gc.ca/pub/ftpcm/!%20for%20Jacob/Introduction%20to%20atmospheric%20chemistry.pdf\n    // Density linearly increases from 0 at 15Km to 1.0 at 25Km and decreases back to 0.0 at 40.0Km\n    float OznDensity = Hi < 25.0 ? clamp( Hi / 15.0 - 2.0 / 3.0, 0.0, 1.0)\n                                 : clamp(-Hi / 15.0 + 8.0 / 3.0, 0.0, 1.0);\n    \n    return vec3(RayDensity, MieDensity, OznDensity * RayDensity);\n}\n\nvec3 OpticalLength(float R, float V, uint NumSteps)\n{    \n    // Early our with infinite to optical length below horizon to make transmittance -> 0.0\n    if (V <= AtmHorizonCos(R))\n    {\n        return vec3(1.0e9);\n    }\n    float MaxDistance = AtmIntersectTop(R, V);\n    float StpDistance = MaxDistance / float(NumSteps);\n    \n    vec3 OptLen = vec3(0.0);\n    \n    OptLen += OpticalLengthStep(R, V, 0.0);\n    OptLen += OpticalLengthStep(R, V, MaxDistance);\n    OptLen *= 0.5;\n    \n    for (uint iStep = 1u; iStep < NumSteps; ++iStep)\n    {\n        OptLen += OpticalLengthStep(R, V, float(iStep) * StpDistance);\n    }\n    return OptLen * StpDistance;\n}\n\nvec3 OznAbsorption()\n{\n\tvec3 Absorption;\n    Absorption.r = kAtmOznAbsorption_293K_680nm;\n    Absorption.g = kAtmOznAbsorption_293K_550nm;\n    Absorption.b = kAtmOznAbsorption_293K_440nm;\n#if ATM_OZONE_ABSORPTION\n    return Absorption * kKilometersToMeters;\n#else\n    return vec3(0.0);\n#endif\n}\n\nvec3 RayScattering()\n{\n    vec3 Scattering;\n    Scattering.r = kAtmRayScattering_680nm;\n    Scattering.g = kAtmRayScattering_550nm;\n    Scattering.b = kAtmRayScattering_440nm;\n    return Scattering * kKilometersToMeters;\n}\n\nvec3 MieExtinction()\n{\n    return vec3(kAtmMieExtinction * kKilometersToMeters);\n}\n\nvec3 MieScattering()\n{\n    return vec3(kAtmMieScattering * kKilometersToMeters);\n}\n\nvec3 Transmittance(vec3 OptLen, float UseOzoneAbsorption)\n{\n    vec3 OznOptDepth = OznAbsorption() * OptLen.b * UseOzoneAbsorption;\n    vec3 RayOptDepth = RayScattering() * OptLen.r;\n    vec3 MieOptDepth = MieScattering() * OptLen.g;\n    return exp(-(RayOptDepth + MieOptDepth + OznOptDepth));\n}\n\n// Parameters for ScatteringStep / Scattering functions\n// R \t\t- radius at starting point\n// V \t\t- cosine of the angle between view direction and zenith\n// L \t\t- cosine of the angle between direction to the light source and zenith\n// VoL \t\t- cosine of the angle between view direction and direction to the light source\n// Di  \t\t- current distance in direction defined by V\n// OptLenV \t- optical length from a starting to the atmosphere's top\n// UseOzoneAbsorption - 1.0 or 0.0 to enable or disbale ozone absorption\nvoid ScatteringStep(float R, float V, float L, float VoL, float Di, vec3 OptLenV, float UseOzoneAbsorption, out vec3 RayS, out vec3 MieS)\n{\n\tfloat Ri = Sqrt((Di + 2.0 * V * R) * Di + R * R);\n    float Vi = (R * V + Di) / Ri;\n    float Li = (R * L + Di * L) / Ri;\n    \n    if (Li > AtmHorizonCos(Ri))\n    {\n        // Opitcal length from a current point to the atmoshere bound \n        // in view direction and in direction to the light source\n        vec3 OptLenVi = OpticalLength(Ri, Vi, ATM_NUM_TRANSMITTANCE_STEPS);\n        vec3 OptLenLi = OpticalLength(Ri, Li, ATM_NUM_TRANSMITTANCE_STEPS);\n        \n        // Compute total optical length of the path and compute transmittance from it\n        vec3 Ti = Transmittance(max(OptLenV - OptLenVi, 0.0) + OptLenLi, UseOzoneAbsorption);\n        \n        float Hi = Ri - R;\n        \n        // Multiply by corresponding particle density\n        RayS = Ti * exp(-Hi * kAtmRayHeightScale);\n        MieS = Ti * exp(-Hi * kAtmMieHeightScale);\n    }\n}\n\nvoid Scattering(float R, float V, float L, float VoL, float UseOzoneAbsorption, out vec3 Scattering)\n{\n    vec3 RayS = vec3(0.0);\n    vec3 MieS = vec3(0.0);\n    \n    float CosH = AtmHorizonCos(R);\n\n#if ATM_CLAMP_BELOW_HORIZON\n    V = max(V, CosH);\n#else\n    if (V >= CosH)\n#endif\n    {\n        uint NumSteps = ATM_NUM_SCATTERING_STEPS;\n        float MaxDistance = AtmIntersectTop(R, V);\n    \tfloat StpDistance = MaxDistance / float(NumSteps);\n        \n        vec3 OptLenV = OpticalLength(R, V, ATM_NUM_TRANSMITTANCE_STEPS);\n        \n        vec3 RaySi;\n        vec3 MieSi;\n        \n        ScatteringStep(R, V, L, VoL, 0.0, OptLenV, UseOzoneAbsorption, RaySi, MieSi);\n        RayS = RaySi;\n        MieS = RaySi;\n        \n        ScatteringStep(R, V, L, VoL, MaxDistance, OptLenV, UseOzoneAbsorption, RaySi, MieSi);\n        RayS = (RayS + RaySi) * 0.5;\n        MieS = (MieS + MieSi) * 0.5;\n        \n        for (uint iStep = 1u; iStep < NumSteps; ++iStep)\n    \t{\n            ScatteringStep(R, V, L, VoL, float(iStep) * StpDistance, OptLenV, UseOzoneAbsorption, RaySi, MieSi);\n        \tRayS += RaySi;\n            MieS += MieSi;\n    \t}\n\n        RayS *= StpDistance * RayScattering() * phaseR(VoL);\n        MieS *= StpDistance * MieScattering() * phaseM_CS(VoL, 0.76);\n        \n        const float kSunAngularRadius32Min33Sec = 0.00473420559;\n        float ToEdge = clamp((1.0 - VoL) / kSunAngularRadius32Min33Sec, 0.0, 1.0);\n        \n        float CosAngle1 = cos(ToEdge * kPi * 0.5);\n        float CosAngle4 = Sqrt(1.0 - ToEdge * ToEdge);\n        float Mask = 1.0\n            #if 0\n                   - ((ToEdge == 1.0) ? 1.0 : 0.0);\n            #else\n                   - ((ToEdge >= 0.8) ? smoothstep(0.8, 1.0, ToEdge) : 0.0);\n            #endif\n\t\t\n        // Limb Darkening model from http://www.physics.hmc.edu/faculty/esin/a101/limbdarkening.pdf\n        // See Formula 1. \n        // Coefficients for wavelengths close to (680 550 440) nm are from Table 2 (PS column)\n        vec3 LimbDarkening = Mask * pow(vec3(1.0 - 1.0 * (1.0 - CosAngle1)), vec3(0.420, 0.503, 0.652));\n        \n        Scattering = (RayS + MieS) + Transmittance(OptLenV, UseOzoneAbsorption) * LimbDarkening;\n    }\n}\n\nvec3 sRGMGamma(vec3 color)\n{\n    vec3 x = color * 12.92;\n    vec3 y = 1.055 * pow(clamp(color, 0.0, 1.0), vec3(1.0 / 2.4)) - 0.055;\n\tcolor.r = color.r < 0.0031308 ? x.x : y.x;\n    color.g = color.g < 0.0031308 ? x.y : y.y;\n    color.b = color.b < 0.0031308 ? x.z : y.z;\n    return color;\n}\n\n// John Hable's tonemapping function from presentation \"Uncharted 2 HDR Lighting\", Page 142-143\nvec3 ToneMap_Uncharted2(vec3 color)\n{\n    float A = 0.15; // 0.22\n\tfloat B = 0.50; // 0.30\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02; // 0.01\n\tfloat F = 0.30;\n\tfloat W = 11.2;\n    \n    vec4 x = vec4(color, W);\n    x = ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n\treturn sRGMGamma(x.xyz / x.w);\n}\n\n// Optimized version of Haarm-Peter Duiker’s curve\n// by Jim Hejl and Richard Burgess-Dawson \n// from John Hable's presentation \"Uncharted 2 HDR Lighting\", Page 140:\n// http://www.gdcvault.com/play/1012459/Uncharted_2__HDR_Lighting\nvec3 ToneMap_FilmicALU(vec3 color)\n{\n    color = max(vec3(0.0), color - 0.004);\n    color = (color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06);\n    return color;\n}\n\nvec3 UVToViewSpaceCoord(float U, float V, float MinCos)\n{\n    float HalfFovV = kPi / 6.0;\n    float AspRatio = iResolution.x / iResolution.y;\n\n    float yScale = cos(HalfFovV) / sin(HalfFovV);\n    float xScale = yScale / AspRatio;\n\n    vec3 Dir;\n    Dir.z = 10.0 / kKilometersToMeters;\n    Dir.x = (U * 2.0 - 1.0) / xScale * Dir.z;\n    Dir.y = (V * 2.0 - 1.0) / yScale * Dir.z;\n    Dir = normalize(Dir);\n    // clamp cosine of zenith angle\n    Dir.xz /= Sqrt(1.0 - Dir.y * Dir.y);\n    Dir.y   = clamp(Dir.y, MinCos, 1.0);\n    Dir.xz *= Sqrt(1.0 - Dir.y * Dir.y);\n    return Dir;\n}\n\nvec3 UVToEquirectCoord(float U, float V, float MinCos)\n{\n    float Phi = kPi - V * kPi;\n    float Theta = U * 2.0 * kPi;\n    vec3 Dir = vec3(cos(Theta), 0.0, sin(Theta));\n\tDir.y   = clamp(cos(Phi), MinCos, 1.0);\n\tDir.xz *= Sqrt(1.0 - Dir.y * Dir.y);\n    return Dir;\n}\n\nvec3 UVToFisheyeCoord(float U, float V, float MinCos)\n{\n    float NdcX = U * 2.0 - 1.0;\n    float NdcY = V * 2.0 - 1.0;\n    NdcX *= iResolution.x / iResolution.y;\n    \n    float R = Sqrt(NdcX * NdcX + NdcY * NdcY);\n    \n    // x - sin(theta), z - cos(theta)\n    vec3 Dir = vec3(NdcX / R, 0.0, NdcY / R);\n    \n    float Phi = clamp(R, 0.0, 1.0) * kPi * 0.75;\n    \n    Dir.y   = clamp(cos(Phi), MinCos, 1.0);\n\tDir.xz *= Sqrt(1.0 - Dir.y * Dir.y);\n    return Dir;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float U = fragCoord.x / iResolution.x;\n    float V = fragCoord.y / iResolution.y;\n    \n    //if (iMouse.w > 0.0)\n    if (ATM_SHOW_TRANSMITTANCE == 1)\n    {\n    \tfloat VScaled = V * 3.0;\n    \tV = fract(VScaled);\n        \n\t\t#if 0\n    \t// Simple linear mapping\n    \tfloat Radius = kAtmRadiusMin + V * (kAtmRadiusMax - kAtmRadiusMin);\n    \tfloat Mu = kAtmHorizonCosMin + U * (1.0 - kAtmHorizonCosMin);\n\t\t#else\n    \t// Non-linear mapping\n    \tfloat Radius = kAtmRadiusMin + (V * V) * (kAtmRadiusMax - kAtmRadiusMin);\n    \tfloat Mu = kAtmHorizonCosMin + tan(1.5 * U) / tan(1.5) * (1.0 - kAtmHorizonCosMin);\n\t\t#endif\n    \n    \tfloat CosHorizon = AtmHorizonCos(Radius);\n    \n    \tMu = max(Mu, CosHorizon);\n    \n    \tvec3 OptLen = OpticalLength(Radius, Mu, 16u);\n    \n        vec3 OznOptDepth = OznAbsorption() * OptLen.b;\n    \tvec3 RayOptDepth = RayScattering() * OptLen.r;\n    \tvec3 MieOptDepth = MieScattering() * OptLen.g;\n    \n    \tif (Mu >= CosHorizon)\n    \t{\n        \tvec3 SumOptDepth = vec3(0.0);\n        \tif (VScaled > 2.0)\n        \t{\n            \tSumOptDepth = RayOptDepth + MieOptDepth;\n        \t}\n        \telse if (VScaled > 1.0)\n        \t{\n            \tSumOptDepth = OznOptDepth;\n        \t}\n        \telse\n        \t{\n            \tSumOptDepth = RayOptDepth + MieOptDepth + OznOptDepth;\n        \t}\n        \tfragColor = vec4(exp(-SumOptDepth), 0.0);\n    \t}\n    \telse\n    \t{\n        \tfragColor = vec4(0.0, 1.0, 1.0, 0.0);\n    \t}\n    }\n    else\n    {\n        float Aspect = iResolution.x / iResolution.y;\n        \n        float U1 = iMouse.x / iResolution.x;\n        float V1 = iMouse.y / iResolution.y;\n        \n        float R    = kAtmRadiusMin + 0.1;\n        float CosH = AtmHorizonCos(R) - 0.01;\n        \n#if ATM_PROJECTION_MODE == 1\n        vec3 VDir = UVToViewSpaceCoord(U, V, -1.0);\n        vec3 LDir = UVToViewSpaceCoord(U1, V1, CosH);\n        \n#elif ATM_PROJECTION_MODE == 2\n        vec3 VDir = UVToEquirectCoord(U, V, -1.0);\n        vec3 LDir = UVToEquirectCoord(U1, V1, CosH);\n#else\n        vec3 VDir = UVToFisheyeCoord(U, V, -1.0);\n        vec3 LDir = UVToFisheyeCoord(U1, V1, CosH);\n#endif\n        \n        float VoL = dot(LDir, VDir);\n        \n        float V = VDir.y;\n        float L = LDir.y;\n\n        vec3 Result = vec3(0.0);\n        Scattering(R, V, L, VoL, VDir.z < 0.0 ? 1.0 : 0.0, Result);\n        \n        float Exposure = exp2(4.0);\n        \n        Result *= Exposure;\n        \n        if (VDir.x * VDir.z < 0.0)\n        {\n        \tResult.x *= kAtmRadianceResponseToRGB_680nm;\n        \tResult.y *= kAtmRadianceResponseToRGB_550nm;\n        \tResult.z *= kAtmRadianceResponseToRGB_440nm;\n        }\n        else\n        {\n            Result.xyz *= kAtmRadianceResponseToRGB_Lum;\n        }\n#if ATM_TONEMAPPING_MODE == 1\n        Result = ToneMap_FilmicALU(Result);\n#elif ATM_TONEMAPPING_MODE == 2\n        Result = ToneMap_Uncharted2(Result);\n#endif\n        fragColor = vec4(Result, 0.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}