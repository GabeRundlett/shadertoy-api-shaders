{
    "Shader": {
        "info": {
            "date": "1692591533",
            "description": "without wireframe, but looks well.",
            "flags": 0,
            "hasliked": 0,
            "id": "dlffRH",
            "likes": 10,
            "name": "cube ray planting",
            "published": 3,
            "tags": [
                "cineshader",
                "nextstop"
            ],
            "usePreview": 0,
            "username": "chenxianming",
            "viewed": 1052
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926\n#define I iResolution\n#define T( s ) fract( iTime * s ) * PI * 4.\n#define T2( s ,b ) fract(iTime * s) * b\n#define rot( a ) mat2( cos( a ), sin( a ), -sin( a ), cos( a ) )\n\n// texture\n\nfloat h(in vec2 a) { return dot(a, a); }\nfloat i(in vec2 c, in vec2 a, in vec2 d) {\n  vec2 e = c - a, b = d - a;\n  return h(e - b * clamp(dot(e, b) / dot(b, b), 0., 1.));\n}\n\nfloat j(vec2 d) {\n  float c = .1;\n  for (float a = 0.; a < 24.; a++) {\n    float b = a + 1.;\n    if (a > 23.)\n      break;\n    float e = cos(a / 24. * 6. * 6.28) * .1 * (a / 5.),\n          k = sin(a / 24. * 6. * 6.28) * .1 * (a / 5.),\n          l = cos(b / 24. * 6. * 6.28) * .1 * (b / 5.),\n          m = sin(b / 24. * 6. * 6.28) * .1 * (b / 5.);\n    c = min(c, i(d, vec2(e, k), vec2(l, m)));\n  }\n  return c;\n}\nvec2 g(inout vec2 b, vec2 a) {\n  vec2 c = a * .5, d = floor((b + c) / a);\n  b = mod(b + c, a) - c;\n  return d;\n}\nfloat n(vec2 a) {\n  float b = .1;\n  a.y += T2( .25, .96 );\n  vec2 c = g(a, vec2(.49, .48));\n  a.xy *= mod(c.x, 2.) == 0. ? rot(0.) : rot(3.141593), b = min(b, j(a * 2.));\n  return b;\n}\n\n// textureEND\n\n// geo\nfloat j(vec3 a, int b) {\n  float c = b == 0 ? 1. : abs(abs(a.y) - .5);\n  return max(max(abs(a.x) - .5 * c, abs(a.z) - .5 * c), abs(a.y) - .5);\n}\n// sdf\nfloat df(vec3 a) {\n  a.z -= 2., a.xz *= -rot(T(.0125)), a.yz *= rot(T(.0125));\n  float c = .8;\n  for (float b = 0.; b < 20.; b++)\n    a.xz *= rot(b), c += b / 20., a.xz = abs(a.xz) - .01 * b,\n                                a.y += c * .01 * -1., a.zy *= -rot(b);\n  return j(a, 1);\n}\n// trace2\nfloat s(vec3 a) {\n  a.xz *= rot(T(.05)), a.yz *= -rot(T(.05));\n  return j(a, 0);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 nrm( vec3 a) {\n    vec2 e = vec2(1.0, -1.0);\n\n    const float eps = .01;\n    return normalize(e.xyx * s(a + e.xyy * eps) +\n        e.yyx * s(a + e.yyx * eps) +\n        e.yxy * s(a + e.yxy * eps) +\n        e.xxx * s(a + e.xxx * eps));\n}\n\nvoid mainImage(out vec4 U, in vec2 V) {\n  \n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 u = ( V + V - I.xy ) / min( I.x, I.y );\n  \n  float bg = .1;\n  u *= rot(.785398), bg = n(u), bg = smoothstep(0., bg, 1e-5);\n  \n  vec3 g = vec3( bg * .2 ), a, m = vec3(0, 0, -6), h = vec3(u * .15, 1);\n  float b, c, n = 0., o = sqrt(1e-4) * .8, i = 0.;\n  \n  // Time varying pixel color\n  \n  //trace\n  for (; i < 32.; i++)\n    a = m + h * b, c = s(a), b += c;\n\n  // gradient\n  if( c < 1e-3 )\n    g += max( nrm( a ).x, .0 ) * .5,\n    g += max( -nrm( a ).y, .0 ) * .3,\n    g += max( nrm( a ).z, .0 ) * .4;\n\n  a = vec3(0);\n  \n  for (int q = 0; q < 12; q++) {\n    a = m + h * b, \n    // a = mod( a, 1. ) - .5, // what if this code?\n    a *= .8, a = normalize(reflect(a, h)), c = df(a),\n    i = 1. - abs(c) / o,\n    i > 0.\n        ? (g -= .8 * (reflect(a, h) * .2 + .5 * i / b), g += sign(g) * .1, n++)\n        : 0.;\n    if (n > 10.)\n      break;\n    b -= max(abs(c), o * .3);\n  }\n  \n  U = vec4(g, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}