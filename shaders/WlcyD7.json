{
    "Shader": {
        "info": {
            "date": "1609185361",
            "description": "It was a fine line between creating a scene with\nTIE Fighters or X-Wings. TIE Fighters won.\n\nScene duration: 40 secs",
            "flags": 0,
            "hasliked": 0,
            "id": "WlcyD7",
            "likes": 83,
            "name": "TIE Fighters",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "snow",
                "starwars",
                "disney",
                "movie",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "dean_the_coder",
            "viewed": 30593
        },
        "renderpass": [
            {
                "code": "// 'TIE Fighters' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/WlcyD7\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// It was a fine line between creating a scene with\n// TIE Fighters or X-Wings. TIE Fighters won.\n// I'm quite happy with the modelling in this one,\n// but definitely want to practice terrains some more.\n//\n// I've switched to using hash functions which don't\n// rely on trig functions. Hopefully that will reduce\n// differences on different platforms...\n//\n// Tricks to get the performance:\n//  - The TIE SDF code bails early if the raymarching point\n//    is 'too far away', so no time wasted calculating the SDF\n//    of all the fine details when not necessary.\n//    See sdTie()\n//  - Shadows are only cast by the TIEs (See calcShadow())\n//    so I don't have to render the entire scene too many times.\n//  - The ray is only reflected if it hits glass or metal, and then\n//    marched only if it points down. (So we don't reflect the sky.)\n//  - I have two normal-calculating functions. One for the TIEs,\n//    and one for the terrain. Once the ray has hit an object,\n//    the relevant 'normal' code is called.\n//  - The high frequency noise is added to the terrain during the\n//    color look-up phase. Only the low frequency noise is added to\n//    the SDF.\n//\n// Things I _could_ do:\n//  - Split the TIE modelling into two functions, one for just\n//    the wings and cockpit, and another which extends it to\n//    include the finer details.\n//    The 'simple' version could be used to generate the shadows.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat T, g;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 uv;\n};\n\n// Thanks Dave Hoskins - https://www.shadertoy.com/view/4djSRW\nvec4 hash44(vec4 p4) {\n\tp4 = fract(p4 * vec4(.1031, .103, .0973, .1099));\n\tp4 += dot(p4, p4.wzxy + 33.33);\n\treturn fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(hash44(h), hash44(h + s.x), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nvoid minH(inout Hit a, Hit b) { if (b.d < a.d) a = b; }\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 opModPolar(vec2 p, float n, float o) {\n\tfloat angle = 3.141 / n,\n\t      a = mod(atan(p.y, p.x) + angle + o, 2. * angle) - angle;\n\treturn length(p) * vec2(cos(a), sin(a));\n}\n\nfloat sdHex(vec3 p, vec2 h) {\n\tconst vec3 k = vec3(-.866, .5, .577);\n\tp = abs(p);\n\tp.xy -= 2. * min(dot(k.xy, p.xy), 0.) * k.xy;\n\tvec2 d = vec2(length(p.xy - vec2(clamp(p.x, -k.z * h.x, k.z * h.x), h.x)) * sign(p.y - h.x), p.z - h.y);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdPlane(vec3 p, vec3 n) { return dot(p, n); }\n\nfloat dot2(vec3 a) { return dot(a, a); }\n\nfloat sdTri(vec3 p, vec3 a, vec3 b, vec3 c) {\n\tvec3 ba = b - a,\n\t     pa = p - a,\n\t     cb = c - b,\n\t     pb = p - b,\n\t     ac = a - c,\n\t     pc = p - c,\n\t     n = cross(ba, ac);\n\treturn sqrt((sign(dot(cross(ba, n), pa)) + sign(dot(cross(cb, n), pb)) + sign(dot(cross(ac, n), pc)) < 2.) ? min(min(dot2(ba * clamp(dot(ba, pa) / dot2(ba), 0., 1.) - pa), dot2(cb * clamp(dot(cb, pb) / dot2(cb), 0., 1.) - pb)), dot2(ac * clamp(dot(ac, pc) / dot2(ac), 0., 1.) - pc)) : dot(n, pa) * dot(n, pa) / dot2(n));\n}\n\nfloat sdCyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nHit sdWings(vec3 p) {\n\tp.xy = abs(p.xy);\n\tp.z = abs(p.z) - 2.3;\n\treturn Hit(min(sdTri(p, vec3(0), vec3(2, 3, 0), vec3(-2, 3, 0)), sdTri(p, vec3(0), vec3(3.3, 0, 0), vec3(2, 3, 0))) - .03, 2, p);\n}\n\nHit sdTie(vec3 p) {\n\tp = p.zyx - vec3(10, 0, 0);\n\n\t// Wings.\n\tHit h = sdWings(p);\n\tif (h.d > 2.5) return h; // Bail early - Point is too far away.\n\t// Wing ribs.\n\tvec3 op = p;\n\tp.xy = abs(p.xy);\n\tp.z = abs(p.z) - 2.3;\n\tfloat f,\n\t      d = 0.;\n\tif ((f = abs(p.y)) < .1) d = .03 + step(f, .025) * .02;\n\telse if ((f = abs(p.y - p.x * 1.5)) < .15) d = .03 + step(f, .025) * .02;\n\telse if (abs(p.y - 3.) < .1) d = .03;\n\telse if (abs(p.x - 3.3 + p.y * .43) < .1) d = .03;\n\n\tif (d > 0.) {\n\t\th.d -= d;\n\t\th.id = 1;\n\t}\n\n\t// Wing center hexes.\n\td = min(sdHex(p, vec2(.7, .06)), sdHex(p, vec2(.5, .12)));\n\n\t// Crossbar.\n\td = min(d, sdCyl(op, vec2(mix(.21, .23, step(p.y, .04)), 2.3))); // Main bar\n\tp.z = abs(p.z + .8) - .5;\n\tf = sdCyl(p, vec2(mix(.21, .33, (p.z + .33) / .48), .24));\n\tp.x -= .25;\n\tp.z += .02;\n\td = min(d, max(f, -sdBox(p, vec3(.1, .4, .08)))); // Join to wing/cockpit.\n\tp = op;\n\tp.yz = abs(p.yz);\n\tminH(h, Hit(min(d, sdTri(p, vec3(0), vec3(0, .8, 0), vec3(0, 0, 2)) - .05), 1, p)); // Triangle cockpit supports.\n\t// Cockpit - Sphere.\n\tf = step(.75, p.y);\n\tminH(h, Hit(length(op) - .9 - .02 * (f + step(p.y, .03) + f * step(p.z, .1)), 6, p));\n\n\t// Cockpit - Glass.\n\tp = op;\n\tp.x += .27;\n\tp.yz = opModPolar(p.yz, 8., .4);\n\tminH(h, Hit(max(length(p) - .7, sdPlane(p + vec3(.77, 0, 0), vec3(vec2(-1, 0) * rot(.5), 0))), 3, p));\n\n\t// Cockpit - Window frame.\n\tminH(h, Hit(max(length(p) - .71, .45 - length(p.yz)), 5, p));\n\n\t// Gunz.\n\tp = op;\n\tp.x += .7;\n\tp.y += .6;\n\tp.z = abs(p.z) - .2;\n\tminH(h, Hit(sdCyl(p.zyx, vec2(.05, .2)), 7, p));\n\treturn h;\n}\n\n// Position of the lead TIE.\nvec3 tiePos(vec3 p, float t) {\n\tfloat x = cos(t * .7);\n\tp += vec3(x, cos(t), sin(t * 1.1));\n\tp.xy *= rot(x * -.1);\n\treturn p;\n}\n\nHit sdTies(vec3 p) {\n\tvec3 op = p;\n\n\t// Front tie.\n\tp = tiePos(p, T);\n\tHit h = sdTie(p);\n\tif (sin(T) - step(T, 0.) * 10. > -.7) {\n\t\t// Weapon fire.\n\t\tp.x = abs(p.x) - .2;\n\t\tp.y += .6;\n\t\tp.z = mod(p.z + T * 50., 8.) - 4.;\n\t\tfloat x = max(sdCyl(p, vec2(.03, 1)), op.z - 8.);\n\t\tminH(h, Hit(x, 9, p));\n\t\tg += .001 / (.01 + x * x);\n\t}\n\n\t// Rear tie.\n\tif (h.d > .0015) {\n\t\tfloat x = -cos(T);\n\t\tp = op + vec3(14, -4. - .5 * cos(T * .5), -20. + 4. * sin(T * .6));\n\t\tp.xy *= rot(x * -.1);\n\t\tminH(h, sdTie(p));\n\t}\n\n\treturn h;\n}\n\nHit sdTerrain(vec3 p) {\n\tp.z -= T * 7e2; // Number controls the terrain speed.\n\tvec2 d = sin(p.xz * vec2(.01476, .01345)) * 10. + sin(p.xz * vec2(.05212, .04512)) * 2.;\n\treturn Hit(abs(p.y - d.x + d.y + 25.), 4, p);\n}\n\nHit map(vec3 p) {\n\tHit h = sdTerrain(p);\n\tminH(h, sdTies(p));\n\treturn h;\n}\n\nvec3 calcN(vec3 p, float t) {\n\tfloat h = t * .2;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdTies(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\n// Terrian normal.\n// (Special case, but faster than using the SDF for the entire scene.)\nvec3 calcTN(vec3 p, float t) {\n\tfloat h = t * 2.;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdTerrain(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\n// Note: For performance, shadows are only cast by tie fighters.\nfloat calcShadow(vec3 p, vec3 ld) {\n\t// Thanks iq.\n\tfloat s = 1.,\n\t      t = 1.;\n\tfor (float i = 0.; i < 30.; i++) {\n\t\tfloat h = sdTies(p + ld * t).d;\n\t\ts = min(s, 30. * h / t);\n\t\tt += h;\n\t\tif (s < .001 || t > 1e2) break;\n\t}\n\n\treturn clamp(s, 0., 1.);\n}\n\n// Note: For performance, occlusion only applied to tie fighters.\nfloat ao(vec3 p, vec3 n, float h) { return clamp(sdTies(p + h * n).d / h, 0., 1.); }\n\n// Sub-surface scattering (Applied to the snow).\n#define SSS(h)\tclamp(sdTerrain(p + ld * h).d / h, 0., 1.)\n\n/**********************************************************************************/\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n\tfloat am, ldt, l, spe,\n\t      sped = 4.;\n\tvec3 c, n, lig,\n\t     ld = normalize(vec3(30, 50, -40) - p);\n\tif (h.id == 4) {\n\t\t// Snow\n\t\tc = vec3(1.2 + SSS(1.) * .44);\n\t\tn = normalize(calcTN(p, d) + n31(h.uv) * .1);\n\t\tam = mix(.3, .9, sdTerrain(p + n).d);\n\t\tsped = .4;\n\t}\n\telse {\n\t\tn = calcN(p, d);\n\t\tam = mix(ao(p, n, .5), ao(p, n, 1.2), .75);\n\t\tif (h.id == 1 || h.id == 6) {\n\t\t\t// Metal\n\t\t\tc = vec3(.3 - n31(h.uv * 18.7) * .1);\n\t\t\tsped = .5;\n\t\t\tif (h.id == 6) c *= 1. - .8 * step(abs(atan(h.uv.y, h.uv.z) - .8), .01); // Cockpit.\n\t\t}\n\t\telse if (h.id == 2) {\n\t\t\t// Black wing area.\n\t\t\tif (h.uv.x < h.uv.y * .7) h.uv.y = 0.;\n\t\t\tc = vec3(.005 + .045 * pow(abs(sin((h.uv.x - h.uv.y) * 12.)), 20.));\n\t\t\tsped = .2;\n\t\t}\n\t\telse if (h.id == 7) {\n\t\t\t// Gunz.\n\t\t\tc = vec3(.02);\n\t\t\tsped = .2;\n\t\t}\n\t\telse if (h.id == 3) c = vec3(.05); // Cockpit glass.\n\t\telse if (h.id == 5) c = vec3(.1); // Glass surround.\n\t\telse c = vec3(.3, 1, .3); // Fire!\n\t}\n\n\t// Primary light.\n\tldt = dot(ld, n);\n\tl = max(0., .2 + .8 * ldt) + max(0., .2 - .8 * ldt) * .3;\n\tspe = smoothstep(0., 1., pow(max(0., dot(rd, reflect(ld, n))), 50.)) * sped;\n\n\t// Combine.\n\tlig = l * am * mix(.4, 1., calcShadow(p, ld)) * vec3(2, 1.8, 1.7) + clamp(n.y, .05, 1.) * vec3(.9, .95, 1); // Sky light.\n\treturn c * lig + spe;\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p, c;\n\tfloat gg,\n\t      d = .01;\n\tHit h;\n\tfor (float i = 0.; i < 120.; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015 || d > 6e2) break;\n\t\td += h.d; // No hit, so keep marching.\n\t}\n\n\tgg = g; // Cache the 'glow'.\n\tif (d > 6e2) c = vec3(.85, .9, 1);\n\telse c = mix(lights(p, rd, d, h), vec3(1), smoothstep(2e2, 540., d));\n\n\tc += gg * vec3(0, 1, 0);\n\tif (h.id == 3 || h.id == 1) {\n\t\t// Reflections applied to cockpit glass and tie metal.\n\t\trd = reflect(rd, calcN(p, d));\n\t\tfloat alpha = (h.id == 3 ? .4 : .2) * smoothstep(0., 1., -rd.y);\n\t\tif (alpha < .001) return c; // Only reflect downwards.\n\t\td = .01;\n\t\tro = p;\n\t\tfor (float i = 0.; i < 40.; i++) {\n\t\t\tp = ro + rd * d;\n\t\t\th = sdTerrain(p);\n\t\t\tif (abs(h.d) < .0015 || d > 3e2) break;\n\t\t\td += h.d; // No hit, so keep marching.\n\t\t}\n\n\t\t// Combine a % of the reflected color.\n\t\tc = mix(c, d > 3e2 ? vec3(1) : lights(p, rd, d, h), alpha);\n\t}\n\n\treturn c;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tT = mod(iTime, 40.) - 4.;\n\tg = 0.;\n\tfloat t = smoothstep(0., 5., T);\n\tvec3 lookAt = mix(vec3(0, 0, 6) - tiePos(vec3(0), T - .2), vec3(2.5, 0, 0), t),\n\t     ro = mix(lookAt - vec3(0, 0, 1), vec3(4. + cos(T), sin(T) * .2, -8. + cos(T * .2) * 6.), t);\n\tfragColor = vec4(vignette(pow(march(ro, getRayDir(ro, lookAt, (fc - .5 * iResolution.xy) / iResolution.y)), vec3(.45)), fc), 0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}