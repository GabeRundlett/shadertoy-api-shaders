{
    "Shader": {
        "info": {
            "date": "1608525298",
            "description": "synthwave theme\nmusic: https://soundcloud.com/synthwave80s/gran-turismo",
            "flags": 96,
            "hasliked": 0,
            "id": "WssBz2",
            "likes": 4,
            "name": "Synthwave Theme",
            "published": 3,
            "tags": [
                "raymarch",
                "synthwave"
            ],
            "usePreview": 0,
            "username": "53",
            "viewed": 533
        },
        "renderpass": [
            {
                "code": "float rand(float p)\n{\n    return fract(sin(p)*43758.5453);\n}\nfloat rand21(vec2 p)\n{\n \treturn fract(sin(dot(p, vec2(1., 113.)))*43758.5453123);   \n}\nvec3 ACES(vec3 x)\n{\n    float a = 2.51;\n    float b = .03;\n    float c = 2.43;\n    float d = .59;\n    float e = .14;\n    return clamp((x*(a*x + b))/(x*(c*x + d) + e), 0., 1.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    int x = int(uv.y*512.);\n    //float freq = texelFetch(iChannel1, ivec2(x, 0), 0).r - .5;\n    float wave = texelFetch(iChannel1, ivec2(x, 1), 0).r - .5;\n    //col = vec3(freq, 4.*freq*(1. - feq), 1. - freq)*freq;\n    //col = vec3(freq,  4.*freq*(1. - feq), 1. - freq)*step(uv.y, freq);\n    //col += vec3(smoothstep(.08, .02, abs(uv.y - wave)));\n    \n    float shake = fract(cos(uv.y*3.14*100. + iTime*20.)*43758.)*.02*wave;\n    uv.x += shake;\n    \n    float id = floor(uv.y*40.);\n    float glitch = rand(id + mod(iTime, 1000.));\n    if(glitch > .999)\n        uv.x += (rand(id) - .5)*.05;\n    \n    vec2 blurR = vec2(100.)/iResolution.xy;\n    vec3 col = vec3(0.);\n    float STEPS = 20.;\n    float phiOffs = rand(dot(fragCoord.xy, vec2(1.12, 2.25)) + iTime);\n    for(float i = 0.; i < STEPS; i++)\n    {\n        vec2 r = blurR*i/STEPS;\n        float phi = (i/STEPS + phiOffs)*2.*3.1415926;\n        vec2 q = uv + vec2(sin(phi), cos(phi))*r;\n        col += texture(iChannel0, q).rgb;\n    }\n    col.rgb = mix(textureLod(iChannel0, uv, 0.).rgb, col/STEPS, .2);\n    float exposure = .2*(1. + .2*sin(.5*iTime)*sin(1.8*iTime));\n    col = ACES(exposure*col);\n    \n    float abber = smoothstep(.25, .5, abs(uv.x - .5));\n    float offset = .004*abber;\n    vec3 colR = vec3(0.);\n    vec3 colB = vec3(0.);\n    colR = textureLod(iChannel0, uv + vec2(offset, 0.), 0.).rgb;\n    colB = textureLod(iChannel0, uv - vec2(offset, 0.), 0.).rgb;\n    colR = ACES(colR*exposure);\n    colB = ACES(colB*exposure);\n    col.r = mix(colR.r, colB.r, step(.5, uv.x));\n    col.b = mix(colR.b, colB.b, step(uv.x, .5));\n    \n    float t = sin(iTime + sin(iTime + sin(iTime)*.5));\n    float vline = step(mod((uv.y + t*.08)*200., 2.), 1.);\n    col *= mix(.8, 1., vline);\n    \n    float len = length(uv - .5);\n    float vignette = smoothstep(.8, .4, len);\n    col *= vignette;\n    \n    //col *= wave*.5 + 1.;\n    \n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 22511,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/synthwave80s/gran-turismo"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float MAX_DIST = 300.;\nconst float MIN_DIST = .01;\nconst int MAX_STEP = 200;\nconst float OFFS_NORM = .1;\n\nconst float blockScale = .3;\nconst float speed = 12.;\n\nconst vec3 col1 = vec3(.9, .1, .7);\nconst vec3 col2 = vec3(.1, .2, .8);\n\nfloat stripe(float y, float h, float dt)\n{\n \tconst float e = .005;\n    float t01 = fract((iTime + dt)*.1);\n    h += t01*.15;\n    float dh = (1. - t01)*.01;\n    float mask = smoothstep(h - dh*.5, h - dh*.5 - e, y);\n    mask += smoothstep(h + dh*.5, h + dh*.5 + e, y);\n    return mask;\n}\nfloat sunStripes(vec2 uv)\n{\n\tconst float start = -.02;\n    float delta = 2.;\n    float mask = stripe(uv.y, start, 0.);\n    mask *= stripe(uv.y, start, delta*1.);\n    mask *= stripe(uv.y, start, delta*2.);\n    mask *= stripe(uv.y, start, delta*3.);\n    mask *= stripe(uv.y, start, delta*4.);\n    return mask;\n}\nfloat rand21(vec2 p)\n{\n    return fract(sin(dot(p, vec2(1., 113.)))*43758.5453123);\n}\nfloat rand212(vec2 p)\n{\n    if (p.x < 2. && p.x > -3.)\n        return 0.;\n        \n    return fract(sin(dot(p, vec2(1., 113.)))*43758.5453123);\n}\nfloat noise_value(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float xGEy = step(fp.y, fp.x);\n    float v_l = rand212(ip + vec2(0., 0.))*(1. - fp.x) +\n                rand212(ip + vec2(1., 0.))*(fp.x - fp.y) +\n                rand212(ip + vec2(1., 1.))*fp.y;\n    float v_u = rand212(ip + vec2(0., 0.))*(1. - fp.y) +\n                rand212(ip + vec2(0., 1.))*(fp.y - fp.x) +\n                rand212(ip + vec2(1., 1.))*fp.x;  \n    return mix(v_u, v_l, xGEy);\n    \n    vec2 w = fp;\n    return mix(mix(rand21(ip + vec2(0., 0.)),\n                   rand21(ip + vec2(1., 0.)), w.x),\n               mix(rand21(ip + vec2(0., 1.)),\n                   rand21(ip + vec2(1., 1.)), w.x), w.y);\n}\nfloat noise_value2(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    vec2 w = fp*fp*(3. - 2.*fp);\n    return mix(mix(rand21(ip + vec2(0., 0.)),\n                   rand21(ip + vec2(1., 0.)), w.x),\n               mix(rand21(ip + vec2(0., 1.)),\n                   rand21(ip + vec2(1., 1.)), w.x), w.y);\n}\nconst vec3 grad3[32] = vec3[32](vec3(1., 1., 0.)/sqrt(2.), vec3(-1., 1., 0.)/sqrt(2.), vec3(1., -1., 0.)/sqrt(2.), vec3(-1., -1., 0.)/sqrt(2.),\n                                vec3(1., 0., 1.)/sqrt(2.), vec3(-1., 0., 1.)/sqrt(2.), vec3(1., 0., -1.)/sqrt(2.), vec3(-1., 0., -1.)/sqrt(2.),\n                                vec3(0., 1., 1.)/sqrt(2.), vec3(0., -1., 1.)/sqrt(2.), vec3(0., 1., -1.)/sqrt(2.), vec3(0., -1., -1.)/sqrt(2.),\n                                vec3(1., 1., 0.)/sqrt(2.), vec3(-1., 1., 0.)/sqrt(2.), vec3(1., -1., 0.)/sqrt(2.), vec3(-1., -1., 0.)/sqrt(2.),\n                                vec3(1., 0., 1.)/sqrt(2.), vec3(-1., 0., 1.)/sqrt(2.), vec3(1., 0., -1.)/sqrt(2.), vec3(-1., 0., -1.)/sqrt(2.),\n                                vec3(0., 1., 1.)/sqrt(2.), vec3(0., -1., 1.)/sqrt(2.), vec3(0., 1., -1.)/sqrt(2.), vec3(0., -1., -1.)/sqrt(2.),\n                                vec3(1., -1., -1.)/sqrt(3.), vec3(-1., 1., 1.)/sqrt(3.), vec3(-1., -1., 1.)/sqrt(3.), vec3(1., 1., -1.)/sqrt(3.),\n                                vec3(1., 1., 1.)/sqrt(3.), vec3(-1., 1., -1.)/sqrt(3.), vec3(1., -1., 1.)/sqrt(3.), vec3(-1., -1., -1.)/sqrt(3.));\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash33(vec3 p3)\n{\n\treturn grad3[int(mod(hash13(p3)*43758., 32.))];\n}\nfloat noise_simplex(vec3 p)\n{\n    const vec3 C = vec3(1./3., 1./6., 1./2.);\n\tvec3 ip = floor(p + dot(p, C.xxx));\n    vec3 d0 = p - (ip - dot(ip, C.yyy));\n    vec3 g = step(d0.zxy, d0.xyz);\n    vec3 l = 1. - g;\n    vec3 i1 = min(g.xyz, l.yzx);\n    vec3 i2 = max(g.xyz, l.yzx);\n    vec3 d1 = d0 - (i1 - C.yyy);\n    vec3 d2 = d0 - (i2 - C.xxx);\n    vec3 d3 = d0 - (1. - C.zzz);\n    vec4 m = max(vec4(0.), .5 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)));\n    m = m*m*m*m;\n    return 107.6535*(m.x*dot(hash33(ip), d0) +\n                     m.y*dot(hash33(ip + i1), d1) +\n                     m.z*dot(hash33(ip + i2), d2) +\n                     m.w*dot(hash33(ip + 1.), d3))*.5 + .5;\n}\nfloat fbm(vec2 p)\n{\n \tfloat sum = 0.;\n    float a = 1.;\n    float s = 1.;\n    float v = 0.;\n    for(int i = 0; i < 5; ++i)\n    {\n     \tsum += a;\n        v += noise_value2(p*s)*a;\n        a *= .5;\n        s *= 2.;\n    }\n    return v/sum;\n}\nfloat fbm(vec3 p)\n{\n \tfloat sum = 0.;\n    float a = 1.;\n    float s = 1.;\n    float v = 0.;\n    for(int i = 0; i < 4; ++i)\n    {\n     \tsum += a;\n        v += noise_simplex(p*s)*a;\n        a *= .5;\n        s *= 2.;\n    }\n    return v/sum;\n}\n\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\nfloat calcHeight(vec3 p)\n{\n    p.z -= iTime*speed;\n    float h = noise_value(p.xz*blockScale - .5)*7.;\n    float mask = clamp((abs(p.x) - 5.)/10., 0., 1.);\n    return h*mask;\n}\nfloat sdPlane(vec3 p, float y)\n{\n    float h = calcHeight(p);\n    return p.y - y - h;\n}\nfloat sdSphere(vec3 p, vec3 c, float r)\n{\n    p -= c;\n    return length(p) - r;\n}\nfloat calcDist(vec3 p)\n{\n    float d = 0.;\n    d = sdPlane(p, 0.);\n    // d = min(d, sdSphere(p, vec3(0., 20., -200), 50.));\n    return d*.5;\n}\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    float d = 0.;\n    float t = 0.;\n    for(int i = 0; i < MAX_STEP; ++i)\n    {\n        d = calcDist(ro + rd*t);\n        t += d;\n        if(d < MIN_DIST || t > MAX_DIST)\n        {\n            break;\n        }\n    }\n    return t;\n}\nvec3 calcNormal(vec3 p)\n{\n    vec3 d0 = vec3(calcDist(p));\n    vec2 e = vec2(OFFS_NORM, 0.);\n    vec3 d = vec3(calcDist(p + e.xyy), calcDist(p + e.yxy), calcDist(p + e.yyx));\n    return normalize(d - d0);\n}\nvec3 calcRayDir(vec3 ro, vec3 c, vec2 uv, float z)\n{\n    vec3 f = normalize(c - ro);\n    vec3 r = normalize(cross(f, vec3(0., 1., 0.)));\n    vec3 u = cross(r, f);\n    vec3 i = f*z + r*uv.x + u*uv.y;\n    return normalize(i);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy)/iResolution.y;\n    vec2 m = (iMouse.xy - .5*iResolution.xy)/iResolution.xy;\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0., 5., 15.);\n    vec3 c = vec3(0., 0., -1.);\n    // c.yz *= rot(m.y*3.14/2.);\n    // c.xz *= rot(m.x*6.28);\n    vec3 rd = calcRayDir(ro, ro + c, uv, 1.);\n    float d = rayMarch(ro, rd);\n    if(d < MAX_DIST)\n    {\n     \tvec3 p = ro + rd*d;\n        vec3 normal = calcNormal(p);\n        vec3 ldir1 = normalize(vec3(-.3, 1., 1.));\n        vec3 ldir2 = normalize(vec3(.3, 1., -1.));\n        float nl1 = max(0., dot(normal, ldir1));\n        float nl2 = max(0., dot(normal, ldir2));\n        \n        float distMod = smoothstep(0., 100., d);\n        vec3 light = mix(nl1*col1, nl2*col2, distMod)*10.;\n        \n        col += nl1*col1;\n        col += nl2*col2*5.*distMod;\n        \n        p.z -= iTime*speed;\n        float lineWidth = .05;\n        float widthMod = smoothstep(100., 50., d)*1.5;\n        vec2 fp = fract(p.xz*blockScale + .5*lineWidth + .5);\n        if(fp.x < lineWidth || fp.y < lineWidth*widthMod) col = light*(2. + distMod);\n    }\n    else\n    {\n     \tfloat sun0 = smoothstep(.25, .248, length(uv - vec2(.0, .1)));\n        float mask = sunStripes(uv);\n        float sun = sun0*mask;\n        vec3 sunCol = 10.*mix(vec3(.6, .1, .8)*.2, vec3(1., .6, .0), smoothstep(.0, .35, uv.y));\n        \n        col += sun*sunCol + (1. - sun)*vec3(.6, .3, .7)*1.;\n        \n        float fog = smoothstep(.25, .0, uv.y);\n        float n = fbm(vec3(uv*3. - vec2(0., iTime*.07), iTime*.07));\n        fog *= n*((1. - sun0) + sun0*.7);\n        \n        col += fog*vec3(.1, .5, .9)*mix(2., 10., fog);\n        \n\t\tvec2 iuv = floor(uv*16.);\n        vec2 fuv = fract(uv*16.);\n        vec2 starPos = rand21(iuv) + iuv;\n        float starDist = length(uv*16. - starPos);\n        float starRnd = rand21(iuv);\n        float starSize = mix(.008, .03, starRnd);\n        float star = smoothstep(starSize, starSize - .001, starDist)*step(mod(starRnd*100., 2.), .5);\n        star *= (1. - sun);\n        \n        col += star*(sin(starRnd*100. + iTime*3.14*.5)*.5 + .5)*20.;\n        \n        float starDust = smoothstep(.2, .2 + .5*n, uv.y);\n        starDust *= n;\n        float starDustMask = noise_value2(uv*2. + .5);\n        starDust *= starDustMask;\n        \n        col += starDust*mix(vec3(.6, .2, .6), vec3(.2, .4, .8), starDustMask)*2.5;\n    }\n    \n    //col = vec3(noise_value(uv*8.));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const ivec2 offs[8] = ivec2[8](ivec2(-1, -1), ivec2(-1, 1), ivec2(1, 1), ivec2(1, -1),\n                         ivec2(1, 0), ivec2(0, 1), ivec2(-1, 0), ivec2(0, -1));\nvec3 RGB2YCoCg(vec3 col)\n{\n    float Y = dot(col, vec3(.25, .5, .25));\n    float Co = dot(col, vec3(.5, 0., -.5)) + .5;\n    float Cg = dot(col, vec3(-.25, .5, -.25)) + .5;\n    return vec3(Y, Co, Cg);\n}\nvec3 YCoCg2RGB(vec3 col)\n{\n    col += vec3(0., -.5, -.5);\n    float r = dot(col, vec3(1., 1., -1.));\n    float g = dot(col, vec3(1., 0., 1.));\n    float b = dot(col, vec3(1., -1., -1.));\n    return vec3(r, g, b);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 new = RGB2YCoCg(texture(iChannel0, uv).rgb);\n    vec3 last = RGB2YCoCg(texture(iChannel1, uv).rgb);\n    vec3 avg = new;\n    vec3 var = new*new;\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 fetch = RGB2YCoCg(texelFetch(iChannel0, ivec2(fragCoord) + offs[i], 0).rgb);\n        avg += fetch;\n        var += fetch*fetch;\n    }\n    avg /= 9.;\n    var /= 9.;\n    vec3 sigma = max(vec3(0.), var - avg*avg);\n    vec3 colMin = avg - .75*sigma;\n    vec3 colMax = avg + .75*sigma;\n    last = clamp(last, colMin, colMax);\n    fragColor = vec4(YCoCg2RGB(mix(new, last, .95)), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}