{
    "Shader": {
        "info": {
            "date": "1658050206",
            "description": "An experimental layered planet that makes it easy to extend, and customize.",
            "flags": 0,
            "hasliked": 0,
            "id": "sdVBDz",
            "likes": 3,
            "name": "layered planet",
            "published": 3,
            "tags": [
                "noise",
                "planet"
            ],
            "usePreview": 0,
            "username": "takahiroando",
            "viewed": 282
        },
        "renderpass": [
            {
                "code": "float hash(vec3 v3) {\n\treturn fract(sin(dot(v3, vec3(12.3, 45.6, 78.9))) * 987654.321);\n}\n\nfloat noise(vec3 v3) {\n\tvec3 i = floor(v3);\n\tvec3 f = fract(v3);\n\tvec3 b = smoothstep(0.0, 1.0, f);\n\tvec2 bin = vec2(0.0, 1.0);\n\treturn 2.0 * mix(\n\t\tmix(\n\t\t\tmix(hash(i + bin.xxx), hash(i + bin.yxx), b.x),\n\t\t\tmix(hash(i + bin.xyx), hash(i + bin.yyx), b.x),\n\t\t\tb.y\n\t\t),\n\t\tmix(\n\t\t\tmix(hash(i + bin.xxy), hash(i + bin.yxy), b.x),\n\t\t\tmix(hash(i + bin.xyy), hash(i + bin.yyy), b.x),\n\t\t\tb.y\n\t\t),\n\t\tb.z\n\t) - 1.0;\n}\n\nvec3 rotate_y(vec3 p, float t) {\n    vec3 a = vec3(0.0, 1.0, 0.0);\n\treturn mix(dot(a, p) * a, p, cos(t)) + cross(a, p) * sin(t);\n}\n\nfloat fbm_core(vec3 p, float amp, float freq, float mul_amp, float mul_freq) {\n\tfloat h = 0.0;\n\tfor (int i = 0; i < 6; ++i) {\n\t\th += amp * noise(p * freq);\n\t\tamp *= mul_amp;\n\t\tfreq *= mul_freq;\n\t}\n\treturn h;\n}\n\nfloat height(vec3 p, float radius) {\n\tp = normalize(p) * radius;\n\tp = rotate_y(p, iTime * 0.1);\n\treturn fbm_core(p, 0.8, 0.2, 0.4, 2.7);\n}\n\nfloat d_sphere(vec3 p, float radius) {\n\treturn length(p) - radius;\n}\n\nfloat d_ground(vec3 p, float radius) {\n\treturn d_sphere(p, radius) - max(height(p, radius), 0.0);\n}\n\nvec4 rt_sphere(vec3 p, vec3 rd, float radius) {\n\tfloat hit = 0.0;\n\tfor(int i = 0; i < 100; ++i) {\n\t\tfloat d = d_sphere(p, radius);\n\t\tp += d * rd;\n\t\tif (d < 0.01) {\n\t\t\thit = 1.0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn vec4(p, hit);\n}\n\nvec3 normal(vec3 p, float r) {\n\tmat3 k = mat3(p, p, p) - mat3(0.001);\n\treturn normalize(d_ground(p, r) - vec3(d_ground(k[0], r), d_ground(k[1], r), d_ground(k[2], r)));\n}\n\nvec3 light_dir() {\n    return normalize(vec3(0.6 * sin(0.1 * iTime), 0.5, 1.0));\n}\n\nvec3 sea(vec3 prev, vec3 p, vec3 rd, float radius) {\n\tfloat h = height(p, radius);\n\n    vec3 L = light_dir();\n\tvec3 n = normalize(p);\n\tvec3 r = reflect(rd, n);\n\tfloat dif_pow = max(0.0, dot(L, n));\n\n\tvec3 sea = vec3(0.1, 0.4, 0.9) * (0.1 * dif_pow - 2.0 * h + 0.9 * exp(max(dot(L, r), 0.0))) + 0.1 * sin(h);\n\treturn h < 0.0 ? sea * 0.5 + prev : prev;\n}\n\nvec3 ground(vec3 prev, vec3 p, vec3 rd, float radius) {\n\tfloat h = height(p, radius);\n\tvec3 snow = vec3(1.0);\n\tvec3 sand = vec3(0.7, 0.66, 0.53);\n\tvec3 grass = vec3(0.1, 0.7, 0.3);\n\tfloat snow_r = exp(-abs(h - 0.5) * 20.0);\n\tfloat sand_r = exp(-abs(h - 0.25) * 20.0);\n\tfloat grass_r = exp(-abs(h) * 20.0);\n\tfloat sum_r = snow_r + sand_r + grass_r;\n\tvec3 dif_mat = (snow * snow_r + sand * sand_r + grass * grass_r) / sum_r;\n\tvec3 ng = normal(p, radius);\n    vec3 L = light_dir();\n\tfloat dif_pow = max(0.0, dot(L, ng));\n\tvec3 ground = vec3(0.1) + dif_mat * dif_pow;\n    return h >= 0.0 ? ground : prev;\n}\n\nvec3 cloud(vec3 prev, vec3 p, vec3 rd, float radius) {\n\tp = rotate_y(p, iTime * -0.1);\n\tp += 0.1 * iTime;\n\tfloat c = pow(clamp(abs(fbm_core(p, 1.1, 0.3, 0.5, 2.2)), 0.0, 1.0), 2.0);\n    c = clamp(c, 0.0, 0.8);\n    return mix(prev, vec3(1.0), c);\n}\n\nvec3 bg(vec2 uv) {\n    vec3 p = vec3(uv, 0.0);\n    return vec3(pow(hash(p * 123.), 56.7));\n}\n\n// here is the core idea(is this an existing idea?)\n#define LAYER(col, p, rd, radius, f) { \\\n    vec4 rt = rt_sphere(p, rd, radius); \\\n    if (rt.w > 0.0) { \\\n        col = f(col, rt.xyz, rd, radius); \\\n    }\\\n}\n\nvec3 render(vec2 uv, vec3 p, vec3 rd) {\n    vec3 col = bg(uv);\n    LAYER(col, p, rd, 7.0, sea)\n    LAYER(col, p, rd, 7.0, ground)\n    LAYER(col, p, rd, 7.1, cloud)\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 p = vec3(0.0, 0.0, 10.0);\n\tvec3 rd = normalize(vec3(uv, -1.));\n\n\tfragColor = vec4( render(uv, p, rd), 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}