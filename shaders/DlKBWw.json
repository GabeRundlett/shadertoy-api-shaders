{
    "Shader": {
        "info": {
            "date": "1702151268",
            "description": "No longer a faithful reproduction of Anarchy in the Kitchen...",
            "flags": 96,
            "hasliked": 0,
            "id": "DlKBWw",
            "likes": 6,
            "name": "More is more!!",
            "published": 3,
            "tags": [
                "2d",
                "amiga",
                "balls",
                "bounce",
                "font",
                "sinus",
                "scroller",
                "malmsteen"
            ],
            "usePreview": 0,
            "username": "misol101",
            "viewed": 259
        },
        "renderpass": [
            {
                "code": "// \"Fireworks\" by Martijn Steinrucken aka BigWings - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n\n#define PI 3.141592653589793238\n#define TWOPI 6.283185307179586\n#define SS(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,w) SS(x-z, x+z, w)*SS(y+z, y-z, w)\n#define saturate(x) clamp(x,0.,1.)\n\n#define NUM_EXPLOSIONS 5.\n#define NUM_PARTICLES 15.\n\n\n// Noise functions by Dave Hoskins \n#define MOD3 vec3(.1031,.11369,.13787)\nvec3 hash31(float p) {\n   vec3 p3 = fract(vec3(p) * MOD3);\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat circ(vec2 uv, vec2 pos, float size) {\n\tuv -= pos;\n    \n    size *= size;\n    return SS(size*1.1, size, dot(uv, uv));\n}\n\nfloat light(vec2 uv, vec2 pos, float size) {\n\tuv -= pos;\n    \n    size *= size;\n    return size/dot(uv, uv);\n}\n\nvec3 explosion(vec2 uv, vec2 p, float seed, float t) {\n\t\n    vec3 col = vec3(0.);\n    \n    vec3 en = hash31(seed);\n    vec3 baseCol = en;\n    for(float i=0.; i<NUM_PARTICLES; i++) {\n    \tvec3 n = hash31(i)-.5;\n       \n\t\tvec2 startP = p-vec2(0., t*t*.1);        \n        vec2 endP = startP+normalize(n.xy)*n.z;\n        \n        \n        float pt = 1.-pow(t-1., 2.);\n        vec2 pos = mix(p, endP, pt);    \n        float size = mix(.01, .005, SS(0., .1, pt));\n        size *= SS(1., .1, pt);\n        \n        float sparkle = (sin((pt+n.z)*100.)*.5+.5);\n        sparkle = pow(sparkle, pow(en.x, 3.)*50.)*mix(0.01, .01, en.y*n.y);\n      \n    \tsize += sparkle*B(.6, 1., .1, t);\n        //size += sparkle*B(en.x, en.y, en.z, t);\n        \n        col += baseCol*light(uv, pos, size);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float shMv = iResolution.x * 0.0125;\n    vec4 shCol = texelFetch(iChannel0, ivec2(fragCoord.x - shMv, fragCoord.y + shMv), 0);\n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n\n    if (col.w == 0. && shCol.w != 0.) col = vec4(0.,0.,0.,1.);\n    fragColor = col;\n\n    if (col.w == 0.) {\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        uv.x -= .5;\n        uv.x *= iResolution.x/iResolution.y;\n\n        float n = hash12(uv+10.);\n        float t = iTime*.5;\n\n        vec3 c=col.xyz;\n\n        for(float i=0.; i<NUM_EXPLOSIONS; i++) {\n            float et = t+i*1234.45235;\n            float id = floor(et);\n            et -= id;\n\n            vec2 p = hash31(id).xy;\n            p.x -= .5;\n            p.x *= 1.6;\n            c += explosion(uv, p, id, et);\n        }\n        fragColor = vec4(c, 1.);\n     }\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 35478,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/yngwiemalmsteen/toccata"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// calculate positions of bouncing balls\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x > float(NOF_BALLS+1)) { return; }\n    if (int(fragCoord.x) == NOF_BALLS) { fragColor = vec4(iResolution.x); return; }\n    if (fragCoord.y >= 1.0) discard;\n    float PX = iResolution.x * 0.00125;\n    \n    vec4 ball = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float xres = texelFetch(iChannel0, ivec2(NOF_BALLS,0), 0).x;\n    \n    if (iFrame < 2 || xres != iResolution.x || SCROLL_TIME_MOD(iTime) > SCROLL_LEN - 2.) {\n        ball.x = iResolution.x + PX*1. - fragCoord.x * PX * (80./float(NOF_BALLS));\n        ball.y = iResolution.y - PX*6. - hash1(0.12*fragCoord.x) * PX*140.;\n        ball.z = ball.w = 0.;\n    }\n\n    pos = ball.xy / iResolution.xy;\n    uv = pos*2.0 - 1.0;\n    getTp(iTime);\n\n    ball.x += ball.z;\n    if (ball.x < 0.) ball.z = abs(ball.z);\n    if (ball.x > iResolution.x) ball.z = -abs(ball.z);\n\n    ball.w += -BALL_GRAVITY * PX;\n    ball.y += ball.w;\n    if (ball.y < iResolution.y-(tp.y*iResolution.y)+iResolution.y*FONT_SIZE+hash1(fragCoord.x*0.14)*PX*90. && ball.w < 0.) {\n        ball.w = -ball.w + 0.2;\n        vec2 refl = reflect(normalize(ball.zw)*1.5, normal);\n        ball.z = refl.y * PX * 2.;\n    }\n\n    fragColor = ball;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec2 pos = vec2(0), uv  = vec2(0), tp  = vec2(0), normal = vec2(0);\n\n#define SCROLL_LEN 33.\n#define SCROLL_SPEED 1.5\n#define SCROLL_TIME_MOD(t) mod(t*SCROLL_SPEED, SCROLL_LEN)\n\n#define FONT_SIZE 0.25\n#define FONT_SPACE 0.45\n#define SIN_FREQ 1.31\n#define SIN_SPEED 3.0\n#define SIN_AMP 0.75\n\n#define NOF_BALLS 250\n\n#define BALL_SIZE 0.008\n#define BALL_GRAVITY 0.1666\n//#define TWO_POINT_NORMAL\n\nvoid getTp(float time) {\n  tp = uv / FONT_SIZE;\n  float ty = tp.y;\n  tp.x = 2.0*(tp.x -4. + SCROLL_TIME_MOD(time));\n  tp.y = ty + 2.9 +SIN_AMP*sin(tp.x*SIN_FREQ +time*SIN_SPEED);\n\n#ifdef TWO_POINT_NORMAL\n  float x1=tp.x-0.5;\n  float x2=tp.x+0.5;\n  float y1 = ty + 2.9 +SIN_AMP*sin(x1*SIN_FREQ +time*SIN_SPEED);\n  float y2 = ty + 2.9 +SIN_AMP*sin(x2*SIN_FREQ +time*SIN_SPEED);\n  normal=vec2((x2-x1), -(y2-y1));\n#else\n  normal = vec2(-0.4, cos(tp.x*SIN_FREQ +time*SIN_SPEED));\n#endif  \n}\n\nfloat hash1(float n) {\n    return fract(sin(n)*138.5453123);\n}\n\n// Letters\n#define S(a) c+=char(float(a)); tp.x-=FONT_SPACE;\n\n#define _note  S(10);\n#define _star  S(28);\n#define _smily S(29);\n#define _    S(32);\n#define _exc S(33);\n#define _add S(43);\n#define _dot S(46);\n#define _col S(58);\n#define _que S(63);\n\n#define _A S(65);\n#define _B S(66);\n#define _C S(67);\n#define _D S(68);\n#define _E S(69);\n#define _F S(70);\n#define _G S(71);\n#define _H S(72);\n#define _I S(73);\n#define _J S(74);\n#define _K S(75);\n#define _L S(76);\n#define _M S(77);\n#define _N S(78);\n#define _O S(79);\n#define _P S(80);\n#define _Q S(81);\n#define _R S(82);\n#define _S S(83);\n#define _T S(84);\n#define _U S(85);\n#define _V S(86);\n#define _W S(87);\n#define _X S(88);\n#define _Y S(89);\n#define _Z S(90);\n\n#define _a S(97);\n#define _b S(98);\n#define _c S(99);\n#define _d S(100);\n#define _e S(101);\n#define _f S(102);\n#define _g S(103);\n#define _h S(104);\n#define _i S(105);\n#define _j S(106);\n#define _k S(107);\n#define _l S(108);\n#define _m S(109);\n#define _n S(110);\n#define _o S(111);\n#define _p S(112);\n#define _q S(113);\n#define _r S(114);\n#define _s S(115);\n#define _t S(116);\n#define _u S(117);\n#define _v S(118);\n#define _w S(119);\n#define _x S(120);\n#define _y S(121);\n#define _z S(122);\n\n#define _0 S(48);\n#define _1 S(49);\n#define _2 S(50);\n#define _3 S(51);\n#define _4 S(52);\n#define _5 S(53);\n#define _6 S(54);\n#define _7 S(55);\n#define _8 S(56);\n#define _9 S(57);\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// AA Sinus Scroller, originally by gPlatl.\n\n// Boncing balls added by misol101\n\nfloat char(float ch) {\n    vec4 f = texture(iChannel0,clamp(tp,-0.05,0.96)/16.+fract(floor(vec2(ch,15.999-float(ch)/16.))/16.));\n    return f.x * (f.y+0.3)*(f.z+0.3)*2.0;   // 3d\n    //return f.x;\n}\n\nvec4 ScrollText() {\n  getTp(iTime);\n  float c = 0.0;\n    \n  _N _e _v _e _r _ _f _o _r _g _e _t _ _t _h _e _ _l _e _g _e _n _d _a _r _y _ _w _o _r _d _s _ \n  \n  _o _f _ _M _r _dot _ _Y _n _g _w _i _e _ _M _a _l _m _s _t _e _e _n   _col _ \n\n  _H _o _w _ _c _a _n _ _l _e _s _s _ _b _e _\n\n  _m _o _r _e _que _ _M _O _R _E _ _I _S _  _M _O _R _E \n      \n  _exc _exc _exc _ _smily _ _smily _ _smily \n\n  return c * vec4(pos, 0.5+0.5*sin(2.0*iTime),1.0) * 3.1;\n}\n\nvec3 ColorPalette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec4 sphere(vec2 fragCoord, vec2 ballPos, float rad, vec4 col, vec4 orgCol, float AA) {\n    float dist = distance(fragCoord, ballPos);\n    return mix(col, orgCol, smoothstep(rad-iResolution.x*AA, rad, dist));\n}\n\nvec4 drawBall(vec2 fragCoord, vec2 ballPos, vec4 col, float rad, int index) {\n//    vec4 ballCol = vec4(0.95, 0.19, 0.4, 1.);\n\tvec4 ballCol = vec4(ColorPalette(float(index)*0.13, vec3(0.5, 0.5, 0.5), \n                           vec3(0.5), \n                           vec3(0.6, 0.4, 0.3), \n                           vec3(0.6, 0.4, 0.3)) + 0.12, 1.) ;    \n    \n    col = sphere(fragCoord, ballPos, rad, ballCol * 0.55, col, 0.004);\n//    col = sphere(fragCoord, ballPos-vec2(rad*0.1,-rad*0.1), rad*0.65, ballCol * 3., col, 0.006);\n    col = sphere(fragCoord, ballPos-vec2(rad*0.1,-rad*0.1), rad*0.85, ballCol * 2., col, 0.011);\n    return sphere(fragCoord, ballPos-vec2(rad*0.2,-rad*0.2), rad*0.2, ballCol*6.5, col, 0.0015);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  pos = fragCoord.xy / iResolution.xy;\n  uv = pos*2.0 - 1.0;\n\n  vec4 col=vec4(0.06, 0.,0.22, 0.);\n  if (uv.y < -0.3 && uv.y > -0.9)\n      col  = max(ScrollText(), col);\n  vec4 oldCol = col;\n\n  // draw balls\n  for (int i=0; i < NOF_BALLS; i++) {\n      vec4 ball = texelFetch(iChannel1, ivec2(i,0), 0);\n      float ballSize = BALL_SIZE + hash1(float(i)*0.14)*0.01;\n      if (distance(fragCoord.xy, ball.xy) < iResolution.x * ballSize) {\n        col = drawBall(fragCoord,ball.xy, col, iResolution.x * ballSize, i);\n        // start/end ball fade\n        col = mix(oldCol, col, clamp(SCROLL_TIME_MOD(iTime), 0., 0.5) * 2.);\n        col = mix(oldCol, col, clamp(SCROLL_LEN-2.0-SCROLL_TIME_MOD(iTime), 0., 3.) * 0.333);\n      }\n  }\n\n  fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}