{
    "Shader": {
        "info": {
            "date": "1588740300",
            "description": "lattice R",
            "flags": 0,
            "hasliked": 0,
            "id": "wsffRf",
            "likes": 7,
            "name": "lattice R",
            "published": 3,
            "tags": [
                "latticer"
            ],
            "usePreview": 0,
            "username": "haptix",
            "viewed": 481
        },
        "renderpass": [
            {
                "code": "vec2 smoothU(vec2 a, vec2 b, float r)\n{\n\tvec2 u = max(vec2(r - a.x, r - b.x), vec2(0.));\n\treturn vec2(max(r, min (a.x, b.x)) - length(u), (a.y+b.y) / 2.);\n}\n\nvec3 rep(vec3 pos, float sp)\n{\n\treturn mod(pos, sp) - .5*sp;\n}\n\nvec2 cylX(vec3 p, vec3 c, float matId)\n{\n\tfloat sdf = length(p.yx - c.zx) - c.x;\n    return vec2(sdf, matId);\n}\n\nvec2 cylY(vec3 p, vec3 c, float matId)\n{\n\tfloat sdf = length(p.xz - c.xy) - c.z;\n    return vec2(sdf, matId);\n}\n\nvec2 cylZ(vec3 p, vec3 c, float matId)\n{\n\tfloat sdf = length(p.yz - c.yx) - c.y;\n    return vec2(sdf, matId);\n}\n\nmat2 rot(float rad)\n{\n    return mat2(cos(rad), sin(rad), -sin(rad), cos(rad));\n}\n\nvec3 kif(vec3 p)\n{    \n    float t = iTime*.05 + 42.;\n    \n    for(int i = 0; i < 6; i++)\n    {\n        p.xy *= rot(.021*t);\n        \n        p = abs(p) + vec3(.02*cos(t*.21) + .31,\n                          .03*sin(t*.27) + 8.35,\n                          .04*sin(t*.37) + 120.37);\n        \n        p.yz *= rot(.013*t);\n    }\n    \n    return p;\n}\n\nvec2 crs(vec3 p, vec3 c, float matId)\n{\n    vec2 cylx = cylX(p, c, matId);\n    vec2 cyly = cylY(p, c, matId + 1.);\n    vec2 cylz = cylZ(p, c, matId + 2.);\n \n    float soft = .015;\n    vec2 sdf = smoothU(cylx, cyly, soft);\n    return smoothU(sdf, cylz, soft);\n}\n\nvec2 map(vec3 p)\n{   \n    p = 250. * sin(p/dot(p,p));\n    p = kif(p);\n    \n    float t = -iTime*.2 - 42.;\n    p = rep(p + t, 1.3);\n    \n    vec2 m = crs(p, vec3(.05), 1.);\n    return m;\n}\n\nvec2 tr(vec3 ro, vec3 rd)\n{\n    float far = 50.;\n\tvec2 h,t= vec2(.75);\n\tfor(int i = 0; i < 256; i++)\n\t{\n\t\th = map(ro + rd*t.x);\n\t\tif(h.x < .01 || t.x > far)\n\t\t\tbreak;\n\t\tt.x += h.x;\n        t.y = h.y;\n  \t}\n    if(t.x > far)\n        t.y = 0.;\n\treturn t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 ro = vec3(3.*sin(iTime*.25), -5.*cos(iTime*.25), 32.);\n    \n\tvec3 camTarget = vec3(0.);\n\tvec3 up = vec3(0., 1., 0.);\n\tvec3 camDir = normalize(camTarget - ro);\n\tvec3 camRight = normalize(cross(up, ro));\n\tvec3 camUp = normalize(cross(camDir, camRight));\n    vec3 lightPos1 = ro;\n    vec3 lightPos2 = ro + 10.;\n  \n\tvec2 screenPos = -1. + 2. * gl_FragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec3 rd = normalize(camRight*screenPos.x + camUp*screenPos.y + camDir);\n  \n\tvec2 t = tr(ro, rd);\n\n    if (t.y > 0.)\n    {\n        vec3 hit = ro + rd*t.x;\n        vec3 lightDir = normalize(lightPos1 - hit);\n\n        vec2 eps = vec2(0., .05);\n        vec3 norm = normalize(map(hit).x - vec3(map(hit - eps.yxx).x,\n                              \t\t\t\t\tmap(hit - eps.xyx).x,\n                              \t\t\t\t\tmap(hit - eps.xxy).x));\n        \n        float diff = max(0., dot(lightDir, norm));\n        float spec = pow(max(dot(rd, reflect(norm, lightDir)), 0.), 45.);\n\n        vec3 col = vec3(0.);\n        col += .2 * diff;\n        col += vec3(1.) * spec;\n        \n        fragColor = vec4(col, 1.);\n    }\n    else\n    {\n        vec3 wh = vec3(1.);\n        fragColor = vec4(.85); \n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}