{
    "Shader": {
        "info": {
            "date": "1719320831",
            "description": "Ray marcher in progress",
            "flags": 0,
            "hasliked": 0,
            "id": "l3tSRS",
            "likes": 1,
            "name": "Ray Marching Bactus' Version",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "Bactus",
            "viewed": 83
        },
        "renderpass": [
            {
                "code": "#define pi 3.14159265359\n#define e 0.0001\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Transform\n{\n    vec3 pos;\n    vec3 f;\n    vec3 u;\n    vec3 r;\n    vec3 scale;\n};\n\nstruct Camera\n{\n\n    float nearPlaneDist;\n    float fov;\n    Transform transform;\n};\n\nstruct Spheres\n{\n    int num;\n    vec3[2] pos;  // positions\n    float[2] r;   // radius(s?)\n    int[2] mat;   // material index\n};\n\nstruct Lights\n{\n    int num;\n    vec3[3] pos;\n    vec3[3] col;       //color\n    float[3] strength;\n};\n\nstruct NearestObject\n{\n    int mat;\n    float dist;\n    vec3 n;\n    vec3 pos;\n};\n\n\n// transformation\nTransform newTransform()\n{\n    Transform t;\n    t.pos = vec3(0.0);\n    t.f = vec3(0.0, 0.0, 1.0);\n    t.u = vec3(0.0, 1.0, 0.0);\n    t.r = vec3(1.0, 0.0, 0.0);\n    t.scale = vec3(1.0);\n    return t;\n}\n\nTransform getTransformation(vec3 t, vec3 r, vec3 s)\n{\n    Transform tr;\n    tr.pos = t;\n    \n    float sinx = sin(r.x);\n    float cosx = cos(r.x);\n    float siny = sin(r.y);\n    float cosy = cos(r.y);\n    float sinz = sin(r.z);\n    float cosz = cos(r.z);\n    \n    mat4 rot;\n    rot[0] = vec4(cosy * cosz,\n                  cosx * sinz + sinx * siny * cosz,\n                  sinx * sinz - cosx * siny * cosz,\n                  0.0);\n    rot[1] = vec4(-cosy * sinz,\n                  cosx * cosz - sinx * siny * sinz,\n                  sinx * cosz + cosx * siny * sinz,\n                  0.0);\n    rot[2] = vec4(siny,\n                  -sinx * cosy,\n                  cosx * cosy,\n                  0.0);\n    rot[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    tr.r = rot[0].xyz;\n    tr.u = rot[1].xyz;\n    tr.f = rot[2].xyz;\n    \n    return tr;\n    \n}\n\n\n// populate scene\nLights makeLights()\n{\n    Lights l;\n    l.num = 3;\n    l.pos = vec3[](vec3(0.0), vec3(0.0), vec3(0.0));\n    l.col = vec3[](vec3(0.0), vec3(0.0), vec3(0.0));\n    l.strength = float[](5.0, 1.0, 1.0);\n    \n    float rotRad = 5.0;\n    float rotSpeed = 0.8;\n    \n    l.pos[0] = vec3(sin(iTime*rotSpeed + pi)*rotRad, 9.0, 3.1 + cos(iTime*rotSpeed + pi)*rotRad);\n    l.col[0] = vec3(1.0, 0.0, 0.0);\n    l.strength[0] = 5.0;\n    \n    \n    l.pos[1] = vec3(sin(iTime*rotSpeed)*rotRad, 9.0, 3.1 + cos(iTime*rotSpeed)*rotRad);\n    l.col[1] = vec3(0.0, 0.0, 1.0);\n    l.strength[1] = 5.0;\n    \n    l.pos[2] = vec3(0.0, -9.0, -5.0);\n    l.col[2] = vec3(0.0, 1.0, 0.0);\n    l.strength[2] = 5.0;\n\n    \n    return l;\n}\n\nSpheres makeSpheres()\n{\n    Spheres s;\n    s.num = 2;\n    s.pos = vec3[](vec3(0.0), vec3(0.0));\n    s.r = float[](3.0, 3.0);\n    s.mat = int[](1, 1);\n    \n    s.pos[0] = vec3(3.0 + 3.0 * cos(iTime * 0.5), 0.0, 0.0);\n    s.pos[1] = vec3(-5.0, 0.0, 0.0);\n    return s;\n}\n\n\n// ray marching\nvec3 getRayDirection(vec2 uv, Camera cam)\n{\n    // a is half of near plane width/height.\n    float a = tan(cam.fov) * cam.nearPlaneDist;\n    \n    vec3 p = a * (uv.x*cam.transform.r + uv.y*cam.transform.u + cam.transform.f*cam.nearPlaneDist);\n    \n    return normalize(p);\n}\n\nNearestObject getNearestSphere(vec3 pos, Spheres spheres)\n{\n    NearestObject o;\n    o.mat = -1;\n    o.dist = 99999999.9;\n    float dist;\n    \n    for (int i = 0; i < spheres.num; i+=1)\n    {\n        dist = distance(pos, spheres.pos[i]) - spheres.r[i];\n        if (dist <o.dist)\n        {\n            o.mat = spheres.mat[i];\n            o.dist = dist;\n            o.pos = pos;\n        }\n    }\n    return o;\n}\n\nNearestObject getNearest(vec3 pos, Spheres spheres)\n{\n       NearestObject o;\n       o = getNearestSphere(pos, spheres);\n       \n       return o;\n}\n\n\nvec3 getNormal(vec3 pos, Spheres spheres)\n{\n    float posDist = getNearest(pos, spheres).dist;\n    float xDist = getNearest(pos + vec3(e, 0.0, 0.0), spheres).dist;\n    float yDist = getNearest(pos + vec3(0.0, e, 0.0), spheres).dist;\n    float zDist = getNearest(pos + vec3(0.0, 0.0, e), spheres).dist;\n    \n    return (vec3(xDist, yDist, zDist) -posDist) / e;\n}\n\nNearestObject castRay(Ray ray, Spheres spheres)\n{\n    int i = 20; // max amount of iterations;\n    float minDist = 0.001;\n    float maxDist = 100.0;\n    \n    NearestObject o;\n    o.mat = -1;\n    \n    while (i > 0)\n    {\n        o = getNearest(ray.origin, spheres);\n        \n        if (o.dist < minDist || o.dist > maxDist)\n            i = -1;\n        \n        ray.origin += ray.direction * o.dist;\n        \n        i -= 1;\n    }\n    \n    o.n = getNormal(o.pos, spheres);\n    return o;\n}\n\n// lighting\n\nvec4 calcColor(NearestObject o, Lights lights)\n{\n    vec4 bgColor = vec4(0.1,0.1,0.1,1.0);\n    \n    if (o.dist > 0.1)\n        return bgColor;\n        \n    vec3 col = vec3(0.0);\n    \n    //// return vec4(o.n, 1.0); //////////\n    \n    for (int i = 0; i < lights.num; i+=1)\n    {\n        vec3 dir = lights.pos[i] - o.pos;\n        float d = dot(normalize(dir), o.n);\n        \n        if(d > 0.0)\n        {\n        //return vec4(vec3(dot(normalize(dir), o.pos)), 1.0);\n            col += d * lights.col[i] * lights.strength[i]/length(dir);\n        }\n    }\n    \n    //col += vec3(0.2); // fake gi\n    //return vec4(o.n, 1.0);\n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Camera cam;\n    cam.nearPlaneDist = 1.5;\n    cam.fov = 70.0 * pi / 180.0;\n    cam.transform = newTransform();\n    \n    //cam.transform = getTransformation(vec3(20.0 * sin(iTime), 0.0, -20.0 * cos(iTime)), vec3(0.0, -iTime, 0.0), vec3(1.0));\n    cam.transform = getTransformation(vec3(0.0, 0.0, -15.0), vec3(0.0), vec3(1.0));\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    // center and scale uv coordinates\n    uv = (uv - vec2(0.5)) * 2.0;\n    // scale uv to screen resolution\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // populate scene\n    Lights l = makeLights();\n    Spheres s = makeSpheres();\n    \n    \n    // cast ray\n    Ray ray;\n    ray.direction = getRayDirection(uv, cam);\n    ray.origin = cam.transform.pos;\n    \n    NearestObject o = castRay(ray, s);\n    \n    \n    fragColor = calcColor(o, l);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}