{
    "Shader": {
        "info": {
            "date": "1677299525",
            "description": "pick a\ntribute to classics",
            "flags": 0,
            "hasliked": 0,
            "id": "mljXzG",
            "likes": 8,
            "name": "metal lotus 04",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "flower",
                "lotus",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "chenxianming",
            "viewed": 1724
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926\n#define TAU 6.2831852\n#define sTime 3.\n#define sS 1.2\n// for less performance device is true\n#define smooth true\n#define calcUnit 0\n\nconst float count = 7.;\n\nfloat easeOutExpo (float t) {\n    // for mac os API pow( x, y )\n    // y was smoothly allowed\n    return t == 1. ? 1. : 1. - pow( 2., -10. * t );\n}\n\nfloat getTimeline( float t ){\n    float tl = ( t >= sTime ) ? ( t - sTime ) : 0.;\n    \n    return ( t >= ( sTime + 1. ) ) ? 1. : tl;\n}\n\nconst mat2 m = mat2(-1.1, -.4, .3, 1.0);\n\nmat2 rotation(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat myNoise( in vec2 f ){\n    f *= m;\n    return ( cos( f.x + .18975 ) * sin( f.y + .494516 ) + .1615246 );\n}\n\n\nfloat fbm( in vec2 x, in float H )\n{    \n    float t = 0.0;\n    for( int i=0; i<7; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        x *= rotation( float( i ) );\n        float a = pow( f, -H );\n        a = smoothstep( 0., .05, a );\n        \n        t += a*myNoise(f*x * rotation( float(i) ));\n\n    }\n    return t;\n}\n\nfloat deg2Rad( float deg ){\n    // return deg * PI / 180.;\n    return radians( deg );\n}\n\nfloat axies( vec3 p, float r, float h ){\n    return max( length( p.xy ) - r, abs( p.z ) - h );\n}\n\n// iq\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat bud( vec3 p, vec3 trasf ){\n    \n    p.z += 1.6;\n    \n    // p.z += pow( dot( p.xz, p.xz ), .5 ) * .2;\n    \n    float a = dot( p.xy, p.xy );\n    \n    p.z -= pow( a, .35 );\n\n    p.z -= cos( p.x ) * .2;\n    p.z -= cos( p.y ) * .2;\n    \n    return sdEllipsoid( p, vec3( .05, .05, .15 ) );\n}\n\nfloat p2d( vec2 uv ){\n\n    float ll = ( pow( uv.x + .35, 2. ) + pow( uv.y, 2. ) - .45 );\n    float rr = ( pow( uv.x - .35, 2. ) + pow( uv.y, 2. ) - .45 );\n\n    return smoothstep( .095, max( ll, rr ), 0.1 );\n}\n\nvec3 calcBg( vec2 uv ){\n    vec3 c = vec3( 0. );\n    \n    for( float i = 0.; i < 20.; i++ ){\n        float x = cos( i / 20. * TAU ) * .4 * ( i / 5. );\n        float y = sin( i / 20. * TAU ) * .4 * ( i / 5. );\n        \n        vec2 v = uv * rotation( deg2Rad( ( 360. / 20. ) * i ) + ( cos( iTime * -.25 ) * i / 20. ) * .5 );\n        \n        v -= .5;\n        v *= rotation( i / 20. );\n        \n        \n        v *= i / 20.;\n        \n        v.x += cos( iTime * .25 ) * .3;\n        v.y += sin( iTime * .25 ) * .3;\n        \n        \n        //p = mix( p, i / 120., p2d( vec2( v.x + x, v.y + y ) ) );\n        \n        c = mix( c, i / 20. * vec3(.83, .3, .43), p2d( vec2( v.x + x, v.y + y ) ) ) * .7;\n    }\n    \n    return c;\n}\n\nfloat petal( vec3 p, vec3 trasf, float h, float r, float rot, float i ){\n    \n    #if calcUnit == 0\n    p.z -= .2;\n    p.xz *= rotation( PI * ( -.15 - i * .13 ) * ( 1. - getTimeline( iTime * sS ) ) );\n    p.z += .2;\n    \n    p.z += pow( p.x, 2.8 );\n    \n    #else\n    \n    p.z -= cos( p.x );\n    p.z -= cos( p.y );\n    p.z += 2.;\n    \n    #endif\n\n    // p.z += pow( p.x, 2.8 );\n    // p.z += pow( p.y, 2.8 );\n    \n    p += trasf;\n    p.xy *= rotation( rot );\n    \n    \n    //p.z += .1;\n    //p.yz *= rotation( PI );\n    \n    //float d = max( length( pow( p.x, 1.6 - i * .05 ) + pow( p.y, 2.0 ) ) - r, abs( p.z ) - h );\n    \n    float ll = ( pow( p.x + .16, 2. ) + pow( p.y, 2. ) - r * 1.4 );\n    float rr = ( pow( p.x - .16, 2. ) + pow( p.y, 2. ) - r * 1.4 );\n\n    float d = max( max( ll, rr ), abs( p.z ) - h );\n    \n    p.y -= .25;\n    p.yz *= rotation( PI * .5 );\n\n    d = min( sdEllipsoid( p, vec3( .005 + ( 4. - i ) * .001, .005 + ( 4. - i ) * .001, .04 + ( 4. - i ) * .025 ) ), d );\n\n    return d;\n}\n\n\nfloat addLayer( float d, vec3 pos, int lI ){\n    vec3 p = pos;\n    \n    p.z += .8;\n    p.z += float( lI ) * .1;\n    \n    p.xy *= rotation( float( lI ) / count * PI );\n    \n    for( float i = 0.; i < count; i++ ){\n        \n        vec3 v = vec3( 0.0, -0.0, -.3 );\n        \n        v.x += cos( ( i / count ) * TAU ) * (.6 - ( float( lI ) ) * .055);\n        v.y += sin( ( i / count ) * TAU ) * (.6 - ( float( lI ) ) * .055);\n        \n        float n = petal( p, v, .01, .11 - float( lI ) * .015, deg2Rad( ( 360. / count ) * i ) + PI * .5, float( lI ) );\n        d = min( d, n );\n    }\n    \n    return d;\n}\n\nvoid repetition(inout vec2 p, float rep) \n{\n\n    float an = TAU/count;\n    \n    float fa = (atan(p.y,p.x)+an*0.5)/an;\n    float ia = floor( fa );\n    \n    float sym = an*ia;\n    vec2 r = mat2(cos(sym),-sin(sym),\n                  sin(sym), cos(sym))*p;\n                  \n    p = r;\n}\n\nfloat allPetals( float d, vec3 pos, int lI ){\n    vec3 p = pos;\n    \n    float i = float( lI );\n    \n    p.xy *= rotation( PI * ( i - 1. ) + ( 1. - easeOutExpo( getTimeline( iTime * sS - max( 0., i / 4. * .8 ) ) ) ) * 4. );\n    \n    p.z += .6;\n    p.z += float( lI ) * .1;\n    \n    repetition( p.xy, 7. );\n    //     float n = petal( p, vec3( -0.58 + ( i * .055 ), 0.0, -.12 ), .01, .11 - i * .015, PI * -.5, i );\n\n    float n = petal( p, vec3( -0.6 + ( i * .07 ), 0.0, -.12 ), .01, .11 - i * .015, PI * -.5, i );\n    return n;\n}\n\nfloat eachPetal( vec3 p ){\n    float d = 5.;\n    vec3 pos = p;\n\n\n    #if calcUnit==1\n    \n    d = min( d, addLayer(d, p, 1) );\n    d = min( d, addLayer(d, p, 2) );\n    d = min( d, addLayer(d, p, 3) );\n    d = min( d, addLayer(d, p, 4) );\n    \n    #else\n    \n    d = min( d, allPetals(d, p, 1) );\n    d = min( d, allPetals(d, p, 2) );\n    d = min( d, allPetals(d, p, 3) );\n    d = min( d, allPetals(d, p, 4) );\n    \n    p = pos;\n    p.yz *= rotation( .5 * PI );\n    \n    #endif\n    \n    // d += pow( d, .999 ) * .001;\n    \n    float n = fbm( vec2( fbm( p.xz, .1 ) ), .1 );\n    \n    \n    return d;\n}\n\nfloat buud( vec3 p ){\n    float d = 5.;\n    p.z += .2;\n    d = min( d, bud( p, vec3( 0.0, 0.0, 0.0 ) ) );\n    p.z -= .2;\n    \n    return d;\n}\n\n\n\nfloat map(vec3 pos) {\n\n    vec3 p = pos;\n    \n    p.yz *= rotation( .5 * PI );\n\n    float d = axies( p, .05, .8 );\n    \n    d = max( d, axies( p, .045, .9 ) );\n    \n    float n = fbm( vec2( fbm( pos.yz, 1. ) ), .9 );\n    \n    p.z -= .4;\n    d = min( d, axies( p + n * .005, .05, 1.4 ) );\n    p.z += .4;\n    p.z += .2;\n    \n    d = min( d, axies( p, .02, 1.1 ) );\n    \n    p.z -= .2;\n    p.yz *= rotation( .0 * PI );\n    \n    d = min( d, buud( p ) );\n    \n    // bottom\n    /*\n    p.z += .7;\n    d = min( d, max( length( p ) - .15, abs( p.z ) - .02 ) );\n    p.z -= .7;\n    \n    p.z += .6;\n    d = min( d, max( length( p ) - .2, abs( p.z ) - .02 ) );\n    p.z -= .6;\n    */\n    \n    d = min( d, eachPetal( p ) );\n    \n    p.z += .875;\n    p.xy *= rotation( .58 * PI );\n    d = min( d, sdHexPrism( p, vec2( .115, .02 ) ) );\n    \n    p.z -= .33 - ( 1. - easeOutExpo( getTimeline( iTime * sS - .7 ) ) ) * .33;\n\n    d = min( d, sdHexPrism( p, vec2( .11 + ( .15 * ( easeOutExpo( getTimeline( iTime * sS - .2 ) ) ) ), .01 ) ) );\n\n    // repair\n    p.z += .25;\n    d = min( d, sdHexPrism( p, vec2( .115, .08 ) ) );\n\n    return d;\n}\n\n// IQ\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    const float eps = 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy * eps) +\n        e.yyx * map(pos + e.yyx * eps) +\n        e.yxy * map(pos + e.yxy * eps) +\n        e.xxx * map(pos + e.xxx * eps));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.yy;\n    uv.x -= ( iResolution.x - iResolution.y ) / iResolution.y * .5;\n\n    // Time varying pixel color\n    float tt = iTime * .4;\n\n    uv = (uv - .5) * 2.;\n\n\n    vec3 origin = vec3(cos(tt) * -2.0, 1.8, sin(tt) * -2.0);\n    vec3 ta = vec3(0.3, 0.3, 0.0);\n\n    // origin = vec3(0.0, 0.0, -3.5);\n\n    // camera matrix\n    vec3 ww = normalize(ta - origin);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n\n    vec3 tot = vec3(0.0);\n\n    vec3 ray = normalize(uv.x * uu + uv.y * vv + 1.5 * ww);\n\n    float t = 0.0;\n\n    const float tmax = 5.0;\n    \n    \n    for (int i = 0; i < ( smooth ? 60 : 256 ); ++i) {\n        vec3 p = origin + ray * t;\n        \n        float distance = map(p);\n        t += distance * .4333;\n    }\n\n    vec3 col = calcBg( uv );\n    \n    vec3 lig = normalize(vec3(.57703));\n    lig.xz *= rotation( iTime * .1 );\n    \n    vec3 hal = normalize(lig - ray);\n    // vec3 spcol = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    if (t < tmax) {\n        vec3 pos = origin + t * ray;\n        vec3 nor = calcNormal(pos);\n\n        float dif = clamp(dot(nor, vec3(.4, 1., -.5)), 0.0, 1.0);\n\n        float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 50.0) * .6;\n        spe *= dif;\n\n        float amb = dot(nor, vec3(0.0, 1.0, 0.0));\n        \n        vec3 ap = pos;\n        ap.yz *= rotation( .5 * PI );\n        \n        vec3 b = reflect( nor, pos );\n        \n        float p = fbm( vec2( fbm( vec2( b.xz ) * .5, 1. ) ), .9 );\n        \n        if( map( pos ) == eachPetal( ap ) ){\n        \n            float shadow = calcSoftshadow( pos, lig, 0.1, 3.0, 1 );\n            dif *= shadow;\n\n            col = spe + ( vec3(.93, .06, .76) + p * dif * .05 ) * amb + vec3(.5) * dif + vec3(.93, .06, .76) * .5;\n        }else if( map( pos ) == buud( ap ) ){\n            col = spe + ( vec3(.8, .2, .5) + p * .05 ) * amb + vec3(.8) * dif + vec3(.8, .2, .5) * .5;\n        }else{\n            col = spe + vec3(.05 + p) * amb + vec3(.1) * dif + vec3(.3, .7, .54) * .15;\n            vec3 af = vec3(0.1);\n            af += 2.*dif*vec3(1.,.2,.3);\n            af += 2.*spe*vec3(1.,2.,3.)*dif;\n            col = col*af;\n        }\n        \n        // af\n        col += 0.08 * cos(iTime+uv.xyx+vec3(0,2,4));\n    }\n\n    // gamma        \n    col = sqrt(col);\n    tot += col;\n\n    // Output to screen\n    fragColor = vec4(tot, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}