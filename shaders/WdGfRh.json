{
    "Shader": {
        "info": {
            "date": "1607221879",
            "description": "diamond!",
            "flags": 32,
            "hasliked": 0,
            "id": "WdGfRh",
            "likes": 25,
            "name": "Round Brilliant Cut",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "Catzpaw",
            "viewed": 1193
        },
        "renderpass": [
            {
                "code": "//--- Round Brilliant Cut\n// by Catzpaw 2020\n\n//Image:post effect\n\n#define ITER   36.\n#define RADIUS 0.05\n\nvec4 tx(vec2 uv){return texture(iChannel0,uv);}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    vec2 m=vec2(1,iResolution.x/iResolution.y);\n    vec4 c=tx(uv);\n    float a=sin(iTime*.1)*6.283,v=0.,b=1./ITER;\n    for(int j=ZERO;j<6;j++){\n        float r=RADIUS/ITER;\n        vec2 d=vec2(cos(a),sin(a))*m;\n        for(int i=ZERO;i<int(ITER);i++){\n            v+=tx(uv+d*r*RADIUS).w*(1.-r);\n            r+=b;\n        }\n        a+=1.047;\n    }\n    v*=.01;\n    c+=v;\n    c.w=1.;\n\tfragColor=c;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//--- Round Brilliant Cut\n// by Catzpaw 2020\n\n//BufferA:scene\n\n//refraction index\n#define RI1 2.40\n#define RI2 2.44\n\n//settings:trace\n#define ITER   256\n#define EPS   1e-4\n#define NEAR   1.0\n#define FAR   10.0\n\n//settings:trace2\n#define ITER2  128\n#define EPS2  1e-4\n#define NEAR2 0.02\n\n//CONSTANTS\nconst float pi=acos(-1.);\nconst float qp=pi*.25,op=qp*.5,hp=op*.5;\nconst mat2 rot4=mat2(sin(qp),cos(qp),-cos(qp),sin(qp));\nconst mat2 rot3=mat2(sin(qp+op),cos(qp+op),-cos(qp+op),sin(qp+op));\nconst mat2 rot2=mat2(sin(op),cos(op),-cos(op),sin(op));\nconst mat2 rot1=mat2(sin(hp),cos(hp),-cos(hp),sin(hp));\n\n//SDF\nfloat sdTable(vec3 p){\n\tvec2 d=abs(vec2(length(p.xz),(p.y+0.159)*1.650))-vec2(1,1);\n\treturn min(max(d.x,d.y),0.)+length(max(d,0.));\n}\nfloat sdCut(vec3 p,float a,float h){\n    p.y*=a;\n    p.y-=(abs(p.x)+abs(p.z))*h;p=abs(p);\n\treturn (p.x+p.y+p.z-1.)*.5;\n}\n\n//SCENE\nfloat map(vec3 p){\n    p.yz*=rot(.3);\n    p.xz*=rot(-iTime*.8);\n    //table & girdle\n    float d=sdTable(p);\n    //star facet\n    vec3 q=p*0.3000;q.y+=0.0808;q.xz*=rot2;\n\tq.xz=abs(q.xz);q.xz*=rot4;q.xz=abs(q.xz);\n    q.xz*=rot2;d=max(d,sdCut(q,3.700,0.0000));\n    //main facet\n    q=p*0.691;\n    q.xz=abs(q.xz);q.xz*=rot4;q.xz=abs(q.xz);\n    q.xz*=rot2;d=max(d,sdCut(q,1.868,0.1744));\n    //girdle facet\n    q*=1.022;q.y-=0.034;\n    q.xz*=rot1;d=max(d,sdCut(q,1.650,0.1000));\n    q.xz*=rot3;d=max(d,sdCut(q,1.650,0.1000));\n\treturn d;\n}\n\n//NORMAL\nvec3 normal(vec3 p){\n    const vec2 e=vec2(-1,1);\n    return normalize(e.xxx*map(p+e.xxx*EPS)+e.xyy*map(p+e.xyy*EPS)+\n                     e.yxy*map(p+e.yxy*EPS)+e.yyx*map(p+e.yyx*EPS));\n}\n\n//RAYMARCHING\nfloat trace(vec3 ro,vec3 rd,out vec3 p,out vec3 n){\n    float t=NEAR,d;\n    for(int i=ZERO;i<ITER;i++){\n        p=ro+rd*t;\n        d=map(p);\n        if(abs(d)<EPS||t>FAR)break;\n        t+=step(d,1.)*d*.5+d*.5;\n    }\n    n=normal(p);\n    return min(t,FAR);\n}\n\n//RAYMARCHING UNDER SURFACE\nfloat trace2(vec3 ro,vec3 rd,out vec3 p,out vec3 n){\n    float t=NEAR2,d;\n    for(int i=ZERO;i<ITER2;i++){\n        p=ro+rd*t;\n        d=-map(p);\n        if(abs(d)<EPS2||d<EPS2)break;\n        t+=d;\n    }\n    n=-normal(p);\n    return t;\n}\n\n//CUBEMAP\nvec3 cubemap(vec3 d){    \n\treturn texture(iChannel0,d).rgb;\n}\n\n//FRESNEL EQUATION\nfloat schlickFresnel(float ri,float co) {\n    float r=(1.-ri)/(1.+ri);\n    r=r*r;\n    return r+(1.-r)*pow(1.-co,5.);\n}\n\n//GET LIGHT PATH\nvec3 lightPath(vec3 p,vec3 rd,float ri){\n    vec3 n;\n    vec3 r0=-rd;\n    //2nd reflection\n    trace2(p,rd,p,n);\n    rd=reflect(rd,n);\n    vec3 r1=refract(rd,n,ri);\n    r1=length(r1)<EPS?r0:r1;\n    //3rd reflection\n    trace2(p,rd,p,n);\n    rd=reflect(rd,n);\n    vec3 r2=refract(rd,n,ri);\n    r2=length(r2)<EPS?r1:r2;\n    //final refraction\n    trace2(p,rd,p,n);\n    vec3 r3=refract(rd,n,ri);\n    return length(r3)<EPS?r2:r3;\n}\n\n//MATERIAL\nvec3 material(vec3 p,vec3 rd,vec3 n){\n\n    //1st reflection\n    vec3 l0=reflect(rd,n);\n\n    //cosine for fresnel\n    float co=max(0.,dot(-rd,n));\n    \n    //low frequency light path\n    float f1=schlickFresnel(RI1,co);\n    vec3 l1=lightPath(p,refract(rd,n,1./RI1),RI1);\n    \n    //high frequency light path\n    float f2=schlickFresnel(RI2,co);\n    vec3 l2=lightPath(p,refract(rd,n,1./RI2),RI2);\n\n    //dispersion\n    float a=0.;\n    vec3 dc=vec3(0);\n    vec3 r=cubemap(l0);\n    for(int i=ZERO;i<10;i++){\n        vec3 l=normalize(mix(l1,l2,a));\n        float f=mix(f1,f2,a);\n        dc+=cubemap(l)*hsv(a+.9,1.,1.)*(1.-f)+r*f;\n        a+=.1;\n    }\n    dc*=.19;\n    \n    return dc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //CAMERA SETUP\n    vec2 m=iMouse.xy/iResolution.xy;\n    vec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 p,n,c=vec3(0),\n         ro=vec3(0,0,-3.5),\n         rd=normalize(vec3(uv,1.5));\n    mat2 r=rot(sin(iTime*.3+4.)*.5-.8+m.y*6.3);\n    ro.yz*=r;\n    rd.yz*=r;\n    r=rot(iTime*.21+.7+m.x*6.3);\n    ro.xz*=r;\n    rd.xz*=r;\n\n    //GET SURFACE\n    float t=trace(ro,rd,p,n);\n\n    //SHADING\n    float w=0.;\n    if(t>9.){\n        //background\n        c=cubemap(rd);\n    }else{\n        //diamond\n\t    c=material(p,rd,n);\n        w=smoothstep(1.60,1.61,length(c));\n    }\n    fragColor=vec4(c,w);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//--- Round Brilliant Cut\n// by Catzpaw 2020\n\n//Common:snippets\n\n#define ZERO min(0,iFrame)\n\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\nvec3 hsv(float h,float s,float v){return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}