{
    "Shader": {
        "info": {
            "date": "1614263437",
            "description": "fun iso?",
            "flags": 0,
            "hasliked": 0,
            "id": "3lKBW1",
            "likes": 2,
            "name": "iso fun",
            "published": 3,
            "tags": [
                "isofun"
            ],
            "usePreview": 0,
            "username": "gourki",
            "viewed": 242
        },
        "renderpass": [
            {
                "code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define PI acos(-1.)\n\nvoid mo(inout vec2 p, vec2 d)\n{\n    p =abs(p)-d;\n    if(p.y>p.x) p = p.yx;\n}\n\n\nfloat signed_box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat SDF (vec3 position)\n{\n    position.yz *=rot(iTime/2.*-atan(1./sqrt(2.)));\n    position.xz *=rot(PI/4.*iTime/2.);\n    \n    //mo(position.xz,vec2(1.));\n    mo(position.xz,vec2(abs(sin(iTime/2.)),abs(cos(iTime/2.))));\n    mo(position.yz,vec2(abs(cos(iTime/2.)),abs(sin(iTime/2.))));\n    position.x -= sin(iTime/2.)+1.;\n    position.y -= cos(iTime/2.)+1.;\n    //position.xz *= rot(iTime);\n    //position.yz *= rot(iTime);\n    return signed_box(position, vec3(.5));\n}\n\nvec3 get_normals (vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize( SDF(p) - vec3(SDF(p-eps.xyy), SDF(p-eps.yxy),SDF(p-eps.yyx)) );\n   //return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n     // thanks remy ! random qui va noise les uvs, rendant un effet sur le rendu\n    float rand = 0.;fract(sin(length(uv)*64.125 + fract(iTime*.001))*752.3216) * sin(iTime/3.)/100.;\n    \n    \n    // perspective camera\n    /*vec3 ray_origin = vec3(0.,0.,-2.),\n    ray_direction = normalize( vec3(uv,1.) ),\n    pos = ray_origin,\n    */\n    \n    \n    //orthographic camera\n    vec3 ray_origin = vec3(uv*2.,-20.),\n    ray_direction = normalize( vec3(vec2(0.+rand, 0.+rand),1.) ),\n    pos = ray_origin,\n    \n    //light \n    dir_light = normalize( vec3(-1.,1.,-2.) ),\n    //background color\n    col = vec3(0.);\n    \n    bool hit = false;\n    float shading;\n    for (float i=0.; i<64.; i++)\n    {\n        float dist = SDF(pos);\n        if(dist < 0.001)\n        {\n            hit = true;\n            shading = i/64.;\n            break;\n        }\n        pos += dist * ray_direction;\n    }\n    \n    if (hit)\n    {\n        vec3 normal = get_normals(pos);\n        float lighting = max(dot(normal,dir_light),0.);\n        col = normal*vec3(lighting);\n    }\n    \n    \n\n    // Output to screen\n    fragColor = vec4(pow(col,vec3(2.)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}