{
    "Shader": {
        "info": {
            "date": "1511725075",
            "description": "subdividing screen space where a tile is crossing the contour of a distance field",
            "flags": 0,
            "hasliked": 0,
            "id": "MlffW8",
            "likes": 54,
            "name": "SDF Raymarch Quadtree",
            "published": 3,
            "tags": [
                "raymarch",
                "sdf",
                "quadtree"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 2025
        },
        "renderpass": [
            {
                "code": "\n#define MAX_STEPS 50\n\n// undef to disable hole, then parameter s.w not needed\n// #define CONVEX\n\n// sdUberprim with precomputed constants\nfloat sdUnterprim(vec3 p, vec4 s, vec3 r, vec2 ba, float sz2) {\n    vec3 d = abs(p) - s.xyz;\n    float q = length(max(d.xy, 0.0)) + min(0.0,max(d.x,d.y)) - r.x;\n    // hole support: without this line, all results are convex\n#ifndef CONVEX    \n    q = abs(q) - s.w;\n#endif\n    \n    vec2 pa = vec2(q, p.z - s.z);\n    vec2 diag = pa - vec2(r.z,sz2) * clamp(dot(pa,ba), 0.0, 1.0);\n    vec2 h0 = vec2(max(q - r.z,0.0),p.z + s.z);\n    vec2 h1 = vec2(max(q,0.0),p.z - s.z);\n    \n    return sqrt(min(dot(diag,diag),min(dot(h0,h0),dot(h1,h1))))\n        * sign(max(dot(pa,vec2(-ba.y, ba.x)), d.z)) - r.y;\n}\n\n// s: width, height, depth, thickness\n// r: xy corner radius, z corner radius, bottom radius offset\nfloat sdUberprim(vec3 p, vec4 s, vec3 r) {\n    // these operations can be precomputed\n    s.xy -= r.x;\n#ifdef CONVEX  \n    r.x -= r.y;\n#else\n    r.x -= s.w;\n    s.w -= r.y;\n#endif\n    s.z -= r.y;\n    vec2 ba = vec2(r.z, -2.0*s.z);\n    return sdUnterprim(p, s, r, ba/dot(ba,ba), ba.y);\n}\n\n// example parameters\n#define SHAPE_COUNT 9.0\nvoid getfactor (int i, out vec4 s, out vec3 r) {\n    //i = 4;\n    if (i == 0) { // cube\n        s = vec4(1.0);\n        r = vec3(0.0);\n    } else if (i == 1) { // cylinder\n        s = vec4(1.0);\n        r = vec3(1.0,0.0,0.0);\n    } else if (i == 2) { // cone\n        s = vec4(0.0,0.0,1.0,1.0);\n        r = vec3(0.0,0.0,1.0);\n\t} else if (i == 3) { // pill\n        s = vec4(1.0,1.0,2.0,1.0);\n        r = vec3(1.0,1.0,0.0);\n    } else if (i == 4) { // sphere\n        s = vec4(1.0);\n        r = vec3(1.0,1.0,0.0);\n    } else if (i == 5) { // pellet\n        s = vec4(1.0,1.0,0.25,1.0);\n        r = vec3(1.0,0.25,0.0);\n    } else if (i == 6) { // torus\n        s = vec4(1.0,1.0,0.25,0.25);\n        r = vec3(1.0,0.25,0.0);\n    } else if (i == 7) { // pipe\n        s = vec4(vec3(1.0),0.25);\n        r = vec3(1.0,0.1,0.0);\n    } else if (i == 8) { // corridor\n        s = vec4(vec3(1.0),0.25);\n        r = vec3(0.1,0.1,0.0);\n\t}\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 1.5 + sin(time * 0.1) * 0.7;\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat doobject (vec3 p, float k) {\n    float u = smoothstep(0.0,1.0,smoothstep(0.0,1.0,fract(k)));\n    int s1 = int(mod(k,SHAPE_COUNT));\n    int s2 = int(mod(k+1.0,SHAPE_COUNT));\n    \n    vec4 sa,sb;\n    vec3 ra,rb;\n    getfactor(s1,sa,ra);\n    getfactor(s2,sb,rb);\n    \n    return  sdUberprim(p.zyx, mix(sa,sb,u), mix(ra,rb,u));\n}\n\nbool interior;\n\nfloat doModel( vec3 p ) {\n    float k = iTime*0.5;\n    float d = doobject(p - vec3(0.0,0.0,-0.5), k);\n    float d2 = doobject(p - vec3(0.0,0.0,0.5), k + 1.0);\n    if (interior)\n    \td = min(d, d2);\n   \telse\n    \td = smin(d, d2, 0.4);\n    \n    return d;\n}\n\nfloat calcIntersection( in float t, in vec3 ro, in vec3 rd, vec2 pixel, float bias, inout int steps )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tfloat aperture = 0.7071067811866 * max(pixel.y,pixel.x);        // aperture of cone\n    float C = sqrt(aperture*aperture + 1.0);\n    // radius of sphere at t=1\n    float R = aperture/C;\n    // constant adjustment factor for t so that the cone sphere touches the distance radius\n    float A = C / (C + bias*aperture);\n    // for a better demo of how the above factors work, see https://www.shadertoy.com/view/4lfBWH\n    \n\tfloat res = -1.0;\n    float tc = (bias > 0.0)?0.0:1.0;\n    t = t * C;\n    for( int i=0; i<MAX_STEPS; i++ ) {\n        steps = steps + 1;\n\t\tfloat limit = bias*R*t;\n        // add small bias to reduce iteration count\n        limit += 1e-03*t;\n\t    float h = doModel( ro+rd*t );\n        t = (t + h)*A;\n    \tif((h <= limit) || (t > maxd)) {\n            break;\n        }\n    }\n\n    if( t<maxd ) res = t;\n    return res / C;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ));\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nbool dorender( inout float dist, inout int steps, out vec3 position, in vec2 p, in vec2 pixel, in float bias)\n{\n    //-----------------------------------------------------\n    // camera1\n    //-----------------------------------------------------\n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, 0.0 );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( dist, ro, rd, pixel, bias, steps );\n    dist = t;\n    if( t>-0.5 )\n    {\n        // geometry\n        position = ro + t*rd;\n        return true;\n\t}\n    return false;\n}\n\nvec3 hue2rgb (float hue) {\n    return clamp(abs(mod(hue * 6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0,0.0,1.0);\n}\n\n// maps n=0 to blue, n=1 to red, n=0.5 to green\nvec3 normhue (float n)  {\n    return hue2rgb((1.0 - clamp(n,0.0,1.0)) * 0.66667);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    vec2 c0 = vec2(-2.0,-2.0);\n    vec2 c1 = vec2(2.0,2.0);\n    const int N = 9;\n    vec3 color = vec3(0.1);\n    int steps = 0;\n    float dist = 0.0;\n    for (int i = 0; i <= N; ++i) {\n        vec2 c = (c0 + c1)*0.5;\n        vec2 h = (c1 - c0)*0.5;\n        if (p.x < c.x) {\n            c1.x = c.x;\n        } else {\n            c0.x = c.x;\n        }\n        if (p.y < c.y) {\n            c1.y = c.y;\n        } else {\n            c0.y = c.y;\n        }\n        vec2 u = vec2(c0.x,c1.x);\n        vec2 v = vec2(c0.y,c1.y);\n        \n        vec2 center = vec2(u.y + u.x, v.y + v.x)*0.5;\n        vec2 radius = vec2(u.y - u.x, v.y - v.x)*0.5;\n        \n        vec3 pos;\n        bool outer_hit = dorender(dist, steps, pos, center, radius, 1.0);\n        float dist2 = dist;\n        bool inner_hit = dorender(dist2, steps, pos, center, radius, -1.0);\n        if (!outer_hit || inner_hit || (i == N)) {\n            color = normhue(float(steps)/float(MAX_STEPS * N));\n            float q = abs(max(abs(p.x - center.x), abs(p.y - center.y)) - radius.x)-0.0001;\n            q = clamp(q*200.0, 0.0, 1.0);\n            color *= vec3(q);\n            break;\n        }\n    }    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}