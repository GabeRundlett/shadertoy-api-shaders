{
    "Shader": {
        "info": {
            "date": "1651105845",
            "description": "Press r to reset\n\nIt's not visually interesting but kind of mathy",
            "flags": 48,
            "hasliked": 0,
            "id": "NlfBRj",
            "likes": 5,
            "name": "Repeated Path Automata",
            "published": 3,
            "tags": [
                "feedback",
                "cellularautomata"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 258
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zm = 0.5;\n    vec3 col = texelFetch( iChannel0, ivec2(vec2(-145, 80) + mix(fragCoord, 0.5 * iResolution.xy, zm)), 0 ).rgb;\n   \n    col.rgb = col.ggg - col.b;\n    fragColor.rgb = vec3(col);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "///\n\n// This is an old idea of mine, and I've never implemented it very well\n\n// Idea:\n// You have 1 particle which follows a fixed route/sequence\n// e.g. up x3, right x5, down x6, left x4\n// Once it's gone up/right/down/left, it will start again\n// If it hits inactive white cells, it will travel through them, pause the sequence\n// and start the sequence again once it's left those cells\n\n// Some sequences have very short \"cycles\" - they'll twirl in a very obvious pattern\n// into the distance\n// Other sequences have very long cycles, and you can only see a pattern after 100s\n// or 1000s of frames.\n\n// I'm not sure if there are sequences which don't repeat\n\n///\n\n#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\n\nvec3 Cell( in ivec2 p )\n{\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    \n    // fetch texel\n   // return (texelFetch(iChannel0, p, 0 ).x > 0.5 ) ? 1 : 0;\n   return texelFetch(iChannel0, p, 0 ).rgb;\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\n// Change me\n#define mx 9.\n#define val vec4(2,2,2,6)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n    \n    if (iFrame == 0 || key_down(KEY_RESET)) {\n        vec2 f = 0.01 * fragCoord + 0.01 * iTime; \n        float h = h21(f);\n        float h2 = h21(f.yx + 1.);\n\n        fragColor.r = 0.;//floor(4. * h2); // 0 1 2 3\n        fragColor.g = 0.;\n        vec2 i = 0.5 * iResolution.xy;\n        vec2 f2 = fragCoord;\n        if (f2.x > i.x && f2.x <= i.x + 1. && f2.y > i.y && f2.y <= i.y + 1.) { \n       // if (h > 0.999) {      \n            fragColor.b = mx;\n        }\n        return;\n    }\n    \n    // center cell\n    vec3 e = Cell(px); \n\n    // neighbour cells\n    vec3 t = Cell(px + ivec2(0,-1));\n    vec3 b = Cell(px + ivec2(0,1));\n    vec3 l = Cell(px + ivec2(-1,0));\n    vec3 r = Cell(px + ivec2(1,0));   \n\n    vec3 k = t + b + l + r;\n    //float k = max( max(l.x, r.x), max(t.x, b.x) );\n \n    // red: direction\n    // green: on/off\n    // blue: is cell active / how many gens before it turns\n    \n    // if cell is active, become inactive\n    if (e.b >= 1.) {\n        e = vec3(e.r, 1, 0);\n        //return;\n    }\n    \n    // (please dont judge me, im too lazy to untab everything)\n    if (true) {//k.b <= 2.) {\n        if (e.g == 1. || k.g > 1.) {\n            if (t.b >= 1. && t.r == 0.)\n                e = t;\n            else if (r.b >= 1. && r.r == 1.) \n                e = r;\n            else if (b.b >= 1. && b.r == 2.) \n                e = b;\n            else if (l.b >= 1. && l.r == 3.)\n                e = l;    \n        } else {\n            if (t.b >= 1. && t.r == 0.) {\n                if (t.b == val.x)\n                    e = vec3(1, 1, mx); \n                else\n                    e = vec3(0, 1, t.b - 1.);       \n            }\n            else if (r.b >= 1. && r.r == 1.) {\n                if (r.b == val.y)\n                    e = vec3(2, 1, mx);\n                else\n                    e = vec3(1, 1, r.b - 1.);\n            }\n            else if (b.b >= 1. && b.r == 2.) {\n                if (b.b == val.z)\n                    e = vec3(3, 1, mx);\n                else\n                    e = vec3(2, 1, b.b - 1.);\n            }\n            else if (l.b >= 1. && l.r == 3.) {\n                if (l.b == val.w)\n                    e = vec3(0, 1, mx);\n                else\n                    e = vec3(3, 1, l.b - 1.);\n            }    \n        }\n    }    \n    //e = clamp(e, 0., 1.);\n\tfragColor = vec4(e, 0.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define pi 3.1415926535\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}