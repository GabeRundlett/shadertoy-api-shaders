{
    "Shader": {
        "info": {
            "date": "1710355268",
            "description": "Inspired by these:\nhttps://www.youtube.com/watch?v=SthcxWPXG_E\nhttps://www.youtube.com/watch?v=lsAlFKXAMjM\nAudio stops after 3 minutes for reasons unknown to me.\n",
            "flags": 40,
            "hasliked": 0,
            "id": "XXjXzz",
            "likes": 14,
            "name": "Polyrhythm Visualizer",
            "published": 3,
            "tags": [
                "music",
                "visualizer"
            ],
            "usePreview": 0,
            "username": "Dev1ati0n",
            "viewed": 735
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = getBlurred(iChannel1,fragCoord-2.,2);\n    fragColor += getBlurred(iChannel1,fragCoord+vec2(2,-2),2);\n    fragColor += getBlurred(iChannel1,fragCoord+vec2(-2,2),2);\n    fragColor += getBlurred(iChannel1,fragCoord+2.,2);\n    fragColor *= 0.7;\n    fragColor += getBlurred(iChannel1,fragCoord,2);\n    fragColor *= 0.7;\n    fragColor += texelFetch(iChannel1,ivec2(fragCoord),0);\n    fragColor *= 0.01;\n    fragColor += texelFetch(iChannel0,ivec2(fragCoord),0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "int chords[8] = int[8](787,992,884,1180,787,662,884,743);\nint penta[5] = int[5](331,295,263,221,197);\n\nvec2 mainSound( int samp, float time )\n{\n    \n    float mult[5] = float[5](0.0189824329522,0.0212989332447,0.0238904384303,0.0284307027474,0.0318943416608);\n    int loopTime = samp & 16777215;\n    vec2 comp = vec2(0);\n    int note = 0;\n    float oct = 1.;\n    int cyc;\n    float wav;\n    float amp;\n    float nocl;\n    for(int i = 0; i < 21; i++){\n        cyc = loopTime-(penta[note]*(loopTime/penta[note])); // Get phase of wave\n        wav = sin(float(cyc)*mult[note]*oct); // Generate sine wave\n        wav += -0.4*wav*wav*wav; // Apply distortion\n        amp = 1.-fract(float(332+i)*float(loopTime)/16777216.); // Polyrhythm\n        amp *= amp; // Shorten the decay of the note; makes it \"pluckier\"\n        amp *= amp;\n        nocl = clamp(mix(1., amp, 500.),0.,1.); // Very short fade-in to avoid clicking at the starts of notes\n        amp -= nocl;\n        comp += vec2(0.04*amp*wav); // Add to signal\n        note += 1; // Move to next note in scale\n        if(note==5){\n            note = 0; // Loop back to first note in scale\n            oct *= 2.; // Up to next octave\n        }\n    }\n    int beat = loopTime/23831; // Which beat we are currently on\n    float sinceBeat = float(loopTime-beat*23831); // Number of samples since the start of this beat\n    float bassAmp = 1.;\n    \n    // Kick drum\n    if(sinceBeat<5000.&&beat>31){\n        wav = sin((0.007-0.0000003*sinceBeat)*sinceBeat-100./(sinceBeat+40.)); // Sine wave that quickly descreases in pitch\n        wav = 3.*clamp(wav,-0.3,0.3); // Apply distortion\n        amp = 0.000000000016*sinceBeat-0.00000012; // Fade out\n        amp *= sinceBeat*sinceBeat;\n        amp += 1.;\n        nocl = clamp(mix(1., amp, 300000.),0.,1.); // Very short fade-in to avoid clicking at the starts of notes\n        amp -= nocl;\n        comp += 0.15*amp*wav*vec2(1.1,0.9); // Add to signal, panned slightly left\n        bassAmp -= 0.9*amp;\n    }\n    \n    // Hi hat\n    else if(sinceBeat>11915.&&sinceBeat<21915.&&beat>63){\n        wav = random(sinceBeat)-random(sinceBeat-1.); // Blue noise (subtracting the previous sample from the current sample cancels out lower frequencies)\n        amp = 1.-(sinceBeat-11915.)*0.0001; // Fade out\n        amp *= amp;\n        amp *= amp*amp;\n        comp += 0.08*wav*amp*vec2(0.9,1.1); // Add to signal, panned slightly right\n    }\n    \n    int measure = (beat >> 4)-6;\n    \n    // Bass\n    if(beat>95){\n        bassAmp *= clamp(0.002*abs(float(loopTime-((loopTime+190648)/381296)*381296)),0.,1.);\n        \n        note = chords[measure&7]-5;\n        cyc = loopTime-(note*(loopTime/note));\n        wav = abs(4.*float(cyc)/float(note)-2.)-1.;\n        wav *= wav*wav;\n        if((measure&8)>0) wav += wav*wav*wav; wav *= 0.6;\n        comp += 0.08*wav*bassAmp*vec2(0.7,1.3);\n        \n        note = chords[measure&7]+5;\n        cyc = loopTime-(note*(loopTime/note));\n        wav = abs(4.*float(cyc)/float(note)-2.)-1.;\n        wav *= wav*wav;\n        if((measure&8)>0)  wav += wav*wav*wav; wav *= 0.6;\n        comp += 0.08*wav*bassAmp*vec2(1.3,0.7);\n    }\n    return vec2( comp );\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "// Random function stolen from here: https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\nvec4 getBlurred( sampler2D image, vec2 coord , int blurAmount ){\n    ivec2 bottomLeft = (ivec2(coord)-(1<<(blurAmount-1)))>>blurAmount;\n    vec4 a = texelFetch(image,bottomLeft,blurAmount);\n    vec4 b = texelFetch(image,bottomLeft+ivec2(1,0),blurAmount);\n    vec4 c = texelFetch(image,bottomLeft+ivec2(0,1),blurAmount);\n    vec4 d = texelFetch(image,bottomLeft+ivec2(1,1),blurAmount);\n    \n    vec2 offset = (coord/float(1<<blurAmount)) - vec2(bottomLeft);\n    offset -= 0.5;\n    //offset *= (3.-2.*offset)*offset;\n    vec4 l = mix(a,c,offset.y);\n    vec4 r = mix(b,d,offset.y);\n    return mix(l,r,offset.x);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec4 penta[5] = vec4[5](vec4(1,0.42,0.42,1),vec4(0.93,0.72,0,1),vec4(0,0.92,0.63,1),vec4(0,0.8,1,1),vec4(0.9,0.53,1,1));\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float constraint = min(iResolution.x,iResolution.y);\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/constraint;\n    float dist = sqrt(dot(uv,uv)); // Distance from center\n    float ang = atan(uv.x,uv.y); // Angle from top center of screen (clockwise=positive, counterclockwise=negative)\n    fragColor = vec4(0.1);\n    fragColor.rgb -= 0.01*dist*dist*dist+0.0015*random(fragCoord); // Vignette with dithering\n    float ring = round(dist*55.-5.);\n    if(ring>-0.5&&ring<20.5){\n        int note = int(ring);\n        note -= 5*(note/5); // Get which note in the scale this ring represents (determines its color)\n        float center = ring*0.0181818+0.09090909;\n        float cyc = fract(0.00262856483459*iTime*(332.+ring))*6.28318530718+ang;\n        if(cyc>6.28318530718){cyc -= 6.28318530718;}\n        if(cyc<0.){cyc += 6.28318530718;}\n        if(cyc<1./(dist*constraint)){cyc *= 1. - dist*constraint; cyc += 1.;}\n        else{cyc *= center + .5;}\n        cyc = clamp(cyc,0.,1.);\n        vec4 bg = vec4(0.05);\n        vec4 head = mix(penta[note],vec4(0),-1.+clamp(fract(0.00262856483459*iTime*(332.+ring))*6.28318530718,0.,1.));\n        vec4 ringCol = mix(head,bg,cyc);\n        \n        float off = abs(dist-center);\n        fragColor = mix(ringCol,fragColor,clamp((off-0.006)*constraint,0.,1.)); // Anti-aliasing\n        \n        for(float i = ring; i < 21.; i++){\n            cyc = fract(0.00262856483459*iTime*(332.+i))*6.28318530718+ang;\n            if(cyc>3.1415926536){cyc -= 6.28318530718;}\n            if(cyc<-3.1415926536){cyc += 6.28318530718;}\n            cyc = 1.-clamp(abs(cyc*dist)*10.,0.,1.);\n            cyc *= cyc;\n            cyc *= cyc;\n            cyc *= cyc;\n            cyc *= cyc;\n            cyc *= cyc;\n            cyc *= clamp((dist-0.083)*200.,0.,1.);\n            if(i == ring){cyc *= clamp((center-dist+0.008)*100.,0.,1.);}\n            fragColor += 0.3*vec4(cyc);\n        }\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor -= 0.2;\n    fragColor = max(fragColor,0.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor  = getBlurred(iChannel0,fragCoord+vec2(0, 4),1);\n    fragColor += getBlurred(iChannel0,fragCoord+vec2(0,-4),1);\n    fragColor += getBlurred(iChannel0,fragCoord+vec2( 4,0),1);\n    fragColor += getBlurred(iChannel0,fragCoord+vec2(-4,0),1);\n    fragColor *= 0.7;\n    fragColor += getBlurred(iChannel0,fragCoord-2.,1);\n    fragColor += getBlurred(iChannel0,fragCoord+vec2(2,-2),1);\n    fragColor += getBlurred(iChannel0,fragCoord+vec2(-2,2),1);\n    fragColor += getBlurred(iChannel0,fragCoord+2.,1);\n    fragColor *= 0.7;\n    fragColor += getBlurred(iChannel0,fragCoord,2);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor  = getBlurred(iChannel0,fragCoord+vec2(0, 4),1);\n    fragColor += getBlurred(iChannel0,fragCoord+vec2(0,-4),1);\n    fragColor += getBlurred(iChannel0,fragCoord+vec2( 4,0),1);\n    fragColor += getBlurred(iChannel0,fragCoord+vec2(-4,0),1);\n    fragColor *= 0.7;\n    fragColor += getBlurred(iChannel0,fragCoord-2.,1);\n    fragColor += getBlurred(iChannel0,fragCoord+vec2(2,-2),1);\n    fragColor += getBlurred(iChannel0,fragCoord+vec2(-2,2),1);\n    fragColor += getBlurred(iChannel0,fragCoord+2.,1);\n    fragColor *= 0.7;\n    fragColor += getBlurred(iChannel0,fragCoord,1);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}