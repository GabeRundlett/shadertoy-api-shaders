{
    "Shader": {
        "info": {
            "date": "1586404606",
            "description": "Here's a raytracer I wrote which is a GLSL version of a trimmed down C version of my C raytracer (trimmed down version was the basis for my assembly language versions (my own CPU design and x86)) - except no reflection/refraction (no recursion in GLSL).",
            "flags": 0,
            "hasliked": 0,
            "id": "wdBcWR",
            "likes": 0,
            "name": "My First Simple Raytracer Shader",
            "published": 3,
            "tags": [
                "raytracer",
                "animation"
            ],
            "usePreview": 0,
            "username": "mrmcsoftware",
            "viewed": 339
        },
        "renderpass": [
            {
                "code": "//#version 130\n//#extension GL_EXT_gpu_shader4 : enable\n//#define GAMMAC 1.0/2.2   // Uncomment this line to apply gamma correction\n#define SPEED 4.0  // speed adjustment - MODIFY AS NEEDED\n\n#define SMALL .001\n#define SMALL3 .000001\n\n#define SPHERE 0\n#define PLANE 1\n#define LIGHT 2\n\nstruct Ray\n\t{\n\tvec3 p;\n\tvec3 v;\n\t};\n\nstruct Rgb\n\t{\n\tfloat r,g,b;\n\t};\n\nstruct View\n\t{\n\tvec3 e,a,u;\n\t};\n\nstruct Light\n\t{\n\tvec3 p;\n\tfloat k,dist,r;\n\tRgb i;\n\t};\n\nstruct Info\n\t{\n\tvec3 v1,v2,v3,v4;\n\tfloat f1,f2,f3;\n\t};\n\nstruct Object\n\t{\n\tint type,id;\n\tRgb amb,diff,spec,tran;\n\tfloat ka,ks,kd,kn,kr,kt,n;\n\tInfo info;\n\t};\n\nstruct Hit\n\t{\n\tObject object;\n\tvec3 normal,pt;\n\tfloat t;\n\tRgb col;\n\t};\n\n#define MAXFLOAT\t3.37E+38\n\nView V;\nint xres,yres;\nint CXc,CYc,xc,yc;\nRgb bg=Rgb(0.0,0.0,0.0),ambient;\nint numlights=0;\nLight light[2];\nint numobj=0;\nObject objs[10];\nint maxlevel=0; // fix it (can't do recursion in GPU)\nfloat ka=.15,ks=.10,kd=.415,kn=8.0,kr=0.0,textoff=32.0,gn=1.0,ior,kt=0.0;\nRgb diff,spec,tran;\nHit hit;\nvec3 pol[3];\nfloat flengthx=1150.0,flengthy=1150.0,min_weight=.05;\nvec3 dir,right;\nInfo infoblank;\nRgb gat;\nfloat gt;\nvec3 gpt;\n\nRgb trace(Ray,int);\nvoid pushobj(int,Info);\n\n/* I'll use GLSL's functions instead, but these do work */\n/*\n\nfloat Dot(vec3 v1,vec3 v2)\n{\nfloat f;\n\nf=v1.x*v2.x+v1.y*v2.y+v1.z*v2.z;\nreturn(f);\n}\n\nfloat Mag(vec3 v1)\n{\nfloat d;\n\nd=sqrt(v1.x*v1.x+v1.y*v1.y+v1.z*v1.z);\nreturn(d);\n}\n\nvec3 Normalize(vec3 v1)\n{\nfloat d;\nvec3 res;\n\nd=sqrt(v1.x*v1.x+v1.y*v1.y+v1.z*v1.z);\nres.x=v1.x/d;\nres.y=v1.y/d;\nres.z=v1.z/d;\nreturn(res);\n}\n\nvec3 CrossProduct(vec3 v2,vec3 v3)\n{\nvec3 res;\n\nres.x=v2.y*v3.z-v2.z*v3.y;\nres.y=v2.z*v3.x-v2.x*v3.z;\nres.z=v2.x*v3.y-v2.y*v3.x;\nreturn(res);\n}\n\n*/\n\nbool sphereinter(Object obj,Ray ray)\n{\nfloat a,b,c,d,spht0,spht1,t;\nvec3 P;\n\nP=ray.p-obj.info.v1;\nc=dot(P,P)-obj.info.f1*obj.info.f1;\nb=2.0*dot(ray.v,P);\na=dot(ray.v,ray.v);\nd=b*b-4.0*a*c;\nif (d<=0.0) { return(false); }\nd=sqrt(d);\nif (a==0.0) { return(false); }\nspht0=(-b+d)/(a+a);\nspht1=(-b-d)/(a+a);\nif ((spht1<spht0)&&(spht1>SMALL)) t=spht1;\nelse t=spht0;\nif (t>SMALL)\n\t{\n\tgpt=P+t*ray.v;\n\tgt=t;\n\treturn(true);\n\t}\nreturn(false);\n}\n\nvec3 spherenorm(Object obj,Ray ray)\n{\nvec3 n,pt;\n\nn=gpt;\ngpt+=obj.info.v1;\nn=normalize(n);\nreturn(n);\n}\n\nbool triinter(Object obj,Ray ray)\n{\nfloat in1,in2,f1,t;\n\nf1=dot(obj.info.v3,ray.v);\nif (abs(f1)<SMALL) return(false);\nin1=obj.info.f3;\nin2=dot(obj.info.v3,ray.p);\nt=(in1-in2)/f1;\nif (t<SMALL) return(false); /* ?? */\ngpt=ray.p+t*ray.v;\nreturn(true);\n}\n\nvec3 trinorm(Object obj,Ray ray)\n{\nvec3 n,pt;\n\nreturn(obj.info.v3);\n}\n\nvoid planarobj(int t)\n{\nInfo info;\n\ninfo=infoblank;\ninfo.v1=pol[1]-pol[0];\ninfo.v2=pol[2]-pol[0];\ninfo.v3=cross(info.v1,info.v2);\ninfo.v3=normalize(info.v3);\ninfo.v4=pol[0];\ninfo.f1=dot(info.v1,info.v1);\ninfo.f2=dot(info.v2,info.v2);\ninfo.f3=dot(info.v3,info.v4);\npushobj(t,info);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\nInfo info;\nfloat r,g,b;\nRay eye_ray;\nfloat xf,yf;\nRgb col;\n\nnumobj=0;\nV.a=vec3(0,0,0);\nV.e=vec3(1,10,20);\nV.u=vec3(0,1,0);\nCXc=(xres/2); CYc=(yres/2);\ndir=V.a-V.e;\ndir=normalize(dir);\nright=cross(V.u,dir);\nright=normalize(right);\nV.u=cross(dir,right);\nV.u=normalize(V.u);\n\n\t/* magenta sphere */\nka=.1; ks=0.0; kd=.6; kn=40.0; ambient=Rgb(.99,.99,.99);\nspec=Rgb(255.0,255.0,255.0);\nks=.5;\ninfo.v1=vec3(1.0,1.0,0.0); info.f1=1.0;\ndiff=Rgb(255.0,0.0,255.0);\nkr=.5;\npushobj(SPHERE,info);\n\t/* green sphere */\nks=0.0;\ninfo.v1=vec3(-1.0,1.0,2.0);\ndiff=Rgb(0.0,255.0,0.0);\nkt=1.0; /*.58;*/ ior=1.75; kd=.07; ks=.4; kr=.26; /*0;*/ /*.1;*/ kn=100.0;\ntran=Rgb(0.0,255.0,0.0);\nka=0.0;\n/* adjust to no refraction possible */\nkt=0.0; ka=.1; kd=.6;\npushobj(SPHERE,info);\n\t/* yellow sphere */\nkt=0.0; kd=.6; ks=0.0; /*.5;*/ kr=.5; kn=40.0;\nka=.1;\ninfo.v1=vec3(.75,1.0,3.25);\ndiff=Rgb(255.0,255.0,0.0);\npushobj(SPHERE,info);\n\t/* light 1 */\nlight[numlights].p=vec3(-2.0,6.0,8.0);\nlight[numlights].i=Rgb(.2,.2,.2);\nlight[numlights].k=0.0; light[numlights].dist=9.0; light[numlights].r=.25;\n//normalize(light[numlights].p); light[numlights].r=0;\ninfo.v1=light[numlights].p;\ninfo.f1=light[numlights].r;\npushobj(LIGHT,info);\nnumlights++;\n\t/* light 2 */\nlight[numlights].p=vec3(2.0,8.0,7.0);\nlight[numlights].i=Rgb(.99,.99,.99);\nlight[numlights].k=0.0; light[numlights].dist=9.0; light[numlights].r=.25;\n//normalize(light[numlights].p); light[numlights].r=0;\ninfo.v1=light[numlights].p;\ninfo.f1=light[numlights].r;\npushobj(LIGHT,info);\nnumlights++;\n\t/* plane */\ndiff=Rgb(255.0,255.0,255.0); ks=.8; kd=.4;\npol[0]=vec3(0.0,0.0,0.0);\npol[1]=vec3(0.0,0.0,1.0);\npol[2]=vec3(1.0,0.0,0.0);\n//kr=0;\nplanarobj(PLANE);\n\n\t/* adjust movements through time */\nfloat iGlobalTime=iTime-1.0;\nif (iGlobalTime<0.0) { iGlobalTime=0.0; }\niGlobalTime*=SPEED;\n//iGlobalTime=0.0;\nobjs[0].info.v1+=vec3(0,0,(iGlobalTime)*.2);\nobjs[1].info.v1+=vec3((iGlobalTime)*-.1,0,0);\nobjs[2].info.v1+=vec3((iGlobalTime)*.2,0,0);\nlight[1].p+=vec3((iGlobalTime)*-1.0,0,0);\n\nCXc=int(iResolution.x/2.0);\nCYc=int(iResolution.y/2.0);\nvec2 q=fragCoord.xy;\nq.y=iResolution.y-q.y-1.0;\nxc=int(q.x); yc=int(q.y);\nflengthx=flengthy=iResolution.y/1.5*750.0/256.0;\n//flengthx=flengthy=150.0/256.0*5.0;\nxf=float(CXc-xc)/flengthx;\nyf=float(CYc-yc)/flengthy;\neye_ray.v=dir+xf*right+yf*V.u;\neye_ray.p=V.e;\ncol=trace(eye_ray,0);\nr=clamp(col.r/255.0,0.0,1.0);\ng=clamp(col.g/255.0,0.0,1.0);\nb=clamp(col.b/255.0,0.0,1.0);\n#ifdef GAMMAC\nr=pow(r,GAMMAC);\ng=pow(g,GAMMAC);\nb=pow(b,GAMMAC);\n#endif\nfragColor=vec4(r,g,b,1);\n}\n\nfloat shadow(Object obj,vec3 p,vec3 vv,float vd)\n{\nRay v;\nfloat t;\nint j;\nbool i;\n\nv.p=p;\nv.v=vv;\nfor (j=0;j<numobj;j++)\n\t{\n\tObject ptr=objs[j];\n\tif ((ptr.id!=obj.id)&&(ptr.type!=LIGHT)&&(ptr.type!=PLANE))\n\t\t{\n\t\tif (ptr.type==SPHERE) { i=sphereinter(ptr,v); }\n\t\telse { i=false; }\n\t\tif (i)\n\t\t\t{\n\t\t\tif (t<vd)\n\t\t\t\t{\n\t\t\t\tif (ptr.kt<min_weight) { return(0.0); }\n\t\t\t\tgat.r*=ptr.kt*ptr.tran.r/255.0;\n\t\t\t\tgat.g*=ptr.kt*ptr.tran.g/255.0;\n\t\t\t\tgat.b*=ptr.kt*ptr.tran.b/255.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nreturn(1.0);\n}\n\nRgb shade(Ray ray,Object obj,vec3 N,vec3 pt,int level)\n{\nRgb color,dcol;\nfloat t2,f;\nfloat t,t3;\nint i;\nvec3 L,ipoint;\nRay R,T;\nfloat light_dist=0.0; /* ?? */\nRgb at;\n\ndcol=hit.col;\nipoint=pt;\nif (obj.type==LIGHT) { color.r=color.g=color.b=0.0; return(color); }\ncolor.r=obj.ka*obj.amb.r*dcol.r;\ncolor.g=obj.ka*obj.amb.g*dcol.g;\ncolor.b=obj.ka*obj.amb.b*dcol.b;\n\nfor (i=0;i<numlights;i++)\n\t{\n\tL=light[i].p-pt;\n\tlight_dist=length(L);\n\tL=normalize(L);\n\tf=dot(N,L);\n\tgat.r=gat.g=gat.b=1.0;\n\tif (shadow(obj,pt,L,light_dist)>0.0)\n\t\t{\n\t\tt3=light[i].dist/(light_dist+light[i].k);\n\t\tif ((f>0.0)||(obj.kt>min_weight))\n\t\t\t{\n\t\t\tt=t3*f*obj.kd;\n\t\t\tif ((obj.kt>min_weight)&&(f<0.0)) { t=-t; }\n\t\t\tcolor.r+=light[i].i.r*dcol.r*t*gat.r;\n\t\t\tcolor.g+=light[i].i.g*dcol.g*t*gat.g;\n\t\t\tcolor.b+=light[i].i.b*dcol.b*t*gat.b;\n\t\t\tt2=2.0*f;\n\t\t\tR.v=t2*N-L;\n\t\t\tt2= -dot(R.v,ray.v);\n\t\t\tif (t2>0.0)\n\t\t\t\t{\n\t\t\t\tt2=t3*pow(t2,obj.kn)*obj.ks;\n\t\t\t\tcolor.r+=light[i].i.r*obj.spec.r*t2*gat.r;\n\t\t\t\tcolor.g+=light[i].i.g*obj.spec.g*t2*gat.g;\n\t\t\t\tcolor.b+=light[i].i.b*obj.spec.b*t2*gat.b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nif (level<maxlevel)\n\t{\n\tif (obj.kr>min_weight)\n\t\t{\n\t\tRgb spcolor;\n\n\t\tf= -2.0*dot(N,ray.v);\n\t\tR.v=f*N+ray.v;\n\t\tR.p=pt+SMALL3*R.v;\n\t\t//spcolor=trace(R,level+1); // fix it (can't do recursion in GPU)\n\t\tcolor.r+=obj.kr*spcolor.r;\n\t\tcolor.g+=obj.kr*spcolor.g;\n\t\tcolor.b+=obj.kr*spcolor.b;\n\t\t}\n\tif (obj.kt>min_weight)\n\t\t{\n\t\tRgb spcolor;\n\t\tfloat n;\n\n\t\tf=dot(N,ray.v);\n\t\tif (f<0.0) { n=gn/obj.n; f= -f; }\n\t\telse { n=obj.n/gn; N=-N; }\n\t\tt=n*f;\n\t\tt3=1.0-n*n*(1.0-f*f);\n\t\tif (t3<0.0) // TIR\n\t\t\t{\n\t\t\tf= -2.0*dot(N,ray.v);\n\t\t\tR.v=f*N+ray.v;\n\t\t\tR.p=ipoint+SMALL3*R.v;\n\t\t\t//spcolor=trace(R,level+1);  // fix it (can't do recursion in GPU)\n\t\t\tcolor.r+=obj.kt*spcolor.r*dcol.r/255.0;\n\t\t\tcolor.g+=obj.kt*spcolor.g*dcol.g/255.0;\n\t\t\tcolor.b+=obj.kt*spcolor.b*dcol.b/255.0;\n\t\t\treturn(color);\n\t\t\t}\n\t\tt2=t-sqrt(t3);\n\t\tT.v=t2*N+n*ray.v;\n\t\tT.p=ipoint+SMALL3*T.v;\n\t\t//spcolor=trace(T,level+1);  // fix it (can't do recursion in GPU)\n\t\tcolor.r+=obj.kt*spcolor.r*dcol.r/255.0;\n\t\tcolor.g+=obj.kt*spcolor.g*dcol.g/255.0;\n\t\tcolor.b+=obj.kt*spcolor.b*dcol.b/255.0;\n\t\t}\n\t}\nreturn(color);\n}\n\nbool intersect(Ray ray)\n{\nObject ptr,p;\nint j;\nbool inter=false,i=false;\nfloat t;\nvec3 pt,gpts;\nfloat mint=MAXFLOAT;\nRgb col,colm;\n\nfor (j=0;j<numobj;j++)\n\t{\n\tptr=objs[j];\n\tif (ptr.type==SPHERE) { i=sphereinter(ptr,ray); }\n\telse if (ptr.type==PLANE) { i=triinter(ptr,ray); }\n\telse { i=false; }\n\tif (i)\n\t\t{\n\t\tinter=true;\n\t\tif (gt<mint)\n\t\t\t{\n\t\t\tp=ptr; mint=gt; gpts=gpt;\n\t\t\tcolm=ptr.diff;\n\t\t\t}\n\t\t}\n\t}\nif (inter)\n\t{\n\thit.object=p;\n\thit.t=mint;\n\tgpt=gpts;\n\tif (p.type==SPHERE) { hit.normal=spherenorm(p,ray); }\n\telse if (p.type==PLANE) { hit.normal=trinorm(p,ray); }\n\thit.pt=gpt;\n\tif (p.type==PLANE)\n\t\t{\n\t\tint ibx,ibz;\n\n\t\tibx=int(gpt.x+textoff);\n\t\tibz=int(gpt.z+textoff);\n\t\tif (((ibx+ibz)%2)==1) { colm.r=colm.g=colm.b=128.0; }\n\t\telse { colm.r=colm.g=colm.b=255.0; }\n\t\t}\n\thit.col=colm;\n\t}\nreturn(inter);\n}\n\nRgb trace(Ray ray,int level)\n{\nvec3 pt,N;\nObject obj;\n\nray.v=normalize(ray.v);\nif (intersect(ray))\n\t{\n\tobj=hit.object;\n\tN=hit.normal;\n\tpt=hit.pt;\n\treturn(shade(ray,obj,N,pt,level));\n\t}\nelse\n\t{\n\treturn(bg);\n\t}\n}\n\nvoid pushobj(int type,Info info)\n{\nobjs[numobj].id=numobj;\nobjs[numobj].type=type;\nif (type!=LIGHT)\n\t{\n\tobjs[numobj].ka=ka;\n\tobjs[numobj].ks=ks;\n\tobjs[numobj].kd=kd;\n\tobjs[numobj].kn=kn;\n\tobjs[numobj].kr=kr;\n\tobjs[numobj].kt=kt;\n\tobjs[numobj].n=ior;\n\tobjs[numobj].diff=diff;\n\tobjs[numobj].tran=tran;\n\tobjs[numobj].amb.r=ambient.r;\n\tobjs[numobj].amb.g=ambient.g;\n\tobjs[numobj].amb.b=ambient.b;\n\tobjs[numobj].spec=spec;\n\t}\nobjs[numobj].info=info;\nnumobj++;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}