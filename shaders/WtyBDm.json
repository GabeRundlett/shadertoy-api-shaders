{
    "Shader": {
        "info": {
            "date": "1614419077",
            "description": "variant preserving drawing (but limited bound)\nreproducing [url]https://joshdata.me/iceberger.html[/url] Using smart MIPmaps.\nDraw iceberg (TAB to erase).    SPACE to start/pause the physics.\nRed dot = center of mass, \nGreen dot = immerged center of mass.",
            "flags": 48,
            "hasliked": 0,
            "id": "WtyBDm",
            "likes": 5,
            "name": "iceberger 3 - object space",
            "published": 3,
            "tags": [
                "simulation",
                "physics",
                "reproduction",
                "gpmipmap",
                "iceberger"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 418
        },
        "renderpass": [
            {
                "code": "// reference-space variant of https://shadertoy.com/view/3tGfzW\n// power-of-2 variant of \"iceberger\" https://shadertoy.com/view/tlKfzz\n// ( otherwise MIPmap is way to bugged )\n// reproducing https://joshdata.me/iceberger.html\n\nvoid mainImage( out vec4 O, vec2 U )\n{ \n    U = 1024.*( .56* ( U - L*iResolution.xy ) / iResolution.y + L );\n    O = T2(U).x - T2(U).y *vec4(.3,.3,-1,0); \n      \n    O = mix(O, vec4(1,0,0,0), D( G.xy, 10.) );\n    O = mix(O, vec4(0,1,0,0), D( G.zw, 10.) );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define L              vec2(.5,.7)\n#define R              vec2(1024) // iResolution.xy\n#define dt            ( .5*iTimeDelta )\n#define T(U)           texture( iChannel0, vec3( 2.*(U)/R -1., 1 ).xzy )\n#define T1(U)          texture( iChannel0,(vec3( 2.*(U)/R -1., 1 )*vec3( 1,-1,-1)).xzy )\n#define T2(U)          texture( iChannel0,(vec3( 2.*(U)/R -1., 1 )*vec3(-1,-1, 1)).zyx )\n#define M            ( textureLod(iChannel0,vec3(1, 0, 0) , 20.) +1e-9 ) // total mass\n#define G              textureLod(iChannel0,vec3(0,-1, 0) , 20.)         // center of mass\n#define D(C,r)         smoothstep( 1.5, 0., length(C-U) - r )            // antialiased disk\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define rot(a)         mat2( cos(a), -sin(a), sin(a), cos(a) )",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// transform Word coords to Object coords.  T(.5).zw = trans.y, rot \n#define transform(V) ( ( V-G.xy ) * rot( T(.5).w ) + G.xy - vec2(0,T(.5).z) )\n\nvoid mainCubemap( out vec4 O, vec2 U, vec3 o, vec3 D )\n{\n    vec3 A = abs(D);\n    if (D.y > max(A.x,A.z)) {       // --- side 1 -------------\n                                                            // O.x = iceberg\n        O = T(U);                                           // previous step \n        if ( U.x < 2. && U.y < 2.) {\n            vec3 F = keyToggle(32.)                         // --- physics \n                // ? G.zww - G.xyy*vec3(1,1,.95) : vec3(0); // torque+force applying on the iceberg\n                   ? vec3(G.z - G.x,-.1*M.z/M.x*.1*R.y, -(.9 - M.z/M.x)*4.*R.y) : vec3(0); // correct physics\n            F.x = sign(F.x) * max(0., abs(F.x)-2.);         // stabilizer (because delayed reaction)\n            if (U.x>1.)\n                O.z = .98*O.z + F.z*dt,                     // vertical velocity\n                O.w = .98*O.w + F.x*F.y*dt*dt;              // angular velocity\n            else\n                O.zw += T(1.5).zw*dt;                       // vertical position; rotation\n        } \n   \n        vec2 s = iChannelResolution[1].xy,                  // screen resolution\n             m = 1024.*( .56* ( iMouse.xy - L*s ) / s.y + L ); // transform screen to 1024x1024 cubemap coords\n        m = transform(m);                                   // transform mouse to object frame \n        if (iMouse.z>0.)                                    // --- paint\n               O.x = keyToggle(9) \n                       ? max( 0., O.x - D( m, .05*R.y ) )   // erase iceberg\n                       : max(O.x,       D( m, .05*R.y ) );  // paint iceberg\n\n     // U = R-1.-abs(2.*U-R); if (U.x*U.y<.5) O.x = 0.;     // clamp paint\n    }\n    else if (-D.y >  max(A.x,A.z)) { // --- side 2 -------------\n    \n    // ultimate MIPmap of O.xy = center of mass\n    // ultimate MIPmap of O.zw = immerged center of mass\n                                                            // --- physics ( rot+translate transforms )\n                                                            // redond side 3 to avoid loosing 1 frame\n        vec2 V = transform(U);\n        O.x = T(V).x;                                       // object transformed by physics ( rot+translate )\n        O.y = step( U.y/R.y , L.y );                        // ocean\n        O.z = O.x*O.y;                                      // immerged part of the iceberg    \n        O /= M;                                             // density field\n\n        O.xy = O.x * U;     // prepare spatial moments of iceberg shape (total vs immerged)\n        O.zw = O.z * U;\n    }\n\n    else if ( D.x >  max(A.y,A.z)) { // --- side 3 -------------\n    // O.x = iceberg, O.y = ocean, O.z = immerged iceberg.  \n    // Ultimate MIPmap = mass (i.e., volume )\n                                                            // --- physics ( rot+translate transforms )\n        vec2 V = transform(U);\n        O.x = T(V).x;                                       // object transformed by physics ( rot+translate )\n        O.y = step( U.y/R.y , L.y );                        // ocean\n        O.z = O.x*O.y;                                      // immerged part of the iceberg    \n    }\n    \n    if (iFrame<1) O=vec4(0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "// guess what is the purpose of this buffer ;-)\nvoid mainImage( out vec4 O, vec2 U ) {}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}