{
    "Shader": {
        "info": {
            "date": "1728046961",
            "description": "Covering a plane with crosses, then subdividing them through opposite inner vertices to create a single non-convex heptagon tiling of the Euclidean plane.",
            "flags": 0,
            "hasliked": 0,
            "id": "MX2yWV",
            "likes": 21,
            "name": "Half Cross Heptagon Pattern",
            "published": 3,
            "tags": [
                "2d",
                "polygon",
                "cross",
                "tile",
                "septagon",
                "heptagon"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 115
        },
        "renderpass": [
            {
                "code": "/*\n    \n    Half Cross Heptagon Pattern\n    ---------------------------\n    \n    Covering a plane with crosses, then subdividing them through opposite \n    inner vertices to create a single non-convex heptagon tiling of the \n    Euclidean plane.\n    \n    It might be more obvious to others, but when I first encountered one \n    of these non-convex heptagon patterns, it took me ages to realize that \n    it was just a reimagining of tiled, rotated crosses that were cut in \n    half. In fact, once you realize this, the pattern loses a bit of its \n    mystique. However, I haven't seen one posted on Shadertoy before, and \n    it still looks interesting to me, so I figured I'd post it anyway. :)\n    \n    As an aside, I tend to prefer the term \"septagon\", which I think is a \n    misusage of latin and Greek to describe a seven sided object, but I'm \n    pretty sure that heptagon is more preferred technical term.\n    \n    There's not much to say about the pattern construction: Tile the plane \n    with Greek style crosses (any dimensions), then subdivide them through \n    opposite inner vertices. The details are below.\n    \n    By the way, I have a 3D traversal version of this pattern that I'll \n    post pretty soon.\n    \n    \n    \n    Other examples:\n    \n    // If you exclude some of the hyperbolic Poincare posting,\n    // heptagon based examples are few and far between on Shadertoy.\n    // Here's one that I'd forgotten I'd written.\n    Heptagon-Pentagon Tiling - Shane\n    https://www.shadertoy.com/view/wtByzh\n\n*/\n\n// Looking at a visual of a repeat grid that produces a pattern can be very \n// helpful. In fact, patterns are often difficult to decipher without one.\n//#define GRID\n\n\n// Pattern type -  Crosses: 0, Heptagons: 1.\n#define PATTERN 1\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n    \n    uvec2 p = floatBitsToUint(f + 512.);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n// Signed distance to a line passing through A and B.... Not a proper\n// signed line distance function, but it works for many things.\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\n\n\n// IQ's cross distance field.\n//\n// Signed distance to a 2D cross. Produces exact exterior and\n// bound interior distance.\n//\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\nfloat sdCross(in vec2 p, in vec2 b, float r){ \n\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    \n\tvec2  q = p - b;\n    float k = max(q.y, q.x);\n    vec2  w = (k>0.) ? q : vec2(b.y - p.x, -k);\n    float d = length(max(w, 0.));\n    return ((k>0.)? d: -d) + r;\n}\n\n\n// Global scale and local coordinates.\nvec2 gSc = vec2(1)/4.;\n//vec2 gP; // Not used here.\n\nvec4 pattern(vec2 p){\n    \n    \n    // Overall coordinates and scale.\n    vec2 sc = gSc;\n    \n    // The cross has thickness, one third of the height, which is evident from\n    // the imagery. If you turn on the grid settings, you'll see that a one to\n    // three ratio triangle is involved, etc.\n    // Cross rotation angle.\n    float a = atan(1., 3.);\n    // Cross height: This follows from the above. Feel free to get out a pen and\n    // paper, or you could take a lazy coder's word for it. :D\n     float ht = sqrt(9./10.);//cos(a);//\n    //a = acos(ht);\n    // The width needs to be one third of the height in order for two equal size\n    // crosses to tile the plane.\n    vec2 si = sc*vec2(ht, ht/3.)/2.;\n    \n    // Cross ID. Only two crosses are needed to tile the plane.\n    int crossID = 0;\n    // Each cross can be subdivided into two septagons.\n    int polyID = 0;\n    \n    \n    // Square grid setup. Cell ID and local coordinates.\n    vec2 q = p;\n    vec2 iq = floor(q/sc) + .5;\n    q -= (iq)*sc;\n    \n    // Matrix to rotate the crosses.\n    mat2 m = rot2(a);\n    \n    float rF = .072*sc.x; // Polygon rounding factor.\n     \n    // The first cross.\n    //\n    // Render a slightly rounded cross using IQ's cross distance field function.\n    // As an aside, if cell traversing, you'd test again a cross bound, rather\n    // than a distance field version.\n    float d2 = sdCross(m*q, si - rF, -rF);\n    float d = d2; // Overal distance set to the first cross.\n    vec2 id = iq; // First cross ID.\n    vec2 lP = q; // The cross is rotated, but the local space is not.\n    \n    // Next cross.\n    q = p - sc/2.; //vID[2]*sc\n    iq = floor(q/sc) + .5;\n    q -= (iq)*sc;\n \n    // The second cross.\n    d2 = sdCross(m*q, si - rF, -rF);\n    \n    // See if this cross is closer, and update, if necessary.  \n    if(d2<d){\n       d = d2;\n       id = iq + .5;\n       lP = q;\n       crossID = 1;\n    }\n    \n    // Individual cross position based ID.\n    vec2 cID = id;\n    \n  \n    #if PATTERN != 0\n\n    // Original cell vertex and mid-edge IDs. I could streamline this, but\n    // it's working, so I'll leave it alone.\n    const mat4x2 vID = mat4x2(vec2(-.5), vec2(-.5, .5), vec2(.5), vec2(.5, -.5));\n    const mat4x2 eID = mat4x2(vec2(-.5, 0), vec2(0, .5), vec2(.5, 0), vec2(0, -.5));\n   \n    // Starting cross dividing line vertex index.\n    int n0 = hash21(id)>.5? 0 : 1;\n    //int n0 = mod(floor(floor(cID.x)) + floor(floor(cID.y)*2.), 2.)==0.? 0 : 1;\n \n    // Half cross dividing line. There are a few ways to divide a 2D distance\n    // field, but this is my \"go to\".\n    float divLn = distLineS(m*lP, vID[(n0 + 2)%4], vID[n0%4]);\n    int n;\n    if(divLn<0.){\n        // Heptagon 1.\n        d = smax(d, divLn, .007); // Smooth maximum, for a bit of rounding.\n        polyID = 0;\n        n = n0;\n    }\n    else{\n        // Heptagon 2.\n        d = smax(d, -divLn, .007);\n        polyID = 1;\n        n = n0 + 2;\n    }\n\n    \n    // Update the position based ID.\n    id += vID[(n + 1)%4]/6.;\n    \n    \n    // Strategic vertex and edge based holes. Originally for debugging,\n    // but they have an interesting aesthetic, so I kept some around. :)\n    \n    float hSz = .02*sc.x; // Hole size.\n    //d = max(d, -(length(m*lP - vID[(n + 1)%4]*sc/6.) - hSz));\n\n    if(hash21(id + .23)<.35){\n        d = max(d, -(length(m*lP - eID[n]*sc/1.732) - hSz));\n        d = max(d, -(length(m*lP - eID[(n + 1)%4]*sc/1.732) - hSz));\n    } \n   \n    #endif\n    \n    // Not actually used for this example, but needed for others.\n    //gP = m*lP; // Rotating the local coordinates to match the rotated crosses.\n    \n    // Distance, cross and pentagon ID, and cell ID.\n    return vec4(d, crossID*2 + polyID, id);\n}\n\n\nfloat gridField(vec2 p){\n    \n    vec2 sc = gSc;\n    vec2 ip = floor(p/sc);\n    p -= (ip + .5)*sc;\n    \n    p = abs(p) - .5*sc;\n    float grid = abs(max(p.x, p.y)) - .007*sc.x;\n    \n    return grid;\n}\n\n\n// A very simple random line routine. It was made up on the\n// spot, so there would certainly be better ways to do it.\nfloat randLines(vec2 p){\n    \n    // Scaling.\n    float sc = 16./gSc.x;\n    p *= sc;\n    \n    // Offset the rows for a more random look.\n    p.x += hash21(vec2(floor(p.y), 7) + .2)*sc;\n    \n    // Cell ID and local coordinates.\n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    // Distance field value and random cell number.\n    float d;\n    float rnd = hash21(ip + .34);\n    \n    // Randomly, but not allowing for single dots.\n    if(rnd<.333 && mod(ip.x, 2.)==0.){\n    \n       // Dots on either side of the cell wall mid-points, to create a space.\n       d = min(length(p - vec2(-.5, 0)), length(p - vec2(.5, 0)));\n        \n    }\n    else {\n        // Otherwise, just render a line that extends beyond the cell wall\n        // mid-points.\n        d =  abs(distLineS(p, vec2(-1, 0), vec2(1, 0)));\n    }\n    \n    // Applying some width.\n    d -= 1./6.;\n    \n    // Scaling down the distance value to match scaling up\n    // the coordinates.\n    return d/sc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Fake distortion. The UV coordinates have been reexpanded along X\n    // to fill up the screen length.\n    vec2 uv2 = uv*vec2(iResolution.y/iResolution.x, 1.);\n    uv *= 1. + (dot(uv2, uv2) - .5)*.2;\n    \n    // Scaling, smoothing factor and translation.\n    float gSc = 1.;\n    float sf = gSc/iResolution.y*gSc;\n    \n    //rot2(3.14159/4.)*\n    // Depending on perspective; Moving the oject toward the bottom left, \n    // or the camera in the north east (top right) direction. \n    vec2 p = rot2(3.14159/9.)*rot2(-atan(1., 3.))*uv*gSc - vec2(-1, -.5)*iTime/12.;//\n    \n    // 2D directional light vector and a nearby sample, in order \n    // to add some directional derviative based highlighting.\n    vec2 ld = normalize(vec2(-1.5, -1));\n    vec4 d4Hi = pattern(p - ld*.005);\n    float poly2 = d4Hi.x;\n\n    vec4 d4 = pattern(p);\n    float poly = d4.x;\n    int oID = int(d4.y);\n    vec2 id = d4.zw;\n  \n    // Transcendental based coloring. I don't know if IQ invented it, but\n    // his examples are the reason everyone uses it now. :)\n    float rnd = hash21(d4.zw + .11);\n    vec3 oCol = .5 + .45*cos(6.2831*rnd/4. + vec3(0, 2, 1));\n   \n    /*\n    // Trying to introduce more colors... It didn't work. :)\n    \n    int crossID = oID/2; // One of two cross IDs. \n    int polyID = oID%2; // One of two polygon IDs.\n    //if((crossID + polyID)%2==0)  oCol = vec3(.35)*dot(oCol, vec3(.299, .587, .114));; \n    if((int(d4.z/2.) + int(d4.w/2.))%2==0){\n         oCol = mix(oCol, oCol.yxz, .9);\n    } \n    // Greyscale. \n    //if(hash21(d4.zw + .13)<.5) oCol = oCol.zzz;\n    */\n     \n    \n    // Directional derivative based bump mapping... Not as good as real gradient\n    // based bump mapping (usually one extra sample), but it has a certain naive \n    // appeal to it.\n    float bump = max(min(-poly/gSc, .016) - min(-poly2/gSc, .016), 0.)/.005;\n    bump += max(min(-poly/gSc, .036) - min(-poly2/gSc, .036), 0.)/.005/3.;\n    //bump += max(-poly/gSc - -poly2/gSc, 0.)/.005*.25;\n    //\n    // Applying the bump highlighting.\n    oCol *= (bump + bump*bump + 1.);\n    \n    // Initializing to the background color.\n    vec3 col = vec3(.1);\n    float ew = .007; // Dark edge width.\n    \n    // Rendering the objects themselves to the background.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, poly));\n    col = mix(col, oCol, 1. - smoothstep(0., sf, poly + ew));\n    \n    // Saving the color here for bump highlighting, if the same\n    // bump color is desired. You'll see that the bump colors are\n    // different, which isn't really physically correct, but it\n    // looks interesting.\n    //vec3 bCol = col;\n    //if(hash21(d4.zw + .41)<.5) bCol = bCol.yxz;\n   \n    \n    // Randomly color half of the tiles with something complimentary.  \n    if(hash21(d4.zw + .41)<.5) col = col.yzx;\n    // Greyscale.\n    //if(hash21(d4.zw + .22)<.35) col = vec3(col.z*.8);\n    \n    // Adding a random line pattern to the background.\n    float pat = randLines(rot2(-3.14159/4.)*p);\n    col = mix(col*1.1, col*.9, 1. - smoothstep(0., sf, pat));\n\n     \n    // Applying the highlighting, or bump mapping, if you prefer.\n    col = mix(pow(col, vec3(1))*1., col.xzy, min(bump*1., 1.));\n    \n    // Applying some light attenuation.\n    uv2 = uv - vec2(.75, .5);\n    uv2 *= rot2(sin(iTime/4.)*.25  + .5);\n    float atten = 1. - 1./(1. + pow(max(uv2.y*.25 + .5, 0.), 2.)*16.);\n    /*\n    // Spotlight: It's an interesting effect, but doesn't really work here.\n    float light = abs(uv2.x) - .3*(-uv2.y*1.);\n    col = mix(col*.65, col*vec3(1, .97, .92)*1.5, \n              (1. - smoothstep(0., .05, light))*atten);\n    */\n    col *= atten*.8 + .4;\n\n    // Grid.\n    #ifdef GRID\n    float grid = gridField(p);\n    col = mix(col, col*0., 1. - smoothstep(0., sf, grid));\n    #endif\n    \n    // Vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y), 1./16.)*1.05;\n\n    \n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}