{
    "Shader": {
        "info": {
            "date": "1571594911",
            "description": "Another October raymarching practice sketch. Experimenting with soft shadows.",
            "flags": 0,
            "hasliked": 0,
            "id": "3ddXRN",
            "likes": 1,
            "name": "Shadertober 20 Shadows -jaburns",
            "published": 3,
            "tags": [
                "raymarch",
                "shadow",
                "practice"
            ],
            "usePreview": 0,
            "username": "jaburns",
            "viewed": 329
        },
        "renderpass": [
            {
                "code": "#define EPS 0.005\n#define MAX_DIST 30.0\n#define ITERATIONS 99\n#define PI 3.14159265358979\n\n#define MAT_LIGHT 0\n#define MAT_SCENE 1\n\nmat2 rot(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c,s,-s,c);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    p.yz = p.zy;\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nvec3 lightPos()\n{\n    vec3 p = vec3(5,3,0);\n    p.xz *= rot(iTime);\n    return p;\n}\n\nvec2 join(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nvec2 DE(vec3 p, bool light)\n{\n    float obj = sdTorus(p+vec3(0,2,0), vec2(2.5,1.));\n    float plane = p.y + 2.;\n    vec2 result = join(vec2(obj,MAT_SCENE), vec2(plane,MAT_SCENE));\n    \n    if (light) {\n \t \tfloat light = length(p - lightPos()) - .3;\n   \t    result = join(result, vec2(light,MAT_LIGHT));\n    }\n        \n    return vec2(max(result.x, 0.), result.y);\n}\n\nvec4 march(vec3 ro, vec3 rd, float offset)\n{\n    ro += rd * offset;\n    \n    vec2 dist;\n    float totalDist = 0.;\n    \n    for (int i = 0; i < ITERATIONS; ++i) {\n        dist = DE(ro, false);\n        ro += rd * dist.x;\n        totalDist += dist.x;\n    \tif (dist.x < EPS || totalDist > MAX_DIST) break;\n    }\n    \n    return vec4(ro, dist.x < EPS ? totalDist : -1.0);\n}\n\nfloat shadowMarch( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    float k = 20.;\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        vec2 h = DE(ro + rd*t, true);\n        if( h.y < .5 ) return res;\n        if( h.x < 0.001 ) return 0.0;\n        res = min( res, k*h.x/t );\n        t += h.x;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy - vec2(.5*iResolution.x/iResolution.y,.5);\n    \n    float bob = .5 + .5*sin(iTime);\n    vec3 ro = vec3(0, 5.*bob, 10);\n    vec3 rd = normalize(vec3(uv, -1));\n    ro.xz *= rot(.12 * iTime);\n    rd.yz *= rot(.5 * bob);\n    rd.xz *= rot(.12 * iTime);\n    \n    vec3 light = lightPos();\n    \n    fragColor = vec4(0);\n    \n    vec4 m = march(ro, rd, 0.);\n    if (m.w >= 0.) {\n        vec3 lightDir = normalize(light - m.xyz);\n        vec3 posToLight = m.xyz - light;\n        fragColor = vec4(  10. / dot(posToLight, posToLight)  );\n        float ml = shadowMarch(m.xyz, lightDir, .1, 30.);\n        fragColor *= .6 + .4*ml;\n    }\n    \n    // Trace to light sphere\n    vec3  sc = light;\n   \tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - .2;\n\tfloat h = b*b - c;\n\tif( h>0.0 )\t{\n        vec3 camToLight = light - ro;\n        vec3 camToPos = m.xyz - ro;\n        float d = (1. - dot(normalize(camToLight), normalize(camToPos))) * 40000.;\n        fragColor += vec4( max(0., 2. - pow(2.*d,.25)) );\n\t}\n    \n    fragColor.rgb *= 1.2*vec3(1.,.5,.5);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}