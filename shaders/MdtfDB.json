{
    "Shader": {
        "info": {
            "date": "1530885325",
            "description": "Hello world! DNA helix inspired by the one depicted in the Metal Gear Solid 2 intro sequence.",
            "flags": 0,
            "hasliked": 0,
            "id": "MdtfDB",
            "likes": 6,
            "name": "Deoxyribonucleic Acid",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "dna"
            ],
            "usePreview": 0,
            "username": "CLPB",
            "viewed": 695
        },
        "renderpass": [
            {
                "code": "// From https://www.youtube.com/watch?v=yxNnRSefK94 with some modifications\n// with parts from http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting\n\nfloat EPSILON = 0.00001;\n\n// From https://iquilezles.org/articles/distfunctions\nfloat sphSDF(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat sdCapCyl(vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat map(vec3 p){\n    float res = 0.0;\n    \n    float c = cos(0.07*p.y);\n    float s = sin(0.07*p.y);\n    \n    float rep = 5.0;\n    \n    vec3 q = vec3(p.x, mod(p.y, rep)-rep*0.5, p.z);\n    q = vec3(q.x * c + q.z *(s), q.y, q.x * (-s) + q.z*c);\n    \n    res += sdCapsule(q, vec3(8.0,-rep*0.4,0.0), vec3(8.0,rep*0.4,0.0), 1.3);\n    res = min(sdCapsule(q, vec3(-8.0,-rep*0.4,0.0), vec3(-8.0,rep*0.4,0.0), 1.3), res);\n    //res = min(sdCylinder(q-vec3(-8.0,0.0,0.0), vec3(1.0,1.1,1.0)), res);\n    \n    res = min(sdCapsule(q, vec3(8.1,0.0,0.0),vec3(-8.1,0.0,0.4),0.6), res);\n    \n    return res;\n}\n\nvec3 gradient(vec3 p){\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n        ));\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    float t = 0.0;\n    for (int i=0;i<128;++i){\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvec3 cameraLookAt(vec3 target, vec3 camPos, vec3 up, vec2 uv, float camNear)\n{\n    vec3 axisZ = normalize(target - camPos);\n    vec3 axisX = cross(axisZ, up);\n    vec3 axisY = cross(axisX, axisZ);\n    return normalize(axisX * uv.x + axisY * uv.y + camNear * axisZ); \n}\n\n// adapted from https://www.shadertoy.com/view/lt33z7\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity, vec3 N) {\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 N) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity,\n                                 N);\n    \n    vec3 light2Pos = vec3(0.0,6.0,-5.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity,\n                                 N);    \n    return color;\n}\n\n// Adapted from https://www.shadertoy.com/view/Xd2GR3\nfloat hexagon( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\t\n\treturn e;\n}\n\n// Adapted from https://www.shadertoy.com/view/Xd3XDS\nfloat t3(vec3 p, vec3 n)\n{\n    \n    float P = 32.0;\n    mat3 R = mat3(vec3(cos(8.0),sin(8.0),0),vec3(-sin(8.0),cos(8.0),0),vec3(0,0,-1));\n    p *= R/8.0;\n    n *= R;\n \treturn  (smoothstep(hexagon(p.xy*P), 1.0, 0.35)*n.z*n.z\n            +smoothstep(hexagon(p.zy*P), 1.0, 0.35)*n.x*n.x\n            +smoothstep(hexagon(p.xz*P), 1.0, 0.35)*n.y*n.y);\n}\n\nvec3 hexGradient( vec2 uv ){\n    float h = smoothstep(hexagon(uv*32.0), 1.0, 0.25);\n    float w = 24.0;\n    vec3 n = normalize(vec3(dFdx(h) * w, dFdy(h) * w, 1.0));\n    \n    return n*0.5 + 0.5;\n}\n\nvec3 t3norm(vec3 p, vec3 n)\n{\n    \n    float P = 1.0;\n    mat3 R = mat3(vec3(cos(8.0),sin(8.0),0),vec3(-sin(8.0),cos(8.0),0),vec3(0,0,-1));\n    p *= R/8.0;\n    n *= R;\n \treturn  (hexGradient(p.xy)*n.z*n.z\n            +hexGradient(p.zy)*n.x*n.x\n            +hexGradient(p.xz)*n.y*n.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // adjusted to -1, 1 range\n    uv = uv * 2.0 - 1.0;\n    // corrected for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //origin\n    vec3 ro = vec3(sin(iTime*0.1)*23.0 + 10.0, 0.0, cos(iTime*0.1)*23.0 + 10.0);\n    \n    //direction\n    // vec3 rd = normalize(vec3(uv, -1.0));\n    vec3 rd = cameraLookAt(vec3(14.0,sin(iTime*0.1)*20.0,0.0), ro, normalize( vec3(0.0,1.0,0.0) ), uv, 1.0);\n    \n    float t = trace(ro,rd);\n    \n    float fog = 100.0 / (100.0 + t * t * 0.1);\n    \n    vec3 spos = ro+rd*t;\n    \n    vec3 norm_ws = gradient(spos);\n    \n    // Texture mapping\n    float hexPattern = t3(spos, norm_ws);\n    \n    vec3 nmap = t3norm(spos, norm_ws);\n    \n    norm_ws = normalize(norm_ws + norm_ws*nmap*0.7);\n    \n    vec3 col = phongIllumination(vec3(0.1,0.4,0.5), \n                                 vec3(0.2), \n                                 vec3(2.0 - hexPattern*1.5), \n                                 1.45, \n                                 spos,\n                                 ro,\n                                 norm_ws);\n    col = mix(vec3(0.152, 0.419, 0.439), col, fog);\n\n    col = (t < 3000.0)? col: vec3(0.152, 0.419, 0.439);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}