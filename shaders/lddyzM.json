{
    "Shader": {
        "info": {
            "date": "1519221761",
            "description": "Three styles of point-lit wooden Penrose tiles. Mouse controls light position. Keys 1, 2, 3 control tile type.",
            "flags": 16,
            "hasliked": 0,
            "id": "lddyzM",
            "likes": 32,
            "name": "Penrose variations",
            "published": 3,
            "tags": [
                "2d",
                "fake3d",
                "tiling",
                "penrose"
            ],
            "usePreview": 1,
            "username": "mattz",
            "viewed": 1495
        },
        "renderpass": [
            {
                "code": "/* Penrose variations, by mattz\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   My brother wondered if you could \"fold\" kite & dart tiles in half for a cool 3D\n   look, and I made this to find out (spoiler: yes you can).\n\n   This shader morphs between \"flat\", \"pyramidal\", and \"folded\" tiles before repeating. \n\n   To implement this, I mainly used pencil & paper, along with these Wikipedia links:\n\n     - https://en.wikipedia.org/wiki/Penrose_tiling\n     - https://en.wikipedia.org/wiki/Golden_triangle_(mathematics)\n\n   Other cool Penrose tiling shaders:\n\n     - https://www.shadertoy.com/view/XlXGWM (tomkh)\n     - https://www.shadertoy.com/view/4t2XWG (tomkh)\n     - https://www.shadertoy.com/view/XdXGDX (daniel_flassig)\n\n   I tried to strive for readability below, feel free to request clarifications\n   in the comments!\n\n */\n\n// I used this when debugging the path, you can also use it to see the overall\n// symmetry of the sun deflation\n//#define DEBUG_PATH\n\n// maximum recursion depth, fun to play with\nconst int MAX_DEPTH = 8;\n\n// 1 / golden ratio\nconst float INVPHI = 0.6180339887498948;\n\n// 36 degrees\nconst float PI5 = 0.6283185307179586;\n\n// tile types\nconst int KITE = 0;\nconst int DART = 1;\n\nconst float GAMMA = 2.2;\nconst float INV_GAMMA = 1.0/GAMMA;\n\n//////////////////////////////////////////////////////////////////////\n// homogeneous 2D coordinates of a line passing through 2 points\n\nvec3 line(vec2 x, vec2 y) {\n    return cross(vec3(x, 1), vec3(y, 1));\n}\n\n//////////////////////////////////////////////////////////////////////\n// offset a line by a distance\n\nvec3 offset_line(vec3 l, float d) {\n    l /= length(l.xy);\n    l.z -= d;\n    return l;\n}\n\n//////////////////////////////////////////////////////////////////////\n// returns signed product indicating which side of line l x is on\n\nfloat side(vec2 x, vec3 l) {\n    return dot(vec3(x, 1), l);\n}\n\n//////////////////////////////////////////////////////////////////////\n// given the 2D coordinates of a line l, and two 3D points a & b\n// compute the intersection of the line from a to b with the plane\n// that contains l and is perpendicular to the XY plane\n\nvec3 intersect(vec3 l, vec3 a, vec3 b) {\n   \n    vec3 p = cross(l, line(a.xy, b.xy));\n    p /= p.z;\n    \n    vec2 pa = p.xy-a.xy;\n    vec2 ba = b.xy-a.xy;\n    \n    float u = dot(pa,ba)/dot(ba, ba);\n    \n    p.z = mix(a.z, b.z, u);\n    \n    return p;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// split a half-kite into a half-dart and two half-kites.\n// see penrose function below for illustration of half-tiles.\n\nint half_kite(inout vec2 a, \n              inout vec2 b,\n              inout vec2 c,\n              in vec2 p) {\n    \n    vec2 x = mix(b, a, INVPHI);\n    vec2 y = mix(a, c, INVPHI);\n    \n    vec3 lxy = line(x, y);\n    \n    if (side(p, lxy) * side(a, lxy) >= 0.) {\n        \n        b = y;\n        c = x;\n        \n        return DART;\n        \n    } else {\n        \n        \n        vec3 lby = line(b, y);\n        \n        if (side(p, lby) * side(c, lby) >= 0.) {\n            \n            a = b;\n            b = c;\n            c = y;\n\n        } else {\n            \n            a = b;\n            b = x;\n            c = y;\n\n        }\n        \n        return KITE;\n                \n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// split a half-dart into a half-dart and a half-kite.\n// see penrose function below for illustration of half-tiles\n\nint half_dart(inout vec2 a, \n              inout vec2 b,\n              inout vec2 c,\n              in vec2 p) {\n    \n    vec2 x = mix(a, b, INVPHI);\n    \n    vec3 lxc = line(x, c);\n    \n    if (side(p, lxc) * side(b, lxc) >=0.) {\n        \n        a = b;\n        b = c;\n        c = x;\n        return DART;\n        \n    } else {\n        \n        b = x;\n        \n        return KITE;\n        \n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// mirrors p about the vector n if it lies in the other direction\n// the vector n is modified to contain half its angle w.r.t. the x-axis\n// returns the matrix M that accomplishes the flip\n//\n// really just 2D folding -- see https://www.shadertoy.com/view/4tX3DS \n// for a more intuitive explanation\n\nmat2 flip(inout vec2 p, inout vec2 n) {\n    \n    float d = dot(p, n);\n    \n    mat2 M = mat2(1.) - 2.*outerProduct(n, n);\n    \n\tn = normalize( vec2(n.x - 1., n.y) );\n    \n    if (d < 0.) {\n        p = M * p;\n        return M;\n    } else {\n        return mat2(1.);\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// given an input point p sufficiently close to the origin,\n// computes the coordinates a, b, c  of the half-dart or half-kite \n// triangle containing p and returns the type of triangle.\n//\n// we do this by repeated deflation of a \"sun\" pattern, see\n// https://en.wikipedia.org/wiki/Penrose_tiling#Deflation_for_P2_and_P3_tilings\n//\n// the half-tile shapes look roughly like this:\n//\n//                 _-* b                            _-* b\n//               _-   \\                           _- /\n//             _-      \\                        _-  /\n//           _-         \\                     _-   /\n//         _-            \\                  _-    /\n//       _-               \\               _-     /\n//     _-                  \\            _-      /\n//  a * - - - - - X - - - - * c      a *- - X -* c  \n//\n//            half-kite                half-dart\n//\n// in both cases, line segment ac is the line of symmetry for each tile,\n// and edge ab has the same length for both half-tiles\n\nint penrose(in vec2 p, out vec2 a, out vec2 b, out vec2 c) {\n    \n    // we start out with a single half-kite on the right side\n    // of the Y axis\n    int type = KITE;\n    \n    a = vec2(0);\n    b = vec2(sin(PI5), cos(PI5));\n    c = vec2(0, 1);\n\n    // use 2D folding to mirror p along lines of symmetry\n    // in the sun pattern until it lands inside the wedge\n    // described by points b and c above\n    \n    vec2 n1 = vec2(-cos(4.*PI5), sin(4.*PI5));\n    vec2 n2 = vec2(1, 0);\n\n    mat2 M = flip(p, n2); // mirror across y-axis\n    M = flip(p, n1) * M;  // 144 degree symmetry lines \n    M = flip(p, n1) * M;  // 72 degree symmetry lines\n    M = flip(p, n1) * M;  // 36 degree symmetry lines\n\n    // stop early if p is outside the central sun figure\n    vec3 lbc = line(b, c);\n    \n    if (side(p, lbc) * side(a, lbc) < 0.) {\n        return -1;\n    }\n\n    // by now, p should live inside the triangle abc, so do\n    // a few iterations of deflation to subdivide triangles\n    \n    for (int i=0; i<MAX_DEPTH; ++i) {\n        // precondition: p lives in abc\n        if (type == KITE) {\n            type = half_kite(a, b, c, p);\n        } else {\n            type = half_dart(a, b, c, p);\n        }\n        // postcondition: abc is updated with the sub-triangle containing p\n    }\n    \n    // now undo whatever flips we did to p, to get the \"real-world\"\n    // coordinates of a, b, and c so we can perform per-pixel lighting\n    a = a * M;\n    b = b * M;\n    c = c * M;\n    \n    // return what type of triangle p is in\n    return type;\n    \n}\n  \n\n//////////////////////////////////////////////////////////////////////\n// return the surface normal of a triangle with vertices at a, b, c\n\nvec3 trinormal(vec3 a, vec3 b, vec3 c) {\n    return normalize( cross(b-a, c-a) );\n}\n\n//////////////////////////////////////////////////////////////////////\n// compute a smoothed square wave\n\nfloat smoothsquare(float t) {\n    \n\tconst float t_rise = 0.25;\n    \n    const float t_hi = 1.0;\n    const float t_lo = 2.0;\n    \n    const float t_total = t_hi + t_lo;\n    \n    t = mod(t, t_total);\n    \n    if (t < t_hi) {\n        \n        return smoothstep(t_hi, t_hi-t_rise, t);\n        \n    } else {\n        \n        t -= t_hi;\n        \n        return smoothstep(t_lo - t_rise, t_lo, t);\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// given a point p inside a half-dart or half-kite with vertices abc, \n// compute the surface normal of the triangle containing p\n\nvec3 get_normal(vec2 p, int type, vec3 a, vec3 b, vec3 c) {\n    \n    // x is the point along line segment ac that bisects angle abc\n    // see ASCII art above for location\n    vec3 x = mix(a, c, INVPHI);\n    \n    vec3 lbx = line(b.xy, x.xy);\n    \n    float scl = length(a.xy-b.xy);\n    float s = sign(side(a.xy, lbx));\n    \n\t// we can treat triangles abx and xbc the same -- if p is on the\n    // same side of line bx as c is, we replace a with c and flip \n    // the sign of the triangle determinant\n    if (side(p, lbx) * s <= 0.) {\n        a = c;\n        s = -s;\n    }\n    \n    // at this point just assume we are dealing with triangle abx \n    \n    ////////////////////////////////////////////////////////////\n    // now select some parameters affecting triangle geometry\n    // 3 types of tile: flat, pyramid, folded    \n    \n    float t = iTime * 0.0625;\n    \n    for (int i=0; i<3; ++i) {\n        if (texelFetch(iChannel1, ivec2(49+i, 0), 0).x > 0.) {\n            t = float(i);\n        }\n    }\n    \n    // size of v-groove border between tiles (bigger for flat)\n    float border =  0.05*scl * (1.0 + smoothsquare(t));\n\n    // height of midpoint for \"pyramid\" type tiles\n    float pyramid = 0.08*scl * smoothsquare(t - 1.0);\n\n    // height of corners for \"folding\" type tiles\n    float fold = 0.3*scl * smoothsquare(t - 2.0);\n\n    \n    ////////////////////////////////////////////////////////////\n    // handle lifting up corners. \n    // note kites and darts are \"folded\" in opposite directions\n\n    if (type == KITE) {\n        a.z += fold;\n        x.z += fold;\n    } else {\n        b.z += fold;\n    }\n\n    ////////////////////////////////////////////////////////////\n    // compute the line that separates the border from the \n    // interior of the tile, and compute its intersections\n    // with segments ax and bx\n   \n    vec3 lab = line(a.xy, b.xy);\n    vec3 oab = offset_line(lab, s*border);\n    \n    vec3 d = intersect(oab, a, x);\n    vec3 e = intersect(oab, b, x);\n    \n    ////////////////////////////////////////////////////////////\n    // now raise up the interior points in z height\n    \n\td.z += border;\n    e.z += border;\n    x.z += border + pyramid;\n    \n    ////////////////////////////////////////////////////////////\n\t// finally, depending upon which side of the line we are on\n    // compute the normal\n    \n    if (side(p, oab)*s >= 0.0) { \n        // inside border\n        return s*trinormal(d, e, x);\n    } else { \n        // outside border\n        return s*trinormal(a, b, d);\n    }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// from Dave_Hoskins' hash without sine: \n// https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// compute wood grain texture for a tile whose centerline in world\n// coordinates is given by ac\n\nvec3 wood_grain(vec2 p, int type, vec2 a, vec2 c) {\n       \n    vec2 cs = normalize(c-a);\n    mat2 R = mat2(cs.x, -cs.y, cs.y, cs.x);\n    \n    vec2 mid = 0.5*(a+c);\n    \n    p = R * (p - mid);\n    \n    p += hash22(mid * 8192.);\n    \n    vec3 color = texture(iChannel0, 12. * p).xyz;\n    \n    if (type == KITE) {\n        color = vec3(color.x + color.y, color.x - color.y, color.z) * 0.3;\n    } else {\n        color = mix(color, vec3(.7, .6, .2), 0.2);\n    }\n    \n    return pow(color, vec3(GAMMA));\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// compute position along winding path\n\nvec2 get_path_pos(float i) {\n       \n    float theta = i * 6.283185307179586;\n    \n    float r = 8.0*sin(6.0*theta) + 2.0;\n    \n    return 0.07 * r * vec2(cos(theta), sin(theta));\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// compute time-varying rotation matrix\n\nmat2 get_rotation(float f) {\n\n    float t = cos(f + 0.13) + 0.5 * cos(f*2.);\n    vec2 fwd = vec2(cos(t), sin(t));\n    \n    return mat2(fwd.x, -fwd.y, fwd.y, fwd.x); \n    \n}\n\n/////////////////////////////////////////////////////////////////////////////\n// our main function\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n\n\n    ////////////////////////////////////////////////////////////\n    // compute light coords\n    \n    vec2 mouse;\n    \n    if (max(iMouse.x, iMouse.y) > 20.0) {\n        mouse = (iMouse.xy - 0.5*iResolution.xy)*1.25 + 0.5*iResolution.xy;\n    } else {\n        mouse = 0.5*iResolution.xy;\n        float t = 0.25*iTime;\n        mouse += vec2(cos(t+1.5707), cos(3.*t))*0.4*iResolution.xy;\n    }\n    \n    vec3 l = normalize( vec3(mouse.xy - fragCoord.xy, 0.3*iResolution.y) );\n\n\n    ////////////////////////////////////////////////////////////\n    // compute 2D scene coords\n\n#ifdef DEBUG_PATH\n    float scl = 1.5 / iResolution.y;\n    mat2 R = mat2(1.);\n    vec2 path_pos = vec2(0);\n#else\n    float scl = (0.09 + cos(iTime*0.0815+0.3)*0.02) / iResolution.y;\n    vec2 path_pos = get_path_pos(0.001*iTime);\n    mat2 R = get_rotation(0.08*iTime);\n#endif\n    \n    vec2 p = (fragCoord - 0.5*iResolution.xy) * scl;       \n\n    p = (R * p) + path_pos;\n\n    ////////////////////////////////////////////////////////////\n    // get triangle type and vertices a, b, c\n    \n    vec2 a, b, c;\n    \n    int type = penrose(p, a, b, c);\n    \n    if (type < 0) {\n        fragColor = vec4(0);\n        return;\n    }\n       \n    ////////////////////////////////////////////////////////////\n    // compute triangle normal\n\n    vec3 n = get_normal(p, type, vec3(a, 0), vec3(b, 0), vec3(c, 0));\n    \n    // rotate the normal back to counter camera rotation\n    n.xy = n.xy * R;\n\n    ////////////////////////////////////////////////////////////\n    // per-pixel lighting\n    \n    vec3 color = wood_grain(p, type, a, c);\n    \n    color *= mix(dot(n, l), 1.0, 0.3);\n    \n    // specular\n    vec3 v = normalize(vec3(fragCoord.xy - 0.5*iResolution.xy, 1.5*iResolution.y));\n    vec3 r = reflect(l, n);\n    color += 0.05*pow(clamp(-dot(r, v), 0.0, 1.0), 10.0);\n    \n    // gamma correct\n    color = pow(color, vec3(INV_GAMMA));\n\n#ifdef DEBUG_PATH    \n    \n    const float di = 1.0/200.0;\n    \n    for (float i=0.0; i<1.0; i+=di) {\n        \n        vec2 pi = get_path_pos(i);\n        vec2 pj = get_path_pos(i+di);\n      \n        float u = dot(p-pi, pj-pi) / dot(pj-pi, pj-pi);\n        vec2 pc = mix(pi, pj, clamp(u, 0.0, 1.0));\n        \n        color = mix(color, vec3(0.75,1,0), smoothstep(scl, 0.0, length(p-pc)-scl));\n        \n    }\n    \n#endif    \n    \n    fragColor = vec4(color, 1);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}