{
    "Shader": {
        "info": {
            "date": "1727106234",
            "description": "I added some sound reactivity - Buffer A captures sound texture and places it in row 0 for other buffers to use.  It computes volume once and places it in 0,0 for other buffers to use.  In this way Buffer B & C can also use the sound info to react",
            "flags": 32,
            "hasliked": 0,
            "id": "MXSyRm",
            "likes": 1,
            "name": "nothingfsa sound visualizer",
            "published": 3,
            "tags": [
                "basic",
                "detection",
                "edge"
            ],
            "usePreview": 0,
            "username": "timmaffett",
            "viewed": 84
        },
        "renderpass": [
            {
                "code": "// Fork of \"nothingfsa on lsd\" by timmaffett. https://shadertoy.com/view/l3syWB\n// 2024-09-22 14:52:08\n// Fork of \"anime lsd\" by fulcanelly. https://shadertoy.com/view/lXsyWM\n// 2024-09-18 04:07:35\n// Combined with Buffer A ->>> Fork of \"nothingfsa\" by louijoe. https://shadertoy.com/view/4XfcR2\n// 2024-09-18 04:07:24\n\n/*\n  Some sound freq/pitch code from @kishimisu\n    \"3D Audio Visualizer\" https://www.shadertoy.com/view/dtl3Dr\n    and #2 https://www.shadertoy.com/view/Dtj3zW\n    (This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en))\n*/\n   \n//  SEE COMMON for defines to control what MOUSE DOES\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.y < 0.0) {\n        fragColor = vec4( texture(iChannel1,  fragCoord/iResolution.xy).xy, 1.0, 1.0 );\n\n        return;\n    }\n    fragColor = texture(iChannel0,  fragCoord/iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "precision highp float;\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nconst float pi = acos(-1.0);\nconst float pi2 = pi*2.0;\n\nvec2 pmod(vec2 p, float r) {\n    float a = atan(p.x, p.y) + pi/r;\n    float n = pi2 / r;\n    a = floor(a/n)*n;\n    return p*rot(-a);\n}\n\nfloat box( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat ifsBox(vec3 p) {\n    for (int i=0; i<5; i++) {\n        p = abs(p) - 1.0;\n        p.xy *= rot(iTime*0.3);\n        p.xz *= rot(iTime*0.1);\n    }\n    p.xz *= rot(iTime);\n    return box(p, vec3(0.4,0.8,0.3));\n}\n\nfloat map(vec3 p, vec3 cPos) {\n    vec3 p1 = p;\n    p1.x = mod(p1.x-5., 10.) - 5.;\n    p1.y = mod(p1.y-5., 10.) - 5.;\n    p1.z = mod(p1.z, 16.)-8.;\n    p1.xy = pmod(p1.xy, 5.0);\n    return ifsBox(p1);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec3 rgb = clamp( abs(mod(c.x *7.0 + vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\n// simple mouse rotate and zoom for shader\n#define pi 3.14159265359 \n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec2 mouseRotZoom(vec2 uv) {\n    // allow mouse zoom and rotate    \n    vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0,0.1) : iMouse.xy/iResolution.xy;\n#if MOUSECONTROLS_ROTATE\n    uv.xy *= r2d(-(mouse.x)*pi*2.);\n#endif\n#if MOUSECONTROLS_ZOOM\n    uv *= (1./(10.0*mouse.y));\n#endif\n    return uv;\n}\n\n\n\n\n\n/* Audio-related functions */\n#define getLevel(x) (texelFetch(iChannel0, ivec2(int(x*512.), 0), 0).r)\n#define getLevelFromOurInfo(x) (texture(iChannel3, vec2(int(x), 0), 0).r)\n#define logX(x,a,c) (1./(exp(-a*(x-c))+1.))\nfloat logisticAmp(float amp){\n   float c = .88, a = 20.;  \n   return (logX(amp, a, c) - logX(0.0, a, c)) / (logX(1.0, a, c) - logX(0.0, a, c));\n}\nfloat getPitch(float freq, float octave){\n   freq = pow(2., freq)   * 261.;\n   freq = pow(2., octave) * freq / 12000.;\n   return logisticAmp(getLevel(freq));\n}\nfloat getVol(float samples) {\n    float avg = 0.;\n    for (float i = 0.; i < samples; i++) avg += getLevel(i/samples);\n    return avg / samples;\n}\n\nfloat getVolFromOurInfo() {\n    // we computed and placed in 0,0\n    return (texelFetch(iChannel3, ivec2(0, 0), 0).r);\n    //return texture(iChannel3, vec2(0, 0)).r;\n}\n\n\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat getFreqBaseOnDistanceFromCenter(vec2 fragCoord) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    float hasSound = 1.;\n    if (iChannelTime[3] <= 0.) hasSound = .4;\n    \n\n    vec2 cen = floor(p.xy) + .5;\n    vec3 id = abs(vec3(cen.x, 0, cen.y));\n    float d = length(id);\n\n    float freq = smoothstep(0., 20., d)*3.*hasSound;// + hash13(id)*2.;\n    float pitch = getPitch(freq, .7);\n\n    return pitch;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Copy the sound texture into Y==0 line so that we\n    // can use it in every other buffer\n    if(fragCoord.y == 0.0) {\n        if(fragCoord.x==0.0) {\n            // compute volume once and store at 0,0\n            float vol = getVol(512.0);\n            fragColor = vec4( vol, vol, vol, 0.0 );\n            return;\n        }    \n        // create sound texture pixel coordinates\n        vec2 uv = fragCoord.xy / iResolution.xy;\n\n        // the sound texture is 512x2\n        int tx = int(uv.x*512.0);\n    \n        // first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n        float fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n\n        // second row is the sound wave, one texel is one mono sample\n        float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n\t\n        // convert frequency to colors\n        fragColor = vec4( fft, wave, 0.0, 0.0 );\n        return;\n    }\n    \n    \n    float sndFactor = getFreqBaseOnDistanceFromCenter(fragCoord);\n    \n    \n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    p = mouseRotZoom(p);\n\n    vec3 cPos = vec3(0.0,0.0, -3.0 * iTime);\n    // vec3 cPos = vec3(0.3*sin(iTime*0.8), 0.4*cos(iTime*0.3), -6.0 * iTime);\n    vec3 cDir = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 cUp  = vec3(sin(iTime), 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir);\n\n    // Phantom Mode https://www.shadertoy.com/view/MtScWW by aiekick\n    float acc = 0.0;\n    float acc2 = 0.0;\n    float t = 0.0;\n    for (int i = 0; i < 99; i++) {\n        vec3 pos = cPos + ray * t;\n        float dist = map(pos, cPos);\n        dist = max(abs(dist), 0.02);\n        float a = exp(-dist*3.0);\n        if (mod(length(pos)+24.0*iTime, 30.0) < 3.0) {\n            a *= 2.0;\n            acc2 += a;\n        }\n        acc += a*sndFactor;\n        t += dist * 0.5;\n    }\n\n    float hue = mod(t * 0.05 + iTime * 0.2, 1.0);\n    float saturation = 1.0;\n    float value = clamp(acc * 0.5 + acc2 * 0.5, 0.3, 1.0);\n\n    vec3 col = hsv2rgb(vec3(hue, saturation, value));\n\n    fragColor = vec4(col, 1.0 - t * 0.03);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 18,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n/* Audio-related functions */\n#define getLevelFromOurInfo(x) (texture(iChannel3, vec2(int(x), 0)).r)\n#define logX(x,a,c) (1./(exp(-a*(x-c))+1.))\nfloat logisticAmp(float amp){\n   float c = .88, a = 20.;  \n   return (logX(amp, a, c) - logX(0.0, a, c)) / (logX(1.0, a, c) - logX(0.0, a, c));\n}\nfloat getPitch(float freq, float octave){\n   freq = pow(2., freq)   * 261.;\n   freq = pow(2., octave) * freq / 12000.;\n   return logisticAmp(getLevelFromOurInfo(freq));\n}\n\nfloat getVolFromOurInfo() {\n    // we computed and placed in 0,0\n    return (texelFetch(iChannel3, ivec2(0, 0), 0).r);\n    //return texture(iChannel3, vec2(0, 0)).r;\n}\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat getEdgeFromFreqBaseOnDistanceFromCenter(vec2 fragCoord) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    float hasSound = 1.; if (iChannelTime[3] <= 0.) hasSound = .4;\n    \n\n    vec2 cen = floor(p.xy) + .5;\n    vec3 id = abs(vec3(cen.x, 0, cen.y));\n    float d = length(id);\n\n    float freq = smoothstep(0., 20., d)*3.*hasSound;// + hash13(id)*2.;\n    float pitch = getPitch(freq, .7);\n\n    return pitch;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\n    float sndFactor = getEdgeFromFreqBaseOnDistanceFromCenter(fragCoord);\n    \n\n    // I suggest playing around with this value\n    float h = 1.0; //2.0;\n    float threshold = 0.04; //0.12;\n\n    //* (1.0+ sin(iTime));\n    \n    vec4 o = texture(iChannel0, (fragCoord + vec2( 0, 0))/iResolution.xy);\n\tvec4 n = texture(iChannel0, (fragCoord + vec2( 0, h))/iResolution.xy);\n    vec4 e = texture(iChannel0, (fragCoord + vec2( h, 0))/iResolution.xy);\n    vec4 s = texture(iChannel0, (fragCoord + vec2( 0,-h))/iResolution.xy);\n    vec4 w = texture(iChannel0, (fragCoord + vec2(-h, 0))/iResolution.xy);\n    \n    vec4 dy = (n - s)*.5;\n    vec4 dx = (e - w)*.5;\n    \n    vec4 edge = sqrt(dx*dx + dy*dy);\n    vec4 angle = atan(dy, dx);\n   \n    if (edge.x + edge.y + edge.z > threshold){\n#if DETECTED_EDGES_BLACK\n      fragColor.xyz = vec3(0);\n#else\n#if MOUSE_X_CONTROLS_HOW_BLACK_EDGES_ARE\n      vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(0.4,1.0) : iMouse.xy/iResolution.xy;\n      fragColor.xyz = (5.0*sndFactor)*edge.xyz * 5.0*mouse.x;\n#else\n      fragColor.xyz = edge.xyz * 5.0;\n#endif\n#endif\n    } else {\n      fragColor = texture(iChannel0,  fragCoord/iResolution.xy);\n    }\n    // Below is another way to make an edge detector, \n    // It is invariant under intensity-scalings of the image\n    // and linear illumination differences.\n    // This should make it more \"human-sight\" like\n   \n    //vec4 laplacian = n + e + s + w - 4.0 * o;\n    //fragColor.xyz = abs(laplacian.xyz/o.xyz) * 1.0;\n \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": " float waveSpeed     = 0.1;                      \n float waveFrequency = 8.0;                  \n\nvec2 distortPosition( vec2 uv ) {                        \n    float timeOffset = iTime * waveSpeed;\n    vec2 frequencyOffset = waveFrequency * (uv + timeOffset);\n    \n    vec2 distortion = cos( vec2(                        \n       cos(frequencyOffset.x - frequencyOffset.y) * cos(frequencyOffset.y + frequencyOffset.x),                       \n       sin(frequencyOffset.x + frequencyOffset.y) * sin(frequencyOffset.y - frequencyOffset.x) ) );                   \n    return distortion;                                  \n}                                             \n\n\n\n\n\nfloat getVolFromOurInfo() {\n    // we computed and placed in 0,0\n    return (texelFetch(iChannel3, ivec2(0, 0), 0).r);\n    //return texture(iChannel3, vec2(0, 0)).r;\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {     \n\n    vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0,1.0) : iMouse.xy/iResolution.xy;\n\n#if MOUSECONTROLS_DISTORTION_FREQUENCY\n//waveFrequency /= mouse.x;\nwaveFrequency = mouse.x/mouse.y;\n#endif\n#if MOUSECONTROLS_DISTORTION_SPEED\n//waveSpeed /= mouse.y;\nwaveSpeed = mouse.y/mouse.x;\n#endif\n\n   waveFrequency = 5.0 * getVolFromOurInfo();\n\n   //waveFrequency *= getVolFromOurInfo();\n    //waveSpeed *= getVolFromOurInfo();\n\n    vec2 uv = fragCoord.xy / iResolution.xy;                      \n    vec2 distorted1 = distortPosition(uv);             \n    vec2 distorted2 = distortPosition(uv + 1.0);      \n    \n    float timeVaryingFactor =  1.5;\n\n    float displacement = timeVaryingFactor * 50.0 / iResolution.x;   \n    vec2 shiftedUV = uv + displacement * (distorted1 - distorted2);\n//shiftedUV.y = 1. - shiftedUV.y; // flip Y axis for ShaderToy\n    fragColor = texture( iChannel0, shiftedUV );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// you can combine any of these:\n// buffer A is Kaleidoscope \n#define MOUSECONTROLS_ZOOM                   1  \n#define MOUSECONTROLS_ROTATE                 1\n// buffer D is distortion buffer\n#define MOUSECONTROLS_DISTORTION_FREQUENCY   1\n#define MOUSECONTROLS_DISTORTION_SPEED       1\n// buffer B is edge detection\n#define MOUSE_X_CONTROLS_HOW_BLACK_EDGES_ARE    1\n\n\n\n// OR THIS overrides MOUSE_X_CONTROLS_HOW_BLACK_EDGES_ARE\n#define DETECTED_EDGES_BLACK   0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* ----------------------- */\n\n#ifdef ORIGINAL_NOT_ADAPTED_TO_OUR\n/* Audio-related functions */\n#define getLevel(x) (texelFetch(iChannel0, ivec2(int(x*512.), 0), 0).r)\n#define logX(x,a,c) (1./(exp(-a*(x-c))+1.))\nfloat logisticAmp(float amp){\n   float c = .88, a = 20.;  \n   return (logX(amp, a, c) - logX(0.0, a, c)) / (logX(1.0, a, c) - logX(0.0, a, c));\n}\nfloat getPitch(float freq, float octave){\n   freq = pow(2., freq)   * 261.;\n   freq = pow(2., octave) * freq / 12000.;\n   return logisticAmp(getLevel(freq));\n}\nfloat getVol(float samples) {\n    float avg = 0.;\n    for (float i = 0.; i < samples; i++) avg += getLevel(i/samples);\n    return avg / samples;\n}\n/* ----------------------- */\n#endif",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}