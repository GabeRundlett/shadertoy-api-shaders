{
    "Shader": {
        "info": {
            "date": "1709118117",
            "description": "I love transparent plastic toys!",
            "flags": 32,
            "hasliked": 0,
            "id": "lXfSzr",
            "likes": 32,
            "name": "amagi: transparent block tower",
            "published": 3,
            "tags": [
                "raymarching",
                "transparent",
                "lego"
            ],
            "usePreview": 1,
            "username": "amagitakayosi",
            "viewed": 528
        },
        "renderpass": [
            {
                "code": "// Transparent Block Tower\n// by Amagi\n// \n// Buffer A: raymarch\n// Buffer B: bloom + tone mapping\n//\n// ref. LEGO dimensions\n// https://bricks.stackexchange.com/questions/288/what-are-the-dimensions-of-a-lego-brick\n\n#define SAMPLES 7.0\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;    \n    vec4 c = texture(iChannel0, uv);\n    \n    // blur\n    vec4 cc = vec4(0);    \n    vec2 d = vec2(5., 2.) / iResolution.xy;        \n    float weights = 0.;\n    for (float x = -SAMPLES; x <= SAMPLES; x++) {\n        for (float y = -SAMPLES; y <= SAMPLES; y++) {    \n            vec2 xy = vec2(x, y);\n            float w = exp(length(xy) * -.1);\n            weights += w;\n                \n            vec4 cs = texture(iChannel0, uv + xy * d);\n            float g = dot(cs.rgb, vec3(0.72, 0.48, 0.2));        \n            cs *= smoothstep(.7, .8, g) * w;\n            cc += clamp(cs, 0., 1.) * w;\n        }\n    }\n    c += cc / weights * 0.4;\n\n    // tone mapping\n    c.rgb = 1. - exp(c.rgb * -2.);\n    c.b = smoothstep(-.1, 1., c.b);\n\n    fragColor = c;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// LEGO UNIT = 1.6mm\n// ref. https://bricks.stackexchange.com/questions/288/what-are-the-dimensions-of-a-lego-brick\n#define LU(x) (x * 1.6)\n\n\n// ================================ Global state ================================\n\nfloat light = 0.;\nfloat transition = 0.;\n\n\n// ================================ Utils ================================\n\nmat2 rot(float t) {\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nfloat hash(vec3 p) {\n    return fract(sin(dot(p, vec3(431., 113., 33.))) * 3319.);\n}\n\nvec2 hash2(vec2 p, float t) {\n    return vec2(hash(vec3(p, t)), hash(vec3(p, t + 100.)));\n}\n\n// ================================ SDFs ================================\n\n#define opUnion(a, b) min(a, b)\n#define opSubtract(a, b) max(a, -b)    \n#define UU(a, b) (a.x < b.x ? a : b)\n\nfloat sdCylinder(vec3 p, float r, float h, float rb) {\n    vec2 d = vec2(\n        length(p.xz) - r,\n        abs(p.y) - h * .5\n    );\n    \n    return min(max(d.x,d.y), 0.0) + length(max(d, 0.0)) - rb;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return min(max(max(q.x, q.y), q.z), 0.0) + length(max(q, 0.0));\n}\n\nfloat sdLogo(vec3 p) {\n    float d = 999.;        \n    d = opUnion(d, sdCylinder(p, LU(10.), LU(6.), 0.03));\n    \n    // top notches\n    vec3 p2 = p;\n    p2.xz = abs(p2.xz);        \n    p2.xz -= LU(4.9);\n    d = opUnion(d, sdCylinder(p2, LU(3.05), LU(10.), 0.03));\n    \n    \n    // bottom empty\n    vec3 p3 = p;\n    p3.y += LU(3.);\n    d = opSubtract(d, sdBox(p3, vec3(LU(8.), LU(2.), LU(8.))));\n    \n    p3 = p;\n    d = opSubtract(d, sdCylinder(p3, LU(8.), LU(5.), 0.01));\n            \n    return d;    \n}\n\n\n// ================================ Scene ================================\n\nvec2 mapTower(vec3 p) {\n    float yUnit = LU(6.2);\n    float id = mod(floor(p.y / yUnit), 24.);            \n\n\n//    // Subtle distortion\n//    float yy = p.y + id;\n//    p.x += sin(yy * 0.13) * sin(p.z * 0.4) * 0.07;\n//    p.z += sin(yy * 0.14) * sin(p.x * 0.3) * 0.07;\n\n    // Repeat Y\n    p.y = mod(p.y, yUnit) - yUnit * 0.5;\n    \n\n    vec2 hit;\n    hit = vec2(sdLogo(p), id);    \n    hit = UU(hit, vec2(sdLogo(p + vec3(0, yUnit, 0)), id - 1.));\n    hit = UU(hit, vec2(sdLogo(p - vec3(0, yUnit, 0)), id + 1.));    \n\n    return hit;\n}\n\nvec2 mapShell(vec3 p, float yUnit, float r, float h, float speed, float seed) {\n    float id = floor(p.y / yUnit);\n    p.y = mod(p.y, yUnit) - yUnit * .5;\n\n    float angle = ((iTime + transition * 4.) * speed) * sign(sin(id * 11. + seed)) + seed * 13.;\n    p.xz *= rot(angle);\n\n    return vec2(opSubtract(\n        sdCylinder(p, r, h, 0.), \n        sdCylinder(p + vec3(LU(1.1), 0, 0), r + LU(1.), h * 2., 0.)\n    ), id);\n\n}\n\nvec2 mapShells(vec3 p) {\n    vec2 hit = vec2(999, -1);\n\n    hit = UU(hit, mapShell(p, LU(17.), LU(15.), LU(2.), -2., 1.));    \n    hit = UU(hit, mapShell(p, LU(23.), LU(21.), LU(3.), 2., 3.));\n    hit = UU(hit, mapShell(p, LU(19.), LU(29.), LU(1.), 3., 11.));        \n\n    light += smoothstep(.4, .9, sin(hit.y + iTime * 3.141593)) * (0.002 / abs(hit.x));\n\n\n    return hit;\n}\n\nvec2 map(vec3 p) {\n    p.xy *= rot(0.35 + sin(iTime * 3.14 * 0.33334) * 0.03);       \n    p.xz *= rot(iTime * 3.141593 * 0.33334 + transition * 1.);\n\n\n    // BG\n    vec2 hit = vec2(999., -1);\n    \n    p.y += (iTime + transition * 6.) * LU(6.);    \n    hit = UU(hit, mapTower(p));\n    hit = UU(hit, mapShells(p));        \n\n    return hit;\n}\n\n// getNormal with fast compilation technique\n// https://iquilezles.org/articles/normalsSDF/#:~:text=An%20important%20implementation%20detail\nvec3 getNormal(vec3 p)\n{\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\n// Main ================================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n\n    // Animation\n    transition = pow(smoothstep(0., .8, mod(iTime+.4, 12.)), 2.) + floor((iTime + .4) / 12.);           \n\n    // Camera setup\n    vec3 ro = vec3(0, 0, 60.);\n    vec3 rt = vec3(0, 0, 0);\n       \n    vec3 cf = normalize(rt - ro);\n    vec3 cu = normalize(vec3(0, 1, 0));\n    vec3 cr = cross(cf, cu);\n    vec2 cp = p;\n    \n    // For export\n    // float bokehD = 0.3;\n    // bokeh = smoothstep(0., bokehD, mod(iTime+bokehD, 12.)) * smoothstep(bokehD * 2., bokehD, mod(iTime+bokehD, 12.));    \n    // cp += hash2(p, iTime) * 0.1 * pow(bokeh, 2.) * vec2(0.3, 1);\n\n    vec3 rd = normalize(\n        cp.x * cr + cp.y * cu + 1.3 * cf\n    );        \n        \n    vec3 rp = vec3(0);\n    vec2 hit = vec2(0);\n    float t = 0.;\n    \n    // Surface (first ray hit) data\n    vec3 rpf;\n    vec2 hitf = vec2(-1);\n    float occ = 0.;    \n    \n    vec3 color;    \n    vec3 innerColor = vec3(1);\n\n    for (int i = min(iFrame, 0); i < 120; i++) {\n        rp = ro + rd * t;        \n        hit = map(rp);\n\n        if (hit.x < 1e-4) {                \n            // Save first hit\n            if (hitf.x == -1.) {\n                hitf = hit;\n                rpf = rp;\n                occ = float(i) * 0.008;\n            }\n            \n            // Absorb the light\n            float s = 0.03;\n            s *= float(i) * 0.03;\n            float bid = mod(hit.y, 3.);\n            if (bid == 0.0) { innerColor -= vec3(1, 0.4, 0.2) * s; }\n            if (bid == 1.0) { innerColor -= vec3(0.3, 1, 0.2) * s; }\n            if (bid == 2.0) { innerColor -= vec3(0.2, 0.24, 1) * s; }\n                       \n            // Move the ray forward a little\n            t += LU(0.3);\n        } else {        \n            t += hit.x * 0.9;\n        }\n    }     \n\n\n    vec3 matColor;\n    \n    if (hitf.x != -1.) {\n        vec3 n = getNormal(rpf);\n        vec3 ld = normalize(vec3(-1, 2, 1));\n        vec3 lc = vec3(1,1,1);\n\n        // Surface color\n        float bid = mod(hitf.y, 3.);        \n        if (bid == 0.0) { matColor = vec3(0, .4, 1); }\n        if (bid == 1.0) { matColor = vec3(1, 0, .8); }\n        if (bid == 2.0) { matColor = vec3(1, .4, 0); }\n        vec3 surfaceColor = ((lc * dot(ld, n)*.5 + .5) * 0.6 + 0.4) * matColor;\n\n        // Mix surface / inner colors by the grazing angle.\n        float fres = clamp(dot(n, rd) + 1., 0., 1.);\n        color = mix(surfaceColor, innerColor, mix(0.4, 0.0, pow(fres, 5.))); \n        \n        // Env & AO\n        color += texture(iChannel0, n).rgb * 0.8;\n        color -= occ; // AO\n    } else {\n        // BG\n        float l = length(p + hash2(p, iTime) * 0.2) * .8;\n        color = (vec3(\n            0,\n            sin(l) * 0.5,\n            sin(l)\n        ) * 0.5 + 0.5) * smoothstep(-.2, 0.2, sin(iTime * 3.14 * 0.166667));\n    }\n    \n    // Emission\n    color += light * (color * 0.2 + matColor * 0.8);\n\n    fragColor = vec4(color, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}