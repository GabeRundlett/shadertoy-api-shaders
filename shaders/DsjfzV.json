{
    "Shader": {
        "info": {
            "date": "1703847835",
            "description": "This shader is just mix of three shaders:\n1. [url]https://www.shadertoy.com/view/cdsGD4[/url] - SDF normals\n2. [url]https://www.shadertoy.com/view/dsX3RM[/url] - improved Raytracing Quadratic Bezier 3D \n",
            "flags": 0,
            "hasliked": 0,
            "id": "DsjfzV",
            "likes": 12,
            "name": "Raytracing 3D Bezier w/ Normals ",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "bezier",
                "normals",
                "intersection",
                "curve",
                "normal",
                "quadratic",
                "analytic",
                "intersect"
            ],
            "usePreview": 0,
            "username": "morimea",
            "viewed": 336
        },
        "renderpass": [
            {
                "code": "\n// Created by Danil (2023+) https://github.com/danilw\n// The MIT License\n\n// self https://www.shadertoy.com/view/DsjfzV\n\n// This shader is just mix of two shaders:\n// https://www.shadertoy.com/view/cdsGD4 - SDF normals\n// https://www.shadertoy.com/view/dsX3RM - improved Raytracing Quadratic Bezier 3D \n\n\n// WARNING - BROKEN NORMALS\n// 1. normal of surface and halph-sphere on sides is broken because self-intersect broken\n// 2. normal of surface is broken at extreme angle/curve - or when camera close to surface\n// This makes this Raytraced 3d Bezier not very good for something like pathtracing.\n// \n// notice that with bloxard_improved_normal - normals do move little\n// but bloxard_improved_normal is cheaper by performance\n// and uncomment col = vec3(dif)... at end of code to see visual color of SDF_normal and bloxard_improved_normal\n\n//--------------------\n// Normals:\n\n// Two ways to get normal - by 1 call to SDF with position on surface - second call of solving\n// Or from improved more recent version of a Raytracing 3D Bezier - by bloxard\n// https://www.shadertoy.com/view/dsX3RM\n\n#define SDF_normal\n//#define bloxard_improved_normal\n\n//--------------------\n\n\n\n#define MAX_DIST 1000.\n#define MIN_DIST .001\n\n#define PI 3.141592653589793\n#define TAU (2.*PI)\n#define HALFPI 1.57079632679\n\n// from https://www.shadertoy.com/view/3sjXDm\n\nconst float fThickness = 335e-3;\n\nmat3 inverseView(vec2 a)\n{\n    vec2 c = cos(a);\n    vec2 s = sin(a);\n    return mat3(c.y,0.,-s.y,s.x*s.y,c.x,s.x*c.y,c.x*s.y,-s.x,c.x*c.y);\n}\n\nvec2 solveCubic2(float a, float b, float c)\n{\n\tfloat p = b-a*a/3., p3 = p*p*p;\n\tfloat q = a*(2.*a*a-9.*b)/27.+ c;\n\tfloat d = q*q+4.*p3/27.;\n\tfloat offset = -a / 3.;\n\tif(d>0.)\n\t{ \n\t\tfloat z = sqrt(d);\n\t\tvec2 x = (vec2(z,-z)-q)*0.5;\n        \n// from https://www.shadertoy.com/view/dsX3RM spalmer comment\n// this bug not visible on this shader \n// visual bug - https://danilw.github.io/GLSL-howto/vulkan_sh_launcher/images_bugs/DsjfzV.png\n// if needed define below\n// #define fixCubic\n// spalmer comment:\n        // credit: iq from comment at http://shadertoy.com/view/dsfGWN \n        // led me back to http://shadertoy.com/view/MlKcDD\n#ifdef fixCubic\n        if (abs(p) < .0504)\n        {\n            float kx = a/3., ky = b/3., kz = c;\n            float P = ky - kx*kx;\n            float P3 = P*P*P;\n            float Q = kx*(2.*kx*kx - 3.*ky) + kz;\n            float k = P3/Q;              // linear approx\n            //float k = (1.-P3/(Q*Q))*P3/Q;  // quadratic approx \n            x = vec2(k,-k-Q);\n        } \n#endif\n\t\tvec2 uv = sign(x)*pow(abs(x), vec2(1./3.));\n\t\treturn vec2(offset + uv.x + uv.y);\n\t}\n\tfloat v = acos(-sqrt(-27./p3)*q/2.)/3.;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\treturn vec2(m + m, -n - m) * sqrt(-p / 3.0) + offset;\n}\n\n#ifdef SDF_normal\n\n// sdBezier from https://www.shadertoy.com/view/cdsGD4\n//--------------------\n\n// for normal\n// if I understand correctly - you do need second run of *Bezier to get normal\n// because you need surface pos as input\n// Warning - generate little broken normal on some angles\nvec4 sdBezier( in vec3 pos, in vec3 A, in vec3 B, in vec3 C) {\n    const float i3 = 1.0 / 3.0;\n    const float sqrt3 = sqrt(3.0);\n    vec3 a = B - A;\n    vec3 b = A - 2.0 * B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n    \n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) * i3;\n    float kz = kk * dot(d, a);\n    \n    float p  = ky - kx * kx;\n    float q  = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float p3 = p * p * p;\n    float h  = q * q + 4.0 * p3;\n    bool tsth = h >= 0.0;\n    h = sqrt(h);\n    float k = p3 / q;\n    bool tstp = abs(p) < 0.01;\n    vec2 x = float(!tstp) * (vec2(h, -h) - q) * 0.5 + float(tstp) * vec2(k, -k - q);\n    vec2 uv = sign(x) * pow(abs(x), vec2(i3));\n    float t1 = clamp(uv.x + uv.y - kx, 0.0, 1.0);\n    vec3  qv3 = d + (c + b * t1) * t1;\n    float z = sqrt(-p);\n    float v = acos(q / (p * z * 2.0)) * i3;\n    float m = cos(v);\n    float n = sin(v) * sqrt3;\n    vec2 t2 = clamp(vec2(m + m, -n - m) * z - kx, 0.0, 1.0);\n    vec3  qx = d + (c + b * t2.x) * t2.x;\n    float dx = dot(qx, qx);\n    vec3  qy = d + (c + b * t2.y) * t2.y;\n    float dy = dot(qy, qy);\n    bool tstdxy = dx < dy;\n    vec4 res;\n    if(tstdxy){\n        float td = float(tsth)*dot(qv3, qv3) + float(!tsth) * dx;\n        vec3 norm = float(tsth)*qv3+ float(!tsth)*qx;\n        res = vec4(td,norm);\n    }else{\n        float td = float(tsth)*dot(qv3, qv3) + float(!tsth) * dy;\n        vec3 norm = float(tsth)*qv3+ float(!tsth)*qy;\n        res = vec4(td,norm);\n    }\n    \n    res.x = sqrt(res.x);\n    res.yzw /= -res.x;\n    \n    return res;\n}\n//--------------------\n#endif\n\n\n// from https://www.shadertoy.com/view/dsX3RM\n//--------------------\n\nvec2 closestPointOnQuadraticBezierCurve(vec3 p0, vec3 p1, vec3 p2) \n{\n\tvec2 A2 = p1.xy - p0.xy;\n\tvec2 B2 = p2.xy - p1.xy - A2;\n\t// Equation solution here: https://perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\n\tvec3 r = vec3(-3.*dot(A2,B2), dot(-p0.xy,B2)-2.*dot(A2,A2), dot(-p0.xy,A2)) / -dot(B2,B2);\n\tvec2 t = clamp(solveCubic2(r.x, r.y, r.z), 0., 1.);\n\tvec3 A3 = p1 - p0;\n\tvec3 B3 = p2 - p1 - A3;\n\tvec3 D3 = A3 * 2.;\n\tvec3 pos1 = (D3+B3*t.x)*t.x+p0;\n\tvec3 pos2 = (D3+B3*t.y)*t.y+p0;\n\tpos1.xy /= fThickness;\n\tpos2.xy /= fThickness;\n\tfloat pos1Len = length(pos1.xy);\n\tif (pos1Len>1.)\n\t{\n\t\tpos1 = vec3(1e8);\n\t}\n\tfloat pos2Len = length(pos2.xy);\n\tif (pos2Len>1.)\n\t{\n\t\tpos2 = vec3(1e8);\n\t}\n\tpos1.z -= cos(pos1Len*HALFPI)*fThickness;\n\tpos2.z -= cos(pos2Len*HALFPI)*fThickness;\n\treturn (length(pos1) < length(pos2)) ? vec2(t.x, pos1Len) : vec2(t.y, pos2Len);\n}\n\nvec2 findRaySphereRoots(in vec3 ro, in vec3 rd, in vec3 sc, in float r, out float disc)\n{\n\tvec3 dRoSc = ro - sc;\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.*dot(rd, dRoSc);\n\tfloat c = dot(dRoSc, dRoSc) - r * r;\n\tdisc = max(b * b - 4. * a * c, 0.);\n\tfloat sqrtD = sqrt(disc);\n\tfloat twoA = 2.*a;\n\treturn (vec2(-b) + vec2(sqrtD, -sqrtD)) / twoA;\n}\n//--------------------\n\nbool QuadraticBezierIntersect(vec3 ro, vec3 rd, out float td, out vec3 norm) {\n    \n    norm = vec3(0.,1.,0.);\n    td = MAX_DIST+1.;\n    mat3 m = inverseView(vec2(asin(-rd.y),atan(rd.x, rd.z)));\n    \n    float timer = iTime*0.00051+11.*0.5;\n    vec3 f = vec3(1.2133, 1.4763, 1.0);\n    vec3 offs = vec3(0.1, 2.5, 3.7);\n    vec3 amp = vec3(3.0, 3.1, 2.9);\n    vec3 p0 = vec3(-4.5, 0.0, 0.0);\n    vec3 p1 = sin(iTime * f + offs) * amp;\n    vec3 p2 = vec3(4.5, 0.0, 0.0);\n\n    vec2 t = closestPointOnQuadraticBezierCurve((p0 - ro)*m, (p1 - ro)*m, (p2 - ro)*m);\n    vec3 A = p1 - p0;\n    vec3 vPointOnInnerBezierCurve = (A * 2. + (p2 - p1 - A) * t.x) * t.x + p0;\n    float disc;\n    vec2 sR = findRaySphereRoots(ro, rd, vPointOnInnerBezierCurve, fThickness, disc);\n    if (disc > 0.)\n    {\n        vec3 vSphereSurfacePos = ro + rd * min(sR.x, sR.y);\n        vec3 vNormal = normalize(vSphereSurfacePos - vPointOnInnerBezierCurve);\n        td = min(sR.x, sR.y);\n#ifdef bloxard_improved_normal\n        norm = vNormal;\n#endif\n#ifdef SDF_normal\n        norm = sdBezier(ro+rd*td,p0,p1,p2).yzw;\n#endif\n    }\n    bool res = td>MIN_DIST&&td<MAX_DIST;\n\n    return res;\n}\n\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s,\n                s,  c);\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3\n        f = normalize(l - p),\n        r = normalize(cross(vec3(0.0, 1.0, 0.0), f)),\n        u = cross(f, r),\n        c = f * z,\n        i = c + uv.x * r + uv.y * u;\n    return normalize(i);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 m = iMouse.xy / iResolution.xy;\n    \n    vec3 ro = vec3(0.0, 3.0, -7.0);\n    ro.yz *= rot(-m.y * PI * 0.9 + 1.0);\n    ro.xz *= rot(-m.x * TAU);\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 rd = getRayDir(uv, ro, vec3(0.0, 0.0, 0.0), 1.0);\n    \n    float td; //depth\n    vec3 norm; //normal\n    QuadraticBezierIntersect(ro, rd, td, norm);\n\n    if(td < MAX_DIST) {\n    \n        col = vec3(norm); // debug\n        //col = vec3(td*0.1); // debug\n    \n        float dif = dot(norm, normalize(vec3(1.0, 2.0, 3.0))) * 0.5 + 0.5;\n        //col = vec3(dif) * vec3(0.4, 0.0, 0.8); //color\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}