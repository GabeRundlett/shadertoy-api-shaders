{
    "Shader": {
        "info": {
            "date": "1698862484",
            "description": "This is inspired by Fabrice's shader\nhttps://www.shadertoy.com/view/dtSfRh\n\nand this twitter (formerly known as X) post:\nhttps://twitter.com/junkiyoshi/status/1697571241513910691\n",
            "flags": 32,
            "hasliked": 0,
            "id": "DtccR8",
            "likes": 48,
            "name": "Cell Swap Automata",
            "published": 3,
            "tags": [
                "grid",
                "automata",
                "cell",
                "cool",
                "ca",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 559
        },
        "renderpass": [
            {
                "code": "// This is inspired by Fabrice's shader\n// https://www.shadertoy.com/view/dtSfRh\n\n// and this twitter (formerly known as X) post:\n// https://twitter.com/junkiyoshi/status/1697571241513910691\n\n// I think it would go well with Shane's moving cubes\n// https://www.shadertoy.com/view/cdtfWS\n\n// Rough overview:\n// Buffer A runs a cellular automata where:\n// - each cell is on or off\n// - each cell picks a neighbour cell to move into\n// - if an on/off pair want to move into each other, they swap\n// - when in a moving state, cells increment a timer\n\n// Image interprets Buffer A by:\n// - drawing \"on\" cells\n// - offsetting cell circle positions using the cell's timer\n\n#define pi 3.14159\n\nvoid mainImage( out vec4 o, vec2 px )\n{\n    px *= .06;\n    o = texture(iChannel0, px / iResolution.xy);\n\n    // Mix between cell positions\n    // Flip o.a motion with on/off value o.g\n    float mx = mix(o.a, 1.-o.a, o.g);\n    mx = smoothstep(0.2, 0.8, mx);\n    \n    vec2 dir = indexToDir(o.b);\n    vec2 f = fract(px) -.5 - mx*dir;\n    float s = smoothstep(0., .1, .3+.2*o.r-length(f));\n    \n    vec4 col = .6+.4*cos(2.*pi*(2.*o.r+vec4(0,1.5,2,0)/6.));\n    \n    o = sqrt(s * col);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 indexToDir(float i) {\n    if (i == 0.) return vec2(-1, 0);\n    if (i == 1.) return vec2( 0, 1);\n    if (i == 2.) return vec2( 1, 0);\n    return vec2(0, -1);\n}\n\nfloat dirToIndex(vec2 u) {\n    if (u == vec2(-1, 0)) return 0.;\n    if (u == vec2( 0, 1)) return 1.;\n    if (u == vec2( 1, 0)) return 2.;\n    return 3.;\n}\n\n// From Fabrice\n// https://www.shadertoy.com/view/WttXWX\n#define hashi(x) triple32(x)\n#define hash(x)  ( float( hashi(floatBitsToUint(hash13(x))) ) / float( 0xffffffffU ) )\n\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\n// From Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "float getIndex(vec2 u) {\n    return floor(4.*hash(vec3(u,.1*iTime)));\n}\n\nvec2 getDir(vec2 u) {\n    return indexToDir(getIndex(u));\n}\n\nvoid mainImage( out vec4 o, vec2 u )\n{\n    if (iFrame < 1) {\n        o.r = hash12(u);     // Color\n        o.g = step(.2, o.r); // 0=off, 1=on\n        o.b = 0.;            // Direction index 0,1,2,3\n        o.a = 1.;            // Motion timer [0,1] range\n    } \n    else {\n        o = texelFetch(iChannel0, ivec2(u), 0);  \n        \n        vec2 dir = getDir(u);\n        vec2 cdir = getDir(u + dir);\n        vec4 c = texelFetch(iChannel0, ivec2(u + dir), 0);\n        \n        // Increment motion timer\n        float inc = .05 * (1.-o.r) * 60. * iTimeDelta;\n        if (o.a < 1.) \n            o.a = min(1., o.a+inc);\n            \n        // Swap cells if:\n        // - other cell is not moving\n        // - other cell wants to move to this cell\n        // - other cell's on/off value is different to this cell\n        else if (c.a == 1. && dir == -cdir && o.g+c.g == 1.) {\n            // Off cells change their color, on cells keep color\n            if (o.g == 0.)\n                o.r = c.r;\n            o.g = c.g;         // Swap on/off value\n            o.b = getIndex(u); // Store direction for Image tab\n            o.a = 0.;          // Initialize timer\n        }\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}