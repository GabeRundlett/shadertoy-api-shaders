{
    "Shader": {
        "info": {
            "date": "1694401950",
            "description": "Little experiment I did, making use of the fact that objects in its own repeating field will never intersect. This should be generalizable to any composite signed distance function, but its not great. Simple cases work, but nothing else does.",
            "flags": 0,
            "hasliked": 0,
            "id": "mt2BRt",
            "likes": 4,
            "name": "occlusionÕè",
            "published": 3,
            "tags": [
                "raymarching",
                "basic",
                "experiment"
            ],
            "usePreview": 0,
            "username": "01000001",
            "viewed": 109
        },
        "renderpass": [
            {
                "code": "int maxSteps = 512;\nfloat maxDepth = 500.;\nfloat minDist = 0.001;\nvec3 lightDir = vec3(.5, -.4, 1.);\n\nconst float aoScale = 0.8;\n\nvoid mainImage( out vec4 O, in vec2 U ){\n\n    lightDir = normalize(lightDir);\n\n    vec2 r = iResolution.xy;\n    vec2 uv = (2.*U - r)/r.y;\n    vec2 muv = iMouse.xy == vec2(0)?vec2(0):(2.*iMouse.xy - r)/r.y;\n    \n    float depth = 0.0;\n    vec3 camDir = vec3(-sin(-muv.x)*cos(muv.y), cos(-muv.x)*cos(muv.y), sin(muv.y));\n    vec3 o = vec3(0, 0, -.5) - camDir*6.;\n    vec3 camRight = normalize(cross(camDir, vec3(0, 0, 1)));\n    vec3 camUp = (cross(camRight, camDir));\n    vec3 dirV = normalize(camDir*2. + camRight * uv.x + camUp * uv.y);\n    vec3 p;\n    \n    for (int i = 0; i++ < maxSteps;){\n    \n        p = o + dirV * depth;\n        float d = DF(p).x;\n        \n        depth += d;\n        \n        if (depth > maxDepth){\n            depth = maxDepth;\n            break;\n        }\n        \n        if (d < minDist){\n            break;\n        }\n    }\n    \n    vec3 norma = norm(p, depth * 1e-4, 0);\n    vec3 normb = norm(p, depth * 1e-4, 1);\n    \n    O*=0.;\n    \n    float light = 1.;\n    \n    float f = smoothstep(0., 1.,-dot(norma, normb)*.5+.5);\n    \n    float ao = sqrt(DF(p).y);\n    \n    O = vec4(.7);\n    light *= min(1., ao/f / aoScale);\n    light *= (dot(norma, lightDir) * .3 + .5) / (depth*.2);\n    O.xyz *= light;    \n    \n    O = pow(O, vec4(1./2.4));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define update;     if (x < one){\\\n        three = two;\\\n        two = one;\\\n        one = x;\\\n    } else if (x < two) { \\\n        three = two; \\\n        two = x; \\\n    } else if (x < three) { \\\n        three = x; \\\n    } \\\n        \n    \n#define rot(x) mat2(cos(x + vec4(0, 33, 11, 0)))\n    \nfloat boxDF( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 DF(vec3 p){\n    float one   = 1e20;\n    float two   = 1e20;\n    float three = 1e20;\n    float x = 0.;\n    vec3 d = p;\n            \n    \n    // Make this procedural iterations\n    \n    \n    for (float i = 0.; i++<5.;){\n        d = p;\n        d.y -= i;\n        d.xy *= rot(i/2.);\n        d.yz *= rot(i/5.);\n        d = mod(d, 10./i)-5./i;\n\n        x = boxDF(d, vec3(exp(-i/2.))*2.);\n        update;\n\n    }\n    /*\n    d = p;\n    d.yz *= rot(.8);\n    d.xy *= rot(1.);\n    d = mod(d, 6.)-3.;\n    \n    x = boxDF(d, vec3(1));\n    update;\n    \n    \n    d = p;\n    d.yz *= rot(.2);\n    d.xy *= rot(1.2);\n    d = mod(d, 4.)-2.;\n    \n    x = boxDF(d, vec3(.5));\n    update;\n*/\n\n    return vec3(one, two, three);\n}\n\nvec3 norm(vec3 p, float eps, int i){\n    return vec3(\n        DF(p + vec3(eps, 0, 0))[i] - DF(p - vec3(eps, 0, 0))[i],\n        DF(p + vec3(0, eps, 0))[i] - DF(p - vec3(0, eps, 0))[i],\n        DF(p + vec3(0, 0, eps))[i] - DF(p - vec3(0, 0, eps))[i]\n    )/(2.*eps);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}