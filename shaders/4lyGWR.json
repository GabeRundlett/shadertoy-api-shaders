{
    "Shader": {
        "info": {
            "date": "1474319430",
            "description": "Painting Pixar's Ball, playing around raymarching.",
            "flags": 32,
            "hasliked": 0,
            "id": "4lyGWR",
            "likes": 9,
            "name": "Pixar's Ball",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "yibojiang",
            "viewed": 1062
        },
        "renderpass": [
            {
                "code": "#define pi 3.14159\n#define precis 0.001\nvec3 ambi = vec3( 0.12, 0.12, 0.12);\n\n#define tmin 0.0\n#define tmax 300.0\n\n\nvec3 rotY( vec3 dir, float rot ) {\n  return dir *\n         mat3( cos(rot), 0.0, -sin(rot),\n               0.0,       1.0, 0.0,\n               sin(rot),  0.0, cos(rot)\n             );\n}\n\nvec4 eularToQuat( vec3 axis, float angle ) {\n  vec4 q;\n  float half_angle = angle / 2.0;\n  q.x = axis.x * sin(half_angle);\n  q.y = axis.y * sin(half_angle);\n  q.z = axis.z * sin(half_angle);\n  q.w = cos(half_angle);\n  return q;\n}\n\nvec4 inverQuat( vec4 quat ) {\n  return vec4( -quat.x, -quat.y, -quat.z, quat.w );\n}\n\nvec4 mul_quat(vec4 q1, vec4 q2) {\n  vec4 qr;\n  qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n  qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n  qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n  qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n  return qr;\n}\n\nvec4 rotate( vec3 p, vec3 axis, float an) {\n  vec4 q = eularToQuat( axis, an );\n  vec4 qr = inverQuat( q );\n  vec4 pos = vec4( p.xyz, 0.0 );\n  vec4 tmp = mul_quat( q, pos );\n  return mul_quat( tmp, qr );\n}\n\nfloat plane( vec3 p ) {\n  return p.y;\n}\n\nfloat sphere( vec3 p, float r ) {\n  return length(p) - r;\n}\n\nfloat box( vec3 p, vec3 b ) {\n  return length( max( abs( p.xyz ) - b.xyz, vec3( 0.0 ) ) );\n}\n\nvec2 opU( vec2 o1, vec2 o2 ) {\n  if (o1.x < o2.x) {\n    return o1;\n  }\n  else {\n    return o2;\n  }\n}\n\nfloat hash( float n ) {\n  return ( sin( 21312.1 * n + 231.2 ));\n}\n\nfloat speed = 0.3;\nvec3 bp;\n\nvec2 map( vec3 p ) {\n  vec2 res = vec2( plane( p - vec3( 0.0, -0.3, 0.0) ), 0.0 );\n\n  //Rotate the space.\n  //vec3 rp = rotate( p - vec3( 0.0, 0.2, 0.0 ), normalize( vec3( 0.4, 0.6, 0.3 ) ), iTime * 1.0 * pi/6.0 ).xyz;\n  //rp = rotate( rp, vec3( 0.0, 1.0, 0.0 ), pi/4.0 ).xyz;\n  //rp = rotate( rp, vec3( 0.0, 1.0, 0.0 ), 2.0 * iTime * pi ).xyz;\n  //p.xz = mod( p.xz , 0.5 );\n\n  res = opU( res, vec2( sphere( p - bp, 0.3 ), 1.0 ) );\n\n  p.y -= 0.1 * floor(  p.x * 6.0  );\n  //res = opU( res, vec2( box( p - vec3( 0.0, 0.2, 0.0 ) , vec3( 1.3, 0.1, 0.7 ) ), 1.0 ) );\n\n\n  return res;\n}\n\nvec3 getNormal( vec3 p ) {\n  vec2 e = vec2( precis, 0.0 );\n  return normalize(vec3( map( p + e.xyy ).x - map( p - e.xyy ).x,\n                         map( p + e.yxy ).x - map( p - e.yxy ).x,\n                         map( p + e.yyx ).x - map( p - e.yyx ).x\n                       ) );\n}\n\nfloat raymarching( vec3 ro, vec3 rd ) {\n\n  float t = 0.0;\n  for ( int i = 0; i < 512; i++ ) {\n\n    float dist = map( ro + rd * t ).x;\n    if ( dist < precis || t > tmax ) {\n      break;\n    }\n\n    t = t + dist * 1.0;\n  }\n\n  return t;\n}\n\nfloat softShadow( vec3 ro, vec3 rd ) {\n  float t = 1.0;\n  float res = 1.0;\n  for ( int i = 0; i < 128; i++ ) {\n\n    float dist = map( ro + rd * t ).x;\n    t = t + dist;\n    res = min( res, 16.0 * dist / t );\n    if ( res < precis || t > tmax ) {\n      break;\n    }\n  }\n\n  return clamp( res, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  uv.y *= iResolution.y / iResolution.x;\n  uv = uv * 2.0 - 1.0;\n  bp = vec3( -iTime * speed, 0.5 * abs( sin( iTime * 1.0 ) ), iTime * speed );\n  vec3 rd = vec3( uv.xy, 1.0 );\n  rd.y += 0.3;\n  rd = normalize(rd);\n  float time = iTime;\n  float radY = -pi * iMouse.x * 0.004 + pi ;\n  float radX = pi * 0.0 - pi * iMouse.y * 0.002;\n  radX = clamp( radX, -pi * 0.5, pi * 0.15 );\n  rd = rotate( rd, vec3( 0.0, 1.0, 0.0 ), -radY ).xyz;\n  vec3 xAxis = rotate( vec3( 1.0, 0.0, 0.0 ), vec3( 0.0, 1.0, 0.0 ), -radY ).xyz;\n  vec3 zAxis = rotate( vec3( 0.0, 0.0, 1.0 ), vec3( 0.0, 1.0, 0.0 ), -radY ).xyz;\n  rd = rotate( rd, xAxis, -radX ).xyz;\n  zAxis = rotate( zAxis, xAxis, -radX ).xyz;\n  vec3 ro = vec3( bp.x, 0.0, bp.z) - zAxis * 1.2;\n  ro.y += 0.26;\n\n  vec3 color = vec3( 0.0, 0.4, 0.8 );\n  color = mix( color, vec3( 0.1 ), uv.y );\n  //color = vec3( 0.1 );\n\n  float t = raymarching( ro, rd );\n  vec3 ld = normalize( vec3( -0.1, -1.0, -0.8 ) );\n\n  //if miss the scene\n  if ( t > tmax ) {\n    float sun = clamp( dot(-ld, rd), 0.0, 1.0 );\n    color += 1.9 * vec3( 0.7, 0.8, 0.2) * pow( sun, 3.0 );\n  }\n  else {\n    vec3 hit = ro + t * rd;\n    vec2 res = map( hit );\n    vec3 n = getNormal( hit );\n    float sh = 1.0;\n    float dif = clamp( dot( -ld, n ), 0.0, 1.0 ) + 0.2;\n\n    if ( dif > 0.21 ) {\n      sh = softShadow( hit + ld * 0.5, normalize( -ld ) );\n    }\n    vec3 difftex = vec3( 1.0 );\n    vec3 sepctex = vec3( 1.0 );\n\n    //Floor texture.\n    if ( res.y == 0.0 ) {\n      difftex = mod( floor( hit.x * 10.0 ) + floor( hit.z * 10.0 ), 2.0 ) * vec3( 0.7 );\n      sepctex = vec3( 0.0 );\n      difftex = texture( iChannel1, vec2( hit.x , hit.z ) ).xyz;\n      //difftex = vec3( 0.4 );\n    }\n    else if ( res.y == 1.0 ) {\n      vec3 sp = ( hit.xyz - bp ) / 0.3;\n      vec3 piv = normalize( vec3( 2.0, 0.0, 1.0 ) );\n      sp = rotate( sp, piv,  -pi * 0.1 - 3.0 * iTime ).xyz;\n      float u = ( atan( sp.x, sp.z ) ) / ( 2.0 * pi ) + 0.5;\n      float v = asin( sp.y ) / pi + 0.5;\n      difftex = texture( iChannel0, vec2( u, v ) ).xyz;\n\n      float v1 = asin( sp.z ) / pi + 0.5;\n\n      if ( v1 > 0.4 && v1 < 0.6 ) {\n        difftex = vec3( 0.0, 0.4, 0.8 );\n      }\n\n      difftex += 0.2 * texture( iChannel2, reflect( -rd, n ) ).xyz;\n      sepctex = vec3( 1.0 );\n    }\n\n    //dif = 1.0;\n    //sh = 1.0;\n\n    vec3 diffCol = difftex * dif * sh;\n    vec3 specCol = sepctex * pow( max( 0.0, dot( rd, reflect( -ld, n ) ) ), 110.0 );\n    color = diffCol + specCol + ambi;\n  }\n\n\n\n  uv = fragCoord.xy / iResolution.xy;\n  //color = texture( iChannel0, uv.xy ).xyz;\n  fragColor = vec4( color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi 3.14\nconst float indent = 0.1;\nfloat angular = 5.0;\n\nfloat drawStar(vec2 o, float size, float startAngle) {\n  vec2 q = o;\n  q *= normalize(iResolution).xy;\n  mat4 RotationMatrix = mat4( cos( startAngle ), -sin( startAngle ), 0.0, 0.0,\n                              sin( startAngle ),  cos( startAngle ), 0.0, 0.0,\n                              0.0,           0.0, 1.0, 0.0,\n                              0.0,           0.0, 0.0, 1.0 );\n  q = (RotationMatrix * vec4(q, 0.0, 1.0)).xy;\n  float angle = atan( q.y, q.x ) / (2.*pi);\n  float segment = angle * angular;\n  float segmentI = floor(segment);\n  float segmentF = fract(segment);\n\n  angle = (segmentI + 0.5) / angular;\n\n  if (segmentF > 0.5) {\n\n    angle -= indent;\n  }\n  else\n  {\n\n    angle += indent;\n  }\n  angle *= 2.0 * pi;\n\n  vec2 outline;\n  outline.y = sin(angle);\n  outline.x = cos(angle);\n  float dist = abs(dot(outline, q));\n  float ss = size;\n  float r = angular * ss;\n  float star = smoothstep( r, r + 0.005, dist );\n  return star;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 p = uv;\n  p.y *= iResolution.y / iResolution.x;\n  vec3 color = vec3( 1.0, 1.0, 0.0 );\n  float star = drawStar( uv - vec2( 0.5, 0.5 ), 0.0045, pi / 4.0  );\n  color = mix( vec3( 0.9, 0.1, 0.2 ), color, star );\n  fragColor = vec4( color.xyz, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}