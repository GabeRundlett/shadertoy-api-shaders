{
    "Shader": {
        "info": {
            "date": "1707360501",
            "description": "My Desktop Background",
            "flags": 0,
            "hasliked": 0,
            "id": "X3sGDr",
            "likes": 1,
            "name": "Rugg0064DesktopBackground",
            "published": 3,
            "tags": [
                "desktop"
            ],
            "usePreview": 0,
            "username": "Rugg0064",
            "viewed": 162
        },
        "renderpass": [
            {
                "code": "\nmat2 skewMatrix = mat2(1.0, -0.5, \n                       0, sqrt(3.0)/2.0);\nmat2 unskewMatrix = mat2(1.0, 1.0/sqrt(3.0), \n                         0, 2.0/sqrt(3.0));\n\nvec2 skew(vec2 point) {\n    return point * skewMatrix;\n}\n\nvec2 unskew(vec2 point) {\n    return point * unskewMatrix;\n}\n\n/*\nfloat skewF3D = -(1.0/6.0);\nfloat skewG3D = (1.0/3.0);\nvec2 skew(vec2 point) {\n    float product = (point.x + point.y) * skewG3D;\n    return vec2(\n        point.x + product,\n        point.y + product\n    );\n}\n\nvec2 unskew(vec2 point) {\n    float product = (point.x + point.y) * skewF3D;\n    return vec2(\n        point.x + product,\n        point.y + product\n    );\n}\n*/\n\n// MurmurHash3 32-bit hash function\nint murmurHash32(int h) {\n    h ^= h >> 16;\n    h *= 0x85ebca6b;\n    h ^= h >> 13;\n    h *= 0xc2b2ae35;\n    h ^= h >> 16;\n    return h;\n}\n\n// Function to generate random vec2 based on ivec2 seed\nvec2 randomVec2(ivec2 seed) {\n    // Combine the x and y components of the seed into a single value\n    int combinedSeed = int(seed.x) * 73856093 + int(seed.y) * 19349663;\n    \n    // Hash the combined seed to generate a pseudorandom value\n    int hashValue = murmurHash32(combinedSeed);\n    \n    // Use the hash value to generate random x and y coordinates in the range [0, 1]\n    float randomX = float(hashValue & 0xFFFF) / 65535.0;\n    float randomY = float((hashValue >> 16) & 0xFFFF) / 65535.0;\n    \n    // Return the random vec2 coordinates\n    return normalize(vec2(randomX, randomY));\n}\n\nfloat handleSimplexVertex(vec2 target, vec2 unskewedCoordinate, vec2 direction) {\n    float dist = distance(target, unskewedCoordinate);\n\n    float value = dist;\n\n    //float squareDistance = dist * dist;\n    //float value = max(0.0, 0.5 - squareDistance);\n    //value = pow(value, 4.0);\n\n    vec2 directionCoordinateToTarget = target - unskewedCoordinate;\n    float dotTo = dot(directionCoordinateToTarget, direction);\n    value *= dotTo;\n    return dotTo;\n}\n\nvec2 floorSmart(vec2 point) {\n    vec2 floored = floor(point);\n    if (point.x < 0.0) {\n        floored.x -= 1.0;\n    }\n    if (point.y < 0.0) { \n        floored.y -= 1.0;\n    }\n    return floored;\n}\n\nfloat mainEffect( vec2 fragCoord, float cubeGridSize )\n{\n    // Turn the pixel coordinate into the domain [0,1]\n    vec2 uv = fragCoord;\n    // vec2 uv = fragCoord;\n\n    // Skew this coordinate into the square-domain\n    vec2 uvSkew = unskew(uv);\n    vec2 uvSkewScaled = uvSkew / cubeGridSize;\n\n    // Get the bottom-left square that the skewed point is in\n    ivec2 lowLeftIndex = ivec2(floorSmart(uvSkewScaled));\n    // Compute which simplex and index the point is in\n    ivec2 middleOffset = (fract(uvSkewScaled.x) >= fract(uvSkewScaled.y)) ? ivec2(1, 0) : ivec2(0, 1);\n    ivec2 middleIndex = lowLeftIndex + middleOffset;\n    ivec2 topRightIndex = lowLeftIndex + ivec2(1, 1);\n\n    // Turn the vertices of the simplex into random vectors\n    vec2 lowLeftDirection = randomVec2(lowLeftIndex + ivec2(1, 1));\n    vec2 middleDirection = randomVec2(middleIndex + ivec2(1, 1));\n    vec2 topRightDirection = randomVec2(topRightIndex + ivec2(1, 1));\n\n    // Convert the indices into actual coordinates on our UV space\n    // Conver to float, then div/20, then unskew\n    vec2 lowLeftPosition =  unskew(vec2(lowLeftIndex) * cubeGridSize);\n    vec2 middlePosition =   unskew(vec2(middleIndex) * cubeGridSize);\n    vec2 topRightPosition = unskew(vec2(topRightIndex) * cubeGridSize);\n\n    float result = handleSimplexVertex(uv, lowLeftPosition, lowLeftDirection)\n        + handleSimplexVertex(uv, middlePosition, middleDirection)\n        + handleSimplexVertex(uv, topRightPosition, topRightDirection);\n    result = result * 1.0;\n    result += 0.0;\n    //vec3 col = vec3(result, result, result);\n\n    float distance1 = distance(uv, lowLeftPosition);\n    float distance2 = distance(uv, middlePosition);\n    float distance3 = distance(uv, topRightPosition);\n    float dot1 = dot(uv - lowLeftPosition, lowLeftDirection);\n    float dot2 = dot(uv - middlePosition, middleDirection);\n    float dot3 = dot(uv - topRightPosition, topRightDirection);\n    result = min(distance1, min(distance2, distance3));\n    result = distance1+distance2+distance3;\n    result = dot1+dot2+dot3;\n    vec2 resultVec2 = lowLeftDirection + middleDirection + topRightDirection;\n    resultVec2 /= 3.0;\n    float value = resultVec2.x;\n    value = (value * 0.7) + 0.1;\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float multiplier1 = 0.90 + max(0.0, pow(cos(iTime*2.0 - uv.x-uv.y), 9.0))*0.10;\n        \n    float out1 = mainEffect(fragCoord + vec2(iTime/2.0), 15.0);\n    float out2 = mainEffect(fragCoord, 30.0);\n    float out3 = mainEffect(fragCoord, 60.0);\n    float out4 = mainEffect(fragCoord, 120.0);\n    float out5 = \n        out2*0.1 +\n        out3*0.1 +\n        out4*0.8;\n    out5 *= multiplier1;\n\n    // Output to screen\n    fragColor = vec4(out5 * 0.3, out5 * 0.7, out5, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}