{
    "Shader": {
        "info": {
            "date": "1685313407",
            "description": "All year long I'm going to just focus on truchet tiles and the likes!\n(mouseable)",
            "flags": 0,
            "hasliked": 0,
            "id": "cltSzN",
            "likes": 13,
            "name": "Year of Truchets #026",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "truchet"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 219
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #026\n    05/28/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI         3.141592653\n#define PI2        6.283185307\n\n#define MAX_DIST    35.\n#define MIN_DIST    1e-4\n\n// globals\nvec3 hit,hitPoint;\nmat2 r90,r45;\nfloat ghs,shs,sd,gd,tspeed=0.,tmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.,gtk,stk;\n\n// constants\nconst float size = 1.15;\nconst float hlf = size/2.;\nconst float db = size*5.;\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 p){return fract(sin(dot(p, vec2(27.609,47.983)+iDate.z))*43758.5453);}\nfloat lsp(float b, float e, float t){return clamp((t-b)/(e-b),0.,1.); }\nfloat eoc(float t){return (t = t-1.)*t*t+1.; }\n\n//@iq sdf & extrude\nfloat cap( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat opx(in float sdf, in float pz, in float h){\n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nvec2 map(vec3 pos){\n    vec2 res = vec2(1e5,0);\n\n    vec2 uv = pos.xz+vec2(ga1,ga2);\n    vec2 r = (uv*size)-.5;\n    vec2 ir = floor(r);\n    \n    vec2 id = floor(uv*size);\n    float rnd = hash21(id);\n    float xnd = fract(rnd*32.323);\n\n    r = fract(r)-.5;\n    vec2 q = fract(uv*size)-.5;\n    if (rnd>.5) q.x=-q.x; \n   \n    vec2 cv = vec2(length(q-.5),length(q+.5));\n    vec2 p = cv.x<cv.y?q-.5:q+.5;\n    \n    float thc = .05;\n    float k = length(p)-.5;k = abs(k)-thc;\n    \n    float sw = .1+.095*sin(pos.x*1.95+ga4);\n          sw-= .1+.095*cos(pos.z*2.25+ga3);\n    ghs = sw;\n    \n    if(xnd>.75) k = min(length(q.x)-thc,length(q.y)-thc);\n    gd = k;\n    \n    float d = opx(k-.07,pos.y,.25)-.05;\n    float d3= opx(abs(k)-.03,pos.y+sw-.225,.015)-.005;\n    \n    if(d3<res.x) {\n        res = vec2(d3,2.);\n        hit=vec3(q.x,pos.y,q.y);\n    }\n   \n    float hs = hash21(ir);\n    float b = cap(vec3(r.x,pos.y,r.y),.45,.15);\n    if(b<res.x&&hs>.6) {\n        res = vec2(b,4.);\n        hit=pos+vec3(ga1,0,ga2);\n    }\n\n    float gnd = pos.y+.01;\n    float gnt = d-.001;\n    gnd = max(gnd,-gnt);\n \n    if(gnd<res.x) {\n        res = vec2(gnd,gnt<gnd?3.:1.);\n        hit=pos+vec3(ga1,0,ga2);\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int steps) {\n    float d = 0., m = 0.;\n    for(int i=0;i<steps;i++){\n        vec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32?ray.x*.35:ray.x*.85;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\n//@iq hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0,4,2),6.)-3.)-1., 0., 1. );\n\treturn c.z * mix( vec3(1), rgb, c.y);\n}\n\nvec4 FC = vec4(0.192,0.227,0.227,0.);\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, float last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    vec2 ray = marcher(ro,rd,128);\n    d=ray.x;m=ray.y;\n    \n    hitPoint = hit;  \n    shs = ghs;\n    sd = gd;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        \n        vec3 lpos =vec3(15.,35.,35.);\n        vec3 l = normalize(lpos-p);\n        \n        float diff = clamp(dot(n,l),.09,.99);\n        \n        float shdw = 1.;\n        for( float t=.01; t < 12.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 12.*h/t);\n            t += h;\n            if( shdw<MIN_DIST ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n        \n        vec3 h = vec3(.25);\n        \n        if(m==1.) {\n            vec2 hp = hitPoint.xz*rot(.78);\n            vec2 f = fract(hp*24.)-.5;\n            h = mix(vec3(.15),vec3(.2),mod(floor(f.x),3.) == 0. ? 1. : 0.);  \n            \n            float px = 4./R.x;\n            float d = smoothstep(px,-px,abs(sd-.125)-.015);\n            h = mix(h, vec3(.275), d);\n            if(p.y<-.01) h = vec3(.1);\n            ref = h;\n        }\n        \n        if(m==2.) { h = hsv2rgb(vec3(shs+(p.x*.05)+T*.08,.85,.5)); ref = h; }\n        if(m==3.) { h = vec3(.025); ref = vec3(.35); }\n        if(m==4.) { h = vec3(.125); ref = vec3(.25); }\n \n        C = (diff*h);\n\n        ro = p+n*.005;\n        rd = reflect(rd,n);\n    } \n    return vec4(C,d);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    // precal\n    tspeed = T*.6;\n    tmod = mod(tspeed,12.);\n    \n    float t1 = lsp(00.,02.,tmod);\n    t1 = eoc(t1); t1 = t1*t1*t1;\n    \n    float t2 = lsp(03.,05.,tmod);\n    t2 = eoc(t2); t2 = t2*t2*t2;\n    \n    float t3 = lsp(06.,8.,tmod);\n    t3 = eoc(t3); t3 = t3*t3*t3;\n    \n    float t4 = lsp(9.,11.,tmod);\n    t4 = eoc(t4); t4 = t4*t4*t4;\n    \n    ga1 = (t1*db)-(t3*db);\n    ga2 = (t2*db)-(t4*db);\n    \n    ga3 = (t1-t3);\n    ga4 = (t2-t4);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,3.);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    float x = M.xy==vec2(0) ? 0. : -(M.y/R.y*.125-.0625)*PI;\n    float y = M.xy==vec2(0) ? 0. : -(M.x/R.x*.5-.25)*PI;\n\n    mat2 rx = rot(-.92-x), ry = rot(y+(ga3-ga4)*PI);\n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(.95);\n    float d =0.,a=0.;\n\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i, d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.)a=pass.w;\n    }\n           \n    C = mix(FC.rgb,C,exp(-.0008*a*a*a));\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}