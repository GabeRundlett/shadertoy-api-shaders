{
    "Shader": {
        "info": {
            "date": "1460393273",
            "description": "Simulating anomalous dispersion by using more than 3 virtual color channels. Mouse controls the camera.\n\nWarning: expensive shader.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xs3Szj",
            "likes": 46,
            "name": "Anomalous Dispersion",
            "published": 3,
            "tags": [
                "refraction",
                "chromatic",
                "aberration",
                "dispersion",
                "anomalous"
            ],
            "usePreview": 0,
            "username": "cornusammonis",
            "viewed": 2574
        },
        "renderpass": [
            {
                "code": "/*\n\tAnomalous Dispersion\n\n\tAnomalous dispersion is a real-life phenomenon where the wavelength/IOR\n\tcurve of a material does not decrease monotonically. These discontinuities \n    occur in a variety of materials outside\tthe visible spectrum, but for \n    a few materials the effect is visible to the human eye.\n\n\tIn order to simulate anomalous dispersion, we need more than just the usual 3 \n\twavelengths/IORs, i.e. red, green, and blue. This shader simulates an arbitrary \n    number of wavelengths and then downsamples the result into RGB, in a similar \n    way to the human eye. \n\n\tIt's best to use a large number of wavelengths to limit banding, though how \n    feasible that is depends on your GPU.\n\n\tThe scale of the anomaly and the amount of dispersion are animated to show\n    the kinds of effects this technique can produce.\n*/\n\n// performance and raymarching options\n#define WAVELENGTHS 12\t\t\t\t // number of rays of different wavelengths to simulate, should be >= 3\n#define INTERSECTION_PRECISION 0.001 // raymarcher intersection precision\n#define MIN_INCREMENT 0.01\t\t\t // distance stepped when entering the surface of the distance field. should be about 10x INTERSECTION_PRECISION\n#define ITERATIONS 250\t\t\t\t // max number of iterations\n#define MAX_BOUNCES 6\t\t\t\t // max number of reflection/refraction bounces\n#define AA_SAMPLES 1\t\t\t\t // anti aliasing samples\n#define BOUND 6.0\t\t\t\t\t // cube bounds check\n#define DIST_SCALE 1.0\t\t\t\t // scaling factor for raymarching position update\n\n// optical properties\n#define ANOMALY_SCALE 2.0\t\t\t // scale of the anomaly\n#define ANOMALY_SHARPNESS 8.0   \t // sharpness of the anomaly curve\n#define DISPERSION 0.1\t\t\t\t // dispersion amount\n#define IOR 0.414 \t\t\t\t\t // base IOR value specified as a ratio (corresponds to diamond)\n#define CRIT_ANGLE_SCALE 1.0\t\t // scaling factor for the critical angle\n#define CRIT_ANGLE_SHARPNESS 2.0\t // sharpness of the total internal reflection curve (if DISCRETE_TIR is undefined)\n#define BOUNCE_ATTENUATION_SCALE 0.5 // scales the amount of attenuation contributed by subsequent bounces\n\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\n// uncomment to use a simple threshold for total internal reflection\n//#define DISCRETE_TIR\n\n// visualize the average number of bounces for each of the rays\n//#define VISUALIZE_BOUNCES\n\n\n// Brilliant-cut diamond DF from TambakoJaguar's Diamond Test shader here: https://www.shadertoy.com/view/XdtGDj\nfloat dist(vec3 pos)\n{     \n    \n    vec3 posr = pos;\n    \n    float d = 0.94;\n    float b = 0.5;\n\n    float af2 = 4./PI;\n    float s = atan(posr.y, posr.x);\n    float sf = floor(s*af2 + b)/af2;\n    float sf2 = floor(s*af2)/af2;\n    \n    vec3 flatvec = vec3(cos(sf), sin(sf), 1.444);\n    vec3 flatvec2 = vec3(cos(sf), sin(sf), -1.072);\n    vec3 flatvec3 = vec3(cos(s), sin(s), 0);\n    float csf1 = cos(sf + 0.21);\n    float csf2 = cos(sf - 0.21);\n    float ssf1 = sin(sf + 0.21);\n    float ssf2 = sin(sf - 0.21);\n    vec3 flatvec4 = vec3(csf1, ssf1, -1.02);\n    vec3 flatvec5 = vec3(csf2, ssf2, -1.02);\n    vec3 flatvec6 = vec3(csf2, ssf2, 1.03);\n    vec3 flatvec7 = vec3(csf1, ssf1, 1.03);\n    vec3 flatvec8 = vec3(cos(sf2 + 0.393), sin(sf2 + 0.393), 2.21);\n     \n    float d1 = dot(flatvec, posr) - d;                           // Crown, bezel facets\n    d1 = max(dot(flatvec2, posr) - d, d1);                       // Pavillon, pavillon facets\n    d1 = max(dot(vec3(0., 0., 1.), posr) - 0.3, d1);             // Table\n    d1 = max(dot(vec3(0., 0., -1.), posr) - 0.865, d1);          // Cutlet\n    d1 = max(dot(flatvec3, posr) - 0.911, d1);                   // Girdle\n    d1 = max(dot(flatvec4, posr) - 0.9193, d1);                  // Pavillon, lower-girdle facets\n    d1 = max(dot(flatvec5, posr) - 0.9193, d1);                  // Pavillon, lower-girdle facets\n    d1 = max(dot(flatvec6, posr) - 0.912, d1);                   // Crown, upper-girdle facets\n    d1 = max(dot(flatvec7, posr) - 0.912, d1);                   // Crown, upper-girdle facets\n    d1 = max(dot(flatvec8, posr) - 1.131, d1);                   // Crown, star facets\n    return d1;\n}\n\n// Fresnel factor from TambakoJaguar's Diamond Test shader here: https://www.shadertoy.com/view/XdtGDj\n// see also: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.0;\n   float angle = clamp(acos(-dot(ray, norm)), -3.14/2.15, 3.14/2.15);\n   float r0 = pow((n1-n2)/(n1+n2), 2.);\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(0., 1.0, r);\n}\n\nvec3 doBackground( void ) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\nfloat doModel( vec3 p ) {\n    return dist(p/4.0);\n}\n\nvec3 calcNormal( in vec3 pos ) {\n    const float eps = INTERSECTION_PRECISION;\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nstruct Bounce\n{\n    vec3 position;\n    vec3 ray_direction;\n    float attenuation;\n    float reflectance;\n    float ior;\n    float bounces;\n    float wavelength;\n};\n    \nfloat sigmoid(float t, float t0, float k) {\n    return 1.0 / (1.0 + exp(-exp(k)*(t - t0)));  \n}\n\n// filmic gamma function from Paniq\nfloat filmic_gamma(float x) {\n    return (x*(x*6.2+0.5))/(x*(x*6.2+1.7)+0.06);\n}\n\nvec3 filmic_gamma(vec3 x) {\n    return (x*(x*6.2+0.5))/(x*(x*6.2+1.7)+0.06);\n}\n\n// inverse of the filmic gamma function\nfloat filmic_gamma_inverse(float x) {\n    x = clamp(x, 0.0, 0.99);\n\treturn (0.0016129 * (-950.329 + 1567.48*x + 85.0 * sqrt(125.0 - 106.0*x + 701.0 * x*x)))\n        /(26.8328 - sqrt(125.0 - 106.0*x + 701.0*x*x));   \n}\n\n// sample weights for the cubemap given a wavelength i\n// room for improvement in this function\nvec3 texCubeSampleWeights(float i) {\n\treturn vec3((1.0 - i) * (1.0 - i), 2.0 * i * (1.0 - i), i * i);\n}\n\nfloat sampleCubeMap(float i, vec3 rd) {\n\tvec3 col = textureLod(iChannel0, rd * vec3(1.0,-1.0,1.0), 0.0).xyz; \n    return dot(texCubeSampleWeights(i), col);\n}\n\nfloat bounce( inout Bounce b ) {\n    float td = doModel(b.position);\n    float t = DIST_SCALE * abs(td);\n    float sig = sign(td);    \n\n    vec3 pos = b.position + t * b.ray_direction;\n    \n    // bounds check, and check if we exited the diamond after entering\n    if ( clamp(pos, -BOUND, BOUND) != pos ||  sig > 0.0 && b.bounces > 1.0 || int(b.bounces) >= MAX_BOUNCES) {\n    \treturn -1.0;    \n    }\n    \n    if ( t < INTERSECTION_PRECISION ) {\n        \n    \tvec3 normal = calcNormal(pos);\n        \n        // avoid darkening too much by decreasing contribution for subsequent bounces\n        b.attenuation *= pow(abs(dot(b.ray_direction, normal)), BOUNCE_ATTENUATION_SCALE / (b.bounces + 1.0));        \n        \n        // if we're inside the diamond...\n        if(sig == -1.0) {\n            float angle = abs(acos(dot(b.ray_direction, normal)));\n            float critical_angle = abs(asin(b.ior)) * CRIT_ANGLE_SCALE;\n\n            // total internal reflection\n            #ifdef DISCRETE_TIR\n                if (angle > critical_angle) {\n                    b.ray_direction = reflect(b.ray_direction, normal);\n                } else {\n                    b.ray_direction = refract(b.ray_direction, normal, 1.0/b.ior);\n                }\n\t\t\t#else\n                vec3 refl = reflect(b.ray_direction, normal);\n                vec3 refr = refract(b.ray_direction, normal, 1.0 / b.ior);\n                float k = sigmoid(angle, critical_angle, CRIT_ANGLE_SHARPNESS);\n                b.ray_direction = normalize(mix(refr, refl, vec3(k)));\n            #endif\n        } else {\n            // cubemap reflection\n            float f = fresnel(b.ray_direction, normal, 1.0 / b.ior);\n            float texCubeSample = sampleCubeMap(b.wavelength, reflect(b.ray_direction, normal));\n            b.reflectance += filmic_gamma_inverse(mix(0.0, texCubeSample, f));\n            b.ray_direction = refract(b.ray_direction, normal, b.ior);\n        }\n\n        b.position = pos + MIN_INCREMENT * b.ray_direction;\n        b.bounces += 1.0;\n        \n    } else {\n    \tb.position = pos;\n    }\n    \n    return 1.0;\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec4 m ) {\n    if (max(m.z, m.w) <= 0.0) {\n    \tfloat an = 1.5 + sin(-time * 0.1 - 0.38) * 4.0;\n        float bn = -2.0 * cos(-time * 0.1 - 0.38);\n\t\tcamPos = vec3(6.5*sin(an), bn ,6.5*cos(an));\n    \tcamTar = vec3(0.0,0.0,0.0);     \n    } else {\n    \tfloat an = 10.0 * m.x - 5.0;\n\t\tcamPos = vec3(6.5*sin(an),10.0 * m.y - 5.0,6.5*cos(an));\n    \tcamTar = vec3(0.0,0.0,0.0);  \n    }\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// MATLAB Jet color scheme\nvec3 jet(float x) {\n\n   x = clamp(x, 0.0, 1.0);\n\n   if (x < 0.25) {\n       return(vec3(0.0, 4.0 * x, 1.0));\n   } else if (x < 0.5) {\n       return(vec3(0.0, 1.0, 1.0 + 4.0 * (0.25 - x)));\n   } else if (x < 0.75) {\n       return(vec3(4.0 * (x - 0.5), 1.0, 0.0));\n   } else {\n       return(vec3(1.0, 1.0 + 4.0 * (0.75 - x), 0.0));\n   }\n   \n}\n\n// 4PL curve fit to experimentally-determined values\nfloat greenWeight() {\n    float a = 4569547.0;\n    float b = 2.899324;\n    float c = 0.008024607;\n    float d = 0.07336188;\n\n    return d + (a - d) / (1.0 + pow(log(float(WAVELENGTHS))/c, b)) + 2.0;    \n}\n\n// sample weights for downsampling to RGB. Ideally this would be close to the \n// RGB response curves for the human eye, instead I use a simple ad hoc solution here.\n// Could definitely be improved upon.\nvec3 sampleWeights(float i) {\n\treturn vec3((1.0 - i) * (1.0 - i), greenWeight() * i * (1.0 - i), i * i);\n}\n\n// downsample to RGB\nvec3 resampleColor(Bounce[WAVELENGTHS] bounces) {\n    vec3 col = vec3(0.0);\n    \n    for (int i = 0; i < WAVELENGTHS; i++) {        \n        float reflectance = bounces[i].reflectance;\n        float index = float(i) / float(WAVELENGTHS - 1);\n        float texCubeIntensity = filmic_gamma_inverse(\n            clamp(bounces[i].attenuation * sampleCubeMap(index, bounces[i].ray_direction), 0.0, 0.99)\n        );\n    \tfloat intensity = texCubeIntensity + reflectance;\n        col += sampleWeights(index) * intensity;\n    }\n\n    return 1.4 * filmic_gamma(3.0 * col / float(WAVELENGTHS));\n}\n\n// compute average number of bounces for the VISUALIZE_BOUNCES render mode\nfloat avgBounces(Bounce[WAVELENGTHS] bounces) {\n    float avg = 0.0;\n    \n    for (int i = 0; i < WAVELENGTHS; i++) {        \n         avg += bounces[i].bounces;;\n    }\n\n    return avg / float(WAVELENGTHS);\n}\n\n// compute the wavelength/IOR curve values. Theoretically the second derivative \n// of any sigmoid function would work here, but many of them have problems with\n// discontinuities and under/overflow. The function used here is the wavelength \n// plus the second derivative of the sigmoid function x / (1.0 + abs(x))^p.\nfloat iorCurve(float x, float anomalyScale, float anomalySharpness) {\n\treturn x - sin(0.5 * iTime) * sign(x - 0.5) * anomalyScale/pow(1.0+abs(x-0.5),anomalySharpness);\n}\n\nBounce initialize(vec3 ro, vec3 rd, float i) {\n    i = i / float(WAVELENGTHS - 1);\n    float ior = IOR + iorCurve(1.0 - i, ANOMALY_SCALE, ANOMALY_SHARPNESS) * sin(iTime * 0.67) * DISPERSION;\n    return Bounce(ro, rd, 1.0, 0.0, ior, 1.0, i); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec4 m = vec4(iMouse.xy/iResolution.xy, iMouse.zw);\n\n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );\n    \n    float dh = (0.5 / iResolution.y);\n    const float rads = TWO_PI / float(AA_SAMPLES);\n    \n    Bounce bounces[WAVELENGTHS];\n    \n    vec3 col = vec3(0.0);\n    \n    for (int samp = 0; samp < AA_SAMPLES; samp++) {\n        vec2 dxy = dh * vec2(cos(float(samp) * rads), sin(float(samp) * rads));\n        vec3 rd = normalize(camMat * vec3(p.xy + dxy, 1.5)); // 1.5 is the lens length\n\n        for (int i = 0; i < WAVELENGTHS; i++) {\n            bounces[i] = initialize(ro, rd, float(i));    \n        }\n\n        for (int i = 0; i < WAVELENGTHS; i++) {\n            for (int j = 0; j < ITERATIONS; j++) {\n                if(bounce(bounces[i]) == -1.0) break;\n            }\n        }\n\n        #ifdef VISUALIZE_BOUNCES\n        \tcol += jet(avgBounces(bounces) / float(MAX_BOUNCES));\n        #else\n        \tcol += resampleColor(bounces);\n        #endif\n    }\n    \n    col /= float(AA_SAMPLES);\n\t   \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}