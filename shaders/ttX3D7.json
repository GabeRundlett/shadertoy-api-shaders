{
    "Shader": {
        "info": {
            "date": "1556507665",
            "description": "Still re-uploading",
            "flags": 0,
            "hasliked": 0,
            "id": "ttX3D7",
            "likes": 18,
            "name": "SoC with DEL",
            "published": 3,
            "tags": [
                "soc",
                "del"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 902
        },
        "renderpass": [
            {
                "code": "// SoC with DEL by eiffie (adding Distance Estimated Light to the Sphere of Confusion renderer)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define time iTime\n#define size iResolution\n\nfloat pixelSize,focalDistance,aperture,fudgeFactor=0.78,shadowCone=0.5;\n\nbool bColoring=false;\nvec3 mcol;\nmat2 rmx;\nconst vec4 p0=vec4(0.0,0.0,4.0,1.0);\nconst vec3 rc=vec3(2.633,0.033,2.133);\nvec2 DE(in vec3 z0){//amazing box by tglad\n vec4 z = vec4(z0,1.0);float r2=10.0;\n for (int n = 0; n < 3; n++) {\n  z.xzy=clamp(z.xyz, -1.0, 1.0) *2.0-z.xyz;\n  z*=2.0/clamp(dot(z.xyz,z.xyz),0.1,1.0);\n  z+=p0;\n  if(n==1)r2=length(z.xyz)/z.w;//distance to light\n  z.xy=z.xy*rmx;\n }\n if(bColoring)mcol+=vec3(0.7,0.6,0.4)+z.xyz*0.2;\n z.xyz=max(abs(z.xyz)-rc,vec3(0.0));\n return vec2((length(z.xyz)-0.1)/z.w,r2);//returns distance to surface and light\n}\n\nfloat CircleOfConfusion(float t){//calculates the radius of the circle of confusion at length t\n return max(abs(focalDistance-t)*aperture,pixelSize*(1.0+t));\n}\nmat3 lookat(vec3 fw,vec3 up){\n fw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\nfloat linstep(float a, float b, float t){return clamp((t-a)/(b-a),0.,1.);}// i got this from knighty and/or darkbeam\n//random seed and generator\nvec2 randv2;\nfloat rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n randv2+=vec2(1.0,1.0);\n return fract(sin(dot(randv2 ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat FuzzyShadow(vec3 ro, vec3 rd, float lightDist, float coneGrad, float rCoC){\n float t=0.01,d=1.0,s=1.0;\n for(int i=0;i<4;i++){\n  if(t>lightDist)continue;\n  float r=rCoC+t*coneGrad;//radius of cone\n  d=DE(ro+rd*t).x+r*0.66;\n  s*=linstep(-r,r,d);\n  t+=abs(d)*(0.8+0.2*rand2());\n }\n return clamp(s,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n randv2=fract(cos((fragCoord.xy+fragCoord.yx*vec2(100.0,100.0))+vec2(time)*10.0)*1000.0);\n pixelSize=1.0/size.y;\n float tim=time*0.25;//camera, lighting and object setup\n float ct=cos(tim),st=sin(tim);\n rmx=mat2(ct,-st,st,ct);\n float z=cos(tim*0.3)*5.0;\n vec3 ro=vec3(vec2(ct,st)*(abs(z)+0.1)*(1.0+sin(tim*0.1)),z);\n focalDistance=min(length(ro)+0.001,1.0);\n aperture=0.007*focalDistance;\n vec3 rd=lookat(-ro,vec3(0.0,1.0,0.0)-sin(ro)*0.1)*normalize(vec3((2.0*fragCoord.xy-size.xy)/size.y,2.0));\n vec3 lightColor=vec3(1.0,0.5,0.25);\n vec4 col=vec4(0.0);//color accumulator, .w=alpha\n float t=0.0,mld=100.0;//distance traveled, minimum light distance\n for(int i=1;i<72;i++){//march loop\n  if(col.w>0.9 || t>15.0)break;//bail if we hit a surface or go out of bounds\n  float rCoC=CircleOfConfusion(t);//calc the radius of CoC\n  vec2 D=DE(ro);\n  float d=D.x+0.33*rCoC;\n  float lightDist=D.y;//the distance estimate to light\n  mld=min(mld,lightDist);//the minimum light distance along the march\n  if(d<rCoC){//if we are inside the sphere of confusion add its contribution\n   vec3 p=ro-rd*abs(d-rCoC);//back up to border of SoC\n   mcol=vec3(0.0);//clear the color trap\n   bColoring=true;//collecting color samples with normal deltas\n   vec2 v=vec2(rCoC*0.5,0.0);//use normal deltas based on CoC radius\n   vec3 N=normalize(vec3(-DE(p-v.xyy).x+DE(p+v.xyy).x,-DE(p-v.yxy).x+DE(p+v.yxy).x,-DE(p-v.yyx).x+DE(p+v.yyx).x));\n   bColoring=false;\n   if(N!=N)N=-rd;//if no gradient assume facing us\n   v=vec2(lightDist,0.0);//now find the closest light's general direction\n   vec3 L=-normalize(vec3(-DE(p-v.xyy).y+DE(p+v.xyy).y,-DE(p-v.yxy).y+DE(p+v.yxy).y,-DE(p-v.yyx).y+DE(p+v.yyx).y));\n   float lightStrength=1.0/(1.0+lightDist*lightDist*20.0);\n   vec3 scol=mcol*0.2*(0.2+0.4*(1.0+dot(N,L)))*lightStrength;//average material color * diffuse lighting * attenuation\n   scol+=pow(max(0.0,dot(reflect(rd,N),L)),8.0)*lightColor;//specular lighting\n   scol*=FuzzyShadow(p,L,lightDist*0.5,shadowCone,rCoC);//now stop the shadow march at light distance\n   col.rgb+=lightColor/(0.5+mld*mld*5000.0)*(1.0-col.w);//add a bloom around the light\n   mld=100.0;//clear the minimum light distance for the march\n   float alpha=fudgeFactor*(1.0-col.w)*linstep(-rCoC,rCoC,-d);//calculate the mix like cloud density\n   col=vec4(col.rgb+scol*alpha,clamp(col.w+alpha,0.0,1.0));//blend in the new color \n  }//move the minimum of the object and light distance\n  d=abs(fudgeFactor*min(d,lightDist+0.33*rCoC)*(0.8+0.2*rand2()));//add in noise to reduce banding and create fuzz\n  ro+=d*rd;//march\n  t+=d;\n }//mix in background color\n vec3 scol=lightColor/(0.5+mld*mld*5000.0);//add one last light bloom\n col.rgb+=scol*(1.0-col.w);\n\n fragColor = vec4(clamp(col.rgb,0.0,1.0),1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}