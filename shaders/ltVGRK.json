{
    "Shader": {
        "info": {
            "date": "1475591885",
            "description": "mouse x: adjust the camera move\nmouse y: the height of legs' movement \n\nQ1: Is it possible to do smin between bodies of the centipede?\n\nQ2: How can I detect collision between legs and the floor correctly without displace the shape?",
            "flags": 0,
            "hasliked": 0,
            "id": "ltVGRK",
            "likes": 10,
            "name": "A centipede",
            "published": 3,
            "tags": [
                "ik",
                "insect"
            ],
            "usePreview": 0,
            "username": "erucipe",
            "viewed": 958
        },
        "renderpass": [
            {
                "code": "// bunch of remix codes from iq, Shane, nimitz\n\nconst float pi = 3.141592;\n\nfloat tri(in float x) {\n\treturn abs(fract(x)-.5);\n}\n\nvec3 tri33(in vec3 x){return abs(x-floor(x)-.5);} \nfloat surfFunc(in vec3 p){\n\treturn dot(tri33(p*0.5 + tri33(p*0.25).yzx), vec3(0.666));\n}\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sdFloor(vec3 p) {\n\treturn p.y + 0.4 * surfFunc(p + vec3(0.0, 0.0, iTime));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float ra, float rb) {\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h) - mix(ra, rb, h);\n}\n\nvec2 opU( vec2 d1, vec2 d2 ) {\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat smin( float a, float b, float k ) {\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 smin( vec2 a, vec2 b, float k ) {\n\tfloat h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 smaxP(vec2 a, vec2 b, float s){    \n\tfloat h = clamp( 0.5 + 0.5*(a.x-b.x)/s, 0., 1.);\n\treturn mix(b, a, h) + h*(1.0-h)*s;\n}\n\nvec4 solve(vec2 p1, float r1, vec2 p2, float r2) {\n\tvec2 p = p2 - p1;\n\tfloat d = length(p);\n\tfloat k = (d * d + r1 * r1 - r2 * r2) / (2.0 * d);\n\tfloat s = sqrt(r1 * r1 - k * k);\n\tfloat x1 = p1.x + (p.x * k) / d + (p.y / d) * s;\n\tfloat y1 = p1.y + (p.y * k) / d - (p.x / d) * s;\n\tfloat x2 = p1.x + (p.x * k) / d - (p.y / d) * s;\n\tfloat y2 = p1.y + (p.y * k) / d + (p.x / d) * s;\n\t\n\treturn vec4(x1, y1, x2, y2);\n}\n\nvec2 map(vec3 p) {\n\tvec2 d = vec2(100.0, 0.0);\n\td = opU(d, vec2(sdFloor(p), 3.0));\n\tfloat s = d.x - p.y;\n\tp.y += s;\n\tfloat z = p.z;\n\tfloat phase = sin(z) * 3.14;\n\tfloat z0 = mod(p.z, 0.25) - 0.125;\n    float z1 = mod(z - 0.25, 0.5) - 0.25;\n    float z2 = mod(z, 0.5) - 0.25;\n    p.z = smin(pow(z1 * z2, 0.6), z0, 0.1);\n    p.z = pow(z1 * z2, 0.8);\n    p.z = z0;\n\tfloat t = iTime * 10.0;\n\tvec3 center = vec3(0.1 * sin(z + iTime * 4.0), 0.5, 0.0);\n\tvec3 joint_r = vec3(-0.4, 0.4, 0.0); \n\tvec3 joint_l = vec3(0.4, 0.4, 0.0);\n\tfloat h = iMouse.y / iResolution.y;\n    h = iMouse.y == 0.0 ? 0.5 : h;\n\tvec3 foot_r = vec3(-0.5, h * (0.5 + 0.5 * sin(t + phase)), 0.0); \n\tvec3 foot_l = vec3(0.5, h * (0.5 + 0.5 * sin(t + pi + phase)), 0.0);\n\tjoint_r.xy = solve(center.xy, 0.4, foot_r.xy, 0.4).xy;\n\tjoint_l.xy = solve(center.xy, 0.4, foot_l.xy, 0.4).zw;\n\t\n\td = opU(d, vec2(sdCapsule(p, center, joint_l, 0.05, 0.02), 2.0));\n\td = opU(d, vec2(sdCapsule(p, joint_l, foot_l, 0.02, 0.01), 2.0));\n\td = opU(d, vec2(sdCapsule(p, center, joint_r, 0.05, 0.02), 2.0));\n\td = opU(d, vec2(sdCapsule(p, joint_r, foot_r, 0.02, 0.01), 2.0));\n    \n    float d1 = sdSphere(vec3(p.xy, z1) - center, 0.1);\n    float d2 = sdSphere(vec3(p.xy, z2) - center, 0.1);\n    float body = smin(d1, d2, 0.2);\n\td = smin(d, vec2(body, 2.2), 0.1);\n\t\n\treturn d;\n}\n\nvec3 calcNormal(vec3 p) {\n\tvec2 e = vec2(-1.0, 1.0) * 0.001;\n\treturn normalize(\n\t\te.xyy * map(p + e.xyy).x +\n\t\te.yxy * map(p + e.yxy).x + \n\t\te.yyx * map(p + e.yyx).x + \n\t\te.xxx * map(p + e.xxx).x\n\t);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax ) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<16; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t ).x;\n\t\tres = min( res, 32.0*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = ( fragCoord.xy - 0.5 * iResolution.xy ) / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\tvec3 ro = vec3((mouse.x - 0.5) * 10.0, 2.0, 6.0);\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 cw = normalize(ta - ro);\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize(cross(cw, up));\n\tvec3 cv = normalize(cross(cu, cw));\n\tvec3 rd = normalize(p.x*cu + p.y*cv + 2.7*cw); \n\t\n\tfloat precis = 0.001;\n\tfloat t = 0.0;\n\tfloat h = precis * 2.0;\n\tfloat m = 0.0;\n\tfor(int i = 0; i < 120; i++) {\n\t\tif(abs(h) < precis || t > 20.0) continue;\n\t\tvec2 o = map(ro + rd * t);\n\t\th = o.x;\n\t\tm = o.y;\n\t\tt += h;\n\t}\n\t\n\tvec3 c = vec3(0.0);\n\tvec3 col = vec3(0.0);\n\tif(h < precis) {\n\t\tvec3 pos = ro + rd * t;\n\t\tvec3 ld = vec3((mouse.x - 0.5)*20.0, 10.0, 5.0) - pos;\n\t\tvec3 lig = normalize(ld);\n\t\tvec3 nor = calcNormal(pos);\n\t\tfloat dif = clamp(dot(lig, nor)*length(ld)*0.1, 0.0, 1.0);\n\t\tfloat spe = pow(clamp(dot(reflect(lig, nor), rd), 0.0, 1.0), 64.0);\n\t\tfloat sh = softshadow(pos, lig, 0.01, 10.0);\n\t\tfloat fre = 1.0 - dot(-rd, nor);\n\t\tfloat fog = 1.0 - clamp(exp(-0.2 * (pos.z + 5.0)), 0.0, 1.0);\n\t\tfloat kk = m == 3.0 ? 0.0 : m;\n\t\tcol = vec3(0.5 + 0.5 * sin(m * 0.1), 0.5 + 0.5 * sin(m * 2.0), kk * (0.5 + 0.5 * sin(pos.z * 0.5 + iTime)));\n\t\tc = 1.5 * col * (dif + spe + fre * 0.5) * (0.5 + 0.5 * sh) * fog;\n\t}\n\n\tfragColor = vec4( c, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}