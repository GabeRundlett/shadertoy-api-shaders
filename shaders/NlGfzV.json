{
    "Shader": {
        "info": {
            "date": "1664819465",
            "description": "Another derivate of iq's raymarcher and rainforst for the fbm",
            "flags": 0,
            "hasliked": 0,
            "id": "NlGfzV",
            "likes": 5,
            "name": "snowy mountain by night",
            "published": 3,
            "tags": [
                "snowsdf"
            ],
            "usePreview": 1,
            "username": "rcargou",
            "viewed": 271
        },
        "renderpass": [
            {
                "code": "#define AA 1   // make this 2 or 3 for antialiasing\n#define ZERO min(iFrame, 0)\n\nfloat fbm_4( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=ZERO; i<9; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        float amp = 0.2 * step(4., float(i));\n        x = f * m2 * x * (1.-amp);\n        \n    }\n\treturn a;\n}\n\nfloat fbm_4( in vec3 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        float amp = 0.2 * step(4., float(i));\n        x = f * m3 * x * (1.-amp);\n    }\n\treturn a;\n}\n\nvec4 fbmd_7( in vec3 x )\n{\n    float f = 1.92;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=ZERO; i<7; i++ )\n    {\n        vec4 n = noised(x);\n        a += b*n.x;          // accumulate values\t\t\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3i*m;\n    }\n\treturn vec4( a, d );\n}\n\nvec4 fbmd_8( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.65;\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=ZERO; i<8; i++ )\n    {\n        vec4 n = noised(x);\n        a += b*n.x;          // accumulate values\t\t\n        if( i<4 )\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3i*m;\n    }\n\treturn vec4( a, d );\n}\n\nfloat fbm_9( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=ZERO; i<9; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n    \n\treturn a;\n}\n\nvec3 fbmd_9( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    vec2  d = vec2(0.0);\n    mat2  m = mat2(1.0,0.0,0.0,1.0);\n    for( int i=ZERO; i<9; i++ )\n    {\n        vec3 n = noised(x);\n        a += b*n.x;          // accumulate values\t\t\n        d += b*m*n.yz;       // accumulate derivatives\n        b *= s;\n        x = f*m2*x;\n        m = f*m2i*m;\n    }\n\n\treturn vec3( a, d );\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    if ((res.x = length(pos - vec3(31.0, 14.0, 40.)) -1.5f) < .0f)\n        res.y = 2.0;\n    \n    float s = smoothstep(1., 105.3, pos.z);\n    float floorDist = pos.y  + .5 + fbm_9(pos.xz / 2.3) / 4.0\n    - s * (fbm_4(pos.xz / 30.0)) *60.;\n    if (floorDist  < res.x) {\n        res.x = floorDist;\n        res.y = 1.0;\n    }\n    \n    return res;\n    float r = 1.;\n    pos.x;// += pos.y * iTime / 50.;\n    vec2 id = floor(pos.xz * r);\n    float h = hash2(id.xy).x * 10. - iTime * 20. * (.5 + abs(hash2(id.xy).y)) / 2.;\n    vec3 pmod = vec3(mod(pos.xz, r) - vec2(r / 2.0), pos.y);\n    h = mod(h, 100.);\n    float snowflake = length(pmod*5. - vec3(0., 0., h))-0.2;\n    if (snowflake < res.x){\n        res.x = snowflake;\n        res.y = 1.0;\n    }\n    return res;\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 90.0;\n\n    // raymarch primitives   \n    {\n    \n        float t = tmin;\n        for( int i=ZERO; i<400 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.01*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x * 0.3;\n        }\n    }\n    \n    return res;\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.5;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n \n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 kMoonCol = vec3(196.0 / 255., 212.0 / 255., 304.0 / 255.);\nvec3 kDirtCol = vec3(18.0 / 255., 12.0 / 255., 35.0 / 255.);\nvec3 ndotl(vec3 light, vec3 nor, vec3 pos, vec3 ro) {\n return  kMoonCol* \n        max(.0f, dot(nor-normalize(pos - ro),  \n        light));\n}\n\nvec3 light(vec3 pos, vec3 nor, vec3 ro, vec3 rd) {\nfloat s = pow(abs(blueNoise( pos.xz / 1.) - 0.2), 4.0);\n     float sparkle = min(1.0, s); \n    vec3 ref = reflect(rd, nor);\n    vec3 l1_dir = normalize(vec3(-1.0f, 1.0f, 1.0f));\n    vec3 ret = vec3(.0);\n    ret += vec3(\n        max(.0, abs(pow(dot(ref, \n        l1_dir), 5.0) ))) * sparkle;\n    vec3 l1 = l1_dir;\n    vec3 l2 = normalize(vec3(10.0f, 1.0f, -1.0f));\n    ret += ndotl(l1, nor, pos, ro) + ndotl(l2, nor, pos, ro);\n    return ret;\n}\n\n\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in float distance ) // camera to point distance\n{\n    float fogAmount = 1.0 - exp( -distance*0.5 );\n    vec3  fogColor  = vec3(0.5,0.6,0.7) / 10.;\n    return mix( rgb, fogColor, fogAmount );\n}\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(.0f);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n    if (res.y >= 1.0 && res.x > 0.) {\n         float s = max(0., smoothstep(-1.0, 5.0, pos.y));\n         col = mix(vec3(1.0), kDirtCol, s * 1. * noise(pos.xz / 1.0));\n        \n    \tcol = col * 0.5 + light(pos, nor, ro, rd) * col;\n        col = applyFog(col, res.x / 10.);\n        } else if (res.x > 0.) {\n            \n            float u = 0.5f + atan(rd.y, rd.z) / (2. * 3.14);\n            float v = 0.5f - asin(rd.x  ) / 3.14;\n            vec2 uv = vec2(v * 1., u * 2.);\n            col = 1.6*pow(.2 + .8*vec3(.5*(1.0 + fbm_4(uv * 310.))), vec3(3.5));\n        }\n    else {\n        col = vec3(4.0 * pow(blueNoise(rd.xy * 2.0) - 0.4, 21.0 ));\n        res.x =10.;\n    }\n    \n   \treturn vec3(col);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat mapRectangle(vec2 p, vec2 dim) {\n    return smoothstep(0.01112, -0.01112, max( abs(p.x) - dim.x, abs(p.y) - dim.y));\n}\nfloat mapSnowFlake(vec2 p, float size) {\n\n    vec2 s = vec2(1., 20.0) * size;\n    float tot;\n    \n    tot += mapRectangle(p, s);\n    tot += mapRectangle(p * rotate2d(3.14 / 3.), s);\n    tot += mapRectangle(p * rotate2d(-3.14 / 3.), s);\n    \n    vec2 s2 = s / 4.;\n    s2.x = 0.;\n    for (int i = 0; i < 6; ++i) {\n       // tot += mapRectangle( ( p - vec2(0.01, 0.041) * rotate2d(float(i) * 3.14 / 2. + 3.14/2.) )  , s2 );\n    //    tot += mapRectangle( ( p * rotate2d(-3.14/3.) - vec2(-0.01, 0.041))  , s2 );\n    }\n    return tot;\n}\n\nvec3 snowFlakes(vec2 base_uv) {\n    \n    vec3 ret = vec3(0.);\n    \n    for (int i = 0; i < 4; ++i) {\n    \n    vec2 uv = base_uv;\n       uv.x += iTime / 10.;// * hash1(uv.x);\n \n//    vec2 uv = base_uv * float(i + 1) * 2.;\n    vec2 r = vec2(0.2, 2.0);\n    vec2 id = floor(uv / r);\n    \n    vec2 s = hash2(id.xx);\n    float speed = iTime * ( 1. + s.x) / 2.;\n    uv.y += speed;\n    vec2 m_uv = mod(uv, r) - r / 2.;\n    float size = 0.0021;\n    ret += vec3( mapSnowFlake(m_uv, size) );\n    base_uv *= 2.;\n    }\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = vec2(0);//iMouse.xy/iResolution.xy;\n\tfloat time = .0f; //iTime;\n\n    // camera\t\n    vec3 ro = vec3(.0f, 1.0f, -5.0f);//vec3( 4.6*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.6*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -0.0, 1.4, 0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = normalize( vec3(p.xy,2.0) * ca );\n\n        // render\t\n        vec3 col = render( ro, rd );\n        col = max(vec3(.0), col);\n        col += snowFlakes(p);\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//==========================================================================================\n// hashes (low quality, do NOT use in production)\n//==========================================================================================\n\n#define hash21(p)  fract(sin(dot(p, vec2(11.9898, 78.233))) * 43758.5453) \n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nvec2 hash2( vec2 p ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    float n = 111.0*p.x + 113.0*p.y;\n    return fract(n*fract(k*n));\n}\nfloat blueNoise(vec2 U) {                           // 5-tap version \n    float v =  hash21( U + vec2(-1, 0) )\n             + hash21( U + vec2( 1, 0) )\n             + hash21( U + vec2( 0, 1) )\n             + hash21( U + vec2( 0,-1) ); \n    return  hash21(U) - v/4.  + .5;\n}\n//==========================================================================================\n// noises\n//==========================================================================================\n\n// value noise, and its analytical derivatives\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    #if 1\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    #else\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    #endif\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), \n                      2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                      k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                      k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    #if 1\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    #else\n    vec3 u = w*w*(3.0-2.0*w);\n    #endif\n    \n\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    #if 1\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec2 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    #else\n    vec2 u = w*w*(3.0-2.0*w);\n    vec2 du = 6.0*w*(1.0-w);\n    #endif\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return vec3( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k4*u.x*u.y), \n                 2.0*du * vec2( k1 + k4*u.y,\n                            k2 + k4*u.x ) );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    #if 1\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    #else\n    vec2 u = w*w*(3.0-2.0*w);\n    #endif\n\n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n    \n    return -1.0+2.0*(a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y);\n}\n\n//==========================================================================================\n// fbm constructions\n//==========================================================================================\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\nconst mat2 m2i = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\n\n//------------------------------------------------------------------------------------------\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}