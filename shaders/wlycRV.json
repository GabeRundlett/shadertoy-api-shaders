{
    "Shader": {
        "info": {
            "date": "1611340158",
            "description": "silly little datamosh shader w/ reprojection filter code from https://www.shadertoy.com/view/lsG3D1",
            "flags": 32,
            "hasliked": 0,
            "id": "wlycRV",
            "likes": 9,
            "name": "glitchmarch",
            "published": 3,
            "tags": [
                "glitch",
                "datamosh"
            ],
            "usePreview": 0,
            "username": "ompuco",
            "viewed": 700
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 BS_A = vec4(   3.0,  -6.0,   0.0,  4.0 ) /  6.0;\nvec4 BS_B = vec4(  -1.0,   6.0, -12.0,  8.0 ) /  6.0;\nvec4 RE_A = vec4(  21.0, -36.0,   0.0, 16.0 ) / 18.0;\nvec4 RE_B = vec4(  -7.0,  36.0, -60.0, 32.0 ) / 18.0;\nvec4 CR_A = vec4(   3.0,  -5.0,   0.0,  2.0 ) /  2.0;\nvec4 CR_B = vec4(  -1.0,   5.0,  -8.0,  4.0 ) /  2.0;\nvec4 PS_A = vec4(   1.25,-2.25,   0.0,  1.0 ) /  1.0;\nvec4 PS_B = vec4(  -0.75, 3.75,  -6.0,  3.0 ) /  1.0;\n\nvec4 powers( float x ) { return vec4(x*x*x, x*x, x, 1.0); }\n\nvec4 ca, cb;\n\nvec4 spline( float x, vec4 c0, vec4 c1, vec4 c2, vec4 c3 )\n{\n    ca = PS_A;\n    cb = PS_B;\n    // We could expand the powers and build a matrix instead (twice as many coefficients\n    // would need to be stored, but it could be faster.\n    return c0 * dot( cb, powers(x + 1.0)) + \n           c1 * dot( ca, powers(x      )) +\n           c2 * dot( ca, powers(1.0 - x)) +\n           c3 * dot( cb, powers(2.0 - x));\n}\n\n#define SAM(a,b)  texture(tex, (i+vec2(float(a),float(b))+0.5)/res, -99.0)\n\n\n\n\n\n\n\n\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nfloat map(vec3 p) {\n    //_Mod = 0;// .6;//+sin(_Frame)*.1;\n\t//p=floor(p*128)/128;\n\t//p=floor(p*128.1)/128.1;\n    //p.xz=kaleido(p.xz,35.0);  \n      \n\n\tvec3 p2=p;\n\tp2.xz+=vec2(sin(p.y*4.0), cos(p.y*4.0))/16.0;\n     float d = sdBox(p, vec3(3.0, 1.0, 3.0));\n   vec3 res = vec3( d, 1.0, 0.0 );\n\n   float s = 1.0;\n   for( int m=0; m<6; m++ )\n   {\n      //float3 a = mod( p*s, 3.0+(_Time.w%p.xyz/100.0)/3.0+.2 )-1.0;\n\n\n    //  float3 a = mod( p*s, 3.313)-1;//+sin(_Time.w)/2.0 )-1.0;\n      //float3 a = mod( p*s, 3.413+sin(_Time.x )/2.0-.5 )-1.0;\n      vec3 a = mod( p*s, 2.0 + .125 )-1.0;\n\n\n      //float3 a = mod( p*s, sin(p)+3.0)-1;//+sin(_Time.w)/2.0 )-1.0;\n     // float3 a = mod( p*s, round(sin(floor(p*32)/32)*1.0)+3.0)-1;//+sin(_Time.w)/2.0 )-1.0;\n      //float3 a = mod( p*s, 2 )-1.0;\n      s *= 3.0;\n      vec3 r = abs(1.0 - 3.0*abs(a));\n\n      float da = max(r.x,r.y);\n      float db = max(r.y,r.z);\n      float dc = max(r.z,r.x);\n      float c = (min(da,min(db,dc))-1.0)/s;\n\n      if( c>d )\n      {\n          d = c;\n          res = vec3( d, 0.2*da*db*dc, (1.0+float(m))/4.0);\n       }\n   }\n\n   return res.x;\n}\n\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.0001,0.0,0.0);\n\n    return normalize( vec3(\n      map( pos+eps.xyy ) - map( pos-eps.xyy ),\n      map( pos+eps.yxy ) - map( pos-eps.yxy ),\n      map( pos+eps.yyx ) - map( pos-eps.yyx ) ) );\n}\n\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n    float res = 0.0;\n    \n    float tmax = 12.0;\n    \n    float t = 0.01;\n    for(int i=0; i<80; i++ )\n    {\n        float h = map(ro+rd*t);\n        if( h<0.0001 || t>tmax) break;\n        t += h;\n    }\n\n    if( t>tmax ) res = 1.0;\n    \n    return res;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\n\n\n\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    float res = -1.0;\n    float tmax = 16.0;\n    float t = 0.001;\n    vec3 ord =rd;\n    for(int i=0; i<128; i++ )\n    {\n        float h = map(ro+rd*t);\n        if( h<0.0001 || t>tmax ) break;\n        \t\t//rd.zy = rotate(ord.zy,t*.3);\n        t +=  h;\n    }\n    \n    if( t<tmax ) res = t;\n\n    return res;\n}\n\n\n\n\nfloat hash1( uint n ) \n{\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return 1.0 - float(n&0x7fffffffU)/float(0x7fffffff);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec4 texture_Bicubic( sampler2D tex, vec2 t )\n{\n    vec2 res = iChannelResolution[0].xy;\n    vec2 p = res*t - 0.5;\n    vec2 f = fract(p);\n    vec2 i = floor(p);\n\n    return spline( f.y, spline( f.x, SAM(-1,-1), SAM( 0,-1), SAM( 1,-1), SAM( 2,-1)),\n                        spline( f.x, SAM(-1, 0), SAM( 0, 0), SAM( 1, 0), SAM( 2, 0)),\n                        spline( f.x, SAM(-1, 1), SAM( 0, 1), SAM( 1, 1), SAM( 2, 1)),\n                        spline( f.x, SAM(-1, 2), SAM( 0, 2), SAM( 1, 2), SAM( 2, 2)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 previousPos = texture(iChannel0, vec2(1.5,1.5) / iResolution.xy).xyz;\n\n    float t = iTime*1.;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n     \n    vec2 p = (-iResolution.xy + 2.0*(fragCoord)) / iResolution.y;\n    vec3 ta = vec3(1.5,0.7,1.5);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(t+uv.xyx+vec3(0,2,4));\n    \n    vec3 ro = vec3(0.0, 0.0, sin(t*.25)*4.0);\n    vec3 rd = normalize(vec3(uv.x-.5,uv.y-.5,1.0));\n    mat3  ca = setCamera( ro, ta, 0.30 );\n    rd = normalize( ca * vec3(p,-1.3) );\n\n    float d = intersect(ro, rd);\n    \n    vec3 pos = ro + rd * d;\n    \n    \n    \n    \n    \n    \n    vec3 roPrev = previousPos;\n    vec3 rdPrev = normalize(vec3(uv.x-.5,uv.y-.5,1.0));\n    ta = vec3(1.5,0.7,1.5);\n    mat3  caPrev = setCamera( roPrev, ta, 0.30 );\n    mat4 cap2 = mat4(\n        caPrev[0][0],caPrev[0][1],caPrev[0][2], -dot(caPrev[0],roPrev),\n\n        caPrev[1][0],caPrev[1][1],caPrev[1][2], -dot(caPrev[1],roPrev),\n\n        caPrev[2][0],caPrev[2][1],caPrev[2][2], -dot(caPrev[2],roPrev),\n\n        0.0, 0.0, 0.0, 1.0);\n        \n        rdPrev = normalize( caPrev * vec3(p,-1.3) );\n    \n    float dPrev = intersect(roPrev, rdPrev);\n    \n    vec3 posPrev = roPrev + rdPrev * dPrev;\n    \n    vec3 cpos = (vec4(pos,1.0) * cap2).xyz;//(pos*caPrev).xyz; // note inverse multiply\n    // ndc space\n    vec2 npos = -1.3 * cpos.xy / cpos.z;\n    // screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y/iResolution.x,1.0);\n    vec2 motion = spos - uv;\n    \n    \n\n    \n    \n    vec3 normal = calcNormal(pos);\n    \n    vec3 lDir = normalize(vec3(-2.3,2.3,2.1));//normalize(vec3(sin(iTime*.5),1.3,cos(iTime*.5)));\n    \n    vec3 sCol = vec3(1.0,1.0,1.0) * (dot(lDir,normal)*.5+.5);\n    float sh = shadow(pos, lDir);\n    sCol *= .3+.75*sh;\n    sCol = clamp(sCol,.0,1.);\n\n    float ns = hash1(uint(floor(fragCoord.x/32.0)+floor(fragCoord.y/32.)*iResolution.x+mod(float(iFrame/4) * iResolution.x * iResolution.y, 24562.7452)));\n    //if(mod(iTime,8.0)>1.0)\n    if(iFrame>10)\n    sCol = mix(sCol, texture_Bicubic(iChannel0, uv + motion).xyz,step(ns*.95 + length(motion)*.25,.9));//sin(coord.xyx*44.0)*.5+.5;//abs(pos - posPrev);\n    \n    sCol = clamp(sCol,.0,1.);\n    if(d>.0)col = sCol;//vec3(n, n, n);\n    // Output to screen\n    \n    if(ivec2(fragCoord.xy)==ivec2(1,1))col = ro; //rd & etc calculated from ro, so that's all we need\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}