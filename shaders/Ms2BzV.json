{
    "Shader": {
        "info": {
            "date": "1501315864",
            "description": "mouse.xy does things\nmultiple stacks of coordinate system lines with y range [-2 .. 2] show multiple y=f(x)\n\nthe 3 triangular waves BELOW the cursor are best.\nfor smoother distance field indication.",
            "flags": 0,
            "hasliked": 0,
            "id": "Ms2BzV",
            "likes": 1,
            "name": "slanting waves",
            "published": 3,
            "tags": [
                "gradient",
                "smoothstep",
                "branchless",
                "symmetry",
                "stretch",
                "differential",
                "seesaw",
                "slant",
                "disymmetry",
                "intuition"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 665
        },
        "renderpass": [
            {
                "code": "/*\nthinking about smoother seesaw variants to paint a distance field i did this\ntake on stretching and triangle waves. It made me realize more about disymmetry:\ntriX() taught me a lot about identities on differentials.\nand how any division by 0 just shows lack of understanding of disymmetry.\n*/\n\n//rotate \"y=f(x)\" to \"x=f(y)\", to better utilize 16/9 screen space.\n//#define rotate\n\n// b is either b=fract(b); OR b=cos((b+1.)*acos(-1.))*.5+.5;\n//enabled it is the later, for more continuity.\n#define cosB\n\n//2 colors show grid.xy, \"showquadrants\" swiwels them between adjacent quadrants.\n#define showquadrants\n\n//mouse.y+Yoffset drags the view.\n#define Yoffset 5.\n\n//view zoom\n#define viewZoom 30.\n//view scaling\n#define frame(u) (u-.5*iResolution.xy)*viewZoom/iResolution.y\n\n\n/*\n[optimizing for symmetry] leads to [thingking in differentials]\n...as if both are conceptually roughly the same.\n\nI am learning enough about [disymmetry] to substitute branches with abs() and fract()\nand at this point, stuff gets REALLY weird!\n...\nwhen you substitute mix(a,b,step(c,0.)) with max(a,b,step(c,0.))\nwhen you substitute step(step()) with step()+step()-1. \nand similar novel things.\nto a point where the difference between comparators and substracting fades out.\nbecause \"difference\" \"comparators\" and \"substraction\" are all about \"differentials\"\n...\nand then you start to substitute:\nb=mix(b,1.,step(fract(b),0.));\nwith\nb*=step(0.,fract(b));\n...\nand then you evade [division by b=0] cases by doing\n return abs(a-1.)/(b*step(0.,fract(b)));\n...\nand suddenly, the problem of dividing by [null differentia] goes completely away!!!!\n...\n...\nfor this, I promote the term definitions:\n[disymmetry]=[gradient between the extremes;[[symmetry]...[asymmetry]]]\n\nthe biggest and most genral problem with disymmetry is overgeneralization.\n*/\n\n//in memory to the moment when I changed a branch into the BRANCH THAT EQUALS a=abs(a-b)\n//It looked familliar, intuitively, but I had to RENDER it to SEE its identity:\nfloat aa(float a,float b){\n //float b=1.;\n return abs(a-b);\n//above is identical to below\n if(a>b)a=a-b;\n else   a=b-a;\n return a;\n}\n\n//these branchless comparators compare [c] with [0.0] to return [a]==true or [b]==false;\n//most commonly: d=(c> 0)?a:b; //but this has all 6 comparators;>,<,=,!=,<=,>=\n//if(high symmetry) , especially if(a==0.), a lot of differentials become =.0 !\n//in these cases, it often makes sense to substitute a branch with its branchless variant\n//likely increasing performance and precision.\n//\n//rule of thumb; the first debugging step is to add or remove \"un*\", to swap [a] and [b],\n//especially if your intuition tells you otherwise,\n//because your intuition is too easily tricked by mirror symmetry.\n//Like a parrot who fails to tell a mirror image from reality.\n//\n//with more symmetry, these boil down to\n//step(c,0)*a+b*step(0,c);\n//...\n//where you can more easily see [a] and [b] partially cancel each other out;\n//step(c,0)*a+x + x+b*step(0,c) == 2*x+(step(c,0)*a+b*step(0,c)) ???\n//step(c,0)*a*x + x*b*step(0,c) == x*(step(c,0)*a+b*step(0,c))  ???\n//or something like that???\n//...\n//or a=0 or b=0 simplifying the whole thing by turning one summand to 0.0\n//\n//based on \n//  https://www.reddit.com/r/askmath/comments/6aag2g/simplifying_stepa00step00a/\n//(c> 0)?a:b\n#define greater(a,b,c)   mix(a,b,step(c,0.))\n//(c< 0)?a:b\n#define less(a,b,c)      mix(a,b,step(0.,c))\n//(c==0)?a:b\n#define equals(a,b,c)    mix(b,a,step(c,0.)+step(0.,c)-1.)\n//----------- mirror symmetry mirror == swap [a] and [b]--------------------\n//(c!=0)?a:b              =not equal\n#define unequals(a,b,c)   equals(b,a,c)\n//(a>=0)?a:b   \"unless   \"=not less   ==greater OR equal\n#define unless(a,b,c)       less(b,a,c) \n//(c<=0)?a:b   \"ungreater\"=not greater==less    OR equal\n#define ungreater(a,b,c) greater(b,a,c)\n//#define sss(a) cos(clamp(a*acos(-1.),0.,acos(-1.)))/acos(-1.);\n//https://www.shadertoy.com/view/XssfRf\n\nfloat pMod1(inout float p,float s){float c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\n//float pmod(float p){return (fract(p+.5)-.5);}\n//from hg_sdf\n\nfloat mi(float a,float b,float c){\n return c*(a-b)+a;\n    //so, the specifications claim that mix(a,b,c)==c*(a-b)+a;\n    //but for triX() it is not the case!\n    //instead, sometimes you MUST chose the \"un*\"-variant from above.\n    //and then substitute that one asin mi()\n return mix(a,b,c);}\n\n//explicit step(a,b), substitutions\nfloat stp(float a){return sign(a)*.5+.5;}\nfloat stp(float a,float b){\n return stp(a-b);//substitute step(a,b) to a differential function.\n //return step(a,b);\n}\n\n//return triangle wave, where local maximum is at (b)\nfloat triX(float a,float b){\n a=fract(a-b)+b;//modulo, offset by b.\n b+=(1.-b*2.)*stp(1.-a);//b*(1.-stp(1.-a))+(1.-b)*stp(1.-a);//dark substitution magic:\n //above is identical to below:\n //b=b*step(1.,a)+(1.-b)*step(a,1.); \n //b=mix(b,1.-b,step(a-1.,0.));\n //b=greater(b,1.-b,a-1.);\n //above and below appear to be identical, which is novel to me.\n //b=greater(b,1.-b,step(1.,a));//b=mix(b,1.-b,step(step(1.,a),0.));\n //if(1.>a)b=1.-b; //branching variant of the above\n \n /*\n b*=step(0.,fract(b));\n //oh YAY, i simplified the below to the above. not sure how, but my intuition is learning!\n //b=mix(b,1.,step(fract(b),0.));\n //b=greater(b,1.,fract(b));\n //above seems identocal to below.\n //b=equals(b,1.,step(fract(b),0.));\n //if(fract(b)==0.)b=1.; //branching variant of the above\n\n return abs(a-1.)/b;\n    \n /*  //initial version of the above:\n if(a<=0.||a==1.)a= -a/(1.-b);//||a==1. makes it extra worksave, avoiding a/0 below\n else a=a/b; \n return a;*/\n    \n //above last 2 modifiers unooted below;\n //totally not weird to have a dividend that is (b*step(0.,fract(b))); !!!!!!!!\n return abs(a-1.)/(b*step(0.,fract(b)));\n}\n\nfloat cosb(float b){//return b;\n #ifdef cosB\n return cos((b+1.)*acos(-1.))*.5+.5;//better continuity\n #else\n return fract(b);//faster\n #endif\n}\n\nfloat sss(float a){return cos(clamp(a,0.,acos(-1.)));}//*.5+.5;\n\nfloat l(float a,float b){return clamp(a/b,0.,1.);}\nfloat stretch(float a,float b){\n float fdd = .2;//first derivative of main diagonal\n if(a<0.)return a*fdd;\n if(a>b)return (a-b)*fdd+1.;\n return a/b;\n}\nfloat tri(float a,float b){//simple triangle wave.\n a=fract(a-b);\n   // a=stretch(a,b);//no, that would have been way too easy.\n a=abs(a*2.-1.);\n return a;}\n\n\n#define MAD(a,b,c) ((a*b+c))\n\n//complicated mix of below functions.\n//\"smoothest slanting triangle-sinusoid\"\n//is a compromise between a triangleWave and y=cos(x)\n//to smoothly display distance fields\n\n\nfloat dat(float u,float m){m=fract(m);\n if(u>=m)return(-.5)/(m-1.)*(u-(.5-m)/-.5);\n return u*.5/m;}\n//float sss(float a){return cos(clamp(a,0.,acos(-1.)));}//*.5+.5;\nfloat sss2(float a){return cos(clamp(a,-1.,1.)*acos(-1.))*.5+.5;}//*.5+.5;\n//sawCosB() can be faster than sawCos(), by being branching?\nfloat sawCosB(float u,float b){return sss2(dat(u,b)*2.-1.);}\n//the scaling is a bit silly here. its a first draft.\n\n//return y of f(u.x) which is a triangle wave, slanted sideways by u.x\n//that is also sinusoidial continuity, but not for: 0.!=u.y!=1.\nfloat sawCos(vec2 u){\n //u.x=fract(u.x);u+=(1.- 2.*u)*step(u.y,u.x);return cos(clamp(1.-u.x/u.y,0., 1.)*acos(-1.))*.5+.5;\n //above line is a 1-liner variant of the whole function below.\n u.x=fract(u.x);\n u+=(1.-2.*u)*stp(u.x-u.y);//u+=(1.-2.*u)*(sign(u)*.5+.5);\n //u=u*step(u.x-u.y,0.)+(1.-u)*step(0.,u.x-u.y);\n //u=mix(1.-u,u,step(u.x-u.y,0.));\n return sss( (1.-u.x/u.y)*acos(-1.))*.5+.5;}\n//lazy utility function for sawCos();\nfloat sawCos(vec2 u,float b){u.x=fract(u.x);//this is a rather silly wrapper\n //return sawCosB(u.x,b);//use SawCosB()\n u.y=b;return sawCos(u);//use SawCos()\n}\n\nfloat mode(vec2 u,float b,float line){\n // b=cos(b);\n if(line==9.)return tri (u.x,cosb(b))-u.y;//triangle wave, failed attempt for triX (slanwable triangle wave)\n if(line==8.)return triX(u.x,cosb(b))-u.y; //this turned out most sidetracking.\n if(line==7.)return min(aa(u.x,b),1.)-u.y;//on the branching identity of abs()\n if(line==6.)return l(      u.x,  b )-u.y;//a smaller simple thing\n if(line==5.)return stretch(u.x,  b )-u.y;//another \"stretch()\" variant where y LESS cntinuous.\n if(line==4.)return sss((1.-u.x)*acos(-1.)/b)*.5+.5+u.x*.2-u.y; //diagonal+scaled sss()=sssStretch()\n if(line==3.)return sss((1.-u.x)*acos(-1.)/b)*.5+.5       -u.y; //         scaled sss()    \n if(line==2.)return sss((1.-u.x)*acos(-1.)  )*.5+.5       -u.y; //smootheststep is sinusoidial. better differentials than smoothstep()         \n if(line==0.)return stp(    u.x,b)-u.y;//step() substituted by sign()\n return sawCos(u,cosb(b))-u.y;//truiangle sin mix sucess.\n}\n\nvoid mainImage(out vec4 O,in vec2 U){\n vec2 u =frame(U); \n vec2 m =frame(iMouse.xy);\n    #ifdef rotate\n u=u.yx;\n m=m.yx;\n    #endif\n vec3 c=vec3(0);    \n //c.g=sss(u.x)-u.y;\n float b=m.x;\n u.y-=m.y-Yoffset;\n \n     #ifdef rotate\n float line=pMod1(u.y,6.);\n    #else\n float line=pMod1(u.y,4.);\n    #endif\n line=mod(line,10.);\n c.g=mode(u,b,line);   \n \n    \n c.g=smoothstep(.01,-.01,c.g);\n\n     #ifdef showquadrants\n if(u.y<0.)c.rb*=.5;//negative.y is darker on the grid.\n if(u.x*u.y<0.)u=u.yx;//indicate y=0 by swiveling the grid domains\n //u.x=abs(u.x); \n    #endif\n c.rb=fract(u);\n c*=.5;\n O=vec4(c+c.yzx,1);\n}\n\n\n/*\nThis shader is more or less the origin of what i later call \"bisymmetry\";\n... as the gradient between symmetry and asymmetry.\n...to create complex shapes by segmgmentning them to simpler partis, \n...unifying segments of the same exponent first, to optimize root solving.\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}