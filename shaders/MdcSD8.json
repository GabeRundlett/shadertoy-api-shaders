{
    "Shader": {
        "info": {
            "date": "1458988227",
            "description": "Up, down, right and left to move the cursor. Space to pick tuna. Press 'r' to reset the level.\nOrange=1 \nPink=2\nGreen=3 \nRed=5\nShiny=10\nWRITE YOUR HIGHSCORE IN A COMMENT\nPractica 2 PGATR - Juego en un shader.\nAutores:\nLucia Cubel\nHector Suarez",
            "flags": 112,
            "hasliked": 0,
            "id": "MdcSD8",
            "likes": 2,
            "name": "pim, pam, pum, bocata de atun",
            "published": 3,
            "tags": [
                "game",
                "pgatr",
                "multipass",
                "migjrv",
                "shooter",
                "urjc"
            ],
            "usePreview": 0,
            "username": "hecLu",
            "viewed": 811
        },
        "renderpass": [
            {
                "code": "/*****************************************************************************************\n*Shader realizado para la asignatura Procesadores Graficos y Aplicaciones en Tiempo Real\n*\n* Autores:\n* Lucia Cubel\n* Hector Suarez\n*\n*This is the link to the presentation\n*https://www.youtube.com/watch?v=8QX9XaFZ2bE\n*See and enjoy\n******************************************************************************************/\n\n#define PI 3.14159265359\nconst float KEY_SP    = 32.5/256.0;\nconst vec2 posCuadrado  = vec2(0.0,0.0);\nconst vec2 dirTiempo  = vec2(1.0,0.0);\nconst vec2 dirPuntuacion  = vec2(6.0,0.0);\n///////////////////////////////////////////////////////////////////////////////////////\n//Obtenido de un shader de iq (https://www.shadertoy.com/view/MddGzf)\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\n    if( abs(vUV.x-0.5)>0.5 || abs(vUV.y-0.5)>0.5 ) return 0.0;\n\n    // digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n    float data = 0.0;\n         if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n    else if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n    else if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    \n    vec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n    float fIndex = vPixel.x + (vPixel.y * 4.0);\n    \n    return mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\nfloat PrintInt( in vec2 uv, in float value )\n{\n    float res = 0.0;\n    float maxDigits = 1.0+ceil(.01+log2(value)/log2(10.0));\n    float digitID = floor(uv.x);\n    if( digitID>0.0 && digitID<maxDigits )\n    {\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n    }\n\n    return res;\n}\n////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////\n//Funciones para crear ruido de worley\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453 );\n}\n//Funcion que crea un efecto de plasma azul\nvec3 getColor(){\n\tvec2 p = vec2(gl_FragCoord.xy / iResolution.xy);\n\tvec2 r =  3.0*vec2(gl_FragCoord.xy + 0.5*iResolution.xy)/iResolution.y;\n\tfloat t = iTime;\n    r = r * 8.0;\n\t\n    float v1 = sin(r.x +t);\n    float v2 = sin(r.y +t);\n    float v3 = sin(r.x+r.y +t);\n    float v4 = sin(sqrt(r.x*r.x+r.y*r.y) +1.7*t);\n\tfloat v = v1+v2+v3+v4;\n\t\n\tvec3 ret;\n\tret = vec3(sin((v+0.5)*PI)*0.0, sin(v)*0.3+0.5, 0.8);\n\t\t\n\t\n\tret = 0.5 + 0.5*ret;\n\t//ret=vec3(1.0);\n\treturn ret;\n}\n//Worley+plasma azul\nvec3 water(){\n\tvec2 pos = gl_FragCoord.xy / iResolution.yy;\n    //Movimiento estilo agua\n\tpos += vec2(sin(pos.x * 12.0 + iTime) * 0.017 + sin(pos.y * 27.0 + 2.0 * iTime) * 0.015);\n\n\tfloat numTiles = 10.0;\n\t\n\tvec2 curretTile = floor(pos * numTiles);\n\tpos = fract(pos * numTiles) + 1.0;\n\t\n\tfloat minDist = 2.0;\n\t\n\tfor(float y = -1.0; y < 2.0; y++) {\n\n\t\tfor(float x = -1.0; x < 2.0; x++) {\n\t\t\tfloat po = rand( vec2(curretTile.x + x, curretTile.y + y) );\n            //Animacion basada en un shader de iq (https://www.shadertoy.com/view/ldl3W8)\n            //con nuestro pequeÃ±o toque personal\n\t\t\tpo=0.5 + 0.4*cos( iTime + 6.2831*po );\n\t\t\tvec2 point = vec2( (1.0 + x) + po , (1.0 + y) + (1.0 - po) );\n\t\t\t\n\t\t\tfloat dist = distance(pos, point);\n\t\t\tfloat cond=float(minDist > dist);\n\t\t\tminDist =minDist*(1.0-cond)+dist*cond;\n\t\t}\n\n\t}\n\tvec3 color=mix(getColor()*0.4,getColor(),smoothstep(0.0,1.0,clamp(minDist*0.9,0.0,1.0)));\n\treturn color;\n}\n////////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////////\n//Metodos para colorear atunes\nvoid triangulo(vec2 r,vec2 centro,float factorD,float xMax,inout vec3 pixel,vec3 colorTri){\n\tvec2 punto=vec2(r.x-centro.x,abs(r.y-centro.y));\n\tfloat pinta=step(punto.x,xMax)*step(punto.y,(xMax/factorD));\n\tfloat valorX=xMax-(factorD*punto.y);\n\tif(valorX>=punto.x&&punto.x>=0.0){\n\t\tpixel=(pixel*abs(pinta-1.0))+(colorTri*pinta);\n\t}\n}\nvec3 pintarPezI(vec2 posCuadrado,vec2 posActual,vec3 colorFrag,vec3 colorPez){\n    vec2 aux=abs(posActual-posCuadrado);\n    float y1=-20.0+0.01*aux.x+0.01*aux.x*aux.x;\n    float y2=-y1;\n    //El cuerpo del pez esta formado por la interseccion de do parabolas\n    float cond=float((aux.y>=y1) && (aux.y<=y2));\n    vec3 colorF=mix(colorFrag,colorPez,cond);\n    //La cola es la mitad de un rombo(un triangulo)\n    triangulo(posCuadrado,posActual+vec2(-43.9,0.0),0.5,13.0,colorF,colorPez);\n    return colorF;\n    \n}\nvec3 pintarPezD(vec2 posCuadrado,vec2 posActual,vec3 colorFrag,vec3 colorPez){\n    vec2 aux=abs(posActual-posCuadrado);\n    aux=-aux;\n    float y1=-20.0+0.01*aux.x+0.01*aux.x*aux.x;\n    float y2=-y1;\n    float cond=float((aux.y>=y1) && (aux.y<=y2));\n    vec3 colorF=mix(colorFrag,colorPez,cond);\n    triangulo(-posCuadrado,-posActual+vec2(-45.0,0.0),0.5,13.0,colorF,colorPez);\n    return colorF;\n    \n}\nvec3 pintarPezUp(vec2 posCuadrado,vec2 posActual,vec3 colorFrag,vec3 colorPez){\n    vec2 aux=abs(posActual-posCuadrado);\n    float y=aux.x;\n    aux.x=aux.y;\n    aux.y=y;\n    float y1=-20.0+0.01*aux.x+0.01*aux.x*aux.x;\n    float y2=-y1;\n    float cond=float((aux.y>=y1) && (aux.y<=y2));\n    vec3 colorF=mix(colorFrag,colorPez,cond);\n    triangulo(-vec2(posCuadrado.y,posCuadrado.x),-vec2(posActual.y,posActual.x)+vec2(-43.9,0.0),0.5,13.0,colorF,colorPez);\n    return colorF;\n    \n}\nvec3 pintarPezAbajo(vec2 posCuadrado,vec2 posActual,vec3 colorFrag,vec3 colorPez){\n    vec2 aux=abs(posActual-posCuadrado);\n    float y=aux.x;   \n    aux.x=aux.y;\n    aux.y=y;\n    float y1=-20.0+0.01*aux.x+0.01*aux.x*aux.x;\n    float y2=-y1;\n    float cond=float((aux.y>=y1) && (aux.y<=y2));\n    vec3 colorF=mix(colorFrag,colorPez,cond);\n     triangulo(vec2(posCuadrado.y,posCuadrado.x),vec2(posActual.y,posActual.x)+vec2(-43.9,0.0),0.5,13.0,colorF,colorPez);\n    return colorF;\n    \n}\n/////////////////////////////////////////////////////////////////////////////////////\n\n//Funcion que pinta y anima los 12 atunes que saldran en la pantalla\nvec3 atunes(vec3 color, vec2 fragCoord){\n    vec2 pintarPez[4];\n    pintarPez[0]=vec2(2.0,0.0);\n    pintarPez[1]=vec2(3.0,0.0);\n    pintarPez[2]=vec2(4.0,0.0);\n    pintarPez[3]=vec2(5.0,0.0);\n    vec3 estadoPez[4];\n    estadoPez[0]=texture( iChannel0, (pintarPez[0]+0.5)/iChannelResolution[0].xy ).xyz;\n    estadoPez[1]=texture( iChannel0, (pintarPez[1]+0.5)/iChannelResolution[0].xy ).xyz;\n    estadoPez[2]=texture( iChannel0, (pintarPez[2]+0.5)/iChannelResolution[0].xy ).xyz;\n    estadoPez[3]=texture( iChannel0, (pintarPez[3]+0.5)/iChannelResolution[0].xy ).xyz;\n    vec3 colorPez=vec3(1.0,0.5,0.0)+vec3(0.2);\n    float t=iTime;\n    ////////////////////////////////////////////////////////////////////////////////\n    //Atunes de la derecha\n    float momento=mod(t*120.0,(iResolution.x+600.0));\n    float x=iResolution.x+43.17-momento;\n    float y=iResolution.y*0.3;\n    /*x=iResolution.x*0.5;\n    y=iResolution.y*0.5;*/\n    if(estadoPez[0].x>0.0){\n    \tcolor=pintarPezI(vec2(x,y),fragCoord,color,colorPez);\n    }\n    momento=mod(t*200.0,(iResolution.x+800.0));\n    x=iResolution.x+43.17-momento;\n    y=iResolution.y*0.6+sin(x*0.02)*80.0;\n    colorPez=vec3(1.0,0.5,0.8)+vec3(0.1);\n    if(estadoPez[0].y>0.0){\n    \tcolor=pintarPezI(vec2(x,y),fragCoord,color,colorPez);\n    }\n    momento=mod(t*80.0,(iResolution.x+400.0));\n    x=iResolution.x+43.17-momento;\n    y=iResolution.y*0.9+tan(x*0.02)*180.0;\n    colorPez=vec3(0.0,1.0,0.2)+vec3(0.1);\n    if(estadoPez[0].z>0.0){\n    \tcolor=pintarPezI(vec2(x,y),fragCoord,color,colorPez);\n    }\n    ////////////////////////////////////////////////////////////////////////////////\n    \n    ////////////////////////////////////////////////////////////////////////////////\n    //Atunes de la izquierda\n    momento=mod(t*250.0,(iResolution.x+4000.0));\n    x=-43.17+momento;\n    y=iResolution.y*0.1+cos(x*0.01)*120.0;\n    colorPez=vec3(1.0,0.5,0.8)+vec3(0.1);\n    if(estadoPez[1].x>0.0){\n    \tcolor=pintarPezD(vec2(x,y),fragCoord,color,colorPez);\n    }\n    momento=mod(t*250.0,(iResolution.x*3.0));\n    x=-43.17+momento;\n    y=iResolution.y*0.4+atan((x-250.0)*0.01)*60.0;\n    colorPez=vec3(1.0,0.5,0.8)+vec3(0.1);\n    if(estadoPez[1].y>0.0){\n    \tcolor=pintarPezD(vec2(x,y),fragCoord,color,colorPez);\n    }\n    momento=mod(t*800.0,(iResolution.x+20000.0));\n    x=-43.17+momento;\n    y=iResolution.y*0.7;\n    colorPez=vec3(1.0,0.0,0.0)+vec3(0.1);\n    if(estadoPez[1].z>0.0){\n    \tcolor=pintarPezD(vec2(x,y),fragCoord,color,colorPez);\n    }\n    ////////////////////////////////////////////////////////////////////////////////\n    \n    ////////////////////////////////////////////////////////////////////////////////\n    //Atunes hacia abajo\n    momento=mod(t*150.0,(iResolution.y*2.5));\n    y=-43.17+momento;\n    x=iResolution.x*0.1+momento*0.8;\n    colorPez=vec3(1.0,0.5,0.0)+vec3(0.2);\n    if(estadoPez[2].x>0.0){\n    \tcolor=pintarPezUp(vec2(x,y),fragCoord,color,colorPez);\n    }\n    momento=mod(t*100.0,(iResolution.y+600.0));\n    y=-43.17+momento;\n    x=iResolution.x*0.5+cos(y*0.1)*90.0;\n    colorPez=vec3(0.0,1.0,0.2)+vec3(0.1);\n    if(estadoPez[2].y>0.0){\n    \tcolor=pintarPezUp(vec2(x,y),fragCoord,color,colorPez);\n    }\n    momento=mod(t*100.0,(iResolution.y*4.0));\n    y=-43.17+momento*momento*0.2;\n    x=iResolution.x*0.9;\n    colorPez=texture(iChannel2,vec2(x,y)).xyz+vec3(0.5);\n    if(estadoPez[2].z>0.0){\n    \tcolor=pintarPezUp(vec2(x,y),fragCoord,color,colorPez);\n    }\n    ////////////////////////////////////////////////////////////////////////////////\n    \n    ////////////////////////////////////////////////////////////////////////////////\n    //Atunes hacia arriba\n    momento=mod(t*100.0,(iResolution.y*5.0));\n    y=iResolution.y+43.17-momento;\n    x=iResolution.x*0.235+cos(y*0.01)*690.0;\n    colorPez=vec3(1.0,0.0,0.0)+vec3(0.1);\n    if(estadoPez[3].x>0.0){\n    \tcolor=pintarPezAbajo(vec2(x,y),fragCoord,color,colorPez);\n    }\n    momento=mod(t*1500.0,(iResolution.y*50.0));\n    y=iResolution.y+43.17-momento;\n    x=iResolution.x*0.32154;\n    colorPez=texture(iChannel2,vec2(x,y)).xyz+vec3(0.5);\n    if(estadoPez[3].y>0.0){\n    \tcolor=pintarPezAbajo(vec2(x,y),fragCoord,color,colorPez);\n    }\n    momento=mod(t*200.0,(iResolution.y*8.0));\n    y=iResolution.y+43.17-momento;\n    x=iResolution.x*0.715-momento*1.5;\n    colorPez=vec3(1.0,0.5,0.0)+vec3(0.2);\n    if(estadoPez[3].z>0.0){\n    \tcolor=pintarPezAbajo(vec2(x,y),fragCoord,color,colorPez);\n    }\n    ////////////////////////////////////////////////////////////////////////////////\n\n    return color;\n}\n\n//Funcion que pinta el cursor (caÃ±a de pescar)\nvec3 pintarCuadrado(vec2 posCuadrado,vec2 posActual,float ancho,float largo,vec3 colorFrag){\n    vec2 aux=abs(posActual-posCuadrado);\n    float cond=float((aux.y<=largo) && (aux.x<=ancho));\n    vec3 colorC=vec3(0.9,0.0,0.2); \n    return colorC*cond+colorFrag*(1.0-cond);\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //Pintamos un lecho de piedras\n    vec3 color=vec3(texture(iChannel1,fragCoord/iResolution.xy).x);\n    //Cargamos el estado\n    vec2 posCuadrado = texture( iChannel0, (posCuadrado+0.5)/iChannelResolution[0].xy ).xy;\n    float tiempo= texture( iChannel0, (dirTiempo+0.5)/iChannelResolution[0].xy ).x;\n    //Si el tiempo no se ha acabado seguimos pintando atunes y animando atunes\n    if(tiempo>0.0){\n    \tcolor=atunes(color,fragCoord);\n    }\n    float puntos=texture( iChannel0, (dirPuntuacion+0.5)/iChannelResolution[0].xy ).x;\n    float f = PrintInt( (((-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y)-vec2(-1.5,0.8))*10.0, puntos);\n    vec3 color2=water();\n    //Creamos la excena final\n    color=mix(color,color2,0.6);\n    color=pintarCuadrado(posCuadrado,fragCoord,5.0,5.0,color);\n    //Pintamos la puntuacion\n    color = mix( color, vec3(1.0,1.0,1.0), f );\n    f = PrintInt( (((-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y)+vec2(-1.3,-0.8))*10.0, tiempo);\n\tcolor = mix( color, vec3(0.8), f );\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 29036,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/skrival-di/hampton-the-hampster-hamster?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*****************************************************************************************\n*Shader realizado para la asignatura Procesadores Graficos y Aplicaciones en Tiempo Real\n*\n* Autores:\n* Lucia Cubel\n* Hector Suarez\n*\n*This is the link to the presentation\n*https://www.youtube.com/watch?v=8QX9XaFZ2bE\n*See and enjoy\n******************************************************************************************/\n\nconst vec2 posCuadrado  = vec2(0.0,0.0);\nconst vec2 dirTiempo=vec2(1.0,0.0);\nconst vec2 dirPuntuacion  = vec2(6.0,0.0);\n\nconst float muRapido=60.0;\nconst float tiempoMax=120.0;\n\n/////////////////////////////////////////////////////////////////////////////////////\n// definicion de constantes para control de teclado\n// Obtenido de un shader de poljere (https://www.shadertoy.com/view/Xst3zX#)\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_R     = 82.5/256.0;\n/////////////////////////////////////////////////////////////////////////////////////\n\n/////////////////////////////////////////////////////////////////////////////////////\n//Funciones para la gestion de memoria\n//Obtenido de un shader de iq (https://www.shadertoy.com/view/MddGzf)\nfloat isInside( vec2 p, vec2 c ) { \n    vec2 d = abs(p-0.5-c)-0.5; \n    return -max(d.x,d.y); \n}\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n/////////////////////////////////////////////////////////////////////////////////////\n\n/////////////////////////////////////////////////////////////////////////////////////\n//Deteccion de las colisiones con el cursor\nvoid triangulo(vec2 r,vec2 centro,float factorD,float xMax,inout float pixel,float id){\n\tvec2 punto=vec2(r.x-centro.x,abs(r.y-centro.y));\n\tfloat pinta=step(punto.x,xMax)*step(punto.y,(xMax/factorD));\n\tfloat valorX=xMax-(factorD*punto.y);\n\tif(valorX>=punto.x&&punto.x>=0.0){\n\t\tpixel=(pixel*abs(pinta-1.0))+(id*pinta);\n\t}\n}\nfloat pescarPezI(vec2 posCuadradoF,vec2 posActual,float idActual,float idPez){\n    vec2 aux=abs(posActual-posCuadradoF);\n    float y1=-20.0+0.01*aux.x+0.01*aux.x*aux.x;\n    float y2=-y1;\n    float cond=float((aux.y>=y1) && (aux.y<=y2));\n    float idF=idPez*cond+idActual*(1.0-cond);\n    triangulo(posCuadrado,posActual+vec2(-43.9,0.0),0.5,13.0,idF,idPez);\n    return idF;\n    \n}\nfloat pescarPezD(vec2 posCuadradoF,vec2 posActual, float idActual,float idPez){\n    vec2 aux=abs(posActual-posCuadradoF);\n    aux=-aux;\n    float y1=-20.0+0.01*aux.x+0.01*aux.x*aux.x;\n    float y2=-y1;\n    float cond=float((aux.y>=y1) && (aux.y<=y2));\n    float idF=idPez*cond+idActual*(1.0-cond);\n    triangulo(-posCuadrado,-posActual+vec2(-45.0,0.0),0.5,13.0,idF,idPez);\n    return idF;\n    \n}\nfloat pescarPezUp(vec2 posCuadradoF,vec2 posActual,float idActual,float idPez){\n    vec2 aux=abs(posActual-posCuadradoF);\n    float y=aux.x;\n    aux.x=aux.y;\n    aux.y=y;\n    float y1=-20.0+0.01*aux.x+0.01*aux.x*aux.x;\n    float y2=-y1;\n    float cond=float((aux.y>=y1) && (aux.y<=y2));\n    float idF=idPez*cond+idActual*(1.0-cond);\n    triangulo(-vec2(posCuadrado.y,posCuadrado.x),-vec2(posActual.y,posActual.x)+vec2(-43.9,0.0),0.5,13.0,idF,idPez);\n    return idF;\n    \n}\nfloat pescarPezAbajo(vec2 posCuadradoF,vec2 posActual,float idActual,float idPez){\n    vec2 aux=abs(posActual-posCuadradoF);\n    float y=aux.x;   \n    aux.x=aux.y;\n    aux.y=y;\n    float y1=-20.0+0.01*aux.x+0.01*aux.x*aux.x;\n    float y2=-y1;\n    float cond=float((aux.y>=y1) && (aux.y<=y2));\n    float idF=idPez*cond+idActual*(1.0-cond);\n    triangulo(vec2(posCuadrado.y,posCuadrado.x),vec2(posActual.y,posActual.x)+vec2(-43.9,0.0),0.5,13.0,idF,idPez);\n    return idF;\n    \n}\n\n//Funcion que detecta las colisiones con los distintos atunes\nfloat atunes(vec2 fragCoord){\n    float id=-1.0;\n    float t=iTime;\n    ////////////////////////////////////////////////////////////////////////////////\n    //Atunes de la derecha\n    float momento=mod(t*120.0,(iResolution.x+600.0));\n    float x=iResolution.x+43.17-momento;\n    float y=iResolution.y*0.3;\n    /*x=iResolution.x*0.5;\n    y=iResolution.y*0.5;*/\n    id=pescarPezI(vec2(x,y),fragCoord,id,0.0);\n    momento=mod(t*200.0,(iResolution.x+800.0));\n    x=iResolution.x+43.17-momento;\n    y=iResolution.y*0.6+sin(x*0.02)*80.0;\n    id=pescarPezI(vec2(x,y),fragCoord,id,1.0);\n    momento=mod(t*80.0,(iResolution.x+400.0));\n    x=iResolution.x+43.17-momento;\n    y=iResolution.y*0.9+tan(x*0.02)*180.0;\n    id=pescarPezI(vec2(x,y),fragCoord,id,2.0);\n    ////////////////////////////////////////////////////////////////////////////////\n    \n    ////////////////////////////////////////////////////////////////////////////////\n    //Atunes de la izquierda\n    momento=mod(t*250.0,(iResolution.x+4000.0));\n    x=-43.17+momento;\n    y=iResolution.y*0.1+cos(x*0.01)*120.0;\n    id=pescarPezD(vec2(x,y),fragCoord,id,3.0);\n    momento=mod(t*250.0,(iResolution.x*3.0));\n    x=-43.17+momento;\n    y=iResolution.y*0.4+atan((x-250.0)*0.01)*60.0;\n    id=pescarPezD(vec2(x,y),fragCoord,id,4.0);\n    momento=mod(t*800.0,(iResolution.x+20000.0));\n    x=-43.17+momento;\n    y=iResolution.y*0.7;\n    id=pescarPezD(vec2(x,y),fragCoord,id,5.0);\n    ////////////////////////////////////////////////////////////////////////////////\n    \n    ////////////////////////////////////////////////////////////////////////////////\n    //Atunes hacia abajo\n    momento=mod(t*150.0,(iResolution.y*2.5));\n    y=-43.17+momento;\n    x=iResolution.x*0.1+momento*0.8;\n    id=pescarPezUp(vec2(x,y),fragCoord,id,6.0);\n    momento=mod(t*100.0,(iResolution.y+600.0));\n    y=-43.17+momento;\n    x=iResolution.x*0.5+cos(y*0.1)*90.0;\n    id=pescarPezUp(vec2(x,y),fragCoord,id,7.0);\n    momento=mod(t*100.0,(iResolution.y*4.0));\n    y=-43.17+momento*momento*0.2;\n    x=iResolution.x*0.9;\n    id=pescarPezUp(vec2(x,y),fragCoord,id,8.0);\n    ////////////////////////////////////////////////////////////////////////////////\n    \n    ////////////////////////////////////////////////////////////////////////////////\n    //Atunes hacia arriba\n    momento=mod(t*100.0,(iResolution.y*5.0));\n    y=iResolution.y+43.17-momento;\n    x=iResolution.x*0.235+cos(y*0.01)*690.0;\n    id=pescarPezAbajo(vec2(x,y),fragCoord,id,9.0);\n    momento=mod(t*1500.0,(iResolution.y*50.0));\n    y=iResolution.y+43.17-momento;\n    x=iResolution.x*0.32154;\n    id=pescarPezAbajo(vec2(x,y),fragCoord,id,10.0);\n    momento=mod(t*200.0,(iResolution.y*8.0));\n    y=iResolution.y+43.17-momento;\n    x=iResolution.x*0.715-momento*1.5;\n    id=pescarPezAbajo(vec2(x,y),fragCoord,id,11.0);\n    ////////////////////////////////////////////////////////////////////////////////\n\n    return id;\n}\n///////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    if(fragCoord.x>7.0&&fragCoord.y>0.0){\n    \t discard;\n    }\n    vec2 pintarPez[4];\n    pintarPez[0]=vec2(2.0,0.0);\n    pintarPez[1]=vec2(3.0,0.0);\n    pintarPez[2]=vec2(4.0,0.0);\n    pintarPez[3]=vec2(5.0,0.0);\n    vec3 estadoPez[4];\n    //Cargamos el estado del juego (basado en un shader de iq: https://www.shadertoy.com/view/MddGzf)\n    float posCuadradoX = loadValue( posCuadrado ).x;\n    float posCuadradoY = loadValue( posCuadrado ).y;\n    estadoPez[0]=loadValue(pintarPez[0]).xyz;\n    estadoPez[1]=loadValue(pintarPez[1]).xyz;\n    estadoPez[2]=loadValue(pintarPez[2]).xyz;\n    estadoPez[3]=loadValue(pintarPez[3]).xyz;\n    float tiempo= loadValue(dirTiempo).x;\n    float tiempoIni=loadValue(dirTiempo).y;\n    float puntos= loadValue(dirPuntuacion).x;\n    //Inicializacion\n    if(iFrame==0){\n    \tposCuadradoX=iResolution.x*0.5;\n    \tposCuadradoY=iResolution.y*0.5;\n    \testadoPez[0]=vec3(1.0);\n    \testadoPez[1]=vec3(1.0);\n    \testadoPez[2]=vec3(1.0);\n    \testadoPez[3]=vec3(1.0);\n        tiempo=120.0;\n        puntos=0.0;\n        tiempoIni=iTime;\n    }\n    //Resetear el estado\n    if(texture( iChannel1, vec2(KEY_R,0.25) ).x>0.5){\n        posCuadradoX=iResolution.x*0.5;\n    \tposCuadradoY=iResolution.y*0.5;\n    \testadoPez[0]=vec3(1.0);\n    \testadoPez[1]=vec3(1.0);\n    \testadoPez[2]=vec3(1.0);\n    \testadoPez[3]=vec3(1.0);\n        tiempo=tiempoMax;\n        puntos=0.0;\n        tiempoIni=iTime;\n    }\n    tiempo=clamp(tiempoMax-(iTime-tiempoIni),0.0,tiempoMax+1.0);\n\tfloat diestra = texture( iChannel1, vec2(KEY_RIGHT,0.25) ).x;\n    float sinistra  = texture( iChannel1, vec2(KEY_LEFT,0.25) ).x;\n    posCuadradoX += 0.02*muRapido*(diestra - sinistra);\n    posCuadradoX=clamp(posCuadradoX,0.0,iResolution.x);\n    float paArriba = texture( iChannel1, vec2(KEY_UP,0.25) ).x;\n    float paBajo  = texture( iChannel1, vec2(KEY_DOWN,0.25) ).x;\n    posCuadradoY += 0.02*muRapido*(paArriba - paBajo);\n    posCuadradoY=clamp(posCuadradoY,0.0,iResolution.y);\n    vec2 posCuadradoF=vec2(posCuadradoX,posCuadradoY);\n    float id=-1.0;\n    float incremento=0.0;\n    //Accion de pesca\n    if(tiempo>0.0){\n    \tif(texture( iChannel1, vec2(KEY_SPACE,0.5) ).x>0.5){\n        \tid=atunes(posCuadradoF);\n        \tif(id>-1.0){\n            \tif(id==0.0&&estadoPez[0].x==1.0){\n            \t    estadoPez[0].x=0.0;\n            \t    incremento=1.0;\n            \t}else if(id==1.0&&estadoPez[0].x==1.0){\n            \t    estadoPez[0].y=0.0;\n            \t    incremento=2.0;\n            \t}else if(id==2.0&&estadoPez[0].y==1.0){\n                \testadoPez[0].z=0.0;\n                \tincremento=3.0;\n            \t}else if(id==3.0&&estadoPez[1].z==1.0){\n                \testadoPez[1].x=0.0;\n                \tincremento=2.0;\n            \t}else if(id==4.0&&estadoPez[1].y==1.0){\n                \testadoPez[1].y=0.0;\n                \tincremento=2.0;\n            \t}else if(id==5.0&&estadoPez[1].z==1.0){\n            \t    estadoPez[1].z=0.0;\n            \t    incremento=5.0;\n            \t}else if(id==6.0&&estadoPez[2].x==1.0){\n            \t    estadoPez[2].x=0.0;\n            \t    incremento=1.0;\n            \t}else if(id==7.0&&estadoPez[2].y==1.0){\n            \t    estadoPez[2].y=0.0;\n            \t    incremento=3.0;\n            \t}else if(id==8.0&&estadoPez[2].z==1.0){\n            \t    estadoPez[2].z=0.0;\n            \t    incremento=10.0;\n            \t}else if(id==9.0&&estadoPez[3].x==1.0){\n            \t    estadoPez[3].x=0.0;\n            \t    incremento=5.0;\n            \t}else if(id==10.0&&estadoPez[3].y==1.0){\n            \t    estadoPez[3].y=0.0;\n            \t    incremento=10.0;\n            \t}else if(id==11.0&&estadoPez[3].z==1.0){\n            \t    estadoPez[3].z=0.0;\n            \t    incremento=1.0;\n            \t}\n        \t}\n    \t}else if(texture( iChannel1, vec2(KEY_SPACE,0.25) ).x<0.5){\n        \tfloat diestra = texture( iChannel1, vec2(KEY_RIGHT,0.25) ).x;\n    \t\tfloat sinistra  = texture( iChannel1, vec2(KEY_LEFT,0.25) ).x;\n    \t\tposCuadradoX += 0.02*muRapido*(diestra - sinistra);\n    \t\tposCuadradoX=clamp(posCuadradoX,0.0,iResolution.x);\n    \t\tfloat paArriba = texture( iChannel1, vec2(KEY_UP,0.25) ).x;\n    \t\tfloat paBajo  = texture( iChannel1, vec2(KEY_DOWN,0.25) ).x;\n    \t\tposCuadradoY += 0.02*muRapido*(paArriba - paBajo);\n    \t\tposCuadradoY=clamp(posCuadradoY,0.0,iResolution.y);\n    \t}\n    }\n    posCuadradoF=vec2(posCuadradoX,posCuadradoY);\n    puntos+=incremento;\n    ////////////////////////////////////////////////////////////////////////////\n    //resetear atunes\n    float t=iTime;\n    //Peces a la derecha\n    float momento=mod(t*120.0,(iResolution.x+600.0));\n    float coord=iResolution.x+43.17-momento;\n    if(coord<=-43.17)\n        estadoPez[0].x=1.0;\n    momento=mod(t*200.0,(iResolution.x+800.0));\n    coord=iResolution.x+43.17-momento;\n    if(coord<=-43.17)\n        estadoPez[0].y=1.0;\n    momento=mod(t*80.0,(iResolution.x+400.0));\n    coord=iResolution.x+43.17-momento;\n    if(coord<=-43.17)\n        estadoPez[0].z=1.0;\n    //Peces a la izquierda\n    momento=mod(t*250.0,(iResolution.x+4000.0));\n    coord=-43.17+momento;\n    if(coord>=iResolution.x+43.17)\n        estadoPez[1].x=1.0;\n    momento=mod(t*250.0,(iResolution.x*3.0));\n    coord=-43.17+momento;\n    if(coord>=iResolution.x+43.17)\n        estadoPez[1].y=1.0;\n    momento=mod(t*800.0,(iResolution.x+20000.0));\n    coord=-43.17+momento;\n    if(coord>=iResolution.x+43.17)\n        estadoPez[1].z=1.0;\n    //Peces hacia abajo\n    momento=mod(t*150.0,(iResolution.y*2.5));\n    coord=-43.17+momento;\n    if(coord>=iResolution.y+43.17)\n        estadoPez[2].x=1.0;\n    momento=mod(t*100.0,(iResolution.y+600.0));\n    coord=-43.17+momento;\n    if(coord>=iResolution.y+43.17)\n        estadoPez[2].y=1.0;\n    momento=mod(t*100.0,(iResolution.y*4.0));\n    coord=-43.17+momento*momento*0.2;\n    if(coord>=iResolution.y+43.17)\n        estadoPez[2].z=1.0;\n    //Peces hacia arriba\n    momento=mod(t*100.0,(iResolution.y*5.0));\n    coord=iResolution.y+43.17-momento;\n    if(coord<=-43.17)\n       \testadoPez[3].x=1.0;\n    momento=mod(t*1500.0,(iResolution.y*50.0));\n    coord=iResolution.y+43.17-momento;\n    if(coord<=-43.17)\n       \testadoPez[3].y=1.0;\n    momento=mod(t*200.0,(iResolution.y*8.0));\n    coord=iResolution.y+43.17-momento;\n    if(coord<=-43.17)\n       \testadoPez[3].z=1.0;\n    ////////////////////////////////////////////////////////////////////////////\n    fragColor = vec4(0.0);\n    \n    //Se guarda el estado (basado en un shader de iq: https://www.shadertoy.com/view/MddGzf)\n    storeValue( posCuadrado,  vec4(posCuadradoX,posCuadradoY,1.0,1.0), fragColor, fragCoord );\n    storeValue( dirTiempo,  vec4(tiempo,tiempoIni,0.0,0.0), fragColor, fragCoord );\n    storeValue( pintarPez[0], vec4(estadoPez[0],1.0), fragColor, fragCoord );\n    storeValue( pintarPez[1], vec4(estadoPez[1],1.0), fragColor, fragCoord );\n    storeValue( pintarPez[2], vec4(estadoPez[2],1.0), fragColor, fragCoord );\n    storeValue( pintarPez[3], vec4(estadoPez[3],1.0), fragColor, fragCoord );\n    \n    storeValue( dirPuntuacion,  vec4(puntos), fragColor, fragCoord );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}