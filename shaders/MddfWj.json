{
    "Shader": {
        "info": {
            "date": "1526825144",
            "description": "Intermediate result.\nRows 32-46 :)",
            "flags": 0,
            "hasliked": 0,
            "id": "MddfWj",
            "likes": 2,
            "name": "Wrong cube math",
            "published": 3,
            "tags": [
                "raymarching",
                "mistake"
            ],
            "usePreview": 0,
            "username": "mlkn",
            "viewed": 500
        },
        "renderpass": [
            {
                "code": "const float EPSILON = 0.00001;\n\n#define numcubes 4\nvec4 cubes[numcubes];\n\nmat3 makeRotationMatrix(vec3 a)\n{\n    return mat3(\n    \tcos(a.x) * cos(a.z) - sin(a.x) * cos(a.y) * sin(a.z),\n        -cos(a.x) * sin(a.z) - sin(a.x) * cos(a.y) * cos(a.z),\n        sin(a.x) * sin(a.y),\n        sin(a.x) * cos(a.z) + cos(a.x) * cos(a.y) * sin(a.z),\n        -sin(a.x) * sin(a.z) + cos(a.x) * cos(a.y) * cos(a.z),\n        -cos(a.x) * sin(a.y),\n        sin(a.y) * sin(a.z),\n        sin(a.y) * cos(a.z),\n        cos(a.y)\n    );\n}\n\n// https://www.shadertoy.com/view/ld2GRz\nfloat sceneSDF( vec3 pos )\n{\n\tbool inRangeOfBoundingShape = false; \n\tfloat dmin = 1e20;\n    \n    float p = 0.0;\n\tfloat h = 1.0; // track Lipschitz constant\n    \n    for (int i=0; i<numcubes; i++) {\n        vec3 cubePos = cubes[i].rgb;\n        vec3 cubeSize = vec3(cubes[i].w);\n        mat3 rot = makeRotationMatrix(vec3(iTime * 2.0, 0.0, 0.0));\n        \n        vec3 cubeDistPoint = (abs(pos - rot*cubePos) - cubeSize) / cubeSize;\n        vec3 cl = rot*clamp(cubeDistPoint, vec3(0.0), vec3(1.0));\n        float cubeP =  max(max(cl.x, cl.y), cl.z);\n\n        float cubeBoundingR = sqrt(dot(cubeSize, cubeSize)) * 0.5;\n\n        if (cubeP < cubeBoundingR) {\n            inRangeOfBoundingShape = true;\n\n            float x = cubeP / 0.5;\n            p += 1.0 - x;\n            // todo: h\n        } else {\n            dmin = min( dmin, cubeBoundingR );\n        }\n    }\n    \n\tif (inRangeOfBoundingShape) {\n\t\tfloat threshold = 0.2; // surface potential value\n\t\treturn h*(threshold-p);\n    } else {\n    \treturn dmin + 0.1;\n    }\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n\tvec3 ro = vec3(0., 0., 1.0), p, repeatedP;\n    \n    cubes[0] = vec4(0.4, 0.3, -0.7 - 1.3*sin(iTime + 0.4), 0.1);\n    cubes[1] = vec4(-0.4, 0.3, -0.7 + sin(iTime), 0.1);\n    cubes[2] = vec4(0.4,-0.3, -0.7 - sin(iTime), 0.1);\n    cubes[3] = vec4(-0.4, -0.3, -0.7 + 1.3*sin(iTime + 0.4), 0.1);\n    \n    float rt = sin(iTime * 0.6);\n    mat2 rot2 = mat2(cos(rt), sin(rt), -sin(rt), cos(rt));\n\tvec3 rd = normalize(vec3(uv, -1));\n\tp = ro;\n    \n\tfloat t = 0.;\n    vec3 normal = vec3(0.0);\n    \n\tfor (float i = 0.; i < 2.0; i += .01) {\n\t\tp = ro + rd * t;\n        \n\t\tfloat d = sceneSDF(p);\n        if (d < .001) {\n            normal = estimateNormal(p);\n            break;\n        }\n        \n\t\tt += d * 0.4;\n        if (t > 70.) {\n            break;\n        }\n\t}\n\tfragColor = vec4(normal, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}