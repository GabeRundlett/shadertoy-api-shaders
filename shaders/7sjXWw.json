{
    "Shader": {
        "info": {
            "date": "1722725961",
            "description": "Explanations on BuffA. \nSPACEBAR clean the board <==> take 'snapshot' of video \n144+ texture call by pixel per frame --> not mobile friendly\nchange SWITCH to 1 or 0 in Common Buffer to change from \"first pixel served\" to \"input erase existing\" behaviors",
            "flags": 48,
            "hasliked": 0,
            "id": "7sjXWw",
            "likes": 5,
            "name": "Fork automata_0 NikolaErce 169",
            "published": 3,
            "tags": [
                "automata"
            ],
            "usePreview": 0,
            "username": "NikolaErceg",
            "viewed": 71
        },
        "renderpass": [
            {
                "code": "#define S3(A) vec3(sin(A+0.00),sin(A+1.04*1.0),sin(A+2.08*1.0))\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n\tvec2 R= iResolution.xy, u = f.xy / R.xy;\n    vec4 ret = texture(iChannel0, u);\n    vec3 or = ret.xyz;\n\n    if (ret.w >= 0.)\n        #ifdef GREENONBLUE\n    \t{\n        \tfloat hi = or.x*(or.z+ZS)/(2.*ZS); // normalize Z\n    \t\tret.xyz = (-abs(hi)/1.+.50)*S3(hi*3.14*1.+1.570*-.25);\n    \t}\n        #else\n        ret.xyz = (or.zzz/(2.*ZS)+.5)*S3((or.z)*3.14*1./(2.*ZS));\n\t    // following 2 lines let u see better how positive values diminish/spread\n\t    //if ((or.z) < ZS-1.)\n\t    //    ret.xyz = vec3(1.)*or.z;//*(or.zzz/12.);\n    \t#endif\n    else\n        ret.xyz = ret.xxx;\n\n\to = vec4(ret.xyz, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n* This automata is based on the \"inversion\" of \n* local maxima of (3*3) square around cell + cell\n* by the local maxima of the moore neighborhood of the same 9 cells\n* It's seeded by vandamme contours who kindly introduce real numbers in the system\n* wich then in turn give numbers a direction to spread on\n*/\n\n/*\n* red store cell state\n* green store frame information (global inversion state)\n* blue store coloring info\n*/\n\nvec2\tlv1(vec2 uv)\n{\n    return N8(iChannel1, uv, 1./iChannelResolution[1].xy).xy;\n}\n\nvec3\tlv0(vec2 uv)\n{\n    return N8(iChannel0, uv, 1./iChannelResolution[0].xy).xyz;\n}\n\nvec3 lsum;\nvec3 vandamme;\nvec2 texsize;\n\nvoid forward(inout vec4 o, vec2 f, inout float vlv1, in vec4 cell)\n{\n    lsum = vec3(.0);\n    vec2 coord;\n    for(int i = -1; i < 2; i++)\n        for(int j = -1; j < 2; j++)\n        {\n            vec2 cd = vec2(i, j);\n        \tcoord = (f+cd) * texsize;\n            o.x = max(texture(iChannel0, coord).x, o.x)*1./1.;\n            /*\n\t\t\t*  Variable o.x is collecting the maximum value\n\t\t\t*  out of the domain (neighborhood + current_cell)\n\t\t\t*  keep in mind, this value can still be negative\n\t\t\t*/\n            lsum.xz = max(lsum.xz, lv0(coord.xy).xz);///9.;\n            /*\n\t\t\t*  let domain NC be neighborhoodUcurrent_cell\n\t\t\t*  let domain NNC be neighborhood(NC)\n\t\t\t*  lsum become the maxima of the domain NNC\n\t\t\t*  Variable vlv1 is operating on NNC\n\t\t\t*/\n            vlv1 += lv1(coord).x/9.;\n            /*\n\t\t\t*  vlv1 is acting on the video input texture\n\t\t\t*  vlv1 is given the sum of the cells of the set\n\t\t\t*  giving following weights : \n\t\t\t*  1 2 3 2 1\n\t\t\t*  2 3 5 3 2\n\t\t\t*  3 5 8 5 3\n\t\t\t*  2 3 5 3 2\n\t\t\t*  1 2 3 2 1\n\t\t\t*  divided by 72, there are 72 texture fetches\n\t\t\t*  size(neighborood) + size(current_cell) == 9.\n\t\t\t*  8*9 = 72\n\t\t\t*  \n\t\t\t*  Don't forget this is added to a variable that already hold\n\t\t\t*  the value of neighborhood(current_cell), \n\t\t\t*  this will be usefull for getting \"inside\" edges\n\t\t\t*  because the resulting total weights for vlv1 is\n\t\t\t*  1 2 3 2 1\n\t\t\t*  2 3 5 3 2\n\t\t\t*  3 5 8 5 3\n\t\t\t*  2 3 5 3 2\n\t\t\t*  1 2 3 2 1\n\t\t\t* + \n\t\t\t* 9 *\n\t\t\t*  0 0 0 0 0\n\t\t\t*  0 1 1 1 0\n\t\t\t*  0 1 0 1 0\n\t\t\t*  0 1 1 1 0\n\t\t\t*  0 0 0 0 0\n\t\t\t*  \n\t\t\t*  ==\n\t\t\t*  \n\t\t\t*  01 02 03 02 01\n\t\t\t*  02 12 14 12 02\n\t\t\t*  03 14 08 14 03\n\t\t\t*  02 12 14 12 02\n\t\t\t*  01 02 03 02 01\n\t\t\t* divided by ((9*1)*8) + 9*8 = 144\n\t\t\t*/\n        }\n    /*\n\t*\tsince we are using lsum to divide o, we want to add cell_value to lsum\n\t*   this is done in order to add stability (immovability==1. --> freedom==.0)\n\t*   play with the weight of cell.x, don't forget to change it in the \n\t*   weight division too.\n\t*/\n    lsum.x = cell.x*1.+1.*lsum.x;\n    lsum.x /= 1.+1.;\n    \n    /*\n\t*  o = o/-lsum;\n\t*  let domain NC be neighborhoodUcurrent_cell\n\t*  This can be defined up as global inversion of maxima of domain NC\n\t*  over the maxima of the neighborhood of NC\n\t*/\n    if (abs(lsum.x) <= 0.0) // prevent division by 0\n    {\n    \to.x = 0.; \n        return ;\n    }\n    o.x = -o.x/lsum.x;\n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    g_colors = mod(iTime*.075, 2.) - 1.;\n    g_switch = g_colors >= .0 ? 1. : .0;\n    o = -o;\n    o = vec4(.0,0.,.0,.0);\n    vec2 R = iResolution.xy, u = f / R;\n    texsize = 1./R.xy;\n    vec4\tret = texture(iChannel0, u);\n    ret.y += (iFrame == 0 ? 1. : 0.);\n    float kb;\n    //kb = texelFetch( iChannel2, ivec2(32,0), 0 ).x; //caused a compilation issue on some hardware\n    kb = texture(iChannel2, vec2(32.5/256., 0.25)).x;\n    if (kb > .5 || g_colors >= .0 && g_colors <= .005) // spacebar pressed or color changing to fill\n    {\n        o.xyz = vec3(.0, 1.,.0); // clear screen\n        return;\n    }\n    vec2 mouse = iMouse.zw / iResolution.xy;\n    vec2 um = u - mouse;\n\n    vandamme = texture(iChannel1, u).xyz;\n\tfloat vlv1; // will store \"contour\" information of vandamme\n    float green = 1.;\n    /*\n\t*  Variable green will hold the state of green screen\n\t*  it will multiply the end result of video processed\n\t*/\n\n    if (length(vandamme.xz) < vandamme.y)\n        green = .0;\n    /*\n\t*  This checks if green > (red and blue)\n\t*  one way to do greenscreening\n\t*/\n    vlv1 = lv1(u).x/1.;\n    forward(o, f, vlv1, ret);\n    /*\n\t*\tvlv1 is divided by 2 here to normalize stuff\n\t*/\n    vlv1 /=2.;\n\n    /*\n\t*  video treatment\n\t*/\n    \n    /*\n\t*\tadding 2 sigmoids to get a contour\n\t*/\n\n    vlv1 = sigmoid(-.25+.5*vlv1)+sigmoid(.465-.90*vlv1);\n    /*\n\t*   green will hold (contours * !greenscreen)\n\t*/\n    if (g_switch == 0.)\n    green /= (abs(vlv1) < 0.001 ? 0.01 : vlv1);    \n    else\n    green *= vlv1*1.;\n    /*\n\t*  Following commented line helps when fiddling with countour treshold of other video\n\t*  It also help to change SWITCH to 0 in the Common tab\n\t*/\n    //green = clamp(green, -1., 1.);\n\n    /*\n\t* Clipping video to the borders and cutting off low value of video\n\t*/\n    float trigger = (length(vandamme.x) > 0.25 ? 1.0 : 0.0);\n    trigger *= step(abs(u.y-0.5), .46)*step(abs(u.x-0.5), .46);\n    \n    /*\n\t*  Variable borders is used to draw the solid border\n\t*/\n    float borders = (max(abs(u.x-.5)-.0, abs(u.y-.5))-.45);    \n        \n\tif ( trigger == 1.)\n    {\n        if (g_switch == 1.)\n        o.x += 1.*green*1.*(1.*(1.));\n        else\n        o.x  = 1.*green*1.*(1.*(1.));\n    }\n    /*\n\t*\tThe following unvariant will initiate some more movements\n\t*   mind the sign, it's always the same\n\t*\tour red system is alternating between values -1., 1. and 0.\n\t*   the addition of this invariant allows for a deviation from 0.\n\t*   since o.x deviate from 0 on the whole plane, lsum do too\n\t*   wich in turn gives (!=0) chunks more possible direction to spread on\n\t*/\n    //o.x += -iTimeDelta*iTimeDelta*1.0;\n    /*\n\t*   Constraining this invariant to alternate like red allow the movements\n\t*   to be constrained inside SHAPE(positive value chunks)\n\t*/\n    //o.x += -iTimeDelta*iTimeDelta*(ret.y);\n\n    /*\n\t*  o.z will be used for coloration purpose\n\t*  without touching the degrees of liberty of the system\n\t*  we store o.x before it's clipped in variable tz\n\t*/\n\n    float tz = -ret.z*1.0+1.0*abs(o.x)*1.;\n    //tz = tz*1.-1./(.005+1.*lsum.z*lsum.z); // experiment with shape constraint to get outer shape\n    /*\n\t*  the range of clamp define degrees of freedom because o is clipped most\n    *  of the time\n    */\n    o.x = clamp(o.x, -1.0, +1.);\n    o.z = clamp(tz , -ZS , +ZS);\n    if\t(\n\t\t\t(borders < .0150 && borders > .010)\n\t\t)\n\t\to += 1.0*vec4(1.*ret.y, 0., ZS*ret.y, 1.);\n\to.y = -ret.y;\n    /*\n\t*   o.y will store the global inversion state\n    *   in order to avoid flicker we will hide 1/2 frames\n\t*   This is buffer B's job\n    */\n    o.w = g_colors;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 f )\n{\n\tvec2 R= iResolution.xy, u = f.xy / R.xy;\n    vec4 ret = texture(iChannel0, u);\n    vec4 pre = texture(iChannel1, u);\n\n    if (g_switch ==  0.)\n    \tret.y = -ret.y;\n    if (ret.y == -1.)\n        ret = pre;\n    //ret *= ret.y; // it flicker without js click on SWITCH 0\n    fragColor = (ret);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// switch behavior\n// SWITCH 1 --> first pixel arrived, first pixel served, addition rule\n// SWITCH 0 --> video texure write itself on top of existing pixels\nfloat g_colors, g_switch;\n\n//#define GREENONBLUE // alternative color mode, works best with low (< 12) ZS\n\n\n// Z scale, used for coloring\n#define ZS 127.\n\n// Curb your sigmoids\nfloat sigmoid(float x) { return 2./(1. + exp2(-x)) - 1.; }\n\n// Moore neighborhood\nvec3\tN8(sampler2D chan, vec2 uv, vec2 texsize)\n{\n\tvec3\tret = vec3(0.);\n    \n    if (uv.x == 0. || uv.y == 0. || uv.x== 1. || uv.y ==1.)\n        return (ret);\n    \n    ret += texture(chan, vec2(uv.x -texsize.x, uv.y) ).xyz * (.125);\n    ret += texture(chan, vec2(uv.x +texsize.x, uv.y) ).xyz * (.125);\n    ret += texture(chan, vec2(uv.x , uv.y -texsize.y) ).xyz * (.125);\n    ret += texture(chan, vec2(uv.x , uv.y +texsize.y) ).xyz * (.125);\n    \n    ret += texture(chan, vec2(uv.x -texsize.x, uv.y -texsize.y) ).xyz * (.125);\n    ret += texture(chan, vec2(uv.x +texsize.x, uv.y -texsize.y) ).xyz * (.125);\n    ret += texture(chan, vec2(uv.x +texsize.x, uv.y +texsize.y) ).xyz * (.125);\n    ret += texture(chan, vec2(uv.x -texsize.x, uv.y +texsize.y) ).xyz * (.125);\n    return (ret);\n}\n\n// random number utility, will be used later to try seeding on still pictures\n// and adding details on empty regions\nfloat N21(vec2 p) {\n\tp = fract(p*vec2(234.34, 435.345));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}