{
    "Shader": {
        "info": {
            "date": "1634051013",
            "description": "The centre looks a little off, I've changed this a few times now",
            "flags": 0,
            "hasliked": 0,
            "id": "ss3XWX",
            "likes": 17,
            "name": "Log Polar Test",
            "published": 3,
            "tags": [
                "e"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 452
        },
        "renderpass": [
            {
                "code": "#define pi 3.14159\n\n// Code modified from here:\n// https://thebookofshaders.com/edit.php#09/marching_dots.frag\n// https://www.osar.fr/notes/logspherical/\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec2 movingTiles(vec2 _st, float _zoom, float _speed){\n    //_st.x = fract(2.*_st.x);\n    //_st.y = fract(2. * _st.y);\n    float time = iTime*_speed;\n    float ft = fract(2.*abs(_st.x-0.5) + 2.*abs(_st.y -0.5)  + time);\n    \n    _st *= _zoom;//sqrt(_zoom);\n    \n    float k = step(0.5, ft);\n    _st.x += k * sign(fract(_st.y * 0.5) - 0.5) *ft * 2.0;\n    _st.y += (1.-k) * sign(fract(_st.x * 0.5) - 0.5) * ft * 2.0;\n\t\n    // replace 3. for fun times\n    return fract(_st * 3.);\n}\n\nfloat circle(vec2 uv, float r){\n    uv = uv - .5;\n //  float a = atan(uv.y, uv.x);  \n //  return step(length(uv) * (1. + cos(20. * a + iTime)) * 0.4, r);\n   \n   return smoothstep(1.0-r,1.0-r+r*0.2,1.-dot(uv,uv)*3.14);\n}\n\nvoid render( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (fragCoord - .5 * iResolution.xy) /iResolution.y;\n    float time = iTime;\n    \n    // Apply the forward log-polar map\n    st = vec2(log(length(st)), atan(st.y, st.x));\n\n    // Scale everything so tiles will fit nicely in the ]-pi,pi] interval\n    st *= 0.5/pi;\n\n    // Convert pos to single-tile coordinates\n    st.x = fract(st.x - 0.05 * time) - 0.;\n    st.y = fract(st.y + 0.03 * time) - 0.;\n\n    // Do the actual pattern\n    float zoom = 17.;\n    \n    // Cut uv into smaller uvs\n    vec2 uv = fract(st * zoom);\n    vec2 ft = floor(st * zoom);\n    \n    // Generate values for each corner of uv\n    float l = h21(vec2(mod(ft.x+1., zoom), ft.y));\n    float t = h21(vec2(ft.x, mod(ft.y+1., zoom)));\n    float tl = h21(vec2(mod(ft.x+1.,zoom), mod(ft.y+1., zoom)));\n    float id = h21(vec2(ft.x, ft.y));\n\n    // Smooth edges of uvs so they meet nicely\n    uv = uv * uv * (3. - 2. * uv);\n    \n    // Box lerp between corner values\n    float v = l * uv.x * (1.-uv.y)\n     \t    + t * (1.-uv.x) * uv.y\n     \t    + tl * uv.x * uv.y\n      \t    + id * (1.-uv.x) * (1.-uv.y);\n        \n    // Generate tile pattern\n    st = movingTiles(st, zoom, 0.2);\n\n    // Scale circles weirdly ( set to 1. to see normal )\n    float sc = (1. + 0.5 * cos(time + 10.*cos(10. * v)));\n    vec3 color = vec3( circle(st, 0.8 * v * sc) - circle(st, 0.6 * v * sc) );\n\n    fragColor =  vec4(color, 1.);\n}\n\n\n//Copy paste this under the other shader\n#define AA 2.\n#define ZERO min(0.0,iTime)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 1.0/AA;\n    vec4 col = vec4(0);\n    \n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    \n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n            //If the shader has global variables they need to be reset here\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}