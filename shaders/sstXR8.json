{
    "Shader": {
        "info": {
            "date": "1632846283",
            "description": "Dumb little shader that i've been playing with - trying to do some title effects - very nerdy I know..",
            "flags": 32,
            "hasliked": 0,
            "id": "sstXR8",
            "likes": 56,
            "name": "Fractal Computer",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "refraction",
                "computer",
                "replica"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 814
        },
        "renderpass": [
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    09/28/21 @byt3_m3chanic \n    Fractal Computer\n\n    Buffer A / Fragment Shader\n    Buffer B / Title and Text Overlay\n\n*/\n\n#define R iResolution\n\nvoid mainImage( out vec4 O, in vec2 F )\n{  \n\tvec2 uv = F.xy/R.xy;\n    \n    vec3 A = texture(iChannel0, uv).rgb;\n    vec4 B = texture(iChannel1, uv);\n    vec3 C = mix(A,vec3(B.rgb),B.w);\n    \n    // output\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    09/28/21 @byt3_m3chanic \n    Fractal Computer\n\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\nfloat eoc(float t) { return (t = t - 1.0) * t * t + 1.0; }\n\nfloat tmod,ga1,ga2,ga3,ga4,ga5,ca1;\n\n//@iq thanks for the sdf's!\nfloat cap( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdbox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdframe( vec3 p, vec3 b, float e ) {\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// polar mod\nfloat modPolar(inout vec2 p, float rep) {\n    float angle = 2.*PI/rep;\n    float a = atan(p.y, p.x) + angle/2.;\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*length(p);\n    return (abs(c) >= (rep/2.)) ? abs(c) : c;\n} \n\n//globals\nmat2 tprot, rx, ry;\n\n//folds\nvoid siepr(inout vec4 p, float k1, float k2, float k3, float k4) {\n\tif (p.x + p.y<0.0) p.xy = -p.yx;\n\tif (p.x + p.z<0.0) p.xz = -p.zx;\n\tif (p.y + p.z<0.0) p.zy = -p.yz;\n\tp.xyz = p.xyz*k1 - vec3(k2, k3, k4)*(k1 - 1.0);\n\tp.w *= k1;\n}\n\nconst float zoom = 10.;\n\nvec2 map(vec3 p) {\n    vec2 res =vec2(1e5,0.);\n    vec3 pp = p;\n    \n    p.x+=(ga5*14.5)-2.5;\n    p.y+=.75;\n    \n    p.x=mod(p.x+7.25,14.5)-7.25;\n    vec4 P = vec4(p.xyz, 1.0);\n\n    P.yz*=rot(ga2*PI);\n    P.xz*=rot(ga1*PI);\n    P.x+=1.75; \n    siepr(P,1.,1.,1.,1.); \n    \n    vec3 q = P.xyz;\n    \n    float fw = 2.75+1.25*sin(ga4);\n    q.x=abs(q.x)-((ga3*5.));\n    q.z=abs(q.z)-((ga2*2.5)+1.);\n    q.y+=1.;\n    \n    float mainbox = sdbox(q-vec3(0,1.1,0),vec3(1.5,3,.75));\n    float cutbox =  sdbox(q-vec3(0,2.50,.775),vec3(1.3,1.,1.1));\n    float cutbox_lower = sdbox(vec3(q.xy,abs(q.z))-vec3(0,-.225 ,.775),vec3(.75,1.5,.3 ));\n\n    cutbox = min(cutbox_lower, cutbox);\n    mainbox = max(mainbox, -cutbox);\n\n    vec3 fq = vec3(q.y,abs(q.x),q.z);\n    float frame = sdframe(q-vec3(0,1.1,0),vec3(1.6,3.1,.82),.075)-.0125;\n    frame = min(sdbox(fq-vec3(.020,.835,.1),vec3(1.675,.05,.75)),frame);\n    frame = min(sdbox(fq-vec3(-.20,.425,.6),vec3(1.6,.05,.15)),frame);\n\n    float screen = sdbox(q-vec3(0,2.50,.825),vec3(1.4,1.1,.05));\n    screen = max(screen, -cutbox);\n    frame = min(screen-.0125,frame);\n    \n    // parts\n    vec3 cq = vec3(q.y,q.z,abs(q.x));\n    //frame = min(sdbox(q-vec3(0,2.05,.5),vec3(.45,.195,.06)),frame);\n    frame = min(cap(cq-vec3(2.8,-.1,.625),.25,.6),frame);\n    frame = min(cap(cq-vec3(1.95,.15,.725),.125,.15),frame);\n    frame = min(cap(cq-vec3(2.05,.15,1.05),.075,.15),frame);\n    frame = min(sdbox(q-vec3(0,1.3,.6),vec3(.445,.35,.15)),frame);\n\n    mainbox = min(mainbox, frame);\n\n    float tapeB = cap(vec3(q.y,q.z,abs(q.x))-vec3(2.8,.55,.65),.225,.1);\n    tapeB = min(  cap(vec3(q.y,q.z,abs(q.x))-vec3(1.95,.5,.65),.100,.1),tapeB);\n\n    vec3 tq1 = q.yzx-vec3(2.8,.25,.65);\n    vec3 pq1 = tq1;\n    pq1.xz*=tprot;\n    modPolar(pq1.xz,3.);\n    float tcbx = sdbox(pq1-vec3(.4,0,0),vec3(.09,.09,.075));\n    \n    float tape1 = cap(tq1,.575,.05);\n    tape1=max(tape1,-tcbx);\n\n    vec3 tq2 = q.yzx-vec3(2.8,.25,-.65);\n    vec3 pq2 = tq2;\n    pq2.xz*=tprot;\n    modPolar(pq2.xz,2.);\n    float tcby = sdbox(pq2-vec3(.4,0,0),vec3(.09,.09,.075));\n    float tape2 = cap(tq2,.575,.05);\n    tape2=max(tape2,-tcby);\n    \n    tape1 = min(tape1, tape2);\n    \n    if(tape1<res.x) res = vec2(tape1/P.w,3.);\n\n    // buttons\n    vec3 bq = q-vec3(.0,3.85,.65);\n    bq.x=abs(abs(bq.x)-.5)-.25;\n    bq.y=abs(bq.y)-.1;\n    float btn1 = sdbox(bq,vec3(.2,.05,.25))-.0125;\n    btn1 = min(sdbox(q-vec3(0,2.05,.5),vec3(.45,.195,.06))-.0125,btn1);\n    if(btn1<res.x) res = vec2(btn1/P.w,2.);\n\n    if(mainbox<res.x) res = vec2(mainbox/P.w,1.);\n\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist) {\n    float e = mindist*t;\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec3 render(vec3 p, vec3 rd, vec3 ro, float d, float m, inout vec3 n, inout float fresnel) {\n    n = normal(p,d,.5);\n    vec3 lpos =  vec3(8,10,-8);\n    lpos.xz*=ry;\n    vec3 l = normalize(lpos-p);\n    float diff = clamp(dot(n,l),0.,1.);\n    \n    fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n    fresnel = mix(.0, .9, fresnel);\n\n    vec3 h = vec3(.3);\n    \n    if(m==1.) h=mix(vec3(.05),vec3(.3),clamp((p.y+4.)*.1,0.,1.));\n\n    if(m==2.) {\n        vec3 h2=mix(vec3(0.596,0.110,0.690),vec3(0.129,0.467,0.831),clamp((p.x+4.)*.07,0.,1.));\n        h=mix(vec3(0.016,0.431,0.008),h2,clamp((p.z+4.)*.07,0.,1.));\n    }\n    if(m==3.) {\n        vec3 h2 = h=mix(vec3(0.639,0.596,0.000),vec3(0.165,0.698,0.180),clamp((p.x+4.)*.1,0.,1.));\n        h=mix(h2,vec3(0.169,0.569,0.871),clamp((p.y+4.)*.1,0.,1.));\n    }\n    \n    return diff*h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    // precal\n    float time = T;\n    \n    tprot=rot(T*75.*PI/180.);\n    //all the timing stuff\n    tmod = mod(time, 16.);\n    float t1 = lsp(0.0, 2.0, tmod);\n    float t2 = lsp(6.0, 7.0, tmod);\n    \n    float t3 = lsp(2.0, 3.5, tmod);\n    float t4 = lsp(9.0, 10.0, tmod);\n    \n    float t5 = lsp(4.0, 5.0, tmod);\n    float t6 = lsp(9.0, 10.0, tmod);\n\n    float t7 = lsp(4.0, 6.0, tmod);\n    float t8 = lsp(14.0, 16.0, tmod);\n    float t9 = lsp(11.0, 15.0, tmod);\n    \n    ga1 = eoc(t1-t2);\n    ga1 = ga1*ga1*ga1;\n \n    ga2 = eoc(t3-t4);\n    ga2 = ga2*ga2*ga2;\n    \n    ga3 = eoc(t5-t6);\n    ga3 = ga3*ga3*ga3; \n    \n    ga4 = eoc(t7-t8);\n    ga4 = ga4*ga4*ga4;\n    \n    t9 = eoc(t9);\n    t9 = t9*t9*t9;  \n    ga5 = (t9);//+floor(time*.1);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    //orthographic camera\n    vec3 ro = vec3(uv*zoom,-zoom-15.);\n    vec3 rd = vec3(0,0,1.);\n\n    float x = M.xy == vec2(0) ? 0. : -(M.y/R.y * .125 - .0625) * PI;\n    float y = M.xy == vec2(0) ? 0. : -(M.x/R.x * .125 - .0625) * PI;\n   \n    float msw = mod(time*.5,32.);\n    float m1 = lsp(0.0, 4.0, msw);\n    float m2 = lsp(16.0, 20.0, msw);\n    ca1 = eoc(m1-m2);\n    ca1 = ca1*ca1*ca1; \n    \n    x += mix(-.38539816339,-.78,ca1);\n    y += mix(2.35,.64,ca1);\n    \n    rx = rot(x);\n    ry = rot(y);\n\n    ro.yz *= rx; ro.xz *= ry;\n    rd.yz *= rx; rd.xz *= ry;\n\n    vec3 C = vec3(.0075);\n    vec3  p = ro + rd;\n    float atten = .95;\n    float k = 1.;\n    float d = 0.;\n    //@blackle's transparent \n    //marcher modified\n    for(int i=0;i<128;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float m = ray.y;\n\n        d = i<48 ? ray.x*.25 : ray.x;\n        p += rd * d *k;\n        \n        if (d*d < 1e-7) {\n  \n            float fresnel=0.;\n            C+=render(p,rd,ro,d,ray.y,n,fresnel)*atten;\n  \n            atten *= .575;\n            p += rd*.075;\n            k = sign(map(p).x);\n\n            vec3 rr = vec3(0);\n\n            if(m==3.) {\n                rd=reflect(-rd,n);\n                p+=n*.05;\n            } else {\n                rr = refract(rd,n,.55);\n                rd=mix(rr,rd,.5-fresnel);\n            }\n\n        } \n       \n        if(distance(p,rd)>35.) { break; }\n    }\n\n    if(C.r<.008&&C.g<.008&&C.b<.008) C = hash21(uv)>.5 ? C+.005 : C;\n    //C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    09/28/21 @byt3_m3chanic \n    Title Overlay Template\n\n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\nfloat time,tmod,ga1,ga2,ga3,ca1,ca2,ca3;\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\nfloat eoc(float t) { return (t = t - 1.0) * t * t + 1.0; }\n\n////////////////////////////////////////////////////////\n// Fabrice Neyret https://www.shadertoy.com/view/llySRh\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.44;\n#define C(c) spc O+= char(U,64+CAPS+c);\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n// webGL2 variant with dynamic size\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i/=10, p.x += .5 )\n        v += char(p, 48+ i%10 );\n    return v;\n}\nvec4 pFloat(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45 ), n = -n;\n    v += pInt(p,floor(n)); p.x -= .5;\n    v += char(p, 46);      p.x -= .95;\n    v += pInt(p,fract(n)*1e2);\n    return v;\n}\n////////////////////////////////////////////////////////\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(23.86,48.32)))*4374.432); }\n\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec4 getHeader(vec2 uv, float px) {\n    vec3 C = vec3(1);\n    vec4 O = vec4(0);\n    vec2 U = ( (uv*8.)+vec2(1.95,+.5) )/.5;\n\n    C(6); low C(18);C(1);C(3);C(20);C(1);C(12); spc caps\n    \n    C(3); low C(15);C(13);C(16);C(21);C(20);C(5);C(18); spc caps\n    \n    float shadetext = O.x;\n    shadetext = smoothstep(px,.95-px,shadetext);\n    float ofs = ca3*.25;\n    float tapeline=box(uv+vec2(.235-ofs,.03),vec2(ofs ,.0425));\n    tapeline=smoothstep(px,.001-px,tapeline);\n\n    return vec4(vec3(C),ca3>0.?clamp(tapeline-shadetext,0.,1.):0.);\n}\n\nvec4 getDate(vec2 uv, float px) {\n    vec3 C = vec3(1);\n    vec4 O = vec4(0);\n    vec2 U = ( (uv*8.)+vec2(1.825,.5) )/.35;\n\n    low C(2);C(25);C(20);U.x-=.4;\n    O+=pInt(U,3.);\n    spc\n    C(13);U.x-=.475;\n    O+=pInt(U,3.);\n    C(3);C(8);C(1);C(14);C(9);C(3);\n    spc spc\n    \n    O+=pInt(U,9.);C(-49); spc spc\n    O+=pInt(U,28.);C(-49); spc spc\n    O+=pInt(U,21.);\n    \n    float shadetext = O.x;\n    shadetext = smoothstep(px,.95-px,shadetext);\n    float ofs = ca2*.25;\n    float tapeline=box(uv+vec2(.235-ofs,.04),vec2(ofs ,.025));\n    tapeline=smoothstep(px,.001-px,tapeline);\n    \n    return vec4(C,ca2>0.?clamp(tapeline-shadetext,0.,1.):0.);\n}\n\nfloat getHatch(vec2 p, float res) {\n    p *= res;\n    float hRnd = hash21(floor(p*.5));\n\n    if (hRnd > 0.33) p*= rot(1.57079632679);\n    float hatch = clamp(sin((p.x - p.y)*PI*2.)*2. + .5, 0., 1.);\n    return hatch;\n}\n\nvec4 getFrame(vec2 uv, float px) {\n\n    vec2 fv = uv;\n    fv.y += .0085*sin(fv.x*70.+T*10.);\n    float frame=box(fv-vec2(.7,-.59),vec2(.25,.25));\n    frame=smoothstep(px,-px,frame);\n    \n    vec3 h2 =mix(vec3(0.639,0.000,0.565),vec3(0.165,0.698,0.180),clamp((uv.x)*2.,0.,1.));\n    vec3 C=mix(h2,vec3(0.122,0.122,0.122),1.-clamp((uv.y+.615)*1.75,0.,1.));\n    float hatch = getHatch(uv,100.);\n    C = mix(C,vec3(0.271,0.271,0.271),hatch);\n    return vec4(C,frame);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{  \n    time = T+50.;\n\n    float msw = mod(time,32.);\n    float m1 = lsp(0.0, 4.0, msw);\n    float m2 = lsp(16.0, 20.0, msw);\n    \n    ca1 = eoc(m1-m2);\n    ca1 = ca1*ca1*ca1;\n    \n    float m3 = lsp(20.0, 21.0, msw);\n    float m4 = lsp(31.0, 32.0, msw);\n    \n    ca2 = eoc(m3-m4);\n    ca2 = ca2*ca2*ca2;\n    \n    float m5 = lsp(19.5, 20.5, msw);\n    float m6 = lsp(30.5, 31.5, msw);\n    \n    ca3 = eoc(m5-m6);\n    ca3 = ca3*ca3*ca3;\n    \n    vec2 vuv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    float px = .002;\n    vec3 C = vec3(0,0,0);\n\n    vec4 frame = getFrame(vuv+vec2(0,ca1), px);\n    C = mix(C,frame.rgb,frame.w);\n  \n    vec4 logo = getHeader(vuv-vec2(.65,-(.4+ca1)), px);\n    C = mix(C,logo.rgb,logo.w);\n    \n    vec4 date = getDate(vuv-vec2(.65,-(.475+ca1)), px);\n    C = mix(C,date.rgb,date.w);\n    \n    float alpha = clamp(frame.w+logo.w+date.w,0.,1.);\n    O = vec4(C,alpha);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}