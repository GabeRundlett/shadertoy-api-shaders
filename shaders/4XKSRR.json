{
    "Shader": {
        "info": {
            "date": "1719835961",
            "description": "A ray marched neon city is partying!",
            "flags": 32,
            "hasliked": 0,
            "id": "4XKSRR",
            "likes": 7,
            "name": "Citadel Life",
            "published": 3,
            "tags": [
                "raymarching",
                "reflection",
                "stars",
                "city",
                "fxaa",
                "neon"
            ],
            "usePreview": 0,
            "username": "orblivius",
            "viewed": 171
        },
        "renderpass": [
            {
                "code": "// Created by Reinder Nijhoff 2016\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/ls3GWS\n//\n// car model is made by Eiffie\n// shader 'Shiny Toy': https://www.shadertoy.com/view/ldsGWB\n//\n// demonstrating post process FXAA applied to my shader 'Tokyo': \n// https://www.shadertoy.com/view/Xtf3zn\n//\n// FXAA code from: http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/\n//\n\n#define FXAA_SPAN_MAX 8.0\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0/4.0)\n\nvec3 FxaaPixelShader( vec4 uv, sampler2D tex, vec2 rcpFrame) {\n    \n    vec3 rgbNW = textureLod(tex, uv.zw, 0.0).xyz;\n    vec3 rgbNE = textureLod(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSW = textureLod(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSE = textureLod(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbM  = textureLod(tex, uv.xy, 0.0).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(tex, uv.xy + dir * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(tex, uv.xy + dir * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rcpFrame = 1./iResolution.xy;\n  \tvec2 uv2 = fragCoord.xy / iResolution.xy;\n    \n    vec3 col;\n    vec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));\n    col = FxaaPixelShader( uv, iChannel0, 1./iResolution.xy );\n    \n    fragColor = vec4( col, 1. );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PROPERTY_FACADE 0\n#define PROPERTY_NEON 1\n#define PROPERTY_NONE 2\n\nconst float pi = acos(-1.);\n\nmat2 rot(float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\n\treturn mat2(c, -s, s, c);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox(vec3 p, vec3 b)\n{\n\tp = abs(p) - b;\n\t\n\treturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBoxFrame(vec3 p, vec3 b, float e)\n{\n\tp = abs(p) - b;\n\tvec3 q = abs(p + e) - e;\n\n\treturn min(min(\n\t\tlength(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n\t\tlength(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n\t\tlength(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat hash(vec2 v)\n{\n\tv = cos(183.14 * fract(124.923 * v));\n\n\treturn fract(128.4 * sin(183.412 * v.y) * fract(123.411 * v.x));\n}\n\nvec2 hash2D(vec2 v)\n{\n\tv = cos(183.14 * fract(124.923 * v));\n\n\treturn fract(vec2(128.4 * sin(183.412 * v.y) * fract(123.411 * v.x),\n\t\t217.14 * sin(182.195 * v.x) * fract(23.19 + 18.51 * v.y)));\n}\n\nfloat findPerlinDot(vec2 cellID, vec2 cellUV, vec2 corner)\n{\n\treturn dot(2. * hash2D(cellID + corner) - 1., cellUV - corner);\n}\n\nfloat generateNoise2D(vec2 uv)\n{\n\tvec2 cellID \t= floor(uv);\n\tvec2 cellUV \t= fract(uv);\n\tvec2 e \t\t\t= vec2(0., 1.);\n\tfloat d00 \t\t= findPerlinDot(cellID, cellUV, e.xx);\n\tfloat d01 \t\t= findPerlinDot(cellID, cellUV, e.xy);\n\tfloat d10 \t\t= findPerlinDot(cellID, cellUV, e.yx);\n\tfloat d11 \t\t= findPerlinDot(cellID, cellUV, e.yy);\n\tfloat bottom \t= mix(d00, d10, cellUV.x);\n\tfloat top \t\t= mix(d01, d11, cellUV.x);\n\n\treturn mix(bottom, top, cellUV.y);\n}\n\nfloat generateBoxHeight(vec3 p)\n{\n    vec2 pc = .1+vec2(round(mod(p.x*10.,40.)/40.),0.);\n    float snd = (texture(iChannel0, vec2(pc.x,0.)).r +\n           texture(iChannel0, vec2(pc.x+0.001,0.)).r);\n\treturn .4 + snd*.5 + .75 * hash(floor(p.xz));\n}\n\nvec3 buildBox(vec3 p)\n{\n\tfloat width = .15;\n\tfloat height = generateBoxHeight(p);\n\t\n\treturn vec3(width, height, width);\n}\n\nvec3 applyDomainRepetition(vec3 p)\n{\n\tvec3 q = p;\n\tq.xz = fract(q.xz) - .5;\n\tq.xz *= rot(hash(floor(p.xz)));\n\tq.xz += .75 * (hash2D(floor(p.xz)) - .5);\n\n\treturn q;\n}\n\nfloat sdNeon(vec3 p)\n{\n\tif (p.z > 0.)\n\t\treturn 1.;\n\tvec3 q = applyDomainRepetition(p);\n\tfloat a = 1.01;\n\tfloat height = generateBoxHeight(p);\n\tfloat neon = sdBoxFrame(q - vec3(0., height, 0.), a * buildBox(p), .001);\n\n\treturn neon;\n}\n\nfloat map(vec3 p)\n{\n\tif (p.z > 0.)\n\t\treturn 1.;\n\tvec3 q = applyDomainRepetition(p);\n\tfloat height = generateBoxHeight(p);\n\tfloat facade = sdBox(q - vec3(0., height, 0.), buildBox(p));\n\n\treturn facade;\n}\n\n// https://iquilezles.org/articles/palettes/\nvec3 applyPalette(float t)\n{\n\tvec3 a = vec3(0.938, 0.328, 0.718);\n\tvec3 b = vec3(0.659, 0.438, 0.328);\n\tvec3 c = vec3(0.388, 0.388, 0.296);\n\tvec3 d = vec3(2.538, 2.478, 0.168);\n\t\n\treturn a + b * cos(2. * pi * (c * fract(t) + d));\n}\n\nvec3 moveCamera(vec3 v)\n{\n\tmat2 rxz = rot(6. * (2. * .25 - .5));\n\tv.xz *= rxz;\n\tmat2 ryz = rot(6. * (2. * .3 - .5));\n\tv.yz *= ryz;\n\n\treturn v;\n}\n\nvec4 trace(vec2 uv)\n{\n\tvec3 ro = moveCamera(vec3(1., -1.+2.*cos(iTime*.2), 1.+1.*sin(iTime*.2)));\n\tro.x -= 0.1;\n\tvec3 rd = moveCamera(normalize(vec3(uv, -1.)));\n\tvec3 p = ro;\n\tfloat numIterations = 500.;\n\tvec3 light = vec3(0.);\n\tfloat reflection = 1.;\n\tfor (float i = 0.; i < numIterations; ++i)\n\t{\n\t\tfloat d = map(p);\n\t\tvec3 col = 1. * light;\n\t\tvec3 paletteColor = applyPalette(.1 * (p.x + p.z - 4.));\n\t\tfloat neon = sdNeon(p);\n\t\tif (neon < .01)\n\t\t\treturn vec4(reflection * 2.5 * paletteColor, 1.);\n\t\tif (d < .01)\n\t\t{\n\t\t\tcol = mix(col, vec3(.980, 0.164, 0.388),\n\t\t\t\t.75 * smoothstep(.25, .4, generateNoise2D(vec2(10. * p.y, floor(5. * p.x)))));\n\t\t\tcol = clamp(col, 0., 1.);\n\n\t\t\treturn vec4(reflection * col, 1.);\n\t\t}\n\t\tif (p.y > 5. || d > 100.)\n\t\t{\n\t\t\tfloat alpha = p.y < 0. ? 1. : 2. * length(min(light, vec3(1.)));\n\t\t\t//float alpha = 0.;\n\n\t\t\treturn vec4(col, alpha);\n\t\t}\n\t\tif (p.y < 0.)\n\t\t{\n\t\t\trd = reflect(rd, vec3(0., 1., 0.));\n\t\t\treflection = .5;\n\t\t\tp.y = 0.01;\n\t\t}\n\t\t\n\t\t// Building neons.\n\t\tlight += .0007 * pow(neon, -2.) * d * paletteColor;\n\n\t\t// Ground neons.\n\t\tlight += .03 * smoothstep(.5, 0., p.y) * d * vec3(.980, 0.164, 0.388);\n\n\t\t// Background light.\n\t\t//light += .03 * smoothstep(0., -10., p.z) * d * vec3(.328, .834, .711);\n\n\t\tlight *= .99;\n\t\tp += .1 * d * rd;\n\t}\n\n\treturn vec4(0.);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\tvec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 uvv = uv + .4- .5*vec2(-sin(iTime*.2),-cos(iTime*.2));\n\tfloat stars = smoothstep(.23, .8, generateNoise2D(100. * uv));\n\tfloat sdMoon = max(length(uvv - vec2(0., .95)) - .1, -(length(uvv - vec2(.05, 1.)) - .15));\n\tfloat moon = .1*abs(sin(-iTime*.1))*pow(50. * max(0.001+.01*(sin(iTime*.2)), sdMoon), -10.);\n\tfloat threshold = 0.3;\n\tmoon -= smoothstep(threshold, threshold + 0.5, uvv.x + uvv.y);\n\tmoon = clamp(moon, 0., abs(sin(iTime*.1)));\n\tvec4 image = trace(uv);\n\tvec3 col = vec3(stars + moon);\n\tcol = mix(col, vec3(1., 1., 2.), .5 * smoothstep(0., -1., uv.y));\n\tcol = mix(col, image.rgb, clamp(image.a, 0., 1.));\n\tfragColor = vec4(col, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 35,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}