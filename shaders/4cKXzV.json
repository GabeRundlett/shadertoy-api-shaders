{
    "Shader": {
        "info": {
            "date": "1716003693",
            "description": "space to play/pause, click to toggle cells",
            "flags": 48,
            "hasliked": 0,
            "id": "4cKXzV",
            "likes": 10,
            "name": "Pentagonal Conway's game",
            "published": 3,
            "tags": [
                "cellularautomata"
            ],
            "usePreview": 0,
            "username": "ArmandB",
            "viewed": 203
        },
        "renderpass": [
            {
                "code": "#define r3 1.73205080757\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = uvmap(fragCoord, iResolution.xy);\n    float pxunit = uvmap(vec2(0,1), iResolution.xy).y;\n    \n    ivec3 pcoord = coordtopenta(uv);\n    fragColor = mix(vec4(0.337,0.404,0.443,1), vec4(0.580,0.608,0.573,1), texelFetch(iChannel0, pcoord.xy, 0)[pcoord.z])*smoothstep(0.0,pxunit*4.0,pentagrid(uv) - 0.01);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//rule: 2,3/3,4,6 (see https://en.wikipedia.org/wiki/Life-like_cellular_automaton#Notation_for_rules)\nbool gol(int n, bool s){\n    return (s && (n == 2 || n == 3)) || (!s && (n == 3 || n == 4 || n == 6));\n}\n\n//each pixel stores 4 pentagons\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    if (iFrame != 0){\n        if (iFrame % 20 == 0 && texelFetch(iChannel1, ivec2(32,2), 0).x > 0.0){\n            vec4 result = vec4(0);\n\n            //fetch surrounding pentagons\n            vec4 g0 = texelFetch(iChannel0, ivec2(fragCoord), 0);\n            vec4 g1 = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(0,-1), 0);\n            vec4 g2 = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(1,-1), 0);\n            vec4 g3 = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(1,0), 0);\n            vec4 g4 = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(1,1), 0);\n            vec4 g5 = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(0,1), 0);\n            vec4 g6 = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(-1,1), 0);\n            vec4 g7 = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(-1,0), 0);\n            vec4 g8 = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(-1,-1), 0);\n\n            //run conway's game on each pentagon in this pixel\n            int neighbors = int(g0[1] + g0[2] + g0[3] + g1[2] + g1[3] + g7[1] + g8[3]);\n            result[0] = float(gol(neighbors, g0[0] == 1.0));\n\n            neighbors = int(g0[0] + g0[2] + g0[3] + g1[3] + g2[2] + g3[0] + g3[2]);\n            result[1] = float(gol(neighbors, g0[1] == 1.0));\n\n            neighbors = int(g0[0] + g0[1] + g0[3] + g5[0] + g6[1] + g7[3] + g7[1]);\n            result[2] = float(gol(neighbors, g0[2] == 1.0));\n\n            neighbors = int(g0[0] + g0[1] + g0[2] + g3[2] + g4[0] + g5[0] + g5[1]);\n            result[3] = float(gol(neighbors, g0[3] == 1.0));\n            \n            fragColor = result;\n        } else {\n            fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        }\n    } else {\n        ivec2 c = ivec2(fragCoord);\n        fragColor = vec4(\n            c == ivec2(1,1),\n            c == ivec2(1,1),\n            c == ivec2(1,1),\n            c == ivec2(1,1)\n        );\n    }\n    \n    if (iMouse.w > 0.0){\n        ivec3 pcoord = coordtopenta(uvmap(iMouse.xy, iResolution.xy));\n        if (pcoord.xy == ivec2(fragCoord)){\n            fragColor[int(pcoord.z)] = float(texelFetch(iChannel0, ivec2(fragCoord), 0)[pcoord.z] == 0.0);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define r3 1.73205080757\n\nvec2 uvmap(vec2 coord, vec2 res){\n    return coord/res.y*15.0;\n}\n\n//gets texture coords + index of a pixel\nivec3 coordtopenta(vec2 uv){\n    uv = mat2(1,-1,1,1)*uv;\n    vec2 cuv = floor(uv);\n    uv = fract(uv) - 0.5;\n    \n    vec2 puv = cuv;\n    int idx = 0;\n    if (mod(cuv.x,2.0) == mod(cuv.y,2.0)){\n        vec2 ruv = mat2(-r3,-1,1,-r3)*uv;\n        idx = int(ruv.x < 0.0) + 2*int(ruv.y < 0.0);\n    } else {\n        vec2 ruv = mat2(r3,1,1,-r3)*uv;\n        bool a = ruv.x < 0.0;\n        bool b = ruv.y < 0.0;\n        idx = 2*int(a) + int(b);\n        puv += sign(ruv.x)*vec2(a == b, a != b);\n    }\n    puv = mat2(1,1,-1,1)*puv/2.0;\n    \n    return ivec3(puv, idx);\n}\n\nfloat sdLine(vec2 a, vec2 b, vec2 p){\n    vec2 ab = b - a;\n    float t = dot(p - a, ab)/dot(ab, ab);\n    vec2 p2 = a + clamp(t,0.0,1.0)*ab;\n    return length(p - p2);\n}\n\n//draws the lines between the pentagons\nfloat pentagrid(vec2 uv){\n    uv = mat2(1,-1,1,1)*uv*r3;\n    vec2 cuv = floor(uv/r3);\n    uv = fract(uv/r3)*r3;\n    float d = 1e20;\n    if (mod(cuv.x,2.0) == mod(cuv.y,2.0)){\n        d = min(d, sdLine(vec2(r3/2.0 - 0.5, 0),vec2(r3/2.0 + 0.5, r3),uv));\n        d = min(d, sdLine(vec2(0, r3/2.0 + 0.5),vec2(r3, r3/2.0 - 0.5),uv));\n        d = min(d, sdLine(vec2(0, 0),vec2(r3/2.0 - 0.5, 0),uv));\n        d = min(d, sdLine(vec2(r3, r3),vec2(r3/2.0 + 0.5, r3),uv));\n        d = min(d, sdLine(vec2(0, r3),vec2(0, r3/2.0 + 0.5),uv));\n        d = min(d, sdLine(vec2(r3, 0),vec2(r3, r3/2.0 - 0.5),uv));\n    } else {\n        d = min(d, sdLine(vec2(0, r3/2.0 - 0.5),vec2(r3, r3/2.0 + 0.5),uv));\n        d = min(d, sdLine(vec2(r3/2.0 + 0.5, 0),vec2(r3/2.0 - 0.5, r3),uv));\n        d = min(d, sdLine(vec2(0, 0),vec2(0, r3/2.0 - 0.5),uv));\n        d = min(d, sdLine(vec2(r3, r3),vec2(r3, r3/2.0 + 0.5),uv));\n        d = min(d, sdLine(vec2(r3, 0),vec2(r3/2.0 + 0.5, 0),uv));\n        d = min(d, sdLine(vec2(0, r3),vec2(r3/2.0 - 0.5, r3),uv));\n    }\n    return d;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}