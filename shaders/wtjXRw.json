{
    "Shader": {
        "info": {
            "date": "1572140806",
            "description": "For details, please read the extensive manual in the \"Image\" tab.\nThis shadertoy uses interactive sliders to switch between a few image processing algorithms and to tweak their parameters.",
            "flags": 32,
            "hasliked": 0,
            "id": "wtjXRw",
            "likes": 7,
            "name": "Image processing with sliders",
            "published": 3,
            "tags": [
                "mouse",
                "ui",
                "utils",
                "sliders",
                "widgets",
                "toolkit"
            ],
            "usePreview": 0,
            "username": "denilsonsa",
            "viewed": 628
        },
        "renderpass": [
            {
                "code": "/*\n\nThere are instuctions over here because the \"description\" field in shadertoy is too small.\n\n\n== User Manual ==\n\nThis \"toy\" has several interactive sliders to control the behavior.\n\nClick outside the \"sliders\" to hide them. Click again to show them.\n\n\n== Sliders ==\n\nHere's the documentation of each slider (from left to right), and their values (from bottom to top):\n\n1. Image scaling mode:\n    1. 1:1 pixel ratio, no scaling.\n    2. Fit to screen, keeping the aspect ratio (and add black bars as needed).\n    3. Fit to screen, keeping the aspect ratio. Instead of black bars, data\n       pixels outside the texture are either clamped to the border or repeated\n       (depending on iChannel0 configuration of Buf A).\n    4. Stretch to fill the entire screen.\n    5. Cover the screen, keeping the aspect ratio and cropping the image.\n2. Grayscale algorithm:\n    1. Pass-through, keep the input image as is.\n    2. RGB threshold, reducing to 1-bit per channel.\n    3. RGB adaptative threshold.\n    4. Desaturate, transform to grayscale by averaging the RGB channels.\n    5. B&W threshold, reducing to 1-bit.\n    6. B&W adaptative threshold.\n3. Threshold:\n    * For RGB and B&W 1-bit conversion, defines the threshold to consider either black or white.\n    * For adaptative threshold, changes the bias given to the region average.\n    * Unused for Pass-through and Desaturate algorithms.\n4. Adaptative threshold region size:\n    * Adaptative threshold works by comparing the current pixel against its neighbors.\n      This slider controls the size of the region around the current pixel.\n      The region can have 4, 8, 12, 20, 24 neighbor pixels.\n    * Unused unless adaptative threshold algorithm is selected.\n\n\n== Changing the input image ==\n\nGo to \"Buf A\" and change the iChannel0 to change the source image.\nYou can even change it to your webcam.\n\n\n== Pipeline Overview ==\n\n.----------------.\n|  Source image  |\n'----------------'\n        |\n        | Scaling the source image to the texture buffer.\n        v\n.----------------.\n|    Buffer A    |\n'----------------'\n        |\n        | Converting to grayscale or BW (thresholding).\n        v\n.----------------.\n|    Buffer B    |\n'----------------'\n        |\n        | Drawing the UI (from Buffer D) on top of it.\n        v\n.----------------.\n|     Output     |\n'----------------'\n\n\n== Credits ==\n\n* Code by me:\n    * <http://denilson.sa.nom.br/>\n* Main idea inspired by:\n    * [8-Bits Of Image Processing You Should Know!](https://youtu.be/mRM5Js3VLCk)\n    * [source-code](https://github.com/OneLoneCoder/olcPixelGameEngine/blob/master/Videos/OneLoneCoder_PGE_8BitsImProc.cpp)\n* UI code written in shader language inspired by:\n    * [Shader UI Toolkit](https://www.shadertoy.com/view/4lBcD3)\n    * [digits/sliders/kbd widgets - 2](https://www.shadertoy.com/view/MdKGRw)\n\n\n== Ideas and TODO ==\n\n* We need a new slider and further algorithms.\n    * Algorithms based on neighbor pixels:\n        * Blur, Sharpen (both are considered convolution)\n        * Sobel\n        * Dilation, Erosion, Edge\n        * Median\n    * Most/all of them can reuse the list of neighbor offsets from the adaptative threshold.\n      They can have a slider to tweak the size (just like in adaptative threshold).\n    * Dilate / Erode can have a single slider from -1.0 to 1.0.\n        * 0.0 doesn't chang anything.\n        * 0.0~1.0 dilates if the more then <slider> neighbors are black.\n        * 0.0~-1.0 erodes if the more then <slider> neighbors are white.\n        * Both can be implemented through step() function.\n        * Bonus points if I can generalize this for the continuous case (instead of just 1-bit).\n* Algorithms based on previous images:\n    * Motion detect.\n    * Low-pss.\n\n* DONE (kind of)! Finally, it would be awesome to have a built-in help screen using https://www.shadertoy.com/view/ldSBzd or https://www.shadertoy.com/view/llySRh\n* OK! Some algorithms require 1-bit input (i.e. thresholded).\n    * DONE! We should have an intermediate texture to store the thresholded image.\n    * DONE! We should have a slider to toggle between multiple threshold implementations (including nothing).\n* DONE! We could have a slider to toggle between grayscale or color.\n* DONE! We could have a slider to toggle between 1:1 pixel parsing, or linear or nearest interpolation.\n\n\n== End of documentation and instructions ==\n\n*/\n\n////////////////////////////////////////////////////////////\n// Start of the real code.\n\n// This is the result of all image transformations. This should be Buffer B.\n#define SRC_CHANNEL iChannel0\n\n// This should be the channel that stores the UI state.\n#define UI_CHANNEL iChannel3\n\n\nvec3 draw_ui(in vec3 color_from_lower_layer, in vec2 uv) {\n    vec4 texel = texture(UI_CHANNEL, uv);\n    return mix(color_from_lower_layer, texel.rgb, texel.a);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Normalized pixel coordinates (from 0 to 1).\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Copying the final image to screen.\n    fragColor = texture(SRC_CHANNEL, uv);\n\n    // Drawing the UI.\n    if (!GET_BOOL_DATA(DATA_IS_UI_HIDDEN)) {\n    \tfragColor.rgb = draw_ui(fragColor.rgb, uv);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This is the UI layer.\n\n////////////////////////////////////////////////////////////\n// Configurable options/constants.\n\n// Where to read from?\n// This should be the channel that contains this buffer.\n#define UI_CHANNEL iChannel3\n\n// The font texture, used for drawing text.\n#define FONT_CHANNEL iChannel0\n#define FONT_CHANNEL_RES (iChannelResolution[0])\n\n// Set this to 1 or 0.\n#define DEBUG 0\n\n// Dimensions (in UV coordinates from 0.0 to 1.0).\n#define HANDLE_HEIGHT (1.0 / 64.0)\n#define DIVISION_MARK_HEIGHT (1.0 / 64.0)\n#define SLIDER_PATH_WIDTH (SLIDER_WIDTH / 16.0)\n\n// Overall interactive area dimensions and position.\n// These are in UV coordinates (from 0.0 to 1.0).\n#define UI_X_MIN (1.0 / 8.0)\n#define UI_X_MAX (7.0 / 8.0)\n#define UI_Y_MIN ( 5.0 / 16.0)\n#define UI_Y_MAX (11.0 / 16.0)\n\n////////////////////////////////////////////////////////////\n// No need to change anything below this line.\n// See also some macros defined at Common.\n\n\n////////////////////////////////////////////////////////////\n// Text constants, with names inspired by HTML entities.\n\n#define __ 0x20\n#define _EXCL 0x21\n#define _QUOT 0x22\n#define _NUM 0x23\n#define _DOLLAR 0x24\n#define _PERCNT 0x25\n#define _AMP 0x26\n#define _APOS 0x27\n#define _LPAR 0x28\n#define _RPAR 0x29\n#define _AST 0x2A\n#define _PLUS 0x2B\n#define _COMMA 0x2C\n#define _MINUS 0x2D\n#define _PERIOD 0x2E\n#define _SOL 0x2F\n#define _0 0x30\n#define _1 0x31\n#define _2 0x32\n#define _3 0x33\n#define _4 0x34\n#define _5 0x35\n#define _6 0x36\n#define _7 0x37\n#define _8 0x38\n#define _9 0x39\n#define _COLON 0x3A\n#define _SEMI 0x3B\n#define _LT 0x3C\n#define _EQUALS 0x3D\n#define _GT 0x3E\n#define _QUEST 0x3F\n#define _COMMAT 0x40\n#define _A 0x41\n#define _B 0x42\n#define _C 0x43\n#define _D 0x44\n#define _E 0x45\n#define _F 0x46\n#define _G 0x47\n#define _H 0x48\n#define _I 0x49\n#define _J 0x4A\n#define _K 0x4B\n#define _L 0x4C\n#define _M 0x4D\n#define _N 0x4E\n#define _O 0x4F\n#define _P 0x50\n#define _Q 0x51\n#define _R 0x52\n#define _S 0x53\n#define _T 0x54\n#define _U 0x55\n#define _V 0x56\n#define _W 0x57\n#define _X 0x58\n#define _Y 0x59\n#define _Z 0x5A\n#define _LBRACK 0x5B\n#define _BSOL 0x5C\n#define _RBRACK 0x5D\n#define _HAT 0x5E\n#define _LOWBAR 0x5F\n#define _GRAVE 0x60\n#define _a 0x61\n#define _b 0x62\n#define _c 0x63\n#define _d 0x64\n#define _e 0x65\n#define _f 0x66\n#define _g 0x67\n#define _h 0x68\n#define _i 0x69\n#define _j 0x6A\n#define _k 0x6B\n#define _l 0x6C\n#define _m 0x6D\n#define _n 0x6E\n#define _o 0x6F\n#define _p 0x70\n#define _q 0x71\n#define _r 0x72\n#define _s 0x73\n#define _t 0x74\n#define _u 0x75\n#define _v 0x76\n#define _w 0x77\n#define _x 0x78\n#define _y 0x79\n#define _z 0x7A\n#define _LBRACE 0x7B\n#define _VERT 0x7C\n#define _RBRACE 0x7D\n#define _TILDE 0x7E\n\n\n////////////////////////////////////////////////////////////\n// Text.\n\n// Static text drawing area.\n// These are in UV coordinates (from 0.0 to 1.0).\n#define TEXT_X_MIN UI_X_MIN\n#define TEXT_X_MAX UI_X_MAX\n#define TEXT_Y_MIN (12.0 / 16.0)\n#define TEXT_Y_MAX (14.0 / 16.0)\n\n#define TEXT_COLS 40\n#define TEXT_ROWS 2\n\nconst int textdata[TEXT_ROWS * TEXT_COLS] = int[TEXT_ROWS * TEXT_COLS](\n\t__,_S,_c,_a,_l,_i,_n,_g,__,__,__,__,__,_B,_AMP,_W,__,__,__,__,_T,_h,_r,_e,_s,_h,_o,_l,_d,__,__,__,_R,_e,_g,_i,_o,_n,__,__,\n\t__,__,_m,_o,_d,_e,__,__,__,__,_a,_l,_g,_o,_r  ,_i,_t,_h,_m,__,__,_o,_r,__,_b,_i,_a,_s,__,__,__,__,__,_S,_i,_z,_e,__,__,__\n);\n\n// Dynamic text drawing area.\n// These are in UV coordinates (from 0.0 to 1.0).\n#define DTEXT_X_MIN TEXT_X_MIN\n#define DTEXT_X_MAX TEXT_X_MAX\n#define DTEXT_Y_MIN ( 2.0 / 16.0)\n#define DTEXT_Y_MAX ( 4.0 / 16.0)\n\n#define DTEXT_COLS TEXT_COLS\n#define DTEXT_ROWS 2\n\n// The different sections of text.\n// In other words, an array of strings, flattened out in a single array.\n#define DTEXTDATA_SCALING       0\n#define DTEXTDATA_BW_ALGORITHM  5\n#define DTEXTDATA_TOTAL        11\n\nconst int dtextdata[DTEXTDATA_TOTAL * DTEXT_COLS] = int[DTEXTDATA_TOTAL * DTEXT_COLS](\n    _1,_COLON,_1,__,_p,_i,_x,_e,_l,__,_r,_a,_t,_i,_o,_COMMA,__,_n,_o,__,_s,_c,_a,_l,_i,_n,_g,__,__,__,__,__,__,__,__,__,__,__,__,__,\n    _F,_i,_t,__,_t,_o,__,_s,_c,_r,_e,_e,_n,_COMMA,__,_b,_l,_a,_c,_k,__,_b,_a,_r,_s,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n    _F,_i,_t,__,_t,_o,__,_s,_c,_r,_e,_e,_n,_COMMA,__,_c,_l,_a,_m,_p,_SOL,_r,_e,_p,_e,_a,_t,__,__,__,__,__,__,__,__,__,__,__,__,__,\n    _S,_t,_r,_e,_t,_c,_h,_COMMA,__,_d,_i,_s,_t,_o,_r,_t,_i,_n,_g,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n    _C,_o,_v,_e,_r,__,_t,_h,_e,__,_s,_c,_r,_e,_e,_n,_COMMA,__,_c,_r,_o,_p,_p,_i,_n,_g,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n\n    _P,_a,_s,_s,_MINUS,_t,_h,_r,_o,_u,_g,_h,_COMMA,__,_k,_e,_e,_p,__,_c,_o,_l,_o,_r,_s,__,_a,_s,__,_i,_s,__,__,__,__,__,__,__,__,__,\n    _R,_G,_B,__,_t,_h,_r,_e,_s,_h,_o,_l,_d,_COMMA,__,_1,_MINUS,_b,_i,_t,__,_p,_e,_r,__,_c,_h,_a,_n,_n,_e,_l,__,__,__,__,__,__,__,__,\n    _R,_G,_B,__,_a,_d,_a,_p,_t,_a,_t,_i,_v,_e,__,_t,_h,_r,_e,_s,_h,_o,_l,_d,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n    _D,_e,_s,_a,_t,_u,_r,_a,_t,_e,_COMMA,__,_t,_r,_a,_n,_s,_f,_o,_r,_m,__,_t,_o,__,_g,_r,_a,_y,_s,_c,_a,_l,_e,__,__,__,__,__,__,\n    _B,_AMP,_W,__,_t,_h,_r,_e,_s,_h,_o,_l,_d,_COMMA,__,_1,_MINUS,_b,_i,_t,__,_p,_e,_r,__,_p,_i,_x,_e,_l,__,__,__,__,__,__,__,__,__,__,\n    _B,_AMP,_W,__,_a,_d,_a,_p,_t,_a,_t,_i,_v,_e,__,_t,_h,_r,_e,_s,_h,_o,_l,_d,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__\n);\n\nvec4 draw_char(int ascii, vec2 in_char_offset, vec4 color) {\n\t// Area around each character that will be cropped in the texture.\n    const vec2 tex_padding = vec2(0.1875, 0.0);\n\n    // Fetching the character from the texture.\n    // The texture is a 16x16 grid of characters.\n    vec2 font_pos = (\n        // Character position in the texture.\n        vec2(\n            float(ascii % 16),\n            float(ascii / 16)\n        )\n        // Plus an offset inside the character.\n        // This extra math is to make each character\n        // wider than they are in the font texture.\n        // Essentially, I'm \"eating away\" a part of\n        // the glyph from both sides (left and right).\n        + (\n            tex_padding\n            + in_char_offset * (vec2(1.0, 1.0) - 2.0 * tex_padding)\n        )\n    ) / 16.0;\n    // Adjusting for upside-down coordinates.\n    font_pos.y = 1.0 - font_pos.y;\n    vec4 glyph = texture(FONT_CHANNEL, font_pos);\n    // Picking a color.\n    vec4 ret;\n    ret.rgb = glyph.rrr * color.rgb;\n    // Adding a shadow around the text.\n    // The A channel of the texture contains the distance.\n    ret.a = max(glyph.r, smoothstep(0.625, 0.5, glyph.a)) * color.a;\n    return ret;\n}\n\n////////////////////////////////////////////////////////////\n// Slider-related macros and functions.\n\n// Auto-calculating some values.\n#define TOTAL_SLIDERS_WIDTH  (UI_X_MAX - UI_X_MIN)\n#define TOTAL_SLIDERS_HEIGHT (UI_Y_MAX - UI_Y_MIN)\n#define SLIDER_WIDTH (TOTAL_SLIDERS_WIDTH / f_TOTAL_SLIDERS)\n\n// Is the supplied id valid?\n#define IS_VALID_SLIDER(id) ((id) >= 0 && (id) < TOTAL_SLIDERS)\n\n// Returns the slider id for the passed X coordinate.\n// Invalid slider if < 0 or if > TOTAL_SLIDERS.\nint get_slider_for_uv_x(float x) {\n\treturn int(floor((x - UI_X_MIN) * f_TOTAL_SLIDERS / TOTAL_SLIDERS_WIDTH));\n}\n\n// Returns the slider value for the passed Y coordinate.\n// Invalid slider if < 0.0 or if > 1.0.\nfloat get_slider_value_for_uv_y(float y) {\n    return (y - UI_Y_MIN) / TOTAL_SLIDERS_HEIGHT;\n}\n\n////////////////////////////////////////////////////////////\n// Main code that handles the UI.\n\n// It has two main purposes:\n// 1. Read input and store values in the texture.\n// 2. Draw the UI into the texture.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// Coordinates in 0.0 to 1.0 range.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Remember that fragCoord is (usually) integers + 0.5.\n    if (fragCoord.y < 1.0) {\n        // Bottom-most row. Just data.\n        int x = int(floor(fragCoord.x));\n\n        // Preserving the previous value, copying it over.\n        fragColor.rgb = GET_DATA(x).rgb;\n\n        // Detecting if the mouse button is down or up.\n        bool was_mouse_down = GET_BOOL_DATA(DATA_IS_MOUSE_DOWN);\n        bool is_mouse_down = iMouse.z > 0.0 || iMouse.w > 0.0;\n        bool mouse_click_event = is_mouse_down && !was_mouse_down;\n        bool mouse_up_event = !is_mouse_down && was_mouse_down;\n\n        // Detecting mouse click (based on iMouse.zw).\n        int clicked_slider = get_slider_for_uv_x(iMouse.z / iResolution.x);\n        float clicked_y = get_slider_value_for_uv_y(iMouse.w / iResolution.y);\n\n        // Note: This is named DATA_IS_UI_HIDDEN instead of DATA_IS_UI_VISIBLE\n        // because I want it visible by default, and zero is the default value.\n        bool is_ui_hidden = GET_BOOL_DATA(DATA_IS_UI_HIDDEN);\n        bool mouse_started_clicking_inside_ui = (\n            (\n                GET_BOOL_DATA(DATA_IS_UI_CLICKED)\n                && was_mouse_down\n            )\n            || (\n                !is_ui_hidden\n                && mouse_click_event\n                && IS_VALID_SLIDER(clicked_slider)\n                && clicked_y >= 0.0\n                && clicked_y < 1.0\n            )\n        );\n\n        // Calculating the new states and storing them on each pixel/texel.\n\n        if (\n            x == DATA_IS_MOUSE_DOWN\n        ) {\n            // This is used to detect when the mouse starts and stops clicking.\n            fragColor.x = float(is_mouse_down);\n        }\n\n        if (\n            x == DATA_IS_UI_HIDDEN\n            && mouse_click_event\n            && !mouse_started_clicking_inside_ui\n        ) {\n            // Hide/show UI when clicking outside of it.\n            fragColor.x = float(!is_ui_hidden);\n        }\n        \n        if (\n            x == DATA_IS_UI_CLICKED\n        ) {\n            // Saving this in order to properly handle click-and-drag.\n            // And \"properly\" means \"the way users would intuitively expect\".\n            //\n            // Note: This can be refactored. Instead of saving a boolean,\n            // it could save an integer that represents which UI widget got\n            // clicked on. This would require each slider and each interactive\n            // element to have one unique id.\n            fragColor.x = float(mouse_started_clicking_inside_ui);\n        }\n\n\t\tif (\n            x == (DATA_SLIDERS_BEGIN + clicked_slider)\n            && is_mouse_down\n            && mouse_started_clicking_inside_ui\n        ) {\n            // A click started inside a slider.\n            // Let's handle the dragging action by updating the stored value.\n            float new_slider_value = clamp(get_slider_value_for_uv_y(iMouse.y / iResolution.y), 0.0, 1.0);\n            fragColor.x = new_slider_value;\n        }\n\n        // Make it invisible, but make it visible while debugging.\n        fragColor.a = 1.0 * float(DEBUG);\n    } else {\n\n        // This is the majority of the buffer/texture.\n        // (All pixels/texels except the bottom-most row.)\n\n\t\tfragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\n        ////////////////////////////////////////////////////////////\n\t\t// Static text drawing.\n        if (uv.x >= TEXT_X_MIN && uv.x <= TEXT_X_MAX &&\n            uv.y >= TEXT_Y_MIN && uv.y <= TEXT_Y_MAX) {\n\n            // Position in 0.0 to 1.0 range inside the text rectangle.\n            vec2 textarea_pos = vec2(\n                (uv.x - TEXT_X_MIN) / (TEXT_X_MAX - TEXT_X_MIN),\n                (uv.y - TEXT_Y_MIN) / (TEXT_Y_MAX - TEXT_Y_MIN)\n            );\n            // Adjusting for upside-down coordinates.\n            textarea_pos.y = 1.0 - textarea_pos.y;\n            // Coordinates measured in characters.\n            vec2 char_pos = textarea_pos * vec2(TEXT_COLS, TEXT_ROWS);\n            vec2 in_char_offset = fract(char_pos);\n            int char_x = int(floor(char_pos.x));\n            int char_y = int(floor(char_pos.y));\n            // Index of the character in the array.\n            int char_index = (char_y * TEXT_COLS) + char_x;\n            // Sanity check to avoid out-of-bounds.\n            if (char_index >= 0 && char_index < TEXT_ROWS * TEXT_COLS) {\n                // ASCII code of the character to be displayed.\n            \tint ascii = textdata[char_index];\n                fragColor = draw_char(ascii, in_char_offset, vec4(c8, c8, c4, c8));\n            }\n        }\n\n        ////////////////////////////////////////////////////////////\n\t\t// Dynamic text drawing.\n        if (uv.x >= DTEXT_X_MIN && uv.x <= DTEXT_X_MAX &&\n            uv.y >= DTEXT_Y_MIN && uv.y <= DTEXT_Y_MAX) {\n\n            // Position in 0.0 to 1.0 range inside the text rectangle.\n            vec2 textarea_pos = vec2(\n                (uv.x - DTEXT_X_MIN) / (DTEXT_X_MAX - DTEXT_X_MIN),\n                (uv.y - DTEXT_Y_MIN) / (DTEXT_Y_MAX - DTEXT_Y_MIN)\n            );\n            // Adjusting for upside-down coordinates.\n            textarea_pos.y = 1.0 - textarea_pos.y;\n            // Coordinates measured in characters.\n            vec2 char_pos = textarea_pos * vec2(DTEXT_COLS, DTEXT_ROWS);\n            vec2 in_char_offset = fract(char_pos);\n            int char_x = int(floor(char_pos.x));\n            int char_y = int(floor(char_pos.y));\n\n            // Index of the character in the array.\n            int char_index = _X;\n            switch(char_y) {\n                case 0:\n\t\t            int scaling_mode = GET_DISCRETE_SLIDER_DATA(SLIDER_SCALING);\n                \tchar_index = (scaling_mode * DTEXT_COLS) + (DTEXTDATA_SCALING * DTEXT_COLS) + char_x;\n                \tbreak;\n                case 1:\n                \tint algorithm = GET_DISCRETE_SLIDER_DATA(SLIDER_BW_ALGORITHM);\n                \tchar_index = (algorithm * DTEXT_COLS) + (DTEXTDATA_BW_ALGORITHM * DTEXT_COLS) + char_x;\n                \tbreak;\n            }\n            \n            // Sanity check to avoid out-of-bounds.\n            if (char_index >= 0 && char_index < DTEXTDATA_TOTAL * DTEXT_COLS) {\n                // ASCII code of the character to be displayed.\n            \tint ascii = dtextdata[char_index];\n                fragColor = draw_char(ascii, in_char_offset, vec4(c8, c8, c8, c8));\n            }\n        }\n\n\t\t////////////////////////////////////////////////////////////\n\t\t// UI Sliders drawing.\n        \n        // Note: The drawing of the slides is based only on the\n        // stored data, and not on the mouse interaction.\n        // Mouse interaction is handled (and stored) in the\n        // previous conditional (the bottom-most row part).\n        // As a consequence, the UI is always lagging behind\n        // one frame, but in exchange the source-code is simpler\n        // and the UI reflects how the rest of the code behaves\n        // (because the rest of the code is also based on stored values).\n\n        // Checking if fragCoord is inside the interactive area (i.e. where the sliders are located).\n        int current_slider = get_slider_for_uv_x(uv.x);\n\n        if (IS_VALID_SLIDER(current_slider)) {\n            // This is the interactive area (horizontally).\n            // Let's draw the sliders.\n\n            // UV coordinates for the middle of the slider handle position.\n            vec2 slider_uv = vec2(\n                UI_X_MIN + (float(current_slider) + 0.5) * SLIDER_WIDTH,\n                UI_Y_MIN + GET_SLIDER_DATA(current_slider) * TOTAL_SLIDERS_HEIGHT\n            );\n            int slider_divisions = sliders[current_slider].divisions;\n\n            // In range 0.0 to 1.0, corresponding the slider values.\n            float current_y = get_slider_value_for_uv_y(uv.y);\n\n            if (abs(uv.y - slider_uv.y) < HANDLE_HEIGHT / 2.0) {\n                // Drawing the \"handle\".\n            \tfragColor = vec4(\n\t                // Using brighter colors.\n                    (1.0 - 0.5 * (1.0 - sliders[current_slider].color))\n                    * smoothstep(HANDLE_HEIGHT / 2.0, HANDLE_HEIGHT / 8.0, abs(uv.y - slider_uv.y)),\n                    // Fully opaque.\n                    1.0);\n            } else if (current_y >= 0.0 && current_y <= 1.0) {\n                if (abs(uv.x - slider_uv.x) < SLIDER_PATH_WIDTH / 2.0) {\n                    // Drawing the vertical slider \"path\".\n\n                    // Distance in range from 0.0 to 0.5.\n                    float distance_to_closest_mark = 0.5 - abs(mod(current_y * float(slider_divisions), 1.0) - 0.5);\n                    float distance_to_mark_in_uv = distance_to_closest_mark * TOTAL_SLIDERS_HEIGHT / float(slider_divisions);\n                    fragColor = vec4(\n                        mix(\n                            // Using darker colors.\n                            0.5 * sliders[current_slider].color,\n                            // Or black/white for marks.\n                            vec3(smoothstep(DIVISION_MARK_HEIGHT / 4.0, DIVISION_MARK_HEIGHT / 8.0, distance_to_mark_in_uv)),\n                            1.0 - step(DIVISION_MARK_HEIGHT / 2.0, distance_to_mark_in_uv)\n                        ),\n                        1.0  // alpha\n                    );\n                } else {\n                    // Area inside the slider but outside the handle and outside the path.\n                    float discrete_min = f_GET_DISCRETE_SLIDER_DATA(current_slider);\n                    float discrete_max = discrete_min + 1.0;\n                    if (\n                        sliders[current_slider].is_discrete\n                        && current_y * float(slider_divisions) >= discrete_min\n                        && current_y * float(slider_divisions) <= discrete_max\n                    ) {\n                        // Drawing a faint background for discrete sliders.\n                        fragColor = vec4(\n                            sliders[current_slider].color,\n                            0.25  // alpha\n                        );\n                    } else {\n                        // Empty area around the path.\n                    }\n                }\n            } else {\n                // Empty area above and below.\n            }\n        } else {\n            // Empty area to the sides.\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// NOTE: It is important to define UI_CHANNEL, otherwise these macros won't work.\n\n////////////////////////////////////////////////////////////\n// UI Sliders definition.\n//\n// They are defined here in Common because their values\n// need to be read from many buffers.\n\n// Some constants to make it easier to define colors.\n#define c0 (0.0 / 8.0)\n#define c1 (1.0 / 8.0)\n#define c2 (2.0 / 8.0)\n#define c3 (3.0 / 8.0)\n#define c4 (4.0 / 8.0)\n#define c5 (5.0 / 8.0)\n#define c6 (6.0 / 8.0)\n#define c7 (7.0 / 8.0)\n#define c8 (8.0 / 8.0)\n\n// How many interactive sliders do we have?\n// This is esentially an ENUM, listing each slider.\n#define TOTAL_SLIDERS 4\n\n#define ADAPTATIVE_THRESHOLD_LEN 6\n\nconst struct Slider {\n    vec3 color;\n    int divisions;\n    bool is_discrete;\n} sliders[TOTAL_SLIDERS] = Slider[](\n    // Define how the sliders look and behave right here.\n\n#define SLIDER_SCALING 0\n    Slider(vec3(c6, c6, c8), 5, true),\n\n#define SLIDER_BW_ALGORITHM 1\n    Slider(vec3(c6, c6, c6), 6, true),\n#define SLIDER_THRESHOLD 2\n    Slider(vec3(c7, c7, c7), 6, false),\n#define SLIDER_ADAPTATIVE_THRESHOLD 3\n    Slider(vec3(c8, c8, c8), ADAPTATIVE_THRESHOLD_LEN - 1, true)\n);\n\n\n////////////////////////////////////////////////////////////\n// Constants and macros used used in multiple places.\n\n// Weirdly enough PI is not defined by default.\nconst float PI = radians(180.0);\n\n// Same as TOTAL_SLIDERS, but as float instead of int.\n#define f_TOTAL_SLIDERS float(TOTAL_SLIDERS)\n\n// All data (persistent state across multiple frames of animation)\n// is stored in the row y=0.0 of the UI_CHANNEL.\n// These constants are the addresses of each piece of data.\n#define DATA_IS_MOUSE_DOWN 0\n#define DATA_IS_UI_HIDDEN 1\n#define DATA_IS_UI_CLICKED 2\n#define DATA_SLIDERS_BEGIN 3\n#define DATA_SLIDERS_END (DATA_SLIDERS_BEGIN + TOTAL_SLIDERS - 1)\n\n// Get the data from one of the pixels/texels from row y=0.\n#define GET_DATA(index) texelFetch(UI_CHANNEL, ivec2(index, 0), 0)\n#define GET_BOOL_DATA(index) bool(GET_DATA(index))\n\n// Get the data for one slider.\n#define GET_SLIDER_DATA(index) ((GET_DATA(DATA_SLIDERS_BEGIN + index)).x)\n// For discrete data, we have to take care of the case 1.0, because the result should be <1.0.\n#define f_GET_DISCRETE_SLIDER_DATA(index) (min(floor(GET_SLIDER_DATA(index) * float(sliders[index].divisions)), float(sliders[index].divisions) - 1.0))\n#define GET_DISCRETE_SLIDER_DATA(index) int(f_GET_DISCRETE_SLIDER_DATA(index))",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// This is the first transformation.\n// It just scales the source image if needed.\n\n// This is the input image.\n// For fun, you can change it (at the bottom of shadertoy page) to your webcam.\n#define SRC_CHANNEL iChannel0\n#define SRC_CHANNEL_RES (iChannelResolution[0])\n\n// This should be the channel that stores the UI state.\n#define UI_CHANNEL iChannel3\n\n\nvec4 get_pixel(in int scaling_mode, in vec2 coord) {\n    switch (scaling_mode) {\n        case 0:\n\t        // 1:1 pixel mapping (no scaling, but centered on screen).\n        \t{\n                ivec2 offset = ivec2((iResolution.xy - SRC_CHANNEL_RES.xy) / 2.0);\n                return texelFetch(SRC_CHANNEL, ivec2(coord) - offset, 0);\n            }\n        \tbreak;\n        case 1:\n        case 2:\n\t        // Stretch but keep aspect ratio. Similar to CSS background-size: contain.\n        \t// The first variation adds black bars.\n        \t// The second variation just tries to access texture values outside 0.0~1.0 range, which can either clamp or repeat.\n            {\n                float aspect_ratio_ratio = iResolution.x / iResolution.y / (SRC_CHANNEL_RES.x / SRC_CHANNEL_RES.y);\n\n                vec2 uv;\n                if (aspect_ratio_ratio > 1.0) {\n                    uv = (coord / iResolution.xy - 0.5) * vec2(aspect_ratio_ratio, 1.0) + 0.5;\n                } else {\n                    uv = (coord / iResolution.xy - 0.5) / vec2(1.0, aspect_ratio_ratio) + 0.5;\n                }\n                if (scaling_mode == 1 && (uv.x < 0.0 || uv.y < 0.0 || uv.x > 1.0 || uv.y > 1.0)) {\n                    // Clamping to zero.\n                    return vec4(0.0);\n                } else {\n                    return texture(SRC_CHANNEL, uv);\n                }\n            }\n        \tbreak;\n        case 3:\n\t        // 0.0 to 1.0 UV mapping. Will stretch and distort to fit.\n\t        return texture(SRC_CHANNEL, coord / iResolution.xy);\n        \tbreak;\n        case 4:\n        default:\n\t        // Stretch but keep aspect ratio. Similar to CSS background-size: cover.\n        \t// Crops the source image to prevent black bars.\n            {\n                float aspect_ratio_ratio = iResolution.x / iResolution.y / (SRC_CHANNEL_RES.x / SRC_CHANNEL_RES.y);\n\n                vec2 uv;\n                if (aspect_ratio_ratio < 1.0) {\n                    uv = (coord / iResolution.xy - 0.5) * vec2(aspect_ratio_ratio, 1.0) + 0.5;\n                } else {\n                    uv = (coord / iResolution.xy - 0.5) / vec2(1.0, aspect_ratio_ratio) + 0.5;\n                }\n                return texture(SRC_CHANNEL, uv);\n            }\n        \tbreak;\n    }\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int scaling_mode = GET_DISCRETE_SLIDER_DATA(SLIDER_SCALING);\n    fragColor = get_pixel(scaling_mode, fragCoord);\n    // IDEA: Apply some multiplier and/or addition here just tweak brightness and constrast.\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 11,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This is the second transformation.\n// It converts the scaled image to grayscale or B&W.\n\n// This is the result of the previous step. This should be Buffer A.\n#define SRC_CHANNEL iChannel0\n\n// This should be the channel that stores the UI state.\n#define UI_CHANNEL iChannel3\n\n// I assume all buffers have the same resolution.\n// It's possible to either use texelFetch() or texture().\n//#define GET_PIXEL(coord) (texture(SRC_CHANNEL, (coord).xy / iResolution.xy).rgb)\n//#define GET_PIXEL(coord) (texelFetch(SRC_CHANNEL, ivec2(coord), 0).rgb)\n#define GET_PIXEL(coord) (texelFetch(SRC_CHANNEL, coord, 0).rgb)\n\n// Simple grayscale conversion, average of of RGB values.\n#define GET_PIXEL_GRAY(coord) vec3(length(GET_PIXEL(coord)) / 3.0)\n\n\nconst int adaptative_length[ADAPTATIVE_THRESHOLD_LEN] = int[](\n    1,  // Only the center pixel.\n    5,  // +-1 in orthogonal direction.\n    9,  // +-1 as a square around the pixel.\n    13,  // +-2 in orthogonal, plus +-1 square.\n    21,  // +-2 as almost circle.\n    25  // +-2 as a square.\n\n// Visually: 0 is the center pixel.\n// 54345\n// 42124\n// 31013\n// 42124\n// 54345\n\n);\n\nconst ivec2 adaptative_offsets[] = ivec2[](\n    ivec2( 0,  0),\n\n    ivec2(-1,  0),\n    ivec2( 1,  0),\n    ivec2( 0, -1),\n    ivec2( 0,  1),\n\n    ivec2(-1, -1),\n    ivec2( 1, -1),\n    ivec2(-1,  1),\n    ivec2( 1,  1),\n\n    ivec2(-2,  0),\n    ivec2( 2,  0),\n    ivec2( 0, -2),\n    ivec2( 0,  2),\n    \n    ivec2(-2,  1),\n    ivec2( 2,  1),\n    ivec2( 1, -2),\n    ivec2( 1,  2),\n    ivec2(-2, -1),\n    ivec2( 2, -1),\n    ivec2(-1, -2),\n    ivec2(-1,  2),\n\n    ivec2(-2, -2),\n    ivec2( 2, -2),\n    ivec2(-2,  2),\n    ivec2( 2,  2)\n);\n\n\nvec3 desaturate(in vec3 color) {\n    return vec3((color.r + color.g + color.b) / 3.0);\n}\n\nvec3 get_pixel(in ivec2 coord, in bool grayscale) {\n    vec3 color = GET_PIXEL(coord);\n    if (grayscale) {\n        return desaturate(color);\n    } else {\n        return color;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Coordinates as integers.\n    ivec2 coord = ivec2(fragCoord);\n    \n    float threshold = GET_SLIDER_DATA(SLIDER_THRESHOLD);\n\n    //vec2 uv = fragCoord/iResolution.xy;\n    //fragColor = GET_PIXEL(fragCoord);\n\n    int algorithm = GET_DISCRETE_SLIDER_DATA(SLIDER_BW_ALGORITHM);\n\tswitch(algorithm) {\n        case 0:  // No-op, pass-through, just copy the data without changing.\n        case 3:  // Desaturation, just converting to grayscale.\n        \tfragColor.rgb = get_pixel(coord, (algorithm == 3));\n        \tbreak;\n\n        case 1:  // RGB thresholding to 1-bit per channel.\n        case 4:  // Grayscale thresholding to 1-bit B&W.\n        \tfragColor.rgb = step(threshold, get_pixel(coord, (algorithm == 4)));\n        \tbreak;\n\n        case 2:  // RGB Adaptative thresholding.\n        case 5:  // Adaptative thresholding to 1-bit B&W.\n        default:\n        \tvec3 thispixel = GET_PIXEL(coord);\n        \tvec3 sum = vec3(0.0);\n        \tint len = adaptative_length[1 + GET_DISCRETE_SLIDER_DATA(SLIDER_ADAPTATIVE_THRESHOLD)];\n        \tfor (int i = 0; i < len; i++) {\n                sum.rgb += GET_PIXEL(coord + adaptative_offsets[i]);\n\t        }\n        \tsum.rgb /= float(len + 1);  // Now sum has the average of the region.\n            if (algorithm == 5) {\n                sum.rgb = desaturate(sum.rgb);\n                thispixel.rgb = desaturate(thispixel.rgb);\n            }\n\n        \tfragColor.rgb = step(sum * (0.5 + threshold), thispixel);  // Scaling threshold from 0.0~1.0 to 0.5~1.5.\n        \tbreak;\n    }\n    fragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}