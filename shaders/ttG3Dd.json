{
    "Shader": {
        "info": {
            "date": "1580171076",
            "description": "Simple layered 2D effect.",
            "flags": 0,
            "hasliked": 0,
            "id": "ttG3Dd",
            "likes": 17,
            "name": "Blue Flower",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "Klems",
            "viewed": 480
        },
        "renderpass": [
            {
                "code": "\n#define PI 3.14159265359\n#define rot(a) mat2(cos(a + PI*0.5*vec4(0,1,3,0)))\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    float zoom = exp(-iTime*0.1);\n\tuv *= mix(20.0, 70.0, zoom); // progressive zoom\n    uv.y += 1.0;\n    \n    const vec3 background = vec3(0.8, 0.85, 0.9);\n    const vec3 light = normalize(vec3(1, 2, 3));\n    const vec3 lightColor = vec3(0.9, 0.8, 0.5);\n    \n    float dd = dot(uv,uv);\n    fragColor = vec4(background, 1);\n    \n    vec2 mou = (iMouse.xy-iResolution.xy*0.5)/iResolution.xy*4.0;\n    if (iMouse.z < 0.5) mou = vec2(0);\n    \n    #define LAYERS 20\n    \n    for (int i = min(0, iFrame) ; i < 2 ; i++) {\n    \tfor (int r = min(0, iFrame) ; r < LAYERS ; r++) {\n    \t\t\n            int rr = i == 0 ? LAYERS - r - 1: r;\n            float radius = float(rr*rr+1)*0.05;\n            \n\t\t\tvec3 pHere = vec3(uv, sqrt(max(0.0, radius*radius-dd)));\n\n            float sig = float(i*2-1);\n            vec3 p = pHere;\n            p.z *= sig;\n            vec3 n = p/radius;\n            n *= sig;\n\n            float dist = max(0.0, 2.0 - p.z);\n\n            float time = iTime*0.05 + float(rr)*0.3;\n            p.zy *= rot(2.2+mou.y);\n            p.xz *= rot(-0.1+mou.x);\n            p.yx *= rot(time);\n            p.xz *= rot(sin(time*8.145)*0.2);\n            p.zy *= rot(sin(time*6.587)*0.2);\n\n            float at = atan(p.x, p.y);\n            float rad = (sin(at*5.0)*0.6 + 0.2)*radius;\n\t\t\t\n            // anti-aliased petal border\n            float df = rad-p.z;\n            float aa = fwidth(df);\n            float sm = smoothstep(aa, -aa, df);\n            // anti-aliased wrap around border\n            float dfs = dd-radius*radius;\n            float aas = fwidth(dfs);\n            sm *= smoothstep(aas, -aas, dfs);\n\n            // fake normal mapping\n            float str = cos(at*5.0)*20.0;\n            str *= smoothstep(0.1, 0.0, abs(str/30.0));\n            float dotl = max(0.0, dot(light, n)+str*0.05);\n            // basic lighting + fog\n            vec3 albedo = vec3(0.2, 0.3, 0.8);\n            float ao = 1.0-min(1.0, exp((p.z/radius-1.0)));\n            vec3 col = albedo*lightColor*dotl*3.0 + albedo*background*0.4*ao;\n            col = mix(background, col, exp(-dist*0.1));\n            // accumulate color\n            fragColor.rgb = mix(fragColor.rgb, col, sm);\n\n        }\n        \n    }\n        \n    // gamma correction, vignette, dithering\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n    vec2 uu = (fragCoord.xy-iResolution.xy*0.5)/iResolution.xy;\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), dot(uu,uu)*0.5);\n    fragColor.rgb += (hash33(vec3(fragCoord, iFrame))-0.5)*0.02;\n    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}