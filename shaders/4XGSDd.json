{
    "Shader": {
        "info": {
            "date": "1720611574",
            "description": "CC0: Old 2D Shadows experiment\nI found an old shader that I for some reason never published\nI was experimenting with 2D shadows at that time.\nhought it looked neat so I publish it now instead.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "4XGSDd",
            "likes": 36,
            "name": "Old 2D Shadows experiment",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 361
        },
        "renderpass": [
            {
                "code": "// CC0: Old 2D Shadows experiment\n//  I found an old shader that I for some reason never published\n//  I was experimenting with 2D shadows at that time.\n//  Thought it looked neat so I publish it now instead.\n\n//#define GIVE_ME_A_LOGO_INSTEAD\n//#define GIVE_ME_A_FRACTAL_INSTEAD\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define MAX_MARCHES 40\n#define TOLERANCE   0.0001\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// -----------------------------------------------------------------------------\n// Licenses\n//  CC0     - https://creativecommons.org/share-your-work/public-domain/cc0/\n//  MIT     - https://mit-license.org/\n//  WTFPL   - https://en.wikipedia.org/wiki/WTFPL\n//  Unknown - No license identified, does not mean public domain\n// -----------------------------------------------------------------------------\n\n// Glimglam distance field font\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nconst float glimglam_corner0 = 0.02;\nconst float glimglam_corner1 = 0.075;\nconst float glimglam_topy    = 0.051+glimglam_corner0;\nconst float glimglam_smoother= 0.0125;\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat corner(vec2 p) {\n  vec2 v = min(p, vec2(0));\n  return length(max(p, vec2(0))) + max(v.x, v.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedBox(vec2 p, vec2 b, vec4 r) {\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat glimglam_bar(vec2 p) {\n  vec2 pbar = p;\n  pbar.y -= glimglam_topy;\n  return abs(pbar.y)-glimglam_corner0;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat glimglam_a(vec2 p) {\n  p.x = abs(p.x);\n  float db = roundedBox(p, vec2 (0.19, 0.166), vec4(glimglam_corner1, glimglam_corner0, glimglam_corner1, glimglam_corner0));\n  float dc = corner(p-vec2(0.045, -0.07))-glimglam_corner0;\n\n  float d = db;\n  d = max(d, -dc);\n\n  return d;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat glimglam_c(vec2 p) {\n  p = -p.yx;\n  float db = roundedBox(p, vec2 (0.166, 0.19), vec4(glimglam_corner1, glimglam_corner0, glimglam_corner1, glimglam_corner0));\n  p.x = abs(p.x);\n  float dc = corner(p-vec2(0.055, glimglam_topy))-glimglam_corner0;\n\n  float d = db;\n  d = max(d, -dc);\n\n  return d;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat glimglam_e(vec2 p) {\n  p = -p.yx;\n  float db = roundedBox(p, vec2 (0.166, 0.19), vec4(glimglam_corner0, glimglam_corner0, glimglam_corner0, glimglam_corner0));\n\n  float dl = abs(p.x-(0.075-glimglam_corner0))-glimglam_corner0;\n  float dt = p.y-glimglam_topy;\n\n  float d = db;\n  d = max(d, -pmax(dl,dt, glimglam_smoother));\n\n  return d;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat glimglam_g(vec2 p) {\n  float db = roundedBox(p, vec2 (0.19, 0.166), vec4(glimglam_corner0, glimglam_corner1, glimglam_corner1, glimglam_corner1));\n  float dc = corner(-(p-vec2(-0.045, -0.055)));\n  dc = abs(dc) - glimglam_corner0;\n  float dd = max(p.x-0.065, p.y-glimglam_topy);\n  float d = db;\n  d = max(d, -max(dc, dd));\n  return d;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat glimglam_h(vec2 p) {\n  p.x = abs(p.x);\n  float da = roundedBox(p-vec2(0.13, 0.0), vec2 (0.066, 0.166), vec4(glimglam_corner0));\n  float db = roundedBox(p, vec2 (0.16, 0.05), vec4(glimglam_corner0));\n  float d = da;\n  d = min(d, db);\n  return d;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat glimglam_i(vec2 p) {\n  return roundedBox(p, vec2 (0.066, 0.166), vec4(glimglam_corner0));\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat glimglam_j(vec2 p) {\n  p.x = -p.x;\n  float db = roundedBox(p, vec2 (0.15, 0.166), vec4(glimglam_corner0, glimglam_corner0, glimglam_corner0, glimglam_corner1));\n  float dc = corner(-(p-vec2(-0.007, -0.055)))-glimglam_corner0;\n  float d = db;\n  d = max(d, -dc);\n  return d;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat glimglam_l(vec2 p) {\n  float db = roundedBox(p, vec2 (0.175, 0.166), vec4(glimglam_corner0, glimglam_corner0, glimglam_corner0, glimglam_corner1));\n  float dc = corner(-(p-vec2(-0.027, -0.055)))-glimglam_corner0;\n  float d = db;\n  d = max(d, -dc);\n  return d;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat glimglam_m(vec2 p) {\n  float db = roundedBox(p, vec2 (0.255, 0.166), vec4(glimglam_corner1, glimglam_corner0, glimglam_corner0, glimglam_corner0));\n  p.x = abs(p.x);\n  float dl = abs(p.x-0.095)-glimglam_corner0*2.0;\n  float dt = p.y-glimglam_topy;\n\n  float d = db;\n  d = max(d, -max(dl,dt));\n\n  return d;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat glimglam_n(vec2 p) {\n  float db = roundedBox(p, vec2 (0.19, 0.166), vec4(glimglam_corner1, glimglam_corner0, glimglam_corner0, glimglam_corner0));\n\n  float dl = abs(p.x)-0.07;\n  float dt = p.y-glimglam_topy;\n\n  float d = db;\n  d = max(d, -max(dl,dt));\n\n  return d;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat glimglam_o(vec2 p) {\n  const float sz = 0.05;\n  float db = roundedBox(p, vec2(0.19, 0.166)-sz, vec4(glimglam_corner1, glimglam_corner1, glimglam_corner1, glimglam_corner1)-sz);\n  db = abs(db)-sz;\n\n  float d = db;\n\n  return d;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat glimglam_s(vec2 p) {\n  p.x = -p.x;\n  p = -p.yx;\n  float db = roundedBox(p, vec2 (0.166, 0.19), vec4(glimglam_corner1, glimglam_corner0, glimglam_corner0, glimglam_corner1));\n  vec2 pc = p;\n  pc.x *= sign(pc.y);\n  pc.y = abs(pc.y);\n  float cr = glimglam_corner1*1.3;\n  pc -=vec2(-0.055, 0.20);\n  pc.x = -pc.x;\n  float dc = corner(pc+cr)-cr;\n  vec2 pk = p;\n  pk = -abs(pk);\n  float dk = pk.x+glimglam_topy;\n  dc = min(dk, dc);\n\n  float dl = abs(p.x-(0.075-glimglam_corner0))-glimglam_corner0;\n  float dt = p.y-glimglam_topy;\n\n  float d = db;\n  d = max(d, -pmax(dl,dt, glimglam_smoother));\n  d = pmax(d, dc, glimglam_smoother);\n\n  return d;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat glimglam_t(vec2 p) {\n  float da = roundedBox(p-vec2(0.0, 0.12), vec2 (0.166, 0.05), vec4(glimglam_corner0));\n  float db = roundedBox(p, vec2 (0.066, 0.166), vec4(glimglam_corner0));\n  float d = da;\n  d = min(d, db);\n  return d;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat glimglam_z(vec2 p) {\n  p = -p.yx;\n  float db = roundedBox(p, vec2 (0.166, 0.19), vec4(glimglam_corner0, glimglam_corner0, glimglam_corner0, glimglam_corner0));\n  vec2 pc = p;\n  pc.x *= sign(pc.y);\n  pc.y = abs(pc.y);\n  float cr = glimglam_corner1*1.3;\n  pc -=vec2(-0.055, 0.20);\n  pc.x = -pc.x;\n  float dc = corner(pc+cr)-cr;\n  vec2 pk = p;\n  pk = -abs(pk);\n  float dk = pk.x+glimglam_topy;\n  dc = min(dk, dc);\n\n  float dl = abs(p.x-(0.075-glimglam_corner0))-glimglam_corner0;\n  float dt = p.y-glimglam_topy;\n\n  float d = db;\n  d = max(d, -pmax(dl,dt, glimglam_smoother));\n  d = pmax(d, dc, glimglam_smoother);\n\n  return d;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat glimglam(vec2 p) {\n  float dbar = glimglam_bar(p);\n\n  vec2 pg = p;\n  pg.x -= -0.665;\n  pg.x = -abs(pg.x);\n  pg.x -= -0.7475;\n  pg.x *= -sign(p.x+0.665);\n  float dg = glimglam_g(pg);\n\n  vec2 pi = p;\n  pi.x -= -0.746;\n  float di = glimglam_i(pi);\n\n  vec2 pl = p;\n  pl.x -= -0.27;\n  pl.x = -abs(pl.x);\n  pl.x -= -0.745;\n  pl.x *= -sign(p.x+0.27);\n  float dl = glimglam_l(pl);\n\n  vec2 pa = p;\n  pa.x -= 0.87;\n  float da = glimglam_a(pa);\n\n  vec2 pm = p;\n  pm.x -= 0.475;\n  pm.x = abs(pm.x);\n  pm.x -= 0.875;\n  pm.x *= sign(p.x-0.475);\n  float dm = glimglam_m(pm);\n\n  float d = 1E6;\n  d = min(d, dg);\n  d = min(d, dl);\n  d = min(d, di);\n  d = min(d, da);\n  d = min(d, dm);\n  d = pmax(d, -dbar, glimglam_smoother);\n\n  return d;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat lance(vec2 p) {\n  p.x -= -0.810;\n  float dbar = glimglam_bar(p);\n\n  vec2 pl = p;\n  float dl = glimglam_l(pl);\n\n  vec2 pa = p;\n  pa.x -= 0.39;\n  float da = glimglam_a(pa);\n\n  vec2 pn = p;\n  pn.x -= 0.795;\n  float dn = glimglam_n(pn);\n\n  vec2 pc = p;\n  pc.x -= 1.2;\n  float dc = glimglam_c(pc);\n\n  vec2 pe = p;\n  pe.x -= 1.605;\n  float de = glimglam_e(pe);\n\n  float d = 1E6;\n  d = min(d, dl);\n  d = min(d, da);\n  d = min(d, dn);\n  d = min(d, dc);\n  d = min(d, de);\n  d = pmax(d, -dbar, glimglam_smoother);\n\n  return d;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat jez(vec2 p) {\n  p.x -= -0.401;\n  float dbar = glimglam_bar(p);\n\n  vec2 pj = p;\n  float dj = glimglam_j(pj);\n\n  vec2 pe = p;\n  pe.x -= 0.36;\n  float de = glimglam_e(pe);\n\n  vec2 pz = p;\n  pz.x -= 0.76;\n  float dz = glimglam_z(pz);\n\n  float d = 1E6;\n  d = min(d, dj);\n  d = min(d, de);\n  d = min(d, dz);\n  d = pmax(d, -dbar, glimglam_smoother);\n  return d;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat longshot(vec2 p) {\n  p.x -= -1.385;\n  float dbar = glimglam_bar(p);\n\n  vec2 pl = p;\n  float dl = glimglam_l(pl);\n\n  vec2 po = p;\n  po -= vec2(1.395, 0.0);\n  po.x = abs(po.x);\n  po -= vec2(1.0125, 0.0);\n  float do_ = glimglam_o(po);\n\n  vec2 pn = p;\n  pn -= vec2(0.785, 0.0);\n  float dn = glimglam_n(pn);\n\n  vec2 pg = p;\n  pg -= vec2(1.185, 0.0);\n  float dg = glimglam_g(pg);\n\n  vec2 ps = p;\n  ps -= vec2(1.585, 0.0);\n  float ds = glimglam_s(ps);\n\n  vec2 ph = p;\n  ph -= vec2(1.995, 0.0);\n  float dh = glimglam_h(ph);\n\n  vec2 pt = p;\n  pt -= vec2(2.78, 0.0);\n  float dt = glimglam_t(pt);\n\n  float d = 1E6;\n  d = min(d, dl);\n  d = min(d, do_);\n  d = min(d, dn);\n  d = min(d, dg);\n  d = min(d, ds);\n  d = min(d, dh);\n  d = min(d, dt);\n  d = pmax(d, -dbar, glimglam_smoother);\n  return d;\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p ) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash_(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n\nfloat starn(vec2 p, float r, float n, float m) {\n    // next 4 lines can be precomputed for a given shape\n    float an = PI/float(n);\n    float en = PI/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nfloat df0(vec2 p, out float h) {  \n  p.x += TIME*0.3;\n  const float z = 0.075;\n  float d1 = p.y-0.15; \n  p /= z;\n  vec2 n = mod2(p, vec2(4.0));\n  float h0 = hash(n+123.4);\n  float h1 = fract(1667.0*h0);\n  float h2 = fract(8367.0*h0);\n  p *= ROT(mix(-1.0, 1.0, h1)*TIME);\n//  float d0 = triangle(p);\n  float sn = floor(mix(2.0, 7.0, h2));\n  h = h2;\n  float sm = sn/2.0+1.0;\n  float d0 = starn(p, 0.5, sn, sm);\n  \n  float d = d0;\n  d *= z;\n  d = max(d, d1);\n  return d;\n}\n\nfloat df1(vec2 p, out float h) {\n  const float z = 1.0;\n  p /= z;\n\n  p.y -= -0.;\n  float d = lance(p);\n  d *= z;\n  \n  return d;\n}\n\nfloat apollian(vec3 p, float s) {\n  float scale = 1.0;\n\n\n  for(int i=0; i<3; ++i) {\n    p = -1.0 + 2.0*fract(0.5*p+0.5);\n\n    float r2 = dot(p,p);\n    \n    float k  = s/r2;\n    p       *= k;\n    scale   *= k;\n\n  }\n  \n  vec3 ap = abs(p/scale);  \n  float d = ap.x-0.005;\n  d = max(d, ap.y);\n  d = min(d, ap.z);\n  return d;\n}\n\nfloat df2(vec2 p, out float h) {\n  const float z = 1.25;\n  p /= z;\n\n  vec3 p3 = vec3(p, 0.1);\n  p3.xz*=ROT(0.1*TIME);\n  p3.yz*=ROT(0.123*TIME);\n  float d = apollian(p3, 1.0+0.2);\n  d *= z;\n  \n  return d;\n}\n\n\n\nfloat df(vec2 p, out float h) {\n#if defined(GIVE_ME_A_FRACTAL_INSTEAD)\n  return df2(p, h);\n#elif defined(GIVE_ME_A_LOGO_INSTEAD)\n  return df1(p, h);\n#else  \n  return df0(p, h);\n#endif\n}\n\nfloat shadow(vec2 lp, vec2 ld, float mint, float maxt) {\n  float t = mint;\n\n  float ds = 1.0-0.4;\n  \n  float nd = 1E6;\n  float h;\n  const float soff = 0.05;\n  const float smul = 1.5;\n  for (int i=0; i < MAX_MARCHES; ++i) {\n    vec2 p = lp + ld*t;\n    float d = df(p, h);\n    \n    if (d < TOLERANCE || t >= maxt) {\n      float sd = 1.0-exp(-smul*max(t/maxt-soff, 0.0));\n      return t >= maxt ? mix(sd, 1.0, smoothstep(0.0, 0.025, nd)) : sd;\n    }\n    nd = min(nd, d);\n\n    t += ds*d;\n  }\n  \n  float sd = 1.0-exp(-smul*max(t/maxt-soff, 0.0));\n  return sd;\n}\n\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float aa = 2.0/RESOLUTION.y;\n  \n  float a = 0.25*TIME;\n  vec2  lightPos  = vec2(1.25*cos(a), 0.75*sin(a));\n  vec2  lightDiff = lightPos - p;\n  float lightD2   = dot(lightDiff,lightDiff);\n  float lightLen  = sqrt(lightD2);\n  vec2  lightDir  = lightDiff / lightLen;\n  vec3  lightPos3 = vec3(lightPos, 0.0);\n  vec3  p3        = vec3(p, -1.0);\n  float lightLen3 = distance(lightPos3, p3);\n  vec3  lightDir3 = normalize(lightPos3-p3);\n  vec3  n3        = vec3(0.0, 0.0, 1.0);\n  vec3  ro3       = vec3(0.0, 0.0, 0.0);\n  vec3  rd3       = normalize(p3 - ro3);\n  float diff      = max(dot(lightDir3, n3), 0.0);\n  vec3 col = vec3(0.0);\n \n  float h;\n  float d   = df(p, h);\n  float od = abs(d)-aa*1.0;\n  float ss = shadow(p,lightDir, 0.005, lightLen);\n  vec3 bcol = hsv2rgb(vec3(h, 0.75, 1.0));\n  col += mix(0., 1.0, diff)*0.5*mix(0.1, 1.0, ss)/(lightLen3*lightLen3);\n  col = mix(col, vec3(0.0), smoothstep(aa, -aa, d));\n  col = mix(col, bcol, smoothstep(aa, -aa, od));\n  col += exp(-40.0*max(lightLen-0.02, 0.0));\n \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q); \n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}