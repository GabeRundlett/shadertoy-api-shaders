{
    "Shader": {
        "info": {
            "date": "1725377854",
            "description": "originals  https://www.shadertoy.com/view/sdt3W2",
            "flags": 0,
            "hasliked": 0,
            "id": "Xc2BRd",
            "likes": 2,
            "name": "crystalized star",
            "published": 3,
            "tags": [
                "fractal",
                "star",
                "crystal"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 117
        },
        "renderpass": [
            {
                "code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n#define time iTime\n#define resolution iResolution.xy\nfloat makePoint(float x,float y,float fx,float fy,float sx,float sy,float t){\n   float xx=x+sin(t*fx*.4)*sx*2.0;\n   float yy=y+cos(t*fy)*sy;\n   return 1.5/sqrt(xx*xx*yy*yy)/(time+5000.);\n}\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a)) //basic rotation matrix thingy yay\n\nfloat t; vec3 glw; //global time and glow variables\n\nfloat bx(vec3 p, vec3 s) //like a cube right, but better, because it can be SCALED!\n{\n  vec3 q=abs(p)-s;\n  return min(max(q.x,max(q.y,q.z)), 0.) + length(max(q,0.));\n}\n\nfloat cyl(vec3 p, float r) //a cylinder. do you know where the ends of it are? I sure don't...\n{\n  return length(p.xz)-r; \n}\n\nfloat tor(vec3 p, vec2 t) //mmn donut shape - ITS A TORUS OKAY?\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat crys(vec3 p, vec3 pp) //makes a cool fluidy warping crystal thingy, p = result centre, pp = kifs centre\n{\np.xz*=rot(iTime); //rotate it\n  p.zy*=rot(iTime);\n  for(float i=0.;i<10.;i++) //blah blah blah kifs yay funky lots of cubes\n  {\n      pp.xy*=rot(i - 2.+0.1); //rotate it and do fun stuff with \"i\"\n      pp.xy=abs(pp.xy)-i*0.2; //free duplication tactics here\n      pp.xy=abs(pp.xy)-2.1; //more high performance cloning\n       //rotate it too\n      pp.yz*=rot(i); //some more rotation just to make sure it's REALLY messed up by now\n  }\n  float b=bx(pp*0.9,vec3(2))-0.03; //create a rando cube in the middle lets go\n  b=mix(b,bx(p,vec3(1)),0.5); //mix is actually amazing with SDFs, this turns the whole mess of cubes into something actually interesting and cool. comment out to see the mess instead\n  float g=length(p); //i just calculated the distance to the centre of this world or something\n  glw+=exp(-g*0.8)*mix(vec3(1,0,0.2),vec3(0.2,0.5,1),sin(t/4.)*0.5+0.5)*0.03; //glow glow glow glow glow glow glow glow glow\n  return b; //\"box\"\n}\n\nvec2 mp(vec3 p) //scene goes here yes\n{  \n  float i = clamp(10.-t,0.,10.); //smooth intro morph variable yay cool\n  float z = (sin(t/3.)*0.5+0.5)*1.5; //slow z warping for better effect\n  float ta = 1.-pow(1.-mod(t,3.) * 0.3,2.);\n  vec3 co=mix(vec3(1,0,0.2),vec3(0.2,0.5,1),sin(-t/4.)*0.5+0.5); //funky colours yup\n  vec3 pp=p-vec3(0,0,i+z); //second position for things yes\n  vec3 ppp=p; //more positions because why not\n  pp.xy*=rot(-t/3.); //rotate it\n  ppp.xy*=rot(t*0.1); //rotate it too\n  vec2 cry = vec2(crys(ppp,pp),1.); //it's a glowy crystal, go cry about it - but if you wanna see a different varient, swap ppp and pp in this line\n  pp=p;pp.yz*=rot(1.57); //reset pp so we can reuse it and also rotate it aprox 90 degrees\n  float tr = tor(pp-vec3(0,12.*ta,0), vec2(16.*ta,0.01)); //donut time!\n  cry.x=min(cry.x,tr); //add donut we don't really care about the material it's just for glow\n  glw+=exp(-tr*1.5)*co*0.1; //do the glowy :D\n  pp=p-vec3(0,9,12);pp.x=abs(pp.x)-11.;pp.x*=0.3;//hooray for free cloning technology\n  float br=bx(pp,vec3(0.5,30,100))-0.2; //make background walls exist\n  pp.z-=mod(t*5.,20.)+5.; pp.z=abs(pp.z)-10.;pp.z=abs(pp.z)-10.;//bars, he says, BARS!\n  float g=bx(pp,vec3(0.8,30,2));//glow amount for bars\n  br=min(br,g);//combine so that we don't get messyness\n  vec3 coco=vec3(1,1,1)-co; //inverted col\n  glw+=exp(-g*1.5)*coco*0.03; //weird outer glowy stuff idk either but hey it looks neat\n  ppp=p;ppp.y=abs(ppp.y)-5.;//get position make position mirror on Y;\n  vec2 flr = vec2(bx(ppp-vec3(0,4,0),vec3(0,1,0)),2); //make floor/roof stuff\n\n  return flr.x<cry.x?flr:cry; //and that's that - i wanted to add more bits on the floor/roof but it was causing issues with lighting :(\n}\n\nvec2 tr(vec3 ro, vec3 rd, float f) //standard raymarching stuff with a distance field multiplier so we can flip things inside out for transparency\n{\n  vec2 d = vec2(0); //d=distance, duh. But it also keeps track of the material ID\n  for(int i = 0; i < 256; i++) //loopy loopy looping loop\n  {\n    vec3 p=ro+rd*d.x; //the position is HERE!\n    vec2 s=mp(p);s.x*=f; //grab the scene SDF\n    d.x+=s.x;d.y=s.y; //move and update material id\n    if(d.x>64.||s.x<0.001)break; //break if we reached something or went too far\n  }\n  if(d.x>64.)d.y=0.;return d; //return distance and ID\n}\n\nvec3 nm(vec3 p)\n{\n  vec2 e = vec2(0.001,0); return normalize(mp(p).x-vec3(mp(p-e.xyy).x,mp(p-e.yxy).x,mp(p-e.yyx).x)); //normals hooray\n}\n\nvec4 px(vec4 h, vec3 rd, vec3 n) //pixel.. shader? it shades pixels, okay? got it? cool.\n{\n  vec4 bg=vec4(0.1,.1,5.1,1); //background colour\n  if(h.a==0.)return bg; //oh no we hit the background how sad\n  vec4 a=h.a==1.?vec4(0.,1.,1.,0.2):vec4(0.1,0.1,0.15,1); //give it some colour, except not because the glow does most of it\n  float d=dot(n,-rd); //ahha this surface is pointy - OR IS IT?!\n  float dd=max(d,0.); //diffuse lighting that makes things actually look like things instead of not looking like things\n  float f=pow(1.-d,4.); //reflecty edges that aren't really reflecty but look reflecty because they're edges\n  float s=(pow(abs(dot(reflect(rd,n),-rd)),40.)*10.); //light bright BUT ONLY WHERE IT NEEDS TO BE\n  if(h.a>1.)s*=0.05;//make id 2 more matt instead of shiny\n  float ao=clamp(1.-mp(h.xyz+n*0.1).x*14.,0.,1.)*0.9; //sorry, we don't want lighting where things are too close to each other :(\n  return vec4(mix(a.rgb*(dd-ao)+s,bg.rgb,f),a.a); //mix it all together - you can replace the whole thing with a vec4(a.rgb*oneofthevalueshere,1.) if you just wanna see what a thing looks like\n}\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n     vec2 p2=(gl_FragCoord.xy/resolution.x)*2.0-vec2(1.0,resolution.y/resolution.x);\n\n  t=iTime; //time is only temporary\n  vec2 uv = vec2(C.x / iResolution.x, C.y / iResolution.y); //u? v? u,v, uv!\n  uv -= 0.5; uv /= vec2(iResolution.y / iResolution.x, 1.); //but now in the middle\n  float ts=1.,io=1.14; //ooh fun variables to track transparency bits\n  vec3 ro=vec3(0,0,-10),rd=normalize(vec3(uv,1.)),oro=ro,ord=rd,cp,cn,rc,cc; //cam pos and ray dir and even more variables for the transparency loop\n  for(int i=0;i<5;i++) //transparency loop! increase the iterations for more transparency depth but less performance if you feel like it. 4 seems like a good middle to me.\n  {\n    vec2 fh=tr(oro,ord,1.); //go find front of object or something\n    cp=oro+ord*fh.x;cn=nm(cp); //figure out the position and normal of the hit\n    vec4 c=px(vec4(cp,fh.y),ord,cn); //grab shaded colour for pixel\n    if(fh.y==0.||c.a==1.) {cc=mix(cc,c.rgb,ts); break;} //oh no it's the background we gotta get out of here!!\n    ro=cp-cn*0.01;rd=refract(ord,cn,1./io); //inject ourselves into the object so we can go THROUGH it!\n    vec2 bh=tr(ro,rd,-1.);//go through inverted distance field to find the exiting face of the object we're currently traversing because yes.\n    cp=ro+rd*bh.x;cn=nm(cp); //figure out position and normal again because we forgot it already duh\n    oro=cp+cn*0.11;ord=refract(rd,-cn,io); //inject ourselves back.. out? outject ourselves? whatever, we back outside again now\n    if(dot(ord,ord)==0.)ord=reflect(rd,-cn); //TOTAL INTERNAL REFRACTION D: (but actually it looks sick so whatever)\n    cc=mix(cc,c.rgb,ts);ts-=c.a; //finally we update the colour\n    if(ts<=0.)break; //if we're still transparent, keep going. If not... time to BREAK OUT OF THIS LOOP!\n  }\n//dude we gotta see things somehow, this does that\n   \n   float x=p2.x;\n   float y=p2.y;\n\n   float a=\n       makePoint(x,y,3.3,2.9,0.3,0.3,time);\n   a=a+makePoint(x,y,1.9,2.0,0.4,0.4,time);\n   a=a+makePoint(x,y,0.8,0.7,0.4,0.5,time);\n   a=a+makePoint(x,y,2.3,0.1,0.6,0.3,time);\n   a=a+makePoint(x,y,0.8,1.7,0.5,0.4,time);\n   a=a+makePoint(x,y,0.3,1.0,0.4,0.4,time);\n   a=a+makePoint(x,y,1.4,1.7,0.4,0.5,time);\n   a=a+makePoint(x,y,1.3,2.1,0.6,0.3,time);\n   a=a+makePoint(x,y,1.8,1.7,0.5,0.4,time);   \n   \n   float b=\n       makePoint(x,y,1.2,1.9,0.3,0.3,time);\n   b=b+makePoint(x,y,0.7,2.7,0.4,0.4,time);\n   b=b+makePoint(x,y,1.4,0.6,0.4,0.5,time);\n   b=b+makePoint(x,y,2.6,0.4,0.6,0.3,time);\n   b=b+makePoint(x,y,0.7,1.4,0.5,0.4,time);\n   b=b+makePoint(x,y,0.7,1.7,0.4,0.4,time);\n   b=b+makePoint(x,y,0.8,0.5,0.4,0.5,time);\n   b=b+makePoint(x,y,1.4,0.9,0.6,0.3,time);\n   b=b+makePoint(x,y,0.7,1.3,0.5,0.4,time);\n\n   float c=\n       makePoint(x,y,3.7,0.3,0.3,0.3,time);\n   c=c+makePoint(x,y,1.9,1.3,0.4,0.4,time);\n   c=c+makePoint(x,y,0.8,0.9,0.4,0.5,time);\n   c=c+makePoint(x,y,1.2,1.7,0.6,0.3,time);\n   c=c+makePoint(x,y,0.3,0.6,0.5,0.4,time);\n   \t\n   float u=dot(vec2(b,c),p2)*100.;\n\t\n   vec3 d=vec3(a,b,c)/10.0*vec3(u,u*.11,u*.1);\n   \n    vec3 p,q,r=iResolution,\n    d2=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(10),H(g*.1),.8)*1./e/8e3\n    )\n    {\n        p=g*d2;\np.z+=iTime*5.;\n        a=30.;\n        p.xy*=mat2(cos(iTime*0.1),sin(iTime*0.1), -sin(iTime*0.1),cos(iTime*0.1));\n         p.xy*=mat2(cos(iTime*0.1),sin(iTime*0.1), -sin(iTime*0.1),cos(iTime*0.1));\n        p=mod(p-a,a*2.)-a;\n        s=5.;\n        for(int i=0;i++<8;){\n        \n            p=.3-abs(p);\n            \n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            s*=e=1.7+sin(iTime*0.7)*.1;\n            p=abs(p)*e-\n                vec3(\n                    12.*3.,\n                    120,\n                    8.*5.\n                 )+cc;\n         }\n         g+=e=length(p.yxz)/s;\n    }\n     O+=vec4(cc+glw*vec3(0.1,1.,3.),1.); \n     uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    O *= vec4(happy_star(uv, anim) * vec3(0.35,0.2,2.15)*1.5, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}