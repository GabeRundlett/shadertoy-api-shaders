{
    "Shader": {
        "info": {
            "date": "1497273855",
            "description": "Expensive way to make noise loop. Twice as expensive than what your noise function would regularly be.",
            "flags": 32,
            "hasliked": 0,
            "id": "XssBzX",
            "likes": 20,
            "name": "looping noise lerp trick",
            "published": 3,
            "tags": [
                "noise"
            ],
            "usePreview": 0,
            "username": "macbooktall",
            "viewed": 2317
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 tex = texture(iChannel0, uv);\n    fragColor =tex;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAXDIST 150.\n#define GIFLENGTH 3.\n#define TRANSSTART 2.5\n\nstruct Ray {\n\tvec3 ro;\n    vec3 rd;\n};\n    \n// Noise and hash function by iq\n    \nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nfloat fbm(vec2 pos) {\n\tfloat n = 0.;\n\tfloat scale = 1. / 1.5;\n\tfor (int i = 0; i < 4; i += 1) {\n\t\tn += noise(pos) * scale;\n\t\tscale *= 0.5;\n\t\tpos *= 2.;\n\t}\n\treturn n;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nvec2 map(vec3 pos) {\n\n    vec3 p = pos;\n    \n    float time = mod(iTime, GIFLENGTH);\n    \n    // Interpolate between two noise functions.\n    // The second function evolves such that it approaches the starting value of the first function.\n    float v1 = (fbm(p.xy + time)-0.5)*.5;\n    float v2 = (fbm(p.xy + time - GIFLENGTH)-0.5)*.5;\n    \n    pos += mix(v1, v2, clamp((time-TRANSSTART)/(GIFLENGTH-TRANSSTART), 0., 1.));\n    \n    float dist = sdSphere(pos, .75);\n   \n    return vec2(dist, 0.);\n}\n\nvec2 march(Ray ray) \n{\n    const int steps = 30;\n    const float prec = 0.001;\n    vec2 res = vec2(0.);\n    \n    for (int i = 0; i < steps; i++) \n    {        \n        vec2 s = map(ray.ro + ray.rd * res.x);\n        \n        if (res.x > MAXDIST || s.x < prec) \n        {\n        \tbreak;    \n        }\n        \n        res.x += s.x;\n        res.y = s.y;   \n    }\n   \n    return res;\n}\n\nvec3 calcNormal(vec3 pos) \n{\n\tconst vec3 eps = vec3(0.01, 0.0, 0.0);\n                          \n    return normalize(\n        vec3(map(pos + eps).x - map(pos - eps).x,\n             map(pos + eps.yxz).x - map(pos - eps.yxz).x,\n             map(pos + eps.yzx).x - map(pos - eps.yzx).x ) \n    );\n}\n\nvec3 render(Ray ray) \n{\n    vec3 col = vec3(0.);\n\tvec2 res = march(ray);\n    \n    if (res.x > MAXDIST) \n    {\n        return col;\n   \t}\n    \n    vec3 normal = calcNormal(ray.ro + ray.rd * res.x);\n    \n    // Color the sphere based on the viewing angle\n  \tcol = vec3(1.+dot(ray.rd,normal));\n    \n    col = mix(col, vec3(0.), clamp(res.x/2., 0., 1.));\n   \treturn col;\n}\n\nmat3 camera(in vec3 ro, in vec3 rd, float rot) \n{\n\tvec3 forward = normalize(rd - ro);\n    vec3 worldUp = vec3(sin(rot), cos(rot), 0.0);\n    vec3 x = normalize(cross(forward, worldUp));\n    vec3 y = normalize(cross(x, forward));\n    return mat3(x, y, forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 camPos = vec3(0., 0., -2.);\n    vec3 camDir = vec3(0., 0., 1.);\n    mat3 cam = camera(camPos, camDir, 0.);\n    vec3 rayDir = cam * normalize( vec3(uv, 1.) );\n    \n    Ray ray;\n    ray.ro = camPos;\n    ray.rd = rayDir;\n    \n    vec3 col = render(ray);\n    \n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This buffer is the feedback loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.495;\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    \n    // sample the last texture with uv's slightly scaled up\n    vec3 overlay = texture(iChannel1, offs).rgb;\n    // Additively blend the colors together\n    vec4 col = vec4(base + overlay*0.8, 1.0);\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}