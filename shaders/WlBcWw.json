{
    "Shader": {
        "info": {
            "date": "1594462191",
            "description": "Fixed the DX9 issue, if you're running on '--use-angle=gl' then comment out '#define DX9_FIX' in common tab. In both modes all the basic logic circuits work (AND, XOR, RS Latch, NOT, etc...).",
            "flags": 48,
            "hasliked": 0,
            "id": "WlBcWw",
            "likes": 11,
            "name": "Shader Redstone 3",
            "published": 3,
            "tags": [
                "game",
                "simulation",
                "sdf",
                "blur",
                "aliasing",
                "shadow",
                "antialiasing",
                "antialiasing",
                "minecraft",
                "alias",
                "anti",
                "circuit",
                "logic",
                "redstone"
            ],
            "usePreview": 1,
            "username": "saidwho12",
            "viewed": 1241
        },
        "renderpass": [
            {
                "code": "/*\n\tShader Redstone 3 (c) by saidwho12\n\n    Shader Redstone 3 is licensed under a\n    Creative Commons Attribution 3.0 Unported License.\n\n    You should have received a copy of the license along with this\n    work.  If not, see <http://creativecommons.org/licenses/by/3.0/>.\n*/\n\nDEFINE_DEFAULT_API(iChannel0, 0)\n    \n    \nbool isKeyPressed (in int key) {\n    return bool(texelFetch(iChannel2, ivec2(key, 0), 0).x);\n}\n\nbool isKeyReleased (in int key) {\n    return bool(texelFetch(iChannel2, ivec2(key, 1), 0).x);\n}\n\nbool isKeyEnabled (in int key) {\n    return bool(texelFetch(iChannel2, ivec2(key, 1), 0).x);\n}\n\n#define _ADDRESS A_ D_ D_ R_ E_ S_ S_\n#define _COORDINATES C_ O_ O_ R_ D_ I_ N_ A_ T_ E_ S_\n#define _TYPE T_ Y_ P_ E_\n#define _ENERGIZED E_ N_ E_ R_ G_ I_ Z_ E_ D_\n#define _ENERGY E_ N_ E_ R_ G_ Y_\n#define _Void V_ o_ i_ d_\n#define BROWNRED cur.rgb = vec3(.63,.5,.25);\n#define PURPLE cur.rgb = vec3(.725, .12, .4);\n#define BERRY cur.rgb = vec3(.9, .12, .5);\n#define DARKGREEN cur.rgb = vec3(.04, .34, .03);\n#define DARKGREY cur.rgb = vec3(.3);\n#define DARKBLUE cur.rgb = vec3(0,0,.86);\n\n// line function, used in k, v, w, x, y, z, 1, 2, 4, 7 and ,\n// rest is drawn using (stretched) circle(g)\n\n// todo: distance fields of s,S, J { and }\n// todo before we can show shaders :)\n// \n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n//These functions are re-used by multiple letters\nfloat _u(vec2 uv, float w, float v) {\n    return length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,-(.4-v)-uv.y) ))-w)\n               ,max(0.,uv.y-.4)));\n}\nfloat _i(vec2 uv) {\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.4)));\n}\nfloat _j(vec2 uv) {\n    uv.x+=.2;\n    uv.y+=.55;\n    float x = uv.x>0.&&uv.y<0.?\n                abs(length(uv)-.25)\n               :min(length(uv+vec2(0.,.25)),\n                    length(vec2(uv.x-.25,max(0.,abs(uv.y-.475)-.475))));\n    return x;\n}\nfloat _l(vec2 uv) {\n    uv.y -= .2;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.6)));\n}\nfloat _o(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.15)))-.25);\n}\n\n// Here is the alphabet\nfloat aa(vec2 uv) {\n    uv = -uv;\n    float x = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.2)-.2))));\n    return min(x,(uv.x<0.?uv.y<0.:atan(uv.x,uv.y+0.15)>2.)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254)));\n}\nfloat bb(vec2 uv) {\n    float x = _o(uv);\n    uv.x += .25;\n    return min(x,_l(uv));\n}\nfloat cc(vec2 uv) {\n    float x = _o(uv);\n    uv.y= abs(uv.y);\n    return uv.x<0.||atan(uv.x,uv.y-0.15)<1.14?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.15))),//makes df right \n                        length(uv+vec2(-.22734,-.254)));\n}\nfloat dd(vec2 uv) {\n    uv.x *= -1.;\n    return bb(uv);\n}\nfloat ee(vec2 uv) {\n    float x = _o(uv);\n    return min(uv.x<0.||uv.y>.05||atan(uv.x,uv.y+0.15)>2.?x:length(vec2(uv.x-.22734,uv.y+.254)),\n               length(vec2(max(0.,abs(uv.x)-.25),uv.y-.05)));\n}\nfloat ff(vec2 uv) {\n    uv.x *= -1.;\n    uv.x += .05;\n    float x = _j(vec2(uv.x,-uv.y));\n    uv.y -= .4;\n    x = min(x,length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y)));\n    return x;\n}\nfloat gg(vec2 uv) {\n    float x = _o(uv);\n    return min(x,uv.x>0.||atan(uv.x,uv.y+.6)<-2.?\n               _u(uv,0.25,-0.2):\n               length(uv+vec2(.23,.7)));\n}\nfloat hh(vec2 uv) {\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x += .25;\n    uv.y *= -1.;\n    return min(x,_l(uv));\n}\nfloat ii(vec2 uv) {\n    return min(_i(uv),length(vec2(uv.x,uv.y-.6)));\n}\nfloat jj(vec2 uv) {\n    uv.x+=.05;\n    return min(_j(uv),length(vec2(uv.x-.05,uv.y-.6)));\n}\nfloat kk(vec2 uv) {\n    float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.4));\n    x = min(x,line(uv,vec2(-.15,.0), vec2(0.25,-0.4)));\n    uv.x+=.25;\n    return min(x,_l(uv));\n}\nfloat ll(vec2 uv) {\n    return _l(uv);\n}\nfloat mm(vec2 uv) {\n    //uv.x *= 1.4;\n    uv.y *= -1.;\n    uv.x-=.175;\n    float x = _u(uv,.175,.175);\n    uv.x+=.35;\n    x = min(x,_u(uv,.175,.175));\n    uv.x+=.175;\n    return min(x,_i(uv));\n}\nfloat nn(vec2 uv) {\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x+=.25;\n    return min(x,_i(uv));\n}\nfloat oo(vec2 uv) {\n    return _o(uv);\n}\nfloat pp(vec2 uv) {\n    float x = _o(uv);\n    uv.x += .25;\n    uv.y += .4;\n    return min(x,_l(uv));\n}\nfloat qq(vec2 uv) {\n    uv.x = -uv.x;\n    return pp(uv);\n}\nfloat rr(vec2 uv) {\n    uv.x -= .05;\n    float x =atan(uv.x,uv.y-0.15)<1.14&&uv.y>0.?_o(uv):length(vec2(uv.x-.22734,uv.y-.254));\n    \n    //)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254))+.4);\n    \n    uv.x+=.25;\n    return min(x,_i(uv));\n}\nfloat ss(vec2 uv) {\n    if (uv.y <.225-uv.x*.5 && uv.x>0. || uv.y<-.225-uv.x*.5)\n        uv = -uv;\n    float a = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n    float b = length(vec2(uv.x-.231505,uv.y-.284));\n    float x = atan(uv.x-.05,uv.y-0.2)<1.14?a:b;\n    return x;\n}\nfloat tt(vec2 uv) {\n    uv.x *= -1.;\n    uv.y -= .4;\n    uv.x += .05;\n    float x = min(_j(uv),length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y)));\n    return x;\n}\nfloat uu(vec2 uv) {\n    return _u(uv,.25,.25);\n}\nfloat vv(vec2 uv) {\n    uv.x=abs(uv.x);\n    return line(uv,vec2(0.25,0.4), vec2(0.,-0.4));\n}\nfloat ww(vec2 uv) {\n    uv.x=abs(uv.x);\n    return min(line(uv,vec2(0.3,0.4), vec2(.2,-0.4)),\n               line(uv,vec2(0.2,-0.4), vec2(0.,0.1)));\n}\nfloat xx(vec2 uv) {\n    uv=abs(uv);\n    return line(uv,vec2(0.,0.), vec2(.3,0.4));\n}\nfloat yy(vec2 uv) {\n    return min(line(uv,vec2(.0,-.2), vec2(-.3,0.4)),\n               line(uv,vec2(.3,.4), vec2(-.3,-0.8)));\n}\nfloat zz(vec2 uv) {\n    float l = line(uv,vec2(0.25,0.4), vec2(-0.25,-0.4));\n    uv.y=abs(uv.y);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.4));\n    return min(x,l);\n}\n\n// Capitals\nfloat AA(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,uv.y-.35) ))-0.25)\n               ,min(0.,uv.y+.4)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1) ));\n}\n\nfloat BB(vec2 uv) {\n    uv.y -=.1;\n    uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.25))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) ));\n}\nfloat CC(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y -= .1;\n    uv.y= abs(uv.y);\n    return uv.x<0.||atan(uv.x,uv.y-0.25)<1.14?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))),//makes df right \n                        length(uv+vec2(-.22734,-.354)));\n}\nfloat DD(vec2 uv) {\n    uv.y -=.1;\n    //uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                max(0.0,abs(uv.y)-.25)))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) ));\n}\nfloat EE(vec2 uv) {\n    uv.y -=.1;\n    uv.y = abs(uv.y);\n    float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat FF(vec2 uv) {\n    uv.y -=.1;\n    float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat GG(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y -= .1;\n    float a = atan(uv.x,max(0.,abs(uv.y)-0.25));\n    x = uv.x<0.||a<1.14 || a>3.?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))),//makes df right \n                        length(uv+vec2(-.22734,-.354)));\n    x = min(x,line(uv,vec2(.22734,-.1),vec2(.22734,-.354)));\n    return min(x,line(uv,vec2(.22734,-.1),vec2(.05,-.1)));\n}\nfloat HH(vec2 uv) {\n    uv.y -=.1;\n    uv.x = abs(uv.x);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y));\n    return min(x,length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))));\n}\nfloat II(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    uv.y = abs(uv.y);\n    return min(x,length(vec2(max(0.,abs(uv.x)-.1),uv.y-.5)));\n}\nfloat JJ(vec2 uv) {\n    uv.x += .125;\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                min(0.0,uv.y+.15) ))-0.25)\n               ,max(0.,max(-uv.x,uv.y-.6))));\n    return min(x,length(vec2(max(0.,abs(uv.x-.125)-.125),uv.y-.6)));\n}\nfloat KK(vec2 uv) {\n    float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.6));\n    x = min(x,line(uv,vec2(-.1, .1), vec2(0.25,-0.4)));\n//    uv.x+=.25;\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5))));\n}\nfloat LL(vec2 uv) {\n    uv.y -=.1;\n    float x = length(vec2(max(0.,abs(uv.x)-.2),uv.y+.5));\n    return min(x,length(vec2(uv.x+.2,max(0.,abs(uv.y)-.5))));\n}\nfloat MM(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.35,max(0.,abs(uv.y)-.5))),\n                  line(uv,vec2(-.35,.5),vec2(.0,-.1)));\n    x = min(x,line(uv,vec2(.0,-.1),vec2(.35,.5)));\n    return min(x,length(vec2(uv.x+.35,max(0.,abs(uv.y)-.5))));\n}\nfloat NN(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))),\n                  line(uv,vec2(-.25,.5),vec2(.25,-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat OO(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n}\nfloat PP(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.35))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n}\nfloat QQ(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y += .3;\n    uv.x -= .2;\n    return min(x,length(vec2(abs(uv.x+uv.y),max(0.,abs(uv.x-uv.y)-.2)))/sqrt(2.));\n}\nfloat RR(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.35))-0.25)\n               ,min(0.,uv.x+.25)));\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n    return min(x,line(uv,vec2(0.0,0.1),vec2(0.25,-0.4)));\n}\nfloat SS(vec2 uv) {\n    uv.y -= .1;\n    if (uv.y <.275-uv.x*.5 && uv.x>0. || uv.y<-.275-uv.x*.5)\n        uv = -uv;\n    float a = abs(length(vec2(max(0.,abs(uv.x)),uv.y-.25))-.25);\n    float b = length(vec2(uv.x-.236,uv.y-.332));\n    float x = atan(uv.x-.05,uv.y-0.25)<1.14?a:b;\n    return x;\n}\nfloat TT(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n}\nfloat UU(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                min(0.0,uv.y+.15) ))-0.25)\n               ,max(0.,uv.y-.6)));\n    return x;\n}\nfloat VV(vec2 uv) {\n    uv.x=abs(uv.x);\n    return line(uv,vec2(0.25,0.6), vec2(0.,-0.4));\n}\nfloat WW(vec2 uv) {\n    uv.x=abs(uv.x);\n    return min(line(uv,vec2(0.3,0.6), vec2(.2,-0.4)),\n               line(uv,vec2(0.2,-0.4), vec2(0.,0.2)));\n}\nfloat XX(vec2 uv) {\n    uv.y -= .1;\n    uv=abs(uv);\n    return line(uv,vec2(0.,0.), vec2(.3,0.5));\n}\nfloat YY(vec2 uv) {\n    return min(min(line(uv,vec2(.0, .1), vec2(-.3, 0.6)),\n                   line(uv,vec2(.0, .1), vec2( .3, 0.6))),\n                   length(vec2(uv.x,max(0.,abs(uv.y+.15)-.25))));\n}\nfloat ZZ(vec2 uv) {\n    float l = line(uv,vec2(0.25,0.6), vec2(-0.25,-0.4));\n    uv.y-=.1;\n    uv.y=abs(uv.y);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5));\n    return min(x,l);\n}\n\n//Numbers\nfloat _11(vec2 uv) {\n    return min(min(\n             line(uv,vec2(-0.2,0.45),vec2(0.,0.6)),\n             length(vec2(uv.x,max(0.,abs(uv.y-.1)-.5)))),\n             length(vec2(max(0.,abs(uv.x)-.2),uv.y+.4)));\n             \n}\nfloat _22(vec2 uv) {\n    float x = min(line(uv,vec2(0.185,0.17),vec2(-.25,-.4)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4)));\n    uv.y-=.35;\n    uv.x += 0.025;\n    return min(x,abs(atan(uv.x,uv.y)-0.63)<1.64?abs(length(uv)-.275):\n               length(uv+vec2(.23,-.15)));\n}\nfloat _33(vec2 uv) {\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return atan(uv.x,uv.y)>-1.?abs(length(uv)-.25):\n           min(length(uv+vec2(.211,-.134)),length(uv+vec2(.0,.25)));\n}\nfloat _44(vec2 uv) {\n    float x = min(length(vec2(uv.x-.15,max(0.,abs(uv.y-.1)-.5))),\n                  line(uv,vec2(0.15,0.6),vec2(-.25,-.1)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y+.1)));\n}\nfloat _55(vec2 uv) {\n    float b = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n                  length(vec2(uv.x+.25,max(0.,abs(uv.y-.36)-.236))));\n    uv.y += 0.1;\n    uv.x += 0.05;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.0)))-.3);\n    return min(b,abs(atan(uv.x,uv.y)+1.57)<.86 && uv.x<0.?\n               length(uv+vec2(.2,.224))\n               :c);\n}\nfloat _66(vec2 uv) {\n    uv.y-=.075;\n    uv = -uv;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _77(vec2 uv) {\n    return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n               line(uv,vec2(-0.25,-0.39),vec2(0.25,0.6)));\n}\nfloat _88(vec2 uv) {\n    float l = length(vec2(max(0.,abs(uv.x)-.08),uv.y-.1+uv.x*.07));\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.245;\n    return min(abs(length(uv)-.255),l);\n}\nfloat _99(vec2 uv) {\n    uv.y-=.125;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _00(vec2 uv) {\n    uv.y-=.1;\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.25)))-.25);\n}\n\n//Symbols\nfloat ddot(vec2 uv) {\n    uv.y+=.4;\n    return length(uv)*0.97;//-.03;\n}\nfloat comma(vec2 uv) {\n    return min(ddot(uv),line(uv,vec2(.031,-.405),vec2(-.029,-.52)));\n}\nfloat exclam(vec2 uv) {\n    return min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y-.2)-.4)))-uv.y*.06);\n}\nfloat question(vec2 uv) {\n    float x = min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y+.035)-.1125))));\n    uv.y-=.35;\n    uv.x += 0.025;\n    return min(x,abs(atan(uv.x,uv.y)-1.05)<2.?abs(length(uv)-.275):\n               length(uv+vec2(.225,-.16))-.0);\n}\nfloat open1(vec2 uv) {\n    uv.x-=.62;\n    return abs(atan(uv.x,uv.y)+1.57)<1.?\n            abs(length(uv)-.8)\n           :length(vec2(uv.x+.435,abs(uv.y)-.672));\n}\nfloat close1(vec2 uv) {\n    uv.x = -uv.x;\n    return open1(uv);\n}\nfloat dotdot(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return length(uv);\n}\nfloat dotcomma(vec2 uv) {\n    uv.y -= .1;\n    float x = line(uv,vec2(.0,-.28),vec2(-.029,-.32));\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return min(length(uv),x);\n}\nfloat eequal(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.15));\n}\nfloat aadd(vec2 uv) {\n    uv.y -= .1;\n    return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n               length(vec2(uv.x,max(0.,abs(uv.y)-.25))));\n}\nfloat ssub(vec2 uv) {\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1));\n}\nfloat mmul(vec2 uv) {\n    uv.y -= .1;\n    uv = abs(uv);\n    return min(line(uv,vec2(0.866*.25,0.5*.25),vec2(0.))\n              ,length(vec2(uv.x,max(0.,abs(uv.y)-.25))));\n}\nfloat ddiv(vec2 uv) {\n    return line(uv,vec2(-0.25,-0.4),vec2(0.25,0.6));\n}\nfloat lt(vec2 uv) {\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    return line(uv,vec2(0.25,0.25),vec2(-0.25,0.));\n}\nfloat gt(vec2 uv) {\n    uv.x=-uv.x;\n    return lt(uv);\n}\nfloat hash(vec2 uv) {\n    uv.y-=.1;\n    uv.x -= uv.y*.1;\n    uv = abs(uv);\n    return min(length(vec2(uv.x-.125,max(0.,abs(uv.y)-.3))),\n               length(vec2(max(0.,abs(uv.x)-.25),uv.y-.125)));\n}\nfloat and(vec2 uv) {\n    uv.y-=.44;\n    uv.x+=.05;\n    float x = abs(atan(uv.x,uv.y))<2.356?abs(length(uv)-.15):1.0;\n    x = min(x,line(uv,vec2(-0.106,-0.106),vec2(0.4,-0.712)));\n    x = min(x,line(uv,vec2( 0.106,-0.106),vec2(-0.116,-0.397)));\n    uv.x-=.025;\n    uv.y+=.54;\n    x = min(x,abs(atan(uv.x,uv.y)-.785)>1.57?abs(length(uv)-.2):1.0);\n    return min(x,line(uv,vec2( 0.141,-0.141),vec2( 0.377,0.177)));\n}\nfloat or(vec2 uv) {\n    uv.y -= .1;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n}\nfloat und(vec2 uv) {\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4));\n}\nfloat open2(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    return min(length(vec2(uv.x+.125,max(0.,abs(uv.y)-.5))),\n               length(vec2(max(0.,abs(uv.x)-.125),uv.y-.5)));\n}\nfloat close2(vec2 uv) {\n    uv.x=-uv.x;\n    return open2(uv);\n}\nfloat open3(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2((uv.x*sign(uv.y-.25)-.2),\n                            max(0.0,abs(uv.y-.25)-.05) ))-0.2)\n               ,max(0.,abs(uv.x)-.2)));\n    return  x;\n    \n}\nfloat close3(vec2 uv) {\n    uv.x=-uv.x;\n    return open3(uv);\n}\n\nvec2 clc(vec2 uv, float cp, float w, float ital) {\n    return uv-vec2(cp-(w*.5)+uv.y*ital,0.);\n}\nbool hit(vec2 uv,inout float cp,float w, float px) {\n    return abs((cp+=w)-uv.x)<w+.2;\n}\n\n//Render char if it's up\n#define ch(l,w) if (hit(uv,cp,w,px)) { x=min(x,l(clc(uv,cp,w,ital))); us=cur;}\n\n//Render char always (no effects anymore)\n//#define ch(l,w) x = min(x,l(clc(uv,cp+=w,w,ital)));\n\n//Make it a bit easier to type text\n#define a_ ch(aa,0.7);\n#define b_ ch(bb,0.7);\n#define c_ ch(cc,0.7);\n#define d_ ch(dd,0.7);\n#define e_ ch(ee,0.7);\n#define f_ ch(ff,0.6);\n#define g_ ch(gg,0.7);\n#define h_ ch(hh,0.7);\n#define i_ ch(ii,0.3);\n#define j_ ch(jj,0.3);\n#define k_ ch(kk,0.7);\n#define l_ ch(ll,0.3);\n#define m_ ch(mm,0.9);\n#define n_ ch(nn,0.7);\n#define o_ ch(oo,0.7);\n#define p_ ch(pp,0.7);\n#define q_ ch(qq,0.7);\n#define r_ ch(rr,0.7);\n#define s_ ch(ss,0.7);\n#define t_ ch(tt,0.7);\n#define u_ ch(uu,0.7);\n#define v_ ch(vv,0.7);\n#define w_ ch(ww,0.9);\n#define x_ ch(xx,0.8);\n#define y_ ch(yy,0.8);\n#define z_ ch(zz,0.7);\n#define A_ ch(AA,0.7);\n#define B_ ch(BB,0.7);\n#define C_ ch(CC,0.7);\n#define D_ ch(DD,0.7);\n#define E_ ch(EE,0.7);\n#define F_ ch(FF,0.7);\n#define G_ ch(GG,0.7);\n#define H_ ch(HH,0.7);\n#define I_ ch(II,0.5);\n#define J_ ch(JJ,0.5);\n#define K_ ch(KK,0.7);\n#define L_ ch(LL,0.5);\n#define M_ ch(MM,0.9);\n#define N_ ch(NN,0.7);\n#define O_ ch(OO,0.7);\n#define P_ ch(PP,0.7);\n#define Q_ ch(QQ,0.7);\n#define R_ ch(RR,0.7);\n#define S_ ch(SS,0.7);\n#define T_ ch(TT,0.7);\n#define U_ ch(UU,0.7);\n#define V_ ch(VV,0.7);\n#define W_ ch(WW,0.9);\n#define X_ ch(XX,0.8);\n#define Y_ ch(YY,0.8);\n#define Z_ ch(ZZ,0.7);\n#define _1 ch(_11,0.7);\n#define _2 ch(_22,0.7);\n#define _3 ch(_33,0.7);\n#define _4 ch(_44,0.7);\n#define _5 ch(_55,0.7);\n#define _6 ch(_66,0.7);\n#define _7 ch(_77,0.7);\n#define _8 ch(_88,0.7);\n#define _9 ch(_99,0.7);\n#define _0 ch(_00,0.7);\n#define _dot ch(ddot,0.3);\n#define _comma ch(comma,0.3);\n#define _exclam ch(exclam,0.3);\n#define _question ch(question,0.8);\n#define _open1 ch(open1,0.7);\n#define _close1 ch(close1,0.7);\n#define _dotdot ch(dotdot,0.3);\n#define _dotcomma ch(dotcomma,0.3);\n#define _equal ch(eequal,0.7);\n#define _add ch(aadd,0.7);\n#define _sub ch(ssub,0.7);\n#define _mul ch(mmul,0.7);\n#define _div ch(ddiv,0.7);\n#define _lt ch(lt,0.7);\n#define _gt ch(gt,0.7);\n#define _hash ch(hash,0.7);\n#define _and ch(and,0.9);\n#define _or ch(or,0.3);\n#define _und ch(und,0.7);\n#define _open2 ch(open2,0.6);\n#define _close2 ch(close2,0.6);\n#define _open3 ch(open3,0.7);\n#define _close3 ch(close3,0.7);\n    \n//Space\n#define _ cp+=.5;\n\n//Markup\n#define BOLD cur.w = 1.5;\n#define NOBOLD cur.w = 0.0;\n#define ITAL ital = 0.15;\n#define NOITAL ital = 0.0;\n#define BLACK cur.rgb = vec3(0);\n#define WHITE cur.rgb = vec3(1);\n#define RED cur.rgb = vec3(1,0,0);\n#define GREEN cur.rgb = vec3(0,1,0);\n#define BLUE cur.rgb = vec3(0,0,1);\n#define ENERGIZED cur.rgb = getEnergyColor(MAX_REDSTONE_POWER);\n#define UNENERGIZED cur.rgb = getEnergyColor(0u);\n\n#define true_ t_ r_ u_ e_\n#define false_ f_ a_ l_ s_ e_\n\n//Next line\n#define crlf uv.y += 2.0; cp = 0.;\n\n\n#define HEX(X)\\\n{\\\n_0 x_;\\\n    for (uint I = 0u; I < 8u; ++I)\\\n    {\\\n        uint _X = (X >> ((7u - I) * 4u)) & 0xFu;\\\n        switch (_X)\\\n        {\\\n            case 0u: _0; break;\\\n            case 1u: _1; break;\\\n            case 2u: _2; break;\\\n            case 3u: _3; break;\\\n            case 4u: _4; break;\\\n            case 5u: _5; break;\\\n            case 6u: _6; break;\\\n            case 7u: _7; break;\\\n            case 8u: _8; break;\\\n            case 9u: _9; break;\\\n            case 10u: A_; break;\\\n            case 11u: B_; break;\\\n            case 12u: C_; break;\\\n            case 13u: D_; break;\\\n            case 14u: E_; break;\\\n            case 15u: F_; break;\\\n        }\\\n    }\\\n}\n\n#define DECIMAL(X)\\\n{\\\n    for (int I = 0; I < 4; ++I)\\\n    {\\\n    \tfloat Y = float(X) / (10. * exp(float(4 - I)));\\\n        switch (int(floor(Y)))\\\n        {\\\n            case 0: _0 break;\\\n            case 1: _1 break;\\\n            case 2: _2 break;\\\n            case 3: _3 break;\\\n            case 4: _4 break;\\\n            case 5: _5 break;\\\n            case 6: _6 break;\\\n            case 7: _7 break;\\\n            case 8: _8 break;\\\n            case 9: _9 break;\\\n        }\\\n    }\\\n}\n\nfloat segment(vec2 uv, float e, vec2 a, vec2 b)\n{         \n    b -= a;\n    uv -= a;\n    return smoothstep(0.0, e, \n                      length( uv - b * clamp(dot(b, uv) / dot(b, b), 0.0, 1.0)));\n}\n\nfloat segment_line(vec2 uv, float e, vec2 a, vec2 b) \n{\n    b -= a;\n    uv -= a;\n    vec2 d = normalize(b);\n    \n    float sd1 = smoothstep(e*0.1, 2.0*e, abs(dot(vec2(-d.y, d.x), uv)));\n    float sd2 = smoothstep(e*0.1, e, abs(dot(vec2(-d.y, d.x), uv)));\n    float t = min(step(0.0, dot(d, uv)), step(0.0, dot(d, b - uv)));\n    \n    float fo = clamp(0.0, 1.0, pow(length(uv - b*0.5)/(length(b)*4.0), 4.0));\n    \n \treturn mix(mix(0.8 + 0.2*sd2,1.0, fo) , sd1, t); \n}\n\nfloat point(vec2 uv, float e, vec2 p) \n{\n\treturn 0.4 + 0.6*smoothstep(1.5*e, 3.0*e, length(uv - p)); \n}\n\nfloat cpoint(vec2 uv, float e, vec2 p)\n{\n    const float s = 1.5;\n\treturn 0.4 + 0.6\n        * segment(uv, 1.5*e, p + e*vec2(s), p - e*vec2(s)) *\n          segment(uv, 1.5*e, p + e*vec2(s, -s), p - e*vec2(s, -s));\n}\n\nfloat bezier(vec2 uv, float e, vec2 b0, vec2 b1, vec2 b2)\n{   \n    // Nehab and Hoppe quadratic bezier distance aproximation.\n    // http://hhoppe.com/ravg.pdf\n    b0 -= uv;\n    b1 -= uv;\n    b2 -= uv;\n    \n    float a = determinant(mat2(b0, b2));\n    float b = 2.0 * determinant(mat2(b1, b0));\n    float d = 2.0 * determinant(mat2(b2, b1));\n    \n    float f = b*d - a*a;\n    vec2 d21 = b2 - b1;\n    vec2 d10 = b1 - b0;\n    vec2 d20 = b2 - b0;  \n    \n    vec2 gf = 2.0 * (b*d21 + d*d10 + a*d20);  \n    gf = vec2(gf.y, -gf.x);\n    \n    vec2 pp = -f*gf / dot(gf, gf);\n    vec2 d0p = b0 - pp;  \n    float ap = determinant(mat2(d0p, d20));\n    float bp = 2.0 * determinant(mat2(d10, d0p)); \n    float t = clamp((ap + bp) / (2.0*a + b + d), 0.0, 1.0);\n    \n    vec2 dist = vec2(length(mix(mix(b0, b1, t), mix(b1, b2, t), t)), length(pp));\n\n    float fo = clamp(0.0, 1.0, pow(length(b1)/(length(d20)*4.0), 4.0));\n    \n    return min(smoothstep(e*0.1, 2.0*e, dist.x), \n               \t\t\t  mix(0.8 + 0.2*smoothstep(e*0.1, e, dist.y), 1.0, fo));\n}\n\nfloat move_to(inout vec2 p, vec2 to, vec2 uv, float e)\n{\n\tp = to;\n    return point(uv, e, to);\n}\n\nfloat line_to(inout vec2 p, vec2 to, vec2 uv, float e)\n{\n\tfloat d = segment_line(uv, e, p, to) * point(uv, e, to);\n    p = to;\n    return d;\n}\n\nfloat conic_to(inout vec2 p, vec2 c, vec2 to, vec2 uv, float e)\n{\n\tfloat d = bezier(uv, e, p, c, to) * cpoint(uv, e, c) * point(uv, e, to);\n    p = to;\n    return d;\n}\n\nfloat glyph(vec2 uv, float e) \n{\n    vec2 p = vec2(0.0);\n\n    float r = 1.0;\n    r = min(r, move_to(p, vec2(57, -162), uv, e) );\n    r = min(r, conic_to(p, vec2(57, -96), vec2(107, -39), uv, e) );\n    r = min(r, conic_to(p, vec2(158, 18), vec2(246, 43), uv, e) );\n    r = min(r, conic_to(p, vec2(156, 100), vec2(156, 225), uv, e) );\n    r = min(r, conic_to(p, vec2(156, 321), vec2(219, 395), uv, e) );\n    r = min(r, conic_to(p, vec2(123, 475), vec2(123, 606), uv, e) );\n    r = min(r, conic_to(p, vec2(123, 727), vec2(219, 816), uv, e) );\n    r = min(r, conic_to(p, vec2(315, 905), vec2(455, 905), uv, e) );\n    r = min(r, conic_to(p, vec2(578, 905), vec2(672, 831), uv, e) );\n    r = min(r, conic_to(p, vec2(770, 927), vec2(889, 928), uv, e) );\n    r = min(r, conic_to(p, vec2(942, 928), vec2(967, 895), uv, e) );\n    r = min(r, conic_to(p, vec2(993, 862), vec2(993, 827), uv, e) );\n    r = min(r, conic_to(p, vec2(993, 796), vec2(973, 781), uv, e) );\n    r = min(r, conic_to(p, vec2(954, 766), vec2(934, 766), uv, e) );\n    r = min(r, conic_to(p, vec2(909, 766), vec2(891, 782), uv, e) );\n    r = min(r, conic_to(p, vec2(874, 799), vec2(874, 825), uv, e) );\n    r = min(r, conic_to(p, vec2(874, 868), vec2(907, 881), uv, e) );\n    r = min(r, conic_to(p, vec2(901, 883), vec2(887, 883), uv, e) );\n    r = min(r, conic_to(p, vec2(787, 883), vec2(702, 803), uv, e) );\n    r = min(r, conic_to(p, vec2(786, 725), vec2(786, 604), uv, e) );\n    r = min(r, conic_to(p, vec2(786, 483), vec2(690, 394), uv, e) );\n    r = min(r, conic_to(p, vec2(594, 305), vec2(455, 305), uv, e) );\n    r = min(r, conic_to(p, vec2(340, 305), vec2(252, 369), uv, e) );\n    r = min(r, conic_to(p, vec2(217, 328), vec2(217, 272), uv, e) );\n    r = min(r, conic_to(p, vec2(217, 221), vec2(248, 181), uv, e) );\n    r = min(r, conic_to(p, vec2(279, 141), vec2(326, 135), uv, e) );\n    r = min(r, line_to(p, /*vec2(340, 133),*/ vec2(479, 133), uv, e) );\n    r = min(r, line_to(p, /*vec2(561, 133),*/ vec2(606, 131), uv, e) );\n    r = min(r, conic_to(p, vec2(651, 129), vec2(715, 115), uv, e) );\n    r = min(r, conic_to(p, vec2(780, 102), vec2(831, 76), uv, e) );\n    r = min(r, conic_to(p, vec2(964, 2), vec2(965, -158), uv, e) );\n    r = min(r, conic_to(p, vec2(965, -275), vec2(830, -348), uv, e) );\n    r = min(r, conic_to(p, vec2(696, -422), vec2(510, -422), uv, e) );\n    r = min(r, conic_to(p, vec2(322, -422), vec2(189, -347), uv, e) );\n    r = min(r, conic_to(p, vec2(57, -273), vec2(57, -162), uv, e) );\n    r = min(r, move_to(p, vec2(164, -162), uv, e) );\n    r = min(r, conic_to(p, vec2(164, -246), vec2(263, -310), uv, e) );\n    r = min(r, conic_to(p, vec2(362, -375), vec2(512, -375), uv, e) );\n    r = min(r, conic_to(p, vec2(659, -375), vec2(758, -311), uv, e) );\n    r = min(r, conic_to(p, vec2(858, -248), vec2(858, -162), uv, e) );\n    r = min(r, conic_to(p, vec2(858, -101), vec2(823, -62), uv, e) );\n    r = min(r, conic_to(p, vec2(788, -23), vec2(716, -7), uv, e) );\n    r = min(r, conic_to(p, vec2(645, 8), vec2(595, 11), uv, e) );\n    r = min(r, line_to(p, /*vec2(545, 14),*/ vec2(453, 14), uv, e) );\n    r = min(r, line_to(p, vec2(332, 14), uv, e) );\n    r = min(r, conic_to(p, vec2(262, 10), vec2(213, -41), uv, e) );\n    r = min(r, conic_to(p, vec2(164, -92), vec2(164, -162), uv, e) );\n    r = min(r, move_to(p, vec2(276, 604), uv, e) );\n    r = min(r, conic_to(p, vec2(276, 352), vec2(455, 352), uv, e) );\n    r = min(r, conic_to(p, vec2(545, 352), vec2(600, 434), uv, e) );\n    r = min(r, conic_to(p, vec2(633, 489), vec2(633, 606), uv, e) );\n    r = min(r, conic_to(p, vec2(633, 858), vec2(455, 858), uv, e) );\n    r = min(r, conic_to(p, vec2(365, 858), vec2(309, 776), uv, e) );\n    r = min(r, conic_to(p, vec2(276, 721), vec2(276, 604), uv, e) );\n    \n\treturn r;    \n}\n\n\nconst float MENU_SCALE                 = .18;\nconst float MENU_MARGIN_Y              = .06;\nconst float ITEM_SELECTOR_SCALE        = .9;\nconst int ITEM_SELECTOR_PARTICLE_COUNT = 25;\n\nfloat getSelectorWave(void) { return .1+(sin(iTime*6.28)*.5+.5)*.7; }\n\nvec4\npaintMenuVoxel (in vec2 pos, in float invScale, in uint type)\n{\n    return drawVoxelTypeIcon(pos, invScale, type);\n}\n\nvec2\ngetParticlePos (in vec2 initialPos, in vec2 vel,\n                in float initialTime, in float lifeTime,\n                in float time)\n{\n    float t = mod(time - initialTime, lifeTime);\n\treturn initialPos + vel * t;// - waveAmp * sin(t * TAU * waveFreq) * normalize(vec2(-vel.y, vel.x));\n}\n\nfloat\ngetParticleAlpha (in float initialTime, in float lifeTime, in float time, in float falloff)\n{\n\treturn SATURATE(exp(-max(falloff, 0.) * mod(time - initialTime, lifeTime) / lifeTime));\n}\n/*\nvoid\npaintItem (inout vec4 ioColor, in vec2 iCoord, in uint iItemIndex)\n{\n    uint selectedItemIndex = uint(readVar(itemIndexLocation));\n \tbool isActive = selectedItemIndex == iItemIndex;   \n    \n    vec2 itemPos = vec2(float(TOP_PANEL_SIZE) * (float(iItemIndex) + .5) - .5 * float(TOP_PANEL_SIZE) * float(itemTypeList.length()),\n                        1. - .5 * float(TOP_PANEL_SIZE));\n\n    uint itemType = itemTypeList[iItemIndex];\n    \n    float itemBoxScale = float(ITEM_SELECTOR_SCALE) * float(TOP_PANEL_SIZE);\n    if (!isActive) itemBoxScale *= .75;\n  \t\n    //iPos -= itemPos;\n    //iPos /= itemBoxScale * .5;\n    \n    //invScale *= itemBoxScale * .5;\n    \n    //float t = sdBox(iPos, vec2(1.));\n    //float alpha = smoothstep(3., 0., t * invScale);\n    //float outlineAlpha = smoothstep(3., 0., (abs(t) - (isActive ? .015 : .0075)) * invScale);\n  \t\n    //vec4 itemColor = drawVoxelTypeIcon(iPos, invScale, itemType);\n    \n    //ioColor.rgb = mix(ioColor.rgb, itemColor.rgb, itemColor.a * alpha);\n    \n    //ioColor.rgb = mix(ioColor.rgb, getEnergyColor(isActive ? MAX_REDSTONE_POWER : 0u), outlineAlpha);\n\t/*\n    if (isActive)\n    {\n        for (uint i = 0u; i < REDSTONE_PARTICLE_COUNT; ++i)\n        {\n            float seed = float(itemIndex * REDSTONE_PARTICLE_COUNT + i * 4u);\n\n            float angle = hash11(seed++) * TAU;\n            float speed = .2 + hash11(seed++) * 1.5;\n            vec2 dir = vec2(sin(angle), cos(angle));\n            vec2 vel = dir * speed;\n            float lifeTime = .3 + .85  * hash11(seed++);\n            float initialTime = hash11(seed++) * lifeTime;\n\n            float radius = (.025 + hash11(seed++) * .02);\n\n            vec2 initialPos = dir;\n\n            vec2 particlePos = getParticlePos(initialPos, vel, initialTime, lifeTime, iTime);\n            float particleAlpha = getParticleAlpha(initialTime, lifeTime, iTime, 1.7);\n\n            float t = length(pos - particlePos) - radius;\n            float alpha = smoothstep(3., 0., t * invScale) * particleAlpha;\n            color.rgb = mix(color.rgb, getEnergyColor(MAX_REDSTONE_POWER), alpha);\n        }\n    }\n}\n\n*/\n\n// x: distance, y: bar index\nvec2 paintIcon0(in vec2 p)\n{\n    vec2 p0 = rotate(radians(-20.)) * vec2(p.x, abs(p.y));\n    float t0 = length(max(abs(p0.xy)-vec2(0,.95),0.0)) - .12;\n    p0 = rotate(radians(-20.)) * vec2(p.x - .5, abs(p.y));\n    float t1 = length(max(abs(p0.xy)-vec2(0,.95),0.0)) - .12;\n    \n    float t = min(t0, t1);\n    float i = t == t1 ? t == t0 ? 0.0 : 1.0 : -1.0;\n    \n\treturn vec2(t, i);\n}\n\n/*\n\nvoid Paint_Inventory0(inout vec4 ioColor, in vec2 pos)\n{\n    float ratio = float(PANEL0_SIZE) / float(INVENTORY0_CELL_SIZE);\n\tuint N = uint(floor(ratio));\n    \n    vec3 p = vec3(pos,1) / float(INVENTORY0_CELL_SIZE);\n    \n    vec2 pf = fract(p.xy);\n    vec2 pi = floor(p.xy);\n    \n    if (pi.x < float(N))\n    {\n    \tioColor.rg = pf;\n    }\n}\n\nvoid paintSidePanel(inout vec4 fragColor, in vec3 blurredColor, in vec2 coord, in float valOpen, in bool isOpen)\n{\n   \tvalOpen = SATURATE(valOpen);\n    float x_offset = valOpen * float(PANEL0_SIZE);\n    //coord.x -= x_offset;\n    \n    vec2 coord0 = coord - vec2(x_offset, 0);\n    \n    float energy = 0.;\n    float emissive = 0.;\n    \n    vec3 color = vec3(1);//vec3(.85 + .15 * sin(coord.x + coord.y));\n    \n#define TO_COORD_BTN0(v) (v - vec2(float(BUTTON0_SIZE_X)*.5, (iResolution.y - float(TOP_PANEL_SIZE))*.5))\n    \n    float t = min(coord0.x, sdBox(coord0 - vec2(0, (iResolution.y - float(TOP_PANEL_SIZE))*.5 ), vec2(1,.5)*vec2(BUTTON0_SIZE_X, BUTTON0_SIZE_Y)));\n    //t = max(t, coord.y - iResolution.y + float(TOP_PANEL_SIZE));\n    \n    float a = smoothstep(1., -1., t);\n    \n    float ao = (1.-.3*SATURATE(exp(-.5 * t)));\n    \n    float t1 = coord0.x + 8.;\n    float a1 = smoothstep(1.5, -1.5, t1);\n    float ao1 = 1. - .1 * SATURATE(exp(-.7*t1)) * (1.-a1);\n    \n    fragColor.rgb *= ao;\n    // GUI_TRANSLUCENCY * (1. - emissive)\n    //fragColor.rgb = mix(fragColor.rgb, mix(mix(blurredColor, TRANSLUCENT_COLOR, GUI_TRANSLUCENCY * (1. - emissive)) * ao1, color, a1), a);\n    fragColor.rgb = mix(fragColor.rgb, mix(blurredColor, TRANSLUCENT_COLOR, GUI_TRANSLUCENCY * (1. - emissive)), a);\n    //fragColor.rgb = mix(fragColor.rgb, mix(blurredColor * ao, color, GUI_TRANSLUCENCY), a);\n\n\t{\n        vec2 mouseCoord = iMouse.xy - vec2(x_offset, 0);\n        // draw panel button\n        \n        vec2 c = TO_COORD_BTN0(coord0);\n        vec2 mc = TO_COORD_BTN0(mouseCoord);\n        \n#undef TO_LOCAL_POS\n        \n        vec3 p = vec3(c,1.) / (float(BUTTON0_SIZE_X)*.5);\n        vec2 m = mc / (float(BUTTON0_SIZE_X)*.5);\n        \n        if (isOpen)\n        {\n            p.x = -p.x;\n            m.x = -m.x;\n        }\n        \n        vec2 v0 = paintIcon0(p.xy);\n        vec2 v1 = paintIcon0(m);\n        \n        float emissive = smoothstep(1., -1., (v0.x) / p.z);\n        \n        float s = .5 + .5 * sin( PI_2 * (iTime - v0.y*.3) );\n        \n        bool isHot = all(greaterThan(m, vec2(-1))) && all(lessThan(m, vec2(1)));\n        bool isActive = true;//isKeyPressed(keyPrimaryAction);\n        \n        energy = (isHot?isActive?1.:.35:0.) * s;\n        vec3 col = vec3(.45);//getEnergyColor( energy );\n        \n        fragColor.rgb = mix(fragColor.rgb, col, emissive);\n    }\n\t\n    if ( isOpen )\n    {\n        //Paint_Inventory0(fragColor, coord);\n        \n    \t// Draw options\n        float value = fract(.2*iTime);\n       \t\n        const float SLIDER_HEIGHT = 20.;\n        const float SLIDER_HALF_WIDTH = float(PANEL0_SIZE) * .33;\n        const float SLIDER_HALF_HEIGHT = SLIDER_HEIGHT * .5;\n        \n        float R0 = SLIDER_HALF_HEIGHT * .8;\n        float R1 = R0 * .2;\n        float R2 = R0 * .25;\n        \n        vec2 sliderCoord = (coord - vec2(0, iResolution.y - float(TOP_PANEL_SIZE)) ) - vec2(PANEL0_SIZE, -SLIDER_HEIGHT-4.)*.5;\n        \n        float t0 = length(max(abs(sliderCoord)-vec2(SLIDER_HALF_WIDTH,0),0.)) - R1;//length(vec2(abs(sliderCoord.x)-SLIDER_HALF_WIDTH, sliderCoord.y))-R1*.25;\n        float a0 = smoothstep(1.5, -1.5, t0);\n        \n        vec2 sliderCoord0 = sliderCoord - vec2(-1.+2.*value,0) * SLIDER_HALF_WIDTH;\n        \n        float t1 = length(sliderCoord0)-R0;\n        float a1 = smoothstep(1.5, -1.5, t1);\n        \n        float t2 = length(sliderCoord0)-R2;\n        float a2 = smoothstep(1.5, -1.5, t2);\n        \n        float energy = float((sliderCoord.x + SLIDER_HALF_WIDTH) / (2.*SLIDER_HALF_WIDTH) < value);\n        \n        float ao0 = 1. - .4 * SATURATE(exp(-.95 * -t0)) * a0;\n        fragColor.rgb = mix(fragColor.rgb, getEnergyColor(energy), a0);\n        fragColor.rgb *= ao0;\n        \n        float ao1 = 1. - .4 * SATURATE(exp(-.95 * t1));\n        fragColor.rgb *= ao1;\n        fragColor.rgb = mix(fragColor.rgb, vec3(1), a1);\n        \n        float ao2 = 1. - .4 * SATURATE(exp(-.95 * -t2)) * a2;\n        //fragColor.rgb = mix(fragColor.rgb, getEnergyColor(value), a2);\n        //fragColor.rgb *= ao2;\n\t\t\n    }\n}\n\n*/\nfloat GaussianG(in float x, in float y, in float sigma )\n{\n    float sigma2 = sigma * sigma;\n    float x2 = x * x;\n    float y2 = y * y;\n\treturn 1./(PI_2*sigma2) * exp(-(x2+y2)/(sigma2+sigma2));\n}\n\nvec3 GaussianBlur(in vec2 co, in int dim, in float sigma, in float sep)\n{\n    vec3 c = vec3(0);\n    float z = 0.;\n    for (int i=-dim; i < dim; ++i)\n    {\n\t\tfor (int j=-dim; j < dim; ++j)\n        {\n\t\t\tfloat g = GaussianG(float(i), float(j), sigma);\n            vec2 p = (co + (vec2(i,j)+.5) * sep);\n            vec3 col;\n            \n            if ( all(greaterThanEqual(ivec2(p), ivec2(0)))\n                && all(lessThan(ivec2(p), ivec2(iResolution.xy))) )\n            {\n            \tcol = texture(iChannel1,  p / iResolution.xy).rgb;\n            }\n            else\n            {\n                col = vec3(1);\n            }\n            \n            c += g * col;\n            z += g;\n\t\t}\n\t}\n    return c/z;\n}\n\n/*\n\nvoid\npaintGui (inout vec4 fragColor, in vec3 blurredColor, in vec2 coord)\n{\n    // Panels rendering\n    float aspect = iResolution.x / iResolution.y;\n    float t1 = -(coord.y - (iResolution.y - float(.1)));\n    float s1 = smoothstep(1., -1., t1);\n    \n    vec4 topPanelColor = vec4(1);\n    \n    float valOpen = readVar(guiStatePtr).x;\n    bool isOpen = bool(valOpen);\n    paintSidePanel(fragColor, blurredColor, coord, valOpen, isOpen);\n    \n    float ao = (1.-.2*SATURATE(exp(-.6 * t1)));\n    fragColor.rgb *= ao;\n    fragColor.rgb = mix(fragColor.rgb, mix(blurredColor, TRANSLUCENT_COLOR, GUI_TRANSLUCENCY), s1);\n\t    \n\t//paintCreeper(fragColor, coord - vec2(0, iResolution.y - float(TOP_PANEL_SIZE)), .65);\n    \n    \n    // Overlay info\n    if (false)\n    {\n       \t// Overlay text\n        float scale = 10.;\n        vec2 uv = coord / iResolution.y * iResolution.y / scale;\n        float px = 1. / iResolution.y * iResolution.y / scale;\n        \n        float x = 100.;\n        float cp = 0.;\n        vec4 cur = vec4(0,0,0,.01);\n        vec4 us = cur;\n        float ital = 0.0;\n\n        int lnr = int(floor(uv.y/2.));\n        uv.y = mod(uv.y,2.0)-1.0;\n        \n        if (lnr == 0)\n        {\n            ITAL DARKGREY W_ o_ r_ l_ d_ _ D_ i_ m_ _dotdot _;\n            BLACK _open1 _close1;\n\n            float weight = 0.05+cur.w*.02;//min(iTime*.02-.05,0.03);//+.03*length(sin(uv*6.+.3*iTime));//+0.02-0.06*cos(iTime*.4+1.);\n            fragColor.rgb = mix(fragColor.rgb, us.rgb, smoothstep(weight+px, weight-px, x));\n        }\n    }\n}\n*/\n\nfloat SinFBM(in float x)\n{\n    float f = 0.0;\n    f += .5 * sin(x * PI);\n    f += .25 * sin((x - .333) * PI * 2.);\n    f += .125 * sin((x - .666) * PI * 4.);\n    f += .0625 * sin((x - 1.) * PI * 8.);\n    \n    return f;\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nvoid paintStartupCreeper(inout vec4 finalColor, in vec3 bgColor, in vec2 uv, float tAnim)\n{\n    vec3 p = vec3(uv, 1./iResolution.y);\n    \n    float tPanel = (p.y - 1.);\n    float aPanel = smoothstep(1.5, -1.5, tPanel / p.z);\n    float aoPanel = 1.0 - .25 * exp(-16. * max(tPanel,0.));\n    \n    const float margin = .525;\n    //vec3 p = vec3(uv, 1) / theme.menu_scale;\n    \n    //p = p * 2. - vec3(1,1,0);\n    p /= margin;\n    \n    const float STRIPE_W = 0.0807;\n    float invStr = p.z / STRIPE_W;\n    float xStr = (p.x + p.y) / STRIPE_W;\n    float yStr = (p.y - p.x) / STRIPE_W;\n    float tStripes = abs(mod(xStr + .115 + .195*sin(.615*yStr), 2.) - 1.) - .591;\n    \n    p = p * .5 + vec3(.5,.5,0.);\n    \n    p *= 6.;\n    \n    vec2 p0 = p.xy;\n    p0.x = -abs(p0.x - 3.) + 3.;\n    \n\tfloat t = min(abs(sdBox(p0 - vec2(1, 5), vec2(1))),\n                  sdBox(p0 - vec2(1.5), vec2(.5, 1.5)) );\n    \n    t = min(t, min(sdBox(p.xy - vec2(3,2), vec2(2,1)),\n                  sdBox(p.xy - vec2(3,2.5), vec2(1,1.5)) ));\n    \n    t = abs(t)-.364;\n    //t /= p.z;\n    float tEdge = t/p.z;\n    t = max(t / p.z, tStripes / invStr);\n    \n    float a = smoothstep(1.5, -1.5, t);\n    \n    vec3 mainColor = UI_BACKGROUND_COLOR.rgb;\n    mainColor = mix(mainColor, bgColor, a);\n    \n    //finalColor.rgb = mix(aoPanel * finalColor.rgb, mainColor, aPanel);\n   \n    //finalColor.rgb *= 1. - .425 * exp(.342 * min(t,0.)) *(.55+.45*texture(iChannel3,p.xy*.0981125).r)* a;\n    mainColor.rgb = mix(mainColor.rgb, vec3(.39515) + .7 * (1.-SATURATE(exp(-.152 * abs(tEdge)) )) , smoothstep(1.5,-1.5,abs(t)-3.25));\n    finalColor.rgb = mix(mainColor.rgb, finalColor.rgb, exp(-2.*(2.-clamp(tAnim,0.,2.))));\n}\n/*\nvoid Paint_Creeper(inout vec4 dest, in vec2 p, in float inverse_scale)\n{\n    bool is_hot = false;\n    bool is_active = is_hot && false;\n    \n    uv = rotate(radians(45.)) * p);\n    \n    float t0 = sdBox(p, vec2(.8));\n    float t = max(min(abs(uv.x), abs(uv.y)), t0)-.025;\n    \n    float a = smoothstep(1.5, 0., t * inverse_scale);\n    \n    vec4 color;\n    if (is_active)\n    {\n        color = theme.active_color;\n    }\n    else if (is_hot)\n    {\n     \tcolor = theme.hot_color;   \n    }\n    else\n    {\n        color = theme.inactive_color;\n    }\n    \n    dest = mix(dest, color, a); \n}\n\nvoid Paint_XButton(inout vec4 dest, in vec2 uv)\n{\n    bool is_hot = false;\n    bool is_active = is_hot && false;\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    float button_scale = theme.menuSize;\n    \n    uv.x *= aspect;\n    uv = rotate(radians(45.)) * (uv - vec2(aspect,1) + button_scale * .5);\n    \n    float t0 = sdBox(uv, vec2(button_scale*.35));\n    float t = max(min(abs(uv.x), abs(uv.y)), t0) - .025*button_scale;\n    \n    float a = smoothstep(1.5, 0., t * iResolution.y);\n    \n    vec4 color;\n    if (is_active)\n    {\n        color = theme.active_color;\n    }\n    else if (is_hot)\n    {\n     \tcolor = theme.hot_color;   \n    }\n    else\n    {\n        color = theme.inactive_color;\n    }\n    \n    dest = mix(dest, color, a);\n}\n\nvoid paintMainButton(inout vec4 dest, in vec2 uv, in bool isOpen)\n{\n\tbool isHot = false;\n    bool isAlive = isHot && false;\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    float button_scale = theme.menuSize;\n    \n    float t = 1000.0;\n    \n    const int N = 3;\n    for (int i = 0; i < N; ++i)\n    {\n        vec2 uv0 = uv - vec2(0, 0.02 * button_scale);//(isOpen ? vec2(uv.x, 0.5*button_scale - uv.y) : uv) - vec2(0, 0.2*button_scale);\n        uv0.y += 0.7 * button_scale * ((float(i) + 0.5) / float(N));\n        uv0.x *= aspect;\n    \tuv0 = (uv0 - vec2(aspect,1) + button_scale * .5);\n        \n        uv0 = (isOpen ? vec2(uv0.x, 0.5*button_scale - uv0.y) : uv0) - vec2(0, 0.2*button_scale);\n\t    uv0 = rotate(radians(60.)) * vec2(abs(uv0.x), uv0.y);\n\n        float t0 = sdBox(uv0, vec2(button_scale*.35));\n    \tfloat t1 = max(abs(uv0.x), t0) - .025*button_scale;//max(min(abs(uv.x), abs(uv.y)), t0) - .025*button_scale;\n    \tt = min(t, t1);\n    }    \n    t *= iResolution.y;\n    \n    float a = smoothstep(1.5, 0.0, t);\n    //float ao = exp(-2.0 * t) * a;\n    \n    vec4 color = isAlive ? UI_ALIVE_COLOR : (isHot ? UI_HOT_COLOR : UI_DEAD_COLOR);\n    \n    //dest.rgb *= (1.0 - 0.9 * ao);\n    dest = mix(dest, color, a);\n}\n\n*/\n// pos is top left corner\n// size is bounds size\n// uv is normalized coordinates, starting from bottom left\n// value is slider value, from 0 to 1\nvoid paintSliderFloat(inout vec4 guiCol, in vec2 uv, in vec2 pos, in vec2 size, in float value)\n{\n    vec2 R = iResolution.xy;\n    float aspect = R.x / R.y;\n    uv.x *= aspect;\n    vec2 halfSize = 0.5 * size;\n    //float t = sdBox((uv - pos) - vec2(halfSize.x, -halfSize.y), halfSize);\n    vec2 centerPos = (uv - pos) - vec2(halfSize.x, -halfSize.y);\n    \n    const float W = 0.75;\n    \n    float t0 = (length( vec2(max(abs(centerPos.x) - W*halfSize.x, 0.0), centerPos.y) ) - 0.17*halfSize.y) * R.y;\n    float a0 = smoothstep(1.5, -1.5, t0);\n    \n    float t1 = (length( vec2((centerPos.x + W*halfSize.x) - W*size.x * value, centerPos.y) ) - 0.95*halfSize.y) * R.y;\n\tfloat a1 = smoothstep(1.5, -1.5, t1);\n    \n    float sliderAlpha = smoothstep(1.5, -1.5, ((centerPos.x + W*halfSize.x) - W*size.x * value) * R.y);\n    \n    vec4 sliderColor = sliderAlpha > 0.0 ? UI_ALIVE_COLOR : UI_DEAD_COLOR;\n    \n    float ao0 = clamp(exp(1.25 * t0), 0.0, 1.0) * a0;\n    guiCol.rgb *= (1.0 - 0.4 * ao0);\n    guiCol = mix(guiCol, sliderColor, a0);\n    \n    float ao1 = clamp(exp(-1.25 * t1), 0.0, 1.0) * (1.0-a1);\n    guiCol.rgb *= (1.0 - 0.4 * ao1);\n    guiCol = mix(guiCol, UI_ALIVE_COLOR, a1);\n    \n}\n\nvoid paintItemBar(inout vec4 finalColor, in vec3 bgColor, in vec4 mainColor, in vec2 coord)\n{\n    float aspect = iResolution.x / iResolution.y;\n    float halfAspect = 0.5 * aspect;\n    \n    vec2 uu = coord / iResolution.y;\n    \n    float halfHeight = 0.5 * ITEM_BOX_HEIGHT;\n    float halfWidth = 0.5 * float(ITEM_TYPE_COUNT) * ITEM_BOX_HEIGHT;\n    \n    vec2 halfItemBarSize = vec2(halfWidth, halfHeight);\n    \n    float tSelectionPanel = sdBox(uu - vec2(halfAspect, 0.1), halfItemBarSize);//abs(length(p)-0.8)-0.12;\n    float aSelectionPanel = smoothstep(1.5, -1.5,tSelectionPanel * iResolution.y);\n    finalColor.rgb *= 1. - .512*SATURATE(exp(-0.51*tSelectionPanel * iResolution.y));\n    \n    vec3 itemBarColor = mix(bgColor, mainColor.rgb, mainColor.a);\n    \n    vec2 itemUV = (uu - (vec2(halfAspect, 0.1) - halfItemBarSize)) / ITEM_BOX_HEIGHT;\n    int itemIndex = int(floor(itemUV.x));\n   \titemUV.x = fract(itemUV.x);\n    \n    finalColor.rgb = mix(finalColor.rgb, itemBarColor, aSelectionPanel);\n    int selectedItemIndex = int(readVar(SELECTED_ITEM_INDEX_ADDR)) % ITEM_TYPE_COUNT;\n    \n    if (itemIndex >= 0 && itemIndex < ITEM_TYPE_COUNT)\n    {\n        // Draw item into bar\n        vec2 itemP = itemUV * 2. - 1.;\n        \n        float invScale = iResolution.y * ITEM_BOX_HEIGHT;\n        float randAngle = UI_ENABLE_RANDOM_ITEM_ROT ? (.1*(hash11(float(itemIndex)+82.)*2.-1. ) * PI * .7) : 0.0;\n        \n        bool isChosen = selectedItemIndex == itemIndex;\n        \n        float itemBoxScale = DARK_ITEM_BOX_SIZE * (isChosen ? 1.0 : 0.8);\n        vec2 darkItemBoxP = rotate(randAngle) * itemP / itemBoxScale;\n        float darkItemBoxInvScale = invScale * itemBoxScale;\n        \n        float tDarkItemBox = sdBox(darkItemBoxP, vec2(1));\n        float aDarkItemBox = smoothstep(1.5, -1.5, tDarkItemBox*darkItemBoxInvScale );\n        float aEdgeItemBox = smoothstep(1.5, -1.5, (abs(tDarkItemBox)-.05)* darkItemBoxInvScale );\n        //float aoDarkItemBox = UI_ButtonAO( tDarkItemBox * darkItemBoxInvScale );\n        //finalColor.rgb *= aoDarkItemBox;\n        \n        finalColor.rgb = mix(finalColor.rgb, mix(bgColor, vec3(1), UI_ALPHA), aDarkItemBox);\n        \n        float itemScale = 1. - ITEM_BOX_Y_PADDING;\n        float invScale0 = darkItemBoxInvScale * itemScale;\n        vec2 itemP0 = darkItemBoxP / itemScale;\n        \n        vec4 menuVoxelColor = paintMenuVoxel(darkItemBoxP, darkItemBoxInvScale, ITEM_TYPE_ARRAY[itemIndex]);\n        float tItemBox = sdBox(darkItemBoxP, vec2(1));\n        float aItemBox = smoothstep(1.5, -1.5, tItemBox * darkItemBoxInvScale);\n        \n        finalColor.rgb = mix(finalColor.rgb, menuVoxelColor.rgb, menuVoxelColor.a * aDarkItemBox);\n        finalColor.rgb = mix(finalColor.rgb, vec3(0.25), aEdgeItemBox*.6);\n        //finalColor.rgb += .9 * illumItem * aDarkItemBox;\n        \n        if (isChosen)\n        {\n        \t// Draw item selector over everything\n            \n            #if 1\n            // Square shape for now\n            float tItemSelected = abs(tDarkItemBox)-.05;\n            float aItemSelected = smoothstep(3.,0.,tItemSelected * invScale);\n            float w = getSelectorWave();\n            finalColor.rgb = mix(finalColor.rgb, vec3(0,0,1), w * aItemSelected);\n            \n\t\t\t#else\n            // N-Gon selector (Hexagon by default)\n            \n            const float N = 5.;\n            float l = length(darkItemBoxP);\n            float a = atan(darkItemBoxP.y,darkItemBoxP.x)/TAU + .5;\n            a = ((fract(a * N)*2.-1.) / N)*.5*PI_2;\n\n            darkItemBoxP = vec2(cos(a), sin(a)) * l;\n            float tItemSelected = abs(darkItemBoxP.x-1.2)-.02;\n            float aItemSelected = smoothstep(3.,0.,tItemSelected * invScale);\n            finalColor.rgb = mix(finalColor.rgb, vec3(0,0,0), aItemSelected);\n            \n            #endif\n        }\n    }\n\n    float invScale = iResolution.y * ITEM_BOX_HEIGHT;\n    vec2 pos = (uu - (vec2(halfAspect, 0.1) - halfItemBarSize)) / ITEM_BOX_HEIGHT;\n    pos.x -= float(selectedItemIndex);\n    pos = pos*2.-1.;\n    \n    // Draw selector particles\n\tif(UI_ENABLE_REDSTONE_PARTICLES)\n    {\n        for (uint i = 0u; i < REDSTONE_PARTICLE_COUNT; ++i)\n        {\n            float seed = float(uint(selectedItemIndex) * REDSTONE_PARTICLE_COUNT + i * 8U);\n\n            float angle = hash11(seed++) * PI_2;\n            float speed = .4 + hash11(seed++) * 0.5;\n            vec2 dir = vec2(sin(angle), cos(angle)) * 0.9;\n            vec2 vel = dir * speed;\n            float lifeTime = .2 + 1.4  * hash11(seed++);\n            float initialTime = hash11(seed++) * lifeTime;\n\n            float radius = (.02 + hash11(seed++) * .05);\n\n            vec2 initialPos = dir;\n\n            vec2 particlePos = getParticlePos(initialPos, vel, initialTime, lifeTime, iTime);\n            float particleAlpha = getParticleAlpha(initialTime, lifeTime, iTime, 1.7);\n\n\n            float t = length(pos - particlePos) - radius;\n            float alpha = smoothstep(3., 0., t * invScale) * particleAlpha;\n            finalColor.rgb = mix(finalColor.rgb, vec3(.2), alpha);\n        }\n    }\n}\n\nvoid paintConfigButton(inout vec4 finalColor, in vec3 bgColor, in vec2 uu, in Button data)\n{\n    float invScale = iResolution.y * 2.;\n    float t = sdBox(uu - data.base.pos, data.base.scale);\n    float a = smoothstep(1.5, -1.5, t * invScale);\n    float ao = UI_ButtonAO(t * invScale);\n\tfinalColor.rgb = mix(finalColor.rgb * ao, mix(bgColor, UI_BACKGROUND_COLOR.rgb, UI_BACKGROUND_COLOR.a), a);\n    \n    // p inside button\n    vec2 p = (uu - data.base.pos) / data.base.scale;\n    float invScaleIcon = invScale * data.base.scale.y;\n    \n    if (t <= 0.)\n    {\n        const float R1 = 0.3, R2 = 0.6, R3 = 0.75;\n        const float N = 8.;\n        const float W = .15;\n\n        float l = length(p);\n        float angle = atan(p.y,p.x)/TAU + .5;\n        angle = ((fract(angle * N)*2.-1.) / N)*.5*PI_2;\n        vec2 pTeeth = vec2(cos(angle), sin(angle)) * l;\n\n        float tTeeth = max( length(p)-R3,  abs(pTeeth.y)-W );\n        float tIcon = max( min(length(p)-R2, tTeeth), -(length(p)-R1));\n\n    \t/*\n        const float N = 6.;\n        float l = length(darkItemBoxP);\n        float a = atan(darkItemBoxP.y,darkItemBoxP.x)/TAU + .5;\n        a = ((fract(a * N)*2.-1.) / N)*.5*PI_2;\n        */\n        float aIcon = smoothstep(1.5, -1.5, tIcon * invScaleIcon);\n\n        finalColor.rgb = mix(finalColor.rgb, vec3(0), aIcon);\n    }\n    \n}\n\nvoid paintUI(inout vec4 finalColor, in vec3 bgColor, in vec2 coord, in bool is_open)\n{\n    vec2 uv = coord / iResolution.xy;\n    vec2 p = (2.*coord - iResolution.xy) / iResolution.y;\n\n    float aspect = iResolution.x / iResolution.y;\n    // Fake UI reflections kinda based on Windows 7 Aero\n    vec2 uu = coord / iResolution.y;\n    //uu.y = 1.0 - uu.y;\n    float fakeReflX = mix(uu.x, uu.y, 0.3) - 3.2;\n    float fakeReflT0 = abs(fract(fakeReflX) * 2.0 - 1.0) - 0.5;\n    float fakeReflT1 = abs(fract(fakeReflX * 2.0 - 1.3) * 2.0 - 1.0) - 0.2;\n    float fakeReflT2 = abs(fract(fakeReflX * 8.0 - 3.7) * 2.0 - 1.0) - 0.1;\n    float fakeRefl = 0.2*smoothstep(64.0, 0.0, fakeReflT0 * iResolution.y) * pow(uv.y, 0.5)\n                   + 0.4*smoothstep(32.0, 0.0, fakeReflT1 * iResolution.y/4.0) * pow(uv.y, 0.8)\n                   + 0.4*smoothstep(24.0, 0.0, fakeReflT2 * iResolution.y/16.0 ) * pow(uv.y, 16.0);\n    \n    float t0 = sdBox(uu - vec2(0.1), vec2(0.07));//-(uv.y - 1.) - theme.menuSize;\n    //float t1 = -(t0 + theme.menu_band_scale);\n    \n    float a0 = smoothstep(3., 0., t0*iResolution.y);\n    \n    float a = false ? 1.0 : a0;\n\n    float w0 = SATURATE(exp(-2.5*abs(uv.x*2.-1.)));\n    //float menu_light = a1 * SATURATE(exp(2. * t0/theme.menu_band_scale)) * w0;\n    \n    vec4 mainColor = UI_BACKGROUND_COLOR;//vec4(mix(UI_BACKGROUND_COLOR.rgb, bg_color, UI_BACKGROUND_COLOR.a) + 0.5 * fakeRefl, 1.0);\n    //mainColor.rgb += 0.25 * fakeRefl;\n    //Paint_Creeper(main_color, uv);\n\n    \n    bool isOpen = false;//bool(fract(iTime)*2.0-1.0);\n    \n    //paintMainButton(mainColor, uv, isOpen);\n\t\n    if (isOpen)\n    {\n        paintSliderFloat(mainColor, uv, vec2(0, 1.0), vec2(0.4, 0.05), fract(iTime));\n        \n        //main_color = mix(main_color, theme.active_color, menu_light);\n\n        finalColor.rgb = mix(bgColor, mainColor.rgb, mainColor.a);\n    \t//float ao0 = 1. - .2 * SATURATE(exp(-60.*t0)) * w0 * (1.-a0);\n        //dest.rgb *= ao0;\n        //dest.rgb = mix(dest.rgb, vec3(0), pow(w0, 0.8) * smoothstep(1.5 / iResolution.y, 0.0, abs(t0)));\n        float s = 50.*64.;\n        float e = s/iResolution.x;\n        vec2 uv = coord * e;\n        uv -= vec2(0.34, 0.20)*s;\n        float alpha = 1.0-pow(glyph(uv, e)*0.8, 0.4545);\n        //dest = vec4(vec3(),1.0);\n        \n        finalColor.rgb = mix(finalColor.rgb, vec3(0), alpha * 0.25);\n        \n    }\n    else\n    {\n    \tpaintItemBar(finalColor, bgColor, mainColor, coord);\n        \n        //paintConfigButton(finalColor, bgColor, uu, UI_CONFIG_BUTTON);\n    \t//main_color = mix(main_color, theme.active_color, menu_light);\n    \t//float ao0 = 1. - SATURATE(exp(-0.95*t0 * iResolution.y));\n        //finalColor.rgb *= ao0;\n        \n        //bgColor = mix(bgColor, mainColor.rgb, mainColor.a);\n        \n        //finalColor.rgb = mix(finalColor.rgb, bgColor, a);\n        //dest.rgb = mix(dest.rgb, vec3(0), pow(w0, 0.8) * smoothstep(1.5 / iResolution.y, 0.0, abs(t0)));\n    }\n}\n\n\n\n\nfloat CURSOR_SIZE = 0.06;\nconst uint CURSOR_TEXT_SIZE = 8u;\n\nvoid\npaintCursor (inout vec4 dest, in vec3 bg_color, in uvec2 sCoord, in uvec2 sMouseCoord,\n             in uvec2 wCoord, in uvec2 wMouseCoord, in bool showBox )\n{\n    vec3 p = vec3(vec2(sCoord) - vec2(sMouseCoord), 1) / iResolution.y / CURSOR_SIZE;\n    p.xy = rotate(-radians(32.)) * p.xy;\n    //pos = pos * .5 + vec3(.5,.5,0);\n    \n    float t = (rotate(radians(65.)) * vec2(abs(p.x), p.y)).y;\n    t = max(t, -(p.y + .9));\n    //t = max(t, -(length(p.xy + vec2(0,1.5)) - .7));\n    \n    float t0 = length(p.xy)-.5;\n    \n    float alpha = smoothstep(1.5, -1.5, t / p.z * 2.);\n    vec3 color = getEnergyColor(cos(iTime * PI_2 * 4.) * .5 + .5);\n    \n    //ioColor.rgb *= 1. - .5 * pow(t, .2);\n    //fragColor.rgb *= 1.- .4 * exp(-25. * t / p.z) * (1.-alpha);\n    \n    vec3 invCol = Contrast(dest.rgb);\n    \n    dest.rgb = mix(dest.rgb, invCol, alpha*.86);\n    //ioColor.rgb *= 1. - .5 * smoothstep(1.5, 0., abs(t) / p.z);\n}\n\n\nvoid paintCursorSelectionInfo(inout vec4 finalColor, in vec3 bgColor, in uvec2 sCoord, in uvec2 sMouseCoord, in uvec2 wMouseCoord)\n{\n    vec4 mainColor = UI_BACKGROUND_COLOR;\n    \n    int layerIndex = int(readVar(VARIABLE_LOCATION_LAYER_INDEX).x);\n    \n    int selectedLayerIndex = layerIndex;\n    \n    int mode = int(readVar(VARIABLE_LOCATION_MODE).x);\n    if (mode == 0)\n    {\n        while (selectedLayerIndex > 0)\n        {\n            if (readVoxel(ivec3(wMouseCoord, selectedLayerIndex)).type != VOXEL_TYPE_VOID)\n                break;\n            --selectedLayerIndex;\n        }\n    }\n    \n    \n    Voxel voxel = readVoxel(ivec3(wMouseCoord, selectedLayerIndex));\n    \n    if (voxel.type != VOXEL_TYPE_VOID)\n    {\n        // Draw box\n        vec2 halfInfoScale = 0.5 * UI_INFO_BOX_SCALE;\n    \tvec2 uuv = vec2(ivec2(sCoord) - ivec2(sMouseCoord)) / iResolution.y;\n        float t = sdBox(uuv - vec2(halfInfoScale), vec2(halfInfoScale));\n        float a = smoothstep(1.5, -1.5, t * iResolution.y);\n        float ao = 1. - .4 * SATURATE(exp(-1.5*t * iResolution.y));\n        \n        finalColor.rgb *= ao;\n        //bgColor = mix(bgColor, mainColor.rgb, mainColor.a);\n        \n        finalColor.rgb = mix(finalColor.rgb, mix(bgColor, vec3(1), UI_ALPHA), a);\n        //finalColor.rgb = mix(finalColor.rgb, vec3(0.0), a);\n        \n        // Draw text info\n        \n        float scale = 1.;\n        float gly = 1. / UI_INFO_BOX_SCALE.x * 15.;\n        float boxPadding = 0.5;\n        vec2 uv = uuv * gly - boxPadding;\n        float px = gly / iResolution.y;\n\n        float x = 100.;\n        float cp = 0.;\n        vec4 cur = vec4(0,0,0,.01);\n        vec4 us = cur;\n        float ital = 0.0;\n\n        int lnr = int(floor(uv.y/2.));\n        uv.y = mod(uv.y,2.0)-0.5;\n        \n        if (lnr >= 0 && lnr <= 3 && voxel.type != VOXEL_TYPE_VOID)\n        {\n            //ITAL;\n\n            DARKGREY;\n            \n            if (lnr == 3)\n            {\n                // TODO: Add quotation marks\n                _TYPE _dotdot _ BLACK;\n                if (voxel.type == VOXEL_TYPE_VOID)\n                {\n                    V_ o_ i_ d_\n                }\n                else if (voxel.type == VOXEL_TYPE_STONE)\n                {\n                    S_ t_ o_ n_ e_\n                }\n                else if (voxel.type == VOXEL_TYPE_REDSTONE_DUST)\n                {\n                    R_ e_ d_ s_ t_ o_ n_ e_ _ D_ u_ s_ t_\n                }\n                else if (voxel.type == VOXEL_TYPE_REDSTONE_TORCH)\n                {\n                    R_ e_ d_ s_ t_ o_ n_ e_ _ T_ o_ r_ c_ h_\n                }\n                else if (voxel.type == VOXEL_TYPE_LEVER)\n                {\n                    L_ e_ v_ e_ r_\n                }\n                else if (voxel.type == VOXEL_TYPE_BUTTON)\n                {\n                    B_ u_ t_ t_ o_ n_\n                }\n                else if (voxel.type == VOXEL_TYPE_REDSTONE_LAMP)\n                {\n                    R_ e_ d_ s_ t_ o_ n_ e_ _ L_ a_ m_ p_\n                }\n            }\n            else if (lnr == 2)\n            {\n                _ENERGIZED _dotdot _;\n\n                if (voxel.energy > 0u)\n                {\n                    ENERGIZED true_;\n                }\n                else\n                {\n                    UNENERGIZED false_;\n                }\n            }\n            else if (lnr == 1)\n            {\n                _ENERGY _dotdot _;\n\n                uint e = voxel.energy;\n\n                cur.rgb = getEnergyColor(e);\n                HEX(e)\n            }\n            else if (lnr == 0)\n            {\n                _ADDRESS _dotdot _;\n\n                int addr = getWorldVirtualToAddr(globalWorld, globalImage, ivec3(wMouseCoord, layerIndex));\n\n                BLACK;\n                HEX(uint(addr));\n                //BLACK ITAL _0 x_;\n            }\n\n            vec3 clr = vec3(0.0);\n\n            float weight = 0.04+cur.w*.05;//min(iTime*.02-.05,0.03);//+.03*length(sin(uv*6.+.3*iTime));//+0.02-0.06*cos(iTime*.4+1.);\n            finalColor = mix(finalColor, vec4(us.rgb, 1.0), .8*smoothstep(weight+px, weight-px, x));\n        }\n        \n        //bgColor = mix(mainColor.rgb, bgColor, 1.0-mainColor.a);\n    }\n    \n/*\n    float boxPadding = 4.;\n    vec2 boxScale = vec2(scale * 5. * 1.5, scale * 5.);\n\n\n    vec2 uv = (uu - boxPadding - vec2(0,4.)) / iResolution.y * iResolution.y / scale;\n    float px = 1. / iResolution.y * iResolution.y / scale;\n\n    float x = 100.;\n    float cp = 0.;\n    vec4 cur = vec4(0,0,0,.01);\n    vec4 us = cur;\n    float ital = 0.0;\n\n    int lnr = int(floor(uv.y/2.));\n    uv.y = mod(uv.y,2.0)-1.0;\n\t*/\n    /*\n    uint layerIndex = uint(readVar(layerIndexLocation).x);\n    Voxel voxel = readVoxel(ivec3(wMouseCoord, layerIndex));\n\n    if (lnr >= 0 && lnr < 4 && voxel.type != VOXEL_TYPE_VOID)\n    {\n        //ITAL;\n\n        DARKGREY\n            if (lnr == 4)\n            {\n                _COORDINATES _dotdot;\n            }\n        else if (lnr == 3)\n        {\n            // TODO: Add quotation marks\n            _TYPE _dotdot _ BLACK;\n\n            if (voxel.type == VOXEL_TYPE_VOID)\n            {\n                _Void;\n            }\n            else if (voxel.type == VOXEL_TYPE_STONE)\n            {\n                _Stone;\n            }\n            else if (voxel.type == VOXEL_TYPE_REDSTONE_DUST)\n            {\n                _RedstoneDust;\n            }\n            else if (voxel.type == VOXEL_TYPE_REDSTONE_TORCH)\n            {\n                _RedstoneTorch;\n            }\n        }\n        else if (lnr == 2)\n        {\n            _ENERGIZED _dotdot _;\n\n            if (voxel.energy > 0u)\n            {\n                ENERGIZED true_;\n            }\n            else\n            {\n                UNENERGIZED false_;\n            }\n        }\n        else if (lnr == 1)\n        {\n            _ENERGY _dotdot _;\n\n            uint e = voxel.energy;\n\n            cur.rgb = getEnergyColor(e);\n            HEX(e)\n                }\n        else if (lnr == 0)\n        {\n            _ADDRESS _dotdot _;\n\n            int addr = getWorldVirtualToAddr(globalWorld, globalImage, ivec3(wMouseCoord, layerIndex));\n\n            BLACK;\n            HEX(uint(addr));\n            //BLACK ITAL _0 x_;\n        }\n\n        vec3 clr = vec3(0.0);\n\n        float weight = 0.05+cur.w*.02;//min(iTime*.02-.05,0.03);//+.03*length(sin(uv*6.+.3*iTime));//+0.02-0.06*cos(iTime*.4+1.);\n        mainColor = mix(mainColor, vec4(us.rgb, 1.0), smoothstep(weight+px, weight-px, x));\n    }\n\n    if (voxel.type != VOXEL_TYPE_VOID)\n    {\n        float t1 = sdBox(coord - boxScale - boxPadding - vec2(0,4.), boxScale + boxPadding);\n        float a = smoothstep(1., -1., t1);\n        bgColor = mix(mainColor.rgb, bgColor, 1.0-mainColor.a);\n        finalColor.rgb *= 1. - .2 * SATURATE(exp(-.6 * t1));\n        finalColor.rgb = mix(finalColor.rgb, bgColor, a);\n        //fragColor.rgb = mix(fragColor.rgb, mix(blurredColor, color, GUI_TRANSLUCENCY), smoothstep(1., -1., t1));\n    }*/\n}\n\nvoid paintModeText(inout vec4 col, in uvec2 coord, in vec3 bg)\n{   \n    vec2 uuv = vec2(coord) / iResolution.y;\n    //float H = 10.;\n    //float gly = 1. / H * 400.;\n    float scale = 3.2;\n    vec2 uv = /*uuv * gly - vec2(.5,gly-1.-.5)*/ vec2(coord.x, float(coord.y) - iResolution.y) / iResolution.x * 22.0 * scale + vec2(-.5,1.5);\n    float px = 22. / iResolution.x * scale;\n\n    float x = 100.;\n    float cp = 0.;\n    vec4 cur = vec4(0,0,0,0.5);\n    vec4 us = cur;\n    float ital = 0.0;\n\n    //int lnr = int(floor(uv.y/2.));\n    //uv.y = mod(uv.y,2.0)-0.5;\n\n    if (uv.y >= -1.0 && uv.y <= 1.0) {\n        BLACK M_ o_ d_ e_ _dotdot _\n        \n    \tint mode = int(readVar(VARIABLE_LOCATION_MODE));\n       \t\n        NOITAL DARKBLUE\n        switch (mode)\n        {\n            case MODE_LOWEST_NONVOID_Z:\n            \tL_ o_ w_ e_ s_ t_ _ N_ o_ n_ _sub V_ o_ i_ d_ _ Z_\n                break;\n            case MODE_CURRENT_Z:\n            \tC_ u_ r_ r_ e_ n_ t_ _ Z_\n            \tbreak;\n            \t\n        }\n\n        vec3 clr = vec3(0.0);\n\n        float weight = 0.008+cur.w*.05;//min(iTime*.02-.05,0.03);//+.03*length(sin(uv*6.+.3*iTime));//+0.02-0.06*cos(iTime*.4+1.);\n        col = mix(col, vec4(us.rgb, 1.0), smoothstep(weight+px, weight-px, x));\n    }\n}\n\nvoid paintWorldDimText(inout vec4 col, in uvec2 coord, in vec3 bg)\n{   \n    vec2 uuv = vec2(coord) / iResolution.y;\n    //float H = 10.;\n    //float gly = 1. / H * 400.;\n    float scale = 3.2;\n    vec2 uv = /*uuv * gly - vec2(.5,gly-1.-.5)*/ vec2(coord) / iResolution.x * 22.0 * scale - vec2(.5,1.);\n    float px = 22. / iResolution.x * scale;\n\n    float x = 100.;\n    float cp = 0.;\n    vec4 cur = vec4(0,0,0,0.5);\n    vec4 us = cur;\n    float ital = 0.0;\n\n    //int lnr = int(floor(uv.y/2.));\n    //uv.y = mod(uv.y,2.0)-0.5;\n\n    if (uv.y >= -1.0 && uv.y <= 1.0) {\n        ITAL W_ o_ r_ l_ d_ _ D_ i_ m_ _dotdot _\n        \n    \tuvec3 virtualDim = uvec3(globalWorld.virtualDim);\n       \t\n        NOITAL /*DARKBLUE u_ v_ e_ c_ _3*/ BLACK _open3\n        \n\t\tfor (int i = 0; i < 3; ++i)\n        {\n            DARKGREEN\n            DECIMAL(x)\n            if (i != 2) { _ _ }\n            \n        }\n        \n        BLACK _ _close3\n       \n        vec3 clr = vec3(0.0);\n\n        float weight = 0.01+cur.w*0.05;//min(iTime*.02-.05,0.03);//+.03*length(sin(uv*6.+.3*iTime));//+0.02-0.06*cos(iTime*.4+1.);\n        col = mix(col, vec4(us.rgb, 1.0), smoothstep(weight+px, weight-px, x));\n    }\n    \n}\n\nmat2 rot (in float x)\n{\n\tfloat c = cos(x), s = sin(x);\n    return mat2(c, s, -s, c);\n}\n\nvoid\npaintGrid (inout vec4 fragColor,\n           in Camera cam,\n           in vec2 wPos, in float alpha01)\n{\n    alpha01 = SATURATE(alpha01);\n    float alpha = 0., time;\n    vec2 pos;\n    float zScale = getScaleZ(cam);\n    \n    for (uint q = 0u; q < WORDL_GRID_QUADRILLAGE_DEPTH; ++q)\n    {\n        float scale = pow(2., float(q));\n    \tpos = abs(fract(wPos / scale + .5) - .5);\n        time = min(pos.x, pos.y);\n        \n        float tmpAlpha = pow((float(q) + 1.5) / float(WORDL_GRID_QUADRILLAGE_DEPTH), 1.5);\n        \n        alpha = max(alpha, tmpAlpha * smoothstep(3./iResolution.y, 0., time * zScale * scale));\n    }\n    \n    fragColor.rgb *= 1. - alpha01 * alpha;\n}\n\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1);\n    initializeAPI(fragCoord);\n    \n    Camera cam = readCamera(VARIABLE_LOCATION_CAMERA);\n    \n    uvec2 sMouseCoord = uvec2(floor(iMouse.xy));\n    uvec2 sCoord = uvec2(floor(fragCoord));\n    \n    vec2 res = iResolution.xy, sPos = (2.*fragCoord - res) / res.y,\n         sMousePos = (2.*iMouse.xy - res) / res.y;\n    \n    vec2 uv = fragCoord / res;\n    \n    mat3 MVP = getWorldToScreen( cam );\n    vec2 wPos = vec2(MVP * vec3(sPos, 1));\n    vec2 wMousePos = vec2(MVP * vec3(sMousePos, 1));\n\tuvec2 wCoord = uvec2(floor(wPos));\n    uvec2 wMouseCoord = uvec2(floor(wMousePos));\n    \n    float scaleZ = getScaleZ( cam );\n    float inverseScale = scaleZ * res.y;\n\n    fragColor.rgb = texture(iChannel1, uv).rgb;\n    \n    if(ENABLE_WORLD_GRID)\n    {\n        paintGrid(fragColor, cam, wPos, /*.25 * min(pow(SATURATE(scaleZ) * 3.25, 1.5), 1.0)*/ .15 );\n    }\n    \n    {\n        vec2 wSize = vec2(getWorld().virtualDim.xy);\n    \tfloat t = sdBox(wPos - wSize*.5, wSize * .5);\n        float alpha = smoothstep(-.25, .25, t);\n        \n        //fragColor.rgb *= 1. - .125 * alpha;\n        fragColor.rgb *= 1. - .3 * smoothstep(3.0, 0.0, -t * inverseScale);\n    }\n    \n    {\n\t    vec2 p = vec2(wMouseCoord) + .5;\n        float t1 = sdBox(wPos - p, vec2(.5));\n        float t2 = abs(t1);\n        float a1 = smoothstep(3., 0., t1 * inverseScale);\n        float a2 = smoothstep(3., 0., t2 * inverseScale);\n        \n        //float w = .1+(sin(3.*iTime*6.28)*.5+.5)*.1;\n        float w = getSelectorWave();\n        \n        //fragColor.rgb *= 1. - .05*w * a1;\n        //fragColor.rgb *= 1. - w * a1;\n        fragColor.rgb *= 1. - a2 * w;\n    }\n    \n    vec3 bgColor = vec3(0,0,0);\n    if (UI_ENABLE_BLUR)\n    {\n    \tbgColor = GaussianBlur(fragCoord, 4, 10.0, 2.0);\n        //bgColor = fragColor.rgb;//mix(fragColor.rgb, vec3(1), UI_ALPHA);\n    }\n    else\n    {\n     \tbgColor =    vec3(1,1,1);//texture(iChannel1, uv).rgb;\n    }\n    \n    paintUI(fragColor, bgColor, fragCoord, true);\n    //bgColor = fragColor.rgb;//1ix(fragColor.rgb, vec3(1), UI_ALPHA);\n    paintCursor(fragColor, bgColor, sCoord, sMouseCoord, wCoord, wMouseCoord, true);\n    //bgColor = fragColor.rgb;\n    paintCursorSelectionInfo(fragColor, bgColor, sCoord, sMouseCoord, wMouseCoord);\n    paintModeText(fragColor, sCoord, bgColor);\n    //paintWorldDimText(fragColor, sCoord, bgColor);\n    \n    #if 1\n    vec2 p = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    \n    float tStartupAnim = max(iTime - 2.,0.);\n    \n    if (tStartupAnim <= 4.0) // 2.0 the distance on y to travel, plus some for the AO\n    {\n    \tpaintStartupCreeper(fragColor, bgColor, p, tStartupAnim);\n    }\n    #endif\n    \n    if (ENABLE_VIGNETTE)\n    {\n        // From IQ's \"Mike\"\n    \tfragColor.rgb *= 0.2 + 0.8 * pow( clamp(16.0 * uv.x * uv.y * (1.0-uv.x) * (1.0-uv.y),0.,1.), 0.05 );\n    }\n    \n    float gamma = 1.1;\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / gamma));\n    //fragColor = vec4(Contrast(vec3(uv.x), 2.));\n\t//fragColor = texture(iChannel0, fragCoord/res);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\tShader Redstone 3 (c) by saidwho12\n\n    Shader Redstone 3 is licensed under a\n    Creative Commons Attribution 3.0 Unported License.\n\n    You should have received a copy of the license along with this\n    work.  If not, see <http://creativecommons.org/licenses/by/3.0/>.\n*/\n\nDEFINE_DEFAULT_API(iChannel0, 0)\n\nbool isWindowResized (void)\n{\n    ivec2 pos = ivec2(floor(globalCoord));\n    return (all(equal(pos, ivec2(VARIABLE_LOCATION_RESOLUTION, 0)))\n        && !any(equal(readVar(VARIABLE_LOCATION_RESOLUTION).xy, iResolution.xy))\n       );\n}\n\nbool isKeyPressed (in int key) {\n    return bool(texelFetch(iChannel1, ivec2(key, 0), 0).x);\n}\n\nbool isKeyReleased (in int key) {\n    return bool(texelFetch(iChannel1, ivec2(key, 1), 0).x);\n}\n\nbool isKeyEnabled (in int key) {\n    return bool(texelFetch(iChannel1, ivec2(key, 2), 0).x);\n}\n\nCamera\ngetDefaultCamera (in float zOffset)\n{\n    Camera cam;\n    cam.pos = vec3(vec2(globalWorld.virtualDim.xy) * .5, zOffset);\n    \n    return cam;\n}\n\nvoid\ninitializeChannel (void)\n{\n    ivec2 pos = ivec2(floor(globalCoord));\n    if (pos.y == 0)    \n    {\n        Camera cam = getDefaultCamera(1.75);\n        writeCamera(VARIABLE_LOCATION_CAMERA, cam);\n        \n        vec2 resolution = iResolution.xy;\n        writeVar(VARIABLE_LOCATION_RESOLUTION, resolution);\n        \n        writeVar(VARIABLE_LOCATION_LAYER_INDEX, 0.);\n    }\n    if (isInsideWorldReal(getWorld(), pos))\n    {\n        Voxel voxel = getDefaultVoxel(VOXEL_TYPE_VOID);\n        writeVoxel(voxel);\n    }\n}\n\nuint maxPowerFromCoord (in ivec3 coord, in bool isAboveOpaque)\n{\n    uint maxPower = 0u;\n    \n    Voxel voxel = readVoxel(coord);\n\tif (voxel.type == VOXEL_TYPE_REDSTONE_TORCH)\n    {\n        maxPower = max(maxPower, voxel.energy);\n    }\n    else if (voxel.type == VOXEL_TYPE_REDSTONE_DUST\n             && voxel.energy > 0u)\n    {\n        maxPower = max(maxPower, voxel.energy - 1u);\n    }\n    else if (voxel.type == VOXEL_TYPE_VOID)\n    {\n        Voxel voxelMinusZ = readVoxel(coord + ivec3(0,0,-1)),\n            voxelPlusZ = readVoxel(coord + ivec3(0,0,1));\n        \n        if (voxelMinusZ.type == VOXEL_TYPE_REDSTONE_DUST\n            && voxelMinusZ.energy > 0u)\n        {\n            maxPower = max(maxPower, voxelMinusZ.energy - 1u);\n        }\n        if (voxelPlusZ.type == VOXEL_TYPE_REDSTONE_DUST\n            && voxelPlusZ.energy > 0u)\n        {\n            maxPower = max(maxPower, voxelPlusZ.energy - 1u);\n        }\n    }\n    else if (voxel.type == VOXEL_TYPE_STONE && !isAboveOpaque)\n    {\n    \tVoxel voxelPlusZ = readVoxel(coord + ivec3(0,0,1));\n        if (voxelPlusZ.type == VOXEL_TYPE_REDSTONE_DUST\n            && voxelPlusZ.energy > 0u)\n        {\n            maxPower = max(maxPower, voxelPlusZ.energy - 1u);\n        }\n    }\n    \n    return maxPower;\n}\n\nconst uint MAX_PATHFINDER_STEPS = MAX_REDSTONE_POWER;\nconst uint MAX_NODE_COUNT = 50u;\n\n#define size_t uint\n\nbool isEnergizedTorch (in Voxel voxel)\n{\n\treturn voxel.type == VOXEL_TYPE_REDSTONE_TORCH && voxel.energy > 0u;\n}\n\nbool isEnergized (in Voxel voxel)\n{\n\treturn (voxel.type == VOXEL_TYPE_REDSTONE_TORCH\n        || voxel.type == VOXEL_TYPE_REDSTONE_DUST) && voxel.energy > 0u;\n}\n\nbool isEnergizedAt (in ivec3 coord)\n{\n\treturn isEnergized(readVoxel(coord));\n}\n\nstruct Node\n{\n    uvec3 key;\n  \tuint value;\n};\n    \nconst uint NODE_STATE_NEW    = 0u;\nconst uint NODE_STATE_OPEN   = 1u;\nconst uint NODE_STATE_CLOSED = 2u;\n    \nuint hash (in uvec3 key)\n{\n\treturn uint(hash13(key) * 43454.7678) % MAX_NODE_COUNT;\n}\n\nstruct Hashtable\n{\n\tNode data [MAX_NODE_COUNT];\n    size_t size;\n};\n    \nvoid hashtable_init (inout Hashtable thiz)\n{\n    thiz.size = MAX_NODE_COUNT;\n\tfor (uint i = 0u; i < thiz.size; ++i)\n    {\n       thiz.data[i].key = uvec3(0);\n       thiz.data[i].value = NODE_STATE_NEW;\n    }\n}\n\nvoid hashtable_insert (inout Hashtable thiz, in Node node)\n{\n    uint index = hash(node.key);\n    \n    while (thiz.data[index].value != NODE_STATE_NEW)\n    {\n        index = (index + 1u) % MAX_NODE_COUNT;\n    }\n    \n    thiz.data[index] = node;\n}\n\nbool hashtable_get (inout Hashtable thiz, in uvec3 key, inout Node node)\n{\n    uint index = hash(key);\n    while (thiz.data[index].value != NODE_STATE_NEW)\n    {\n        if (all(equal(key, thiz.data[index].key)))\n        {\n            node = thiz.data[index];\n            return true;\n        }\n        else\n        {\n            index = (index + 1u) % MAX_NODE_COUNT;\n        }\n    }\n    return false;\n}\n\nbool hashtable_delete (inout Hashtable thiz, in uvec3 key)\n{\n\tuint index = hash(key);\n   \n\tNode node;\n    while (thiz.data[index].value != NODE_STATE_NEW)\n    {\n        if (all(equal(key, thiz.data[index].key)))\n        {\n            break;\n        }\n        else\n        {\n            index = (index + 1u) % MAX_NODE_COUNT;\n        }\n    }\n    \n    if (thiz.data[index].value != NODE_STATE_NEW)\n    {\n        return false;\n    }\n    \n    thiz.data[index].value = NODE_STATE_NEW;\n    for (index = (index + 1u) % MAX_NODE_COUNT;\n         thiz.data[index].value != NODE_STATE_NEW;\n         index = (index + 1u) % MAX_NODE_COUNT)\n    {\n        node = thiz.data[index];\n        thiz.data[index].value = NODE_STATE_NEW;\n        hashtable_insert(thiz, node);\n    }\n    \n    return true;\n}\n\nNode hashtable_get (inout Hashtable thiz, in uint index)\n{\n\treturn thiz.data[int(index)];\n}\n\n#define Vector(T, N) struct { T data[N]; size_t size; }\n#define vector_init(_this) { _this.size = 0u; }\n\n#define vector_push(_this, _item)\\\nif (_this.size < size_t(_this.data.length()))\\\n{\\\n    _this.size ++; _this.data[_this.size - 1u] = _item;\\\n}\n\n#define vector_pop_at(_this, _index)\\\nif (_index < _this.size)\\\n{\\\n    for (size_t i_ = 0U; i_ < _this.size - 1u; ++i_)\\\n    {\\\n        if (i_ >= _index)\\\n        _this.data[i_] = _this.data[i_ + 1u];\\\n    }\\\n \t--_this.size;\\\n}\n\n/*\n#define vector_pop_at(_this, _index)\\\nif (_index < _this.size)\\\n{\\\n    size_t i_ = _index;\\\n    while (true)\\\n    {\\\n        if (i_ >= _this.size) break;\\\n        _this.data[i_] = _this.data[i_ + 1u];\\\n        ++i_;\\\n    }\\\n \t--_this.size;\\\n}\n*/\nbool pathfind (in ivec3 coord, inout uint pathLength)\n{\n    Vector(ivec3, 16u) openCoords;\n    Vector(ivec3, 32u) closedCoords;\n    vector_init(openCoords);\n    vector_push(openCoords, coord);\n    vector_init(closedCoords);\n    \n    ivec3 coordList[12];\n#define IS_COORD_BELOW(x) ((x) < 4U)\n#define IS_COORD_LEVEL(x) ((x) > 3U && (x) < 8U)\n#define IS_COORD_ABOVE(x) ((x) > 7U)\n\n    bool isClosedList[12];\n    bool isOpenList[12];\n    \n    for (uint i = 0u; i < MAX_REDSTONE_POWER; ++i)\n    {\n        pathLength = i;\n        for (size_t _j = openCoords.size, j = _j - 1u; _j > 0u; j = --_j - 1u)\n        {\n            /*\n    \t\tisClosedList = isOpenList\n                = bool[12](false, false, false, false, false, false, false, false, false, false, false, false);\n            */\n            isClosedList[0] = isOpenList[0] = false;\n            isClosedList[1] = isOpenList[1] = false;\n            isClosedList[2] = isOpenList[2] = false;\n            isClosedList[3] = isOpenList[3] = false;\n            isClosedList[4] = isOpenList[4] = false;\n            isClosedList[5] = isOpenList[5] = false;\n            isClosedList[6] = isOpenList[6] = false;\n            isClosedList[7] = isOpenList[7] = false;\n            isClosedList[8] = isOpenList[8] = false;\n            isClosedList[9] = isOpenList[9] = false;\n            isClosedList[10] = isOpenList[10] = false;\n            isClosedList[11] = isOpenList[11] = false;\n            \n            coordList[0]  = openCoords.data[j] + ivec3(-1,0,-1);\n            coordList[1]  = openCoords.data[j] + ivec3(1,0,-1);\n            coordList[2]  = openCoords.data[j] + ivec3(0,-1,-1);\n            coordList[3]  = openCoords.data[j] + ivec3(0,1,-1);\n            \n            coordList[4]  = openCoords.data[j] + ivec3(-1,0,0);\n            coordList[5]  = openCoords.data[j] + ivec3(1,0,0);\n            coordList[6]  = openCoords.data[j] + ivec3(0,-1,0);\n            coordList[7]  = openCoords.data[j] + ivec3(0,1,0);\n            \n            coordList[8]  = openCoords.data[j] + ivec3(-1,0,1);\n            coordList[9]  = openCoords.data[j] + ivec3(1,0,1);\n            coordList[10] = openCoords.data[j] + ivec3(0,-1,1);\n            coordList[11] = openCoords.data[j] + ivec3(0,1,1);\n            \n            for (size_t _k = closedCoords.size, k = _k - 1u; _k > 0u; k = --_k - 1u)\n            {\n                for (size_t voxelIdx = 0U; voxelIdx < size_t(coordList.length()); ++voxelIdx)\n                {\n                    ivec3 voxelCoord = coordList[voxelIdx];\n                    if (!isClosedList[voxelIdx] && isInsideWorldVirtual(globalWorld, voxelCoord))\n                    {\n                        isClosedList[voxelIdx] = all(equal( closedCoords.data[k], voxelCoord ));\n                    }\n                }\n            }\n            \n            for (size_t _k = openCoords.size, k = _k - 1u; _k > 0u; k = --_k - 1u)\n            {\n                if (i != j)\n                {\n                    for (size_t voxelIdx = 0U; voxelIdx < size_t(coordList.length()); ++voxelIdx)\n                    {\n                    \tivec3 voxelCoord = coordList[voxelIdx];\n                    \tif (!isOpenList[voxelIdx] && isInsideWorldVirtual(globalWorld, voxelCoord))\n                        {\n                            isOpenList[voxelIdx] = all(equal( openCoords.data[k], coordList[voxelIdx] ));\n                        }\n                    }\n                }\n            }\n            \n            // Actual spread code\n            for (size_t voxelIdx = 0U; voxelIdx < size_t(coordList.length()); ++voxelIdx)\n            {\n                ivec3 currCoord = coordList[voxelIdx];\n                Voxel currVoxel = readVoxel(currCoord);\n                if (!isOpenList[voxelIdx] && !isClosedList[voxelIdx] && isInsideWorldVirtual(globalWorld, currCoord))\n                {\n                    if (isEnergizedTorch(currVoxel) && IS_COORD_LEVEL(voxelIdx))\n                    {\n                        return true;\n                    }\n                    else if (currVoxel.type == VOXEL_TYPE_REDSTONE_DUST)\n                    {\n                        if (IS_COORD_BELOW(voxelIdx))\n                        {\n                            // Check if opaque block is blocking the energy\n                            Voxel aboveVoxel = readVoxel(currCoord + ivec3(0,0,1));\n                            if (!isVoxelOpaque(aboveVoxel))\n                            {\n                        \t\tvector_push(openCoords, currCoord);\n                            }\n                        }\n                        else if (IS_COORD_ABOVE(voxelIdx))\n                        {\n                        \t// Check if opaque block is blocking the energy\n                            Voxel aboveVoxel = readVoxel(openCoords.data[j] + ivec3(0,0,1));\n                            if (!isVoxelOpaque(aboveVoxel))\n                            {\n                        \t\tvector_push(openCoords, currCoord);\n                            }\n                        }\n                        else\n                        {\n                        \tvector_push(openCoords, currCoord);\n                        }\n                    }\n                }\n            }\n            \n            vector_push(closedCoords, openCoords.data[j]);\n            vector_pop_at(openCoords, j);\n        }\n    }\n    \n    return false;\n}\n\n// DirectX 9 ANGLE fix for force unroll loop issue\nvoid calculateEnergyDirectX9(inout Voxel voxel, in ivec3 worldCoord)\n{\n    uint maxTorchEnergy = 0U;\n    uint maxDustEnergy = 0U;\n\n    // Voxels on the same level\n    Voxel levelVoxels[4] = Voxel[4](\n        readVoxel(worldCoord + ivec3(-1, 0, 0)),\n        readVoxel(worldCoord + ivec3(1,  0, 0)),\n        readVoxel(worldCoord + ivec3(0,  1, 0)),\n        readVoxel(worldCoord + ivec3(0, -1, 0))\n    );\n\n    for (int i = 0; i < levelVoxels.length(); ++i)\n    {\n        if (levelVoxels[i].energy > 0U)\n        {\n            switch (levelVoxels[i].type)\n            {\n                case VOXEL_TYPE_REDSTONE_DUST:\n                maxDustEnergy = max(maxDustEnergy, levelVoxels[i].energy - 1U);\n                break;\n\n                case VOXEL_TYPE_REDSTONE_TORCH:\n                maxTorchEnergy = max(maxTorchEnergy, levelVoxels[i].energy);\n                break;\n            }\n        }\n    }\n\n    Voxel aboveVoxel = readVoxel(worldCoord + ivec3(0,0,1));\n\n    if (worldCoord.z > 0)\n    {\n        // Voxels below\n        Voxel voxels[4] = Voxel[4](\n            readVoxel(worldCoord + ivec3(-1, 0, -1)),\n            readVoxel(worldCoord + ivec3(1,  0, -1)),\n            readVoxel(worldCoord + ivec3(0,  1, -1)),\n            readVoxel(worldCoord + ivec3(0, -1, -1))\n        );\n\n\n        for (int i = 0; i < voxels.length(); ++i)\n        {\n            if (voxels[i].type == VOXEL_TYPE_REDSTONE_DUST\n                && voxels[i].energy > maxDustEnergy\n                && levelVoxels[i].type != VOXEL_TYPE_STONE)\n            {\n                maxDustEnergy = voxels[i].energy - 1U;\n            }\n        }\n    }\n\n    if (worldCoord.z <= globalWorld.virtualDim.z && aboveVoxel.type != VOXEL_TYPE_STONE)\n    {\n        // Voxels above\n        Voxel voxels[4] = Voxel[4](\n            readVoxel(worldCoord + ivec3(-1, 0, 1)),\n            readVoxel(worldCoord + ivec3(1,  0, 1)),\n            readVoxel(worldCoord + ivec3(0,  1, 1)),\n            readVoxel(worldCoord + ivec3(0, -1, 1))\n        );\n\n\n        for (int i = 0; i < voxels.length(); ++i)\n        {\n            if (voxels[i].type == VOXEL_TYPE_REDSTONE_DUST\n                && voxels[i].energy > maxDustEnergy)\n            {\n                maxDustEnergy = voxels[i].energy - 1U;\n            }\n        }\n    }\n\n\n    if (maxTorchEnergy > 0U)\n        voxel.energy = max(voxel.energy, maxTorchEnergy);\n    else\n        voxel.energy = maxDustEnergy;\n}\n\n\n// NOTE: this is also used for stone-like blocks such as lamps\nuint calculateStoneMaxPower(in Voxel voxel, in ivec3 worldCoord)\n{\n    uint maxPower = 0U;\n\n    Voxel voxelMinusZ = readVoxel(worldCoord + ivec3(0,0,-1));\n    if (voxelMinusZ.type == VOXEL_TYPE_REDSTONE_TORCH)\n    {\n        maxPower = max(maxPower, voxelMinusZ.energy);\n    }\n    else\n    {\n        int dummyOutInt;\n        Voxel voxelMinusX, voxelPlusX, voxelMinusY, voxelPlusY, voxelPlusZ;\n\n        voxelMinusX = readVoxel(worldCoord + ivec3(-1,0,0));\n        voxelPlusX = readVoxel(worldCoord + ivec3(1,0,0));\n        voxelMinusY = readVoxel(worldCoord + ivec3(0,-1,0));\n        voxelPlusY = readVoxel(worldCoord + ivec3(0,1,0));\n        voxelPlusZ = readVoxel(worldCoord + ivec3(0,0,1));\n\n        bool voxelAboveOpaque = checkFlag(readVoxel(worldCoord + ivec3(-1,0,1)).type,\n                                          VOXEL_TYPE_OPAQUE);\n\n        bool leftConnected, rightConnected, forwardConnected;\n\n        if (voxelMinusX.type == VOXEL_TYPE_REDSTONE_DUST)\n        {\n            leftConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(-1,-1,0), dummyOutInt, voxelAboveOpaque);\n            rightConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(-1,1,0), dummyOutInt, voxelAboveOpaque);\n            forwardConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(-2,0,0), dummyOutInt, voxelAboveOpaque);\n\n            if (  forwardConnected && !(leftConnected || rightConnected)\n                || !(forwardConnected || leftConnected || rightConnected)\n               )\n            {\n                maxPower = max(maxPower, voxelMinusX.energy);\n            }\n        }\n\n        if (voxelPlusX.type == VOXEL_TYPE_REDSTONE_DUST)\n        {\n            leftConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(1,1,0), dummyOutInt, voxelAboveOpaque);\n            rightConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(1,-1,0), dummyOutInt, voxelAboveOpaque);\n            forwardConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(2,0,0), dummyOutInt, voxelAboveOpaque);\n\n            if (  forwardConnected && !(leftConnected || rightConnected)\n                || !(forwardConnected || leftConnected || rightConnected)\n               )\n            {\n                maxPower = max(maxPower, voxelPlusX.energy);\n            }\n        }\n        if (voxelMinusY.type == VOXEL_TYPE_REDSTONE_DUST)\n        {\n            leftConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(-1,-1,0), dummyOutInt, voxelAboveOpaque);\n            rightConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(1,-1,0), dummyOutInt, voxelAboveOpaque);\n            forwardConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(0,-2,0), dummyOutInt, voxelAboveOpaque);\n\n            if (  forwardConnected && !(leftConnected || rightConnected)\n                || !(forwardConnected || leftConnected || rightConnected)\n               )\n            {\n                maxPower = max(maxPower, voxelMinusY.energy);\n            }\n        }\n\n        if (voxelPlusY.type == VOXEL_TYPE_REDSTONE_DUST)\n        {\n            leftConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(1,1,0), dummyOutInt, voxelAboveOpaque);\n            rightConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(-1,1,0), dummyOutInt, voxelAboveOpaque);\n            forwardConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(0,2,0), dummyOutInt, voxelAboveOpaque);\n\n            if (  forwardConnected && !(leftConnected || rightConnected)\n                || !(forwardConnected || leftConnected || rightConnected)\n               )\n            {\n                maxPower = max(maxPower, voxelPlusY.energy);\n            }\n        }\n\n        if (voxelPlusZ.type == VOXEL_TYPE_REDSTONE_DUST)\n        {\n            maxPower = max(maxPower, voxelPlusZ.energy);\n        }\n\n    }\n\n    return maxPower;\n}\n\n\nvoid simlateWorld (inout Voxel voxel, in ivec3 worldCoord)\n{\n    if (voxel.type == VOXEL_TYPE_REDSTONE_DUST)\n    {\n#ifdef DX9_FIX\n        \n        calculateEnergyDirectX9(voxel, worldCoord);\n        \n#else\n        voxel.energy = 0u;\n        uint pathLength = 0u;\n        if (pathfind(worldCoord, pathLength))\n        {\n            voxel.energy = MAX_REDSTONE_POWER - pathLength;\t\n        }\n#endif\n    }\n    else if (voxel.type == VOXEL_TYPE_STONE)\n    {\n        voxel.energy = calculateStoneMaxPower(voxel, worldCoord);\n    }\n    else if (voxel.type == VOXEL_TYPE_REDSTONE_TORCH\n             && isRedstoneTorchFacing(voxel.facing))\n    {\n        Voxel voxelAttached;\n        ivec3 voxelAttachedOffset;\n\n        if (voxel.facing == VOXEL_FACING_MINUS_X)\n        {\n            voxelAttachedOffset = ivec3(-1,0,0);\n        }\n        else if (voxel.facing == VOXEL_FACING_PLUS_X)\n        {\n            voxelAttachedOffset = ivec3(1,0,0);\n        }\n        else if (voxel.facing == VOXEL_FACING_MINUS_Y)\n        {\n            voxelAttachedOffset = ivec3(0,-1,0);\n        }\n        else if (voxel.facing == VOXEL_FACING_PLUS_Y)\n        {\n            voxelAttachedOffset = ivec3(0,1,0);\n        }\n        else if (voxel.facing == VOXEL_FACING_PLUS_Z)\n        {\n            voxelAttachedOffset = ivec3(0,0,-1);\n        }\n\n        voxelAttached = readVoxel(worldCoord + voxelAttachedOffset);\n\n        if (voxelAttached.type == VOXEL_TYPE_STONE)\n        {\n            voxel.energy = uint(!bool(voxelAttached.energy > 0u)) * MAX_REDSTONE_POWER;\n        }\n        else\n        {\n        \tvoxel.energy = getDefaultVoxelEnergy(voxel.type);\n        }\n    }\n    else if (voxel.type == VOXEL_TYPE_REDSTONE_LAMP)\n    {\n        uint maxPower = calculateStoneMaxPower(voxel, worldCoord);\n        \n        // In addition to typical stone block mechanics,\n        // the lamp can receive power directly from a neighboring\n        // redstone torch.\n        Voxel levelVoxels[4] = Voxel[4](\n            readVoxel(worldCoord + ivec3(-1, 0, 0)),\n            readVoxel(worldCoord + ivec3(1,  0, 0)),\n            readVoxel(worldCoord + ivec3(0,  1, 0)),\n            readVoxel(worldCoord + ivec3(0, -1, 0))\n        );\n\n        for (int i = 0; i < levelVoxels.length(); ++i)\n        {\n            if (levelVoxels[i].type == VOXEL_TYPE_REDSTONE_TORCH || levelVoxels[i].type == VOXEL_TYPE_STONE)\n            {\n                maxPower = max(maxPower, levelVoxels[i].energy);\n            }\n        }\n\n        voxel.energy = maxPower;\n    }\n}\n\n/*\nGUI_Extent Button0_Extent(in bool isOpen) // side panel button\n{\n    uint xOffset = uint(isOpen) * PANEL0_SIZE;\n    uint yOffset = uint(SATURATE(BUTTON0_YOFFSET) * (iResolution.y - float(TOP_PANEL_SIZE))) - BUTTON0_SIZE_Y/2U;\n    \n    GUI_Extent extent;\n    extent.x0 = uvec2(xOffset, yOffset);\n    extent.x1 = extent.x0 + uvec2(BUTTON0_SIZE_X, BUTTON0_SIZE_Y);\n    \n    return extent;\n}\n\nbool Do_Button0(in bool isOpen)\n{\n    ivec2 p = ivec2(iMouse.xy);\n \t\n    GUI_Extent extent = Button0_Extent(isOpen);\n    \n    bool isHit = hitPointAABB(ivec2(extent.x0), ivec2(extent.x1), p);\n    return isHit && isKeyReleased(keyPrimaryAction);\n}\n*/\n\nvoid\nupdateChannel (void)\n{\n    ivec2 pos = ivec2(floor(globalCoord));\n    \n    Camera cam = readCamera(VARIABLE_LOCATION_CAMERA);\n    mat3 viewProj = getWorldToScreen(cam);\n\n    vec2 _mousePos = (2.*iMouse.xy - iResolution.xy) / iResolution.y;\n    ivec2 mousePos = ivec2(floor(viewProj * vec3(_mousePos, 1)));        \n\n    if (pos.y == 0)\n    {\n        writeVar(pos.x, readVar(pos.x));\n        \n        // Handle zooming\n        float zoomSpeed = 0.;\n        \n        Camera cam = readCamera(VARIABLE_LOCATION_CAMERA);\n        \n        if (isKeyPressed(KEY_ZOOM_PLUS))\n        {\n        \tzoomSpeed -= CAMERA_ZOOM_SPEED;\n        }\n        if (isKeyPressed(KEY_ZOOM_MINUS))\n        {\n        \tzoomSpeed += CAMERA_ZOOM_SPEED;\n        }\n        \n        // Handle motion\n        vec2 motionSpeed = vec2(0);\n        \n        if (isKeyPressed(KEY_MOVE_MINUS_X))\n        {\n        \tmotionSpeed.x -= CAMERA_MOTION_SPEED;\n        }\n        if (isKeyPressed(KEY_MOVE_PLUS_X))\n        {\n        \tmotionSpeed.x += CAMERA_MOTION_SPEED;\n        }\n        if (isKeyPressed(KEY_MOVE_MINUS_Y))\n        {\n        \tmotionSpeed.y -= CAMERA_MOTION_SPEED;\n        }\n        if (isKeyPressed(KEY_MOVE_PLUS_Y))\n        {\n        \tmotionSpeed.y += CAMERA_MOTION_SPEED;\n        }\n        \n        if (isKeyPressed(KEY_FAST_MOVE))\n        {\n        \tmotionSpeed *= 2.;\n        }\n        \n        cam.pos.xy += motionSpeed * iTimeDelta;\n        cam.pos.z += zoomSpeed * iTimeDelta;\n        \n        ///cam.pos.z = 2. + sin(iTime)*1.5;\n        writeCamera(VARIABLE_LOCATION_CAMERA, cam);\n        \n        int layerIndex = int(readVar(VARIABLE_LOCATION_LAYER_INDEX));\n        \n        if (isKeyReleased(KEY_LAYER_MINUS))\n        {\n            --layerIndex;\n        }\n        if (isKeyReleased(KEY_LAYER_PLUS))\n        {\n            ++layerIndex;\n        }\n        \n        layerIndex = clamp(layerIndex, 0, getWorld().virtualDim.z);\n        \n        writeVar(VARIABLE_LOCATION_LAYER_INDEX, float(layerIndex));\n        \n        // Handle item selection\n        int itemIndex = int(readVar(SELECTED_ITEM_INDEX_ADDR));\n        \n        if (isKeyReleased(KEY_SELECTOR_LEFT))\n        {\n            --itemIndex;\n        }\n        if (isKeyReleased(KEY_SELECTOR_RIGHT))\n        {\n            ++itemIndex;\n        }\n        \n        itemIndex = int(mod(float(itemIndex), float(ITEM_TYPE_ARRAY.length())));\n        \n        writeVar(SELECTED_ITEM_INDEX_ADDR, float(itemIndex));\n        \n        {\n            // Change edit mode\n            int mode = int(readVar(VARIABLE_LOCATION_MODE).x);\n            mode += int(isKeyReleased(KEY_CHANGE_MODE));\n            writeVar(VARIABLE_LOCATION_MODE, float(mode % 2));\n        }\n        \n        /*\n        bool isPanelOpen = bool(readVar(guiStatePtr).x);\n        \n        if (Do_Button0(isPanelOpen))\n        {\n            isPanelOpen = !isPanelOpen;\n        }\n        \n        writeVar(guiStatePtr, float(isPanelOpen));*/\n    }\n    else if (isInsideWorldReal(getWorld(), pos))\n    {\n        // Update world from UI interaction\n        ivec2 realWorldPos = getImageToWorldReal(getWorld(), getImage(), pos);\n        ivec3 worldCoord = getImageToWorldVirtual(getWorld(), getImage(), pos);\n\n        int layerIndex = int(readVar(VARIABLE_LOCATION_LAYER_INDEX));\n\n        Voxel voxel = readVoxel(worldCoord);\n        uint selectedItemType = ITEM_TYPE_ARRAY[int(readVar(SELECTED_ITEM_INDEX_ADDR))];\n\n        // Find lowest block which isn't void\n        int selectedLayerIndex = layerIndex;\n        \n        int mode = int(readVar(KEY_CHANGE_MODE).x);\n        if (mode == 0)\n        {\n            while (selectedLayerIndex > 0)\n            {\n                if (readVoxel(ivec3(mousePos, selectedLayerIndex)).type != VOXEL_TYPE_VOID)\n                    break;\n            \t--selectedLayerIndex;\n            }\n        }\n\n        ivec3 selectedCoordZeroZ = ivec3(mousePos, selectedLayerIndex);\n        ivec3 selectedCoordOneZ = selectedCoordZeroZ + ivec3(0,0,1);\n        bool selectedZeroZ = all(equal(worldCoord, selectedCoordZeroZ));\n        bool selectedOneZ = all(equal(worldCoord, selectedCoordOneZ)) && selectedLayerIndex != layerIndex;\n\n        if (isKeyReleased(KEY_PRIMARY_ACTION) && (selectedZeroZ || selectedOneZ))\n        {\n            if (selectedOneZ)\n            {\n                Voxel voxelZeroZ = readVoxel(selectedCoordZeroZ);\n                if (voxel.type == VOXEL_TYPE_VOID\n                    && voxelZeroZ.type != VOXEL_TYPE_VOID\n                    && !checkFlag(voxelZeroZ.type, VOXEL_TYPE_FACING)\n                   ) \n                {\n                    voxel = getDefaultVoxel(selectedItemType);\n                }\n            }\n\n            if (selectedZeroZ)\n            {\n                if (voxel.type == VOXEL_TYPE_VOID)\n                {\n                    voxel = getDefaultVoxel(selectedItemType);\n                }\n                else if (checkFlag(voxel.type, VOXEL_TYPE_FACING)\n                         && selectedItemType == voxel.type)\n                {\n                    // Changing voxel facing direction\n                    voxel.facing = getNextVoxelFacing(voxel);\n                }\n            }\n        }\n        else if (isKeyReleased(KEY_SECONDARY_ACTION) && selectedZeroZ)\n        {\n            voxel = getDefaultVoxel(VOXEL_TYPE_VOID);\n        }\n        \n        // Simulate redstone in world\n        simlateWorld(voxel, worldCoord);\n        writeVoxel(voxel);\n    }\n}\n\nvoid\nmainImage (out vec4 fragColor, in vec2 fragCoord)\n{   \n    initializeAPI(fragCoord);\n    \n    \n    if (iFrame == 0)\n    {\n        initializeChannel();\n    }\n    else\n    {\n        updateChannel();\n    }\n    \n    fragColor = terminate();\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n\tShader Redstone 3 (c) by saidwho12\n\n    Shader Redstone 3 is licensed under a\n    Creative Commons Attribution 3.0 Unported License.\n\n    You should have received a copy of the license along with this\n    work.  If not, see <http://creativecommons.org/licenses/by/3.0/>.\n*/\n\n/*\n\tControls are set in 'Common' tab.\n*/\n\nDEFINE_DEFAULT_API(iChannel0, 0)\n\nvoid blendOver(out vec4 Co, in vec3 Ca, in vec3 Cb, in float alpha_a, in float alpha_b)\n{\n\tCo.a = alpha_a + alpha_b * (1.0 - alpha_a);\n    Co.rgb = /*Ca + Cb * (1.0 - alpha_a);*/(Ca * alpha_a + Cb * alpha_b * (1.0 - alpha_a)) / Co.a;\n}\n\n\nvoid\ndrawRedstoneLamp(inout vec4 color,\n        in vec2 pos,\n        in float alphaScale,\n        in float invScale,\n        in float power) // 0-1 power\n{\n    const float W = .13;\n    float t1 = -sdBox(pos,vec2(1))-W/2.;\n    float t2 = min(abs(pos.x),abs(pos.y));\n    float t3 = length(vec2(abs(pos.x), abs(pos.y)))-.5;\n    float tt = min(min(t1,t2),t3);\n    float alpha = smoothstep(1.5, -1.5, (abs(tt)-W) * invScale );\n    vec4 tmp = vec4(mix(LAMP_COLOR*power,WOOD_COLOR,alpha),1);\n    color = mix(color, tmp, alphaScale);\n}\n\nvoid\ndrawRedstoneDust (inout vec4 color,\n                  in vec2 pos,\n                  in ivec3 coord, in float alphaScale, in float invScale)\n{\n    float t = 1000.;\n    \n    Voxel voxel = readVoxel(coord);\n    \n    bool magicBool = isVoxelAtCoordOpaque(coord + ivec3(0, 0, 1));\n    int dummyZOffset;\n\t\n    bool connectableLeft = isVoxelAtCoordDustConnectable(coord + ivec3(-1, 0, 0), dummyZOffset, magicBool);\n    bool connectableRight = isVoxelAtCoordDustConnectable(coord + ivec3(1, 0, 0), dummyZOffset, magicBool);\n\tbool connectableBottom = isVoxelAtCoordDustConnectable(coord + ivec3(0, -1, 0), dummyZOffset, magicBool);\n    bool connectableTop = isVoxelAtCoordDustConnectable(coord + ivec3(0, 1, 0), dummyZOffset, magicBool);\n    \n    bvec4 voxelsAroundConnectable = bvec4(connectableLeft, connectableRight, connectableBottom, connectableTop);  \n    \n    if (!any(voxelsAroundConnectable))\n    {\n        t = min(abs(pos.x), abs(pos.y));\n    }\n    else if (any(voxelsAroundConnectable.xy) && !any(voxelsAroundConnectable.zw))\n    {\n    \tt = abs(pos.y);\n    }\n    else if (!any(voxelsAroundConnectable.xy) && any(voxelsAroundConnectable.zw))\n    {\n    \tt = abs(pos.x);\n    }\n    else\n    {\n        if (voxelsAroundConnectable[0])\n        {\n        \tt = min(t, max(abs(pos.y), pos.x) );\n        }\n        if (voxelsAroundConnectable[1])\n        {\n        \tt = min(t, max(abs(pos.y), -pos.x) );\n        }\n        if (voxelsAroundConnectable[2])\n        {\n        \tt = min(t, max(abs(pos.x), pos.y) );\n        }\n        if (voxelsAroundConnectable[3])\n        {\n        \tt = min(t, max(abs(pos.x), -pos.y) );\n        }\n    }\n    \n    t -= REDSTONE_DUST_WIDTH*.5;\n    \n    float alpha = smoothstep(3., 0., t * invScale);\n    \n    vec4 voxelColor = vec4(getEnergyColor(voxel.energy) * ENERGY_BRIGHTNESS,\n                    alpha * alphaScale);\n    \n    //voxelColor.rgb *= voxelColor.a;\n    //blendOver(color, color.rgb, voxelColor.rgb, color.a, voxelColor.a);\n    color = mix(color, voxelColor, voxelColor.a /** (1.0 - color.a)*/);\n}\n\n\nvoid\ndrawRedstoneTorch (inout vec4 color,\n                   in vec2 pos,\n                   in ivec3 coord, in float alphaScale, in float invScale)\n{\n    Voxel voxel = readVoxel(coord);\n    \n    float tHandle, handleAlpha, tHead = length(pos) - REDSTONE_TORCH_RADIUS, headAlpha;\n    \n    \n    if (voxel.facing != VOXEL_FACING_PLUS_Z)\n    {\n    \n        if      (voxel.facing == VOXEL_FACING_MINUS_X)\n            tHandle = max(abs(pos.y), pos.x);\n        else if (voxel.facing == VOXEL_FACING_PLUS_X)\n            tHandle = max(abs(pos.y), -pos.x);\n        else if (voxel.facing == VOXEL_FACING_MINUS_Y)\n            tHandle = max(abs(pos.x), pos.y);\n        else if (voxel.facing == VOXEL_FACING_PLUS_Y)\n            tHandle = max(abs(pos.x), -pos.y);\n    \n    \ttHandle -= REDSTONE_TORCH_HANDLE_WIDTH * .5;\n    \n        handleAlpha = smoothstep(3., 0., tHandle * invScale);\n        vec4 handleColor = vec4(REDSTONE_TORCH_HANDLE_COLOR, handleAlpha * alphaScale);\n        //handleColor.rgb *= handleColor.a;\n        //blendOver(color, color.rgb, handleColor.rgb, color.a, handleColor.a);\n        color = mix(color, handleColor, handleColor.a /** (1.0 - color.a)*/);\n        //color.a = (1.0 - color.a) * handleColor.a;\n    }\n\n    headAlpha = smoothstep(3., 0., tHead * invScale);\n    //color.rgb = mix(color.rgb, getRedstoneColor(voxel.power), alphaScale * headAlpha);\n    \n    vec4 voxelColor = vec4(getEnergyColor(voxel.energy) * ENERGY_BRIGHTNESS, headAlpha * alphaScale);\n    //voxelColor.rgb *= voxelColor.a;\n    //blendOver(color, color.rgb, voxelColor.rgb, color.a, voxelColor.a);\n    \n    \n    color = mix(color, voxelColor, voxelColor.a);\n    //color.a = voxelColor.a;\n    //color.rgb *= 1. - .1 * exp(-10. * t) * (1.-alpha);\n    /*\n    uint uniqueIndex = uint(getWorldVirtualToIndex(getWorld(), getImage(), coord));\n    \n    for (uint i = 0u; i < REDSTONE_PARTICLE_COUNT; ++i)\n    {\n    \tfloat seed = float(uniqueIndex * REDSTONE_PARTICLE_COUNT + i * 4u);\n\n        float angle = hash11(seed++) * TAU;\n        float speed = .1 + hash11(seed++) * .4;\n        vec2 dir = vec2(sin(angle), cos(angle));\n        vec2 vel = dir * speed;\n        float lifeTime = .4 + .6  * hash11(seed++);\n        float initialTime = hash11(seed++) * lifeTime;\n\n        float radius = (.03 + pow(hash11(seed++), 2.) * .22) * REDSTONE_TORCH_RADIUS;\n\n        vec2 initialPos = dir * REDSTONE_TORCH_RADIUS;\n\n        vec2 particlePos = getParticlePos(initialPos, vel, initialTime, lifeTime, iTime);\n        float particleAlpha = .7 * getParticleAlpha(initialTime, lifeTime, iTime, 2.5);\n\n        float t = length(pos - particlePos) - radius;\n        float alpha = smoothstep(3., 0., t * invScale) * particleAlpha * alphaScale;\n        color.rgb = mix(color.rgb, getRedstoneColor(MAX_REDSTONE_POWER), alpha);\n    }\n\t*/\n}\n\nvoid\npaintVoxel ( inout vec4 fragColor, in vec2 mPos, in ivec3 wCoord, in float alpha01, in float inverseScale )\n{\n    Voxel voxel = readVoxel(wCoord);\n    \n\n    if (voxel.type == VOXEL_TYPE_STONE)\n    {\n        vec4 voxelColor = vec4(STONE_COLOR, SATURATE(alpha01));\n        //voxelColor.rgb *= voxelColor.a;\n        //blendOver(fragColor, fragColor.rgb, voxelColor.rgb, fragColor.a, voxelColor.a);\n        fragColor = mix(fragColor, voxelColor, voxelColor.a);\n\n\n    }\n    else if (voxel.type == VOXEL_TYPE_REDSTONE_DUST)\n    {\n        drawRedstoneDust(fragColor, mPos, wCoord, alpha01, inverseScale);\n    }\n    else if (voxel.type == VOXEL_TYPE_REDSTONE_TORCH)\n    {\n        drawRedstoneTorch(fragColor, mPos, wCoord, alpha01, inverseScale);\n    } else if (voxel.type == VOXEL_TYPE_REDSTONE_LAMP) {\n        drawRedstoneLamp(fragColor, mPos, alpha01, inverseScale, float(voxel.energy > 0u));\n    }\n}\n\nfloat customLength(float x, float y)\n{\n    //return max(x,y);\n    return abs(x + y);\n}\n\nfloat AO_Falloff (in float x)\n{\n\treturn exp(-8.0 * (1.0-x));\n}\n\nvoid\npaintVoxelAO (inout vec4 color, in vec2 p, in ivec3 coord, in float alphaScale)\n{\n    float ao = 0.;\n    float t = MAX_SDF_DISTANCE;\n    \n    bool opaqueLeft, opaqueRight, opaqueBottom, opaqueTop;\n    opaqueLeft = opaqueRight = opaqueBottom = opaqueTop = false;\n    \n    if (isVoxelAtCoordOpaque(coord + ivec3(-1,0,0)))\n    {\n        opaqueLeft = true;\n        ao += AO_Falloff((1.-(p.x + 1.)*.25));\n    }\n    if (isVoxelAtCoordOpaque(coord + ivec3(1,0,0)))\n    {\n        opaqueRight = true;\n        ao += AO_Falloff(1.-(-(p.x - 1.)*.25));\n    }\n    if (isVoxelAtCoordOpaque(coord + ivec3(0,-1,0)))\n    {\n        opaqueBottom = true;\n        ao += AO_Falloff(1.-(p.y + 1.)*.25);\n    }\n    if (isVoxelAtCoordOpaque(coord + ivec3(0,1,0)))\n    {\n        opaqueTop = true;\n        ao += AO_Falloff(1.-(-(p.y - 1.)*.25));\n    }\n    \n    \n    if (isVoxelAtCoordOpaque(coord + ivec3(-1,-1,0)) && !(opaqueBottom || opaqueLeft))\n    {\n        float a = 1.-clamp(customLength(p.x + 1., p.y + 1.)*.25, 0., 1.);\n        ao += AO_Falloff(a);\n    }\n    if (isVoxelAtCoordOpaque(coord + ivec3(1,-1,0)) && !(opaqueBottom || opaqueRight))\n    {\n        float a = 1.-clamp((customLength(-p.x + 1., p.y + 1.)*.25), 0., 1.);\n        ao += AO_Falloff(a);\n    }\n    if (isVoxelAtCoordOpaque(coord + ivec3(-1,1,0)) && !(opaqueTop || opaqueLeft))\n    {\n        float a = 1.-clamp(customLength(p.x + 1., -p.y + 1.)*.25, 0., 1.);\n        ao += AO_Falloff(a);;\n    }\n    if (isVoxelAtCoordOpaque(coord + ivec3(1,1,0)) && !(opaqueTop || opaqueRight))\n    {\n        float a = 1.-clamp(customLength(-p.x + 1., -p.y + 1.)*.25, 0., 1.);\n        ao += AO_Falloff(a);\n    }\n    \n    vec4 voxelColor = vec4(0, 0, 0, alphaScale *  clamp(ao*.3, 0., 1.));\n    //voxelColor.rgb *= voxelColor.a;\n    //blendOver(fragColor, fragColor.rgb, voxelColor.rgb, fragColor.a, voxelColor.a);\n    color = mix(color, voxelColor, voxelColor.a * (1.0 - color.a));\n    ;//color.rgb *= (1. - clamp(ao*.3, 0., 1.) * alphaScale);\n    \n}\n\nvec3 toGrayscale(in vec3 col)\n{\n\tfloat x = (col.x + col.y + col.z) / 3.0;\n    return vec3(x);\n}\n\nvoid\npaintWorld ( inout vec4 fragColor, in vec2 wPos, in float inverseScale )\n{\n    vec2 mPos = fract(wPos) * 2. - 1.;\n \tinverseScale /= 2.;\n    \n    Voxel voxel;\n    ivec3 wCoord;\n    \n    uint selectedLayerIndex = uint(readVar(VARIABLE_LOCATION_LAYER_INDEX));\n    uint layersToLoop = max(selectedLayerIndex, MAX_VISIBLE_LAYERS);\n\n    for (uint i = 1u; i <= layersToLoop; ++i)\n    {\n       \tuint layerIndex = selectedLayerIndex - (layersToLoop - i);\n\t\twCoord = ivec3(ivec2(floor(wPos)), layerIndex);\n        \n        if (!isInsideWorldVirtual(getWorld(), wCoord)) continue;\n        \n        float layerDistance = 1. - float(i) / float(layersToLoop);\n        \n        voxel = readVoxel(wCoord);\n        \n        //if (voxel.type == VOXEL_TYPE_VOID) continue;\n\t\t\n        //float alphaScale = 1.;\n        //float alphaScale = (i == 0u) ? 1.\n        //    : exp(-7. * float(i + 1u) / float(MAX_VISIBLE_LAYERS) * GHOST_LAYER_ALPHA);\n\n        float alphaScale = exp(-1.9 * layerDistance);\n        \n        if (ENABLE_AMBIENT_OCCLUSION && voxel.type != VOXEL_TYPE_STONE)\n        {\n        \tpaintVoxelAO(fragColor, mPos, wCoord, alphaScale);\n        }\n        \n        paintVoxel(fragColor, mPos, wCoord, alphaScale, inverseScale);\n        \n        //if (i != selectedLayerIndex + 1u) tmpColor.rgb = mix(tmpColor.rgb, toGrayscale(tmpColor.rgb), 1.0);\n        \n        //blendOver(fragColor, fragColor.rgb, tmpColor.rgb, fragColor.a, tmpColor.a);\n        //fragColor = mix(fragColor, tmpColor, tmpColor.a);\n        \n    }\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0, 1.0, 1.0, 0.0);\n    initializeAPI(fragCoord);\n    \n    Camera cam = readCamera(VARIABLE_LOCATION_CAMERA);\n    \n    uvec2 sMouseCoord = uvec2(floor(iMouse.xy));\n    uvec2 sCoord = uvec2(floor(fragCoord));\n    \n    vec2 res = iResolution.xy, sPos = (2.*fragCoord - res) / res.y,\n         sMousePos = (2.*iMouse.xy - res) / res.y;\n    \n    mat3 MVP = getWorldToScreen( cam );\n    vec2 wPos = vec2(MVP * vec3(sPos, 1));\n    vec2 wMousePos = vec2(MVP * vec3(sMousePos, 1));\n\tuvec2 wCoord = uvec2(floor(wPos));\n    uvec2 wMouseCoord = uvec2(floor(wMousePos));\n    \n    float inverseScale = getScaleZ( cam ) * res.y;\n\n    paintWorld(fragColor, wPos, inverseScale);\n    \n    /*\n    {\n        vec2 wSize = vec2(getWorld().virtualDim.xy);\n    \tfloat t = sdBox(wPos - wSize*.5, wSize * .5);\n        float alpha = smoothstep(-.25, .25, t);\n        \n        fragColor.rgb *= 1. - .125 * alpha;\n    }\n    */\n    //fragColor = clamp(fragColor, 0.0, 1.0);\n    //paintGrid(fragColor, cam, wPos, .1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n\tShader Redstone 3 (c) by saidwho12\n\n    Shader Redstone 3 is licensed under a\n    Creative Commons Attribution 3.0 Unported License.\n\n    You should have received a copy of the license along with this\n    work.  If not, see <http://creativecommons.org/licenses/by/3.0/>.\n*/\n\n#define PI 3.14159\n#define PI_2 6.28318\n\n#define SATURATE(x) clamp(x,0.,1.)\n\n#define size_t uint\n\n// Comment if you fixed your browser\n#define DX9_FIX\n\n// Key code constants\nconst int KEY_BSP   = 8;\nconst int KEY_SHIFT_LEFT = 16;\nconst int KEY_CTRL_LEFT = 17;\nconst int KEY_SPACE    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\nconst int KEY_0     = 48;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_6     = 54;\nconst int KEY_7     = 55;\nconst int KEY_8     = 56;\nconst int KEY_9     = 57;\n\n#define AABB(T, N) struct { T x0[N], x1[N]; }\n\n// Key bindings\nconst int KEY_MOVE_MINUS_X     = KEY_A;\nconst int KEY_MOVE_PLUS_X      = KEY_D;\nconst int KEY_MOVE_MINUS_Y     = KEY_S;\nconst int KEY_MOVE_PLUS_Y      = KEY_W;\nconst int KEY_FAST_MOVE        = KEY_SHIFT_LEFT;\nconst int KEY_ZOOM_MINUS       = KEY_Q;\nconst int KEY_ZOOM_PLUS        = KEY_E;\nconst int KEY_SELECTOR_LEFT    = KEY_LEFT;\nconst int KEY_SELECTOR_RIGHT   = KEY_RIGHT;\nconst int KEY_LAYER_MINUS      = KEY_DOWN;\nconst int KEY_LAYER_PLUS       = KEY_UP;\nconst int KEY_PRIMARY_ACTION   = KEY_F;\nconst int KEY_SECONDARY_ACTION = KEY_R;\nconst int KEY_CHANGE_MODE      = KEY_M;\n\n// Shader constants for the game (Overrides GUI options if available && possible)\nconst uint  TICKS_PER_SECOND             = 20U;\nconst uint  MIN_TICKS_PER_SECOND         = 10U;\nconst uint  MAX_TICKS_PER_SECOND         = 60U;\nconst uint  MAX_FRAME_SKIP               = 10U;\nconst uint  MAX_VISIBLE_LAYERS           = 8U;\nconst float MAX_SDF_DISTANCE             = 1e3;\nconst uint  MAX_REDSTONE_POWER           = 16U;\nconst float GHOST_LAYER_ALPHA            = .91;\nconst uint  REDSTONE_PARTICLE_COUNT      = 16U;\nconst float REDSTONE_DUST_WIDTH          = .3;\nconst float REDSTONE_TORCH_RADIUS        = .4;\nconst float REDSTONE_TORCH_HANDLE_WIDTH  = .3;\nconst float CAMERA_MOTION_SPEED          = 5.;\nconst float CAMERA_ZOOM_SPEED            = .75;\nconst bool  ENABLE_AMBIENT_OCCLUSION     = false; // LOOKS SO UGLY!\nconst bool  ENABLE_VIGNETTE              = false;\nconst float ENERGY_BRIGHTNESS            = 1.0;\nconst float ITEM_BOX_HEIGHT              = 0.11; // 0 -> 2\nconst float ITEM_BOX_Y_PADDING           = 0.1; // 0 -> 1\nconst float DARK_ITEM_BOX_SIZE           = 0.812;\nconst bool  ENABLE_WORLD_GRID            = true;\nconst uint  WORDL_GRID_QUADRILLAGE_DEPTH = 1U;\n\n// Shader constants for UI rendering\nconst vec4  UI_BACKGROUND_COLOR       = vec4(1,1,1,.5);//vec3(0.68, 0.75, 0.74);\nconst vec4  UI_DEAD_COLOR             = vec4(0.7, 0.7, 0.7, 1.0);\nconst vec4  UI_HOT_COLOR              = vec4(0.9, 0.9, 0.9, 1.0);\nconst vec4  UI_ALIVE_COLOR            = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec2  UI_INFO_BOX_SCALE         = vec2(0.3, 0.18);\nconst bool  UI_ENABLE_RANDOM_ITEM_ROT = false;\nconst bool  UI_ENABLE_ITEM_ANIM       = true;\nconst bool  UI_ENABLE_BLUR = false;\nconst bool  UI_ENABLE_REDSTONE_PARTICLES = false;\nconst float UI_ALPHA = 0.8;\n\nconst vec3 WOOD_COLOR = vec3(.46,.375,.253);\nconst vec3 LAMP_COLOR = vec3(1.,.95,.745);\nconst vec3 STONE_COLOR = vec3(.715);//vec3(1,1,0);//vec3(0.84);//vec3(.35);\nconst vec3 REDSTONE_TORCH_HANDLE_COLOR = WOOD_COLOR;\nconst vec3 GRAY_STONE_COLOR = vec3(.415);\n\n#define POINTER int\n\n// Storage variable locations\nconst int VARIABLE_LOCATION_RESOLUTION = 0;\nconst int VARIABLE_LOCATION_CAMERA = 1;\nconst int VARIABLE_LOCATION_LAYER_INDEX = 2;\nconst int VARIABLE_LOCATION_MODE = 3;\n\nconst POINTER SELECTED_ITEM_INDEX_ADDR = 4;\n\n#define MODE_LOWEST_NONVOID_Z 0\n#define MODE_CURRENT_Z 1\n\n//const int editorModeLocation = 4;\n\n//const int sliderState04Ptr = 6;\n\nconst uint EDITOR_MODE_EDIT = 0U;\nconst uint EDITOR_MODE_ROTATE = 1U;\nconst uint EDITOR_MODE_COPY = 2U; // TODO: Actually implement\nconst uint EDITOR_MODE_COUNT = 3U;\nconst float GUI_TRANSLUCENCY = 0.75;\n\n#define PI 3.14159\n#define TAU (2.*PI)\n#define ONE_OVER_THREE .333333\n\nfloat logn (in float x, in float n) { return log(x * 10./n); }\nfloat cuberoot (in float x) { return pow(abs(x), ONE_OVER_THREE); }\n\n#define WIDGET_TYPE uint\n#define WIDGET_TYPE_LABEL        0U\n#define WIDGET_TYPE_BUTTON       1U\n#define WIDGET_TYPE_CHECKBOX     2U\n#define WIDGET_TYPE_SLIDER_FLOAT 3U\n#define WIDGET_TYPE_SLIDER_INT   4U\n\n// Widget base, this stays constant accross frames\nstruct Widget\n{\n    POINTER addr;\n    WIDGET_TYPE type;\n    vec2 pos;\n    vec2 scale;\n};\n    \nstruct Button\n{\n    Widget base;\n\tbool value;\n};\n    \nstruct Checkbox\n{\n\tWidget base;\n    bool value;\n};\n\nstruct Slider_Float\n{\n    Widget base;\n    float minValue;\n    float maxValue;\n    float value;\n};\n    \nstruct Slider_Int\n{\n    Widget base;\n    int minValue;\n    int maxValue;\n    int value;\n    int stepSize;\n};\n\nfloat UI_ButtonAO(in float t)\n{\n\treturn 1.0 - .7 * exp(-.5 * max(t,0.));\n}\n\nfloat Brightness(in vec3 c)\n{\n\treturn (c.r + c.g + c.b) / 3.0;\n}\n\nvec3 Contrast(in vec3 c)\n{\n    float alpha = Brightness(c);\n    alpha = SATURATE(alpha);\n    \n    float w = .5;\n    return vec3(smoothstep(w, -w, alpha - .5));//max((1. + pow(1. - 2. * alpha, 1. / (1. + 2. * n) )) / 2., 0.);\n}\n    \nButton BUTTON_ARRAY[] = Button[](\n    Button( Widget(0x5, WIDGET_TYPE_BUTTON, vec2(0), vec2(0)), false )\n);\n\nButton UI_CONFIG_BUTTON = Button( Widget(6, WIDGET_TYPE_BUTTON, vec2(0.1), vec2(0.045)), false);\n\n\nfloat sdBox (in vec2 p, in vec2 b)\n{\n\tvec2 d = abs(p) - b;\n \treturn length(max(d,0.0)) + min(max(d.x,d.y),0.0); \n}\n\n\nivec3\ngetMaxWorldDim (in ivec2 R)\n{\n    return ivec3(floor(cuberoot(float(R.x * R.y))));\n}\n\nstruct Camera\n{\n\tvec3 pos;\n};\n    \nmat3 translate (in vec2 x)\n{\n\treturn mat3(1,0,0,0,1,0,x,1);\n}\n\nmat2 rotate (in float x)\n{\n\tfloat c = cos(x), s = sin(x);\n    return mat2(c, s, -s, c);\n}\n\nfloat\ngetScaleZ (in Camera cam)\n{\n\treturn exp(-cam.pos.z);\n}\n\nmat3\ngetWorldToScreen (in Camera cam)\n{\n    float z_scale = getScaleZ(cam);\n    \n    mat3 m = /*mat3(rotate(radians(44.))) * */ translate(cam.pos.xy) * mat3(1./z_scale, 0, 0, 0, 1./z_scale, 0, 0, 0, 1);\n    \n    return m;\n}\n\nbool\nhitPointAABB (in ivec2 x0, in ivec2 x1, in ivec2 p)\n{\n\treturn all(greaterThanEqual(p, x0)) && all(lessThanEqual(p, x1));\n}\n\nbool\nhitPointAABB (in ivec3 x0, in ivec3 x1, in ivec3 p)\n{\n\treturn all(greaterThanEqual(p, x0)) && all(lessThanEqual(p, x1));\n}\n\nstruct Image_t\n{\n    int id;\n    ivec2 dim;\n};\n    \nstruct World_t\n{\n\tivec2 realPos;\n    ivec2 realDim;\n    ivec3 virtualDim;\n};\n\nivec2\ngetImageToWorldReal (in World_t world, in Image_t image, in ivec2 pos)\n{\n\tpos -= world.realPos;\n    int index = pos.y * image.dim.x + pos.x;\n    pos = ivec2(index % world.realDim.x, index / world.realDim.x);\n    return pos;\n}\n\nivec3\ngetImageToWorldVirtual (in World_t world, in Image_t image, in ivec2 pos)\n{\n\tpos -= world.realPos;\n    int index = pos.y * image.dim.x + pos.x;\n    \n    return ivec3(\n    index % world.virtualDim.x,\n    (index % (world.virtualDim.x * world.virtualDim.y)) / world.virtualDim.x,\n    index / (world.virtualDim.x * world.virtualDim.y));\n}\n\nivec2\ngetWorldRealToImage (in World_t world, in Image_t image, in ivec2 pos)\n{\n\tpos += world.realPos;\n    int index = pos.y * world.realDim.x + pos.x;\n    pos = ivec2(index % image.dim.x, index / image.dim.x);\n    return pos;\n}\n\nivec2\ngetWorldVirtualToImage (in World_t world, in Image_t image, in ivec3 pos)\n{\n    int i0 = (pos.y * world.virtualDim.x + pos.x)\n        + (world.virtualDim.x * world.virtualDim.y) * pos.z;\n    \n    int i1 = world.realPos.y * image.dim.x + world.realPos.x;\n    \n    int index = i0 + i1;\n    \n\treturn ivec2(index % image.dim.x, index / image.dim.x);\n}\n\nPOINTER\ngetWorldVirtualToAddr(in World_t world, in Image_t image, in ivec3 pos)\n{\n\tint i0 = (pos.y * world.virtualDim.x + pos.x)\n        + (world.virtualDim.x * world.virtualDim.y) * pos.z;\n    \n    int i1 = world.realPos.y * image.dim.x + world.realPos.x;\n    \n    return i0 + i1;\n}\n\nint\ngetWorldVirtualToIndex (in World_t world, in Image_t image, in ivec3 pos)\n{\n    return (pos.y * world.virtualDim.x + pos.x)\n        + (world.virtualDim.x * world.virtualDim.y) * pos.z;\n}\n\nbool isInsideWorldVirtual (in World_t world, in ivec2 pos)\n{\n    return hitPointAABB(ivec2(0), world.virtualDim.xy, pos);\n}\n\nbool isInsideWorldVirtual (in World_t world, in ivec3 pos)\n{\n    return hitPointAABB(ivec3(0), world.virtualDim, pos);\n}\n\nbool isInsideWorldReal (in World_t world, in ivec2 pos)\n{\n    return hitPointAABB(world.realPos, world.realPos + world.realDim, pos);\n}\n\n/*\n\nivec2 getCoordWorldToImage (in ivec3 worldCoord)\\\n{\\\n    int i = (p.y * getWorld().virtualDim.x + p.x)\\\n        + (getWorld().virtualDim.x * getWorld().virtualDim.y) * p.z;\\\n \t\\\n\tivec2 x0 = getWorld().realPos;\\\n    ivec2 x1 = ivec2(i / getWorld().realDim.x, i % getWorld().realDim.y);\\\n    \\\n    ivec2 x = x0 + x1;\\\n    return x;\\\n}\\\n*/\n\nconst uint VOXEL_TYPE_VOID              = 0x0U;\nconst uint VOXEL_TYPE_STONE             = 0x1U;\nconst uint VOXEL_TYPE_REDSTONE_DUST     = 0x2U;\nconst uint VOXEL_TYPE_REDSTONE_TORCH    = 0x4U;\nconst uint VOXEL_TYPE_LEVER             = 0x8U;\nconst uint VOXEL_TYPE_BUTTON            = 0x10U;\nconst uint VOXEL_TYPE_REDSTONE_REPEATER = 0x20U;\nconst uint VOXEL_TYPE_REDSTONE_LAMP     = 0x40U;\n\nconst uint VOXEL_TYPE_OPAQUE = VOXEL_TYPE_STONE | VOXEL_TYPE_REDSTONE_LAMP;\n\nconst uint VOXEL_TYPE_MONOCHROME =\n      VOXEL_TYPE_STONE\n    | VOXEL_TYPE_REDSTONE_DUST\n    | VOXEL_TYPE_REDSTONE_LAMP;\n\nconst uint VOXEL_TYPE_POLYCHROME =\n      VOXEL_TYPE_REDSTONE_TORCH\n    | VOXEL_TYPE_LEVER\n    | VOXEL_TYPE_BUTTON\n    | VOXEL_TYPE_REDSTONE_REPEATER\n    | VOXEL_TYPE_REDSTONE_LAMP;\n\nconst uint VOXEL_TYPE_FACING =\n      VOXEL_TYPE_REDSTONE_TORCH\n    | VOXEL_TYPE_LEVER\n    | VOXEL_TYPE_REDSTONE_REPEATER;\n\nconst uint VOXEL_FACING_NOWHERE = 0U;\nconst uint VOXEL_FACING_MINUS_X = 1U;\nconst uint VOXEL_FACING_PLUS_X  = 2U;\nconst uint VOXEL_FACING_MINUS_Y = 3U;\nconst uint VOXEL_FACING_PLUS_Y  = 4U;\nconst uint VOXEL_FACING_PLUS_Z  = 5U;\n\nbool isRedstoneTorchFacing (in uint x)\n{\n\treturn x == VOXEL_FACING_MINUS_X\n        || x == VOXEL_FACING_PLUS_X\n        || x == VOXEL_FACING_MINUS_Y\n        || x == VOXEL_FACING_PLUS_Y\n        || x == VOXEL_FACING_PLUS_Z;\n}\n\nstruct Voxel\n{\n    uint type;\n    uint energy; // 0;16\n    uint facing; // variation in placement orientation\n};\n\nbool isVoxelFacing (in Voxel voxel)\n{\n\treturn voxel.facing > 0U;\n}\n\n    \nVoxel readVoxel (in ivec3 coord);\n\nbool\ncheckFlag (uint x, uint y) { return (x & y) > 0U; }\n\nbool isVoxelOpaque (in Voxel voxel)\n{\n\treturn checkFlag(voxel.type, VOXEL_TYPE_OPAQUE);\n}\n\nuint getNextVoxelFacing (in Voxel voxel)\n{\n    if (voxel.type == VOXEL_TYPE_REDSTONE_TORCH)\n\t\treturn (voxel.facing + 1U) % 5U + 1U;\n}\n\nuint getDefaultVoxelEnergy (in uint type)\n{\n    if (type == VOXEL_TYPE_REDSTONE_TORCH) return MAX_REDSTONE_POWER;\n    else return 0U;\n}\n\nVoxel getDefaultVoxel (in uint type)\n{\n\tVoxel voxel;\n\n    voxel.type = type;\n    \n    voxel.energy = getDefaultVoxelEnergy(type);\n    voxel.facing = checkFlag(type, VOXEL_TYPE_FACING) ? VOXEL_FACING_PLUS_Z\n        : VOXEL_FACING_NOWHERE;\n    \n    return voxel;\n}\n\nVoxel getDefaultMenuVoxel (in uint type)\n{\n\tVoxel voxel;\n    \n    voxel.type = type;\n    \n    if (type == VOXEL_TYPE_REDSTONE_TORCH) voxel.energy = MAX_REDSTONE_POWER;\n    else voxel.energy = 0u;\n    \n    voxel.facing = checkFlag(type, VOXEL_TYPE_FACING) ? VOXEL_FACING_PLUS_Z\n        : VOXEL_FACING_NOWHERE;\n    \n    return voxel;\n}\n\nvec3 getEnergyColor (in float iEnergy01)\n{\n    //return vec3(iEnergy01 > 0.0, 0, 0);\n    return vec3(.1 + .9 * SATURATE(iEnergy01), 0, 0);\n\t//return vec3(/*.15 + .85 * SATURATE(iEnergy01)*/ iEnergy01 == 0.0 ? 0.15 : 1.0, 0, 0);\n}\n\nvec3 getEnergyColor (in uint energy)\n{\n\tenergy = min(energy, MAX_REDSTONE_POWER);\n    return getEnergyColor(float(energy) / float(MAX_REDSTONE_POWER));\n}\n\nconst uint ITEM_TYPE_ARRAY[] = uint[](\n    VOXEL_TYPE_STONE,\n    VOXEL_TYPE_REDSTONE_DUST,\n    VOXEL_TYPE_REDSTONE_TORCH,\n    VOXEL_TYPE_LEVER,\n    VOXEL_TYPE_BUTTON,\n    VOXEL_TYPE_REDSTONE_REPEATER,\n    VOXEL_TYPE_REDSTONE_LAMP\n);\n\nconst int ITEM_TYPE_COUNT = ITEM_TYPE_ARRAY.length();\n\nvec4\ndrawVoxelTypeIcon (in vec2 pos, in float invScale, in uint type)\n{\n    vec4 color;\n\tif (type == VOXEL_TYPE_STONE)\n    {\n        color = vec4(STONE_COLOR, 1);\n    }\n    else if (type == VOXEL_TYPE_REDSTONE_DUST)\n    {\n        float t = min(abs(pos.x), abs(pos.y)) - REDSTONE_DUST_WIDTH * .5;\n        color.rgb = getEnergyColor(0U);\n        color.a = smoothstep(3., 0., t * invScale);\n    }\n    else if (type == VOXEL_TYPE_REDSTONE_TORCH)\n    {\n        color.rgb = getEnergyColor(MAX_REDSTONE_POWER);\n        float t = length(pos) - REDSTONE_TORCH_RADIUS;\n        color.a = smoothstep(3., 0., t * invScale);\n    } else if (type == VOXEL_TYPE_LEVER) {\n        vec3 energyCol = getEnergyColor(0u);\n        \n        // base\n        float t1 = sdBox(pos,vec2(.45,.72));\n        float a1 = smoothstep(3., 0., t1 * invScale);\n        \n        // hole\n        float t2 = sdBox(pos,vec2(.2,.47));\n        float a2 = smoothstep(3., 0., t2 * invScale);\n        \n        // lever\n        float t3 = sdBox(pos-vec2(0,-.41),vec2(.2));\n        float a3 = smoothstep(3., 0., t3 * invScale);\n        \n        color = vec4(0,0,0,0);\n        color.rgb = STONE_COLOR;\n        color.a = a1;\n        color = mix(color,vec4(energyCol,1.),a2);\n        color = mix(color,vec4(WOOD_COLOR,1.),a3);\n    } else if (type == VOXEL_TYPE_REDSTONE_LAMP) {\n        const float W = .13;\n        float t1 = -sdBox(pos,vec2(1))-W/2.;\n        float t2 = min(abs(pos.x),abs(pos.y));\n        float t3 = length(vec2(abs(pos.x), abs(pos.y)))-.5;\n        float tt = min(min(t1,t2),t3);\n        float alpha = smoothstep(1.5, -1.5, (abs(tt)-W) * invScale );\n        color.a = 1.;\n        color.rgb = mix(LAMP_COLOR,WOOD_COLOR,alpha);\n    }\n    \n    return color;\n}\n\n#define DEFINE_DEFAULT_API( CHANNEL, CHANNEL_ID ) \\\nImage_t globalImage;\\\nWorld_t globalWorld;\\\nvec2 globalCoord;\\\nvec4 globalPixel;\\\nvoid \\\ninitializeAPI (in vec2 fragCoord)\\\n{\\\n    globalPixel = vec4(0);\\\n    globalCoord = fragCoord;\\\n    globalImage.id = CHANNEL_ID;\\\n    globalImage.dim = ivec2(floor(iChannelResolution[CHANNEL_ID]));\\\n    globalWorld.realPos = ivec2(0, 1);\\\n    globalWorld.realDim = globalImage.dim - ivec2(0, 1);\\\n    globalWorld.virtualDim = getMaxWorldDim(globalWorld.realDim);\\\n}\\\nvec4 \\\nterminate (void) { return globalPixel; }\\\nvec4 \\\nreadVar (in int x)\\\n{\\\n    return texelFetch(CHANNEL, ivec2(x,0), 0);\\\n}\\\nvoid \\\nwriteVar (in int x, in vec4 var)\\\n{\\\n    ivec2 coord = ivec2(floor(globalCoord));\\\n    if (all(equal(coord, ivec2(x,0)))) globalPixel = var;\\\n}\\\nvoid \\\nwriteVar (in int x, in vec3 var)\\\n{\\\n    ivec2 coord = ivec2(floor(globalCoord));\\\n    if (all(equal(coord, ivec2(x,0)))) globalPixel = vec4(var, 0);\\\n}\\\nvoid \\\nwriteVar (in int x, in vec2 var)\\\n{\\\n    ivec2 coord = ivec2(floor(globalCoord));\\\n    if (all(equal(coord, ivec2(x,0)))) globalPixel = vec4(var, 0, 0);\\\n}\\\nvoid \\\nwriteVar (in int x, in float var)\\\n{\\\n    ivec2 coord = ivec2(floor(globalCoord));\\\n    if (all(equal(coord, ivec2(x,0)))) globalPixel = vec4(var, 0, 0, 0);\\\n}\\\nvoid \\\nwriteCamera (in int x, in Camera cam)\\\n{\\\n    writeVar(x, cam.pos);\\\n}\\\nCamera \\\nreadCamera (in int x)\\\n{\\\n\tvec4 var;\\\n    Camera cam;\\\n    var = readVar(x);\\\n    cam.pos = var.xyz;\\\n    return cam;\\\n}\\\nImage_t getImage (void) { return globalImage; } \\\nWorld_t getWorld (void) { return globalWorld; } \\\nivec3 getWorldVirtual (void) { return getImageToWorldVirtual(getWorld(), getImage(), ivec2(floor(globalCoord))); }\\\nbool isCurrentWorldPos (in ivec3 pos) { return all(equal(getWorldVirtual(), pos)); }\\\nVoxel \\\nreadVoxel (in ivec3 pos)\\\n{\\\n    Voxel dst;\\\n    vec4 data = texelFetch(CHANNEL, getWorldVirtualToImage(getWorld(), getImage(), pos), 0);\\\n    dst = Voxel(uint(data.x), uint(data.y), uint(data.z));\\\n    return dst;\\\n}\\\nbool isVoxelAtCoordOpaque (in ivec3 p)\\\n{\\\n\treturn checkFlag(readVoxel(p).type, VOXEL_TYPE_OPAQUE);\\\n}\\\nbool isVoxelAtCoordDustConnectable (in ivec3 coord, out int zOffset, bool isVoxelAboveOpaque)\\\n{\\\n    Voxel voxels[3] = Voxel[3](\\\n        readVoxel(coord + ivec3(0,0,-1)),\\\n        readVoxel(coord),\\\n        readVoxel(coord + ivec3(0,0,1))\\\n    );\\\n    \\\n    bool isConnectable = ((voxels[0].type == VOXEL_TYPE_REDSTONE_DUST && voxels[1].type != VOXEL_TYPE_STONE\\\n        || voxels[1].type == VOXEL_TYPE_REDSTONE_DUST\\\n        || voxels[2].type == VOXEL_TYPE_REDSTONE_DUST)\\\n        && !isVoxelAboveOpaque)\\\n        || voxels[1].type == VOXEL_TYPE_REDSTONE_TORCH\\\n        || voxels[1].type == VOXEL_TYPE_LEVER;\\\n    \\\n    if (voxels[0].type == VOXEL_TYPE_REDSTONE_DUST && !isVoxelAboveOpaque)\\\n    {\\\n    \tzOffset = -1;\\\n    }\\\n    \\\n    if (voxels[1].type == VOXEL_TYPE_REDSTONE_DUST && !isVoxelAboveOpaque)\\\n    {\\\n    \tzOffset = 0;\\\n    }\\\n    \\\n    if (voxels[2].type == VOXEL_TYPE_REDSTONE_DUST && !isVoxelAboveOpaque)\\\n    {\\\n    \tzOffset = 1;\\\n    }\\\n    \\\n    return isConnectable;\\\n}\\\nvoid \\\nwriteVoxel (in Voxel voxel)\\\n{\\\n    globalPixel = vec4(voxel.type, voxel.energy, voxel.facing, 0);\\\n}\n\n\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins. May 2018\n\n\n// Almost a direct copy of most of \"Simplest Fastest 2D Hash\" with additional hash types.\n// https://www.shadertoy.com/view/MdcfDj\n\n// For use in WebGL 2 shaders.\n// The float versions should still be in integer steps, but they can be negetive.\n\n\n// The defines don't need to change for scaling purposes,\n// but I'll keep them in for any future needs.\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n// The labeling refers to the number of values - hash(out)(in)...\n//---------------------------------------------------------------------------------------------------------------\nfloat hash11(uint q)\n{\n\tuvec2 n = q * UI2;\n\tq = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\nfloat hash11(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tuint q = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nfloat hash12(uvec2 q)\n{\n\tq *= UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nfloat hash13(uvec3 q)\n{\n\tq *= UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash13(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq *= UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec2 hash21(uint q)\n{\n\tuvec2 n = q * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n\nvec2 hash21(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec2 hash22(uvec2 q)\n{\n\tq *= UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec2 hash23(uvec3 q)\n{\n\tq *= UI3;\n\tuvec2 n = (q.x ^ q.y ^ q.z) * UI2;\n\treturn vec2(n) * UIF;\n}\n\nvec2 hash23(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuvec2 n = (q.x ^ q.y ^ q.z) * UI2;\n\n\treturn vec2(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash31(uint q)\n{\n\tuvec3 n = q * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\nvec3 hash31(float p)\n{\n\n\tuvec3 n = uint(int(p)) * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash32(uvec2 q)\n{\n\tuvec3 n = q.xyx * UI3;\n\tn = (n.x ^ n.y ^n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\nvec3 hash32(vec2 q)\n{\n\tuvec3 n = uvec3(ivec3(q.xyx)) * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash33(uvec3 q)\n{\n\tq *= UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}