{
    "Shader": {
        "info": {
            "date": "1610337756",
            "description": "Experimenting with fog. Mouse to rotate and arrow keys to move.",
            "flags": 48,
            "hasliked": 0,
            "id": "WtKyzR",
            "likes": 3,
            "name": "Foggy Valley - Fog Experiment",
            "published": 3,
            "tags": [
                "raymarching",
                "terrain",
                "fog",
                "fractalnoise"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 229
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    vec4 bl = texelFetch(iChannel0, iFragCoord, 0);\n    vec4 br = texelFetch(iChannel0, iFragCoord + ivec2(1, 0), 0);\n    vec4 tl = texelFetch(iChannel0, iFragCoord + ivec2(0, 1), 0);\n    vec4 tr = texelFetch(iChannel0, iFragCoord + 1, 0);\n    fragColor = (bl + br + tl + tr) * 0.25;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Math constants:\nconst float TWO_PI = 6.2832;\n\n// Amount by which the camera moves and rotates:\nconst float STEP_SIZE      = 0.05;\nconst float ROTATION_SPEED = 1.0;\n\n// Addresses to viewing data:\nconst ivec2 VIEW_POS = ivec2(0, 0);\nconst ivec2 VIEW_DIR = ivec2(1, 0);\n\n// Key codes from iq's keyboard input demo (https://www.shadertoy.com/view/lsXGzf):\nconst int    KEY_UP = 38;\nconst int  KEY_DOWN = 40;\nconst int KEY_RIGHT = 39;\nconst int  KEY_LEFT = 37;\n\n#define fetch(buf, addr) texelFetch(buf, addr, 0).xyz\n\n// Calculates camera axes:\nmat3 getCamera(in vec2 viewDirection) {\n    vec2 c = cos(viewDirection); vec2 s = sin(viewDirection);\n    return mat3(vec3(       c.x, 0.0,         s.x),  // Camera right axis (x)\n                vec3(s.x * -s.y, c.y, -c.x * -s.y),  // Camera up axis (y)\n                vec3(s.x *  c.y, s.y, -c.x *  c.y)); // Camera forward axis (z)\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(-1.5, 0.0, -50.0, 1.0);\n    if (iFrame > 0) {\n        ivec2 address = ivec2(fragCoord);\n        if (address == VIEW_POS) {\n            fragColor = vec4(fetch(iChannel0, VIEW_POS), 1.0);\n            mat3 camera = getCamera(fetch(iChannel0, VIEW_DIR).xy);\n \n            if (bool(fetch(iChannel1, ivec2(KEY_UP, 0)).x)) {\n                fragColor.xz += camera[2].xz * STEP_SIZE;\n            }\n\n            if (bool(fetch(iChannel1, ivec2(KEY_DOWN, 0)).x)) {\n                fragColor.xz -= camera[2].xz * STEP_SIZE;\n            }\n\n            if (bool(fetch(iChannel1, ivec2(KEY_RIGHT, 0)).x)) {\n                fragColor.xz += camera[0].xz * STEP_SIZE;\n            }\n\n            if (bool(fetch(iChannel1, ivec2(KEY_LEFT, 0)).x)) {\n                fragColor.xz -= camera[0].xz * STEP_SIZE;\n            }\n        }\n\n        if (address == VIEW_DIR) {\n            float viewDirection = fetch(iChannel0, VIEW_DIR).x;\n            if (iMouse.z > 0.0) {\n                viewDirection = (iMouse.x - 0.5 * iResolution.x) / iResolution.x * TWO_PI * ROTATION_SPEED;\n            }\n\n            fragColor = vec4(viewDirection, 0.0, 0.0, 1.0);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Hash from \"Hash without Sine\" by Dav_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat noise(in vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat snoise(in vec2 p) {\n    vec2 cell = floor(p);\n    vec2 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float bl = noise(cell);\n    float br = noise(cell + vec2(1.0, 0.0));\n    float tl = noise(cell + vec2(0.0, 1.0));\n    float tr = noise(cell + 1.0);\n\n    return mix(mix(bl, br, local.x), mix(tl, tr, local.x), local.y);\n}\n\nfloat fnoise(in vec2 p, in float scale, in float octaves) {\n    p *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += snoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nfloat mapScene(in vec3 p) {\n    return p.y - fnoise(p.xz, 1.0, 10.0);\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\n// Based on Inigo Quilez's fog article (https://iquilezles.org/articles/fog):\nvoid applyFog(inout vec3 color, in vec3 rayOri, in vec3 rayDir, in vec3 sunDir, in float dist) {\n    float b = 2.5;\n    float sunAmount = max(0.0, dot(rayDir, sunDir));\n    vec3 fogColor = mix(vec3(0.5, 0.6, 0.7), vec3(1.0, 0.9, 0.7), pow(sunAmount, 2.0));\n    float fogAmount = 1.0 - exp(-dist * b);\n    color = mix(color, fogColor, fogAmount);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = fetch(iChannel0, VIEW_POS);\n    mat3 camera = getCamera(fetch(iChannel0, VIEW_DIR).xy);\n    vec3 rd = normalize(camera[2] + uv.x * camera[0] + uv.y * camera[1]);\n    ro.y += 0.1 + fnoise(ro.xz, 1.0, 3.0);\n\n    vec3 l = vec3(-0.58, 0.58, 0.58);\n\n    float t = 0.0;\n    for (int iter=0; iter < 100; iter++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001 * (t + 1.0)) { // Accelerated raymarching technique from jarble\n            vec3 n = getNormal(p);\n            vec3 material = mix(vec3(0.0, 1.0, 0.0), vec3(0.6, 0.4, 0.0), 1.25 * p.y);\n            fragColor.rgb += material * max(0.0, dot(n, l)) * 2.0;\n            break;\n        }\n\n        if (t > 30.0) {\n            break;\n        }\n\n        t += d;\n    }\n\n    applyFog(fragColor.rgb, ro, rd, l, t);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}