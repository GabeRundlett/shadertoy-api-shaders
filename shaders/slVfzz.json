{
    "Shader": {
        "info": {
            "date": "1663964715",
            "description": "This shader uses interval arithmetic to draw parametric surfaces. Keyboard/mouse controls listed in Buffer A.",
            "flags": 48,
            "hasliked": 0,
            "id": "slVfzz",
            "likes": 27,
            "name": "Parametric Surface Renderer",
            "published": 3,
            "tags": [
                "3d",
                "interactive",
                "plotter",
                "arithmetic",
                "interval"
            ],
            "usePreview": 0,
            "username": "fad",
            "viewed": 667
        },
        "renderpass": [
            {
                "code": "//------------------------Parametric Surface Renderer-------------------------//\n\n// How It Works:\n// This shader raytraces parametric surfaces by recursively subdividing the u-v\n// domain of the surface, using interval arithmetic to calculate bounding boxes\n// for the subdivisions of the surface to test for the possible presence of ray\n// intersections.\n\n// Drawing Domain:\nconst float uMin = 0.0;\nconst float uMax = 2.0 * PI;\nconst float vMin = 0.0;\nconst float vMax = 2.0 * PI;\n\n// Parametric Surface Equation:\n// This function uses interval types (defined in the Common tab).\niVec3 f(iFloat u, iFloat v) {\n    iFloat cosU = iCos(u);\n    iFloat sinU = iSin(u);\n    iFloat cosV = iCos(v);\n    iFloat sinV = iSin(v);\n    \n    // Trefoil Knot\n    // https://commons.wikimedia.org/wiki/File:Parametric_surface_illustration_(trefoil_knot).png\n    float r = 1.5;\n    iFloat a = iAdd(2.0, iCos(iAdd(v, PI * 2.0 / 3.0)));\n    iFloat u2 = iMul(2.0, u);\n    return iVec3(\n        iDiv(iMul(r, iSin(iMul(3.0, u))), iAdd(2.0, cosV)),\n        iDiv(iMul(r, iAdd(sinU, iMul(2.0, iSin(u2)))), a),\n        iMul(iMul(iMul(r / 8.0, iSub(cosU, iMul(2.0, iCos(u2)))), iAdd(2.0, cosV)), a)\n    );\n    \n    // Klein Bottle\n    // https://www.shadertoy.com/view/XttSW8\n    //iFloat r = iSub(2.0, cosU);\n    //return iVec3(\n    //    iMul(0.6, iAdd(iMul(iMul(2.0, iSub(1.0, sinU)), cosU), iMul(iMul(r, cosV), iSub(iMul(2.0, iExp(iNeg(iPow(iSub(iDiv(u, 2.0), PI), 2.0)))), 1.0)))),\n    //    iMul(0.6, iAdd(iMul(6.0, sinU), iMul(iMul(iMul(iMul(0.5, r), sinU), cosV), iExp(iNeg(iPow(iSub(u, 1.5 * PI), 2.0)))))),\n    //    iMul(0.6, iMul(r, sinV))\n    //);\n\n    // Torus\n    //return iVec3(\n    //    iMul(iAdd(2.0, cosU), cosV),\n    //    sinU,\n    //    iMul(iAdd(2.0, cosU), sinV)\n    //);\n    \n    // Sphere\n    //return iVec3(\n    //    iMul(3.0, iMul(sinU, cosV)),\n    //    iMul(3.0, iMul(sinU, sinV)),\n    //    iMul(3.0, cosU)\n    //);\n}\n\n// Resolution:\n// The amount of times to recursively subdivide the u-v domain. \nconst int maxDepth = 16;\n\n// Discontinuity Tolerance:\n// If the bounding box for a leaf surface patch has a side length bigger than or\n// equal to discontinuityTolerance, that surface patch is counted as containing\n// a discontinuity and is not counted as an intersection. It can be set to\n// INFINITY if the surface is known to be continous.\nconst float discontinuityTolerance = 1000.0 * max(vMax - vMin, uMax - uMin) / pow(2.0, float(maxDepth - 1));\n\n// Display Settings:\nconst float fovY = 50.0;\n#define VIGNETTE 1\n#define USE_CUBEMAP_BACKGROUND_FOR_PBR 1\n\n// Rendering Mode:\n#define REGULAR 1\n#define PBR 2\n#define NORMAL_MAP 3\n\n#define RENDERING_MODE PBR\n\n\n\n//============================================================================//\n\n\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n\niFloat intersect(Ray r, iVec3 a) {\n    // Basically a ray-AABB intersection test but returns both the min and max\n    // intersection t-values.\n    vec3  t0 = (vec3(a.x.l, a.y.l, a.z.l) - r.o) / r.d;\n    vec3  t1 = (vec3(a.x.u, a.y.u, a.z.u) - r.o) / r.d;\n    float t;\n    \n    if (t0.x > t1.x) {\n        t    = t0.x;\n        t0.x = t1.x;\n        t1.x = t;\n    }\n    \n    if (t0.y > t1.y) {\n        t    = t0.y;\n        t0.y = t1.y;\n        t1.y = t;\n    }\n    \n    if (t0.z > t1.z) {\n        t    = t0.z;\n        t0.z = t1.z;\n        t1.z = t;\n    }\n    \n    float h0 = max(t0.x, max(t0.y, t0.z));\n    float h1 = min(t1.x, min(t1.y, t1.z));\n    \n    if (h0 > h1) {\n        return EMPTY_SET;\n    }\n    \n    return iFloat(h0, h1);\n}\n\n// Main Intersection Function:\n// Performs a depth-first search of the u-v domain treating it as a quadtree,\n// keeping track of the closest intersection found so far and only descending\n// the quadtree if it possibly contains a closer intersection. Every time a leaf\n// patch is reached and there might be an intersection within it, it is counted\n// as an intersection.\nbool intersect(Ray r, out float t, out float u, out float v) {\n    if (maxDepth < 1) {\n        return false;\n    }\n    \n    float uRange = uMax - uMin;\n    float vRange = vMax - vMin;\n    int depth = 0;\n    int uPos = 0;\n    int vPos = 0;\n    t = INFINITY;\n    \n    while (true) {\n        // Calculate the current u-v domain at this location in the quadtree\n        float size = float(1 << depth);\n        iFloat ui = iFloat(uMin + uRange * float(uPos) / size, uMin + uRange * float(uPos + 1) / size);\n        iFloat vi = iFloat(vMin + vRange * float(vPos) / size, vMin + vRange * float(vPos + 1) / size);\n        // Calculate a bounding box for the surface patch\n        iVec3 fi = f(ui, vi);\n        // Intersect the bounding box\n        iFloat ti = intersect(r, fi);\n        \n        // If the ray has intersected the bounding box and currently at a leaf\n        // patch which doesn't contain a discontinuity, check if this\n        // intersection value is closer than the current best intersection and\n        // update it if so.\n        if (depth == maxDepth - 1 && 0.0 < ti.l && ti.u < t\n            && fi.x.u - fi.x.l < discontinuityTolerance\n            && fi.y.u - fi.y.l < discontinuityTolerance\n            && fi.z.u - fi.z.l < discontinuityTolerance) {\n            t = ti.u;\n            u = (ui.l + ui.u) / 2.0;\n            v = (vi.l + vi.u) / 2.0;\n        }\n        \n        // If the ray didn't intersect the patch or currently at a leaf patch,\n        // don't descend the quadtree any further, instead go to the next patch \n        // in the depth-first search and continue on to the next iteration.\n        if (ti.u <= 0.0 || t <= ti.l || depth == maxDepth - 1) {\n            while (uPos % 2 == 1 && vPos % 2 == 1) {\n                --depth;\n                uPos /= 2;\n                vPos /= 2;\n            }\n            \n            if (vPos % 2 == 0) {\n                ++vPos;\n            } else {\n                ++uPos;\n                --vPos;\n            }\n            \n            // Exit the loop if back at root node\n            if (depth == 0 && vPos == 1) {\n                break;\n            }\n            \n            continue;\n        }\n\n        // There is a potential intersection in this surface patch, so descend\n        // and check its children for intersections.\n        ++depth;\n        uPos *= 2;\n        vPos *= 2;\n    }\n    \n    return t != INFINITY;\n}\n\nvec3 normal(float u, float v) {\n    const float e = 1e-3;\n    iVec3 fup = f(ifloat(u + e), ifloat(v));\n    iVec3 fun = f(ifloat(u - e), ifloat(v));\n    iVec3 fvp = f(ifloat(u), ifloat(v + e));\n    iVec3 fvn = f(ifloat(u), ifloat(v - e));\n    \n    return normalize(cross(\n        vec3(fup.x.l - fun.x.l, fup.y.l - fun.y.l, fup.z.l - fun.z.l),\n        vec3(fvp.x.l - fvn.x.l, fvp.y.l - fvn.y.l, fvp.z.l - fvn.z.l)\n    ));\n}\n\nvec3 normal(Ray r, float u, float v) {\n    vec3 n = normal(u, v);\n    return faceforward(n, r.d, n);\n    return n;\n}\n\n\n\n//============================================================================//\n\n// Start of modified PBR code from https://www.shadertoy.com/view/XsfXWX\n\nfloat somestep(float t) {\n    return pow(t,4.0);\n}\n\nvec3 textureAVG(samplerCube tex, vec3 tc) {\n    const float diff0 = 0.35;\n    const float diff1 = 0.12;\n \tvec3 s0 = texture(tex,tc).xyz;\n    vec3 s1 = texture(tex,tc+vec3(diff0)).xyz;\n    vec3 s2 = texture(tex,tc+vec3(-diff0)).xyz;\n    vec3 s3 = texture(tex,tc+vec3(-diff0,diff0,-diff0)).xyz;\n    vec3 s4 = texture(tex,tc+vec3(diff0,-diff0,diff0)).xyz;\n    \n    vec3 s5 = texture(tex,tc+vec3(diff1)).xyz;\n    vec3 s6 = texture(tex,tc+vec3(-diff1)).xyz;\n    vec3 s7 = texture(tex,tc+vec3(-diff1,diff1,-diff1)).xyz;\n    vec3 s8 = texture(tex,tc+vec3(diff1,-diff1,diff1)).xyz;\n    \n    return (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8) * 0.111111111;\n}\n\nvec3 textureBlured(samplerCube tex, vec3 tc) {\n   \tvec3 r = textureAVG(tex,vec3(1.0,0.0,0.0));\n    vec3 t = textureAVG(tex,vec3(0.0,1.0,0.0));\n    vec3 f = textureAVG(tex,vec3(0.0,0.0,1.0));\n    vec3 l = textureAVG(tex,vec3(-1.0,0.0,0.0));\n    vec3 b = textureAVG(tex,vec3(0.0,-1.0,0.0));\n    vec3 a = textureAVG(tex,vec3(0.0,0.0,-1.0));\n        \n    float kr = dot(tc,vec3(1.0,0.0,0.0)) * 0.5 + 0.5; \n    float kt = dot(tc,vec3(0.0,1.0,0.0)) * 0.5 + 0.5;\n    float kf = dot(tc,vec3(0.0,0.0,1.0)) * 0.5 + 0.5;\n    float kl = 1.0 - kr;\n    float kb = 1.0 - kt;\n    float ka = 1.0 - kf;\n    \n    kr = somestep(kr);\n    kt = somestep(kt);\n    kf = somestep(kf);\n    kl = somestep(kl);\n    kb = somestep(kb);\n    ka = somestep(ka);    \n    \n    float d;\n    vec3 ret;\n    ret  = f * kf; d  = kf;\n    ret += a * ka; d += ka;\n    ret += l * kl; d += kl;\n    ret += r * kr; d += kr;\n    ret += t * kt; d += kt;\n    ret += b * kb; d += kb;\n    \n    return ret / d;\n}\n\n// GGX code from https://www.shadertoy.com/view/MlB3DV\nfloat G1V ( float dotNV, float k ) {\n\treturn 1.0 / (dotNV*(1.0 - k) + k);\n}\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n    \tfloat alpha = roughness*roughness;\n\tvec3 H = normalize (V + L);\n\n\tfloat dotNL = clamp (dot (N, L), 0.0, 1.0);\n\tfloat dotNV = clamp (dot (N, V), 0.0, 1.0);\n\tfloat dotNH = clamp (dot (N, H), 0.0, 1.0);\n\tfloat dotLH = clamp (dot (L, H), 0.0, 1.0);\n\n\tfloat D, vis;\n\tfloat F;\n\n\t// NDF : GGX\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.1415926535;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr / (pi * denom * denom);\n\n\t// Fresnel (Schlick)\n\tfloat dotLH5 = pow (1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\t// Visibility term (G) : Smith with Schlick's approximation\n\tfloat k = alpha / 2.0;\n\tvis = G1V (dotNL, k) * G1V (dotNV, k);\n\n\treturn /*dotNL */ D * F * vis;\n}\n\nvec3 shade(vec3 ray, vec3 normal, vec3 materialColor) {\n    // material\n    float metallic = 0.07;\n    float roughness = 0.1;\n    float fresnel_pow = mix(5.0, 3.5,metallic);\n    vec3 color_mod = vec3(1.0);\n    vec3 light_color = pow(texture(iChannel1,vec3(1.0,0.0,0.0)).xyz * 1.2, vec3(2.2));\n\n\n    // IBL\n    vec3 ibl_diffuse = pow(textureBlured(iChannel1,normal), vec3(2.2));\n    vec3 ibl_reflection = pow(textureBlured(iChannel1,reflect(ray,normal)), vec3(2.2));\n\n    // fresnel\n    float fresnel = max(1.0 - dot(normal,-ray), 0.0);\n    fresnel = pow(fresnel,fresnel_pow);    \n\n    // reflection        \n    vec3 refl = pow(texture(iChannel1,reflect(ray,normal)).xyz, vec3(2.2));\n    refl = mix(refl,ibl_reflection,(1.0-fresnel)*roughness);\n    refl = mix(refl,ibl_reflection,roughness);\n\n    // specular\n    vec3 light = normalize(vec3(-0.5,1.0,0.0));\n    float power = 1.0 / max(roughness * 0.4,0.01);\n    vec3 spec = light_color * GGX(normal,-ray,light,roughness*0.7, 0.2);\n    refl -= spec;\n\n    // diffuse\n    vec3 diff = ibl_diffuse * pow(materialColor, vec3(2.2));\n    diff = mix(diff * color_mod,refl,fresnel);        \n\n    vec3 color = mix(diff,refl * color_mod,metallic) + spec;\n    return pow(color, vec3(1.0/2.2));\n}\n\n// End of modified PBR code from https://www.shadertoy.com/view/XsfXWX\n\n//============================================================================//\n\n\n\nvec3 saturate(vec3 color, float amount) {\n    vec3 gray = vec3(dot(vec3(0.2126,0.7152,0.0722), color));\n    return clamp(mix(gray, color, 1.0 + amount), vec3(0.0), vec3(1.0));\n}\n\nvec3 calculateColor(Ray r) {\n    float t, u, v;\n    \n    if (intersect(r, t, u, v)) {\n        vec3 n = normal(r, u, v);\n        \n#if RENDERING_MODE == REGULAR\n        vec3 lv = normalize(vec3(-1.0, 2.0, -3.0));\n        float ld = dot(lv, n);\n        float l = mix(max(ld, 0.0), mix(0.02, 1.0, ld * 0.5 + 0.5), 0.1);\n        vec3 c = vec3(1.0);\n        return pow(c * l, vec3(1.0 / 2.2));\n#elif RENDERING_MODE == NORMAL_MAP\n        return n * 0.5 + 0.5;\n#elif RENDERING_MODE == PBR\n        return shade(r.d, n, saturate(n * 0.5 + 0.5, 0.7));\n#endif\n    } else {\n#if RENDERING_MODE == REGULAR\n        vec3 lv = normalize(vec3(-1.0, 2.0, -3.0));\n        float ld = dot(lv, r.d);\n        float l = pow(mix(0.4, 1.0, ld * 0.5 + 0.5), 5.0);\n        vec3 c = vec3(0.2);\n        return pow(c * l, vec3(1.0 / 2.0));\n#elif RENDERING_MODE == NORMAL_MAP\n        return vec3(0.2);\n#elif RENDERING_MODE == PBR\n    #if USE_CUBEMAP_BACKGROUND_FOR_PBR\n        return texture(iChannel1, r.d).rgb;\n    #else\n        return vec3(0.2);\n    #endif\n#endif\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Calculate camera configuration from keyboard & mouse input buffer\n    vec2 camRot = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec2 cr = cos(camRot);\n    vec2 sr = sin(camRot);\n    mat3 v2wRotMat = mat3(\n            cr.y,         0.0,  -sr.y,\n            sr.x * sr.y,  cr.x,  cr.y * sr.x,\n            cr.x * sr.y, -sr.x,  cr.x * cr.y);\n    vec4 camPosD = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec3 camPos = camPosD.xyz + v2wRotMat * vec3(0.0, 0.0, 1.0) * camPosD.w; \n    vec2 tanHalfFov = vec2(tan(radians(fovY) * 0.5)); \n    tanHalfFov.x *= iResolution.x / iResolution.y;\n    vec2 cCoord = fragCoord / iResolution.xy * 2.0 - 1.0;\n    vec3 vDir = normalize(vec3(cCoord * tanHalfFov, -1.0));\n    vec3 wDir = v2wRotMat * vDir;\n    Ray r = Ray(camPos, wDir);\n    \n    // Calculate color\n    fragColor = vec4(calculateColor(r), 1.0);\n    \n#if VIGNETTE\n    fragColor.rgb *= 1.0 - 0.8 * pow(distance(vec2(0.5, 0.5), fragCoord / iResolution.xy), 3.0);\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//------------------------Interval Arithmetic Library-------------------------//\n\n// Interval Types:\n// These types keep track of a lower and upper bound throughout computation, \n// giving definitive bounds for the end result.\n\nstruct iFloat {\n    float l;\n    float u;\n};\n\nstruct iVec3 {\n    iFloat x;\n    iFloat y;\n    iFloat z;\n};\n\nstruct iBool {\n    bool l;\n    bool u;\n};\n\n// Functions: \n// Most of these functions have the same domains as the native GLSL equivalents. \n// If the arguments are outside of the domain, an empty set is returned. To be \n// correct, these should be propagated like NaNs, however, it slows down the\n// shader a lot and isn't necessary most of the time so propagation is optional.\n// These functions are overloaded so they can be called without having to\n// convert floats to iFloats or bools to iBools when mixing them with non-\n// interval types.\n\n#define PROPAGATE_EMPTY_SETS 0\n\niFloat iAdd(iFloat x, iFloat y);\niFloat iSub(iFloat x, iFloat y);\niFloat iMul(iFloat x, iFloat y);\niFloat iDiv(iFloat x, iFloat y);\n\niFloat iNeg(iFloat x); // -x\niFloat iInv(iFloat x); // 1 / x\n\niFloat iSin(iFloat x);\niFloat iCos(iFloat x);\niFloat iTan(iFloat x);\n\niFloat iAsin(iFloat x);\niFloat iAcos(iFloat x);\niFloat iAtan(iFloat x);\niFloat iAtan(iFloat y, iFloat x); // never undefined\n\niFloat iSinh(iFloat x);\niFloat iCosh(iFloat x);\niFloat iTanh(iFloat x);\n\niFloat iAsinh(iFloat x);\niFloat iAcosh(iFloat x);\niFloat iAtanh(iFloat x);\n\niFloat iExp(iFloat x);\niFloat iExp2(iFloat x);\n\niFloat iLog(iFloat x);\niFloat iLog2(iFloat x);\n                                                                                \niFloat iPow(iFloat x, iFloat y); // defined for x >= 0.0 or when y is an integer\n\niFloat iSqrt(iFloat x);\niFloat iCbrt(iFloat x);\niFloat iSquare(iFloat x);\n\niFloat iSign(iFloat x);\niFloat iAbs(iFloat x);\niFloat iFloor(iFloat x);\niFloat iCeil(iFloat x);\niFloat iRound(iFloat x);\niFloat iTrunc(iFloat x);\niFloat iMod(iFloat x, iFloat y);\niFloat iFract(iFloat x);\n\niFloat iMin(iFloat x, iFloat y);\niFloat iMax(iFloat x, iFloat y);\niFloat iClamp(iFloat x, iFloat minVal, iFloat maxVal);\n\niFloat iMix(iFloat x, iFloat y, iFloat a);\niFloat iSmoothstep(iFloat edge0, iFloat edge1, iFloat x);\niFloat iStep(iFloat edge, iFloat x);\n\niFloat iIf(iBool P, iFloat x, iFloat y); // use this as the ternary operator\n\niBool iEqual(iFloat x, iFloat y);\niBool iGreaterThan(iFloat x, iFloat y);\niBool iGreaterThanEqual(iFloat x, iFloat y);\niBool iLessThan(iFloat x, iFloat y);\niBool iLessThanEqual(iFloat x, iFloat y);\n\niBool iNOT(iBool x);\niBool iAND(iBool x, iBool y);\niBool iOR(iBool x, iBool y);\niBool iXOR(iBool x, iBool y);\n\n// Constructors:\n// Aren't necessary most of the time since the functions are already overloaded.\niFloat ifloat(float x);\niBool ibool(bool x);\n\n// Constants:\nconst float INFINITY = uintBitsToFloat(0x7F800000u);\nconst float PI = 3.14159265;\n\n\n\n//============================================================================//\n\n\n\n// Overloads:\n#define MAKE_OVERLOADSB(fn) iBool fn(bool x,iBool y){return fn(ibool(x),y);}iBool fn(iBool x,bool y){return fn(x,ibool(y));}\n#define MAKE_OVERLOADSBF(fn) iBool fn(float x,iFloat y){return fn(ifloat(x),y);}iBool fn(iFloat x,float y){return fn(x,ifloat(y));}\n#define MAKE_OVERLOADS2(fn) iFloat fn(float x,iFloat y){return fn(ifloat(x),y);}iFloat fn(iFloat x,float y){return fn(x,ifloat(y));}\n#define MAKE_OVERLOADS3(fn) iFloat fn(float x,iFloat y,iFloat z){return fn(ifloat(x),y,z);}iFloat fn(iFloat x,float y,iFloat z){return fn(x,ifloat(y),z);}iFloat fn(iFloat x,iFloat y,float z){return fn(x,y,ifloat(z));}iFloat fn(float x,float y,iFloat z){return fn(ifloat(x),ifloat(y),z);}iFloat fn(float x,iFloat y,float z){return fn(ifloat(x),y,ifloat(z));}iFloat fn(iFloat x,float y,float z){return fn(x,ifloat(y),ifloat(z));}\n\nMAKE_OVERLOADS2(iAdd)\nMAKE_OVERLOADS2(iSub)\nMAKE_OVERLOADS2(iMul)\nMAKE_OVERLOADS2(iDiv)\nMAKE_OVERLOADS2(iPow)\n\nMAKE_OVERLOADS2(iMod)\n\nMAKE_OVERLOADS2(iMin)\nMAKE_OVERLOADS2(iMax)\nMAKE_OVERLOADS3(iClamp)\n\nMAKE_OVERLOADS3(iMix)\nMAKE_OVERLOADS3(iSmoothstep)\nMAKE_OVERLOADS2(iStep)\n\nMAKE_OVERLOADSBF(iEqual)\nMAKE_OVERLOADSBF(iGreaterThan)\nMAKE_OVERLOADSBF(iGreaterThanEqual)\nMAKE_OVERLOADSBF(iLessThan)\nMAKE_OVERLOADSBF(iLessThanEqual)\n\nMAKE_OVERLOADSB(iAND)\nMAKE_OVERLOADSB(iOR)\nMAKE_OVERLOADSB(iXOR)\n\n// Empty Sets:\nconst iFloat EMPTY_SET = iFloat(-INFINITY, -INFINITY);\nconst iBool EMPTY_BSET = iBool(true, false);\n\n#if PROPAGATE_EMPTY_SETS\n    #define CHECK_IF_EMPTY_SET_F(x) if ((x) == EMPTY_SET) return EMPTY_SET\n    #define CHECK_IF_EMPTY_SET_B(x) if ((x) == EMPTY_SET) return EMPTY_BSET\n    #define CHECK_IF_EMPTY_BSET_F(x) if ((x) == EMPTY_BSET) return EMPTY_SET\n    #define CHECK_IF_EMPTY_BSET_B(x) if ((x) == EMPTY_BSET) return EMPTY_BSET\n#else\n    #define CHECK_IF_EMPTY_SET_F(x)\n    #define CHECK_IF_EMPTY_SET_B(x)\n    #define CHECK_IF_EMPTY_BSET_F(x)\n    #define CHECK_IF_EMPTY_BSET_B(x)\n#endif\n\n// Constructors:\niFloat ifloat(float x) {\n    return iFloat(x, x);\n}\n\n\niBool ibool(bool x) {\n    return iBool(x, x);\n}\n\n// Helper Functions:\niFloat iMinMax(float x, float y, float z, float w) {\n    return iFloat(\n        min(x, min(y, min(z, w))),\n        max(x, max(y, max(z, w)))\n    );\n}\n\niBool iMinMax(bool x, bool y, bool z, bool w) {\n    return iBool(\n        x || y || z || w,\n        x && y && z && w\n    );\n}\n\n\n// Function Implementations:\n\niFloat iAdd(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x); \n    CHECK_IF_EMPTY_SET_F(y);\n    return iFloat(x.l + y.l, x.u + y.u);\n}\n\niFloat iSub(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x); \n    CHECK_IF_EMPTY_SET_F(y);\n    return iFloat(x.l - y.u, x.u - y.l);\n}\n\niFloat iMul(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x); \n    CHECK_IF_EMPTY_SET_F(y);\n    return iMinMax(x.l * y.l, x.l * y.u, x.u * y.l, x.u * y.u);\n}\n\niFloat iDiv(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    return iMul(x, iInv(y));\n}\n\n\niFloat iNeg(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(-x.u, -x.l);\n}\n\niFloat iInv(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x); \n    \n    if (x.l > 0.0 || x.u < 0.0) {\n        return iFloat(1.0 / x.u, 1.0 / x.l);\n    } else if (x.l < 0.0 && x.u > 0.0) {\n        return iFloat(-INFINITY, INFINITY);\n    } else if (x.u == 0.0) {\n        return iFloat(-INFINITY, 1.0 / x.l);\n    } else {\n        return iFloat(1.0 / x.u, INFINITY);\n    }\n}\n\n\niFloat iSin(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    float u = PI * round(x.l / PI) + PI * 1.5;\n    \n    if (u < x.u) {\n        return iFloat(-1.0, 1.0);\n    }\n    \n    u -= PI;\n    vec2 s = vec2(sin(x.l), sin(x.u));\n    vec2 r = vec2(min(s.x, s.y), max(s.x, s.y));\n    \n    if (u < x.u) {\n        float s = sin(u);\n        return iFloat(min(r.x, s), max(r.y, s));\n    }\n    \n    return iFloat(r.x, r.y);\n}\n\niFloat iCos(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iSin(iAdd(x, ifloat(PI / 2.0)));\n}\n\niFloat iTan(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iDiv(iSin(x), iCos(x));\n}\n\n\niFloat iAsin(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u < -1.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.l <= -1.0) {\n        if (x.u < 1.0) {\n            return iFloat(-PI / 2.0, asin(x.u));\n        }\n        \n        return iFloat(-PI / 2.0, PI / 2.0);\n    }\n    \n    if (x.u < 1.0) {\n        return iFloat(asin(x.l), asin(x.u));\n    }\n    \n    if (x.l < 1.0) {\n        return iFloat(asin(x.l), PI / 2.0);\n    }\n    \n    if (x.l == 1.0) {\n        return ifloat(PI / 2.0);\n    }\n    \n    return EMPTY_SET;\n}\n\niFloat iAcos(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u < -1.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.l <= -1.0) {\n        if (x.u < 1.0) {\n            return iFloat(acos(x.u), PI);\n        }\n        \n        return iFloat(0.0, PI);\n    }\n    \n    if (x.u < 1.0) {\n        return iFloat(acos(x.u), acos(x.l));\n    }\n    \n    if (x.l < 1.0) {\n        return iFloat(0.0, acos(x.l));\n    }\n    \n    if (x.l == 1.0) {\n        return ifloat(0.0);\n    }\n    \n    return EMPTY_SET;\n}\n\niFloat iAtan(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(atan(x.l), atan(x.u));\n}\n\niFloat iAtan(iFloat y, iFloat x) {\n    CHECK_IF_EMPTY_SET_F(y);\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u < 0.0) {\n        if (y.u < 0.0) {\n            return iFloat(atan(y.u, x.l), atan(y.l, x.u));\n        }\n        \n        if (y.l < 0.0) {\n            return iFloat(-PI, PI);\n        }\n        \n        return iFloat(atan(y.u, x.u), atan(y.l, x.l));\n    }\n    \n    if (x.u == 0.0) {\n        if (x.l < 0.0) {\n            if (y.u < 0.0) {\n                return iFloat(atan(y.u, x.l), -PI / 2.0);\n            }\n            \n            if (y.l < 0.0) {\n                return iFloat(-PI, PI);\n            }\n            \n            if (y.l == 0.0) {\n                return iFloat(0.0, PI);\n            }\n            \n            return (iFloat(PI / 2.0, atan(y.l, x.l)));\n        }\n        \n        if (y.u < 0.0) {\n            return ifloat(-PI / 2.0);\n        }\n        \n        if (y.u == 0.0) {\n            if (y.l < 0.0) {\n                return iFloat(-PI / 2.0, 0.0);\n            }\n            \n            return ifloat(0.0);\n        }\n        \n        if (y.l < 0.0) {\n            return iFloat(-PI / 2.0, PI / 2.0);\n        }\n        \n        if (y.l == 0.0) {\n            return iFloat(0.0, PI / 2.0);\n        }\n        \n        return ifloat(PI / 2.0);\n    }\n    \n    if (x.l < 0.0) {\n        if (y.u < 0.0) {\n            return iFloat(atan(y.u, x.l), atan(y.u, x.u));\n        }\n        \n        if (y.u == 0.0) {\n            if (y.l == 0.0) {\n                return iFloat(0.0, PI);\n            }\n            \n            return iFloat(-PI, PI);\n        }\n        \n        if (y.l < 0.0) {\n            return iFloat(-PI, PI);\n        }\n        \n        if (y.l == 0.0) {\n            return iFloat(0.0, PI);\n        }\n        \n        return iFloat(atan(y.l, x.u), atan(y.l, x.l));\n    }\n    \n    if (x.l == 0.0) {\n        if (y.u <= 0.0) {\n            return iFloat(atan(y.u, x.u), -PI / 2.0);\n        }\n        \n        if (y.l < 0.0) {\n            return iFloat(-PI / 2.0, PI / 2.0);\n        }\n        \n        if (y.l == 0.0) {\n            return iFloat(0.0, PI / 2.0);\n        }\n        \n        return iFloat(atan(y.l, x.u), PI / 2.0);\n    }\n    \n    return iAtan(iDiv(y, x));\n}\n\n\niFloat iSinh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(sinh(x.l), sinh(x.u));\n}\n\niFloat iCosh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u <= 0.0) {\n        return iFloat(cosh(x.u), cosh(x.l));\n    }\n    \n    if (x.l <= 0.0 && 0.0 < x.u) {\n        return iFloat(1.0, cosh(max(-x.l, x.u)));\n    }\n    \n    return iFloat(cosh(x.l), cosh(x.u));\n}\n\niFloat iTanh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(tanh(x.l), tanh(x.u));\n}\n\n\niFloat iAsinh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(asinh(x.l), asinh(x.u));\n}\n\niFloat iAcosh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u < 1.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.u == 1.0) {\n        return ifloat(0.0);\n    }\n    \n    if (x.l <= 1.0) {\n        return iFloat(0.0, acosh(x.u));\n    }\n    \n    return iFloat(acosh(x.l), acosh(x.u));\n}\n\niFloat iAtanh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u <= -1.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.l <= -1.0) {\n        if (x.u < 1.0) {\n            return iFloat(-INFINITY, atanh(x.u));\n        }\n        \n        return iFloat(-INFINITY, INFINITY);\n    }\n    \n    if (x.l < 1.0) {\n        if (x.u < 1.0) {\n            return iFloat(atanh(x.l), atanh(x.u));\n        }\n        \n        return iFloat(atanh(x.l), INFINITY);\n    }\n    \n    return EMPTY_SET;\n}\n\n\niFloat iExp(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(exp(x.l), exp(x.u));\n}\n\niFloat iExp2(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(exp2(x.l), exp2(x.u));\n}\n\n\niFloat iLog(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l > 0.0) {\n        return iFloat(log(x.l), log(x.u));\n    }\n    \n    if (x.u > 0.0) {\n        return iFloat(-INFINITY, log(x.u));\n    }\n    \n    return EMPTY_SET;\n}\n\niFloat iLog2(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l > 0.0) {\n        return iFloat(log2(x.l), log2(x.u));\n    }\n    \n    if (x.u > 0.0) {\n        return iFloat(-INFINITY, log2(x.u));\n    }\n    \n    return EMPTY_SET;\n}\n\n\niFloat iPow(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    \n    if (x.l < 0.0 && y.l == y.u && fract(y.l) == 0.0) {\n        float y = y.l;\n        \n        if (y == 0.0) {\n            return ifloat(1.0);\n        }\n\n        if (y > 0.0) {\n            if (mod(y, 2.0) == 1.0) {\n                return iFloat(-pow(-x.l, y), pow(abs(x.u), y) * sign(x.u));\n            }\n\n            if (x.u > 0.0) {\n                return iFloat(0.0, pow(max(-x.l, x.u), y));\n            }        \n\n            return iFloat(pow(-x.u, y), pow(-x.l, y));;\n        }\n\n        if (mod(y, 2.0) == 1.0) {\n            if (x.u > 0.0) {\n                return iFloat(-INFINITY, INFINITY);\n            }\n\n            if (x.u == 0.0) {\n                return iFloat(-INFINITY, -pow(-x.l, y));\n            }\n\n            return iFloat(-pow(-x.u, y), -pow(-x.l, y));\n        }\n\n        if (x.u > 0.0) {\n            return iFloat(min(pow(-x.l, y), pow(x.u, y)), INFINITY);\n        }\n\n        if (x.u == 0.0) {\n            return iFloat(pow(-x.l, y), INFINITY);\n        }\n\n        return iFloat(pow(-x.l, y), pow(-x.u, y));\n    }\n    \n    if (x.u < 0.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.u == 0.0) {\n        if (y.l == 0.0 && y.u == 0.0) {\n            return EMPTY_SET;\n        }\n        \n        return ifloat(0.0);\n    }\n    \n    x.l = max(x.l, 0.0);\n    \n    if (x.l == 0.0) {\n        if (y.u <= 0.0) {\n            if (y.l == 0.0) {\n                return ifloat(1.0);\n            }\n            \n            if (x.u < 1.0) {\n                return iFloat(pow(x.u, y.u), INFINITY);\n            }\n            \n            return iFloat(pow(x.u, y.l), INFINITY);\n        }else\n        \n        if (y.l < 0.0) {\n            return iFloat(0.0, INFINITY);\n        }\n        \n        if (y.l == 0.0) {\n            return iFloat(0.0, max(1.0, pow(x.u, y.u)));\n        }\n    }\n    \n    return iMinMax(pow(x.l, y.l), pow(x.l, y.u), pow(x.u, y.l), pow(x.u, y.u));\n}\n\n\niFloat iSqrt(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l > 0.0) {\n        return iFloat(sqrt(x.l), sqrt(x.u));\n    }\n    \n    if (x.u > 0.0) {\n        return iFloat(0.0, sqrt(x.u));\n    }\n    \n    if (x.u == 0.0) {\n        return ifloat(0.0);\n    }\n    \n    return EMPTY_SET;\n}\n\niFloat iCbrt(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(pow(abs(x.l), 1.0 / 3.0) * sign(x.l), pow(abs(x.u), 1.0 / 3.0) * sign(x.u));\n}\n\niFloat iSquare(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l <= 0.0 && 0.0 <= x.u) {\n        float t = max(-x.l, x.u);\n        return iFloat(0.0, t * t);\n    }\n    \n    if (x.u <= 0.0) {\n        return iFloat(x.u * x.u, x.l * x.l);\n    }\n    \n    return iFloat(x.l * x.l, x.u * x.u);\n}\n\n\niFloat iSign(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(sign(x.l), sign(x.u));\n}\n\niFloat iAbs(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l >= 0.0) {\n        return x;\n    }\n    \n    if (x.u <= 0.0) {\n        return iNeg(x);\n    }\n    \n    return iFloat(0.0, max(-x.l, x.u));\n}\n\niFloat iFloor(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(floor(x.l), floor(x.u));\n}\n\niFloat iCeil(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(ceil(x.l), ceil(x.u));\n}\n\niFloat iRound(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(round(x.l), round(x.u));\n}\n\niFloat iTrunc(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(trunc(x.l), trunc(x.u));\n}\n\niFloat iMod(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    return iSub(x, iMul(y, iFloor(iDiv(x, y))));\n}\n\niFloat iFract(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iSub(x, iFloor(x));\n}\n\n\niFloat iMin(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    return iFloat(min(x.l, y.l), min(x.u, y.u));\n}\n\niFloat iMax(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    return iFloat(max(x.l, y.l), max(x.u, y.u));\n}\n\niFloat iClamp(iFloat x, iFloat minVal, iFloat maxVal) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(minVal);\n    CHECK_IF_EMPTY_SET_F(maxVal);\n    return iFloat(clamp(x.l, minVal.l, maxVal.l), clamp(x.u, minVal.u, maxVal.u));\n}\n\n\niFloat iMix(iFloat x, iFloat y, iFloat a) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    CHECK_IF_EMPTY_SET_F(a);\n    return iAdd(x, iMul(iSub(y, x), a));\n}\n\niFloat iSmoothstep(iFloat edge0, iFloat edge1, iFloat x) {\n    CHECK_IF_EMPTY_SET_F(edge0);\n    CHECK_IF_EMPTY_SET_F(edge1);\n    CHECK_IF_EMPTY_SET_F(x);\n    iFloat t = iClamp(iDiv(iSub(x, edge0), iSub(edge1, edge0)), 0.0, 1.0);\n    return iMul(iSquare(t), iSub(3.0, iMul(2.0, t)));\n}\n\niFloat iStep(iFloat edge, iFloat x) {\n    CHECK_IF_EMPTY_SET_F(edge);\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (edge.u <= x.l) {\n        return ifloat(1.0);\n    }\n    \n    if (x.u < edge.l) {\n        return ifloat(0.0);\n    }\n    \n    return iFloat(0.0, 1.0);\n}\n\n\niFloat iIf(iBool P, iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_BSET_F(P);\n    \n    if (P.l) {\n        return x;\n    }\n    \n    if (!P.u) {\n        return y;\n    }\n    \n    if (x == EMPTY_SET) {\n        return y;\n    }\n    \n    if (y == EMPTY_SET) {\n        return x;\n    }\n    \n    return iFloat(min(x.l, y.l), max(x.u, y.u));\n}\n\niFloat iIf(bool P, iFloat x, iFloat y) {\n    return iIf(ibool(P), x, y);\n}\niFloat iIf(bool P, float x, iFloat y) {\n    return iIf(ibool(P), ifloat(x), y);\n}\niFloat iIf(bool P, iFloat x, float y) {\n    return iIf(ibool(P), x, ifloat(y));\n}\niFloat iIf(iBool P, float x, iFloat y) {\n    return iIf(P, ifloat(x), y);\n}\niFloat iIf(iBool P, float x, float y) {\n    return iIf(P, ifloat(x), ifloat(y));\n}\niFloat iIf(iBool P, iFloat x, float y) {\n    return iIf(P, x, ifloat(y));\n}\n\niBool iEqual(iFloat x, iFloat y) {\n    if (x == y) {\n        return ibool(true);\n    }\n    \n    if (x.l <= y.u && y.l <= x.l) {\n        return iBool(false, true);\n    }\n    \n    return ibool(false);\n}\n\niBool iGreaterThan(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_B(x);\n    CHECK_IF_EMPTY_SET_B(y);\n    \n    if (x.l > y.u) {\n        return ibool(true);\n    }\n    \n    if (x.u <= y.l) {\n        return ibool(false);\n    }\n    \n    return iBool(false, true);\n}\n\niBool iGreaterThanEqual(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_B(x);\n    CHECK_IF_EMPTY_SET_B(y);\n    \n    if (x.l >= y.u) {\n        return ibool(true);\n    }\n    \n    if (x.u < y.l) {\n        return ibool(false);\n    }\n    \n    return iBool(false, true);\n}\n\niBool iLessThan(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_B(x);\n    CHECK_IF_EMPTY_SET_B(y);\n    \n    if (x.u < y.l) {\n        return ibool(true);\n    }\n    \n    if (x.l >= y.u) {\n        return ibool(false);\n    }\n    \n    return iBool(false, true);\n}\n\niBool iLessThanEqual(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_B(x);\n    CHECK_IF_EMPTY_SET_B(y);\n    \n    if (x.u <= y.l) {\n        return ibool(true);\n    }\n    \n    if (x.l > y.u) {\n        return ibool(false);\n    }\n    \n    return iBool(false, true);\n}\n\n\niBool iNOT(iBool x) {\n    CHECK_IF_EMPTY_BSET_B(x);\n    \n    if (x.l && x.u) {\n        return ibool(false);\n    }\n    \n    if (!x.l && !x.u) {\n        return ibool(true);\n    }\n    \n    return iBool(false, true);\n}\n\niBool iAND(iBool x, iBool y) {\n    CHECK_IF_EMPTY_BSET_B(x);\n    CHECK_IF_EMPTY_BSET_B(y);\n    \n    return iMinMax(x.l && y.l, x.l && y.u, x.u && y.l, x.u && y.u);\n}\n\niBool iOR(iBool x, iBool y) {\n    CHECK_IF_EMPTY_BSET_B(x);\n    CHECK_IF_EMPTY_BSET_B(y);\n    \n    return iMinMax(x.l || y.l, x.l || y.u, x.u || y.l, x.u || y.u);\n}\n\niBool iXOR(iBool x, iBool y) {\n    CHECK_IF_EMPTY_BSET_B(x);\n    CHECK_IF_EMPTY_BSET_B(y);\n    \n    return iMinMax(x.l ^^ y.l, x.l ^^ y.u, x.u ^^ y.l, x.u ^^ y.u);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//-----------------------Keyboard & Mouse Input Handler-----------------------//\n\n// Settings: \nconst float MOUSE_SENSITIVITY = 5.0;  \nconst float MOVEMENT_SPEED = 10.0; // Units per second\n\n// Controls:\nconst float KEY_W = 87.0;     // forwards\nconst float KEY_A = 65.0;     // left\nconst float KEY_S = 83.0;     // backwards\nconst float KEY_D = 68.0;     // right\nconst float KEY_UP = 38.0;    // forwards\nconst float KEY_LEFT = 37.0;  // left\nconst float KEY_DOWN = 40.0;  // backwards\nconst float KEY_RIGHT = 39.0; // right\nconst float KEY_SPACE = 32.0; // up\nconst float KEY_SHIFT = 16.0; // down\nconst float KEY_J = 74.0;     // up\nconst float KEY_N = 78.0;     // down\nconst float KEY_K = 75.0;     // decrease orbit radius\nconst float KEY_M = 77.0;     // increase orbit radius\n\n\n\n//============================================================================//\n\n\n\nbool keyPressed(float keyCode) {\n    return texture(iChannel0, vec2((keyCode + 0.5) / 256.0, 0.5 / 3.0)).r > 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n    \n    if (fragCoord == vec2(0.5, 0.5)) {\n        if (iMouse.z > 0.0) {\n            vec2 oldCamRot = texelFetch(iChannel1, ivec2(0, 0), 0).zw;\n            float mouseSens = -MOUSE_SENSITIVITY / iResolution.x;\n            fragColor = vec4(clamp(oldCamRot.x - (iMouse.y - abs(iMouse.w)) * mouseSens, -PI * 0.5, PI * 0.5),\n                                   oldCamRot.y + (iMouse.x - abs(iMouse.z)) * mouseSens,\n                                   oldCamRot);\n        } else {\n            vec2 camRot = texelFetch(iChannel1, ivec2(0, 0), 0).xy;\n            fragColor = camRot.xyxy;\n        }\n        \n        if (iFrame == 0 || iMouse.x == 0.0 && iMouse.z == 0.0) {\n            fragColor.x = mix(0.1, -0.1, 0.5 - 0.5 * cos(iTime * 0.5));\n            fragColor.y = -1.9 + iTime * 0.3;\n        }\n    } else if (fragCoord == vec2(1.5, 0.5)) {\n        fragColor = texelFetch(iChannel1, ivec2(1, 0), 0);\n        float camRotY = texelFetch(iChannel1, ivec2(0, 0), 0).y;\n        float c = cos(camRotY);\n        float s = sin(camRotY);\n        mat3 rotMat = mat3(\n                c,   0.0,  -s,\n                0.0, 1.0,  0.0,\n                s,   0.0,  c\n            ) * MOVEMENT_SPEED * iTimeDelta;\n        vec3 right = vec3(1.0, 0.0, 0.0);\n        vec3 up = vec3(0.0, 1.0, 0.0);\n        vec3 forward = vec3(0.0, 0.0, -1.0);\n        \n        if (keyPressed(KEY_W) || keyPressed(KEY_UP)) {\n            fragColor.xyz += rotMat * forward;\n        }\n        if (keyPressed(KEY_S) || keyPressed(KEY_DOWN)) {\n            fragColor.xyz -= rotMat * forward;\n        }\n        \n        if (keyPressed(KEY_D) || keyPressed(KEY_RIGHT)) {\n            fragColor.xyz += rotMat * right;\n        }\n        if (keyPressed(KEY_A) || keyPressed(KEY_LEFT)) {\n            fragColor.xyz -= rotMat * right;\n        }\n        \n        if (keyPressed(KEY_SPACE) || keyPressed(KEY_J)) {\n            fragColor.xyz += rotMat * up;\n        }\n        if (keyPressed(KEY_SHIFT) || keyPressed(KEY_N)) {\n            fragColor.xyz -= rotMat * up;\n        }\n            \n        if (keyPressed(KEY_K)) {\n            fragColor.w   -= MOVEMENT_SPEED * iTimeDelta;\n        }\n        if (keyPressed(KEY_M)) {\n            fragColor.w   += MOVEMENT_SPEED * iTimeDelta;\n        }\n        \n        fragColor.w = iFrame == 0 ? 11.0 : max(fragColor.w, 0.0);\n    } else if (fragCoord == vec2(0.5, 1.5)) {\n        if (keyPressed(KEY_W)     || keyPressed(KEY_A)     || \n            keyPressed(KEY_S)     || keyPressed(KEY_D)     || \n            keyPressed(KEY_UP)    || keyPressed(KEY_LEFT)  || \n            keyPressed(KEY_DOWN)  || keyPressed(KEY_RIGHT) || \n            keyPressed(KEY_SPACE) || keyPressed(KEY_SHIFT) || \n            keyPressed(KEY_J)     || keyPressed(KEY_N)     || \n            keyPressed(KEY_K)     || keyPressed(KEY_M)     || \n            \n            iMouse.z > 0.0) {\n            fragColor.x = 1.0;\n        } else {\n            fragColor.x = texelFetch(iChannel1, ivec2(0, 1), 0).x + 1.0;\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}