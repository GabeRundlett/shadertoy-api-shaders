{
    "Shader": {
        "info": {
            "date": "1524257973",
            "description": "nfs menu",
            "flags": 32,
            "hasliked": 0,
            "id": "ld3fRn",
            "likes": 3,
            "name": "NFS",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "janneasdf",
            "viewed": 424
        },
        "renderpass": [
            {
                "code": "/* stuff to consider:\n\nx grid edges\n\nx vertical lines\n\nx fading sides\n\nx tint colors (search online)\n\nx flowing binary (todo improve font)\n\nx random tile animation/transition\n\ncar images\n\nspinning logo thing\n\ndriving scene (low-fps)\n\n*/\n\n/** IMPLEMENTATION **/\n\n// UV is in [0, 1] x [0, 1]\nfloat font_zero(vec2 uv) {\n    \n    // Stroke width\n    float sw = 0.1;\n    \n\t// top, left, bottom, right (top/left of stroke)\n    float t = 0.1, l = 0.25, b = 0.9, r = (1.0 - l - sw);\n    \n    // top\n    if (uv.x > l && uv.x < r+sw && uv.y > t && uv.y < t+sw) return 1.0;\n    // left\n    if (uv.x > l && uv.x < l+sw && uv.y > t && uv.y < b+sw) return 1.0;\n    // bottom\n    if (uv.x > l && uv.x < r+sw && uv.y > b && uv.y < b+sw) return 1.0;\n    // right\n    if (uv.x > r && uv.x < r+sw && uv.y > t && uv.y < b+sw) return 1.0;    \n    \n    return 0.0;\n}\n\n// UV is in [0, 1] x [0, 1]\nfloat font_one(vec2 uv) {\n    \n    // Stroke width\n    float sw = 0.12;\n    \n    float t = 0.1, l = 0.5 - 0.5*sw, b = 0.9, r = l+sw;\n    \n    if (uv.y > t && uv.y < b && uv.x > l && uv.x < r) return 1.0;\n        \n    return 0.0;\n}\n\nfloat binary_flow(vec2 p, vec2 pos, vec2 dim, vec2 scale) {\n    \n    if (p.x < pos.x) return 0.0;\n    if (p.y < pos.y) return 0.0;\n    if (p.x > pos.x + dim.x * scale.x) return 0.0;\n    if (p.y > pos.y + dim.y * scale.y) return 0.0;\n    \n    vec2 wh = scale * dim;\n    \n    float scroll_freq = 1.0 / 0.21;\n    float scroll = ceil(scroll_freq * iTime);\n    \n    vec2 pos_in_flow = p - pos;\n    vec2 pos_in_cell = mod(pos_in_flow, scale.x);\n    vec2 cell_pos = ceil(pos_in_flow / scale);\n    bool one = rand(vec2(cell_pos.x, cell_pos.y - scroll)) > 0.5; //pos_in_flow.x < scale.x;\n    return one ? font_one(pos_in_cell / scale) : font_zero(pos_in_cell / scale);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // TODO: pixelize\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x / iResolution.y;\n\n    vec2 coord = 2.0 * (uv - vec2(0.5));\n    coord.x *= ar;\n    \n    // Image\n    //vec3 col = texture(iChannel0, uv).xxx;\n\tvec3 col = texture(iChannel1, uv).xyz;\n    \n    // Contrast (todo: better)\n    col *= 3.0;\n    col -= vec3(0.45);\n    \n    // Tint (transition todo: fade in pairs, pair cells in different quadrants\n    float grid_time = calc_grid_time(iTime, coord);\n    \n    vec3 tint;\n    float phase = calc_phase(grid_time);\n    if (phase == 0.0) tint = tint_blue;\n    if (phase == 1.0) tint = tint_red;\n    if (phase == 2.0) tint = tint_green;\n    if (phase == 3.0) tint = tint_gold;\n    col *= tint;\n    \n    // Transition fade (buggy, fuck it for now)\n    float dist_from_transition = min(fract(grid_time), 1.0 - fract(grid_time));\n    float fade_length_in_proportion = transition_fade_length / transition_length;\n    float transition_fade = max(0.0, 1.0 - (1.0 / fade_length_in_proportion) * dist_from_transition);\n    col *= (1.0 - transition_fade);\n    \n    // Black outside the main square\n    if (abs(coord.x) > 1.0) col = vec3(0.0);\n\n    // Edge fades\n    vec2 edge_dist = smoothstep(0.87, 1.0, abs(coord));\n    float fade = max(edge_dist.x, edge_dist.y);\n    col = (1.0 - fade) * col;\n    \n    // Vertical lines (todo: little bit offset)\n    float dist_from_vert_line = mod(coord.x, 2.0 * vertical_lines_interval);\n    if (dist_from_vert_line < vertical_lines_width) col *= vec3(0.9);\n    \n    // Binary flow\n    vec2 binary_bottom_left = vec2(0.58, -0.95);\n    vec2 char_scale = vec2(0.08, 0.08);\n    float binary = binary_flow(\n        coord, \n        binary_bottom_left, \n        vec2(5.0, 24.0/*19.0*/), \n        char_scale\n    );\n    if (binary > 0.0) {\n        col = vec3(binary) * 0.45 + 0.45 * tint;\n    }\n    \n    // Grid\n    vec2 dist_from_grid_xy = mod(coord, 2.0 * grid_intervals);\n    if (min(dist_from_grid_xy.x, dist_from_grid_xy.y) < grid_line_width) col = vec3(0.0);\n    \n    // Gamma correction\n    col = pow(col, gamma_inv);\n    \n    // Override for debug\n    col = texture(iChannel1, uv).xyz;\n    \n    fragColor = vec4(col,1.0);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Raymarch car images\n\nmat4 rm(float tx, float ty, float tz) {\n\treturn mat4(\n        vec4(1.0, 0.0, 0.0, 0.0),\n        vec4(0.0, cos(tx), sin(tx), 0.0),\n        vec4(0.0, -sin(tx), cos(tx), 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0))\n        * mat4(\n        vec4(cos(ty), 0.0, -sin(ty), 0.0),\n        vec4(0.0, 1.0, 0.0, 0.0),\n        vec4(sin(ty), 0.0, cos(ty), 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0))\n        * mat4(\n        vec4(cos(tz), sin(tz), 0.0, 0.0),\n        vec4(-sin(tz), cos(tz), 0.0, 0.0),\n        vec4(0.0, 0.0, 1.0, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0));\n}\n\nmat4 tr(vec3 t) {\n    return mat4(\n        vec4(1.0, 0.0, 0.0, 0.0),\n        vec4(0.0, 1.0, 0.0, 0.0),\n        vec4(0.0, 0.0, 1.0, 0.0),\n        vec4(t, 1.0));\n}\n\nvec3 transform_point(vec3 p, vec3 r, vec3 t) {\n    mat4 rotation = rm(r.x, r.y, r.z);\n    mat4 translation = tr(-t);\n    vec4 p4 = vec4(p, 1.0);\n    mat4 model = rotation * translation;\n    p4 = model * p4;\n    return p4.xyz;\n}\n\n/* CAR 1 */\nvec3 car1_r = vec3(0.0, 0.2, 0.0);\nvec3 car1_pos = 1.6*vec3(4.0, -1.4, 5.0);\n\nfloat car1(vec3 p, vec3 rd) {\n    \n    vec3 p_orig = p;\n    \n    // car body\n    car1_r = mod(mod(iTime, 60.0) * vec3(0.5, 0.2, 0.5), 2.*3.1415629);\n    vec3 p_body = transform_point(p, car1_r, car1_pos);\n    //float d = udRoundBox(p_body, vec3(5.0, 0.8, 1.8), 0.14);\n    float d = sdBox(p_body, vec3(5.0, 0.8, 1.8));\n    d = max(0.0, d);\n    \n    // wheels\n    vec3 wheel_r = car1_r + vec3(radians(0.), radians(0.), radians(0.0));\n    vec3 p_wheel1 = transform_point(p, wheel_r, car1_pos);\n    //d = min(d, sdCappedCylinder(p_wheel1, vec2(5.*.7, .18)));\n    \n    return d;\n}\n\n/* CAR 2 */\nfloat car2(vec3 p, vec3 rd) {\n    return 0.2;\n}\n\nfloat car3(vec3 p, vec3 rd) {\n    return 0.4;\n}\n\nfloat car4(vec3 p, vec3 rd) {\n    return 0.6;\n}\n\nfloat map(vec3 p, vec3 rd, float phase) {\n\t\n    if (phase == 0.0) return car1(p, rd);\n\tif (phase == 1.0) return car2(p, rd);\n\tif (phase == 2.0) return car3(p, rd);\n\tif (phase == 3.0) return car4(p, rd);\n    \n    return car1(p, rd); // should not happen\n}\n\nvec3 shade_body(vec3 normal) {\n    vec3 light_pos = vec3(3.5, 5.0, 0.0);\n    vec3 light_target = car1_pos;\n    vec3 light_dir = normalize(light_target - light_pos);\n    float e = max(0.0, dot(light_dir, normal));\n    return vec3(e);\n}\n    \n\nvec3 getColor(vec3 rayPos, vec3 rayDir, float phase)\n{\n    vec3 color = phase == 0.0 \n        ? texture(iChannel0, rayDir).xyz\n    \t: phase == 1.0 ? texture(iChannel1, rayDir).xyz\n        : texture(iChannel2, rayDir).xyz;\n\n    color = vec3(1.0, 0.0, 0.0);\n    \n    float total_dist = 0.0;\n    float d = 9999999.0;\n    int iters = 0;\n    float eps = 0.001;\n    for (int i = 0; i < 128; ++i)\n    {\n    \t++iters;\n    \td = map(rayPos, rayDir, phase);\n        rayPos += d * rayDir;\n        total_dist += d;\n        if (d < eps)\n        {\n        \tbreak;\n        }\n    }\n    \n    if (d == 0.0) { return color; }\n    \n    if (d < eps)\n    {\n        vec3 normal = normalize(cross(dFdx(rayPos), dFdy(rayPos)));\n        //color = shade_body(normal);\n        color = normal;\n        //color = vec3(500.0*d);\n    }\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x / iResolution.y;\n\n    vec2 coord = 2.0 * (uv - vec2(0.5));\n    coord.x *= ar;\n\n    vec3 col = vec3(1.0);\n    \n    \n    // Initialize camera stuff\n    uv -= .5;\n    uv.x = ar * uv.x;\n    vec3 camPos = vec3(0.0, 0.0, -2.0);\n    vec3 camTarget = vec3(0.0);\n    vec3 camUp = vec3(0., 1., 0.);\n    vec3 camDir = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(camUp, camDir));\n    camUp = normalize(cross(camDir, camRight));\n    \n    vec3 rayPos = camPos;\n    vec3 rayDir = normalize(camDir + uv.x * camRight + uv.y * camUp);\n    rayPos += rayDir * 0.01;\n    \n    //rayDir = (rm(0.0, 0.0, 0.0) * vec4(rayDir, 1.0)).xyz;\n    \n    \n    //float phase = calc_phase(calc_grid_time(iTime, coord));\n    float phase = 0.0;\n    \n    //col = vec3(map(rayPos, rayDir, phase));\n    \n    col = getColor(rayPos, rayDir, phase);\n    \n    // \n    //if (abs(coord.x) > 1.0) col = vec3(0.0);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/***** LIBRARY FUNCTIONS *****/\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(float n){\n    return fract(cos(n*89.42)*343.42);\n}\n\nvec3 rgb_to_hsv(vec3 rgb) {\n    float c_max = max(max(rgb.x, rgb.y), rgb.z);\n    float c_min = min(min(rgb.x, rgb.y), rgb.z);\n    float delta = c_max - c_min;\n    \n    // Hue\n    float hue = 0.0; // todo\n    \n    // Saturation\n    float saturation = c_max == 0.0 ? 0.0 : delta / c_max;\n    \n    // Value\n    float value = c_max;\n    \n    return vec3(hue, saturation, value);\n}\n\nvec3 hsv_to_rgb(vec3 hsv) { // todo\n\tfloat r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    return vec3(r, g, b);\n}\n\n\nvec4 euler_to_q(vec3 euler) {\n\n    float cy = cos(euler.z * 0.5);\n\tfloat sy = sin(euler.z * 0.5);\n\tfloat cr = cos(euler.y * 0.5);\n\tfloat sr = sin(euler.y * 0.5);\n\tfloat cp = cos(euler.x * 0.5);\n\tfloat sp = sin(euler.x * 0.5);\n\n    vec4 q;\n\tq.w = cy * cr * cp + sy * sr * sp;\n\tq.x = cy * sr * cp - sy * cr * sp;\n\tq.y = cy * cr * sp + sy * sr * cp;\n\tq.z = sy * cr * cp - cy * sr * sp;\n\treturn q;\n}\n\n/* Distance fields (mainly iq stuff) */\n\nfloat sdBox(vec3 p, vec3 boxDims)\n{\n  vec3 d = abs(p) - boxDims;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat udRoundBox(vec3 p, vec3 boxDims, float r)\n{\n\treturn length(max(abs(p)-boxDims,0.0))-r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nvec3 opTx( vec3 p, mat4 m )\n{\n    vec3 q = (inverse(m)*vec4(p, 1.0)).xyz; // todo check\n    return q;\n}\n\n/*float opScale( vec3 p, float s )\n{\n    return primitive(p/s)*s;\n}*/\n\n\n/***** PARAMETERS *****/\n\nconst vec3 gamma_inv = vec3(1.0 / 2.2);\n\nconst vec2 grid_intervals = 1.0 / vec2(4.0, 4.0);\nconst float grid_line_width = 0.007;\nconst float vertical_lines_interval = 1.0 / 70.0;\nconst float vertical_lines_width = 0.011;\n\nconst vec3 tint_blue = vec3(0.05, 0.23, 1.0);\nconst vec3 tint_red = vec3(1.0, 0.1, 0.1);\nconst vec3 tint_green = vec3(0.1, 1.0, 0.1);\nconst vec3 tint_gold = vec3(0.9, 0.74, 0.1);\n\nconst float transition_length = 10.0;\nconst float transition_speed = 1.0 / transition_length;\nconst float transition_fade_length = 1.0;\n\n/***** FUNCTIONS *****/\n\nfloat calc_grid_time(float time, vec2 coord) {\n    vec2 grid_pos = floor(0.5 * (coord + 1.0) * 4.0);\n    vec2 cell_pos = ceil(0.5 * (coord + vec2(1.0)) * (1.0/grid_intervals));\n    float grid_cell_time_offset = 2.0 * rand(cell_pos*12.0);\n    float grid_time = transition_speed * (time + grid_cell_time_offset);\n    return grid_time;\n}\n\nfloat calc_phase(float grid_time) {\n\treturn mod(ceil(grid_time), 4.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}