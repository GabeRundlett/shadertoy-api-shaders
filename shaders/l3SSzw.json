{
    "Shader": {
        "info": {
            "date": "1710366619",
            "description": "Playing with some ideas for a procedural city. Tried the \"curling city\" effect from Inception (2010) and thought it was cool enough to share.",
            "flags": 0,
            "hasliked": 0,
            "id": "l3SSzw",
            "likes": 29,
            "name": "Inception City",
            "published": 3,
            "tags": [
                "proceduralcity"
            ],
            "usePreview": 1,
            "username": "milkfat",
            "viewed": 353
        },
        "renderpass": [
            {
                "code": "#define U vec2(0,.0001)\n#define MOVE vec3(50.+iTime*.02*.0,.5,500.+iTime*.20)\n#define _LIGHT (vec3(1,6,0)+MOVE)\n//#define NOLIGHT\n\nfloat hash(float n) {return fract(n*fract(n*.133929));}\n\nvec2 rotate(vec2 p, float a) {return vec2 (cos(a)*p.x - sin(a)*p.y, sin(a)*p.x + cos(a)*p.y);}\n\n//procedural brick texture with LOD\nvec3 brick(vec2 uv, float pitch, vec3 col, float scale)\n{\n    vec2 p=pitch*vec2(scale*25.0,scale*25.0*3.42);\n    uv*=vec2(scale*25.0,scale*25.0*3.42);\n    float d = clamp(-(abs(fract(uv.y+.5)-.5)-p.y-.05),0.0,.1);\n    float d2 = clamp(-(abs(fract(uv.x+.5*float(mod(uv.y,2.0)<1.0))-.5)-p.x-.05/3.42),0.0,.1);\n    col+=vec3(d/(p.y))*.3/(pitch*iResolution.x);\n    col+=vec3(d2/(p.y))*.3/(pitch*iResolution.x)*3.42;\n    return col;\n}\n\nfloat check_cube(vec3 p, vec3 ps, vec3 sz, vec3 offset, inout vec3 norm, float sgn)\n{\n    p = vec3(fract(p.x),p.y,fract(p.z))+offset;\n    \n\n    \n    vec3 hmm = -(p+sgn*sign(ps)*(sz))/ps; //number of steps\n    \n    \n    vec3 pssx = p+ps*hmm.x; //coordinate of collision   \n    bool testx = abs(pssx.y)<sz.y && abs(pssx.z)<sz.z; //test if coordinates touch cube\n    \n    vec3 pssy = p+ps*hmm.y; //coordinate of collision   \n    bool testy = abs(pssy.x)<sz.x && abs(pssy.z)<sz.z; //test if coordinates touch cube\n    \n    vec3 pssz = p+ps*hmm.z; //coordinate of collision   \n    bool testz = abs(pssz.x)<sz.x && abs(pssz.y)<sz.y; //test if coordinates touch cube\n\n    float vx = (testx)?hmm.x:1000.0;\n    float vy = (testy)?hmm.y:1000.0;\n    float vz = (testz)?hmm.z:1000.0;\n    \n    \n    float val = min(min(vx,vy),vz);\n    norm = (val==vx)?vec3(1.0*-sign(ps.x),0,0):((val==vy)?vec3(0,1.0*-sign(ps.y),0):vec3(0,0,1.0*-sign(ps.z)));\n\n    return val;\n}\n\nfloat scene(vec3 p, vec3 ps, inout int id, inout float cell_id)\n{\n    float xq = (ps.x<0.0)?ceil(p.x):floor(abs(p.x)); //snap to cell boundary to avoid rounding errors\n    float zq = (ps.z<0.0)?ceil(p.z):floor(abs(p.z));\n    cell_id = (xq+max(sign(ps.x),0.0))*100.0+zq+max(sign(ps.z),0.0);\n    \n    \n    \n    float x = ( (xq+sign(ps.x)) - p.x ) / ps.x; //cell boundary\n    float y = (ps.y<0.0)?( 0.0 - p.y ) / ps.y:10000.0;\n    float z = ( (zq+sign(ps.z)) - p.z ) / ps.z; //cell boundary\n    \n    \n    vec3 norm;\n    float curb = check_cube(p+ps*.001,ps,vec3(.4,.1,.4),vec3(-.5,.09,-.5),norm,1.0);\n    if(curb<-0.01)curb=3.0;\n    float h = floor(pow(hash(cell_id),4.0)*4.0/.20);\n    float bdng_height = h*.01+h*abs((sin(xq*.25)*.5+.5)-(sin(zq*.17)*.5+.5))*.1;\n    bdng_height = .12+floor(bdng_height*10.0)/10.0;\n    float bdng = check_cube(p+ps*.001,ps,vec3(.33,bdng_height,.33),vec3(-.5,0,-.5),norm,1.0);\n    if(bdng<-0.01)bdng=3.0;\n    float ornm = check_cube(p+ps*.001,ps,vec3(.13,.1,.13),vec3(-.33-hash(cell_id*1234.567)*.4,-(bdng_height),-.33-hash(cell_id*3177.17)*.2),norm,1.0);\n    if(ornm<-0.01)ornm=3.0;\n    \n    //return plane;\n    float mn = min(min(min(min(min(x,z),y),curb),bdng),ornm);\n    id=(mn==y)?0:(mn==curb)?1:(mn==bdng)?2:(mn==ornm)?6:id;\n    return mn;\n}\n\nfloat scene(vec3 p, vec3 ps)\n{\n    int id;\n    float cell_id;\n    return scene(p,ps,id,cell_id);\n}\n\nvec4 draw(vec2 C, inout vec3 p_in, inout vec3 ps_in, inout int id_in)\n{\n    vec3 p = p_in;\n    vec3 ps = ps_in;\n    int id = -1;\n    float sun = 0.0;\n    float travel=0.0;\n    float cell_id;\n    float last_val=(ps.x<0.0)?ceil(p.x):floor(abs(p.x));\n    float rot = sin(iTime*.2+3.14159*1.5)*.45+.45;\n    \n    for (int i = 0; i < 60; i++)\n    {\n        \n        float d = scene(p, ps, id,cell_id);\n        p += ps*d;\n        travel+=d;\n        if(id!=-1) break;\n        if(i==59||travel > 30.0)return vec4(0);\n        \n        float diff = p.x-p_in.x;\n        //diff+=sign(diff);\n        float val = (ps.x<0.0)?ceil(p.x):floor(abs(p.x));\n        \n        if(abs(diff)<8.&&val!=last_val)\n        {\n            p-=ps*d;\n            travel-=d;\n            float v = val - last_val;\n            ps.xy = rotate(ps.xy, -rot*.25*v);\n            p.x -= val;\n            p.xy = rotate(p.xy, -rot*.25*v);\n            p.x += val;\n            \n            last_val=val;\n            \n        }\n        \n    }\n    //vec3 LIGHT = p+vec3(sin(iTime)*3.0,6,cos(iTime)*3.0);\n    vec3 LIGHT = p+vec3(3.0,6,-1.0);\n#ifndef NOLIGHT\n    \n    {\n    \n        vec3 p2 = LIGHT;\n        vec3 ps2 = normalize(p-LIGHT);\n        float travel2 = 0.0;\n        float max_travel = length(LIGHT-p);\n        int id2 = -1;\n        float cell_id2;\n        \n        for (int i = 0; i < 30; i++)\n        {\n            if(id2!=-1) break;\n            float d2 = scene(p2, ps2, id2, cell_id2);\n            p2 += ps2*d2;\n            travel2+=d2;\n            if(travel2>max_travel-.01)\n            {\n                sun=1.;\n                break;\n            }\n        }\n    }\n#endif  \n    vec3 norm = normalize(vec3(scene(p+U.yxx, ps)-scene(p-U.yxx, ps), scene(p+U.xyx, ps)-scene(p-U.xyx, ps), scene(p+U.xxy, ps)-scene(p-U.xxy, ps)));\n\n    float scale = .66/10.0;\n    float indoor_bri=0.0;\n#ifndef SIMPLE\n    {\n        vec3 p2 = p;\n        vec3 ps2 = ps;\n        vec2 uv=vec2(mod(fract(p2.x-.17)*10.0/.66,1.0),mod(fract(p2.y-.01)*10.0,1.0));\n        float blerpx=floor(fract(p2.x-.17)*10.0/.66);\n        float blerp=floor(fract(p2.z)*10.0);\n        float blerpy=floor(fract(p2.y-.01)*10.0);\n        if(abs(norm.z)>.5 && id==2 && uv.x<.99) //x-axis window check\n        {\n            if(uv.x<.8&&uv.x>.23&&uv.y<.8&&uv.y>.2)  //y-axis window check\n            {\n                p_in=p;\n                float h = hash(blerp*1991.37+blerpy*9119.13);\n                float h2 = hash(blerpx*1991.37+blerpy*9119.13);\n                vec3 norm3 = norm;\n                norm3.zy=rotate(norm3.zy,norm.z*(uv.y-.5)*(h-.5)*.02+(h-.5)*.02); //window curve\n                norm3.zx=rotate(norm3.zx,norm.z*(uv.x-.5)*(h-.5)*.02+(h-.5)*.02);\n                ps_in=reflect(ps,norm3);\n                id_in=3;\n                //col=vec3(.1,.1,.1); //windows x-axis\n                \n                float f = floor(fract(p2.x-.17)*10./.66)/(10.0/.66)+.17+scale/2.0;\n                float f2 = floor((p2.y-.01)*10.0)/10.0+.01+.05;\n                vec3 norm2;\n                float room = check_cube(p2,ps2,vec3(.3*scale,.3*.1,.002),vec3(-f,-f2,-fract(p2.z)+.001*sign(norm.z)),norm2,-1.0);//window frame\n                p+=ps*room;\n                norm=norm2;\n                id=3;\n                if(norm2.z==-sign(ps.z)) //draw interior\n                {\n                    p2 = p;\n                    float room = check_cube(p2,ps2,vec3(.45*scale,.45*.1,.04),vec3(-f,-f2,-fract(p2.z)+(.001+.035)*sign(norm.z)),norm2,-1.0);\n                    vec3 norm3;\n                    float room2 = check_cube(p2,ps2,vec3(.2*scale,.025*h2,.02),vec3(-f,-f2+.02,-fract(p2.z)+(.001+.035+.01)*sign(norm.z)),norm3,1.0);\n                    if(room2<room)\n                    {\n                        room = room2;\n                        norm2 = norm3;\n                    }\n                    p+=ps*room;\n                    norm=norm2;\n                    id=4;\n                    indoor_bri = dot(norm2,normalize(vec3(f,f2+.075,fract(p2.z)+.015)-vec3(fract(p.x),p.y,fract(p.z))));\n                    if(hash(f*1000.0+f2*9.917+floor(p.z)*99.73+floor(p.x)*599.73)>.4)indoor_bri*=.025;\n                }\n            }\n        }\n    }\n    {\n        vec3 p2 = p;\n        vec3 ps2 = ps;\n        vec2 uv=vec2(mod(fract((p2.z-.17))*10.0/.66,1.0),mod(fract(p2.y-.01)*10.0,1.0));\n        float blerp=floor(fract(p2.x)*10.);\n        float blerpy=floor(fract(p2.y-.01)*10.0);\n        if(abs(norm.x)>.5 && id==2 && uv.x<.99) //z-axis window check\n        {\n            if(uv.x<.8&&uv.x>.2&&uv.y<.8&&uv.y>.2)  //y-axis window check\n            {\n                p_in=p;\n                ps_in=reflect(ps,norm);\n                ps_in.xy=rotate(ps_in.xy,norm.x*(uv.y-.5)*(hash(blerp*1991.37+blerpy*9119.13)-.5)*.02); //window curve\n                ps_in.xz=rotate(ps_in.xz,norm.x*(uv.x-.5)*(hash(blerp*1991.37+blerpy*9119.13)-.5)*.02);\n                id_in=3;\n                //col=vec3(.1,.1,.1); //windows x-axis\n                \n                float f = floor(fract((p2.z-.17))*10.0/.66)/(10.0/.66)+.17+scale/2.0;\n                float f2 = floor((p2.y-.01)*10.0)/10.0+.01+.05;\n                vec3 norm2 = norm;\n                float room = check_cube(p2,ps2,vec3(.002,.3*.1,.3*scale),vec3(-fract(p2.x)+.001*sign(norm.x),-f2,-f),norm2,-1.0);\n                p+=ps*room;\n                norm=norm2;\n                id=3;\n                if(norm2.x==-sign(ps.x)) //draw interior\n                {\n                    p2 = p;\n                    float room = check_cube(p2,ps2,vec3(.04,.45*.1,.45*scale),vec3(-fract(p2.x)+(.001+.035)*sign(norm.x),-f2,-f),norm2,-1.0);\n                    vec3 norm3;\n                    float room2 = check_cube(p2,ps2,vec3(.02,.025*.1,.2*scale),vec3(-fract(p2.x)+(.001+.035-.01)*sign(norm.x),-f2+.02,-f),norm3,1.0);\n                    if(room2<room)\n                    {\n                        room = room2;\n                        norm2 = norm3;\n                    }\n                    p+=ps*room;\n                    norm=norm2;\n                    id=4;\n                    indoor_bri = dot(norm2,normalize(vec3(fract(p2.x)+.015,f2+.075,f)-vec3(fract(p.x),p.y,fract(p.z))));\n                    if(hash(f*1000.0+f2*9.917+floor(p.x)*99.73+floor(p.z)*599.73)>.4)indoor_bri*=.025;\n                }\n            } \n        }\n    }\n#endif\n    \n    float bri = dot(norm,normalize(LIGHT-p));\n    bri*=max(sun,.2);\n    if(id==4)bri=indoor_bri*.4;\n    float dist = 1.0-clamp(distance(LIGHT,p)/55.0,0.0,1.0);\n    dist = dist*dist*dist;\n    vec3 col = vec3(1,1,1);\n    vec3 gd = abs(round(p)-p);\n    if(gd.x < .1 || gd.z < .1 ) col = vec3(.2,.2,.2); //road surface\n    if((gd.x < .005  && mod(p.z,.1)<.05) || (gd.z < .005 && mod(p.x,.1)<.05)) col = vec3(1,1,0); //yellow lines\n    if(gd.x < .1 && gd.z < .1 ) col = vec3(.2,.2,.2); //redraw intersection surface\n    if(id==1)col=vec3(.4,.4,.4);\n    float md = hash(floor(fract(p.z)*1000.0)*499.17+floor(fract(p.x)*1000.0)*9.931);\n    md=md*md;\n    if(id==0)col*=vec3(md*.3+.5);\n    float building_bri = hash(cell_id*.95777)*.4+.02;\n    if(id==2||id==3||id==6)col=vec3(building_bri);\n    vec3 brick_color = vec3(.4,.1,.1);\n    float brick_scale = 1.0;\n    if(hash(floor(p.x)*999.11)>.6&&hash(floor(p.z)*444.233)>.6)\n    {\n        brick_color = vec3(.4,.32,.23);\n        brick_scale = .25;\n    }\n    vec2 brick_uv = (abs(norm.z)>.9)?p.xy:(abs(norm.x)>.9)?p.zy:p.xz;\n    if(hash(floor(p.x)*555.137)>.4&&hash(floor(p.z)*1234.567)>.4)\n    if(id==2||id==3||id==6)col=brick(fract(brick_uv*2.0),(.4+travel*2.8)/iResolution.x,brick_color,brick_scale);\n    return clamp(vec4(bri*dist*col,1.0)*vec4(1.0-travel/30.0), 0.0, 1.0)+vec4(0)*vec4(clamp(travel/30.0,0.0,1.0));\n\n}\n\nvec4 draw0(vec2 C)\n{\n    vec4 F=vec4(0);\n    vec2 C2 = C/iResolution.xy-.5;\n    \n    vec3 p = vec3(0.0,.2,.0)+MOVE;\n    \n    vec3 ps = normalize(vec3(C2.x,C2.y/(iResolution.x/iResolution.y),.5));\n    ps.xy = rotate(ps.xy, (sin(iTime*.2+2.2)*.1)-.005);\n    ps.yz = rotate(ps.yz, .2);\n    ps.xz = rotate(ps.xz, (sin(iTime*.2)*.4)-.005);\n    \n    int id = -1;\n    F = draw(C2, p, ps, id);\n    if(id!=3)\n    {       \n        //F=pow(F,vec4(1.0/2.2));\n        return F;\n    }\n    \n    id=-1;\n    F += draw(C2, p, ps, id)*.5;\n    F/=2.0;\n    return F;\n}\nvoid mainImage( out vec4 F, in vec2 C )\n{\n    F=draw0(C);\n\n    //dither\n    F.r+=hash(float(iFrame)*.791173+C.x*.379111+C.y*.897377)*.002;\n    F.g+=hash(float(iFrame)*.891173+C.x*.719733+C.y*.797377)*.002;\n    F.b+=hash(float(iFrame)*.971173+C.x*.931917+C.y*.717377)*.002;\n    \n    F=pow(F,vec4(1.0/2.2));\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}