{
    "Shader": {
        "info": {
            "date": "1696723167",
            "description": "A simple bouncing ball animation test",
            "flags": 0,
            "hasliked": 0,
            "id": "DsycDd",
            "likes": 0,
            "name": "Bouncing SDF Ball",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "animated",
                "animation"
            ],
            "usePreview": 0,
            "username": "tristanantonsen",
            "viewed": 136
        },
        "renderpass": [
            {
                "code": "// Ray marching constants\n#define MAX_STEPS 350\n#define SURF_DIST 0.0001\n#define MAX_DIST 100.0\n#define PI 3.141592653592\n#define TAU 6.283185307185\n\n\n////////////////////////////////////////////////////////////////\n// Signed Distance Functions\n////////////////////////////////////////////////////////////////\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,normalize(n)) + h;\n}\n\nfloat sdSphere( vec3 p, vec3 c, float r )\n{\n    return length(p-c) - r;\n}\n\nfloat sdRoundedBox(vec3 p, vec3 s, float r) {\n    p = abs(p)-(s-r);\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.) - r;\n}\n\nfloat sdEllipsoid( vec3 po, vec3 c, vec3 r )\n{\n    vec3 p = po-c;\n\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n////////////////////////////////////////////////////////////////\n// SDF Operations\n////////////////////////////////////////////////////////////////\n\nfloat opUnion(float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction(float d1, float d2) {\n    //NOTE: Flipped order because it makes more sense to me\n    return max(-d2, d1);\n}\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\nfloat opSmoothIntersection(float d1, float d2, float k){\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n////////////////////////////////////////////////////////////////\n// Rotations\n////////////////////////////////////////////////////////////////\n\nvec3 rotX(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        1., 0., 0.,\n        0., c, -s,\n        0., s, c\n        );\n    return m * p;\n}\n\nvec3 rotY(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, 0., s,\n        0., 1., 0.,\n        -s, 0., c\n        );\n    return m * p;\n}\n\nvec3 orbitControls(vec3 po) {\n    vec2 m = (vec2(iMouse.x, iMouse.y) / iResolution.xy) + 0.5;\n    vec3 p = po;\n    p = rotY(po, -(m.x+1.)*TAU + PI * 0.95);\n    return p;\n}\n\n\n\n////////////////////////////////////////////////////////////////\n// Ray Marching & Map Functions\n////////////////////////////////////////////////////////////////\n\nfloat ramp(float t, float inMin, float inMax, float outMin, float outMax) {\n\n    return mix(outMin, outMax, smoothstep(inMin, inMax, t));\n\n}\n\nfloat ball(vec3 p, float x, float t) {\n    \n    float ymin = -0.85;     // max height (t = 1)\n    float ymax = 0.625;     // min height (t = 0)\n        \n    float r = 0.35;\n    float dry = 0.5;\n    float drxz = 0.625;\n\n    float sxz = ramp(t, 0., 0.3, drxz + 1., 1.);         // xz radius ramp\n    float sy = ramp(abs(t-0.35), 0., 0.6, dry + 1., 1.); // y radius ramp\n\n    float rt = sxz * r; // - r * sy * 0.5;\n    float ry = sy * r;\n    \n    \n    rt *= ramp(abs(t-0.35), 0., 0.6, 0.625, 1.);;\n    ry *= ramp(t, 0., 0.3, 0.5, 1.);\n    \n\n    float b = sdEllipsoid(p, vec3(x, mix(ymin, ymax, t), 0.), vec3(rt, ry, rt));\n    \n    return b;\n\n}\n\nvec2 map(vec3 po) {\n\n    // Mouse\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;  \n    vec3 p = po;\n\n    vec2 res;\n    \n    float speed = 3.;\n    float t = abs(sin(iTime * speed)); // 0 to 1\n\n    float b = ball(p, 0., t);\n    \n    res = vec2(b, 1.0); \n    \n    // Ground\n    float g = sdRoundedBox(p-vec3(0.,-1.2,0.), vec3(3.,0.2,3.), 0.1);\n    \n    if (g < res.x) {res.y = 2.;};\n    res.x = opUnion(res.x,g);\n    \n    return res;\n}\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    float mat = 1.0;\n    float minDist = MAX_DIST;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        if (i >= MAX_STEPS ) break;\n        vec3 p = ro + rd * d;\n        vec2 ds = map(p);\n        d += ds.x;\n        mat = ds.y;\n        minDist = min(minDist, ds.x);\n        if (d >= MAX_DIST || ds.x < SURF_DIST) break;\n        i++;\n    }\n    return vec3(d, mat, minDist);\n}\n\nvec3 gradient(vec3 p) {\n    float epsilon = 0.0001;\n    vec3 dx = vec3(epsilon, 0., 0.0);\n    vec3 dy = vec3(0., epsilon, 0.0);\n    vec3 dz = vec3(0., 0.0, epsilon);\n\n    float ddx = map(p + dx).x - map(p - dx).x;\n    float ddy = map(p + dy).x - map(p - dy).x;\n    float ddz = map(p + dz).x - map(p - dz).x;\n    \n    return normalize(vec3(ddx, ddy, ddz));\n}\n\nvec3 rayDirection(vec2 p, vec3 ro, vec3 rt) {\n\n    // screen orientation\n    vec3 vup = vec3(0., 1.0, 0.0);\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 vw = normalize(ro - rt);\n    vec3 vu = normalize(cross(vup, vw));\n    vec3 vv = cross(vw, vu);\n    float theta = radians(30.); // half FOV\n    float viewport_height = 2. * tan(theta);\n    float viewport_width = aspectRatio * viewport_height;\n    vec3 horizontal = -viewport_width * vu;\n    vec3 vertical = viewport_height * vv;\n    float focus_dist = length(ro - rt);\n    vec3 center = ro - vw * focus_dist;\n\n    vec3 rd = center + p.x * horizontal + p.y * vertical - ro;\n\n    return normalize(rd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy - 0.5) * 2.0; // normalizing\n\n    // Ray Marching\n    vec3 rt = vec3(0., 0., 0.);\n    vec3 ro = vec3(0., -0.5, -60.02);\n\n    vec3 rd = rayDirection(uv, ro, rt);\n    vec3 d = rayMarch(ro, rd); \n\n    // Background\n    float v = length(uv) * .75;\n    fragColor = vec4(0.1,0.7,1.,1.);\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.y)));\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.x)));\n    \n    vec3 color;\n\n    if (d.x <= 100.0) {\n        vec3 p = ro + rd * d.x;\n        vec3 pr = orbitControls(p);\n        vec3 N = gradient(p);\n        float light1 = dot(N, normalize(vec3(1, 1,-1)))*.5+.5;\n        float light2 = dot(N, normalize(vec3(-1, 1,-1)))*.5+.5;\n        vec3 illumination = 0.5 * vec3(light1) + 0.5 * vec3(light2);\n\n        if (d.y == 1.0) color = vec3(0.9,0.1,0.1);\n        if (d.y == 2.0) color = vec3(0.2,0.8,1.);\n        if (d.y == 3.0) color = vec3(0.1,0.9,0.1);\n        color *= illumination; \n        \n\n        // Specular highlights\n        vec3 R = reflect(normalize(vec3(1.,0.,0.)), N);\n        vec3 specular = vec3(1.0) * pow(max(dot(R, rd), 0.0),10.0);\n        color += specular * 0.08;\n         \n         \n        // fake fresnel\n        float nDotV = dot(N, rd) + 1.;\n        color += nDotV * nDotV * 0.45;\n       \n        fragColor = vec4(color, 1.0);\n\n        \n    }\n        \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}