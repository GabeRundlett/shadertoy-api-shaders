{
    "Shader": {
        "info": {
            "date": "1557748122",
            "description": "Lit raytraced spheres from https://www.shadertoy.com/view/tdBXDc with voronoi texture. \n\nUse mouse input to scramble the noise.\n\nCredit to Ronja's tutorial https://www.ronja-tutorials.com/2018/09/29/voronoi-noise.html",
            "flags": 0,
            "hasliked": 0,
            "id": "tllGWj",
            "likes": 3,
            "name": "3D Voronoi-textured Spheres",
            "published": 3,
            "tags": [
                "raytracing",
                "voronoi",
                "texture",
                "sphere"
            ],
            "usePreview": 0,
            "username": "clepirelli",
            "viewed": 677
        },
        "renderpass": [
            {
                "code": "#define E 2.71828\n\n//ray data, used to get the pixel color by sending (or casting) a ray per pixel into the scene\nstruct ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n    \n//material represents the way light bounces off the surface of a primitive\nstruct material\n{\n\tfloat kSpecular;\n    float kDiffuse;\n    float glossiness;\n};\n    \n//one-color sphere\nstruct sphere\n{\n\tvec3 origin;\n    vec3 color;\n    float radius;\n    material mat;\n};\n    \n//point light\nstruct light\n{\n    vec3 origin;\n  \tfloat intensity;\n};\n    \nstruct directionalLight\n{\n    vec3 direction;\n    float intensity;\n};\n\nstruct intersection\n{\n    //distance from the origin of the ray to the intersection\n    float dist;\n    //color of the primitive at the intersection\n    vec3 color;\n    //normal of the primitive at the intersection\n    vec3 normal;\n    //material of the primitive at the intersection\n    material mat;\n};\n\nvec3 pseudorandPos(vec3 randseed)\n{\n    return abs(cos(fract(randseed * dot(sin(randseed * 242.589), vec3(42.48391588, 24.47571723, .91711988))) * 294419.4857));\n}\n\nfloat pseudorandScalar(float randseed)\n{\n\treturn fract(dot(vec3(sin(randseed*194.0154)), vec3(1043.94219, 4920.22948, 744.2918)));\n}\n\nvec3 getCell(vec3 pos)\n{\n    vec3 baseCell = floor(pos);\n    float minDistToCell = 10000.0;\n    vec3 closestCell = vec3(.0);\n    for(int i = -1; i <= 1; i++)\n    {\n        for(int j = -1; j <= 1; j++)\n        {\n            for(int k = -1; k <=1; k++)\n            {\n            \tvec3 cell = baseCell + vec3(i,j,k);\n                vec3 cellPos = cell + pseudorandPos(cell);\n                vec3 toCell = cellPos - pos;\n                float distToCell = length(toCell);\n                minDistToCell = mix(distToCell, minDistToCell, float(distToCell > minDistToCell));\n            \tclosestCell = mix(cell, closestCell, float(distToCell > minDistToCell));\n            }\n        \t\n        }\n    }\n    \n\treturn pseudorandPos(closestCell);\n}\n\nconst float renderDistance = 1.0;\n\n//return value if a ray misses a primitive\nconst intersection miss = intersection(9999.0, vec3(.0), vec3(.0), material(.0, .0, .0));\n\n\n\nconst int sphereCount = 6;\n\nconst int lightCount = 3;\n\nconst float ambientLight = .1;\n\nconst vec3 WHITE = vec3(1.0);\nconst vec3 GREEN = vec3(.0, 1.0, .0);\nconst vec3 RED = vec3(1.0, .0,.0);\nconst vec3 TEAL = vec3(.0, 1.0, 1.0);\nconst vec3 YELLOW = vec3(1.0, 1.0, .0);\n\n\n//gets the intersection between a ray and a sphere\n//from : https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/minimal-ray-tracer-rendering-spheres\nintersection sphereIntersect(in ray pRay, in sphere pSphere)\n{\n    float radius2 = pSphere.radius*pSphere.radius;\n    vec3 L = pSphere.origin - pRay.origin; \n    float tca = dot(L, pRay.direction); \n    float d2 = dot(L,L) - tca * tca; \n    if (d2 > radius2) return miss; \n    float thc = sqrt(radius2 - d2); \n    float t0 = tca - thc;\n    float t1 = tca + thc;\n    float t = min(t0, t1);\n    \n    vec3 hit = pRay.origin + pRay.direction * t;\n    vec3 coords = hit - pSphere.origin;\n    //return the distance from the ray's origin to the point\n    return intersection(t, pSphere.color, normalize(pSphere.origin - hit), pSphere.mat);\n}\n\nfloat lightAura(in ray pRay, in light pLight, sphere[sphereCount] spheres)\n{\n\t//distance from the ray's origin to the light's origin\n    float distanceToLightOrigin = distance(pLight.origin, pRay.origin);\n    \n    //projection of the ray on the light, aka the point on the ray which is the closest to the light's origin\n    vec3 rayProjection = pRay.origin + pRay.direction * distanceToLightOrigin;\n    \n    return pLight.intensity /(distance(pLight.origin, rayProjection)*100.0);\n}\n\n//mixes two intersection\nintersection mixIntersections(intersection a, intersection b, float mixRatio)\n{\n\treturn intersection\n            (\n            mix(a.dist, \tb.dist, \tmixRatio),\n            mix(a.color, \tb.color, \tmixRatio),\n            mix(a.normal, \tb.normal, \tmixRatio),\n            material\n                (\n                mix(a.mat.kSpecular, \tb.mat.kSpecular, \tmixRatio),\n                mix(a.mat.kDiffuse, \tb.mat.kDiffuse, \tmixRatio),\n                mix(a.mat.glossiness, \tb.mat.glossiness, \tmixRatio)\n\t\t\t\t)\n            );\n}\n\nfloat getDiffuse(intersection pIntersection, vec3 lightDirection)\n{\n    //clamp the dot product of the normal of the point and of the origin of the light\n\treturn clamp(dot(pIntersection.normal, lightDirection), .0, 1.0) * pIntersection.mat.kDiffuse;\n}\n\n\nfloat getSpecular(vec3 point, intersection pIntersection, ray pRay, vec3 lightDirection)\n{\n    //reflection of the light on the surface\n    vec3 reflection = reflect(lightDirection, pIntersection.normal);\n    \n    //specular term\n    //Thanks to UglySwedishFish#3207 on discord for their help with this :\n    //dot products range from -1 to 1, so the dot product of the reflection and the ray's direction\n    //has to be clamped so that a negative value doesn't get squared into a positive value\n    return pow(clamp(dot(normalize(reflection), pRay.direction), .0, 1.0), pIntersection.mat.glossiness) * pIntersection.mat.kSpecular;\n}\n\nconst float CELL_SIZE = .1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n         uv.x *= iResolution.x / iResolution.y;\n    \n    directionalLight SUN = directionalLight(normalize(vec3(-.5, -1.5, 1.5)), 2.0);\n    \n    ray currentRay = ray(vec3(uv.xy, .0), normalize(vec3(uv, 1.))); \n    \n    material mat = material(.7, .2, 32.);    \n    \n    //sphere definitions\n    sphere spheres[sphereCount] = sphere[sphereCount]\n\t(\n\t\tsphere(vec3(cos(time), .2, .5), \tWHITE,\t\t.2, mat),\n\t    sphere(vec3(.5, .2 * cos(iTime), .45), \t\tWHITE,\t.4,mat),\n        sphere(vec3(.1, sin(iTime), .5), \t\tWHITE,\t.2,mat),\n        sphere(vec3(-.7, .0, .3), \t\t\t\tWHITE,\t.1, mat),\n        sphere(vec3(sin(time), .0, .4), WHITE,\t.1, mat),\n        sphere(vec3(.0, sin(iTime), .6), \t\t\t\tWHITE,\t.5,mat)\n\t);\n    \n    //light definitions\n    light lights[lightCount] = light[lightCount]\n    (\n        light(vec3(1.0, .2, 10.0 + abs(sin(iTime)*10.0)), 1.),\n        light(vec3(.0, -2.0, 10.0), 1.),\n        light(vec3(1.0, 1.0, .0), 5.)\n    );    \n    \n    intersection finalIntersection = miss;\n    \n    //for every sphere, see whether the ray intersects it\n    for(int i = 0; i < sphereCount; i++)\n    {\n        //sphere intersection returns the distance at which the sphere is intersected\n        intersection currentIntersection = sphereIntersect(currentRay, spheres[i]);\n        \n        //if the current distance is smaller than the final distance\n        //set the final intersection to be the current intersection\n        float distanceSmaller = float(currentIntersection.dist < finalIntersection.dist);\n        finalIntersection = mixIntersections(finalIntersection, currentIntersection, distanceSmaller);\n    }\n    \n    //whether the ray missed or not\n    bool rayMissed = finalIntersection.dist >= miss.dist;\n    \n    //the point where the ray hit a primitive\n    vec3 hit = currentRay.origin + currentRay.direction * finalIntersection.dist;\n    \n    vec3 finalCol = vec3(.0);\n    \n    //sun light\n    finalCol += min(finalIntersection.color * \n        (\n            getDiffuse(finalIntersection, SUN.direction) + \n            getSpecular(hit, finalIntersection, currentRay, SUN.direction)\n            + ambientLight\n        ) * \n        SUN.intensity ,1.0)*\n        clamp(dot(finalIntersection.normal, SUN.direction), ambientLight, 1.0);\n    \n    for(int i = 0; i < lightCount; i++)\n    {        \n        //the light's intensity is its intensity variable divided by its attenuation over distance\n        float lightIntensity = lights[i].intensity / pow(distance(hit, lights[i].origin), 2.0);                \n        vec3 lightDirection = normalize(hit - lights[i].origin);\n        \n        //final color\n    \tfinalCol +=\n        \t//color of the primitive\n        \tfinalIntersection.color *\n            //lighting terms\n        \t(\n            getDiffuse(finalIntersection, lightDirection)\n            + getSpecular(hit, finalIntersection, currentRay, lightDirection)\n            + ambientLight\n            ) *\n            //intensity of the light\n            lightIntensity *\n            clamp(dot(finalIntersection.normal, lightDirection), ambientLight, 1.0);\n    }\n    \n    vec3 col = getCell((hit + iMouse.xyx)/CELL_SIZE);\n    finalCol *= col;\n\n\t//background color\n\tvec3 bgCol = vec3(.4, .2, .9);\n    bgCol = clamp(bgCol, .0, 1.0);\n    //select between the background color (if the ray missed) and the final color (if the ray hit)\n    finalCol = mix(finalCol, bgCol, float(rayMissed));\n    \n    // Output to buffer\n    fragColor = vec4(finalCol, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}