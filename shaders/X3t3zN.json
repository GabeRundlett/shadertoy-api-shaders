{
    "Shader": {
        "info": {
            "date": "1717502619",
            "description": "ha ha ha",
            "flags": 0,
            "hasliked": 0,
            "id": "X3t3zN",
            "likes": 5,
            "name": "Sapphire ocean",
            "published": 3,
            "tags": [
                "2d",
                "noise"
            ],
            "usePreview": 0,
            "username": "DeMaCia",
            "viewed": 129
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n\nfloat randomNoise(vec2 p)\n{\n    return fract((sin(dot(p,vec2(127.1,311.7)))*43758.5453123));\n}\n\nfloat BINoise(vec2 p)\n{//Bilinear interpolation\n\n    float tiles = 50.;\n\n    vec2 base = floor(p/tiles);\n    p = fract(p/tiles);\n    vec2 f = smoothstep(0., 1., p);\n\n    float q11 = randomNoise(base);\n    float q12 = randomNoise(vec2(base.x, base.y+1.));\n    float q21 = randomNoise(vec2(base.x+1., base.y));\n    float q22 = randomNoise(vec2(base.x+1., base.y+1.));\n\n    float r1 = mix(q11, q21, f.x);\n    float r2 = mix(q12, q22, f.x);\n\n    return mix (r1, r2, f.y);\n} \n\n\nvec2 gradn(vec2 p)\n{\n\tfloat ep = .09;\n\tfloat gradx = BINoise(vec2(p.x+ep, p.y))-BINoise(vec2(p.x-ep, p.y));\n\tfloat grady = BINoise(vec2(p.x, p.y+ep))-BINoise(vec2(p.x, p.y-ep));\n\treturn vec2(gradx,grady);\n}\n\nmat2 makeRotM2(float theta){\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, -s, s, c);\n}\n\nfloat perlinNoise(vec2 p)\n{\n    float t = iTime*2.;\n\tfloat z = 2.;\n\tfloat rz = 0.;\n\tvec2 bp = p;\n\n\tfor (float i = 1.; i < 7.; i++ )\n\t{\n\t\tp += t*1.6;\n\t\t\n\t\tbp += t*1.9;\n\t\t\n\t\tvec2 gr = gradn(i*p*.34+t*1.)*100.*100.;\n\t\t\n\t\tgr *= makeRotM2(i*.05*t);\n\t\t\n\t\tp += gr;\n\t\t\n\t\trz+= (sin(BINoise(p)*7.)*0.5+0.5)/z;\n\t\t\n\t\tp = mix(bp, p, .77);\n\t\t\n\t\tz *= 1.4;\n\t\tp *= 2.;\n\t\tbp *= 1.9;\n\t}\n\treturn rz;\n}\n\n\nvec3 flow(vec2 fragCoord, float sx )\n{\n    float t = iTime*2.;\n    float ry = 2.*((fragCoord.y/iResolution.y)-.5);\n    fragCoord.y *= tan(mix(PI/2.-.1, PI/4.+.1, abs(ry)));\n\n    vec2 d1 = vec2(t*1., t*.5);\n    vec2 d2 = vec2(t*2., t*-4.);\n    vec2 d3 = vec2(t*-6., t*8.);\n\n    float p1 = perlinNoise(fragCoord - d1);\n    float p2 = perlinNoise(fragCoord + d2);\n    float p3 = perlinNoise(fragCoord - d3);\n\n    float pn = mix(p1, p2, p3);\n    \n    vec3 color1 = vec3(.25, 0.75, 1.);\n    vec3 color2 = vec3(.5, .5, .9);\n\n    vec3 color = vec3(mix(color1, color2, pn));\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    float w = .2/tan(mix(PI/2.-.4, PI/4., abs(ry)));\n    float s = smoothstep(sx-w-.5, sx+w, uv.x );\n    color *= 1.+s*.4;\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 col = (1.5- uv.y) *vec3(.25, 0.75, 1.);\n    \n    vec2 sunPos = vec2(1.4, .75);\n    float sunR = .06;\n    vec3 sunHalo = vec3(2., 1.25, .5);\n    col += sunHalo * (sunR / distance(uv, sunPos));\n    \n    float height = abs(sin(uv.x * 10.25 )*cos(uv.x * 5.65 )*.18);\n    height *= 1./(uv.x+0.425);\n    float horizon = smoothstep(-.015, .015, .5 - uv.y + height) * smoothstep(-0.05, 0., uv.y-.5);\n\n    col -= horizon * ((.5-uv.y)/(height-.5)) * 0.555;\n    \n    float da = smoothstep(0.1, 0.2, uv.y-.25);\n        \n    col = col*da +  flow(fragCoord, sunPos.x) *(1.-da);\n\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}