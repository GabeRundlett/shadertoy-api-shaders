{
    "Shader": {
        "info": {
            "date": "1579086048",
            "description": "Twisting tunnel.",
            "flags": 0,
            "hasliked": 0,
            "id": "WtVGDw",
            "likes": 7,
            "name": "Twisted tunnel (checkerboard v3)",
            "published": 3,
            "tags": [
                "procedural",
                "tunnel",
                "visualization",
                "fast",
                "checkerboard",
                "glmixer"
            ],
            "usePreview": 0,
            "username": "tombla",
            "viewed": 506
        },
        "renderpass": [
            {
                "code": "#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define COLOR1 vec3(0.9, 0.9, 0.8)\n#define COLOR2 vec3(0.05, 0.05, 0.05)\n#define LIGHTCOLOR  vec3(1., 1., 1.)\n\n#define ARMS 10.\n#define DENSITY 3.\n#define ANGLE_SPEED 3.\n#define ANGLE_TEMPO 2.\n#define SPEED 2.\n#define PULSE_SPEED 4.\n#define SMOOTH 0.04\n\nfloat smoothstepCheckerboard(in vec2 uv) {\n    // Shift, as fract gives 0..1 and we will smooth\n    // around 0.25 and 0.75.\n    uv = fract(uv + 0.25);\n    float sm2 = SMOOTH * 0.5;\n    // p01 oscillates between 0 and 1.\n    vec2 p01 =\n        smoothstep(0.25 - sm2, 0.25 + sm2, uv) -\n        smoothstep(0.75 - sm2, 0.75 + sm2, uv);\n    // pn11 oscillates between -1 and 1.\n    vec2 pn11 = (p01 - 0.5) * 2.;\n    // This results in smoothed 0..1 transitions.\n    // We take advantage of the fact that multiplication\n    // of -1/1 behaves like XOR. Then we rescale\n    // -1..1 result of the multiplication to 0..1.\n    return 0.5 - 0.5 * pn11.x * pn11.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2\n        R = iResolution.xy,\n        // Cartesian [-1, 1] along shorter axis.\n        uv = (2. * fragCoord - R) / min(R.x, R.y);\n    float\n        T = iTime,\n        // Angle [-PI, PI] and radius.\n        a = atan(uv.x, uv.y),\n        r = length(uv),\n        // Twisted angle\n        w = a - sin(1. / r) * r * ANGLE_SPEED * sin((T - 1./r) / ANGLE_TEMPO);\n\n    vec2 polar = vec2(\n        w * ARMS / PI2,\n        1. / r * DENSITY + T * SPEED \n    );\n\n    // vec3 checker = mix(COLOR1, COLOR2, smoothCheckerboard(polar));\n    vec3 checker =\n         mix(COLOR1, COLOR2,\n         smoothstepCheckerboard(polar));\n    // Light in the center.\n    float light = smoothstep(0.7 + 0.3 * sin(T * PULSE_SPEED), 0.2, r);\n\n    vec3 color = mix(checker, LIGHTCOLOR, light);\n    // Approximate output gamma correction.\n    fragColor = vec4(pow(color, vec3(1./2.2)), 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}