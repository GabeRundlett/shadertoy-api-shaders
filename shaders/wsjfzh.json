{
    "Shader": {
        "info": {
            "date": "1589582677",
            "description": "Shader test: Implemented n_reflections based on object normal. Also, have Lightsource and shadows which are based on the distance to the object. A camera with basic functionality has also been implemented. Very inefficient..",
            "flags": 0,
            "hasliked": 0,
            "id": "wsjfzh",
            "likes": 1,
            "name": "RayMarching - BasicExample",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "SimonParschat",
            "viewed": 304
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DIST  1000.\n#define SURF_DIST .01\n#define N_SPHERES 2\n#define N_PLANES 1\n#define N_BOXES 0\n#define N_REFLECTIONS 0\n#define SOURCE_TO_CAM_DISTANCE 10.\n#define M_PI 3.1415926535897932384626433832795\n\nstruct Sphere  {    \n    vec3  spherePosition;\n    vec3  sphereColor;\n    float sphereRadius;\n};\n    \nstruct Plane {\n    vec3  planeColor;\n    float planeY;\n};\n\nstruct Box {\n    vec3 boxPosition;\n    vec3 boxSize;\n    vec3 boxColor;\n};\n\nfloat GetSphereDistance(in Sphere spheres[N_SPHERES], in vec3 p, out int sphereID) {\n    float minLen = 10000.;\n    sphereID = 0;\n    for (int i = 0; i < N_SPHERES; i++) {\n        float sLen = length(p - spheres[i].spherePosition) - spheres[i].sphereRadius;\n        minLen = min(minLen, sLen);\n        sphereID = (minLen == sLen) ? i : sphereID;\n    }\n    return minLen;\n}\n\nfloat GetPlaneDistance(in Plane planes[N_PLANES], in vec3 p, out int planeID) {\n    float minLen = 10000.;\n    planeID = 0;\n    for (int i = 0; i < N_PLANES; i++) {\n        float pLen = abs(p.y - planes[i].planeY);\n        minLen     = min(minLen, pLen);\n        planeID    = (minLen == pLen) ? i : planeID;\n    }\n    return minLen;\n}\n\nfloat GetBoxDistance(in Box box, in vec3 p) {\n    return length(max(abs(p) - box.boxSize, 0.));\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n   \n    return mat2(c, -s, s, c);\n}\n\nvec3 RotateAboutNormal(in vec3 rayNorm, in vec3 objNorm) {\n    float angle     =  M_PI;\n    rayNorm         = -rayNorm;\n    vec3   paraComp = (dot(rayNorm,objNorm) / dot(objNorm,objNorm))*objNorm;\n    vec3   perpComp =  rayNorm - paraComp;\n    vec3   w        =  cross(objNorm, perpComp);\n    float  x1       =  cos(angle) / length(perpComp);\n    float  x2       =  sin(angle) / length(w);\n    \n    vec3 perpObjAng =  length(perpComp) * (x1 * perpComp + x2 * w);\n    vec3 rotVec     =  perpObjAng + paraComp;\n    return rotVec;\n}\n\nfloat GetDist(in vec3 p, out vec3 objColor) {\n    int sphereID = 0;\n    int planeID = 0;\n    \n    Sphere sphere[N_SPHERES] = Sphere[N_SPHERES](\n        \tSphere(vec3( -.5,  1.,  0.),  vec3(0.5,0.8,0.5),  .4),\n    \t\tSphere(vec3(  .5,  1.,  0.),  vec3(0.5,0.5,0.8),    .4) );\n        \n    Plane  plane[N_PLANES] = Plane[N_PLANES](\n        \tPlane(vec3(1.,1.,1.), \t\t\t 0.  ));\n    //Box    box \t = Box(   vec3(-5., 2., 5.), vec3(.5, .5, .5), vec3(1.,.8,.8) );\n    \n    float SphereDist  = GetSphereDistance(sphere, p, sphereID);\n    float PlaneDist   = GetPlaneDistance(plane, p, planeID); \n    float d = min(SphereDist, PlaneDist);\n    \n    if (d == SphereDist)     { objColor = sphere[sphereID].sphereColor; }\n    else if (d == PlaneDist) { objColor = plane[planeID].planeColor; }\n    //else if (d == BoxDistance) { objColor = box.boxColor; }\n        \n    return d;\n}\n\nfloat RayMarch(in vec3 ro, in vec3 rd, out vec3 objCol) {\n\tfloat pointPos = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = ro + rd * pointPos;\n        float dS = GetDist(p, objCol);\n        pointPos += dS;\n        \n        if ( pointPos > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return pointPos;\n}\n\nvec3 GetNormal(in vec3 p) {\n    vec3 cOlDummy = vec3(0);\n    float d = GetDist(p, cOlDummy);\n    vec2  e = vec2(.01,0);\n    \n    vec3 n = d - vec3(\n        GetDist(p - e.xyy, cOlDummy),\n        GetDist(p - e.yxy, cOlDummy),\n        GetDist(p - e.yyx, cOlDummy));\n    return normalize(n);\n}\n\nfloat GetLight(in vec3 p) {\n    vec3 cOlDummy = vec3(0.);\n    vec3 lightPosition = vec3(0,5,0);\n    lightPosition.xz += vec2(sin(iTime * .5) * 10.,cos(iTime * .5) * 10.);\n    \n    vec3 l = normalize(lightPosition - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p + n*SURF_DIST*1.5, l, cOlDummy);\n    \n    if (d < length(lightPosition - p)) dif *= 0.3* clamp(d, 0.,1.);\n\treturn dif;\n}\n\nvec3 RayDirection(in vec3 pixelPos, in vec3 intermediatePlane) {    \n    vec3 rDir = normalize(pixelPos - intermediatePlane);\n    return rDir;\n}\n\nfloat RayReflection(in vec3 p, in vec3 rayNorm, out vec3 refCol, in int N){\n    float d = 0.;\n    for (int i = 0; i < N; i++) {\n        vec3 objNormal = GetNormal(p);\n        vec3 refNormal = RotateAboutNormal(rayNorm, objNormal);\n       \tvec3 coL = vec3(0.);    \n       \t\n        d = RayMarch(p + objNormal*SURF_DIST*1.6, refNormal, coL);\n        refCol += (coL * 1./ float(N))*.9;\n        p += refNormal*d;\n    }\n        \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 colorOfPixel = vec3(0.);\n    \n    vec3 cameraPosition = vec3(0.,5.,-20.);\n    vec3 viewNorm = normalize(vec3(0.,1.,0.) - cameraPosition);\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    vec3 camRightNorm = normalize(cross(vec3(0.,-1.,0.), viewNorm));\n    vec3 camUpNorm = normalize(cross(camRightNorm, viewNorm));\n\n    vec3 ro = (-camRightNorm*uv.x)+(camUpNorm*uv.y) + cameraPosition;\n    vec3 ri = (-camRightNorm*uv.x * 0.5) + (camUpNorm*uv.y * 0.5) + cameraPosition + viewNorm * (-SOURCE_TO_CAM_DISTANCE*.5);\n    vec3 rd = RayDirection(ro, ri);\n    \n    float d = RayMarch(ro, rd, colorOfPixel);\n    vec3 p = ro + rd*d;\n    vec3 dumCol = colorOfPixel;\n    if (N_REFLECTIONS != 0) {\n    \tfloat dRef = RayReflection(p, rd, dumCol, N_REFLECTIONS);\n    \tcolorOfPixel = (colorOfPixel + dumCol) * (1./float(N_REFLECTIONS)) ;\n    }\n        \n\tfloat dif = GetLight(p);\n    \n    fragColor = vec4(colorOfPixel,1.0) * dif;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}