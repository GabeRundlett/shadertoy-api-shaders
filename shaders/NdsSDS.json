{
    "Shader": {
        "info": {
            "date": "1619151693",
            "description": "Dupin Cyclides quartic surface raytraced with reflections.\nbased on\nmla@[url]https://www.shadertoy.com/view/3tVcWV[/url]\nFabriceNeyret2@[url]https://www.shadertoy.com/view/4ljyWc[/url]",
            "flags": 48,
            "hasliked": 0,
            "id": "NdsSDS",
            "likes": 11,
            "name": "Mirrored Dupin Cyclides",
            "published": 3,
            "tags": [
                "reflection",
                "torus",
                "sphere",
                "raytrace",
                "cubic",
                "quartic",
                "lanczos"
            ],
            "usePreview": 0,
            "username": "cyperus",
            "viewed": 599
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"Mirrored Dupin Cyclides\" created by Colling Patrik (cyperus) in 2020\n//\n// based on original code \n// - mla --- Goursat Quartic Surface --- https://www.shadertoy.com/view/wsXGWS\n// - FabriceNeyret2 --- compared interpolation --- https://www.shadertoy.com/view/4ljyWc\n//\n// documentation:\n// - https://mathcurve.com/surfaces.gb/cycliddedupin/cyclidededupin.shtml\n// - https://en.wikipedia.org/wiki/Dupin_cyclide \n//\n// Controls:\n// <mouse>: change view direction\n// <up/down>: zoom\n// 'c': clip at x = 0\n// 'g': show grid\n// 'r': do rotation\n// 'm': mirror surface\n// 's': no reflections\n// 'p': plain colouring\n// 'e': toggle between elliptic-hyperbolic and parabolic cyclide.\n//\n// Quartic surfaces with rotational symmetry. Surface (including normals)\n// is raytraced using analytic solution to quartic due to Lanczos with\n// cubic solver from Numerical Recipes, plus some Newton-Raphson polishing.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint AA = 1;\n\n// Lighting\nvec3 light;\nfloat ambient;\nfloat diffuse;\nfloat specular = 0.4;\nfloat specularpow = 4.0;\nvec3 specularcolor = vec3(1);\n\n// Animation\nfloat animvelocity = 0.25;    \n//#define NEAREST\n//#define LINEAR\n#define CUBICLINEAR\n//#define CATMULL    \n\nfloat evalquadratic(float x, float A, float B, float C) {\n  return (A*x+B)*x+C;\n}\n\nfloat evalcubic(float x, float A, float B, float C, float D) {\n  return ((A*x+B)*x+C)*x+D;\n}\n\n// Quadratic solver from Kahan\nint quadratic(float A, float B, float C, out vec2 res) {\n  float b = -0.5*B, b2 = b*b;\n  float q = b2 - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    res[0] = C/A;\n    res[1] = -res[0];\n  } else {\n    res[0] = C/r;\n    res[1] = r/A;\n  }\n  return 2;\n}\n\n// Numerical Recipes algorithm for solving cubic equation\nint cubic(float a, float b, float c, float d, out vec3 res) {\n  if (a == 0.0) {\n    return quadratic(b,c,d,res.xy);\n  }\n  if (d == 0.0) {\n    res.x = 0.0;\n    return 1+quadratic(a,b,c,res.yz);\n  }\n  float tmp = a; a = b/tmp; b = c/tmp; c = d/tmp;  // TODO: if(very large roots) {solve for the reciprocal roots}\n  // solve x^3 + ax^2 + bx + c = 0\n  float Q = (a*a-3.0*b)/9.0;\n  float R = (2.0*a*a*a - 9.0*a*b + 27.0*c)/54.0;\n  float R2 = R*R, Q3 = Q*Q*Q;\n  if (R2 < Q3) {\n    float X = clamp(R/sqrt(Q3),-1.0,1.0);\n    float theta = acos(X);\n    float S = sqrt(Q); // Q must be positive since 0 <= R2 < Q3\n    res[0] = -2.0*S*cos(theta/3.0)-a/3.0;\n    res[1] = -2.0*S*cos((theta+2.0*PI)/3.0)-a/3.0;\n    res[2] = -2.0*S*cos((theta+4.0*PI)/3.0)-a/3.0;\n    return 3;\n  } else {\n    float alpha = -sgn(R)*pow(abs(R)+sqrt(R2-Q3),0.3333);\n    float beta = alpha == 0.0 ? 0.0 : Q/alpha;\n    res[0] = alpha + beta - a/3.0;\n    return 1;\n  }\n}\n\nfloat qcubic(float B, float C, float D) {\n  vec3 roots;\n  int nroots = cubic(1.0,B,C,D,roots);\n  // Sort into descending order\n  if (nroots > 1 && roots.x < roots.y) roots.xy = roots.yx;\n  if (nroots > 2) {\n    if (roots.y < roots.z) roots.yz = roots.zy;\n    if (roots.x < roots.y) roots.xy = roots.yx;\n  }\n  // And select the largest\n  float psi = roots[0];\n  // There _should_ be a positive root, but sometimes the cubic\n  // solver doesn't find it directly (probably a double root\n  // around zero).\n  if (psi < 0.0) assert(evalcubic(psi,1.0,B,C,D) < 0.0);\n  // If so, nudge in the right direction\n  psi = max(1e-6,psi);\n  // and give a quick polish with Newton-Raphson\n  for (int i = 0; i < 3; i++) {\n    float delta = evalcubic(psi,1.0,B,C,D)/evalquadratic(psi,3.0,2.0*B,C);\n    psi -= delta;\n  }\n  return psi;\n}\n\n// The Lanczos quartic method\nint lquartic(float c1, float c2, float c3, float c4, out vec4 res) {\n  float alpha = 0.5*c1;\n  float A = c2-alpha*alpha;\n  float B = c3-alpha*A;\n  float a,b,beta,psi;\n  psi = qcubic(2.0*A-alpha*alpha, A*A+2.0*B*alpha-4.0*c4, -B*B);\n  psi = max(0.0,psi);\n  a = sqrt(psi);\n  beta = 0.5*(A + psi);\n  if (psi <= 0.0) {\n    b = sqrt(max(beta*beta-c4,0.0));\n  } else {\n    b = 0.5*a*(alpha-B/psi);\n  }\n  int resn = quadratic(1.0,alpha+a,beta+b,res.xy);\n  vec2 tmp;\n  if (quadratic(1.0,alpha-a,beta-b,tmp) != 0) { \n    res.zw = res.xy;\n    res.xy = tmp;\n    resn += 2;\n  }\n  return resn;\n}\n\nint quartic(float A, float B, float C, float D, float E, out vec4 roots) {\n  int nroots;\n  // Solve for the smallest cubic term, this seems to give the least wild behaviour.\n  if (abs(B/A) < abs(D/E)) {\n    nroots = lquartic(B/A,C/A,D/A,E/A,roots);\n  } else {\n    nroots = lquartic(D/E,C/E,B/E,A/E,roots);\n    for (int i = 0; i < nroots; i++) {\n      roots[i] = 1.0/roots[i];\n    }\n  }\n  assert(nroots == 0 || nroots == 2 || nroots == 4);\n  return nroots;\n}\n\nstruct Surface {\n  vec4 params;\n  vec3 p;\n};\n\n\n// https://en.wikipedia.org/wiki/Dupin_cyclide\n// https://mathcurve.com/surfaces.gb/cycliddedupin/cyclidededupin.shtml\n\nint elhypcyc_surface(Surface surface, in vec3 o, in vec3 d, out vec4 roots) {\n    // F : ( x^2+y^2+z^2 +b0^2-r0^2 )^2 -4*(( a0*x-c0*r0 )^2 + b^2*y^2) = 0\n    \n    // float not used = surface.params[0];\n    float a0 = surface.params[1];\n\tfloat c0 = surface.params[2];     \n\tfloat r0 = surface.params[3];\n    \n    // parameter constraints\n    a0 = abs(a0); // semi major axis of the ellipse\n    c0 = abs(c0); // linear eccentricity of the ellipse\n    r0 = abs(r0); // radius tangent spheres at (0,-+b) of the ellipse\n    if (c0 > a0) c0 = a0;\n    float b0 = sqrt(a0*a0-c0*c0); // semi minor axis of the ellipse    \n    \n    // commun factors\n    float od = dot(d,o);\n    float dd = dot(d,d); // dd = 1; unitvector\n    float e0 = dot(o,o) + b0*b0-r0*r0;\n    float f0 = a0*o.x-c0*r0;\n    float b02 = b0*b0;\n        \n    // A * t^4 + B * t^3 + C * t^2 + D * t^1 + E = 0\n    float A =    dd*dd;\n    float B = 4.*dd*od;\n    float C = 2.*(2.*od*od+dd*e0) -4.*( a0*a0*d.x*d.x       +b02*d.y*d.y );\n    float D = 4.*od          *e0  -8.*( a0   *d.x    *f0    +b02*d.y    *o.y );\n    float E =              e0*e0  -4.*(               f0*f0 +b02        *o.y*o.y );  \n    return quartic(A,B,C,D,E,roots);\n}\n\nvec3 elhypcyc_normal(Surface surface, vec3 p) {\n    // float not used = surface.params[0];\n    float a0 = surface.params[1];\n\tfloat c0 = surface.params[2];     \n\tfloat r0 = surface.params[3];\n    \n    // parameter constraints\n    a0 = abs(a0); // semi major axis of the ellipse\n    c0 = abs(c0); // linear eccentricity of the ellipse\n    r0 = abs(r0); // radius tangent spheres at (0,-+b) of the ellipse\n    if (c0 > a0) c0 = a0;\n    float b0 = sqrt(a0*a0-c0*c0); // semi minor axis of the ellipse   \n    \n    // grad(F)\n    float e0 = dot(p,p)+b0*b0-r0*r0;           \n    return 4.*(e0*p -2.*vec3(a0*(a0*p.x-c0*r0), b0*b0*p.y, 0.));\n}\n\nint elhypcyc_nanimparams = 12;\nvec4 elhypcyc_animparams(int i) {\n  // cyclide vec4(not used,a0,c0,r0)\n  if (i == 0) return vec4(0., 1.0, 0.0, 0.3); // torus \n  if (i == 1) return vec4(0., 1.0, 0.0, 0.3);\n  if (i == 2) return vec4(0., 1.0, 1.0, 0.0); // symmetric spheres \n  if (i == 3) return vec4(0., 1.0, 1.0, 0.0);    \n  if (i == 4) return vec4(0., 1.0, 0.3, 0.0); // symmetric horns \n  if (i == 5) return vec4(0., 1.0, 0.3, 0.0);\n  if (i == 6) return vec4(0., 1.0, 0.3, 0.3); // horn-ring \n  if (i == 7) return vec4(0., 1.0, 0.3, 0.3);\n  if (i == 8) return vec4(0., 1.0, 0.3, 1.0); // ring-spindel \n  if (i == 9) return vec4(0., 1.0, 0.3, 1.0);\n  if (i == 10)return vec4(0., 1.0, 0.0, 1.5); // torus-spindle\n  else        return vec4(0., 1.0, 0.0, 1.5);\n  \n}\n\n// https://en.wikipedia.org/wiki/Dupin_cyclide\n// https://mathcurve.com/surfaces.gb/cycliddedupin/cyclidededupin.shtml\nint paracyc_surface(Surface surface, in vec3 o, in vec3 d, out vec4 roots) {    \n    // F : (x+0.5*k0-1) * (x^2+y^2+z^2 -0.25*k0^2*p0^2) + p0*z^2 = 0\n    \n    // float not used = surface.params[0];\n    // float not used = surface.params[1];\n\tfloat p0 = surface.params[2]; // relation of the diameters of the two holes   \n\tfloat k0 = surface.params[3]; // shape of parabolas  \n    \n    // commun factors\n    k0 *= 0.5;\n    float d0 = -k0*k0*p0*p0;\n    float c0 = p0*(k0-1.);\n    float dd = dot(d,d); // dd = 1; unitvector\n    float od = dot(o,d);\n    float a0 = dot(o,o)+d0;\n    float b0 = o.x+c0;\n        \n    // A * t^3 + B * t^2 + C * t^1 + D = 0\n    float A = d.x   *dd;\n    float B = d.x*2.*od + b0   *dd + p0   *d.z*d.z;\n    float C = d.x   *a0 + b0*2.*od + p0*2.*o.z*d.z;\n    float D =           + b0   *a0 + p0   *o.z*o.z;\n    vec3 res; int resn = cubic(A, B, C, D, res);\n    roots = vec4(res,0.); return resn;\n}\n\nvec3 paracyc_normal(Surface surface, vec3 p) {\n    // float not used = surface.params[0];\n    // float not used = surface.params[1];\n\tfloat p0 = surface.params[2]; // relation of the diameters of the two holes   \n\tfloat k0 = surface.params[3]; // shape of parabolas \n    \n    // commun factors\n    k0 *= 0.5;\n    float pp = dot(p,p);\n    float d0 = -k0*k0*p0*p0;\n    float c0 = p0*(k0-1.);\n    //float f0 = p.x*(p.x+c0);\n    float f0 = p.x+c0; // TEST:\n    \n    // grad(F)           \n    return vec3(pp+d0+2.*p.x*f0, 2.*p.y*f0, 2.*p.z*(f0+p0));\n}\n\nint paracyc_nanimparams = 10;\nvec4 paracyc_animparams(int i) {\n  // vec4(not used,not used,p0,k0)\n  if (i == 0)  return vec4(0., 0., 1.0,-1.0); // ring equal diameters\n  if (i == 1)  return vec4(0., 0., 1.0,-1.0); \n  if (i == 2)  return vec4(0., 0., 1.0, 0.0); // ring equal diameters\n  if (i == 3)  return vec4(0., 0., 1.0, 0.0);  \n  if (i == 4)  return vec4(0., 0., 1.0, 0.5); // ring equal diameters\n  if (i == 5)  return vec4(0., 0., 1.0, 0.5); \n  if (i == 6)  return vec4(0., 0., 1.0, 1.0); // ring-horn \n  if (i == 7)  return vec4(0., 0., 1.0, 1.0);\n  if (i == 8)  return vec4(0., 0., 1.0, 2.0); // horn\n  else         return vec4(0., 0., 1.0, 2.0);\n  }\n\nvec3 applylighting(vec3 baseColor, vec3 p, vec3 n, vec3 r) {\n  if (dot(r,n) > 0.0) n = -n; // Face forwards\n  vec3 c = baseColor*ambient;\n  c += baseColor*diffuse*(max(0.0,dot(light,n)));\n  float s = pow(max(0.0,dot(reflect(light,n),r)),specularpow);\n  c += specular*s*specularcolor;\n  return c;\n}\n\nstruct Result {\n  vec3 p;\n  vec3 n;\n  vec3 color;\n  float t;\n};\n\nfloat gridline(vec3 p) {\n  // Draw some gridlines on surface\n  vec3 t = fract(p*4.0);\n  t = min(t,1.0-t);\n  float d = min(t.x,min(t.y,t.z));\n  return smoothstep(0.02,0.025,d);\n}\n\nint dosurface(Surface surface, vec3 p0, vec3 r, out vec4 roots) {\n  if (!key(CHAR_E))\n    return elhypcyc_surface(surface, p0, r, roots);\n  else\n    return paracyc_surface(surface, p0, r, roots);  \n\n}\n  \nvec3 donormal(Surface surface, vec3 p0) {\n  if (!key(CHAR_E))\n      return elhypcyc_normal(surface, p0);\n  else\n      return paracyc_normal(surface, p0);  \n}\n\nvec4 animparams(int i ) {\n  if (!key(CHAR_E))\n      return elhypcyc_animparams(i);\n  else\n      return paracyc_animparams(i);  \n}\n\nbool solve(Surface surface, vec3 p0, vec3 r, float tmin, inout Result result) {\n  vec4 roots;\n  int nroots = dosurface(surface,p0,r,roots);\n  // Find smallest root greater than tmin.\n  float t = result.t;\n  for (int i = 0; i < 4; i++) {\n    if (i == nroots) break;\n    if (roots[i] > tmin && roots[i] < t) {\n      vec3 p = p0+roots[i]*r;\n      if (!key(CHAR_C) || p.x > 0.0) { // clip at x == 0\n        t = roots[i];\n      }\n    }\n  }\n  if (t == result.t) return false;\n  vec3 p = p0 + t*r;\n  vec3 n = donormal(surface, p);\n  if (dot(n,r) > 0.0) n = -n;\n  n = normalize(n);\n  vec3 basecolor = abs(n);\n  basecolor *= gridline(p);\n  if (key(CHAR_P)) basecolor = vec3(0.8);\n  result.p = p; result.n = n; result.color = applylighting(basecolor,p,n,r);\n  return true;\n}\n\nSurface surface;\n\nvec3 scene(vec3 p, vec3 r) {\n  vec3 color = vec3(0);\n  float att = 1.0;\n  for (int i = 0; i < 6; i++) {\n    // If we've hit the surface some distance from origin,\n    // stop reflecting.\n    if (dot(p,p) > 1000.0) break;\n    // Solve from closest point to origin.\n    // This makes p.r = 0.\n    float tmin = -dot(p,r);\n    p += tmin*r;\n    Result res = Result(vec3(0),vec3(0),vec3(0),1e8);\n    if (!solve(surface,p,r,-tmin,res)) break;\n    if (key(CHAR_P) || key(CHAR_S)) return res.color;\n    color += att*res.color;\n    att *= 0.5;\n    p = res.p;\n    r = reflect(r,res.n);\n    p += 0.001*r;\n  }\n  if (key(CHAR_P)) return vec3(0.5);\n  if (key(CHAR_M)) return texture(iChannel1,r).xyz;  \n  return color + att*pow(abs(r),vec3(2));\n}\n\n\nint imod(int n, int m) {\n    return n-n/m*m;\n}\n\n// by FabriceNeyret2 --- compared interpolation --- https://www.shadertoy.com/view/4ljyWc\nvec4 nearest(vec4 v1) {\n    return v1;\n    }\n\nvec4 linear(vec4 v1, vec4 v2, float t) {\n    return mix(v1,v2,t);\n    }\n\nvec4 cubiclinear(vec4 v1, vec4 v2, float t) {\n    return mix(v1,v2,smoothstep(0.,1.,t));\n    }\n\nvec4 catmull(vec4 v0, vec4 v1, vec4 v2, vec4 v3, float t) {\n\tvec4 A0 = mix( v0, v1, t+1.),\n\t     A1 = mix( v1, v2, t),\n\t     A2 = mix( v2, v3, t-1.),\n         B0 = mix( A0, A1, .5*t + .5),\n\t     B1 = mix( A1, A2, .5*t);\n\treturn mix( B0, B1, t);\n    }\n\nvoid init() {\n  float ttime = animvelocity*iTime;\n  float rtime = floor(ttime);\n  ttime -= rtime;\n  \n  int nanimparams;\n  if (!key(CHAR_E)) {\n    nanimparams = elhypcyc_nanimparams; }\n  else{\n    nanimparams = paracyc_nanimparams; }\n  \n  vec4 params;\n  int isurface = max(0,keycount(KEY_RIGHT)-keycount(KEY_LEFT));\n  isurface %= nanimparams;+1;\n  if (isurface == 0) {\n    // get parameter id for interpolation\n    ivec4 param_id = ivec4(\n        int(rtime-1.0)%nanimparams,\n        int(rtime)%nanimparams,\n        int(rtime+1.0)%nanimparams,\n        int(rtime+2.0)%nanimparams);\n    // get parameter values with selected interpolation\n    #ifdef NEAREST\n    params = nearest(animparams(param_id[2]));\n    #endif\n    #ifdef LINEAR    \n    params = linear(animparams(param_id[1]),\n                    animparams(param_id[2]), ttime);\n    #endif\n    #ifdef CUBICLINEAR \n    params = cubiclinear(animparams(param_id[1]),\n                         animparams(param_id[2]), ttime);\n    #endif\n    #ifdef CATMULL \n    params = catmull(animparams(param_id[0]),\n                     animparams(param_id[1]),\n                     animparams(param_id[2]),\n                     animparams(param_id[3]), ttime);\n    #endif\n  } else {\n    params = animparams(isurface-1);\n  }\n  surface = Surface(params,vec3(0));\n}\n\n// GUI related code starts here\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) {\n    float t = iTime + 3.5;\n    p.yz = rotate(p.yz, 0.1*t);\n    p.zx = rotate(p.zx, 0.222*t);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  light = vec3(1,1,-1);\n  ambient = 0.4;\n  diffuse = 1.0-ambient;\n  specular = 0.8;\n  specularpow = 10.0;\n\n  float scale = 1.0;\n  float camera = 4.0;\n  \n  vec3 p = vec3(0.0, 0.0, -camera);\n  p *= 0.1*float(10+keycount(KEY_DOWN)-keycount(KEY_UP));\n  p = transform(p);\n  light = transform(light);\n  light = normalize(light);\n  init();\n  vec3 color = vec3(0);\n  for (int i = 0; i < AA; i++) {\n     for (int j = 0; j < AA; j++) {\n       vec2 uv = scale*(2.0*(fragCoord.xy+vec2(i,j)/float(AA)) - iResolution.xy)/iResolution.y;\n       vec3 r = normalize(vec3(uv, 2.0));\n       r = transform(r);\n       r = normalize(r);\n       color += scene(p,r);\n     }\n  }\n  color /= float(AA*AA);\n  color = pow(color,vec3(0.4545));\n  if (alert) color.x = 1.0;\n  fragColor = vec4(color,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n// Common\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n// Debug\nbool alert = false;\n\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\n#define assert(x)\n\nbool eq(float x, float y) {\n  return abs(x-y) < 1e-4;\n}\n\nbool eq(vec4 p, vec4 q) {\n  return eq(p.x,q.x) && eq(p.y,q.y) && eq(p.z,q.z) && eq(p.w,q.w);\n}\n\nbool eq(mat4 m, mat4 n) {\n  return eq(m[0],n[0]) && eq(m[1],n[1]) && eq(m[2],n[2]) && eq(m[3],n[3]);\n}\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_X = 88;\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nfloat sgn(float x) {\n  return x < 0.0 ? -1.0: 1.0; // Return 1 for x == 0\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}