{
    "Shader": {
        "info": {
            "date": "1461436582",
            "description": "julia set visualization\n",
            "flags": 0,
            "hasliked": 0,
            "id": "XsdGzs",
            "likes": 3,
            "name": "Julia3D",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "Varcho",
            "viewed": 671
        },
        "renderpass": [
            {
                "code": "#define EPSILON 0.01\n#define BOUNDING_RAD 3.0\n#define TEX_SCALE 10.0\n\nvec3 getNormal(vec3 pos, vec4 c, float k);\n\nvec4 quatMultiply(vec4 a, vec4 b) {\n    return vec4(a.x * b.x - a.y * b.y - a.z * b.z - a.w * b.w, \n                a.y * b.x + a.x * b.y - a.w * b.z + a.z * b.w, \n                a.z * b.x + a.w * b.y + a.x * b.z - a.y * b.w, \n                a.w * b.x - a.z * b.y + a.y * b.z + a.x * b.w);\n}\n\nfloat intersectJulia(vec3 ro, vec3 rd, vec4 c, float k) {\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < 300; i++) {\n        vec4 z = vec4(ro, k);\n    \tvec4 zp = vec4(1., 0.0, 0.0, 0.0);\n        \n        // iterate to find distance\n        for (int j = 0; j < 15; j++) {\n        \tzp = 2.0 * quatMultiply(z, zp);\n            z = quatMultiply(z, z) + c;\n            if( dot( z, z ) > 100.0 ) {\n            \tbreak; \n            }\n        }\n        float norm_z = length(z);\n    \tt = (.5 * norm_z * log(norm_z)) / length(zp);\n        d+=t;\n        ro += rd * t;\n        if (t < EPSILON || dot(ro, ro) > BOUNDING_RAD) {\n        \tbreak;\n        }\n    }\n    if (t <EPSILON) {\n    \treturn d;\n    } else {\n    \treturn -1.0;\n    }\n}\n\nvec3 getColor(vec3 pos, vec3 view, vec3 n, vec4 c, float k) {\n    vec3 light1 = normalize(vec3(1., 1., 1.));\n    vec3 light2 = vec3(0., 1., 0.);\n    vec3 light3 = vec3(0., 0., 1.);\n    \n    vec3 norm = getNormal(pos, c, k);\n    float t1 = intersectJulia(pos + 10. * EPSILON * light1, \n                              -light1, c, k);\n    float shadowed1 = 1.0;\n    if (t1 < 0.0) {\n    \tshadowed1 = 0.0;\n    } \n    shadowed1 = smoothstep(-0.0, 0.01, t1);\n    \n    return shadowed1 * vec3(max(dot(norm, light1), 0.0)) * vec3(1., 0., 0.)\n        + .6 * abs(n) + .6 *abs(pos);\n}\n\nvec3 getBackgroundColor(vec3 dir) {\n    float n = dot(dir, vec3(0., 1., 0.));\n    vec3 red = smoothstep(.3, .4, n) * vec3(.81, 0.06, 0.15);\n    vec3 white = smoothstep(.4, .3, abs(n)) * vec3(1.0);\n    vec3 green = smoothstep(.3, .4, -n) * vec3(0.0, 0.61, 0.28);\n    return vec3(.1);//red + white + green;\n}\n\nvec3 getNormal(vec3 pos, vec4 c, float k) {\n    \n    vec4 zp = vec4(pos, k);\n\tfloat DELTA = 0.001;\n    \n    // use basic central differences to find normal\n    vec4 nxp = zp + vec4(DELTA, 0.0, 0.0, 0.0);\n    vec4 nxm = zp - vec4(DELTA, 0.0, 0.0, 0.0);\n    vec4 nyp = zp + vec4(0.0, DELTA, 0.0, 0.0);\n    vec4 nym = zp - vec4(0.0, DELTA, 0.0, 0.0);\n    vec4 nzp = zp + vec4(0.0, 0.0, DELTA, 0.0);\n    vec4 nzm = zp - vec4(0.0, 0.0, DELTA, 0.0);\n    \n    // iterate to determine divergence <- need better description\n    for (int i = 0; i < 10; i++) {\n    \tnxp = quatMultiply(nxp, nxp) + c;\n        nxm = quatMultiply(nxm, nxm) + c;\n        nyp = quatMultiply(nyp, nyp) + c;\n        nym = quatMultiply(nym, nym) + c;\n        nzp = quatMultiply(nzp, nzp) + c;\n        nzm = quatMultiply(nzm, nzm) + c;\n    }\n        \n    // grad = length of vectors\n    return normalize(vec3(length(nxp) - length(nxm),\n                         length(nyp) - length(nym),\n                         length(nzp) - length(nzm)));//));\n}\n\n// basic sphere intersection to determine if raymarching necessary\nfloat intersectSphere(in vec3 ro, in vec3 rd) {\n   float B, C, d, t0, t1, t;\n   float radius = BOUNDING_RAD;\n   B = 2. * dot( ro, rd );\n   C = dot( ro, ro ) - radius;\n   d = sqrt( B*B - 4. *C );\n   t0 = ( -B + d ) * 0.5;\n   t1 = ( -B - d ) * 0.5;\n   t = min( t0, t1 );\n   return t;\n}\n\n\n//takes in 3d point (which lies on ray)..\n// and returns closest distance to point\nfloat map( in vec3 p )\n{   \n    // ground plane\n\tfloat plane =  p.y+2.0;\n    return plane;\n}\n\n//start with original poin (ro), and original direction (rd)\n// then iterate the point along the ray \n// with each iteration move the point x units along the ray\n// where x is the distance from the point to the closest object in the scene (via map)\n// once x is small enough, then an intersection can be assumed\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 40.0;\n\tfloat h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<80; i++ )\n    {\n        if( h<0.001 || t>maxd ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\t\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n    //use epsilon-delta limit to approximate normal\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    \n    float theta = iTime/5.0;\n    mat3 rotMat = mat3(cos(theta), 0.0, sin(theta),\n                      0.0, 1.0, 0.0,\n                      -sin(theta), 0.0, cos(theta));\n    \n    vec3 view = vec3(0.0, 0.0, -1.);\n\tvec3 rd = normalize( vec3(p,-1.) );\n    \n    view = view * rotMat;\n    rd = rd * rotMat;\n    \n    vec3 ro = -3. * view;\n    vec3 eye = ro;\n    vec3 col = getBackgroundColor(rd);\n    vec4 mu = vec4(abs(sin(iTime / 3.0)),\n                       .8 * sin(iTime / 5.0),\n                       .5 * sin(iTime / 7.0),\n                       .5 * sin(iTime / 11.0));\n        \n    mu = vec4(sin(iTime),cos(iTime),.0,.0);\n    float k = 0.0;\n    bool s_inter = false;\n    bool j_inter = false;\n    \n    float t = intersectSphere(ro, rd);\n    if (t > 0.0) {\n        s_inter = true;\n        // update ro to be on radius of bounding sphere\n        ro += t * rd;\n        \n        // k is chosen somewhat arbitrarily to limit 4D quaternion space\n        // to 3D Euclidean\n        t = intersectJulia(ro, rd, mu, k);\n        if (t > 0.0) {\n            j_inter = true;\n        \tro += t * rd;\n            vec3 norm = getNormal(ro, mu, k);\n            col = getColor(ro, eye, norm, mu, k);\n        } \n    } \n   \t\n    // Ground plane coloring\n    if (!j_inter) {\n    \tfloat t = intersect(ro, rd);\n        if (t > 0.) {\n            ro += t * rd;\n            vec3 norm = calcNormal(ro);\n            ro = ro + EPSILON * norm;\n            \n            // trace towards ground plane\n            col = ro;\n            t = intersectJulia(ro, vec3(1., 2., 0.), mu, k);\n            \n            col = texture( iChannel0, ro.xz / TEX_SCALE ).xyz;\n            if (t > -0.1) {\n            \tcol *= .6;\n            }\n            \n        }\n    }\n    fragColor = vec4(col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}