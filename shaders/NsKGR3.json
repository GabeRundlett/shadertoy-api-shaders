{
    "Shader": {
        "info": {
            "date": "1631871029",
            "description": "Spheres falling through an array of fixed spheres",
            "flags": 32,
            "hasliked": 0,
            "id": "NsKGR3",
            "likes": 14,
            "name": "Balls Falling",
            "published": 3,
            "tags": [
                "collision",
                "dynamics",
                "physics"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 356
        },
        "renderpass": [
            {
                "code": "// \"Balls Falling\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  No. 37 in \"Ball Dynamics\" series\n    \"Molecular Dynamics\"        (4dG3RW)\n    \"Granular Vibration\"        (Mdy3RW)\n    \"Puck Dynamics\"             (MsV3zW)\n    \"Colliding Balls\"           (XsGGRm)\n    \"Pseudo Billiards\"          (4sy3Rm)\n    \"Pseudo Billiards 2\"        (ldy3zm)\n    \"Balls and Springs\"         (MsV3zw)\n    \"Reflecting Balls\"          (Xsy3WR)\n    \"Flashing Balls\"            (ldVGDR)\n    \"Quasi Billiards\"           (MsGGD1)\n    \"Trapped Balls\"             (4dV3RG)\n    \"Herding Balls\"             (4dKGRt)\n    \"Ball Run\"                  (XsyGWG)\n    \"Leaping Balls\"             (MdKGWc)\n    \"Leaping Balls Return\"      (4sG3Wt)\n    \"Stairway from Heaven\"      (4sG3Dt)\n    \"Faberge Balls\"             (MsdXWn)\n    \"Free the Balls\"            (lttGRn)\n    \"Balls and Springs 2\"       (XlGXzz)\n    \"More Balls\"                (MsfyRn)\n    \"Rolling Stones\"            (MdsfD7)\n    \"Ben-Hur Balls\"             (XtfBWf)\n    \"Refracted Colliding Balls\" (lljBDR)\n    \"Reflecting Ben-Hur Balls\"  (MsVfRW)\n    \"Quasi Billiards 2\"         (4ldBWl)\n    \"Ball Cluster\"              (3sfGD8)\n    \"Molecular Diffusion\"       (3d23z3)\n    \"Freezing and Melting\"      (3dj3Wy)\n    \"Racetrack\"                 (tscSDn)\n    \"Channeling Marbles\"        (wtfcRr)\n    \"Truchet Balls\"             (tlXBW4)\n    \"Marble Paths\"              (wddyDn)\n    \"Balls in Spinning Drum\"    (tdcyWs)\n    \"Magic Ball Sorter\"         (tsGyDy)\n    \"Balls In Motion\"           (WdGBRG)\n    \"Stairway to Hell\"          (sdl3WS)\n\n  (List includes both 3D and 2D dynamics, but not those in \"Sheet Dynamics\",\n  \"Chain Dynamics\", \"Rigid Body Dynamics\" series and those dealing with\n  mazes / slime / mondrians)\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrSphDf (vec3 p, float s);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat Minv2 (vec2 p);\nmat3 QtToRMat (vec4 q);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv3 (vec3 p);\nvec4 Loadv4 (int idVar);\n\nconst ivec3 nBallD = ivec3 (10, 4, 10);\nconst int nBall = nBallD.x * nBallD.y * nBallD.z;\n\nvec3 ltDir, vnBall, gId;\nfloat tCur, dstFar, gSize, gLim, sRad;\nint idBall, idObj;\nconst float pi = 3.1415927;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat GObjDf (vec3 p)\n{\n  float d;\n  d = dstFar;\n  if (sRad > 0.) d = min (d, PrSphDf (p - gSize * (gId + 0.5), sRad));\n  return d;\n}\n\nvoid SetGParm ()\n{\n  sRad = min (0.1 + 0.5 * Hashfv3 (17.1 * gId + 1.11), 0.5);\n  if (sRad < 0.2) sRad = 0.;\n}\n\nfloat GObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi, gIdP, s;\n  float dHit, d, eps;\n  eps = 0.0002;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.y == 0.) rd.y = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  rdi = 1. / rd;\n  gIdP = vec3 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 240; j ++) {\n    p = ro + dHit * rd;\n    gId = floor (p / gSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGParm ();\n    }\n    if (Maxv3 (abs (gId)) < gLim) d = GObjDf (p);\n    else d = dstFar;\n    s = (gSize * (gId + step (0., rd)) - p) * rdi;\n    dHit += min (d, eps + max (0., Minv3 (s)));\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 GObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    u = ro - p.xyz;\n    rad = 0.5 * p.w;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vnBall = (u + d * rd) / rad;\n        idBall = n;\n      }\n    }\n  }\n  return dMin;\n}\n\nfloat BallChqr (int idBall, vec3 vnBall)\n{\n  vec3 u;\n  vec2 a;\n  u = vnBall * QtToRMat (Loadv4 (4 * idBall + 2));\n  a = mod (floor (8. * vec2 (atan (u.x, u.y), asin (u.z)) / pi), 2.) - 0.5;\n  return step (0., sign (a.x) * sign (a.y));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObjG, dstBall;\n  col = vec3 (0.05);\n  dstObjG = GObjRay (ro, rd);\n  dstBall = BallHit (ro, rd);\n  if (min (dstBall, dstObjG) < dstFar) {\n    if (dstObjG < dstBall) {\n      ro += dstObjG * rd;\n      vn = GObjNf (ro);\n      col4 = vec4 (0.8, 0.8, 0.9, 0.1);\n    } else {\n      ro += dstBall * rd;\n      vn = vnBall;\n      col4 = vec4 (HsvToRgb (vec3 (mod (21. * float (idBall) / float (nBall) +\n         0.2 * BallChqr (idBall, vn), 1.), 1., 1.)), 0.2);\n    }\n    col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n    rd = reflect (rd, vn);\n    if (dstObjG < dstBall) col += vec3 (0.05) * step (0.1, Minv2 (mod (4. *\n       vec2 (atan (rd.z, rd.x), asin (rd.y)) + 0.5, 1.) - 0.5));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 rd, ro, vd, col;\n  vec2 canvas, uv;\n  float az, el, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  stDat = Loadv4 (4 * nBall);\n  gSize = stDat.x;\n  gLim = stDat.y;\n  dstFar = 200.;\n  az = 0.;\n  el = -0.08 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.3 * pi * mPtr.y;\n  } else {\n    az += 0.1 * tCur;\n  }\n  el = clamp (el, -0.1 * pi, 0.1 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -80.);\n  ltDir = vuMat * normalize (vec3 (1., 2., -1.));\n  zmFac = 6. / (1. - 0.7 * abs (mod (az + pi, 2. * pi) - pi) / pi);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (clamp (col, 0., 1.), 1.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Balls Falling\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat Maxv3 (vec3 p);\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nfloat Hashfv3 (vec3 p);\nvec4 Hashv4f (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec3 nBallD = ivec3 (10, 4, 10);\nconst int nBall = nBallD.x * nBallD.y * nBallD.z;\n\nfloat todCur, fOvlap, fricN, fricS, fricSW, fricT, gSize, gLim, bGap;\nconst float pi = 3.1415927;\n\nvoid CollFc (float rSep, float szAv, vec3 dr, vec3 dv, vec3 dw, inout vec3 am, inout vec3 wam)\n{\n  float fc, drv, ft;\n  fc = fOvlap * (szAv / rSep - 1.);\n  drv = dot (dr, dv) / (rSep * rSep);\n  fc = max (fc - fricN * drv, 0.);\n  am += fc * dr;\n  dv -= drv * dr + cross (dw, dr);\n  ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n  am -= ft * dv;\n  wam += (ft / rSep) * cross (dr, dv);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, am, wam, gId;\n  float fDamp, fCent, grav, rSep, szN, szAv, ft, ms, drv, dt, sRad;\n  fOvlap = 1000.;\n  fricN = 10.;\n  fricS = 0.05;\n  fricSW = 1.;\n  fricT = 0.5;\n  fDamp = 0.01;\n  fCent = 0.02;\n  grav = 2.;\n  p = Loadv4 (4 * mId);\n  rm = p.xyz;\n  sz = p.w;\n  vm = Loadv4 (4 * mId + 1).xyz;\n  qm = Loadv4 (4 * mId + 2);\n  wm = Loadv4 (4 * mId + 3).xyz;\n  ms = sz * sz * sz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    rmN = p.xyz;\n    szN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    szAv = 0.5 * (sz + szN);\n    if (n != mId && rSep < szAv) {\n      vmN = Loadv4 (4 * n + 1).xyz;\n      wmN = Loadv4 (4 * n + 3).xyz;\n      CollFc (rSep, szAv, dr, vm - vmN, (sz * wm + szN * wmN) / (sz + szN), am, wam);\n    }\n  }\n\n  gId = floor (rm / gSize);\n  if (Maxv3 (abs (gId)) < gLim) {\n    sRad = min (0.1 + 0.5 * Hashfv3 (17.1 * gId + 1.11), 0.5);\n    if (sRad > 0.) {\n      szAv = 0.5 * (sz + sRad);\n      dr = rm - gSize * (gId + 0.5);\n      rSep = length (dr);\n      if (rSep < szAv) {\n        CollFc (rSep, szAv, dr, vm, wm, am, wam);\n      }\n    }\n  }\n  \n  am.xz -= fCent * normalize (rm.xz);\n  am.y -= grav * ms;\n  am -= fDamp * vm;\n  dt = 0.01;\n  vm += dt * am / ms;\n  rm += dt * vm;\n  wm += dt * wam / (0.1 * ms * sz);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec4 h;\n  vec3 nb;\n  float mIdf;\n  mIdf = float (mId);\n  nb = vec3 (nBallD);\n  rm.z = floor (mIdf / (nb.x * nb.y));\n  rm.y = floor (mod (mIdf, nb.x * nb.y) / nb.x);\n  rm.x = mod (mIdf, nb.x);\n  rm = bGap * (rm - 0.5 * (nb - 1.));\n  rm.y += 0.5 * bGap * nb.y + gSize * gLim + 8.;\n  vm.xz = -0.1 * sign (rm.xz);\n  vm.y = -0.1;\n  h = Hashv4f (mIdf);\n  qm = EulToQt (normalize (h.xyz));\n  wm = vec3 (0.);\n  sz = 1. - 0.2 * h.w;\n}\n\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag;\n  float sz, nStep;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 1) discard;\n  doInit = (iFrame <= 3);\n  if (doInit) {\n    nStep = 0.;\n    gSize = 1.5;\n    gLim = 6.;\n  } else {\n    stDat = Loadv4 (4 * nBall);\n    gSize = stDat.x;\n    gLim = stDat.y;\n    nStep = stDat.w;\n    ++ nStep;\n  }\n  mId = (pxId < 4 * nBall) ? pxId / 4 : -1;\n  bGap = 1.2;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, sz);\n    else {\n      Step (mId, rm, vm, qm, wm, sz);\n      if (rm.y < - (0.5 * bGap * float (nBallD.y) + gSize * gLim + 8.))\n         Init (mId, rm, vm, qm, wm, sz);\n    }\n  }\n  if (pxId < 4 * nBall) {\n    kp = pxId - 4 * mId;\n    if      (kp == 0) stDat = vec4 (rm, sz);\n    else if (kp == 1) stDat = vec4 (vm, 0.);\n    else if (kp == 2) stDat = qm;\n    else if (kp == 3) stDat = vec4 (wm, 0.);\n  } else {\n    stDat = vec4 (gSize, gLim, 0., nStep);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}