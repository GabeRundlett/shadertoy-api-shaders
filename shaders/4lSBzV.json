{
    "Shader": {
        "info": {
            "date": "1516460838",
            "description": "Path tracing a procedurally created material. On slower systems disable the path tracing by setting PATH to 0. The path tracer currently supports PBR and dielectric materials.",
            "flags": 32,
            "hasliked": 0,
            "id": "4lSBzV",
            "likes": 22,
            "name": "PBR Material: Gold",
            "published": 3,
            "tags": [
                "material",
                "trace",
                "path",
                "pbr",
                "gold"
            ],
            "usePreview": 1,
            "username": "markusm",
            "viewed": 1602
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 color = vec3(0.0);\n\n    if( iFrame > 0 ) {\n        color = texture( iChannel0, uv ).xyz;\n        color /= float( iFrame );\n        color = pow( color, vec3(0.4545) );\n    }\n\n    fragColor = vec4( color, 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Except where otherwise noted:\n\n// Copyright Â© 2018 Markus Moenig Distributed under The MIT License.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\n// 0 - Wall, 1 - Sphere, 2 - Cylinder, 3 - Twisted, 4 - Floor, 5 - Preview\n#define SHAPE 5\n\n// Displacement / Bump Mapping switch\n#define DISPLACEMENT 1\n\n// Path-tracing switch and depth\n#define PATH 1\n#define PATH_DEPTH 2\n\n// --- Material Code\n\nstruct Material {\n    int type;\n    vec3 color;\n    vec3 specularColor;\n    float specularAmount;\n    float metallic;\n    float smoothness;\n    float reflectance;\n    float bump;\n    vec3 emission;\n    float ior;\n};\n\n// --- Exported by Material-Z.com. Currently in early alpha.\n\nvec3 source0( in vec3 inPos, in vec2 inUV, in vec3 inNormal, in float inTime, in vec3 inInput1, in vec3 inInput2, in vec3 inInput3 ) {\n  float noise = fract(sin(dot(inUV.xy, vec2(12.9898,78.233))) * 43758.5453123);\ninInput1 = vec3( noise );\nreturn inInput1;\n}\n\nvec3 source1( in vec3 inPos, in vec2 inUV, in vec3 inNormal, in float inTime, in vec3 inInput1, in vec3 inInput2, in vec3 inInput3 ) {\n  // Based on IQs value noise https://www.shadertoy.com/view/lsf3WH.\n  vec2 x = inUV / 0.374 * vec2( 1.000, 1.000 );\n  vec2 p = floor(x);\n  vec2 f = fract(x);\n  f = f*f*(3.0-2.0*f);\n  float noise = mix(mix( source0(inPos, p, inNormal, inTime, inInput1, inInput2, inInput3 ).x,\n                          source0(inPos, p + vec2( 1.0, 0.0), inNormal, inTime, inInput1, inInput2, inInput3 ).x,f.x),\n                     mix( source0(inPos, p + vec2( 0.0, 1.0), inNormal, inTime, inInput1, inInput2, inInput3 ).x,\n                          source0(inPos, p + vec2( 1.0, 1.0), inNormal, inTime, inInput1, inInput2, inInput3 ).x, f.x),f.y);\ninInput1 = vec3( noise );\nreturn inInput1;\n}\n\nvec3 source2( in vec3 inPos, in vec2 inUV, in vec3 inNormal, in float inTime, in vec3 inInput1, in vec3 inInput2, in vec3 inInput3 ) {\n  float value = 0.0;\n  float amplitude = 1.;\n  vec2 p = inUV;\n  for (int i = 0; i < 16; i++)\n  {\n      value += amplitude * source1( inPos, p, inNormal, inTime, inInput1, inInput2, inInput3 ).x;\n      p *= 3.141;\n      amplitude *= 0.668;\n  }\ninInput1 = vec3( value );\nreturn inInput1;\n}\n\n\nvoid material0( in vec3 pos, inout vec3 normal, in float time, inout Material material ) {\n    vec2 uv;\n    material.color = vec3( 1, 0.7098039215686275, 0.2901960784313726 );material.specularColor = vec3( 1, 1, 1 );material.specularAmount = 0.000;material.smoothness = 0.820;material.reflectance = 1.000;\n    vec3 n = abs( normal );\n    if( n.x > 0.57735 ) uv = pos.yz;\n    else if (n.y>0.57735) uv = pos.xz;\n    else uv = pos.xy;\n    material.bump = 0.5;\n    vec3 _oLOw = source0( pos, uv, normal, 0., vec3(0), vec3(0), vec3(0) );\n    vec3 _YWZs = source1( pos, uv, normal, 0., _oLOw, vec3(0), vec3(0) );\n    vec3 _cvoZ = source2( pos, uv, normal, 0., _YWZs, vec3(0), vec3(0) );\n    vec3 _lWDq = 1.000 - _cvoZ;\n    vec3 _WzWp = _lWDq * 0.100 * vec3( 1.000, 1.000, 1.000 );\n    material.metallic = _cvoZ.x;\n    material.bump = _WzWp.x;\n}\n\n// ---\n\nstruct Light {\n    float id;\n    vec3 emission;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\n// --- IQs distance functions\n// --- https://iquilezles.org/articles/distfunctions\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\nvec3 opBlend( vec3 d1, vec3 d2, float k )\n{\n    vec3 rc;\n    rc.x=smin( d1.x, d2.x, k );\n\n    if ( d1.x < d2.x )\n    {\n        rc.y=d1.y;\n        rc.z=d1.z;\n    } else\n    {\n        rc.y=d2.y;\n        rc.z=d2.z;\n    }\n\n    return rc;\n}\n\nvec3 opU( vec3 d1, vec3 d2 )\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opTwist( vec3 p, float twist )\n{\n    float c = cos(twist*p.z);\n    float s = sin(twist*p.z);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// ---\n\n#define PI 3.1415926535897932384626422832795028841971\n\n#define LIGHT1_POS vec3( 0.5, 0.5, 8 )\n#define LIGHT1_EM vec3( 180*5, 180 *5, 180 *5 )\n\n#define SUN_POS vec3( 0.5, 3.5, 3 )\n#define SUN_EM vec3( 180*5, 180 *5, 180 *5 )\n\nvec2 randv2;\n\nfloat random() {\n    randv2+=vec2(1.0,0.0);\n    // return fract(sin(dot(vTexCoord, vec2(12.9898, 78.233)) + seed++) * 43758.5453);\n    return fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n    randv2+=vec2(1.0,1.0);\n    return vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 43758.5453),\n        fract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\n// --- Map functions\n\n#if (SHAPE != 5)\n\nvec3 map( vec3 p )\n{\n    vec3 res=vec3( 1000000, -2, -1 );\n\n    #if (SHAPE == 0)\n    res=opU( res, vec3( p.z, 0, 0 ) );\n    #elif (SHAPE == 1)\n    res = opU( res, vec3( length( p ) - 1.0, 0, 0 ) );\n    #elif (SHAPE == 2)\n    vec2 h = vec2( 0.95, 0.8 ); vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    res=opU( res, vec3( min(max(d.x,d.y),0.0) + length(max(d,0.0)), 0, 0 ) );\n    #elif (SHAPE == 3)\n    vec3 tp=p;tp.zxy=opTwist( tp.zxy, 2.531 );\n    res=opU( res, vec3( length( max( abs(tp) - vec3( 0.213 * 3.0, 0.978 * 3.0, 0.213 * 3.0 ), 0.0 ) ) - 0.10, 0, 0 ) );\n    #elif (SHAPE == 4)\n    res=opU( res, vec3( p.y + 1.5, 0, 0 ) );\n    #endif\n\n#if (DISPLACEMENT == 1)\n    vec3 normal; Material material;\n    material0( p, normal, 0., material );\n    res.x -=material.bump/50.;\n#endif\n    res = opU( res, vec3( length( p - LIGHT1_POS ) - 1.0, 2, 2 ) );\n\n    return res;\n}\n\n#elif (SHAPE == 5)\n\nvec3 map( vec3 p )\n{\n    // --- Exported by RaySupreme.com\n    vec3 res=vec3( 1000000, -2, -1 ); mat4 mat; vec3 tp, temp;\n    vec3 gResult1, gResult2;\n    gResult1 = vec3( 1000000, -2, -1 );\n    tp=p;\n    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 399.741, 399.741, 399.741 ), 0.0 ) ) - 0.259, 0, 0 ) );\n    tp=p;\n    tp.y = tp.y + -19.0000;\n    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 84.000, 3.000, 3.000 ), 0.0 ) ) - 16.000);\n    res=opU( res, gResult1 );\n    tp=p;\n    tp = tp + vec3(-2.0000,-2.0000,-4.0000);\n    res=opU( res, vec3( length( tp ) - 1.000, 1, 3 ) );\n    tp=p;\n    tp = tp + vec3(4.0000,-1.5000,-4.0000);\n    res=opU( res, vec3( length( tp ) - 0.300, 1, 4 ) );\n    gResult1 = vec3( 1000000, -2, -1 );\n    gResult2 = vec3( 1000000, -2, -1 );\n    tp=p;\n    tp.x = tp.x + -0.3542;\n    tp /= vec3( 1.300, 1.300, 1.300 );\n    gResult2=opU( gResult2, vec3( sdCylinder( tp, vec2( 1.000, 0.030) ), 3, 5 ) );\n    tp=p;\n    tp.xy = tp.xy + vec2(-0.3542,-0.1300);\n    tp /= vec3( 1.300, 1.300, 1.300 );\n#if (DISPLACEMENT == 1)\n    vec3 bumpNormal; Material bumpMaterial;\n    material0( p, bumpNormal, 0., bumpMaterial );\n    gResult2 = opBlend( gResult2, vec3( sdCylinder( tp, vec2( 0.800, 0.030) )- bumpMaterial.bump/50., 2, 6 ), 16.7396 );\n #else\n    gResult2 = opBlend( gResult2, vec3( sdCylinder( tp, vec2( 0.800, 0.030) ), 2, 6 ), 16.7396 );\n #endif\n    tp=p;\n    tp.xy = tp.xy + vec2(-0.3542,-0.1560);\n    tp /= vec3( 1.300, 1.300, 1.300 );\n    gResult2.x=opS( gResult2.x, sdCylinder( tp, vec2( 0.700, 0.040) ));\n    gResult1=opU( gResult1, gResult2 );\n    gResult2 = vec3( 1000000, -2, -1 );\n    tp=p;\n    mat=mat4(0.3323,-0.1160,-0.9360,0.0000\n    ,0.3295,0.9442,0.0000,0.0000\n    ,0.8838,-0.3084,0.3519,0.0000\n    ,-0.4378,-0.8764,0.3315,1.0000);\n    tp=(mat * vec4(tp, 1.0)).xyz;\n    tp /= vec3( 1.495, 1.495, 1.495 );\n#if (DISPLACEMENT == 1)\n    material0( p, bumpNormal, 0., bumpMaterial );\n    gResult2=opU( gResult2, vec3( length( tp ) - 0.600- bumpMaterial.bump/50., 2, 9 ) );\n#else\n    gResult2=opU( gResult2, vec3( length( tp ) - 0.600, 2, 9 ) );\n#endif\n    tp=p;\n    tp.xz = mat2(0.8400,-0.5426,0.5426,0.8400) * tp.xz;\n    tp = tp + vec3(-0.3472,-1.4950,-2.3441);\n    tp /= vec3( 1.495, 1.495, 1.495 );\n    gResult2.x=opS( gResult2.x, length( tp ) - 1.280);\n    tp=p;\n    mat=mat4(0.8400,0.0942,-0.5344,0.0000\n    ,-0.0000,0.9848,0.1736,0.0000\n    ,0.5426,-0.1459,0.8272,0.0000\n    ,-0.2975,-0.9904,0.0205,1.0000);\n    tp=(mat * vec4(tp, 1.0)).xyz;\n    tp /= vec3( 1.495, 1.495, 1.495 );\n    gResult2.x=opS( gResult2.x, sdCylinder( tp, vec2( 0.630, 0.030) ));\n    tp=p;\n    tp.xz = mat2(0.8400,-0.5426,0.5426,0.8400) * tp.xz;\n    tp = tp + vec3(-0.2975,-0.9717,0.1922);\n    tp /= vec3( 1.495, 1.495, 1.495 );\n    gResult2.x=opS( gResult2.x, length( tp ) - 0.550);\n    tp=p;\n    tp.xz = mat2(0.8400,-0.5426,0.5426,0.8400) * tp.xz;\n    tp = tp + vec3(-0.2975,-0.9717,0.1922);\n    tp /= vec3( 1.495, 1.495, 1.495 );\n    gResult2=opU( gResult2, vec3( length( tp ) - 0.520, 0, 13 ) );\n    gResult1=opU( gResult1, gResult2 );\n    res=opU( res, gResult1 );\n    return res;\n}\n\n#endif\n\n// --- Normal\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x +\n                    e.yyx*map( pos + e.yyx ).x +\n                    e.yxy*map( pos + e.yxy ).x +\n                    e.xxx*map( pos + e.xxx ).x );\n}\n\n// --- IQs raycasting\n\nvec3 castRay( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t=tmin;\n    float m=-1.0, id=-1.0;\n\n    for( int i=0; i<100; i++ )\n    {\n        float precis = 0.0005*t;\n\n        vec3 res = map( ro+rd*t );\n        if( t<precis || t>tmax ) break;\n        t += res.x;\n        m = res.y;\n        id = res.z;\n    }\n\n    if( t>tmax ) { m=-1.0; id=-1.0; }\n    return vec3( t, m, id );\n}\n\n// --- PBR / GGX\n\nfloat ggx(vec3 N, vec3 V, vec3 L, float roughness, float F0)\n{\n    vec3 H = normalize(V + L);\n\n    float dotLH = max(dot(L, H), 0.0);\n    float dotNH = max(dot(N, H), 0.0);\n    float dotNL = max(dot(N, L), 0.0);\n    float dotNV = max(dot(N, V), 0.0);\n\n    float alpha = roughness * roughness + 0.0001;\n\n    // GGX normal distribution\n    float alphaSqr = alpha * alpha;\n    float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;\n    float D = alphaSqr / (denom * denom);\n\n    // Fresnel term approximation\n    float F_a = 1.0;\n    float F_b = pow(1.0 - dotLH, 5.0);\n    float F = mix(F_b, F_a, F0);\n\n    // GGX self shadowing term\n    float k = (alpha + 2.0 * roughness + 1.0) / 8.0;\n    float G = dotNL / (mix(dotNL, 1.0, k) * mix(dotNV, 1.0, k));\n\n    // '* dotNV' - Is canceled due to normalization\n    // '/ dotLN' - Is canceled due to lambert\n    // '/ dotNV' - Is canceled due to G\n    return max(0.0, min(10.0, D * F * G / 4.0));\n}\n\n#if (PATH == 0)\n// --- If no path tracing, use IQs softshadow to add detail\n// --- https://iquilezles.org/articles/rmshadows\n\nfloat softshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    for( float t=0.02; t < 2.; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 ) return 0.0;\n        res = min( res, 8.0*h/t );\n        t += h;\n    }\n    return res;\n}\n#endif\n\n// --- Light Sampling\n\nvec3 angleToDir(vec3 n, float theta, float phi)\n{\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    vec3 w = normalize(n);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n    return (u * cos(theta) + v * sin(theta)) * sinPhi + w * cosPhi;\n}\n\nvec3 jitter(vec3 d, float phi, float sina, float cosa) {\n    vec3 w = normalize(d), u = normalize(cross(w.yzx, w)), v = cross(w, u);\n    return (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nvec3 sampleLightBRDF( in vec3 hitOrigin, in vec3 hitNormal, in vec3 rayDir, in Material material  )\n{\n    vec3 brdf = vec3( 0 );\n    vec3 s = vec3( 0 );\n\n    Light light;\n    light.id = 3.0;\n    light.emission = LIGHT1_EM;\n\n    vec3 l0 = vec3( 2, 2, 4 ) - hitOrigin;\n\n    float cos_a_max = sqrt(1. - clamp(0.5 * 0.5 / dot(l0, l0), 0., 1.));\n    float cosa = mix(cos_a_max, 1., random());\n    vec3 l = jitter(l0, 2.*PI*random(), sqrt(1. - cosa*cosa), cosa);\n\n#if (PATH == 1)\n    vec3 lightHit = castRay( hitOrigin, l, 0.001, 100.0 );\n    if ( lightHit.z == light.id )\n#else\n    s += softshadow( hitOrigin, normalize(l0) );\n#endif\n    {\n        float roughness = 1.0 - material.smoothness * material.smoothness;\n        float metallic = material.metallic;\n\n        float omega = 2. * PI * (1. - cos_a_max);\n        brdf += ((light.emission * clamp(ggx( hitNormal, rayDir, l, roughness, metallic),0.,1.) * omega) / PI);\n    }\n\n    light.id = 4.0;\n\n    l0 = vec3( -4, 1.5, 4 ) - hitOrigin;\n\n    cos_a_max = sqrt(1. - clamp(0.5 * 0.5 / dot(l0, l0), 0., 1.));\n    cosa = mix(cos_a_max, 1., random());\n    l = jitter(l0, 2.*PI*random(), sqrt(1. - cosa*cosa), cosa);\n\n#if (PATH == 1)\n    lightHit = castRay( hitOrigin, l, 0.001, 100.0 );\n    if ( lightHit.z == light.id )\n#else\n    s += softshadow( hitOrigin, normalize(l0) );\n#endif\n    {\n        float roughness = 1.0 - material.smoothness * material.smoothness;\n        float metallic = material.metallic;\n\n        float omega = 2. * PI * (1. - cos_a_max);\n        brdf += ((light.emission * clamp(ggx( hitNormal, rayDir, l, roughness, metallic),0.,1.) * omega) / PI);\n    }\n\n#if (PATH == 0)\n    brdf *= clamp( s, 0., 1. );\n#endif\n\n    return brdf;\n}\n\nvec3 sampleLightE( in vec3 hitOrigin, in vec3 hitNormal, in vec3 rayDir, in Material material  )\n{\n    vec3 e = vec3( 0 );\n    vec3 s = vec3( 0 );\n\n    Light light;\n    light.id = 3.0;\n    light.emission = LIGHT1_EM;\n\n    vec3 l0 = LIGHT1_POS - hitOrigin;\n\n    float cos_a_max = sqrt(1. - clamp(0.5 * 0.5 / dot(l0, l0), 0., 1.));\n    float cosa = mix(cos_a_max, 1., random());\n    vec3 l = jitter(l0, 2.*PI*random(), sqrt(1. - cosa*cosa), cosa);\n\n#if (PATH == 1)\n    vec3 lightHit = castRay( hitOrigin, l, 0.001, 100.0 );\n    if ( lightHit.z == light.id )\n#else\n    s += softshadow( hitOrigin, normalize(l0) );\n#endif\n    {\n        float omega = 2. * PI * (1. - cos_a_max);\n        vec3 n = normalize(hitOrigin - LIGHT1_POS);\n        e += ((light.emission * clamp(dot(l, n),0.,1.) * omega) / PI);\n    }\n\n    light.id = 4.0;\n\n    l0 = vec3( -4, 1.5, 4 ) - hitOrigin;\n\n    cos_a_max = sqrt(1. - clamp(0.5 * 0.5 / dot(l0, l0), 0., 1.));\n    cosa = mix(cos_a_max, 1., random());\n    l = jitter(l0, 2.*PI*random(), sqrt(1. - cosa*cosa), cosa);\n\n#if (PATH == 1)\n    lightHit = castRay( hitOrigin, l, 0.001, 100.0 );\n    if ( lightHit.z == light.id )\n#else\n    s += softshadow( hitOrigin, normalize(l0) );\n#endif\n    {\n        float omega = 2. * PI * (1. - cos_a_max);\n        vec3 n = normalize(hitOrigin - vec3( -4, 1.5, 4 ));\n        e += ((light.emission * clamp(dot(l, n),0.,1.) * omega) / PI);\n    }\n\n#if (PATH == 0)\n    e *= clamp( s, 0., 1. );\n#endif\n\n    return e;\n}\n\n#if (DISPLACEMENT == 0)\n\n// --- IQs screen space bump mapping: https://www.shadertoy.com/view/ldSGzR\n\nvec3 doBump( in vec3 pos, in vec3 nor, in float signal, in float scale )\n{\n    // build frame\n    vec3  s = dFdx( pos );\n    vec3  t = dFdy( pos );\n    vec3  u = cross( t, nor );\n    vec3  v = cross( nor, s );\n    float d = dot( s, u );\n\n    // compute bump\n    float bs = dFdx( signal );\n    float bt = dFdy( signal );\n\n    // offset normal\n#if 1\n\treturn normalize( nor - scale*(bs*u + bt*v)/d );\n#else\n    // if you cannot ensure the frame is not null\n\tvec3 vSurfGrad = sign( d ) * ( bs * u + bt * v );\n    return normalize( abs(d)*nor - scale*vSurfGrad );\n#endif\n}\n#endif\n\n// --- Calculate the color for the given ray\n\nvec4 getColor( in Ray ray )\n{\n    vec4 tcol = vec4(0,0,0,0);\n    vec4 fcol = vec4(1.0);\n\n#if (PATH == 1)\n    for (int depth = 0; depth < PATH_DEPTH; depth++)\n#endif\n    {\n        Material material;\n        vec3 normal;\n\n        vec3 hit = castRay( ray.origin, ray.dir, 0.001, 100.0 );\n\n        if ( hit.y >= 0.0 )\n        {\n            vec3 hitOrigin = ray.origin + ray.dir * hit.x;\n            normal = calcNormal( hitOrigin );\n\n#if (SHAPE != 5)\n            material0( hitOrigin, normal, 0., material );\n#if (DISPLACEMENT == 0)\n            // --- Bump Mapping\n\t\t    normal = doBump( hitOrigin, normal, dot(vec3(material.bump),vec3(0.33)), 0.02 );\n#endif\n#else\n            // --- Hardcoded environment materials for the preview shape\n\t        material.emission = vec3( 0 );\n    \t    material.specularColor = vec3( 1 );\n        \tmaterial.specularAmount = 0.;\n\n            if ( hit.y == 0.0 ) {\n            \tmaterial.type = 0;\n            \tmaterial.color = vec3( 0.996, 0.929, 0.929 );\n            \tmaterial.metallic = 0.;\n            \tmaterial.smoothness = 0.;\n            \tmaterial.reflectance = 1.;\n        \t} else\n        \tif ( hit.y == 1.0 ) {\n            \tmaterial.type = 2;\n            \tmaterial.emission = vec3( 200 );\n        \t} else\n        \tif ( hit.y == 2.0 ) {\n            \tmaterial0( hitOrigin, normal, 0., material );\n#if (DISPLACEMENT == 0)\n            \t// --- Bump Mapping\n\t\t    \tnormal = doBump( hitOrigin, normal, dot(vec3(material.bump),vec3(0.33)), 0.02 );\n#endif\n            } else\n            if ( hit.y == 3.0 ) {\n                material.type = 0;\n                material.color = vec3( 1 );\n                material.metallic = 0.0;\n                material.smoothness = 0.4;\n                material.reflectance = 1.;\n            }\n#endif\n\n            if ( material.type == 0 )\n            {\n                // PBR\n\n                float E = 1.;\n                float roughness = 1.0 - material.smoothness * material.smoothness;\n                float alpha = roughness * roughness;\n                float metallic = material.metallic;\n                float reflectance = material.reflectance;\n                float specular = material.specularAmount;\n                float diffuse = 1.0 - specular;\n                vec4 color = vec4( material.color * diffuse + material.specularColor * specular, 1.0 );\n\n                vec3 brdf = vec3(0);\n\n#if (PATH == 1)\n                if ( random() < reflectance)\n#else\n                if ( true )\n#endif\n                {\n                    vec3 brdf = sampleLightBRDF( hitOrigin, normal, ray.dir, material );\n\n                    vec2 rand = rand2();\n                    float xsi_1 = rand.x;\n                    float xsi_2 = rand.y;\n                    float phi = atan((alpha * sqrt(xsi_1)) / sqrt(1.0 - xsi_1));\n                    float theta = 2.0 * PI * xsi_2;\n                    vec3 direction = angleToDir(normal, theta, phi);\n\n                    ray = Ray( hitOrigin, direction );\n\n                    tcol += fcol * vec4( material.emission, 1.0 ) * E + fcol * color * vec4( brdf, 1.0 );\n                    fcol *= color;\n                } else\n                {\n                    float r2 = random();\n                    vec3 d = jitter(normal, 2.*PI*random(), sqrt(r2), sqrt(1. - r2));\n\n                    vec3 e = sampleLightE( hitOrigin, normal, ray.dir, material );\n\n                    float E = 1.;\n\n                    ray = Ray( hitOrigin, d );\n\n                    tcol += fcol * vec4( material.emission, 1.0 ) * E + fcol * color * vec4( e, 1.0 );\n                    fcol *= color;\n                }\n            } else\n            if ( material.type == 1 )\n            {\n                // --- Dielectric - material.ior is the index of refraction\n                // --- Based on this smallpt implementation https://www.shadertoy.com/view/MsySzd\n\n                vec3 nl = dot(normal,ray.dir) < 0.0 ? normal : normal * -1.0;\n                float specular = material.specularAmount;\n                float diffuse = 1.0 - specular;\n                vec4 color = vec4( material.color * diffuse + material.specularColor * specular, 1.0 );\n                fcol *= color;\n\n                // Ideal dielectric REFRACTION\n                Ray reflRay = Ray( hitOrigin, ray.dir - normal * 2.0 * dot(normal,ray.dir));\n                bool into = dot(normal,nl) > 0.0;                // Ray from outside going in?\n\n                float nc = 1.0;   // IOR of air\n                float nt = material.ior; // IOR of solid\n                float nnt = into ? nc / nt : nt / nc;\n                float ddn = dot(ray.dir , nl);\n                float cos2t = 1.0 - nnt * nnt * (1.0 - ddn * ddn);\n\n                if (cos2t < 0.0)    // Total internal reflection\n                {\n                    tcol += fcol * vec4( material.emission, 1.0);\n                    ray = reflRay;\n                } else {\n                    vec3 tdir = normalize(ray.dir * nnt - normal * ((into ? 1.0 : -1.0) * (ddn * nnt + sqrt(cos2t))));\n\n                    float a = nt - nc;\n                    float b = nt + nc;\n                    float R0 = a * a / (b * b);\n                    float c = 1.0 - (into ? -ddn : dot(tdir,normal));\n                    float Re = R0 + (1.0 - R0) * c * c * c * c * c;\n                    float Tr = 1.0 - Re;\n                    float P = .25 + .5 * Re;\n                    float RP = Re / P;\n                    float TP = Tr / (1.0 - P);\n\n                    if( random() < P )\n                    {\n                        vec3 brdf = sampleLightBRDF( hitOrigin, normal, ray.dir, material );\n\n                        ray = reflRay;\n                        fcol = fcol * RP;\n                        tcol += fcol * vec4( material.emission, 1.0 ) + fcol * vec4( brdf, 1.0 );\n\n                    } else {\n                        vec3 e = sampleLightE( hitOrigin, normal, ray.dir, material );\n\n                        ray = Ray( hitOrigin, normalize( tdir ) );\n                        fcol = fcol * TP;\n                        tcol += fcol * vec4( material.emission, 1.0 ) + fcol * vec4( e, 1.0 );\n                    }\n                }\n\n            } else\n            if ( material.type == 2 )\n            {\n                // --- Light\n                return vec4( material.emission, 1.0 );\n            }\n        } else {\n\n            vec4 backColor = vec4( 0.322, 0.322, 0.322, 01.0 );\n            return tcol + fcol * backColor;\n        }\n    }\n\n    return tcol;\n}\n\n#if (SHAPE != 5)\nvec3 uOrigin = vec3( 0.0, 0.0, 2.5 );\nvec3 uLookAt = vec3( 0.0, 0.0, 0 );\n#else\nvec3 uOrigin = vec3( 0.08, 0.5, 2.8 );\nvec3 uLookAt = vec3( 0.4, 0.7, 0 );\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float ratio = iResolution.x / iResolution.y;\n    vec2 pixelSize = vec2(1.0) / iResolution.xy;\n\n    randv2 = fract(cos((uv.xy+uv.yx * vec2(1000.0,1000.0) ) + vec2(iTime)*10.0));\n\n    // --- Camera\n\n    const float fov = 80.0;\n    float halfWidth = tan(radians(fov) * 0.5);\n    float halfHeight = halfWidth / ratio;\n\n    vec3 upVector = vec3(0.0, 1.0, 0.0);\n\n    vec3 w = normalize(uOrigin - uLookAt);\n    vec3 u = cross(upVector, w);\n    vec3 v = cross(w, u);\n\n    vec3 lowerLeft = uOrigin - halfWidth * u - halfHeight * v - w;\n    vec3 horizontal = u * halfWidth * 2.0;\n    vec3 vertical = v * halfHeight * 2.0;\n    vec3 dir = lowerLeft - uOrigin;\n    vec2 rand = rand2();\n\n    dir += horizontal * (pixelSize.x * rand.x + uv.x);\n    dir += vertical * (pixelSize.y * rand.y + uv.y);\n\n    // ---\n\n    vec3 color = getColor( Ray( uOrigin, normalize( dir ) ) ).xyz;\n    color = clamp( color, -1., 1. );\n    color += texture( iChannel0, uv).xyz;\n    fragColor = vec4( color, 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}