{
    "Shader": {
        "info": {
            "date": "1715459313",
            "description": "Fork of https://www.shadertoy.com/view/McVXWW where I used the llama3-70B-instruct to replace the sdWug function. conversation: https://hf.co/chat/r/gJgP-q0 I made some minor edits to paste it correctly.\n\nColor changed for a presentation",
            "flags": 0,
            "hasliked": 0,
            "id": "4cKXRK",
            "likes": 0,
            "name": "Wug by Llama3-70B-instruct",
            "published": 3,
            "tags": [
                "raymarching",
                "generated",
                "wug"
            ],
            "usePreview": 0,
            "username": "jakel101",
            "viewed": 58
        },
        "renderpass": [
            {
                "code": "// Apache 2.0 licnese for this shader :)\n\n#define EPS 0.001\n\n\nmat2 rot2D( float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n// root smooth minimum from @iq MIT license: https://www.shadertoy.com/view/DlVcW1\nfloat smin( float a, float b, float k )\n{\n    k *= 2.0;\n    float x = b-a;\n    return 0.5*( a+b-sqrt(x*x+k*k) );\n}\n\n// rounded cone by @iq MIT license: https://www.shadertoy.com/view/Xds3zN\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n// capsule/stick/linesegment by @iq MIT license: https://www.shadertoy.com/view/Xds3zN\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// sphere from @iq MIT license: https://www.shadertoy.com/view/Xds3zN\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\n// arbitrary orientation sdCylinder by @iq MIT license: https://www.shadertoy.com/view/Xds3zN\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// pyramid from @iq MIT license: https://www.shadertoy.com/view/Xds3zN\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n// this function is generated by a language model\nvec2 sdWug(vec3 p) {\n    // Body\n    float bodyRadius = 0.5;\n    float bodyHeight = 1.0;\n    float bodyDistance = sdCapsule(p, vec3(0.0, -bodyHeight/2.0, 0.0), vec3(0.0, bodyHeight/2.0, 0.0), bodyRadius);\n    \n    // Head\n    float headRadius = 0.3;\n    float headHeight = 0.4;\n    float headDistance = sdCapsule(p, vec3(0.0, bodyHeight/2.0 - headHeight/2.0, 0.0), vec3(0.0, bodyHeight/2.0 + headHeight/2.0, 0.0), headRadius);\n    \n    // Eyes\n    float eyeRadius = 0.1;\n    float eyeDistance = sdSphere(p - vec3(0.0, bodyHeight/2.0 + headHeight/2.0 - eyeRadius, 0.0), eyeRadius);\n    eyeDistance = min(eyeDistance, sdSphere(p - vec3(0.0, bodyHeight/2.0 + headHeight/2.0 - eyeRadius, 0.0), eyeRadius));\n    \n    // Legs\n    float legRadius = 0.05;\n    float legHeight = 0.3;\n    float legDistance = sdCylinder(p - vec3(0.2, -bodyHeight/2.0 - legHeight/2.0, 0.0), vec3(0.2, -bodyHeight/2.0 + legHeight/2.0, 0.0), vec3(0.0), legRadius);\n    legDistance = min(legDistance, sdCylinder(p - vec3(-0.2, -bodyHeight/2.0 - legHeight/2.0, 0.0), vec3(-0.2, -bodyHeight/2.0 + legHeight/2.0, 0.0), vec3(0.0), legRadius));\n    \n    // Combine distances\n    float distance = bodyDistance;\n    distance = min(distance, headDistance);\n    distance = min(distance, eyeDistance);\n    distance = min(distance, legDistance);\n    \n    // Material ID\n    float materialID = 1.0; // Body\n    if (headDistance < distance) materialID = 1.0; // Head\n    if (eyeDistance < distance) materialID = 2.0; // Eyes\n    if (legDistance < distance) materialID = 2.0; // Legs\n    \n    return vec2(distance, materialID);\n}\n\nvec2 map( vec3 p ){\n    float dist = float(0.0);\n    float mat = 0.0;\n    \n    // ground is a plane just now\n    float groundHeight = 2.0;\n    float ground = p.y + groundHeight; \n    \n    vec3 wugPos = vec3(p);\n    // wugPos.z = 1.5 - mod(wugPos.z, 3.0); // <--- uncomment this line to get more of them!\n    vec2 wug = sdWug(wugPos);\n    dist = min(ground, wug.x);\n    \n    if (wug.x < ground) mat = wug.y; // if ground is closer than wug return wug material, else 0.0?\n    \n    return vec2(dist, mat);\n}\n\nvec3 calcNormal( in vec3 pos){\n    vec2 e = vec2(EPS, 0.0);\n    return normalize(vec3(  map(pos+ e.xyy).x - map(pos-e.xyy).x,\n                            map(pos+ e.yxy).x - map(pos-e.yxy).x,\n                            map(pos+ e.yyx).x - map(pos-e.yyx).x ) );\n}\n\n\nvec2 rayCast( in vec3 ro, in vec3 rd){\n    float t = 0.0;                          //total distance travelled\n    float m = -1.0; // base material ID -1.0 will be sky/miss\n    // Raymarching loop\n    int i;\n    for (i=0; i<=100; i++){\n        vec3 pos = ro + rd*t;                 // position along the ray\n        vec2 h = map(pos);             // \"hit\"? currennt distance to next object in the scene\n        m = h.y;\n        if (h.x < EPS) break;               // early stop near\n        t += h.x;                             // marching step\n        \n        if (t > 20.0) break;        // early stop far\n    }\n    if (t>20.0) m=-1.0;\n    \n    return vec2(t,m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n    vec2 m = (iMouse.xy * vec2(4.0,2.0) - iResolution.xy)/iResolution.y;\n    m.y -= 0.5;\n    // Initialize\n    vec3 ro = vec3(0.0, 0.0, 4.0);         // rayOrigin\n    vec3 rd = normalize(vec3(uv, -0.8));       // rayDirection, value changes fov\n    vec3 col = vec3(0.55,0.65,0.9) - 0.6*rd.y;           // sky color with gradient\n\n    // mouse control\n    if ((iMouse.x<=0.0)||(iMouse.y<=0.0)){m.x=-.5,m.y=-.4;};//quick hack to detect no mouse input for thumbnail\n    m.x += iTime*0.25;\n    ro.yz *= rot2D(m.y);\n    rd.yz *= rot2D(m.y);\n    \n    ro.xz *= rot2D(m.x);\n    rd.xz *= rot2D(m.x);\n    \n    \n    vec2 res = rayCast(ro, rd);\n    float dist = res.x;\n    float mat = res.y;\n    \n    if (mat > -0.5){\n        vec3 pos = ro + rd*dist;\n        vec3 nor = calcNormal(pos);\n        vec3 material = vec3(0.03,0.18,0.03); // + 0.03*sin(rd.x); // base baterial, albedo low for floor\n        \n        if (mat > 0.5) // ID 1.0 = wug\n        {\n            material = vec3(0.9, 0.1, 0.1); \n        }\n        // should be else if, but I need to have the order correct\n        if (mat > 1.5) // ID 2.0 = eyes, legs\n        {\n            material = vec3(0.03); // near black\n        }\n        \n        \n        vec3 sun_dir = normalize(vec3(1.6, 1.2, 0.7));                   // sun direction\n        float sun_dif = clamp( dot(nor, sun_dir), 0.0, 1.0);             //diffused keylight?\n        float sun_sha = step(rayCast( pos+nor*EPS, sun_dir ).y, 0.0); \n        float sky_dif = clamp( 0.5 + 0.5*dot(nor, vec3(0.0, 1.0, 0.0)), 0.0, 1.0); //diffused sky light, biased?\n        \n        col = material*vec3(1.0, 0.7, 0.5) * sun_dif * sun_sha;   // yellow sunlight\n        col += material*vec3(0.0, 0.2, 0.4) * sky_dif;  // blue skylight\n        \n    }\n    \n    col = pow ( col, vec3(0.4545)); // gamma space - which one?\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}