{
    "Shader": {
        "info": {
            "date": "1603850584",
            "description": "Remake of my favorite \"Second Reality\" effect, unfortunately need a beefy PC to run fullscreen.\nhttps://youtu.be/KTjnt_WSJu8?t=383",
            "flags": 96,
            "hasliked": 0,
            "id": "tdycWV",
            "likes": 8,
            "name": "Bouncing Dots (2nd Reality)",
            "published": 3,
            "tags": [
                "demoscene",
                "particles",
                "demo",
                "demoeffect",
                "dots",
                "bouncing",
                "secondreality",
                "future",
                "reproduction",
                "crew"
            ],
            "usePreview": 0,
            "username": "xjorma",
            "viewed": 729
        },
        "renderpass": [
            {
                "code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#define AA 0\n\nvec4 Load(in int id)\n{\n\treturn texelFetch(iChannel0, ivec2(id % int(MAX_PER_ROW), id / int(MAX_PER_ROW)), 0);\n}\n\n\n\nvec3 Fog(vec3 rgb,float distance, vec3 fogColor)\n{\n    float fogAmount = 1.0 - exp( -distance*0.3 );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nbool floorIntersect(in vec3 ro, in vec3 rd, out float t) \n{\n    if(rd.y < -0.01)\n    {\n        t = ro.y / - rd.y;\n        return true;\n    }\n    return false;\n} \n\n\nvec3 Render(vec3 ro,vec3 rd,vec3 cd,float dist, int frame)\n{\n    float \tt = 0.;\n    vec3\tpi;\n    bool\tcolPlane = false;    \n    if(floorIntersect(ro, rd, t))\n    {\n        pi = ro + rd * t;\n        colPlane = true;\n    }\n    \n    \n    \n    float mint = dist;\n    float sha = 1.;\n    vec3  c = vec3(0);\n    for(int i = 0; i < nbPart; i++)\n    {\n        vec3 pos = Load(i).xyz;\n        float t = sphIntersect( ro, rd, pos, BALL_RADIUS).x;\n        if(t > 0. && t < mint)\n        {\n            mint = t;\n            c = pos;\n        }\n        if(colPlane)\n        {\n            float lifeSpan;\n        \tif (i > (frame % nbPart))\n            {\n                lifeSpan = float(i - (frame % nbPart)) / float(nbPart);\n            }\n            else\n            {\n                lifeSpan = float(512 + i - (frame % nbPart)) / float(nbPart);\n            }\n            float fadeGap = 0.05;\n            float sc = BALL_RADIUS * smoothstep(0.0, fadeGap, lifeSpan) * smoothstep(1.0, 1.0 - fadeGap, lifeSpan);\n\n            t = sphIntersect( pi, normalize(vec3(0.2,1,0.1)), pos, sc).x;\n          \tif(t > 0.)\n            {\n                sha = 0.7;\n            }\n        }\n    }\n    \n    vec3\tcol = vec3(0);\n    if(mint<dist)\n    {\n        vec3 i = (ro + mint * rd);\n        vec3 n = normalize(i - c);\n        vec3 r = reflect(rd, n);\n        col = texture(iChannel1, r).rgb;\n    }\n    else if(colPlane)\n    {\n        mint = t;\n        col = vec3(0.3) * sha;\n    }\n    col = Fog(col, mint, vec3(0)); \n    \n    return col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n        \n#if AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n\t    int f = iFrame % wrapFrame;\n        float a1 = sin(float(f) * 1./60.f) * radians(90.);\n        float a2 = (float(f - 1900) * 1./60.f) * 3. ;\n\t\tfloat theta\t= mix(a1, a2, clamp((float(f) - 1900.) / 100., 0., 1. ));\n        float phi\t= radians(70.);\n\n        vec3 ro = 2.2 * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        vec3 ta = vec3(0,0.8,0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        vec3 rd =  ca*normalize(vec3(p,1.5));              \n        vec3 col = Render(ro ,rd ,ca[2],12., f);\n        tot += col;\n            \n#if AA\n    }\n    tot /= 4.;\n#endif\n\ttot = vignette(tot, fragCoord / iResolution.xy, 0.8);\n\tfragColor = vec4( sqrt(tot), 1.0 );\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 24304,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/hexen-1/second-reality-future-crew"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\nvec4 Load(in int id)\n{\n\treturn texelFetch(iChannel0, ivec2(id % int(MAX_PER_ROW), id / int(MAX_PER_ROW)), 0);\n}\n\n\nconst float restitution = 13. / 16.;\nconst float dropper\t\t= 1.f;\nconst float scale\t\t= 1. / 40.;\nconst float baseGravity\t= 9.8 / 200.;\n\nfloat intToRad(in int a)\n{\n\treturn float(a) * tau / 1024.;\n}\n\nvec4 spawnNewParticle(in int f)\n{\n    vec4 dotInfo;\n    if(f < 500)\n    {\n        dotInfo.x = sin(intToRad(f*11)) * 40. * scale;\n        dotInfo.y = cos(intToRad(f*13)) * 10. * scale + dropper;\n        dotInfo.z = sin(intToRad(f*17)) * 40. * scale;\n        dotInfo.w = 0.;\n    }\n    else if(f < 900)\n    {\n        dotInfo.x = cos(intToRad(f*15)) * 55. * scale;\n        dotInfo.y = dropper;\n        dotInfo.z = sin(intToRad(f*15)) * 55. * scale;\n        dotInfo.w = 2.5;\n    }\n    else if(f < 1700)\n\t{\t\n        float a = sin(intToRad(f)) * 256. / 8.;\n        dotInfo.x = cos(intToRad(f*66)) * a * scale;\n        dotInfo.y = 0.;\n        dotInfo.z = sin(intToRad(f*66)) * a * scale;\n        dotInfo.w = 5.;\n\t}\n    else if(f < 2360)\n    {\n        dotInfo.xyz= (hash31(float(f)) - 0.5) * 2. * 3.;\n        dotInfo.w = 0.;    \n    }\n    else\n    {\n        dotInfo = vec4(vec3(4000.), 0);\n    }\n    \n\treturn dotInfo;\n}\n\nvec4 update(in vec4 dotInfo, in int f)\n{\n    float oldY = dotInfo.y;\n    float gravity = baseGravity * smoothstep(2000., 1900., float(f));\n    dotInfo.y += dotInfo.w / 200.;\n    dotInfo.w -= gravity;\n    if(dotInfo.y < 0.)\n    {\n        float r = oldY / (oldY - dotInfo.y);\n        dotInfo.y = -dotInfo.y * restitution;\n        dotInfo.w = (-2. * gravity * (1. - r) - dotInfo.w)  * restitution;\t\t// This make the bounce almost perfect, this point that annoyed my eye a little in the original demo. But let say, it's an old demo from the integer time, much easier to fix today :)\n    }\n    return dotInfo;\n}\n  \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int\tpixId = int(fragCoord.x + MAX_PER_ROW * fragCoord.y);\n    if( fragCoord.x >= MAX_PER_ROW || pixId >= nbPart)\n    {\n        discard;\n    }\n    vec4\tdotInfo;\n    if(iFrame == 0)\n    {\n        dotInfo = vec4(vec3(4000.), 0);\n    }\n    else\n    {\n        dotInfo = Load(pixId);\n    }\n    \n   \n    int f = iFrame % wrapFrame;\n    \n    if((f % nbPart) == pixId)\n    {\n        dotInfo = spawnNewParticle(f);\n    }\n\n\tdotInfo = update(dotInfo, f);\n    \n    fragColor = dotInfo;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nconst int\twrapFrame = 3000;\nconst int\tnbPart = 512;\nconst float\ttau = radians(360.);\n#define MAX_PER_ROW\t\t256.\n#define BALL_RADIUS\t\t0.01\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}