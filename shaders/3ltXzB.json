{
    "Shader": {
        "info": {
            "date": "1581239086",
            "description": "34rregtr",
            "flags": 0,
            "hasliked": 0,
            "id": "3ltXzB",
            "likes": 6,
            "name": "sohere defoirmation",
            "published": 3,
            "tags": [
                "333"
            ],
            "usePreview": 0,
            "username": "antoinefortin",
            "viewed": 342
        },
        "renderpass": [
            {
                "code": "float sdElipsoid(vec3 pos, vec3 rad)\n{\n\tfloat k0 = length(pos / rad);\n    float k1 = length(pos / rad / rad);\n    \n    return k0 *(k0 - 1.0) / k1;\n    \n    \n}   \n\nvec2 rotate(vec2 pos, float angle)\n{\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c,s,-s,c) * pos;\n}\n\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n    \nfloat sdSphere(vec3 pos, vec3 r)\n{\n\treturn 1.0;\n}\n\n \n\nfloat shape(vec3 p)\n{\n\n    vec3 res = vec3(1.0,-1., -1.);\n\tvec3 q = p;\n   \tq.y -=5.5;\n    q.xz = rotate(q.xz, iTime *.5);\n    q.yx = rotate(q.yx, iTime *1.25);\n    float rad = 5.0 + .5 * sin(q.z - iTime * 5.)\n        * cos(q.x + 2.0 * 1.5) \n        * (sin(q.z * 3.5) + cos(q.y * 1.5) ); // base\n  \n     // q.x = mod(q.x + .5, 1.0) - .5;\n    float d = length(q) - rad;\n    \n    \n    d *= .25;\n    \n    res = vec3(d, 1.0, res.z);\n    return res.x; // the distance;\n    \n}\n\n\n\n\nfloat map(vec3 pos)\n{\n    vec3 q = pos;\n    \n\tfloat d = shape(q);\n    \n    \n    // Floor\n    float d2 = pos.y - (-0.95);\n    float ret = min(d, d2);\n    \n        \n    \n    return ret;\n}\n\n\n\n    \n\nfloat castRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n    \tvec3 pos = ro + t * rd;\n        \n        float h = map(pos);\n        if(h < 0.001)\n        {\n        \tbreak;\n        }\n        t += h;\n        \n        if(t > 20.0) break;\n        \n    }\n    \n    if(t > 20.0) t = -1.0;\n    \n    return t;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    \n\treturn normalize(vec3(\n        \t\t\t\t\tmap(pos+e.xyy) - map(pos-e.xyy),\n        \t\t\t\t\tmap(pos+e.yxy) - map(pos-e.yxy),\n        \t\t\t\t\tmap(pos+e.yyx) - map(pos-e.yyx)\n    \t\t\t\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * fragCoord- iResolution.xy) / iResolution.y;\n\n\t//vec3 ro = vec3(0.0 + iTime * 3.,4.5 + sin(iTime),12.5 + iTime * 5.);\n    \n    \n    vec3 ro = vec3(1.,  4., 15.);\n    vec3 rd = normalize(vec3(p, -1.5));\n\t\n    \n    vec3 col = vec3(0.4, 0.75, 1.0) - 0.7 * rd.y;\n    \n\tfloat t = castRay(ro, rd);\n    \n    \n    if(t > 0.)\n    {\n        \n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        vec3 sunPosition = vec3(sin(iTime),  1. + cos(iTime),0.9);\n       \tvec3 sundir = normalize(sunPosition);\n     \tvec3 mate = vec3(0.18);\n        \n\n        float sundif = clamp(dot(nor, sundir), 0.0, 1.0);\n        float sun_sha = smoothstep(castRay(pos + nor * 0.001, sundir), 0.0, 1.0);\n        float sky_dif = clamp(0.5 + 0.5 * dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0);\n        float bou_dif = clamp(0.5 + 0.5 *dot(nor,vec3(0.0,-1.0,0.0)), 0.0, 1.0);\n        \n        col = mate * vec3(t * 0.5, t * 0.25, 1.0) * sundif * sun_sha;\n        col += mate * vec3(0.75, 0.8, 0.9) * sky_dif;\n        col += mate * vec3(0.75, 0.3, 0.2) * bou_dif;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}