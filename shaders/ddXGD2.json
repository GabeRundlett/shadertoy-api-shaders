{
    "Shader": {
        "info": {
            "date": "1666803765",
            "description": "quick and messy idea, might be cool to have a whole bunch of these in a grid or something",
            "flags": 0,
            "hasliked": 0,
            "id": "ddXGD2",
            "likes": 9,
            "name": "Circle Joiny Thingy",
            "published": 3,
            "tags": [
                "e"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 247
        },
        "renderpass": [
            {
                "code": "// Maths and stuff:\n// http://jwilson.coe.uga.edu/EMAT6680Su06/Swanagan/Assignment7/BSAssignment7.html\n\n#define pi 3.14159\n#define k 1. / iResolution.y\n\nvec2 getCircle(vec2 uv, vec2 p1, float r1, vec2 p2, float r2, float a) {\n     // maths and stuff\n    vec2 e = p2 - r2 * vec2(cos(a), sin(a));\n    vec2 f = e  + r1 * vec2(cos(a), sin(a));\n    vec2 g = 0.5 * (f + p1);\n    \n    // intersect 2 lines to find 3rd point\n    float v1 = (f.y - p1.y) / (f.x - p1.x);\n    float v2 = (f.y - p2.y) / (f.x - p2.x);\n    vec2 p3;\n    p3.x = (g.x + v1 * v2 * f.x + v1 * (g.y - f.y)) / (v1 * v2 + 1.);\n    p3.y = v2 * (p3.x - f.x) + f.y;\n        \n    return p3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = (fragCoord - 0.5 * res) / res.y;\n    \n    // first 2 circles\n    vec2 p1 = vec2(0.1, 0.1 * cos(0.5 * iTime));\n    vec2 p2 = vec2(-0.3, 0.1 * sin(0.5 * iTime));\n    float l = length(p1 - p2);\n    float r1 = (0.3 + 0.2 * cos(iTime)) * l;\n    float r2 = (0.3 + 0.2 * sin(iTime)) * l;\n    \n    float d1 = length(uv - p1);\n    float d2 = length(uv - p2);\n    float s1 = smoothstep(-k, k, 2. * k - abs(d1 - r1));\n    float s2 = smoothstep(-k, k, 2. * k - abs(d2 - r2));\n     \n    // angle from p2 circle where p3 circle is tangent\n    float a = atan(p2.y - p1.y, p2.x - p1.x);\n    float av = 0.4 * pi; // abs(av) < 0.5 I think\n    vec2 p3 = getCircle(uv, p1, r1, p2, r2, a + av);\n    float r3 = length(p3 - p2) - r2;\n    vec2 e1 = p3 + normalize(p2 - p3) * r3;\n    vec2 e2 = p3 + normalize(p1 - p3) * r3;\n    float de1 = length(uv - e1);\n    float de2 = length(uv - e2);\n    float se1 = smoothstep(-k, k, 0.01 - de1);\n    float se2 = smoothstep(-k, k, 0.01 - de2);\n\n    float d3 = length(uv - p3);\n    float s3 = smoothstep(-k, k, d3 - r3 + 2. * k);\n    \n    vec2 p4 = getCircle(uv, p1, r1, p2, r2, a - av);\n    float r4 = length(p4 - p2) - r2;\n    vec2 e3 = p4 + normalize(p2 - p4) * r4;\n    vec2 e4 = p4 + normalize(p1 - p4) * r4;\n    float de3 = length(uv - e3);\n    float de4 = length(uv - e4);\n    float se3 = smoothstep(-k, k, 0.01 - de3);\n    float se4 = smoothstep(-k, k, 0.01 - de4);\n\n    float d4 = length(uv - p4);\n    float s4 = smoothstep(-k, k, d4 - r4 + 2. * k);\n    \n    float left  = min(min(e1.x,e2.x),min(e3.x,e4.x));\n    float right = max(max(e1.x,e2.x),max(e3.x,e4.x));\n    float top   = min(min(e1.y,e2.y),min(e3.y,e4.y));\n    float bot   = max(max(e1.y,e2.y),max(e3.y,e4.y));\n    float avx = 0.5 * (left + right);\n    float avy = 0.5 * (bot + top);   \n    float w = right - left;\n    float h = bot - top;\n    float sb = step(abs(uv.y - avy), 0.5 * h) *\n               step(abs(uv.x - avx), 0.5 * w);\n    sb *= smoothstep(-k, k, d1 - r1 - k * 2.);\n    sb *= smoothstep(-k, k, d2 - r2 - k * 2.);\n    \n    vec3 col = vec3(0.2,0.6,0.95) * vec3(s1 + s2 + s3 * s4 * sb);\n    //col += se1 + se2 + se3 + se4;\n    col += 0.08;\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}