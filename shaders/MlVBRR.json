{
    "Shader": {
        "info": {
            "date": "1541656961",
            "description": "Voronoi tessellated sphere with normal perturbation and reflection map\n\nMainly based on iq's Voronoi tessellation https://www.shadertoy.com/view/ldl3W8\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "MlVBRR",
            "likes": 26,
            "name": "Disco Ball",
            "published": 3,
            "tags": [
                "3d",
                "voronoi"
            ],
            "usePreview": 0,
            "username": "cfrezksa",
            "viewed": 1791
        },
        "renderpass": [
            {
                "code": "\n#define PI 3.1415926\n// set to reflection anim speed\n#define ANIMATE (0.0) \n// set to rotation anim speed\n#define ROTATE (0.025)\n#define RIM_ATTENUATION \n\nconst vec2 scale = vec2(50.0,100.0);\n\n// sphere of size ra centered at point ce\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h < 0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec2 perturb(vec2 o) {\n    return  0.5+0.5*o*vec2(sin(6.2831*o.x + ANIMATE * iTime), cos(6.2831*o.x + ANIMATE * iTime));\n}\n\nvec2 mg;\nvec2 mo;\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( mod(n + g,scale) );\n\t\t#ifdef ANIMATE\n        o = perturb(o);\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n            mo = o;\n        }\n    }\n\n   \n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( mod(n + g,scale)  );\n\t\t#ifdef ANIMATE\n        o = perturb(o);\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\t\n    return vec3( md, mr );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\t{\n        \n\tvec2 position=(fragCoord.xy/iResolution.xy);\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n   \n\tvec3 ro = vec3(0.0, 0.0, 4.0 );\n\tvec3 rd = normalize( vec3(p,-2.0) );\n\t        \n    vec2 sphere = sphIntersect(ro, rd, vec3(0.0), 1.5);\n        if (sphere.x < 0.0) {\n         fragColor= 0.5*texture(iChannel0, rd);\n         return;   \n        }\n        \n    vec3 q = ro + sphere.x * rd;\n    vec3 n = -normalize(q);\n        \n    float r = length(n);\n    float theta = acos(n.y/r) / PI;\n    float phi   = (atan(n.z,n.x) / PI + 1.0)/2.0;\n    phi = mod(phi + ROTATE*iTime + iMouse.x/iResolution.x, 1.0);\n    theta = mod(theta + (1.0-iMouse.y/iResolution.y), 1.0);\n    float phiN = fract(phi);    \n    float thetaN = fract(theta);\n\n        \n    vec2 x = vec2(thetaN, phiN);\n    vec3 c = voronoi(scale * x);\n\n\tfloat dd = length( c.yz );\n\t// isolines\n    vec3 col = mo.xyx;//vec3(0.2,0.4, 0.6);\n\n    vec3 N = normalize(n + 0.2 * col);\n    vec3 V = vec3(0.0, 0.0, 1.0);\n    vec3 R = dot(N,V)*N*2.0 - V;\n    \n    vec4 refl = vec4(1.0,0.95,0.98,1.0)*texture(iChannel0, R); \n        // borders\t\n    float s = 0.05 + 0.2 * pow(1.0-dot(n,rd),3.0);\n    refl *= mix( 0.25, 1.0, smoothstep( 0.0, s, c.x ) );\n        \n\tfragColor = (0.5 + 0.7*(1.0 - dot(n,rd))) * refl;\n        \n#ifdef RIM_ATTENUATION\n    fragColor *= vec4(-n.zzz, 1.0);\n#endif\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}