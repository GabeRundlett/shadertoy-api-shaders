{
    "Shader": {
        "info": {
            "date": "1563860222",
            "description": "Just randomly trying things with this fractal and seeing what looks nice.",
            "flags": 0,
            "hasliked": 0,
            "id": "3llSzf",
            "likes": 11,
            "name": "Apollonian Flow",
            "published": 3,
            "tags": [
                "fractal",
                "apollonian"
            ],
            "usePreview": 0,
            "username": "otaviogood",
            "viewed": 663
        },
        "renderpass": [
            {
                "code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n-Otavio Good\n*/\n\n// Number of antialiasing samples - if your computer is fast, make it bigger.\nconst int numSamples = 32;\n// Set to 0 or 1 for different effects\n#define STYLE2 0\n\n\nvec3 Fractal(vec2 p, uint seed0, float localTime)\n{\n    vec2 wraps = vec2(0.0);\n    uint seed = SmallHashIA(uint(floor((p.x+256.0)*0.5)));\n    seed ^= SmallHashIB(uint(floor((p.y+256.0)*0.5+139.0)*15467.0));\n    seed ^= seed0;\n\n    vec2 pr = p;\n    // repeat -1 to 1 region, still scaled to -1 to 1\n    pr = fract(pr*0.5+0.5)*2.0 - 1.0;\n    // Bend to be more squareish or diamondish, oscillating over time\n    pr = pow(abs(pr),vec2(1.0+sin(iTime*0.5)*0.3))*sign(pr);\n    //if (length(fract(pr*0.5)-0.5) > 0.5) return vec4(0.005);\n    for (int i = 0; i < 15; i++)\n    {\n        // If it's out of range and gonna be repeated, count it.\n        wraps.xy = floor(pr*0.5+0.5)*1.1-0.015;\n        // repeat -1 to 1 region, still scaled to -1 to 1\n        pr = fract(pr*0.5+0.5)*2.0 - 1.0;\n        // Bend to be more squareish\n        pr = pow(abs(pr),vec2(1.2))*sign(pr);\n        // Make little rings that turn into swooshy lines at higher iterations.\n        float l = length(fract(pr*0.5)-0.5);\n        l = sin(l*4.0/float(i+1));\n        if ((l > 0.35) && (l < 0.355)) return vec3(0.025);\n\n        // Darken regions outside a circle on higher iterations.\n        if ((i > 2) && (length(fract(pr*0.5)-0.5) > 0.5)) return vec3(0.005);\n        // Rotate whatever is outside the circle\n        if (length(pr) > 1.0)\n            pr = Rotate(pr, localTime*0.03+float(seed&0xffu));\n        // length squared\n        float len = dot(pr, pr);\n        // sorta normalize position - divide by length SQUARED. Invert the circle.\n        float inv = 1.0/len;\n        pr *= inv;\n        // Rotate things based on their distance from the center of the circle.\n#if STYLE2\n        if (length(pr) < 1.1)\n#endif\n        \tpr = mix(pr, Rotate(pr, -localTime*0.1), saturate(length(pr)));\n    }\n    float dist = 0.0;// length(pr*pr)*0.5;\n    return vec3(dist, wraps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    SetRandomSeed(uint(fragCoord.x), uint(fragCoord.y), uint(iFrame*0));\n    // center and scale the UV coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x -= 0.2;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 4.0;\n\n    fragColor = vec4(0,0,0,1);\n    if (uv.x >= 4.0) return;\n    if (uv.x <= 0.0) return;\n\n    // Loop that takes many samples of the image for anti-aliasing\n    vec4 totalColor = vec4(0.0);\n    for (int samp = ZERO_TRICK; samp < numSamples; samp++) {\n        float antialias = dFdx(uv.xy).x*1.0;\n        vec2 uv2 = uv + Randf2() * antialias;\n        // Do the thing!\n        vec3 fr = Fractal(uv2, 1234567u, cos(iTime*0.25)*12.0);\n        //fr.x = step(fr.x, 0.5);\n        float dist = length(fr.yz);\n        vec3 finalColor = vec3(-cos(dist*21.123), -cos(dist*0.77), -cos(dist*5.321))*0.5+0.5;\n\n        // Accumulate antialiasing samples\n        totalColor.xyz += finalColor;\n        totalColor.w += 1.0;\n    }\n\n    fragColor = vec4(sqrt(totalColor.xyz / totalColor.w), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ---- general helper functions / constants ----\n#define saturate(a) clamp(a, 0.0, 1.0)\n// Weird for loop trick so compiler doesn't unroll loop\n// By making the zero a variable instead of a constant, the compiler can't unroll the loop and\n// that speeds up compile times by a lot.\n#define ZERO_TRICK max(0, -iFrame)\nconst float PI = 3.14159265;\n\nvec2 Rotate(vec2 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec2(cos * v.x + sin * v.y, -sin * v.x + cos * v.y);\n}\n\n// ---- Hash functions and random number generation ----\n// Random 32 bit primes from this site: https://asecuritysite.com/encryption/random3?val=32\n// This is the single state variable for the random number generator.\nuint randomState = 4056649889u;\n\n// 2 simple hash functions - for extra randomness, call them both\nuint SmallHashIA(uint seed) {\n    return (seed ^ 1057926937u) * 3812423987u;\n}\nuint SmallHashIB(uint seed) {\n    return (seed ^ 2156034509u) * 808515863u;\n}\n\n// Returns a random float from [0..1]\nfloat Hashf1(uint seed) {\n    seed = SmallHashIA(seed);\n    // 0xffffff is biggest 2^n-1 that 32 bit float does exactly.\n    // Check with Math.fround(0xffffff) in javascript.\n    return float(seed & 0xffffffu) / float(0xffffff);\n}\n// Reduced precision to 10 bits per component.\nvec3 Hashf3(uint seed) {\n    seed = SmallHashIA(seed);\n    return vec3((seed >> 2) & 0x3ffu,\n                (seed >> 12) & 0x3ffu,\n                seed >> 22) / float(0x3ffu);\n}\n\n// Combine random state with hash function to get a random float [0..1]\nfloat Randf1() {\n    randomState = SmallHashIA(randomState) >> 7;\n    randomState = SmallHashIB(randomState);\n    // 0xffffff is biggest 2^n-1 that 32 bit float does exactly.\n    // Check with Math.fround(0xffffff) in javascript.\n    return float(randomState & 0xffffffu) / float(0xffffff);\n}\n// Reduced precision to 16 bits per component.\nvec2 Randf2() {\n    randomState = SmallHashIA(randomState) >> 7;\n    randomState = SmallHashIB(randomState);\n    return vec2(randomState & 0xffffu,\n                randomState >> 16) / float(0xffff);\n}\n// Reduced precision to 10 bits per component.\nvec3 Randf3() {\n    randomState = SmallHashIA(randomState) >> 7;\n    randomState = SmallHashIB(randomState);\n    return vec3((randomState >> 2) & 0x3ffu,\n                (randomState >> 12) & 0x3ffu,\n                randomState >> 22) / float(0x3ffu);\n}\n\n// Set a unique (hopefully) random seed for each pixel and time.\n// Call like this: SetRandomSeed(uint(fragCoord.x), uint(fragCoord.y), uint(iFrame));\nvoid SetRandomSeed(uint a, uint b, uint c) {\n    randomState = SmallHashIA(a)>>7;\n    randomState ^= SmallHashIB(b * 3435263017u);\n    randomState += c * 7u;\n}\n\n// Returns random number sampled from a circular gaussian distribution\n// https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\nvec2 RandGaussianCircle() {\n    vec2 u = Randf2();\n    u.x = max(u.x, 0.00000003); // We don't want log() to fail because it's 0.\n    float a = sqrt(-2.0 * log(u.x));\n    return vec2(a * cos(2.0*PI*u.y), a * sin(2.0 * PI * u.y));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}