{
    "Shader": {
        "info": {
            "date": "1677414370",
            "description": "*** PAUSE/REWIND SHADER FOR SOUND ***",
            "flags": 64,
            "hasliked": 0,
            "id": "mdt3D7",
            "likes": 56,
            "name": "I'll Be Back",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "robot",
                "lava",
                "terminator",
                "movie",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "dean_the_coder",
            "viewed": 3694
        },
        "renderpass": [
            {
                "code": "// 'I'll Be Back' dean_the_coder (Twitter: @deanthecoder)\n// Shadertoy: https://www.shadertoy.com/view/mdt3D7\n// YouTube: https://youtu.be/Tk-UNehhoMw\n//\n// *** PAUSE/REWIND SHADER FOR SOUND ***\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// My 2nd Terminator-inspired shader (1st: https://www.shadertoy.com/view/3tKyzV)\n// I took some aristic license on this one. In the movie the palm is facing\n// away from the camera, but I thought it more interesting to see the fingers.\n//\n// I'm making use of a few routines I've built up in my earlier shaders.\n// E.g. Ground fog, floating particles, and 'glow'.\n//\n// Tricks to aid performance:\n//   - There's only two fingers.\n//     Two are reflections (with a tweak in dimensions and animation).\n//   - There's only two chain links and one chain.\n//     Domain repetion extends the links to make a single chain.\n//     The second chain is a mirror of the first (z = abs(z)).\n//   - Small SDF details are only calculated when the ray point is\n//     close to the object.\n//   - Precalculate function results and simplify calculations\n//     when possible (see GLSL Shader Shrinker).\n//     (Rotation matrices, etc...)\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n#define MIN_DIST\t1e-4\n#define START_DIST\t1.\n#define MAX_DIST\t64.\n#define MAX_STEPS\t120.\n#define MAX_RDIST\t7.\n#define MAX_RSTEPS\t32.\n#define SHADOW_STEPS\t30.\n#define LIGHT_RGB\tvec3(4, 2.34, .04)\n\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define I0\tmin(iFrame, 0)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n\nfloat t;\nvec2 g;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 p;\n};\n\nvoid U(inout Hit h, float d, int id, vec3 p) { if (d < h.d) h = Hit(d, id, p); }\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat dot3(vec3 v) { return dot(v, v); }\n\nfloat sum2(vec2 v) { return dot(v, vec2(1)); }\n\n// Thnx Dave_Hoskins - https://www.shadertoy.com/view/4djSRW\nfloat h11(float p) {\n\tp = fract(p * .1031);\n\tp *= p + 3.3456;\n\treturn fract(p * (p + p));\n}\n\nfloat h31(vec3 p3) {\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 333.3456);\n\treturn fract(sum2(p3.xy) * p3.z);\n}\n\nfloat h21(vec2 p) { return h31(p.xyx); }\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, sum2(s.yz)) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\n// Three n31 results from three scales.\nvec3 n3331(vec3 p) {\n\tconst vec3 s = vec3(5, 13, 196);\n\tvec3 ns;\n\tfor (int i = I0; i < 3; i++)\n\t\tns[i] = n31(p * s[i]);\n\n\treturn ns;\n}\n\nfloat fbm(vec3 p) {\n\tfloat i,\n\t      a = 0.,\n\t      b = .5;\n\tfor (i = Z0; i < 4.; i++) {\n\t\ta += b * n31(p);\n\t\tb *= .5;\n\t\tp *= 2.;\n\t}\n\n\treturn a * .5;\n}\n\nfloat sabs(float f) { return sqrt(f * f + .01); }\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 ax(vec3 p) { return vec3(abs(p.x) - .5, p.yz); }\n\nvec3 az(vec3 p) { return vec3(p.xy, abs(p.z) - .8); }\n\nfloat rep(float p, float c) { return p - c * floor(p / c + .5); }\n\nvec3 bend(vec3 p, float k) {\n\tfloat c = cos(k * p.x),\n\t      s = sin(k * p.x);\n\tp.xz *= mat2(c, s, -s, c);\n\treturn p;\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat box2d(vec2 p) {\n\tvec2 q = abs(p) - vec2(.015, 0);\n\treturn length(max(q, 0.)) + min(max2(q), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.yz), p.x)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tr *= 1. - p.x / h * .14;\n\tp.x -= clamp(p.x, 0., h);\n\treturn length(p) - r;\n}\n\nfloat tri(vec3 p, vec3 a, vec3 c) {\n\tconst vec3 b = vec3(.06, 0, 0);\n\tvec3 ba = b - a,\n\t     pa = p - a,\n\t     cb = c - b,\n\t     pb = p - b,\n\t     ac = a - c,\n\t     pc = p - c,\n\t     n = cross(ba, ac);\n\treturn sqrt((sign(dot(cross(ba, n), pa)) + sign(dot(cross(cb, n), pb)) + sign(dot(cross(ac, n), pc)) < 2.) ? min(min(dot3(ba * sat(dot(ba, pa) / dot3(ba)) - pa), dot3(cb * sat(dot(cb, pb) / dot3(cb)) - pb)), dot3(ac * sat(dot(ac, pc) / dot3(ac)) - pc)) : dot(n, pa) * dot(n, pa) / dot3(n));\n}\n\nfloat honk(inout vec3 p, mat2 rot, float h, float r) {\n\tp.xz *= rot;\n\tfloat d = cap(p, h, r);\n\tp.x -= h;\n\treturn d;\n}\n\nfloat hex3D(vec3 p, vec2 h) {\n\tconst vec3 k = vec3(-.8660254, .5, .57735);\n\tp = abs(p);\n\tp.xz -= 2. * min(dot(k.xy, p.xz), 0.) * k.xy;\n\tvec2 d = vec2(length(p.xz - vec2(clamp(p.x, -k.z * h.x, k.z * h.x), h.x)) * sign(p.z - h.x), p.y - h.y);\n\treturn min(max2(d), 0.) + length(max(d, 0.));\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nfloat fakeEnv(vec3 n) {\n\t// Thanks Blackle.\n\treturn length(sin(n * 2.5) * .5 + .5) * (.4 + .6 * n31(n - t));\n}\n\nvec3 skyCol(vec3 rd) { return mix(vec3(.2, .001, .005), vec3(1, .15, .001), fakeEnv(rd)); }\n\n// Shameless self-promotion. :)\nfloat dtc(vec2 p) {\n\tp *= vec2(-4, 5);\n\tif (abs(p.x) > .6 || abs(p.y) > .5) return 0.;\n\tif (step(min2(abs(p - vec2(0, .25))), .08) * step(p.y, .3) * step(abs(p.x), .4) > 0.) return 1.;\n\tfloat f,\n\t      dc = step(.5, p.x);\n\tp.x = abs(p.x) - .46;\n\tf = dot(p, p);\n\tdc += step(f, .25) * step(.16, f);\n\treturn dc > 0. ? .8 : 0.;\n}\n\n#define SKY_ID\t0\n#define LAVA_ID\t1\n#define GLOVE_ID\t2\n#define SKIN_ID\t3\n#define LEATHER_ID\t4\n#define BELOW_ARE_REFLECTIVE\t5\n#define STEEL_ID\t6\n#define CHAIN_ID\t7\n\nfloat links(vec3 p) {\n\tp.y = rep(p.y, .36);\n\tfloat r2 = .01 + .002 * S(.015, 0., abs(p.y)) * step(p.x, 0.);\n\treturn length(vec2(length(vec2(p.x, max(abs(p.y) - .05, 0.))) - .06, p.z)) - r2;\n}\n\nfloat chain(vec3 p, float b) {\n\tp.y -= 5.;\n\tp.yzx = bend(p.yzx, -.003 * sin(t) * b);\n\tp.y += 5.;\n\tfloat d = links(p);\n\tp.y += .18;\n\tp.xz *= mat2(.07074, .99749, -.99749, .07074);\n\treturn min(d, links(p));\n}\n\nHit sdf(vec3 p, float shad) {\n\tp.x += .25;\n\tfloat curl, l,\n\t      lava = p.y + 1. + sin(p.x + t) * .05,\n\t      d = lava;\n\tHit h = Hit(d + shad * 1e7, LAVA_ID, p);\n\n\t// Big floaty.\n\tvec3 r,\n\t     q = ax(p);\n\tif (d < .3 && q.x > 2.) {\n\t\tq.xz -= 3.;\n\t\tq.y += 1.05 - sin(p.x + t - 2.) * .04;\n\t\td = n31(q * 4.5) * .1;\n\t\td = hex3D(q, vec2(.7 + d, .1)) - d;\n\t\tU(h, d, LEATHER_ID, q);\n\t}\n\n\t// Dunk!\n\tp.y += t * .15 - .3;\n\n\t// Glow near the lava.\n\tg += 1e-4 / (.01 + lava);\n\tg += S(.7 * S(16., 10., t), 0., length(p.xz + .25)) * 2e-4 / (2e-5 + lava * lava);\n\n\t// Chains.\n\tq = p;\n\tq.xz *= mat2(.92106, .38942, -.38942, .92106);\n\tq = az(q - vec3(1, 0, -.5));\n\tU(h, chain(q, sign(p.z)), CHAIN_ID, q);\n\n\t// Sleeve.\n\tq = p.yxz;\n\tq.x++;\n\tq.y += .16;\n\td = abs(length(q.yz) - .5 + .01 * cos(p.y * 14.)) - .01;\n\td = smin(d, p.y + p.x * .3 + .4 * cos(p.x * 1.6), -.05);\n\tU(h, d, LEATHER_ID, q);\n\n\t// Zip.\n\tq = p;\n\tq.x = abs(q.x) - .2;\n\tq.xy *= mat2(.995, -.09983, .09983, .995);\n\tq.y = rep(q.y, .05);\n\td = max(box2d(q.xy), d - .02);\n\td = max(d, q.z);\n\td = max(d, .43 + p.y + .3 * p.x);\n\tU(h, d, STEEL_ID, q);\n\n\t// Wrist.\n\tq = p.yxz;\n\tq.xy *= mat2(.995, .09983, -.09983, .995);\n\tq.y = sabs(q.y + .2) - .16;\n\tq.x += .8;\n\tq.z -= .04;\n\td = cap(q, .7, .13);\n\tU(h, d, SKIN_ID, q);\n\tcurl = mix(sin(t * 3.) * .1, S(2., 6., t), sat(t / 4.));\n\tp.xy *= rot(1. - .4 * curl);\n\n\t// Thumb.\n\tq = p + vec3(.25, -.1, .07);\n\tq.xy *= mat2(.49757, .86742, -.86742, .49757);\n\td = honk(q, mat2(.98007, -.19867, .19867, .98007), .42, .04 - .07 * S(.1, .5, q.x));\n\tq.yz *= mat2(.16997, -.98545, .98545, .16997);\n\td = smin(d, honk(q, rot(.3 * curl - .5), .26, -.025), .04);\n\tU(h, cyl(q, vec2(.06, .15)), STEEL_ID, p);\n\td = smin(d, honk(q, mat2(.995, -.09983, .09983, .995), .22, -.03 - .065 * S(.1, .25, q.x) * S(.05, -.08, q.z)), .02);\n\n\t// Glove cut-outs.\n\td = max(d, sin(q.x * 70.) * .01 + .22 - length(q - vec3(-.25, .12, .05)));\n\n\t// Palm.\n\tp = bend(p, -.3);\n\tr = vec3(.37, .47 - S(.1, -.4, p.x) * .15, .12);\n\td = smin(d, box(p, r - .12), .16);\n\td += S(0., .2, abs(sin((atan(p.x, p.z) + atan(p.z, p.y - .2)) * 4.))) * .005;\n\tp.x -= r.x;\n\tcurl = S01(curl * (1. + step(p.y, 0.) * .3));\n\n\t// Pre-fingers paddy bit.\n\td = smin(d, tri(p, vec3(0, r.y - .12, 0), vec3(0, .12 - r.y, 0)), .05);\n\td -= .12;\n\tp.xz *= rot(-.2 - curl * .63);\n\tl = 1. + step(0., p.y) * .1 + step(.25, p.y) * .2;\n\tp.y = -abs(p.y);\n\tp.xz -= .05;\n\n\t// Ring/Middle.\n\tq = p;\n\tq.y += r.y * .5 - .12;\n\tq.xy *= mat2(.9998, -.02, .02, .9998);\n\tmat2 r1 = rot(-.7 * curl),\n\t     r2 = rot(-1.4 * curl);\n\td = smin(d, honk(q, r1, .32 * l, .105), .06);\n\td = smin(d, honk(q, r2, .17 * l, .09), .01);\n\td = smin(d, honk(q, r1, .13 * l, .08), .01);\n\n\t// Pinky/Index.\n\tq = p;\n\tq.y += r.y - .12;\n\tq.z += .07;\n\tq.xy *= mat2(.995, -.09983, .09983, .995);\n\td = smin(d, honk(q, r1, .19 * l, .105), .06);\n\td = smin(d, honk(q, r2, .13 * l, .09), .01);\n\td = smin(d, honk(q, mat2(1, 0, 0, 1), .12 * l, .08), .01);\n\n\t// Glove cut-outs.\n\td = max(d, .13 - length(q + vec3(0, .02, .03)));\n\tU(h, d, GLOVE_ID, p);\n\n\t// Robot finger tip.\n\tq.x += .07;\n\td = cyl(q, vec2(.02, .1));\n\tq.x -= .03;\n\td = min(d, cyl(q, vec2(.04)));\n\tU(h, d, STEEL_ID, p);\n\n\t// Nothing is perfectly sharp.\n\th.d -= .01;\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .1;\n\tvec3 n = vec3(0);\n\tfor (int i = I0; i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdf(p + e * h, 0.).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 lp, vec3 ld, vec3 n) {\n\t// Quick abort if light is behind the normal.\n\tif (dot(ld, n) < -.1) return 0.;\n\tfloat d,\n\t      s = 1.,\n\t      t = .005,\n\t      mxt = length(p - lp);\n\tfor (float i = Z0; i < SHADOW_STEPS; i++) {\n\t\td = sdf(t * ld + p, 1.).d;\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.03, d);\n\t\tif (mxt - t < 5. || s < .05) break;\n\t}\n\n\treturn S01(s);\n}\n\n// Quick 2-level ambient occlusion.\nfloat ao(vec3 p, vec3 n) {\n\tconst vec2 h = vec2(.25, .7);\n\tvec2 ao;\n\tfor (int i = I0; i < 2; i++)\n\t\tao[i] = sdf(h[i] * n + p, 0.).d;\n\n\treturn sat(min2(ao / h));\n}\n\nvec3 lights(vec3 p, vec3 ro, vec3 rd, vec3 n, Hit h) {\n\tconst vec3 lp = vec3(0, -10, -6);\n\tif (h.id == SKY_ID) return skyCol(rd);\n\tfloat _ao, fre, fogY, fg,\n\t      spe = 10.,\n\t      shine = 1.;\n\tvec3 c, ns, l, sky, col, uv,\n\t     ld = normalize(lp - p);\n\n\t// Cache noise.\n\tns = n3331(h.p);\n\t_ao = ao(p, n);\n\tif (h.id == LAVA_ID) {\n\t\tc = vec3(5, 2.49, .98);\n\t\tc *= .6 + .4 * (ns.x + .6 * ns.y);\n\t\tc += (1. - _ao) * 13.;\n\t}\n\telse if (h.id == GLOVE_ID) {\n\t\tc = vec3(.2, .15, .9);\n\t\tc *= .1 + .6 * ns.z;\n\t\tshine *= 4. * ns.y;\n\t}\n\telse if (h.id == LEATHER_ID) {\n\t\tc = vec3(.1 * ns.x * (.2 + .8 * ns.y));\n\t\tshine *= 20. * S01(abs(ns.z - .5 + rd.x));\n\t}\n\telse if (h.id == CHAIN_ID) {\n\t\tc = vec3(.15);\n\t\tshine = 5. * ns.y * ns.z;\n\t}\n\telse if (h.id == SKIN_ID) c = vec3(1, .63, .46);\n\telse {\n\t\t// Exo-skeleton / zip.\n\t\tc = vec3(.912, .914, 10.92);\n\t\tshine = 20.;\n\t\tspe = 50.;\n\t}\n\n\t// Specular imperfections.\n\tshine *= .5 + .5 * ns.x * ns.y;\n\n\t// Key light, reverse, sky.\n\tl = sat(vec3(dot(ld, n), dot(-ld.xz, n.xz), n.y));\n\n\t// Diffuse.\n\tl.xy = .1 + .9 * l.xy;\n\n\t// Ambient occlusion.\n\tl *= .1 + .9 * _ao;\n\n\t// Light contributions (key, reverse, sky).\n\tl *= vec3(1, .8, .3);\n\n\t// Specular (Blinn-Phong)\n\tl.x += pow(sat(dot(normalize(ld - rd), n)), spe) * shine;\n\n\t// Shadow.\n\tl.x *= .1 + .9 * shadow(p, lp, ld, n);\n\n\t// Light falloff\n\tl.x *= dot(lp, lp) / (1. + dot(lp - p, lp - p));\n\tfre = S(.7, 1., 1. + dot(rd, n)) * .2;\n\tsky = skyCol(rd);\n\tcol = mix((sum2(l.xy) * LIGHT_RGB + l.z * sky) * c, sky, fre);\n\n\t// Simple fog layer.\n\tfogY = -.25;\n\tuv = vec3(p.xz, fogY) * .4 + t * vec3(.1, -.9, .2);\n\tfloat fogTex = S(0., .5, fbm(uv));\n\tfogY -= (1. - fogTex) * .5;\n\tfg = S(0., -.5, p.y - fogY);\n\tfg *= fogTex;\n\tfg *= 1. - sat(-rd.y);\n\n\t// Distance Fog.\n\tfg += 1. - exp(dot3(p - ro) * -.01);\n\treturn mix(skyCol(vec3(rd.x, 0, rd.z)), col, 1. - sat(fg));\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Heat haze.\n\trd.xy *= 1. + n31((rd - vec3(0, t * .5, 0)) * 10.) * .03;\n\trd = normalize(rd);\n\n\t// March the scene.\n\tvec3 dv, n, col,\n\t     p = ro;\n\tfloat i,\n\t      d = START_DIST;\n\tHit h;\n\tfor (i = Z0; i < MAX_STEPS; i++) {\n\t\tif (d > MAX_DIST) {\n\t\t\th.id = SKY_ID;\n\t\t\tbreak;\n\t\t}\n\n\t\th = sdf(p, 0.);\n\t\tif (abs(h.d) < MIN_DIST * d) break;\n\t\td += h.d;\n\t\tp += h.d * rd;\n\t}\n\n\t// Floaty particles.\n\tdv = rd;\n\tfor (i = 1.5; i < d; i += 4.) {\n\t\tvec3 vp = ro + dv * i;\n\t\tvp.yz -= t * .15;\n\t\tg.x += 1. - S(0., mix(.05, .02, sat((i - 1.) / 19.)), length(fract(vp - ro) - .5));\n\t\tdv.xz *= mat2(.87758, .47943, -.47943, .87758);\n\t}\n\n\tcol = g.x * LIGHT_RGB;\n\tcol += lights(p, ro, rd, n = N(p, d), h);\n\tif (h.id > BELOW_ARE_REFLECTIVE) {\n\t\t// We hit a reflective surface, so march reflection.\n\t\trd = reflect(rd, n);\n\t\tp += n * .01;\n\t\tro = p;\n\t\td = .01;\n\t\tfor (i = Z0; i < MAX_RSTEPS; i++) {\n\t\t\tif (d > MAX_RDIST) {\n\t\t\t\th.id = SKY_ID;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\th = sdf(p, 0.);\n\t\t\tif (abs(h.d) < MIN_DIST * d) break;\n\t\t\td += h.d;\n\t\t\tp += h.d * rd;\n\t\t}\n\n\t\t// Add a hint of the reflected color.\n\t\tcol += .2 * lights(p, ro, rd, N(p, d), h);\n\t}\n\n\treturn pow(max(vec3(0), col), vec3(.4545));\n}\n\n#define RR(v)\tmod(4e4 * sin(dot(ceil(v), vec2(12, 7))), 10.)\n\n// Based on https://www.shadertoy.com/view/llXSzj by FabriceNeyret2\n// in turn based on https://www.shadertoy.com/view/XlXSz2 by patriciogv\n// Thanks all!\nvec3 os(vec2 u) {\n\tu *= 1. + sat(S(21., 23., t) * vec2(1, 1.5) - vec2(.3, 0)) * 50.;\n\tif (max2(abs(u)) > 1.) return vec3(0);\n\tvec2 o = u;\n\tfloat s = S(22., 20., t);\n\tu.x += u.y * .5 * (1. - s) * h11(u.y * 129.45 + 2.3 * t);\n\tfloat l = dtc(u - vec2(.62, -.35));\n\tfloat c = step(-.2, u.y) + step(u.x, .4);\n\tc *= step(abs(u.y), .458);\n\tvec2 p = 6. * fract(u *= 24.) - .5;\n\tu.y += ceil(t * RR(u.xx));\n\tint i = int(p.y);\n\ti = (abs(p.x - 1.5) > 1.5 ? 0 : i == 5 ? 972980223 : i == 4 ? 690407533 : i == 3 ? 704642687 : i == 2 ? 696556137 : i == 1 ? 972881535 : 0) / int(exp2(30. - ceil(p.x) - 3. * floor(RR(u))));\n\tc *= i > i / 2 * 2 ? 1. : 0.;\n\tc *= step(1., abs(u.x));\n\tc *= step(1., abs(abs(u.x) - 10.));\n\tc *= step(abs(u.x), 19.);\n\tvec3 f = max(vec3(l), sat(vec3(.9, .3, .01) + c));\n\tf *= s + (1. - s) * h21(floor(o * 1e2) + floor(t * 50.) * 123.4);\n\tf *= .6 + .4 * step(.5, fract(o.y * 80.)) * sat(.5 + .5 * sin(o.y * 8. - t * 3.));\n\treturn f * S(25., 22.5, t);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tt = mod(max(0., iTime - 1.), 28.);\n\tg = vec2(0);\n\tvec2 uv = (fc - .5 * R.xy) / R.y;\n\tvec3 col;\n\tif (t < 18.) {\n\t\tfloat st = S(0., 15., t);\n\t\tvec3 lookAt = vec3(-.1, .1 - 1.2 * st, 0),\n\t\t     ro = vec3(-st * .5, .001, mix(-2.8, -1., st));\n\n\t\t// View bob.\n\t\tro += .1 * sin(iTime * vec3(.9, .7, .3));\n\t\tro.yz *= rot(mix(-.1, .4, st));\n\t\tro.xz *= rot(mix(-.4, .4, st));\n\t\tcol = march(ro, rayDir(ro, lookAt, uv));\n\t}\n\telse col = os(uv);\n\n\t// Vignette.\n\tcol *= 1. - .5 * dot(uv, uv);\n\n\t// Grain.\n\tcol += (h21(fc) - .5) / 48.;\n\tfragColor = vec4(col * min(1., t), 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 32473,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/randyheavenridgemusic/terminator-theme"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}