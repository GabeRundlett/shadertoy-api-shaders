{
    "Shader": {
        "info": {
            "date": "1548178771",
            "description": "left: wave spectrum (set in bufC).   Mouse.y = wind speed  M.x = angle\nright: spatial waves (  inverseFourier. phases obey deep water dispersion ) \nSPACE:         show   module / phase / complex / real / imaginary    (left)\nshift-SPACE:  same for right.",
            "flags": 48,
            "hasliked": 0,
            "id": "3sf3Dj",
            "likes": 31,
            "name": "ocean spectrum",
            "published": 3,
            "tags": [
                "waves",
                "fft",
                "spectrum",
                "ocean",
                "interpolation",
                "fourier",
                "phase",
                "tessendorf"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 2596
        },
        "renderpass": [
            {
                "code": "// based on \"Fourier Workflow 2\" https://shadertoy.com/view/XtScWt\n// set module and phase in Buf C. BufD computes DFT. BufA[MIPmap max] = tot energy.\n\n\n//Display modes\n#define MAGNITUDE 0.\n#define PHASE     1.\n#define COMPONENT 2.\n#define REAL      3.\n#define IMAG      4.\n\n//Scaling\n#define LOG 0\n#define LINEAR 1\n\n#define MAG_SCALE LOG\n\nvec4 rainbow(float x)  { return .5 + .5 * cos(6.2832*(x - vec4(0,1,2,0)/3.)); }\nvec4 rainbow(vec2 C)   { return rainbow(atan(C.y,C.x)/3.1416 + .5); }\n\nvec4 paintDFT(vec2 F, float mode) {\n    // F /= SIZE;\n    return \n         mode == MAGNITUDE \n     #if   MAG_SCALE == LOG\n                           ?  vec4(log(length(F)))\n     #elif MAG_SCALE == LINEAR\n                           ?  vec4(length(F))\n     #endif\n       : mode == PHASE     ?  rainbow(F)        \n       : mode == COMPONENT ?  .5+.5*vec4(F, 0,0)\n       : mode == REAL      ?  .5+.5*vec4(F.x)\n       : mode == IMAG      ?  .5+.5*vec4(F.y)\n       : vec4(-1); // error\n}\n\nvoid mainImage( out vec4 O,  vec2 uv )\n{\n    vec2 U=uv;\n        \n    vec2 pixel = ( uv - iResolution.xy/2.) / SIZEt  + vec2(2,1)/2.,\n         tile  = floor(pixel),\n         stile = floor(mod(2.*pixel,2.));\n         uv = fract(pixel) * SIZEt / R ;\n\n    O*=0.;  \n    // uv = abs(2.*uv-1.); O = vec4(max(uv.x,uv.y)<.98); return;\n    // O = texture(iChannel3, U/R); return;\n    \n    vec2 DISPLAY_MODE = floor(texture(iChannel3, .5/R).zw);// persistant key flag.\n    \n    if (tile.y==-1. && abs(tile.x-.5)<1.) {                // buttons displaying current flags value\n        for (float i=0.; i<5.; i++) \n            O += smoothstep(.005,.0,abs(length(uv*R/SIZEt-vec2(.2+i/7.,.97))-.025));\n        float v = tile.x==0. ? DISPLAY_MODE[0] : DISPLAY_MODE[1];\n        O.b += smoothstep(.03,.02,length(uv*R/SIZEt-vec2(.2+v/7.,.97)));\n    }\n    \n    if(tile == vec2(0,0))                                  // --- spectrum (Left)\n         O += paintDFT(texture(iChannel3, ((uv-.5*SIZEt/R)/Z2+.5*SIZEt/R)/(Z)).xy, DISPLAY_MODE[0]); // initial Fourier\n\n    if(tile == vec2(1,0))  {                               // --- Output (Right)\n       float l = floor(log2(SIZE)), // normalize using modulus 2nd moment.\n             I = sqrt(texelFetch(iChannel0,ivec2(0),int(l)).r);\n        I = .3*SIZE/I;\n       //O += paintDFT(texture(iChannel2, uv).xy, DISPLAY_MODE[1]);    // final texture\n         O += paintDFT(I*texture(iChannel2, fract(.5+uv*R/SIZE/Z3)*SIZE/R).xy, DISPLAY_MODE[1]); // fftshift\n    }\n    \n    if (tile != mod(tile,vec2(2,1))) O+=.3;    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// do your operation in spectral domain here\n\n//#define rand(p)        fract(1e5*sin(dot(p,vec2(17.4,123.7))))\n#define rand(p)        hash( uvec3( 4096.*(.5+.5*p), 818) ).x \n#define gauss(x)       exp( -.5* dot(x,x) )\n#define gaussA0(U,P,S) gauss((P-(U))/(S))\n//#define gaussA(U,P,S) (( gauss((P-(U))/(S)) + gauss((P+(U))/(S)) ) /2.)\n#define ang(a)         vec2( cos(a), sin(a) )\n#define cmul(a,b)     ( mat2( a,-(a).y,(a).x ) * ang(b) )\n#define PI2 6.283185\n\n// keyboard https://www.shadertoy.com/view/llySRh\n#define keyToggle(a)  ( texelFetch(iChannel2,ivec2(a,2),0).x > 0.)\n#define keyDown(a)    ( texelFetch(iChannel2,ivec2(a,1),0).x > 0.)\n#define keyClick(a)   ( texelFetch(iChannel2,ivec2(a,0),0).x > 0.)\n\n// hash from https://www.shadertoy.com/view/XlXcW4\nvec3 hash( uvec3 x ){\nconst uint k = 1103515245U;  // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;   \n    return vec3(x)/float(0xffffffffU);\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    // --- GUI management\n    \n    vec2 M = iMouse.xy;\n    M = MOUSE==1 && length(M)>10. ? ((M-.5*R)/ SIZEt +vec2(2,1)/2.)*2.-1. : vec2(.25,0);\n    O*=0.;\n    if ( U==vec2(.5)) {\n        if (iFrame==0) O.zw = vec2(0,3);\n        else           O.zw = texture(iChannel1, U/R).zw;  \n        if ( keyDown(32) ) \n         // if ( iMouse.x/R.x < .5 )\n            if ( !keyClick(16) )\n                 O.z = mod(O.z+1., 5.) ; // persistant key flag for left window\n            else O.w = mod(O.w+1., 5.) ; // persistant key flag for right window\n        return;\n    }\n    if ( U==vec2(1.5,.5)) { O.w = float(keyToggle(64+19)); return; } // key S state\n\n    // --- spectrum construction\n    \n    O*=0.;\n    if(U.x > SIZE || U.y > SIZE) return;\n        \n    U -= .5;  // freq 0 must exist\n    vec2 X = 2.*U/SIZE - 1.; // NB: in fullscreen, slightly not symmetrical, not cheap rand did not work\n                                               // (or had to use phi(U-SIZE/2.) instead )\n    X *= Z2;  // scale frequencies\n    float l = length(X), y = iMouse.y/R.y;\n    \n    // --- your custom Fourier-space filter here --------------------\n\n    // --- create random phases with global conjugate constraint (to get real signal)\n    float s = sign(-X.x); if (s==0.) s = sign(X.y);\n    //vec2 T = ang(s*rand(s*X)*PI2); \n           // constrains (0,fmax), (fmax,0), (fmax,fmax) + DC\n    //if ( X==vec2(-1,0) || X==vec2(0,-1) || X==vec2(-1,-1) ) T *= 0.;\n\n    // --- oceanographics  Pierson and Moskowitz\n    // https://wikiwaves.org/Ocean-Wave_Spectra\n    //          exp(-.74/2(k0/k)⁴)/k^(5/2)   k0=g/V\n \n    // --- oceanographics Tessendorf / Philips spectrum\n    // p6 http://jtessen.people.clemson.edu/papers_files/coursenotes2002.pdf\n    // modulus= exp(-.5/(kL)²)/k².|dot(k,V/|V|) ; L = V²/g. stable: *exp(-.5*k²eps²)\n    // F = gauss(a/l)/(l*l)* abs(X.x) * gauss(l*eps)\n\n    float t = iTime * TIME,                         // time evolution\n          c =\n              // 1.;                                // rigid motion\n                 .4 / sqrt(l);                      // c(t) for deep water\n\n    // --- define modulus and phases:\n\n#if 0    \n\n#  define mod(X)   gauss( ( M - (X) ) / (1./16.) )  // biGauss\n\n#else    \n                                                    // P.M. oceanographic spectrum\n    float   a = M.y==0. ? .02 : .1*(.5-.5*M.y), eps = .05 / a;\n#  define d(X)  M.y==0. ? X.x : dot(X, vec2(cos(1.57*M.x),-sin(1.57*M.x)) )\n#  define mod(X)   1e-4/sqrt(a)* gauss(a/l)/(l*l)* max(0.,d(X)) * gauss(l*eps)\n\n    #endif\n    \n#define RndPhaseSep 1                               // at which stage to insert random phases\n#if RndPhaseSep\n#  define phi(X)   (   -70.*(t)*c * l )             // dispersion relation ( cf #def c )\n#else\n#  define phi(X)   ( rand(X)*PI2  -70.*(t)*c * l )  // include random phases early\n#endif\n    \n    vec2 T = (   mod( X) * ang( phi( X))            // combines modulus and phases\n               + mod(-X) * ang(-phi(-X)) ) /2.; \n#if RndPhaseSep\n    T = cmul( T, s*rand(s*X)*PI2 );                 // include random phases lately\n#endif\n    \n    // phase constraints in  (0,fmax), (fmax,0), (fmax,fmax) + DC\n    if ( X==vec2(-1,0) || X==vec2(0,-1) || X==vec2(-1,-1) ) T *= 0.;\n    //if (X.x==-1. || X.y==-1.) T=vec2(0); \n\tif (l==0.) T *= 0.;                             // cancels DC\n    \n    O = vec4(T*SIZE*10.,0,0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// invFourier transform ( based on DFT. note that FFT would be a lot more efficient ;-) )\n\n// Horizontal + Vertical Discrete Fourier Transform of the input \n// 2 passes pipelined : in -> buf.zw -> buf.xy -> out\n// ( adapted from  Flyguy's https://www.shadertoy.com/view/MscGWS# )\n\n\n//#define tex(ch,x,y) texture(ch, vec2(x,y)/iResolution.xy )\n#define tex(ch,x,y)  texelFetch(ch, ivec2(x,y), 0)\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x)*vec2(cos(b), sin(b)); } \n#define W(uv)   mod(uv+SIZE/2.,SIZE)                    // wrap [-1/2,1/2] to [0,1]\n\n\nvoid mainImage( out vec4 O, vec2 uv )\n{\n    O*=0.; \n    if(uv.x > SIZE || uv.y > SIZE) return;\n\n    for(float n = 0.; n < SIZE; n++)  {\n        float m = W(n);       // W to warp 0,0 to mid-window.\n        vec2 xn = tex(iChannel0, m+.5, uv.y).xy,\n             yn = tex(iChannel1, uv.x, m+.5).zw,\n             a =  6.2831853 *  (uv-.5) * n/SIZE;\n        \n        O.zw += cmul(xn, a.x);\n        O.xy += cmul(yn, a.y);\n    }\n    O /= SIZE;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define TIME  1.                              // 0 or 1 or speed\nconst float Z = 1., Z2 = 1., Z3 = 1.;         \n// overload via defines                  \n//#define Z     floor(exp2(4.*iMouse.y/R.y))  // Z: big pixels (lower FFT resolution )\n//#define Z2 Z                                // Z2: scale spectrum\n//#define Z3 4. // Z2.                        // Z3: scale space output\n#define MOUSE 1      // mouse controls what    1: lobe position 2: scale\n\n#define R  iResolution.xy\n#define SIZE   ( 2.*floor( R.x/(Z)/4. *1. ) ) // FFT resolution\n                                   // .8 if bandguard requires\n#define SIZEt  ( (Z) * SIZE )                 // subwindow visible size",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// used to compute spectrum energy, for final image normalization \n// ( via Parseval's identity )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O*=0.;\n    if(U.x > SIZE || U.y > SIZE) return;\n    \n    O = texelFetch(iChannel0, ivec2(U), 0);\n    O = vec4( dot(O.xy,O.xy) ); // square modulus\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}