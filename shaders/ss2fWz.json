{
    "Shader": {
        "info": {
            "date": "1646055221",
            "description": "playing with some mobius transformations.\nmaking of:\nhttps://twitter.com/Scrygl/status/1498285695282020354",
            "flags": 0,
            "hasliked": 0,
            "id": "ss2fWz",
            "likes": 6,
            "name": "Racing Thoughts",
            "published": 3,
            "tags": [
                "3d",
                "mobius",
                "cohomology"
            ],
            "usePreview": 0,
            "username": "scry",
            "viewed": 256
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n#define time iTime\n#define ptime iTime*pi/5.\n#define pi 3.141592654\n#define def pi/180.\n\n//from https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n//#define dtime time*hill(time,10.)\nfloat bitm(vec2 uv,int c) {\n    float h = 5.;\n    float w = 3.;\n    int p = int(pow(2.,w));\n    float line1 = 9591.;\n    uv = floor(vec2(uv.x*w,uv.y*h))/vec2(w,w);\n    float c1 = 0.;\n    float cc = uv.x + uv.y*w;\n    c1 = mod( floor( float(c) / exp2(ceil(cc*w-0.6))) ,2.);\n    c1 *= step(0.,uv.x)*step(0.,uv.y);\n    c1 *= step(0.,(-uv.x+0.99))*step(0.,(-uv.y+1.6));\n    return (c1);\n}\n \nvec3 slogo(vec2 uv, float ar, float size) {\n    vec2 px = vec2(1./3.,1./5.);\n    float ls = 4.1;\n    uv.x = 0.993-uv.x;\n    uv *= 8.*ls*(1./size);\n    ls += 2.;\n    float ul = length(uv);\n    uv -= px.yx*0.5*0.5*ls;\n    ul = length(vec2(uv.x*0.5,uv.y)-0.5);\n    uv.x *= ar*1.75;\n    int s = 29671;\n    int c = 29263;\n    int r = 31469;\n    int y = 23186;\n    uv.x= 5.-uv.x;\n    float b = bitm(uv,s);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,c);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,r);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,y);\n    float rr = step(0.,uv.x+px.x*13.)*step(0.,uv.y+px.y)*step(0.,(-uv.x+px.x*4.))*step(0.,(-uv.y+px.y*6.));\n    b = clamp(b,0.,1.);\n    //b = rr*floor(b);\n    //float ptime = iTime;\n    vec3 l = hsv2rgb(vec3(b+time,1.,rr-b*1.9))*rr;\n    //l -= length(uv)*0.5;\n    //l -= ul*rr*0.6;\n    l -= 0.1-clamp(ul*0.1,rr*1.-b,0.1);\n    //l -= 3.-ul*2;\n    //l = clamp(l,-1.,1.);\n    return vec3(l);\n}\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec4 map(vec3 p) {\n    vec3 o = p;\n    p.z -= .2;\n    //p *= 0.4;\n    p.xy *= r2d(sin(ptime+p.z*4.)*p.z*0.1);\n    vec3 c = p;\n    \n    p.xz *= r2d(ptime+c.z*pi*1.);\n    float rp = 2.;\n    \n    float pm = length(p);\n    //p.xz *= r2d(sin(o.y)*4.);\n    p = p/dot(p,p);\n    //p -= 0.5;\n    //p += 100.1;\n    //p.z -= 0.;\n    //p.yz *= r2d(sin(ptime)+pm*10.);\n    //p.z += 0.4;\n    p.xz += .1;\n    p.yz *= r2d(ptime+(c.y)*pi);\n    p.xz *= r2d(ptime+(c.x)*pi);\n    p.z -= .1;\n    p = p/dot(p,p);\n    //p.xy += rp/2.;\n    p = (fract(p/rp)-0.5)*rp;\n    //p += sin(abs(c)+time*20.)*.6;\n    float d = length(p)-0.03;\n    //d *= 0.2;\n    d *= 1.25-pm*0.3;\n    //d *= 0.01;\n    //d += 0.01;\n    //d += 0.1;\n    ///d = 2.;\n    //d *= pow(pm+0.01,2.)-0.1;\n    //d += 0.001-pm*0.001;\n    //d -= 0.3-pm*0.9;\n    //d *= pm-.2;\n    return vec4(p,d);\n}\n\nvec2 RM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<350;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w;\n        dO += dS*0.16;\n        ii += 0.016;\n        if (dO > 100. || dS < 0.01) {break;}\n    }\n    return vec2(dO,ii);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 R = iResolution.xy;\n    vec2 tv = uv;\n    float ar = R.x/R.y;\n    uv -= 0.5;\n    uv.x *= ar;\n    //uv = abs(uv)-sin(-ptime+length(uv)*6+2.)*0.1;\n    float dv = 4.;\n    vec2 fv = floor(uv*dv);\n    //uv -= fv/dv;\n    //uv -= 1./dv*0.5;\n    //uv *= r2d(sin(time*fv.y*fv.x)*pi+pi/2.);\n    //uv += fv/dv;\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.);\n    vec3 rd = normalize(vec3(uv,1.));\n    vec2 d = RM(ro,rd);\n    col = vec3(d.y*0.2);\n    col.r += sin(d.y*4.)/10.;\n    col.b += d.x*0.02;\n    col.g *= d.y*0.3;\n    col -= sin(col*40.+ptime)*0.02;\n    //col = sin(col*1.2);\n    col = sin(col*3.+3.7+d.x*7.);\n    col = cos(col*1.57);\n    col = rgb2hsv(vec3(col.x,col.y,col.z));\n    col.x *= 0.56;\n    col.x += 0.5;\n    col = hsv2rgb(col);\n    col = clamp(col,0.,1.);\n    //col *= 0.5;\n    //col += 0.3;\n    col += slogo(tv,ar,1.)/24.;\n    //col.g += sin(d.y*0.1);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}