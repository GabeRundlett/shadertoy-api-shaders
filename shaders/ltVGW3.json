{
    "Shader": {
        "info": {
            "date": "1477249472",
            "description": "compaction of Shau's Mandelbulb [url]https://www.shadertoy.com/view/lty3Dc[/url]\n\nSome help for getting it smaller ? :-)",
            "flags": 0,
            "hasliked": 0,
            "id": "ltVGW3",
            "likes": 25,
            "name": "shortest mandelbulb ( 430 chars)",
            "published": 3,
            "tags": [
                "fractal",
                "mandelbulb",
                "short",
                "codegolf"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 2340
        },
        "renderpass": [
            {
                "code": "// compression of Shau's Mandelbulb https://www.shadertoy.com/view/lty3Dc\n// Mandelbulb distance: see http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n\n// ( NB: a shorter ugly version there: https://www.shadertoy.com/view/XlyGWd )\n// (           another less ugly here: https://www.shadertoy.com/view/4t3Szn )\n\n\n/**/   // --------------------------------------- Coyote: 430.  -4 with macro instead of func\n\n#define V vec2(cos(r),sin(r))\n\nfloat t,r,c,d,e = .005,p;\nvec3 z, w, o, f;\n\n// #define M d=2.;z=o;for(int i=0;i<10;i++)p=pow(r=length(z),8.),r<4.?d=p/r*8.*d+2.,r=8.*acos(z.z/r)+t*25.,f.xy=V,r=8.*atan(z.y,z.x),z=p*vec3(f.y*V,f)+o:z;r*=log(r)/d\n\nvoid M() {\n    d = 2.;\n    z = o;\n    for (int i=0; i<10; i++)\n        p = pow( r = length(z), 8.),\n        r < 4. ?\n        \td = p/r*8.*d  +2.,\n        \tr = 8.* acos(z.z/r) + t*25.,\n        \tf.xy = V,\n        \tr = 8.* atan(z.y,z.x),\n        \tz = p*vec3(f.y*V,f ) + o\n        : z;\n    r *= log(r)/d;\n\n}\n\nvoid mainImage( out vec4 O, vec2 U ) \n{\n    z = iResolution, o = z-z, r = t = .1*iDate.w; // initialization on globals now forbidden\n    w = vec3((U-z.xy*.5)/z.y, 1);\n    w.xz *= mat2(o.zx=V,-o.x,o.z);\n    o /= -.4;\n    for (int i = 0; i < 90; i++) {\n        M();\n        c = r;\n        c > e ? o += c*w : o;\n    }\n    o.x += e;\n    M();\n    O = O-O + 2.* abs( c - r ) / e ;\n}\n/**/\n\n\n\n\n\n/**   // --------------------------------------- Coyote : 446+1-4 chars  stduhpf: -6 Fab -7\n\nfloat t = .1*iDate.w, r,a,b,c,d,e = .005,p;\nvec3 z=iResolution, w, o;\n\nvoid M() \n{\n    d = 2.;\n    z = o;\n    for (int i = 0; i < 10 ; i++) \n        // --- just equivalent to z = z^8 + o via Moivre formula in Complexes (here, 3complexes) \n        p = pow(r = length(z), 8.) ,\n      //if (r > 4.) break;\n      //if (r < 4.)                         // stduhpf\n        r < 4. ?                            // coyote 2\n        \ta = 8.*acos(z.z / r) + t*25.,\n        \tb = 8.*atan(z.y, z.x),\n        \tz = p * vec3( sin(a) * vec2(cos(b), sin(b)), cos(a) ) + o,\n        \td = p/r* 8. * d + 2.\n            : d;\n    \n    r *= log(r) / d;\n}\n\nvoid mainImage( out vec4 O, vec2 U ) \n{\n    w = vec3((U-z.xy*.5)/z.y, 1);          // Fabrice -7\n // w = normalize(vec3(U-z.xy*.5, z.y));\n // o = vec3(1,1,-2.5); // & swap w=       // -37-17 chars    without animation\n    w.xz *= mat2(a=cos(t),b=sin(t),-b,a);\n    o = -vec3( b, 0, a )/.4;\n\n    for (int i = 0; i < 90; i++)\n        M(),\n        c = r,\n        c > e ? o += c*w : o;\n    \n    o.x += e;\n    M();\n    O = O-O + 2.* abs( c - r ) / e ;\n}\n/**/\n\n\n\n\n/**   // --------------------------------------- Fab & Coyote : 452 chars\n\nfloat t = .1*iDate.w, r,a,b,c,d,e = .005,p;\nvec3 z=iResolution, w, o;\n\nfloat M() \n{\n    d = 2.;\n    z = o;\n    for (int i = 0; i < 10 ; i++) \n    {\n        // --- just equivalent to z = z^8 + o via Moivre formula in Complexes (here, 3complexes) \n        p = pow(r = length(z), 8.) ; if (r > 4.) break;\n        a = 8.*acos(z.z / r) + t*24.;\n        b = 8.*atan(z.y, z.x),\n        z = p * vec3( sin(a) * vec2(cos(b), sin(b)), cos(a) ) + o; \n        \n        d = p/r* 8. * d + 2.;\n    }\n    return  log(r) * r / d; \n}\n\nvoid mainImage( out vec4 O, vec2 U ) \n{\n    w = normalize(vec3( U-z.xy*.5, z.y) );\n // o = vec3(1,1,-2.5); // & swap w=       // -37-17 chars    without animation\n    w.xz *= mat2(a=cos(t),b=sin(t),-b,a); \n    o = -2.5*vec3( b, 0, a );\n    \n\n    for (int i = 0; i < 90; i++) \n        c = M(),\n        o += c > e ? c*w : o-o; \n    \n    o.x += e;\n    O += 2.* abs( M() - c ) / e - O;\n}\n/**/\n\n\n\n\n/**   // --------------------------------------- stduhpf : 465 chars\n\nfloat t = .1*iDate.w, r,a,b,c,d,e = .005,p;\nvec3 z, w, o;\n\nfloat M() \n{\n    d = 2.;\n    z = o;\n    for (int i = 0; i < 10 ; i++) \n    {\n        r = length(z); if (r > 4.) break;\n        a = acos(z.z / r) + t*3.;\n        b = 8.*atan(z.y, z.x),\n        p = pow(r,8.);\n        z = p * vec3( sin(a*=8.) * cos(b), sin(b) * sin(a), cos(a) ) + o;\n        \n        d = p/r* 8. * d + 2.;\n    }\n    return  log(r) * r / d; \n}\n\nvoid mainImage( out vec4 O, vec2 U ) \n{\n    w = normalize(vec3( (U+U-(O.xy=iResolution.xy))/O.y, 2) );\n    w.xz *= mat2(a=cos(t),b=sin(t),-b,a); \n    o = -2.5*vec3( b, 0, a );\n    \n    // 471 chars, faster\n//  for (int i = 0; i < 90; i++) {\n//      c = M();\n//      if (c < e ) break;\n//      o += c*w;\n//  }\n\n    for (int i = 0; i < 90; i++) \n        c = M(),\n        o += c*w*step(e,c);\n    \n    o.x += e;\n    O += 2.* abs( M() - c ) / e - O;\n}\n\n/**/\n\n\n\n\n/**  // --------------------------------------------- iq - GregRostami : 469 chars\n\nfloat t = .1*iDate.w, r,a,b,c,d,e = .005;\nvec3 z, w, o;\n\nfloat M() \n{\n    d = 1.;\n    z = o;\n    for (int i = 0; i < 10 ; i++) \n    {\n        r = length(z); if (r > 4.) break;\n        a = 8.*acos(z.z / r) + t*25.2;\n        b = 8.*atan(z.y, z.x);\n        z = pow(r, 8.) * vec3(sin(a) * cos(b), sin(b) * sin(a), cos(a)) + o;\n        d = pow(r, 7.) * 8. * d + 1.;\n    }\n    return .5 * log(r) * r / d; \n}\n\nvoid mainImage( out vec4 O, vec2 U ) \n{\n    w = normalize(vec3( (U+U-(O.xy=iResolution.xy))/O.y, 2) );\n    w.xz *= mat2(a=cos(t),b=sin(t),-b,a); \n    o = -2.5*vec3( b, 0, a );\n    \n\n    // 474 chars, faster\n//  for (int i = 0; i < 90; i++) {\n//      c = M();\n//      if (c < e ) break;\n//      o += c*w;\n//  }\n\n\n    for (int i = 0; i < 90; i++) \n        c = M(),\n        o += c*w*step(e,c);\n    \n    o.x += e;\n    O += 2.* abs( M() - c ) / e - O;\n}\n\n\n/**/\n\n\n\n\n\n/**      // -------------------------------------------- initial reduction : 548 chars\n\nfloat P = 8., t = iDate.w;\n\nfloat M(vec3 Z) { // Mandelbulb distance func\n    vec3  z = Z;\n\tfloat d = 1., r;\n\n\tfor (int i = 0; i < 10 ; i++) {\n\t\tr = length(z); if (r > 4.) break;\n\t\t\n\t\tfloat a = acos(z.z / r) + fract(t/20.) *6.3,\n\t\t      b = atan(z.y, z.x),\n              p = pow(r, P);\n\t\td = p/r * P * d + 1.;\n\t\t\n\t\tz = p * vec3(sin(a*=P) * cos(b*=P), sin(b) * sin(a), cos(a))   + Z;\n\t}\n\treturn .5 * log(r) * r / d; \n}\n\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    vec2  R = iResolution.xy;\n          U = (U+U-R) / R.y;\n\n    float E = .005, s,c;\n    \n    vec3  d = normalize(vec3(U, 2.)),\n          o = vec3(0, 0, -2.5), p;\n\n                                             // -58 chars without animation    \n//#define rot(a) mat2(c=cos(a),s=sin(a),-s,c)\n//    mat2 m =  rot(t * .1);\n    mat2 m =  mat2(c=cos(t*.1),s=sin(t*.1),-s,c);\n    o.xz *= m;\n    d.xz *= m; \n // m = rot(2.8 + sin(t) * .1);\n // o.yx *= m;\n // d.yx *= m;\n\n    \n    s = 0.;\n    for (int i = 0; i < 90; i++) {  // iterations\n        s += c = M( p = o + s*d );\n        if (c < E ) break;\n    }\n    \n    O += 2.* abs( M(p+vec3(E,0,0)) - c ) / E -O; // IQ's optimized Lambert vith lightwise derivative\n}\n\n/**/\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}