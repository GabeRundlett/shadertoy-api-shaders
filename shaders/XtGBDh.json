{
    "Shader": {
        "info": {
            "date": "1542290776",
            "description": "same map function, using IQs marching code / shadows etc. (press mouse for bonus nipple mix)",
            "flags": 0,
            "hasliked": 0,
            "id": "XtGBDh",
            "likes": 4,
            "name": "Raymarch anything (iq mix)",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "Del",
            "viewed": 496
        },
        "renderpass": [
            {
                "code": "// Raymarch anything #3 - using one of IQs raymarchers :)\n//\n// RayMarch + Shadow base code from here: https://www.shadertoy.com/view/lsKcDD\n//------------------------------------------------------------------\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat objID = 0.0;\nfloat svobjID = 0.0;\n\n#define\tTAU 6.28318\n\n//------------------------------------------------------------------\n\n\n\nfloat map(vec3 p)\n{\n    float time=iTime;\n    float zo = time*6.75;\n    float modz = mod(zo,44.0);\n    \n    float t2 = fract(time*1.1) * TAU;\n    float t3 = fract(time*0.7) * TAU;\n    float t4 = fract(time*0.14)* TAU;\n    \n    float m = 0.5+sin(t2+p.z*0.4)*0.5;\n    m += 0.5+cos(p.z*0.4+t3+p.x*0.4)*0.5;\n    \n    p.xy *= rotate(p.z * .08 + t4);\n    \n\tp.z += modz;\n    float c1 = pMod1(p.z,44.0);\n    \n\tfloat dist = 3.5 -abs(p.y)+m;\n    \n    vec3 p2 = p;\n\tfloat cz = pMod1(p2.z,4.0);\n\tfloat cx = pMod1(p2.x,4.0);\n\n    float r = hash(vec2(cz+(cz*0.31),cx+(cx*0.61)));\n\n    if (abs(cx)<1.0)\n        r=0.0;\n\n    if (iMouse.z < 0.5)\n    {\n        if (r>0.75)\n        {\n            float d2 = sdCylinder(p2,vec2(0.7,5.5));         \n            dist = smin(dist,d2,1.1);\n        }\n    }\n    else\n    {\n        // nipple mix\n        if (r>0.875)\n        {\n            float d2 = sdSphere(p2+vec3(0.0,3.2+m,0.0),0.8);\n            float d3 = sdSphere(p2-vec3(0.0,3.2+m,0.0),0.8);\n            dist = smin(dist,d2,1.1);\n            dist = smin(dist,d3,1.1);\n        }\n    }\n    \n    \n    objID = abs(p.z)/44.0;\n    return dist;\n}\n\n\n//------------------------------------------------------------------\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<50; i++ )\t//32\n    {\n\t\tfloat h = map( ro + rd*t );\n\n        // traditional technique\n        //\tres = min( res, 10.0*h/t );\n        // improved technique\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nfloat castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 100.0;\n   \n    \n    float t = tmin;\n    for( int i=0; i<180; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    float res = map( ro+rd*t );\n        if( res<precis || t>tmax ) break;\n        t += res*0.25;\n    }\n\n    if( t>tmax ) t=-1.0;\n    return t;\n    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd)\n{ \n    vec3  col = vec3(0.0);\n    float t = castRay(ro,rd);\n\n    svobjID = objID;\n    if( t>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        \n        // material        \n\t\tvec3 mate1 = vec3(1.7,0.6,0.7)*0.2;\n\t\tvec3 mate2 = vec3(1.5,1.2,0.7)*0.2;\n        \n        float m = svobjID;\n        vec3 mate = mix(mate1,mate2,m);\n        \n\n        // key light\n        //vec3  lig = normalize( vec3(-0.1, 0.3, 0.6) );\n        \n\t\tvec3 lig = ro+vec3(-0.1,0.0,12.0);\n        lig = normalize(lig);\n        \n        vec3  hal = normalize( lig-rd );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float sha = calcSoftshadow( pos, lig, 0.01, 3.0 );\n        dif *= sha*0.85;\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tcol = mate * 4.0*dif*vec3(1.00,0.70,0.5);\n        col +=      12.0*spe*vec3(1.00,0.70,0.5);\n        \n        // ambient light\n        //float occ = calcAO( pos, nor );\n        float occ=1.0;\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        col += mate*amb*occ*vec3(0.0,0.08,0.1);\n        \n        // fog\n        col *= exp( -0.0005*t*t );\n    }\n\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\t\n    vec3 ro = vec3( 0.0, 0.0, -111.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    //int technique = (fract(iTime/2.0)>0.5) ? 1 : 0;\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n    // gamma\n    col = pow( col, vec3(0.4545) );\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}