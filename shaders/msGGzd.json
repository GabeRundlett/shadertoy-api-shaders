{
    "Shader": {
        "info": {
            "date": "1678942355",
            "description": "adding absorption to glass, and some non-caustic colored shadows.\nthis marches up to 60 rays per pixel! Most only use 20 or so. <space> for heat-map.\neach transparent intersection gets two or three child rays, until contribution is too low.",
            "flags": 48,
            "hasliked": 0,
            "id": "msGGzd",
            "likes": 13,
            "name": "three tumblers",
            "published": 3,
            "tags": [
                "refraction",
                "optics",
                "absorption",
                "elenzil",
                "tumblers"
            ],
            "usePreview": 1,
            "username": "elenzil",
            "viewed": 325
        },
        "renderpass": [
            {
                "code": "const uint mtl_0                 =  0u;\nconst uint mtl_floor             =  1u;\nconst uint mtl_pedastle          =  2u;\nconst uint mtl_glass             =  3u;\nconst uint mtl_glass_chartreuse  =  4u;\nconst uint mtl_glass_red         =  5u;\nconst uint mtl_green             =  6u;\nconst uint mtl_room              =  7u;\nconst uint mtl_ball              =  8u;\nconst uint mtl_count             =  9u;\n\n\nfloat gT               = 1e9;\n\nfloat gNumGeometryReps = 3.0;\n\n\nfloat gHeight;\nfloat gCupCenterY;\nfloat gCupRadOuter;\nfloat gCupRadInner;\nfloat gCupBase;\nfloat gCupRepM;\nvec3  gPedastle;\nfloat gPedastleRad;\nfloat gBouncersHeight[3];\nfloat gBouncerRad;\nvec2  gDimpleDist;\nfloat gDimpleRad;\nmat2  gCupRotXZ;\n\n\nconst float cDeathStarInflate = 0.005;\n\nconst float cRoomSize         = 12.0;\nconst float cRoomRads         = cRoomSize / 5.0;\n\nfloat gCamDist;\nfloat gCamZoom;\n\n\nvoid setupScene2() {\n\n    gHeight = 1.0;\n    \n    gCupRadOuter  = gHeight      * 0.7   - cDeathStarInflate;\n    gCupRadInner  = gCupRadOuter * 0.93;\n    gCupBase      = gCupRadOuter * 0.9;\n\n    gCupRepM      = gCupRadOuter * gNumGeometryReps;    \n    gPedastle     = vec3(gCupRadOuter * (gNumGeometryReps + 1.0), gCupRadOuter * 0.2, gCupRadOuter);\n    gPedastle.xz += gCupRadOuter * 0.05;\n    gPedastleRad  = gPedastle.y * 0.125;\n\n    gCupCenterY   = gCupBase + 0.02 + gPedastle.y * 2.0;\n    \n    gCamDist      = gPedastle.x * 2.0;\n    gCamZoom      = 2.5;\n    \n    gBouncerRad = gCupRadOuter * 0.3;\n    for (float n = 0.0; n < 3.0; ++n) {\n        uint i = uint(n);\n        if (i < 2u) {\n            i = 1u - i;\n        }\n        gBouncersHeight[i] = gCupCenterY + (gCupRadInner - gBouncerRad) * 0.8 * sin(gT * 4.0 * (n + 1.0));\n    }\n    \n    gDimpleRad = gCupRadOuter * 0.3;\n    \n    gDimpleDist = vec2(gCupRadOuter * 0.92, gCupRadOuter * -0.75);\n    \n    gCupRotXZ = matRot2(-gT);\n}\n\n\nfloat gMapCount =  0.0;\nmapSample_t map(in vec3 p) {\n    gMapCount += 1.0;\n    \n    MST ret = MST(1e9, mtl_0);\n    \n    vec3 q;\n    \n    q = p;\n    q.y -= gCupCenterY;\n    float instance = round(q.x/gCupRepM);\n    q.x -= gCupRepM * clamp(instance,-1.0,1.0);\n    \n    q.xz *= gCupRotXZ;\n    \n    uint mtl = uint(int(instance) + int(mtl_glass) + 1);\n    \n    opUnion(ret, MST(sdDeathStar(q.yxz, gCupRadOuter, gCupRadInner, gCupRadOuter * 0.1) - cDeathStarInflate, mtl));\n   \n    opMinus(ret, MST(q.y + gCupBase          , mtl));\n\n    // subtract donuts\n    q.y = abs(q.y) - gCupRadInner * 0.3;\n    opMinus(ret, MST(sdTorus(q, vec2(gCupRadInner * 1.18, 0.1)), mtl));\n    \n    // subtract dimples\n    q.y = p.y - gCupCenterY;\n    // radial repeat\n    float num = instance + 5.0;\n    float pTheta = atan(q.z, q.x) / pi * 0.5 + 0.5;\n    float repTheta = (fract(pTheta * num) * 2.0 - 1.0) / num * pi;\n    q.xz = vec2(cos(repTheta), sin(repTheta)) * length(q.xz);\n    \n    q.xy -= gDimpleDist;\n    opMinus(ret, MST(sdSphere(q, gDimpleRad), mtl));\n\n\n    // bouncing spheres\n    #if 0\n    q.y = p.y - gBouncersHeight[uint(instance + 1.0)];\n    opUnion(ret, MST(sdSphere(q, gBouncerRad), mtl_ball));\n    #endif\n    \n    // pedastle\n    q = p;\n    q.y -= gPedastle.y + 0.01;\n    opUnion(ret, MST(sdBox(q, gPedastle - gPedastleRad) - gPedastleRad, mtl_pedastle));\n\n    return ret;\n}\n\nconst mtl_t materials[mtl_count] = mtl_t[](\n    mtl_t(1.0, 1.0 , v1                 , v41),                       // sky\n    mtl_t(1.0, 0.0 , v1                 , v41),                       // floor\n//  mtl_t(1.1, 0.2 , v1                 , vec4(0.9, 0.9, 0.9, 5e1)),  // pedastle clear\n    mtl_t(1.0, 0.0 , v1                 , v41),                       // pedastle\n    mtl_t(1.7, 1.0 , v1                 , vec4(0.5, 0.7, 0.9, 5e0)),  // glass\n    mtl_t(1.5, 1.0 , v1                 , vec4(0.7, 0.9, 0.3, 5e1)),  // glass chartreuse\n    mtl_t(1.5, 0.85, vZ * 0.5           , vec4(0.7, 0.1, 0.3, 2e1)),  // glass red\n    mtl_t(1.8, 0.0 , vec3(0.5, 0.8, 0.0), v41),                       // green\n    mtl_t(1.0, 0.0 , vec3(0.8, 0.7, 0.6), v41),                       // room\n    mtl_t(3.0, 0.0 , vec3(0.8, 0.7, 0.6), v41)                        // ball\n);\n\n\nconst float cPixelize           =   1.0;\n\nconst float cMinRayAmt          =   0.4 / 256.0;\nconst uint  cMaxRays            =   60u;\n      uint  gMaxRays            =   cMaxRays; // toggled at runtime\n#define Q_TYPE        ray_t\n#define Q_MAX_ENTRIES 15u\nQ_IMPLEMENTATION\n\nconst float cSurfEps            =   0.005;\nconst int   cMaxMarchSteps      = 120;\nconst float cWSEps              =   0.001;\n      float gUnderStepFactor    =   1.0;\n\n#if SOFT_SHADOWS\nconst float cSelfSoftShadowDist =   0.015;\n#endif\n\n\n\n\nvec2 viewportFromScreen(in vec2 p) {\n    return (p * 2.0 - RES) / MINRES;\n}\n\nfloat gSmoothEps   = 1e9;\nvec3  gSunDir      = 1e9 * v1;\nvec3  gRGB         = 1e9 * (vX + vZ);\n\nvoid setupScene() {\n    float sunT = gT * 0.212;\n    float sunTTheta = sunT - 0.7;\n    gSunDir = vec3(sin(sunTTheta), cos(sunTTheta), 0.04 + 2.0 * (cos(sunT) * -0.5 + 0.5)).xzy;\n    gSunDir = normalize(gSunDir);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 mapNormal(vec3 p){\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*cWSEps).dist;\n    }\n    return normalize(n);\n}\n\n\nvoid rayVsScene(in ray_t r, inout hit_t h) {\n    // tack on a plane via analytic intersection.\n    rayVsPlane (r, vY, 0.0, mtl_room, h);\n\n    float t = 0.0;\n    \n    for (int n = 0; n < cMaxMarchSteps && t < 1e3; ++n) {\n        vec3 p = r.ro + r.rd * t;\n        MST ms = map(p);\n        if (t < h.t && (ms.dist * r.side < cWSEps)) {\n            h.hit      = true;\n            h.t        = t;\n            h.pnt      = p;\n            h.nrm      = mapNormal(p);\n            h.mtl      = ms.mtl;\n            h.miss     = 0.0;\n            return;\n        }\n        #if SOFT_SHADOWS\n        else {\n            if (t > cSelfSoftShadowDist && ms.dist < h.miss) {\n                h.miss  = ms.dist;\n                h.missT = t;\n            }\n        }\n        #endif\n\n        t += r.side * ms.dist * gUnderStepFactor;\n    }\n}\n\n\n//------------------------------------------------------------------\n\nvec3 toneSky(in ray_t r) {\n    vec3 rd = r.rd;\n    vec3 rgb = simple_sky(r.ro, r.rd, gSunDir);\n    if (!r.DLR) {\n        float theta = atan(r.rd.z, r.rd.x);\n        float q = 2.0 - smoothstep(1.0, 0.98, cos((theta + pi/2.0) * 37.0));\n        rgb *= q;\n    }\n    return rgb;\n}\n\nvec3 toneFloor(in vec2 p) {\n    return vec3(0.9, 0.8, 0.7);\n    vec3 tx = texture(iChannel0, fract(p * 0.4)).rgb * 1.2;\n    tx *= tx;\n    tx = mix(tx, v1, 0.1);\n    return tx;\n}\n\nvec3 tone(in ray_t r, in hit_t h) {\n    switch (h.mtl) {\n        case mtl_0:\n            return toneSky(r);\n        case mtl_floor:\n            return toneFloor(h.pnt.xz);\n        default:\n            return materials[h.mtl].color;\n    }\n}\n\n//------------------------------------------------------------------\n\nbool gShadows = true;\nuint gRayCount;\nvoid runRays() {\n\n    // accumulates in gRGB.\n    \n    gRayCount = 0u;\n    \n    while (!QIsEmpty()) {\n        gRayCount += 1u;\n        ray_t r = QDequeue();\n\n        hit_t h = newHit();\n        h.mtl = mtl_0;\n        rayVsScene(r, h);\n        \n        if (!h.hit) {\n            // no hit - escapes to the sky\n            gRGB += r.amt * toneSky(r);\n        }\n        else {\n            // a hit!\n            // \"nrm\" here is the hit-facing normal,\n            // while h.nrm is the \"outward\" facing normal.\n            \n            mtl_t m = materials[h.mtl];\n                        \n            vec3  nrm     = h.nrm * r.side;\n            float R0      = schlickR0(m.ior, ior_air);\n            vec3  reflAmt = v1 * schlick  (R0, dot(r.rd, -nrm));            \n            vec3  trnsAmt = m.diffVsTrns * (1.0 - reflAmt);\n            vec3  diffAmt = (1.0 - m.diffVsTrns) * (1.0 - reflAmt);\n\n            if (r.side < 0.0) {\n                // just traveled through media, attenuate !\n                r.amt *= exp(-m.absorption.w * h.t * (1.0 - m.absorption.rgb));\n            }\n\n            reflAmt *= r.amt;\n            trnsAmt *= r.amt;\n            diffAmt *= r.amt;\n            \n            if (gRayCount >= cMaxRays) {\n                continue;\n            }\n            \n            // diffuse\n\n            if (QSpaceLeft() < 1u) {\n                continue;\n            }\n            \n            if (dot(diffAmt, diffAmt) > cMinRayAmt * cMinRayAmt) {\n                // diffuse lighting at surfaces.\n                \n                float sunDot      = dot(gSunDir, h.nrm);\n                if (sunDot > 0.0) {\n\n                    // cast a diffuse lighting ray.\n                    ray_t dlrRay;\n                    dlrRay.ro         = h.pnt + h.nrm * cSurfEps;\n                    dlrRay.rd         = gSunDir;\n                    dlrRay.amt        = diffAmt * sunDot * tone(r, h);\n                    dlrRay.side       = 1.0;\n                    dlrRay.DLR        = true;\n                    \n                    if (dot(dlrRay.amt, dlrRay.amt) > cMinRayAmt * cMinRayAmt) {\n                        QEnqueue(dlrRay);\n                    }\n                }\n                // todo: subsurface scattering ?\n            }\n\n\n            // transmission\n            \n            if (QSpaceLeft() < 1u) {\n                continue;\n            }\n            \n            if (dot(trnsAmt, trnsAmt) > cMinRayAmt * cMinRayAmt) {\n                if (!r.DLR) {\n                    float eta = ior_air / m.ior;\n                    if (r.side < 0.0) {\n                        eta = 1.0 / eta;\n                    }\n                    vec3 trnRayDir = refract(r.rd, nrm, eta);\n                    if (dot(trnRayDir, trnRayDir) < 0.001) {\n                        // total internal reflection.\n                        // this is theoretically impossible for a ray that entered a sphere,\n                        // but keeping it in here anyhow for more exotic scenarios.\n                        reflAmt += trnsAmt;\n                    }\n                    else {\n                        ray_t trnRay;\n                        trnRay.ro   = h.pnt - nrm * cSurfEps;\n                        trnRay.rd   = trnRayDir;\n                        trnRay.side = -r.side;\n                        trnRay.amt  = trnsAmt;\n                        trnRay.DLR  = false;\n\n                        QEnqueue(trnRay);\n                    }\n                }\n                else {\n                    // diffuse lighting ray not refracted, reflected, etc.\n                    ray_t trnRay;\n                    trnRay.ro   = h.pnt - nrm * cSurfEps;\n                    trnRay.rd   = r.rd;\n                    trnRay.side = -r.side;\n                    trnRay.amt  = trnsAmt;\n                    trnRay.DLR  = true;\n\n                    QEnqueue(trnRay);\n                }\n            }\n\n            // reflection\n            if (QSpaceLeft() < 1u) {\n                continue;\n            }\n            if (!r.DLR && dot(reflAmt, reflAmt) > cMinRayAmt * cMinRayAmt) {\n                ray_t rflRay;\n                rflRay.ro   = h.pnt + nrm * cSurfEps;\n                rflRay.rd   = reflect(r.rd, nrm);\n                rflRay.side = r.side;\n                rflRay.amt  = reflAmt;\n                rflRay.DLR  = false;\n\n                QEnqueue(rflRay);\n            }\n        }\n    }\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    const float timeFac = 0.2;\n    gT         = iTime * timeFac;\n    gSmoothEps = 4.0 / MINRES;\n    \n    const float pipScale = 0.4;\n    bool pip = XY.x < RES.x * pipScale && XY.y < RES.y * pipScale;\n    pip = pip && KEY_TOGGLED(32, iChannel2);\n    \n    gShadows  = !KEY_TOGGLED(83, iChannel2);\n    gMaxRays  =  KEY_TOGGLED(76, iChannel2) ? 1u : cMaxRays;\n    \n    if (pip) {\n        XY /= pipScale;\n    }\n    \n    // pixelate\n    vec2 XY2 = XY - (fract(XY / cPixelize ) - 0.5) * cPixelize;\n    \n    vec2 xy = viewportFromScreen(XY2);\n    \n    vec4 inp = texelFetch(iChannel1, ivec2(0), 0);\n    vec2 m  = viewportFromScreen(inp.xy);\n    if (length(inp.xy) < 50.0) {\n        m = v0.xy;\n        float q = 0.1 * gT * smoothstep(0.0, 20.0, gT / timeFac - 10.0);\n        m.x = q;\n    }\n\n    setupScene();\n    setupScene2();\n    \n    // setup camera\n    float theta     = (m.x * 0.75 + 0.5) * -pi;\n    vec3  lookTo    = vY * gHeight * 0.0;\n    float camYMin = 0.3;\n    float camYMax = gHeight * 50.0;\n    float camYMid = gCupCenterY + gCupRadOuter * 2.1;\n    float camY;\n    float mySmooth = smoothstep(-1.0, 1.0, m.y) * 2.0 - 1.0;\n    if (m.y > 0.0) {\n        camY = mix(camYMin, camYMid, 1.0 - m.y);\n    }\n    else {\n        camY = mix(camYMid, camYMax, -m.y);\n        gCamDist = mix(gCamDist, gCamDist * 1.3, -m.y);\n    }\n    vec3 lookFrom = vec3(cos(theta) * 9.0, camY, sin(theta) * 9.0);\n    \n    lookFrom = normalize(lookFrom) * gCamDist;\n    \n    // configure our initial ray for this pixel\n    ray_t r0;\n    r0.ro   = lookFrom;\n    r0.rd   = matLookTo(lookFrom, lookTo) * normalize(vec3(xy, -gCamZoom));\n    r0.amt  = v1;\n    r0.side = 1.0;\n    r0.DLR  = false;\n    QEnqueue(r0);\n    \n    gRGB = v0;\n    runRays();\n        \n    gRGB = pow(gRGB, vec3(1.0/2.2));\n    \n    if (pip) {\n        float mapCost = gMapCount / (float(cMaxMarchSteps) * 5.0);\n        float rayCost = float(gRayCount) / float(cMaxRays);\n        gRGB.r = mapCost;\n        if (cMaxRays > 1u) {\n            gRGB.g = rayCost;\n        }\n        else {\n            gRGB.g = 0.2;\n        }\n        gRGB.b = 0.3;\n    }\n    \n    RGBA = vec4(gRGB, 1.0);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n#define ZERO   (0)\n\nconst float pi  = 3.14159265359;\nconst vec3  v1  = vec3(1.0);\nconst vec3  v0  = vec3(0.0);\nconst vec3  vX  = vec3(1.0, 0.0, 0.0);\nconst vec3  vY  = vec3(0.0, 1.0, 0.0);\nconst vec3  vZ  = vec3(0.0, 0.0, 1.0);\nconst vec4  v41 = vec4(1.0);\n\n//--------------------------------------------------------------------------------\n\n#define SOFT_SHADOWS 0 // not working, don't enable.\n\nstruct ray_t {\n    vec3  ro;\n    vec3  rd;\n    vec3  amt;   // [0, 1] amount of light left in the ray\n    float side;  // -1 = inside, 1 = outside.\n    bool  DLR;   // Diffuse Lighting Ray.\n};\n\nstruct hit_t {\n    bool  hit;\n    float t;\n    vec3  pnt;\n    vec3  nrm;\n    uint  mtl;\n    float miss;  // smallest distance to a shadowing point.\n    #if SOFT_SHADOWS\n    float missT; // distance to miss.\n    #endif\n};\n\nstruct mapSample_t {\n    float dist;\n    uint mtl;\n};\n#define MST mapSample_t\n\nstruct mtl_t {\n    float ior;\n    float diffVsTrns;\n    vec3  color;\n    vec4  absorption;  // transmissive color, density.  eg (0.8, 0.7, 0.1, 30.0)\n};\n\nhit_t newHit() {\n    hit_t ret;\n    ret.hit      = false;\n    ret.t        = 1e9;\n    ret.miss     = 1e9;\n    #if SOFT_SHADOWS\n    ret.missT    = 1e9;\n    #endif\n    return ret;\n}\n\n\n//--------------------------------------------------------------------------------\n\nconst float ior_air     =  1.0003;\nconst float ior_aerogel =  1.03;\nconst float ior_ice     =  1.309;\nconst float ior_water   =  1.333;\nconst float ior_quartz  =  1.46;\nconst float ior_diamond =  2.42;\nconst float ior_shiny1  =  4.0;    // ad hoc\nconst float ior_mrr     =  1e2;    // ad hoc\n\n\n//--------------------------------------------------------------------------------\n\n// fifo queue.\n// This is a basic ringbuffer.\n// NO ERROR CHECKING\n//\n// usage:\n// #define Q_TYPE and Q_MAX_ENTRIES,\n// then put Q_IMPLEMENTATION.\n// (Q_MAX_ENTRIES is a uint)\n//\n// for example:\n// #define Q_TYPE        ray_t\n// #define Q_MAX_ENTRIES 16u\n// Q_IMPLEMENTATION\n//\n// orion elenzil 2022.\n#define Q_IMPLEMENTATION                           \\\nconst uint gQCapacity = Q_MAX_ENTRIES;             \\\nconst uint gQNumSlots = gQCapacity + 1u;           \\\nQ_TYPE gQ[gQNumSlots];                             \\\nuint gQHead = 0u;                                  \\\nuint gQTail = 0u;                                  \\\n                                                   \\\nuint QCount() {                                    \\\n    if (gQHead >= gQTail) {                        \\\n        return gQHead - gQTail;                    \\\n    }                                              \\\n    else {                                         \\\n        return gQNumSlots - (gQTail - gQHead);     \\\n    }                                              \\\n}                                                  \\\n                                                   \\\nuint QSpaceLeft() {                                \\\n    return gQCapacity - QCount();                  \\\n}                                                  \\\n                                                   \\\nbool QIsFull() {                                   \\\n    return QSpaceLeft() == 0u;                     \\\n}                                                  \\\n                                                   \\\nbool QIsEmpty() {                                  \\\n    return QCount() == 0u;                         \\\n}                                                  \\\n                                                   \\\nuint _QEnqueueIndex() {                            \\\n    gQHead = (gQHead + 1u) % gQNumSlots;           \\\n    return gQHead;                                 \\\n}                                                  \\\n                                                   \\\nuint _QDequeueIndex() {                            \\\n    gQTail = (gQTail + 1u) % gQNumSlots;           \\\n    return gQTail;                                 \\\n}                                                  \\\n                                                   \\\nvoid QEnqueue(Q_TYPE item) {                       \\\n    gQ[_QEnqueueIndex()] = item;                   \\\n}                                                  \\\n                                                   \\\nQ_TYPE QDequeue() {                                \\\n    return gQ[_QDequeueIndex()];                   \\\n}\n////////////////////////////////////////////////////\n\n\n//--------------------------------------------------------------------------------\n\n// assumes 'up' is world Y.\nmat3 matLookTo(in vec3 lookFrom, in vec3 lookTo) {\n    vec3 fw = -normalize(lookTo - lookFrom);\n    vec3 rt =  normalize(cross(fw, vY));\n    vec3 up =  cross(rt, fw);\n    \n    return mat3(rt, up, fw);\n}\n\nmat2 matRot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n\n//--------------------------------------------------------------------------------\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvoid rayVsPlane(in ray_t ray, in vec3 n, in float d, uint mtl, inout hit_t hit) {\n    float t = -(dot(ray.ro, n) + d) / (dot(ray.rd, n));\n    if (t > 0.0 && t < hit.t) {\n        hit.hit = true;\n        hit.t   = t;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = n;\n    }\n}\n\n//--------------------------------------------------------------------------------\n\n// https://en.wikipedia.org/wiki/Schlick%27s_approximation\nfloat schlickR0(in float n1, in float n2) {\n    // same if n1 and n2 are swapped.\n    float q  = (n1 - n2) / (n1 + n2);\n    float q2 = q * q;\n    return q2;\n}\n\nfloat schlick(in float R0, in float cosTheta) {\n    float q  = 1.0 - cosTheta;\n    float q5 = q * q * q * q * q;\n    return R0 + ((1.0 - R0) * q5);\n}\n\n\n//--------------------------------------------------------------------------------\n\n// how far to offset each of two spheres of radius sphRad\n// to obtain a lens of radius lensRad\nfloat offsetToMakeLens(float sphRad, float lensRad) {\n    return sqrt(max(0.0, (sphRad * sphRad) - (lensRad * lensRad)));\n}\n\n// lensmaker's equation\nfloat radiusForFocalLength(float focalLength, float ior) {\n    return (ior - 1.0) * 2.0 * focalLength;\n}\n\nvec2 radiusAndOffsetForLens(float focalLength, float ior, float lensRad) {\n    vec2 ret;\n    \n    ret.x = radiusForFocalLength(focalLength, ior);\n    ret.y = offsetToMakeLens(ret.x, lensRad);\n    \n    return ret;\n}\n\n\n//--------------------------------------------------------------------------------\n// @Gijs\n// https://www.shadertoy.com/view/7dSSzy Basic : Less Simple Atmosphere\n\nvec3  SUN_COLOR = vec3(1.0,1.0,1.0);\nvec3  SKY_SCATTERING = vec3(0.1, 0.3, 0.7);\n// vec3  SUN_VECTOR;\nfloat SUN_ANGULAR_DIAMETER = 0.08;\nfloat CAMERA_HEIGHT = -0.3;\n\n\n// Consider an atmosphere of constant density & isotropic scattering \n// Occupying, in the y axis, from -infty to 0\n// This shaders ``solves'' that atmosphere analytically.\n\nfloat atmosphereDepth(vec3 pos, vec3 dir)\n{\n    return max(pos.y, 0.1)/ max(dir.y, 0.0);\n}\n\nvec3 transmittance(float l)\n{\n    return exp(-l * SKY_SCATTERING);\n}\n\nvec3 simple_sun(in vec3 dir, in vec3 lightDir)\n{\n    //sometimes |dot(dir, SUN_VECTOR)| > 1 by a very small amount, this breaks acos\n    float a = acos(clamp(dot(dir, lightDir),-1.0,1.0));\n    float t = 0.005;\n    float e = smoothstep(SUN_ANGULAR_DIAMETER*0.5 + t, SUN_ANGULAR_DIAMETER*0.5, a);\n    return SUN_COLOR * e;\n}\n\nvec3 simple_sky(in vec3 p, in vec3 d, in vec3 lightDir)\n{\n    p.y *= -1.0;\n    p.y = max(0.1, p.y);\n    float l = atmosphereDepth(p, d);\n    vec3 sun = simple_sun(d, lightDir) * transmittance(l);\n    float f = 1.0 - d.y / lightDir.y;\n    float l2 = atmosphereDepth(p, lightDir);\n    vec3 sk = simple_sun(lightDir, lightDir) * transmittance(l2) / f * (1.0 - transmittance(f*l));\n    return clamp(sun + sk, 0.0, 1.0);\n}\n\n///////////////////////////////////////////////////////\n\n#define KEY_IS_DOWN(key, chan) (texelFetch(chan, ivec2(key, 0), 0).r > 0.0)\n#define KEY_TOGGLED(key, chan) (texelFetch(chan, ivec2(key, 2), 0).r > 0.0)\n\n///////////////////////////////////////////////////////\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdHollowSphere(in vec3 p, in float r1, in float r2) {\n    float rr = (r2 - r1) / 2.0;\n    float r = r1 + rr;\n    return abs(length(p) - r) - rr;\n}\n\nfloat sdCyl(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBoxFrame(in vec3 p, in vec3 b, in float e ) {\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinderX( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n// https://iquilezles.org/articles/distfunctions\n// ra = sphere's radius\n// rb = small sphere's radius\n// d  = distance between the two spheres\nfloat sdDeathStar( in vec3 p2, in float ra, float rb, in float d )\n{\n  // sampling independent computations (only depend on shape)\n  float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n  float b = sqrt(max(ra*ra-a*a,0.0));\n\t\n  // sampling dependant computations\n  vec2 p = vec2( p2.x, length(p2.yz) );\n  if( p.x*b-p.y*a > d*max(b-p.y,0.0) )\n    return length(p-vec2(a,b));\n  else\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\n\n\n\n\n// return a symmetric bi-concave lens shape given:\n// desc.x = sphere radius\n// desc.y = lens radius\n// desc.z = chamfer radius\nfloat sdLensCc(in vec3 p, vec3 desc) {\n\n    p.x = abs(p.x) + desc.y;\n    \n    float dCyl = length(p.yz) - desc.z;\n    \n    float d = length(p) - desc.x;\n    \n    d = max(d, dCyl);\n    \n    return d;\n}\n\nvoid opUnion(inout mapSample_t cur, mapSample_t new) {\n    if (new.dist < cur.dist) {\n        cur.dist = new.dist;\n        cur.mtl  = new.mtl;\n    }\n}\n\nvoid opMinus(inout float cur, in float new) {\n    cur = -min(new, -cur);\n}\n\nvoid opMinus(inout mapSample_t cur, mapSample_t new) {\n    if (-new.dist > cur.dist) {\n        cur.dist = -new.dist;\n        cur.mtl  = new.mtl;\n    }\n}\n\nvoid opInter(inout mapSample_t cur, mapSample_t new) {\n    if (new.dist > cur.dist) {\n        cur.dist = new.dist;\n        cur.mtl  = new.mtl;\n    }\n}\n\nvoid opUnion(inout float cur, float new) {\n    cur = min(cur, new);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// mouse state\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    ivec2 IJ = ivec2(XY);\n    \n    if (iFrame < 2) {\n        RGBA = vec4(0.0, 0.0, iResolution.y / 2.0, 0.0);\n        return;\n    }\n    \n    if (IJ == ivec2(0)) {\n        RGBA = texelFetch(iChannel0, IJ, 0);\n        RGBA.xy = iMouse.xy;\n    }\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}