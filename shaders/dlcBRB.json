{
    "Shader": {
        "info": {
            "date": "1701357337",
            "description": "Test of fluid implementation using Chroma 3000 shader. \n\nToggle brushes by pressing key 1-9 on the keyboard, then press LMB and drag to add color and interact with the fluid. \n",
            "flags": 48,
            "hasliked": 0,
            "id": "dlcBRB",
            "likes": 1,
            "name": "Fluid Chroma",
            "published": 3,
            "tags": [
                "fluid",
                "dev"
            ],
            "usePreview": 0,
            "username": "fingertwister",
            "viewed": 144
        },
        "renderpass": [
            {
                "code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// grid (velocity, density)\n\n#define dt 0.15\n#define K 0.03\n#define VS 0.4\n#define PI 3.14159265357989\n\nvec2 penForce(float time, float fq, float dist, float radius) {\n    float magnitude =  0.001 * abs(dist / radius);\n    return magnitude * vec2(cos(fq * time * PI * 2.), sin(fq * time * PI * 2.));\n}\n\nvec2 getMouseDelta(vec2 pos) {\n    vec2 oldMouse = vec2(\n        texelFetch(iChannel0, ivec2(0, 0), 0).w,\n        texelFetch(iChannel0, ivec2(1, 0), 0).w);\n    if (oldMouse.x > 0.) {\n        vec2 diff = (pos - 0.5) - (oldMouse - 0.5);\n        return -diff;\n    }\n    return vec2(0.);\n}\n\nfloat simple_rnd(vec3 coords) {\n    return fract(sin(74.2134 * dot(coords, vec3(72.3451, 135.98312, 23.22))) * 3452.1393);\n}\n\n\n// ----------------------------------------------------------------\n// Simplex noise code generated at: https://stegu.github.io/webgl-noise/webdemo/periodic.html\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n// ----------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float S = K / dt;\n    vec2 step = vec2(1.0) / iResolution.xy;\n    vec2 extForce = vec2(0.);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy;\n    vec2 nMousePos = mouse.xy / iResolution.xy;\n    float ar = iResolution.x / iResolution.y;\n    \n    if (iFrame < 10) {\n        fragColor = vec4(\n            0.001 * snoise(0.00125 * fragCoord.xy), \n            0.001 * snoise(0.00125 * fragCoord.yx), 1.0, 0.0);\n        return;\n    }\n    // external force\n    if (iMouse.z > 0.) {\n        vec2 mDelta = getMouseDelta(nMousePos);\n        float dist = circleSdf(uv, nMousePos, PEN_FORCE_RADIUS, ar);\n        if (dist < 0.) {\n            float p = -1.0 * dist / PEN_FORCE_RADIUS;\n            extForce = mix(0., 0.3, p) * mDelta; //penForce(iTime, 1.0, dist, PEN_FORCE_RADIUS);\n        }\n    }\n    \n    //extForce = vec2(sin(iTime)) * 0.0001 * (texture(iChannel1, uv) - 0.5).xy;\n    \n    vec4 left = texture(iChannel0, uv + vec2(step.x, .0));\n    vec4 right = texture(iChannel0, uv - vec2(step.x, 0.));\n    vec4 top = texture(iChannel0, uv - vec2(0., step.y));\n    vec4 bottom = texture(iChannel0, uv + vec2(0., step.y));\n    \n    vec4 center = texelFetch(iChannel0, ivec2(fragCoord), 0);    \n    \n    // density\n    float divX = 0.5 * (left.x - right.x);\n    float divY = 0.5 * (top.y - bottom.y);\n    float divU = divX + divY;\n    vec2 divD = vec2(left.z - right.z, top.z - bottom.z) * vec2(0.5);\n    float nextDensity = center.z - dt * dot(vec3(divD, divU), center.xyz);\n    nextDensity = clamp(nextDensity, 0.5, 3.0);\n    center.z = nextDensity;\n    \n    // u - velocity\n    vec2 lapl = (left.xy + right.xy + top.xy + bottom.xy) - center.xy * 4.0;\n    vec2 viscF = VS * lapl;\n    \n    // advection\n    \n    vec2 uvAdv = uv - dt * center.xy * step;\n    center.xy = texture(iChannel0, uvAdv).xy;\n    center.xy += dt * viscF;\n    center.xy -= S * divD;\n    center.xy += dt * extForce;\n    center.xy *= 0.9995;\n    \n    if (((uv.x + step.x) > 1.0) || ((uv.x - step.x) < 0.0)) {\n        center.x = 0.;\n    } \n    if (((uv.y + step.y) > 1.0) || ((uv.y - step.y) < 0.0)) {\n        center.y = 0.;\n    }\n    \n    fragColor = center;\n    if (fragCoord.y < 1.) {\n        if (fragCoord.x < 1.) {\n            if (iMouse.z > 0.) {\n                fragColor.w = nMousePos.x;\n            } else {\n                fragColor.w = 0.0;\n            }\n        } else if (fragCoord.x >= 1. && fragCoord.x < 2.) {\n            if (iMouse.z > 0.) {\n                fragColor.w = nMousePos.y;\n            } else {\n                fragColor.w = 0.0;\n            }\n        }\n    }    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nvec4 shaderColors[NUM_BRUSHES] = vec4[NUM_BRUSHES](\n    vec4(0.65, 0.94, 0.94, 0.3),\n    vec4(0.95, 0.38, 0.38, 0.3),\n    vec4(0.13, 0.58, 0.58, 0.3),\n    vec4(0.95, 0.48, 0.49, 0.3),\n    vec4(0.92, 0.96, 0.96, 0.3),\n    vec4(0.06, 0.99, 0.99, 0.3),\n    vec4(0.74, 1.00, 1.0, 0.3),\n    vec4(0.54, 0.89, 0.87, 0.3),\n    vec4(1.00, 0.19, 0.19, 0.3)\n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float rMix = (0.5 + 0.5 * sin(iTime));\n    vec4 col = vec4(1.);\n    float ar = iResolution.x / iResolution.y;\n    if (iFrame < 10) {\n        float hdist = mod(fragCoord.x, 40.0);\n        float vdist = mod(fragCoord.y, 40.0);\n        int hcol = int(floor(fragCoord.x / 40.0)) % NUM_BRUSHES;\n        int vcol = int(floor(fragCoord.y / 40.0)) % NUM_BRUSHES;\n        col = hdist < 4. ? shaderColors[hcol] : vec4(0.);\n        //col += vdist < 2. ? shaderColors[vcol] : vec4(0.);\n        \n    } else {\n        vec2 u = texelFetch(iChannel2, ivec2(fragCoord), 0).xy;\n        col = texture(iChannel1, uv + u);\n        vec4 addedColor = vec4(0.);\n        float numActive = 0.;\n        for (int i=0; i < NUM_BRUSHES; i++) {\n            vec4 mouse = texelFetch(iChannel3, indexToCoord(i, iResolution), 0);    \n            //float dynR = 0.25 * length(iMouse.xy - mouse.xy) / iResolution.x;\n            float dynR = mix(PEN_INK_RADIUS * 2., PEN_INK_RADIUS * 6., sin(iTime * 0.5) * 0.5 + 0.5);\n            if (mouse.xy != vec2(0.)) {      \n                float dist = circleSdf(uv, mouse.xy / iResolution.xy, mix(dynR, dynR * 1., rMix), ar);\n                if (dist < 0.) {\n                    vec4 inkColor = shaderColors[i];\n                    vec4 b = reflect(addedColor, inkColor);\n                    float p = smoothstep(0., 1.0, -1. * dist / dynR);\n                    vec4 a = mix(b, vec4(inkColor.xyz, 1.0), p);\n                    addedColor += mix(b, a, sin(iTime * 0.5) * 0.5 + 0.5);\n                    numActive += 1.;\n                }\n            }\n        }\n        if (numActive > 0.) {\n            addedColor = addedColor / numActive;\n        }\n        float overflow = dot(col, vec4(1.0));\n        if (overflow > 4.0) {;\n            col = addedColor * 0.5;\n        } else {\n            col = (col + addedColor);\n        }\n    }\n    col *= 0.995;\n    fragColor = clamp(col, vec4(0.), vec4(1.));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// NOTE: This shader is intended to be used at the Chroma creator tool app. \n// If you want to explore music expressions with your shaders, you just have to try it. \n// \n// See the Chroma template shader for more details: https://www.shadertoy.com/view/ctGcWG\n// \n// Added fluid dynamics with multiple brush support (turn on and off brushes with key 1-9). \n// The brush and mouse management are adapted from the Chroma template shader. \n// This is just a starting point. A lot more can be done. \n\n#define PEN_FORCE_RADIUS 0.2\n#define PEN_INK_RADIUS 0.01\n\n#define NUM_BRUSHES 9\n\n/**\n * Lookup function for texture data buffers.\n *\n * Maps 2D fragment coordinates to its corresponding 1d buffer position (index = y * width + x)\n *\n * Discussion: \n * Note that using textures as data storage on shadertoy will be dependent on the canvas size \n * since the buffers allocated will follow those dimensions. \n * \n * Since we have a super small buffer, we could probably get away with using the x-value for index \n * (and hard code y to 0). We would save a few cpu cycles this way. \n * But we do it properly just in case to avoid strange errors if the shader is modified.\n *\n */\n\nint fragToIndex(in vec2 fragCoord, in vec3 iResolution) {\n    ivec2 icoord = ivec2(fragCoord);\n    ivec2 ires = ivec2(iResolution);\n    int fragIndex = icoord.y * ires.x + icoord.x;\n    return fragIndex;\n}\n\n/**\n * Reverse lookup function for texture data buffers. \n *\n * Maps a 1d buffer position to its corresponding 2D fragment coordinates\n */\n\nivec2 indexToCoord(in int index, in vec3 iResolution) {\n    int h = int(iResolution.y);\n    int y = index / h;\n    int x = index - (y * h);\n    return ivec2(x, y);\n}\n\nfloat circleSdf(vec2 uv, vec2 pt, float radius, float ar) {\n    return length(vec2(ar, 1.0) * (uv - pt)) - radius;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/**\n * KEYBOARD\n *\n * Implement a mouse state memory for each brush controlled by the keyboard. \n *\n * Use the following rules:\n * - Initialise the buffer to zero\n * - Each brush is mapped to a numeric key. \n * - A key can be toggled or not toggled (like Caps Lock)\n * - If a key is toggled then the mouse xyzw position will be tracked for that brush\n * - If a key is not toggled then we keep the last mouse position (.xy) and zero the rest (.zw)\n * \n * Ultimately a buffer with mouse coordinates for each brush index will be produced\n * At brush index a vec4 is stored with the following properties:\n * - xy - The mouse screen position\n * - zw - The mouse start posistion (iMouse.zw) if toggled, otherwise vec2(0.) \n */\n\n#define keyToggle(ascii) ( texelFetch(iChannel3, ivec2((ascii),2),0).x > 0.)\n\n#define ASCII_NUM_1 49\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    if (iFrame < 10) {\n        return;\n    }\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    int fragIndex = fragToIndex(fragCoord, iResolution);\n    for (int i = 0; i < NUM_BRUSHES; i++) {\n        int key = ASCII_NUM_1 + i;\n        if (fragIndex == i) {\n            if (keyToggle(key)) {\n                fragColor = iMouse;\n            } else {\n                fragColor.zw = vec2(0.);\n            }\n        }\n    }   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/**\n * BRUSH TRANSITION\n *\n * Implement a brush transition memory that eases the current mouse positions to its corresponding target \n *\n * Use the following rules:\n * - Initialise the buffer to zero\n * - Use the similar indexing system as in Buffer A (keyboard)\n * - Buffer A contains the target values\n * - Buffer B contains the intermediate values\n * - For valid brush indices, store a new intermediate value by mixing the target value with the intermediate value\n * - For empty values, skip mixing and just output zero\n */\n \n#define MOTION_EASING_FACTOR 0.15\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int fragIndex = fragToIndex(fragCoord, iResolution);\n    fragColor = vec4(0.);\n    if (fragIndex < NUM_BRUSHES) {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        if (fragColor.z >= 0.) {\n            vec4 colB = texelFetch(iChannel1, ivec2(fragCoord), 0);\n            fragColor.xy = mix(colB.xy, fragColor.xy, MOTION_EASING_FACTOR);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}