{
    "Shader": {
        "info": {
            "date": "1622628736",
            "description": "A ukiyo a inspired shader. Inspired by a Shin hanga Kawase Hasui piece known as Road to Arayu, Shiobara. You can find the original here https://artsandculture.google.com/asset/road-to-arayu-shiobara-artist-kawase-hasui-publisher-s-watanabe-color-print-co/",
            "flags": 0,
            "hasliked": 0,
            "id": "sdsXWf",
            "likes": 74,
            "name": "Ukiyo-e Japanese Woodblock Print",
            "published": 3,
            "tags": [
                "2d",
                "landscape",
                "painting",
                "japanese",
                "reproduction",
                "ukiyoe"
            ],
            "usePreview": 1,
            "username": "ircss",
            "viewed": 1417
        },
        "renderpass": [
            {
                "code": "#define sky_upper        vec3(0.76,  0.74,  0.64)\n#define sky_lower        vec3(0.81,  0.68,  0.53)\n#define mountain_color   vec3(0.25,  0.35,  0.45)\n#define mountain_outline vec3(0.24,  0.28,  0.31)*0.9\n#define hill_upper       vec3(0.71,0.53,0.26)\n#define hill_lower       vec3(0.71,0.53,0.26)\n#define hill_natural     vec3(0.77,0.61,0.37)\n#define hill_outline     vec3(0.57,0.37,0.14)\n#define cloud_upper      vec3(0.85,  0.79,  0.69)\n#define cloud_lower      vec3(0.72,  0.7,   0.63)\n#define cloud_outline    vec3(0.64,  0.6,   0.48) * 0.9\n#define border_color     vec3(0.250, 0.250, 0.250)\n#define bush_color_far   vec3(0.63,0.35,0.16)\n#define bush_color_far2  vec3(0.51,0.25,0.14)\n#define d_tree_outline   vec3(0.42,0.17,0.05)\n#define tree_close_trunk vec3(0.39,0.3,0.15)\n#define tree_leaves      vec3(0.56,0.26,0.11)\n#define tree_leaves2     vec3(0.61,0.4,0.22)\n#define leaves_outline   vec3(0.35,0.22,0.09)\n#define paper_color      vec3(0.84,0.79,0.66)\n#define paper_outline    vec3(0.61,0.58,0.47)\n#define paper_col_dark   vec3(0.78,0.72,0.6)\n\n#define TAU  6.28318530718\n#define PI   3.14159265359\n\n// -----------------------------------------------\n// From https://www.shadertoy.com/view/XdXGW8\n\nvec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)b\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n#if 0\n\n    // simple random vectors\n    return vec2(cos(float(n)),sin(float(n)));\n    \n#else\n\n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;\n#endif                              \n}\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat rand(float seed) \n{\n  return fract(sin(mod(seed,1000.) *52.02) * 7632.2);\n}\n\nfloat rand2D(vec2 seed) \n{\n  return fract(sin(dot(mod(seed, vec2(1000.)), vec2(18.612, 52.624)) *52.02) * 842.2);\n}\n\n// From https://github.com/glslify/glsl-aastep/blob/master/index.glsl\nfloat aaStep(float threshold, float x)\n{\n    float afwidth = clamp(length(vec2(dFdx(x), dFdy(x))) * 0.70710678118654757, 0. ,0.05);\n    return smoothstep(threshold-afwidth, threshold+afwidth, x);\n}\n\nfloat tWave(float x, float amplitude, float frequency){\n      return abs((fract(x*frequency) *2.)-1.) * amplitude;   \n}\n\n\nfloat distanceWithAspectRatio(vec2 v1, vec2 v2, float aspectRatio)\n{\n   vec2 t = v2 - v1; \n   return sqrt(t.x* t.x*(aspectRatio*aspectRatio)  + t.y *t.y);\n}\n\nvoid DrawWithOutline(inout vec3 col, vec3 paintCol, vec3 outlineCol, float threshold, float value, float thickness)\n{\n       vec3 maskCol = mix(outlineCol, paintCol, aaStep(thickness, threshold - value));\n       col = mix(maskCol, col, aaStep(threshold, value));\n}\n\n\nfloat distanceOnNormalizedAngle(float angle, float refPoin)\n{\n  \n  float d =abs( angle - refPoin);\n  if(d> 0.5) d = 1. - d;\n  return d;\n}\n\n\nvoid DrawBetweenTwoPoints(vec2 origin, vec2 end, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){\n    \n    \n    vec2 vector = end - origin;\n          uv  -= origin;\n    float len  = length(vector);\n       vector /= len;\n    float v2   = dot(vector, vector);\n    float vUv  = dot(vector, uv);\n    vec2  p    = vector * clamp(vUv, 0.,len) /v2;\n    float d    = distance(p, uv);\n\n    sceneColor = mix(lineColor, sceneColor, clamp(aaStep(size, d), 0. ,1.)); \n}\n\n// -----------------------------------------------\n\nvoid PaintSky(inout vec3 col, in vec2 uv)\n{\n\n   \n    col = mix( sky_lower, sky_upper, smoothstep(0.5, 0.70, uv.y));\n    col = mix(col, paper_color ,  pow(texture(iChannel0,uv*2.).x,5.));\n}\n\n\nfloat cloudsHeightFunction(float coord_x, float baseamplitude, float baseFrequency, float height, vec2 coord_i, float distanceToEdge)\n{\n\n   float upperPart = rand2D(coord_i + vec2(51.2, 82.58))*0.15;\n   \n   float upOrDown = step(0.,height);\n   \n   for(float f = 1.; f <6.0; f++)\n     {\n       upperPart += abs(sin(coord_x * baseFrequency * f + rand2D(coord_i + \n       vec2(f*51.2 +72.124, f*82.58+ 93.125))\n       + iTime*0.2)) * baseamplitude/f;\n     };\n     \n     float lowerPart = 0.0f;\n     \n      for(float f = 1.; f <4.0; f++)\n     {\n       lowerPart += abs(sin(coord_x * baseFrequency * f*0.5 + \n       rand2D(coord_i+ vec2(f*12.8231+53.838, f*62.61+ 12.09)))) * baseamplitude * 0.5/f;\n     };\n     \n     return mix(upperPart, lowerPart, mix(upOrDown, 1.,  1.-distanceToEdge));\n}\nvoid PaintMountain(inout vec3 col, in vec2 uv)\n{\n\n\n    float fogHeight = sin(uv.x*2.) *0.1;\n\n\n\n     float f  = 0.40;\n     float baseAmplitude = 0.12;\n     float baseFrequency = 1.;\n     \n     f += fogHeight;\n     \n     \n     for(float i = 1.; i<10. ; i++)\n     {\n        f += tWave(uv.x + rand(i), baseAmplitude / i,  baseFrequency * i);\n     }\n     \n     fogHeight += tWave(uv.x + 21.521, 0.1,  0.4);\n     \n    vec3 mountainAndFog = mix(mountain_color, sky_lower, smoothstep(0.1, 0.3 , fogHeight *0.5 + 0.6  - uv.y) ); \n     \n     \n     \n     \n     \n     float fracUV_y = uv.y;\n     \n     fracUV_y-= f;\n  \n     float uv_i_y = floor(fracUV_y *12.);\n     fracUV_y = fract(fracUV_y *12.);\n  \n     \n     float outline = aaStep(0.02 , \n                            abs(fracUV_y - 0.5 + sin(uv.x*20.) * 0.5)) - \n                            abs(sin(uv.x*8. + rand(uv_i_y*10.)*6.4)) *0.008 \n                      + abs(sin(uv.x *10. + rand((uv_i_y +24.12)*10.)*6.4)) ;\n           outline = clamp(outline, 0. , 1.);\n    \n        mountainAndFog = mix(mountain_outline, mountainAndFog, outline);\n        mountainAndFog = mix(mountainAndFog, paper_color ,  pow(texture(iChannel0,uv*5.).x,6.));\n        \n        DrawWithOutline(col, mountainAndFog, mountain_outline, f, uv.y, 0.004 + abs(sin(uv.x*5.)) *0.004);\n     \n}\n\nvoid DetermineHillHeights(inout vec3 col, in vec2 uv, out float hillHeight)\n{\n    hillHeight =   (sin(uv.x*7. +2.5) *0.5 + 0.5) *0.05  + 0.4 +\n          + sin(uv.x*3. + 2.3) *0.06+ (sin(uv.x*88.+ 7.) ) * 0.0025  + sin(uv.x*30. + 3.3 ) *0.01;\n}\n\nvoid PaintHills(inout vec3 col, in vec2 uv, in float hillHeight)\n{\n    vec3 hillWithGradient = mix(hill_upper, hill_lower, smoothstep(0.1, 0.5, sin(uv.x*8.) *0.05 + 0.3 - uv.y) ); \n\n\n    float innerLinesWave = (abs(sin(uv.x*2.) + 0.05))*( 1.-min(1., (hillHeight - uv.y)))* 0.25;\n    \n    vec2 coord   = uv - vec2(0., hillHeight + innerLinesWave); \n    vec2 coord_f = fract(coord* vec2(2., 10.) );\n    vec2 coord_i = floor(coord* vec2(2., 10.) );\n    \n    float sinWaveOne =  sin(uv.x* 13. + rand(coord_i.y*252.125 + 521.2)*612.21);\n    float outline = aaStep(0.0, \n    abs(coord_f.y - 0.5 +sinWaveOne*0.2) - 0.0025\n    + sin(uv.x* 15. + rand(coord_i.y*252.125)*612.21)*0.015 );\n    \n           \n           \n           \n     mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n     vec2 noiseUV = (coord +vec2(0., sinWaveOne)*0.03 ) * vec2(69., 80.);\n    float noisef  = noise(noiseUV); noiseUV = m* noiseUV;\n          noisef += 0.5*noise(noiseUV); noiseUV = m* noiseUV;\n          noisef += 0.25*noise(noiseUV); noiseUV = m* noiseUV;\n          noisef += 0.125*noise(noiseUV);\n          noisef += noise(coord * 5.);\n    float texturefactor = clamp(abs(noisef),0., 1.);\n    \n    hillWithGradient = mix(hillWithGradient, hill_natural, texturefactor);\n    \n    hillWithGradient = mix(hill_outline ,hillWithGradient,outline);\n    \n    hillWithGradient = mix(hillWithGradient, paper_color ,  pow(texture(iChannel0,uv*2.).x,5.));\n    \n    DrawWithOutline(col, hillWithGradient, hill_outline, 0.001,uv.y -hillHeight , 0.0025 + abs(sin(uv.x*5.)) *0.003);\n    \n}\n\nvoid PaintHClouds(inout vec3 col, in vec2 uv, float aspectRatio)\n{\n    vec2 uv_cloud_i = floor(uv * vec2(2., 8.)) ;\n    vec2 uv_cloud_f = fract(uv * vec2(2., 8.) + vec2( rand(uv_cloud_i.y*3.) * 0.5, 0.)) ;\n    vec2 uv_cloud_r = floor(uv * vec2(2., 8.) + vec2( rand(uv_cloud_i.y*3.) * 0.5, 0.)) ;\n     aspectRatio =  4./aspectRatio  ;\n    \n    vec2 center      = vec2(rand2D(uv_cloud_r + vec2(21.51,73.)), rand2D(uv_cloud_r + vec2(2., 51.51)));\n         center.x    = center.x *2. - 1.;\n         center      = vec2(0.5, 0.25) + center *vec2(0.3, 0.0); \n         \n         \n         // Determine cloud starting and ending point\n   float leftPoint   = 0.1       + (center.x - 0.1)  * rand2D(uv_cloud_r *vec2(572.21, 72.823) + vec2(94.1, 46.87));\n   float rightPoint  = center.x  + (0.9 - center.x ) * rand2D(uv_cloud_r *vec2(55.93, 287.23) + vec2(2.215,912.2));\n         \n   float endsAsdots  =  aaStep(0.02, min(distanceWithAspectRatio(vec2(leftPoint, center.y),uv_cloud_f, aspectRatio),\n                 distanceWithAspectRatio(vec2(rightPoint, center.y),uv_cloud_f, aspectRatio)));\n\n         // Determining the projection of the current pixel on the line between left and right points\n         \n    float projectionPos = min(max(leftPoint, uv_cloud_f.x), rightPoint);\n    float distanceToEdge =  min(uv_cloud_f.x - leftPoint , rightPoint - uv_cloud_f.x); \n\n\n    float distanceToLine  = distanceWithAspectRatio(vec2(projectionPos, center.y), uv_cloud_f,aspectRatio )*0.5;\n          distanceToLine -= cloudsHeightFunction(uv_cloud_f.x, 0.1, 10., \n          center.y - uv_cloud_f.y, uv_cloud_r* vec2(51.251, 72.21), smoothstep(0., 0.01, distanceToEdge)) \n          * smoothstep(-0.05, 0.05, distanceToEdge);\n\n    float maskCoord  = distanceToLine ;\n    float threshold  = 0.01;\n          threshold -= step(7., uv_cloud_i.y);\n          threshold -= step(0.5, rand2D(uv_cloud_r));\n          \n    vec3  cloudColGrad =mix(cloud_lower, cloud_upper, uv_cloud_f.y) ;\n        cloudColGrad = mix(cloudColGrad, paper_color ,  pow(texture(iChannel0,uv*2.).x,5.));\n    DrawWithOutline(col, cloudColGrad, cloud_outline, threshold, maskCoord, 0.004 + abs(sin(uv.x*12.)) *0.01);\n    \n}\n\nfloat GetFarTreeDisplacement(float Domain, float baseFrequency, float baseAmplitude, float seed)\n{\n  float d = 0.0;\n  \n\n\n        d += (sin((Domain + rand(seed*25.521 + 0.0)) *baseFrequency ) *0.5 + 0.5)* baseAmplitude; \n        baseAmplitude *= 0.9;\n        baseFrequency *= 1.2;\n        \n        d += (sin((Domain + rand(seed*25.521 + 61.21)) *baseFrequency ) *0.5 + 0.5)* baseAmplitude; \n        \n        baseAmplitude *= 0.9;\n        baseFrequency *= 1.5;\n        \n        d += (sin((Domain + rand(seed*25.521 + 21.6231)) *baseFrequency ) *0.5 + 0.5)* baseAmplitude; \n        baseAmplitude *= 0.5;\n        baseFrequency *= 3.5;\n        \n        d += (sin((Domain + rand(seed*12.521 + 93.8236)) *baseFrequency ) *0.5 + 0.5)* baseAmplitude; \n        d += (sin((Domain + rand(seed*12.521 + 62.8787)) *120. ) *0.5 + 0.5)* 0.05; \n        \n  return d;\n}\n\n\nvoid PaintDistanceTrees(inout vec3 col, in vec2 uv, in float terrainHeight, float seed, float aspectRatio)\n{\n   vec2 uv_bush_i = floor(uv * vec2(15., 1.));\n   vec2 uv_bush_f = fract(uv * vec2(15., 1.));\n        uv_bush_f.y = uv_bush_f.y - terrainHeight;\n        uv_bush_f.y *= 15. * aspectRatio;\n  \n   float threshold = 0.3;\n   float shoulDraw = step(0.4, rand(uv_bush_i.x +1. + seed));\n         threshold-=  shoulDraw;\n         \n         float treeCenterY = (rand((uv_bush_i.x+seed)*65.)*2.0-1.0) * 0.4;\n         \n         vec2 toTreeCenter = vec2(0.5, treeCenterY) - uv_bush_f;\n         \n         float randOne = rand(seed*251.221 + uv_bush_i.x*2.521);\n   float f         = length(toTreeCenter);\n   float angle     = fract(atan(toTreeCenter.y, toTreeCenter.x) / TAU + 0.5 + 0.25);\n   float dis       = GetFarTreeDisplacement(angle, \n                     6.+randOne*10.,\n                     0.2,  seed + uv_bush_i.x);\n         f        -= dis * distanceOnNormalizedAngle(angle, 0.);\n   \n   float sinOne = sin((uv_bush_f.x + seed *82.12+ uv_bush_i.x*10.67) *35.);\n   float colorFactor = abs(noise(uv_bush_f*2.\n   + vec2(0., sinOne*0.1 )));\n   \n   colorFactor +=  smoothstep(treeCenterY+0.1, treeCenterY-0.3, uv_bush_f.y  + sinOne*0.01);\n   \n  vec3 bushColor  = mix( bush_color_far, bush_color_far2, colorFactor);\n  \n    // Draw trunk\n    \n    float thickness = abs(sin(angle*12. + seed*6.21 + uv_bush_i.x*5.214 + uv.y*30.));\n    \n    DrawBetweenTwoPoints(vec2(0.5, treeCenterY), vec2(0.5, treeCenterY-0.5),\n    uv_bush_f + vec2(0., 0.), 0.005 - shoulDraw + thickness*0.03 , mix(d_tree_outline, bush_color_far, 0.25), col);\n    \n    // Draw inner leaves\n    \n    \n    float coord_leaves =  distance(uv_bush_f, vec2(0.5, treeCenterY-0.5))*5.;\n    float coord_l_i    = floor(coord_leaves);\n          coord_leaves = fract(coord_leaves);\n    float sinTwo   = sin(uv_bush_f.x *82. + randOne *65.61+ coord_l_i*82.21);\n    float sinThree = sin(uv_bush_f.x *10. + randOne *65.61+ coord_l_i*52.21);\n          coord_leaves = abs(coord_leaves - 0.5 + sinTwo*0.05+ sinThree*0.4);\n          coord_leaves = aaStep(-0.031, coord_leaves  + sinThree*0.1);\n    bushColor = mix(bush_color_far2,bushColor, coord_leaves);\n    \n      bushColor = mix(bushColor, paper_color ,  pow(texture(iChannel0,uv*3.).x,6.));\n    \n   DrawWithOutline(col, bushColor, d_tree_outline, threshold, f,\n   0.008 + thickness*0.01);\n   \n   \n   \n}\n\n\n\nvec4 LineSegCoord(vec2 p1, vec2 p2, vec2 uv, out float segmentLength){\n    \n\n    vec2 vector = p2 - p1;                         // Find the vector between the two lines\n          uv   -= p1;                              // Move the entire coord system so that the point 1 sits on the origin, it is either that or always adding point 1 when you want to find your actual point\n    float len   = max(length(vector), 0.01);                  // Find the ditance between the two points\n       vector  /= len;                             // normalize the vector \n    float vUv   = dot(vector, uv);                 // Find out how far the projection of the current pixel on the line goes along the line using dot product\n    vec2  p     = vector * clamp(vUv, 0.,len) ;    // since vector is normalized, the if you multiplied it with the projection amount, you will get to the coordinate of where the current uv has the shortest distance on the line. The clamp there ensures that this point always remains between p1 and p2, take this out if you want an infinite line\n    vec2 ToLine = p - uv;                       \n    float d     = length(ToLine);                  // the actual distance between the current pixel and its projection on the line\n    \n    vec2 ortho    = vec2(vector.y, -vector.x);     // For 3D you would have to use cross product or something\n    float signedD = dot(ortho, ToLine);            // this gives you a signed distance between the current pixel and the line. in contrast to the value d, first this value is signed, so different on the different sides of the line, and second, for a line segment with finite ends, beyond the finit end, the magnitude of this value and d start to differ. This value will continue to get smaller, as you go around the corner on the finit edge and goes into negative\n    segmentLength = len;\n    \n                                                   // fourth component is used for drawing the branch thickness, is a noramlized value stating how far the pixel is between p1 nad p2\n    return vec4(vUv, d, signedD, clamp(vUv, 0.,len)/ len); \n}\n\nfloat determineBranchThickness(float size, vec4 branchCoord)\n{\n    size = mix(size, max(size, 0.8),  branchCoord.w);\n    return mix(0.05, 0., size);\n}\n\n\n\n\nfloat GetBranchDisplacement(vec2 uv, float seed)\n{\n  float d  =  (sin((uv.x + rand(seed*82.521 + 0.0)) *10. ) *0.5 + 0.5)* 0.1; \n        d  =  (sin((uv.y + rand(seed*82.521 + 0.0)) *10. ) *0.5 + 0.5)* 0.1; \n        d +=  (sin((uv.x + rand(seed*12.57 + 2.6123)) *15. ) *0.5 + 0.5)* 0.08;\n        d +=  (sin((uv.y + rand(seed*68.2146 + 5.84746)) *40. ) *0.5 + 0.5)* 0.025;\n        d +=  (sin((uv.y + rand(seed*90.572 + 73.232)) *60. ) *0.5 + 0.5)* 0.03;\n        return abs(d);\n}\n\nfloat GetLeaveShapes(vec4 branchCoord, float segmentLength, float treeShouldExist, float seed, out float randLeaveSpace)\n{\n   \n  vec2 leaveCoord_f = fract(vec2(branchCoord.x*4. + sign(branchCoord.z)*0.2, branchCoord.z));\n  vec2 leaveCoord_i = floor(vec2(branchCoord.x*4. + sign(branchCoord.z)*0.2, branchCoord.z));\n  \n  float leaveIsOnBranch = step( segmentLength, (leaveCoord_i.x +0.5)/4.);\n        leaveIsOnBranch += step((leaveCoord_i.x +0.5)/4., 0.);\n  \n  randLeaveSpace =  rand(seed + rand2D(leaveCoord_i + vec2(51.61,87.21)));\n  \n  float laeveShape = abs(leaveCoord_f.x - 0.5);\n        laeveShape = leaveIsOnBranch+ treeShouldExist\n        + laeveShape - mix(0., mix(0.2,0.25 + abs(sin(2.35* branchCoord.x/TAU\n        + rand(randLeaveSpace+2.731 + sign(branchCoord.y)*20.0231)))*0.2, randLeaveSpace),  \n        abs(sin(PI*clamp(branchCoord.z/mix(0.2, 0.35, rand(randLeaveSpace+52.731)), -1.,1.))));\n\n\n     \n  return laeveShape;  \n}\n\nvoid DrawLeaves(inout vec3 col, vec4 branchCoord, float segmentLength, float treeShouldExist, float seed, vec2 uv)\n{\n     float randLeaveSpace;\n\n   branchCoord.x += sin(branchCoord.z*5. + rand(seed) * 6.12)*0.05;\n\n   float leaveShape = GetLeaveShapes(branchCoord, segmentLength, treeShouldExist, seed , randLeaveSpace);\n   \n   float noiseMask = pow(texture(iChannel0,uv*3.).x,5.);\n   vec3 leaveColor = mix(tree_leaves, tree_leaves2,randLeaveSpace);\n leaveColor = mix(leaveColor, paper_color ,  noiseMask);\n   \n   float leaveOutlineThickness = sin(branchCoord.x*20.+randLeaveSpace);\n   DrawWithOutline(col, leaveColor, leaves_outline, -0.03, leaveShape, 0.05 + abs(leaveOutlineThickness*0.06));\n   branchCoord.x += /*sin(branchCoord.z*5. + rand(seed+62.721) * 6.12 )*0.05 + */\n                    sin(branchCoord.x*5. + rand(seed+62.721) * 6.12 )*0.05  ;\n   leaveShape = GetLeaveShapes(branchCoord + vec4(0.15,0.,0.,0.), segmentLength, treeShouldExist, seed +62.213, randLeaveSpace);\n   leaveOutlineThickness = sin(branchCoord.x*20.+randLeaveSpace);\n  \n  leaveColor = mix(tree_leaves, tree_leaves2,randLeaveSpace);\n leaveColor = mix(leaveColor, paper_color ,  noiseMask);\n  \n  DrawWithOutline(col, leaveColor, leaves_outline, -0.03, leaveShape, 0.05 + abs(leaveOutlineThickness*0.06));\n   \n    leaveShape = GetLeaveShapes(branchCoord + vec4(-0.1521,0.,0.,0.), segmentLength, treeShouldExist, seed +9.213, randLeaveSpace);\n   leaveOutlineThickness = sin(branchCoord.x*20.+randLeaveSpace);\n   \n   leaveColor = mix(tree_leaves, tree_leaves2,randLeaveSpace);\n leaveColor = mix(leaveColor, paper_color ,  noiseMask);\n   \n   DrawWithOutline(col, leaveColor, leaves_outline, -0.03, leaveShape, 0.05 + abs(leaveOutlineThickness*0.06));\n   \n     leaveShape = GetLeaveShapes(branchCoord + vec4(0.1,0.,0.,0.), segmentLength, treeShouldExist, seed -24.173, randLeaveSpace);\n   leaveOutlineThickness = sin(branchCoord.x*20.+randLeaveSpace);\n  \n  leaveColor = mix(tree_leaves, tree_leaves2,randLeaveSpace);\n leaveColor = mix(leaveColor, paper_color ,  noiseMask);\n  \n  \n  DrawWithOutline(col, leaveColor, leaves_outline, -0.03, leaveShape, 0.05 + abs(leaveOutlineThickness*0.06));\n\n \n}\n\n#define trunkBorder 0.25\n#define branchStartRange 0.7\n#define treeEndPad 0.2\nvoid PaintCloseUpTrees(inout vec3 col, vec2 uv, float seed)\n{\n\n\n  uv.x += sin(uv.y*10. + uv.x + seed)*0.02 + sin(uv.y*20. + uv.x + seed)*0.01;\n\n  vec2 uv_trunk_i = floor(uv * vec2(10., 7.));\n  vec2 uv_trunk_f = fract(uv * vec2(10., 7.));\n  \n  float range_x_dis = 1. - trunkBorder*2.;\n  \n  vec2 p0 = vec2( rand2D(uv_trunk_i)                * range_x_dis + trunkBorder, 0.);\n  vec2 p1 = vec2( rand2D(uv_trunk_i + vec2(0., 1.)) * range_x_dis + trunkBorder, 1.);\n  \n  \n  vec2 p0To1  = normalize(p1 - p0);\n  vec2 p0Touv = uv_trunk_f - p0;\n  \n  float dot_x   = dot(p0Touv, p0To1);\n  float error_y = distance(uv_trunk_f- p0,  dot_x * p0To1);\n  \n\n  float treeShouldExist  = step(.15,rand(uv_trunk_i.x +52.12 + seed*5.213)) ;\n  float trunkHeight      = rand(uv_trunk_i.x)*4.0;\n        treeShouldExist  = max(treeShouldExist, step(trunkHeight, uv_trunk_i.y));\n  float thicknessControl = min(1., (uv_trunk_i.y + uv_trunk_f.y)/ trunkHeight); \n  \n  \n  // --- branches\n  // - left  \n  float cellRandOne = rand2D(uv_trunk_i + vec2(5.21 + seed, 1.2541 + seed));\n  float branchLeftStartf   =  cellRandOne\n                             * min(trunkHeight - uv_trunk_i.y, branchStartRange + treeEndPad);\n  vec2  branchLeftStartv   = p0 + p0To1 * branchLeftStartf;\n  vec2  branchLeftEndv     = vec2(treeEndPad + rand2D(uv_trunk_i + vec2(2.712,  16.41)) * (branchLeftStartv.x - treeEndPad), \n                                  rand2D(uv_trunk_i + vec2(93.221 + seed, 22.83 + seed))\n                                  * (1. - branchLeftStartv.y - treeEndPad) +  branchLeftStartv.y );  \n \n  float branchThickStart   = min(1., (uv_trunk_i.y + branchLeftStartv.y)/ trunkHeight); \n  \n  \n  float segmentLength = 0.0;\n  vec4 branchCoord = LineSegCoord(branchLeftStartv, branchLeftEndv, uv_trunk_f, segmentLength);\n  \n\n float  branch = aaStep(0.001, branchCoord.y - determineBranchThickness(branchThickStart, branchCoord));\n \n  \n   float randLeaveSpace;\n   DrawLeaves(col, branchCoord, segmentLength, treeShouldExist, seed + cellRandOne, uv);\n \n  // - right \n  \n  float branchRightStartf   = rand2D(uv_trunk_i + vec2(251.24, 7.1281)) \n  * min(trunkHeight - uv_trunk_i.y, branchStartRange + treeEndPad);\n  vec2  branchRightStartv   = p0 + p0To1 * branchRightStartf;\n  vec2  branchRightEndv     = vec2(rand2D(uv_trunk_i + vec2(71.22,  96.12)) * (1. - branchRightStartv.x - treeEndPad) +  branchRightStartv.x , \n                                   rand2D(uv_trunk_i + vec2(0.21, 83.16)) * (1. - branchRightStartv.y - treeEndPad) +  branchRightStartv.y);  \n  \n        branchThickStart    = min(1., (uv_trunk_i.y + branchRightStartv.y)/ trunkHeight); \n\n     \n     \n     branchCoord = LineSegCoord(branchRightStartv, branchRightEndv, uv_trunk_f, segmentLength);\n     \n        branch *= aaStep(0.001, branchCoord.y - determineBranchThickness(branchThickStart, branchCoord));\n       DrawLeaves(col, branchCoord, segmentLength, treeShouldExist, seed + cellRandOne, uv);\n      vec3 trunkCol = mix(tree_close_trunk, paper_color ,  pow(texture(iChannel0,uv*2.).x,5.));\n  col = mix(trunkCol, col, max(aaStep(0., error_y - mix(0.05, 0., thicknessControl))* branch,treeShouldExist));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n         uv.y = 1.5 * uv.y  - 0.25;\n    vec3 col = vec3(0., 0., 0.);\n    uv.x += iTime*0.01;\n\n\n    float aspectRation = (iResolution.y / 1.5)/ iResolution.x;\n    PaintSky(col, uv);\n \n    PaintHClouds(col, uv, aspectRation);\n      uv.x += iTime*0.0065;\n      \n    PaintHClouds(col, uv * vec2(1., 0.8)+ vec2(7.213, 0.05 ), aspectRation);\n            uv.x += iTime*0.015;\n    PaintMountain(col, uv );\n    uv.x += iTime*0.1;\n    float hillHeights;\n    DetermineHillHeights(col, uv, hillHeights);\n    PaintDistanceTrees(col, uv*1.1, hillHeights+0.05, 0., aspectRation);\n    PaintHills(col, uv, hillHeights);\n    PaintDistanceTrees(col, (uv * 0.9) + vec2(5.2134, 0.), hillHeights-0.05, 51.613, aspectRation);\n    \n     uv.x += iTime*0.1;\n    \n    PaintCloseUpTrees(col, uv , -24.0);\n    \n     uv.x += iTime*0.1;\n    PaintCloseUpTrees(col, uv *0.95+ vec2(25.421, 0.05), 58.612);\n    \n    vec2 uvUnchanged = fragCoord/iResolution.xy;\n         uvUnchanged.x *= iResolution.x/iResolution.y;\n    \n     \n    vec2 shaderToyBorder      = vec2(0.0, 0.120 );\n    vec2 paperBorderThickness = vec2(0.045, 0.045);\n    float outlineThickness = 0.003 + abs(sin(uvUnchanged.x*5. +2.612) *0.1 + sin(uvUnchanged.y*5.)*0.1)*0.015;\n    \n    \n    vec3 outlineColor =  mix(paper_outline, paper_color ,  pow(texture(iChannel0,uvUnchanged*3.).x,3.));\n    \n    col = mix(outlineColor , col,  step(shaderToyBorder.y + paperBorderThickness.y + outlineThickness, uvUnchanged.y)\n              * (1.- step(1.- (shaderToyBorder.y + paperBorderThickness.y + outlineThickness), uvUnchanged.y)));\n    \n    col = mix(outlineColor , col,  step(shaderToyBorder.x + paperBorderThickness.x + outlineThickness, uvUnchanged.x)\n              * (1.- step((iResolution.x/iResolution.y) - (shaderToyBorder.x + paperBorderThickness.x + outlineThickness), uvUnchanged.x)));\n    \n    \n    vec3 pape = mix(paper_color, paper_col_dark ,  pow(texture(iChannel0,uvUnchanged*2.).x,2.)); \n    \n    \n    col = mix(pape , col,  step(shaderToyBorder.y + paperBorderThickness.y, uvUnchanged.y)\n              * (1.- step(1.- (shaderToyBorder.y + paperBorderThickness.y), uvUnchanged.y)));\n    \n    col = mix(pape , col,  step(shaderToyBorder.x + paperBorderThickness.x, uvUnchanged.x)\n              * (1.- step((iResolution.x/iResolution.y) - (shaderToyBorder.x + paperBorderThickness.x), uvUnchanged.x)));\n    \n    \n    \n    \n    \n    col = mix(border_color , col,  step(shaderToyBorder.x, uvUnchanged.x) \n    * (1.- step((iResolution.x/iResolution.y)- shaderToyBorder.x, uvUnchanged.x)));\n    \n    col = mix(border_color , col,  step(shaderToyBorder.y, uvUnchanged.y) \n    * (1.- step(1.-shaderToyBorder.y, uvUnchanged.y)));\n\n\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}