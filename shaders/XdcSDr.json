{
    "Shader": {
        "info": {
            "date": "1458789604",
            "description": "W, A, S, D, SPACE (ascend), SHIFT (descend). Render options and look inversion are at the top of the Image shader. Enjoy!",
            "flags": 48,
            "hasliked": 0,
            "id": "XdcSDr",
            "likes": 14,
            "name": "Camera Controls",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "mgattis",
            "viewed": 941
        },
        "renderpass": [
            {
                "code": "#define MAX_DISTANCE            (32.0)\n#define MIN_DELTA               (0.01)\n#define MAX_RAYITERATIONS       (192)\n\n// Look inversion.\n//#define Y_LOOK_INVERSION\n\n// Render options.\n#define USE_ANTIALIAS\n#define USE_REFLECTION\n#define USE_SHADOW\n\n// Debug mode? :3\n//     Scale [Zero Iterations] black > red > yellow > white [MAX_DEBUGITERATIONS]\n//     Brighter (yellow, white) pixels require more iterations to render, which is a\n//     good indicator of relative performance.\n//#define DEBUG\n#define MAX_DEBUGITERATIONS     (MAX_RAYITERATIONS * 4) /* quarter of max */\n\n// Background\n#define BG_DIRECTION            (vec3(0.0, 0.0, 1.0))\n#define BG_COLOR1               (vec3(1.0, 1.0, 1.0))\n#define BG_COLOR2               (vec3(0.0, 0.5, 1.0))\n#define BG_COLOR3               (vec3(1.0, 1.0, 1.0))\n//#define USE_CUBEMAP\n\n// Sun\n#define SUN_DIRECTION           (normalize(vec3(0.5, 0.5, 1.0)))\n\n// Surface\n#define OBJECT_REFLECTIVITY     (0.1)\n\n// Fog\n#define FOG_POWER               (32.0)\n\n#ifndef M_PI\n#define M_PI                    (3.1415926535897932384626433832795)\n#endif\n\n#define VALUE_POSITION          (1)\n#define VALUE_ROTATION          (2)\n\nint debugIterationCount;\n\n// Retrieve value from BufferA.\nvec4 getValue(int a)\n{\n    vec2 q = vec2(float(a) + 0.5, 0.0) / iResolution.x;\n    return texture(iChannel0, q);\n}\n\nvec3 vRotateX(vec3 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(p.x, c*p.y + s*p.z, -s*p.y + c*p.z);\n}\n\nvec3 vRotateY(vec3 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(c*p.x - s*p.z, p.y, s*p.x + c*p.z);\n}\n\nvec3 vRotateZ(vec3 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(c*p.x + s*p.y, -s*p.x + c*p.y, p.z);\n}\n\nfloat sphere(in vec3 p, in float r)\n{\n    p.xy = mod(p.xy, 4.0) - 2.0;\n    return length(p) - r;\n}\n\nfloat getMap(in vec3 p, out int object)\n{\n    float finalDistance;\n    float tempDistance;\n    \n    finalDistance = sphere(p - vec3(0.0, 4.0, 1.0), 1.0);\n    object = 1;\n    \n    tempDistance = p.z;\n    if (tempDistance < finalDistance)\n    {\n        finalDistance = tempDistance;\n        object = 2;\n    }\n    \n    return finalDistance;\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n\tfloat stepSize = 0.017;\n\tfloat t = stepSize;\n\tfloat oc = 0.0;\n\tint object = 0;\n\tfor(int i = 0; i < 8; ++i)\n\t{\n\t\tfloat d = getMap(p + n * t, object);\n\t\toc += t - d; // Actual distance to surface - distance field value\n\t\tt += stepSize;\n\t}\n\n\treturn 1.0-clamp(oc, 0.0, 1.0);\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec3 s = p;\n    float h = MIN_DELTA;\n    int object;\n    return normalize(vec3(\n            getMap(p + vec3(h, 0.0, 0.0), object) - getMap(p - vec3(h, 0.0, 0.0), object),\n            getMap(p + vec3(0.0, h, 0.0), object) - getMap(p - vec3(0.0, h, 0.0), object),\n            getMap(p + vec3(0.0, 0.0, h), object) - getMap(p - vec3(0.0, 0.0, h), object)));\n}\n\nfloat castRay(in vec3 origin, in vec3 direction, out int object)\n{\n    float rayDistance = 0.0;\n    float rayDelta = 0.0;\n    vec3 rayPosition;\n    object = 0;\n    \n    rayPosition = origin;\n    \n    for (int i = 0; i < MAX_RAYITERATIONS; i++)\n    {\n        debugIterationCount++;\n        \n        rayDelta = getMap(rayPosition, object);\n        \n        rayDistance += rayDelta;\n        rayPosition = origin + direction * rayDistance;\n        if (rayDelta <= MIN_DELTA)\n        {\n            return rayDistance;\n        }\n        if (rayDistance >= MAX_DISTANCE)\n        {\n            object = 0;\n            return MAX_DISTANCE;\n        }\n    }\n    \n    object = 0;\n    return MAX_DISTANCE;\n}\n\nvec3 getBackground(in vec3 direction)\n{\n#ifdef USE_CUBEMAP\n    return texture(iChannel1, -direction.xzy).rgb;\n#endif\n    \n    float bgVal = dot(direction, BG_DIRECTION);\n    \n    if (bgVal >= 0.0)\n    {\n        bgVal = pow(1.0 - bgVal, 2.5);\n        return mix(BG_COLOR2, BG_COLOR1, bgVal);\n    }\n    \n    return BG_COLOR1;\n}\n\n// http://www.pouet.net/topic.php?which=7931&page=1&x=3&y=14\nvec3 hsv(float h,float s,float v) {\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nvec3 getSurfaceColor(in vec3 position, in int object)\n{\n    \n    if (object == 1)\n    {\n        position.xy = position.xy / 4.0;\n        position.xy = position.xy - fract(position.xy);\n        position.xy = position.xy / 6.0;\n        float dist = abs(position.x) + abs(position.y);\n        return hsv(dist, 1.0, 1.0) + vec3(0.2, 0.2, 0.2);\n    }\n    else if (object == 2)\n    {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    \n    return vec3(1.0, 1.0, 1.0);\n}\n\nvec3 applyLight(in vec3 color, in vec3 normal, in vec3 position, in vec3 direction)\n{\n    vec3 diffuseColor = vec3(0.0, 0.0, 0.0);\n    vec3 specularColor = vec3(0.0, 0.0, 0.0);\n    int object = 0;\n    \n    vec3 SunDirection = SUN_DIRECTION;\n    \n    vec3 ambientColor = color * 0.2 * ambientOcclusion(position, normal);\n    \n#ifdef USE_SHADOW\n    position = position + normal * MIN_DELTA * 1.1;\n    castRay(position, SunDirection, object);\n    \n    if (object == 0)\n#endif\n    {\n        float diffuse = max(0.0, dot(normal, SunDirection));\n        diffuseColor = color * diffuse;\n        \n        vec3 ref = normalize(reflect(direction, normal));\n        float specular = max(0.0, dot(SunDirection, ref));\n        specular = pow(specular, 16.0);\n        specularColor = vec3(1.0, 1.0, 1.0) * specular;\n    }\n    \n    //float ao = ambientOcclusion(position, normal);\n    \n    return ambientColor + diffuseColor + specularColor;\n}\n\nvec3 drawScene(in vec3 origin, in vec3 direction)\n{\n    vec3 firstColor = vec3(0.0, 0.0, 0.0);\n    vec3 secondColor = vec3(0.0, 0.0, 0.0);\n    vec3 finalColor = vec3(0.0, 0.0, 0.0);\n    int object = 0;\n    \n    float firstDistance = castRay(origin, direction, object);\n    \n    vec3 firstPosition = origin + direction * firstDistance;\n    vec3 firstNormal = getNormal(firstPosition);\n    \n    firstColor = getSurfaceColor(firstPosition, object);\n    \n    if (object == 0)\n    {\n        vec3 bgColor = getBackground(direction);\n        float fogVal = pow(firstDistance / MAX_DISTANCE, FOG_POWER);\n        return mix(firstColor, bgColor, fogVal);\n    }\n    \n    firstColor = applyLight(firstColor, firstNormal, firstPosition, direction);\n    \n#ifdef USE_REFLECTION\n    vec3 secondOrigin = firstPosition + firstNormal * MIN_DELTA * 1.1;\n    vec3 secondDirection = normalize(reflect(direction, firstNormal));\n    \n    float secondDistance = castRay(secondOrigin, secondDirection, object);\n    \n    if (object != 0)\n    {\n        vec3 secondPosition = secondOrigin + secondDirection * secondDistance;\n        vec3 secondNormal = getNormal(secondPosition);\n\n        secondColor = getSurfaceColor(secondPosition, object);\n        secondColor = applyLight(secondColor, secondNormal, secondPosition, secondDirection);\n        // We are going to apply some background color to the secondColor.\n        vec3 secondReflection = normalize(reflect(secondDirection, secondNormal));\n        secondColor = mix(secondColor, getBackground(secondReflection), OBJECT_REFLECTIVITY);\n    }\n    else\n    {\n        secondColor = getBackground(secondDirection);\n    }\n    \n    finalColor = mix(firstColor, secondColor, OBJECT_REFLECTIVITY);\n#else\n    // Finish up first ray (NO_REFLECTION).\n    if (object != 0)\n    {\n        // We are going to apply some background color only if we hit an object.\n        vec3 firstReflection = normalize(reflect(direction, firstNormal));\n        firstColor = mix(firstColor, getBackground(firstReflection), OBJECT_REFLECTIVITY);\n    }\n    \n    finalColor = firstColor;\n#endif\n    \n    vec3 bgColor = getBackground(direction);\n    float fogVal = pow(firstDistance / MAX_DISTANCE, FOG_POWER);\n    return mix(finalColor, bgColor, fogVal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    vec3 cameraPosition = getValue(VALUE_POSITION).xyz;\n    vec3 cameraRotation = getValue(VALUE_ROTATION).xyz;\n    \n#ifdef Y_LOOK_INVERSION\n    cameraRotation.x = -cameraRotation.x;\n#endif\n    \n    vec3 origin = vec3(0.0, 0.0, 4.0) - cameraPosition;\n    \n    debugIterationCount = 0;\n    \n    // Use simple AA.\n#ifdef USE_ANTIALIAS\n    for (int i = 0; i < 4; i++)\n    {\n        vec2 offset = vec2(\n            mod(float(i), 2.0),\n            float(i / 2)\n            ) / 2.0;\n        \n        vec2 p = 2.0 * (fragCoord.xy + offset) / iResolution.y;\n        p -= vec2(iResolution.x / iResolution.y, 1.0);\n        \n        vec3 direction = vec3(p.x, -1.5, p.y);\n        direction = vRotateX(direction, cameraRotation.x);\n        direction = vRotateZ(direction, cameraRotation.z);\n        direction = normalize(direction);\n\n        color += drawScene(origin, direction) / 4.0;\n    }\n#else\n    vec2 p = 2.0 * fragCoord.xy / iResolution.y;\n    p -= vec2(iResolution.x / iResolution.y, 1.0);\n\n    vec3 direction = vec3(p.x, -1.5, p.y);\n    direction = vRotateX(direction, cameraRotation.x);\n    direction = vRotateZ(direction, cameraRotation.z);\n    direction = normalize(direction);\n\n    color += drawScene(origin, direction);\n#endif\n    \n#ifdef DEBUG\n    float debug = (float(debugIterationCount) / float(MAX_DEBUGITERATIONS)) * 3.0;\n    fragColor = vec4(debug, debug - 1.0, debug - 2.0, 1.0);\n    if (fragCoord.y < 1.0)\n    {\n    \tfragColor = texture(iChannel0, vec2(fragCoord.x / iResolution.x, 0.0));\n    }\n    return;\n#endif\n    \n\tcolor = pow(color, vec3(1.0 / 2.2));\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_ACCELERATION      (64.0)\n#define MAX_VELOCITY          (8.0)\n#define FRICTION              (16.0)\n\n#define VALUE_VELOCITY        (0)\n#define VALUE_POSITION        (1)\n#define VALUE_ROTATION        (2)\n#define VALUE_MOUSE           (3)\n\n#ifndef M_PI\n#define M_PI                  (3.1415926535897932384626433832795)\n#endif\n\nvec3 vRotateZ(vec3 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(c*p.x + s*p.y, -s*p.x + c*p.y, p.z);\n}\n\nvec3 getAcceleration()\n{\n    vec3 acc = vec3(0.0, 0.0, 0.0);\n    \n    if (texture(iChannel1, vec2(87.0 / 256.0, 0.0)).x != 0.0)\n    {\n        acc.y += 1.0;\n    }\n    if (texture(iChannel1, vec2(65.0 / 256.0, 0.0)).x != 0.0)\n    {\n        acc.x += 1.0;\n    }\n    if (texture(iChannel1, vec2(83.0 / 256.0, 0.0)).x != 0.0)\n    {\n        acc.y -= 1.0;\n    }\n    if (texture(iChannel1, vec2(68.0 / 256.0, 0.0)).x != 0.0)\n    {\n        acc.x -= 1.0;\n    }\n    if (texture(iChannel1, vec2(32.0 / 256.0, 0.0)).x != 0.0)\n    {\n        acc.z -= 1.0;\n    }\n    if (texture(iChannel1, vec2(16.0 / 256.0, 0.0)).x != 0.0)\n    {\n        acc.z += 1.0;\n    }\n    \n    if (length(acc) > 0.1)\n    {\n        acc = normalize(acc);\n    }\n    \n    return acc;\n}\n\nvec4 getValue(int a)\n{\n    vec2 q = vec2(float(a) + 0.5, 0.0) / iResolution.x;\n    return texture(iChannel0, q);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y >= 1.0)\n    {\n        discard;\n    }\n    \n    vec2 q = vec2(fragCoord.x, 0.0) / iResolution.xy;\n    vec2 bs = fragCoord.xy;\n    int a = int(fragCoord.x);\n    vec4 value = texture(iChannel0, q);\n    \n    if (a == VALUE_ROTATION && iMouse.z > 0.0)\n    {\n        vec4 mouse = 2.0 * abs(iMouse) / iResolution.y;\n        vec4 rot = getValue(VALUE_MOUSE);\n        \n        value.z = mouse.z - mouse.x + rot.z;\n        value.x = mouse.y - mouse.w + rot.x;\n        \n        value.x = clamp(value.x, -M_PI / 2.0, M_PI / 2.0);\n    }\n    else if (a == VALUE_MOUSE && iMouse.z < 0.0)\n    {\n        value = getValue(VALUE_ROTATION);\n    }\n    else if (a == VALUE_VELOCITY)\n    {\n        float rot = getValue(VALUE_ROTATION).z;\n        vec3 acc = getAcceleration();\n        \n        float velocityMag = length(value.xyz);\n        if (velocityMag > FRICTION * iTimeDelta)\n        {\n            value.xyz = normalize(value.xyz) * (velocityMag - FRICTION * iTimeDelta);\n        }\n        else\n        {\n            value.xyz = vec3(0.0, 0.0, 0.0);\n        }\n        \n        acc = vRotateZ(acc, rot);\n        \n        value.xyz += acc * MAX_ACCELERATION * iTimeDelta;\n        \n        velocityMag = length(value.xyz);\n        if (velocityMag > MAX_VELOCITY)\n        {\n            value.xyz = normalize(value.xyz) * MAX_VELOCITY;\n        }\n    }\n    else if (a == VALUE_POSITION)\n    {\n        vec3 velocity = getValue(VALUE_VELOCITY).xyz;\n        \n        value.xyz += velocity * iTimeDelta;\n        \n        value.z = clamp(value.z, -12.0, 3.9);\n    }\n    \n    fragColor = vec4(value);\n    return;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}