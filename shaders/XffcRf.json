{
    "Shader": {
        "info": {
            "date": "1721377329",
            "description": "source https://www.shadertoy.com/view/McXyRj",
            "flags": 0,
            "hasliked": 0,
            "id": "XffcRf",
            "likes": 1,
            "name": "inside galaxy",
            "published": 3,
            "tags": [
                "fractal",
                "galaxy",
                "stars",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 220
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359 // created with love by B4K3D\nmat3 rotateY(float t){float c=cos(t);float s=sin(t);return mat3(vec3(c,0,s),vec3(0,1,0),vec3(-s,0,c));}\nmat3 rotateX(float t){float c=cos(t);float s=sin(t);return mat3(vec3(1,0,0),vec3(0,c,-s),vec3(0,s,c));}\n\n#if HW_PERFORMANCE==0\n#define NEWTON_ITERATIONS 2\n#define NUM_STEPS 8\n#else\n#define NEWTON_ITERATIONS 2\n#define NUM_STEPS 64    \n#endif\n\n#define NUM_PARTICLES 16    \n#define DENSITY 2.0\n#define RADIUS 1.0\n\n#define EXPOSURE 3.5 \n\n// Attribute colormap\nvec3 viridis(float t) {\n    t = clamp(t, 0.0, 1.0);\n    \n    const vec3 c0 = vec3(0.2777273272234177, 0.005407344544966578, 0.3340998053353061);\n    const vec3 c1 = vec3(0.1050930431085774, 1.404613529898575, 1.384590162594685);\n    const vec3 c2 = vec3(-0.3308618287255563, 0.214847559468213, 0.09509516302823659);\n    const vec3 c3 = vec3(-4.634230498983486, -5.799100973351585, -19.33244095627987);\n    const vec3 c4 = vec3(6.228269936347081, 14.17993336680509, 56.69055260068105);\n    const vec3 c5 = vec3(4.776384997670288, -13.74514537774601, -65.35303263337234);\n    const vec3 c6 = vec3(-5.435455855934631, 4.645852612178535, 26.3124352495832);\n\n    vec3 srgb = c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n    return pow(srgb, vec3(2.2));\n}\n\n// Density transfer function\nfloat densityMap(float phi) {\n    if (phi < .5) return 0.0;\n    return clamp((phi - .5)/.5, 0.0, 1.0);\n}\n\n// Evaluates the RBF \"φ^\" (from Eq. 1)\nfloat evaluateRBF(vec3 x, float r, vec3 p, float sigma) {\n    return exp(-.5 * pow((distance(x, p) * sigma) / r, 2.f));\n}\n\n// Tests if a point at the location \"x\" is within range of the query point.\n// Used to determine the piecewise \"φ\" (from Eq. 2.)\nbool inRange(vec3 x, float r, vec3 p) {\n    vec3 d = p - x;\n    if (dot(d,d) < r*r) return true;\n    return false;\n}\n\n// Particle positions, with \"y\" up and data values stored in \"w\" \nvec4 interpolate(vec3 P, in vec4 v[NUM_PARTICLES]) {    \n    // The accumulated density value \"Φ\" (from Eq. 3)\n    float phiSum = 0.0; \n    \n    // The accumulated density-weighted color value, ∑ θ*φ (in Eq. 4)\n    vec3 thetaSum = vec3(0.0); \n        \n    for (int i = 0; i < NUM_PARTICLES; ++i) {\n        float t = float(i) / float(NUM_PARTICLES);\n        float r = RADIUS * (.5 + .5 * t);\n        if (inRange(v[i].xyz, r, P)) {\n            float phi = evaluateRBF(v[i].xyz, r, P, 4.f); //1.0;\n            vec3 theta = viridis(v[i].w);\n            \n            phiSum += phi;\n            thetaSum += theta * phi;\n        }\n    }\n    \n    // If no particles were in range, return a background field value\n    if (phiSum == 0.0) return vec4(0.0);\n\n    // Return weighted average color \"Θ\" (From Eq. 4) in the XYZ and \n    // the transformed density value (explained at end of sec 3.1.3) in W.\n    return vec4(thetaSum / phiSum, densityMap(phiSum));\n}\n\n\n//-----------------------------------------------------------------------------\n// Utils\n//-----------------------------------------------------------------------------\n\nvec4 over(vec4 a, vec4 b) {\n  vec4 result;\n  result.a = a.a + b.a * (1.f - a.a);\n  if (result.a == 0.f)\n    return a; // avoid NaN\n  result.rgb = (a.rgb * a.a + b.rgb * b.a * (1.f - a.a)) / result.a;\n  return result;\n}\n\n#define M_2PI 6.2831853071795865f\n#define M_GRC 0.61803398875f\n\n// Vertex positions for the element\n\n//-----------------------------------------------------------------------------\n// Main functions\n//-----------------------------------------------------------------------------\n\nvec4[NUM_PARTICLES] CreateParticles() {\n    float time = iTime;\n    const float angle_offset = M_2PI / 4.0;\n    float speed = 0.2;\n    float dist = .3 + .6 * pow(sin(time * speed * 2.0), 2.0);\n    \n    vec4[NUM_PARTICLES] particles;\n\n    // Borrowed from here : https://www.shadertoy.com/view/MssXDn\n    for(int i=0;i<NUM_PARTICLES;i++)\n\t{\n\t\tfloat t=float(i)/float(NUM_PARTICLES);\n\t\tfloat a=t*M_2PI+iTime*speed;\n\n\t\tvec3 pos=vec3(sin(a)+2.0*sin(2.0*a),cos(a)-2.0*cos(2.0*a),-sin(3.0*a));//*0.01;\n\n\t\tfloat a1=speed*iTime;\n\t\tpos.yz*=mat2(cos(a1),-sin(a1),sin(a1),cos(a1));\n        pos *= dist * .5;\n        \n        //float a2=0.1;\n\t\t//pos.yz*=mat2(cos(a2),-sin(a2),sin(a2),cos(a2))* 2.0;\n        \n        particles[i].xyz = pos;\n        particles[i].w = .5 + .5 * cos(t * M_2PI); //cos(time * .05);\n    }\n    \n    return particles;\n        \n}\n\nvec3 palette(float t){vec3 a=vec3(0.5),b=vec3(0.5),c=vec3(1.0),d=vec3(0.263,0.416,0.557);return a+b*cos(6.28318*(c*t+d));}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{vec2 uv=(fragCoord-0.5*iResolution.xy)/iResolution.y;\nvec3 ro=vec3(0,0,-3);vec3 rd=normalize(vec3(uv,1));\nfloat time=iTime*0.1;mat3 rot=rotateY(time)*rotateX(time*0.7);\nfloat t=0.0,d=0.0;vec3 p;\nfor(int i=0;i<150;i++)\n{p=ro+rd*t;\np=rot*p;\nd=(p,p,0.2);\nif(abs(d)<0.001||t>10.0)break;\nt+=d*0.5;}vec3 col=vec3(0.0);\nif(t<20.0){float thickness=0.02;\nvec3 normal;\n\nfloat angle=atan(p.z,p.x);\nfloat wire1=abs(fract(angle*15.0/PI+iTime*0.0)-0.5);\nfloat wire2=abs(fract(atan(length(p.xz)-0.8,p.y)*30.0/PI+iTime*0.0)-0.5);\nfloat wire=min(wire1,wire2);\nif(wire<thickness){float colorTime=iTime*0.1;\nvec3 baseColor=palette(length(p)*0.2+colorTime);float fresnel=pow(1.0-abs(dot(normal,rd)),3.0);\ncol=mix(baseColor,vec3(1.0),fresnel);\nfloat sparkle=fract(sin(dot(p,vec3(12.9898,78.233,45.164)))*43758.5453);\ncol+=vec3(1.0,1.0,0.8)*step(0.99,sparkle)*3.0;}else{float glow=exp(-wire*10.0);\ncol=palette(length(p)*1.1+iTime*0.05)*glow*1.2;}}vec3 bgCol=vec3(0.02);\nfloat stars=step(0.950,fract(sin(dot(uv,vec2(12.9898,78.233)))*43758.5453));\nbgCol+=vec3(stars)*1.3;\ncol=mix(bgCol,col,smoothstep(0.0,0.01,col));\ncol+=pow(col,vec3(2.0))*0.4;\nfragColor=vec4(col+bgCol,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}