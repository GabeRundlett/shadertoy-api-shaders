{
    "Shader": {
        "info": {
            "date": "1591051302",
            "description": "Mouse enabled",
            "flags": 32,
            "hasliked": 0,
            "id": "WsBfWt",
            "likes": 91,
            "name": "Crystal Tetrahedron",
            "published": 3,
            "tags": [
                "refraction",
                "dispersion",
                "bluenoise",
                "polyhedra"
            ],
            "usePreview": 1,
            "username": "tdhooper",
            "viewed": 1804
        },
        "renderpass": [
            {
                "code": "/*\n\n    Crystal Tetrahedron\n    -------------------\n\n    Brute force dispersion with a fractal zoom.\n\n    The colours come from performing the whole render multiple times,\n    each with a different refractive index and colour tint, then\n    combining the results. With so few iterations this usually results\n    in a lot of banding, but the addition of some animated blue noise\n    gives an acceptable result with just 2 samples.\n\n    If it's running slow, drop MAX_DISPERSE in Buffer A to 2.\n\tIt looks really pretty with 30 bounces and 10 dispersion samples.\n\n\tGetting good camera and lighting angles was tricky, so there are a\n\tbunch of hardcoded matrices and rotations from my tool. \n\n\tCheck out the high quality capture on my Instagram\n\t* https://www.instagram.com/p/CA09i10HgDN/\n\n\tInspired by a couple of things:\n\t* The shading in this GIF by Tatsuya M https://twitter.com/TatsuyaBot/status/1208415211360665607\n\t* This animation by ayquo https://www.shadertoy.com/view/3d2BRW\n\n*/\n\n\n// http://tuxedolabs.blogspot.com/2018/05/bokeh-depth-of-field-in-single-pass.html\n\nvec2 uPixelSize; //The size of a pixel: vec2(1.0/width, 1.0/height)\nfloat uFar = 1.; // Far plane\n\nconst float GOLDEN_ANGLE = 2.39996323;\nconst float MAX_BLUR_SIZE = 10.;\nconst float RAD_SCALE = 1.; // Smaller = nicer blur, larger = faster\n\nfloat getBlurSize(float depth, float focusPoint, float focusScale) {\n    float coc = clamp((1.0 / focusPoint - 1.0 / depth)*focusScale, -1.0, 1.0);\n    return abs(coc) * MAX_BLUR_SIZE;\n}\n\nvec3 depthOfField(vec2 texCoord, float focusPoint, float focusScale) {\n    vec4 centerTex = texture(iChannel0, texCoord);\n    float centerDepth = centerTex.a * uFar;\n    float centerSize = getBlurSize(centerDepth, focusPoint, focusScale);\n    vec3 color = centerTex.rgb;\n    \n    #ifdef DISABLE_DOF\n    \treturn color;\n    #endif\n\n    float tot = 1.0;\n\n    float radius = RAD_SCALE;\n    for (float ang = 0.; ang < 10000.; ang += GOLDEN_ANGLE) {\n        if (radius >= MAX_BLUR_SIZE) break;\n\n        vec2 tc = texCoord + vec2(cos(ang), sin(ang)) * uPixelSize * radius;\n        vec4 sampleTex = texture(iChannel0, tc);\n        vec3 sampleColor = sampleTex.rgb;\n        float sampleDepth = sampleTex.a * uFar;\n        float sampleSize = getBlurSize(sampleDepth, focusPoint, focusScale);\n        //if (sampleSize < centerSize) break;\n        if (sampleDepth > centerDepth) {\n            sampleSize = clamp(sampleSize, 0.0, centerSize*2.0);\n        }\n        float m = smoothstep(radius-0.5, radius+0.5, sampleSize);\n        color += mix(color/tot, sampleColor, m);\n        tot += 1.0;\n        radius += RAD_SCALE/radius;\n        \n        // modification: exit early when we're in focus\n       // if (centerDepth < uFar / 3. && m == 0.) break;\n    }\n    return color /= tot;\n}\n\n\n// http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 tonemap2(vec3 texColor) {\n    texColor /= 2.;\n   \ttexColor *= 16.;  // Hardcoded Exposure Adjustment\n   \tvec3 x = max(vec3(0),texColor-0.004);\n   \treturn (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uPixelSize = vec2(.002) / (iResolution.xy / iResolution.y);\n\n    //fragColor = vec4(texture2D(iChannel0, uv).aaa, 1.); return;\n    \n    vec3 col = depthOfField(uv, .65, 1.);\n\n    col = pow(col, vec3(1.25)) * 2.5;\n    col = tonemap2(col);\n\n    fragColor = vec4(col, 1);    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n//#define DARK_MODE\n\nconst float MAX_DISPERSE = 5.;\nconst float MAX_BOUNCE = 10.;\n\nmat4 cameraMatrix = mat4(\n    0.9780874848365784,\n    -0.07870610803365707,\n    -0.19274398684501648,\n    0,\n    0.20812205970287323,\n    0.3452317416667938,\n    0.9151507019996643,\n    0,\n    -0.005486522801220417,\n    -0.935211718082428,\n    0.35404732823371887,\n    0,\n    -4.901630745735019e-7,\n    0.00000874467059475137,\n    -9.502106666564941,\n    1\n);\n\n\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n//--------------------------------------------------------\n\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n#define saturate(x) clamp(x, 0., 1.)\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smax(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat fBox(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\nfloat range(float vmin, float vmax, float value) {\n  return clamp((value - vmin) / (vmax - vmin), 0., 1.);\n}\n\nmat4 rotX(float a) {\n    return mat4(1,0,0,0, 0,cos(a),-sin(a),0, 0,sin(a),cos(a),0, 0,0,0,1);\n}\n\nmat4 rotZ(float a) {\n    return mat4(cos(a),-sin(a),0,0, sin(a),cos(a),0,0, 0,0,1,0, 0,0,0,1);\n}\n\n// Spectrum palette\n// IQ https://www.shadertoy.com/view/ll2GD3\n//--------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n// Polyhedra\n// Knighty https://www.shadertoy.com/view/MsKGzw\n//--------------------------------------------------------\n\nint Type=3;\n\nvec3 nc,pab,pbc,pca;\nvoid initPoly() {//setup folding planes and vertex\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n\tnc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n\tpab=vec3(0.,0.,1.);\n\tpbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n\tpca=vec3(0.,scospin,cospin);\n\tpbc=normalize(pbc);\tpca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :) \n}\n\nvec3 fold(vec3 pos) {\n\tfor(int i=0;i<3 /*Type*/;i++){\n\t\tpos.xy=abs(pos.xy);//fold about xz and yz planes\n\t\tpos-=2.*min(0.,dot(pos,nc))*nc;//fold about nc plane\n\t}\n\treturn pos;\n}\n\n\n//========================================================\n// Modelling\n//========================================================\n\nfloat time;\n\nfloat tweenOffset(float t, float start, float duration) {\n    t = range(start, start + duration, t);\n    t = pow(t, 2.);\n    return t;\n}\n\nfloat tweenBlend(float t, float start, float duration) {\n    t = range(start, start + duration, t);\n    t = pow(t, .5);\n    t = smoothstep(0., 1., t);\n    return t;\n}\n\nconst float STEP_SCALE = 1./3.;\n\nfloat tetAnim(vec3 p, float time) {\n    \n    p = fold(p);\n\n    // config\n    float sz = .3;\n    float rBase = .04;\n    float rInner = rBase * STEP_SCALE;\n    float blendDuration = .75;\n    float offsetDuration = .75;\n    float t = time * (blendDuration + offsetDuration);\n    offsetDuration *= 2.; // extend animation beyond loop section\n    float offsetDistance = .6;\n\n    // animation\n    float blend = tweenBlend(t, .0, blendDuration);\n    float offsetT = tweenOffset(t, blendDuration, offsetDuration);\n    float offset = offsetT * offsetDistance;\n\n    // skip if animation hasn't started or is complete\n    if (t < 0. || offsetT >= 1.) {\n        return 1e12;\n    }\n\n    // tetrahedron planes\n    vec3 n1 = pca;\n    vec3 n2 = normalize(pca * vec3(-1,-1,1));\n    vec3 n3 = normalize(pbc * vec3(1,-1,-1));\n    vec3 n4 = normalize(pbc * vec3(-1,-1,-1));\n\n    float sep = .001 * (1. - offsetT);\n    float scale = 1. - offsetT;\n    \n    float bound = (dot((p + (n4 + n3) * offset) / scale, n1) - sz) * scale;\n    if (bound > .004) {\n        return bound;\n    }\n\n    vec3 pp = p;\n    \n    // octahedrons\n    p = pp + n4 * offset;\n    p /= scale;\n    float oct = dot(p, n1) - sz;\n    oct = smax(oct, (dot(p, n2) - sz), rBase);\n    oct = smax(oct, -(dot(p, n4) + .5 - sep), rInner);\n    oct = smax(oct, -(dot(p, n3) + .1 - sep), rInner);\n    oct = smax(oct, (dot(p, n4) + .1 + sep), rInner);\n    oct *= scale;\n\n    // shared edge\n\tp = pp + (n4 + n3) * offset;\n    p /= scale;\n    float edge = dot(p, n1) - sz;\n    edge = smax(edge, (dot(p, n2) - sz), rBase);    \n    \n    // side tets\n    p = pp + (n4 + n3) * offset;\n    p /= scale;\n    float side = edge;\n    side = smax(side, (dot(p, n3) + .1 + sep), rInner);\n    side = smax(side, (dot(p, n4) + .1 + sep), rInner);\n    side *= scale;\n\n    // vertex tets\n    p = pp + n4 * (offset + offset);\n    p /= scale;\n    float vert = edge; vert = smax(vert, (dot(p, n3) - sz), rBase);\n    vert = smax(vert, (dot(p, n4) + .5 + sep), rInner);\n    vert *= scale;\n\n    float sliced = 1e12;\n    sliced = min(sliced, oct);\n    sliced = min(sliced, vert);\n    sliced = min(sliced, side);\n\n    // inner tet gets replaced with the next iteration\n    if (time < 1.) {\n        p = pp;\n        float inner = -(dot(p, n4) + .1 - sep);\n        inner = smax(inner, -(dot(p, n3) + .1 - sep), rInner);\n        inner = smax(inner, -(dot(p, n2) + .1 - sep), rInner);\n        sliced = min(sliced, inner);\n    }\n\n    if (blend >= 1.) {\n        return sliced;\n    }\n\n    // base tet\n    float base = dot(p, n1) - sz;\n    base = smax(base, (dot(p, n2) - sz), rBase);\n    base = smax(base, (dot(p, n3) - sz), rBase);\n\n    float surface = 1. - saturate(-base / sz); // 1 at surface, 0 at center\n    \n    // blend indentations into the surface\n    float surfaceBlend = saturate(blend * .66 * range(.9, 1., surface));\n    base = mix(base, sliced, surfaceBlend);\n    \n    // grow the sliced tet from the center of the unsliced tet\n    float slicedS = min(sliced, -base - (.3 - .3 * blend));\n    float d = max(base, slicedS);\n    d = mix(d, sliced, smoothstep(.9, 1., blend));\n\n    return d;\n}\n\nfloat tetLoop(vec3 p) {\n    pR(p.xy, PI/2. * -time + PI/2.);\n\n    float t = time;\n    float scale = pow(STEP_SCALE, t);\n    float d = tetAnim(p * scale, time) / scale;\n\n    scale *= STEP_SCALE;\n    pR(p.xy, PI/2. * -1.);\n    d = min(d, tetAnim(p * scale, time + 1.) / scale);\n\n    return d;\n}\n\nvec2 map(vec3 p) {\n    float d = tetLoop(p);\n    return vec2(d, 1.);\n}\n\n\n//========================================================\n// Lighting\n//========================================================\n\nfloat intersectPlane(vec3 rOrigin, vec3 rayDir, vec3 origin, vec3 normal, vec3 up, out vec2 uv) {\n    float d = dot(normal, (origin - rOrigin)) / dot(rayDir, normal);\n  \tvec3 point = rOrigin + d * rayDir;\n\tvec3 tangent = cross(normal, up);\n\tvec3 bitangent = cross(normal, tangent);\n    point -= origin;\n    uv = vec2(dot(tangent, point), dot(bitangent, point));\n    return max(sign(d), 0.);\n}\n\nmat3 envOrientation;\n\nvec3 light(vec3 origin, vec3 rayDir) {\n    origin = -(cameraMatrix * vec4(origin, 1)).xyz;\n    rayDir = -(cameraMatrix * vec4(rayDir, 0)).xyz;\n\n    origin *= envOrientation;\n    rayDir *= envOrientation;\n\n    vec2 uv;\n    float hit = intersectPlane(origin, rayDir, vec3(5,-2,-8), normalize(vec3(1,-.5,-.1)), normalize(vec3(0,1,0)), uv);\n    float l = smoothstep(.75, .0, fBox(uv, vec2(.4,1.2) * 6.));\n\treturn vec3(l) * hit;\n}\n\nvec3 env(vec3 origin, vec3 rayDir) {    \n    origin = -(cameraMatrix * vec4(origin, 1)).xyz;\n    rayDir = -(cameraMatrix * vec4(rayDir, 0)).xyz;\n\n    origin *= envOrientation;\n    rayDir *= envOrientation;\n\n    float l = smoothstep(.0, 1.7, dot(rayDir, vec3(.5,-.3,1))) * .4;\n   \treturn vec3(l) * vec3(1,1,1);\n}\n\n\n\n//========================================================\n// Marching\n//========================================================\n\n#define ZERO (min(iFrame,0))\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal( in vec3 pos )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e).x;\n    }\n    return normalize(n);\n}\n\nstruct Hit {\n    vec2 res;\n    vec3 p;\n    float len;\n    float steps;\n};\n\nHit march(vec3 origin, vec3 rayDir, float invert, float maxDist, float understep) {\n    vec3 p;\n    float len = 0.;\n    float dist = 0.;\n    vec2 res = vec2(0.);\n    vec2 candidate = vec2(0.);\n    float steps = 0.;\n\n    for (float i = 0.; i < 100.; i++) {\n        len += dist * understep;\n        p = origin + len * rayDir;\n        candidate = map(p);\n        dist = candidate.x * invert;\n        steps += 1.;\n        if (dist < .001) {\n            res = candidate;\n            break;\n        }\n        if (len >= maxDist) {\n            len = maxDist;\n            break;\n        }\n    }   \n\n    return Hit(res, p, len, steps);\n}\n\nmat3 sphericalMatrix(vec2 tp) {\n    float theta = tp.x;\n    float phi = tp.y;\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initPoly();\n\n    time = iTime / 2.;\n    //time = 0.5;\n    //time = 0.1;\n    //time = 1.;\n    time = fract(time + .4);\n    \n    #ifndef DARK_MODE\n        envOrientation = sphericalMatrix(((vec2(81.5, 119) / vec2(187)) * 2. - 1.) * 2.);\n    #else\n        envOrientation = sphericalMatrix((vec2(0.7299465240641712,0.3048128342245989) * 2. - 1.) * 2.);\n    #endif\n\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    Hit hit, firstHit;\n    vec2 res;\n    vec3 p, rayDir, origin, sam, ref, raf, nor, camOrigin, camDir;\n    float invert, ior, offset, extinctionDist, maxDist, firstLen, bounceCount, wavelength;\n    \n    vec3 col = vec3(0);\n    float focal = 3.8;\n    bool refracted;\n\n    vec3 bgCol = vec3(.22);\n\n    invert = 1.;\n    maxDist = 15.; \n    \n    if (iMouse.z > 0.) {\n        cameraMatrix *= rotX(((iMouse.y / iResolution.y) * 2. - 1.) * 2.);\n\t    cameraMatrix *= rotZ(((iMouse.x / iResolution.x) * 2. - 1.) * 2.);\n    }    \n\n\tcamOrigin = -(cameraMatrix[3].xyz) * mat3(cameraMatrix);\n   \tcamDir = normalize(vec3(uv * .168, -1.) * mat3(cameraMatrix));\n\n\n    firstHit = march(camOrigin, camDir, invert, maxDist, .9);\n    firstLen = firstHit.len;\n\n    float steps = 0.;\n    \n    for (float disperse = 0.; disperse < MAX_DISPERSE; disperse++) {\n        invert = 1.;\n    \tsam = vec3(0);\n\n        origin = camOrigin;\n        rayDir = camDir;\n\n        extinctionDist = 0.;\n        wavelength = disperse / MAX_DISPERSE;\n   \t\tfloat rand = texture(iChannel0, fragCoord.xy / iChannelResolution[0].xy).r;\n        rand = fract(rand + float(iFrame) * 1.61803398875);\n\n        wavelength += (rand * 2. - 1.) * (.5 / MAX_DISPERSE);\n        \n\t\tbounceCount = 0.;\n\n        for (float bounce = 0.; bounce < MAX_BOUNCE; bounce++) {\n\n            if (bounce == 0.) {\n                hit = firstHit;\n            } else {\n                hit = march(origin, rayDir, invert, maxDist / 2., 1.);\n            }\n            \n            steps += hit.steps;\n            \n            res = hit.res;\n            p = hit.p;\n            \n            if (invert < 0.) {\n\t            extinctionDist += hit.len;\n            }\n\n            // hit background\n            if ( res.y == 0.) {\n                break;\n            }\n\n            vec3 nor = normal(p) * invert;            \n            ref = reflect(rayDir, nor);\n            \n            // shade\n            sam += light(p, ref) * .5;\n            sam += pow(1. - abs(dot(rayDir, nor)), 5.) * .1;\n            sam *= vec3(.85,.85,.98);\n\n            // refract\n            float ior = mix(1.3, 1.6, wavelength);\n            ior = invert < 0. ? ior : 1. / ior;\n            raf = refract(rayDir, nor, ior);\n            bool tif = raf == vec3(0); // total internal reflection\n            rayDir = tif ? ref : raf;\n            offset = .01 / abs(dot(rayDir, nor));\n            origin = p + offset * rayDir;\n            //invert = tif ? invert : invert * -1.;\n            invert *= -1.; // not correct but gives more interesting results\n\n            bounceCount = bounce;\n        }\n\n        #ifndef DARK_MODE\n            sam += bounceCount == 0. ? bgCol : env(p, rayDir);\t\n        #endif\n\n        if (bounceCount == 0.) {\n            // didn't bounce, so don't bother calculating dispersion\n            col += sam * MAX_DISPERSE / 2.;\n            break;\n        } else {\n            vec3 extinction = vec3(.3,.3,1.) * .5;\n            extinction = 1. / (1. + (extinction * extinctionDist));\t\n            col += sam * extinction * spectrum(-wavelength+.2);\n        }\n\t}\n    \n    // debug\n \t//fragColor = vec4(spectrum(steps / 2000.), 1); return;\n    //fragColor = vec4(vec3(bounceCount / MAX_BOUNCE), 1); return;\n    //fragColor = vec4(vec3(firstHit.steps / 100.), 1); return;\n\n    col /= MAX_DISPERSE;\n        \n    fragColor = vec4(col, range(4., 12., firstLen));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}