{
    "Shader": {
        "info": {
            "date": "1576700436",
            "description": "Remix of my [url=https://www.shadertoy.com/view/wtd3D4]Christmas Tree Star[/url] shader. Added temporal anti-aliasing, bokeh-filtered depth of field, and fairy lights.",
            "flags": 32,
            "hasliked": 0,
            "id": "Wt33zS",
            "likes": 17,
            "name": "Christmas Tree Star Post Process",
            "published": 3,
            "tags": [
                "raymarching",
                "christmas",
                "cubemap",
                "tree",
                "shiny",
                "snow",
                "xmas",
                "festive",
                "realistic",
                "holiday"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 1257
        },
        "renderpass": [
            {
                "code": "#define FOCAL_BLUR\n\nconst float maxBokeh = .025;\nconst int numSamples = 200;\nconst float fieldDepth = 1.; // narrower = more severe blur\n\nfloat BokehSize( float depth )\n{\n    return .03*abs(depth/fieldDepth);\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{    \n    fragColour = texelFetch(iChannel0,ivec2(fragCoord),0);\n\n#ifdef FOCAL_BLUR    \n    float depth = fragColour.a;\n    float pointBokeh = BokehSize(depth);\n\n    // crude bokeh blur\n    // closer bokehs should bleed over more distant\n    // further ones don't have enough samples, so fake it with a weighted average\n    // closer ones don't become see through when small points blur - not much I can do about that\n    fragColour.a = 1.;\n    for ( int i=0; i < numSamples; i++ )\n    {\n        float f = float(i+1);\n        float a = tau*phi*f;\n        float r = sqrt(f/float(numSamples)) * maxBokeh;\n        vec2 p = vec2(cos(a),sin(a))*r;\n        \n        vec4 tap = textureLod(iChannel0,(fragCoord/iResolution.y + p)*iResolution.y/iResolution.xy,.0);\n    \tfloat tapBokeh = BokehSize(tap.a);\n        \n        if ( depth > tap.a && r < tapBokeh )\n        {\n            float weight = .3;\n            fragColour.rgb += weight*tap.rgb;\n            fragColour.a += weight;\n        }\n\n        if ( r < pointBokeh )\n        {\n            float weight = smoothstep( -2., 0., tap.a-depth );\n            fragColour.rgb += tap.rgb*weight;\n            fragColour.a += weight;\n        }\n    }\n    fragColour /= fragColour.a;\n#endif\n    \n    fragColour.rgb = HDRtoLDR( fragColour.rgb );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float tau = 6.28318530718;\nconst float phi = 1.61803398875;\n\nconst float whiteSoftness = 0.2; // this mostly affects the diffuse light - rewind to recompute it!\n\nvec3 HDRtoLDR( vec3 col )\n{\n    // soft clamp to white (oh this is so good)\n    float w2 = whiteSoftness*whiteSoftness;\n    col += w2;\n    col = (1.-col)*.5;\n    col = 1. - (sqrt(col*col+w2) + col);\n    \n    // linear to sRGB (approx)\n    col = pow( col, vec3(1./2.2) );\n\n    return col;\n}\n\nvec3 LDRtoHDR( vec3 col )\n{\n    // sRGB to linear (approx)\n    col = pow( col, vec3(2.2) );\n    \n    col = clamp(col,0.,.99);\n    \n    float w2 = whiteSoftness*whiteSoftness;\n    col = (w2 - col*col + 2.*col - 1.)/(2.*(col - 1.)); // inverted by wolfram\n    col = 1.-col*2.;\n    col -= w2;\n    \n    return col;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Make a diffuse convolution of the LDRtoHDR of the cube map\n// This is not an efficient approach - it's based on code I use for Monte Carlo rendering - but it converges to the right solution pretty quickly\n\n// quasi random numbers from: http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nconst uvec2 quasi2 = uvec2(3242174889u,2447445413u);\n\n// input rand = 2 floats in range [0,1)\nvec3 SphereRand( vec2 rand )\n{\n    float sina = rand.x*2. - 1.;\n    float b = 6.283*rand.y;\n    float cosa = sqrt(1.-sina*sina);\n    return vec3(cosa*cos(b),sina,cosa*sin(b));\n}\n\nvec3 PowRand( vec2 rand, vec3 axis, float fpow )\n{\n    vec3 r = SphereRand(rand);\n    \n    // redistribute samples\n    float d = dot(r,axis);\n\n    // map sphere to cylinder\n    r -= d*axis;\n    r = normalize(r); // hahaha! I'd forgotten this, very clever\n\n    // project onto a spike\n    // h = pow(1.-radius,m)*2-1\n    // radius = 1.-pow(h*.5+.5,1/m)\n    // ^ WRONG! That's radius squared, otherwise POW=1 gives a spike\n    float h = d*.5+.5;\n    //        r *= sqrt(1.-pow(h,1./POW));\n    // ^ wrong again! Need to solve the integral with that sqrt in,\n    // and needed a factor of /radius for sample density\n    r *= sqrt( 1. - pow( h, 2./(fpow+1.) ) ); // YES!!!!\n\n    // and down onto the hemisphere\n    r += axis*sqrt(1.-dot(r,r));\n\n    return r;\n}\n\nvec3 HemisphereRand( vec3 axis, uint seed )\n{\n    return PowRand( vec2(quasi2*seed)/exp2(32.), axis, 1. );\n}\n\nvoid mainCubemap( out vec4 fragColour, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    fragColour = textureLod( iChannel0, rayDir, 0. ); // this needs NEAREST filter on the texture\n\tif ( iFrame == 0 ) fragColour = vec4(0);\n\n    // wait for texture to load (I know the top of the cubemap should not be black)\n    if ( textureLod( iChannel1, vec3(0,1,0), 0. ).r == 0. ) return;\n    \n    // early-out once we've got a good enough result\n    if ( fragColour.a > 16.*60.*3. ) return;\n    \n    const int n = 16;\n    for ( int i = 0; i < n; i++ )\n    {\n        vec3 ray = HemisphereRand(rayDir,uint(i+n*iFrame));\n\n        fragColour.rgb += LDRtoHDR(textureLod( iChannel1, ray, 0. ).rgb);\n        fragColour.a += 1.;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "// Fork of \"Christmas Tree Star\" by TekF. https://shadertoy.com/view/wtd3D4\n// 2019-12-17 21:26:15\n\n// Christmas Tree Star\n// by Hazel Quantock 2019\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\n\n// adjust this to improve frame rate in windowed mode\n#define AA_QUALITY .3\n\n// allow a little bleed between pixels - I think this looks more photographic, but blurrier\n#define AA_ROUND true\n#define AA_ROUND_RADIUS 0.7071\n\n\n// very silly effect, but it kinda shows some of how the branch and bauble placement works\n//#define PATTERN_SCROLL vec3(0,.3,0)\n#define PATTERN_SCROLL vec3(0)\n\n// uncomment this to fill space with christmas tree stars!\n//#define CLONES 1\n\n\n//--\n\n// hashes from https://www.shadertoy.com/view/4dVBzz\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 exp2(-32.)\n//(1.0/float(0xffffffffU))\n\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) (p*M1)\n#define coord2(p) (p.x*M1^p.y*M2)\n#define coord3(p) (p.x*M1^p.y*M2^p.z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n\n\nfloat TreeBoundsSDF( vec3 pos )\n{\n    // just a cone\n    float r = length(pos.xz);\n    return max(//max(\n        dot( vec2(pos.y-7.,r), normalize(vec2(.3,1)) ),\n        //pos.y-7.), // something goes wrong with the cone SDF?\n        -pos.y+1.8+r*.6\n        );\n}\n\n\n/*\nWarp space into a series of repeated cells (\"branches\") around the y axis\nThis causes some distortion, causing marching errors near the axis when branches are\nparticularly sparse. But this can be worked round by tweaking the SDF.\n\nCells are mirrored so whatever's placed in them will tile with itself!\n\nyByOutStep - tilts branches along the axis, but breaks vertical tiling.\n*/\nvec3 HelixGrid( out ivec2 grid, vec3 pos, int numSpokes, float yStepPerRotation, float yByOutStep )\n{\n    // convert to polar coordinates\n    vec3 p = vec3(atan(pos.x,pos.z),pos.y,length(pos.xz));\n\n    p.y -= yByOutStep*p.z;\n    float l = sqrt(1.+yByOutStep*yByOutStep);\n    \n    // draw a grid of needles\n    vec2 scale = vec2(6.283185/float(numSpokes),yStepPerRotation);\n    p.xy /= scale;\n    \n    // rotate and skew the grid to get a spiral with nice irrational period\n    float sn = 1./float(numSpokes); // so we step by an integer number of rows\n\n    p.xy += p.yx*vec2(-1,1)*sn;\n    \n    // make horizontal triangle-waved, so edges of cells match up no matter what's put inside them!\n    grid = ivec2(floor(p.xy));\n    vec2 pair = fract((p.xy + 1.)*.5)*2.-1.;\n    p.xy = (abs(pair)-.5);\n    vec2 flip = step(0.,pair)*2.-1.; // sign() but without a 0.\n    p.xy *= scale;\n\n    // unshear...\n    p.y += flip.y*yByOutStep*p.z;\n    \n    // reconstruct a non-bent space\n    p.xz = p.z*vec2(sin(p.x),cos(p.x));\n\n    // ...and apply rotation to match the shear (now we've sorted out the grid stuff)\n    p.yz = ( p.yz + flip.yy*p.zy*vec2(-1,1)*yByOutStep )/l; // dammit - I think it breaks the wrap\n    \n// might be worth returning a bound on y to mask the discontinuous area\n// I think it will just be yByAngleStep/sqrt(1.+yByOutStep*yByOutStep) which caller can do if desired\n// Or, could make z NOT start at 0 - so caller has to bound using parent-level's length (totally viable and I'm doing it a lot)\n// so mirroring WOULD line up!\n    \n    return p;\n}\n\n\n\nstruct TreeSpace\n{\n    vec3 branch;\n    vec3 twig;\n    vec3 needle;\n    ivec2 branchGrid;\n    ivec2 twigGrid;\n    ivec2 needleGrid;\n};\n\n\nTreeSpace GetTreeSpace( in vec3 pos )\n{\n    TreeSpace o;\n    o.branch = HelixGrid( o.branchGrid, pos, 12, .5, .5 ); //.5\n    o.twig = HelixGrid( o.twigGrid, o.branch.xzy, 5, .5, 1. );\n    o.needle = HelixGrid( o.needleGrid, o.twig.xzy, 9, .04, 1. );\n    \n    return o;\n}\n\n\nfloat TreeSDF( vec3 pos )\n{\n    float bounds = TreeBoundsSDF(pos);\n    \n    if ( bounds > 1. ) return bounds-.0;\n    \n    pos += PATTERN_SCROLL*iTime;\n\tTreeSpace ts = GetTreeSpace(pos);\n\n\tfloat branchRand = hash1(coord2(uvec2(ts.branchGrid+0x10000)));\n    float branchEndLength = .3*(branchRand-.5);\n    \n    return\n        min(\n            max(\n                min(\n                    min(\n                        // twig\n                        length(ts.twig.xy)-.005,\n                        // needle\n                        length( vec3( ts.needle.xy, max(0.,ts.needle.z-.05) ) ) - .003\n                    ),\n                    // branch\n                    max(\n                    \t(length(ts.branch.xy\n                               + .004*sin(vec2(0,6.283/4.)+ts.branch.z*6.283/.1) // spiral wobble\n                              )-.01)*.9,\n                    \tbounds - branchEndLength - .2 // trim branches shorter than twigs\n                    )\n            \t),\n            \t// branch length (with rounded tip to clip twigs nicely)\n                length( vec3(ts.branch.xy,max(0.,bounds\n                                              -branchEndLength  // this seems to cause more floating twigs (or more obvious ones)\n                                             )) )-.3\n            ),\n            max(\n                // trunk\n                length(pos.xz)-.03,\n                bounds  // this will give a sharp point - better to just chop it - but might not show it\n            )\n        )*.7; // the helical distortion bends the SDF, so gradient can get higher than 1:1\n}\n\n\n// baubles only spawn in negative areas of this mask\nfloat BaubleBoundsSDF( vec3 pos, float depth )\n{\n    return abs(TreeBoundsSDF(pos)+depth)-.3; // half the width of the area bauble centres can be placed in\n}\n\n\n// pass different seeds and densities to generate different sets of baubles\n// if spacing = radius*2. the baubles will lie on a grid touching each other\nfloat BaublesSDF( vec3 pos, uint seed, float spacing, float radius, float power, float twist, float depth )\n{\n    // avoid looping over every bauble - find closest one from a handful of candidates, using a jittered grid\n    float f = BaubleBoundsSDF(pos,depth);\n    f -= radius;\n    \n    float margin = .1; // distance at which to start computing bauble SDFs - affects speed of marching (trial and error suggests .1 is fairly optimal)\n    if ( f > margin ) return f;\n    \n\tvec3 offset = spacing*(hash3(coord1(seed))-.5); // use a different grid for each set of baubles\n    offset += PATTERN_SCROLL*iTime;\n\tpos += offset;\n\n    // find closest centre point\n    vec3 c = floor(pos/spacing);\n    ivec3 ic = ivec3(c);\n    c = (c+.5)*spacing; // centre of the grid square\n    \n    c += (spacing*.5 - radius /*- margin*/) * ( hash1(coord3(uvec3(ic+63356))^seed)*2. - 1. );\n    \n    // cull it if it's outside bounds\n    if ( BaubleBoundsSDF(c-offset,depth) > 0. ) return margin; // could do max (margin, distance to grid cell edge)\n    \n//    float f = length(pos-c)-radius;\n    vec3 v = pos-c;\n    v.xz = v.xz*cos(v.y*twist) + v.zx*vec2(1,-1)*sin(v.y*twist);\n    v = abs(v)/radius;\n    f = (pow(dot(v,pow(v,vec3(power-1.))),1./power)-1.)*radius;\n    return min( f, margin ); // don't return values > margin otherwise we'll overshoot in next cell!\n}\n\nfloat Baubles1( vec3 pos ) { return BaublesSDF( pos, 0x1002U, .3, .014, 1., -150., 0.4 )*.8; }\nfloat Baubles2( vec3 pos ) { return BaublesSDF( pos, 0x2037U, 1., .08, 1.2, -45., 0. ); }\nfloat Baubles3( vec3 pos ) { return BaublesSDF( pos, 0x3003U, .8, .08, 1.8, 50., 0. ); }\n\n\nfloat Ground( vec3 pos )\n{\n    return length(pos-vec3(0,-2,0))-2.-1.7 + .003*textureLod(iChannel2,pos.xz*5.,.0).x - .04*textureLod(iChannel2,pos.xz*.4,.0).x;\n}\n\n\nvec3 FoldSpace( vec3 pos )\n{\n#ifdef CLONES\n    pos = (abs(fract(pos/40.+.25)-.5)-.25)*40.; // tile space\n#endif\n    \n    // mirror space in an octahedron, tilted so one face points up\n    vec3 k = vec3(0,sqrt(1./3.),sqrt(2./3.));\n    vec3 i = vec3(k.z*sqrt(3./4.),k.y,-k.z*sqrt(1./4.)); //rotate 120 about y\n    vec3 j = i*vec3(-1,1,1);\n    \n    // mirror on each axis\n    pos = pos + i*max(0.,-dot(i,pos)*2.);\n    pos = pos + j*max(0.,-dot(j,pos)*2.);\n    pos = pos + k*max(0.,-dot(k,pos)*2.);\n\n//    pos += sin(iTime*8.*vec3(.11,.13,.102))*vec3(1,0,1);\n\n    return pos;\n}\n\nfloat SDF( vec3 pos )\n{\n\tpos = FoldSpace(pos);\n    \n    return min(min(min(min(\n        \tTreeSDF(pos),\n        \tBaubles1(pos)),\n        \tBaubles2(pos)),\n        \tBaubles3(pos)),\n        \tGround(pos));\n}\n\n\n// assign a material index to each of the SDFs\n// return whichever one we're closest to at this point in space\nint GetMat( vec3 pos )\n{\n    struct MatDist { int mat; float dist; };\n    MatDist mats[] = MatDist[](\n        \tMatDist( 0, TreeSDF(pos) ),\n        \tMatDist( 1, Baubles1(pos) ),\n        \tMatDist( 2, Baubles2(pos) ),\n        \tMatDist( 3, Baubles3(pos) ),\n        \tMatDist( 4, Ground(pos) )\n        );\n    \n    MatDist mat = mats[0];\n    for ( int i=1; i < mats.length(); i++ )\n    {\n        if ( mats[i].dist < mat.dist ) mat = mats[i];\n    }\n    \n    return mat.mat;\n}\n\n\nfloat epsilon = .0004; // todo: compute from t everywhere it's used (see \"size of pixel\"\\/\\/)\nint loopCount = 400; // because of the early out this can actually be pretty high without costing much\n\nfloat Trace( vec3 rayStart, vec3 rayDirection, float far, out int count )\n{\n\tfloat t = epsilon;\n    for ( int i=0; i < loopCount; i++ )\n    {\n        float h = SDF(rayDirection*t+rayStart);\n        t += h;\n        if ( t > far || h < epsilon ) // *t )\n            return t;\n    }\n    \n    return t;\n}\n\n\nvoid mainImage2( out vec4 fragColour, in vec2 fragCoord )\n{\n    float time = 3.-3.*cos(iTime/5.);//fract(iTime/12.)*12.;\n    \n    vec3 camPos = mix( vec3(2,3,-5), vec3(0,-5,-24), smoothstep(.5,6.,time) );\n    vec2 a = vec2(-.05,1.35-(iTime/5.-sin(iTime/5.))*.25)+.02*sin(vec2(1,.618)*iTime/3.);\n    \n    if ( iMouse.z > 0. ) a += ((iMouse.xy/iResolution.xy).yx-.5)*vec2(-3,6);\n    \n    camPos.yz = camPos.yz*cos(a.x)+sin(a.x)*vec2(-1,1)*camPos.zy;\n    camPos.zx = camPos.zx*cos(a.y)+sin(a.y)*vec2(-1,1)*camPos.xz;\n\n\tvec3 camLook = mix( vec3(0,3,0), vec3(0,1,0), smoothstep(.5,5.5,time) );\n\n    vec3 camK = normalize(camLook-camPos);\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\n    vec3 camJ = cross(camK,camI);\n    \n    camPos -= camI*(.5+1.*smoothstep(.5,5.5,time));\n    \n    float zoom = 5.-3.*smoothstep(.5,5.5,time);\n    vec3 ray = vec3((fragCoord-.5*iResolution.xy)/iResolution.y,zoom);\n    ray = ray.x*camI + ray.y*camJ + ray.z*camK;\n    ray = normalize(ray);\n    \n    int count = 0;\n    const float far = exp2(5.5\n#ifdef CLONES\n                           +3.5\n#endif\n                          );\n    float t = Trace( camPos, ray, far, count );\n    \n    fragColour = vec4(vec3(.05),t);\n    \n    if ( t < far )\n    {\n    \tvec3 pos = camPos + t*ray;\n\n        // size of 1 pixel\n\t\t// tan(a) = h / zoom\n\t\t// h = .5 / (resolution.y*.5)\n        vec2 d = vec2(-1,1) * t / (zoom*iResolution.y);\n        vec3 normal = normalize(\n            \tSDF(pos+d.xxx)*d.xxx +\n            \tSDF(pos+d.xyy)*d.xyy +\n            \tSDF(pos+d.yxy)*d.yxy +\n            \tSDF(pos+d.yyx)*d.yyx\n            );\n\n        vec3 uvw = FoldSpace(pos);\n\n        int matIdx = GetMat(uvw);\n        \n        struct Material\n        {\n            vec3 albedo;\n            vec3 subsurfaceColour;\n            float metallicity;\n            float roughness; // blurriness of the metallicity\n        };\n\n\t\tvec3 fairyColour = mix( (sin(pos*5.)*.5+.5), vec3(1), .3 )*(.1+5.*smoothstep(0.,.5,sin(atan(uvw.x,uvw.z)*2.+iTime*2.+length(uvw.xz)*2.+uvw.y*2.)));\n            \n\t\tMaterial mat = Material[](\n            Material( vec3(0/*overridden*/), vec3(0/*overridden*/), 0., 0. ), // tree\n            Material( vec3(fairyColour), vec3(fairyColour), 0., .0 ),\n            Material( vec3(1,.4,.1), vec3(0), 1., .0 ),\n            Material( vec3(1)-(.5+.5*sin(pos*7.))*vec3(.1,.4,.6), vec3(0), 1., .4 ),\n            Material( vec3(.9)*smoothstep(-.8,1.5,TreeBoundsSDF(uvw)), vec3(.2), .0, .05 ) // not getting enough shine on the snow so make it metallic\n\t\t)[matIdx]; // is this bad? I kind of like it!\n\n        if ( matIdx == 3 )\n        {\n            // glitter bauble / snow\n            normal += .4*(hash3(coord3(uvec3(pos/.002 + 65536.)))-.5);\n            normal = normalize(normal);\n        }\n        \n        vec3 refl = reflect( ray, normal );\n        \n        // very broad AO - just use the tree's bound SDF\n        float AO = exp2(min(0.,TreeBoundsSDF(uvw)-.3)/.3);\n        \n\t\tTreeSpace ts = GetTreeSpace(uvw);\n        if ( matIdx == 0 )\n        {\n\t\t\t// compute tree albedo\n            \n            float leafness = smoothstep(.0,.05, ts.needle.z) // // gradient along needle\n                \t\t\t* smoothstep(.01,.04, length(ts.branch.xy))\n                \t\t\t* smoothstep(.03,.06, length(uvw.xz));\n            \n            // blend wood to leaf colour\n        \tmat.albedo = mix( vec3(.05,.025,.01), vec3(0,.3,0), leafness );\n            mat.subsurfaceColour = mix( vec3(0), vec3(.04,.5,0), leafness );\n            \n            // snow\n            float snow = textureLod(iChannel2,pos.xz/.02,log2(t/iResolution.x)+13.).r;\n            snow = smoothstep(.1,.5,normal.y*.1+snow-.3*(1.-AO));\n            mat.albedo = mix( mat.albedo, vec3(1), snow );\n            mat.subsurfaceColour = mix( mat.subsurfaceColour, vec3(.1), snow );\n            \n        \t// and use the same things to paint the albedo trunk/branch colours\n            mat.roughness = .7;\n        }\n            \n        // fake reflection of the tree\n\t\t// I can probably afford a reflection trace - but I want to blur it based on roughness\n        float SO = smoothstep(-1.,1.,(TreeBoundsSDF(uvw + refl*1.)\n\t\t\t                              -1.*(textureLod(iChannel2,refl.yz*2.,.0).r*2.-.7)*pow(1.-mat.roughness,5.)\n                                      +.4)/(1.*(mat.roughness+.3))\n                             );\n        \n        vec4 diffuseSample = textureLod( iChannel0, normal, .0 );\n        vec3 diffuseLight = diffuseSample.rgb/diffuseSample.a;\n        \n        // sub surface scattering\n        vec4 subsurfaceSample = textureLod( iChannel0, -normal, .0 );\n        diffuseLight += mat.subsurfaceColour * subsurfaceSample.rgb/subsurfaceSample.a;\n        \n        diffuseLight *= AO;\n        \n\t\tvec3 specularLight = LDRtoHDR(textureLod( iChannel1, refl, mix(4.,9.,mat.roughness) ).rgb);\n        specularLight = mix( vec3(.01,.02,.0)+.0, specularLight, SO ); // blend to a rough tree colour\n        \n        float fresnel = pow(1.-abs(dot(ray,normal)),5.);\n        \n        fragColour.rgb =\n            mix(\n                mix ( mat.albedo, vec3(1.), mat.metallicity*(1.-mat.roughness)*fresnel ) *\n                mat.albedo *\n                mix(\n                    diffuseLight,\n                    specularLight,\n                    mat.metallicity\n                ),\n                specularLight,\n                mix( .02, 1., fresnel )*(1.-mat.roughness)\n            );\n\n        // debug colours\n\t\t//fragColour.rgb = fract( pos );\n        //fragColour.rgb = normal*.5+.5;\n        \n        fragColour.a = t;\n    }\n    else\n    {\n        fragColour.rgb = LDRtoHDR(textureLod( iChannel1, ray, .0 ).rgb);\n        \n        fragColour.a = far;\n    }\n    \n    // adjust depth to be signed distance from focal plane\n    // scale it proportionally, because that's how focus works\n    fragColour.a /= length(camLook-camPos);\n    fragColour.a += .15\n        + .65*smoothstep(.65,.85,sin(iTime/3.)); // move focus to near side of look target\n//        - 1.*smoothstep(.65,.85,sin(iTime/3.)); // move focus to near side of look target\n    fragColour.a -= 1.;\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    // todo: compute numSamples dynamically\n    int numSamples = max( 1, int((1920.*1080.*AA_QUALITY) / (iResolution.x*iResolution.y)) ); // I get 35fps at 1080p\n\n    fragColour = vec4(0);\n    for ( int i=0; i < numSamples; i++ )\n    {\n        uvec2 quasi2 = uvec2(0xC13FA9A9u,0x91E10DA5u);\n\t\tuint seed = uint(iFrame*numSamples+i)+uint(fragCoord.x)*quasi2.y+uint(fragCoord.y)*quasi2.x;\n        vec2 jitter = vec2( quasi2 * seed ) / exp2(32.);\n\n        if ( AA_ROUND )\n        {\n            // circle of confusion slightly bigger than a pixel - should look more photographic\n            jitter.x *= 6.283185;\n            jitter = AA_ROUND_RADIUS*(1.-jitter.y*jitter.y)*vec2(cos(jitter.x),sin(jitter.x));\n        }\n        else\n        {\n            jitter -= .5;\n        }\n        \n        vec4 col;\n        mainImage2( col, fragCoord + jitter );\n        fragColour += col;\n    }\n    fragColour /= float(numSamples);\n    \n    // exposure\n    fragColour.rgb *= 1.3;\n    \n    fragColour = mix(fragColour,texelFetch(iChannel3,ivec2(fragCoord),0),.4);\n\n    fragColour.rgb = max(fragColour.rgb,0.);//clamp( fragColour.rgb, 0., 1. );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}