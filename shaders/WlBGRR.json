{
    "Shader": {
        "info": {
            "date": "1558161948",
            "description": "Eiffie space is any space defined by a distance estimate. (look it up, it will be in Wikipedia shortly) These are rotations thru that space maintaining the distance estimate. Uses self correcting tables to keep \"arc\" lengths the same.",
            "flags": 32,
            "hasliked": 0,
            "id": "WlBGRR",
            "likes": 5,
            "name": "eiffie rotations",
            "published": 3,
            "tags": [
                "superformula",
                "rotation",
                "minkowski",
                "noneuclidean"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 481
        },
        "renderpass": [
            {
                "code": "//Rotation through Eiffie Space (the code is self explanatory)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor=texture(iChannel0,fragCoord/iResolution.xy);\n    if(fragCoord.x<iResolution.x/2.){\n        vec2 uv=fragCoord/iResolution.xy;\n        float d=abs(uv.y*4.0-2.0-texture(iChannel0,vec2(uv.x,0.5/iResolution.y)).r);\n      \tfragColor.b=smoothstep(0.02,0.0,d);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//from mickdermack https://www.shadertoy.com/view/MdXXDB \nfloat SuperFormula(float phi, float a, float b, float m, float n1, float n2, float n3){ \n return pow((pow(abs(cos(m*phi/4.0)/a),n2) + pow(abs(sin(m*phi/4.0)/b), n3)), -(1.0/n1)); \n} \nfloat SuperShape(in vec2 p){ \n float d=length(p);//the distance to the center of the shape \n float phi=atan(p.y,p.x);//the angles to feed the formula \n float r=SuperFormula(phi,0.75,1.0,floor(iTime/4.),3.0,3.0,4.0); \n vec2 np=r*vec2(cos(phi),sin(phi));//reconstituted point \n d-=length(np);//the distance to this point \n return d;\n}\nvec2 rotate(vec2 v, float angle) {return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\nfloat polygon(in vec2 p){\n  float pwr=floor(5.0+(iTime-40.0)/5.0);\n  float a=floor(0.5+atan(p.x,-p.y)*pwr/6.283)*6.283/pwr;\n  return -rotate(p,a).y-1.0;\n}\n/*float DE(vec2 p){\n  float n=3.0;//squircle power\n  if(iTime<5.0)return length(p)-1.0;//euclidean distance\n  if(iTime<10.0)return pow(pow(abs(p.x),n)+pow(abs(p.y),n),1.0/n)-1.0;//squircle (minkowski distance)\n  if(iTime<15.0)return abs(p.x)+abs(p.y)-1.0;//manhattan distance\n  if(iTime<40.0)return SuperShape(p);\n  return polygon(p);\n}*/\nfloat DE(vec2 p){\n  float n=1.0+iTime*iTime*0.02-0.18;//squircle power\n  if(n>2. && n<4.)n=2.;//pause at sphere to see adjustment\n  if(iTime<3.0)return abs(p.x)+abs(p.y)-1.0;//manhattan distance\n  //if(iTime<10.0)return length(p)-1.0;//euclidean distance\n  if(iTime<20.0)return pow(pow(abs(p.x),n)+pow(abs(p.y),n),1.0/n)-1.0;//squircle (minkowski distance)\n  \n  /*float d=length(p)-1.0+iTime*0.01;\n  p=abs(p)-vec2(0.5);\n  d=min(d,length(p)-0.3);\n  return d;*/\n  if(iTime<40.0)return SuperShape(p);\n  return polygon(p);\n}\nfloat Length(vec2 p){return DE(p)+1.0;}\nvec2 CosSin(float a){return texture(iChannel0,vec2(0.5*fract(a),0)+vec2(0.5)/iResolution.xy).xy;}\nfloat aCosSin(vec2 p){p/=Length(p);\n  p+=vec2(2);p/=vec2(8,4);p.y+=(p.y<0.5?-1.0:1.0)/iResolution.y;\n  return texture(iChannel0,p).x;\n}\nvec2 Rotate(vec2 p, float a){return Length(p)*CosSin(fract(aCosSin(p)+a));}\n\n//trig for manhattan distance (used as a starting point. no real trig used anywhere)\n#define Pi (2.0*sqrt(2.0))\nfloat t_cos(float a){return 2.0*abs(mod(a,2.0*Pi)-Pi)/Pi-1.0;}\nfloat t_atan(float x, float y){  \n float a=x-y,b=x+y,res;if(b==0.0)res=(a>0.0?7.0:3.0);  \n else{float d=a/b;if(abs(d)<1.0){if(b>0.0)res=1.0-d;else res=5.0-d;}else{d=b/a;if(a>0.0)res=7.0+d;else res=3.0+d;}}  \n return res*0.25*Pi;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 uv=fragCoord/iResolution.xy;\n  fragColor=texture(iChannel0,uv);\n  if(uv.x<=0.52){//tables\n    vec2 p,pL,pR;\n    if(fragCoord.y>0.5){//aCosSin\n      p=uv;if(abs(p.y-0.5)<2.0/iResolution.y)fragColor.r=p.x<0.25?0.5:p.y>0.5?0.0:1.0;\n      else {\n        p.y-=(p.y<0.5?-1.0:1.0)/iResolution.y;\n        p.x=p.x*2.0;p=(p*4.0)-vec2(2.0);\n        if(iFrame<5){//start with t_atan\n          fragColor=vec4(t_atan(p.x,p.y)/(2.0*Pi),0,0,1);//atan(p.y,p.x)/6.283,0,0,1);\n        }else if(abs(fragCoord.y-iResolution.y/2.)>1.0){//avoid crease\n          p/=Length(p);//compare p to CosSin of table value for p and adjust\n          float a=aCosSin(p);pL=CosSin(a);\n          float a2=aCosSin(pL);a+=(a-a2)*length(p-pL)*5.0;a=clamp(a,0.0,1.0);\n          fragColor.g=length(p-pL)*10.0;\n          fragColor.r=a;\n        }\n      }\n    }else{//CosSin\n      float a=uv.x*2.0;\n      if(iFrame<5){//start with a diamond of points\n        fragColor=vec4(t_cos(a*2.0*Pi),t_cos((a-0.25)*2.0*Pi),0,1);//cos(a*6.283),sin(a*6.283),0.0,1.0);\n      }else{//push points to surface and away from each other\n        p=fragColor.xy;\n        p/=Length(p);\n        if(fragCoord.x>0.5 && fragCoord.x<iResolution.x/2.-1.0){\n          float xL=fragCoord.x-1.0,xR=fragCoord.x+1.0;\n          pL=p-texture(iChannel0,vec2(xL,0.5)/iResolution.xy).xy;\n          pR=p-texture(iChannel0,vec2(xR,0.5)/iResolution.xy).xy;\n          float dl=length(pL)-length(pR);p+=(dl>0.0?-pL:pR)*dl*5.0;\n        }\n        fragColor.xy=p;\n      }\n    }\n  }else{//draw shape with dots and rotate\n    vec2 U=uv;U.x=((U.x-0.5)*2.0);U=(U*4.0)-vec2(2.0);U.y*=2.0*iResolution.y/iResolution.x;\n    float d=1.0;\n    for(int i=0;i<36;i++){\n      float a=float(i)/36.;\n      vec2 p=CosSin(a); \n      d=min(d,length(U-p));\n    }\n    d=smoothstep(0.0,0.02,d);\n    fragColor=vec4(d,d,d,1.0);\n    U=Rotate(U,iTime*0.1);\n    fragColor.r=step(sign(DE(U))*(mod(U.x*2.0,2.0)-1.0)*(mod(U.y*2.0,2.0)-1.0),0.0);\n  }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}