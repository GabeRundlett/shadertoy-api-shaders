{
    "Shader": {
        "info": {
            "date": "1703664814",
            "description": "Fork of \"Vyshyvanka GPU Patterns \" by mkngry. The pattern is mapped to white, black and red which are the most common vyshyvanka colors\n",
            "flags": 0,
            "hasliked": 0,
            "id": "XflGDf",
            "likes": 3,
            "name": "Vyshyvanka pattern on cloth",
            "published": 3,
            "tags": [
                "pattern",
                "cloth",
                "integerhashing",
                "vyshyvanka"
            ],
            "usePreview": 0,
            "username": "ikucha",
            "viewed": 193
        },
        "renderpass": [
            {
                "code": "// Fork of \"Vyshyvanka GPU Patterns \" by mkngry. https://shadertoy.com/view/sllGRB\n\nconst float PI = 3.1415926535;\nconst float WIDTH = 0.9;\nconst float HEIGHT = 1.5;\nconst float CLOTHTHICKNESS = 0.15;\nconst float CLOTHFINENESS =30.;\nconst vec3 LINENCOLOR = vec3(0.97, 0.97, 0.95);\n\n//hash function is by mkngry\nuvec3 hash(vec2 s)\n{\t\n  uvec2 u = uvec2(s);\n  //uint x = fmix(yellow_code(u.x^u.y));\n  uint x = triple32(fmix(u.x^u.y));\n  //uint x = pcg_hash(fmix(u.x^u.y));\n  uint y = avalanche0(yellow_code(u.x^~u.y));\n  uint z = avalanche1(yellow_code(~u.x^u.y));\n  //return uvec3(tw_hash(x),tw_hash(y),tw_hash(z));\n  return uvec3(yellow_code(EncodeMorton2(x,tw_hash(y))),yellow_code(EncodeMorton2(z,esgtsa(x))),yellow_code(EncodeMorton2(y,z)));\n}\n\nvec3 basePattern(vec2 st){\n    //unnormalized st\n    //create a fake resolution to make the size of the pattern consistent accross different resolutions\n    vec2 fakeRes = iResolution.xy/iResolution.x*700.;\n    vec2 unst = st*fakeRes.xy;\n    uint bit = uint(st.x+4.) + uint(st.y);\n    vec2 seed = mod(unst, vec2(fakeRes.x, fakeRes.y));\n    uvec3 hash = hash(seed);\n    return vec3((hash >> bit) & 1u);\n}\n//this function rotates the pattern properly and also takes isometric coordinates as input while basepattern takes [0,1]^2\n//and outputs a pattern that fills any resolution canvas\nvec3 rotatedPattern(vec2 st){\n    mat2 rotate = mat2(1., -1.,\n                     1., 1.);    \n    //the pattern is skewed so we need to unskew rotate and then skew again to rotate the pattern\n    st = rotate*st;\n    st.x*=iResolution.y/iResolution.x;\n    return basePattern(st);\n}\n\nvec3 mapColor(vec3 col){\n    //get a number from 0 to 7 from amount of 1s in color\n    float n = 4.*col.x+2.*col.y+col.z;\n    vec3 mappedCol = LINENCOLOR;\n    if(n>=2.9){mappedCol = vec3(0.1);}\n    if(n>=6.){mappedCol = vec3(0.93,0.,0.);}\n    return mappedCol;\n}\n\n//draws a sinetube on [-1,1]^2\nfloat sineTube(vec2 v, float _width, float _height){\n    float sine = -0.5*cos(v.x*PI)+0.5;\n    float _y = v.y/_width;\n    float circHeight = sqrt(_width-_y*_y)*_height/_width;\n    //can be NaN if _y is >than _width\n    //circHeight = isnan(circHeight)? 0. : circHeight;\n    float result = (sine+circHeight)/(1.+_height);\n    return isnan(result)? 0.: result*CLOTHTHICKNESS;\n}\n\n//here v is in [0,1]^2\nfloat clothPattern(vec2 v, float _width, float _height){\n    float threadht = sineTube(vec2(v.x*2.-1.-0.5,map(0.,1.,-3.,1.,v.y)),_width,_height);\n    float threadhb = sineTube(vec2(v.x*2.-1.+0.5,map(0.,1.,-1.,3.,v.y)),_width,_height);\n    float threadvr = sineTube(vec2(v.y*2.-1.+0.5,map(0.,1.,-3.,1.,v.x)),_width,_height);\n    float threadvl = sineTube(vec2(v.y*2.-1.-0.5,map(0.,1.,-1.,3.,v.x)),_width,_height);\n    float un = max(max(max(threadht, threadhb),threadvl),threadvr);\n    return un;\n}\n\nvec3 clothPatternNormal(vec2 v, float _width, float _height){\n    float epsilon = 1./(2.*max(iResolution.x,iResolution.y));\n    vec2 xnudge = v + vec2(epsilon, 0.);\n    vec2 ynudge = v+vec2(0.,epsilon);\n    \n    vec3 v3 = vec3(v,clothPattern(v,_width,_height));\n    vec3 xnudge3 = vec3(xnudge,clothPattern(xnudge,_width,_height));\n    vec3 ynudge3 = vec3(ynudge,clothPattern(ynudge,_width,_height));\n    vec3 normal = normalize(cross(xnudge3-v3,ynudge3-v3));\n    return normal;\n}\nvec2 pixellate(vec2 v, float n){\n    v= v*2.-1.;\n    v*=n;\n    return (floor(v)+vec2(0.5))/n;\n}\nvec2 distort(vec2 v, float frequency, float amplitude){\n    return v + vec2(snoise(v*frequency)*amplitude, snoise((v+vec2(100.,200.)*frequency)*amplitude));\n}\n\nvec3 clothPatternPhongLighting(vec3 albedo, vec2 pos, float n){\n    //normal is already normalized\n    vec3 normal = clothPatternNormal(fract(pos*n), WIDTH, HEIGHT);\n    //for now - a directional light\n    vec3 lightDir = normalize(vec3(1.,1., 1.));\n    \n    vec3 ambient = albedo * vec3(0.5);\n    vec3 diffuse = albedo * dot(normal, lightDir) * step(0.,dot(normal, lightDir));\n    //if dot product is negative then set to zero\n    //return vec3(step(dot(normal,lightDir), 0.));\n    return diffuse+ambient;\n}\n\n//averages clothPatternPhongLighting to fix a flashing issue\nvec3 smoothLighting(vec3 albedo, vec2 pos, float n){\n    const float epsilon = 0.001;\n    vec3 sum = vec3(0.);\n    for(float x = -1.; x<=1.;x+=1.){\n        for(float y = -1.; y<=1.; y+=1.){\n            //15 degree rotation for the offset vectors so that it doesn't align with the vertical and horizontal\n            vec2 offsetPos = pos + epsilon*(x*vec2(0.965926, -0.258819) +y*vec2(0.258819, 0.965926));\n            sum += clothPatternPhongLighting(albedo, offsetPos, n);\n        }\n    }\n    sum/=9.;\n    return sum;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy;\n  uv.x*=iResolution.x/iResolution.y;\n  uv+=iTime*vec2(1., 0.8)*0.1;\n  \n  vec3 color = smoothLighting(mapColor(rotatedPattern((distort(uv/14., 1500., 0.00015)))), distort(uv,500.,0.003), CLOTHFINENESS);\n  \n  fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float map(float froml, float fromr, float tol, float tor, float x){\n    x-=froml;\n    x/=fromr-froml;\n    x*=tor-tol;\n    x+=tol;\n    return x;\n}\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n//random function from user hornet https://www.shadertoy.com/view/4ssXRX\nfloat rand21( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n//everything below is from https://www.shadertoy.com/view/sllGRB/ by mkngry\n\n// from fxt_book\n// https://jjj.de/\nuint yellow_code(uint a)\n{\n  uint m = ~0u >> 16u;\n  a ^= ((a & m) << 16u);\n  m ^= (m << 8u);\n  a ^= ((a & m) << 8u);\n  m ^= (m << 4u);\n  a ^= ((a & m) << 4u);\n  m ^= (m << 2u);\n  a ^= ((a & m) << 2u);\n  m ^= (m << 1u);\n  a ^= ((a & m) << 1u);\n  return a;\n}\n\n// from http://burtleburtle.net/bob/hash/integer.html\nuint avalanche0(uint a)\n{\n  a = (a+0x7ed55d16u) + (a<<12u);\n  a = (a^0xc761c23cu) ^ (a>>19u);\n  a = (a+0x165667b1u) + (a<<5u);\n  a = (a+0xd3a2646cu) ^ (a<<9u);\n  a = (a+0xfd7046c5u) + (a<<3u);\n  a = (a^0xb55a4f09u) ^ (a>>16u);\n  return a;\n}\n\n// from http://burtleburtle.net/bob/hash/integer.html\nuint avalanche1(uint a)\n{\n  a = (a+0x7fb9b1eeu) + (a<<12u);\n  a = (a^0xab35dd63u) ^ (a>>19u);\n  a = (a+0x41ed960du) + (a<<5u);\n  a = (a+0xc7d0125eu) ^ (a<<9u);\n  a = (a+0x071f9f8fu) + (a<<3u);\n  a = (a^0x55ab55b9u) ^ (a>>16u);\n  return a;\n}\n\n// from http://burtleburtle.net/bob/hash/integer.html\nuint avalanche2(uint a)\n{\n  a -= (a<<6);\n  a ^= (a>>17);\n  a -= (a<<9);\n  a ^= (a<<4);\n  a -= (a<<3);\n  a ^= (a<<10);\n  a ^= (a>>15);\n  return a;\n}\n\n// Also avalanche, last step from from murmur3 hash\n// see: \"Hash Functions for GPU Rendering\" \n// https://www.shadertoy.com/view/XlGcRh\nuint fmix(uint h)\n{\n  h ^= h >> 16;\n  h *= 0x85ebca6bu;\n  h ^= h >> 13;\n  h *= 0xc2b2ae35u;\n  h ^= h >> 16;\n  return h;\n}\n\n// Tomas Wang hash\n// http://burtleburtle.net/bob/hash/integer.html\n// also https://github.com/tugrul512bit/EpicWarCL/blob/master/EpicWarCL/bin/x64/Release/opencl_source/opencl_kernels.cl\nuint tw_hash(uint s)\n{\n  s = (s ^ 61u) ^ (s >> 16u);\n  s *= 9u;\n  s = s ^ (s >> 4u);\n  s *= 0x27d4eb2du;\n  s = s ^ (s >> 15u);\n  return s;\n}\n\n// Schechter and Bridson hash\n// https://www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf\nuint esgtsa(uint s)\n{\n  s = (s ^ 2747636419u) * 2654435769u;\n  s = (s ^ (s >> 16u)) * 2654435769u;\n  s = (s ^ (s >> 16u)) * 2654435769u;\n  return s;\n}\n\n// 32-bit xorshift\n//  - Marsaglia, Xorshift RNGs, Journal of Statistical Software, v8n14, 2003\nuint xorshift32(uint v)\n{\n  v ^= v << 13u;\n  v ^= v >> 17u;\n  v ^= v << 5u;\n  return v;\n}\n\nuint triple32(uint x)\n{\n  x ^= x >> 17u;\n  x *= 0xed5ad4bbu;\n  x ^= x >> 11u;\n  x *= 0xac4c1b51u;\n  x ^= x >> 15u;\n  x *= 0x31848babu;\n  x ^= x >> 14u;\n  return x;\n}\n\nuint pcg_hash(uint x)\n{\n  uint state = x * 747796405u + 2891336453u;\n  uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n  return (word >> 22u) ^ word;\n}\n\n// Morton Code taken from fg:\n// https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/\n\n// \"Insert\" a 0 bit after each of the 16 low bits of x\nuint Part1By1(uint x)\n{\n  x &= 0x0000ffffu;                  // x = ---- ---- ---- ---- fedc ba98 7654 3210\n  x = (x ^ (x <<  8u)) & 0x00ff00ffu; // x = ---- ---- fedc ba98 ---- ---- 7654 3210\n  x = (x ^ (x <<  4u)) & 0x0f0f0f0fu; // x = ---- fedc ---- ba98 ---- 7654 ---- 3210\n  x = (x ^ (x <<  2u)) & 0x33333333u; // x = --fe --dc --ba --98 --76 --54 --32 --10\n  x = (x ^ (x <<  1u)) & 0x55555555u; // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0\n  return x;\n}\n\n// \"Insert\" two 0 bits after each of the 10 low bits of x\nuint Part1By2(uint x)\n{\n  x &= 0x000003ffu;                  // x = ---- ---- ---- ---- ---- --98 7654 3210\n  x = (x ^ (x << 16u)) & 0xff0000ffu; // x = ---- --98 ---- ---- ---- ---- 7654 3210\n  x = (x ^ (x <<  8u)) & 0x0300f00fu; // x = ---- --98 ---- ---- 7654 ---- ---- 3210\n  x = (x ^ (x <<  4u)) & 0x030c30c3u; // x = ---- --98 ---- 76-- --54 ---- 32-- --10\n  x = (x ^ (x <<  2u)) & 0x09249249u; // x = ---- 9--8 --7- -6-- 5--4 --3- -2-- 1--0\n  return x;\n}\n\nuint EncodeMorton2(uint x, uint y)\n{\n  return (Part1By1(y) << 1u) + Part1By1(x);\n}\n\nuint EncodeMorton3(uint x, uint y, uint z)\n{\n  return (Part1By2(z) << 2u) + (Part1By2(y) << 1u) + Part1By2(x);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}