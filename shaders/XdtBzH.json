{
    "Shader": {
        "info": {
            "date": "1524074166",
            "description": "Drawing quasi-periodic tilings using cut and project technique. Each pixel is tested to see which tile it belongs to. Really stupid implementation.\n[url=https://www.shadertoy.com/view/Xs3fDr]interactive version[/url]\nWIP",
            "flags": 0,
            "hasliked": 0,
            "id": "XdtBzH",
            "likes": 25,
            "name": "Cut n'project",
            "published": 3,
            "tags": [
                "tiling",
                "cut",
                "project",
                "aperiodic"
            ],
            "usePreview": 1,
            "username": "knighty",
            "viewed": 1266
        },
        "renderpass": [
            {
                "code": "/*--------------------------------------------------------------------------\n Aperiodic tiling\n by knighty (april 2018)\n License: Free\n Info: Uses cut and project method. The pixel is tested for which tile it \n       belongs to. Unlike The usual method that draws the tiles \"one by one\"\n       thus have cost proportionnal to the number of drawn tiles, the cost\n       per pixel in this shader is bound by a -rather big- constant. \n       ... WIP :o)\n For an interactive version, see: https://www.shadertoy.com/view/Xs3fDr\n\n Some references (both by Greg Egan.):\n - https://plus.google.com/u/0/113086553300459368002/posts/VJBnyhxH44y\n   (With a cool aniated gif that visually explains almost every thing.)\n - https://plus.google.com/u/0/113086553300459368002/posts/aMm17RELcsJ\n   (With links to articles and applets)\n--------------------------------------------------------------------------*/\n\n\n//the two vectors defining the cut and project plane\nconst float udir[5] = float[5](0.632456, 0.19544, -0.511667, -0.511667, 0.19544);\nconst float vdir[5] = float[5](0., 0.601501, 0.371748, -0.371748, -0.601501);\n//the 3 directions perpendicular to the cut and project plane\nconst float u2dir[5] = float[5](0.632456, -0.511667, 0.19544, 0.19544, -0.511667);\nconst float v2dir[5] = float[5](0., 0.371748, -0.601501, 0.601501, -0.371748);\nconst float adir[5] = float[5](0.447214, 0.447214, 0.447214, 0.447214, 0.447214);\n//Cut and project plane origin\nfloat CPO[5];\n\n//results of tiling search\nstruct Data{\n\tfloat dist;\n\tivec2 sides;\n\tvec2 posInTile;\n};\n\nvoid init(){\n\tfloat CP_tans_u2dir = 0.; \n    float CP_tans_v2dir = 0.;\n    float CP_tans_adir  = 2.2*sin(iTime*0.25);\n    for(int i=0; i<5; i++)\n\t\tCPO[i] = CP_tans_u2dir * u2dir[i] + CP_tans_v2dir * v2dir[i] + CP_tans_adir * adir[i];\n}\n\n//Gives the coordinates of the point (x,y) on the \"cutting\" plane into the 5D space\nfloat[5] P2E5(vec2 z){\n\tfloat p[5];\n\tfor(int i=0; i<5; i++)\n\t\tp[i] = CPO[i] + z.x * udir[i] + z.y * vdir[i];\n\treturn p;\n}\n\n//given a point p, return the nearest vertex in the lattice and the offset.\nvoid getRoundAndOffest(in float[5] p, out float[5] ip, out float[5] ofs){\n\tfor(int i=0; i<5; i++){\n\t\tip[i] = round(p[i]);\n\t\tofs[i] = p[i] - ip[i];\n\t}\n}\n\n//given a vector Ofs, return the vector of 1 when component >0 and -1 otherwise \nfloat[5] getOfsDir(float[5] ofs){\n\tfloat dir[5];\n\tfor(int i=0; i<5; i++){\n\t\t//if(ofs[i]>0.) dir[i]=1.; else dir[i]=-1.;\n\t\t//dir[i] = 2. * float(ofs[i] > 0.) - 1.;\n        dir[i] = ofs[i] > 0. ? 1. : -1.;\n\t}\n\treturn dir;\n}\n\n//project the vector ofs onto the plane (udir,vdir)\nvec2 projectOfs(float[5] ofs){\n   //dot products\n\tvec2 pofs = vec2(0);\n\tfor(int i=0; i<5; i++){\n\t\tpofs.x += ofs[i] * udir[i];\n\t\tpofs.y += ofs[i] * vdir[i];\n\t}\n\treturn pofs;\n}\n\n//Distance from a to the parallelogramm defined\n//by u and v. a is expressed in the (u,v) basis\nfloat Dist22V2(vec2 a, float f){\n\tvec2 p = abs(a - .5) - .5;//abs(a-vec2(.5))-vec2(.5);\n\treturn max(p.x, p.y) * f;//\n}\n\n//Finds if p is inside a the tile defined by (i,j,ip)\n//dir is not per se necessary it could be se to 1s\nData section(int i, int j, float[5] p, float[5] ip, mat2 m, float f, vec2 s){\n    //check intersection with dual\n    vec2 lhs = vec2(ip[i] - CPO[i], ip[j] - CPO[j]) + 0.5*s;\n\tvec2 z = lhs * m;\n\t\n    float[5]  ofs, q;\n\tq = P2E5(z);\n\t//the intersection can be on a neighbouring tile!\n\tfor(int k=0; k<5; k++){\n\t\tq[k] = floor(q[k]+.5);\n\t\tif(k==i)      ofs[k]=p[k] - (ip[k] + .5 * (s.x - 1.));\n        else if(k==j) ofs[k]=p[k] - (ip[k] + .5 * (s.y - 1.));\n\t\telse          ofs[k]=p[k] - q[k];\n\t}\n\t\n\tvec2 pofs = projectOfs(ofs);\n\t\n\t//get the face corresponding to the intersected dual\n    vec2 pit = (m * pofs);\n    \n\tfloat dist   = Dist22V2(pit, f);\n\tData d1 = Data(dist, ivec2(i,j), pit);\n\treturn d1;\n}\n\n//\nData DE(vec2 z){\n\n\tfloat[5] p = P2E5(z);\n\t\n\tfloat[5] ip, ofs, dir;\n\tgetRoundAndOffest(p,ip,ofs);\n    // dir is the preferred direction. Most of the tiling shows up thanks to it.\n    // comment \"#define NO_GLITCH\" below to see the difference\n    // Now faster thanks to dir and coherent branching :).\n    // One may notice that when zooming out (a lot) it slows down.\n    dir = getOfsDir(ofs);\n#define NO_GLITCH\n\n\tfor(int i=0; i<4; i++)\n\t\tfor(int j=i+1; j<5; j++)\n\t\t{\n\t\t\t//m and f can/should be precomputed!\n            // the inverse of m is used to test if:\n            // - the projection of p onto cutting plane is inside the current tile\n            // - the cut plane intersects the dual of the current tile\n            mat2 m = mat2(vec2(udir[i],vdir[i]), vec2(udir[j],vdir[j]));\n            // f is a correction factor to get the distance to the boundary of the tile\n    \t\tfloat f = dot(m[0],m[1]); f = sqrt(dot(m[0],m[0]) - f*f / dot(m[1],m[1]));\n            //We use the inverse of m in reality :D\n    \t\tm = inverse(m);\n            \n            //Scan the diffrent possible 4 directions\n            Data d1 = section(i, j, p, ip, m, f, vec2(dir[i],dir[j]));\n\t\t\tif(d1.dist < 0.) return d1;\n\t\t}\n    \n#ifdef NO_GLITCH    \n    for(int i=0; i<4; i++)\n\t\tfor(int j=i+1; j<5; j++)\n\t\t{\n\t\t\t//m and f can/should be precomputed!\n            // the inverse of m is used to test if:\n            // - the projection of p onto cutting plane is inside the current tile\n            // - the cut plane intersects the dual of the current tile\n            mat2 m = mat2(vec2(udir[i],vdir[i]), vec2(udir[j],vdir[j]));\n            // f is a correction factor to get the distance to the boundary of the tile\n    \t\tfloat f = dot(m[0],m[1]); f = sqrt(dot(m[0],m[0]) - f*f / dot(m[1],m[1]));\n            //We use the inverse of m in reality :D\n    \t\tm = inverse(m);\n            \n            vec2 s = vec2(1.,-1.);\n            //Scan the diffrent possible 4 directions\n            Data d1 = section(i, j, p, ip, m, f, vec2(-dir[i],dir[j]));\n\t\t\tif(d1.dist < 0.) return d1;\n\n\t\t\td1 = section(i, j, p, ip, m, f, vec2(dir[i],-dir[j]));\n\t\t\tif(d1.dist < 0.) return d1;\n\t\t\t\n\t\t\td1 = section(i, j, p, ip, m, f, vec2(-dir[i],-dir[j]));\n\t\t\tif(d1.dist < 0.) return d1;\n\t\t}\n#endif\n    \n\treturn Data(0., ivec2(0), vec2(0));\n}\n\n//-------------------------------------------------------------------------------------------\n// End of aperiodic tiling\n//-------------------------------------------------------------------------------------------\n\nfloat getFaceSurf(int i, int j){\n    float k = abs(float(j-i)-2.5);\n    return (k+0.5) * 0.2;\n\t/*vec2 u,v;\n\tu[0]=udir[i]; u[1]=vdir[i];\n\tv[0]=udir[j]; v[1]=vdir[j];\n\treturn abs(u[0]*v[1]-u[1]*v[0]);*/\n}\n\nfloat coverageFunction(float t){\n\t//this function returns the area of the part of the unit disc that is at the rigth of the verical line x=t.\n\t//the exact coverage function is:\n\t//t=clamp(t,-1.,1.); return (acos(t)-t*sqrt(1.-t*t))/PI;\n\t//this is a good approximation\n\treturn 1.-smoothstep(-1.,1.,t);\n\t//a better approximation:\n\t//t=clamp(t,-1.,1.); return (t*t*t*t-5.)*t*1./8.+0.5;//but there is no visual difference\n}\n\n#define DRadius .75\n#define Width 1.5\n#define BackgroundColor vec3(1)\n#define CurveColor vec3(0)\n#define Gamma 2.2\nfloat coverageLine(float d, float lineWidth, float pixsize){\n\td=d*1./pixsize;\n\tfloat v1=(d-0.5*lineWidth)/DRadius;\n\tfloat v2=(d+0.5*lineWidth)/DRadius;\n\treturn coverageFunction(v1)-coverageFunction(v2);\n}\n\nvec3 color(vec2 pos) {\n\tfloat pixsize=dFdx(pos.x);\n\tData data = DE(pos);\n\tfloat v=coverageLine(abs(data.dist), Width, pixsize);\n    \n\tvec3 faceCol = vec3(getFaceSurf(data.sides.x, data.sides.y)*3.5);\n    //vec3 faceCol = vec3(data.posInTile,0.);\n    faceCol *= texture(iChannel1,0.5*data.posInTile).rgb;\n    \n\treturn mix(BackgroundColor*faceCol,CurveColor,v);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = 5. * (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tinit();\n    fragColor = vec4(color(p), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}