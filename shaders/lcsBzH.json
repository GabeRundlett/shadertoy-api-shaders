{
    "Shader": {
        "info": {
            "date": "1723394829",
            "description": "Extract sign,exponent,mantissa of IEEE754 floats, try to convert every value to human readable version, print it on screen, may help to trace computation errors while developing shader in a limited environnement. Print values not dependent on fragCoord.",
            "flags": 0,
            "hasliked": 0,
            "id": "lcsBzH",
            "likes": 8,
            "name": "printf(\"%f %x %d\") HLSL/GLSL/Web",
            "published": 3,
            "tags": [
                "glsl",
                "webgl",
                "debug",
                "utils",
                "decode",
                "ieee754",
                "hlsl",
                "printf"
            ],
            "usePreview": 0,
            "username": "ludolpif",
            "viewed": 159
        },
        "renderpass": [
            {
                "code": "/* Inspired from https://www.shadertoy.com/view/3lGBDm ; Licensed under CC BY-NC-SA 3.0\n    Font extracted with : zcat /usr/share/fonts/X11/misc/4x6.pcf.gz | pcf2bdf\n    See: https://github.com/ludolpif/obs-shadertastic-effects/blob/main/utils/x11-bitmap-font-extractor.sh\n   You might like https://www.shadertoy.com/view/7dfyRH (I discovered it lately, use font texture).\n\n    Primarily written for OBS Shadertastic plugin (shader library for live streaming with OBS Studio)\n    See: https://shadertastic.com\n*/\n#define float2 vec2\n#define float4 vec4\n#define int2 ivec2\n#define int3 ivec3\n\nconst bool should_print_grid = true;\nconst bool should_print_font_test = true;\nconst float font_size = 0.083333333; // for option 1 (uv coordinates)\nconst float font_scale = 4.0; // for option 2 (pixel coordinates)\nconst float2 grid_origin = float2(0.5,0.15); // in [0.0;1.0[²\nconst float4 text_color = float4(0.9, 0.2, 0.2, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Tech demo on gray background\n    vec4 rgba = vec4(0.2, 0.2, 0.2, 1.0);\n\n    int2 text_offset = int2(0,-1);\n    /* Option 1: UV coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y = 1.0 - uv.y; // with 'v' going from 0.0:top to 1.0:bottom as OBS do\n    float aspect_ratio = iResolution.x/iResolution.y;\n    // Compute once current pixel in text_coords space\n    float2 text_coords = debug_get_text_coords_from_uv(uv, grid_origin, aspect_ratio, font_size, text_offset );\n    */\n    /* Option 2 : fragCoord (pixel) coordinates */\n    float2 text_coords = debug_get_text_coords_from_fragCoord(fragCoord, iResolution.xy*grid_origin, iResolution.xy, font_scale, text_offset);\n\n    if ( should_print_grid ) {\n        rgba = debug_print_text_grid(rgba, text_coords, text_offset, -12, 0, 13, 9);\n    }\n\n    if ( should_print_font_test ) {\n        text_offset = int2(-11, 0);\n        if ( debug_inside_text_box(text_coords, text_offset, 24) ) {\n            int wanted_digit_font_test = debug_get_wanted_digit_from_text_coords(text_coords);\n            int glyph_index_font_test = 12 - wanted_digit_font_test;\n            rgba = debug_print_glyph(text_coords, glyph_index_font_test)?text_color:rgba;\n        }\n    }\n\n    // debug_decode_float() in:\n    float float_to_decode = iTime;\n    int wanted_digit = debug_get_wanted_digit_from_text_coords(text_coords);\n    // debug_decode_float() out:\n    int sign, exp, mant, signi, glyph_index;\n    float expf;\n    int2 fixed_point;\n    // debug_decode_float() call:\n    debug_decode_float(float_to_decode, wanted_digit, 9, 8, sign, exp, mant, signi, expf, fixed_point, glyph_index);\n    /*\n     * note: you should call debug_decode_float() call only for pixels that will display it's values\n     *  because doing the decoding for the full texture may make the GPU too busy.\n     *  For this demo, multiple lines of text will depend on this debug_decode_float() so we call it unconditionnaly\n     */\n    // displaying the result then inner details as an API demo\n    text_offset = int2(-8, 1);\n    if ( debug_inside_text_box(text_coords, text_offset, 19) ) {\n        rgba = debug_print_glyph(text_coords, glyph_index)?text_color:rgba;\n    }\n    // show the float_to_decode as hex, from previously splitted bit fields\n    text_offset = int2(0, 2);\n    if ( debug_inside_text_box(text_coords, text_offset, 10) ) {\n        int decoded_float = sign<<31 | (exp&0xff)<<23 | mant;\n        glyph_index = debug_decode_int_hexadecimal_fixed(decoded_float, wanted_digit, 8);\n        rgba = debug_print_glyph(text_coords, glyph_index)?text_color:rgba;\n    }\n    // show the float_to_decode mantissa 23 bits as binary number (0b........................)\n    text_offset = int2(-12, 3);\n    if ( debug_inside_text_box(text_coords, text_offset, 25) ) {\n        glyph_index = debug_decode_int_binary_fixed(mant, wanted_digit+12, 23);\n        rgba = debug_print_glyph(text_coords, glyph_index)?text_color:rgba;\n    }\n    // show the float_to_decode mantissa 23 bits as decimal number\n    text_offset = int2(0, 4);\n    if ( debug_inside_text_box(text_coords, text_offset, 8) ) {\n        glyph_index = debug_decode_int_decimal(mant, wanted_digit);\n        rgba = debug_print_glyph(text_coords, glyph_index)?text_color:rgba;\n    }\n    // show the float_to_decode exponent (without IEEE -127 offset) as decimal number\n    text_offset = int2(0, 5);\n    if ( debug_inside_text_box(text_coords, text_offset, 4) ) {\n        glyph_index = debug_decode_int_decimal(int(expf), wanted_digit);\n        rgba = debug_print_glyph(text_coords, glyph_index)?text_color:rgba;\n    }\n    // show the -0.0 special case\n    text_offset = int2(-2, 6);\n    if ( debug_inside_text_box(text_coords, text_offset, 6) ) {\n        float_to_decode = -0.0; // it's a different binary representation than +0.0 but compilers may throw it\n        debug_decode_float(float_to_decode, wanted_digit, 9, 8, sign, exp, mant, signi, expf, fixed_point, glyph_index);\n        rgba = debug_print_glyph(text_coords, glyph_index)?text_color:rgba;\n    }\n    // This part of code causes compilation error on NVIDIA 555.58.02 driver with ArchLinux and GTX1060\n    // C7532: global function unitBitsToFloat requires \"#version 330\" or later.\n    /*\n    // show the -inf special case\n    text_offset = int2(-2, 7);\n    if ( debug_inside_text_box(text_coords, text_offset, 6) ) {\n        float_to_decode = 2e38; // Near to maximum encodable IEEE754 binary32 float\n        float_to_decode *= -2.0;// Should be -inf\n        debug_decode_float(float_to_decode, wanted_digit, 9, 8, sign, exp, mant, signi, expf, fixed_point, glyph_index);\n        rgba = debug_print_glyph(text_coords, glyph_index)?text_color:rgba;\n    }\n    // show the +nan special case\n    text_offset = int2(-2, 8);\n    if ( debug_inside_text_box(text_coords, text_offset, 6) ) {\n        float_to_decode = sqrt(-abs(expf)); // Maybe +nan if float_to_decode not between 1.0 and 1.5\n        debug_decode_float(float_to_decode, wanted_digit, 9, 8, sign, exp, mant, signi, expf, fixed_point, glyph_index);\n        rgba = debug_print_glyph(text_coords, glyph_index)?text_color:rgba;\n    }\n    */\n    // Output to screen\n    fragColor = rgba;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define _OPENGL\n#define float2 vec2\n#define float4 vec4\n#define int2 ivec2\n#define int3 ivec3\n#define frac fract\n#define fmod mod\n\n/**\n * Returns true if v is included in the rectangle defined by left_top (inclusive) and right_bottom (exclusive)\n * Alternative definition : with left_top.x <= right_bottom.x and left_top.y <= right_bottom.y,\n *  it returns ( left_top.x <= v.x < right_bottom.x && left_top.y <= v.y < right_bottom.y )\n * Behavior on limits is tricky if left_top.x > right_bottom.x or left_top.y > right_bottom.y\n * @param v coordinates of a point to test\n * @param left_top coordinates of the top left corner of the rectangle\n * @param right_bottom coordinates of the bottom right corner of the rectangle\n */\nbool inside_box(float2 v, float2 left_top, float2 right_bottom) {\n    float2 s = step(left_top, v) - step(right_bottom, v);\n    return s.x * s.y != 0.0;\n}\n\n#ifndef DEBUG_FONT_GLYPHS\n#define DEBUG_FONT_GLYPH_WIDTH 4\n#define DEBUG_FONT_GLYPH_HEIGHT 6\n#define DEBUG_FONT_GLYPHS \\\n        /*\" \"*/ 0, \\\n        /* + */ 320512, \\\n        /* . */ 4194304, \\\n        /* 0 */ 4909632, \\\n        /* 1 */ 14961728, \\\n        /* 2 */ 14953024, \\\n        /* 3 */ 12731104, \\\n        /* 4 */ 2288288, \\\n        /* 5 */ 12765408, \\\n        /* 6 */ 4900960, \\\n        /* 7 */ 8930016, \\\n        /* 8 */ 13257312, \\\n        /* 9 */ 12741184, \\\n        /* a */ 6989312, \\\n        /* b */ 13282432, \\\n        /* c */ 6850048, \\\n        /* d */ 6989344, \\\n        /* e */ 7119872, \\\n        /* f */ 4514848, \\\n        /* i */ 14991424, \\\n        /* n */ 11185152, \\\n        /* x */ 10766848, \\\n        /* - */ 57344, \\\n        /* ? */ 4211392\n#endif /* DEBUG_FONT_GLYPHS */\n/* Note : '+' is 4514880 from the x11 font + script, but it's ugly, manually changed here. */\n\n/**\n * Returns a point in the text_coords space from uv space taking ratio, origin, offset and text height into account.\n *  text_coords has integer part that represent a glyph, and fractionnal part for glyph pixels.\n *  text_coords[0] goes from right to left (as numbers digit powers/positions goes)\n *  text_coords[1] goes from top to bottom (as lines in a terminal)\n * @param uv point in uv space, should be in [0.0,1.0]²\n * @param uv_grid_origin point in uv space that becomes the origin [0.0,0.0] in text_coord space\n * @param uv_aspect_ratio ratio to keep glyph pixels as square in case of non square target texture\n * @param uv_line_height font size expressed as a fraction of target texture height\n *  (1.0: one line of text occupies the full texture height. 0.1: ten lines of text avaiable in the texture height)\n * @param text_offset offset in text_coords space to ease text positionning in a glyph size unit\n */\nfloat2 debug_get_text_coords_from_uv(in float2 uv, in float2 uv_grid_origin, in float uv_aspect_ratio,\n        in float uv_line_height, in int2 text_offset) {\n    const float font_ratio = float(DEBUG_FONT_GLYPH_HEIGHT)/float(DEBUG_FONT_GLYPH_WIDTH);\n    return (uv - uv_grid_origin)*float2(-uv_aspect_ratio*font_ratio, 1.0)/uv_line_height - float2(text_offset);\n}\n\n/**\n * Returns a point in the text_coords space from fragCoord (pixel) space taking scale, origin, offset into account.\n *  text_coords has integer part that represent a glyph, and fractionnal part for glyph pixels.\n *  text_coords[0] goes from right to left (as numbers digit powers/positions goes)\n *  text_coords[1] goes from top to bottom (as lines in a terminal)\n * @param fragCoord point in fragCoord (pixel) space, should be between [0.0,0.0] and resolution\n * @param grid_origin point in fragCoord (pixel) space that becomes the origin [0.0,0.0] in text_coord space\n * @param resolution size of the output texture in pixels\n * @param font_scale each pixel in font should be zoomed by this factor on the target texture\n * @param text_offset offset in text_coords space to ease text positionning in a glyph size unit\n */\nfloat2 debug_get_text_coords_from_fragCoord(float2 fragCoord, float2 grid_origin, float2 resolution, float font_scale, int2 text_offset) {\n    const float2 glyph_size = float2(DEBUG_FONT_GLYPH_WIDTH,DEBUG_FONT_GLYPH_HEIGHT);\n    float2 text_origin = grid_origin*float2(1.0, -1.0) + float2(0.0, resolution.y);\n    return (text_origin - fragCoord) / (glyph_size*font_scale) - float2(text_offset);\n}\n\n/**\n * returns the wanted_digit integer number from a text_coords point for debug_decode_* functions.\n *  wanted_digit convention for int: 0 will be units, 1 tens, 2 hundreds...\n *  wanted_digit convention for floats : 0 will be '.', 1 units, 2 tens... -1 first digit of fractionnal part...\n * @param text_coords the text_coords point from current uv space point (see debug_get_text_coords_from_uv)\n */\nint debug_get_wanted_digit_from_text_coords(in float2 text_coords) {\n    //note: floor() will make a double wanted_digit==0 for text_coords in [-1.0;1.0], round() will not but needs -0.5\n    return int(round(text_coords.x-0.5));\n}\n\n/**\n * returns true if text_coords is the rectangle defined by text_offset and text_len, considering only one line of text\n * @param text_coords current point in text_coords space\n * @param text_offset offset in text_coords space to ease text positionning in a glyph size unit\n * @param text_len maximum number of glyphs to be expected on the text field\n */\nbool debug_inside_text_box(in float2 text_coords, in int2 text_offset, in int text_len) {\n    return inside_box(text_coords, float2(text_offset), float2(text_offset.x + text_len, text_offset.y + 1));\n}\n\n/**\n * returns an rgba pixel value to display the pixel at text_coords of a text grid.\n *  Meant to help choosing parameters for debug_get_text_coords_from_uv().\n *  Not really for final render.\n * @param rgba pixel value to return of the current text_coords is not on the grid\n * @param text_coords current point in text_coords space\n * @param text_offset should be same as text_offset in debug_get_text_coords_from_uv() call\n * @param cols_neg number of columns on the right of (0,0) character\n * @param lines_neg number of lines over the (0,0) character\n * @param cols_pos number of columns on the left of (0,0) character\n * @param lines_pos number of lines below the (0,0) character\n */\nfloat4 debug_print_text_grid(in float4 rgba, in float2 text_coords, in int2 text_offset,\n        in int cols_neg, in int lines_neg, in int cols_pos, in int lines_pos) {\n    // Make lines thick like 1 pixel in font\n    const float2 glyph_size = float2(DEBUG_FONT_GLYPH_WIDTH,DEBUG_FONT_GLYPH_HEIGHT);\n    const float2 grid_thickness = 1.0/glyph_size;\n    // Don't draw anything if we are computing a pixel outside of the grid rectangle\n    float2 left_top = float2(cols_neg, lines_neg);\n    float2 right_bottom = float2(cols_pos, lines_pos) + grid_thickness;\n    if ( !inside_box(text_coords, left_top, right_bottom) ) {\n        return rgba;\n    }\n    // Highlight the uv-spaced anchor of the grid\n    if ( inside_box(text_coords + float2(text_offset), float2(0.0, 0.0), grid_thickness) ) {\n        return float4(0.0, 0.0, 1.0, 1.0);\n    }\n    // Print the grid\n    if ( frac(text_coords.x) < grid_thickness.x || frac(text_coords.y) < grid_thickness.y ) {\n        return float4(0.2, 0.2, 0.2, 1.0);\n    }\n    // Make the character at origin with a dark background\n    if ( debug_inside_text_box(text_coords, int2(0,0), 1) ) {\n        return float4(0.0, 0.0, 0.0, 1.0);\n    }\n    // Make a gray background for the whole grid\n    return float4(0.3, 0.3, 0.3, 1.0);\n}\n\n/**\n * returns true if a debug pixel should be printed on target texture.\n *  Alternative definition: return glyph_bit from the glyph at glyph_index in font for the position given by text_coords.\n * @param text_coords the text_coords point from current uv space point (see debug_get_text_coords_from_uv)\n * @param glyph_index index of the glyph to display from the array made from DEBUG_FONT_GLYPHS\n */\nbool debug_print_glyph(in float2 text_coords, in int glyph_index) {\n#ifdef _OPENGL\n    const int font[24] = int[24](DEBUG_FONT_GLYPHS);\n#else\n    static const int font[24] = {DEBUG_FONT_GLYPHS};\n#endif\n    // select the right glyph in the font, with a default '?' in case of out-of-bounds glyph_index\n    int i = (glyph_index >= 0 && glyph_index < 24)?glyph_index:23;\n    // from 2D fractionnal parts of text_coords, find which bit in font encodes the current pixel\n    const float2 glyph_size = float2(DEBUG_FONT_GLYPH_WIDTH,DEBUG_FONT_GLYPH_HEIGHT);\n    int2 bit_coord = int2( frac(text_coords) * glyph_size );\n    int bit_number = bit_coord.y * DEBUG_FONT_GLYPH_WIDTH + bit_coord.x;\n    // return the selected glyph bit as bool\n    return (font[i] >> bit_number & 1) == 1;\n}\n\n/**\n * returns a glyph_index to use with debug_print_glyph() to make a rudimentary printf(\"%d\",int_to_decode), one wanted_digit at a time.\n * @param int_to_decode int value to be decoded as a decimal number\n * @param wanted_digit digit number you want to get from int_to_decode (0: units, 1: tens, 2: hundreds...)\n * @param total_digits int_to_decode will be displayed on total_digits digits + 1 for sign, with leading 0's.\n */\nint debug_decode_int_decimal_fixed(in int int_to_decode, in int wanted_digit, in int total_digits) {\n#ifdef _OPENGL\n    const int pow10_table[10] = int[10](1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000);\n#else\n    static const int pow10_table[10] = {1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000};\n#endif\n    if ( total_digits < 1 ) total_digits = 1;\n    int glyph_index;\n    if ( wanted_digit < 0 || wanted_digit > total_digits ) {\n        glyph_index = 0; // for ' '\n    } else if ( wanted_digit == total_digits ) {\n        glyph_index = int_to_decode<0?22:1; // for '-' or '+'\n    } else if ( wanted_digit == 9 ) {\n        glyph_index = 3 + abs(int_to_decode) / pow10_table[9];\n    } else {\n        int pow10_next = pow10_table[wanted_digit+1];\n        int pow10_curr = pow10_table[wanted_digit];\n        //note: a % b is portable only in positive numbers case. See https://www.shadertoy.com/view/Dlj3Rh\n        glyph_index = 3 + ( abs(int_to_decode) % pow10_next ) / pow10_curr;\n    }\n    return glyph_index;\n}\n\n/**\n * returns a glyph_index to use with debug_print_glyph() to make a rudimentary printf(\"%d\",int_to_decode), one wanted_digit at a time.\n *  This is a wrapper for debug_decode_int_decimal_fixed() trying to guess the right total_digits for you.\n * @param int_to_decode int value to be decoded as a decimal number\n * @param wanted_digit digit number you want to get from int_to_decode (0: units, 1: tens, 2: hundreds...)\n */\nint debug_decode_int_decimal(in int int_to_decode, in int wanted_digit) {\n    const float inv_log10 = 1.0/log2(10.0);\n    int total_digits = 1+int(log2(float(abs(int_to_decode)))*inv_log10);\n    /* note: tried a for loop with 10 iterations, then a while loop with integer comparisons to get exact total_digits\n     * it ran smoothly on many platforms but makes code totally unusable on Chrome + Windows10 + NVIDIA driver + GTX1060\n     * (no output at all, shadertoy player running at 6 FPS)\n     */\n    return debug_decode_int_decimal_fixed(int_to_decode, wanted_digit, total_digits);\n}\n\n/**\n * returns a glyph_index to use with debug_print_glyph() to make a rudimentary printf(\"%x\",int_to_decode), one wanted_digit at a time.\n * @param int_to_decode int value to be decoded as an hexadecimal number\n * @param wanted_digit digit number you want to get from int_to_decode (0: first hex digit, least significate, 1: second hex digit...)\n * @param total_digits int_to_decode will be displayed on total_digits digits + 2 for \"0x\" prefix.\n */\nint debug_decode_int_hexadecimal_fixed(in int int_to_decode, in int wanted_digit, in int total_digits) {\n    int glyph_index = 0; // for ' '\n    if ( total_digits < 1 ) total_digits=1;\n    if ( wanted_digit == total_digits+1 ) {\n        glyph_index = 3; // for '0'\n    } else if ( wanted_digit == total_digits ) {\n        glyph_index = 21; // for 'x'\n    } else if ( wanted_digit >= 0 && wanted_digit < total_digits) {\n        glyph_index = 3 + (int_to_decode >> (wanted_digit*4)) % 16; // for [0-9a-f]\n    }\n    return glyph_index;\n}\n/**\n * returns a glyph_index to use with debug_print_glyph() to make a rudimentary printf(\"%b\",int_to_decode), one wanted_digit at a time.\n * @param int_to_decode int value to be decoded as an binary number\n * @param wanted_digit digit number you want to get from int_to_decode (0: least significant bit, 1: second bit...)\n * @param total_digits int_to_decode will be displayed on total_digits digits + 2 for \"0b\" prefix.\n */\nint debug_decode_int_binary_fixed(in int int_to_decode, in int wanted_digit, in int total_digits) {\n    int glyph_index = 0; // for ' '\n    if ( total_digits < 1 ) total_digits=1;\n    if ( wanted_digit == total_digits+1 ) {\n        glyph_index = 3; // for '0'\n    } else if ( wanted_digit == total_digits ) {\n        glyph_index = 14; // for 'b'\n    } else if ( wanted_digit >= 0 && wanted_digit < total_digits) {\n        glyph_index = 3 + (int_to_decode >> wanted_digit) % 2; // for '0' or '1'\n    }\n    return glyph_index;\n}\n\n/**\n * returns the \"sign\" bitfield as encoded in IEEE754 floats. 0b0: positive numbers, 0b1:negative numbers.\n *  Internally used by debug_decode_float(). You should not need to call this function directly.\n * @param float_to_decode float from which we want field extraction\n */\nint debug_decode_float_sign(in float float_to_decode) {\n    return\n        float_to_decode < 0.0?1:\n        float_to_decode > 0.0?0:\n        (1.0 / float_to_decode < 1.0)?1: // for -0.0\n        0; // for +0.0\n    // note: -0.0 is not < +0.0 if using comparison operators\n    // TODO may someone know a fairly portable way without division to detect -0.0 ?\n}\n\n/**\n * returns a fixed-point decimal reprensentation of a certain mantissa power of two (adjusted by exp)\n *  Internally used by debug_decode_float(). You should not need to call this function directly.\n *  The first int is integer part, the second is fractionnal part.\n *  For fractionnal part, a +9 implied decimal fraction digits is used.\n *  So, to get the canonical representation, divide the fractionnal part value value by 10^9.\n *  This function will return wrong integer part if mantissa_pow > 30.0\n *    and 0 fractionnal part if mantissa_pow < -29.0.\n * @param mantissa_pow the mantissa power of two (adjusted by exp) to retreive (max 30.0).\n */\nint2 debug_decode_float_mantissa_to_fixed_point(in float mantissa_pow) {\n    int fpart = int(clamp(-mantissa_pow, 0.0, 31.0));\n    int ipart = int(clamp( mantissa_pow, 0.0, 31.0));\n    return int2( 1 << ipart >> fpart, (1000000000 >> fpart)%1000000000 );\n    /*\n     * note: two tricks are used here to not have conditionnal branches on this code called frequently\n     *  \">> fpart\"  makes result[0] equals to 0 (and not 1)   for all strictly negative mantissa_pow\n     *  %1000000000 makes result[1] equals to 0 (and not 1e9) for all strictly positive mantissa_pow\n     */\n}\n\n/**\n * returns a glyph_index for a special float value described by glyphs, at wanted_digit.\n *  Internally used by debug_decode_float(). You should not need to call this function directly.\n *  It's for +/-inf, +/-nan, +/-0.0.\n * @param sign Sign of the specal value\n * @param glyphs triplet of glyph indices needed for the current float special value to display\n * @param wanted_digit digit number you want to get from glyphs triplet (from 2 to -1 to center nicely, including sign)\n */\nint debug_format_float_special_values(in int sign, in int3 glyphs, in int wanted_digit) {\n    return\n        wanted_digit==2?(sign==1?22:1): // for '-' or '+'\n        wanted_digit==1?glyphs[0]:\n        wanted_digit==0?glyphs[1]:\n        wanted_digit==-1?glyphs[2]:\n        0;\n}\n\n/**\n * returns a glyph_index for a finite float value described by sign+fixed_point, at wanted_digit.\n *  Internally used by debug_decode_float(). You should not need to call this function directly.\n *  It's for floats that's fit on 9 digits with up to 8 decimal places.\n * @param sign Sign of the specal value\n * @param fixed_point fixed point number representation [0] is integer part,\n *   [1] is fractionnal part with 1e9 implicit multiplicator\n * @param wanted_digit digit number you want to get from glyphs triplet (from 10 to -8, 0 is '.')\n */\nint debug_format_float_finite_values_natural_form(int sign, int2 fixed_point, int wanted_digit) {\n    int glyph_index;\n    if ( wanted_digit < -8 || wanted_digit > 10 ) {\n        glyph_index = 0; // for ' '\n    } else if ( wanted_digit == 10 ) {\n        glyph_index = (sign==1?22:1); // for '-' or '+'\n    } else if ( wanted_digit > 0 ) {\n        glyph_index = debug_decode_int_decimal_fixed(fixed_point[0], wanted_digit-1, 9);\n    } else if ( wanted_digit == 0 ) {\n        glyph_index = 2; // for '.'\n    } else /* ( wanted_digit < 0 ) */ {\n        glyph_index = debug_decode_int_decimal_fixed(fixed_point[1], wanted_digit+8, 8);\n    }\n    return glyph_index;\n}\n\n/**\n * returns a glyph_index for a finite float value described by sign+float_to_decode_abs, at wanted_digit.\n *  Internally used by debug_decode_float(). You should not need to call this function directly.\n *  It's for floats values that are very tiny or very big\n * @param sign Sign of the specal value\n * @param float_to_decode_abs abs(float_to_decode)\n * @param wanted_digit digit number you want to get from glyphs triplet (from 10 to -8, 0 is '.')\n */\nint debug_format_float_finite_values_scientific_form(int sign, float float_to_decode_abs, int wanted_digit) {\n    int glyph_index;\n    //TODO log10f seems to loose precision for tiny float_to_decode_abs values (negative log values)\n    float log10f = log2(float_to_decode_abs)/log2(10.0);\n    if ( wanted_digit < -3 || wanted_digit > 2 ) {\n        glyph_index = 0; // for ' '\n    } else if ( wanted_digit == 2 ) {\n        glyph_index = (sign==1?22:1); // for '-' or '+'\n    } else if ( wanted_digit == 1 ) {\n        //TODO no sci_m calculus for now, seems tricky to write\n        glyph_index = 4; // for '1'\n    } else if ( wanted_digit == 0 ) {\n        glyph_index = 17; // for 'e'\n    } else /* ( wanted_digit < 0 ) */ {\n        int sci_n = int(log10f);\n        glyph_index = debug_decode_int_decimal_fixed(sci_n, wanted_digit+3, 2);\n    }\n    return glyph_index;\n}\n\n/**\n * returns a glyph_index to use with debug_print_glyph() to make a rudimentary printf(\"%f\",float_to_decode), one wanted_digit at a time.\n *  This function has many out paramters to get as many details as possible from float_to_decode.\n *  With IEEE754 floats on 32 bits, biggest is -/+3.4028235e38, tiniest non-zero is -/+1e-45.\n * @param float_to_decode int value to be decoded as a decimal number with fractionnal part\n * @param wanted_digit digit number you want to get from int_to_decode (1: units, 2: tens, -1: first fractionnal digit...)\n * @param integer_digits number of digit to display for the integer part of float_to_decode (max 9)\n * @param fractionnal_digits number of digit to display for the fractionnal part of float_to_decode (max 8)\n * @param sign outputs the sign bit as encoded in IEE754\n * @param exp outputs the exp bitfield as encoded in IEE754 (=expf+127 encoded on unsigned int of 8 bits)\n * @param mant outputs the mantissa bitfield as encoded in IEE754 (23 bits, the 24th bit is always 1 and is implicit)\n * @param signi outputs the sign as a integer directly usable to multiply numbers against (-1:negative, +1:positive)\n * @param expf outputs the exponent with IEEE754 offset, as float (but will never have any fractionnal part)\n * @param fixed_point outputs the fixed point reprensentation of float_to_decode\n *  (limited with 9 digits for integer part and 8 for fractionnal part)\n * @param glyph_index outputs the glyph index for in wanted_digit of float_to_decode to use with debug_print_glyph()\n */\nvoid debug_decode_float(in float float_to_decode, in int wanted_digit, in int integer_digits, in int fractionnal_digits,\n        out int sign, out int exp, out int mant, out int signi,\n        out float expf, out int2 fixed_point, out int glyph_index)\n{\n    // Floats numbers are coded in IEEE754 in a way roughly representable as signi*2^expf*(1+mantissa_fractionnal)\n    sign = debug_decode_float_sign(float_to_decode);\n    signi = sign==1?-1:1;\n\n    // Before exponent extraction, eliminate special cases on which log2(x) will not be useful\n    if ( float_to_decode == 0.0 ) {\n        expf = -126.0; exp = 0; mant = 0; fixed_point = int2(0,0);\n        glyph_index = debug_format_float_special_values(sign, int3(3,2,3), wanted_digit); // for \" +0.0 \"\n    } else if ( isnan(float_to_decode) || isinf(float_to_decode) ) {\n        expf = float_to_decode; // non-finite value as a placeholder\n        exp = 255; mant = 0; fixed_point = int2(0,0);\n        int3 glyphs = isnan(float_to_decode)?int3(20,13,20):int3(19,20,18); // for \"nan\" or \"inf\"\n        glyph_index = debug_format_float_special_values(sign, glyphs, wanted_digit);\n    } else {\n        float float_to_decode_abs = abs(float_to_decode);\n        // We will transform float_to_decode to conveniently decode it, do it in a copy for clarity\n        float float_tmp = float_to_decode_abs;\n\n        // Exponent extraction (for all finite cases)\n        expf = floor(log2(float_tmp)); // float exponent without -127 offset (out parameter)\n        exp = int(expf) + 127; // IEEE754 encoded 8bits-wide exponent (out parameter)\n\n        // Extract the mantissa bit per bit, compute the fixed_point value simultaneously\n        // using only float values that are exactly represented in IEEE754 encoding (powers of two)\n        mant = 0; // IEEE754 23bits-wide mantissa as int without the leading implicit one\n        //fixed_point: limited range fixed point representation with 8 decimals for floats in [-1e10-1 ; 1e10-1]\n        fixed_point = debug_decode_float_mantissa_to_fixed_point(expf);\n        // The 1 is always implicit in the sense that no bit represent it in the mantissa nor exponent bitfields\n        float mantissa_implicit_one = pow(2.0, expf);\n        for ( int i=1; i<24; i++ ) {\n            mant = mant << 1;\n            float mantissa_pow = expf - float(i);\n            float mantissa_fractionnal = pow(2.0, mantissa_pow); // All power of two are exactly representable (mant==0, exp varies)\n            float crible = mantissa_implicit_one + mantissa_fractionnal;\n            if ( float_tmp >= crible ) {\n                float_tmp -= mantissa_fractionnal;\n                mant = mant | 1;\n                // Fixed point is split into integer part and fractionnal part\n                // The way the floats are encoded garantee there is not carry to handle between those two parts\n                fixed_point += debug_decode_float_mantissa_to_fixed_point(mantissa_pow);\n            }\n        }\n        //TODO may the user want to round are arbitrary number of digit, allow it, this may lead to carry for fixed_point[0]\n        // Manually round fixed_point fractionnal part from 9 to 8 digits because the 9th digit\n        //  is not always exact with the table we use (and we can't put 5e9 in int)\n        int to_be_rounded = fixed_point[1];\n        if ( to_be_rounded % 10 >= 5 ) to_be_rounded += 10;\n        fixed_point[1] = to_be_rounded / 10;\n\n        // To ease a rudimentary printf(\"%f\",x) this function output glyph_index, the character index to display at wanted_digit position\n        //TODO make number of digits on integer and fractionnal part configurable by the user (max 9 and 8)\n        /* Note: next if() need to be at least as restrictive as preconditions\n         * of debug_decode_float_mantissa_to_fixed_point() to not display wrong results\n         */\n        if ( float_to_decode_abs >= 0.00000001 && float_to_decode_abs < 1000000000.0 ) {\n            // print a natural form\n            glyph_index = debug_format_float_finite_values_natural_form(sign, fixed_point, wanted_digit);\n        } else {\n            // print using scientific notation like -1e12 or +1e-36 or sci_m * 10^sci_n\n            glyph_index = debug_format_float_finite_values_scientific_form(sign, float_to_decode_abs, wanted_digit);\n        }\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}