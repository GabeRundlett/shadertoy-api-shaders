{
    "Shader": {
        "info": {
            "date": "1673443533",
            "description": "Cubemap To spherical map",
            "flags": 0,
            "hasliked": 0,
            "id": "ctSGzG",
            "likes": 4,
            "name": "Cubemap To HDRi map",
            "published": 3,
            "tags": [
                "camera",
                "cubemap",
                "map",
                "spherical",
                "hdri"
            ],
            "usePreview": 0,
            "username": "shaofun",
            "viewed": 1571
        },
        "renderpass": [
            {
                "code": "// #define USE_CAMERA\n\nvec2 spherical_map(vec3 p) {\n    vec2 uv = vec2(atan(p.z, p.x), asin(p.y));\n    uv *= vec2(1.0 / TAU, 1.0 / PI); uv += 0.5;\n    return uv;\n}\n\nvec3 spherical_map(vec2 uv) {\n    uv -= 0.5; uv *= vec2(TAU, PI);\n    vec2 s = sin(uv), c = cos(uv);\n    return vec3(c.x*c.y, s.y, s.x*c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv    = fragCoord / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    if (all(equal(mouse, vec2(0)))) mouse = vec2(0.5);\n\n#if defined(USE_CAMERA)\n    camera cam;\n    cam.lookfrom = vec3(0, 0, 0);\n    cam.lookat   = CameraRotation((mouse - 0.5) * vec2(PI)) * vec3(0, 0, 1);\n    cam.aspect   = iResolution.x / iResolution.y;\n    cam.vfov     = 50.0;\n    cam.vup      = vec3(0, 1, 0);\n    cam.focus    = 1.0;\n    cam.aperture = 0.0;\n    \n    vec3 p = spherical_map(uv);\n    \n    vec2 uvv = spherical_map(p);\n    \n    ray r = get_ray(cam, uvv, vec3(1));\n    \n    vec3 col = texture(iChannel0, r.direction).rgb;\n#else\n    vec3 p = spherical_map(uv);\n    p *= CameraRotation((mouse - 0.5) * vec2(PI));\n    \n    vec3 col = texture(iChannel0, p).rgb;\n#endif\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// 数学常量\nconst float ZERO = 0.0;\nconst float PI   = 3.141592653589;\nconst float TAU  = 2.0 * PI;\n\nstruct ray {\n    vec3 origin;        // 光的起点\n    vec3 direction;     // 光的方向\n    vec3 color;         // 光的颜色\n};\n\nstruct camera {\n    vec3  lookfrom;     // 视点位置\n    vec3  lookat;       // 目标位置\n    vec3  vup;          // 向上的方向\n    float vfov;         // 视野\n    float aspect;       // 传感器长宽比\n    float aperture;     // 光圈大小\n    float focus;        // 对焦距离\n};\n\nfloat seed; // 随机数种子\n\n// 用随机数种子产生归一化的随机数\nfloat rand13(vec3 x) {\n    uvec3 p = floatBitsToUint(x);\n    p = 1103515245U * ((p.xyz >> 1U) ^ (p.yzx));\n    uint h32 = 1103515245U * ((p.x ^ p.z) ^ (p.y >> 3U));\n    uint n = h32 ^ (h32 >> 16U);\n    return float(n) * (1.0 / float(0xffffffffU));\n}\n\nfloat rand11() {\n    uvec2 n = floatBitsToUint(seed++) * uvec2(1597334673U, 3812015801U);\n    uint q = (n.x ^ n.y) * 1597334673U;\n    return float(q) * (1.0 / float(0xffffffffU));\n}\n\nvec2  rand21() {\n    uvec2 n = floatBitsToUint(seed++) * uvec2(1597334673U, 3812015801U);\n    n = (n.x ^ n.y) * uvec2(1597334673U, 3812015801U);\n    return vec2(n) * (1.0 / float(0xffffffffU));\n}\n\n// 光子在射线所在的位置\nvec3 at(ray r, float t) {\n    return r.origin + t * r.direction;\n}\n\n// 单位圆内随机取一点\nvec2 random_in_unit_disk() {\n    vec2 r = rand21() * vec2(1.0, TAU);\n    return sqrt(r.x) * vec2(sin(r.y), cos(r.y));\n}\n\nray get_ray(camera c, vec2 uv, vec3 color) {\n    // 根据 VFOV 和显示画布长宽比计算传感器长宽\n    float theta = radians(c.vfov);\n    float half_height = tan(theta * 0.5);\n    float half_width = c.aspect * half_height;\n    \n    // 以目标位置到摄像机位置为 Z 轴正方向\n    vec3 z = normalize(c.lookfrom - c.lookat);\n    // 计算出摄像机传感器的 XY 轴正方向\n    vec3 x = normalize(cross(c.vup, z));\n    vec3 y = cross(z, x);\n    \n    vec3 hwfx = half_width  * c.focus * x;\n    vec3 hhfy = half_height * c.focus * y;\n    \n    vec3 lower_left_corner = c.lookfrom - hwfx - hhfy - c.focus * z;\n    \n    vec3 horizontal = 2.0 * hwfx;\n    vec3 vertical   = 2.0 * hhfy;\n    \n    // 模拟光进入镜头光圈\n    float lens_radius = c.aperture * 0.5;\n    vec2 rud = lens_radius * random_in_unit_disk();\n    vec3 offset = x * rud.x + y * rud.y;\n    \n    // 计算光线起点和方向\n    vec3 ro = c.lookfrom + offset;\n    vec3 po = lower_left_corner + uv.x * horizontal\n                                + uv.y * vertical;\n    vec3 rd = normalize(po - ro);\n    \n    return ray(ro, rd, color);\n}\n\nmat3 CameraRotation(vec2 m) {\n    m *= mat2(vec2(0, -1), vec2(1, 0));\n    vec2 s = sin(m), c = cos(m);\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.x, s.x, 0.0, -s.x, c.x);\n    mat3 rotY = mat3(c.y, 0.0, -s.y, 0.0, 1.0, 0.0, s.y, 0.0, c.y);\n    \n    return rotY * rotX;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}