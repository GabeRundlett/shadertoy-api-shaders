{
    "Shader": {
        "info": {
            "date": "1611712187",
            "description": "Abstract Skyscrapers in two point perspective.",
            "flags": 0,
            "hasliked": 0,
            "id": "wlKyWG",
            "likes": 4,
            "name": "Skyscrapers, 2D Perspective",
            "published": 3,
            "tags": [
                "skyscrapers",
                "twopoint",
                "perspectie"
            ],
            "usePreview": 0,
            "username": "mherreshoff",
            "viewed": 292
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159\n#define hash33(p) fract(sin( (p) * mat3( 127.1,311.7,74.7 , 269.5,183.3,246.1 , 113.5,271.9,124.6) ) *43758.5453123)\n\n// See: https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q= abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nstruct result {\n    float dist;\n    vec3 color;\n};\n\n#define STREET_SZ 2.\nresult map(vec3 v, vec3 dv) {\n    vec2 cell = floor(v.xy);\n    result r;\n    r.dist = 1e38;\n    for (int dy = -1; dy <= 1; dy++) {\n        for (int dx = -1; dx <= 1; dx++) {\n            vec2 cell2 = cell + vec2(float(dx), float(dy));\n            vec3 rand = hash33(vec3(cell2, 0));\n            float height = 2.+floor(4.*rand.x);\n            if (rand.y > .99) height += 5.;\n            \n            if (mod(cell2.x, 10.) < STREET_SZ || mod(cell2.y, 10.) < STREET_SZ) height = 0.;\n            \n            float dist = sdBox(v-vec3(cell2.x+.5, cell2.y+.5, 0), vec3(.3,.3,height));\n            if (dist < r.dist) {\n                r.dist = dist;\n                r.color = vec3(.25+.75*rand.z);\n            }\n        }\n    }\n    r.dist = min(r.dist, 1.);\n\n    float mx = mod(v.x, 10.), my = mod(v.y, 10.);\n    if (mx < STREET_SZ) { // If we're in an alley, we know we can skip ahead.\n        if (dv.x < 0.) r.dist = max(r.dist, -mx/dv.x);\n        if (dv.x > 0.) r.dist = max(r.dist, (STREET_SZ-mx)/dv.x);\n    }\n\n    if (my < STREET_SZ) { // If we're in an alley, we know we can skip ahead.\n        if (dv.y < 0.) r.dist = max(r.dist, -my/dv.y);\n        if (dv.y > 0.) r.dist = max(r.dist, (STREET_SZ-my)/dv.y);\n    }\n    return r;\n}\n\nvec4 rayMarch(vec3 v, vec3 dv, vec4 sky) {\n    float totalDist = 0.;\n    for (int i = 0; i < 800; i++) {\n        result r = map(v, dv);\n        if (r.dist <= .01) return vec4(r.color, 0);\n        v += r.dist*dv;\n        totalDist += r.dist;\n        if (v.z < 0.1) return vec4(0,0,0,1);\n        //if (totalDist >= 100.) break;\n        \n    }\n    if (dv.z < 0. && -v.z/dv.z < 10.) return vec4(0,0,0,1);\n    \n    return sky;\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 R = iResolution.xy, uv = (U - 0.5*R)/R.y;\n    float t = iTime*.1, m = mod(t, 2.);\n    float cx = 10.*(t - m + 2. * clamp(m, 0., 1.));\n    float cy = 10.*(t - m + 2. * clamp(m-1., 0., 1.));\n    vec3 camera = vec3(cx, cy, 3.);\n    float theta = PI/4. + uv.x*(PI/3.);\n    vec3 dv = normalize(vec3(cos(theta), sin(theta), uv.y));\n    vec4 sky = vec4(0., .8, 1., 1.);\n    O = rayMarch(camera, dv, sky);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}