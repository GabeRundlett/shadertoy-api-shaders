{
    "Shader": {
        "info": {
            "date": "1683253711",
            "description": "Inspired by / Remix of \"ice and fire\" by mattz (https://www.shadertoy.com/view/MdfBzl)",
            "flags": 0,
            "hasliked": 0,
            "id": "cldGDf",
            "likes": 12,
            "name": "Triangle Gradient Background",
            "published": 3,
            "tags": [
                "2d",
                "triangles",
                "gradient",
                "background"
            ],
            "usePreview": 0,
            "username": "kbnt",
            "viewed": 288
        },
        "renderpass": [
            {
                "code": "/* \n   Triangle Gradient Background by kbnt\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   Inspired by / Remix of \"ice and fire\" by mattz (https://www.shadertoy.com/view/MdfBzl)\n*/\n\nconst float scaleAmnt = 6.2;\nconst float motionSpeed = 0.1;\nconst float motionSize  = 0.45; // max 0.5\nconst float colourSpeed = 0.1;\n\n/*\nconst float s6  = 0.866025388240814208984; // sin(60)\nconst float ti6 = 0.577350258827209472656; // cos(60) / sin(60)\nconst float si6 = 1.154700517654418945310; // 1 / sin(60)\n\nconst mat2 tri2cart = mat2(s6, -0.5, 0, 1);\nconst mat2 cart2tri = mat2(si6, ti6, 0, 1);\n/**/\n\n/**/\nconst float s3 = 1.7320508075688772; // 2 * sin(60)\nconst float i3 = 0.5773502691896258; // tan(60)\n\nconst mat2 tri2cart = mat2(1.0, 0.0, -0.5, 0.5*s3);\nconst mat2 cart2tri = mat2(1.0, 0.0, i3, 2.0*i3);\n/**/\n\n/*\nconst mat2 tri2cart = mat2(1, 0, 0, 1);\nconst mat2 cart2tri = mat2(1, 0, 0, 1);\n/**/\n\n//////////////////////////////////////////////////////////////////////\n// cosine based palette \n// adapted from https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return clamp(a + b*cos( 6.28318*(c*t+d) ), 0.0, 1.0);\n}\n\nvec3 pala(in float t) {\n    return pal( t, vec3(0.5),vec3(0.5),vec3(0.8, 0.8, 0.5),vec3(0, 0.2, 0.5) );\n}\n\nvec3 colourForPoint(vec2 uv) {\n    float t = colourSpeed*iTime;\n    \n    // pallet sample\n    vec3 col00 = pala( t+0.00 );\n    vec3 col01 = pala( t+0.25 );\n    vec3 col11 = pala( t+0.50 );\n    vec3 col10 = pala( t+0.75 );\n    \n    // mix colours\n    vec3 colorA = mix(col00,col10,uv.x);\n    vec3 colorB = mix(col01,col11,uv.x);\n    return mix(colorA, colorB, uv.y);\n}\n\n//////////////////////////////////////////////////////////////////////\n// from https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);   \n}\n\nvec2 hash23(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// generate a random point on a circle from 3 integer coords (x, y, t)\n\nvec2 randCircle(vec3 p) {\n    \n    vec2 rt = hash23(p);\n    \n    float r = sqrt(rt.x);\n    float theta = 6.283185307179586 * rt.y;\n    \n    return r*vec2(cos(theta), sin(theta));\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// make a time-varying cubic spline at integer coords p that stays\n// inside a unit circle\n\nvec2 randCircleSpline(vec2 p, float t) {\n\n    // standard catmull-rom spline implementation\n    float t1 = floor(t);\n    t -= t1;\n    \n    vec2 pa = randCircle(vec3(p, t1-1.0));\n    vec2 p0 = randCircle(vec3(p, t1));\n    vec2 p1 = randCircle(vec3(p, t1+1.0));\n    vec2 pb = randCircle(vec3(p, t1+2.0));\n    \n    vec2 m0 = 0.5*(p1 - pa);\n    vec2 m1 = 0.5*(pb - p0);\n    \n    vec2 c3 = 2.0*p0 - 2.0*p1 + m0 + m1;\n    vec2 c2 = -3.0*p0 + 3.0*p1 - 2.0*m0 - m1;\n    vec2 c1 = m0;\n    vec2 c0 = p0;\n    \n    return (((c3*t + c2)*t + c1)*t + c0) * 0.8;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// perturbed point from index\n\nvec2 triPoint(vec2 p) {\n    float t0 = hash12(p);\n    return tri2cart*p + motionSize*randCircleSpline(p, motionSpeed*iTime + t0);\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// https://stackoverflow.com/questions/2049582/how-to-determine-if-a-point-is-in-a-2d-triangle\n\nfloat sgn (vec2 p1, vec2 p2, vec2 p3)\n{\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\n\nbool PointInTriangle (vec2 pt, vec2 v1, vec2 v2, vec2 v3)\n{\n    float d1, d2, d3;\n    bool has_neg, has_pos;\n\n    d1 = sgn(pt, v1, v2);\n    d2 = sgn(pt, v2, v3);\n    d3 = sgn(pt, v3, v1);\n\n    has_neg = (d1 < 0.0) || (d2 < 0.0) || (d3 < 0.0);\n    has_pos = (d1 > 0.0) || (d2 > 0.0) || (d3 > 0.0);\n\n    return !(has_neg && has_pos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // scale from screen space to scene space\n    float scl = scaleAmnt / iResolution.y;\n   \n    // get 2D scene coords\n    vec2 p = (fragCoord - 0.5*iResolution.xy) * scl;\n    \n    // get triangular base coords\n    vec2 tfloor = floor(cart2tri * p + 0.5);\n\n    // precompute 9 neighboring points\n    vec2 pts[9];\n\n    for (int i=0; i<3; ++i) {\n        for (int j=0; j<3; ++j) {\n            pts[3*i+j] = triPoint(tfloor + vec2(i-1, j-1));\n        }\n    }\n    \n    vec2 center;\n    \n    // note: must look at 4 quads cause when the triangle our current  \n    //       pixel is in gets randomly nudged in the positive direction,\n    //       our pixel may end up in another triangle\n    // for each of the 4 quads:\n    for (int i=0; i<2; ++i) {\n        for (int j=0; j<2; ++j) {\n    \n            // look at lower and upper triangle in this quad\n            vec2 t00 = pts[3*i+j  ];\n            vec2 t10 = pts[3*i+j+3];\n            vec2 t01 = pts[3*i+j+1];\n            vec2 t11 = pts[3*i+j+4];\n          \n            // lower\n            if (PointInTriangle(p, t00, t10, t11)) \n                center = (t00 + t10 + t11) / 3.0; // get centeroid of triangle\n\n            // upper\n            if (PointInTriangle(p, t00, t11, t01))\n                center = (t00 + t11 + t01) / 3.0;\n           \n        }\n    }\n    \n    \n    // convert from scene space to uv to sample colour \n    center = center / scl;\n    center += 0.5*iResolution.xy;\n    center += 0.5;\n    center = center / iResolution.xy;\n    \n    vec4 col = vec4(colourForPoint(center), 1.0);\n    \n    // final pixel color\n    fragColor = col;\n    \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}