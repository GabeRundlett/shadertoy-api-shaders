{
    "Shader": {
        "info": {
            "date": "1650931595",
            "description": "playing with the an incomplete version of hexrosa that was tuned to work with n7",
            "flags": 0,
            "hasliked": 0,
            "id": "ftsBD4",
            "likes": 19,
            "name": "Forest Hexrosa",
            "published": 3,
            "tags": [
                "forest",
                "tiling",
                "bricks",
                "aperiodic",
                "hexrosa"
            ],
            "usePreview": 1,
            "username": "ufffd",
            "viewed": 479
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 50\n#define PI 3.141592653589793\n#define NORMAL_MAP false // true for overly expensive normal maps\n\nconst int nfold = 7;\nconst float hexH = 1.;\nconst int hexL = 6;\nvec2 center = vec2(0.);\nfloat initR = 0.;\nconst float angle1 = 1. / float(nfold) * PI * 2.;\nconst float angle2 = PI * 0.5 - angle1 / 2.;\nconst float sidelength = hexH / (2. * cos(0.5 * angle1) + 1.);\nconst float hexW = 2. * sidelength * sin(0.5 * angle1);\nconst float offX = hexW / 2.;\nconst float offY = sidelength + ((hexH - sidelength) / 2.);\n\nfloat hexSDF(in vec2 position) {\n    position /= vec2(sqrt(3.0), 1.5); // magic numbers\n    position.y -= 0.5;\n    position.x -= fract(floor(position.y) * 0.5);\n    position = abs(fract(position) - 0.5);\n    return abs(1. - max(position.x * tan(angle2) * 1.15 + position.y, position.x / hexW * 1.15)) * sqrt(3.) * 0.5; // magic numbers\n}\n\nfloat drawHex(in vec2 position, in float size) {\n    // position *= vec2(hexH,hexW)/hexH;\n    float sdf = hexSDF(position);\n    if (position.x < -0.5) sdf = 0.;\n    if (position.x > 0.5) sdf = 0.;\n    if (position.y < -0.5) sdf = 0.;\n    if (position.y > 0.5) sdf = 0.;\n    return smoothstep(size-0.002,size+0.002,sdf);\n}\n  \nfloat lineSDF( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nfloat drawLine(in vec2 p, in vec2 a, in vec2 b, in float lt) {\n    return 1.-smoothstep(0.0,lt,lineSDF(p, a, b));\n}\n\n\nfloat moveDot( in vec2 start, in vec2 end, in float dt, in float size, in vec2 uv) {\n    vec2 dotpos = mix(start,end,mod(dt,1.));\n    float dotstep = length(uv+dotpos);\n    return 1.0 - smoothstep(size,size+0.0001,dotstep);\n}\n\nvec3 drawHexrosa(in vec2 uv, in float thic) {\n    // incomplete version of hexrosa, tuned to work with n7\n    vec3 color = vec3(0.);\n    \n    float dt = iTime * 0.5;\n    \n    float lines = 0.;\n        // dot positions of hexagon edge. magic numbers, the lot of them\n        float xedge = 0.0317 * 2.;\n        float y12 = 0.139 * 1.46;\n        float y1 = 0.139;\n        float y2 = 0.139 * 0.55;\n        float y3 = 0.;\n\n        // points, clock wise (12 at top)\n        vec2 p12 = vec2(0.,y12);\n        vec2 p1 = vec2(xedge/2.,y1);\n        vec2 p2 = vec2(xedge,y2);\n        vec2 p3 = vec2(xedge,y3);\n        vec2 p4 = vec2(xedge,-y2);\n        vec2 p5 = vec2(xedge/2.,-y1);\n        vec2 p6 = vec2(0.,-y12);                    \n        vec2 p7 = vec2(-xedge/2.,-y1);\n        vec2 p8 = vec2(-xedge,-y2);                    \n        vec2 p9 = vec2(-xedge,y3);\n        vec2 p10 = vec2(-xedge,y2);\n        vec2 p11 = vec2(-xedge/2.,y1);\n                    \n        float lt = thic*0.002;\n    \n    //the hex rosa is made of 2 sets of nfold# of what I call 'branches'. a branch is a single triangular array of 'seeds' drawn as 'hexes' (base hexagons shapes)\n    //this loop doubles the process for each set of branches\n    for(int outset=0;outset<2;outset++){    \n        vec2 ouv = uv;\n        ouv *= Rot(float(outset) * PI / float(nfold));\n        //this loop divides the circle by nfold# and draws that many branches, evenly spaced\n        for (int branch=0;branch<nfold;branch++){\n            vec2 buv = ouv;\n            buv *= Rot(angle1 * float(branch));\n            buv.y -= .08 / float(nfold); // magic numbers\n            buv.y += sidelength * float(outset) * 0.41; // magic numbers\n            //this loop sets and positions the row being drawn in the current branch\n            for (int row=0;row<hexL;row++) { // the hexagonal loop could probably be optimized\n                //this loop sets and positions the individual seed being drawn in the current row\n                for (int col = row * -1; col <= row; col += 2) {\n                    vec2 huv = buv;\n                    vec2 hexcenter = vec2(float(col)*offX,float(row)*offY) * 0.41;\n                    huv += hexcenter; // magic numbers\n                    huv.y += offY/PI;\n                    \n                    float mainhex = drawHex(huv, 0.749); // magic numbers\n                    color += mainhex * 0.8;\n                    \n                    lines += drawLine(huv,p12,p2,lt);\n                    lines += drawLine(huv,p12,p10,lt);\n                    lines += drawLine(huv,p2,p8,lt);\n                }            \n            }            \n        }\n    }\n    \n    color = vec3(lines);\n    \n    return clamp(color, vec3(0.),vec3(1.));\n}\nvec3 drawHexrosa(in vec2 uv) {\n    return drawHexrosa(uv, 5.);\n}\n\nstruct March \n{\n    float dist;\n    int mater;\n    bool hit;\n    vec3 p;\n};\n\n// array of structs not working, neither is declaring mat1\n// struct Mater\n// {\n//     vec3 col;\n// };\n\n// Mater mat1;\n// mat1.col = vec3(1.,0.,0.);\n\nvec3 mat1 = vec3(1.,0.,0.);\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdCube( vec3 p, float b ) {\n    return sdBox(p,vec3(b));\n}\nfloat sdCutSphere( vec3 p, float r, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n  return (s<0.0) ? length(q)-r :\n         (q.x<w) ? h - q.y     :\n                   length(q-vec2(w,h));\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat Bounce3(float x, float base) {\n    \n    x = -log(1.-x)/log(base);\n    x -= (1.-pow(base, -.5)) / (1.-1./base);\n    \n    float i = floor(x);\n\n    x = fract(x);\n    \n    x = (1.-pow(base, -x)) / (1.-1./base);\n    float bounce = -4.*x*(x-1.);\n    \n    bounce /= pow(base*.8, i+1.);\n    return .4*bounce;   \n}\n\nMarch map(in vec3 p, in int mode) {\n    float d = 1000.;\n    int mater = -1;\n    \n    if (mode==0) {\n\n        float floatyT = sin(PI * 1.5 + iTime * 0.5); // timing of floaters\n        float floatheight = 1.25 + 0.5 * floatyT; // float up\n        if (mod(iTime*0.5,PI*2.)/(PI*2.) > 0.5) { // hover at top\n            floatheight = 1.75;\n        }\n        if (mod(iTime*0.5,PI*2.)/(PI*2.) > 0.75) { // fall\n            // floatheight = Bounce3(fract(iTime*0.5), 0.5);\n            floatheight = .75 + 2.5*Bounce3(fract(iTime*0.5*(2./PI)), 0.7);\n        }\n        vec3 floatyp = p - vec3(0.,floatheight,0.);\n        float ballsize = sin(PI*1.5+iTime*0.25)*0.5;\n        ballsize = clamp(ballsize+0.15, 0.05, 0.2);\n        float ball = length(floatyp)-ballsize;\n        if (ball < d) mater = 1;\n        // d = min(d,ball);\n\n        floatyp.xz *= Rot(iTime + sin(PI*1.15+iTime*0.5)*1.8);\n        if (mod(iTime * 0.5, PI*2.) < PI) \n            floatyp.xy *= Rot(iTime * 0.25);\n        // floatyp.yz *= Rot(iTime * 0.08);\n        float cubesize = sin(PI*.5+iTime*0.25)*0.5;\n        cubesize = clamp(cubesize+0.15, 0.05, 0.15);\n        float cube = sdCube(floatyp,cubesize) - 0.02;\n        if (cube < d) mater = 1;\n        // d = min(d,cube);\n        d = min(d,smin(cube,ball,0.1));\n    }\n    \n    float brickfloor = p.y - .6;\n    if (brickfloor < d) mater = 2;\n    d = min(d, brickfloor);\n    \n    vec3 rock1p = p;\n    rock1p.x = mod(rock1p.x - 2., 2.) + 2.;\n    rock1p.z = mod(rock1p.z - 1.5, 2.) + 1.5;\n    rock1p.y *= 1.1;\n    float rocksize = noise(p.xz*3.)*0.4;\n    rocksize *= smoothstep(3.,4.,length(p.xz));\n    float rock1 = length(rock1p-vec3(2.5,0.55,2.))-rocksize;\n    rock1 -= noise(p.xz*5.) * 0.2;\n    rock1 -= noise(p.xz*8.) * 0.1;\n    if (rock1 < d) mater = 4;\n    d = min(d, rock1);\n    \n    vec3 mush1p = p;\n    mush1p.xz *= Rot(0.5);\n    mush1p.xz += 3. + sin(p.x) * 0.2;\n    mush1p.y -= .6;\n    float mush1s = .2;\n    // mush1p.x = mod(mush1p.x - 1., 2.) + 1.;\n    mush1p.z = mod(mush1p.z, 3.) - 1.5;\n    mush1p.x = mod(mush1p.x, 3.) - 1.5;\n    mush1p.x += sin(p.z)*0.2;\n    mush1p.z += sin(p.x)*0.2;\n    float mush_stem = sdVerticalCapsule(vec3(mush1p),0.8*mush1s,0.08*mush1s);\n    float mush = mush_stem;\n    float mush_cap = length(mush1p-vec3(0.,1.*mush1s,0.))-.1*mush1s;\n    mush_cap = sdCutSphere(mush1p-vec3(0.,1.*mush1s,0.), .25*mush1s, 0.);\n    mush = min(mush, mush_cap);\n    if (mush < d) mater = 5;\n    d = min(d, mush);\n    \n    float clsize = 0.09;\n\n    if (length(p.xz) > 2.) {\n    for (int j=0;j<3;j++) {\n    \n        vec3 cloverp = p - vec3(1.,.6,0.);\n\n        cloverp *= 0.5 + float(j)/8.;\n        cloverp.x += float(j);\n\n        cloverp.xz *= Rot(0.8 + 0.3*sin(length(cloverp.xz)));\n        cloverp.x = mod(cloverp.x, .8) - 0.15;\n        // cloverp.y = mod(cloverp.z, .3) - 0.15;\n        cloverp.z = mod(cloverp.z, .8) - 0.15;\n        cloverp.xz *= Rot(noise(p.xz) * 5.);\n\n        cloverp.x += sin(p.x + iTime*0.5) * cloverp.y * .3;\n        cloverp.z += sin(p.x + iTime*0.22) * cloverp.y * .2;\n        //\n        // cloverp.x += noise(p.xz) * 0.05;\n        \n        \n        // cloverp.x += cloverp.y;\n\n        float cloverstem = sdVerticalCapsule(vec3(cloverp),clsize*0.6,clsize*0.05);\n        float clover = min(cloverstem, 2000.);\n        cloverp.xz *= Rot(0.2);\n        float cloverleaf1 = sdCappedCylinder(cloverp - clsize*vec3(.2,.7,0.),clsize*0.18,clsize*0.02) - 0.01*clsize;\n        cloverp.yz *= Rot(-0.1);\n        float cloverleaf2 = sdCappedCylinder(cloverp - clsize*vec3(-.08,.69,-.12),clsize*0.18,clsize*0.018) - 0.01*clsize;\n        cloverp.xy *= Rot(0.1);\n        float cloverleaf3 = sdCappedCylinder(cloverp - clsize*vec3(-.08,.69,.12),clsize*0.18,clsize*0.015) - 0.01*clsize;\n        clover = min(clover, cloverleaf1);\n        clover = min(clover, cloverleaf2);\n        clover = min(clover, cloverleaf3);\n        if (clover < d) mater = 3;\n        d = min(d, clover);\n        \n        \n    }\n    }\n    \n    March result;\n    result.dist = d;\n    result.mater = mater;\n    result.hit = d < 0.0001;\n    result.p = p;\n    \n    return result;\n}\nMarch map(in vec3 p) {\n    return map(p,0);\n}\n\nMarch raymarch(in vec3 ro, in vec3 rd, in int steps, in int mode) {\n    March march; // initialize result struct\n    vec3 p;\n    float d = 0.;\n    for (int i=0;i<steps;i++){\n        p = ro + rd * d;\n        march = map(p,mode);\n        d += march.dist;\n        if (march.hit) break;\n        if (march.dist > 100.) break;\n    }\n    return march;\n}\n\nMarch raymarch(in vec3 ro, in vec3 rd) {\n    return raymarch(ro,rd,MAX_STEPS, 0);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = map(p).dist;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        map(p-e.xyy).dist,\n        map(p-e.yxy).dist,\n        map(p-e.yyx).dist);\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p, vec3 n) {\n    float floatyT = sin(PI*1.5 + iTime * 0.5); // timing of floaters\n    vec3 lightPos = vec3(0., 2. + 0.5*floatyT, 0.);\n    vec3 l = normalize(lightPos-p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = raymarch(p+n*0.0001*2., l, 60, 1).dist;\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\nfloat GetLight(vec3 p) {\n    vec3 n = GetNormal(p);\n    return GetLight(p,n);\n}\n\nvec2 hexrosaNormal(in vec2 uv) { // expensive, ~33% GPU\n    if (!NORMAL_MAP) return vec2(0.);\n    float s = 0.001;\n    \n    float p = drawHexrosa(uv,7.).r;\n    float h1 = drawHexrosa(uv + vec2(s,0),7.).r;\n    float v1 = drawHexrosa(uv + vec2(0,s),7.).r;\n       \n   \treturn (p - vec2(h1, v1)) * 10.;\n}\n\nvec3 getCol(in March march) {\n    vec3 col = vec3(0.);\n    vec3 norm = GetNormal(march.p);\n    if (march.mater == 1) {\n        col = vec3(0.95,0.94,0.99);\n    }\n    if (march.mater == 2) {\n        vec3 hexrosa = drawHexrosa(march.p.xz * .4);\n        col = 1. - hexrosa;\n        vec3 bricktexture = texture(iChannel0,march.p.xz * 0.1 * iResolution.x/800.).rgb;\n        col *= bricktexture * vec3(.9,0.8,0.6);\n        vec2 hexnorm = hexrosaNormal(march.p.xz * .4);\n        norm.rg += hexnorm;\n        \n    \n        // grass zone\n        vec2 grasslim = march.p.xz * 0.5 - 0.5;\n        grasslim += texture(iChannel0,march.p.xz).rb;\n        grasslim += texture(iChannel0,march.p.xz * 0.05).rb - 0.5;\n        float grasszone = length(grasslim) - 1.1;\n        grasszone = clamp(grasszone,0.,1.);\n\n        vec3 grass = texture(iChannel0,march.p.xz * Rot(0.5) * .5).rgb * vec3(0.1,0.5,0.1);\n        grass -= texture(iChannel0,march.p.xz * Rot(-0.5) * .1).rgb * vec3(0.05,0.3,0.05);\n        col = mix(col,grass,grasszone);\n\n        // col = vec3(grasszone);\n        \n        float mossbricks = grasszone * hexrosa.r * (1. - grasszone);\n        mossbricks += mossbricks;\n        mossbricks *= mossbricks;\n        col.g += mossbricks;\n        \n        float floatyT = min(1.25,sin(PI*1.75 + iTime * 0.5) + 0.75); // timing of floaters\n        \n        float glowbricks = hexrosa.r * (1. - grasszone);\n        col.r += clamp(glowbricks * (2.*floatyT - length(march.p.xz)),0.,1.);\n        \n        float glowbricksfine = drawHexrosa(march.p.xz * .4,3.).r * (1. - grasszone);\n        col.g += clamp(glowbricksfine * glowbricksfine * (1.5*floatyT - length(march.p.xz)),0.,1.);\n        \n        \n        float glowbrickscenter = hexrosa.r * (1. - grasszone);\n        col.b += clamp(glowbricksfine * glowbricks * (1.*floatyT - length(march.p.xz)),0.,1.);\n        \n    }\n    if (march.mater == 3) { // clovers\n        col = vec3(0.01,0.25,0.05);\n    }\n    if (march.mater == 4) { // rocks\n        vec3 bricktexture = texture(iChannel0,march.p.xz * 0.1).rgb;\n        col = vec3(1.);\n        col *= bricktexture * vec3(0.6,0.57,0.49);\n        col.g += smoothstep(0.2,.45,1.-march.p.y) * 0.11;\n        col.g += smoothstep(0.35,.45,1.-march.p.y) * 0.6;\n        col -= smoothstep(0.35,.45,1.-march.p.y) * 0.5;\n        col *= (1. - smoothstep(0.3,.4,1.-march.p.y) * 0.5);\n        col *= 0.6+march.p.y*march.p.y;\n    }\n    if (march.mater == 5) { // mushies\n        col = vec3(0.86,0.7,0.5);\n        col = mix(col,col*norm.g,0.6);\n        col += 1.-march.p.y*1.6;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 col = vec3(0.);\n    vec2 uv = (2.*fragCoord - iResolution.xy ) / iResolution.y;\n    \n    // raymarch\n    vec3 ro = vec3(0.,5.,-3.);\n    vec3 rd = normalize(vec3(uv.x,uv.y,2.));\n    \n    float d = 0.;\n    ro.xz *= Rot(iTime*0.02);\n    // rd.yz *= Rot(0.5);\n    rd.yz *= Rot(1.);\n    \n    rd.xz *= Rot(iTime*0.02);\n    \n    March march = raymarch(ro,rd);\n    \n    if (march.hit) {\n        col = mat1;\n    }\n    \n    // for debugging\n    // if (march.mater == 5) {fragColor = vec4(1.,0.,0.,1.); return;}\n    \n    vec3 norm = GetNormal(march.p);\n    \n    col = getCol(march);\n    if (march.mater == 1) {\n        march.dist += 0.001;\n        // single bounce reflection\n        ro = ro + rd * march.dist;\n        rd = reflect(rd, norm);\n        March bounce = raymarch(ro,rd);\n        vec3 bouncecol = getCol(bounce);\n        // if (bounce.hit) col = getCol(bounce);\n        vec3 forest = texture(iChannel1,rd).rgb;\n        \n        float floatyT = sin(iTime * 0.5); // timing of floaters\n        bouncecol.r += floatyT * 0.7;\n        forest += floatyT * 0.5;\n        \n        col = mix(bouncecol,forest,smoothstep(0.4,0.5,norm.g));\n    }\n    \n    float shad = GetLight(march.p, norm);\n    shad = mix(shad,1.,0.8); // dim the lights\n    col *= shad;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nmat2 Rot(in float a) {\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}