{
    "Shader": {
        "info": {
            "date": "1627884030",
            "description": "Lot's of collecting constants, putting them in variables, and not trying to save the rainforest.\nYou can turn the samples up to 128 at the top if you have a very fast computer and want to see a higher quality image.",
            "flags": 0,
            "hasliked": 0,
            "id": "7l2XDm",
            "likes": 16,
            "name": "Intersection Circle - Circle",
            "published": 3,
            "tags": [
                "2d",
                "gi",
                "global",
                "illumination",
                "globalillumination",
                "pathtracing",
                "2dpathtracing",
                "illuminati"
            ],
            "usePreview": 1,
            "username": "Yusef28",
            "viewed": 443
        },
        "renderpass": [
            {
                "code": "\n/////////////////////////////////////////////////////////////\n//                                                         //\n// Author:Yusef28                                          //\n// Start Date: 28-07-2021                                  //\n// Status: On Going                                        //\n// Topic: Circle-Circle Intersection                       //\n// Sources: https://www.analyzemath.com/CircleEq           //\n//                      /circle_intersection.html          //\n//                                                         //\n// The original: https://www.shadertoy.com/view/lldcDf     //\n//                                                         //\n// Listening to: satellites - Familiar Shorelines [Album]  //\n//                                                         // \n/////////////////////////////////////////////////////////////\n\n//before I get into it, here is the main inspiration for this\n//effect https://www.shadertoy.com/view/lldcDf\n//some of the code has been \"borrowed\" like the add function \n//used to add objects to the distance field without returning \n//anything. It's pretty sleak.\n\n//If you have every tryed getting into path tracing but\n//didn't enjoy the learning curve, 2d pathtracing is a grate\n//way to get something on the screen fast and gain some \n//understanding.\n//\n//\n//I had a few false starts with the intersection code in this one. \n//Then I didn't want to upload too many at once so I spaced things\n//out. In doing so I stumbled on a cooler idea and decided to \n//apply it to this shader before uploading it.\n\n//So other than a basic circle x circle intersection I \n//am also path tracing everything in 2 dimentions to calculate\n//global illumination. So what that means is for every pixel \n//I take samples out in many \"random\" direction.Where here\n//it is actually just rays shot out offset by uniform angles + \n//the angle is offset by a random number. So from every pixel we\n//ge tthe 360 degree view of where the other objects are.\n\n//To do that we use raymarching of a 2d map. \n\n//Not sure how coherent I am right now since it's pretty late.\n//\n\n//somthing new to try\n#define numSamples 68.\n\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////      RayMarching Functions          //\n      //                                   //\n      /////////////////////////////////////\n      \n      \nfloat rnd(vec2 uv){\n    return fract(sin(dot(uv,\n        vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\nvoid add(float dist, vec3 color, inout float endDist, inout vec3 endColor){\n    if(dist < endDist){\n        endDist = dist;\n        endColor = color;\n    }\n}\n\nvoid map(vec2 uv, inout float d, inout vec3 color){\n\n      ////////////////////////////////////////////\n      //                                       //\n////////     INTERSECTION CALCULATIONS       //\n      //                                   //\n      /////////////////////////////////////\n    \n    \n    //centers for two circles\n    vec2 center1 = vec2(-4.*cos(iTime*1.),-3.*sin(iTime*2.));\n    vec2 center2 = vec2(.8*sin(iTime),.5*cos(iTime));\n    \n    //radius for 2 circles\n    float c1 = 2.; //radius 1\n    float c2 = 3.; //radius 2\n    \n    //x and y for each circle separate for algebra\n    float h1 = center1.x;\n    float k1 = center1.y;\n    float h2 = center2.x;\n    float k2 = center2.y;\n    \n    //and here we go...\n    \n    //So in order to solve for our firss term we need\n    //to do a similar thing to what we do with line segments.\n    //we set the standard form circle equations to equal\n    //each other and then shift everything to one side leaving\n    //0 on the other. Then we do the subtraction and notice\n    //only the second order variable terms x^2 and y^2 will cancel\n    //The result is a line equation (which maybe have some significance).\n    \n    //I go a step further by laying all the constant like-terms\n    //from this step into variables since they are constants. \n    //That makes future steps way more manageble.\n    \n    //so after setting the equality, and subtracting, I will..\n    //Well I set the x term but I can't show that step because\n    //it still has the unknown of \"y\" so I'll just set up the constants\n    //so after isolating x we have\n    \n    float k3 = k1 - k2;\n    float h3 = h1 - h2;\n    float c3 = k1*k1 - (k2*k2) + h1*h1 - (h2*h2) - (c1*c1) + (c2*c2);\n    // x = y*w - u where....\n    float w = -(k3/h3);\n    float u = -c3/(2.*h3);\n    \n    //and I've already worked out a,b and c so I'll go ahead and...\n    float a = w*w + 1.;\n    float b = 2.*(w*h1 + w*u + k1);\n    float c = (u*u) + 2.*u*h1 + k1*k1 - (c1*c1) + h1*h1;\n    \n    /*float w = (-2.*(k1-k2))/(2.*(h1-h2));\n    float u = k1*k1 - (k2*k2) + h1*h1 - (h2*h2) - (c1*c1) + (c2*c2);\n    \n    //and I've already worked out a,b and c so I'll go ahead and...\n    float a = w*w + 1.;\n    float b = w*w*h1 - w*u - k1;\n    float c = -(u*u) - 2.*u*h1 + k1*k1 - (c1*c1) + h1*h1;\n    */\n    \n    //the discriminant\n    float disc = b*b - 4.*a*c;\n    \n    //the two roots (or one or none de0pending)\n    float y1 = (-b + sqrt(disc))/(2.*a); //<-- this right here!!!!\n    float y2 = (-b - sqrt(disc))/(2.*a); //<-- If you forget bracket on (2.*a)...\n                                         //you're gonna have a bad experience.\n                                         \n    \n    //Note:\n    //You can factor out the \"2.\" from the \"b\" initialization\n    //and then the \"4.\" from the discriminant along with the \"2.\"\n    //from each of y1 and y2. Deleting all these is akin to\n    //things canceling and you end up with the same result\n    \n    //so what we did was kind of snuck past getting x, \n    //we got out of that and went for y while only having x\n    //in terms of y. Then we got out qaudtradic variables and solved the \n    //quadratic for 0-2 roots which will bw our y1 and y2\n    //now we'll swing back around and get the x's using our x = yw - u\n    //formula.\n   \n    float x1 = y1*w + u;\n    float x2 = y2*w + u;\n    //ja just like that and now...\n    //calculate the intersection points\n    \n    //I had to calculate everything again and somehow still ended up\n    //missing a sign somewhere because the points have the wrong sign.\n    //so I flip the sign of the points and there it is.\n    //I know what I did! I calculated everything with:\n    // (x + h)^2 + (y + k)^2 = c^2\n    // it should have been -h and -k\n    // so flipping the sign of the coordinates at the end is the same\n    // as flipping the signs of the centers\n    vec2 intersectionPoint1 = -vec2(x1,y1);\n    vec2 intersectionPoint2 = -vec2(x2,y2);\n        \n        \n      ////////////////////////////////////////////\n      //                                       //\n////////        DRAWING EVERYTHING           //\n      //                                   //\n      /////////////////////////////////////\n    \n    \n    //This time everything is happening in the distance\n    //estimation map so I use all the algebra above\n    //in the basic process of finding the closest object\n    \n    d = 1e9;\n    color = vec3(0.0);\n    float f;\n    \n    float radicalLine = -uv.x +(uv.y*w - u);//adjusted because of \n    //the sign error above\n    \n    \n    \n    //circle at center1\n    \n    f = abs(length(uv-center1)-c1);\n    add(f,vec3(0.8,0.3,0.7)/4., d, color);\n    \n    //circle at center2\n    //f = 1.-smoothstep(0.02,0.04,abs(length(uv-center2)-c2));\n    \n    if(length(uv-center1) > c1){\n    f = abs(length(uv-center2)-c2);\n    add(f,vec3(0.2,0.5,0.9)/3., d, color);\n    }\n    \n    if(disc >= 0.){\n    \n    //intersection pointss\n    f = abs(length(uv-intersectionPoint1)-0.12);\n    add(f,vec3(0.6,0.7,1.)*2., d, color);\n    f = abs(length(uv-intersectionPoint2)-0.12);\n    add(f,vec3(0.6,0.7,1.)*2., d, color);\n\n    \n    }\n    \n    f = abs(length(uv-vec2(7.,4.*sin(iTime)))-0.5);\n    add(f,vec3(1.,1.,0.7), d, color);\n    f = abs(length(uv+vec2(7.,4.*cos(iTime)))-0.5);\n    add(f,vec3(1.4,0.9,.5), d, color);\n\n}\n\nfloat trace(vec2 ro, vec2 rd, inout vec3 color, vec3 grid){\n    float t = 0.;\n    \n    for(float i = 0.;i<30.;i++){\n        \n        float d;\n        map(ro + rd*t, d, color);\n        //if(d<0.0001)return;\n        \n        //if(d>10.)break;\n        if(d <0.0001 || t > 10.) break;\n        \n            t += d;\n    }\n    \n    if(t > 10.)color = grid;//if no hit at this point, draw background grid\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5,0.5)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n    \n      ////////////////////////////////////////////\n      //                                       //\n////////      BACKGROUND GRID DESIGN         //\n      //                                   //\n      /////////////////////////////////////\n      \n      \n    vec2 st = uv;//save the unscaled uv\n    //I'm only making an 8(*aspect)x8 grid, higher variables\n    //may end up with graphs completely outside it\n    uv*=8.;\n    //graph background\n    vec3 col = vec3(0.);\n    //center highlights\n    col = mix(col,vec3(0.16),1.0-length(uv/8.));\n    //dust \n    float specks = fract(sin(dot(uv,vec2(123.,16.)))*43343.);\n    //nice soft texture \n    float tex = texture(iChannel0,st).x;\n    col = mix(col,vec3(0.25),pow(tex,2.));\n    //small grid lines\n    vec2 lines = fract(uv*5.);\n    lines = smoothstep(0.45,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.3),lines.x);\n    col = mix(col,vec3(0.3),lines.y);\n    //larger grid lines\n    lines = fract(uv);\n    lines = smoothstep(0.47,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.5),lines.x);\n    col = mix(col,vec3(0.5),lines.y);\n    //axis lines\n    lines = smoothstep(0.0,0.02,abs(uv));\n    col = mix(col,vec3(0.6),1.0-lines.x);\n    col = mix(col,vec3(0.6),1.-lines.y);\n    //col = mix(col,vec3(0.1),step(0.1,specks)*0.2);\n    \n    vec3 grid = col/2.;\n      //marching\n      \n    uv = (fragCoord-iResolution.xy*0.5)/iResolution.y*10.;\n    vec2 ro = uv;\n    vec2 rd;\n    vec3 tmpColor;\n    float t;\n    vec3 marchColor = vec3(0.);\n    \n    // Time varying pixel color\n    for(float i = 0.; i < numSamples; i++){\n        float angle = ( i + rnd( uv + float(i)) ) / numSamples*3.1415*2. ;\n        \n        rd = vec2(cos(angle),sin(angle));\n        //I give the grid design to the trace function\n        t = trace(ro, rd, tmpColor,grid);\n        marchColor += tmpColor;\n    }\n    \n\n    \n    \n    marchColor/=(numSamples);\n    col = marchColor*2.;//mix(col,marchColor,mask);\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    \n    \n      ////////////////////////////////////////////\n      //                                       //\n////////          POST PROCESSING            //\n      //                                   //\n      /////////////////////////////////////\n        \n    col = pow(col,vec3(0.75));\n    \n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    // Output to screen\n    fragColor = vec4(col*vig,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}