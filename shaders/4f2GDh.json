{
    "Shader": {
        "info": {
            "date": "1704164881",
            "description": "a mandelbulb that looks frosted like ice or glass, that has videos playing _inside_\n\ndrag your own videos / images in here: https://jakedowns.github.io/starpages/webgl2.html\n\nbased on this one from 10 years ago: https://www.shadertoy.com/view/MdXSWn",
            "flags": 0,
            "hasliked": 0,
            "id": "4f2GDh",
            "likes": 3,
            "name": "frosted video mandlebulb",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "jakedowns",
            "viewed": 725
        },
        "renderpass": [
            {
                "code": "// https://github.com/jakedowns/starpages/blob/alpha/shaders/frosted-video-mandlebulb.glsl\n\n// Fork of \"mandlebulb_\" by evilryu: // via https://www.shadertoy.com/view/MdXSWn\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// modified by jakedowns on 1/1/24 to add iChannel0 texture support\n// https://jakedowns.github.io/starpages/webgl2.html\n\n// whether turn on the animation\n//#define phase_shift_on \n\nfloat stime, ctime;\nvoid ry(inout vec3 p, float a) {\n    float c, s;\n    vec3 q = p;\n    c = cos(a);\n    s = sin(a);\n    p.x = c * q.x + s * q.z;\n    p.z = -s * q.x + c * q.z;\n}\n\nfloat pixel_size = 0.0;\n\n/* \n\nz = r*(sin(theta)cos(phi) + i cos(theta) + j sin(theta)sin(phi)\n\nzn+1 = zn^8 +c\n\nz^8 = r^8 * (sin(8*theta)*cos(8*phi) + i cos(8*theta) + j sin(8*theta)*sin(8*theta)\n\nzn+1' = 8 * zn^7 * zn' + 1\n\n*/\n\nvec3 mb(vec3 p) {\n    p.xyz = p.xzy;\n    vec3 z = p;\n    vec3 dz = vec3(0.0);\n    float power = 8.0;\n    float r, theta, phi;\n    float dr = 1.0;\n\n    float t0 = 1.0;\n    for(int i = 0; i < 7; ++i) {\n        r = length(z);\n        if(r > 2.0)\n            continue;\n        theta = atan(z.y / z.x);\n        #ifdef phase_shift_on\n        phi = asin(z.z / r) + iTime * 0.1;\n        #else\n        phi = asin(z.z / r);\n        #endif\n\n        dr = pow(r, power - 1.0) * dr * power + 1.0;\n\n        r = pow(r, power);\n        theta = theta * power;\n        phi = phi * power;\n\n        z = r * vec3(cos(theta) * cos(phi), sin(theta) * cos(phi), sin(phi)) + p;\n\n        t0 = min(t0, r);\n    }\n    return vec3(0.5 * log(r) * r / dr, t0, 0.0);\n}\n\nvec3 f(vec3 p) {\n    ry(p, iTime * 0.2);\n    return mb(p);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float k) {\n    float akuma = 1.0, h = 0.0;\n    float t = 0.01;\n    for(int i = 0; i < 50; ++i) {\n        h = f(ro + rd * t).x;\n        if(h < 0.001)\n            return 0.02;\n        akuma = min(akuma, k * h / t);\n        t += clamp(h, 0.01, 2.0);\n    }\n    return akuma;\n}\n\nvec3 nor(in vec3 pos) {\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(f(pos + eps.xyy).x - f(pos - eps.xyy).x, f(pos + eps.yxy).x - f(pos - eps.yxy).x, f(pos + eps.yyx).x - f(pos - eps.yyx).x));\n}\n\nvec3 intersect(in vec3 ro, in vec3 rd) {\n    float t = 1.0;\n    float res_t = 0.0;\n    float res_d = 1000.0;\n    vec3 c, res_c;\n    float max_error = 1000.0;\n    float d = 1.0;\n    float pd = 100.0;\n    float os = 0.0;\n    float step = 0.0;\n    float error = 1000.0;\n\n    for(int i = 0; i < 48; i++) {\n        if(error < pixel_size * 0.5 || t > 20.0) {\n        } else {  // avoid broken shader on windows\n\n            c = f(ro + rd * t);\n            d = c.x;\n\n            if(d > os) {\n                os = 0.4 * d * d / pd;\n                step = d + os;\n                pd = d;\n            } else {\n                step = -os;\n                os = 0.0;\n                pd = 100.0;\n                d = 1.0;\n            }\n\n            error = d / t;\n\n            if(error < max_error) {\n                max_error = error;\n                res_t = t;\n                res_c = c;\n            }\n\n            t += step;\n        }\n\n    }\n    if(t > 20.0/* || max_error > pixel_size*/ )\n        res_t = -1.0;\n    return vec3(res_t, res_c.y, res_c.z);\n}\nvec3 transform3DPointToUVDepth(vec3 point, vec3 normal, vec3 camPos, vec3 camToP) {\n    // Determine the repeat factor based on mouse position\n    float repeatFactorX = 100. * iMouse.x / iResolution.x; // More repeats as mouse moves right\n    float repeatFactorY = 100. * iMouse.y / iResolution.y; // More repeats as mouse moves up\n\n    // Centering the UV coordinates\n    vec2 centeredUV = point.xy / iResolution.xy - 0.5;\n\n    // Apply the repeating effect to the UV coordinates\n    centeredUV *= vec2(repeatFactorX, repeatFactorY);\n\n    // Use mod to create a repeating pattern and recenter it\n    //centeredUV = mod(centeredUV, 1.0);\n\n    // Recenter the UV coordinates after repeating\n    point.xy = (centeredUV + 0.5) * iResolution.xy;\n\n    // Basic UV transformation\n    vec2 uv = fract(vec2(point.x, point.y) * 0.1);\n\n    // Apply distortion based on normal direction\n    uv += normal.xy * 0.1; // Adjust the factor as needed\n\n    // Apply a non-linear transformation based on camera distance\n    float camDist = length(camPos - point); // Calculate the distance from the camera to the point\n    float distFactor = smoothstep(0.0, 20.0, camDist); // Adjust range as needed\n    uv += vec2(sin(uv.y * 3.14 * distFactor), cos(uv.x * 3.14 * distFactor)) * 0.02;\n\n    // Add depth information as the third component\n    float depth = length(camToP); // Calculate depth based on the vector from camera to point\n\n    return vec3(uv, depth);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) { \n     // Sample from iChannel0\n    vec4 texColor = texture(iChannel0, fragCoord / iResolution.xy);\n\n    // Calculate luminance\n    float luminance = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));\n\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 uv = -1.0 + 2.0 * q;\n    uv.x *= iResolution.x / iResolution.y;\n\n    pixel_size = 1.0 / (iResolution.x * 3.0);\n\t// camera, stime = sin(time), ctime = cos(time)\n    stime = 0.7 + 0.3 * sin(iTime * 0.4);\n    ctime = 0.7 + 0.3 * cos(iTime * 0.4); \n\n    // ta = target, ro = camera position\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ro = vec3(0.0, 3. * stime * ctime, 3. * (1. - stime * ctime));\n\n    // cf = forward, cs = right, cu = up, rd = ray direction\n    vec3 cf = normalize(ta - ro);\n    vec3 cs = normalize(cross(cf, vec3(0.0, 1.0, 0.0)));\n    vec3 cu = normalize(cross(cs, cf));\n    vec3 rd = normalize(uv.x * cs + uv.y * cu + 3.0 * cf);  // transform from view to world\n\n    vec3 sundir = normalize(vec3(0.1, 0.8, 0.6));\n    vec3 sun = vec3(1.64, 1.27, 0.99);\n    vec3 skycolor = vec3(0.6, 1.5, 1.0);\n\n    vec3 bg = exp(uv.y - 2.0) * vec3(0.4, 1.6, 1.0);\n\n    float halo = clamp(dot(normalize(vec3(-ro.x, -ro.y, -ro.z)), rd), 0.0, 1.0);\n    vec3 col = bg + vec3(1.0, 0.8, 0.4) * pow(halo, 17.0);\n\n    float t = 0.0;\n    vec3 p = ro;\n\n    vec3 res = intersect(ro, rd);\n    if(res.x > 0.0) {\n        p = ro + res.x * rd;\n        vec3 n = nor(p);\n        float shadow = softshadow(p, sundir, 10.0);\n\n        float dif = max(0.0, dot(n, sundir));\n        float sky = 0.6 + 0.4 * max(0.0, dot(n, vec3(0.0, 1.0, 0.0)));\n        float bac = max(0.3 + 0.7 * dot(vec3(-sundir.x, -1.0, -sundir.z), n), 0.0);\n        float spe = max(0.0, pow(clamp(dot(sundir, reflect(rd, n)), 0.0, 1.0), 10.0));\n\n        vec3 lin = 4.5 * sun * dif * shadow;\n        lin += 0.8 * bac * sun;\n        lin += 0.6 * sky * skycolor * shadow;\n        lin += 3.0 * spe * shadow;\n\n        res.y = pow(clamp(res.y, 0.0, 1.0), 0.55);\n        vec3 tc0 = 0.5 + 0.5 * sin(3.0 + 4.2 * res.y + vec3(0.0, 0.5, 1.0));\n        col = lin * vec3(0.9, 0.8, 0.6) * 0.2 * tc0;\n        col = mix(col, bg, 1.0 - exp(-0.001 * res.x * res.x));\n\n        float camDist = length(ro - p);\n        // vector from camera to point\n        vec3 camToP = p - ro;\n        vec3 newUV = transform3DPointToUVDepth(p, n, ro, camToP);\n\n        // Sample from iChannel0 using the new UV coordinates\n        vec4 texColor = texture(iChannel0, newUV.xy);\n        col = texColor.rgb;\n\n        // apply fog based on newUV.z\n        // float fogAmount = smoothstep(0.0, 1.0, newUV.z);\n        // col = mix(col, bg, fogAmount);\n    } \n\n    // Mix the luminance into the existing color\n    //col = mix(col, vec3(luminance), 0.5); // Adjust the 0.5 as needed for mixing amount\n\n    // use pixel brightness to offset the texture lookup\n    //float lum = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));\n    //vec2 offsetLookup = vec2(lum * 10.0, 0.0);\n    // vec4 texColor2 = texture(iChannel0, fragCoord/iResolution.xy + offsetLookup);\n    // col = mix(col, texColor2.rgb, 0.5);\n\n    // show a Picture-in-Picture in the top left of the original iChannel0\n    // make sure to make it appear scaled down in the top left corner\n    vec2 PIP_TOP_LEFT_RANGE = vec2(0.0, 0.2);\n    vec2 PIP_SIZE = vec2(0.2, 0.2);\n    vec2 PIP_OFFSET = vec2(0.0, 0.0);\n    vec2 PIP_UV = (fragCoord.xy - iResolution.xy * PIP_TOP_LEFT_RANGE) / (iResolution.xy * PIP_SIZE);\n    float mask = step(0.0, PIP_UV.x) * step(0.0, PIP_UV.y) * step(PIP_UV.x, 1.0) * step(PIP_UV.y, 1.0);\n    col = mix(col, texture(iChannel0, PIP_UV + PIP_OFFSET).rgb, mask * 0.5);\n\n    // post\n    col = pow(clamp(col, 0.0, 1.0), vec3(0.45));\n    col = col * 0.6 + 0.4 * col * col * (3.0 - 2.0 * col);  // contrast\n    col = mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.7);  // vigneting\n    fragColor = vec4(col.xyz, smoothstep(0.55, .76, 1. - res.x / 5.));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}