{
    "Shader": {
        "info": {
            "date": "1610344832",
            "description": "Draws a star with n points, parametric outer and inner radius, and a nice glow around it.\nSample animation: spin a and make a pulsating wave inside it.",
            "flags": 0,
            "hasliked": 0,
            "id": "3lVyzR",
            "likes": 1,
            "name": "N-Star",
            "published": 3,
            "tags": [
                "star",
                "polygon",
                "shape"
            ],
            "usePreview": 0,
            "username": "hugoaboud",
            "viewed": 340
        },
        "renderpass": [
            {
                "code": "/*\n\tThis program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, version 3.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst float M_PI = 3.14159265358979323846264338327950288;\n\n/** Properties **/\n\nconst int N = 5; // Number of points\n\nconst float radius = 1.0; // Outer Radius: absolute value (in UV)\nconst float iradius = 0.6; // Inner Radius: relative to outer\nconst float glow = 0.3; // Glow Size: relative\n\nconst vec4 inColor = vec4(1,1,0,1);\nconst vec4 outColor = vec4(0,1,1,1);\nconst vec4 glowColor = vec4(1,0,0.5,1);\n\n/** Animation **/\n\nconst float rotateSpeed = 0.05;\nconst float waveSpeed = 0.5;\nconst vec4 waveColor = vec4(0.2,0.5,1.0,0.4);\n\nconst vec4 transp = vec4(0,0,0,0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Starting from center\n    uv.xy -= 0.5;\n    uv.xy *= -2.0;\n    \n    // Adjusted to aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Radius\n    float r = length(uv);\n\n    // Background color\n    vec4 col = vec4(0,0,0,0);\n    \n    // Inside outer circle\n    if (r < radius) {\n    \n        // Linear position in circle\n        // This is a simplified projection of the vertex vector on y\n        float ly = uv.y/r;\n        \n        // Calculate polar angle\n        float a = atan(uv.x,uv.y);\n        \n        // Rotate Animation\n        a -= iTime*rotateSpeed;\n        \n        // Break angle into N sections\n        // then rearrange from [0 ~ 1] to [1 ~ 0 ~ 1]\n        // The section angle can be precalculated if N doesn't change\n        float sa = M_PI/float(N); // section angle\n        float p = fract(a/(2.0*sa)); // position in section (angular)\n        p = abs(p-0.5)*2.0;\n        \n        // Get chord midpoint radius\n        // A.K.A. height of the equilateral triangle inside the arc\n        float cr = cos(sa)*radius;\n                \n        // Get chord point radius, given the angle \n        float pa = p*sa; // point angle\n        float cpr = cr/cos(sa-pa);\n                \n        // rough method: maybe too expensive?\n        // scale cr by triangle propotionality rule\n        // The inner radius decomposition can be precalculated if N doesn't change\n        float xp = cpr*sin(pa); // decompose cpr x\n        float yp = cpr*cos(pa); // decompose cpr y\n        float xi = sin(sa*0.5)*iradius*radius; // decompose inner radius x\n        float yi = cos(sa*0.5)*iradius*radius; // decompose inner radius y\n        \n        //float yx = xi/((xp*(1.0-yi)/yp)+xi); // y component of border (if radius == 1)\n        float yx = (xi*yp*radius)/(xp*radius-xp*yi+xi*yp);// y component of border (general radius)\n        \n        // Final result: the star border radius\n        float border = yx/cos(pa);\n        \n        // Coloring (Internal + Glow)\n        if (r < border) {\n            float gl = 1.0-glow;\n            float c = r/border;\n            // star\n            if (c < gl) {\n                col = mix(inColor,outColor,c/gl);\n            }\n            // antialias\n            else if (c < gl*1.025) {\n                col = mix(outColor,glowColor,(c-gl)*50.0);\n            }\n            // glow\n            else {\n                col += glowColor*((1.0-c)/glow);\n            }\n        }\n        \n        // Wave animation\n        float t = fract(iTime*waveSpeed);\n        float rt = t*radius;\n                \n        if (r < rt) rt = 1.0-(rt - r)/radius;\n        else rt = (r - rt)/radius;\n        \n        rt = fract(rt*2.0);\n        \n        // Lighten\n        col += rt*waveColor*waveColor.a*col.a;\n    }\n\n    // Output to screen\n    fragColor = col;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}