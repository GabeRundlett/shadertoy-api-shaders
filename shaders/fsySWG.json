{
    "Shader": {
        "info": {
            "date": "1635251321",
            "description": "truchet test",
            "flags": 0,
            "hasliked": 0,
            "id": "fsySWG",
            "likes": 2,
            "name": "truchet 3d",
            "published": 3,
            "tags": [
                "raymarching",
                "truchet"
            ],
            "usePreview": 0,
            "username": "drschizzo",
            "viewed": 282
        },
        "renderpass": [
            {
                "code": "float N21(vec2 p){\n    p+=12.245;\n    p=fract(p*vec2(1.432342,515.5621));\n    p+=dot(p,p+341.3535);\n    return fract(p.x*p.y*.12);\n    \n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  float r=length(q)-t.y;\n  return min(r,length(vec3(abs(p.x),p.y,abs(p.z))-vec3(.17,0,.18))-.06);\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  \n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat crossTorus(vec3 p,vec3 id){\n    float w=.035;\n    \n    float t1=sdTorus(vec3(abs(p.x)-.5,p.z,abs(p.y)-.5),vec2(.25,w));\n    //t1=min(t1,length(p-vec3(.25,-.25,-.25))-.2);\n       \n\n\n    float t2=sdTorus(vec3(abs(p.x)-.5,p.z,p.y),vec2(.25,w));\n    t2=min(t2,sdTorus(vec3(p.x,p.z,abs(p.y)-.5),vec2(.25,w)));\n   \n\n\n    float r=N21(id.xy+id.z+floor(iTime/3.));\n    float rn=N21(id.xy+id.z+floor(iTime/3.)+1.);\n    float t=r>.5?t1:t2;\n    float tn=rn>.5?t1:t2;\n    \n    return mix(t,tn,smoothstep(.8,.9,fract(iTime/3.)));\n\n    \n}\n\nfloat cube(vec3 p, vec3 id){\n    \n    float c=cos(1.57);\n    float s=sin(1.57);\n    mat2 m=mat2(c,s,-s,c);\n    vec2 a=p.yz*m;\n    vec2 b=p.xz*m;\n    float t=min(crossTorus(p,id),crossTorus(vec3(p.x,a.x,a.y),id));\n    t=min(crossTorus(vec3(a.x,p.y,b.y),id),t);\n    return max(sdBox(p,vec3(.52)),t);\n}\n\nvec3 transform(inout vec3 p){\n    float c=cos(sin(iTime/10.));\n    float s=sin(sin(iTime/10.));\n    \n    mat2 m=mat2(c,s,-s,c);\n    p.xy*=m;\n    vec3 op=p;\n    vec3 r=vec3(1.);\n    p=fract(p)-.5;\n    return floor(op-p); \n}\n\nfloat dist(vec3 p){\n    \n    vec3 id=transform(p);   \n    float cu=cube(p,id);\n       \n    return cu;\n}\n\nvec3 normal(vec3 p){\n    vec2 e=vec2(.001,0.0);\n    float d=dist(p);\n    vec3 n=vec3(\n        d-dist(p-e.xyy),\n        d-dist(p-e.yxy),\n        d-dist(p-e.yyx));\n    return normalize(n);\n}\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd){\n    float d=0.;\n    float td=0.;\n    float i=0.;;\n    for(;i<50.;i++){\n        d=dist(ro+td*rd);\n        td+=d;\n        if(td>50. || d<.001)\n            break;\n    }\n    if(i>50.)\n        return 50.;\n    return float(td);    \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n\n    for( float t=.001; t<100.; )\n    {\n        float h = dist(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 shade(vec3 p,vec3 rd){\n    vec3 n=normal(p);\n    \n    \n    vec3 id=transform(p); \n    \n    vec3 col=vec3(.15,.55,.80);\n    //WIP color mix\n    vec3 col1=normalize(.5+.5*sin(iTime/2.+col*(id.x+id.y*10.)));\n    vec3 col2=normalize(.5+.5*sin(iTime/2.+col*((id.x+1.)+id.y*10.)));\n    vec3 col3=normalize(.5+.5*sin(iTime/2.+col*((id.x-1.)+id.y*10.)));\n    vec3 col4=normalize(.5+.5*sin(iTime/2.+col*((id.x)+(id.y-1.)*10.)));\n    vec3 col5=normalize(.5+.5*sin(iTime/2.+col*((id.x)+(id.y+1.)*10.)));\n    col1+=col3*smoothstep(.75,1.,length(p.x-vec2(.25)));\n    col1+=col2*smoothstep(.75,1.,length(p.x+vec2(.25)));\n    col1+=col4*smoothstep(.75,1.,length(p.y-vec2(.25)));\n    col1+=col5*smoothstep(.75,1.,length(p.y+vec2(.25)));\n    \n    vec3 a=col1/1.5*vec3(abs(dot(n,normalize(vec3(3.,2.,13.)-p))));\n    return a;//*softshadow(p+n*.1,normalize(-p+vec3(0,0.,0.-iTime/10.)),2.);\n}\n\n\n\n\n\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float t=iTime/10.;\n    vec3 camera=vec3(0.,0.,6.-t);\n    vec3 lookAt=vec3(sin(iTime/3.),cos(iTime/3.),-t);\n    float zoom=.8;\n    vec3 f=normalize(camera-lookAt);\n    vec3 r=cross(vec3(0,1.,0),f);\n    vec3 u=cross(f,r);\n    vec3 c=camera-f*zoom;\n    vec3 i=c+uv.x*r+uv.y*u;\n    vec3 ray=normalize(i-camera);\n    \n    float d=rayMarch(c,ray);\n    \n    \n    vec3 p=c+ray*d;\n    vec3 n=normal(p);\n    vec3 col=shade(p,ray);\n    /*vec3 rf=reflect(n,ray);\n    float df=rayMarch(p+n*.01,rf);\n    float fresnel=clamp(pow(1.-dot(ray,n),5.),.2,.8);\n    col+=shade(p+rf*df,rf)*.3*fresnel;\n      */  \n    fragColor = vec4(col*max((1.-d*.15),.05),1.);\n}\n\n//from https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/ \nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .05 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n      //O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}