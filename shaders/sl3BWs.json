{
    "Shader": {
        "info": {
            "date": "1663806699",
            "description": "This shader is visualizing the construction used in https://www.shadertoy.com/view/7tcBDl.\nSee top comment for explanation.\n\nMove control point with mouse.",
            "flags": 0,
            "hasliked": 0,
            "id": "sl3BWs",
            "likes": 7,
            "name": "Biarc quad Bezier approx expl.",
            "published": 3,
            "tags": [
                "2d",
                "bezier",
                "beziercurve",
                "spline",
                "curve",
                "quadratic",
                "arc",
                "biarc"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 197
        },
        "renderpass": [
            {
                "code": "/*\nA circle can be defined by three points.\nAlternatively, one can use two points and one tangent.\n(This is the limit case when one point tends to another point).\n\nYou often want to have a curve (spline) connecting\ntwo points with a certain tangent at both points.\n\nFor this, you can use a biarc, where two arcs\nconnect two points with a predetermined tangent\nat both points. You have some freedom to choose\nthe point at which you connect both arcs.\n(I'm calling that the node)\n\nYou want the arcs to connect smoothly,\nwhich restricts the possible nodes to\nthe points lying on two circles\n(Shown in green)\n\nThe incenter of the black triangle is always\non one of the two green circles.\n(This is used to construct it)\n\nThe second green circle also goes through the endpoints,\nand intersects the first circle perpendicularly in the endpoints.\n\nOne heuristic is to just use the incenter as node.\n\nAnother is to compute the intersection point of the quadratic bezier\ncurve and the green circle going through the incenter.\n\nThis follows the quadratic bezier curve more closely,\nbut is a bit more difficult to compute.\n*/\n\n//#define INCENTER /* Use the incenter heuristic instead */\n//#define MOVE_NODE /* Move the node with the mouse instead */\n\nconst vec3 dot_col=vec3(0);\nconst vec3 line_col=vec3(0);\nconst vec3 bezier_col=vec3(0,0,1);\nconst vec3 arc_col=vec3(1,0,0);\nconst vec3 bg_col=vec3(1);\n\nconst float dot_size=.004;\nconst float line_width=.001;\n\nconst float zoom=1.;\n\nconst float pi=3.1415925;\n\nvec2 parametric_quadratic_bezier(float t, vec2 p0, vec2 p1, vec2 p2){\n\treturn mix(mix(p0,p1,t),mix(p1,p2,t),t);\n}\n\nfloat quadratic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2){\n\tvec2 a_1=a1+t*a2;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*a2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat quadratic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2){\n\tvec2 a2 = p0 - 2. * p1 + p2;\n\tvec2 a1 = -2. * p0 + 2. * p1;\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tvec3 t0=vec3(0.,.5,1.);\n\tfloat t;\n\n\tfor(int i=0;i<3;i++){\n\t\tt=t0[i];\n\t\tfor(int j=0;j<3;j++){\n\t\t\tt=quadratic_bezier_normal_iteration(t,a0,a1,a2);\n\t\t}\n\t\tt=clamp(t,0.,1.);\n\t\tvec2 uv_to_p=(a2*t+a1)*t+a0;\n\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t}\n\n\treturn d0;\n}\n\nfloat quadratic_bezier_dis_approx(vec2 uv, vec2 p0, vec2 p1, vec2 p2){\n\treturn sqrt(quadratic_bezier_dis_approx_sq(uv,p0,p1,p2));\n}\n\nfloat segment_dis(vec2 p, vec2 a, vec2 b){\n\tvec2 pa=p-a, ba=b-a;\n\tfloat h=clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n\treturn length(pa-ba*h);\n}\n\n// Compute the incenter of the triangle given by p0, p1, p2\nvec2 incenter(vec2 p0, vec2 p1, vec2 p2){\n\tvec2 v1=normalize(p1-p0);\n\tvec2 v2=normalize(p2-p0);\n\n\tvec2 v3=normalize(p2-p1);\n\tvec2 v4=normalize(p0-p1);\n\n\tvec3 line1, line2;\n\tline1.xy=(v1+v2)/2.;\n\tline1.xy=vec2(-line1.y,line1.x);\n\tline1.z=-dot(line1.xy,p0);\n\n\tline2.xy=(v3+v4)/2.;\n\tline2.xy=vec2(-line2.y,line2.x);\n\tline2.z=-dot(line2.xy,p1);\n\n\tvec3 l12=cross(line1,line2);\n\n\treturn l12.xy/l12.z;\n}\n\n// Compute the circumcenter of the triangle given by p0, p1, p2\nvec2 circumcenter(vec2 p0, vec2 p1, vec2 p2){\n\tvec3 line1, line2;\n\tline1.xy=p1-p0;\n\tline1.z=-dot(line1.xy,(p0+p1)/2.);\n\n\tline2.xy=p2-p1;\n\tline2.z=-dot(line2.xy,(p1+p2)/2.);\n\n\n\tvec3 m1=cross(line1,line2);\n\tm1/=m1.z;\n\n\treturn m1.xy;\n}\n\n// Compute the point at which the two arcs should be connected\n// in order to best approximate a quadratic bezier curve.\nvec2 compute_best_node(vec2 p0, vec2 p1, vec2 p2){\n\tvec2 m1=incenter(p0,p1,p2);\n\tvec2 m2=circumcenter(p0,m1,p2);\n\n\tvec2 a2=p0-2.*p1+p2;\n\tvec2 a1=2.*(p1-p0);\n\tvec2 a0=p0-m2;\n\n\tfloat b3=dot(a2,a2);\n\tfloat b2=2.*dot(a2,a1);\n\tfloat b1=2.*dot(a2,a0)+dot(a1,a1);\n\n\tfloat c2=b3;\n\tfloat c1=b2+b3;\n\tfloat c0=b1+b2+b3;\n\n\tfloat discriminant=c1*c1-4.*c2*c0;\n\n\tif(discriminant < 0.){\n\t\treturn m1;\n\t}\n\n\tfloat disc_sq=sqrt(discriminant);\n\n\tfloat root1=(-c1-disc_sq)/(2.*c2);\n\tfloat root2=(-c1+disc_sq)/(2.*c2);\n\n\tif(root1 > 0. && root1 < 1.){\n\t\treturn parametric_quadratic_bezier(root1,p0,p1,p2);\n\t}\n\telse if(root2 > 0. && root2 < 1.){\n\t\treturn parametric_quadratic_bezier(root2,p0,p1,p2);\n\t}\n\telse{\n\t\treturn m1;\n\t}\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border=2./iResolution.x;\n\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n    uv.y*=iResolution.y/iResolution.x;\n\n\tvec2 mouse=iMouse.xy/iResolution.xy;\n\tmouse-=.5;\n    mouse.y*=iResolution.y/iResolution.x;\n\n\tborder*=zoom;\n\tuv*=zoom;\n\tmouse*=zoom;\n    \n    // Quadratic bezier control points\n\n\tvec2 p0=vec2(-.2,-.2);\n    #ifndef MOVE_NODE\n\tvec2 p1=mouse;\n    // Animate if mouse is in left bottom corner\n    if(max(iMouse.x, iMouse.y) < 20.){\n        p1=vec2(-.26,.1)+vec2(.2*sin(iTime),.08*cos(iTime));\n    }\n    #else\n    vec2 p1=vec2(-.26,.1);\n    #endif\n\tvec2 p2=vec2(.2,-.2);\n\n    // Node (The point where the two arcs connect)\n\n    #ifdef MOVE_NODE\n\tvec2 p3=mouse;\n    #else\n    #ifdef INCENTER\n    vec2 p3=incenter(p0,p1,p2);\n    #else\n\tvec2 p3=compute_best_node(p0,p1,p2);\n    #endif\n    #endif\n\n\tvec3 color=bg_col;\n\n\t// Show segments\n\tfloat dis=segment_dis(uv,p0,p1)-line_width;\n\tdis=min(dis,segment_dis(uv,p1,p2)-line_width);\n\tcolor=mix(line_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\t// Show quadratic bezier curve\n\tdis=quadratic_bezier_dis_approx(uv,p0,p1,p2)-line_width;\n\tcolor=mix(bezier_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\tvec3 line1, line2, line3, line4, line5, line6;\n\n\t// Line at p0 perpendicular to the segment between p0 and p1\n\tline1.xy=p1-p0;\n\tline1.z=-dot(line1.xy,p0);\n\n\t// Perpendicular bisector of segment between p0 and p3\n\tline2.xy=p3-p0;\n\tline2.z=-dot(line2.xy,(p0+p3)/2.);\n\n\tvec3 l12=cross(line1,line2);\n\n\t// Intersection of line1 and line2, the midpoint of the first arc\n\tvec2 m1=l12.xy/l12.z;\n\tfloat r1=distance(m1,p0);\n\n\t// Line at p0 perpendicular to the segment between p2 and p1\n\tline3.xy=p2-p1;\n\tline3.z=-dot(line3.xy,p2);\n\n\t// Perpendicular bisector of segment between p2 and p3\n\tline4.xy=p3-p2;\n\tline4.z=-dot(line4.xy,(p2+p3)/2.);\n\n\tvec3 l34=cross(line3,line4);\n\n\t// Intersection of line2 and line3, the midpoint of the second arc\n\tvec2 m2=l34.xy/l34.z;\n\tfloat r2=distance(m2,p2);\n\n\tvec2 m3=incenter(p0,p1,p2);\n\n\t// The midpoint of the first green circle\n\tvec2 m4=circumcenter(p0,m3,p2);\n\tfloat r4=distance(p0,m4);\n\n\t// Line at p0 perpendicular to the first green circle\n\tline5.xy=m4-p0;\n\tline5.z=-dot(line5.xy,p0);\n\n\t// Perpendicular bisector of segment between p0 and p2\n\tline6.xy=p2-p0;\n\tline6.z=-dot(line6.xy,(p0+p2)/2.);\n\n\tvec3 l56=cross(line5,line6);\n\n\t// The midpoint of the second green circle\n\tvec2 m5=l56.xy/l56.z;\n\tfloat r5=distance(p0,m5);\n\n\t// Show dots\n\tdis=distance(m1,uv)-dot_size;\n\tdis=min(dis,distance(m2,uv)-dot_size);\n\tdis=min(dis,distance(m3,uv)-dot_size);\n\tdis=min(dis,distance(m4,uv)-dot_size);\n\tdis=min(dis,distance(m5,uv)-dot_size);\n\tcolor=mix(dot_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\t// Show red circles (arcs)\n\tdis=abs(distance(m1,uv)-r1)-line_width;\n\tdis=min(dis,abs(distance(m2,uv)-r2)-line_width);\n\tcolor=mix(arc_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\t// Show green circles\n\tdis=abs(distance(m4,uv)-r4)-line_width;\n\tdis=min(dis,abs(distance(m5,uv)-r5)-line_width);\n\tcolor=mix(vec3(0,1,0),color,smoothstep(-border/2.,border/2.,dis));\n\n\tdis=distance(uv,p0)-dot_size;\n\tdis=min(dis,distance(uv,p1)-dot_size);\n\tdis=min(dis,distance(uv,p2)-dot_size);\n\tdis=min(dis,distance(uv,p3)-dot_size);\n\tcolor=mix(dot_col,color,smoothstep(-border/2.,border/2.,dis));\n\t\n\n\tfragColor=vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}