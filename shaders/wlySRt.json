{
    "Shader": {
        "info": {
            "date": "1583343010",
            "description": "Dielectric Fresnel is on top.  Conductive Fresnel driven by Artistic Edge Tint is on the bottom.  Define-based presets are from the \"Artist Friendly Metallic Fresnel\" paper: http://jcgt.org/published/0003/04/03/paper-lowres.pdf",
            "flags": 0,
            "hasliked": 0,
            "id": "wlySRt",
            "likes": 4,
            "name": "Artist Friendly Metallic Fresnel",
            "published": 3,
            "tags": [
                "complex",
                "fresnel",
                "metallic",
                "conductor"
            ],
            "usePreview": 0,
            "username": "bhouston",
            "viewed": 999
        },
        "renderpass": [
            {
                "code": "vec3 sphere = vec3(0, 0, 2);\nfloat sphere_size = 1.3;\n\nconst float INFINITY = 100000.0;\n\n#define UNOBTAINIUM\n#define ENV_MAP\n\n//\n// these numbers are taken from the paper http://jcgt.org/published/0003/04/03/paper-lowres.pdf\n// using GIMP's dropper tool.\n//\n\n#ifdef GOLD\n\t// NOTE: Edge tint chosen to look identical to dielectric Fresnel\n\tvec3 reflectivity = vec3( 241.0/255.0, 186.0/255.0, 95.0/255.0 );\n\tvec3 edgeTint = vec3( 254.0/255.0, 248.0/255.0, 187.0/255.0 );\n#endif\n\n#ifdef COPPER\n\t// NOTE: Edge tint chosen to look identical to dielectric Fresnel\n\tvec3 reflectivity = vec3( 236.0/255.0, 175.0/255.0, 128.0/255.0 );\n\tvec3 edgeTint = vec3( 254.0/255.0, 241.0/255.0, 209.0/255.0 );\n#endif\n\n#ifdef SILVER\n\t// NOTE: Edge tint chosen to look identical to dielectric Fresnel\n\tvec3 reflectivity = vec3( 245.0/255.0, 242.0/255.0, 234.0/255.0 );\n\tvec3 edgeTint = vec3( 255.0/255.0, 255.0/255.0, 255.0/255.0 );\n#endif\n\n#ifdef UNOBTAINIUM\n\tvec3 reflectivity = vec3( 153.0/255.0, 179.0/255.0, 230.0/255.0 );\n\tvec3 edgeTint = vec3( 0.0/255.0, 255.0/255.0, 128.0/255.0 );\n#endif\n\n\nfloat pow2( const in float a ) { return a *a; }\nvec3 pow2( const in vec3 a ) { return a *a; }\n\nvoid edgeTintToConductiveFresnel( const in vec3 reflectivity, const in vec3 edgeTint, out vec3 n, out vec3 k ) {\n\t// this is based on the code in Autodesk's Standard Surface OSL as well as in the OSL repository in my thread from 2015.\n\tvec3 r = clamp( reflectivity, vec3(0), vec3(0.99) );\n\tvec3 g = edgeTint;\n\tvec3 r_sqrt = sqrt( r );\n\tvec3 n_min = ( 1.0 - r ) / ( 1.0 + r );\n\tvec3 n_max = ( 1.0 + r_sqrt ) / ( 1.0 - r_sqrt );\n\tn = mix( n_max, n_min, g );\n\tvec3 k2 = (( n + 1.0 ) * ( n + 1.0 ) * r - ( n - 1.0 ) * ( n - 1.0 ) ) / ( 1.0 - r );\n\tk2 = max( k2, 0.0 );\n\tk = sqrt( k2 );\n}\n\n//\n// Approximation of Spectral Complex Fresnel based on just sampling RGB wavelengths\n//\n// Refractive index for red, green, blue wavelengths (f.e. for 0.65, 0.55, 0.45 micrometers)\n// Extinction coefficient for red, green, blue wavelengths (f.e. for 0.65, 0.55, 0.45 micrometers)\n//\n// source: https://docs.chaosgroup.com/display/OSLShaders/Complex+Fresnel+shader\n//\nvec3 F_ConductiveFresnel( const in vec3 reflectivity, const in vec3 edgeTint, const in float dotNV ) {\n\n\tvec3 n, k;\n\tedgeTintToConductiveFresnel( reflectivity, edgeTint, n, k );\n\n\t//n=vec3(0.27105, 0.67693, 1.3164);\n\t//k=vec3(3.6092, 2.6247, 2.2921);\n\n    vec3 rs_num = pow2( n ) + pow2( k ) - 2.0 * n * dotNV + pow2( dotNV );\n    vec3 rs_den = pow2( n ) + pow2( k ) + 2.0 * n * dotNV + pow2( dotNV );\n    vec3 rs = rs_num / rs_den;\n     \n    vec3 rp_num = ( pow2( n ) + pow2( k ) ) * pow2( dotNV ) - 2.0 * n * dotNV + 1.0;\n    vec3 rp_den = ( pow2( n ) + pow2( k ) ) * pow2( dotNV ) + 2.0 * n * dotNV + 1.0;\n    vec3 rp = rp_num / rp_den;\n     \n    return clamp( 0.5 * ( rs + rp ), vec3(0.0), vec3(1.0) );\n}\n\nvec3 F_DielectricFresnel( const in vec3 reflectivity, const in float dotNV ) {\n\t// Based on the standard Schlick approximation\n\tfloat fresnel = pow( 1.0 - dotNV, 5.0 );\n\treturn vec3( ( 1.0 - reflectivity ) * fresnel + reflectivity );\n}\n\nfloat raySphere(vec3 rpos, vec3 rdir, vec3 sp, float radius, inout vec3 point, inout vec3 normal) {\n\tradius = radius * radius;\n    vec3 tmp = rpos - sp;\n\tfloat dt = dot(rdir, -tmp);\n\tif (dt < 0.0)\n\t\treturn INFINITY;\n\ttmp.x = dot(tmp, tmp);\n\ttmp.x = tmp.x - dt*dt;\n\tif (tmp.x >= radius)\n\t\treturn INFINITY;\n\tdt = dt - sqrt(radius - tmp.x);\n\tpoint = rpos + rdir * dt;\n\tnormal = normalize(point - sp);\n\treturn dt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv.y = -uv.y;\n\tvec3 ray = vec3(uv.x, uv.y, 1.0);\n\tray = normalize(ray);\t\n\t\n\tvec3 point, normal; \n\tfloat dist = raySphere(vec3(0.0), ray, sphere, sphere_size, point, normal);\n    \n    vec3 viewDir = normalize( -point );\n    float dotVN = dot( viewDir, normal );\n  \n        \n    vec3 reflection = reflect( viewDir, normal );\n\n    vec3 env = texture( iChannel2, reflection ).xyz;\n\n    vec3 F = vec3( 0.0 );\n    \n\tif (dist < INFINITY) {\n\t  \n     if( ( uv.y + sin( iTime ) ) < 0.0 ) {  \n\t\t\tF = F_DielectricFresnel( reflectivity, dotVN );\n        }\n        else {\n\t\t\tF = F_ConductiveFresnel( reflectivity, edgeTint, dotVN );\n        }\n    }\n    else {\n        fragColor = vec4(0.0);\n    }\n     \n    \n    \n\tfragColor.xyz = F;\n#ifdef ENV_MAP\n    fragColor.xyz *= env * 1.5;\n#endif\n    \n    if (dist >= INFINITY) {\n\t  \n        if( ( uv.y + sin( iTime ) ) > 0.0 && abs( uv.x ) > 1.0 ) {  \n            fragColor.xyz = vec3( 0.2 );\n\t    }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}