{
    "Shader": {
        "info": {
            "date": "1621273225",
            "description": "wow man, far out",
            "flags": 32,
            "hasliked": 0,
            "id": "ssBXWd",
            "likes": 6,
            "name": "Eyeful of towers",
            "published": 3,
            "tags": [
                "raymarching",
                "fractals",
                "menger"
            ],
            "usePreview": 0,
            "username": "xenn",
            "viewed": 358
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uuv = uv * 2.0 - 1.0;\n    vec3 c = texture(iChannel0, uv).rgb;\n    vec4 col = vec4(pow(c, vec3(0.5)), 1.0);\n\n    fragColor = mix(vec4(.0), col, 1.-smoothstep(0.,1.,length(uuv)*0.6));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Fork of \"Menger Journey\" by Syntopia. https://shadertoy.com/view/Mdf3z7\n// 2021-05-17 16:50:31\n\n#define MaxSteps 32\n#define MinimumDistance 0.0009\n#define normalDistance     0.0002\n\n#define Iterations 16\n#define PI 3.141592\n#define Scale 3.0\n#define FieldOfView 1.0\n#define Jitter 0.05+abs(01.1*sin(iTime*0.725)/2.0)\n#define FudgeFactor 0.6\n#define NonLinearPerspective 2.0*abs(01.1+sin(iTime*0.5)/4.0)\n#define DebugNonlinearPerspective false\n\n#define Ambient 0.132184\n#define Diffuse 0.45\n#define LightDir vec3(1.0)\n#define LightColor vec3(1.0,1.0,0.858824)\n#define LightDir2 vec3(1.0*abs(01.1-sin(iTime*01.5)/2.0),-1.0*abs(01.1-sin(iTime*2.5)/2.0),1.0/abs(01.1-sin(iTime*0.5)/0.50))\n#define LightColor2 vec3(0.1*abs(01.1+sin(iTime*01.25)/2.0),0.333333,1.0)\n#define Offset vec3(0.82858-(0.51*(cos(iTime*01.5))/09.50),0.92858090,0.58090*(01.1-cos(iTime*0.235)/18.0))\n\nvec2 rotate(vec2 v, float a) {\n\treturn vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\n// Two light sources. No specular \nvec3 getLight(in vec3 color, in vec3 normal, in vec3 dir) {\n\tvec3 lightDir = normalize(LightDir);\n\tfloat diffuse = max(0.0,dot(-normal, lightDir)); // Lambertian\n\t\n\tvec3 lightDir2 = normalize(LightDir2);\n\tfloat diffuse2 = max(0.0,dot(-normal, lightDir2)); // Lambertian\n\t\n\treturn\n\t(diffuse*Diffuse)*(LightColor*color) +\n\t(diffuse2*Diffuse)*(LightColor2*color);\n}\n\n\n// DE: Infinitely tiled Menger IFS.\n//\n// For more info on KIFS, see:\n// http://www.fractalforums.com/3d-fractal-generation/kaleidoscopic-%28escape-time-ifs%29/\nfloat DE(in vec3 z)\n{\n\t// enable this to debug the non-linear perspective\n\tif (DebugNonlinearPerspective) {\n\t\tz = fract(z);\n\t\tfloat d=length(z.xy-vec2(0.5));\n\t\td = min(d, length(z.xz-vec2(0.5)));\n\t\td = min(d, length(z.yz-vec2(0.5)));\n\t\treturn d-0.01;\n\t}\n\t// Folding 'tiling' of 3D space;\n\tz  = abs(1.0-mod(z,2.0));\n\n\tfloat d = 10.0;\n\tfor (int n = 0; n < Iterations; n++) {\n\t\tz.xy = rotate(z.xy,12.0+8.0*cos( iTime/64.0));\t\t\n\t\tz = abs(z);\n\t\tif (z.x<z.y){ z.xy = z.yx;}\n\t\tif (z.x< z.z){ z.xz = z.zx;}\n\t\tif (z.y<z.z){ z.yz = z.zy;}\n\t\tz = Scale*z-Offset*(Scale-1.0);\n\t\tif( z.z<-0.25*Offset.z*(Scale-1.0))  z.z+=Offset.z*(Scale-1.0);\n\t\td = min(d, length(z) * pow(Scale, float(-n)-1.0));\n\t}\n\t\n\treturn d-0.001;\n}\n\n// Finite difference normal\nvec3 getNormal(in vec3 pos) {\n\tvec3 e = vec3(0.0,normalDistance,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tDE(pos+e.yxx)-DE(pos-e.yxx),\n\t\t\tDE(pos+e.xyx)-DE(pos-e.xyx),\n\t\t\tDE(pos+e.xxy)-DE(pos-e.xxy)\n\t\t\t)\n\t\t);\n}\n\n// Solid color \nvec3 getColor(vec3 normal, vec3 pos) {\n\treturn vec3(1.0);\n}\n\n\n// Pseudo-random number\n// From: lumina.sourceforge.net/Tutorials/Noise.html\nfloat rand(vec2 co){\n\treturn fract(cos(dot(co,vec2(4.898,7.23))) * 23421.631);\n}\n\nvec4 rayMarch(in vec3 from, in vec3 dir, in vec2 fragCoord) {\n\t// Add some noise to prevent banding\n\tfloat totalDistance = Jitter*rand(fragCoord.xy+vec2(iTime));\n\tvec3 dir2 = dir;\n\tfloat distance;\n\tint steps = 0;\n\tvec3 pos;\n\tfor (int i=0; i < MaxSteps; i++) {\n\t\t// Non-linear perspective applied here.\n\t\tdir.zy = rotate(dir2.zy,totalDistance*cos( iTime/4.0)*NonLinearPerspective);\n\t\t\n\t\tpos = from + totalDistance * dir;\n\t\tdistance = DE(pos)*FudgeFactor;\n\t\ttotalDistance += distance;\n\t\tif (distance < MinimumDistance) break;\n\t\tsteps = i;\n\t}\n\t\n\t// 'AO' is based on number of steps.\n\t// Try to smooth the count, to combat banding.\n\tfloat smoothStep =   float(steps) + distance/MinimumDistance;\n\tfloat ao = 1.1-smoothStep/float(MaxSteps);\n\t\n\t// Since our distance field is not signed,\n\t// backstep when calc'ing normal\n\tvec3 normal = getNormal(pos-dir*normalDistance*3.0);\n\t\n\tvec3 color = getColor(normal, pos);\n\tvec3 light = getLight(color, normal, dir);\n\tcolor = (color*Ambient+light)*ao;\n\treturn vec4(color,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Camera position (eye), and camera target\n\tvec3 camPos = 0.5*iTime*vec3(1.0,0.0,0.0);\n\tvec3 target = camPos + vec3(1.0,0.0*cos(iTime),0.0*sin(0.4*iTime));\n\tvec3 camUp  = vec3(0.0,1.0,0.0);\n\t\n\t// Calculate orthonormal camera reference system\n\tvec3 camDir   = normalize(target-camPos); // direction for center ray\n\tcamUp = normalize(camUp-dot(camDir,camUp)*camDir); // orthogonalize\n\tvec3 camRight = normalize(cross(camDir,camUp));\n\t\n\tvec2 coord =-1.0+2.0*fragCoord.xy/iResolution.xy;\n\tcoord.x *= iResolution.x/iResolution.y;\n\t\n\t// Get direction for this pixel\n\tvec3 rayDir = normalize(camDir + (coord.x*camRight + coord.y*camUp)*FieldOfView);\n\t\n\tfragColor = rayMarch(camPos, rayDir, fragCoord );\n}\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// This buffer does some bokeh based on the alpha channel of buffer A which is the distance of the surface from the pixel.\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 base = vec3(0.);\n    \n    // Gaussian blur by mrharicot https://www.shadertoy.com/view/XdfGDH\n    \n    //declare stuff\n    const int mSize = 7;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\tfloat depth = texture(iChannel0, uv).a;\n    \n    //create the 1-D kernel\n    float sigma = mix(0.1, 10., max(0., -.55 + depth*0.2));\n    float Z = .0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        for (int j=-kSize; j <= kSize; ++j)\n        {\n            base += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n        }\n    }\n   \tvec4 b = vec4(base/(Z*Z), 1.0);\n\n    fragColor = b;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// subtle feedback loop: blend the last frame with the current one\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n    vec3 s = step(0.5,blend);\n    return s * (sqrt(base)*(-2.0*blend+2.0)+2.0*base*(1.0-blend)) - (1.-s)*(2.*base*blend+base*base*(1.0-2.0*blend));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 base = texture(iChannel0, uv).rgb;\n    vec3 overlay = texture(iChannel1, uv).rgb;\n    vec4 col = vec4(base +(blendSoftLight(base, overlay*2.)), 1.0);\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}