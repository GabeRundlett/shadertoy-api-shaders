{
    "Shader": {
        "info": {
            "date": "1483845019",
            "description": "I tend to call them fish scale tiles, but I've heard them referred to as Japanese wave patterns, European tiles, etc. Either way, it's just an excuse to play around with 2D polar coordinates.",
            "flags": 0,
            "hasliked": 0,
            "id": "XlKXzD",
            "likes": 37,
            "name": "Japanese Wave Pattern",
            "published": 3,
            "tags": [
                "grid",
                "wave",
                "polar",
                "tile",
                "scales"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1968
        },
        "renderpass": [
            {
                "code": "/*\n\tJapanese Wave Pattern\n\t---------------------\n\n\tI tend to call them fish scale tiles, but I've heard them referred to as Japanese wave \n\tpatterns, European tiles, etc. Either way, it's just an excuse to play around with 2D \n\tpolar coordinates.\n\n\tThis particular design is based on something I came across on the net years ago. I'm \n\tnot sure who originally came up with it, but I see it frequently in various forms all \n\tover the net. I have a feeling that the originals were hand drawn, because I don't \n\tthink anyone would ever get bored enough to code one... :)\n\n\tConceptually, there's nothing difficult here, but the routines are a little fiddly. In \n\tessence, the texture is constructed from a series of fan-like shapes made up of \n\tcombinations of strategically placed circles. Decorating the tiles involves a few steps, \n\tdue to the intricate details. However, it's essentially nothing more than a few lines \n\tand shapes rendered on a polar grid.\n\n\tGetting finely detailed images to look right on everyone's system is impossible. I find \n\tthe biggest problem is the large range in PPIs these days. What looks right on my \n\tsystem might not look that great on someone elses.\n\n\tI coded this using the 800x450 canvas on a 17 inch laptop with 1920x1080 resolution, so \n\tthe resulting image physically looks the size of Samsung phone in side view. However, \n\tit's not uncommon for people to have systems with PPIs way in excess of that these days, \n\twhich would result in a much smaller image, and thus, squashed details. Unfortunately, \n\tit's not possibe to control that.\n\n\tIn order to show the repeat texture qualities, I've opted for scales that look the same \n\tsize at different resolutions. That may or may not have been the best choice.\n\n    There's a compile option to distinguish between alternating scale layers and another \n\toption to turn off the highlights, just in case a rippling, hardened scale is messing \n\twith your sense of physical correctness. It disturbs mine a bit. :)\n\n\tOther examples:\n\n\t// I deliberately refrained from looking at Kuvkar's rendition in the hope that I could \n    // bring something new to the table. I didn't. :D\n\tEuropean Cobblestone Tiles - kuvkar\n\thttps://www.shadertoy.com/view/ldyXz1\n\n\t// Awesome usage of fish scales would be putting it mildly. :)\n\tKelp Forest - BigWIngs\n\thttps://www.shadertoy.com/view/llcSz8\n\n\t// Fabrices take on it. I might look into it more closely.\n\tHexagonal Tiling 5 - FabriceNeyret2\n    https://www.shadertoy.com/view/4dKXz3\n\n\n*/\n\n// Cheap bump highlights.\n#define SHOW_HIGHLIGHTS\n\n// Distinguishes between the two layers by changing the color of one.\n//#define SHOW_ALTERNATE_LAYERS\n   \n\n// A cheap hack to store a bump value.\nfloat bumpValue;\n\n// Fabrices consice, 2D rotation formula.\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\n\n// Decorating each scale. For all intents and purposes, this is a demonstration of converting\n// an N by N square grid to N by N disc-like polar cells and drawing some things in them.\n// The code looks more involved than it really is, due to the coloring, decision making, etc. \nvec3 scaleDec(vec2 p, float layerID){\n\n    // Square grid partioning for the scales. This will be further partitioned into a polar\n    // grid to draw some details.\n    p = mod(p, vec2(.9, .5)) - vec2(.9, .5)/2.;\n\n\n    \n    // Mover the center of the disc to the top of the cell. In fact, we've moved it slightly \n    // higher to allow for the thicker fan border.\n    p -= vec2(-.05, -.28);\n    \n\n    \n    // Pinching the design together along X to match the fact that we're drawing circles slightly\n    // squashed along X... Technically ellipses.\n    // We're also multiply by a scalar factor or 14. This breaks each scale into a 14x14 grid, \n    // which we'll convert to polar coordinates. See the radius (r) and angle (a) lines below.\n    p *= 14./vec2(.95, 1); \n    \n    float r = length(p); // Radius. The radial part of the polar coordinate.\n    float patID = step(.5, fract(r/2.)); // Pattern ID. Either lines or the sinusoidal design.\n     \n    \n    // Rotate: I've given the layer IDs values of one and negative-one, in order to spin the\n    // discs in opposing directions... I figured it might look more interesting. Commenting it\n    // out stops the rotation.\n    p *= r2(-iTime/12.*layerID); \n    //p *= r2(-iTime/48.*(floor(r) + 4.)*spin); // Rotate sections at differt rates.\n    //if(patID>.5) p *= r2(-iTime/12.*spin);  // Only rotate half the sections.\n    \n    \n    // Controls the amount of vertical lines in each polar segment. Just to make things difficult,\n    // I wanted a higher density of lines and squiggles as we moved down the scale.\n    float vLineNum = floor(r)*12. + 16.;    \n    if(patID>.5)  vLineNum /= 2.; // Lower the frequency where rendering the squiggly bits.\n    \n    \n    // Angle of the pixel in the grid with respect to the center.\n    float a = atan(p.y, p.x);\n    // Partioning the angles into a number of segments.\n    float ia = floor(a*vLineNum/6.2831853);\n    ia = (ia + .5)/vLineNum*6.2831853; \n    \n    // Rotating by the segment angle above.\n    p *= r2(ia);\n    p.x = fract(p.x) - .5; \n    \n\t// The vertical lines.\n    float vLine = abs(p.y) - .05;  \n    vLine = smoothstep(0., fwidth(vLine), vLine)*.75 + .25;//step(0., d);////clamp(fwidth(vLine), 0., .1)*2.\n    if(patID>.5) vLine = 1.; // No vertical lines every second segment.\n    \n    // Horizontal partitioning lines.\n    float hLine = abs(fract(r + .5) - .5) - .05;\n    hLine = smoothstep(0., fwidth(hLine)*1., hLine);  \n \n    // Scale border - Smooth (trial and error) version of: if(r>7.15) hLine1 *= .05;\n    hLine *= .05 + smoothstep(0., fwidth(7.2 - r), 7.2-r)*.95; \n    \n    // Every second partition, draw a sinusoidal pattern.\n    if(patID>.5){\n        \n        // Line, centered in the partition, perturbed sinusoidally.\n        float wave = sin(a*vLineNum/2.)*.2;\n        float hLine2 = abs(fract(r + wave) - .5) - .04;\n        hLine2 = smoothstep(0., fwidth(hLine2)*1., hLine2);\n        // Place some dots in amongst the sinusoid.\n        float dots = length(p - vec2(wave*.5, 0)) - .07;\n        dots = smoothstep(0., fwidth(dots), dots);\n        hLine2 = min(hLine2, dots);\n        hLine2 = hLine2*.8 + .2;\n        \n        hLine = min(hLine, hLine2);\n    }\n    \n    \n    // Combining the horizontal line patterns and the vertical lines.   \n    vec3 col = vec3(1)*min(vLine, hLine);\n    \n\t// Color up every second partition according to object ID. I did this out of \n    // sheer boredom. :)\n    if(patID<.5) {        \n        \n        if (layerID > 0.) col *= vec3(.7, .9, 1.3);\n        else col *= vec3(.8, 1.2, 1.4);\n    }\n    \n    // Apply some color, dependent on segment number.\n    vec3 gradCol = pow(vec3(1.5, 1, 1)*max(1. - floor(r)/7.*.7, 0.), vec3(1, 2, 10)); \n    //vec3 gradCol = pow(vec3(1.5, 1, 1)*max(1. - (r)/7.*.7, 0.), vec3(1, 2, 10)); \n    //vec3 gradCol = pow(vec3(1.5, 1, 1)*max(1. - (r)/7.*.7, 0.), vec3(1, 3, 16)); \n\n    // Very simple bump value. It's a global variable, separate to the coloring. It's\n    // a bit of hack added after the fact, but it works.\n    //bumpFunc = cos(r*6.283)*.5 + .5;\n    bumpValue = 1. - clamp(-cos(r*6.283*1.)*2. + 1.5, 0., 1.)*1.;\n   \n    \n    // Return the final color.\n    return col*(min(gradCol, 1.)*.98 + .02);\n    \n    \n    \n}\n\n// Basically, three circular shapes combined in such a way as to create a fan. The result \n// is a grid \"half\" filled with fan shapes. A second layer - offset appropriately - is \n// required to fill in the entire space to create the overall scale texture.\n//\n// By the way, the procedure below is pretty simple, but a little difficult to describe. \n// Isolating the function and running it by itself is the best way to grasp it.\nfloat scalesMask(vec2 p){\n\n    \n    const float fwScale = 3.; // \"fwidth\" smoothing scale. Controls border blurriness to a degree.\n \n    // Repeat space: Breaking it up into .9 by .5 squares... just to be difficult. :)\n    // I wanted the scales to overlap slightly closer together, which meant bringing the centers\n    // closer together. This meant offsetting everything... You have my apologies. :)\n    p = mod(p, vec2(.9, .5)) - vec2(.9, .5)/2.;\n \n    \n    // Draw a circle, centered at the top of the .9 by .5 rectangle.\n    float c = length(p +  vec2(.0, .25)); \n    c = smoothstep(0.,  min(fwidth(c), .01)*fwScale, c - .5);\n\n    float mask = c;\n\n    // Chopped off two partial circles at the top left and top right. They're positioned in such\n    // a way to create a fan shape.\n    //\n    // The \"sign\" business is just a repetitive trick to take care of two quadrants at once.\n    // \"sign(p.x)\" has the effect of an \"if\" statement.\n    c = length(p - vec2(sign(p.x)*.9, -1.)*.5);\n    \n    \n    // Combine the three circular shapes to create the fan.\n    return max(mask, smoothstep(0., min(fwidth(c), .01)*fwScale, .5 - c));\n    \n}\n\n// The decrotated scale tiles. Render one set of decorated fans, combine them with the\n// other set, then add some highlighting and postprocessing.\nvec3 scaleTile(vec2 p){\n    \n    // Contorting the scale a bit to add to the hand-drawn look.\n    vec2 scale = vec2(3, -2.);\n    \n    // One set of scale tiles, which take up half the space.\n    float sm = scalesMask(p*scale); // Mask.\n    vec3 col = sm*scaleDec(p*scale + vec2(-.5, -.25), 1.); // Decoration.\n    float bf2 = bumpValue*sm;\n    \n    // The other set of scale tiles.\n    float sm2 = scalesMask(p*scale + vec2(-.45, -.75)); // Mask.\n    vec3 col2 = sm2*scaleDec(p*scale + vec2(-.5, -.75) + vec2(-.45, -.25), -1.); // Decoration.\n    \n    \n    #ifdef SHOW_ALTERNATE_LAYERS\n    // A simple way to distinguish between the two layers.\n    col2 = col2*.7 + col2.yxz*.3;\n    #endif\n    \n    // Add some highlighting.\n    bumpValue = max(bf2, bumpValue*sm2);\n    col = max(col, col2);\n    \n    // Toning the color down a bit. This was a last minute thing.\n    return col*.8 + col.zxy*.2;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates. Feel free to tweak it, if you want.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/450.; // iResolution.y;\n\n    // Perturbing - and shifting - the screen coordinates for a bit of a wavy effect. It\n    // gives the texture a kind of hand-drawn feel.\n    uv += sin(uv*3.14159*3. - sin(uv.yx*3.14159*6. + iTime*.5))*.0075 + vec2(0, .125);\n \n    \n    // Producing the scale tile.\n    vec3 col = scaleTile(uv);\n    #ifdef SHOW_HIGHLIGHTS\n    float bf = bumpValue; // Saving the bump value.\n    \n    // Taking a second nearby sample, in order to produce some cheap highlighting.\n    vec3 col2 = scaleTile(uv + .5/450.);// 450.;\n    float bf2 = bumpValue;\n    \n    // Color-based, or texture based bump.\n    float bump = max(dot(col2 - col, vec3(.299, .587, .114)), 0.)*4.;\n    // Adding a cheap and nasty functional bump. It effectively adds some extra contour.\n    bump += max(bf2 - bf, 0.)*2.;\n    \n    \n    // Add the rough highlighting.\n    col = col + vec3(1, 1, 1.5)*(col*.9 + .1)*bump;\n    //col = col*(vec3(.5, .7, 1)*bump*8. + 1.);\n    #endif\n    \n    // Rought gamma correction.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}