{
    "Shader": {
        "info": {
            "date": "1717127466",
            "description": "mobius transformation\nsmith chart inspiration",
            "flags": 0,
            "hasliked": 0,
            "id": "lXcGDs",
            "likes": 2,
            "name": "Magma Core",
            "published": 3,
            "tags": [
                "transformation"
            ],
            "usePreview": 0,
            "username": "ShadeWhizz",
            "viewed": 83
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926\nfloat sdGrid(in vec2 position, in float margin) {\n\n\t// Calculate per-axis distance from 0.5 to position mod 1\n\tvec2 gridDist = abs(fract(position) - 0.5) - margin;\n    //gridDist.x = 0.0; //makes it look like a magnetic field\n    // nb somehow related to mobius transformations which is related to smith chart\n    // smith chart is z-1/z+1\n\t\n\t// Calculate length for round outer corners, ripped from Inigo Quilez\n\tfloat outsideDist = length(max(gridDist, 0.0));\n\t// Calculate inside separately, ripped from Inigo Quilez\n\tfloat insideDist = min(max(gridDist.x, gridDist.y), 0.0);\n\t\n\treturn outsideDist + insideDist;\n}\n\nconst vec2 c1 = vec2(1.0, 0.0); //1\nconst vec2 c0 = vec2(0.0); //0\nconst vec2 ci = vec2(0.0, 1.0);\n\n// operations of complex numbers\nvec2 cMult(vec2 z, vec2 w) {    //z*w\n    return vec2(z.x * w.x - z.y * w.y, z.y * w.x + z.x * w.y);\n}\nvec2 cConj(vec2 z) {    //bar{z}\n    return vec2(z.x, - z.y);\n}\nvec2 cInv(vec2 z) { //z^{-1}\n    return (1.0 / pow(length(z), 2.0)) * cConj(z);\n}\nvec2 cDiv(vec2 z, vec2 w) {\n    return cMult(z, cInv(w));\n}\n\nvec2 moebius(vec2 a, vec2 b, vec2 c, vec2 d, vec2 z) {\n    return cMult((cMult(a, z) + b), (cMult(c, z) + d));\n}\nvec2 mymoebius(vec2 a, vec2 b, vec2 c, vec2 d, vec2 z) {\n    return cDiv((cMult(a, z) + b), (cMult(c, z) + d));\n}\n// moebius(a,b,c,d,z)=(az+b)/(cz+d)\n\n// probably related to other one\n//vec2 moebiusInv(vec2 a, vec2\n\nvec2 smith(vec2 z, float t) {\n    vec2 a = c1;\n    // vec2 a = vec2(cos(iTime), sin(iTime)); // fair enough just rotates it\n    //vec2 b = vec2(cos(iTime), sin(iTime)); // fair enough just rotates it\n    t = 2.0*PI*sin(0.25*t);\n    vec2 b = vec2(cos(t), sin(t));\n    // true because its like choose your 2 points or is it 4 points? idk\n    //return mymoebius(b, -a, c1, c0, z);\n    //return mymoebius(b, -b, c1, c0, z);\n    return mymoebius(c0, -c1, b, c0, z);\n    //return mymoebius(c1, -c1, b, c0, z); // opposite way of aboove \n    //return mymoebius(b, c0, c1, b, z);\n    //return mymoebius(b, -b, c1, b, z);\n}\n\nfloat channel(vec2 uv, float t) {\n    //uv = uv / iTime; // top kek see the floating point artifacts\n    // would love to make it tunnel tho\n    //uv = smith(uv);\n    uv = fract(log(1.0 + abs(0.5*smith(uv, t))));\n    return sdGrid(uv + t*0.49, 0.2);\n}\n\nvec3 image(vec2 uv) {\n    float x = channel(uv, iTime);\n    float y = channel(uv, -iTime);\n    //float z = x+y / x-y;\n    float z1 = abs(-y / (x+y));\n    float z2 = abs(x*y/(x+y));\n    float z3 = abs(x*y/(x-y));\n    // reverse time symmetry\n    return vec3(z1,z2,0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2.0;\n    uv -= 1.0;\n    // Output to screen\n    fragColor = vec4(image(uv),1.0);\n}\n\n// todo checkout mobius inv\n// todo checkout fixed point formulation. still needs 4 points. it maps z1 to z2 and z3 to z4.",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}