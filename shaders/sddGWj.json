{
    "Shader": {
        "info": {
            "date": "1631640563",
            "description": "4D medusa chillin",
            "flags": 32,
            "hasliked": 0,
            "id": "sddGWj",
            "likes": 3,
            "name": "4D Medusa",
            "published": 3,
            "tags": [
                "raymarching4dcubeunderwater"
            ],
            "usePreview": 0,
            "username": "dominionxvii",
            "viewed": 235
        },
        "renderpass": [
            {
                "code": "\nvec2 pulseDir = vec2(-0.5, 0.866);\n\nbool IsInFrame(vec2 uv)\n{\n   return (uv.x > 0. && uv.y > 0. && uv.x < 1. && uv.y < 1.);\n}\n\nvec4 FakeVolumetricLight(vec2 uv, float thicc, float speed, float offset, float offsetHeight, float offsetAngle, uint state)\n{\n    float a = atan(pulseDir.y / pulseDir.x) + offsetAngle;\n    \n    float height = easeOutQuad(uv.y - offsetHeight);\n    vec2 prevUv = uv;\n    \n    uv -= 0.5;\n    uv = RotateZ(vec3(uv, 1.0), -a).xy;\n    uv += 0.5;\n    \n    if(uv.y > uv.x - thicc && uv.y < uv.x + thicc)\n    {\n        //God rays\n        float dist = height - distance(uv.y, uv.x);\n        float light = 0.2 * (sin(((iTime * speed) + offset) * TAU - PI/2.) * 0.5 + 0.5);\n        float godRay = light * height * dist;\n        return vec4(godRay);        \n    }\n\n    return vec4(0.0);\n}\n\nvec4 LightSparkles(vec2 uv)\n{\n    //Nasty rescaling from [0,1] to around [-.5, 5.] based on resolution\n    uv *= iResolution.xy;\n    uv = (uv-0.5*iResolution.xy)/iResolution.y;\n\n    uv.y -= iTime * 0.1;\n\n    float spread = 0.05;\n    uv /= spread;\n    \n    float size = 0.025;\n    \n    float cell = cellular(uv).x;\n    float dist = saturate(size - cell) / size;\n    \n    return vec4(dist);\n}\n\nvec4 LightStreak(vec2 uv, vec2 dir)\n{\n\n\n    //Poorly adjust the uv to compensate for the different uv \n    uv -= 0.5;\n    uv = RotateZ(vec3(uv, 1.0), -0.13).xy;\n    uv += 0.5;\n    \n    \n   vec4 sum = vec4(0.0);\n\n   float streakLen = 0.125;\n   int count = 50; //boost for bootiful\n   float steps = streakLen / float(count);\n   \n   float distoSpeed = 0.1;\n   float intensity = 1.25;\n\n   for(int i = 0; i < count; i++)\n   {   \n       vec2 uv2 = uv + dir * float(i) * steps;\n       float iratio = 1. - (float(i) / float(count - 1));\n       \n       bool verticalStreakInRange = dir.y == -1. && dir.x == 0.0 && uv2.y >= 0.;\n       bool radialStreakInRange = IsInFrame(uv2);\n       \n       if(verticalStreakInRange || radialStreakInRange)\n       {\n           vec4 col = texture(iChannel0, uv2);\n           sum += saturate(vec4(col.rgb * col.a, col.a)) * iratio;\n       }\n     }\n \n  // float filterNoise = norm(fbm_4r(vec3(uv * 5., iTime * 0.3), m3));\n   return (sum / float(count)) * intensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    \n    float speed = 0.25;\n    int godRayCount = 32;\n    float godRayRatio = 1. / float(godRayCount);\n    \n    vec4 godRayMask = vec4(0.);\n    \n    for(int i = 0; i < godRayCount; i++)\n    {\n        float ratio = float(i) * godRayRatio;\n        \n        uint seed = uint(floor(iTime * speed + ratio) + float(i) * 643.32);\n        uint state = WangHash(seed);\n    \n        float xOffset = NextFloat(-0.75, 0.75, state);\n        float size = NextFloat(0.001, 0.2, state);\n        float offsetAngle = NextFloat(-0.02, 0.02, state);\n        float amplitude = NextFloat(0.05, 0.15, state);\n        float height = NextFloat(0.0, 0.2, state);\n        vec4 light = FakeVolumetricLight(uv + vec2(xOffset, 0.0), size, speed, ratio, height, offsetAngle, state) * amplitude;\n        col += light;\n        godRayMask += light;\n    }\n\n    col += saturate(godRayMask * 10.) * LightSparkles(uv) * 0.15;\n    col += saturate(godRayMask * 10.) * LightSparkles(uv * 2.0) * 0.15;\n    col += saturate(godRayMask * 10.) * LightSparkles(uv * 3.0) * 0.15;\n\n    //col -= LightStreak(uv, pulseDir);\n    \n    col = saturate(col);\n    fragColor =col;\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.1416\n#define TAU 6.2831\n\nvec3 vecX(float x)\n{\n    return vec3(x, 0.0, 0.0);\n}\nvec3 vecY(float y)\n{\n    return vec3(0.0, y, 0.0);\n}\nvec3 vecZ(float z)\n{\n    return vec3(0.0, 0.0, z);\n}\nfloat norm(float x)\n{\n    return x * 0.5 + 0.5;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x)\n{\n    return vec3(saturate(x.x), saturate(x.y), saturate(x.z));\n}\n\nvec4 saturate(vec4 x)\n{\n    return vec4(saturate(x.x), saturate(x.y), saturate(x.z), saturate(x.w));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat unlerp(float x, float fromMin, float fromMax)\n{\n    return (x - fromMin) / (fromMax - fromMin);\n}\n\nfloat Remap(float fromMin, float fromMax, float toMin, float toMax, float x)\n{\n    float t = saturate(unlerp(x, fromMin, fromMax));\n    return mix(toMin, toMax, t);\n}\n\nfloat ReduceResolution(float x, float resolution)\n{\n    return floor(x * resolution) / resolution;\n}\n\nvec2 ReduceResolution(vec2 x, float resolution)\n{\n    return floor(x * resolution) / resolution;\n}\n\nvec3 RotateZ(vec3 p, float a)\n{\n    float c = cos(-a);\n    float s = sin(-a);\n    return vec3(\n        p.x * c - p.y * s,   \n        p.x * s + p.y * c,\n        p.z);\n}\n\nvec3 RotateY(vec3 p, float a)\n{\n    float c = cos(-a);\n    float s = sin(-a);\n    return vec3(\n        p.x * c - p.z * s,\n        p.y,\n        p.x * s + p.z * c);\n}\n\n//delay attack sustain release\nfloat DASRCurve(float t, float delay, float attack, float sustain, float release)\n{\n    if(t < delay)\n        return 0.0;\n    if(t < attack)\n        return Remap(delay, attack, 0.0, 1.0, t);\n    if(t < sustain)\n        return 1.0;\n    else if(t < release)\n        return Remap(sustain, release, 1.0, 0.0, t);\n    else\n        return 0.0;\n        \n}\nfloat remap(float v, float fmn, float fmx, float tmn, float tmx) {\n    return saturate((v-fmn) / (fmx-fmn)) * (tmx-tmn) + tmn;\n}\n\n//IQ https://iquilezles.org\n\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float ra )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - ra*ra*baba;\n    float h = b*b - a*c;\n    if( h >= 0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n        float y = baoa + t*bard;\n        // body\n        if( y>0.0 && y<baba ) return t;\n        // caps\n        vec3 oc = (y <= 0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - ra*ra;\n        h = b*b - c;\n        if( h>0.0 ) return -b - sqrt(h);\n    }\n    return -1.0;\n}\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n\nvec3 opTwist(vec3 p, float k)\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec3 opRepLim( in vec3 p, in float c, in vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\nvec3 opRepLim( in vec3 p, in vec3 c,  in vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nfloat pow2(float x) { return x * x; }\n\n//Ease, https://easings.net\n\nfloat easeInOutCubic(float x)\n{\n    return x < 0.5 ? 4. * x * x * x : 1. - pow(-2. * x + 2., 3.) / 2.;\n}\n\nfloat easeInOutQuad(float x)\n{\n    return x < 0.5 ? 2. * x * x : 1. - pow(-2. * x + 2., 2.) / 2.;\n}\n\nfloat easeOutBounce(float x)\n{\n    const float n1 = 7.5625;\n    const float d1 = 2.75;\n\n    if (x < 1.0 / d1) {\n        return n1 * x * x;\n    } else if (x < 2.0 / d1) {\n        return n1 * (x -= 1.5 / d1) * x + 0.75;\n    } else if (x < 2.5 / d1) {\n        return n1 * (x -= 2.25 / d1) * x + 0.9375;\n    } else {\n        return n1 * (x -= 2.625 / d1) * x + 0.984375;\n    }\n}\nfloat easeOutElastic(float x)\n{\n    const float c4 = (2.0 * PI) / 5.0;\n\n    return x == 0.0\n      ? 0.0\n      : x == 1.0\n      ? 1.0\n      : pow(2.0, -10.0 * x) * sin((x * 10.0 - 0.75) * c4) + 1.0;\n}\nfloat easeInOutBack(float x) \n{\n    const float c1 = 1.70158;\n    const float c2 = c1 * 1.525;\n\n    return x < 0.5\n      ? (pow(2.0 * x, 2.0) * ((c2 + 1.0) * 2.0 * x - c2)) / 2.0\n      : (pow(2.0 * x - 2.0, 2.0) * ((c2 + 1.0) * (x * 2.0 - 2.0) + c2) + 2.0) / 2.0;\n}\n\nfloat easeInBack(float x)\n{\n    const float c1 = 1.70158;\n    const float c3 = c1 + 1.0;\n\n    return c3 * x * x * x - c1 * x * x;\n}\n\nfloat easeOutBack(float x)\n{\n    const float c1 = 1.70158;\n    const float c3 = c1 + 1.0;\n\n    return 1.0 + c3 * pow(x - 1.0, 3.0) + c1 * pow(x - 1.0, 2.0);\n}\n\nfloat easeInCirc(float x)\n{\n    return 1.0 - sqrt(1.0 - pow(x, 2.0));\n}\n\nfloat easeInQuad(float x)\n{\n    return x * x;\n}\n\nfloat easeOutQuad(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x);\n}\n\nfloat easeInCubic(float x)\n{\n    return x * x * x;\n}\n\nfloat easeOutCubic(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x) * (1.0 - x);\n}\n\nfloat easeOutCirc(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x) * (1.0 - x) * (1.0 - x) * (1.0 - x);\n}\n\n//HASH / noise\n\n\nfloat cheapNoise(vec2 v)\n{\n    return \n        0.333 * sin(v.x + 3.151) +\n        0.333 * sin(v.y + 8.357) + \n        0.333 * cos((v.x + v.y) + 3.723);\n\n}\n\nfloat cheapNoiseRepeat(float x, float t, float period, float amp)\n{\n    t = mod(t, period);\n    t /= period;\n    vec2 v = vec2(amp * sin(x + TAU * t), amp * cos(x + TAU * t));\n    \n    return cheapNoise(v);\n}\n\n\n\nvec3 cheapNoise(float x, float t)\n{\n    return vec3(\n        cheapNoise(vec2(x, x + t + 126.)),\n        cheapNoise(vec2(x + 26.34, x + t + 252.)),\n        cheapNoise(vec2(x + 12.63, x + t + 623.))\n        );\n}\n\n\nvec3 cheapNoise(vec3 v, float t)\n{\n    return vec3(\n        cheapNoise(vec2(v.x, v.y + t + 126.)),\n        cheapNoise(vec2(v.y, v.z + t + 252.)),\n        cheapNoise(vec2(v.z, v.x + t + 623.))\n        );\n}\n\n\n//Personal easing\n\nfloat OverShoot(float x, float overshoot, float undershoot, float sinSpeed, float sinAmp)\n{\n    float sinvalue = sinAmp * sin(x * TAU * sinSpeed);\n\n    float s = x * x * (3. - 2. * x); //smooth step\n    float a = overshoot * pow2(s);\n    float b = 1. - undershoot * pow2(s - 1.);\n    return easeInOutQuad(mix(a, b, s)) + sinvalue;\n}\n\n\nfloat OverShoot(float x)\n{\n    float sinSpeed = 2.;\n    float sinAmp = 0.075;\n    return OverShoot(x, 2.5, 0.5, sinSpeed, sinAmp);\n}\nfloat OverShootDx(float x)\n{\n    float dx = 0.001;\n    return (OverShoot(x + dx) - OverShoot(x)) / dx;\n}\n\n// NOISE\n// All this section is taken from \n//https://github.com/Unity-Technologies/Unity.Mathematics/blob/master/src/Unity.Mathematics/Noise/noise2D.cs\n\nfloat mod289(float x)  \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 mod289(vec3 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\n vec4 mod289(vec4 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) \n{ return mod289((34.0 * x + 1.0) * x); }\nvec4 permute(vec4 x) \n{ return mod289((34.0 * x + 1.0) * x); }\nvec3 mod7(vec3 x) \n{ return x - floor(x * (1.0f / 7.0f)) * 7.0f; }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nvec2 fade(vec2 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\nvec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\nvec4 fade(vec4 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n        \nvec2 cellular(vec2 P)\n{\n    const float K = 0.142857142857f; // 1/7\n    const float Ko = 0.428571428571f; // 3/7\n    const float jitter = 1.0f; // Less gives more regular pattern\n\n    vec2 Pi = mod289(floor(P));\n    vec2 Pf = fract(P);\n    vec3 oi = vec3(-1.0, 0.0, 1.0);\n    vec3 of = vec3(-0.5, 0.5, 1.5);\n    vec3 px = permute(Pi.x + oi);\n    vec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n    vec3 ox = fract(p * K) - Ko;\n    vec3 oy = mod7(floor(p * K)) * K - Ko;\n    vec3 dx = Pf.x + 0.5 + jitter * ox;\n    vec3 dy = Pf.y - of + jitter * oy;\n    vec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n    p = permute(px.y + Pi.y + oi); // p21, p22, p23\n    ox = fract(p * K) - Ko;\n    oy = mod7(floor(p * K)) * K - Ko;\n    dx = Pf.x - 0.5 + jitter * ox;\n    dy = Pf.y - of + jitter * oy;\n    vec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n    p = permute(px.z + Pi.y + oi); // p31, p32, p33\n    ox = fract(p * K) - Ko;\n    oy = mod7(floor(p * K)) * K - Ko;\n    dx = Pf.x - 1.5 + jitter * ox;\n    dy = Pf.y - of + jitter * oy;\n    vec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n    // Sort out the two smallest distances (F1, F2)\n    vec3 d1a = min(d1, d2);\n    d2 = max(d1, d2); // Swap to keep candidates for F2\n    d2 = min(d2, d3); // neither F1 nor F2 are now in d3\n    d1 = min(d1a, d2); // F1 is now in d1\n    d2 = max(d1a, d2); // Swap to keep candidates for F2\n    d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n    d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n    d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n    d1.y = min(d1.y, d1.z); // nor in  d1.z\n    d1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n    return sqrt(d1.xy);\n}\n\n// RNG\nuint WangHash(uint n)\n{\n    // https://gist.github.com/badboy/6267743#hash-function-construction-principles\n    // Wang hash: this has the property that none of the outputs will\n    // collide with each other, which is important for the purposes of\n    // seeding a random number generator.  This was verified empirically\n    // by checking all 2^32 uints.\n    n = (n ^ 61u) ^ (n >> 16);\n    n *= 9u;\n    n = n ^ (n >> 4);\n    n *= 0x27d4eb2du;\n    n = n ^ (n >> 15);\n\n    return n;\n}\n\nuint NextState(uint state)\n{\n    state ^= state << 13;\n    state ^= state >> 17;\n    state ^= state << 5;\n    return state;\n}\n\nfloat NextFloat(float xmin, float xmax, inout uint state)\n{\n    state = NextState(state);\n    int n = int(state % 1000u);\n    float t = float(n) / 1000.;   \n    return mix(xmin, xmax, t);\n}\n\nvec2 NextVec2(vec2 rmin, vec2 rmax, inout uint state)\n{\n    float x = NextFloat(rmin.x, rmax.x, state);\n    float y = NextFloat(rmin.y, rmax.y, state);\n    return vec2(x, y);\n}\n\nvec3 NextVec3(vec3 rmin, vec3 rmax, inout uint state)\n{\n    float x = NextFloat(rmin.x, rmax.x, state);\n    float y = NextFloat(rmin.y, rmax.y, state);\n    float z = NextFloat(rmin.z, rmax.z, state);\n    return vec3(x, y, z);\n}\n\n//Quaternions\n\n// Quaternion multiplication.\n// http://mathworld.wolfram.com/Quaternion.html\nvec4 qmul(vec4 q1, vec4 q2)\n{\n    return vec4(\n        q2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),\n        q1.w * q2.w - dot(q1.xyz, q2.xyz)\n    );\n}\n\n// Rotate a vector with a rotation quaternion.\n// http://mathworld.wolfram.com/Quaternion.html\nvec3 qmul(vec4 r, vec3 v)\n{\n    vec4 r_c = r * vec4(-1.0, -1.0, -1.0, 1.0);\n    return qmul(r, qmul(vec4(v, 0.0), r_c)).xyz;\n}\n\nvec4 qAxisAngleRotation(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s,c;\n\ts = sin(angle);\n    c = cos(angle);\n\treturn vec4(axis.x*s,axis.y*s,axis.z*s,c);\n}\n\nvec4 qInverse(vec4 q)\n{\n    vec4 x = q;\n    return vec4(1.0/(dot(x, x)) * x * vec4(-1.0, -1.0, -1.0, 1.0));\n}\n\n\n//Camera model\n\nvoid PerspectiveCam(vec3 camPos, vec4 camRot, vec2 uv, float fovFactor, out vec3 ro, out vec3 rd)\n{\n    vec3 forward = normalize(vec3(uv.x * fovFactor, uv.y * fovFactor, 1.0));\n\n    ro = camPos;\n    rd = qmul(camRot, forward);\n}\n\n\nvoid OrthographicCam(vec3 camPos, vec4 camRot, vec2 uv, float zoom, out vec3 ro, out vec3 rd)\n{    \n    vec3 up = qmul(camRot, vecY(1.0));\n    vec3 right = qmul(camRot, vecX(1.0));\n\n    ro = camPos + (up * uv.y + right * uv.x) * (1.0 / zoom);\n    rd = qmul(camRot, vecZ(1.0));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//uncomment for hd\n#define HD\n\n\nconst int dimension = 4;\nconst int edgeLength = dimension * (2 << (dimension - 2));\nconst int verticeLength = (2 << dimension);\n\nconst int tentacleJoint = 12;\nconst float armLength = 0.25;\n\nconst int tentaclePosLength = tentacleJoint * verticeLength;\nconst float loopSteps = 4.;\n\n\nvec4 verticesRaw[verticeLength];\nvec3 vertices[verticeLength];\nivec2 edges[edgeLength];\nvec3 tentaclePos[tentaclePosLength];\n\nfloat cameraDist = 7.5;\n\nfloat timeScale = 1. / 7.2; // match to 100 bpm\nfloat iTimeS;\nmat4 rot;\n\nfloat pulse;\nfloat pulseRatio;\nfloat pulseDx;\n\nvec3 pulseDir = vec3(-0.5, 0.866, 0.0);\n\nstruct RayHit \n{\n    bool hasHit;\n    vec3 hitPos;\n    float dist;\n    float col;\n};\n\n\nmat4 rotation_XZ(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat4(\n        vec4(c  , 0.0, s  , 0.0),\n        vec4(0.0, 1.0, 0.0, 0.0),\n        vec4(-s , 0.0, c  , 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nmat4 rotation_YZ(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat4(\n        vec4(1.0, 0.0, 0.0, 0.0),\n        vec4(0.0, c  , -s , 0.0),\n        vec4(0.0, s  , c  , 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\n\nmat4 rotation_XY(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat4(\n        vec4(c  , -s , 0.0, 0.0),\n        vec4(s  , c  , 0.0, 0.0),\n        vec4(0.0, 0.0, 1.0, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nmat4 rotation_XW(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat4(\n        vec4(c  , 0.0, 0.0, -s ),\n        vec4(0.0, 1.0, 0.0, 0.0),\n        vec4(0.0, 0.0, 1.0, 0.0),\n        vec4(s  , 0.0, 0.0, c  )\n    );\n}\n\nmat4 rotation_YW(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat4(\n        vec4(1.0, 0.0, 0.0, 0  ),\n        vec4(0.0, c  , 0.0, -s),\n        vec4(0.0, 0.0, 1.0, 0.0),\n        vec4(0.0, s  , 0.0, c  )\n    );\n}\n\nvec3 to3d(vec4 pos4d)\n{\n    vec4 pos4dRot = rot * pos4d;\n    pos4dRot.xyz += normalize(pos4dRot.xyz) * (pos4dRot.w + 0.5) * 0.7;\n    return pos4dRot.xyz;\n}\n\n//\n\nfloat MedusaIntersection(vec3 ro, vec3 rd)\n{\n    float capsuleSize = 0.02;\n    \n    float bodyAlpha = 1.0;\n    float tentacleAlpha = 0.5;\n    \n    for(int i = 0; i < edgeLength; i++)\n    {\n        vec3 v1 = vertices[edges[i].x];\n        vec3 v2 = vertices[edges[i].y];\n        \n        float wiggle = 0.01;\n        float d = capIntersect(ro, rd, v1, v2, capsuleSize);\n\n        if(d != -1.0)\n            return bodyAlpha;\n    }\n    \n    float maxAlpha = 0.0;\n    for(int i = 0; i < verticeLength; i++)\n    {\n        int offset = i * tentacleJoint;\n        \n        for(int j = 1; j < tentacleJoint; j++)\n        {\n            vec3 v1 = tentaclePos[offset + j - 1];\n            vec3 v2 = tentaclePos[offset + j];\n            vec3 ro2 = ro + 0.15 * cheapNoise(ro + rd, iTimeS);\n            \n            float ratio = float(j) / float(tentacleJoint - 1);\n            float foffset = float(offset);\n            vec3 offset = 0.05 * cheapNoise(v1 + ratio * 15.25, iTimeS * 2.0);\n            \n            float sphereScale = 0.15 * (1.0 - ratio);\n            float d = sphIntersect(ro, rd, v1 + offset, sphereScale).x;            \n            \n            if(d != -1.0)\n            {    \n                float depthAlpha = saturate(remap(d, cameraDist - 0.5, cameraDist + 0.5, 1.0, 0.25)); \n                float ratio = float(j) / float(tentacleJoint - 1);\n                float alpha =  ratio * tentacleAlpha * depthAlpha;\n                maxAlpha = max(maxAlpha, alpha);\n            }\n        }\n    }\n      \n    return maxAlpha;\n}\n\nRayHit RayCast(vec3 ro, vec3 rd)\n{\n    float col = MedusaIntersection(ro, rd);\n    RayHit rayHit;\n    \n    rayHit.hasHit = col != -1.0;\n    rayHit.col = col;\n    return rayHit;\n}\n\nvec4 GetColor(RayHit hit, vec3 viewDir, vec2 uv)\n{\n    return vec4(1.0);\n}\n\nvoid PrepareVertices()\n{\n    int i = 0;\n    for(int w = 0; w <= 1; w++)\n    for(int z = 0; z <= 1; z++)\n    for(int y = 0; y <= 1; y++)\n    for(int x = 0; x <= 1; x++)\n    {\n        \n        //norm between [-0.5, 0.5]\n        verticesRaw[i] = vec4(x, y, z, w) - vec4(0.5);\n        vertices[i] = to3d(verticesRaw[i]);\n        i++;\n    }   \n    \n    //tentacles\n    for(i = 0; i < verticeLength; i++)\n    {\n        int offset = i * tentacleJoint;\n        tentaclePos[offset] =  vertices[i];\n        for(int j = 1; j < tentacleJoint; j++)\n        {\n            int k = offset + j;\n            vec3 noPulseDir = normalize(vertices[i] - pulseDir * 1.75);\n            \n            vec3 invPulseDir = -pulseDir;\n            vec3 orthoDir = -normalize(cross(pulseDir, vertices[i]));\n            \n            vec3 pulseDir = mix(invPulseDir, orthoDir, 0.2);\n            \n            float ratio = float(j) / float(tentacleJoint - 1);\n            ratio = easeOutQuad(ratio);\n            \n            float pulseDxOffset = OverShootDx(fract(pulseRatio - 0.1));\n            float t = pulseDxOffset * ratio * 1.5;\n\n            vec3 currentDir = normalize(mix(noPulseDir, pulseDir, t));\n\n            tentaclePos[k] = tentaclePos[k - 1] + currentDir * armLength;\n        }\n    }\n}\n\nvoid PrepareEdges()\n{\n    edges[0] = ivec2(0, 1);\n\n    int l = 1;\n    for (int dim = 2; dim <= dimension; dim++)\n    {\n        int dimPower = 2 << (dim - 2);\n        int vertexOffset = dimPower;\n        int edgeNumber = dim * dimPower;\n        int count = l;\n\n        //duplicate all edges with offset\n        for (int i = 0; i < count; i++)\n        {\n            edges[l++] = ivec2(vertexOffset + edges[i].x, vertexOffset + edges[i].y);\n        }\n\n        count = edgeNumber - l;\n        for (int i = 0; i < count; i++)\n        {\n            edges[l++] = ivec2(i, i + count);\n        }\n    }\n}\n\nbool InSphere(vec2 uv, vec2 pos, float radius, float thicc)\n{\n    float d = distance(uv, pos);\n    return d < radius + thicc && d > radius;\n}\n\nvec4 BubbleBurst(vec2 uv, float uvScaling, float speed)\n{\n    float strip1 = 0.35;\n    float strip2 = 0.45;\n    float fwStrip = 0.5;\n    \n    vec2 rotuv = RotateZ(vec3(uv * uvScaling, 0.0), -15.0 / 360.0 * TAU).xy;\n    float upperStrip = Remap(strip1 - rotuv.x, strip2  - rotuv.x, 1.0, 0.0, rotuv.y);\n    float lowerStrip = Remap(-strip1 - rotuv.x, -strip2  - rotuv.x, 1.0, 0.0, rotuv.y);\n    float forwardStrip = saturate(rotuv.x - rotuv.y);\n    \n    float stripPower = min(min(upperStrip, lowerStrip), forwardStrip);\n    if(stripPower <= 0.0)\n        return vec4(0.0);\n    \n    float repeat = 0.2;\n    vec2 center = vec2(repeat / 2.0);\n    \n    uv += pulseDir.xy * pulse * 3.0 - vec2(0.0, 2.0) * pulseRatio;\n    uv *= uvScaling;\n    vec2 i = floor(uv / repeat);\n    uv = mod(uv, repeat);\n    \n   //debug lines\n    //if(uv.x < 0.005 || uv.y < 0.005)\n    //    return vec4(0.75);\n    \n    float bubbleRadiusMin = 0.01;\n    float bubbleRadiusMax = 0.02;\n\n    uint seed = 2u;\n    uint state = WangHash(seed + uint((23.0 + i.x) + (62.0 + i.y * 5.0)));\n\n    float bubbleRadius = NextFloat(bubbleRadiusMin, bubbleRadiusMax, state);\n    float bubbleThicc = 0.005;\n    float wiggleRadius = 0.15;\n    \n    float randomRange = center.x - bubbleRadius - bubbleThicc - wiggleRadius;\n    vec2 rmin = vec2(-randomRange);\n    vec2 rmax = vec2(randomRange);\n    vec2 rngOffset = NextVec2(rmin, rmax, state);\n    \n    if(InSphere(uv, center + rngOffset, bubbleRadius, bubbleThicc))\n    { \n        return vec4(1.0) * stripPower;\n    }\n    \n    return vec4(0.0);\n}\n\nvec4 GenerateBubbleBurst(vec2 uv)\n{\n    const int row = 15;\n    const int col = 10;\n    const float colAngle = TAU / float(col);\n    const float spinRow = 0.2;\n    \n    float radius = 0.01;\n    float thicc = 0.005;\n\n    float distRadius = 0.05;\n    \n    float spinAngle = pulse * TAU / 4.0;\n    \n    float rowHeight = 15.;\n    \n\n    vec4 rot = qAxisAngleRotation(pulseDir, PI / 4.0);\n    vec2 uv2 = RotateZ(vec3(uv.x, uv.y, 0.0), PI / 4.7).xy;\n    \n    float localY = uv2.y;\n    uv2.y += pulseRatio * 2.5;\n\n    float ypos = uv2.y + radius + thicc;\n    float i = floor(ypos * rowHeight);\n\n    float spinAngleRow = i * spinRow; \n    vec3 start = vecY(i / rowHeight);\n    \n    float cutoff = 0.5;\n    localY = -localY - 0.2;\n    float heightIntensity = DASRCurve(localY, -0.2, 0.2, cutoff, 1.0);\n    heightIntensity = \n        (localY <= cutoff) ?\n          easeOutCubic(heightIntensity) :\n          easeInCubic(heightIntensity);\n         \n    distRadius += -pulseDx * 0.02 + heightIntensity * 0.2;\n    \n    float curIntensity = 0.0;\n    for(int j = 0; j < col; j++)\n    {        \n        float a = float(j) * colAngle + spinAngleRow + spinAngle;            \n        vec3 pos = start + RotateY(vecZ(distRadius), a);\n        \n        if(InSphere(uv2, pos.xy, radius, thicc))\n        {   \n            float depthIntensity = saturate((pos.z + distRadius + 0.03) / (distRadius * 2.0));\n            float intensity = heightIntensity * depthIntensity;\n\n            curIntensity = max(curIntensity, intensity);\n        }\n    }\n\n    return vec4(curIntensity * 0.5);\n}\n\nvec4 GenerateBubble(vec2 f, ivec2 i, out vec2 bubbleCenter)\n{\n    uint seed = 2u + uint(i.x + i.y * 5);\n    //seed = seed % 1u;\n    \n    uint state = WangHash(seed);\n\n    //debug lines\n    if(f.x < 0.01 || f.y < 0.01)\n        return vec4(0.075);\n    \n    float bubbleRadiusMin = 0.002;\n    float bubbleRadiusMax = 0.05;\n\n    float bubbleRadius = NextFloat(bubbleRadiusMin, bubbleRadiusMax, state);\n    float bubbleThicc = 0.0075;\n    float wiggleRadius = 0.05;\n    \n    float randomRange = 0.5 - bubbleRadius - bubbleThicc - wiggleRadius;\n    vec2 rmin = vec2(-randomRange);\n    vec2 rmax = vec2(randomRange);\n    vec2 rngOffset = NextVec2(rmin, rmax, state);\n    \n    f += rngOffset;\n    \n    float wiggleSpeed = 10.0;\n    f += vec2(sin(wiggleSpeed * iTimeS + float(i.x) * 252.2), sin(wiggleSpeed * iTimeS + float(i.y) * 31.2)) * wiggleRadius;\n    \n    bubbleCenter = f;\n    float d = distance(bubbleCenter, vec2(0.5));\n    \n    if(d > bubbleRadius && d < bubbleRadius + bubbleThicc)\n        return vec4(1.0);\n        \n   return vec4(0.0);\n}\n\n\nvec4 GetBubbleColor(vec2 uv, float scaledown, vec2 offset, float speed)\n{\n    uv *= scaledown;\n    uv += offset;\n\n    //fake camera movement\n    float timeStep = floor(iTimeS);\n        \n       \n    float pulseDist = 6.0; //6\n    \n    //going fastttt\n    uv += pulseDist * (timeStep + pulse) * pulseDir.xy;\n    \n    //feels like the medusa is going down a bit when standing still\n    uv += vec2(0.0, -iTimeS * 2.0);\n    \n\n    float size = 0.75;\n    uv = (uv + vec2(0.5)) * size;\n  \n    uv += vec2(0.5, 1.0) * speed * iTimeS;\n \n    //vec2 loopOffset = ((vec3(1) - pulseDir) / loopSteps).xy;\n    //uv += loopOffset * pulseRatio;\n \n    ivec2 i = ivec2(floor(uv)); \n    vec2 f = fract(uv);\n    \n    vec2 bCenter;\n    vec4 bubbleCol = GenerateBubble(f, i, bCenter);\n    \n    \n    return bubbleCol;\n}\n\nvoid PrepareCubeData()\n{\n    pulseRatio = fract(iTimeS);\n    pulse = OverShoot(pulseRatio);  \n    pulseDx = OverShootDx(pulseRatio);\n        \n    float angle4D = pulse * (TAU / 4.0);\n\n    mat4 rotRoll = rotation_XY(1.0472);\n    mat4 rotYaw = rotation_XZ(PI / 8.0);  \n    mat4 rotPitch = rotation_YZ(pulse * PI + PI / 8.0);    \n    mat4 roll4D = rotation_XW(angle4D);\n    \n    rot = rotRoll * rotYaw * rotPitch * roll4D;\n    \n    PrepareVertices();\n    PrepareEdges();\n}\n\nvec4 Render(vec2 uv)\n{\n    vec4 col = vec4(0.);\n    float shakeIntensity = 0.1;\n    float shakeSpeed = 1.0;\n    //vec2 shakeNoise = vec2(cheapNoise(vec2(iTimeS * shakeSpeed, 0.0)),cheapNoise(vec2(0.0, iTimeS * shakeSpeed)));\n    vec2 shakeNoise = vec2(\n        cheapNoiseRepeat(2353., iTimeS * shakeSpeed, 1.0, 1.0),\n        cheapNoiseRepeat(3624., iTimeS * shakeSpeed, 1.0, 1.0));\n\n    uv += shakeIntensity * shakeNoise;\n    \n    //Pixelize\n    float resolution = 750.0;\n    //uv = ReduceResolution(uv, resolution);\n    \n    vec3 camPos = vec3(0.0, 0.0, -cameraDist);\n      \n    mat4 rotYaw = rotation_XZ(PI / 8.0);  \n    mat4 rotRoll = rotation_XY(PI / 8.0);\n\n    \n    vec4 camRot = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    float zoom = 0.1;\n    \n    \n    vec2 uvMedusa = uv + sin(pulse * TAU) * pulseDir.xy * 0.2; \n\n    vec3 ro, rd;\n    OrthographicCam(camPos, camRot, uvMedusa, zoom, ro, rd);\n    //PerspectiveCam(camPos, camRot, uv, 1.0, ro, rd);\n    \n    \n    RayHit hit = RayCast(ro, rd);\n    if(hit.hasHit)\n    {\n        col = vec4(vec3(hit.col), 1.0);\n    }\n    else\n    {\n        col = vec4(0.0);\n    }\n    \n    float burstRatio = \n        DASRCurve(pulseRatio, 0.3, 0.43, 0.5, 1.0);\n    \n    //fragColor += GenerateBubbleBurst(uvMedusa) * burstRatio;\n    col += BubbleBurst(uvMedusa, 1.5, 1.0) * burstRatio * 1.0;\n    col += BubbleBurst(uvMedusa, 2.0, 1.0) * burstRatio * 0.75;\n    col += BubbleBurst(uvMedusa, 3.0, 1.0) * burstRatio * 0.5; \n    \n    \n    col += GetBubbleColor(uv, 4.0, vec2(2.0, 3.0), 0.2);\n    col += GetBubbleColor(uv, 7.0, vec2(5.3, 2.0), 0.2) * 0.5;\n    col += GetBubbleColor(uv, 8.0, vec2(8.2, 3.4), 0.2) * 0.25;\n    col += GetBubbleColor(uv, 10.0, vec2(2.7, 1.2), 0.2) * 0.125;\n    \n    return col;\n}\n\nvec4 RenderAntiAliasing(vec2 uv, vec2 fragCoord)\n{\n    vec4 colorSum = vec4(0.0);        \n    vec2 nextUv = ((fragCoord+vec2(1.0))-0.5*iResolution.xy)/iResolution.y;\n\n    colorSum += Render(uv);\n    colorSum += Render(mix(uv, vec2(uv.x, nextUv.y), 0.5));\n    colorSum += Render(mix(uv, vec2(nextUv.x, uv.y), 0.5));\n    colorSum += Render(mix(uv, nextUv, 0.5));\n    colorSum /= 4.0;\n    return colorSum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    iTimeS = iTime * timeScale;\n    \n    \n    //iTimeS = mod(iTimeS, loopSteps);\n    \n    PrepareCubeData();\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    fragColor = Render(uv);\n   \n#ifdef HD  \n    fragColor = RenderAntiAliasing(uv, fragCoord);  \n#else\n    fragColor = Render(uv); \n#endif\n\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}