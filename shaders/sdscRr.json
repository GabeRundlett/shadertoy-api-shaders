{
    "Shader": {
        "info": {
            "date": "1641819413",
            "description": "Mouse controls, camera.  swap #4 for textu\n\nreference: ( but I do the symmetric way )\n[url]https://twitter.com/akira2768922/status/1475077131151769613[/url]\n[url]https://www.reddit.com/r/desmos/comments/ry7zo8/production_line_manufacturing_boxes_d/[/url]\n",
            "flags": 0,
            "hasliked": 0,
            "id": "sdscRr",
            "likes": 62,
            "name": "box factory",
            "published": 3,
            "tags": [
                "origami",
                "reproduction"
            ],
            "usePreview": 1,
            "username": "FabriceNeyret2",
            "viewed": 679
        },
        "renderpass": [
            {
                "code": "#define rot(a)          mat2(cos(a+vec4(0,11,33,0)))                       // axial rotation\n#define rot3(P,A,a)   ( mix( A*dot(P,A), P, cos(a) ) + sin(a)*cross(P,A) ) // 3D rotation\n#define D(u)            vec4( vec3( smoothstep( 0., .1 ,  .5 - max(u.x,u.y) ) ), 1 ) // tile decoration\n//#define D(u)          texture( iChannel0, u )                            // tile decoration\n\nvoid mainImage(out vec4 O, vec2 U)\n{ \n    vec4  C = O-=O;\n    vec3  R = iResolution, c,A,\n          D = normalize(vec3(U+U-R.xy, 5.*R.y)),          // ray direction\n          p = vec3(0,0,-20), q,                           // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(10,6,0)/1e2*cos(.5*iTime+vec3(0,11,0))+vec3(0,.12,0);\n    M = vec3(0,.5,0) - 6.3*M;      \n    p.yz *= rot(M.y),                                     // camera rotations\n    p.xz *= rot(M.x); \n    D.yz *= rot(M.y),         \n    D.xz *= rot(M.x);\n    float T = mod(iTime,2.), n,i,t,a,s;\n    p.z += T - 7.;\n    for ( i=0.; i<10.; i++ ) {                            // --- folded parts ----------------\n        n = D.z > 0. ? 9.-i : i;                          // parse front to back\n        t = mod(T+n,6.), a = 1.57*fract(t);\n        vec2 CS = .707*sin(a+1.57/2.+vec2(1.57,0));\n        if (T<1.) c = vec3(3.,  0, -2.5), c.xy += CS, A = vec3( 0,0,1); // even roll\n        else      c = vec3(2.5, 0, -3. ), c.zy += CS, A = vec3(-1,0,0); // odd roll\n        c.xz -= floor(t/2.); c.z -= n;\n        if (mod(n,2.)>0.) c.x = -c.x, int(t)%2>0 ? c.x++ : c.z++, A.z = -A.z; // left side\n     // if ( (T>1. && n>3. ) || n>5. ) c = .5-vec3(0, 0, n<6. ? 10-int(t)%2 : 5+int(n) ), a=0.; // cubes tail\n        if ( (T>1. && n>3. ) || n>5. ) c = .5-vec3(0, n>4.?T+n-6.:0., n<6. ? 10-int(t)%2 : 5+int(n) ), // a = 0.;\n                                       A = vec3(-1,0,0), n!=6.-floor(T) ? a=0.: a;\n        q = p-c;\n     // if ( dot(q,q) - dot(q,D)*dot(q,D) < 1.  ) {\n            vec3 Pr = rot3(q,A,a), Dr = rot3(D,A,a),      // cube frame  \n                  v = (-.5*sign(Dr) - Pr ) / Dr ,P;       // intersection with cube planes\n     // if ( dot(Pr,Pr) - dot(Pr,Dr)*dot(Pr,Dr) < 1.  ) { // Bbox. why not working ?\n            int j;                                        // draw cube faces corresponding to folds\n            #define inter(i,s) P = abs(Pr + v[i]*Dr);                   \\\n                         j = int[](1,3,2,5,0,4)[ s Dr[i]>0.?3+i:i ];    \\\n                         if( v[i]>0. && max(P.x,max(P.y,P.z)) < .501 )  \\\n                        /**/ if( j <= int(T)+int(n/2.)*2 ) /**/         \\\n                          /**/  { int t = n<6. ? int(T):1; O += D( vec2( P[(i+1+t)%3], P[(i+2-t)%3] ) ); break;} /**/ \\\n                            //  { O[j%3] =j<3?.5:1.; O.a++; break; }   // attempt of time-consistant colors\n                            //  { O[i] =.5+step(s Dr[i],0.); return; } // debug : draw color cube\n            s = sign(c.x-.5);                             // left side \n            inter(0, s*); inter(1,); inter(2,);           // front cube faces\n            v = ( .5*sign(Dr) - Pr ) / Dr ,P;             // rear cube faces\n            inter(0,-s*); inter(1,-); inter(2,-);\n     // }\n    }\n    if ( O.a > 0. && ( D.y < 0. || D.z>0. && n+T > 6. ) ) return;\n                                                          // --- unfolded tiling -------------\n    q = p;                                                // intersection with plane y=0\n    t = -q.y/D.y; q += t*D;\n    if (t>0.) C += 1.-t/200., C.a = 1.;                   // pseudo shading\n\n    p = floor(q); if (3.*abs(p.x)-p.z > 10.+step(p.x,0.) ) C-=C;  // trim cells left by rolling cubes\n    if ( T > 1. &&  abs(p.x)<=2. && p.z == -9.+3.*abs(p.x)-step(p.x,0.) )  C-=C;\n    q.x += mod(ceil(q.z),2.);                             // offset\n    if  ( q.x < -2. || q.x > 4. || q.z < -10.) C-=C;      // tiling limits\n    \n    C *= D( abs( fract(q.xz) -.5) );                      // tiles decoration\n    \n    O = mix(O,C,C.a);                                     // --- blend folded and straight parts ---\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}