{
    "Shader": {
        "info": {
            "date": "1686763131",
            "description": "Small, self-contained spectrum approximation.\nUse at your own risk: this may or may not be a cunning application of Cunningham's Law.",
            "flags": 0,
            "hasliked": 0,
            "id": "msXyDH",
            "likes": 10,
            "name": "wavelength2rgb approx.",
            "published": 3,
            "tags": [
                "spectrum",
                "wavelength",
                "cie",
                "cmf"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 300
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Wavelength to RGB conversion, under CIE 1931 2Â° Standard Observer\n// (see https://en.wikipedia.org/wiki/CIE_1931_color_space#CIE_standard_observer )\n// using \"Simple Analytic Approximations to the CIE XYZ Color Matching Functions\",\n// (see https://jcgt.org/published/0002/02/01/), same as e.g. https://www.shadertoy.com/view/4ttBRB .\n\n// The approximation error is (claimed) below variance in source data.\n\n// Several potentially non-obvious points:\n//   1. Produced RGB may well be negative: sRGB is incapable\n//      of representing pure spectral colors. You can e.g. blend with\n//      gray background, or do something fancier.\n//   2. The core function works in linear space (XYZ and RGB)\n//      so conversion is necessary for a proper look, since\n//      Shadertoy (presumably) considers output a gamma-ful sRGB. Between\n//      the Shadertoy, browsers, and monitor profiles, this is\n//      a murky territory anyway.\n//   3. The XYZ values produced are \"densities\", in *wavelength domain*, i.e.\n//      you are supposed to integrate them with spectral radiance,\n//      see https://en.wikipedia.org/wiki/CIE_1931_color_space#Computing_XYZ_from_spectral_data .\n//      Sampling it is equivalent to integrating with delta-function,\n//      corresponding to a highly monochromatic light source *of unit intensity*.\n//      The plot of the function corresponds to a light source with a flat spectrum\n//      in *wavelength domain* (which is non-flat in frequency domain), which might\n//      be not what you want.\n//      For black body (e.g. Sun) spectrum you may use https://en.wikipedia.org/wiki/Planck%27s_law .\n\n// Helper function (separately-sloped gaussian).\nfloat f(float t,float l,float h) {t*=mix(l,h,step(0.0,t)); return exp(-0.5*t*t);}\n\n// Input is in nanometers.\nvec3 wavelength2xyz(float lambda)\n{\n    return vec3(\n        +0.362*f(lambda-442.0,0.0624,0.0374)\n        +1.056*f(lambda-599.8,0.0264,0.0323)\n        -0.065*f(lambda-501.1,0.0490,0.0382),\n        +0.821*f(lambda-568.8,0.0213,0.0247)\n        +0.286*f(lambda-530.9,0.0613,0.0322),\n        +1.217*f(lambda-437.0,0.0845,0.0278)\n        +0.681*f(lambda-459.0,0.0385,0.0725));\n}\n\n// Output is linear RGB.\nvec3 xyz2rgb(vec3 xyz)\n{\n    return mat3( // WARNING: column-major.\n        +3.2404542, -0.9692660, +0.0556434,\n        -1.5371385, +1.8760108, -0.2040259,\n        -0.4985314, +0.0415560, +1.0572252)*xyz;\n}\n\nvec3 linear2srgb(vec3 rgb)\n{\n    return mix(12.92*rgb,1.055*pow(rgb,vec3(1.0/2.4))-0.055,step(0.0031308,rgb));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    float lambda=mix(350.0,750.0,uv.x);\n    vec3 col=0.25+0.25*xyz2rgb(wavelength2xyz(lambda)); // Fits in [0;1]^3, just barely.\n    col=linear2srgb(col);\n    fragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}