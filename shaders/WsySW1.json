{
    "Shader": {
        "info": {
            "date": "1573871620",
            "description": "Colorsssss",
            "flags": 0,
            "hasliked": 0,
            "id": "WsySW1",
            "likes": 2,
            "name": "Codevember #15",
            "published": 3,
            "tags": [
                "sdf",
                "beginner",
                "newbie"
            ],
            "usePreview": 0,
            "username": "desertsky",
            "viewed": 346
        },
        "renderpass": [
            {
                "code": "float sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return float((p.x+p.y+p.z-s)*0.57735027);\n}\nvec2 sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return vec2(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),1.));\n}\n\nvec2 map(vec3 p)\n{\n    vec3 q = mod(p+0.5*2.,2.)-2.*.5;\n    vec2 pl = vec2(.7+p.y,0.);\n    \n    vec2 sphere = vec2(length(q) - .3,1.);\n    \n    vec2 box = vec2(sdOctahedron(q,.25),1.);\n    \n    vec2 morph = vec2(mix(sphere.x,box.x,sin(iTime)),1);\n\n//    sdf = min(sdf,sphere);\n\treturn (morph.x < pl.x) ? morph : pl;\n\n}\n\n\n//raymarching\nvec2 RM(vec3 ro, vec3 rd) \n{\n    float m = -1.;\n    float dO = 0.;\n    \n    for (int i = 0; i < 100; i++) {\n\n        vec2 p = map(ro + rd * dO);\n        m = p.y;\n        if (p.x <= .01) break;\n        dO+=p.x;\n        if (dO >= 20.) \n        {\n            dO = -1.;\n        \tbreak;\n        }        \n    }\n    return vec2(dO,m);\n}\n\n//normals\nvec3 n(vec3 p) \n{\n    float d = map(p).x;\n    vec2 e = vec2(.001,.0);\n    vec3 pn = d - vec3(\n        map(p-vec3(e.xyy)).x,\n        map(p-vec3(e.yxy)).x,\n        map(p-vec3(e.yyx)).x\n        );\n    return normalize(pn);\n}\n\n//lighting\nvec3 l(vec3 p)\n{\n    vec3 mat = vec3(1.,.75,.5);\n    vec3 nor = n(p);\n    vec3 sunDir = vec3(2,1.,-1);\n\n    vec3 sunDif = clamp(dot(nor,sunDir),0.,1.)*mat;\n\n    vec3 skyDif = clamp(dot(nor,vec3(0.,1.,0.)),0.,1.)*vec3(0.,2.,4.)*.02;\n\t\n    vec3 bounce = (clamp(dot(nor,sunDir*-1.),.0,1.))*vec3(1.)*.005;\n    \n//    float sunSha = step(RM(p+n(p)*.02,sunDir),0.);\n    \n    \n    return sunDif+skyDif+bounce;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(.1,.3,.5)*uv.y*2.;\n    \n\t\n    vec3 ro = vec3(sin(10.*iMouse.x/iResolution.x), sin(5.*iMouse.y/iResolution.y),cos(10.*iMouse.x/iResolution.x));\n    vec3 ta = vec3(0.);\n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww,vec3(.0,1.,.0)));\n    vec3 vv = normalize(cross(uu,ww));\n    \n    vec3 rd = normalize(uv.x*uu+uv.y*vv+1.5*ww);\n    \n    vec2 rm = RM(ro,rd);\n    \n    if(rm.x > -1.) \n    {\t\n\t\tvec3 p = ro + rd * rm.x;\n\t\tvec3 mate = vec3(0.);\n        if(rm.y == 0.) {         mate = vec3(.2,.2,0.1);}\n        else if(rm.y > 1.) {        mate = vec3(.0,1.,.0);}\n        else { mate = mix(vec3(.9,.8,9.),vec3(.3*p.x,.5*p.z/2.,.9-p.x),sin(iTime));}\n        \n    \tcol = vec3(l(p))*mate;\n    \t\n            // fog\t\t\n        col = mix( col, vec3(0.9), 1.0-exp( -0.00001*p*p ) );\n\n        \n//        col = vec3(rm.y);\n    }\n    \n    \n    //gamma\n    col = pow(col, vec3(.4545));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}