{
    "Shader": {
        "info": {
            "date": "1670536153",
            "description": "Some nested 11-gons.",
            "flags": 16,
            "hasliked": 0,
            "id": "DdjXRK",
            "likes": 12,
            "name": "Nest of Polygons",
            "published": 3,
            "tags": [
                "simple",
                "sdf",
                "polygon",
                "dihedral"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 193
        },
        "renderpass": [
            {
                "code": "// Nest of Polygons, mla, 2022\n\nfloat N = 11.0; // Number of sides\nfloat M = 18.0; // Radial density.\n\nconst float PI = 3.141592654;\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// Signed distance from p segment qr. Positive distance for\n// points on the left of the line looking from q to r.\nfloat ssegment(vec2 p, vec2 q, vec2 r) {\n  p -= q; r -= q;\n  float k = dot(p,r)/dot(r,r);\n  k = clamp(k,0.0,1.0);\n  vec2 closestpoint = k*r;\n  float dist = distance(p,closestpoint);\n  vec2 normal = vec2(-r.y,r.x);\n  float s = dot(p,normal) >= 0.0 ? 1.0 : -1.0;\n  return s*dist;\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\nfloat polydist(float N, vec2 p, float r) {\n    float phi = PI/N; // angle of half sector\n    float theta = atan(p.x,-p.y);// negative y-axis is theta = 0\n    theta = mod(theta+phi,2.0*phi)-phi;\n    //theta /= 2.0*phi; theta -= round(theta); theta *= 2.0*phi; // Equivalent\n    theta = abs(theta); // Mirror symmetry\n    // With dihedral symmetry, the closest point is always in the\n    // fundamental region, so can limit attention just to there\n    // for finding the SDF.\n    vec2 p1 = length(p)*vec2(cos(theta),sin(theta));\n    vec2 q0 = r*vec2(cos(phi),sin(phi)), q1 = r*vec2(cos(phi),0);\n    return ssegment(p1,q0,q1);\n}\n\nfloat poly(float k, vec2 p, float px) {\n    float k0 = k;\n    k /= M;\n    k += 0.25*iTime;\n    k = exp(k);\n    float r = exp(k+0.1*iTime);\n    //p = rotate(p,0.5*iTime*sin(0.05*k0-0.1*sin(0.01*iTime)));\n    //p = rotate(p,0.5*sin(3.0*iTime+0.1*k0));\n    p = rotate(p,0.5*iTime*sin(k0));\n    float d = polydist(N,p,k);\n    return d;\n}\n\nvec3 getcol(float k) {\n  return 0.25+0.75*h2rgb(0.01*iTime+0.5*fract(100.0*sin(k)));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 p = 2.0*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = fwidth(length(p));\n    float k = length(p);\n    k = log(k);\n    k -= 0.25*iTime;\n    k *= M;\n    k = round(k);\n    float d0 = poly(k-0.5,p,px);\n    float d1 = poly(k+0.5,p,px);\n    \n    float d = min(abs(d0),abs(d1));\n    vec3 col;\n    if (d0 < 0.0) col = getcol(k-0.5);\n    else if (d1 < 0.0) col = getcol(k+0.5);\n    else col = getcol(k+1.5);\n    col = mix(vec3(0),col,vec3(smoothstep(0.0,px,abs(d)-0.0015)));\n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}