{
    "Shader": {
        "info": {
            "date": "1598868383",
            "description": "Source : https://www.youtube.com/watch?v=PGtv-dBi2wE\nMy Game :  https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect",
            "flags": 0,
            "hasliked": 0,
            "id": "WtjBW1",
            "likes": 0,
            "name": "27. Ray Marching for Dummies",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "altera0",
            "viewed": 292
        },
        "renderpass": [
            {
                "code": "#define MAX_DIST 100.0\n#define MAX_STEP 100.0\n#define SURF_DIST 0.01\t\t// 이 범위 안이면 더 이상 할 필요 없이 충돌한 것으로 인정하기\n\nfloat GetDist( vec3 p ) {\n\n    vec4 sphere = vec4( 0 , 1.5 , 6 , 1 ); // XYZ + scale\n    \n    float sphereDist = length( p - sphere.xyz ) - sphere.w;\n    \n    float planDist = p.y;\n        \n\tfloat minDist = min ( planDist , sphereDist );\n    \n    return minDist;\n}\n\n\nfloat RayMarch( vec3 ro , vec3 rd ) {\n\tfloat dO = 0.0;\n\n    for ( float i = 0.0 ; i < MAX_STEP ; i++ ) {\n    \n        vec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += dS;\n        \n        if ( dO > MAX_DIST || dS < SURF_DIST ) break;\n    }\n    \n    \n    // 거리를 리턴한다.\n    return dO;\n}\n\n\nvec3 GetNormal( vec3 p ) {\n    float d = GetDist(p);\n    \n    vec2 e = vec2( 0.01, 0.0 );\n    vec3 n = d - vec3(\n        \tGetDist( p - e.xyy ),\n        \tGetDist( p - e.yxy ),\n        \tGetDist( p - e.yyx )\n        );\n                       \n    return normalize( n );\n}\n\n\n\nfloat GetLight( vec3 p ) {\n    vec3 lightPos = vec3( 0, 5, 6 );\n    lightPos.zx += vec2( sin(iTime) , cos(iTime)  ) * 2.0;\n    \n    vec3 l = normalize( lightPos - p );\n\n    vec3 n = GetNormal(p);\n    \n    float diffuse = clamp( dot ( n , l ) , 0.0 , 1.0 ) ;\t// same as 1 * 1 * cos(t)\n\n    // Shdow\n    float d = RayMarch( p + n * SURF_DIST * 2.0 , l );\n    if ( d < length( lightPos - p )) diffuse *= 0.25;\n\n    \n    return diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy ) /iResolution.y;\n\tvec3 col = vec3(0);\n\n    vec3 ro = vec3( 0 , 1 , 0 );\n    vec3 rd = normalize( vec3( uv.x , uv.y , 1) );\n    \n    float d = RayMarch( ro , rd );\n    vec3 intersectionPoint = ro + rd * d;\n\n    \n    float diffuse = GetLight( intersectionPoint );\n\n    col = vec3(diffuse);\n    \n     \n    fragColor = vec4(col,1.0);\n}\n\n/*\n\t1. 구성요소\n\n\t\t1. 카메라 IN ( UV, POS, Lookat, Zoom ) OUT( View Ray )\n\t\t2. Ray Intersection ( Ray ) => ( Distance )\n\t\t3. Material & Lighting ( Material, Distance , Light ) => PixelColor\n\n\t2. 심플한 카메라 모델을 만든다.\n\n\n\t3. 어떻게 InterSection을 판별해 내는가?\n\n\t\t1. lookAt으로 광선을 쏜다.\n\t\t2. 광선의 각 등분된 지점에서 오브젝트와의 거리를 체크한다.\n\t\t3. 체크된 거리중에서 가장 작은 것을 선택한다. ( 이게  오브젝트까지의 거리이다. )\n\t\t\n\t\t4. 이렇게 하면, 규칙이 없는 랜덤한 물체에 대해서는 일단은 판별이 어려운 점이 있긴하다.\n\t\t5. 하지만 일단은 이렇게 본다.\n\n\n\t\t6. [ 중요 ] 체크하는 방법이 각 오브젝트 마다 다르다. \n\n\t\t\t* 스피어, 사각형, 원통 등에 따라 다 다르다.\n\n\n\n\n\t3-1 . 체크 방법\n\n\t\t1. 카메라의 rd ( Ray Dirction )을 타고 내려가면서, 스피어의 중심점과 계속해서 비교를 한다.\n\n\n\n\t4. RayMarch( vec3 ro , vec3 rd )   만들기\n\n\t5. GetDist( vec p ) 만들기\n\n\t6. 노멀 만들기\n\n\t7. 라이팅의 개념을 넣는다.  \n\n\t\t* 라이트의 포지션 계산\n\t\t* 라이트 노멀에 대한 계산\n\t\t* 힛팅 포인트에서 e만큼 xyz 축으로 뺀다음. 노멀라이즈 한다.\n\n\n\n\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}