{
    "Shader": {
        "info": {
            "date": "1711291734",
            "description": "A simple function and differentiation visualizer, with integer and axis lines.\nSimply use your function inside \"theFunction\", instead of the quadratic function.\nA red marker is displayed at (0,0) if the function hits (close enough to) the origin point.",
            "flags": 0,
            "hasliked": 0,
            "id": "MfcGRn",
            "likes": 1,
            "name": "Math function visualizer",
            "published": 3,
            "tags": [
                "math",
                "visualizer",
                "function",
                "tool"
            ],
            "usePreview": 0,
            "username": "lcb",
            "viewed": 67
        },
        "renderpass": [
            {
                "code": "# define DER_SEG 0.0001 // Segment size for numerical differentiation\n\n# define EQ_THR 0.0000000000001 // Equality threshold\n\n# define THRESH 0.015 // Line thickness\n\nfloat dist(float a, float b){\n    return abs(a-b);\n}\n\nfloat dist2(vec2 a, vec2 b){\n    return sqrt((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y));\n}\n\n// Math function to be rendered.\nfloat theFunction(float x){\n\n    return x*x - 2.*x;\n    \n}\n\n// Viewport offset and scale settings.\n// Viewport can also be dragged around with mouse.\n# define SCALE_X 1.\n# define SCALE_Y 1.\n# define OFFSET_X 0.\n# define OFFSET_Y 0.\n\nfloat computeNumDifferentiation(float inp) { // Numerical differentiation implementation\n    \n    float diff = theFunction(inp) - theFunction(inp - DER_SEG);\n    return diff * (1. / DER_SEG);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Rescale UV for a more viewable image...\n    uv -= 0.5;\n    uv *= 6.;\n    \n    // Real coords\n    float aspectRatio = iResolution.x/iResolution.y;\n    vec2 c = vec2(uv.x * aspectRatio, uv.y);\n    \n    // Redefine x,y - Move, scale\n    c.x = c.x * SCALE_X + OFFSET_X;\n    c.y = c.y * SCALE_Y + OFFSET_Y;\n    // Move by mouse\n    if (iMouse.z > 0.) c -= 6. * (iMouse.xy/iResolution.xy - 0.5);\n\n    // Compute output and differentiation (numeric)\n    float result = theFunction(c.x);\n    float differentiation = computeNumDifferentiation(c.x);\n    \n    // background color (init)\n    vec3 col = vec3(0.1,0.1,0.15);\n    \n    // func color\n    if (dist(c.y,result) < THRESH) col = vec3(1.);\n    \n    // differentiation color\n    else if (dist(c.y,differentiation) < THRESH * 2.) col = vec3(0.,0.3,0.5);\n    \n    // axes\n    else if (dist(c.x, 0.) < THRESH || dist(c.y,0.) < THRESH) col = vec3(0.3,0.,0.);\n    // y integer lines\n    else if (dist(c.y, round(c.y)) < THRESH) col = vec3(0.,0.2,0.15);\n    // x integer lines\n    else if (dist(c.x, round(c.x)) < THRESH) col = vec3(0.,0.2,0.15);\n    \n    // Mark 0,0 as red if function hits it close enough\n    else if(dist2(c,vec2(0.)) < THRESH*5. && abs(theFunction(0.)) < EQ_THR) col = vec3(1.,0.,0.);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}