{
    "Shader": {
        "info": {
            "date": "1544698753",
            "description": "Another experiment. A bouncy sphere.",
            "flags": 0,
            "hasliked": 0,
            "id": "tdXGRn",
            "likes": 2,
            "name": "Bouncy Sphere",
            "published": 3,
            "tags": [
                "raymarching",
                "tutorial",
                "shadow",
                "light",
                "sphere",
                "bouncy"
            ],
            "usePreview": 0,
            "username": "josemorval",
            "viewed": 466
        },
        "renderpass": [
            {
                "code": "float time;\n\n//Distance to a sphere\nfloat sphere(vec3 p,float r){\n\treturn length(p)-r;    \n}\n\nvec2 scene(vec3 p){\n    float sr = 1.;\n    vec3 bouncep = vec3(0.);\n    \n    /* Spawn many spheres for 'free'\n    float index = 5.*floor(p.z/5.+0.5);\n    sr = 1.+0.3*sin(234.12*index);\n    p.z = p.z-0.5-index;\n\t*/\n\t\n    //Bouncy ball\n    float pt = 10.*time/3.14159;\n    \n    //Here the height on the jump\n    float h = mod(pt/10.,1.);\n    h=sqrt(h);\n    h=1.-h;\n    bouncep = 5.*h*abs(sin(10.*time))*vec3(0.,-1.,0.);\n    \n    //Here the move on the x axis\n    bouncep+=vec3(10.-3.*mod(pt,10.),0.,0.);\n    bouncep-=vec3(-mix(0.,5.5,pow(mod(pt,10.)/7.,2.)),0.,0.);\n\tvec2 res = vec2(sphere(p+vec3(0.,-sr,0.)+bouncep,sr),1.);\n    \n    //Use a large sphere as a plane\n    float r =100.;\n    vec2 a = vec2(sphere(p+vec3(0.,r,0.),r),2.);\n    \n    //Check what see the camera first: the bouncy ball or the plane\n    if(a.x<res.x) res = a;\n    \n    return res;\n}\n\n//Ray to the world\nvec2 raycast(vec3 p,vec3 d){\t\n    vec2 res = vec2(0.,-1.);\n    for(int i=0;i<64;i++){\n    \tvec2 f = scene(p);\n        if(f.x<0.001*res.x){\n            res.y = f.y;\n        \tbreak;   \n        }\n        p+=f.x*d;\n        res.x += f.x;\n    }   \n    \n    return res;   \n}\n\n//Compute normal (sampling some delta points)\nvec3 normal(vec3 p) \n{\n    const float eps = 0.001;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(scene(p+h.xyy).x - scene(p-h.xyy).x,\n                           scene(p+h.yxy).x - scene(p-h.yxy).x,\n                           scene(p+h.yyx).x - scene(p-h.yyx).x));\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv-0.5;\n    p.x*=iResolution.x/iResolution.y;\n\ttime = 0.7*iTime;\n    \n    vec3 col = vec3(0.);\n\t\n    //Camera\n    //---------//\n   \tvec3 po = 2.*vec3(0.,5.,-10.);\n    vec3 ta = vec3(0.,0.,0.);\n    \n    vec3 di = normalize(ta-po);\n    vec3 up = vec3(0.,1.,0.);\n    vec3 ri = -cross(di,up);\n    up = -cross(ri,di);\n    \n    float fov = 3.;\n    di = normalize(p.x*ri+p.y*up+fov*di);\n\tpo += p.x*ri+p.y*up;\n    //---------//\n    \n    //Throw a ray to the world (direction depends on the pixel of the camera)\n    vec2 res = raycast(po,di);\n    \n    if(res.y>0.){\n        \n        //Moving light\n        vec3 lightdir = normalize(vec3(cos(time),0.5+0.05*sin(time),-0.7+0.05*sin(3.*time)));\n        \n        po+=res.x*di;\n        //Throw a ray from hit position on the world to the light\n        //if hit another surface, then we are in shadow\n        float s = raycast(po+0.01*normal(po),lightdir).y>0.?1.:0.;\n        \n        //Ambient light\n        col = 0.1*vec3(0.3,0.3,0.5);\n        \n       \tif(res.y<1.5){\n            //Color bouncy ball (diffuse)\n    \t\tcol += 1.5*vec3(0.3,0.3,0.5)*clamp(dot(normal(po),lightdir),0.,1.);  \n            //Add shadow\n            col *= (1.-0.5*s);\n        }else if(res.y<2.5){\n            //Color plane (diffuse)\n            col += 1.5*vec3(0.6,0.3,0.5)*clamp(dot(normal(po),lightdir),0.,1.);\n            //Add shadow\n            col *= (1.-0.5*s);\n        }     \n    }\n\t\n    //Playing with gamma correction\n    col.x = pow(col.x,1.5+0.2*sin(time));\n    col.y = pow(col.y,1.3+0.1*sin(1.5*time+0.3));\n    col.z = pow(col.z,1.+0.1*sin(1.5*time+0.3));\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}