{
    "Shader": {
        "info": {
            "date": "1629158129",
            "description": "Thank you @Fabrice for helping me though this beast - wanted to share / Doing a UV map on a tile set made my head cave in but wow!! ( Kind of looking like a Lisa Frank sticker)",
            "flags": 0,
            "hasliked": 0,
            "id": "NddGzH",
            "likes": 52,
            "name": "UV Mapping Truchet Tiles",
            "published": 3,
            "tags": [
                "raymarching",
                "uv",
                "truchet",
                "tiles"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 1066
        },
        "renderpass": [
            {
                "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    UV Mapping a Truchet Tile Set\n    @byt3_m3chanic 8/16/21\n\n\n    Thank you @Fabrice for the knowledge and math\n    Started as an experiment - how can I do this.\n    https://www.shadertoy.com/view/sdtGRn\n\n    And finally ended up here, it's pretty tricky as\n    you have to get the closest arc and use that in\n    the mapping formula.\n\n*/\n\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MAX_DIST    20.00\n#define MIN_DIST    0.001\n#define SCALE       0.7500\n\n//utils\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n//globals\nvec3 hit,hitP1,sid,id;\nfloat speed,sdir,hitD,chx,checker;\nmat2 t90;\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n//@iq torus sdf\nfloat torus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n//make tile piece\nfloat truchet(vec3 p,vec3 x, vec2 r) {\n    return min(torus(p-x,r),torus(p+x,r));\n}\n//const\nconst float size = 1./SCALE;\nconst float hlf = size/2.;\nconst float shorten = 1.26;   \n//domain rep\nvec3 drep(inout vec3 p) {\n    vec3 id=floor((p+hlf)/size);\n    p = mod(p+hlf,size)-hlf;\n    return id;\n}\nvec2 drep(inout vec2 p) {\n    vec2 id=floor((p+hlf)/size);\n    p = mod(p+hlf,size)-hlf;\n    return id;\n}\nvec2 map(vec3 q3){\n    vec2 res = vec2(100.,0.);\n\n    float k = 5.0/dot(q3,q3); \n    q3 *= k;\n\n    q3.z += speed;\n\n    vec3 qm = q3;\n    vec3 qd = q3+hlf;\n    qd.xz*=t90;\n    vec3 qid=drep(qm);\n    vec3 did=drep(qd);\n    \n    float ht = hash21(qid.xy+qid.z);\n    float hy = hash21(did.xz+did.y);\n    \n    float chk1 = mod(qid.y + qid.x,2.) * 2. - 1.;\n    float chk2 = mod(did.y + did.x,2.) * 2. - 1.;\n\n    // truchet build parts\n    float thx = .115;\n    float thz = .200;\n\n    if(ht>.5) qm.x *= -1.;\n    if(hy>.5) qd.x *= -1.;\n\n    float t = truchet(qm,vec3(hlf,hlf,.0),vec2(hlf,thx));\n    if(t<res.x) {\n        sid = qid;\n        hit = qm;\n        chx = chk1;\n        sdir = ht>.5 ? -1. : 1.;\n        res = vec2(t,2.);\n    }\n\n    float d = truchet(qd,vec3(hlf,hlf,.0),vec2(hlf,thz));\n    if(d<res.x) {\n\n        sid = did;\n        hit = qd;\n        chx = chk2;\n        sdir = hy>.5 ? -1. : 1.;\n        res = vec2(d,1.);\n    }\n\n    float mul = 1.0/k;\n    res.x = res.x * mul / shorten;\n    \n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec3 hue(float t)\n{ \n    vec3 d = vec3(0.220,0.961,0.875);\n    return .375 + .375*cos(PI2*t*(vec3(.985,.98,.95)+d)); \n}\n\nfloat gear(vec2 p, float radius)\n{\n    //length of cog\n    float sp = floor(radius*PI2)*2.;\n    float gs = length(p.xy)-radius;\n    float at = atan(p.y,p.x);\n    //gear teeth\n    float gw = abs(sin(at*sp)*.15);\n    gs +=smoothstep(.05,.5,gw);\n\n    gs=max(gs, -(length(p.xy)-(radius*.45)) );\n    return gs;\n}\n\nvec4 FC= vec4(.001,.001,.001,0.);\nvec3 lpos = vec3(-hlf,hlf,3.85);\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d) {\n\n    vec3 C = vec3(0);\n    vec3 p = ro;\n    float m = 0.;\n    \n    for(int i=0;i<150;i++) {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<64? ray.x*.35: ray.x;\n        m  = ray.y;\n    } \n    // save globals\n    hitP1 = hit;\n    id = sid;\n    hitD = sdir;\n    checker=chx;\n    \n    float alpha = 0.;\n    if(d<MAX_DIST) {\n    \n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 l = normalize(lpos-p);\n        \n        vec3 h = vec3(.05);\n\n        float diff = clamp(dot(n,l),0.,1.);\n        float bounce = clamp(dot(n,vec3(0.,-1.,0.)), 0.,1.);\n        \n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 5.);\n        fresnel = mix(.01, .7, fresnel);\n\n        float shdw = 1.0;\n        for( float t=.01; t < 12.; ){\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 24.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        \n        diff += bounce;\n        diff = mix(diff,diff*shdw,.65);\n  \n        \n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), (m==2.||m==4.)?24.:64.);\n\n        // uv mapping stuff here\n        \n        if(m==2.) {\n           vec3 hp = hitP1*hitD;\n            \n            // get closest arc\n            vec2 d3 = vec2(length(hp-hlf), length(hp+hlf));\n            vec3 g3 = d3.x<d3.y? vec3(hp-hlf) : vec3(hp+hlf);\n            \n            //angle for the tube\n            float angle = atan(g3.y,g3.x)/PI2;\n            //angle for the arc/truchet path\n            float gz =  atan( hp.z,  length(g3.yx)-hlf ) / PI2;\n            //make the uv\n            vec2 uv = vec2(angle,gz);\n\n            if(hitD<1. ^^ checker>0.) uv.y*=-1.;\n            // make truchet design down\n            float px  = .0125;\n            \n            vec2 scaler = vec2(28.,6.);\n            vec2 grid = fract(uv.xy*scaler)-.5;\n            vec2 cid   = floor(uv.xy*scaler);\n\n            if(hash21(cid)<.5) grid.x*=-1.;\n            \n            h = vec3(.6); \n\n            vec2 d2 = vec2(length(grid-.5), length(grid+.5));\n            vec2 gx = d2.x<d2.y? vec2(grid-.5) : vec2(grid+.5);\n\n            float circle = length(gx)-.5;\n            float center =smoothstep(.03-px,px,abs(abs(abs(circle)-.2)-.1)-.025);\n            h = mix(vec3(0),h, center);\n           \n            ref = vec3(clamp(1.-center,0.,1.))-fresnel;\n        }\n\n        if(m==1.) {\n            vec3 hp = hitP1*hitD;\n            \n            // get closest arc\n            vec2 d3 = vec2(length(hp-hlf), length(hp+hlf));\n            vec3 g3 = d3.x<d3.y? vec3(hp-hlf) : vec3(hp+hlf);\n    \n            //angle for the tube\n            float angle = atan(g3.y,g3.x)/PI2;\n            //angle for the arc/truchet path\n            float gz =  atan( hp.z,  length(g3.yx)-hlf ) / PI2;\n            //make the uv\n            vec2 uv = vec2(angle,gz);\n\n            if(hitD<1. ^^ checker>0.) uv.y*=-1.;\n            // make truchet design down\n            float px  = .0125;\n           \n            vec2 scaler = vec2(28.,10.);\n            vec2 grid = fract(uv.xy*scaler)-.5;\n            vec2 cid   = floor(uv.xy*scaler);\n            float hs = hash21(cid);\n            if(hs<.5) grid.x*=-1.;\n\n            vec2 d2 = vec2(length(grid-.5), length(grid+.5));\n            vec2 gx = d2.x<d2.y? vec2(grid-.5) : vec2(grid+.5);\n\n            float circle = length(gx)-.5;\n            float center =smoothstep(.03-px,px,abs(circle)-.15);\n            h = mix(hue(length(p.zy*.3)*3.) ,hue(length(p.zx*.5)*2.), center);\n            \n            //debug with london texture \n            //h=texture(iChannel0,uv*vec2(8.,4.)).rgb;\n            \n            // super freakout animation\n            float chk = mod(cid.y + cid.x,2.) * 2. - 1.;\n            vec2 arc = grid-sign(grid.x+grid.y+.001)*.5;\n            float angle2 = atan(arc.x, arc.y);\n            float width = .2;\n            float d = length(arc);\n            // coord checker\n            float tm = T*.25;\n            vec2 tuv = vec2(\n                fract(1.*chk*angle2/1.57+tm),\n                (d-(.5-width))/(2.*width)*2.\n            );\n            tuv.y-=.5;\n            vec2 tid = vec2(\n                floor(1.*chk*angle2/1.57+tm),\n                floor(d-(.5-width))/(2.*width)\n            );\n\n            tuv.xy*=vec2(2.,.5);\n            tuv.x=mod(tuv.x+.5,1.)-.5;\n            // float ddt = length(tuv.xy-vec2(0,.25))-.25;\n            \n            // new gear spin thing\n            // comment out to change back to dots - and use above.\n            vec2 gvec = tuv.xy-vec2(0,.25);\n            float dir = (chk>0.^^ hs>.5) ? -1.:1.;\n            gvec*= rot( (T*1.4) * dir);\n            float ddt = gear(gvec,.45);\n            // end\n            \n            ddt = smoothstep(-px,px,min(ddt,center));\n            h = mix(h,vec3(0.),ddt);\n            \n            \n            ref = vec3(clamp(1.-center,0.,1.))-fresnel;\n        }\n\n        C = diff*h+spec;\n        if(last) C = mix(FC.rgb,C,  exp(-.05*d*d*d));\n    \n        ro = p+n*.002;\n        rd = reflect(rd,n);\n    } else {\n        C = FC.rgb;\n    }\n     \n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    // precal\n    t90 = rot(90.*PI/180.);\n    speed = T*.225;\n    //\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,3.5);\n    vec3 rd = normalize(vec3(uv,-1));\n    //mouse rotation\n    float x = -.305;\n    float y = -.750;\n    \n    if(M.z>0.){\n        x = -(M.y/R.y * .5 - .25) * PI;\n        y = -(M.x/R.x * .5 - .25) * PI;\n    }\n    \n    mat2 rx = rot(x);\n    mat2 ry = rot(y);\n    \n    ro.yz *= rx;\n    rd.yz *= rx;\n    ro.xz *= ry;\n    rd.xz *= ry;\n    \n    // pre render\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0);\n    vec3 fil=vec3(1.);\n    \n    float d =0.;\n    float bounces = 2.;\n    for(float i=0.; i<bounces; i++) {\n        vec4 pass = render(ro, rd, ref, i==bounces-1., d);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.) FC = vec4(FC.rgb,exp(-.145*d*d*d));\n    }\n\n    //mixdown\n    C = mix(C,FC.rgb,1.-FC.w);\n    C = clamp(C,vec3(0),vec3(1));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}