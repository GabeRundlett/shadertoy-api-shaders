{
    "Shader": {
        "info": {
            "date": "1593285805",
            "description": "Triangle Inequality coloring, designed by Damien M. Jones and Javier Barrallo. This is an adaptation of code I wrote in 2001. Unfortunately it only works in double precision, so what you see is an incomplete picture (hairs/flumes should be way longer)",
            "flags": 0,
            "hasliked": 0,
            "id": "wlXyDX",
            "likes": 17,
            "name": "Julia - Triangle Inequality",
            "published": 3,
            "tags": [
                "2d",
                "fractal",
                "julia",
                "triangleinequality"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 916
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Triangle Inequality coloring. This is an adaptation of\n// code I wrote in 2001. The algorihtm was designed by \n// Damien M. Jones and Javier Barrallo who were trying to\n// measure the average orbit curvature.\n//\n// The algorithm requires double precision floating point\n// numbers, which GLSL doesn't support. See line 32. So\n// this image you see here is just an approximation to the\n// real image, which should have way longer hairs going out\n// all the way to the border of the image.\n\n\n#define AA 2\n\nvec3 render( vec2 p, float time )\n{\n    // animation\n\tfloat ltime = 0.5-0.5*cos(time*0.06);\n    float zoom = pow( 0.9, 40.0*ltime );\n\tvec2  cen = vec2( 0.2655,0.301 ) + zoom*0.8*cos(4.0+2.0*ltime);\n\tvec2 c = vec2( -0.745, 0.186 ) - 0.045*zoom*(1.0-ltime*0.5);\n\n    // pixel to z plane\n    p = (2.0*p-iResolution.xy)/iResolution.y;\n\tvec2 zo = cen + (p-cen)*zoom;\n    \n    // iteration\n    float th  = 1e7; // th needs to be way bigger to work well, but in\n    float ld2 = 1.0; // WebGL we only have floats, so it that sucks!\n    const int kNumIterations = 2048;\n    vec2  z = zo;\n    float lz2 = dot(z,z);\n    float ti_av1 = 0.0;\n    float ti_av2 = 0.0;\n\tfloat ti_lc = length(c);\n    float n = 0.0;\n    for( int i=0; i<kNumIterations; i++ )\n\t{\n        // z' = 2·z·z', derivative of z for distance computation\n        ld2 *= 4.0*lz2; \n        \n        // z = z²+c\n        z = vec2(z.x*z.x-z.y*z.y, 2.0*z.x*z.y) + c;\n        \n        // escape condition\n\t\tfloat olz2 = lz2;\n        lz2 = dot(z,z);\n\t\tif( lz2>th*th ) break;\n        \n        // triangle inequality\n        if( i>0 )\n        {\n        \tti_av2 = ti_av1;\n            float mi = abs(olz2 - ti_lc);\n            float ma = olz2 + ti_lc;\n            ti_av1 += (sqrt(lz2)-mi)/(ma-mi);\n        }\n        \n        // iteration counter\n        n += 1.0;\n\t}\n    \n    // --- properties ---\n    \n    // continuous iteration : https://iquilezles.org/articles/msetsmooth\n    float f = log2(log(length(z))/log(th));\n    float sn = n - f;\n    \n    // distance: https://iquilezles.org/articles/distancefractals\n    float d = sqrt(lz2/ld2)*log(lz2);\n\n    // triangle inequality\n\tti_av1 = ti_av1/(n    );\n    ti_av2 = ti_av2/(n-1.0);\n\tti_av1 = ti_av2+(ti_av1-ti_av2)*smoothstep(0.0,1.0,1.0-f);\n    \n    // --- coloring ---\n    \n    vec3 col = max(0.6+0.8*sin(ti_av1*1.5 + 5.5 + vec3(0.0,0.3,0.5)),0.0);\n    col *= clamp( 1024.0*d/zoom, 0.0, 1.0 );\n        \n    return col;\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n\tfor( int j=0; j<AA; j++ )\n\tfor( int i=0; i<AA; i++ )\n\t{\n\t\tvec2 of = vec2(float(i),float(j))/float(AA)-0.5;\n\t    col += render( fragCoord+of, iTime );\n\t}\n\tcol /= float(AA*AA);\n\t\n\tfragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}