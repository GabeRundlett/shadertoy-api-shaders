{
    "Shader": {
        "info": {
            "date": "1624847469",
            "description": "Overly complex spinning cube demo. mouseable",
            "flags": 32,
            "hasliked": 0,
            "id": "slB3Ry",
            "likes": 24,
            "name": "Cube Map [ Truchet Box ]",
            "published": 3,
            "tags": [
                "raymarching",
                "cubemap",
                "truchet",
                "tile"
            ],
            "usePreview": 1,
            "username": "byt3_m3chanic",
            "viewed": 617
        },
        "renderpass": [
            {
                "code": "/** \n    Cube Map [ Truchet Box ]\n    6/27/21 @byt3_m3chanic\n    \n    playing with cube mapping on objects\n    using bmp and textures. mouseable\n    \n*/\n\nfloat offset[3] = float[]( 0.0, 1.35, 2.95 );\nfloat weight[3] = float[]( 0.2, 0.35, 0.075 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\n    vec3 C = texture(iChannel0, uv).rgb;\n    vec3 R = texture(iChannel0, uv).rgb * weight[0];\n    for (int i=1; i<3; i++) {\n      R += texture(iChannel0, uv + vec2(offset[i])/iResolution.xy, 0.0).rgb * weight[i];\n      R += texture(iChannel0, uv - vec2(offset[i])/iResolution.xy, 0.0).rgb * weight[i];\n    }\n    \n    // mask for effect and mixdown \n    float dt = distance(uv.xy,vec2(.5))*.32;\n    dt = smoothstep(0.82,.965,1.-dt);\n    vec3 Color = mix(R,C,dt);\n    \n    // output\n    Color=pow(Color, vec3(.4545));\n    fragColor = vec4(Color,1.);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/**\n\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    100.\n#define MIN_DIST    .0001\n\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat vmax(vec3 p){ return max(max(p.x,p.y),p.z); }\n//@iq\nfloat cap( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n//@iq\nfloat vcap( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat modPolar(inout vec2 p, float rep) \n{\n    float angle = 2.*PI/rep;\n    float a = atan(p.y, p.x) + angle/2.;\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*length(p);\n    return (abs(c) >= (rep/2.)) ? abs(c) : c;\n} \n\nfloat box(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,vec3(0))) + vmax(min(d,vec3(0)));\n}\n\nvec3 hit=vec3(0),hitPoint=vec3(0);\nmat2 ria,gia,turn,spin;\n\nconst float sz = 3.;\nconst float hf = sz*.5;\n\nvec2 map(vec3 pos, float sg)\n{\n    vec2 res = vec2(1e5,0.);\n    pos.y+=1.25;;\n    vec3 q = pos-vec3(0,2.5,0);\n    \n    vec3 b = pos-vec3(0,1.05,0);\n    \n    q.yx*=spin;\n    q.zx*=spin;\n\n    float d1 = box(q,vec3(1.5))-.0423;\n    if(d1<res.x){\n        res = vec2(d1,2.);\n        hit=q;\n    }\n\n    b.xz=abs(abs(abs(b.xz)-12.)-6.)-3.;\n    vec3 hitb = b;\n    \n    float pillar = cap(b,.3,1.5);\n    vec3 tb =vec3(b.x,abs(b.y),b.z);\n    float pcap = box(tb-vec3(0,1.45,0),vec3(.5,.15,.5))-.005;\n        pcap=min(cap(tb-vec3(0,1.3,0),.4,.05),pcap);\n    \n    modPolar(b.xz,16.);\n    vec3 bt = b-vec3(.3,-1.1,0);\n    \n    float grv = vcap(bt,2.2,.045);\n    pillar = max(pillar,-grv);\n    pillar = min(pcap,pillar);\n\n    if(pillar<res.x)\n    {\n        res = vec2(pillar*.75,3.);\n    \thit=hitb;\n    }\n\n    float ground =pos.y+.5;\n    if(ground<res.x){\n        res = vec2(ground,1.);\n        hit=pos;\n    }\n  \n    return res;\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e,0.).x+\n             h.yyx * map(p+h.yyx*e,0.).x+\n             h.yxy * map(p+h.yxy*e,0.).x+\n             h.xxx * map(p+h.xxx*e,0.).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps, float sg){\n\tfloat d = 0.;\n    float m = 0.;\n    for(int i=0;i<maxsteps;i++){\n    \tvec2 ray = map(ro + rd * d, sg);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += ray.x * .85;\n        m  = ray.y;\n    }\n\treturn vec2(d,m);\n}\n\n// Tri-Planar blending function. GPU Gems 3 - Ryan Geiss:\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    n = max(abs(n), MIN_DIST);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n    //return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\nfloat sface;\nvec3 getFace(int face, vec3 p)\n{\n    float cir = 0.;\n    vec2 uv;\n    \n    if(face==0) uv=p.yz;\n    if(face==1) uv=p.zx;\n    if(face==2) uv=p.xy;\n    if(face==3) uv=p.xy;\n    if(face==4) uv=p.xz;\n    if(face==5) uv=p.zy;\n    uv*=2.;\n    \n    float px = fwidth(uv.x);\n    vec2 grid_uv = fract(uv)-.5;\n    vec2 grid_id = floor(uv);\n    \n    float chk = mod(grid_id.y + grid_id.x,2.) * 2. - 1.;\n    float hs = hash21(grid_id);\n    if(hs>.5) grid_uv.x*=-1.;\n    \n    vec2 d2 = vec2(length(grid_uv-.5), length(grid_uv+.5));\n    vec2 gx = d2.x<d2.y? vec2(grid_uv-.5) : vec2(grid_uv+.5);\n\n    float circle = length(gx)-.5;\n    float circle2 =abs(circle)-.025;\n    circle2=smoothstep(.001+px,-px,circle2);\n    circle=(chk>0.^^ hs>.5)?smoothstep(-px,.001+px,circle):smoothstep(.001+px,-px,circle);\n\n    cir= mix(cir,.0,circle);\n    cir= mix(cir,1.,circle2);\n    sface=mix(0.,1.,circle);\n    return vec3(cir);\n}\n// based on bmp mapping from\n// https://www.shadertoy.com/view/ld3yDn\nvec3 doBumpMap( vec3 p, vec3 n, float bf, float per, int face)\n{\n    vec2 e = vec2(per*MIN_DIST, 0);   \n    mat3 m = mat3( \n        getFace(face, p - e.xyy), \n        getFace(face, p - e.yxy), \n        getFace(face, p - e.yyx)\n    );\n    vec3 g = vec3(0.299, 0.587, 0.114) * m; \n    g = (g - dot(getFace(face, p), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);  \n    return normalize( n + g*bf );\n}\n\nvec4 FC = vec4(0.019,0.019,0.019,0.);\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,152, 1.);\n\n    hitPoint = hit;\n    gia=ria;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(3.,8,3.);\n        vec3 lpos2 =vec3(5.,5,-5.);\n        vec3 l = normalize(lpos-p);\n        vec3 l2 = normalize(lpos2-p);\n        \n        vec3 h = vec3(.5);\n        vec3 hp = hitPoint;\n        vec3 cuv;\n        int face;\n        vec3 tn = n;\n        vec3 cn = n;\n        if(m==2.){\n            tn = n;\n            tn.yx*=spin;\n            tn.zx*=spin;\n            //https://www.shadertoy.com/view/3sVBDd\n            //finding the face of a cube using normal\n            vec3 aN = abs(tn);\n            ivec3 idF = ivec3(tn.x<-.25? 0 : 5, tn.y<-.25? 1 : 4, tn.z<-.25? 2 : 3);\n            face = aN.x>.5? idF.x : aN.y>.5? idF.y : idF.z;\n            \n            // set coords\n            if(face==0) cuv = hp.xyz;\n            if(face==1) cuv = hp.xyz;\n            if(face==2) cuv = hp.xyz;\n            if(face==3) cuv = hp.xyz;\n            if(face==4) cuv = hp.zyx;\n            if(face==5) cuv = hp.xyz;\n       \n            // get bump map surface\n            n=doBumpMap( cuv, n, .05, d, face);\n        }\n\n        float diff = clamp(dot(n,l),0.,1.);\n        float diff2 = clamp(dot(n,l2),0.,1.);\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n        fresnel = mix(.01, .7, fresnel);\n\n        float shdw = 1.0;\n        for( float t=.01; t < 12.; )\n        {\n            float h = map(p + l*t,0.).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 16.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        float shdw2 = 1.0;\n        for( float t=.01; t < 12.; )\n        {\n            float h = map(p + l2*t,0.).x;\n            if( h<MIN_DIST ) { shdw2 = 0.; break; }\n            shdw2 = min(shdw2, 16.*h/t);\n            t += h;\n            if( shdw2<MIN_DIST || t>32. ) break;\n        }\n        \n        diff = mix(diff,diff*shdw,.75);\n        diff2 = mix(diff2,diff2*shdw2,.75);\n        \n        vec3 diffMix =vec3(0);\n        diffMix = diff * vec3(0.502,0.290,0.000);\n        diffMix += diff2 * vec3(0.004,0.510,0.894);\n        \n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), (m==2.||m==4.)?24.:64.);\n\n        // materials\n        if(m==1.){\n            h=tex3D(iChannel1,hitPoint*.1,n).rgb;\n            C = (diffMix*h);\n            ref = vec3(clamp(.35-fresnel-(d*.01),.01,1.));\n        }\n        if(m==2.){\n            h = mix(tex3D(iChannel0,cuv*.5,tn).rgb, tex3D(iChannel1,cuv*.5,tn).rgb ,sface);\n            C = (diffMix*h)+spec;\n            ref = vec3(clamp(sface-fresnel,.01,.9));\n        }\n        if(m==3.){\n            h=clamp(tex3D(iChannel2,hitPoint*.1,tn).rrr+.5+fresnel,vec3(0),vec3(.8));//vec3(.2);\n            C = (diffMix*h);\n            ref = clamp((h-fresnel)-.5,vec3(0),vec3(1));\n        }\n        \n        C = mix(FC.rgb,C,exp(-.00015*d*d*d));\n        ro = p+n*.001;\n        rd = reflect(rd,n);\n    } else {\n        if(last) C = mix(FC.rgb,C,exp(-.000015*d*d*d));\n    }\n    C = clamp(C,vec3(0),vec3(1));\n    return vec4(C,alpha);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    float timer = T*05.*PI/180.;\n    turn = rot(timer);\n    spin = rot(T*25.*PI/180.);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,7.75);\n    vec3 rd = normalize(vec3(uv,-1));\n    \n    //mouse\n    float x = M.xy == vec2(0) ? .75: -(M.y/R.y * 1. - .5) * PI;\n    float y = M.xy == vec2(0) ? 0. : -(M.x/R.x * 1. - .5) * PI;\n    if(x<-.15)x=-.15;\n    mat2 rx = rot(x);\n    mat2 ry = rot(y+timer);\n    \n    ro.yz *= rx;\n    rd.yz *= rx;\n    ro.xz *= ry;\n    rd.xz *= ry;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(1);\n    float d =0.;\n    float numBounces = 2.;\n    // 3 is pretty but slows down \n    for(float i=0.; i<numBounces; i++) {\n        vec4 pass = render(ro, rd, ref, i==numBounces-1., d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.) FC = vec4(FC.rgb,exp(-.000075*d*d*d));\n    }\n \n    C = mix(C,FC.rgb,1.-FC.w);\n    // gamma\n    C = clamp(C,vec3(0),vec3(1));\n    O = vec4(C,1.0);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}