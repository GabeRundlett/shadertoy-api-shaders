{
    "Shader": {
        "info": {
            "date": "1725375188",
            "description": "source https://glslsandbox.com/e#75585.0",
            "flags": 0,
            "hasliked": 0,
            "id": "Xfjfzt",
            "likes": 0,
            "name": "protoshield armor",
            "published": 3,
            "tags": [
                "fractal",
                "shield"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 66
        },
        "renderpass": [
            {
                "code": "#define  time iTime\n#define resolution  iResolution.xy\n\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MAX_DIST    300.00\n#define MIN_DIST    10.01\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\nfloat eoc(float t) { return (t = t - 1.0) * t * t + 1.0; }\n\n//@iq sdf's!\nfloat sdframe( vec3 p, vec3 b, float e ) {\n \n  p = abs(p  )-b;\n   p.xz*=rot(iTime); \n   \n  vec3 q = abs(p+e)-e;\n   \n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n//@gaz crystal shape via twitter\nfloat zag(vec3 p, float s) {\n  p.xz*=rot(iTime);\n    p = abs(p)-s;\n    \n    if (p.x < p.z) p.xz = p.zx;\n    if (p.y < p.z) p.yz = p.zy;\n    if (p.x < p.y) p.xy = p.yx;\n     \n    return dot(p,normalize(vec3(s*.42,s,0)));\n}\n\nfloat tmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.,ga5=0.;\nmat2 r45=mat2(0.),ry,rx;\n\n#define SCALE 1.25\nconst float scale = 1./SCALE;\nconst vec2 l = vec2(scale);\nconst vec2 s = l*1.0;\nconst float sl = l.x*41.;\nvec2 ps4[4];\n\nvec2 map(vec3 p) {\n    vec2 res =vec2(100000,0.);\n p.xz*=rot(iTime);\n    p.z+=ga5*sl;\n    \n    mat2 rz = rot(ga4*PI);\n    p.xz*=rz;\n    vec2 r,ip,ct = vec2(0);\n\n    //@Shane - multi tap grid\n    for(int i =0; i<4; i++){\n        ct = ps4[i]/5.;              // Block center.\n        r = p.xz - ct*s;             // Local coordinates. \n        ip = floor(r/s) + .5;        // Local tile ID. \n        r -= (ip)*s;                 // New local position.   \n        vec2 idi = (ip*s) + ct;\n \n        vec3 q = vec3(r.x,p.y,r.y);\n        float chx = mod(idi.x,2.) * 2. - 1.;\n         \n        float chy = mod(idi.y,2.) * 2. - 1.;\n        float chk = (chy<1. ^^ chx<1.) ? 1.2 : .4;\n          if(chk>1.5) { \n            q.xz*=rz; \n            q.z+=cos(iTime);\n            q.xz*=rot(ga1*PI); \n        }\n        if(chk>.5) { \n            q.xy*=rz; \n            \n            q.xz*=rot(ga1*PI); \n        }\n        \n        else {\n        q.zy*=rot(ga3*PI);\n        \n            q.yz*=rz; \n            q.yz*=rot(-ga5*PI);\n        }\n\n        float ms = l.x*.16;\n        float mf = l.x*.27;\n\n        float frame2 = sdframe(q,vec3(mf),.0725);\n        if(frame2<res.x) res = vec2(frame2,4.);\n  \n        float mainbox = zag(q,ms);\n        q.yz*=r45;\n        q.zx*=r45;\n\n        mainbox=max(mainbox,-zag(q,ms*.425));\n    \n        if(mainbox<res.x) res = vec2(mainbox,1.);\n\n    }\n\n    return res;\n}\n\n//Tetrahedron technique\n//https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 normal(vec3 p, float t) {\n    float e = t;\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n                      h.yyx*map( p + h.yyx*e ).x + \n                      h.yxy*map( p + h.yxy*e ).x + \n                      h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec3 render(vec3 p, vec3 rd, vec3 ro, float d, float m, inout vec3 n, inout float fresnel) {\n    n = normal(p,d);\n    vec3 lpos =  vec3(8,10,8);\n    vec3 l = normalize(lpos-p);\n    float diff = clamp(dot(n,l),0.,1.);\n    \n    fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n    fresnel = mix(.0, .9, fresnel);\n\n    vec3 h = vec3(.3);\n      \n    if(m==1.) h=mix(vec3(.5),vec3(0.322,0.831,1.000),clamp((p.z+8.)*.075,0.,1.));\n    if(m==4.) h=mix(vec3(.9),vec3(.5),1.-clamp((p.z+8.)*.075,0.,1.));\n    h = mix(h,vec3(0.322,0.831,1.000),fresnel);\n    \n    return diff*h;\n}\n\nconst float zoom = 7.;\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    // precal\n    float time = T;\n\n    \n    tmod = mod(time, 16.);\n    float t1 = lsp(2.0, 4.0, tmod);\n    float t2 = lsp(6.0, 8.0, tmod);\n    \n    float t5 = lsp(4.0, 6.0, tmod);\n    float t6 = lsp(8.0, 10.0, tmod);\n    \n    float t7 = lsp(0.0, 2.0, tmod);\n    float t8 = lsp(8.0, 10.0, tmod);\n    \n    float t9 = lsp(10.0, 16.0, tmod);\n    \n    ga1 = eoc(t1-t2);\n    ga1 = ga1*ga1*ga1;\n\n    ga3 = eoc(t5-t6);\n    ga3 = ga3*ga3*ga3;\n    \n    ga4 = eoc(t7-t8);\n    ga4 = ga4*ga4*ga4;\n    \n    t9 = eoc(t9);\n    t9 = t9*t9*t9;  \n    ga5 = (t9);\n    //\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\nuv.xy*=rot(iTime);\n    \n    vec3 ro = vec3(uv*zoom,-zoom-25.);\n    vec3 rd = vec3(0,0,1.);\n\n    rx = rot(.615);\n    ry = rot(-.7853981);\n    \n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C = vec3(.0075);\n    vec3  p = ro + rd;\n    float atten = .95;\n    float k = 1.;\n    float d = 0.;\n     \n    for(int i=0;i<100;i++)\n    {\n   \n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float m = ray.y;\n\n        d = i<32 ? ray.x*0.2 : ray.x;\n        p += rd * d *k;\n        \n        if (d*d < 1e-7) {\n  \n            float fresnel=0.;\n            C+=render(p,rd,ro,d,ray.y,n,fresnel)*atten;\n  \n            atten *= .525;\n            p += rd*.025;\n            k = sign(map(p).x);\n\n            vec3 rr = vec3(0);\n\n            if(m== 14.) {\n                rd=reflect(-rd,n);\n                p+=n*.05;\n            } else {\n                rr = refract(rd,n,.55);\n                rd=mix(rr,rd,.5-fresnel);\n            }\n\n        } \n       \n        if(distance(p,rd)>35.) { break; }\n    }\n\n    if(C.r<.008&&C.g<.008&&C.b<.008) C = hash21(uv)>.85 ? C+.015 : C;\n   \n    O = vec4(C*vec3(0.494,0.655,0.827),1.0);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}