{
    "Shader": {
        "info": {
            "date": "1626844670",
            "description": "Combined iq's https://www.shadertoy.com/view/4dffRH\nw/\nDave Hoskins' https://www.shadertoy.com/view/4dlGW2\n---\nI'll be adapting this to produce tileable volume textures inside of unreal engine.",
            "flags": 0,
            "hasliked": 0,
            "id": "sllSDl",
            "likes": 4,
            "name": "Tileable 3d Noise + derivs",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "noise",
                "tiled",
                "perlin",
                "tiling",
                "tileable",
                "analytic"
            ],
            "usePreview": 0,
            "username": "granito",
            "viewed": 611
        },
        "renderpass": [
            {
                "code": "#define SHOW_TILING\n#define TILES 3.0 // Use 1.0 for normal tiling across whole texture.\n#define SCALE 40.0 // noise scale inside tile\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord / iResolution.xy;\n\tvec2 uv = (p-0.5) * vec2(1., iResolution.y/iResolution.x) + 0.5;\n    \n\n\t#ifdef SHOW_TILING\n\tuv *= TILES;\n\t#endif\n       \n    vec4 f = noised(vec3(uv,iTime/SCALE), SCALE);\n    f = f * 0.5 + 0.5;\n    fragColor = mix( vec4(f.x), vec4(vec3(f.yzw),0.0) , vec4(round(fract(iTime*0.25f))) );\n    \n    \n\t#ifdef SHOW_TILING\n\t// Flash tile borders...\n\tvec2 pixel = TILES / iResolution.xy;\n\tif (mod(iTime-2.0, 4.0) < 2.0)\n\t{\n\t\tvec2 first \t\t= step(pixel, uv);\n\t\tuv  = step(fract(uv), pixel);\t// Only add one line of pixels per tile.\n\t\tfragColor.xyz = mix(fragColor.xyz, vec3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y);\n\t}\n\t#endif    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 hash( vec3 p , float scale) // replace this by something better\n{\n\tp = mod(p, scale);\n    \n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// return value noise (in x) and its derivatives (in yzw)\nvec4 noised( in vec3 x, in float scale )\n{\n    x *= scale;\n\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    #if 1\n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    #else\n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    #endif    \n    \n    // gradients\n    vec3 ga = hash( i+vec3(0.0,0.0,0.0), scale );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0), scale );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0), scale );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0), scale );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0), scale );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0), scale );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0), scale );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0), scale );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}