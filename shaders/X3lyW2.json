{
    "Shader": {
        "info": {
            "date": "1726674563",
            "description": "transparent variant of \"Conformal Torus Texture Mapping2\" https://shadertoy.com/view/sdd3R4\nSwap comment line #33 for mesh along.\n\nCleaner test to pass layers ?\n",
            "flags": 0,
            "hasliked": 0,
            "id": "X3lyW2",
            "likes": 24,
            "name": "transp Conformal Torus T.Mapping",
            "published": 3,
            "tags": [
                "torus",
                "uv",
                "conformal",
                "short"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 250
        },
        "renderpass": [
            {
                "code": "// transparent variant of \"Conformal Torus Texture Mapping2\" by FabriceNeyret2. https://shadertoy.com/view/sdd3R4\n\n#define hue(v)  ( .6 + .6 * cos( v  + vec4(0,23,21,0)  ) )    // hue\n//#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )            // rotation                  \n  #define rot(a)  mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.,d, l, i, k = 2., // .9                         // tile multiplier\n          R0 = 20., R1 = 10.;                                 // large and small radii\n\n    vec3  R = iResolution,\n          D = normalize( vec3( U+U, -3.5*R.y ) - R ),         // ray direction\n          p = 90./R, q,                                       // marching point along ray \n       // M =  iMouse.xyz/R -.5;\n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0));\n\n    for ( O *= 0.; i++ < 1e2 ; ) {                            // --- ray-marching\n        q = p,\n        q.yz *= rot( .5+6.*M.y),                              // rotations\n        q.xz *= rot( 2.-6.*M.x),\n        l += t = abs( length(vec2(d=length(q.xz)-R0,q.y)) - R1); // abs for inside + outside\n        //if ( t < .01 ) { // not good for fwidth\n        \n            float a = atan(q.z,q.x), b = atan(q.y,d),         // base torus parameterization\n                                                              // --- conformal mapping\n            r = R1/R0, ir = sqrt(1.-r*r);                     // antiderivative of 1/circonf(b) \n            b = .996*  2./ir* atan( (r-1.)/ir* tan(b/2.) );   //  NB: tan(b/2) = ( -d + sqrt(d*d+q.y*q.y) )/q.y )        \n            vec4 C = hue( floor(k*R0*a/6.283) + 17.*mod(round(k*R1*b/6.283),R1) ); // colored tiles \n\n            a = sin(k*R0*a/2.), b = cos(k*R1*b/2.);\n            C *= .25 / exp( (l-80.)/30. )                     // color * depth darkening\n                      * sqrt( min(abs(a)/fwidth(a),1.) * min( abs(b)/fwidth(b),1.) ); // tiles borders\n         // C = vec4( sqrt( 1. - min(abs(a)/fwidth(a),1.) * min( abs(b)/fwidth(b),1.) ) / exp( (l-80.)/30. ) ); // mesh alone\n            if ( t < .01 ) O += C, t = .2;                    // traverse the layer and continue\n        // }\n        p += t*D;                                             // step forward = dist to obj          \n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}