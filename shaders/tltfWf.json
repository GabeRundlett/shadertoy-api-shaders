{
    "Shader": {
        "info": {
            "date": "1613664244",
            "description": "Uniform distribution and cosine distribution.",
            "flags": 0,
            "hasliked": 0,
            "id": "tltfWf",
            "likes": 4,
            "name": " Pick Points On Hemisphere",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "moranzcw",
            "viewed": 460
        },
        "renderpass": [
            {
                "code": "// Pick Points On Hemisphere - by moranzcw - 2021\n// Email: moranzcw@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define Epsilon 1e-2\n#define PI 3.14159265359\n\n\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void)  { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n// --------------------------------------\n// hash by Hugo Elias\n// --------------------------------------\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\nstruct Ray \n{ \n    vec3 origin, direction;\n};\n\nstruct Sphere \n{\n\tfloat radius;\n\tvec3 position;\n};\n\nSphere sphere1 = Sphere(1.0, vec3(-1.2, 0.0, 0.0));\nSphere sphere2 = Sphere(1.0, vec3(1.2, 0.0, 0.0));\n\nfloat intersect(Sphere sphere, Ray ray)\n{\n\tvec3 op = sphere.position - ray.origin;\n\tfloat t1, t2 = Epsilon;\n    float b = dot(op, ray.direction);\n    float det = b * b - dot(op, op) + sphere.radius * sphere.radius;\n    \n\tif (det < 0.0)\n        return 0.0;\n    else\n        det = sqrt(det);\n    \n    t1 = b - det;\n    t2 = b + det;\n    if(t1 > Epsilon)\n        return t1;\n    if(t2 > Epsilon)\n        return t2;\n    return 0.0;\n}\n\nRay cameraRay(vec3 camPosition, vec3 lookAt, vec2 fragCoord)\n{\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\n    vec3 cz = normalize(lookAt - camPosition);\n\tvec3 cx = normalize(cross(cz, vec3(0.0, 1.0, 0.0)));\n\tvec3 cy = normalize(cross(cx, cz));\n    \n    return Ray(camPosition, normalize(0.53135 * (iResolution.x/iResolution.y*uv.x * cx + uv.y * cy) + cz));\n}\n\n// unifrom picking\nvec3 hemiSpherePoint(vec3 normal)\n{\n    float theta = 2.0 * PI * frand();\n    float cosPhi = frand();\n    float phi = acos(cosPhi);\n    \n    vec3 zAxis = normal;\n    vec3 xAxis = normalize(cross(normal, vec3(1.0, 0.0, 0.0)));\n    vec3 yAxis = normalize(cross(normal, xAxis));\n    \n    vec3 x = cos(theta) * xAxis;\n    vec3 y = sin(theta) * yAxis;\n    vec3 horizontal = normalize(x + y);\n    vec3 z = cosPhi * zAxis;\n    vec3 p = horizontal * sin(phi) + z;\n    \n    return normalize(p);\n}\n\n// Cosine distribution picking by iq\nvec3 hemiSpherePointCos(vec3 normal)\n{\n    float u = frand();\n    float v = frand();\n    float a = 6.2831853 * v;\n    u = 2.0*u - 1.0;\n    return normalize( normal + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    ivec2 q = ivec2(fragCoord);\n    srand(hash(1117));\n    \n    // camera ray\n    vec3 camPosition = mix(vec3(0.0, 0.0, 4.0), vec3(0.0, 3.0, 3.0), 0.5*sin(iTime*0.2)+0.5);\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    Ray ray = cameraRay(camPosition, lookAt, fragCoord);\n    \n\tvec3 color = vec3(0.0);\n    \n    // intersect\n    float t = intersect(sphere1, ray);\n    if(t > 0.0)\n    {\n        vec3 point = ray.origin + t * ray.direction;\n        for(float i=0.0; i<5000.0; i++)\n        {\n            vec3 p = sphere1.position + hemiSpherePoint(vec3(0.0, 1.0, 0.0));\n            \n            float tt = 0.5*sin(iTime)+0.5;\n            vec3 color1 = vec3(1.0,0.0,0.0) * step(length(point-p), 0.007) * step(0.0, point.y);\n            vec3 color2 = vec3(0.006,0.0,0.0) * step(length(point-p), 0.2) * step(0.0, point.y);\n            color += mix(color1, color2 , tt);\n        }\n    }\n    \n    t = intersect(sphere2, ray);\n    if(t > 0.0)\n    {\n        vec3 point = ray.origin + t * ray.direction;\n        for(float i=0.0; i<5000.0; i++)\n        {\n            vec3 p = sphere2.position + hemiSpherePointCos(vec3(0.0, 1.0, 0.0));\n            float tt = 0.5*sin(iTime)+0.5;\n            vec3 color1 = vec3(0.0,1.0,0.0) * step(length(point-p), 0.007) * step(0.0, point.y);\n            vec3 color2 = vec3(0.0,0.006,0.0) * step(length(point-p), 0.2) * step(0.0, point.y);\n            color += mix(color1, color2 , tt);\n        }\n    }\n\tfragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}