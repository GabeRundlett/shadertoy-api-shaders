{
    "Shader": {
        "info": {
            "date": "1723744479",
            "description": "from  https://www.shadertoy.com/view/stsXDl https://www.shadertoy.com/view/4tyfWy",
            "flags": 0,
            "hasliked": 0,
            "id": "MfXBW4",
            "likes": 2,
            "name": " colorful Kaleidoscope 10",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 73
        },
        "renderpass": [
            {
                "code": "\n#define time iTime\n#define resolution iResolution.xy\n\n\n\n\n\n// Emulate a black texture\n#define texture(s, uv) vec4(0.0)\n\n\n// not tied to uniform names\n#define R           iResolution\n#define M           iMouse\n#define T           iTime\n#define S           smoothstep\n#define PI          3.1415926\n#define PI2         6.2831853\n#define d5          .5773\n#define MINDIST     .0001\n#define MAXDIST     100.\n\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define R3(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*2.3+vec3(50,53,21))*.5+.5)\n//thebookofshaders timing functions\nfloat easeInOutExpo(float t) {\n    if (t == 0.0 || t == 1.0) return t;\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * pow(2.0, 10.0 * (t - 1.0));\n    } else {\n        return 0.5 * (-pow(2.0, -10.0 * (t - 1.0)) + 2.0);\n    }\n}\n\nfloat linearstep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0.0, 1.0);\n}\n\n\nfloat sdBox(vec3 p, vec3 s) {\n p.yz*=mat2(cos(iTime), sin(iTime), -sin(iTime),cos(iTime ));\n    p = abs(p)-s;\n    \n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.)-.05;\n}\nfloat orbit = .0,\n      txx   = .0025,\n      txa   = .0025,\n      glw   = .0;\nfloat zoom = 17.5; \nmat2 rotA = mat2(0.), rotB = mat2(0.), spin = mat2(12.);\n\n\nfloat Scale;\nvec3 map(vec3 p,float mgl){\n\n    \n    vec3 res = vec3(100.,-1.,0.);\n\n    float b = sdBox(p,vec3(2.5));\n    if(b<res.x) res=vec3(b,2.,orbit);\n    \n    \n    p=abs(p)-3.5;\n\n      p.zy*=mat2(cos(iTime), sin(iTime), -sin(iTime),cos(iTime ));\n   \n\n    \n\tfloat rate=-16.5;\n\t\n\t\n\tfloat mr2=.25;\n\t\n\tfloat off=1.37;\t// This number is the initial magnification. \n   \n\tfloat s=.095;\n    \n    vec3  p0 = p;\n\n    // You can play around with the number of iterations.\n    for (float i=0.; i<2.; i++){\n\n    // Please do not tamper with this function.\n    p=1.05-abs(p-1.);\n\n    // You can play around with all the constants here.\n    float g=clamp(mr2*max(1.25/dot(p,p),.8),0.,1.);\n\n    // Please do not tamper with these two lines.\n    p=p*rate*g+p0*off;\n    s=s*abs(rate)*g+off;\n        \n    // Rotate the coordinates a little. It's a bit peaky, so try it little by little.\n    // You can do various things without rotating it forcibly. I think it's better to use it with an accentã€‚\n    p.yz*=mat2(cos(iTime), sin(iTime), -sin(iTime),cos(iTime ));\n\n    p.zx*=mat2(cos(iTime), sin(iTime), -sin(iTime),cos(iTime ));\n   \n    }\n\n    // This number is log2() the final scale factor. It is a parameter for coloring.\n    // There is no problem with log() separately. I'm using it with a glue like log2() because it will be multiplied like twice.\n \n\n   \n    \n    float d= length(p.xz*mat2(cos(iTime), sin(iTime), -sin(iTime),cos(iTime )))/s-.6025;\n    d= max(sdBox(p,vec3(5.))/s-.21,-d);\n    if(d<res.x) res=vec3(d,1.,orbit);\n   \n    glw += .15/(.3+b*b);//@evvvil\n    return res;\n    \n}\n\n\nvec3 marcher(vec3 ro, vec3 rd, int maxsteps) {\n    float d = 0.,\n    \n          m = -1.,\n          o = 0.;\n    int i = 0;\n    \n    \n    for(int ii = 0; ii<256; ii++) {\n   \n    \n        vec3 p = ro + rd * d;\n        \n         \n        \n        vec3 t = map(p,1.);\n       \n    \n        d += t.x*.5;\n        m  = t.y;\n        o  = t.z;\n      \n    }\n    float de = float(i)/float(maxsteps);\n    return vec3(d,m,o);\n}\n\n// Tetrahedron technique @iq\n// https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 getNormal(vec3 p, float t){\n\n    float e = (MINDIST + .0001) *t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    \n    return normalize( h.xyy*map( p + h.xyy*e ,0.).x + \n                      h.yyx*map( p + h.yyx*e ,0.).x + \n                      h.yxy*map( p + h.yxy*e ,0.).x + \n                      h.xxx*map( p + h.xxx*e ,0.).x );\n}\n\n//camera setup\nvec3 camera(vec3 lp, vec3 ro, vec2 uv) {\n    vec3 f=normalize(lp-ro),//camera forward\n         r=normalize(cross(vec3(0,1,0),f)),//camera right\n         u=normalize(cross(f,r)),//camera up\n         c=ro+f*0.595,//zoom\n         i=c+uv.x*r+uv.y*u,//screen coords\n        rd=i-ro;//ray direction\n    return rd;\n}\n//vec3(.45,1.5,1.25)?\nvec3 gethue(float a){return  .5 + .45*cos((4.5*a) - vec3(.25,1.5,2.15));}\n\nvec3 getColor(float m, float o){\n    vec3 h = gethue(o*.25);\n    // use orbit number to band coloring\n    \n    return h;\n}\n\nfloat ao(float j, vec3 p, vec3 n) {\n    return clamp(map(p + n*j,0.).x/j, 0.,1.);   \n}\n\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nvoid mainImage( out vec4 O, in vec2 F ){\n \n    float tm = mod(T*2.5, 32.);\n    // move x steps in rotation\n    float v1 = linearstep(0.0, 1.0, tm);\n    float a1 = linearstep(2.0, 3.0, tm);\n    \n\tfloat v2 = linearstep(4.0, 5.0, tm);\n    float a2 = linearstep(6.0, 7.0, tm);\n    \n    float v3 = linearstep(8.0, 9.0, tm);\n    float a3 = linearstep(10.0, 11.0, tm);\n    \n    float v4 = linearstep(12.0, 13.0, tm);\n    float a4 = linearstep(14.0, 15.0, tm);\n    \n    float v5 = linearstep(16.0, 17.0, tm);\n    float a5 = linearstep(18.0, 19.0, tm);\n    \n\tfloat v6 = linearstep(20.0, 21.0, tm);\n    float a6 = linearstep(22.0, 23.0, tm);\n    \n    float v7 = linearstep(24.0, 25.0, tm);\n    float a7 = linearstep(26.0, 27.0, tm);\n    \n    float v8 = linearstep(28.0, 29.0, tm);\n    float a8 = linearstep(30.0, 31.0, tm);\n    \n    float degs = mix(0., 360./8.,v1);\n    float degx = mix(0., 360./8.,a1);\n    \n    // mix downs\n    txa = degs;\n    txx = degx;\n    \n    rotB = r2(degs*PI/iTime);\n    rotA = r2(degx*PI/180.);\n    \n    spin = r2(-T*.06);\n\n    // Normalized pixel coordinates -1 to 1\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 C = vec3(0.);\n\tvec3 FC = gethue(13.3);\n    vec3 lp = vec3(0.,0.,0.),\n         ro = vec3(0.,0.,zoom);\n       \n         ro.zx*=mat2(cos(iTime), sin(iTime), -sin(iTime),cos(iTime ));\n   ro.zy*=mat2(cos(iTime), sin(iTime), -sin(iTime),cos(iTime ));\n    vec3 rd = camera(lp, ro, uv);\n          \n    vec3 t = marcher(ro,rd, 256);\n    \n    float m = t.y;\n    float o = t.z;\n    // Standard shading procedures\n    // yah dif - p and n - dif yah\n    if(t.x<MAXDIST) {\n        vec3 p = ro + rd * t.x,\n        \n             n = getNormal(p, t.x);\n             n.zx*=mat2(cos(iTime), sin(iTime), -sin(iTime),cos(iTime ));\n        vec3 light1 = vec3(0,25.,-15.0),\n             light2 = vec3(0,25.,15.0);\n        float dif  = clamp(dot(n,normalize(light1-p)),0. , 1.);\n              dif += clamp(dot(n,normalize(light2-p)),0. , 1.);\n        vec3 h = (m==1.) ? getColor(m,o) : FC;      \n        C += dif* (ao (0.5,p,n) + ao(.05,p,n))*h*vec3(2.);\n    } else {\n        C += FC;\n    }\n    // Background - I enjoy the slight motion stuff\n    vec2 dv = uv+vec2(T*.041,-T*.023);\n   \n \n    vec3 cirx = mix(FC,gethue(14.3),1.);\n    float dt = smoothstep(.2,.65,distance(uv,vec2(0.))*.75);\n    cirx = mix(FC,cirx,dt*.25);\n    // Fog / Blending\n    C = mix( C, cirx, 1.-exp(-.000125*t.x*t.x*t.x));\n    // add back glow\n    // Output to screen\n    C *=vec3(texture(iChannel0,uv/.23).x);\n    C += vec3(glw*.65)*FC;\n    O = vec4(pow(C, vec3(0.4545)),1.0);\n    \nvec4 O2=vec4(0);\nvec2 C2=F;\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C2*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O2.xyz+=mix(vec3(1.,0.1,3.2),H(g*.1),.8)*1./e/8e3\n    )\n    {\n        p=g*d;\n            p.xz+=dot((p.x), (p.z));\n        p.z+=iTime*10.5;\n        a=30.;\n        p=mod(p-a,a*2.)-a;\n    \n        s=2.;\n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            s*=e=1.4+sin(iTime*.1)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.+sin(iTime*.3+.5*sin(iTime*.3))*3.,\n                    120,\n                    8.+cos(iTime*.5)*5.\n                 )*O.xyz;\n         }\n         g+=e=length(p.yx)/s;\n    }\n    O=O2;\n     \n    uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    O*= vec4(happy_star(uv, anim) * vec3(0.35,0.2,0.55), 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}