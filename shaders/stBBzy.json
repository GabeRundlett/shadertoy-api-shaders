{
    "Shader": {
        "info": {
            "date": "1652365126",
            "description": "Randomly rendering particles across a sin graph",
            "flags": 0,
            "hasliked": 0,
            "id": "stBBzy",
            "likes": 2,
            "name": "particles graph",
            "published": 3,
            "tags": [
                "2d",
                "particles"
            ],
            "usePreview": 0,
            "username": "makscee",
            "viewed": 262
        },
        "renderpass": [
            {
                "code": "const float pi = 3.14159;\n\nvec3 p_colors[3];\nconst int p_count = 200;\nconst float p_radius = 0.02;\nconst float p_glow_radius = 0.6;\n\nvec4 alphaBlend(vec4 c1, vec4 c2)\n{\n    return vec4(\n        mix(c1.r, c2.r, c2.a),\n        mix(c1.g, c2.g, c2.a),\n        mix(c1.b, c2.b, c2.a),\n        clamp(max(c1.a, c2.a) + c1.a * c2.a * .3, 0., 1.));\n}\n\nvec2 N22(vec2 p) \n{\n  vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n  a += dot(a, a+34.45);\n  return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nfloat rand(int i)\n{\n    return N22(vec2(i)).x;\n}\n\nvec3 mix3Colors(float t, vec3 colors[3])\n{\n    t += float(t < 0.);\n    int colorInd = int(t * 3.);\n    vec3 c1 = colors[colorInd];\n    vec3 c2 = colors[(colorInd + 1) % 3];\n    return mix(c1, c2, t * 3. - float(colorInd));\n}\n\nvec2 p_graph(float t)\n{\n    float scale = sin(iTime * .5) * 8.;\n    t -= floor(t + 0.5);\n    t *= 10.;\n    return vec2(t, sin(t * scale));\n}\n\nvec2 p_positionOverT(int i, float t)\n{\n    const float part = 0.25;\n    float r0 = rand(i);\n    float r1 = rand(i + 1);\n    return float(r1 < part) * (vec2(fract(r0 + iTime * .1) * 10. - 5., sign(r1 - part * .5)))\n        + float(r1 > part) * p_graph(r0 - 0.5 + t * 1.);\n}\n\nvec3 p_color(int i)\n{\n    return mix3Colors(rand(i), p_colors);\n}\n\nfloat p_glow(float dist)\n{\n    return smoothstep(p_glow_radius, 0., dist - p_radius) * .3;\n}\n\nvec4 p_renderParticle(vec2 uv, int i, float t)\n{\n    vec2 position = p_positionOverT(i, t);\n    float dist = distance(uv, position);\n    float alpha = max(float(dist < p_radius), p_glow(dist));\n    return vec4(p_color(i), alpha);\n}\n\nbool p_discardCheck(vec2 uv, float t)\n{\n    return abs(uv.y) - p_radius - p_glow_radius > 1.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    p_colors[0] = vec3(0.862, 0.078, 0.235);\n    p_colors[1] = vec3(0.541, 0.168, 0.886);\n    p_colors[2] = vec3(0.117, 0.564, 1);\n\n    float t = iTime * .1;\n    fragCoord -= iResolution.xy / 2.0;\n    vec2 uv = fragCoord/iResolution.x*10.0;\n    if (p_discardCheck(uv, t))\n    {\n        fragColor = vec4(0);\n        return;\n    }\n\n    vec4 col = vec4(0);\n    for (int i = 0; i < p_count; i++)\n        col = alphaBlend(col, p_renderParticle(uv, i, t));\n    fragColor = alphaBlend(vec4(0), col);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}