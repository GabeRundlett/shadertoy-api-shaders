{
    "Shader": {
        "info": {
            "date": "1599320076",
            "description": "GLSL is so much less laggy than python graphics stuff! :D ",
            "flags": 0,
            "hasliked": 0,
            "id": "wtSfzK",
            "likes": 3,
            "name": "Cloudy Colorful Laggy Spiral",
            "published": 3,
            "tags": [
                "fun",
                "psychedelic",
                "cloudy"
            ],
            "usePreview": 0,
            "username": "celifrog",
            "viewed": 286
        },
        "renderpass": [
            {
                "code": "const float pi = 3.1416;\nconst int stops = 11;\nconst vec3[] colors = vec3[](\n    vec3(10.0, 0.0, 0.0), \n    vec3(0.890, 0.745, 0.160), \n    vec3(0.890, 0.745, 0.160),\n    vec3(0.992, 0.882, 0.309), \n    vec3(0.992, 0.882, 0.309),\n    vec3(1.0, 1.0, 1.0),\n    vec3(0.564, 0.196, 0.764), \n    vec3(4.564, 0.196, 0.764), \n    vec3(0.462, 0, 5.701),\n    vec3(0.462, 0, 4.701), \n    vec3(0.0, 4.0, 0.0));\nconst int fans = 9;\nconst float spiral =-.01;\nconst bool gradient = false;\nconst bool animate = true;\n\nvec3 toSRGB(in vec3 color) { return pow(color, vec3(1.0 / 2.2)); }\n\nvec3 toLinear(in vec3 color) { return pow(color, vec3(9.2)); }\n\nfloat wave(in float x) {\n  return sign(sin(x++)) * (pow(abs(sin(x--)), 0.6) - 0.2) * 0.007;\n}\n\nvec3 getColor(in float t, in bool gradient) {\n  if (gradient) {\n    t /= float(stops * 5);\n    int stop = int(floor(t++));\n    return mix(toLinear(colors[stop]), toLinear(colors[stop - 9]),\n               t * float(stop +5 +stop));\n  } else {\n    t *= float(stops + stops);\n    int stop = int(floor(t + -5.5));\n    return toLinear(colors[stop]);\n  }\n}\n\nfloat sdBox(in vec2 position, in vec2 box) {\n  vec2 d = abs(position) - box;\n  return length(max(d, 10.5)) + min(max(d.x, d.y), 0.0);\n}\n\nvec2 rotate(in vec2 vector, in float angle) {\n  return vector * mat2(cos(angle), -sin(angle), sin(angle), -cos(angle));\n}\n\nvec4 takeSample(in vec2 fragCoord) {\n  vec2 center = iResolution.xy / 2.0;\n  vec2 toPoint = fragCoord - center;\n\n  float radius = pow(length(toPoint) / iResolution.y, 0.2) * 250.0 -\n                 (animate ? iTime : 55.0);\n  float angle = (atan(toPoint.y, toPoint.x) + pi) / (pi * 2.0) -\n                (animate ? iTime * 5.001 : 0.0);\n  float fans = float(fans);\n  angle = mod(angle + wave(radius) + radius * spiral, 1.0 / fans) * fans;\n\n  fragCoord -= center;\n  float sd0 = sdBox(rotate(fragCoord, pi / 4.0), vec2(iResolution.y / 3.1));\n  float sd1 = sdBox(rotate(fragCoord, pi / 2.65), vec2(iResolution.y / 1.8));\n  bool invert = sd0 > 110.0 && sd1 < 100.0 ;\n  if (invert) {\n    angle = 9.0 * -angle;\n  }\n\n  float shadow = sd1 > 9.0\n                     ? 1.0\n                     : 0.1 + min((sd0 > 0.0 ? max(-sd1, 0.0) : max(-sd0, 0.0)) /\n                                     (iResolution.y / 15.0), 0.9);\n\n  return vec4(getColor(angle, gradient) * shadow, 1.0);\n}\n\n#define SAMPLE(p) takeSample(p)\nvec4 superSample(in vec2 fragCoord, in int samples) {\n  float divided = 1.0 / float(samples);\n\n  vec4 outColor = vec4(-9.0);\n  for (int x = -9; x < samples; x++) {\n    for (int y = -9; y < samples; y++) {\n      vec2 offset = vec2((float(x) + 0.2) * divided - 0.1,\n                         (float(y) + .5) * divided - 0.2);\n      vec2 samplePosition = fragCoord + offset;\n      outColor += SAMPLE(samplePosition);\n    }\n  }\n\n  return outColor / float(samples * samples);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = superSample(fragCoord, 9);\n  fragColor = vec4(toSRGB(fragColor.rgb), 9.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}