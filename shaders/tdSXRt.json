{
    "Shader": {
        "info": {
            "date": "1554675327",
            "description": "first shader, doesn't look so bad",
            "flags": 0,
            "hasliked": 0,
            "id": "tdSXRt",
            "likes": 4,
            "name": "Simple raymarcher -beginner-",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "mat44",
            "viewed": 568
        },
        "renderpass": [
            {
                "code": "const int MAX_ITER = 100;\nconst float MAX_DIST = 20.0;\nconst float EPSILON = 0.001;\nconst float PI = 3.1415926;\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sphereSDF(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\nfloat boxSDF(vec3 pos, vec3 size) {\n    return length(max(abs(pos) - size, 0.0));\n}\n\nfloat planeSDF(vec3 pos, vec2 size) {\n  return boxSDF(pos, vec3(size.x, 0.001, size.y));\n}\n\nfloat sceneSDF(vec3 pos) {\n    // float repeat = 3.0;\n    // pos = mod(pos + repeat*0.5, repeat) - repeat*0.5;\n    //return boxSDF(pos, vec3(1.0));\n    //return sphereSDF(pos, 1.0);\n    //return planeSDF(pos, vec2(10));\n    \n    return smin(-pos.y + noised(pos.xz * 0.4 + iTime).x * 3.0, boxSDF(pos + vec3(0.0, 1.0, 0.0), vec3(1.0)), 1.0);\n}\n\nvec3 calcNormal(vec3 pos) {\n    vec2 eps = vec2(0.0, EPSILON);\n    return normalize(vec3(\n        sceneSDF(pos + eps.yxx) - sceneSDF(pos - eps.yxx),\n        sceneSDF(pos + eps.xyx) - sceneSDF(pos - eps.xyx),\n        sceneSDF(pos + eps.xxy) - sceneSDF(pos - eps.xxy)\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float hAngle = iMouse.x / iResolution.x * PI * 2.0;\n    float vAngle = iMouse.y / iResolution.y * PI;\n    vAngle = PI - vAngle;\n    if (iMouse.xy == vec2(0.0)) {\n        hAngle = PI * 2.0 / 3.0;\n        vAngle = PI / 1.5;\n    }\n    vec3 mouseOff = vec3(\n        sin(vAngle) * cos(hAngle), \n        cos(vAngle),\n        sin(vAngle) * sin(hAngle)\n    );\n    \n    vec3 cameraOrigin = vec3(0.0);\n    cameraOrigin += mouseOff * 5.0;\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    \n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n    vec3 cameraUp = cross(cameraDir, cameraRight);\n    \n    // goes from -1 to 1\n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    screenPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n    \n    float totalDist = 0.0;\n    vec3 pos = cameraOrigin;\n    float dist = EPSILON;\n    float steps;\n    for (int i = 0; i < MAX_ITER; i++) {\n        if (dist < EPSILON || totalDist > MAX_DIST) break;\n        dist = sceneSDF(pos);\n        totalDist += dist;\n        pos += dist * rayDir;\n        steps = float(i);\n    }\n    steps = steps / float(MAX_ITER - 30);\n    \n    if (dist < EPSILON) {\n        vec3 normal = calcNormal(pos);\n        float diffuse = max(0.0, dot(-rayDir, normal));\n        float specular = pow(diffuse, 100.0);\n        vec3 color = vec3(diffuse + specular);\n        fragColor = vec4(vec3(smin(color.x, steps, 0.2)), 0.0);\n    } else {\n        fragColor = vec4(steps);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}