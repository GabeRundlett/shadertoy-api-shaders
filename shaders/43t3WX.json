{
    "Shader": {
        "info": {
            "date": "1717084295",
            "description": "Framework containing performance improvements over my previous text utilities for shader string manipulation",
            "flags": 0,
            "hasliked": 0,
            "id": "43t3WX",
            "likes": 63,
            "name": "Better Text in Shaders",
            "published": 3,
            "tags": [
                "utility",
                "string",
                "display",
                "alphabet",
                "debug",
                "character",
                "fonts",
                "characters",
                "char"
            ],
            "usePreview": 0,
            "username": "kishimisu",
            "viewed": 810
        },
        "renderpass": [
            {
                "code": "/*\n    > See \"Common\" Tab for usage detail.\n    \n    This shader is an improved version of my previous text utility (see fork) that was designed\n    to facilitate string manipulation in shaders. This version greatly improves performance.\n    \n    === What's new ? ===\n    \n    In short, I'm now using int[] arrays to declare strings. I only create 1 function per string\n    instead of creating 1 function per character like the previous version did.\n    The idea for this new approach came from @jiang on my recent code-golfing challenge (https://www.shadertoy.com/view/lXt3zf)\n    \n    1. One Texture Call Per Line\n    \n        The performance impact of the previous version scaled with the total number of characters in\n        each string. For every character that was defined, there was one associated texture sample.\n        \n        In this new version, there is only 1 texture sample per string definition, greatly reducing \n        the performance impact. A 20-character string now contains 20x less texture samples.\n        \n    2. No \"For\" Loop\n    \n        The floating point debug of my previous algorithm was using 3 for-loops to print a number,\n        and had precision issues.\n        \n        This is also greatly improved in this version as this shader doesn't rely on any loop whatsoever.\n        Moreover, the algorithm now supports integer debugging (which wasn't possible in the previous\n        version), and the precision is slightly improved.\n        \n    3. Fast Compile Time\n    \n        In the previous version, each character was calling a function to calculate\n        its position in the alphabet texture in order to sample the texture at that position.\n        This was done using well-crafted #defines for every character, but could lead to \n        excessive compile times.\n        \n        In this version, the #defines are much simpler as I'm using integer arrays instead\n        of complex define trickery.\n        \n        Previously, \"_A\" was defined as: #define _A ); u.x -= CHAR_SPACING; d += _char(FONT_TEXTURE, u, 65\n        \n        Now, \"_A\" simply is \"65,\" (a single element in an int[] array) and the compilation time is greatly improved.\n        \n        Moreover, I managed to keep each int[] array as a compile-time constant (const) in order to\n        maximize performance.\n        \n    ===================================================================================================\n*/\n\n/* Basic string definition: makeStr(name) _A _B _C _end\n *\n * Will create a function:  float name(vec2 uv);\n */\nmakeStr (printBetter) _B _e _t _t _e _r __ _W _a _y __ _T _o __ _P _r _i _n _t __ _T _e _x _t __ _i _n __ _S _h _a _d _e _r _s _EX _end\n\n/* String + integer debug : makeStrI(name) _A _num_ _B _C _endNum\n *\n * Will create a function:  float name(vec2 uv, int num);\n * The input variable will be displayed at the position of the \"_num_\" keyword.\n */\nmakeStrI(printFrame)  _D _e _b _u _g __ _I _n _t _e _g _e _r _s _COL __ _i _F _r _a _m _e __ _EQ __ _num_ __ _f _r _a _m _e _s _endNum\n\n/* String + float debug :   makeStrF(name) _A _B _num_ _C _endNum\n *\n * Will create a function:  float name(vec2 uv, float num, int decimal_count);\n * The input variable will be displayed at the position of the \"_num_\" keyword.\n */\nmakeStrF(printTime)   _D _e _b _u _g __ _F _l _o _a _t _s _COL __ _s _i _n _LPR _i _T _i _m _e _RPR __ _EQ __ _num_ __ _a _s __ _f _3 _2 _endNum             \n\n/* Quick int/float debug: debugInt & debugFloat\n *\n * Defining these two helpers allow to quickly debug int/float variables, \n * without the need to create a full string definition each time with makeStr().\n *\n *     color += debugInt(uv, 42);\n *     color += debugFloat(uv, 3.14, 2);\n */\nmakeStrI(debugInt) _num_ _endNum\nmakeStrF(debugFloat) _num_ _endNum\n\n// Other string definitions\nmakeStr (print1)      _1 _DOT __ _O _n _e __ _T _e _x _t _u _r _e __ _C _a _l _l __ _P _e _r __ _l _i _n _e _end\nmakeStr (print2)      _2 _DOT __ _N _o __ _DBQ _F _o _r _DBQ __ _L _o _o _p _end\nmakeStrI(print3)      _num_ _DOT __ _F _a _s _t __ _C _o _m _p _i _l _e __ _T _i _m _e _endNum\nmakeStr (printJS)     _ADD __ _J _a _v _a _s _c _r _i _p _t __ _S _t _r _i _n _g __ _G _e _n _e _r _a _t _o _r _end\nmakeStr (printUse)    _B _a _s _i _c __ _U _s _a _g _e _COL _end\nmakeStr (printCode1)  _m _a _k _e _S _t _r _LPR _m _y _UN _s _t _r _i _n _g _RPR __ _UN _H __ _UN _e __ _UN _l __ _UN _l __ _UN _o __ _UN _UN __ _UN _W __ _UN _o __ _UN _r __ _UN _l __ _UN _d __ _UN _e _n _d _end\nmakeStr (printCode2)  _f _r _a _g _C _o _l _o _r __ _ADD _EQ __ _m _y _UN _s _t _r _i _n _g _LPR _u _v _RPR _SEM _end\n\n// Color definitions\n#define RED     vec3( 1,.3,.4)\n#define BLUE    vec3(.5, 1, 1)\n#define YELLOW  vec3( 1, 1,.4)\n#define ORANGE  (1.+cos(uv.y*12. + .7 + vec3(0,1,2)))\n#define RAINBOW abs(cos(uv.x*4. - iTime*2. + vec3(5,6,1)))\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y; // uv in [0, 1] range\n    vec3 col = vec3(0);                // final color\n\n    uv.y -= .9;                   // Start writing from top\n    uv = uv * .8 - vec2(.02, .0); // Font size + padding left\n    \n    col += ORANGE  * printBetter(uv*.81); // Better Way To Print Text in Shaders!\n    \n    col += BLUE    * printFrame(uv + vec2(0, .1), iFrame);           // Debug Integers: iFrame\n     \n    col += BLUE    * printTime(uv+vec2(0,.18), sin(iTime)*1200., 3); // Debug Floats: sin(iTime)\n    \n    col += RED/.8  * print1(uv + vec2(-.2, .3));                     // 1. One texture Call Per Line\n    \n    col += RED/.5  * print2(uv + vec2(-.2, .37));                    // 2. No \"For\" Loop\n    \n    col += RED/.4  * print3(uv + vec2(-.2, .44), iFrame%100-50);     // 3. Fast Compile time\n            \n    col += RAINBOW * printJS(uv*1.5 + vec2(-1.1, .78));              // + Javascript String Generator\n    \n    col += YELLOW  * printUse(uv*1.35 + vec2(0, .75)); // Basic Usage:\n    \n    col += printCode1(uv*1.35 + vec2(-.1, .84));       // makeStr(my_string) _H _e _l _l _o __ _W _o _r _l _d _end\n    \n    col += printCode2(uv*1.35 + vec2(-.1, .92));       // fragColor += my_string(uv);\n    \n    // Use debugInt & debugFloat to directly display variables \n    // without the need to create additional string definitions:\n    //\n    //     col += debugInt(uv*.2 + vec2(0, .05), 42);    \n    //     col += debugFloat(uv*.2 + vec2(0, .1), 3.1415, 4);\n    \n    fragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*** Settings ***/\n\n#define FONT_TEXTURE iChannel0 // Set to the iChannel containing the alphabet texture\n\n#define FONT_SPACING 2.        // Horizontal character spacing [1 - 2.5]\n\n\n/* ### How to use this shader ? ###\n   \n   === Setup ===\n   \n   0. Copy the content of the \"Common\" tab inside your shader\n   1. Make sure the FONT_TEXTURE #define is set to the iChannel \n      containing the alphabet texture\n      \n      Also make sure the texture filter type is set to \"linear\"  \n      (not \"mipmap\", which creates horizontal lines between the characters)\n   \n   === Declare String ===\n   \n   2. Use makeStr to declare a new string (needs to be done outside any function)\n   3. Write your text using _ before each char, and __ for spaces\n   4. Finish your string with the _end keyword\n   \n       makeStr(printExample) _A _n _o _t _h _e _r __ _E _x _a _m _p _l _e    _end\n          \n   === Print String ===\n   \n   5. Call the new function by passing it your uvs. It returns a grayscale value.\n   \n       finalCol += printExample(uv);\n   \n   - Note that you are responsible for scaling/offsetting the uvs \n     to control the text placement before calling the function.\n   \n   - If you want to print float or integer variables, see below.\n   \n   \n   ###### Printing variables ######\n   \n   In order to print int & float variables, you can call two other functions instead of makeStr:\n   \n     - makeStrI (for integers) & makeStrF (for floats).\n     \n   [ IMPORTANT ]: When using makeStrI or makeStrF, you MUST use _endNum instead of _end \n                  to terminate a string.\n                  \n                  If you're seeing many errors when trying to compile, it's probably\n                  because you're using the wrong terminator for the current string type (_end/_endNum)\n   \n   === Declare Strings ===\n   \n   - In both cases, the variable will be displayed at the position of the _num_ keyword:\n   \n       makeStrI(print_my_int)   _M _y __ _I _n _t _e _g _e _r       _num_            _endNum\n       makeStrF(print_my_float) _F _l _o _a _t  _num_  _A _d _d _i _t _i _o _n _a _l _endNum\n   \n    - print_my_int   will be (vec2 uv, int num)\n    - print_my_float will be (vec2 uv, float num, int number_of_decimals)\n      \n   === Print Strings ===\n\n       print_my_int(uv, 42);          // will print \"My Integer 42\"\n       print_my_float(uv, 42.123, 2); // will print \"Float 42.12 Additional\"\n       \n    - A limitation of this version compared to the previous one is that you can only display\n      one variable per string definition (so only one _num_ keyword is allowed per string).\n   \n   === Debug variables without makeStr ===\n  \n   A handy thing you can do in your Image tab is to create \n   the following debugInt & debugFloat helpers:\n  \n       makeStrF(debugFloat) _num_ _endNum\n       makeStrI(debugInt) _num_ _endNum\n       \n   Defining these two helpers allow to quickly debug int/float variables, \n   without the need to create a full string definition every time using makeStr().\n \n      color += debugInt(uv, 42);\n      color += debugFloat(uv, 3.14, 2);\n \n \n   ### Characters available ###\n   \n   uppercase: _A _B _C ...\n   lowercase: _a _b _c ...\n   digits   : _0 _1 _2 ...\n   special  : _ADD _SUB _DOT ... (see \"Special Characters\" below)\n   \n   \n   ### Javascript string generator helper ###\n    \n    Even if this framework allow for easier string editing, it can still be a bit tedious to create\n    long strings with special characters, so I've also made a javascript function that you can run\n    in your developer console to easily create strings:\n\n    function createString(str) {\n        const special_chars = {\n            \" \": \"_\", \"!\": \"EX\", \"\\\"\":\"DBQ\", \"#\": \"NUM\", \"$\": \"DOL\", \"%\": \"PER\",  \"&\": \"AMP\", \n            \"\\'\":\"QT\", \"(\": \"LPR\", \")\": \"RPR\", \"*\": \"MUL\", \"+\": \"ADD\", \",\": \"COM\", \"-\": \"SUB\", \n            \".\": \"DOT\", \"/\": \"DIV\", \":\": \"COL\", \";\": \"SEM\", \"<\": \"LES\", \"=\": \"EQ\", \">\": \"GE\", \n            \"?\": \"QUE\", \"@\": \"AT\", \"[\": \"LBR\", \"\\\\\": \"ANTI\", \"]\": \"RBR\",  \"_\": \"UN\", \n        };\n        const num = str.indexOf('_num_');\n        const end = num == -1 ? ' _end' : ' _endNum';\n        str = str.replace('_num_', '').split('').map(e =>  '_' + (special_chars[e] || e));\n        if (num != -1) str = str.slice(0, num).concat( '_num_', str.slice(num));\n        return str.join(' ') + end;\n    }\n\n    Usage (static): \n        > createString(\"Hello World!\") \n        '_H _e _l _l _o __ _W _o _r _l _d _EX _end'\n           \n    Usage (variable): \n        > createString(\"My Number is _num_!\")\n        '_M _y __ _N _u _m _b _e _r __ _i _s __ _num_ _EX _endNum'\n*/\n\n// Special characters\n#define __    32,\n#define _EX   33, // \" ! \"\n#define _DBQ  34, // \" \" \"\n#define _NUM  35, // \" # \"\n#define _DOL  36, // \" $ \"\n#define _PER  37, // \" % \"\n#define _AMP  38, // \" & \"\n#define _QT   39, // \" ' \"\n#define _LPR  40, // \" ( \"\n#define _RPR  41, // \" ) \"\n#define _MUL  42, // \" * \"\n#define _ADD  43, // \" + \"\n#define _COM  44, // \" , \"\n#define _SUB  45, // \" - \"\n#define _DOT  46, // \" . \"\n#define _DIV  47, // \" / \"\n#define _COL  58, // \" : \"\n#define _SEM  59, // \" ; \"\n#define _LES  60, // \" < \"\n#define _EQ   61, // \" = \"\n#define _GE   62, // \" > \"\n#define _QUE  63, // \" ? \"\n#define _AT   64, // \" @ \"\n#define _LBR  91, // \" [ \"\n#define _ANTI 92, // \" \\ \"\n#define _RBR  93, // \" ] \"\n#define _UN   95, // \" _ \"\n\n// Digits\n#define _0 48,\n#define _1 49,\n#define _2 50,\n#define _3 51,\n#define _4 52,\n#define _5 53,\n#define _6 54,\n#define _7 55,\n#define _8 56,\n#define _9 57,\n// Uppercase\n#define _A 65,\n#define _B 66,\n#define _C 67,\n#define _D 68,\n#define _E 69,\n#define _F 70,\n#define _G 71,\n#define _H 72,\n#define _I 73,\n#define _J 74,\n#define _K 75,\n#define _L 76,\n#define _M 77,\n#define _N 78,\n#define _O 79,\n#define _P 80,\n#define _Q 81,\n#define _R 82,\n#define _S 83,\n#define _T 84,\n#define _U 85,\n#define _V 86,\n#define _W 87,\n#define _X 88,\n#define _Y 89,\n#define _Z 90,\n// Lowercase\n#define _a 97,\n#define _b 98,\n#define _c 99,\n#define _d 100,\n#define _e 101,\n#define _f 102,\n#define _g 103,\n#define _h 104,\n#define _i 105,\n#define _j 106,\n#define _k 107,\n#define _l 108,\n#define _m 109,\n#define _n 110,\n#define _o 111,\n#define _p 112,\n#define _q 113,\n#define _r 114,\n#define _s 115,\n#define _t 116,\n#define _u 117,\n#define _v 118,\n#define _w 119,\n#define _x 120,\n#define _y 121,\n#define _z 122,\n\n// ======  utils  ======\n\n#define print_char(i) \\\n    texture(FONT_TEXTURE, u + vec2(float(i)-float(x)/FONT_SPACING + FONT_SPACING/8., 15-(i)/16) / 16.).r\n\n// ======  makeStr()  ======\n\n// Function start\n#define makeStr(func_name)                               \\\n    float func_name(vec2 u) {                            \\\n        if (u.x < 0. || abs(u.y - .03) > .03) return 0.; \\\n        const int[] str = int[](                         \\\n\n// Function end\n#define _end  0);                                        \\\n    int x = int(u.x * 16. * FONT_SPACING);               \\\n    if (x >= str.length()-1) return 0.;                  \\\n    return print_char(str[x]);                           \\\n}\n\n\n// -------------------------------------------------------------------\n//    If you only plan to display static characters (no variables) \n//    you don't need to include anything below this disclaimer\n// -------------------------------------------------------------------\n\n// ======  makeStrFloat() & makeStrInt() ======\n\n#define log10(x) int(ceil(.4342944819 * log(x + x*1e-5)))\n#define _num_ 0); const int[] str2 = int[]( \n\n// makeStrFloat() start\n#define makeStrF(func_name)                              \\\n    float func_name(vec2 u, float num, int dec) {        \\\n        if (u.x < 0. || abs(u.y - .03) > .03) return 0.; \\\n        const int[] str1 = int[](\n\n// makeStrInt() start\n#define makeStrI(func_name)                              \\\n    float func_name(vec2 u, int num_i) {                 \\\n        if (u.x < 0. || abs(u.y - .03) > .03) return 0.; \\\n        float num = float(num_i);                        \\\n        const int dec = -1;                              \\\n        const int[] str1 = int[](\n\n// makeStrFloat & makeStrInt end\n#define _endNum  0);                            \\\n    const int l1 = str1.length() - 1;           \\\n    int x = int(u.x * 16. * FONT_SPACING);      \\\n    if (x < l1) return print_char(str1[x]);     \\\n    int neg = 0;                                \\\n    if (num < 0.) {                             \\\n        if (x == l1) return print_char(45);     \\\n        num = abs(num);                         \\\n        neg = 1;                                \\\n    }                                           \\\n    int pre = neg + max(1, log10(num));         \\\n    int s2 = l1 + pre + dec + 1;                \\\n    if (x >= s2) {                              \\\n        if (x >= s2+str2.length()-1) return 0.; \\\n        int n2 = str2[x - s2];                  \\\n        return print_char(n2);                  \\\n    }                                           \\\n    float d = float(l1 + pre - x);              \\\n    if (d == 0.) return print_char(46);         \\\n    d = pow(10., d < 0.  ? ++d : d);            \\\n    int n = 48 + int(10.*fract(num/.999999/d)); \\\n    return print_char(n);                       \\\n}\n\n/* === Curious about how makeStrI() and makeStrF() work ? ===\n\nHere is a broken-down and commented version of the following syntax:\n\n    makeStrF(print_string_with_float) _H _e _l _l _o _num_ _W _o _r _l _d _endNum\n    \nThis will translate exactly to the following code:\n\nfloat print_string_with_float(vec2 u, float num, int decimals) \n{\n    if (u.x < 0. || abs(u.y - .03) > .03) return 0.;\n    \n    // The number (num) will be displayed between these two strings.\n    // The separation is handled by the #define \"_num_\"\n    const int[] str1 = int[]( _H _e _l _l _o  0);\n    const int[] str2 = int[]( _W _o _r _l _d  0);\n    \n    const int str1_length = str1.length() - 1;\n    \n    int x = int(u.x * 16. * SPACING);\n    \n    // Print char from 1st string (before number)\n    if (x < str1_length) {\n        int n1 = str1[x];\n        return print_char(n1);\n    }\n    \n    // Handle negative numbers\n    int is_negative = 0;\n    if (num < 0.) {        \n        // Print a minus sign\n        if (x == str1_length) return print_char(45);\n        \n        num = abs(num);\n        is_negative = 1;\n    }\n        \n    int digit_count = is_negative + max(1, log10(num)); // Number of characters before decimal point\n    int num_length  = digit_count + decimals + 1;       // Total number of characters for the number\n    int str2_start  = str1_length + num_length;\n    \n    // Print char from 2nd string (after number)\n    if (x >= str2_start) {\n        const int str2_length = str2.length() - 1;\n        int n2 = str2[x - str2_start];\n        if (x >= str2_start + str2_length) return 0.; // right bound\n        return print_char(n2);\n    }\n        \n    // Print the decmial separator (dot)\n    if (x == str1_length + digit_count) {\n        return print_char(46);\n    }\n    \n    // Get current digit\n    int digit_index = x - str1_length;\n    if (digit_index > digit_count) {\n        // Offset by 1 for digits located after the decimal point\n        digit_index--;\n    }\n    float exponent = float(digit_count - digit_index);\n    int n = 48 + int(10.*fract(num/.999999/pow(10., exponent)));\n        \n    // Print digit\n    return print_char(n);\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}