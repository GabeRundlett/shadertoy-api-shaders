{
    "Shader": {
        "info": {
            "date": "1723305286",
            "description": "Variation of https://www.shadertoy.com/view/NltBRB trading pre-computation for a lower evaluation cost.",
            "flags": 0,
            "hasliked": 0,
            "id": "XfffR8",
            "likes": 13,
            "name": "Faster Bezier Spline",
            "published": 3,
            "tags": [
                "bezier",
                "spline"
            ],
            "usePreview": 1,
            "username": "Zavie",
            "viewed": 169
        },
        "renderpass": [
            {
                "code": "//\n// Modified version of the spline proposed by Michele Matteini:\n// http://michelematteini.altervista.org/article/spline-texture-mapping\n//\n// The original shader evaluates the entire Bézier spline for each pixel.\n// This version uses a bounding box test to reduce the number of Bézier\n// curve evaluations.\n//\n// The bounding boxes and the length of the Bézier curve are pre-computed\n// first, and used during evaluation. This doesn't make a lot of difference\n// in this shader, but should reduce the evaluation cost in cases where the\n// spline is evaluated multiple times, like in a ray marching loop for\n// example.\n//\n\n#define ZERO min(0, iFrame)\n\n#define KNOT_COUNT 19\n\nvec4 splineAABB;\nvec4 splineSegmentAABBs[KNOT_COUNT / 2];\nfloat splineSegmentDistances[KNOT_COUNT / 2];\n\nvec2 spline[] = vec2[KNOT_COUNT](\n    vec2(0.00, 0.10),\n    vec2(0.20, 0.10),\n    vec2(0.20, 0.60),\n    vec2(0.20, 0.90),\n    vec2(0.40, 0.90),\n    vec2(0.60, 0.90),\n    vec2(0.60, 0.50),\n    vec2(0.60, 0.10),\n    vec2(0.80, 0.10),\n    vec2(1.60, 0.10),\n    vec2(1.60, 0.30),\n    vec2(1.60, 0.50),\n    vec2(1.10, 0.50),  \n    vec2(0.9, 0.50),\n    vec2(0.80, 0.70),\n    vec2(0.7, 0.95),\n    vec2(1.2, 0.7),\n    vec2(1.70, 0.4),\n    vec2(1.70, 0.9)\n);\n\n\nfloat Box(vec2 p, vec2 size, float corner)\n{\n   p = abs(p) - size + corner;\n   return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - corner;\n}\n\nfloat DistanceFromAABB(vec2 p, vec4 aabb)\n{\n    vec2 center = (aabb.xy + aabb.zw) / 2.0;\n    vec2 size = aabb.zw - aabb.xy;\n\n    return Box(p - center, size / 2.0, 0.0);\n}\n\nvec2 Bezier(vec2 A, vec2 B, vec2 C, float t)\n{\n    vec2 AB = mix(A, B, t);\n    vec2 BC = mix(B, C, t);\n    return mix(AB, BC, t);\n}\n\n// Roots of the cubic equation for the closest point to a bezier.\n// From: https://www.shadertoy.com/view/MdXBzB by tomkh\nvec4 FindCubicRoots(float a, float b, float c)\n{\n    float p = b - a * a / 3.0, p3 = p * p * p;\n    float q = a * (2.0 * a * a - 9.0 * b) / 27.0 + c;\n    float d = q * q + 4.0 * p3 / 27.0;\n    float offset = -a / 3.0;\n    if (d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x) * pow(abs(x), vec2(1.0, 1.0) / 3.0);\n        return vec4(offset + uv.x + uv.y, 0, 0, 1.0);\n    }\n\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v);\n    float n = sin(v) * sqrt(3.0);\n    return vec4(vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset, 3.0);\n}\n\n// Returns 1.0 if the two vector are clockwise sorted, -1.0 otherwise\nfloat GetWinding(vec2 a, vec2 b)\n{\n    return 2.0 * step(a.x * b.y, a.y * b.x) - 1.0;\n}\n\n// Returns the signed distance from a point to a bezier curve\n// Mostly from: https://www.shadertoy.com/view/MdXBzB by tomkh\nvec2 BezierSDF(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    float dotbb = dot(b, b);\n\n    vec3 k = vec3(3.0 * dot(a, b), 2. * dot(a, a) + dot(d, b), dot(d, a)) / dotbb;\n    vec4 t = FindCubicRoots(k.x, k.y, k.z);\n    vec2 tsat = clamp(t.xy, 0., 1.);\n\n    vec2 dp1 = d + (c + b * tsat.x) * tsat.x;\n    float d1 = dot(dp1, dp1);\n    vec2 dp2 = d + (c + b * tsat.y) * tsat.y;\n    float d2 = dot(dp2, dp2);\n\n    // Find closest distance and t\n    vec4 r = (d1 < d2) ? vec4(d1, t.x, dp1) : vec4(d2, t.y, dp2);\n\n    // Check the distance sign\n    float s = GetWinding(r.zw, 2.0 * b * r.y + c);\n    \n    return vec2(s * sqrt(r.x), r.y);\n}\n\n// Calc the length of a quadratic bezier at the start/end points and at the specified value for the parameter t.\n// X = length of the bezier up to \"t\" \n// Y = total length of the curve\nfloat BezierCurveLengthAt(vec2 A, vec2 B, vec2 C, float t)\n{\n    // Bezier curve function:\n    // f(t) = t^2(A - 2B + C) + t(2B - 2A) + A\n\n    // Calc the bezier curve derivative (velocity function):\n    // f'(t) = t(2A-4B+2C) + 2B - 2A = a1t + b1\n    vec2 a1 = 2.0 * (A - 2.0 * B + C);\n    vec2 b1 = 2.0 * (B - A);\n\n    // Calc the velocity function magnitude:\n    // ||f'(t)|| = sqrt(t^2 * k1 + t * k2 + k3)\n    float k1 = dot(a1, a1);\n    float k2 = 2.0 * dot(a1, b1);\n    float k3 = dot(b1, b1);\n\n    // Reparametrize for easier integration\n    // t^2k1 + tk2 + k3 = k1((t + k4)^2 + k5)\n    float k4 = 0.5 * k2 / k1;\n    float k5 = k3 / k1 - k4 * k4;\n\n    // Calculate the definite integrals of the velocity function to obtain the distance function\n    // solution to this integral form is from:\n    // https://en.wikipedia.org/wiki/List_of_integrals_of_irrational_functions\n    // S ||f'(t)|| dt = 0.5 * sqrt(k1) * [(k4 + t) * sqrt((t + k4)^2 + k5) + k5 ln(k4 + t + sqrt((t + k4)^2 + k5))]  \n    vec2 ti = vec2(0.0, t); // calc at both integration bounds at once\n    vec2 vt = sqrt((ti + k4) * (ti + k4) + k5);\n    vec2 sdft = sqrt(k1) * 0.5 * ((k4 + ti) * vt + k5 * log(abs(k4 + ti + vt)));\n    return sdft.y - sdft.x;\n}\n\n// Quadradic Bézier curve exact bounding box from IQ:\n// https://www.shadertoy.com/view/XdVBWd\nvec4 BezierAABB(vec2 A, vec2 B, vec2 C)\n{\n    // extremes\n    vec2 mi = min(A, C);\n    vec2 ma = max(A, C);\n\n    // maxima/minima point, if p1 is outside the current bbox/hull\n    if (B.x < mi.x || B.x > ma.x ||\n        B.y < mi.y || B.y > ma.y)\n    {\n        // p = (1-t)^2*p0 + 2(1-t)t*p1 + t^2*p2\n        // dp/dt = 2(t-1)*p0 + 2(1-2t)*p1 + 2t*p2 = t*(2*p0-4*p1+2*p2) + 2*(p1-p0)\n        // dp/dt = 0 -> t*(p0-2*p1+p2) = (p0-p1);\n\n        vec2 t = clamp((A - B) / (A - 2.0*B+C),0.0,1.0);\n        vec2 s = 1.0 - t;\n        vec2 q = s*s*A + 2.0*s*t*B + t*t*C;\n        \n        mi = min(mi, q);\n        ma = max(ma, q);\n    }\n    \n    return vec4(mi, ma);\n}\n\nfloat DistanceFromBezierAABB(vec2 p, vec2 A, vec2 B, vec2 C)\n{\n    vec4 aabb = BezierAABB(A, B, C);\n\n    vec2 center = (aabb.xy + aabb.zw) / 2.0;\n    vec2 size = aabb.zw - aabb.xy;\n\n    return Box(p - center, size / 2.0, 0.0);\n}\n\nvoid ComputeBezierSegmentsLengthAndAABB()\n{\n    float splineLength = 0.0;\n    splineAABB = vec4(1e6, 1e6, -1e6, -1e6);\n\n    for (int i = ZERO; i < KNOT_COUNT / 2; ++i)\n    {\n        int index = 2 * i;\n        vec2 A = spline[index + 0];\n        vec2 B = spline[index + 1];\n        vec2 C = spline[index + 2];\n        float segmentLength = BezierCurveLengthAt(A, B, C, 1.0);\n        splineSegmentDistances[i] = splineLength;\n        splineLength += segmentLength;\n\n        vec4 AABB = BezierAABB(A, B, C);\n        splineSegmentAABBs[i] = AABB;\n        splineAABB.xy = min(splineAABB.xy, AABB.xy);\n        splineAABB.zw = max(splineAABB.zw, AABB.zw);\n    }\n}\n\n// Decompose a give location into its distance from the closest point on the spline. \n// and the length of the spline up to that point.\n// Returns a vector where:\n// X = signed distance from the spline\n// Y = spline parameter t in the Bezier segment [0; 1]\n// Z = spline length at the closest point\n// W = spline segment index\n//\n// To get t of the entire spline:\n// (Y + 0.5 * W) / float(KNOT_COUNT)\n//\nvec4 ToSplineLocalSpace(vec2 p, float splineWidth)\n{\n    vec4 splineUV = vec4(1e6, 0, 0, 0);\n\n    if (DistanceFromAABB(p, splineAABB) > splineWidth)\n    {\n        return splineUV;\n    }\n\n    // For each bezier segment\n    for (int i = ZERO; i < KNOT_COUNT / 2; ++i)\n    {\n        int index = 2 * i;\n        vec2 A = spline[index + 0];\n        vec2 B = spline[index + 1];\n        vec2 C = spline[index + 2];\n\n        if (DistanceFromAABB(p, BezierAABB(A, B, C)) > splineWidth)\n        {\n            continue;\n        }\n\n        // This is to prevent 3 colinear points, but there should be better solution to it.\n        B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C))); \n        // Current bezier curve SDF\n        vec2 bezierSDF = BezierSDF(A, B, C, p);\n\n        if (abs(bezierSDF.x) < abs(splineUV.x))\n        {\n            float lengthInSegment = BezierCurveLengthAt(A, B, C, clamp(bezierSDF.y, 0., 1.));\n            float lengthInSpline = splineSegmentDistances[i] + lengthInSegment;\n            splineUV = vec4(\n                bezierSDF.x,\n                clamp(bezierSDF.y, 0., 1.),\n                lengthInSpline,\n                float(index));\n        }\n    }\n\n    return splineUV;\n}\n\n//\n// If you have a splineUV, call:\n// GetPositionOnSpline(splineUV.yw)\n//\nvec2 GetPositionOnSpline(vec2 spline_t_and_index)\n{\n    float t = spline_t_and_index.x;\n    int i = int(spline_t_and_index.y);\n    vec2 A = spline[i + 0];\n    vec2 B = spline[i + 1];\n    vec2 C = spline[i + 2];\n\n    return Bezier(A, B, C, t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ComputeBezierSegmentsLengthAndAABB();\n\n    vec2 uv = fragCoord /iResolution.y;\n    \n    float splineWidth = 0.05;\n\n    // Get the signed distance to bezier curve and calc an uv field\n    vec4 splineUV = ToSplineLocalSpace(uv, splineWidth);\n    splineUV.y = (splineUV.y + 0.5 * splineUV.w) / float(KNOT_COUNT);\n    \n    vec3 color = mix(vec3(0.5), fract(20.*splineUV).xyz, 0.2);\n    if (abs(splineUV.x) < splineWidth)\n    {\n        vec2 scaledUV = fract(splineUV.zx + vec2(fract(-0.2*iTime), splineWidth));\n\n        // Animate between UV and texture display\n        vec3 colorUV = vec3(scaledUV.xy, 0.);\n        color = mix(colorUV, texture(iChannel0, scaledUV).rgb, 0.25);\n    }\n\n\n    int example_i = int(2.0 * floor(fract(iTime * 0.1) * float(1 + KNOT_COUNT / 2))) - 2;\n    vec3 controlColor = vec3(0.8, 0.7, 0.0);\n    float AABBdistance;\n\n    if (example_i < 0)\n    {\n        // Show spline bounding box\n        AABBdistance = DistanceFromAABB(uv, splineAABB) - splineWidth;\n    }\n    else\n    {\n        // Show Bezier segment controls\n        for (int j = 0; j < 3; ++j)\n        {\n            float d = length(uv - spline[example_i + j]);\n            float dd = fwidth(d);\n            color *= smoothstep(-dd, dd, d - 0.015);\n            color = mix(color, (j % 2 == 0 ? controlColor : vec3(1.0)), 1.0 - smoothstep(-dd, dd, d - 0.01));\n        }\n\n        // Show bounding boxes\n        vec2 A = spline[example_i + 0];\n        vec2 B = spline[example_i + 1];\n        vec2 C = spline[example_i + 2];\n        AABBdistance = DistanceFromAABB(uv, splineSegmentAABBs[example_i / 2]) - splineWidth;\n    }\n\n    float dd = fwidth(AABBdistance);\n    float thickness = 0.005;\n\n    float outside = smoothstep(-dd, dd, AABBdistance);\n    float inside = smoothstep(-dd, dd, -AABBdistance - thickness);\n    float outline = 1.0 - inside - outside;\n\n    color *= mix(0.7, 1.0, inside);\n    color = mix(color, controlColor, outline);\n    //color = mix(color, controlColor, 0.2 * outside * fract(50.*AABBdistance));\n\n    fragColor = vec4(color, 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}