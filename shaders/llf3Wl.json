{
    "Shader": {
        "info": {
            "date": "1426094581",
            "description": "Playing around with distance-estimated 3D fractals",
            "flags": 0,
            "hasliked": 0,
            "id": "llf3Wl",
            "likes": 12,
            "name": "heyx3 Distance-estimated fractal",
            "published": 3,
            "tags": [
                "3d",
                "fractal",
                "distancefield"
            ],
            "usePreview": 0,
            "username": "heyx3",
            "viewed": 1921
        },
        "renderpass": [
            {
                "code": "//------Distance field--------\n\n//Returns the following values:\n//X: distance to the fractal.\n//Y: number of iterations needed, from 0 to 1.\n//Z: The 'r' value.\n//W: The 'dr' value.\nvec4 getDistanceToFractal(vec3 pos, float timeScale, float bailoutScale)\n{\n    const int Iterations = 7;\n    float Bailout = 2.0 * bailoutScale;\n    float powLerp = 0.5 + (0.5 * sin((iTime * timeScale) + 4.9));\n    float Power = mix(1.0, 8.0, pow(powLerp, 1.0));\n    \n    vec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    float nIterations = 0.0;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n        nIterations += 1.0;\n        \n\t\tif (r>Bailout)\n        {\n            break;\n        }\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta *= Power;\n\t\tphi *= Power;\n\t\tphi = (phi);\n        \n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn vec4(0.5*log(r)*r/dr,\n                nIterations / float(Iterations),\n                r,\n                dr);\n}\n\nmat3 rotPos2 = mat3(-0.7071067812, -0.7071067812, 0.0,\n                   \t0.70710678120, -0.7071067812, 0.0,\n                    0.0, \t\t   0.0, \t\t  1.0);\n//Returns the following values:\n//X: distance to the surface.\n//Y: number of iterations needed, from 0 to 1.\n//Z: The 'r' value.\n//W: The 'dr' value.\nvec4 getDistanceToSurface(vec3 pos)\n{\n    return getDistanceToFractal(pos, 1.0, 1.0);\n    vec4 first = getDistanceToFractal(pos, 1.0, 1.0),\n         second = getDistanceToFractal(pos, 1.04, 1.0);\n    if (first.x < -second.x) return first;\n    else return second;\n}\n\nvec3 getNormal(vec3 pos)\n{\n    const vec2 epsilon = vec2(0.0, 0.001);\n    \n    return normalize(vec3(getDistanceToSurface(pos + epsilon.yxx).x -\n                              getDistanceToSurface(pos - epsilon.yxx).x,\n                     \t  getDistanceToSurface(pos + epsilon.xyx).x -\n                              getDistanceToSurface(pos - epsilon.xyx).x,\n                     \t  getDistanceToSurface(pos + epsilon.xxy).x -\n                              getDistanceToSurface(pos - epsilon.xxy).x));\n}\n\n\n\n//-----Ray-marching---------\n\nstruct RayMarchData\n{\n    float moveDist;\n    vec3 hitPos;\n    float nIterations;\n    \n    float nFractalIterations;\n    float fractalR, fractalDR;\n};\n\n#define MAX_ITERATIONS 200\n#define MAX_ITERATIONS_F float(MAX_ITERATIONS)\n    \n#define DISTANCE_EPSILON 0.00001\n\n//Performs the ray-marching algo. Returns whether something was hit.\nbool marchRay(out RayMarchData dat, vec3 rayStart, vec3 rayDir)\n{\n    dat.hitPos = rayStart;\n    dat.nIterations = 0.0;\n    vec4 distData;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i)\n    {\n        dat.nIterations += 1.0;\n        distData = getDistanceToSurface(dat.hitPos);\n        \n        if (distData.x < DISTANCE_EPSILON)\n        {\n            dat.nFractalIterations = distData.y;\n            dat.nIterations /= float(MAX_ITERATIONS);\n            dat.fractalR = distData.z;\n            dat.fractalDR = distData.w;\n            return true;\n        }\n        \n        dat.hitPos += (distData.x * rayDir);\n        dat.moveDist += distData.x;\n    }\n    \n    dat.nIterations /= float(MAX_ITERATIONS);\n    return false;\n}\n\n\n\n//-----------Main------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //Cam data.\n    float distFromCenter = 2.5 + (0.0000 * sin(1.8 * iTime));\n    const float camRotSpeed = 0.25;\n    vec3 camForward = normalize(vec3(cos((camRotSpeed * iTime) + (iMouse.x / iResolution.x * -8.0)),\n                                     sin((camRotSpeed * iTime) + (iMouse.x / iResolution.x * -8.0)),\n                                     mix(-1.5, 1.5, iMouse.y / iResolution.y))),\n         camPos = distFromCenter * -camForward,\n         camUp = vec3(0.0, 0.0, 1.0),\n         camSide = cross(camForward, camUp);\n    camUp = cross(camSide, camForward);\n    \n    \n    //Ray data.\n    const float fovScale = 1.0;\n    vec2 uvNormalized = -1.0 + (2.0 * uv);\n    vec3 rayStart = camPos + (camForward * fovScale) +\n        \t\t\t(camSide * uvNormalized.x) +\n        \t\t\t(camUp * uvNormalized.y * (iResolution.y / iResolution.x));\n    vec3 rayDir = normalize(rayStart - camPos);\n    \n     \n    //Ray-march through the scene.\n    RayMarchData dat;\n    bool hit = marchRay(dat, rayStart, rayDir);\n    \n    //Color the scene.\n    if (hit)\n    {\n        float val = 1.0 - smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, pow(dat.nIterations, 0.25)));\n        //float val = pow(dat.fractalR, 0.25);\n        fragColor.xyz = vec3(val);\n        \n        //fragColor.xyz = fract(dat.hitPos * 2.0);\n        //fragColor = texture(iChannel0, vec2(val, iTime * 0.1));\n        //fragColor = vec4(dat.hitPos * pow(val, 0.5), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(texture(iChannel1, rayDir.xzy).xyz, 1.0);\n    }\n    \n    \n    //Some debug-logging color outputs.\n    //fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    //fragColor = vec4(0.5 + (0.5 * getNormal(dat.hitPos)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}