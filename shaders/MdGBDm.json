{
    "Shader": {
        "info": {
            "date": "1529065766",
            "description": "Build random  mazes",
            "flags": 32,
            "hasliked": 0,
            "id": "MdGBDm",
            "likes": 8,
            "name": "Maze Builder",
            "published": 3,
            "tags": [
                "maze",
                "puzzle"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 542
        },
        "renderpass": [
            {
                "code": "// \"Maze Builder\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Build random \"perfect\" mazes (click upper right to restart,\n    else automatic).\n  See https://github.com/thejoshwolfe/maze-generator\n    (\"ivy\" method - just like the plant).\n  Same idea (different implementation) in \"Basic Maze Generator\" by stb.\n  Cell grid (blue) used for building; one random maze wall segment (black)\n    per cell; red lines (0-3) complete wall segments; maze paths are green,\n    or white adjacent to interior walls.\n  Construction is intentionally slow.\n*/\n\nvec2 Rot2D (vec2 q, float a);\nvec4 Loadv4 (vec2 vId);\n\nconst float pi = 3.14159;\n\nfloat WallDst (vec2 p, float a)\n{\n  p = 0.5 - ((a < 0.) ? vec2 (0.) : fract (Rot2D (p, 0.5 * pi * a)));\n  return max (abs (p.x), p.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 col;\n  vec2 canvas, ut, utt, gSize, e;\n  float dw, dww, s;\n  canvas = iResolution.xy;\n  gSize = Loadv4 (vec2 (0.)).yz;\n  ut = fragCoord * gSize / canvas;\n  s = Loadv4 (floor (ut)).x;\n  dw = WallDst (ut, (s >= 0.) ? s : -1.);\n  col = mix (vec3 (0.), vec3 (1.), step (0.09, dw));\n  dww = dw;\n  for (float ai = 0.; ai < 4.; ai ++) {\n    e = vec2 (0., 1.);\n    e = (ai < 2.) ? ((ai == 0.) ? e : e.yx) : ((ai == 2.) ? - e : - e.yx);\n    if (Loadv4 (floor (ut) - e).x == ai) dw = min (dw, WallDst (ut, mod (ai + 2., 4.)));\n  }\n  if (dw < dww && dww >= 0.09) col = mix (vec3 (1., 0., 0.), vec3 (1.), step (0.09, dw));\n  col = mix (col, vec3 (0., 1., 0.), step (0.33, dw));\n  if (canvas.x >= 256.) {\n    utt = abs (fract ((fragCoord / canvas) * gSize));\n    col = mix (vec3 (0.5, 0.5, 1.), col, smoothstep (1.5, 2., min (utt.x, utt.y) * 1000. / gSize.x));\n  }\n  utt = abs (ut - 0.5 * gSize) - 0.5 * gSize;\n  if (max (utt.x, utt.y) > -0.45) col = vec3 (0., 1., 0.);\n  fragColor = vec4 (col, 1.);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Maze Builder\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Hashfv2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec2 canvas, iFrag, gSize, e;\n  float tCur, nStep, growInt, ai, ar;\n  bool init;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  gSize = vec2 (16., 9.) * ((canvas.x >= 256.) ? 2. : 1.);\n  if (fragCoord.x >= txSize.x || fragCoord.y >= txSize.y) discard;\n  iFrag = floor (fragCoord);\n  growInt = 30.;\n  init = (iFrame <= 5 || mPtr.z > 0. && max (mPtr.x, mPtr.y) > 0.45);\n  if (! init) {\n    nStep = Loadv4 (vec2 (0., 0.)).w;\n    init = (mod (nStep + 1., 400.) == 0.);\n  }\n  ar = -1.;\n  if (init) {\n    nStep = 0.;\n    if (iFrag.y == 0. || iFrag.y == gSize.y - 1.) ar = 1.;\n    else if (iFrag.x == 0.) ar = (iFrag.y >= 2.) ? 0. : 2.;\n    else if (iFrag.x == gSize.x - 1.) ar = (iFrag.y >= gSize.y - 2.) ? 0. : 2.;\n  } else {\n    ar = texture (txBuf, fragCoord / txSize).x;\n    if (nStep < 2. * max (gSize.x, gSize.y)) {\n      if (mod (float (iFrame), growInt) == 0. && ar < 0.) {\n        ai = floor (4. * Hashfv2 (iFrag + tCur));\n        e = vec2 (0., 1.);\n        e = (ai < 2.) ? ((ai == 0.) ? e : e.yx) : ((ai == 2.) ? - e : - e.yx);\n        if (texture (txBuf, (fragCoord + e) / txSize).x >= 0.) ar = ai;\n      }\n    }\n    if (mod (float (iFrame), growInt) == 0.) ++ nStep;\n  }\n  fragColor.x = ar;\n  if (iFrag.y == 0. && iFrag.x == 0.) fragColor.yzw = vec3 (gSize, nStep);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}