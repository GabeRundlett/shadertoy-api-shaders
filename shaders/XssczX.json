{
    "Shader": {
        "info": {
            "date": "1489150642",
            "description": "Loosely inspired by an Escher sketch. I had a nice anti-aliasing going on at some point (see line 428) but it was too expensive for this shader. Click the screen to rotate the camera!",
            "flags": 0,
            "hasliked": 0,
            "id": "XssczX",
            "likes": 138,
            "name": "Moebius Ants",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "escher",
                "toon",
                "insect",
                "leg",
                "reproduction"
            ],
            "usePreview": 1,
            "username": "Klems",
            "viewed": 6029
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define SOFT_STEPS 16\n#define RAYS_STEPS 100\n\n// uncomment this to show a closeup of the ant\n// #define SHOW_ANT\n\n// hopefully this should compile to a const mat2\n#define rot_const(a) (mat2(cos(a), sin(a), -sin(a), cos(a)))\n\n// Fabrice's rotation matrix\nmat2 rot( in float a ) {\n    vec2 v = sin(vec2(PI*0.5, 0) + a);\n    return mat2(v, -v.y, v.x);\n}\n\n// Dave Hoskins hash function\nvec3 hash33( in vec3 p3 ) {\n    #define HASHSCALE3 vec3(.1031, .1030, .0973)\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// iq's functions\nfloat sdBox( in vec3 p, in vec3 b ) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) {\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\nfloat smin( in float a, in float b, in float s ) {\n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0.0, 1.0 );\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\nfloat smax( in float a, in float b, in float s ) {\n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0.0, 1.0 );\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n// intersection of 2 circles, by eiffie (used for the legs IKs)\nvec2 intersect(vec3 c0, vec3 c1) {\n    vec2 dxy = vec2(c1.xy - c0.xy);\n    float d = length(dxy);\n    float a = (c0.z*c0.z - c1.z*c1.z + d*d)/(2.*d);\n    vec2 p2 = c0.xy + (a / d)*dxy;\n    float h = sqrt(c0.z*c0.z - a*a);\n    vec2 rxy = vec2(-dxy.y, dxy.x) * (h/d);\n    return p2 + rxy;\n}\n\n// ant's legs distance function\nfloat deAntLeg(in vec3 p, in vec3 anchor, in vec3 legStart,\n               in float lenStart, in vec3 legEnd, in float lenEnd) {\n    \n\t// express coordinates from the starting leg\n    vec3 inLeg = p - legStart;\n    vec3 legEndInStart = legEnd - legStart;\n    // express coordinates in the leg plane\n    vec3 xDir = normalize(vec3(legEnd.xy - legStart.xy, 0));\n    vec2 planar = vec2(dot(inLeg, xDir), inLeg.z);\n    vec2 endInPlanar = vec2(dot(legEndInStart, xDir), legEndInStart.z);\n    \n    // get intersection\n    vec2 jointPlanar = intersect( vec3(0, 0, lenStart), vec3(endInPlanar, lenEnd) );\n    // go back to 3D space\n    vec3 joint = legStart + xDir*jointPlanar.x + vec3(0, 0, 1)*jointPlanar.y;\n    \n    float d = sdCapsule( p, anchor, legStart, 0.03 );\n    d = smin(d, sdCapsule( p, legStart, joint, 0.02 ), 0.02);\n    d = smin(d, sdCapsule( p, joint, legEnd, 0.015 ), 0.02);\n    return d;\n    \n}\n\n// ant distance function, phase is the animation (between 0 and 1)\nfloat deAnt( in vec3 p, in float phase, out vec3 color1, out vec3 color2, out float roughness ) {\n    \n    color1 = vec3(0.90, 0.18, 0.01);\n    color2 = vec3(0.35, 0.10, 0.01);\n    roughness = 12.0;\n    \n    p = p.zyx;\n    \n    // bounding box optimization\n    float bb = sdBox(p, vec3(1.1, 0.5, 0.5));\n    if (bb > 0.5) {\n        return bb;\n    }\n    \n    p -= vec3(-0.05, 0, 0.75);\n    \n    // 3 parts for the ant\n    const vec2 slopeCenter = vec2(0.4, 0.8);\n    vec2 inSlope = slopeCenter - p.xz;\n    float slope = atan(inSlope.y, inSlope.x);\n    slope /= PI;\n    float part = clamp(floor(slope * 10.0), 3.0, 5.0);\n    slope = (part + 0.5) / 10.0;\n    slope *= PI;\n    vec2 center = slopeCenter - vec2(cos(slope), sin(slope)) * 1.6;\n    vec3 partCenter = vec3(center.x, 0.0, center.y);\n    \n    vec3 inPart = p - partCenter;\n    float side = sign(inPart.y);\n    inPart.y = abs(inPart.y);\n    \n    float dist = bb;\n    \n    if (part > 4.5) {\n        \n        // rotation\n        inPart.x += 0.3;\n        float r = sin(phase*2.0*PI)*0.05;\n        inPart.xz *= rot(r-0.1);\n        inPart.x -= 0.3;\n        \n        // abdomen\n        inPart -= vec3(0.33, 0.0, -0.02);\n        float radius = 0.1 + smoothstep(-0.2, 0.7, -inPart.x) * 0.5;\n        \n        // add ridges\n        float s = cos(-inPart.x*40.0)*0.5+0.5;\n        s *= s; s *= s;\n        radius -= s*0.005;\n        \n        dist = length(inPart) - radius;\n        float sMix = pow(s, 8.0);\n        color1 = mix(vec3(0.1, 0.05, 0.01), vec3(0.6, 0.5, 0.4), sMix);\n        color2 = mix(vec3(0.05, 0.02, 0.01), vec3(0.5, 0.4, 0.2), sMix);\n        roughness = 16.0 - s*12.0;\n        \n    } else if (part > 3.5) {\n        \n        // thorax\n        inPart += vec3(0.02, 0.0, -0.05);\n        inPart.xz *= rot_const(-0.3);\n        \n        // pronotum\n        vec3 inThoraxA = inPart - vec3(-0.13, 0.0, 0.05);\n        float radiusA = 0.10 + smoothstep(-0.1, 0.5, inThoraxA.x) * 0.2;\n        radiusA -= smoothstep(-0.1, 0.2, inThoraxA.z) * 0.1;\n        float thoraxDistA = length(inThoraxA) - radiusA;\n        \n        // propodeum\n        vec3 inThoraxB = inPart - vec3(0.06, 0.0, 0.03);\n        float radiusB = 0.05 + smoothstep(-0.1, 0.4, inThoraxB.x) * 0.2;\n        radiusB -= smoothstep(-0.1, 0.4, inThoraxA.z) * 0.1;\n        float thoraxDistB = length(inThoraxB) - radiusB;\n        dist = smin(thoraxDistA, thoraxDistB, 0.05);\n        \n        // petiole\n        vec3 inThoraxC = inPart - vec3(0.24, 0.0, 0.0);\n        float radiusC = 0.05 - smoothstep(-0.1, 0.2, inThoraxC.z-inThoraxC.x*0.3) * 0.04;\n        float thoraxDistC = sdCapsule( inThoraxC, vec3(0), vec3(-0.03, 0, 0.11), radiusC);\n        dist = smin(dist, thoraxDistC, 0.03);\n        \n        // add ridges\n        vec3 inRidges = inPart - vec3(0.01, 0.0, 0.1);\n        float ridgesDist = abs(length(inRidges) - 0.12);\n        dist += smoothstep(0.02, 0.0, ridgesDist) * 0.004;\n        \n    } else if (part > 2.5) {\n        \n        // head\n        inPart -= vec3(-0.09, 0.0, -0.06);\n        inPart.xz *= rot_const(0.3);\n        float radius = 0.07 + smoothstep(-0.15, 0.4, inPart.x) * 0.3;\n        radius -= smoothstep(0.0, 0.4, abs(inPart.z))*0.2;\n        dist = length(inPart) - radius;\n        \n        // frontal carina\n        vec3 inCarina = inPart - vec3(0.02, 0.0, 0.09);\n        inCarina.xy *= rot_const(-0.4);\n        inCarina.xz *= rot_const(0.1);\n        float carina = sdBox( inCarina, vec3(0.1, 0.05, 0.01) ) - 0.01;\n        dist = smin(dist, carina, 0.05);\n        \n        // antenna\n        vec3 inAntenna = inPart - vec3(-0.03, 0.1, 0.1);\n        inAntenna.yz *= rot_const(-0.4);\n        inAntenna.xz *= rot(sin((phase+side*0.25)*2.0*PI)*0.3-0.2);\n        const vec3 funiculusStart = vec3(0, 0, 0.3);\n        float scapeRadius = 0.007 + inAntenna.z*0.04;\n        float scape = sdCapsule( inAntenna, vec3(0), funiculusStart, scapeRadius );\n        vec3 funiculusDir = normalize(vec3(-0.5, 0.0, -0.1));\n        funiculusDir.xz *= rot(sin((phase+side*0.25)*4.0*PI)*0.2);\n        float funiculusRadius = dot(funiculusDir, inAntenna - funiculusStart);\n        funiculusRadius = abs(sin(funiculusRadius*67.0));\n        funiculusRadius = 0.01 + funiculusRadius*0.004;\n        float funiculus = sdCapsule(inAntenna, funiculusStart, \n                                    funiculusStart+funiculusDir*0.5, funiculusRadius );\n        float antennaDist = min(scape, funiculus);\n        dist = min(dist, antennaDist);\n        \n        // mandibles\n        vec3 inMandibles = inPart;\n        inMandibles.xy *= rot(sin(phase*4.0*PI)*0.1-0.1);\n        float mandiblesOuter = sdEllipsoid( inMandibles, vec3(0.25, 0.14, 0.1) );\n        float mandiblesInner = sdEllipsoid( inMandibles, vec3(0.15, 0.1, 0.4) );\n        float mandibles = smax(mandiblesOuter, -mandiblesInner, 0.05);\n        mandibles = smax(mandibles, 0.005-inMandibles.y+sin(inMandibles.x*300.0)*0.005, 0.01);\n        dist = smin(dist, mandibles, 0.05);\n        \n        // eyes\n        float eyes = sdEllipsoid( inPart - vec3(0.21, 0.15, 0.03), vec3(0.06, 0.05, 0.05 ) );\n        if (eyes < dist) {\n            color1 = color2 = vec3(0.05);\n            roughness = 32.0;\n            dist = eyes;\n        }\n\n    }\n    \n    // add a capsule in the center to connect the parts\n    float connector = sdCapsule( p, vec3(-0.15, 0, -0.63), vec3(0.5, 0, -0.83), 0.03);\n    dist = min(dist, connector);\n    \n    // add legs\n    vec3 inLegs = p;\n    inLegs.y = abs(inLegs.y);\n    phase += side*0.25;\n    \n    float angleA = (phase)*PI*2.0;\n    vec3 legAOffset = vec3(cos(angleA), 0, max(0.0, sin(angleA)))*0.2;\n    float legA = deAntLeg(inLegs, vec3(0.05, 0.0, -0.75),\n                          vec3(0.1, 0.1, -0.82), 0.25, \n                          vec3(-0.2, 0.4, -1.2)+legAOffset, 0.5);\n    float angleB = (phase+0.33)*PI*2.0;\n    vec3 legBOffset = vec3(cos(angleB), 0, max(0.0, sin(angleB)))*0.2;\n    float legB = deAntLeg(inLegs, vec3(0.18, 0.0, -0.8),\n                          vec3(0.2, 0.1, -0.85), 0.3, \n                          vec3(0.3, 0.5, -1.2)+legBOffset, 0.6);\n    float angleC = (phase+0.66)*PI*2.0;\n    vec3 legCOffset = vec3(cos(angleC), 0, max(0.0, sin(angleC)))*0.2;\n    float legC = deAntLeg(inLegs, vec3(0.25, 0.0, -0.8),\n                          vec3(0.3, 0.1, -0.85), 0.4, \n                          vec3(0.6, 0.4, -1.2)+legCOffset, 0.7);\n    \n    float distLegs = min(min(legA, legB), legC);\n    if (distLegs < dist) {\n        color1 = vec3(0.35, 0.10, 0.01);\n        color2 = vec3(0.05, 0.02, 0.01);\n        dist = distLegs;\n    }\n    \n    return dist;\n}\n\n// main distance function, coordinates in, distance and surface parameters out\nfloat de( in vec3 p, out vec3 color1, out vec3 color2, out float roughness ) {\n    \n    color1 = vec3(0.7);\n    color2 = vec3(0.7);\n    roughness = 4.0;\n    \n    #ifdef SHOW_ANT\n    return deAnt(p.zxy, fract(iTime), color1, color2, roughness);\n    #endif\n    \n    // perimeter of the moebius strip is 38\n    #define RADIUS (1.0/(PI*2.0)*38.0)\n    \n    // cylindrical coordinates\n    vec2 cyl = vec2(length(p.xy), p.z);\n    float theta = atan(p.x, p.y);\n    vec2 inCyl = vec2(RADIUS, 0) - cyl;\n    // rotate 180° to form the loop\n    inCyl *= rot(theta*1.5-2.0);\n    // coordinates in a torus (cylindrical coordinates + position on the stripe)\n    vec3 inTor = vec3(inCyl, theta * RADIUS);\n    \n    // add the band\n    float bandDist = sdBox(inTor, vec3(0.05, 1, 100)) - 0.05;\n    float d = bandDist;\n    // add holes\n    vec3 inHole = vec3(mod(inTor.yz, vec2(0.5)) - vec2(0.25), inTor.x);\n    inHole.xyz = inHole.zxy;\n    float holeDist = sdBox(inHole, vec3(0.18));\n    d = smax(d, -holeDist, 0.05);\n    \n    // add ants\n    vec3 inTorObj = vec3(abs(inTor.x), inTor.y, inTor.z + iTime*1.3 + sign(inTor.x));\n    float ant = floor(inTorObj.z / 4.0);\n    vec3 objCenter = vec3(0.6, 0, ant * 4.0 + 2.0);\n    float phase = fract(iTime) + mod(ant, 9.0) / 9.0;\n    vec3 antColor1 = vec3(0.0);\n    vec3 antColor2 = vec3(0.0);\n    float antRoughness = 0.0;\n    float antDist = deAnt(inTorObj-objCenter, phase, antColor1, antColor2, antRoughness);\n    if (antDist < d) {\n        color1 = antColor1;\n        color2 = antColor2;\n        roughness = antRoughness;\n        return antDist;\n    }\n    \n\treturn d;\n}\n\nfloat de( in vec3 p ) {\n    vec3 dummy1 = vec3(0);\n    vec3 dummy2 = vec3(0);\n    float dummy3 = 0.0;\n    return de(p, dummy1, dummy2, dummy3);\n}\n\n// normal from backward difference\nvec3 computeNormal( in vec3 p, in float d ) {\n\tconst vec3 e = vec3(0.0, 0.01, 0.0);\n\treturn normalize(vec3(\n\t\td-de(p-e.yxx),\n\t\td-de(p-e.xyx),\n\t\td-de(p-e.xxy)));\t\n}\n\n// cone trace the soft shadows\nfloat computeSoftShadows( in vec3 from, in vec3 dir, in float theta ) {\n    float sinTheta = sin(theta);\n    float acc = 1.0;\n    float totdist = 0.0;\n    for (int i = 0 ; i < SOFT_STEPS ; i++) {\n        vec3 p = from + totdist * dir;\n        float dist = de(p);\n        float prox = dist / (totdist*sinTheta);\n        acc *= clamp(prox * 0.5 + 0.5, 0.0, 1.0);\n        if (acc < 0.01) break;\n        totdist += max(0.01, dist*0.85);\n    }\n    return acc;\n}\n\n// compute lighting at this position\nvec3 computeColor( in vec3 p, in vec3 dir, in vec2 fragCoord ) {\n    \n    // sunlight and ambient\n    const vec3 sunLight = vec3(0.9, 0.8, 0.6)*9.0;\n    const vec3 sunLightDir = normalize(vec3(-2, -1, 3));\n    const vec3 subLight = vec3(0.4, 0.4, 0.8)*3.0;\n    const vec3 subLightDir = normalize(vec3(2, -1, -8));\n    const vec3 ambLight = vec3(0.7, 0.7, 0.9)*4.0;\n    \n    // compute distance to get the surface albedo\n    vec3 albedo1 = vec3(0);\n    vec3 albedo2 = vec3(0);\n    float roughness = 0.0;\n    float dist = de(p, albedo1, albedo2, roughness);\n    \n    // compute surface normal\n    vec3 normal = computeNormal(p, dist);\n    \n    float specScale = (roughness+1.0)*0.25;\n    float sunLightDiff = max(0.0, dot(normal, sunLightDir));\n    float sunLightSpec = pow(max(0.0, dot(sunLightDir, reflect(dir, normal))), roughness);\n    sunLightSpec *= specScale;\n    float subLightDiff = max(0.0, dot(normal, subLightDir));\n    float subLightSpec = pow(max(0.0, dot(subLightDir, reflect(dir, normal))), roughness);\n    subLightSpec *= specScale;\n    \n   \t// soft shadows\n    float soft = 0.0;\n    if (sunLightDiff > 0.01) {\n        soft = computeSoftShadows(p+normal*0.05, sunLightDir, 0.2);\n    }\n    \n    // fake subsurface scattering\n    float subsurface = max(0.0, dot(normal, -dir));\n    subsurface = pow(subsurface, 4.0);\n    vec3 albedo = mix(albedo2, albedo1, subsurface);\n    \n    // do some arty sketchy stuff on the light\n    float sun = (sunLightDiff+sunLightSpec)*soft;\n    float sub = (subLightDiff+subLightSpec);\n    float amb = 1.0;\n    vec3 lightValues = vec3(sun, sub, amb);\n    \n    // exposition\n    lightValues *= 0.06;\n    // gamma correction\n    lightValues = pow( lightValues, vec3(1.0/2.2) );\n    // cel shading\n    lightValues = floor(lightValues * 7.0) / 6.0;\n    \n    // compose color\n    vec3 color = vec3(0);\n    color += albedo*sunLight*lightValues.x;\n    color += albedo*subLight*lightValues.y;\n    color += albedo*ambLight*lightValues.z;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    // position of the camera\n    vec3 camPos = vec3(-40, 0, 0);\n    // user input\n    vec2 mouse=(iMouse.xy / iResolution.xy - 0.5) * 0.5;\n    mouse *= step(1.0, iMouse.z);\n    camPos.xz *= rot(mouse.y*-3.0+0.4);\n    camPos.xy *= rot(mouse.x*-10.0+0.2);\n    \n    // direction of the camera\n    vec3 forward = normalize(vec3(0) - camPos);\n    // right and top vector\n    vec3 right = normalize(cross(vec3(0, 0, 1), forward));\n    vec3 top = cross(forward, right);\n    \n    // create direction\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.y *= iResolution.y / iResolution.x;\n    uv *= 0.2;\n    #ifdef SHOW_ANT\n    uv *= 0.2;\n    #endif\n    vec3 dir = normalize(forward + right*uv.x + top*uv.y);\n    \n    // some noise is always useful\n    vec3 noise = hash33(vec3(fragCoord.xy, iFrame));\n    \n    bool hit = false;\n    float prevDist = 0.0;\n    float borderAcc = 1.0;\n    \n    float totdist = 0.0;\n    totdist += de(camPos)*noise.x;\n    \n\tfor (int i = 0 ; i < RAYS_STEPS ; i++) {\n\t\tvec3 p = camPos + totdist * dir;\n        float dist = de(p);\n        \n// if you replace 0.0015 by the sine of the pixel angle, you get the average opacity in a pixel\n// by accumulating the opacity front to back you can get an anti-aliased edge\n// problem is you have to compute the normal to shade the surface and get the effective color\n// computing the normal at every steps is too expensive (unless the normal is analytical)\n// nonetheless the border color is constant so we can cone trace it without any trouble\n        \n        // cone trace the border\n        if (dist > prevDist) {\n            float prox = dist / (totdist*0.0015);\n            float alpha = clamp(prox * 0.5 + 0.5, 0.0, 1.0);\n            borderAcc *= alpha;\n        }\n        \n        // hit a surface, stop here\n        if (dist < 0.01) {\n            hit = true;\n            break;\n        }\n        \n        // continue forward\n        totdist += min(dist*0.85, 100.0);\n        prevDist = dist;\n\t}\n    \n    // color and lights\n    if (hit) {\n        vec3 p = camPos + totdist * dir;\n    \tfragColor.rgb = computeColor(p, dir, fragCoord.xy);\n    } else {\n        fragColor.rgb = vec3(0.8, 0.8, 0.9);\n    }\n    \n    // add a black border\n    borderAcc = pow(borderAcc, 8.0);\n    fragColor.rgb = mix(vec3(0), fragColor.rgb, borderAcc);\n    \n    // vigneting\n    vec2 p = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), dot(p, p)*0.2);\n\t\n    // add some noise\n    fragColor.rgb += noise * 0.08 - 0.04;\n    \n    fragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}