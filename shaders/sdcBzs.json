{
    "Shader": {
        "info": {
            "date": "1657016120",
            "description": "Walkers with lights",
            "flags": 0,
            "hasliked": 0,
            "id": "sdcBzs",
            "likes": 13,
            "name": "Walkers 2",
            "published": 3,
            "tags": [
                "gait",
                "quadruped",
                "lightbeam"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 285
        },
        "renderpass": [
            {
                "code": "// \"Walkers 2\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  1   // (= 0/1) optional antialiasing\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_WLK 2\n\nvec3 sunDir, qHit, wPos;\nfloat tCur, dstFar, spd;\nint idObj;\nconst int idLeg = 1, idAx = 2, idFoot = 3, idPlat = 4, idTur = 5, idMnt = 6, idBrl = 7;\nbool isSh;\nconst float pi = 3.1415927;\n\nstruct Leg {\n  vec2 cs1, cs2, cs3;\n};\n\nstruct Walker {\n  Leg leg[4];\n  vec3 wPos, ltPos, bmAx;\n  vec2 csTur, csBrl;\n};\nWalker wlk[N_WLK];\n\nvec3 szLeg;\nvec2 bmCs, brlPiv;\nfloat hPlat, bLen, bWid;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid SetWlkConf ()\n{\n  vec2 e;\n  float sDir, tc, t, tH, tt, tV, limT, fUp, limEx, a1, a2, fh;\n  szLeg = vec3 (0.06, 0.15, 2.);\n  bWid = 1.5;\n  bLen = 1.5;\n  tH = 0.01;\n  tV = 0.3;\n  limT = 0.2;\n  limEx = 0.997;\n  fUp = 1.;\n  hPlat = 4. * limEx * szLeg.z * cos (atan (limT));\n  bmCs = sin (-0.015 * pi + vec2 (0.5 * pi, 0.));\n  brlPiv = vec2 (1.5, -1.4);\n  e = vec2 (1., -1.);\n  for (int j = 0; j < N_WLK; j ++) {\n    tc = tCur * spd / (hPlat * limT * 2. / 3.);\n    for (int k = 0; k < 4; k ++) {\n      t = mod (tc + float (k), 4.);\n      if (t > 1.) {\n        sDir = -1.;\n        t = (t - 1.) / 3.;\n      } else sDir = 1.;\n      tt = 0.5 - abs (t - 0.5);\n      a1 = atan (limT * (((tt < tH) ? tt * tt / tH : 2. * tt - tH) / (1. - tH) - 1.) *\n         sign (0.5 - t) * sDir);\n      fh = hPlat;\n      if (sDir > 0.) fh -= fUp * smoothstep (0., tV, tt);\n      fh *= 0.5 / cos (a1);\n      a2 = acos (0.5 * fh / szLeg.z);\n      wlk[j].leg[k].cs1 = sin (-0.5 * pi + a1 + a2 + vec2 (0.5 * pi, 0.));\n      wlk[j].leg[k].cs2 = sin (-2. * a2 + vec2 (0.5 * pi, 0.));\n      wlk[j].leg[k].cs3 = sin (0.5 * pi - a1 + a2 + vec2 (0.5 * pi, 0.));\n    }\n    wlk[j].csTur = sin (0.3 * pi * (2. * SmoothBump (0.25, 0.75, 0.25,\n       fract (0.08 * tCur)) - 1.) - pi + vec2 (0.5 * pi, 0.));\n    wlk[j].csBrl = sin (-0.03 * pi * (2. * SmoothBump (0.25, 0.75, 0.25,\n       fract (0.2 * tCur)) - 1.) + 0.08 * pi + vec2 (0.5 * pi, 0.));\n    wlk[j].wPos = wPos - vec3 (6. * float (2 * j - N_WLK + 1), 0., 0.);\n    wlk[j].ltPos = vec3 (0., hPlat, 0.) + vec3 (0., brlPiv);\n    wlk[j].ltPos.yz = Rot2Cs (wlk[j].ltPos.yz, wlk[j].csBrl * e);\n    wlk[j].ltPos.xz = Rot2Cs (wlk[j].ltPos.xz, wlk[j].csTur * e);\n    wlk[j].ltPos += wlk[j].wPos;\n    wlk[j].bmAx = vec3 (0., 0., -1.);\n    wlk[j].bmAx.yz = Rot2Cs (wlk[j].bmAx.yz, wlk[j].csBrl * e);\n    wlk[j].bmAx.xz = Rot2Cs (wlk[j].bmAx.xz, wlk[j].csTur * e);\n  }\n}\n\nfloat WlkDf (vec3 p, float dMin, Walker wk)\n{\n  vec3 q;\n  float d, qz;\n  p.y -= hPlat;\n  q = p;\n  q.y -= 0.3;\n  d = SmoothMax (-1.6 * bWid + dot (vec2 (length (q.xz), abs (q.y)),\n     sin (0.2 * pi +  vec2 (0.5 * pi, 0.))), abs (q.y) - 0.35, 0.02);\n  d = max (d, - max (PrRoundBox2Df (vec2 (abs (q.xz - vec2 (0., 0.1)) - vec2 (bWid, bLen)),\n     vec2 (0.1, 0.3), 0.05), q.y - 0.3));\n  DMINQ (idPlat);\n  q.y -= 1.25;\n  q.xz = Rot2Cs (q.xz, wk.csTur);\n  q.xz = vec2 (q.z, - q.x);\n  if (length (q.xz) > 0.) q.xz = Rot2D (q.xz, 2. * pi * (floor (7. * atan (q.z, - q.x) /\n     (2. * pi) + 0.5) / 7.));\n  d = SmoothMax (-1.3 - dot (vec2 (q.x, abs (q.y)), sin (-0.15 * pi + vec2 (0.5 * pi, 0.))),\n     abs (q.y) - 0.82, 0.02);\n  DMINQ (idTur);\n  q = p;\n  q.xz = Rot2Cs (q.xz, wk.csTur);\n  q.yz = Rot2Cs (q.yz - brlPiv, wk.csBrl);\n  d = length (q) - 0.3;\n  DMINQ (idMnt);\n  q.z -= -0.8;\n  d = PrCylDf (q, 0.2, 0.8);\n  DMINQ (idBrl);\n  q = p;\n  q.xz = abs (q.xz) - vec2 (bWid, bLen);\n  q.y -= szLeg.y;\n  d = PrCylDf (q.yzx, 1.4 * szLeg.y, 3. * szLeg.x);\n  DMINQ (idAx);\n  for (int k = 0; k < 4; k ++) {\n    q = p;\n    q.xz += vec2 (bWid * ((k == 0 || k == 1) ? -1. : 1.), bLen * ((k == 1 || k == 3) ? -1. : 1.));\n    q.y -= szLeg.y;\n    q.yz = Rot2Cs (q.yz, wk.leg[k].cs1);\n    q.z -= szLeg.z;\n    d = PrRoundBoxDf (q, szLeg - 0.02, 0.02);\n    DMINQ (idLeg);\n    q.z -= szLeg.z;\n    q.yz = Rot2Cs (q.yz, wk.leg[k].cs2);\n    q.z -= szLeg.z;\n    d = PrRoundBoxDf (q, szLeg - 0.02, 0.02);\n    DMINQ (idLeg);\n    qz = q.z;\n    q.z = abs (q.z) - szLeg.z;\n    d = PrCylDf (q.yzx, 1.2 * szLeg.y, 2.5 * szLeg.x);\n    DMINQ (idAx);\n    q.z = qz - szLeg.z;\n    q.yz = Rot2Cs (q.yz, wk.leg[k].cs3);\n    d = max (max (PrCaps2Df (q.yz, szLeg.y, 0.5), abs (q.x) - 5. * szLeg.x),\n       - PrRoundBox2Df (q.xz - vec2 (0., 0.05), vec2 (0.1, 0.25), 0.05));\n    DMINQ (idFoot);\n  }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  for (int j = VAR_ZERO; j < N_WLK; j ++) {\n    q = p - wlk[j].wPos;\n    d = (isSh) ? 0. : PrRoundBoxDf (q - vec3 (0., 5.2, 0.), vec3 (3., 5.2, 4.2) - 0.1, 0.1);\n    if (d < 0.3) d = WlkDf (q, dMin, wlk[j]);\n    dMin = min (d, dMin);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.02 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = 0.7 * vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nfloat GrndHt (vec2 p)\n{\n  return 0.7 * Fbm2 (0.2 * p.yx);\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x)).xzy;\n}\n\nvec4 ConCylHit (vec3 ro, vec3 rd, vec2 cs, float rad, float len, out float dcHit)\n{\n  vec3 s, vn;\n  float dMin, d, g, a, b, w, ta;\n  dMin = 1e6;\n  ta = cs.y / cs.x;\n  g = 1. + ta * ta;\n  a = 1. - g * rd.z * rd.z;\n  b = dot (ro, rd) + (ta * rad - g * ro.z) * rd.z;\n  w = b * b - a * (dot (ro, ro) + (2. * ta * rad - g * ro.z) * ro.z - rad * rad);\n  if (w > 0. && a != 0.) {\n    d = - (b + sqrt (w)) / a;\n    s = ro + d * rd;\n    if (abs (s.z) < len) {\n      dMin = d;\n      dcHit = 1. - s.z / len;\n      vn = vec3 (cs, 0.).xzy;\n      vn.xy = Rot2Cs (vn.xy, normalize (s.xy));\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nfloat BmVal (vec3 ro, vec3 rd, float dstLim)\n{\n  vec4 dc4;\n  vec3 ror, rdr, vn;\n  vec2 e;\n  float bmVal, bmLen, bmRad, dcHit;\n  bmLen = 50.;\n  bmRad = 2.45;\n  e = vec2 (1., -1.);\n  bmVal = 0.;\n  for (int j = VAR_ZERO; j < N_WLK; j ++) {\n    ror = ro - wlk[j].wPos; \n    ror.y -= hPlat;\n    rdr = rd;\n    ror.xz = Rot2Cs (ror.xz, wlk[j].csTur);\n    ror.yz -= brlPiv;\n    ror.yz = Rot2Cs (ror.yz, wlk[j].csBrl);\n    rdr.xz = Rot2Cs (rdr.xz, wlk[j].csTur);\n    rdr.yz = Rot2Cs (rdr.yz, wlk[j].csBrl);\n    ror.z += bmLen;\n    dc4 = ConCylHit (ror, rdr, bmCs * e, bmRad, bmLen, dcHit);\n    if (dc4.x < dstLim) {\n      vn = dc4.yzw;\n      vn.yz = Rot2Cs (vn.yz, wlk[j].csBrl * e);\n      vn.xz = Rot2Cs (vn.xz, wlk[j].csTur * e);\n      bmVal = max (bmVal, max (- dot (vn, rd), 0.) / (1. + 5. * dcHit * dcHit));\n    }\n  }\n  return bmVal;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roo, ror, rdr, bmDir;\n  float dstObj, dstGrnd, sh, nDotL, bmLen, att, bmVal, r;\n  SetWlkConf ();\n  isSh = false;\n  dstGrnd = dstFar;\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    col4 = vec4 (0.85, 0.85, 0.95, 0.2);\n    if (idObj == idLeg) {\n      col4 *= 0.8 + 0.2 * smoothstep (0.08, 0.1, abs (fract (4. * qHit.z - 0.5 * qHit.y) - 0.5));\n    } else if (idObj == idAx) {\n      col4 = vec4 (0.8, 0.8, 0.9, 0.2) * (0.8 + 0.2 * smoothstep (0.08, 0.1,\n         length (qHit.yz))) * (0.8 + 0.2 * smoothstep (0.01, 0.02, abs (abs (qHit.x) - 0.07)));\n    } else if (idObj == idFoot) {\n      col4 = vec4 (0.8, 0.8, 0.9, 0.2) * (0.8 + 0.2 * smoothstep (0.08, 0.1, abs (fract (8. *\n         qHit.x) - 0.5))) * (0.8 + 0.2 * step (0.12, length (vec2 (qHit.y, abs (qHit.z) - 0.45))));\n    } else if (idObj == idPlat) {\n      r = length (qHit.xz);\n      if (r > 2.7) col4 *= 0.8 + 0.2 * smoothstep (0.03, 0.04, abs (dot (qHit.zx, sin (2. * pi *\n         (floor (64. * atan (qHit.z, - qHit.x) / (2. * pi) + 0.5) / 64.) + vec2 (0.5 * pi, 0.)))));\n      else col4 *= 0.8 + 0.2 * smoothstep (0.03, 0.05, abs (abs (r - 1.9) - 0.3));\n    } else if (idObj == idTur) {\n      r = length (qHit.xz);\n      col4 *= (0.8 + 0.2 * smoothstep (0.04, 0.06, abs (fract (4. * qHit.y) - 0.5))) *\n         (0.8 + 0.2 * smoothstep (0.03, 0.04, abs (r - 0.5)));\n      col4 = mix (mix (vec4 (0.8, 0., 0., -1.), 0.8 * col4, step (0.5, fract (tCur))), col4,\n         step (0.15, r));\n    } else if (idObj == idBrl) {\n      r = length (qHit.xy);\n      if (r < 0.15) col4 = vec4 (1., 1., 0.9, -1.);\n      else if (r > 0.19) col4 = mix (col4, vec4 (0.8, 0.8, 0.6, -1.),\n         step (fract (6. * qHit.z + 8. * tCur), 0.4));\n    } else if (idObj == idMnt) {\n      col4 *= 0.8;\n    }\n    vn = ObjNf (ro);\n    nDotL = max (dot (vn, sunDir), 0.);\n    nDotL *= nDotL;\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    col4 = 0.2 * mix (vec4 (0.8, 0.7, 0.5, 0.), vec4 (0.9, 1., 0.5, 0.),\n       smoothstep (0.4, 0.6, Fbm2 (0.5 * ro.xz)));\n    vn = GrndNf (ro);\n    vn = VaryNf (0.5 * ro, vn, 1.5 * (1. - smoothstep (0.3, 0.7, dstGrnd / dstFar)));\n    nDotL = max (dot (vn, sunDir), 0.);\n  } else {\n    col = 0.3 * SkyBgCol (ro, rd);\n  }\n  if (dstObj < dstFar || rd.y < 0.) {\n    if (col4.a >= 0.) {\n      sh = (min (dstObj, dstGrnd) < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n      col = col4.rgb * (0.2 + 0.1 * max (- dot (vn, sunDir), 0.) + 0.8 * sh * nDotL) +\n         col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n    } else {\n      col = col4.rgb * (0.5 + 0.5 * max (- dot (vn, rd), 0.));\n    }\n  }\n  if (dstGrnd < min (dstObj, dstFar)) {\n    for (int j = VAR_ZERO; j < N_WLK; j ++) {\n      bmDir = wlk[j].ltPos - ro;\n      bmLen = length (bmDir);\n      bmDir = normalize (bmDir);\n      att = 5. * smoothstep (-0.001, 0.0001, - dot (wlk[j].bmAx, bmDir) - bmCs.x) *\n         step (- dot (vn, bmDir), 0.) / (1. + 0.0002 * bmLen * bmLen);\n      col += att * (col4.rgb * max (dot (vn, bmDir), 0.) +\n         col4.a * pow (max (dot (bmDir, reflect (rd, vn)), 0.), 32.));\n    }\n  }\n  if (rd.y < 0. && dstObj >= dstFar) col = mix (col, 0.3 * vec3 (0.3, 0.4, 0.5),\n     pow (1. + rd.y, 16.));\n  bmVal = BmVal (roo, rd, min (min (dstObj, dstGrnd), 4. * dstFar));\n  if (bmVal > 0.) col = mix (col, vec3 (1., 1., 0.9), 0.8 * bmVal);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  spd = 2.;\n  wPos = vec3 (0., 0.01, spd * tCur);\n  az = -0.3 * pi;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    az += 0.02 * pi * tCur;\n  }\n  el = clamp (el, -0.35 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = wPos + vuMat * vec3 (0., 3., -80.);\n  zmFac = 3.5 + 3. * abs (fract (az / (2. * pi)) - 0.5);\n  dstFar = 200.;\n  sunDir = vuMat * normalize (vec3 (0.5, 0.7, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}