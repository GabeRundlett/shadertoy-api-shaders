{
    "Shader": {
        "info": {
            "date": "1726304502",
            "description": "As part of my shader-learning adventure, I decided to make my first shader: a Minecraft-Terrain thingy.\nPlease feel free to play around with the code and leave suggestions (both code optimizations or things that I can work on)!\n:)",
            "flags": 0,
            "hasliked": 0,
            "id": "Mct3RH",
            "likes": 1,
            "name": "Minecraft-esque Shader v0.2",
            "published": 3,
            "tags": [
                "3d",
                "voxel",
                "raymarcher",
                "minecraft",
                "learningshaders"
            ],
            "usePreview": 0,
            "username": "bananabajanana",
            "viewed": 85
        },
        "renderpass": [
            {
                "code": "/*****Minecraft Shader & World Generation v0.2*****\n*\n*  I am a new shader-programmer (or just 'shader'? not sure)\n*  and in my adventure to learn this craft, I decided to start\n*  with a shader immitating Minecraft terrain generation. To\n*  do this, all I'll need is a voxel 3d engine, and Perlin \n*  noise, which is why I thought it would be a good beginner\n*  project.\n*\n*  I have just finished a simple voxel ray-marcher and a\n*  perlin noise generator! Which is why I decided it is time\n*  to finally upload this version, even if I am not fully\n*  satisfied with it just yet.\n*\n*  The main two goals I have for now, are to add movement\n*  (i.e. simple movement on x axis as time goes on) and textures\n*  because having flat colors is boooring! But I am still\n*  looking to improve this in any way possible, so if you have\n*  any suggestions please feel free to comment!\n*/\n\n// Seed for the world generation. Feel free to play with it\n// but you should probably keep it bigger than 100 or so\n// otherwise the changes between seeds are less noticable.\n#define SEED 1435.7931\n\n#define MAX_STEPS 160\n#define PERL_SCALE 0.05\n#define EPSILON 0.1\n/*TODO:\n** * Add camera movement\n** * Smarter condition for loop (instead of just max steps)\n** * Add textures instead of pure colors\n** * \n** * Understand Camera Rotation code (as I just copied it from a simple raymarching tutorial)\n*/\n\n//Perlin Noise{\nfloat Hash21(vec2 p) {\n    vec3 p3 = fract(p.xyx * SEED);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 Hash2Angle(vec2 t) {\n    float h = Hash21(t) * 6.2831;\n    return vec2(cos(h), sin(h));\n}\nfloat lerp(float t, float x, float y) {\n    return x + t*(y-x);\n}\nvec2 fade(vec2 pos) {\n    return ((6.*pos -15.)*pos + 10.)*pos*pos*pos;\n}\n\nfloat perlinNoise(vec2 pos) {\n    vec2 p = pos*PERL_SCALE;\n    vec2 cell = floor(p);\n    \n    // offset vectors from meta-grid cell\n    vec2 bl = p - cell; //bottom left\n    vec2 br = vec2(bl.x - 1., bl.y); // bottom right\n    vec2 tl = vec2(bl.x, bl.y - 1.); // top left\n    vec2 tr = vec2(bl.x - 1., bl.y - 1.); // top right\n    \n    // random constant vectors based on the meta-grid cell corners\n    vec2 vbl = Hash2Angle(cell);\n    vec2 vbr = Hash2Angle(cell + vec2(1., 0.));\n    vec2 vtl = Hash2Angle(cell + vec2(0., 1.));\n    vec2 vtr = Hash2Angle(cell + vec2(1., 1.));\n    \n    // dot products\n    float dotbl = dot(bl, vbl);\n    float dotbr = dot(br, vbr);\n    float dottl = dot(tl, vtl);\n    float dottr = dot(tr, vtr);\n    \n    vec2 fadedcoord = fade(bl);\n    \n    return mix(mix(dotbl, dottl, fadedcoord.y), \n               mix(dotbr, dottr, fadedcoord.y),\n               fadedcoord.x);\n}\n//}\n\n//Voxel Ray Marcher{\n// should probably clean this function up or\n// seperate to multiple functions...\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    \n    vec3 dirSign = vec3(rd.x > 0. ? 1 : -1, rd.y > 0. ? 1 : -1, rd.z > 0. ? 1 : -1);\n    vec3 dirSignSided = max(dirSign, 0.);\n    vec3 p = ro;\n    vec3 tileP = floor(p);\n    float t = 0.;\n    float wasLastJumpY = 0.;\n    int i;\n    //while(cond) {\n    for(i = 0; i < MAX_STEPS; i++) {\n        vec3 dt = ((tileP + dirSignSided) - p) / rd;\n        float progress = 0.;\n        vec3 dTile = vec3(0.);\n        float cortemp = 0.;\n        if(dt.x < dt.y && dt.x < dt.z) {\n            progress = dt.x;\n            dTile.x = dirSign.x;\n            wasLastJumpY = 0.;\n        }\n        else if(dt.y < dt.z) {\n            progress = dt.y;\n            dTile.y = dirSign.y;\n            wasLastJumpY = 1.;\n            \n        }\n        else {\n            progress = dt.z;\n            dTile.z = dirSign.z;\n            wasLastJumpY = 0.;\n        }\n        \n        t += progress;\n        tileP += dTile;\n        p += rd * progress;\n        if(perlinNoise(tileP.xz)*5. > tileP.y) break;\n    }\n    \n    if(i == MAX_STEPS) return vec2(t * 0.01, -1);\n    return vec2(t * 0.01,wasLastJumpY);\n}\n//}\n\n//Camera rotation{\nmat2 rotationMat(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\nvec3 rotationDirection(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n//}Camera-Rotation\n\nvec3 getColor(vec2 data, vec3 p) {\n    vec3 col = vec3(0);\n    \n    if(data.y!=-1.) {\n        //p = floor(p*1000.);\n\n        if(data.y == 1.) {\n            col = vec3(0.343, 0.835, 0.41);\n            //col += vec3(Hash21(p.xz)*.1);\n        }\n        else {\n            col = vec3(0.808, 0.589, 0.371);\n        }\n        \n        col = mix(col, vec3(0.433, 0.89, 0.906), data.x*.5);\n    } else {\n        col = vec3(0.433, 0.89, 0.906);\n    }\n    \n    return col;\n}\n\n// should probably also clean up the main\n// function as it is kinda clustered\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 15, -5);\n    ro.yz *= rotationMat(-m.y+.2);\n    ro.xz *= rotationMat(-m.x*6.2831);\n    vec3 rd = rotationDirection(uv, ro, vec3(0,0,0), .7);\n    \n    vec2 data = rayMarch(ro, rd);\n    \n    vec3 p = ro + rd * data.x;\n    \n    vec3 col = getColor(data, p);\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}