{
    "Shader": {
        "info": {
            "date": "1577651695",
            "description": "...multiply colors.\n\nBox Nearest | Box Linear | Tent Nearest | Tent Linear | Tent Linear Wheel/Bastard Color\n\nApproximation of the content of your Framebuffer:\nhttp://coding.hanfling.de/OneDoesNotSimplyMultiplyColors.jpg\n\n!! Make luminance preserving\n",
            "flags": 0,
            "hasliked": 0,
            "id": "WltGWj",
            "likes": 2,
            "name": "One does not simply...",
            "published": 3,
            "tags": [
                "aliasing"
            ],
            "usePreview": 0,
            "username": "hanfling",
            "viewed": 219
        },
        "renderpass": [
            {
                "code": "//\n// Left side:  Red\n// Right side: Blue\n//\n// Repeat Red/Blue values on the outside,\n// could also be rotatory, for like a\n// colorcircle, for more artistic use cases\n// outside of (physically based) rendering.\n//\n\n// Center at 0, Right at 1. Integration between 0 and 1/2.\nfloat BoxNearestRight( float OneCenter, float OneRight, float TwoCenter, float TwoRight )\n{\n    return 0.5*OneCenter*TwoCenter;\n}\n\n// Left at -1, Center at 0. Integration between -1/2 and 0.\nfloat BoxNearestLeft( float OneLeft, float OneCenter, float TwoLeft, float TwoCenter )\n{\n    return 0.5*OneCenter*TwoCenter;\n}\n\n// In case one does simply multiply colors.\nvec3 BoxNearestMultiplyColors( vec3 ColorOne, vec3 ColorTwo )\n{\n\treturn ColorOne*ColorTwo;\n}\n\n// Left at -1, Center at 0. Integration between -1/2 and 0.\nfloat BoxLinearLeft( float OneLeft, float OneCenter, float TwoLeft, float TwoCenter )\n{\n    float Result = 0.0;\n    \n    Result += (1.0/24.0)*OneLeft*TwoLeft;\n    Result += (2.0/24.0)*OneLeft*TwoCenter;\n    Result += (2.0/24.0)*OneCenter*TwoLeft;\n    Result += (7.0/24.0)*OneCenter*TwoCenter;\n    \n    return Result;\n}\n\n// Center at 0, Right at 1. Integration between 0 and 1/2.\nfloat BoxLinearRight( float OneCenter, float OneRight, float TwoCenter, float TwoRight )\n{\n    float Result = 0.0;\n    \n    Result = BoxLinearLeft( OneRight, OneCenter, TwoRight, TwoCenter );\n    \n    return Result;\n}\n\nvec3 BoxLinearMultiplyColors( vec3 ColorOne, vec3 ColorTwo )\n{\n    vec3 Result = vec3(0.0);\n    \n    // Left of Red.\n    Result.r += BoxNearestLeft( ColorOne.r, ColorOne.r, ColorTwo.r, ColorTwo.r );\n\n    // Right of Red.\n    Result.r += BoxLinearRight( ColorOne.r, ColorOne.g, ColorTwo.r, ColorTwo.g );\n\n    // Left of Green.\n    Result.g += BoxLinearLeft( ColorOne.r, ColorOne.g, ColorTwo.r, ColorTwo.g );\n\n    // Right of Green.\n    Result.g += BoxLinearRight( ColorOne.g, ColorOne.b, ColorTwo.g, ColorTwo.b );\n\n    // Left of Blue.\n    Result.b += BoxLinearLeft( ColorOne.g, ColorOne.b, ColorTwo.g, ColorTwo.b );\n\n    // Right of Blue.\n    Result.b += BoxNearestRight( ColorOne.b, ColorOne.b, ColorTwo.b, ColorTwo.b );\n\n\treturn Result;\n}\n\n\n// Left at -1, Center at 0. Integration between -1/2 and 0.\nfloat TentNearestLeft( float OneLeft, float OneCenter, float TwoLeft, float TwoCenter )\n{\n    float Result = 0.0;\n\n    Result += (1.0/8.0)*OneLeft*TwoLeft;\n    Result += (3.0/8.0)*OneCenter*TwoCenter;\n\n    return Result;\n}\n\n// Center at 0, Right at 1. Integration between 0 and 1/2.\nfloat TentNearestRight( float OneCenter, float OneRight, float TwoCenter, float TwoRight )\n{\n    float Result = 0.0;\n    \n    Result = TentNearestLeft( OneRight, OneCenter, TwoRight, TwoCenter );\n    \n    return Result;\n}\n\nvec3 TentNearestMultiplyColors( vec3 ColorOne, vec3 ColorTwo )\n{\n    vec3 Result = vec3(0.0);\n    \n    // Left of Red.\n    Result.r += BoxNearestLeft( ColorOne.r, ColorOne.r, ColorTwo.r, ColorTwo.r );\n\n    // Right of Red.\n    Result.r += TentNearestRight( ColorOne.r, ColorOne.g, ColorTwo.r, ColorTwo.g );\n\n    // Left of Green.\n    Result.g += TentNearestLeft( ColorOne.r, ColorOne.g, ColorTwo.r, ColorTwo.g );\n\n    // Right of Green.\n    Result.g += TentNearestRight( ColorOne.g, ColorOne.b, ColorTwo.g, ColorTwo.b );\n\n    // Left of Blue.\n    Result.b += TentNearestLeft( ColorOne.g, ColorOne.b, ColorTwo.g, ColorTwo.b );\n\n    // Right of Blue.\n    Result.b += BoxNearestRight( ColorOne.b, ColorOne.b, ColorTwo.b, ColorTwo.b );\n\n\treturn Result;\n}\n\n// Left at -1, Center at 0. Integration between -1/2 and 0.\nfloat TentLinearLeft( float OneLeft, float OneCenter, float TwoLeft, float TwoCenter )\n{\n    float Result = 0.0;\n\n    Result += (1.0/12.0)*OneLeft*TwoLeft;\n    Result += (1.0/12.0)*OneLeft*TwoCenter;\n    Result += (1.0/12.0)*OneCenter*TwoLeft;\n    Result += (3.0/12.0)*OneCenter*TwoCenter;\n\n    return Result;\n}\n\n// Center at 0, Right at 1. Integration between 0 and 1/2.\nfloat TentLinearRight( float OneCenter, float OneRight, float TwoCenter, float TwoRight )\n{\n    float Result = 0.0;\n    \n    Result = TentLinearLeft( OneRight, OneCenter, TwoRight, TwoCenter );\n    \n    return Result;\n}\n\n// This works more in the sense of a \"spectrum\", which RGB colors are NOT.\nvec3 TentLinearMultiplyColors( vec3 ColorOne, vec3 ColorTwo )\n{\n    vec3 Result = vec3(0.0);\n    \n    // Left of Red.\n    Result.r += BoxNearestLeft( ColorOne.r, ColorOne.r, ColorTwo.r, ColorTwo.r );\n\n    // Right of Red.\n    Result.r += TentLinearRight( ColorOne.r, ColorOne.g, ColorTwo.r, ColorTwo.g );\n\n    // Left of Green.\n    Result.g += TentLinearLeft( ColorOne.r, ColorOne.g, ColorTwo.r, ColorTwo.g );\n\n    // Right of Green.\n    Result.g += TentLinearRight( ColorOne.g, ColorOne.b, ColorTwo.g, ColorTwo.b );\n\n    // Left of Blue.\n    Result.b += TentLinearLeft( ColorOne.g, ColorOne.b, ColorTwo.g, ColorTwo.b );\n\n    // Right of Blue.\n    Result.b += BoxNearestRight( ColorOne.b, ColorOne.b, ColorTwo.b, ColorTwo.b );\n\n\treturn Result;\n}\n\n// This works more in the sense of a Bastard Color: https://en.wikipedia.org/wiki/Bastard_color\nvec3 TentLinearMultiplyColorsWheel( vec3 ColorOne, vec3 ColorTwo )\n{\n    vec3 Result = vec3(0.0);\n    \n    // Left of Red is Blue again!\n    Result.r += TentLinearLeft( ColorOne.b, ColorOne.r, ColorTwo.b, ColorTwo.r );\n\n    // Right of Red.\n    Result.r += TentLinearRight( ColorOne.r, ColorOne.g, ColorTwo.r, ColorTwo.g );\n\n    // Left of Green.\n    Result.g += TentLinearLeft( ColorOne.r, ColorOne.g, ColorTwo.r, ColorTwo.g );\n\n    // Right of Green.\n    Result.g += TentLinearRight( ColorOne.g, ColorOne.b, ColorTwo.g, ColorTwo.b );\n\n    // Left of Blue.\n    Result.b += TentLinearLeft( ColorOne.g, ColorOne.b, ColorTwo.g, ColorTwo.b );\n\n    // Right of Blue is Red again!\n    Result.b += TentLinearRight( ColorOne.b, ColorOne.r, ColorTwo.b, ColorTwo.r );\n\n\treturn Result;\n}\n\nvoid mainImage( out vec4 FragColor, in vec2 FragCoord )\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n    vec2 NormalizedScreenCoords = FragCoord/iResolution.xy;\n\n    vec3 ColorOne = 0.5 + 0.5*cos(iTime+vec3(0,2,4));\n    //vec3 ColorOne = vec3(1.0,1.0,0.0); // <-------------- Color A (Yellow). (1.0,1.0,0.0)\n\n    vec3 ColorTwo = texture(iChannel0,NormalizedScreenCoords).rgb;\n    //vec3 ColorTwo = vec3(1.0,0.0,1.0); // <-------------- Color B (Pink).   (1.0,0.0,1.0)\n    \n    vec3 BoxNearest      = BoxNearestMultiplyColors     ( ColorOne, ColorTwo );\n    vec3 BoxLinear       = BoxLinearMultiplyColors      ( ColorOne, ColorTwo );\n    vec3 TentNearest     = TentNearestMultiplyColors    ( ColorOne, ColorTwo );\n    vec3 TentLinear      = TentLinearMultiplyColors     ( ColorOne, ColorTwo );\n    vec3 TentLinearWheel = TentLinearMultiplyColorsWheel( ColorOne, ColorTwo );\n\n/*\n         if ( NormalizedScreenCoords.x<0.2 ) FragColor = vec4(BoxNearest,      1.0); // Box Nearest.\n    else if ( NormalizedScreenCoords.x<0.4 ) FragColor = vec4(BoxLinear,       1.0); // Box Linear.\n    else if ( NormalizedScreenCoords.x<0.6 ) FragColor = vec4(TentNearest,     1.0); // Tent Nearest.\n    else if ( NormalizedScreenCoords.x<0.8 ) FragColor = vec4(TentLinear,      1.0); // Tent Linear.\n    else                                     FragColor = vec4(TentLinearWheel, 1.0); // Tent Linear Wheel/Bastard Color.\n*/\n    if ( NormalizedScreenCoords.x<0.5 )\n        FragColor = vec4(BoxNearest,      1.0); // Box Nearest.\n    else\n    \tFragColor = vec4(TentLinear,      1.0); // Tent Linear.\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}