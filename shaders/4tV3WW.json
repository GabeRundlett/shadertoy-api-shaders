{
    "Shader": {
        "info": {
            "date": "1474675271",
            "description": "Plotting Rec.709 colors against the CIE 1931 chromaticity curve, RGB calculated from the Rec.709 matrices only",
            "flags": 0,
            "hasliked": 0,
            "id": "4tV3WW",
            "likes": 11,
            "name": "CIE 1931 with Rec.709",
            "published": 3,
            "tags": [
                "colorspace",
                "chromaticity"
            ],
            "usePreview": 0,
            "username": "robingreen",
            "viewed": 1569
        },
        "renderpass": [
            {
                "code": "// by Robin Green, Sept 2016\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define EPS    .005\n\n// CIE curve generated from \"Selected Colormetric Tables\" from the CIE website:\n//\n//    http://www.cie.co.at/index.php/LEFTMENUE/index.php?i_ca_id=298\n//\nconst vec2 aa = vec2( 0.174112257, 0.004963727 ); // 380.0\nconst vec2 ab = vec2( 0.150985408, 0.022740193 ); // 455.0\nconst vec2 ac = vec2( 0.135502671, 0.039879121 ); // 465.0\nconst vec2 ad = vec2( 0.124118477, 0.057802513 ); // 470.0\nconst vec2 ae = vec2( 0.109594324, 0.086842511 ); // 475.0\nconst vec2 af = vec2( 0.091293516, 0.132702055 ); // 480.0\nconst vec2 ag = vec2( 0.068705910, 0.200723220 ); // 485.0\nconst vec2 ah = vec2( 0.045390735, 0.294975965 ); // 490.0\nconst vec2 ai = vec2( 0.023459943, 0.412703479 ); // 495.0\nconst vec2 aj = vec2( 0.008168028, 0.538423071 ); // 500.0\nconst vec2 ak = vec2( 0.003858521, 0.654823151 ); // 505.0\nconst vec2 al = vec2( 0.013870246, 0.750186428 ); // 510.0\nconst vec2 am = vec2( 0.038851802, 0.812016021 ); // 515.0\nconst vec2 an = vec2( 0.074302424, 0.833803082 ); // 520.0\nconst vec2 ao = vec2( 0.114160721, 0.826206968 ); // 525.0\nconst vec2 ap = vec2( 0.154722061, 0.805863545 ); // 530.0\nconst vec2 aq = vec2( 0.192876183, 0.781629131 ); // 535.0\nconst vec2 ar = vec2( 0.229619673, 0.754329090 ); // 540.0\nconst vec2 as = vec2( 0.265775085, 0.724323925 ); // 545.0\nconst vec2 at = vec2( 0.736842105, 0.263157895 ); // 780.0\n\n// Some known points for Rec.709\nconst vec2 D65 = vec2( 0.3127, 0.3290 );\nconst vec2 primaryR_709 = vec2( 0.64, 0.33 );\nconst vec2 primaryG_709 = vec2( 0.30, 0.60 );\nconst vec2 primaryB_709 = vec2( 0.15, 0.06 );\n\n\n// totally stole these line drawing bits from Nikos Papadopoulos, 4rknova\n// from the Bezier curve shader https://www.shadertoy.com/view/ll23Wt\n\nfloat df_circ(in vec2 p, in vec2 c, in float r)\n{\n    return abs(r - length(p - c));\n}\n\nfloat df_line(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nfloat sharpen(in float d, in float w)\n{\n    float e = 1. / min(iResolution.y , iResolution.x);\n    return 1. - smoothstep(-e, e, d - w);\n}\n\nvec3 XYtoXYZ(vec2 xy)\n{\n    vec3 XYZ;\n    \n    // Convert xyY to XYZ where Y = 1.0\n    if(xy.x <= 1.0 && xy.x >= 0.0 && xy.y <= 1.0 && xy.y > 0.0)\n    {\n        XYZ = vec3( xy.x / xy.y, 1.0, (1.0 - xy.x - xy.y) / xy.y);          \n    }\n    return XYZ;\n }\n\nvec2 XYZtoXY(vec3 XYZ)\n{\n    return vec2( XYZ.x/(XYZ.x+XYZ.y+XYZ.z), XYZ.y/(XYZ.x+XYZ.y+XYZ.z) );\n}\n\n\nvec3 trismus(vec2 uv)\n{\n\t// matrices are transposed from the reference material for sRGB at:\n    //\n    //    http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n    //\n    const mat3 RGB_to_XYZ_709 = mat3(\n        0.4124564, 0.2126729, 0.0193339,\n        0.3575761, 0.7151522, 0.1191920,\n        0.1804375, 0.0721750, 0.9503041 );\n\n    const mat3 XYZ_to_RGB_709 = mat3(\n        3.2404542, -0.9692660,  0.0556434,\n       -1.5371585,  1.8760108, -0.2040259,\n       -0.4985314,  0.0415560,  1.0572252 );   \n       \n\tvec3 rgb;\n    \n    // given a point on the screen, is it inside the Gamut triangle?\n    // test this by untransforming the point and testing whether it's\n    // inside the lower left triangle of the 0..1 UV square. Essentially\n    // a barycentric triangle test\n    \n    vec2 pos = XYZtoXY(XYZ_to_RGB_709 * XYtoXYZ(uv));   \n    \n    if ((pos.x + pos.y) >= 1.0 || pos.x <= 0.0 || pos.y <= 0.0) {\n        rgb = vec3(0.25);\n    } else {\n        // color according to the untransformed UV coordinate\n    \trgb = (XYZ_to_RGB_709 * XYtoXYZ(uv));\n        float m = max( rgb.x, max( rgb.y, rgb.z )); // looks better than normalize()\n        rgb = pow( rgb/m, vec3( 0.45 ) ); // de-gamma by inverse of 2.2\n    }\n     \n    // add gamut border from first principles\n    vec2 red   = XYZtoXY(RGB_to_XYZ_709 * vec3(1.0, 0.00, 0.0));\n    vec2 green = XYZtoXY(RGB_to_XYZ_709 * vec3(0.0, 1.00, 0.0));\n    vec2 blue  = XYZtoXY(RGB_to_XYZ_709 * vec3(0.0, 0.00, 1.0));\n     \n\trgb = max(rgb, sharpen(df_line(uv, red.xy, green.xy), EPS * .2));\n    rgb = max(rgb, sharpen(df_line(uv, red.xy, blue.xy), EPS * .2));\n    rgb = max(rgb, sharpen(df_line(uv, green.xy, blue.xy), EPS * .2));\n    \n    return rgb;\n}\n\nfloat CIEcurve(vec2 uv)\n{\n    float cp =   sharpen(df_line(uv, aa, ab), EPS * .4);\n    cp = max(cp, sharpen(df_line(uv, ab, ac), EPS * .4));\n    cp = max(cp, sharpen(df_line(uv, ac, ad), EPS * .4));\n    cp = max(cp, sharpen(df_line(uv, ad, ae), EPS * .4));\n    cp = max(cp, sharpen(df_line(uv, ae, af), EPS * .4));\n    cp = max(cp, sharpen(df_line(uv, af, ag), EPS * .4));\n    cp = max(cp, sharpen(df_line(uv, ag, ah), EPS * .4));\n    cp = max(cp, sharpen(df_line(uv, ah, ai), EPS * .4));\n    cp = max(cp, sharpen(df_line(uv, ai, aj), EPS * .4));\n    cp = max(cp, sharpen(df_line(uv, aj, ak), EPS * .4));\n    cp = max(cp, sharpen(df_line(uv, ak, al), EPS * .4));\n    cp = max(cp, sharpen(df_line(uv, al, am), EPS * .4));\n    cp = max(cp, sharpen(df_line(uv, am, an), EPS * .4));\n    cp = max(cp, sharpen(df_line(uv, an, ao), EPS * .4));   \n    cp = max(cp, sharpen(df_line(uv, ao, ap), EPS * .4));   \n    cp = max(cp, sharpen(df_line(uv, ap, aq), EPS * .4));   \n    cp = max(cp, sharpen(df_line(uv, aq, ar), EPS * .4));   \n    cp = max(cp, sharpen(df_line(uv, ar, as), EPS * .4));   \n    cp = max(cp, sharpen(df_line(uv, as, at), EPS * .4));   \n    cp = max(cp, sharpen(df_line(uv, at, aa), EPS * .2));   \n    return cp;\n}\n\nfloat primaries(vec2 pos)\n{\n    // plot some known points in xyY so we can debug these matrices\n    float cp = 0.0;\n    cp = sharpen(df_circ(pos, D65, 0.004), EPS * 0.6);\n    cp = max(cp, sharpen(df_circ(pos, primaryR_709, 0.004), EPS * 0.6));\n    cp = max(cp, sharpen(df_circ(pos, primaryG_709, 0.004), EPS * 0.6));\n    cp = max(cp, sharpen(df_circ(pos, primaryB_709, 0.004), EPS * 0.6));\n    return cp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 1.0 / min(iResolution.x, iResolution.y);\n\tvec2 uv = fragCoord.xy * scale;\n    vec3 col = vec3(0);   \n    // vec2 mouse = (vec2(0.0, iResolution.y)*0.5 - iMouse.xy) * scale;\n    vec2 mouse = vec2(-iResolution.x * 0.3, -iResolution.y * 0.1) * scale;\n        \n\tfloat cp = CIEcurve(uv + mouse);\n    cp = max(cp, primaries(uv + mouse));\n\tfragColor = vec4(trismus(uv + mouse), 1.0) + vec4(cp, cp, cp, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}