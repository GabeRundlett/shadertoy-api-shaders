{
    "Shader": {
        "info": {
            "date": "1496141577",
            "description": "mouse input!\nsimpler while \"paused\" -> no phase shifting\n\nmay be useful for shadertoy audio.\nthinking of tessellating the music_sheet rather than checking EVERY sheet_note for every moment in time.\n\ni might be missing something obvious as i am no expert.",
            "flags": 0,
            "hasliked": 0,
            "id": "XsXfD4",
            "likes": 1,
            "name": "fit periodic mod()ulations",
            "published": 3,
            "tags": [
                "filter",
                "audio",
                "tiling",
                "tile",
                "tesselation",
                "modulation"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 629
        },
        "renderpass": [
            {
                "code": "#define zoom 3.\n#define frame(u) zoom*(u-.5*iResolution.xy)/iResolution.y\n\n/*\nIf you put a period inside another period, for tiling tesselation.\nEg: If you want to play a sine wave of a set wavelength \n... for a limited (or tiled) amount of time (==note duration).\nYou have the problem of a tiling suddenly breaking mix-tile,\n...that fourier-transforms into one high pitch cracking-noise at the end\n...that is usually filtered lazily with a band-filter (overkill)\n...or dealt with by fading it into silence (lazy (physical piano solution)).\n\nHaving a periodic wave only stop when f(x)=0,\n... and defining a period.y's start=end=f(x)=0, (like sin(x))\n... avoids this high pitch cracking-noise at the end.\n\nyou just calculate how man times a smaller tile fits into a larger tile.\nvia howManyAfitInB() and use that within the packsin() filter.\n*/\n\n//return how many times period [a] fits into period [b].\nfloat howManyAfitInB(float a, float b){if(a==0.)return 0.;return floor(b/a);}\nfloat howManyFitIn(float a){if(a==0.)return 0.;return floor(1./a);}\n\n//if (x < largest_possible_stack_of_interval_p ) return 1; return 0; //[p]PeriodLength (wavelength)\nfloat packsin(float x,float p){return step(abs(x),p*howManyFitIn(p));}\n//is oblivious about negative input ranges.\n\n#define tau acos(-1.)*2.\n\nvoid mainImage(out vec4 O,in vec2 U){vec2 u=frame(U);\n vec2 m=frame(iMouse.xy);\n float d;  \n m.x=fract(m.x);//if(out of bounds) beter have strange (but save) things happen than nothing happen. (derivative_voids are boring)\n m.x=max(.001,abs(m.x));//skipping \"0\"\n float w=u.x;//modifying a copy of u.x\n w+=sin(iTime*.1);//phase shift the whole thing\n d=packsin(w,m.x);//a filter;\n d*=sin(w/m.x*tau);//a periodic waveform.\n d-=u.y;\n d=smoothstep(.01,-.01,abs(d)-.1);\n u=fract(u);\n O=vec4(d,u,1.);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}