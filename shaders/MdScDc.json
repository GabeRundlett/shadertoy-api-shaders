{
    "Shader": {
        "info": {
            "date": "1494098533",
            "description": "understanding perlin noise",
            "flags": 0,
            "hasliked": 0,
            "id": "MdScDc",
            "likes": 8,
            "name": "Understanding Perlin Noise 2D",
            "published": 3,
            "tags": [
                "perlin"
            ],
            "usePreview": 0,
            "username": "fscur",
            "viewed": 1146
        },
        "renderpass": [
            {
                "code": "//http://flafla2.github.io/2014/08/09/perlinnoise.html\n//https://web.archive.org/web/20160530124230\n//http://freespace.virgin.net/hugo.elias/models/m_perlin.htm\n//http://eastfarthing.com/blog/2015-04-21-noise/\n//https://www.youtube.com/watch?v=Or19ilef4wE\n//https://www.youtube.com/watch?v=MJ3bvCkHJtE\n\n\n\n//hash from iq\n//https://www.shadertoy.com/view/Xs23D3\nvec2 hash( vec2 p ) \n{  \t\t\t\t\t\t\n\tp = vec2(dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)));\n    \n\treturn -1.0 + 2.0 * fract(sin(p + 20.0) * 53758.5453123);\n}\n\nfloat lerp(float a, float b, float t)\n{\n\treturn a + t * (b - a);\n}\n\nfloat perlin_noise_2(in vec2 p)\n{\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n    \n    //grid points\n    vec2 p0 = vec2(0.0, 0.0);\n    vec2 p1 = vec2(1.0, 0.0);\n    vec2 p2 = vec2(0.0, 1.0);\n    vec2 p3 = vec2(1.0, 1.0);\n    \n    //distance vectors to each grid point\n    vec2 s0 = f - p0;\n    vec2 s1 = f - p1;\n    vec2 s2 = f - p2;\n    vec2 s3 = f - p3;\n    \n    //random gradient vectors on each grid point\n    vec2 g0 = hash(i + p0);\n    vec2 g1 = hash(i + p1);\n    vec2 g2 = hash(i + p2);\n    vec2 g3 = hash(i + p3);\n    \n    //gradient values\n    float q0 = dot(s0, g0);\n    float q1 = dot(s1, g1);\n    float q2 = dot(s2, g2);\n    float q3 = dot(s3, g3);\n    \n    //interpolant weights\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    //bilinear interpolation\n    float l0 = lerp(q0, q1, u.x);\n    float l1 = lerp(q2, q3, u.x);\n    float l2 = lerp(l0, l1, u.y);\n    \n    return l2;\n}\n\nfloat perlin_fbm(vec2 uv, float persistence, int octaves) \n{\n    float total = 0.0;\n    float maxValue = 0.0;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    \n    for(int i=0; i<octaves;++i)\n    {\n        total += perlin_noise_2(uv * frequency) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n    }\n    \n    return total/maxValue;\n}\n\nvec4 render(vec2 uv)\n{\n    float n = perlin_fbm(uv, 0.7, 8);\n    return vec4(n+0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float width = 1.0;\n    vec2 uv = ((fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y) * width * 0.5;\n   \tfragColor = render(uv);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}