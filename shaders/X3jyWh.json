{
    "Shader": {
        "info": {
            "date": "1727200579",
            "description": "originals shader from glslsandbox, and fractal 62",
            "flags": 0,
            "hasliked": 0,
            "id": "X3jyWh",
            "likes": 3,
            "name": "box with colorspace",
            "published": 3,
            "tags": [
                "color",
                "space",
                "box"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 88
        },
        "renderpass": [
            {
                "code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\n#define SHADERTOY 1\n#define PI 3.141592654\n#define saturate(a) clamp(a, 0., 1.)\n#define range(a, b) (step(a, floor(time2)) * step(floor(time2), b))\n\nconst int maxIteration = 128;\nconst float fmaxIteration = float(maxIteration);\n#define time iTime\n#define resolution iResolution.xy\n\nfloat time0, time1, time2, zoom, a;\nint iter;\n\nfloat box(vec3 p, float b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 hue(float hue) {\n    vec3 rgb = fract(hue + vec3(0., 2. / 3., 1. / 3.));\n    rgb = abs(rgb * 2. - 1.);\n    return clamp(rgb * 3. - 1., 0., 1.);\n}\n\nfloat hash11(float p) {\n    vec3 p3 = fract(vec3(p) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat2 rot1, rot2, rot3, rot4;\n\nvec2 ifs(vec3 p) {\n    float d1 = 999., d2 = 999.;\n    float range = .8, radius = .5 * (1. + zoom);\n\n    const float maxIter = 8.;\n    for (int i = int(maxIter); i > 0; i--) {\n        if (i <= iter) {\n            break;\n        }\n\n        float ratio = float(i) / maxIter;\n        float bx = box(p, radius * ratio);\n        d1 = mix(d1, min(d1, bx), float(i > iter + 1));\n        d2 = min(d2, bx);\n\n        ratio *= ratio;\n\n        p.xz = abs(p.xz) - range * ratio * .7;\n        p.xz *= rot1;\n        p.yz *= rot3;\n        p.yx *= rot2;\n\n        p.yz = abs(p.yz) - range * ratio * .7;\n        p.xz *= rot1;\n        p.yz *= rot4;\n        p.yx *= rot2;\n    }\n\n    return vec2(d1, d2);\n}\n\nfloat map(vec3 p) {\n    vec2 d = ifs(p);\n    return mix(d.y, d.x, mix(a, 1. - a, step(time0, 5.5)));\n}\n\nfloat calcAo(vec3 p, vec3 n) {\n    float sca = 1.0, occ = 0.0;\n\n    for (float i = 0.; i < 5.; i++) {\n        float hr = 0.05 + i * 0.08;\n        float dd = map(n * hr + p);\n        occ += (hr - dd) * sca;\n        sca *= 0.5;\n    }\n\n    return saturate(1.0 - occ);\n}\n\nvec3 intersect(vec3 ro, vec3 ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i < maxIteration; i++) {\n        float res = abs(map(ro + ray * t));\n        if (res < 0.005) return vec3(t, res, i);\n        t += res;\n    }\n\n    return vec3(-1.0);\n}\n\nvec3 normal(vec3 pos, float e) {\n    vec2 eps = vec2(1.0, -1.0) * 0.5773 * e;\n\n    return normalize(eps.xyy * map(pos + eps.xyy) +\n                     eps.yyx * map(pos + eps.yyx) +\n                     eps.yxy * map(pos + eps.yxy) +\n                     eps.xxx * map(pos + eps.xxx));\n}\n\nmat3 createCamera(vec3 ro, vec3 ta, float cr) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    \n    return mat3(cu, cv, cw);\n}\n\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(vec2 x) {\n\tvec2 i = floor(x), f = fract(x);\n\n\tfloat a = hash(i);\n\tfloat b = hash(i + vec2(1.0, 0.0));\n\tfloat c = hash(i + vec2(0.0, 1.0));\n\tfloat d = hash(i + vec2(1.0, 1.0));\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 p) {\n\tconst mat2 m2 = mat2(0.8, -0.6, 0.6, 0.8);\n\n\tp.xy += 0.1 * time1;\n\n\tfloat f = 0.5000 * noise(p); p = m2 * p * 2.02;\n\tf += 0.2500 * noise(p); p = m2 * p * 2.03;\n\tf += 0.1250 * noise(p); p = m2 * p * 2.01;\n\tf += 0.0625 * noise(p);\n\treturn f / 0.9375;\n}\n\nvec3 sky(vec3 ro, vec3 ray) {\n    vec3 col = vec3(0.);\n\n    float rd = ray.y + 0.3;\n    col = mix(col, vec3(2.0, 0.25, 2.0), 0.5 * smoothstep(0.5, 0.8, fbm((ro.xz + ray.xz * (250000.0 - ro.y) / rd) * 0.000008)));\n    col = mix(col, vec3(0.), pow(1.0 - max(rd, 0.0), 4.0));\n    \n    col = mix(vec3(0.), col, saturate(time1 * 3. - 4.));\n    col = mix(col, vec3(0.), saturate(time1 - 5.25));\n    return col * 1.3;\n}\n\n#define edge(start, end, sStart, sEnd, ecol) if (range(start, end) > 0.) { showEdge = 1.; float offs = pos.y - mix(sStart, sEnd, 0.025 + saturate(time2 - start)); edgeColor = ecol; edgeIntensity = mix(0., edgeIntensity, saturate(1. - abs(offs))); col = mix(col, objectColor, saturate(1. - (offs + 1.5))); }\n\nvec3 render(vec2 p) {\n    float t = time0 * 0.7 - 1.;\n    float offs = mix(1., hash11(max(1., floor(t * 4.))), smoothstep(0., .5, time0));\n    vec3 ro = vec3(cos(t * 3.5) * 11., sin(t * 3.9) * 4.5, sin(t * 1.5) * 10.) * 0.7;\n\n    t = time1 * 0.7;\n    offs = mix(mix(1., hash11(max(1., floor(t * 4.))), step(0., time1)), 1., step(4.6, time1));\n   \n\n    vec3 ta = vec3(0.0, 0.0, (sin(t * 0.55) * 0.5 + 0.5) * 2.0);\n    ta = mix(ta, vec3(0.), saturate(time1 - 6.7));\n\n    mat3 cm = createCamera(ro, ta, 0.);\n    vec3 ray = cm * normalize(vec3(p, 4.0));\n\n    vec3 res = intersect(ro, ray);\n    if (res.y < -0.5) {\n        return sky(ro, ray);\n    }\n\n    vec3 pos = ro + ray * res.x;\n    vec3 nor = normal(pos, 0.008);\n\n    float glowIntensity = saturate(pow(abs(1. - abs(dot(nor, ray))), 1.));\n    vec3 objectColor = (vec3(.003, .001, .0095)\n            * pow(1. / res.z * 1.5, -1.8) + glowIntensity * vec3(.1, .25, .3)) * res.x * 0.3\n            * calcAo(pos, nor)\n            + sky(ro, normalize(reflect(ray, nor))) * .4 * (1. - zoom);\n\n    float a = smoothstep(0.3, 0.7, pow(fract(time0 * 3.), 0.4));\n    float edgeThreshold = mix(0.02, 0.03, (1. - a) * (1. - zoom));\n    float edgeIntensity = smoothstep(edgeThreshold - 0.01, edgeThreshold, length(nor - normal(pos, .015)));\n\n    float noShade = range(-10., 3.);\n    vec3 col = mix(objectColor, vec3(0.), noShade);\n\n    float showEdge = 0.;\n    vec3 edgeColor = vec3(1.);\n    vec3 rainbow = hue(pos.z / 2.);\n   \n\n    \n    col += edgeColor * edgeIntensity * step(1., zoom + noShade + showEdge);\n   \n    return col;\n}\n\nvec2 shake(float t) {\n    float s = t * 50.0;\n    return (vec2(hash11(s), hash11(s + 11.0)) * 2.0 - 1.0) * exp(-5.0 * t) * 0.2;\n}\n\nvec3 vignette(vec2 p) {\n    p *= 1.0 - p.yx;\n    return vec3(1.2, 1.1, .85) * pow(16. * p.x * p.y * (1. - p.x) * (1. - p.y), 0.125);\n}\n\n\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec2 p2 = (C.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n\n    time0 = mod(time * 0.4, 11.);\n  \n\n    float t = time0 * 3.;\n    iter = int(mix(clamp(14. - floor(t), 0., 7.), min(8., floor(t) - 24.), step(24., floor(t))));\n    a = mix(1., smoothstep(0.3, 0.7, pow(fract(t), 0.4)), step(7.5, t));\n\n    t = time1 * 0.;\n    float angle = step(1.2, time1) * (floor(t + 0.5) + smoothstep(0.3, 0.7, pow(fract(t + 0.5), 0.4)));\n\n    rot1 = rot(0.785397);\n    rot2 = rot(1.7079);\n    rot3 = rot(angle * 1.2 + 424. + step(7.035716, time0) * 3.);\n    rot4 = rot(angle * 1.2 + 226.);\n\n   \n\n    p2 = mix(p2, vec2(1. + hash11(p2.y) * 10., p2.y), saturate(time0 - 10.33) * 5.);\n\n    p2 *= 1.0 + 5. * pow(length(p2), 1.5) * zoom;\n\n    vec3 col = render(p2);\n  \n    col = mix(col, vec3(0.), saturate(time0 - 10.33) * 10. + step(time, 0.));\n\n   vec4 color = vec4(col, 0.);\n \n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1),H(g*.1),.8)*12./e/8e3\n    )\n    {\n        p=g*d*color.xyz;\n  float c24 = fbm(p.xy);\n        a=30.;\n        p=mod(p-a,a*2.)-a;\n        s=2.;\n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n         \n            s*=e=1.7+sin(iTime*.01)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.*3.,\n                    120,\n                    8.*5.\n                 );\n         }\n         g+=e=length(p.yzxx)/s;\n    }\n   \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}