{
    "Shader": {
        "info": {
            "date": "1501527485",
            "description": "A Geometric Construction of an Axis of Rotation.\n\nUse the sliders on the right to compose rotations around the x, y, and z axes.",
            "flags": 32,
            "hasliked": 0,
            "id": "4dSBRc",
            "likes": 9,
            "name": "[SH17C] Axis of Rotation",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "ui"
            ],
            "usePreview": 1,
            "username": "culdevu",
            "viewed": 1267
        },
        "renderpass": [
            {
                "code": "/* \n    Author: Daniel Taylor\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\t-- A Geometric Construction of an Axis of Rotation --\n\n\tIn 3D space, it's always true that any composition of rotations around an arbitrary\n\taxis is itself a rotation around some axis. You've problably seen a proof of this at\n\tsome point in a Linear Algebra class that uses the fact that the characterstic polynomial\n\tof any such transformation has degree 3, and so it has a at least one real root.\n\n\tThat proof is enough to convince me that such an axis exists, but I've never really been\n\table to visualize what a construction of such an axis would look like. This shader is\n\tme trying to explain this to myself.\n\n\tThe idea: Take a look at those 2 red dots on the sphere. We want to find an axis so that\n\tthe rotation around it will put one of the red dots on top of the other. So, these dots\n\tmust lie on a circle. So, picture the set of all circles on the surface of the sphere\n\tgoing through the 2 red points, and then picture the set of all axes going through the\n\tcenters of those circles. Hopefully you can see that all such axes lie in a plane\n\t(represented here by the red plane). Repeat for the green and blue points, and you'll\n\tsee that they all intersect in a line. This is where the common axis must lie.\n\n\tI hope you learn as much as much as I did making this shader, and I hope that you all\n\tlearn a ton of new interesting things after this Shadertoy challenge is over!\n*/\n\n// Instructions: Pause and rewind back to 0.0 seconds.\n// There are 3 sliders on the side. These compose rotations of the sphere around the x,y,and z axes.\n// Observe the how there's always an axis\n// Press play to see the actual rotation\n\n#define PI 3.14159\n#define inf 80000.0\n\n#define SPHERE_TRANSLUC 0.8\n#define AXIS_TRANSLUC 0.8\n#define PLANE_TRANSLUC 0.4\n\n//------------------------------------------------------------------\n// Utilities\n//------------------------------------------------------------------\nvoid pR(inout vec2 p, float a)\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nbool xor(bool a, bool b)\n{\n    return (a || b) && (a != b);\n}\n\n// shoutouts to the amazing tool at\n//   http://dev.thi.ng/gradients/\n// for generating these color palettes\nvec3 color(float t)\n{\n    vec3 a = vec3(0.660, 0.560, 0.680);\n    vec3 b = vec3(0.718, 0.438, 0.720);\n    vec3 c = vec3(0.520, 0.800, 0.520);\n    vec3 d = vec3(-0.430, -0.397, -0.083);\n    \n    vec3 ret = a + b * cos(2.0 * 3.14159 * (c * t + d));\n    return clamp(ret, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------\n// Primatives\n//------------------------------------------------------------------\nfloat fPlane(vec3 p, vec3 r, vec3 n)\n{\n    if (abs(dot(n, r)) < 0.001)\n        return inf;\n    float t = dot(n, p) / dot(n, r);\n    if (t < 0.)\n        return inf;\n    return t;\n}\nfloat fSphere(vec3 p, vec3 ray, float rad)\n{\n    float totalL = dot(ray, p);\n    \n    vec3 closestToCenter = ray * totalL;\n    vec3 dO = p - closestToCenter;\n    float O = length(dO);\n    \n    if (O > rad)\n        return inf;\n    \n    float adj = sqrt(rad*rad - O*O);\n    \n    if (-adj > totalL)\n        return inf;\n    \n    if (-adj < totalL && totalL < adj)\n        return totalL + adj;\n    return totalL - adj;\n}\n\n// stolen from iq's shader: https://www.shadertoy.com/view/MtcXRf\nvec4 iCylinder( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, in float ra ) // point a, point b, radius\n{\n    // center the cylinder, normalize axis\n    vec3 cc = 0.5*(pa+pb);\n    float ch = length(pb-pa);\n    vec3 ca = (pb-pa)/ch;\n    ch *= 0.5;\n\n    vec3  oc = ro - cc;\n\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - ra*ra;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(-1.0);\n    h = sqrt(h);\n    float t1 = (-b-h)/a;\n    //float t2 = (-b+h)/a; // exit point\n\n    float y = caoc + t1*card;\n\n    // body\n    if( abs(y)<ch ) return vec4( t1, normalize( oc+t1*rd - ca*y ) );\n    \n    // caps\n    float sy = sign(y);\n    float tp = (sy*ch - caoc)/card;\n    if( abs(b+a*tp)<h )\n    {\n        return vec4( tp, ca*sy );\n    }\n\n    return vec4(-1.0);\n}\n\n//------------------------------------------------------------------\n// Rendering utilities\n//------------------------------------------------------------------\nvec3 rotatePt(vec3 pt)\n{\n    vec3 ang = texture(iChannel1, vec2(0.25, 0.5)).xyz * 2. * PI;\n    \n    pR(pt.yz, ang.x);\n    pR(pt.xz, ang.y);\n    pR(pt.xy, ang.z);\n    \n    return pt;\n}\nvec3 rotatePtInv(vec3 pt)\n{\n    vec3 ang = texture(iChannel1, vec2(0.25, 0.5)).xyz * 2. * PI;\n    \n    pR(pt.xy, -ang.z);\n    pR(pt.xz, -ang.y);\n    pR(pt.yz, -ang.x);\n    \n    return pt;\n}\nvec3 rotatePtInv_2(vec3 pt, float t)\n{\n    vec3 N = vec3(1,0,0);\n    vec3 N2 = rotatePt(N);\n    \n    vec3 M = vec3(0,0,1);\n    vec3 M2 = rotatePt(M);\n    \n    vec3 y_d = normalize(cross(N2 - N, M2 - M));\n    vec3 x_d = normalize(N - y_d * dot(y_d, N));\n    vec3 z_d = normalize(cross(x_d, y_d));\n    \n    mat3 CoB = mat3(x_d, y_d, z_d);\n    pt = inverse(CoB) * pt;\n    vec3 N2_2 = inverse(CoB) * N2;\n    \n    float angle = atan(N2_2.z, N2_2.x) * t;\n    \n    pR(pt.xz, angle * t);\n    //pR(pt.xz, PI/2.);\n    \n    pt = CoB * pt;\n    \n    return pt;\n}\n\nvec3 colSphere(vec3 pt, float c1, float c2, bool justChars)\n{\n    float azimuth = acos(pt.y) * 5. / PI;\n    float theta = atan(pt.z, pt.x) * 4. / PI;\n    vec3 q = vec3(theta, 0, -azimuth);\n    vec3 albedo;\n    \n    // colored pattern\n    bool b1 = texture(iChannel0, vec2(q.x + 4., q.z) / 16.).x > 0.5;\n    bool b2 = xor(mod(q.x, 2.0) < 1.0, mod(q.z, 2.0) < 1.0);\n    if (justChars)\n    {\n        if (b1)\n            albedo = color(c1);\n    }\n    else\n    {\n        if (xor(b1, b2))\n            albedo = color(c1);\n        else\n            albedo = color((c1+c2)/2.);\n    }\n    \n    if (length(pt - vec3(1,0,0)) < 0.1)\n        albedo = vec3(1,0,0);\n    if (length(pt - vec3(0,1,0)) < 0.1)\n        albedo = vec3(0,1,0);\n    if (length(pt - vec3(0,0,1)) < 0.1)\n        albedo = vec3(0,0,1);\n    \n    return albedo;\n}\nfloat fresnel(vec3 ray, vec3 norm, float f)\n{\n    // my dumb fresnel. not physically accurate. sue me.\n    return f + 0.25 * f * (1. - abs(dot(-ray, norm)) );\n    //return 0.5;\n}\n\nfloat rotatingPlaneFunc(vec3 pt)\n{\n    vec3 N = vec3(1,0,0);\n    vec3 N2 = rotatePt(N);\n    \n    vec3 o = (N + N2)/2.;\n    \n    vec3 x = normalize(o);\n    vec3 y = normalize(N2 - N);\n    vec3 z = cross(x, y);\n    \n    mat3 m = mat3(x, y, z);\n    \n    vec3 ray = vec3(1,0,0);\n    pR(ray.xz, iTime);\n    ray = m * ray;\n    \n    return dot(ray, pt - o);\n}\n\n//------------------------------------------------------------------\n// Storyboard functions\n//------------------------------------------------------------------\nfloat story_ring_transluc()\n{\n    return smoothstep(1., 2., iTime) * (1. - smoothstep(18., 19., iTime));\n}\nfloat story_pole_transluc()\n{\n    return smoothstep(6., 7., iTime) * (1. - smoothstep(18., 19., iTime));\n}\nfloat story_redplane_transluc()\n{\n    return smoothstep(12., 13., iTime);\n}\nfloat story_greenblueplane_transluc()\n{\n    return smoothstep(19., 20., iTime);\n}\nfloat story_axis_transluc()\n{\n    return smoothstep(21., 22., iTime);\n}\nfloat story_sphere_rotate()\n{\n    return step(23., iTime) * pow(sin(iTime - 23.), 2.);\n}\n\n//------------------------------------------------------------------\n// Rendering\n//------------------------------------------------------------------\nfloat trace(vec3 pt, vec3 ray, out vec3 norm, out vec3 color, out float fres)\n{\n    float bt = inf;\n    norm = -ray;\n    color = vec3(0,0,0);\n    fres = 0.5;\n    \n    // the sphere\n    {\n        float t = fSphere(-pt, ray, 1.);\n        if (t < bt)\n        {\n            bt = t;\n            vec3 p = pt + ray * t;\n            norm = normalize(pt);\n            fres = fresnel(ray, norm, SPHERE_TRANSLUC);\n            \n            vec3 p2 = rotatePtInv(p);\n            vec3 p3 = rotatePtInv_2(p, story_sphere_rotate() );\n            vec3 red = colSphere(p2, 0.7, 0., true);\n            color = mix(colSphere(p3, 0.4, 0.2, false), red, length(red));\n            \n            vec3 ring_color = mix(vec3(1,0,0), color, smoothstep(0., 0.02, abs(rotatingPlaneFunc(p)) ));\n            color = mix(color, ring_color, story_ring_transluc());\n        }\n    }\n    \n    // Planes\n    if (story_greenblueplane_transluc() > 0.001)\n    {\n        vec3 N = vec3(0, 1, 0);\n        vec3 N2 = rotatePt(N);\n        vec3 n = normalize(N - N2);\n        \n        float t = fPlane(-pt, ray, n );\n        vec3 p = pt + ray * t;\n        if (length(p) < 1.2 && t < bt)\n        {\n            bt = t;\n            norm = n;\n            fres = fresnel(ray, norm, story_greenblueplane_transluc() * PLANE_TRANSLUC);\n            color = vec3(0,1,0);\n        }\n    }\n    \n    if (story_redplane_transluc() > 0.001)\n    {\n        vec3 N = vec3(1, 0, 0);\n        vec3 N2 = rotatePt(N);\n        vec3 n = normalize(N - N2);\n        \n        float t = fPlane(-pt, ray, n );\n        vec3 p = pt + ray * t;\n        if (length(p) < 1.2 && t < bt)\n        {\n            bt = t;\n            norm = n;\n            fres = fresnel(ray, norm, story_redplane_transluc() * PLANE_TRANSLUC);\n            color = vec3(1,0,0);\n        }\n    }\n    \n    if (story_greenblueplane_transluc() > 0.001)\n    {\n        vec3 N = vec3(0, 0, 1);\n        vec3 N2 = rotatePt(N);\n        vec3 n = normalize(N - N2);\n        \n        float t = fPlane(-pt, ray, n );\n        vec3 p = pt + ray * t;\n        if (length(p) < 1.2 && t < bt)\n        {\n            bt = t;\n            norm = n;\n            fres = fresnel(ray, norm, story_greenblueplane_transluc() * PLANE_TRANSLUC);\n            color = vec3(0,0,1);\n        }\n    }\n    \n    // Axis\n    if (story_axis_transluc() > 0.001)\n    {\n        vec3 N = vec3(1,0,0);\n        vec3 N2 = rotatePt(N);\n\n        vec3 M = vec3(0,1,0);\n        vec3 M2 = rotatePt(M);\n\n        vec3 y_d = normalize(cross(M2 - M, N2 - N));\n        \n        vec4 t = iCylinder(pt, ray, y_d * 1.5, -y_d * 1.5, 0.05);\n        if (t.x > 0. && t.x < bt)\n        {\n            bt = t.x;\n            norm = t.yzw;\n            fres = fresnel(ray, norm, story_axis_transluc() * AXIS_TRANSLUC);\n            color = vec3(1);\n        }\n    }\n    \n    // rotating axis\n    if (story_pole_transluc() > 0.001) // to get rid of the subtle artifacts\n    {\n        vec3 N = vec3(1,0,0);\n        vec3 N2 = rotatePt(N);\n\n        vec3 o = (N + N2)/2.;\n\n        vec3 x = normalize(o);\n        vec3 y = normalize(N2 - N);\n        vec3 z = cross(x, y);\n\n        mat3 m = mat3(x, y, z);\n\n        vec3 y_d = vec3(1,0,0);\n        pR(y_d.xz, iTime);\n        y_d = m * y_d;\n        \n        vec4 t = iCylinder(pt, ray, y_d * 1.5, -y_d * 1.5, 0.05);\n        if (t.x > 0. && t.x < bt)\n        {\n            bt = t.x;\n            norm = t.yzw;\n            fres = fresnel(ray, norm, story_pole_transluc());\n            color = vec3(1);\n        }\n    }\n    \n    return bt;\n}\n\nvec3 render(vec2 uv)\n{\n    //float mouseU = 2. * PI * 2. * (iMouse.x / iResolution.x - 0.5);\n    //float mouseV = PI * (iMouse.y / iResolution.y) - PI/2.;\n    float mouseU = 4. * PI * texture(iChannel1, vec2(0.75, 0.5)).x;\n    float mouseV = PI * texture(iChannel1, vec2(0.75, 0.5)).y - PI/2.;\n    \n    vec3 pxl = vec3(uv, 1.5);\n    vec3 origin = vec3(0, 0, -3);\n    \n    // rotate\n    pR(origin.yz, mouseV);\n    pR(pxl.yz, mouseV);\n    \n    pR(origin.xz, mouseU);\n    pR(pxl.xz, mouseU);\n    \n    vec3 ray = normalize(pxl);\n    \n    vec3 pt = origin;\n    vec3 norm, color = vec3(0);\n    float t, fres = 1.;\n    \n    for (int i = 0; i < 5; ++i)\n    {\n        vec3 c;\n        float f;\n        t = trace(pt, ray, norm, c, f);\n        if (t > 20.)\n        {\n            color += vec3(0.5) * fres;\n            break;\n        }\n        color += c * f * fres;\n        //color = c;\n        fres *= (1. - f);\n        pt += ray * (t + 0.01);\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = fragCoord.xy / iResolution.y - vec2(iResolution.x/iResolution.y/2., 0.5);\n    vec3 final;\n\n    vec2 res = vec2(iResolution.x * 0.85, iResolution.y);\n    vec2 uv = 2.*fragCoord.xy / res.y - vec2(res.x/res.y, 1.);\n    \n    // because apparently these are mandatory now\n    float distSqr = dot(uv/2.2, uv/2.);\n\tfloat vignette = 1.0 - distSqr;\n    \n    final = render(uv) * vignette;\n    \n    uv = fragCoord.xy / iResolution.xy;\n    vec3 ang = texture(iChannel1, vec2(0.25, 0.5)).xyz;\n    if (uv.x > 0.85)\n    {\n        final = mix(vec3(1), final, 0.1);\n        \n        if (uv.x < 0.9)\n        {\n            final = mix(final, color(0.1), step(uv.y, ang.x) * 0.2);\n            final = mix(color(0.9), final, pow(smoothstep(0., 0.005, abs(uv.y - ang.x)), 4.) );\n        }\n        else if (uv.x < 0.95)\n        {\n            final = mix(final, color(0.1), step(uv.y, ang.y) * 0.2);\n            final = mix(color(0.9), final, pow(smoothstep(0., 0.005, abs(uv.y - ang.y)), 4.) );\n        }\n        else\n        {\n            final = mix(final, color(0.1), step(uv.y, ang.z) * 0.2);\n            final = mix(color(0.9), final, pow(smoothstep(0., 0.005, abs(uv.y - ang.z)), 4.) );\n        }\n        \n        final = mix(color(0.1), final, pow(smoothstep(0., 0.005, abs(uv.x - 0.85)), 4.) );\n        final = mix(color(0.1), final, pow(smoothstep(0., 0.005, abs(uv.x - 0.90)), 4.) );\n        final = mix(color(0.1), final, pow(smoothstep(0., 0.005, abs(uv.x - 0.95)), 4.) );\n        final = mix(color(0.1), final, pow(smoothstep(0., 0.005, abs(uv.x - 1.00)), 4.) );\n    }\n    \n\tfragColor = vec4(final, 1.0);\n    //fragColor = texture(iChannel1, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragColor = vec4(0.0,0.0,1.0,1.0);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    vec3 final = texture(iChannel0, uv).xyz;\n    \n    if (length(iMouse.xy) < 20.)\n    {\n        if (uv.x < 0.5)\n        {\n            fragColor = vec4(0.2, 0.58, 0.5, 1);\n            return;\n        }\n        else\n        {\n            fragColor = vec4(0.35, 0.5, 0, 0);\n            return;\n        }   \n    }\n    \n    if (uv.x < 0.5 && m.x > 0.85)\n    {\n        //final = vec3(0.5, 0.3, 0.8);\n        //final = vec3(0);\n        \n        if (m.x > 0.85)\n        {\n            if (m.x < 0.9)\n            {\n                final.x = m.y;\n            }\n            else if (m.x < 0.95)\n            {\n                final.y = m.y;\n            }\n            else\n            {\n                final.z = m.y;\n            }\n        }\n    }\n    else if (uv.x >= 0.5 && m.x < 0.85)\n        final = vec3(m, 1.);\n    \n    fragColor = vec4(final, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}