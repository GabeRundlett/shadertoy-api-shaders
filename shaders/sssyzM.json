{
    "Shader": {
        "info": {
            "date": "1642764403",
            "description": "Simple Ray-tracer",
            "flags": 48,
            "hasliked": 0,
            "id": "sssyzM",
            "likes": 0,
            "name": "Ray-tracer by LinusDev",
            "published": 3,
            "tags": [
                "raytracer"
            ],
            "usePreview": 0,
            "username": "Pro_Coder",
            "viewed": 211
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 bufA = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 postProcessingData = GET(iChannel1, POST_PROC_TEXEL);\n\n    vec3 col = abs(bufA.rgb);\n    \n    // Output to screen\n    fragColor = vec4(min(col, col / postProcessingData.a ),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "Light lights[] = Light[](\n  //Light(vec3(5., 13., 0.), vec3(0.,0., 1.), vec3(0.0), 0.0),\n  //Light(vec3(0., 13., 5.), vec3(1., 0., 0.), vec3(0.0), 0.0),\n  //Light(vec3(0., 7., 0.), vec3(0., 1., 0.), vec3(0.0), 0.0)\n  Light(vec3(0., 13., 0.), vec3(3., 3., 3.), vec3(0.0), 0.0)\n);\n\n\nfloat getDistance(vec3 pos, out uint hitId){\n    hitId = 0u;\n    float dis = RENDER_DISTANCE;\n    \n    float disYPlane = abs(pos.y+0.1)-0.1;\n    float disBox1 = sdfBox(pos, vec3(0., 0.5, 0.), vec3(1.));\n    float disBox2 = sdfBox(pos, vec3(3.5, 5., 0.), vec3(1., 10., 10.));\n    float disBox3 = sdfBox(pos, vec3(-2, 5., -5.5), vec3(10., 10., 1.));\n    \n    mmin(dis, disYPlane, hitId, GROUND_ID, 0u);\n    \n    mmin(dis, sdfSphere(pos, vec3(0.0, 4.0, 0.0), 1.6), hitId, SUN_ID, 0u);\n    mmin(dis, sdfSphere(pos, EARTH_POS, 0.5), hitId, EARTH_ID, 0u);\n    mmin(dis, sdfSphere(pos, MOON_POS, 0.20), hitId, MOON_ID, 0u);\n    \n    return dis;\n}\n\nfloat getDistance(vec3 pos){\n    uint a;\n    return getDistance(pos, a);\n}\n\nvec3 getNormal(vec3 p){\n \tfloat d = getDistance(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(getDistance(p - e.xyy), getDistance(p - e.yxy), getDistance(p - e.yyx));\n    return normalize(n);\n}\n\nHit rayMarch(Ray r){\n    \n    Hit hit = Hit(r.o, 0.0, NO_HIT_ID);\n    \n    float dis = 1000.;\n    for(uint i = 0u; i < MAX_STEPS; i++){\n        dis = getDistance(hit.pos, hit.id);\n        hit.dis += dis;\n        \n        hit.pos = r.o + r.d * hit.dis;\n        \n        if(dis < MIN_DISTANCE || hit.dis >= r.md){\n            break;\n        }\n    }\n    \n    if(dis > MIN_DISTANCE) {\n        hit.id = NO_HIT_ID;\n    }\n    \n    return hit;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //coordinates from -1 to 1. x coordinates may exceed 1.\n    vec2 uv = (fragCoord - iResolution.xy*.5) / (iResolution.yy*.5);\n    vec4 col = vec4(0.0);\n\n    //read Vars\n    vec4 camPosition = GET(iChannel1, CAM_POS_TEXEL); //xyz = pos; w = distance to screen\n    vec4 viewDirection = GET(iChannel1, VIEW_DIR_TEXEL);\n    \n    //calc ray Direction\n    vec3 screenXVector = cross(viewDirection.xyz, UP_VECTOR);\n    vec3 screenYVector = -cross(viewDirection.xyz, screenXVector);\n    \n    vec3 rayDirection = viewDirection.xyz * camPosition.w + screenXVector * uv.x + screenYVector  * uv.y;   \n    rayDirection = normalize(rayDirection);\n    \n    \n    Hit hit = rayMarch(Ray(camPosition.xyz, rayDirection, RENDER_DISTANCE));\n    \n    if(hit.id != NO_HIT_ID){\n        if(hit.id == GROUND_ID){\n            col.rgb = vec3(.6, 0.4, 0.25);\n        }else if(hit.id == SUN_ID){\n            col.rgb = vec3(0.9, 0.9, 0.2);\n        }else if(hit.id == EARTH_ID){\n            col.rgb = vec3(.3, .7, 1.);\n        }else if(hit.id == MOON_ID){\n            col.rgb = vec3(.7);\n        }\n        \n        vec3 normal = getNormal(hit.pos);\n        vec3 lightColor = vec3(0.0);\n        \n        for(int i = 0; i < lights.length(); i++){\n            Light light = lights[i];\n         \n            \n            vec3 dir = light.position - hit.pos;\n            float dis = length(dir);\n            dir = normalize(dir);\n            Hit lHit = rayMarch(Ray(hit.pos + normal*0.001, dir, dis));\n            \n            if(lHit.id == NO_HIT_ID){\n                \n                float angleFact = dot(normal, dir);\n                float disFact = 1. / (1. + dis*dis*.001);\n                \n                float inte = angleFact*disFact;\n\n                lightColor += light.color * inte;       \n              \n            }\n            \n        }\n        \n        col.rgb *= lightColor;\n        \n        //col.rgb = abs(normal);\n    }else {\n        col.rgb = vec3(0.3, 0.6, 0.8)*3.;\n    }\n\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n *\n *\n * World Stuff\n *\n *\n */\n#define UP_VECTOR vec3(0., 1., 0.)\n\n#define CAM_START_POS vec3(10., 8., 0.)\n#define CAM_START_DIS_TO_SCREEN 1.\n#define CAM_START_LOOK_AT_POSITION vec3(1., 1., 1.)\n\n/*\n *\n *\n * Constants\n *\n *\n */\n#define PI 3.14\n\n/*\n *\n *\n * Vars\n *\n *\n */\n#define DO_SAVE(texel) (ivec2(fragCoord) == texel)\n#define GET(buffer, texel) (texelFetch(buffer, texel, 0))\n\n#define CAM_POS_TEXEL   ivec2(0, 0)\n#define VIEW_DIR_TEXEL  ivec2(0, 1)\n#define GI_DATA         ivec2(0, 2)\n#define POST_PROC_TEXEL ivec2(0, 3)\n\n/*\n *\n *\n * Ray-tracer\n *\n *\n */\n#define MIN_DISTANCE 0.0001\n#define MAX_STEPS 1000u\n#define RENDER_DISTANCE 100.\n\nfloat vmax(vec3 a){\n    return max(a.z, max(a.x, a.y));\n}\nfloat sdfBox(vec3 pos, vec3 center, vec3 size){\n    pos -= center;\n    vec3 d = abs(pos) - size*.5;\n    float m = (vmax(d));\n    return max(length(min(sign(d) + vec3(1.), 1.) * d), abs(m)) * sign(m);\n}\nfloat sdfSphere(vec3 pos, vec3 center, float radius){\n    return length(pos-center)-radius;\n}\n\n\n\n/*void mmin(inout float dis, float b, inout uint id, uint idB, uint ignoreId) {\n    if(dis < b || ignoreId == idB) return;\n    dis = b;\n    id = idB;\n}*/\n\n#define mmin(currentDis, thisDis, currentId, thisId, ignoreId) if(thisId != ignoreId && currentDis > thisDis) {currentDis = thisDis; currentId = thisId;}\n\nvoid mmin2(inout float dis, float b, inout uint id, uint idB, uint ignoreId, uint inverseId) {\n    if(idB == inverseId) b = -b;\n    if(dis < b || ignoreId == idB) return;\n    dis = b;\n    id = idB;\n}\n\n//Distance function\n#define NO_HIT_ID 0u\n\n#define GROUND_ID 4u\n\n#define SUN_ID 1u\n\n#define EARTH_ID 2u\n#define EARTH_POS vec3(sin(iTime)*5., 4.0, cos(iTime)*5.)\n\n#define MOON_ID 3u\n#define MOON_POS (EARTH_POS + vec3(sin(iTime*2.), 0.0, cos(iTime*2.)))\n\n\n//Ray marching\n\nstruct Ray {\n    vec3 o;//origin\n    vec3 d;//distance\n    float md;//max distance\n};\n\nstruct Hit {\n    vec3 pos;\n    float dis;\n    uint id;\n};\n\n\n//light\n\nstruct Light{\n    vec3 position;\n    vec3 color;\n    vec3 direction;  //spotlight only\n    float angle;     //spotlight only\n    \n};\n\n/*\n *\n *\n * Functions\n *\n *\n */\n\nmat3 rotAroundYAxis(float angle){\n   return mat3( cos(angle) , 0.,  sin(angle),\n                0.         , 1.,  0.        ,\n                -sin(angle), 0.,  cos(angle)); \n}\n\nmat3 rotAroundZAxis(float angle){\n   return mat3( cos(angle) , -sin(angle), 0.,\n                sin(angle) , cos(angle) , 0.,\n                0.         , 0.         , 1.); \n}\n\nmat3 rotAroundXAxis(float angle){\n   return mat3( 1. , 0.         , 0.         ,\n                0. , cos(angle) , -sin(angle),\n                0. , sin(angle) , cos(angle)); \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//Keyboard and storage buffer\n\n\n#define MOVE_SPEED 0.5\n\n//Keyboard\n#define NUMBER_OF_KEYS 256.\n#define IS_PRESSED 0.0\n#define ON_PRESS 0.5\n#define BUFFFER_PRESS 1.0\n\n#define KEY_TAB 10./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_ENTER 14./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_SHIFT 17./NUMBER_OF_KEYS - 1./512.\n#define KEY_CTRL 18./NUMBER_OF_KEYS - 1./512.\n#define KEY_ALT 19./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_SPACE 33./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_ARROW_LEFT 38./NUMBER_OF_KEYS - 1./512.\n#define KEY_ARROW_UP 39./NUMBER_OF_KEYS - 1./512.\n#define KEY_ARROW_RIGHT 40./NUMBER_OF_KEYS - 1./512.\n#define KEY_ARROW_DOWN 41./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_0 49./NUMBER_OF_KEYS - 1./512.\n#define KEY_1 50./NUMBER_OF_KEYS - 1./512.\n#define KEY_2 51./NUMBER_OF_KEYS - 1./512.\n#define KEY_3 52./NUMBER_OF_KEYS - 1./512.\n#define KEY_4 53./NUMBER_OF_KEYS - 1./512.\n#define KEY_5 54./NUMBER_OF_KEYS - 1./512.\n#define KEY_6 55./NUMBER_OF_KEYS - 1./512.\n#define KEY_7 56./NUMBER_OF_KEYS - 1./512.\n#define KEY_8 57./NUMBER_OF_KEYS - 1./512.\n#define KEY_9 58./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_NUMPAD_0 97./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_1 98./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_2 99./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_3 100./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_4 101./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_5 102./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_6 103./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_7 104./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_8 105./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_9 106./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_GREATER 61./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_SS 64./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_A 66./NUMBER_OF_KEYS - 1./512.\n#define KEY_B 67./NUMBER_OF_KEYS - 1./512.\n#define KEY_C 68./NUMBER_OF_KEYS - 1./512.\n#define KEY_D 69./NUMBER_OF_KEYS - 1./512.\n#define KEY_E 70./NUMBER_OF_KEYS - 1./512.\n#define KEY_F 71./NUMBER_OF_KEYS - 1./512.\n#define KEY_G 72./NUMBER_OF_KEYS - 1./512.\n#define KEY_H 73./NUMBER_OF_KEYS - 1./512.\n#define KEY_I 74./NUMBER_OF_KEYS - 1./512.\n#define KEY_J 75./NUMBER_OF_KEYS - 1./512.\n#define KEY_K 76./NUMBER_OF_KEYS - 1./512.\n#define KEY_L 77./NUMBER_OF_KEYS - 1./512.\n#define KEY_M 78./NUMBER_OF_KEYS - 1./512.\n#define KEY_N 79./NUMBER_OF_KEYS - 1./512.\n#define KEY_O 80./NUMBER_OF_KEYS - 1./512.\n#define KEY_P 81./NUMBER_OF_KEYS - 1./512.\n#define KEY_Q 82./NUMBER_OF_KEYS - 1./512.\n#define KEY_R 83./NUMBER_OF_KEYS - 1./512.\n#define KEY_S 84./NUMBER_OF_KEYS - 1./512.\n#define KEY_T 85./NUMBER_OF_KEYS - 1./512.\n#define KEY_U 86./NUMBER_OF_KEYS - 1./512.\n#define KEY_V 87./NUMBER_OF_KEYS - 1./512.\n#define KEY_W 88./NUMBER_OF_KEYS - 1./512.\n#define KEY_X 89./NUMBER_OF_KEYS - 1./512.\n#define KEY_Y 90./NUMBER_OF_KEYS - 1./512.\n#define KEY_Z 91./NUMBER_OF_KEYS - 1./512.\n\n//example isKey(KEY_A, IS_PRESSED)\nbool isKey(float checkKey, float type, sampler2D channel){\n    return texture( channel, vec2(checkKey, type)).r > 0.0;\n}\n\n#define KEYBOARD_CHANNEL iChannel0\n#define BACK_BUFFER_CHANNEL iChannel1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n     \n    if(iFrame > 0) {\n        if(DO_SAVE(POST_PROC_TEXEL)){\n            vec4 oldData = GET(BACK_BUFFER_CHANNEL, POST_PROC_TEXEL);\n            \n            #define M_P_TEX(channel, x, y) (pow(texture(channel, vec2(x, y)).rgb + 1., vec3(1.5)) - 1.)\n            #define M_P_AVG(c, m) (0.25 * M_P_TEX(c, m, m) + 0.25 * M_P_TEX(c, m, 1.-m) + 0.25 * M_P_TEX(c, 1.-m, m) + 0.25 * M_P_TEX(c, 1.-m, 1.-m))\n            \n            vec3 a1 = M_P_AVG(iChannel2, 0.1);\n            vec3 a2 = M_P_AVG(iChannel2, 0.2);\n            vec3 a3 = M_P_AVG(iChannel2, 0.3);\n            vec3 a4 = M_P_AVG(iChannel2, 0.4);\n            vec3 b1 = M_P_AVG(iChannel2, 0.42);\n            vec3 c1 = M_P_AVG(iChannel2, 0.43);\n            vec3 c2 = M_P_AVG(iChannel2, 0.44);\n            vec3 c3 = M_P_AVG(iChannel2, 0.45);\n            vec3 c4 = M_P_AVG(iChannel2, 0.46);\n            vec3 c5 = M_P_AVG(iChannel2, 0.47);\n            vec3 c6 = M_P_AVG(iChannel2, 0.48);\n            \n            vec3 res = .15 * a1 + .15 * a2 + .15 * a3 + .15 * a4\n                        + 0.0571 * b1\n                        + 0.0571 * c1\n                        + 0.0571 * c2\n                        + 0.0571 * c3\n                        + 0.0571 * c4\n                        + 0.0571 * c5\n                        + 0.0571 * c6;\n\n            oldData.rgb = mix(oldData.rgb, res, 0.03);\n            oldData.a = min(vmax(oldData.rgb), 2.5);\n            fragColor = oldData;\n        }\n        else if(DO_SAVE(GI_DATA)){\n            vec4 data = GET(BACK_BUFFER_CHANNEL, GI_DATA);\n            if(isKey(KEY_R, IS_PRESSED, KEYBOARD_CHANNEL)){\n                fragColor = vec4(1., float(iFrame), 0., 0.);\n            }else{\n                fragColor = vec4(0., data.y, 0., 0.);\n            }\n            \n        }\n        else if(DO_SAVE(CAM_POS_TEXEL)){\n            vec4 pos = GET(BACK_BUFFER_CHANNEL, CAM_POS_TEXEL);\n            vec4 vdir = GET(BACK_BUFFER_CHANNEL, VIEW_DIR_TEXEL);\n            vec2 v = normalize(vdir.xz);\n            vec2 t = normalize(cross(UP_VECTOR, vdir.xyz)).xz;\n    \n            float speed = MOVE_SPEED;\n            \n            //move cam\n            if(isKey(KEY_W, IS_PRESSED, KEYBOARD_CHANNEL)){//forward\n                pos.xz += v * speed;\n            }\n            if(isKey(KEY_S, IS_PRESSED, KEYBOARD_CHANNEL)){//backward\n                pos.xz -= v * speed;\n            }\n            if(isKey(KEY_A, IS_PRESSED, KEYBOARD_CHANNEL)){//left\n                pos.xz += t * speed;\n            }\n            if(isKey(KEY_D, IS_PRESSED, KEYBOARD_CHANNEL)){//right\n                pos.xz -= t * speed;\n            }\n            if(isKey(KEY_SHIFT, IS_PRESSED, KEYBOARD_CHANNEL)){\n                pos.y -= 1.0 * speed;\n            }\n            if(isKey(KEY_SPACE, IS_PRESSED, KEYBOARD_CHANNEL)){\n                pos.y += 1.0 * speed;\n            }\n            \n            //Zoom\n            if(isKey(KEY_C, IS_PRESSED, KEYBOARD_CHANNEL)){\n                pos.w *= 1.052631578947368;\n            }\n            if(isKey(KEY_X, IS_PRESSED, KEYBOARD_CHANNEL)){\n                pos.w *= 0.95;\n            }\n            \n            fragColor = pos;\n            return;\n            \n        }else if(DO_SAVE(VIEW_DIR_TEXEL)){\n            vec4 viewDirection = GET(BACK_BUFFER_CHANNEL, VIEW_DIR_TEXEL);\n            \n            if(iMouse.z > 0.0){\n                vec2 nxz = normalize(vec2(viewDirection.z, viewDirection.x));\n                float angleXZ = atan(nxz.x, nxz.y);\n                \n                angleXZ += ((iMouse.x-iResolution.x*.5)/iResolution.x)*PI*0.05;\n                viewDirection.a -= ((iMouse.y-iResolution.y*.5)/iResolution.x)*PI*0.05; // angle XY\n                \n                viewDirection.a = clamp(viewDirection.a, -PI/2., PI/2.);\n               \n                viewDirection.xyz = rotAroundYAxis(angleXZ) * rotAroundZAxis(viewDirection.a) * vec3(1., 0., 0.);\n            }\n               \n            \n            fragColor = viewDirection;\n            return;    \n        }\n         \n    }else{\n         //initial values\n         if(DO_SAVE(CAM_POS_TEXEL)){\n            fragColor = vec4(CAM_START_POS, CAM_START_DIS_TO_SCREEN);\n\n         }else if(DO_SAVE(VIEW_DIR_TEXEL)){\n            vec3 viewDirection = normalize(CAM_START_LOOK_AT_POSITION - CAM_START_POS);\n            fragColor = vec4(viewDirection, 0.0);\n\n         }    \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}