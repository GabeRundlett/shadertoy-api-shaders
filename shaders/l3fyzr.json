{
    "Shader": {
        "info": {
            "date": "1725726376",
            "description": "originals  https://glslsandbox.com/e#74643.0 https://www.shadertoy.com/view/stsXDl",
            "flags": 0,
            "hasliked": 0,
            "id": "l3fyzr",
            "likes": 5,
            "name": "magic circles 42",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 78
        },
        "renderpass": [
            {
                "code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*0.5+.5)\nconst int N = 4;\nfloat sdPolygon( in vec2[N] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=N-1; i<N; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\nfloat PI = 3.14159;\nfloat TAU = 2.*3.14159;\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define time iTime\n\nfloat sdCapsule(vec3 p, float w, float r) {\n\tp.x -= clamp(p.x, -w, w);\n\treturn length(p) - r;\n}\n\nvec2 pmod(vec2 p, float r) {\n\tfloat n = radians(360.) / r;\n\tfloat a = atan(p.x, p.y) + n * .5;\n\ta = floor(a / n) * n;\n\treturn p * rot(a);\n}\n\nfloat heptagon(vec3 p, mat2 rotz) {\nmat2 roty = rot(time);\nmat2 rot0 = rot(0.);\nmat2 rot1 = rot(radians(180. / 7.));\n\n\tp.yx *= roty;\n\tp.xy *= rotz;\n\tp.xy = pmod(p.xy, 5.);\n\tp.y -= 1.;\n\treturn sdCapsule(p, 1., .12);\n}\n\nfloat map(vec3 p) {\nmat2 roty = rot(time);\nmat2 rot0 = rot(0.);\nmat2 rot1 = rot(radians(180. / 7.));\n\n\tfloat d = 1.;\n\td = min(d, heptagon(p, rot0));\n\td = min(d, heptagon(p, rot1));\n\tp.z -= 1.;\n\td = min(d, heptagon(p, rot0));\n\td = min(d, heptagon(p, rot1));\n\treturn d;\n}\n\n\n\n\n#define resolution iResolution.xy\n#define saturate(x) clamp(x,0.,1.)\n#define _tail2x(p,n) (mod(p,2.)-1.)\n\nfloat Hash( vec2 p, in float s ){\n    return fract(sin(dot(vec3(p.xy,10.0 * abs(sin(s))),vec3(27.1,61.7, 12.4)))*273758.5453123);\n}\n\nfloat noise(in vec2 p, in float s){\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  return mix(\n    mix(Hash(i + vec2(0.,0.), s), Hash(i + vec2(1.,0.), s),f.x),\n    mix(Hash(i + vec2(0.,1.), s), Hash(i + vec2(1.,1.), s),f.x),f.y) * s;\n}\n\nfloat fbm(vec2 p){\n  float v = 0.0;\n  v += noise(p*34., .1);\n  v += noise(p*20., .04);\n  return v;\n}\n\nvec2 mPolar(vec2 p){\n  float a = atan(p.y, p.x);\n  float r = length(p);\n  return vec2(a, r);\n}\n\nvec2 tailY2x(vec2 p,float n){p*=n;return vec2(p.x,_tail2x(p.y,n));}\n\n\nhighp float rand(vec2 p){\n  highp float a = 12.9898;\n  highp float b = 78.233;\n  highp float c = 43758.5453;\n  highp float dt= dot(p ,vec2(a,b));\n  highp float sn= mod(dt,3.14);\n  return fract(sin(sn) * c);\n}\n\n// signed distance\nfloat sd(float d,float r){return r-d;} \nfloat sd(float d){return 1.-d;} \n// glow + fill\nfloat gf(float d,float r){return r/d;} \nfloat gf(float d){return 1./d;} \n\nfloat fill_na(float d){return step(0.,d);}\nfloat fill(float d){return smoothstep(0.,0.01,d);}\nfloat stroke(float d,float w){return 1.-smoothstep(w,w+0.01,abs(d));}\nfloat strokeInner(float d,float w){return stroke(d-w,w);}\nfloat strokeOuter(float d,float w){return stroke(d+w,w);}\n\nfloat lSquare(vec2 p){p = abs(p);return max(p.x,p.y);}     \n\nfloat lPoly(vec2 p,float n){\n  float a = atan(p.x,p.y)+PI;\n  float r = TAU/n;\n  return cos(floor(.5+a/r)*r-a)*length(p)/cos(r*.5);\n}\n\nfloat strokeStar(vec2 p,float n,float w){\n  float l =strokeInner(sd(lPoly(p,n*.5)),w);\n  l+=strokeInner(sd(lPoly(mod(n,2.)!=0.?vec2(-p.x,p.y):p*rot(TAU/n),n*.5)),w);\n  return l;\n}\n\nvec2 mPoly(vec2 p,float n,float s){\n  float r = TAU / n;\n  float a = floor(atan(p.y,p.x)/r)*r+r*.5;\n  return (vec2(cos(a),sin(a))*s-p)*rot(-a-PI*.5);\n}\n\nfloat wsaw(float x){return fract(x*.5+.5)*2.-1.;}\nfloat wtri(float x){return abs(2.*fract(x*.5-.25)-1.)*2.-1.;}\nfloat utri(float x){return abs(2.*fract(x*.5-.5)-1.);}\nfloat wtrz(float x,float w){return clamp(wtri(x*2.)*w,-1.,1.);} // 台形波 trapezoidal wave\n\n// ease\nfloat o2(float t){t=1.-t;return 1.-t*t;}\nfloat oN(float t,float n){return 1.-pow(1.-t,n);}\n\nfloat dot2(vec2 p){return dot(p,p);}\n\nvec2 mSimplePerspective(vec2 p){p.y+=.2;p.y*=3.;return p;}\n\nfloat ring(vec2 p,float t){\n  float alpha =    fract(-t);\n  float l = 0.;\n  vec2 p3=mPoly(p*rot(PI*.5),1.,1.);\n\n  vec2 p4=mPolar(p*(.57-oN(t,1.3)*.28)).yx;\n  p4.x-=.65;\n  l+= saturate(abs(1./((p4.x + fbm( p4 + vec2(sin(t*.2),t*0.1))) * 50.0))*sd(dot2(tailY2x(p4+vec2(.1,0.),12.)),.9)*alpha);\n  return l;\n}\n\nfloat summoningCircle(vec2 p){\n  float l=0.;\n\n  l=saturate(l);\n  l-=fill(sd(lPoly(p,5.)));\n  l=saturate(l);\n\n  vec2 q=mPoly(p*rot(PI*3.5),3.,.5);\n  l+=fill(sd(lPoly(q,3.),.3));\n  vec2 q2=mPoly(p*rot(PI/3.+PI*.5),3.,.7);\n  l+=fill(sd(lPoly(q2,350.),.1));\n  l+=strokeInner(sd(lPoly(p*rot(PI),3.),.5),.02);\n  l+=fill(sd(length(p),.05));\n  vec2 q3=mPoly(p*rot(PI*.5),3.,1.);\n  l=saturate(l);\n  l-=fill(sd(length(q3),.2));\n\n\n  return l;\n}\n\nfloat render(vec2 p){\n  //p=mSimplePerspective(p);\n\n  p*=2.;\n  vec2 p2=p;\n  p2*=2.*cos(iTime);\n  float tt = time*.075;\n  float l2 = ring(p,o2(fract(tt)));\n  l2+=ring(p*rot(PI/3.),o2(fract(tt+.5)));\n  float l=0.;\n    float l3=0.;\n  l = summoningCircle(p*=rot((time*20.)/3.));\n  \n    l3 = summoningCircle(p2*=rot((-time*200.)/3.));\n  return l2+l+l3;\n}\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    \n    vec2 uv = ( C- .5* iResolution.xy ) /iResolution.y;\n   vec3 col = vec3(0.);   \n   float tt = fract(.3*iTime);\n     vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / 200.;\n  float l=0.;\n   float l2=0.;\n  l = (render(p)+render(p+vec2(0.,1./min(resolution.x, resolution.y))))*.5;\n    l2 = (render(p)+render(p*0.5+vec2(0.,3./max(resolution.x, resolution.y))))*0.25;\n   float scale =20.;\n \n   vec2 cellID = round(uv);\n\n \n\tvec3 rd = normalize(vec3(uv, 1.5));\n\tvec3 ro = vec3(0, 0, -5);\n\tvec3 color;\n\tfloat dist = 0.;\n\n\tfor (int i = 0; i < 20; i++) {\n\t\tvec3 p = ro + rd * dist;\n\t\tfloat d = map(p);\n\t\tif (d < .01) {\n\t\t\tcolor = vec3(1,1,2) * 2. / float(i);\n\t\t\tbreak;\n\t\t}\n\t\tdist += d;\n\t\tif (dist > 10.) break;\n\t}\n    \n   float nS = 2.;\n   float minVal = 1E20;\n   float nCheck = 1.;\n   for (float i = -nCheck; i <= nCheck; i++)\n     for(float j = -nCheck; j <= nCheck; j++){ \n       vec2 uvCenter = (cellID + vec2(i,j)) / scale;\n       float xCutoff = .7;\n       float yCutOff = xCutoff/(iResolution.x/iResolution.y);\n       if (abs(uvCenter.x) < xCutoff && abs(uvCenter.y) < yCutOff){\n         float centerDelta = TAU*(tt - 2.*length(uvCenter));\n         centerDelta = PI/2.;\n\n         float meshDim = clamp(.35 + .35*sin(centerDelta),0.,.5); \n         \n         vec2 p1 = uvCenter + vec2(-meshDim/scale,meshDim/scale);\n         vec2 p2 = uvCenter + vec2(-meshDim/scale,-meshDim/scale);\n         vec2 p3 = uvCenter + vec2(meshDim/scale,-meshDim/scale);\n         vec2 p4 = uvCenter + vec2(meshDim/scale,meshDim/scale);      \n         \n         float v1delta = TAU*(tt - 4.*length(p1)) + atan(p1.y,p1.x);\n         float v2delta = TAU*(tt - 4.*length(p2)) + atan(p2.y,p2.x);\n         float v3delta = TAU*(tt - 4.*length(p3)) + atan(p3.y,p3.x);\n         float v4delta = TAU*(tt - 4.*length(p4)) + atan(p4.y,p4.x);\n\n         vec2[4] verts; \n         float r = .5;\n         verts[0] = vec2(i,j) + vec2(-meshDim,meshDim) + vec2(r*cos(v1delta),r*sin(v1delta));\n         verts[1] = vec2(i,j) + vec2(-meshDim,-meshDim)+ vec2(r*cos(v2delta),r*sin(v2delta));\n         verts[2] = vec2(i,j) + vec2(meshDim, -meshDim)+ vec2(r*cos(v3delta),r*sin(v3delta));\n         verts[3] = vec2(i,j) + vec2(meshDim, meshDim) + vec2(r*cos(v4delta),r*sin(v4delta));\n         float poly = sdPolygon(verts, uv);\n         minVal = min(poly, minVal);\n       }\n     }\n     \n   \n     col += 1.035/abs(minVal);\n  \n        \n       \n    \n    \n    vec3 n1,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(0,.2,2.)*10.,H(g*.5),0.8)*1./e/8e3\n    )\n    {\n        n1=g*d+l;\n\n a=30.;\n n1.z+=iTime*10.;\n        n1=mod(n1-a,a*2.)-a;\n        s=3.;\n        n1.zx*=rot(iTime*0.1);\nn1.yx*=rot(iTime*0.1);\n        for(int i=0;i++<8;){\n        \n            n1=.23-abs(n1);\n            \n            n1.x<n1.z?n1=n1.zyx:n1;\n            n1.z<n1.y?n1=n1.xzy:n1;\n            s*=e=1.2+sin(iTime*.001)*.1;\n            n1=abs(n1)*e-\n                vec3(\n                    10.*3.+mod(C.y, 2.),\n                    120,\n                    2.*5.+mod(C.x+n1.z, 2.)\n                 )+color*+l*l2*vec3(l+l2*0.5,l+l2,l+l2*3.5);\n         }\n         g+=e=length(n1.yz)/s;\n    }\n    \n   O*= vec4(color*2.+mod(C.x, 2.)*mod(C.y, 2.), 1);\n   O+=vec4(vec3(l+l2*0.5,l+l2,l+l2*3.5),3.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}