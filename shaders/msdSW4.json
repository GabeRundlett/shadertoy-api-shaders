{
    "Shader": {
        "info": {
            "date": "1679850667",
            "description": "A rectangular tiling where the tile dimensions iin both axes increase proportional to the sequence 1,2,3,4...\n\nI think the method should work for any sequence of widths/heights if the sum of the sequence is invertible (maybe)\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "msdSW4",
            "likes": 12,
            "name": "Incrementally Spaced Tiling",
            "published": 3,
            "tags": [
                "grid",
                "tiling",
                "sum"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 240
        },
        "renderpass": [
            {
                "code": "// Rough explanation in one dimension:\n\n// Start with a sequence of widths, e.g. 1,2,3,4,5,...\n//\n// Get the sum of the widths up to n, e.g. S(n) = 0.5*n*(n+1.)\n//\n// Get the inverse of the sum to see which width corresponds to\n// this pixel\n// e.g. S^-1(x) = 0.5 + 0.5 * sqrt(1. + 8. * x)\n// and if W(x) = floor(S^-1(x)) == 5, then this pixel belongs to the\n// width 5 tile\n//\n// Get it's tile uv coordinates by finding the left side of \n// the tile S(W(x)) and compute (x - S(W(x))) / W(x)\n\n// https://www.desmos.com/calculator/akrsjxegis\n\n// Square distance\nfloat mlength(vec2 a) { return max(abs(a.x), abs(a.y)); }\n\nvoid mainImage( out vec4 O, in vec2 px )\n{\n    vec2 res = iResolution.xy;\n    float k = 1. / res.y;\n    vec2 uv = px / res.y;\n    \n    float t = iTime;\n    float t1 = min(20., t);                //  0-20 seconds\n    float t2 = min(20., max(0., t - 20.)); // 20-40 seconds\n    float t3 = max(0., t - 40.);           // 40-60 seconds\n    \n    // Scale with time\n    float sc = 4. + t1 * t1;\n    uv *= sc;\n    \n    // Traverse to show different properties   \n    uv   += 2. * t2 * t2;       \n    uv.x += 2. * t3 * t3;\n    \n    // Cell dimensions (inverse function of 0.5n(n+1))\n    vec2 dim = floor(0.5 + 0.5 * sqrt(1. + 8. * uv));\n    \n    // Sum of all previous intervals in both axes, \n    // coordinates of bottom left corner of cell\n    vec2 a = 0.5 * dim * (dim - 1.);    \n    \n    // Centre the [-0.5,0.5]^2 uv coords in each cell\n    // (uv - a) / md - 0.5  is fine too\n    // (uv - a) / dim - 0.5 stretches the uv to the whole cell\n    float md = min(dim.x, dim.y);\n    uv = (uv - a - .5 * dim) / md;\n\n    // k rescaled for each cell (probably incorrect)\n    float ksc = sc * k / md; \n    \n    // Draw uv and circle\n    float s = smoothstep(-ksc, ksc, 0.1 - length(uv));\n    vec3 col = 0.4 * s + vec3(uv, 0) + 0.5;    \n    \n    // Restrict to square\n    col *= 0.2 + 0.8 * smoothstep(-ksc, ksc, 0.5 - mlength(uv));\n    \n    O = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}