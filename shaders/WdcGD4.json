{
    "Shader": {
        "info": {
            "date": "1568476601",
            "description": "im so bored",
            "flags": 0,
            "hasliked": 0,
            "id": "WdcGD4",
            "likes": 28,
            "name": "foggy glass",
            "published": 3,
            "tags": [
                "raytracing",
                "cube",
                "fog",
                "glass"
            ],
            "usePreview": 0,
            "username": "JuliaPoo",
            "viewed": 680
        },
        "renderpass": [
            {
                "code": "const float END = 20.;\nconst float ep = 0.001;\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat cube(vec3 p, float b, float r){\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) - r + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sphere(vec3 p, float r){\n \treturn length(p) - r;  \n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  \treturn dot(p,n.xyz) + n.w;\n}\n\nfloat light(vec3 p){\n    vec3 move = 1.5*vec3(cos(iTime)*sin(iTime), sin(iTime)*sin(iTime), cos(iTime));\n    vec3 p_ = p - move; p_.xy *= rot(iTime * 3.); p_.zy *= rot(iTime * 2.);\n\treturn min(cube(p_, .17, 0.), sphere(p + move, .2)); \n}\n\nfloat obj(vec3 p){\n    p.xy *= rot(iTime * .3);\n    float cube = cube(p, .5, .5);\n    vec3 shook = .4*vec3(sin(iTime*3.), cos(iTime*4.), sin(iTime*2.));\n    float sphere = sphere(p + shook, .4);\n\treturn max(cube, -sphere);   \n}\n\nfloat mirror(vec3 p){\n    float ripples = 0.1*sin(3.*length(p.xz) - iTime*pow(abs(sin(iTime*0.1)*0.5), 4.));\n    //return plane(p, vec4(0.,1.,0., 1.1)) + ripples;\n    return cube(p + vec3(0., 3., 0.), 1.7, 0.3) + ripples;\n}\n\nfloat SDscene(vec3 p){\n   \n\tfloat obj = obj(p);\n    float mirror = mirror(p);\n    float light = light(p);\n    float d = min(min(obj, mirror), light);\n    \n    return d;\n}\n\nvec3 SDnormal(vec3 p){\n    \n    //Calculates the normal vector of SDscene\n    \n    return normalize(vec3(\n    SDscene(vec3(p.x+ep,p.y,p.z))-SDscene(vec3(p.x-ep,p.y,p.z)),\n    SDscene(vec3(p.x,p.y+ep,p.z))-SDscene(vec3(p.x,p.y-ep,p.z)),\n    SDscene(vec3(p.x,p.y,p.z+ep))-SDscene(vec3(p.x,p.y,p.z-ep))\n    ));\n}\n\nfloat depth(vec3 ro, vec3 rd, float sig, inout float min_l){\n    \n    //Returns depth from ro given raydirection\n    \n    int max=300;\n    vec3 p;\n    \n    float dist=0., d;\n    for (int i=0; i<max; i++){\n        p = ro + dist*rd;\n    \td = SDscene(p)*sig;\n        if (light(p) < min_l){ min_l = light(p);}\n    if (abs(d)<ep){\n        return dist;\n    }\n    dist += d;\n    if (dist > END){\n        return END;\n    }\n  }\n}\n\nvoid ray_mirror(inout vec3 ro, inout vec3 rd, inout float d, inout float min_l){\n    \n    int Nmax = 15, count = 0;\n    while (count < Nmax){\n        \n        ro -= rd*ep*5.;\n        rd = normalize(reflect(rd, SDnormal(ro)));\n        d = depth(ro, rd, 1., min_l);\n        ro += d*rd;\n       \n        if (mirror(ro) > ep){break;}\n        \n        count += 1;\n    }\n}\n\nvoid ray_obj(inout vec3 ro, inout vec3 rd, inout float Dglass, inout float d, inout float min_l){\n    \n    int Nmax = 15, count = 0, count2 = 0;\n    vec3 p, rd_;\n    while (count < Nmax){\n        \n        //Go into glass\n        ro += rd * ep*50.;\n        rd = normalize(refract(rd, SDnormal(ro), 0.6));\n        d = depth(ro, rd, -1., min_l);\n        ro += rd * d;\n    \tDglass += d;\n        \n        //internal refraction\n    \trd_ = refract(rd, -SDnormal(ro), 1.5);\n       \twhile (length(rd_) < 0.0001 && count2 < Nmax){\n            \n            rd = normalize(reflect(rd, -SDnormal(ro)));\n            d = depth(ro, rd, -1., min_l);\n            ro += d*rd;\n            \n            Dglass += d;\n            rd_ = refract(rd, -SDnormal(ro), 1.5);\n            count2 += 1;\n        }\n  \n        if (length(rd_) > 0.0001){rd = normalize(rd_);}\n        ro += rd * ep*10.;\n        d = depth(ro, rd, 1., min_l);\n        ro += rd * d;\n        \n        if (obj(ro) > ep){break;}\n        \n        //if (mirror(ro) > ep){ break;}\n      \t\n\t\tcount += 1;\n    }\n}\n\n\nvoid fresnel(vec3 ro, vec3 rd, inout float refl, inout float refr){\n \t   \n   \tfloat b = ((1. - 1.5)/(1. + 1.5));\n    float r0 = b*b;\n    refl = r0 + (1. - r0)*pow((1. - abs(dot(SDnormal(ro), normalize(rd)))), 5.);\n    refr = 1.-refl;\n    //refl = .5; refr = .5;\n}\n\nvec3 render(vec2 uv){\n    vec3 col;\n    \n    //Camera\n    float ScreenSize = 4.;\n    float shake = 0.3*sin(.3*iTime);\n    \n    float zoom = 2.5;\n    float k = 0.4;\n    float osc = sin(iTime*.3); //3.5 + 2.*osc*osc\n  \tvec3 ro = 6.*vec3(sin(k*iTime), shake, cos(k*iTime)) + vec3(0.,2.,0.);\n  \tvec3 lookat = vec3(0,0,0);\n    \n    \n  \tvec3 fw = normalize(lookat - ro);\n  \tvec3 r = normalize(cross(vec3(0,1.,0), fw));\n  \tvec3 up = normalize(cross(fw,r));\n  \tvec3 scrC = ro + (zoom)*fw;\n  \tvec3 scrP = scrC + (uv.x*r + uv.y*up) * ScreenSize;\n  \tvec3 rd = normalize(scrP - ro);\n    \n    float Dglass, min_l = END;\n    float d = depth(ro, rd, 1., min_l);\n    ro += d*rd;\n    \n    vec3 ro_, rd_;\n    float refl, refr;\n    int Nmax = 15, count;\n    while (count < Nmax){\n        //hits background\n        if (d > END - ep){\n            //col += texture(iChannel0, ro).xyz;\n            vec3 tint = vec3(exp(Dglass*-0.05),exp(Dglass*-0.3),exp(Dglass*-0.7));\n            col *= tint;\n            col += pow(clamp(abs(1./min_l)*0.1, 0., 1.), .7);\n            break;\n        }\n        \n        //hit light\n        else if (light(ro) < ep){\n        \tcol += vec3(1.);\n            break;\n        }\n\n        //hit obj\n        else if (obj(ro) < ep){\n            ro_ = ro; rd_ = rd;\n            ray_obj(ro, rd, Dglass, d, min_l);\n            ray_mirror(ro_, rd_, d, min_l);\n        }\n\n        //hit mirror\n        else if (mirror(ro) < ep){\n            ray_mirror(ro, rd, d, min_l);\n        }\n        \n        else{d = END;}\n        \n        count += 1;\n    }\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // float degree = .35*pow(0.538502*(sin(3.*iTime) + sin(iTime * 1.8)),8.) + .1;\n    // Bug found by FabriceNeyret2\n    float degree = .35*pow(abs(0.538502*(sin(3.*iTime) + sin(iTime * 1.8))),8.) + .1;\n    \n    //Shader setup\n    vec2 R = iResolution.xy;\n    vec2 uv2 = (fragCoord - 0.5*R)/R.x;\n    float aberr = length(uv2);\n    vec2 uv_off = uv2 * vec2(aberr,aberr*aberr)*degree;\n    fragColor = vec4(1);\n    for(int i = 0; i < 3; i++) {\n        vec2 uv = uv2 + uv_off*float(1-2*i);\n        vec3 col = render(uv);\n        fragColor[i] = col[i];\n    }\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}