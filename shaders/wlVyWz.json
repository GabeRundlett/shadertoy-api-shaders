{
    "Shader": {
        "info": {
            "date": "1610844934",
            "description": "First ray tracing scene. Distance to sphere and to plane were used, having the sphere as priority.",
            "flags": 0,
            "hasliked": 0,
            "id": "wlVyWz",
            "likes": 2,
            "name": "First ray tracing exercise",
            "published": 3,
            "tags": [
                "raytracing",
                "basic",
                "sphere",
                "floor"
            ],
            "usePreview": 0,
            "username": "avinitzca",
            "viewed": 300
        },
        "renderpass": [
            {
                "code": "\nfloat distanceLinePoint(vec3 point, vec3 lineOrigin, vec3 lineDirection)\n{\n    return length(cross(point - lineOrigin, lineDirection)) / length(lineDirection);\n\n}\n\nfloat intersectionSphereRay(vec3 center, float radius, vec3 rayOrigin, vec3 rayDirection){\n    vec3 oc = rayOrigin - center;\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * dot(oc, rayDirection);\n    float c = dot(oc,oc) - radius*radius;\n    float discriminant = b*b - 4.0*a*c;\n    if(discriminant < 0.0){\n        return -1.0;\n    }\n    else{\n        return (-b - sqrt(discriminant)) / (2.0*a);\n    }\n}\n\nfloat LineLineIntersection(vec3 rayAOrigin, vec3 rayADirection, vec3 rayBOrigin, vec3 rayBDirection)\n{ \n    vec3 lineVec3 = rayBOrigin - rayAOrigin;\n    vec3 crossVec1and2 = cross(rayADirection, rayBDirection);\n    vec3 crossVec3and2 = cross(lineVec3, rayBDirection);\n \n    float planarFactor = dot(lineVec3, crossVec1and2);\n \n    bool less = abs(planarFactor) < 0.0001;\n    bool j = 0.0001 < length(crossVec1and2);\n    \n    //is coplanar, and not parrallel\n    if(less && j)\n    {\n        return dot(crossVec3and2, crossVec1and2) / sqrt(length(crossVec1and2));        \n    }\n    else\n    {\n        return -1.0;\n    }\n}\n\n\nfloat saturate(float value)\n{\n    return clamp(value, 0.0, 1.0);\n}\n\nfloat invLerp(float from, float to, float value){\n  return (value - from) / (to - from);\n}\n\n\nfloat linePlaneIntersection(vec3 normal, vec3 coord, vec3 rayOrigin, vec3 rayDirection) \n{\n    // get d value\n    float d = dot(normal, coord);\n\n    float denominator = dot(normal, rayDirection);\n\n    // Compute the X value for the directed line ray intersecting the plane\n    return (denominator == 0.0) ? -1.0 : ((d - dot(normal, rayOrigin)) / denominator);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    \n    uv.x *= iResolution.x/iResolution.y;\n        \n    \n    \n    // Camera and ray tracing \n    float zoom = 1.0;    \n    vec3 normalUp = vec3(0.0, 1.0, 0.0);    \n    vec3 rayOrigin = vec3(4.0 * -cos(iTime * 0.5), 2.0, 4.0 + 4.0 * sin(iTime * 0.5));\n    rayOrigin = vec3(0.0, 0.5, 0.5);\n    vec3 lookAtPosition = vec3(0.0, 0.0, 4.0);    \n    vec3 cameraForward = normalize(lookAtPosition - rayOrigin);\n    vec3 cameraRight = cross(normalUp, cameraForward);\n    vec3 cameraUp = cross(cameraForward, cameraRight);\n    \n    vec3 center = rayOrigin + cameraForward * zoom;\n    vec3 intersection = center + uv.x * cameraRight + uv.y * cameraUp;\n        \n    vec3 rayDirection = intersection - rayOrigin;\n    \n    \n    \n    // Sphere\n    vec3 sphereCenter = vec3(0.0, 0.0, 4.0);\n    float sphereRadius = 1.0;\n    \n    vec3 planeNormal = vec3(0.0, 1.0, 0.0);\n    vec3 planePosition = vec3(0.0, -1.0, 0.0);\n    \n    // Intersection\n    float sphereResult = intersectionSphereRay(sphereCenter, sphereRadius, rayOrigin, rayDirection); \n    \n    \n    vec3 color = vec3(0.0);\n    vec3 lightPosition = vec3(-10.0, 10.0, -6.0);\n    \n    vec3 normal = vec3(0.0, 1.0, 0.0);\n    vec3 intersectionPoint = vec3(0.0);\n    float shadow = 1.0;\n    \n    float kA = 0.1;\n    float kD = 0.8;\n    float kS = 0.2;\n\n    vec3 baseColor = vec3(1.0);\n    vec3 specularAdditive = vec3(0.0);\n    float n = 0.0;\n    \n    bool geometry = false;\n    \n    if(sphereResult != -1.0)\n    {\n        geometry = true;\n        intersectionPoint = rayOrigin + rayDirection * sphereResult;\n        normal = normalize(intersectionPoint - sphereCenter);\n        /*vec3 reflectionDirection = reflect(rayDirection, normal);\n        float intersectReflection = linePlaneIntersection(planeNormal, planePosition, intersectionPoint, reflectionDirection);\n        \n        if(intersectReflection >= 0.0)\n        {\n            vec3 reflectionIntersectionPoint = intersectionPoint + reflectionDirection * intersectReflection;\n            vec2 checker = floor(reflectionIntersectionPoint.xz * 5.0);\n            specularAdditive = vec3(saturate(mod(checker.x + checker.y, 2.0))) * 0.25 + 0.25;\n        }\n        else\n            specularAdditive = vec3(0.0, 0.6, 1.0) * .75;\n        */\n    }\n    else\n    {\n        \n        float planeResult = linePlaneIntersection(planeNormal, planePosition, rayOrigin, rayDirection);\n        if(planeResult > .0)\n        {       \n            geometry = true;\n            intersectionPoint = rayOrigin + rayDirection * planeResult;    \n            vec3 shadowRayOrigin = intersectionPoint;\n            vec3 shadowRayDirection = normalize(lightPosition - shadowRayOrigin);\n            float shadowResult = intersectionSphereRay(sphereCenter, sphereRadius, shadowRayOrigin, shadowRayDirection);\n\n            vec2 checker = floor(intersectionPoint.xz * 3.0);\n            baseColor = vec3(saturate(mod(checker.x + checker.y, 2.0))) * 0.25 + 0.25;\n\n            kD = 0.75;\n            kS = 0.2;\n            if(shadowResult > 0.0)\n            {\n                // Not-plausible-shadow\n                shadow = saturate((shadowResult * 1.55 - 2.0) * shadowResult);\n            }\n        }\n    }\n    \n    if(geometry)\n    {    \n        // Blinn-Phong\n        vec3 light = normalize(lightPosition - intersectionPoint);\n        vec3 view = normalize(rayOrigin - intersectionPoint);\n        float lambertian = max(dot(light, normal), 0.0);\n        vec3 halfway = normalize(view + light);    \n        specularAdditive += pow(saturate(dot(halfway, normal)), 32.0);\n\n        color += vec3(lambertian * kD * baseColor + kA + kS * specularAdditive) * shadow;\n    }\n    else\n    {\n        // Sky\n        color = vec3(0.0, 0.67, 0.95);    \n    }\n        \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}