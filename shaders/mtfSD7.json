{
    "Shader": {
        "info": {
            "date": "1674857296",
            "description": "An infinite maze with randomly colored [url=https://en.wikipedia.org/wiki/Flood_fill]flood-filled[/url] walls.\nThis flood fill algorithm doesn't always fill every pixel, so some of the walls have more than one color.",
            "flags": 8,
            "hasliked": 0,
            "id": "mtfSD7",
            "likes": 17,
            "name": "Flood fill maze",
            "published": 3,
            "tags": [
                "maze",
                "dungeon",
                "labyrinth",
                "roguelike"
            ],
            "usePreview": 0,
            "username": "jarble",
            "viewed": 456
        },
        "renderpass": [
            {
                "code": "float threshold = .5;\nint iters = 4;\n\n#define noise2D(p) float(((p).x * 68657387u ^ (p).y * 361524851u + (p).x) % 890129u) / 890128.\n\nbool labyrinth(uvec2 U,float n2){\n    bvec2 b = bvec2(U & 1u);\n    return (b.x && b.y || b.x != b.y  && n2 < threshold);\n}\n\nbool labyrinth1(uvec2 I){\nbool b = false;\n    for(int i = 0; i++ < iters;I = I*2u/3u){\n        float n = noise2D(I);\n        b = !b || labyrinth(I,n);\n        \n        //some random-looking distortion\n        //{I = I+I.yx/(31u)-I.yx/(29u)-I.yx/(23u);}\n        //{I = I-I.yx/13u/11u/7u/5u+I.yx/11u/7u/5u-I.yx/7u/5u;}\n    }\n    return b;\n}\n\n\nbool next_to_wall(uvec2 current){\n    return labyrinth1(current + uvec2(0,1))\n    || labyrinth1(current - uvec2(0,1))\n    || labyrinth1(current + uvec2(1,0))\n    || labyrinth1(current - uvec2(0,1));\n}\n\nuvec2 next_pos(uvec2 prev,uvec2 current){\n    uvec2 diff = current-prev;\n    uvec2 forward = current+diff;\n    uvec2 left = current + diff.yx;\n    uvec2 right = current - diff.yx;\n    //if(prev == current || !next_to_wall(current)) current.y += 1u;\n    if(!labyrinth1(forward) && next_to_wall(forward)) return forward;\n    else if(labyrinth1(forward) && !labyrinth1(left) && next_to_wall(left)) return left;\n    else if(labyrinth1(forward) &&  !labyrinth1(right) && next_to_wall(right)) return right;\n    else return prev;\n    \n}\n\nvec3 hash32(uvec2 p1)\n{\n    vec2 p=vec2(p1);\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nbool move1(in uvec2 I,inout uvec2 I1){\n    if(!labyrinth1(I))\n    {I1=I;return true;}\n    else return false;\n}\n\nvec4 floodfill(uvec2 I){\n    vec4 O = vec4(1);\n    if(labyrinth1(I)) return O = 1.-O;\n        \n    while(true){\n            if(!(move1(uvec2(I.x,I.y-1u),I)\n            || move1(uvec2(I.x-1u,I.y),I)))\n            break;\n    }\n    while(true){\n            if(!(move1(uvec2(I.x,I.y-1u),I)\n            || move1(uvec2(I.x+1u,I.y),I)))\n            break;\n    }\n    while(true){\n            if(!(move1(uvec2(I.x,I.y+1u),I)\n            || move1(uvec2(I.x+1u,I.y),I)))\n            break;\n    }\n    while(true){\n            if(!(move1(uvec2(I.x,I.y+1u),I)\n            || move1(uvec2(I.x-1u,I.y),I)))\n            break;\n    }\n    return vec4(hash32(I),1.);\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    uvec2 I = uvec2( U/8.+ iTime*8.);\n    O = floodfill(I);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float fmod(float a, float b){\n    //a += floor(a/b);\n    /*\n    for(int i = 0; i < 3; i++){\n        a /= 1. + mod(floor(a*2.),2.);\n        a += floor(a/pow(2.,b));\n    }\n    */\n    a +=\n        floor(a*pow(2.,b))/pow(2.,b)\n        //floor(a*8.)/8.\n    ;    \n    //divide by powers of 2 to get interesting rhythms\n    float a1 = floor(a);\n    //a /= 1. + mod(floor(a1/32.),2.);\n    //a /= 1. + mod(floor(a1/16.),2.);\n    //a /= 1. + mod(floor(a1/8.),2.);\n    //a /= 1. + mod(floor(a1/4.),2.);\n    //a /= 1. + mod(floor(a1/2.),2.);\n    return\n        mod(floor(a),b)\n        //mod(floor(a+floor(a/2.)),b)\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n    ;\n}\n#define fmax(x,y,z) max(fmod(x,z),fmod(y,z))\n\nvec2 mainSound(int samp, float t){\n  float tempo = 1.;\n  t /= tempo;\n  //t = mod(t,2.)+floor(t/2.)*2.;\n  //t = (t + pow(2.,fmod(t,3.)));\n  //t +=\n      //floor(t/8.) + floor(t*8.)/8.\n      //mod(floor(t*8.)+floor(t/8.),8.)/8.\n  //;\n  //t /= 2.;\n  float\n  tempo1 =\n      //4.\n      pow(2.,1.+fmod(t/8.,2.))\n  ,\n  m1 =\n      //tempo1\n      //pow(2.,1.+fmod(t/tempo1,3.))\n      pow(2.,1.+fmod(t*tempo1,3.))\n  ,\n  \n  c1 = fmod(t*tempo1,m1+fmod(t,m1)),\n  s1 = 1.+c1,\n  \n  t1 = t*tempo1,\n  m2 = fmod(t1*(1.+fmod(t,2.))/2.,s1),\n\n  a=\n      64.*pow((1.-sqrt(fract((t*tempo1+m2+t1)/2.))/1.25),2.)*.2\n      //16.*log((1.-abs(fract((-t*tempo1+m2-t1)/2.))/1.25))\n      //pow((1.-sqrt(fract(t*tempo1+floor(m2+t1)/2.))/1.25),2.)*.2\n  ,\n  nb =\n      t*tempo*pow(2.,m2/5.+7.)/(1.+fmod(t+m2,2.))\n      //pow(2.,m2/5.+7.5)/(1.+fmax(t+m2,t,2.))\n  ;\n  return\n      abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a\n      //log(1.-abs(.5-vec2(fract(nb*.998*2.),fract(nb))))*a\n      //vec2(fract(t*nb*.998/2.*(1.+m2)),fract(t*nb*2./(1.+m2)))*a\n  ;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}