{
    "Shader": {
        "info": {
            "date": "1470127757",
            "description": "spiral porn for a mate. now with rings! makes silvery colours that go round and round\nput on some relaxing music, fullscreen it, and empty your mind of all else\n\n40 second cycle time on the animation btw\n\n\nfeedback pls? :3",
            "flags": 0,
            "hasliked": 0,
            "id": "lltGzB",
            "likes": 12,
            "name": "soft silver spiral stack",
            "published": 3,
            "tags": [
                "2d",
                "commented",
                "relaxing",
                "slow",
                "greyscale",
                "spirals",
                "hypnoporn",
                "koru",
                "silvery"
            ],
            "usePreview": 0,
            "username": "main",
            "viewed": 1627
        },
        "renderpass": [
            {
                "code": "const float pi = 3.141592653589793;\n\nfloat spiralpiece (vec2 uv, float rotate) { \n    \n    // take polar coords \n    vec2 polar = vec2(length(uv - vec2(0.0)),\n                      atan(uv.y, uv.x) + rotate*pi);\n    \n    // log spiral is e^(2*pi*theta), thanks wikipedia\n    // this makes a spiral boundrary, abs and subtract from 1 for spiral line pieces\n    // with MAGIC constants for nicer 'colors'. ok nicer greyscale, whatever. \n    return 1.0 - clamp(abs(mod(polar.y, pi*2.0) - (3.0 * log(polar.x))), 0.0, 1.1);\n}\n\n// stack spiralpieces line segments 4 times over.\n// TODO: spirals not perfect, can see boundraries between pieces\n// MAGIC: why 8.1? because it looks better than 8.0 >_< \n// probably 'should be' some multiple of pi or something else stupid like that\nvec4 spiral (vec2 uv, float rotate, vec3 color) {\n\treturn clamp(vec4(spiralpiece(uv*1.000, rotate) \n                    + spiralpiece(uv*8.12, rotate) \n                    + spiralpiece(uv*66.0, rotate)\n                    + spiralpiece(uv*536.0, rotate)),\n                 0.0, 1.0) * vec4(color, 0.0);\n}\n\n// rings... distance to center, take mod to repeat, subtract and abs to make symmetrical. \n// then pow for less blur / thinner pieces, and weirder silvery overlaps. \nfloat ring (vec2 p, float offset) {\n    // MAGIC WITH EXTRA MAGIC ON TOP HOLY SHIT\n    // color   v1    |    ringsize (*will* break it)    v2, 1/2*v1 v3 | color v4\n    return pow(2.42*abs(mod(offset-length(vec2(0.0)-p), 0.75) -0.375) + 0.1, 5.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    /// resolution indepentant coords with 0,0 in the center\n\tvec2 uv = fragCoord.xy / iResolution.xy - vec2(0.5);\n    float aspect = iResolution.x / iResolution.y; // aspect ratio\n\tuv.y = uv.y / aspect; // same scale for x and y axis -- aspect ratio correction\n    \n    /// animate shit\n    // camera scale/animation\n    uv = uv * vec2(3.0 + 0.5* /*distance*/sin(iTime*0.5/*time*/));\n    // rotation animation\n\tfloat rotate = /*-*/iTime; // uncomment for inwards spiral...\n    // ring animation\n    float ringoffset = iTime * 0.375;\n    \n    /// more objects\n    // soft silvery ring-emphasis, center of screen. does this one actually do anything?\n    vec4 ring1 = clamp(vec4(1.0 - abs(1.4*length(uv - vec2(0.0)) -1.0)), -1.0, 1.0);\n    // same again, edge of screen\n    vec4 ring2 = clamp(vec4(1.0 - abs(0.5*pow(length(uv - vec2(0.0)), 2.0) -1.0)), -1.0, 1.0);\n    // central spot\n    vec4 spot = smoothstep(0.3, 0.6,clamp(vec4(1.0 - 110.0*length(uv - vec2(0.0))), 0.0, 1.0));\n    \n    // combine parts by adding... goes weird-in-a-good-way when they overlap \n    // yeah, this is why I clamp my spirals :P\n    // TODO: should probably be a loop of some kind I guess\n    vec4 sumc = vec4(spiral(uv, rotate*1.00, vec3(0.22))\n                   + spiral(uv, rotate*0.95, vec3(0.22))\n                   + spiral(uv, rotate*0.90, vec3(0.22))\n                   + spiral(uv, rotate*0.85, vec3(0.22))\n                   + spiral(uv, rotate*0.80, vec3(0.22))\n                   + spiral(uv, rotate*0.75, vec3(0.22))\n                   + spiral(uv, rotate*0.70, vec3(0.22))\n                   + spiral(uv, rotate*0.65, vec3(0.22))\n                   + 0.132* ring(uv, 0.05*ringoffset)\n                   + 0.132* ring(uv, 0.10*ringoffset)\n                   + 0.132* ring(uv, 0.15*ringoffset)\n                   + 0.132* ring(uv, 0.20*ringoffset)\n                   + 0.132* ring(uv, 0.25*ringoffset)\n                   + 0.132* ring(uv, 0.30*ringoffset)\n                   + 0.132* ring(uv, 0.35*ringoffset)\n                   + 0.132* ring(uv, 0.40*ringoffset)\n                   + ring1 * 0.08 // might be too dim to have much of an effect :/\n                   + ring2 * 0.15\n                   // MAGIC. FUCKING MAGIC.\n                   + 0.32 * smoothstep(0.05, 0.6, abs(1.0 - length(uv - vec2(0.0)+0.1 *1.0)))\n                   + spot * 0.6\n                   );\n    \n    // 'tone mapping' lol\n    fragColor = pow(sumc, vec4(1.2)) - vec4(0.1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}