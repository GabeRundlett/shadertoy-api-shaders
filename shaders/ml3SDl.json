{
    "Shader": {
        "info": {
            "date": "1685859753",
            "description": "render Cube - Sphere U Sphere with ray marching",
            "flags": 0,
            "hasliked": 0,
            "id": "ml3SDl",
            "likes": 1,
            "name": "Cube - Sphere U Sphere",
            "published": 3,
            "tags": [
                "raymarching",
                "raymarch",
                "spheretracing"
            ],
            "usePreview": 0,
            "username": "silica163",
            "viewed": 158
        },
        "renderpass": [
            {
                "code": "//#extension GL_OES_standard_derivatives : enable\n\n//precision highp float;\n\n//uniform float time;\n//uniform vec2 mouse;\n//uniform vec2 resolution;\n\n#define time iTime\n#define resolution iResolution\n#define mouse iMouse.xy\n#define PI 3.14159265\n#define MAX_DIST 100.\n#define MIN_DIST .00001\n#define MAX_STEP  128\n\nstruct Ray {\n\tvec3 o;\n\tvec3 p;\n\tvec3 dir;\n\tvec3 c;\n\tfloat dist;\n};\n\nstruct Sphere {\n\tvec4 p;\n\tvec3 color;\n};\n\t\nstruct Cube {\n\tvec3 p;\n\tvec3 c;\n\tvec3 s;\n};\n\nstruct Light {\n\tvec3 p;\n\tvec3 c;\n\tvec3 L;\n} light;\n\nvec3 N = vec3(0);\nvec3 V = vec3(0);\n\t\nfloat dist(vec3 p){\n\tfloat d = 0.;\n\td = length(p-vec3(0,0,0))-.65;\n\t\n\tvec3 cu = abs(p-vec3(0,0,0))-.5;\n\tvec3 cu2 = abs(p-vec3(0,-.5,0))-vec3(3.,.01,3.);\n\t\n\td = max(length(max(cu,0.)) + min(0.,max(cu.x,max(cu.y,cu.z)))-.005,-d);\n\td = min(d,length(max(cu2,0.)) + min(0.,max(cu2.x,max(cu2.y,cu2.z))));\n    d = min(d,length(p-vec3(0,0,0))-.3);\n\t\n\treturn d;\n}\n\nfloat lightDist(vec3 p,float d){\n\td = min(length(p-vec3(sin(2./3.*PI*2.)*1.5,1,cos(2./3.*PI*2.)*1.5))-.1,d);\n\td = min(length(p-vec3(sin(1./3.*PI*2.)*1.5,1,cos(1./3.*PI*2.)*1.5))-.1,d);\n\td = min(length(p-vec3(sin(0.)*1.5,1,cos(0.)*1.5))-.1,d);\n\treturn d;\n}\n\nvoid march(inout Ray r,int t){\n\tfor(int i = 0;i<MAX_STEP;i++){\n\t\tr.p = r.o + r.dist*r.dir;\n\t\tfloat d = dist(r.p);\n\t\td = t == 0 ? d : min(d,lightDist(r.p,d));\n        r.dist += d;\n\t\tif(d <= MIN_DIST || d > MAX_DIST)break;\n\t}\n}\n\nvec3 sNormal(vec3 p){\n\tvec2 t = vec2(.001,0);\n\tfloat d = dist(p);\n\t\n\treturn normalize(d - vec3(\n\t\tdist(p-t.xyy),\n\t\tdist(p-t.yxy),\n\t\tdist(p-t.yyx)\n\t));\n}\n\nfloat diffuse(vec3 p,vec3 L){\n\treturn max(dot(sNormal(p),normalize(L)),0.);\n}\n\nvec3 colorDiff(Light l,Ray r){\n\tvec3 c = vec3(0);\n\tfloat d = diffuse(r.p,l.L);\n\t\n\tc += l.c * d;\n\t\n\treturn c;\n}\n\nfloat bPhong(Light l,Ray r){\n\tfloat c = 0.;\n\tfloat d = diffuse(r.p,l.L);\n\t\n\tc += pow(max(dot(normalize(l.L+V),N),0.),100.)*2. * d;\n\t\n\treturn c;\n}\n\nfloat shadowMask(vec3 p,vec3 l){\n\tfloat m = 1.;\n\tfloat x = 10.;\n\tRay r = Ray(p+N*MIN_DIST*x,p+N*MIN_DIST*x,normalize(l-p),vec3(0),0.);\n\tmarch(r,0);\n\tif(r.dist < length(l-p))m = 0.1;\n\treturn m;\n}\n\nvoid lNormal(inout Light l,Ray r){\n\tl.L = normalize(l.p-r.p);\n}\n\nvec3 getColor(Light l,Ray r){\n    return ((colorDiff(l,r) + bPhong(l,r)*l.c) * vec3(shadowMask(r.p,l.p)))/length(r.p-l.p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = ( fragCoord.xy / resolution.xy )*2.-1.;\n\tuv.x*= resolution.x/resolution.y;\n\t//uv*=1.5;\n\tvec2 m = vec2(time*.1,-abs(sin(time/40.)*1.));\n\t\n\tfloat camz = PI;\n\tvec3 ca = vec3(\n\t\tPI/2.+m.y*PI/2.,\n\t\tPI/2.+m.x*PI/1.,\n\t\t0\n\t);\n\t\n\tmat3 rotX = mat3(\n\t\t1,         0,        0,\n\t\t0, sin(ca.x),cos(ca.x),\n\t\t0,-cos(ca.x),sin(ca.x)\n\t);\n\t\n\tmat3 rotY = mat3(\n\t\t sin(ca.y),0, cos(ca.y),\n\t\t0,         1,         0,\n\t\t-cos(ca.y),0, sin(ca.y)\n\t);\n\tvec3 camera = vec3(0,0,camz)*rotX*rotY;\n\tvec3 plane = (vec3(uv,0)*rotX*rotY);\n\t\n\tlight.p = vec3(sin(2./3.*PI*2.)*1.5,2,cos(2./3.*PI*2.)*1.5);\n\tlight.c = vec3(0,0,1);\n\tLight l2;\n\tl2.p = vec3(sin(1./3.*PI*2.)*1.5,2,cos(1./3.*PI*2.)*1.5);\n\tl2.c = vec3(1,0,0);\n\tLight l3;\n\tl3.p = vec3(sin(0.)*1.5,2,cos(0.)*1.5);\n\tl3.c = vec3(0,1,0);\n    \n    Light l4;\n\tl4.p = vec3(0,5,0);\n\tl4.c = vec3(1);\n\t\n\tRay r = Ray(camera,camera,normalize(plane-camera),vec3(0),0.);\n\t\n\tmarch(r,0);\n\t\n\tvec3 c = vec3(0);\n\tN = sNormal(r.p);\n\tV = -r.dir;\n\t\n\tlNormal(light,r);\n\tlNormal(l2,r);\n\tlNormal(l3,r);\n    lNormal(l4,r);\n\t\n\tc += getColor(light,r);\n\tc += getColor(l2,r);\n\tc += getColor(l3,r);\n    c += getColor(l4,r);\n\t\t\n\tif(r.dist > MAX_DIST) c = vec3(.1);\n\t\n\tif(length(r.p-light.p)-.1 <= MIN_DIST) c = light.c*5.;\n\tif(length(r.p-l2.p)-.1 <= MIN_DIST) c = l2.c*5.;\n\tif(length(r.p-l3.p)-.1 <= MIN_DIST) c = l3.c*5.;\n\t\n\tfragColor = vec4( c, 1.0 );\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}