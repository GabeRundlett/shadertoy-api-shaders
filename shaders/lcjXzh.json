{
    "Shader": {
        "info": {
            "date": "1706044722",
            "description": "Sea and Stars",
            "flags": 0,
            "hasliked": 0,
            "id": "lcjXzh",
            "likes": 1,
            "name": "Sea and Stars",
            "published": 3,
            "tags": [
                "sea",
                "stars"
            ],
            "usePreview": 1,
            "username": "antoinebou12",
            "viewed": 150
        },
        "renderpass": [
            {
                "code": "const int NUM_STEPS = 8;\nconst float PI = 3.141592;\nconst float EPSILON = 1e-3;\n#define EPSILON_NRM (0.1 / iResolution.x)\n\n// sea constants\nconst int ITER_GEOMETRY = 12;\nconst int ITER_FRAGMENT = 20;\nconst float SEA_HEIGHT = 0.4;\nconst float SEA_CHOPPY = 2.0;\nconst float SEA_SPEED = 0.6;\nconst float SEA_FREQ = 0.12;\nconst vec3 SEA_BASE = vec3(0.0, 0.09, 0.18);\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6) * 0.6;\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\nconst mat2 octave_m = mat2(1.6, 1.2, -1.2, 1.6);\n\nconst vec3 SAND_COLOR = vec3(0.9, 0.8, 0.5);\n\n#define iterations 12\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.5\n\n#define brightness 0.01\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\nfloat prm1 = 0.0;\nvec2 bsMo = vec2(0.0);\n\n\nconst vec3 sphereCenters[3] = vec3[3](\n    vec3(42.0, -10.0, -70.0),\n    vec3(30.0, -10.0, -12.0),\n    vec3(0.0, -10.0, 0.0)\n);\nconst float sphereRadii[3] = float[3](6.0, 8.0, 6.0);\n\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {\n    float nrm = (s + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\nvec2 mapCloud(vec3 p) {\n    vec3 p2 = p;\n    p2.xy -= disp(p.z).xy;\n    p.xy *= rot(sin(p.z+iTime)*(0.1 + prm1*0.05) + iTime*0.09);\n    float cl = mag2(p2.xy);\n    float d = 0.;\n    p *= .61;\n    float z = 1.;\n    float trk = 1.;\n    float dspAmp = 0.1 + prm1*0.2;\n    for(int i = 0; i < 5; i++)\n    {\n\t\tp += sin(p.zxy*0.75*trk + iTime*trk*.8)*dspAmp;\n        d -= abs(dot(cos(p), sin(p.yzx))*z);\n        z *= 0.57;\n        trk *= 1.4;\n        p = p*m3;\n    }\n    d = abs(d + prm1*3.)+ prm1*.3 - 2.5 + bsMo.y;\n    return vec2(d + cl*.2 + 0.25, cl);\n}\n\nvec4 renderCloud( in vec3 ro, in vec3 rd, float time )\n{\n\tvec4 rez = vec4(0);\n    const float ldst = 8.;\n\tvec3 lpos = vec3(disp(time + ldst)*0.5, time + ldst);\n\tfloat t = 1.5;\n\tfloat fogT = 0.;\n\tfor(int i=0; i<130; i++)\n\t{\n\t\tif(rez.a > 0.99)break;\n\n\t\tvec3 pos = ro + t*rd;\n        vec2 mpv = mapCloud(pos);\n\t\tfloat den = clamp(mpv.x-0.3,0.,1.)*1.12;\n\t\tfloat dn = clamp((mpv.x + 2.),0.,3.);\n        \n\t\tvec4 col = vec4(0);\n        if (mpv.x > 0.6)\n        {\n        \n            col = vec4(sin(vec3(5.,0.4,0.2) + mpv.y*0.1 +sin(pos.z*0.4)*0.5 + 1.8)*0.5 + 0.5,0.08);\n            col *= den*den*den;\n\t\t\tcol.rgb *= linstep(4.,-2.5, mpv.x)*2.3;\n            float dif =  clamp((den - mapCloud(pos+.8).x)/9., 0.001, 1. );\n            dif += clamp((den - mapCloud(pos+.35).x)/2.5, 0.001, 1. );\n            col.xyz *= den*(vec3(0.005,.045,.075) + 1.5*vec3(0.033,0.07,0.03)*dif);\n        }\n\t\t\n\t\tfloat fogC = exp(t*0.2 - 2.2);\n\t\tcol.rgba += vec4(0.06,0.11,0.11, 0.1)*clamp(fogC-fogT, 0., 1.);\n\t\tfogT = fogC;\n\t\trez = rez + col*(1. - rez.a);\n\t\tt += clamp(0.5 - dn*dn*.05, 0.09, 0.3);\n\t}\n\treturn clamp(rez, 0.0, 1.0);\n}\n\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\n    vec3 color = vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\n    //get coords and direction\n\tvec2 uv=gl_FragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.y;\n\tvec3 dir=vec3(uv,1.);\n\tfloat time=iTime*speed+.25;\n    float s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) {\n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n    return color * v * 0.01;\n}\n\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);\n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));\n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n//sand islands\nfloat island_octave(vec2 uv, float choppy) {\n    uv += noise(uv);\n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));\n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nvec3 getSandColor(vec3 p) {\n    float noise1 = island_octave(p.xz * 0.2 + 0.1, 0.5) * 0.7;\n    float noise2 = island_octave(p.xz * 1.0 + 0.5, 0.3) * 0.3;\n    return SAND_COLOR * (noise1 + noise2);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n\n    float d, h = 0.0;\n    for(int i = 0; i < ITER_GEOMETRY; i++) {\n        d = sea_octave((uv+SEA_TIME)*freq,choppy);\n        d += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n\n    float d, h = 0.0;\n    for(int i = 0; i < ITER_FRAGMENT; i++) {\n        d = sea_octave((uv+SEA_TIME)*freq,choppy);\n        d += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {\n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\n    fresnel = pow(fresnel, 20.);\n    fresnel = min(pow(fresnel,3.0), 0.5);\n\n    vec3 reflected = getSkyColor(reflect(eye,n));\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12;\n\n    vec3 color = mix(refracted,reflected,fresnel);\n\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n\n    color = mix(color, vec3(specular(n,l,eye,60.0)), pow(smoothstep(0.0, -0.02, l.y), 0.2));\n\n    vec2 st = gl_FragCoord.xy / iResolution.xy * 3.0;\n    st += st * abs(sin(iTime * 0.01) * 2.0);\n\n    vec2 q = vec2(0.0);\n    q.x = fbm(st + vec2(0.0, 0.0) * 10.0);\n    q.y = fbm(st + vec2(1.0, 0.0));\n\n    vec2 r = vec2(0.0);\n    r.x = fbm(st + (q * 1.0) + vec2(1.7, 9.2) + (0.15 * 10.0));\n    r.y = fbm(st + (q * 1.0) + vec2(8.3, 2.8) + (0.126 * 10.0));\n\n    float f = fbm(st + r);\n\n    vec3 color2 = mix(color,\n        vec3(0.0, 0.0, 0.164706),\n        clamp(length(q), 0.0, 1.0));\n\n    vec3 color3 = mix(color2,\n        vec3(0.666667, 1.0, 1.0),\n        clamp(length(r.x), 0.0, 1.0));\n\n    color = mix(color3, color, 0.75);\n\n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {\n    float tm = 0.0;\n    float tx = 1000.0;\n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) {\n        p = ori + dir * tx;\n        return tx;\n    }\n    float hm = map(ori + dir * tm);\n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));\n        p = ori + dir * tmid;\n        float hmid = map(p);\n\t\tif(hmid < 0.0) {\n            tx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\nvec3 calculateSphereColor(vec3 spherePos, vec3 sphereNormal, vec3 light, float time) {\n    vec2 q = gl_FragCoord.xy/iResolution.xy;\n    vec2 p = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    bsMo = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    time = iTime*3.;\n    vec3 ro = vec3(0,0,time);\n    \n    ro += vec3(sin(iTime)*0.5,sin(iTime*1.)*0.,0);\n        \n    float dspAmp = .85;\n    ro.xy += disp(ro.z)*dspAmp;\n    float tgtDst = 3.5;\n    \n    vec3 target = normalize(ro - vec3(disp(time + tgtDst)*dspAmp, time + tgtDst));\n    ro.x -= bsMo.x*2.;\n    vec3 rightdir = normalize(cross(target, vec3(0,1,0)));\n    vec3 updir = normalize(cross(rightdir, target));\n    rightdir = normalize(cross(updir, target));\n\tvec3 rd=normalize((p.x*rightdir + p.y*updir)*1. - target);\n    rd.xy *= rot(-disp(time + 3.5).x*0.2 + bsMo.x);\n    prm1 = smoothstep(-0.4, 0.4,sin(iTime*0.3));\n\tvec4 scn = renderCloud(ro, rd, time);\n\t\t\n    vec3 col = scn.rgb;\n    col = iLerp(col.bgr, col.rgb, clamp(1.-prm1,0.05,1.));\n    \n    col = pow(col, vec3(.55,0.65,0.6))*vec3(1.,.97,.9);\n\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12)*0.7+0.3; //Vign\n    \n    return col;\n}\n\n\nvec3 renderSea(vec3 ori, vec3 dir, vec3 light) {\n    vec3 p;\n    heightMapTracing(ori, dir, p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist, dist) * EPSILON_NRM);\n    return mix(getSkyColor(dir), getSeaColor(p, n, light, dir, dist), pow(smoothstep(0.0, -0.02, dir.y), 0.2));\n}\n\nvec3 getPixel(in vec2 coord, float time) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Camera setup\n    float u_cameraPositionZ = (sin(iTime * 0.1) + 1.0) * 0.5 * 1.0 + 1.0;\n    uv /= u_cameraPositionZ;\n\n    // Ray setup\n    vec3 ang = vec3(sin(time * 3.0) * 0.01, sin(time) * 0.01 + 0.2, 0.4);\n    vec3 ori = vec3(0.0, 3.5, 20.0);\n    vec3 dir = normalize(vec3(uv.xy, -2.0));\n    dir.z += length(uv) * 0.14;\n    dir = normalize(dir) * fromEuler(ang);\n\n    // Lighting\n    vec3 light = normalize(vec3(0.0, 1.0, 0.8));\n\n    // Initialize variables for color and hit detection\n    vec3 color = vec3(0.0);\n    bool hitSomething = false;\n\n    // Check intersection with each sphere\n    for (int i = 0; i < 3; i++) {\n        float waterLevelAtSphere = map(vec3(sphereCenters[i].x, 0.0, sphereCenters[i].z));\n        vec3 adjustedSphereCenter = sphereCenters[i];\n        adjustedSphereCenter.y = max(waterLevelAtSphere, sphereCenters[i].y);\n        float tSphere = raySphereIntersect(ori, dir, adjustedSphereCenter, sphereRadii[i]);\n        if (tSphere > 0.0) {\n            hitSomething = true;\n            vec3 spherePos = ori + dir * tSphere;\n            vec3 sphereNormal = normalize(spherePos - sphereCenters[i]);\n\n            vec3 p;\n            heightMapTracing(ori, dir, p);\n            vec3 dist = p - ori;\n            vec3 n = getNormal(p, dot(dist, dist) * EPSILON_NRM);\n            sphereNormal = mix(sphereNormal, n, 0.075);\n            float blendFactor = smoothstep(waterLevelAtSphere - 0.6, waterLevelAtSphere + 0.3, spherePos.y);\n\n            // Compute color for the sphere\n            vec3 sphereColor = calculateSphereColor(spherePos, sphereNormal, light, time + spherePos.x);\n            \n            vec3 seaColor = getSeaColor(p, n, light, dir, dist);\n            color = mix(seaColor, sphereColor, blendFactor);\n        }\n    }\n\n    // Render sea if no sphere was hit\n    if (!hitSomething) {\n        color = renderSea(ori, dir, light);\n    }\n\n    return color;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime * 0.1;\n#ifdef AA\n    vec3 color = vec3(0.0);\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 uv = (fragCoord + vec2(i, j) / 3.0);\n            color += getPixel(uv, time);\n        }\n    }\n    color /= 9.0;\n#else\n    vec3 color = getPixel(fragCoord, time);\n#endif\n\n    // post\n\tfragColor = vec4(pow(color,vec3(0.65)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Function to calculate ray-sphere intersection\nfloat raySphereIntersect(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float sphereRadius) {\n    vec3 oc = rayOrigin - sphereCenter;\n    float b = 2. * dot(oc, rayDir);\n    float c = dot(oc, oc) - sphereRadius * sphereRadius;\n    float discriminant = b * b - 4. * c;\n    if (discriminant < 0.0) return -1.0;\n    return (-b - sqrt(discriminant)) / 2.0;\n}\n\n\nmat2 rot(in float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat getsat(vec3 c)\n{\n    float mi = min(min(c.x, c.y), c.z);\n    float ma = max(max(c.x, c.y), c.z);\n    return (ma - mi)/(ma+ 1e-7);\n}\n\n\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339) * 1.93;\n\nfloat mag2(vec2 p) {\n    return dot(p, p);\n}\n\nfloat linstep(in float mn, in float mx, in float x) {\n    return clamp((x - mn) / (mx - mn), 0.0, 1.0);\n}\n\nvec2 disp(float t) {\n    return vec2(sin(t * 0.22) * 1.0, cos(t * 0.175) * 1.0) * 2.0;\n}\n\nvec3 iLerp(in vec3 a, in vec3 b, in float x)\n{\n    vec3 ic = mix(a, b, x) + vec3(1e-6,0.,0.);\n    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));\n    vec3 dir = normalize(vec3(2.*ic.x - ic.y - ic.z, 2.*ic.y - ic.x - ic.z, 2.*ic.z - ic.y - ic.x));\n    float lgt = dot(vec3(1.0), ic);\n    float ff = dot(dir, normalize(ic));\n    ic += 1.5*dir*sd*ff*lgt;\n    return clamp(ic,0.,1.);\n}\n\nfloat random(vec2 co){\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise2(in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n        (c - a) * u.y * (1.0 - u.x) +\n        (d - b) * u.x * u.y;\n}\n\nfloat fbm(in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < 5; ++i) {\n        v += a * noise2(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ),\n    hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ),\n                hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}