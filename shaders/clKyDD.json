{
    "Shader": {
        "info": {
            "date": "1700235931",
            "description": "Fork of @Shane's!\nJust added color by changing channels1 and 2 and added mouse control of camera and ray direction vary over time. Allows exploring how cool and complex @Shane's shader automata is! -TMM\n3D automata moving in a random diffusive fashion.\n",
            "flags": 32,
            "hasliked": 0,
            "id": "clKyDD",
            "likes": 3,
            "name": "Colorful/🐁 3DDiffusionAutomata",
            "published": 3,
            "tags": [
                "grid",
                "random",
                "automata",
                "cell",
                "swap",
                "walk",
                "traversal"
            ],
            "usePreview": 0,
            "username": "timmaffett",
            "viewed": 206
        },
        "renderpass": [
            {
                "code": "// Fork of \"3D Diffusion Automata\" by Shane. https://shadertoy.com/view/cl3yDN\n// 2023-11-17 15:45:14\n\n/*\n\n    Random Diffusion Automata \n    -------------------------\n    \n    Fabrice put together a pixelized diffusion example that was based on a \n    moving image he saw on X.com (both links are below), which was cool and \n    concise, but omitted smooth cell transitions. The source image contained \n    some neat sliding motion based on occupied cell elements moving to empty \n    ones -- Similar to the motion in a sliding puzzle. This is standard \n    stuff, so there are plenty of demonstrations on the internet, and even a \n    few related examples on here, but they tend to be long winded -- my own \n    efforts included...\n    \n    Digressing, SnoopethDuckDuck rearranged Fabrice's example and added the \n    necessary sliding element that gives it that smooth animated appearance.\n    However, he managed to do it using very little code and just one texture \n    channel, which was really cleverly done. After sneaking a peak at his \n    solution, then looking at my own obfuscated mess, I realized that I'd \n    really overthought it... :)\n    \n    Anyway, I'm very greatful for the aforementioned postings, and this is \n    just a 3D extension of that. I used a different template, so the variables \n    and functions don't quite match up to Fabrice and SnoopethDuckDuck's, but \n    it's basically the same thing. There is also an unlisted accompanying \n    2D example with some additional texture-based cell indexing, plus some \n    explanations for anyone interested in this kind of thing.\n    \n    I didn't put a great deal of effort into the design, as I simply wanted \n    to get one of these on the board, as they say. 3D cell swap examples are \n    not common on Shadertoy, but I'm not the first to post one of these. \n    Coposuke posted a beautiful example a couple of years ago. I've posted \n    the link below, for anyone who hasn't seen it. \n    \n    \n    // Largely based on the following:\n    \n    // Fabrice and SnoopethDuckDuck's combined logic, which is\n    // pretty difficult to compete with. It's a really nicely \n    // written example. If anyone does manage to outlogic this \n    // logic, please let me know. :) \n    Cell Swap Automata - SnoopethDuckDuck\n    https://www.shadertoy.com/view/DtccR8\n    \n    // This is inspired by Fabrice's shader\n    Shuffle gradient - random walk 3 - FabriceNeyret2 \n    https://www.shadertoy.com/view/dtSfRh\n    //\n    In turn, based on this X.com post:\n    https://twitter.com/junkiyoshi/status/1697571241513910691\n    \n    // This is my simple 2D version, which is an old version of Fabrice's\n    // that I completely rearranged to incorporate SnoopethDuckDuck's\n    // smooth cell swapping code.\n    Random Diffusion Automata - Shane\n    https://www.shadertoy.com/view/mtdyDH\n    \n    Other examples:\n    \n    // Beautifully done. I haven't had time to look it over, but I can \n    // see that the BRDF is really nicely done. My example also features \n    // BRDF patterned cubes, but that's purely coincidental.\n    High-Collar Cubes - coposuke\n    https://www.shadertoy.com/view/WldBRH\n    \n*/\n\n \n\n//////////////////////////////////\n\n\n// Max ray distance.\n#define FAR 20.\n\n// Alternate gold only color.\n//#define GOLD\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n \n\n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n// Texture sample.\n//\nvec3 getTex(sampler2D iCh, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iCh, p).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Cube mapping - Adapted from one of Fizzer's routines. \nvec4 cubeMap(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n\n    /*\n    vec3 idF = step(0., p)*2. - 1.;\n    vec3 faceID = (idF + 1.)/2. + vec3(0, 2, 4);\n    */    \n    \n    // Integer version.\n    ivec3 idF = ivec3(step(0., p))*2 - 1;\n    ivec3 faceID = (idF + 1)/2 + ivec3(0, 2, 4);\n    \n    return f.x>.5? vec4(p.yz/p.x/2. + .5, idF.x, faceID.x) : \n           f.y>.5? vec4(p.xz/p.y/2. + .5, idF.y, faceID.y) : \n                   vec4(p.xy/p.z/2. + .5, idF.z, faceID.z); \n}\n\n// IQ's 3D signed box formula.\nfloat sBoxS(vec3 p, vec3 b, float sf){\n\n    p = abs(p) - b + sf;\n    return min(max(p.x, max(p.y, p.z)), 0.) + length(max(p, 0.)) - sf;\n}\n\n \n////////////////////\n\n// Globals for the cell values, moving direction vector and cell ID.\nvec4 gCell;\nvec3 gTmDir;\nvec3 gID3;\n\nvec3 getAutomata(vec3 p, inout vec3 sc){\n\n    \n    // Obtaining the four object (particle) values for this cell.\n    // Channel values:\n    // X: Original cell position ID (for colors, etc). Needs converting to vec2.\n    // Y: Direction (clockwise from the left): Left, up, right, down (0, 1, 2, 3).\n    // Z: Transfer time. Starting (0), ending (1), or somewhere between ([0, 1]).\n    // W: Inactive or active status (0 or 1) -- Empty or not.\n    //\n    // Using \"floor(p)\" to avoid artifacts at certain resolutions.\n    //vec4 cell = texelFetch(iChannel0, ivec2(floor(p/sc)), 0);\n    \n    //vec4 cell = tMap(iChannel0, mod(floor(p/sc), wrap));\n    \n    vec2 uv = convertCoord(mod(floor(p/sc), wrap));//mod(floor(p/sc), wrap)\n    vec4 cell = texelFetch(iChannel0, ivec2(uv), 0);\n\n    // Inactive to active transfer (cell.z), or active to inactive transfer.\n    // Inactive moves forward (cell.z), active are losing a particle, so move in the\n    // opposite direction (1. - cell.z).\n    //\n    // Smoothly transition from one cell to the next. It's a minor distinction, but\n    // an asymmetric easing process needs to be applied prior to mixing.\n    cell.z = smoothstep(.15, .85, cell.z); \n    float tm = mix(cell.z, 1. - cell.z, cell.w);\n     \n    \n    \n    // Cell coordinate ID. Converting from stored float to vec2.\n    //vec3 iq = vec3(cell.x, floor(cell.x/wrap), floor(cell.x/(wrap*wrap)));\n    vec3 iq = mod(vec3(cell.x, floor(cell.x/wrap), floor(cell.x/(wrap*wrap))), wrap);\n\n\n    // Local cell coordinates.\n    vec3 q = mod(p, sc) -.5*sc; \n    \n    // Cell direction.\n    vec3 dir = indexToDir(cell.y);\n    \n    \n    gCell = cell;\n    \n \n    // Size.\n    //float rndSz = hash21(iq + .11);\n    //float obj = sBoxS(q - tm*dir, vec2(.4), .2);\n    //float obj = length(q - tm*dir) - (.4 - .0*rndSz); // Etc.\n    \n    gTmDir = tm*dir*sc;\n    \n    //q -= gTmDir;\n    \n    gID3 = iq*sc;\n    \n        \n    return q;//vec4(q, iq*sc);\n \n}\n\n\n///////////////////\n\n\n// Global cell boundary distance variables.\nvec3 gDir; // Cell traversing direction.\nvec3 gRd; // Ray direction.\nfloat gCD; // Cell boundary distance.\n// Box dimension and local XY coordinates.\nvec3 gSc; \nvec3 gP;\n\n \n// An extruded subdivided rectangular block grid. Use the grid cell's \n// center pixel to obtain a height value (read in from a height map), \n// then render a pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n \n\n  \n    // Scale. This will include two blocks, each 8 cells deep, so we'll move the wall\n    // forward by half a unit to obscure the second block.\n    vec3 sc = vec3(1./16.);\n    \n    \n    // Local coordinates and ID.\n    vec3 p = getAutomata(q3, sc);\n    vec3 id3 = gID3;\n \n\n\n    // The distance from the current ray position to the cell boundary\n    // wall in the direction of the unit direction ray. This is different\n    // to the minimum wall distance, so you need to trace out instead\n    // of merely doing a box calculation. Anyway, the following are pretty \n    // standard cell by cell traversal calculations. The resultant cell\n    // distance, \"gCD\", is used by the \"trace\" and \"shadow\" functions to \n    // restrict the ray from overshooting, which in turn restricts artifacts.\n    vec3 rC = (gDir*sc - vec3(p))/gRd;\n    //vec2 rC = (gDir.xy*sc.xy - (p))/gRd.xy; // For 2D, this will work too.\n    \n    // Minimum of all distances, plus not allowing negative distances, which\n    // stops the ray from tracing backwards... I'm not entirely sure it's\n    // necessary here, but it stops artifacts from appearing with other \n    // non-rectangular grids.\n    gCD = max(min(min(rC.x, rC.y), rC.z), 0.) + .0015;\n    //gCD = max(min(rC.x, rC.y), 0.) + .001; // Adding a touch to advance to the next cell.\n\n   \n    // Change the prism rectangle scale just a touch to create some subtle\n    // visual randomness. You could comment this out if you prefer more order.\n    sc -= .005;//*(hash21(id)*.9 + .1);\n    \n  \n    // Move the box.\n    p -= gTmDir;\n    \n\n    // Rendering the box. You could do some cool things here, but I've\n    // kept things simple.\n    float d = sBoxS(p, sc/2., .05*sc.x);\n    \n    //float dS = length(p) - sc.x/2.;\n    //d = mix(d, dS, .125);\n    \n\n    \n    \n    // This is a bit of a hack to get rid of fuzzy shadows. Basically, \n    // don't render inactive cells that are technically out of cell range.\n    if(gCell.z==1. && gCell.w == 0.) d = 1e5;\n    \n   \n\n    // Debug: Getting rid of some boxes.\n    //if(hash31(id3)<.5) d  = 1e5;\n    \n    \n    // Only include one block level (16 z-positions deep), just in front of the wall\n    if(floor(q3.z) != -1.) d = 1e5; \n    \n    // Excluding XY sheets behind this Z depth.\n    //if(floor(id3.z/sc.z)>3.) d = 1e5;\n\n    // Saving the box dimensions and local coordinates.\n    gSc = sc;//vec3(sc.xy, h);\n    gP = p;\n    \n   \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id3);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 gID, svGID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor, or wall, depending on your perspective. Kind of redundant,\n    // since you can't see it, but it's there, just in case.\n    float fl = -p.z - .5;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4; // Individual block ID.\n    \n    /*\n    // Putting the boxes in a cage... No. Dumb idea, but I had to try. :)\n    vec3 dC = vec3(1e5);\n    vec3 sc = vec3(1./16.);\n    vec3 q = mod(p + sc/2., sc) -.5*sc; \n    dC.x = sBoxS(q.xy, sc.xy*.05, .025*sc.x);\n    dC.y = sBoxS(q.yz, sc.yz*.05, .025*sc.x);\n    dC.z = sBoxS(q.xz, sc.xz*.05, .025*sc.x);\n    float dR = min(min(dC.x, dC.y), dC.z);\n    \n    fl = min(fl, dR);\n    fl = max(fl, -(p.z + 1. + .05*gSc.z));\n    */\n    \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return  min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float d, t = 0.;// hash31(ro + rd)*.15;\n    \n    //vec2 dt = vec2(1e5, 0); // IQ's clever desparkling trick.\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = step(0., rd) - .5;\n    gRd = rd; \n    \n    int i;\n    const int iMax = 128;\n    for (i = min(iFrame, 0); i<iMax; i++){ \n    \n        d = map(ro + rd*t);       \n        //dt = d<dt.x? vec2(d, dt.x) : dt; // Shuffle things along.\n        \n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, \n        // as \"t\" increases. It's a cheap trick that works in most situations.\n        if(abs(d)<.001 || t>FAR) break; \n        \n        //t += i<32? d*.75 : d; \n        t += min(d*.9, gCD); \n    }\n    \n    // If we've run through the entire loop and hit the far boundary, \n    // check to see that we haven't clipped an edge point along the way. \n    // Obvious... to IQ, but it never occurred to me. :)\n    //if(i>=iMax - 1) t = dt.y;\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with \n// limited iterations is impossible... However, I'd be very grateful if someone could \n// prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable. :)\n    const int maxIterationsShad = 64; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = step(0., rd) - .5;\n    gRd = rd;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. \n    // Obviously, the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        \n        \n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), \n        // dist += clamp(h, .01, stepDist), etc.\n        t += clamp(min(d*.9, gCD), .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Shadow.\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for(int i = 0; i<5; i++){\n    \n        float hr = float(i + 1)*.125/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);    \n    \n}\n\n\n// Surface bump function..\nfloat bumpSurf3D(in vec3 p, in vec3 n){\n\n\n    vec3 id3 = svGID.yzw;\n    vec4 c4 = cubeMap(p);\n    vec2 tuv = c4.xy;\n    float faceID = c4.w;\n\n    vec2 oTuv = tuv;\n\n    vec2 scl = vec2(1);\n    vec2 oScl = scl;\n\n\n    // The two distance field values (they overlap) and corresponding\n    // lines patterns.\n    vec4 d = Truchet(tuv, id3, faceID, scl);\n\n    // Edge width and smoothing factor.\n    float ew2 = .03*oScl.x;\n    float sf2 = .02*oScl.x;\n\n    // Saving the original cube color.\n    float objCol = (.25);\n\n    // A little extra thickness for the edges.\n    d.xy -= ew2*2.;\n\n    // Distance field shading.\n    vec2 sh = max(-d.xy/oScl.x*4., 0.);\n    sh = smoothstep(0., .65, sh);\n\n    // Rendering the two overlapping distance fields and line patterns.\n    for(int i = 0; i<2; i++){\n\n         // Line pattern.\n         float lnCol = mix(.5, .35, 1. - smoothstep(0., sf2, d[i + 2]));\n\n         // Subtle highlighting.\n         lnCol *= .25 + sh[i]*.75;\n\n         // Faux AO, dard edges and pattern.\n         objCol = mix(objCol, 0., (1. - smoothstep(0., sf2*4., d[i]))*.5);\n         objCol = mix(objCol, 0., 1. - smoothstep(0., sf2, d[i]));\n         objCol = mix(objCol, lnCol, 1. - smoothstep(0., sf2, d[i] + ew2));\n\n    }  \n    \n    return objCol;\n\n}\n\n\n \n// Standard function-based bump mapping routine: This is the cheaper four tap version. \n// There's a six tap version (samples taken from either side of each axis), but this \n// works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the \n    // aliasing.\n    const vec2 e = vec2(.001, 0);  \n    \n    mat4x3 p4 = mat4x3(p, p - e.xyy, p - e.yxy, p - e.yyx);\n    \n    // This utter mess is to avoid longer compile times. It's kind of \n    // annoying that the compiler can't figure out that it shouldn't\n    // unroll loops containing large blocks of code.\n \n    vec4 b4;\n    for(int i = min(iFrame, 0); i<4; i++){\n        b4[i] = bumpSurf3D(p4[i], n);\n        if(n.x>1e5) break; // Fake break to trick the compiler.\n    }\n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    vec3 grad = (b4.yzw - b4.x)/e.x; \n   \n    \n    // Six tap version, for comparisson. No discernible visual difference, in a lot of \n    //cases.\n    //vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n    //                 bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n    //                 bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    \n  \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some \n    // kind of orthogonal space fix using the Gram-Schmidt process, or something to that \n    // effect.\n    grad -= n*dot(n, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more \n    // bumpy.\n    return normalize(n + grad*bumpfactor);\n\t\n}\n\n///////////////////////////\n\n/*\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. \n// I tried to make it as concise as possible. Whether that translates to speed, \n// or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale \n    // texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), \n                  tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks \n    // to EvilRyu for reminding me why we perform this step. It's been a while, but I \n    // vaguely recall that it's some kind of orthogonal space fix using the Gram-Schmidt \n    // process. However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n} \n*/\n\n//////////\n\n// simple mouse rotate and zoom for shader\n#define pi 3.14159265359 \n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n\nvec2 mouseRotZoom(vec2 uv) {\n    vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(0.20, 0.17) : iMouse.xy/iResolution.xy;\n    // allow mouse zoom and rotate    \n    uv.xy *= r2d(-(mouse.x)*pi*2.);\n    uv *= (1./(10.0*mouse.y));\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.    \n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\tuv = mouseRotZoom(uv); // TMM allow mouse to modify uv from start\n    \n\t// Camera Setup.\n\tvec3 lk = vec3(iTime/32., .036, -1); // \"Look At\" position.\n\tvec3 ro = lk + vec3(-.04, .12, -.3);  // Camera position.\n \n \n // TMM and further let mouse moidify camera position\n vec2 mouse = iMouse.xy / iResolution.xy - 0.5; // <-0.5,0.5>\n ro = ro + vec3( 0.25*mouse.x, 0.02, 0.28 *mouse.y);\n\n\n\n    // Light positioning.\n    vec3 lp = ro + vec3(1, .38, -.5);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x ));\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    //TMM and let time move our ray direction with influence from mouse\n    rd *= rotateY(sin(iTime) * mouse.y*0.5); //tmm\n    rd *= rotateX(cos(iTime) * mouse.x*0.5);\n    \n    // Rough fish-eye lens.\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.125, 0.))));\n    \n    // Evening the camera up a bit.\n    rd.xy *= rot2(-.02);\n    \n    /*\n    // Mouse movement.\n    if(iMouse.z>1.){\n        rd.yz *= rot2(-(iMouse.y - iResolution.y*.5)/iResolution.y*3.1459);  \n        rd.xz *= rot2(-(iMouse.x - iResolution.x*.5)/iResolution.x*3.1459);  \n    } \n    */  \n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID and object ID.\n    svGID = gID;\n    \n    // Scene object ID. Either the pylons or the floor.\n    float svObjID = objID;\n    \n    // Saving the bloxk scale and local 2D base coordinates.\n    vec3 svSc = gSc;\n    vec3 svP = gP;\n    \n    // Saving the moving direction position vector.\n    vec3 svDir = gTmDir;\n    \n\t\n    // Initiate the scene color to black.\n    vec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n\n        \n        // Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n        \n          \n        // Obtaining the texel color. \n\t    vec3 objCol; \n        \n        \n        vec3 svTx;\n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n             vec3 txP = svP;//vec3(svP, sp.z);\n            //txP.xy += svDir;\n            \n            vec3 id3 = svGID.yzw;\n            \n            // Random coloring using IQ's short versatile palette formula.\n            //float rnd = hash31(id3 + .34);\n            //vec3 sCol = .5 + .45*cos(6.2831853*rnd/1. + vec3(0, 1, 2) + .8);\n            \n            \n            // Coloring the individual blocks with the saved ID.\n            vec2 id2 = convertCoord(floor(id3/svSc.x));\n            vec3 col1 = getTex(iChannel1, id2*svSc.x/2.);\n            col1 = smoothstep(.0, .5, col1);\n            \n            // More coloring.\n            vec3 col2 = getTex(iChannel2, id2*svSc.x/2.);\n            col2 = smoothstep(-.1, .35, col2);\n            \n            // Grunge texturing.\n            vec3 tx1 = tex3D(iChannel1, (id3 + txP)*2., sn);\n            vec3 tx2 = tex3D(iChannel1, (id3 + txP)*4., sn);\n            tx1 = smoothstep(.0, .5, tx1);\n             \n            // Random colors.\n            objCol = (hash31(id3 + .22)<.333)? col2 : col1;\n            \n            // Interwoven checkered colors.\n            //vec3 id = floor(id3/svSc);\n            //if(mod(id.x + id.y + id.z, 2.)<.5) objCol = objCol.zyx;\n\n                      \n            // Texturing the colored boxes and adding some sepia.\n            objCol *= vec3(1.5, 1.25, 1)*(tx2*3. + .25);\n \n            \n            #ifdef GOLD \n            // Alternate gold coloring.\n            objCol = vec3(.3 + hash31(id3 + .51)*.4);\n            if(hash31(id3 + .21)<1.5)\n            objCol = .5 + .45*cos(6.2831853*hash31(id3 + .32)/8. + vec3(0, 1.2, 2) + .25);\n            objCol *= vec3(1, 1.1, 1.2);\n            //if(hash31(id3 + .26)<.5) objCol = mix(objCol, objCol.zyx, .75);\n            objCol *= (tx2*3. + .25);\n            #endif\n             \n            //////////////////////\n            // Rendering a cliche art deco multiscale Truchet design onto the cube faces.\n            vec4 c4 = cubeMap(svP);\n            vec2 tuv = c4.xy;\n            float faceID = c4.w;\n\n            vec2 oTuv = tuv;\n\n            vec2 scl = vec2(1);\n            vec2 oScl = scl;\n\n            \n            // The two distance field values (they overlap) and corresponding\n            // lines patterns.\n            vec4 d = Truchet(tuv, id3, faceID, scl);\n\n            // Edge width and smoothing factor.\n            float ew2 = .03*oScl.x;\n            float sf2 = .01*oScl.x;\n            \n            \n            // Evening up the tone, just a little.\n            objCol = mix(objCol, objCol/(1./3. + dot(objCol, vec3(.299, .587, .114))), .5);\n\n            // Saving the original cube color.\n            vec3 svCol = objCol;\n            objCol /= 2.; // Darkening the background.\n\n            // A little extra thickness for the edges.\n            d.xy -= ew2*2.;\n            \n            // Distance field shading.\n            vec2 sh = max(-d.xy/oScl.x*4., 0.);\n            sh = smoothstep(0., .65, sh);\n\n            // Rendering the two overlapping distance fields and line patterns.\n            for(int i = 0; i<2; i++){\n\n                 // Line pattern.\n                 vec3 lnCol = svCol*1.;\n                 lnCol = mix(lnCol, svCol*.25, 1. - smoothstep(0., sf2, d[i + 2]));\n                 \n                 // Subtle highlighting.\n                 lnCol *= .75 + sh[i]*.5;\n\n                 // Faux AO, dard edges and pattern.\n                 objCol = mix(objCol, vec3(0), (1. - smoothstep(0., sf2*8., d[i]))*.5);\n                 objCol = mix(objCol, svCol*.125, 1. - smoothstep(0., sf2, d[i]));\n                 objCol = mix(objCol, lnCol, 1. - smoothstep(0., sf2, d[i] + ew2));\n\n            }\n            \n            \n            // Bump map the above pattern. Not as nice as displacement mapping\n            // in the distance function, but way effective, and way cheaper.\n            // The bump is subtle, but it's there. Too much can be overpowering.\n            sn = doBumpMap(svP, sn, .003);\n              \n\n            // Save the texture postion.\n            svTx = (id3 + txP)*2.;\n \n        }\n        else {        \n            \n            // The dark wall in the background. Hidden behind the boxes.\n            vec3 tx = tex3D(iChannel1, sp*4., sn);\n            objCol = vec3(1.5, 1.25, 1)*(tx*3. + .05)/2.;\n             \n            // Save the texture postion.\n            svTx = sp*4.;\n        }\n        \n        // Adding a purple tinge.\n        //objCol = mix(objCol, objCol*vec3(2, 1, .5).yzx, .5);\n        \n        \n        // Texture based bump mapping. You'd need to uncomment the\n        // bump map function first.\n        //sn = texBump(iChannel1, svTx, sn, .001);///(1. + t/FAR)\n        \n        \n        \n\n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n    \t\n    \t// Diffuse lighting.\n\t    //float diff = max( dot(sn, ld), 0.);\n        \n        float roughness = min(dot(objCol, vec3(.299, .587, .114))*.75 + .15, 1.);\n        float reflectance = .5;\n        float matType = 1.;\n            \n         \n        // Cheap specular reflections. Requires loading the \"Forest\" cube map \n        // into \"iChannel3\".\n        float speR = pow(max(dot(normalize(ld - rd), sn), 0.), 5.);\n        vec3 rf = reflect(rd, sn); // Surface reflection.\n        \n        //TMM\n        //vec3 rTx = vec3(1.12);// \n        vec3 rTx =texture(iChannel3, rf.xzy*vec3(1, -1, -1)).xyz;\n        \n        rTx *= rTx;\n        float spF = 2.; //svObjID<.5? 4. : 2.;\n        objCol = objCol + objCol*speR*rTx*spF;\n         \n        // I wanted to use a little more than a constant for ambient light this \n        // time around, but without having to resort to sophisticated methods, then I\n        // remembered Blackle's example, here:\n        // Quick Lighting Tech - blackle\n        // https://www.shadertoy.com/view/ttGfz1\n        //float am = pow(length(sin(sn*2.)*.5 + .5)/sqrt(3.), 2.)*1.75; // Studio.\n        float am = length(sin(sn*2.)*.5 + .5)/sqrt(3.)*smoothstep(-1., 1., -sn.z); // Outdoor.\n        //float am = clamp(.5 - .35*(rd.x - rd.y), 0., 1.);        \n\n        // Cook-Torrance based lighting.\n        vec3 ct = BRDF(objCol, sn, ld, -rd, matType, roughness, reflectance);\n \n        // Combining the ambient and microfaceted terms to form the final color:\n        // None of it is technically correct, but it does the job. Note the hacky \n        // ambient shadow term. Shadows on the microfaceted metal doesn't look \n        // right without it... If an expert out there knows of simple ways to \n        // improve this, feel free to let me know. :)\n        col = (objCol*am*(sh*.5 + .5) + ct*(sh));        \n        \n        // Ambient occlusion and attenuation.\n        col *= ao*atten;\n          \n           \n\t\n\t}\n    \n    \n    // Applying fog: This fog begins at 90% towards the horizon.\n    col = mix(col, vec3(1), smoothstep(.25, .9, t/FAR));\n \n    // Very basic Reinhard tone mapping.\n    col = col/(1. + col/3.);\n    \n    // Greyscale.\n    //col = vec3(1)*dot(col, vec3(.299, .587, .114));\n    \n \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// A cube of dimension 8 and a square of dimension 64 will\n// each require the same number of pixels for storage.\nconst float wrap = 8.; // (2^3)*(2^3)*(2^3) = 2^12.\nconst float cubeMapRes = 64.; // (2^6)*(2^6) = 2^12.\n\n/////////////////////\n/////////////////////\n\n// I might replace this with the Murmurhash functions, but I wanted\n// to try these out first, since I like the simplicity, and they're\n// supposed to be fast. Anyway, you can read all about it, here:\n\n// A Mind Forever Programming - Random Floats in GLSL 330\n// Author: Lee C\n// https://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n \nuint hash( uint x ){\n    x += ( x << 10u ); x ^= ( x >>  6u );\n    x += ( x <<  3u ); x ^= ( x >> 11u );\n    x += ( x << 15u ); return x;\n}\n\nuint hash( uvec2 v ){ return hash( v.x ^ hash(v.y) ); }\nuint hash( uvec3 v ){ return hash( v.x ^ hash(v.y) ^ hash(v.z) ); }\nuint hash( uvec4 v ){ return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\nfloat hash41( vec4 f ){\n\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n    \n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.;\n}\n\nfloat hash31( vec3 f ){\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n    \n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.;\n}\n\nfloat hash21( vec2 f ){\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n    \n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.;\n}\n\n//////////////////////\n\n// Converting pixels on a 2D square area to their equivalent \n// 3D positions and back again: For anyone who finds this confusing,\n// I've explained the simple process below.\n\n\nvec3 convertCoord(vec2 p){\n\n    // Convert the 2D coordinate to its equivalent 3D coordinates.\n    \n    // 2D coordinate -- Wrapping isn't mandatory, but this is a wrapped example.\n    p = mod(floor(p), cubeMapRes); \n    // Converting the above 2D coordinate to its linear representation.\n    float i = p.x + p.y*cubeMapRes;\n\n    // Converting the linear number above to 3D coordinates. The wrapping is\n    // overkill here, since things have been arranged to fit perfectly, \n    // but it's there anyway.\n    return mod(vec3(i, floor(i/wrap), floor(i/(wrap*wrap))), wrap);\n}\n\nvec2 convertCoord(vec3 p){\n\n    // Convert the 3D coordinates to its equivalent 2D coordinates.\n    \n    // Wrapping the 3D coordinates first -- Only for this example.\n    p = mod(floor(p), wrap);\n    // Converting the above 3D coordinate to its linear representation.\n    float i = p.x + (p.y + p.z*wrap)*wrap;\n    // Converting the linear number above to 2D coordinates. The wrapping is\n    // overkill here, since things have been arranged to fit perfectly, \n    // but it's there anyway.\n    return mod(vec2(i, floor(i/cubeMapRes)), cubeMapRes);\n}\n\n\n\n/*\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n*/\n\n/* \n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash31(vec3 f){\n\n    //f.xy = mod(f.xy, 1.);\n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n*/\n\n/*\n// IQ's \"uint\" based uvec4 to float hash.\nfloat hash41(vec4 f){\n\n    uvec4 p = floatBitsToUint(f);\n    uint h32 = 19u*p.x + 47u*p.y + 101u*p.z + 131u*p.w + 173u;\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n*/\n\n/*\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n*/\n\n// Six cube face directions.\nconst vec3[6] e = vec3[6](vec3(-1, 0, 0), vec3(1, 0, 0), vec3(0, -1, 0), vec3(0, 1, 0),\n                          vec3(0, 0, -1), vec3(0, 0, 1));\n \nvec3 indexToDir(float i) {\n   // Converts the indices 0 through to 5 to one of the direction above.\n   return e[int(i)]; \n}\n\nfloat dirToIndex(vec3 p) {\n    \n    // Converts the left, right, down, up, backward, forward \n    // vectors to 0, 1, 2, 3,  4 or 5 respectively.\n    for(int i = 0; i<6; i++){\n        if(p == e[i]) return float(i);\n    }\n    \n    // Redundant, because the above will always return... but I'm paranoid, \n    // so if one day it doesn't, this will be waiting. :D\n    return 0.;\n}\n\nfloat rndDirIndex(vec4 ut){\n    // Returns a random number based on 2D position and time.\n    return mod(floor(96.*hash41(ut)), 6.);\n}\n\nfloat rndDirIndex(vec4 ut, float maxM){\n    // Returns a random number based on 2D position and time,\n    // but with restrictions.\n    return mod(floor(72.*hash41(ut)), maxM);\n}\n\nvec3 rndDir(vec4 u) {\n    // Returns a random direction.\n    return indexToDir(rndDirIndex(u));\n}\n\nvec3 rndDir(vec4 u, float maxM) {\n    // Returns a random direction with restrictions.\n    return indexToDir(rndDirIndex(u, maxM));\n}\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\n///////////////////////////\nconst float PI = 3.14159265;\n\n// Microfaceted normal distribution function.\nfloat D_GGX(float NoH, float roughness) {\n    float alpha = pow(roughness, 4.);\n    float b = (NoH*NoH*(alpha - 1.) + 1.);\n    return alpha/(PI*b*b);\n}\n\n// Surface geometry function.\nfloat G1_GGX_Schlick(float NoV, float roughness) {\n    //float r = roughness; // original\n    float r = .5 + .5*roughness; // Disney remapping.\n    float k = (r*r)/2.;\n    float denom = NoV*(1. - k) + k;\n    return max(NoV, .001)/denom;\n}\n\nfloat G_Smith(float NoV, float NoL, float roughness) {\n    float g1_l = G1_GGX_Schlick(NoL, roughness);\n    float g1_v = G1_GGX_Schlick(NoV, roughness);\n    return g1_l*g1_v;\n}\n\n// Bidirectional Reflectance Distribution Function (BRDF). \n//\n// If you want a quick crash course in BRDF, see the following:\n// Microfacet BRDF: Theory and Implementation of Basic PBR Materials\n// https://www.youtube.com/watch?v=gya7x9H3mV0&t=730s\n//\nvec3 BRDF(vec3 col, vec3 n, vec3 l, vec3 v, \n          float type, float rough, float fresRef){\n     \n  vec3 h = normalize(v + l); // Half vector.\n\n  // Standard BRDF dot product calculations.\n  float nv = clamp(dot(n, v), 0., 1.);\n  float nl = clamp(dot(n, l), 0., 1.);\n  float nh = clamp(dot(n, h), 0., 1.);\n  float vh = clamp(dot(v, h), 0., 1.);  \n\n  \n  // Specular microfacet (Cook- Torrance) BRDF.\n  //\n  // F0 for dielectics in range [0., .16] \n  // Default FO is (.16 * .5^2) = .04\n  // Common Fresnel values, F(0), or F0 here.\n  // Water: .02, Plastic: .05, Glass: .08, Diamond: .17\n  // Copper: vec3(.95, .64, .54), Aluminium: vec3(.91, .92, .92), Gold: vec3(1, .71, .29),\n  // Silver: vec3(.95, .93, .88), Iron: vec3(.56, .57, .58).\n  vec3 f0 = vec3(.16*(fresRef*fresRef)); \n  // For metals, the base color is used for F0.\n  f0 = mix(f0, col, type);\n  vec3 F = f0 + (1. - f0)*pow(1. - vh, 5.);  // Fresnel-Schlick reflected light term.\n  // Microfacet distribution... Most dominant term.\n  float D = D_GGX(nh, rough); \n  // Geometry self shadowing term.\n  float G = G_Smith(nv, nl, rough); \n  // Combining the terms above.\n  vec3 spec = F*D*G/(4.*max(nv, .001));\n  \n  \n  // Diffuse calculations.\n  vec3 diff = vec3(nl);\n  diff *= 1. - F; // If not specular, use as diffuse (optional).\n  diff *= (1. - type); // No diffuse for metals.\n\n  \n  // Combining diffuse and specular.\n  // You could specify a specular color, multiply it by the base\n  // color, or multiply by a constant. It's up to you.\n  return (col*diff + spec*PI);\n  \n}\n////////////////////\n\n// An art deco multiscale Truchet pattern. Made up on the spot, \n// but it seems to work.\nvec4 Truchet(vec2 p, vec3 cellID, float faceID, inout vec2 scl){\n      \n\n     // Save coordinates.\n     vec2 oP = p;\n\n\n     // Scaling, ID, and local coordinates.\n     vec2 oScl = scl;\n     vec2 id2 = floor(p/scl) + .5;\n     p -= (id2)*scl;//mod(tuv, scl) - scl/2.;\n     \n     // Unique face identifier.\n     vec3 id3 = cellID + vec3(id2/12., faceID/12.);\n\n     // Random subdivision.\n     int divN = 0;\n     if(hash31(id3 + .09)<.5){ \n         scl /= 2.; \n         p = oP;\n         id2 = floor(p/scl) + .5;\n         //p = mod(p, scl) - scl/2.;\n         p -= (id2)*scl;\n         \n         id3 = cellID + vec3(id2/12., faceID/12.);\n         \n         divN++; // Subdivision number.\n     }\n\n\n     \n     // Random coordinate rotation.\n     //if(hash31(id3 + .42)<.5) p = rot2(3.14159/2.*floor(hash21(id3 + .01)*32.))*p;\n     if(hash31(id3 + .42)<.5) p = p.yx*vec2(-1, 1);\n\n     // The distance field holder. The pattern involves rending overlapping,\n     // so requires to place holders.\n     vec2 dd = vec2(1e5);\n     \n     // Triangle experiment for next time.\n     //vec2 rTuv = rot2(3.14159/4.)*tuv;\n     //dd.x = (tuv.x + tuv.y)*.7071;\n     //dd.y = -(tuv.x + tuv.y)*.7071;\n     //dd = max(dd, max(abs(tuv.x), abs(tuv.y)) - scl.x/2.);\n     \n     // Cell bounds.\n     //float bx = sBoxS(p, scl/2. - .005, 0.);\n\n     \n     if(hash31(id3 + .12)<.65){\n     \n         // Random arcs, interspersed with random points that \n         // break up the pattern.\n\n         if(hash31(id3 + .19)<.65){\n             dd.x = length(p - scl/2.);\n             dd.x = abs(dd.x - scl.x/2.);\n         }\n         else {\n             dd.x = length(p - vec2(1, 0)*scl/2.);\n             dd.x = min(dd.x, length(p - vec2(0, 1)*scl/2.));\n         }\n\n         if(hash31(id3 + .21)<.65){\n             dd.y = length(p + scl/2.);\n             dd.y = abs(dd.y - scl.y/2.);\n         }\n         else {\n             dd.y = length(p - vec2(-1, 0)*scl/2.);\n             dd.y = min(dd.y, length(p - vec2(0, -1)*scl/2.));\n             \n         }  \n\n     }\n     else {\n     \n         // Random lines, interspersed with random points that \n         // break up the pattern.\n\n         if(hash31(id3 + .13)<.65){\n             dd.x = abs(p.y);\n         }\n         else {\n             dd.x = length(p - vec2(-1, 0)*scl/2.);\n             dd.x = min(dd.x, length(p - vec2(1, 0)*scl/2.));\n         }\n\n         if(hash31(id3 + .14)<.65){\n             dd.y = abs(p.x);\n         }\n         else {\n             dd.y = length(p - vec2(0, -1)*scl/2.);\n             dd.y = min(dd.y, length(p - vec2(0, 1)*scl/2.));\n         }\n     }\n\n\n     // Line pattern.\n     float lNum = 12./oScl.x;\n     float offs = divN==0? .5 : .5; //  Different for different scales.\n     vec2 pat = (abs(fract(dd*lNum + offs) - .5) - .2)/lNum;\n     //vec2 pat = vec2(1e5);//\n\n     // If not subdivided, split the pattern and move it to match the\n     // position of the subdivided one. It's one of many standard\n     // multiscale pattern moves.\n     if(divN == 0) dd = abs(dd - .25*scl.x);\n     //dd = abs(dd + .125) - .125;\n    \n     // Apply some scale based width.\n     dd.xy -= .24/2.*oScl;\n     \n     \n     \n     // Randomize the rendering order to mix things up more.\n     if(hash31(id3 + .15)<.5){ dd = dd.yx; pat = pat.yx; }\n     \n     //dd = max(dd, sBoxS(tuv, scl/2. - .005, 0.));\n \n\n     // Return the overlapping Truchet pattern distances \n     // and the lines pattern distances.\n     return vec4(dd, pat);  \n\n}\n\n\n\n\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n\n    // Reject any pixels outside the wrapping area to lessen the GPU load.\n    if(fragCoord.x>cubeMapRes || fragCoord.y>cubeMapRes) discard;\n\n\n    // Wrapped coordinates... Kind of redundant here, since we're rejecting\n    // pixels outside this area range, but it's good practice.\n    vec2 u = mod(fragCoord, cubeMapRes);\n    vec4 col;\n    \n    // Convert the 2D canvase coordinates to 3D coordinates.\n    vec3 p = convertCoord(u);\n\n    \n    if(textureSize(iChannel0, 0).x<2 || iFrame==0){ // || iMouse.z>0.\n    \n        // Initial setup conditions:\n        \n        // Initial cell index: This is a 2D position (in float form), which \n        // allows for diffusion of pictures. However, any initial cell \n        // identifier (like a random number) can be put here.\n        col.x = p.x + p.y*wrap + p.z*wrap*wrap;\n        //col.x = p.x + (p.y + p.z*wrap)*wrap;\n        //col.x = floor(u.x/4) + floor(u.y/4.)*iResolution.y;\n        // Direction index. Clockwise from the left. 0,1,2,3.\n        col.y = 0.; // Any number will do.\n        // When conditions are met, the cell object will transfer from one\n        // cell to the next via an interpolating mechanism that ranges\n        // between zero and one.\n        //\n        // Motion timer [0,1] range. Thanks, SnoopethDuckDuck.\n        col.z = 1.; // Put it into \"accepting new transfer\" mode.\n        // Initial random active/inactive threshold. It could be pattern\n        // based, random, or whatever you wish. This one is obviously random.\n        col.w = step(.4, hash31(p + .11)); // Inactive or active: 0 or 1.\n        \n           \n    } \n    else {\n    \n        // Obtain the current stored cell states.\n        col = texelFetch(iChannel0, ivec2(u), 0);  \n        \n        // Obtain the current stored cell states.\n        //vec2 uv = convertCoord(p);\n        //col = texelFetch(iChannel0, ivec2(uv), 0);  \n\n        \n        // I wanted the cells to wrap along the XY plane, but at the same \n        // time be clamped to the near and far Z walls. The solution is very\n        // simple... but still took me an hour. :) In the XY directions, let\n        // the cells objects move in all six directions. However, if they hit \n        // the front or back Z positions, don't allow them to move in the Z \n        // direction... OMG, that was so obvious. :D\n        float maxDirections = (p.z<0. || p.z>=wrap)? 4. : 6.;\n        \n        // Obtain the random direction for this pixel at this point in time.\n        vec3 dir = rndDir(vec4(p, iFrame), maxDirections); \n  \n        \n        // Use the random direction above to move to the neighboring cell in that \n        // direction, then obtain the random direction for that cell... That was a \n        // bit wordy, but a lot of this stuff depends on understanding it.\n        //\n        vec3 nP = p + dir; // Neighboring cell position.\n        // Neighboring cell movement needs to be restricted along the far Z planes also.\n        if(nP.z<0. || nP.z>=wrap) maxDirections = 4.;\n        // The random direction value in the neighboring cell... Not the direction\n        // to the neighboring cell, which is a different entity.\n        vec3 dirNgbr = rndDir(vec4(mod(nP, wrap), iFrame), maxDirections); \n        // Obtain the cell information for that neighbor as well.\n        //vec4 colNgbr = texelFetch(iChannel0, ivec2(mod(p + dir, wrap)), 0);\n        vec2 uvN = convertCoord(mod(nP, wrap));\n        vec4 colNgbr = texelFetch(iChannel0, ivec2(uvN), 0);\n         \n        \n        // If a transfer is still in progress, update the transfer timer -- which,\n        // in turn, will be converted to cell object position.\n        if (col.z < 1.){ \n            // Increment the motion timer.\n            \n            // Converting to 3D cell coordinates.\n            vec3 ip = mod(vec3(col.x, floor(col.x/wrap), floor(col.x/(wrap*wrap))), wrap);\n            \n            float rnd = hash31(ip + .2); // Random number for each cell.\n            float dS =  (1. - rnd*.66)*3.*iTimeDelta; // Incremental distance change.\n            col.z = min(col.z + dS, 1.); // Increasing the distance, whilst not overshooting.\n        }\n        // Both cells (current and neighbor) need to have completed a motion transfer \n        // and be awaiting te next transfer (\"col.z == 1.\" and \"colNgbr.z == 1\").\n        //\n        // The transfer between cells needs to be valid (the cell and neighbor directions \n        // need to point toward each other). Finally, two empty or two full cells obviously \n        // can't cell swap, which leaves full to empty, or empty to full. In other words, \n        // an active cell can only transfer to an inactive one, or an inactive cell can only\n        // receive a transfer from a full one (Ie. col.a != colNgbr.a).\n        else if(colNgbr.z == 1. && dir == -dirNgbr && col.w != colNgbr.w) {\n    \n            // An inactive cell will receive the index of the transferring\n            // active cell.\n            if (col.w == 0.) col.x = colNgbr.x; // New index.\n            col.y = dirToIndex(dir); // Store the random direction index at this time point.\n            col.z = 0.;          // Reset the timer back to the start.\n            col.w = colNgbr.w;   // The inactive cell will now be active, and vice versa.\n \n        }\n        \n        \n    }\n    \n    // Store the updated values to the buffer.\n    fragColor = col;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}