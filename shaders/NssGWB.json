{
    "Shader": {
        "info": {
            "date": "1616480823",
            "description": "splits the UI into two, including mouse events.\nactual shaders from IQ: https://www.shadertoy.com/view/lssGRM\nand TDM: https://www.shadertoy.com/view/Ms2SD1\n\ntbh, I haven't tested mouse z & w.",
            "flags": 32,
            "hasliked": 0,
            "id": "NssGWB",
            "likes": 12,
            "name": "UI splitter",
            "published": 3,
            "tags": [
                "ui",
                "util",
                "splitter",
                "taggui"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 439
        },
        "renderpass": [
            {
                "code": "// splits the UI into two.\n// actual shaders from IQ: https://www.shadertoy.com/view/4sX3Rn\n// and TDM: https://www.shadertoy.com/view/Ms2SD1\n\nvec3 gResolution;\nvec4 gMouse;\n\nvoid mainImageLeft( out vec4 fragColor, in vec2 fragCoord );\nvoid mainImageRight( out vec4 fragColor, in vec2 fragCoord );\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    vec2 splitInfo = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    float splitPos = splitInfo.x;\n    bool isGrabbed = splitInfo.y == 1.0;\n   \n    RGBA = vec4(vec3(isGrabbed ? 1.0 : 0.5), 1.0);\n    \n    if (XY.x < splitPos - splitterRad) {\n        gResolution   = iResolution;\n        gResolution.x = splitPos - splitterRad;\n        gMouse        = texelFetch(iChannel0, ivec2(1, 0), 0);\n        mainImageLeft(RGBA, XY);\n    }\n    else if (XY.x > splitPos + splitterRad) {\n        gResolution   = iResolution;\n        gResolution.x = iResolution.x - splitPos - splitterRad;\n        gMouse        = texelFetch(iChannel0, ivec2(2, 0), 0);\n        mainImageRight(RGBA, vec2(XY.x - splitPos - splitterRad, XY.y));\n    }\n}\n\n///////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////\n/*\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\nconst int NUM_STEPS = 8;\nconst float PI      = 3.141592;\nconst float EPSILON = 1e-3;\n#define EPSILON_NRM (0.1 / gResolution.x)\n#define AA_AA\n\n// sea\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n// math\nmat3 fromEuler(vec3 ang) {\n    vec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n    m[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n    m[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n    return m;\n}\nfloat hash( vec2 p ) {\n    float h = dot(p,vec2(127.1,311.7)); \n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );    \n    vec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\n}\n\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map_AA(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n        d = sea_octave((uv+SEA_TIME)*freq,choppy);\n        d += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n        uv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n        d = sea_octave((uv+SEA_TIME)*freq,choppy);\n        d += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n        uv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\n    fresnel = pow(fresnel,3.0) * 0.5;\n        \n    vec3 reflected = getSkyColor(reflect(eye,n));    \n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    color += vec3(specular(n,l,eye,60.0));\n    \n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map_AA(ori + dir * tx);\n    if(hx > 0.0) return tx;   \n    float hm = map_AA(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n        float hmid = map_AA(p);\n        if(hmid < 0.0) {\n            tx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\nvec3 getPixel(in vec2 coord, float time) {    \n    vec2 uv = coord / gResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= gResolution.x / gResolution.y;    \n        \n    // ray\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \n    vec3 ori = vec3(0.0,3.5,time*5.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    // color\n    return mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n        pow(smoothstep(0.0,-0.02,dir.y),0.2));\n}\n\n// main\nvoid mainImageLeft( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime * 0.3 + gMouse.x*0.01;\n    \n#ifdef AA_AA\n    vec3 color = vec3(0.0);\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 uv = fragCoord+vec2(i,j)/3.0;\n            color += getPixel(uv, time);\n        }\n    }\n    color /= 9.0;\n#else\n    vec3 color = getPixel(fragCoord, time);\n#endif\n    \n    // post\n    fragColor = vec4(pow(color,vec3(0.65)), 1.0);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////\n\n// Created by inigo quilez - iq/2013\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n// If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\nfloat hash( float n )\n{\n    return fract(sin(n)*1751.5453);\n}\n\nfloat hash1( vec2 p )\n{\n    return fract(sin(p.x+131.1*p.y)*1751.5453);\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n// ripped from Kali's Lonely Tree shader\nmat3 rotationMat(vec3 v, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n                (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n                (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z);\n}\n\nvec3 axis = normalize( vec3(-0.3,-1.,-0.4) );\n\nvec2 map( vec3 p )\n{\n    // animation\n    float atime = iTime+12.0;\n    vec2 o = floor( 0.5 + p.xz/50.0  );\n    float o1 = hash( o.x*57.0 + 12.1234*o.y );\n    float f = sin( 1.0 + (2.0*atime + 31.2*o1)/2.0 );\n    p.y -= 2.0*(atime + f*f);\n    p = mod( (p+25.0)/50.0, 1.0 )*50.0-25.0;\n    if( abs(o.x)>0.5 )  p += (-1.0 + 2.0*o1)*10.0;\n    mat3 roma = rotationMat(axis, 0.34 + 0.07*sin(31.2*o1+2.0*atime + 0.1*p.y) );\n    // modeling\n    for( int i=0; i<16; i++ )\n    {\n        p = roma*abs(p);\n        p.y-= 1.0;\n    }\n    float d = length(p*vec3(1.0,0.1,1.0))-0.75;\n    float h = 0.5 + p.z;\n    return vec2( d, h );\n}\n\nvec3 raycast( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 140.0;\n    float precis = 0.001;\n    float t = 0.0;\n    float d = 0.0;\n    float m = 1.0;\n    for( int i=0; i<200; i++ )\n    {\n        vec2 res = map( ro+rd*t );\n        if( res.x<precis||t>maxd ) break;\n        t += 0.6*min( res.x, 5.0 );\n        d = res.y;\n    }\n    if( t>maxd ) m=-1.0;\n    return vec3( t, d, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.2,0.0,0.0);\n    return normalize( vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<128; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n        if( res<0.0001 ) break;\n        t += clamp( h, 0.01, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float totao = 0.0;\n    for( int aoi=0; aoi<16; aoi++ )\n    {\n        vec3 aopos = -1.0+2.0*hash3(float(aoi)*213.47);\n        aopos *= sign( dot(aopos,nor) );\n        aopos = pos + aopos*0.5;\n        float dd = clamp( map( aopos ).x*4.0, 0.0, 1.0 );\n        totao += dd;\n    }\n    totao /= 16.0;\n    return clamp( totao*totao*1.5, 0.0, 1.0 );\n}\n\nvec3 lig = normalize(vec3(-0.5,0.7,-1.0));\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 fc )\n{\n    // render\n    vec3 bgc = 0.6*vec3(0.8,0.9,1.0)*(0.5 + 0.3*rd.y);\n    vec3 col = bgc;\n    // raymarch\n    vec3 tmat = raycast(ro,rd);\n    float dis = tmat.x;\n    if( tmat.z>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n        // material\n        vec3 mate = 0.5 + 0.5*mix( sin( vec3(1.2,1.1,1.0)*tmat.y*3.0 ),\n                                  sin( vec3(1.2,1.1,1.0)*tmat.y*6.0 ),\n                                  1.0-abs(nor.y) );\n        // lighting\n        float occ = calcAO( pos, nor );\n        float amb = 0.8 + 0.2*nor.y;\n        float dif = max(dot(nor,lig),0.0);\n        float bac = max(dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))),0.0);\n        float sha = 0.0; if( dif>0.001 ) sha=softshadow( pos+0.001*nor, lig, 0.1, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n        // lights\n        vec3 brdf = vec3(0.0);\n        brdf += 1.0*dif*vec3(1.00,0.90,0.65)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n        brdf += 1.0*amb*vec3(0.05,0.05,0.05)*occ;\n        brdf += 1.0*bac*vec3(0.03,0.03,0.03)*occ;\n        brdf += 1.0*fre*vec3(1.00,0.70,0.40)*occ*(0.2+0.8*sha);\n        brdf += 1.0*occ*vec3(1.00,0.70,0.30)*occ*max(dot(-nor,lig),0.0)*pow(clamp(dot(rd,lig),0.0,1.0),64.0)*tmat.y*2.0;\n        // surface-light interacion\n        col = mate * brdf;\n        // fogt\n        col = mix( col, bgc, clamp(1.0-1.2*exp(-0.0002*tmat.x*tmat.x ),0.0,1.0) );\n    }\n    else\n    {\n        // sun\n        vec3 sun = vec3(1.0,0.8,0.5)*pow( clamp(dot(rd,lig),0.0,1.0), 32.0 );\n        col += sun;\n        dis = 140.0;\n    }\n    \n    // god rays\n    #if 0\n    float gr = 0.0;\n    float t = 10.1 * hash1(fc);\n    for( int i=0; i<32; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float dt = clamp(0.3*t,1.0,10.0);\n        gr += dt*softshadow( pos, lig, 0.01, 128.0 );\n        t  += dt;\n        if( t>dis ) break;\n    }\n    col += vec3(1.0,0.9,0.7)*pow(gr*0.004,2.0) - 0.02;\n    #endif\n    \n    // sun scatter\n    col += 0.6*vec3(0.2,0.14,0.1)*pow( clamp(dot(rd,lig),0.0,1.0), 5.0 );\n    // postprocessing\n    // gamma\n    col = pow( col, vec3(0.45) );\n    // contrast/brightness\n    col = 1.3*col-0.1;\n    // tint\n    col *= vec3( 1.0, 1.04, 1.0);\n\n     return col;\n}\n\nvoid mainImageRight( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / gResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= gResolution.x/gResolution.y;\n    vec2 m = vec2(0.5);\n    if( gMouse.z>0.0 ) m = gMouse.xy/gResolution.xy;\n    // camera\n    float an = 2.5 + 0.12*iTime - 6.2*m.x;\n    float cr = 0.3*cos(0.2*iTime);\n    vec3 ro = vec3(15.0*sin(an),12.0-24.0*m.y,15.0*cos(an));\n    vec3 ta = vec3( 0.0, 2.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(cr),cos(cr),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.2*ww );\n    vec3 col = render( ro, rd, fragCoord );\n    // vigneting\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    fragColor = vec4( col, 1.0 );\n}\n\n///////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float splitterWidth = 3.0;\nconst float splitterRad   = splitterWidth / 2.0;\nconst float splitterExtra = 3.0;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 RGBA, in vec2 XY )\n{\n    ivec2 IJ = ivec2(XY);\n    if (IJ.y > 0) {\n        return;\n    }\n    \n    bool  isMousePressed      = iMouse.z >= 1.0;\n    bool  wasMouseJustPressed = iMouse.w >= 1.0;\n    \n    vec4 state = texelFetch(iChannel0, ivec2(0, 0), 0);\n    \n    float splitPos            = state.x;\n    bool  isGrabbed           = (state.y == 1.0) && isMousePressed;\n    bool  isDownInLeft        = (state.y == 2.0) && isMousePressed;\n    bool  isDownInRight       = (state.y == 3.0) && isMousePressed;\n    \n    if (iFrame < 5) {\n        splitPos = iResolution.x / 2.0;\n    }\n    \n    if (isGrabbed) {\n        if (isMousePressed) {\n            splitPos = iMouse.x;\n            splitPos = max(splitPos - splitterRad, 0.0);\n            splitPos = min(splitPos + splitterRad, iResolution.x);\n        }\n        else {\n            isGrabbed = false;\n        }\n    }\n    else {\n        if (wasMouseJustPressed) {\n            float d = iMouse.x - splitPos;\n            if (d < -splitterRad - splitterExtra) {\n                isDownInLeft = true;\n            }\n            else if (d > splitterRad + splitterExtra) {\n                isDownInRight = true;\n            }\n            else {\n                isGrabbed = true;\n                splitPos = iMouse.x;\n                splitPos = max(splitPos - splitterRad, 0.0);\n                splitPos = min(splitPos + splitterRad, iResolution.x);\n            }\n        }\n    }\n    \n    if (abs(splitPos - iResolution.x / 2.0) < 10.0) {\n        splitPos = iResolution.x / 2.0;\n    }\n    \n    if (length(iMouse.xy) < 20.0) {\n        float s  = sin(iTime * 0.7);\n        float th = 0.5;\n        splitPos = mix(iResolution.x * 0.2, iResolution.x * 0.8,\n                       smoothstep(th, -th, s));\n        isGrabbed = abs(s) < th;\n    }\n\n    if (IJ.x == 0) {\n        RGBA.x = splitPos;\n        RGBA.y = isGrabbed ? 1.0 : (isDownInLeft ? 2.0 : (isDownInRight ? 3.0 : 0.0));\n    }\n    else if (IJ.x == 1) {\n        if (isDownInLeft) {\n            RGBA = iMouse;\n        }\n        else {\n            RGBA = texelFetch(iChannel0, ivec2(1, 0), 0);\n        }\n    }\n    else if (IJ.x == 2) {\n        if (isDownInRight) {\n            RGBA = iMouse;\n            RGBA.x = iMouse.x - splitPos - splitterRad;\n        }\n        else {\n            RGBA = texelFetch(iChannel0, ivec2(2, 0), 0);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}