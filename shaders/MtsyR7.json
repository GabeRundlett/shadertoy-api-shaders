{
    "Shader": {
        "info": {
            "date": "1504169085",
            "description": "Added something looks like subtitle on the video.\nI hope it looks like japanese for people who don't know japanese.\n\nGenerating something looks like a charactor on fragment shader is hard.\nDoing so with vector graphics library would be easier.",
            "flags": 0,
            "hasliked": 0,
            "id": "MtsyR7",
            "likes": 2,
            "name": "Fake subtitle",
            "published": 3,
            "tags": [
                "2d",
                "simplexnoise",
                "generativefont"
            ],
            "usePreview": 0,
            "username": "tomohiro",
            "viewed": 786
        },
        "renderpass": [
            {
                "code": "const float PI = 3.1415926;\n/*\nCounter based pseudorandom number generator Philox\n\nIt is introduced in this paper:\nParallel Random Numbers: As Easy as 1, 2, 3\nby John K. Salmon, Mark A. Moraes, Ron O. Dror, and David E. Shaw\n\nPhilox is a modification of Threefish.\nIt is explained in 2.2 and 3.3 in this paper:\nThe Skein Hash Function Family\nby Niels Ferguson, Stefan Lucks, Bruce Schneier, Doug Whiting, Mihir Bellare, Tadayoshi Kohno, Jon Callas, Jesse Walker\n\nYou can download original Random123 source code from here:\nhttp://www.thesalmons.org/john/random123/\n\nHow to use:\nuvec4 counter;\nuvec2 key;\nuintToFloat(philox4x32_7(counter, key))\nreturns pseudorandom float4 value where each components are [0, 1).\n*/\n\n//umulExtended is not available in\n//umulExtended was added GLSL ES 3.1\n//This function is based on _mulhilo_c99_tpl macro in Random123-1.09/include/Random123/philox.h in Random123 source code.\nvoid umulExtended_(uint a, uint b, out uint hi, out uint lo) {\n    const uint WHALF = 16u;\n    const uint LOMASK = (1u<<WHALF)-1u;\n    lo = a*b;               /* full low multiply */\n    uint ahi = a>>WHALF;\n    uint alo = a& LOMASK;\n    uint bhi = b>>WHALF;\n    uint blo = b& LOMASK;\n\n    uint ahbl = ahi*blo;\n    uint albh = alo*bhi;\n\n    uint ahbl_albh = ((ahbl&LOMASK) + (albh&LOMASK));\n    hi = ahi*bhi + (ahbl>>WHALF) +  (albh>>WHALF);\n    hi += ahbl_albh >> WHALF; /* carry from the sum of lo(ahbl) + lo(albh) ) */\n    /* carry from the sum with alo*blo */\n    hi += ((lo >> WHALF) < (ahbl_albh&LOMASK)) ? 1u : 0u;\n}\n\nuvec2 philox4x32Bumpkey(uvec2 key) {\n    uvec2 ret = key;\n    ret.x += 0x9E3779B9u;\n    ret.y += 0xBB67AE85u;\n    return ret;\n}\n\nuvec4 philox4x32Round(uvec4 state, uvec2 key) {\n    const uint M0 = 0xD2511F53u, M1 = 0xCD9E8D57u;\n    uint hi0, lo0, hi1, lo1;\n//    umulExtended(M0, state.x, hi0, lo0);\n//    umulExtended(M1, state.z, hi1, lo1);\n    umulExtended_(M0, state.x, hi0, lo0);\n    umulExtended_(M1, state.z, hi1, lo1);\n\n    return uvec4(\n        hi1^state.y^key.x, lo1,\n        hi0^state.w^key.y, lo0);\n}\n\nuvec4 philox4x32_7(uvec4 plain, uvec2 key) {\n    uvec4 state = plain;\n    uvec2 round_key = key;\n\n    for(int i=0; i<7; ++i) {\n        state = philox4x32Round(state, round_key);\n        round_key = philox4x32Bumpkey(round_key);\n    }\n\n    return state;\n}\n\nfloat uintToFloat(uint src) {\n    return uintBitsToFloat(0x3f800000u | (src & 0x7fffffu))-1.0;\n}\n\nvec4 uintToFloat(uvec4 src) {\n    return vec4(uintToFloat(src.x), uintToFloat(src.y), uintToFloat(src.z), uintToFloat(src.w));\n}\n\nfloat skewF(float n)\n{\n/*\nn∈N\nX∈R^n\nX'∈R^n\nA∈R^n ∧ |A| = 1\ns∈R\nf is a non-uniform scaling along direction A and s is the scaling factor.\nf:R^n → R^n\nX' = f(X)\n   = X・A*s*A - X・A*A + X\n   = X・A*(s-1)*A + X\n\n∀B(B∈R^n ∧ B・A = 0 ⇒ f(X)・B = X・B)\n\nX' = f^-1(X)\n   = X・A*(1/s-1)*A + X\n\nf^-1(f(X)) = X\nX' = X・A*(s-1)*A + X\nX = X'・A*(1/s-1)*A + X'\n  = (X・A*(s-1)*A + X)・A*(1/s-1)*A + X・A*(s-1)*A + X\n  = X・A*(s-1)*(A・A)*(1/s-1)*A + X・A*(1/s-1)*A + X・A*(s-1)*A + X\n  = X・A*(1-s-1/s+1)*A          + X・A*(1/s-1)*A + X・A*(s-1)*A + X\n  = -X・A*(s-1)*A - X・A*(1/s-1)*A + X・A*(1/s-1)*A + X・A*(s-1)*A + X\n  = X\n\nWhen creating simplex noise, A is a unit vector parallel to a unit hypercube's longest diagonal.\nA = (1/√(n), 1/√(n), ...)\n  = 1/√(n)(1, 1, ...)\n\nX' = f(X) = (s-1)/n*X・(1, 1, ...)*(1, 1, ...) + X\n\nIn skewed coordinate system, basis is not orthogonal.\nAny points P in skewed coordinate system such that P∈Z^n become a vertex of a simplex.\nIn the Cartesian coordinate, all edge of a simplex should have a same length.\nBut it is not possible in 3D and higher dimension.\nEquilateral triangle alone can fill space, but regular tetrahedra alone do not.\nFind 's' such that |f^-1((1, 0, 0, ...))| = |f^-1((1, 1, 1, ...))|\n|(1/s-1)/n*(1, 0, 0, ...)・(1, 1, ...)*(1, 1, ...) + (1, 0, 0, ...)| = |(1/s-1)/n*(1, 1, ...)・(1, 1, ...)*(1, 1, ...) + (1, 1, 1)|\n|(1/s-1)/n*(1, 1, ...) + (1, 0, 0, ...)| = |(1/s-1)*(1, 1, ...) + (1, 1, 1)|\n((1/s-1)/n+1)^2 + (((1/s-1)/n)^2)*(n-1) = ((1/s)^2)*n\n(1/s-1)*(1/s-1)/(n*n)+ 2*(1/s-1)/n + 1 + (1/s-1)*(1/s-1)*(n-1)/(n*n) = n/(s*s)\n2*(1/s-1)/n + 1 + (1/s-1)*(1/s-1)*n/(n*n) = n/(s*s)\n2*(1/s-1)/n + 1 + (1/s-1)*(1/s-1)/n = n/(s*s)\n(1/s-1)/n*(2 + (1/s-1)) + 1 = n/(s*s)\n(1/s-1)/n*(1 + 1/s) + 1 = n/(s*s)\n(1-s)/n*(s + 1) + s*s = n\n(1-s)*(s + 1) + s*s*n = n*n\n(n-1)*s*s + 1 = n*n\ns*s = (n*n - 1)/(n-1) = (n+1)(n-1)/(n-1) = n+1\ns = sqrt(n+1)\n\nX' = f(X) = (√(n+1)-1)/n*X・(1, 1, ...)*(1, 1, ...) + X\nf^-1(X) = (1/√(n+1)-1)/n*X・(1, 1, ...)*(1, 1, ...) + X\n\nLength of edge of a simplex in Cartesian coordinate system:\n f^-1((1, 0, 0, ...))  = (1/√(n+1)-1)/n*(1, 0, 0, ...)・(1, 1, ...)*(1, 1, ...) + (1, 0, 0, ...)\n                       = (1/√(n+1)-1)/n*(1, 1, ...) + (1, 0, 0, ...)\n|f^-1((1, 0, 0, ...))| = √( ((1/√(n+1)-1)/n+1)^2 + (((1/√(n+1)-1)/n)^2)*(n-1) )\n                       = √( ((1/√(n+1)-1)/n)^2 + 2*(1/√(n+1)-1)/n + 1 + (((1/√(n+1)-1)/n)^2)*(n-1) )\n                       = √( (((1/√(n+1)-1)/n)^2)*n + 2*(1/√(n+1)-1)/n + 1 )\n                       = √( (1/√(n+1)-1)/n*(1/√(n+1)-1 + 2) + 1 )\n                       = √( (1/(n+1) - 1)/n + 1 )\n                       = √( -n/(n+1)/n + 1 )\n                       = √( -1/(n+1) + 1 )\n                       = √( n/(n+1) )\nhttps://www.wolframalpha.com/input/?i=sqrt(+((1%2Fsqrt(n%2B1)-1)%2Fn%2B1)^2+%2B+(((1%2Fsqrt(n%2B1)-1)%2Fn)^2)*(n-1)+)\n\nLength of edges of a simplex in Cartesian coordinate system in 3 or higher dimension are not equal.\nY∈{0,1}^n\nm = Y・(1, 1, ...)\nf^-1(Y) = m*(1/√(n+1)-1)/n*(1, 1, ...) + Y\n|f^-1(Y)| = √( ((m*(1/√(n+1)-1)/n+1)^2)*m + ((m*(1/√(n+1)-1)/n)^2)*(n-m) )\n          = √( ((m*(1/√(n+1)-1)/n)^2)*m + 2*m*m*(1/√(n+1)-1)/n + m + ((m*(1/√(n+1)-1)/n)^2)*(n-m) )\n          = √( ((m*(1/√(n+1)-1)/n)^2)*n + 2*m*m*(1/√(n+1)-1)/n + m )\n          = √( (m*(1/√(n+1)-1)/n)*( (m*(1/√(n+1)-1)) + 2*m ) + m )\n          = √( (m*(1/√(n+1)-1)/n)*m*( 1/√(n+1)+1 ) + m )\n          = √( m*m*(1/(n+1)-1)/n + m )\n          = √( m*m*(-n)/(n+1)/n + m )\n          = √( -m*m/(n+1) + m )\nd/dm(|f^-1(Y)|) = 0.5*(1 - 2*m/(n+1))/√( -m*m/(n+1) + m )\nd/dm(|f^-1(Y)|) = 0 when m = 0.5*(n+1)\nd/dm(|f^-1(Y)|) = 0.5*(1 - 2/(n+1))/√( n/(n+1) )\n                = 0.5*(n-1)/√( n*(n+1) ) > 0 when m = 1\nd/dm(|f^-1(Y)|) = 0.5*(1 - 2*n/(n+1))/√( n/(n+1) )\n                = 0.5*(1-n)/√( n*(n+1) ) < 0 when m = n\n\nSo length of edge is shortest when m = 1 or m = n and other edge is longer than them.\n\nShortest distance between a vertex on simplex and the opposite edge:\nL = √( n/(n+1) )*√(3)/2\n\nReferences:\nhttps://en.wikipedia.org/wiki/Simplex_noise\nhttp://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n*/\n    return (sqrt(n + 1.0) - 1.0)/n;\n}\n\nfloat unskewG(float n)\n{\n    return (1.0/sqrt(n + 1.0) - 1.0)/n;\n}\n\nvec3 randTheta(vec2 i0, vec2 i1, vec2 i2, uvec2 randKey)\n{\n    //According to 5.4.1 Conversion and Scalar Constructors in The OpenGL Shading Language Version 4.5, \n    //it is undefined to convert a negative floating-point value to an uint.\n    //The constructor uint(int) preserves the bit pattern in the argument, which will change its value if it is negative.\n    vec3 r = 2.0*PI*vec3(\n        uintToFloat(philox4x32_7(uvec4(ivec2(i0), 0, 0), randKey).x),\n        uintToFloat(philox4x32_7(uvec4(ivec2(i1), 0, 0), randKey).x),\n        uintToFloat(philox4x32_7(uvec4(ivec2(i2), 0, 0), randKey).x));\n    return r;\n}\n\nvec2 smplxNoise2DDeriv(vec2 x, float m, vec2 g)\n{\n    vec2 dmdxy = max(vec2(0.5) - dot(x, x), 0.0);\n    dmdxy = -8.0*x*dmdxy*dmdxy*dmdxy;\n    return dmdxy*dot(x, g) + m*g;\n}\n\nvec2 smplxNoise2DDeriv2(vec2 x, vec2 g)\n{\n/*\n    f(X) = (0.5 - dot(X, X))^4*dot(X, G)\n\n    ∂f(X)/∂x = -4*2*Xx*(0.5 - dot(X, X))^3 * dot(X, G) + (0.5 - dot(X, X))^4*Gx\n          = -8*Xx*(0.5 - dot(X, X))^3 * dot(X, G) + (0.5 - dot(X, X))^4*Gx\n\n    ∂/∂x・∂f(X)/∂x = (-8*(0.5 - dot(X, X))^3 - 8*Xx*3*(-2*Xx)*(0.5 - dot(X, X))^2) * dot(X, G) - 8*Xx*(0.5 - dot(X, X))^3*Gx + 4*(-2*Xx)*(0.5 - dot(X, X))^3*Gx\n                   = (0.5 - dot(X, X))^3*(-8*dot(X, G) - 8*Xx*Gx -8*Xx*Gx) + 48*Xx*Xx*dot(X, G)*(0.5 - dot(X, X))^2\n                   = (0.5 - dot(X, X))^3*(-8*dot(X, G) - 16*Xx*Gx) + 48*Xx*Xx*dot(X, G)*(0.5 - dot(X, X))^2\n*/\n\n    vec2 a = max(vec2(0.5) - dot(x, x), 0.0);\n    float dotxg = dot(x, g);\n    return a*a*a*(vec2(-8.0*dotxg) - 16.0*x*g) + 48.0*x*x*dotxg*a*a;\n}\n\nfloat smplxNoise2D(vec2 p, out vec2 deriv, out vec2 deriv2, uvec2 randKey)\n{\n    //i is a skewed coordinate of a bottom vertex of a simplex where p is in.\n    vec2 i0 = floor(p + vec2( (p.x + p.y)*skewF(2.0) ));\n    //x0, x1, x2 are unskewed displacement vectors.\n    float unskew = unskewG(2.0);\n    vec2 x0 = p - (i0 + vec2((i0.x + i0.y)*unskew));\n\n    vec2 ii1 = x0.x > x0.y ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec2 ii2 = vec2(1.0);\n\n//  vec2 i1 = i0 + ii1;\n//  vec2 x1 = p - (i1 + vec2((i1.x + i1.y)*unskew));\n//          = p - (i0 + ii1 + vec2((i0.x + i0.y + 1.0)*unskew));\n//          = p - (i0 + vec2((i0.x + i0.y)*unskew)) - ii1 - vec2(1.0)*unskew;\n    vec2 x1 = x0 - ii1 - vec2(unskew);\n//  vec2 i2 = i0 + ii2;\n//  vec2 x2 = p - (i2 + vec2((i2.x + i2.y)*unskew));\n//          = p - (i0 + ii2 + vec2((i0.x + i0.y + 2.0)*unskew));\n//          = p - (i0 + vec2((i0.x + i0.y)*unskew)) - ii2 - vec2(2.0)*unskew;\n    vec2 x2 = x0 - ii2 - vec2(2.0*unskew);\n\n    vec3 m = max(vec3(0.5) - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);\n    m = m*m;\n    m = m*m;\n\n    vec3 r = randTheta(i0, i0 + ii1, i0 + ii2, randKey);\n\n    //r = floor(r*2.0)/2.0;\n    //Gradients;\n    vec2 g0 = vec2(cos(r.x), sin(r.x));\n    vec2 g1 = vec2(cos(r.y), sin(r.y));\n    vec2 g2 = vec2(cos(r.z), sin(r.z));\n\n    deriv = smplxNoise2DDeriv(x0, m.x, g0) + smplxNoise2DDeriv(x1, m.y, g1) + smplxNoise2DDeriv(x2, m.z, g2);\n    deriv2 = smplxNoise2DDeriv2(x0, g0) + smplxNoise2DDeriv2(x1, g1) + smplxNoise2DDeriv2(x2, g2);\n    return dot(m*vec3(dot(x0, g0), dot(x1, g1), dot(x2, g2)), vec3(1.0));\n//    return dot(m*vec3(length(x0), length(x1), length(x2)), vec3(1.0));\n}\n\nconst vec2 charsize = vec2(1.0/4.0, 1.0/4.0);\nconst float charspace = 0.2;\n\nbool drawNoiseChar(vec2 uv, out vec4 debugColor)\n{\n    debugColor = vec4(0.0);\n    uint ti = uint(iTime*0.5);\n    float tf = fract(iTime*0.5);\n    uvec4 timeRand = philox4x32_7(uvec4(ti), uvec2(3u, 111u));\n    int len = int(timeRand.x % 4u + 2u);\n    vec2 textpos = vec2(0.0, -0.75);\n    vec2 localpos = (uv- textpos)/charsize;\n    ivec2 charposi = ivec2(floor(localpos));\n    vec2 charUV = fract(localpos)*(vec2(1.0)+charspace) - vec2(charspace*0.5);\n\n    float str = 0.0, strbg = 0.0;\n    if(charposi.y == 0 && abs(charposi.x) <= len && charUV.x > 0.0 && charUV.x < 1.0 && charUV.y > 0.0 && charUV.y < 1.0 && iTime > 3. && tf < 0.9)\n    {\n        uvec4 charRand = philox4x32_7(uvec4(uint(charposi.x), ti, 0u, 0u), uvec2(7u, 121u));\n\n        vec2 deriv, deriv2;\n\n        const float ew = 0.2;\n        vec2 edge = max(abs(charUV - vec2(0.5)) - (0.5-ew), 0.0)/ew;\n        float e = max(edge.x, edge.y);\n        for(int i=0; i<abs(int(charRand.x))%4+3; ++i)\n        {\n            vec4 randRect = uintToFloat(philox4x32_7(charRand, uvec2(i, 0xabcd)));\n            //x: min x, y: min y, z: size, w: area\n            const float minsize = 0.4;\n            const float minarea = 0.3*0.8;\n            vec2 minSA = vec2(minsize, minarea);\n            randRect.zw = randRect.zw*(1.0 - minSA) + minSA;\n            randRect.w = randRect.w / randRect.z;\n            randRect.xy = randRect.xy*(1.0 - minsize);\n            vec4 rect = vec4(randRect.xy, randRect.xy + randRect.zw);//vec4(min_x, min_y, max_x, max_y);\n            if(rect.z > 1.0)\n            {\n                float delta = rect.z - 1.0;\n                rect.x -= delta;\n                rect.z -= delta;\n            }\n            if(rect.w > 1.0)\n            {\n                float delta = rect.w - 1.0;\n                rect.y -= delta;\n                rect.w -= delta;\n            }\n            vec2 rectUV = (charUV - rect.xy)/(rect.zw - rect.xy);\n            if(charUV.x < rect.x || charUV.x > rect.z || charUV.y < rect.y || charUV.y > rect.w)\n                continue;\n            else\n                debugColor = vec4(rectUV, 0.0, 0.0);\n\n            vec2 randp = uintToFloat(philox4x32_7(charRand, uvec2(i, 0xabc))).xy;\n\n            float c = smplxNoise2D(charUV*0.5+randp, deriv, deriv2, uvec2(0xdeadbefu+charRand.y+uint(i), 0xfeedfadeu));\n            float cn = c*54.0 + 0.5;\n            float dd = dot(deriv, deriv);\n\n            float e = 1.0/(1.0+c*c*2200./dd);\n            str += step(0.7, e);\n        }\n        str = step(0.9, str);\n        return str > 0.9;\n    //    fragColor = vec4(charUV, 0.0, 1.0);\n    }else\n    {\n        return false;\n    }\n}\n\n//https://www.shadertoy.com/view/XsfGzn\nvec3 matteCompositing(vec3 bg, vec3 fg)\n{\n    float maxrb = max( fg.r, fg.b );\n    float k = clamp( (fg.g-maxrb)*5.0, 0.0, 1.0 );\n    \n    float dg = fg.g; \n    fg.g = min( fg.g, maxrb*0.8 ); \n    fg += dg - fg.g;\n\n    return mix(fg, bg, k);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy*2.0 - iResolution.xy) / iResolution.y;\n\n    vec4 debugColor;\n    if(drawNoiseChar(uv, debugColor))\n    {\n        fragColor = vec4(1.0);\n    }else\n    {\n        vec3 tex = texture(iChannel0, fragCoord.xy / iResolution.xy).xyz;\n        vec3 bg = vec3(0.0);\n        if(iTime > 18.1)\n        {\n            float theta = atan(uv.y, uv.x);\n            float r = length(uv);\n            float c = sin(theta*16. + iTime*16.) - (max(0.7, fract(iTime*1.7+0.2))-0.7)/0.3;\n            c = r < 0.3 ? 1.0 : max(c, 0.0);\n            bg = vec3(0.8+c, 0.8-c, 0.8-c);\n        }else\n        {\n            vec2 deriv, deriv2;\n            uint ti = uint(iTime);\n            float tr = fract(iTime);\n            float c0 = smplxNoise2D(uv*2.0, deriv, deriv2, uvec2(0xdeadbefu+ti, 0xfeedfadeu));\n            float c1 = smplxNoise2D(uv*2.0, deriv, deriv2, uvec2(0xdeadbefu+ti+1u, 0xfeedfadeu));\n            float c = mix(c0, c1, tr);\n            float cn = c*54.0 + 0.5;\n            bg = vec3(cn*0.3);\n        }\n        fragColor = vec4(matteCompositing(bg, tex), 1.0);\n    }\n\n//    fragColor = debugColor;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}