{
    "Shader": {
        "info": {
            "date": "1686301703",
            "description": "A 2D drawing library to draw shapes and text. I made this so that I can easily visualise things on Shadertoy without having to write the same boilerplate code over and over again :)",
            "flags": 0,
            "hasliked": 0,
            "id": "cdB3RD",
            "likes": 18,
            "name": "2D Drawing Library",
            "published": 3,
            "tags": [
                "2d",
                "antialiasing",
                "vector",
                "aa",
                "drawing",
                "alias",
                "library",
                "anti",
                "graphics"
            ],
            "usePreview": 0,
            "username": "fad",
            "viewed": 426
        },
        "renderpass": [
            {
                "code": "// Example use of drawing library (defined in Common tab)\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    // Create and bind a new context (i.e. initialize position)\n    vec2 p = fragCoord / iResolution.y;\n    vec2 topRight = iResolution.xy / iResolution.y;\n    Context ctx = newContext(p);\n    bindContext(ctx);\n    \n    // Draw the white background\n    drawPixel(vec4(1.0));\n    \n    // Draw the background grid\n    enableFill();\n    setFillColor(vec4(0.0, 0.0, 0.0, 0.03));\n    enableStroke();\n    setStrokeColor(vec4(0.7, 0.7, 0.7, 1.0));\n    setStrokeWidth(1.0 / getContext().scale);\n    // Dividing by getContext().scale converts the measurement to pixels\n    // in screenspace\n    drawGrid(vec2(-0.075), vec2(0.15, 0.2), vec2(0.02, 0.01));\n    \n    // Draw the blue blob as an implicit function\n    enableFill();\n    setFillColor(vec4(0.6, 0.7, 1.0, 1.0));\n    enableStroke();\n    setStrokeColor(vec4(0.2, 0.2, 0.5, 1.0));\n    setStrokeWidth(0.01);\n    drawImplicit(distance(p + sin(p * 25.0) * 0.03, topRight * 0.25) - 0.2);\n    \n    // Print the text\n    enableFill();\n    setFillColor(vec4(0.0, 0.0, 0.0, 1.0));\n    enableStroke();\n    strokeBehindFill();\n    setStrokeColor(vec4(1.0, 1.0, 1.0, 1.0));\n    setStrokeWidth(0.005);\n    setWritePosition(topRight * 0.2);\n    setCharSize(0.052);\n    // See all CH_char definitions in Common tab\n    printString((\n        CH_H,CH_e,CH_l,CH_l,CH_o,CH_CMA,CH_SPC, // Hello, \n        CH_w,CH_o,CH_r,CH_l,CH_d,CH_EXC,CH_SPC)); // world! \n    print(iFrame); // frame count\n    printString((\n        CH_SPC,CH_f,CH_r,CH_a,CH_m,CH_e,CH_s,CH_SPC, //  frames \n        CH_h,CH_a,CH_v,CH_e,CH_SPC, // have \n        CH_e,CH_l,CH_a,CH_p,CH_s,CH_e,CH_d,CH_SPC, // elapsed \n        CH_s,CH_o,CH_SPC, // so \n        CH_f,CH_a,CH_r,CH_DOT)); // far.     \n    strokeOverFill();\n    \n    // Mouse position for line\n    vec2 p1 = abs(iMouse.zw) / iResolution.y;\n    vec2 p2 = iMouse.xy / iResolution.y;\n    \n    // Draw dots at end of line\n    enableFill();\n    setFillColor(vec4(1.0, 0.0, 0.0, 1.0));\n    disableStroke();\n    drawCircle(p1, 0.01);\n    drawCircle(p2, 0.01);\n    \n    // Draw line\n    disableFill();\n    enableStroke();\n    setStrokeColor(vec4(0.0, 0.0, 0.0, 1.0));\n    setStrokeWidth(0.002);\n    drawLine(p1, p2, 0.01);\n    \n    // Draw green rectangle\n    enableFill();\n    setFillColor(vec4(0.0, 1.0, 0.0, 0.5));\n    disableStroke();\n    drawRect(topRight * 0.5, topRight * 0.5);\n    \n    // Output color\n    fragColor = premultiply(getColor());\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// 2D Drawing Library - by fad\n// https://www.shadertoy.com/view/cdB3RD\n// https://www.shadertoy.com/user/fad\n\n#define SDF_FONT_TEXTURE iChannel0\n\n// Treat the context as an opaque data type.\nstruct Context {\n    vec2 pixelCoord;\n    float scale;\n    bool drawingEnabled;\n    bool fillEnabled;\n    vec4 fillColor;\n    bool strokeEnabled;\n    bool strokeOverFill;\n    vec4 strokeColor;\n    float strokeWidth;\n    vec4 outColor;\n    vec2 writePosition;\n    float charSize;\n    float charWeight;\n    float lineSpacing;\n    float charSpacing;\n    int floatPrecision;\n    vec2 nextCharTopLeft;\n};\n\n// Create a new drawing context with the position of the pixel. The\n// mapping from fragCoord to pixelCoord is expected to be aspect-ratio\n// preserving, i.e. uniform scaling across both axes. The context\n// inherits its properties from the currently bound context. To use the\n// created canvas, bind it with bindContext().\nContext newContext(vec2 pixelCoord);\n\n// Bind a new context and return the previously bound context\nContext bindContext(Context ctx);\n\n// Get the currently bound context\nContext getContext();\n\n// Blit (copy) the canvas of a context onto the currently bound context,\n// optionally using another context canvas's alpha channel as a mask\nvoid blit(Context ctx);\nvoid blit(Context ctx, Context mask);\n\n// Draw the canvas of a context over the currently bound context,\n// optionally using another context canvas's alpha channel as a mask\nvoid drawCanvas(Context ctx);\nvoid drawCanvas(Context ctx, Context mask);\n\n// Get the rendered color so far (not premultiplied)\nvec4 getColor();\n\n// Enable or disable drawing\nvoid enableDrawing(bool drawingEnabled);\nvoid enableDrawing();\nvoid disableDrawing();\n\n// Enable or disable fill\nvoid enableFill(bool fillEnabled);\nvoid enableFill();\nvoid disableFill();\n\n// Set the fill color\nvoid setFillColor(vec4 fillColor);\n\n// Enable or disable stroke\nvoid enableStroke(bool strokeEnabled);\nvoid enableStroke();\nvoid disableStroke();\n\n// Set the stroke to render over or behind the fill\nvoid strokeOverFill(bool enable);\nvoid strokeOverFill();\nvoid strokeBehindFill();\n\n// Set the stroke color\nvoid setStrokeColor(vec4 strokeColor);\n\n// Set the stroke width\n// Note: a width of 0 does not work as expected\nvoid setStrokeWidth(float strokeWidth);\n\n// Draw a pixel for the current fragment\nvoid drawPixel(vec4 color);\n\n// Draw a shape\nvoid drawLine(vec2 start, vec2 end, float thickness);\nvoid drawRect(vec2 center, vec2 sideLength);\nvoid drawAABB(vec2 bottomLeft, vec2 topRight);\nvoid drawCircle(vec2 center, float radius);\nvoid drawGrid(vec2 spacing, vec2 thickness);\nvoid drawGrid(float spacing, float thickness);\n\n// Draw a shape defined by a signed distance value (sd < 0.0)\nvoid drawSD(float sd);\n\n// Draw a shape defined by an implicit function (f < 0.0)\nvoid drawImplicit(float f);\n\n// Draw a shape defined by the contour (zero-crossing) of an implicit\n// function (f == 0.0)\nvoid drawImplicitContour(float f, float width);\n\n// Text rendering functions\n// Set the top left position to write the text from\nvoid setWritePosition(vec2 writePosition);\n\n// Set the size of each character in pixels\nvoid setCharSize(float charSize);\n\n// Set the weight of each character (between 0 and 1)\nvoid setCharWeight(float charWeight);\n\n// Set the space between lines relative to character scale\nvoid setLineSpacing(float lineSpacing);\n\n// Set the space between successive characters relative to character\n// scale\nvoid setCharSpacing(float charSpacing);\n\n// Set the precision floating point numbers are printed at\nvoid setFloatPrecision(int floatPrecision);\n\n// Print Functions\nvoid printChar(int x);\n// These functions are also overloaded for vectors\nvoid print(bool x);\nvoid print(int x);\nvoid print(uint x);\nvoid print(float x);\n\n// The next two print functions are actually macros\n\n#define PREVENT_LOOP_UNROLLING 1\n\n// void printCharArray(int[] charArray);\n\n// void printString(string s);\n\n// Use printString with two pairs of brackets and comma separated chars,\n// e.g. printString((CH_H,CH_e,CH_l,CH_l,CH_o));\n\n// Calculate the color from blending the front color over the back color\nvec4 blendOver(vec4 front, vec4 back);\n\n// Premultiply a color\nvec4 premultiply(vec4 color);\n\n// Get the fraction of a pixel covered by an SDF (i.e. where sd < 0.0).\n// This function expects the SDF to be in screen-space where 1 unit of\n// distance corresponds to the width of a pixel.\nfloat sdfFill(float sd);\n\n// Get the fraction of a pixel covered by the outline of an SDF (i.e.\n// where abs(sd) < width / 2.0). This function expects the SDF to be in\n// screen-space where 1 unit of distance corresponds to the width of a\n// pixel.\nfloat sdfOutline(float sd, float width);\n\n// Get the fraction of a pixel covered by an implicit function (i.e.\n// where f < 0.0) by approximating the distance to the edge with\n// derivatives\nfloat implicitFill(float f);\n\n// Get the fraction of a pixel covered by the outline of an implicit\n// function (i.e. where (distance to f=0) < width / 2.0) by\n// approximating the distance to the edge with derivatives.\nfloat implicitOutline(float f, float width);\n\n// Return the fraction of the pixel where step(edge, x) == 1.0 by\n// approximating the distance to the edge with derivatives.\nfloat aastep(float edge, float x);\n\n// Character Definitions\nconst int CH_TAB = 9;   // \\t\nconst int CH_NL  = 10;  // \\n\nconst int CH_SPC = 32;  // space\nconst int CH_EXC = 33;  // !\nconst int CH_DQT = 34;  // \"\nconst int CH_HSH = 35;  // #\nconst int CH_DLR = 36;  // $\nconst int CH_PER = 37;  // %\nconst int CH_AMP = 38;  // &\nconst int CH_SQT = 39;  // '\nconst int CH_LP  = 40;  // (\nconst int CH_RP  = 41;  // )\nconst int CH_AST = 42;  // *\nconst int CH_PLS = 43;  // +\nconst int CH_CMA = 44;  // ,\nconst int CH_HYP = 45;  // -\nconst int CH_DOT = 46;  // .\nconst int CH_FSL = 47;  // /\nconst int CH_0   = 48;  // 0\nconst int CH_1   = 49;  // 1\nconst int CH_2   = 50;  // 2\nconst int CH_3   = 51;  // 3\nconst int CH_4   = 52;  // 4\nconst int CH_5   = 53;  // 5\nconst int CH_6   = 54;  // 6\nconst int CH_7   = 55;  // 7\nconst int CH_8   = 56;  // 8\nconst int CH_9   = 57;  // 9\nconst int CH_CLN = 58;  // :\nconst int CH_SCL = 59;  // ;\nconst int CH_LT  = 60;  // <\nconst int CH_EQ  = 61;  // =\nconst int CH_GT  = 62;  // >\nconst int CH_QST = 63;  // ?\nconst int CH_AT  = 64;  // @\nconst int CH_A   = 65;  // A\nconst int CH_B   = 66;  // B\nconst int CH_C   = 67;  // C\nconst int CH_D   = 68;  // D\nconst int CH_E   = 69;  // E\nconst int CH_F   = 70;  // F\nconst int CH_G   = 71;  // G\nconst int CH_H   = 72;  // H\nconst int CH_I   = 73;  // I\nconst int CH_J   = 74;  // J\nconst int CH_K   = 75;  // K\nconst int CH_L   = 76;  // L\nconst int CH_M   = 77;  // M\nconst int CH_N   = 78;  // N\nconst int CH_O   = 79;  // O\nconst int CH_P   = 80;  // P\nconst int CH_Q   = 81;  // Q\nconst int CH_R   = 82;  // R\nconst int CH_S   = 83;  // S\nconst int CH_T   = 84;  // T\nconst int CH_U   = 85;  // U\nconst int CH_V   = 86;  // V\nconst int CH_W   = 87;  // W\nconst int CH_X   = 88;  // X\nconst int CH_Y   = 89;  // Y\nconst int CH_Z   = 90;  // Z\nconst int CH_LB  = 91;  // [ \nconst int CH_BSL = 92;  // \\\nconst int CH_RB  = 93;  // ]\nconst int CH_CRT = 94;  // ^\nconst int CH_UND = 95;  // _\nconst int CH_GRV = 96;  // `\nconst int CH_a   = 97;  // a\nconst int CH_b   = 98;  // b\nconst int CH_c   = 99;  // c\nconst int CH_d   = 100; // d\nconst int CH_e   = 101; // e\nconst int CH_f   = 102; // f\nconst int CH_g   = 103; // g\nconst int CH_h   = 104; // h\nconst int CH_i   = 105; // i\nconst int CH_j   = 106; // j\nconst int CH_k   = 107; // k\nconst int CH_l   = 108; // l\nconst int CH_m   = 109; // m\nconst int CH_n   = 110; // n\nconst int CH_o   = 111; // o\nconst int CH_p   = 112; // p\nconst int CH_q   = 113; // q\nconst int CH_r   = 114; // r\nconst int CH_s   = 115; // s\nconst int CH_t   = 116; // t\nconst int CH_u   = 117; // u\nconst int CH_v   = 118; // v\nconst int CH_w   = 119; // w\nconst int CH_x   = 120; // x\nconst int CH_y   = 121; // y\nconst int CH_z   = 122; // z\nconst int CH_LC  = 123; // {\nconst int CH_VB  = 124; // |\nconst int CH_RC  = 125; // }\nconst int CH_TLD = 126; // ~\n\n// IMPLEMENTATION\n\nContext _ctx = Context(\n    vec2(0.0),\n    0.0,\n    false,\n    false,\n    vec4(0.0),\n    false,\n    false,\n    vec4(0.0),\n    0.0,\n    vec4(0.0),\n    vec2(0.0),\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0,\n    vec2(0.0)\n);\n\nContext newContext(vec2 pixelCoord) {\n    Context ctx;\n    float scale = 1.0 / length(vec2(dFdx(pixelCoord.x), dFdy(pixelCoord.x)));\n    \n    if (getContext().scale != 0.0) {\n        ctx = getContext();\n        ctx.outColor = vec4(0.0);\n        ctx.pixelCoord = pixelCoord;\n        ctx.scale = scale;\n    } else {\n        ctx.pixelCoord = pixelCoord;\n        ctx.scale = scale;\n        ctx.drawingEnabled = true;\n        ctx.fillEnabled = true;\n        ctx.fillColor = vec4(1.0, 0.0, 0.0, 1.0);\n        ctx.strokeEnabled = true;\n        ctx.strokeOverFill = true;\n        ctx.strokeColor = vec4(0.0, 0.0, 0.0, 1.0);\n        ctx.strokeWidth = 1.0;\n        ctx.outColor = vec4(0.0);\n        Context old = bindContext(ctx);\n        setWritePosition(vec2(100.0));\n        setCharSize(64.0);\n        setCharWeight(0.5);\n        setLineSpacing(0.0);\n        setCharSpacing(-0.55);\n        setFloatPrecision(5);\n        ctx = bindContext(old);\n    }\n    \n    return ctx;\n}\n\nContext bindContext(Context ctx) {\n    Context old = getContext();\n    _ctx = ctx;\n    return old;\n}\n\nContext getContext() {\n    return _ctx;\n}\n\nvoid blit(Context ctx) {\n    _ctx.outColor = ctx.outColor;\n}\n\nvoid blit(Context ctx, Context mask) {\n    _ctx.outColor = mix(_ctx.outColor, ctx.outColor, mask.outColor.a);\n}\n\nvoid drawCanvas(Context ctx) {\n    drawPixel(ctx.outColor);\n}\n\nvoid drawCanvas(Context ctx, Context mask) {\n    drawPixel(ctx.outColor * vec4(1.0, 1.0, 1.0, mask.outColor.a));\n}\n\nvoid enableDrawing(bool drawingEnabled) {\n    _ctx.drawingEnabled = drawingEnabled;\n}\n\nvoid enableDrawing() {\n    enableDrawing(true);\n}\n\nvoid disableDrawing() {\n    enableDrawing(false);\n}\n\nvoid enableFill(bool fillEnabled) {\n    _ctx.fillEnabled = fillEnabled;\n}\n\nvoid enableFill() {\n    enableFill(true);\n}\n\nvoid disableFill() {\n    enableFill(false);\n}\n\nvoid setFillColor(vec4 fillColor) {\n    _ctx.fillColor = clamp(fillColor, 0.0, 1.0);\n}\n\nvoid enableStroke(bool strokeEnabled) {\n    _ctx.strokeEnabled = strokeEnabled;\n}\n\nvoid enableStroke() {\n    enableStroke(true);\n}\n\nvoid disableStroke() {\n    enableStroke(false);\n}\n\nvoid strokeOverFill(bool enable) {\n    _ctx.strokeOverFill = enable;\n}\n\nvoid strokeOverFill() {\n    strokeOverFill(true);\n}\n\nvoid strokeBehindFill() {\n    strokeOverFill(false);\n}\n\nvoid setStrokeColor(vec4 strokeColor) {\n    _ctx.strokeColor = clamp(strokeColor, 0.0, 1.0);\n}\n\nvoid setStrokeWidth(float strokeWidth) {\n    _ctx.strokeWidth = max(strokeWidth, 0.0);\n}\n\nvoid drawPixel(vec4 color) {\n    if (_ctx.drawingEnabled) {\n        _ctx.outColor = blendOver(color, _ctx.outColor);\n    }\n}\n\nvoid _drawFillStroke(float fillOpacity, float strokeOpacity) {\n    if (_ctx.strokeEnabled && !_ctx.strokeOverFill) {\n        drawPixel(_ctx.strokeColor * vec4(1.0, 1.0, 1.0, strokeOpacity));\n    }\n\n    if (_ctx.fillEnabled) {\n        drawPixel(_ctx.fillColor * vec4(1.0, 1.0, 1.0, fillOpacity));\n    }\n    \n    if (_ctx.strokeEnabled && _ctx.strokeOverFill) {\n        drawPixel(_ctx.strokeColor * vec4(1.0, 1.0, 1.0, strokeOpacity));\n    }\n}\n\nvoid drawSD(float sd) {\n    sd *= _ctx.scale;\n    _drawFillStroke(sdfFill(sd), sdfOutline(sd, _ctx.scale * _ctx.strokeWidth));\n}\n\nvoid drawImplicit(float f) {\n    _drawFillStroke(implicitFill(f), implicitOutline(f, _ctx.scale * _ctx.strokeWidth));\n}\n\nvoid drawImplicitContour(float f, float width) {\n    float sd = abs(f) / length(vec2(dFdx(f), dFdy(f))) - _ctx.scale * width / 2.0;\n    _drawFillStroke(sdfFill(sd), sdfOutline(sd, _ctx.scale * _ctx.strokeWidth));\n}\n\nvoid drawLine(vec2 start, vec2 end, float thickness) {\n    vec2 ba = end - start;\n\tvec2 pa = _ctx.pixelCoord - start;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\tdrawSD(length(pa - h * ba) - thickness);\n}\n\nvoid drawRect(vec2 center, vec2 sideLength) {\n    vec2 a = abs(_ctx.pixelCoord - center) - sideLength / 2.0;\n    drawSD(length(max(a, vec2(0.0))) + min(max(a.x, a.y), 0.0));\n}\n\nvoid drawAABB(vec2 bottomLeft, vec2 topRight) {\n    drawRect((bottomLeft + topRight) / 2.0, abs(topRight - bottomLeft));\n}\n\nvoid drawCircle(vec2 center, float radius) {\n    drawSD(distance(_ctx.pixelCoord, center) - radius);\n}\n\nvoid drawGrid(vec2 origin, vec2 spacing, vec2 thickness) {\n    vec2 a = \n        abs(mod(_ctx.pixelCoord - origin + spacing / 2.0, spacing) - spacing / 2.0) -\n        thickness / 2.0;\n    drawSD(min(a.x, a.y));\n    \n}\n\nvoid drawGrid(float spacing, float thickness) {\n    drawGrid(vec2(0.0), vec2(spacing), vec2(thickness));\n}\n\nvoid setWritePosition(vec2 writePosition) {\n    _ctx.writePosition = writePosition;\n    _ctx.nextCharTopLeft = writePosition;\n}\n\nvoid setCharSize(float charSize) {\n    _ctx.charSize = charSize;\n}\n\nvoid setCharWeight(float charWeight) {\n    _ctx.charWeight = charWeight;\n}\n\nvoid setLineSpacing(float lineSpacing) {\n    _ctx.lineSpacing = lineSpacing;\n}\n\nvoid setCharSpacing(float charSpacing) {\n    _ctx.charSpacing = charSpacing;\n}\n\nvoid setFloatPrecision(int floatPrecision) {\n    _ctx.floatPrecision = floatPrecision;\n}\n\n#ifndef HW_PERFORMANCE\nuniform sampler2D SDF_FONT_TEXTURE;\n#endif\n\nvoid printChar(int char) {\n    if (char == 10) {\n        _ctx.nextCharTopLeft.x = _ctx.writePosition.x;\n        _ctx.nextCharTopLeft.y -= (1.0 + _ctx.lineSpacing) * _ctx.charSize;\n        return;\n    }\n    \n    vec2 bottomLeft = _ctx.nextCharTopLeft - vec2(0.0, _ctx.charSize);\n    vec2 uv = (_ctx.pixelCoord - bottomLeft) / _ctx.charSize;\n    \n    if (clamp(uv, 0.0, 1.0) == uv) {\n        drawSD((texture(SDF_FONT_TEXTURE, (uv + vec2(char % 16, 15 - char / 16)) / 16.0).a - mix(0.45, 0.55, _ctx.charWeight)) * _ctx.charSize);\n    }\n    \n    _ctx.nextCharTopLeft.x += (1.0 + _ctx.charSpacing) * _ctx.charSize;\n}\n\n#ifndef HW_PERFORMANCE\nuniform int iFrame;\n#endif\n\n#define printCharArray(charArray) for (int i = 0; i < (charArray).length() + min(PREVENT_LOOP_UNROLLING * iFrame, 0); ++i) printChar((charArray)[i])\n\n#define printString(string) printCharArray(int[]string)\n\nvoid print(bool x) {\n    if (x) {\n        printString((CH_t,CH_r,CH_u,CH_e));\n    } else {\n        printString((CH_f,CH_a,CH_l,CH_s,CH_e));\n    }\n}\n\nvoid print(int x) {\n    if (x < 0) {\n        printChar(CH_HYP);\n        x = -x;\n    }\n    \n    print(uint(x));\n}\n\nvoid print(uint x) {\n    int n = 1;\n    uint t = x % 10u;\n    \n    while (x > 9u) {\n        ++n;\n        x /= 10u;\n        t = 10u * t + x % 10u;\n    }\n    \n    while (n --> 0) { // lol\n        printChar(CH_0 + int(t % 10u));\n        t /= 10u;\n    }\n}\n\nvoid print(float x) {\n    if (isnan(x)) {\n        printString((CH_n,CH_a,CH_n));\n        return;\n    }\n    \n    if (floatBitsToUint(x) >> 31 == 1u) {\n        printChar(CH_HYP);\n        x = -x;\n    }\n    \n    if (isinf(x)) {\n        printString((CH_i,CH_n,CH_f));\n        return;\n    }\n    \n    if (x == 0.0) {\n        printChar(CH_0);\n        return;\n    }\n    \n    float e = floor(log2(x)/log2(10.0));\n    x /= pow(10.0, e);\n    \n    for (int n = 0; x > 0.0 && n < _ctx.floatPrecision; ++n) {\n        if (n == 1) {\n            printChar(CH_DOT);\n        }\n        \n        float digit = floor(x);\n        printChar(CH_0 + int(digit));\n        x = (x - digit) * 10.0;\n    }\n    \n    printChar(CH_e);\n    print(int(e));\n}\n\n#define OVERLOAD_PRINT(T, n, c)                              \\\n    void print(T x) {                                        \\\n        printString((c, CH_v, CH_e, CH_c, CH_0 + n, CH_LP)); \\\n                                                             \\\n        for (int i = 0; i < n; ++i) {                        \\\n            print(x[i]);                                     \\\n                                                             \\\n            if (i != n - 1) {                                \\\n                printString((CH_CMA, CH_SPC));               \\\n            }                                                \\\n        }                                                    \\\n                                                             \\\n        printChar(CH_RP);                                    \\\n    }\n\n#define OVERLOAD_PRINT_FLOAT(T, n)                           \\\n    void print(T x) {                                        \\\n        printString((CH_v, CH_e, CH_c, CH_0 + n, CH_LP));    \\\n                                                             \\\n        for (int i = 0; i < n; ++i) {                        \\\n            print(x[i]);                                     \\\n                                                             \\\n            if (i != n - 1) {                                \\\n                printString((CH_CMA, CH_SPC));               \\\n            }                                                \\\n        }                                                    \\\n                                                             \\\n        printChar(CH_RP);                                    \\\n    }\n\nOVERLOAD_PRINT(bvec2, 2, CH_b)\nOVERLOAD_PRINT(bvec3, 3, CH_b)\nOVERLOAD_PRINT(bvec4, 4, CH_b)\nOVERLOAD_PRINT(ivec2, 2, CH_i)\nOVERLOAD_PRINT(ivec3, 3, CH_i)\nOVERLOAD_PRINT(ivec4, 4, CH_i)\nOVERLOAD_PRINT(uvec2, 2, CH_u)\nOVERLOAD_PRINT(uvec3, 3, CH_u)\nOVERLOAD_PRINT(uvec4, 4, CH_u)\nOVERLOAD_PRINT_FLOAT(vec2, 2)\nOVERLOAD_PRINT_FLOAT(vec3, 3)\nOVERLOAD_PRINT_FLOAT(vec4, 4)\n\nvec4 blendOver(vec4 top, vec4 bottom) {\n    float a = top.a + bottom.a * (1.0 - top.a);\n    return a > 0.0\n        ? vec4((top.rgb * top.a + bottom.rgb * bottom.a * (1.0 - top.a)) / a , a)\n        : vec4(0.0);\n}\n\nvec4 premultiply(vec4 color) {\n    return vec4(color.rgb * color.a, color.a);\n}\n\nvec4 getColor() {\n    return _ctx.outColor;\n}\n\nfloat _areaSquareLine(vec2 n, float d) {\n    // From https://www.shadertoy.com/view/mtcXDH\n    // https://www.desmos.com/calculator/dorvdj5nbq for visualization\n    n = abs(n);\n    n = vec2(max(n.x, n.y), min(n.x, n.y));\n    float a = abs(d);\n    float b;\n\n    if (n.y != 0.0 && n.x - n.y <= 2.0 * a) {\n        vec2 c = 1.0 + (n - 2.0 * a) / n.yx;\n        b = 1.0 - max(c.x, 0.0) * c.y / 8.0;\n    } else {\n        b = min(0.5 + a / n.x, 1.0);\n    }\n    \n    return d < 0.0 ? 1.0 - b : b;\n}\n\nfloat _areaSquareLineAverage(float d) {\n    // From https://www.shadertoy.com/view/mtcXDH\n    // Approximate average value of areaSquareLine(n, d) w.r.t. n\n    float a = abs(d);\n    float b;\n    \n    if (a < 1.0 / sqrt(2.0)) {\n        b = 4.1434218 * pow(a, 12.647891) -\n            1.3070394 * pow(a, 3.9787831) +\n            1.0998631 * a +\n            0.5012205;\n        b = clamp(b, 0.0, 1.0);\n    } else {\n        b = 1.0;\n    }\n    \n    return d < 0.0 ? 1.0 - b : b;\n}\n\nfloat sdfFill(float sd) {\n    // From https://www.shadertoy.com/view/mtcXDH\n    // Return the fraction of the pixel covered by the SDF (i.e. where\n    // sd < 0.0)\n    vec2 n = vec2(dFdx(sd), dFdy(sd));\n    \n    if (n == vec2(0.0) || isnan(n.x) || isnan(n.y)) {\n        // Ambiguous case, so instead we just return the average. This\n        // is the problem with using dFdx/dFdy that would occur much\n        // less frequently if we had access to the analytic derivatives.\n        return _areaSquareLineAverage(-sd);\n    }\n\n    n = normalize(n);\n    return _areaSquareLine(n, -sd);\n}\n\nfloat sdfOutline(float sd, float width) {\n    // From https://www.shadertoy.com/view/mtcXDH\n    // Return the fraction of the pixel covered by the outline of the\n    // SDF (i.e. where abs(sd) < width / 2.0)\n    return sdfFill(sd - width / 2.0) - sdfFill(sd + width / 2.0);\n}\n\nfloat aastep(float edge, float x) {\n    // From https://www.shadertoy.com/view/mtcXDH\n    // Return the fraction of the pixel where step(edge, x) == 1.0 by\n    // approximating the distance to the edge with derivatives.\n    x -= edge;\n    vec2 n = vec2(dFdx(x), dFdy(x));\n    \n    if (n == vec2(0.0) || isnan(n.x) || isnan(n.y)) {\n        // Ambiguous case, so we resort to using regular step(edge, x).\n        // We can't use areaSquareLineAverage(x) because that function\n        // assumes that x measures distance across pixels but we have no\n        // information about distance here as the derivatives are zero.\n        return step(edge, x);\n    }\n    \n    float l = length(n);\n    return _areaSquareLine(n / l, x / l);\n}\n\nfloat implicitFill(float f) {\n    return aastep(f, 0.0);\n}\n\nfloat implicitOutline(float f, float width) {\n    return implicitFill(abs(f) / length(vec2(dFdx(f), dFdy(f))) - width / 2.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}