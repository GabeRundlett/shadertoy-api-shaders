{
    "Shader": {
        "info": {
            "date": "1453443592",
            "description": "Use the mouse to rotate the camera; reset the time if you get stuck in the maze ;).",
            "flags": 32,
            "hasliked": 0,
            "id": "MdyGRD",
            "likes": 28,
            "name": "Lost",
            "published": 3,
            "tags": [
                "game",
                "maze",
                "collisions"
            ],
            "usePreview": 0,
            "username": "Nrx",
            "viewed": 1186
        },
        "renderpass": [
            {
                "code": "// Rendering parameters\n#define FOV\t\t\t\t\t80.0\n#define RAY_STEP_MAX\t\t20.0\n#define RAY_LENGTH_MAX\t\t10.0\n#define EDGE_LENGTH\t\t\t0.1\n#define EDGE_FULL\n#define TEXTURE\n#define SHADOW\n#define BUMP_RESOLUTION\t\t100.0\n#define BUMP_INTENSITY\t\t0.1\n#define AMBIENT_NORMAL\t\t0.2\n#define AMBIENT_HIGHLIGHT\t2.5\n#define SPECULAR_POWER\t\t2.0\n#define SPECULAR_INTENSITY\t0.3\n#define FADE_POWER\t\t\t1.5\n#define GAMMA\t\t\t\t0.8\n\n// Math constants\n#define DELTA\t0.002\n#define PI\t\t3.14159265359\n\n// PRNG (unpredictable)\nfloat randUnpredictable (in vec3 seed) {\n\tseed = fract (seed * vec3 (5.6789, 5.4321, 6.7890));\n\tseed += dot (seed.yzx, seed.zxy + vec3 (21.0987, 12.3456, 15.1273));\n\treturn fract (seed.x * seed.y * seed.z * 5.1337);\n}\n\n// PRNG (predictable)\nfloat randPredictable (in vec3 seed) {\n\treturn fract (11.0 * sin (3.0 * seed.x + 5.0 * seed.y + 7.0 * seed.z));\n}\n\n// PRNG (2D only)\nfloat rand (in vec2 seed) {\n\tseed = fract (seed * vec2 (5.3983, 5.4427));\n\tseed += dot (seed.yx, seed.xy + vec2 (21.5351, 14.3137));\n\treturn fract (seed.x * seed.y * 95.4337);\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n}\n\n// Check whether there is a block at a given voxel edge\nfloat blockCheck (in vec3 p, in vec3 n) {\n\tvec3 blockPosition = floor (p + 0.5 + n * 0.5);\n\tvec3 blockEven = mod (blockPosition, 2.0);\n\tfloat blockSum = blockEven.x + blockEven.y + blockEven.z;\n\treturn max (step (blockSum, 1.5), step (blockSum, 2.5) * step (0.5, randPredictable (blockPosition))) *\n\t\tstep (4.5, mod (blockPosition.x, 32.0)) *\n\t\tstep (2.5, mod (blockPosition.y, 16.0)) *\n\t\tstep (4.5, mod (blockPosition.z, 32.0));\n}\n\n// Cast a ray\nvec3 hit (in vec3 rayOrigin, in vec3 rayDirection, in float rayLengthMax, out float rayLength, out vec3 hitNormal) {\n\n\t// Launch the ray\n\tvec3 hitPosition = rayOrigin;\n\tvec3 raySign = sign (rayDirection);\n\tvec3 rayInv = 1.0 / rayDirection;\n\tvec3 rayLengthNext = (0.5 * raySign - fract (rayOrigin + 0.5) + 0.5) * rayInv;\n\tfor (float rayStep = 0.0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\n\t\t// Reach the edge of the voxel\n\t\trayLength = min (rayLengthNext.x, min (rayLengthNext.y, rayLengthNext.z));\n\t\thitNormal = step (rayLengthNext.xyz, rayLengthNext.yzx) * step (rayLengthNext.xyz, rayLengthNext.zxy) * raySign;\n\t\thitPosition = rayOrigin + rayLength * rayDirection;\n\n\t\t// Check whether we hit a block\n\t\tif (blockCheck (hitPosition, hitNormal) > 0.5 || rayLength > rayLengthMax) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Next voxel\n\t\trayLengthNext += hitNormal * rayInv;\n\t}\n\n\t// Return the hit point\n\treturn hitPosition;\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Read the data\n\tvec3 headPosition;\n\tmat3 headOrientation;\n\tvec3 lightPosition;\n\n\tif (iFrame < 5) {\n\t\theadPosition = vec3 (13.05, 1.5, 13.0);\n\t\tlightPosition = vec3 (13.0, 1.0, 13.0);\n\t\theadOrientation [0] = vec3 (0.0, 0.0, -1.0);\n\t\theadOrientation [1] = vec3 (1.0, 0.0, 0.0);\n\t} else {\n\t\tvec4 data = texture (iChannel0, vec2 (0.5, 0.5) / iResolution.xy);\n\t\theadPosition = data.xyz;\n\t\theadOrientation [1].x = data.w;\n\t\tdata = texture (iChannel0, vec2 (2.5, 0.5) / iResolution.xy);\n\t\tlightPosition = data.xyz;\n\t\theadOrientation [1].y = data.w;\n\t\tdata = texture (iChannel0, vec2 (4.5, 0.5) / iResolution.xy);\n\t\theadOrientation [0] = data.xyz;\n\t\theadOrientation [1].z = data.w;\n\t}\n\theadOrientation [2] = cross (headOrientation [0], headOrientation [1]);\n\n\t// Animate the ambient lighting\n\tfloat ambientIntensity = max (step (1.0, mod (iTime, 10.0)), step (0.25, randUnpredictable (vec3 (iTime))));\n\n\t// Define the ray corresponding to this fragment\n\tvec3 rayOrigin = headPosition;\n\tvec3 rayDirection = headOrientation * normalize (vec3 (2.0 * fragCoord - iResolution.xy, 0.5 * iResolution.x / tan (FOV * PI / 360.0)));\n\n\t// Cast a ray\n\tfloat hitDistance;\n\tvec3 hitNormal;\n\tvec3 hitPosition = hit (rayOrigin, rayDirection, RAY_LENGTH_MAX, hitDistance, hitNormal);\n\tvec3 hitUV = hitPosition * abs (hitNormal.yzx + hitNormal.zxy);\n\n\t// Basic edge detection\n\tvec3 edgeDistance = fract (hitUV + 0.5) - 0.5;\n\tvec3 edgeDirection = sign (edgeDistance);\n\tedgeDistance = abs (edgeDistance);\n\n\t#ifdef EDGE_FULL\n\tvec3 hitNormalAbs = abs (hitNormal);\n\tvec2 edgeSmooth = vec2 (dot (edgeDistance, hitNormalAbs.yzx), dot (edgeDistance, hitNormalAbs.zxy));\n\tfloat highlightIntensity = (1.0 - blockCheck (hitPosition + edgeDirection * hitNormalAbs.yzx, hitNormal)) * smoothstep (0.5 - EDGE_LENGTH, 0.5 - EDGE_LENGTH * 0.5, edgeSmooth.x);\n\thighlightIntensity = max (highlightIntensity, (1.0 - blockCheck (hitPosition + edgeDirection * hitNormalAbs.zxy, hitNormal)) * smoothstep (0.5 - EDGE_LENGTH, 0.5 - EDGE_LENGTH * 0.5, edgeSmooth.y));\n\thighlightIntensity = max (highlightIntensity, (1.0 - blockCheck (hitPosition + edgeDirection, hitNormal)) * smoothstep (0.5 - EDGE_LENGTH, 0.5 - EDGE_LENGTH * 0.5, min (edgeSmooth.x, edgeSmooth.y)));\n\t#else\n\tfloat highlightIntensity = 1.0 - blockCheck (hitPosition + step (edgeDistance.yzx, edgeDistance.xyz) * step (edgeDistance.zxy, edgeDistance.xyz) * edgeDirection, hitNormal);\n\thighlightIntensity *= smoothstep (0.5 - EDGE_LENGTH, 0.5 - EDGE_LENGTH * 0.5, max (edgeDistance.x, max (edgeDistance.y, edgeDistance.z)));\n\t#endif\n\n\t// Texture\n\t#ifdef TEXTURE\n\tvec2 textureUV = fract (vec2 (dot (hitUV, hitNormal.yzx), dot (hitUV, hitNormal.zxy)) + 0.5);\n\ttextureUV.x = (textureUV.x + mod (floor (iTime * 20.0), 6.0)) * 40.0 / 256.0;\n\tfloat textureIntensity = 1.0 - texture (iChannel1, textureUV).r;\n\tfloat texturePhase = 2.0 * PI * randUnpredictable (floor (hitPosition + 0.5 + hitNormal * 1.5));\n\ttextureIntensity *= smoothstep (0.8, 1.0, cos (iTime * 0.2 + texturePhase));\n\thighlightIntensity = max (highlightIntensity, textureIntensity);\n\t#endif\n\n\t// Set the object color\n\tvec3 color = cos ((hitPosition + hitNormal * 0.5) * 0.05);\n\tcolor = hsv2rgb (vec3 (color.x + color.y + color.z + highlightIntensity * 0.05, 1.0, 1.0));\n\n\t// Lighting\n\tvec3 lightDirection = hitPosition - lightPosition;\n\tfloat lightDistance = length (lightDirection);\n\tlightDirection /= lightDistance;\n\n\tfloat lightIntensity = min (1.0, 1.0 / lightDistance);\n\t#ifdef SHADOW\n\tfloat lightHitDistance;\n\tvec3 lightHitNormal;\n\thit (hitPosition - hitNormal * DELTA, -lightDirection, lightDistance, lightHitDistance, lightHitNormal);\n\tlightIntensity *= step (lightDistance, lightHitDistance);\n\t#endif\n\n\t// Bump mapping\n\tvec2 bumpUV = BUMP_RESOLUTION * vec2 (dot (hitUV, hitNormal.yzx), dot (hitUV, hitNormal.zxy));\n\tvec4 bumpID = floor (vec4 (bumpUV, bumpUV + 1.0));\n\tbumpUV = fract (bumpUV);\n\tfloat bump = mix (\n\t\tmix (rand (bumpID.xy), rand (bumpID.zy), bumpUV.x),\n\t\tmix (rand (bumpID.xw), rand (bumpID.zw), bumpUV.x),\n\t\tbumpUV.y);\n\thitNormal = normalize (hitNormal + hitNormal.yzx * (1.0 - highlightIntensity) * BUMP_INTENSITY * (bump - 0.5));\n\n\t// Shading\n\tfloat ambient = mix (AMBIENT_NORMAL, AMBIENT_HIGHLIGHT, highlightIntensity) * ambientIntensity;\n\tfloat diffuse = max (0.0, dot (hitNormal, lightDirection));\n\tfloat specular = pow (max (0.0, dot (reflect (rayDirection, hitNormal), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\tcolor = (ambient + diffuse * lightIntensity) * color + specular * lightIntensity;\n\tcolor *= pow (max (0.0, 1.0 - hitDistance / RAY_LENGTH_MAX), FADE_POWER);\n\n\t// Light source\n\tlightDirection = lightPosition - rayOrigin;\n\tif (dot (rayDirection, lightDirection) > 0.0) {\n\t\tlightDistance = length (lightDirection);\n\t\tif (lightDistance < hitDistance) {\n\t\t\tvec3 lightNormal = cross (rayDirection, lightDirection);\n\t\t\tcolor += smoothstep (0.001, 0.0, dot (lightNormal, lightNormal));\n\t\t}\n\t}\n\n\t// Adjust the gamma\n\tcolor = pow (color, vec3 (GAMMA));\n\n\t// Set the fragment color\n\tfragColor = vec4 (color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Physics parameters\n#define GRAVITY vec3 (0.0, -3.0, 0.0) // Feel free to comment this out to explore the maze freely :)\n\n// Math constants\n#define DELTA\t0.002\n#define PI \t\t3.14159265359\n\n// Element\nstruct Element {\n\tvec3 position;\n\tvec3 speed;\n\tvec3 force;\n\tfloat friction;\n\tfloat radius;\n\tfloat elasticity;\n};\n\n// Head\nstruct Head {\n\tElement element;\n\tmat3 orientation;\n\tfloat forceOrientation;\n};\n\n// Light ball\nstruct LightBall {\n\tElement element;\n\tfloat aheadDistance;\n\tfloat movementAmplitude;\n\tfloat forceSpringStiffness;\n\tfloat forceMaxSqr;\n\tfloat collisionTimer;\n\tfloat collisionTimerMax;\n};\n\n// PRNG (predictable)\nfloat randPredictable (in vec3 seed) {\n\treturn fract (11.0 * sin (3.0 * seed.x + 5.0 * seed.y + 7.0 * seed.z));\n}\n\n// Check whether there is a block at a given position\nfloat blockCheck (in vec3 blockPosition) {\n\tvec3 blockEven = mod (blockPosition, 2.0);\n\tfloat blockSum = blockEven.x + blockEven.y + blockEven.z;\n\treturn max (step (blockSum, 1.5), step (blockSum, 2.5) * step (0.5, randPredictable (blockPosition))) *\n\t\tstep (4.5, mod (blockPosition.x, 32.0)) *\n\t\tstep (2.5, mod (blockPosition.y, 16.0)) *\n\t\tstep (4.5, mod (blockPosition.z, 32.0));\n}\n\n// React to collisions\nvoid collisionReact (inout Element element, in vec3 relativePosition) {\n\n\t// Compute the position relative to the actual hit point\n\trelativePosition -= 0.5 * sign (relativePosition);\n\n\t// Make sure there is a hit\n\tfloat distance = length (relativePosition);\n\tif (distance < element.radius) {\n\n\t\t// Compute the normalized direction of the hit\n\t\trelativePosition /= distance;\n\n\t\t// Upate the position\n\t\tdistance -= element.radius;\n\t\telement.position -= relativePosition * distance;\n\n\t\t// Update the speed\n\t\telement.speed -= (1.0 + element.elasticity) * dot (element.speed, relativePosition) * relativePosition;\n\t}\n}\n\n// Detect collisions (here, \"element\" is a sphere, and the environment is made of cubes)\nvoid collisionDetect (inout Element element) {\n\n\t// Get the position of the current block\n\tvec3 blockPosition = floor (element.position + 0.5);\n\n\t// There is no collision if we are inside a block already\n\tif (blockCheck (blockPosition) > 0.5) {\n\t\treturn;\n\t}\n\n\t// Compute the relative position within the block\n\tvec4 relativePosition = vec4 (element.position - blockPosition, 0.0);\n\n\t// Check whether we are close to a side of the current block\n\tvec3 check = step (0.5 - element.radius, abs (relativePosition.xyz));\n\tif (check.x + check.y + check.z < 0.5) {\n\t\treturn;\n\t}\n\n\t// Prepare to check nearby blocks\n\tvec4 blockDelta = sign (relativePosition);\n\n\t// Handle collisions with the sides\n\tif (check.x > 0.5 && blockCheck (blockPosition + blockDelta.xww) > 0.5) {\n\t\tcheck.x = 0.0;\n\t\tcollisionReact (element, relativePosition.xww);\n\t}\n\tif (check.y > 0.5 && blockCheck (blockPosition + blockDelta.wyw) > 0.5) {\n\t\tcheck.y = 0.0;\n\t\tcollisionReact (element, relativePosition.wyw);\n\t}\n\tif (check.z > 0.5 && blockCheck (blockPosition + blockDelta.wwz) > 0.5) {\n\t\tcheck.z = 0.0;\n\t\tcollisionReact (element, relativePosition.wwz);\n\t}\n\n\t// Take note of whether we have to check the collision with the corner\n\tfloat checkXYZ = check.x * check.y * check.z;\n\n\t// Handle collisions with the edges\n\tif (check.x * check.y > 0.5 && blockCheck (blockPosition + blockDelta.xyw) > 0.5) {\n\t\tcheckXYZ = 0.0;\n\t\tcollisionReact (element, relativePosition.xyw);\n\t}\n\tif (check.y * check.z > 0.5 && blockCheck (blockPosition + blockDelta.wyz) > 0.5) {\n\t\tcheckXYZ = 0.0;\n\t\tcollisionReact (element, relativePosition.wyz);\n\t}\n\tif (check.z * check.x > 0.5 && blockCheck (blockPosition + blockDelta.xwz) > 0.5) {\n\t\tcheckXYZ = 0.0;\n\t\tcollisionReact (element, relativePosition.xwz);\n\t}\n\n\t// Handle the collision with the corner\n\tif (checkXYZ > 0.5 && blockCheck (blockPosition + blockDelta.xyz) > 0.5) {\n\t\tcollisionReact (element, relativePosition.xyz);\n\t}\n}\n\n// Handle movements\nvoid move (inout Element element, in bool collide) {\n\n\t// Handle the friction\n\telement.force -= element.speed * element.friction;\n\n\t// Update the speed\n\telement.speed += element.force * iTimeDelta;\n\n\t// Compute the movement\n\tfloat speed = length (element.speed);\n\tfloat movementLength = speed * iTimeDelta;\n\tvec3 movementDirection = element.speed / speed;\n\n\t// Move towards the destination by small increments, to make sure we detect all collisions\n\t// Note: we could optimize this by going faster when within the inner part of a block, far from the sides\n\t// ...but this isn't really needed, so let's keep it simple\n\tif (collide && element.radius > 0.0) {\n\t\tfor (int iteration = 0; iteration < 8; ++iteration) {\n\t\t\tif (movementLength > element.radius) {\n\t\t\t\telement.position += element.radius * movementDirection;\n\t\t\t\tmovementLength -= element.radius;\n\t\t\t\tcollisionDetect (element);\n\t\t\t}\n\t\t}\n\t}\n\telement.position += movementLength * movementDirection;\n\tif (collide) {\n\t\tcollisionDetect (element);\n\t}\n}\n\n// Get the orientation of the head\nmat3 headOrientationGet () {\n\n\tfloat yawAngle = 3.0 * PI * (iMouse.x / iResolution.x - 0.5);\n\tfloat pitchAngle = PI * (0.5 - iMouse.y / iResolution.y);\n\n\tfloat cosYaw = cos (yawAngle);\n\tfloat sinYaw = sin (yawAngle);\n\tfloat cosPitch = cos (pitchAngle);\n\tfloat sinPitch = sin (pitchAngle);\n\n\tmat3 headOrientation;\n\theadOrientation [0] = vec3 (cosYaw, 0.0, -sinYaw);\n\theadOrientation [1] = vec3 (sinYaw * sinPitch, cosPitch, cosYaw * sinPitch);\n\theadOrientation [2] = vec3 (sinYaw * cosPitch, -sinPitch, cosYaw * cosPitch);\n\treturn headOrientation;\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Don't waste time...\n\tif (fragCoord.x > 5.0 || fragCoord.y > 1.0) {\n\t\tdiscard;\n\t}\n\n\t// Define the head\n\tHead head;\n\thead.element.friction = 1.0;\n\thead.element.radius = 0.1;\n\thead.element.elasticity = 0.5;\n\thead.forceOrientation = 2.0;\n\n\t// Define the light ball\n\tLightBall lightBall;\n\tlightBall.element.friction = 1.0;\n\tlightBall.element.radius = 0.03;\n\tlightBall.element.elasticity = 0.5;\n\tlightBall.aheadDistance = 0.5;\n\tlightBall.movementAmplitude = 0.1;\n\tlightBall.forceSpringStiffness = 15.0;\n\tlightBall.forceMaxSqr = 900.0;\n\tlightBall.collisionTimerMax = 5.0;\n\n\t// Initialize the position and speed of both the head and the light ball\n\tif (iFrame < 5) {\n\t\thead.element.position = vec3 (13.05, 1.5, 13.0);\n\t\thead.element.speed = vec3 (0.0);\n\t\tlightBall.element.position = vec3 (13.0, 1.0, 13.0);\n\t\tlightBall.element.speed = vec3 (0.0);\n\t\tlightBall.collisionTimer = 0.0;\n\t} else {\n\t\thead.element.position = texture (iChannel0, vec2 (0.5, 0.5) / iResolution.xy).xyz;\n\t\thead.element.speed = texture (iChannel0, vec2 (1.5, 0.5) / iResolution.xy).xyz;\n\t\tlightBall.element.position = texture (iChannel0, vec2 (2.5, 0.5) / iResolution.xy).xyz;\n\t\tvec4 data = texture (iChannel0, vec2 (3.5, 0.5) / iResolution.xy);\n\t\tlightBall.element.speed = data.xyz;\n\t\tlightBall.collisionTimer = data.w;\n\t}\n\n\t// Move the head\n\thead.orientation = headOrientationGet ();\n\thead.element.force = head.orientation [2] * head.forceOrientation;\n\t#ifdef GRAVITY\n\tfloat gravitySqr = dot (GRAVITY, GRAVITY);\n\tif (gravitySqr > DELTA) {\n\t\thead.element.force += (1.0 - dot (head.element.force, GRAVITY) / gravitySqr) * GRAVITY;\n\t}\n\t#endif\n\tmove (head.element, true);\n\n\t// Move the light ball (using a spring force)\n\tvec3 lightBallPositionTarget = lightBall.movementAmplitude * vec3 (sin (iTime * 2.0), sin (iTime * 3.0), sin (iTime));\n\tlightBallPositionTarget.z += lightBall.aheadDistance;\n\tlightBallPositionTarget = head.element.position + head.orientation * lightBallPositionTarget;\n\tlightBall.element.force = (lightBallPositionTarget - lightBall.element.position) * lightBall.forceSpringStiffness;\n\tif (dot (lightBall.element.force, lightBall.element.force) < lightBall.forceMaxSqr) {\n\t\tlightBall.collisionTimer = 0.0;\n\t} else {\n\t\tlightBall.collisionTimer += iTimeDelta;\n\t}\n\tmove (lightBall.element, lightBall.collisionTimer < lightBall.collisionTimerMax);\n\n\t// Store the data\n\tif (fragCoord.x < 1.0) {\n\t\tfragColor = vec4 (head.element.position, head.orientation [1].x);\n\t} else if (fragCoord.x < 2.0) {\n\t\tfragColor = vec4 (head.element.speed, 0.0);\n\t} else if (fragCoord.x < 3.0) {\n\t\tfragColor = vec4 (lightBall.element.position, head.orientation [1].y);\n\t} else if (fragCoord.x < 4.0) {\n\t\tfragColor = vec4 (lightBall.element.speed, lightBall.collisionTimer);\n\t} else {\n\t\tfragColor = vec4 (head.orientation [0], head.orientation [1].z);\n\t}\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}