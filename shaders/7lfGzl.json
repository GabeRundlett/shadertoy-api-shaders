{
    "Shader": {
        "info": {
            "date": "1622605486",
            "description": "earth",
            "flags": 32,
            "hasliked": 0,
            "id": "7lfGzl",
            "likes": 16,
            "name": "ðŸŒŽ",
            "published": 3,
            "tags": [
                "earth"
            ],
            "usePreview": 0,
            "username": "ssartell",
            "viewed": 599
        },
        "renderpass": [
            {
                "code": "/*\n    Mostly just playing around with textures and displacement. Super fake atmosphere effect, but it works well enough\n*/\n\nfloat farClip = 30.0;\nfloat pi = 3.14159;\n\nfloat sphere(vec3 p, vec3 c, float r) {\n  return length(p - c) - r;\n}\n\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nvec3 triplaner(vec3 n, sampler2D tex, float s) {\n  n = normalize(n);\n  vec3 xz = texture(tex, (n.xz * .5 + .5) * s).rgb;\n  vec3 xy = texture(tex, (n.xy * .5 + .5) * s).rgb;\n  vec3 zy = texture(tex, (n.yz * .5 + .5) * s).rgb;\n\n  vec3 tn = abs(n);\n  tn *= pow(abs(n), vec3(20.));\n  tn /= tn.x + tn.y + tn.z;\n  return tn.y * xz + tn.z * xy + tn.x * zy;\n}\n\nvec4 map(vec3 p) {\n  float d1 = sphere(p, vec3(0.), .25);\n\n  float roc = triplaner(p, iChannel1, .6).r * 2. - 1.;\n  float d3 = roc;\n\n  float gra = triplaner(p, iChannel0, 1.).g * 2. - 1.;\n  float gt = .3;\n  float d2 = max(roc, gt) + gra * .2;\n\n  float wat = gt;\n  float wt = .1;\n\n  float t1 = smoothstep(gt, gt , roc);\n  float t2 = smoothstep(wt, wt, roc);\n  float t = mix(wat, mix(d2, d3, t1), t2);\n  float dis = t * .05;\n  float d = .7 * (d1 - dis);\n\n  return vec4(d, t1 + t2, roc, d1);\n}\n\nvec3 calcNormal(vec3 p) {\n  float d = map(p).x;\n  vec2 e = vec2(.001, 0);\n\n  vec3 n = d - vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x);\n\n  return normalize(n);\n}\n\nvec4 marchRay(vec3 ro, vec3 rd) {\n  float t = 0.;\n  vec4 res;\n  for(int i = 0; i < 100; i++) {\n    vec3 p = ro + t * rd;\n    res = map(p);\n    float h = res.x;\n    if (h < 0.0001) return vec4(t, res.yz, i);\n    t += h;\n    if (t > farClip) return vec4(0.0, res.yz, i);\n  }\n  return vec4(t, res.yz, 100.);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float k) {\n  float res = 1.0;\n    float ph = 1e20;\n    for( float t = 0.; t<100.;)\n    {\n      float h = map(ro + rd*t).x;\n      if( h<0.001 )\n        return 0.0;\n      float y = h*h/(2.0*ph);\n      float d = sqrt(h*h-y*y);\n      res = min( res, k*d/max(0.0,t-y) );\n      ph = h;\n      t += h;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.x;\n\n  float tx = iTime / 2.0 + 3.;\n  float ty = 0.2;\n  if (iMouse.z > 0.0) {\n    tx = iMouse.x / iResolution.x * 3.1416 * 3.0 + 3.14;\n    ty = iMouse.y / iResolution.y - .1;\n  }\n\n  vec3 ro = vec3(cos(tx * .7), ty, sin(tx * .7));\n  vec3 ta = vec3(0.0, 0.0, 0.0);\n\n  // camera axes\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n  vec3 vv = normalize(cross(uu, ww));\n\n  vec3 rd = normalize(uv.x*uu + uv.y*vv + .9*ww);\n\n    vec4 res = marchRay(ro, rd);\n    float t = res.x;\n    float mat = res.y;\n    float h = res.z;\n    float i = res.w;\n\n    vec3 l = normalize(vec3(1., .17, 1.));\n    float vdotl = max(dot(rd, l), 0.0);\n\n    vec3 fog = vec3(.01, .01, .02);\n    vec3 sun = vec3(1.6, 1.2, 1.);\n    float sunAmount = pow(vdotl, 256.);\n    fog = mix(fog, sun, sunAmount);\n    fog += pow(triplaner(rd, iChannel2, 2.), vec3(1.));\n    fog += pow(triplaner(rd, iChannel1, 1.), vec3(10.))\n    * vec3(.7, .5, .9);\n    vec3 col = fog;\n\n    if (t > 0.0) {\n        col = vec3(0.0);\n        vec3 p = ro + t * rd;\n\n        vec3 n = calcNormal(p);\n        vec3 np = normalize(p);\n        vec3 cNoise = triplaner(p, iChannel0, 2.) * 2. - 1.;\n        n = mix(mix(np, cNoise, .02), mix(n, cNoise, .3), step(1.5, mat));\n        n = mix(mix(n, cNoise, .02), n, step(.5, mat));\n        n = normalize(n);\n\n        vec3 r = reflect(-l, n);\n\n        float ndotl = clamp(dot(n, l), 0., 1.);\n        float rdotv = clamp(dot(-rd, r), 0., 1.);\n        float npdotl = clamp(dot(np, l), 0., 1.);\n\n        vec3 albedo;\n        vec3 water1 = vec3(.05, .1, .4);\n        vec3 water2 = vec3(.05, .25, .55);\n        vec3 water = mix(water1, water2, smoothstep(-.4, .2, h));\n\n        vec3 rock = mix(vec3(.3, .28, .25),\n          vec3(2.0), smoothstep(.5, .6, h));\n        albedo = mix(water, triplaner(n, iChannel0, 1.) * vec3(.5, 1., .6), clamp(mat, 0., 1.));\n        albedo = mix(albedo, rock, clamp(mat - 1., 0., 1.));\n\n        float sha = softShadow(p + .02 * n, l, 64.);\n        float diff = max(ndotl, .3 * npdotl);\n        float sp = pow(rdotv, 30.) * smoothstep(.9, 0., mat);\n        float sky = clamp(.5 + .5 * n.y, 0., 1.);\n        float ind = clamp(dot(n, normalize(l * vec3(-1., 0., -1.))), 0., 1.);\n\n        vec3 lin = (diff * sha) * .7 * sun + .02;\n        col = albedo * lin + sp * sun * .8;\n    }\n\n    // atmosphere\n    vec3 p = .9 * rd * length(ro) / dot(normalize(-ro), rd);\n    float sha = clamp(capsule(ro + p, vec3(0.), -l * 100., .24), 0., 1.);\n\n    float at = pow(i / 20., 2.);\n    col += mix(\n    vec3(.2, .5, 1.) * (pow(vdotl, 3.) * .5 + .1),\n    vec3(.7, .4, .3) * (pow(vdotl, 3.) * .5),\n    pow(vdotl, 10.)) * smoothstep(0., .05, sha) * at;\n\n    col = pow(col, vec3(1.0 / 2.2));\n\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float random(vec2 p) {\n  return fract(sin(dot(p, vec2(12.75, 8.92))) * 53638.97582);\n}\n\nfloat noise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n\n  float a = random(i);\n  float b = random(i + vec2(1., 0.));\n  float c = random(i + vec2(0., 1.));\n  float d = random(i + vec2(1., 1.));\n\n  f = f * f * (3.0 - 2.0 * f);\n\n  return mix(mix(a,b,f.x),mix(c,d,f.x), f.y);\n}\n\nfloat fbm(vec2 p) {\n  float a = .5;\n  float f = 1.;\n  float y = 0.;\n\n  for(int i = 0; i < 8; i++) {\n    y += a * noise(f * p);\n    f *= 2.;\n    a *= .5;\n  }\n\n  return y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float mx = max(iResolution.x, iResolution.y);\n  vec2 uv = gl_FragCoord.xy / mx;\n  uv *= 20.;\n  vec3 color = vec3(0.);\n\n  color += fbm(uv);\n\n  fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float random(vec2 p) {\n  return fract(sin(dot(p, vec2(124.75, 83.92))) * 53638.97582);\n}\n\nfloat noise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n\n  float a = random(i);\n  float b = random(i + vec2(1., 0.));\n  float c = random(i + vec2(0., 1.));\n  float d = random(i + vec2(1., 1.));\n\n  f = f * f * (3.0 - 2.0 * f);\n\n  return mix(mix(a,b,f.x),mix(c,d,f.x), f.y);\n}\n\nfloat fbm(vec2 p) {\n  float a = .5;\n  float f = 1.;\n  float y = 0.;\n\n  for(int i = 0; i < 8; i++) {\n    y += a * noise(f * p);\n    f *= 2.;\n    a *= .5;\n  }\n\n  return y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float mx = max(iResolution.x, iResolution.y);\n  vec2 uv = gl_FragCoord.xy / mx;\n  uv *= 20.;\n  vec3 color = vec3(0.);\n\n  color += smoothstep(.995, 1., random(uv));\n\n  fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}