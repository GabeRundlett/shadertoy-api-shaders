{
    "Shader": {
        "info": {
            "date": "1715909026",
            "description": "simply layered voronoi. Infinitely expandable, though I can't say the performance will be very good. Check out waves mode!",
            "flags": 32,
            "hasliked": 0,
            "id": "MfGXDd",
            "likes": 5,
            "name": "mountainsÕè",
            "published": 3,
            "tags": [
                "procedural",
                "voronoi",
                "terrain",
                "fbm",
                "generation"
            ],
            "usePreview": 0,
            "username": "01000001",
            "viewed": 108
        },
        "renderpass": [
            {
                "code": "float treeLine = .3;\n\n#define n(x) m=min(m, x)\nfloat df(vec3 p){\n    float m = 1e9;\n    \n    p.xy = p.xy*.5+.5;\n    \n    n(\n        max(\n            p.z - texture(iChannel0, p.xy).z,\n            max(abs(p.x-.5), abs(p.y-.5))-.5\n        )\n    );\n    \n    #ifndef waves\n    if (p.z < treeLine && max(abs(p.x-.5), abs(p.y-.5)) < .5){\n        vec4 temp = voronoi((p.xy+iTime*.05/scale)*3e2);\n        m -= (1.-pow(temp.z, 2.))*1e-2 * clamp((-p.z+treeLine)*20., 0., 1.);\n    }\n    #endif\n    \n    return m;\n}\n\nvec3 norm(vec3 p, float e){\n    return normalize(vec3(\n        df(p + vec3(e, 0, 0)) - df(p - vec3(e, 0, 0)),\n        df(p + vec3(0, e, 0)) - df(p - vec3(0, e, 0)),\n        df(p + vec3(0, 0, e)) - df(p - vec3(0, 0, e))\n    ));\n}\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    vec2 muv = (2.*iMouse.xy-r)/r.y;\n        \n    //O = texture(iChannel0, uv); return;\n    \n    vec3 o = vec3(0,0,.2);\n    vec3 dir = vec3(sin(muv.x)*cos(muv.y), cos(muv.x)*cos(muv.y), sin(muv.y));\n    o -= dir*2.;\n    vec3 right = normalize(cross(dir, vec3(0, 0, 1)));\n    vec3 up = cross(right, dir);\n    \n    vec2 camUV = cuv * .5;\n    vec3 dirV = vec3(sin(camUV.x)*cos(camUV.y), cos(camUV.x)*cos(camUV.y), sin(camUV.y));\n    dirV = normalize(dir * dirV.y + right * dirV.x + up * dirV.z);\n\n    vec3 p = o;\n    float d, t = 0.;\n    for (int i = 128; i-->0;){\n        p = o + dirV * t;\n        d = df(p);\n        t += d*.5;\n        if (d < 1e-4) i--;\n    }\n        \n    vec3 normal = norm(p, 1e-3*t);\n    vec3 lfnorm = norm(p, 1e-2); \n    \n    if (length(p.xy) > sqrt(2.) || abs(normal.x*normal.x + normal.y*normal.y-1.) < 1e-2){\n        O = exp(dirV.z*vec4(3,2,1,0)-1.);\n        return;\n    }\n    \n    #ifdef waves\n    \n     // this should blur low frequencies more, and leave high frequencies fairly unaffected\n    // idk how to do that so for now it's just the exact normal which doesn't look great\n    float light = max(0., dot(normal, normalize(vec3(1))));\n\n    \n    light*=.5;\n    O = pow(vec4(light*light, light, sqrt(light), 1),\n        vec4(1./2.2)\n    );\n    \n    #else\n    \n    float light = max(0., dot(normal, normalize(vec3(1))));\n    vec4 ambient = mix(vec4(1), vec4(.01,.02,.08,0), light);\n    \n    float sg = clamp((pow(lfnorm.z, 5.)), 0., 1.);\n    vec4 sgcol = mix(vec4(.1,.2,.1,1), vec4(1), smoothstep(0., 1., p.z*5.*scale-2.4 + sg*.5));\n    vec4 rscol = mix(vec4(.1, .05, .02, 1), vec4(.2), smoothstep(.3, .4, p.z*scale));\n    \n    O = pow(mix(rscol, sgcol, sg)*ambient,\n        vec4(1./2.2));\n        \n    #endif\n    \n    //O = vec4(exp(-t/3.));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 voronoiFBM(vec2 p, int levels){\n    vec4 sum, temp;\n    for (float i = 1.; i <= float(levels); i++){\n        temp = voronoi(p*i*i + i*\n        #ifdef waves\n        vec2(sin(i), cos(i))*iTime*.2\n        #else\n        i*1e2\n        #endif        \n        );\n        sum += vec4(temp.xyz / (pow(i, 2.7)), temp.w);\n    }\n    \n    return sum / scale;\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    vec2 muv = (2.*iMouse.xy-r)/r.y;\n    \n    O = vec4(voronoiFBM(uv*scale + iTime*.05, int(detail)));\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//#define waves\n\nfloat scale = 1.;\n\nconst float pi = 3.14159265;\nfloat detail = 16.;\n\nfloat hash( uvec2 x )\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    return float(n) * (1.0/float(0xffffffffU));\n} // hash by iq https://www.shadertoy.com/view/4tXyWN\n\nvec2 spiral(float t){\n    return vec2(sin(t*1e3), cos(t*1e3))*t;\n}\n\nvec4 voronoi(vec2 p){\n    float d = 9., t;\n\n    vec2 cell = floor(p), temp, n, id;\n    for(float x = -1.; x <= 1.; x++){\n        for (float y = -1.; y <= 1.; y++){\n            temp = cell + vec2(x,y);\n            temp = (p - cell - .5 - vec2(x,y) - \n                spiral(fract(hash(uvec2(abs(temp.x*9.), abs(temp.y*3.))))) / sqrt(2.)\n            );\n            t = length(temp);\n            if (t < d){\n                d = t;\n                n = temp;\n                id = cell + vec2(x, y);\n            }\n        }\n    }\n    \n    return vec4(n, d\n    #ifdef waves\n    *d\n    #endif\n    , sin(id.x*3.32432+id.y*4.543)*.5+.5);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}