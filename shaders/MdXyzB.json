{
    "Shader": {
        "info": {
            "date": "1616887901",
            "description": "POC for \"sandstorm cube\" from Phobos PC 8k intro.  https://youtu.be/_iyo6pT3ZVU?t=2159 2017\n#makeYourShadersPublic\n\n",
            "flags": 32,
            "hasliked": 0,
            "id": "MdXyzB",
            "likes": 21,
            "name": "sandstorm cube - [poc]",
            "published": 3,
            "tags": [
                "cube",
                "demoscene",
                "sandstorm",
                "phobos"
            ],
            "usePreview": 0,
            "username": "patu",
            "viewed": 698
        },
        "renderpass": [
            {
                "code": "#define getNormal getNormalHex\n\n#define FAR 570.\n#define INFINITY 1e32\n#define t iTime\n#define mt iChannelTime[1]\n#define FOV 100.0\n#define FOG .06\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat vol = 0.;\n\nvec3 fromRGB(int r, int g, int b) {\n \treturn vec3(float(r), float(g), float(b)) / 255.;   \n}\n    \nvec3 \n    light = vec3(0.0),\n\tlightDir = vec3(0.);\n\n\nvec3 lightColour = normalize(vec3(1.0, 1.0, 1.)); \n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n\nconst mat2 m2 = mat2(1.6,-1.2,1.2,1.6);\nfloat tri( in vec2 p )\n{\n    return 0.2*(cos(6.2831*p.x) + cos(6.2831*p.y));\n}\n\nfloat cloud (in vec2 p) {\n    \n    p *= 2.507;\n    p.y -= 0.5 * iTime;\n    float s = 1.0;\n\tfloat t = 0.0;\n    \n\tfor( int i=0; i< 3; i++ )\n\t{\n        t += s * tri( p );\n\t\ts *= 0.15 + .9 * t;\n        p = 1.9317 * m2 * p + (t - 0.5 ) * .1;// + sin(iTime / 14.);\n\t}\n    \n    return pow(t + .4, 2.2);\n}\nfloat spherical_texturing(in vec3 normal, float delta) {\n     float u = atan(normal.z, normal.x) / PI * 2.0 + delta;\n\t float v = asin(normal.y) / PI * 2.0;\n     return cloud(vec2(u, v));\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\nvec4 fold1(vec4 z) {\n    vec3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return vec4(p, z.w);\n}\n\nvec4 fold2(vec4 z) {\n    vec3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return vec4(p * 2.0, 2.0 * z.w);\n}\n\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nstruct geometry {\n    float dist;\n    vec3 space;\n    vec3 hit;\n    vec3 sn;\n    vec2 material;\n    int iterations;\n    float glow;\n};\n\ngeometry geoU(geometry g1, geometry g2) {\n    if (g1.dist < g2.dist) return g1;\n    return g2;\n}\n\ngeometry geoI(geometry g1, geometry g2) {\n    if (g1.dist > g2.dist) return g1;\n    return g2;\n}\n\nvec3 opS2( vec3 d1, vec3 d2 )\n{\t\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\nvec3 opI2( vec3 d1, vec3 d2 ) {\n \tif (d1.x > d2.x) return d1;\n    return d2;\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\n\n\nfloat smin( float a, float b, float k ){\n    \n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n    \n}\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat fCross(vec3 p, vec3 size) {\n    float obj = fBox(p, size);\n    obj = opU2(obj, fBox(p, size.zxy));\n    obj = opU2(obj, fBox(p, size.yzx));\n               \n               return obj;\n}\n\nvec4 boxmap(sampler2D t, in vec3 p, vec3 n, in float k ) {\n    vec3 m = pow( abs(p), vec3(k) );\n\tvec4 x = texture(t, p.yz);\n\tvec4 y = texture(t, p.zx);\n\tvec4 z = texture(t, p.xy);\n\treturn (x * m.x + y * m.y + z * m.z) / (m.x + m.y + m.z);\n}\n\nvec2 mpi(vec2 p) {\n\tp = mod(p, 2.);\n    if (p.x > 1.) p.x = 2. - p.x;\n    if (p.y > 1.) p.y = 2. - p.y;\n    \n    return p ;//+ sin( p.y - p.x) * .1;\n}\nvec2 pixel = vec2(0.);\n\nfloat noi(vec3 p) {\n \tfloat noise = \n        2. * textureLod(iChannel0, mpi(-vec2(p.yx * 0.3) - vec2(t * 1.2, 1.2)), 4.).r;\n       // texture(iChannel0, pixel + mpi(-vec2(p.yx * 0.25) - vec2(t * 1.2, 1.2))).r;\n    \n    noise *= \n        textureLod(iChannel0, mpi(-vec2(p.xz * .02) - vec2(-t * .4, 9.)), 4.).r;\n        \n    \n    noise -= textureLod(iChannel0, mpi(vec2((noise), p.xy * .1)),4.).r * 2.;\n      \n    \n    return noise;\n}\n\ngeometry map(vec3 p) {\n    \n    vec3 bp = p;\n    \n    geometry obj2, obj, cap;\n    \n    p = bp;\n    \n\tfloat noise = noi(p);\n    \n\tcap.dist = length(p.zy) - 1.4 - noise; \n    \n    cap.material = vec2(2., 0.);\n    cap.space = p;\n\n    obj.material = vec2(2., 0.);\n    bp.y += 3.;// + noise *.1;\n    bp.y += texture(iChannel0, mpi(p.xz * 0.9 + vec2(0., t * 3.))).r * 0.1;\n    \n    obj.dist = fBox2Cheap(bp.xy, vec2(10., 1.));\n    obj.space = p;\n    \n    bp += vec3(0., 0., +16.);\n    \n    bp.y -= 6.;\n    pR(bp.xy, t);   \n    pR(bp.xz, t);\n    \n\n    obj2.dist = fBox(bp, vec3(9.) + sin(t * .5) * 2.);\n    obj2.material = vec2(3., 0.);\n    \n    geometry obj3 = obj2;\n    \n    obj2.dist += abs(noise * .5);\n    \n    //if (obj.dist > 18.) return obj2;\n    \n    cap.dist = smin(obj2.dist, cap.dist, .15 + noise * .01);\n    \n    obj2.dist -= 1.;\n    \n    p.z -= 6.;\n    p.x -= 2.;\n    p.y += 1.5 + sin(t) * noi(p.zyx / 90.) * 4.2;\n    \n   \n    return geoU(geoU(obj, cap), obj3);\n}\n\n\nfloat t_min = 0.1;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 100;\n\ngeometry trace(vec3 o, vec3 d) {\n    float omega = 1.3;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 1./ 100.;\n    \n    geometry mp = map(o);\n    mp.glow = 0.;\n    \n    float functionSign = mp.dist < 0. ? -1. : +1.;\n    float minDist = INFINITY;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n\n        mp = map(d * t + o);\n\t\tmp.iterations = i;\n        \n        //minDist = min(minDist, mp.dist * 3.);\n        //if (i < 116) mp.glow = pow(1. / minDist, 1.8);\n        \n        //glow = pow( 1. / minDist, 0.8);\n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength * .4;\n   \t}\n    \n    mp.dist = candidate_t;\n    \n    \n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INFINITY;\n    \n    \n    return mp;\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 12;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = .5;\n    float dist = 1.;\n    float end = max(length(rd), 0.001);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).dist;\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.2), 1.0);\n}\n\n\n#define EPSILON .001\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).dist;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(EPSILON,0,0)).dist-d,\n                map(pos+vec3(0,EPSILON,0)).dist-d,\n                map(pos+vec3(0,0,EPSILON)).dist-d \n        \t)\n    \t);\n}\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos).dist;\n    return clamp(sdist / dist, 0.8, 1.0);\n}\n\nvec3 Sky(in vec3 rd, bool showSun, vec3 lightDir)\n{\n   \n   float sunSize = .4;\n   float sunAmount = max(dot(rd, lightDir), .4);\n   float v = pow(1.2 - max(rd.y, 0.0), 3.);\n   vec3 sky = mix(fromRGB(255,136,154), vec3(1., .5, .3) * 1., v);\n   if (showSun == false) sunSize = .1;\n   sky += lightColour * sunAmount * sunAmount * 1. + lightColour * min(pow(sunAmount, 111.0)* sunSize, 1. * sunSize);\n   \n    //if (showSun) sky += texture(iChannel0, vec2(v, rd.x) * 4.).rgb / 4.;\n   //if (showSun) sky -= fract(v /  4.) * vec3(0.3, 0.2, 0.1) ;//- noise(rd.xy * 100.);\n   return clamp(sky, 0.0, 1.0);\n}\n\nvec4 getObjectColor(vec3 p, vec3 n, geometry obj) {\n    vec4 col = vec4(.0);\n    col.rgb = vec3(1., .6, 0.4) * 4.;\n    \n    if (obj.material.x == 1.0) { \n        col /= 9.;\n        col += pow(texture(iChannel0, mpi(p.xz / 3. + vec2(0, t * 2.))).rrrr * 3., vec4(.4));///col.a = .5;\n    };    \n        \n    if (obj.material.x == 3.0) {\n        col += 10.;  \n    }\n\n    return col;\n}\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayOri,   // camera position\n               in vec3  rayDir ) {  // camera to point vector\n    \n    float c = .3;\n    float b = .3;\n\n    float fogAmount = c * exp(-rayOri.y * b) * (1.0-exp( -distance*rayDir.y*b ))/rayDir.y;\n    \n    vec3  fogColor  = vec3(1., .6, .3);//Sky(rayDir, false, normalize(light)) * 1.;//\n    \n    return mix( rgb, fogColor, min(1.2, fogAmount) );\n}\n\nvec4 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec4 sceneCol = vec4(0.0);\n    lp = sp + lp;\n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld / 2.), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n\n    // Attenuating the light, based on distance.\n    float atten = 1. / (1.0 + lDist * 0.025 + lDist * lDist * 0.2);\n\n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 1.);\n    // Standard specualr term.\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), 1.), 0.1);\n\n\n    vec4 objCol = getObjectColor(sp, sn, obj);\n\t  \n\n    sceneCol.rgb += (objCol.rgb * (diff + .15) * spec  * .1);\n    \n    return sceneCol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    //lightColour = normalize(fromRGB(133,7,142)) * 2.; \n    \n    vec2 ouv = fragCoord.xy / iResolution.xy;\n    vec2 uv = ouv - .5;\n    \n    vol = 1.;//length(texture(iChannel0, vec2(.42, .25)).rgb);\n    \n    pixel = 1./iResolution.xy;\n    \n    uv *= tan(radians (FOV) / 2.0) * 1.1;\n\n    //uv.y *= 1.2;\n    //vol = texture(iChannel0, vec2(.5, .25)).r  * 4.; \n    float t2 = t - 35.;\n    float \n        sk = sin(-t2 * .4) * 166.0, \n        ck = cos(-t2 * .4) * 162.0,\n        \n        mat = 0.;\n    \n    //uv.x *= 1. + abs(cos(uv.y)) / 2.; // fisheye\n    \n    light = vec3(10., 20., -10.);        \n    lightDir = light;\n    \n    //uv += length(uv)/4.;//pow(uv, vec2(1.));\n    \n    vec3 \n        vuv = vec3(0., 1., 0.), // up\n    \tro = vec3(0., -1., 10.);// + vec3(iMouse.x / 2. - 100.,iMouse.y / 2. - 100., 10.); // pos\n    \n    vec3\n        vrp =  vec3(0., 1.4, 0.) , // lookat    */\n\t\t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro),\n        object;        \n\t\n    vec3 sceneColor = vec3(0.);\n    \n    vec3 lp = light;\n\tlightDir = lp;\n    \n    geometry tr = trace(ro, rd);\n    \n    float fog = smoothstep(FAR * FOG, 0., tr.dist / 6.);\n    tr.hit = ro + rd * tr.dist;\n    \n    tr.sn = getNormal(tr.hit);\t\n    \n    float sh = softShadow(tr.hit, ro + light, 2.);\n    \n    float \n        ao = getAO(tr.hit, tr.sn, 1.6);\t\n\n    vec3 sky = Sky(rd, true, normalize(light)) * 1.;\n    vec3 skyNoSun = Sky(rd, false, normalize(light)) * 1.;\n    \n\n    float alpha = 0.;\n    if (tr.dist < FAR) { \n        \n        vec4 col = doColor(tr.hit, rd, tr.sn, light, tr) * 1.;\n        //alpha = pow(tr.dist / FAR * 3.6, 6.);\n        sceneColor = col.rgb;\n        \n        sceneColor *= ao; \n        sceneColor *= sh;\n        \n               \n        sceneColor *= 1. + length(\n            max(0.,\n                1. * max(\n                    0.,\n                    length(normalize(light.xy) * max(vec2(0.), tr.sn.xy))\n                )\n             * 3.\n        ));\n        sceneColor = mix(sceneColor, skyNoSun, (1. - fog) * .6);  \n        sceneColor = mix(sceneColor, skyNoSun, saturate(tr.dist * 1.1 / FAR));\n    } else {\n        sceneColor = sky;\n    \ttr.dist = FAR;\n    }\n    \n    sceneColor = applyFog(sceneColor, tr.dist, ro, rd) + 0.1 * texture(iChannel0,mpi(tr.hit.xy * .2)).r;\n   \n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 2.5), 0.0, 1.0), alpha);\n    fragColor = pow(fragColor, vec4(1.4));\n\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define getNormal getNormalHex\n\n#define FAR 570.\n#define INFINITY 1e32\n#define t iTime\n#define mt iChannelTime[1]\n#define FOV 70.0\n#define FOG .06\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat vol = 0.;\n\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\n\nfloat fbm(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise_3(s * x);\n    }\n    return r;\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(\n        fbm(vec3(uv.y + 32. + uv.xy * 1.1, 0))// -\n        //fbm(vec3(uv.y + 32. + uv.xy * 13.5, 0))\n        ,\n        0,\n        0,\n        1.\n    );\n    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}