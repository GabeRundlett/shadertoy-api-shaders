{
    "Shader": {
        "info": {
            "date": "1692890218",
            "description": "hexagonal Void And Cluster bluenoise + its power spectrum ( sigma = 2.5 )\n- in A, the energy rejection modulo is along equilateral triangle grid\n- tile is 64*(1,sqrt(3)/2), should repeat as brick wall → inst, we produce 64*(1,sqrt(3)) which tiles as usual",
            "flags": 32,
            "hasliked": 0,
            "id": "mllfW8",
            "likes": 18,
            "name": "hexagonal Void And Cluster",
            "published": 3,
            "tags": [
                "noise",
                "bluenoise"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 368
        },
        "renderpass": [
            {
                "code": "// Hexagonal variant of https://shadertoy.com/view/DlXfWn\n// inspired from krax shader + my simplifications: https://www.shadertoy.com/results?query=Void+And+Cluster+Bluenoise\n\n// ===  Fourier Transform of Void And Cluster bluenoise ( Buff A,B,C, from https://www.shadertoy.com/view/mt2cWR ) ===\n// fork from Fourier-based transform (e.g. kernel convolution) using https://www.shadertoy.com/view/4s3GDs\n// adapted from  Flyguy's https://www.shadertoy.com/view/MscGWS#\n// see also https://www.shadertoy.com/view/4dGGz1 to play with spectrum.\n\n\n// #define paintDFT(F) log(length(F)) / log(SIZE.x*SIZE.y)     // log scale\n   #define paintDFT(F)     length(F) / sqrt(SIZE.x*SIZE.y)     // linear scale    \n\nvoid mainImage( out vec4 O,  vec2 u )\n{ \n    vec2 R = iResolution.xy,     \n         U = ( u - R/2.) / SIZE  + vec2(2,1)/2.,\n         I = floor(U);\n         U = fract(U) * SIZE / R ;\n\n // O =       texelFetch(iChannel0, ivec2(u) % (S*ivec2(1,2)), 0).xxxx ;return;              // uncomment for fullpage texture\n // O = vec4( texelFetch(iChannel0, ivec2(u) % (S*ivec2(1,2)), 0).x < iMouse.x/R.x) ;return; // dither(mouse.x)\n\n//O = texture(iChannel0,u/R*s/R      *vec2(1,2))/64.;                        return;  // (for debug)\n//O = texture(iChannel2,u/R*s/8./R   *vec2(1,2)).yzwx / vec4(.0001,64,64,0); return;\n//O = texture(iChannel3,u/R*s/8./8./R*vec2(1,2)).yzwx / vec4(.0001,64,64,0); return;\n    O *= 0.;\n    \n    O +=  I == vec2(0,0) ? texture(iChannel0, (u+vec2(1,.5)*SIZE-floor(R/2.))/R).x // left tile: Input image\n                        // texture(iChannel0, U).x                     // left tile: Input image\n        : I == vec2(2,0) ? paintDFT(texture(iChannel1, U*SIZE/s.x).xy) // right tile: DFT\n        : I.x < -1.      ? texture(iChannel0, u/R).x                   // left border: repeated tile\n        :                  .3;  \n    \n    if ( int(u) > int(R)-10 ) { O = vec4(1, u.y/R.y > float(iFrame)/(s.x*s.y),0,0); return; } // red separator + progress bar\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define SIZE (2.*floor(iResolution.xx/4.*.8)) // uncomment for large spectrum (not nice for repeated tiles )\n  #define SIZE (s*vec2(1,2))\n\nconst ivec2 S = ivec2(64,55);  // bluenoiseSize = S x S.sqrt(3)/2 , cycling tile (like brick wall. use S.y*2 for regular tiling).\nvec2  s = vec2(S);             // note that more buffers are needed if S > 64 : clone C , S/8^(i+1)\nfloat sigma = 2.5;             // NB: krax used 1.9 \n\n#define T(x,y) texelFetch(iChannel0, ivec2(x,y) % S, 0)\n\nfloat H( uvec3 x ) {           // from iq https://www.shadertoy.com/view/XlXcW4\n    uint k = 1103515245U;      // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n // x = ((x>>8U)^x.yzx)*k;     // but this version only return 10⁻¹⁹ amplitude\n    return uintBitsToFloat( ((((x.x>>8U)^x.y)*k )  & 0x1fffffffU) );\n}\n\n#define M(S,c)                                                                                         \\\nvoid mainImage( out vec4 O, vec2 U ) {                                                                 \\\n    if( U.x > vec2((S+7)/8).x || U.y > vec2((S+7)/8).y ) return; /* we only simulate a small square */ \\\n    O = vec4( 0,1e35,0,0);                                                                             \\\n    ivec2   start = min( ivec2(U)*8, S - 1 ),                 /* to reduce a 8x8 above subtile to 1 */ \\\n              end = min( start + 8, S );                                                               \\\n    for( int y=start.y; y<end.y; ++y)                                                                  \\\n      for( int x=start.x; x<end.x; ++x) {                                                              \\\n        vec4 E = T(x,y);                                                                               \\\n        c;                                                    /* store result */                       \\\n}   } \n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// This stage deals with updating the blue noise energy.\n// On the first iteration, we simply seed it with background energy.\n// output: .x = bluenoise, .y = energy.   \n// input:  D.yz = location or largest void.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = texelFetch(iChannel0, ivec2(U) % (S*ivec2(1,2)), 0);  // uncomment to repeat copies\n    if( U.y>s.y && U.y<2.*s.y )  O = T(U.x+s.x/2.,U.y);       // to avoid managing brick wall tiling, copy the offseted odd line\n    if( U.x>s.x || U.y>s.y ) return; // we only simulate a small (cyclicling) tile\n\n    if(iFrame == 0)                  // init: noise = 0, energy = random\n    {   O.xy = vec2( 0, H(uvec3(U, 2111)) );\n        return;\n    }\n    \n    O = T(U.x,U.y);                  // previous state\n    if(iFrame > S.x*S.y-1) return;   // max iteration reached\n \n \n    // Get the result from downscaling and finding the smallest void center\n    U = abs( floor(U) - texelFetch(iChannel1, ivec2(0), 0).zw ) / s;  // delta to target\n\n    float v = 1. - float(iFrame-1) / (s.x*s.y-1.); // noise value = normalized iterations\n\n    // Wrap around logic : max energy around optimal void center modulo s : https://www.desmos.com/calculator/zuopknqihy\n//  vec2 d = ( abs( U - .5 ) - .5 )  * s / sigma;\n    U*=s; \n    float d = min( min( length(U), length(U-vec2(s.x,0)) ), length(U-vec2(s.x/2.,s.y)) ) / sigma;\n    // should I reject more modulos ?\n    d = min(d, min( length(U-vec2(-s.x/2.,s.y)),length(U-vec2(3.*s.x/2.,s.y)) ) / sigma );  // probably useless ?\n    \n    O.xy += vec2( U==vec2(0) ? v : 0.,            // we are at the optimum : store noise\n                  v * exp( -d*d )                 // energy += gaussian to optimum\n              //  v * max(0., 1.-d )              // variant\n                );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Void and cluster reduce init\n// input:  .xy = SxS state noise,energy.\n// output: .yzw = lowest energy value + position on SxS /8   ( and not already chosen )\n\nM( S , \n   if( E.x == 0. && E.y < O.y ) O = vec4( 0, E.y, x, y )\n )",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Void and cluster reduce iteration\n// input:  .xy = SxS /8 state energy,location\n// output: .yzw = lowest energy value + position on SxS /8²  ( and not already chosen )\n//                note that with S = 64 this is only 1 pixel.\n\nM( (S+7)/8 ,                                            \n   if( E.y < O.y ) O = E\n )",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Fourier transform of the input\n\n// Horizontal + Vertical Discrete Fourier Transform of the input \n// 2 passes pipelined : in -> buf.zw -> buf.xy -> out\n// ( adapted from  Flyguy's https://www.shadertoy.com/view/MscGWS# )\n\n\n#define tex(ch,I)  texelFetch(ch, I, 0)\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage( out vec4 O, vec2 uv )\n{\n    O-=O; \n    \n    if(uv.x > SIZE.x || uv.y > SIZE.y) return;\n        \n    for(float n = 0.; n < SIZE.x; n++)  {\n        vec2 xn = tex(iChannel0, ivec2(n+.5, uv.y) ).xy,\n             a = - 6.2831853 * (uv-.5 -SIZE/2.) * n/SIZE;       \n        O.zw += cmul(xn, a.x);\n    }\n    for(float n = 0.; n < SIZE.y; n++)  {\n        vec2 yn = tex(iChannel1, ivec2(uv.x, n+.5) ).zw,\n             a = - 6.2831853 * (uv-.5 -SIZE/2.) * n/SIZE;\n        O.xy += cmul(yn, a.y);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}