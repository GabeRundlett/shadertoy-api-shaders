{
    "Shader": {
        "info": {
            "date": "1722089140",
            "description": "source https://www.shadertoy.com/view/fstGRX https://www.shadertoy.com/view/4slXD7 https://www.shadertoy.com/view/stsXDl",
            "flags": 0,
            "hasliked": 0,
            "id": "Mcjyzm",
            "likes": 0,
            "name": "fractal with music",
            "published": 3,
            "tags": [
                "fractal",
                "music"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 77
        },
        "renderpass": [
            {
                "code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(10.,23,21))*1.5+.5)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat t; //time\nvec3 glw = vec3(0); //glow\n\nfloat bx(vec3 p, vec3 s) //box sdf\n{\n  vec3 q=abs(p)-s;\n  return min(max(q.x,max(q.y,q.z)), 0.) + length(max(q,0.));\n}\n\nfloat cy(vec3 p, float r) //cylinder sdf\n{\n  return length(p.xz)-r;\n}\n\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nvec2 mp(vec3 p) //map/scene\n{\n  vec3 pp = p; //temp position\n\n  //audio based modifier - just replaced with a sine here\n  float fb = sin(t)*0.5+0.5;\n float ss=0.,s=0.,st=1./4.;\n    for(float z=0.; z<1.; z+=st) {\n    for(float y=0.; y<1.; y+=st) {\n    for(float x=0.; x<1.; x+=st) {\n    \n         s = 2.+10.*texture(iChannel0, vec2(x*y*z,.0)).r;\n         }}}\n  float g = length(pp) - fb*2.; //centre glow calculation\n  glw +=0.21/(0.21+g*g)*vec3(0.4,0.1,0.9); //add glow\n  \n  for(float i=0.;i<5.;i++) //kifs loop for centre\n  {\n     pp.xy=abs(pp.xy)-0.2 - fb*0.5*s;\n  pp.zx*=rot(s*0.1*i);\n  pp.zy*=rot(iTime*0.1);\n     pp.z += fb*s;\n\n  }\n  vec2 b = vec2(bx(pp, vec3(1.*s)) - 0.1, 1.); //create centre crystal\n  pp=p; \n  \n\n\n \n  vec2 c = vec2(cy(pp,1.),2.); //outer cylinders\n  pp.y*=sin(t/3.); //hacky way to get the colours to shift by shifting the y\n  g = length(pp.xz) * 0.85; //slight glow on pillars\n \n\n  \n  return b.x < c.x ? b : c;\n} \n\n\nvec2 tr(vec3 ro,vec3 rd,float x) //raymarcher\n{\n  vec2 d = vec2(0);\n  for(int i = 0; i < 10; i++)\n  {\n    vec3 p=ro+rd*d.x;\n    vec2 s=mp(p);s.x*=x;\n    d.x+=s.x;d.y=s.y;\n    if(d.x>64.||s.x<0.001)break;\n  }\n  if(d.x>64.)d.y=0.;return d;\n}\n\nvec3 nm(vec3 p) //normal calc\n{\n  vec2 e = vec2(0.001,0); return normalize(mp(p).x-vec3(mp(p-e.xyy).x,mp(p-e.yxy).x,mp(p-e.yyx).x));\n}\n\nvec4 px(vec4 h, vec3 rd, vec3 n) //hit \"shader\" - calculates the colour from position + object + ray + normal data\n{\n  vec4 b=vec4(0,0,0,1); //background\n  if(h.a==0.)return vec4(b.rgb,1.); //return background for object id 0\n  vec4 a=h.a == 1. ? vec4(cos(t)*0.5+0.5,0.1,0.3, 0.2) : vec4(0.,0.,0.,0.8); //base colour\n  float d=dot(n,-rd); //unclamped diffuse\n  float dd=max(d,0.); //diffuse proper\n  float f=pow(1.-d,4.); //easy fres by using inverse of unclamped diffuse\n  float s=pow(abs(dot(reflect(rd,n),-rd)),40.); //specular\n  return vec4(a.rgb*(dd+f)+s,a.a); //mix together\n}\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n       t=iTime; \n     vec2 uv = vec2(C.x/iResolution.x, C.y/iResolution.y); //uv\n  uv-=0.5;uv/=vec2(iResolution.y/iResolution.x,1); //uv normalise\n  vec3 ro = vec3(0, 0, -30),rd=normalize(vec3(uv + vec2(0, 0),1.)), //ray origin and direction\n  oro=ro,ord=rd,cn,cp,cc;float ts=1.; //lots of variables to track transparency loop\n  for(int i=0;i<4;i++) //transparency loop\n  {\n    vec2 f=tr(oro,ord,1.); //march to front object\n    cp=oro+ord*f.x;cn=nm(cp); //update current position and normal\n    vec4 c=px(vec4(cp,f.y),ord,cn); //colour for front object\n    if(f.y==0.||c.a==1.){cc=mix(cc,c.rgb,ts);break;}; //mix colour and break if object is solid or there was no object\n    ro=cp-cn*0.01;rd=refract(ord,cn,1./1.3); //refract and update ray\n    vec2 z=tr(ro,rd,-1.); //march through object\n    cp=ro+rd*z.x;cn=nm(cp); //update current position and normal\n    oro=cp+cn*0.01;ord=refract(rd,-cn,1.3); //refract and update the original ray variables\n    if(dot(ord,ord)==0.)ord=reflect(rd,-cn); //reflect if refraction failed\n    cc=mix(cc,c.rgb,ts);ts-=c.a; //mix colour\n    if(ts<=0.)break; //break if we reached 0 transmission\n  }\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(0.1,0.,1.),H(g*.1),1.8)*1./e/8e3\n    )\n    {\n        p=g*d;\n        \n     \n   p.yx*=rot(iTime);\n       \n        a=30.;\n        p=mod(p-a,a*2.)-a;\n        s=2.;\n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n            p.x<p.z?p=p.zyx:p;\n              p.yz*=rot(iTime);\n            p.z<p.y?p=p.xzy:p;\n            s*=e=1.4+sin(iTime*.1)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.+sin(iTime*.3+.5*sin(iTime*.3))*3.,\n                    120,\n                    8.+cos(iTime*.5)*5.\n                 )*cc;\n         }\n         g+=e=length(p.yx)/s;\n    }\n   \n    uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    O*= vec4(happy_star(uv, anim) * vec3(2.35,1.2,0.15)*3.5, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 19,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}