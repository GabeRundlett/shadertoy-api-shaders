{
    "Shader": {
        "info": {
            "date": "1469402944",
            "description": "Threw together some old shaders along with stubbe's Stubble Bobble competition entry. Thought it was fun.\n\nhttps://www.shadertoy.com/view/Mlt3Wn",
            "flags": 56,
            "hasliked": 0,
            "id": "lld3D4",
            "likes": 13,
            "name": "Tablet Stubble Bobble",
            "published": 3,
            "tags": [
                "draft"
            ],
            "usePreview": 1,
            "username": "P_Malin",
            "viewed": 1177
        },
        "renderpass": [
            {
                "code": "\n// Coffee & Tablet - @P_Malin\n\n// Stubble Bobble from - https://www.shadertoy.com/view/Mlt3Wn\n\n#define PI 3.141592654\n\n//#define LOW_QUALITY\n\n//#define ENABLE_MONTE_CARLO\n#define ENABLE_REFLECTIONS\n#define ENABLE_FOG\n#define ENABLE_SPECULAR\n#define ENABLE_POINT_LIGHT\n#define ENABLE_POINT_LIGHT_FLARE\n\n#ifdef LOW_QUALITY\n\n#define kRaymarchMatIter 32\n\n#else\n\n#define kRaymarchMatIter 128\n\n#endif\n\n#ifdef ENABLE_MONTE_CARLO\nuniform sampler2D backbuffer;\n\nvec4 gPixelRandom;\nvec3 gRandomNormal;\n \nvoid CalcPixelRandom( const in vec2 fragCoord, float seed )\n{\n\tvec2 vOffset = fract(sin(seed * 123.3 + vec2(0.2, 0.43)) * 30.0);\n\tgPixelRandom = texture(iChannel3, fragCoord.xy / 64.0 + vOffset);\n\tgRandomNormal = normalize( gPixelRandom.xyz - 0.5);\n}\n \n#endif\n \n \nstruct C_Ray\n{\n\tvec3 vOrigin;\n\tvec3 vDir;\n};\n\nstruct C_HitInfo\n{\n\tvec3 vPos;\n\tfloat fDistance;\n\tvec3 vObjectId;\n};\n\nstruct C_Material\n{\n\tvec3 cAlbedo;\n\tfloat fR0;\n\tfloat fSmoothness;\n\tvec2 vParam;\n};\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\n\t\nvec3 RotateX( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vPos.x, vSinCos.y * vPos.y + vSinCos.x * vPos.z, -vSinCos.x * vPos.y + vSinCos.y * vPos.z);\n}\n\nvec3 RotateY( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.z, vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.z );\n}\n\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n\t\nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateX( vPos, SinCos(fAngle) );\n}\n\nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateY( vPos, SinCos(fAngle) );\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\n\nvec4 DistCombineUnion( const in vec4 v1, const in vec4 v2 )\n{\n\t//if(v1.x < v2.x) return v1; else return v2;\n\treturn mix(v1, v2, step(v2.x, v1.x));\n}\n\nvec4 DistCombineIntersect( const in vec4 v1, const in vec4 v2 )\n{\n\treturn mix(v2, v1, step(v2.x,v1.x));\n}\n\nvec4 DistCombineSubtract( const in vec4 v1, const in vec4 v2 )\n{\n\treturn DistCombineIntersect(v1, vec4(-v2.x, v2.yzw));\n}\n\nfloat GetDistanceYZTorus( const in vec3 p, const in float r1, const in float r2 )\n{\n\tvec2 q = vec2(length(p.yz)-r1,p.x);\n\treturn length(q)-r2;\n}\n\nfloat GetDistanceRoundedBox( const in vec3 vPos, const in vec3 vSize, float fRadius )\n{\n\tvec3 vClosest = max(min(vPos, vSize), -vSize);\n\treturn length(vClosest - vPos) - fRadius;\n}\n\n\nfloat GetDistanceMug( const in vec3 vPos )\n{\n\tfloat fDistCylinderOutside = length(vPos.xz) - 1.0;\n\tfloat fDistCylinderInterior = length(vPos.xz) - 0.9;\n\tfloat fTop = vPos.y - 1.0;\n       \n\tfloat r1 = 0.6;\n\tfloat r2 = 0.15;\n\tvec2 q = vec2(length(vPos.xy + vec2(1.2, -0.1))-r1,vPos.z);\n\tfloat fDistHandle = length(q)-r2;\n       \n\tfloat fDistMug = max(max(min(fDistCylinderOutside, fDistHandle), fTop), -fDistCylinderInterior);\n\treturn fDistMug;\n}\n\nfloat GetDistanceCoffee( const in vec3 vPos )\n{\n\tfloat fTopCoffee = vPos.y - 0.7;\n\tfloat fDistCylinderCoffee = length(vPos.xz) - 0.95;\n\t\n\tfloat fDistCoffee = max(fTopCoffee, fDistCylinderCoffee);\n\treturn fDistCoffee;\n}\n\nvec4 GetDistanceTablet( const in vec3 vPos )\n{             \n\tvec3 vBevelPos = vPos - vec3(0.0, 1.71, 0.0);\n\tfloat r = 1.0;\n\tfloat fBevelDist = GetDistanceRoundedBox( vBevelPos, vec3(1.5, 1.0, 2.0), r );\n\n\tvec3 vCasePos = vPos - vec3(0.0, 0.0, 0.0);\n\tfloat fCaseDist = GetDistanceRoundedBox( vCasePos, vec3(1.5, 1.0, 2.0), 0.5 );\n\n\tvec4 vResult = vec4(max(fBevelDist, fCaseDist), 4.0, vPos.xz);\n\t\n\tvec4 vScreenDist = vec4(-vPos.y, 5.0, vPos.xz);\n\tvResult = DistCombineSubtract(vResult, vScreenDist);\n       \n\tvec4 vButtonDist = vec4( length(vPos + vec3(0.0, -0.25, 2.1)) - 0.3, 5.0, vPos.xz);\n\tvResult = DistCombineSubtract(vResult, vButtonDist);\n\t\n\treturn vResult;\n}\n\n// result is x=scene distance y=material or object id; zw are material specific parameters (maybe uv co-ordinates)\nvec4 GetDistanceScene( const in vec3 vPos )\n{           \n\tvec4 vResult = vec4(10000.0, -1.0, 0.0, 0.0);\n\t\n\tvec3 vMugDomain = vPos + vec3(2.4, 0.0, -2.0);\n\tvMugDomain = RotateY(vMugDomain, 1.0);\n\t\n\tvec4 vDistMug = vec4( GetDistanceMug(vMugDomain), 2.0, atan(vMugDomain.z,vMugDomain.x), vMugDomain.y);\n\tvResult = DistCombineUnion(vResult, vDistMug);\n\t\n\tvec4 vDistCoffee = vec4( GetDistanceCoffee(vMugDomain), 3.0, vMugDomain.xz);\n\tvResult = DistCombineUnion(vResult, vDistCoffee);\n\t\n\tvec4 vDistFloor = vec4(vPos.y + 1.0, 1.0, vPos.xz);\n\tvResult = DistCombineUnion(vResult, vDistFloor);\n\t\n\tvec3 vTabletDomain = vPos;\n\tvTabletDomain += vec3(-0.8, 0.7, 0.0);\n\tvTabletDomain = RotateY(vTabletDomain, -1.0);\n\tvec4 vDistTablet = GetDistanceTablet(vTabletDomain);\n\tvResult = DistCombineUnion(vResult, vDistTablet);\n\t\n\treturn vResult;\n}\n \nC_Material GetObjectMaterial( const in vec3 vObjId, const in vec3 vPos )\n{\n\tC_Material mat;\n\t\n\tif(vObjId.x < 1.5)\n\t{\n\t\t// floor\n\t\tvec4 cTextureSample = texture(iChannel0, vPos.xz * 0.2);                    \n\t\tmat.fR0 = 0.02;\n\t\tmat.cAlbedo = cTextureSample.rgb * cTextureSample.rgb; // cheap gamma\n\t\tmat.fSmoothness = mat.cAlbedo.r;\n\t}\n\telse\n\tif(vObjId.x < 2.5)\n\t{\n\t\t// mug\n\t\tmat.fR0 = 0.05;\n\t\tmat.fSmoothness = 0.9;\n\t\tvec2 vUV = vObjId.yz / vec2(PI, -2.0) + vec2(1.0, 0.5);\n\t\t//vUV = clamp( vUV, 0.0, 1.0);\n\t\t//vUV = (vUV / (vec2(6.0,1.0)) - vec2(0.0,0.0));\n        vUV.x = 1.0 - vUV.x;\n        vUV.y = 1.0 - vUV.y;\n\t\tvec4 cTextureSample = texture(iChannel2, vUV);  \n\t\tvec3 vColour = cTextureSample.rgb * cTextureSample.rgb;\n\t\tmat.cAlbedo = vColour * 0.9 + 0.1;\n\t}\n\telse\n\tif(vObjId.x < 3.5)\n\t{\n\t\t// coffee\n\t\tmat.fR0 = 0.01;\n\t\tmat.fSmoothness = 1.0;\n\t\tmat.cAlbedo = vec3(0.5, 0.3, 0.2);\n\t}\n\telse\n\tif(vObjId.x < 4.5)\n\t{\n\t\t// tablet back\n\t\tmat.fR0 = 0.25;\n\t\tmat.fSmoothness = 0.0;\n\t\tmat.cAlbedo = vec3(0.8, 0.8, 0.8);                            \n\t}\n\telse\n\t{\n\t\t// tablet screen\n\t\tmat.fR0 = 0.01;\n\t\tmat.fSmoothness = 1.0;                               \n\t\tmat.cAlbedo = vec3(0.025);\n\t}\n               \t\n\t\n\treturn mat;\n}\n \nvec3 GetSkyGradient( const in vec3 vDir )\n{\n\tfloat fBlend = vDir.y * 0.5 + 0.5;\n\treturn mix(vec3(0.0, 0.0, 0.0), vec3(0.4, 0.9, 1.0), fBlend);\n}\n \nvec3 GetLightPos()\n{\n\tvec3 vLightPos = vec3(0.0, 1.0, 3.0);\n\t#ifdef ENABLE_MONTE_CARLO         \n\tvLightPos += gRandomNormal * 0.2;\n\t#endif\n\treturn vLightPos;\n}\n \nvec3 GetLightCol()\n{\n\treturn vec3(32.0, 6.0, 1.0);\n}\n\nvec3 GetAmbientLight(const in vec3 vNormal)\n{\n\treturn GetSkyGradient(vNormal);\n}\n \n#define kFogDensity 0.025\nvoid ApplyAtmosphere(inout vec3 col, const in C_Ray ray, const in C_HitInfo intersection)\n{\n\t#ifdef ENABLE_FOG\n\t// fog\n\tfloat fFogAmount = exp(intersection.fDistance * -kFogDensity);\n\tvec3 cFog = GetSkyGradient(ray.vDir);\n\tcol = mix(cFog, col, fFogAmount);\n\t#endif\n\t\n\t// glare from light (a bit hacky - use length of closest approach from ray to light)\n\t#ifdef ENABLE_POINT_LIGHT_FLARE\n\tvec3 vToLight = GetLightPos() - ray.vOrigin;\n\tfloat fDot = dot(vToLight, ray.vDir);\n\tfDot = clamp(fDot, 0.0, intersection.fDistance);\n\t\n\tvec3 vClosestPoint = ray.vOrigin + ray.vDir * fDot;\n\tfloat fDist = length(vClosestPoint - GetLightPos());\n\tcol += GetLightCol() * 0.01/ (fDist * fDist);\n\t#endif      \n}\n \nvec3 GetSceneNormal( const in vec3 vPos )\n{\n\t// tetrahedron normal\n\tfloat fDelta = 0.025;\n\n\tvec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);\n\tvec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);\n\tvec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);\n\tvec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);\n\n\tfloat f1 = GetDistanceScene( vPos + vOffset1 ).x;\n\tfloat f2 = GetDistanceScene( vPos + vOffset2 ).x;\n\tfloat f3 = GetDistanceScene( vPos + vOffset3 ).x;\n\tfloat f4 = GetDistanceScene( vPos + vOffset4 ).x;\n\n\tvec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;\n\n\treturn normalize( vNormal );\n}\n \n#define kRaymarchEpsilon 0.01\n#define kRaymarchStartDistance 0.1\n \n// This is an excellent resource on ray marching -> https://iquilezles.org/articles/distfunctions\nvoid Raymarch( const in C_Ray ray, out C_HitInfo result, const float fMaxDist, const int maxIter )\n{          \n\tresult.fDistance = kRaymarchStartDistance;\n\tresult.vObjectId.x = 0.0;\n\t\t\t\t    \n\tfor(int i=0;i<=kRaymarchMatIter;i++)                \n\t{\n\t\tresult.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n\t\tvec4 vSceneDist = GetDistanceScene( result.vPos );\n\t\tresult.vObjectId = vSceneDist.yzw;\n\t\t\n\t\t// abs allows backward stepping - should only be necessary for non uniform distance functions\n\t\tif((abs(vSceneDist.x) <= kRaymarchEpsilon) || (result.fDistance >= fMaxDist) || (i > maxIter))\n\t\t{\n\t\t\tbreak;\n\t\t}                          \t\n\t\t\n\t\tresult.fDistance = result.fDistance + vSceneDist.x;      \n\t}\n\t\n\t\n\tif(result.fDistance >= fMaxDist)\n\t{\n\t\tresult.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n\t\tresult.vObjectId.x = 0.0;\n\t\tresult.fDistance = 1000.0;\n\t}\n}\n \nfloat GetShadow( const in vec3 vPos, const in vec3 vLightDir, const in float fLightDistance )\n{\n\tC_Ray shadowRay;\n\tshadowRay.vDir = vLightDir;\n\tshadowRay.vOrigin = vPos;\n\n\tC_HitInfo shadowIntersect;\n\tRaymarch(shadowRay, shadowIntersect, fLightDistance, 32);\n\t\t\t\t\t\t\t\t\t\t\t\t\t     \n\treturn step(0.0, shadowIntersect.fDistance) * step(fLightDistance, shadowIntersect.fDistance );           \n}\n \n// http://en.wikipedia.org/wiki/Schlick's_approximation\nfloat Schlick( const in vec3 vNormal, const in vec3 vView, const in float fR0, const in float fSmoothFactor)\n{\n\tfloat fDot = dot(vNormal, -vView);\n\tfDot = min(max((1.0 - fDot), 0.0), 1.0);\n\tfloat fDot2 = fDot * fDot;\n\tfloat fDot5 = fDot2 * fDot2 * fDot;\n\treturn fR0 + (1.0 - fR0) * fDot5 * fSmoothFactor;\n}\n \nfloat GetDiffuseIntensity(const in vec3 vLightDir, const in vec3 vNormal)\n{\n\treturn max(0.0, dot(vLightDir, vNormal));\n}\n \nfloat GetBlinnPhongIntensity(const in C_Ray ray, const in C_Material mat, const in vec3 vLightDir, const in vec3 vNormal)\n{            \n\tvec3 vHalf = normalize(vLightDir - ray.vDir);\n\tfloat fNdotH = max(0.0, dot(vHalf, vNormal));\n\n\tfloat fSpecPower = exp2(4.0 + 6.0 * mat.fSmoothness);\n\tfloat fSpecIntensity = (fSpecPower + 2.0) * 0.125;\n\n\treturn pow(fNdotH, fSpecPower) * fSpecIntensity;\n}\n \n// use distance field to evaluate ambient occlusion\nfloat GetAmbientOcclusion(const in C_Ray ray, const in C_HitInfo intersection, const in vec3 vNormal)\n{\n\tvec3 vPos = intersection.vPos;\n\t\n\tfloat fAmbientOcclusion = 1.0;\n\t\n\tfloat fDist = 0.0;\n\tfor(int i=0; i<=5; i++)\n\t{\n\t\tfDist += 0.1;\n\t\n\t\tvec4 vSceneDist = GetDistanceScene(vPos + vNormal * fDist);\n\t\n\t\tfAmbientOcclusion *= 1.0 - max(0.0, (fDist - vSceneDist.x) * 0.2 / fDist );                                    \n\t}\n\t\n\treturn fAmbientOcclusion;\n}\n\nvec3 GetObjectLighting(const in C_Ray ray, const in C_HitInfo intersection, const in C_Material material, const in vec3 vNormal, const in vec3 cReflection)\n{\n\tvec3 cScene ;\n\t\n\tvec3 vSpecularReflection = vec3(0.0);\n\tvec3 vDiffuseReflection = vec3(0.0);\n\t\n\tfloat fAmbientOcclusion = GetAmbientOcclusion(ray, intersection, vNormal);\n\tvec3 vAmbientLight = GetAmbientLight(vNormal) * fAmbientOcclusion;\n\t\n\tvDiffuseReflection += vAmbientLight;\n\t\n\tvSpecularReflection += cReflection * fAmbientOcclusion;\n\t\t\n\t#ifdef ENABLE_POINT_LIGHT\n\tvec3 vLightPos = GetLightPos();\n\tvec3 vToLight = vLightPos - intersection.vPos;\n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fLightDistance = length(vToLight);\n\t\n\tfloat fAttenuation = 1.0 / (fLightDistance * fLightDistance);\n\t\n\tfloat fShadowBias = 0.1;              \n\tfloat fShadowFactor = GetShadow( intersection.vPos + vLightDir * fShadowBias, vLightDir, fLightDistance - fShadowBias );\n\tvec3 vIncidentLight = GetLightCol() * fShadowFactor * fAttenuation;\n\t\n\tvDiffuseReflection += GetDiffuseIntensity( vLightDir, vNormal ) * vIncidentLight;                                                                                  \n\tvSpecularReflection += GetBlinnPhongIntensity( ray, material, vLightDir, vNormal ) * vIncidentLight;\n\t#endif // ENABLE_POINT_LIGHT\n\t\n\tvDiffuseReflection *= material.cAlbedo;\n\n\t// emmissive glow from screen\n\tif(intersection.vObjectId.x > 4.5)\n\t{\n\t\tvec2 vScreenPos = intersection.vObjectId.zy * vec2(-0.25, -0.3) + vec2(0.54, 0.5);\n\t       \n\t\t// emissive brightness is 0 unless screen\n\t\tvec2 vMul = step(vScreenPos, vec2(1.0)) * step(vec2(0.0), vScreenPos);\n\t\tfloat kScreenBrightness = 0.8;\n\t\tfloat fMul = vMul.x * vMul.y * kScreenBrightness;\n        \n        {\n\t\t    vec2 targetSize = vec2(32.,27.)*8.;\n            vScreenPos *= targetSize / iResolution.xy;\n        }\n        \n\t\tvec3 cVideoColour = texture(iChannel1, vScreenPos).xyz;\n\t\tvDiffuseReflection += cVideoColour * cVideoColour * fMul; // cheap gamma correction\n\t}\n\t\n\t\n\t#ifdef ENABLE_SPECULAR\n\tfloat fFresnel = Schlick(vNormal, ray.vDir, material.fR0, material.fSmoothness * 0.9 + 0.1);\n\tcScene = mix(vDiffuseReflection , vSpecularReflection, fFresnel);\n\t#else\n\tcScene = vDiffuseReflection;\n\t#endif\n\t\n\treturn cScene;\n}\n \nvec3 GetSceneColourSimple( const in C_Ray ray )\n{\n\tC_HitInfo intersection;\n\tRaymarch(ray, intersection, 16.0, 32);\n\t\t\t     \n\tvec3 cScene;\n       \n\tif(intersection.vObjectId.x < 0.5)\n\t{\n\t\tcScene = GetSkyGradient(ray.vDir);\n\t}\n\telse\n\t{\n\t\tC_Material material = GetObjectMaterial(intersection.vObjectId, intersection.vPos);\n\t\tvec3 vNormal = GetSceneNormal(intersection.vPos);\n      \n\t\t// use sky gradient instead of reflection\n\t\tvec3 cReflection = GetSkyGradient(reflect(ray.vDir, vNormal));\n      \n\t\t// apply lighting\n\t\tcScene = GetObjectLighting(ray, intersection, material, vNormal, cReflection );\n\t}\n       \n\tApplyAtmosphere(cScene, ray, intersection);\n       \n\treturn cScene;\n}\n \nvec3 GetSceneColour( const in C_Ray ray )\n{                                                           \n\tC_HitInfo intersection;\n\tRaymarch(ray, intersection, 30.0, 256);\n\t\t     \n\tvec3 cScene;\n\t\n\tif(intersection.vObjectId.x < 0.5)\n\t{\n\t\tcScene = GetSkyGradient(ray.vDir);\n\t}\n\telse\n\t{\n\t\tC_Material material = GetObjectMaterial(intersection.vObjectId, intersection.vPos);\n\t\tvec3 vNormal = GetSceneNormal(intersection.vPos);\n\t\n\t\t#ifdef ENABLE_MONTE_CARLO\n\t\tvNormal = normalize(vNormal + gRandomNormal / (5.0 + material.fSmoothness * 200.0));\n\t\t#endif\n\t\n\t\tvec3 cReflection;\n\t\t#ifdef ENABLE_REFLECTIONS\t\n\t\t{\n\t\t\t// get colour from reflected ray\n\t\t\tfloat fSepration = 0.05;\n\t\t\tC_Ray reflectRay;\n\t\t\treflectRay.vDir = reflect(ray.vDir, vNormal);\n\t\t\treflectRay.vOrigin = intersection.vPos + reflectRay.vDir * fSepration;\n\t\t\t\t\t\t\t\t\t       \n\t\t\tcReflection = GetSceneColourSimple(reflectRay);                                                                          \n\t\t}\n\t\t#else\n\t\tcReflection = GetSkyGradient(reflect(ray.vDir, vNormal));                               \n\t\t#endif\n\t\t// apply lighting\n\t\tcScene = GetObjectLighting(ray, intersection, material, vNormal, cReflection );\n\t}\n\t\n\tApplyAtmosphere(cScene, ray, intersection);\n\t\n\treturn cScene;\n}\n \nvoid GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, const in vec2 fragCoord, out C_Ray ray)\n{\n\tvec2 vPixelCoord = fragCoord.xy;\n\t#ifdef ENABLE_MONTE_CARLO\n\tvPixelCoord += gPixelRandom.zw;\n\t#endif\n\tvec2 vUV = ( vPixelCoord / iResolution.xy );\n\tvec2 vViewCoord = vUV * 2.0 - 1.0;\n\n\tvViewCoord *= 0.75;\n\t\n\tfloat fRatio = iResolution.x / iResolution.y;\n\n\tvViewCoord.y /= fRatio;                            \n\n\tray.vOrigin = vPos;\n\n\tvec3 vRight = normalize(cross(vForwards, vWorldUp));\n\tvec3 vUp = cross(vRight, vForwards);\n\t     \n\tray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards);         \n}\n \nvoid GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, const in vec2 fragCoord, out C_Ray ray)\n{\n\tvec3 vForwards = normalize(vInterest - vPos);\n\tvec3 vUp = vec3(0.0, 1.0, 0.0);\n\n\tGetCameraRay(vPos, vForwards, vUp, fragCoord, ray);\n}\n \nvec3 OrbitPoint( const in float fHeading, const in float fElevation )\n{\n\treturn vec3(sin(fHeading) * cos(fElevation), sin(fElevation), cos(fHeading) * cos(fElevation));\n}\n \nvec3 Tonemap( const in vec3 cCol )\n{\n\treturn 1.0 - exp2(-cCol);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t#ifdef ENABLE_MONTE_CARLO              \n\tCalcPixelRandom( fragCoord, iTime );\n\t#endif\n\t\n\tC_Ray ray;\n\t\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\t\n\t// If we have never moved the mouse\n\tif(iMouse.x <= 0.0)\n\t{\n\t\tmouse.xy = vec2(0.5);\n\t}\n\t\n\tvec3 vCameraPos = OrbitPoint(-mouse.x * 14.0 + PI, (mouse.y) * PI * 0.2 + PI * 0.025) * 6.0 - vec3(0.0, 0.0, 0.0);\n\t#ifdef ENABLE_MONTE_CARLO              \n\tfloat fDepthOfField = 0.1;\n\tvCameraPos += gRandomNormal * 0.05;\n\t#endif\n\t\n\tGetCameraRayLookat( vCameraPos, vec3(1.0, -0.5, 0.0), fragCoord, ray);\n\t//GetCameraRayLookat(vec3(0.0, 0.0, -5.0), vec3(0.0, 0.0, 0.0), ray);\n\t\n\tvec3 cScene = GetSceneColour( ray );\t\n\t\n\tfloat fExposure = 2.5;\n\tcScene = cScene * fExposure;\n\tvec3 cCurr = Tonemap(cScene );\n\t\n\t#ifdef ENABLE_MONTE_CARLO                              \n\tvec3 cPrev = texture(backbuffer, fragCoord.xy / iResolution.xy).xyz;\n\t// would be nice to combine before tonemap but undoing a gamma=2.0 will do instead\n\tcPrev = cPrev * cPrev;\n\t// add noise to pixel value (helps values converge)\n\tcPrev += (gPixelRandom.xyz - 0.5) * (1.0 / 255.0);\n\tcCurr = cCurr * cCurr;\n\t// converge speed\n\t//float fBlend = 8.0/255.0;\n\tfloat fBlend = 1.0;\n\tvec3 cFinal = mix(cPrev, cCurr, fBlend);\n\t// re-apply gamma 2.0\n\tcFinal = sqrt(cFinal);\n\t#else\n\tvec3 cFinal = cCurr;\n\t#endif\n\t\n\tfloat fAlpha = 1.0;\n\n\t\n\tfragColor = vec4( cFinal, fAlpha );    \n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// shared game state\n\nconst int ENTITIES_START_Y = 1;\nconst int MAX_ENTITIES = 64;\nconst int NUM_DYNAMIC_ROWS = 3;\n\nconst int LEVEL_WIDTH = 28;\nconst int LEVEL_HEIGHT = 25;\nconst int LEVEL_START_Y = 32;\nconst int NUM_LEVELS = 4;\n\nconst int FONT_START_Y = 8;\nconst int FONT_HEIGHT = 8;\nconst int FONT_WIDTH = 8;\n\nconst int SPRITE_WIDTH = 16;\nconst int SPRITE_HEIGHT = 16;\nconst int SPRITE_START_Y = 16;\n\nconst int STRINGS_START_Y = 60;\nconst int STR_GAME_OVER = 0;\nconst int STR_BEGINNING0 = 1;\nconst int STR_BEGINNING1 = 2;\nconst int STR_BEGINNING2 = 3;\nconst int STR_BEGINNING3 = 4;\nconst int STR_BEGINNING4 = 5;\nconst int STR_PUSH_START = 6;\nconst int STR_1UP = 7;\nconst int STR_HIGH_SCORE = 8;\nconst int STR_00 = 9;\nconst int STR_INSERT = 10;\nconst int STR_COIN = 11;\nconst int STR_TO = 12;\nconst int STR_CONTINUE = 13;\nconst int STR_COPYRIGHT = 14;\nconst int STR_ALL_RIGHTS = 15;\nconst int STR_INSERT_COIN = 16;    \nconst int NUM_STRINGS = 17;\n\nconst int LOGO_START_Y = 200;\nconst int LOGO_WIDTH = 300;\nconst int LOGO_HEIGHT = 150;\n\nconst float ENTITY_TYPE_BUBBLE = 1.0;\nconst float ENTITY_TYPE_MONSTER = 2.0;\nconst float ENTITY_TYPE_TUMBLING_MONSTER = 3.0;\nconst float ENTITY_TYPE_ITEM = 4.0;\nconst float ENTITY_TYPE_SCORE = 5.0;\n\nconst int MONSTER_SPRITE_START_IDX = 5;\nconst int ITEM_SPRITE_START_IDX = 9;\n\nconst int NUM_PLACE_PLAYER_FRAMES = 120;\n\nconst float BUBBLE_ATTACK_FRAMES = 20.0;\nconst float BUBBLE_DEATH_FRAMES = 30.0;\nconst float BUBBLE_LIFE_FRAMES = 1200.0;\nconst float BUBBLE_FLOW_POWER = 0.4;\nconst float BUBBLE_ATTACK_EXP_SCALE = .15;\nconst float BUBBLE_POP_THRESHOLD = 4.0;\nconst float BUBBLE_COOLDOWN = 15.0;\nconst float RESPAWN_FRAMES = 120.0;\nconst float MONSTER_FREE_FRAME = 120.0;\nconst float MONSTER_HIT_DIST_SQ = 60.0;\n\nconst float WIN_DELAY_FRAMES = 150.0;\nconst float INVULNERABLE_FRAMES = 90.0;\n\nconst float PI = 3.1415926535;\nconst float GRAVITY = 0.10;\nconst float TERMINAL_VELOCITY = 1.0;\nconst float MOVEMENT_SPEED = 1.5;\nconst float JUMP_VELOCITY = 3.0;\nconst float PUSH_VECTOR_SCALE = .3;\nconst vec2 txGameState =    vec2(0.0,0.0);\nconst vec2 txGameState2 =   vec2(1.0,0.0);\nconst vec2 txGameState3 =   vec2(2.0,0.0);\nconst vec2 txPlayerPos =    vec2(3.0,0.0);  \nconst vec2 txPlayerSprite = vec2(4.0,0.0);  //vec4(sprite_idx, mirrored, 0, 0)\nconst vec2 txPlayerFlags =  vec2(5.0,0.0);\n// private game state\nconst vec2 txPlayerVel =    vec2(6.0,0.0);\nconst vec2 txKeyWasDown =\tvec2(7.0,0.0);\nconst vec2 txCoolDown = \tvec2(8.0,0.0);\nconst vec2 txStaticDataInited = vec2(9.0,0.0);\n\nconst int SKIP_INTRO = 0;\nconst int START_LEVEL = 1;\n\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\n\nconst int _A = 10, _B = 11, _C = 12, _D = 13, _E = 14, _F = 15, _G = 16, _H = 17, _I = 18, _J = 19, _K = 20, _L = 21, _M = 22, _N = 23, _O = 24, _P = 25, _Q = 26, _R = 27, _S = 28, _T = 29, _U = 30, _V = 31, _W = 32, _X = 33, _Y = 34, _Z = 35, _COPYRIGHT = 36, _EXCLAMATION = 37, _SPACE = 38;\n\n#define HASHSCALE1 .1031\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 Logo(int x, int y)\n{\n    y += 50;\n    vec2 coord = vec2(x, y);\n    float radius = 5.0;\n    float radiusSq = radius*radius;\n    vec2 pos = vec2(0);\n    \n    const int NUM_STEPS = 50;\n    const int NUM_OBJECTS = 13;\n    const int NUM_PARTS = 3;\n    const float STEP_SIZE = 1.5;\n    \n\t#define P(_T) enabled = true; if(phase == ph++ && t >= (_T)) phase++, \n    #define E(_T) if(phase == ph++ && t >= (_T)) break;\n    \n    float value = 0.0;\t//0.0: not drawn, 1.0: inner, 2.0: edge, 3.0: shadow\n    \n    vec2 shadowOffset = vec2(-3,-2);\n    for(int object = 0; object < NUM_OBJECTS; object++)\n    {\n        for(int pass = 0; pass < 2; pass++)\n        {\n            for(int part = 0; part < NUM_PARTS; part++)\n            {       \n                int phase = 0;\n                float shortestDistSq = 1e10;\n                float hitT = 0.0;\n\n                float angle = 0.0;\n                float velocity = 0.0;\n                float acceleration = 0.0;\n                bool enabled = false;\n                bool overrideInner = false;\n                for(int i = 0; i < NUM_STEPS; i++)\n                {\n                    float t = float(i) / float(NUM_STEPS - 1);\n                    int ph = 0;\n                    \n                    // E\n                    if(object == 0)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(170,115), angle = -PI*.5;\n                            P(0.4) angle += PI*.5;\n                            E(0.6);\n                        }\n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(170,115), angle = -PI*.5;\n                            P(0.2) angle += PI*.5;\n                            E(0.35);\n                        }\n                        if(part == 2)\n                        {\n                            P(0.0) pos=vec2(170,115), angle = 0.0;\n                            E(0.2);\n                        }\n                    }\n                    \n                    // L\n                    if(object == 1)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(155,115), angle = -PI*.5-.2;\n                            P(0.4) angle += PI*.5;\n                            E(0.6);\n                        }\n                    }\n                    \n                    // B\n                    if(object == 2)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(130,95), angle = PI*.5;\n                            P(0.35) angle -= PI*0.5, acceleration = -0.007;\n                            P(0.70) acceleration = 0.004;\n                            E(0.82);\n                        }\n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(130,95), angle = -.3, acceleration = 0.007;\n                            P(0.2) overrideInner = true;\n                            E(0.35);\n                        }\n                    }\n                    \n                    // B\n                    if(object == 3)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(108,90), angle = PI*.5-.2;\n                            P(0.35) angle -= PI*0.5, acceleration = -0.007;\n                            P(0.70) acceleration = 0.004;\n                            E(0.82);\n                        }\n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(108,90), angle = -.5, acceleration = 0.007;\n                            P(0.2) overrideInner = true;\n                            E(0.37);\n                        }\n                    }\n                    \n                    // O\n                    if(object == 4)\n                    {\n                        if(part == 0)\n                        {\n                    \t\tP(0.0) pos=vec2(95,100), velocity = 0.13;\n                            E(0.7);\n                        }\n                    }\n                    \n                    // B\n                    if(object == 5)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(65,90), angle = PI*.5;\n                            P(0.4) angle -= PI*0.5, acceleration = -0.007;\n                            P(0.8) acceleration = 0.004;\n                            E(0.87);\n                        }\n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(65,90), angle = -0.2, acceleration = 0.0065;\n                            P(0.2) overrideInner = true;\n                            E(0.4);\n                        }   \n                    }\n                    \n                    // E\n                    if(object == 6)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(190,165), angle = -PI*.5-.2;\n                            P(0.4) angle += PI*.5;\n                            E(0.6);\n                        }\n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(190,165), angle = -PI*.5-.2;\n                            P(0.2) angle += PI*.5;\n                            E(0.35);\n                        }\n                        if(part == 2)\n                        {\n                            P(0.0) pos=vec2(190,165), angle = -.2;\n                            E(0.2);\n                        }\n                    }\n                    \n                    // L\n                    if(object == 7)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(173,165), angle = -PI*.5-.25;\n                            P(0.4) angle += PI*.5;\n                            E(0.6);\n                        }\n                    }\n                    \n                    // B\n                    if(object == 8)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(140,135), angle = PI*.5-.1;\n                            P(0.37) angle -= PI*0.5, acceleration = -0.007;\n                            P(0.70) acceleration = 0.004;\n                            E(0.82);\n                        }\n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(140,135), angle = -.4, acceleration = 0.007;\n                            P(0.2) overrideInner = true;\n                            E(0.4);\n                        }\n                    }\n                    \n                    // B\n                    if(object == 9)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(115,135), angle = PI*.5-.1;\n                            P(0.35) angle -= PI*0.5, acceleration = -0.007;\n                            P(0.70) acceleration = 0.004;\n                            E(0.82);\n                        }\n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(115,135), angle = -.4, acceleration = 0.007;\n                            P(0.2) overrideInner = true;\n                            E(0.37);\n                        }\n                    }\n                    \n                    // U\n                    if(object == 10)\n                    {\n                        if(part == 0)\n                        {\n                    \t\tP(0.0) pos=vec2(95,155), angle =-PI*.5-.2;\n                            P(0.2) velocity = 0.15;\n                            P(0.489) velocity = 0.0;\n                            E(0.68);\n                        }\n                    }\n                    \n                    // T\n                    if(object == 11)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(80,160), angle = -PI*.5+.1;\n                            E(0.35);\n                        }\n                        \n                        if(part == 1)\n                        {\n                            P(0.0) pos=vec2(67,157), angle = .1;\n                            E(0.30);\n                        }\n                    }\n                    \n                    // S\n                    if(object == 12)\n                    {\n                        if(part == 0)\n                        {\n                            P(0.0) pos=vec2(60,167), angle = PI+.3;\n                            P(0.1) velocity = 0.12;\n                            P(0.35) velocity = 0.0;\n                            P(0.6) velocity = -0.15;\n                            P(0.85) velocity = 0.0;\n                            E(0.95);\n                        }\n                        \n                    }\n                    \n                    \n                    if(!enabled) break;\n\n                    velocity += acceleration * STEP_SIZE;\n                    angle += velocity * STEP_SIZE;\n                    pos += STEP_SIZE * vec2(cos(angle), sin(angle));\n\n                    vec2 offset = (pass == 0) ? shadowOffset : vec2(0,0);\n                    vec2 delta = (coord + offset) - pos;\n                    float lenSq = dot(delta, delta);\n                    if(lenSq < radiusSq)\n                    {\n                        if(lenSq < shortestDistSq)\n                        {\n                            shortestDistSq = lenSq;\n                            hitT = t;\n\n                            if(pass == 0)\n                                value = 3.0;\n                            else\n                                if(lenSq < radiusSq * 0.4)\n                                {\n                                    value = 1.0;\n                                }\n                            \telse\n                                {\n                                    if(value != 1.0 || overrideInner)\n                                    \tvalue = 2.0;\n                                }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    vec3 color = vec3(0);\n    float len = 1e10;\n    for(int i = 0; i < 200; i++)\n    {\n        float t = float(i) + 1200.0;\n        vec2 p = vec2((hash11(t)*2.0)*80.0-80.0,(hash11(t+1000.0)*2.0)*40.0-40.0) + vec2(128, 125);\n        len = min(len, length(p - coord) - hash11(t + 2000.0)*25.+8.0);\n    }\n    if(len < 10.0)\n    {\n        color = mix(vec3(250,161,0)/255.0, color, smoothstep(9.5, 10.0, len));\n        color = mix(vec3(0), color, smoothstep(6.5, 7.0, len));\n        color = mix(vec3(255,240,32)/255.0, color, smoothstep(5.0, 5.5, len));\n    }\n    \n    if(value == 1.0)\n        color = vec3(-1);\n    else if(value >= 2.0)\n        color = vec3(0);\n    \n    return color;\n}\n\n\n\n//hack hack: encode bits into floating point mantissa. much faster to compile than any of the alternatives\n#define D24(_y, _d0, _d1, _d2, _d3, _d4, _d5, _d6, _d7, _d8, _d9, _d10, _d11, _d12, _d13, _d14, _d15, _d16, _d17, _d18, _d19, _d20, _d21, _d22, _d23) v = (y == (_y)) ? (float(_d0)*0.5 + float(_d1)*1.0 + float(_d2)*2.0 + float(_d3)*4.0 + float(_d4)*8.0 + float(_d5)*16.0 + float(_d6)*32.0 + float(_d7)*64.0 + float(_d8)*128.0 + float(_d9)*256.0 + float(_d10)*512.0 + float(_d11)*1024.0 + float(_d12)*2048.0 + float(_d13)*4096.0 + float(_d14)*8192.0 + float(_d15)*16384.0 + float(_d16)*32768.0 + float(_d17)*65536.0 + float(_d18)*131072.0 + float(_d19)*262144.0 + float(_d20)*524288.0 + float(_d21)*1048576.0 + float(_d22)*2097152.0 + float(_d23)*4194304.0) : v;\n\nbool Font(int x, int y, int n)\n{\n    if(x < 0 || x >= FONT_WIDTH || y < 0 || y >= FONT_HEIGHT) return false;\n    float v = 0.0;\n    y = (FONT_HEIGHT - 1) - y;\n    \n    int b = n / 3;\n    \n    \n    if(b == 0)\n    {\n        // 0, 1, 2\n        D24(0, 0,0,0,1,1,1,0,0, 0,0,0,0,1,1,0,0, 0,0,1,1,1,1,1,0)\n        D24(1, 0,0,1,0,0,1,1,0, 0,0,0,1,1,1,0,0, 0,1,1,0,0,0,1,1)\n        D24(2, 0,1,1,0,0,0,1,1, 0,0,0,0,1,1,0,0, 0,0,0,0,0,1,1,1)\n        D24(3, 0,1,1,0,0,0,1,1, 0,0,0,0,1,1,0,0, 0,0,0,1,1,1,1,0)\n        D24(4, 0,1,1,0,0,0,1,1, 0,0,0,0,1,1,0,0, 0,0,1,1,1,1,0,0)\n        D24(5, 0,0,1,1,0,0,1,0, 0,0,0,0,1,1,0,0, 0,1,1,1,0,0,0,0)\n        D24(6, 0,0,0,1,1,1,0,0, 0,0,1,1,1,1,1,1, 0,1,1,1,1,1,1,1) \n    }\n    else if(b == 1)\n    {\n        // 3, 4, 5\n        D24(0, 0,0,1,1,1,1,1,1, 0,0,0,0,1,1,1,0, 0,1,1,1,1,1,1,0)\n        D24(1, 0,0,0,0,0,1,1,0, 0,0,0,1,1,1,1,0, 0,1,1,0,0,0,0,0)\n        D24(2, 0,0,0,0,1,1,0,0, 0,0,1,1,0,1,1,0, 0,1,1,1,1,1,1,0)\n        D24(3, 0,0,0,1,1,1,1,0, 0,1,1,0,0,1,1,0, 0,0,0,0,0,0,1,1)\n        D24(4, 0,0,0,0,0,0,1,1, 0,1,1,1,1,1,1,1, 0,0,0,0,0,0,1,1)\n        D24(5, 0,1,1,0,0,0,1,1, 0,0,0,0,0,1,1,0, 0,1,1,0,0,0,1,1)\n        D24(6, 0,0,1,1,1,1,1,0, 0,0,0,0,0,1,1,0, 0,0,1,1,1,1,1,0)        \n    }\n    else if(b == 2)\n    {\n        // 6, 7, 8\n        D24(0, 0,0,0,1,1,1,1,0, 0,1,1,1,1,1,1,1, 0,0,1,1,1,1,0,0)\n        D24(1, 0,0,1,1,0,0,0,0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,0)\n        D24(2, 0,1,1,0,0,0,0,0, 0,0,0,0,0,1,1,0, 0,1,1,1,0,0,1,0)\n        D24(3, 0,1,1,1,1,1,1,0, 0,0,0,0,1,1,0,0, 0,0,1,1,1,1,0,0)\n        D24(4, 0,1,1,0,0,0,1,1, 0,0,0,1,1,0,0,0, 0,1,0,0,1,1,1,1)\n        D24(5, 0,1,1,0,0,0,1,1, 0,0,0,1,1,0,0,0, 0,1,0,0,0,0,1,1)\n        D24(6, 0,0,1,1,1,1,1,0, 0,0,0,1,1,0,0,0, 0,0,1,1,1,1,1,0)\n    }\n    else if(b == 3)\n    {\n        // 9, A, B\n        D24(0, 0,0,1,1,1,1,1,0, 0,0,0,1,1,1,0,0, 0,1,1,1,1,1,1,0)\n        D24(1, 0,1,1,0,0,0,1,1, 0,0,1,1,0,1,1,0, 0,1,1,0,0,0,1,1)\n        D24(2, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(3, 0,0,1,1,1,1,1,1, 0,1,1,0,0,0,1,1, 0,1,1,1,1,1,1,0)\n        D24(4, 0,0,0,0,0,0,1,1, 0,1,1,1,1,1,1,1, 0,1,1,0,0,0,1,1)\n        D24(5, 0,0,0,0,0,1,1,0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(6, 0,0,1,1,1,1,0,0, 0,1,1,0,0,0,1,1, 0,1,1,1,1,1,1,0)\n    }\n    else if(b == 4)\n    {\n        // C, D, E\n        D24(0, 0,0,0,1,1,1,1,0, 0,1,1,1,1,1,0,0, 0,1,1,1,1,1,1,1)\n        D24(1, 0,0,1,1,0,0,1,1, 0,1,1,0,0,1,1,0, 0,1,1,0,0,0,0,0)\n        D24(2, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,0,0)\n        D24(3, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,1,1, 0,1,1,1,1,1,1,0)\n        D24(4, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,0,0)\n        D24(5, 0,0,1,1,0,0,1,1, 0,1,1,0,0,1,1,0, 0,1,1,0,0,0,0,0)\n        D24(6, 0,0,0,1,1,1,1,0, 0,1,1,1,1,1,0,0, 0,1,1,1,1,1,1,1)\n    }\n    else if(b == 5)\n    {\n        // F, G, H\n        D24(0, 0,1,1,1,1,1,1,1, 0,0,0,1,1,1,1,1, 0,1,1,0,0,0,1,1)\n        D24(1, 0,1,1,0,0,0,0,0, 0,0,1,1,0,0,0,0, 0,1,1,0,0,0,1,1)\n        D24(2, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,1,1)\n        D24(3, 0,1,1,1,1,1,1,0, 0,1,1,0,0,1,1,1, 0,1,1,1,1,1,1,1)\n        D24(4, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(5, 0,1,1,0,0,0,0,0, 0,0,1,1,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(6, 0,1,1,0,0,0,0,0, 0,0,0,1,1,1,1,1, 0,1,1,0,0,0,1,1)\n    }\n    else if(b == 6)\n    {\n        // I, J, K\n        D24(0, 0,0,1,1,1,1,1,1, 0,0,0,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(1, 0,0,0,0,1,1,0,0, 0,0,0,0,0,0,1,1, 0,1,1,0,0,1,1,0)\n        D24(2, 0,0,0,0,1,1,0,0, 0,0,0,0,0,0,1,1, 0,1,1,0,1,1,0,0)\n        D24(3, 0,0,0,0,1,1,0,0, 0,0,0,0,0,0,1,1, 0,1,1,1,1,0,0,0)\n        D24(4, 0,0,0,0,1,1,0,0, 0,0,0,0,0,0,1,1, 0,1,1,1,1,1,0,0)\n        D24(5, 0,0,0,0,1,1,0,0, 0,1,1,0,0,0,1,1, 0,1,1,0,1,1,1,0)\n        D24(6, 0,0,1,1,1,1,1,1, 0,0,1,1,1,1,1,0, 0,1,1,0,0,1,1,1)\n    }\n    else if(b == 7)\n    {\n        // L, M, N\n        D24(0, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(1, 0,1,1,0,0,0,0,0, 0,1,1,1,0,1,1,1, 0,1,1,1,0,0,1,1)\n        D24(2, 0,1,1,0,0,0,0,0, 0,1,1,1,1,1,1,1, 0,1,1,1,1,0,1,1)\n        D24(3, 0,1,1,0,0,0,0,0, 0,1,1,1,1,1,1,1, 0,1,1,1,1,1,1,1)\n        D24(4, 0,1,1,0,0,0,0,0, 0,1,1,0,1,0,1,1, 0,1,1,0,1,1,1,1)\n        D24(5, 0,1,1,0,0,0,0,0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,1,1,1)\n        D24(6, 0,1,1,1,1,1,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n    }\n    else if(b == 8)\n    {\n        // O, P, Q\n        D24(0, 0,0,1,1,1,1,1,0, 0,1,1,1,1,1,1,0, 0,0,1,1,1,1,1,0)\n        D24(1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(2, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(3, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(4, 0,1,1,0,0,0,1,1, 0,1,1,1,1,1,1,0, 0,1,1,0,1,1,1,1)\n        D24(5, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,0,0, 0,1,1,0,0,1,1,0)\n        D24(6, 0,0,1,1,1,1,1,0, 0,1,1,0,0,0,0,0, 0,0,1,1,1,1,0,1)\n    }\n    else if(b == 9)\n    {\n        // R, S, T\n        D24(0, 0,1,1,1,1,1,1,0, 0,0,1,1,1,1,0,0, 0,0,1,1,1,1,1,1)\n        D24(1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,1,1,0, 0,0,0,0,1,1,0,0)\n        D24(2, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,0,0, 0,0,0,0,1,1,0,0)\n        D24(3, 0,1,1,0,0,1,1,1, 0,0,1,1,1,1,1,0, 0,0,0,0,1,1,0,0)\n        D24(4, 0,1,1,1,1,1,0,0, 0,0,0,0,0,0,1,1, 0,0,0,0,1,1,0,0)\n        D24(5, 0,1,1,0,1,1,1,0, 0,1,1,0,0,0,1,1, 0,0,0,0,1,1,0,0)\n        D24(6, 0,1,1,0,0,1,1,1, 0,0,1,1,1,1,1,0, 0,0,0,0,1,1,0,0)\n    }\n    else if(b == 10)\n    {\n        // U, V, W\n        D24(0, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1)\n        D24(2, 0,1,1,0,0,0,1,1, 0,1,1,0,0,0,1,1, 0,1,1,0,1,0,1,1)\n        D24(3, 0,1,1,0,0,0,1,1, 0,1,1,1,0,1,1,1, 0,1,1,1,1,1,1,1)\n        D24(4, 0,1,1,0,0,0,1,1, 0,0,1,1,1,1,1,0, 0,1,1,1,1,1,1,1)\n        D24(5, 0,1,1,0,0,0,1,1, 0,0,0,1,1,1,0,0, 0,1,1,1,0,1,1,1)\n        D24(6, 0,0,1,1,1,1,1,0, 0,0,0,0,1,0,0,0, 0,1,1,0,0,0,1,1)\n    }\n    else if(b == 11)\n    {\n        // X, Y, Z\n        D24(0, 0,1,1,0,0,0,1,1, 0,0,1,1,0,0,1,1, 0,1,1,1,1,1,1,1)\n        D24(1, 0,1,1,1,0,1,1,1, 0,0,1,1,0,0,1,1, 0,0,0,0,0,1,1,1)\n        D24(2, 0,0,1,1,1,1,1,0, 0,0,1,1,0,0,1,1, 0,0,0,0,1,1,1,0)\n        D24(3, 0,0,0,1,1,1,0,0, 0,0,0,1,1,1,1,0, 0,0,0,1,1,1,0,0)\n        D24(4, 0,0,1,1,1,1,1,0, 0,0,0,0,1,1,0,0, 0,0,1,1,1,0,0,0)\n        D24(5, 0,1,1,1,0,1,1,1, 0,0,0,0,1,1,0,0, 0,1,1,1,0,0,0,0)\n        D24(6, 0,1,1,0,0,0,1,1, 0,0,0,0,1,1,0,0, 0,1,1,1,1,1,1,1)\n    }\n    else if(b == 12)\n    {\n        // copyright, exclamation, space\n        D24(0, 0,0,1,1,1,1,0,0, 0,0,0,1,1,1,0,0, 0,0,0,0,0,0,0,0)\n        D24(1, 0,1,0,0,0,0,1,0, 0,0,0,1,1,1,0,0, 0,0,0,0,0,0,0,0)\n        D24(2, 1,0,0,1,1,0,0,1, 0,0,0,1,1,1,0,0, 0,0,0,0,0,0,0,0)\n        D24(3, 1,0,1,0,0,0,0,1, 0,0,0,1,1,0,0,0, 0,0,0,0,0,0,0,0)\n        D24(4, 1,0,1,0,0,0,0,1, 0,0,0,1,1,0,0,0, 0,0,0,0,0,0,0,0)\n        D24(5, 1,0,0,1,1,0,0,1, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0)\n        D24(6, 0,1,0,0,0,0,1,0, 0,0,0,1,1,0,0,0, 0,0,0,0,0,0,0,0)\n        D24(7, 0,0,1,1,1,1,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0)\n    }\n    \n    int bi = n - b*3;\n    return fract(v*exp2(float(-(bi*8 + x)))) >= 0.5;\n}\n\nint ModLevel(int level)\n{\n    if(level == 0) return 0;\n    return level - (level - 1)/NUM_LEVELS*NUM_LEVELS;\n}\n\nbool Level(int x, int y, int level)\n{\n    if(x < 0 || x >= LEVEL_WIDTH) return true;\n    if(y < 0 || y >= LEVEL_HEIGHT) return false;\n    \n    int abs_x = x <= (LEVEL_WIDTH - 1) - x ? x : (LEVEL_WIDTH - 1) - x;\n    \n    level = ModLevel(level);\n    \n    if(level == 1)\n    {\n        if(y == 0 || y == LEVEL_HEIGHT - 1)\n            return true;\n        else if((y == 5 || y == 10 || y == 15) && (abs_x <= 1 || abs_x >= 5))\n            return true;\n    }\n    else if(level == 2)\n    {\n        if(y == 0)\n            return true;\n        else if(y == 5 && ((abs_x >= 2 && abs_x <= 8) || (abs_x >= 11)))\n            return true;\n        else if(y == 10 && abs_x >= 5)\n            return true;\n        else if(y == 15 && abs_x >= 9 && abs_x <= 12)\n            return true;\n        else if(y == 20 && abs_x >= 11)\n            return true;\n    }\n    else if(level == 3)\n    {\n        if((y == 0 || y == 24) && (abs_x <= 6 || abs_x >= 11))\n            return true;\n        else if(y == 5 && (abs_x <= 4 || (abs_x >= 7 && abs_x <= 9)))\n            return true;\n        else if(abs_x == 3 && y >= 10 && y <= 19)\n            return true;\n        else if(y == 10 && abs_x >= 3 && abs_x <= 12)\n            return true;\n        else if(y == 15 && abs_x >= 3 && abs_x <= 11)\n            return true;\n        else if(y == 20 && abs_x >= 3 && abs_x <= 10)\n            return true;\n    }\n    else if(level == 4)\n    {\n        if((y == 0 || y == 24) && (abs_x <= 6 || abs_x >= 11))\n            return true;\n        if(y == 5 && (abs_x >= 3 && abs_x <= 9 || abs_x == 13))\n            return true;\n        if((y == 10 || y == 15) && (abs_x >= 3 && abs_x <= 6))\n            return true;\n        if(y == 19 && (abs_x >= 3 && abs_x <= 11))\n           return true;\n        if(y == 22 && (abs_x >= 6 && abs_x <= 8))\n           return true;\n        if(y == 23 && abs_x == 6)\n           return true;\n        if(abs_x == 3 && (y >= 5 && y <= 10 || y >= 15 && y <= 19))\n            return true;\n        if((abs_x >= 10 && abs_x <= 11) && (y >= 11 && y <= 19))\n            return true;\n    }\n    \n    return false;\n}\n\nbool Collision(int x, int y, int level)\n{\n    if(level == 0) return false;\n    \n    if(y < 0 || y >= LEVEL_HEIGHT-1) return false;\n    if(x < 0 || x >= LEVEL_WIDTH) return true;\n    \n    level = ModLevel(level);\n    \n    return texture(iChannel0, (vec2(x + level*LEVEL_WIDTH, y+LEVEL_START_Y) + 0.5) / iChannelResolution[0].xy).x > 0.5;\n}\n\n#define D16(_y, _d0, _d1, _d2, _d3, _d4, _d5, _d6, _d7, _d8, _d9, _d10, _d11, _d12, _d13, _d14, _d15) if(y == (_y)) v0 = float(_d0) * 0.125 + float(_d1) * 1.0 + float(_d2) * 8.0 + float(_d3) * 64.0 + float(_d4) * 512.0 + float(_d5) * 4096.0 + float(_d6) * 32768.0 + float(_d7) * 262144.0, v1 = float(_d8) * 0.125 + float(_d9) * 1.0 + float(_d10) * 8.0 + float(_d11) * 64.0 + float(_d12) * 512.0 + float(_d13) * 4096.0 + float(_d14) * 32768.0 + float(_d15) * 262144.0;    \nvec3 Sprite(int x, int y, int n)\n{\n    vec3 color = vec3(-1);\n    if(x < 0 || x >= SPRITE_WIDTH || y < 0 || y >= SPRITE_HEIGHT) return color;\n    y = (SPRITE_HEIGHT - 1) - y;\n \n    int palette = 0;\n    \n    float v0 = 0.0;\n    float v1 = 0.0;\n    if(n == 1)\n    {\n        palette = 0;\n        D16( 0, 0,0,0,0,0,0,0,0, 1,0,0,0,0,0,0,0)\n        D16( 1, 0,0,0,0,0,0,0,1, 1,1,0,0,0,0,0,0)\n        D16( 2, 0,0,0,1,1,1,1,2, 2,2,2,2,0,0,0,0)\n        D16( 3, 0,0,0,0,1,1,2,2, 2,2,2,2,2,0,0,0)\n        D16( 4, 0,0,0,0,0,2,2,2, 2,3,3,2,3,2,0,0)\n        D16( 5, 0,0,1,1,1,2,2,2, 3,3,4,2,4,3,0,0)\n        D16( 6, 0,0,0,1,2,2,2,2, 3,3,4,2,4,3,0,0)\n        D16( 7, 0,0,0,0,2,2,2,2, 3,3,4,2,4,3,2,0)\n        D16( 8, 0,0,1,1,2,2,2,2, 3,3,4,2,4,3,2,0)\n        D16( 9, 0,0,0,1,2,2,2,2, 2,3,3,2,3,3,2,0)\n        D16(10, 0,0,0,0,2,1,2,2, 0,0,0,3,0,0,0,0)\n        D16(11, 0,0,0,2,1,1,1,2, 2,2,2,2,2,2,0,0)\n        D16(12, 0,0,0,2,1,1,1,2, 2,3,3,3,3,0,0,0)\n        D16(13, 0,0,1,2,1,1,2,2, 3,3,3,3,3,3,0,0)\n        D16(14, 0,1,2,2,2,2,2,1, 1,3,3,3,3,3,0,0)\n        D16(15, 2,2,2,2,2,2,1,1, 1,1,3,3,3,1,1,1)\n    }\n    else if(n == 2)\n    {\n        // shoot\n        palette = 0;\n        D16( 0, 0,0,0,0,0,0,0,1, 0,0,0,0,0,0,0,0)\n        D16( 1, 0,0,0,0,0,0,1,1, 1,3,3,0,0,0,0,0)\n        D16( 2, 0,0,0,1,1,1,1,2, 2,4,3,3,2,0,0,0)\n\t\tD16( 3, 0,0,0,0,1,1,2,3, 4,2,4,3,3,2,0,0)\n        D16( 4, 0,0,0,0,0,2,3,3, 4,4,2,3,2,2,0,0)\n        D16( 5, 0,0,1,1,1,2,3,3, 3,4,3,2,2,0,0,0)\n        D16( 6, 0,0,0,1,2,2,2,3, 3,3,3,2,3,0,0,0)\n\t\tD16( 7, 0,0,0,0,2,2,2,2, 3,3,2,0,0,0,0,0)\n        D16( 8, 0,0,1,1,2,2,2,2, 2,2,0,0,0,0,0,0)\n        D16( 9, 0,0,0,0,0,2,2,2, 2,0,0,0,0,0,0,0)\n        D16(10, 0,0,0,1,1,1,2,2, 0,0,0,0,0,0,0,0)\n\t\tD16(11, 0,0,0,1,1,1,1,2, 2,2,2,2,2,2,0,0)\n        D16(12, 2,0,0,0,1,1,2,2, 2,3,3,3,3,0,0,0)\n        D16(13, 2,1,1,2,2,2,2,2, 3,3,3,3,3,3,0,0)\n        D16(14, 0,2,2,2,2,2,2,1, 1,1,3,3,3,3,0,0)\n\t\tD16(15, 0,0,2,2,2,2,1,1, 1,1,1,3,3,1,1,1)\n    }\n    else if(n == 3)\n    {\n        // dead!\n        palette = 0;\n        D16( 0, 0,0,0,3,0,0,0,0, 1,0,0,0,0,0,0,0)\n        D16( 1, 0,3,0,0,0,0,0,1, 1,1,0,0,0,0,0,0)\n        D16( 2, 0,0,0,1,1,1,1,2, 2,2,2,2,0,0,0,0)\n        D16( 3, 0,0,0,0,1,1,2,2 ,2,2,2,2,2,0,0,0)\n        D16( 4, 0,0,0,0,0,2,2,2 ,2,3,3,2,3,2,0,0)\n        D16( 5, 0,0,1,1,1,2,2,2 ,3,3,4,3,4,3,0,0)\n        D16( 6, 0,0,0,1,2,2,2,2 ,3,3,4,3,4,3,0,0)\n        D16( 7, 2,0,0,1,2,2,2,2 ,4,4,4,4,4,4,2,0)\n        D16( 8, 2,1,1,0,2,2,2,2 ,3,3,4,3,4,3,2,0)\n        D16( 9, 2,1,1,1,1,2,2,2 ,2,3,3,2,3,2,2,0)\n        D16(10, 0,1,1,1,1,1,2,0 ,0,0,0,0,0,0,0,0)\n        D16(11, 0,2,1,1,1,2,2,2 ,0,0,0,0,0,0,0,0)\n        D16(12, 0,0,2,2,2,2,2,2 ,0,0,0,0,0,0,0,0)\n        D16(13, 0,0,2,1,1,1,1,3 ,3,0,0,0,0,0,0,0)\n        D16(14, 0,0,2,2,1,1,1,1 ,3,3,3,3,1,1,1,0)\n        D16(15, 0,0,0,2,3,1,1,1 ,3,3,3,1,1,1,0,0)\n    }\n    else if(n == 4)\n    {\n        // in bubble\n        D16( 0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0)\n        D16( 1, 0,0,0,0,0,0,2,2, 2,2,0,0,0,0,0,0)\n        D16( 2, 0,0,0,0,2,2,2,2, 2,2,2,2,0,0,0,0)\n        D16( 3, 0,0,0,0,2,2,3,3, 2,3,3,2,0,0,0,0)\n        D16( 4, 0,0,0,2,2,3,3,4, 2,4,3,3,2,0,0,0)\n        D16( 5, 0,0,0,2,2,3,3,4, 2,4,3,3,2,0,0,0)\n        D16( 6, 0,0,2,2,2,3,3,4, 2,4,3,3,2,0,0,0)\n        D16( 7, 0,0,2,4,2,3,3,3, 2,3,3,3,2,2,0,0)\n        D16( 8, 0,0,2,4,2,2,3,3, 2,3,3,2,2,2,0,0)\n        D16( 9, 0,0,0,2,4,4,4,4, 4,4,4,4,4,0,0,0)\n        D16(10, 0,0,1,1,1,2,2,2, 2,2,2,2,2,0,1,0)\n        D16(11, 0,1,1,1,1,2,3,3, 3,3,3,2,1,1,1,0)\n        D16(12, 0,0,1,1,2,3,3,3, 3,3,3,3,2,1,0,0)\n        D16(13, 0,0,2,2,1,1,1,3, 3,3,1,1,1,0,0,0)\n        D16(14, 0,0,0,1,1,1,1,1, 3,1,1,1,1,0,0,0)\n        D16(15, 0,0,0,0,0,0,0,0, 0,1,1,1,0,0,0,0)\n    }\n    else if(n == 5)\n    {\n        // monster 0\n        palette = 1;\n        D16( 0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0)\n        D16( 1, 0,0,0,1,1,1,1,1, 1,1,1,1,1,0,0,0)\n        D16( 2, 0,0,1,1,3,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 3, 0,0,1,3,1,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 4, 0,0,1,3,1,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 5, 0,0,1,1,1,1,1,1, 1,1,1,1,2,5,5,0)\n        D16( 6, 0,0,1,1,1,1,1,1, 1,1,1,1,5,6,6,5)\n        D16( 7, 0,0,1,4,1,4,1,1, 1,1,1,1,5,6,6,5)\n        D16( 8, 0,0,1,4,1,4,1,1, 1,1,5,5,5,5,5,0)\n        D16( 9, 0,0,1,4,1,4,1,1, 1,2,6,6,5,6,0,0)\n        D16(10, 0,0,1,1,1,1,1,2, 2,2,6,6,5,6,0,0)\n        D16(11, 0,2,2,2,2,2,2,2, 2,6,5,5,6,2,0,0)\n        D16(12, 0,2,2,2,2,2,2,2, 2,2,6,6,2,2,0,0)\n        D16(13, 0,0,2,2,2,2,2,2, 2,2,2,2,2,0,0,0)\n        D16(14, 0,0,0,0,7,7,7,0, 0,7,7,7,7,0,0,0)\n        D16(15, 0,0,7,7,7,7,7,7, 0,0,0,0,0,0,0,0)\n    }\n    else if(n == 6)\n    {\n        // monster 1\n        palette = 1;\n        D16( 0, 0,0,0,0,0,1,1,1, 1,1,1,0,0,0,0,0)\n        D16( 1, 0,0,0,0,1,1,3,1, 1,1,1,1,1,1,0,0)\n        D16( 2, 0,0,0,1,1,3,1,1, 1,1,1,1,1,1,1,0)\n\t\tD16( 3, 0,0,0,1,1,1,1,1, 1,1,1,1,1,1,1,0)\n        D16( 4, 0,0,0,1,4,1,4,1, 1,1,1,1,1,1,1,0)\n        D16( 5, 0,0,0,1,4,1,4,1, 1,1,1,1,6,5,5,0)\n        D16( 6, 0,0,0,1,4,1,4,1, 1,1,1,6,5,6,6,5)\n\t\tD16( 7, 0,0,0,1,1,1,1,1, 1,1,1,6,5,6,6,5)\n        D16( 8, 0,0,0,4,4,4,4,4, 4,1,1,1,6,5,5,0)\n        D16( 9, 0,0,0,0,4,4,4,4, 4,4,4,4,5,5,5,0)\n        D16(10, 0,0,2,2,2,2,2,2, 2,2,2,6,5,6,6,5)\n\t\tD16(11, 0,0,2,2,2,2,2,2, 2,2,2,6,5,6,6,5)\n        D16(12, 0,0,2,2,2,2,2,2, 2,2,2,2,6,5,5,0)\n        D16(13, 0,7,7,2,2,2,2,2, 2,2,2,2,2,6,0,0)\n        D16(14, 0,0,0,7,7,7,7,0, 0,7,7,7,0,0,0,0)\n\t\tD16(15, 0,0,0,0,0,0,0,7, 7,7,7,7,7,0,0,0)\n    }\n    else if(n == 7)\n    {\n        // monster 2\n        palette = 1;\n        D16( 0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0)\n        D16( 1, 0,0,0,1,1,1,1,1, 1,1,1,1,1,0,0,0)\n        D16( 2, 0,0,1,1,3,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 3, 0,0,1,3,1,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 4, 0,0,1,3,1,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 5, 0,0,1,1,1,1,1,1, 1,1,5,5,1,1,0,0)\n        D16( 6, 0,0,1,1,1,1,1,1, 1,5,6,6,5,0,0,0)\n        D16( 7, 0,0,1,4,1,4,1,1, 1,5,6,6,5,0,0,0)\n        D16( 8, 0,0,1,4,1,4,1,1, 1,6,5,5,5,5,5,0)\n        D16( 9, 0,0,1,4,1,4,1,1, 1,1,1,1,5,6,6,5)\n        D16(10, 0,0,1,1,1,1,1,2, 2,2,2,2,5,6,6,5)\n        D16(11, 0,2,2,2,2,2,2,2, 2,2,2,2,6,5,5,6)\n        D16(12, 0,2,2,2,2,2,2,2, 2,2,2,7,7,6,6,0)\n        D16(13, 0,0,2,2,2,2,2,2, 2,7,7,7,7,7,0,0)\n        D16(14, 0,0,0,0,7,7,7,0, 0,7,7,7,0,0,0,0)\n        D16(15, 0,0,7,7,7,7,7,7, 0,0,0,0,0,0,0,0)   \n    }\n    else if(n == 8)\n    {\n        // monster 3\n        palette = 1;\n        D16( 0, 0,0,0,0,1,1,1,1, 1,1,0,0,0,0,0,0)\n        D16( 1, 0,0,0,1,1,3,1,1, 1,1,1,1,1,0,0,0)\n        D16( 2, 0,0,1,1,3,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 3, 0,0,1,1,1,1,1,1, 1,1,1,1,1,1,0,0)\n        D16( 4, 0,0,1,4,1,4,1,1, 1,1,1,1,1,1,0,0)\n        D16( 5, 0,0,1,4,1,4,1,1, 1,1,1,1,1,1,0,0)\n        D16( 6, 0,0,1,4,1,4,1,1, 1,1,5,5,1,5,5,0)\n        D16( 7, 0,0,1,1,1,1,1,1, 1,5,6,6,5,6,6,5)\n        D16( 8, 0,0,4,4,4,4,4,4, 1,5,6,6,5,6,6,5)\n        D16( 9, 0,0,0,4,4,4,4,4, 4,4,5,5,6,5,5,0)\n        D16(10, 0,2,2,2,2,2,2,2, 2,2,6,6,2,6,0,0)\n        D16(11, 0,2,2,2,2,2,2,2, 2,2,2,2,2,2,0,0)\n        D16(12, 7,7,7,7,2,2,2,2, 2,2,2,2,2,2,0,0)\n        D16(13, 0,7,7,7,7,2,2,2, 2,2,2,2,2,0,0,0)\n        D16(14, 0,0,7,7,7,7,0,0, 7,7,7,0,0,0,0,0)\n        D16(15, 0,0,0,0,0,0,7,7, 7,7,7,7,0,0,0,0)        \n    }\n    else if(n == 9)\n    {\n        // banana?\n        palette = 2;\n        D16( 0, 0,0,0,0,0,0,0,0, 0,0,0,3,3,0,0,0)\n        D16( 1, 0,0,0,0,0,0,0,0, 0,0,0,1,2,3,0,0)\n        D16( 2, 0,0,0,0,0,0,0,0, 0,0,0,1,1,1,3,0)\n        D16( 3, 0,0,0,0,0,0,0,0, 0,5,3,1,1,1,1,1)\n        D16( 4, 0,0,0,0,0,0,0,5, 5,3,3,3,1,1,0,0)\n        D16( 5, 5,5,5,5,5,5,5,3, 3,2,3,3,1,1,1,0)\n        D16( 6, 5,3,3,3,3,3,2,2, 2,3,3,1,3,1,1,0)\n        D16( 7, 0,2,2,2,2,2,2,3, 3,3,1,3,3,2,1,0)\n        D16( 8, 0,0,0,2,2,3,3,3, 3,1,3,3,3,2,1,0)\n        D16( 9, 5,5,5,5,5,3,3,2, 1,3,3,3,2,2,1,0)\n        D16(10, 1,5,5,3,2,2,1,1, 3,3,3,2,2,1,0,0)\n        D16(11, 0,1,1,1,1,2,3,3, 3,3,2,2,1,1,0,0)\n        D16(12, 0,0,5,5,5,5,3,3, 2,2,2,1,1,0,0,0)\n        D16(13, 0,5,5,5,5,3,2,2, 2,1,1,1,0,0,0,0)\n        D16(14, 0,0,1,1,1,1,1,1, 1,1,1,0,0,0,0,0)\n        D16(15, 0,0,0,0,1,1,1,1, 1,0,0,0,0,0,0,0)\n    }\n    else if(n == 10)\n    {\n        palette = 2;\n        D16( 0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0)\n        D16( 1, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0)\n        D16( 2, 0,0,0,0,0,0,0,0, 0,0,0,3,2,0,0,0)\n        D16( 3, 0,0,0,0,0,0,1,2, 2,2,2,3,4,2,0,0)\n        D16( 4, 0,0,0,0,1,2,2,3, 3,3,3,3,3,2,0,0)\n        D16( 5, 0,0,0,1,2,3,3,6, 6,3,3,2,2,2,0,0)\n        D16( 6, 0,0,0,2,3,3,3,6, 6,3,3,3,2,2,0,0)\n        D16( 7, 0,0,1,3,3,6,3,3, 3,3,3,3,3,2,0,0)\n        D16( 8, 0,0,2,3,3,3,3,3, 3,3,3,3,3,2,0,0)\n        D16( 9, 0,0,2,3,3,3,3,3, 3,3,3,3,3,2,0,0)\n        D16(10, 0,0,2,3,3,3,3,3, 3,3,3,3,2,2,0,0)\n        D16(11, 0,0,3,3,3,3,3,3, 3,3,3,3,2,2,0,0)\n        D16(12, 0,2,3,3,3,3,3,3, 3,3,3,2,2,0,0,0)\n        D16(13, 0,2,3,2,3,3,3,3, 3,3,2,2,2,0,0,0)\n        D16(14, 0,0,2,2,2,2,2,2, 2,2,2,2,0,0,0,0)\n        D16(15, 0,0,0,0,2,2,2,2, 2,2,0,0,0,0,0,0)\n    }\n    else if(n == 11)\n    {\n        palette = 2;\n        D16( 0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,4,4)\n        D16( 1, 0,0,0,0,0,0,0,0, 0,0,5,5,5,0,4,0)\n        D16( 2, 0,0,0,0,0,0,0,0, 0,5,5,5,4,4,0,0)\n        D16( 3, 0,0,0,0,0,0,0,0, 4,5,6,5,5,4,4,0)\n        D16( 4, 0,0,0,0,0,0,4,4, 4,5,5,5,5,4,4,0)\n        D16( 5, 0,0,0,4,4,4,4,4, 5,5,5,5,5,4,4,0)\n        D16( 6, 0,0,4,4,4,5,5,5, 5,5,5,5,5,4,4,0)\n        D16( 7, 0,4,4,4,4,6,6,4, 5,5,5,5,4,4,4,0)\n        D16( 8, 0,4,4,5,5,6,6,5, 5,4,5,5,4,4,0,0)\n        D16( 9, 4,4,4,5,5,4,5,5, 5,5,5,4,4,4,0,0)\n        D16(10, 4,4,5,4,5,5,5,4, 5,5,5,4,4,4,0,0)\n        D16(11, 4,4,5,5,5,5,5,5, 5,5,4,4,4,0,0,0)\n        D16(12, 4,4,4,5,4,5,5,5, 4,5,4,4,4,0,0,0)\n        D16(13, 0,4,4,4,5,5,4,5, 0,4,4,4,4,0,0,0)\n        D16(14, 0,4,4,4,4,4,4,4, 4,4,4,4,0,0,0,0)\n        D16(15, 0,0,4,4,4,4,4,4, 4,4,4,0,0,0,0,0)\n    }\n    \n    int shift = x < 8 ? 3*x : 3*x-24;\n    float v = x < 8 ? v0 : v1;\n    float idx = floor(fract(v*exp2(float(-shift))) * 8.0);\n    if(palette == 0)\n    {\n        color = (idx == 1.0) ? vec3(224,128, 64)/255.0 : color;\n        color = (idx == 2.0) ? vec3( 96,224, 64)/255.0 : color;\n        color = (idx == 3.0) ? vec3(255,255,255)/255.0 : color;\n        color = (idx == 4.0) ? vec3(  0,  0,  0)/255.0 : color;\n    }\n    else if(palette == 1)\n    {\n        color = (idx == 1.0) ? vec3(170,170,221)/255.0 : color;\n        color = (idx == 2.0) ? vec3(136,136,187)/255.0 : color;\n        color = (idx == 3.0) ? vec3(255,255,255)/255.0 : color;\n        color = (idx == 4.0) ? vec3(  0,  0,  0)/255.0 : color;\n        color = (idx == 5.0) ? vec3(  0,153,255)/255.0 : color;\n        color = (idx == 6.0) ? vec3(136,  0,255)/255.0 : color;\n        color = (idx == 7.0) ? vec3(255,  0,119)/255.0 : color;\n    }\n    else if(palette == 2)\n    {\n        color = (idx == 1.0) ? vec3(255,136,  0)/255.0 : color;\n        color = (idx == 2.0) ? vec3(255,187,  0)/255.0 : color;\n        color = (idx == 3.0) ? vec3(204,255,  0)/255.0 : color;\n        color = (idx == 4.0) ? vec3(  0,187,  0)/255.0 : color;\n        color = (idx == 5.0) ? vec3(  0,255,  0)/255.0 : color;\n        color = (idx == 6.0) ? vec3(255,255,255)/255.0 : color;\n\n    }\n    \n    return color;\n}\n\nvec2 Flow(int x, int y, int level)\n{\n    if(x < 0) return vec2(1,0);\n    if(x >= LEVEL_WIDTH) return vec2(-1,0);\n    if(y < 0) return vec2(0,1);\n    if(y >= LEVEL_HEIGHT - 2) return vec2(0,-1);\n    \n    level = ModLevel(level);\n    \n    float xsign = sign(float(14 - x));\n    \n    //if(level == 1 || level == 2)\n    {\n        if(y > 21) return vec2(xsign, 0);\n    }\n    \n    return vec2(0,1);\n}\n\n#define S4(_c0, _c1, _c2, _c3) { v = (current++ == b) ? (float(_c0)*0.015625 + float(_c1)*1.0 + float(_c2)*64.0 + float(_c3)*4096.0) : v; }\nint String(int str, int x)\n{\n    int b = x / 4;\n    int bi = x - b*4;\n    int current = 0;\n    float v = float(_SPACE)*4161.015625;\n    if(str == STR_GAME_OVER)\n    {\n        S4(_G, _A, _M, _E)\n        S4(_SPACE, _O, _V, _E)\n        S4(_R, _SPACE, _SPACE, _SPACE)\n    }\n    else if(str == STR_BEGINNING0)\n    {\n        S4(_N, _O, _W, _SPACE)\n        S4(_I, _T, _SPACE, _I)\n        S4(_S, _SPACE, _T, _H)\n        S4(_E, _SPACE, _B, _E)\n        S4(_G, _I, _N, _N)\n        S4(_I, _N, _G, _SPACE)\n        S4(_O, _F, _SPACE, _SPACE)\n    } else if(str == STR_BEGINNING1)\n    {\n        S4(_A, _SPACE, _F, _A)\n        S4(_N, _T, _A, _S)\n        S4(_T, _I, _C, _SPACE)\n        S4(_S, _T, _O, _R)\n        S4(_Y, _EXCLAMATION, _SPACE, _L)\n        S4(_E, _T, _SPACE, _U)\n        S4(_S, _SPACE, _SPACE, _SPACE)\n    }\n    else if(str == STR_BEGINNING2)\n    {\n        S4(_M, _A, _K, _E)\n        S4(_SPACE, _A, _SPACE, _J)\n        S4(_O, _U, _R, _N)\n        S4(_E, _Y, _SPACE, _T)\n        S4(_O, _SPACE, _SPACE, _SPACE)\n    }\n    else if(str == STR_BEGINNING3)\n    {\n        S4(_T, _H, _E, _SPACE)\n        S4(_C, _A, _V, _E)\n        S4(_SPACE, _O, _F, _SPACE)\n        S4(_M, _O, _N, _S)\n        S4(_T, _E, _R, _S)\n        S4(_EXCLAMATION, _SPACE, _SPACE, _SPACE)\n    }\n    else if(str == STR_BEGINNING4)\n    {\n        S4(_G, _O, _O, _D)\n        S4(_SPACE, _L, _U, _C)\n        S4(_K, _EXCLAMATION, _SPACE, _SPACE)\n    }\n    else if(str == STR_PUSH_START)\n    {\n        S4(_P, _U, _S, _H)\n        S4(_SPACE, _S, _T, _A)\n        S4(_R, _T, _SPACE, _SPACE)\n    }\n    else if(str == STR_1UP)\n    {\n        S4(1, _U, _P, _SPACE)\n    }\n    else if(str == STR_HIGH_SCORE)\n    {\n        S4(_H, _I, _G, _H)\n        S4(_SPACE, _S, _C, _O)\n        S4(_R, _E, _SPACE, _SPACE)\n    }\n    else if(str == STR_00)\n    {\n        S4(0, 0, _SPACE, _SPACE)\n    }\n    else if(str == STR_INSERT)\n    {\n        S4(_I, _N, _S, _E)\n        S4(_R, _T, _SPACE, _SPACE)\n    }\n    else if(str == STR_COIN)\n    {\n        S4(_C, _O, _I, _N)\n    }\n    else if(str == STR_TO)\n    {\n        S4(_T, _O, _SPACE, _SPACE)\n    }\n    else if(str == STR_CONTINUE)\n    {\n        S4(_C, _O, _N, _T)\n        S4(_I, _N, _U, _E)\n    }\n    else if(str == STR_COPYRIGHT)\n    {\n        S4(_COPYRIGHT, _SPACE, _M, _E)\n        S4(_N,_T,_O,_R)\n        S4(_SPACE,_C,_O,_R)\n        S4(_P,_O,_R,_A)\n        S4(_T,_I,_O,_N)\n        S4(_SPACE,1,9,8)\n        S4(6,_SPACE,_SPACE,_SPACE)\n    }\n    else if(str == STR_ALL_RIGHTS)\n    {\n        S4(_A,_L,_L,_SPACE)\n        S4(_R,_I,_G,_H)\n        S4(_T,_S,_SPACE,_R)\n        S4(_E,_S,_E,_R)\n        S4(_V,_E,_D,_SPACE)\n    }\n    else if(str == STR_INSERT_COIN)\n    {\n        S4(_I, _N, _S, _E)\n        S4(_R, _T, _SPACE, _C)\n        S4(_O, _I, _N, _SPACE)\n    }\n       \n    return int(fract(v * exp2(-float(bi*6)))*64.0);\n}\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue(vec2 re)\n{\n    return texture( iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue(vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord)\n{\n    fragColor = (isInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int x = int(fragCoord.x);\n    int y = int(fragCoord.y);\n\n    fragColor = texture( iChannel0, fragCoord / iChannelResolution[0].xy, -100.0 );\n    vec4 staticDataInited = loadValue(txStaticDataInited);\n    if(staticDataInited.x == 0.0)\n    {\n        fragColor = vec4(0);\n        if(y >= FONT_START_Y && y < FONT_START_Y + FONT_HEIGHT)\n        {\n            fragColor = Font(x - x/FONT_WIDTH*FONT_WIDTH, y - FONT_START_Y, x/FONT_WIDTH) ? vec4(1) : vec4(0);\n        }\n        \n        if(y >= LEVEL_START_Y && y < LEVEL_START_Y + LEVEL_HEIGHT)\n        {\n            fragColor = Level(x - x/LEVEL_WIDTH*LEVEL_WIDTH, y - LEVEL_START_Y, x/LEVEL_WIDTH) ? vec4(1) : vec4(0);\n        }\n        \n        if(y >= SPRITE_START_Y && y < SPRITE_START_Y + SPRITE_HEIGHT)\n        {\n            fragColor = vec4(Sprite(x - x/SPRITE_WIDTH*SPRITE_WIDTH, y - SPRITE_START_Y, x/SPRITE_WIDTH), 1.0);\n        }\n        if(y >= STRINGS_START_Y && y < STRINGS_START_Y + NUM_STRINGS*FONT_HEIGHT)\n        {\n            int str = (y - STRINGS_START_Y) / FONT_HEIGHT;\n            int c = String(str, x / FONT_WIDTH);\n            int lx = x - x/FONT_WIDTH*FONT_WIDTH;\n            int ly = (y - STRINGS_START_Y) - str*FONT_HEIGHT;\n            fragColor = Font(lx, ly, c) ? vec4(1) : vec4(0);\n        }\n        if(y >= LOGO_START_Y && y < LOGO_START_Y + LOGO_HEIGHT)\n        {\n            fragColor.xyz = Logo(x, y - LOGO_START_Y);\n        }\n        \n        staticDataInited.x = 1.0;\n\t}\n    else\n    {\n        if(y >= NUM_DYNAMIC_ROWS)\n        {\n            return;\n        }\n    }\n\n    if(y == 0 && x >= 16) discard;\n    if(((y == ENTITIES_START_Y) || (y == ENTITIES_START_Y + 1)) && x >= MAX_ENTITIES) discard;\n    \n    // load state\n    vec4 gameState = loadValue(txGameState);\n    vec4 gameState2 = loadValue(txGameState2);\n    vec4 gameState3 = loadValue(txGameState3);\n    vec4 playerPos = loadValue(txPlayerPos);\n    vec4 playerSprite = loadValue(txPlayerSprite);\n    \n    vec4 playerVel = loadValue(txPlayerVel);\n    vec4 playerFlags = loadValue(txPlayerFlags);\n    vec4 keyWasDown = loadValue(txKeyWasDown);\n    vec4 cooldown = loadValue(txCoolDown);\n    \n    float moveRight = texture( iChannel1, vec2(KEY_RIGHT, 0.25) ).x;\n    float moveLeft  = texture( iChannel1, vec2(KEY_LEFT,  0.25) ).x;\n    float moveUp    = texture( iChannel1, vec2(KEY_UP,    0.25) ).x;\n    float keySpace\t= texture( iChannel1, vec2(KEY_SPACE, 0.0) ).x;\n    \n    float time = iTime - gameState2.w;\n    \n    \n    if(gameState.x == 0.0)\n    {\n        // init\n        playerPos = vec4(0,8,0,0);\n        playerSprite = vec4(1,0,0,0);\n        playerVel = vec4(0);\n        playerFlags = vec4(0);\n        gameState = vec4((SKIP_INTRO == 0) ? 1.0 : 5.0, float(0.0), 0.0, 2.0);   //state, level, score, lives\n        //gameState2 = vec4(0,0,0,0);\t\t//old_player_x, old_player_x, frame_counter, globaltime offset\n        gameState2.xyz = vec3(0,0,0);\n        gameState3 = vec4(0);\t//win_counter\n        \n        if(y == ENTITIES_START_Y || y == ENTITIES_START_Y + 1)\n        {\n            fragColor = vec4(-1);\t\t//(x, y, time, type)\n            //monster:\n            //(x, y, time, type), (direction, target_height, y_velocity, had_floor_contact)\n            //bubble:\n            //(x, y, time, type), (direction, monster, pop_from_timeout, ?)\n        }\n        \n    }\n    else if(gameState.x == 1.0)\n    {\n        if(time > 7.0)\n            gameState.x = 2.0;\n    }\n    else if(gameState.x == 2.0)\n    {\n        if(time > 9.6)\n        {\n            gameState.x = 3.0;\n            gameState2.z = 0.0;\n            \n            float angle = time*2.5;\n        \tplayerPos.xy = vec2(40,120) + vec2(cos(angle)*30.0,sin(angle)*20.0);\t//hack: avoid pop\n        }\n    }\n    else if(gameState.x == 3.0)\n    {\n        // now is the beginning...\n        float angle = time*2.5;\n        playerPos.xy = vec2(40,120) + vec2(cos(angle)*30.0,sin(angle)*20.0);\n        \n        if(time > 18.36)\n        {\n            gameState.x = 4.0;\n            \n            gameState.y += 1.0;\t//hack: avoid pop\n            gameState2.xy = playerPos.xy;\n            playerPos = vec4(0,8,0,0);\n            playerSprite = vec4(1,0,0,0);\n            playerVel = vec4(0);\n            playerFlags = vec4(0);\n        }\n    }\n    else if(gameState.x == 4.0)\n    {\n        if(gameState2.z == 0.0)\n        {\n            if(y == ENTITIES_START_Y || y == ENTITIES_START_Y + 1)\n            {\n                fragColor = vec4(-100,-100,-1,-1e5);\n            }\n            \n            // init level\n            /*\n            gameState2.xy = playerPos.xy;\n            playerPos = vec4(0,8,0,0);\n            playerSprite = vec4(1,0,0,0);\n            playerVel = vec4(0);\n            playerFlags = vec4(0);\n            */\n            int modLevel = ModLevel(int(gameState.y));\n         \n            if(modLevel == 1)\n            {\n                if(y == ENTITIES_START_Y)\n                {\n                    if(x == 0) fragColor = vec4(14*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 1) fragColor = vec4(14*8, LEVEL_HEIGHT*8+16, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 2) fragColor = vec4(14*8, LEVEL_HEIGHT*8+32, 0, ENTITY_TYPE_MONSTER);\n                }\n                \n                if(y == ENTITIES_START_Y + 1)\n                {\n                    if(x == 0) fragColor = vec4(-1, 16*8, -1, -1);\n                    if(x == 1) fragColor = vec4(-1, 18*8, -1, -1);\n                    if(x == 2) fragColor = vec4(-1, 20*8, -1, -1);\n                }\n            }\n            else if(modLevel == 2)\n            {\n                if(y == ENTITIES_START_Y)\n                {\n                    if(x == 0) fragColor = vec4(10*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 1) fragColor = vec4(12*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 2) fragColor = vec4(14*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 3) fragColor = vec4(16*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                }\n                \n                if(y == ENTITIES_START_Y + 1)\n                {\n                    if(x == 0) fragColor = vec4(-1, 16*8, -1, -1);\n                    if(x == 1) fragColor = vec4(-1, 21*8, -1, -1);\n                    if(x == 2) fragColor = vec4( 1, 21*8, -1, -1);\n                    if(x == 3) fragColor = vec4( 1, 16*8, -1, -1);\n                }\n            }\n            else if(modLevel == 3)\n            {\n                if(y == ENTITIES_START_Y)\n                {\n                    if(x == 0) fragColor = vec4(4*8, LEVEL_HEIGHT*8,  0, ENTITY_TYPE_MONSTER);\n                    if(x == 1) fragColor = vec4(8*8, LEVEL_HEIGHT*8,  0, ENTITY_TYPE_MONSTER);\n                    if(x == 2) fragColor = vec4(18*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 3) fragColor = vec4(22*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                }\n                \n                if(y == ENTITIES_START_Y + 1)\n                {\n                    if(x == 0) fragColor = vec4( 1, 16*8, -1, -1);\n                    if(x == 1) fragColor = vec4( 1, 21*8, -1, -1);\n                    if(x == 2) fragColor = vec4(-1, 21*8, -1, -1);\n                    if(x == 3) fragColor = vec4(-1, 16*8, -1, -1);\n                }\n            }\n            else if(modLevel == 4)\n            {\n                if(y == ENTITIES_START_Y)\n                {\n                    if(x == 0) fragColor = vec4(4*8, LEVEL_HEIGHT*8,  0, ENTITY_TYPE_MONSTER);\n                    if(x == 1) fragColor = vec4(6*8, LEVEL_HEIGHT*8,  0, ENTITY_TYPE_MONSTER);\n                    if(x == 2) fragColor = vec4(8*8, LEVEL_HEIGHT*8,  0, ENTITY_TYPE_MONSTER);\n                    if(x == 3) fragColor = vec4(18*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 4) fragColor = vec4(20*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                    if(x == 5) fragColor = vec4(22*8, LEVEL_HEIGHT*8, 0, ENTITY_TYPE_MONSTER);\n                }\n                \n                if(y == ENTITIES_START_Y + 1)\n                {\n                    if(x == 0) fragColor = vec4( 1, 20*8, -1, -1);\n                    if(x == 1) fragColor = vec4( 1, 16*8, -1, -1);\n                    if(x == 2) fragColor = vec4( 1,  8*8, -1, -1);\n                    if(x == 3) fragColor = vec4(-1,  8*8, -1, -1);\n                    if(x == 4) fragColor = vec4(-1, 16*8, -1, -1);\n                    if(x == 5) fragColor = vec4(-1, 20*8, -1, -1);\n                }\n            }\n\n        }\n        \n        gameState2.z++;\n        if(gameState2.z > float(NUM_PLACE_PLAYER_FRAMES))\n        {\n            gameState.x = 5.0;\n            gameState2.z = 0.0;\n        }\n    }\n    else if(gameState.x == 5.0)\n    {\n        gameState2.z++;\n\n        \n        // player\n        playerVel.y = max(playerVel.y - GRAVITY, -TERMINAL_VELOCITY);\n\n        float oldPlayerPosX = playerPos.x;\n        if(playerFlags.y >= 0.0)\n        {\n            // alive\n            \n            if(moveUp > 0.0 && playerFlags.x == 1.0)\t//only allow jump if we had ground collision last frame\n            {\n                //playerFlags.x = 1.0;\n                playerVel.y += JUMP_VELOCITY;\n            }\n\n            playerPos.x += MOVEMENT_SPEED * (moveRight - moveLeft);\n            playerSprite.y = (moveRight > 0.0 ^^ moveLeft > 0.0) ? float(moveLeft) : playerSprite.y;\n            \n            playerFlags.y += 1.0;\n        }\n        else\n        {\n            playerFlags.y -= 1.0;\n        }\n        \n        playerPos.xy += playerVel.xy;\n        \n        {\n            float deltaX = playerPos.x - oldPlayerPosX;\n            if(deltaX > 0.0)\n            {\n                int bx = int(playerPos.x/8.0+2.0);\n            \tbool wallCollision = Collision(bx, int(playerPos.y/8.0+0.5), int(gameState.y)) &&\n                \t\t\t\t\tCollision(bx, int(playerPos.y/8.0+1.5), int(gameState.y));\n            \tif(wallCollision) playerPos.x = float(bx)*8.0-16.0;\n            }\n            else\n            {\n                int bx = int(floor(playerPos.x/8.0));\n                bool wallCollision = Collision(bx, int(playerPos.y/8.0+0.5), int(gameState.y)) &&\n                    \t\t\t\tCollision(bx, int(playerPos.y/8.0+1.5), int(gameState.y));\n                if(wallCollision) playerPos.x = float(bx)*8.0+8.0;\n            }            \n        }\n        \n        \n        if(playerPos.y < -16.0) playerPos.y = float(LEVEL_HEIGHT)*8.0;\t// wrap around y-axis\n        \n        \n        // did I walk into a monster?\n        int firstFreeEntity = 0;\n        for(int i = 0; i < MAX_ENTITIES; i++)\n        {\n            vec4 entity0 = texture( iChannel0, (vec2(i, ENTITIES_START_Y) + 0.5) / iChannelResolution[0].xy, -100.0 );\n            \n            if(entity0.w == ENTITY_TYPE_MONSTER && playerFlags.y >= INVULNERABLE_FRAMES && length(entity0.xy - playerPos.xy) < 10.0)\n            {\n                // death\n                playerFlags.y = -1.0;\n                gameState.w -= 1.0;\n            }\n            \n            if(entity0.w < 0.0 && firstFreeEntity == 0)\n            {\n                firstFreeEntity = i;\n            }\n        }\n        \n        // respawn?\n        if(playerFlags.y < -RESPAWN_FRAMES)\n        {\n            if(gameState.w >= 0.0)\n            {\n                playerFlags.y = 0.0;\n                playerPos = vec4(0,8,0,0);\n                playerSprite = vec4(1,0,0,0);\n                playerVel = vec4(0);\n            }\n            else\n            {\n                gameState.x = 6.0;\t//game over!\n            }\n        }\n        \n        \n        bool didFire = (keySpace != 0.0 && keyWasDown.x == 0.0 && cooldown.x <= 0.0 && playerFlags.y >= 0.0);\n        if(didFire)\n        {\n            cooldown.x = BUBBLE_COOLDOWN;\n        }\n        \n        if(playerFlags.y >= 0.0)\n        \tplayerSprite.x = float(cooldown.x > 5.0) + 1.0;\n        else\n            playerSprite.x = 3.0; \n        \n        bool floorCollision = Collision(int(playerPos.x/8.0+.5), int(playerPos.y/8.0), int(gameState.y)) || Collision(int(playerPos.x/8.0+.5)+1, int(playerPos.y/8.0), int(gameState.y));\n        playerFlags.x = 0.0;\n        if(playerVel.y <= 0.0 && floorCollision)\n        {\n            float new_y = (floor(playerPos.y/8.0)+1.0)*8.0;\n            if(new_y <= playerPos.y + 2.0)\t//ignore if it moves us up too much\n            {\n                playerPos.y = new_y;\n                playerVel.y = 0.0;\n                playerFlags.x = 1.0;\n            }\n        }\n\n        \n        // entity update\n        if((y == ENTITIES_START_Y || y == ENTITIES_START_Y + 1) && x < MAX_ENTITIES)\n        {\n            vec4 entity0 = texture( iChannel0, (vec2(x, ENTITIES_START_Y + 0) + 0.5) / iChannelResolution[0].xy, -100.0 );\n            vec4 entity1 = texture( iChannel0, (vec2(x, ENTITIES_START_Y + 1) + 0.5) / iChannelResolution[0].xy, -100.0 );\n            \n            \n            if(entity0.w == ENTITY_TYPE_BUBBLE)\t// bubble update\n            {\n                entity1.w = 0.0;\t// clear points\n                \n                bool turnToMonster = false;\n                bool turnToTumbling = false;\n                \n                vec2 pushVector = vec2(0);\n            \tfor(int i = 0; i < MAX_ENTITIES; i++)\n            \t{\n                \tvec4 otherEntity0 = texture( iChannel0, (vec2(i, ENTITIES_START_Y + 0) + 0.5) / iChannelResolution[0].xy, -100.0 );\n                    vec4 otherEntity1 = texture( iChannel0, (vec2(i, ENTITIES_START_Y + 1) + 0.5) / iChannelResolution[0].xy, -100.0 );\n                \n                    if(entity0.z >= 0.0 && otherEntity0.w == ENTITY_TYPE_BUBBLE)\n                    {\n                        vec2 delta = entity0.xy - otherEntity0.xy;\n                        float dist = length(delta);\n                        if(otherEntity0.z >= 0.0)\n                        {\n                            if(length(delta) > 0.01) pushVector += normalize(delta) * max(0., 13.0 - dist);\n                        }\n                        else if(otherEntity0.z >= -2.0 && otherEntity1.z == 0.0 && dist < 15.0)\t//neighbor died very recently\n                        {\n                            entity0.z = -1.0;\n                            entity1.z =  0.0;\t// not timeout\n                            entity1.w = (entity1.y > 0.0) ? 1000.0 : 10.0;\t// points\n                           \tturnToTumbling = (entity1.y > 0.0);\n                        }\n                    }\n            \t}\n                \n                if(entity0.z >= 0.0)\n                {\n                    if(entity0.z < BUBBLE_ATTACK_FRAMES && entity1.y <= 0.0 && gameState2.z >= MONSTER_FREE_FRAME)\n                    {\n                        for(int j = 0; j < MAX_ENTITIES; j++)\n                        {\n                            vec4 otherEntity0 = texture( iChannel0, (vec2(j, ENTITIES_START_Y + 0) + 0.5) / iChannelResolution[0].xy, -100.0 );\n                            if(otherEntity0.w == ENTITY_TYPE_MONSTER)\n                            {\n                                vec2 delta = entity0.xy - (otherEntity0.xy + vec2(8,8));\n                                if(dot(delta, delta) < MONSTER_HIT_DIST_SQ)\n                                {\n                                    entity1.y = 1.0;\t// caught a monster!\n                                }\n                            }\n                        }\n                    }\n                    \n                    vec2 delta = entity0.xy - (playerPos.xy + vec2(8,8));\n                    float penetration = max(0.,16. - length(delta));\n                    if(length(delta) > .01) pushVector += normalize(delta) * penetration;\n\n                    if(entity0.z < BUBBLE_ATTACK_FRAMES)\n                        entity0.x += entity1.x * exp2(-BUBBLE_ATTACK_EXP_SCALE * entity0.z) / BUBBLE_ATTACK_EXP_SCALE;\n                    else\n                        entity0.xy += Flow(int(entity0.x/8.0), int(entity0.y/8.0), int(gameState.y)) * BUBBLE_FLOW_POWER;\n                    entity0.xy += pushVector*PUSH_VECTOR_SCALE;\n                    entity0.x = clamp(entity0.x, 8., float(LEVEL_WIDTH)*8.-8.);\n                    entity0.z += 1.0;\n                    if(entity0.z >= BUBBLE_LIFE_FRAMES)\n                    {\n                        entity0.z = -1.0;\n                        entity1.z =  1.0;\t// timeout\n                        entity1.w =  0.0;\t// 0 points\n                        turnToMonster = (entity1.y > 0.0);\n                    }\n                    else if(entity0.z > 10.0 && penetration > BUBBLE_POP_THRESHOLD)\n                    {\n                        entity0.z = -1.0;\t// popped by player\n                        entity1.z =  0.0;\t// not timeout\n                        entity1.w = (entity1.y > 0.0) ? 1000.0 : 10.0;\t// points\n                        turnToTumbling = (entity1.y > 0.0);\n                    }   \n                }\n                else\n                {\n                    entity0.z -= 1.0;\n                }\n              \n                if(entity0.z < -BUBBLE_DEATH_FRAMES)\n                {\n                    entity0.w = -1.0;\n                }\n                \n                if(turnToMonster)\n                {\n                    entity0.z = 0.0;\n                    entity0.w = ENTITY_TYPE_MONSTER;\n                    entity1 = vec4(1, 0, -1, -1);\n                }\n                \n                if(turnToTumbling)\n                {\n                    entity0.z = 0.0;\n                    entity0.w = ENTITY_TYPE_TUMBLING_MONSTER;\n                    entity1 = vec4(-1, -1, -1, 1000.0);\n                    entity1.x = (hash11(iTime + float(x)*100.0)*2.0-1.0)*3.0;\n                    entity1.y = 3.5;\n                }\n                \n            }\n            else if(entity0.w == ENTITY_TYPE_MONSTER)\t// monster update\n            {\n                // alive                \n                if(gameState2.z < MONSTER_FREE_FRAME)\n                {\n                    //move monsters down to starting location\n                    if(entity0.y > entity1.y)\n                    {\n                        entity0.y = max(entity0.y - 1.5, entity1.y);\n                    }\n                }\n                else\n                {\n                    // was monster hit by bubble?\n                    for(int i = 0; i < MAX_ENTITIES; i++)\n                    {\n                        vec4 otherEntity0 = texture( iChannel0, (vec2(i, ENTITIES_START_Y + 0) + 0.5) / iChannelResolution[0].xy, -100.0 );\n                        vec4 otherEntity1 = texture( iChannel0, (vec2(i, ENTITIES_START_Y + 1) + 0.5) / iChannelResolution[0].xy, -100.0 );\n                        if(otherEntity0.w == ENTITY_TYPE_BUBBLE && otherEntity0.z >= 0.0 && otherEntity0.z < BUBBLE_ATTACK_FRAMES && otherEntity1.y <= 0.0)\n                        {\n                            vec2 delta = otherEntity0.xy - (entity0.xy + vec2(8,8));\n                            if(dot(delta, delta) < MONSTER_HIT_DIST_SQ)\n                            {\n                                entity0.w = -1.0;\n                            }\n                        }\n                    }\n                    \n                    entity1.z = max(entity1.z - GRAVITY, -TERMINAL_VELOCITY);\n                    \n                    \n                    entity0.y += entity1.z;\n                    bool floorCollision = Collision(int(entity0.x/8.0+.5), int(entity0.y/8.0), int(gameState.y)) || Collision(int(entity0.x/8.0+.5)+1, int(entity0.y/8.0), int(gameState.y));\n                    \n                    bool ceilingCollision = false;\n                    for(int i = 2; i <= 5; i++)\n                    {\n                        ceilingCollision = ceilingCollision || Collision(int(entity0.x/8.0+1.0), int(entity0.y/8.0+float(i)), int(gameState.y));\n                    }\n                    \n                    if(entity1.w > 0.0)\n                    {\n                        //we can jump, but should we?\n                        if(playerPos.y > entity0.y + 8.0 && ceilingCollision && hash11(time+float(x)*200.0)>0.98)\n                        {\n                             // yes!\n                            entity1.z += JUMP_VELOCITY;\n                            entity1.w = 0.0;\n                        }\n                    }\n                    \n                    entity1.w = 0.0;\n                    if(entity1.z <= 0.0 && floorCollision)\n                    {\n                        float new_y = (floor(entity0.y/8.0)+1.0)*8.0;\n                        if(new_y <= entity0.y + 2.0)\t//ignore if it moves us up too much\n                        {\n                            entity0.y = new_y;\n                            entity1.z = 0.0;\n                            entity1.w = 1.0;\n                        }\n                        entity0.x += entity1.x;\n                        \n                        float xpos = entity0.x/8.0 + ((entity1.x < 0.0) ? -1.0 : 2.0);\n                        bool wallCollision = Collision(int(xpos), int(entity0.y/8.0+.5), int(gameState.y));\n                        if(wallCollision)\n                        {\n                            entity0.x -= entity1.x;\n                            entity1.x *= -1.0;\n                        }\n                    }\n                    if(entity0.y < -16.0) entity0.y = float(LEVEL_HEIGHT)*8.0;\t// wrap around y-axis\n                    \n                }\n                entity0.z += 1.0;\n            }\n            else if(entity0.w == ENTITY_TYPE_TUMBLING_MONSTER)\n            {\n                entity1.w = 0.0;\t//clear points\n                \n                entity0.z += 1.0;\n                entity0.xy += entity1.xy;\n                if(entity0.y < -16.0) entity0.y = float(LEVEL_HEIGHT)*8.0;\t// wrap around y-axis\n                \n                entity1.y = max(entity1.y - GRAVITY, -TERMINAL_VELOCITY);\n                \n                if(entity0.x < 0.0)\n                {\n                    entity0.x = 0.0;\n                    entity1.x *= -1.0;\n                }\n                else if(entity0.x >= float(LEVEL_WIDTH-4)*8.0)\n                {\n                    entity0.x = float(LEVEL_WIDTH-4)*8.0;\n                    entity1.x *= -1.0;\n                }\n                entity1.x *= 0.98;\n                \n                if(entity0.z > 180.0)\n                {\n                    bool floorCollision = Collision(int(entity0.x/8.0+.5), int(entity0.y/8.0), int(gameState.y)) || Collision(int(entity0.x/8.0+.5)+1, int(entity0.y/8.0), int(gameState.y));\n    \t\t\t\tif(floorCollision)\n                    {\n                        entity0.y = (floor(entity0.y/8.0)+1.0)*8.0;\n                    \tentity0.z = floor(hash11(iTime + float(x)*100.0)*2.99);\t// icon\n                        entity0.w = ENTITY_TYPE_ITEM;\n                        entity1.w = 1000.0;\t// points\n                    }\n                }   \n            }\n            else if(entity0.w == ENTITY_TYPE_ITEM)\n            {\n                if(length(playerPos.xy - entity0.xy) < 10.0)\n                {\n                    entity0.w = ENTITY_TYPE_SCORE;\n                    entity1.w = 1000.0;\n                }\n            }\n            else if(entity0.w == ENTITY_TYPE_SCORE)\n            {\n                entity1.w = 0.0;\n            }\n            \n            // fire new bubble?\n            if(didFire && x == firstFreeEntity)\n            {\n                if(playerSprite.y > 0.0)\n                {\n                    entity0 = vec4(playerPos.x +  6.0, playerPos.y + 8., 0, ENTITY_TYPE_BUBBLE);\n                    entity1 = vec4(-1, -1, -1, 0);\n                }\n                else\n                {\n                    entity0 = vec4(playerPos.x + 10.0, playerPos.y + 8., 0, ENTITY_TYPE_BUBBLE);\n                    entity1 = vec4( 1, -1, -1, 0);\n                }\n            }\n            \n            fragColor = (y == ENTITIES_START_Y) ? entity0 : entity1;\n        }\n        \n        \n        \n        keyWasDown.x = keySpace;\n        cooldown -= 1.0;\n        \n        bool winCondition = true;//gameState.y > 0.0;\n        if(y == 0)\n        {\n            for(int i = 0; i < MAX_ENTITIES; i++)\n            {\n                vec4 entity0 = texture( iChannel0, (vec2(i, ENTITIES_START_Y + 0) + 0.5) / iChannelResolution[0].xy, -100.0 );\n                vec4 entity1 = texture( iChannel0, (vec2(i, ENTITIES_START_Y + 1) + 0.5) / iChannelResolution[0].xy, -100.0 );\n                if(entity0.w == ENTITY_TYPE_MONSTER || (entity0.w == ENTITY_TYPE_BUBBLE && entity1.y > 0.0))\n                {\n                    winCondition = false;\n                }\n                if(entity0.w == ENTITY_TYPE_BUBBLE || entity0.w == ENTITY_TYPE_SCORE)\n                {\n                    gameState.z += entity1.w;\n                }\n                if(entity0.w == ENTITY_TYPE_TUMBLING_MONSTER)\n                {\n                    gameState.z += entity1.w;\n                    winCondition = false;\n                }\n            }\n        }\n        \n        if(winCondition)\n        {\n            gameState3.x += 1.0;\n            \n            if(gameState3.x >= WIN_DELAY_FRAMES)\n            {\n                gameState.x = 4.0;\t//next level\n                gameState2.z = 0.0;\n                gameState3.x = 0.0;\n                \n                //hack hack to avoid pop when changing level\n                gameState.y++;\n                gameState2.xy = playerPos.xy;\n                playerPos = vec4(0,8,0,0);\n                playerSprite = vec4(1,0,0,0);\n                playerVel = vec4(0);\n                playerFlags = vec4(0);\n            }\n        }\n        \n    } else if(gameState.x == 6.0)\n    {\n        if(keySpace != 0.0)\n        {\n            gameState.x = 0.0;\n            gameState2.w = iTime;\n        }\n    }\n    \n    // store state\n    storeValue(txGameState,     vec4(gameState),    fragColor, fragCoord);\n    storeValue(txGameState2,    vec4(gameState2),   fragColor, fragCoord);\n    storeValue(txGameState3,    vec4(gameState3),   fragColor, fragCoord);\n    storeValue(txPlayerPos,     vec4(playerPos),    fragColor, fragCoord);\n    storeValue(txPlayerSprite,  vec4(playerSprite), fragColor, fragCoord);\n    storeValue(txPlayerVel,     vec4(playerVel),    fragColor, fragCoord);\n    storeValue(txPlayerFlags,   vec4(playerFlags),  fragColor, fragCoord);\n    storeValue(txKeyWasDown,  \tvec4(keyWasDown),\tfragColor, fragCoord);\n    storeValue(txCoolDown,  \tvec4(cooldown),\t\tfragColor, fragCoord);\n    storeValue(txStaticDataInited, vec4(staticDataInited),\tfragColor, fragCoord);\n    \n}\n\n\n//TODO:\n//*d24 font\n//**baseline: ~2s\n//**now: ~1s\n//*move sprites to Buf A\n//**baseline: ~5s\n//**now: ~3s\n//**float hacking for sprites\n//*monster sprite + movement\n//*sprite rotation\n//*life counter\n//*fix pattern 0 length\n//*intro animation: \"now it is the beginning of a fantastic story..\"\n//*hero in bubble\n//*change level animation\n//*game over\n//*game restart\n//-fix state transition glitches!\n//**remove bubbles\n//**clear jump state\n//-monster in bubble: begin: 9:17\n//**monster disappears when hit by attack bubble: 9:26\n//**monster trapped in bubble: 10:55\n//**monsters/items/bubbles are entities! 11:12\n//**release monster\n//**win condition\n//*bug: hit multiple monsters with one bubble!\n//**multipop doesn't work anymore\n//**fall out the bottom...\n//**bug: can walk on top of level\n//**draw monster in bubble\n//*support for multiple tiles\n//*shake bubble when about to pop\n//*bubbles shouldn't pop neighbors when popped by timeout\n//*points for bubbles\n//*monsters use collision\n//**wall collision\n//*collision issues\n//**jump after fall\n//**glide into wall\n//**walk through wall\n//*monster fall\n//*monster jump\n//*better AI\n//*repeat levels!\n//*invulnerable\n//*item pickup\n//**sync music with logo\n//**optimize: performance is crappy now\n//*resolution scaling\n//*more fruit\n//*faster compile\n//*only update 'dynamic' part of texture\n//*level 4\n//*fix transitions\n//*logo\n//*copyright message?\n//-long compile time because of logo\n//-real tiles\n//-bubble effect in intro\n//-dead monster sprite\n//-bug no wall colision on top row\n//-logo AA?\n//-jump animation\n//-fall animation\n//-walk animation\n//-bubbles collide with level?\n//-monster leaping\n//-death animation\n//-player 2\n//-TODO: retrigger notes\n//-note slide\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// shared game state\nconst int LEVEL_WIDTH = 28;\nconst int LEVEL_HEIGHT = 25;\nconst int LEVEL_START_Y = 32;\nconst int NUM_LEVELS = 4;\n\nconst int FONT_START_Y = 8;\nconst int FONT_HEIGHT = 8;\nconst int FONT_WIDTH = 8;\n\nconst int SPRITE_WIDTH = 16;\nconst int SPRITE_HEIGHT = 16;\nconst int SPRITE_START_Y = 16;\n\nconst int ENTITIES_START_Y = 1;\nconst int MAX_ENTITIES = 64;\n\nconst int STRINGS_START_Y = 60;\nconst int STR_GAME_OVER = 0;\nconst int STR_BEGINNING0 = 1;\nconst int STR_BEGINNING1 = 2;\nconst int STR_BEGINNING2 = 3;\nconst int STR_BEGINNING3 = 4;\nconst int STR_BEGINNING4 = 5;\nconst int STR_PUSH_START = 6;\nconst int STR_1UP = 7;\nconst int STR_HIGH_SCORE = 8;\nconst int STR_00 = 9;\nconst int STR_INSERT = 10;\nconst int STR_COIN = 11;\nconst int STR_TO = 12;\nconst int STR_CONTINUE = 13;\nconst int STR_COPYRIGHT = 14;\nconst int STR_ALL_RIGHTS = 15;\nconst int STR_INSERT_COIN = 16;\n\nconst int LOGO_START_Y = 200;\nconst int LOGO_WIDTH = 300;\nconst int LOGO_HEIGHT = 150;\n\n\nconst float ENTITY_TYPE_BUBBLE = 1.0;\nconst float ENTITY_TYPE_MONSTER = 2.0;\nconst float ENTITY_TYPE_TUMBLING_MONSTER = 3.0;\nconst float ENTITY_TYPE_ITEM = 4.0;\n\nconst int MONSTER_SPRITE_START_IDX = 5;\nconst int ITEM_SPRITE_START_IDX = 9;\n\nconst int NUM_PLACE_PLAYER_FRAMES = 120;\nconst float INVULNERABLE_FRAMES = 90.0;\n\nconst float BUBBLE_ATTACK_FRAMES = 20.0;\nconst float BUBBLE_DEATH_FRAMES = 30.0;\nconst float BUBBLE_LIFE_FRAMES = 1200.0;\nconst vec3 BUBBLE_COLOR = vec3(0.25, 1.0, 0.25);\n\nconst float TILE_SIZE = 8.;\nconst float SHADOW_WIDTH = 3.0;\nconst int LEVEL_HEIGHT_MARGIN = 4;\nconst int LEVEL_HEIGHT_IN_PIXELS = int(TILE_SIZE) * (LEVEL_HEIGHT + LEVEL_HEIGHT_MARGIN);\nconst vec2 txGameState = \tvec2(0.0,0.0);\nconst vec2 txGameState2 = \tvec2(1.0,0.0);\nconst vec2 txGameState3 = \tvec2(2.0,0.0);\nconst vec2 txPlayerPos = \tvec2(3.0,0.0);\nconst vec2 txPlayerSprite = vec2(4.0,0.0);\nconst vec2 txPlayerFlags =  vec2(5.0,0.0);\n\nconst float PI = 3.1415926535;\n\n\n\n#define HASHSCALE1 .1031\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nbool Letter(int x, int y, int n)\n{\n    if(x < 0 || x >= FONT_WIDTH || y < 0 || y >= FONT_HEIGHT) return false;\n    return texture(iChannel0, (vec2(x + n*FONT_WIDTH, y+FONT_START_Y) + 0.5) / iChannelResolution[0].xy).x > 0.5;\n}\n\nint ModLevel(int level)\n{\n    if(level == 0) return 0;\n    return level - (level - 1) / NUM_LEVELS * NUM_LEVELS;\n}\n\n#define D16(_y, _d0, _d1, _d2, _d3, _d4, _d5, _d6, _d7, _d8, _d9, _d10, _d11, _d12, _d13, _d14, _d15) if(y == (_y)) v0 = float(_d0) * 0.125 + float(_d1) * 1.0 + float(_d2) * 8.0 + float(_d3) * 64.0 + float(_d4) * 512.0 + float(_d5) * 4096.0 + float(_d6) * 32768.0 + float(_d7) * 262144.0, v1 = float(_d8) * 0.125 + float(_d9) * 1.0 + float(_d10) * 8.0 + float(_d11) * 64.0 + float(_d12) * 512.0 + float(_d13) * 4096.0 + float(_d14) * 32768.0 + float(_d15) * 262144.0;    \nvec3 Sprite(vec2 coord, int n, vec3 color, bool mirror, int rotate, vec3 colorMultiply)\n{\n    int x = int(coord.x);\n    int y = int(coord.y);\n    if(mirror) x = (SPRITE_WIDTH - 1) - x;\n    int old_x = x;\n    int old_y = y;\n    if(rotate == 1) { x = 15-old_y; y = old_x; }\n    else if(rotate == 2) { x = 15-old_x; y = 15-old_y; }\n    else if(rotate == 3) { x = old_y; y = 15-old_x; }\n\n    if(x < 0 || x >= SPRITE_WIDTH || y < 0 || y >= SPRITE_HEIGHT) return color;\n    \n    vec3 c = texture(iChannel0, (vec2(x + n*SPRITE_WIDTH, y + SPRITE_START_Y) + 0.5) / iChannelResolution[0].xy).xyz;\n    return c.x >= 0.0 ? (c * colorMultiply) : color;\n}\n\n\nvec3 PrintStr(vec2 fragCoord, int x, int y, int str, vec3 color, vec3 inputColor)\n{\n    int lx = int(fragCoord.x) - x;\t\n    int ly = int(fragCoord.y) - y;\n    if(lx < 0 || ly < 0 || ly >= FONT_HEIGHT) return inputColor;\n    \n    return texture(iChannel0, (vec2(lx, STRINGS_START_Y + str * FONT_HEIGHT + ly) + 0.5) / iChannelResolution[0].xy).x > 0.5 ? color : inputColor;\n}\n\n\nfloat Number(vec2 coord, int n, int numDigits)\n{\n    int x = int(coord.x);\n    int y = int(coord.y);\n    if(x < 0 || y < 0 || x >= FONT_WIDTH*numDigits || y >= FONT_HEIGHT)\n    {\n        return 0.0;\n    }\n    \n    int d = x / FONT_WIDTH;\n    x = x - d * FONT_WIDTH;\n    int tmp = int((float(n) + 0.5) / pow(10.,float((numDigits - 1) - d)));\n    if(tmp == 0 && d < numDigits - 2)\n        return 0.0;\n\n    tmp = tmp - tmp/10*10;\n    return Letter(x, y, tmp) ? 1.0 : 0.0;\n}\n\nbool Map(vec2 coord, int level)\n{\n    int x = int(coord.x);\n    int y = int(coord.y);\n    \n    if(level == 0) return false;\n    \n    if(y < 0 || y >= LEVEL_HEIGHT) return false;\n    if(x < 0 || x >= LEVEL_WIDTH) return true;\n    \n    level = ModLevel(level);\n    \n    \n    return texture(iChannel0, (vec2(x + level*LEVEL_WIDTH, y+LEVEL_START_Y) + 0.5) / iChannelResolution[0].xy).x > 0.5;\n}\n\nvec3 Tile(vec2 coord, int tile)\n{\n    //coord = floor(coord);\t//pixelate\n    if(tile == 1)\n    {\n        float s = sin((coord.x + coord.y)/8.0*PI*2.0+1.);\n        return (s >= 0.0 ? vec3(244,106,252) : vec3(252, 194, 252)) / 255.0;\n    }\n    else if(tile == 2)\n    {\n        float s = sin((coord.x + coord.y)/8.0*PI*2.0+1.);\n        return (s >= 0.0 ? vec3(106,244,252) : vec3(194, 252, 252)) / 255.0;\n    }\n    else if(tile == 3)\n    {\n        float s = sin((coord.x + coord.y)/8.0*PI*2.0+1.);\n        return (s >= 0.0 ? vec3(244,252,106) : vec3(252, 252, 194)) / 255.0;\n    }\n    else if(tile == 4)\n    {\n        float s = sin((coord.x + coord.y)/8.0*PI*2.0+1.);\n        return (s >= 0.0 ? vec3(244,252,106) : vec3(252, 252, 194)) / 255.0;\n    }\n    \n    return vec3(0.0);\n}\n\nvoid TileShadowColors(int tile, out vec3 color0, out vec3 color1)\n{\n    color0 = color1 = vec3(0);\n    if(tile == 1)\n    {\n        color0 = vec3(244,106,252)/255.0*.6;\n        color1 = vec3(244,106,252)/255.0*.4;\n    } else if(tile == 2)\n    {\n        color0 = vec3(106,244,252)/255.0*.6;\n        color1 = vec3(106,244,252)/255.0*.4;\n    }\n    else if(tile == 3)\n    {\n        color0 = vec3(244,252,106)/255.0*.6;\n        color1 = vec3(244,252,106)/255.0*.4;\n    }\n    else if(tile == 4)\n    {\n        color0 = vec3(244,252,106)/255.0*.6;\n        color1 = vec3(244,252,106)/255.0*.4;\n    }\n}\n\n\n\nvec3 LargeBubble(vec2 coord, float time, vec3 color)\n{\n    float radius = 12.0 + sin(time*3.0);\n    float aspect = 1.0 + sin(time*7.5)*.1;\n    float len = abs(length(coord*vec2(aspect, 2.0 - aspect)) - radius);\n    float alpha = max(0.0, 1.0 - len);\n    return mix(color, vec3(1), alpha);\n}\n\nvec3 DrawMap(vec2 pixelCoord, float offset, vec3 color)\n{\n    if(offset < float(LEVEL_HEIGHT_IN_PIXELS)*.5)\n    {\n        int ioffset = int(offset);\n        \n        // vec3 PrintStr(vec2 fragCoord, int x, int y, int str, vec3 color, vec3 inputColor)\n        color = PrintStr(pixelCoord, 1*8, 25*8+ioffset, STR_BEGINNING0, vec3(1), color);\n        color = PrintStr(pixelCoord, 2*8, 23*8+ioffset, STR_BEGINNING1, vec3(1), color);\n        color = PrintStr(pixelCoord, 6*8, 21*8+ioffset, STR_BEGINNING2, vec3(1), color);\n        color = PrintStr(pixelCoord, 4*8, 19*8+ioffset, STR_BEGINNING3, vec3(1), color);\n        color = PrintStr(pixelCoord, 9*8, 16*8+ioffset, STR_BEGINNING4, vec3(1), color);\n    }\n    \n    int level = int(offset - pixelCoord.y + float(LEVEL_HEIGHT_IN_PIXELS)) / LEVEL_HEIGHT_IN_PIXELS;\n    level = ModLevel(level);\n    pixelCoord.y = mod(pixelCoord.y - offset, float(LEVEL_HEIGHT_IN_PIXELS));\n                    \n    vec2 tileCoord = floor((pixelCoord + 0.5) / TILE_SIZE);\n    vec2 tileOffset = (pixelCoord - tileCoord*TILE_SIZE);\n    tileOffset.y = (TILE_SIZE - 1.0) - tileOffset.y;\n    \n    \n    \n    \n    int tile = level;\n    if(Map(tileCoord, level))\n    {\n        color = Tile(tileOffset, tile);\n    }\n    else\n    {\n        //TODO: optimize this!\n        vec3 color0, color1;\n        TileShadowColors(tile, color0, color1);\n        bool left = Map(tileCoord+vec2(-1,0), level);\n        bool up = Map(tileCoord+vec2(0,1), level);\n        bool upleft = Map(tileCoord+vec2(-1,1), level);\n        if(upleft && left && up && tileOffset.x < SHADOW_WIDTH && tileOffset.y < SHADOW_WIDTH)\n        \tcolor = (tileOffset.x < tileOffset.y)?color0:color1;\n        else if(upleft && left && tileOffset.x < SHADOW_WIDTH)\n        \tcolor = color0;// now is the beginning...\n        else if(upleft && up && tileOffset.y < SHADOW_WIDTH)\n        \tcolor = color1;\n        else if(upleft && tileOffset.x < SHADOW_WIDTH && tileOffset.y < SHADOW_WIDTH)\n        \tcolor = (tileOffset.x < tileOffset.y)?color1:color0;\n        else if(left && tileOffset.x < SHADOW_WIDTH)\n            color = (tileOffset.x < tileOffset.y)?color0:vec3(0);\n        else if(up && tileOffset.y < SHADOW_WIDTH)\n            color = (tileOffset.x < tileOffset.y)?vec3(0):color1;\n    }\n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 targetSize = vec2(32.,27.)*TILE_SIZE;\n    if(fragCoord.x > targetSize.x || fragCoord.y > targetSize.y) discard;\n    fragColor = vec4(0,0,0,0);\n\n    // load state\n    vec4 gameState = \ttexture(iChannel0, (txGameState + 0.5) / iChannelResolution[0].xy);\n    vec4 gameState2= \ttexture(iChannel0, (txGameState2+ 0.5) / iChannelResolution[0].xy);\n    vec2 playerPos = \ttexture(iChannel0, (txPlayerPos + 0.5) / iChannelResolution[0].xy).xy;\n    vec4 playerSprite =\ttexture(iChannel0, (txPlayerSprite + 0.5) / iChannelResolution[0].xy);\n    vec4 playerFlags =\ttexture(iChannel0, (txPlayerFlags + 0.5) / iChannelResolution[0].xy);\n    \n    vec2 playFieldCoord = fragCoord - vec2(TILE_SIZE*2.0,0);\n    vec2 tileCoord = floor((playFieldCoord + 0.5) / TILE_SIZE);\n    vec2 tileOffset = (playFieldCoord - tileCoord*TILE_SIZE);\n    tileOffset.y = (TILE_SIZE - 1.0) - tileOffset.y;\n    \n    float time = iTime;\n    \n\tint level = int(gameState.y);\n    /*\n    if(gameState.x == 3.0)\n    {\n        // now is the beginning...\n        \n        fragColor.xyz = Sprite(playFieldCoord - playerPos.xy, 4, fragColor.xyz, fract(time*2.0) > 0.5, 0);\n        fragColor.xyz = LargeBubble(playFieldCoord - playerPos.xy - vec2(8.0, 8.0), time, fragColor.xyz);\n        \n        \n        \n        return;\n    }\n    */\n    \n    if(gameState.x == 3.0 || gameState.x == 4.0)\n    {\n        // transition to level\n        float s = min(1.0, gameState2.z * .01);\n        vec2 pos = mix(gameState2.xy, playerPos.xy, s);\n        float offset = (float(level-1)+s) * float(LEVEL_HEIGHT_IN_PIXELS);\n        if(gameState.x == 3.0)\n        {\n            pos = playerPos;\n            offset = 0.0;\n        }\n    \n        fragColor.xyz = DrawMap(playFieldCoord, offset, fragColor.xyz);\n        \n        fragColor.xyz = Sprite(playFieldCoord - pos.xy, 4, fragColor.xyz, fract(time*2.0) > 0.5, 0, vec3(1));\n        fragColor.xyz = LargeBubble(playFieldCoord - pos.xy - vec2(8.0, 8.0), time, fragColor.xyz);\n        \n        return;\n    }\n    \n    // header\n    if(tileCoord.y > 24.0)\n    {\n        int score = int(gameState.z);\n        fragColor.xyz = vec3( Number(fragCoord - vec2(0,25.*8.), score, 8) +\n                              Number(fragCoord - vec2(10*8,25.*8.), 30000, 8));\n    \n        fragColor.xyz = PrintStr(fragCoord, 4*8, 26*8, STR_1UP, vec3(0,210,0)/255., fragColor.xyz);\n        fragColor.xyz = PrintStr(fragCoord, 11*8, 26*8, STR_HIGH_SCORE, vec3(210,0,0)/255., fragColor.xyz);\n        \n        float playTime = iTime;\t//TODO: fix this\n        if(gameState.x < 4.0)\n        {\n            fragColor.xyz = PrintStr(fragCoord, 25*8, 26*8, STR_1UP, vec3(0,190,255)/255., fragColor.xyz);\n            fragColor.xyz = PrintStr(fragCoord, 27*8, 25*8, STR_00, vec3(0,190,255)/255., fragColor.xyz);\n        }\n        else\n        {\n            if(mod(iTime,3.0) < 1.5)\n            {\n                fragColor.xyz = PrintStr(fragCoord, 24*8, 26*8, STR_INSERT, vec3(0,190,255)/255., fragColor.xyz);\n                fragColor.xyz = PrintStr(fragCoord, 25*8, 25*8, STR_COIN, vec3(0,190,255)/255., fragColor.xyz);\n            }\n            else\n            {\n                fragColor.xyz = PrintStr(fragCoord, 26*8, 26*8, STR_TO, vec3(0,190,255)/255., fragColor.xyz);\n                fragColor.xyz = PrintStr(fragCoord, 23*8, 25*8, STR_CONTINUE, vec3(0,190,255)/255., fragColor.xyz);\n            }\n        }\n        \n        return;\n    }\n\n\n    \n    if(gameState.x == 1.0)\n    {\n        // bubble bobble splash\n        \n        fragColor.xyz = PrintStr(fragCoord, 3*8, 5*8, STR_COPYRIGHT, vec3(1), fragColor.xyz);\n        fragColor.xyz = PrintStr(fragCoord, 7*8, 3*8, STR_ALL_RIGHTS, vec3(1), fragColor.xyz);\n        \n        float c = sin(iTime*24.5)*.5+0.5;\n        \n        /*\n        vec2 coord = fragCoord + vec2(0, min(0.0,-160.0+floor(iTime*120.0)));\n        float len = 1e10;\n        for(int i = 0; i < 200; i++)\n        {\n            float t = float(i) + 1200.0;\n            vec2 p = vec2((hash11(t)*2.0)*80.0-80.0,(hash11(t+1000.0)*2.0)*40.0-40.0) + vec2(128, 125);\n            len = min(len, length(p - coord) - hash11(t + 2000.0)*25.+8.0);\n        }\n        if(len < 10.0)\n        {\n            vec3 color = vec3(0);\n            color = mix(vec3(250,161,0)/255.0, color, smoothstep(9.5, 10.0, len));\n            color = mix(vec3(0), color, smoothstep(6.5, 7.0, len));\n            color = mix(vec3(255,240,32)/255.0, color, smoothstep(5.0, 5.5, len));\n        \tfragColor.xyz = color;\n        }\n        \n        fragColor.xyz = Logo(int(coord.x), int(coord.y), vec3(1), fragColor.xyz);\n\t\t*/\n        \n        vec2 coord = fragCoord - vec2(0, 50) + vec2(0, min(0.0,-160.0+floor(iTime*120.0)));\n        int x = int(coord.x);\n        int y = int(coord.y);\n        \n        \n        if(x >= 0 && x < LOGO_WIDTH && y >= 0 && y < LOGO_HEIGHT)\n        {\n            vec3 tmp = texture(iChannel0, (vec2(x, y+LOGO_START_Y) + 0.5) / iChannelResolution[0].xy).xyz;\n            float s = sin(iTime*50.0)*.5+.5;\n            \n            if(iTime >= 0.12*20.0) s = 0.0;\n    \t\tvec3 drawColor = mix(vec3(255, 88, 152), vec3(255, 255, 100), s)/255.0;\n            \n    \n    \t\tfragColor.xyz = tmp.x < 0.0 ? drawColor : tmp;\n        }\n        \n        return;\n    }\n    \n    if(gameState.x == 2.0)\n    {\n        // insert coin\n        fragColor.xyz = PrintStr(fragCoord, 10*8, 13*8, STR_INSERT_COIN, vec3(1), fragColor.xyz);\n        return;\n    }\n    \n    if(gameState.x == 6.0)\n    {\n        // game over        \n        fragColor.xyz = PrintStr(fragCoord, 12*8, 13*8, STR_GAME_OVER, vec3(1), fragColor.xyz);\n        fragColor.xyz = PrintStr(fragCoord, 11*8, 7*8, STR_PUSH_START, vec3(1), fragColor.xyz);\n        return;\n    }\n    \n    fragColor.xyz = DrawMap(playFieldCoord, float(level * LEVEL_HEIGHT_IN_PIXELS), fragColor.xyz);\n    \n    int lives = int(gameState.w);\n    \n    // bubbles    \n    for(int i = 0; i < MAX_ENTITIES; i++)\n    {\n        vec4 entity0 = texture(iChannel0, (vec2(i, ENTITIES_START_Y + 0) + 0.5) / iChannelResolution[0].xy);\n        vec4 entity1 = texture(iChannel0, (vec2(i, ENTITIES_START_Y + 1) + 0.5) / iChannelResolution[0].xy);\n        if(entity0.w == ENTITY_TYPE_BUBBLE && entity0.z >= -BUBBLE_DEATH_FRAMES)\n        {\n            float radius =  min(8.,1.0 + entity0.z*.5);\n            if(entity0.z < 0.0) radius = 8.0;\n            vec2 delta = playFieldCoord - entity0.xy;\n            float aspect = 1.0 + sin(entity0.z*.1 )*.1;\n            float l = length(delta*vec2(aspect,2.0-aspect));\n            if(l < radius + 1.)\n            {\n                float l2 = length(delta + vec2(2,-2));\n                float c = max(0.0, 1.0 - entity0.z / BUBBLE_ATTACK_FRAMES);\n                \n                if(entity0.z >= 0.0)\n                {    \n                    if(entity1.y >= 0.0)\n                    {\n                        // draw monster inside\n                        fragColor.xyz = Sprite(delta*1.25 + vec2(8.,8.), MONSTER_SPRITE_START_IDX, fragColor.xyz, false, 0, vec3(1));\n                    }\n                    \n                    // bubble\n                    float shake = max(0., entity0.z - (BUBBLE_LIFE_FRAMES - 120.0));\n                    shake = sin(shake)*.3 + 1.0;\n                    float alpha = max(0., 1.0 - abs(l - 7.5)*.75);\n                \tfragColor.xyz = ((fragColor.xyz + c) * (mix(vec3(1), BUBBLE_COLOR, c)) + (alpha*.75*BUBBLE_COLOR + exp(-l2)))*shake;\n                }\n                else\n                {\n                    // bursting animation\n                    float angle = fract(atan(delta.y, delta.x)/(2.0*PI));\n                    float band = min(.4 - entity0.z*.05, 1.3);\n                    float q = abs(0.5 - 2.0*fract(angle*16.0))*5.0/l * float(l > radius*(band-.1) && l < radius*band);\n                    q = clamp(q, 0.0, 1.0);\n                    fragColor.xyz = mix(fragColor.xyz, vec3(1), vec3(q));\n                }\n            }\n        }\n    }\n    \n    // draw monsters/tumblers/items\n    for(int i = 0; i < MAX_ENTITIES; i++)\n    {\n        vec4 entity0 = texture(iChannel0, (vec2(i, ENTITIES_START_Y + 0) + 0.5) / iChannelResolution[0].xy);\n        vec4 entity1 = texture(iChannel0, (vec2(i, ENTITIES_START_Y + 1) + 0.5) / iChannelResolution[0].xy);\n        if(entity0.w == ENTITY_TYPE_MONSTER)\n        {\n            int frame = int(mod(entity0.z*.1, 4.0));\n            fragColor.xyz = Sprite(playFieldCoord - entity0.xy, MONSTER_SPRITE_START_IDX+frame, fragColor.xyz, entity1.x > 0.0, 0, vec3(1));\n        }\n        else if(entity0.w == ENTITY_TYPE_TUMBLING_MONSTER)\n        {\n            int rot = int(mod(entity0.z*.1, 4.0));\n            int frame = int(mod(entity0.z*.2, 4.0));\n            fragColor.xyz = Sprite(playFieldCoord - entity0.xy, MONSTER_SPRITE_START_IDX+frame, fragColor.xyz, entity1.x > 0.0, rot, vec3(0.5,0.7,1));\n        }\n        else if(entity0.w == ENTITY_TYPE_ITEM)\n        {\n            int frame = int(entity0.z);\n            fragColor.xyz = Sprite(playFieldCoord - entity0.xy, ITEM_SPRITE_START_IDX+frame, fragColor.xyz, false, 0, vec3(1));\n        }\n    }\n\n    if(playerFlags.y >= 0.0)\n    {\n        float intensity = 1.0 + 0.1*sin(playerFlags.y)*float(playerFlags.y < INVULNERABLE_FRAMES);\n        // alive\n        fragColor.xyz = Sprite(playFieldCoord - playerPos, int(playerSprite.x), fragColor.xyz, playerSprite.y != 0.0, 0, vec3(intensity));\n    }\n    else\n    {\n        // dead\n        int rot = int(-playerFlags.y)/16;\n        rot = rot - rot/4*4;\n        fragColor.xyz = Sprite(playFieldCoord - playerPos, int(playerSprite.x), fragColor.xyz, playerSprite.y != 0.0, rot, vec3(1));\n    }\n    \n    \n    \n    if(fragCoord.x < 2.0*8.0)\n    {\n    \t// level\n        if(fragCoord.y > 23.5*8.0)\n        {\n            fragColor.xyz -= Number(fragCoord - vec2(-1,24.*8.-1.) + vec2(-1,1), level, 2);\n            fragColor.xyz = clamp(fragColor.xyz, 0.0, 1.0);\n            fragColor.xyz += Number(fragCoord - vec2(-1,24.*8.-1.), level, 2);\n        }\n        // lives\n        if(fragCoord.y < 8.0)\n        {\n            fragColor.xyz -= Number(fragCoord - vec2(-1,0.*8.-1.) + vec2(-1,1), lives, 2);\n            fragColor.xyz = clamp(fragColor.xyz, 0.0, 1.0);\n            fragColor.xyz += Number(fragCoord - vec2(-1,0.*8.-1.), lives, 2);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float BPM = 125.0;\nconst float SPEED = 6.0;\nconst float ROWS_PER_SEC = BPM * 24.0 / (60.0 * SPEED);\nconst float SEC_PER_ROW = 1.0 / ROWS_PER_SEC;\n\nconst int\tPATTERN0_LENGTH = 153;\nconst int\tPATTERN_LENGTH = 64;\nconst int \tNUM_PATTERNS = 7;\n\nconst float PI = 3.1415926535;\n\nconst int C  = 0;\nconst int Cs = 1;\nconst int D  = 2;\nconst int Ds = 3;\nconst int E  = 4;\nconst int F  = 5;\nconst int Fs = 6;\nconst int G  = 7;\nconst int Gs = 8;\nconst int A  = 9;\nconst int As = 10;\nconst int B  = 11;\nconst int X  = -1;\n\n#define N(_pos, _note, _octave) if(row >= (_pos)) { note = ((_octave)*12 + (_note)); hitRow = baseRow + (_pos); }\n\nint imod(int x, int m)\n{\n    return x - x / m * m;\n}\n\nint Data(float time, int track, out float envTime)\n{\n    int globalRow = int(time * ROWS_PER_SEC);\n    \n    int baseRow = 0;\n    int pattern = 0;\n    int row = globalRow;\n    \n    if(globalRow >= PATTERN0_LENGTH)\n    {\n        int m = NUM_PATTERNS - 1;\n        \n        int tmp = globalRow - PATTERN0_LENGTH;\n        \n        row = imod(tmp, PATTERN_LENGTH);\n        \n        pattern = tmp / PATTERN_LENGTH;\n        int numRepeats = pattern / m;\n        pattern = imod(pattern, m);\n        \n        baseRow = PATTERN0_LENGTH + (numRepeats*m+pattern) * PATTERN_LENGTH;\n        pattern++;\n    }\n    \n    int hitRow = -10;\n    int note = 0;\n    if(track == 0)\n    {\n        if(pattern == 0)\n        {\n            N( 0,  B, 0) N( 1,  C, 1) N( 2,  D, 1) N( 3,  E, 1) N( 4,  F, 1) N( 5,  G, 1) N( 6,  A, 1) N( 7,  B, 1) N( 8,  C, 2) \n            N( 9,  D, 2) N(10,  E, 2) N(11,  F, 2) N(12,  G, 2) N(13,  A, 2) N(14,  C, 3) N(20,  X, 0)         \n            //break between splash and intro. Currently 60 beats.\n            N(80,  C, 2) N(86,  C, 2) N(90,  B, 1) N(92,  A, 1)\n            N(96,  B, 1) N(98,  C, 2) N(100, D, 2) N(102, G, 1) N(108,  B, 1)\n            N(112, A, 1) N(118, E, 1) N(124, B, 1)\n            N(128, C, 2) N(132, D, 2) N(139, E, 2) N(146, Fs, 2)\n        }\n        else if(pattern == 1)\n        {\n            N( 0,  G, 2) N( 2, Fs, 2) N( 4,  E, 2) N( 7,  D, 2) N( 8, Fs, 2) N(10,  E, 2) N(12,  D, 2) N(15,  C, 2)\n            N(16,  E, 2) N(18,  D, 2) N(20,  C, 2) N(21,  B, 1) N(24,  D, 2) N(30,  B, 1) N(31,  A, 1) \n            N(32,  G, 1) N(34,  A, 1) N(36,  B, 1) N(38,  C, 2) N(40,  A, 1) N(42,  B, 1) N(43,  C, 2) N(46,  D, 2)\n            N(48,  D, 2) N(50,  E, 2) N(52, Fs, 2) N(53,  E, 2) N(56,  D, 2) N(58,  D, 2) N(60,  E, 2) N(62, Fs, 2) \n        }\n        else if(pattern == 2)\n        {\n            N( 0,  G, 2) N( 2, Fs, 2) N( 4,  E, 2) N( 7,  D, 2) N( 8, Fs, 2) N(10,  E, 2) N(12,  D, 2) N(15,  C, 2)\n            N(16,  E, 2) N(18,  D, 2) N(20,  C, 2) N(21,  B, 1) N(24,  D, 2) N(30,  B, 1) N(31,  A, 1) \n            N(32,  G, 1) N(34,  A, 1) N(36,  B, 1) N(38,  C, 2) N(40,  A, 1) N(42,  B, 1) N(43,  C, 2) N(46,  D, 2)\n            N(48,  D, 2) N(50,  E, 2) N(52, Fs, 2) N(53,  D, 2) N(56,  G, 2) N(58,  D, 2) N(60,  E, 2) N(62, Fs, 2) \n        }\n        else if(pattern == 3)\n        {\n            N( 0, Fs, 2) N(10,  D, 2) N(12,  E, 2) N(14, Fs, 2)\n            N(16,  G, 2) N(26,  D, 2) N(28,  E, 2) N(30, Fs, 2)\n            N(32,  A, 2) N(42,  D, 2) N(44,  E, 2) N(46, Fs, 2)\n            N(48,  B, 2) N(58,  G, 2) N(60,  A, 2) N(62,  B, 2)\n        }\n        else if(pattern == 4)\n        {\n            N( 0,  C, 3) N( 2,  C, 3) N( 6,  C, 3) N(10,  B, 2) N(12,  A, 2)\n            N(16,  B, 2) N(28,  B, 2)\n            N(32,  A, 2) N(38,  E, 2) N(44,  B, 2) N(48,  A, 2) \n            N(58,  D, 2) N(60,  E, 2) N(62,  Fs, 2) \n        }\n        else if(pattern == 5)\n        {\n            N( 0, Fs, 2) N(10,  D, 2) N(12,  E, 2) N(14, Fs, 2)\n            N(16,  G, 2) N(26,  D, 2) N(28,  E, 2) N(30, Fs, 2)\n            N(32,  A, 2) N(42,  D, 2) N(44,  E, 2) N(46, Fs, 2)\n            N(48,  B, 2) N(58,  G, 2) N(60,  A, 2) N(62,  B, 2)\n        }\n        else if(pattern == 6)\n        {\n            N( 0,  C, 3) N( 2,  C, 3) N( 6,  C, 3) N(10,  B, 2) N(12,  A, 2)\n            N(16,  B, 2) N(28,  B, 2)\n            N(32,  A, 2) N(38,  D, 2) N(42,  B, 2) N(44,  D, 2) N(46,  B, 2)\n            N(48,  G, 2) N(56,  X, 0) N(58,  D, 2) N(60,  E, 2) N(62, Fs, 2) \n        }\n    }\n    else if(track == 1)\n    {\n        if(pattern == 0)\n            \n        {\n            N(50, C, 1) \n            N(66,  G, 1)\n            N(82,  A, 1)\n            N(98,  D, 1) N(102,  D, 1) N(109,  E, 1) N(116, Fs, 1)\n\n        }\n        else if(pattern == 1)\n        {\n            N( 0,  G, 1) N( 2,  G, 2) N( 4,  G, 1) N( 6,  G, 2) N( 8,  G, 1) N(10,  G, 2) N(12,  G, 1) N(14,  G, 2)\n            N(16,  G, 1) N(18,  G, 2) N(20,  G, 1) N(22,  G, 2) N(24,  G, 1) N(26,  G, 2) N(28,  G, 1) N(30,  G, 2)\n            N(32,  E, 0) N(34,  E, 1) N(36,  E, 0) N(38,  E, 1) N(40,  E, 0) N(42,  E, 1) N(44,  E, 0) N(46,  E, 1)\n            N(48,  E, 0) N(50,  E, 1) N(52,  E, 0) N(54,  E, 1) N(56,  E, 0) N(58,  E, 1) N(60,  E, 0) N(62,  E, 1)\n        }\n        else if(pattern == 2)\n        {\n            N( 0,  G, 1) N( 2,  G, 2) N( 4,  G, 1) N( 6,  G, 2) N( 8,  G, 1) N(10,  G, 2) N(12,  G, 1) N(14,  G, 2)\n            N(16,  G, 1) N(18,  G, 2) N(20,  G, 1) N(22,  G, 2) N(24,  G, 1) N(26,  G, 2) N(28,  G, 1) N(30,  G, 2)\n            N(32,  E, 0) N(34,  E, 1) N(36,  E, 0) N(38,  E, 1) N(40,  E, 0) N(42,  E, 1) N(44,  E, 0) N(46,  E, 1)\n            N(48,  E, 0) N(50,  E, 1) N(52,  E, 0) N(54,  E, 1) N(56,  G, 0) N(58,  D, 0) N(60,  E, 0) N(62,  F, 0)\n        }\n        else if(pattern == 3 || pattern == 5)\n        {\n            N( 0, Fs, 0) N( 2, Fs, 1) N( 4, Fs, 0) N( 6, Fs, 1) N( 8, Fs, 0) N(10,  D, 0) N(12,  E, 0) N(14, Fs, 0)\n            N(16,  G, 0) N(18,  G, 1) N(20,  G, 0) N(22,  G, 1) N(24,  G, 0) N(26,  D, 0) N(28,  E, 0) N(30,  F, 0)\n            N(32, Fs, 0) N(34, Fs, 1) N(36, Fs, 0) N(38, Fs, 1) N(40, Fs, 0) N(42,  D, 0) N(44,  E, 0) N(46, Fs, 0)\n            N(48,  G, 0) N(50,  G, 1) N(52,  G, 0) N(54,  G, 1) N(56,  G, 0) N(58,  G, 0) N(60,  A, 1) N(62,  B, 1)\n        }\n        else if(pattern == 4)\n        {\n            N( 0,  C, 1) N( 2,  C, 2) N( 4,  C, 1) N( 6,  C, 2) N( 8,  C, 1) N(10,  C, 2) N(12,  C, 1) N(14,  C, 2)\n            N(16,  B, 0) N(18,  B, 1) N(20,  B, 0) N(22,  B, 1) N(24,  B, 0) N(26,  B, 1) N(28,  B, 0) N(30,  B, 1)\n            N(32,  A, 0) N(34,  A, 1) N(36,  A, 0) N(38,  A, 1) N(40,  E, 0) N(42,  E, 1) N(44,  E, 0) N(46,  E, 1)\n            N(48,  A, 0) N(50,  A, 1) N(52,  A, 0) N(54,  A, 1) N(56,  A, 0) \n        }\n        else if(pattern == 6)\n        {\n            N( 0,  C, 1) N( 2,  C, 2) N( 4,  C, 1) N( 6,  C, 2) N( 8,  C, 1) N(10,  C, 2) N(12,  C, 1) N(14,  C, 2)\n            N(16,  B, 0) N(18,  B, 1) N(20,  B, 0) N(22,  B, 1) N(24,  B, 0) N(26,  B, 1) N(28,  B, 0) N(30,  B, 1)\n            N(32,  A, 0) N(34,  A, 1) N(36,  A, 0) N(38,  A, 1) N(40,  D, 0) N(42,  A, 0) N(44,  D, 0) N(46,  A, 0)\n            N(48,  G, 0) N(56,  X, 0) N(58,  D, 0) N(60,  E, 1) N(62, Fs, 1) \n        }\n    }\n    else if(track == 2)\n    {\n        if(pattern == 3 || pattern == 5)\n        {\n            N( 2,  D, 3) N( 4,  E, 3) N( 6,  F, 3) N( 8, Fs, 3)\n            N(18,  D, 3) N(20,  E, 3) N(22, Fs, 3) N(24,  G, 3)\n            N(34,  D, 3) N(36,  E, 3) N(38, Fs, 3) N(40,  A, 3)\n            N(50,  D, 3) N(52,  E, 3) N(54, Fs, 3) N(56,  B, 3)\n        }\n    }\n    \n    envTime = time - float(hitRow)*SEC_PER_ROW;\n    \n    return note;\n}\n\nfloat Square(float x, float threshold)\n{\n    return fract(x) > threshold ? 1.0 : -1.0;\n}\n\nfloat Square2(float x, float threshold, float detune)\n{\n    return (Square(x-detune, threshold) + Square(x+detune, threshold))*.5;\n}\n    \nvec2 mainSound( in int samp, float time )\n{\n    float threshold = sin(time*5.)*.1+.5;\n    \n    float envTime0;\n    float envTime1;\n    float envTime2;\n    float envTime3;\n    \n    int note0 = Data(time, 0, envTime0);\n    int note1 = Data(time, 1, envTime1);\n    int note2 = Data(time, 2, envTime2);\n    int note3 = Data(time - SEC_PER_ROW, 0, envTime3);\n    \n    float freq0 = 440.0*pow(2.0, float(note0)/12.0)*.5*.5;\n    float freq1 = 440.0*pow(2.0, float(note1)/12.0)*.5*.5;\n    float freq2 = 440.0*pow(2.0, float(note2)/12.0)*.5*.5;\n    float freq3 = 440.0*pow(2.0, float(note3)/12.0)*.5*.5;\n    \n    float v = 0.0;\n    v += Square(envTime0*freq0, .5) * exp(-envTime0*.1) * float(note0 >= 0);\n    v += Square(envTime3*freq3, .5) * exp(-envTime3*.1) * float(note0 >= 0) * .2;\n    v += Square2(envTime1*freq1*.5*.5, threshold, 0.03) * float(note0 >= 0);\n    v += Square(envTime2*freq2, .5) * exp(-envTime2*2.) * float(note0 >= 0);\n    \n    return vec2(v*.1);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 38
                    }
                ],
                "type": "sound"
            },
            {
                "code": "// Shadertoy font shader - @P_Malin\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// ----------------------------------------------------------------------------------------\n\n#define LOW_QUALITY\n\n// The main characters are made up from a number of curve segments.\n// I made another shader to illustrate how these work:\n//\n//     https://www.shadertoy.com/view/Xds3Dn\n//\n// The middle of the characters are filled in triangles or convex quadrilaterals\n// Enable this define to see just the curved sections:\n\n//#define CURVES_ONLY\n\n// Initially I made most of characters this way but I ran into the constant register limit. \n// To avoid this, the curved sections of the o, a and d are oval shapes. \n// Also I managed to cut the constant data down dramatically by sharing a lot of\n// the shapes in the font (see the comments in the function Shadertoy() ). \n// For example the tails for h, a, d, t, the left hand side of the y and the \n// top of the h all use the same shape! \n// I was probably more happy that I should have been when I realised I could share\n// the shape making the curve of the r with the little loop on the o.\n//\n// I experimented with a distance field version but it looked like it would involve \n// a lot more work and I thought Id already spent too much time on this shader :)\n\n#ifdef LOW_QUALITY\n\n\t#define AA_X 1\n\t#define AA_Y 1\n\n#else\n\n\t#define AA_X 2\n\t#define AA_Y 2\n\n#endif\n\n\nfloat TestCurve(vec2 uv)\n{\n\tuv = 1.0 - uv;\n    return 1.0 - dot(uv, uv);\n}\n\nfloat Cross( const in vec2 A, const in vec2 B )\n{\n    return A.x * B.y - A.y * B.x;\n}\n\nvec2 GetUV(const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P)\n{\n    vec2 vPB = B - P;\n    float f1 = Cross(A-B, vPB);\n    float f2 = Cross(B-C, vPB);\n    float f3 = Cross(C-A, C-P);\n    \n    return vec2(f1, f2) / (f1 + f2 + f3);\n}\n\nfloat InCurve( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P )\n{\n    vec2 vCurveUV = GetUV(A, B, C, P);\n    \n    float fResult = -1.0;\n\n\tfResult = max(fResult, (-vCurveUV.x));\n\tfResult = max(fResult, (-vCurveUV.y));\n\tfResult = max(fResult, (vCurveUV.x + vCurveUV.y - 1.0));\n\n\tfloat fCurveResult = TestCurve(vCurveUV);\n\t\t\n\tfResult = max(fResult, fCurveResult);\t\n\t\n    return fResult;\n}\n\nfloat InCurve2( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P )\n{\n    vec2 vCurveUV = GetUV(A, B, C, P);\n\t\n    float fResult = -1.0;\n\n\tfResult = max(fResult, (vCurveUV.x + vCurveUV.y - 1.0));\n\t\n\tfloat fCurveResult = -TestCurve(vCurveUV);\n\t\n\tfResult = max(fResult, fCurveResult);\t\n\t\n    return fResult;\n}\n\nfloat InTri( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P )\n{\n\t#ifdef CURVES_ONLY\n\treturn 1.0;\n\t#endif\n\t\n    float f1 = Cross(B-A, A-P);\n    float f2 = Cross(C-B, B-P);\n    float f3 = Cross(A-C, C-P);\n\t\n    return (max(max(f1, f2), f3));\n}\n\nfloat InQuad( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 D, const in vec2 P )\n{\n\t#ifdef CURVES_ONLY\n\treturn 1.0;\n\t#endif\n\t\n    float f1 = Cross(B-A, A-P);\n    float f2 = Cross(C-B, B-P);\n    float f3 = Cross(D-C, C-P);\n    float f4 = Cross(A-D, D-P);\n    \n    return (max(max(max(f1, f2), f3), f4));\n}\n\n\nfloat Glyph0(const in vec2 uv)\n{\n    const vec2  vP0 = vec2 ( 0.112, 0.056 );\n    const vec2  vP1 = vec2 ( 0.136, 0.026 );\n    const vec2  vP2 = vec2 ( 0.108, 0.022 );\n    const vec2  vP3 = vec2 ( 0.083, 0.017 ); \n    const vec2  vP4 = vec2 ( 0.082, 0.036 ); \n    const vec2  vP5 = vec2 ( 0.088, 0.062 ); \n    const vec2  vP6 = vec2 ( 0.115, 0.086 ); \n    const vec2  vP7 = vec2 ( 0.172, 0.147 ); \n    const vec2  vP8 = vec2 ( 0.100, 0.184 ); \n    const vec2  vP9 = vec2 ( 0.034, 0.206 ); \n    const vec2 vP10 = vec2 ( 0.021, 0.160 ); \n    const vec2 vP11 = vec2 ( 0.011, 0.114 ); \n    const vec2 vP12 = vec2 ( 0.052, 0.112 ); \n    const vec2 vP13 = vec2 ( 0.070, 0.108 ); \n    const vec2 vP14 = vec2 ( 0.075, 0.126 );\n    const vec2 vP15 = vec2 ( 0.049, 0.124 );\n    const vec2 vP16 = vec2 ( 0.047, 0.148 );\n    const vec2 vP17 = vec2 ( 0.046, 0.169 );\n    const vec2 vP18 = vec2 ( 0.071, 0.171 );\n    const vec2 vP19 = vec2 ( 0.098, 0.171 ); \n    const vec2 vP20 = vec2 ( 0.097, 0.143 ); \n    const vec2 vP21 = vec2 ( 0.100, 0.118 ); \n    const vec2 vP22 = vec2 ( 0.080, 0.100 ); \n    const vec2 vP23 = vec2 ( 0.055, 0.083 ); \n    const vec2 vP24 = vec2 ( 0.050, 0.052 ); \n    const vec2 vP25 = vec2 ( 0.052, 0.004 ); \n    const vec2 vP26 = vec2 ( 0.107, 0.010 ); \n    const vec2 vP27 = vec2 ( 0.148, 0.011 ); \n    const vec2 vP28 = vec2 ( 0.140, 0.041 ); \n    const vec2 vP29 = vec2 ( 0.139, 0.069 ); \n\n    float fDist = 1.0;\n\n\tfDist = min( fDist, InCurve2(vP6,vP7,vP8, uv) );\n    fDist = min( fDist, InCurve2(vP8,vP9,vP10, uv) );\n\tfDist = min( fDist, InCurve2(vP10,vP11,vP12, uv) );\n    fDist = min( fDist, InCurve2(vP12,vP13,vP14, uv) );\n\tfDist = min( fDist, InCurve(vP14,vP15,vP16, uv) );\n    fDist = min( fDist, InCurve(vP16,vP17,vP18, uv) );\n    fDist = min( fDist, InCurve(vP18,vP19,vP20, uv) );\n    fDist = min( fDist, InCurve(vP20,vP21,vP22, uv) );\n\tfDist = min( fDist, InCurve2(vP22,vP23,vP24, uv) );\n    fDist = min( fDist, InCurve2(vP24,vP25,vP26, uv) );\n    fDist = min( fDist, InCurve2(vP26,vP27,vP28, uv) );\n    fDist = min( fDist, InCurve2(vP28,vP29,vP0, uv) );\n\tfDist = min( fDist, InCurve(vP0,vP1,vP2, uv) );\n\tfDist = min( fDist, InCurve(vP2,vP3,vP4, uv) );\n    fDist = min( fDist, InCurve(vP4,vP5,vP6, uv) );\n\n\n    fDist = min( fDist, InTri(vP0, vP1, vP28, uv) );\n\tfDist = min( fDist, InQuad(vP26, vP1, vP2, vP3, uv) );\n    fDist = min( fDist, InTri(vP3, vP4, vP24, uv) );\n    fDist = min( fDist, InTri(vP4, vP5, vP24, uv) );\n    fDist = min( fDist, InTri(vP24, vP5, vP22, uv) );\n    fDist = min( fDist, InTri(vP5, vP6, vP22, uv) );\n    fDist = min( fDist, InTri(vP22, vP6, vP21, uv) );\n    fDist = min( fDist, InTri(vP6, vP8, vP21, uv) );\n    fDist = min( fDist, InTri(vP21, vP8, vP20, uv) );\n    fDist = min( fDist, InTri(vP20, vP8, vP19, uv) );\n    fDist = min( fDist, InTri(vP19, vP8, vP18, uv) );\n    fDist = min( fDist, InTri(vP18, vP8, vP10, uv) );\n    fDist = min( fDist, InTri(vP10, vP16, vP17, uv) );\n    fDist = min( fDist, InTri(vP10, vP15, vP16, uv) );\n    fDist = min( fDist, InTri(vP10, vP12, vP16, uv) );\n    fDist = min( fDist, InTri(vP12, vP14, vP15, uv) );\n\n    return fDist;\n}\n\nfloat Glyph1(const in vec2 uv, const in vec2 vOffset)\n{\n    vec2 vP0 = vec2 ( 0.171, 0.026 ) + vOffset;\n    vec2 vP1 = vec2 ( 0.204, 0.022 ) + vOffset;\n    const vec2 vP2 = vec2 ( 0.170, 0.185 );\n    const vec2 vP3 = vec2 ( 0.137, 0.185 );\n    \n    return InQuad(vP0, vP1, vP2, vP3, uv);\n}\n\nfloat Glyph3(const in vec2 uv, vec2 vOffset)\n{\n    vec2 vP0 = vec2 ( 0.212, 0.112 ) + vOffset;\n    vec2 vP2 = vec2 ( 0.243, 0.112 ) + vOffset;\n    const vec2  vP4 = vec2 ( 0.234, 0.150 );\n    const vec2  vP5 = vec2 ( 0.230, 0.159 );\n    const vec2  vP6 = vec2 ( 0.243, 0.164 );\n    const vec2  vP7 = vec2 ( 0.257, 0.164 );\n    const vec2  vP8 = vec2 ( 0.261, 0.148 );\n    const vec2 vP10 = vec2 ( 0.265, 0.164 );\n    const vec2 vP11 = vec2 ( 0.256, 0.180 );\n    const vec2 vP12 = vec2 ( 0.239, 0.185 );\n    const vec2 vP13 = vec2 ( 0.194, 0.194 );\n    const vec2 vP14 = vec2 ( 0.203, 0.150 );\n    const vec2 vP16 = vec2 ( 0.212, 0.113 );\n\n    float fDist = 1.0;\n    fDist = min( fDist, InCurve(vP4,vP5,vP6, uv) );\n    fDist = min( fDist, InCurve(vP6,vP7,vP8, uv) );\n    fDist = min( fDist, InCurve2(vP10,vP11,vP12, uv) );\n    fDist = min( fDist, InCurve2(vP12,vP13,vP14, uv) );\n\n    fDist = min( fDist, InQuad(vP0, vP2, vP4, vP14, uv) );\n    fDist = min( fDist, InTri(vP14, vP4, vP5, uv) );\n    fDist = min( fDist, InTri(vP14, vP5, vP12, uv) );\n    fDist = min( fDist, InTri(vP5, vP6, vP12, uv) );\n    fDist = min( fDist, InTri(vP6, vP7, vP12, uv) );\n    fDist = min( fDist, InTri(vP6, vP10, vP12, uv) );\n    fDist = min( fDist, InTri(vP8, vP10, vP7, uv) );\n    \n    return fDist;\n}\n\nfloat Glyph4(const in vec2 uv)\n{\n    vec2 vP = uv - vec2(0.305, 0.125);\n    vP /= 0.065;\n    vP.x *= 1.5;\n    vP.x += vP.y * 0.25;\n    \n    vec2 vP2 = vP;\n\n    vP.y = abs(vP.y);\n    vP.y = pow(vP.y, 1.2);\n    float f= length(vP);\n    \n    vP2.x *= 1.2;\n    float f2 = length(vP2 * 1.5 - vec2(0.6, 0.0));\n        \n    return max(f - 1.0, 1.0 - f2) / 20.0;\n} \n\nfloat Glyph5(const in vec2 uv)\n{\n    const vec2  vP0 = vec2 ( 0.507, 0.138 );\n    const vec2  vP1 = vec2 ( 0.510, 0.065 );\n    const vec2  vP2 = vec2 ( 0.570, 0.066 );\n    const vec2  vP3 = vec2 ( 0.598, 0.066 );\n    const vec2  vP4 = vec2 ( 0.594, 0.092 );\n    const vec2  vP5 = vec2 ( 0.599, 0.131 );\n    const vec2  vP6 = vec2 ( 0.537, 0.137 );\n    const vec2  vP8 = vec2 ( 0.538, 0.125 );\n    const vec2  vP9 = vec2 ( 0.564, 0.129 );\n    const vec2 vP10 = vec2 ( 0.574, 0.100 );\n    const vec2 vP11 = vec2 ( 0.584, 0.085 );\n    const vec2 vP12 = vec2 ( 0.571, 0.079 );\n    const vec2 vP13 = vec2 ( 0.557, 0.081 );\n    const vec2 vP14 = vec2 ( 0.549, 0.103 );\n    const vec2 vP15 = vec2 ( 0.518, 0.166 );\n    const vec2 vP16 = vec2 ( 0.557, 0.166 );\n    const vec2 vP17 = vec2 ( 0.589, 0.163 );\n    const vec2 vP18 = vec2 ( 0.602, 0.137 );\n    const vec2 vP20 = vec2 ( 0.602, 0.152 );\n    const vec2 vP21 = vec2 ( 0.572, 0.194 );\n    const vec2 vP22 = vec2 ( 0.537, 0.185 );\n    const vec2 vP23 = vec2 ( 0.503, 0.189 );\n    \n    float fDist = 1.0;\n    fDist = min( fDist, InCurve2(vP0,vP1,vP2, uv) ); \n    fDist = min( fDist, InCurve2(vP2,vP3,vP4, uv) ); \n    fDist = min( fDist, InCurve2(vP4,vP5,vP6, uv) );\n    fDist = min( fDist, InCurve(vP8,vP9,vP10, uv) ); \n    fDist = min( fDist, InCurve(vP10,vP11,vP12, uv) ); \n    fDist = min( fDist, InCurve(vP12,vP13,vP14, uv) );\n    fDist = min( fDist, InCurve(vP14,vP15,vP16, uv) );\n    fDist = min( fDist, InCurve(vP16,vP17,vP18, uv) ); \n    fDist = min( fDist, InCurve2(vP20,vP21,vP22, uv) ); \n    fDist = min( fDist, InCurve2(vP22,vP23,vP0, uv) );\n\n    fDist = min( fDist, InTri(vP0, vP2, vP13, uv) );\n    fDist = min( fDist, InTri(vP13, vP2, vP12, uv) );\n    fDist = min( fDist, InTri(vP2, vP11, vP12, uv) );\n    fDist = min( fDist, InTri(vP2, vP4, vP11, uv) );\n    fDist = min( fDist, InTri(vP11, vP4, vP10, uv) );\n    fDist = min( fDist, InTri(vP10, vP4, vP9, uv) );\n    fDist = min( fDist, InTri(vP6, vP8, vP9, uv) );\n    fDist = min( fDist, InTri(vP0, vP13, vP14, uv) );\n    fDist = min( fDist, InTri(vP0, vP14, vP15, uv) );\n    fDist = min( fDist, InTri(vP15, vP16, vP22, uv) );\n    fDist = min( fDist, InTri(vP16, vP17, vP22, uv) );\n    fDist = min( fDist, InTri(vP17, vP18, vP20, uv) );\n    \n    return fDist;\n}\n\nfloat Glyph6(const in vec2 uv)\n{\n    const vec2  vP0 = vec2 ( 0.638 , 0.087 ); \n    const vec2  vP1 = vec2 ( 0.648 , 0.073 ); \n    const vec2  vP2 = vec2 ( 0.673 , 0.068 ); \n    const vec2  vP3 = vec2 ( 0.692 , 0.069 ); \n    const vec2  vP4 = vec2 ( 0.687 , 0.086 ); \n    const vec2  vP5 = vec2 ( 0.688 , 0.104 ); \n    const vec2  vP6 = vec2 ( 0.672 , 0.102 ); \n    const vec2  vP7 = vec2 ( 0.659 , 0.099 ); \n    const vec2  vP8 = vec2 ( 0.663 , 0.092 ); \n    const vec2  vP9 = vec2 ( 0.662 , 0.086 ); \n    const vec2 vP10 = vec2 ( 0.655 , 0.086 ); \n    const vec2 vP11 = vec2 ( 0.644 , 0.087 ); \n    const vec2 vP12 = vec2 ( 0.637 , 0.102 ); \n    const vec2 vP13 = vec2 ( 0.638 , 0.094 ); \n\n    float fDist = 1.0;\n    fDist = min( fDist, InCurve2(vP0,vP1,vP2, uv) ); \n    fDist = min( fDist, InCurve2(vP2,vP3,vP4, uv) ); \n    fDist = min( fDist, InCurve2(vP4,vP5,vP6, uv) ); \n    fDist = min( fDist, InCurve2(vP6,vP7,vP8, uv) ); \n    fDist = min( fDist, InCurve(vP8,vP9,vP10, uv) ); \n    fDist = min( fDist, InCurve(vP10,vP11,vP12, uv) );\n\n    fDist = min( fDist, InQuad(vP2, vP4, vP6, vP8, uv) );\n    fDist = min( fDist, InTri(vP9, vP2, vP8, uv) );\n    fDist = min( fDist, InTri(vP10, vP2, vP9, uv) );\n    fDist = min( fDist, InQuad(vP0, vP2, vP10, vP11, uv) );\n    fDist = min( fDist, InTri(vP11, vP12, vP0, uv) );\n    \n    return fDist;\n}\n\nfloat Glyph7(const in vec2 uv)\n{\n    const vec2 vP0 = vec2 ( 0.693 , 0.068 );\n    const vec2 vP1 = vec2 ( 0.748 , 0.069 );\n    const vec2 vP2 = vec2 ( 0.747 , 0.078 );\n    const vec2 vP3 = vec2 ( 0.691 , 0.077 );\n    \n    return InQuad(vP0, vP1, vP2, vP3, uv);\n}\n\n\nfloat Glyph8(const in vec2 uv)\n{ \n    vec2 vP = uv - vec2(0.788, 0.125);\n    vP /= 0.065;\n    vP.x *= 1.4;\n    vP.x += vP.y * 0.25;\n    \n    vec2 vP2 = vP;\n    \n    vP.y = abs(vP.y);\n    vP.y = pow(vP.y, 1.2);\n    float f= length(vP);\n    \n    vP2.x *= 1.5;\n    float f2 = length(vP2 * 1.5 - vec2(0.3, 0.0));\n    \n    \n    return max(f - 1.0, 1.0 - f2) / 20.0;\n}\n\nfloat Glyph11(const in vec2 uv)\n{\n    const vec2  vP0 = vec2 ( 0.921 , 0.070 );\n    const vec2  vP2 = vec2 ( 0.955 , 0.070 );\n    const vec2  vP4 = vec2 ( 0.926 , 0.202 );\n    const vec2  vP5 = vec2 ( 0.926 , 0.240 );\n    const vec2  vP6 = vec2 ( 0.885 , 0.243 );\n    const vec2  vP7 = vec2 ( 0.852 , 0.239 );\n    const vec2  vP8 = vec2 ( 0.859 , 0.219 );\n    const vec2  vP9 = vec2 ( 0.862 , 0.192 );\n    const vec2 vP10 = vec2 ( 0.889 , 0.189 );\n    const vec2 vP12 = vec2 ( 0.928 , 0.178 );\n    const vec2 vP13 = vec2 ( 0.949 , 0.173 );\n    const vec2 vP14 = vec2 ( 0.951 , 0.162 );\n    const vec2 vP15 = vec2 ( 0.960 , 0.150 );\n    const vec2 vP16 = vec2 ( 0.960 , 0.144 );\n    const vec2 vP18 = vec2 ( 0.971 , 0.144 );\n    const vec2 vP19 = vec2 ( 0.968 , 0.157 );\n    const vec2 vP20 = vec2 ( 0.957 , 0.171 );\n    const vec2 vP21 = vec2 ( 0.949 , 0.182 );\n    const vec2 vP22 = vec2 ( 0.922 , 0.189 );\n    const vec2 vP24 = vec2 ( 0.900 , 0.196 );\n    const vec2 vP25 = vec2 ( 0.866 , 0.205 );\n    const vec2 vP26 = vec2 ( 0.871 , 0.217 );\n    const vec2 vP27 = vec2 ( 0.871 , 0.225 );\n    const vec2 vP28 = vec2 ( 0.880 , 0.224 );\n    const vec2 vP29 = vec2 ( 0.889 , 0.218 );\n    const vec2 vP30 = vec2 ( 0.893 , 0.203 );\n\n    float fDist = 1.0;\n    fDist = min( fDist, InCurve2(vP4,vP5,vP6, uv) );\n    fDist = min( fDist, InCurve2(vP6,vP7,vP8, uv) );\n    fDist = min( fDist, InCurve2(vP8,vP9,vP10, uv) );\n    fDist = min( fDist, InCurve(vP12,vP13,vP14, uv) );\n\n    fDist = min( fDist, InCurve(vP14,vP15,vP16, uv) );\n    fDist = min( fDist, InCurve2(vP18,vP19,vP20, uv) );\n    fDist = min( fDist, InCurve2(vP20,vP21,vP22, uv) );\n\n    fDist = min( fDist, InCurve(vP24,vP25,vP26, uv) );\n    fDist = min( fDist, InCurve(vP26,vP27,vP28, uv) );\n    fDist = min( fDist, InCurve(vP28,vP29,vP30, uv) );\n    \n    fDist = min( fDist, InQuad(vP0, vP2, vP4, vP30, uv) );\n\n    fDist = min( fDist, InQuad(vP10, vP12, vP22, vP24, uv) );\n        \n    fDist = min( fDist, InTri(vP30, vP4, vP6, uv) );\n    fDist = min( fDist, InTri(vP30, vP6, vP29, uv) );\n    fDist = min( fDist, InTri(vP28, vP29, vP6, uv) );\n    fDist = min( fDist, InTri(vP28, vP6, vP27, uv) );\n    \n    fDist = min( fDist, InTri(vP8, vP27, vP6, uv) );\n    \n    fDist = min( fDist, InTri(vP8, vP26, vP27, uv) );\n    fDist = min( fDist, InTri(vP8, vP25, vP26, uv) );\n    fDist = min( fDist, InTri(vP25, vP10, vP24, uv) );\n    \n    fDist = min( fDist, InTri(vP12, vP13, vP20, uv) );\n    fDist = min( fDist, InTri(vP12, vP20, vP22, uv) );\n    fDist = min( fDist, InTri(vP13, vP14, vP20, uv) );\n    fDist = min( fDist, InTri(vP15, vP20, vP14, uv) );\n    fDist = min( fDist, InTri(vP15, vP18, vP20, uv) );\n    fDist = min( fDist, InTri(vP15, vP16, vP18, uv) );\n    \n    return fDist;\n}\n\nfloat Shadertoy(in vec2 uv)\n{\n    float fResult = 1.0;\n    \n    fResult = min(fResult, Glyph0(uv)); // S\n\n    vec2 vUVOffset = vec2(0.001, 0.0); // tail of h\n    vec2 vTailOffset = vec2(0.0, 0.0);  \n    float fUVScale = 1.0;\n\n    if(uv.x < 0.3)\n    {\n        if(uv.y < 0.12)\n        {\n            // top of h\n            fUVScale = -1.0;\n            vUVOffset = vec2(0.448, 0.25);  \n            vTailOffset = vec2(0.0, 0.0);   \n        }\n    }\n    else if(uv.x < 0.4)    \n    {\n        // tail of a\n        vUVOffset = vec2(-0.124, 0.0);  \n        vTailOffset = vec2(0.01, -0.04);    \n    }\n    else if(uv.x < 0.6)\n    {\n        // tail of d\n        vUVOffset = vec2(-0.248, 0.0);  \n        vTailOffset = vec2(0.02, -0.1); \n    }\n    else if(uv.x < 0.83)\n    {\n        // stalk of t\n        vUVOffset = vec2(-0.48, 0.0);   \n        vTailOffset = vec2(0.02, -0.1); \n    }\n    else\n    {\n        // start of y\n        vUVOffset = vec2(-0.645, 0.0);  \n        vTailOffset = vec2(0.005, -0.042);  \n    }\n    \n    fResult = min(fResult, Glyph3(uv * fUVScale + vUVOffset, vTailOffset)); // tails h, a, d, t, start of y and top of h\n\n\n    vec2 vUVOffset3 = vec2(0.0, 0.0);   // vertical of h\n    vec2 vTailOffset3 = vec2(0.0, 0.0);\n    \n    if(uv.x > 0.5)\n    {\n        // vertical of r\n        vUVOffset3 = vec2(-0.45, 0.0);  \n        vTailOffset3 = vec2(-0.01, 0.04);   \n    }\n    \n    fResult = min(fResult, Glyph1(uv + vUVOffset3, vTailOffset3)); // vertical of h, r\n\n    vec2 vUVOffset2 = vec2(0.0, 0.0); // curve of a\n    if(uv.x > 0.365)\n    {\n        vUVOffset2 = vec2(-0.125, 0.0); // curve of d\n    }\n\n    fResult = min(fResult, Glyph4(uv + vUVOffset2)); // curve of a, d\n    \n    fResult = min(fResult, Glyph5(uv)); // e\n\n    vec2 vUVOffset4 = vec2(0.001, 0.0); // top of r\n    vec2 vUVScale4 = vec2(1.0, 1.0);        \n    \n    if(uv.x > 0.7)\n    {\n        // o loop\n        vUVOffset4.x = 1.499;\n        vUVOffset4.y = 0.19;\n        \n        vUVScale4.x = -1.0;\n        vUVScale4.y = -1.0;\n    }\n    \n    fResult = min(fResult, Glyph6(uv * vUVScale4 + vUVOffset4)); // top of r and o loop\n\n    fResult = min(fResult, Glyph7(uv)); // cross t    \n    \n    fResult = min(fResult, Glyph8(uv)); // o1\n    \n    fResult = min(fResult, Glyph11(uv)); // y2        \n\n    return fResult; \n}\n\nvec2 GetUVCentre(const vec2 vInputUV)\n{\n\tvec2 vFontUV = vInputUV;\n    vFontUV.y -= 0.35;\n\t\t\n\treturn vFontUV;\n}\n\nvec2 GetUVScroll(const vec2 vInputUV, float t)\n{\n\tvec2 vFontUV = vInputUV;\n\tvFontUV *= 0.25;\n\t\n    vFontUV.y -= 0.005;\n\tvFontUV.x += t * 3.0 - 1.5;\n\t\n\treturn vFontUV;\n}\n\nvec2 GetUVRepeat(const vec2 vInputUV, float t2)\n{\n\tvec2 vFontUV = vInputUV;\n\t\n\tvFontUV *= vec2(1.0, 4.0);\n\t\n\tvFontUV.x += floor(vFontUV.y) * t2;\n\t\n\tvFontUV = fract(vFontUV);\n\t\n\tvFontUV /= vec2(1.0, 4.0);\n\t\t\n\treturn vFontUV;\n}\n\nvec2 GetUVRotate(const vec2 vInputUV, float t)\n{\n\tvec2 vFontUV = vInputUV - 0.5;\n\t\n\tfloat s = sin(t);\n\tfloat c = cos(t);\n\t\n\tvFontUV = vec2(  vFontUV.x * c + vFontUV.y * s,\n\t\t\t        -vFontUV.x * s + vFontUV.y * c );\n\t\n\tvFontUV += 0.5;\n\t\n\treturn vFontUV;\n}\n\nvec3 StyleDefault( float f )\n{\n\treturn mix(vec3(0.25), vec3(1.0), f);\n}\n\nvec3 StyleScanline( float f, in vec2 fragCoord )\n{\n\tfloat fShade = f * 0.8 + 0.2;\n\t\n\tfShade *= mod(fragCoord.y, 2.0);\n\t\n\treturn mix(vec3(0.01, 0.2, 0.01), vec3(0.01, 1.0, 0.02), fShade);\n}\n\nvec3 StyleStamp( float fFont, vec2 uv )\n{\n\tvec3 t1 = texture(iChannel0, uv + 0.005).rgb;\n\tvec3 t2 = texture(iChannel0, uv).rgb;\n\tfloat dt = clamp(0.5 + (t1.x - t2.x), 0.0, 1.0);\n\tfloat fWear = clamp((0.9 - t2.x) * 4.0, 0.0, 1.0);\n\tfloat f =  clamp(fFont * fWear, 0.0, 1.0);\n\treturn mix( vec3(1.0, 0.98, 0.9) * (dt * 0.1 + 0.9), vec3(0.7, 0.0, 0.0), f);\n}\n\nvec3 StyleWood( float fFont, vec2 uv )\n{\n\tvec3 t = texture(iChannel0, uv).rgb;\n\tfloat fWear = fFont * smoothstep(0.0, 0.4, t.b);\n\treturn mix(t, vec3(0.0), fWear);\n}\n\nvec4 GetRandom4(float x)\n{\n\treturn fract(vec4(987.65, 432.10, 765.43, 210.98) * sin(vec4(123.456, 789.123, 456.789, 567.890) * x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    /*if ( iFrame != 0 )\n    {\n        fragColor = texture( iChannel0, fragCoord.xy / iResolution.xy );\n        return;\n    }\n    */\n    \n\tfloat fSequenceLength = 5.0;\n\t\n\tfloat fTime = 0.0;//iTime;\n\t\n\tfloat fBlendSpeed = 0.05;\n\t\n\t// Skip the initial fade-in\n\tfTime += fBlendSpeed * fSequenceLength;\n\t\n\tfloat fInt = floor(fTime / fSequenceLength);\n\tfloat fFract = fract(fTime / fSequenceLength);\n\t\n\tvec4 vRandom4 = GetRandom4(fInt);\n\tvec2 vRandom2 = floor(vRandom4.xy * vec2(1234.56, 123.45));\n\t\n\tfloat fUVEffect = mod(vRandom2.x, 4.0);\n\tfloat fScreenEffect = mod(vRandom2.y, 4.0);\n\n\tif(fInt < 0.5)\n\t{\n\t\tfUVEffect = 0.0;\n\t\tfScreenEffect = 0.0;\n\t}\n\n\tvec4 vResult = vec4(0.0);\n\t\t\n\tfloat fX = 0.0;\n\tfor(int iX=0; iX<AA_X; iX++)\n\t{\n\t\tfloat fY = 0.0;\n\t\tfor(int y=0; y<AA_Y; y++)\n\t\t{\n\t\n\t\t\tvec2 vUV = (fragCoord.xy + vec2(fX, fY)) / iResolution.xy;\n\t\t\tvUV.x = ((vUV.x - 0.5) * (iResolution.x / iResolution.y)) + 0.5;    \n\t\t\tvUV.y = 1.0 - vUV.y;\n\t\t\t\t\n\t\t\tvec2 vFontUV = vUV;\n\t\t\tvec2 vBgUV = vUV;\n\t\t\t\n\t\t\t/*if(iMouse.z > 0.0)\n\t\t\t{\n\t\t\t\tfUVEffect = 999.0;\n\t\t\t\tfScreenEffect = 0.0;\n\t\t\t\tfFract = 0.5;\n\t\t\t\t\n\t\t\t\tvFontUV *= 0.25;\n\t\t\t\tvFontUV += iMouse.xy / iResolution.xy;\n\t\t\t\tvFontUV.y -= 0.5;\n\t\t\t\tvBgUV = vFontUV;\n\t\t\t}*/\t\n\t\t\t\n\t\t\tif(fUVEffect < 0.5)\n\t\t\t{\n\t\t\t\tvFontUV = GetUVCentre(vBgUV);\n\t\t\t}\n\t\t\telse\n\t\t\tif(fUVEffect < 1.5)\n\t\t\t{\n\t\t\t\tvBgUV = GetUVScroll(vBgUV, fFract);\n\t\t\t\tvFontUV = vBgUV;\n\t\t\t}\n\t\t\telse\n\t\t\tif(fUVEffect < 2.5)\n\t\t\t{\n\t\t\t\tfloat fSpeed = 0.1 + vRandom4.z;\n\t\t\t\tvBgUV.x += fFract * fSpeed;\n\t\t\t\tvFontUV = GetUVRepeat(vBgUV, 0.25);\n\t\t\t}\n\t\t\telse\n\t\t\tif(fUVEffect < 3.5)\n\t\t\t{\n\t\t\t\tfloat fSpeed = 1.0 + vRandom4.z * 2.0;\n\t\t\t\tif(vRandom4.w > 0.5)\n\t\t\t\t{\n\t\t\t\t\tfSpeed = -fSpeed;\n\t\t\t\t}\n\t\t\t\tvBgUV = GetUVRotate(vBgUV, 1.0 + fSpeed * fFract);\n\t\t\t\tvFontUV = GetUVRepeat(vBgUV, 0.0);\n\t\t\t}\n\t\t\t\n\t\t\tfloat fShadertoy = step(Shadertoy(vFontUV), 0.0);\n\t\t\t\t\n\t\t\tif(fScreenEffect < 0.5)\n\t\t\t{\n\t\t\t\tvResult += vec4(StyleDefault(fShadertoy), 1.0);\n\t\t\t}\n\t\t\telse if(fScreenEffect < 1.5)\n\t\t\t{\n\t\t\t\tvResult += vec4(StyleScanline(fShadertoy, fragCoord), 1.0);\n\t\t\t}\n\t\t\telse if(fScreenEffect < 2.5)\n\t\t\t{\n\t\t\t\tvResult += vec4(StyleStamp(fShadertoy, vBgUV), 1.0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvResult += vec4(StyleWood(fShadertoy, vBgUV), 1.0);\n\t\t\t}\n\n\t\t\tfY += 1.0 / float(AA_Y);\n\t\t}\n\t\t\n\t\tfX += 1.0 / float(AA_X);\n\t}\n\t\n\tvResult.xyz /= vResult.w;\n\n\tfloat fFade = 0.0;\t\n\tif(fFract > (1.0 - fBlendSpeed))\n\t{\n\t\tfFade = smoothstep(1.0 - fBlendSpeed, 1.0, fFract);\n\t}\n\n\tif(fFract < fBlendSpeed)\n\t{\n\t\tfFade = smoothstep(fBlendSpeed, 0.0, fFract);\n\t}\n\n\tvResult = mix(vResult, vec4(1.0), fFade);\n\t\n    fragColor = vec4(vResult.xyz, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}