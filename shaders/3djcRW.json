{
    "Shader": {
        "info": {
            "date": "1586206950",
            "description": "potato",
            "flags": 0,
            "hasliked": 0,
            "id": "3djcRW",
            "likes": 12,
            "name": "Day 109",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 475
        },
        "renderpass": [
            {
                "code": "// HYPERBOLIC CODE FROM http://roy.red/generating-spherical-and-hyperbolic-tilings-in-glsl-.html#generating-spherical-and-hyperbolic-tilings-in-glsl\n// Super interesting read, I am still in the process of understanding all of it, so I copied the UV generation\n// and added some textures on top to make it shiny\n\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define PI acos(-1.)\n\n#define pi acos(-1.)\n#define tau (1.*pi)\n\n// Adjust p, q, r\nconst float p = 3.; const float q=4.; const float r=3.;\nfloat space = float(sign(q*r+p*r+p*q-p*q*r));\nvec3 fold( vec3 p, in vec3 dir, inout int n) {\n// Reflect if we're outside the fundamental region\n    float dt = dot(p,dir);\n    if (dt < 0.) {\n        n = n + 1;\n        return p-2.*dt*dir*vec3(1,1,space);\n    }\n    return p;\n}\nfloat sdBox(vec2 p, vec2 s){\n\tfloat d = 10e8;\n    p = abs(p) - s;\n    d = max(p.x,p.y);\n    return d;\n}\nfloat xor(float a, float b){\n\treturn float(int(a)^ int(b));\n}\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\n\nvec3 get(vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 z = uv;\n    z *= 2.5;\n    \n    // - HYPERBOLIC UV - //\n    \n    if(length(z) > 1.)\n    \tz /= dot(z,z);\n    \n    // Stereographically project\n    vec3 w=vec3(2.*z,1.-space*dot(z,z))*1./(1.+space*dot(z,z));\n    \n    // Hyperbolic rotation\n    float amt = mod(iTime, 2.45*2.);\n    \n    float envA = smoothstep(0.,1.,amt/2.45)*0.2;\n    float envB = smoothstep(0.,1.,amt/2.45 - 1.)*0.2;\n    \n    if(amt > 2.45)\n        amt -= 2.45*2.;\n    w.yz *= mat2(cosh(amt), sinh(amt), sinh(amt),cosh(amt));\n    //w.yz *= mat2(cosh(amt), sinh(amt), sinh(amt),cosh(amt));\n    // Calculate cutting planes\n    float ab = -cos(PI/p);\n    float bc = -cos(PI/q);\n    float ac = -cos(PI/r);\n    vec3 a = vec3(1.,0.,0);\n    vec3 b = vec3(ab,sin(PI/p),0.);\n    float c0 = ac;\n    float c1 = (bc-b[0]*c0)/b[1];\n    vec3 c = vec3(c0,c1,sqrt(abs(1.-c0*c0-c1*c1)));\n    if (space==0.)\n        c[2] = .5;\n\n    // Fold across the planes a few times\n    int n=0; int m = 0;\n    for (int i=0;i<10;i++){\n        w = fold(w,a,m);\n        w = fold(w,b,m);\n        w = fold(w,c,n);\n    }\n\n    \n    // - COLORING - //\n    //w.x += iTime;\n    \n    float d = 10e7;\n    vec4 no = noise(float(n + m));\n    vec2 p = w.xy;\n    //p = sin(p*7.);\n    #define pmod(p,x) (mod(p,x) - 0.5*x)\n    //vec2 j = pmod(p, 20.);\n    vec2 j = p;\n    j.x -= 2.5;\n    j = sin(j*7.);\n    vec3 col = vec3(0);\n    //col += w*1.;\n    \n    \n    vec3 ff = 1. - vec3(1.)*(dot(w*1.,a*8.));\n    \n    ff = clamp(ff, 0.,1.);\n    //col += ff*0.1;\n\t\n    p.x -= 0.5;\n    float db = sdBox(j, vec2(0.2,0.9));\n    #define pal(a,b,c,d,e) (a + b*sin((c)*(d)+(e)))\n    vec3 cc = pal(0., 0.5, vec3(4.7,4.4,3.4), 1.7,.4 + w*2. + iTime*0.);\n    \n    cc = texture(iChannel1,w.xy, 1.3 + dot(uv*0.5,uv*0.5)*5.).xyz;\n    \n    cc = sin(cc*(5.4) + vec3(0.,0. ,.4 - envB + envA));\n    cc = max(cc, 0.);\n    \n    //cc.bg *= 0.2 +  pow(1. - length(w.x), 2.)*0.8;\n    float bb = length(cc) * pow(1. - length(w), 1.)*1.;\n    cc = sin(cc*1.  + bb*20.);\n    cc *= pow(1. - length(w.x)*1.25, 1.)*1.;\n    cc = smoothstep(0.,1.,cc);\n    cc = smoothstep(0.,1.,cc);\n    col += cc;\n    \n    \n    col -= smoothstep(0.,1.*dFdy(uv.x),-db );\n    col = max(col, 0.);\n    vec3 cb = smoothstep(0.,1.*dFdy(uv.x),-db )*pal(0.5, 0.5, vec3(0.7,0.4,0.9), 0.7 ,0.4 + uv.x + iTime);\n    \n    //col += cb;\n    \n    col = clamp(col, 0., 1.);\n    \n    //col = vec3(1);\n    \n    //col *= 1. - exp2(-abs(length(uv) - 0.4)*20.)*1.;\n    //col *= 1. - exp2(-abs(length(uv) - 0.4)*20.)*1.;\n    \n    float edge = exp2(-abs (length(uv) - 0.4)*50.)*1.;\n    \n    edge = smoothstep(0.,1.,edge);\n    edge = smoothstep(0.,1.,edge);\n    //edge = smoothstep(0.,1.,edge);\n    \n    //col = pow(col, vec3(1. + pow(edge, 0.5)));\n    col = max(col, 0.);\n    col.gb = pow(col.gb, vec2(1. + pow(edge, 0.5) ));\n    \n    col *= 1. - edge*1.0;\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0);\n    \n    float aa = 4.;\n    \n    for(float i =0.; i < aa*aa + min(float(iFrame),0.); i++){\n    \tcol += get(fragCoord + vec2(mod(i,aa),floor(i/aa))/aa);\n    }\n    col /= aa*aa;\n    \n    col = clamp(col, 0., 1.);\n    //col *= 0.999;\n    //col = 1. - col;\n    \n    \n    \n    //col *= max((1. + 1.*cos(iTime*1.+length(uv)*2.+vec3(4,2.5,1.5)))*1., 0.);\n    //col *= max((1.5 + 1.4*cos(iTime+length(uv)*2.+vec3(1,1.5,1.5)))*1., 0.);\n    col *= 2.;\n    col *= 1. - pow(smoothstep(0.,1.,dot(uv,uv)*0.9),0.9)*1.;\n    //col = 1. - col;\n    col = max(col, 0.);\n    \n    col = pow(col, vec3(0.45454));\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}