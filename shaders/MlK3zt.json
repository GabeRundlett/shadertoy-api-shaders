{
    "Shader": {
        "info": {
            "date": "1476631165",
            "description": "A re-make and extension of sebbi's shader so I can understand it better.\nhttps://www.shadertoy.com/view/lly3Rc\nMouse drag to camera look.\nDark color falloff is just to make it easier to see the different layers not to hide max distance of intersection!",
            "flags": 0,
            "hasliked": 0,
            "id": "MlK3zt",
            "likes": 10,
            "name": "Infinite Plane Shape Raytracing",
            "published": 3,
            "tags": [
                "raytrace"
            ],
            "usePreview": 1,
            "username": "demofox",
            "viewed": 1399
        },
        "renderpass": [
            {
                "code": "/*\n    By Alan Wolfe\n    http://blog.demofox.org\n\n    A remake and extension of sebbi's shader to understand the ideas better. (https://twitter.com/SebAaltonen)\n    https://www.shadertoy.com/view/lly3Rc\n\n    This shader ray traces infinite layers of infinite grids of shapes.  It's raytracing not ray marching\n    which means it is a constant time operation and analytically solves for the intersection point.\n\n    The shapes are:\n    1) L\n    2) square\n    3) circle\n    4) checkerboard\n    5) thin square\n\n    The idea is that you can reduce the problem from 3d to 2d by seeing where the ray hits the first two planes\n    and then using the uv coordinates of those intersections as two points defining a 2d ray.  You then do a\n    2d raytrace of that ray versus a shape, but valid intersection distances are a multiple of the vector's length\n    instead of a continuous calculation.\n\n    For this to work, you need to be able to analystically solve 2d ray vs 2d infinitely repeating shape.\n\n    An way to solve this is to make sure the shape is constrained to a single tile, and when laying the shape on\n    a grid, that no border between \"open spaces\" is less than 0.5 units.\n\n    The reason for that is because the vector can at most move by 0.5 units on any single axis (since we modulus the vector).\n    \n    If we have a border that is less than 0.5, we will think we got a hit, when in fact it might be a miss, if the sample point\n    is not actually inside the solid point!\n\n    The last two shapes are fail cases.\n\n    The checkerboard is a problem because if the ray is moving up and to the right or down and to the left, it can encounter\n    border thickness less than 0.5.\n\n    The thin square is a problem because it has a very thin border, which is less than 0.5 in all directions!\n\n    The ultimate goal of this stuff is to try and figure out how to make infinitely repeating shapes in ray tracing, like\n    can be done in ray marching via modulus!\n    http://computergraphics.stackexchange.com/questions/4094/is-there-a-method-to-do-ray-marching-style-modulus-repeat-with-raytracing\n\n    Blog post coming before too long.\n*/\n\n#define DARKEN_OVER_DISTANCE 1  // This makes it easier to see the different layers in a static image, not to hide a max distance.\n#define SHOW_2D_SHAPE        1  // This makes the 2d shape be shown in upper left corner\n\nconst float c_cameraDistance\t= 6.0;\nconst float c_cameraViewWidth\t= 24.0;\n\n//============================================================\nfloat binarySign (float v)\n{\n    return step(0.0, v) * 2.0 - 1.0;\n}\n\n//============================================================\n// returns t\n// circle xy = position, z = radius\n// Adapted from \"real time collision detection\" IntersectRaySphere()\nfloat RayIntersectCircle (in vec2 rayPos, in vec2 rayDir, in vec3 circle)\n{\n    // rayDir isn't normalized, so normalize it but remember it's length\n    float rayLen = length(rayDir);\n    rayDir = normalize(rayDir);\n\n\tvec2 m = rayPos - circle.xy;\n\tfloat b = dot(m, rayDir);\n\tfloat c = dot(m, m) - circle.z*circle.z;\n\t\n\t// Exit if the ray is outside the circle and pointing away from the circle\n\tif (c > 0.0 && b > 0.0)\n\t\treturn -1.0;\n\n\tfloat discr = b*b - c;\n\n\t// A negative discriminant means it missed the sphere\n\tif (discr < 0.0)\n\t\treturn -1.0;\n\n\tfloat t = -b - sqrt(discr);\n\tif (t < 0.0)\n\t\tt = -b + sqrt(discr);\n\n\treturn t / rayLen;\n}\n\n//============================================================\nfloat NumberStepsFunction_L_OneAxis (float current, float stepValue)\n{\n    float steps;\n    if (stepValue < 0.0)\n        steps = (current - 0.5) / -stepValue;\n    else\n        steps = (1.0 - current) / stepValue;\n    return steps;\n}\n\n//============================================================\nbool BooleanFunction_L (vec2 current)\n{\n    return (current.x < 0.5 || current.y < 0.5);\n}\n\n//============================================================\nfloat NumberStepsFunction_L (vec2 current, vec2 stepValue)\n{\n    if (BooleanFunction_L(current))\n        return 0.0;\n    \n    float stepsX = NumberStepsFunction_L_OneAxis(current.x, stepValue.x);\n    float stepsY = NumberStepsFunction_L_OneAxis(current.y, stepValue.y);\n    return ceil(min(stepsX, stepsY));\n}\n\n//============================================================\nbool BooleanFunction_Checker (vec2 current)\n{\n    if (current.x >= 0.5)\n    {\n        return current.y < 0.5;\n    }\n    else\n    {\n        return current.y >= 0.5;\n    }\n}\n\n//============================================================\nfloat NumberStepsFunction_Checker (vec2 current, vec2 stepValue)\n{\n    // if it's already in the shape, no steps to take\n    if (BooleanFunction_Checker(current))\n        return 0.0;\n\n\t// there are different values to reach based on where we are in the pattern.\n    float lower = step(0.5, current.x) * 0.5;\n    float upper = lower + 0.5;\n\n    // see how long to escape the box on each axis, take sooner event\n    float stepsX;\n    if (stepValue.x < 0.0)\n        stepsX = (current.x - lower) / -stepValue.x;\n    else\n        stepsX = (upper - current.x) / stepValue.x;\n\n    float stepsY;\n    if (stepValue.y < 0.0)\n        stepsY = (current.y - lower) / -stepValue.y;\n    else\n        stepsY = (upper - current.y) / stepValue.y;     \n    \n\treturn ceil(min(stepsX, stepsY));    \n}\n\n//============================================================\nbool BooleanFunction_Square (vec2 current)\n{\n    return (current.x < 0.25 || current.x > 0.75 || current.y < 0.25 || current.y > 0.75);\n}\n\n//============================================================\nfloat NumberStepsFunction_Square (vec2 current, vec2 stepValue)\n{\n    // if it's already in the shape, no steps to take\n    if (BooleanFunction_Square(current))\n        return 0.0;\n    \n    float stepsX;\n    if (stepValue.x < 0.0)\n        stepsX = (current.x - 0.25) / -stepValue.x;\n    else\n        stepsX = (0.75 - current.x) / stepValue.x;\n    \n    float stepsY;\n    if (stepValue.y < 0.0)\n        stepsY = (current.y - 0.25) / -stepValue.y;\n    else\n        stepsY = (0.75 - current.y) / stepValue.y;    \n    \n    return ceil(min(stepsX, stepsY));\n}\n\n//============================================================\nbool BooleanFunction_Circle (vec2 current)\n{\n    const float radius = 0.25;\n    const float radiusSq = radius * radius;\n    vec2 rel = current - vec2(0.5, 0.5);\n    return rel.x*rel.x + rel.y*rel.y > radiusSq;\n}\n\n//============================================================\nfloat NumberStepsFunction_Circle (vec2 current, vec2 stepValue)\n{\n    // if it's already in the shape, no steps to take\n    if (BooleanFunction_Circle(current))\n        return 0.0;\n    \n    float steps = RayIntersectCircle(current, stepValue, vec3(0.5, 0.5, 0.25));\n    return ceil(steps);\n}\n\n//============================================================\nbool BooleanFunction_ThinSquare (vec2 current)\n{\n    return (current.x < 0.05 || current.x > 0.95 || current.y < 0.05 || current.y > 0.95);\n}\n\n//============================================================\nfloat NumberStepsFunction_ThinSquare (vec2 current, vec2 stepValue)\n{\n    // if it's already in the shape, no steps to take\n    if (BooleanFunction_ThinSquare(current))\n        return 0.0;\n    \n    float stepsX;\n    if (stepValue.x < 0.0)\n        stepsX = (current.x - 0.05) / -stepValue.x;\n    else\n        stepsX = (0.95 - current.x) / stepValue.x;\n    \n    float stepsY;\n    if (stepValue.y < 0.0)\n        stepsY = (current.y - 0.05) / -stepValue.y;\n    else\n        stepsY = (0.95 - current.y) / stepValue.y;    \n    \n    return ceil(min(stepsX, stepsY));\n}\n    \n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float mode = mod(iTime / 3.0, 5.0);\n    \n    #if SHOW_2D_SHAPE\n    {\n        vec2 percent = (fragCoord / iResolution.xy);\n        percent.x *= iResolution.x / iResolution.y;\n        if (percent.x < 0.2 && percent.y > 0.8)\n        {\n            percent.x *= 5.0;\n            percent.y = (percent.y - 0.8) * 5.0;\n            float color = 1.0;\n            if (abs(percent.x - 0.5) > 0.48 || abs(percent.y - 0.5) > 0.48)\n            {\n                fragColor = vec4(1.0, 0.5, 0.0, 1.0);\n                return;\n            }   \n            \n            if (mode < 1.0)\n            \tcolor = float(BooleanFunction_L(percent));                        \n            else if (mode < 2.0)\n                color = float(BooleanFunction_Square(percent));               \n            else if (mode < 3.0)\n                color = float(BooleanFunction_Circle(percent));   \n            else if (mode < 4.0)\n                color = float(BooleanFunction_Checker(percent));                  \n            else if (mode < 5.0)\n                color = float(BooleanFunction_ThinSquare(percent));                  \n\t\t\tfragColor = vec4(vec3(color), 1.0);\n            return;                              \n        }\n    }\n    #endif\n    \n    // set up the camera\n    vec3 cameraPos;\n    vec3 rayDir;\n    {\n        vec2 percent = (fragCoord / iResolution.xy) - vec2(0.5,0.5);  \n\n        vec3 offset = vec3(0.5, 0.5, iTime+0.01);\n\n        float angleX = 0.0;\n        float angleY = 0.0;\n\n        if (iMouse.z > 0.0) {\n            vec2 mouse = iMouse.xy / iResolution.xy;\n            angleX = 3.14 + 6.28 * mouse.x;\n            angleY = (mouse.y - 0.5) * 3.14;//(mouse.y * 3.90) - 0.4;\n        }\n\n        vec3 cameraFwd\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY)));           \n        vec3 cameraRight = normalize(cross(vec3(0.0,1.0,0.0),cameraFwd));\n        vec3 cameraUp = normalize(cross(cameraFwd, cameraRight));\n\n        cameraPos = vec3(0.0, 0.0, -1.0) + offset;\n        vec3 cameraTarget = vec3(0.0, 0.0, 0.0) + offset;\n\n        float cameraViewHeight\t= c_cameraViewWidth * iResolution.y / iResolution.x;\n        vec3 rayTarget = cameraPos +  cameraFwd * c_cameraDistance + cameraRight * c_cameraViewWidth * percent.x + cameraUp * cameraViewHeight * percent.y;\n        rayDir = normalize(rayTarget - cameraPos);\n    }\n\n    // keep the camera in a unit cube\n\tcameraPos = fract(cameraPos);   \n    \n    // If ray facing negative on z axis, just flip direction and invert where we are in the cube on the z axis.\n    // Now we only have to deal with positive z directions.\n    if (rayDir.z < 0.0) {\n        rayDir *= -1.0;\n        cameraPos.z = 1.0 - cameraPos.z;\n    }\n        \n    // calculate the 3d position of the next two plane intersections\n    float intersection1Distance = (1.0 - cameraPos.z) / rayDir.z;\n    float intersection2Distance = (2.0 - cameraPos.z) / rayDir.z;\n    vec3 intersection1 = fract(cameraPos + rayDir * intersection1Distance);\n    vec3 intersection2 = fract(cameraPos + rayDir * intersection2Distance);\n     \n    // Calculate how much the uv changes from intersection1 to intersection2.\n    // Convert it from [0,1] to [-0.5, 0.5].\n    // We need to know this to know if the uvs are going positive or negative and by how much, on each axis.\n    vec2 uvStep = intersection2.xy - intersection1.xy;\n    uvStep = fract(uvStep + 0.5) - 0.5;\n          \n    // calculate how many steps it takes to hit something on the X and Y axis and take whichever hits first.\n    float steps = 0.0;\n    if (mode < 1.0)\n    \tsteps = NumberStepsFunction_L(intersection1.xy, uvStep);\n    else if (mode < 2.0)\n        steps = NumberStepsFunction_Square(intersection1.xy, uvStep);\n    else if (mode < 3.0)\n        steps = NumberStepsFunction_Circle(intersection1.xy, uvStep);    \n    else if (mode < 4.0)\n        steps = NumberStepsFunction_Checker(intersection1.xy, uvStep);            \n    else if (mode < 5.0)\n        steps = NumberStepsFunction_ThinSquare(intersection1.xy, uvStep);        \n        \n    // calculate how far it is to the intersection we found\n    float dist = (1.0 - cameraPos.z) / rayDir.z + steps / rayDir.z;\n    \n    #if DARKEN_OVER_DISTANCE\n\tfloat tint = clamp(1.0 - dist / 5.0, 0.0, 1.0);\n    #else\n    float tint = 1.0;\n    #endif\n    \n    // calculate the hit point\n    vec3 hitPoint = cameraPos + rayDir * dist;\n    vec2 uv = hitPoint.xy;\n    \n    // sample the texture\n\tfragColor = vec4(texture(iChannel0, uv).rgb * tint, 1.0);    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}