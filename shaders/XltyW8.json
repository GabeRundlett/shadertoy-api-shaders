{
    "Shader": {
        "info": {
            "date": "1532434865",
            "description": "Trying to recreate the style of these classic images: [url]https://svs.gsfc.nasa.gov/30028[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "XltyW8",
            "likes": 27,
            "name": "Earth at Night",
            "published": 3,
            "tags": [
                "earth",
                "night",
                "lights",
                "network",
                "satellite"
            ],
            "usePreview": 0,
            "username": "davidar",
            "viewed": 962
        },
        "renderpass": [
            {
                "code": "// 2018 David A Roberts <https://davidar.io>\n\nfloat rexp(vec2 p) {\n    return -log(1e-4 + (1. - 2e-4) * hash12(p));\n}\n\nfloat line(vec2 a, vec2 b, vec2 p, float width) {\n    // https://iquilezles.org/articles/distfunctions\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n    float d = length(pa - ba * h);\n    float x = distance(p,a) / (distance(p,a) + distance(p,b));\n    return 1.5 * mix(rexp(a), rexp(b), x) * smoothstep(width/2., 0., d) * smoothstep(1.75, 0.5, distance(a,b));\n}\n\nfloat network(vec2 p, float width) {\n    // based on https://www.shadertoy.com/view/lscczl\n    vec2 c = floor(p) + hash22(floor(p));\n    vec2 n = floor(p) + N + hash22(floor(p) + N);\n    vec2 e = floor(p) + E + hash22(floor(p) + E);\n    vec2 s = floor(p) + S + hash22(floor(p) + S);\n    vec2 w = floor(p) + W + hash22(floor(p) + W);\n    \n    float m = 0.;\n    m += line(n, e, p, width);\n\tm += line(e, s, p, width);\n    m += line(s, w, p, width);\n    m += line(w, n, p, width);\n   \n    for (float y = -1.; y <= 1.; y++) {\n        for (float x = -1.; x <= 1.; x++) {\n            vec2 q = floor(p) + vec2(x,y) + hash22(floor(p) + vec2(x,y));\n            float intensity = distance(p,q) / clamp(rexp(floor(p) + vec2(x,y)), 0., 1.);\n            m += line(c, q, p, width);\n            m += 5. * smoothstep(0.09, 0., intensity);\n        }\n    }\n    \n    return m;\n}\n\nfloat speckle(vec2 p, float density) {\n    float m = 0.;\n    for (float y = -1.; y <= 1.; y++) {\n        for (float x = -1.; x <= 1.; x++) {\n            vec2 q = floor(p) + vec2(x,y) + hash22(floor(p) + vec2(x,y));\n            m += 1.5 * rexp(q) * smoothstep(1., 0.5, distance(p,q) / clamp(density, 0., 1.));\n        }\n    }\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord + vec2(iFrame,0)) / iResolution.y;\n    vec2 wiggle = vec2(FBM(vec3(50. * uv, 1)), FBM(vec3(50. * uv, 2))) - 0.5;\n    \n    float height = FBM(vec3(6. * uv + 0.1 * wiggle, 3)) - 0.5;\n    if (height < 0.) {\n        fragColor = vec4(0.00, 0.01, 0.11, 1);\n    } else {\n        float d = 0.75;\n        float width = 6e-3;\n        d += 0.5 * network(50. * uv + 1.0 * wiggle, 50. * width);\n        d += 1.0 * network(15. * uv + 0.3 * wiggle, 15. * width);\n        d += 2.0 * network( 5. * uv + 0.1 * wiggle,  5. * width);\n        d += smoothstep(0.04, 0., height); // coast\n        d *= 0.1 + clamp(2. * FBM(vec3(12. * uv, 0)) - 0.5, 0., 1.);\n        d *= 0.2 + 1.2 * clamp(2. * FBM(vec3(3. * uv, 0)) - 0.5, 0., 1.);\n\n        uv = (fragCoord + vec2(iFrame,0)) / iResolution.y;\n        float a = speckle(3. * uv / width, d);\n        if (d > 5.) a = d;\n        a *= 0.5 * FBM(vec3(50. * uv, iTime));\n        \n        fragColor = vec4(0.02, 0.03, 0.15, 1);\n        fragColor.rgb *= 1. + 0.7 * clamp(FBM(vec3(100. * uv, 0)) - 0.15, 0., 1.);\n        fragColor = mix(fragColor, 0.75 * sqrt(d) * vec4(0.95, 0.76, 0.47, 1), smoothstep(0., 1., a));\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265359\n\n#define N vec2( 0, 1)\n#define E vec2( 1, 0)\n#define S vec2( 0,-1)\n#define W vec2(-1, 0)\n\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n        vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n        vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n        vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n        p4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n// By David Hoskins, May 2014. @ https://www.shadertoy.com/view/4dsXWn\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n        vec3 f = fract(p); \n        f *= f * (3.0-2.0*f);\n\n    return mix(\n                mix(mix(hash13(i + vec3(0.,0.,0.)), hash13(i + vec3(1.,0.,0.)),f.x),\n                        mix(hash13(i + vec3(0.,1.,0.)), hash13(i + vec3(1.,1.,0.)),f.x),\n                        f.y),\n                mix(mix(hash13(i + vec3(0.,0.,1.)), hash13(i + vec3(1.,0.,1.)),f.x),\n                        mix(hash13(i + vec3(0.,1.,1.)), hash13(i + vec3(1.,1.,1.)),f.x),\n                        f.y),\n                f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 ) * 1.7;\n\nfloat FBM( vec3 p )\n{\n    float f;\n        \n        f = 0.5000 * Noise(p); p = m*p;\n        f += 0.2500 * Noise(p); p = m*p;\n        f += 0.1250 * Noise(p); p = m*p;\n        f += 0.0625   * Noise(p); p = m*p;\n        f += 0.03125  * Noise(p); p = m*p;\n        f += 0.015625 * Noise(p);\n    return f;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}