{
    "Shader": {
        "info": {
            "date": "1594572040",
            "description": "Inspired by the 'Hackers' movie, when they 'hack the Gibson'.\n\nThe scene is made entirely out of accumulated 'glow', so the edges aren't as sharp as 'normal' raymarching. I liked the experiment though...\n(PS. The 'code' is obviously fake!)",
            "flags": 96,
            "hasliked": 0,
            "id": "ttByRm",
            "likes": 43,
            "name": "Hacking the Gibson",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "glow",
                "hackers"
            ],
            "usePreview": 1,
            "username": "dean_the_coder",
            "viewed": 1147
        },
        "renderpass": [
            {
                "code": "// 'Hacking the Gibson' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/ttByRm\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq and a bunch of others for sharing their knowledge!\n// Thanks FabriceNeyret2 for the text code: https://www.shadertoy.com/view/llySRh\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat time = 0.0;\n\n// Random number generator.\nfloat hash(float p) {\n    return fract(sin(dot(p, 123.45)) * 5432.3);\n}\n\n// 2D rotation matrix.\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// SDF box function.\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// SDF line function.\nfloat sdLine(vec3 p, vec3 a, vec3 b) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n// SDF to a lightning bolt-stle line.\nfloat sdBolt(vec3 p, vec3 a, vec3 b, float id) \n{\n    float d = 1e7;\n    vec3 dp = (b - a) / 5.0;\n    for (float i = 0.0; i < 5.0; i++) {\n        float t = i + floor((time + id) * 2.0);\n        d = min(d, sdLine(p, a + vec3(0.0, hash(t), 0.0), a + dp + vec3(0.0, hash(t + 1.0), 0.0)));\n        a += dp;\n    }\n    \n    return d;\n}\n\n// SDF 'framed' box function.\nfloat sdFramedBox(vec3 p, vec3 b) {\n\t// Thanks iq.\n    p = abs(p) - b;\n    vec3 q = abs(p);\n    return min(min(\n        length(max(vec3(p.x, q.y, q.z), 0.0)) + min(max(p.x, max(q.y, q.z)), 0.0),\n        length(max(vec3(q.x, p.y, q.z), 0.0)) + min(max(q.x, max(p.y, q.z)), 0.0)),\n        length(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0));\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec4 minD(vec4 a, vec4 b) {\n    return a.x < b.x ? a : b;\n}\n\nconst vec3 s = vec3(2.0, 6.0, 2.0);\nvec2 sdTower(vec3 p) {\n    p.y -= s.y;\n    \n    // Frame glow.\n    float outline = sdFramedBox(p, s);\n    float glow = 0.001 / (0.001 + outline * outline);\n    \n    // Base glow.\n    float d = sdBox(p + vec3(0.0, s.y, 0.0), vec3(s.x, 0.01, s.z));\n    glow += 0.001 / (0.001 + d * d);\n    \n    // Writing glow.\n    d = sdBox(p, s);\n    if (d > 0.0 && d < 0.075) {\n        glow += 0.03;\n         \n        vec2 uv = (p.xy + s.xy) / (2.0 * s.xy);\n        uv.x *= 0.8;\n        uv.y = mod(uv.y * 1.6 - 0.5, 1.0);\n        glow += texture(iChannel0, uv).r;\n    }\n    \n\treturn vec2(d, glow);\n}\n\nvoid applyTowerGap(inout vec3 p) {\n    p.z = mod(p.z, 9.0) - 4.5;\n}\n\n// Distance to the lightning bolts.\nfloat bolt(vec3 p, float id) {\n    float t = fract(time * 0.04 * hash(id) + id);\n    if (id > 12.5) t = 1.0 - t;\n    float h = mix(-50.0, s.y * 1.95, t);\n    \n    vec3 a = vec3(s.x, h, -s.z);\n    vec3 b = vec3(s.x, h, s.z);\n\n    if (hash(id) > 0.5) {\n        a.x = -a.x;\n        b.x = -b.x;\n    }\n\n    return sdBolt(p, a, b, id);\n}\n\n// Collection of towers.\nvec4 sdTowers(vec3 p) {\n    float id = hash(floor(p.z / 9.0)) * 25.0;\n    p.x = mod(p.x, 12.0) - 6.0;\n    applyTowerGap(p);\n\n    // Lightning bolts.\n    float boltD = bolt(p, id);\n    float boltGlow = step(0.0, p.y) * 0.01 / (0.01 + boltD * boltD);\n    \n    return vec4(sdTower(p), 0.0, boltGlow);\n}\n\n// SDF to the floor.\nvec3 sdFloor(vec3 p) {\n    if (p.y > 3.0) {\n        // Ray not near the ground - Abort early.\n        return vec3(1e10, 0.0, 0.0);\n    }\n    \n    vec3 pp = p;\n    \n    applyTowerGap(p);\n    \n    p.x = abs(p.x + 1.6) - 0.4;\n    p.z -= 4.5;\n   \n    const vec2 wh = vec2(0.1, 0.01);\n    float d = sdBox(p, vec3(wh, 1e10));\n    d = min(d, sdBox(p.zyx - vec3(0.0, 0.0, 100.0), vec3(wh, 100.0)));\n\n    if (pp.x > 0.0) {\n    \td = min(d, sdBox(p - vec3(2.0, 0.0, 0.0), vec3(wh, 3.0)));\n    \td = min(d, sdBox(p - vec3(4.0, 0.0, -6.0), vec3(wh, 3.0)));\n    \td = min(d, sdBox(p - vec3(3.0, 0.0, -3.0), vec3(wh, 1.1).zyx));\n    } else {\n    \td = min(d, sdBox(p - vec3(2.5, 0.0, -8.0), vec3(wh, 1.5)));\n    }\n    \n    float glow = 0.001 / (0.001 + d * d);\n    float t = time * 10.0;\n    \n    float pulse1 = sin((pp.z + t) * 0.02);\n    float pulse2 = sin((pp.z + t) * 0.02 - 0.6);\n    float pulse = step(0.999, pow(0.5 + 0.5 * max(pulse1, pulse2), 10.0));\n    return vec3(d, glow - pulse, sqrt(glow) * pulse * 3.0);\n}\n\nvec4 map(vec3 p) {\n    // dist/white_glow/yellow_glow/blue_glow\n    return minD(sdTowers(p), vec4(sdFloor(p), 0.0));\n}\n\nvec3 calcNormal(in vec3 p) {\n    // Thanks iq.\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(p + e.xyy).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\n/**********************************************************************************/\n\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvoid initCamera(out vec3 ro, out vec3 rd, vec2 uv) {\n    vec3 lookat;\n    float intro = time / 32.0;\n\n    ro = vec3(2.0 * sin(time * 0.05), 1.5 + 11.0 * smoothstep(0.0, 1.0, (0.5 + 0.5 * cos(time * 0.05))), time - 32.0 + 6.4);\n    lookat = ro + vec3(-smoothstep(-2.0, 2.0, ro.x) * 0.5, -sin(time * 0.06) * 0.4, 2.0);\n    if (intro < 1.2) {\n        vec3 intro_ro = vec3(-6.0 * (1.0 - intro), 11.5 - time / 32.0, 6.7);\n        vec3 intro_lookat = intro_ro + vec3(0.0, -0.5, 1.0);\n        \n        {\n            float trans = clamp((intro - 1.0) * 5.0, 0.0, 1.0);\n            ro = mix(intro_ro, ro, trans);\n            lookat = mix(intro_lookat, lookat, trans);\n        }\n    }\n    \n    rd = getRayDir(ro, lookat, uv);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    time = iTime * 8.0;\n\n    // Position camera and view direction.\n    vec3 ro, rd;\n    initCamera(ro, rd, uv);\n\n    vec3 col = vec3(0.3, 0.1, 0.4) * max(0.0, rd.y * 0.2); // Sky gradient\n    \n    // Raymarch.\n    const float maxDist = 100.0;\n    float d = 0.0;\n    float alpha = 1.0;\n    for (float steps = 0.0; steps < 80.0; steps++) {\n        vec3 p = ro + rd * d;\n        vec4 h = map(p); // Distance, glow1, glow2, glow3\n\n        if (abs(h.x) < 0.005) {\n            // We've hit something. Reduce opacity and keep marching.\n            h.x = 0.1;\n            alpha *= 0.2;\n        }\n\n        if (d >= maxDist) // Max draw distance reached - Stop.\n            break;\n        if (p.y < -0.5) // Ray is below the ground - Stop.\n            break;\n\n        // Accumulate the glow.\n\t    float fog = pow(1.0 - d / maxDist, 3.0);\n        vec3 whiteGlow = vec3(0.5, 0.6, 1.0);\n        vec3 rgb = whiteGlow * max(0.0, (h.y - h.z)) + vec3(1.0, 0.4, 0.02) * h.z;\n        rgb += whiteGlow * max(0.0, (h.y - h.w)) + vec3(0.2, 0.3, 1.0) * h.w;\n        col += rgb * fog * alpha;\n\n        d += abs(h.x);\n    }\n\n    // Output to screen.\n    col = pow(col, vec3(0.4545)); // Gamma correction\n    col = vignette(col, fragCoord); // Fade screen corners\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 23356,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/thanatos-ventrue/halcyon-on-on#t=2:30"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// 'Hacking the Gibson'\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq and a bunch of others for sharing their knowledge!\n// Thanks FabriceNeyret2 for the text code: https://www.shadertoy.com/view/llySRh\n\n#define RET(a) uv.y += 1.0; uv.x += a * 0.45\n#define SPC uv.x -= 0.45\n#define CHR(x)  g += char(uv, x); SPC\n\nfloat char(vec2 p, int c) {\n    if (p.x < 0.0 || p.x > 1.0 || p.y < 0.0 || p.y > 1.0)\n        return 0.0;\n    vec2 dFdx = dFdx(p / 16.0), dFdy = dFdy(p / 16.0);\n\treturn textureGrad(iChannel0, p / 16.0 + fract(vec2(c, 15 - c / 16) / 16.), dFdx, dFdy).r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y -= 1.0;\n    uv *= 16.0;\n    uv.y += 1.0;\n    \n\tfloat g = 0.0;\n    CHR(47); CHR(47); SPC; CHR(70); CHR(114); CHR(111); CHR(109); SPC; CHR(68); CHR(101); CHR(97); CHR(110); CHR(84); CHR(104); CHR(101); CHR(67); CHR(111); CHR(100); CHR(101); CHR(114); CHR(46);\n    RET(21.0);\n    CHR(119); CHR(104); CHR(105); CHR(108); CHR(101); SPC; CHR(40); CHR(49); CHR(41);\n    RET(9.0);\n    CHR(123);\n    RET(1.0); SPC; SPC; CHR(99); CHR(111); CHR(117); CHR(116); SPC; CHR(60); CHR(60); SPC; CHR(34); CHR(89); CHR(111); SPC; CHR(70); CHR(108); CHR(111); CHR(112); CHR(105); CHR(110); CHR(101); CHR(33); CHR(92); CHR(110); CHR(34); CHR(59);\n    RET(26.0); SPC; SPC; CHR(105); CHR(110); CHR(105); CHR(116); CHR(95); CHR(69); CHR(118); CHR(118); CHR(118); CHR(118); CHR(105); CHR(108); CHR(40); CHR(34); CHR(66); CHR(114); CHR(111); CHR(115); CHR(107); CHR(105); CHR(34); CHR(41); CHR(59);\n    RET(25.0); SPC; SPC; CHR(97); CHR(112); CHR(112); CHR(108); CHR(121); CHR(73); CHR(81); CHR(66); CHR(114); CHR(97); CHR(105); CHR(110); CHR(115); CHR(40); CHR(41); CHR(59);\n    RET(18.0);\n    SPC; SPC; CHR(65); CHR(114); CHR(116); CHR(79); CHR(102); CHR(67); CHR(111); CHR(100); CHR(101); SPC; CHR(43); CHR(61); SPC; CHR(66); CHR(105); CHR(103); CHR(87); CHR(105); CHR(110); CHR(103); CHR(115); CHR(59);\n    RET(24.0);\n    CHR(125);\n    RET(1.0);\n    RET(0.0);\n    CHR(118); CHR(111); CHR(105); CHR(100); SPC; CHR(72); CHR(97); CHR(99); CHR(107); CHR(84); CHR(104); CHR(101); CHR(80); CHR(108); CHR(97); CHR(110); CHR(101); CHR(116); CHR(40); CHR(41); SPC; CHR(123);\n    RET(22.0);\n    SPC; SPC; CHR(47); CHR(47); SPC; CHR(84); CHR(79); CHR(68); CHR(79); SPC; CHR(45); SPC; CHR(87); CHR(97); CHR(116); CHR(99); CHR(104); SPC; CHR(72); CHR(97); CHR(99); CHR(107); CHR(101); CHR(114); CHR(115); CHR(46);\n    RET(26.0);\n    SPC; SPC; CHR(114); CHR(101); CHR(116); CHR(117); CHR(114); CHR(110); CHR(59);\n    RET(9.0);\n    CHR(125);\n    \n\tvec3 col = vec3(g);\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}