{
    "Shader": {
        "info": {
            "date": "1632193637",
            "description": "A bumpy hilly landscape based on Karang's [url=https://www.shadertoy.com/view/XdVSW1]\"Desert biome\"[/url] shader.",
            "flags": 0,
            "hasliked": 0,
            "id": "7dyGWV",
            "likes": 6,
            "name": "Insane Bumpy Terrain",
            "published": 3,
            "tags": [
                "procedural",
                "terrain",
                "mountain",
                "desert",
                "hill"
            ],
            "usePreview": 0,
            "username": "jarble",
            "viewed": 309
        },
        "renderpass": [
            {
                "code": "////////////////////////////////\n// Terrain generation section //\n////////////////////////////////\n\nfloat snoise(vec2 p) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\nfloat terrain(in vec2 uv,int octaves)\n{\n    //float scale_factor = 1.;\n    //uv /= scale_factor;\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = .25;\n    float n1 = 0.;\n    \n    //float f2 = .1; //this constant changes the variation in mountain height\n    \n    //float f1 = f2;\n    //float f3 = 1.-f1;\n    //vec2 uv1 = uv;\n    for (int i = 0; i < octaves; i++)\n    {\n        //uv += vec2(amplitude,freq);\n        float n2 = noise((uv) * freq);\n        n1 = abs(n2+n1+freq);\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        \n        \n        value = (value-n1 * amplitude);\n        freq *= 1.5+1./(1.+amplitude);\n        amplitude *= (1./(1.+freq));\n        \n\n        uv = uv.yx+n1/(1.+amplitude);\n\n        //value *= .9-.1*noise(uv/freq); //dunes\n\n\n}\n    return value;\n}\n\n\nvec2 map(vec3 p, int octaves) {\n\tfloat dMin = 28.0;\n\tfloat d;\n\tfloat mID = -1.0;\n\t\n\t// Mountains\n\tfloat h = terrain(p.xz, octaves);\n\t//h += smoothstep(0.0, 1.1, h);\n    //h += smoothstep(-0.1, 1.0, p.y)*0.6;\n\td = p.y - h;\n\tif (d<dMin) { \n\t\tdMin = d;\n\t\tmID = 0.0;\n\t}\n\n\treturn vec2(dMin, mID);\n}\n\n////////////////////\n// Render section //\n////////////////////\n\nvec2 castRay(vec3 ro, vec3 rd, int octaves) {\n\tconst float p = 0.001;\n\tfloat t = 0.0;\n\tfloat h = p * 2.0;\n\tfloat m = -1.0;\n\tfor (int i=0; i<36; i++) {\n\t\tif (abs(h)<=p || t>=28.0) break;\n        t += h;\n        vec2 res = map(ro + rd*t, octaves);\n        h = res.x;\n        m = res.y;\n\t}\n\tif (t>28.0) m = -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal(vec3 p, int octaves) {\n\tconst vec3 eps = vec3(0.002, 0.0, 0.0);\n\treturn normalize( vec3(map(p+eps.xyy, octaves).x - map(p-eps.xyy, octaves).x,\n\t\t\t       map(p+eps.yxy, octaves).x - map(p-eps.yxy, octaves).x,\n\t\t\t       map(p+eps.yyx, octaves).x - map(p-eps.yyx, octaves).x) );\n}\n\nfloat shadows(vec3 ro, vec3 rd, float tMax, float k, int octaves) {\n    float res = 1.0;\n\tfloat t = 0.1;\n\tfor(int i=0; i<22; i++) {\n        if (t>=tMax) break;\n        float h = map(ro + rd*t, octaves).x;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return clamp(res, 0.2, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tconst int geoLOD = 4;\n\t\n\tvec2 res = castRay(ro, rd, geoLOD);\n\t\n\tvec3 lPos = normalize(vec3(1.0, 0.5, 0.0));\n\tvec3 lCol = vec3(1.0, 0.9, 0.8);\n\t\n\tvec3 pos = ro + rd*res.x;\n\t\n\t// mat -1 = Background / sky\n    vec3 color = vec3(0.45,0.5,0.6);\n    float sun = clamp(dot(rd,lPos),0.0,1.0);\n    color += 0.6 * lCol * sun*sun;\n    if (res.y < -0.5) {\n\t\treturn color;\n\t}\n    \n    vec3 skyColor = color;\n\t\n\tint norLOD = int(max(2.0, 12.0-11.0*res.x/28.0));\n\tvec3 nor = calcNormal(pos, norLOD);\n\t\n\t// mat 0 = Rock / mountain\n\tif (res.y>-0.5 && res.y<0.5) {\n\t\t// Base rock\n\t\tcolor = mix( vec3(0.4, 0.1, 0.0), vec3(0.7, 0.6, 0.3), step(0.9, nor.y) );\n\t\t\n\t\t// Layer noise\n\t\tfloat n = 0.5*(snoise(pos.xy*vec2(2.0, 15.0))+1.0);\n\t\tcolor = mix( vec3(0.6, 0.5, 0.4), color, n*smoothstep(0.0, 0.7, 1.0-nor.y) );\n\t\t\n        // Sand on top\n        color = mix(color, vec3(0.7, 0.6, 0.3), smoothstep(0.0, 0.2, nor.y-0.8));\n\t}\n\t// mat 1 = Sand\n\tif (res.y>0.5) {\n\t\t// Base sand and rock color\n\t\tcolor = mix( vec3(0.3, 0.2, 0.0), vec3(0.7, 0.6, 0.3), nor.y );\n\t}\n\t\n    // Lighting and shadows\n    float lAmb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float lDif = clamp( dot( nor, lPos ), 0.0, 2.0);\n\n    if (lDif>0.05) lDif *= shadows(pos, lPos, 8.0, 12.0, geoLOD);\n\n    color += (0.4*lAmb) * lCol;\n    color *= (1.8*lDif) * lCol;\t\n    \n\t// Fog\n\tfloat fog = exp(-0.003 *res.x*res.x);\n\tcolor = mix(skyColor, color, fog);\n\t\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0;\n\tpos.x *= iResolution.x / iResolution.y;\n    float t1 = iTime;\n\t// Camera\n\tfloat x = 0.0 + (0.5*t1);\n\tfloat y = 0.0;\n\tfloat z = 0.0 + sin(0.1*t1)*2.;\n\tvec3 cPos = vec3(x, y, z);\n\tcPos.y = terrain(cPos.xz, 1) + 2.5;\n\t\n\tconst vec3 cUp = vec3(0., 1., 0.);\n\tvec3 cLook = vec3(cPos.x + 1.0, cPos.y*0.85, 0.0);\n\t\n\t// Camera matrix\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + 2.0*ww );\n\t\n\t// Render\n\tvec3 color = render(cPos, rd);\n\t\n\tfragColor = vec4( color, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}