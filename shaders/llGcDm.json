{
    "Shader": {
        "info": {
            "date": "1662423684",
            "description": "Converting form Hilbert to raster order, or from raster to Hilbert, and seeing how that affects different shapes.",
            "flags": 0,
            "hasliked": 0,
            "id": "llGcDm",
            "likes": 144,
            "name": "Linear To Hilbert",
            "published": 3,
            "tags": [
                "2d",
                "hilbert"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 3749
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2022\n\n// I'm drawing some shapes in a pixel buffer as usual where pixels are ordered\n// in \"raster\" or \"linear\", that is, left to right one row at a time, and then\n// repositioning all pixels back into the buffer following a hilbert curve.\n//\n// That is the TRANSFORM set to 0 below. You can set TRANSFORM to 1 to see the\n// opposite - drawing shapes into a buffer that has a hilbert curve in it just\n// to then stretch it into a linear string that we lay again over the plane in\n// regular \"raster\" order.\n\n\n// 0: linear  -> hilbert\n// 1: hilbert -> linear\n#define TRANSFORM 0\n\n\n// adapted from https://en.wikipedia.org/wiki/Hilbert_curve\nint hilbert( ivec2 p, int level )\n{\n    int d = 0;\n    for( int k=0; k<level; k++ )\n    {\n        int n = level-k-1;\n        ivec2 r = (p>>n)&1;\n        d += ((3*r.x)^r.y) << (2*n);\n    \tif (r.y == 0) { if (r.x == 1) { p = (1<<n)-1-p; } p = p.yx; }\n    }\n    return d;\n}\n\n// adapted from  https://en.wikipedia.org/wiki/Hilbert_curve\nivec2 ihilbert( int i, int level )\n{\n    ivec2 p = ivec2(0,0);\n    for( int k=0; k<level; k++ )\n    {\n        ivec2 r = ivec2( i>>1, i^(i>>1) ) & 1;\n        if (r.y==0) { if(r.x==1) { p = (1<<k) - 1 - p; } p = p.yx; }\n        p += r<<k;\n        i >>= 2;\n    }\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // work in integer coordinates please\n    ivec2 ip = ivec2(fragCoord);\n    ivec2 ir = ivec2(iResolution);\n\n    // select hilbert resolution\n    int             level =  7;\n    if( ir.x> 512 ) level =  8;\n    if( ir.x>1024 ) level =  9;\n    if( ir.x>2048 ) level = 10;\n\n    // two square's bottom-left corner coordinates\n    int res = (1<<level);\n    ivec2 c1 = ivec2( (ir.x-2*res)/3, (ir.y-1*res)/2 );\n    ivec2 c2 = ivec2( c1.x+res+c1.x, c1.y );\n\n    // distance to two squares\n    ivec2 e1 = abs(ip-c1-res/2)-res/2; int d1 = max(e1.x,e1.y);\n    ivec2 e2 = abs(ip-c2-res/2)-res/2; int d2 = max(e2.x,e2.y); \n        \n    // twitter \"dark\" mode background        \n    vec3 col = vec3(20,30,40)/255.0; \n    vec2 p;\n        \n    // inside left square\n    if( d1<0 )\n    {\n        #if TRANSFORM==1\n        int id = (ip.y-c1.y)*res + (ip.x-c1.x);\n        p = vec2( ihilbert(id,level) ) / float(res);\n        #else    \n        int i = hilbert(ip-c1,level);\n        p = vec2( i%res, i/res ) / float(res);\n        #endif\n    }\n    // inside right square\n    else if( d2<0 )\n    {\n        p = vec2(ip-c2)/float(res);\n    }\n    // otherwise, exterior\n    else\n    {\n        // border color\n        if( min(d1,d2)<8 ) col*=3.5;\n        fragColor = vec4(col,1.0);\n        return;\n    }\n    \n    // animate\n    int id = int(floor(iTime/4.0)) % 4;\n    float t = 0.5 - 0.5*cos(6.283185*iTime/4.0);\n\n    // render\n    float f = 0.0;\n    \n    // horizontal line\n    if( id==0 ) { f = abs(p.y-t); f = 1.0-smoothstep( 0.00, 0.02, f ); }\n    // vertical line\n    if( id==1 ) { f = abs(p.x-t); f = 1.0-smoothstep( 0.00, 0.10, f ); }\n    // circle\n    if( id==2 ) { f = abs(length(p-0.5)-0.5*t); f = 1.0-smoothstep( 0.00, 0.08, f ); }\n    // circular waves\n    if( id==3 ) \n    {\n        t = -6.283185*2.0*fract(iTime/4.0);\n        float l = length(p-0.5);\n        f  = 1.0*sin(  20.0*l+0.0 + t*1.0);\n        f += 0.5*sin(  56.0*l+1.0 + t*1.3);\n        f += 0.3*sin(  82.0*l+2.0 + t*2.1);\n        f += 0.2*sin( 132.0*l+3.0 + t*2.7);\n        f -= 0.2;\n        f = smoothstep(0.0,1.0,f);\n    }\n\n    // put color\n    col = mix( col, vec3(1.0), f );\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}