{
    "Shader": {
        "info": {
            "date": "1667432233",
            "description": "exploring some more ideas with reaction diffusion\nsome kind of smoke trail that generates stacking slime\na bit hacky and incomplete but I like the look so I'm saving this and iterating onwards",
            "flags": 32,
            "hasliked": 0,
            "id": "ms23RW",
            "likes": 9,
            "name": "reaction diffusion experiment 3",
            "published": 3,
            "tags": [
                "reactiondiffusion"
            ],
            "usePreview": 0,
            "username": "ufffd",
            "viewed": 324
        },
        "renderpass": [
            {
                "code": "const int DEBUG = 0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/R.xy;\n    vec2 muv = iMouse.xy/R.xy;\n    \n    // fetch buffers\n    vec4 buffA = texture(iChannel0,uv);\n    vec4 buffB = texture(iChannel1,uv);\n\n    // fragColor = vec4(vec3(1.-texture(iChannel1,uv,5.5).a),1.); return;\n    \n    // if (iMouse.z>0.5 && muv.x<uv.x) {\n    if (uv.x+uv.y<1.) {\n        // fragColor = vec4(buffB.rrr,1.); return;\n    }\n    \n    // debug\n    if (DEBUG==1)\n        fragColor = 1.-buffA;\n    if (DEBUG==2)\n        fragColor = 1.-buffB;\n    if (DEBUG==3)\n        fragColor = buffB - buffA;\n    if (DEBUG==4)\n        fragColor = vec4(buffB.ab, buffA.ab);\n    if (DEBUG!=0) return;\n\n    // colorize\n    vec3 col = buffB.bbb / buffB.aaa;\n    col = smoothstep(0.2,0.9,col);\n    \n    col *= buffA.a;\n    col.b += buffA.b*0.4;\n    col.r += buffA.b*buffA.b*buffA.b*0.8;\n    col.g *= 1.-buffA.b;\n    col -= smoothstep(0.5,0.9,buffA.b);\n    col.b += smoothstep(0.99,1.,buffA.b)*.7;\n    \n    col.r *= .2;\n    col.g *= uv.y;\n    \n    col = 1. - col;\n    col.r *= col.r;\n    col.b *= col.r;\n    col = 1. - col;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"smoke\"\nvec2 laplacianAB(in vec2 xy) {\n    vec2 sum = vec2(0.);\n    vec2 px = 1./iResolution.xy;\n    px *= 3.;\n    int range = 1;\n    for (int i=-range;i<range+1;i++){\n        for (int j=-range;j<range+1;j++){\n            vec2 offset = vec2(float(i),float(j))*px;\n            float factor = 0.05;\n            if (i==0||j==0) factor = 0.2;\n            if (i==0&&j==0) factor = -1.;\n            if (i<-1||j<-1) factor = 0.02;\n            if (i>1||j>1) factor = 0.02;\n            sum += texture(iChannel0,xy+offset).ab*factor;\n        }\n    }\n    px *= 1.;\n    range = 1;\n    for (int i=-range;i<range+1;i++){\n        for (int j=-range;j<range+1;j++){\n            vec2 offset = vec2(float(i),float(j))*px;\n            float factor = 0.05;\n            if (i==0||j==0) factor = 0.2;\n            if (i==0&&j==0) factor = -1.;\n            if (i<-1||j<-1) factor = 0.025;\n            if (i>1||j>1) factor = 0.025;\n            sum += texture(iChannel0,xy+offset).ab*factor;\n        }\n    }\n    return sum / 2.;\n}\n\nvec2 setAB(in vec2 xy, in float cdist) {\n\n    float dA = 0.95;\n    float dB = .3;\n    float feed = 0.06 + sin(iTime*4.)*0.05;\n    float k = 0.06 + 0.01*sin(iTime);\n\n    float a = texture(iChannel0,xy).a;\n    float b = texture(iChannel0,xy).b;\n    vec2 lapAB = laplacianAB(xy);\n    return vec2(\n        a +\n        dA * lapAB.x -\n        a * b * b +\n        feed * (1. - a),\n        b +\n        dB * lapAB.y +\n        a * b * b -\n        (k + feed) * b\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/R.xy;\n    vec2 muv = iMouse.xy/R.xy;\n    vec2 uvc = (fragCoord*2. - R.xy)/R.y;\n    vec2 muvc = (iMouse.xy*2. - R.xy)/R.y;\n    float mdist = distance(uvc,muvc);\n    float cdist = length(uvc);\n    \n    vec2 offset = vec2(0.,0.001) + noise(vec3(uvc,iTime*0.5))*0.01;\n    fragColor.ab = setAB(uv-offset,cdist);\n    if (iMouse.z > 0.5 && mdist<0.1) { \n        fragColor.b = 1.; \n        fragColor.a = 0.; \n    }\n    \n    // init animation\n    if (iMouse.z < 0.00001) {\n        vec2 p = vec2(0.,.75);\n        p.x += sin(iTime)*0.666;\n        p.x += sin(iTime*3.3)*0.25;\n        p.x += smoothstep(.1,.9,sin(iTime*.5)*0.5+0.5)*1.4 - 0.7;\n        p.y += sin(iTime*3.7)*0.05;\n        p.y -= smoothstep(.4,.9,sin(iTime*0.2)*.5+.5)*1.5;\n        float pdist = distance(uvc, p);\n        if (pdist < .1+sin(iTime*1.6)*.05) {\n            fragColor.b = 1.;\n            fragColor.a = 0.;\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"slime\"\nvec2 laplacianAB(in vec2 xy) {\n    vec2 sum = vec2(0.);\n    vec2 px = 1./iResolution.xy;\n    px *= 1.;\n    int range = 1;\n    for (int i=-range;i<range+1;i++){\n        for (int j=-range;j<range+1;j++){\n            vec2 offset = vec2(float(i),float(j))*px;\n            float factor = 0.05;\n            if (i==0||j==0) factor = 0.2;\n            if (i==0&&j==0) factor = -1.;\n            if (i<-1||j<-1) factor = 0.02;\n            if (i>1||j>1) factor = 0.02;\n            sum += texture(iChannel0,xy+offset).ab*factor;\n        }\n    }\n    return sum;\n}\n\nvec2 setAB(in vec2 xy, in float cdist) {\n\n    float dA = 1.1;\n    float dB = .35;\n    float feed = 0.055;\n    float k = 0.059;\n\n    float a = texture(iChannel0,xy).a;\n    float b = texture(iChannel0,xy).b;\n    vec2 lapAB = laplacianAB(xy);\n    return vec2(\n        a +\n        dA * lapAB.x -\n        a * b * b +\n        feed * (1. - a),\n        b +\n        dB * lapAB.y +\n        a * b * b -\n        (k + feed) * b\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (R.y-fragCoord.y<1.5) {fragColor = vec4(0.);return;} // skip the top pixel row to avoid artifacts\n    vec2 uv = fragCoord/R.xy;\n    vec2 muv = iMouse.xy/R.xy;\n    vec2 uvc = (fragCoord*2. - R.xy)/R.y;\n    vec2 muvc = (iMouse.xy*2. - R.xy)/R.y;\n    float mdist = distance(uvc,muvc);\n    float cdist = length(uvc);\n    \n    vec2 px = 1./iResolution.xy;\n\n    /* \n       slime stacking:\n       this works by comparing mipmaps at the current location vs \n       a location below to get a \"slime differential\" (?).\n       this was coded by feel, I think this general method could \n       be tuned to be more interesting or \"realistic\"\n   */\n    float drip_speed = 1.;\n    vec2 look_below = vec2(0,.05);\n    look_below.x += noise(vec3(uvc,iTime))*px.x; // fuzz left and right slightly\n    // check how much \"slime\" is below\n    float slime_below = texture(iChannel0, uv-look_below, 4.).a;\n    // wider \"slime\" check\n    slime_below += texture(iChannel0, uv-look_below*2., 8.).a;\n    // negative check within current space - to avoid slime columns\n    slime_below /= .2+.8*texture(iChannel0, uv, 4.).a;\n    slime_below = smoothstep(2.,.5,slime_below);\n    fragColor.r = slime_below/2.; // debug\n    drip_speed *= 1.-slime_below;\n    // slow down at the bottom\n    drip_speed *= 0.1+0.9*smoothstep(0.02,0.2,uv.y);\n    // drip\n    uv.y += drip_speed*px.y;\n    \n    float xoffset = -uvc.x*px.x;\n    uv.x += mix(0.,xoffset,slime_below);\n    // uv.x += sin(slime_below*3.)*px.x;\n    \n    vec2 buffA = texture(iChannel1,uv).ab;\n    \n    fragColor.ab = mix(\n        mix(setAB(uv,cdist),vec2(0.),0.001),\n        buffA,\n        (1.-buffA.x)*0.05\n      );\n    if (iMouse.z > 0.5) {\n        if (mdist<0.05) { fragColor.b = 1.; fragColor.a = 0.; }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define R iResolution\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat nsin(in float a) {\n    return sin(a)*0.5+0.5;\n}\n\n\n// hashes from Dave Hoskins https://www.shadertoy.com/view/4djSRW\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// 3D noise from IQ\n// returns 3D value noise\nfloat noise( in vec3 x ) {\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    \n    // gradients\n    vec3 ga = hash33( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash33( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash33( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash33( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash33( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash33( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash33( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash33( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    return va + \n           u.x*(vb-va) + \n           u.y*(vc-va) + \n           u.z*(ve-va) + \n           u.x*u.y*(va-vb-vc+vd) + \n           u.y*u.z*(va-vc-ve+vg) + \n           u.z*u.x*(va-vb-ve+vf) + \n           u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}