{
    "Shader": {
        "info": {
            "date": "1549611208",
            "description": "Inspired by dr2's Molecular Dynamic (https://www.shadertoy.com/view/4dG3RW)\nmade my version using grids to store particles, which is more efficient\nIt's fun to watch two gases mix and fill the space",
            "flags": 32,
            "hasliked": 0,
            "id": "td2Gzc",
            "likes": 56,
            "name": "Molecular diffusion with grid",
            "published": 3,
            "tags": [
                "collision",
                "particles",
                "gas",
                "moleculardiffusion"
            ],
            "usePreview": 0,
            "username": "archee",
            "viewed": 1526
        },
        "renderpass": [
            {
                "code": "/*\n\nEvery particle is stored in the grid by the integer part of it's coordinates.\nColors and masses are stored in every odd line of the off screen surfaces\nA grid can't be shared by more than one particle. In that rare case their \nmass get's combined and displayed as a bug. However it's possible to implement a \nmechanism that splits them into multiple particles again.\n\nPlay with gravity, grid size and bounciness.\n\nEnergy loss also occours when a particle tries to go faster than the speed limit,\nwhich is one grid/frame, and also when more than 2 particles collide in the same time, \nor with the wall.\nBuffer B can measure and display the total kinetic energy of the particles.\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pixel = uv*vec2(float(GridX),float(GridY));\n    vec2 grid = floor(uv*vec2(float(GridX),float(GridY)));\n    float pixelsize = float(GridX)/iResolution.x;\n    vec3 col = vec3(0.0,0.,0.3);\n\n    float minrad = Radius;\n    for(int y=-1;y<=1;y++) // check surrounding grids for particle\n        for(int x=-1;x<=1;x++)\n        {\n            vec2 grid2 = grid+vec2(float(x),float(y));\n            vec2 pos = getPos(grid2);\n            float d = length(pixel-pos);\n            if (d<minrad && pos.x!=0.0)\n            {\n                float aa = min((minrad-d)/pixelsize,1.);\n                minrad = d;\n                vec3 moleculecolor = getColorSize(grid2).xyz;\n                \n                // show buggy joint particles blinking\n                if (getColorSize(grid2).a>1.0) moleculecolor = vec3(1.,1.,1.)*(iFrame%40>20?1.0:0.7);\n                \n                col = mix(col,moleculecolor,aa);\n            }\n        }\n\n  // debug grids in use  \n//    if (getColorSize(grid).a!=0.0) col=mix(col,vec3(1.,1.,1.),getColorSize(grid).a*0.3);\n    \n    fragColor = vec4(col,1.0);\n    \n    // debug energy bar\n    vec4 bufB = textureLod(iChannel1,vec2(0.00001,0.00001),0.);\n    if (uv.y<0.01 && bufB.a>0.5)\n    {\n        float energy = bufB.x;\n        float avgenergy = energy/GridX/GridY;\n        fragColor = vec4( avgenergy*1000. > uv.x ,0.,0.,1.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// play values:\n#define GridX 180.          // any value between 20 to 300 is fine\n#define Bouncefac 1.0     // try 0.5 for nonelastic collisions\n#define Gravity -0.0000     // try -0.0003\n\n// fixed values\n#define GridY floor(GridX*9./16.)\n#define Radius 1.0 // minimum value would be sqrt(1*1 + 1*1)/2.0 + max_velocity * 2.  so 1.0 is a safe value\n#define getColorSize(grid) textureLod(iChannel0,(grid*vec2(1.,2.0)+vec2(5.1,11.1))/iResolution.xy,0.)\n#define getPos(grid) textureLod(iChannel0,(grid*vec2(1.,2.0)+vec2(5.1,10.1))/iResolution.xy,0.).xy\n#define getVel(grid) textureLod(iChannel0,(grid*vec2(1.,2.0)+vec2(5.1,10.1))/iResolution.xy,0.).zw\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 grid = floor(fragCoord.xy/vec2(1.0,2.0)-vec2(5.,5.));\n   \tfloat datai = floor(fract(fragCoord.y/2.0)*2.0);\n    if (grid.x>=float(GridX) || grid.y>=float(GridY) || grid.x<0. || grid.y<0.) {\n        fragColor = vec4(0.,0.,0.,0.);\n        return;\n    }\n    \n    vec2 newpos = vec2(0.,0.);\n    vec2 newvel = vec2(0.,0.);\n    vec4 newcolorsize = vec4(0.0,0.0,0.0,0.);\n    \n    \n    if (iFrame<5) // init\n    {\n        if (mod(grid.x,2.0)==1. && mod(grid.y,3.0)==1.)\n        {\n            newpos  = vec2(sin(grid.y)*0.5+0.5,sin(grid.x)*0.7+0.5)+grid; // middle of the grid\n            newvel = vec2(sin(grid.y),cos(grid.x*1.2))*0.3;\n            \n            \n            float diskrad = GridX*0.24;\n            if (length(grid-vec2(diskrad,diskrad*0.5))<diskrad) \n            {\n                newcolorsize = vec4(0.1,0.8,1.0,1.0);\n                newvel = vec2(0.,0.); // cold gas\n            }\n            if (length(grid-vec2(GridX-diskrad,diskrad))<diskrad)\n            {\n                newcolorsize = vec4(1.0,0.9,0.2,1.0);\n            }\n            \n            if (newcolorsize.a==0.0) newpos = vec2(0.,0.);\n        }\n    }\n    else\n    {\n        // check surrounding grid for particles that move to this one\n        for(int x=0;x<9;x++) // for some reason nested loops compiles wrong\n        {\n            vec2 grid2 = grid+vec2(float(x%3-1),float(x/3-1));\n\n            vec2 pos = getPos(grid2)+getVel(grid2);\n            vec2 vel = getVel(grid2);\n            vec4 colorsize = getColorSize(grid2);\n\n            if ( floor(pos)==grid)\n            {\n                newpos += pos*colorsize.a;\n                newvel += vel*colorsize.a;\n                newcolorsize.xyz += colorsize.xyz*colorsize.a;\n                newcolorsize.a += colorsize.a;\n            }\n        }\n        \n        if (newcolorsize.a>0.) // in case multiple particles hit occopy the same grid, combine their mass and average their data\n        {\n            newpos/=newcolorsize.a;\n            newvel/=newcolorsize.a;\n            newcolorsize.xyz/=newcolorsize.a;\n        }\n        \n    \n        // bouncing walls\n        if (newpos.x<Radius) newvel.x = abs(newvel.x);        \n        if (newpos.x>float(GridX)-Radius) newvel.x = -(newpos.x-float(GridX)+Radius); \n        if (newpos.y<Radius) newvel.y = abs(newvel.y);        \n        if (newpos.y>float(GridY)-Radius) newvel.y = -abs(newvel.y); \n    \n        // bouncing other molecules\n        vec2 orignewvel = newvel;\n        for(int y=-3;y<=3;y++)\n            for(int x=-3;x<=3;x++)\n            {\n                vec2 grid2 = grid+vec2(float(x),float(y));\n                vec2 pos = getPos(grid2)+getVel(grid2);\n                if (pos!=newpos && getColorSize(grid2).a>0.)\n                {\n                    if (length(pos-newpos)<Radius*2.)\n                    {\n                        vec2 normal = normalize(pos-newpos);\n                        vec2 veldif = orignewvel - getVel(grid2);\n                        newvel -= normal * max(dot(normal,veldif)*Bouncefac,0.);\n                    }\n                }\n            }\n\n         \n\t\tnewvel.y -= Gravity;  // gracity setting in Common:\n        float maxvel = 1.0; // make sure they don't jump over grids\n        if (length(newvel)>maxvel) newvel *= maxvel/length(newvel); \n    }\n    \n    fragColor = (datai==0.)?vec4(newpos,newvel):newcolorsize;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define MEASURE 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (MEASURE!=0)\n    {\n    vec2 pixel = floor(fragCoord.xy);\n   \n    if (pixel.x==0. && pixel.y==0.)\n    {\n        float energy= 0.;\n        \n        vec2 grid;\n        for(grid.y=0.;grid.y<GridY;grid.y+=1.0)\n        {\n            for(grid.x=0.;grid.x<GridX;grid.x+=1.0)\n            {\n                if (getColorSize(grid).w>0.0)\n                {\n                vec2 vel = getVel(grid);\n                energy += dot(vel,vel)*0.5;\n                }\n            }\n        }\n       \t\n        fragColor = vec4(energy,0.0,1.0,1.0);\n        return;\n    }\n    }\n    \n    discard;\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}