{
    "Shader": {
        "info": {
            "date": "1674286422",
            "description": "exercises done while going through thebookofshaders.com\nim bad at math so i write a lot of notes to try to understand better!",
            "flags": 0,
            "hasliked": 0,
            "id": "dlBGD1",
            "likes": 0,
            "name": "2.2 - Radial Values for Dummies",
            "published": 3,
            "tags": [
                "thebookofshaders"
            ],
            "usePreview": 0,
            "username": "retonym",
            "viewed": 213
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926535\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // EDIT: fixing screen ratio distortion. previously had overcomplicated stretching/ratio shenanigans\n    // fragCoord is a value anywhere from 0x0, to 945x531, representing the current pixel coordinates\n    // iResolution is just 945x531.\n    // uv is current pixel coordinate minus one half screen (x+y), to move it that half screen up+right to the center,\n    // divided by the y to get rid of the screen stretch\n    // this means (0,0) is now the center of the screen!\n    vec2 uv = (fragCoord - (.5 * iResolution.xy))/iResolution.y;\n    \n\n    //These are notes digging into the 'atan' part of this lesson: https://thebookofshaders.com/06/\n    //GOAL: draw a circle around the center of the screen and vary its color based on angle.\n\n\n    //RADIAL VALUES FOR DUMMIES\n \n       \n    //to map around a circle, we need to get the current pixel's angle relative to a\n    // baseline angle. we can get the angle of the vector from the center of the screen to the current pixel\n    // in radians, using atan\n    // ok that's a lot of math words. what the heck is atan?\n\n    // so... imagine that this pixel's distance from the center is drawn as a line from the center of the screen\n    // to the current pixel. A nice diagonal line.\n    \n    //      . < current pixel\n    //     /\n    //    /\n    //   /\n    //  . < center of screen\n    \n    // now imagine we draw out a horizontal line and a vertical line representing the \n    // 'height and width' of this diagonal.\n\n    //      .\n    //     /|\n    //    / |< height line\n    //   /  |\n    //  .___| \n    //    ^\n    //   width line\n    \n\n    // i'm bad at math but this link shows how the triangle's left-side angle value changes based on \n    // the horizontal line length and vertical line length: \n            // mathopenref.com/arctan.html\n\n    // i'm still not sure what exactly arctan (long name for atan) is doing inside the math black box \n        // that is its function, \n    // but it seems that when you write out atan(height, width) \n    // what you're essentially doing is giving atan the height line and width line, and then it uses that\n    // to find and return the angle of the that inner corner of the triangle shown above. \n\n    float angleInRadians = atan(uv.y, uv.x);\n    \n    // this angle isn't in degrees, but in radians. \n    // we actually don't need to convert it to degrees. We just want to remap any output values\n    // we get from atan across a 0 to 1 space, where 0 = -180 degrees and 1 = 180 degrees.\n    \n    // right now the minimum angleInRadians we will ever get as output is -PI. -PI radians is -180 degrees.\n    // and the maximum angleInRadians we will ever get as output is PI. PI radians is 180 degrees.\n    // this is just how arctan works, those are the most extreme values it can put out.\n    \n    // so you can think of our output values as falling across a -PI to PI range\n    // (i'm gonna think of this as a -3.14 to 3.14 range for ease of visualization.)\n    \n    // .[-3].....[-2].....[-1].....[0].....[1].....[2].....[3].\n\n    // and the output values falling across that range, i want to squish down into a 0 to 1 range\n\n    //                      [-.5]..[0]..[.5]\n\n    // as you can see, the big range is ~6.28 times as big as the small range\n    // which means any output values i get from arctan are also ~6.28 times too big\n    // so i can take my output values, and divide them by ~6.28 to squish em down into this 0 to 1 space.\n\n    float zeroToOneRadialValue = angleInRadians / (2.0 * PI);\n\n    // then i need to add .5 to my output values to shift them from a (-.5, .5) range up into a (0, 1) range\n    \n    //                             [0].....[1]\n    \n    zeroToOneRadialValue += 0.5;\n    \n    // great, now we have a radial gradient going from -180 to 180.\n    // use this line as the final output to preview how it looks when red is mapped across this gradient!\n    //fragColor = vec4(zeroToOneRadialValue, 0, 0, 1);\n\n\n    // now if i wanna turn this into a rainbow circle\n    // i can do that by picturing a 'venn diagram' of colors: red, green, blue, red.\n    // when these colors overlap each other they form the entire rainbow spectrum.\n    //  (     R   { Y )   G   [ GB }   B   ( V ]   R     )\n    // so i just wanna map these 4 colors across my 0-1 space.\n    \n\n\n    // EDIT: to get a color band with a soft falloff, i'll use... SMOOTHSTEP (ty FabriceNeyret2!):\n    \n    // smoothstep( floor, ceiling, abs(x - c) )\n    \n    // this is tricky to visualize at first, but imagine x is a horizontal space, and\n    // c is the spot we want to place our color band gradient in that space.\n    // when you draw abs(x - c) it is basically a positive value that bounces off 0 at the spot we want our gradient.\n\n    //      \\  /\n    //  0....\\/.............\n    //       c\n\n    // smoothstep takes those values, and clamps em into a curve between 2 ceiling and floor values provided.\n    // then whatever the resulting values are, it remaps across a 0-1 space.\n    \n    // so when smoothstep clamps that abs(x-c) in between the floor and ceiling values, and remaps them, we get this:\n\n\n    //                 smoothstep( 0, w, abs(x - c) )\n    //bright color (1)   ______    __________\n    //                         \\  /\n    //black  (0)                \\/\n\n\n    // essentially x is flooded with color except for a black gradient band right at that bounce point.\n    // to invert the gradient you can swap the ceiling and floor values, then you get this:\n    \n\n    //                 smoothstep( w, 0, abs(x - c) )\n    //bright color (1)    \n    //                          /\\ \n    //black  (0)         ______/  \\__________\n\n\n    //phew! then you can just map that gradient across your radial space instead of a horizontal one.\n\n        \n    float redGradient1 = smoothstep(.5, 0.0, abs(zeroToOneRadialValue));\n    float greenGradient = smoothstep(.35, 0.0, abs(zeroToOneRadialValue - .35));\n    float blueGradient = smoothstep(.35, 0.0, abs(zeroToOneRadialValue - .65));\n    float redGradient2 = smoothstep(.5, 0.0, abs(zeroToOneRadialValue - 1.0));\n    \n    \n    vec4 rainbowGradient = vec4(redGradient1 + redGradient2, greenGradient, blueGradient, 1);\n    \n    //i want red at the start and at the end so that the gradient loops/tiles nicely.\n    \n    // use this line as the final output to preview how the rainbow gradient looks!\n    //fragColor = rainbowGradient;\n    \n    \n    \n    \n    // the last thing i want to do is put this inside a circle.\n    // i can draw a circle by checking the distance of the current pixel from the center of the screen\n    // and using a step function to set the color to black if the pixel is outside the radius.\n    //EDIT: don't need to do distance from 0,0. use len :)\n    float len = length(uv);\n    len = step(.5, 1.0-len);\n     \n    //then just combine the circle and the rainbow!\n    fragColor = len * rainbowGradient;\n\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}