{
    "Shader": {
        "info": {
            "date": "1468439472",
            "description": "Trying to implement the old school effect rubber glenz from amiga 500\nHold LMB to disable transparency",
            "flags": 0,
            "hasliked": 0,
            "id": "4lt3R7",
            "likes": 19,
            "name": "Old School Rubber Glenz",
            "published": 3,
            "tags": [
                "raymarching",
                "transparency",
                "oldschool",
                "glenz"
            ],
            "usePreview": 0,
            "username": "Himred",
            "viewed": 1128
        },
        "renderpass": [
            {
                "code": "/*\nA try of implementation of the old school effect rubber glenz (first seen on Amiga in 1991).\n\nThe code is *NOT* optimized at all\nIt was coded as a proof of concept and a personal challenge (don't laugh).\n\nI borrowed some code (thats the concept of shadertoy isnt'it ?) from:\nLighting stuff: https://www.shadertoy.com/view/MdGXWG by Shane\nOriginal tentative of glenz: https://www.shadertoy.com/view/ldlSW2 by rix\nrgb bars: I was unable to find the shader where i copied the code :(\n\nHold LMB to disable transparency\n\n*/\n\nvec3 cubevec;\n\n// Sinus bars function\nvec3 calcSine(vec2 uv, float frequency, float amplitude, float shift, float offset, vec3 color, float width, float exponent)\n{\n    float y = sin(iTime * frequency + shift + uv.x) * amplitude + offset;\n    float d = distance(y, uv.y);\n    float scale = smoothstep(width, 0.0, distance(y, uv.y));\n    return color * scale;\n}\n\n// Render the bars calling 3 CalcSines() and adding rgb componants\nvec3 Bars(vec2 f)\n{\n    vec2 uv = f / iResolution.xy;\n    vec3 color = vec3(0.0);\n    color += calcSine(uv, 2.0, 0.25, 0.0, 0.5, vec3(0.0, 0.0, 1.0), 0.1, 3.0);\n    color += calcSine(uv, 2.6, 0.15, 0.2, 0.5, vec3(0.0, 1.0, 0.0), 0.1, 1.0);\n    color += calcSine(uv, 0.9, 0.35, 0.4, 0.5, vec3(1.0, 0.0, 0.0), 0.1, 1.0);\n    return color;\n}\n\n// Classic iq twist function\nvec3 Twist(vec3 p)\n{\n    float f = sin(iTime/3.)*1.45;\n    float c = cos(f*p.y);\n    float s = sin(f/2.*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// The distance function which generate a rotating twisted rounded cube \n// and we save its pos into cubevec\nfloat Cube( vec3 p )\n{\n    p=Twist(p);\n    cubevec.x = sin(iTime);\n    cubevec.y = cos(iTime);\n    mat2 m = mat2( cubevec.y, -cubevec.x, cubevec.x, cubevec.y );\n    p.xy *= m;p.xy *= m;p.yz *= m;p.zx *= m;p.zx *= m;p.zx *= m;\n    cubevec = p;\n    return length(max(abs(p)-vec3(0.4),0.0))-0.08;\n}\n\n// Split the face in 4 triangles zones\n// return color index 0 or 1 if color1 or color2\nfloat Face( vec2 uv )\n{\n        uv.y = mod( uv.y, 1.0 );\n        return ( ( uv.y < uv.x ) != ( 1.0 - uv.y < uv.x ) ) ? 1.0 : 0.0;\n}\n\n//Classic iq normal\nvec3 getNormal( in vec3 p )\n{\n    vec2 e = vec2(0.005, -0.005);\n    return normalize(\n        e.xyy * Cube(p + e.xyy) +\n        e.yyx * Cube(p + e.yyx) +\n        e.yxy * Cube(p + e.yxy) +\n        e.xxx * Cube(p + e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = fragCoord.x;\t\t\t\t\t\t// Save x for shorter code\n    float pat = iTime*5.0;\t\t\t\t// Precalc 5time for later use\t\t\t\t\n    float Step = 1.0;\t\t\t\t\t\t\t// For raymarching\n    float Distance = 0.0;\t\t\t\t\t\t// For raymarching\n    float Near = -1.0;\t\t\t\t\t\t\t// Near color index\n    float Far = -1.0;\t\t\t\t\t\t\t// Far color index\n    vec3 lightPos = vec3(1.5, 0, 0);\t\t\t// Light position\n    vec2 kp = fragCoord.xy / iResolution.xy;\t// Normalized coords\n    vec2 p = -1.0 + 2.0*kp;\t\t\t\t\t\t// Uv\n    vec4 m = iMouse / iResolution.xxxx;\t\t\t// Mouse status\n    float hd=-1.;\t\t\t\t\t\t\t\t// Hit Distance\n    float ay=max(0.1,0.5-iTime/6.);\t\t// For opening the screen\n     \n    // Non standard Raymarching\n    // When we hit a face, we continue to march, so the ray goes into the cube\n    // But we keep in Near the color index of the first face hit by the ray\n    // We also keep in Far the last color index the ray hit\n    // We break when 256 steps has been done or distance > 4\n    // Finnaly we get in Near and Far vars the coloring values to simulate the transparency\n    \n    p.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3( 0.0, 0.0, 2.1 );\n    vec3 rd = normalize( vec3( p, -2. ) );\n    for( int i = 0; i < 256; i++ )\n        {\n        \tStep = Cube( ro + rd*Distance );\n            Distance += Step*.5;\n\n            if( Distance > 4.0 ) break;\n            if( Step < 0.001 )\n            \t{\n                    // Getting the color index of hit point\n                 \tFar = Face( cubevec.yx ) + Face( -cubevec.yx ) + Face( cubevec.xz ) + Face( -cubevec.xz ) + Face( cubevec.zy ) + Face( -cubevec.zy );\n                    // save in hd the first hit distance for later lighting\n            \t\tif(hd<0.) hd=Distance;\n                    // Save Far as Near on first hit\n                    if( Near < 0.0 ) Near = Far;\n                    // If transparency is not disabled lets keep walking into the cube\n                    // Or maybe outside. Otherwise break\n            \t\tif(m.z<=0.0) Distance += 0.05; else break; // 0.05 is a magic number \n                }\n        }\n\n    // Initialize the background color to the sinus bars\n    vec3 Color=Bars(fragCoord);\n    \n    // if we hit something\n    if( Near > 0.0 )\n    \t{\n          \t// lighting stuff (taken from a Shane shader)\n            vec3 sp = ro + rd*hd;\n        \tvec3 ld = lightPos - sp;\n            float lDist = max(length(ld), 0.001);\n            ld /= lDist;\n            float atten = 1./(1. + lDist*.2 + lDist*.1); \n            float ambience = 0.7;\n            vec3 sn = getNormal( sp);\n            float diff = min(0.3,max( dot(sn, ld), 0.0));\n            float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n            \n            // Simulating transparency with mix() Near and Far\n            if(m.z<=0.) Color = Color/5. + mix( vec3( 0.2, 0.0, 1.0 ), vec3( 1.0, 1.0, 1.0 ), vec3( ( Near*0.45 + Far*Far*0.04 ) ) );\n            else Color = mix( vec3( 0.2, 0.0, 1.0 ), vec3( 1.0, 1.0, 1.0 ), vec3( ( Near*0.45 + Far*Far*0.04 ) ) );\n            \n            // Applying the lighting to color\n            Color = Color*(diff+ambience)+vec3(0.78,0.5,1.)*spec/1.5;\n        }\n\n    // The bottom and top rainbow lines\n    if (kp.y > ay && kp.y < ay+0.006 || kp.y > (1.-ay) && kp.y < 1.-ay+0.006 ) Color = vec3(0.5 + 0.5 * sin(x/120. + 3.14 + pat), 0.5 + 0.5 * cos (x/120. + pat), 0.5 + 0.5 * sin (x/120. + pat));\n    // The bottom and top purple zones\n    if(kp.y<ay || kp.y>1.-ay+0.006) Color=vec3(0.20,0.17,0.35);\n\n    // Presenting color to the screen\n    fragColor = vec4( Color, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 19,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}