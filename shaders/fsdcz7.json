{
    "Shader": {
        "info": {
            "date": "1653485561",
            "description": "Performing CSG operations on variable frequency, randomly rotated, offset grids to produce a fractal-like polygonal pattern mildly reminiscent of randomly subdivided Voronoi cells.",
            "flags": 0,
            "hasliked": 0,
            "id": "fsdcz7",
            "likes": 60,
            "name": "Random Grid Subdivision",
            "published": 3,
            "tags": [
                "2d",
                "fractal",
                "fbm",
                "csg",
                "hexagon",
                "square",
                "cell",
                "subdivision"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1152
        },
        "renderpass": [
            {
                "code": "/*\n\n    Random Grid Subdivision\n    -----------------------\n    \n    Performing CSG operations on variable frequency, randomly rotated, \n    offset grids to produce a fractal-like polygonal pattern mildly \n    reminiscent of randomly subdivided Voronoi cells... As you can see, \n    I'm really struggling to describe this. :D It's kind of a mixture of \n    fBm, CSG and subdivision. Either way, verbose description aside, these \n    things are easy to code.\n    \n    I came across Ruojake's cool \"Grids all the way down\" example the other \n    day. There are a few examples relating to it on Shadertoy, and each \n    involve randomly subdividing or partitioning cells in some way to form \n    a fractal-like pattern. I've used similar methods a few times on \n    Shadertoy.\n    \n    Anyway, this is just one of infinite variations possible. The process \n    is pretty simple: Render a grid, then in each cell, render a randomly \n    offset, rotated grid at a higher frequency (Make the cells smaller). \n    After that, repeat the step as many times as you want, and that's it.\n    \n    Which variation on the aforementioned you choose is up to you. Ruojake \n    chose the commonly occurring square grid, so just to be different, I've \n    adapted some old code to produce a hexagonally based one. The result is \n    interesting, but I prefer the more common square grid that most use. By \n    the way, I've provided that option below for anyone who'd like to see \n    that.\n    \n    Aesthetically, I kept things simple -- Just some basic coloring and \n    highlighting with a line overlay. I was tempted to make an extruded \n    version -- I know of at least one method that would work, but I didn't \n    have time to waste on this diversion in the first place, so I might \n    leave it at that... Actually, a globally illuminated wall refected \n    version would look nice... :)\n    \n    \n    \n    Other Examples:\n    \n    // Clean code and a nice result.\n    Grids all the way down - ruojake\n    https://www.shadertoy.com/view/fdccR8\n    \n    // A simpler line partitioned version.\n    Sloped Line Partitioning - Shane\n    https://www.shadertoy.com/view/fstcD7\n    \n*/\n\n// Using a hexagon grid based pattern, instead of a square one.\n#define HEXAGON\n\n// Random cell subdivsion: Commenting this out would mean compulsory cell \n// subdivision. Whether you leave this in or not depends on the look you're after.\n#define RANDOM_SUBDIVISION\n\n// Thick outer cell borders for a more cartoonish look.\n//#define THICK_BORDER\n        \n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n\n// Flat top or pointed top hexagon.\n#define FLAT_TOP_HEXAGON\n//\n// Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n// 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\n#ifdef FLAT_TOP_HEXAGON\nvec2 s = vec2(1.7320508, 1);\n#else\nvec2 s = vec2(1, 1.7320508);\n#endif\n\n\n// The 2D hexagonal isosuface function: If you were to render a horizontal line and one that\n// slopes at 60 degrees, mirror, then combine them, you'd arrive at the following. As an aside,\n// the function is a bound -- as opposed to a Euclidean distance representation, but either\n// way, the result is hexagonal boundary lines.\nfloat hex(in vec2 p){\n    \n    p = abs(p);\n    \n    #ifdef FLAT_TOP_HEXAGON\n    // Below is equivalent to:\n    //return max(p.x*.866025 + p.y*.5, p.y); \n\n    return max(dot(p, vec2(1.7320508, 1)*.5), p.y); // Hexagon.\n    #else\n    // Below is equivalent to:\n    //return max(p.x*.5 + p.y*.866025, p.x); \n\n    return max(dot(p, vec2(1, 1.7320508)*.5), p.x); // Hexagon.\n    #endif\n    \n}\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID -- in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything -- in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec4 getHex(vec2 p){\n    \n    // The hexagon centers: Two sets of repeat hexagons are required to fill in the space, and\n    // the two sets are stored in a \"vec4\" in order to group some calculations together. The hexagon\n    // center we'll eventually use will depend upon which is closest to the current point. Since \n    // the central hexagon point is unique, it doubles as the unique hexagon ID.\n    #ifdef FLAT_TOP_HEXAGON\n    vec4 hC = floor(vec4(p/s, p/s - vec2(1.7320508/3., .5))) + .5;\n    #else\n    vec4 hC = floor(vec4(p/s, p/s - vec2(.5, 1.7320508/3.))) + .5;\n    #endif    \n   \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    //vec4 h = p.xyxy - vec4(hC.xy + .5, hC.zw)*s.xyxy;\n    \n    \n    // Nearest hexagon center (with respect to p) to the current point. In other words, when\n    // \"h.xy\" is zero, we're at the center. We're also returning the corresponding hexagon ID --\n    // in the form of the hexagonal central point. By the way, the unique ID (the .zw bit), \n    // needs to be multiplied by \"s\" to give the correct quantized position back. \n    // For example: float ns = noise2D(hID*s);\n    //\n    // On a side note, I sometimes compare hex distances, but I noticed that Iomateron compared\n    // the squared Euclidian version, which seems neater, so I've adopted that. \n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + .5);\n\n}\n\n// A second offset distance field value. Used for hilighting.\nfloat dHi;\n\nvec3 distField(vec2 p){\n\n    // Set the distance (and highlight distance) to a minimum.\n    float d = -1e5;\n    dHi = -1e5;\n    \n    // Overal unique cell ID.\n    vec2 gIP = vec2(0);\n    \n    // Inititalize the scale to one.\n    float sc = 1.;\n    \n    // Directional light.\n    vec2 ld = normalize(vec2(1, 1.5));\n    \n    // Rotate and translate the coordinates and light.\n    p *= rot2(iTime/8.);\n    p -= iTime/16.;\n    ld *= rot2(iTime/8.);\n     \n   \n    // Six subdivided grid partitions.\n    for(int i = 0; i<6; i++){\n    \n        \n        // Get the hexagon (or square) grid information\n        // (local coordinates and cell ID) for this iteration.\n        #ifdef HEXAGON\n        vec4 p4 = getHex(p);\n        p = p4.xy;\n        vec2 ip = p4.zw;\n        d = max(d, hex(p) - .5/sc); // Hexagon distance.\n        dHi = max(dHi, (hex(p + ld*.001) - .5/sc)); // Highlight distance.\n        #else\n        vec2 ip = floor(p*sc) + .5;\n        p -= ip/sc;\n        d = max(d, sBoxS(p, vec2(.5/sc), 0.)); // Square distance.\n        dHi = max(dHi, sBoxS(p + ld*.001, vec2(.5/sc), 0.)); // Highlight distance.\n        #endif\n  \n        \n  \n        // Rescale the grid for the next iteration.\n        #ifdef HEXAGON\n        sc *= 1.4;\n        s /= 1.4;\n        #else\n        sc *= 1.5;\n        #endif\n        \n        // Update the overall cell ID.\n        gIP += ip/sc;    \n        \n        // Optional random rotation -- It looks more interesting, but\n        // it's not mandatory.\n        p *= rot2((hash21(gIP + .05) - .5)*6.2831);\n        ld *= rot2((hash21(gIP + .05) - .5)*6.2831);\n       \n        // Random translation.\n        p -= vec2(hash21(gIP + .13), hash21(gIP + .04))/sc*.75;\n        \n        #ifdef RANDOM_SUBDIVISION\n        // Random cell subdivsion. Commenting this out would mean compulsory\n        // cell subdivision. Whether you leave this in or not depends on what\n        // look you're after.\n        if(i>2 && hash21(gIP + .22)<.2) break;\n        #endif\n        \n        /*\n        // Internal moving rotation -- Interesting, but a bit much.\n        float dir = hash21(gIP + .07)<.5? -1. : 1.;\n        p *= rot2(dir*iTime/sc/8.);\n        ld *= rot2(dir*iTime/sc/8.);\n        */ \n        \n        // Extra temporal translation. Also not mandatory.\n        p -= iTime/32.;\n         \n        \n        \n    \n    }\n   \n    // Return the cell distance and unique ID.\n    return vec3(d, gIP);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Aspect corret coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    // Scale and smoothing factor.\n    const float sc = 1.;\n    float sf = sc/iResolution.y;\n    \n    \n    // Scaling and translation.\n    vec2 p = sc*uv;\n    \n    // Scene object -- Returns distance and ID.\n    vec3 d = distField(p); \n    \n    // Rendering onto the canvas.\n    \n    // ID based cell coloring.\n    float rnd = hash21(d.yz + .1);\n    float taper = rnd<.35? .7 : 1.;\n    vec3 oCol = .5 + .45*cos(6.2831*hash21(d.yz + .2)/5. + vec3(0, 1, 2)/taper);\n    if(rnd>=.35) oCol = mix(oCol.zyx, vec3(1)*dot(oCol, vec3(.299, .587, .114)), .75)/4.;\n    //else oCol = oCol.zyx;\n    \n    // Directional derivative bump map calculation for some highlighting.\n    float b = max(dHi - d.x, 0.)/.001;\n  \n    oCol = oCol*(.25 + b*.75)*1.35;\n   \n     \n    // Diagonal line pattern.\n    //\n    // Resolution independent line number -- Not PPI independent though.\n    float lns = 120.*iResolution.y/450.;\n    vec2 rp = rot2(-3.14159/3.)*p;\n    float pat = abs(fract((rp.x)*lns) - .5)*2. - .05;\n    pat = smoothstep(0., sf*lns*2., pat); \n    \n    float ew = .005*450./iResolution.y; // Resolution independent edge width.\n    \n    // Scene color.\n    vec3 col = oCol*(pat*1. + .5);\n    \n    // Cell border.\n    #ifdef THICK_BORDER\n    const float bw = .0025; // Border width.\n    #else\n    const float bw = .001; // Border width.\n    #endif\n    // Border distance.\n    float dBord = abs(d.x + bw) - bw; \n    \n    // Application... There are definitely better ways, but I was pushed for time.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dBord - ew))*.25); // Inner gradient.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, dBord - ew - .005))*.8); // Inner edge.\n    col = mix(col, mix(oCol, vec3(1), .125), 1. - smoothstep(0., sf, dBord - ew)); // Colored edge.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dBord)); // Outer edge.\n    \n\n    // Vertical color gradient of sorts.\n    float grad = clamp(uv.y + .65, 0., 1.);\n    col = mix(col.yxz, col.zyx, grad*grad);\n    \n    // Red to blue colors.\n    //col = col.yxz;\n    \n    // Rough gamma correction and screen presentation.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}