{
    "Shader": {
        "info": {
            "date": "1530627719",
            "description": "The converse of Magritte's \"Time Transfixed\" painting (mouseable)",
            "flags": 0,
            "hasliked": 0,
            "id": "MdVBDK",
            "likes": 8,
            "name": "Time Released",
            "published": 3,
            "tags": [
                "time",
                "clock",
                "train",
                "surreal",
                "magritte"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 639
        },
        "renderpass": [
            {
                "code": "// \"Time Released\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// The converse of Magritte's \"Time Transfixed\" painting (mouseable)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nvec3 RgbToHsv (vec3 c);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define GEARS  1   // set = 0 to reduce work\n#define AA     0   // set = 1 for antialiasing\n\nvec3 carPos[3], qHit, qSmk, vnSmk, ltPos, ltDir, szClkCase;\nfloat dstFar, tCur, todCur, trnSzFac, trkWid, rlWid, rlHt, clkSzFac, ntt[12], gRot[6],\n   aVelFac, axDist, axRad, wlGap, ttWid, hFac1, hFac2, fadeCase;\nint idObj;\nbool visCase;\nconst int idEng = 11, idAxle = 12, idCar = 13, idWheel = 14, idCrod = 15, idFun = 16,\n   idCpl = 17, idLamp = 18, idRail = 19, idSlp = 20, idCase = 30, idGearS = 31, idGearB = 32,\n   idAxH = 33, idAxM = 34, idAxS = 35, idAxF = 36, idAxB = 37, idBar = 38, idRing = 39,\n   idFoot = 40, idBWal = 51, idWFrm = 52, idShlf = 53, idPil = 54, idFlr = 55;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat TrnEngDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float wRad, d, aw, sx, tw;\n  tw = trkWid + 0.02;\n  wRad = 0.8;\n  q = p;\n  d = min (max (max (PrBoxDf (q - vec3 (0., 0., -1.75), vec3 (1., 1.4, 0.6)),\n     - PrBoxDf (q - vec3 (0., 0., -1.95), vec3 (0.95, 1.3, 0.65))),\n     - PrBox2Df (q.yz - vec2 (0.7, -1.75), vec2 (0.5, 0.4))),\n     max (PrCylDf (q - vec3 (0., -2.4, -1.75), 4., 0.65), - (q.y - 1.35)));\n  d = min (d, max (PrCapsDf (q - vec3 (0., -0.2, 0.5), 1., 2.), - (q.z + 1.2)));\n  d = min (min (min (min (d, PrBoxDf (q - vec3 (0., -0.5, -3.15), vec3 (1., 0.7, 0.3))),\n     PrBoxDf (q - vec3 (0., -1.3, -0.25), vec3 (1., 0.1, 3.2))),\n     PrBoxDf (q - vec3 (0., -1.4, 3.), vec3 (1.1, 0.2, 0.07))),\n     PrCylDf (vec3 (abs (q.x) - 0.6, q.y + 1.4, q.z - 3.1), 0.2, 0.1));\n  DMINQ (idEng);\n  q.yz -= vec2 (-1.4, -3.5);\n  d = PrCylDf (q.xzy, 0.4, 0.03);\n  DMINQ (idCpl);\n  q = p;\n  d = min (PrCylDf ((q - vec3 (0., 1.1, 2.1)).xzy, 0.3, 0.5),\n     PrCylDf ((q - vec3 (0., 1.5, 2.1)).xzy, 0.4, 0.15));\n  d = min (d, PrCapsDf ((q - vec3 (0., 0.8, 0.5)).xzy, 0.3, 0.2));\n  DMINQ (idFun);\n  q = p;  q.yz -= vec2 (-0.2, 3.3);\n  d = PrCylDf (q, 0.2, 0.2);\n  DMINQ (idLamp);\n  q = p;  q.xz = abs (q.xz);  q -= vec3 (tw - 0.12, -1.4, 1.1);\n  d = min (max (min (PrCylDf (q.zyx, wRad, 0.1),\n     PrCylDf (q.zyx - vec3 (0.,0., -0.07), wRad + 0.05, 0.03)),\n     - PrCylDf (q.zyx, wRad - 0.1, 0.12)), PrCylDf (q.zyx, 0.15, 0.10));\n  q = p;  q.x = abs (q.x);  q -= vec3 (tw - 0.17, -1.4, 1.1 * sign (q.z));\n  aw = -1. * tCur / wRad;\n  q.yz = Rot2D (q.yz, aw);\n  q.yz = Rot2D (q.yz, 2. * pi * floor ((atan (q.y, q.z) + pi) * 8. / (2. * pi) + 0.5) / 8.);\n  q.z += 0.5 * wRad;\n  d = min (d, PrCylDf (q, 0.05, 0.5 * wRad));\n  DMINQ (idWheel);\n  q = p;  sx = sign (q.x);  q.x = abs (q.x);  q -= vec3 (tw + 0.08, -1.4, 0.);\n  aw -= 0.5 * pi * sx; \n  q.yz -= 0.3 * vec2 (cos (aw), - sin (aw));\n  d = PrCylDf (q, 0.04, 1.2);\n  q.z = abs (q.z);  q -= vec3 (-0.1, 0., 1.1);\n  d = min (d, PrCylDf (q.zyx, 0.06, 0.15));\n  DMINQ (idCrod);\n  q = p;  q.z = abs (q.z);  q -= vec3 (0., -1.4, 1.1);\n  d = PrCylDf (q.zyx, 0.1, tw - 0.1);\n  DMINQ (idAxle);\n  return dMin;\n}\n\nfloat TrnCarDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float wRad, d, tw;\n  wRad = 0.35;\n  tw = trkWid + 0.02;\n  q = p;\n  d = min (min (PrBoxDf (q, vec3 (1.3, 1.4, 2.8)),\n     max (PrCylDf (q - vec3 (0., -2.35, 0.), 4., 2.8), - (q.y - 1.4))),\n     PrBoxDf (q - vec3 (0., -1.6, 0.), vec3 (0.8, 0.3, 2.)));\n  DMINQ (idCar);\n  q = p;  q.z = abs (q.z);  q -= vec3 (0., -1.4, 2.9);\n  d = PrCylDf (q.xzy, 0.4, 0.03);\n  DMINQ (idCpl);\n  q = p;  q.xz = abs (q.xz);  q -= vec3 (tw - 0.1, -1.85, 1.1);\n  d = min (min (PrCylDf (q.zyx, wRad, 0.1),\n     PrCylDf (q.zyx - vec3 (0.,0., -0.07), wRad + 0.05, 0.03)),\n     PrCylDf (q.zyx, 0.15, 0.10));\n  q.x -= 0.1;\n  d = max (d, - PrCylDf (q.zyx, 0.2, 0.05));\n  DMINQ (idWheel);\n  q = p;  q.z = abs (q.z);  q -= vec3 (0., -1.85, 1.1);\n  d = PrCylDf (q.zyx, 0.1, tw - 0.15);\n  DMINQ (idAxle);\n  return dMin;\n}\n\nfloat TrnTrackDf (vec3 p, float r, float dMin)\n{\n  vec3 q;\n  float d;\n  p.yz -= vec2 (6., 9.5);\n  q = p;  q.y -= -0.4 * rlHt;  q.z = mod (q.z + 1., 2.) - 1.;\n  d = max (PrBoxDf (q.zyx, vec3 (0.2 * trkWid, 0.6 * rlHt, 1.3 * trkWid)), abs (p.z) - 9.5);\n  DMINQ (idSlp);\n  q = p;  q.y -= 0.7 * rlHt;  q.x = abs (q.x) - trkWid;\n  d = max (PrRoundBox2Df (q.yx, vec2 (rlHt, rlWid), 0.8 * rlWid), abs (p.z) - 9.5);\n  DMINQ (idRail);\n  return dMin;\n}\n\nfloat TrainDf (vec3 p)\n{\n  vec3 q;\n  float dMin, r, d;\n  dMin = dstFar / trnSzFac;\n  p /= trnSzFac;\n  r = length (p.xz);\n  dMin = TrnTrackDf (p, r, dMin);\n  q = p - carPos[0].xyz;\n  dMin = TrnEngDf (q, dMin);\n  for (int k = 1; k < 3; k ++) {\n    q = p - carPos[k].xyz;\n    dMin = TrnCarDf (q, dMin);\n  }\n  return trnSzFac * dMin;\n}\n\nfloat TrainRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = TrainDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 TrainNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (TrainDf (p + e.xxx), TrainDf (p + e.xyy), TrainDf (p + e.yxy), TrainDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec4 TrainCol ()\n{\n  vec4 col4, carCol, carCol2;\n  if (idObj == idEng || idObj == idCar || idObj == idFun) {\n    carCol = vec4 (0.1, 0.1, 0.9, 0.2);\n    carCol2 = vec4 (0.9, 0.9, 0.2, 0.3);\n    if (idObj == idEng) {\n      col4 = (abs (qHit.y + 0.2) < 0.05 || qHit.y > 1.35) ? carCol2 : carCol;\n      if (qHit.y < -1.15) col4 *= 0.5;\n      if (abs (abs (qHit.x) - 0.5) < 0.4 && abs (qHit.y - 1.1) < 0.2) col4.a = -2.;\n      else if (abs (abs (qHit.z - 1.) - 1.5) < 0.1 && qHit.y > -1.1) col4 *= 0.7;\n      if (qHit.z > 3.1 && qHit.y < -1.) col4 = carCol;\n      if (qHit.z < - 2.8 && qHit.y > 0.1) col4 = vec4 (vec3 (0.01), 0.);\n    } else if (idObj == idCar) {\n      col4 = (abs (qHit.y + 0.2) < 0.05 || qHit.y > 1.4) ? carCol2 : carCol;\n      if (qHit.y < -1.15) col4 *= 0.5;\n      if (abs (qHit.y - 0.6) < 0.6 && (abs (qHit.x) < 0.5 || abs (abs (qHit.z) - 1.2) < 1.1))\n         col4.a = -2.;\n    } else if (idObj == idFun) {\n      col4 = (length (qHit.xz - vec2 (0., 2.1)) < 0.3) ? vec4 (vec3 (0.05), 0.) :\n         ((qHit.y > 1.35) ? carCol : carCol2);\n    }\n  } else if (idObj == idRail) col4 = vec4 (0.7, 0.7, 0.75, 0.5);\n  else if (idObj == idSlp) col4 = vec4 (0.5, 0.3, 0.1, 0.);\n  else if (idObj == idAxle) col4 = vec4 (0.4, 0.4, 0.5, 0.3);\n  else if (idObj == idWheel) col4 = vec4 (0.5, 0.5, 0.6, 0.3);\n  else if (idObj == idCrod) col4 = vec4 (0.7, 0.7, 0.1, 0.3);\n  else if (idObj == idLamp) col4 = (mod (0.5 * tCur, 2.) < 1.) ? vec4 (1., 0., 0., -1.) :\n     vec4 (0., 1., 0., -1.);\n  return col4;\n}\n\nfloat SmkBallHit (vec3 ro, vec3 rd)\n{\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  const float nsShow = 20.;\n  for (float n = 0.; n < nsShow; n ++) {\n    u = ro - trnSzFac * vec3 (0., 10.7, 18.2 - 18. * (mod (3. * tCur, 1.) + n) / nsShow);\n    rad = trnSzFac * (0.4 - 0.3 * n / nsShow);\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        qSmk = u + d * rd;\n        vnSmk = qSmk / rad;\n      }\n    }\n  }\n  return dMin;\n}\n\nvoid SetTrainConfig ()\n{\n  trkWid = 1.55;\n  rlWid = 0.05;\n  rlHt = 0.125;\n  for (int k = 0; k < 3; k ++)\n     carPos[k] = vec3 (0., 2.7 * rlHt + 8.15, 16. - (float (k) * 6.4 + ((k > 0) ? 0.3 : 0.)));\n}\n\n#if GEARS\n\nfloat GearWlDf (vec3 p, float rtFac, float nth, float aRot, float tWid, float wlThk,\n   float dMin, int idGear)\n{\n  vec3 q, qq;\n  float nspi, rad, d, a, g, r;\n  q = p;\n  nspi = 1./8.;\n  rad = rtFac * nth;\n  r = rad - 1.5 * tWid;\n  d = PrBox2Df (vec2 (length (q.xz) - r, q.y), vec2 (2. * tWid, wlThk));\n  q.zx = Rot2D (q.zx, aRot);\n  g = atan (q.z, - q.x);\n  if (d < dMin) {\n    qq = q;\n    a = 2. * pi / nth;\n    qq.xz = Rot2D (qq.xz, a * floor (g / a + 0.5));\n    d = 0.4 * max (d, - (r + clamp (2. * (abs (qq.z) - tWid) - abs (qq.x),\n       qq.x - tWid, qq.x + tWid)));\n  }\n  d = min (d, PrCylDf (q.xzy, 5.2 * wlThk, 2. * wlThk));\n  a = 2. * pi * nspi;\n  q.xz = Rot2D (q.xz, a * floor (g / a + 0.5));\n  q.x += 0.5 * (rad - tWid);\n  d = min (d, PrBoxDf (q, vec3 (0.5 * rad - 2. * tWid, wlThk, 0.03 * rad)));\n  DMIN (idGear);\n  return dMin;\n}\n\nfloat ClkGearsDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, angRot, rtFac, sx, tw, rtFacB, wlThk, f1, f2;\n  int kk;\n  wlThk = 0.16;\n  rtFacB = (7./32.);\n  kk = int (floor (3. - p.y / wlGap));\n  if (kk >= 0 && kk < 6) {\n    sx = -1.;\n    for (int k = 0; k < 6; k ++) {\n      sx = - sx;\n      wlThk *= 0.92;\n      f1 = ntt[2 * k];\n      f2 = ntt[2 * k + 1];\n      angRot = gRot[k];\n      if (k == kk) break;\n    }\n    rtFac = rtFacB;\n    tw = ttWid;\n    if (kk == 1) rtFac *= 0.8;\n    else if (kk == 4) {\n      rtFac *= 0.66667;\n      tw *= 0.65;\n    }\n    q = p;\n    q.y = mod (q.y, wlGap) - 0.5 * wlGap;\n    q.x -= sx * axDist;\n    dMin = GearWlDf (q, rtFac, f1, angRot, ttWid, wlThk, dMin, idGearB);\n    angRot = - (f1 / f2) * angRot + pi / f2;\n    q.x -= -2. * sx * axDist;\n    dMin = GearWlDf (q, rtFac, f2, angRot, tw, wlThk, dMin, idGearS);\n  }\n  return dMin;\n}\n\nfloat ClkGearsRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d, srd, rdi;\n  if (rd.y == 0.) rd.y = 0.0001;\n  srd = - sign (rd.y) / (clkSzFac * wlGap);\n  rdi = 1. / abs (rd.y);\n  dHit = PrBoxDf (ro, clkSzFac * vec3 (szClkCase.x, 3. * wlGap, szClkCase.z));\n  for (int j = 0; j < 60; j ++) {\n    p = ro + dHit * rd;\n    d = ClkGearsDf (p / clkSzFac, dstFar / clkSzFac);\n    dHit += clkSzFac * min (d, wlGap * (0.3 + max (0., fract (rdi * fract (srd * p.y)))));\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  if (d >= 0.0002) dHit = dstFar;\n  return dHit;\n}\n\nfloat ClkAxlesDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;  q.xy -= vec2 (- axDist, 2. * wlGap);\n  d = PrCylDf (q.xzy, axRad, 0.9 * wlGap);\n  q = p;  q.xy -= vec2 (- axDist, 1.5 * wlGap);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.3 * wlGap));\n  q = p;  q.xy -= vec2 (- axDist, 0.);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.9 * wlGap));\n  q = p;  q.xy -= vec2 (axDist, -0.5 * wlGap);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.4 * wlGap));\n  q = p;  q.xy -= vec2 (axDist, - wlGap);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.9 * wlGap));\n  q = p;  q.xy -= vec2 (axDist, -1.5 * wlGap);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.4 * wlGap));\n  q = p;  q.xy -= vec2 (- axDist, -2. * wlGap);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.9 * wlGap));\n  DMIN (idAxB);  \n  q = p;  q.y = abs (q.y) - 2.75 * wlGap;\n  d = PrBoxDf (q, vec3 (axDist - 1.8 * axRad, 0.3 * axRad, 0.7 * axRad));\n  q.x = abs (q.x) - axDist;\n  d = min (d, PrCylDf (q.xzy, 2. * axRad, 0.3 * axRad));\n  DMIN (idBar);\n  q = p;  q.xy -= vec2 (- axDist, 0.);\n  d = PrCylDf (q.xzy, 0.5 * axRad, 3.05 * wlGap);\n  DMIN (idAxF); \n  return dMin;\n}\n\n#endif\n\nfloat ClkHandsDf (vec3 p, float dMin)\n{\n  vec3 q, pp;\n  float d, angRot;\n  pp = p;\n  p.y -= 2.5 * wlGap;\n  q = p;  q.xy -= vec2 (axDist, 0.25 * wlGap);\n  d = PrCylDf (q.xzy, 1.5 * axRad, 0.7 * wlGap);\n  DMIN (idAxH);\n  p.y += 2. * wlGap;\n  q = p;  q.xy -= vec2 (axDist, 1.5 * wlGap);\n  d = PrCylDf (q.xzy, axRad, 2. * wlGap);\n  DMIN (idAxM);\n  p.y += 3. * wlGap;\n  q = p;  q.xy -= vec2 (axDist, 3.2 * wlGap);\n  d = PrCylDf (q.xzy, 0.5 * axRad, 3.6 * wlGap);\n  DMIN (idAxS); \n  p = pp;\n  p.xy -= vec2 (axDist, 0.5 * wlGap);\n  angRot = - gRot[0];\n  q = p;\n  q.xz = Rot2D (q.xz, angRot - 0.5 * pi);\n  q.xy -= vec2 (-2., 2.85 * wlGap);\n  d = PrCapsDf (q.zyx, 0.5 * ttWid, 2.);\n  DMIN (idAxH);\n  angRot *= hFac1;\n  q = p;\n  q.xz = Rot2D (q.xz, angRot - 0.5 * pi);\n  q.xy -= vec2 (-2.5, 3.25 * wlGap);\n  d = PrCapsDf (q.zyx, 0.5 * ttWid, 2.5);\n  DMIN (idAxM);\n  angRot *= hFac2;\n  q = p;\n  q.xz = Rot2D (q.xz, angRot - 0.5 * pi);\n  q.xy -= vec2 (-2.7, 3.65 * wlGap);\n  d = PrCapsDf (q.zyx, 0.3 * ttWid, 3.2);\n  DMIN (idAxS);\n  return dMin;\n}\n\nfloat ClkCaseDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  p.y -= -0.8 + 0.5 * wlGap;\n  q = p;\n  d = PrRoundBoxDf (q, szClkCase - 0.5, 0.5);\n  DMINQ (idCase);\n  q.xy -= vec2 (-8., 4.3);\n  d = PrTorusDf (q.xzy, 0.25, 3.2);\n  q = p;\n  q.xy -= vec2 (axDist, 4.3);\n  d = min (d, PrTorusDf (q.xzy, 0.25, 7.2));\n  DMINQ (idRing);\n  q = p;  q.xy = abs (q.xy) - vec2 (10., 2.4);  q.z -= 8.7;\n  d = PrCylDf (q, 1., 0.5);\n  DMINQ (idFoot);\n  return dMin;\n}\n\nfloat ClockDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar / clkSzFac;\n  p /= clkSzFac;\n  if (visCase) dMin = ClkCaseDf (p, dMin);\n#if GEARS\n  else dMin = ClkAxlesDf (p, dMin);\n#endif\n  dMin = ClkHandsDf (p, dMin);\n  return clkSzFac * dMin;\n}\n\nfloat ClockRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 60; j ++) {\n    d = ClockDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat ClockNDf (vec3 p)\n{\n  float dMin;\n  dMin = ClockDf (p);\n#if GEARS\n  if (! visCase) dMin = clkSzFac * ClkGearsDf (p / clkSzFac, dMin / clkSzFac);\n#endif\n  return dMin;\n}\n\nvec3 ClockNf (vec3 p)\n{\n  const vec2 e = vec2 (0.0001, -0.0001);\n  vec4 v = vec4 (ClockNDf (p + e.xxx), ClockNDf (p + e.xyy), ClockNDf (p + e.yxy), ClockNDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec4 ClockCol ()\n{\n  vec4 col4;\n  vec2 s;\n  float a;\n  if (idObj == idCase) {\n    col4 = vec4 (0.7, 0.7, 0.7, 0.1);\n    if (qHit.y > 0.) {\n      s = qHit.xz - vec2 (axDist, 0.);\n      if (length (s) < 7.) {\n        col4 = vec4 (0.8, 0.8, 0.6, 0.5);\n        a = 6. * (atan (s.y, - s.x) / pi + 1.);\n        if (abs (mod (a + 0.5, 1.) - 0.5) < 0.05 &&\n           abs (length (s.xy) - 5.9) < 0.9) col4 *= 0.5;\n      } else if (length (qHit.xz - vec2 (-8., 0.)) < 3.)\n         col4 = vec4 (0.8, 0.75, 0.8, 0.) * (1. - 0.3 * Noisefv2 (32. * qHit.xz));\n    }\n  } else if (idObj == idRing) col4 = vec4 (0.7, 0.7, 0.1, 0.3);\n#if GEARS\n  else if (idObj == idGearB) col4 = vec4 (1., 1., 0.5, 0.3);\n  else if (idObj == idGearS) col4 = vec4 (0.8, 0.8, 0.2, 0.3);\n#endif\n  else if (idObj == idAxB) col4 = vec4 (0.6, 0.6, 0.3, 0.1);\n  else if (idObj == idAxH) col4 = vec4 (1., 0.3, 0.2, 0.1);\n  else if (idObj == idAxM) col4 = vec4 (0.3, 0.2, 1., 0.1);\n  else if (idObj == idAxS) col4 = vec4 (0.3, 1., 0.2, 0.1);\n  else if (idObj == idAxF || idObj == idBar) col4 = vec4 (0.5, 0.5, 0.6, 0.1);\n  else if (idObj == idFoot) col4 = vec4 (0.4, 0.4, 0.4, 0.05);\n  return col4;\n}\n\nvoid SetClockConfig ()\n{\n  float tCyc, tSeq;\n  fadeCase = 1.;\n  aVelFac = 2. * pi / (12. * 3600.);\n#if GEARS\n  tCyc = 30.;\n  tSeq = mod (tCur, tCyc);\n  fadeCase -= 0.8 * SmoothBump (0.25, 0.75, 0.05, tSeq / tCyc);\n  aVelFac *= 1. + 69. * SmoothBump (0.4, 0.6, 0.002, tSeq / tCyc);\n#endif\n  wlGap = 1.4;\n  szClkCase = vec3 (13.5, 4.4, 8.5);\n  axDist = 4.83;\n  axRad = 0.3;\n  ttWid = 0.35;\n  ntt[0] = 36.; ntt[1] = 12.; ntt[2] = 48.;  ntt[3] = 12.;\n  ntt[4] = 32.; ntt[5] = 16.; ntt[6] = 36.;  ntt[7] = 12.;\n  ntt[8] = 60.; ntt[9] = 12.; ntt[10] = 32.; ntt[11] = 16.;\n  hFac1 = (ntt[0] / ntt[1]) * (ntt[2] / ntt[3]);\n  hFac2 = (ntt[4] / ntt[5]) * (ntt[6] / ntt[7]) * (ntt[8] / ntt[9]) *\n     (ntt[10] / ntt[11]);\n  gRot[0] = - todCur * aVelFac;\n  for (int k = 0; k < 5; k ++) gRot[k + 1] = - gRot[k] * ntt[2 * k] / ntt[2 * k + 1];\n}\n\nfloat RoomDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  d = q.z;\n  DMINQ (idBWal);\n  q = p;  q.y -= 11.7;\n  d = max (PrRoundBoxDf (q, vec3 (5., 3., 0.1), 0.1), - q.z);\n  DMINQ (idWFrm);\n  q = p;  q.yz -= vec2 (8., 1.5);\n  d = PrBoxDf (q, vec3 (7., 0.12, 1.5));\n  DMINQ (idShlf);\n  q = p;  q.x = abs (q.x);  q -= vec3 (5., 4., 2.);\n  d = PrCylDf (q.xzy, 0.4, 4.);\n  DMINQ (idPil);\n  q = p;\n  d = q.y;\n  DMINQ (idFlr);\n  return dMin;\n}\n\nfloat RoomRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 60; j ++) {\n    d = RoomDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 RoomNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (RoomDf (p + e.xxx), RoomDf (p + e.xyy), RoomDf (p + e.yxy), RoomDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat RoomSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 30; j ++) {\n    p = ro + rd * d;\n    h = min (TrainDf (p), RoomDf (p));\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.1, 0.5);\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec2 u;\n  float a;\n  rd.z *= -1.;\n  ro.z *= -1.;\n  a = 0.5 * atan (length (rd.xy), rd.z);\n  rd = normalize (vec3 (rd.xy * tan (a), 1.));\n  u = vec2 (ro.xy + 2. * tCur + rd.xy * (100. - ro.z) /rd.z);\n  return mix (mix (vec3 (0.2, 0.2, 0.6), vec3 (1.), 1.5 * Fbm2 (0.1 * u)),\n     vec3 (0.3, 0.3, 0.6), smoothstep (0.35 * pi, 0.4 * pi, a));\n}\n\nvec4 ShowTrain (vec3 ro, vec3 rd, vec3 col, float dstMin)\n{\n  vec4 col4;\n  vec3 vn;\n  float dstTrain, dstSmk;\n  dstSmk = SmkBallHit (ro, rd);\n  if (dstSmk < dstFar) vnSmk = VaryNf (32. * qSmk, vnSmk, 2.);\n  dstTrain = TrainRay (ro, rd);\n  if (dstTrain < min (dstMin, dstFar)) {\n    ro += rd * dstTrain;\n    vn = TrainNf (ro);\n    col4 = TrainCol ();\n    col = col4.rgb;\n    if (col4.a >= 0.) col = col * (0.3 + 0.7 * max (dot (vn, ltDir), 0.)) +\n        col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n    else if (col4.a == -2.) col = mix (col, 0.5 * BgCol (8. * qHit.yxz, vec3 (0., 1., 0.)), 0.5);\n  }\n  if (dstSmk < min (dstTrain, dstMin)) col = mix (col, vec3 (0.8, 0.8, 0.75) *\n     (0.5 + 0.5 * max (dot (vnSmk, ltDir), 0.)), 0.7);\n  return vec4 (col, dstTrain);\n}\n\nvec3 ShowClock (vec3 ro, vec3 rd, vec3 col, float dstMin)\n{\n  vec4 col4;\n  vec3 vn, roo, colC, colNC;\n  float dstClk, d;\n  int idObjC;\n  ro = ro.xzy;  ro.z *= -1.;\n  rd = rd.xzy;  rd.z *= -1.;\n  colC = col;\n  colNC = col;\n  roo = ro;\n  visCase = true;\n  dstClk = ClockRay (ro, rd);\n  if (dstClk < min (dstMin, dstFar)) {\n    ro += rd * dstClk;\n    vn = ClockNf (ro).xzy;  vn.y *= -1.;\n    col4 = ClockCol ();\n    colC = col4.rgb * (0.3 + 0.7 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  }\n#if GEARS\n  ro = roo;\n  visCase = false;\n  dstClk = ClkGearsRay (ro, rd);\n  idObjC = idObj;\n  d = ClockRay (ro, rd);\n  if (d < dstClk) dstClk = d;\n  else idObj = idObjC;\n  if (dstClk < min (dstMin, dstFar)) {\n    ro += rd * dstClk;\n    vn = ClockNf (ro).xzy;  vn.y *= -1.;\n    col4 = ClockCol ();\n    colNC = col4.rgb * (0.3 + 0.7 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  }\n  col = mix (colNC, colC, fadeCase);\n#else\n  col = colC;\n#endif\n  return col;\n}\n\nvec3 ShStagGrid (vec2 p, vec2 g)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (2. * floor (0.5 * floor (q.y)) == floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.3 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec4 ShowRoom (vec3 ro, vec3 rd, vec3 col, float dstMin)\n{\n  vec4 col4;\n  vec3 vn, rg;\n  float dstRoom, a, s;\n  bool fxz;\n  dstRoom = RoomRay (ro, rd);\n  if (dstRoom < min (dstMin, dstFar)) {\n    ro += dstRoom * rd;\n    vn = RoomNf (ro);\n    if (idObj == idBWal) {\n      col4 = vec4 (0.9, 0.7, 0.4, 0.1);\n      rg = ro;\n      fxz = (abs (vn.x) > 0.99);\n      rg = ShStagGrid ((fxz ? rg.zy : rg.xy), vec2 (0.6, 1.2));\n      col4 *= rg.y;\n      rg.xz *= sign (fxz ? vn.x : vn.z);\n      if (fxz) {\n        if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n        else vn.xz = Rot2D (vn.xz, rg.x);\n      } else {\n        if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n        else vn.zx = Rot2D (vn.zx, rg.x);\n      }\n    } else if (idObj == idWFrm) {\n      col4 = (vn.z > 0.99 && abs (qHit.x) < 4.9 && abs (qHit.y) < 2.9) ? \n         vec4 (0.5 * BgCol (4. * qHit, vec3 (0., 1., 0.)), -1.) : vec4 (0.7, 0.7, 0.1, 0.3);\n    } else if (idObj == idPil) {\n      col4 = vec4 (0.9, 0.7, 0.7, 0.2);\n      if (abs (vn.y) < 0.01) {\n        a = (length (qHit.xz) > 0.) ? atan (qHit.z, - qHit.x) / pi : 0.;\n        s = mod (2. * qHit.y + a, 1.);\n        vn.y = 0.3 * (1. - SmoothBump (0.2, 0.8, 0.1, s)) * sign (s - 0.5);\n        vn.xz *= sqrt (1. - vn.y * vn.y);\n      }\n    } else if (idObj == idShlf) {\n      col4 = vec4 (0.5, 0.3, 0.1, 0.1);\n      if (vn.y > 0.99) {\n        col4.rgb = mix (col4.rgb, vec3 (0.7, 0.4, 0.2), Fbm2 (vec2 (2., 16.) * qHit.xz));\n        if (abs (qHit.x - 0.1) < clkSzFac * szClkCase.x &&\n           abs (qHit.z - 0.4) < clkSzFac * szClkCase.y) col4 *= mix (1., 0.7, fadeCase);\n      }\n    } else if (idObj == idFlr) {\n      col4 = mix (vec4 (0.8, 0.4, 0.2, 0.2), vec4 (0.5, 0.25, 0.1, 0.1),\n         Fbm2 (vec2 (8., 1.) * qHit.xz)) *\n         (0.6 + 0.4 * smoothstep (0.03, 0.08, mod (qHit.x + 0.5, 1.)));\n      col4 *= 0.7 + 0.3 * smoothstep (0.4, 0.6, length (vec2 (abs (qHit.x), qHit.z) - vec2 (5., 2.)));\n    }\n    col = col4.rgb;\n    if (col4.a >= 0.) col = col * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    if (idObj == idBWal || idObj == idFlr) col *= 1. - smoothstep (0.08, 0.2,\n       acos (dot (normalize (ltPos - ro), ltDir)) / pi);\n  }\n  return vec4 (col, dstRoom);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  float dMin, sh;\n  dMin = dstFar;\n  col4 = vec4 (vec3 (0.), dMin);\n  dMin = min (dMin, col4.a);\n  col4 = ShowRoom (ro, rd, col4.rgb, dMin);\n  if (col4.a < dMin) {\n    dMin = col4.a;\n    if (idObj == idFlr || idObj == idBWal) col4.rgb *= 0.7 + 0.4 * RoomSShadow (ro + dMin * rd, ltDir);\n  }\n  col4 = ShowTrain (ro, rd, col4.rgb, dMin);\n  dMin = min (dMin, col4.a);\n  ro.yz -= vec2 (9.9, 2.);\n  col4.rgb = ShowClock (ro, rd, col4.rgb, dMin);\n  return clamp (col4.rgb, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, t, ltEl, ltAz;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 100.;\n  az = pi;\n  el = 0.03 * pi;\n  if (mPtr.z > 0.) {\n    az -= 0.6 * pi * mPtr.x;\n    el -= 0.2 * pi * mPtr.y;\n  } else {\n    t = 16. * (mod (0.02 * tCur, 2.) - 0.5);\n    t = (floor (t) + smoothstep (0.9, 1., mod (t, 1.))) / 16.;\n    az += 0.4 * pi * min (1. - t, t);\n  }\n  az = clamp (az, 0.75 * pi, 1.25 * pi);\n  el = clamp (el, -0.01 * pi, 0.1 * pi);\n  clkSzFac = 0.2;\n  trnSzFac = 0.6;\n  SetClockConfig ();\n  SetTrainConfig ();\n  ro = vec3 (0., 0., -50.);\n  ro.yz = Rot2D (ro.yz, el);  ro.xz = Rot2D (ro.xz, az);\n  ro.y += 7.;\n  zmFac = 5.4;\n  ltEl = -0.3 * pi;\n  ltAz = 0.2 * pi;\n  ltDir = vec3 (0., 0., 1.);\n  ltDir.yz = Rot2D (ltDir.yz, ltEl);  ltDir.xz = Rot2D (ltDir.xz, ltAz);\n  ltPos = 50. * ltDir;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), zmFac));\n    rd.yz = Rot2D (rd.yz, el);  rd.xz = Rot2D (rd.xz, az);\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  col = RgbToHsv (col);\n  col = HsvToRgb (vec3 (col.r, 0.7 * col.g, pow (0.5 * col.b + 0.5 * smoothstep (0., 1., col.b), 0.8)));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nvec3 RgbToHsv (vec3 c)\n{\n  vec4 p, q;\n  float d;\n  const float e = 1.e-10;\n  p = mix (vec4 (c.bg, vec2 (-1., 2./3.)), vec4 (c.gb, vec2 (0., -1./3.)), step (c.b, c.g));\n  q = mix (vec4 (p.xyw, c.r), vec4 (c.r, p.yzx), step (p.x, c.r));\n  d = q.x - min (q.w, q.y);\n  return vec3 (abs (q.z + (q.w - q.y) / (6. * d + e)), d / (q.x + e), q.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}