{
    "Shader": {
        "info": {
            "date": "1517049686",
            "description": "A grid based system that generations glowing particles. ",
            "flags": 0,
            "hasliked": 0,
            "id": "Xl2BDy",
            "likes": 23,
            "name": "Grid based Particles ",
            "published": 3,
            "tags": [
                "particlesgenerativ"
            ],
            "usePreview": 0,
            "username": "ircss",
            "viewed": 6057
        },
        "renderpass": [
            {
                "code": "\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 permute(in vec4 x)\n{\n return mod ((34.0 * x + 1.0) * x , 289.0);   \n}\n\nvec2 celluar2x2( vec2 P) {\n    \n    float pp =  7.0; \n \tfloat K = 1.0/pp;\n\tfloat K2 = 0.5/pp;\n\tfloat jitter = 0.8 ; // jitter 1.0 makes F1 wrong more often\n\tvec2 Pi = mod(floor(P), 289.0) ;\n\tvec2 Pf = fract(P);\n\tvec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);\n\tvec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);\n\tvec4 p = permute (Pi.x + vec4(0.0 , 1.0, 0.0, 1.0));\n\tp = permute (p + Pi.y + vec4(0.0 , 0.0, 1.0, 1.0));\n\tvec4 ox = mod(p, pp) * K + K2;\n\tvec4 oy = mod(floor(p * K) ,pp) * K + K2;\n\tvec4 dx = Pfx + jitter * ox;\n\tvec4 dy = Pfy + jitter * oy;\n\tvec4 d = dx * dx + dy * dy; // distances squared\n\t// Cheat and pick only F1 for the return value\n\td.xy = min(d.xy, d.zw);\n\td.x = min(d.x, d.y);\n\treturn d.xx; // F1 duplicated , F2 not computed\n \n    \n}\n\nvoid DrawAParticleSet(inout vec4 color, vec2 uv, float size ){\n   float aCellLenght = size;\n   vec3 colorTint;\n   float randomSeed01 = rand(floor (uv /aCellLenght));\n   float randomSeed02 = rand(floor (uv /aCellLenght) + 5.0);\n   float randomSeed03 = rand(floor (uv /aCellLenght) + 10.0);\n    \n  \n    colorTint= vec3(randomSeed01, randomSeed02, randomSeed03);\n    \n   float circleLenght =abs(sin(iTime * randomSeed03 + randomSeed02))  * randomSeed01 * aCellLenght;\n   \n   float jitterFreedom = 0.5 - circleLenght;\n   float jitterAmountX =  jitterFreedom * (randomSeed03 *2.0 -1.0);\n   float jitterAmounty =  jitterFreedom * (randomSeed01 *2.0 -1.0); \n   vec2 coord =  fract(uv / aCellLenght);\n    \n    \n   coord -= 0.5;\n   float z = 0.0;\n   vec3 toReturn; \n   for(int i=0; i < 3; i++) {\n       z += 0.015 * celluar2x2(coord + iTime * 0.1).x  /*abs(sin(iTime * randomSeed01 + randomSeed01))*/;\n\t\tcoord += z;\n\t\ttoReturn[i] = 1.0 - smoothstep(circleLenght- 30.5/iResolution.y,\n                                       circleLenght, distance(coord, vec2(jitterAmountX, jitterAmounty)));\n\t}\n    \n   toReturn = mix(color.xyz, colorTint *toReturn, length(toReturn));\n   color = vec4(toReturn.xyz, 0.1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    float screenXLenght = iResolution.x/ iResolution.y;\n    \n    vec4 endColor = vec4(.0);\n    \n    uv.x -= screenXLenght/2.0; \n    uv.y -= 0.5;\n    \n    \n    DrawAParticleSet(endColor, uv, 0.1);\n    DrawAParticleSet(endColor, uv- 0.1, 0.15);\n    DrawAParticleSet(endColor, uv + 0.3, 0.17);\n\tfragColor = vec4(endColor);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}