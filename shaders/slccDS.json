{
    "Shader": {
        "info": {
            "date": "1660430614",
            "description": "Hurwitz Zeta function is a generalization of Riemann Zeta function depending on a parameter a\nFor a = 1 (time = 0) we get Riemann Zeta function.\nHurwitz(z,a) = sum (n+a)**z for n in N\nThe approximation method is Euler-Maclaurin",
            "flags": 16,
            "hasliked": 0,
            "id": "slccDS",
            "likes": 3,
            "name": "Hurwitz Zeta function",
            "published": 3,
            "tags": [
                "zeta",
                "hurwitz"
            ],
            "usePreview": 0,
            "username": "guil",
            "viewed": 233
        },
        "renderpass": [
            {
                "code": "const float pi = 3.1415926535897932;\nconst float LOG2 = 0.6931471805599453;\nconst float LOGPI = 1.1447298858494002;\n\n\n\n//------------------ ------------------------------------------\n// complex number operations\nvec2 cadd( vec2 a, float s ) { return vec2( a.x+s, a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cinv(vec2 z) {return vec2(z.x,-z.y)/dot(z,z);}\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 csqr( vec2 a ) { return vec2(a.x*a.x-a.y*a.y, 2.0*a.x*a.y ); }\nvec2 csqrt( vec2 z ) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\nvec2 cpow( float n, vec2 z ) {  return pow( n, z.x )*vec2( cos(z.y*log(n)), sin(z.y*log(n)) ); }\nvec2 cexp( vec2 z) {  return exp( z.x )*vec2( cos(z.y), sin(z.y) ); }\nvec2 clog( vec2 z) {  return vec2( 0.5*log(z.x*z.x+z.y*z.y), atan(z.y,z.x)); }\nvec2 csin( vec2 z) { float r = exp(z.y); return 0.5*vec2((r+1.0/r)*sin(z.x),(r-1.0/r)*cos(z.x));}\nvec2 cpow( vec2 a, vec2 b ) {  return cexp(cmul(b,clog(a))) ;}\nvec2 ccos( vec2 z) { float r = exp(z.y); return 0.5*vec2((r+1.0/r)*cos(z.x),-(r-1.0/r)*sin(z.x));}\nvec2 clogsin(vec2 z) {\n  if (abs(z.y)<8.0)return clog(csin(z));  \n  if (z.y > 0.) return vec2(z.y - LOG2, mod(1.5*pi-z.x, 2.0*pi) - pi);\n  else return vec2(-z.y - LOG2, mod(0.5*pi+z.x, 2.0*pi) - pi);\n  \n}\n//------------------------------------------------------------\n\n\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 col(vec2 u){\n    float r = u.x;\n    float v =min( exp(-r*.15),1.);\n    return hsv2rgb(vec3(u.y/(2.*pi),.5+.5*fract(r),.8))*v;\n}\n\n\n\n// Spouge's method for gamma\nvec2 gamma(vec2 z){\n    const int N = 16;\n    float c = sqrt(2.*pi);\n\tvec2 s = vec2(c,0.);\n    float f = 1.;\n\tfor(int k = 1; k<N ;k++){\n\t\tc = exp(float(N-k)) * pow(float(N-k),float(k)-.5)/f;\n        f *= -float(k);\n        s += c*cinv(z+vec2(float(k),0.));\n\t}\t   \n    s = cmul(s,cmul(cexp(-z-vec2(float(N),0.)),cpow(z+vec2(float(N),0.),z+vec2(.5,0.))));\n    return cdiv(s,z);\n    //s = clog(s); \n    //s += -z - vec2(float(N),0.) + cmul(z+vec2(.5,0.), clog(z+vec2(float(N),0.)));\n    //return s-clog(z);      \n}\n\n//Bernoulli\nfloat bn(int n){\n    float[40] a = float[40](0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,\n                            0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,\n                            0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,\n                            0.,0.,0.,0.,0.,0.,0.,0.,0.,0.);\n    for(int i = 0; i <= n; i++){\n        a[i]=1./float(i+1);\n        for(int j = i; j > 0; j--){\n            a[j-1] = float(j)*(a[j-1] - a[j]);\n        }\n    }\n    return a[0];\n}\n\n\n//Hurwitz zeta : Euler Maclaurin approximation\nvec2 zeta7(vec2 z, float a){\n  const float N = 20.;\n  const float P = 12.;\n   \n  vec2 sum = vec2(0);\n  \n  for(float i = 0.; i < N; i++)\n    sum += cpow(i+a,-z); \n  sum += cpow(N+a,-z)/2.;  \n  sum += cdiv(cpow(N+a,vec2(1,0)-z),z-vec2(1,0));\n  vec2 c = z/2.;\n  for(float i = 1.; i < P; i++){\n    sum += cmul(c,cpow(N+a,-z-vec2(2.*i-1.,0)))*bn(2*int(i)); \n    c=cmul(c,cmul(z+vec2(2.*i-1.,0),z+vec2(2.*i,0)))/(2.*i+1.)/(2.*i+2.);\n  }     \n  return sum;\n}\n\n\nvec2 reflection(vec2 z, float a){\n  const float N = 20.;\n  vec2 sum1 = vec2(0);\n  for(float i = 1.; i < N; i++)\n    sum1 += cos(2.*pi*i*a)*cpow(i,z-vec2(1,0)); \n  vec2 sum2 = vec2(0);\n  for(float i = 1.; i < N; i++)\n    sum2 += sin(2.*pi*i*a)*cpow(i,z-vec2(1,0)); \n  vec2 f = cmul(csin(pi*z/2.),sum1)+cmul(ccos(pi*z/2.),sum2);\n  return 2.*cmul(cpow(2.*pi,z-vec2(1,0)),cmul(gamma(vec2(1,0)-z),f));\n}\n\nvec2 Hurwitz(vec2 z, float a){\n  if(z.x<-1.)return reflection(z,a);\n  return zeta7(z,a);\n}\n\nbool keypress(int key) {\n    return texelFetch(iChannel3, ivec2(key,2),0).x != 0.0;\n}\n\nvoid mainImage(out vec4 fragColor,  in vec2 fragCoord){\n  vec2 uv = (2.*fragCoord - iResolution.xy-iMouse.xy) / iResolution.y+(iMouse.xy==vec2(0.,0.)?0.:.5);;  // Map y-coordinates to [-1;1]\n  float zoom = 12.;\n  if (keypress(90)) zoom = 4.0;\n  uv *= zoom;  // Zoom out\n  vec2 z = uv.yx;  \n  z = clog(Hurwitz(z,.5+.5*cos(.1*iTime)));\n  fragColor.rgb = col(z);\n  float size = 4.*zoom/iResolution.x;\n  if (mod(abs(uv.x),5.)<size)fragColor.rgb = vec3(0.5);\n  if (mod(abs(uv.y),5.)<size)fragColor.rgb = vec3(0.5);\n  if (abs(uv.y-.5)<size)fragColor.rgb = vec3(1);\n  \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}