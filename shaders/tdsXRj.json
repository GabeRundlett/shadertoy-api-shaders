{
    "Shader": {
        "info": {
            "date": "1552842382",
            "description": "Yummy!",
            "flags": 0,
            "hasliked": 0,
            "id": "tdsXRj",
            "likes": 66,
            "name": "Strawberry",
            "published": 3,
            "tags": [
                "eyes",
                "fruit",
                "strawberry",
                "inversesphericalfibonacci"
            ],
            "usePreview": 1,
            "username": "EvilRyu",
            "viewed": 1474
        },
        "renderpass": [
            {
                "code": "// Created by EvilRyu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nfloat hash11(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash13(vec3 p)\n{\n    p=fract(p*vec3(5.3983,5.4472,6.9371));\n    p+=dot(p.yzx,p.xyz+vec3(21.5351,14.3137,15.3219));\n    return fract(p.x*p.y*p.z*95.4337);\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  \tvec3 d=abs(p)-b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0));\n}\n\nfloat cylinder(vec3 p, vec2 h)\n{    \n  \tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvoid basis(vec3 n, out vec3 b1, out vec3 b2) \n{\n    if(n.y<-0.999999) \n    {\n        b1=vec3(0,0,-1);\n        b2=vec3(-1,0,0);\n    } \n    else \n    {\n    \tfloat a=1./(1.+n.y);\n    \tfloat b=-n.x*n.z*a;\n    \tb1=vec3(1.-n.x*n.x*a,-n.x,b);\n    \tb2=vec3(b,-n.z,1.-n.z*n.z*a);\n    }\n}\n\nvoid rot2d(inout vec2 p, float t)\n{\n    float ct=cos(t),st=sin(t);\n    vec2 q=p;\n\tp.x=ct*q.x+st*q.y;\n    p.y=-st*q.x+ct*q.y;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h=clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b,a,h)-k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a,b,-k);\n}\n\nconst float PI=3.14159265359;\nconst float PHI=1.61803398875;\n\n// from iq: https://www.shadertoy.com/view/lllXz4\nvec4 invsf(vec3 p, float n)\n{\n    float m=1.-1./n;\n    float phi=min(atan(p.y,p.x),PI);\n    float k=max(2.,floor(log(n*PI*sqrt(5.)*\n                             (1.-p.z*p.z))/log(PHI+1.)));\n    float Fk=pow(PHI,k)/sqrt(5.);\n    vec2  F=vec2(round(Fk), round(Fk*PHI));\n    vec2 ka=2.*F/n;\n    vec2 kb=2.*PI*(fract((F+1.)*PHI)-(PHI-1.));    \n    mat2 iB=mat2(ka.y,-ka.x, \n                    kb.y,-kb.x)/(ka.y*kb.x-ka.x*kb.y);\n    \n    vec2 c=floor(iB*vec2(phi, p.z-m));\n    float d=0.;\n    vec4 res=vec4(0);\n    for(int s=0; s<4; s++) \n    {\n        vec2 uv=vec2(s&1,s>>1);\n        float i=dot(F,uv+c); \n        float phi=2.*PI*fract(i*PHI);\n        float ct=m-2.*i/n; //costheta\n        float st=sqrt(1.-ct*ct); //sintheta\n        \n        vec3 q=vec3(cos(phi)*st, \n                    sin(phi)*st, \n                    ct);\n        float d1=dot(p,q);\n        if(d1>d) \n        {\n            d=d1;\n            res=vec4(q,d);\n        }\n    }\n    return res;\n}\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=textureLodOffset(sam, p.xy-vec2(.14), 1.5, ivec2(2));\n    vec4 p2=textureLod(sam, p.xz, 0.);\n    vec4 p3=textureLod(sam, p.yz, 1.5);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\nfloat id=0.;\n\nvec4 get_eye_params(vec3 p)\n{\n    vec3 r,f;\n    vec4 fibo=invsf(normalize(p),88.3);\n    vec3 q=p-fibo.xyz;\n    vec3 n=normalize(fibo.xyz);\n    basis(n,r,f);\n    q=vec3(dot(r,q),dot(n,q),dot(f,q));\n    rot2d(q.xz,hash13(fibo.xyz)*7.);\n    return vec4(q,0.1+0.088*hash13(fibo.xyz+vec3(13.399,71.137,151.11)));\n}\n\nvec3 deform(vec3 p)\n{\n    vec3 q=p;\n    q*=1.-(smoothstep(0.,1.,q.y)-smoothstep(1.,2.,q.y)*3.)*0.16;\n    q*=1.-(smoothstep(0.,.45,q.y)-smoothstep(.45,.9,q.y))*0.07;\n    q.xz*=(1.-smoothstep(-.6,0.2,q.y))*.2+1.;\n    q.y*=0.8;\n    return q;\n}\n\nvec2 polar_rep(vec2 p, float n)\n{\n    n=PI*0.5/n;\n    float a=atan(p.y, p.x);\n    float r=length(p);\n    a=mod(a+n/2.0, n)-n/2.0;\n    p=r*vec2(cos(a), sin(a));\n    return 0.5*(p+p-vec2(1,0));\n}\n\nfloat leaf(vec3 p)\n{\n    vec3 q=p;  \n    q.xz=polar_rep(q.xz,2.5);\n    q.y+=0.1*sin(q.x*6.);\n    vec3 q1=q;\n    q.z=abs(q.z)+0.6;\n    float d=cylinder(q,vec2(0.7,0.01));\n    float d1=box(q1-vec3(0.,0.01,0.),vec3(0.45,0.013,0.001));\n    d=smin(d,d1,0.05);\n    p.x+=0.1*sin(p.y*4.0);\n \tp.x-=0.05;\n    d1=cylinder(p,vec2(0.04,0.7));\n    d=smin(d,d1,0.3);\n    return d;\n}\n\nfloat map(vec3 p)\n{\n    float lea=leaf(p.xyz-vec3(0.,1.32,0.));\n    p=deform(p);\n    float d0=sphere(p,1.)-0.1*texcube(iChannel0, p*0.45, normalize(p)).x;\n    vec4 q=get_eye_params(p);\n    float d1=sphere(q.xyz+vec3(0.,(-0.188+q.w)*.8,0.),q.w*.8);\n    d0=smin(d0,d1,0.09);\n    \n    float a=mod(iTime*q.w*1.3,1.);\n    d1=sphere(vec3(q.x,q.y-0.188+q.w*(smoothstep(0.,.1,a)-smoothstep(0.9,1.,a)),\n                   abs(q.z)+q.w*0.35),\n              q.w*0.7);\n    d0=smax(d0,-d1,0.09);\n    d1=sphere(q.xyz+vec3(0.,-0.09+q.w,0.),q.w);\n    \n    if(d0>d1){d0=d1;id=1.;}\n    if(d0>lea){d0=lea;id=2.;}\n    \n    return d0;\n}\n\nvec3 get_normal(vec3 p)\n{\n    vec3 eps=vec3(0.001,0,0);\n    return normalize(vec3(map(p+eps.xyz)-map(p-eps.xyz),\n                     map(p+eps.yxz)-map(p-eps.yxz),\n                     map(p+eps.yzx)-map(p-eps.yzx)));\n}\n\n#define FAR 30.0\nfloat intersect(vec3 ro, vec3 rd)\n{\n    float t=0.1;\n    float d=0.;\n   \tfor(int i=0;i<96;++i)\n    {\n        d=map(ro+t*rd);\n        if(d<0.003&&t>FAR)\n        \tbreak;\n        t+=d;\n    }\n        \n    return t;\n}\n\nfloat noise(vec2 x)\n{\n    vec2 p=floor(x);\n    vec2 f=fract(x);\n    f=f*f*(3.0-2.0*f);\n    float n=p.x + p.y*57.0;\n    return mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),\n               mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\n}\nconst mat2 m=mat2(0.8,0.6,-0.6,0.8);\n\n\nfloat fbm(vec2 p)\n{\n    float f=0.0;\n    f+=.5*noise(p); p=m*p*2.;\n    f+=.25*noise(p); p=m*p*2.;\n    f+=.125*noise(p); p=m*p*2.;\n    f+=.0625*noise(p); p=m*p*2.;\n    f+=.03125*noise(p);\n    return f/0.984375;\n}\n\nfloat trace_sphere(vec3 ro, vec3 rd, vec4 sph)\n{\n    vec3 p=sph.xyz;\n    float t=-1.0;\n    vec3  ce=ro-p;\n    float b=dot(rd, ce);\n    float c=dot(ce, ce)-sph.w*sph.w;\n    float h=b*b - c;\n    if(h>0.0)\n    {\n        t=-b-sqrt(h);\n    }\n    \n    return t;\n}\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r=0.0, w=1.0, d;\n    for(float i=1.; i<5.0+1.1; i++)\n    {\n        d=i/5.0;\n        r+=w*(d-map(p+n*d));\n        w*=0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\nvec3 get_material(vec3 ro, vec3 rd, vec3 p)\n{\n    if(id<1.)\n    {\n    \t//return vec3(0.82,0.055,0.027)*0.4;   // real strawberry color  \n        return vec3(0.984,0.352,0.551)*0.75;\n    }\n    else if(id>1.1)\n    {\n        return vec3(0.05,0.15,0.);\n    }\n    \n\tp=deform(p);\n    vec4 eyes=get_eye_params(p);\n\n    vec3 col=vec3(1.);\n\tvec2 uv=vec2(eyes.xz);\n    float r=length(uv);\n    if(r<eyes.w*.13)\n    {\n        col=vec3(0.01);\n    }\n    else if(r<eyes.w*.3)\n    {\n        col=mix(vec3(.9,.8,.3)*.5,vec3(.01), fbm(50.*uv));\n    }\n\tcol=mix(col,vec3(0.2,0.,0.)*fbm(50.*uv),\n            smoothstep(eyes.w*.35, eyes.w*.6, r));\n   \n    return col;\n}\n\nfloat sss(vec3 p, vec3 n, float d, float i) \n{ \n    float o,v; \n    for(o=0.;i>0.;i--) \n        o+=(i*d+map(p+n*i*d))/exp2(i); \n    return o; \n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float s = 1.0,t = 0.01,h = 1.0;\n    for( int i=0; i<16; i++ )\n    {\n        h = map(ro + rd*t);\n        s = min( s, 16.*h/t );\n        if( s<0.0001 ) break;\n        t += clamp( h, .01, .05 );\n    }\n    return clamp(s,.0,1.);\n}\n\nvec3 lighting(vec3 ro, vec3 rd, vec3 n, float t, vec3 p)\n{\n    vec3 ld0=normalize(vec3(1,1.5,-1.7));\n    \n    float dif=max(0.,dot(ld0,n));\n    float spe=pow(max(0.,dot(rd,reflect(ld0,n))), 24.0);\n    float bac=max(0.,dot(-ld0,n));\n    float amb=clamp(0.3+0.7*n.y,0.0,1.0);\n    float sca=sss(p,-n,.5,10.);\n    float fre=clamp(1.-dot(n,-rd),0.,1.);\n    id=0.;\n    float d=map(p);\n    vec3 mate=get_material(ro,rd,p);\n    \n    float ao=get_ao(p,n);\n    float sha=shadow(p,ld0);\n    \n    vec3 col=(4.0*dif*sha+0.5*bac+1.*amb*sha+fre*fre*fre*10.*sha)*mate*ao*ao+1.5*spe*sha;\n    col+=2.*mate*sca;\n    col*=0.2;\n    return col;\n}\n\nvec3 tonemap(vec3 x) \n{\n    const float a=2.51;\n    const float b=0.03;\n    const float c=2.43;\n    const float d=0.59;\n    const float e=0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 bg(vec2 p)\n{\n    vec2 po;\n    po.x=atan(p.y, p.x);\n    po.y=length(p)-iTime*0.4;\n    float d=length(p);\n    vec3 col=vec3(d,d*.5,d*.7);\n    float c=pow(fbm(po*5.),5.)*(1.-(smoothstep(0.,0.01,d)-smoothstep(.4,1.,d)))\n        \t*max(0.,1.5-d);\n    col-=vec3(c*4.,c*7.,c*3.)*.2;\n    return clamp(col,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    vec2 p=q*2.0-1.;\n    p.x*=iResolution.x/iResolution.y;\n\n    vec3 ro=vec3(0,0.7,-6);\n    vec3 ta=vec3(0,0,0);\n     // debugging camera\n    float x_rot=-iMouse.x/iResolution.x*PI*2.0;\n    float y_rot=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;\n    if(iMouse.z>0.||iMouse.w>0.)\n    \tro=vec3(0.,0,-3)+vec3(cos(y_rot)*cos(x_rot),cos(y_rot)*cos(x_rot),cos(y_rot)*sin(x_rot))*5.;\n     \n    vec3 f=normalize(ta-ro);\n    vec3 r=normalize(cross(vec3(0,1,0),f));\n    vec3 u=normalize(cross(f,r));\n    \n    vec3 rd=normalize(mat3(r,u,f)*vec3(p.x,p.y,2.8));\n    \n    vec3 col=bg(p);\n    \n    float t=trace_sphere(ro,rd,vec4(0.,0.,0.,2.));\n    if(t>0.&&t<1000.)\n    {\n        float t=intersect(ro,rd);\n        if(t<FAR)\n        {\n            vec3 pos=ro+t*rd;\n            vec3 n=get_normal(pos);\n   \t        col=lighting(ro, rd,n,t,pos);\n    \t}\n    }\n    \n\tcol=tonemap(col);\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}