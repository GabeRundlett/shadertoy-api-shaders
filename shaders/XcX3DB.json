{
    "Shader": {
        "info": {
            "date": "1703437899",
            "description": "Weaving patterns in hyperbolic tilings. A nice decoration for the festive season.\n\nMouse rotates, see code for other controls.",
            "flags": 16,
            "hasliked": 0,
            "id": "XcX3DB",
            "likes": 22,
            "name": "Hyperbolic Weave",
            "published": 3,
            "tags": [
                "hyperbolic",
                "weave"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 333
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Hyperbolic Weave, mla, 2023.\n//\n// First attempt at a generic weave pattern for hyperbolic tilings.\n//\n// c: don't colour tiles\n// d: don't shade area outside disc\n// h: half space projection\n// w: hide weave\n// x: show single tile\n// z: zoom in (only in half space projection)\n//\n// Most of the calculations are done in the hyperboloid model, with\n// the Poincare disc used for folding into the fundamental region.\n// The tile colouring doesn't always work properly.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int N = 3;\nivec3 angles = ivec3(2,3,7);\nfloat lwidth = 0.07;\nbool doubleup = true;\nvoid config(int i) {\n  i %= 6;\n  if (i == 0) { angles = ivec3(2,3,7); lwidth = 0.07; }\n  if (i == 1) { angles = ivec3(2,7,3); lwidth = 0.11; }\n  if (i == 2) { angles = ivec3(2,4,5); lwidth = 0.09; }\n  if (i == 3) { angles = ivec3(5,3,3); lwidth = 0.09; }\n  if (i == 4) { angles = ivec3(4,4,4); lwidth = 0.15; }\n  if (i == 5) { angles = ivec3(3,4,5); lwidth = 0.12; }\n  doubleup = angles[0] == 2;\n}\n\n#define configmode (key(CHAR_X))\n\nvec2 getselection(int i) {\n  if (configmode && iMouse.x > 0.0) return (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  return vec2(0.8,0.7);\n}\n\nvec2 defaultselection() {\n  if (iMouse.x > 0.0) return (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  return vec2(0);\n}\n\n// Basic operations for hyperbolic (Minkowski) space\n// Inner product\nfloat hdot(vec3 p, vec3 q) {\n  return dot(vec3(1,1,-1)*p,q);\n}\n\nvec3 hcross(vec3 p, vec3 q) {\n  // hdot(p,hcross(p,q)) = hdot(q,hcross(p,q)) = 0\n  return cross(p,q)*vec3(1,1,-1);\n}\n\nfloat hnorm(vec3 p) {\n  return hdot(p,p);\n}\n\nfloat hlength(vec3 p) {\n  return sqrt(abs(hnorm(p)));\n}\n\n// Normalize a point or a line\nvec3 hnormalize(vec3 p) {\n  float t = hnorm(p);\n  if (t < 0.0 && p.z < 0.0) p = -p;\n  return p/sqrt(abs(t));\n}\n\n// Now redundant\nvec3 pnormalize(vec3 p) {\n  if (p.z < 0.0) p = -p;\n  return hnormalize(p);\n}\n\n// Map point on plane to hyperboloid hnorm(p) = -1\nvec3 unproject(vec2 z) {\n  // k²|z|²-(1-k)² = -1\n  // k²|z|²-1+2k-k² = -1\n  // k|z|²+2-k = 0\n  float k = 2.0/(1.0-dot(z,z));\n  return vec3(k*z,k-1.0);\n}\n\n// NB: sinh(x) = asinh(x) = tanh(x) = x (approximately) for\n// small values of x (eg. sinh 0.1 = 0.10017, tanh 0.1 = 0.0997)\n// Hyperbolic distance from line\nfloat hline(vec3 p, vec3 l) {\n  return abs(asinh(hdot(p,l)));\n}\n\n// Hyperbolic distance between points\nfloat hpoint(vec3 p, vec3 q) {\n  //return acosh(-hdot(p,q)); // Bad truncation error\n  return 2.0*abs(asinh(0.5*hlength(p-q)));\n}\n\n// Reflect in a hyperbolic line\nint tryreflect(vec3 l, int i, inout vec3 p, inout uint h) {\n  float k = hdot(p,l);\n  if (k > 0.0) return 0;\n  p -= 2.0*k*l;\n  h = ihash(h^uint(i));\n  return 1;\n}\n\n// Reflect in a euclidean line\nint tryreflect(vec2 l, int i, inout vec2 z, inout uint h) {\n  float k = dot(z,l);\n  if (k > 0.0) return 0;\n  z -= 2.0*k*l;\n  h = ihash(h^uint(i));\n  return 1;\n}\n\n// Invert in a euclidean circle\nint tryinvert(vec3 c, int i, inout vec2 z, inout uint h) {\n  float r2 = c.z;\n  vec2 z1 = z-c.xy;\n  float l2 = dot(z1,z1);\n  if (l2 > r2) return 0;\n  z1 *= r2/l2;\n  z = z1+c.xy;\n  h = ihash(h^uint(i));\n  return 1;\n}\n\n// Convert hyperbolic line into a Euclidean circle.\n// z component is square of radius.\nvec3 tocircle(vec3 l) {\n  assert(l.z != 0.0);\n  l /= l.z;\n  l.z = dot(l.xy,l.xy)-1.0;\n  return l;\n}\n\n// Convert hyperbolic line into a Euclidean line.\nvec2 toline(vec3 l) {\n  assert(l.z == 0.0);\n  return l.xy;\n}\n\nvec3 fold(vec2 z, int nfolds, mat3 edges, inout uint h, inout int parity) {\n  // Using Poincare model for the fold seems to be more stable\n  // so convert hyperbolic lines to Euclidean lines or circles\n  vec3 a = tocircle(edges[0]);\n  vec3 a1 = a*vec3(-1,1,1);\n  vec2 b = toline(edges[1]);\n  vec2 c = toline(edges[2]);\n  for (int step = 0; step < nfolds; step++) {\n    int k = 0;\n    uint h0;\n    k += tryinvert(a,0,z,h);\n    k += tryinvert(a1,1,z,h);\n    k += tryreflect(b,2,z,h);\n    if (k == 1 || k == 3) z.x = -z.x; // Keep chirality\n    if (k == 0) break;\n    parity += k;\n  }\n  return unproject(z);\n}\n\nvec3 hfold(vec2 z, int nsteps, mat3 edges, inout uint h, inout int parity) {\n  // Neat, but errors accumulate much more quickly\n  vec3 p = unproject(z);\n  for (int step = 0; step < nsteps; step++) {\n    int k = 0;\n    for (int i = 0; i < N; i++) {\n      k += tryreflect(edges[i],i,p,h);\n    }\n    if (k == 0) break;\n    parity += k;\n  }\n  return p;\n}\n\nvec3 absx(vec3 p) {\n  p.x = abs(p.x);\n  return p;\n}\n\n// Construct the sides of a hyperbolic triangle, for\n// p,q,r the cosines of the dihedral angles.\n// b.c = -p, c.a = -q, a.b = -r.\n// (Side a is opposite point A at (0,0,1) etc.)\n// These are normals so that side c is the y-axis, etc.\n// Ensure everthing is properly (h)normalized.\nmat3 triangle(float p, float q, float r) {\n  vec3 c = vec3(1,0,0);\n  vec3 b = vec3(-p,sqrt(1.0-p*p),0);\n  // a = (x,y,z):\n  // a.c = -r -> x = -r\n  // a.b = -q = -r*-p + y*b.y = -q\n  // x²+y²-z² = 1\n  float x = -r, y = -(q+p*r)/b.y, z = -sqrt(x*x+y*y-1.0);\n  vec3 a = vec3(x,y,z);\n  return mat3(a,b,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  config(int(iTime));\n  mat3 edges = triangle(icos(angles[0]),icos(angles[1]),icos(angles[2]));\n  mat3 points = mat3(vec3(0,0,1),\n                     hnormalize(hcross(edges[2],edges[0])),\n                     hnormalize(hcross(edges[0],edges[1])));\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      // Check incidence relation\n      assert(eq(hdot(points[i],edges[j]),0.0) == (i != j));\n    }\n  }\n  assert(eq(hdot(points[0],edges[1]),0.0));\n  vec2 z = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  vec2 w = vec2(0);\n  if (!configmode) w = defaultselection();\n  \n  float px = fwidth(z.x);\n  bool dohalfplane = key(CHAR_H);\n  bool dozoom = key(CHAR_Z);\n  if (dohalfplane) z.y += 1.0;\n  // Conversion factor between hyperbolic and screen distances\n  float scalefactor = 1.0;\n  if (dohalfplane) {\n    if (dozoom) {\n      float k = exp(-iTime);\n      z *= k;\n      scalefactor /= k;\n    }\n    z.y += 1.0;\n    float k = 2.0/dot(z,z);\n    z *= k;\n    scalefactor /= k;\n    z.y -= 1.0;\n  }\n  scalefactor *= 0.5*abs(1.0 - dot(z,z));\n  if (!configmode) {\n    // Invert to mouse position\n    vec2 c = w;\n    z -= c;\n    z *= (dot(c,c)-1.0)/dot(z,z);\n    z += c;\n    z /= -dot(z,z);\n  }\n  px /= scalefactor;\n  bool indisc = dot(z,z) <= 1.0;\n  if (!indisc) z /= dot(z,z);\n  int nfolds = configmode ? 0 : 20;\n  uint h = 12345678u; // hash for region\n  int flips = 0;\n  vec3 p = (doubleup) ? fold(z,nfolds,edges,h,flips) : hfold(z,nfolds,edges,h,flips);\n  bool parity = flips%2 == 1;\n  //p.x = abs(p.x);\n  vec3 col = vec3(1,1,0.5);\n  if (!configmode && !key(CHAR_C)) col = h2rgb(float(h)/exp2(32.0));\n  //if (parity) col *= 0.5;\n  vec3 lcol = vec3(0.2);\n  {\n    float t = 1e8;\n    for (int i = 0; i < N; i++) {\n      if (doubleup && i == 2) continue;\n      t = min(t,hline(absx(p),edges[i]));\n    }\n    col = mix(lcol,col,smoothstep(0.0,px,abs(t)));\n  }\n  if (!key(CHAR_W)) {\n    vec3 xflip = vec3(-1,1,1);\n    vec3 A = points[0], B = points[1], C = points[2];\n    vec3 a = edges[0], b = edges[1], c = edges[2];\n    vec3 lines[3];\n    if (doubleup) {\n      vec3 a1 = xflip*a;\n      vec3 d = hcross(C,a1); // Altitude\n      vec3 D = hcross(d,a1); // Foot of altitude\n      vec3 D1 = xflip*D;\n      vec3 f = hnormalize(hcross(A,D)); // Left side of orthic\n      vec3 f1 = xflip*f; // Right side of orthic\n      vec3 g = hnormalize(hcross(D,D1)); // Top side of orthic\n      lines = vec3[](f,f1,g);\n    } else {\n      vec3 d = hcross(A,a); // Altitudes\n      vec3 e = hcross(B,b);\n      vec3 f = hcross(C,c);\n      vec3 D = hcross(a,d);\n      vec3 E = hcross(b,e);\n      vec3 F = hcross(c,f);\n      vec3 g = hnormalize(hcross(D,E));\n      vec3 h = hnormalize(hcross(E,F));\n      vec3 i = hnormalize(hcross(F,D));\n      lines = vec3[](h,g,i);\n      if (parity) lines = vec3[](i,g,h);\n    }\n    float t = 1e8; int imin = -1;\n    for (int i = 0; i < lines.length(); i++) {\n      float t = hline(p,lines[i]);\n      //0 beats 1, 1 beats 2, 2 beats 0\n      bool draw = false;\n      if (t < lwidth+px) {\n        if (imin < 0 || i == 0) { draw = true; imin = i; }\n        else if (i == 2 && imin == 0) { draw = true; imin = i; }\n      }\n      if (draw) {\n        col = mix(lcol,col,smoothstep(0.0,px,t - lwidth));\n        col = mix(vec3(1),col,smoothstep(0.0,px,abs(t - lwidth)));\n      }\n    }\n  }  \n  if (!key(CHAR_D) && !indisc) col *= 0.0;\n  col = pow(col,vec3(0.4545));\n  if (!key(CHAR_A) && alert) col.r = 1.0;\n  fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define map(screenpos) ((2.0*(screenpos)-iResolution.xy)/iResolution.y)\n\nconst float PI = 3.141592654;\nconst float TWOPI = 2.0*PI;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n// const int KEY_SHIFT = 16;\n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\n// const int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\n// const int CHAR_K = 75;\nconst int CHAR_L = 76;\n//const int CHAR_M = 77;\nconst int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\n// const int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\n// const int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n\nvec2 expi(float t) {\n  return normalize(vec2(cos(t),sin(t)));\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nbool eq(float a, float b) {\n  return abs(a-b) < 1e-4;\n}\n\nfloat COS[] =\n  float[](1.0,-1.0,0.0,0.5,0.7071067812,0.8090169944,0.8660254038,\n          0.9009688679,0.9238795325,0.9396926208,0.9510565163,0.9594929736,\n          0.9659258263,0.9709418174,0.9749279122,0.9781476007,0.9807852804,\n          0.9829730997,0.984807753,0.9863613034,0.9876883406,0.9888308262,\n          0.9898214419,0.990685946,0.9914448614,0.9921147013,0.9927088741,\n          0.9932383577,0.9937122099,0.9941379572,0.9945218954,0.9948693234);\n\nfloat icos(int p) {\n  // cos(PI/p)\n  if (p < COS.length()) return COS[p];\n  return cos(PI/float(p));\n}\n                        \nfloat isin(int p) {\n  // sin(PI/p)\n  float t = icos(p);\n  return sqrt(1.0-t*t);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}