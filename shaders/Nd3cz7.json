{
    "Shader": {
        "info": {
            "date": "1653147876",
            "description": "A rather simple shader to play with refractions, noise, and the oklab colorspace.",
            "flags": 0,
            "hasliked": 0,
            "id": "Nd3cz7",
            "likes": 5,
            "name": "Water Tiles",
            "published": 3,
            "tags": [
                "water"
            ],
            "usePreview": 0,
            "username": "bmatcuk",
            "viewed": 309
        },
        "renderpass": [
            {
                "code": "#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\n\n// Modulo 289 without a division (only multiplications)\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\n// Permutation polynomial: (34x^2 + 6x) mod 289\nfloat permute(float x) {\n  return mod289((34.0 * x + 10.0) * x);\n}\n\nvec3 permute(vec3 x) {\n  return mod289((34.0 * x + 10.0) * x);\n}\n\nvec4 permute(vec4 x) {\n  return mod289((34.0 * x + 10.0) * x);\n}\n\n// Hashed 2-D gradients with an extra rotation.\n// (The constant 0.0243902439 is 1/41)\nvec2 rgrad2(vec2 p, float rot) {\n#if 0\n// Map from a line to a diamond such that a shift maps to a rotation.\n  float u = permute(permute(p.x) + p.y) * 0.0243902439 + rot; // Rotate by shift\n  u = 4.0 * fract(u) - 2.0;\n  // (This vector could be normalized, exactly or approximately.)\n  return vec2(abs(u)-1.0, abs(abs(u+1.0)-2.0)-1.0);\n#else\n// For more isotropic gradients, sin/cos can be used instead.\n  float u = permute(permute(p.x) + p.y) * 0.0243902439 + rot; // Rotate by shift\n  u = fract(u) * 6.28318530718; // 2*pi\n  return vec2(cos(u), sin(u));\n#endif\n}\n\n//\n// 2-D non-tiling simplex noise with rotating gradients and analytical derivative.\n// The first component of the 3-element return vector is the noise value,\n// and the second and third components are the x and y partial derivatives.\n//\nvec3 srdnoise(vec2 pos, float rot) {\n  // Offset y slightly to hide some rare artifacts\n  pos.y += 0.001;\n  // Skew to hexagonal grid\n  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n  vec2 i0 = floor(uv);\n  vec2 f0 = fract(uv);\n  // Traversal order\n  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n  // Unskewed grid points in (x,y) space\n  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n  // Integer grid point indices in (u,v) space\n  i1 = i0 + i1;\n  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n  // Vectors in unskewed (x,y) coordinates from\n  // each of the simplex corners to the evaluation point\n  vec2 d0 = pos - p0;\n  vec2 d1 = pos - p1;\n  vec2 d2 = pos - p2;\n\n  vec3 x = vec3(p0.x, p1.x, p2.x);\n  vec3 y = vec3(p0.y, p1.y, p2.y);\n  vec3 iuw = x + 0.5 * y;\n  vec3 ivw = y;\n\n  // Avoid precision issues in permutation\n  iuw = mod289(iuw);\n  ivw = mod289(ivw);\n\n  // Create gradients from indices\n  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n  // Gradients dot vectors to corresponding corners\n  // (The derivatives of this are simply the gradients)\n  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n  // Radial weights from corners\n  // 0.8 is the square of 2/sqrt(5), the distance from\n  // a grid point to the nearest simplex boundary\n  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n  // Partial derivatives for analytical gradient computation\n  vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);\n  vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);\n\n  // Set influence of each surflet to zero outside radius sqrt(0.8)\n  if (t.x < 0.0) {\n    dtdx.x = 0.0;\n    dtdy.x = 0.0;\n\tt.x = 0.0;\n  }\n  if (t.y < 0.0) {\n    dtdx.y = 0.0;\n    dtdy.y = 0.0;\n\tt.y = 0.0;\n  }\n  if (t.z < 0.0) {\n    dtdx.z = 0.0;\n    dtdy.z = 0.0;\n\tt.z = 0.0;\n  }\n\n  // Fourth power of t (and third power for derivative)\n  vec3 t2 = t * t;\n  vec3 t4 = t2 * t2;\n  vec3 t3 = t2 * t;\n\n  // Final noise value is:\n  // sum of ((radial weights) times (gradient dot vector from corner))\n  float n = dot(t4, w);\n\n  // Final analytical derivative (gradient of a sum of scalar products)\n  vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;\n  vec2 dn0 = t4.x * g0 + dt0 * w.x;\n  vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;\n  vec2 dn1 = t4.y * g1 + dt1 * w.y;\n  vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;\n  vec2 dn2 = t4.z * g2 + dt2 * w.z;\n\n  return 11.0*vec3(n, dn0 + dn1 + dn2);\n}\n\n/**\n * Convert OKLab to RGB\n * @param lab Color in OKLab\n * @see https://bottosson.github.io/posts/oklab/\n */\nvec3 oklab2rgb(vec3 lab) {\n  const mat3 m1 = mat3(\n    1.0, 1.0, 1.0,\n    0.3963377774, -0.1055613458, -0.0894841775,\n    0.2158037573, -0.0638541728, -1.2914855480\n  );\n  const mat3 m2 = mat3(\n    4.0767416621, -1.2684380046, -0.0041960863,\n    -3.3077115913, 2.6097574011, -0.7034186147,\n    0.2309699292, -0.3413193965, 1.7076147010\n  );\n  vec3 lms = m1 * lab;\n  return clamp(m2 * (lms * lms * lms), 0.0, 1.0);\n}\n\n/**\n * Convert LCh(oklab) to RGB\n * @param lch Color in LCh(oklab)\n */\nvec3 lchoklab2rgb(vec3 lch) {\n  float hrad = radians(lch.z);\n  vec3 lab = vec3(\n    lch.x,\n    lch.y * cos(hrad),\n    lch.y * sin(hrad)\n  );\n  return oklab2rgb(lab);\n}\n\nfloat _rgbLinear2Component_1540259130(float c) {\n  if (c <= 0.0031308) {\n    return 12.92 * c;\n  }\n  return 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\n\n/**\n * Convert linear RGB to RGB\n * @param linear Color in linear RGB\n * @see http://www.brucelindbloom.com/index.html?Eqn_XYZ_to_RGB.html\n */\nvec3 linear2rgb(vec3 linear) {\n  return vec3(\n    _rgbLinear2Component_1540259130(linear.r),\n    _rgbLinear2Component_1540259130(linear.g),\n    _rgbLinear2Component_1540259130(linear.b)\n  );\n}\n\nconst vec3 blue = vec3(0.8, 0.470, 230.0);\nconst vec3 pink = vec3(0.8, 0.470, 280.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float minor_axis = min(iResolution.x, iResolution.y);\n  vec2 st = fragCoord.xy / minor_axis;\n\n  // These values are used to put a roughly 5% border around the whole image.\n  // The border is aligned to an even multiple of 15px so no fractional boxes\n  // will appear. Additionally, since the bottom/left borders may be different\n  // than the top/right depending on how close the edges are to even-15px\n  // rounding, we use an adjustment to recenter the image later on.\n  vec2 borderwidthbl = vec2(15.0 * floor(0.05 * minor_axis / 15.0));\n  vec2 borderwidthtr = iResolution.xy - borderwidthbl;\n  vec2 adjustment = mod(borderwidthtr, 15.0);\n  borderwidthtr = (borderwidthtr - adjustment) / minor_axis;\n  borderwidthbl /= minor_axis;\n  adjustment /= 2.0 * minor_axis;\n\n  // calculate noise - multiply the partial derivatives by 0.5 to \"calm down\"\n  // the waves, otherwise it's too choppy; noise is on a grid roughly 400x400\n  vec3 ndxdy = srdnoise((st + iTime * 0.1) * minor_axis / 400.0, 0.4);\n  vec2 dxdy = ndxdy.yz * 0.5;\n  float n = ndxdy.x;\n\n  // calculate normal from partial derivatives\n  vec3 normal = normalize(vec3(-dxdy.x, -dxdy.y, 1.0));\n\n  // calculate the transmission vector as if we're looking straight down on\n  // some water (with refraction index 1.33)\n  vec3 T = refract(vec3(0.0, 0.0, -1.0), normal, 1.0 / 1.33);\n\n  // follow that vector down 25 units... p represents the offset from our\n  // current position to what we'd be looking at through the water\n  vec2 p = T.xy * 25.0 / (abs(T.z) * minor_axis);\n\n  // imagine under the water is an infinite grid of 15x15px squares - by adding\n  // p to st, we can calculate what part of the grid we'd see at the current\n  // location. The adjustment is used to recenter the image here.\n  vec2 boxpos = p + st - adjustment;\n  if (\n    any(lessThan(boxpos, borderwidthbl)) ||\n    any(greaterThan(boxpos, borderwidthtr))\n  ) {\n    // add a border around the image\n    fragColor = vec4(1.0);\n    return;\n  }\n\n  // dist is how far away we are from a grid line, width is how wide the grid\n  // lines are, pct will be 0 if we're on a grid line and 1 as we move away\n  float boxsize = minor_axis / 15.0;\n  vec2 dist = 1.0 - 2.0 * abs(fract(boxpos * boxsize) - 0.5);\n  vec2 width = vec2(mix(3.0, 3.5, n) * boxsize / minor_axis);\n  vec2 pct = smoothstep(vec2(0.0), width, dist);\n\n  // the color will be a gradient from top right to bottom left and white on\n  // the grid lines\n  vec2 bgpct = gl_FragCoord.xy / iResolution.xy;\n  vec3 color = mix(blue, pink, bgpct.x * bgpct.y);\n  color = mix(vec3(1.0, 0.0, color.z), color, pct.x * pct.y);\n  color = lchoklab2rgb(color);\n  color = linear2rgb(color);\n\n  fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}