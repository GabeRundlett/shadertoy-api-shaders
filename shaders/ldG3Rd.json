{
    "Shader": {
        "info": {
            "date": "1456186880",
            "description": "A creepy, foggy pathway!",
            "flags": 0,
            "hasliked": 0,
            "id": "ldG3Rd",
            "likes": 3,
            "name": "Foggy Path",
            "published": 3,
            "tags": [
                "fog",
                "path",
                "creepy",
                "horror",
                "eerie"
            ],
            "usePreview": 0,
            "username": "jackdavenport",
            "viewed": 898
        },
        "renderpass": [
            {
                "code": "#define MAX_ITERATIONS 128\n#define MIN_DISTANCE  .001\n\n#define MOON_COLOR vec3(.2,.2,.3)\n#define MOON_DIR normalize(vec3(35.,30.,25.))\n\nstruct Ray { vec3 ori; vec3 dir; };\nstruct Dst { float dst; int id;  };\nstruct Hit { vec3 p; int id;     };\n    \n// Source: http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand(vec2 co) {\n    \n    return fract(sin(dot(co.xy,vec2(12.9898,78.233)))*43758.5453);\n\n}\n    \nDst dstLightpole(vec3 p, vec3 pos) {\n    \n    float rep = 4.;\n    p.z = mod(p.z, rep) - rep * .5;\n    \n    vec3 r = pos - p;\n    vec2 d = abs(vec2(length(r.xz),r.y)) - vec2(.1,.75);\n \tfloat dst = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    \n    vec2 q = vec2( length(r.xz), r.y + .6 );\n    vec3 c = vec3(.4,.4,.3);\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    d = max(qv,0.0)*qv/vv;\n   \tdst = min(sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y)), dst);\n    \n    return Dst(dst, 0);\n    \n}\n\nDst dstGround(vec3 p, float y, bool shadow) {\n \n    if(!shadow) y += texture(iChannel0, mod(p.xz,1.)).r * .005;\n    return Dst(p.y - y, 1);\n    \n}\n\nDst minDst(Dst a, Dst b) {\n \n    if(a.dst < b.dst) return a;\n    return b;\n    \n}\n\nDst dstScene(vec3 p, bool shadow) {\n \n    Dst dst = dstLightpole(p, vec3(1.3,-.25,.5));\n    dst = minDst(dst, dstLightpole(p, vec3(-1.3,-.25,.5)));\n    dst = minDst(dst, dstGround(p, -1., shadow));\n    \n    return dst;\n    \n}\n    \nHit raymarch(Ray ray, bool shadow) {\n \n    vec3 p = ray.ori;\n    int id = -1;\n    \n    for(int i = 0; i < MAX_ITERATIONS; i++) {\n     \n        Dst scn = dstScene(p, shadow);\n        p += ray.dir * scn.dst * .75;\n        \n        if(scn.dst < MIN_DISTANCE) {\n         \n            id = scn.id;\n            break;\n            \n        }\n        \n    }\n    \n    return Hit(p,id);\n    \n}\n\nvec3 calcNormal(vec3 p) {\n \n    vec2 eps = vec2(.001,0.);\n    vec3   n = vec3(dstScene(p + eps.xyy,false).dst - dstScene(p - eps.xyy,false).dst,\n                    dstScene(p + eps.yxy,false).dst - dstScene(p - eps.yxy,false).dst,\n                    dstScene(p + eps.yyx,false).dst - dstScene(p - eps.yyx,false).dst);\n    return normalize(n);\n    \n}\n\nbool inShadow(vec3 p) {\n \n    Ray sr = Ray(p + MOON_DIR * .005, MOON_DIR);\n    Hit sh = raymarch(sr, true);\n    return sh.id != -1;\n    \n}\n\nvec3 calcLighting(Hit scn, vec3 n, bool s) {\n \n    float d = max(dot(MOON_DIR,n), 0.);\n    if(s) d = 0.;\n    \n    return MOON_COLOR * d;\n    \n}\n\nvec3 calcSpecular(vec3 r, float shininess, bool s) {\n \n    float f = max(pow(dot(r,MOON_DIR),shininess),0.);\n    if(s) f = 0.;\n    \n    return MOON_COLOR * f;\n    \n}\n\nfloat getFog(Ray ray, vec3 p) {\n \n    float dst = distance(ray.ori, p);\n    return smoothstep(1., 15., dst);\n    \n}\n\nvec3 shadeGround(Ray ray, Hit scn) {\n \n    bool s = inShadow(scn.p);\n        \n    vec2 uv = mod(scn.p.xz, 1.);\n    vec3  n = calcNormal(scn.p);\n    vec3  l = calcLighting(scn, n, s);\n        \n    vec3 tx = texture(iChannel0, uv).xyz * vec3(0.,1.,0.);\n    if(scn.p.x > -1. && scn.p.x < 1.) tx = texture(iChannel0, uv).xyz * vec3(.34,.23,.05);\n        \n    tx *= l;\n    tx += calcSpecular(reflect(ray.dir,n), 5., s);\n    \n    return tx;\n    \n}\n\nvec3 shade(Ray ray) {\n    \n    Hit scn  = raymarch(ray, false);\n    vec3 col = vec3(0.);\n    \n    float fog = getFog(ray,scn.p);\n    if(fog == 1.) return MOON_COLOR;\n    \n    if(scn.id == 0) {\n    \n        bool s = inShadow(scn.p);\n        \n        vec3 n = calcNormal(scn.p);\n        vec3 l = calcLighting(scn, n, s);\n        vec3 r = reflect(ray.dir, n);\n        \n        col = vec3(.5) * l;\n        \n        Ray rr  = Ray(scn.p + r * .01, r);\n        Hit rh  = raymarch(rr, true);\n        vec3 rc = rh.id == 1 ? shadeGround(rr,rh) : mix(col,MOON_COLOR,getFog(rr,rh.p));\n        \n        float fresnel = mix(.2,.9, max(dot(ray.dir,n), 0.));\n        col = mix(col, rc, fresnel);\n        \n        col += calcSpecular(r, 90., s);\n        \n\t} else if(scn.id == 1) {\n     \n        col = shadeGround(ray, scn);\n        \n    }\n    \n    col = mix(col, MOON_COLOR, fog);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    vec2 m = (iMouse.xy / iResolution.xy) * 2. - 1.;\n    if(iMouse.xy == vec2(0.)) m = vec2(0.);\n    \n    vec3 ori = vec3(m.x * .3,m.y * .4,-3. + (iTime * .2));\n    vec3 dir = vec3(uv, 1.);\n    \n    vec3 col = shade(Ray(ori,dir));\n\tfragColor = vec4(col,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}