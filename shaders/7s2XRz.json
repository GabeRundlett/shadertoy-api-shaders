{
    "Shader": {
        "info": {
            "date": "1620865855",
            "description": "Distance to a circle inverted box by converting its edges to circle segments. Has artifacts due to very extreme cases, WIP.",
            "flags": 0,
            "hasliked": 0,
            "id": "7s2XRz",
            "likes": 6,
            "name": "Distance to Circle Inverted Box",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "circle",
                "box",
                "inverted",
                "arc"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 190
        },
        "renderpass": [
            {
                "code": "// Utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// SDFs\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\n// ax: vec2(cos(axis), sin(axis))\n// ap: vec2(cos(aperture), sin(aperture))\nfloat sdArc(in vec2 p, in vec2 ax, in vec2 ap, in float r) {\n    p = vec2(dot(p, ax), abs(p.y * ax.x - p.x * ax.y));\n    return p.y * ap.x < p.x * ap.y ? abs(length(p) - r) : length(p - ap * r);\n}\n\nfloat cInvSegment(in vec2 p, in vec2 a, in vec2 aInv, in vec2 b, in vec2 bInv) {\n    vec2 ba = b - a;\n\n    // The closest point on the line segment to the origin will invert the farthest away.\n    // Since the line stretches to infinity, its inversion will wrap around to the origin.\n    // The center is then halfway between the farthest point on the line's inversion and the origin.\n    // The radius is then the distance from a point on the line's inversion to the center.\n    vec2 cen = a - ba * dot(a, ba) / dot(ba, ba);\n    cen = 0.5 * cen / dot(cen, cen);\n    float rad = length(cen);\n\n    // The arc lies on one side of the line passing through the end points.\n    // Taking a point on the line's inversion (within the segment only) and projecting\n    // it onto the line passing through endpoints allows the direction in which the\n    // arc lies to be calculated.\n    vec2 far = 0.5 * (a + b), baInv = bInv - aInv;\n    far = far / dot(far, far);\n    vec2 faInv = far - aInv;\n    far = normalize(faInv - baInv * dot(faInv, baInv) / dot(baInv, baInv));\n\n    // Return distance to circle segment\n    aInv -= cen;\n    float ap = dot(aInv, far) / length(aInv);\n    return sdArc(p - cen, far, vec2(ap, sqrt(1.0 - ap * ap)), rad);\n}\n\n// Precomputes values and then combines the distance to each edge and the sign\nfloat sdCircleInvBox(in vec2 p, in mat3 t, in vec2 b, in float r) {\n    float rr = r * r;\n    p /= rr;\n\n    // Transform and invert through a circle\n    vec2 v1 = (vec3(-b,         1.0) * t).xy, v1Inv = v1 / dot(v1, v1);\n    vec2 v2 = (vec3( b.x, -b.y, 1.0) * t).xy, v2Inv = v2 / dot(v2, v2);\n    vec2 v3 = (vec3( b,         1.0) * t).xy, v3Inv = v3 / dot(v3, v3);\n    vec2 v4 = (vec3(-b.x,  b.y, 1.0) * t).xy, v4Inv = v4 / dot(v4, v4);\n\n    // Combine edges\n    float d =  cInvSegment(p, v1, v1Inv, v2, v2Inv);\n    d = min(d, cInvSegment(p, v2, v2Inv, v3, v3Inv));\n    d = min(d, cInvSegment(p, v3, v3Inv, v4, v4Inv));\n    d = min(d, cInvSegment(p, v4, v4Inv, v1, v1Inv));\n\n    // Get sign and return signed distance\n    p = abs((vec3(p / dot(p, p), 1.0) * inverse(t)).xy) - b;\n    return d * rr * sign(max(p.x, p.y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n\n    // Default before interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse.xy = vec2(cos(iTime), sin(iTime)) * 0.75;\n\n    vec2 a = mouse.xy;\n    vec2 b = mouse.zw;\n    float r = 1.0;\n\n    float cInvBox = sdCircleInvBox(uv, mat3(1.0, 0.0, mouse.x, 0.0, 1.0, mouse.y, 0.0, 0.0, 1.0), vec2(0.25), r) * 0.5;\n    if (mod(iTime * 0.5, 2.0) < 1.0) cInvBox = sdBox(uv * r * r / dot(uv, uv) - mouse.xy, vec2(0.25));\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(cInvBox) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(cInvBox));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * cInvBox);\n    color = mix(color, vec3(0.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.015, abs(cInvBox)));\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}