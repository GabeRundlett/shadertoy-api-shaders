{
    "Shader": {
        "info": {
            "date": "1665009152",
            "description": "while doing research on cone marching and looking for optimisations,\ni found a way of getting the distance between a \"cone\" and a point.\nfinally, i'm not sure what this could be useful for, bet there it is :)",
            "flags": 0,
            "hasliked": 0,
            "id": "NtGfzt",
            "likes": 6,
            "name": "cone - point intersection",
            "published": 3,
            "tags": [
                "cone"
            ],
            "usePreview": 0,
            "username": "sympou",
            "viewed": 205
        },
        "renderpass": [
            {
                "code": "#define coneWidth .25\n#define ptPos  vec2(0.5)\n#define camPos vec2(0.1,0.2)\n\n#define lineWidth 2.\n\nfloat circleDist(vec2 pos, vec2 pt, float radius) {\n    return abs(length(pos-pt) - radius);\n}\nfloat circleFillDist(vec2 pos, vec2 pt, float radius) {\n    return max(length(pos-pt) - radius, 0.);\n}\nfloat segLineDist(vec2 pos, vec2 a, vec2 b) {\n    vec2 pa = pos-a, ba = b-a;\n    float h = max( dot(pa,ba) / dot(ba,ba), 0.0);\n    return length( pa - ba*h );\n}\nfloat smoothLine( in float x) {\n    float t = clamp(x , 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 p = fragCoord;\n    vec2 m = iMouse.xy;\n\n    if ( m == vec2(0.) ) m = vec2(0.5,0.5+cos(iTime)*0.1) * iResolution.xy;\n\n    vec2 ro = camPos * iResolution.xy;\n    vec2 pt = ptPos  * iResolution.xy;\n\n\n    //distance of closest shape\n    float d = 99999.;\n    \n    vec3 col = vec3(1.);\n\n    /////////\n        \n    //direction between mouse and origin\n    vec2  rd = normalize(m - ro);\n\n    //direction and length between the point and origin\n    vec2  sr   = pt - ro;\n    float len2 = length(sr);\n    vec2  rd2  = sr / len2;\n    \n    ///////\n        \n    //coordinates of the \"hidden\" circle,\n    //on which the collision actually occurs\n    float cw2  = coneWidth*coneWidth;\n    float dist = len2 / (1. - cw2);\n    float rad  = dist * coneWidth;\n     \n    //ray-circle intersection\n    //https://www.shadertoy.com/view/4d2XWV\n    vec2 oc = - rd2 * dist;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - rad*rad;\n    float h = sqrt(b*b - c);\n    float tN = - b - h;\n    float tF = - b + h;\n    \n    /////////\n \n    //drawing the starting point\n    d = min(d, circleFillDist(p, ro, 2.5));\n    \n    //drawing the target point\n    d = min(d, circleFillDist(p, pt, 2.5));\n\n    //drawing the edges of the cone\n    vec2 offset = vec2(rd.y,-rd.x) * coneWidth / sqrt(1.-cw2);\n    d = min(d, segLineDist(p, ro, ro + rd + offset));\n    d = min(d, segLineDist(p, ro, ro + rd - offset));\n\n    //drawing the two resulting circles\n    if ( tN > 0. ) {\n        d = min(d, circleDist(p, ro + rd * tN, coneWidth * tN));\n        d = min(d, circleDist(p, ro + rd * tF, coneWidth * tF));\n        d = min(d, circleFillDist(p, ro + rd * tN, 2.5));\n        d = min(d, circleFillDist(p, ro + rd * tF, 2.5));\n    }\n \n    //distance to color\n    d = smoothLine( d / lineWidth );\n    col = min(col, vec3( d ) );\n \n    //showing \"hidden\" circle and line\n    float d2 = circleDist(p, ro + rd2 * dist, rad);\n    d2 = min(d2, segLineDist(p, ro, ro + rd));\n    d2 = smoothLine( d2 / lineWidth );\n    col = min(col, vec3( mix(d2,1.,0.9) ) );\n\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}