{
    "Shader": {
        "info": {
            "date": "1701216651",
            "description": "It's as simple as pushing squares",
            "flags": 96,
            "hasliked": 0,
            "id": "DtcfWN",
            "likes": 8,
            "name": "Dancing Vaporwave Fern",
            "published": 3,
            "tags": [
                "bezier",
                "fern",
                "90s",
                "plant",
                "vaporwave"
            ],
            "usePreview": 0,
            "username": "Xibanya",
            "viewed": 218
        },
        "renderpass": [
            {
                "code": "float nrand(float x, float y) \n{\n    return fract(sin(dot(\n        vec2(x, y), vec2(12.9898, 78.233))) * \n        43758.5453); \n}\nvec4 Blend(vec4 top, vec4 bottom) \n{\n\tvec4 result;\n\tresult.a = top.a + bottom.a * (1.0 - top.a);\n\tresult.rgb = (top.rgb * top.aaa + bottom.rgb * bottom.aaa * \n        (vec3(1.0, 1.0, 1.0) - top.aaa)) / result.aaa;\n\treturn result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float jitter = nrand(uv.y, iTime / 20.) * 2. - 1.;\n    uv.x += jitter * step(0.0, abs(jitter)) * 0.00175;\n    \n    vec2 texel = 1. / iResolution.xy;\n\tvec3 duv = texel.xyx * vec3(0.5, 0.5, -0.5);\n\n\tvec3 blur = texture(iChannel0, uv.xy - duv.xy).rgb;\n\tblur += texture(iChannel0, uv.xy - duv.zy).rgb;\n\tblur += texture(iChannel0, uv.xy + duv.zy).rgb;\n\tblur += texture(iChannel0, uv.xy + duv.xy).rgb;\n\tblur /= 4.;\n    \n    float sub = -0.1;\n    float hard = 0.3;\n\n    float modulo = floor(mod(uv.x / texel.x * 0.25, 3.0));\n    vec3 tmp = blur.rgb;\n    float is0 = step(modulo, 0.) * step(0., modulo);\n    float is1 = step(1., modulo) * step(modulo, 1.);\n    tmp -= vec3(0., sub * hard, \n        sub * hard * 2.0) * is0;\n    tmp -= vec3(sub * hard, 0., \n        sub * hard) * step(1., modulo) * step(modulo, 1.);\n    tmp -= vec3(sub * hard * 2.0, \n        sub * hard, 0.) * (1. - is0) * (1. - is1);\n    vec3 col = Blend(vec4(tmp, 0.9), vec4(blur, 1.)).rgb;\n    \n    float scanline = \n        sin((uv.y - sin(iTime / 200.)) * iResolution.y) * 0.025;\n    col.rgb -= scanline;\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// I was inspired by 4rknova's shader to see if I \n// could animate objects as if they were anchored to\n// a point in on a curve. Most of the curve-drawing\n// code is adapted from https://www.shadertoy.com/view/ll23Wt\n// ------------------------------------------\n\n// colors used to draw the plant\n#define LEAF vec3(0.5, 0.6, 0.5)\n#define LEAF_TIP vec3(0.68, .7, 0.97)\n#define LEAF_OUTLINE vec3(0.7, .75, 0.95)\n// if progress along curve is less than this\n// then the plant should be drawn even if\n// outside the triangle\n#define THRESH 0.5\n\n// ------------------------------------------------\n// bezier functions from \n// Interpolation: Bezier, Cubic\n// by 4rknova\n// https://www.shadertoy.com/view/ll23Wt\n#define STEPS  25.\n#define STROKE .9\n#define LEAF_COUNT 19.\n#define EPS    .01\n\nvec2 interpolate(vec2 a, vec2 b, vec2 c, vec2 d, float p)\n{\n    vec2 v0 = mix(a, b, p);\n    vec2 v1 = mix(b, c, p);\n    vec2 v2 = mix(c, d, p);\n    vec2 v3 = mix(v0, v1, p);\n    vec2 v4 = mix(v1, v2, p);\n    \n    return mix(v3, v4, p);\n}\nfloat df_line(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\nfloat sharpen(in float d, in float w)\n{\n    float e = 1. / min(iResolution.y , iResolution.x);\n    return 1. - smoothstep(-e, e, d - w);\n}\n// ----------------------------------------------------\n\n// all sdf functions from iq\n//https://iquilezles.org/articles/distfunctions2d\nfloat sdEgg( in vec2 p, in float ra, in float rb )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    float r = ra - rb;\n    return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n            (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\nvec2 opRep(vec2 p, vec2 c)\n{\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\nvec2 opRepLim( in vec2 p, in vec2 s, in vec2 lima, in vec2 limb)\n{\n    return p-s*clamp(round(p/s),lima,limb);\n}\n//https://iquilezles.org/articles/functions\nfloat polyImpulse( float k, float n, float x )\n{\n    return (n/(n-1.0))*pow((n-1.0)*k,1.0/n)*x/(1.0+k*pow(x,n));\n}\n/////////////////////////////////////////////////////////\n// star functions adapted from \n// https://www.shadertoy.com/view/ssK3Dt by Scintoth\nfloat noiseFloat(vec2 p)\n{\n    p = fract(p * vec2(1000. * 0.21353, 1000. * 0.97019));\n    p = p + dot(p, p + 1000. * 0.54823);\n    return fract(p.x * p.y);\n}\nvec2 noiseVector(vec2 p)\n{\n    float n = noiseFloat(p);\n    return vec2(n, noiseFloat(p + n));\n}\nvec2 GetPos(vec2 id, vec2 offsets)\n{\n    vec2 n = noiseVector(id + offsets) * 500. * \n        (8000. / (1000. * 50.));\n    return (sin(n) * 0.9) + offsets;\n}\n\n\nfloat Audio(float x)\n{\n    return texture(iChannel0, vec2(x, 0.0)).r;\n}\n\n/////////////////////////\n\nfloat Leaf(vec2 uv, float radius, float tip, float pos)\n{\n    vec2 size = mix(vec2(4.), vec2(.75, 0.7), polyImpulse(1.75, 1.75, pos));\n    vec2 p = uv * size;\n    p += vec2(0., tip * 0.5);\n    float leaf = sdEgg(p, radius, tip);\n    leaf = min(leaf, sdEgg(-p, radius, tip));\n    return leaf;\n}\nfloat Margin(float sdf)\n{\n    return clamp(1. - smoothstep(0.005, 0.01, abs(sdf)), 0.0, 1.0);\n}\nfloat AStep(float d)\n{\n    return smoothstep(0.9, 1.01, d);\n}\nfloat MStep(float d)\n{\n    return 1. - clamp(smoothstep(-0.005, 0.0, d), 0., 1.);\n}\nvec2 Rotate2D( vec2 p, float theta )\n{\n    float co = cos( theta );\n    float si = sin( theta );\n    return vec2( co * p.x + si * p.y,\n                -si * p.x + co * p.y );\n}\nfloat LeafTier(vec2 uv, vec2 a, vec2 b, vec2 c, vec2 d, \n    float pos, out vec4 col)\n{\n\n    float bass = smoothstep(0.25, 1., Audio(0.1));\n    float mid = smoothstep(0.5, 0.7, Audio(0.5));\n    \n    vec2 end1 = interpolate(a, b, c, d, 0.);\n    vec2 p = interpolate(a, b, c, d, pos);\n    float radius = 0.04;\n    float tip = -0.45;\n    vec2 leafPos = uv - p;\n    float r = dot(leafPos, end1);\n    leafPos = Rotate2D(leafPos, -1. + r / max(0.2, pos));\n    float leaf = Leaf(leafPos, radius, tip, pos);\n    leafPos = Rotate2D(\n        leafPos, 2. - (cos(iTime * 0.5) * r / max(0.2, pos)));\n    leaf = min(leaf, Leaf(leafPos, radius, tip, pos));\n    float maxDist = .4 - min(.4, mid);\n    float dist = distance(uv, p);\n    dist = clamp(dist/maxDist, 0., 1.);\n    vec3 tipCol =  pow(pow(LEAF_TIP, vec3(1. - bass)), vec3(1. + mid));\n    col.rgb = mix(LEAF, tipCol, dist);\n    col.rgb = mix(col.rgb, LEAF_OUTLINE, Margin(leaf) * dist);\n    col.a = step(pos, THRESH);\n    return sharpen(leaf, EPS * 1.);\n}\n// leafCol.a used to determine if color should be \n// drawn outside the triangle container\nfloat Branch(in vec2 uv, out vec4 leafCol)\n{\n    float bass = smoothstep(0.25, 0.9, Audio(0.1));\n    float treb = smoothstep(0.4, 0.8, Audio(0.9));\n    \n    vec2 a = vec2(-.5 * (1. + treb * 0.5), .2 * (1. + bass * 0.2)) * 1. + (cos(-iTime * 0.5 + bass * 0.1) * 0.25);\n    vec2 b = vec2( .00, .75) * (cos(-iTime * 0.2 * (1. + bass * 0.05)) * 0.5 + 0.5);\n    vec2 c = vec2( .75,-.75 + treb * 1.); \n    vec2 d = vec2( .0, -1.);\n\n    float leaf = 0.;\n    float stem = 0.;\n    leafCol.a = 0.;\n    for (float i = 0.; i < STEPS; ++i)\n    {\n        vec2  p0 = interpolate(a, b, c, d, (i   ) / STEPS);\n        vec2  p1 = interpolate(a, b, c, d, (i+1.) / STEPS);\n        float l = sharpen(df_line(uv, p0, p1), EPS * STROKE);\n        // if the stem is higher than the threshold, want\n        // to draw it even if it is outside the triangle\n        leafCol.a = stem > l? leafCol.a : step(i / STEPS, THRESH);\n        stem = max(stem, l);\n    }   \n    leaf = stem;\n    leafCol.rgb = LEAF * 0.9 * stem;\n    for (float i = 0.1; i < LEAF_COUNT; i++)\n    {\n        vec4 nextCol;\n        float nextLeaf = LeafTier(uv, a, b, c, d, 0.05 * i, nextCol);\n        leafCol = mix(leafCol, nextCol, nextLeaf);\n        leaf = max(leaf, nextLeaf);\n    }\n    return leaf;\n}\nfloat IsBlack(vec3 col)\n{\n    return step(abs(col.r + col.g + col.b), 0.);\n}\nfloat IsWhite(vec3 col)\n{\n    return step(1., (col.r + col.g + col.b) / 3.);\n}\nvec3 Dodge(vec3 col, vec3 effect)\n{\n    float isBlack = IsBlack(effect);\n\tvec3 inverted = (1. - effect) * (1. - isBlack) + isBlack;\n\tfloat anyWhite = min(IsWhite(effect) + IsWhite(col), 1.);\n\treturn clamp(col / inverted, 0., 1.) * (1. - anyWhite) + anyWhite;\n}\n/////////////////////////////////////////////////////////\n// star functions adapted from \n// https://www.shadertoy.com/view/ssK3Dt by Scintoth\n\nfloat Stars(vec2 uv, float gain)\n{\n    uv -= 1.;\n    float m = 0.;\n    uv = uv * 10.;\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    int n = 0;\n    for (float y = -1.; y <= 1.; y++)\n    {\n        for (float x = -1.; x <= 1.; x++)\n        {\n            p[n++] = GetPos(id, vec2(x, y));\n        }\n    }\n    for (int i=0; i < 9; i++)\n    {\n        vec2 j = (p[i] - gv) * 2.0;\n        float sparkle = 0.1/dot(j, j) * (gain / 8000.0);\n        m = m + sparkle * (sin((8000.0 + p[i].x)* 0.5)*0.5 + 0.9);\n    }\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy * 2. - 1.);\n    uv.x *= iResolution.x / iResolution.y;\n    uv = uv * 0.8 + vec2(0.0, -0.1);\n\n    vec2 checkUV = opRepLim(uv * 10., vec2(2., 0.), \n        vec2(-10., 0.), vec2(10., 1.));\n    float check = sdBox(checkUV, vec2(0.5));\n    checkUV = opRepLim(uv * 10. + vec2(1., 1.), \n        vec2(2., 0.), vec2(-10., 0.), vec2(10., 1.));\n    check = min(check, sdBox(checkUV, vec2(0.5)));\n    float notChat = uv.x < 0.75? 1. : 0.;\n    vec3 bg = vec3(0.);\n    \n    float bass = smoothstep(0.4, 0.9, Audio(0.2));\n    float specks = smoothstep(0.05, 0.1, (Stars(uv * 0.5 / (1. - bass * 0.2), 50.)));\n    vec3 specCol = mix(vec3(1.), vec3(0.89, 0.435, 0.9), bass);\n    bg = clamp(bg + specCol * specks, 0., 1.);\n\n    //uv.x -= 0.15;\n    vec3 low = vec3(.8, .035, .96);\n    vec3 high = vec3(.39, .69, .94);\n    vec3 col = mix(low, high, clamp(uv.y + 1., 0., 1.));\n    vec4 leafCol = vec4(col, 0.);\n    float branch = AStep(Branch(uv, leafCol));\n    col = mix(col, leafCol.rgb, branch);\n    \n    \n    vec2 triUV = uv * 1.5 + vec2(0., 0.2);\n    triUV = Rotate2D(triUV, -iTime * 0.05);\n    float fullTri = sdEquilateralTriangle(triUV);\n    float tri = abs(fullTri) - 0.02;\n    vec3 dodge = Dodge(col, col);\n    col = mix(col, dodge, MStep(tri));\n    col = mix(col, bg, 1. - MStep(fullTri));\n    col = mix(col, leafCol.rgb, clamp(branch * leafCol.a, 0., 1.));\n\tfragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 35404,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/blankbanshee/wavestep?si=00eefcdf8412495e805a7e4d25f111c9"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}