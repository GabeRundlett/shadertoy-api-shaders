{
    "Shader": {
        "info": {
            "date": "1572530108",
            "description": "Using a triangular grid to construct a randomly connected impossible geometric lattice.",
            "flags": 0,
            "hasliked": 0,
            "id": "wd3XRj",
            "likes": 33,
            "name": "Impossible Geometric Lattice",
            "published": 3,
            "tags": [
                "grid",
                "triangle",
                "cube",
                "transparent",
                "geometry",
                "lattice",
                "impossible",
                "layer"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1131
        },
        "renderpass": [
            {
                "code": "/*\n\n\tImpossible Geometric Lattice\n\t----------------------------\n\n\tUsing a triangular grid to construct an impossible geometric lattice,\n\tconnected together with random, semi-transparent tubes. \n\n\tOne of my favorite pastimes is looking at a standard repeat pattern on \n\tthe net, then trying to figure out how to reconstruct it -- We all need \n\tour hobbies, right? :D Sometimes, I'll get lucky and figure it out \n\timmediately. Other times, I'll try for ages getting nowhere, then have \n\tto quit. However, if I'm patient enough, someone on Shadertoy will \n\teventually do it. :D\n\n\tThankfully, the trick behind the impossible geometric lattice pattern \n    came to me quickly. On the down side, I'd already produced it on a \n    diamond grid before realizing that a triangle grid version would allow \n\tfor a much more elegant construction. Whilst on the subject, I should\n\talso point out that a Wang tile approach would be even better, but this\n\tis another thing I only figured out at the end. :)\n\n\tAs mentioned above, this is an example of impossible geometry -- The \n    connections you're seeing wouldn't be possible in the real world, which \n    can mess with your sense of perception, but that's half the appeal.\n\n\tThe imagery was rendered in a psuedo pencil drawing style using 2D \n\ttechniques. Like the geometry itself, the lighting, shadows, etc, are a \n\tmixture of real world calculations and ones that don't really add up, \n\tso as when watching movies, a certain suspension of belief is necessary.\n\n\tIf you just wanted a simple connecting lattice, you could set up a\n\ttriangle grid, then render one cube face and connecting tube at each of\n\tthe three triangle vertex points, and you'd be done. Essentially, that's \n\tall I've done here. However, I got a little carried away prettying it\n\tup, adding shadows, extra settings, etc, so this is a little longer. \n\tHaving said that, it's still not what I'd describe as a long example.\n\n\n\n\tOther Impossible Geometry Examples:\n\n\t// Fabrice has covered everything at one point or another. :)\n\timpossible triangle (224 ch) -  FabriceNeyret2\n\thttps://www.shadertoy.com/view/XtyfDc\n\n\t// Beatiful example: There are some things you can't really achieve\n\t// with 2D overlays.\n\tPenrose Pathtraced - yx\n\thttps://www.shadertoy.com/view/ttXGWr\n\n*/\n\n\n// A regular equilateral scaling, which is just a special form of isosceles.\n// With an example like this, equilateral triangles are the way to go, but\n// I wanted to show that isosceles triangles are possible also. By the way,\n// on a diamond grid, playing with the stretch settings make more sense.\n#define EQUILATERAL\n\n\n// Adding in some noise. Comment it out for a smoother, cleaner look.\n#define NOISE_TEX\n\n// Turn the hatching on or off. I prefer it, but others might like a cleaner, \n// smoother, look.\n#define DO_HATCH\n\n// Flat shading. It looks cleaner, and probably looks a little more natural, \n// but I wanted vibrancy, for this particular example.\n//#define FLAT_SHADING\n\n// A hacky glass tube effect. Putting in more effect to render glass cubes\n// would be cool, but that would require more writing. :D\n//#define GLASS\t\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.687, 57.583)))*43758.5453); }\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\n// A hatch-like algorithm, or a stipple... or some kind of textured pattern.\nfloat doHatch(vec2 p, float res){\n    \n    \n    // The pattern is physically based, so needs to factor in screen resolution.\n    p *= res/16.;\n\n    // Random looking diagonal hatch lines.\n    float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.); // Diagonal lines.\n\n    // Slight randomization of the diagonal lines, but the trick is to do it with\n    // tiny squares instead of pixels.\n    float hRnd = hash21(floor(p*6.) + .73);\n    if(hRnd>.66) hatch = hRnd;  \n\n\n    return hatch;\n    \n}\n\n\n// IQ's standard box function.\nfloat sBox(in vec2 p, in vec2 b){\n   \n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n    \n   vec2 l = vec2(length(b - a), ew);\n   return sBox(p, (l + ew)/2.) ;\n}\n\n// Entirely based on IQ's signed distance to a 2D triangle -- Very handy.\n// I have a generalized version somewhere that's a little more succinct,\n// so I'll track that down and drop it in later.\nfloat quad(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3){\n\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p3 - p2;\n\tvec2 e3 = p0 - p3;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\tvec2 v3 = p - p3;\n\n\tvec2 pq0 = v0 - e0*clamp(dot(v0, e0)/dot(e0, e0), 0., 1.);\n\tvec2 pq1 = v1 - e1*clamp(dot(v1, e1)/dot(e1, e1), 0., 1.);\n\tvec2 pq2 = v2 - e2*clamp(dot(v2, e2)/dot(e2, e2), 0., 1.);\n\tvec2 pq3 = v3 - e3*clamp(dot(v3, e3)/dot(e3, e3), 0., 1.);\n    \n    float s = sign(e0.x*e3.y - e0.y*e3.x);\n    vec2 d = min( min( vec2(dot(pq0, pq0), s*(v0.x*e0.y - v0.y*e0.x)),\n                       vec2(dot(pq1, pq1), s*(v1.x*e1.y - v1.y*e1.x))),\n                       vec2(dot(pq2, pq2), s*(v2.x*e2.y - v2.y*e2.x)));\n    \n    d = min(d, vec2(dot(pq3, pq3), s*(v3.x*e3.y-v3.y*e3.x)));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n// Signed distance to a regular hexagon -- using IQ's more exact method.\nfloat sdHex(in vec2 p, in float r){\n    \n  const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n\n  // X and Y reflection.\n  p = abs(p);\n  p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n    \n  // Polygon side.\n  return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r);\n    \n}\n\n// \nfloat shade(vec2 p, float shd){\n    \n    #ifdef FLAT_SHADING\n    return pow(shd, 4.) + .25;\n    #else\n    \n    //float lgt = max(1.3 - length(p), 0.);\n    //return pow(lgt, 4.)*shd*shd + .2;\n   \n    shd *= max(1.3 - length(p), 0.);\n    return pow(shd, 4.) + .15;\n    #endif\n}\n\nfloat shade2(vec2 p, float shd){\n    \n    #ifdef FLAT_SHADING\n    return pow(shd, 4.) + .25;\n    #else\n    //float lgt = max(1.35 - length(p), 0.);\n    //return pow(lgt, 4.)*shd*shd + .25;\n   \n    shd *= max(1.35 - length(p), 0.);\n    return pow(shd, 4.) + .15;\n    #endif\n}\n\n\n\n// The scaling vector. Basically, it determines the height to width ratio.\n//\n#ifdef EQUILATERAL\n// An equilateral scaling, which is just a special kind of isosceles.\nconst vec2 s = vec2(1, .8660254); //1./.8660254\n#else\n// I wanted to show that this example would work with other scales too, even \n// if they don't look particularly great. :)\nconst vec2 s = vec2(1.3, 1)*.84; \n// One to one scaling -- which would effectively make the scaling redundant.\n//const vec2 s = vec2(1); \n#endif\n\n\nvec4 getTri(vec2 p, inout float itri){\n    \n    // Scaling the cordinates down, which makes them easier to work with. You scale \n    // them back up, after the calculations are done.\n    p /= s;\n    \n    // Triangles pack a grid nicely, but unfortunately, if you want vertices to \n    // match up, each alternate row needs to be shifted along by half the base \n    // width. The following vector will help effect that.\n    float ys = mod(floor(p.y), 2.)*.5;\n    vec4 ipY = vec4(ys, 0, ys + .5, 0);\n    \n    // Two triangles pack into each square cell, and each triangle uses the bottom \n    // left point as it's unique identifier. The two points are stored here.\n    vec4 ip4 = floor(p.xyxy + ipY) - ipY + .5; \n    \n    // The local coordinates of the two triangles are stored here.\n    vec4 p4 = fract(p.xyxy - ipY) - .5;\n    \n    // Which isoso... I always struggle to spell it... isosceles triangle\n    // are we in? Right way up, or upside down. By the way, if you're wondering\n    // where the following arises from, \"A*abs(x) + B*abs(y) - C\" partitions \n    // a quad and \"A*abs(x) +  B*y - C\" partitions a triangle.\n    float i = (abs(p4.x)*2. + p4.y<.5)? 1. : -1.;\n    \n    itri = i;\n    \n    // Depending on which triangle we're in, return a vector containing the local \n    // coordinates in the first two spots, and the unique position-based identifying \n    // number in the latter two spots. These two positions would be all you'd need\n    // to render a colored triangle grid. However, when combined with the triangle \n    // orientation and vertices (above), you can render more interesting things.\n    p4 = i>0.? vec4(p4.xy*s, ip4.xy) : vec4(p4.zw*s, ip4.zw);  \n    \n    return p4;\n    \n}\n\n\nvec3 triLattice(vec2 q, float sf, vec2 uv, float iRes){    \n \n    // The relative vertice positions. You could hardcode these into the formulae \n\t// below, but if you're performing various edge arithmetic, etc, they're handy \n\t// to keep around.\n\tvec2 v0 = vec2(-.5), v1 = vec2(0, .5), v2 = vec2(.5, -.5);\n\tvec2 v0Sh = v0, v1Sh = v1, v2Sh = v2;\n\n    // Keeping a copy of the original coordinate.\n    vec2 oP = q;\n    \n    // Rotating the entire grid, according to the grid dimensions. Basically, this\n    // just orients the camera to an isometric view that's easier on the eyes.\n    // // \"q *= r(a)\"works too, but apparently not all cards like it. Typical. :)\n    q = rot2(-atan(s.x/s.y/2.))*q; \n\n    \n    // The shadowed triangle grid, IDs, physical positions, etc.\n    float itriSh;\n    vec4 p4Sh = getTri(q - vec2(.12, -.12), itriSh);\n    vec2 pSh = p4Sh.xy; // Local coordinates.\n    vec2 ipSh = p4Sh.zw; // Triangle ID.\n    if(itriSh>0.) { vec2 tmp = v0Sh; v0Sh = v2Sh; v2Sh = tmp; }\n\n    vec2[3] vIDSh = vec2[3](v0Sh*itriSh, v1Sh*itriSh, v2Sh*itriSh);\n    vec2[3] vVSh = vec2[3](vIDSh[0]*s, vIDSh[1]*s, vIDSh[2]*s);\n    vec2[3] eIDSh = vec2[3](mix(vIDSh[0], vIDSh[1], .5), mix(vIDSh[1], vIDSh[2], .5), mix(vIDSh[2], vIDSh[0], .5));\n    \n    // The main triangle grid, IDs, physical positions, etc. All this is explained in my\n    // triangle jigsaw example on this site, if you feel like looking for it.\n    float itri;\n    vec4 p4 = getTri(q, itri);\n     // Making a copy of the triangle's local coordinates and ID. It's not particularly\n    // necessary, but saves a bit of extra writing and confusion.\n    vec2 p = p4.xy; // Local coordinates.\n    vec2 ip = p4.zw; // Triangle ID.\n    // Arranging for the vertices of complimentary triangle set to line up.\n    if(itri>0.) { vec2 tmp = v0; v0 = v2; v2 = tmp; }\n    \n    \n    // The unscaled triangle vertices, which double as an ID: Note that the vertices of\n    // alternate triangles are flipped in a such a way that edge neighboring edge vertices\n    // match up.\n    vec2[3] vID = vec2[3](v0*itri, v1*itri, v2*itri);\n    // Edge IDs, based on the vertex IDs above. The mid points of neighboring triangles\n    // occur in the same position, which means both triangles will generate the same\n    // unique random number at that position. This is handy for all kinds of things.\n    vec2[3] eID = vec2[3](mix(vID[0], vID[1], .5), mix(vID[1], vID[2], .5), mix(vID[2], vID[0], .5));\n    // Scaled vertices -- It's not absolutely necessary to have these, but when doing more\n    // complicated things, I like to switch between the unscaled IDs and the physically scaled\n    // vertices themselves.\n    vec2[3] vV = vec2[3](vID[0]*s, vID[1]*s, vID[2]*s);\n    // Scaled mid-edge vertices.\n    vec2[3] vE = vec2[3](eID[0]*s, eID[1]*s, eID[2]*s);\n\n\n    \n    const float cw = .45; // The cube face dimension. \".5\" would be the maximum.\n    const float lw = .175; // The connecting tube face dimension.\n    float spc = (cw - lw)/1.732; // The diagonal distance to center the tube.\n    const float ew = .01; // Edge width.\n    \n    const float thresh = .57; // Join threshold.\n    const float thresh2 = .57; // Threshold for cubes without holes.\n    \n    \n    \n    // Individual cube face and connecting tube face shades. These have been tailored\n    // to suit the example.\n    vec3 sh = vec3(1, .65, .25);\n    vec3 sh2 = vec3(.5, .15, 1.2);\n   \n    // Triangles can be tricky. Alternating triangles need the shades shifted around.\n    // I was feeling lazy, so I got these through trial and error. The top cube face\n    // needed to be lighter, and so forth.\n    if(itri<0.) { sh = sh.yxz; sh2 = sh2.zyx; }\n    \n    \n    // The scene color, initialized to a simple background gradient.\n    vec3 col = mix(vec3(.7, .85, 1)/1.25, vec3(1, .7, .4)*.8, -uv.y + .5);\n\n    #ifdef GLASS\n    // Darken the background for the glass setting. Yeah, it needs more effort. :)\n    col *= .75;\n    #endif    \n    \n    #ifdef NOISE_TEX\n    // The subtle noise texture.\n    float ns = fbm(oP*32.*max(iRes/450., 1.));\n    vec3 tx = mix(vec3(1, .8, .7), vec3(.05, .1, .15), ns);\n    tx = smoothstep(-.25, .55, tx);    \n    col *= tx;\n    #endif\n    \n    // Render connecting tube links and there shadows, or not.\n    vec3 drawLink = vec3(0);\n    vec3 drawLinkSh = vec3(0.);\n\n    \n    // An impossible geometric lattice with all the links in tact looks interesting,\n    // but I don't feel it looks as interesting as the one with random links. Rendering\n    // links randomly is simple enough (just compare the random shared edge value \n    // against a threshold), but you wind up with floating cubes. If you're OK with that,\n    // then the following isn't necessary. If it bothers you, like it did me, then you\n    // have to check for empty neighboring links, and either, omit the cube, or put a\n    // link in, which is what is happening here. By the way, using a Wang tile approach\n    // would be a more effective solution, but the following hack will do for now.\n  \n    for(int i = 0; i<3; i++){\n    \n        // Random number from the shared edge ID.\n        float rndI = hash21(ip + eID[i]);\n        // If it's below the threshold, flag the index of the link drawing vector.\n        if(rndI<thresh) drawLink[i]++;\n      \n        // Check for floating cubes:\n        //\n        // At the end of the final iteration, if no links have been rendered\n        // to the cube, add one in. I'm not happy with this logic, but it\n        // seems to work, so I'll leave it as is, for now.\n        if(i == 2){\n            int lCnt2 = 0;\n            if(hash21(ip + eID[(i + 0)%3])<thresh) lCnt2++;\n            if(hash21(ip + eID[(i + 2)%3])<thresh) lCnt2++;\n            if(hash21(ip + eID[(i + 0)%3]*2. + eID[(i + 2)%3])<thresh) lCnt2++;\n            if(hash21(ip + eID[(i + 2)%3]*2. + eID[(i + 4)%3])<thresh) lCnt2++;\n            if(lCnt2==0) drawLink[i]++;\n        }\n        \n        // Do the same with the shadow links. I'd hoped to use the variables above.\n        // Unfortunately, however, shadows need to be calculated seperately.\n        rndI = hash21(ipSh + eIDSh[i]);\n        if(rndI<thresh){\n            drawLinkSh[i]++;\n        }\n        \n        // Check for floating shadow cubes.\n        if(i == 2){\n            int lCnt2 = 0;\n            if(hash21(ipSh + eIDSh[(i + 0)%3])<thresh) lCnt2++;\n            if(hash21(ipSh + eIDSh[(i + 2)%3])<thresh) lCnt2++;\n            if(hash21(ipSh + eIDSh[(i + 0)%3]*2. + eIDSh[(i + 2)%3])<thresh) lCnt2++;\n            if(hash21(ipSh + eIDSh[(i + 2)%3]*2. + eIDSh[(i + 4)%3])<thresh) lCnt2++;\n           if(i==2 && lCnt2==0) drawLinkSh[i]++;\n        }\n\n    }\n   \n\n    // Render the shadows first. Something I get wrong all the time is trying to\n    // render the shadows layer upon layer. You have to take the overal minimum then\n    // render the entier shadow to the background... or on top of objects that are\n    // between the light and the background... And that's why I find it easier just\n    // to render things in 3D. :)\n    float dSh = 1e5;\n    for(int i = 0; i<3; i++){\n    \n        // Cube shadows. Just hexigons at each vertice. Quadrilateral cube faces\n        // would also work, but this does the same thing, and is easier.\n        dSh = min(dSh, sdHex(pSh - vVSh[i], cw));\n        \n        // If applicable, render the link shadow, which is just a box \n        // between vertices.\n        if(drawLinkSh[i]>.5){\n        \tdSh = min(dSh, lBox(pSh, vVSh[i], vVSh[(i + 1)%3], lw));\n        }\n     \t\n    }\n    \n\n    // Apply the background shadow.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dSh + .08))*.7);\n    \n    \n    // With the shadow done, it's time to render the boxes (with or without holes),\n    // and the connecting tubes.\n     \n    for(int i = 0; i<3; i++){\n\n        // Normal vectors. There are used to obtain the vertices of the\n        // quadrilateral cube faces.\n        vec2 n0 = normalize(vV[i] - vV[(i + 1)%3]);\n    \tvec2 n1 = normalize(vV[(i + 1)%3] - vV[(i + 2)%3]);\n    \tvec2 n2 = normalize(vV[(i + 2)%3] - vV[i]);\n\n        // Cube face distance field.\n        //\n        // Clockwise.\n        vec2 v0 = vV[i];\n\t\tvec2 v1 = v0 + n1*cw;\n\t\tvec2 v2 = v1 + n2*cw;\n\t\tvec2 v3 = v2 - n1*cw;\n        float d = quad(p, v0, v1, v2, v3);\n\n        \n        // Connecting tube distance field.\n        float side2 = length(vV[i] - vV[(i + 1)%3]);\n        v0 = vV[i] - n0*spc;\n\t\tv1 = v0 + n2*lw;\n\t\tv2 = v1 - n0*(side2 - spc - cw);\n\t\tv3 = v2 - n2*lw;\n        float d2 = quad(p, v0, v1, v2, v3);\n        \n        // The cube hole.\n        float dH = max(d2, d);\n        \n        \n        // Make a hole in the cube, or not. You could put holes on\n        // all cubes, if you wanted, but I thought this added a bit\n        // more visual interest.\n        float cbRnd = hash21(ip + vID[i] + .1);\n        if(drawLink[i]>.5 || cbRnd<thresh2) {\n            // Cube hole, on all link faces, and on\n            // random cubes as well.\n            v0 = vV[i] - n0*spc;\n\t\t\tv1 = v0 + n2*lw;\n\t\t\tv2 = v1 + n1*lw;\n\t\t\tv3 = v2 - n2*lw;\n            d = max(d, -quad(p, v0, v1, v2, v3));\n        }\n        \n        \n        \n        // The shading formula. Fake, of course. Basically, we're just manipulating the\n        // distance field itself, and hoping it looks kind of right. :) The more correct\n        // part of the lighting simply comes from giving the top cube face a light shade,\n        // the left a middle range shade, and the right a dark one.\n        float vSh = shade(p.xy - (vV[i] + s.yx*vec2(-1, 1)*.05), sh[i]);\n        \n        \n  \n        // Using the random vertex ID to give the cubes (which share a common triangle\n        // vertex) a random color.\n        float rnd = hash21((ip + vID[i])*s);\n        // Tweaking IQ's elegant underutilized one line palette formula to produce some subtle \n        // reddish earth tones. By the way, it's worth knowing the formula by heart, because it's\n        // so useful. In fact, if there's a cleverer more versatile formula than this, then I'm \n        // yet to see it. A close second would be the following: \n        // c = pow(vec3(a, b, c)*grey, vec3(d, e, f));\n        vec3 tCol = .5 + .45*cos(6.2831*mix(0., .3, rnd) + vec3(0, 1, 2)/1.5);\n        tCol = mix(vec3(1, .4, .25), tCol, .5);\n\n\n        #ifdef NOISE_TEX\n        tCol *= tx;\n        #endif\n\n        vec3 svCol = col;\n  \t\t\t\n        // If applicable, render an inner box.\n        if(drawLink[i]>.5 ||  cbRnd<thresh2){\n\n            float vSh2 = shade(p.xy - (vV[i] + s.yx*vec2(-1, 1)*.05), sh[(i + 2)%3]);\n            // Fake AO.\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., dH))*.5);\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf, dH)));\n        \tcol = mix(col, mix((tCol + vec3(.6, .8, 1)*.5)*vSh2*vSh2, svCol, .5), \n                      \t\t   (1. - smoothstep(0., sf, dH + ew)));\n           \n            // Shadow cast on object.\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., max(dSh + .08, dH)))*.35);\n         }   \n   \t\t\t\n        \n        // Boxes --  We're actually rendering a diamond quadrilateral cube face at \n        // each vertex, but when joined together on a triangle grid, it looks like a \n        // repetitive cubes.\n        //\n        // Fake AO, border, color and shading.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., d))*.5);\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, d)));\n   \t\tcol = mix(col, mix(tCol*vSh, svCol, 0.), (1. - smoothstep(0., sf, d + ew)));\n        // Shadow cast on the object -- The physics are nonsensical, but no one will check. :)\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., max(dSh + .08, d)))*.35);\n       \n        \n        // Connecting tube links.\n        \n        // Brightening up the left verticle tube link a bit. There's no science behind this --\n        // I just thought it looked a little better.\n        //if(itri>0.) vSh[0] *= 2.;\n        if(itri>0.) sh2[0] = mix(sh2[0], sh2[2], .55);\n        \n        if(drawLink[i]>.5){\n          \n            // The science behind the lighting here is pretty simple. Basically, I shifted\n            // the position around to various places until it looked like it might be scientifically\n            // correct... Then, when I didn't like how that looked, I moved it around until I\n            // thought it looked pretty. :D\n            //vSh = doShade(p.xy - mix(vE[(i + 1)%3], vV[i], .8), vSh);\n            vSh = shade2(p.xy - (mix(vE[(i + 1)%3], vV[i], .25) - s.yx*vec2(-1, 1)*.15), sh2[i]);\n            \n            vec3 lCol = vec3(.6, .8, 1);\n            #ifdef NOISE_TEX\n            // Add a little noise to the tubes.\n            lCol *= tx*.75 + .25;\n            #endif\n            \n            // The tubes are slightly transparent, to I've saved the background to mix\n            // with it. Normally, I wouldn't have to, but the dark edges are just a slightly\n            // larger black tube, with the colored tube over the top. I could use the \"abs\"\n            // trick, but sometimes, it doesn't quite work.\n            svCol = col;\n         \n            // Fake AO -- Technically, this encroaches a little onto the sides of the\n            // cube, but it's barely noticeable... to most, but there's always one :D\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., d2 + ew))*.5); \n            // Edges.\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf, d2)));\n            #ifdef GLASS\n            // Glowing glass tubes.\n   \t\t\tcol = mix(col, mix(lCol*vSh, svCol, .9)*vec3(1.5, 2.3, 3.4), \n                     (1. - smoothstep(0., sf, d2 + ew)));\n            #else\n            // Transparent... hard plastic tubes? Either way, they'll do.\n   \t\t\tcol = mix(col, mix(lCol*vSh, svCol, .5), (1. - smoothstep(0., sf, d2 + ew)));\n            #endif\n          \n            // Shadow object cast. Again, not realistic, but I doubt anyone will care. :)\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., max(dSh + .08, d2)))*.35);\n            \n \n        }\n \n    }\n    \n\n    return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n\n    // Restricting the fullscreen resolution.\n    float iRes = min(iResolution.y, 800.);\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iRes;\n    \n    \n    // Scaling and translation.\n    float gSc = 4.5;\n    // Depending on perspective; Moving the scene toward the bottom left, \n    // or the camera in the north east (top right) direction. \n    //\n    // Warped version.\n    //vec2 p = uv*(.95 + length(uv*vec2(iResolution.y/iResolution.x, 1))*.05)*gSc - vec2(-1, -.5)*iTime;\n    vec2 p = (uv*gSc - vec2(-.6, -.3)*iTime);\n    \n    // A nonwarped copy, for postprocessing purposes.\n    vec2 oP = uv*gSc - vec2(-.6, -.3)*iTime;\n    \n    \n    // The smoothing factor.\n    float sf = gSc/iRes;\n    \n    \n    // The isosceles grid lattice object.\n    vec3 col = triLattice(p, sf, uv, iRes);\n    //vec3 col = triLattice(rot2(-3.14159/6.)*p, sf, uv, iRes);\n     \n\n    #ifdef DO_HATCH\n    // A cheap hatch-like pattern, just to give it that extra oldschool look.\n    float hatch = doHatch(oP/gSc, iRes);\n    col *= hatch*.45 + .75;\n    #endif\n  \n    \n    // Spotlight color mixing.\n    //col = mix(col, col.xzy, pow(dot(uv, uv), 1.5)*.35);\n \n  \n    \n    // Applying a subtle silhouette, for art's sake.\n\tuv = fragCoord/iResolution.xy;\n    col *= pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./16.)*1.05; \n    \n    // Rough gamma correction, then output to the screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}