{
    "Shader": {
        "info": {
            "date": "1366977990",
            "description": "My attempt at a demo like sequence in a shader.\nThe code is a bit messy. I was just having fun.\nThe framerate is low. I may try to optimize some bits and pieces.\n\n(you may need to pause and restart the audio track for the shader to work)",
            "flags": 1,
            "hasliked": 0,
            "id": "XsX3Dr",
            "likes": 83,
            "name": "Palindrome",
            "published": 3,
            "tags": [
                "demo",
                "shader"
            ],
            "usePreview": 0,
            "username": "P_Malin",
            "viewed": 7520
        },
        "renderpass": [
            {
                "code": "#define kRaymarchMaxIter 96\n\n//#define LOW_QUALITY\n\n//#define OVERRIDE_TIME\n\nconst vec3 cSkyColourTop = vec3(0.2, 0.05, 0.15) * 0.5;\nconst vec3 cSkyColourHorizon = vec3(0.4, 0.1, 0.01) * 2.0;\nconst vec3 cSunScatteringColour = vec3(1.0, 0.01, 0.005) * 1.0;\n\nconst vec3 cFogColour = vec3(0.4, 0.05, 0.01) * 2.0;\n\nconst vec3 cSunColour = vec3(1.0, 0.01, 0.005) * 5.0;\nvec3 vSunDirection = normalize(vec3(-0.3, 0.2, -0.7));\n\nconst vec3 cSunLightColour = vec3(1.0, 0.15, 0.025) * 1.0;\nconst vec3 cAmbientLight = vec3(0.4, 0.1, 0.01) * 0.2;\n\nconst vec3 vPortalPos = vec3(0.0, 2.7, 20.0);\n\nconst float fSequenceLength = 18.0;\n\nmat3 g_mPortalRotation;\nfloat g_fTime = 0.0;\nfloat g_fSceneTime = 0.0;\nfloat g_ReverseEffectEnabled= 0.0;\n\nstruct C_Ray\n{\n    vec3 vOrigin;\n    vec3 vDir;\n    float fStartDistance;\n    float fLength;\n};\n\nstruct C_HitInfo\n{\n    vec3 vPos;\n    float fDistance;\n    float fObjectId;\n};\n    \nstruct C_Surface\n{\n    vec3 vNormal; \n};\n\nstruct C_Material\n{\n    vec3 cAlbedo;\n};\n\t\n/////////////////////////////////////\n// Distance Field CSG\n// These carry with them the material parameters in y\n\nvec2 DistCombineUnion( const in vec2 v1, const in vec2 v2 )\n{\n    //if(v1.x < v2.x) return v1; else return v2;\n    return mix(v1, v2, step(v2.x, v1.x));\n}\n\n/////////////////////////////////////\n// Scene Description \n\nfloat GetRayFirstStep( const in C_Ray ray )\n{\n\treturn ray.fStartDistance;\n}\n\nfloat hash( const in float n ) {\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat smoothnoise(const in float o) \n{\n\tfloat p = floor(o);\n\tfloat f = fract(o);\n\t\t\n\tfloat n = p;\n\n\tfloat a = hash(n+  0.0);\n\tfloat b = hash(n+  1.0);\n\t\n\tfloat f2 = f * f;\n\tfloat f3 = f2 * f;\n\t\n\tfloat t = 3.0 * f2 - 2.0 * f3;\n\t\n\treturn mix(a, b, t);\n}\n\nfloat smoothnoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = hash(n+  0.0);\n\tfloat b = hash(n+  1.0);\n\tfloat c = hash(n+ 57.0);\n\tfloat d = hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\tvec2 dt = 6.0 * f - 6.0 * f2;\n\t\n\tfloat u = t.x;\n\tfloat du = dt.x;\t\n\tfloat v = t.y;\n\tfloat dv = dt.y;\t\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n\t\n\t//float dx = (b-a)*du + (a-b+d-c)*du*v;\n\t//float dy = (c-a)*dv + (a-b+d-c)*u*dv;\n\t\n\treturn res;\n}\n\nfloat smoothnoise(const in vec3 o) \n{\n\tvec3 p = floor(o);\n\tvec3 fr = fract(o);\n\t\t\n\tfloat n = p.x + p.y*101.0 + p.z * 4001.0;\n\n\tfloat a = hash(n+   0.0);\n\tfloat b = hash(n+   1.0);\n\tfloat c = hash(n+ 101.0);\n\tfloat d = hash(n+ 102.0);\n\tfloat e = hash(n+4001.0);\n\tfloat f = hash(n+4002.0);\n\tfloat g = hash(n+4102.0);\n\tfloat h = hash(n+4103.0);\n\t\n\tvec3 fr2 = fr * fr;\n\tvec3 fr3 = fr2 * fr;\n\t\n\tvec3 t = 3.0 * fr2 - 2.0 * fr3;\n\t\t\n\treturn mix(\n\t\t\t    mix( mix(a,b, t.x),\n\t\t             mix(c,d, t.x), t.y),\n\t\t\t    mix( mix(e,f, t.x),\n\t\t             mix(g,h, t.x), t.y),\n\t\t\tt.z);\n}\n\nfloat GetDistanceGround( const in vec3 vPos )\n{\n\tfloat fResult = vPos.y;\n\t\n\tfloat h = smoothnoise(vPos.xz * 0.1);\t\t\n\tfloat fRidgePos = vPos.x + h * 10.0;\n\t\n\tfloat s = sin(fRidgePos);\n\ts *= sin(vPos.z * 0.1 + vPos.x * 0.2);\n\ts = s * 0.5 + 0.5;\t\n\ts = sqrt(s);\n\t\n\tvec2 vFlattenPos = abs(vPos.xz);\n\tfloat fFlattenDist = max(vFlattenPos.x, vFlattenPos.y);\n\tfloat fFlatten = smoothstep(50.0, 65.0, fFlattenDist);\n\tfResult += mix(0.0, s, fFlatten);\n\n\t#ifndef LOW_QUALITY\n\tfloat s2= sin(fRidgePos * 40.0);\n\ts2 = s2 * 0.5 + 0.5;\t\n\tfResult += s2 * s * 0.01;\n\t#endif\n\n\treturn fResult;\n}\n\nvec2 GetDistancePyramid(const in vec3 vPos, const in float fWorldNoise)\n{\n\tvec2 vResult;\n\tvResult.y = 2.0; // object id\n\n\tfloat fPyramidSize = 50.0;\n\t\n\tvec3 vStepPos = vPos;\n\tvStepPos.y -= fPyramidSize;\n\tvStepPos.xz = abs(vStepPos.xz) - 0.5;\n\tvec2 vStepOffset = floor((vStepPos.y - vStepPos.xz) * 0.5 + 0.5);\n\tfloat fStepOffset = min(vStepOffset.x, vStepOffset.y);\n\t\n\tvStepPos.x += fStepOffset;\t\n\tvStepPos.y -= fStepOffset;\n\tvStepPos.z += fStepOffset;\n\n\tvec3 vClosest = min(vStepPos.xyz, vec3(0.0));\t\n\t\n\tvResult.x = length(vStepPos - vClosest);\t\n\t\n\tfloat fFlatSide = (vPos.y + max(abs(vPos.x), abs(vPos.z))) - 50.0;\n\tvResult.x = mix(vResult.x, fFlatSide, 0.3);\n\t\t\n\tconst float fTunnelHeight = 4.0;\n\tconst float fTunnelWidth = 1.0;\n\tfloat fTunnelInner = min(min(fTunnelWidth - abs(vPos.x), fTunnelHeight - vPos.y), 35.0-vPos.z);\n\n\tconst float fTunnelThickness = 1.5;\n\tconst float fTunnelExtent = 2.0;\n\tfloat fTunnelOuter = max(abs(vPos.x) - (fTunnelWidth + fTunnelThickness), vPos.y - (fTunnelHeight + fTunnelThickness));\n\tfTunnelOuter = max(fTunnelOuter, vPos.y + abs(vPos.z + fTunnelExtent) - (fPyramidSize));\n\t\n\tvResult.x = min(vResult.x, fTunnelOuter);\n\tvResult.x = max(vResult.x, fTunnelInner);\n\t\n\tfloat fRoomWallDist = (vPos.y + max(abs(vPos.x), abs(vPos.z - 20.0)));\n\tfloat fInnerRoom = 20.0 - fRoomWallDist;\n\tvResult.x = max(vResult.x, fInnerRoom);\n\t\n\tvResult.x -= 0.1 - clamp(fWorldNoise, 0.0, 1.0) * 0.1;\t\n\t\n\treturn vResult;\n}\n\nvec2 GetDistancePyramids( const in vec3 vPos )\n{\n\t#ifdef LOW_QUALITY\n\tfloat fWorldNoise = 0.0;\n\t#else\n\tfloat fWorldNoise = smoothnoise(vPos * 2.0);\n\t#endif\n\t\t\n\tfloat fHeight = 0.0;\n\tvec3 vPyramidPos = vPos;\n\tif(vPyramidPos.x > 50.0)\n\t{\n\t\tvPyramidPos.x -= 100.0;\n\t\tvPyramidPos.z += 100.0;\n\t\tfHeight = 10.0;\n\t}\n\n\tif(vPyramidPos.x < -70.0)\n\t{\n\t\tvPyramidPos.x += 100.0;\n\t\tvPyramidPos.z += 200.0;\n\t\tfHeight = 20.0;\n\t}\n\t\n\tvPyramidPos.y = max(vPyramidPos.y + fHeight, fHeight);\n\t\n\tvec2 vPyramidDistance = GetDistancePyramid( vPyramidPos, fWorldNoise );\t\n\t\n\treturn vPyramidDistance;\n}\n\n// result is x=scene distance y=material or object id; zw are material specific parameters (maybe uv co-ordinates)\nvec2 GetDistanceScene( const in vec3 vPos, const in float fShadow )\n{          \n    vec2 vResult = vec2(10000.0, -1.0);\n    \n\tfloat fScale = 1.0;\n\tvec3 vPyramidPos = vPos;\n\tvec3 vSmallPyramidPos = vPyramidPos - vec3(0.0, 0.0, 20.0);\n\tvec3 vAbsPos = abs(vSmallPyramidPos);\t\n\tif( max(vAbsPos.x, vAbsPos.z) + vSmallPyramidPos.y < 15.0 )\n\t{\n\t\tvSmallPyramidPos.y -= 0.5;\n\t\tfScale = 30.0;\n\t\tvPyramidPos = vSmallPyramidPos * fScale;\n\t}\t\n\t\n\tvec2 vPyramidDistance = GetDistancePyramids( vPyramidPos );\t\n\tvPyramidDistance.x /= fScale;\n\t\n\tfloat fRoomWallDist = (vPos.y + max(abs(vPos.x), abs(vPos.z - 17.0)));\n\tfloat fPedistalDist = max(fRoomWallDist - 7.0, vPos.y - 0.5);\n\tvPyramidDistance.x = min(vPyramidDistance.x, fPedistalDist);\n\t\n\tvec2 vFloorDistance = vec2(GetDistanceGround( vPos ), 1.0);\n\tvResult = vFloorDistance;\n\n\tvResult = DistCombineUnion(vResult, vPyramidDistance);\n\t\n\tif(fShadow > 0.5)\n\t{\n\t\tvec2 vPortalDistance = vec2( (length(vPos - vPortalPos) - 0.1), 3.0);\n\t\tvResult = DistCombineUnion(vResult, vPortalDistance);\n\t}\n\t\n    return vResult;\n}\n\nC_Material GetObjectMaterial( const in C_HitInfo hitInfo )\n{\n    C_Material mat;  \n        \n\tmat.cAlbedo = vec3(0.8, 0.5, 0.3);\n\t\n\tif(hitInfo.fObjectId > 1.0)\n\t{\n    \tmat.cAlbedo = vec3(1.0, 0.8, 0.5);\n\t}\n\telse if(hitInfo.fObjectId > 2.0)\n\t{\n\t\tmat.cAlbedo = vec3(1.0, 1.0, 1.0);\n\t}\n\n    return mat;\n}\n\nvec3 GetSkyColour( const in vec3 vDir )\n{\n\n    float fBlend = clamp(vDir.y, 0.0, 1.0);\n\tfBlend = 1.0 - fBlend;\n\t\n\t\n    vec3 vResult =  mix(cSkyColourHorizon, cSkyColourTop, 1.0 - fBlend * fBlend * fBlend);\n\t\t\n\tfloat fSunDot = max(dot(vDir, vSunDirection), 0.0);\n\tvResult += (pow(fSunDot, 500.0) + fSunDot * fSunDot) * cSunScatteringColour;\n\t\n\tfloat fSun = clamp(5000.0 * (fSunDot - 0.999), 0.0, 1.0);\t\n\tvResult = vResult + cSunColour * fSun;\n\t\n\treturn vResult;\n}\n\n////////////////////////////////\n// Raymarching \n\nvec3 GetSceneNormal( const in vec3 vPos )\n{\n    // tetrahedron normal\n    const float fDelta = 0.025;\n\n    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);\n    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);\n    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);\n    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);\n\n    float f1 = GetDistanceScene( vPos + vOffset1, 1.0 ).x;\n    float f2 = GetDistanceScene( vPos + vOffset2, 1.0 ).x;\n    float f3 = GetDistanceScene( vPos + vOffset3, 1.0 ).x;\n    float f4 = GetDistanceScene( vPos + vOffset4, 1.0 ).x;\n\n    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;\n\n    return normalize( vNormal );\n}\n\n#define kRaymarchEpsilon 0.001\n\n// This is an excellent resource on ray marching -> https://iquilezles.org/articles/distfunctions\nvoid Raymarch( const in C_Ray ray, out C_HitInfo result, const int maxIter, const in float fShadow )\n{        \n    result.fDistance = GetRayFirstStep( ray );\n    result.fObjectId = 0.0;\n        \n    for(int i=0;i<=kRaymarchMaxIter;i++)              \n    {\n        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n        vec2 vSceneDist = GetDistanceScene( result.vPos, fShadow );\n        result.fObjectId = vSceneDist.y;\n        \n        // abs allows backward stepping - should only be necessary for non uniform distance functions\n        if((abs(vSceneDist.x) <= kRaymarchEpsilon) || (result.fDistance >= ray.fLength) || (i > maxIter))\n        {\n            break;\n        }                        \n\n        result.fDistance = result.fDistance + vSceneDist.x; \n    }\n\n\n    if(result.fDistance >= ray.fLength)\n    {\n        result.fDistance = 1000.0;\n        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n        result.fObjectId = 0.0;\n    }\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<8; aoi++ )\n    {\n        float hr = 0.01 + 1.2*pow(float(aoi)/8.0,1.5);\n        vec3 aopos =  nor * hr + pos;\n        float dd = GetDistanceScene( aopos, 0.0 ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.85;\n    }\n    return clamp( 1.0 - 1.0*totao, 0.0, 1.0 );\n}\n\nvec3 ShadeSurface(const in C_Ray ray, const in C_HitInfo hitInfo, const in C_Surface surface, const in C_Material material, float fInsideDist)\n{\n    vec3 cScene;\n    \n    vec3 vAmbientLight;\n\t\t\t\n\tvec3 vDiffuseLight = vec3(0.0);\n\n\tvec3 vToLight;\n\tvec3 cLightColour;\n\t\n\tfloat fPortalOn = smoothstep(9.0, 9.5, g_fTime);\n\t\n\tif(fInsideDist > 0.0)\n\t{\n\t\tvToLight = vSunDirection * 100.0;\n\t\tcLightColour = cSunLightColour;\n\t\tvAmbientLight = cAmbientLight;\n\t}\n\telse\n\t{\n\t\tvec3 vLightPos;\t\t\n\t\t\n\t\t// apply point light\n\t\t{\n\t\t\t\n\t\t\tif((hitInfo.vPos.z - hitInfo.vPos.y) < 0.01)\n\t\t\t{\n\t\t\t\tfloat fLightId = floor(min(max(hitInfo.vPos.z, -50.0), 0.0) * 0.1 + 0.5);\n\t\t\t\tvLightPos = vec3(0.5 * sign(hitInfo.vPos.x), 2.5, 10.0 * fLightId - 0.5);\t\t\n\t\t\t\t\n\t\t\t\tfloat fFlicker = (smoothnoise(fLightId + iTime * 500.0) * 0.5 + 0.5);\n\t\t\t\tcLightColour = vec3(1.0, 0.5, 0.1) * fFlicker * 0.01;\n\t\t\t\tvAmbientLight = cAmbientLight * 0.01;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvLightPos = vPortalPos;\n\t\t\t\tvec3 vToLight = vLightPos - hitInfo.vPos;\n\t\t\t\t\n\t\t\t\tcLightColour = textureLod(iChannel0, vToLight * g_mPortalRotation, 0.0).rgb;\n\t\t\t\tcLightColour = cLightColour * cLightColour * 10.0 * vec3(0.0, 1.0, 0.0);\n\n\t\t\t\tfloat fFft = smoothstep(0.7, 0.9, textureLod(iChannel3, vec2(0.018, 0.0), 0.0).r);\n\t\t\t\tfFft = fFft * fFft;\n\t\t\t\tcLightColour = vec3(1.0, 0.2, 0.1) * fFft + cLightColour * fPortalOn;\n\t\t\t\tvAmbientLight = vec3(1.0, 0.2, 0.1) * 0.001;\t\t\t\t\t\t\t\t\n\t\t\t}\t\t\t\t\t\n\t\t}\n\t\t\n\t\tvToLight = vLightPos - hitInfo.vPos;\n\t\tfloat fDist2 = dot(vToLight, vToLight);\n\t\tcLightColour /= fDist2;\n\t}\n\n\tC_Ray shadowRay;\n\tshadowRay.vOrigin = hitInfo.vPos;\n\tshadowRay.fLength = length(vToLight);\n\tshadowRay.vDir = normalize(vToLight);\n\tshadowRay.fStartDistance = dot(shadowRay.vDir, surface.vNormal);\n\tC_HitInfo shadowHitInfo;\n\tRaymarch(shadowRay, shadowHitInfo, 64, 0.0);\n\t\n\tfloat fShadow = 1.0;\n\tif(shadowHitInfo.fDistance < 90.0)\n\t{\n\t\tfShadow = 0.0;\n\t}\n\t\n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDiffuseLight = clamp(dot(surface.vNormal, vLightDir), 0.0, 1.0) * fShadow;\n\t\n\tvDiffuseLight += fDiffuseLight * cLightColour;\n\t\n\tfloat fAmbientOcclusion = calcAO(hitInfo.vPos, surface.vNormal);\n\t\n    vDiffuseLight += vAmbientLight * fAmbientOcclusion;\n              \n    vec3 vDiffuseReflection = vDiffuseLight * material.cAlbedo;              \n\n    cScene = vDiffuseReflection;\n    \n    return cScene;\n}\n\nvec3 GetSceneColour( const in C_Ray ray )\n{                                                          \n    C_HitInfo intersection;\n    Raymarch(ray, intersection, 256, 1.0);\n                \n    vec3 cScene;\n\n    if(intersection.fObjectId < 0.5)\n    {\n\t\tcScene = GetSkyColour(ray.vDir);\n    }\n    else\n    {\n        C_Surface surface;\n        \n        surface.vNormal = GetSceneNormal(intersection.vPos);\n\n\t\tif(intersection.fObjectId > 2.5)\n\t\t{\n\t\t\t// flip portal light source surface\n\t\t\tsurface.vNormal = -surface.vNormal;\n\t\t}\n\n        C_Material material = GetObjectMaterial(intersection);\n\n\t\tvec3 vAbsPos = abs(intersection.vPos);\n\t\tfloat fInsideDist = (max(vAbsPos.x, vAbsPos.z) + vAbsPos.y) - 46.0;\n\n        // apply lighting\n        cScene = ShadeSurface(ray, intersection, surface, material, fInsideDist);\t\t\t\t\t\n\t\t\n\t\tif( fInsideDist > 0.0 )\n\t\t{\n\t\t\t// apply fog\t\n\t\t\tfloat fNoise = smoothnoise((intersection.vPos.xz) * 0.1 + g_fSceneTime * 10.0);\n\t\t\tfloat fDensity= 0.04;\n\t\t\tfloat fHeightFalloff = 0.5;\n\t\t\t\n\t\t\tfloat fogAmount = fDensity * exp(-ray.vOrigin.y*fHeightFalloff) * (1.0-exp(-intersection.fDistance*ray.vDir.y*fHeightFalloff ))/ray.vDir.y;\n\t\t\tfogAmount *= (0.5 + fNoise * 0.5);\n\t\t\tcScene = mix(cScene, cFogColour, fogAmount);\n\t\t}\n    }\n\t\n    return cScene;\n}\n\nfloat kFarClip = 1000.0;\n\nvoid GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, in vec2 fragCoord, out C_Ray ray)\n{\n    vec2 vUV = ( fragCoord.xy / iResolution.xy );\n    vec2 vViewCoord = vUV * 2.0 - 1.0;\n\t\n    float fRatio = iResolution.x / iResolution.y;\n    vViewCoord.y /= fRatio;                          \n\n\tvViewCoord *= 0.75;\n\t\n    ray.vOrigin = vPos;\n\t\n    vec3 vRight = normalize(cross(vForwards, vWorldUp));\n    vec3 vUp = cross(vRight, vForwards);\n        \n    ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards); \n    ray.fStartDistance = 0.0;\n    ray.fLength = kFarClip;      \n}\n\nvoid GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, in vec2 fragCoord, out C_Ray ray)\n{\n    vec3 vForwards = normalize(vInterest - vPos);\n    vec3 vUp = vec3(0.0, 1.0, 0.0);\n\n    GetCameraRay(vPos, vForwards, vUp, fragCoord, ray);\t\n}\n\n\nvoid GetCameraPosAndTarget( float fCameraIndex, out vec3 vCameraPos, out vec3 vCameraTarget )\n{\n\tfloat fCameraCount = 14.0;\n\tfloat fCameraIndexModCount = max(min(fCameraIndex, fCameraCount), 0.0);\n\n\tif(fCameraIndexModCount < 0.5)\n\t{\n\t\tvCameraPos = vec3(2000.0, 3.0, 500.0);\n\t\tvCameraTarget = vCameraPos + vec3(-10.0, -3.0, -10.0);\n\t}\n\telse if(fCameraIndexModCount < 1.5)\n\t{\n\t\tvCameraPos = vec3(2000.0, 4.0, 500.0);\n\t\tvCameraTarget = vCameraPos + vec3(-10.0, -3.0, -10.0);\n\t}\n\telse if(fCameraIndexModCount < 2.5)\n\t{\n\t\tvCameraPos = vec3(2000.0, 3.0, 500.0);\n\t\tvCameraTarget = vCameraPos + vec3(15.0, -4.0, -10.0);\n\t}\n\telse if(fCameraIndexModCount < 3.5)\n\t{\n\t\tvCameraPos = vec3(2000.0, 20.0, 500.0);\n\t\tvCameraTarget = vCameraPos + vec3(15.0, -8.0, -10.0);\n\t}\n\telse if(fCameraIndexModCount < 4.5)\n\t{\n\t\tvCameraPos = vec3(500.0, 20.0, 500.0);\n\t\tvCameraTarget = vCameraPos + vec3(15.0, -3.0, -10.0);\n\t}\n\telse if(fCameraIndexModCount < 5.5)\n\t{\n\t\tvCameraPos = vec3(500.0, 3.0, 500.0) + vec3(100.0, 0.0, 0.0);\n\t\tvCameraTarget = vCameraPos + vec3(10.0, -3.0, -10.0);\n\t}\n\telse if(fCameraIndexModCount < 6.5)\n\t{\n\t\tvCameraPos = vec3(500.0, 5.0, 500.0) + vec3(100.0, 0.0, 0.0);\n\t\tvCameraTarget = vec3(0.0, 10.0, 0.0);\n\t}\n\telse if(fCameraIndexModCount < 7.5)\n\t{\n\t\tvCameraPos = vec3(-30.0, 20.0, -200.0);\n\t\tvCameraTarget = vec3(0.0, 10.0, 0.0);\n\t}\n\telse if(fCameraIndexModCount < 8.5)\n\t{\n\t\tvCameraPos = vec3(0.0, 5.0, -100.0);\n\t\tvCameraTarget = vec3(0.0, 0.0, 0.0);\n\t}\n\telse if(fCameraIndexModCount < 9.5)\n\t{\n\t\tvCameraPos = vec3(0.0, 1.0, 5.0);\n\t\tvCameraTarget = vec3(0.0, 1.0, 20.0);\n\t}\n\telse if(fCameraIndexModCount < 10.5)\n\t{\n\t\tvCameraPos = vec3(0.0, 2.0, 5.0);\n\t\tvCameraTarget = vec3(0.0, 1.0, 20.0);\n\t}\n\telse if(fCameraIndexModCount < 11.5)\n\t{\n\t\tvCameraPos = vec3(10.0, 5.0, 30.0);\n\t\tvCameraTarget = vec3(0.0, 1.0, 20.0);\n\t}\n\telse if(fCameraIndexModCount < 12.5)\n\t{\n\t\tvCameraPos = vec3(10.0, 6.0, 30.0);\n\t\tvCameraTarget = vec3(0.0, 1.0, 20.0);\n\t}\n\telse if(fCameraIndexModCount < 13.5)\n\t{\n\t\tvCameraPos = vec3(0.0, 6.0, 20.0);\n\t\tvCameraTarget = vec3(0.0, -1.0, 19.0);\n\t}\n\telse\n\t{\n\t\tvCameraPos = vec3(0.0, 2.0, 20.0);\n\t\tvCameraTarget = vec3(0.0, -10.0, 19.0);\n\t}\n}\n\nvec3 BSpline( const in vec3 a, const in vec3 b, const in vec3 c, const in vec3 d, const in float t)\n{\n\tconst mat4 mSplineBasis = mat4( -1.0,  3.0, -3.0, 1.0,\n\t\t\t\t\t\t\t         3.0, -6.0,  0.0, 4.0,\n\t\t\t\t\t\t\t        -3.0,  3.0,  3.0, 1.0,\n\t\t\t\t\t\t\t         1.0,  0.0,  0.0, 0.0) / 6.0;\t\n\t\n\tfloat t2 = t * t;\n\tvec4 T = vec4(t2 * t, t2, t, 1.0);\n\t\t\n\tvec4 vWeights = T * mSplineBasis;\n\t\n\tvec3 vResult;\n\n\tvec4 vCoeffsX = vec4(a.x, b.x, c.x, d.x);\n\tvec4 vCoeffsY = vec4(a.y, b.y, c.y, d.y);\n\tvec4 vCoeffsZ = vec4(a.z, b.z, c.z, d.z);\n\t\n\tvResult.x = dot(vWeights, vCoeffsX);\n\tvResult.y = dot(vWeights, vCoeffsY);\n\tvResult.z = dot(vWeights, vCoeffsZ);\n\t\n\treturn vResult;\n}\n\nvoid GetCamera(out vec3 vCameraPos, out vec3 vCameraTarget)\n{\n\tfloat fCameraGlobalTime = g_fSceneTime;\t\t\n\t\n\tfloat fCameraTime = fract(fCameraGlobalTime);\n\tfloat fCameraIndex = floor(fCameraGlobalTime);\n\t\n\tvec3 vCameraPosA;\n\tvec3 vCameraTargetA;\n\tGetCameraPosAndTarget(fCameraIndex, vCameraPosA, vCameraTargetA);\n\t\n\tvec3 vCameraPosB;\n\tvec3 vCameraTargetB;\n\tGetCameraPosAndTarget(fCameraIndex + 1.0, vCameraPosB, vCameraTargetB);\n\t\n\tvec3 vCameraPosC;\n\tvec3 vCameraTargetC;\n\tGetCameraPosAndTarget(fCameraIndex + 2.0, vCameraPosC, vCameraTargetC);\n\t\n\tvec3 vCameraPosD;\n\tvec3 vCameraTargetD;\n\tGetCameraPosAndTarget(fCameraIndex + 3.0, vCameraPosD, vCameraTargetD);\n\t\n\tvCameraPos = BSpline(vCameraPosA, vCameraPosB, vCameraPosC, vCameraPosD, fCameraTime);\n\tvCameraTarget = BSpline(vCameraTargetA, vCameraTargetB, vCameraTargetC, vCameraTargetD, fCameraTime);\n}\n\n\nvec3 Tonemap( const in vec3 cCol )\n{\n    return sqrt(1.0 - exp(-cCol));\n}\n\nfloat GetTime()\n{\n\tfloat fTime = iTime;\n    if ( iChannelTime[3] > 0.0 )\n    {\n        fTime = iChannelTime[3];\n    }\n    fTime = fTime / 8.0;\n\t#ifdef OVERRIDE_TIME\n\tfTime = iMouse.x * fSequenceLength / iResolution.x;\n\t#endif\n\t\n\t// hack the preview image\n\tif(iTime == 10.0)\n\t{\n\t\tfTime = 30.0 / 8.0;\n\t}\n\t\n\treturn mod(fTime, fSequenceLength);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\n\tg_fTime = GetTime();\n\n\t// (noisy) motion blur by dithering time per pixel!\n\n    // Switched to Blue Noise 2020/10/26\n    g_fTime += (texelFetch(iChannel2, ivec2(fragCoord.xy) % 1024, 0).r - 0.5) * 0.005;\t\n    \n    // old version\n    //g_fTime += (texture(iChannel1, (fragCoord.xy / 64.0) + 0.5).r - 0.5) * 0.005;\t\n\t\n\tfloat fTimeWarp = 0.0;\n\t\n\tg_ReverseEffectEnabled = smoothstep(13.0, 14.0, g_fTime);\n\t\n\t// During the reverse sequence time is further backward at the edge of the screen\n\tg_fSceneTime = g_fTime;\n\tif(g_fSceneTime > 13.0)\n\t{\n\t\tfloat t = (g_fSceneTime - 13.0);\n\t\t\n\t\tfloat l = length(vUV);\n\t\tfTimeWarp = l * l * g_ReverseEffectEnabled;\n\t\tt += fTimeWarp * 0.2;\n\t\t\n\t\tg_fSceneTime = 13.0 - t * t;\n\n\t}\t\n\n\tg_fSceneTime = max(g_fSceneTime, 0.0);\n\t\n\tfloat a = (g_fSceneTime - 8.0);\n\ta = a * a * a;\n\tg_mPortalRotation = mat3(sin(a), 0.0, cos(a), \n\t\t\t\t\t  0.0, 1.0, 0.0,\n\t\t\t\t\t  cos(a), 0.0, -sin(a));\n \n    vec3 vCameraPos;\n    vec3 vCameraInterest;\n\tGetCamera(vCameraPos, vCameraInterest);\n\t\n\tC_Ray ray;\n    GetCameraRayLookat( vCameraPos, vCameraInterest, fragCoord, ray);\n\n    vec3 cScene = GetSceneColour( ray );  \n    \n\tfloat fExposure = 1.5;    \n\t\n\tfExposure = mix(fExposure, 0.3, smoothstep(3.45, 3.6, g_fTime));\n\tfExposure = mix(fExposure, 1.0, smoothstep(5.35, 5.5, g_fTime));\n\tfExposure = mix(fExposure, 20.0, smoothstep(7.6, 7.8, g_fTime));\n\n\tfExposure = mix(fExposure, 1.5, smoothstep(15.0, 17.0, g_fTime));\n\t\n\t// vignette\n\tfloat fDist = dot(vUV, vUV);\n\tfDist = fDist * fDist;\n\tfloat fAmount = 1.0 / (fDist + 1.0);\n\tcScene = cScene * fAmount;\n\t\n\tvec3 cColour = Tonemap(cScene * fExposure);\n\n    fragColor = vec4(cColour, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tvec2 vUV = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\n\tg_fTime = GetTime();\n\n\t// (noisy) motion blur by dithering time per pixel!    \n    //g_fTime += (texture(iChannel1, (fragCoord.xy / 64.0) + 0.5).r - 0.5) * 0.005;\t// (Removed from VR version)\n\n\tfloat fTimeWarp = 0.0;\n\t\n\tg_ReverseEffectEnabled = smoothstep(13.0, 14.0, g_fTime);\n\t\n\t// During the reverse sequence time is further backward at the edge of the screen\n\tg_fSceneTime = g_fTime;\n\tif(g_fSceneTime > 13.0)\n\t{\n\t\tfloat t = (g_fSceneTime - 13.0);\n\t\t\n\t\tfloat l = length(vUV);\n\t\tfTimeWarp = l * l * g_ReverseEffectEnabled;\n\t\tt += fTimeWarp * 0.2;\n\t\t\n\t\tg_fSceneTime = 13.0 - t * t;\n\n\t}\t\n\n\tg_fSceneTime = max(g_fSceneTime, 0.0);\n\t\n\tfloat a = (g_fSceneTime - 8.0);\n\ta = a * a * a;\n\tg_mPortalRotation = mat3(sin(a), 0.0, cos(a), \n\t\t\t\t\t  0.0, 1.0, 0.0,\n\t\t\t\t\t  cos(a), 0.0, -sin(a));\n \n    vec3 vCameraPos;\n    vec3 vCameraInterest;\n\tGetCamera(vCameraPos, vCameraInterest);\n\t\n    fragRayOri += vCameraPos;\n    \n\tC_Ray ray;\n    ray.vOrigin = fragRayOri;\n    ray.vDir = fragRayDir;\n    ray.fStartDistance = 0.0;\n    ray.fLength = kFarClip;\n    //GetCameraRayLookat( vCameraPos, vCameraInterest, fragCoord, ray);\n\n    vec3 cScene = GetSceneColour( ray );  \n    \n\tfloat fExposure = 1.5;    \n\t\n\tvec3 cColour = Tonemap(cScene * fExposure);\n\n    fragColor = vec4(cColour, 1.0 );    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "music",
                        "id": 21,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}