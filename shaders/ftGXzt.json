{
    "Shader": {
        "info": {
            "date": "1641208676",
            "description": "All I think about when I'm on SNS: Twitter, Instagram, GitHub, and, of course, Shadertoy! :)",
            "flags": 0,
            "hasliked": 0,
            "id": "ftGXzt",
            "likes": 23,
            "name": "Approval Seeking Behavior N",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "modeling",
                "love",
                "approvalseeking"
            ],
            "usePreview": 0,
            "username": "IWBTShyGuy",
            "viewed": 467
        },
        "renderpass": [
            {
                "code": "// Copyright Â© 2022 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n#if HW_PERFORMANCE!=0\n// If defined, activate anti-aliasing, level: 2 or 3\n#define AA 3\n#endif\n\n/******************** 3D ToolKit ********************/\nconst float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float h = tan(camera.fov * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\n#define rotate3D(axis, angle) mat3(\\\n    axis[0] * axis[0] * (1.0 - cos(angle)) + cos(angle),\\\n    axis[0] * axis[1] * (1.0 - cos(angle)) + axis[2] * sin(angle),\\\n    axis[0] * axis[2] * (1.0 - cos(angle)) - axis[1] * sin(angle),\\\n    axis[0] * axis[1] * (1.0 - cos(angle)) - axis[2] * sin(angle),\\\n    axis[1] * axis[1] * (1.0 - cos(angle)) + cos(angle),\\\n    axis[1] * axis[2] * (1.0 - cos(angle)) + axis[0] * sin(angle),\\\n    axis[0] * axis[2] * (1.0 - cos(angle)) + axis[1] * sin(angle),\\\n    axis[1] * axis[2] * (1.0 - cos(angle)) - axis[0] * sin(angle),\\\n    axis[2] * axis[2] * (1.0 - cos(angle)) + cos(angle)\\\n)\n\nfloat microfacet(vec3 normal, vec3 cameraDir, vec3 lightDir, float metal, float roughness) {\n    vec3 middle = normalize(cameraDir + lightDir);\n    float dotCN = clamp(-dot(cameraDir, normal), 0.0, 1.0);\n    float dotLN = clamp(-dot(lightDir, normal), 0.0, 1.0);\n    float dotNM = clamp(-dot(normal, middle), 0.0, 1.0);\n    float dotCM = clamp(dot(cameraDir, middle), 0.0, 1.0);\n    float alpha = roughness * roughness;\n    \n    // diffuse BRDF\n    float diffuse = 1.0 - metal;\n    \n    // microfacet distribution\n    float alpha2 = alpha * alpha;\n    float tmp = 1.0 - dotNM * dotNM * (1.0 - alpha2);\n    float distribution = alpha2 / (tmp * tmp);\n\n    // schlick approxy & geometric decay\n    float alp = alpha * 0.5;\n    float sal = dotLN / (dotLN * (1.0 - alp) + alp);\n    float sac = dotCN / (dotCN * (1.0 - alp) + alp);\n    float decay = sal * sac;\n\n    // fresnel\n    float c = 1.0 - dotCM;\n    c = c * c * c * c * c;\n    float fresnel = metal + (1.0 - metal) * c;\n\n    // specular BRDF\n    tmp = 4.0 * dotCN * dotLN;\n    float specular = distribution * decay / tmp * fresnel;\n    if (tmp < 0.0001) specular = 0.0;\n    \n    return (diffuse + specular) * dotLN;\n}\n\n/******************** Hash & Noise ********************/\n// https://www.shadertoy.com/view/XlXcW4\nvec3 hash(uvec3 x) {\n    const uint k = 1103515245U;\n    x.y = ((x.y>>8U)^x.y)*k;\n    x.z = ((x.z>>8U)^x.z)*k;\n    x.z = ((x.z>>8U)^x.z)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)/float(0xffffffffU);\n}\n\nvec3 noise(vec3 x) {\n    uvec3 s = uvec3(ivec3(floor(x)) + 2147483647);\n    vec3 t = fract(x);\n    uvec2 e = uvec2(0, 1);\n    return mix(\n        mix(\n            mix(hash(s + e.xxx), hash(s + e.yxx), t.x),\n            mix(hash(s + e.xyx), hash(s + e.yyx), t.x),\n            t.y\n        ),\n        mix(\n            mix(hash(s + e.xxy), hash(s + e.yxy), t.x),\n            mix(hash(s + e.xyy), hash(s + e.yyy), t.x),\n            t.y\n        ),\n        t.z\n    );\n}\n\n\n/******************** SDFs ********************/\nconst int CLICK[] = int[](67, 108, 105, 99, 107, 32, 127);\nconst int CLICK_STAR[] = int[](67, 108, 105, 99, 107, 32, 28);\nconst int I_want_your_Love[] = int[](73, 32, 119, 97, 110, 116, 32, 121, 111, 117, 114, 32, 76, 111, 118, 101);\nconst int I_want_your_Fav[] = int[](73, 32, 119, 97, 110, 116, 32, 121, 111, 117, 114, 32, 70, 97, 118, 32);\n\nfloat dot2(in vec2 a) { return dot(a,a); }\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdHeart( in vec2 p ) {\n    p.x = abs(p.x);\n    return p.y + p.x > 1.0 ?\n    sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0 :\n    sqrt(min(dot2(p-vec2(0.00,1.00)), dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdStar5(in vec2 p, in float r, in float rf) {\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nfloat sdLetter(in vec2 uv, in int idx) {\n    if (idx == 127) return sdHeart(vec2(uv.x * 2. - 1., uv.y * 2. - .5)) / 2.0;\n    uv = (clamp(uv, 0., 1.) + vec2(idx % 16, 15 - idx / 16)) / 16.;\n    return textureLod(iChannel0, uv, 0.0).w - .5;\n}\n\nfloat ratioDeform(in float t) { return clamp(0.5 + sin(t * 2.0 * PI), 0.0, 1.0); }\nfloat sdDeformed(in vec2 p, in float t) { return mix(sdStar5(p, 0.7, 0.4), sdHeart(p + vec2(0, 0.5)), ratioDeform(t)); }\nfloat sdDeformed3D(in vec3 p, in float t) { return length(vec2(max(sdDeformed(p.xy, t), 0.0), max(abs(p.z) - 0.05, 0.0))); }\nfloat sdRing(in vec3 p, in float r, in float h) { return length(vec2(length(p.zx) - r, max(abs(p.y) - h, 0.0))); }\n\nconst mat3 CENTER_OBJECT_ROT = rotate3D(normalize(vec3(1, 1, 0)), 0.45);\nconst mat3 LETTER_RING1_ROT = rotate3D(normalize(vec3(-0.5, 1, -1)), 0.45);\nconst vec3 LETTER_RING1_DISP = vec3(-0.04, 0, 0);\nconst mat3 LETTER_RING2_ROT = rotate3D(normalize(vec3(-0.5, 1, 1)), 0.45);\nfloat sdCenterObject(in vec3 p, in float t) { return sdDeformed3D(CENTER_OBJECT_ROT * p, t) - 0.05; }\nfloat sdLetterRing1(in vec3 p) { return sdRing(LETTER_RING1_ROT * (p + LETTER_RING1_DISP), 0.85, 0.05) - 0.01; }\nfloat sdLetterRing2(in vec3 p) { return sdRing(LETTER_RING2_ROT * p, 1.0, 0.05) - 0.01; }\nfloat sdStarHeartScene(in vec3 p, in float t) { return min(min(sdCenterObject(p, t), sdLetterRing1(p)), sdLetterRing2(p)); }\n\nvec3 normalStarHeartScene(in vec3 p, in float t) {\n    const vec2 e = vec2(1.0e-4, 0);\n    return normalize(vec3(\n        sdStarHeartScene(p + e.xyy, t) - sdStarHeartScene(p - e.xyy, t),\n        sdStarHeartScene(p + e.yxy, t) - sdStarHeartScene(p - e.yxy, t),\n        sdStarHeartScene(p + e.yyx, t) - sdStarHeartScene(p - e.yyx, t)\n    ));\n}\n\nint getObjectIDStarHeart(in vec3 p, in float t) { return sdLetterRing1(p) < 1.0e-3 ? 1 : sdLetterRing2(p) < 1.0e-3 ? 2 : 0; }\n\nvec2 uvLetterRing1(in vec3 p, in float t) {\n    p = LETTER_RING1_ROT * (p + LETTER_RING1_DISP); vec2 uv = normalize(p.zx);\n    return vec2(\n        fract((acos(uv.x) * sign(uv.y) / PI + 1.0) / 2.0 + t * 0.01),\n        (p.y + 0.05) / 0.1\n    );\n}\n\nvec2 uvLetterRing2(in vec3 p, in float t) {\n    p = LETTER_RING2_ROT * p; vec2 uv = normalize(p.zx);\n    return vec2(\n        fract((acos(uv.x) * sign(uv.y) / PI + 1.0) / 2.0 + t * 0.01),\n        (p.y + 0.05) / 0.1\n    );\n}\n\nvec3 colorCenterObject(in vec3 p, in vec3 dir, in float t) {\n    vec3 normal = normalStarHeartScene(p, t);\n    float c = microfacet(normal, dir, dir, 0.5, 0.5);\n    return vec3((c + 0.1) / 1.1, (1.0 - ratioDeform(t)) * c, 0);\n}\n\nvec3 colorLetterRing1(in vec3 p, in vec3 dir, in float t) {\n    vec3 normal = normalStarHeartScene(p, t);\n    vec2 uv = uvLetterRing1(p, t);\n    int tapeWidth = int(0.85 * 2.0 * PI / 0.1 / 0.75) - 1;\n    uv.x *= float(tapeWidth);\n    int idx = int(floor(uv.x)) % (tapeWidth / 7);\n    uv.x = fract(uv.x) * 0.72 + 0.14;\n    float c = 0.0, c0 = smoothstep(0.49, 0.51, abs(uv.y - 0.5));\n    if (idx < CLICK.length()) {\n        c = mix(\n            sdLetter(uv, CLICK_STAR[idx]),\n            sdLetter(uv, CLICK[idx]),\n            ratioDeform(t)\n        );\n        c = clamp(1.0e-4 / (1.0e-8 + c * c) - 0.02, 0.0, 1.0);\n    }\n    vec3 col = vec3(microfacet(normal, dir, dir, .3, .8)) * 0.075;\n    col = col * (1.0 - c) + vec3(c * c * c, c, c * c);\n    col = col * (1.0 - c0) + c0 * vec3(1,0,0) * microfacet(normal, dir, dir, .1, .9);\n    return clamp(col, 0.0, 1.0);\n}\n\nvec3 colorLetterRing2(in vec3 p, in vec3 dir, in float t) {\n    vec3 normal = normalStarHeartScene(p, t);\n    vec2 uv = uvLetterRing2(p, -t);\n    int tapeWidth = int(2.0 * PI / 0.1 * 2.0) - 6;\n    uv.x *= float(tapeWidth);\n    int idx = int(floor(uv.x)) % (tapeWidth / 7);\n    uv.x = fract(uv.x) * 0.54 + 0.23;\n    float c = 0.0, c0 = smoothstep(0.49, 0.51, abs(uv.y - 0.5));\n    if (idx < I_want_your_Love.length()) {\n        float w = dot(normal, dir);\n        w = (1.0 + w) * 15.0 / iResolution.x;\n        float c1 = mix(\n            sdLetter(uv, I_want_your_Fav[idx]),\n            sdLetter(uv, I_want_your_Love[idx]),\n            ratioDeform(t)\n        );\n        c = clamp(1.0e-4 / (c1 * c1) - 0.02, 0.0, 1.0);\n        // I tried a few different patterns of AA, but this looks the most effective.\n        // If you have a better method, please let me know.\n        c1 = mix(\n            sdLetter(uv + vec2(w, w), I_want_your_Fav[idx]),\n            sdLetter(uv + vec2(w, w), I_want_your_Love[idx]),\n            ratioDeform(t)\n        );\n        c += clamp(1.0e-4 / (c1 * c1) - 0.02, 0.0, 1.0);\n        c1 = mix(\n            sdLetter(uv + vec2(-w, w), I_want_your_Fav[idx]),\n            sdLetter(uv + vec2(-w, w), I_want_your_Love[idx]),\n            ratioDeform(t)\n        );\n        c += clamp(1.0e-4 / (c1 * c1) - 0.02, 0.0, 1.0);\n        c1 = mix(\n            sdLetter(uv + vec2(w, -w), I_want_your_Fav[idx]),\n            sdLetter(uv + vec2(w, -w), I_want_your_Love[idx]),\n            ratioDeform(t)\n        );\n        c += clamp(1.0e-4 / (c1 * c1) - 0.02, 0.0, 1.0);\n        c1 = mix(\n            sdLetter(uv + vec2(-w, -w), I_want_your_Fav[idx]),\n            sdLetter(uv + vec2(-w, -w), I_want_your_Love[idx]),\n            ratioDeform(t)\n        );\n        c += clamp(1.0e-4 / (c1 * c1) - 0.02, 0.0, 1.0);\n        c /= 5.0;\n    }\n    vec3 col = vec3(microfacet(normal, dir, dir, .3, .8)) * 0.075;\n    col = col * (1.0 - c) + vec3(c * c * c, c, c * c);\n    col = col * (1.0 - c0) + c0 * vec3(1,0,0) * microfacet(normal, dir, dir, .1, .9);\n    return clamp(col, 0.0, 1.0);\n}\n\nconst vec3 BACK_GROUND = pow(vec3(0, 5, 10) / 255.0, vec3(2.2));\nconst float STAR_INTERVAL = 1.0 / 15.0;\n\nfloat cellStar(in vec2 uv, in vec2 nbr, in float t) {\n    vec2 xy = uv + nbr; vec3 rand = noise(vec3(floor(xy), 1));\n    if (rand.z < 0.3) return 0.0;\n    vec2 disp = (2.0 * rand.xy - 1.0) * 0.6;\n    vec2 r = fract(xy) + uv - xy - disp - 0.5;\n    float c = length(r) * STAR_INTERVAL;\n    c = clamp(5.0e-4 / c, 0.0, 1.0);\n    float a = noise(vec3(floor(xy), t * 30.0 * noise(vec3(1, floor(xy))).x)).x;\n    return c * c * mix(0.1, 1.0, a);\n}\n\nfloat star(in vec2 uv, in float t) {\n    uv.x += t * 0.01; uv /= STAR_INTERVAL;\n    float c = 0.0;\n    for (int k = 0; k < 25; k++)\n        c += cellStar(uv, vec2(k / 5, k % 5) - 2., t);\n    return clamp(c, 0.0, 1.0);\n}\n\nvoid starHeartSceneWithA(out vec4 fragColor, in vec2 U, in float t) {\n    vec2 r = iResolution.xy;\n    Camera camera = Camera(\n        vec3(0,0,2),\n        vec3(0,0,-1),\n        vec3(0,1,0),\n        PI / 4.0,\n        r.x / r.y\n    );\n    Ray ray = cameraRay(camera, U/r);\n\n    float dist0, dist = 0.0; vec3 p, ro = ray.origin, rd = ray.direction;\n    for (int i = 0; ++i < 255\n        && (dist0 = sdStarHeartScene(p = ro + dist * rd, t)) > 1.0e-4\n        && (dist += dist0) < 12.0;);\n\n    vec3 col = vec3(0);\n    if (dist < 12.0) {\n        switch (getObjectIDStarHeart(p, t)) {\n            case 0: col = colorCenterObject(p, rd, t); break;\n            case 1: col = colorLetterRing1(p, rd, t); break;\n            case 2: col = colorLetterRing2(p, rd, t); break;\n        }\n    } else {\n        float c = star(U/r.y, t);\n        col = BACK_GROUND * (1.0 - c) + c;\n    }\n\n    fragColor = vec4(clamp(col, 0.0, 1.0), dist);\n}\n\nvoid starHeartScene(out vec4 O, in vec2 U, in float t) {\n    starHeartSceneWithA(O, U, t);\n    \n    // smart anti-aliasing\n    // reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\n    // If defined, visualize anti-aliased pixels.\n    //#define VISUALIZE_AA\n    #ifdef AA\n    if (fwidth(length(O.xyz)) > 0.1 && O.w < 12.0) {\n        vec4 o;\n    #if (AA == 2)\n        for (int k = 0; k < 4; k++) {\n              starHeartSceneWithA(o,U + (vec2(k % 2, k / 2) - 0.5) / 1.5, t);\n              O += o;\n        }\n        O /= 5.0;\n    #elif (AA == 3)\n        for (int k = 0; k < 9; k += k == 3 ? 2 : 1 ) {\n              starHeartSceneWithA(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.0, t);\n              O += o;\n        }\n        O /= 9.0;\n    #endif\n    #ifdef VISUALIZE_AA\n        O = vec4(1);\n    } else {\n        O = vec4(0,0,0,1);\n    #endif\n    }\n    #endif\n    O.xyz = pow(O.xyz, vec3(.4545));\n    O.w = 1.0;\n}\n\nvoid mainImage(out vec4 O, in vec2 U) { starHeartScene(O, U, iTime); }\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}