{
    "Shader": {
        "info": {
            "date": "1649117618",
            "description": "It is here, finally",
            "flags": 0,
            "hasliked": 0,
            "id": "slSyzz",
            "likes": 8,
            "name": "Marzipan Froge",
            "published": 3,
            "tags": [
                "froge",
                "marzipan"
            ],
            "usePreview": 0,
            "username": "clepirelli",
            "viewed": 408
        },
        "renderpass": [
            {
                "code": "COLOR(white, white_id,255.0,255.0,255.0)\nCOLOR(pink, pink_id,255.0,120.0,214.0)\nCOLOR(green, green_id, 237.0,255.0,50.0)\nCOLOR(brown, brown_id, 17.5,8.5,2.0)\nCOLOR(purple, purple_id, 128.0,25.0,128.0)\n\nvec3 idToColor(float id)\n{\n    RETURN_COLOR(white, white_id)\n    RETURN_COLOR(pink, pink_id);\n    RETURN_COLOR(green, green_id);\n    RETURN_COLOR(brown, brown_id);\n    return purple;\n}\n\nsdfRet sdf(vec3 point)\n{\n    //body\n    sdfRet belly = sdfRet(sphere(point, vec3(.0, -.95, 1.1), .9), white_id);\n    sdfRet head = sdfRet(sphere(point, vec3(.0), 1.0), green_id);\n    float back = sphere(point, vec3(.0, -.1, -.9), .7);\n    \n    sdfRet allParts = paintUnionSDF(head, belly);\n    allParts = sdfRet(smin(allParts.dist, back, .7), allParts.id);\n    \n    vec3 mirroredX = mirrorX(point); \n    \n    //face\n    sdfRet eyes = sdfRet(sphere(mirroredX, vec3(.4, .3, .68), .3), brown_id);\n    sdfRet mouth = sdfRet(capsule(bend(point, 2.0), vec3(-.22, -.15, 1.0), vec3(.22, -.15, 1.0), .1), brown_id);\n    sdfRet blush = sdfRet(sphere(mirroredX, vec3(.68, -.03, .7), .15), pink_id);\n    \n    allParts = minSDF(allParts, eyes);\n    allParts = minSDF(allParts, mouth);\n    allParts = minSDF(allParts, blush);\n    \n    //back legs\n    float backThighs = sphere(mirroredX, vec3(.6, -.1, -.6), .7);\n    float backFeet = capsule(mirroredX, vec3(.9, -.6, -.6), vec3(1.0, -.6, -.2), .3);\n    sdfRet backLegs = sdfRet(smin(backThighs, backFeet, .1), allParts.id);\n    allParts = minSDF(allParts, backLegs);\n    \n    //front legs\n    float frontThighs = sphere(mirroredX, vec3(.8, -.6, .4), .2);\n    float frontFeet = capsule(mirroredX, vec3(.8, -.7, .4), vec3(.5, -.8, .6), .2);\n    sdfRet frontLegs = sdfRet(smin(frontFeet, frontThighs, .1), green_id);\n    allParts = minSDF(allParts, frontLegs);\n    \n    return allParts;\n}\n\n\n//from iq: https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 p)\n{\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdf( p + k.xyy*CLOSE_ENOUGH).dist + \n                      k.yyx*sdf( p + k.yyx*CLOSE_ENOUGH).dist + \n                      k.yxy*sdf( p + k.yxy*CLOSE_ENOUGH).dist + \n                      k.xxx*sdf( p + k.xxx*CLOSE_ENOUGH).dist );\n}\n\n//from: https://www.shadertoy.com/view/lllBDM\nfloat subsurface(vec3 p, vec3 v, vec3 n){\n    //vec3 d = normalize(mix(v, -n, 0.5));\n    // suggested by Shane\n    vec3 d = refract(v, n, 1.0/1.5);\n    vec3 o = p;\n    float a = 0.0;\n    \n    const float max_scatter = 1.5;\n    for(float i = 0.1; i < max_scatter; i += 0.2)\n    {\n        o += i*d;\n        float t = sdf(o).dist;\n        a += t;\n    }\n    float thickness = max(0.0, -a);\n    const float scatter_strength = 16.0;\n\treturn scatter_strength*pow(max_scatter*0.5, 3.0)/thickness;\n}\n\nvec3 light(vec3 point, float id, vec3 viewDir)\n{\n    vec3 norm = calcNormal(point);\n    vec3 baseColor = idToColor(id);\n    vec3 lightDir = normalize(vec3(1.0,1.0,.0));\n    vec3 reflectDir = reflect(lightDir, norm);\n    float lambert = lambertian(norm, lightDir);\n    //from: https://www.shadertoy.com/view/lllBDM\n    float subsurface_scattering = pow(subsurface(point, viewDir, norm), 0.6);\n    lambert = mix(lambert, 1.5*smoothstep(0.1, 6.0, subsurface_scattering), 0.5);\n    \n    vec3 shading = vec3(1.0,.9,.8)*lambert + pow(max(dot(viewDir, reflectDir), 0.0), 2.0);\n    return baseColor * shading;\n}\n\nvec3 Image(vec2 uv)\n{\n    float mousex = 9.0*iMouse.x/iResolution.x;\n    ray currentRay = cameraRay(mousex, uv);\n    \n    vec3 col = sky(currentRay.direction);\n    \n    float currentDistance = .0;\n    \n    for(int i = 0; i < ITERATIONS; i++)\n    {\n        vec3 samplePoint = currentRay.origin + currentRay.direction*currentDistance;\n        sdfRet ret = sdf(samplePoint);\n        if(ret.dist < CLOSE_ENOUGH)\n        {\n            col = light(samplePoint, ret.id, currentRay.direction);\n            break;\n        }\n        currentDistance += ret.dist;\n    }\n    \n    return col;\n}\n\n\n//------------ boilerplate\n\nvec4 colorCorrect(vec3 color)\n{\n    vec3 x = max(vec3(.0), color-.004);\n    vec3 retColor = (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n    return vec4(min(retColor, 1.0), 1.0);\n}\n\n//AA trick from Fabrice Neyret: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/                     \nvoid mainImage0(out vec4 frogColor, in vec2 fragCoord)\n{                                                     \n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);    \n    uv.x *= iResolution.x/iResolution.y;              \n    frogColor = colorCorrect(Image(uv));           \n}                                                     \n                                                      \nvoid mainImage(out vec4 frogColor, in vec2 fragCoord)  \n{                                                     \n    mainImage0(frogColor,fragCoord);                  \n    if ( fwidth(length(frogColor)) > .01 )            \n    {                                                 \n        vec4 col;                                     \n        for (int k=0; k < 9; k+= k==3?2:1 )           \n        {                                             \n            vec2 offset = vec2(k%3-1,k/3-1)/3.;       \n            mainImage0(col,fragCoord+offset);         \n            frogColor += col;\n        }                                             \n        frogColor /= 9.;\n    }                                                 \n}\n//------------",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define CLOSE_ENOUGH 0.0001\n#define ITERATIONS 500\n#define CAMERA_DISTANCE 6.0\n#define CAMERA_HEIGHT .5\n\n#define COLOR(name, id, r,g,b) const vec3 name = vec3(r,g,b)/255.0; const float id = float(__LINE__);\n#define RETURN_COLOR(name, col_id) if(id <= col_id) return name;\n\nstruct ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n\nstruct sdfRet\n{\n    float dist;\n    float id;\n};\n\n\n//------------ all from Inigo Quilez: https://iquilezles.org/articles/distfunctions\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sphere(vec3 point, vec3 origin, float radius)\n{\n\treturn distance(point,origin)-radius;\n}\n\nfloat smin(float d1, float d2, float k) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec3 bend(vec3 point, float amount)\n{\n    float c = cos(amount*point.x);\n    float s = sin(amount*point.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*point.xy,point.z);\n    return q;\n}\n\n//------------ end of iq code\n\n\nvec3 mirrorX(vec3 point)\n{\n    return vec3(abs(point.x), point.y, point.z);\n}\n\nsdfRet minSDF(sdfRet a, sdfRet b)\n{\n    if(a.dist < b.dist)\n    {\n        return a;\n    }\n    return b;\n}\n\nsdfRet paintUnionSDF(sdfRet a, sdfRet b)\n{\n    sdfRet bPrime = sdfRet(max(a.dist, b.dist), b.id);\n    return minSDF(a, bPrime);\n}\n\n\nfloat lambertian(vec3 n, vec3 l)\n{\n\treturn dot(n,l);\n} \n\nvec3 sky(vec3 direction)\n{\n    return vec3(.2,.4,.9)-vec3(.4,.4,.9)*direction.y;\n}\n\n\nray cameraRay(float mousex, vec2 uv)\n{\n    vec3 target = vec3(.0,.0,.0);\n    vec3 rayOrigin = target + vec3(CAMERA_DISTANCE*sin(mousex),CAMERA_HEIGHT,CAMERA_DISTANCE*cos(mousex));\n    vec3 front = normalize(target - rayOrigin);\n    vec3 right = normalize(cross(front, vec3(0.,1.,0.)));\n    vec3 up = normalize(cross(right, front));\n    return ray(rayOrigin, normalize(uv.x*right+uv.y*up+1.0*front));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}