{
    "Shader": {
        "info": {
            "date": "1431170325",
            "description": "A new version of a previous shader, now with an islamic star pattern (p6mm symmetry and hyperbolic inversion). The pattern is taken from \"Reales Alcázares\" in Seville (Spain). Comment '#define INVERSION' (line 10) to see the pattern without inversion.",
            "flags": 0,
            "hasliked": 0,
            "id": "Mlj3zc",
            "likes": 14,
            "name": "p6mm inversion with star pattern",
            "published": 3,
            "tags": [
                "pattern",
                "tilling",
                "hyperbolic",
                "wallpaper",
                "p6mm"
            ],
            "usePreview": 0,
            "username": "curena",
            "viewed": 871
        },
        "renderpass": [
            {
                "code": "// \"p6mm inversion\" by Carlos Ureña - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// *******************************************************************\n// global defs and params\n//\n\n// uncomment to perform animated circle inversion\n#define INVERSION\n\n// uncomment to view the fundamental region\n//#define HILIGHT_FUNDAMENTAL        \n\n// uncomment to view stripe animation\n// #define ANIMATION\n\n// ----------------------------------------------------------------\n// parameters and pre-calculated constants\n\nconst int \n    n          = 5 ; // square root of the number of samples per pixel (for A.A.)\n                     // full supersample anti-aliasing is done\n\nconst float \n    sqr2       = 1.41421356237, // square root of 2\n    sqr3       = 1.73205080756, // square root of 3.0\n    sqr2_inv   = 1.0/sqr2 ,\n    sqr3_inv   = 1.0/sqr3 ,\n    cos30      = 0.86602540378, // cos(30 degrees)\n    sin30      = 0.50000000000, // sin(30 degrees)\n    \n    \n#ifdef INVERSION\n    l           = 0.1,          // length of triangle in NDC (mind --> 1.0)\n#else\n#ifdef HILIGHT_FUNDAMENTAL            \n    l           = 5.2,\n#else    \n    l           = 5.5,          // length of triangle in NDC (mind --> 1.0)\n#endif    \n#endif\n    l_inv       = 1.0/l ,       // length inverse\n    line_w      = 0.03,         // line width for basic symmetry lines render\n    speedFactor = 1.0 ,         // speed factor for inversion animation (greater->faster)\n    sw          = 0.020 ;       // stripes half width for islamic star pattern\n\nconst vec2  \n    u        = 1.0*vec2( 1.0, 0.0  ) ,          // grid basis: U vector\n    v        = 0.5*vec2( 1.0, sqr3 ) ,          // grid basis: V vector\n    u_dual   = 1.0*vec2( 1.0, -sqr3_inv ) ,     // dual grid basis: U vector\n    v_dual   = 2.0*vec2( 0.0,  sqr3_inv ) ,     // dual grid basis: V vector\n    tri_cen  = vec2( 0.5, 0.5*sqr3_inv ) ;      // triangle center\nvec2\n    center ; //= 0.5*iResolution.xy ;             // viewport center in DC \nfloat \n    mind ,   // = min(iResolution.x,iResolution.y),// minimun viewport dimension in pixels \n    secs ;   // == iTime*speedFactor ;  // global time, scaled by speed factor\n    \n// -----------------------------------------------------------------------------------\n// point orbit transformation parameters\nint \n    nMirrorOdd = 0 , \n    nMirror    = 0 ,\n\tnGridX     = 0 , \n    nGridY     = 0 ;\n\n\n// *******************************************************************************\n// functions\n\n\nfloat NormCos( float w )\n{\n \treturn 0.5*(1.0+cos(secs*w)) ;   \n}\n\n\n// -------------------------------------------------------------------------------\n// mirror reflection of 'p' around and axis through 'v1' and 'v2'\n// (only for points to right of the line from v1 to v2)\n//\nvec2 Mirror( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           n = normalize(vec2( s.y, -s.x )) ;\n    float  d = dot(p-v1,n) ;\n    \n    if ( 0.0 <= d )\n    {\n       nMirrorOdd = 1-nMirrorOdd ;\n       nMirror = nMirror+1 ;\n       return p-2.0*d*n ;\n    }\n    else\n       return p ;\n}\n// -------------------------------------------------------------------\n// Signed perpendicular distance from 'p' to line through 'v1' and 'v2'\n\nfloat SignedDistance( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           n = normalize(vec2( s.y, -s.x )) ;\n    return dot(p-v1,n) ;\n}\n// -------------------------------------------------------------------\n// un-normalized signed distance to line\n\nfloat UnSignedDistance( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           un = vec2( s.y, -s.x ) ;\n    return dot(p-v1,un) ;\n}\n// -------------------------------------------------------------------\n// Signed perpendicular distance from 'p' to polyline from 'v1' \n// to 'v2' then to 'v3'\n\nfloat DoubleSignedDistance( vec2 p, vec2 v1, vec2 v2, vec2 v3 )\n{\n \t\n    vec2  dir1 = v2 + normalize(v1-v2),\n          dir3 = v2 + normalize(v3-v2);\n        \n    vec2  vm = 0.5*(dir1+dir3) ;\n    \n    float dm = UnSignedDistance( p, v2, vm ) ;\n    \n    if ( dm >= 0.0 )\n   \t\treturn SignedDistance( p, v1, v2 ) ;\n   \telse\n        return SignedDistance( p, v2, v3 ) ; \n}\n// -------------------------------------------------------------------------------\n// Takes 'p0' to the group's fundamental region, returns its coordinates in that region\n\nvec2 p6mm_ToFundamental( vec2 p0 ) \n{\n    nMirrorOdd = 0 ;\n    nMirror    = 0 ;\n    \n    // p1 = fragment coords. in the grid reference frame\n    \n    vec2 p1 = vec2( dot(p0,u_dual), dot(p0,v_dual) );\n    \n    // p2 = fragment coords in the translated grid reference frame \n    \n    vec2 p2 = vec2( fract(p1.x), fract(p1.y) ) ;\n    \n    nGridX = int(p1.x-p2.x) ; // largest integer g.e. to p1.x\n    nGridY = int(p1.y-p2.y) ; // largest integer g.e. to p2.x\n    \n    // p3 = barycentric coords in the translated triangle\n    // (mirror, using line x+y-1=0 as axis, when point is right and above axis)\n    \n    vec2 p3 = Mirror( p2, vec2(1.0,0.0), vec2(0.0,1.0) );\n    \n    // p4 = p3, but expressed back in cartesian coordinates\n    \n    vec2 p4 = p3.x*u + p3.y*v ;\n    \n    // p7 = mirror around the three lines through the barycenter, perp. to edges.\n    \n    vec2 p5 = Mirror( p4, vec2(0.5,0.0), tri_cen );\n    vec2 p6 = Mirror( p5, vec2(1.0,0.0), tri_cen );\n    vec2 p7 = Mirror( p6, tri_cen, vec2(0.0,0.0) );\n  \n    return p7 ;\n}\n\n// --------------------------------------------------------------------\n// A possible distance function\n\nfloat DistanceFunc( float d )\n{\n   return 1.0-smoothstep( line_w*0.85, line_w*1.15, d );   \n}\n\n// -------------------------------------------------------------------------------\n// Point color for basic symmetry lines in (r,g,b)\n\nvec4 p6mm_SimmetryLines( vec2 p_ndc )\n{\n\n    vec2 pf = p6mm_ToFundamental( p_ndc );\n    \n    float d1 = abs(pf.y),\n          d2 = abs(pf.x-0.5),\n          d3 = abs( SignedDistance( pf, tri_cen, vec2(0.0,0.0) ) );\n     \n    vec4 res = vec4( 0.0, 0.0, 0.0, 1.0 ) ;\n        \n    res.r = DistanceFunc(d2);\n    res.g = DistanceFunc(d1);\n    res.b = DistanceFunc(d3);\n    \n    return res ;    \n}\n\n// ---------------------------------------------------------------------\n// Stripe half width for star pattern\n\nvec4 Stripe( float d )\n{\n   if ( d > sw*0.85 )\n     return vec4( 0.0,0.0,0.0,1.0 );\n   else\n     return vec4(1.0,1.0,1.0,1.0)  ;\n    \n    \n}\n\n \n\n\n// ----------------------------------------------------------------------\n// Converts from device (pixel) coordinates to normalized coordinates\n\nvec2 DCToNDC( vec2 p_dc )\n{\n    // compute NDC:\n    vec2 p = l_inv*(p_dc - center)/mind ;\n\n#ifdef HILIGHT_FUNDAMENTAL    \n    p = p + vec2(0.25*l, 0.25*l*sqr3_inv) ;\n#endif\n    \n    // rotate 30 deg. and return\n    vec2 res= vec2( p.x*cos30 - p.y*sin30,\n                 p.y*cos30 + p.x*sin30 );\n                    \n    // flip (just to match photo)\n    return vec2( res.y, res.x ) ;\n}\n// --------------------------------------------------------------------\n// When activated, performs the circle inversion\n\nvec2 Inversion( vec2 p, vec2 cen )\n{\n#ifdef INVERSION     \n   vec2  vr   = p  -cen ;\n   float r    = length( vr );\n   \n    return cen + normalize(vr)/(r*0.1) \n              + secs/4.0*vec2(1.0,0.5)  \n              + 1.0*l*vec2( sin(secs/40.0), cos(secs/42.0) ) ;\n#else\n   return p*13.0 ;  // an arbitrary constant to allow seeing a bigger region\n#endif\n}\n\n// ---------------------------------------------------------------------\n// Color for islamic star pattern\n\nvec4 p6mm_Stripes( vec2 p_ndc )\n{\n    vec2 pf = p6mm_ToFundamental( p_ndc );\n    vec2 c  = tri_cen ;\n    \n    // constants defining the stripes \n    float \n        f   = 0.30 ,\n        fs1 = 0.14 ,\n        s1  = fs1*c.x,\n        s2  = 0.5*s1 ;\n        \n    // stripes vertexes\n    vec2 \n        // upper strip\n        u1 = vec2( f*c.x, 0.0 ) ,\n        u2 = vec2( c.x, (1.0-f)*c.y ),\n        \n        // lower strip\n        l1 = vec2( c.x, s1+s2 ),\n        l2 = vec2( c.x-s2, s1 ),\n        l3 = vec2( sqr3*s1, s1 ),\n        \n        // right strip\n        r1 = vec2( c.x-s1, (1.0-fs1)*c.y ),\n        r2 = vec2( c.x-s1, s2 ) ,\n        r3 = vec2( c.x-s1-s2, 0.0 ),\n        \n    \t// origin star strip\n        mm = vec2( s1*(sqr3-1.0/3.0), s1*(1.0-sqr3_inv) );\n    \n#ifdef ANIMATION    \n    const float k = 0.3 ;\n    \n    vec2 u2_despl = vec2(c.x,NormCos(1.0*k)*c.y), \n         u1_despl = vec2(NormCos(2.0*k)*c.x, 0.0),\n         l1_despl = vec2(c.x,s1+NormCos(3.0*k)*(c.y-s1)), \n         r3_despl = vec2((1.0-s1)*NormCos(5.0*k)*c.x, 0.0);\n    \n    u1 = 0.5*(u1+u1_despl) ;\n    u2 = 0.5*(u2+u2_despl) ;\n    l1 = 0.5*(l1+l1_despl) ;\n    r3 = 0.5*(r3+r3_despl);\n#endif    \n                    \n    // signed and unsigned distances to stripes:\n    \n    float\n        d1s = SignedDistance( pf, u1, u2 ) ,\n        d2s = DoubleSignedDistance( pf, l1, l2, l3 ) ,\n        d3s = DoubleSignedDistance( pf, r1, r2, r3 ) ,\n        d4s = DoubleSignedDistance( pf, u1, mm, l3 ) ,\n        d1  = abs( d1s ),\n        d2  = abs( d2s ),\n        d3  = abs( d3s ),\n        d4  = abs( d4s );\n    \n   \n    // stripes inclusion\n    bool in1, in2, in3, in4 ;\n    \n    if ( nMirrorOdd == 0 )\n    {\n        in1 = (d1 < sw) && ! (d2 < sw) && ! (d4 < sw);\n        in2 = (d2 < sw) && ! (d3 < sw);\n        in3 = (d3 < sw) && ! (d1 < sw);\n        \n        in4 = (d4 < sw) && ! (d2 < sw);\n    }\n    else\n    {\n        in1 = (d1 < sw) && ! (d3 < sw) ;\n        in2 = (d2 < sw) && ! (d1 < sw) && ! (d4 < sw);;\n        in3 = (d3 < sw) && ! (d2 < sw);\n        \n        in4 = (d4 < sw) && ! (d1 < sw);\n    } \n    \n    vec4 col ;\n    \n    // compute final color\n    \n    if ( in1 )      \n        col = Stripe( d1 ) ;\n    else if ( in2 ) \n        col = Stripe( d2 ) ;\n    else if ( in3 ) \n        col = Stripe( d3 ) ; \n    else if ( in4 )\n        col = Stripe( d4 ) ;   \n    else if ( d2s < 0.0 && d3s < 0.0 )\n        col = vec4( 0.0, 0.4, 0.0, 1.0 ) ;\n    else if ( d1s < 0.0 && d2s < 0.0 || d1s <0.0 && d3s < 0.0 )\n        col = vec4( 0.1, 0.1, 0.1, 1.0 );\n    else if ( d1s < 0.0 || d2s < 0.0 )\n        col = vec4( 0.0, 0.4, 0.9, 1.0 );   \n    else    \n        col = vec4( 0.6, 0.0, 0.0, 1.0 ) ; \n        \n#ifdef HILIGHT_FUNDAMENTAL        \n    if ( nMirror != 0 || nGridX != 0 || nGridY != 0 )\n     \tcol = 0.9*vec4(0.5,0.5,0.5,1) + 0.1*col ;   \n#endif\n        \n    return col ;\n}\n                  \n// ------------------------------------------------------------\n// islamic star pattern, for a point in DC coordinates\n\nvec2 mou ; //= DCToNDC( 0.5*iResolution.xy ); // mouse pressed position (==center before pressing)\n                  \nvec4 p6mm_Stripes_dc( vec2 p_dc )                 \n{\n  vec2 p_ndc = Inversion( DCToNDC( p_dc ), mou );\n  return p6mm_Stripes( p_ndc ) ;          \n}\n\n// --------------------------------------------------------------------\n// camera in world coordinates\n// (in world coordinates, Z is the vertical direction)\n\nfloat near = 1.7 ;\n\nvec3 eye_pos = vec3( -1.0, -1.5, 1.0 ),\n     look_at = vec3( 0.0, 0.0, 0.0 ),\n     eye_vup = vec3( 0.0, 0.0, 1.0 );\n\nvec3 eye_z    , //= normalize( eye_pos-look_at ) ,\n     eye_x   , //= normalize( cross( eye_vup, eye_z ) ),\n     eye_y   ; //= normalize( cross( eye_z, eye_x ) ); \n\n// -------------------------------------------------------------------------------\n\nvec3 GetDir( vec2 p_dc )\n{\n    vec2        p_ndc = 2.0*(p_dc-center)/mind ;      \n    vec3        dir   = normalize( p_ndc.x*eye_x \n                                   + p_ndc.y*eye_y \n                                   - near*eye_z );\n    const float wd    = 0.3 ;\n    float       c     = cos( iTime*wd ), \n                s     = sin( iTime*wd ) ;\n     \n    return vec3(  dir.x*c - dir.y*s,\n                  dir.y*c + dir.x*s,\n                  dir.z);\n}\n\n// -------------------------------------------------------------------------------\n\nvec4 Sky( vec3 ndir ) // ndir == normalized direction\n{\n   float z = max( ndir.z, 0.0 ) ;   \n   return vec4( 0.5,0.5,0.5, 1.0) + z*0.5*vec4( 0.3, 0.4, 0.5, 1.0 ) ;\n    \n}\n\nfloat Luminance( vec4 col )\n{\n   return col.r ; //0.3333*( col.r+col.g+col.b ) ;   \n    \n}\n\n// -------------------------------------------------------------------------------\n\nvec3 GetNormal( vec2 pos )\n{\n    const float d = 0.003 ;   \n    \n    vec2 dx = vec2( d, 0.0 ),\n         dy = vec2( 0.0, d );\n    float h0  = Luminance( p6mm_Stripes( pos )),\n          hdx = Luminance( p6mm_Stripes( pos+dx )),\n          hdy = Luminance( p6mm_Stripes( pos+dy ));\n    vec3 vdx = vec3( d, 0.0, 2.0*(hdx-h0) ),\n         vdy = vec3( 0.0, d, 2.0*(hdy-h0) );\n    \n    vec3 nor = normalize( cross( vdx, vdy ) );\n\n    if ( nor.z < 0.0 ) nor = -nor ;\n    return nor ;\n}\n\n// -------------------------------------------------------------------------------\n\nstruct TraceState\n{\n    vec3  ray_org, \n          ray_dir,\n          hit_pos,\n          hit_nor ;\n    float hit_col,\n          tmin ;\n          \n    \n} ;\n    \nvoid BasePlane( inout TraceState ts )\n{\n    if ( ts.ray_dir.z > 0.0 ) // ray to the sky\n       return ; \n    \n    // find distance (t) to intersection with plane z=0\n   float t = - ts.ray_org.z / ts.ray_dir.z ;\n    \n   if ( t < 0.0 ) // t must be positive\n       return  ; // use red to flag an error\n    \n   // if t is further away than previous, exit\n   if ( ts.tmin >= 0.0 )\n   if ( t > ts.tmin )\n       return ;\n       \n    // intersection point\n   vec3 p_int = ts.ray_org + t*ts.ray_dir ; \n    \n  \n   // if out limits, return\n   const float hs = 60.0 ;  \n   if ( abs( p_int.x ) > hs || abs( p_int.y ) > hs )\n       return ;\n    \n   // convert to ndc and do inversion\n   vec2 p_int_ndc = Inversion( 0.5*p_int.xy, vec2(0.0,0.0) ) ;\n   vec4 col = p6mm_Stripes( p_int_ndc ) ;\n   \n   // compute normal\n   vec3 nor = GetNormal( p_int_ndc ); \n    //nor = vec3( 0.0, 0.0, 1.0 );\n    \n    \n}\n\n// ------------------------\nvec4 RayTrace_dc( vec2 p_dc )\n{\n   vec3 ray_org = eye_pos,\n        ray_dir = GetDir( p_dc ) ;\n   \n   if ( ray_dir.z > 0.0 ) // ray to the sky\n       return vec4( 0.5, 0.5, 0.8, 1.0 ); \n    \n    // find distance (t) to intersection with plane z=0\n   float t = - ray_org.z / ray_dir.z ;\n    \n   if ( t < 0.0 ) // t must be positive\n       return Sky( ray_dir) ; // use red to flag an error\n    \n   vec3 p_int = ray_org + t*ray_dir ;  // intersection point\n    \n  \n   // if out limits, return\n   const float hs = 60.0 ;  \n   if ( abs( p_int.x ) > hs || abs( p_int.y ) > hs )\n       return vec4( 0.0, 0.0, 1.0, 1.0 ) ;//Sky( ray_dir ) ;\n    \n   // convert to ndc and do inversion\n   vec2 p_int_ndc = Inversion( 0.5*p_int.xy, vec2(0.0,0.0) ) ;\n   vec4 col = p6mm_Stripes( p_int_ndc ) ;\n   \n   // compute normal\n   vec3 nor = GetNormal( p_int_ndc ); \n    //nor = vec3( 0.0, 0.0, 1.0 );\n   \n   // dir to light\n   vec3 ldir = normalize( vec3( 1.0, 0.2, 1.0 ) ) ;\n    \n   // vector to viewer (and reflected)\n   vec3 vv = normalize( -ray_dir );\n    \n   if ( vv.z < 0.0 ) vv = -1.0*vv ;\n   vec3 vvr = normalize(vv- 2.0*dot( vv,nor)*nor) ;\n    \n   // MIL\n   float nl = max( 0.0, dot(nor,ldir) ),\n         rv = max( 0.0, dot(ldir,vvr) ),\n         pexp = 1.0 ;\n    \n  const float kd = 1.1, ks = 1.2 ;\n    \n  return kd*nl*col + ks*pow( rv, pexp)*vec4( 1.0, 1.0, 1.0, 1.0 ); \n   \n}\n\n// -------------------------------------------------------------------------------\n// main color computing function for a point in device coordinates\n\nvec4 MainColorFunction_dc( vec2 p_dc )\n{\n    return p6mm_Stripes_dc( p_dc );  // islamic star pattern \n    //return RayTrace_dc( p_dc ) ;\n}\n\n// -------------------------------------------------------------------------------\n// initialize globals which depend on values known at run-time \n\nvoid InitGlobals()\n{\n    center = 0.5*iResolution.xy ;             // viewport center in DC \n    mind   = min(iResolution.x,iResolution.y); // minimun viewport dimension in pixels \n    secs   = iTime*speedFactor ;  // global time, scaled by speed factor\n    mou    = DCToNDC( 0.5*iResolution.xy ); // mouse pressed position (==center before pressing)\n    \n    // eye pos\n    eye_z  = normalize( eye_pos-look_at ) ;\n    eye_x  = normalize( cross( eye_vup, eye_z ) );\n    eye_y  = normalize( cross( eye_z, eye_x ) ); \n}\n \n// -------------------------------------------------------------------------------\n// main function, does multi-sample anti-aliasing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    InitGlobals() ;\n    \n    const float n_inv = 1.0/float(n) ;\n    vec4 res          = vec4( 0.0, 0.0, 0.0, 1.0 );\n    \n    if ( iMouse.w != 0.0 )\n        mou  = DCToNDC( iMouse.xy  ) ;\n    \n    for (int ix = 0 ; ix < n ; ix += 1 )\n    for (int iy = 0 ; iy < n ; iy += 1 )\n    {\n       float px = -0.5 + (0.5+float(ix))*n_inv,   \n             py = -0.5 + (0.5+float(iy))*n_inv ;\n        \n       vec2 p_dc = fragCoord + vec2( px, py ) ;\n       res += MainColorFunction_dc( p_dc );\n    }\n    fragColor = n_inv*n_inv*res ;   \n}\n// -------------------------------------------------------------------------------",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}