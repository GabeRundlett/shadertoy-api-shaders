{
    "Shader": {
        "info": {
            "date": "1643968394",
            "description": "From a concept by @oneshade: [url]https://www.shadertoy.com/view/fdjczd[/url] - and using the line calculations from that shader.",
            "flags": 0,
            "hasliked": 0,
            "id": "sd2czd",
            "likes": 11,
            "name": "Glowing Hyperboloid",
            "published": 3,
            "tags": [
                "star",
                "festive",
                "pentagram"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 444
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n// Glowing Hyperboloid, Matthew Arcus, mla, 2022\n// Inspired by, and uses code from https://www.shadertoy.com/view/fdjczd\n// by @oneshade\n////////////////////////////////////////////////////////////////////////////////\n\nconst int N = 50; // Number of lines\nconst float scale = 1.0;\nconst float CAMERA = 6.0;\nconst float A = 0.1; // Light amplitude\nconst float K = 6.0; // Exponental falloff\nconst float PI = 3.14159265;\nconst float TWOPI = 2.0*PI;\n#define sin(x) sin(mod((x),TWOPI))\n#define cos(x) cos(mod((x),TWOPI))\n\nfloat det(vec2 c0, vec2 c1) {\n  return determinant(mat2(c0,c1));\n}\n\n// Given lines p+kq and r+js, points\n// u = p+kq, v = r+js are closest if\n// q.(u-v) = 0 = s.(u-v) (ie. the line\n// between them is orthogonal to both lines).\n// Expanding out gives a linear system to\n// solve for k and j.\nvec2 closest0(vec3 p,vec3 q,vec3 r,vec3 s) {\n  // Use Cramer's rule to solve linear system\n  // Matrices are column major!\n  // Assume q and s are unit vectors\n  // No cross products, 4 dot products, 3 2x2 determinants\n  vec2 c0 = vec2(1.0,dot(q,s));\n  vec2 c1 = vec2(-dot(q,s),-1.0);\n  vec2 a = vec2(dot(r-p,q),dot(r-p,s));\n  return vec2(det(a,c1),det(c0,a))/det(c0,c1);\n}\n\n// return vec2(k,j) such that p + kq and\n// r + js are closest points on lines\n// Assumes q and s are normalized\nvec2 closest1(vec3 p,vec3 q,vec3 r,vec3 s) {\n  // Matrices are column major!\n  // Assume q and s are unit vectors\n  mat2 m = mat2(1.0,dot(q,s),-dot(q,s),-1.0);\n  return inverse(m)*vec2(dot(r-p,q),dot(r-p,s));\n}\n\n// Nice \"geometric\" solution from Wikipedia.\n// Probably not as fast as Cramer's rule,\n// 3 cross products, 4 dot products & a normalize\nvec2 closest2(vec3 p,vec3 q,vec3 r,vec3 s) {\n   vec3 n = normalize(cross(q,s));\n   vec3 n1 = cross(q,n); \n   vec3 n2 = cross(s,n);\n   return vec2(dot(r-p,n2)/dot(q,n2),\n               dot(p-r,n1)/dot(s,n1));\n}\n\nvec2 closest3(vec3 p,vec3 q,vec3 r,vec3 s) {\n  // Matrices are column major!\n  // Assume q and s are unit vectors\n  float k = dot(q,s);\n  mat2 m = mat2(-1.0,-k,k,1.0);\n  return m*vec2(dot(r-p,q),dot(r-p,s))/(k*k-1.0);\n}\n\nvec2 closest(vec3 p,vec3 q,vec3 r,vec3 s) {\n  return closest3(p,q,r,s);\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return rgb;\n}\n\n// Quaternion to rotation matrix, assumes normalized\nmat3 qrot(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x*x, y2 = y*y, z2 = z*z;\n  float xy = x*y, xz = x*z, xw = x*w;\n  float yz = y*z, yw = y*w, zw = z*w;\n  return 2.0*mat3(0.5-y2-z2, xy+zw, xz-yw,\n                  xy-zw, 0.5-x2-z2, yz+xw,\n                  xz+yw, yz-xw, 0.5-x2-y2);\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  return p;\n}\n\nvoid mainImage(out vec4 outColor, vec2 fragCoord) {\n  vec2 xy = scale*(2.0*fragCoord - iResolution.xy)/iResolution.y;\n  // p+kq is viewing ray\n  vec3 p = vec3(0,0,-CAMERA);\n  vec3 q = vec3(xy,2);\n  p = transform(p);\n  q = transform(q);\n  q = normalize(q);\n  \n  // r+js is polygon line, to be rotated in loop\n  vec3 r = vec3(0,1,0);\n  vec3 s = vec3(1,0,0);\n  // Rotation axis\n  vec3 axis = normalize(vec3(1,1,cos(0.1*iTime)));\n  float phi = iTime*0.15;\n  mat3 n = qrot(vec4(sin(phi)*axis,cos(phi)));\n  p = n*p; q = n*q;\n  float mindist = 1e10;\n  vec3 color = vec3(0); // Accumulate color here\n  float len = 2.0;\n  float twist = sin(0.25 * iTime) * PI / 2.0;\n\n  // Convert twist angle to a rotation matrix\n  float co = cos(twist), si = sin(twist);\n  mat2 rot = mat2(co, -si, si, co);\n\n  // Calculate height to keep line length constant\n  float chord = 2.0 * sin(twist);\n  float halfHeight = sqrt(len * len - chord * chord) / 2.0;\n  for (int i = 0; i < N; i++) {\n    float a = TWOPI*float(i)/float(N);\n    vec3 p1 = vec3(cos(a), -halfHeight, sin(a));\n    vec3 p2 = vec3(p1.x, halfHeight, p1.z);\n\n    p1.xz *= transpose(rot); // Rotate in opposite direction\n    p2.xz *= rot;\n    vec3 r = 0.5*(p1+p2), s = normalize(p1-p2);    \n    vec2 k = closest(p,q,r,s);\n    if (k.x > 0.0) {\n      vec3 p0 = p+k.x*q;\n      vec3 r0 = r+k.y*s;\n      float d = distance(p0,r0);\n      float h = mod(0.3*(-iTime+log(1.0+abs(k.y))),1.0);\n      vec3 basecolor = h2rgb(h);\n      color += A*exp(-K*d)*basecolor;\n    }\n  }\n  color = pow(color,vec3(0.4545));\n  outColor = vec4(color,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}