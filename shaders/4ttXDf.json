{
    "Shader": {
        "info": {
            "date": "1481910790",
            "description": "Originally Krzysztof Narkowicz made quake 1 logo and I made it for quake 2 logo for fun.\nyou should check https://www.shadertoy.com/view/4dKXDy",
            "flags": 0,
            "hasliked": 0,
            "id": "4ttXDf",
            "likes": 5,
            "name": "Quake 2 Logo",
            "published": 3,
            "tags": [
                "quake2logo"
            ],
            "usePreview": 0,
            "username": "ProgC",
            "viewed": 660
        },
        "renderpass": [
            {
                "code": "// Original Quake 1 Logo by \n// \"Quake Logo\" by Krzysztof Narkowicz @knarkowicz\n// and this is quake 2 logo!\n\nconst float MATH_PI = float( 3.14159265359 );\n\nfloat VisibilityTerm( float roughness, float ndotv, float ndotl )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat visV\t= ndotl * sqrt( ndotv * ( ndotv - ndotv * m2 ) + m2 );\n\tfloat visL\t= ndotv * sqrt( ndotl * ( ndotl - ndotl * m2 ) + m2 );\n\treturn 0.5 / max( visV + visL, 0.00001 );\n}\n\nfloat DistributionTerm( float roughness, float ndoth )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat d\t\t= ( ndoth * m2 - ndoth ) * ndoth + 1.0;\n\treturn m2 / ( d * d * MATH_PI );\n}\n\nvec3 FresnelTerm( vec3 specularColor, float vdoth )\n{\n\tvec3 fresnel = clamp( 50.0 * specularColor.y, 0.0, 1.0 ) * specularColor + ( 1.0 - specularColor ) * pow( ( 1.0 - vdoth ), 5.0 );\n\treturn fresnel;\n}\n\nvec3 LightSpecular( vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightColor, float roughness, vec3 specularColor )\n{\n\tvec3 halfVec = normalize( viewDir + lightDir );\n\n\tfloat vdoth = clamp( dot( viewDir,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndoth\t= clamp( dot( normal,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndotv = clamp( dot( normal,\tviewDir  ), 0.0, 1.0 );\n\tfloat ndotl = clamp( dot( normal,\tlightDir ), 0.0, 1.0 );\n    \n   \tvec3\tf = FresnelTerm( specularColor, vdoth );\n\tfloat\td = DistributionTerm( roughness, ndoth );\n\tfloat\tv = VisibilityTerm( roughness, ndotv, ndotl );\n    \n    vec3 specular;\n\tspecular = lightColor * f * ( d * v * MATH_PI * ndotl );\n\treturn specular;\n}\n\nfloat Cylinder( vec3 p, float r, float height ) \n{\n\tfloat d = length( p.xz ) - r;\n\td = max( d, abs( p.y ) - height );\n\treturn d;\n}\n\nfloat Sphere( vec3 p, float s )\n{\n\treturn length( p ) - s;\n}\n\nfloat Box( vec3 p, vec3 b )\n{\n\tvec3 d = abs( p ) - b;\n\treturn min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat Substract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat SubstractRound( float a, float b, float r ) \n{\n\tvec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n\treturn min( -r, max( a, -b ) ) + length( u );\n}\n\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat UnionRound( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( b - a ) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\nfloat TriPrism( vec3 p, vec3 h )\n{        \n    vec3 q = abs( p );\n    return max( q.y - h.y, max( q.z * 0.866025 + p.x * h.z, -p.x ) - h.x * 0.5 );\n}\n\nfloat Scene( vec3 p, mat3 localToWorld )\n{\n    p = p * localToWorld;\n    \n    // ring\n    float a = Cylinder( p, 1.0, 0.1 );\n    float b = Cylinder( p + vec3( 0.12, 0.0, 0.0 ), 0.9, 0.2 ); \n    float ring = Substract( a, b );\n    \n    // nail\n    float c = Box( p + vec3( -0.8, 0.0, -0.18 ), vec3( 0.4, 0.1, 0.1 ) );\n    float d = Box( p + vec3( -0.4, 0.0, -0.18 ), vec3( 0.02, 0.1, 0.25 ) );\n    float e = TriPrism( p + vec3( -1.274, 0.0, -0.18 ), vec3( 0.149, 0.1, 0.16 ) );\n    float nail = Union( UnionRound( c, d, 0.1 ), e );\n    \n    // nail2\n    float c2 = Box( p + vec3( -0.8, 0.0, 0.18 ), vec3( 0.4, 0.1, 0.1 ) );\n    float d2 = Box( p + vec3( -0.4, 0.0, 0.18 ), vec3( 0.02, 0.1, 0.25 ) );\n    float e2 = TriPrism( p + vec3( -1.274, 0.0, 0.18 ), vec3( 0.149, 0.1, 0.16 ) );\n    float nail2 = Union( UnionRound( c2, d2, 0.1 ), e2 );\n    \n    // dents\n    float f = TriPrism( p + vec3( +0.08, 0.0, -0.85 ), vec3( 0.1, 0.2, 0.5 ) );\n    float g = TriPrism( p + vec3( -0.45, 0.0, -0.4 ), vec3( 0.1, 0.2, 0.16 ) );\n    float h = TriPrism( p + vec3( -0.8, 0.0, -0.65 ), vec3( 0.08, 0.2, 0.16 ) );\n    float i = TriPrism( p + vec3( -0.9, 0.0, 0.3 ), vec3( 0.04, 0.2, 0.16 ) );\n    float j = TriPrism( p + vec3( +0.3, 0.0, 0.68 ), vec3( 0.28, 0.2, 0.16 ) );\n    float k = TriPrism( p + vec3( -0.45, 0.0, -0.94 ), vec3( 0.07, 0.2, 0.5 ) );\n    float l = TriPrism( p + vec3( 0.0, 0.0, 1.06 ), vec3( 0.1, 0.2, 0.5 ) );\n\n    float dents = Union( Union( Union( Union( Union( Union( f, g ), h ), i ), j ), k ), l );\n    ring = SubstractRound( ring, dents, 0.03 );\n    \n    float ret = Union(Union( ring, nail ), nail2);\n\treturn ret;\n}\n\nfloat CastRay( in vec3 ro, in vec3 rd, mat3 localToWorld )\n{\n    const float maxd = 5.0;\n    \n\tfloat h = 0.5;\n    float t = 0.0;\n   \n    for ( int i = 0; i < 50; ++i )\n    {\n        if ( h < 0.001 || t > maxd ) \n        {\n            break;\n        }\n        \n\t    h = Scene( ro + rd * t, localToWorld );\n        t += h;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n\t\n    return t;\n}\n\nvec3 SceneNormal( in vec3 pos, mat3 localToWorld )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    Scene( pos + eps.xyy, localToWorld ) - Scene( pos - eps.xyy, localToWorld ),\n\t    Scene( pos + eps.yxy, localToWorld ) - Scene( pos - eps.yxy, localToWorld ),\n\t    Scene( pos + eps.yyx, localToWorld ) - Scene( pos - eps.yyx, localToWorld ) );\n\treturn normalize( -nor );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n\n\tvec3 rayOrigin \t= vec3( 0.0, -0.28, -3.5 );\n    vec3 rayDir \t= normalize( vec3( p.x, p.y, 2.0 ) );\n    \n    float theta = -0.5 * MATH_PI;\n    mat3 rotX = mat3(\n        vec3( cos( theta ), sin( theta ), 0.0 ),\n        vec3( -sin( theta ), cos( theta ), 0.0 ),\n\t\tvec3( 0.0, 0.0, 1.0 )\n        );    \n    \n    vec2 mo = iMouse.xy / iResolution.xy;    \n    float phi = 0.25 * MATH_PI + 2.0 * iTime + 10.0 * mo.x;    \n    mat3 rotY = mat3(\n        vec3( 1.0, 0.0, 0.0 ),\n        vec3( 0.0, cos( phi ), sin( phi ) ),\n        vec3( 0.0, -sin( phi ), cos( phi ) )\n        );\n    \n    mat3 localToWorld = rotX * rotY;    \n\n\n\tvec3 color = texture( iChannel0, q ).yyy * 0.3;\n    \n\tfloat t = CastRay( rayOrigin, rayDir, localToWorld );\n    if ( t > 0.0 )\n    {\n        vec3 pos = rayOrigin + t * rayDir;\n        vec3 normal = SceneNormal( pos, localToWorld );\n        vec3 lightDir = normalize( vec3( 0.5, 0.3, 1.0 ) );\n        vec3 lightColor = vec3( 1.6 );\n        \n        vec3 posLS = pos * localToWorld;\n        vec3 nrmLS = normal * localToWorld;\n        vec2 uvX = posLS.yz;\n        vec2 uvY = posLS.xz;\n        vec2 uvZ = posLS.xy;\n        \n        vec3 textureX = texture( iChannel0, uvX ).xyz;\n        vec3 textureY = texture( iChannel0, uvY ).xyz;\n        vec3 textureZ = texture( iChannel0, uvZ ).xyz;\n        \n        vec3 weights = max( abs( nrmLS ), 0.00001 );\n\t\tweights /= weights.x + weights.y + weights.z;\n        \n        vec3 texture = textureX * weights.x + textureY * weights.y + textureZ * weights.z;\n        \n        float rustMask = clamp( texture.x * 3.0 - 0.5, 0.0, 1.0 );\n                \n        vec3 diffuseColor = mix( vec3( 0.0 ), texture, rustMask );\n        diffuseColor *= diffuseColor * vec3( 0.94, 0.72, 0.47 ) * 1.5;\n        vec3 specularColor = mix( texture, vec3( 0.04 ), rustMask );\n        float roughness = mix( 0.2, 0.6, rustMask );\n        \n        vec3 diffuse = lightColor * clamp( dot( normal, lightDir ), 0.0, 1.0 );\n        color = diffuseColor * ( diffuse + 0.2 );\n        color += LightSpecular( normal, rayDir, lightDir, lightColor, roughness, specularColor );\n    }\n    \n    fragColor = vec4( color, 1.0 );\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}