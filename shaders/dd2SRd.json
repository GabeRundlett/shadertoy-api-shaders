{
    "Shader": {
        "info": {
            "date": "1670775299",
            "description": " Implementing physical diffraction grating by Alan Zucconi (great article):\n\n https://www.alanzucconi.com/2017/07/15/the-mathematics-of-diffraction-grating/\n\n",
            "flags": 64,
            "hasliked": 0,
            "id": "dd2SRd",
            "likes": 19,
            "name": "[phreax] escher's dream",
            "published": 3,
            "tags": [
                "escher",
                "bumpmapping",
                "isometric",
                "diffractiongrating"
            ],
            "usePreview": 0,
            "username": "phreax",
            "viewed": 330
        },
        "renderpass": [
            {
                "code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2022\n   \n   Implementing physical diffraction grating by Alan Zucconi (great article)\n   \n   https://www.alanzucconi.com/2017/07/15/the-mathematics-of-diffraction-grating/\n   \n   This was of great help, as I was to stupid to compute the tangent vectors\n   https://www.shadertoy.com/view/7dVGzz\n   \n   Based on https://www.shadertoy.com/view/dd2SRd\n*/\n\n#define PI 3.141592\n#define TAU (2.*PI)\n#define SIN(x) (sin(x)*.5+.5)\n#define BUMP_EPS 0.004\n#define tt iTime\n\n\nfloat g_mat;\nvec2 g_uv;\n\n// first time to use a struct in my shaders (;\nstruct ObjectInfo {\n    float t;\n    float mat;\n    vec2 uv;\n};\n\n\nmat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n\nfloat saturate(float x) {\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x) {\n    return clamp(x, vec3(0), vec3(1));\n}\n\n\n// zucconis spectral palette https://www.alanzucconi.com/2017/07/15/improving-the-rainbow-2/\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n    vec3 y = 1. - x * x;\n    y = clamp((y-yoffset), vec3(0), vec3(1));\n    return y;\n}\n\nconst highp float NOISE_GRANULARITY = 0.5/255.0;\n\nhighp float random(highp vec2 coords) {\n   return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 invGamma(vec3 col) {\n    return pow(col, vec3(2.2));\n}\n\nvec3 gamma(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}\n\nvec3 spectralZucconi6(float x) {\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\tvec3 col =  bump3y(c1 * (x - x1), y1) + bump3y(c2 * (x - x2), y2);\n    col = invGamma(col);\n    return col;\n}\n\n// wrapped map\nvec3 wrappedSpectralZucconi6(float x) {\n    x = fract(x);\n    return spectralZucconi6(x);\n}\n\n// wavelength normalized for diffraction grading\nvec3 waveZucconi6(float w) {\n\n    if(w > 700.0 || w < 400.0){\n        return vec3(0);\n    }\n    \n\tfloat x = fract((w - 400.0)/ 300.0);\n\n    return spectralZucconi6(x);\n}\n\nfloat rect( vec2 p, vec2 b, float r ) {\n    vec2 d = abs(p) - (b - r);\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.) - r;\n}\n\n\n// Get orthonormal basis from surface normal\n// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\n// from: https://www.shadertoy.com/view/7dVGzz\nvoid pixarONB(vec3 n, out vec3 b1, out vec3 b2){\n\tfloat sign_ = sign(n.z);\n\tfloat a = -1.0 / (sign_ + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = vec3(1.0 + sign_ * n.x * n.x * a, sign_ * b, -sign_ * n.x);\n\tb2 = vec3(b, sign_ + n.y * n.y * a, -n.y);\n}\n\nvec3 diffraction(vec3 rd, vec3 n, vec3 td, vec3 l, float d) {\n\n    vec3 col = vec3(0);\n   \n    float cos_ThetaL = dot(l, td);\n    float cos_ThetaV = dot(rd, td);\n   \n    float u = abs(cos_ThetaL - cos_ThetaV);\n    \n    if(u == 0.) {\n        return vec3(0);\n    }\n    \n    for(float i=1.; i < 2.; i++) {\n        float wavelength = u * d / i;\n        col += waveZucconi6(wavelength);\n    }\n    col = clamp(col, vec3(0), vec3(1));\n    return col;\n}\n\n// iq\nfloat sdBoxFrame( vec3 p, vec3 b, float e ){\n\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n\nfloat box(vec3 p, vec3 r) {\n  vec3 d = abs(p) - r;\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n\nvec3 transform(vec3 p) {\n   p.z -= 5.;\n   p.yz *= rot(.3*PI*sin(0.25*tt));\n   p.yx *= rot(PI*.25 );\n   return p;\n}\n\n// polar coords\nvec2 torusUV(vec3 p) {\n    float a = atan(p.z, p.x);\n    float r = length(p.zx);\n    \n    return vec2(r, a);  \n}\n\n// adapted from https://www.shadertoy.com/view/4sjXW1\nvec2 cubeUV(in vec3 p) {\n    vec2 x = p.zy/p.x;\n    vec2 y = p.xz/p.y;\n    vec2 z = p.xy/p.z;\n    \n    //select face\n    p = abs(p);\n    if (p.x > p.y && p.x > p.z) return x;\n    else if (p.y > p.x && p.y > p.z) return y;\n    else return z;\n}\n\nfloat map(vec3 p) {     \n  \n    vec3 bp = p;\n    float edge = 0.005;\n    \n    p = transform(p);\n\n    vec3 p1 = abs(p)- mix(.0, 1.9, SIN(0.5*tt));\n    float f1 = sdBoxFrame(p1, vec3(1.0), .15)-edge;\n\n    vec3 p2 = abs(p)- mix(.0, 1.9*2., SIN(.25*tt))-edge;\n    float f2 = sdBoxFrame(p2, vec3(1.+.5*SIN(.25*tt)), .15)*.75;\n    \n    g_uv = f1 < f2 ? cubeUV(p1) : cubeUV(p2);  // save uv's for texture and bump mapping\n\n    float d = min(f1, f2); \n    return d;\n    \n}\n\n\nvec3 getNormal(vec3 p) {\n\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(map(p + eps.xyy) - map(p - eps.xyy),\n                          map(p + eps.yxy) - map(p - eps.yxy),\n                          map(p + eps.yyx) - map(p - eps.yyx)\n                         )\n                     );\n}\n\n// Shane's bump mapping\nfloat gridSurface( in vec3 p){\n    p = abs(mod(p*2., 1.*0.125)-0.0125);\n    \n    float x = min(p.x,min(p.z, p.y))/0.03125;\n\n    return clamp(x, 0., 1.);\n}\n\n// Standard function-based bump mapping function (from Shane)\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const float eps = BUMP_EPS;\n    float ref = gridSurface(p);                 \n    vec3 grad = vec3( gridSurface(vec3(p.x-eps, p.y, p.z))-ref,\n                      gridSurface(vec3(p.x, p.y-eps, p.z))-ref,\n                      gridSurface(vec3(p.x, p.y, p.z-eps))-ref )/eps;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + bumpfactor*grad );\n\t\n}\n\n// from iq\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nObjectInfo raymarch(vec3 ro, vec3 rd, float steps) {\n\n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n          \n    vec2 uv; // object uv\n          \n    vec3 p = ro;\n    for(float i=.0; i<steps; i++) {\n    \n        d = map(p);\n        mat = g_mat;  // save global material infos\n        uv = g_uv;\n        \n        if(abs(d) < 0.0001 || t > 100.) break;\n        \n        t += d;\n        p += rd*d;\n    }\n    \n    return ObjectInfo(t, mat, uv);  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(uv*9.,-4.),      // ray origin and ray direction swapped, for isometric /\n         rd = vec3(0,0,1.),         // orhographic perspective\n         lp = vec3(3., 4., -4),\n         lp2 = vec3(-3., -4., -2);\n\n    vec3 col;\n       \n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n\n\n    vec2 e = vec2(0.0035, -0.0035);\n     \n    // background color\n    vec3 c1 = vec3(0.478,1.000,0.914);\n    vec3 c2 = vec3(0.922,0.784,0.976);\n    \n    float steps = 200.;\n\n    ObjectInfo objectInfo = raymarch(ro, rd, steps);\n    mat = objectInfo.mat;\n\n    vec3 p = ro + objectInfo.t*rd;\n\n    vec3 n = normalize(e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                       e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n\n\n    vec2 tuv = objectInfo.uv;\n\n    n = doBumpMap(vec3(tuv*.5, 0.), n, .009);\n\n    if(objectInfo.t < 50.) {\n\n        vec3 l = normalize(lp-p);\n        vec3 l2 = normalize(lp2-p);\n        float dif = max(dot(n, l), .0);\n        float dif2 = max(dot(n, l2), .0);\n        float spe = pow(max(dot(reflect(-rd, n), -l), .0),40.);\n\n\n        float shd = softshadow(p, l2, 0.1, 50., 5.0);\n\n        float sss = smoothstep(0., 1., map(p + l * .4)) / .4;\n        float height = atan(n.y, n.x);\n\n        // some none physical iridescence\n        vec3 iri = spectralZucconi6(height*1.11)*smoothstep(.8, .2, abs(n.z))-.08;\n\n        // get tangent vector for diffraction grating\n        vec3 tangent;\n        vec3 bitangent;\n\n        pixarONB(n, tangent, bitangent);\n        tangent = normalize(tangent);\n        bitangent = normalize(bitangent);\n        \n        mat3 tbn = mat3(tangent, bitangent, n);\n        vec3 td = normalize(tbn * vec3(tuv, 0.));\n        \n        l = normalize(vec3(0, 1, 0));\n        vec3 difr = diffraction(-rd, n, td, l, 780.); // zucconis diffraction grating\n        col += .5*(c1*dif + c2*dif2)+ 1.8*difr + .9*iri + .4*sss + .2;\n\n        float grids = 60.;\n\n        vec2 grid = smoothstep(.0, .1, SIN(grids*(tuv+.5)));\n        col *= dot(grid, vec2(.5));\n        \n        if(mat == 0.) {\n            vec3 refld = reflect(ro, n);\n\n            vec3 refl = texture(iChannel0, refld, 5.).rgb;\n            \n            refl = invGamma(refl);\n            col = mix(col, refl, .5);\n        } \n\n        col *= 1.3; // brighten\n        \n        // fog\n        float t = objectInfo.t;\n        float fog = 1.-exp(-t*t*0.005);\n        \n        col = mix(col, c1, fog);\n        col = mix(col, col*shd, .7);\n\n    } else {\n        col =  mix(c1, c2, (pow(dot(uv, uv), .8)))*.9; // background\n        col = invGamma(col);\n\n    } \n    \n\n    col += mix(-NOISE_GRANULARITY, NOISE_GRANULARITY, random(uv)); // dither\n    col *= mix(.2, 1., (1.5-pow(dot(uv, uv), .5))); // vignette\n    col = gamma(col); // gamma\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 31248,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/carbonbasedlifeforms/accede?si=871fd3cc13664e3982d54125d484e1e9&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}