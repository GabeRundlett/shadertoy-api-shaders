{
    "Shader": {
        "info": {
            "date": "1699723321",
            "description": "Classic raytracing using Cook-Torrance shading model. It supports reflection (4 levels) and refraction, hard shadow are supported but enabled only for the ground balls.",
            "flags": 0,
            "hasliked": 0,
            "id": "Dt3cDf",
            "likes": 9,
            "name": "Cook-Torrance Raytracing",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "Ryukijano",
            "viewed": 242
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////\n// Classic raytracing\n// Cook-Torrance shading \n//\n// The shaders displays 3 series of balls with different materials:\n// - Ground: Basic (no reflection, no refraction), roughness and density varying foreach ball.\n// - Along blue wall: Reflective materials, roughness and density varying foreach ball.\n// - Along orange wall: Refractive materials,roughness and density varying foreach ball.\n// - Center: the ball at the center is both reflective and refractive.\n//\n// Hard shadow are supported but enabled only for the ground balls.\n//\n\nstruct Material {\n\tvec3  color;\t\t// diffuse color\n\tbool reflection;\t// has reflection \n\tbool refraction;\t// has refraction\n\tfloat n;\t\t\t// refraction index\n\tfloat roughness;\t// Cook-Torrance roughness\n\tfloat fresnel;\t\t// Cook-Torrance fresnel reflectance\n\tfloat density;\t\t// Cook-Torrance color density i.e. fraction of diffuse reflection\n};\n\nstruct Light {\n\tvec3 pos;\n\tvec3 color;\n};\n\n//////////////////////////////////////\n/// Ray-Primitive intersections\n/// fast version test the existence of \n/// an intersection\n\nstruct Inter {\n\tvec3 p;\t\t//pos\n\tvec3 n; \t//normal\n\tvec3 vd;\t// viewdir\n\tfloat d;\t//distance\n\tbool inside; // inside object\n\tMaterial mat; // object material\n};\n\nfloat fastintSphere(vec3 ro, vec3 rd, vec3 p, float r)\n{\n\tfloat dist = -1.;\n\tvec3 v = ro-p;\n\tfloat b = dot(v,rd);\n\tfloat c = dot(v,v) - r*r;\n\tfloat d = b*b-c;\n\tif (d>0.)\n\t{\n\t\tfloat t1 = (-b-sqrt(d));\n\t\tfloat t2 = (-b+sqrt(d));\n\t\tif (t2>0.)\n\t\t\tdist = t1>0.?t1:t2;\n\t}\n\treturn dist;\n}\n\nvoid intSphere(vec3 ro, vec3 rd, vec3 p, float r, Material mat, inout Inter i)\n{\n\tfloat dist = -1.;\n\tvec3 v = ro-p;\n\tfloat b = dot(v,rd);\n\tfloat c = dot(v,v) - r*r;\n\tfloat d = b*b-c;\n\tif (d>0.)\n\t{\n\t\tfloat t1 = (-b-sqrt(d));\n\t\tfloat t2 = (-b+sqrt(d));\n\t\tif (t2>0.)\n\t\t{\n\t\t\tdist = t1>0.?t1:t2;\n\t\t\tif ((dist<i.d)||(i.d<0.))\n\t\t\t{\n\t\t\t\ti.p = ro+dist*rd;\n\t\t\t\ti.n = normalize(i.p-p);\n\t\t\t\ti.d = dist;\n\t\t\t\ti.vd = -rd;\n\t\t\t\ti.inside = t1<0.;\n\t\t\t\tif (i.inside)\n\t\t\t\t\ti.n *= -1.; //invert the normal when hitting inside during refraction\n\t\t\t\ti.mat = mat;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfloat fastintPlane(vec3 ro, vec3 rd, vec3 p, vec3 n)\n{\n\tfloat res = -1.;\n\tfloat dpn = dot(rd,n);\n\tif (abs(dpn)>0.00001)\n\t\tres = (-(dot(n, p) + dot(n,ro)) / dpn);\n\treturn res;\n}\n\nbool intPlane(vec3 ro, vec3 rd, vec3 p, vec3 n, Material mat, inout Inter i)\n{\n\tfloat d = -1.;\n\tfloat dpn = dot(rd,n);\n\tif (abs(dpn)>0.00001)\n\t{\n\t\td = -(dot(n, p) + dot(n,ro)) / dpn;\n\t\tif ((d>0.)&&((d<i.d)||(i.d<0.)))\n\t\t{\n\t\t\ti.p = ro+d*rd;\n\t\t\ti.n = n;\n\t\t\ti.d = d;\n\t\t\ti.vd = -rd;\n\t\t\ti.inside = false;\n\t\t\ti.mat = mat;\n\t\t}\n\t}\n\treturn (i.d==d);\n}\n\n//////////////////////////////////////\n/// Shading functions\nvec3 shadeBlinnPhong( Inter i, vec3 lp )\n{\n\tfloat diffuse = 0.6;\n\tfloat specular = 0.4;\n\t\n\tvec3 res = vec3(0.);\n\tvec3 ld = normalize(lp-i.p);\n\tres = i.mat.color*diffuse*dot(i.n,ld);\n\tvec3 h = normalize(i.vd+ld);\n\tres += specular*pow(dot(i.n,h), 16.);\n\treturn res;\n}\n\nvec3 shadePhong( Inter i, vec3 lp )\n{\n\tfloat diffuse = 0.6;\n\tfloat specular = 0.4;\n\t\n\tvec3 res = vec3(0.);\n\tvec3 ld = normalize(lp-i.p);\n\tres = i.mat.color*diffuse*dot(i.n,ld);\n\tres += specular*pow( clamp(dot(reflect(i.vd,i.n),ld),0.,1.), 16.);\n\treturn res;\n}\n\n/// References:\n/// http://content.gpwiki.org/index.php/D3DBook:%28Lighting%29_Cook-Torrance\n/// http://ruh.li/GraphicsCookTorrance.html\nvec3 shadeCookTorrance( Inter i, Light lig )\n{\n\tfloat roughness = i.mat.roughness;\n\tfloat F0 = i.mat.fresnel;\n\tfloat K = i.mat.density;\n\t//\n\tvec3 ld = normalize(lig.pos-i.p);\n\tvec3 h = normalize(i.vd+ld);\n\tfloat NdotL = clamp( dot( i.n, ld ),0.,1. );\n\tfloat NdotH = clamp( dot( i.n, h ),0.,1. );\n\tfloat NdotV = clamp( dot( i.n, i.vd ),0.,1. );\n\tfloat VdotH = clamp( dot( h, i.vd ),0.,1. );\n\tfloat rsq = roughness * roughness;\n\t\n\t// Geometric Attenuation\n\tfloat NH2   = 2. * NdotH / VdotH;\n\tfloat geo_b = (NH2 * NdotV );\n\tfloat geo_c = (NH2 * NdotL );\n\tfloat geo   = min( 1., min( geo_b, geo_c ) );\n\t\n\t// Roughness\n\t// Beckmann distribution function\n\tfloat r1 = 1. / ( 4. * rsq * pow(NdotH, 4.));\n\tfloat r2 = (NdotH * NdotH - 1.) / (rsq * NdotH * NdotH);\n\tfloat rough = r1 * exp(r2);\n\t\n\t// Fresnel\t\t\t\n\tfloat fres = pow( 1.0 - VdotH, 5. );\n\tfres *= ( 1.0 - F0 );\n\tfres += F0;\n\t\n\tvec3 spec = (NdotV * NdotL==0.) ? vec3(0.) : vec3 ( fres * geo * rough ) / ( NdotV * NdotL );\n\tvec3 res = NdotL * ( (1.-K)*spec + K*i.mat.color ) * lig.color;// * exp(-0.001*length(lig.pos-i.p));\n\treturn res;\n}\n\n////////////////////////////////////\n// Raytracing\n\nfloat hidden( Inter i, vec3 lp)\n{\n\tvec3 ro = i.p;\n\tfloat dmax = length(lp-ro);\n\tvec3 rd = normalize(lp-ro);\n\tro += 0.001*rd;\n\t//\n\tfloat hit = -1.;\n\tvec3 p = vec3(0.,0.,0.);\n\tvec3 n = vec3(0.,1.,0.);\n\thit = fastintPlane( ro, rd, p, n);\n\thit = hit>dmax?-1.:hit;\n\t//\n\tif (hit<0.)\n\t{\n\t\tfloat pi = 1.25;\n\t\tp = vec3(-2.5,0.5,-2.5);\n\t\tfor (int k=0; k<5; ++k)\n\t\t{\n\t\t\tp.z = -2.5;\n\t\t\tfor (int l=0;l<5;++l)\n\t\t\t{\n\t\t\t\thit = fastintSphere( ro, rd, p, 0.5);\n\t\t\t\tif ((hit>0.) && (hit<dmax)) break;\n\t\t\t\tp.z += pi;\n\t\t\t}\n\t\t\tif (hit>0.) break;\n\t\t\tp.x += pi;\n\t\t}\n\t}\n\treturn hit;\n}\n\nvec3 raytraceRay( vec3 ro, vec3 rd, inout Inter i)\n{\n\tMaterial mat;\n\tmat.color = vec3(0.75);\n\tmat.reflection = false;\n\tmat.refraction = false;\n\tmat.n = 1.;\n\tmat.fresnel = 0.8;\n\tmat.roughness = 1.;\n\tmat.density = 1.;\n\tvec3 p = vec3(0.,0.,0.);\n\tvec3 n = vec3(0.,1.,0.);\n\tif (intPlane( ro, rd, p, n, mat, i))\n\t{\n\t\t// checker plane hack\n\t\ti.mat.color = vec3(0.75)*mod(floor(i.p.x)+floor(i.p.z),2.)+0.25;\n\t}\n\t//\n\tp = vec3(-8.,0.,0.);\n\tn = vec3(-1.,0.,0.);\n\tif (intPlane( ro, rd, p, n, mat, i))\n\t{\n\t\t// checker plane hack\n\t\ti.mat.color = vec3(0.95,0.35,0.)*mod(floor(i.p.y)+floor(i.p.z),2.)+0.25;\n\t}\n\t//\n\tp = vec3(0.,0.,8.);\n\tn = vec3(0.,0.,1.);\n\tif (intPlane( ro, rd, p, n, mat, i))\n\t{\n\t\t// checker plane hack\n\t\ti.mat.color = vec3(0.35,0.65,0.95)*mod(floor(i.p.x)+floor(i.p.y),2.)+0.25;\n\t}\n\t//\n\tmat.color = vec3(1.0,1.0,0.25);\n\tmat.reflection = false;\n\tmat.refraction = false;\n\tmat.n = 1.;\n\tmat.fresnel = 0.8;\n\tmat.roughness = 0.1;\n\tmat.density = 0.95;\n\tfloat pi = 1.25;\n\tfloat ri = 0.2;\n\tp = vec3(-2.5,0.5,-2.5);\n\tfor (int k=0; k<5; ++k)\n\t{\n\t\tmat.roughness = 0.1;\n\t\tp.z = -2.5;\n\t\tfor (int l=0; l<5; ++l)\n\t\t{\n\t\t\tintSphere( ro, rd, p, 0.5, mat, i);\n\t\t\tmat.roughness += ri;\n\t\t\tp.z += pi;\n\t\t}\n\t\tmat.density -= ri;\n\t\tp.x += pi;\n\t}\n\t//\n\tmat.color = vec3(1.0,1.0,0.25);\n\tmat.reflection = true;\n\tmat.refraction = false;\n\tmat.n = 1.;\n\tmat.fresnel = 0.8;\n\tmat.roughness = 0.1;\n\tmat.density = 0.95;\n\tpi = 1.25;\n\tri = 0.2;\n\tp = vec3(-2.5,1.,-4.);\n\tfor (int k=0; k<5; ++k)\n\t{\n\t\tmat.roughness = 0.1;\n\t\tp.y = 1.;\n\t\tfor (int l=0; l<5; ++l)\n\t\t{\n\t\t\tintSphere( ro, rd, p, 0.5, mat, i);\n\t\t\tmat.roughness += ri;\n\t\t\tp.y += pi;\n\t\t}\n\t\tmat.density -= ri;\n\t\tp.x += pi;\n\t}\n\t//\n\tmat.color = vec3(1.0,1.0,0.25);\n\tmat.reflection = false;\n\tmat.refraction = true;\n\tmat.n = 1.16;\n\tmat.fresnel = 0.8;\n\tmat.roughness = 0.9;\n\tmat.density = 0.15;\n\tpi = 1.25;\n\tri = 0.2;\n\tp = vec3(4.,1.,2.5);\n\tfor (int k=0; k<5; ++k)\n\t{\n\t\tmat.density = 0.15;\n\t\tp.y = 1.;\n\t\tfor (int l=0; l<5; ++l)\n\t\t{\n\t\t\tintSphere( ro, rd, p, 0.5, mat, i);\n\t\t\tmat.density += ri;\n\t\t\tp.y += pi;\n\t\t}\n\t\tmat.roughness -= ri;\n\t\tp.z -= pi;\n\t}\n\t//\n\tmat.color = vec3(0.0,1.0,1.0);\n\tmat.reflection = true;\n\tmat.refraction = true;\n\tmat.n = 1.33;\n\tmat.fresnel = 0.8;\n\tmat.roughness = .1;\n\tmat.density = 0.5;\n\tp = vec3(0.,4.0,0.);\n\tintSphere( ro, rd, p, 1.5, mat, i);\n\t//\n\tvec3 col = vec3(0.1,0.1,0.1);\n\tif (i.d>0.)\n\t{\n\t\t// ambiant\n\t\tfloat ambiant = 0.1;\n\t\tcol = ambiant*i.mat.color;\n\t\t\n\t\tif (!i.inside)\n\t\t{\n\t\t\t// lighting\n\t\t\tLight lig;\n\t\t\tlig.color = vec3(1.,1.,1.);\n\t\t\tlig.pos = vec3(0., 6., 0.);\n\t\t\tif (hidden(i,lig.pos)<0.)\n\t\t\t\tcol += 0.5*shadeCookTorrance(i, lig);\n\t\t\tlig.pos = vec3(-4., 6., -4.);\n\t\t\tif (hidden(i,lig.pos)<0.)\n\t\t\t\tcol += 0.5*shadeCookTorrance(i, lig);\n\t\t}\n\t}\n\treturn clamp(col,0.,1.);\n}\n\nvec3 raytrace( vec3 ro, vec3 rd)\n{\n\tInter i;\n\ti.p = vec3(0.,0.,0.);\n\ti.n = vec3(0.,0.,0.);\n\ti.d = -1.;\n\ti.vd = vec3(0.,0.,0.);\n\ti.inside = false;\n\t//\n\tvec3 accum = vec3(0.);\n\tvec3 col = vec3(0.);\n\tfloat refl = 1.;\n\tfloat refr = 1.;\n\tcol = raytraceRay(ro, rd, i);\n\taccum += col; // * exp(-0.0005*i.d*i.d);\n\tif (i.mat.reflection)\n\t{\n\t\tInter li = i;\n\t\tvec3 lro = ro;\n\t\tvec3 lrd = rd;\n\t\tlro = li.p;\n\t\tlrd = reflect(-li.vd,li.n);\n\t\tlro += 0.0001*lrd;\n\t\tfor (int k=1; k<4; ++k)\n\t\t{\n\t\t\tli.d = -1.;\n\t\t\trefl *= 1.-i.mat.density;\n\t\t\t//\n\t\t\tcol = raytraceRay(lro, lrd, li);\n\t\t\t//\n\t\t\taccum += col * refl; // * exp(-0.005*i.d*i.d);\n\t\t\tif ((li.d<.0)||(!li.mat.reflection)) break;\n\t\t\tlro = li.p;\n\t\t\tlrd = reflect(-li.vd,li.n);\n\t\t\tlro += 0.0001*lrd;\n\t\t}\n\t}\n\tif (i.mat.refraction)\n\t{\n\t\tInter li = i;\n\t\tvec3 lro = ro;\n\t\tvec3 lrd = rd;\n\t\tfloat n = 1./li.mat.n;\n\t\tfloat cosI = -dot(li.n,li.vd);\n\t\tfloat cost2 = 1.-n*n*(1.-cosI*cosI);\n\t\tif (cost2>0.)\n\t\t{\n\t\t\tlro = li.p;\n\t\t\tlrd = normalize(-li.vd*n+li.n*(n*cosI - sqrt(cost2)));\n\t\t\tlro += 0.0001*lrd;\n\t\t\tfor (int k=1; k<4; ++k)\n\t\t\t{\n\t\t\t\tli.d = -1.;\n\t\t\t\trefr *= 1.-li.mat.density;\n\t\t\t\t//\n\t\t\t\tcol = raytraceRay(lro, lrd, li);\n\t\t\t\t//\n\t\t\t\taccum += col * refr; //* exp(-0.005*i.d*i.d);\n\t\t\t\tif ((li.d<.0)||(!li.mat.refraction)) break;\n\t\t\t\tif (li.inside)\n\t\t\t\t\tn = li.mat.n;\n\t\t\t\telse\n\t\t\t\t\tn = 1./li.mat.n;\n\t\t\t\tcosI = -dot(li.n,li.vd);\n\t\t\t\tcost2 = 1.-n*n*(1.-cosI*cosI);\n\t\t\t\tif (cost2<=0.) break;\n\t\t\t\tlro = li.p;\n\t\t\t\tlrd = normalize(-li.vd*n+li.n*(n*cosI - sqrt(cost2)));\n\t\t\t\tlro += 0.0001*lrd;\n\t\t\t}\n\t\t}\n\t}\n\treturn clamp(accum,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\t \n\tfloat Time = 0.45*(15.0 + iTime);\n\t// camera\t\n\tvec3 ro = vec3( 8.0*cos(Time), 6.0, 8.0*sin(Time) );\n//\tvec3 ro = vec3( -8.0, 6.0, 8.0 );\n\tvec3 ta = vec3( 0.0, 2.5, 0. );\n\n\tvec2 m = iMouse.xy / iResolution.xy;\n\tif( iMouse.z>0.0 )\n\t{\n\t\tfloat hd = -m.x * 14.0 + 3.14159;\n\t\tfloat elv = m.y * 3.14159 * 0.4 - 3.14159 * 0.25;\n\t\tro = vec3(sin(hd) * cos(elv), sin(elv), cos(hd) * cos(elv));\n\t\tro = ro * 8.0 + vec3(0.0, 6.0, 0.0);\n\t}\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n    vec3 col = raytrace( ro, rd );\n\t\n\tfragColor=vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}