{
    "Shader": {
        "info": {
            "date": "1653850831",
            "description": "Fixed version of pbr implementation (old: https://www.shadertoy.com/view/7djBDh)\nFixes: extra shadowing was removed, ao was replaced by ao+so, shadow algorithm was changed.\nGGX brdf + point light + env probe + ao + so + bent normals + volume selfshadowing",
            "flags": 32,
            "hasliked": 0,
            "id": "Nsdyzf",
            "likes": 13,
            "name": "Some pbr",
            "published": 3,
            "tags": [
                "pbr"
            ],
            "usePreview": 0,
            "username": "kaylent",
            "viewed": 544
        },
        "renderpass": [
            {
                "code": "//minus: texture is convoluted for diff part from -Pi/2 to Pi/2. It`s better to use horizon.\n\n#define PI 3.1415926535897932384626433832795\n#define heightCoef 5.\nconst float lightSourceRadius = 0.05*heightCoef;\n\nconst float convKernel[] = float[]\n(\n    0.00291502, 0.0130642, 0.0215393, 0.0130642, 0.00291502, \n    0.0130642, 0.0585498, 0.0965324, 0.0585498, 0.0130642, \n    0.0215393, 0.0965324, 0.159155, 0.0965324, 0.0215393, \n    0.0130642, 0.0585498, 0.0965324, 0.0585498, 0.0130642, \n    0.00291502, 0.0130642, 0.0215393, 0.0130642, 0.00291502 \n);\n\nconst vec3 albedo = vec3(0.7,0.7,0.8);\nconst float metallic = 0.7;\nconst float roughness = 0.1;\nconst float lightStrength = 3.*heightCoef*heightCoef;\n\nvec3 lightPosition = vec3(0.,0.,0.);\n\n\nvec3 Lo_Env(const vec3 N, const vec3 V, const vec3 H, const vec2 texCoord);\nvec3 Lo_DL(const vec3 N, const vec3 V, const vec3 L, const vec3 H);\nfloat getSelfShadows(const vec2 fragCoord);\nvec3 bentNormal(const vec2 texCoords, const vec3 normal);\nvec3 orientToVector(const vec3 toVector, const vec3 vector);\nvec3 convolultedEnvMap(const vec3 normal);\nfloat specularAOExperiment(vec2 texCoord, vec3 L, vec3 V);\nvec3 animateLightPoint();\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float xzFragCoordToWorld = heightCoef/iResolution.y;\n    lightPosition = vec3(iMouse.x*xzFragCoordToWorld, heightCoef, iMouse.y*xzFragCoordToWorld);\n    if (iMouse.x == 0.)\n    {\n        lightPosition = animateLightPoint();\n    }\n    vec3 cameraPosition = vec3(0.5*iResolution.x*xzFragCoordToWorld, heightCoef, 0.5*iResolution.y*xzFragCoordToWorld);   \n    vec2 uv = fragCoord/iResolution.y*2.;\n    vec3 pixelPosition = vec3(fragCoord.x*xzFragCoordToWorld,  (texture(iChannel0, uv).x - 1.)*heightCoef, fragCoord.y*xzFragCoordToWorld);\n    vec3 L = normalize(lightPosition - pixelPosition );\n    vec3 V = normalize(cameraPosition - pixelPosition );\n    float shadowMultiplier = getSelfShadows(fragCoord);\n    \n    /////////////////////////////////////////////////\n    ////calculate normal/////////////////////////////\n    /////////////////////////////////////////////////\n    vec3 vector1;\n    vec3 vector2;\n    float deltaHeight;\n    float stepUv = 1./512.;\n    \n    deltaHeight = ( texture(iChannel0, vec2(uv.x, uv.y+stepUv)).x - texture(iChannel0, vec2(uv.x, uv.y-stepUv)) ).x * heightCoef;\n    vector1.x = 0.;\n    vector1.y = deltaHeight;\n    vector1.z = 1.;\n    \n    deltaHeight = ( texture(iChannel0, vec2(uv.x+stepUv, uv.y)).x - texture(iChannel0, vec2(uv.x-stepUv, uv.y)) ).x * heightCoef;\n    vector2.x = 1.;\n    vector2.y = deltaHeight;\n    vector2.z = 0.;\n    \n    vec3 N = normalize(cross(vector1, vector2));\n    \n    //////////////////////////////////////////////\n    ////PBR///////////////////////////////////////\n    //////////////////////////////////////////////\n    vec4 lightColor = vec4(1., 1., 1., 1.)*lightStrength;\n    float gamma = 2.2f;\n    \n    vec3 H = normalize(L + V);\n    \n    float lightDistance = distance(lightPosition, pixelPosition);\n    float attenuation = 1./pow(lightDistance-lightSourceRadius, 2.);\n    vec3 radiance = lightColor.xyz*attenuation;\n    \n    float NdotL = max(dot(N, L), 0.);\n    vec3 Lo = Lo_Env(N, V, H, uv); //bent to diff\n    Lo+=Lo_DL(N, V, L, H)*radiance*NdotL*shadowMultiplier;\n    \n    fragColor = vec4(Lo , 1.);\n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(1./gamma));\n    \n    if (distance(lightPosition.xz/xzFragCoordToWorld, fragCoord.xy) < 3.)\n        fragColor = vec4(1., 0.,0.,1.); \n}\n\n    \n//////////////////////////////////////////////\n////IBL///////////////////////////////////////\n//////////////////////////////////////////////\n\nvec3 fresnelSchlick_IBL(float cosTheta, vec3 F0){\n    return F0 + (max(vec3(1. - roughness), F0) - F0) * pow(1. - cosTheta, 5.);\n}\n\nfloat DistributionGGX_IBL(vec3 N, vec3 H, float roughness){\n    float a = pow(roughness, 2.);\n    float a2 = pow(a, 2.);\n    float NdotH = max(dot(N, H), 0.);\n    float NdotH2 = pow(NdotH, 2.);\n    \n    float num = a2;\n    float denom = (NdotH2 * (a2 - 1.) + 1.);\n    denom = PI * pow(denom, 2.);\n    \n    return num / denom;\n}\n\nfloat GeometrySchlickGGX_IBL(float NdotV, float roughness){\n    float r = (roughness);\n    float k = sqrt((r*r)*2.);\n    \n    float nom   = NdotV;\n    float denom = NdotV * (1. - k) + k;\n    \n    return nom / denom;\n}\n\nfloat GeometrySmith_IBL(vec3 N, vec3 V, vec3 L, float roughness){\n    float NdotV = max(dot(N, V), 0.);\n    float NdotL = max(dot(N, L), 0.);\n    float ggx2 = GeometrySchlickGGX_IBL(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX_IBL(NdotL, roughness);\n    \n    return ggx1 * ggx2;\n}\n\n\nfloat RadicalInverse_VdC(uint bits)\n{\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10;\n}\n\nvec2 Hammersley(uint i, uint N)\n{\n    return vec2(float(i)/float(N), RadicalInverse_VdC(i));\n}\n\nvec3 ImportanceSampleGGX_IBL(vec2 Xi, vec3 N)\n{\n    float a = roughness*roughness;\n\t\n    float phi = 2. * PI * Xi.x;\n    float sinTheta = a*sqrt(Xi.y)/sqrt(1.-Xi.y);\n    float cosTheta = sqrt(1. - sinTheta*sinTheta);\n\t\t\n    vec3 H;\n    H.x = cos(phi) * sinTheta;\n    H.y = cosTheta;\n    H.z = sin(phi) * sinTheta;\n    \n    return normalize(orientToVector(N, H));\n}  \n\nvec3 getFilteredEnvironmentMap(vec3 N, vec3 V)\n{\n    const uint SAMPLE_COUNT = 32u;\n    float totalWeight = 0.;\n    vec3 prefilteredColor = vec3(0.);\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H  = ImportanceSampleGGX_IBL(Xi, N);\n        vec3 L  = normalize(2. * dot(V, H) * H - V);\n        \n        float NdotL = max(dot(N, L), 0.);\n        if(NdotL > 0.)\n        {\n            prefilteredColor += texture(iChannel1, L).rgb * NdotL;\n            totalWeight      += NdotL;\n        }\n    }\n    prefilteredColor = prefilteredColor / totalWeight;\n    \n    return prefilteredColor;\n}\n\nvec2 IntegrateBRDF(float NdotV)\n{\n    vec3 V;\n    V.x = sqrt(1. - NdotV*NdotV);\n    V.y = NdotV;\n    V.z = 0.;\n    \n    float A = 0.;\n    float B = 0.;\n    \n    vec3 N = vec3(0., 1., 0.);\n    \n    const uint SAMPLE_COUNT = 32u;\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H  = ImportanceSampleGGX_IBL(Xi, N);\n        vec3 L  = normalize(2. * dot(V, H) * H - V);\n        \n        float NdotL = max(L.y, 0.);\n        float NdotH = max(H.y, 0.);\n        float VdotH = max(dot(V, H), 0.);\n        \n        if(NdotL > 0.)\n        {\n            float G = GeometrySmith_IBL(N, V, L, roughness);\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\n            float Fc = pow(1. - VdotH, 5.);\n            \n            A += (1. - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A /= float(SAMPLE_COUNT);\n    B /= float(SAMPLE_COUNT);\n    return vec2(A, B);\n}\n\nvec3 Lo_Env(const vec3 N, const vec3 V, const vec3 H, const vec2 texCoord){\n    vec3 F0 = vec3(0.04, 0.04, 0.04);\n    F0 = mix(F0, albedo, metallic);\n    vec3 F = fresnelSchlick_IBL(max(dot(N, V), 0.), F0);\n    vec2 envBRDF = IntegrateBRDF(dot(N, V));\n    vec3 prefilteredColor = getFilteredEnvironmentMap(N, V);\n    vec3 specular = prefilteredColor * (F0 * envBRDF.x + envBRDF.y);\n    \n    vec3 kD = vec3(1.) - F;\n    kD *= 1.0f - metallic;\n    vec3 bentN = bentNormal(texCoord, N);\n    vec3 irradiance = convolultedEnvMap(bentN);\n    vec3 ambient = kD * irradiance * albedo;\n    \n    vec3 fr = length(bentN)*ambient/PI + clamp(pow(dot(V, H)+length(bentN), 2.) - 1. + length(bentN), 0.,1.)*specular;\n    return fr;\n}\n\nvec3 fresnelSchlick_DL(float cosTheta, vec3 F0){\n    return F0 + (1. - F0) * pow(1. - cosTheta, 5.);\n}\n\nfloat DistributionGGX_DL(vec3 N, vec3 H, float roughness){\n    float a = pow(roughness, 2.);\n    float a2 = pow(a, 2.);\n    float NdotH = max(dot(N, H), 0.);\n    float NdotH2 = pow(NdotH, 2.);\n    \n    float num = a2;\n    float denom = (NdotH2 * (a2 - 1.) + 1.);\n    denom = PI * pow(denom, 2.);\n    \n    return num / denom;\n}\n\nfloat GeometrySchlickGGX_DL(float NdotV, float roughness){\n    float r = (roughness);\n    float k = pow((r+1.), 2.)/8.;\n    \n    float num = NdotV;\n    float denom = NdotV * (1. - k) + k;\n    \n    return num / denom;\n}\n\nfloat GeometrySmith_DL(vec3 N, vec3 V, vec3 L, float roughness){\n    float NdotV = max(dot(N, V), 0.);\n    float NdotL = max(dot(N, L), 0.);\n    float ggx2 = GeometrySchlickGGX_DL(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX_DL(NdotL, roughness);\n    \n    return ggx1 * ggx2;\n}\n\nvec3 Lo_DL(const vec3 N, const vec3 V, const vec3 L, const vec3 H)\n{\n    vec3 F0 = vec3(0.04, 0.04, 0.04);\n    F0 = mix(F0, albedo, metallic);\n    vec3 F = fresnelSchlick_DL(max(dot(H, V), 0.0f), F0);\n    float NDF = DistributionGGX_DL(N, H, roughness);\n    float G = GeometrySmith_DL(N, V, L, roughness);\n    \n    vec3 numerator = NDF*F*G;\n    float denominator = 4. * max(dot(N, V), 0.) * max (dot(N, L), 0.) + 0.001;\n    vec3 specular = numerator / denominator;\n    \n    vec3 kS = F;\n    vec3 kD = vec3(1.) - kS;\n    kD *= 1. - metallic;\n    \n    vec3 fr = kD*albedo/PI + specular;\n    \n    return fr;\n}\n\nvec3 orientToVector(const vec3 toVector, const vec3 vector)\n{\n    vec3 up        = abs(toVector.y) < 0.999 ? vec3(0.0, 1.0, 0.0) : vec3(0.0, 0.0, 1.0);\n    vec3 tangent   = normalize(cross(up, toVector));\n    vec3 bitangent = cross(toVector, tangent);\n\t\n    return tangent * vector.x + bitangent * vector.z + toVector * vector.y;\n}\n\nfloat getSelfShadows(const vec2 fragCoord) //minus - depends on screen size\n{\n    float accum = 0.;\n    for (int x = -2; x < 3; ++x)\n    {\n        for (int y = -2; y < 3; ++y)\n        {\n            vec2 uv = vec2(fragCoord.x + float(x), fragCoord.y + float(y))/iResolution.xy;\n            accum += texture(iChannel2, uv).x*convKernel[x+2 + (y+2)*5]; // 5x5 conv kernel\n        }\n    }\n    return accum;\n}\n\nvec3 bentNormal(const vec2 texCoords, const vec3 N)\n{\n    const uint numRotateSteps = 16u;\n    const uint numRaySteps = 8u;\n    const float maxTexCoordDistance = 0.05;\n    const float rotateStep = 2.*PI/float(numRotateSteps);\n    \n    float fragmentHeight = (texture(iChannel0, texCoords).x - 1.)*heightCoef;\n    \n    vec3 bentNormal = vec3(0.);\n    for (uint theta = 0u; theta<numRotateSteps/4u; ++theta)\n    {\n        for(uint phi = 0u; phi<numRotateSteps; ++phi)\n        {\n            vec3 pRandVecDir;\n            pRandVecDir.y = cos(rotateStep*float(theta));            \n            float xzFactor = sin(rotateStep*float(theta));\n            pRandVecDir.x = cos(rotateStep*float(phi))*xzFactor;\n            pRandVecDir.z = sin(rotateStep*float(phi))*xzFactor;\n            pRandVecDir = orientToVector(N, pRandVecDir);\n            \n            vec3 stepRay = pRandVecDir/float(numRaySteps)*maxTexCoordDistance/xzFactor;\n            vec3 ray = stepRay;\n            \n            bool isOccluded = false;\n            uint step = 1u;\n            for (; step < numRaySteps+1u; ++step)\n            {\n                if ((texture(iChannel0, texCoords+ray.xz).x - 1.)*heightCoef > fragmentHeight + stepRay.y)\n                {\n                    break;\n                }\n                ray += stepRay;\n            }\n           \n            bentNormal+=((float(step)/float(numRaySteps)))*pRandVecDir*pRandVecDir*sin(rotateStep*float(theta))*cos(rotateStep*float(theta))*PI/(float(numRotateSteps/4u*numRotateSteps));\n        }\n    }\n    return bentNormal;\n}\n\nvec3 convolultedEnvMap(const vec3 N)\n{\n    const uint numRotateSteps = 20u;\n    const float rotateStep = 2.*PI/float(numRotateSteps);\n    vec3 convColor = vec3(0.);\n    \n    for (uint theta = 0u; theta<numRotateSteps/4u; ++theta)\n    {\n        for(uint phi = 0u; phi<numRotateSteps; ++phi)\n        {\n            vec3 pRandVecDir;\n            pRandVecDir.y = cos(rotateStep*float(theta));\n            float xzFactor = sin(rotateStep*float(theta));\n            pRandVecDir.x = cos(rotateStep*float(phi))*xzFactor;\n            pRandVecDir.z = sin(rotateStep*float(phi))*xzFactor;\n            pRandVecDir = orientToVector(N, pRandVecDir);\n            \n            convColor += texture(iChannel1, pRandVecDir).xyz*sin(rotateStep*float(theta))*cos(rotateStep*float(theta))*PI*PI/(float(numRotateSteps/4u*numRotateSteps)); \n        }\n    }\n    return convColor;\n}\n\nvec3 animateLightPoint()\n{\n    vec3 pointPos1 = vec3(0.);\n    pointPos1.y = heightCoef;\n    float modulo = mod(iTime, 2.*PI);\n    pointPos1.x = ((cos(modulo + PI/2.) + 1.)/2.*0.8 + 0.1)*heightCoef;\n    pointPos1.z = ((sin(modulo + PI/2.) + 1.)/2.*0.8 + 0.1)*heightCoef;\n\n    vec3 pointPos2 = vec3(0.);\n    pointPos2.y = heightCoef;\n    modulo = mod(iTime, 2.*PI);\n    pointPos2.x = ((cos(-modulo - PI/2.) + 1.)/2.*0.8 + 0.1 + iResolution.x/iResolution.y - 1.)*heightCoef;\n    pointPos2.z = ((sin(-modulo - PI/2.) + 1.)/2.*0.8 + 0.1)*heightCoef;\n    \n    vec3 pointPos = vec3(0.);\n    pointPos = mix(pointPos1, pointPos2, (cos(mod(iTime, 2.*PI) + PI/2.)+1.)/2.);\n    \n    return pointPos;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.1415926535897932384626433832795\n#define lightSourceRadius 0.05\n#define heightCoef 5.\n\nconst vec3 lightApprx[16] = vec3[]\n(\n    vec3(0.551047, 0.766867, 0.329033), vec3(0.40481, 0.903168, -0.142888), \n    vec3(0.544277, 0.804168, 0.238905), vec3(-0.900311, 0.0365544, -0.43371), \n    vec3(0.526163, 0.0951804, -0.84504), vec3(0.928479, 0.362623, 0.0802011), \n    vec3(-0.371819, 0.287964, -0.882512), vec3(0.079554, 0.54282, 0.836073), \n    vec3(-0.320073, 0.842607, -0.433089), vec3(-0.958668, 0.261276, -0.112653), \n    vec3(-0.670151, 0.674361, -0.310056), vec3(0.309392, 0.420734, -0.852795), \n    vec3(-0.955604, 0.0966579, 0.27835), vec3(0.684154, 0.286764, 0.670597), \n    vec3(0.60757, 0.772842, 0.183232), vec3(0.393977, 0.563268, 0.726299)\n);\n\nconst float lightApprxNoise[4] = float[](1.804289383, 0.846930886, 0.424238335, 3.044897763);\n\nvec3 orientToVector(vec3 toVector, vec3 vector)\n{\n    vec3 up        = abs(toVector.y) < 0.999 ? vec3(0.0, 1.0, 0.0) : vec3(0.0, 0.0, 1.0);\n    vec3 tangent   = normalize(cross(up, toVector));\n    vec3 bitangent = cross(toVector, tangent);\n\t\n    return tangent * vector.x + bitangent * vector.z + toVector * vector.y;\n}\n\nvec3 rotateAlongY(const float angle, const vec3 vector)\n{\n    mat3 rotM;\n    float cosa = cos(angle);\n    float sina = sin(angle);\n    rotM[0] = vec3(cosa, 0., -sina);\n\n    rotM[1] = vec3(0., 1., 0.);\n\n    rotM[2] = vec3(sina, 0., cosa);\n                    \n    return rotM*vector;\n}\n\nfloat isShadowed(const vec2 pixelPos, vec3 toLight)\n{ \n    toLight.y += heightCoef - texture(iChannel0, pixelPos).x*heightCoef;\n    float alignFactor = dot(vec3(0.,1.,0.), normalize(toLight));\n    const float minNumSteps = 32.;\n    const float maxNumSteps = 64.;\n    uint numSteps = uint(mix(maxNumSteps, minNumSteps, abs(alignFactor)));\n    vec3 stepRay = toLight/float(numSteps)*((heightCoef - heightCoef*texture(iChannel0, pixelPos).x)/toLight.y); //no sense to check it over 0\n    \n    vec3 ray = stepRay;\n    ray.y -= heightCoef - texture(iChannel0, pixelPos).x*heightCoef;\n    for (uint i = 0u; i < numSteps; ++i)\n    {\n        float currHeight = heightCoef*texture(iChannel0, pixelPos+ray.xz).x - heightCoef;\n        if (currHeight > ray.y)\n            return 1.;\n        ray += stepRay;\n    }    \n    \n    return 0.;\n}\n\nfloat getSelfShadow(const vec2 texCoord, const vec3 lightPos, const vec3 pixelPosition, const vec2 fragCoord)\n{\n    float shadowMultiplier = 1.;\n    for (uint i = 0u; i < 16u; ++i)\n    {       \n        vec3 noisedLightApprx = rotateAlongY(lightApprxNoise[int(fragCoord.x)%2 + 2*int(fragCoord.y)%2],  lightApprx[i]);\n        vec3 lightPoint = orientToVector(normalize(vec3(-1.,0.,0.)), noisedLightApprx*lightSourceRadius);\n        shadowMultiplier -= isShadowed(texCoord, lightPos + lightPoint - pixelPosition)/16.;        \n    }\n    \n    return shadowMultiplier;\n}\n\nvec3 lightPosition = vec3(0.,0.,0.);\n\nvec3 animateLightPoint();\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lightPosition = vec3(iMouse.x/iResolution.y, 1.0f, iMouse.y/iResolution.y);\n    if (iMouse.x == 0.)\n    {\n        lightPosition = animateLightPoint();\n    }\n    vec2 uv = fragCoord/iResolution.y*2.;   \n    vec3 pixelPosition = vec3(fragCoord.x/iResolution.y, 0., fragCoord.y/iResolution.y);\n    float shadowMultiplier = getSelfShadow(uv, lightPosition, pixelPosition, fragCoord);\n    fragColor = vec4(shadowMultiplier, 0., 0., 0.);\n}\n\nvec3 animateLightPoint()\n{\n    float xzFragCoordToWorld = heightCoef/iResolution.y;\n    vec3 pointPos1 = vec3(0.);\n    pointPos1.y = 1.;\n    float modulo = mod(iTime, 2.*PI);\n    pointPos1.x = ((cos(modulo + PI/2.) + 1.)/2.*0.8 + 0.1);\n    pointPos1.z = ((sin(modulo + PI/2.) + 1.)/2.*0.8 + 0.1);\n\n    vec3 pointPos2 = vec3(0.);\n    pointPos2.y = 1.;\n    modulo = mod(iTime, 2.*PI);\n    pointPos2.x = ((cos(-modulo - PI/2.) + 1.)/2.*0.8 + 0.1 + iResolution.x/iResolution.y - 1.);\n    pointPos2.z = ((sin(-modulo - PI/2.) + 1.)/2.*0.8 + 0.1);\n    \n    vec3 pointPos = vec3(0.);\n    pointPos = mix(pointPos1, pointPos2, (cos(mod(iTime, 2.*PI) + PI/2.)+1.)/2.);\n    \n    return pointPos;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}