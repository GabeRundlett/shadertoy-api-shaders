{
    "Shader": {
        "info": {
            "date": "1614291388",
            "description": "Evo32 SMNCA: Selective Multiple Neighbourhood Cellular Automata by Slackermanz\nPattern variant created through manual searching and variation with evolutionary functions\nhttps://www.reddit.com/user/slackermanz/\nhttps://www.reddit.com/r/cellular_automata\n",
            "flags": 32,
            "hasliked": 0,
            "id": "tlGBW1",
            "likes": 67,
            "name": "Evo32 SMNCA - Slackermanz",
            "published": 3,
            "tags": [
                "2d",
                "simulation",
                "diffusion",
                "automata",
                "life",
                "chaos",
                "cellular",
                "conway",
                "gameoflife",
                "cellularautomata",
                "cellularautomata",
                "cgol"
            ],
            "usePreview": 0,
            "username": "SlackermanzCA",
            "viewed": 2296
        },
        "renderpass": [
            {
                "code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tNAME:Evo32 Selective MNCA\n//\tTYPE:Selective Multiple Neighbourhood Cellular Automata\n//\tRULE:Pattern coordinates hardcoded into 'demo' array\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tSpecification: SlackCA_Specification_2021_02_23:\n//\t\thttps://mega.nz/file/yRliVDJT#6CUlcGma4DpfXI4S8j0VoUi8Vju0vwRXwVI4klyiNXg\n//\tAdapted for Shadertoy. FPS compared to the C++/Vulkan application is about 20% of maximum\n//\n//\tText file containing other pattern coordinates:\n//\t\thttps://mega.nz/file/uY0GjSjJ#-TvjklejZBh3O5DfqtLXFtjZaoVetqHPgotdYLH5xoQ\n//\tVisualisation of a small subset of rules recorded by Softology:\n//\t\thttps://www.youtube.com/watch?v=LtdKNso0DwE\n//\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\nprecision highp int;\nprecision highp float;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 bufA = texture(iChannel0, uv);\n\n    // Output to screen\n    fragColor = bufA;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tNAME:Evo32 Selective MNCA\n//\tTYPE:Selective Multiple Neighbourhood Cellular Automata\n//\tRULE:Pattern coordinates hardcoded into 'demo' array\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tSpecification: SlackCA_Specification_2021_02_23:\n//\t\thttps://mega.nz/file/yRliVDJT#6CUlcGma4DpfXI4S8j0VoUi8Vju0vwRXwVI4klyiNXg\n//\tAdapted for Shadertoy. FPS compared to the C++/Vulkan application is about 20% of maximum\n//\n//\tText file containing other pattern coordinates:\n//\t\thttps://mega.nz/file/uY0GjSjJ#-TvjklejZBh3O5DfqtLXFtjZaoVetqHPgotdYLH5xoQ\n//\tVisualisation of a small subset of rules recorded by Softology:\n//\t\thttps://www.youtube.com/watch?v=LtdKNso0DwE\n//\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define tex0_in (iChannel0)\n#define tex_size (iResolution.xy)\n\nprecision highp int;\nprecision highp float;\n\nfloat gdv(float x, float y, int v, float div) {\n//\tGet Div Value: Return the value of a specified pixel\n//\t\tx, y : \tRelative integer-spaced coordinates to origin [ 0.0, 0.0 ]\n//\t\tv\t :\tColour channel [ 0, 1, 2 ]\n//\t\tdiv\t :\tInteger-spaced number of toroidal divisions of the surface/medium\n\tvec4\tfc \t\t= gl_FragCoord;\n\tvec2 \tdm \t\t= vec2(iResolution.x, iResolution.y);\n    float \tdivx\t= dm[0] / div;\n\tfloat \tdivy\t= dm[1] / div;\n\tfloat \tpxo \t= 1.0 / dm[0];\n\tfloat \tpyo \t= 1.0 / dm[1];\n\tfloat \tfcxo \t= fc[0] + x;\n\tfloat \tfcyo \t= fc[1] + y;\n\tfloat \tfcx \t= (mod(fcxo,divx) + floor(fc[0]/divx)*divx ) * pxo;\n\tfloat \tfcy \t= (mod(fcyo,divy) + floor(fc[1]/divy)*divy ) * pyo;\n    vec4 \tpxdata \t= texture( tex0_in, vec2(fcx, fcy) );\n\treturn pxdata[v];\n}\n\nvec3 nhd( vec2 nbhd, vec2 ofst, float psn, float thr, int col, float div ) {\n//\tNeighbourhood: Return information about the specified group of pixels\n\tfloat dist \t\t= 0.0;\n\tfloat cval \t\t= 0.0;\n\tfloat c_total \t= 0.0;\n\tfloat c_valid \t= 0.0;\n\tfloat c_value \t= 0.0;\n\tfor(float i = -nbhd[0]; i <= nbhd[0]; i += 1.0) {\n\t\tfor(float j = -nbhd[0]; j <= nbhd[0]; j += 1.0) {\n\t\t\tdist = round(sqrt(i*i+j*j));\n\t\t\tif( dist <= nbhd[0] && dist > nbhd[1] && dist != 0.0 ) {\n\t\t\t\tcval = gdv(i+ofst[0],j+ofst[1],col,div);\n\t\t\t\tc_total += psn;\n\t\t\t\tif( cval > thr ) {\n\t\t\t\t\tc_valid += psn;\n\t\t\t\t\tcval = psn * cval;\n\t\t\t\t\tc_value += cval-fract(cval); } } } } \n\treturn vec3( c_value, c_valid, c_total );\n}\n\nfloat get_xc(float x, float y, float xmod) {\n//\tUsed to reseed the surface with noise\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0);\n}\nfloat shuffle(float x, float y, float xmod, float val) {\n//\tUsed to reseed the surface with noise\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val));\n}\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n//\tUsed to reseed the surface with noise\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc);\n}\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n//\tUsed to reseed the surface with noise\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf;\n}\nfloat reseed() {\n//\tUsed to reseed the surface with noise\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1], 2.0, 19.0 + mod(iDate[3],17.0), 23.0 + mod(iDate[3],43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 24.0, 13.0 + mod(iDate[3],29.0), 17.0 + mod(iDate[3],31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1], 8.0, 13.0 + mod(iDate[3],11.0), 51.0 + mod(iDate[3],37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tInitilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\t\t\tvec4\tfc \t\t= gl_FragCoord;\t\t\t\t\t\t\t// \tFrag Coords\n\t\t\tvec2 \tdm \t\t= vec2(iResolution.x, iResolution.y);\t//\tSurface Dimensions\n\tconst \tint \tVMX \t= 32;\t\t\t\t\t\t\t\t\t//\tEvolution Variables\n\t\t\tfloat \tpsn\t\t= 250.0;\t\t\t\t\t\t\t\t//\tPrecision\n\t\t\tfloat \tmnp\t\t= 0.004;\t\t\t\t\t\t\t\t//\tMinimum Precision Value : (1.0 / psn);\n\t\t\tfloat\tdiv\t\t= 2.0;\t\t\t\t\t\t\t\t\t//\tToroidal Surface Divisions\n\t\t\tfloat \tdivi \t= floor((fc[0]*div)/(dm[0]))\t\t\n\t\t\t\t\t\t\t+ floor((fc[1]*div)/(dm[1]))*div;\t\t//\tDivision Index\n\tfloat \tdspace  = (divi+1.0)/(div*div);\n\t\t\tdspace  = (div == 1.0) ? 1.0 : dspace;\t\t\t\t\t//\tDivision Weight\n\tvec3 \tcol \t= vec3( 0.0, 0.0, 0.0 );\t\t\t\t\t\t//\tFinal colour value output container\n\n//\tPattern coordinates hardcoded for demonstration purposes\n//\tText file containing other pattern coordinates:\n//\t\thttps://mega.nz/file/uY0GjSjJ#-TvjklejZBh3O5DfqtLXFtjZaoVetqHPgotdYLH5xoQ\n\tfloat[VMX] \tdemo_0 \t= float[VMX]\n\t(\t0.264000,\t0.293000,\t0.156000,\t0.287000,\t\n\t\t0.411000,\t0.305000,\t0.200000,\t0.093000,\t\n\t\t0.467000,\t0.345000,\t0.127000,\t-0.016000,\t\n\t\t-0.108000,\t0.079000,\t0.098000,\t0.370000,\t\n\t\t0.209000,\t0.030000,\t0.222000,\t0.144000,\t\n\t\t0.187000,\t0.199000,\t0.294000,\t0.194000,\t\n\t\t0.277000,\t0.170000,\t0.178000,\t0.007000,\t\n\t\t0.261000,\t0.335000,\t-0.093000,\t0.138000\t);\n        \n\tfloat[VMX] \tdemo_1 \t= float[VMX]\n\t(\t0.352000,\t0.236000,\t0.313000,\t0.197000,\t\n\t\t0.140000,\t0.443000,\t0.252000,\t0.394000,\t\n\t\t0.450000,\t0.567000,\t0.233000,\t0.387000,\t\n\t\t0.273000,\t0.489000,\t0.190000,\t0.374000,\t\n\t\t0.215000,\t0.241000,\t0.264000,\t0.387000,\t\n\t\t0.308000,\t0.373000,\t0.263000,\t0.499000,\t\n\t\t0.225000,\t0.252000,\t0.168000,\t0.344000,\t\n\t\t0.179000,\t0.324000,\t0.391000,\t0.327000\t);\n        \n\tfloat[VMX] \tdemo_2 \t= float[VMX]\n\t(\t0.534000,\t-0.129000,\t0.041000,\t0.683000,\t\n\t\t0.228000,\t0.562000,\t-0.097000,\t0.340000,\t\n\t\t-0.043000,\t0.209000,\t-0.136000,\t0.746000,\t\n\t\t0.663000,\t0.222000,\t0.768000,\t0.299000,\t\n\t\t0.354000,\t0.449000,\t0.172000,\t0.263000,\t\n\t\t0.074000,\t0.760000,\t-0.020000,\t0.060000,\t\n\t\t0.133000,\t0.198000,\t0.200000,\t0.516000,\t\n\t\t0.320000,\t0.429000,\t0.378000,\t0.710000\t);\n        \n\tfloat[VMX] \tdemo_3 \t= float[VMX]\n\t(\t0.378000,\t0.228000,\t0.196000,\t-0.046000,\t\n\t\t0.156000,\t-0.055000,\t0.017000,\t0.055000,\t\n\t\t0.065000,\t0.255000,\t0.115000,\t0.395000,\t\n\t\t-0.041000,\t0.029000,\t0.000000,\t0.125000,\t\n\t\t0.352000,\t0.346000,\t0.178000,\t0.305000,\t\n\t\t0.020000,\t0.237000,\t0.397000,\t0.311000,\t\n\t\t0.215000,\t0.048000,\t0.344000,\t-0.009000,\t\n\t\t0.359000,\t0.244000,\t0.022000,\t0.174000\t);\n\n//\tDivision Weighted V number\n\tfloat[VMX] \tdvmd;\n    if(divi == 0.0) {\n\t\tfor(int i = 0; i < VMX; i++) { dvmd[i] = demo_0[i]; } }\n    if(divi == 1.0) {\n\t\tfor(int i = 0; i < VMX; i++) { dvmd[i] = demo_1[i]; } }\n    if(divi == 2.0) {\n\t\tfor(int i = 0; i < VMX; i++) { dvmd[i] = demo_2[i]; } }\n    if(divi == 3.0) {\n\t\tfor(int i = 0; i < VMX; i++) { dvmd[i] = demo_3[i]; } }\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tRULE:Evo32 Selective MNCA\n//\tTYPE:Selective Multiple Neighbourhood Cellular Automata\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tRule Initilisation\n\n//\tGet the reference frame's origin pixel values\n\tfloat\tres_r\t= gdv( 0.0, 0.0, 0, div );\n\tfloat\tres_g\t= gdv( 0.0, 0.0, 1, div );\n\tfloat\tres_b\t= gdv( 0.0, 0.0, 2, div );\n\n//\tIntended rate of change\n\tfloat \ts \t\t= mnp * 12.0;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tSTAGE:MNCA\n//\t\tDOMAIN: \tTotalistic Multiple Neighbourhood Continuous\n//\t\tREQUIRES:\tConditional Range\n//\t\tUPDATE:\t\tAdditive\n//\t\tVALUE:\t\tOrigin\n//\t\tBLUR:\t\tRelative\n//\t\tRESULT:\t\tMultiple\n\n//\tNumber of Individual Neighbourhoods\n\tconst \tint \t\tnhds\t= 8;\n//\tContainer for Neighbourhood Totalistic values\n\t\t\tfloat[nhds] nhdt;\n\n//\tNumber of MNCA Groups\n\tconst \tint \t\tsets\t= 4;\n//\tContainer for STAGE:MNCA results\n\t\t\tfloat[sets] rslt;\n\t\t\t\t\t\trslt[0] = res_r;\n\t\t\t\t\t\trslt[1] = res_r;\n\t\t\t\t\t\trslt[2] = res_r;\n\t\t\t\t\t\trslt[3] = res_r;\n\n//\tDefine and assess the Individual Neighbourhoods\n\tvec3 \tn00r \t= nhd( vec2( 1.0, \t0.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, div );\n\tvec3 \tn01r \t= nhd( vec2( 3.0, \t0.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, div );\n\tvec3 \tn10r \t= nhd( vec2( 2.0, \t0.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, div );\n\tvec3 \tn11r \t= nhd( vec2( 5.0, \t3.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, div );\n\tvec3 \tn20r \t= nhd( vec2( 5.0, \t2.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, div );\n\tvec3 \tn21r \t= nhd( vec2( 9.0, \t7.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, div );\n\tvec3 \tn30r \t= nhd( vec2( 4.0, \t2.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, div );\n\tvec3 \tn31r \t= nhd( vec2( 12.0, \t9.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, div );\n\n//\tGet the Totalistic value of each Individual Neighbourhood\n\tnhdt[0] = n00r[0] / n00r[2];\n\tnhdt[1] = n01r[0] / n01r[2];\n\tnhdt[2] = n10r[0] / n10r[2];\n\tnhdt[3] = n11r[0] / n11r[2];\n\tnhdt[4] = n20r[0] / n20r[2];\n\tnhdt[5] = n21r[0] / n21r[2];\n\tnhdt[6] = n30r[0] / n30r[2];\n\tnhdt[7] = n31r[0] / n31r[2];\n    \n\n//\tUPDATE:Additive the VALUE:Origin according to REQUIRES:Conditional Range\n\tif(\tnhdt[0] >= dvmd[0] \t&& nhdt[0] <= dvmd[1] \t) { rslt[0] += s; }\n\tif(\tnhdt[0] >= dvmd[2] \t&& nhdt[0] <= dvmd[3] \t) { rslt[0] -= s; }\n\tif( nhdt[1] >= dvmd[4] \t&& nhdt[1] <= dvmd[5] \t) { rslt[0] += s; }\n\tif( nhdt[1] >= dvmd[6] \t&& nhdt[1] <= dvmd[7] \t) { rslt[0] -= s; }\n\n\tif( nhdt[2] >= dvmd[8] \t&& nhdt[2] <= dvmd[9] \t) { rslt[1] += s; }\n\tif( nhdt[2] >= dvmd[10] && nhdt[2] <= dvmd[11] \t) { rslt[1] -= s; }\n\tif( nhdt[3] >= dvmd[12] && nhdt[3] <= dvmd[13] \t) { rslt[1] += s; }\n\tif( nhdt[3] >= dvmd[14] && nhdt[3] <= dvmd[15] \t) { rslt[1] -= s; }\n\n\tif(\tnhdt[4] >= dvmd[16] && nhdt[4] <= dvmd[17] \t) { rslt[2] += s; }\n\tif(\tnhdt[4] >= dvmd[18] && nhdt[4] <= dvmd[19] \t) { rslt[2] -= s; }\n\tif( nhdt[5] >= dvmd[20] && nhdt[5] <= dvmd[21] \t) { rslt[2] += s; }\n\tif( nhdt[5] >= dvmd[22] && nhdt[5] <= dvmd[23] \t) { rslt[2] -= s; }\n\n\tif( nhdt[6] >= dvmd[24] && nhdt[6] <= dvmd[25] \t) { rslt[3] += s; }\n\tif( nhdt[6] >= dvmd[26] && nhdt[6] <= dvmd[27] \t) { rslt[3] -= s; }\n\tif( nhdt[7] >= dvmd[28] && nhdt[7] <= dvmd[29] \t) { rslt[3] += s; }\n\tif( nhdt[7] >= dvmd[30] && nhdt[7] <= dvmd[31] \t) { rslt[3] -= s; }\n\n//\tApply a BLUR:Relative to the result\n\trslt[0] = (rslt[0] + nhdt[0] * s * 0.5 + nhdt[1] * s * 0.5) / (1.0 + s * 1.0 );\n\trslt[1] = (rslt[1] + nhdt[2] * s * 0.5 + nhdt[3] * s * 0.5) / (1.0 + s * 1.0 );\n\trslt[2] = (rslt[2] + nhdt[4] * s * 0.5 + nhdt[5] * s * 0.5) / (1.0 + s * 1.0 );\n\trslt[3] = (rslt[3] + nhdt[6] * s * 0.5 + nhdt[7] * s * 0.5) / (1.0 + s * 1.0 );\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tSTAGE:Variance\n//\t\tDOMAIN: \tMNCA\n//\t\tREQUIRES:\tUnconditional\n//\t\tUPDATE:\t\tSubtract\n//\t\tVALUE:\t\tOrigin\n//\t\tBLUR:\t\tSpecific\n//\t\tRESULT:\t\tMultiple\n\n//\tContainer for STAGE:Variance results\n\tfloat[sets] variance;\n\n//\tUPDATE:Subtract the REQUIRES:Previous value\n\tfor(int i = 0; i < sets; i++) { \n\t\t{ variance[i] = res_r - rslt[i]; } }\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tSTAGE:Output\n//\t\tDOMAIN: \tMNCA, Variance\n//\t\tREQUIRES:\tMaximumABS_Match\n//\t\tUPDATE:\t\tSelect\n//\t\tVALUE:\t\tDomain[0]\n//\t\tBLUR:\t\tSpecific\n//\t\tRESULT:\t\tSingle\n\n//\tIndex of an element in DOMAIN:Variance\n\tint von = 0;\n\n//\tGet the index of the element in DOMAIN:Variance that meets REQUIRES:MaximumABS_Match\n\tfor( int i = 0; i < sets; i++ ) { if( abs(variance[von]) < abs(variance[i]) ) { von = i; } }\n\n//\tUPDATE:Select the DOMAIN:MNCA value with the REQUIRES:MaximumABS_Match index\n\tfloat maxvar = rslt[von];\n\n//\tOutput that value\n\tres_r = maxvar;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tPresentation Filtering\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\tvec3 \tn0g \t= nhd( vec2( 1.0, 0.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 1, div );\n\tvec3 \tn0b \t= nhd( vec2( 2.0, 0.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 2, div );\n\tfloat \tn0gw \t= n0g[0] / n0g[2];\n\tfloat \tn0bw \t= n0b[0] / n0b[2];\n\tres_g = ( res_g + n0gw * s * 2.0 + res_r * s * 2.0 ) / (1.0 + s * 4.0);\n\tres_b = ( res_b + n0bw * s * 1.0 + res_r * s * 1.0 ) / (1.0 + s * 2.0);\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tFragment Shader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n    \n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 32.0) { res_r = mod(float(iFrame),2.0); }\n    if (iFrame == 0) { res_r = reseed(); }\n    fragColor=vec4(clamp(res_r,0.0,1.0),clamp(res_g,0.0,1.0),clamp(res_b,0.0,1.0),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}