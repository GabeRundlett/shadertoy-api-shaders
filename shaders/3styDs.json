{
    "Shader": {
        "info": {
            "date": "1602031230",
            "description": "This is a template I created for my future raymarching projects. You can use it if you want but I would suggest getting familiarized with the raymarching algorithm if you aren't already.",
            "flags": 0,
            "hasliked": 0,
            "id": "3styDs",
            "likes": 14,
            "name": "Raymarcher Template",
            "published": 3,
            "tags": [
                "template",
                "raymarcher"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 923
        },
        "renderpass": [
            {
                "code": "/*\nBased on Michael Walczyk's blog on raymarching at https://michaelwalczyk.com/blog-ray-marching.html\n\nThe MIT License\nCopyright Â© 2020 Elijah Bevers\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and\nassociated documentation files (the \"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the\nfollowing conditions: The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY\nKIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\nPARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR\nANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nUpdate information:\n* Future updates:\n\n\n* Added features (in order):\n  - Original version\n  - Added new SDFs for plane and torus\n  - Added a background variable\n  - Added individual shape coloring\n  - Added structures to allow CSG operators to work alongside coloring\n  - Put the surface shading code into a seperate function\n  - Fixed plane SDF\n  - Added clamping of colors to prevent weird issues\n  - Added shadows\n  - Simplified plane SDF\n  - Added antialiasing\n  - Added cone SDF\n  - Added soft shadows\n  - Added a sky function\n  - Added fog\n*/\n\n// Post process settings:\nvec2 antialiasing = vec2(1.0, 1.0); // Set to 2x2 if your computer is fast enough.\n\n// Light settings:\nvec3 lightDirection = vec3(-0.58, 0.58, 0.58);\nvec3 lightEmissionColor = vec3(1.0, 1.0, 1.0);\nvec3 lightColor = vec3(1.0, 0.9, 0.7);\nfloat lightPower = 2.0;\n\n// Soft shadows:\nfloat shadowSoftness = 5.0;\n\n// Fog:\nvec3 fogColor = vec3(0.25, 0.25, 0.6);\nfloat fogginess = 0.0001;\n\n// Camera settings:\nvec3 cameraPosition = vec3(0.0, 300.0, 1100.0);\nvec3 cameraRight = vec3(1.0, 0.0, 0.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraForward = vec3(0.0, 0.0, -1.0);\nfloat cameraFocalLength = 400.0;\n\n// User interaction settings:\nfloat tiltSpeed = 3.0;\n\n// Ray marching constants:\nconst vec3 GRADIENT_STEP = vec3(0.001, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 2000.0;\nconst float MIN_HIT_DISTANCE = 0.005;\nconst float SHADOW_BIAS = MIN_HIT_DISTANCE * 2.0;\nconst int MAX_STEPS = 500;\n\n// Raymarching structures:\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Surface {\n    vec3 ambientColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float shininess;\n    float signedDistance;\n};\n\n// Signed Distance Functions (SDFs):\nfloat sdPlane(in vec3 p, in vec3 n) {\n    return dot(n, p);\n}\n\n// sdCuboid(), sdCone(), and sdCylinder() are taken from Inigo Quilez's 3D distance functions article (https://iquilezles.org/articles/distfunctions):\nfloat sdCuboid(in vec3 p, in float h, in float w, in float d) {\n    vec3 q = abs(p) - 0.5 * vec3(w, h, d);\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCone(in vec3 p, in float b, in float h) {\n    p.y -= h;\n    vec2 q = h * vec2(b / h * 2.0, -2.0);\n    \n    vec2 w = vec2( length(p.xz), p.y );\n    vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n    vec2 c = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n    float k = sign(q.y);\n    float d = min(dot(a, a), dot(c, c));\n    float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n    return sqrt(d) * sign(s);\n}\n\nfloat sdCylinder(in vec3 p, in float h, in float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, 0.5 * h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus(in vec3 p, in float r1, in float r2) {\n    return length(vec2(length(p.xz) - r1, p.y)) - r2;\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// Constructive Solid Geometry (CSG) Operators:\nSurface Union(in Surface surface1, in Surface surface2) {\n    Surface surfaceUnion = surface1;\n    if (surface2.signedDistance < surfaceUnion.signedDistance) {\n        surfaceUnion = surface2;\n    }\n\n    return surfaceUnion;\n}\n\nSurface Intersection(in Surface surface1, in Surface surface2) {\n    Surface surfaceIntersection = surface1;\n    if (surface2.signedDistance > surfaceIntersection.signedDistance) {\n        surfaceIntersection = surface2;\n    }\n\n    return surfaceIntersection;\n}\n\nSurface Difference(in Surface surface1, in Surface surface2) {\n    return Intersection(surface1, Surface(surface2.ambientColor,\n                                          surface2.diffuseColor,\n                                          surface2.specularColor,\n                                          surface2.shininess,\n                                          -surface2.signedDistance));\n}\n\n// Transformations:\nvec3 Translate(in vec3 p, in vec3 t) {\n    return p - t;\n}\n\nvec3 Rotate(in vec3 p, in vec3 r) {\n    vec3 rad = radians(-r);\n    vec3 cosRad = cos(rad);\n    vec3 sinRad = sin(rad);\n\n    mat3 xRotation = mat3(1.0,      0.0,       0.0,\n                          0.0, cosRad.x, -sinRad.x,\n                          0.0, sinRad.x,  cosRad.x);\n\n    mat3 yRotation = mat3( cosRad.y, 0.0, sinRad.y,\n                                0.0, 1.0,      0.0,\n                          -sinRad.y, 0.0, cosRad.y);\n\n    mat3 zRotation = mat3(cosRad.z, -sinRad.z, 0.0,\n                          sinRad.z,  cosRad.z, 0.0,\n                               0.0,       0.0, 1.0);\n\n    return zRotation * yRotation * xRotation * p;\n}\n\nvec3 Scale(in vec3 p, in vec3 s) {\n    return p / s;\n}\n\n// Scene mapping function:\nSurface mapScene(in vec3 p) {\n    Surface plane = Surface(vec3(0.0, 0.0, 0.0),\n                            vec3(mod(dot(floor(p.xz / 100.0), vec2(1.0)), 2.0) * 1.25),\n                            vec3(0.0, 0.0, 0.0), 0.0,\n                            sdPlane(Translate(p, vec3(0.0, -75.0, 0.0)), vec3(0.0, 1.0, 0.0)));\n\n    Surface cuboid = Surface(vec3(0.0, 0.0, 0.0),\n                            vec3(1.0, 0.6, 0.0),\n                            vec3(1.0, 0.4, 0.0), 1.0,\n                            sdCuboid(Translate(p, vec3(-300.0, -12.5, -300.0)), 125.0, 250.0, 200.0));\n\n    Surface cone = Surface(vec3(0.0, 0.0, 0.0),\n                            vec3(1.0, 1.0, 0.0),\n                            vec3(1.0, 1.0, 1.0), 8.0,\n                            sdCone(Translate(p, vec3(0.0, 25.0, -300.0)), 50.0, 100.0));\n\n    Surface cylinder = Surface(vec3(0.0, 0.0, 0.0),\n                            vec3(0.0, 1.0, 0.0),\n                            vec3(0.0, 0.0, 0.0), 0.0,\n                            sdCylinder(Translate(p, vec3(300.0, 0.0, -300.0)), 150.0, 50.0));\n\n    Surface torus = Surface(vec3(0.0, 0.0, 0.0),\n                            vec3(0.0, 0.0, 1.0),\n                            vec3(1.0, 1.0, 1.0), 8.0,\n                            sdTorus(Translate(p, vec3(-150.0, -35.0, 100.0)), 100.0, 40.0));\n\n    Surface sphere = Surface(vec3(0.0, 0.0, 0.0),\n                            vec3(1.0, 0.0, 0.0),\n                            vec3(1.0, 1.0, 1.0), 8.0,\n                            sdSphere(Translate(p, vec3(150.0, 0.0, 100.0)), 75.0));\n\n    return Union(plane, Union(cuboid, Union(cone, Union(cylinder, Union(torus, sphere)))));\n}\n\n// Normal calculation function (using gradient):\nvec3 calculateNormal(in vec3 p) {\n    float gradientX = mapScene(p + GRADIENT_STEP.xyy).signedDistance - mapScene(p - GRADIENT_STEP.xyy).signedDistance;\n    float gradientY = mapScene(p + GRADIENT_STEP.yxy).signedDistance - mapScene(p - GRADIENT_STEP.yxy).signedDistance;\n    float gradientZ = mapScene(p + GRADIENT_STEP.yyx).signedDistance - mapScene(p - GRADIENT_STEP.yyx).signedDistance;\n    return normalize(vec3(gradientX, gradientY, gradientZ));\n}\n\n// Sky mapping function:\nvec3 mapSky(in Ray ray) {\n    return mix(vec3(1.0), vec3(0.25, 0.25, 1.0), 0.5 + 0.5 * ray.direction.y);\n}\n\n// Fog function:\nvec3 applyFog(in vec3 shade, in Ray ray, in float rayDistance) {\n    float lightAmount = max(0.0, dot(ray.direction, lightDirection));\n    vec3 fog = mix(fogColor, lightColor, pow(lightAmount, lightPower));\n    float fogAmount = 1.0 - exp(-rayDistance * fogginess);\n    return mix(shade, fog, fogAmount);\n}\n\n// Shadow mapping function:\nfloat mapShadow(in vec3 p, in vec3 normal, in float softness) {\n    float softShadow = 1.0;\n    p += normal * SHADOW_BIAS;\n    float shadowDistance = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; iterations++) {\n        vec3 shadowTestPosition = p + lightDirection * shadowDistance;\n        Surface occluderSurface = mapScene(shadowTestPosition);\n        if (abs(occluderSurface.signedDistance) < MIN_HIT_DISTANCE) {\n            return 0.0;\n        }\n\n        if (shadowDistance > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        shadowDistance += occluderSurface.signedDistance;\n        softShadow = min(softShadow, softness * occluderSurface.signedDistance / shadowDistance);\n    }\n\n    return softShadow;\n}\n\n// Surface shader (uses the Phong illumination model):\nvec3 shadeSurface(in Surface surface, in vec3 hitPosition, in Ray ray, in vec3 normal) {\n    vec3 illuminationAmbient = surface.ambientColor * lightEmissionColor;\n\n    float lambertian = max(0.0, dot(normal, lightDirection));\n    vec3 illuminationDiffuse = lambertian * surface.diffuseColor * lightEmissionColor;\n\n    vec3 reflection = reflect(lightDirection, normal);\n    float specularAngle = max(0.0, dot(reflection, ray.direction));\n    vec3 illuminationSpecular = clamp(pow(specularAngle, surface.shininess), 0.0, 1.0) * surface.specularColor * lightEmissionColor;\n\n    return illuminationAmbient + (illuminationDiffuse + illuminationSpecular) * mapShadow(hitPosition, normal, shadowSoftness);\n}\n\n// Raymarching loop:\nvec4 rayMarch(in Ray ray) {\n    float distanceTraveled = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; iterations++) {\n        vec3 currentPosition = ray.origin + ray.direction * distanceTraveled;\n        Surface sceneSurface = mapScene(currentPosition);\n        if (abs(sceneSurface.signedDistance) < MIN_HIT_DISTANCE) {\n            vec3 normal = calculateNormal(currentPosition);\n            vec3 color = shadeSurface(sceneSurface, currentPosition, ray, normal);\n            color = applyFog(color, ray, distanceTraveled);\n            return vec4(color, 1.0);\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        distanceTraveled += sceneSurface.signedDistance;\n    }\n\n    return vec4(mapSky(ray), 1.0);\n}\n\n// Pixel shader output function:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    cameraPosition = Rotate(cameraPosition, vec3(0.0, -iTime * 20.0, 0.0));\n    float tilt = iMouse.y - screenCenter.y;\n    if (iMouse.z > 0.0) cameraPosition.y += tilt * tiltSpeed;\n\n    cameraForward = -normalize(cameraPosition);\n    cameraRight = normalize(vec3(-cameraForward.z, 0.0, cameraForward.x));\n    cameraUp = cross(cameraRight, cameraForward);\n\n    for (float yOffset=0.0; yOffset < antialiasing.y; yOffset++) {\n        for (float xOffset=0.0; xOffset < antialiasing.x; xOffset++) {\n            vec2 pixel = fragCoord + vec2(xOffset, yOffset) / antialiasing - screenCenter;\n            vec3 rayOrigin = cameraPosition + cameraForward * cameraFocalLength;\n            vec3 rayDirection = normalize(rayOrigin - (cameraPosition - cameraRight * pixel.x - cameraUp * pixel.y));\n            fragColor += rayMarch(Ray(rayOrigin, rayDirection));\n        }\n    }\n\n    fragColor /= antialiasing.y * antialiasing.x;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}