{
    "Shader": {
        "info": {
            "date": "1572998484",
            "description": "Raymarching Operator for few basic shapes",
            "flags": 0,
            "hasliked": 0,
            "id": "tscXDf",
            "likes": 1,
            "name": "Raymarching Operator",
            "published": 3,
            "tags": [
                "raymarchingoperator"
            ],
            "usePreview": 0,
            "username": "zrcoy",
            "viewed": 618
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define SURF_DIST .01\n#define MAX_DIST 100.\n#define PI 3.14159265359\n\nfloat DToRad(float d)//degree to radian\n{\n \t return d /180.f * PI  ;\n}\n\nmat2 Rot(float angle)\n{\n \tfloat s = sin(angle);\n    float c= cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin(float a, float b , float k)\n{\n \tfloat h = clamp(.5 + .5*(b -a)/k, 0., 1.);\n    return mix(b,a,h) - k*h*(1.f - h);\n}\n\nfloat Sphere(vec3 p, float r)\n{\n \treturn length(p) - r;   \n}\n\nfloat Torus(vec3 p, float r1, float r2)//r1 bigger radius\n{\n    float x = length(p.xz) - r1;\n    float y = p.y;\n    float d = length(vec2(x,y));\n    return d - r2;\n}\n\nfloat Capsule(vec3 p, vec3 a, vec3 b, float r, vec3 pos)\n{\n    p-=pos;\n \tvec3 ab = b-a;\n    vec3 ap = p-a;\n    float ratio = clamp((dot(ap, ab) / dot(ab,ab)), 0., 1.);\n    \n    vec3 PointC = a + ab * ratio;\n    return length(PointC - p)-r;\n}\n\n\nfloat Cylinder(vec3 p, vec3 a, vec3 b, float r, vec3 pos)\n{\n    p-=pos;\n \tvec3 ab = b-a;\n    vec3 ap = p-a;\n    float t = dot(ap, ab) / dot(ab,ab);    \n    vec3 PointC = a + ab * t;\n    float d = length(PointC - p)-r;\n    float y = abs(t-.5f) - .5f;// make the dist on y range from infinite...0...-0.5...0...infinite \n\tfloat e = length(max(vec2(d,y),0.));\n    float i = min(max(d,y),0.);\n    return e+i;\n}\n\nfloat Link( in vec3 p, in float le, in float r1, in float r2 ,vec3 pos )\n{\n    p-=pos;\n    vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n    return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat Box(vec3 p, float side)\n{\n    float dx = max(abs(p.x) - side,0.);\n    float dy = max(abs(p.y) - side,0.);\n    float dz = max(abs(p.z) - side,0.);\n    return length(vec3(dx,dy,dz));\n}\n\nfloat GetDist(vec3 p)//a simple scene with just a ground plane and a sphere\n{\n    float t = iTime;\n    \n    // ground plane\n    float pd = p.y;\n    \n    // rotating box & sphere transformation\n    vec3 bp = p ;\n    bp -= vec3(0,.75,3);\t\t// translation\n    bp.xz *= Rot(iTime);\t\t// rotation\n    float dsBox = Box(bp, 1.f);\n    float dsSphere = Sphere(bp,1.8f);\n    vec3 sp_B = p;\n    sp_B -= vec3(0, 2.75f,3);\n    sp_B.y -= 2.f*(sin(iTime * .5f));\n    float dsSp_Blend = Sphere(sp_B,.8f);\n    \n    \n    \n    //Cylinder\n    \n    vec3 CylinderP = vec3(1.f,1.f,0.f);\n    CylinderP.xz+=vec2(sin(iTime)*5.f, cos(iTime)*5.f);//move\n    CylinderP.xz *= Rot(iTime*1.5f);\n    float dsCylinder = Cylinder(p, vec3(0,2,0),vec3(3,2,0),.2f, CylinderP);\n    float dsCylinder2 = Cylinder(p, vec3(1.5f,2,-1.5f),vec3(1.5f,2,1.5f),.2f, CylinderP);\n    float dsCylinder3 = Cylinder(p, vec3(1.5f,2.f+1.5f,0),vec3(1.5f,2.f-1.5f,0),.2f, CylinderP);\n    dsCylinder = mix(dsCylinder, dsCylinder2, abs(sin(iTime)));\n    dsCylinder = smin(dsCylinder, dsCylinder3,.3);\n    \n    \n    //Sphere substraction\n    vec3 Sp1 = vec3(-2.f, 1.f, -2.f);\n    Sp1 = p-Sp1;//translate    \n    Sp1.y -= abs(sin(iTime));//jump\n    Sp1.xz +=vec2(sin(iTime), cos(iTime));   \n    vec3 Sp2 = vec3(-1.f, 1.f, -2.f);\n    Sp2 = p-Sp2;   \n    Sp2.y -= abs(sin(iTime));\n    Sp2.x += .4f*sin(iTime);    \n    float dsSp = Sphere(Sp1, 1.f);\n    float dsSp2 = Sphere(Sp2, .8f);\n    dsSp = max(-dsSp2,dsSp);\n    dsSp = smin(dsSp,dsCylinder,.3f);\n    \n    \n    //Torus\n    \n    vec3 torusP = p;\n    torusP -= vec3(3.f + sin(iTime) * 5.f,1.f,(-2.f) + cos(iTime)*5.f);\n    torusP.y -= abs(sin(iTime)) * 3.f;//translate\n    torusP *= vec3(1.f + abs(sin(iTime)),1,1);//scale\n    torusP.yz *= Rot(DToRad(90.f));//rotate\n    \n    float dsTorus = Torus(torusP, 1.f,.25f);\n      \n    \n    \n    \n    //final dist calculation\n    float d;\n    d = mix(dsBox, dsSphere, abs(sin(iTime)));\n    d = smin(d,dsSp_Blend,.4f);\n    d = min(d, pd);\n    d = min(d, dsCylinder);\n    d = min(d, dsSp);\n    d = min(d,dsTorus/2.f);\n    \n    return d;\n}\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat RayMarching(vec3 ro, vec3 rd)\n{\n    float dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = abs( GetDist(p) );\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\n\nfloat GetLight(vec3 p, vec3 lightPos) {\n    \n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.f;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l),0. , 1.);\n    float shadowR = RayMarching(p + n * SURF_DIST * 2., l);\n    if(shadowR < length(p -  lightPos))\n        dif *= .1f;\n    return dif;\n}\n\nvec3 Ray(vec2 uv, vec3 ro, vec3 lookat, float dToScreen)//lookat camera\n{\n    vec3 f = normalize(lookat - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),f));\n    vec3 up = normalize(cross(f, right));\n    vec3 center = ro + f * dToScreen; \n    vec3 intersectP = center + uv.x * right + uv.y * up;\n    return normalize(intersectP - ro);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n     vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -10);\n    ro.yz *= Rot(-m.y+.7f);\n    ro.xz *= Rot(m.x*2.f *PI);\n    \n    \n    vec3 rd = Ray(uv, ro, vec3(0,0,0), .7);\n\n    float d = RayMarching(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 light1 = vec3(0, 10, 2);\n\n    \tfloat dif = GetLight(p, light1);\n\n    \tcol = vec3(dif);\n    }\n    \n    fragColor = vec4(col,1.0);\n   \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}