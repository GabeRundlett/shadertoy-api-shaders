{
    "Shader": {
        "info": {
            "date": "1719850647",
            "description": "Cloud globe",
            "flags": 32,
            "hasliked": 0,
            "id": "lXVXRz",
            "likes": 1,
            "name": "Cloud globe",
            "published": 3,
            "tags": [
                "cloudglobe"
            ],
            "usePreview": 0,
            "username": "NoxWings",
            "viewed": 39
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    fragColor = ACESFilm(fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#ifndef __COMMON_BASIC_GLSL__\n#define __COMMON_BASIC_GLSL__\n\n#define S(x, y, z) smoothstep(x, y, z)\n#define A(v1,v2,t1,t2) mix(v1,v2,S(t1,t2,iTime))\n\nconst float PI = 3.14159;\nconst float HALF_PI = PI * 0.5;\nconst float TAU = PI * 2.0;\nconst float DEG2RAD = TAU/360.0;\n\nfloat invLerp(float a, float b, float x) {\n    x = clamp(x, a, b);\n    return (x - a) / (b - a);\n}\n\nmat3 lookAtMatrix(in vec3 lookAtDirection) {\n\tvec3 ww = normalize(lookAtDirection);\n    vec3 uu = cross(ww, vec3(0.0, 1.0, 0.0));\n    vec3 vv = cross(uu, ww);\n    return mat3(uu, vv, -ww);\n}\n\nstruct Camera {\n    vec3 position;\n\tvec3 direction;\n};\n\nCamera createOrbitCamera(vec2 uv, vec2 mouse, vec2 resolution, float fov, vec3 target, float height, float distanceToTarget)\n{\n    vec2 r = mouse / resolution * vec2(3.0 * PI, 0.5 * PI);\n    float halfFov = fov * 0.5;\n    float zoom = cos(halfFov) / sin(halfFov);\n\n    vec3 position = target + vec3(sin(r.x), 0.0, cos(r.x)) * distanceToTarget + vec3(0, height, 0);\n    vec3 direction = normalize(vec3(uv, -zoom));\n    direction = lookAtMatrix(target - position) * direction;\n\n    return Camera(position, direction);\n}\n\nmat2 rot2d(float a) {\n    float ca = cos(a), sa = sin(a);\n    return mat2(ca, sa, -sa, ca);\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 100000.5453);\n}\n\nfloat hash12(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\n#endif // __COMMON_BASIC_GLSL__\n#ifndef __COMMON_COLORS_GLSL__\n#define __COMMON_COLORS_GLSL__\n\nvec4 linearTosRGB(vec4 linearRGB)\n{\n    bvec4 cutoff = lessThan(linearRGB, vec4(0.0031308));\n    vec4 higher = vec4(1.055)*pow(linearRGB, vec4(1.0/2.4)) - vec4(0.055);\n    vec4 lower = linearRGB * vec4(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\nvec4 sRGBToLinear(vec4 sRGB)\n{\n    bvec4 cutoff = lessThan(sRGB, vec4(0.04045));\n    vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n    vec4 lower = sRGB/vec4(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\nvec4 ACESFilm(vec4 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), vec4(0), vec4(1));\n}\n\n\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat sdSphere(vec3 p, float s) {\n  return length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPrism(vec3 p, float tall, vec2 topSize, vec2 botSize) {\n    vec3 top = vec3(topSize.x, tall, topSize.y);\n    vec3 bot = vec3(botSize.x, tall, botSize.y);\n\n    float q = (p.y+tall)*.5/tall;\n    vec3 shape = mix(bot, top, q);\n\n    return sdBox(p, shape);\n}\n\n#endif // __COMMON_DIST_FUNCTIONS_GLSL__\n\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\nvoid initRandomGenerator(vec2 res, int frame, vec2 fragCoord){\n    seed = uint(fragCoord.y*res.x + fragCoord.x)+uint(frame)*uint(res.x)*uint(res.y);\n}\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define JITTER_SECONDARY_RAYS 1\n#define LOBE_G1 0.5\n#define LOBE_G2 -0.1\n#define USE_SPHERE_TRACING 1\n#define MAX_VOLUME_DENSITY 0.3\n\n#define SUN_STRENGTH 3.0\n#define AMBIENT_STRENGTH 10.0\n\n#define VOLUME_ABSORPTION 0.2\n#define VOLUME_SCATTERING 0.5\n\nstruct Sample {\n    int id;\n    float dist; // means distance from ray to hit (<= surfHit usually)\n};\n\n// ***********************************************************************\n// *************************** SCENE *************************************\n// ***********************************************************************\n\nSample map(vec3 p) {\n    Sample ball = Sample(1, sdSphere(p - vec3(0,1.0,0), 20.0));\n    Sample result = ball;\n    return result;\n}\n\n// ***********************************************************************\n// *************************** END SCENE *********************************\n// ***********************************************************************\n\nvec3 mapNormal(vec3 p, float surfHit) {\n    vec2 e = vec2(surfHit, 0);\n    float d = map(p).dist;\n\n    return normalize(vec3(\n        d - map(p - e.xyy).dist,\n        d - map(p - e.yxy).dist,\n        d - map(p - e.yyx).dist\n    ));\n}\n\nstruct VolumetricTrace {\n    float transmission;\n    vec3 col;\n};\n\n\nstruct VolumeSample {\n    float dist;\n    float density;\n    float absorption;\n    float scattering;\n};\n\nfloat volumeSample(vec3 p) {\n    return texture(iChannel0, p).r * 2.0 - 1.0;\n}\n\nVolumeSample sampleVolume(vec3 p) {\n    float dist = map(p).dist;\n    if (dist > 0.0) {\n        return VolumeSample(dist, 0.0, 0.0, 0.0);\n    };\n    \n    // fine sampling 1\n    float density = volumeSample(p * 0.005) * 5.0;\n    \n    float coarseFbm = volumeSample(p * 0.025) * 1.0;\n    \n    float fbm = coarseFbm;\n    fbm += volumeSample(p * 0.2/ 4. + vec3(iTime, 0, iTime) * .02) * 0.4;\n    fbm += volumeSample(p * 0.4/ 4. + vec3(iTime, 0, iTime) * .04) * 0.4;\n    fbm += volumeSample(p * 0.8/ 4.) * 0.1;\n    fbm += volumeSample(p * 1.6/ 4.) * 0.2;\n    \n    density = density - fbm;\n    \n    // ensure density range\n    float coarseDensity = density - coarseFbm;    \n    density = clamp(density, 0.0, MAX_VOLUME_DENSITY);\n    \n    // fade out ball edges\n    density = density * min(abs(dist) * 1., 1.0);\n    \n    float absorption = VOLUME_ABSORPTION;\n    float scattering = VOLUME_SCATTERING;\n    return VolumeSample(dist, density, absorption, scattering);\n}\n\nvec3 mapVolumeNormal(vec3 p, float surfHit) {\n    vec2 e = vec2(surfHit, 0);\n    float d = sampleVolume(p).density;\n\n    return normalize(vec3(\n        d - sampleVolume(p - e.xyy).density,\n        d - sampleVolume(p - e.yxy).density,\n        d - sampleVolume(p - e.yyx).density\n    ));\n}\n\n\nfloat secondaryLightTrace(vec3 ro, vec3 rd) {\n    float maxDistance = 40.0;\n    int maxSteps = 20;\n    float stepSize = maxDistance / float(maxSteps);\n    \n    float startingD = stepSize * 0.5;\n    #if JITTER_SECONDARY_RAYS == 1\n    startingD = random() * stepSize;\n    #endif\n    \n    float T = 1.0;\n    for (float d = startingD; d < maxDistance; d += stepSize) {\n        vec3 p = ro + rd * d;\n        \n        VolumeSample volume = sampleVolume(p);\n        if (volume.dist > 0.0) {\n            break;\n        }\n        \n        float transmission = exp(-stepSize * volume.density * (volume.absorption + volume.scattering));\n        T *= transmission;\n    }\n    \n    return T;\n}\n\nfloat henyeyGreensteinPhase(float g, float cosTheta) {\n    float denom = 1.0 + g * g - 2.0 * g * cosTheta;\n    return 1.0 / (4.0 * PI) * (1.0 - g * g) / (denom * sqrt(denom));\n}\n\n// Volume marching\nVolumetricTrace traceVolume(vec3 ro, vec3 rd, float maxDistance, int maxSteps, vec2 fragCoord) {\n    VolumetricTrace res = VolumetricTrace(1.0, vec3(0));\n\n    vec3 lightColor = vec3(13.0, 13.0, 13.0) * SUN_STRENGTH;\n    vec3 lightDirection = normalize(vec3(-1.0, 0.3, 0.0));\n    float ambientStrength = AMBIENT_STRENGTH;\n\n    vec3 backgroundColor = vec3(0.45, 0.9, 2.) * 1.;\n    backgroundColor = texture(iChannel2, rd).rgb;\n    \n    // fake sun\n    backgroundColor = mix(backgroundColor, lightColor, max(0.00001, pow(dot(lightDirection, rd), 1000.0)));\n    \n    float volumeStepSize = 1.0;\n    float g1 = LOBE_G1;\n    float g2 = LOBE_G2;\n    \n    vec3 lighting = vec3(0);\n   \n    vec3 rand = texelFetch(iChannel1, ivec2(mod(fragCoord, iChannelResolution[1].xy)), 0).rgb;\n   \n    float d = 0.0;\n    int i;\n    for (i = 0; i < maxSteps && d <= maxDistance; i++) {\n        vec3 p = ro + rd * d;\n        Sample h = map(p);\n    \n        #if USE_SPHERE_TRACING == 1\n        // if we are out of the shape, sphere marching\n        if (h.dist > 0.0) {\n            d += max(h.dist, 0.01); // min step of 0.01\n        }\n        // otherwise, fixed steps volume marching\n        else {\n        #endif\n            float randomValue = rand.x;\n        \n            vec3 samplePoint = p + rd * volumeStepSize * randomValue;\n            VolumeSample volume = sampleVolume(samplePoint);\n            float transmission = exp(-volumeStepSize * volume.density * (volume.absorption + volume.scattering));\n            res.transmission *= transmission;\n            \n            // <directional>\n            float lightTransmission = secondaryLightTrace(samplePoint, lightDirection);\n            float cosTheta = dot(rd, lightDirection);\n            float phase1 = henyeyGreensteinPhase(g1, cosTheta);\n            float phase2 = henyeyGreensteinPhase(g2, cosTheta);\n            \n            float integratedInScattering = lightTransmission \n                * volume.density \n                * volume.scattering \n                * res.transmission \n                * volumeStepSize;\n            \n            integratedInScattering = mix(integratedInScattering * phase1, integratedInScattering * phase2, 0.5);\n            \n            lighting += integratedInScattering * lightColor;\n            // </directional>\n            \n            // <ambient>\n            float ambientScattering = pow(1.0 - volume.density, 0.5)\n                * volume.density \n                * volume.scattering \n                * res.transmission \n                * volumeStepSize;\n\n            vec3 ambientRd = mapNormal(samplePoint, 0.01);\n            float ambientCosTheta = dot(rd, ambientRd);\n            ambientScattering = ambientScattering * henyeyGreensteinPhase(-0.2, cosTheta);\n            lighting += ambientScattering * ambientStrength * textureLod(iChannel2, ambientRd, 10.0).rgb;\n            // </ambient>\n            \n            if (res.transmission <= 0.01) {\n                res.transmission = 0.0;\n                break;\n            }\n            \n            d += volumeStepSize;\n        #if USE_SPHERE_TRACING == 1\n        }\n        #endif\n    }\n    \n    res.col = lighting + res.transmission * backgroundColor;\n    // show if we are bound by steps\n    if (i >=maxSteps) { res.col = vec3(1,0,1); }\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    initRandomGenerator(iResolution.xy, iFrame, fragCoord);\n    \n    vec2 fakeScreen = uv * 2.0 - 1.0;\n    fakeScreen.x *= iResolution.x / iResolution.y;\n\n\n    vec2 rotation = vec2(iResolution.x * 0.03, 0);\n    rotation.x += iResolution.x * iTime * 0.01;\n\n    Camera cam = createOrbitCamera(\n        fakeScreen,\n        iMouse.xy + rotation,\n        iResolution.xy,\n        60.0 * DEG2RAD,\n        vec3(0,1.0,0),  // target,\n        0.0,            // height,\n        35.0            // distanceToTarget,\n    );\n    \n    int primarySteps = 256;\n    float farPlane = 100.0;\n    float surfHit = 0.01;\n    VolumetricTrace traceRes = traceVolume(cam.position, cam.direction, farPlane, primarySteps, fragCoord);\n    \n    fragColor = vec4(traceRes.col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Main image\nconst float VOLUME_BLUR_DIRECTIONS = 8.0;\nconst float VOLUME_BLUR_SIZE = 0.0025;\nconst float VOLUME_BLUR_QUALITY = 2.0;\n\n\nvec4 sampleBlur(\n    sampler2D tex, \n    vec2 res, \n    vec2 pos, \n    float directions, \n    float quality, \n    float size\n) {\n    vec2 radius = size / res.xy;\n    vec2 uv = pos / res.xy;\n    \n    vec4 color = texture(tex, uv);\n    \n    float directionStep = TAU/directions;\n    float qualityStep = 1.0/quality;\n    \n    float importance = 1.0;\n    \n    for(float arc = 0.0; arc < TAU; arc += directionStep)\n    for(float q = 1.0; q > 0.0; q -= qualityStep) {\n        vec2 offset = vec2(cos(arc),sin(arc)) * q * radius * res.y;\n        vec2 cuv = uv + offset;\n        \n        // Avoid sampling outside the edges\n        if (\n            cuv.x < 0.0 ||\n            cuv.y < 0.0 ||\n            cuv.x > res.x ||\n            cuv.y > res.y\n        ) {\n            continue;\n        }\n        \n        vec4 fog = texture(tex, cuv);\n        float spatialImportance = 1.0 + (1.0 - q); // linear fallof\n        float sampleImportance = spatialImportance;\n        importance += sampleImportance;\n        color += texture(tex, cuv) * sampleImportance;\n    }\n    \n    return color / importance;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec4 prev = texture(iChannel1, uv);\n    \n    // Main scene\n    vec4 col = sampleBlur(\n        iChannel0, \n        iResolution.xy, \n        fragCoord, \n        VOLUME_BLUR_DIRECTIONS, \n        VOLUME_BLUR_QUALITY, \n        VOLUME_BLUR_SIZE\n    );\n       \n    fragColor = mix(col, prev, 0.3);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec3 col = 0.5 + vec3(-0.35, 0.2, 0.8) * vec3(-rayDir.x, clamp(rayDir.y, 0.0, 1.0), abs(rayDir.z)) ;\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}