{
    "Shader": {
        "info": {
            "date": "1451026555",
            "description": "Just got a new phone, so now that my phone can load basic shaders without slowing to 15fps, I'm just writing this shader to test out different kinds of raymarchers on it.",
            "flags": 1,
            "hasliked": 0,
            "id": "MdtGzj",
            "likes": 4,
            "name": "iPhone Shader Test",
            "published": 3,
            "tags": [
                "raymarcher",
                "iphone"
            ],
            "usePreview": 0,
            "username": "jackdavenport",
            "viewed": 757
        },
        "renderpass": [
            {
                "code": "#define MAX_ITERATIONS 256\n#define MAX_ITERATIONS_S 128\n#define MIN_DISTANCE .001\n\nstruct Ray { vec3 ori; vec3 dir; };\nstruct Dst { float dst; int id;  };\nstruct Hit { vec3 p; int id;     };\n\nfloat dSphere(vec3 p, vec3 pos, float radius) {\n\n    return length(pos - p) - radius;\n    \n}\n\nfloat dFloor(vec3 p, float y) {\n \n    return p.y - y;\n    \n}\n\nDst distScene(vec3 p) {\n \n    float flor = dFloor(p, -1.);\n    float sph1 = dSphere(p, vec3(sin(iTime), 0., 0.), 1.);\n    \n    float dst = min(flor,sph1);\n    return Dst(dst, dst == sph1 ? 0 : 1);\n    \n}\n\nHit raymarch(Ray ray, bool secondary) {\n\n    vec3 p = ray.ori;\n    int id = -1;\n    \n    for(int i = 0; i < MAX_ITERATIONS_S; i++) {\n     \n        Dst scn = distScene(p);\n        p += ray.dir * scn.dst;\n        \n        if(scn.dst < MIN_DISTANCE) {\n         \n            id = scn.id;\n            break;\n            \n        }\n        \n    }\n    \n    return Hit(p,id);\n    \n}\n    \nvec3 clearColor(vec3 dir) {\n \n    return texture(iChannel0, dir).xyz;\n    \n}\n\nvec3 getLightDirection(vec3 p) {\n \n    return vec3(1.,1.5,-1.) - p;\n    \n}\n\nvec3 calcNormal(vec3 p) {\n \n    vec2 eps = vec2(.001, .0);\n    vec3 n = vec3(distScene(p + eps.xyy).dst - distScene(p - eps.xyy).dst,\n                  distScene(p + eps.yxy).dst - distScene(p - eps.yxy).dst,\n                  distScene(p + eps.yyx).dst - distScene(p - eps.yyx).dst);\n    return normalize(n);\n    \n}\n\nvec3 getDiffuse(Hit hit, vec3 n) {\n \n    const float a = .2;\n    vec3 ld = getLightDirection(hit.p);\n    float d = a + max(dot(normalize(ld),n), 0.);\n    d *= 1. - clamp(length(ld) / 20., 0., 1.);\n    \n    ld = normalize(ld);\n    Ray sr = Ray(hit.p + (ld * .01), ld);\n    Hit sh = raymarch(sr, true);\n    \n    if(sh.id != -1) d = a;\n    return vec3(d);\n    \n}\n\nvec3 shadePlane(Hit scn, Ray ray) {\n    \n    vec3 n = calcNormal(scn.p);\n    vec3 d = getDiffuse(scn, n);\n        \n    return vec3(1.) * d;\n    \n}\n\nvec3 shade(Ray ray) {\n \n    Hit scn = raymarch(ray, false);\n    \n    if(scn.id == 0) {\n     \n        vec3 n = calcNormal(scn.p);\n\t\tvec3 rd = reflect(ray.dir, n);\n        Ray rr = Ray(scn.p + (rd * .01), rd);\n        Hit rh = raymarch(rr, true);\n        \n        if(rh.id == 1) {\n         \n            return shadePlane(rh,rr);\n            \n        }\n        \n        return clearColor(rd);\n        \n    } else if(scn.id == 1) {\n     \n        return shadePlane(scn, ray);\n        \n    }\n    \n    return clearColor(ray.dir);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy / 2.) / iResolution.y;\n    \n    vec3 ori = vec3(0.,0.,-3.);\n    vec3 dir = vec3(uv, 1.);\n    \n    vec3 col = shade(Ray(ori,dir));\n\tfragColor = vec4(col,1.0);\n}\n\nvoid mainVR(out vec4 fc, in vec2 fp, in vec3 ro, in vec3 rd) {\n\tfc = vec4(shade(Ray(ro-vec3(0.,0.,3.),rd)),1.);   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}