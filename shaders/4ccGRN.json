{
    "Shader": {
        "info": {
            "date": "1711446691",
            "description": "包包的测试嘎嘎嘎",
            "flags": 32,
            "hasliked": 0,
            "id": "4ccGRN",
            "likes": 5,
            "name": "BaoFluidDispersion",
            "published": 3,
            "tags": [
                "fluid"
            ],
            "usePreview": 0,
            "username": "SamOrantin",
            "viewed": 243
        },
        "renderpass": [
            {
                "code": "vec3 ThinFilm(float g)\n{\n    vec3 lambda = vec3(612.0f, 535.0f, 465.0f); \n    vec3 omega = g / lambda;\n    vec3 col = vec3(cos(omega * 20000.0f) * 0.5f + 0.5f); \n    col = mix(vec3(0.25f), col, exp(-omega * 1000.0f)); \n    //col.rgb = vec3(col.b);\n    return pow(col, vec3(1.0f / 2.2f));\n}\n\nvec4 ChromaKey(vec3 Color)\n{\n    float sf = max(Color.r, Color.b);\n\tfloat k = clamp((Color.g - sf) * 4.0, 0., 1.);\n\t\n\tif (Color.g > sf) Color = vec3(0.,0.,0.);\n    return vec4(Color.xyz,k);\n    \n}\n\nfloat rgb2gray(vec3 A)\n{\n    return A.r*0.299 + A.g*0.587 + A.b*0.114;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col1 = texture(iChannel0,uv);\n    \n    col1 *= 1.0 - col1.z;\n\n    float gray = rgb2gray(col1.rgb);\n    \n    vec2 finalUV = mix(uv,col1.xy,gray * 0.2);\n    \n    vec4 col = texture(iChannel2,finalUV,gray*8.);\n    \n    col.rgb = vec3(0.4,0.4,0.4) * ThinFilm(gray) * gray + col.rgb * (1.0 - 0.4*gray);\n    \n    fragColor = col1.w * col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define uMseventeen 0.6\n\n#define FlowSpeed 0.6\n#define DispSpeed 0.6\n#define DiffuseAmount 0.5\n#define FlowDir vec2(0.0,0.0)\n#define NoiseSize 0.5\n#define Jitter 0.01\n\n#define RotNum 5\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n#define keyTex iChannel3\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nfloat kp(int k){\n    float kp = texelFetch( iChannel3, ivec2(k,2), 0 ).x;\n    return kp;\n}\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv){\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b){\n    vec2 p = b*(FlowSpeed)*(2.*DiffuseAmount);\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++){\n        rot+=dot(texture(iChannel0,fract((pos+p)*(2.*NoiseSize) /Res.xy)).xy-vec2(0.5), p.yx * (mix(vec2(DispSpeed,DispSpeed), vec2(sin(iTime)*4.,cos(iTime)*4.), FlowSpeed))); // laatste stukje is direction\n        p = m * p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvec4 ChromaKey(vec3 Color)\n{\n    float sf = max(Color.r, Color.b);\n\tfloat k = clamp((Color.g - sf) * 4.0, 0., 1.);\n\t\n\tif (Color.g > sf) Color = vec3(0.,0.,0.);\n    return vec4(Color.xyz,k);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv *= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 col = vec3(0);\n\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*Jitter*rnd)*Jitter,sin(ang*Jitter*rnd)*Jitter);\n    vec2 v = FlowDir; \n    float bbMax=0.7*Res.y;\n    bbMax*=bbMax;\n    for(int l=0;l<30;l++){  \n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++){\n            v+=p.yx*getRot(pos+p,b);\n            p = m*p;\n        }       \n        b*=2.0;\n    }\n   \n    vec4 SourceColor = texture(iChannel2,fragCoord.xy/Res.xy);\n    \n    SourceColor = ChromaKey(SourceColor.xyz);\n    \n    vec4 vel = texture(iChannel1,0.03*(fragCoord-.5*iResolution.xy)/iResolution.y);\n    \n    vec4 fcol = mix(texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy)),vel, 1.0 - SourceColor.w);\n    \n    fcol = mix(fcol, vec4(0.0,0.0,0.0,1.0),0.002);\n    \n    fcol.z = 1.0 - SourceColor.w;\n    \n    fcol.w = SourceColor.w;\n    \n    vec4 debug = vec4(1.0,1.0,1.0,1.0);\n    \n    fragColor = fcol;\n\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec3 hash(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0*fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// from https://www.shadertoy.com/view/Xsl3Dl\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n\n\n\nvec2 speed(vec2 uv)\n{\n    float ratio = iResolution.y/iResolution.x;\n    uv = uv*10.*vec2(1., ratio);\n#if 1 // random velocity field\n    return 1.5*vec2(noise(vec3(uv, iTime*0.5)), noise(vec3(uv + vec2(12.10135, 1354.2435), iTime*0.5)));\n\n#else // test: uniform rotation\n    uv -= 5.*vec2(1., ratio); return .3*SPEED_AM*vec2(-uv.y,uv.x);\n#endif    \n}\n\n\nvoid mainImage( out vec4 O, vec2 C )\n{\n\tO.xy = speed(C/iResolution.xy);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}