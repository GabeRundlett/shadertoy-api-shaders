{
    "Shader": {
        "info": {
            "date": "1723472158",
            "description": "Heavily inspired by [this shader](https://www.shadertoy.com/view/Wdj3zm) and [this video](https://youtu.be/makaJpLvbow), but with totally different physics\nAlso mouse enabled!",
            "flags": 32,
            "hasliked": 0,
            "id": "MfffzN",
            "likes": 16,
            "name": "Cell-Forming Particles! :D",
            "published": 3,
            "tags": [
                "2d",
                "simulation",
                "particles",
                "life",
                "multipass"
            ],
            "usePreview": 1,
            "username": "Ebanflo",
            "viewed": 214
        },
        "renderpass": [
            {
                "code": "// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n// Copyright © 2024 Eben Kadile\n\n/*\nThe basic idea is that particles are attracted or\nrepelled from other particle types at different ranges\nvia a super simple scattering physics defined in Buffer A.\nKinetic energy is conserved, momentum is not.\nSystem parameters can be fiddled with in Common.\nAny decent gaming PC can probably handle 2X as many particles at 800x450\n*/\n\n\nconst mat4x4 palette = mat4x4(0.3, 0.7, 0.2, 1.0,\n                              0.0, 0.7, 0.5, 1.0,\n                              0.4, 0.2, 0.9, 1.0,\n                              0.8, 0.2, 0.5, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float dist = 1e6;\n    int atom_id = 0;\n\n    for(int i = 0; i < TOT_ATOMS; i++) {\n        vec4 atom = get_atom(iChannel0, i);\n    \tvec2 offs = fragCoord - atom.xy*iResolution.y;\n        float dsqr = dot(offs, offs);\n\n        if(dsqr < dist) {\n            dist = dsqr;\n            atom_id = i;\n        }\n    }\n\n    int atom_type = get_atom_type(atom_id);\n    fragColor = palette[atom_type] * smoothstep(2.0, 1.5, sqrt(dist));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n// Copyright © 2024 Eben Kadile\n\n#define PI 4.0*atan(1.0)\n#define MOUSE iMouse.xy/iResolution.y\n#define MOUSE_RADIUS 0.3\n\n#define N_ATOMS_0 1024\n#define N_ATOMS_1 1024\n#define N_ATOMS_2 1024\n#define N_ATOMS_3 1024\n#define TOT_ATOMS N_ATOMS_0 + N_ATOMS_1 + N_ATOMS_2 + N_ATOMS_3\n//#define LOW_ENTROPY_INIT\n\nint get_atom_type(int i) {\n    return 3 - int(i < N_ATOMS_0)\n             - int(i < N_ATOMS_0 + N_ATOMS_1)\n             - int(i < N_ATOMS_0 + N_ATOMS_1 + N_ATOMS_2);\n}\n\nconst vec4 close_radii = vec4(0.05, 0.02, 0.05, 0.05);\n#define close (close_radii*close_radii)\nconst vec4 far_radii = vec4(0.15, 0.3, 0.15, 0.15);\n#define far (far_radii*far_radii)\n// same sign attractive, opposite sign repulsive\nconst vec4 close_potential = vec4(2.0, 2.0, 1.0, 0.5);\nconst vec4 far_potential = -vec4(2.0, 4.0, 0.5, 0.5);\nconst mat4x4 coupling_matrix = mat4x4(-1e3, 1e2, 1e2, -1e4,\n                                      1e4, 1e3, 1e2, 1e2,\n                                      1e2, 1e2, -1e3, 1e2,\n                                      -1e4, 1e2, 1e2, -1e3);\nconst float max_init_speed = 0.003;\nconst float min_init_speed = 0.0003;\n\nfloat potential(int t, float d2) {\n    return step(0.0, far[t] - d2)\n          *(far_potential[t]*step(close[t], d2)\n          + close_potential[t]*step(0.0, close[t] - d2));\n}\n\nbool in_range(float d2) {\n    return d2 < max(far[0],\n                    max(far_radii[1],\n                    max(far_radii[2], far_radii[3])));\n}\n\nvec4 get_atom(sampler2D buf, int id) {\n    ivec2 res = textureSize(buf, 0);\n\tivec2 uv = ivec2(\n        (id/4)%res.x,\n        id%4 + 4*((id/4)/res.x)\n    );\n\n    return texelFetch(buf, uv, 0);\n}\n\n\nvec2 perp(vec2 v) {\n    return vec2(-v.y,v.x);\n}\n\nvec2 wrap(vec2 v, vec2 size) {\n\treturn mod(v + size/2.0, size) - size/2.0;\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 expi(float t) {\n    return vec2(cos(t), sin(t));\n}\n\nvec2 rotate(vec2 x, float t) {\n    return cmul(x, expi(t));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n// Copyright © 2024 Eben Kadile\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 res = iResolution.xy/iResolution.y;\n\n    ivec2 pixel = ivec2(fragCoord.xy);\n    int pixel_id = pixel.y%4 + 4*pixel.x + 4*int(iResolution.x)*(pixel.y/4);\n    vec4 pixel_atom = get_atom(iChannel0, pixel_id);\n    int pixel_type = get_atom_type(pixel_id);\n    vec2 pixel_velocity = pixel_atom.zw;\n    \n    float total_turn = 0.0;\n    \n    if(pixel_id < TOT_ATOMS) {\n        if(iFrame < 10) {\n            vec4 rnd = get_atom(iChannel1, pixel_id);\n            \n            #ifdef LOW_ENTROPY_INIT\n            pixel_atom.xy = vec2(0.2 + 0.7*float(pixel_id%3), 0.2 + 0.3*float(pixel_id%3));\n            pixel_atom.xy += 0.3*rnd.xy - 0.1;\n            #else\n            pixel_atom.xy = rnd.xy*res;\n            #endif\n\n            pixel_velocity = 2.0*max_init_speed*(rnd.zw - 0.5);\n            if(length(pixel_velocity) < min_init_speed) {\n                pixel_velocity = vec2(min_init_speed, 0.0);\n            }\n        } else if(iMouse.z < 1e-4 || distance(pixel_atom.xy, MOUSE) > MOUSE_RADIUS) {\n            for(int i = 0; i < TOT_ATOMS; i++) {\n                vec4 i_atom = get_atom(iChannel0, i);\n                vec2 dir = pixel_atom.xy - i_atom.xy;\n                dir = wrap(dir, res);\n                float d2 = dot(dir, dir);\n\n                int i_type = get_atom_type(i);\n\n                // - for left, + for right\n                float side = sign(dot(pixel_velocity, perp(dir)));\n//*\n                total_turn += float(i != pixel_id)\n                             *side\n                             *coupling_matrix[pixel_type][i_type]\n                             *potential(pixel_type, d2)\n                             *potential(i_type, d2)\n                             *length(pixel_velocity)\n                             *length(i_atom.zw);\n                total_turn = clamp(total_turn, -0.5*PI, 0.5*PI);\n//*/\n            }\n        }\n        pixel_velocity = rotate(pixel_velocity, total_turn);\n        pixel_atom.zw = pixel_velocity;\n        pixel_atom.xy += pixel_velocity;\n        pixel_atom.xy = mod(pixel_atom.xy, res);\n        fragColor = pixel_atom;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}