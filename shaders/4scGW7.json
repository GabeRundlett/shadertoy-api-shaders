{
    "Shader": {
        "info": {
            "date": "1449913353",
            "description": "Understanding raymarching via iq's nice article: https://iquilezles.org/articles/terrainmarching/terrainmarching.htm",
            "flags": 0,
            "hasliked": 0,
            "id": "4scGW7",
            "likes": 3,
            "name": "RollingHillsXP",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "nslottow",
            "viewed": 873
        },
        "renderpass": [
            {
                "code": "\nfloat f(float x, float z)\n{\n    return sin(x + cos(z * 3.0 + iTime * 0.5)) * sin(z + iTime);\n}\n\nbool castRay(vec3 ro, vec3 rd, out float resT)\n{\n    const float mint = 0.001;\n    const float maxt = 20.0;\n    const float dt = 0.08;\n    float lh = 0.0;\n    float ly = 0.0;\n    \n    float t = mint;\n    \n    for (float t = mint; t < maxt; t += dt)\n    {\n        vec3 p = ro + rd * t;\n        float h = f(p.x, p.z);\n        if (p.y < h)\n        {\n            resT = t - dt + dt * (lh - ly) / (p.y - ly - h + lh);\n            return true;\n        }\n        lh = h;\n        ly = p.y;\n    }\n    \n    return false;\n}\n\nvec3 getNormal(vec3 p)\n{\n    const float eps = 0.02;\n    vec3 n = vec3(\n        f(p.x - eps, p.z) - f(p.x + eps, p.z),\n        2.0 * eps,\n        f(p.x, p.z - eps) - f(p.x, p.z + eps));\n    return normalize(n);  \n}\n\nvec3 getShading(vec3 p, vec3 n)\n{\n    return dot(n, vec3(0.0, 1.0, 0.0)) * vec3(0.2, 0.7, 0.2);\n}\n\nvec3 terrainColor(vec3 ro, vec3 rd, float t)\n{\n    vec3 p = ro + rd * t;\n    vec3 n = getNormal(p);\n    vec3 s = getShading(p, n);\n    \n    return s;\n}\n\nvec3 skyColor(vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    return vec3(0.4, 0.6, 0.9 * uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    const float hfov = 45.0 * 0.5 * 3.1415926535 / 180.0;\n    const float tanhfov = tan(hfov);\n    const float near = 0.1;\n    const float far = 1.0;\n    \n    vec2 uv = fragCoord.xy / (iResolution.xy * 0.5) - vec2(1.0, 1.0);\n    float dx = tanhfov * uv.x / aspect;\n    float dy = tanhfov * uv.y;\n    \n    vec3 viewRayDir = normalize(vec3(dx, dy, 1.0) * (far - near));\n    \n    float bob = -0.4 + 0.1 * cos(iTime * 0.5);\n    mat4 inverseViewMatrix = mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, bob, 1.0, 0.0,\n        0.0, 0.0, 0.0, 0.0\n        );\n    \n    const vec3 ro = vec3(0.0, 7.0, 0.0);\n    vec3 rd = (inverseViewMatrix * vec4(viewRayDir, 0.0)).xyz;\n    float resT;\n    \n    if (castRay(ro, rd, resT))\n    {\n        fragColor = vec4(terrainColor(ro, rd, resT), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(skyColor(fragCoord), 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}