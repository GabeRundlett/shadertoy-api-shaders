{
    "Shader": {
        "info": {
            "date": "1363670394",
            "description": "Using rasterization to render a deforming polygonal mesh, in a fragment shader!!! :D",
            "flags": 0,
            "hasliked": 0,
            "id": "4slGzn",
            "likes": 239,
            "name": "Rasterizer - Object",
            "published": 3,
            "tags": [
                "3d",
                "rasterizer",
                "mesh"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 16164
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n\n// A perspective correct triangle rasterizer, in a shader :D\n\n\nmat4 setRotation( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\nmat4 setTranslation( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,     y,   z, 1.0 );\n}\n\nstruct Vertex\n{\n    vec3  pos; \n\tvec2  uv; \n\tfloat occ;\n};\n\n\t\nstruct Triangle\n{\n    Vertex a;\n    Vertex b;\n    Vertex c;\n    vec3 n;\n};\n\n\nvec4 func( in vec2 s )\n{\n\tfloat r = 1.0 + 0.4*sin(20.0*s.x + 6.28318*s.y + iTime );\n\t\n\treturn vec4( r*vec3( sin(3.14159*s.x)*sin(6.28318*s.y),\n\t\t\t             sin(3.14159*s.x)*cos(6.28318*s.y),\n\t\t\t             cos(3.14159*s.x) ), \n                 pow(r*0.8,4.0) );\n}\n\n\nTriangle calcTriangle128( int k )\n{\n    int i = (k>>1)&7;\n    int j = (k>>4)&7;\n        \n    const float du = 1.0/8.0;\n    const float dv = 1.0/8.0;\n        \n    float u = float(i)*du;\n\tfloat v = float(j)*dv;\n    \n\tvec2 aUV = vec2( u,    v    );\n\tvec2 bUV = vec2( u+du, v+dv );\n\tvec2 cUV = vec2( u+du, v    );\n\tvec2 dUV = vec2( u,    v+dv );\n\t\n\tif( (k&1)==1 )\n\t{\n\t\tcUV = bUV; \n\t\tbUV = dUV;\n\t}\n\n\tvec4 a = func( aUV );\n\tvec4 b = func( bUV );\n\tvec4 c = func( cUV );\n\tvec3 n = normalize( cross(b.xyz-a.xyz, c.xyz-a.xyz) );\n\t\n\treturn Triangle( Vertex(a.xyz, 4.0*aUV, a.w), \n\t\t\t\t\t Vertex(b.xyz, 4.0*bUV, b.w), \n\t\t\t\t\t Vertex(c.xyz, 4.0*cUV, c.w), n );\n}\n\nvec3 lig = normalize( vec3( 0.4,0.5,0.3) );\n\nvec3 pixelShader( in vec3 nor, in float oc, in vec2 uv, vec3 di )\n{\n    // perform lighting/shading\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\tvec3 brdf = vec3(0.20,0.20,0.20)*oc + \n                vec3(0.20,0.25,0.30)*oc*(0.6+0.4*nor.y) + \n                vec3(1.00,0.90,0.80)*oc*dif;\n\t\n    float wire = 1.0 - smoothstep( 0.0, 0.03, di.x ) *\n                       smoothstep( 0.0, 0.03, di.y ) *\n                       smoothstep( 0.0, 0.03, di.z );\n\t\n    vec3 material = texture( iChannel0, uv ).xyz;\n\t\n    material += wire * smoothstep(0.0,0.5,sin(3.0+iTime));\n\n    return sqrt( brdf * material );\n}\n\nfloat cross2d( vec2 a, vec2 b )\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 mo = iMouse.xy/iResolution.xy;\n\tmat4 mdv = setTranslation( 0.0, 0.0, -3.0 ) * \n\t\t       setRotation( 0.6-6.0*mo.y, 0.0,  0.6 ) * \n\t\t       setRotation( 0.0, 20.0+0.05*iTime - 6.3*mo.x, 0.0 );\n\t\n    vec2 px = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n\n\n    vec3 color = vec3( 0.5 + 0.1*px.y );\n\n\t// clear zbuffer\n    float mindist = -1000000.0; // negative like in OpenGL\n\n\t// for every triangle\n    for( int i=0; i<128; i++ )\n    {\n\t\t// get the triangle\n\t\tTriangle tri = calcTriangle128( i );\n\n\t\t// transform to eye space\n        vec3 ep0 = (mdv * vec4(tri.a.pos,1.0)).xyz;\n        vec3 ep1 = (mdv * vec4(tri.b.pos,1.0)).xyz;\n        vec3 ep2 = (mdv * vec4(tri.c.pos,1.0)).xyz;\n        vec3 nor = (mdv * vec4(tri.n,0.0)).xyz;\n\n        // transform to NDC space \n        float w0 = 1.0/ep0.z;\n        float w1 = 1.0/ep1.z;\n        float w2 = 1.0/ep2.z;\n\n        vec2 cp0 = 2.0*ep0.xy * -w0;\n        vec2 cp1 = 2.0*ep1.xy * -w1;\n        vec2 cp2 = 2.0*ep2.xy * -w2;\n\t\t\n\t\t//vec2 bboxmin = min( min( cp0, cp1 ), cp2 );\n\t\t//vec2 bboxmax = max( max( cp0, cp1 ), cp2 );\n        //if( px.x>bboxmin.x && px.x<bboxmax.x && px.y>bboxmin.y && px.y<bboxmax.y )\n\t\t{\n\t\t\n        // fetch vertex attributes, and divide by z\n        vec2  u0 = tri.a.uv  * w0;\n        vec2  u1 = tri.b.uv  * w1;\n        vec2  u2 = tri.c.uv  * w2;\n        float a0 = tri.a.occ * w0;\n        float a1 = tri.b.occ * w1;\n        float a2 = tri.c.occ * w2;\n\n        //-----------------------------------\n        // rasterize\n        //-----------------------------------\n\n        // calculate areas for subtriangles\n        vec3 di = vec3( cross2d( cp1 - cp0, px - cp0 ), \n\t\t\t\t\t    cross2d( cp2 - cp1, px - cp1 ), \n\t\t\t\t\t    cross2d( cp0 - cp2, px - cp2 ) );\n\t\t\t\n        // if all positive, point is inside triangle\n        if( all(greaterThan(di,vec3(0.0))) )\n        {\n            // calc barycentric coordinates\n            vec3 ba = di.yzx / (di.x+di.y+di.z);\n\n            // barycentric interpolation of attributes and 1/z\n            float iz = ba.x*w0 + ba.y*w1 + ba.z*w2;\n            vec2  uv = ba.x*u0 + ba.y*u1 + ba.z*u2;\n            float oc = ba.x*a0 + ba.y*a1 + ba.z*a2;\n\n            // recover interpolated z\n\t\t\tfloat z = 1.0/iz;\n\n\t\t\t// depth buffer test\n\t\t\tif( z>mindist )\n\t\t\t{\n                // recover interpolated attributes\n                uv *= z;\n                oc *= z;\n\t\t\t\tmindist = z;\n\n                // run pixel shader\n                color = pixelShader( nor, oc, uv, ba );\n\t\t\t}\n        }\n\t\t}\n    }\n\n\tcolor *= 1.0 - 0.1*dot(px,px);\n    color.y *= 1.03;\n\t\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}