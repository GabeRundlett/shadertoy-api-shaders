{
    "Shader": {
        "info": {
            "date": "1697674913",
            "description": "Exact solution to \"square-halfplane\" coverage, plus some approximations.\nClick on colored circle to select a function.\nHold the mouse button to see a (scaled) plot of the error, rather than of the function itself.\nPlots are for 0째 to 45째 in 5째 intervals.",
            "flags": 0,
            "hasliked": 0,
            "id": "cdcBDX",
            "likes": 13,
            "name": "2D analytical AA",
            "published": 3,
            "tags": [
                "antialiasing",
                "coverage"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 334
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Consider the following problem: \"what fraction of [-1;+1]x[-1;+1] square\n// is covered by A*x+B*y+C>=0 halfplane?\". Assuming, without loss of\n// generality, that A>=B>=0, the exact solution is:\n//     0                   , if C<=-(A+B)\n//     (A+B+C)^2/(8*A*B)   , if -(A+B)<=C<=-(A-B)\n//     0.5+0.5*C/max(A,B)  , if |C|<=(A-B)\n//     1-(A+B-C)^2/(8*A*B) , if +(A-B)<=C<=+(A+B)\n//     1                   , if C>=+(A+B)\n// Note that coverage(A,B,C)=coverage(B,A,C)=coverage(-A,B,C)=coverage(A,-B,C)=1-coverage(A,B,-C).\n//\n// You can use this to approximate anti-aliasing for some SDF-like function.\n// If you know function f() and its derivatives f'x() and f'y() (or can\n// approximate them), then the part of a rectangle (\"pixel\") [x-w/2;x+w/2]*[y-h/2;y+h/2],\n// covered by f(x)<0 can be approximated as the above problem with\n//     A=w*f'x(x,y)\n//     B=h*f'y(x,y)\n//     C=-2*f(x,y)\n//\n// Of course, you are not *required* to do the anti-aliasing this way. E.g using\n// gaussian (i.e. erf) has its appeal (despite infinite support).\n//\n// Accuracy of some approximations (see https://godbolt.org/z/z38xPesd3):\n//   Linf     - infiniy norm (i.e. max. abs. error)\n//   RMS      - root mean square error\n//   Inside   - max. error when wrongly returning {0,1}\n//   Outside  - max. error when wrongly returning (0;1)\n// Note: A, B, C are uniformly distributed in [-1;+1]x[-1;+1]x[-sqrt(2);+sqrt(2)].\n// This affects computed RMS.\n// | Color     | Function            | Linf        | RMS         | Inside      | Outside     |\n// |-----------|---------------------|-------------|-------------|-------------|-------------|\n// | Gray      |cov_exact            |  0.00000000 |  0.00000000 |  0.00000000 |  0.00000000 |\n// |           |cov_msaa< 1>         |  0.49999636 |  0.20408611 |  0.49999636 |  0.00000000 |\n// | Violet    |cov_msaa< 2>         |  0.24952590 |  0.07040552 |  0.24723244 |  0.00000000 |\n// |           |cov_msaa< 4>         |  0.12452590 |  0.02481787 |  0.12280673 |  0.00000000 |\n// |           |cov_msaa< 8>         |  0.06172752 |  0.00875571 |  0.06071138 |  0.00000000 |\n// |           |cov_msaa<16>         |  0.03047752 |  0.00309934 |  0.02749920 |  0.00000000 |\n// |           |cov_msaa<32>         |  0.01511553 |  0.00110750 |  0.01278222 |  0.00000000 |\n// |           |cov_msaa<64>         |  0.00719970 |  0.00038004 |  0.00280529 |  0.00000000 |\n// | Cyan      |cov_step             |  0.49999636 |  0.20408611 |  0.49999636 |  0.00000000 |\n// | Yellow    |cov_lin              |  0.12499946 |  0.06321841 |  0.00000000 |  0.00000000 |\n// | Pink      |cov_smooth           |  0.09602143 |  0.02111146 |  0.00000000 |  0.00000000 |\n// | Blue      |cov_mix              |  0.03703614 |  0.01561240 |  0.00000000 |  0.00000000 |\n// | Green     |cov_sqrt             |  0.04289210 |  0.01701449 |  0.04265356 |  0.00000000 |\n// | Magenta   |cov_smoothsqrt       |  0.03111339 |  0.00881568 |  0.00494635 |  0.03111339 |\n// | Orange    |cov_erf              |  0.04798281 |  0.01579871 |  0.00000000 |  0.04736865 |\n// |           |cov_tanh             |  0.05639169 |  0.02119081 |  0.00000000 |  0.05517477 |\n// |           |cov_atan             |  0.09770226 |  0.05461564 |  0.00000000 |  0.09770226 |\n// | L. blue   |cov_si               |  0.08948976 |  0.04159512 |  0.00000000 |  0.08948976 |\n\n//==============================================================================\n// Some constants and special functions.\n\n#define pi 3.14159265358979\n\n// From Abramowitz and Stegun. Max. abs. error ~5e-4,\n// which is somewhat better than https://www.shadertoy.com/view/7dXXDN\n// which has max. abs. error ~3.6e-3 using B체rmann series.\nfloat erf(float x)\n{\n    float y=abs(x),t=1.0+y*(0.278393+y*(0.230389+y*(0.000972+y*0.078108)));\n    return sign(x)*(1.0-1.0/((t*t)*(t*t)));\n}\n\n// From Abramowitz & Stegun.\n// Max. abs. error ~1e-6.\nfloat Si(float x)\n{\n    // Adapted from https://github.com/GalSim-developers/GalSim/blob/releases/2.5/src/math/Sinc.cpp\n    // NOTE: this is based on #ifdef'd out version.\n    float x2=x*x;\n    if(x2<1.0) return x*(1.0+x2*(-0.0555555556+x2*(0.00166666667+x2*-2.83446712e-05)));\n    return ((pi/2.0)*((x>0.0)?1.0:-1.0)\n        - (38.102495+x2*(335.677320+x2*(265.187033+x2*(38.027264+x2))))\n        / (x*(157.105423+x2*(570.236280+x2*(322.624911+x2*(40.021433+x2)))))*cos(x)\n        - (21.821899+x2*(352.018498+x2*(302.757865+x2*(42.242855+x2))))\n        / (x2*(449.690326+x2*(1114.978885+x2*(482.485984+x2*(48.196927+x2)))))*sin(x));\n}\n\n//==============================================================================\n// Coverage functions.\n\nfloat cov_exact(float A,float B,float C)\n{\n    A=abs(A);B=abs(B);\n    float s=A+B,d=abs(A-B),m=abs(C);\n    if     (m<=d) return 0.5+0.5*C/max(A,B);\n    else if(m>=s) return step(0.0,C);\n    else          return abs(step(0.0,C)-(s-m)*(s-m)/(8.0*A*B));\n}\n\n#define MSAA 2\nfloat cov_msaa(float A,float B,float C)\n{\n    float ret=0.0;\n    for(int i=0;i<MSAA;++i) for(int j=0;j<MSAA;++j)\n    {\n        float x=2.0*(float(i)+0.5)/float(MSAA)-1.0;\n        float y=2.0*(float(j)+0.5)/float(MSAA)-1.0;\n        ret+=step(0.0,A*x+B*y+C);\n    }\n    return ret/float(MSAA*MSAA);\n}\n\nfloat cov_step(float A,float B,float C)\n{\n    return step(0.0,C);\n}\n\nfloat cov_lin(float A,float B,float C)\n{\n    return clamp(0.5*(1.0+C/(abs(A)+abs(B))),0.0,1.0);\n}\n\nfloat cov_smooth(float A,float B,float C)\n{\n    return smoothstep(-1.0,1.0,C/(abs(A)+abs(B)));\n}\n\n// This is mix(smooth,lin,factor).\nfloat cov_mix(float A,float B,float C)\n{\n#if 0\n    // 2-division version.\n    // NOTE: we would need an extra abs, if we were raising\n    // m to an odd power. Powers 2 (which we use), 3, and 4\n    // give about equal accuracy.\n    float s=abs(A)+abs(B),t=clamp(C/s,-1.0,+1.0),m=(abs(A)-abs(B))/s;\n    t*=1.0+0.5*(1.0-t*t)*(1.0-m*m);\n    return 0.5+0.5*t;\n#else\n    // 1-division version.\n    // May overflow/underflow for |A|,|B| outside of [1e-6,1e+6].\n    // May be slightly more accurate near |C|=|A|+|B|.\n    float s=abs(A)+abs(B),s2=s*s,s4=s2*s2,c=clamp(C,-s,+s);\n    return (s+c)*(0.5*s4+c*(s-c)*abs(A*B))/(s4*s);\n#endif\n}\n\nfloat cov_sqrt(float A,float B,float C)\n{\n    return clamp(0.5*(1.0+C/sqrt(A*A+B*B)),0.0,1.0);\n}\n\nfloat cov_smoothsqrt(float A,float B,float C)\n{\n    // NOTE: the factor is (probably) 2/pi in terms\n    // of pixel distance, but since we work in\n    // terms of on 2x2 square ([-1;+1]x[-1;+1]),\n    // it is doubled.\n    float d=4.0/pi;\n    return smoothstep(-d,+d,C/sqrt(A*A+B*B));\n}\n\n// NOTE: tanh and atan are similar to erf,\n// but have worse max. error.\nfloat cov_erf(float A,float B,float C)\n{\n#if 1\n    // Constant numerically tuned to minimize Linf error.\n    return 0.5+0.5*erf(1.1765*C/sqrt(A*A+B*B));\n#else\n    // Linf error is ~7.8% vs ~4.8% for the above version.\n    // NOTE: 0.5+0.5*tanh(sqrt(2.0)*C/sqrt(A*A+B*B)) is ~5.7%.\n    return 0.5+0.5*erf(C/sqrt(A*A+B*B));\n#endif\n}\n\nfloat cov_si(float A,float B,float C)\n{\n    // NOTE: We work in terms of on 2x2 square ([-1;+1]x[-1;+1]),\n    // so the radius is doubled.\n    float R=2.0;\n    float d=C/sqrt(A*A+B*B);\n    return 0.5+Si(pi*d/R)/pi;\n}\n\n//==============================================================================\n// Dispatcher\n\nfloat coverage(float A,float B,float C,int id)\n{\n    switch(id)\n    {\n        case 0: return cov_exact     (A,B,C);\n        case 1: return cov_msaa      (A,B,C);\n        case 2: return cov_step      (A,B,C);\n        case 3: return cov_lin       (A,B,C);\n        case 4: return cov_smooth    (A,B,C);\n        case 5: return cov_mix       (A,B,C);\n        case 6: return cov_sqrt      (A,B,C);\n        case 7: return cov_erf       (A,B,C);\n        case 8: return cov_smoothsqrt(A,B,C);\n        case 9: return cov_si        (A,B,C);\n#define NUM_CASES 10 // Need to update when adding new functions!\n    }\n    return 0.0;\n}\n\n//==============================================================================\n// Helper functions\n\nvec3 linear2srgb(vec3 rgb)\n{\n    return mix(12.92*rgb,1.055*pow(rgb,vec3(1.0/2.4))-0.055,step(0.0031308,rgb));\n}\n\nvec3 palette(int id)\n{\n    return id==0?vec3(0.5):0.5+0.5*cos(8.0*float(id)+vec3(0.0,2.0,4.0));\n}\n\n//==============================================================================\n// Main program\n\n// Returns function in z, and derivatives in xy.\nvec3 f(vec2 d)\n{\n    float l=length(d);\n    float D=2.0,R=16.0;\n    return vec3(\n        2.0*d-2.0*R*normalize(d),\n        (l-(R-0.5*D))*(l-(R+0.5*D)));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    float W=iResolution.x;\n    float H=iResolution.y;\n    float M=max(W-H,0.25*H);\n    float R=10.0;\n    float G=1.0/32.0;\n    float S=8.0;\n    float D=(W-M)/float(NUM_CASES);\n    int id=int(abs(iMouse.x)/D)%NUM_CASES;\n    vec2 uv=fragCoord.xy/H;\n    vec2 xy=(floor(H*(2.0*uv-1.0)/(2.0*S))+0.5);\n    vec2 c=R*vec2(cos(0.73*iTime),sin(0.37*iTime));\n    vec2 d=xy-c;\n    vec3 F=f(d);\n    float A=F.x,B=F.y,C=-2.0*F.z;\n    float a=coverage(A,B,C,id);\n    vec3 color=vec3(a);\n    color.g+=G*step(1.0,mod(xy.x+xy.y,2.0))*exp(-16.0*(S*S/(H*H))*dot(xy,xy));\n    if(uv.x*H<W-M&&uv.y*H<D)\n    {\n        float x=uv.x/((W-M)/H),y=uv.y/(D/H);\n        x*=float(NUM_CASES);\n        int idx=int(x);\n        x=fract(x);\n        vec2 d=D*(2.0*vec2(x,y)-1.0)-c;\n        vec3 F=f(d);\n        float A=F.x,B=F.y,C=-2.0*F.z;\n        float a=coverage(A,B,C,idx);\n        color=mix(color,palette(idx),a);\n        if(id==idx) color=mix(color,palette(idx),exp(-0.25*D*D*x*(1.0-x)*y*(1.0-y)));\n    }\n    if(uv.x*H>W-M)\n    {\n        float angle=(3.14159265358979/4.0)*(floor(10.0*uv.y)/10.0);\n        float A=cos(angle),B=sin(angle);\n        float e=0.1;\n        float x=(H*uv.x-(W-M))/M,y=fract(10.0*uv.y)*(1.0+2.0*e)-e;\n        float h=0.1*H/M;\n        x=(1.0+h)*x-h;\n        if(x>=0.0)\n        {\n            float v0=cov_exact(A,B,sqrt(2.0)*(2.0*x-1.0))-y;\n            float v1=coverage(A,B,sqrt(2.0)*(2.0*x-1.0),id)-y;\n            float v=0.5+5.0*(v1-v0)-y;\n            if(y>=0.0&&y<=1.0) color=mix(color,vec3(0.125),0.75);\n            if(sign(iMouse.z)<0.0)\n                color+=exp(-1e-2*H*H*v1*v1)*palette(id)+exp(-1e-2*H*H*v0*v0)*0.5;\n            else\n                color+=exp(-1e-2*H*H*v*v)*palette(id);\n        }\n        else\n        {\n            x=x/h+1.0;\n            x=(2.0*x-1.0)/(1.0+e);\n            y=2.0*y-1.0;\n            if(abs(x)<1.0&&abs(y)<1.0)\n            {\n                color=mix(color,vec3(0.25+0.5*step(A*x+B*y,0.0)),0.75*exp(-2.0*(x*x+y*y)));\n            }\n        }\n    }\n    color=linear2srgb(color);\n    fragColor=vec4(color,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}