{
    "Shader": {
        "info": {
            "date": "1626474057",
            "description": "* added cylinder and octahedron sdf\n* shadow casting\n* checkerboard 3d texture\n* uv texturing\n* assign materials\n* phong shading",
            "flags": 1,
            "hasliked": 0,
            "id": "slXSzB",
            "likes": 3,
            "name": "Checkerworld",
            "published": 3,
            "tags": [
                "sdf",
                "texture",
                "shadow",
                "light"
            ],
            "usePreview": 0,
            "username": "golinad",
            "viewed": 400
        },
        "renderpass": [
            {
                "code": "// Uncomment for debug rendering\n//#define COMPLEXITY\n//#define ISOLINES\n\nconst float pi = 3.1415926535897932384626433832795;\n\nfloat delta = 0.001;\nfloat maxT = 20.0;\nconst int maxIt = 100;\nvec4 ambientColor = vec4(0.20,0.20,0.3,1.0);\nvec4 lightColor = vec4(1.0,1.0,0.7,1.0);\n\n// Material types\nconst int matDefault = 0;\nconst int matChecker = 1;\nconst int matRed = 2;\nconst int matGreen = 3;\nconst int matUVCyan = 4;\nconst int matUVMagenta = 5;\n\nstruct SpotInfo {\n    float d;\n    vec3 pos;\n    vec2 uv;\n    int m;\n};\n\n// SDF primitives\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\nfloat sdBox(in vec3 p,in vec3 ext) {\n    vec3 q = abs(p) - ext/2.0;\n    return length(max(q,0.0)) + min(max(max(q.x, q.y),q.z),0.0);\n}\nfloat sdTorus(in vec3 p, float r1, float r2) {\n    vec3 c = vec3(normalize(p.xy)*r1, 0.0);\n    return distance(p, c) - r2;\n}\nfloat sdCylinder(in vec3 p, in float r, in float h) {\n    p = abs(p);\n    vec3 q = normalize(vec3(p.x, 0.0, p.z))*r + vec3(0,min(p.y, h/2.0),0);\n    q = abs(p) - q;\n    return length(max(q, 0.0)) + min(max(p.y-h/2.0, length(p.xz)-r), 0.0);\n}\n// simple version, not compatible with rounding\nfloat sdOctahedron(in vec3 p, in float r) {\n    p = abs(p);\n    // basically a plane\n//    vec3 n = normalize(vec3(1,1,1));\n//    float ri =  r*(pow(3.0, 0.5)/3.0);\n//    return  dot(n,p) - ri;\n\n    // the same, but fast and cryptic\n    return (p.x + p.y + p.z - r) * 0.57735026;\n}\n\nSpotInfo sdTorusUV(in vec3 p, in float r1, in float r2) {\n    vec3 c = vec3(normalize(p.xy)*r1, 0.0);\n    return SpotInfo(distance(p, c) - r2, p,\n                    vec2(-atan(p.x, p.y)/2.0/pi+0.5, -atan(p.z, distance(p.xy, c.xy))/2.0/pi+0.5), 0);\n}\n\nSpotInfo sdSphereUV(in vec3 p, in float r) {\n    return SpotInfo(length(p) - r, p,\n                vec2(atan(p.x, p.z)/2.0/pi+0.5, -atan(p.y, length(p.xz))/pi+0.5), 0);\n}\n\n// SDF operations\nfloat sdUnion(float a, float b) {return min(a,b);}\nfloat sdIntersect( float a, float b) {return max(a,b);}\nfloat sdSubstract(float a, float b) {return max(a, -b);}\n\n// SDF operations including spot info\nSpotInfo sdUnion(in SpotInfo a, in SpotInfo b) {\n    if(a.d<b.d)\n        return a;\n    else\n        return b;\n}\nSpotInfo sdIntersect(in SpotInfo a, in SpotInfo b) {\n    if(a.d>b.d)\n        return a;\n    else\n        return b;\n}\nSpotInfo sdSubstract(in SpotInfo a, in SpotInfo b) {\n    if (a.d>-b.d)\n        return a;\n    else\n        return SpotInfo(-b.d, b.pos, b.uv, b.m);\n}\n\nfloat checkerBoard(in vec2 uv, in float w) {\n    float cx = mod(uv.x, w)>w*0.5?1.0:0.0;\n    float cy = mod(uv.y, w)>w*0.5?1.0:0.0;\n    \n    // XOR: (a || b) && !( a && b) ->  (a+b)*(1-a*b)\n    return (cx+cy)*(1.0 - cx*cy);\n}\n\n// XOR: (a || b) && !( a && b) ->  (a+b)*(1-a*b)\nfloat xor(float a, float b) {\n    return (a+b)*(1.0 - a*b);\n}\n\nfloat checkerBoard(in vec3 p, float w) {\n    float cx = mod(p.x, w)>w*0.5?1.0:0.0;\n    float cy = mod(p.y, w)>w*0.5?1.0:0.0;\n    float cz = mod(p.z, w)>w*0.5?1.0:0.0;\n    \n    return xor(xor(cx, cy),cz);\n}\n\nfloat isoLines(float d, float seg) {\n    return mod(d, seg) > seg*0.95 ^^ d < 0.0?1.0:0.0;\n}\n\n// sdf only, used for marching\nfloat map(in vec3 p) {\n    float dBox = sdBox(p-vec3(0,-2,0), vec3(40,0.1,40));\n    float dTorus = sdTorus((p - vec3(sin(iTime),1,-3.0+cos(iTime))).xzy, 1.5, 0.2);\n    float dSphere = sdSphere(p - vec3(cos(iTime),0,-3.0+sin(iTime)), 0.5);\n    float d3 = sdUnion(dSphere, dTorus);\n    float d = sdUnion(d3,dBox);\n    d = sdUnion(d, sdCylinder(p - vec3(0,0,-3), 0.2, 4.0)-0.1);\n    d = sdUnion(d, sdOctahedron(p - vec3(-2,-1,-5), 1.0));\n    return d;\n}\n\n// spot info, expensive, only used on surfac hit\nSpotInfo mapSI(in vec3 p) {\n    SpotInfo siBox = SpotInfo(sdBox(p-vec3(0,-2,0), vec3(40,0.1,40)),p,vec2(0,0), matChecker);\n    SpotInfo siTorus = sdTorusUV((p - vec3(sin(iTime),1,-3.0+cos(iTime))).xzy, 1.5, 0.2);\n    siTorus.m = matUVMagenta;\n    SpotInfo siSphere = sdSphereUV(p - vec3(cos(iTime),0,-3.0+sin(iTime)), 0.5);\n    siSphere.m = matUVCyan;\n    SpotInfo si3 = sdUnion(siSphere, siTorus);\n    SpotInfo si = sdUnion(si3,siBox);\n    SpotInfo siCyl = SpotInfo(sdCylinder(p - vec3(0,0,-3), 0.2, 4.0)-0.1, p, vec2(0), matRed);\n    si = sdUnion(si, siCyl);\n    SpotInfo siOct = SpotInfo(sdOctahedron(p - vec3(-2,-1,-5), 1.0), p, vec2(0), matGreen);\n    si = sdUnion(si, siOct);\n    return si;\n}\n\nvec3 tex(in SpotInfo si, in int matID) {\n    // switch case not working on gl es ... so use if else\n    if (matID == matChecker) {\n        return vec3(1.0)*(checkerBoard(si.pos, 1.0)*0.5+0.5);\n    } else if (matID == matRed) {\n        return vec3(1,0,0)*(checkerBoard(si.pos, 1.0)*0.5+0.5);\n    } else if (matID == matGreen) {\n        return vec3(0,1,0)*(checkerBoard(si.pos, 1.0)*0.5+0.5);\n    } else if (matID == matUVCyan) {\n        return vec3(0,1,1)*(checkerBoard(si.uv*vec2(2,1), 0.1)*0.5+0.5);\n    } else if (matID == matUVMagenta) { // uv checkerboard\n        return vec3(1,0,1)*(checkerBoard(si.uv*vec2(2,1), 0.1)*0.5+0.5);\n    } else {\n        return vec3(1.0);\n    }\n}\n\n// calculate normal based on simplified(3 vs. 6 samples) gradient around pos\n// Note: when we are marching solids, d is almost 0 on surface (varying due to marching)\nvec3 calcNormal(in vec3 p, in float d) {\n    float dx = map(p + vec3(delta,0,0));\n    float dy = map(p + vec3(0,delta,0));\n    float dz = map(p + vec3(0,0,delta));\n    \n    return normalize(vec3(dx-d, dy-d, dz-d));\n}\n\n// return distance\nfloat march(in vec3 ro, in vec3 rd, inout int j, out float d) {\n    float t = 0.0;\n    \n    for(int i = 0; i < maxIt; i++) {\n        if (t > maxT) {\n            return t;\n        }\n        \n        d = map(ro+t*rd);\n        if(d < delta || i == 99) {\n            return t;\n        } else {\n            t += d;\n        }\n        j++;\n    }\n}\n\nvec3 lightDirection() {\n    return normalize(vec3(sin(iTime*0.123),0.5,cos(iTime*0.123)));\n}\n\nvec4 bgColor(in vec3 rd) {\n    return ambientColor*cos(rd.y) + pow(max(dot(lightDirection(), rd),0.0),100.0);\n}\n\nvoid shade(out vec4 fragColor, in vec3 p, in vec3 n,in vec3 rd, in float t, inout int j) {\n    // ambient light\n    vec3 light = ambientColor.xyz;\n\n    // direct light\n    vec3 ld = lightDirection();\n    float d;\n    bool shadowed = march(p + n*delta, ld, j, d) < maxT;\n    vec3 lightSpec = vec3(0,0,0);\n    if(!shadowed)  {\n        light += max(dot(n, ld), 0.0)*lightColor.xyz; // diffuse\n        vec3 r = rd-2.0*n*dot(n, rd); // reflection ray\n        float n = 6.0;// exoonent\n        lightSpec = pow(max(dot(r,ld), 0.0),n)*((n+2.0)/2.0/pi)*lightColor.xyz;// specular\n    }\n\n\n    SpotInfo si = mapSI(p);\n    fragColor = vec4(tex(si, si.m)*light + lightSpec, 1.0);\n\n    // fade to bg (fog)\n    fragColor = mix(fragColor, bgColor(rd), t/maxT);\n}\n\nvoid render(out vec4 fragColor, in vec3 ro, in vec3 rd) {\n\n    int j = 0;\n    float d;\n    float t = march(ro, rd, j, d);\n    \n    if (t >= maxT) { // background\n        fragColor = bgColor(rd);\n    } else { // hit something\n        vec3 p = vec3(ro+t*rd);\n        vec3 n = calcNormal(p, d);\n        \n        shade(fragColor, p, n, rd, t, j);\n\n    }\n\n\n#ifdef COMPLEXITY\n    // marching complexity heatmap\n    fragColor = mix(vec4(0,0,1,1), vec4(1,0,0,1), float(j)/float(maxIt*2));\n#endif\n}\n\nvoid debugRender(out vec4 fragColor, in vec2 uv) {\n    float d = map(vec3(uv,0));\n    vec3  n = calcNormal(vec3(uv, 0), d);\n    float l = isoLines(d, 0.1);\n\n    // colored\n    //fragColor = vec4((n*0.5+0.5)*l,1.0);\n    \n    // monochrome\n    fragColor = vec4(l,l,l,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.y*2.0;\n    \n#ifdef ISOLINES\n    debugRender(fragColor, uv);\n    //fragColor = vec4(mod(uv, 1.0), 0,1);\n#else\n    vec3 ro = vec3(0,0,2);\n    vec3 rd = normalize(vec3(uv.xy, 0) - ro);\n    render(fragColor, ro , rd);\n#endif\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n\n    render(fragColor, fragRayOri, fragRayDir);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}