{
    "Shader": {
        "info": {
            "date": "1590816024",
            "description": "An animated two-tiled Truchet arrangement.",
            "flags": 0,
            "hasliked": 0,
            "id": "tsSfWK",
            "likes": 39,
            "name": "Animated Two-Tiled Truchet",
            "published": 3,
            "tags": [
                "abstract",
                "animation",
                "truchet"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 934
        },
        "renderpass": [
            {
                "code": "/*\n\n    Animated Two-Tiled Truchet\n    --------------------------\n\n\n\tAn animated two-tiled Truchet arrangement -- to accompany the texture mapped\n\tone -- for anyone only interested in the animated portion. I tried to give \n\tit a kind of geometric art deco feel.\n\n    For anyone wanting to make one of these, a few simple observations should help: \n    \n    Animating square grid Truchet arc tiles on their own requires the flow directions \n    to be reversed on alternate checkered tiles. Furthermore, in order to work \n    straight line tiles in with them, both horizontal and vertical lines must span \n    two grid cells. In addition, adjacent horizontal line rows must flow in opposite \n    directions. The same applies to adjacent vertical line columns.\n\n\n    Other examples:\n\n\t// The texture mapped version of this.\n\tAnimated Textured Truchet - Shane\n\thttps://www.shadertoy.com/view/3dSBzt\n\n\t// A much, much simpler version containing just the arc tiles.\n\tMinimal Animated Truchet - Shane\n\thttps://www.shadertoy.com/view/XtfyDf\n\n*/\n\n\n// Displays each separate grid cell, which allows you to more easily discern\n// individual tiles.\n//#define SHOW_GRID\n\n// Thinner Truchet rails.\n//#define THINNER\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// Global Truchet constants. The angle is either the angle of the\n// Truchet semi-circles, which have been normalized to the zero to one\n// range, or the value of the straight line position on the straight\n// edge tile arrangement, which also ranges from zero to one.\nvec2 ang;\n\n// The Truchet distance field. A lot of this is standard stuff. The additional\n// code here involved texture mapping.\nvec2 df(vec2 p){\n    \n    // Two by two cell random value.\n    vec2 ip2 = floor(p/2.);\n    float rnd2 = hash21(ip2 + .43);  \n    \n    // Cell ID and local coordinates.\n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    // Random 1x1 numbers, for flipping and rotating.\n    float rnd = hash21(ip);\n    float rnd3 = hash21(ip + .57);\n    \n    // The distance field container. Each cell contains either two lines\n    // or two arcs, so this will hold each one.\n    vec2 d = vec2(1e5);\n  \n    \n    // When animating arc Truchet arrangements only, the trick is to \n    // reverse the animation flow on alternate checkered cells... \n    // I have a basic animated version on here somewhere, if you\n    // require more information.\n    //\n    // Anyway, working in the extra overlapping straight line tiles \n    // complicates things. However, after a while, you'll realise that \n    // either the horizontal or vertical line must span two cells for \n    // the animation to work, so that's what the following two-by-two \n    // checkered \"mod\" decision is all about.\n    //\n    // Every 2 by 2 alternate checker, put in the overlapped straight \n    // tiles. Otherwise, calculate the distance field for the double \n    // arc one.\n    //\n    if(mod(ip2.x + ip2.y, 2.)<.5){ // Alternate checkers.\n    //if(rnd2<.5){ // Random 2x2 coverings.\n    //if((mod(ip2.x, 2.)<.5 || mod(ip2.y, 2.)<.5) && rnd2<.5){ // Mixing.\n        \n        \n        \n        // Overlapping straight tile.\n\n        d = abs(p);\n        ang = p.yx;\n\n        // Reversing just the X-directions on every second column. It's \n        // common sense... but it still took me a while to figure out.. :)\n        if(mod(ip.x + 1., 2.)<.5){\n            ang.x *= -1.;\n\n        }\n        // Reversing just the Y-directions on every second row.\n        if(mod(ip.y + 1., 2.)>.5){\n            ang.y *= -1.;\n        }  \n\n\n        // Randomly change the rendering order, which means\n        // switching everything else. I always forget this, then spend\n        // ages trying to figure out why things aren't working. :)\n        if(rnd3<.5) {\n            d = d.yx;\n            ang = ang.yx;\n        }\n\n        // This makes things line up.\n        ang += .5;\n        \n        // The straight lines are about 1.5 times the length of the\n        // quarter arcs, so multiply the straight line pattern \n        // frequency by 3 and the arc frequency by 2.\n        ang *= 3.;\n\n    }\n    else {\n        \n        \n        // Double arc tile.\n        \n        // Randomly rotate.\n        if(rnd<.5) {\n        \tp = p.yx*vec2(1, -1);\n    \t}\n        \n        // Individual arc distances. One in each corner.\n        d.x = length(p - .5) - .5;\n    \td.y = length(p + .5) - .5;\n        d = abs(d);\n        \n        // The angles of the pixels subtended to the circle centers of each \n        // arc. Standard polar coordinate stuff... In a hurry, I threw some\n        // negative signs in and everything lined up, but you could rework \n        // everything to work without them.\n        ang.x = -atan(p.y - .5, p.x - .5);\n        ang.y = -atan(p.y + .5, p.x + .5);\n        \n        \n        // This comes up all the time when animating square Truchets.\n        // It's necessary to reverse the animation flow on alternate\n        // checker squares.\n        if(mod(ip.x + ip.y, 2.)<.5) ang *= -1.;\n\n        \n        // Reverse the flow on all randomly rotated tiles.\n        if(rnd<.5) ang *= -1.;\n        \n        // Randomly change the rendering order, which means\n        // switching everything else. I always forget this, then spend\n        // ages trying to figure out why things aren't working. :)\n        if(rnd3<.5) {\n             d = d.yx;\n             ang = ang.yx;\n         }\n        \n        // Normalizing the angle. Four arcs make up a circle, which\n        // means each needs to run from zero to one four times over\n        // for the texture to wrap... I'm pretty sure that's right...\n        // but I've been wrong before. :)\n        ang *= 4./6.2831853;\n        \n        // The straight lines are about 1.5 times the length of the\n        // quarter arcs, so multiply the straight line pattern \n        // frequency by 3 and the arc frequency by 2.\n        ang *= 2.;\n        \n        \n        \n    }\n    \n    // Adding some time-based movement... or animation, if you wish to \n    // call it that. :D By the way, if you take out the time component,\n    // I think the \"fract\" call still needs to be there.\n    ang = fract(ang + iTime/4.);\n    \n    \n    return d;\n    \n}\n\n// The square grid boundaries.\nfloat gridField(vec2 p){\n    \n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    p = abs(p);\n    return abs(max(p.x, p.y) - .5) - .001;\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scaling and translation.\n    const float gSc = 7.;\n    // Depending on perspective; Moving the oject toward the bottom left, \n    // or the camera in the north east (top right) direction. \n    vec2 p = uv*gSc - vec2(-1, -.5)*iTime/4.;\n    \n\n    // Smoothing factor, based on scale.\n    float sf = 2./iResolution.y*gSc;\n   \n    // Thinner rails.\n    float lSc = 6.;\n    #ifdef THINNER\n    lSc = 8.;\n    #endif\n    \n    // Line width.\n    float lw = 1./lSc/gSc;\n    \n    // Calling the Truchet pattern distance field and giving it a bit of width.\n    // Each cell contains two overlapping arcs or line objects. \n    vec2 d = df(p) - 2.5/lSc;\n    \n    // Background color. Keeping things simple.\n    vec3 col = vec3(1., .9, .8);\n    \n    #ifdef THINNER\n    // Line pattern. Used for thinner Truchet widths.\n    float pat = abs(fract(p.x*lSc + .5*0.)  - .5) - lw*lSc/2.;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, pat)));\n    #endif\n   \n    // Rendering the two Truchet layers. A lot of this was made up as I\n    // went along, so you could ignore the details.\n    //\n    for(int i = 0; i<2; i++){\n         \n        // The tile layer distance... offset by a small amount or whatever\n        // reason I had at the time. :)\n        float di = d[i] - lw/4.;\n        \n        // The animated part: This is a standard cheap way to do it, but \n        // you could also plug \"ang[i]\" into a function that renders\n        // shapes, etc.\n        float tracks = clamp(sin(ang[i]*6.2831 + iTime*6.)*4., 0., 1.);\n       \n         \n        \n        // Set to 1 for normal edge thickness.\n        float gap = 1. + lw;// + sf/2.;//.25/lSc;\n        // Set to \"di + lw\" for normal edge thickness.\n        \n        // Fake ambient occlusion and dark edge.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*6., di))*.35);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, di));\n        \n        // Outer layers.\n        col = mix(col, vec3(1., .9, .8), 1. - smoothstep(0., sf, di + lw*2.)); \n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, di + gap/lSc));\n        // Middle.\n        col = mix(col, vec3(1), 1. - smoothstep(0., sf, di + gap/lSc + lw));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, di + 2.*gap/lSc));\n        // The central tracks.\n        col = mix(col, vec3(1)*tracks, 1. - smoothstep(0., sf, di + 2.*gap/lSc + lw));\n         \n\n    }\n    \n    // Displaying the grid cells.\n    #ifdef SHOW_GRID\n    float grid = gridField(p);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, grid)));\n    #endif\n\n    \n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}