{
    "Shader": {
        "info": {
            "date": "1635967547",
            "description": "My second try in raymarching)",
            "flags": 0,
            "hasliked": 0,
            "id": "NdcGRS",
            "likes": 3,
            "name": "Sierpinski triangle/ raymarching",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "triangle",
                "sierpinski"
            ],
            "usePreview": 0,
            "username": "bugaga777",
            "viewed": 360
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159\n#define HALF_PI 1.57\n#define HALF_HALF_PI 0.785\n\n\nconst float MIN_DIST = 0.;\nconst float MAX_DIST = 100.;\nconst int   MARCH_STEPS = 200;\nconst float EPSILON = 0.001;\n\nconst int POWER = 2;\nconst int PYRAMIDS = int(pow(5.,float(POWER)));\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat sceneSDF(vec3 point) {\n    const mat4 scene_mat = mat4(\n       0.5, 0., 0., 0.,\n       0., 0.5, 0., 0.,\n       0., 0., 0.5, 0.,\n       0., 0.5, 0., 1.\n    );\n    float result = MAX_DIST;\n    \n     for (int i = 0; i < PYRAMIDS; i++) {\n        mat4 modelMtx = mat4(\n           1., 0., 0., 0.,\n           0., 1., 0., 0.,\n           0., 0., 1., 0.,\n           0., 0., 0., 1.\n        ) * scene_mat;\n        \n        for (int ii = POWER - 1; ii >= 0; ii--) {\n            float loc_order = floor(mod(float(i), pow(5., float(ii + 1))) / pow(5., float(ii)));\n            float isMiddle = floor(loc_order / 4.);\n            float angle = HALF_HALF_PI + HALF_PI * loc_order;\n            float r = sqrt(0.5);\n            float y = -isMiddle;\n            float x = (1. - isMiddle) * cos(angle) * r;\n            float z = (1. - isMiddle) * sin(angle) * r;\n            \n        \n            modelMtx = mat4(\n               2., 0., 0., 0.,\n               0., 2., 0., 0.,\n               0., 0., 2., 0.,\n               x, y, z, 1.\n            ) * modelMtx;\n        }\n        \n       result = min(result, sdPyramid(vec3(modelMtx * vec4(point, 1.)), 1.) / modelMtx[0][0]);\n    }\n\n    return result;\n}\n\nfloat rayMarching(vec3 eye, vec3 dir) {\n    float full_dist = MIN_DIST;\n    \n    for (int i = 0; i < MARCH_STEPS; i++) {\n        float current_dist = sceneSDF(eye + dir * full_dist);\n        \n        if (current_dist < EPSILON) {\n            return full_dist;\n        }\n        \n        full_dist += current_dist;\n        if (full_dist >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    \n     return MAX_DIST;\n} \n\nvec3 getDirection(float fov, vec2 fragCoord, vec2 screenSize) {\n    vec2 xy = fragCoord - screenSize / 2.;\n    float z = screenSize.y / 2. / tan(radians(fov / 2.));\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float polar_angle;\n    float azimut_angle;\n    float r = 6.;\n    if (iMouse.y == 0. || iMouse.x == 0.) {\n        polar_angle = HALF_PI * .8;\n        azimut_angle = iTime;\n    } else {\n        polar_angle =  iMouse.y / iResolution.y * PI;\n        azimut_angle = (iMouse.x / iResolution.x * -2. + 1.) * PI;\n    }\n    \n    \n    vec3  eye  = vec3(\n        r * sin(azimut_angle) * sin(polar_angle),\n        r * cos(polar_angle),\n        r * cos(azimut_angle) * sin(polar_angle)\n    );\n    \n    vec3  dir  = lookAt(eye, vec3(0.,0.,0.), vec3(0.,1.,0.)) * getDirection(45., fragCoord, iResolution.xy);\n   \n    float dist = rayMarching(eye, dir);\n    \n    if(dist >= MAX_DIST) {\n         fragColor = vec4(0., 0., 0., 1.0);\n         return;\n    }\n    \n    vec3 p = eye + dist * dir;\n    vec3 normal = estimateNormal(p);\n    vec3 lightPos = eye;\n    vec3 lightDir = normalize(lightPos - p);\n    \n    //diff\n    vec3 diff = max(dot(lightDir, normal), 0.) * vec3(1., 0., 0.);\n    \n    //spec\n    vec3 reflectedLight = reflect(-lightDir, normal);\n    vec3 spec = vec3(.8) *  pow(max(dot(reflectedLight, normalize(eye - p)),.0), 25.);\n    \n    vec3 color = diff + spec;\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "mat3 lookAt( vec3 eye, vec3 target, vec3 up ) {\n        vec3 z = normalize(eye - target);\n        vec3 x = normalize(cross(up, z));\n        vec3 y = normalize(cross(z, x));\n\n\t\treturn mat3(\n            x.x, x.y, x.z,\n            y.x, y.y, y.z,\n            z.x, z.y, z.z\n        );\n     \n\t}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}