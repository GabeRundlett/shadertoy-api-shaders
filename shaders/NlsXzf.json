{
    "Shader": {
        "info": {
            "date": "1626211581",
            "description": "Webcam as orbit trap",
            "flags": 2,
            "hasliked": 0,
            "id": "NlsXzf",
            "likes": 2,
            "name": "Fractal webcam",
            "published": 3,
            "tags": [
                "fractal",
                "webcam",
                "feedback"
            ],
            "usePreview": 0,
            "username": "matigekunstintelligentie",
            "viewed": 644
        },
        "renderpass": [
            {
                "code": "\nprecision highp float;\n\n\nfloat ShadeMode = 0.; // value=1, min=0, max=1, step=1 (No, Yes)\nfloat ImageMode = 1.; // value=1, min=0, max=1, step=1 (No, Yes)\nfloat ImageXScale = 1.; // value=1, min=0, max=2, step=0.1\nfloat ImageYScale = 1.; // value=1, min=0, max=2, step=0.1\nfloat Front = 1.; // value=1, min=0, max=1, step=1 (No, Yes)\nfloat Animate = 1.; // value=1, min=0, max=1, step=1 (No, Yes)\nfloat Radius = 0.5; // value=0.5, min=0, max=1, step=0.01\nfloat Normalised = 1.; // value=1, min=0, max=1, step=1 (No, Yes)\nfloat Julia = 1.; // value=1, min=0, max=1, step=1 (No, Yes)\nfloat Julia_c1 = 0.; // value=0, min=-1.0, max=1.0, step=0.01\nfloat Julia_c2 = 0.; // value=0, min=-1.0, max=1.0, step=0.01\nint MaxIter = 50; // value=50, min=1, max=1000, step=1\nint AA = 4; // value=4, min=1, max=9, step=1\nfloat Zoom = 1.; // value=1, min=0.01, max=20, step=0.01\nfloat Xoffset = 0.; // value=0, min=-1, max=1, step=0.01\nfloat Xpan = 0.; // value=0, min=-1, max=1, step=0.01\nfloat Yoffset = 0.; // value=0, min=-1, max=1, step=0.01\nfloat Ypan = 0.; // value=0, min=-1, max=1, step=0.01\nfloat light = 1.5; // value=1.5, min=0, max=4, step=0.01\nfloat angle = 0.5; // value=0.5, min=0, max=1, step=0.01\nfloat EscapeRadius = 100.; // value=4, min=0, max=100, step=0.01\n\nfloat jc1;\nfloat jc2;\n\n\n\nvec2 cMul(vec2 a, vec2 b) {\n    return vec2( a.x*b.x -  a.y*b.y,a.x*b.y + a.y * b.x);\n}\n\nvec2 cInverse(vec2 a) {\n    return  vec2(a.x,-a.y)/dot(a,a);\n}\nvec2 cDiv(vec2 a, vec2 b) {\n    return cMul( a,cInverse(b));\n}\nvec2 cExp(in vec2 z){\n    return vec2(exp(z.x)*cos(z.y),exp(z.x)*sin(z.y));\n}\n\n// https://thebookofshaders.com/10/\n// Random function\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Colour scheme\n// Stolen from llemarie\n// vec3 HSVtoRGB(float iter){\n//     iter = mod(iter+iTime, float(MaxIter));\n//     float value = 1. - float(iter)/float(MaxIter);\n//     value *= value;\n        \n//     float h = value;\n//     float s = 1.;\n//     float v = (iter < float(MaxIter)) ? 1. - value*value : 0.;\n    \n//     float r, g, b, f, p, q, t;\n//     int i;\n//     i = int(h * 6.);\n//     f = h * 6. - float(i);\n//     p = v * (1. - s);\n//     q = v * (1. - f * s);\n//     t = v * (1. - (1. - f) * s);\n//     switch (i % 6){\n//         case 0: r = v, g = t, b = p; break;\n//         case 1: r = q, g = v, b = p; break;\n//         case 2: r = p, g = v, b = t; break;\n//         case 3: r = p, g = q, b = v; break;\n//         case 4: r = t, g = p, b = v; break;\n//         case 5: r = v, g = p, b = q; break;\n//     }\n//     return vec3(r, g, b);\n// }\n\nvec3 palette(float t)\n{\n    //return vec3(0.5,0.5,0.5) + vec3(0.5,0.5,0.5)*cos(6.28318*(vec3(2.0,1.0,0.0)*t + vec3(0.5,0.2,0.25)));\n    return vec3(0.5) + vec3(0.5)*cos(6.28318*(vec3(1.0)*t + vec3(0.,0.33,0.67) + iTime));\n    //return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5)*cos(6.28318*(vec3(1.0, 1.0, 1.0)*t+2.*iTime*vec3(0.01, 0.10, 0.20)) );\n}\n\n\n// Put anything you like here. This is the image that is rendered in the image orbit traps\nvec4 subrender(float xin, float yin){\n    xin = xin/ImageXScale;\n    yin = yin/ImageYScale;\n    float sqr = sqrt((xin-0.5)*(xin-0.5)+(yin-0.5)*(yin-0.5));\n    if(sqr<Radius){\n        return texture( iChannel0,vec2(xin,yin));\n    }\n    else{\n        return vec4(0.0);\n    }\n}\n\nvec4 render(float xin, float yin){\n    // vec4 final_col = vec4(0.0);\n    // for(int i = 0; i<AA;i++){\n        float trap1 = 0.0;\n        float x = 0.0;\n        float y = 0.0;\n        float xx = 0.0;\n        float yy = 0.0;\n        float xy = 0.0;\n        \n        // sample points around the main pixel for anti-aliasing\n        float c1 = (1./Zoom)*(xin + Xoffset + Xpan);\n        float c2 = (1./Zoom)*(yin + Yoffset - Ypan);\n        \n        // Julia mode\n        if(Julia>0.0){\n            x = c1;\n            y = c2;\n            c1 = jc1;\n            c2 = jc2;\n        }\n        \n        vec2 dc = vec2(1, 0);\n        vec2 der = dc;\n        \n        float h2 = light;\n        float angle = angle;\n        vec2 v = cExp(vec2(0.0, angle*2.*3.1415/360.));\n        v = vec2(sin(iTime),angle*cos(iTime));\n        \n        int j = 0;\n        // Flag keeps track of opqque pixels\n        int flag = 0;\n        \n        vec4 col = vec4(palette(1.0), 1.0);\n        \n        while(j<MaxIter){\n            xx = x*x;\n            yy = y*y;\n            col = vec4(palette(trap1), 1.0);\n            if((xx + yy) > EscapeRadius){\n                if(flag<1){\n                    // Normalised/Smooth iteration count\n                    if(Normalised>0.0){\n                        float iter =float(j) - log2(log2(dot(vec2(x,y),vec2(x,y)))) + 4.0;\n                        \n                        // float logzn = log(xx+yy);\n                        // float log4 = log(4.0);\n                        // float log2 = 1.44269504089;\n                        // float logzndiv4 = logzn/log4;\n                        // float loglogzndiv4 = log(logzndiv4);\n                        // float nu = loglogzndiv4 * 1.0/log2;\n                        // nu = log(logzn/log(4.0))/log(2.0);\n                        // float iter = float(j) + 1.0 - nu;\n                        \n                        col = vec4(palette(trap1), 1.0);\n                    }\n                    else{\n    \n                        \n                        col = vec4(palette(float(j)), 1.0);\n                    }\n                }\n                \n                break;\n            }\n            der = cMul(vec2(x,y), der) * 2.0 + dc;\n            \n            // TODO: Karatsuba style - not sure how much time it saves. https://mathr.co.uk/blog/2016-04-10_complex_squaring.html\n            xy = x*y;\n            x = xx - yy + c1;\n            y = xy+xy + c2;\n            \n            float d1 = abs(dot(vec2(x,y)-vec2(0.0,1.0),vec2(0.5)));\n\t\t    float ff = 1.0-smoothstep(0.7,1.3,d1);\n\t\t    trap1 += ff*d1;\n            \n            // Image orbit trap\n            if(ImageMode>0.0 && x>-1.0*ImageXScale && x<=1.0*ImageXScale && y > -1.0*ImageYScale && y<=1.0*ImageYScale){\n                vec4 sr = subrender(x+0.5, y+0.5);\n                if(sr.a>0.0){\n                    col = sr;\n                    if(Front>0.0){\n                        break;\n                    }\n                    flag = 1;\n                }\n            }\n            j++;\n        }\n        \n        if(ShadeMode>0.0){\n        \n            vec2 u = cDiv(vec2(x,y), der);\n            u = cDiv(u, abs(vec2(u.x, u.y)));\n            float t = dot(u,v) + h2;\n            t = t/(1. + h2);\n            \n            if(t<0.){\n                t =0.;\n            }\n            \n            col.xyz *= t;\n        }\n        \n        return col;\n        \n        \n\n    // }\n    \n    // return final_col/float(AA);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    for( int m=0; m<AA; m++ ){\n    for( int n=0; n<AA; n++ ){\n    // Screen coordinate (from [-aspect, -1] to [aspect, 1])\n\n    vec2 q   = (2.0*(fragCoord.xy+vec2(float(m),float(n))/float(AA))-iResolution.xy) / iResolution.y;\n    \n    jc1 = Julia_c1;\n    jc2 = Julia_c2;\n    if(Animate>0.0){\n        jc1 = sin(Julia_c1 + iTime + 5.);\n        jc2 = cos(Julia_c2 + iTime + 7.);\n    }\n    \n    vec4 col = render(q.x, q.y);\n    col.xyz = pow(col.xyz, vec3(0.9));\n    \n    // Output\n    fragColor += col;\n    }\n    }\n    fragColor/=float(AA*AA);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}