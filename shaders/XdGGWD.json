{
    "Shader": {
        "info": {
            "date": "1454425202",
            "description": "Click mouse to interact.\nHold D and click mouse to draw solid\nHold E and click mouse to erase\nHold S and click mouse to spawn liquid\nPress P to show particlesd",
            "flags": 48,
            "hasliked": 0,
            "id": "XdGGWD",
            "likes": 29,
            "name": "Liquid Experiment",
            "published": 3,
            "tags": [
                "simulation",
                "dynamics",
                "liquid"
            ],
            "usePreview": 0,
            "username": "P_Malin",
            "viewed": 2280
        },
        "renderpass": [
            {
                "code": "// Liquid Experiment\n// @P_Malin\n\n// Click mouse to interact.\n// Press D and click mouse to draw solid\n// Press E and click mouse to erase\n// Press S and click mouse to spawn liquid\n\nvec3 SampleCubemap( vec3 vDir )\n{\n\tvec3 vSpec = texture( iChannel3, vDir ).rgb;\n    vSpec = vSpec * vSpec;\n    vSpec = -log2(1.0 - vSpec * 0.999);\n    return vSpec;\n}\n\nvec2 ScaleUV( vec2 vUV )\n{\n    return vUV;\n    //vec2 vClampRes = min( iResolution.xy, vec2(640.0, 480.0) );    \n    //return vUV * vClampRes / iResolution.xy;    \n}\n\nvec4 SampleImage( vec2 vUV )\n{\n    return texture( iChannel0, ScaleUV(vUV) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUV = fragCoord / iResolution.xy;\n    \n    vec2 vOffset = vec2(1.0) / iResolution.xy;\n    float fScale = 0.5;\n    \n    vec4 vSampleA = SampleImage( vUV );\n    float fIsLiquid = clamp( vSampleA.r * 2.0, 0.0, 1.0);\n    float fPressure = vSampleA.g;\n\n    vec4 vSampleB = SampleImage( vUV - vec2(vOffset.x, 0.0) );\n    vec4 vSampleC = SampleImage( vUV - vec2(0.0, vOffset.y) );\n    \n    vec2 vDelta;\n    \n    vDelta.x = vSampleB.x - vSampleA.x;\n    vDelta.y = vSampleC.x - vSampleA.x;\n    vec3 vNormal = normalize( vec3( vDelta.x * fScale, vDelta.y * fScale, 1.0 ) );\n    \n    vec3 vView = normalize( vec3(vUV * 2.0 - 1.0, 1.0) * vec3(1.0, -1.0, 1.0));\n    vec3 vRefl = reflect( vView, vNormal );\n    vec3 vRefr = refract( vView, vNormal, 0.9 );\n    \n    //vec4 vSample = texture( iChannel1, vUV + vRefl.xy);\n    vec3 vRefraction = SampleCubemap( vRefr );\n    vec3 vReflection = SampleCubemap( vRefl );\n    \n    fragColor = vec4(vRefraction.xyz,1.0);\n    \n    fragColor = fragColor * fragColor;\n    \n    vec3 vColor = vec3( 0.01, 1.0, 0.8 );\n    \n    fragColor.rgb *= exp2( (1.0 - vColor) * (fIsLiquid * 0.2 + fPressure) * -10.0 );\n        \n    vec3 vSpec = SampleCubemap( vRefl );\n    \n    float NdotV = clamp( dot( vNormal, vView ), 0.0, 1.0);\n    float fFresnel =  0.02 + pow( 1.0 - NdotV, 5.0 ) * (1.0 - 0.02);\n    fragColor.rgb = mix( fragColor.rgb, vSpec, fFresnel );\n    \n    \n    fragColor = 1.0 - exp2( fragColor * -5.0 );\n    fragColor = sqrt( fragColor );\n    \n    if( vSampleA.z < -50.0 )\n    {\n        fragColor.rgb = texture( iChannel2, vUV ).rgb;\n        \n        if(vSampleB.z > -50.0)\n        {\n            fragColor.rgb *= 0.5;\n        }\n        if(vSampleC.z > -50.0)\n        {\n            fragColor.rgb *= 0.5;\n        }\n    }    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define SIZE 16\n\nvec4 SampleCell( const in vec2 vCellCoord )\n{\n    vec4 vSample = texelFetch( iChannel0, ivec2(floor(vCellCoord)), 0 );            \t    \n    \n    return vSample;\n}\n\nbool InCell( const in vec2 vCellCoord, const in vec2 vTestPos )\n{\n    vec2 vCellMin = floor( vCellCoord );\n    vec2 vCellMax = vCellMin + 1.0;\n    \n    if ( vTestPos.x < vCellMin.x ) return false;\n    if ( vTestPos.y < vCellMin.y ) return false;\n    if ( vTestPos.x >= vCellMax.x ) return false;\n    if ( vTestPos.y >= vCellMax.y ) return false;\n    \n    return true;\n}\n\n\n/////////////////////////\n\n// Keyboard \n\n\n// Keyboard constants definition\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\nbool KeyIsPressed(int key)\n{\n\treturn texelFetch( iChannel1, ivec2(key, 0), 0 ).x > 0.0;\n}\n\nbool KeyIsToggled(int key)\n{\n\treturn texelFetch( iChannel1, ivec2(key, 2), 0 ).x > 0.0;\n}\n\n\n\nconst float g_fTimeStep = 1.0 / 60.0;\nconst float g_fTimeStepSq = g_fTimeStep * g_fTimeStep;\nconst float g_fSmoothingRadius = float(SIZE);\n\nconst float g_fRestDensity = 2000000.0;\nconst float g_fK = 0.01;\nconst float g_fViscosity = 0.25;\n\nvoid UpdateParticle( const in vec2 fragCoord, inout vec2 vParticlePos, inout vec2 vParticleVel )\n{    \n#if 1     \n    float fDensity = 0.0;\n    float fNearDensity = 0.0;\n    \n    \n    {\n        vec2 vOffset;\n        vOffset.y = -float(SIZE);\n        for( int iY=-SIZE; iY<=SIZE; iY++ )\n        {\n            vOffset.x = -float(SIZE);\n            for( int iX=-SIZE; iX<=SIZE; iX++ )\n            {\n                vec2 vCoord = fragCoord + vOffset;\n\n                vec4 vSample = SampleCell( vCoord );\n                vec2 vOtherPos = vSample.xy;\n                vec2 vOtherVel = vSample.zw;\n                \n                if( vOtherPos.x >= 0.0 )\n                {\n                    float fDist = length(vOtherPos.xy - vParticlePos);\n                    if ( fDist > 0.0 )\n                    {\n                        if ( fDist < g_fSmoothingRadius )\n                        {\n                            float fOneMinusQ = 1.0 - (fDist / g_fSmoothingRadius);\n\n                            fDensity += fOneMinusQ * fOneMinusQ;\n                        }\n                    }\n                }                \t\t\t\t\n\n                vOffset.x += 1.0;\n            }\n\n            vOffset.y += 1.0;\n        }      \n    }\n    \n\tfloat fPressure = g_fK * (fDensity - g_fRestDensity);\n    \n    vec2 vD = vec2( 0.0 );\n\n    vec2 vI = vec2( 0.0 );\n    \n    {\n        vec2 vOffset;\n        vOffset.y = -float(SIZE);\n        for( int iY=-SIZE; iY<=SIZE; iY++ )\n        {\n            vOffset.x = -float(SIZE);\n            for( int iX=-SIZE; iX<=SIZE; iX++ )\n            {\n                vec2 vCoord = fragCoord + vOffset;\n\n                vec4 vSample = SampleCell( vCoord );\n                vec2 vOtherPos = vSample.xy;\n                vec2 vOtherVel = vSample.zw;\n\n                if( vOtherPos.x >= 0.0 )\n                {\n\n                    float fDist = length(vOtherPos.xy - vParticlePos);\n                    if ( fDist > 0.0 )\n                    {\n                        if ( fDist < g_fSmoothingRadius )\n                        {\n                            float fOneMinusQ = 1.0 - (fDist / g_fSmoothingRadius);\n\n                            vec2 vDiff = vOtherPos - vParticlePos;\n                            float fDist = length( vDiff );\n                            vec2 vDir = normalize( vDiff );\n\n                            if ( fDist < g_fSmoothingRadius )\n                            {\n                                float fOneMinusQ = 1.0 - (fDist / g_fSmoothingRadius);\n                                vD += vDir * (g_fTimeStepSq * (fPressure * fOneMinusQ));\n\n\n                                vec2 vVelDiff = vOtherVel - vParticleVel;\n                                float u = dot( vVelDiff, vDir );\n\n                                if( u > 0.0 )\n                                {\n                                    vI += vDir * (g_fTimeStep * fOneMinusQ * (g_fViscosity * u * u));\n                                }\n                            }\n                        }                                               \n                    }\n                }\n                else if( vOtherPos.x < -50.0 )\n                {\n                    vec2 vOtherPos = vCoord;\n                    vec2 vDelta = vOtherPos - vParticlePos;\n                    float fDist = length( vDelta );\n                    float g_CollideRadius = 16.0;\n                    if( fDist < g_CollideRadius )\n                    {\n                    \tfloat fOneMinusQ = 1.0 - (fDist / g_CollideRadius);\n                        vParticleVel -= normalize( vDelta ) * fOneMinusQ * 10.0;                        \n                    }\n                }\n                \n\n                vOffset.x += 1.0;\n            }\n\n            vOffset.y += 1.0;\n        }      \n    }\n\n    vParticleVel += vI * 0.5;\n\tvParticleVel += vD * 0.5 / g_fTimeStep;    \n    \n\n#endif    \n    \n    vParticleVel.y -= 1000.0 * g_fTimeStep;  \n    \n    float fVelMag = length(vParticleVel);\n    if ( fVelMag > 0.0 )\n    {\n        fVelMag = clamp( fVelMag, 0.0, 8.0 * 60.0 );\n\t    vParticleVel = normalize( vParticleVel ) * fVelMag;\n    }\n\n    vParticlePos += vParticleVel * g_fTimeStep;    \n}\n\nvec2 GetMouse()\n{\n\treturn iMouse.xy;    \n    \n    //vec2 vClampRes = min( iResolution.xy, vec2(640.0, 480.0) );    \n    //return iMouse.xy * vClampRes / iResolution.xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //if( fragCoord.x > 640.0 || fragCoord.y > 480.0 ) discard;\n    fragCoord = fragCoord - 1.0;\n    fragColor = vec4( -10.0, -10.0, 0.0, 0.0 );\n    \n    if ( iTime <= 1.0 )\n    {\n        if( (fragCoord.x > 16.0) && \n           (fragCoord.y > 16.0) && \n           (fragCoord.x < (iResolution.x - 16.0)) && \n           (fragCoord.y < (iResolution.y - 16.0)) )\n        {\n            if( mod( fragCoord.x, 10.0 ) < 1.0 )\n            if( mod( fragCoord.y, 10.0 ) < 1.0 )\n            {\n        \t\tfragColor = vec4( fragCoord.x, fragCoord.y, 0.0, 0.0 );\n            }\n        }\n        else\n        {\n        \tfragColor = vec4( -100.0, -10.0, 0.0, 0.0 );\n        }\n        return;\n    }\n        \n    vec4 vSample = SampleCell( fragCoord );\n    \n    if ( vSample.x < 0.0 )\n    {\n        if ( vSample.x <= -100.0 )\n        {\n\t        fragColor = vec4( -100.0, -10.0, 0.0, 0.0 );\n        }\n        else\n        {\n\t        fragColor = vec4( -10.0, -10.0, 0.0, 0.0 );            \n        }\n    }\n    \n    if ( vSample.x >= 0.0 )\n    {    \n        UpdateParticle( fragCoord, vSample.xy, vSample.zw );\n    }\n\n    if ( iMouse.z > 0.0 )\n    {\n        if ( KeyIsPressed( KEY_E ) )\n        {\n            vec2 vDelta = fragCoord.xy - GetMouse();\n            if( length(vDelta) < 10.0 )\n            {\n            \tfragColor = vec4( -10.0, -10.0, 0.0, 0.0 );\n                return;\n            }\n        }            \n        else            \n        if ( KeyIsPressed( KEY_D ) )\n        {\n            vec2 vDelta = fragCoord.xy - GetMouse();\n            if( length(vDelta) < 10.0 )\n            {\n            \tfragColor = vec4( -100.0, -10.0, 0.0, 0.0 );\n                return;\n            }\n        }            \n        else\n        if ( KeyIsPressed( KEY_S ) )\n        {     \n            vec2 vParticlePos = GetMouse();\n            vec2 vParticleVel = vec2(0.0, -10.0);\n\n            {\n                if( InCell( fragCoord, vParticlePos ) )\n                {        \n                    vSample.xy = vParticlePos;\n                    vSample.zw = vParticleVel;\n                }\n\n            }            \n        }\n        else            \n        {\n            float fRadius = 128.0;\n\n            vec2 vDelta = vSample.xy - GetMouse();\n            float fDelta = length( vDelta );\n            if( fDelta < fRadius )\n            {\n                vec2 vDir = normalize( vDelta );\n                float fForce = clamp( (fRadius - fDelta) / fRadius, 0.0, 1.0 );\n                vSample.zw += vDir * fForce * 100.0;\n            }\n        }\n        \n\n    }        \n    \t\n\n    fragColor = vSample;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define SIZE 16\n\nvec4 SampleCell( const in vec2 vCellCoord )\n{\n    vec4 vSample = texelFetch( iChannel0, ivec2(vCellCoord), 0 );            \t    \n    \n    return vSample;\n}\n\nbool InCell( const in vec2 vCellCoord, const in vec2 vTestPos )\n{\n    vec2 vCellMin = floor( vCellCoord );\n    vec2 vCellMax = vCellMin + 1.0;\n    \n    if ( vTestPos.x < vCellMin.x ) return false;\n    if ( vTestPos.y < vCellMin.y ) return false;\n    if ( vTestPos.x >= vCellMax.x ) return false;\n    if ( vTestPos.y >= vCellMax.y ) return false;\n    \n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //if( fragCoord.x > 640.0 || fragCoord.y > 480.0 ) discard;\n    \n    fragCoord = fragCoord + 0.5;\n    \n    fragColor = vec4( -10.0, -10.0, 0.0, 0.0 );\n    \n    vec4 vSample = SampleCell( fragCoord );\n    if( vSample.x < -50.0) \n    {\n        fragColor = vSample;\n    }\n    else\n    {\n\n        vec2 vOffset;\n        vOffset.y = -float(SIZE);\n        for( int iY=-SIZE; iY<=SIZE; iY++ )\n        {\n            vOffset.x = -float(SIZE);\n            for( int iX=-SIZE; iX<=SIZE; iX++ )\n            {\n                vec2 vCoord = fragCoord + vOffset;\n\n                vec4 vSample = SampleCell( vCoord );\n\n                if( InCell( fragCoord, vSample.xy ) )\n                {\n                    fragColor = vSample;\n                }\n\n                //float fCurrDist = length( vSample.xy - fragCoord.xy );\n                //fDist = min( fDist, fCurrDist );\n\n                vOffset.x += 1.0;\n            }\n\n            vOffset.y += 1.0;\n        }    \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define SIZE 16\n\nvec4 SampleCell( const in vec2 vCellCoord )\n{\n    vec4 vSample = texelFetch( iChannel0, ivec2(vCellCoord), 0 );            \t    \n    \n    return vSample;\n}\n\n/////////////////////////\n\n// Keyboard \n\n\n// Keyboard constants definition\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\nbool KeyIsPressed(int key)\n{\n\treturn texelFetch( iChannel1, ivec2(key, 0), 0 ).x > 0.0;\n}\n\nbool KeyIsToggled(int key)\n{\n\treturn texelFetch( iChannel1, ivec2(key, 2), 0 ).x > 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    //if( fragCoord.x > 640.0 || fragCoord.y > 480.0 ) discard;\n    \n    float fResult = 0.0;\n    \n    vec2 vOffset;\n    vOffset.y = -float(SIZE);\n    for( int iY=-SIZE; iY<=SIZE; iY++ )\n    {\n\t    vOffset.x = -float(SIZE);\n        for( int iX=-SIZE; iX<=SIZE; iX++ )\n        {\n            vec2 vCoord = fragCoord + vOffset;\n            \n    \t\tvec4 vSample = SampleCell( vCoord );\n            \n            float fCurrDist = length( vSample.xy - fragCoord.xy );\n            \n            float g_fSmoothingRadius = float(SIZE);\n            \n            if( KeyIsToggled( KEY_P ) )\n            {\n                g_fSmoothingRadius *= 0.25;\n            }\n            \n            if( fCurrDist < g_fSmoothingRadius )\n            {\n\t\t\t\tfloat fOneMinusQ = 1.0 - (fCurrDist / g_fSmoothingRadius);\n                    \n           \t\tfResult = fResult + fOneMinusQ * fOneMinusQ;\n            }\n                    \n            vOffset.x += 1.0;\n        }\n            \n        vOffset.y += 1.0;\n    }\n    \n    vec3 vResult = vec3(fResult);\n    //\n    vResult.x = 1.0 - exp2( vResult.x * -10.0 );\n    vResult.x = smoothstep( 0.0, 1.0, vResult.x);\n    \n    vResult.x = pow( vResult.x, 0.5 );\n    vResult.x -= pow( 1.0 - vResult.y * 0.5, 2.0);\n    vResult.y = pow( vResult.y, 3.0 );                        \n    \n    vResult.z = SampleCell( fragCoord ).x;                        \n    \n    //vResult = vec3(1.0) / (fDist + 0.5);\n    \n\tfragColor = vec4(vResult.xyz, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}