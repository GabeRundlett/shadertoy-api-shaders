{
    "Shader": {
        "info": {
            "date": "1576281478",
            "description": "See also https://t.co/THbz9C33CN?amp=1",
            "flags": 0,
            "hasliked": 0,
            "id": "3lc3WN",
            "likes": 66,
            "name": "Stellar magnetic field",
            "published": 3,
            "tags": [
                "field",
                "magnetic"
            ],
            "usePreview": 0,
            "username": "tdhooper",
            "viewed": 1641
        },
        "renderpass": [
            {
                "code": "#define CORRECT_STREAMLINES\n\n#define saturate(x) clamp(x, 0., 1.)\n\nconst float PI = 3.1419;\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nvec2 force(vec2 p, vec2 pole) {\n    // return normalize(p - pole) / distance(p, pole);\n    // optim by Fabrice:\n  \tp -= pole;\n\treturn p / dot(p,p);\n}\n\nfloat calcVelocity(vec2 p) {\n  \tvec2 velocity = vec2(0);\n  \tvec2 pole;\n    vec2 f;\n  \tfloat o, r, m;\n \tfloat flip = 1.;\n    float j = 0.;\n  \tconst float limit = 15.;\n  \tfor (float i = 0.; i < limit; i++) {\n    \tr = rand(i / limit) - .5;\n    \tm = rand(i + 1.) - .5;\n    \tm *= (iTime+(23.78 * 1000.)) * 2.;\n    \to = i + r + m;\n    \tpole = vec2(\n      \t\tsin(o / limit * PI * 2.),\n      \t\tcos(o / limit * PI * 2.)\n    \t);\n    \tf = force(p, pole);\n        flip *= -1.;\n    \tvelocity -= f * flip;\n    \tj += atan(f.x, f.y) * flip;\n  \t}  \n  \tvelocity = normalize(velocity);\n    #ifdef CORRECT_STREAMLINES\n    \treturn j;\n   \t#endif\n    return atan(velocity.x, velocity.y);\n}\n\nvec2 dir(float a) {\n\treturn vec2(sin(a), cos(a));\n}\n\nfloat calcDerivitive(float a, vec2 p) {\n    vec2 v = dir(a);\n    float n = 2. / iResolution.x;\n    float d = 0.;\n\td += length(v - dir(calcVelocity(p + vec2(0,n))));\n    d += length(v - dir(calcVelocity(p + vec2(n,0))));\n    d += length(v - dir(calcVelocity(p + vec2(n,n))));\n\td += length(v - dir(calcVelocity(p + vec2(n,-n))));\n    d /= 4.;\n    return d;\n}\n\nfloat spacing = 1./30.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.x;\n\tp *= 3.;\n    float a = calcVelocity(p);\n    float deriv = calcDerivitive(a, p);\n    a /= PI * 2.;\n    //fragColor = vec4(vec2(sin(atan(v.x, v.y)), cos(atan(v.x, v.y))) * .5 + .5, 0, 0); return;\n    //fragColor = vec4(1.-abs(a)*2.); return;\n    //a = result.z;\n    float lines = fract(a / spacing);\n    // create stripes\n    lines = min(lines, 1. - lines) * 2.;\n    // thin stripes into lines\n   \tlines /= deriv / spacing;\n    // maintain constant line width across different screen sizes\n   \tlines -= iResolution.x * .0005;\n    // don't blow out contrast when blending below\n    lines = saturate(lines);\n\n    float disc = length(p) - 1.;\n    disc /= fwidth(disc);\n    disc = saturate(disc);\n    lines = mix(1. - lines, lines, disc);\n    lines = pow(lines, 1./2.2);\n    fragColor = vec4(lines);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}