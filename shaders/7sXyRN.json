{
    "Shader": {
        "info": {
            "date": "1642535653",
            "description": "Cube-like pixels based on hexagonal tiling. Mouse to rotate the axis.",
            "flags": 32,
            "hasliked": 0,
            "id": "7sXyRN",
            "likes": 39,
            "name": "Cube Pixel Tetrahedron",
            "published": 3,
            "tags": [
                "mouse",
                "cube",
                "hexagon",
                "tetrahedron",
                "tiling"
            ],
            "usePreview": 0,
            "username": "amhall",
            "viewed": 803
        },
        "renderpass": [
            {
                "code": "// Cube-like pixels based on hexagonal tiling. Buffer A acts as a vertex shader.\n\n// Created by Anthony Hall\n\nconst int SS = 2;\n\nconst float tileSize = 0.09;\nconst float lineThickness = 0.025;\n\nconst float pi = radians(180.0);\nconst float twoPi = radians(360.0);\n\n// Populated in mainImage\nvec4[6] lines;\n\n// Slightly cheaper linear version of smoothstep\nfloat linestep(float a, float b, float x)\n{\n  return clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\n// \"Hexagonal\" distance to origin\nfloat hexDist(vec2 point)\n{\n    point = abs(point);\n    return max(point.x, dot(point, vec2(0.5, 0.5 * sqrt(3.0))));\n}\n\n// Returns the point relative to and \"hexagonal\" distance from the center of the tile\nvec3 hexTile(vec2 point)\n{\n    const vec2 tileBox = tileSize * vec2(1.0, sqrt(3.0));\n    vec2 p1 = mod(point, tileBox) - 0.5 * tileBox;\n    vec2 p2 = mod(point + 0.5 * tileBox, tileBox) - 0.5 * tileBox;\n    \n    vec2 hexPoint = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n    return vec3(hexPoint, hexDist(hexPoint));\n}\n\n// From Inigo Quilez\nfloat lineDist(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 image(vec2 point)\n{\n    float dist = 1e5;\n    for (int i = 0; i < 6; i++)\n    {\n        vec4 line = lines[i];\n        dist = min(dist, lineDist(point, line.xy, line.zw));\n    }\n    // Cap intensity at 1.0 while avoiding any unlucky division by 0\n    float intensity = lineThickness / max(lineThickness, dist);\n    return pow(vec3(intensity), vec3(0.9, 3.0, 0.5));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Populate lines array with rotated vertices\n    vec2[4] vertices;\n    for (int i = 0; i < 4; i++)\n    {\n      vertices[i] = texelFetch(iChannel0, ivec2(i, 0), 0).xy;;\n    }\n\n    int lineIndex = 0;\n    for (int i = 0; i < 3; i++)\n    {\n      for (int j = i + 1; j < 4; j++)\n      {\n        lines[lineIndex] = vec4(vertices[i], vertices[j]);\n        lineIndex++;\n      }\n    }\n    \n    // Independent of supersampling, there's a little bit of antialiasing at the borders.\n    // It has to be corrected so changing the tile size or resolution doesn't mess with it\n    float aaCorrection = 0.00605 / tileSize * 450.0 / iResolution.y;\n\n    const float increment = 1.0 / float(SS);\n    const float offset = 0.5 * increment - 0.5;\n    vec3 color = vec3(0.0);\n    \n    for (int x = 0; x < SS; x++)\n    {\n        for (int y = 0; y < SS; y++)\n        {\n            vec2 screenCoord = fragCoord + vec2(x, y) * increment + offset;\n            vec2 uv = (2.0 * screenCoord - iResolution.xy) / iResolution.y;\n            vec3 tile = hexTile(uv);\n            \n            // Anti-aliased black border\n            float border = linestep(0.9, 0.9 - aaCorrection, 2.0 * tile.z / tileSize);\n\n            // Figure out which cube face we're in and sample in the middle of it\n            float theta = atan(tile.y, tile.x) - pi/6.0;\n            theta = floor(3.0 * theta / twoPi) / 3.0 * twoPi;\n            theta += pi/2.0;\n            vec2 samplePoint = uv - tile.xy\n                + 0.5 / sqrt(3.0) * tileSize * vec2(cos(theta), sin(theta));\n            samplePoint.y += 0.125; // Move the screen down a bit\n            \n            vec3 sampleColor = border * image(samplePoint);\n            color += sampleColor;\n        }\n    }\n    color /= float(SS * SS);\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Each of the first four pixels of this buffer performs a simple rotation and\n// orthographic projection on its respective vertex\n\nconst vec3[4] vertices = vec3[4](\n    vec3(1, 1, 1),\n    vec3(-1, 1, -1),\n    vec3(-1, -1, 1),\n    vec3(1, -1, -1));\n    \nvec2 CS(float theta)\n{\n  return vec2(cos(theta), sin(theta));\n}\n\nmat2 rotate(float theta)\n{\n    vec2 cs = CS(theta);\n    return mat2(cs.x, cs.y, -cs.y, cs.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Final point to be written to buffer\n    vec2 point = vec2(0.0); \n    \n    fragCoord = floor(fragCoord);\n    int index = int(fragCoord.x + fragCoord.y * iResolution.x);\n    if (index < 4)\n    {\n        // Rotate the tetrahedron so it's flat on a face, looking directly at\n        // another face\n        const vec3 fInit = vertices[3];\n        const vec3 u = vertices[0] / sqrt(3.0);\n        const vec3 r = normalize(cross(fInit, u));\n        const vec3 f = cross(u, r);\n        \n        // Tilt the axis based on time/mouse\n        vec3 tilt = vec3(0, 1, 0);  \n        if (iMouse.z > 0.0)\n            tilt.xz = 0.4 * (2.0 * iMouse.xy - iResolution.xy) / iResolution.xy;\n        else\n            tilt.zx = 0.4 * CS(0.3 * iTime);\n\n        vec3 tiltU = normalize(tilt);\n        vec3 tiltR = normalize(cross(tiltU, vec3(0, 0, 1)));\n        vec3 tiltF = cross(tiltU, tiltR);\n        mat3 tiltMat = mat3(tiltR, tiltU, -tiltF);\n        \n        vec3 point3 = transpose(mat3(r, u, -f)) * vertices[index];\n        point3.xz = rotate(0.5 * iTime) * point3.xz;\n        point3 = tiltMat * point3;\n        point = 0.5 * point3.xy;\n    }\n    fragColor = vec4(point, 0.0, 1.0);\n}  ",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}