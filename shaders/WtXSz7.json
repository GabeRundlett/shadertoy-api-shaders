{
    "Shader": {
        "info": {
            "date": "1562362826",
            "description": "Having fun with interlocking sin() calls.",
            "flags": 0,
            "hasliked": 0,
            "id": "WtXSz7",
            "likes": 1,
            "name": "Scatterfrom Output1A",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "distancefield"
            ],
            "usePreview": 0,
            "username": "audiopixel",
            "viewed": 676
        },
        "renderpass": [
            {
                "code": "// Created by Hepp Maccoy 2019, hepp@audiopixel.com\n// Built with Haxademic+Scatterform, github.com/cacheflowe/haxademic\n// Distance functions by Inigo Quilez, iquilezles.org\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define PI 3.14159265358979323846\n\nfloat d1;\nfloat t1;\n\nfloat soc(vec3 p) {\n    vec3 n = normalize(sign(p+1e6));\n    return min(min(dot(p.xy, n.xy), dot(p.yz, n.yz)), dot(p.xz, n.xz));\n}\n\nfloat sinc(float x, float k) {\n    float a = PI * (float(k)*x-1.0);\n    return sin(a)/a;\n}\n\nmat2 r2d(float a) {\n    float sa=sin(a);\n    float ca=cos(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nvec2 amod(vec2 p, float m) {\n    float a=mod(atan(p.x,p.y), m)-m*.5;\n    return vec2(cos(a), sin(a))*length(p);\n}\n\nfloat map(vec3 p) {\n    float d = 1.0;\n    float a = abs(p.y);\n    p.yz *= r2d(sign(a) * 1.0);\n    p.xz *= r2d(sign(a) * (d1 * .04) + (t1 * .5));\n    p.xz = amod(p.xz, (PI * 1.0) / 3.0);\n    p.xz = max(abs(p.xz) - (sin(t1 * 1.97) * 1.9) - 1.5, -1.29);\n    p.z = mod(p.z, 5.0)-(5.0 *.5);\n    p.x = mod(p.x, (d1 * 6.25) - 4.1)-((d1 * 6.25) - 4.1 *.5);\n    p.y = mod(p.y + 35., 16.0) - 5.;\n    d = min(d, soc(max(abs(p) - 0.172, -(d1 * .15) - .3)));\n    return (length(p * -0.12) - .94 + (sin(t1 * .3) * .18)) * 0.6 - (d * -1.0);\n}\n\nvec3 calcNormal(in vec3 p, in int type, in float m1, in float m2, in float m3) {\n    vec2 e = vec2(m2, m3) * m1;\n    return normalize( e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx) );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    t1 = iTime + 18.;\n    d1 = sin(t1 * .4);\n    vec2 st = (fragCoord.xy / iResolution.xy) * 2.5 - 1.;\n    st.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(st, 14.0);\n    vec3 rd = normalize(vec3(st + vec2(0.), -1.0));\n    vec3 mp;\n    mp = ro;\n    float md;\n    for(int i=0; i<50; i++) {\n        md = map(mp);\n        mp += (rd * .9 + (-d1 * .18)) * md;\n    }\n    float b = length(ro - mp);\n    float dA = 0.4799 - (b * 0.02) * 0.3232;\n    float dB = 0.479 - (b * 0.03) * 0.523;\n    dA = sinc(dA, 1.0);\n    dB = sinc(dB, -4.2706);\n    vec3 p = ro + rd * (mp);\n    vec3 lt = vec3(3.0, 10.0, 29.0);\n    vec3 l;\n    vec3 nm = calcNormal(p, 0, 0.2895, -0.063, 0.6906);\n    if (md < 0.2325) {\n        float dif = clamp(dot(nm, normalize(lt - p)), 0., 1.);\n        dif *= 4.9841 / dot(lt - p, lt - p);\n        l = vec3(pow(dif, 0.4245));\n    }\n    float src1 = dA;\n    float src2 = dB;\n    float src3 = l.x;\n    vec3 c;\n    src1 *= 2.0;\n    src2 *= (d1 * .4) * 5.2;\n    c = (mix(vec3(0.0,0.33333334,0.9411765), vec3(0.0), src1) * 1.0) + (mix(vec3(0.0), vec3(0.0,0.17254902,0.43529412), src2) * (d1 * .4) * 2.);\n    c = c + vec3(src3);\n    fragColor = vec4(c, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}