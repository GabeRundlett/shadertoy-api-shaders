{
    "Shader": {
        "info": {
            "date": "1716764809",
            "description": "Rendering a lightmap to a texture along with a raymarched depth pass into the alpha of the lightmap;\nRendering volumetric lighting (single scatter) w/ shadows (shadowmap w/ angle bias)  - code still needs cleanup and debugging. What do you think?",
            "flags": 32,
            "hasliked": 0,
            "id": "43t3zj",
            "likes": 7,
            "name": "Disco light demo",
            "published": 3,
            "tags": [
                "raymarching",
                "fog",
                "shadows",
                "volumetricfx"
            ],
            "usePreview": 0,
            "username": "d00fd00f",
            "viewed": 188
        },
        "renderpass": [
            {
                "code": "/*\n\nstruct Ray{\n    vec4 origin;\n    vec4 pos;\n    vec4 hitPos;\n    vec4 dir;\n    uint iter;\n    uint bounce;\n    bool hit;\n    uint objIdx;\n    float hitDist;\n    vec3 illum;\n};\n*/\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // world space light position\n    lightPos = vec4(\n        4.*sin(iTime/5.)+(1.+0.5*sin(iTime/6.)),\n        2.*sin(iTime/4.),\n        4.*cos(iTime/5.)+(1.+0.5*sin(iTime/6.)),\n        1.\n    );\n    \n    vec2 uv = fragCoord/iResolution.xy;    \n    vec4 ndc = vec4(uv*2.-1., 1., -clip.y);// image plane in clip space\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    mat4 lookatMat = lookAt(identity(), (lightPos).xyz, (vec4(0.,0.,0.,1.)).xyz);\n    \n    model = rotateY(identity(), -fract(iTime/12.)*PI2); // model space -> world space\n    view = translate(identity(), -camPos.xyz); // world space -> camera space\n   //view=lookatMat;\n   proj = perspfov(aspect, clip, 40.); // camera -> clip\n    \n    invmodel = inverse(model);\n    invview = inverse(view);\n    invproj = inverse(proj);\n    \n    \n    mat4 matLight = proj*lookatMat;\n    \n    mat4 mrot = rotateX(identity(), 45.*d2r+iTime*.5);\n    mrot *= rotateZ(identity(), 45.*d2r+iTime*1.666*.5);\n    mat4 irot = inverse(mrot);\n    \n    xf1 = mrot*model;\n    xf2 = mrot * xf1;\n    ixf1 = inverse(xf1);\n    ixf2 = inverse(xf2);\n    \n    vec4 pos = inverse(view)*vec4(0.,0.,0.,1.);\n   \n    vec4 dir = ndc;//ndcToClip(ndc, proj); // is now clip space image plane \n    \n    dir.xyz *= dir.w;\n    dir = inverse(proj*view) * dir; // is now view space image plane, camera at origin\n    dir -= pos;\n    dir=normalize(dir);\n      \n    Ray result = rayTraceSingle(pos, dir, 0u, -1u,-1u, mrot, matLight, iChannel0, aspect);\n\n    vec3 tColor = vec3(0.);\n    float T;\n    \n    if(result.hit)\n    {\n        vec3 lightOffs,lightDir;        \n        \n        lightOffs = (result.hitPos-lightPos).xyz;         \n        lightDir = normalize(lightOffs);\n        \n        // shoot ray from light to me, if not hit me i dark\n        //Ray shadowRay = rayTraceSingle(lightPos, vec4(lightDir,0.), 1u, -1u,-1u, mrot, matLight, iChannel0, aspect);\n   \n            vec4 uv = rayPosToClip(result.hitPos, matLight);\n            \n            uv.xyz /= uv.w;\n          //  vec3 onColor = vec3(sx*sy);\n           /* vec3 onColor = vec3(min(min(rangeOutside(uv.x, -uv.w, 0.),\n            rangeOutside(uv.y, -uv.w, 0.)),\n            rangeOutside(uv.z, -uv.w, 0.)));*/\n            vec4 texel = texture(iChannel0, .5+.5*uv.xy);\n            \n            \n        \n        vec3 baseColor = vec3(1.);\n        vec3 hitNormal;\n        if(result.objIdx == 0u)\n            hitNormal = (ixf1*\n            vec4(\n                sdBoxFrameN(\n                    (xf1*result.pos).xyz,\n                    vec3(0.8, 0.6, 0.5), 0.08\n                ),\n                1.\n            )).xyz;\n        else if(result.objIdx == 1u)\n            hitNormal = (ixf2*\n            vec4(\n                sdCutHollowSphereN(\n                    (xf2*result.pos).xyz,\n                    .25,\n                    0.0,\n                    0.025\n                ),\n                1.\n            )).xyz;\n        else if(result.objIdx == 2u){\n            tColor += vec3(1.,1.,0.);\n            \n            hitNormal = (vec4(sdOctahedronN((lightPos-vec4(result.pos)).xyz, 0.25),1.)).xyz;\n        }\n        \n        \n            vec3 onColor = 7.5*texel.xyz*(1.0/dot(lightOffs,lightOffs));\n   \n             float x =  texel.a;\n            float map = x;//2.*x*x-1.;\n    \n            float sF= map >= uv.z - 0.01*(1.-dot(-hitNormal,lightDir))\n            ? 1. : 0.;\n        \n        \n        // view light\n        float lCam = length(result.hitPos-(camPos));\n        float l = lCam+lCam;\n        T = pow(exp(muFog*l),1.);        \n        tColor += (5000./(5000.+l*l))*T*baseColor * 0.01*clamp(dot(-hitNormal, result.dir.xyz),0.,1.);\n        \n            //vec3 onColor = vec3(clamp(uv,0.,1.),0);\n        // diffuse light; \n        l = length(lightOffs+lCam);\n        T = pow(exp(muFog*l),1.);\n        tColor += onColor*pow(dot(-lightDir,normalize(lightPos.xyz)),20.)\n        *sF*(5000./(5000.+l*l))*T*baseColor * 2.*clamp(dot(-hitNormal,lightDir),0.,1.);\n       \n        // specular highlight\n        vec3 refl = reflect(lightDir, hitNormal);\n        tColor +=  onColor*pow(dot(-lightDir,normalize(lightPos.xyz)),20.)\n        *sF*(5000./(5000.+l*l))*T*30.0*baseColor*pow(clamp(dot(-result.dir.xyz,refl),0.,1.),99.);\n        /*\n        l = length(pixRay.hitpos-vec4(0.,0.,tempz, 0.)*view);\n        T = pow(exp(-.0225*l),1.);\n        */\n        \n    }\n    else\n    {\n        T=1.0;\n        tColor = vec3(0.,0.,0.);//vec4(theSdf/main_ray_hit_dist,ndc,1.);\n    }\n    tColor += result.illum;\n        \n   fragColor = vec4(exposure(mix(fColor,tColor,T),2.2,10.0),1.);\n    \n    //fragColor = vec4(uv, 0., 1.);   \n   //fragColor = vec4(vec3(abs(dir.z)), 1.);\n    //vec4 t = inverse(proj*view)*ndc;\n    //t.xyz /= t.w;\n   // fragColor = vecToColor(dir);  \n  //  fragColor = vec4(dir.xyz*200.,2.);\n /* uv = fragCoord/iResolution.xy;  \n  fragColor = texture(iChannel0, uv);*/\n      //  fragColor = texture(iChannel0, uv)+vec4(0.5+0.5*vec3((result.hitDist-clip.x)/(clip.y-clip.x)*.5),1.);\n /*   fragColor = vec4(\n        abs(model*camPos/length(camPos.xyz)\n    ));;*/\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI = 3.14159265359;\nconst float PI2 = 2.*PI;\nconst float PHI =  1.618033988749;\nconst float d2r = PI/180.;\nconst float eps16 = 0.000061;\nconst uint f2um =  4294967295u;\nfloat muFog = -0.00125;\n//const uint f2um =  2147483647u;\n//const uint f2um = 65535u;\n\nuint f2u(in float f){\n    f = fract(f/65535.);\n    f *= float(f2um);\n    return uint(f);\n}\n\nuint urotl(in uint a, in uint n)\n{\n    // rotating left n bits shifts the leftmost n bits onto the right\n    const uint umax = 0xFFFFFFFFu;\n    \n    uint s = (32u-n)%32u;\n    // take left n bits and make them the right bits\n    uint x = a&(umax<<s);\n    x >>= s;\n    \n    \n    // take remaining and make them the left bits\n    uint y = a&(umax^(umax<<s));\n    y <<= n;\n    \n    return x|y;\n}\nuint urotr(in uint a, in uint n)\n{\n    // rotating right n bits shifts the rightmost n bits onto the left\n    const uint umax = 0xFFFFFFFFu;    \n    uint s = (32u-n)%32u;\n    \n    uint x = a & (umax ^ (umax<<n));\n    x <<= s;\n    \n    \n    uint y = a & (umax<<n);\n    y >>= n;\n    \n    return x|y;\n}\nuint pcg(uint v) {\n\tuint state = v * uint(747796405) + uint(2891336453);\n\tuint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\n\treturn (word >> uint(22)) ^ word;\n}\nuint shiftRound(in uint a){\n    uint aa, bb;\n    \n    aa =pcg(a);\n    \n    aa ^= aa<<19;\n    aa ^= aa>>5;\n    aa ^= aa<<11; \n    \n    aa = aa^urotl(aa, 15u);\n    ;\n    \n    return aa;\n}\n\nfloat xorshift(in vec2 src){\n    uint a = f2u(src.x);\n    uint b = f2u(src.y);\n    \n    a = shiftRound(a); \n    b = shiftRound(b);\n    \n    float res = float(a*b)/float(f2um);\n    return fract(res);\n}\n\nfloat hash(in vec2 p ) {\n    return xorshift(p);    \n}\n\n// ALL MATRICES COLUMN MAJOR/ VEC4 IS A COLUMN\n// ALL VECTORS ROW VECTORS / PERFORM M*V AND NOT V*M!\nmat4 identity(){\n    return mat4(\n        vec4(1.,0.,0.,0.),\n        vec4(0.,1.,0.,0.),\n        vec4(0.,0.,1.,0.),\n        vec4(0.,0.,0.,1.)\n    );\n}\n\n\nmat4 translate(in mat4 m, in vec3 t){\n    mat4 result = mat4(\n        vec4(1.,0.,0.,0.),\n        vec4(0.,1.,0.,0.),\n        vec4(0.,0.,1.,0.),\n        vec4(t.xyz,1.)\n    )*m;\n    return result;\n}\n\n\nmat4 rotateX(in mat4 m, in float a){\n    float c = cos(a);\n    float s = sin(a);\n    mat4 result = mat4(\n        vec4(1.,0.,0.,0.),\n        vec4(0.,c,s,0.),\n        vec4(0.,-s,c,0.),\n        vec4(0.,0.,0.,1.)\n    )*m;    \n    return result;\n}\n\nmat4 rotateY(in mat4 m, in float a){\n    float c = cos(a);\n    float s = sin(a);\n    mat4 result = mat4(\n        vec4(c,0.,-s,0.),\n        vec4(0.,1.,0.,0.),\n        vec4(s,.0,c,0.),\n        vec4(0.,0.,0.,1.)\n    )*m;    \n    return result;\n}\n\nmat4 rotateZ(in mat4 m, in float a){\n    float c = cos(a);\n    float s = sin(a);\n    mat4 result = mat4(\n        vec4(c,s,0.,0.),\n        vec4(-s,c,0.,0.),\n        vec4(0.,0.,1.,0.),\n        vec4(0.,0.,0.,1.)\n    )*m;    \n    return result;\n}\n\n\nmat4 lookAt(in mat4 m, in vec3 pos, in vec3 tgt){\n    vec3 dir = normalize(tgt-pos);\n    \n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = cross(dir, right);\n    \n    mat4 result = mat4(\n        vec4(right.x,up.x,dir.x,0.),\n        vec4(right.y,up.y,dir.y,0.),\n        vec4(right.z,up.z,dir.z,0.),\n        vec4(0.,0.,0.,1.)\n    )* mat4(\n        vec4(1.,0.,0.,0.),\n        vec4(0.,1.,0.,0.),\n        vec4(0.,0.,1.,0.),\n        vec4(-pos,1.)\n    )*\n    m;\n    \n    return result;\n}\nmat4 perspective(in mat4 m, in vec2 clip, in vec4 lrtb){\n    clip = -clip;\n\n    float rml = lrtb.y-lrtb.x;\n    float tmb = lrtb.z-lrtb.w;\n    float fmn = clip.y-clip.x;\n    \n    float n2 = 2.*clip.x;\n    \n    mat4 result = mat4(\n        vec4(\n            n2/rml,\n            0.,\n            0.,\n            0.),\n        vec4(\n            0.,\n            n2/tmb,\n            0.,\n            0.),\n        vec4(\n            (lrtb.y+lrtb.x)/rml,\n            (lrtb.z+lrtb.w)/tmb,\n            (-(clip.y+clip.x))/fmn,\n            -1),\n        vec4(\n            0.,\n            0.,\n            (-n2*clip.y)/fmn,\n            0.)\n    )*m;\n    return result;\n}\n\nmat4 ortho(in mat4 m, in vec2 clip, in vec4 lrtb){\n    float rml = lrtb.y-lrtb.x;\n    float tmb = lrtb.z-lrtb.w;\n    float fmn = clip.y-clip.x;\n    \n    mat4 result = mat4(\n        vec4(\n            2./rml,\n            0.,\n            0.,\n            0.),\n        vec4(\n            0.,\n            2./tmb,\n            0.,\n            0.),\n        vec4(\n            0.,\n            0.,\n            -2./fmn,\n            0.),\n        vec4(\n            -(lrtb.y+lrtb.x)/rml,\n            -(lrtb.z+lrtb.w)/tmb,\n            -(clip.y+clip.x)/fmn,\n            1.)\n    )*m;\n    return result;\n}\n\nmat4 perspfov(in float aspect, in vec2 clip, in float fovy){\n    vec4 lrtb = vec4(0.);    \n    lrtb.z = clip.x * tan(0.5*fovy*d2r);\n    lrtb.w = -lrtb.z;\n    lrtb.x = -lrtb.z*aspect;\n    lrtb.y = -lrtb.x;\n    return perspective(identity(), clip,lrtb);\n}\nfloat noise( in vec2 p ) {\n    \n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);    \n}\n\nfloat sea_octave(in vec2 uv,in float iTime, in float choppy) {\n    uv += noise(uv+iTime);\n    float s = sin(uv.x);\n    float c = cos(uv.y);\n    vec2 wv = 1.0-abs(vec2(s,c));\n    vec2 swv = abs(vec2(s,c));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n\n// cheap hdr/desaturate\nvec3 exposure(in vec3 color, float gamma, float exposure){\n\n    vec3 hdrColor = color;//texture(hdrBuffer, TexCoords).rgb;\n  \n    // exposure tone mapping\n    vec3 mapped = vec3(1.0) - exp(-hdrColor * exposure);\n    // gamma correction \n    mapped = pow(mapped, vec3(1.0 / gamma));\n  \n    return mapped;\n}\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n// https://iquilezles.org/articles/normalsSDF\n\nvec3 sdBoxFrameN( in vec3  pos, in vec3 b, in float ed ) // for function f(p)\n{\n    const float h = eps16; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdBoxFrame( pos + k.xyy*h,b, ed ) + \n                      k.yyx*sdBoxFrame( pos + k.yyx*h, b, ed ) + \n                      k.yxy*sdBoxFrame( pos + k.yxy*h,b, ed ) + \n                      k.xxx*sdBoxFrame( pos + k.xxx*h ,b,ed) );\n}\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n  \n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\nvec3 sdCutHollowSphereN( in vec3  pos,  float r, float h, float t ) // for function f(p)\n{\n    const float hi = eps16; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdCutHollowSphere( pos + k.xyy*hi, r, h, t) + \n                      k.yyx*sdCutHollowSphere( pos + k.yyx*hi, r, h, t) + \n                      k.yxy*sdCutHollowSphere( pos + k.yxy*hi, r, h, t) + \n                      k.xxx*sdCutHollowSphere( pos + k.xxx*hi, r, h, t) );\n}\nfloat sdOctahedron( vec3 p, float s )\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\nvec3 sdOctahedronN( in vec3  pos, float s ) // for function f(p)\n{\n    const float hi = eps16; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdOctahedron( pos + k.xyy*hi, s) + \n                      k.yyx*sdOctahedron( pos + k.yyx*hi, s) + \n                      k.yxy*sdOctahedron( pos + k.yxy*hi, s) + \n                      k.xxx*sdOctahedron( pos + k.xxx*hi, s) );\n}\n\nfloat Beers(float muFog, float l){\n    return pow(exp(muFog*l),1.);\n}\n\nstruct Ray{\n    vec4 origin;\n    vec4 prevPos;\n    vec4 pos;\n    vec4 hitPos;\n    vec4 dir;\n    uint iter;\n    uint bounce;\n    bool hit;\n    uint objIdx;\n    float hitDist;\n    vec3 illum;\n};\n\nconst uint maxIter = 2048u;\nconst float hitDist = eps16;\nconst float maxDist = 30.;//clip.y;\nconst float minIllumStep = 0.01;\n// world-space positions\nvec4 lightPos = vec4(5.0,3.0,-3.0,1.0);// replaced by orbit!\nvec4 camPos = vec4(0.,0.0,-10,1.);\nvec2 clip = vec2(.1,155.);\n    \nvec3 fColor = vec3(0.025,0.025,0.025);  \n\nmat4 model;\nmat4 invmodel;\nmat4 view;\nmat4 invview;\nmat4 proj;\nmat4 invproj;\n\nmat4 xf1,xf2,ixf1,ixf2;\n\nfloat sdfArray[16];\nuint sdfCount = 0u;\n\nvoid caldSdfs(vec4 pos,uint mode, mat4 xform){\n    sdfCount = mode==0u?3u:2u;\n    sdfArray[0] = sdBoxFrame(\n        (xf1*pos).xyz,\n        vec3(0.8, 0.6, 0.5), 0.08\n    );\n    sdfArray[1] = sdCutHollowSphere(\n        (xf2*pos).xyz,\n        0.25,\n        0.0,\n        0.025\n    );\n    if(mode==0u)\n        sdfArray[2] = sdOctahedron(\n                (pos-lightPos).xyz,\n                0.25)\n            ;\n}\nfloat minSdf(out uint index){\n    float theSdf = float(f2um);\n    float sut;\n    index = -1u;\n    for(uint i = 0u; i<sdfCount; i++){\n        sut = sdfArray[i];\n        if(sut<theSdf){\n            index = i;\n            theSdf = sut;\n        }\n    }\n    return index != -1u ? theSdf : 0.0;\n}\nvec3 objectNormal(uint objIdx){\n    return vec3(0.);\n}\nbool pointIsHit(vec3 a, vec3 b){\n    vec3 offs = a-b;\n    return dot(offs, offs)<max(hitDist,1./(length(offs)+.1)*hitDist);\n}\nbool rayIsHit(uint index, uint mode){\n    switch(mode){\n        case 1u:\n            return sdfArray[index]<hitDist;;\n        default:\n            return sdfArray[index]<hitDist;\n    }\n}\n\nfloat ifGt(float a, float b){\n    return max(sign(a-b),0.);\n}\nfloat ifLt(float a, float b){\n    return max(sign(b-a),0.);\n}\nfloat ifEq(float a, float b){\n    return 1.-sign(abs(a-b));\n}\n// true if -b < a < b\nfloat isBetweenPN(float a, float b){\n return 1.-max(sign(2.*abs(a*.5)-b),0.);\n}\n\n// returns i if -b < a < b, otherwise returns how far a is outisde\nfloat rangeOutside(float a, float b, float i){\n    return max(abs(a)-b,i);\n}\n\nvec4 rayPosToClip(vec4 worldPos, mat4 mat){\n            vec4 ndc = mat*worldPos; \n            \n            return ndc;\n}\nvec2 rayPosToUv(vec4 worldPos, mat4 mat){\n            vec4 ndc = rayPosToClip(worldPos, mat); // light view matrix\n            \n            ndc.xyz /= ndc.w; // -1..1\n            \n            ndc.xy = 0.5+ndc.xy*0.5;\n            \n            vec2 uv = ndc.xy;\n            \n            return uv;\n}\nfloat maxRayStep(Ray ray, float theSdf, uint mode, mat4 matLight){\n    // 0: no maximum\n    // 1: appropriate microstep in light volume\n    vec3 camToRay = ray.hitPos.xyz-(camPos).xyz;\n    float camToRayLen = dot(camToRay,camToRay);\n    switch(mode){\n        case 0u:// main ray: accumulate radiance\n            vec3 lightToRay = ray.hitPos.xyz-lightPos.xyz;            \n            float lightToRayLen = dot(lightToRay,lightToRay);\n            \n            vec3 camToRayDir = camToRayLen >= 0.001 ? camToRay/sqrt(camToRayLen) : vec3(0.);\n            vec3 lightToRayDir = lightToRayLen >= 0.001 ? camToRay/sqrt(lightToRayLen) : vec3(0.);\n            \n            vec3 lightToCam = camPos.xyz-lightPos.xyz;\n            float lightToCamLen = dot(lightToCam, lightToCam);\n            vec3 lightToCamDir = lightToCam/sqrt(lightToCamLen);\n            \n            float lf = \n                min(\n                    max(2.*minIllumStep,0.01*sqrt(lightToRayLen))\n                    ,\n                    max(5.*minIllumStep,0.005*camToRayLen*(1.-dot(-lightToCamDir,ray.dir.xyz)))\n                )              \n                ;\n            \n            vec4 uv = rayPosToClip(ray.hitPos, matLight);\n            \n            float d = abs(length(uv.xyz/uv.w))-uv.w;\n            \n            float sx = isBetweenPN(uv.x, -uv.w);\n            float sy = isBetweenPN(uv.y, -uv.w);\n            float sz = isBetweenPN(uv.z, -uv.w);\n            float sw = sx*sy*sz;\n            return min(theSdf,\n                sw*lf\n                +(1.0-sw)*\n                (max(\n                    min(\n                        minIllumStep+0.1*sqrt(camToRayLen),\n                        minIllumStep+0.1*sqrt(lightToRayLen)\n                    ),\n                    max(\n                       1.*min(min(rangeOutside(uv.x/uv.w, 1., minIllumStep),\n                            rangeOutside(uv.y/uv.w, 1., minIllumStep)),\n                            rangeOutside(uv.z/uv.w, 1., minIllumStep)),\n                            minIllumStep))\n                    )// sw*lf+(1.-sw)*theSdf\n                );\n        default:\n            return theSdf;// shadow: max fast convergence\n    }\n}\n\n\nvec4 vecToColor(vec4 pos){\n    vec3 x, y, z;\n    x = vec3(1.0, 0.0, 0.0);\n    y = vec3(0.0, 1.0, 0.0);\n    z = vec3(0.0, 0.0, 1.0);\n    \n    vec3 nx, ny, nz;\n    nx = vec3(0.);//1.0-x;\n    ny = vec3(0.);//1.0-y;\n    nz = vec3(0.);//1.0-z;\n    \n    vec3 cx = ifGt(pos.x,0.)*x + ifLt(pos.x,0.)*nx;\n    vec3 cy = ifGt(pos.y,0.)*y + ifLt(pos.y,0.)*ny;\n    vec3 cz = ifGt(pos.z,0.)*z + ifLt(pos.z,0.)*nz;\n    return vec4(abs(pos.xyz)*(cx + cy + cz), 1.);\n}\n\nRay rayTraceSingleB(\n    vec4 pos,\n    vec4 dir,\n    uint mode,\n    uint pBounce,\n    uint pIter,\n    mat4 xform,\n    mat4 matlight)\n{\n    Ray ray;\n    \n    ray.origin = pos;\n    ray.prevPos = ray.origin;\n    ray.pos = ray.origin;\n    ray.hitPos = ray.origin;\n    \n    ray.hitDist = 0.;\n    \n    ray.dir.xyz = normalize(dir.xyz);\n    ray.dir.w = 1.0;\n    \n    ray.iter = pIter;\n    ray.bounce = pBounce++;\n    \n    ray.hit = false;\n    ray.objIdx = -1u;\n    \n    ray.illum = vec3(0.);\n    \n    float theSdf = 0.;\n    float currDist = 0.;\n    float stepSize = 0.;    \n    float tStep = 0.;\n    \n    caldSdfs(ray.pos, mode, xform);\n    theSdf = minSdf(ray.objIdx);\n    ray.hit = rayIsHit(ray.objIdx, mode);\n      \n    float dsq = maxDist*maxDist;\n    while(\n        (ray.iter==-1u||ray.iter<maxIter)\n        &&\n        dot(ray.hitPos,ray.hitPos)<dsq\n        &&\n        !ray.hit\n    ){\n        ray.iter++;\n        \n        stepSize = maxRayStep(ray, theSdf, mode, matlight);\n        tStep = tStep< minIllumStep && stepSize < minIllumStep\n            ? tStep+stepSize\n            : stepSize;\n        \n        vec3 stepOffset = ray.dir.xyz * stepSize;   \n        \n        ray.hitDist += stepSize;\n        \n        ray.prevPos = ray.pos;\n        \n        ray.pos.xyz += stepOffset;        \n        ray.hitPos.xyz += stepOffset;         \n       \n \n                \n        caldSdfs(ray.pos, mode, xform);\n        \n        theSdf = minSdf(ray.objIdx);\n        ray.hit = rayIsHit(ray.objIdx,mode);      \n    };\n    \n    return ray;\n}\n\n// UPDATE BELOW ONE ONLY AND COPY ABOVE AFTER\nRay rayTraceSingle(\n    vec4 pos,\n    vec4 dir,\n    uint mode,\n    uint pBounce,\n    uint pIter,\n    mat4 xform,\n    mat4 matlight,\n    sampler2D iChannel0,\n    float aspect)\n{\n    Ray ray;\n    \n    ray.origin = pos;\n    ray.prevPos = ray.origin;\n    ray.pos = ray.origin;\n    ray.hitPos = ray.origin;\n    \n    ray.hitDist = 0.;\n    \n    ray.dir.xyz = normalize(dir.xyz);\n    ray.dir.w = 1.0;\n    \n    ray.iter = pIter;\n    ray.bounce = pBounce++;\n    \n    ray.hit = false;\n    ray.objIdx = -1u;\n    \n    ray.illum = vec3(0.);\n    \n    float theSdf = 0.;\n    float currDist = 0.;\n    float stepSize = 0.;    \n    float tStep = 0.;\n    \n    caldSdfs(ray.pos, mode, xform);\n    theSdf = minSdf(ray.objIdx);\n    ray.hit = rayIsHit(ray.objIdx, mode);\n      \n    float dsq = maxDist*maxDist;\n    while(\n        (ray.iter==-1u||ray.iter<maxIter)\n        &&\n        dot(ray.hitPos,ray.hitPos)<dsq\n        &&\n        !ray.hit\n    ){\n        ray.iter++;\n        \n        stepSize = maxRayStep(ray, theSdf, mode, matlight);\n        tStep = tStep< minIllumStep && stepSize < minIllumStep/2.\n            ? tStep+stepSize\n            : stepSize;\n        \n        vec3 stepOffset = ray.dir.xyz * stepSize;   \n        \n        ray.hitDist += stepSize;\n        \n        ray.prevPos = ray.pos;\n        \n        ray.pos.xyz += stepOffset;        \n        ray.hitPos.xyz += stepOffset;         \n       \n        if(/*true==false &&*/ mode==0u && tStep==stepSize){\n            // shoot ray from light to me, if not hit me i dark\n            \n            vec3 lightOffs = (ray.hitPos-lightPos).xyz;   \n            float dOffs = dot(lightOffs, lightOffs);\n            float lOffs = sqrt(dOffs);\n            float iF = 0.5*(tStep/(10.+dOffs))*10.;\n            vec3 lightDir = lightOffs/lOffs;\n            \n            //Ray shadowRay = rayTraceSingleB(lightPos, vec4(lightDir,0.), 1u, -1u,-1u, xform, matlight);\n           \n        highp    vec4 uv = rayPosToClip(ray.hitPos, matlight);\n            \n            uv.xyz /= uv.w;\n          //  vec3 onColor = vec3(sx*sy);\n           /* vec3 onColor = vec3(min(min(rangeOutside(uv.x, -uv.w, 0.),\n            rangeOutside(uv.y, -uv.w, 0.)),\n            rangeOutside(uv.z, -uv.w, 0.)));*/\n            vec4 texel = texture(iChannel0, .5+.5*uv.xy);\n            \n            \n            vec3 onColor = 10.*texel.xyz*(1.0/dOffs)\n            *isBetweenPN(uv.x,1.)\n            *isBetweenPN(uv.y,1.)\n            *isBetweenPN(uv.z,1.);\n            \n            float x =  texel.a;\n            float map =x;// 2.*x*x-1.;\n    \n            float sF= map >= uv.z /* (shadowRay.hitDist*shadowRay.hitDist) >= dOffs*/\n                ? pow(dot(-lightDir,normalize(lightPos.xyz)),20.) \n                : smoothstep(0.,pow(dot(lightDir,normalize(lightPos.xyz)),20.)\n                        , 5.-ray.hitDist);\n             \n               \n            vec3 leDot = vec3(dot(-normalize(lightOffs),ray.dir.xyz));\n            vec3 tIllum = clamp(0.75*iF*sF*vec3(leDot),0.,1.);\n            \n            tIllum += clamp(0.25*iF*sF*vec3(-leDot),0.,1.);\n            \n            \n            ray.illum += \n            onColor\n            *tIllum\n            *Beers(muFog,ray.hitDist); \n               \n        }\n                \n        caldSdfs(ray.pos, mode, xform);\n        \n        theSdf = minSdf(ray.objIdx);\n        ray.hit = rayIsHit(ray.objIdx,mode);      \n    };\n    \n    return ray;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "mat4 mc[4];\n\nvec2 rotate(in vec2 uv, in float angle){\n    uv = vec2(\n        uv.x*cos(angle)+uv.y*sin(angle),\n        uv.y*cos(angle)-uv.x*sin(angle)\n    );\n    return uv;\n}\n\nvec2 prismOffset(in vec2 uv, in float radius, in float scale, in float angle){\n    uv *= scale;\n    uv += vec2(\n        radius*sin(angle),\n        radius*cos(angle)\n    );\n    return uv;\n}\n\n\nvec2 animOffset(in vec2 uv, in float offset){\n   uv.x += 0.1*sea_octave(uv*10.+offset, iTime, 1.)-0.05;\n   uv.x += 0.05*sea_octave(uv*20.+offset+30., iTime,10.)-0.025;\n   \n   \n   uv.y += 0.1*sea_octave(uv*10.+offset, iTime,6.)-0.05;\n   uv.y += 0.05*sea_octave(uv*20.+offset+11., iTime,10.)-0.025;\n   return uv;\n}\n\n\nvec3 circle(in vec2 uv, in float radius, in float feather){\n    float sdf = length(uv)-radius;\n    return vec3(smoothstep(-feather, feather, -sdf));\n}\n\nvec3 fan(in vec2 uv, in float splits, in float a, in float b){\n    float angle = acos(dot(normalize(uv),vec2(0.,1.)));\n    return vec3(smoothstep(a,b,cos(splits*angle)*.5+.5));\n}\n\nvec3 intensity(in vec2 uv){\n    return circle(uv, 0.95, 0.05);\n}\n\nvec3 colorwheel(in vec2 uv, in float color)\n{\n    // some imaginary 12-plus-open color palette\n    vec3 colors[13] = vec3[](\n        vec3(1.,1.,1.),\n        vec3(1.,0.,0.),\n        vec3(1.,.6,0.),\n        vec3(1.,1.,0.),\n        vec3(.6,1.,0.),\n        vec3(0.,1.,0.),\n        vec3(0.,1.,.6),\n        vec3(0.,1.,1.),\n        vec3(0.,.6,1.),\n        vec3(0.,0.,1.),\n        vec3(.6,0.,1.),\n        vec3(.1,0.,1.),\n        vec3(.1,0.,.6)\n    );\n    float nColors = 13.;\n    \n    // simulate color wheel, offset center from center of beam\n    \n    // d*tan(PI/2/colors) must be > 1\n    uv += vec2(0.,1.125/tan(PI*2.0/nColors));\n    uv = rotate(uv, PI/2.);\n    color -= atan(uv.y/uv.x);\n    \n    // calculate fake color edge with some feathering (more exponent is more narrower and more sharper)    \n    float periodic = 2.0*abs(fract(color)-0.5);\n    float multiplier = 1.-pow(periodic, 3.0);\n    \n    // take input parameter and make it integer\n    float colstep = color - fract(color);\n    \n    // generate random offset into color array\n    float colp = mod(hash(vec2(colstep))*nColors*nColors,nColors);\n  \n    // show color(s) w/ edge as needed\n    return multiplier * colors[int(colp)];\n}\n\nvec3 gridcircle(in vec2 uvcolor, in vec2 uv){\n    vec2 ouv = uv;\n    vec3 col = vec3(0);\n    \n    uv = 2.0*abs(fract(uv)-0.5);\n    col += smoothstep(0.98,0.99,vec3(uv.xy,0.0));\n    \n    uv = 2.0*abs(fract(5.0*uv)-0.5);\n    col += 0.66*smoothstep(0.97,0.98,vec3(uv.xy,0.0));\n    \n    uv = 2.0*abs(fract(2.0*uv)-0.5);  \n    col += 0.33*smoothstep(0.9,0.95,vec3(uv.xy,0.0));\n    \n    vec3 mcol = (sign(ouv.x)/2.0+0.5) * vec3(1.,0.,0.)\n    +(-sign(ouv.x)/2.0+0.5) * vec3(0.,1.,1.)\n    +(sign(ouv.y)/2.0+0.5) * vec3(0.,1.,0.)\n    +(-sign(ouv.y)/2.0+0.5) * vec3(1.,0.,1.);\n    // positive: red/green\n    // negative: cyan, magenta\n    \n    mcol *= col;\n    mcol.x = mcol.x + mcol.y+mcol.z;\n    \n    return  colorwheel(uvcolor, iTime*10.0)*circle(ouv,0.75,0.125)*clamp(mcol.x, 0.,1.);\n    //*col*mcol*clamp(1.0-length(ouv),0.,1.);\n}\n\nvec3 basebeam(in vec2 uvcolor, in vec2 uvgobo){\n    vec2 ouv = uvgobo;\n    vec3 col = vec3(0);\n   \n   \n    vec3 gobo0 = circle(uvgobo, .8, .15);\n    gobo0 = clamp(gobo0, 0., 1.);\n    \n    vec3 gobo1 = fan(uvgobo, 8.,.9,1.)-circle(uvgobo, .66, .05);    \n    gobo1 = clamp(gobo1, 0., 1.);\n    \n    \n    vec3 gobo2 =  circle(uvgobo, .8, .15)\n    *clamp(sign(2.*abs(fract(2.*uvgobo.y))-1.5),0.,1.)\n    *clamp(sign(2.*abs(fract(2.*uvgobo.x))-1.5),0.,1.);\n    gobo2 = clamp(gobo2, 0., 1.);\n    \n    switch(int(iTime)/10%3)\n    {\n     case 0:\n    return  intensity(uvcolor)*colorwheel(uvcolor, iTime/4.)*gobo0;\n     case 1:\n    return  intensity(uvcolor)*colorwheel(uvcolor, iTime/4.)*gobo1;\n     case 2:\n    return  intensity(uvcolor)*colorwheel(uvcolor, iTime/4.)*gobo2;\n    }\n    //*col*mcol*clamp(1.0-length(ouv),0.,1.);\n}\n\nvec3 animbeam(in vec2 uv, in float goboAngle, in int anim){\n            vec2 uvcolor, uvgobo;\n            vec2 tuv;\n            const float nAnimSamples = 16.;\n            float animScale = 1.0/nAnimSamples;\n    switch(anim){\n        case 0:\n            uvcolor = uv;\n            uvgobo = rotate(uv, goboAngle);\n            return basebeam(uvcolor, uvgobo);\n        case 1:\n        {\n            vec3 stage = vec3(0.);\n            mat4 rotate = identity();\n            rotate = rotateZ(rotate, goboAngle);\n            vec4 uvr;\n            for(float n = 0.; n < nAnimSamples; n++){\n                uvcolor = animOffset(uv, n);\n                uvr = vec4(uvcolor, 0., 0.);\n                uvr *= rotate;\n                uvgobo=uvr.xy;\n                //uvgobo = rotate(uvcolor,goboAngle);\n                stage += animScale * basebeam(uvcolor, uvgobo);\n            }\n            return stage;\n        }\n    }\n}\nvec3 mainFull(in vec2 uv){\n    const float offs3face = 1.2;\n    const float scale3face = 1.0+offs3face;\n    \n    const int anim = 1;\n    float goboAngle = iTime/4.;\n    \n    vec2 offs3face_1 = prismOffset(uv, offs3face, scale3face, iTime/6. + 0.);\n    vec2 offs3face_2 = prismOffset(uv, offs3face, scale3face, iTime/6. + PI/1.5);\n    vec2 offs3face_3 = prismOffset(uv, offs3face, scale3face, iTime/6. + 2. * PI/1.5);\n    \n    vec3 stage =\n        0.33*animbeam(offs3face_1,goboAngle,anim) +\n        0.33*animbeam(offs3face_2,goboAngle,anim) +\n        0.33*animbeam(offs3face_3,goboAngle,anim) ;\n        \n    return stage*circle(uv,0.95,0.05);\n}\n\n\n// screenquad uv to center-origin aspect-correct -n..n x -1..1\nvec2 toFillVertical(in vec2 uv){\n    // origin center of screen\n    uv -= 0.5;\n    uv *= 2.;\n\n    // 0....1.nnnnn horizontal\n    float aspect = iResolution.x/iResolution.y;     \n    uv.x *= aspect;\n    \n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 0..1 but aspect is wrong    \n    vec2 uv = fragCoord/iResolution.xy;\n\n    // -1.nnn - 1.nnnn x -1...1\n    uv = toFillVertical(uv);\n   \n    fragColor = vec4(exposure(mainFull(uv),1.0,5.0),1.0);\n    \n    // BELOW IS DEPTH PASS\n    \n  \n    // world space light position\n    lightPos = vec4(\n        4.*sin(iTime/5.)+(1.+0.5*sin(iTime/6.)),\n        2.*sin(iTime/4.),\n        4.*cos(iTime/5.)+(1.+0.5*sin(iTime/6.)),\n        1.\n    );\n    \n    \n    uv = fragCoord/iResolution.xy;    \n    vec4 ndc = vec4(uv*2.-1., 1., -clip.y);// image plane in clip space\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    mat4 lookatMat = lookAt(identity(), (lightPos).xyz, (vec4(0.,0.,0.,1.)).xyz);\n    \n    model = rotateY(identity(), -fract(iTime/12.)*PI2); // model space -> world space\n    //view = translate(identity(), -camPos.xyz); // world space -> camera space\n   view=lookatMat;\n   proj = perspfov(aspect, clip, 40.); // camera -> clip\n    \n    invmodel = inverse(model);\n    invview = inverse(view);\n    invproj = inverse(proj);\n    \n    \n    mat4 matLight = proj*lookatMat;\n    \n    mat4 mrot = rotateX(identity(), 45.*d2r+iTime*.5);\n    mrot *= rotateZ(identity(), 45.*d2r+iTime*1.666*.5);\n    mat4 irot = inverse(mrot);\n    \n    xf1 = mrot*model;\n    xf2 = mrot * xf1;\n    ixf1 = inverse(xf1);\n    ixf2 = inverse(xf2);\n    \n    vec4 pos = inverse(view)*vec4(0.,0.,0.,1.);\n   \n    vec4 dir = ndc;//ndcToClip(ndc, proj); // is now clip space image plane \n    \n    dir.xyz *= dir.w;\n    dir = inverse(proj*view) * dir; // is now view space image plane, camera at origin\n    dir -= pos;\n    dir=normalize(dir);\n      \n    Ray result = rayTraceSingle(pos, dir, 1u, -1u,-1u, mrot, matLight, iChannel0, aspect);\n\n    vec3 tColor = vec3(0.);\n    float T;\n    \n    highp vec4 rp = proj*view*result.hitPos;\n    rp.xyz /= rp.w;\n    \n    float x =  rp.z;\n    float map = x;//((x/2.+.5))/sqrt((x/2.+.5));\n    fragColor.w = map;\n    //fragColor = vec4(uv, 0., 1.);   \n   //fragColor = vec4(vec3(abs(dir.z)), 1.);\n    //vec4 t = inverse(proj*view)*ndc;\n    //t.xyz /= t.w;\n   // fragColor = vecToColor(dir);  \n  //  fragColor = vec4(dir.xyz*200.,2.);\n      //  fragColor = texture(iChannel0, uv)+vec4(0.5+0.5*vec3((result.hitDist-clip.x)/(clip.y-clip.x)*.5),1.);\n /*   fragColor = vec4(\n        abs(model*camPos/length(camPos.xyz)\n    ));;*/\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}