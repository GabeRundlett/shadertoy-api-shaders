{
    "Shader": {
        "info": {
            "date": "1615404606",
            "description": "Path Traced Minecraft ( :",
            "flags": 32,
            "hasliked": 0,
            "id": "fds3zr",
            "likes": 9,
            "name": "Minecraft RTX on",
            "published": 3,
            "tags": [
                "minecraft"
            ],
            "usePreview": 0,
            "username": "me_123",
            "viewed": 853
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float pi = 3.1415926536;\nconst float fov = 2.2;\nconst float threshold = 0.5;\nconst float clouds_threshold = 0.525;\nconst float sun_movement = 0.1;\nconst vec3 eye_movement = vec3(-4.0, 0.0, -1.0);\nconst vec3 cloud_movement = vec3(-1.0, 0.0, -1.5);\nconst vec3 eye_start = vec3(-40.0, 10.0, 20.0);\n\nvec3 sun_dir;\nvec3 eye;\nvec3 clouds_offset;\n\nfloat sq(float x) { return x * x; }\nfloat sq(vec2 x) { return dot(x, x); }\nfloat sqi(float x) { return 1.0 - sq(1.0 - x); }\nfloat sqi(vec2 x) { return 1.0 - sq(1.0 - x); }\n\nvec3 background(vec3 d)\n{\n\tconst float sun_intensity = 1.0;\n    vec3 sun = (pow(max(0.0, dot(d, sun_dir)), 48.0) + pow(max(0.0, dot(d, sun_dir)), 4.0) * 0.25) * sun_intensity * vec3(1.0, 0.85, 0.5);\n    vec3 sky = mix(vec3(0.6, 0.65, 0.8), vec3(0.15, 0.25, 0.65), d.y) * 1.15;\n    return sun + sky;\n}\n\nfloat noise(vec3 p)\n{\n    return textureLod(iChannel1, p, 0.0).x;\n}\n\nfloat cnoise(vec3 p)\n{\n    vec3 size = 1.0 / vec3(textureSize(iChannel1, 0));\n    return clamp((\n        noise(p * size * 1.0 + vec3(0.52, 0.78, 0.43)) * 0.5 + \n        noise(p * size * 2.0 + vec3(0.33, 0.30, 0.76)) * 0.25 + \n        noise(p * size * 4.0 + vec3(0.70, 0.25, 0.92)) * 0.125) * 1.0, 0.5, 1000.0);\n}\n\nbool voxel(vec3 vp)\n{\n    return cnoise(vp * 0.05) + vp.y * -0.02 > threshold; \n}\nstruct TraceResult\n{\n    vec3 vp;\n    vec3 p;\n    vec3 n;\n    float r;\n    bool hit;\n};\n\nTraceResult traceVoxel(vec3 p, vec3 d, float dist)\n{\n    TraceResult r;\n    r.hit = false;\n    r.n = -d;\n    r.r = dist;\n\n    vec3 id = 1.0 / d;\n    vec3 sd = sign(d);\n    vec3 nd = max(-sd, 0.0);\n    vec3 vp = floor(p) - nd * vec3(equal(floor(p), p));\n\n    for (int i = 0; i < 500; ++i)\n    {\n        if (dist <= 0.0 || d.y > 0.0)\n        \tbreak;\n\n        if (voxel(vp))\n        {\n\t\t\tr.vp = vp;\n\t\t\tr.p = p;\n\t\t\tr.r = dist;\n\t\t\tr.hit = true;\n\t\t\treturn r;\n        }\n\n        vec3 n = mix(floor(p + 1.0), ceil(p - 1.0), nd);\n\t\tvec3 ls = (n - p) * id;\n\t\tfloat l = min(min(ls.x, ls.y), ls.z);\n\t\tvec3 a = vec3(equal(vec3(l), ls));\n\n        p = mix(p + d * l, n, a);\n        vp += sd * a;\n        r.n = -sd * a;\n        dist -= l;\n    }\n\n    return r;\n}\nfloat hash(vec2 p) {\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nfloat hash3(vec3 pp) {\n    vec2 p = pp.xy+(pp.z/100.);\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nvec4 boxmap( in sampler2D s, in vec3 p, in vec3 n, in float k )\n{\n    // project+fetch\n    vec4 x = texture( s, p.yz );\n    vec4 y = texture( s, p.zx );\n    vec4 z = texture( s, p.xy );\n    \n    // blend factors\n    vec3 w = pow( abs(n), vec3(k) );\n    // blend and return\n    return (x*w.x + y*w.y + z*w.z) / (w.x + w.y + w.z);\n}\nvec3 rus(vec2 seed) {\n    float u = hash(seed);\n    float v = hash(seed+2.);\n    float theta = u * 2.0 * 3.1415;\n    float phi = acos(2.0 * v - 1.0);\n    float r = pow(hash(seed+10.), 0.3333333);\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    float x = r * sinPhi * cosTheta;\n    float y = r * sinPhi * sinTheta;\n    float z = r * cosPhi;\n    return vec3(x, y, z);\n}\nfloat s = 100.;\nvec3 ray(vec3 p, vec3 d, vec2 seed)\n{\n    const float view_distance = 300.0;\n    vec3 color = vec3(1);\n    vec3 ro = p;\n    vec3 rd = d;\n    float occ = 1.0;\n    vec3 sun = normalize(vec3(-3., 5, -0));\n    for (int i = 0; i < 2; i += 1) {\n        occ /= 2.0;\n        TraceResult r = traceVoxel(ro, rd, view_distance);\n        if (!r.hit) {\n            color *= texture(iChannel3, rd).xyz;\n            break;\n        }\n        if (r.vp.y >= -0.) {\n            if (r.vp.y >= 1.) {\n                color *= boxmap(iChannel0, r.p, r.n, 1.0).xyz;//((texture(iChannel0, r.p.xz).xyz)+(texture(iChannel0, r.p.xy).xyz))/2.0;\n            } else {\n                color *= 0.2;\n            }\n            vec3 target = r.p + r.n + rus(rd.xy+float(i)+seed);\n            rd = target - r.p;\n        } else {\n            color *= vec3(1.0, 0.5, 0.125)*texture(iChannel0, r.p.xz).xyz*10.0;\n            rd = reflect(rd, r.n);\n            break;\n        }\n        ro = r.p;\n    }\n    return color;//vec3(r.hit : r.n ? 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    eye = eye_start + vec3(0.01) + mod(eye_movement * 0., 640.0);\n\n    float ry = iMouse.x / iResolution.x * pi * 2.0 + pi * 0.85;\n    float rx = -iMouse.y / iResolution.y * pi * 0.5 + pi * 0.95;\n\n    vec4 cs = cos(vec4(ry, rx, ry - pi * 0.5, rx - pi * 0.5));\n    vec3 forward = -vec3(cs.x * cs.y, cs.w, cs.z * cs.y);\n\tvec3 up = vec3(cs.x * cs.w, -cs.y, cs.z * cs.w);\n\tvec3 left = cross(up, forward);\n\n\tvec2 uv = fov * (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;\n    vec3 dir = normalize(vec3(forward + uv.y * up + uv.x * left));    \n    vec3 color = ray(eye, dir, uv+iTime);\n    if (iMouse.z < 0.01) {\n        fragColor = ((texture(iChannel2, fragCoord.xy/iResolution.xy)*s) + vec4(color, 1))/(s+1.0);\n    } else {\n        fragColor = vec4(color, 1);\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}