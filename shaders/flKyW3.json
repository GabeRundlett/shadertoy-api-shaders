{
    "Shader": {
        "info": {
            "date": "1662345194",
            "description": "I tried to add shading to the Paraboloid, somewhat successful, there are many glitches though. This mainly tests if the SDF is right. As the time passes, the sides of the shape keeps growing, like a Paraboloid should.",
            "flags": 0,
            "hasliked": 0,
            "id": "flKyW3",
            "likes": 1,
            "name": "010 - Paraboloid SDF Shading",
            "published": 3,
            "tags": [
                "mouse",
                "sdf",
                "begginer",
                "paraboloid"
            ],
            "usePreview": 0,
            "username": "PiGIon",
            "viewed": 258
        },
        "renderpass": [
            {
                "code": "// 2022.09.04\n\n#define PI 3.14159265\n\n// rayMarch\n// returns the vector that hit the geometry\nvec3 rayMarch(vec3 origin, vec3 direction);\n\nvec3 mouseRot(vec3 v);\n\n// SDF main function\n// calculates distance from items in the scene\nfloat SDF();\n\nvec2 mouseScale;\nvec2 uv;\n\n// sined distance function of a paraboloid at Z\n// https://en.wikipedia.org/wiki/Signed_distance_function\nfloat paraboloidZSDF(vec2 o, vec3 p, float a, float b) {\n    float z = (pow(p.x - o.x, 2.)/pow(a, 2.)) + (pow(p.y - o.y, 2.)/pow(b, 2.));\n\n    return z - p.z;\n}\n\nfloat planeSDF(float y, vec3 p) {\n    return p.y - y;\n}\n\nfloat SDF(vec3 p) {\n    return min(\n            paraboloidZSDF(vec2(0., 0.), p, 1., 1.),\n            planeSDF(-5., p)\n            );\n}\n\nvec3 getNormal(vec3 p) {\n    float d = SDF(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        SDF(p - e.xyy),\n        SDF(p - e.yxy),\n        SDF(p - e.yyx));\n    \n    return normalize(n);\n}\n\nfloat light(vec3 o, vec3 view) {\n    vec3 l = normalize(o - view);\n    vec3 n = getNormal(view);\n    float distView = length(o - view);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    \n    float d = length(rayMarch(view + n * 0.02, l));\n    if (d < distView) dif *= .5;\n    \n    return dif;\n}\n\nvec3 rayMarch(vec3 o, vec3 d) {\n    vec3 ray;\n    vec3 mouseDir = d;\n    float t = 0.;\n\n    for (int i = 0; i < 128; i++) {\n        ray = o + mouseDir * t;\n\n        float dist = SDF(ray);\n\n    \tif(dist < 0.001) break;\n\n\t\tt += dist;\n    }\n    \n    return ray;\n}\n\n// initializes global vars\nvoid init(vec4 fragColor, vec2 fragCoord) {\n    mouseScale = vec2((iMouse.x / iResolution.x) - 0.5, (iMouse.y / iResolution.y) - 0.5);\n    \n    // if scene started, defaults to middle of screen mouse\n    if (length(iMouse) == 0.) {\n        mouseScale = vec2(((iResolution.x/2.) / iResolution.x) - 0.5, ((iResolution.y/2.) / iResolution.y) - 0.5);\n    }\n    \n    uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    init(fragColor, fragCoord);\n    \n\n    vec3 dir = normalize(vec3(uv, 1.));\n    vec3 eyes = vec3(0, 2., -5. + iTime/1.);\n    vec3 lightPos = vec3(2., 2., -4);\n    \n    eyes.xy += mouseScale * 10.;\n    lightPos.xy += mouseScale * 10.;\n    \n\n    // gest the vector where it was hit\n    vec3 hit = rayMarch(eyes, normalize(vec3(uv, 1.)));\n    \n    float l = light(lightPos, hit);\n    \n\n    fragColor = vec4(vec3(l), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}