{
    "Shader": {
        "info": {
            "date": "1486346428",
            "description": "Showing not one but all corner problem areas in BÃ©zier spline distance fields in [url=https://www.shadertoy.com/view/MlVSWc]SVG viewer[/url] by FabriceNeyret2",
            "flags": 0,
            "hasliked": 0,
            "id": "4lySWd",
            "likes": 11,
            "name": "SVG debug aid",
            "published": 3,
            "tags": [
                "distance",
                "debug",
                "meter",
                "svg",
                "discontinuous"
            ],
            "usePreview": 0,
            "username": "TimoKinnunen",
            "viewed": 1354
        },
        "renderpass": [
            {
                "code": "////////////////////////////\n//\n// SVG Distance field discontinuities\n//\n// Adapting svg viewer / nVidia logo by FabriceNeyret2\n// @ https://www.shadertoy.com/view/MlVSWc\n//\n// And utilizing distance meter by cupe\n// @ https://www.shadertoy.com/view/ldK3zD\n\n//#define SHOW_GLITCH\n#define IMPROVE_ACCURACY\n#define REPLACE_ZERO_DISTANCE\n\n// splines discretization. Lower it on slow GPUs\nconst float N = 20.;\nvec2 uv;\nvec2 interpolate(vec2 G1, vec2 G2, vec2 G3, vec2 G4, float t);\nvoid pnpolyAdd(vec2 p, vec2 a, vec2 b);\nfloat fOpUnion(float a, float b);\nfloat fLineSegment(vec2 p, vec2 a, vec2 b);\n\nvoid bezier(vec2 A, vec2 B, vec2 C, vec2 D) {\n\tvec2 p = A;\n#ifdef SHOW_GLITCH\n\t\tfor(float t = 1.; t<= N; t++) {\n\t\t\t// The expression t/N here is problematic.\n\t\t\t// As division is expensive, the compiler\n\t\t\t// is allowed to instead do it as t*(1./N).\n\t\t\t// (1./N) for N=20 is about 0.050, or more\n\t\t\t// precisely 0.0500000007450580596923828125.\n\t\t\t// Multiplied by 20, before rounding that's\n\t\t\t// 1.00000001490116119384765625 which the\n\t\t\t// compiler can round freely to 1.0 or\n\t\t\t// something else. A gap between edges would\n\t\t\t// then be the result. This isn't the cause\n\t\t\t// of the glitch in this case, however...\n\t\t\tvec2 q = interpolate(A,B,C,D,t/ N);\n\t\t\tpnpolyAdd(uv,p,q);\n\t\t\tp = q;\n\t\t}\n#else\n\t\tfor(float t = 1.; t< N; t++) {\n\t\t\tvec2 q = interpolate(A,B,C,D,t/ N);\n\t\t\tpnpolyAdd(uv,p,q);\n\t\t\tp = q;\n\t\t}\n\t\tpnpolyAdd(uv,p,D);\n#endif\n}\n\n// --- spline interpolation ( inspired from revers https://www.shadertoy.com/view/MlGSz3 )\nvec2 interpolate(vec2 G1, vec2 G2, vec2 G3, vec2 G4, float t) {\n\tvec2 A = G4- G1+ 3.* (G2- G3),B = 3.* (G1- 2.* G2+ G3),C = 3.* (G2- G1),D = G1;\n\t// When t=1, we would expect to get G4 from this\n\t// and mathematically speaking that's what we'd\n\t// get too as everything else cancels out. But\n\t// the route leading to G4 is not so simple and\n\t// straight-forward. For G4 to be the result,\n\t// G4-G1 needs to be calculated without causing\n\t// round-off. In addition, an expression like\n\t// 3.*(G2-G1) is problematic, as multiplying\n\t// something by 3 requires something to have 1\n\t// unused mantissa bit or else round-off will\n\t// again occur.\n\treturn t* (t* (t* A+ B)+ C)+ D;\n}\n\n// constants and stuff\n\n#define int1 int\n#define float1 float\n#define mul( a , b ) (a) * (b)\n#define div( a , b ) (a) / (b)\n#define add( a , b ) (a) + (b)\n#define sub( a , b ) (a) - (b)\n\n// === SVG Player ====      short spec: https://www.w3.org/TR/2008/REC-SVGTiny12-20081222/paths.html\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float INFINITY = 1e38;\nconst float FILL = 1.,CONTOUR = 0.,DIR = 1.,INDIR = -1.;\nfloat _d = INFINITY;\nfloat _x,_y,x0,y0;\n\nvec4 COL = vec4(0);\nfloat fill = FILL,dir = DIR,contrast = 1.;  // style state\n\nfloat saturate(float x) {\n\treturn clamp(x,0.,1.);\n}\nfloat fOpUnion(float a, float b) {\n\treturn min(a,b);\n}\n// Distance to line segment between a and b\nfloat fLineSegment(vec2 p, vec2 a, vec2 b) {\n\tvec2 ab = b- a;\n\tfloat t = saturate(dot(p- a,ab)/ dot(ab,ab));\n\treturn length((ab* t+ a)- p);\n}\n//rotate p.x towards p.y by a radians\nvec2 pR(vec2 p, float a) {\n\treturn cos(a)* p+ sin(a)* vec2(p.y,-p.x);\n}\n// The original version of _pnpoly_ is available @\n// https://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html or @\n// http://web.archive.org/web/20161116163747/https://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n//\n// Copyright (c) 1970-2003, Wm. Randolph Franklin\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n// Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimers.\n// Redistributions in binary form must reproduce the above copyright notice in the documentation and/or other materials provided with the distribution.\n// The name of W. Randolph Franklin may not be used to endorse or promote products derived from this Software without specific prior written permission.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\nbool pInPoly = false;\nfloat pInPolyDist = INFINITY;\nvoid pnpolyAdd(vec2 p, vec2 a, vec2 b) {\n#ifdef IMPROVE_ACCURACY\n\t\t// To improve the accuracy of the polygon insidedness test\n\t\t// and making the result consist with the distance field\n\t\t// gradient, the division forcing 2 things into the same\n\t\t// magnitude can be replaced with multiplication, making\n\t\t// sure not to flip signs in the process. After rearranging\n\t\t// the result is the same as in the algorithm\n\t\t// CrossingsMultiplyTest by Eric Haines @\n\t\t// http://www.realtimerendering.com/resources/GraphicsGems//gemsiv/ptpoly_haines/ptinpoly.c\n\t\tpInPoly = pInPoly!= (a.y> p.y!= b.y> p.y&& a.y> b.y!= (a.x- b.x)* (p.y- b.y)< (a.y- b.y)* (p.x- b.x));\n#else\n\t\tpInPoly = pInPoly!= (a.y> p.y!= b.y> p.y&& p.x< ((a.x- b.x)* (p.y- b.y))/ (a.y- b.y)+ b.x);\n#endif\n\tpInPolyDist = fOpUnion(pInPolyDist,fLineSegment(p,a,b));\n}\nfloat pnpolyEnd() {\n#ifdef REPLACE_ZERO_DISTANCE\n\tif(pInPolyDist== 0.) {\n\t\t// Arbitrary, chosen visually to be smaller than values nearby.\n\t\tpInPolyDist = 0.00000001490116119384765625;\n    }\n#endif\n\tfloat result = pInPoly? -pInPolyDist: pInPolyDist;\n\tpInPoly = false;\n\tpInPolyDist = INFINITY;\n\treturn result;\n}\nvoid C(float x1, float y1, float x2, float y2, float x, float y) {\n\tbezier(vec2(_x,_y),vec2(x1,y1),vec2(x2,y2),vec2(x,y));\n\t_x = x;\n\t_y = y;\n}\nvoid M(float x, float y) {\n\tx0 = _x = x;\n\ty0 = _y = y;\n}\nvoid L(float x, float y) {\n\tvec2 a = vec2(_x,_y);\n\tvec2 b = vec2(x,y);\n\tpnpolyAdd(uv,a,b);\n\t_x = x;\n\t_y = y;\n}\nvoid z() {\n\tif(pInPolyDist!= INFINITY) {\n\t\tif(_x!= x0|| _y!= y0) {\n\t\t\tvec2 _xy = vec2(_x,_y);\n\t\t\tvec2 xy0 = vec2(x0,y0);\n\t\t\tpnpolyAdd(uv,_xy,xy0);\n\t\t}\n\t\t_d = fOpUnion(_d,pnpolyEnd());\n\t}\n}\nvoid H(float x) {\n\tL(x,_y);\n}\nvoid V(float y) {\n\tL(_x,y);\n}\nvoid c(float x1, float y1, float x2, float y2, float x, float y) {\n\tC(_x+ x1,_y+ y1,_x+ x2,_y+ y2,_x+ x,_y+ y);\n}\nvoid m(float x, float y) {\n\tM(_x+ x,_y+ y);\n}\nvoid l(float x, float y) {\n\tL(_x+ x,_y+ y);\n}\nvoid h(float x) {\n\tH(_x+ x);\n}\nvoid v(float y) {\n\tV(_y+ y);\n}\n\nvoid Z() {\n\tz();\n}\n\nvoid style(float fillRule, uint rgb, float diection, float contrastBoost) {\n\tfill = fillRule;\n\tdir = diection;\n\tCOL = vec4((rgb>> uint(16))& uint(0xFF),(rgb>> uint(8))& uint(0xFF),rgb& uint(0xFF),1)/ 255.;\n\tcontrast = contrastBoost;\n}\nvoid style(float f, uint c, float d) {\n\tstyle(f,c,d,1.);\n}\nvoid path() {\n\tif(pInPolyDist!= INFINITY) {\n\t\tif(fill> 0.) {\n\t\t\tz();\n\t\t} else {\n\t\t\t_d = fOpUnion(_d,abs(pnpolyEnd()));\n\t\t}\n\t}\n}\n\n// === SVG drawing ===============================================================\n\nfloat fSvgWorldIcon(vec3 p) {\n\t_d = INFINITY;\n\tuv = p.xz;\n    // scaling\n\tuv *= 80.;\n\tuv += vec2(29.-251./ 1024.+240./ 1024./ 2048.,7.-33./ 1024.+475./ 1024./ 2048.);\n\n// SVG by Freepik http://www.flaticon.com/free-icon/world_52349\n#if 1\n\tpath();\n\tstyle(FILL,0x000060u,DIR);  // atlantic ocean\n\tM(28.755,6.968);\n\tl(-0.47,0.149);\n\tL(25.782,7.34);\n\tl(-0.707,1.129);\n\tl(-0.513,-0.163);\n\tL(22.57,6.51);\n\tl(-0.289,-0.934);\n\tL(21.894,4.58);\n\tl(-1.252,-1.123);\n\tl(-1.477,-0.289);\n\tl(-0.034,0.676);\n\tl(1.447,1.412);\n\tl(0.708,0.834);\n\tL(20.49,6.506);\n\tl(-0.648,-0.191);\n\tL(18.871,5.91);\n\tl(0.033,-0.783);\n\tl(-1.274,-0.524);\n\tl(-0.423,1.841);\n\tl(-1.284,0.291);\n\tl(0.127,1.027);\n\tl(1.673,0.322);\n\tl(0.289,-1.641);\n\tl(1.381,0.204);\n\tl(0.642,0.376);\n\th(1.03);\n\tl(0.705,1.412);\n\tl(1.869,1.896);\n\tl(-0.137,0.737);\n\tl(-1.507,-0.192);\n\tl(-2.604,1.315);\n\tl(-1.875,2.249);\n\tl(-0.244,0.996);\n\th(-0.673);\n\tl(-1.254,-0.578);\n\tl(-1.218,0.578);\n\tl(0.303,1.285);\n\tl(0.53,-0.611);\n\tl(0.932,-0.029);\n\tl(-0.065,1.154);\n\tl(0.772,0.226);\n\tl(0.771,0.866);\n\tl(1.259,-0.354);\n\tl(1.438,0.227);\n\tl(1.67,0.449);\n\tl(0.834,0.098);\n\tl(1.414,1.605);\n\tl(2.729,1.605);\n\tl(-1.765,3.372);\n\tl(-1.863,0.866);\n\tl(-0.707,1.927);\n\tl(-2.696,1.8);\n\tl(-0.287,1.038);\n\tc(6.892,-1.66,12.019,-7.851,12.019,-15.253);\n\tC(31.413,12.474,30.433,9.465,28.755,6.968);\n\tz();\n#endif\n#if 1\n\tpath();\n\tstyle(FILL,0x006000u,DIR);  // pacific ocean\n\tM(17.515,23.917);\n\tl(-1.144,-2.121);\n\tl(1.05,-2.188);\n\tl(-1.05,-0.314);\n\tl(-1.179,-1.184);\n\tl(-2.612,-0.586);\n\tl(-0.867,-1.814);\n\tv(1.077);\n\th(-0.382);\n\tl(-2.251,-3.052);\n\tv(-2.507);\n\tL(7.43,8.545);\n\tL(4.81,9.012);\n\tH(3.045);\n\tL(2.157,8.43);\n\tL(3.29,7.532);\n\tL(2.16,7.793);\n\tc(-1.362,2.326,-2.156,5.025,-2.156,7.916);\n\tc(0.,8.673,7.031,15.707,15.705,15.707);\n\tc(0.668,0.,1.323,-0.059,1.971,-0.137);\n\tl(-0.164,-1.903);\n\tc(0.,0.,0.721,-2.826,0.721,-2.922);\n\tC(18.236,26.357,17.515,23.917,17.515,23.917);\n\tz();\n#endif\n#if 1\n\tpath();\n\tstyle(FILL,0x600000u,DIR); // polar sea\n\tM(5.84,5.065);\n\tl(2.79,-0.389);\n\tl(1.286,-0.705);\n\tl(1.447,0.417);\n\tl(2.312,-0.128);\n\tl(0.792,-1.245);\n\tl(1.155,0.19);\n\tl(2.805,-0.263);\n\tL(19.2,2.09);\n\tl(1.09,-0.728);\n\tl(1.542,0.232);\n\tl(0.562,-0.085);\n\tC(20.363,0.553,18.103,0.,15.708,0.);\n\tC(10.833,0.,6.474,2.222,3.596,5.711);\n\th(0.008);\n\tL(5.84,5.065);\n\tz();\n\tM(16.372,1.562);\n\tl(1.604,-0.883);\n\tl(1.03,0.595);\n\tl(-1.491,1.135);\n\tl(-1.424,0.143);\n\tl(-0.641,-0.416);\n\tL(16.372,1.562);\n\tz();\n\tM(11.621,1.691);\n\tl(0.708,0.295);\n\tl(0.927,-0.295);\n\tl(0.505,0.875);\n\tl(-2.14,0.562);\n\tl(-1.029,-0.602);\n\tC(10.591,2.526,11.598,1.878,11.621,1.691);\n\tz();\n#endif\n    // unscaling\n\treturn _d/80.;\n}\n//\n// scale-invariant distance meter\n//\n// be less confused by your distances!\n//\n// (as seen in the screenshots on http://mercury.sexy/hg_sdf/)\n//\n// tries to paint a plane in useful colors. outputs HDR colors, so can easily\n// be integrated into your existing rendering without looking bad.\n//\n//\n\n// the actual SDF:\nfloat f(vec3 p) {\n    return fSvgWorldIcon(p);\n}\n\n// tone mapping stolen from zavie's shader\nvec3 Uncharted2ToneMapping(vec3 color) {\n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\tfloat W = 11.2;\n\tfloat exposure = 2.;\n\tcolor *= exposure;\n\tcolor = ((color* (A* color+ C* B)+ D* E)/ (color* (A* color+ B)+ D* F))- E/ F;\n\tfloat white = ((W* (A* W+ C* B)+ D* E)/ (W* (A* W+ B)+ D* F))- E/ F;\n\tcolor /= white;\n\treturn color;\n}\n\nvec3 fusion(float x) {\n// the meter uses the \"fusion\" gradient, which goes from dark magenta (0) to white (1)\n// (often seen in heatmaps in papers etc)\n\tfloat t = clamp(x,0.0,1.0);\n\treturn clamp(vec3(sqrt(t),t* t* t,max(sin(PI* 1.75* t),pow(t,12.0))),0.0,1.0);\n}\nvec3 fusionHDR(float x) {\n// HDR version\n\tfloat t = clamp(x,0.0,1.0);\n\treturn fusion(sqrt(t))* (0.5+ 2.* t);\n}\n\nvec3 distanceMeter(float dist, float rayLength, vec3 rayDir, float camHeight) {\n// distance meter function. needs a bit more than just the distance\n// to estimate the zoom level that it paints at.\n//\n// if you have real opengl, you can additionally use derivatives (dFdx, dFdy)\n// to detect discontinuities, i had to strip that for webgl\n//\n// visualizing the magnitude of the gradient is also useful\n\tfloat idealGridDistance = 20.0/ rayLength* pow(abs(rayDir.y),0.8);\n\tfloat nearestBase = floor(log(idealGridDistance)/ log(10.));\n\tfloat relativeDist = abs(dist/ camHeight);\n\n\tfloat largerDistance = pow(10.0,nearestBase+ 1.);\n\tfloat smallerDistance = pow(10.0,nearestBase);\n\n\tvec3 col = fusionHDR(log(1.+ relativeDist));\n\tcol = max(vec3(0.),col);\n\tif((dist)< 0.) {\n\t\tcol = col.grb* 3.;\n\t}\n\n\tfloat l0 = (pow(0.5+ 0.5* cos(dist* PI* 2.* smallerDistance),10.0));\n\tfloat l1 = (pow(0.5+ 0.5* cos(dist* PI* 2.* largerDistance),10.0));\n\n\tfloat x = fract(log(idealGridDistance)/ log(10.));\n\tl0 = mix(l0,0.,smoothstep(0.5,1.0,x));\n\tl1 = mix(0.,l1,smoothstep(0.0,0.5,x));\n\n\tcol.rgb *= 0.1+ 0.9* (1.- l0)* (1.- l1);\n\treturn col;\n}\nvec4 mainImage_meter(vec2 fragCoord) {\n\tvec2 reso = iResolution.xy;\n\tvec2 screenCoord = (((2.0* fragCoord)- reso)/ iResolution.y);\n\tfloat camDolly = iMouse.z> 0.? iMouse.y/ iResolution.y: (.5)+ (.5)* sin(iTime* .5);\n\tfloat camRotation = iMouse.z> 0.? iMouse.x/ iResolution.x* PI* (2.)+ PI: (.2)* iTime;\n\tvec3 cam_pos = (vec3(0.0,1.0,1.4)* pow(10.,camDolly* 8.- 8.0));\n\tvec3 cam_dir = normalize(vec3(0.0,-0.8,-1.0));\n\tvec3 cam_up = normalize(vec3(0.0,1.0,-0.8));\n\tcam_up.xz = (pR(cam_up.xz,camRotation));\n\tcam_dir.xz = (pR(cam_dir.xz,camRotation));\n\tcam_pos.xz = (pR(cam_pos.xz,camRotation));\n\tfloat cam_fov = (45.);\n\tvec3 u = cross(cam_dir,cam_up);\n\tvec3 v = cam_up;\n\tvec3 w = -cam_dir;\n\tvec3 o = cam_pos;\n\tvec3 d = vec3(screenCoord,-1.0/ tan(radians(.5*cam_fov)));\n\td = normalize((mat3(u,v,w)* d));\n\tfloat t = INFINITY;\n\tif(d.y< 0.) {\n\t\tt = (o.y)/ -d.y;\n\t}\n\tvec3 p = ((d* t)+ o);\n\tfloat dist = f(p);\n\tvec3 col = distanceMeter(dist,t,d,cam_pos.y);\n\tcol = Uncharted2ToneMapping(col);\n\tvec4 fragColor = vec4(pow(col,vec3(1./ 2.2)),1);\n\treturn fragColor;\n}\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tfragColor = mainImage_meter(fragCoord);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}