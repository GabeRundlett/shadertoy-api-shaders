{
    "Shader": {
        "info": {
            "date": "1575123429",
            "description": "Cybertruck with cracked windows\nALL CREDIT for original Cybertruck and scene goes to BigWIngs/TheArtOfCode: https://www.shadertoy.com/view/wdGXzK\n\nShatter effect inspired by https://www.shadertoy.com/view/XdBSzW",
            "flags": 0,
            "hasliked": 0,
            "id": "3syXWc",
            "likes": 13,
            "name": "Cybertruck Cracked Windows",
            "published": 3,
            "tags": [
                "windows",
                "cracked",
                "cybertruck"
            ],
            "usePreview": 1,
            "username": "Onnowhere",
            "viewed": 1287
        },
        "renderpass": [
            {
                "code": "// Modified by Onnowhere to add cracked windows ðŸ‘Œ\n// Link to original source: https://www.shadertoy.com/view/wdGXzK\n\n// \"Wait.. what? CyberTruck!\" by Martijn Steinrucken aka BigWings/CountFrolic - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n//\n// Music:\n// https://soundcloud.com/weareallsynners/cyberpunk\n//\n// Tesla's insanely cool new pickup truck. I figured it'd be doable because of the angular look\n// Still turned out to be A LOT of work. Code is quite messy as a result, which is quite usual\n// for a version 1 of anything ;)\n//\n// Might do a run through of how this was made on The Art of Code if there is enough interest\n//\n// I have a quite convoluted way of rendering the interior behind the glass. \n// I'm raymarching to the glass and then spawning another raymarch loop for the interior.\n// In hindsight that could have been done better, I think rendering everything without the glass\n// and then rendering the glass on top would have been better. Oww well.\n//\n// If you are not fond of the disco effect, or if you want a better look at the car then\n// I suggest lowering the BEAMS_PER_SECOND, pressing pause or activating MODEL_MODE\n\n// Tweak these!\n#define BEAMS_PER_SECOND 1.85\n#define GROUND_DISPLACEMENT\n//#define MODEL_MODE\n\n\n#define MAX_STEPS 300\n#define MIN_DIST .5\n#define MAX_DIST 60.\n#define SURF_DIST .002\n\n#define S(a, b, t) smoothstep(a, b, t)\n\n#define MAT_BASE 0.\n#define MAT_FENDERS 1.\n#define MAT_RUBBER 2.\n#define MAT_LIGHTS 3.\n#define MAT_GLASS 4.\n#define MAT_SHUTTERS 5.\n#define MAT_GROUND 6.\n#define MAT_CAB 6.\n#define MAT_SHATTERED 7.\n\n\n\nvec3 beamStart, beamEnd, beamCol;\nfloat throughWindow;\n\nfloat rnd(vec2 s)\n{\n    return 1.-2.*fract(sin(s.x*253.13+s.y*341.41)*589.19);\n}\n\nvec2 sdCar(vec3 p) {\n    float matId=MAT_BASE;\n    p.x = sabs(p.x, .5);\t\t// smooth abs to make front rounded\n       \n    // body\n    float d, w;\n    \n    float frontGlass = dot(p.yz, vec2(0.9493, 0.3142))-1.506; // front\n    d = frontGlass;\n    \n    float topGlass = dot(p.yz, vec2(0.9938, -0.1110))-1.407;\n    d = max(d, topGlass); \n    float back = dot(p.yz, vec2(0.9887, -0.16))-1.424;\n    d = max(d, back); // back\n    \n    float side1 = dot(p, vec3(0.9854, -0.1696, -0.0137))-0.580;\n    d = max(d, side1); // side 1\n    \n    float side2 = dot(p, vec3(0.9661, 0.2583, 0.0037))-0.986;\n    //d = max(d, side2);\t\t// side 2\n    d = smin(d, side2, -.005);\n    d = max(d, dot(p, vec3(0.0000, -0.1578, -0.9875))-2.056); // rear\n    d = max(d, dot(p, vec3(0.0952, -0.1171, 0.9885))-2.154);\n    d = max(d, dot(p, vec3(0.5019, -0.1436, 0.8529))-2.051);\n    d = max(d, dot(p, vec3(0.0000, -0.9999, -0.0118))+0.2643); // bottom\n    d = max(d, dot(p, vec3(0.0839, -0.4614, 0.8832))-1.770);\n    d = max(d, dot(p, vec3(0.0247, -0.9653, 0.2599))-0.196);\n    d = max(d, dot(p, vec3(0.0000, -0.9486, -0.3163))-0.295);\n    \n    float body = d;\n    float car = d;\n    if((-frontGlass<car && p.z < 1.8-p.x*p.x*.16 && side2<-.01) ||\n       (abs(-topGlass-car)<.01 && p.z>-.6 && p.z < .5 && side2<-.01)) \n        matId = MAT_GLASS;\n    \n    // bed shutters\n    d = max(p.x-.63, abs(p.z+1.44)-.73);\n    if(d<-.02) matId = MAT_SHUTTERS;\n    \n    d = max(d, (-back-.01)-S(.5,1., sin(p.z*100.))*.0);\n    \n    car = max(car, -d);\n    \n    // bumper\n    d = S(.03, .02, abs(p.y-.55))*.045;\n    d -= S(.55, .52, p.y)*.05;\n    d *= S(1.3, 1.5, abs(p.z));\n    \n    float rB = max(p.x-p.y*.15-.21, .45-p.y);\n    float fB = max(p.x-.51, abs(.42-p.y)-.02);\n    d *= S(.0,.01, mix(rB, fB, step(0.,p.z)));\n   \tif(p.y<.58-step(abs(p.z), 1.2)) matId = MAT_FENDERS;\n    \n    // lights\n    float lt = map01(.5, .8, p.x);\n    float lights = map01(.02*(1.+lt), .01*(1.+lt), abs(p.y-(.82+lt*.03)));\n    lights *= S(2.08, 2.3, p.z);\n\td += lights*.05;\n    lights = map01(.01, .0, side1+.0175);\n    lights *= step(p.z, -2.17);\n    lights *= map01(.01, .0, abs(p.y-1.04)-.025);\n    d += lights*.03;\n    \n    if(d>0.&&matId==0.) matId = MAT_LIGHTS;\n    \n    if(car<.1) d*= .5;\n    car += d;\n    \n    // step\n    car += map(p.y+p.z*.022, .495, .325, 0., .05);//-S(.36, .34, p.y)*.1;\n    d = sdBox(p-vec3(0, .32, 0), vec3(.72+p.z*.02, .03, 1.2));\n    if(d<car) matId = MAT_FENDERS;\n    car = min(car, d);\n    \n    // windows Holes\n    vec2 P = p.yz;\n    d = w = dot(P, vec2(-0.9982, -0.0601))+1.0773;\n    d = max(d, dot(P, vec2(0.1597, -0.9872))-0.795);\n    d = max(d, dot(P, vec2(0.9931, -0.1177))-1.357);\n    d = max(d, dot(P, vec2(0.9469, 0.3215))-1.459);\n    //d = max(d, -.03-side2);\n    float sideWindow = dot(p, vec3(-0.9687, -0.2481, 0.0106))+0.947;\n    sideWindow = map01(0., 1., p.y-1.)*.05;\n    if(d<-.005) matId = MAT_SHATTERED;\n    \n    \n    d = max(d, sideWindow);\n    car = max(car, -d);\n    \n    // panel lines\n    if(car<.1) {\n    \td = abs(dot(p.yz, vec2(0.0393, 0.9992))+0.575);\n        d = min(d, abs(dot(p.yz, vec2(0.0718, 0.9974))-0.3));\n        d = min(d, abs(p.z-1.128));\n        float panels = S(.005, .0025, d) * step(0., w) * step(.36, p.y);\n        \n        float handleY = dot(p.yz, vec2(-0.9988, -0.0493))+0.94;\n        d = S(.02, .01, abs(handleY))*S(.01, .0, min(abs(p.z-.4)-.1, abs(p.z+.45)-.1));\n        panels -= abs(d-.5)*.5;\n        \n        // charger\n        d = S(.02, .01, abs(p.y-.81)-.04)*S(.01, .0, abs(p.z+1.75)-.12);\n        panels += abs(d-.5)*.5;\n        \n        d = S(.005, .0, abs(side2+.015));\n        d *= S(.03, .0, abs(frontGlass));\n        panels += d;\n        \n        car += panels *.001;\n    }\n    \n    // fenders\n    //front\n    d = dot(p, vec3(0.4614, 0.3362, 0.8210))-2.2130;\n    d = max(d, dot(p, vec3(0.4561, 0.8893, 0.0347))-1.1552);\n    d = max(d, dot(p, vec3(0.4792, 0.3783, -0.7920))+0.403);\n    d = max(d, dot(p, vec3(0.4857, -0.0609, -0.8720))+0.6963);\n    d = max(d, dot(p, vec3(0.4681, -0.4987, 0.7295))-1.545);\n    d = max(d, .3-p.y);\n    d = max(d, abs(p.x-.62-p.y*.15)-.07);\n    if(d<car) matId = MAT_FENDERS;\n    car = min(car, d);\n    \n    // back\n    d = dot(p, vec3(0.4943, -0.0461, 0.8681))+0.4202;\n    d = max(d, dot(p, vec3(0.4847, 0.4632, 0.7420))+0.0603);\n    d = max(d, dot(p, vec3(0.4491, 0.8935, 0.0080))-1.081);\n    d = max(d, dot(p, vec3(0.3819, 0.4822, -0.7885))-1.973);    \n    d = max(d, min(.58-p.y, -1.5-p.z));\n    d = max(d, .3-p.y);\n    d = max(d, abs(side1+.01)-.08);\n    if(d<car) matId = MAT_FENDERS;\n    car = min(car, d);\n    \n    //if(car>.1) return vec2(car, matId);\n    \n    // wheel well\n    // front\n    d = p.z-2.0635;\n    d = max(d, dot(p.yz, vec2(0.5285, 0.8489))-2.0260);\n    d = max(d, dot(p.yz, vec2(0.9991, 0.0432))-0.8713);\n    d = max(d, dot(p.yz, vec2(0.5258, -0.8506))+0.771);\n    d = max(d, 1.194-p.z);\n    d = max(d, .5-p.x);\n    car = max(car, -d);\n    if(d<car) matId = MAT_FENDERS;\n    \n    // back\n    d = p.z+0.908;\n    d = max(d, dot(p.yz, vec2(0.5906, 0.8070))+0.434);\n    d = max(d, dot(p.yz, vec2(0.9998, 0.0176))-0.7843);\n    d = max(d, dot(p, vec3(-0.0057, 0.5673, -0.8235))-1.7892);\n    d = max(d, -p.z-1.7795);\n   \td = max(d, .5-p.x);//.65-p.x\n    car = max(car, -d);\n    if(d<car) matId = MAT_FENDERS;\n    \n   return vec2(car, matId);\n}\n\nvec2 sdWheel(vec3 p) {\n    float matId=MAT_RUBBER;\n    \n    vec3 wp = p;\n\tfloat  w = sdCylinder(wp, vec3(-.1, 0,0), vec3(.1, 0,0), .32)-.03;\n    float dist = length(wp.zy);\n    \n    if(dist>.3&&w<.05) {\t\t// wheel detail\n    \tfloat a = atan(wp.z, wp.y);\n        float x = wp.x*20.;\n        float tireTop = S(.29, .4, dist);\n        float thread = S(-.5, -.3, sin(a*40.+x*x))*.01 * tireTop;\n        \n        thread *= S(.0, .007, abs(abs(wp.x)-.07+sin(a*20.)*.01));\n        thread *= S(.005, .01, abs(wp.x+sin(a*20.)*.03));\n        \n        w -= thread*2.;\n        \n        float e = length(wp-vec3(2, .1, 0))-.5;\n        w = min(w, e);\n    }\n    \n    if(w>.1) return vec2(w, matId);\n    \n    wp *= .95;\n    wp.yz = pModPolar(wp.yz, 7., 1.);\n    float cap = max(p.x-.18, wp.y-.3);\n    \n    wp.z = abs(wp.z);\n    \n    float d = map01( .3, .23, wp.y);\t\t// spoke bevel\n    d *= map01(.04, .03, wp.z);\t\t\t// spokes\n    d *= map01(-.23, .23, wp.y)*.7;\t\t\t// spoke gradient\n    \n    d = max(d, map01(.13, .0, wp.y)*1.5);\t// center outside\n    d = min(d, map01(.0, .07, wp.y));\t\t// center inside\n    d = max(d, .8*step(wp.y, .05));\t\t\t// middle plateau\n    \n    d = max(d, .4*map01(.23, .22, dot(wp.zy, normalize(vec2(1., 2.)))));\n    cap += (1.-d)*.07;\n    cap = max(cap, .05-p.x);\n    cap *= .8;\n    if(cap<w) matId = MAT_FENDERS;\n    \n    w = min(w, cap);\n    w += S(.3, .0, dist)*.025; // concavivy!\n    \n    return vec2(w, matId);\n}\n\n\nfloat Height(vec2 p) {\n    float x = SmoothNoise(p.xy);\n    float y = SmoothNoise((p.xy+x)*3.);\n    float z = SmoothNoise(vec2(y, x)*10.);\n    return S(0., z, y)*.5+.3;\n}\n\nvec2 GetDist(vec3 p) {\n    vec2 car = sdCar(p);\n    vec3 wp = p-vec3(0,0,.14);\n    wp.xz = abs(wp.xz);\n    wp-=vec3(.7383, .365, 1.5);\n    \n    if(p.z>0.) wp.xz *= Rot(.3*sign(p.x));\n    vec2 wheel = sdWheel(wp);\n    \n    float y = p.y;\n    \n    #ifdef GROUND_DISPLACEMENT\n    float centerDist = dot(p.xz, p.xz);\n    if(centerDist<100.&&p.y<.01) {\n        y = SmoothNoise(p.xz*2.)+SmoothNoise(p.xz*5.)*.5+SmoothNoise(p.xz*23.)*.05;\n        y += SmoothNoise(y*p.xz);\n        \n        float fade = S(100.,0.,centerDist);\n        fade *= fade*fade;\n        \n        y = y*y*.03*fade;\n        y *= S(.0, .6, dot(wp.xz,wp.xz));\n    }\n\ty+=p.y;\n    #endif\n    \n    if(min(y, min(car.x, wheel.x))==y)\n        return vec2(y, MAT_GROUND);\n    else \n    \treturn car.x<wheel.x ? car : wheel;\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=MIN_DIST;\n    float dS;\n    float matId=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 g = GetDist(p);\n        dS = g.x;\n        dO += dS;\n        matId = g.y;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec3(dO, abs(dS), matId);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(1e-4, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\nvec4 TubeInfo(vec3 ro, vec3 rd, vec3 a, vec3 b) {\n\tvec2 ts = RayLineDist(ro, rd, a, b);\n    \n    vec3 pr = ro+max(0., ts.x)*rd;\t\t\t// closest point on ray\n    vec3 pl = a+clamp(ts.y, 0., 1.)*(b-a);\t// closest point on line\n    float closestDist = length(pr-pl);\t\t// distance between closest points\n    float distToCrossing = length(ro-pl);\t// distance along ray to crossing\n    \n    return vec4(pl, closestDist);\n}\n\nfloat Intensity(float d, float w) {\n    return exp(-(d*d)/w)/sqrt(w);\n}\n\n\nvec3 Ground(vec3 P) {\n\tvec2 p = P.xz;\n    float d = 1.+max(0.,dot(p,p));\n    float shadow = smoothstep(.5, 1.8, length(p-vec2(0, clamp(p.y, -1.5, 1.3))) );\n\t\n    float albedo = SmoothNoise(p*4.+SmoothNoise(p*7.)*.66+SmoothNoise(p*13.)*.33);\n    float specks = SmoothNoise(p*albedo*5.)+P.y;\n    albedo -= specks*specks*specks;\n    albedo /= 1.+max(0.,dot(p,p))*.5;\n    \n    albedo = (albedo+1.)/3.;\n    vec3 col = vec3(albedo)*shadow;\n    \n    return col;\n}\n\nvec3 GroundRef(vec3 ro, vec3 rd) {\n\tvec2 p = ro.xz-rd.xz*(ro.y/rd.y);\n    \n    float d = 1.+max(0.,dot(p,p));\n    float albedo = SmoothNoise(p*4.+SmoothNoise(p*7.)*.66+SmoothNoise(p*13.)*.33);\n    \n    albedo /= 1.+max(0.,dot(p,p))*.5;\n    \n    albedo = (albedo+1.)/3.;\n    vec3 col = vec3(albedo)*S(.6, .0, rd.y);\n    \n    return col;\n}\n\n// Interior of the car\nvec2 CabDist(vec3 p) {\n    p.x = abs(p.x);\n    \n    float cab,d;\n    \n    float frontGlass = dot(p.yz, vec2(0.9493, 0.3142))-1.506; // front\n    float topGlass = dot(p.yz, vec2(0.9938, -0.1110))-1.407;\n    float windowBottom = dot(p.yz, vec2(-0.9982, -0.0601))+1.0773;\n    \n    float side1 = dot(p, vec3(0.9854, -0.1696, -0.0137))-0.580;\n    float side2 = dot(p, vec3(0.9661, 0.2583, 0.0037))-0.986;\n    float side = max(side1, side2);\n    \n    float w = .05;\n    float hw = .5*w;\n    \n    float glass = max(frontGlass, topGlass);\n    float glassShell = abs( glass+.025 ) -.025; \n    d = min(glassShell, max(abs(p.z-.17),glass+.1)-.05); // center column\n    cab = max(d,abs(-side2-w)-w);\n    \n    // top bar\n    d = max(abs(p.z-.43)-w, glassShell);\n    d = max(d, side2);\n    cab = min(cab, d);\n    \n    d = max(abs(-side1-w)-w, -windowBottom);\t// side wall\n    float walls = min(p.y-.3, p.z+.6);\n    walls = min(d, walls);\n    \n    walls = max(walls, glass);\n    d = max(walls,side);\t\t\t\t// bottom\n\tcab = min(cab, d);\n    \n    // front seats\n    float cup = cos(p.x*10.);\n    vec3 seatPos = p-vec3(.35, .2+cup*.04, .8);\n    d = sdBox(seatPos, vec3(.27, .25, .3)*.8)-.05;\n    seatPos = p-vec3(.35, .75, .6);\n    seatPos.z += S(.0, 1.2, p.y)*.4-cup*.05;\n    vec3 seatScale = vec3(.27, .6, .03)*.8;\n    seatScale.x *= 1.-S(.9, 1.1, p.y)*.6;\n    seatScale.xz *= 1.-S(1.1, 1.3, p.y)*.7;\n    \n    d = min(d, sdBox(seatPos, seatScale)-.04);\n    \n    cab = min(cab, d);\n    \n    // dash\n    d = sdBox(p-vec3(0,.5,1.7), vec3(2,.5,.3));\n    d = min(d, sdBox(p-vec3(0,.89+(p.z-1.3)*.1,1.5), vec3(2,.07,.3))-.01);\n    d = max(d, side1);\n    cab = min(cab, d);\n    \n    // screen\n    vec3 scrPos = p-vec3(0,.9,1.15);\n    scrPos.yz *= Rot(-.4);\n    d = sdBox(scrPos, vec3(.16,.1,-.005))-.02;\n    cab = min(cab, d);\n    // wheel\n\t   \n   \n    return vec2(cab, MAT_CAB);\n}\n\nvec3 CabNormal(vec3 p) {\n\tfloat d = CabDist(p).x;\n    vec2 e = vec2(1e-4, 0);\n    \n    vec3 n = d - vec3(\n        CabDist(p-e.xyy).x,\n        CabDist(p-e.yxy).x,\n        CabDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec4 RenderCab(vec3 ro, vec3 rd) {\n    vec4 info;\n    \n\tfloat dO=MIN_DIST;\n    float dS;\n    float matId=0.;\n    vec3 p;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tp = ro + rd*dO;\n        vec2 g = CabDist(p);\n        dS = g.x;\n        dO += dS;\n        matId = g.y;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    vec3 col = vec3(0);\n    if(abs(dS)<SURF_DIST) {\n        vec3 n = CabNormal(p);\n        info = vec4( n, 0. );\n    } else\n        info = vec4(0,0,0,.5);\n    \n    return info;\n}\n\nvec3 Material(vec3 ro, vec3 rd, vec3 p, vec3 n, vec3 d) {\n    vec3 col = vec3(0);\n    \n    float dif = n.y;\n    vec3 r = reflect(rd,n);\n    \n    vec4 nDif = TubeInfo(p, n, beamStart, beamEnd);\n    vec4 nRef = TubeInfo(p, r, beamStart, beamEnd);\n\n    float dist = length(nDif.xyz-p);\n    float nDiffuse = 4.*max(0., dot(n, nDif.xyz/dist))/(dist*dist);\n    nDiffuse *= S(50., 9., length(nDif.xyz-ro));\n\n    vec3 wp = abs(p-vec3(0,0,.14))-vec3(.7383, .36, 1.5);\n\tfloat matId = d.z;\n    \n    if(matId==MAT_GROUND) {\n        col = Ground(p);//ro, rd);\n        float z = p.z-2.;\n        float headLight = S(1.+z,-1.-z, abs(p.x)-p.z*.35);\n        \n        headLight -= headLight*n.z*2.; // bump map\n        headLight /= 1.+z*z*.05;\n        \n        vec3 tlPos = p+vec3(0,0,3);\n        col *= nDiffuse*beamCol+headLight*S(0., 3.,z)+\n            .5/(1.+dot(tlPos,tlPos))*vec3(1.,.1,.1);\n    } else if(matId==MAT_BASE || matId==MAT_GLASS || matId==MAT_SHUTTERS || matId==MAT_SHATTERED) { \n        vec3 ref = vec3(0.);//GetRef(p, r)*1.;\n\n        ref += Intensity(nRef.w*(10.*(1.+matId)), length(p-nRef.xyz)+.25)*5.;\n        ref *= beamCol;\n        ref += GroundRef(p, r)*beamCol;\n\n        vec3 P =p-r*(p.y/r.y);\n\n        nDif = TubeInfo(P, vec3(0,1,0), beamStart, beamEnd);\n\n        dist = length(nDif.xyz-P);\n        nDiffuse = 4.*max(0., dot(n, nDif.xyz/dist))/(dist*dist);\n        nDiffuse *= S(50., 9., length(nDif.xyz-ro));\n\n        col += ref*nDiffuse;\n        \n        vec3 lighten = max(0., r.y*r.y*n.y)*beamCol;\n        if(matId==MAT_BASE) {\n            col += ref*max(.1,nDiffuse);\n        \n            //col *= 2.;\n            col += lighten*.5;\n        } else if(matId==MAT_SHUTTERS) {\n            float seams = sin(p.z*150.)*.5+.5;\n            col *= seams;\n            col += lighten *.3*(S(.0, .1, seams)*.1+.9);  \n        } else if(matId==MAT_GLASS) {\n            vec4 cabInfo = RenderCab(ro, rd);\n            col += cabInfo.y*.005;\n            throughWindow = cabInfo.w;\n        } else if(matId==MAT_SHATTERED) {\n            vec4 cabInfo = RenderCab(ro, rd);\n            col += cabInfo.y*.005;\n            throughWindow = cabInfo.w;\n            \n            vec3 p2 = p;\n            vec2 p = p.xz;\n            p.x += 0.72;\n            p.y -= 0.6;\n            p.xy *= 4.0;\n            p.x *= 4.0;\n            if(p.y > -1.6) {\n                vec2 v=vec2(1E3);\n                vec2 v2=vec2(1E4);\n                vec2 center=vec2(.1,-.5);\n                for(int c=0;c<90;c++)\n                {\n                    float angle=floor(rnd(vec2(float(c),387.44))*16.)*3.1415*.4-.5;\n                    float dist=pow(rnd(vec2(float(c),78.21)),2.)*.5;\n                    vec2 vc=vec2(center.x+cos(angle)*dist+rnd(vec2(float(c),349.3))*7E-3,\n                                 center.y+sin(angle)*dist+rnd(vec2(float(c),912.7))*7E-3);\n                    if(length(vc-p)<length(v-p))\n                    {\n                        v2=v;\n                        v=vc;\n                    }\n                    else if(length(vc-p)<length(v2-p))\n                    {\n                        v2=vc;\n                    }\n                }\n\n                float col2=abs(length(dot(p-v*0.91,normalize(v-v2)))*0.97-length(dot(p-v2,normalize(v-v2))));\n                if(col2<0.02) {\n                    col = vec3(0.4)*(1.0-col2*20.0);\n                    col *= 0.3;\n                    col *= 1.0 - abs(length(p.xy+vec2(-0.1,0.5)));\n                }\n            } else if (p.y < -1.8) {\n            \tp.y += 2.0;\n                p.x -= 0.7;\n                vec2 v=vec2(1E3);\n                vec2 v2=vec2(1E4);\n                vec2 center=vec2(.1,-.5);\n                for(int c=0;c<90;c++)\n                {\n                    float angle=floor(rnd(vec2(float(c),387.44))*16.)*3.1415*.399-.5;\n                    float dist=pow(rnd(vec2(float(c),78.21)),2.)*.5;\n                    vec2 vc=vec2(center.x+cos(angle)*dist+rnd(vec2(float(c),349.3))*7E-3,\n                                 center.y+sin(angle)*dist+rnd(vec2(float(c),912.7))*7E-3);\n                    if(length(vc-p)<length(v-p))\n                    {\n                        v2=v;\n                        v=vc;\n                    }\n                    else if(length(vc-p)<length(v2-p))\n                    {\n                        v2=vc;\n                    }\n                }\n\n                float col2=abs(length(dot(p-v*0.85,normalize(v-v2)))*0.97-length(dot(p-v2,normalize(v-v2))));\n                if(col2<0.02) {\n                    col = vec3(0.4)*(1.0-col2*20.0);\n                    col *= 0.3;\n                    col *= 1.0 - abs(length(p.xy+vec2(0.0,0.5)));\n                }\n            }\n        }\n    } else if(matId==MAT_LIGHTS) {\n    \tif(p.z<0.)\n        \tcol.r += 1.;\n        else\n            col += 1.;\n    } else if(matId==MAT_FENDERS) {\n        float spec = Intensity(nRef.w*3., length(p-nRef.xyz)+.25);\n        col += max(n.y*.05, spec)*(beamCol+.5);\n        \n    } else if(matId==MAT_RUBBER) {\n        float shadow = S(.0, .1, abs(p.x)-.7);\n        col += nDiffuse*shadow*beamCol*.2;\n    }\n    \n    return col;      \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec4 m = iMouse/iResolution.xyxy;\n    if(m.x<.05) m.xy = vec2(.7,.45);\n    float t = iTime;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -5)*.7;\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831+t*.3+1.);\n    ro.y = max(ro.y, .1);\n    vec3 lookat = vec3(0,.5,0);\n    //lookat = vec3(.7,.5,1.5);\n    #ifdef MODEL_MODE\n    vec3 rd = R(uv, ro, lookat, 2.);\n\t#else\n    vec3 rd = R(uv, ro, lookat, 1.);\n    #endif\n    \n    vec3 d = RayMarch(ro, rd);\n    throughWindow = 0.;\t\t// will be set to >0 if we are looking all the way through the car\n   \n    // neon tubes\n    float climax = 1.+step(35.,iChannelTime[0])*5.*step(iChannelTime[0], 52.);\n    float ft = floor(t*BEAMS_PER_SECOND*climax)*BEAMS_PER_SECOND*climax;\n   \tbeamStart = vec3(-40,3.,0)+sin(ft*vec3(.234,.453,.486))*vec3(5,2,5)*.5;\n    beamEnd = vec3(40, 3.,0)+sin(ft*vec3(.345,.538,.863))*vec3(5,2,5)*.5;\n    mat2 rot = Rot(ft*45.4532);\n    beamStart.xz *=rot;\n    beamEnd.xz*=rot;\n    \n  \tbeamCol = sin(ft*vec3(.234,.453,.486))*.5+.5;\n    beamCol *= beamCol;\n    beamCol = normalize(beamCol);\n    \n    vec2 ts;\n    vec3 a, b, s;\n    float nd;\n    vec3 p = ro + rd * d.x;\n    \n    if(d.y<SURF_DIST) {\n    \tvec3 n = GetNormal(p);\n        \n        #ifdef MODEL_MODE\n        float matId = d.z;\n        col = n*.5+.5;\n\n        if(matId==MAT_BASE)\n\t\t\tcol *= vec3(1,0,0);\n        else if(matId==MAT_FENDERS)\n            col *= vec3(0,1,0);\n        else if(matId==MAT_LIGHTS)\n            col *= vec3(0,0,1);\n        else if(matId==MAT_GLASS) {\n            vec4 cabInfo = RenderCab(ro, rd);\n            col = cabInfo.xyz/3.;\n            throughWindow = cabInfo.w;\n        }else if(matId==MAT_RUBBER)\n            col *= vec3(1,1,0);\n        else if(matId==MAT_SHUTTERS)\n            col *= vec3(0,1,1);\n        else if(matId==MAT_GROUND)\n            col *= .2;\n        #else\n    \tcol = Material(ro, rd, p, n, d);\n        #endif\n    } else if(rd.y>0.){\n        col += rd.y*rd.y*(beamCol);\n    }\n    \n    #ifndef MODEL_MODE\n    if(rd.y<0.) {\n        float groundDist = length(rd*(ro.y/rd.y));\n        if(groundDist<d.x){// || groundDist>MAX_DIST) {\n        \tvec3 groundPos = ro+groundDist*rd;\n           // col = Ground(ro, rd);\n        \t//col = texture(iChannel1, groundPos.xz*.1).rgb;\n        \t//col *= nDiffuse*beamCol;\n        //col += 1.;\n        }\n    }\n    \n    ts = RayLineDist(ro, rd, beamStart, beamEnd);\n    a = ro+max(0., ts.x)*rd;\n    b = beamStart+clamp(ts.y, 0., 1.)*(beamEnd-beamStart);\n    nd = length(a-b);\n    float dist = length(ro-b);\n    \n    float beam = (.005/dot(nd,nd))*S(50., 9., dist);\n    beam *= max(throughWindow, S(0., 1., d.x-length(ro-b)));\n    col += beam*beamCol;\n    \n    // headlights\n    float brightness = .02;\n    float z = 2.22;\n    float bias = 1.;\n    float offs = .0;\n    vec4 h;\n    \n    h = TubeInfo(ro, rd, vec3(.56, .82, z), vec3(.74,.85,z-.1));\n    float headlight = max(0., dot(vec2(.3, .8), -rd.xz)*bias+offs)*brightness/h.w;\n   \th = TubeInfo(ro, rd, vec3(-.56, .82, z), vec3(-.74,.85,z-.1));\n    headlight += max(0., dot(vec2(-.3, .8), -rd.xz)*bias+offs)*brightness/h.w;\n    \n    // middle\n    brightness *= .66;\n    h = TubeInfo(ro, rd, vec3(-.52, .82, z), vec3(.52,.82,z));\n    headlight += max(0., -rd.z)*brightness/h.w;\n    \n    // top\n   // h = TubeInfo(ro, rd, vec3(-.52, 1.43, .5), vec3(.52,1.43,.5));\n   // headlight += max(0., -rd.z)*.005/h.w;\n    \n    \n    col += headlight*vec3(.8, .8, 1);\n    \n    // rear light\n    h = TubeInfo(ro, rd, vec3(-.7, 1.05, -2.25), vec3(.7,1.05,-2.25));\n    col += vec3(1., .1, .1)*max(0., rd.z*rd.z*rd.z)*.04/h.w;\n    \n    \n    //col *= 3.;\n    \n    //if(uv.x>0.)col =  col*3.;//filmic_reinhard(col); else\n    col = Tonemap_ACES(col*4.);\n    col *= 1.-dot(uv,uv)*.5;\n    \n    #endif\n    //col = pow(col,vec3(1./2.2));\n   fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float sabs(float x,float k) {\n    float a = (.5/k)*x*x+k*.5;\n    float b = abs(x);\n    return b<k ? a : b;\n}\nvec2 sabs(vec2 x,float k) { return vec2(sabs(x.x, k), sabs(x.y,k)); }\nvec3 sabs(vec3 x,float k) { return vec3(sabs(x.x, k), sabs(x.y,k), sabs(x.z,k)); }\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// From http://mercury.sexy/hg_sdf\nvec2 pModPolar(inout vec2 p, float repetitions, float fix) {\n\tfloat angle = 6.2832/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - (angle/2.)*fix;\n\tp = vec2(cos(a), sin(a))*r;\n\n\treturn p;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat LineDist(vec2 a, vec2 b, vec2 p) {\n\tvec2 ab=b-a, ap=p-a;\n    float h = dot(ab, ap)/dot(ab, ab);\n    float d = length(ap - ab * h);\n    float s = sign(ab.x * ap.y - ab.y * ap.x);\n    return d*s;\n}\n\nfloat LineDist(float ax,float ay, float bx,float by, vec2 p) {\n    return LineDist(vec2(ax, ay), vec2(bx, by), p);\n}\nfloat map01(float a, float b, float t) {\n\treturn clamp((t-a)/(b-a), 0., 1.);\n}\nfloat map(float t, float a, float b, float c, float d) {\n\treturn (d-c)*clamp((t-a)/(b-a), 0., 1.)+c;\n}\n\nvec2 RayLineDist(vec3 ro, vec3 rd, vec3 a, vec3 b) {\n    \n    b -= a;\n    vec3 rdb = cross(rd,b);\n    vec3 rop2 = a-ro;\n    \n\tfloat t1 = dot( cross(rop2, b), rdb ); \n    float t2 = dot( cross(rop2, rd), rdb );\n    \n    return vec2(t1, t2) / dot(rdb, rdb);\n}\n\nfloat RayPlane(vec3 ro, vec3 rd, vec3 n, float d) {\n\treturn (d-dot(ro, n)) / dot(rd, n);\n}\n\nfloat N21(vec2 p) {\n    p = fract(p*vec2(123.34,456.23));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n    //return fract(sin(p.x*100.+p.y*6574.)*5647.);\n}\n\nfloat SmoothNoise(vec2 uv) {\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    lv = lv*lv*(3.-2.*lv);\n    \n    float bl = N21(id);\n    float br = N21(id+vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = N21(id+vec2(0,1));\n    float tr = N21(id+vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nfloat SmoothNoise2(vec2 uv) {\n    float c = SmoothNoise(uv*4.);\n    \n    // don't make octaves exactly twice as small\n    // this way the pattern will look more random and repeat less\n    c += SmoothNoise(uv*8.2)*.5;\n    c += SmoothNoise(uv*16.7)*.25;\n    c += SmoothNoise(uv*32.4)*.125;\n    c += SmoothNoise(uv*64.5)*.0625;\n    \n    c /= 2.;\n    \n    return c;\n}\n\nfloat Tonemap_ACES(float x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 Tonemap_ACES(vec3 x) {\n    return vec3(Tonemap_ACES(x.r),Tonemap_ACES(x.g),Tonemap_ACES(x.b));\n}\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}