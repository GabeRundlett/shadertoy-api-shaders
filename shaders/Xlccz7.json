{
    "Shader": {
        "info": {
            "date": "1531959948",
            "description": "Raymarching experiment, use mouse to control camera. And tweak the code â™¥ !",
            "flags": 0,
            "hasliked": 0,
            "id": "Xlccz7",
            "likes": 48,
            "name": "Cubucious",
            "published": 3,
            "tags": [
                "cubucious"
            ],
            "usePreview": 0,
            "username": "leon",
            "viewed": 1780
        },
        "renderpass": [
            {
                "code": "// ponk (Leon Denise) 19/07/2018\n// most lines below are from the shadertoy community\n// licensed under hippie love conspiracy\n// happy tweaking\n\n// Geometry\nfloat range = .8;\nfloat radius = .4;\nfloat blend = .3;\nconst float count = 8.;\n\n// Light\nvec3 lightPos = vec3(1, 1, 1);\nfloat specularSharpness = 10.;\nfloat glowSharpness = 1.;\n\n// Colors\nvec3 ambient = vec3(.1);\nvec3 light = vec3(0);\nvec3 specular = vec3(1);\nvec3 glow = vec3(1);\n\n// Raymarching\nconst float epsilon = .001;\nconst float steps = 30.;\nconst float far = 10.;\n#define repeat(p,r) (mod(p,r)-r/2.)\n#define sdist(p,r) (length(p)-r)\nfloat box (vec3 p, vec3 b) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\nfloat torus (vec3 p, vec2 t) { vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y; }\nfloat smoothmin (float a, float b, float r) { float h = clamp(.5+.5*(b-a)/r, 0., 1.); return mix(b, a, h)-r*h*(1.-h); }\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nvec3 look (vec3 eye, vec3 target, vec2 anchor) {\n\tvec3 forward = normalize(target-eye);\n\tvec3 right = normalize(cross(forward, vec3(0,1,0)));\n\tvec3 up = normalize(cross(right, forward));\n\treturn normalize(forward + right * anchor.x + up * anchor.y);\n}\n\n// Miscellaneous\n#define time iTime*.4\n#define PI 3.14159\n#define TAU 6.28318\n#define PIHALF 1.7079\n#define PIQUART 0.785397\n#define saturate(p) clamp(p,0.,1.)\nfloat random (in vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123); }\n\nfloat geometry (vec3 pos)\n{\n    float scene = 10.;\n    vec3 p = pos;\n\tfor (float index = count; index > 0.; --index) {\n\t\tfloat ratio = index / count;\n        \n        // easing\n\t\tratio *= ratio;\n        \n        // domain reptition and translation offset\n\t\tp.xz = abs(p.xz) - range * ratio;\n        \n        // rotations\n\t\tp.xz *= rot(PIQUART);\n\t\tp.yz *= rot(time);\n\t\t//p.yx *= rot(PIHALF);\n\n\t\tscene = smoothmin(scene, box(p, vec3(radius * ratio)), blend * ratio);\n\t}\n    return scene;\n}\n\nvec3 getNormal (vec3 p) {\n    vec2 e = vec2(epsilon,0);\n    return normalize(vec3(geometry(p+e.xyy)-geometry(p-e.xyy),\n                          geometry(p+e.yxy)-geometry(p-e.yxy),\n                          geometry(p+e.yyx)-geometry(p-e.yyx)));\n}\n\nvoid raymarching (vec3 pos, vec3 ray, inout vec4 hit)\n{\n\tfloat total = 0.;\n\tfor (float i = steps; i >= 0.; --i) {\n\t\tfloat dist = geometry(pos);\n\t\tif (dist < epsilon * total || total > far) {\n\t\t\thit.xyz = pos;\n\t\t\thit.w = i/steps;\n\t\t\tbreak;\n\t\t}\n\t\ttotal += dist;\n\t\tpos += ray * dist;\n\t}\n}\n\nvoid mainImage( out vec4 color, in vec2 coordinate )\n{    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse.x = (mouse.x * 2. - 1.) * PI;\n    mouse.y *= 1.5;\n    \n\tvec2 uv = (coordinate.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 eye = vec3(0,2,2) * (2. - mouse.y);\n    vec3 target = vec3(0);\n\tvec4 hit;\n    \n    eye.xz *= rot(mouse.x);\n    lightPos.xz *= rot(time);\n    \n\tvec3 ray = look(eye, target, uv);\n    raymarching(eye, ray, hit);\n    \n    vec3 pos = hit.xyz;\n\tvec3 normal = getNormal(pos);\n\tvec3 lightDir = normalize(lightPos);\n\tfloat lightIntensity = clamp(dot(lightDir, normal),0.,1.);\n\tfloat specularIntensity = saturate(pow(max(0., dot(reflect(lightDir, normal), ray)), specularSharpness));\n\tfloat glowIntensity = saturate(pow(abs(1.-abs(dot(normal, ray))), glowSharpness));\n\n\tcolor.rgb = ambient + light * lightIntensity + specular * specularIntensity + glow * glowIntensity;\n\tcolor.rgb *= hit.w;\n    color.rgb *= step(length(eye-pos), far);\n\t//color.rgb = normal * .5 + .5;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}