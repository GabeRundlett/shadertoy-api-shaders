{
    "Shader": {
        "info": {
            "date": "1586867288",
            "description": "Mapping the whole plane plus points at infinity to a finite disk.\nPoints on the border with the same color are the same points in the projective plane.",
            "flags": 0,
            "hasliked": 0,
            "id": "Wd2cRG",
            "likes": 9,
            "name": "Projective plane disk",
            "published": 3,
            "tags": [
                "2d",
                "math",
                "geometry",
                "projective"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 419
        },
        "renderpass": [
            {
                "code": "/*\nMapping of the projective plane to a disk.\n\nThe whole affine plane is mapped to the disk without border,\nthe border is the line at infinity. Two opposing points on\nthe disk border are corresponding to just one point in the\nprojective plane. I gave two opposing points the same color\nto emphasize this.\n\nBasically, the lines parallel to the x axis are\nan interpolation between the x axis and the disk border,\nthose parallel to the y axis between y axis and disk border accordingly.\nEvery point can then be described as the intersection of two\nof those circles.\n(You can think of the disk border as third axis)\n\nThe animation shows how ellipses are those conic sections without\nintersections with the line at infinity,\nparabolas are those with exactly one intersection, and\nhyperbolas those with exactly two intersections.\n\n(Or optionally a triangle where one point is movable with mouse)\n(Or optionally an elliptic curve whose parameters you can change with mouse)\n\nI got the basic idea of the mapping from a prof of mine,\ni derived the exact formulas myself. I don't know\nhow this mapping is called, but this has certainly been done\nbefore.\n*/\n\n//#define TRIANGLE\n//#define ELLIPTIC_CURVE\n\nconst float pi=3.14159265358979;\n\nconst float eps=.000001;\n\nconst float t0=2.00001;\nconst float t1=4.00002;\nconst float t2=7.00003;\nconst float t3=9.00004;\nconst float tt=11.00005;\n//the perturbations are a workaround for https://gitlab.freedesktop.org/mesa/mesa/issues/2610\n\nfloat sgn(float a){\n\tif(a<0.){\n\t\treturn -1.;\n\t}\n\telse{\n\t\treturn 1.;\n\t}\n}\n\nvec2 from_projective(vec3 p, float stretch_factor, float radius, out vec2 int_p2){\n\tvec2 int_p;\n\n\tfloat a=p.x*p.x+p.y*p.y;\n\tfloat b=p.z*p.x/(stretch_factor*stretch_factor);\n\tfloat c=-p.x*p.x*radius*radius;\n\n\tfloat int_x=(-b+sgn(p.x)*sqrt(b*b-4.*a*c))/(2.*a);\n\tfloat int_y=int_x*p.y/p.x;\n\n\tint_p=vec2(int_x,int_y);\n\n\tif(abs(p.z)<eps){\n\t\tint_p2=-int_p;\n\t}\n\telse{\n\t\tint_p2=int_p;\n\t}\n\n\treturn int_p;\n}\n\nvec3 to_projective(vec2 p, float stretch_factor, float radius){\n\treturn vec3(p.xy,stretch_factor*stretch_factor*(radius*radius-dot(p,p)));\n}\n\nmat2x3 to_projective_jacobi(vec2 p, float stretch_factor, float radius){\n\tvec3 column1=vec3(1.,0.,-2.*stretch_factor*stretch_factor*p.x);\n\tvec3 column2=vec3(0.,1.,-2.*stretch_factor*stretch_factor*p.y);\n\n\treturn mat2x3(column1, column2);\n}\n\nfloat to_projective_line(float a, float b){\n\treturn -sgn(a)*sgn(b)*abs(a)/(abs(a)+abs(b));\n}\n\nvec2 from_projective_line(float a){\n\treturn vec2(a,1.-abs(a));\n}\n\nfloat line_dist(vec2 uv, const vec2 p0, vec2 p1){\n\tvec2 tang=p1-p0;\n\tvec2 nor=normalize(vec2(tang.y,-tang.x));\n\n\tif(dot(tang,uv)<dot(tang,p0)){\n\t\treturn distance(p0,uv);\n\t}\n\telse if(dot(tang,uv)>dot(tang,p1)){\n\t\treturn distance(p1,uv);\n\t}\n\telse{\n\t\treturn abs(dot(nor,uv)-dot(nor,p0));\n\t}\n}\n\nvec3 line(vec2 p_0, vec2 p_1){\n\tvec2 tan1 = p_1-p_0;\n\tvec2 nor1 = normalize(vec2(tan1.y,-tan1.x));\n\treturn vec3(nor1,-dot(nor1,p_0));\n}\n\nvec3 line(vec3 p_0, vec3 p_1){\n\treturn normalize(cross(p_0,p_1));\n}\n\n//mapping from barth's skript:\n//https://web.archive.org/web/20051104003320/http://www.mi.uni-erlangen.de/~barth/docs/geoset.ps (german)\n//it basically gives the formula and says:\n//by this formula, you see the projective plane can be bijectively mapped to a disk, but this is not too useful\n//the mapping does not have any favorably properties compared to the other one, i just implemented it for reference\nvec2 from_projective_barth(vec3 p, float radius, out vec2 int_p2){\n\tvec2 int_p = 2.*radius/pi*p.xy*atan(dot(p.xy,p.xy)/(p.z*p.z))/length(p.xy);\n\n\tif(abs(p.z)<eps){\n\t\tint_p=radius*normalize(p.xy);\n\t\tint_p2=-int_p;\n\t}\n\telse{\n\t\tint_p2=int_p;\n\t}\n\n\treturn int_p;\n}\n\nvec3 to_projective_barth(vec2 p, float radius){\n\treturn vec3(p.xy*sqrt(tan(pi/(2.*radius)*length(p))),length(p));\n}\n\nmat2x3 to_projective_jacobi_barth(vec2 p, float radius){\n\tfloat fac=pi/(2.*radius);\n\tfloat len=length(p);\n\n\tfloat tmp=tan(len*fac);\n\n\tfloat a11=.5*(tmp*tmp + 1.)*fac*p.x*p.x/(len*sqrt(tmp)) + sqrt(tmp);\n\tfloat a12=.5*(tmp*tmp + 1.)*fac*p.x*p.y/(len*sqrt(tmp));\n\tfloat a22=.5*(tmp*tmp + 1.)*fac*p.y*p.y/(len*sqrt(tmp)) + sqrt(tmp);\n\n\tvec3 column1=vec3(a11,a12,p.x/len);\n\tvec3 column2=vec3(a12,a22,p.y/len);\n\n\treturn mat2x3(column1,column2);\n}\n\n//elliptic degree is the same but for lines instead of points\nfloat elliptic_distance(vec3 p1, vec3 p2){\n\treturn acos(1./sqrt(dot(p1,p1)*dot(p2,p2))*dot(p1,p2));\n}\n\nfloat spectral(float x){\n        return clamp(abs(mod((x/pi+1.)*4.,8.)-4.)-2.,-.75,.75)*.5/.75+.5;\n}\n\nvec3 to_col(vec2 z){\n\tfloat direction = 2.*atan(z.x,z.y);\n\treturn vec3(spectral(direction),spectral(direction+pi/2.),spectral(direction-pi));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv-=.5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tmouse-=.5;\n\tmouse.x *= iResolution.x / iResolution.y;\n\n\tvec2 mouse2 = iMouse.zw / iResolution.xy;\n\tmouse2-=.5;\n\tmouse2.x *= iResolution.x / iResolution.y;\n    \n    #ifdef TRIANGLE\n    float animation=1.;\n    #else\n    #ifdef ELLIPTIC_CURVE\n    float animation=1.;\n    #else\n    float animation;\n    \n    float tc=abs(mod(iTime-tt,2.*tt)-tt);\n    \n    if(tc<t1){\n        animation=exp(mix(5.,0.,smoothstep(0.,t0,tc)));\n    }\n    else if(tc<.5*(t1+t2)){\n        animation=exp(mix(0.,5.,smoothstep(t1,.5*(t1+t2),tc)));\n    }\n    else if(tc<t3){\n        animation=exp(mix(5.,0.,smoothstep(.5*(t1+t2),t2,tc)));\n    }\n    else{\n        animation=exp(mix(0.,5.,smoothstep(t3,tt,tc)));\n    }\n    #endif\n    #endif\n    \n    float stretch_factor=1./animation;\n    float radius=.47*animation;\n\n\tconst float line_width = .001;\n\tconst float circle_width = .003;\n\tconst float grid_width = .0;\n\tconst float curve_width = .001;\n\tconst float dot_size = .005;\n\tconst float axis_width = .005;\n\n\tconst float grid_size = .8;\n\n\tconst vec3 bg_col = vec3(1,1,1);\n\tconst vec3 axis_col = vec3(0,0,0);\n\tconst vec3 grid_col = vec3(.75);\n\tconst vec3 line_col = vec3(0,1,0);\n\tconst vec3 curve_col = vec3(0,0,1);\n\tconst vec3 dot_col = vec3(1,0,0);\n\n\tvec3 circle_col = to_col(uv);\n\n    float border = 2./iResolution.y;\n\n\tfloat curve_dis = 1e38;\n\tfloat dot_dis = 1e38;\n\tfloat axis_dis = 1e38;\n\tfloat grid_dis = 1e38;\n\tfloat line_dis = 1e38;\n\tfloat circle_dis = 1e38;\n\n\tvec3 color=bg_col;\n\n\tcircle_dis=min(circle_dis,abs(length(uv)-radius)-circle_width);\n\n\taxis_dis=min(axis_dis,line_dist(uv,vec2(0,radius),vec2(0,-radius))-line_width);\n\taxis_dis=min(axis_dis,line_dist(uv,vec2(radius,0),vec2(-radius,0))-line_width);\n\n\tvec3 uv_p=to_projective(uv,stretch_factor,radius);\n\n\tmat2x3 jac=to_projective_jacobi(uv,stretch_factor,radius);\n\n    #ifdef TRIANGLE\n\tvec2 m0=normalize(mouse)*min(length(mouse),radius);\n\tvec3 p0=to_projective(m0,stretch_factor,radius);\n\tvec3 p1=vec3(2.7,2.2,1.);\n\tvec3 p2=vec3(2.,-2.,1.);\n    \n    vec2 int_p;\n\tvec2 int_p2;\n\n\tint_p = from_projective(p0,stretch_factor,radius,int_p2);\n\n\tdot_dis=min(dot_dis,distance(uv,int_p)-dot_size);\n\tdot_dis=min(dot_dis,distance(uv,int_p2)-dot_size);\n\n\tint_p = from_projective(p1,stretch_factor,radius,int_p2);\n\n\tdot_dis=min(dot_dis,distance(uv,int_p)-dot_size);\n\tdot_dis=min(dot_dis,distance(uv,int_p2)-dot_size);\n\n\tint_p = from_projective(p2,stretch_factor,radius,int_p2);\n\n\tdot_dis=min(dot_dis,distance(uv,int_p)-dot_size);\n\tdot_dis=min(dot_dis,distance(uv,int_p2)-dot_size);\n    \n    vec3 l1=line(p0,p1);\n\tvec3 l2=line(p1,p2);\n\tvec3 l3=line(p2,p0);\n    \n\tcurve_dis=min(curve_dis,abs(dot(uv_p,l1)/length(l1*jac)));\n\tcurve_dis=min(curve_dis,abs(dot(uv_p,l2)/length(l2*jac)));\n\tcurve_dis=min(curve_dis,abs(dot(uv_p,l3)/length(l3*jac)));\n    #else\n    #ifdef ELLIPTIC_CURVE\n    \n\tfloat g_2 = 10.*mouse.x;\n\tfloat g_3 = 10.*mouse.y;\n\n\tfloat elliptic_curve_val=(4.*uv_p.x*uv_p.x-g_2*uv_p.z*uv_p.z)*uv_p.x-(g_3*uv_p.z*uv_p.z+uv_p.y*uv_p.y)*uv_p.z;\n\tvec3 elliptic_curve_grad=vec3(12.*uv_p.x*uv_p.x-g_2*uv_p.z*uv_p.z,-2.*uv_p.y*uv_p.z,(-3.*g_3*uv_p.z-2.*g_2*uv_p.x)*uv_p.z-uv_p.y*uv_p.y);\n    \n    curve_dis=min(curve_dis,abs(elliptic_curve_val/length(elliptic_curve_grad*jac)));\n    #else\n\tfloat hyperbola_val=8.*uv_p.x*uv_p.x-4.*uv_p.y*uv_p.y+uv_p.z*uv_p.z;\n\tvec3 hyperbola_grad=vec3(8.*2.*uv_p.x,-4.*2.*uv_p.y,+2.*uv_p.z);\n\n\tfloat parabola_val=uv_p.x*uv_p.x-uv_p.y*uv_p.z;\n\tvec3 parabola_grad=vec3(2.*uv_p.x,-uv_p.z,-uv_p.y);\n\n\tfloat circle_val=uv_p.x*uv_p.x+uv_p.y*uv_p.y-uv_p.z*uv_p.z;\n\tvec3 circle_grad=vec3(2.*uv_p.x,2.*uv_p.y,-2.*uv_p.z);\n    \n\tfloat mix_val;\n\tvec3 mix_grad;\n    \n    mix_val=mix(circle_val,parabola_val,smoothstep(t0,t1,tc));\n\tmix_grad=mix(circle_grad,parabola_grad,smoothstep(t0,t1,tc));\n    \n    if(tc>t2){\n        mix_val=mix(parabola_val,hyperbola_val,smoothstep(t2,t3,tc));\n\t\tmix_grad=mix(parabola_grad,hyperbola_grad,smoothstep(t2,t3,tc));\n    }\n\n\tcurve_dis=min(curve_dis,abs(mix_val/length(mix_grad*jac)));\n    #endif\n    #endif\n\n\tvec3 grid_grad=vec3(1./uv_p.z,0.,-uv_p.x/(uv_p.z*uv_p.z));\n\tgrid_dis = min(grid_dis, abs(mod(uv_p.x/uv_p.z-grid_size*.5,grid_size)-grid_size*.5)/length(grid_grad*jac)-grid_width);\n\tgrid_grad=vec3(0.,1./uv_p.z,-uv_p.y/(uv_p.z*uv_p.z));\n\tgrid_dis = min(grid_dis, abs(mod(uv_p.y/uv_p.z-grid_size*.5,grid_size)-grid_size*.5)/length(grid_grad*jac)-grid_width);\n\n\tfloat d0=length(uv)-radius;\n\n\tgrid_dis=max(d0,grid_dis);\n\tcurve_dis=max(d0,curve_dis);\n\n\tcolor=vec3(mix(grid_col,color,smoothstep(0., border, grid_dis)));\n\tcolor=vec3(mix(axis_col,color,smoothstep(0., border, axis_dis)));\n\tcolor=vec3(mix(line_col,color,smoothstep(0., border, line_dis)));\n\tcolor=vec3(mix(circle_col,color,smoothstep(0., border, circle_dis)));\n\tcolor=vec3(mix(curve_col,color,smoothstep(0., border, curve_dis)));\n\tcolor=vec3(mix(dot_col,color,smoothstep(0., border, dot_dis)));\n\n\tfragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}