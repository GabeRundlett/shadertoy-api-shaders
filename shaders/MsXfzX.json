{
    "Shader": {
        "info": {
            "date": "1497190919",
            "description": "Colours stuck inside objects",
            "flags": 0,
            "hasliked": 0,
            "id": "MsXfzX",
            "likes": 2,
            "name": "Day 6 - Stuck inside colours",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "Mercesa",
            "viewed": 469
        },
        "renderpass": [
            {
                "code": "\n#define MAXMARCHSTEPS 64\n#define EPSILON 0.0001\n\nfloat udSphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opBlend( vec3 p, float a, float b)\n{\n   \n    return smin( a, b, 0.1f );\n}\n\nfloat opS(float d1, float d2)\n{\n    return max(-d1, d2);\n}\n\nfloat repeatedSpheres(vec3 p)\n{\n    p.x = mod(p.x, 6.0) - 3.0;\n    p.z = mod(p.z, 6.0) - 3.0;\n    return udSphere(p, 1.0f);\n}\n    \nfloat Map(vec3 p)\n{\n    float d1 = udSphere(p, 1.0f);\n    // Rotate around the x axis\n    float d2 = udSphere(p + vec3(cos(iTime + 2.0f) * 1.2f , sin(iTime) * 1.2f, 0.0f), 0.6f);\n    float d3 = udSphere(p + vec3(sin(iTime+ 1.0f) * 1.2f, 0.0f, 0.0f), 0.5f);\n   //float d4 = udBox(p + vec3(, vec3(0.5f, 0.5f, 0.05f);\n    float blend = opBlend(p, d1, d2);\n    float blend2 = opBlend(p, blend, d3);\n    float blend3 = opS(udBox(p + vec3(0.0f, 0.0f, sin(iTime) * 4.0f), vec3(0.5f, 0.5f, 0.5f)), blend2);\n\t\n    //float subSphere = opS(udSphere(p + vec3(0.0f, 0.0f, sin(iTime)), 0.f), blend2);\n    return blend2;\n    \n    \n}\n\nfloat Trace(vec3 origin, vec3 direction, float min, float end, vec2 xy)\n{\n    float t = min;\n    \n    for(int i = 0; i < MAXMARCHSTEPS; ++i)\n    {\n        // We do some trippy things with our sampling point\n        vec3 p = origin + direction * t;\n        \n        float d = Map(p);\n        \n        if(d < EPSILON)\n        {\n            return t;\n        }\n        \n        t += d;\n        \n    \tif(t >= end)\n    \t{\n        \treturn end;\n    \t}    \n    }\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nmat3 ViewMatrix(vec3 eye, vec3 center, vec3 up)\n{\n    vec3 f = normalize(center-eye);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = cross(r,f);\n    \n    return mat3(r,u,-f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \t// Calculate a nice screenspace color\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n    vec2 uv = xy;\n    xy = xy * 2.0f - 1.0f;\n\t//fragColor = vec4(xy,0.5+0.5*sin(iTime),1.0);\n    \n  \n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    \n    vec3 lookAt = vec3(0.0f, 0.0f, 0.0f);\n    vec3 eye = vec3(0.0, 6.0f, 7.0f);\n    \n    mat3 viewToWorld = ViewMatrix(eye, vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 1.0f, 0.0f));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float t = Trace(eye, worldDir, 0.0, 1000.0f, xy);\n\n    viewDir += vec3(texture(iChannel0, xy + vec2(0.0f, 1.0f - iTime)).r) /20.0f * sin(iTime);\n    worldDir = viewToWorld * viewDir;\n\n    float t2 = Trace(eye, worldDir, 0.0, 1000.0f, xy);\n    float fog = 1.0f / (1.0f + t*t*0.4);\n    //fragColor.rg = xy.rg;\n    \n    \n    if(t > 1000.0f - EPSILON)\n    {\n    \tfragColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);   \n        return;\n    }\n\tvec3 position = normalize(eye + worldDir * t);\n\tvec3 position2 = normalize(eye + worldDir * t2);\n\t\n   \n    fragColor.rgb = position2;\n    \n    fragColor += fog;\n    //fragColor = vec4(1.0f, 1.0f, 1.0f, 1.0f);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}