{
    "Shader": {
        "info": {
            "date": "1501383079",
            "description": "Shows the steps taken to produce a basic landscape scene, from noise generation to lighting and texturing.\n\nCoincidentally, my first Shadertoy landscape.",
            "flags": 32,
            "hasliked": 0,
            "id": "Ms2fRK",
            "likes": 54,
            "name": "[SH17C] Landscape Composition",
            "published": 3,
            "tags": [
                "terrain",
                "tutorial",
                "landscape",
                "demo",
                "sh17c"
            ],
            "usePreview": 1,
            "username": "ssell",
            "viewed": 1520
        },
        "renderpass": [
            {
                "code": "/**\n * Created by Steven Sell (ssell) / 2017\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * Step-by-step process of creating a basic landscape render. \n * Entry for [SH17C] https://www.shadertoy.com/view/4dBfRK\n *\n *     Buffer A: Text rendering\n *     Buffer B: Base geometry rendering\n *     Buffer C: Lighting and materials\n *     Image: Combining text with result of Buffer C\n */\n\n// Source (3Dfx): https://www.shadertoy.com/view/4dGXW1\nvec4 SampleAA(in vec2 uv)\n{\n    vec2 s = vec2(1.0 / iResolution.x, 1.0 / iResolution.y);\n    vec2 o = vec2(0.11218413712, 0.33528304367) * s;\n    \n    return (texture(iChannel1, uv + vec2(-o.x,  o.y)) +\n            texture(iChannel1, uv + vec2( o.y,  o.x)) +\n            texture(iChannel1, uv + vec2( o.x, -o.y)) +\n            texture(iChannel1, uv + vec2(-o.y, -o.x))) * 0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    vec4 text      = texture(iChannel0, uv);\n    vec4 landscape = SampleAA(uv);\n    \n    fragColor.rgb  = mix(landscape.rgb, text.rgb, text.a);\n    fragColor.rgb *=  0.2 + (0.8 * pow(64.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.125));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/**\n * ---------------------------------------------------------------\n * - Buffer A: Text Rendering\n *\n * Text functions and algorithm from:\n *\n *     'Shadertext proportional spacing' - Andre\n *     https://www.shadertoy.com/view/4s3XDn\n * \n * Compacted the line count a bit.\n * ---------------------------------------------------------------\n */\n\nfloat line(vec2 p, vec2 a, vec2 b) { vec2 pa = p - a; vec2 ba = b - a; float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0); return length(pa - ba * h); }\nfloat _u(vec2 uv, float w, float v) { return length(vec2( abs(length(vec2(uv.x, max(0.0,-(.4-v)-uv.y) ))-w) ,max(0.,uv.y-.4))); } float _i(vec2 uv) { return length(vec2(uv.x,max(0.,abs(uv.y)-.4))); } float _j(vec2 uv) { uv.x+=.2; uv.y+=.55; float x = uv.x>0.&&uv.y<0.? abs(length(uv)-.25) :min(length(uv+vec2(0.,.25)), length(vec2(uv.x-.25,max(0.,abs(uv.y-.475)-.475)))); return x; } float _l(vec2 uv) { uv.y -= .2; return length(vec2(uv.x,max(0.,abs(uv.y)-.6))); } float _o(vec2 uv) { return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.15)))-.25); } float aa(vec2 uv) { uv = -uv; float x = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2); x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.2)-.2)))); return min(x,(uv.x<0.?uv.y<0.:atan(uv.x,uv.y+0.15)>2.)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254))); } float bb(vec2 uv) { float x = _o(uv); uv.x += .25; return min(x,_l(uv)); } float cc(vec2 uv) { float x = _o(uv); uv.y= abs(uv.y); return uv.x<0.||atan(uv.x,uv.y-0.15)<1.14?x: min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.15))), length(uv+vec2(-.22734,-.254))); } float dd(vec2 uv) { uv.x *= -1.; return bb(uv); } float ee(vec2 uv) { float x = _o(uv); return min(uv.x<0.||uv.y>.05||atan(uv.x,uv.y+0.15)>2.?x:length(vec2(uv.x-.22734,uv.y+.254)), length(vec2(max(0.,abs(uv.x)-.25),uv.y-.05))); } float ff(vec2 uv) { uv.x *= -1.; uv.x += .05; float x = _j(vec2(uv.x,-uv.y)); uv.y -= .4; x = min(x,length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y))); return x; } float gg(vec2 uv) { float x = _o(uv); return min(x,uv.x>0.||atan(uv.x,uv.y+.6)<-2.? _u(uv,0.25,-0.2): length(uv+vec2(.23,.7))); } float hh(vec2 uv) { uv.y *= -1.; float x = _u(uv,.25,.25); uv.x += .25; uv.y *= -1.; return min(x,_l(uv)); } float ii(vec2 uv) { return min(_i(uv),length(vec2(uv.x,uv.y-.6))); } float jj(vec2 uv) { uv.x+=.05; return min(_j(uv),length(vec2(uv.x-.05,uv.y-.6))); } float kk(vec2 uv) { float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.4)); x = min(x,line(uv,vec2(-.15,.0), vec2(0.25,-0.4))); uv.x+=.25; return min(x,_l(uv)); } float ll(vec2 uv) { return _l(uv); } float mm(vec2 uv) { uv.y *= -1.; uv.x-=.175; float x = _u(uv,.175,.175); uv.x+=.35; x = min(x,_u(uv,.175,.175)); uv.x+=.175; return min(x,_i(uv)); } float nn(vec2 uv) { uv.y *= -1.; float x = _u(uv,.25,.25); uv.x+=.25; return min(x,_i(uv)); } float oo(vec2 uv) { return _o(uv); } float pp(vec2 uv) { float x = _o(uv); uv.x += .25; uv.y += .4; return min(x,_l(uv)); } float qq(vec2 uv) { uv.x = -uv.x; return pp(uv); } float rr(vec2 uv) { uv.x -= .05; float x =atan(uv.x,uv.y-0.15)<1.14&&uv.y>0.?_o(uv):length(vec2(uv.x-.22734,uv.y-.254)); uv.x+=.25; return min(x,_i(uv)); } float ss(vec2 uv) { if (uv.y <.225-uv.x*.5 && uv.x>0. || uv.y<-.225-uv.x*.5) uv = -uv; float a = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2); float b = length(vec2(uv.x-.231505,uv.y-.284)); float x = atan(uv.x-.05,uv.y-0.2)<1.14?a:b; return x; } float tt(vec2 uv) { uv.x *= -1.; uv.y -= .4; uv.x += .05; float x = min(_j(uv),length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y))); return x; } float uu(vec2 uv) { return _u(uv,.25,.25); } float vv(vec2 uv) { uv.x=abs(uv.x); return line(uv,vec2(0.25,0.4), vec2(0.,-0.4)); } float ww(vec2 uv) { uv.x=abs(uv.x); return min(line(uv,vec2(0.3,0.4), vec2(.2,-0.4)), line(uv,vec2(0.2,-0.4), vec2(0.,0.1))); } float xx(vec2 uv) { uv=abs(uv); return line(uv,vec2(0.,0.), vec2(.3,0.4)); } float yy(vec2 uv) { return min(line(uv,vec2(.0,-.2), vec2(-.3,0.4)), line(uv,vec2(.3,.4), vec2(-.3,-0.8))); } float zz(vec2 uv) { float l = line(uv,vec2(0.25,0.4), vec2(-0.25,-0.4)); uv.y=abs(uv.y); float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.4)); return min(x,l); }\nfloat AA(vec2 uv) { float x = length(vec2( abs(length(vec2(uv.x, max(0.0,uv.y-.35) ))-0.25) ,min(0.,uv.y+.4))); return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1) )); }\nfloat BB(vec2 uv) { uv.y -=.1; uv.y = abs(uv.y); float x = length(vec2( abs(length(vec2(max(0.0,uv.x), uv.y-.25))-0.25) ,min(0.,uv.x+.25))); return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) )); } float CC(vec2 uv) { float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25); uv.y -= .1; uv.y= abs(uv.y); return uv.x<0.||atan(uv.x,uv.y-0.25)<1.14?x: min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))), length(uv+vec2(-.22734,-.354))); } float DD(vec2 uv) { uv.y -=.1; float x = length(vec2( abs(length(vec2(max(0.0,uv.x), max(0.0,abs(uv.y)-.25)))-0.25) ,min(0.,uv.x+.25))); return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) )); } float EE(vec2 uv) { uv.y -=.1; uv.y = abs(uv.y); float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)), length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5))); return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)))); } float FF(vec2 uv) { uv.y -=.1; float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)), length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5))); return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)))); } float GG(vec2 uv) { float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25); uv.y -= .1; float a = atan(uv.x,max(0.,abs(uv.y)-0.25)); x = uv.x<0.||a<1.14 || a>3.?x: min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))), length(uv+vec2(-.22734,-.354))); x = min(x,line(uv,vec2(.22734,-.1),vec2(.22734,-.354))); return min(x,line(uv,vec2(.22734,-.1),vec2(.05,-.1))); } float HH(vec2 uv) { uv.y -=.1; uv.x = abs(uv.x); float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y)); return min(x,length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5)))); } float II(vec2 uv) { uv.y -= .1; float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5))); uv.y = abs(uv.y); return min(x,length(vec2(max(0.,abs(uv.x)-.1),uv.y-.5))); } float JJ(vec2 uv) { uv.x += .125; float x = length(vec2( abs(length(vec2(uv.x, min(0.0,uv.y+.15) ))-0.25) ,max(0.,max(-uv.x,uv.y-.6)))); return min(x,length(vec2(max(0.,abs(uv.x-.125)-.125),uv.y-.6))); } float KK(vec2 uv) { float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.6)); x = min(x,line(uv,vec2(-.1, .1), vec2(0.25,-0.4))); return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)))); } float LL(vec2 uv) { uv.y -=.1; float x = length(vec2(max(0.,abs(uv.x)-.2),uv.y+.5)); return min(x,length(vec2(uv.x+.2,max(0.,abs(uv.y)-.5)))); } float MM(vec2 uv) { uv.y-=.1; float x = min(length(vec2(uv.x-.35,max(0.,abs(uv.y)-.5))), line(uv,vec2(-.35,.5),vec2(.0,-.1))); x = min(x,line(uv,vec2(.0,-.1),vec2(.35,.5))); return min(x,length(vec2(uv.x+.35,max(0.,abs(uv.y)-.5)))); } float NN(vec2 uv) { uv.y-=.1; float x = min(length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))), line(uv,vec2(-.25,.5),vec2(.25,-.5))); return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)))); } float OO(vec2 uv) { return abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25); } float PP(vec2 uv) { float x = length(vec2( abs(length(vec2(max(0.0,uv.x), uv.y-.35))-0.25) ,min(0.,uv.x+.25))); return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) )); } float QQ(vec2 uv) { float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25); uv.y += .3; uv.x -= .2; return min(x,length(vec2(abs(uv.x+uv.y),max(0.,abs(uv.x-uv.y)-.2)))/sqrt(2.)); } float RR(vec2 uv) { float x = length(vec2( abs(length(vec2(max(0.0,uv.x), uv.y-.35))-0.25) ,min(0.,uv.x+.25))); x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) )); return min(x,line(uv,vec2(0.0,0.1),vec2(0.25,-0.4))); } float SS(vec2 uv) { uv.y -= .1; if (uv.y <.275-uv.x*.5 && uv.x>0. || uv.y<-.275-uv.x*.5) uv = -uv; float a = abs(length(vec2(max(0.,abs(uv.x)),uv.y-.25))-.25); float b = length(vec2(uv.x-.236,uv.y-.332)); float x = atan(uv.x-.05,uv.y-0.25)<1.14?a:b; return x; } float TT(vec2 uv) { uv.y -= .1; float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5))); return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5))); } float UU(vec2 uv) { float x = length(vec2( abs(length(vec2(uv.x, min(0.0,uv.y+.15) ))-0.25) ,max(0.,uv.y-.6))); return x; } float VV(vec2 uv) { uv.x=abs(uv.x); return line(uv,vec2(0.25,0.6), vec2(0.,-0.4)); } float WW(vec2 uv) { uv.x=abs(uv.x); return min(line(uv,vec2(0.3,0.6), vec2(.2,-0.4)), line(uv,vec2(0.2,-0.4), vec2(0.,0.2))); } float XX(vec2 uv) { uv.y -= .1; uv=abs(uv); return line(uv,vec2(0.,0.), vec2(.3,0.5)); } float YY(vec2 uv) { return min(min(line(uv,vec2(.0, .1), vec2(-.3, 0.6)), line(uv,vec2(.0, .1), vec2( .3, 0.6))), length(vec2(uv.x,max(0.,abs(uv.y+.15)-.25)))); } float ZZ(vec2 uv) { float l = line(uv,vec2(0.25,0.6), vec2(-0.25,-0.4)); uv.y-=.1; uv.y=abs(uv.y); float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)); return min(x,l); }\nfloat _11(vec2 uv) { return min(min( line(uv,vec2(-0.2,0.45),vec2(0.,0.6)), length(vec2(uv.x,max(0.,abs(uv.y-.1)-.5)))), length(vec2(max(0.,abs(uv.x)-.2),uv.y+.4))); } float _22(vec2 uv) { float x = min(line(uv,vec2(0.185,0.17),vec2(-.25,-.4)), length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4))); uv.y-=.35; uv.x += 0.025; return min(x,abs(atan(uv.x,uv.y)-0.63)<1.64?abs(length(uv)-.275): length(uv+vec2(.23,-.15))); } float _33(vec2 uv) { uv.y-=.1; uv.y = abs(uv.y); uv.y-=.25; return atan(uv.x,uv.y)>-1.?abs(length(uv)-.25): min(length(uv+vec2(.211,-.134)),length(uv+vec2(.0,.25))); } float _44(vec2 uv) { float x = min(length(vec2(uv.x-.15,max(0.,abs(uv.y-.1)-.5))), line(uv,vec2(0.15,0.6),vec2(-.25,-.1))); return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y+.1))); } float _55(vec2 uv) { float b = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)), length(vec2(uv.x+.25,max(0.,abs(uv.y-.36)-.236)))); uv.y += 0.1; uv.x += 0.05; float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.0)))-.3); return min(b,abs(atan(uv.x,uv.y)+1.57)<.86 && uv.x<0.? length(uv+vec2(.2,.224)) :c); } float _66(vec2 uv) { uv.y-=.075; uv = -uv; float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25); uv.y-=.175; float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25); return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b: length(uv+vec2(0.2,0.6))); } float _77(vec2 uv) { return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)), line(uv,vec2(-0.25,-0.39),vec2(0.25,0.6))); } float _88(vec2 uv) { float l = length(vec2(max(0.,abs(uv.x)-.08),uv.y-.1+uv.x*.07)); uv.y-=.1; uv.y = abs(uv.y); uv.y-=.245; return min(abs(length(uv)-.255),l); } float _99(vec2 uv) { uv.y-=.125; float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25); uv.y-=.175; float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25); return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b: length(uv+vec2(0.2,0.6))); } float _00(vec2 uv) { uv.y-=.1; return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.25)))-.25); }\nfloat ddot(vec2 uv) { uv.y+=.4; return length(uv)*0.97; } float comma(vec2 uv) { return min(ddot(uv),line(uv,vec2(.031,-.405),vec2(-.029,-.52))); } float exclam(vec2 uv) { return min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y-.2)-.4)))-uv.y*.06); } float question(vec2 uv) { float x = min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y+.035)-.1125)))); uv.y-=.35; uv.x += 0.025; return min(x,abs(atan(uv.x,uv.y)-1.05)<2.?abs(length(uv)-.275): length(uv+vec2(.225,-.16))-.0); } float open1(vec2 uv) { uv.x-=.62; return abs(atan(uv.x,uv.y)+1.57)<1.? abs(length(uv)-.8) :length(vec2(uv.x+.435,abs(uv.y)-.672)); } float close1(vec2 uv) { uv.x = -uv.x; return open1(uv); } float dotdot(vec2 uv) { uv.y -= .1; uv.y = abs(uv.y); uv.y-=.25; return length(uv); } float dotcomma(vec2 uv) { uv.y -= .1; float x = line(uv,vec2(.0,-.28),vec2(-.029,-.32)); uv.y = abs(uv.y); uv.y-=.25; return min(length(uv),x); } float eequal(vec2 uv) { uv.y -= .1; uv.y = abs(uv.y); return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.15)); } float aadd(vec2 uv) { uv.y -= .1; return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)), length(vec2(uv.x,max(0.,abs(uv.y)-.25)))); } float ssub(vec2 uv) { return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1)); } float mmul(vec2 uv) { uv.y -= .1; uv = abs(uv); return min(line(uv,vec2(0.866*.25,0.5*.25),vec2(0.)) ,length(vec2(uv.x,max(0.,abs(uv.y)-.25)))); } float ddiv(vec2 uv) { return line(uv,vec2(-0.25,-0.4),vec2(0.25,0.6)); } float lt(vec2 uv) { uv.y-=.1; uv.y = abs(uv.y); return line(uv,vec2(0.25,0.25),vec2(-0.25,0.)); } float gt(vec2 uv) { uv.x=-uv.x; return lt(uv); } float hash(vec2 uv) { uv.y-=.1; uv.x -= uv.y*.1; uv = abs(uv); return min(length(vec2(uv.x-.125,max(0.,abs(uv.y)-.3))), length(vec2(max(0.,abs(uv.x)-.25),uv.y-.125))); } float and(vec2 uv) { uv.y-=.44; uv.x+=.05; float x = abs(atan(uv.x,uv.y))<2.356?abs(length(uv)-.15):1.0; x = min(x,line(uv,vec2(-0.106,-0.106),vec2(0.4,-0.712))); x = min(x,line(uv,vec2( 0.106,-0.106),vec2(-0.116,-0.397))); uv.x-=.025; uv.y+=.54; x = min(x,abs(atan(uv.x,uv.y)-.785)>1.57?abs(length(uv)-.2):1.0); return min(x,line(uv,vec2( 0.141,-0.141),vec2( 0.377,0.177))); } float or(vec2 uv) { uv.y -= .1; return length(vec2(uv.x,max(0.,abs(uv.y)-.5))); } float und(vec2 uv) { return length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4)); } float open2(vec2 uv) { uv.y -= .1; uv.y = abs(uv.y); return min(length(vec2(uv.x+.125,max(0.,abs(uv.y)-.5))), length(vec2(max(0.,abs(uv.x)-.125),uv.y-.5))); } float close2(vec2 uv) { uv.x=-uv.x; return open2(uv); } float open3(vec2 uv) { uv.y -= .1; uv.y = abs(uv.y); float x = length(vec2( abs(length(vec2((uv.x*sign(uv.y-.25)-.2), max(0.0,abs(uv.y-.25)-.05) ))-0.2) ,max(0.,abs(uv.x)-.2))); return x; } float close3(vec2 uv) { uv.x=-uv.x; return open3(uv); }\nvec2 clc(vec2 uv, float cp, float w, float ital) { return uv-vec2(cp-(w*.5)+uv.y*ital,0.); } bool hit(vec2 uv,inout float cp,float w, float px) { return abs((cp+=w)-uv.x)<w+.2; }\n\n#define ch(l,w) if (hit(uv,cp,w,px)) { x=min(x,l(clc(uv,cp,w,ital))); us=cur;}\n\n#define a_ ch(aa,0.7);\n#define b_ ch(bb,0.7);\n#define c_ ch(cc,0.7);\n#define d_ ch(dd,0.7);\n#define e_ ch(ee,0.7);\n#define f_ ch(ff,0.6);\n#define g_ ch(gg,0.7);\n#define h_ ch(hh,0.7);\n#define i_ ch(ii,0.3);\n#define j_ ch(jj,0.3);\n#define k_ ch(kk,0.7);\n#define l_ ch(ll,0.3);\n#define m_ ch(mm,0.9);\n#define n_ ch(nn,0.7);\n#define o_ ch(oo,0.7);\n#define p_ ch(pp,0.7);\n#define q_ ch(qq,0.7);\n#define r_ ch(rr,0.7);\n#define s_ ch(ss,0.7);\n#define t_ ch(tt,0.7);\n#define u_ ch(uu,0.7);\n#define v_ ch(vv,0.7);\n#define w_ ch(ww,0.9);\n#define x_ ch(xx,0.8);\n#define y_ ch(yy,0.8);\n#define z_ ch(zz,0.7);\n#define A_ ch(AA,0.7);\n#define B_ ch(BB,0.7);\n#define C_ ch(CC,0.7);\n#define D_ ch(DD,0.7);\n#define E_ ch(EE,0.7);\n#define F_ ch(FF,0.7);\n#define G_ ch(GG,0.7);\n#define H_ ch(HH,0.7);\n#define I_ ch(II,0.5);\n#define J_ ch(JJ,0.5);\n#define K_ ch(KK,0.7);\n#define L_ ch(LL,0.5);\n#define M_ ch(MM,0.9);\n#define N_ ch(NN,0.7);\n#define O_ ch(OO,0.7);\n#define P_ ch(PP,0.7);\n#define Q_ ch(QQ,0.7);\n#define R_ ch(RR,0.7);\n#define S_ ch(SS,0.7);\n#define T_ ch(TT,0.7);\n#define U_ ch(UU,0.7);\n#define V_ ch(VV,0.7);\n#define W_ ch(WW,0.9);\n#define X_ ch(XX,0.8);\n#define Y_ ch(YY,0.8);\n#define Z_ ch(ZZ,0.7);\n#define _1 ch(_11,0.7);\n#define _2 ch(_22,0.7);\n#define _3 ch(_33,0.7);\n#define _4 ch(_44,0.7);\n#define _5 ch(_55,0.7);\n#define _6 ch(_66,0.7);\n#define _7 ch(_77,0.7);\n#define _8 ch(_88,0.7);\n#define _9 ch(_99,0.7);\n#define _0 ch(_00,0.7);\n#define _dot ch(ddot,0.3);\n#define _comma ch(comma,0.3);\n#define _exclam ch(exclam,0.3);\n#define _question ch(question,0.8);\n#define _open1 ch(open1,0.7);\n#define _close1 ch(close1,0.7);\n#define _dotdot ch(dotdot,0.3);\n#define _dotcomma ch(dotcomma,0.3);\n#define _equal ch(eequal,0.7);\n#define _add ch(aadd,0.7);\n#define _sub ch(ssub,0.7);\n#define _mul ch(mmul,0.7);\n#define _div ch(ddiv,0.7);\n#define _lt ch(lt,0.7);\n#define _gt ch(gt,0.7);\n#define _hash ch(hash,0.7);\n#define _and ch(and,0.9);\n#define _or ch(or,0.3);\n#define _und ch(und,0.7);\n#define _open2 ch(open2,0.6);\n#define _close2 ch(close2,0.6);\n#define _open3 ch(open3,0.7);\n#define _close3 ch(close3,0.7);\n    \n#define _ cp+=.5;\n\n#define BOLD cur.w = 2.0-cur.w;\n#define ITAL ital = 0.15-ital;\n#define RED cur.r = 0.8-cur.r;\n#define GREEN cur.g = 0.6-cur.g;\n#define BLUE cur.b = 1.0-cur.b;\n#define WHITE cur.r = 1.0 - cur.r; cur.g = 1.0 - cur.g; cur.b = 1.0 - cur.b;\n\n#define crlf uv.y += 2.0; cp = 0.;\n\n#define TIME_Blank        3.0\n#define TIME_Noise        6.0\n#define TIME_NoiseOctaves 16.0\n#define TIME_PreviewB     25.0\n#define TIME_3DLookUp     33.0\n#define TIME_3DExtrude    38.0\n#define TIME_Lighting     41.0\n#define TIME_Sky          46.0\n#define TIME_Fog          49.0\n#define TIME_SteepnessB   53.0\n#define TIME_Texture      57.0\n#define TIME_Water        61.0\n#define TIME_Trees        65.0\n\n#define line1  _open2 S_ H_ _1 _7 C_ _close2 _ L_ a_ n_ d_ s_ c_ a_ p_ e_ _ C_ o_ m_ p_ o_ s_ i_ t_ i_ o_ n_\n#define line2  S_ t_ a_ r_ t_ _ w_ i_ t_ h_ _ s_ o_ m_ e_ _ n_ o_ i_ s_ e_ _dot\n#define line3  T_ w_ e_ a_ k_ _ a_ n_ d_ _ t_ u_ n_ e_ _ i_ t_ _dot\n#define line4  _open1 _2 D_ _ P_ r_ e_ v_ i_ e_ w_ _close1\n#define line5  A_ d_ d_ _ a_ _ d_ i_ m_ e_ n_ s_ i_ o_ n_ _dot\n#define line6  P_ u_ l_ l_ _ u_ p_ _ s_ o_ m_ e_ _ m_ o_ u_ n_ t_ a_ i_ n_ s_ _dot\n#define line7  A_ d_ d_ _ l_ i_ g_ h_ t_ s_ _ a_ n_ d_ _ s_ h_ a_ d_ o_ w_ s_ _dot\n#define line8  C_ r_ e_ a_ t_ e_ _ a_ _ s_ k_ y_ _dot\n#define line9  A_ _ t_ o_ u_ c_ h_ _ o_ f_ _ f_ o_ g_ _dot\n#define line10 D_ e_ t_ e_ r_ m_ i_ n_ e_ _ s_ t_ e_ e_ p_ n_ e_ s_ s_ _dot\n#define line11 A_ p_ p_ l_ y_ _ t_ e_ x_ t_ u_ r_ e_ s_ _dot\n#define line12 W_ a_ t_ e_ r_ _ f_ o_ r_ _ s_ c_ a_ l_ e_ _dot\n#define line13 P_ l_ a_ n_ t_ _ a_ _ f_ e_ w_ _ t_ r_ e_ e_ s_ _dot\n#define line14 E_ n_ j_ o_ y_ _dot\n\n#define LINE(t, l) else if(iTime < t) { l }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iTime > (TIME_Trees + 5.0))\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    float scale = 1.1;\n\tvec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.x * 22.0 * scale;\n    uv.y += 9.0;\n    uv.x += 1.5;\n    \n    float px = 22.0/iResolution.x*scale;\n    float x = 100.;\n    float cp = 0.;\n    vec4 cur = vec4(0.,0.,0.,0.5);\n    vec4 us = cur;\n    float ital = 0.0;\n    uv.x += 10.1;\n    \n    int lnr = 1-int(floor(uv.y/2.));\n    uv.y = mod(uv.y,2.0)-1.0;\n    \n    if(lnr==0) \n    {\n        BOLD WHITE\n            \n        if(iTime < TIME_Blank) { line1 }\n        LINE(TIME_Noise, line2)\n        LINE(TIME_NoiseOctaves, line3)\n        LINE(TIME_PreviewB, line4)\n        LINE(TIME_3DLookUp, line5)\n        LINE(TIME_3DExtrude, line6)\n        LINE(TIME_Lighting, line7)\n        LINE(TIME_Sky, line8)\n        LINE(TIME_Fog, line9)\n        LINE(TIME_SteepnessB, line10)\n        LINE(TIME_Texture, line11)\n        LINE(TIME_Water, line12)\n        LINE(TIME_Trees, line13)\n        else{ line14 }\n    }\n    \n    float weight = 0.01+us.w*min(.05,0.03);\n\n    fragColor = mix(vec4(us.rgb, 1.0),vec4(0.0),smoothstep(weight-px,weight+px, x));\n    fragColor.a = mix(fragColor.a, 0.0, clamp((iTime - TIME_Trees) / 5.0, 0.0, 1.0));\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/**\n * ---------------------------------------------------------------\n * - Buffer B: Geometry Rendering\n *\n * Essentially produces a G-Buffer with the following data:\n *\n *     .r = (norm.x, norm.y, norm.z)\n *     .g = (heightmap, shadow, steepness)\n *     .b = (depth)\n *     .a = hit boolean\n *\n * Initially I chose Simplex Noise for the heightmap generation since it is\n * something I am familiar with and very easy to modify. This was important\n * for the 2D component of the shader. But once the scene transitions to 3D\n * and the raymarching steps started to increase (along with the lighting \n * calculations), the performance began to degrade rapidly.\n *\n * As there is no free-form camera movement in the shader, and the scene\n * geometry is relatively static, I decided to offload the geometry rendering\n * to this separate buffer and to only perform geometry updates as needed.\n *\n * The use of this G-Buffer saw an increase of static performance (no camera\n * movement, no tree growing, etc.) from ~35 to 60+ fps on my machine.\n *\n * There were two alternatives to using the G-Buffer:\n *\n *     (1) Lower the Simplex Noise octave count. This would be fine if my\n *         landscape goals were smooth hills or sand dunes, but otherwise\n *         the landscape would be far too rounded to make interesting mountains.\n *\n *     (2) Use an alternative noise algorithm. The majority of other terrain\n *         shaders on this site do not use Simplex Noise, and their results\n *         are very good. Unfortunately, my knowledge of those alternate\n *         algorithms is lacking and I do not like copy-pasting code. I will\n *         most likely learn those other approaches for future terrain shaders\n *         but time is limited for the shader entry.\n * \n * Note: If modifying this buffer (ie to adjust Simplex octave count, etc.),\n * it must be done either during a time period where the buffer is rebuilt or\n * a resolution change must be triggered. See RebuildBuffer().\n * ---------------------------------------------------------------\n */\n\n// General Defines\n\n#define Epsilon               0.2\n#define NearClip              Epsilon\n#define FarClip               450.0\n#define SoftShadowFactor      256.0\n#define SoftShadowOffset      0.1\n#define ShadowDistance        FarClip * 0.2\n\n// Terrain Parameters\n\n#define MaxHeight             205.0\n#define Shoreline             MaxHeight * 0.4\n#define VegMaxSlope           0.3\n#define VegTransition         (VegMaxSlope - 0.1)\n\n// Time Defines\n\n#define TimeLerp(x, y, a, b) mix(x, y, clamp((iTime - a) / (b - a), 0.0, 1.0))\n\n#define TIME_Noise        6.0\n#define TIME_NoiseScale   11.0\n#define TIME_NoiseOctaves 16.0\n#define TIME_2DPause      28.0\n#define TIME_3DLookUp     33.0\n#define TIME_3DExtrude    38.0\n#define TIME_Water        61.0\n#define TIME_Trees        65.0\n\nconst vec3 SunDir = normalize(vec3(-1.2, 1.0, 0.62));\n\n//------------------------------------------------------------------------------------------\n// Heightmap Generation\n//------------------------------------------------------------------------------------------\n\n// Modified hash33 by Dave_Hoskins (original does not play well with simplex)\n// Original Source: https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\n    p3 += dot(p3, p3.yxz + 19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\n// Raw simplex implementation by candycat\n// Source: https://www.shadertoy.com/view/4sc3z2\nfloat SimplexNoiseRaw(vec3 pos)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(pos + (pos.x + pos.y + pos.z) * K1);\n    vec3 d0 = pos - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\n// Simplex Noise from https://www.shadertoy.com/view/MslBzf\nfloat SimplexNoise(\n    vec3  pos,\n    float octaves,\n    float scale,\n    float persistence)\n{\n    float final        = 0.0;\n    float amplitude    = 1.0;\n    float maxAmplitude = 0.0;\n    \n    for(float i = 0.0; i < octaves; ++i)\n    {\n        final        += SimplexNoiseRaw(pos * scale) * amplitude;\n        scale        *= 2.0;\n        maxAmplitude += amplitude;\n        amplitude    *= persistence;\n    }\n    \n    return (final / maxAmplitude);\n}\n\n// Produces a Simplex Noise-based heightmap that is modified over time.\nfloat Heightmap(vec3 pos)\n{\n    float octaves     = TimeLerp(1.0, 7.0, TIME_NoiseScale, TIME_NoiseOctaves);  \n    float scale       = TimeLerp(1.0, 0.005, TIME_Noise, TIME_NoiseScale);\n    float persistence = 0.35;\n    float heightMod   = TimeLerp(1.0, 2.05, TIME_NoiseScale, TIME_NoiseOctaves);\n    \n    float noise = SimplexNoise(pos, octaves, scale, persistence) * heightMod;\n    \n    return clamp(((noise / heightMod) + 1.0) * 0.5, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------------------------------\n// Ray Structures and Functions\n//------------------------------------------------------------------------------------------\n    \nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n    \nstruct RayHit\n{\n    bool  hit;\n    \n    vec3 surfPos;\n    vec3 surfNorm;\n    \n    float depth;\n    float heightmap;\n    float steepness;\n    float shadow;\n};\n    \n//------------------------------------------------------------------------------------------\n// Camera Structures and Functions\n//------------------------------------------------------------------------------------------\n\nstruct Camera\n{\n    vec3 right;\n    vec3 up;\n    vec3 forward;\n    vec3 origin;\n};\n\nRay Camera_GetRay(in Camera camera, vec2 uv)\n{\n    Ray ray;\n    \n    uv    = (uv * 2.0) - 1.0;\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    ray.origin    = camera.origin;\n    ray.direction = normalize((uv.x * camera.right) + (uv.y * camera.up) + (camera.forward * 2.5));\n\n    return ray;\n}\n\nCamera Camera_LookAt(vec3 origin, vec3 lookAt)\n{\n\tCamera camera;\n    \n    camera.origin  = origin;\n    camera.forward = normalize(lookAt - camera.origin);\n    camera.right   = normalize(cross(camera.forward, vec3(0.0, 1.0, 0.0)));\n    camera.up      = normalize(cross(camera.right, camera.forward));\n    \n    return camera;\n}\n\n//------------------------------------------------------------------------------------------\n// Signed Distance Fields\n//------------------------------------------------------------------------------------------\n\nfloat SteepnessRatio(float steepness)\n{\n    return clamp(steepness, 0.0, VegTransition) / VegTransition;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat treeNoise(vec2 p)\n{\n    p = vec2(ivec2(p * 1.8));\n    vec2 o = vec2(0.12, 0.08);\n    return (hash12(p + o.xy) + hash12(p + o.yx) + hash12(p + o.xx) + hash12(p + o.yy)) * 0.25;\n}\n\nvec2 Scene_SDF(vec3 point, inout RayHit hit)\n{\n    float sdf = FarClip;\n    \n    float heightmap = Heightmap(vec3(point.xz, 0.0));\n    float heightMod = TimeLerp(1.0, MaxHeight, TIME_3DLookUp, TIME_3DExtrude);\n    \n    if(SteepnessRatio(hit.steepness) > (1.0 - Epsilon) && (point.y > Shoreline + 0.55))\n    {\n        // 'Tree' generation is done here. Just applies a displacement to the heightmap\n        // value if the steepness is gentle enough and we are above the shoreline.\n        sdf = (point.y - (heightmap * heightMod + treeNoise(point.xz) * 1.75 * TimeLerp(0.0, 1.0, TIME_Water, TIME_Trees)));\n    }\n    else\n    {\n    \tsdf = (point.y - heightmap * heightMod);\n    }\n                          \n    return vec2(sdf, heightmap);\n}\n\n// Calculates two different normal values depending on r:\n//     r = 0 : normal based on the 2D raw heightmap value (heightmap normal)\n//     r = 1 : normal based on the 3D sdf value (surface normal)\n// Heightmap normal is used for steepness calculation; Surface normal for lighting.\nvec3 Scene_Normal(vec3 p, float r, inout RayHit hit)\n{\n    vec2 e = vec2(1.0, -1.0);\n    \n    vec2 r0 = Scene_SDF(p + e.xyy, hit);\n    vec2 r1 = Scene_SDF(p + e.yyx, hit);\n    vec2 r2 = Scene_SDF(p + e.yxy, hit);\n    vec2 r3 = Scene_SDF(p + e.xxx, hit);\n    \n    vec3 norm = e.xyy * mix(r0.x, r0.y, r) + \n                e.yyx * mix(r1.x, r1.y, r) + \n                e.yxy * mix(r2.x, r2.y, r) + \n                e.xxx * mix(r3.x, r3.y, r);\n    \n    return normalize(norm);\n}\n\n// Basic soft shadowing. Does the ray from the surface to the sun intersect any geometry?\nfloat CalculateShadow(in RayHit hit)\n{\n    vec3 lightOrigin = hit.surfPos + (vec3(-SunDir.x, SunDir.y, -SunDir.z) * (ShadowDistance + SoftShadowOffset));\n    vec3 lightRay    = normalize(hit.surfPos - lightOrigin);\n    vec3 point       = vec3(0.0);\n    \n    vec2  sdf    = vec2(FarClip, 0.0);\n    float depth  = 0.1;\n    float result = 1.0;\n        \n    for(int steps = 0; (depth < ShadowDistance) && (steps < 8); ++steps)\n    {\n    \tpoint  = (hit.surfPos + (-lightRay * depth));\n        sdf    = Scene_SDF(point, hit);\n        result = min(result, (SoftShadowFactor * sdf.x) / depth);\n        depth += sdf.x;\n    }\n    \n    return clamp((sdf.x < Epsilon ? 0.0 : result), 0.3, 1.0);\n}\n\n//------------------------------------------------------------------------------------------\n// Raymarching\n//------------------------------------------------------------------------------------------\n\nvoid RaymarchScene(in Ray ray, inout RayHit hit)\n{\n    hit.hit = false;\n    \n    vec2 sdf   = vec2(FarClip, 0.0);\n    vec3 hNorm = vec3(0.0);\n    \n    float depth = NearClip;\n    \n    for(int steps = 0; (depth < FarClip) && (steps < 80); ++steps)\n    {\n    \tvec3 pos = ray.origin + (ray.direction * depth);\n        \n        hit.steepness = 0.0;\n        hNorm         = Scene_Normal(pos, 0.0, hit);\n        hit.steepness = smoothstep(0.75, 1.0, hNorm.y);\n        \n        sdf = Scene_SDF(pos, hit);\n        \n        if(sdf.x < Epsilon)\n        {\n            hit.hit       = true;\n            hit.surfPos   = pos;\n            hit.surfNorm  = Scene_Normal(pos, 1.0, hit);\n            hit.depth     = depth;\n            hit.heightmap = sdf.y;\n            \n            break;\n        }\n        \n        depth += sdf.x;\n    }\n}\n\n//------------------------------------------------------------------------------------------\n// Rendering\n//------------------------------------------------------------------------------------------\n\n// Sends a ray through the scene and builds RayHit structure\nRayHit Render(vec2 fragCoord, Camera camera)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    \n    Ray ray = Camera_GetRay(camera, uv);\n    RayHit hit;\n    \n    RaymarchScene(ray, hit);\n    \n    hit.shadow = CalculateShadow(hit);\n   \n    return hit;\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nfloat PackR8G8B8(vec3 rgb)\n{\n    rgb = (rgb * 255.0) + 0.5;\n    return float((uint(rgb.r)) | (uint(rgb.g) << 8) | (uint(rgb.b) << 16));\n}\n\nfloat PackNorm(vec3 norm)\n{\n\treturn PackR8G8B8((norm + 1.0) * 0.5);   \n}\n\n// If true, the G-Buffer needs to be rebuilt\nbool RebuildBuffer(in vec2 fragCoord)\n{\n\treturn (iFrame == 0 ||                                                            // If first frame\n            ivec2(texelFetch(iChannel0, ivec2(0), 0).rg) != ivec2(iResolution.xy) ||  // If resolution change\n            iTime < TIME_NoiseOctaves ||                                              // If adjusting 2D heightmap\n            ((iTime > TIME_2DPause) && (iTime < TIME_3DExtrude)) ||                   // If extruding mountains\n            ((iTime > TIME_Water) && (iTime < TIME_Trees)));                          // If extruding trees\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    // Store the current resolution in pixel (0,0)\n    if(ivec2(fragCoord.xy) == ivec2(0))\n    {\n    \tfragColor.rg = iResolution.xy;\n        return;\n    }\n    \n    // If G-Buffer does not need to be rebuilt, just output existing value.\n    if(RebuildBuffer(fragCoord) == false)\n    {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n    \n    vec3 camPos  = TimeLerp(vec3(0.0, 300.0, 0.0), vec3(120.0, MaxHeight * 0.475, 0.0), TIME_2DPause, TIME_3DLookUp);\n\n    vec3 camLookA = vec3(0.0, 0.0, 1.0);\n    vec3 camLookB = vec3(500.0, MaxHeight * 0.7, 300.0);\n\n    vec3 camLook  = TimeLerp(camLookA, camLookB, TIME_2DPause, TIME_3DLookUp);\n\n    Camera camera = Camera_LookAt(camPos, camLook);\n\n    RayHit hit = Render(fragCoord, camera);\n\n    // Pack the scene data into the pixel RGBA\n    fragColor.r = PackNorm(hit.surfNorm);\n    fragColor.g = PackR8G8B8(vec3(hit.heightmap, hit.shadow, (hit.steepness + 1.0) * 0.5));\n    fragColor.b = hit.depth;\n    fragColor.a = (hit.hit == true ? 1.0 : 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/**\n * ---------------------------------------------------------------\n * - Buffer C: Landscape Rendering\n *\n * Takes the output of Buffer B and applies lighting, materials, water, and sky.\n * ---------------------------------------------------------------\n */\n\n// General Defines\n\n#define Epsilon               0.1\n#define NearClip              Epsilon\n#define FarClip               450.0\n\n// Terrain Parameters\n\n#define MaxHeight             205.0\n#define Shoreline             MaxHeight * 0.4\n#define ShoreThickness        MaxHeight * 0.1\n#define VegMaxSlope           0.3\n#define VegTransition         (VegMaxSlope - 0.1)\n\n// Time Defines\n\n// TimeLerp is used for the temporal scene transitions.\n#define TimeLerp(x, y, a, b) mix(x, y, clamp((iTime - a) / (b - a), 0.0, 1.0))\n\n#define TIME_Blank        3.0\n#define TIME_Noise        6.0\n#define TIME_NoiseScale   11.0\n#define TIME_NoiseOctaves 16.0\n#define TIME_PreviewA     21.0\n#define TIME_PreviewB     25.0\n#define TIME_2DPause      28.0\n#define TIME_3DLookUp     33.0\n#define TIME_3DExtrude    38.0\n#define TIME_Lighting     41.0\n#define TIME_Sky          46.0\n#define TIME_Fog          49.0\n#define TIME_SteepnessA   51.0\n#define TIME_SteepnessB   53.0\n#define TIME_Texture      57.0\n#define TIME_Water        61.0\n#define TIME_Trees        65.0\n\nconst vec3 SunDir            = normalize(vec3(-1.2, 1.0, 0.62));\nconst vec3 SunColor          = vec3(1.0);\nconst vec3 HorizonColor      = vec3(0.29804, 0.61569, 0.92157);//RGB(76, 157, 235);//RGB(200, 225, 255);\nconst vec3 SkyColor          = vec3(0.10980, 0.31764, 0.79215);//RGB(28, 81, 202);//RGB(125, 185, 225);\nconst vec3 AmbColor          = vec3(1.0);\nconst vec3 WaterShallowColor = vec3(0.29803, 0.61568, 0.92156);//RGB(76, 157, 235);//RGB(120, 150, 255);\nconst vec3 WaterDeepColor    = vec3(0.10980, 0.31764, 0.79215);//RGB(28, 81, 202);//RGB(60, 100, 225);\nconst vec3 GrassColor        = vec3(0.37254, 0.47058, 0.17647);//RGB(95, 120, 45)\nconst vec3 CliffColor        = vec3(0.87451, 0.85490, 0.73725);//RGB(223, 218, 188)\n\n//------------------------------------------------------------------------------------------\n// Heightmap Generation\n//------------------------------------------------------------------------------------------\n\nvec3 PreviewColorScale(float h)\n{\n    vec3 start = vec3(h);\n    vec3 end = vec3(h);\n    \n    if(h < 0.4)\n    {\n        end = WaterDeepColor;\n    }\n    else if(h < 0.45)\n    {\n        end = WaterShallowColor;\n    }\n    else if(h < 0.5)\n    {\n        end = vec3(0.37647, 0.90980, 0.34509);//RGB(96, 232, 88);\n    }\n    else if(h < 0.7)\n    {\n        end = vec3(0.37647, 0.78431, 0.34509);//RGB(96, 200, 88);\n    }\n    else\n    {\n        end = vec3(1.0);//RGB(255, 255, 255);\n    }\n    \n    return TimeLerp(TimeLerp(start, end, TIME_NoiseOctaves, TIME_PreviewA), start, TIME_PreviewA, TIME_PreviewB);\n}\n\n//------------------------------------------------------------------------------------------\n// Ray Structures and Functions\n//------------------------------------------------------------------------------------------\n    \nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n    \nstruct RayHit\n{\n    bool  hit;\n    \n  \tvec3  surfPos;\n    vec3  surfNorm;\n    \n    float shadow;     // Shadow light modifier [0, 1]\n    float heightmap;  // 2D heightmap value [0, 1]\n    float steepness;  // Steepness value [-1, 1]\n};\n    \n//------------------------------------------------------------------------------------------\n// Camera Structures and Functions\n//------------------------------------------------------------------------------------------\n\nstruct Camera\n{\n    vec3 right;\n    vec3 up;\n    vec3 forward;\n    vec3 origin;\n};\n\nRay Camera_GetRay(in Camera camera, vec2 uv)\n{\n    Ray ray;\n    \n    uv    = (uv * 2.0) - 1.0;\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    ray.origin    = camera.origin;\n    ray.direction = normalize((uv.x * camera.right) + (uv.y * camera.up) + (camera.forward * 2.5));\n\n    return ray;\n}\n\nCamera Camera_LookAt(vec3 origin, vec3 lookAt)\n{\n\tCamera camera;\n    \n    camera.origin  = origin;\n    camera.forward = normalize(lookAt - camera.origin);\n    camera.right   = normalize(cross(camera.forward, vec3(0.0, 1.0, 0.0)));\n    camera.up      = normalize(cross(camera.right, camera.forward));\n    \n    return camera;\n}\n\n//------------------------------------------------------------------------------------------\n// Steepness\n//------------------------------------------------------------------------------------------\n\n// Returns value [0, 1] where 0 = too steep for vegetation and 1 = ok for vegetation\nfloat SteepnessRatio(float steepness)\n{\n    return clamp(steepness, 0.0, VegTransition) / VegTransition;\n}\n\n//------------------------------------------------------------------------------------------\n// Material Application\n//------------------------------------------------------------------------------------------\n\n// Basic sky background. Gets lighter as the ray aligns with the sun vector and/or closer to horizon.\nvec3 CalcSky(Ray ray)\n{\n    vec3 black = vec3(0.0);\n\tvec3 color = mix(mix(HorizonColor, SkyColor, clamp(ray.direction.y * 2.0, 0.0, 1.0)), HorizonColor * 1.5, clamp(dot(ray.direction, -SunDir), 0.0, 1.0)); \n    \n    color = TimeLerp(black, color, TIME_Lighting, TIME_Sky);\n    \n    return color;\n}\n\n// Adjusted iq fog (https://iquilezles.org/articles/fog)\nvec3 CalcFog(vec3 color, RayHit hit, Camera camera)\n{\n    float dist = distance(camera.origin, hit.surfPos);\n    \n    float fogAmount = 1.0 - exp(-dist * 0.00002);\n    \n    float sunAmount = max(dot(camera.forward, SunDir), 0.2);\n    vec3  fogColor  = mix(SkyColor, SunColor, pow(sunAmount, 2.0)) * 25.5;\n    \n    return mix(color, fogColor, fogAmount * TimeLerp(0.0, 1.0, TIME_Sky, TIME_Fog));\n}\n\n// 'iq-style' outdoor lighting (https://iquilezles.org/articles/outdoorslighting).\nvec3 CalcLighting(RayHit hit)\n{\n    float shadow = hit.shadow;\n    \n    vec3  sunColor = SunColor * 4.5;\n    float sunContr = clamp(dot(hit.surfNorm, SunDir), 0.0, 1.0);\n    vec3  sunLight = sunColor * sunContr * shadow;\n    \n    vec3  skyColor = SkyColor;\n    float skyContr = clamp(0.5 + (0.5 * hit.surfNorm.y), 0.0, 1.0);\n    vec3  skyLight = skyColor * skyContr;\n    \n    vec3  ambColor = AmbColor;\n    float ambContr = clamp(dot(hit.surfNorm, normalize(SunDir * vec3(-1.0, 0.0, -1.0))), 0.0, 1.0);\n    vec3  ambLight = ambColor * ambContr;\n    \n    return sunLight + skyLight + ambLight;\n}\n\n// Red == too steep for vegetation to grow; Green == OK for vegetation\nvec3 VisualizeSteepness(float steepness)\n{\n    return mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), SteepnessRatio(steepness)) * 0.2;\n}\n\n// Creates grass or cliff texture based on surface steepness\nvec3 CreateTexture(in RayHit hit)\n{\n    // Create toned down diffuse textures to account for later gamma correction\n    vec3 grass = GrassColor - (texture(iChannel0, hit.surfPos.xz * 0.1).r * 0.3);\n    vec3 cliff = CliffColor - (abs(sin(texture(iChannel1, hit.surfPos.xy * 0.01).r)) * 0.5);\n    \n    vec3 color = mix(cliff, grass, SteepnessRatio(hit.steepness)) * 0.2;\n    \n    return TimeLerp(vec3(0.2), color, TIME_SteepnessB, TIME_Texture);\n}\n\n// Creates lazy and bad water \nvec3 CreateWater(in vec3 color, in RayHit hit, in vec3 rayDir)\n{\n    // Calculate the water surface position by following ray backwards to water level\n    vec3 waterSurfPos = hit.surfPos + -rayDir * (hit.surfPos.y / rayDir.y);\n    \n    // Color water from the deep to shallow based on water depth (distance from shoreline/sea level)\n    vec3 waterColor = mix(WaterShallowColor, WaterDeepColor, clamp((Shoreline - hit.surfPos.y) * 0.5, 0.0, 1.0));\n    \n    // Apply lazy waves that move towards land\n    waterColor = waterColor - sin(texture(iChannel0, (waterSurfPos.xz - vec2(iTime, iTime * 3.0)) * 0.01).r) * 0.15;\n    \n    // Mix between surface and water color. *5.0 controls the sharpness of the transition.\n    color = mix(waterColor, color, clamp((hit.surfPos.y - Shoreline) * 5.0, 0.0, 1.0));\n    \n    return color;\n}\n\n// Applies color to the geometry\nvec3 ApplyMaterial(in Ray ray, in RayHit hit, in Camera camera)\n{\n    vec3 color = vec3(0.0);\n    \n    // Albedo is either the heightmap value (for 2D view) or a generated texture (for 3D view).\n    vec3 albedo = TimeLerp(vec3(hit.heightmap), CreateTexture(hit), TIME_3DExtrude, TIME_Lighting);\n\n    // Apply steepness color for steepness preview if needed\n    color = TimeLerp(TimeLerp(albedo, VisualizeSteepness(hit.steepness), TIME_Fog, TIME_SteepnessA), albedo, TIME_SteepnessA, TIME_SteepnessB);\n        \n    // Calculate lighting value for the surface\n    vec3 lighting = TimeLerp(vec3(1.0), CalcLighting(hit), TIME_3DExtrude, TIME_Lighting);\n\n    // Apply lighting\n    color *= lighting;\n\n    // Color in fake water\n    color = TimeLerp(color, CreateWater(color, hit, ray.direction), TIME_Texture, TIME_Water);\n    \n    // Apply fog\n    color = CalcFog(color, hit, camera);\n    \n\treturn color;   \n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nvec3 UnpackR8G8B8(float f)\n{\n    uint ufloat = uint(f);\n    return vec3(float(ufloat & 0xFFu), float((ufloat >> 8) & 0xFFu), float((ufloat >> 16) & 0xFFu)) * 0.00392156862;\n}\n\nvec3 UnpackNorm(float f)\n{\n\treturn (UnpackR8G8B8(f) * 2.0) - 1.0;   \n}\n\n// Rebuilds the RayHit structure from the hitInfo vector.\nRayHit BuildRayHit(in Ray ray, in vec4 hitInfo)\n{\n\tRayHit hit;\n    \n    vec3  hitSurfNorm  = UnpackNorm(hitInfo.r);    \n    vec3  hitSceneInfo = UnpackR8G8B8(hitInfo.g);  // .r = 2D heightmap value, .g = shadow value, .b = steepness\n    float hitDepth     = hitInfo.b;\n    \n    hit.hit       = (hitInfo.a > Epsilon ? true : false);\n    hit.surfPos   = ray.origin + (ray.direction * hitDepth);\n    hit.surfNorm  = hitSurfNorm;\n    hit.heightmap = hitSceneInfo.r;\n    hit.shadow    = hitSceneInfo.g;\n    hit.steepness = (hitSceneInfo.b * 2.0) - 1.0;\n    \n    return hit;\n}\n\n\n// Retrieves the geometry info for the uv and shades the scene.\nvec3 TraceHit(in Camera camera, in vec4 hitInfo, vec2 uv)\n{\n    Ray ray = Camera_GetRay(camera, uv);\n    RayHit hit = BuildRayHit(ray, hitInfo);\n    \n    if(hit.hit)\n    {\n        if(iTime < TIME_3DExtrude)\n        {\n            return PreviewColorScale(hit.heightmap);\n        }\n        else\n        {\n        \treturn ApplyMaterial(ray, hit, camera);\n        }\n    }\n    else\n    {\n        return CalcSky(ray);\n    }\n}\n\nvec3 GammaCorrect(vec3 color)\n{\n    vec3 corrected = pow(color, vec3(1.0 / 2.2));\n    return TimeLerp(color, corrected, TIME_3DExtrude, TIME_Lighting);   // Dont apply gamma correct to 2D view\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    if(iTime < TIME_Blank)\n    {\n        return;\n    }\n    \n    vec4 hitInfo = texelFetch(iChannel2, ivec2(fragCoord), 0);   // Retrive the G-Buffer info for this pixel\n    \n    // Camera starts out looking straight down to mimic 2D view, then eventually pans up for 3D view.\n    vec3 camPos  = TimeLerp(vec3(0.0, 300.0, 0.0), vec3(120.0, MaxHeight * 0.475, 0.0), TIME_2DPause, TIME_3DLookUp);\n    vec3 camLook = TimeLerp(vec3(0.0, 0.0, 1.0), vec3(500.0, MaxHeight * 0.7, 300.0), TIME_2DPause, TIME_3DLookUp);\n\n    Camera camera = Camera_LookAt(camPos, camLook);\n\n    fragColor.rgb = TraceHit(camera, hitInfo, uv);    // Color the scene according to the G-Buffer info\n    fragColor.rgb = GammaCorrect(fragColor.rgb);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}