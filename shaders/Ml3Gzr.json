{
    "Shader": {
        "info": {
            "date": "1467666675",
            "description": "Just a little plaything",
            "flags": 0,
            "hasliked": 0,
            "id": "Ml3Gzr",
            "likes": 4,
            "name": "Sphere Marching Experiment",
            "published": 3,
            "tags": [
                "spheremarching"
            ],
            "usePreview": 0,
            "username": "culdevu",
            "viewed": 600
        },
        "renderpass": [
            {
                "code": "\n// distance functions\nfloat dPoint(vec3 p)\n{\n    float ret;\n    ret = length(p);\n    return ret;\n}\n\nfloat dPlane(vec3 p, vec3 norm)\n{\n    float ret;\n    ret = dot(-p, norm);\n    \n    return ret;\n}\n\nfloat dSphere(vec3 p, float rad)\n{\n    float ret;\n    float len = length(p);\n    ret = len - rad;\n    return ret;\n}\n\nfloat dCylinder(vec3 p, vec3 dir, float rad)\n{\n    float ret;\n    vec3 closest = p - dir * dot(p, dir);\n    float lenClosest = length(closest);\n    \n    ret = lenClosest - rad;\n    \n    return ret;\n}\n\n// main functions\nmat3 sphereAnim;\n\nvec2 rMax(vec2 r1, vec2 r2)\n{\n    if (r1.x < r2.x)\n        return r1;\n    return r2;\n}\n\nvec2 findNearest(vec3 o)\n{\n    vec2 ret;\n    \n    ret = vec2(dPlane(vec3(0, -2, 0) - o, vec3(0, 1, 0)), 0.0);\n    ret = rMax(ret, vec2(dPlane(vec3(-9, 0, 0) - o, vec3(1, 0, 0)), 0));\n    ret = rMax(ret, vec2(dPlane(vec3(9, 0, 0) - o, vec3(-1, 0, 0)), 0));\n    ret = rMax(ret, vec2(dPlane(vec3(0, 0, -9) - o, vec3(0, 0, 1)), 0));\n    ret = rMax(ret, vec2(dPlane(vec3(0, 0, 9) - o, vec3(0, 0, -1)), 0));\n    \n    ret = rMax(ret, vec2(dSphere(vec3(0, -1, 0) - o, 1.0), 2));\n    //ret = rMax(ret, vec2(fTruncatedOctahedron(vec3(0, -1, 0) - o, 1.), 2));\n    ret = rMax(ret, vec2(dSphere(sphereAnim * vec3(2.3, -1, 0) - o, 0.25), 2));\n    ret = rMax(ret, vec2(dSphere(sphereAnim * vec3(-2.3, -1, 0) - o, 0.25), 2));\n    ret = rMax(ret, vec2(dSphere(sphereAnim * vec3(0, -1, 2.3) - o, 0.25), 2));\n    ret = rMax(ret, vec2(dSphere(sphereAnim * vec3(0, -1, -2.3) - o, 0.25), 2));\n    \n    ret = rMax(ret, vec2(dCylinder(vec3(2, 0, 0) - o, vec3(0, 1, 0), 1.0), 1));\n    \n    ret.x = max(0.0, ret.x);\n    \n    //return ret;\n    return ret;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    findNearest(pos+eps.xyy).x - findNearest(pos-eps.xyy).x,\n\t    findNearest(pos+eps.yxy).x - findNearest(pos-eps.yxy).x,\n\t    findNearest(pos+eps.yyx).x - findNearest(pos-eps.yyx).x);\n\treturn normalize(nor);\n}\n\nvec2 calcUV(vec3 pos, vec3 norm)\n{\n    vec3 temp = pos / 5.0;\n    vec3 temp2 = vec3(1, 0, 0);\n    \n    if (abs(dot(temp2, norm)) > 0.99)\n        temp2 = vec3(0, 1, 0);\n    \n    vec3 tang = cross(norm, temp2);\n    vec3 bivec = cross(norm, tang);\n    \n    return vec2(dot(temp, tang), dot(temp, bivec));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy / iResolution.y;\n   \tvec3 pxlLoc = 2.0 * vec3(uv, 0) - vec3(iResolution.x / iResolution.y, 1, 0);\n    vec3 origin = vec3(0, 0, 2);\n    \n    float mouseX = iMouse.x / iResolution.x;\n    \n    // camera animation\n    {\n        float angle = 2.0 * 3.14159 * mouseX; //0.5 * iTime;\n        mat3 rot = mat3(cos(angle), 0, -sin(angle),\n                        0, 1, 0,\n                        sin(angle), 0, cos(angle));\n        pxlLoc = rot * pxlLoc;\n        origin = rot * origin;\n   \n        //vec3 animOffset = vec3(4.0 * cos(iTime), 0, 4.0 * sin(iTime));\n        vec3 animOffset = rot * vec3(0, 0, 5.0);\n        origin += animOffset;\n        pxlLoc += animOffset;\n    }\n    \n    // sphere animation\n    {\n        float angle = 1.9 * iTime;\n        sphereAnim = mat3(cos(-angle), 0, -sin(-angle),\n                          0, 1, 0,\n                          sin(-angle), 0, cos(-angle));\n    }\n    \n    //------------------------------\n    // Ray tracing\n    //------------------------------\n    vec3 ray = normalize(pxlLoc - origin);\n    vec2 t;\n    for (int i = 0; i < 32; ++i)\n    {\n        t = findNearest(origin);\n        origin += t.x * ray;\n    }\n    \n    // didn't hit anything\n    if (t.x > 10.0)\n    {\n        fragColor = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    vec3 intersect = origin;\n    vec3 norm = calcNormal(intersect);\n    vec2 uvCoord = calcUV(intersect, norm);\n    \n    //------------------------------\n    // Lighting\n    //------------------------------\n    float ambient = 1.0;\n    vec3 albedo;\n    \n    if (-0.5 < t.y && t.y < 0.5)\n    {\n        albedo = vec3(texture(iChannel0, uvCoord));\n    }\n    else if (0.5 < t.y && t.y < 1.5)\n    {\n        albedo = vec3(texture(iChannel1, uvCoord));\n    }\n    else if (1.5 < t.y && t.y < 2.5)\n    {\n        albedo = vec3(texture(iChannel2, uvCoord));\n    }\n    \n    // direct lighting\n    vec3 lightPos = vec3(2, 2, -5);\n    float flux = 9.0;\n    \n    vec3 rToLight = lightPos - intersect;\n    float dToLight = length(rToLight);\n    float directLight = flux * max(0.0, dot(rToLight, norm)) / (dToLight * dToLight);\n    \n    // shadow casting\n    float smallestDist = 8000.0;\n    float largestTolerance = 0.25;\n    vec3 sray = normalize(lightPos - intersect);\n    vec3 sorigin = intersect + sray * largestTolerance / max(0.001, dot(norm, sray));\n    for (int i = 1; i < 20; ++i)\n    {\n        t = findNearest(sorigin);\n        \n        float d = clamp(t.x, 0.0, dToLight - dot(sray, sorigin + t.x * sray - intersect));\n        sorigin += d * sray;\n        \n        if (smallestDist > t.x)\n        {\n            smallestDist = t.x;\n        }\n    }\n    \n    float penumbra = clamp(smallestDist / largestTolerance, 0.0, 1.0);\n    directLight *= penumbra;\n    \n    // AO\n    vec3 aoOrigin = intersect + 0.05 * norm;\n    vec3 aoRay = norm;\n    for (int i = 0; i < 4; ++i)\n    {\n        t = findNearest(aoOrigin);\n        aoOrigin += t.x * aoRay;\n    }\n    \n    float dist = max(0.0, min(0.8, dot(norm, aoOrigin - intersect)));\n    float ao = pow(dist / 0.8, 0.5);\n    \n    float ambientLight = ambient * ao;\n    \n    // final lighting\n    float irrad = directLight + ambientLight;\n    vec3 d = albedo * irrad;\n    d.xyz = d.xyz / (d.xyz + 1.0);\n    \n    fragColor = vec4(d.x, d.y, d.z, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}