{
    "Shader": {
        "info": {
            "date": "1561491571",
            "description": "Tests:\n1. Anti-aliasing\n2. shadows\n3. SSAO\n4. refraction + reflection from reference: http://stemkoski.github.io/Three.js/Bubble.html\n5. SDF functions: http://iquilezles.org/articles/distfunctions/distfunctions.htm",
            "flags": 0,
            "hasliked": 0,
            "id": "tlf3Rs",
            "likes": 12,
            "name": "Maybe a glassy mushroom ",
            "published": 3,
            "tags": [
                "reflection",
                "refraction"
            ],
            "usePreview": 0,
            "username": "zxxuan1001",
            "viewed": 639
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926\n#define EPSILON 0.001\nconst int MAX_STEPS = 120;\nconst float MAX_DISTANCE = 100.0;\nconst float AA_SIZE = 2.0;\nconst vec3 LIGHT_COLOR = vec3(1.0, 1.0, 1.0);\n\nvec3 light_position;\n\nfloat plane(vec3 p) \n{\n    return p.y;\n}\n\nfloat displacement (vec3 p) \n{\n    return sin(p.y) * 1.5;\n}\n\nfloat sphereSDF(vec3 p, float r) \n{\n    return length(p) - r;\n}\n\nfloat dot2(in vec2 v) {\n    return dot(v, v);\n}\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nvec2 unionSDF(vec2 d1, vec2 d2) \n{\n    return d1.x < d2.x? d1 : d2;\n}\n\nvec3 doTranslate(vec3 p, vec3 offset) \n{\n    return p - offset;\n}\n\nvec2 sceneSDF(vec3 p) \n{\n    vec2 result0 = vec2(plane(p), -1.0);\n    \n    vec3 p1= doTranslate(p,vec3(0.0, 3.0 , 0.0));\n    vec2 result1 = vec2(sphereSDF( p1 , 2.5) + displacement(p1), 2.0);\n    result1.x *= 0.5;\n    \n    vec3 p2= doTranslate(p,vec3(3.0, 3.5 , 0.0));\n    vec2 result2 = vec2(sphereSDF( p2 , 2.5), 2.0);\n    \n    vec3 p3 = doTranslate(p,vec3(0.0, 0.0 , 0.0));\n    vec2 result3 = vec2(sdCappedCone(p3, 1.5, 3.0, 2.2), 3.0);  \n    \n    \n    vec2 result = unionSDF(result0, result1);\n    //result = unionSDF(result, result2);\n    //result = unionSDF(result, result3);\n    return result;\n}\n\nvec2 marching(vec3 ro, vec3 rd) \n{\n    float tmax = MAX_DISTANCE;\n    float t = 0.001;\n    vec2 result = vec2(-1.0);\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * t;\n        vec2 res = sceneSDF(p);\n        if (res.x < EPSILON)\n        {\n            return result;\n        }\n        else if (t > tmax)\n        {\n            result.y = -1.0;\n            result.x = tmax;\n            break;\n        }\n        t += res.x;\n        result.x = t;\n        result.y = res.y;\n    }\n    \n    return result;\n}\n\nfloat calcShadow(in vec3 ro, in vec3 rd) {\n    float mint = 0.1;\n    float t = mint;\n    float res = 1.0;\n    float k = 4.0;\n    for (int i = 0; i < 40; i++)\n    {\n        float h = sceneSDF(ro + rd * t).x;\n        \n\t\tres = min( res, k * h / t );\n        t += clamp( h, 0.02, 0.20 );\n     \n        if ( h < EPSILON ) \n        {\n            res = min(res, 0.0);\n            break;\n        } \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    //float k = 5.0; \n    float h = 0.001;\n    for( float i = 0.0; i < 5.0; i++ )\n    {\n        float d = sceneSDF( pos + h * nor ).x;\n        occ += ( h - d ) * sca;\n        sca *= 0.9;\n        h += 0.45 * i / 5.0;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec2 OFFSET = vec2(EPSILON, 0.0);\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(p + OFFSET.xyy).x - sceneSDF(p - OFFSET.xyy).x,\n        sceneSDF(p + OFFSET.yxy).x - sceneSDF(p - OFFSET.yxy).x,\n        sceneSDF(p + OFFSET.yyx).x - sceneSDF(p - OFFSET.yyx).x\n    ));\n}\n\nvec3 shading(vec3 ro, vec3 p, float objId) \n{\n    vec3 outCol = vec3(0.0);\n    vec3 lightPos = light_position; \n    vec3 viewDir = ro - p;\n    vec3 lightDir = lightPos - p;\n    float dist = length(lightDir);\n    \n    vec3 nor = vec3(0.0);\n    nor = getNormal(p);\n    vec3 diffCol = LIGHT_COLOR;\n    if (objId == -1.0) \n    {//floor\n        vec2 offset = vec2(0.002, 0.0);\n        vec2 floorUV = p.xz * 5.0/MAX_DISTANCE;\n        diffCol = texture(iChannel1, floorUV).rgb; \n        float dx = texture(iChannel1, floorUV + offset.xy).r \n            \t - texture(iChannel1, floorUV - offset.xy).r ;\n        float dz = texture(iChannel1, floorUV + offset.yx).r \n            \t - texture(iChannel1, floorUV - offset.yx).r ;\n        nor = normalize(vec3(dx, 1.0, dz ));\n    } \n    vec3 N = nor;\n    vec3 I = normalize(viewDir);\n    vec3 L = normalize(lightDir);\n    vec3 R = normalize(reflect(-L, N));\n    vec3 RV = normalize(reflect(-I, N));\n\n    float ao = calcAO(p, N) ;\n    vec3 ambient = LIGHT_COLOR * ao * 0.3;\n    float diff = max(dot(L, N), 0.0);\n    float sd = calcShadow(p, normalize(lightPos));\n     \n    vec3 diffuse = diffCol * diff * sd * 0.5 ;\n    float spec = pow(max(dot(I, R), 0.0), 16.0);\n    vec3 specular = LIGHT_COLOR * spec * 0.8;\n    outCol = LIGHT_COLOR * (ambient + diffuse + specular);\n    \n    //reflection + refraction\n    vec3 refl = texture(iChannel0, RV).rgb;\n    \n    float refractRatio = 0.95;\n    float fresnelBias = 0.0;\n    float fresnelPow = 0.2;\n    float fresnelScale = 1.0;\n    float reflectionFactor = clamp(fresnelBias + fresnelScale * pow( 1.0 + dot( -I, N ), fresnelPow ), 0.0, 1.0);\n        \n    vec3 refractR = normalize(refract(-I, N, refractRatio));\n    vec3 refractG = normalize(refract(-I, N, refractRatio * 0.98));\n    vec3 refractB = normalize(refract(-I, N, refractRatio * 0.96));\n    \n    float level = smoothstep(0.8, 1.2, p.y); //adding a bit blur\n    //if (p.y > 1.0)\n    //{\n        vec3 refractCol = vec3(1.0);\n        refractCol.r = texture(iChannel0, refractR).r;\n        refractCol.g = texture(iChannel0, refractG).g;\n        refractCol.b = texture(iChannel0, refractB).b;\n        vec3 fr = mix(refl, refractCol, reflectionFactor);\n        outCol = mix(outCol, fr, level);\n    //}\n    \n    return outCol;\n}\n\nmat3 getCamera( in vec3 ro, in vec3 ta)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 render(in vec2 fragCoord) \n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5; // translate to the center of the screen\n    uv.x *= iResolution.x/iResolution.y; // restore aspect ratio\n    \n    vec3 col = vec3(0.0);\n    vec2 mouse = vec2(0.01) + iMouse.xy  / iResolution.xy ;\n    mouse -= 0.5;\n    float t = iTime * 0.1;\n    \n    vec3 ro = vec3(10.0 * cos(mouse.x * 2.0 * PI + t), 2.0 + mouse.y * 4.0, 10.0 * sin(mouse.x * 2.0 * PI + t));\n    //vec3 ro = vec3(0.0, 5.0, 10.0);\n    vec3 ta = vec3(0.0, 2.0, 0.0);\n    mat3 cam = getCamera(ro, ta);\n    vec3 rd = normalize(cam * vec3(uv, 1.0));\n    \n    vec2 h = marching(ro, rd);\n    vec3 p = ro + rd * h.x;\n    if (h.x < MAX_DISTANCE) \n    {\n      \n        col += shading(ro, p, h.y);\n    } else \n    {\n        col += texture(iChannel0, rd).rgb;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    float count = 0.0;\n    light_position = vec3(0.0, 10.0, 4.0);\n    for (float aay = 0.0; aay < AA_SIZE; aay++) \n    {\n        for (float aax = 0.0; aax < AA_SIZE; aax++) \n        {\n            col += render(fragCoord + vec2(aax, aay)/AA_SIZE);\n            count++;\n        }\n    }\n    \n    col /= count;\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}