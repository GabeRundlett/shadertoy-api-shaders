{
    "Shader": {
        "info": {
            "date": "1523884279",
            "description": "Sandbox for RGB to HSV/HSL conversions and vice versa\n\nThings to notice:\n1) There's a visible difference between changing the \"V\" in HSV and the \"L\" in HSL\n2) The round-trip of HSV is slightly more accurate than HSL (but not worth considering in reality)",
            "flags": 0,
            "hasliked": 0,
            "id": "4dKcWK",
            "likes": 32,
            "name": "RGB to HSV/HSL",
            "published": 3,
            "tags": [
                "rgb",
                "hsv",
                "hsl"
            ],
            "usePreview": 1,
            "username": "tayloia",
            "viewed": 5277
        },
        "renderpass": [
            {
                "code": "const float EPSILON = 1e-10;\n\nvec3 HUEtoRGB(in float hue)\n{\n    // Hue [0..1] to RGB [0..1]\n    // See http://www.chilliant.com/rgb2hsv.html\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\n\nvec3 RGBtoHCV(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Chroma-Value [0..1]\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1., 2. / 3.) : vec4(rgb.gb, 0., -1. / 3.);\n    vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);\n    float c = q.x - min(q.w, q.y);\n    float h = abs((q.w - q.y) / (6. * c + EPSILON) + q.z);\n    return vec3(h, c, q.x);\n}\n\nvec3 HSVtoRGB(in vec3 hsv)\n{\n    // Hue-Saturation-Value [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsv.x);\n    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nvec3 HSLtoRGB(in vec3 hsl)\n{\n    // Hue-Saturation-Lightness [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsl.x);\n    float c = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * c + hsl.z;\n}\n\nvec3 RGBtoHSV(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Saturation-Value [0..1]\n    vec3 hcv = RGBtoHCV(rgb);\n    float s = hcv.y / (hcv.z + EPSILON);\n    return vec3(hcv.x, s, hcv.z);\n}\n\nvec3 RGBtoHSL(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Saturation-Lightness [0..1]\n    vec3 hcv = RGBtoHCV(rgb);\n    float z = hcv.z - hcv.y * 0.5;\n    float s = hcv.y / (1. - abs(z * 2. - 1.) + EPSILON);\n    return vec3(hcv.x, s, z);\n}\n\n// RGB\n\nvec3 image0(vec3 rgb) {\n    // Just return the raw image value\n    return rgb;\n}\n\nvec3 image1(vec3 rgb) {\n    // Return the greyscale of the image\n\tconst vec3 weights = vec3(0.299, 0.587, 0.114);\n    return vec3(dot(rgb, weights));\n}\n\nvec3 image2(vec3 rgb) {\n    // Return the exaggerated hue of the image\n    float hue = RGBtoHCV(rgb).x;\n    return HUEtoRGB(hue);\n}\n\n// HSL\n\nvec3 image3(vec3 rgb) {\n    // Round-trip RGB->HSL->RGB with time-dependent hue shift\n    vec3 hsl = RGBtoHSL(rgb);\n    hsl.x = fract(hsl.x + iTime * 0.15);\n    return HSLtoRGB(hsl);\n}\n\nvec3 image4(vec3 rgb) {\n    // Round-trip RGB->HSL->RGB with time-dependent lightness\n    vec3 hsl = RGBtoHSL(rgb);\n    hsl.z = pow(hsl.z, sin(iTime) + 1.5);\n    return HSLtoRGB(hsl);\n}\n\nvec3 image5(vec3 rgb) {\n    // Round-trip RGB->HSL->RGB and display exaggerated errors\n    vec3 hsl = RGBtoHSL(rgb);\n    return abs(rgb - HSLtoRGB(hsl)) * 10000000.;\n}\n\n// HSV\n\nvec3 image6(vec3 rgb) {\n    // Round-trip RGB->HSV->RGB with time-dependent lightness\n    vec3 hsv = RGBtoHSV(rgb);\n    hsv.y = clamp(hsv.y * (1. + sin(iTime * 1.5)), 0., 1.);\n    return HSVtoRGB(hsv);\n}\n\nvec3 image7(vec3 rgb) {\n    // Round-trip RGB->HSV->RGB with time-dependent value\n    vec3 hsv = RGBtoHSV(rgb);\n    hsv.z = pow(hsv.z, sin(iTime) + 1.5);\n    return HSVtoRGB(hsv);\n}\n\nvec3 image8(vec3 rgb) {\n    // Round-trip RGB->HSV->RGB and display exaggerated errors\n    vec3 hsv = RGBtoHSV(rgb);\n    return abs(rgb - HSVtoRGB(hsv)) * 10000000.;\n}\n\n// sRGB\n\nvec3 SRGBtoRGB(vec3 srgb) {\n    // See http://chilliant.blogspot.co.uk/2012/08/srgb-approximations-for-hlsl.html\n    // This is a better approximation than the common \"pow(rgb, 2.2)\"\n    return pow(srgb, vec3(2.1632601288));\n}\n\nvec3 RGBtoSRGB(vec3 rgb) {\n    // This is a better approximation than the common \"pow(rgb, 0.45454545)\"\n    return pow(rgb, vec3(0.46226525728));\n}\n\nvec3 image(int panel, vec2 uv) {\n    vec3 rgb = SRGBtoRGB(texture(iChannel0, uv).rgb);\n    switch (panel) {\n        case 0: return RGBtoSRGB(image0(rgb));\n        case 1: return RGBtoSRGB(image1(rgb));\n        case 2: return RGBtoSRGB(image2(rgb));\n        case 3: return RGBtoSRGB(image3(rgb));\n        case 4: return RGBtoSRGB(image4(rgb));\n        case 5: return RGBtoSRGB(image5(rgb));\n        case 6: return RGBtoSRGB(image6(rgb));\n        case 7: return RGBtoSRGB(image7(rgb));\n        case 8: return RGBtoSRGB(image8(rgb));\n    }\n    return vec3(0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const float ROWS = 3.;\n    const float COLUMNS = 3.;\n    const float GAP = 0.05;\n    // If ROWS=3 and COLUMNS=3 then the layout of the panels is:\n    //\n    // \t+---+---+---+\n    // \t| 6 | 7 | 8 |\n    // \t+---+---+---+\n    // \t| 3 | 4 | 5 |\n    // \t+---+---+---+\n    // \t| 0 | 1 | 2 |\n    // \t+---+---+---+\n    //\n    vec3 srgb = vec3(0.1);\n    vec2 uv = fragCoord / iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n    uv.x -= (1. - COLUMNS / ROWS) * 0.5; // Centre the panels according to the aspect ratio\n    uv = uv * (ROWS + GAP) - GAP; // Add gaps between panels\n    if ((uv.x >= 0.) && (uv.y >= 0.) && (uv.x < COLUMNS))\n    {\n        // We're inside the main panel region\n        ivec2 iuv = ivec2(uv);\n        uv = fract(uv) * (1. + GAP);\n        if (max(abs(uv.x), abs(uv.y)) < 1.)\n        {\n\t        // We're inside one of the panels\n\t        int panel = iuv.x + iuv.y * int(COLUMNS);\n            srgb = image(panel, uv);\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(srgb, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}