{
    "Shader": {
        "info": {
            "date": "1369659042",
            "description": "This demonstrates the effect of quantization in gamma and linear space (watch fullscreen and see the banding).\nIt's basically a live example of the problem shown in this article:\n\nhttp://hacksoflife.blogspot.jp/2010/11/value-of-gamma-compression.html\n",
            "flags": 0,
            "hasliked": 0,
            "id": "XdX3D4",
            "likes": 17,
            "name": "Gamma and quantization",
            "published": 3,
            "tags": [
                "gammaspace",
                "linearspace",
                "quantization",
                "colorbits"
            ],
            "usePreview": 0,
            "username": "Zavie",
            "viewed": 5475
        },
        "renderpass": [
            {
                "code": "/*\n\nThis shader demonstrates the effect of gamma and\nquantization.\n\nEach gradient is generated using only a limited\nnumber of bits per channel: you can define this\nnumber here after.\n\nThe gradients are then shown in linear space and\nin gamma space. Notice how the banding in the\ndark colors becomes more visible in gamma space.\n\nThe vertical lighter line shows where the\ngradients should reach half luminosity (that's\nwhere the contrast with the grainy color\nunderneath should be minimal).\n\nMore info:\nhttp://hacksoflife.blogspot.jp/2010/11/value-of-gamma-compression.html\nhttp://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html\n\n--\nZavie\n\n*/\n\nivec3 bitsPerChannel = ivec3(5, 6, 5);\nfloat gamma = 2.2;\n\n\nvec3 checker(vec2 coord, vec3 color)\n{\n  float intensity = float(mod(coord.x, 2.) == mod(coord.y, 2.));\n  return intensity * color;\n}\n\nvec3 shade(vec2 uv, vec3 color)\n{\n  float intensity = uv.x;\n  return intensity * color;\n}\n\nvec3 quantized(vec3 color, ivec3 bits)\n{\n  vec3 range = pow(vec3(2.), vec3(bits));\n  return floor(color * range) / range;\n}\n\n\nvec3 getColor(float x)\n{\n  int i = int(floor(13. * x));\n\n  if (i == 0) return vec3(1., 0., 0.);\n  if (i == 1) return vec3(1., .5, 0.);\n  if (i == 2) return vec3(1., 1., 0.);\n  if (i == 3) return vec3(.5, 1., 0.);\n  if (i == 4) return vec3(0., 1., 0.);\n  if (i == 5) return vec3(0., 1., .5);\n  if (i == 6) return vec3(0., 1., 1.);\n  if (i == 7) return vec3(0., .5, 1.);\n  if (i == 8) return vec3(0., 0., 1.);\n  if (i == 9) return vec3(.5, 0., 1.);\n  if (i == 10) return vec3(1., 0., 1.);\n  if (i == 11) return vec3(1., 0., .5);\n\n  return vec3(1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 color;\n\n\tif (fract(13. * uv.y) < 0.2)\n\t\tcolor = checker(fragCoord.xy, getColor(uv.y));\n\telse\n\t\tcolor = shade(uv, getColor(uv.y));\n\n\tfloat halfLuminosity = 0.5;\n\t\n\tif (mod(iDate.w, 8.) > 4.)\n\t{\n\t\thalfLuminosity = pow(halfLuminosity, 1./gamma);\n\t\tcolor = pow(color, vec3(gamma));\n\t}\n\tif (mod(iDate.w, 4.) > 2.)\n    {\n\t\tcolor = quantized(color, bitsPerChannel);\n    }\n\tcolor = pow(color, vec3(1./gamma));\n\n\tif (abs(uv.x - halfLuminosity) < 0.001)\n\t\tcolor = mix(color, vec3(1.), 0.3);\n\n\tfragColor = vec4(color, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}