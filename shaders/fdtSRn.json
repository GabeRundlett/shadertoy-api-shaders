{
    "Shader": {
        "info": {
            "date": "1632495948",
            "description": "CIE (1964) 10-deg chromaticity coordinates.\n[When Left Image Clicked] Displaying clicked pixel color on XY Chromaticity Diagram.\n[When Right Diagram Clicked] Fill the left image area with yellow\n(Triangle is sRGB color space)",
            "flags": 0,
            "hasliked": 0,
            "id": "fdtSRn",
            "likes": 9,
            "name": "XY Chromaticity Diagram(CIE1964)",
            "published": 3,
            "tags": [
                "2d",
                "color",
                "static",
                "cie"
            ],
            "usePreview": 0,
            "username": "mosan_hoshi",
            "viewed": 426
        },
        "renderpass": [
            {
                "code": "// writen by mossan-hoshi\n//// twitter : https://twitter.com/mossan_hoshi\n//// GitHub : https://github.com/mossan-hoshi/\n//// ShaderToy : https://www.shadertoy.com/user/mosan_hoshi\n\n\n#define MARGIN 0.05\n#define TILE_WIDTH ((1. - 3. * MARGIN) / 2.)\n#define TILE_HEIGHT TILE_WIDTH\n#define RIGHT_START  vec2(MARGIN * 2. + TILE_WIDTH,MARGIN)\n#define LEFT_START  vec2(MARGIN,MARGIN)\n#define TEXTURE_ASPECT_RATIO (iChannelResolution[0].y / iChannelResolution[0].x)\n#define INSIDE_CIRCLE_RADIUS 0.003\n#define OUTSIDE_CIRCLE_RADIUS 0.01\n#define NEAR_COLOR_DISTANCE 0.02\n#define GAMMA_VALUE 2.2\n\nvec3 xy2Rgb(vec2 xy){\n  // xyz to rgb matrix\n  // http://k-ichikawa.blog.enjoy.jp/etc/HP/js/CIEXYZ2/cie3.html\n  vec3 xyz = vec3(xy, 1. - xy.x - xy.y);\n\n  // xyz => CIE \n  // vec3[3] matxyz2RGB = vec3[](vec3( 2.3655, -0.8971, -0.4683),\n  //                             vec3(-0.5151,  1.4264,  0.0887),\n  //                             vec3( 0.0052,  0.0144,  1.0089));\n  // xyz => sRGB\n  vec3[3] matxyz2RGB = vec3[](vec3( 3.2410, -1.5374, -0.4986),\n                              vec3(-0.9692,  1.8760,  0.0416),\n                              vec3( 0.0556, -0.2040,  1.0507));\n  vec3 rgb = vec3(dot(matxyz2RGB[0],xyz),\n                  dot(matxyz2RGB[1],xyz),\n                  dot(matxyz2RGB[2],xyz));\n  return rgb;\n}\n\nvec3 RGB2xyz(vec3 RGB){\n  // xyz to rgb matrix\n  // http://k-ichikawa.blog.enjoy.jp/etc/HP/js/CIEXYZ2/cie3.html\n  vec3 rgb = RGB / (RGB.x + RGB.y + RGB.z);\n  \n  // CIE => xyz\n  //vec3[3] matrgb2xyz = vec3[](vec3(.4898, .3101, .2001),\n  //                            vec3(.1769, .8124, .0107),\n  //                            vec3(.0000, .0100, .9903));\n  // sRGB => xyz\n  vec3[3] matrgb2xyz = vec3[](vec3(.4124, .3576, .1805),\n                              vec3(.2126, .7152, .0722),\n                              vec3(.0193, .1192, .9505));\n  \n  vec3 xyz = vec3(dot(matrgb2xyz[0],rgb),\n                  dot(matrgb2xyz[1],rgb),\n                  dot(matrgb2xyz[2],rgb));\n  xyz = xyz / (xyz.x + xyz.y + xyz.z);\n  return xyz;\n}\n\n// vec3 sRGB2xy(vec3 rgb){\n//   // xyz to rgb matrix\n//   // http://k-ichikawa.blog.enjoy.jp/etc/HP/js/CIEXYZ2/cie3.html\n// }\n\n\nbool isInside(vec3[71] convexPoints, vec2 center, in vec2 uv){\n  int n = 71; // point num\n\n  // inside-outside check(Crossing Number Algorithm)\n  // https://edom18.hateblo.jp/entry/2018/11/28/200032\n  int crossNumber = 0;\n  for(int i=0;i<n;i+=1){\n    int i2 = (i + 1) % n;\n\n    // cross check of two lines \n    // line1: convexPoints[i]~convexPoints[i+1]\n    // line2:              uv~(1.0, uv.y))\n    // y = a * x + b\n    // dy = a * dx\n    // a = (y2-y1)/(x2-x1)\n    // dy = (uv.y -y1)\n    float a = (convexPoints[i2].y - convexPoints[i].y) / (convexPoints[i2].x - convexPoints[i].x);\n    float dy = uv.y - convexPoints[i].y;\n    float dx = dy / a;\n    float b = convexPoints[i].y - a * convexPoints[i].x;\n    // uv.y = a * x2 + b\n    float x2 = (uv.y - b) / a;\n    crossNumber += int((abs(convexPoints[i2].x - convexPoints[i].x) > .0001)&&\n     ((convexPoints[i].y > uv.y) && (convexPoints[i2].y <= uv.y)||\n     ((convexPoints[i].y <= uv.y) && (convexPoints[i2].y > uv.y)))&&\n      (uv.x <= x2));\n  }\n\n  return crossNumber == 1;\n}\n\nbool isInsideHourseShoe(vec2 uv){\n  \n  // CIE (1964) 10-deg chromaticity coordinates\n  //// http://www.cvrl.org/cie.htm\n  //// x    ,    y   ,    z   ,   wave length[nm]\n  vec3[71] horseShoe = vec3[](\n    vec3(.182218, .019978, .797804),// 360,\n    vec3(.182098, .019938, .797964),// 365,\n    vec3(.181923, .019879, .798198),// 370,\n    vec3(.181671, .019797, .798532),// 375,\n    vec3(.181333, .019685, .798982),// 380,\n    vec3(.180906, .019542, .799552),// 385,\n    vec3(.180313, .019348, .800339),// 390,\n    vec3(.179466, .019044, .801491),// 395,\n    vec3(.178387, .018711, .802902),// 400,\n    vec3(.177122, .018402, .804476),// 405,\n    vec3(.175488, .018134, .806378),// 410,\n    vec3(.173231, .017806, .808963),// 415,\n    vec3(.170634, .017849, .811517),// 420,\n    vec3(.167902, .018708, .813390),// 425,\n    vec3(.165027, .020283, .814690),// 430,\n    vec3(.162170, .022487, .815343),// 435,\n    vec3(.159022, .025725, .815253),// 440,\n    vec3(.155391, .030017, .814592),// 445,\n    vec3(.151001, .036439, .812560),// 450,\n    vec3(.145945, .045217, .808838),// 455,\n    vec3(.138922, .058920, .802158),// 460,\n    vec3(.129520, .077870, .792610),// 465,\n    vec3(.115180, .109040, .775780),// 470,\n    vec3(.095732, .159090, .745178),// 475,\n    vec3(.072777, .229239, .697984),// 480,\n    vec3(.045167, .327343, .627490),// 485,\n    vec3(.020987, .440113, .538900),// 490,\n    vec3(.007302, .562523, .430175),// 495,\n    vec3(.005586, .674543, .319871),// 500,\n    vec3(.021874, .752578, .225548),// 505,\n    vec3(.049540, .802302, .148157),// 510,\n    vec3(.085024, .816976, .098000),// 515,\n    vec3(.125236, .810194, .064569),// 520,\n    vec3(.166408, .792172, .041421),// 525,\n    vec3(.207057, .766282, .026661),// 530,\n    vec3(.243642, .739873, .016486),// 535,\n    vec3(.278588, .711300, .010112),// 540,\n    vec3(.313230, .681278, .005492),// 545,\n    vec3(.347296, .650090, .002614),// 550,\n    vec3(.381161, .618164, .000675),// 555,\n    vec3(.414213, .585787, .000000),// 560,\n    vec3(.446924, .553076, .000000),// 565,\n    vec3(.479038, .520962, .000000),// 570,\n    vec3(.509641, .490359, .000000),// 575,\n    vec3(.538560, .461440, .000000),// 580,\n    vec3(.565444, .434556, .000000),// 585,\n    vec3(.589960, .410040, .000000),// 590,\n    vec3(.611597, .388403, .000000),// 595,\n    vec3(.630629, .369371, .000000),// 600,\n    vec3(.647127, .352873, .000000),// 605,\n    vec3(.661224, .338776, .000000),// 610,\n    vec3(.673055, .326945, .000000),// 615,\n    vec3(.682660, .317340, .000000),// 620,\n    vec3(.689759, .310241, .000000),// 625,\n    vec3(.695483, .304517, .000000),// 630,\n    vec3(.700989, .299011, .000000),// 635,\n    vec3(.705873, .294127, .000000),// 640,\n    vec3(.710249, .289751, .000000),// 645,\n    vec3(.713713, .286287, .000000),// 650,\n    vec3(.715619, .284381, .000000),// 655,\n    vec3(.716790, .283210, .000000),// 660,\n    vec3(.717887, .282113, .000000),// 665,\n    vec3(.718732, .281268, .000000),// 670,\n    vec3(.719344, .280656, .000000),// 675,\n    vec3(.719763, .280237, .000000),// 680,\n    vec3(.720016, .279984, .000000),// 685,\n    vec3(.720160, .279840, .000000),// 690,\n    vec3(.720296, .279704, .000000),// 695,\n    vec3(.720358, .279642, .000000),// 700,\n    vec3(.720324, .279676, .000000),// 705,\n    vec3(.720227, .279773, .000000)//,// 710,\n    // Trim non convex frequency\n    // vec3(.720090, .279910, .000000),// 715,\n    // vec3(.719911, .280089, .000000),// 720,\n    // vec3(.719694, .280306, .000000),// 725,\n    // vec3(.719447, .280553, .000000),// 730,\n    // vec3(.719186, .280814, .000000),// 735,\n    // vec3(.718906, .281094, .000000),// 740,\n    // vec3(.718609, .281391, .000000),// 745,\n    // vec3(.718292, .281708, .000000),// 750,\n    // vec3(.717959, .282041, .000000),// 755,\n    // vec3(.717607, .282393, .000000),// 760,\n    // vec3(.717240, .282760, .000000),// 765,\n    // vec3(.716859, .283141, .000000),// 770,\n    // vec3(.716464, .283536, .000000),// 775,\n    // vec3(.716057, .283943, .000000),// 780,\n    // vec3(.715637, .284363, .000000),// 785,\n    // vec3(.715208, .284792, .000000),// 790,\n    // vec3(.714770, .285230, .000000),// 795,\n    // vec3(.714325, .285675, .000000),// 800,\n    // vec3(.713872, .286128, .000000),// 805,\n    // vec3(.713411, .286589, .000000),// 810,\n    // vec3(.712943, .287057, .000000),// 815,\n    // vec3(.712471, .287529, .000000),// 820,\n    // vec3(.711999, .288001, .000000),// 825,\n    // vec3(.711523, .288477, .000000) // 830,\n  );\n  \n  vec2 whitePoint = vec2(0.3333,0.3333);\n\n  return isInside(horseShoe, whitePoint, uv);\n}\n\n\nvec3 deGamma(vec3 rgb) {\n  // gamma(sRGB)\n  // https://knowledge.shade3d.jp/knowledgebase/%E3%82%AC%E3%83%B3%E3%83%9E2-2%E3%81%A8srgb%E3%81%AE%E9%81%95%E3%81%84\n rgb = vec3(pow(rgb.x, GAMMA_VALUE),pow(rgb.y, GAMMA_VALUE),pow(rgb.z, GAMMA_VALUE));\n return rgb;\n}\n\n\nvec3 displayGamma(vec3 rgb) {\n  // gamma(sRGB)\n  // https://knowledge.shade3d.jp/knowledgebase/%E3%82%AC%E3%83%B3%E3%83%9E2-2%E3%81%A8srgb%E3%81%AE%E9%81%95%E3%81%84\n  vec3 val1 = 12.92 * rgb;\n  vec3 val2 = vec3(pow(rgb.x, 1. / 2.4),pow(rgb.y, 1. / 2.4),pow(rgb.z, 1. / 2.4)) * 1.055 - .055;\n  return (1. - step(.0031308,rgb)) * val1 + step(.0031308,rgb) * val2;\n}\n\nvec3 drawXYChromaticityDiagram(in vec2 uv){\n\n\n  vec3 rgb = xy2Rgb(uv);\n  float rgbSum = uv.x + uv.y;\n  rgbSum = 1. - step(1., rgbSum);\n\n  // display gamma\n  rgb = displayGamma(rgb * rgbSum);\n  rgb = step(.01,float(isInsideHourseShoe(uv))) * rgb;\n  return rgb;\n}\n\nfloat errorCheckUV(vec2 checkUV){\n  return float((checkUV.x < .0)||(checkUV.y < .0)||(checkUV.x > 1.)||(checkUV.y > 1.));\n}\n\nvec2 errorCheckUV(vec2 checkUV, vec2 returnUV){\n  float errorFlg = errorCheckUV(checkUV);\n  return step(0.1,errorFlg) * (-1.,-1.) + (1. - step(.1,errorFlg)) * returnUV;\n}\n\nvec2 uv2LeftUV(vec2 uv){\n  vec2 leftUV = vec2((uv.x - LEFT_START.x)/ TILE_WIDTH,(uv.y - LEFT_START.y)/ TILE_HEIGHT);\n  leftUV.y = leftUV.y / TEXTURE_ASPECT_RATIO;\n  return errorCheckUV(uv, leftUV);\n}\n\nvec2 normalizeLeftUV(vec2 leftUV){\n  vec2 normalizedLeftUV = leftUV;\n  normalizedLeftUV.y = normalizedLeftUV.y * TEXTURE_ASPECT_RATIO;\n  return errorCheckUV(leftUV, normalizedLeftUV);\n}\n\nvec2 leftUV2uv(vec2 leftUV){\n  vec2 uv = vec2((leftUV.x * TILE_WIDTH + LEFT_START.x) ,(leftUV.y * TILE_HEIGHT + LEFT_START.y) );\n  return errorCheckUV(uv, leftUV);\n}\n\nvec2 uv2RightUV(vec2 uv){\n  vec2 rightUV = vec2((uv.x - RIGHT_START.x)/ TILE_WIDTH,(uv.y - RIGHT_START.y)/ TILE_HEIGHT);\n  return errorCheckUV(uv, rightUV);\n}\n\nvec2 rightUV2uv(vec2 rightUV){\n  vec2 gainedRightUV = vec2(rightUV.x * TILE_WIDTH,rightUV.y * TILE_HEIGHT);\n  vec2 uv = vec2((gainedRightUV.x + RIGHT_START.x) ,(gainedRightUV.y + RIGHT_START.y) );\n  return errorCheckUV(rightUV, uv);\n}\n\nfloat lineMask(vec2 uv, vec2 linePoint1,vec2 linePoint2, float threshold){\n  // rotate line to y-axis\n  vec2 v1 = (linePoint1 - linePoint2);\n  float lineLength = sqrt(dot(v1,v1));\n  v1 = v1 / lineLength;\n  float theta = atan(v1.x, v1.y);\n  vec2[2] rotateMat = vec2[](\n    vec2(cos(theta), -sin(theta)),\n    vec2(sin(theta),  cos(theta))\n  );\n  vec2 rotatedUV = vec2((dot(rotateMat[0], (uv - linePoint2))),\n                        (dot(rotateMat[1], (uv - linePoint2))));\n  return float(\n               (abs(rotatedUV.x ) < threshold)&&\n               (rotatedUV.y       > -threshold)&&\n               (rotatedUV.y       < lineLength + threshold)\n               );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  // normalize position(x,y:.0~1.0)\n  vec2 uv = fragCoord.xy/ iResolution.x;\n  vec4 m = iMouse / iResolution.x;\n\n  // get local positions\n  vec2 leftUV = uv2LeftUV(uv);\n  vec2 normalizedLeftUV = normalizeLeftUV(leftUV);\n  vec2 leftMouseUV = uv2LeftUV(m.xy);\n  vec2 normalizedMouseLeftUV = normalizeLeftUV(leftMouseUV);\n  vec2 rightMouseUV = uv2RightUV(m.xy);\n  float leftMouseMask = errorCheckUV(leftMouseUV);\n  vec2 rightUV = uv2RightUV(uv);\n\n  // draw XY Chromaticity Diagram\n  vec3 rgbXY = drawXYChromaticityDiagram(rightUV);\n  \n  // draw left side(image(iChannel0))\n  vec3 rgbImage = texture(iChannel0, clamp(leftUV,0.,1.)).xyz;\n  float leftImageMask = float((leftUV.x >= .0)&&(leftUV.y >= .0)&&(leftUV.x <= 1.)&&(leftUV.y <= 1.));\n  vec3 rgb = max((leftImageMask * rgbImage) , ((1. - leftImageMask) * rgbXY));\n\n  // draw left mouse cursol\n  float validLeftMouseFlg = 1. - errorCheckUV(normalizedMouseLeftUV);\n  float nearLeftMouseFlg = validLeftMouseFlg * float((distance(m.xy, uv) > INSIDE_CIRCLE_RADIUS)&&\n                                                     (distance(m.xy, uv) < OUTSIDE_CIRCLE_RADIUS));\n  rgb = nearLeftMouseFlg * vec3(1., 1., .0) + (1. - nearLeftMouseFlg) * rgb;\n  //// draw right cursol\n  vec2 rightPos = (1. - leftMouseMask) * rightUV2uv(RGB2xyz(deGamma(texture(iChannel0, leftMouseUV).xyz)).xy) + \n                  leftMouseMask * (0.5, 0.5);\n  float nearRightFlg = validLeftMouseFlg * float((distance(rightPos,uv)>INSIDE_CIRCLE_RADIUS)&&\n                                  (distance(rightPos,uv)< OUTSIDE_CIRCLE_RADIUS));\n  rgb = nearRightFlg * vec3(1., 1., .0) + (1. - nearRightFlg) * rgb;\n\n  // draw right mouse cursol\n  float validRightMouseFlg = 1. - max(errorCheckUV(rightMouseUV), float(!isInsideHourseShoe(rightMouseUV)));\n  float nearRightMouseFlg = validRightMouseFlg * float((distance(rightUV2uv(rightMouseUV),uv)>INSIDE_CIRCLE_RADIUS)&&\n                                  (distance(rightUV2uv(rightMouseUV),uv)< OUTSIDE_CIRCLE_RADIUS));\n  rgb = nearRightMouseFlg * vec3(1.,1.,0.) + (1. - nearRightMouseFlg) * rgb;\n  //// Fill the left image area with yellow, the same color as the clicked position in the XY diagram on the right.\n  float nearColorFlg = leftImageMask * float(distance(RGB2xyz(deGamma(texture(iChannel0, leftUV).xyz)).xy,rightMouseUV) < NEAR_COLOR_DISTANCE);\n  rgb = nearColorFlg * vec3(1.,1.,0.) + (1. - nearColorFlg) * rgb;\n  \n\n  // draw grid\n  float nearGridFlg = (1. -errorCheckUV(rightUV)) * float(((abs(mod(rightUV.x, .1)) < .004)||(abs(mod(rightUV.y, .1)) < .004)));\n  rgb = nearGridFlg * vec3(1.,1.,1.) + (1. - nearGridFlg) * rgb;\n  \n  \n  // draw sRGB triangle\n  //// https://en.wikipedia.org/wiki/SRGB\n  vec2 sRGBxyR = vec2(.64, .33);\n  vec2 sRGBxyB = vec2(.33, .6);\n  vec2 sRGBxyG = vec2(.15, .06);\n  float nearTriangleFlg = lineMask(rightUV, sRGBxyR,sRGBxyB, .002)+\n                          lineMask(rightUV, sRGBxyB,sRGBxyG, .002)+\n                          lineMask(rightUV, sRGBxyG,sRGBxyR, .002);\n  rgb = nearTriangleFlg * vec3(.0, .0, .0) + (1. - nearTriangleFlg) * rgb;\n\n\n  fragColor=vec4(rgb, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}