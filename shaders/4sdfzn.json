{
    "Shader": {
        "info": {
            "date": "1524828180",
            "description": "A classic ray-tracer - use mouse to change viewpoint. It implements the classic recursive algorithm by using a stack. \nYou can increase 'n_aa' for antialiasing (by using raw supersampling)",
            "flags": 0,
            "hasliked": 0,
            "id": "4sdfzn",
            "likes": 16,
            "name": "Classic Ray-tracer",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "curena",
            "viewed": 655
        },
        "renderpass": [
            {
                "code": "// -----------------------------------------------------------------------------------\n//\n// Carlos Ure√±a, Apr,2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// -----------------------------------------------------------------------------------\n\n\n\n// --------------------------------------------------------------------\n// RAY-TRACER\n// --------------------------------------------------------------------\n\n// root of the number of samples for antialiasing\nconst int n_aa = 1 ;\n\n\n// struct datatypes\n\nstruct Camera\n{\n   vec3  obs;\n   vec3  o,x,y, z ;\n   float ratio_yx ;\n} ;\n\n// --------------------------------------------------------------------\n\nstruct Ray\n{\n   vec3 org, dir ;\n   vec2 fragC ;\n   int  obj_id ; // if the ray has origin in one object, the object's id,\n                 // -1 otherwise (primary rays)\n   bool in_glass ; // true if the start of the ray is in glass,\n                   // false otherwise (it is false for primary rays)\n} ;\n \n// --------------------------------------------------------------------\n\nstruct Material\n{\n    float kd,    // diffuse reflection coefficient (in [0,1])\n          kps ,  // perfect specular reflection coefficient (in [0,1])\n          kph,   // phong component\n          kt ;   // transmitted component (refracted)\n} ;\n    \n// --------------------------------------------------------------------\n\nstruct Sphere\n{\n   vec3  center ;\n   float radius ;\n   vec3  color ;\n   int   id ;  // object id\n} ;\n\n// --------------------------------------------------------------------\n\nstruct ShadingPoint\n{\n    vec3 pos,      // position \n         nor,      // normal vector\n         view ;    // vista\n    int  obj_id ;  // identifier of the object whose surface the point is in\n    bool in_glass; // true if the normal points towards a glass medium\n                   // false when it points towards air\n\n} ;\n\n// --------------------------------------------------------------------\n// scene\n\nconst int id_base_plane = 0,\n          id_sphere1    = 1,\n          id_sphere2    = 2,\n          id_sphere3    = 3,\n          id_sphere4    = 4,\n          \n          id_sphere5    = 5,\n          \n          id_sphere6    = 6,\n          \n          num_objects   = 6 ;\n    \nstruct Scene\n{\n   vec3   sun_dir ;\n   float  sun_ap_sin ;\n   Camera camera ;\n   Sphere sphere1,\n          sphere2,\n          sphere3, // outer transparent sphere (white one)\n          sphere4, // inner transparent sphere (white one)\n          sphere5, // outer transparent sphere (green one)\n          sphere6; // inner transparent sphere (green one)\n    \n   Material materials[num_objects] ;\n} ;\n    \n// scene\nScene scene ;\n\n// --------------------------------------------------------------------\n// rays stack\n\nstruct RayStackEntry\n{\n   Ray   ray ;       // ray to process\n   bool  processed ; // true if the color has been already computed,\n                     // and the child nodes have been pushed\n   int   iparent ;   // parent stack entry index, -1 for root node\n   vec3  color ;     // resulting color, only if 'processed == true'\n   float weight ;    // weight of this color in parent ray, if any\n} ;\n    \nconst int max_n_stack = 20 ;  // max number of items in the stack\n\nRayStackEntry  stack[max_n_stack] ;\n    \n// --------------------------------------------------------------------\n\nstruct InterStat  // ray-scene intersection status data\n{\n    Ray   ray ;    // ray being intersected\n    float t_max,   // max. value for 't' (-1.0 if it is +infinity)\n          t_hit ;  // actual smaller positive value found for 't' (-1.0 if none)\n   \tint   id_hit ; // 'id' of current object (-1 if none)\n} ;\n\n\n// --------------------------------------------------------------------\nconst float t_threshold = 0.001 ;\n\nbool update_is( inout InterStat is, float t, int id )\n{\n   if ( t < t_threshold )\n     return false;\n   if ( 0.0 < is.t_hit && is.t_hit < t )\n     return false;\n   if ( 0.0 < is.t_max && is.t_max < t )\n     return false;\n\n   is.t_hit  = t ;\n   is.id_hit = id ;\n   return true ;\n}\n\n// --------------------------------------------------------------------\n// ray-sphere intersection\n//\n// 'is.ray.dir' is assumed normalized\n// returns 'true' if there is an intersection, and, if there is a previous\n// intersection, this is nearest than previous\n\nbool sphere_intersect( in Sphere sphere, inout InterStat is  )\n{\n\tvec3\n      oc = is.ray.org - sphere.center;\n\tfloat\n      c  = dot(oc, oc) - (sphere.radius*sphere.radius),\n\t  b  = dot(is.ray.dir, oc) ,\n      di = b*b - c ;   // discriminant\n\n    if ( di < 0.0 ) // no sphere-ray intersection, 'is' is not written\n        return false ;\n\n    float\n      sqrt_di = sqrt(di),\n      t ;\n\n    t = -b - sqrt_di ;\n\tif ( t < t_threshold )\n      t = -b + sqrt_di ;\n\n    return update_is( is, t, sphere.id );\n}\n\n// --------------------------------------------------------------------\n// ray-plane intersection (infinite plane at y==0)\n// returns 'true' if there is an intersection and it is nearest than a \n// the previous one stored in 'is', if any.\n\nbool horizon_plane_intersection( in int plane_id, inout InterStat is )\n{\n    if ( abs(is.ray.dir.y) < 1e-5 )\n       return  false ;\n\n    float\n      t = -is.ray.org.y / is.ray.dir.y ;\n\n    return update_is( is, t, plane_id );\n}\n\n// --------------------------------------------------------------------\n// it just test if the ray is blocked by any object in the scene\n\nbool ray_blocked( in Ray ray )\n{\n   InterStat is ;\n\n   is.t_max  = -1.0 ;\n   is.t_hit  = -1.0 ;\n   is.id_hit = -1 ;\n   is.ray    = ray ;\n\n   if ( ray.obj_id != id_base_plane )\n   {\n      horizon_plane_intersection( id_base_plane, is );\n      if ( is.id_hit != -1 )\n        return true ;\n   }\n\n   if ( ray.obj_id != id_sphere1 )\n   {\n      sphere_intersect( scene.sphere1, is );\n      if ( is.id_hit != -1 )\n         return true ;\n   }\n\n   if ( ray.obj_id != id_sphere2 )\n   {\n   \t  sphere_intersect( scene.sphere2, is );\n      if ( is.id_hit != -1 )\n        return true ;\n   }\n    \n   if ( ray.obj_id != id_sphere3 )\n   {\n   \t  sphere_intersect( scene.sphere3, is );\n      if ( is.id_hit != -1 )\n        return true ;\n   }\n    \n   if ( ray.obj_id != id_sphere4 )\n   {\n   \t  sphere_intersect( scene.sphere4, is );\n      if ( is.id_hit != -1 )\n        return true ;\n   }\n    \n  \n\n   return false ;\n}\n\n// --------------------------------------------------------------------\n// returns true if the shading point is visible from 'scene.sun_dir', false otherwise\n\nbool sun_dir_visible( in ShadingPoint sp )\n{\n   Ray ray ;\n    \n   if ( dot( sp.nor, scene.sun_dir ) < 0.0 )\n      return false ;\n\n   ray.org    = sp.pos ;\n   ray.dir    = scene.sun_dir ;\n   ray.obj_id = sp.obj_id ;\n\n   return ! ray_blocked( ray );\n}\n// --------------------------------------------------------------------\n\nvec3 phong_component( in vec3 nor, in vec3 view, in vec3 light )\n{\n    float vh = dot( nor, normalize( view+light ) ),\n          b  = pow( vh, 8.0 );\n    \n    return vec3( b, b, b );\n}\n\n// --------------------------------------------------------------------\n\nvec3 sphere_shader( in Sphere sphere, in ShadingPoint sp )\n{\n    vec3 res = vec3(0.0,0.0,0.0);\n    \n    if ( sun_dir_visible( sp ) )\n    {\n      float ldn = dot( sp.nor, scene.sun_dir ),\n            kd  = scene.materials[sp.obj_id].kd ,\n            kph = scene.materials[sp.obj_id].kph ;\n        \n      res += ldn*kd*sphere.color ;\n        \n      if ( 0.0 < kph )\n         res += kph*phong_component( sp.nor, sp.view, scene.sun_dir ); \n    }\n\n    return max(res, 0.1*sphere.color ) ;\n}\n\n// --------------------------------------------------------------------\n\nvec3 sphere_color( in Sphere sphere, in InterStat is,  out ShadingPoint sp )\n{\n    sp.pos    = is.ray.org + is.t_hit*is.ray.dir ;\n    sp.view   = -is.ray.dir ;\n    \n    sp.nor    = normalize( sp.pos - sphere.center );\n    sp.obj_id = sphere.id ;\n    sp.in_glass = is.ray.in_glass ;\n\n    return sphere_shader( sphere, sp );\n}\n\n// --------------------------------------------------------------------\n\nvec3 horizon_plane_shader( in ShadingPoint sp )\n{\n    \n    float vis = sun_dir_visible( sp ) ?  1.0 : 0.5 ,\n          kd  = scene.materials[sp.obj_id].kd,\n          kph = scene.materials[sp.obj_id].kph ;\n    \n//#define BASE_PLANE_RELIEF\n    \n#ifdef BASE_PLANE_RELIEF \n    \n    float delta = 0.001, k = 2.0 ;\n    vec2 p00 = sp.pos.xz ;\n    vec2 p10 = p00 + vec2( delta, 0.0 ),\n         p01 = p10 + vec2( 0.0, delta );\n    \n    vec4 col = p6mm_pattern( p00 ),\n         col01 = p6mm_pattern( p01 ),\n         col10 = p6mm_pattern( p10 );\n    \n    float v00 = col.r + col.g + col.b ,\n          v01 = col01.r + col01.g + col01.b ,\n          v10 = col10.r + col10.g + col10.b ;\n    \n    vec3 t1 = normalize( vec3( delta, k*(v10-v00), 0.0 ) ),\n         t2 = normalize( vec3( 0.0,   k*(v01-v00), delta ) );\n    \n    vec3 nor = normalize( cross( t1, t2 ) );\n    if ( nor.y < 0.0 )\n        nor = -1.0*nor ;\n#else\n    vec4 col = p6mm_pattern( sp.pos.xz );\n    vec3 nor = vec3( 0.0, 1.0, 0.0 );\n#endif\n    vec3 res_color = vis*kd*col.rgb ;\n    \n    if ( vis == 1.0 && 0.0 < kph)\n       res_color += kph*phong_component(nor,sp.view,scene.sun_dir) ; \n    \n    return res_color ;\n}\n\n// --------------------------------------------------------------------\n\nvec3 horizon_plane_color( in InterStat is, out ShadingPoint sp )\n{\n\n    sp.pos    = is.ray.org + is.t_hit*is.ray.dir ;\n    sp.view   = -is.ray.dir ;\n    sp.obj_id = is.id_hit ;\n    sp.nor    = vec3( 0.0, 1.0, 0.0 );\n    sp.in_glass = false ;\n\n    return horizon_plane_shader( sp );\n}\n\n// --------------------------------------------------------------------\n// compute primary ray origin and direction, from the fragment coord and\n// camera parameters\n\nCamera compute_camera( in vec3 cam_look_at )\n{\n\n    Camera cam ;\n    vec3 cam_vup = vec3( 0.0, 1.0, 0.0 );\n    float dist = 2.0 ;\n    vec2 dxy = iMouse.xy - abs(iMouse.zw) ; // sign of .zw tells if a click happened or not...\n\n    float fx   = 0.011,\n          fy   = 0.01 ,\n          lat0 = 0.5,\n          lon0 = 0.5,\n          lon  = lon0 + fx*dxy.x,\n          lat  = max( 0.0, min( 1.5, lat0 - fy*dxy.y )),\n          cos_lat = cos(lat);\n\n    cam.z = vec3( cos(lon)*cos_lat , sin(lat), sin(lon)*cos_lat );\n\n    cam.obs = cam_look_at + dist*cam.z ;\n    cam.o   = cam.obs - 1.5*cam.z ;\n    cam.x   = normalize( cross( cam_vup, cam.z ) );\n    cam.y   = normalize( cross( cam.x, cam.z ) ); // do we really need to normalize here ?\n\n    cam.ratio_yx = iResolution.y/iResolution.x ;\n\n    return cam ;\n}\n\n\n// --------------------------------------------------------------------\n// compute primary ray origin and direction, from the fragment coord and\n// camera parameters\n\nRay primary_ray( in vec2 sample_coords, in Camera cam )\n{\n    Ray pray ;\n    vec2  uv  = sample_coords/iResolution.xy;     // uv in [0,1]^2\n    float x   = 2.0*uv[0] - 1.0 ,                 // x in [-1,+1]\n          y   = (1.0 - 2.0*uv[1] )*cam.ratio_yx ; // y in [-ratio_yx,+ratio_yx]\n    vec3  p   = cam.o + x*cam.x + y*cam.y ; // p is the point in the view-plane\n\n    pray.dir    = normalize( p - cam.obs ),\n    pray.org    = cam.obs ;\n    pray.fragC  = sample_coords ;\n    pray.obj_id = -1 ;\n    pray.in_glass = false ; // we assume observer is not 'in glass'\n\n    return pray ;\n}\n\n// --------------------------------------------------------------------\n\nvec3 background_color( in Ray ray )\n{\n    float b = max( 0.0, dot( ray.dir, scene.sun_dir ) );\n    if ( 1.0-scene.sun_ap_sin < b )\n        return vec3( 1.0,1.0,1.0 );\n    //else\n    //    return max(0.5,pow(b,5.0))*vec3( 0.0, 0.1, 0.2 );\n    \n    vec3 d = vec3( ray.dir.x, ray.dir.y/2.0, ray.dir.z ),\n         da = abs( d );\n    \n    vec2 tcoords ;\n    if ( da.x <= da.y && da.z <= da.y ) // max is Y (use x,z)\n        tcoords = vec2( 0.5, 0.5) + 0.5*vec2( d.x, d.z )/da.y;\n    else if ( da.z <= da.x && da.y <= da.x ) // max is X (use z,y)\n        tcoords = vec2( 0.5, 0.0 ) + vec2( 0.5*d.z, d.y )/da.x;\n    else // max is Z (use x,y)\n        tcoords = vec2( 0.5, 0.0 ) + vec2( 0.5*d.x, d.y )/da.z;\n    \n    const float margin = 0.001 ;\n    \n    if ( tcoords.x < margin || 1.0-margin < tcoords.x   )\n        return vec3( 0.0, 0.0, 0.0 );\n        \n    if ( tcoords.y < margin || 1.0-margin < tcoords.y )\n        return vec3( 0.0, 0.0, 0.0 );\n    \n   \tvec2 tc2 = (tcoords-vec2(margin,margin))/(1.0-2.0*margin) ;\n    const float nrep = 2.0 ;\n        \n    vec4 col = texture( iChannel0, fract( nrep*tc2 ));\n    return 1.0*pow( col.rgb, 2.0*vec3(1.0, 1.0, 1.0) ) ;\n    \n}\n// --------------------------------------------------------------------\n\nInterStat scene_intersect( in Ray ray )\n{\n   InterStat is ;\n\n   is.t_max  = -1.0 ;\n   is.t_hit  = -1.0 ;\n   is.id_hit = -1 ;\n   is.ray    = ray ;\n\n   if ( ray.obj_id != id_sphere1 )\n   \t sphere_intersect( scene.sphere1, is );\n   \n   if ( ray.obj_id != id_sphere2 )\n   \t sphere_intersect( scene.sphere2, is );\n    \n   //if ( ray.obj_id != id_sphere3 )\n   \t sphere_intersect( scene.sphere3, is );\n    \n   //if ( ray.obj_id != id_sphere4 )\n   \t sphere_intersect( scene.sphere4, is );\n      \n   if ( ray.obj_id != id_base_plane )\n     horizon_plane_intersection( id_base_plane, is ); \n   \n   return is ;\n}\n\n// --------------------------------------------------------------------\n\nvec3 scene_color( in InterStat is, out ShadingPoint sp )\n{\n    if ( is.id_hit == id_base_plane )\n       return horizon_plane_color( is, sp );\n    \n    if ( is.id_hit == id_sphere1 )\n      return sphere_color( scene.sphere1, is, sp  );\n     \n    if ( is.id_hit == id_sphere2 )\n       return sphere_color( scene.sphere2, is, sp  );\n    \n    if ( is.id_hit == id_sphere3 )\n       return sphere_color( scene.sphere3, is, sp  );\n    \n    if ( is.id_hit == id_sphere4 )\n       return sphere_color( scene.sphere4, is, sp  );\n      \n    return background_color( is.ray ) ;\n}\n// --------------------------------------------------------------------\n// computes the reflected ray, the classical formula for the direction \n// is here:\n// https://en.wikipedia.org/wiki/Specular_reflection#Vector_formulation\n\nRay reflected_ray( in ShadingPoint sp )\n{\n   Ray rr ; \n    \n   rr.org      = sp.pos ;\n   rr.dir      = 2.0*dot(sp.view,sp.nor)*sp.nor - sp.view ;\n   rr.obj_id   = sp.obj_id ;\n   rr.in_glass = sp.in_glass ;\n    \n   return rr ;\n}\n// --------------------------------------------------------------------\n// computed the refracted ray\n// the formula for the refracted ray direction can be seen here:\n// https://en.wikipedia.org/wiki/Snell%27s_law#Vector_form\n\nRay get_refracted_ray( in ShadingPoint sp )\n{\n   const float glass_ri = 1.3 , // refractive index of glass \n               glass_ri_inv = 1.0/glass_ri ;\n    \n   vec3 l = -sp.view , // wikipedia formulation uses l \"from light to shading point\"\n        no = sp.nor ;\n    \n   // r == ratio of refraction indexes\n   float r = sp.in_glass ? glass_ri : glass_ri_inv ;\n    \n    // c == cosine of incidence angle\n   float c = -dot( no, l );\n   \n   // if we hit the point in the 'back' side (w.r.t the normal), flip normal.\n   if ( c < 0.0 ) \n   {  \n      c = -c ;\n      no = -no ;\n   }\n   \n   Ray rr ; // resulting ray \n   float radicand = 1.0-r*r*(1.0-c*c);\n    \n   if ( radicand < 0.0 ) \n   {\n      // total internal reflection \n      rr.org      = sp.pos ;\n      rr.dir      = 2.0*c*no + l ; // reflected ray formula, with l = -sp.view\n      rr.obj_id   = sp.obj_id ;\n      rr.in_glass = sp.in_glass ; // no medium switch \n   }\n   else\n   {\n      // normal refraction: build rr \n      rr.org      = sp.pos ;\n      rr.dir      = r*l + (r*c-sqrt(radicand))*no ;\n      rr.obj_id   = sp.obj_id ;\n      rr.in_glass = ! sp.in_glass ; // medium switch\n   } \n   return rr ;\n}\n\n// --------------------------------------------------------------------\n// returns the color (radiance) incident on ray origin, coming \n// from ray direction\n\nvec3 ray_color( in Ray ray )\n{\n   int  n = 0;     // number of entries already in the stack \n   vec3 res_color; // resulting color\n\n   // push the first ray\n   stack[n].ray       = ray ;\n   stack[n].processed = false ;\n   stack[n].iparent   = -1 ;      // -1 means this is first node in stack (has no parent)\n   stack[n].color     = vec3( 0.0, 0.0, 0.0 );\n   stack[n].weight    = 1.0 ;\n   n++ ;\n    \n   // loop while the stack is not empty\n    \n   while( n > 0 )\n   {\n     int itop = n-1 ;\n\n     // if node on top is already processed, pop it\n     if ( stack[itop].processed ) \n     {\n         vec3 col     = stack[itop].weight*stack[itop].color ;\n         int  iparent = stack[itop].iparent ;\n          \n         if ( iparent == -1 ) \n             res_color = col ; \n         else  \n         \tstack[iparent].color += col ;\n         \t\n         n-- ;  // pop this node\n         continue ;\n     }\n     \n     // Process an unprocessed node:\n     \n     // (1) intersect ray and get 'is' object\n       \n     ShadingPoint sp ;\n     InterStat    is     = scene_intersect( stack[itop].ray ); \n     bool         inters = is.id_hit != -1 ;\n     \n       \n     // (2) compute and update node color (initializes 'sp')\n     stack[itop].color = scene_color( is, sp );    \n      \n     // (3) push child rays if neccesary   \n     if ( inters && (n < max_n_stack) )\n     {  \n        float kps = scene.materials[is.id_hit].kps ;\n         \n        float vn = dot(sp.nor,sp.view);\n            \n        if ( 0.0 < kps && 0.0 < vn && ! sp.in_glass ) // if we should compute reflected ray...\n        {\n           // computed reflected ray\n           Ray refl_ray = reflected_ray( sp ); \n             \n           // push reflected ray entry      \n           stack[n].ray       = refl_ray ;\n           stack[n].processed = false ;\n           stack[n].iparent   = itop ; \n           stack[n].color     = vec3( 0.0, 0.0, 0.0 );\n           stack[n].weight    = kps ;\n           n++ ;\n        }\n         \n        float kt = scene.materials[is.id_hit].kt ;\n         \n        if ( (n < max_n_stack) && 0.0 < kt )\n        {\n           // compute refracted ray\n           Ray refrac_ray = get_refracted_ray( sp );\n              \n           // push refracted ray entry      \n           stack[n].ray       = refrac_ray ;\n           stack[n].processed = false ;\n           stack[n].iparent   = itop ; \n           stack[n].color     = vec3( 0.0, 0.0, 0.0 );\n           stack[n].weight    = kt ;\n           n++ ;  \n        }\n     }\n     // (4) mark the node as processed\n     stack[itop].processed = true ;\n       \n   } // end while \n\n   return res_color; \n}\n\n// --------------------------------------------------------------------\n// computed anti-aliased pixel color\n//\n// fcoords.x  goes from 0.5 to iResolution.x-0.5 (same for .y)\n\nvec4 AA_pixel_color( in vec2 pixel_coords )\n{\n    vec3 sum = vec3( 0.0, 0.0, 0.0 );\n    const float n_aa_f = float(n_aa);\n\n    for( int i = 0 ; i < n_aa ; i++ )\n    {\n       float desplx = (float(i)+0.5)/n_aa_f -0.5 ;\n\n       for( int j = 0 ; j < n_aa ; j++ )\n       {\n          float desply = (float(j)+0.5)/n_aa_f -0.5;\n          float fac = 1.0000 ;\n          vec2  despl         = fac*vec2( desplx, desply  ), // why we must multiply by something other than 1 ?\n                sample_coords = pixel_coords + despl ;\n          Ray   ray           = primary_ray( sample_coords, scene.camera ) ;\n          vec3  col           = ray_color( ray );\n\n          sum = sum + col ;\n       }\n    }\n\n    return vec4( sum/(n_aa_f*n_aa_f) ,1.0 );\n}\n\n// --------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n\n    // scene parameters\n    \n    vec3 cam_look_at = vec3( 0.0, 0.15, 0.5 ) \n                          + cos( iTime )*vec3(1.0,0.0,0.0)\n                          + sin( iTime )*vec3(0.0,0.1,0.3) ;\n\n    scene.camera  = compute_camera( cam_look_at );\n    scene.sun_dir = normalize( vec3( 0.2, 1.2, 1.0 ) );\n    scene.sun_ap_sin = 0.003 ;\n    \n    // base plane \n    \n    scene.materials[id_base_plane].kd  = 0.6;\n    scene.materials[id_base_plane].kps = 0.0;\n    scene.materials[id_base_plane].kph = 0.7;\n    scene.materials[id_base_plane].kt  = 0.0;\n    \n    // sphere 1 \n\n    scene.sphere1.id      = id_sphere1 ;\n    scene.sphere1.center  = vec3( 0.0, 0.5, 0.0 );\n    scene.sphere1.radius  = 0.5 ;\n    scene.sphere1.color   = vec3(0.5,0.5,1.0);\n    \n    scene.materials[id_sphere1].kd  = 0.6;\n    scene.materials[id_sphere1].kph = 0.6;\n    scene.materials[id_sphere1].kps = 0.4;\n    scene.materials[id_sphere1].kt  = 0.0;\n    \n    \n    // sphere 2 \n\n    scene.sphere2.id      = id_sphere2 ;\n    scene.sphere2.center  = vec3( 0.0, 0.4, 0.9 );\n    scene.sphere2.radius  = 0.4 ;\n    scene.sphere2.color   = vec3( 1.0, 0.2, 0.2 );\n\n    scene.materials[id_sphere2].kd  = 0.3;\n    scene.materials[id_sphere2].kph = 0.3;\n    scene.materials[id_sphere2].kps = 0.4;\n    scene.materials[id_sphere2].kt  = 0.0;\n    \n    // sphere 3 (outer sphere in the transparent ball)\n    \n    float tr_sph_rad    = 0.35 ;\n    vec3  tr_sph_center = vec3( 1.0, tr_sph_rad, 0.6 ) ;\n\n    scene.sphere3.id      = id_sphere3 ;\n    scene.sphere3.center  = tr_sph_center;\n    scene.sphere3.radius  = tr_sph_rad ;\n    scene.sphere3.color   = vec3( 1.0, 1.0, 1.0 );\n\n    scene.materials[id_sphere3].kd  = 0.0;\n    scene.materials[id_sphere3].kph = 0.0;\n    scene.materials[id_sphere3].kps = 0.3;\n    scene.materials[id_sphere3].kt  = 0.7;\n    \n    // sphere 4 (inner sphere in the transparent ball)\n\n    scene.sphere4.id      = id_sphere4 ;\n    scene.sphere4.center  = tr_sph_center;\n    scene.sphere4.radius  = 0.9*tr_sph_rad ;\n    scene.sphere4.color   = vec3( 1.0, 1.0, 1.0 );\n\n    scene.materials[id_sphere4].kd  = 0.0;\n    scene.materials[id_sphere4].kph = 0.0;\n    scene.materials[id_sphere4].kps = 0.0;\n    scene.materials[id_sphere4].kt  = 1.0;\n    \n    /**\n    // sphere 5 \n\n    scene.sphere5.id      = id_sphere5 ;\n    scene.sphere5.center  = vec3( 0.9, 0.25, 0.0 );\n    scene.sphere5.radius  = 0.25 ;\n    scene.sphere5.color   = vec3( 1.0, 1.0, 1.0 );\n\n    scene.materials[id_sphere5].kd  = 0.0;\n    scene.materials[id_sphere5].kph = 0.0;\n    scene.materials[id_sphere5].kps = 0.2;\n    scene.materials[id_sphere5].kt  = 0.8;\n    \n    // sphere 6 \n\n    scene.sphere6.id      = id_sphere6 ;\n    scene.sphere6.center  = vec3( 0.9, 0.25, 0.0 );\n    scene.sphere6.radius  = 0.22 ;\n    scene.sphere6.color   = vec3( 1.0, 1.0, 1.0 );\n\n    scene.materials[id_sphere6].kd  = 0.0;\n    scene.materials[id_sphere6].kph = 0.0;\n    scene.materials[id_sphere6].kps = 0.0;\n    scene.materials[id_sphere6].kt  = 1.0;\n    **/\n    \n    // ----\n    \n    vec2 pixel_coords = fragCoord.xy ;\n\n    fragColor = AA_pixel_color( pixel_coords ) ;\n               \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// -----------------------------------------------------------------------------------\n//\n// Carlos Ure√±a, Apr,2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// -----------------------------------------------------------------------------------\n\n// ----------------------------------------------------------------\n// ISLAMIC STAR PATTERN related functions\n\n\n// parameters and pre-calculated constants\nconst float \n    sqr2       = 1.41421356237, // square root of 2\n    sqr3       = 1.73205080756, // square root of 3.0\n    sqr2_inv   = 1.0/sqr2 ,\n    sqr3_inv   = 1.0/sqr3 ,\n    cos30      = 0.86602540378, // cos(30 degrees)\n    sin30      = 0.50000000000, // sin(30 degrees)\n    l          = 5.5,          // length of triangle in NDC (mind --> 1.0)\n    l_inv      = 1.0/l ,       // length inverse\n    line_w     = 0.03,         // line width for basic symmetry lines render\n    sw         = 0.020 ;       // stripes half width for islamic star pattern\n\nconst vec2  \n    u        = 1.0*vec2( 1.0, 0.0  ) ,          // grid basis: U vector\n    v        = 0.5*vec2( 1.0, sqr3 ) ,          // grid basis: V vector\n    u_dual   = 1.0*vec2( 1.0, -sqr3_inv ) ,     // dual grid basis: U vector\n    v_dual   = 2.0*vec2( 0.0,  sqr3_inv ) ,     // dual grid basis: V vector\n    tri_cen  = vec2( 0.5, 0.5*sqr3_inv ) ;      // triangle center\n\n    \n// -----------------------------------------------------------------------------------\n// point orbit transformation parameters\nint \n    nMirrorOdd = 0 , \n    nMirror    = 0 ,\n\tnGridX     = 0 , \n    nGridY     = 0 ;\n\n\n// -------------------------------------------------------------------------------\n// mirror reflection of 'p' around and axis through 'v1' and 'v2'\n// (only for points to right of the line from v1 to v2)\n//\nvec2 Mirror( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           n = normalize(vec2( s.y, -s.x )) ;\n    float  d = dot(p-v1,n) ;\n    \n    if ( 0.0 <= d )\n    {\n       nMirrorOdd = 1-nMirrorOdd ;\n       nMirror = nMirror+1 ;\n       return p-2.0*d*n ;\n    }\n    else\n       return p ;\n}\n// -------------------------------------------------------------------\n// Signed perpendicular distance from 'p' to line through 'v1' and 'v2'\n\nfloat SignedDistance( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           n = normalize(vec2( s.y, -s.x )) ;\n    return dot(p-v1,n) ;\n}\n// -------------------------------------------------------------------\n// un-normalized signed distance to line\n\nfloat UnSignedDistance( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           un = vec2( s.y, -s.x ) ;\n    return dot(p-v1,un) ;\n}\n// -------------------------------------------------------------------\n// Signed perpendicular distance from 'p' to polyline from 'v1' \n// to 'v2' then to 'v3'\n\nfloat DoubleSignedDistance( vec2 p, vec2 v1, vec2 v2, vec2 v3 )\n{\n \t\n    vec2  dir1 = v2 + normalize(v1-v2),\n          dir3 = v2 + normalize(v3-v2);\n        \n    vec2  vm = 0.5*(dir1+dir3) ;\n    \n    float dm = UnSignedDistance( p, v2, vm ) ;\n    \n    if ( dm >= 0.0 )\n   \t\treturn SignedDistance( p, v1, v2 ) ;\n   \telse\n        return SignedDistance( p, v2, v3 ) ; \n}\n// -------------------------------------------------------------------------------\n// Takes 'p0' to the group's fundamental region, returns its coordinates in that region\n\nvec2 p6mm_ToFundamental( vec2 p0 ) \n{\n    nMirrorOdd = 0 ;\n    nMirror    = 0 ;\n    \n    // p1 = fragment coords. in the grid reference frame\n    \n    vec2 p1 = vec2( dot(p0,u_dual), dot(p0,v_dual) );\n    \n    // p2 = fragment coords in the translated grid reference frame \n    \n    vec2 p2 = vec2( fract(p1.x), fract(p1.y) ) ;\n    \n    nGridX = int(p1.x-p2.x) ; // largest integer g.e. to p1.x\n    nGridY = int(p1.y-p2.y) ; // largest integer g.e. to p2.x\n    \n    // p3 = barycentric coords in the translated triangle\n    // (mirror, using line x+y-1=0 as axis, when point is right and above axis)\n    \n    vec2 p3 = Mirror( p2, vec2(1.0,0.0), vec2(0.0,1.0) );\n    \n    // p4 = p3, but expressed back in cartesian coordinates\n    \n    vec2 p4 = p3.x*u + p3.y*v ;\n    \n    // p7 = mirror around the three lines through the barycenter, perp. to edges.\n    \n    vec2 p5 = Mirror( p4, vec2(0.5,0.0), tri_cen );\n    vec2 p6 = Mirror( p5, vec2(1.0,0.0), tri_cen );\n    vec2 p7 = Mirror( p6, tri_cen, vec2(0.0,0.0) );\n  \n    return p7 ;\n}\n\n// --------------------------------------------------------------------\n// A possible distance function\n\nfloat DistanceFunc( float d )\n{\n   return 1.0-smoothstep( line_w*0.5, line_w*1.5, d );   \n}\n\n// -------------------------------------------------------------------------------\n// Point color for basic symmetry lines in (r,g,b)\n\nvec4 p6mm_SimmetryLines( vec2 p_ndc )\n{\n\n    vec2 pf = p6mm_ToFundamental( p_ndc );\n    \n    float d1 = abs(pf.y),\n          d2 = abs(pf.x-0.5),\n          d3 = abs( SignedDistance( pf, tri_cen, vec2(0.0,0.0) ) );\n     \n    vec4 res = vec4( 0.0, 0.0, 0.0, 1.0 ) ;\n        \n    res.r = DistanceFunc(d2);\n    res.g = DistanceFunc(d1);\n    res.b = DistanceFunc(d3);\n    \n    return res ;    \n}\n\n// ---------------------------------------------------------------------\n// Stripe half width for star pattern\n\nvec4 Stripe( float d )\n{\n   if ( d > sw*0.85 )\n     return vec4( 0.0,0.0,0.0,1.0 );\n   else\n     return vec4(1.0,1.0,1.0,1.0)  ;\n}\n\n// ---------------------------------------------------------------------\n// Color for islamic star pattern\n\nvec4 p6mm_pattern( vec2 p )\n{\n    vec2 pf = p6mm_ToFundamental( p );\n    \n    //return p6mm_SimmetryLines( p ) ;\n    vec2 c  = tri_cen ;\n    \n    // constants defining the stripes \n    float \n        f   = 0.30 ,\n        fs1 = 0.14 ,\n        s1  = fs1*c.x,\n        s2  = 0.5*s1 ;\n        \n    // stripes vertexes\n    vec2 \n        // upper strip\n        u1 = vec2( f*c.x, 0.0 ) ,\n        u2 = vec2( c.x, (1.0-f)*c.y ),\n        \n        // lower strip\n        l1 = vec2( c.x, s1+s2 ),\n        l2 = vec2( c.x-s2, s1 ),\n        l3 = vec2( sqr3*s1, s1 ),\n        \n        // right strip\n        r1 = vec2( c.x-s1, (1.0-fs1)*c.y ),\n        r2 = vec2( c.x-s1, s2 ) ,\n        r3 = vec2( c.x-s1-s2, 0.0 ),\n        \n    \t// origin star strip\n        mm = vec2( s1*(sqr3-1.0/3.0), s1*(1.0-sqr3_inv) );\n                        \n    // signed and unsigned distances to stripes:\n    \n    float\n        d1s = SignedDistance( pf, u1, u2 ) ,\n        d2s = DoubleSignedDistance( pf, l1, l2, l3 ) ,\n        d3s = DoubleSignedDistance( pf, r1, r2, r3 ) ,\n        d4s = DoubleSignedDistance( pf, u1, mm, l3 ) ,\n        d1  = abs( d1s ),\n        d2  = abs( d2s ),\n        d3  = abs( d3s ),\n        d4  = abs( d4s );\n    \n   \n    // stripes inclusion\n    bool in1, in2, in3, in4 ;\n    \n    if ( nMirrorOdd == 0 )\n    {\n        in1 = (d1 < sw) && ! (d2 < sw) && ! (d4 < sw);\n        in2 = (d2 < sw) && ! (d3 < sw);\n        in3 = (d3 < sw) && ! (d1 < sw);\n        \n        in4 = (d4 < sw) && ! (d2 < sw);\n    }\n    else\n    {\n        in1 = (d1 < sw) && ! (d3 < sw) ;\n        in2 = (d2 < sw) && ! (d1 < sw) && ! (d4 < sw);;\n        in3 = (d3 < sw) && ! (d2 < sw);\n        \n        in4 = (d4 < sw) && ! (d1 < sw);\n    } \n    \n    vec4 col ;\n    \n    // compute final color\n    \n    if ( in1 )      \n        col = Stripe( d1 ) ;\n    else if ( in2 ) \n        col = Stripe( d2 ) ;\n    else if ( in3 ) \n        col = Stripe( d3 ) ; \n    else if ( in4 )\n        col = Stripe( d4 ) ;   \n    else if ( d2s < 0.0 && d3s < 0.0 )\n        col = vec4( 0.0, 0.4, 0.0, 1.0 ) ;\n    else if ( d1s < 0.0 && d2s < 0.0 || d1s <0.0 && d3s < 0.0 )\n        col = vec4( 0.1, 0.1, 0.1, 1.0 );\n    else if ( d1s < 0.0 || d2s < 0.0 )\n        col = vec4( 0.0, 0.4, 0.9, 1.0 );   \n    else    \n        col = vec4( 0.6, 0.0, 0.0, 1.0 ) ; \n       \n    return col ;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}