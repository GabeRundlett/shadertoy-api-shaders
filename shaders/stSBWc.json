{
    "Shader": {
        "info": {
            "date": "1652815392",
            "description": "A filter with arbitrarily steep cut-off that cuts the frequency content in half.",
            "flags": 32,
            "hasliked": 0,
            "id": "stSBWc",
            "likes": 4,
            "name": "Band-Split Filter",
            "published": 3,
            "tags": [
                "filtering",
                "kernel"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 240
        },
        "renderpass": [
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    A filter with arbitrarily steep cut-off that cuts the frequency content in half.\n    \n    This actually is just the smooth square wave from here https://www.shadertoy.com/view/tlyyzd used as a filter response.\n  \n    Relevant code is in Buffer A.\n*/\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    float b = ceil((iResolution.y - SIZE)*0.5);\n    \n    if(uv0.y < b || uv0.y > iResolution.y-b) { outCol = vec4(0.11); return; }\n    \n    uv0.y -= b;\n    \n    vec2 tc = uv0/iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    \n    if (tc.x > 0.5)\n    {\n        // fft\n        vec2 dft = texelFetch(iChannel1, ivec2(uv0-0.5-vec2(SIZE,0.0)), 0).xy;\n        \n        float amp = length(dft); \n         //amp += length(texelFetch(iChannel1, ivec2(uv0-0.5-vec2(SIZE*1.5,0.0)), 0).xy);\n         //amp += length(texelFetch(iChannel1, ivec2(uv0-0.5-vec2(SIZE*.5,0.0)), 0).xy); amp *= 0.5;\n        \n        float s = 0.005;\n        amp *= s;\n        \n        col = vec3(amp);\n\n        if(amp <= exp2(-13.0)) col = vec3(1.0, 0.0, 0.0)*0.25;\n        if(amp <= exp2(-16.0)) col = vec3(1.0, 0.5, 0.0)*0.25;\n        \n        col = clamp01(col);\n    }\t\n    else\n    {\n        // input\n        float n = texelFetch(iChannel0, ivec2(uv0-0.5), 0).x;\n        col = vec3((n));\n        //if(n < 0.0) col *= vec3(1.0, 0., 0.0);\n        \n        col = pow(clamp01(col), vec3(1.0/2.2));\n    }\n    \n\n    outCol = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n  #define SIZE (floor(iResolution.y/2.25)*2.)\n\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvec2 cossin(float x) { return vec2(cos(x), sin(x)); }\n\nvec2 cmul(vec2 c0, vec2 c1)\n{\n\treturn vec2(c0.x * c1.x - c0.y * c1.y, \n\t\t        c0.y * c1.x + c0.x * c1.y);\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//==============================================================================================================================================//\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n// https://probablydance.com/2018/06/16/fibonacci-hashing-the-optimization-that-the-world-forgot-or-a-better-alternative-to-integer-modulo/\nconst float rPhif1 =      0.6180340;\nconst vec2  rPhif2 = vec2(0.7548777, 0.5698403);\nconst vec3  rPhif3 = vec3(0.8191725, 0.6710436, 0.5497005);\nconst vec4  rPhif4 = vec4(0.8566749, 0.7338919, 0.6287067, 0.5385973);\n\nconst uint  rPhi1 =       2654435769u;\nconst uvec2 rPhi2 = uvec2(3242174889u, 2447445413u);\nconst uvec3 rPhi3 = uvec3(3518319153u, 2882110345u, 2360945575u);\nconst uvec4 rPhi4 = uvec4(3679390609u, 3152041523u, 2700274805u, 2313257605u);\n\n// low bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\n// minimal bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c)\n{ \n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u;\n}\n\n// Pierre L'Ecuyer - \"TABLES OF LINEAR CONGRUENTIAL GENERATORS OF DIFFERENT SIZES AND GOOD LATTICE STRUCTURE\"\n// https://www.ams.org/journals/mcom/1999-68-225/S0025-5718-99-00996-5/S0025-5718-99-00996-5.pdf\nconst uint lcgM = 2891336453u;// ideal for 32 bits with odd c\n\nuint lcg(uint h)\n{\n    return h * lcgM + 0x5C995C6Du;\n}\n\n#define SEED uvec4(0x5C995C6Du, 0x6A3C6A57u, 0xC65536CBu, 0x3563995Fu)\n\n// Melissa E. Oâ€™Neill - \"PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation\"\n// https://www.cs.hmc.edu/tr/hmc-cs-2014-0905.pdf\n\n// Mark Jarzynski & Marc Olano - \"Hash Functions for GPU Rendering\"\n// http://jcgt.org/published/0009/03/02/ | https://www.shadertoy.com/view/XlGcRh\nuvec3 pcg3Mix(uvec3 h)\n{\n    h.x += h.y * h.z; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    \n    return h;\n}\n\nuvec3 pcg3Permute(uvec3 h)\n{\n    h = pcg3Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg3Mix(h);\n}\n\nuvec3 pcg3(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg3Permute(uvec3(2447445413u, state, 3242174889u));\n}\n\nuvec3 pcg3(uvec3 h, uint seed)\n{\n    uvec3 c = (seed << 1u) ^ SEED.xyz;\n    \n    return pcg3Permute(h * lcgM + c);\n}\n\nuvec4 pcg4Mix(uvec4 h)\n{\n    h.x += h.y * h.w; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    h.w += h.y * h.z;\n    \n    return h;\n}\n\nuvec4 pcg4Permute(uvec4 h)\n{\n    h = pcg4Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg4Mix(h);\n}\n\nuvec4 pcg4(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg4Permute(uvec4(2882110345u, state, 3518319153u, 2360945575u));\n}\n\nuvec4 pcg4(uvec4 h, uint seed)\n{\n    uvec4 c = (seed << 1u) ^ SEED;\n\n    return pcg4Permute(h * lcgM + c);\n}\n\nuint pcg(inout uint state)\n{\n    state = lcg(state);\n    \n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    \n    return (word >> 22u) ^ word;\n}\n\nuint pcg(uint h, uint seed)\n{\n    uint c = (seed << 1u) ^ SEED.x;\n\n    h = h * lcgM + c;\n    \n    h = ((h >> ((h >> 28u) + 4u)) ^ h) * 277803737u;\n    \n    return (h >> 22u) ^ h;\n}\n\n#undef SEED\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//==============================================================================================================================================//\n\nvec4  Hash01x4(inout uint state) { return Float01(uvec4(pcg(state), pcg(state), pcg(state), pcg(state))); }\nvec3  Hash01x3(inout uint state) { return Float01(uvec3(pcg(state), pcg(state), pcg(state))); }\nvec2  Hash01x2(inout uint state) { return Float01(uvec2(pcg(state), pcg(state))); }\nfloat Hash01  (inout uint state) { return Float01(      pcg(state)); }\n\nvec4  Hash11x4(inout uint state) { return Float11(uvec4(pcg(state), pcg(state), pcg(state), pcg(state))); }\nvec3  Hash11x3(inout uint state) { return Float11(uvec3(pcg(state), pcg(state), pcg(state))); }\nvec2  Hash11x2(inout uint state) { return Float11(uvec2(pcg(state), pcg(state))); }\nfloat Hash11  (inout uint state) { return Float11(      pcg(state)); }\n\n\nvec4 Hash01x4(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed)); }\nvec4 Hash01x4(vec3  v, uint seed) { return Hash01x4(vec4(v, 0.0          ), seed); }\nvec4 Hash01x4(vec2  v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash01x4(float v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash01x3(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash01x3(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed)); }\nvec3 Hash01x3(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed); }\nvec3 Hash01x3(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash01x2(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash01x2(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash01(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).x); }\nfloat Hash01(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).x); }\nfloat Hash01(vec2  v, uint seed) { return Float01(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash01(float v, uint seed) { return Float01(pcg(asuint2(v), seed)); }\n\n\nvec4 Hash11x4(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed)); }\nvec4 Hash11x4(vec3  v, uint seed) { return Hash11x4(vec4(v, 0.0          ), seed); }\nvec4 Hash11x4(vec2  v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash11x4(float v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash11x3(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash11x3(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed)); }\nvec3 Hash11x3(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed); }\nvec3 Hash11x3(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash11x2(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash11x2(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash11(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).x); }\nfloat Hash11(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).x); }\nfloat Hash11(vec2  v, uint seed) { return Float11(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash11(float v, uint seed) { return Float11(pcg(asuint2(v), seed)); }\n\n//==============================================================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n\n#define FILTER_WIDTH 8\n\n\nfloat Read(vec2 uv)\n{\n    float size = SIZE*1.0;\n    if(uv.x < 0.0) uv.x += size;\n    if(uv.y < 0.0) uv.y += size;\n    \n    if(uv.x >= size) uv.x -= size;\n    if(uv.y >= size) uv.y -= size;\n    \n    return Hash01(uv, 0u);\n}\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    if(uv0.x > SIZE || uv0.y > SIZE)\n    {\n        discard;\n    }\n    \n    vec2 uv = uv0 - 0.5;\n    \n    #if 0\n    if((uint(uv.x) & 1u) != 0u)\n    {\n        outCol = vec4(0.0);\n        return;\n    }\n    #endif\n    #if 0\n    if((uint(uv.y) & 1u) != 0u)\n    {\n        outCol = vec4(0.0);\n        return;\n    }    \n    #endif\n    //uv = floor(uv * 0.5) * 2.0;\n    //uv *= 2.0;\n    \n    float v = 0.0;\n   \n   #if 0\n    int r = 0;\n    float ws[] = float[](1.0);\n   #elif 0\n    int r = 1;\n    float ws[] = float[](0.5, 0.25);\n   #elif 0\n    int r = 2;\n    float ws[] = float[](0.5, 9.0/32.0, -1.0/32.0);\n   #elif 0\n    int r = 3;\n    float ws[] = float[](0.5, 75.0/256.0, -25.0/512.0, 3.0/512.0);\n   #elif 0\n    int r = 4;\n    float ws[] = float[](0.5, 1225.0/4096.0, -245.0/4096.0, 49.0/4096.0, -5.0/4096.0);\n   #elif 0\n    int r = 5;\n    float ws[] = float[](0.5, 19845.0/65536.0, -2205.0/32768.0, 567.0/32768.0, -405.0/131072.0, 35.0/131072.0 );\n   #elif 0\n    int r = 6;\n    float ws[] = float[](0.5, 160083.0/524288.0, -38115.0/524288.0, 22869.0/1048576.0, -5445.0/1048576.0, 847.0/1048576.0, -63.0/1048576.0);\n   #elif 1\n    \n    const int r = FILTER_WIDTH;\n    float ws[r+1];\n    \n    float n = float(r);\n    \n    float ww = 0.25;\n    for(float i = 1.0; i < n; ++i)\n    {\n        ww *= -(i * 2.0 - 1.0) / (i * 8.0);\n    }\n    \n    ws[r] = ww;\n    \n    float a = n * 2.0 - 1.0;\n    float b = n * 2.0;\n    float c = n * 2.0 + 1.0;\n    \n    int j = 1;\n    for(float i = 1.0; i < n; ++i, ++j)\n    {\n        ww *= ((i * 2.0 - c) * (i - b)) / \n              ((i * 2.0 - a) *  i     );\n        \n        ws[r - j] = ww;\n    }\n    \n    ws[0] = 0.5;\n    \n   #endif\n   \n    for(int y = -r; y <= r; ++y)\n    for(int x = -r; x <= r; ++x)\n    {\n        float w = ws[abs(x)] * ws[abs(y)];\n        // 0, 1, 3, 5, 7, ...\n        int x0 = (abs(x) * 2 - 1) * sign(x);\n        int y0 = (abs(y) * 2 - 1) * sign(y);\n        v += Read(uv + vec2(x0, y0)) * w;\n    }\n    \n    outCol = vec4(v, 0.0, 0.0, 1.0);\n    \n    return;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n    vec2 uv = fragCoord.xy - 0.5;\n    \n    if(fragCoord.x >= SIZE || fragCoord.y >= SIZE) {fragColor = vec4(0.01); return;}\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, uv.y), 0).rg;\n        //vec2 yn = texelFetch(iChannel1, ivec2(uv.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (uv -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\t//fragColor.xy += cmul(yn, ang.y);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n    vec2 uv = fragCoord.xy - 0.5;\n    \n    if(fragCoord.x >= SIZE || fragCoord.y >= SIZE) {fragColor = vec4(0.01); return;}\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\t//vec2 xn = texelFetch(iChannel0, ivec2(i, uv.y), 0).rg;\n        vec2 yn = texelFetch(iChannel1, ivec2(uv.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (uv -SIZE/2.) * i/SIZE;\n\t\t//fragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}