{
    "Shader": {
        "info": {
            "date": "1530664758",
            "description": "Particle physics done by storing the particles as pixels in 2D, rather than the generally much more practical list of particles that are then rendered via some form of iteration over the list. This allows for as many particles as pixels on the screen.",
            "flags": 48,
            "hasliked": 0,
            "id": "ldKfDV",
            "likes": 8,
            "name": "Particle Physics",
            "published": 3,
            "tags": [
                "2d",
                "mouse",
                "interactive",
                "particles",
                "fun",
                "physics",
                "particle",
                "momentum",
                "inertia"
            ],
            "usePreview": 0,
            "username": "1j01",
            "viewed": 820
        },
        "renderpass": [
            {
                "code": "/*\n\nControls:\n- Click to gravitate particles.\n- Hold Ctrl to randomize velocities.\n- Hold Shift to expand particles into big blocks of particles.\n\n*/\n\n/* the interesting code is all in Buf A */\n\n// get color from Buf A, relative to current pixel\nvec4 bufColor(in vec2 fragCoord) {    \n    return texture(iChannel0,  fract(fragCoord.xy / iResolution.xy));\n}\n\nconst bool colorMode = true;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = bufColor(fragCoord);\n    \n    if(col.w > 0.0){\n        if(colorMode){\n            // optionally change the color scheme\n            //col.z = 1.0;\n            fragColor = col;\n        }else{\n\t\t\tfragColor = vec4(1.0, 1.0, 1.0, 1.0);\n        }\n    }else{\n        if(colorMode){\n            // optional background color\n            //col.z = vec4(1.0, 1.0, 1.0, 1.0);\n        }\n    }\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n\n\n\n// --- key toggles -----------------------------------------------------\n\n// FYI: LEFT:37  UP:38  RIGHT:39  DOWN:40   PAGEUP:33  PAGEDOWN:34  END : 35  HOME: 36\n// Modifiers: SHIFT: 16 CTRL: 17 ALT: 18\n// Advice:  Mode: keyToggle(key)  Action: keydown(key)+keyclick(modifier)\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define shift             ( texelFetch(iChannel3,ivec2(16,0),0).x  > 0.)\n#define ctrl              ( texelFetch(iChannel3,ivec2(17,0),0).x  > 0.)\n#define alt               ( texelFetch(iChannel3,ivec2(18,0),0).x  > 0.)\n\n\n//----------------------------------------------------------------------------------------\n// Pseudorandom number generator, based on https://www.shadertoy.com/view/4djSRW\n///  3 out, 3 in...\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define MAX_ITERATIONS 30\n#define MIN_ITERATIONS 4\n\n// hash33, tweaked to include an extra param\nvec3 hash33(vec3 p3, int i)\n{\n    p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19+float(i)/20.);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nvec3 rnd3(vec2 position, int i)\n{\n\n    i += MIN_ITERATIONS;\n    vec3 a = vec3(0.0), b = a;\n    //NOTE - not handling i > MAX_ITERATIONS\n    //will just start scaling down random numbers\n    for (int t = 0; t < MAX_ITERATIONS; t++)  // max_iterations thing is due to GLSL limitations?\n    {\n        if (t == i) {\n            break;\n        }\n        float v = float(t+1)*.132;\n        vec3 pos = vec3(position, iTime*.3) + iTime * 500. + 50.0;\n        a += hash33(pos, i);  //just changing the numer of iterations doesn't work, so we pass in i\n    }\n    vec3 col = a / float(i);\n    return col;\n}\n//----------------------------------------------------------------------------------------\n\n/*\nfloat toroidalDistance (float x1, float y1, float x2, float y2) {\n    float dx = abs(x2 - x1);\n    float dy = abs(y2 - y1);\n \n    if (dx > 0.5f)\n        dx = 1.0f - dx;\n \n    if (dy > 0.5f)\n        dy = 1.0f - dy;\n \n    return sqrt(dx*dx + dy*dy);\n}\n*/\n/*\nvec2 toroidalNearestWay (vec2 from, vec2 to, vec2 mapSize) {\n    vec2 delta = to - from; // difference in position\n\n    if (delta.x > mapSize.x / 2.0) // if distance is bigger than half map width, then looping must be closer\n        delta.x = (delta.x - mapSize.x) * -1.0; // reduce distance by map width, reverse \n    else if (delta.x < -mapSize.x / 2.0) // handle the case that delta x is negative\n        delta.x = (delta.x + mapSize.x) * -1.0;\n\n    if (delta.y > mapSize.y / 2.0)\n        delta.y = (delta.y - mapSize.y) * -1.0;\n    else if (delta.y < -mapSize.y / 2.0)\n        delta.y = (delta.y + mapSize.y) * -1.0;\n\n    return delta;\n}\n*/\n\nvec2 toroidalNearestWay (vec2 from, vec2 to, vec2 mapSize) {\n    return (mod((to - from + 3.0 * mapSize / 2.0), mapSize)) - mapSize / 2.0;\n}\n\n\n\n// Get old color, relative to current pixel\nvec4 oldColor(in vec2 fragCoord, in vec2 xyDelta) {\n    // Try messing with me!\n   \t//xyDelta.x += sin(fragCoord.x);\n   \t//xyDelta.y += sin(fragCoord.y * 3.0);\n    return texture(iChannel0, fract((fragCoord.xy + xyDelta) / iResolution.xy));\n}\n\n// Get the next random number for the current pixel\n#define RND() (rnd3(fragCoord, rndi++))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    int rndi = 0;\n    const vec4 black = vec4(0., 0., 0., 1.);\n    const vec4 white = vec4(1.);\n    const vec4 red = vec4(1., 0., 0., 1.);\n    // current coordinates, normalised 0..1\n    vec2 uv = fragCoord.xy / iResolution.xy;              \n\n    //////////////////////    \n    // Add particles\n    //////////////////////    \n    vec3 rnd = RND();\n    if (iTime < 0.2) { //  || iMouse.z > 0.0\n        if (rnd.x < .00001) {\n            fragColor = vec4(RND(), 1.);\n            return;\n        }\n    }\n\n    //////////////////////\n    // Shuffle pixels around\n    //////////////////////\n\n    vec4 col;\n\n\n    float velDetectRange = shift ? 3.0 : 0.5;\n    //const float velDetectRange = 1.95; // mess with me! \"supposed\" to be 0.5 but try 0.75; etc.\n    //float velDetectRange = max(0.5, sin(iTime / 2.0) * 3.0); // heck, let's go crazy with it!\n    // TODO: control this with the keyboard\n    \n    const float mouseForce = 0.25;\n    //const float mouseForce = 1111.0;\n\n     // WARNING: determines O(N^2) pixel iteration! (i.e. doesn't scale good)\n    const float maxVelocity = 5.0;\n    \n    // Iterate over nearby pixels\n    for (float dx = -maxVelocity; dx < maxVelocity; dx++) {\n        for (float dy = -maxVelocity; dy < maxVelocity; dy++) {\n            \n            // The idea here is we're looking at each potential place a particle could end up,\n            // because that's how a fragment shader is set up, to output a given pixel, not an arbitrary pixel\n            // so rather than iterate over pixels, see if there's a particle there and if so apply phyiscs and put a pixel representing that particle somewhere else,\n            // we iterate over the pixels and see if there's a particle that will end up where we're looking based on its current velocity,\n            // then we apply physics, updating it's velocity for the pixel we're going to output\n            \n            // TODO: try avoiding velocity quantization (which leads to squarey behavior)\n            // by having time-accumulating fields, one for x and one for y\n            \n            // TODO: try increasing the effective velEqDetectRange when particle is marked as having collided\n            // for a chain-reaction effect instead of just deleting particles\n            // (can use the z component or w component (to create such a mark); w just needs share with > 0 for the \"existence\" property)\n\n            // TODO: try making it (pseudo)random what particle is chosen when multiple should end up in the same spot\n            // and/or combine them (i.e. their velocities)\n            vec4 acol = oldColor(fragCoord, vec2(dx, dy));\n            vec2 vel = (acol.xy * 2.0 - 1.0) * maxVelocity;\n            if (ctrl) {\n                //vel *= 1. + rnd.xy;\n                vel *= 1. + rnd3(fragCoord.xy + vec2(dx, dy), 1).xy;\n            }\n            // TODO: try clamping circularly w/ normalize, or at least use clamp()\n            vec2 effectiveVel = clamp(vel, -(maxVelocity - 1.0), maxVelocity - 1.0);\n            //float particlesSuperimposed = 0.0;\n            //vec2 accumulatedVel;\n            if(\n                length(effectiveVel) <= maxVelocity &&\n                acol.w > 0.0 && \n                (float(dx) - velDetectRange < effectiveVel.x && effectiveVel.x < float(dx) + velDetectRange) &&\n                (float(dy) - velDetectRange < effectiveVel.y && effectiveVel.y < float(dy) + velDetectRange)\n            ){\n                // gravity\n                //vel.y += 0.1;\n                \n                // mouse attraction\n                if(iMouse.z > 0.0){\n                    //vec2 towardsMouseDelta = iMouse.xy - fragCoord;\n                    //vec2 wrappedTowardsMouseDelta = mod(iMouse.xy, vec2(10.0, 10.0)) - fragCoord;\n                    //vec2 wrappedTowardsMouseDelta = mod(iMouse.xy, iResolution.xy) - fragCoord;\n                    //if(length(wrappedTowardsMouseDelta) < length(towardsMouseDelta)){\n                    //    towardsMouseDelta = wrappedTowardsMouseDelta;\n                    //}\n                    //float nearestMouseX = iMouse.x - fragCoord.x;\n                    vec2 towardsMouseDelta = toroidalNearestWay(fragCoord, iMouse.xy, iResolution.xy);\n                    \n                    //vec2 towardsMouseDelta = mod(iMouse.xy - fragCoord, iResolution.xy) + iResolution.xy / 2.0;\n                    //vec2 towardsMouseDelta = mod(iMouse.xy - fragCoord - iResolution.xy / 2.0, iResolution.xy) + iResolution.xy / 2.0;\n                    \n                    vec2 towardsMouseForce = normalize(towardsMouseDelta) * mouseForce;\n                    //exponential falloff or whatever:\n                    //vec2 towardsMouseForce = normalize(towardsMouseDelta) / (pow(length(towardsMouseDelta), 2.0)) * mouseForce;\n                    \n                    vel.x -= towardsMouseForce.x;\n                    vel.y -= towardsMouseForce.y;\n                }\n                \n                // friction\n                //vel *= 0.99;\n                // random:\n                //vel *= 1.0 - (RND().x) / 200.0;\n                \n                // max velocity\n                //vel = min(max(vel, -(maxVelocity - 1.0)), maxVelocity - 1.0);\n                // fun:\n                //vel = normalize(vel) * 2.0;\n                // wrong (or corrong):\n                //vel = min(vel, normalize(vel) * (maxVelocity));\n                // correct:\n                vel = normalize(vel) * min(length(vel), maxVelocity - 0.1);\n                \n                //col = acol;\n                col.xy = (vel / maxVelocity + 1.0) / 2.0;\n                col.zw = acol.zw;\n                //col.z += RND().x * 0.1;\n                //col.xy += (vel / maxVelocity + 1.0) / 2.0;\n                //accumulatedVel += vel;\n                //particlesSuperimposed++;\n            }\n            //col.xy /= particlesSuperimposed;\n            //accumulatedVel /= particlesSuperimposed;\n            //col.xy = (accumulatedVel / maxVelocity + 1.0) / 2.0;\n        }\n    }\n\n    fragColor = col;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}