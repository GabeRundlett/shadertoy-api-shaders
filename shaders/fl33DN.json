{
    "Shader": {
        "info": {
            "date": "1636152273",
            "description": "Continuous Multiple Neighborhood Cellular Automata",
            "flags": 32,
            "hasliked": 0,
            "id": "fl33DN",
            "likes": 3,
            "name": "Multiple Neighborhood CA (MNCA)",
            "published": 3,
            "tags": [
                "2d",
                "simulation",
                "diffusion",
                "automata",
                "life",
                "chaos",
                "cellular",
                "conway",
                "gameoflife",
                "cellularautomata",
                "cellularautomata",
                "cgol"
            ],
            "usePreview": 1,
            "username": "SlackermanzCA",
            "viewed": 434
        },
        "renderpass": [
            {
                "code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texelFetch( iChannel0, ivec2(gl_FragCoord[0], gl_FragCoord[1]), 0); }",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define txdata (iChannel0)\n#define PI 3.14159265359\n#define LN 2.71828182846\n\nconst uint MAX_RADIUS = 12u;\n\nuint[64] ub =  uint[64]\n(   2839374232u, 0u, 1190592433u, 120280933u, \n    1201467016u, 2983406577u, 2297663992u, 1569390293u, \n    3397953984u, 1373611332u, 1618794663u, 2895989683u, \n    3930721692u, 1194469218u, 3471826459u, 2539298369u, \n    898988449u, 834832879u, 2351275768u, 2491209886u, \n    4226066187u, 2922813275u, 3190474889u, 3664004364u, \n    3133186130u, 2598110722u, 3222427546u, 595394072u, \n    0u, 2532027177u, 2332938883u, 2284688949u, \n    3736139869u, 606451005u, 2938049042u, 3274101706u, \n    157067970u, 1270063803u, 416605332u, 313708814u, \n    1997778351u, 2602811305u, 2401004755u, 2462067509u, \n    916236747u, 1813810308u, 1142529981u, 713743344u, \n    0u, 0u, 0u, 0u, \n    0u, 0u, 0u, 0u, \n    0u, 0u, 0u, 0u, \n    0u, 1073928355u, 1116964338u, 0u );\n\nuint u32_upk(uint u32, uint bts, uint off) { return (u32 >> off) & ((1u << bts)-1u); }\n\nfloat lmap() { return (gl_FragCoord[0] / float(textureSize(txdata,0)[0])); }\nfloat vmap() { return (gl_FragCoord[1] / float(textureSize(txdata,0)[1])); }\nfloat cmap() { return sqrt\t( ((gl_FragCoord[0] - float(textureSize(txdata,0)[0])*0.5) / float(textureSize(txdata,0)[0])*0.5)\n\t\t\t\t\t\t\t* ((gl_FragCoord[0] - float(textureSize(txdata,0)[0])*0.5) / float(textureSize(txdata,0)[0])*0.5)\n\t\t\t\t\t\t\t+ ((gl_FragCoord[1] - float(textureSize(txdata,0)[1])*0.5) / float(textureSize(txdata,0)[1])*0.5)\n\t\t\t\t\t\t\t* ((gl_FragCoord[1] - float(textureSize(txdata,0)[1])*0.5) / float(textureSize(txdata,0)[1])*0.5) ); }\nfloat vwm() {\n\tfloat \tscale_raw \t= uintBitsToFloat(ub[62]);\n\tfloat \tzoom \t\t= uintBitsToFloat(ub[61]);\n\tfloat\tscale_new\t= scale_raw;\n\tuint \tmode \t\t= u32_upk(ub[59], 2u, 0u);\n\tif( mode == 1u ) { //\tLinear Parameter Map\n\t\tscale_new = ((lmap() + zoom) * (scale_raw / (1.0 + zoom * 2.0))) * 2.0; }\n\tif( mode == 2u ) { //\tCircular Parameter Map\n\t\tscale_new = ((sqrt(cmap()) + zoom) * (scale_raw / (1.0 + zoom * 2.0))) * 2.0; }\n\treturn scale_new; }\n    \nfloat  tp(uint n, float s) \t\t\t{ return (float(n+1u)/256.0) * ((s*0.5)/128.0); }\nfloat utp(uint v, uint  w, uint o) \t{ return tp(u32_upk(v,w,w*o), vwm()); }\nfloat bsn(uint v, uint  o) \t\t\t{ return float(u32_upk(v,1u,o)*2u)-1.0; }\n    \nvec4  sigm(vec4  x, float w) { return 1.0 / ( 1.0 + exp( (-w*2.0 * x * (PI/2.0)) + w * (PI/2.0) ) ); }\nfloat hmp2(float x, float w) { return 3.0*((x-0.5)*(x-0.5))+0.25; }\n\nvec4  gdv( ivec2 of, sampler2D tx ) {\n\tof \t\t= ivec2(gl_FragCoord) + of;\n\tof[0] \t= (of[0] + textureSize(tx,0)[0]) % (textureSize(tx,0)[0]);\n\tof[1] \t= (of[1] + textureSize(tx,0)[1]) % (textureSize(tx,0)[1]);\n\treturn \ttexelFetch( tx, of, 0); }\n    \nvec4 nbhd( vec2 r, sampler2D tx ) {\n//\tPrecision limit of signed float32 for [n] neighbors in a 16 bit texture (symmetry preservation)\n\tuint\tchk = 2147483648u /\n\t\t\t(\t( \tuint( r[0]*r[0]*PI + r[0]*PI + PI\t)\n\t\t\t\t- \tuint( r[1]*r[1]*PI + r[1]*PI\t\t) ) * 128u );\n\tfloat\tpsn = (chk >= 65536u) ? 65536.0 : float(chk);\n\tvec4\ta = vec4(0.0,0.0,0.0,0.0);\n\tfloat\tw = 1.0;\t// Weighting, unused\n\tif(r[0] == 0.0) { return vec4( gdv( ivec2(0,0), tx )*w*psn ); }\n\telse \t\t\t{\n\t\tfor(float i = 0.0; i <= r[0]; i++) {\n\t\t\tfor(float j = 1.0; j <= r[0]; j++) {\n\t\t\t\tfloat\td = round(sqrt(i*i+j*j));\n\t\t\t\t\t\tw = 1.0;\t//\tPer-Neighbor Weighting, unused\n\t\t\t\tif( d <= r[0] && d > r[1] ) {\n\t\t\t\t\tvec4 t0  = gdv( ivec2( i, j), tx ) * w * psn; a += t0 - fract(t0);\n\t\t\t\t\tvec4 t1  = gdv( ivec2( j,-i), tx ) * w * psn; a += t1 - fract(t1);\n\t\t\t\t\tvec4 t2  = gdv( ivec2(-i,-j), tx ) * w * psn; a += t2 - fract(t2);\n\t\t\t\t\tvec4 t3  = gdv( ivec2(-j, i), tx ) * w * psn; a += t3 - fract(t3); } } }\n\t\treturn a; } }\n\nvec4 totl( vec2 r, sampler2D tx ) {\n//\tPrecision limit of signed float32 for [n] neighbors in a 16 bit texture (symmetry preservation)\n\tuint\tchk = 2147483648u /\n\t\t\t(\t( \tuint( r[0]*r[0]*PI + r[0]*PI + PI\t)\n\t\t\t\t- \tuint( r[1]*r[1]*PI + r[1]*PI\t\t) ) * 128u );\n\tfloat\tpsn = (chk >= 65536u) ? 65536.0 : float(chk);\n\tvec4\tb = vec4(0.0,0.0,0.0,0.0);\n\tfloat\tw = 1.0;\t// Weighting, unused\n\tif(r[0] == 0.0) { return vec4( psn * w, psn * w, psn * w, psn * w ); }\n\telse \t\t\t{\n\t\tfor(float i = 0.0; i <= r[0]; i++) {\n\t\t\tfor(float j = 1.0; j <= r[0]; j++) {\n\t\t\t\tfloat\td = round(sqrt(i*i+j*j));\n\t\t\t\t\t\tw = 1.0;\t//\tPer-Neighbor Weighting, unused\n\t\t\t\tif( d <= r[0] && d > r[1] ) { b += psn * w * 4.0; } } }\n\t\treturn b; } }\n\nvec4 bitring(vec4[MAX_RADIUS] rings_a, vec4[MAX_RADIUS] rings_b, uint bits, uint of) {\n\tvec4 sum = vec4(0.0,0.0,0.0,0.0);\n\tvec4 tot = vec4(0.0,0.0,0.0,0.0);\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) {\n\t\tif(u32_upk(bits, 1u, i+of) == 1u) { sum += rings_a[i]; tot += rings_b[i]; } }\n\treturn sigm( (sum / tot), LN ); } // TODO\n    \nvec4 conv(vec2 r, sampler2D tx) {\n\tvec4 nha = nbhd(r, tx);\n\tvec4 nhb = totl(r, tx);\n\treturn \tnha / nhb; }\n    \n//\tUsed to reseed the surface with lumpy noise\nfloat get_xc(float x, float y, float xmod) {\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0); }\nfloat shuffle(float x, float y, float xmod, float val) {\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val)); }\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc); }\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf; }\nfloat reseed(uint seed, float scl, float amp) {\n\tfloat \tfx = gl_FragCoord[0];\n\tfloat \tfy = gl_FragCoord[1];\n\tfloat \tr0 = get_lump(fx, fy, round( 6.0  * scl), 19.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),17.0), 23.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),43.0));\n\tfloat \tr1 = get_lump(fx, fy, round( 22.0 * scl), 13.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),29.0), 17.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),31.0));\n\tfloat \tr2 = get_lump(fx, fy, round( 14.0 * scl), 13.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),11.0), 51.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),37.0));\n\tfloat \tr3 = get_lump(fx, fy, round( 18.0 * scl), 29.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed), 7.0), 61.0 + mod(float(u32_upk(ub[63], 24u, 0u)+seed),28.0));\n\treturn clamp( sqrt((r0+r1)*r3*(amp+1.2))-r2*(amp*1.8+0.2) , 0.0, 1.0); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tRule Initilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tNH Rings\n\tvec4[MAX_RADIUS] nh_rings_c_a;\n\tvec4[MAX_RADIUS] nh_rings_c_b;\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) {\n\t\tnh_rings_c_a[i] = nbhd( vec2(i+1u,i), txdata );\n\t\tnh_rings_c_b[i] = totl( vec2(i+1u,i), txdata ); }\n\n//\tParameters\n\tconst\tfloat \tmnp \t= 1.0 / 65536.0;\t\t\t//\tMinimum value of a precise step for 16-bit channel\n\tconst\tfloat \ts  \t\t= mnp *  48.0 *  64.0;\n\tconst\tfloat \tn  \t\t= mnp *  48.0 *   2.0;\n\n//\tOutput Values\n\tvec4 res_c = gdv( ivec2(0, 0), txdata );\n\n//\tResult Values\n\tvec4 res_v = res_c;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tUpdate Functions\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n    uint[12] nb = uint[12] (\n\t\tub[0],  ub[1],  ub [2],  ub[3],\n\t\tub[4],  ub[5],  ub [6],  ub[7],\n\t\tub[8],  ub[9],  ub[10], ub[11] );\n\n\tuint[24] ur = uint[24] (\n\t\tub[12], ub[13], ub[14], ub[15], \n\t\tub[16], ub[17], ub[18], ub[19],\t\n\t\tub[20], ub[21], ub[22], ub[23],\n\t\tub[24], ub[25], ub[26], ub[27],\t\n\t\tub[28], ub[29], ub[30], ub[31], \n\t\tub[32], ub[33], ub[34], ub[35]  );\n\n\tuint[ 3] ch2 = uint[ 3] ( 2286157824u, 295261525u, 1713547946u );\n\tuint[ 3] ch  = uint[ 3] ( ub[38], ub[39], ub[40] );\n\tuint[ 3] ch3 = uint[ 3] ( ub[41], ub[42], ub[43] );\n\n//\tUpdate Sign\n\tuint[ 2] us = uint[ 2] ( ub[36], ub[37] );\n\n\tfor(uint i = 0u; i < 24u; i++) {\n\t\tuint  \tcho = u32_upk( ch[i/8u], 2u, (i*4u+0u) & 31u );\n\t\t\t\tcho = (cho == 3u) ? u32_upk( ch2[i/8u], 2u, (i*4u+0u) & 31u ) : cho;\n\t\tuint  \tchi = u32_upk( ch[i/8u], 2u, (i*4u+2u) & 31u );\n\t\t\t\tchi = (chi == 3u) ? u32_upk( ch2[i/8u], 2u, (i*4u+2u) & 31u ) : chi;\n\t\tuint  \tchm = u32_upk( ch3[i/8u], 2u, (i*4u+2u) & 31u );\n\t\t\t\tchm = (chm == 3u) ? u32_upk( ch[i/8u], 2u, (i*4u+2u) & 31u ) : chm;\n\n\t\tfloat nhv = bitring( nh_rings_c_a, nh_rings_c_b, nb[i/2u], (i & 1u) * 16u )[cho];\n\n\t\tif( nhv >= utp( ur[i], 8u, 0u) && nhv <= utp( ur[i], 8u, 1u)) {\n\t\t\tfloat h = hmp2(res_c[chm],1.2);\n\t\t\tres_v[chi] += bsn(us[i/16u], ((i*2u+0u) & 31u)) * s * h; }\n\t\tif( nhv >= utp( ur[i], 8u, 2u) && nhv <= utp( ur[i], 8u, 3u)) {\n\t\t\tfloat h = hmp2(res_c[chm],1.2);\n\t\t\tres_v[chi] += bsn(us[i/16u], ((i*2u+1u) & 31u)) * s * h; } }\n\n\tvec4 n4 = sigm(res_v, 0.5) * n * 64.0 + n;\n\tres_c = res_v - n4;\n//\tres_c = conv(vec2(1.0,0.0),txdata);\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 14.0) {\n        res_c[0] = round(mod(float(iFrame),2.0));\n        res_c[1] = round(mod(float(iFrame),3.0));\n        res_c[2] = round(mod(float(iFrame),5.0)); }\n    if (iFrame == 0) { res_c[0] = reseed(0u, 1.0, 0.4); res_c[1] = reseed(1u, 1.0, 0.4); res_c[2] = reseed(2u, 1.0, 0.4); }\n\n//\tForce alpha to 1.0\n\tres_c[3] \t= 1.0;\n    fragColor=clamp(res_c,0.0,1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}