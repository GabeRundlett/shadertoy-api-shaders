{
    "Shader": {
        "info": {
            "date": "1554247615",
            "description": "Had to do one of these myself. Camera-path needs some work. Added SSAA but lost the reflections. Still debugging that.",
            "flags": 64,
            "hasliked": 0,
            "id": "tsjXRG",
            "likes": 3,
            "name": "Yet another lattice structure",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "aa",
                "pbr",
                "lattice"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 510
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// \"Yet another lattice structure\" - One of those things you have to write at\n// least once\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int MAX_ITER    = 48;\nconst float STEP_SIZE = 1.1;\nconst float EPSILON   = .001;\nconst float PI = 3.14159265359;\nconst int AA_SIZE = 3; // 1: no anti-aliasing, 2 and up: better anti-aliasing\n\nmat2 r2d (in float a) {\n    float rad = radians (a);\n    float c = cos(rad);\n    float s = sin (rad);\n    return mat2 (c, s, -s, c);\n}\n\nstruct Result {\n\tfloat d;\n\tint id;\n};\n\n// ---- PBR toolbox ------------------------------\nfloat DistributionGGX (in vec3 N, in vec3 H, in float roughness)\n{\n    float a2     = roughness * roughness;\n    float NdotH  = max (dot (N, H), .0);\n    float NdotH2 = NdotH * NdotH;\n\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.) + 1.);\n    denom        = PI * denom * denom;\n\n    return nom / denom;\n}\n\nfloat GeometrySchlickGGX (in float NdotV, in float roughness)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1. - roughness) + roughness;\n\n    return nom / denom;\n}\n\nfloat GeometrySmith (in vec3 N, in vec3 V, in vec3 L, in float roughness)\n{\n    float NdotV = max (dot (N, V), .0);\n    float NdotL = max (dot (N, L), .0);\n    float ggx1 = GeometrySchlickGGX (NdotV, roughness);\n    float ggx2 = GeometrySchlickGGX (NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick (in float cosTheta, in vec3 F0, float roughness)\n{\n\treturn F0 + (max (F0, vec3(1. - roughness)) - F0) * pow (1. - cosTheta, 5.);\n}\n\nfloat smin (in float d1, in float d2, in float r)\n{\n    float h = clamp (.5 + .5 * (d2 - d1) / r, .0, 1.);\n    return mix (d2, d1, h) - r * h * (1. - h);\n}\n\nvec2 mapToScreen (in vec2 p)\n{\n    vec2 res = p;\n    res = res * 2. - 1.;\n    res.x *= iResolution.x / iResolution.y;\n    \n    return res;\n}\n\n\n// ---- Raymarching toolbox ------------------------------\n\n// slightly adapted column-step operator from Mercury's http://mercury.sexy/hg_sdf\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n    if ((a < r) && (b < r)) {\n        vec2 p = vec2(a, b); \n        float columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n        p *= r2d (45.);\n        p.x -= sqrt(2.)/2.*r;\n        p.x += columnradius*sqrt(2.);\n        if (mod(n,2.) == 1.) {\n            p.y += columnradius;\n        }\n        p.y = mod (p.y + columnradius, columnradius*2.)-columnradius;\n        float result = length(p) - columnradius;\n        result = min(result, p.x);\n        result = min(result, a); \n        return min(result, b); \n    } else {\n        return min(a, b); \n    }   \n}\n\nfloat udRoundedBox (in vec3 p, in vec3 size, in float r)\n{\n    return length(max (vec3 (.0), abs (p) - size)) - r;\n}\n\nvec3 cylinderCenter;\n\nResult scene (in vec3 p)\n{\n\tp.xz *= r2d (34.*iTime);\n\tp.xy *= r2d (23.*iTime);\n\tp.x -= cos (iTime);\n\tp.z -= sin (iTime);\n\n    // bye-bye Lipschitz continuity... but it looks cool :)\n    p.xy *= r2d (3.*p.z);\n    p.yz *= r2d (3.*p.x);\n\n\tcylinderCenter = p;\n\tvec3 size = vec3 (3.5);\n\tcylinderCenter = mod (cylinderCenter + .5*size, size) - .5*size;\n\tfloat cylinder = length (cylinderCenter.xz) - .1;\n\tcylinder = min (cylinder, length (cylinderCenter.yz) - .3);\n\tcylinder = min (cylinder, udRoundedBox (cylinderCenter, vec3 (.1, .2, 2.), .075));\n    float d = cylinder;\n\n    vec3 ballCenter = p;\n    ballCenter = mod (ballCenter + .5*size, size) - .5*size;\n\n    float ball = length (ballCenter) - .6;\n\n    Result res = Result (.0, 0);\n\tres.d = fOpUnionColumns (cylinder, ball, .1, 2.);\n    res.id = 2;\n    return res;\n}\n\nResult raymarch (in vec3 ro, in vec3 rd)\n{\n    Result res = Result (.0, 0);\n\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        vec3 p = ro + res.d * rd;\n        Result tmp = scene (p);\n        if (abs (tmp.d) < EPSILON*(1. + .125*tmp.d)) return res;\n        res.d += tmp.d * STEP_SIZE;\n        res.id = tmp.id;\n    }\n\n    return res;\n}\n\nvec3 normal (in vec3 p)\n{\n    vec2 e = vec2(.0001, .0);\n    float d = scene (p).d;\n    vec3 n = vec3 (scene (p + e.xyy).d,\n                   scene (p + e.yxy).d,\n                   scene (p + e.yyx).d) - d;\n    return normalize(n);\n}\n\nfloat shadow (in vec3 p, in vec3 n, in vec3 ldir, in float ldist)\n{\n\tfloat d2w = raymarch (p + .01*n, ldir).d;\n\treturn ldist < d2w ? 1. : .1;\n}\n\nfloat ao (vec3 p, vec3 n, float stepsize, int iter, float i) {\n\tfloat ao = .0;\n\tfloat dist = .0;\n\tfor (int a = 1; a <= iter; ++a) {\n\t\tdist = float (a)*stepsize;\n\t\tao += max (.0, (dist - scene (p+n*dist).d)/dist);\n\t}\n\treturn 1. - ao*i;\n}\nvec3 shadePBR (in vec3 ro, in vec3 rd, in float d, in int id)\n{\n    vec3 p = ro + d * rd;\n    vec3 nor = normal (p);\n\n    // \"material\" hard-coded for the moment\n    vec3 s = cylinderCenter;\n    float m = smoothstep (.1, .9, .5 + .5*cos(26.9*(s.x + s.y + s.z)));\n    float metallic  = mix (.4, .6, m);\n    float roughness = mix (.6, .4, m);\n    vec3 albedo = mix (vec3 (.4, .2, .1), vec3 (.8, .7, .6), m);\n    float ao = ao (p, nor, .05, 8, .2);\n\n    // lights hard-coded as well atm\n    vec3 lightColors[2];\n    lightColors[0] = vec3 (.5, .5, .9) * 60.;\n    lightColors[1] = vec3 (.9, .9, .7) * 60.;\n\n    vec3 lightPositions[2];\n    lightPositions[0] = vec3 (.5, 2.75, .5);\n    lightPositions[1] = vec3 (-.3, .25, -.5);\n\n\tvec3 N = normalize (nor);\n    vec3 V = normalize (ro - p);\n\n    vec3 F0 = vec3 (0.04); \n    F0 = mix (F0, albedo, metallic);\n    vec3 kD = vec3(.0);\n\t\t           \n    // reflectance equation\n    vec3 Lo = vec3 (.0);\n    for(int i = 0; i < 2; ++i) \n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - p);\n        vec3 H = normalize(V + L);\n        float ldist = distance (lightPositions[i], p);\n        float attenuation = 5./(ldist * ldist);\n        vec3 radiance = lightColors[i] * attenuation;\n\t        \n        // cook-torrance brdf\n        float aDirect = .125 * pow (roughness + 1., 2.);\n        float aIBL = .5 * roughness * roughness;\n        float NDF = DistributionGGX(N, H, roughness);        \n        float G   = GeometrySmith(N, V, L, roughness);      \n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0, roughness);\n\t        \n        vec3 kS = F;\n        kD = vec3(1.) - kS;\n        kD *= 1. - metallic;\t  \n\t        \n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular     = nominator / max(denominator, .001);  \n\n        // add to outgoing radiance Lo\n        float NdotL = max(dot(N, L), 0.0);                \n        Lo += (kD * albedo / PI + specular) * radiance * NdotL; \n\t    Lo *= shadow (p, N, L, ldist);\n    }\n\n    vec3 ambient = kD*albedo*ao;\n\n    return ambient + Lo;\n}\n\nvec3 camera (in vec2 uv, in vec3 ro, in vec3 aim, in float zoom)\n{\n    vec3 camForward = normalize (vec3 (aim - ro));\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (camForward, worldUp));\n    vec3 camUp = normalize (cross (camRight, camForward));\n    vec3 camCenter = normalize (ro + camForward * zoom);\n\n    return normalize ((camCenter + uv.x*camRight + uv.y*camUp) - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalizing and aspect-correction\n\tvec2 uvRaw = fragCoord.xy/iResolution.xy;\n\n    // set up \"camera\", view origin (ro)\n    vec3 ro = vec3 (.0, 1., 2.);\n    vec3 aim = vec3 (.0, .0, .0);\n    float zoom = 2.;\n\n    float fog = .0;\n    Result res;\n    vec3 color = vec3 (.0);\n\n    for (int x = 0; x < AA_SIZE; ++x) {\n\t    for (int y = 0; y < AA_SIZE; ++y) {\n\n            // anti-alias offset\n            vec2 pixelOffset = vec2 (float(x), float(y)) / float (AA_SIZE) - .5;\n\n            // normalize, aspect-correct and 'bulge' UVs\n\t\t\tvec2 uv = (fragCoord.xy + pixelOffset)/iResolution.xy;\n\t\t    uv = uv * 2. - 1.;\n    \t\tuv.x *= iResolution.x/iResolution.y;\n\t\t\tuv *= 1. + .5*length (uv);\n\n            // create ray for view direction\n\t\t    vec3 rd = camera (uv, ro, aim, zoom);\n\n            // do the ray-march...\n            res = raymarch (ro, rd);\n            fog = 1. / (1. + res.d * res.d * .05);\n            vec3 ctmp = shadePBR (ro, rd, res.d, res.id);\n            ctmp *= fog;\n\n            // do the reflections\n            /*if (res.id == 2) {\n                vec3 p = ro + res.d*rd;\n                vec3 n = normal (p);\n                ro = p +.01*n;\n                rd = normalize (reflect (rd, n));\n\t            Result resRefl = raymarch (ro, rd);\n                ctmp += .05*shadePBR (ro, rd, resRefl.d, resRefl.id);\n            }*/\n\t\t\tcolor += ctmp;\n    \t}\n    }\n    color /= float (AA_SIZE*AA_SIZE);\n\n    // distance-mist, tonemapping, tint, vignette, raster-line, gamma-correction\n\tcolor = mix (color, vec3 (.9, .85, .7), pow (1. - 1. / res.d, 30.));\n\tcolor = color / (1. + color);\n    color *= vec3 (.9, .8, .7);\n    color *= .2 + .8*pow(16.*uvRaw.x*uvRaw.y*(1. - uvRaw.x)*(1. - uvRaw.y), .3);\n\tcolor *= mix (1., .5, cos (1100.*uvRaw.y));\n    color = pow (color, vec3 (1./2.2));\n\n\tfragColor = vec4(color, 1.);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 18264,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/dannybyrdmusic/quantum-leap-feat-terri-pace"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}