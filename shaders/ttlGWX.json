{
    "Shader": {
        "info": {
            "date": "1557933105",
            "description": "Ray tracing tutorial series for the CG discord, Chapter 1, Part 1:\nRay Casting: Intersecting a Sphere\nNext part: https://www.shadertoy.com/view/Wtf3Wl",
            "flags": 0,
            "hasliked": 0,
            "id": "ttlGWX",
            "likes": 2,
            "name": "RC1: Intersecting a Sphere",
            "published": 3,
            "tags": [
                "raycasting",
                "sphere",
                "intersection"
            ],
            "usePreview": 0,
            "username": "vchizhov",
            "viewed": 1148
        },
        "renderpass": [
            {
                "code": "/*\n\t@author: Vassillen Chizhov, 2019\n\tRay tracing tutorial series\n\tChapter 1, Part 1:\n\tRay Casting: Intersecting a sphere\n\n\tUnlike in the C++ code, here the function mainImage(...) is called for every pixel\n\tso while we do not have to iterate over all pixels, since this is done \n\tautomatically for us, we have to redefine the camera and scene for each pixel\n\n\tI have added a time depenedent position for the sphere compared to the C++ code\n\n\tYou can find the tutorial series at:\n\thttps://vchizhov.github.io/resources/ray%20tracing/ray%20tracing%20tutorial%20series%20vchizhov/\n\n\tYou can find the shadertoy code for the next part at:\n\thttps://www.shadertoy.com/view/Wtf3Wl\n*/\n\n// 0 - gradient, 1 - binary image, 2 - inverse power distance\n#define RENDER_MODE 2\n\n/*\n\tThis gets executed for every pixel, the pixel coordinates\n\tare given by fragCoord and are in the range [0,iResolution.x) x [0,iResolution.y)\n\tfragColor is the output color for the pixel.\n\n\tThe correspondence to the C++ code of this function would be the part \n\twithing the two for loops iterating over all image pixels.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 col;\n    \n#if RENDER_MODE == 0\n    // gradient rendering:\n    col = vec3(fragCoord.x/iResolution.x);\n#else\n    \n    // map to [0,1]^2\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    // map to [-1,1]^2\n    uv = (2.0 * uv - 1.0);\n    // map to [-aspectRatio,aspectRatio] x [-1,1] to avoid stretching\n    uv *= vec2(aspectRatio,1.0);\n\n    Camera cam;\n    cam.o = vec3(0.0,0.0,0.0);\n    cam.e0 = vec3(1.0,0.0,0.0);\n    cam.e1 = vec3(0.0,1.0,0.0);\n    cam.e2 = vec3(0.0,0.0,1.0);\n    \n    Sphere sphere;\n    // the sin(iTime) makes the sphere move forward and backward\n    // the z range is [2,4]\n    sphere.origin = vec3(0.0,0.0,3.0+sin(iTime));\n    sphere.radius = 1.0;\n    \n    Ray ray = generateRay(cam, uv);\n    \n    float distanceToIntersection = intersect(sphere, ray, 0.0, INFINITY);\n#if RENDER_MODE == 1\n    // binary image rendering:\n    col = vec3(distanceToIntersection<INFINITY);\n#else\n    // inverse distance^2 rendering:\n\tcol = vec3(1.0 / pow(distanceToIntersection, 2.0));\n#endif\n#endif \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\t@author: Vassillen Chizhov, 2019\n\tRay tracing tutorial series\n\tChapter 1, Part 1:\n\tRay Casting: Intersecting a sphere\n\n\tHere you can find some basics that we use to structure our code.\n\tGenerally this will hold most of the functions and structures that \n\tare in separate header and source files in the C++ code. The correspondence \n\tis not one to one, because of the difference of glsl and C++, however, the \n\tidea behind the functions/structures remains the same, it's just programmed \n\tin a slightly different manner.\n*/\n\n\n// INFINITY is used mainly to filter out intersections, if dist >= INFINITY \n// we consider it as a no intersection case\n// 2^24-1 fits in the mantissa of 32bit floating point numbers nicely and converts \n// to a 24bit int perfectly, I use this as infinity since some GPUs do not like 1.0/0.0\n#define INFINITY 16777215.0\n\n\n\n\n\n/////////////////////////////////////////////////////////////////////////////////////////\n//\n//\t\t\t\t\t\t\t\t\t\tRAY\n//\n/////////////////////////////////////////////////////////////////////////////////////////\n\n\n\n/*\n\t\\brief A ray defined through its origin and a unit-length direction vector\n*/\nstruct Ray\n{\n    vec3 o;\t//!< origin of the ray\n\tvec3 d;\t//!< direction of the ray\n\n};\n\n//! convenience function, returns the point along the ray direction at a distance t from the ray origin\nvec3 at(in Ray ray, in float t)\n{\n \treturn ray.o + t * ray.d;  \n}\n\n\n\n\n\n/////////////////////////////////////////////////////////////////////////////////////////\n//\n//\t\t\t\t\t\t\t\t\t\tCAMERA\n//\n/////////////////////////////////////////////////////////////////////////////////////////\n\n\n\n/*\n\t\\brief A simple pinhole camera model\n*/\nstruct Camera\n{\n\tvec3 e0, e1, e2;\t//!< basis vectors of the camera: right, up, forward\n\tvec3 o;\t\t\t\t//!< the camera origin\n};\n    \n//! returns the normalized ray corresponding to the point (u,v) on the virtual film\nRay generateRay(in Camera cam, in vec2 uv)\n{\n    return Ray(cam.o, normalize(uv.x * cam.e0 + uv.y * cam.e1 + cam.e2));\n}\n\n\n\n\n\n/////////////////////////////////////////////////////////////////////////////////////////\n//\n//\t\t\t\t\t\t\t\t\t\tSPHERE\n//\n/////////////////////////////////////////////////////////////////////////////////////////\n\n\n\n/*\n\t\\brief A sphere defined through its origin and radius\n*/\nstruct Sphere\n{\n\tvec3 origin; \t//! sphere center\n\tfloat radius;\t//! sphere radius\n};\n    \n// Evaluates whether the ray intersects the sphere within the ray segment (minT, maxT)\n// returns INFINITY if there is no intersection, so that a check for intersection can be performed as intersect(...)<INFINITY\n// otherwise returns the distance from the ray origin to the closest intersection\nfloat intersect(in Sphere s, in Ray ray, in float minT, in float maxT)\n{\n    /*\n        |ray(t) - pos| == r <->\n        |ray(t) - pos|^2 == r^2 <->\n        <ray(t)-pos,ray(t)-pos> == r^2 <->\n        <ray.o-pos + t * ray.d, ray.o-pos + t * ray.d> == r^2 <->\n        <ray.d,ray.d> * t^2 - 2 * <ray.d, pos - ray.o> * t + <pos-ray.o,pos-ray.o> - r^2 == 0\n        A = <ray.d,ray.d>, but |ray.d|==1 if the direction is normalized -> A = 1\n        B = <ray.d, pos - ray.o>\n        C = <pos-ray.o,pos-ray.o> - r^2\n\n        D = B^2 - C\n        D<0  -> no intersection\n        D==0 -> grazing intersection\n        D>0  -> 2 intersections\n\n        One can ignore grazing intersections since they are actually numerical error.\n\n        D>0 -> sqrtD = sqrt(D)\n        t_1 = B - D\n        t_2 = B + D\n\n        If maxT>t_1>minT -> intersection at ray(t_1)\n        Else If maxT>t_2>min_t -> intersection at ray(t_2)\n        Else -> no intersection\n    */\n    vec3 oPos = s.origin - ray.o;\n    float b = dot(ray.d, oPos);\n    float c = dot(oPos, oPos) - s.radius * s.radius;\n    float d = b * b - c;\n\n    // If the discriminant is 0 or negative -> no (actual) intersection\n    if (d <= 0.0) return INFINITY;\n\n    float sqrtD = sqrt(d);\n    float t1 = b - sqrtD; // closer intersection\n    // is it within the defined ray segment by (minT,maxT) ?\n    if (t1 > minT && t1 < maxT) return t1;\n\n    float t2 = b + sqrtD; // farther intersection\n    // is it within the defined ray segment by (minT,maxT) ?\n    if (t2 > minT && t2 < maxT) return t2;\n\n    return INFINITY;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}