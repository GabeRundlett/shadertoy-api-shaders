{
    "Shader": {
        "info": {
            "date": "1623581231",
            "description": "shader got the sussy drip\nthe code very sussy tho (dont read ples)",
            "flags": 8,
            "hasliked": 0,
            "id": "flf3Rr",
            "likes": 31,
            "name": "Amogus",
            "published": 3,
            "tags": [
                "2d",
                "sound",
                "sdf",
                "drip",
                "amongus",
                "amogus"
            ],
            "usePreview": 0,
            "username": "manu210404",
            "viewed": 923
        },
        "renderpass": [
            {
                "code": "float msign(in float x) { return (x<0.0)?-1.0:1.0; }\n// sdEllipse by iq - https://www.shadertoy.com/view/4sS3zz\nfloat sd_ellipse( vec2 p, in vec2 ab )\n{\n  //if( ab.x==ab.y ) return length(p)-ab.x;\n\n\n\tp = abs( p ); \n    if( p.x>p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2+n2-1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float d = c3 + m2*n2;\n    float q = d  + m2*n2;\n    float g = m  + m *n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h) + 2.0;\n        float t = sin(h) * sqrt(3.0);\n        float rx = sqrt( m2-c*(s+t) );\n        float ry = sqrt( m2-c*(s-t) );\n        co = ry + sign(l)*rx + abs(g)/(rx*ry);\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt(d);\n        float s = msign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float t = msign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -(s+t) - c*4.0 + 2.0*m2;\n        float ry =  (s-t)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = ry/sqrt(rm-rx) + 2.0*g/rm;\n    }\n    co = (co-m)/2.0;\n\n    float si = sqrt( max(1.0-co*co,0.0) );\n \n    vec2 r = ab * vec2(co,si);\n\t\n    return length(r-p) * msign(p.y-r.y);\n}\n\n\n// opSmoothUnion and opSmoothSubtraction by iq - https://www.shadertoy.com/view/lt3BW2\nfloat s_min( float d1, float d2, float k ) {\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\nfloat s_sub( float d1, float d2, float k ) {\n    float h = max(k-abs(-d1-d2),0.0);\n    return max(-d1, d2) + h*h*0.25/k;\n}\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat edge(float a, vec2 p) {\n    p *= rot(a);\n    return p.y;\n}\n\nvec4 blend(vec4 a, vec4 b) {\n    return vec4(a.w*a.xyz + (1.-a.w)*b.xyz, max(a.w, b.w));\n}\n\nfloat sd_amogus(vec2 p) {\n    \n    // who the heck would use bezier curves for that? not me.\n    \n    float b = sd_ellipse(p, vec2(.5,1.66));   // body\n    b = s_sub(edge(PI*0.97, p)+0.75, b, 0.4); // carving away some edges\n    b = s_sub(edge(PI*0.6, p)+0.42, b, 0.1);\n    b = s_sub(edge(PI*0.54, p)+0.37, b, 0.1);\n    b = s_sub(edge(PI*0.07, p)+0.55, b, 0.1);\n    \n    float r = b;\n    \n    float l = sd_ellipse(p-vec2(-0.02,-0.4),vec2(.21,0.2625)); // seperation between the legs, starting with an ellipse\n    l = s_sub(edge(PI, p) - 0.2, l, 0.1);                      // again, carvin away some parts of the ellipse\n    l = s_sub(edge(PI*0.4, p)+0.32, l, 0.1);\n    \n    r = s_sub(l, r, 0.1); // subtracting that modified ellipse from the body\n    \n    float f1 = sd_ellipse((p*rot(PI*0.1)-vec2(-0.3,-0.53)),vec2(1./0.6*0.14,1.0*0.14)); // left foot, again an ellipse\n    f1 = s_sub(edge(PI*1.09, p)-0.45, f1, 0.1);                                         // make the footh a bit steeper in the front\n    \n    r = s_min(f1, r, 0.07);\n    \n    float f2 = sd_ellipse((p-vec2(0.22,-0.6)),vec2(1./0.52*0.14,1.0*0.14)); // right foot\n    f2 = s_sub(edge(PI*1.1, p)-0.35, f2, 0.2);                    // flatten the foot in the front\n    //f2 = s_sub(edge(PI*0.1, p)+0.75, f2, 0.2);\n    \n    r = s_min(f2, r, 0.05);\n    r = s_sub(edge(PI*-0.05, p)+0.75, r, 0.2); // flatten the underside of the right foot\n    \n    // maybe i should have used bezier curves\n    return r;\n}\n\nvec4 visor(vec2 p) {\n    float l = sd_ellipse(p-vec2(0.0,0.45), vec2(0.4,0.1));\n    l = s_sub(edge(PI*0.45, p)+0.1, l, 0.1);\n    l = s_sub(edge(PI*1.48, p)+0.35, l, 0.1);\n    \n    vec4 e1 = vec4(vec3(0.467,0.549,0.733), smoothstep(0.0,0.025,sd_ellipse(p-vec2(0.1,0.47), vec2(0.2,0.05))));\n    vec4 e2 = vec4(vec3(0.686,0.776,0.871), smoothstep(0.0,0.025,sd_ellipse(p-vec2(0.1,0.47), vec2(0.1,0.025))));\n    vec4 e3 = vec4(vec3(0.910,0.929,0.969), smoothstep(0.0,0.025,sd_ellipse(p-vec2(0.1,0.47), vec2(0.05,0.0125))));\n    vec4 c = blend(e1, e2);\n    c = blend(c, e3);\n\n    \n    float area = smoothstep(0.03,0.0,l);\n    float outline = smoothstep(0.01,0.033,abs(l));\n    \n    return vec4(vec3(outline)*c.xyz, area);\n    //return c;\n}\n\n\nvec4 amogus(vec2 p) {\n    vec2 e = vec2(0.01,0.0);\n    vec2 d = vec2(sd_amogus(p+e.xy)-sd_amogus(p-e.xy), sd_amogus(p+e.yx)-sd_amogus(p-e.yx))/e.x*0.5;\n    float l = sd_amogus(p);\n    float nl = l/length(d);\n    \n    \n    float area = smoothstep(0.03,0.0,nl);\n    float outline = smoothstep(0.01,0.033,abs(nl));\n    \n    \n    //vec3 col = d_to_color(l);\n    vec4 col = vec4(outline*vec3(0.898,0.933,1.000), area);\n\n    vec4 vis = visor(p);\n    \n    col = blend(vis, col);\n    return col;\n    \n}\n\nfloat sdChecker(in vec2 p) {\n    p = fract(p*0.5-0.5)*2.-1.;\n    p = abs(p);\n    float adj = max(abs(p.x-1.0)-0.5,abs(p.y-1.0)-0.5);\n    return min(max(p.x-0.5,p.y-0.5), adj);\n}\n\nvec3 d_to_color(float d) {\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\treturn mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n}\n\nvec2 transform(vec2 p) {\n    float t = (iTime-1.0) * BPS * 0.5; // enter bps here\n    float d = smoothstep(6.0,7.0,t); // intensity of the distortion/movement\n    \n    vec2 offs = p+vec2(sin(t*PI*2.), cos(t*PI))*0.2*(0.5 + 0.5 * d);\n    offs *= rot(sin(t*PI)*PI*0.1);\n    p *= (1.-pow(abs(sin(t*PI*2.)), 10.))*(0.25 + 0.25*d)-pow(length(p), 1.)*(0.5+0.5*d)*0.25;\n    p += offs;\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    uv = transform(uv);\n    \n    vec4 col = amogus(uv);\n    vec4 bg = vec4(vec3(0.910,0.129,0.404),1.0);\n    bg.rgb *= 0.75 + 0.25 * smoothstep(0.0,0.05,sdChecker(uv*2.));\n    col = blend(col, bg);\n    \n    vec2 nuv = fragCoord/iResolution.xy*2.-1.;\n    col *= 0.6+0.4*(1.-nuv.x*nuv.x)*(1.-nuv.y*nuv.y);\n    \n    // Output to screen\n    fragColor = col;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float G2  = 98.00;\nconst float C3  = 130.81;\nconst float BF4 = 466.16;\nconst float C5  = 523.25;\nconst float D5  = 587.33;\nconst float EF5 = 622.25;\nconst float F5  = 698.46;\nconst float GF5 = 739.99;\n\nfloat square_wave(float f, float x) {\n    return floor(2.*floor(f*x)-floor(2.*f*x)+1.);\n}\n\nfloat triangle_wave(float f, float x) {\n    return abs(fract(f*x)*2.-1.)*2.-1.;\n}\n\nfloat sine_wave(float f, float x) {\n    return sin(6.2831*f*x);\n}\n\nfloat amog_note(float f, float x) {\n    //float n = noise(x)*smoothstep(0.1,0.,x)*smoothstep(0.0,0.01,x)*0.1;\n    float amp = smoothstep(0.0,0.01,x);\n    amp *= sine_wave(7., x)*0.5+0.5;\n    amp *= 0.25+0.75*smoothstep(0.12,0.1,x);\n    amp *= smoothstep(0.3, 0.2, x);\n    float w = sine_wave(f, x)*0.875+triangle_wave(f*2.,x)*0.125;\n    return w * amp;\n}\n\nfloat amog_bass(float f, float x) {\n    float amp = smoothstep(0.3,0.2, x);\n    amp *= smoothstep(-0.00,0.01,x);\n    amp *= 0.5 + 0.5 * smoothstep(0.1, 0.0, x);\n    return (square_wave(f, x) + sine_wave(f*.5, x))*amp*0.5;\n}\n\nfloat soft_bass(float f, float x) {\n    float amp = smoothstep(0.3,0.2, x);\n    amp *= smoothstep(-0.00,0.01,x);\n    amp *= 0.5 + 0.5 * smoothstep(0.1, 0.0, x);\n    return (sine_wave(f*.5, x))*amp*0.5;\n}\n\nfloat clap(float x) {\n    float amp = smoothstep(0.2,0.1,x);\n    amp *= smoothstep(0.0,0.01,x);\n    amp *= fract(x*20.);\n    return (FBM21(x*50.).x*0.5+noise(x*200.))*amp*0.25;\n}\n\nfloat hihat(float x) {\n    float amp = smoothstep(0.2,0.15, x);\n    amp *= smoothstep(0.0,0.02, x);\n    amp *= 0.25 + 0.75 * smoothstep(0.1,0.05, x);\n    return (noise((x-.25)*(x-.25)*1000.)*0.5 + FBM21(x).x)*amp*0.5;\n}\n\nvec2 amog_drums(float t) {\n    float eigh = fract(t*BPS*4.)/BPS;\n    float trip = fract(t*BPS*3.)/BPS;\n    float sext = fract(t*BPS*12.)/BPS*0.5;\n    float fast = fract(t*BPS*18.)/BPS*0.5;\n    \n    float x = t*BPS-16.;\n    float amp = 1.;\n    amp *= 0.5 + 0.5 * smoothstep(0.125, 0.0, fract(x/2.));\n    if(x > 0.) {x = fract(x*0.125)*8.;\n        if(x > .5 && x < 1.) {amp *= smoothstep(1., 0.5, x); x = fast;} else \n        if(x > 2.5 && x < 2.75) {amp *= smoothstep(2.75, 2.5, x)*2.; x = fast;} else \n        if(x > 2.75 && x < 3.) {amp *= smoothstep(3., 2.75, x)*2.; x = fast;} else \n        if(x > 7. && x < 7.25) {x = sext;} else \n        if(x > 8. && x < 9.) {x = trip;} else \n        {x = eigh;}\n    }\n    float h = hihat(x) * amp;\n    \n    x = t*BPS-16.;\n    amp = 0.5;\n    if(x > 0.) {x = fract(x*0.25)*4.;\n        if(x > .25 && x < .75) {x -= 0.25; x *= 2.;} else \n        if(x > 1. && x < 1.5) {x -= 1.; amp = 1.;} else \n        if(x > 1.75 && x < 2.25) {x -= 1.75; x *= 2.;} else \n        if(x > 2.25 && x < 2.75) {x -= 2.25; x *= 2.;} else \n        if(x > 3. && x < 3.5) {x -= 3.; amp = 1.;}\n    }\n    float c = clap(x) * amp;\n    return vec2(\n            h*0.5 + c\n        );\n}\n\nvec2 amog_melody_synth(float t) {\n    t = fract(t/16.*BPS)*16.*RBPS;\n    return vec2(\n         amog_note(C5, t-1.*RBPS)\n        +amog_note(EF5, t-1.5*RBPS)\n        +amog_note(F5, t-2.*RBPS)\n        +amog_note(GF5, t-2.5*RBPS)\n        +amog_note(F5, t-3.*RBPS)\n        +amog_note(EF5, t-3.5*RBPS)\n        +amog_note(C5, t-4.*RBPS)\n        +amog_note(BF4, t-5.5*RBPS)\n        +amog_note(D5, t-5.75*RBPS)\n        +amog_note(C5, t-6.*RBPS)\n        \n        +amog_note(C5, t-9.*RBPS)\n        +amog_note(EF5, t-9.5*RBPS)\n        +amog_note(F5, t-10.*RBPS)\n        +amog_note(GF5, t-10.5*RBPS)\n        +amog_note(F5, t-11.*RBPS)\n        +amog_note(EF5, t-11.5*RBPS)\n        +amog_note(GF5, t-12.*RBPS)\n        +amog_note(GF5, t-14.*RBPS)// them Triplets\n        +amog_note(F5, t-14.33*RBPS)\n        +amog_note(EF5, t-14.66*RBPS)\n        +amog_note(GF5, t-15.*RBPS)\n        +amog_note(F5, t-15.33*RBPS)\n        +amog_note(EF5, t-15.66*RBPS)\n        +amog_note(C5, t-16.*RBPS)\n        )*0.5;\n}\n\nvec2 amog_melody_bass(float t) {\n    t = fract(t/16.*BPS)*16.*RBPS;\n    float bt = fract(t/8.*BPS)*8.*RBPS;\n    return vec2(\n        +soft_bass(C3, bt-0.*RBPS)\n        +soft_bass(C3, bt-1.*RBPS)\n        +soft_bass(C3, bt-2.*RBPS)\n        +soft_bass(C3, bt-3.*RBPS)\n        +soft_bass(C3, bt-4.*RBPS)\n        +soft_bass(C3, bt-5.*RBPS)\n        +soft_bass(C3, bt-6.*RBPS)\n        +soft_bass(G2, bt-7.5*RBPS)\n        +soft_bass(C3, bt-8.*RBPS)\n        \n        +amog_bass(G2, t-7.5*RBPS)\n        +amog_bass(C3, t-8.*RBPS)\n        +amog_bass(C3, t-0.*RBPS)\n        );\n}\n\nvec2 mainSound( int samp, float time )\n{\n    vec2 s = vec2(amog_melody_bass(time)) * vec2(sin(time*BPS*0.25*PI), sin((time+1.)*BPS*0.25*PI));\n    s += vec2(amog_melody_synth(time)) * vec2(0.5,1.0);\n    s += vec2(amog_drums(time)) * vec2(1.0,0.25);\n    return s;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "const float BPM = 100.;\nconst float BPS = BPM/60.;\nconst float RBPS = 60./BPM;\n#define PI 3.1415926\n\n\n// from https://www.shadertoy.com/view/4ts3z2\nvec2 add = vec2(1.0, 0.0);\n#define MOD2 vec2(.16632,.17369)\n#define MOD3 vec3(.16532,.17369,.15787)\n\nfloat noise(float x) {\n\tvec2 p2 = fract(vec2(x) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\nvec2 Noise22(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 res = mix(mix( hash22(p),          hash22(p + add.xy),f.x),\n                    mix( hash22(p + add.yx), hash22(p + add.xx),f.x),f.y);\n    return res-.5;\n}\nvec2 FBM21(float v)\n{\n    vec2 r = vec2(0.0);\n    vec2 x = vec2(v, v*1.3+23.333);\n    float a = .6;\n    for (int i = 0; i < 8; i++)\n    {\n        r += Noise22(x * a) / a;\n        a += a;\n    }\n    return r;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}