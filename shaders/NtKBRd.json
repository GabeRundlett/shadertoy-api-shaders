{
    "Shader": {
        "info": {
            "date": "1665068177",
            "description": "how could we interpolate more smoothly the curve betweel levels ?",
            "flags": 0,
            "hasliked": 0,
            "id": "NtKBRd",
            "likes": 33,
            "name": "Hilbert curve morphed 7",
            "published": 3,
            "tags": [
                "morphing",
                "short",
                "filling",
                "hilbertcurve"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 281
        },
        "renderpass": [
            {
                "code": "// variant of https://shadertoy.com/view/XtjXW3\n\n//#define interp(l0,l1,t)        mix(l0,l1, t ) \n  #define interp(l0,l1,t)  sqrt( mix(l0*l0,l1*l1, t ) )\n//#define interp(l0,l1,t)     1./mix(1./l0,1./l1, t ) \n//#define interp(l0,l1,t)   pow( mix(pow(l0,10.),pow(l1,10.), t ), .1 ) \n//#define interp(l0,l1,t)   pow( mix(pow(l0,.1),pow(l1,.1), t ), 10. ) \n//#define interp(l0,l1,t)   log( mix(exp(l0),exp(l1), t ) ) \n  \n#define plot(U,l) ( dot(U,l) > 0.  ? abs( dot(U , vec2(-l.y,l.x)) ) : 0. )  // segment\n#define plotC(U,l)  abs( length( U - (l)/2. ) - .5 )                        // arc\n\nvoid iter( inout vec2 U, inout vec2 l, inout vec2 r ) {\n        vec2 I = vec2(1,0), J = vec2(0,1), k,\n           fU = step(.5,U);                                                 // select child\n        bvec2 c = bvec2(fU);     \n        U = 2.*U - fU;                                                      // go to new local frame\n        l = c.x ? c.y ? -J : -I                                             //   node left segment\n                : c.y ?  l :  J;\n        r =  c.x==c.y ?  I : c.y ?-J:J;                                     //   node right segment\n                                                                            // the heart of Hilbert curve : \n        if (c.x) { U.x = 1.-U.x;  l.x=-l.x;  r.x=-r.x;  k=l;l=r;r=k; }      //   sym\n        if (c.y) { U   = 1.-U.yx; l  =-l.yx; r  =-r.yx; }                   //   rot+sym\n}\n\nvoid mainImage( out vec4 O,  vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = u/R.y - vec2(.3,0) + 1e-5, // or bug at depth 2. why ?\n          P = vec2(.5), l = vec2(-1,0), r=l;\n    float T = 2.*ceil( log2(R.y)-3. ), t = mod(iTime,T ), l0,l1; \n    t = min(t, T-t);\n    \n    for (float i=0.; i < t; i++)\n         iter(U,l,r);\n     // Shane: dot(l,r)==0.\n    l0 = length(l+r) > 0. ? plotC (U-P, l+r) :  plot (U-P, l) + plot (U-P, r); // curve at lod n & n+1\n    iter(U,l,r);\n    l1 = length(l+r) > 0. ? plotC (U-P, l+r) :  plot (U-P, l) + plot (U-P, r); \n    \n   \n    P = min(U,1.-U);                                                           // clamp \n    O = vec4(   smoothstep( 1.5, -1.5, ( interp(l0,l1,fract(t)) -.33 ) *.5*R.y/exp2(t) )  // draw\n // O = vec4(   smoothstep( 3., 0., ( mix(vec4(l0),vec4(l1),vec4(0,1,fract(t),0) ) -.1 ) *.5*R.y/exp2(t) ) \n // O = vec4(   smoothstep( 3., 0., abs( mix(vec4(l0),vec4(l1),vec4(0,1,fract(t),0) ) -.33 ) *.5*R.y/exp2(t) ) \n              * step( 0., min(P.x,P.y)  )\n            );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}