{
    "Shader": {
        "info": {
            "date": "1531565244",
            "description": "experimenting with 2d vector (of known max mag) encoding into closest point(theta-param) on Archimedes spiral, stored in 8-bits. \nInterpolates OK when filter-sampled from texture.\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "4tdcRH",
            "likes": 4,
            "name": "Vec2d to scalar/spiral encoding",
            "published": 3,
            "tags": [
                "packing"
            ],
            "usePreview": 0,
            "username": "msomeone",
            "viewed": 525
        },
        "renderpass": [
            {
                "code": "// MODE 0 - original 2d vector field\n// MODE 1 - spiral encoded vector field\n// MODE 2 - spiral encoded & quantized to 8 bit\n// MODE 3,4 - errors\n// MODE 5 - MODE0 VS MODE2\n#define MODE 5\n\n\n#define M_PI (3.14159)\n\n// better have more spiral turns and \n// scale your vector before encode/decode\nconst float MAX_VECTOR_MAGNITUDE = 1.;\n\n// spiral params\nconst int number_of_turns = 8;\nconst float n = float(number_of_turns);\n\nconst float a_initial_radius = .0001; // assuming that vectors mag < 0.1 mean zero vector.\nconst float a_final_radius = MAX_VECTOR_MAGNITUDE;\nconst float dR = (a_final_radius - a_initial_radius);\n\nconst float start_angle = 0.;\nconst float final_angle = 2. * M_PI * n;\n\nconst float b_growth_rate = dR / (final_angle - start_angle);\n\nfloat field(vec2 uv) {\n    vec2 c0 = vec2(0.7);  \n    vec2 c1 = vec2(0.3);\n    return min(\n        \t(length(uv - c0) * length(uv - c1)) * \n        \t\tMAX_VECTOR_MAGNITUDE,\n        \t\tMAX_VECTOR_MAGNITUDE\n    \t\t);\n}\n\nvec2 field_grad(vec2 uv) {\n    float c = field(uv);\n    vec2 dxy = 1./iResolution.xy;\n    float x = field(uv + vec2(dxy.x, 0.));\n    float y = field(uv + vec2(0., dxy.y));\n    return (vec2(x,y) - c ) / dxy;\n}\n\n\nfloat encode_into_archimedes_spiral_parameter(vec2 v)\n{    \n    float vl = length(v);\n    vec2 vn = v / vl;\n    float theta = atan(vn.y,vn.x) + M_PI; theta = max(0., theta);\n    \n    float f = a_initial_radius + b_growth_rate*theta;\n    float K = b_growth_rate*2.*M_PI;\n    \n    float th = theta;\n    for (int i = 0; i < number_of_turns; i++ ) { // T_T\n        f += K;\n        th += 2.*M_PI;\n    }\n        \n    return max(theta,th - 2.*M_PI) - M_PI;\n}\n\nvec2 decode_from_archimedes_spiral_parameter(float theta)\n{\n   \tvec2 v; v.x = cos(theta); v.y = sin(theta);\n    return (theta*b_growth_rate + a_initial_radius) * v;    \n}\n\nfloat quantize_unit_input_to_8bit(float x) {\n    return floor(x * 255.);\n}\n\nfloat _8bit_unit_input_to_float(float x) {\n    return fract(x / 255.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 vector_to_encode = -field_grad(uv) * MAX_VECTOR_MAGNITUDE;\n    float encoded_vector = encode_into_archimedes_spiral_parameter(vector_to_encode);\n    vec2 decoded_vector = decode_from_archimedes_spiral_parameter(encoded_vector);\n    \n    float quantized_spiral_parameter_8bit = \n        \tquantize_unit_input_to_8bit(encoded_vector/final_angle);\n    \n    float encoded_vector_unpacked_from_8bit = \n        \tfinal_angle * _8bit_unit_input_to_float(quantized_spiral_parameter_8bit);\n    \n    vec2 decoded_vector_from_8bit = decode_from_archimedes_spiral_parameter(encoded_vector_unpacked_from_8bit);\n    \n    vec3 col = vec3(0.);\n        \n    #if MODE == 0\n    col.xy = (vector_to_encode * .5 + .5) / MAX_VECTOR_MAGNITUDE;\n    #elif MODE == 1\n    col.xy = (decoded_vector * .5 + .5) / MAX_VECTOR_MAGNITUDE;\n    #elif MODE == 2\n    col.xy = (decoded_vector_from_8bit * .5 + .5) / MAX_VECTOR_MAGNITUDE;\n    #elif MODE == 3\n    vec2 e1 = abs(vector_to_encode - decoded_vector);\n    col.xyz = vec3(sqrt(dot(e1,e1))/length(vector_to_encode)); // error vis\n    #elif MODE == 4\n    vec2 e2 = abs(vector_to_encode - decoded_vector_from_8bit);\n    col.xyz = vec3(sqrt(dot(e2,e2))/length(vector_to_encode)); // error vis\n    #elif MODE == 5\n    vec2 col_m0 = (vector_to_encode * .5 + .5) / MAX_VECTOR_MAGNITUDE;\n    vec2 col_m1  = (decoded_vector_from_8bit * .5 + .5) / MAX_VECTOR_MAGNITUDE;\n    \n    float ta = -iTime * 0.1;\n    vec2 animv1 = vec2(cos(ta), sin(ta));\n    vec2 line_normal = vec2(-animv1.y,animv1.x);\n    float line_d = dot(line_normal, vec2(0.5));\n    \n    if ( dot(uv,line_normal) < line_d ) {\n        col.xy = col_m0;\n    } else {\n        col.xy = col_m1;\n    }\n    #endif\n    \n\tfragColor = vec4(pow(col, vec3(1./2.4)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}