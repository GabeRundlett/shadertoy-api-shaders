{
    "Shader": {
        "info": {
            "date": "1667894649",
            "description": "Tri Cylinder - sdf - practice",
            "flags": 0,
            "hasliked": 0,
            "id": "cd23zV",
            "likes": 4,
            "name": "Tri Cylinder - sdf - practice",
            "published": 3,
            "tags": [
                "phong",
                "raymarch",
                "sdf",
                "blinn"
            ],
            "usePreview": 0,
            "username": "kanayuki",
            "viewed": 204
        },
        "renderpass": [
            {
                "code": "# define pi 3.141592653589793238462643383279502\n\nmat2 rotateMatrix(float theta)\n{\n    return mat2(cos(theta),-sin(theta),\n                sin(theta),cos(theta));\n}\n\nfloat sdTorus(vec3 p, float r1, float r2)\n{\n    float d = length(p.xy)-r1;\n    return length(vec2(d,p.z))-r2;\n}\n\nfloat sdCylinder(vec3 p, float r, float h)\n{\n    float d = length(p.xy)-r;\n    vec2 w = vec2(d, abs(p.z)-h);\n    return min(max(w.x,w.y), 0.0) + length(max(w,0.0));\n}\n\nfloat sdf(vec3 p) \n{\n    p.xz *= rotateMatrix(iTime);\n    p.xy *= rotateMatrix(iTime);\n    \n    // Symmetries\n    p = abs(p);\n    if(p.x>p.y) p.xy=p.yx;\n    if(p.y>p.z) p.yz=p.zy;\n    if(p.x>p.y) p.xy=p.yx;\n    \n    float cy = sdCylinder(p,0.3,3.0);\n    float t = sdTorus(p.zyx,3.0,0.5);\n     \n    return min(cy,t);\n }\n\nfloat rayMarching(vec3 raySource, vec3 direction)\n{\n    float d = 0.0;\n    for (int i=0; i<100; i++)\n    {\n        float len = sdf(raySource+direction*d);\n        if (len<0.001 || d>30.0) break;\n        d += len;\n    }\n    return d;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0.0001,0);\n    float d = sdf(p);\n    float pdx=sdf(p+e.xyy)-d;\n    float pdy=sdf(p+e.yxy)-d;\n    float pdz=sdf(p+e.yyx)-d;\n    return normalize(vec3(pdx,pdy,pdz));\n \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y * 4.0;\n\n    vec3 col = vec3(0.75);\n    vec3 raySource = vec3(0,0,20);\n        \n    vec3 screen = vec3(uv,1.0);\n    \n    vec3 direction = normalize(screen-raySource);\n    \n    float d = rayMarching(raySource, direction );\n    if(d<30.0)\n    {\n        vec3 p = raySource+direction*d;\n        vec3 N = getNormal(p);\n        vec3 light = vec3(5,0,5);\n        // light.xz *= rotateMatrix(iTime);\n        \n        vec3 L = normalize(light-p);\n        \n        float diffuse = dot(N,L);\n        // Lambert\n        // diffuse = max(0,diffuse);\n        // Half Lambert\n        diffuse = diffuse * 0.5 + 0.5;\n         \n        \n        // Phong\n        vec3 R = normalize(2.0*N*dot(N,L)-L);\n        vec3 V = -direction;\n        // vec3 specular = 0.1*vec3(1)*pow(dot(R,V),8.0);\n        \n        // Blinn\n        vec3 H = normalize(V+L);\n        vec3 specular = 0.9*vec3(1)*pow(dot(H,N),5.0);\n        \n        \n        vec3 ambient = vec3(0.1,0.1,0.3)*1.5;\n        \n        col = vec3(1,0,1);\n        col = ambient + 0.5*col*diffuse + specular;\n    }\n    \n    // Time varying pixel color\n    // col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}