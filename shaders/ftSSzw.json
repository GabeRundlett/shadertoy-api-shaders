{
    "Shader": {
        "info": {
            "date": "1627321747",
            "description": "Trying to make a cool looking water effect. I also wanted to play around more with reflections.",
            "flags": 0,
            "hasliked": 0,
            "id": "ftSSzw",
            "likes": 5,
            "name": "Reflective Bobbing Floaty Effect",
            "published": 3,
            "tags": [
                "reflection",
                "waves",
                "water",
                "float"
            ],
            "usePreview": 0,
            "username": "intrakits",
            "viewed": 303
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\n#define AA 1\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\nvec2 colMin(vec2 res, vec2 obj){\n    res.x = min(obj.x,res.x);\n    if(obj.x == res.x){\n        res.y = obj.y;\n    }\n    return res;\n}\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\nfloat getDisp(vec2 uv){\n\n    vec2 p = 0.5 - 0.5*sin(vec2(1.01,1.71) );\n    p = vec2(1.0, 1.0);\n\t\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\t\n\tfloat f = iqnoise(24.0*uv, p.x, p.y);\n\t\n\treturn f;\n}\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\nvec2 GetDist(vec3 p){\n    float off =sin(5.*iTime+p.x)*.1+sin(3.*iTime+p.z)*.1;\n    off*=sin(iTime+p.x*2.);\n    off+=sin(7.*iTime+(length(p)-.4)*7.*smoothstep(7.,1.,length(p)-.4))*.01;\n    vec2 res = vec2(p.y+off,1.);\n    off = pow(sin(iTime*2.),2.)*.5+1.;\n    vec2 base = vec2(sdCapsule(p-vec3(0,-smoothstep(off-.5,off,p.y),0), vec3(0.), vec3(0,off,0), .8),2.);\n    \n    \n    res = colMin(res, base);\n    vec2 cone = vec2(sdCapsule(p-vec3(0,1.3-smoothstep(off,off+.8,p.y),0), vec3(0,-1,0), vec3(0,off,0), .5-(p.y-off)*.2),3.);\n    res = colMin(res, cone);\n    \n    vec2 washer = vec2(sdTorus(p-vec3(0,off-.2,0), vec2(.5,.1)),4.);\n    res = colMin(res, washer);\n    \n    vec2 screw = vec2(sdCylinder(p-vec3(.55,off-.3,0), vec3(0,.3,0), vec3(0,0,0), .05-pow(sin((off-p.y)*100.),2.)*.02),4.);\n    \n    res = colMin(res, screw);\n    vec2 screw2 = vec2(sdCylinder(p-vec3(.23,off-.3,.5), vec3(0,.3,0), vec3(0,0,0), .05-pow(sin((off-p.y)*100.),2.)*.02),4.);\n    \n    res = colMin(res, screw2);\n    p.xz *=Rot(iTime);\n    vec2 lightBase = vec2(dBox(p-vec3(0,off+.8,0), vec3(.2,.2,.2)),5.);\n    vec2 lightBaseM = vec2(dBox(p-vec3(0,off+.8,0), vec3(.5,.1,.1)),5.);\n    vec2 lightBaseM2 = vec2(dBox(p-vec3(0,off+.8,0), vec3(.1,.1,.5)),5.);\n    lightBase.x = min(lightBase.x,lightBaseM.x);\n    lightBase.x = min(lightBase.x,lightBaseM2.x);\n   \n    res = colMin(res, lightBase);\n    \n    vec2 light = vec2(sdCapsule(p-vec3(0,off+1.,0), vec3(0,0,0), vec3(0,.3,0), .05+(p.y-off)*.2),6.);\n    res = colMin(res, light);\n    //res = light;\n    return res;\n}\nvec2 RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist(p);\n        //move origin to new point\n        dO+=ds.x*.4;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy).x,\n         GetDist(p-e.yxy).x,\n         GetDist(p-e.yyx).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(4,5.,10);\n    \n    lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;\n    if(d < length(lightPos-p)){\n        diff *= .1;\n    }\n    \n    return diff;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nfloat DrawSquare (vec2 uv, float width, float height, float posX, float posY, float blur){\n    float w = length((uv.x + posX));\n    float h = length(uv.y + posY);\n    float col = smoothstep(width,width-blur, w);\n    col *= smoothstep(height,height-blur, h);\n    return col;\n}\nvec3 A (vec2 uv){\n    vec3 base =vec3(1)*DrawSquare (uv-vec2(0,0), .1-uv.y*.2, .2, 0., 0., .01);\n    vec3 mask =vec3(1)*DrawSquare (uv-vec2(0,.1), .05-uv.y*.2, .07, 0., 0., .01);\n    vec3 mask2 =vec3(1)*DrawSquare (uv-vec2(0,-.1), .05-uv.y*.2, .1, 0., 0., .01);\n    return base - mask - mask2;\n}\nvec3 X (vec2 uv){\n    vec3 slashR = vec3(1)*DrawSquare (uv-vec2(uv.y*.5,0), .04, .2, 0., 0., .01);\n    vec3 slashL = vec3(1)*DrawSquare (uv-vec2(-uv.y*.5,0), .04, .2, 0., 0., .01);\n    return slashR+slashL;\n}\nvec3 coneText(vec2 uv){\n    vec3 col = A(uv-vec2(-.3,0))+X(uv-vec2(0,0));\n    return col;\n}\nvec3 Render (inout vec3 ro, inout vec3 rd, inout float reflVal){\n//------------------\n    vec2 d = RayMarch(ro,rd);\n// position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n //get diffuse lighting\n    float diff = GetLight(p);\n    vec3 col = vec3(0);\n    col = vec3(diff);\n    \n    vec3 n = GetNormal(p);\n    vec3 r = reflect(rd, n);\n    vec3 refl = texture(iChannel0, r).rgb;\n    refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n    \n    if(d.y == 1.){\n        col *= vec3(0,.7,1);\n        col*=refl;\n        reflVal = .9;\n    }\n    else if(d.y==2.){\n       col *= vec3(1,0,0);\n       reflVal = 0.1;\n    }\n    else if(d.y==3.){\n        float off = pow(sin(iTime*2.),2.)*.5+1.;\n        vec2 uv = vec2(atan(p.x,p.z)/(3.14159),p.y-off);\n        uv.x-=.4;\n        uv.y-=.3;\n        col*=vec3(1,0,0);\n        col-= coneText(uv).rgb;\n        reflVal = 0.1;\n    }\n    else if(d.y==4.){\n      col*=vec3(1.);\n      reflVal=0.9;\n    }\n    else if(d.y==5.){\n      col*=vec3(1.);\n      reflVal=0.9;\n    }\n    else if(d.y==6.){\n      col=vec3(1.,1,0);\n      col.xy*=sin(iTime*3.)*.5+.5;\n      reflVal=0.9;\n    }\n    else{\n        col=texture(iChannel0, rd).rgb*.3;\n    }\n     ro = p+n*SURFACE_DIST*3.;\n     rd=r;\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n   \n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    vec3 ta = vec3( 0, 0., -3);\n    vec3 ro = ta + vec3( 4.5, 4.3, 4.5);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n//    vec3 ro = vec3(0,3,-5);\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    \n    \n    \n    float reflVal = 1.;\n    vec3 col = Render(ro,rd,reflVal);\n    vec3 bounce = reflVal*Render(ro,rd,reflVal);\n    col += bounce;\n    /*vec3 bounce2 = reflVal*Render(ro,rd,reflVal);\n    col += bounce2;*/\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}