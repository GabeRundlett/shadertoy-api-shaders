{
    "Shader": {
        "info": {
            "date": "1501600027",
            "description": "Some further extensions to the Let's Make A Ray Marcher example shader.",
            "flags": 0,
            "hasliked": 0,
            "id": "4dSfzt",
            "likes": 9,
            "name": "Let's Make - extensions",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 844
        },
        "renderpass": [
            {
                "code": "void Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\n\nfloat Sphere( vec3 centre, float radius, vec3 pos )\n{\n    return length(centre-pos)-radius;\n}\n\n// A more interesting SDF:\nfloat Superellipsoid( vec3 centre, float radius, float power, vec3 pos )\n{\n    pos = abs(pos-centre)/radius; // scale and sign-flip pos into a [0,1] range\n    pos = pow(pos,vec3(power)); // apply power before summing components\n    float d = dot(pos,vec3(1)); // add the components together\n\td = pow(d,1./power); // apply inverse power so SDF is well behaved\n    float fix = min(1.,.5+.5*(power-1.)); // corrective factor for lower powers, ensure gradient of SDF doesn't exceed 1.\n    return fix*(d-1.)*radius; // undo the scaling, to hit the desired radius\n}\n\n// pass vec2's so we can attach an object-ID to objects in the SDF\nvec2 Union( vec2 a, vec2 b )\n{\n    return a.x < b.x ? a : b;\n}\n\nvec2 Intersection( vec2 a, vec2 b )\n{\n    return a.x > b.x ? a : b;\n}\n\nvec2 Scene( vec3 pos )\n{\n\tvec2 angle = vec2(iTime,0);\n\tRotate(pos,angle);\n\n    float shapeIndex = 0.;\n    vec2 f = vec2( Sphere(vec3(0,1,-1),1.,pos), shapeIndex++ );\n    \n    // ripply sphere (*.8 to keep SDF gradient <= 1.0)\n    f = Union( f, vec2( Sphere(vec3(1,-1,-1),1.,pos)*.8 + sin(pos.y*20.+iTime*3.)*.03, shapeIndex++ ) );\n\n    f = Union( f, vec2( Superellipsoid(vec3(0,0,1),.7,1./(.5+.48*sin(iTime*1.3)),pos), shapeIndex++ ) );\n    \n    // cut a circular chunk out of the scene\n    f = Intersection( f, vec2( -Sphere(vec3(0,0,-.5),1.,pos), shapeIndex++ ) );\n    \n    // this sphere is combined after the cut-out sphere, so it doesn't get cut\n    f = Union( f, vec2( Sphere(vec3(-1,-1,-1),.8,pos), shapeIndex++ ) );\n\n\t// floor\n    f = Union( f, vec2( Sphere(vec3(0,-20,0),18.,pos), shapeIndex++ ) );\n    \n    return f;\n}\n\nfloat SDF( vec3 pos )\n{\n    return Scene(pos).x;\n}\n\nfloat GetShapeIndex( vec3 pos )\n{\n    return Scene(pos).y;\n}\n\nfloat ShadowMarch( vec3 pos, vec3 light )\n{\n    vec3 ray = normalize(light-pos);\n    float e = length(light-pos);\n    float t = .02; // step away from the surface\n    for ( int i=0; i < 200; i++ )\n    {\n        float h = SDF(pos+ray*t);\n        if ( h < .001 )\n        {\n            return 0.; // hit something\n        }\n        if ( t >= e )\n        {\n            break;\n        }\n        t += h;\n    }\n    return 1.; // didn't hit anything\n}\n\n// material parameters, per shape\nconst vec3 albedo[] = vec3[](\n    vec3(.03),\n    vec3(0,1,1),\n    vec3(0),\n    vec3(1,0,0),\n    vec3(0,0,1),\n    vec3(1)\n);\nconst vec3 fresnelColour[] = vec3[](\n    vec3(.0),\n    vec3(.004),\n    vec3(.98,.7,.1),\n    vec3(.0),\n    vec3(.004),\n    vec3(.0)\n);\nconst float roughness[] = float[](\n    .8f,\n    .0f,\n    .0f,\n    .9f,\n    .0f,\n    .9f\n);\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ray = normalize( vec3(\n\t\t\t\t(fragCoord-iResolution.xy*.5)/iResolution.x, // pixel pos on screen\n\t\t\t\t1 ) ); // place screen 1 unit in front of eye\n    vec3 pos = vec3(0,0,-8); // move eye 8 units back from scene\n\tvec2 angle = vec2(0,.3);\n\tif ( iMouse.z > .0 ) angle = (iMouse.xy/iResolution.xy-.5)*3.14;\n\tRotate(pos,angle);\n\tRotate(ray,angle);\n\n    fragColor = 4.*pow(texture(iChannel0,ray),vec4(2.2));\n    for ( int i=0; i < 100; i++ )\n    {\n        float h = SDF(pos);\n        if ( h < .01 )\n        {\n            fragColor = vec4(0);\n            break;\n        }\n        pos += ray*h;\n    }\n\n    if ( SDF(pos) < .01 )\n    {\n        vec3 normal;\n        normal.x = SDF(pos+vec3(.01,0,0)) - SDF(pos-vec3(.01,0,0));\n        normal.y = SDF(pos+vec3(0,.01,0)) - SDF(pos-vec3(0,.01,0));\n        normal.z = SDF(pos+vec3(0,0,.01)) - SDF(pos-vec3(0,0,.01));\n        normal = normalize(normal);\n\n        vec3 lightSource = vec3(4,4,-4);\n\t\tfloat light = max(.0,dot(normal,normalize(lightSource-pos)));\n        light *= ShadowMarch( pos, lightSource );\n\n        vec3 ambient = mix( vec3(.07), vec3(.05,.1,.15), normal.y*.5+.5 ); // looks better than a flat colour\n        vec3 lightCol = vec3(1.,.9,.8);\n        vec3 lighting = light*lightCol + ambient;\n\n        // material\n        int shapeIndex = int(GetShapeIndex(pos));\n        \n        fragColor.rgb = albedo[shapeIndex] * lighting;\n        \n        // specular highlight\n        \n        // reflection mapping\n        vec3 reflection = reflect(ray,normal);\n        vec3 refMap = 4.*pow(texture(iChannel0,reflection).rgb,vec3(2.2));\n        vec3 fresnel = mix( fresnelColour[shapeIndex], vec3(1.-roughness[shapeIndex]), pow(dot(normal,ray)+1.,5.) );\n        fragColor.rgb = mix( fragColor.rgb, refMap, fresnel );\n    }\n    \n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0/2.2) );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}