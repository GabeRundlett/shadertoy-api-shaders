{
    "Shader": {
        "info": {
            "date": "1538770801",
            "description": "With special relativity different observers will not agree about which events happened at the same timeâ€”even if you accelerate you may change your idea of simultaneity.\n\nArrows: thrust\nSpace: break\nD: toggle perspective\nS: toggle 3d\n\nMay not be correct.",
            "flags": 48,
            "hasliked": 0,
            "id": "ltcBzN",
            "likes": 5,
            "name": "Relative Simultaneity Sol System",
            "published": 3,
            "tags": [
                "relativity"
            ],
            "usePreview": 0,
            "username": "JeroenDStout",
            "viewed": 630
        },
        "renderpass": [
            {
                "code": "struct PlaneHit {\n    float dist;\n    vec3  localHit;\n    vec3  pos;\n    vec2  uv;\n};\n    \nstruct FieldRel {\n    float dist;\t\n    vec3  colour;\n};\n    \nstruct FieldHit {\n    vec3  pos;\n    float dist;\n    float hitCost;\n    vec3  colour;\n};\n\nPlaneHit intersectSimulPlane( in vec3 rflPos, in vec3 rflDir, in mat4 trIn, in mat4 trOut )\n{\n    PlaneHit hit;\n    \n    hit.pos = (trIn * vec4(rflPos, 1.)).xyz;\n    rflDir = (trIn * vec4(rflDir, 0.)).xyz;\n    \n    if (sign(rflDir.z) == sign(hit.pos.z)) {\n        hit.dist = 1e10;\n        return hit;\n    }\n    \n    hit.dist = hit.pos.z / -rflDir.z;\n    \n    hit.pos += rflDir * hit.dist;\n    hit.localHit = hit.pos;\n    \n    hit.pos = (trOut * vec4(hit.pos, 1.)).xyz;\n    hit.uv  = hit.pos.xy;\n\n    hit.dist = length(rflPos - hit.pos);\n    \n    return hit;\n}\n\nvec2 samplePlanetHelix( in vec3 rflPos, in PlanetData planet )\n{\n    vec3 p = rflPos.zyx;\n    \n    vec3 helixA = closestHelix(p, planet.orbitLength, planet.orbitDist);    \n    \n    vec3 p2 = p;\n    p2.yz -= helixA.yz;\n    \n    vec2 d;\n    d.x = length((p - helixA)) - planet.size;\n    d.y = 1e10;\n    \n    if (planet.moonCount == 0)\n        return d;\n    \n    vec3 helixB;\n    \n    helixB = closestHelix(p2, planet.moonA.x, planet.moonA.y);\n    helixB.yz += helixA.yz;\n    d.y = length((p - helixB)) - planet.moonA.z;\n    \n    if (planet.moonCount == 1)\n        return d;\n    \n    helixB = closestHelix(p2, planet.moonB.x, planet.moonB.y);\n    helixB.yz += helixA.yz;\n    d.y = min(d.y, length((p - helixB)) - planet.moonB.z);\n    \n    if (planet.moonCount == 2)\n        return d;\n    \n    helixB = closestHelix(p2, planet.moonC.x, planet.moonC.y);\n    helixB.yz += helixA.yz;\n    d.y = min(d.y, length((p - helixB)) - planet.moonC.z);\n    \n    return d;\n    \n    /* \n    vec3 p2 = p;\n    p2.yz -= helixA.yz;\n    //p2.yz += 1.;\n    \n    vec3 helixB = closestHelix(p2, 5.0, radius * 0.2);\n    helixB.xy /= 1.;\n    helixB.yz += helixA.yz;\n    \n    float d = min(length(p - helixA) - 0.05, length(p - helixB) - 0.05);\n    \n    vec3 hp = helixCoordinates(p, helixA, lead, radius);\n\tvec2 uv = vec2(hp.x, atan(hp.y, hp.z) / PI / 2.);\n*/\n}\n\nFieldRel sampleField( in vec3 rflPos )\n{\n    FieldRel rel;\n    \n    float distSun = length(rflPos.xy) - sunRadius;\n    rel.dist = distSun;\n    rel.colour = vec3(2., 1.9, 1.8) * 3.;\n    \n    for (int i = 0; i < _PLANET_COUNT; i++) {\n        vec2 dist = samplePlanetHelix(rflPos, planetData[i]);\n        if (dist.x < dist.y) {\n        \tif (dist.x < rel.dist) {\n        \t\trel.dist = dist.x;\n            \trel.colour = planetData[i].colour;\n            }\n        }\n        else {\n        \tif (dist.y < rel.dist) {\n        \t\trel.dist = dist.y;\n            \trel.colour = vec3(0.5);\n            }\n        }\n    }\n    \n    return rel;\n}\n\nvec3 sampleOrbits( in vec3 rflPos )\n{\n    float dist = 1e10;\n    vec3 colour = vec3(20., 19., 18.) * (1. / (1. + length(rflPos.xy)));\n    \n    float centDist = length(rflPos.xy);\n    \n    for (int i = 0; i < _PLANET_COUNT; i++) {\n        float nDist = abs(centDist - planetData[i].orbitDist);\n        colour += planetData[i].colour * (1. / (1. + nDist));\n    }\n    \n    return colour;\n}\n\nvec4 sampleShip( in vec2 rflPos, in vec2 ship, in vec4 mom )\n{\n    vec4 ret = vec4(0.);\n    \n    vec2 nMom = normalize(mom.zw);\n    \n    vec2 shipRel = rflPos - ship;\n    shipRel = vec2(dot(shipRel, nMom), dot(shipRel, vec2(nMom.y, -nMom.x)));\n    shipRel *= 0.05;\n    \n    if (shipRel.x > 2e0 || shipRel.x < -4e0) {\n        return vec4(0.);\n    }\n    if (0.2 - abs(shipRel.y) < abs(shipRel.x * 0.2)) {\n        return vec4(0.);\n    }\n    \n    ret = vec4(saturate(shipRel.x * 10.));\n    ret.xyz *= 0.2 * abs(shipRel.y);\n    \n    ret += vec4(saturate(-shipRel.x * 10.)) *\n             (0.5 + (sin(sin(iTime * 4.) + cos(iTime * 2.)))) * saturate(1. - length(mom.zw));\n    \n    return ret;\n}\n\nFieldHit hitField( in vec3 rflPos, in vec3 rflDir )\n{\n    FieldHit hit;\n    \n    hit.pos  = rflPos;\n    hit.dist = 1e10;\n    hit.hitCost = 0.;\n    \n    for (int i = 0; i < 16; i++) {\n        FieldRel rel = sampleField(hit.pos);\n        \n        if (rel.dist < 2e0) {\n            hit.dist = length(hit.pos - rflPos);\n            hit.colour = rel.colour;\n            return hit;\n        }\n        \n        hit.pos += rflDir * rel.dist * 0.9995;\n        hit.hitCost += 1.;\n    }\n    \n    return hit;\n}\n\nvoid scalePlanets(in float scaleA, in float scaleB)\n{\n    sunRadius = log(sunRadius * scaleA) * scaleB;\n    \n    for (int i = 0; i < _PLANET_COUNT; i++) {\n        planetData[i].size    = log(planetData[i].size * scaleA) * scaleB * .5;\n        planetData[i].orbitLength *= 4e0;\n        planetData[i].moonA.x *= 4e0;\n        planetData[i].moonA.y = log(planetData[i].moonA.y * scaleA) * 1.01e1 * scaleB;\n        planetData[i].moonA.z = log(planetData[i].moonA.z * scaleA * 2.) * .85 * scaleB;\n        planetData[i].moonB.x *= 4e0;\n        planetData[i].moonB.y = log(planetData[i].moonB.y * scaleA) * 1.01e1 * scaleB;\n        planetData[i].moonB.z = log(planetData[i].moonB.z * scaleA * 2.) * .5 * scaleB;\n        planetData[i].moonC.x *= 4e0;\n        planetData[i].moonC.y = log(planetData[i].moonC.y * scaleA) * 1.01e1 * scaleB;\n        planetData[i].moonC.z = log(planetData[i].moonC.z * scaleA * 2.) * .5 * scaleB;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 mouse = (-iResolution.xy + 2.0*iMouse.xy)/iResolution.y;\n\n    float timeScale = 1e0;\n    \n    bool cameraTrByPlane = texelFetch( iChannel3, ivec2(KEY_D,2),0 ).x != 0.;\n    \n    vec4 momDat = texelFetch( iChannel0, ivec2(0,0),0 );\n    vec4 posDat = texelFetch( iChannel0, ivec2(1,0),0 );\n    vec2 xyTranslate = vec2(posDat.x, posDat.y);\n    \n    float zoom = 2e-3;\n    //zoom *= exp(length(xyTranslate) * -2e-3);\n    zoom *= exp((-.2 - mouse.y) * 3.);\n    \n    float time      = -4.0e3 + posDat.z * timeScale;\n    \n    float camOrb = iMouse.x * 2e-2;\n    float camPitch = 1e-3 + exp(-0.5 + mouse.y * 0.4);\n    \n\tvec3 camPos = vec3(cos(camOrb) * cos(camPitch) / zoom, sin(camOrb) * cos(camPitch) / zoom, sin(camPitch) / zoom);\n    vec3 camTar = vec3(0., 0.,0.);\n    vec3 camUp = vec3(0,0,1);\n    \n    camPos.xy += xyTranslate;\n    camTar.xy += xyTranslate;\n    \n    mat3 camMat = calcLookAtMatrix(camPos, camTar, camUp);\n\n    float focalLength = 4.;\n    vec3 rayDir = normalize(camMat * vec3(p, focalLength));\n    vec3 rayPos = camPos + rayDir * 10.;\n    \n    vec2 relativisticSpeed = getShipRelSpeed(momDat.xy).xy;\n    float spaceSpeed = length(relativisticSpeed);\n    float angle = -atan(spaceSpeed);//spaceSpeed / sqrt(spaceSpeed*spaceSpeed + 1.);\n    \n    float relativisticScale = 1. / sqrt((1. + spaceSpeed*spaceSpeed) / (1. - spaceSpeed*spaceSpeed));\n    \n    mat4 angRot = rotationMatrix(vec3(0., 1., 0.), -angle);\n    \n    mat4 xyRot  = rotationMatrix(vec3(0., 0., 1.), atan(-relativisticSpeed.y, relativisticSpeed.x));\n    \n   // xyTranslate *= 0.;\n    \n    mat4 translate = mat4(  1, 0, 0, 0,\n                            0, 1, 0, 0,\n                            0, 0, 1, 0,\n                            xyTranslate.x, xyTranslate.y, 0, 1 ) * xyRot;\n\n    mat4 contTrIn =  translate *\n        mat4(  cos(angle) * relativisticScale, 0, sin(angle) * relativisticScale, 0,\n               0, 1, 0, 0,\n               sin(angle) * relativisticScale, 0, cos(angle) * relativisticScale, 0.,\n               0, 0, 0., 1 );// * angRot;\n     \n    contTrIn *= inverse(translate);\n    \n    mat4 contTrOut = inverse(contTrIn);\n    \n    if (cameraTrByPlane) {\n        rayDir = (contTrOut * vec4(rayDir, 0.)).xyz;    \n        rayPos = (contTrOut * vec4(rayPos, 1.)).xyz;\n    }\n    \n    PlaneHit plHit = intersectSimulPlane(rayPos, rayDir, contTrIn, contTrOut);\n    \n    scalePlanets(2.0, 3.0);\n    \n    float opacPotential = 0.5;\n    \n    if (plHit.dist < 1e10) {\n        vec2 effUv = plHit.uv / 10.;\n        \n        float c = mod(floor(effUv.x) + floor(effUv.y), 2.);\n        fragColor = vec4(c) * .05 + 0.2;\n        \n        opacPotential += saturate(c) * 0.3;\n        \n        c = mod(floor(effUv.x * .1) + floor(effUv.y * .1), 2.);\n        fragColor *= vec4(c) * .1 + .9;\n        \n        opacPotential += saturate(c) * 0.05;\n        \n        vec3 effPos = plHit.pos;\n        effPos.z *= timeScale;\n        effPos.z += time;\n        FieldRel rel = sampleField(effPos);\n        \n        if (rel.dist < 2e0) {\n            fragColor = 1. * vec4(rel.colour, 1.);\n            opacPotential = 0.1;\n            \n            vec3 norm = vec3(0., 0., (2. - rel.dist) * 1.5);\n            \n            if (max(abs(effPos.x), abs(effPos.y)) > 15.) {\n                FieldRel relX = sampleField(effPos + vec3(1., 0., 0.));\n                norm.x = relX.dist - rel.dist;\n                FieldRel relY = sampleField(effPos + vec3(0., 1., 0.));\n                norm.y = relY.dist - rel.dist;\n\n                norm = normalize(norm);\n                fragColor.xyz *= 0.85 + 0.65 * dot(norm, -normalize(vec3(effPos.xy, 0.)));\n            }\n        }\n        else {\n            vec3 orbit = sampleOrbits(effPos);\n            fragColor.xyz += orbit;\n        }\n        \n        fragColor *= 0.5 / (1. + length(effUv) * 0.01);\n        \n        vec4 sampleShip = sampleShip(effPos.xy, xyTranslate, momDat);\n        fragColor.xyz = mix(fragColor.xyz, sampleShip.xyz, sampleShip.w);\n        opacPotential = mix(opacPotential, 1., sampleShip.w);\n    }\n     \n    fragColor /= 1. / (1. + length(xyTranslate) * 0.0095);\n    \n    if (texelFetch( iChannel3, ivec2(KEY_S,2),0 ).x != 1.) {\n        vec3 effPos = rayPos;\n        effPos.z *= timeScale;\n        effPos.z += time;\n        rayDir.z *= timeScale;\n        rayDir = normalize(rayDir);\n        FieldHit fiHit = hitField(effPos + rayDir, rayDir);\n\n        if (fiHit.dist < 1e10) {\n            vec3 rHit = fiHit.pos;\n            float rDist = length((rHit - rayPos));\n\n            vec3 planeRel = (contTrOut * vec4(fiHit.pos, 1.)).xyz;\n\n            float mixture = 1.0 - saturate((plHit.pos.z - rHit.z + time) * 1e1) * opacPotential;\n            mixture *= 1. / (1. + abs(plHit.pos.y - fiHit.pos.y) * 0.001);\n\n            fiHit.colour *= 0.9 + 0.1 * floor(mod(fiHit.pos.z / timeScale, 2.));\n            fiHit.colour *= 0.8 + 0.2 * floor(mod(fiHit.pos.z / timeScale * 0.1, 2.));\n\n            fragColor = mix(fragColor, 4. * vec4(fiHit.colour, 1.) / (1. + fiHit.hitCost * 0.2), mixture);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 data = texture(iChannel0, uv);\n    \n    ivec2 pix = ivec2(fragCoord.xy);\n    \n    fragColor = data;\n    \n    if (pix.y == 0) {\n        if (pix.x == 0) { // Momentum\n            if (iTime < .2) {\n                fragColor.x = 0.;\n                fragColor.y = 0.;\n                fragColor.zw = vec2(-1., 0.);\n                return;\n            }\n            \n           //fragColor.x += 5. * iTimeDelta;\n            \n            vec2 acc = vec2(0.);\n            \n            acc.x += texelFetch( iChannel1, ivec2(KEY_LEFT,0),0 ).x;\n            acc.y -= texelFetch( iChannel1, ivec2(KEY_UP,0),0 ).x;\n            acc.x -= texelFetch( iChannel1, ivec2(KEY_RIGHT,0),0 ).x;\n            acc.y += texelFetch( iChannel1, ivec2(KEY_DOWN,0),0 ).x;\n            \n            acc = acc / max(1e-3, length(acc)) * 5. * iTimeDelta;\n            \n    \t\tfloat camOrb = iMouse.x * 2e-2;\n            \n            acc.xy = vec2( sin(camOrb) * acc.x + cos(camOrb) * acc.y,\n                          -cos(camOrb) * acc.x + sin(camOrb) * acc.y  );\n            \n            fragColor.xy += acc.xy;\n            \n            fragColor.zw = data.zw + acc.xy * 0.5 + sin(iTime) * 1e-5;\n            if (length(acc) > 0.) {\n            \tfragColor.zw /= max(length(fragColor.zw) * 2.5, 1e-3);\n            }\n            else {\n            \tfragColor.zw /= max(length(fragColor.zw), 1e-3);\n            }\n            \n            if (texelFetch( iChannel1, ivec2(KEY_SPACE,0),0 ).x != 0.) {\n                fragColor.xy *= exp(iTimeDelta * -.5);\n            }            \n        }\n        else if (pix.x == 1) { // Position\n            if (iTime < .2) {\n                fragColor.x = 149.6;\n                fragColor.y = 0.;\n                fragColor.z = 0.;\n                return;\n            }\n            \n            vec4 momDat = texelFetch( iChannel0, ivec2(0,0),0 );\n            vec4 curDat = texelFetch( iChannel0, ivec2(1,0),0 );\n            \n            vec3 relMom = getShipRelSpeed( momDat.xy );\n            \n            float timeFactor = min(0.1, iTimeDelta) / (relMom.z);\n            \n            fragColor.xy = curDat.xy + relMom.xy * LIGHT_SPEED * timeFactor;\n            fragColor.z  += timeFactor * LIGHT_SPEED;\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// 1 unit is 1,000,000 km\n#define LIGHT_SPEED 20.\n\nvec3 getShipRelSpeed( vec2 speed )\n{\n    float sSpL = length(speed);\n    float ang = atan(sSpL / LIGHT_SPEED);\n    return vec3( (speed.xy / max(1e-4, sSpL)) * sin(ang), cos(ang) );\n}\n\n#define PLANET_MERCURY 0\n#define PLANET_VENUS   1\n#define PLANET_EARTH   2\n#define PLANET_MARS    3\n#define PLANET_JUPITER 4\n#define PLANET_SATURN  5\n#define PLANET_URANUS  6\n#define PLANET_NEPTUNE 7\n#define PLANET_NINE    8\n#define _PLANET_COUNT  9\n\nstruct PlanetData {\n    float\torbitLength, orbitDist, size;\n    vec3    colour;\n    int     moonCount;\n    vec3    moonA, moonB, moonC;\n};\n\n#define NO_MOONS 0, vec3(0.), vec3(0.), vec3(0.)\n    \nfloat sunRadius = 696.342;\n    \nPlanetData planetData[9] = PlanetData[9](\n    \n// Mercury\n    PlanetData(   240.,   57.90,  2.44, vec3(0.5, 0.5, 0.5), NO_MOONS),\n    \n// Venus\n    PlanetData(   615.,  108.21,  6.05, vec3(0.5, 0.6, 0.5), NO_MOONS),\n    \n// Earth\n    PlanetData(  1000.,  149.60,  6.48, vec3(0.2, 0.3, 0.9),\n               \t\t\t\t\t\t\t\t1, vec3(75., .36, 1.7 ), vec3(0.), vec3(0.)),\n    \n// Mars\n    PlanetData(  1880.,  227.94,  3.40, vec3(0.9, 0.5, 0.2), NO_MOONS),\n    \n// Jupiter\n    PlanetData( 11862., 1178.41, 71.49, vec3(0.9, 0.5, 0.3), \n               \t\t\t\t\t\t\t\t3, vec3(1000.,  .60, 1.56 ),\n               \t\t\t\t\t\t\t       vec3(2000., 1.70, 2.68 ),\n                                               vec3(5000., 1.88, 2.81 ) ),\n    \n// Saturn\n    PlanetData( 29447., 1426.73, 60.27, vec3(0.7, 0.7, 0.3),\n               \t\t\t\t\t\t\t\t2, vec3(1.1, 1.00, 1.6 ),\n                                               vec3(45., 1.45, 5.5), vec3(0.)),\n    \n// Uranus\n    PlanetData( 84016., 2870.90, 25.57, vec3(0.5, 0.5, 0.8), \n               \t\t\t\t\t\t\t\t3, vec3(11.6, .26, .55 ),\n               \t\t\t\t\t\t\t       vec3(24.5, .43, .76 ),\n                                               vec3(37.8, .58, .72 ) ),\n    \n// Neptune\n    PlanetData(164791., 4498.25, 24.77, vec3(0.2, 0.2, 0.9),\n               \t\t\t\t\t\t\t\t1, vec3(-16.3, .35, 1.35 ), vec3(0.), vec3(0.)),\n    \n// Planet 9\n    PlanetData(   15e6,   105e3, 20.00, vec3(0.5, 0.5, 0.5), NO_MOONS)\n    \n);\n\n// --------------------------------------------------------\n// Utilities\n// --------------------------------------------------------\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_S     = 83;\nconst int KEY_D     = 68;\nconst int KEY_SPACE = 32;\n\n#define PI 3.14159265359\n\n#define saturate(x) clamp(x, 0., 1.)\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n    \n// Repeat space along one axis\nfloat pMod1(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\n// Cartesian to polar coordinates\nvec3 cartToPolar(vec3 p) {\n    float x = p.x; // distance from the plane it lies on\n    float a = atan(p.y, p.z); // angle around center\n    float r = length(p.zy); // distance from center\n    return vec3(x, a, r);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n// --------------------------------------------------------\n// Helix\n// --------------------------------------------------------\n\nvec2 closestPointOnRepeatedLine(vec2 line, vec2 point){\n\n    // Angle of the line\n    float a = atan(line.x, line.y);\n\n    // Rotate space so we can easily repeat along\n    // one dimension\n    pR(point, -a);\n\n    // Repeat to create parallel lines at the corners\n    // of the vec2(lead, radius) polar bounding area\n    float repeatSize = sin(a) * line.y;\n    float cell = pMod1(point.x, repeatSize);\n\n    // Rotate space back to where it was\n    pR(point, a);\n\n    // Closest point on a line\n    line = normalize(line);\n    float d = dot(point, line);\n    vec2 closest = line * d;\n\n    // Part 2 of the repeat, move the line along it's\n    // perpendicular by the repeat cell\n    vec2 perpendicular = vec2(line.y, -line.x);\n    closest += cell * repeatSize * perpendicular;\n\n    return closest;\n}\n\n// Polar to cartesian coordinates\nvec3 polarToCart(vec3 p) {\n    return vec3(\n        p.x,\n        sin(p.y) * p.z,\n        cos(p.y) * p.z\n    );\n}\n\n// Closest point on a helix\nvec3 closestHelix(vec3 p, float lead, float radius) {\n\n    p = cartToPolar(p);\n    p.y *= radius;\n\n    vec2 line = vec2(lead, radius * PI * 2.);\n    vec2 closest = closestPointOnRepeatedLine(line, p.xy);\n\n    closest.y /= radius;\n    vec3 closestCart = polarToCart(vec3(closest, radius));\n\n    return closestCart;\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}