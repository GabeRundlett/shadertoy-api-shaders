{
    "Shader": {
        "info": {
            "date": "1696034622",
            "description": "CSG Raytrace with unlimited layering (up to iteration limit) by reevaluating scene as needed and merging first two hits of each primitive.",
            "flags": 0,
            "hasliked": 0,
            "id": "mdGyWh",
            "likes": 12,
            "name": "CSG Iterative Raytracing",
            "published": 3,
            "tags": [
                "raytracing",
                "csg"
            ],
            "usePreview": 0,
            "username": "ttg",
            "viewed": 239
        },
        "renderpass": [
            {
                "code": "/*\n\nCSG Iterative Raytracing\nCopyright Theron Tarigo 2023\nhttps://www.shadertoy.com/view/mdGyWh\n\nI did not invent the techniques used here, they are free to use.\nHowever, the shader is for illustration and may not be copied.\n\nCSG Raytrace with unlimited layering (up to iteration limit) by reevaluating\nscene as needed and merging first two hits of each primitive.\n\n*/\n\n#define OUTPUT_EOTF EOTF_SRGB\n//#define OUTPUT_EOTF EOTF_POWSRGB\n\n#define ORI(R)   R[3].xyz\n#define DIR(R)   R[0].xyz\n\n// no intersection\n#define DIST_INF 1e10\n\nmat4 transl(vec3 t){ mat4 m=mat4(1.0);m[3]=vec4(-t,1.);return m;}\n\nmat4 rotx(float a){\n  vec2 s = vec2(cos(a),sin(a));\n  return mat4(   1,   0,   0, 0,\n                 0, s.x, s.y, 0,\n                 0,-s.y, s.x, 0,\n                 0,   0,   0, 1 );\n}\n\nmat4 roty(float a){\n  vec2 s = vec2(cos(a),sin(a));\n  return mat4( s.x,   0,-s.y, 0,\n                 0,   1,   0, 0,\n               s.y,   0, s.x, 0,\n                 0,   0,   0, 1 );\n}\n\nmat4 rotz(float a){\n  vec2 s = vec2(cos(a),sin(a));\n  return mat4( s.x, s.y,   0, 0,\n              -s.y, s.x,   0, 0,\n                 0,   0,   1, 0,\n                 0,   0,   0, 1 );\n}\n\nvec3 tex_blendrep(sampler2D samp, vec2 u) {\n  u = fract(u);\n  return mix(\n    mix(texsrgb(samp,.5*(u+vec2(1,1))),\n        texsrgb(samp,.5*(u+vec2(0,1))),\n        u.x),\n    mix(texsrgb(samp,.5*(u+vec2(1,0))),\n        texsrgb(samp,.5*(u+vec2(0,0))),\n        u.x),\n    u.y );\n}\n\nvec3 tex_triplan(sampler2D samp, vec3 pos, vec3 nor) {\n  // rotate to distract slightly from repeats on parallel axis-aligned planes\n  mat3 rot=mat3(rotx(.5)*roty(.2));\n  pos=rot*pos; nor=rot*nor;\n  nor = normalize(nor);\n  vec3 nor2 = nor*nor;\n  vec3 o=.5+.25*sign(nor);\n  return\n      nor2.x*tex_blendrep(samp,vec2(0,o.x)+pos.yz+vec2(1./6.,0))\n    + nor2.y*tex_blendrep(samp,vec2(0,o.y)+pos.zx+vec2(3./6.,0))\n    + nor2.z*tex_blendrep(samp,vec2(0,o.z)+pos.xy+vec2(5./6.,0)) ;\n}\n\nstruct seg {\n  vec4 n,f;\n  bool inside;\n};\n\nseg segc(bool inside, vec4 A, vec4 B) { return seg(A,B,inside); }\nseg segc(bool inside, vec3 Anorm, float Adist, vec3 Bnorm, float Bdist) {\n  return segc(inside,vec4(Anorm,Adist),vec4(Bnorm,Bdist));\n}\n\nseg surf_step(bool inside, vec4 A) {\n  return segc(inside,A,vec4(0));\n}\n\nseg surf_none() {\n  return surf_step(false,vec4(vec3(0),DIST_INF));\n}\n\nseg torus(mat4 ray, vec2 r) {\n  vec2 res;\n  float dist=0.;\n  for (int i=0;i<3;i++) {\n    // iq's torus should be exact, but seems to be troublesome numerically:\n    // pretend it's an estimator and solve in a few steps for slight improvement\n    res = iq_iTorus(ORI(ray)+DIR(ray)*dist,DIR(ray),r*(1.+.001*float(2-i)));\n    if (res.y<0.) return surf_none();\n    if(i==2) {\n      dist+=res.x;\n      break;\n    }\n    dist+=.5*res.x;\n  }\n  vec3 nn = iq_nTorus(ORI(ray)+DIR(ray)*dist,r);\n  if (res.y) nn=-nn;\n  nn=nn*mat3(ray);\n  return segc(bool(res.y),nn,dist,vec3(0),0.);\n}\n\nseg sphere(mat4 ray, float r) {\n  vec3 o = ORI(ray);\n  vec3 d = DIR(ray);\n  float a = dot(d,d);\n  float b = -dot(o,d)/a;\n  float c = (r*r-dot(o,o))/a;\n  float x = b*b+c;\n  if (x<=0.||b<0.&&c<0.) return surf_none();\n  float distfront = b-sqrt(x);\n  float distback = b+sqrt(x);\n  \n  vec3 normfront = (o+abs(distfront)*d)/r;\n  vec3 normback = -(o+distback*d)/r;\n  normfront=normfront*mat3(ray);\n  normback=normback*mat3(ray);\n  if(distfront>0.) return segc(false,normfront,distfront,normback,distback);\n  return segc(true,normback,distback,vec3(0),DIST_INF);\n}\n\nseg iq_box( mat4 ray, in vec3 rad ) \n{\n// Modified from https://www.shadertoy.com/view/ld23DV\n// Portions Copyright © 2014 Inigo Quilez\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Modifications by Theron Tarigo © 2023\n\n    vec3 rdd = DIR(ray).xyz;\n    vec3 roo = ORI(ray).xyz;\n    \n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return surf_none();\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    vec3 norback = -sign(rdd)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy);\n\n    float s = 1.;\n    if(all(lessThan(abs(roo),rad)))s=-1.;\n    \n    nor=nor*mat3(ray);\n    norback=norback*mat3(ray);\n    \n    if(s>0.) return segc(false,nor,tN,norback,tF);\n    return segc(true,norback,tF,vec3(0),DIST_INF);\n}\n\n\nseg intersect(seg A, seg B) {\n\n  // sort nears\n  if(A.n.w>B.n.w) { seg T=A;A=B;B=T; }\n\n  seg R=surf_none();\n  R.inside=A.inside&&B.inside;\n  // most conservative case: never step beyond first surface, whatever it is\n  R.n=A.n; R.f.w=0.;\n  // return R;\n  \n  // if one of the segs is a step, step to it\n  // should check for one finite when other is a step...\n  if( A.n.w>A.f.w || B.n.w>B.f.w ) return R;\n\n  if(A.inside&&B.inside) {R.f=A.f.w<B.f.w?A.f:B.f; }\n  if(!A.inside&&!B.inside) {R.n=B.n; R.f=A.f.w<B.f.w?A.f:B.f; }\n  if(A.inside&&!B.inside) {\n    if(A.f.w<B.f.w) {R.n=B.n;R.f.w=0.; }\n    else {R.n=A.n;R.f.w=0.; }\n  }\n  if(!A.inside&&B.inside) {\n    if(A.f.w<B.f.w) { R.n=A.n; R.f=A.f; R.f.w=0.; }\n    else { R.n=A.n; R.f=A.n; }\n  }\n  \n  return R;\n}\n\nseg neg (seg A) {\n  A.inside=!A.inside;\n  return A;\n}\n\nseg uniond (seg A, seg B) {\n  return neg(intersect(neg(A),neg(B)));\n}\n\nseg unionconvex (seg A, seg B) {\n// to be used only when each input is either a convex primitive or a result of unionconvex !\n  seg R = surf_none();\n  R.inside = A.inside||B.inside;\n  if(A.n.w>B.n.w) { seg T=A;A=B;B=T; }\n  R.n=A.n;\n  R.f=B.n.w>A.f.w?A.f:B.f;\n  return R;\n}\n\nseg makestep (seg A) {\n  A.f.w=0.;\n  return A;\n}\n\nseg _boundseg;\n#define BOUND(B,A) (_boundseg=(B),_boundseg.inside?intersect(A,_boundseg):makestep(_boundseg))\n#define GFNBOUND(B) seg _gfnboundseg=(B); if(!_gfnboundseg.inside)return makestep(_gfnboundseg);\n#define GFNBOUNDRET(A) return intersect(_gfnboundseg,A);\n\nseg dumbtorus(mat4 ray, vec2 rad) {\n  GFNBOUND(sphere(ray,rad.x+rad.y))\n  int n=24;\n  seg d = surf_none();\n  mat4 rot=rotz(_2pi/float(n));\n  for(int i=0;i<n;i++) {\n    seg d0 = sphere(transl(vec3(rad.x,0,0))*ray,rad.y);\n    //seg d0 = iq_box(rotx(.4)*transl(vec3(rad.x,0,0))*ray,vec3(rad.y));\n    d = unionconvex(d,d0);\n    ray = rot*ray;\n  }\n  GFNBOUNDRET(d)\n  //return d;\n}\n\n//#define torus dumbtorus\n\nseg geometry (mat4 ray) {\n\n  ORI(ray).z-=.5;\n\n    //return uniond(iq_box(ray,vec3(.2)),torus(ray,vec2(1,.5)));\n\n    //return (torus(ray,vec2(1,.5)));\n\n    seg d0=iq_box(ray,vec3(1.));\n    \n    //return d0;\n    \n    seg d1=sphere(transl(vec3(.6,-.6,.02))*ray,1.03);\n    seg d2=sphere(transl(vec3(.0,-.2,.02))*ray,1.03);\n    seg d3=neg(d1);\n    seg d4=neg(d2);\n    seg d5=intersect(d3,d4);\n    seg d6=neg(d5);\n    seg d7=neg(d6);\n    seg d8=intersect(d0,d7);\n    \n    seg d9=iq_box(transl(vec3(0,-.4,0))*ray,vec3(.2));\n    seg d10=uniond(d8,d9);\n    seg d11=iq_box(transl(vec3(-1.4,0,0))*ray,vec3(.02,1,1));\n    seg d12=uniond(d10,d11);\n\n    mat4 raytor = transl(vec3(0,0,-.5))*ray;\n    seg dtorus=torus(raytor,vec2(1,.5));\n    \n    d12 = intersect(d12,neg(dtorus));\n    d12 = intersect(d12,neg(iq_box(transl(vec3(0,0,.8))*ray,vec3(1.1,.5,.3))));\n    \n    //return torus(raytor,vec2(1,1.3));\n    \n    d12 = uniond(d12,\n      intersect(iq_box(transl(vec3(0,0,-1.5))*ray,vec3(vec2(2.02),1)),\n        intersect(torus(raytor,vec2(1,1.3)),\n                  neg(torus(raytor,vec2(1,1.))) ) )\n    );\n    \n    seg R=d12;\n\n    return (R);\n}\n\n#define NORTZERO\n#ifndef NORTZERO\nint rtzero;\n#else\nconst int rtzero=0;\n#endif\n\nconst int itermax = 200;\n\nvoid mainImageLRGB (out vec4 ImgOut, vec2 f) {\n#ifndef NORTZERO\n  rtzero = min(iFrame,0);\n#endif\n  ivec2 I = ivec2(f);\n  vec2 R = iResolution.xy;\n  vec2 uf=f;\n  vec2 uv = (uf+uf-R)/R.y;\n  vec2 m = (2.*iMouse.xy-R)/R.y;\n  if(iMouse==vec4(0)) m = vec2(-.5,-.3);\n\n  mat3 rdm;\n  rdm[0]=normalize(vec3(uv,-3.));\n  rdm[2]=normalize(cross(rdm[0],vec3(0,1,0)));\n  rdm[1]=cross(rdm[0],rdm[2]);\n  mat4 ray=mat4(rdm);\n  \n  ray=transl(vec3(0,0,-6))*ray;\n  ray=rotx(pi/2.)*ray;\n  ray=rotx(m.y*1.8)*ray;\n  ray=rotz(-m.x*2.)*ray;\n  \n  float distaccum=0.;\n  vec3 lastnorm=vec3(0);\n  vec3 hitnorm;\n  float hitdist;\n  for(int iter=0;iter<itermax;iter+=1+rtzero) {\n  \n    seg d = geometry(ray);\n\n    d.n.w=max(d.n.w,.0001); // should scale to current dist?\n    hitdist=(d.n.w);\n    bool surf=true;\n    hitnorm=d.n.xyz;\n  \n    if(d.n.w>d.f.w) {\n      surf=false;\n    }\n    if(d.inside) {\n      hitdist=0.;\n      hitnorm=vec3(0,0,0);\n      surf=true;\n    }\n\n    if(hitnorm==vec3(0))hitnorm=lastnorm;\n\n    if(hitdist>=DIST_INF) break;\n    ray[3].xyz+=ray[0].xyz*(hitdist)*(1.0001);\n    distaccum+=hitdist;\n    hitdist=distaccum;\n    if(!surf&&hitnorm!=vec3(0)) lastnorm=hitnorm;\n    if(hitnorm==vec3(0))hitnorm=lastnorm;\n    \n    if(surf) break;\n  }\n  \n  vec3 col=vec3(.5);\n  vec3 n=normalize(mat3(ray)*hitnorm);\n  vec3 p=ray[3].xyz;\n  if(hitdist<DIST_INF){\n    col=.7+.3*n;\n    col*=tex_triplan(iChannel1,p/4.,n);\n    p.z+=.9;\n    p.z*=4.;\n    col*=(1.-.8*exp(-.3*dot(p,p)));\n  }\n\n  ImgOut.rgb = col;\n}\n\nvoid mainImage (out vec4 Out, vec2 f) {\n  vec4 OutLRGB;\n  mainImageLRGB(OutLRGB,f);\n  output_eotf_select = OUTPUT_EOTF;\n  Out.rgb = output_oetf(OutLRGB.rgb);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define if(c) if(bool(c))\n\nconst float pi = acos(-1.);\nconst float _2pi = 2.*acos(-1.);\n\nvec3 srgb_oetf (vec3 c) {\n  return mix(12.92*c,1.055*pow(c,vec3(1./2.4))-.055,step(.0031308,c));\n}\n\nvec3 srgb_eotf (vec3 e) {\n  return mix(e/12.92,pow((e+.055)/1.055,vec3(2.4)),step(.04045,e));\n}\n\n#define EOTF_SRGB 0\n#define EOTF_POWSRGB 1\n\nint output_eotf_select = EOTF_SRGB;\n\nvec3 output_oetf (vec3 c) {\n  if(output_eotf_select==EOTF_SRGB)return srgb_oetf(c);\n  if(output_eotf_select==EOTF_POWSRGB)return pow(c,vec3(1./2.2));\n}\n\nvec3 output_eotf (vec3 c) {\n  if(output_eotf_select==EOTF_SRGB)return srgb_eotf(c);\n  if(output_eotf_select==EOTF_POWSRGB)return pow(c,vec3(2.2));\n}\n\n\nvec3 texsrgb(sampler2D samp, vec2 u) {\n  return srgb_eotf(texture(samp,u).rgb);\n}\n\n\n\nvec2 iq_iTorus( in vec3 ro, in vec3 rd, in vec2 tor )\n{\n// https://www.shadertoy.com/view/4sBGDy\n// Copyright © 2014 Inigo Quilez\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n    float po = 1.0;\n    \n    float Ra2 = tor.x*tor.x;\n    float ra2 = tor.y*tor.y;\n\t\n    float m = dot(ro,ro);\n    float n = dot(ro,rd);\n\n    // bounding sphere\n    {\n\tfloat h = n*n - m + (tor.x+tor.y)*(tor.x+tor.y);\n\tif( h<0.0 ) return vec2(-1.0);\n\t//float t = -n-sqrt(h); // could use this to compute intersections from ro+t*rd\n    }\n    \n\t// find quartic equation\n    float k = (m - ra2 - Ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*rd.z*rd.z + k;\n    float k1 = k*n + Ra2*ro.z*rd.z;\n    float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n    \n    bool inside=(k0<0.);\n\t\n    #if 1\n    // prevent |c1| from being too close to zero\n    if( abs(k3*(k3*k3 - k2) + k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n\t#endif\n\n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n\t\n    float h = R*R - Q*Q*Q;\n    float z = 0.0;\n    if( h < 0.0 )\n    {\n    \t// 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos( acos(R/(sQ*Q)) / 3.0 );\n    }\n    else\n    {\n        // 2 intersections\n        float sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );\n        z = sign(R)*abs( sQ + Q/sQ );\n    }\t\t\n    z = c2 - z;\n\t\n    float d1 = z   - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    if( abs(d1) < 1.0e-4 )\n    {\n        if( d2 < 0.0 ) return vec2(-1.0);\n        d2 = sqrt(d2);\n    }\n    else\n    {\n        if( d1 < 0.0 ) return vec2(-1.0);\n        d1 = sqrt( d1/2.0 );\n        d2 = c1/d1;\n    }\n\n    //----------------------------------\n\t\n    float result = 1e20;\n\n    h = d1*d1 - z + d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = -d1 - h - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -d1 + h - k3; t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=t1; \n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    h = d1*d1 - z - d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = d1 - h - k3;  t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = d1 + h - k3;  t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=min(result,t1);\n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    return vec2(result,inside);\n}\n\n// df(x)/dx\nvec3 iq_nTorus( in vec3 pos, vec2 tor )\n{\n// https://www.shadertoy.com/view/4sBGDy\n// Copyright © 2014 Inigo Quilez\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\treturn normalize( pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}